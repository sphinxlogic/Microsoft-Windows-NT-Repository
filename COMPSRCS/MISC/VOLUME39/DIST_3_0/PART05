Newsgroups: comp.sources.misc
From: Raphael Manfredi <ram@acri.fr>
Subject: v39i009:  dist-3.0 - Configure script generator and related tools, Part05/28
Message-ID: <1993Aug18.183901.17010@sparky.sterling.com>
X-Md4-Signature: 93c4173cd0bd60220b7ba27703f195a3
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Advanced Computer Research Institute, Lyon, France.
Date: Wed, 18 Aug 1993 18:39:01 GMT
Approved: kent@sparky.sterling.com

Submitted-by: Raphael Manfredi <ram@acri.fr>
Posting-number: Volume 39, Issue 9
Archive-name: dist-3.0/part05
Environment: UNIX, Perl, RCS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  bin/perload mcon/U/i_pwd.U mcon/pl/lint.pl
# Wrapped by ram@soft208 on Wed Aug 18 14:42:19 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 5 (of 28)."'
if test -f 'bin/perload' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bin/perload'\"
else
  echo shar: Extracting \"'bin/perload'\" \(20820 characters\)
  sed "s/^X//" >'bin/perload' <<'END_OF_FILE'
X: # feed this into perl
X'/bin/true' && eval 'exec perl -S $0 "$@"'
X	if $running_under_some_shell;
X'di';
X'ig00';
X
X#
X# This perl script is its own manual page [generated by wrapman]
X#
X
X# $Id: perload,v 3.0 1993/08/18 12:04:06 ram Exp $
X#
X#  Copyright (c) 1991-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic Licence,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic Licence; a copy of which may be found at the root
X#  of the source tree for dist 3.0.
X#
X# $Log: perload,v $
X# Revision 3.0  1993/08/18  12:04:06  ram
X# Baseline for dist 3.0 netwide release.
X#
X
X# Replace each function definition in a loading section by two stubs and
X# reject the definition into the DATA part of the script if in a dataload
X# section or into a FILE if in an autoload section.
X
X$in_load = 0;					# In a loading section
X$autoload = '';					# Name of autoloaded file
X$has_invocation_stub = 0;		# True if we detect a #! stub
X$current_package = 'main';		# Current package
X$init_emitted = 0;				# True when dataloading stamp was emitted
X$in_function = 0;
X
Xrequire 'getopt.pl';
X&Getopt;
X
Xwhile (<>) {
X	if ($. == 1 && /^(:|#).*perl/) {	# Invocation stub
X		$has_invocation_stub = 1;
X		print;
X		next;
X	}
X	if ($. <= 3 && $has_invocation_stub) {
X		print;
X		next;
X	}
X	if (/^\s*$/) {
X		&flush_comment;
X		print unless $in_function;
X		print if $in_function && !$in_load;
X		if ($in_function && $in_load) {
X			push(@Data, "\n") unless $autoload;
X			$Auto{$autoload} .= "\n" if $autoload;
X		}
X		next;
X	}
X	if (/^\s*;?#/) {
X		if (/#\s*perload on/i) {		# Enter a loading section
X			print unless /:$/;
X			$in_load = 1;
X			next;
X		}
X		if (/#\s*perload off/i) {		# End a loading section
X			print unless /:$/;
X			$in_load = 0;
X			next;
X		}
X		if (/#\s*autoload (\S+)/i) {	# Enter autoloading section
X			print unless /:$/;
X			push(@autoload, $autoload);	# Directives may be nested
X			$autoload = $1;
X			$in_load += 2;
X			next;
X		}
X		if (/#\s*offload/i) {			# End autoloading section
X			print unless /:$/;
X			$autoload = pop(@autoload);	# Revert to previously active file
X			$in_load -= 2;
X			next;
X		}
X		&emit_init unless $init_emitted;
X		push(@Comment, $_) unless $in_function;
X		print if $in_function && !$in_load;
X		next unless $in_function;
X		push(@Data, $_) unless $autoload;
X		$Auto{$autoload} .= $_ if $autoload;
X		next;
X	}
X	&emit_init unless $init_emitted;
X	/^package (\S+)\s*;/ && ($current_package = $1);
X	unless ($in_load) {
X		&flush_comment;
X		print;
X		next;
X	}
X	# We are in a loading section
X	if (/^sub\s+([\w']+)\s*\{(.*)/) {
X		die "line $.: function $1 defined within another function.\n"
X			if $in_function;
X		# Silently ignore one-line functions
X		if (/\}/) {
X			&flush_comment;
X			print;
X			next;
X		}
X		$comment = $2;
X		$in_function = 1;
X		$function = $1;
X		($fn_package, $fn_basename) = $function =~ /^(\w+)'(\w+)/;
X		unless ($fn_package) {
X			$fn_package = $current_package;
X			$fn_basename = $function;
X		}
X		# Keep leading function comment
X		foreach (@Comment) {
X			push(@Data, $_) unless $autoload;
X			$Auto{$autoload} .= $_ if $autoload;
X		}
X		@Comment = ();
X		# Change package context for correct compilation: the name is visible
X		# within the original function package while the body of the function
X		# is compiled within the current package.
X		$declaration = "sub $fn_package" . "'load_$fn_basename {$comment\n";
X		$package_context = "\tpackage $current_package;\n";
X		if ($autoload) {
X			$Auto{$autoload} .= $declaration . $package_context;
X		} else {
X			push(@Data, $declaration, $package_context);
X		}
X		# Emit stubs
X		print "sub $fn_package", "'$fn_basename";
X		print " { &auto_$fn_package", "'$fn_basename; }\n";
X		print "sub auto_$fn_package", "'$fn_basename { ";
X		print '&main\'dataload' unless $autoload;
X		print '&main\'autoload(' . "'$autoload'" . ', @_)' if $autoload;
X		print "; }\n";
X		next;
X	}
X	unless ($in_function) {
X		&flush_comment;
X		print;
X		next;
X	}
X	# We are in a loading section and inside a function body
X	push(@Data, $_) unless $autoload;
X	$Auto{$autoload} .= $_ if $autoload;
X	$in_function = 0 if /^\}/;
X	if (/^\}/) {
X		push(@Data, "\n") unless $autoload;
X		$Auto{$autoload} .= "\n" if $autoload;
X	}
X}
X
X@auto = keys %Auto;
Xif (@auto > 0) {
X	print &q(<<'EOC');
X:# Load the calling function from file and call it. This function is called
X:# only once per file to be loaded.
X:sub main'autoload {
X:	local($__file__) = shift(@_);
X:	local($__packname__) = (caller(1))[3];
X:	local($__rpackname__) = $__packname__;
X:	local($__saved__) = $@;
X:	$__rpackname__ =~ s/^auto_//;
X:	&perload'load_from_file($__file__);
X:	$__rpackname__ =~ s/'/'load_/;
X:	$@ = $__saved__;		# Restore value $@ had on entrance
X:	&$__rpackname__(@_);	# Call newly loaded function
X:}
X:
X:# Load file and compile it, substituing the second stub function with the
X:# loaded ones. Location of the file uses the @AUTO array.
X:sub perload'load_from_file {
X:	package perload;
X:	local($file) = @_;				# File to be loaded
X:	local($body) = ' ' x 1024;		# Pre-extent
X:	local($load) = ' ' x 256;		# Loading operations
X:	# Avoid side effects by protecting special variables which will be
X:	# changed by the autoloading operation.
X:	local($., $_, $@);
X:	$body = '';
X:	$load = '';
X:	&init_auto unless defined(@'AUTO);	# Make sure we have a suitable @AUTO
X:	&locate_file unless -f "$file";		# Locate file if relative path
X:	open(FILE, $file) ||
X:		die "Can't load $'__rpackname__ from $file: $!\n";
X:	while (<FILE>) {
X:		$load .= '*auto_' . $1 . '\'' . $2 . '= *' . $1 . '\'' . "load_$2;\n"
X:			if (/^sub\s+(\w+)'load_(\w+)\s*\{/);
X:		$body .= $_;
X:	}
X:	close FILE;
XEOC
X	if ($opt_t) {
X		print &q(<<'EOC');
X:	# Untaint body when running setuid
X:	$body =~ /^([^\0]*)/;
X:	# No need to untaint $load, as it was built using trusted variables
X:	eval $1 . $load;
XEOC
X	} else {
X		print &q(<<'EOC');
X:	eval $body . $load;
XEOC
X	}
X	print &q(<<'EOC');
X:	chop($@) && die "$@, while parsing code of $file.\n";
X:}
X:
X:# Initialize the @AUTO array. Attempt defining it by using the AUTOLIB
X:# environment variable if set, otherwise look in auto/ first, then in the
X:# current directory.
X:sub perload'init_auto {
X:	if (defined $ENV{'AUTOLIB'} && $ENV{'AUTOLIB'}) {
X:		@AUTO = split(':', $ENV{'AUTOLIB'});
X:	} else {
X:		@AUTO = ('auto', '.');
X:	}
X:}
X:
X:# Locate to-be-loaded file held in $file by looking through the @AUTO array.
X:# This variable, defined in 'load_from_file', is modified as a side effect.
X:sub perload'locate_file {
X:	package perload;
X:	local($fullpath);
X:	foreach $dir (@'AUTO) {
X:		$fullpath = $dir . '/' . $file;
X:		last if -f "$fullpath";
X:		$fullpath = '';
X:	}
X:	$file = $fullpath if $fullpath;		# Update var from 'load_from_file'
X:}
X:
XEOC
X}
X
Xif (@Data > 0) {
X	print &q(<<'EOC');
X:# Load the calling function from DATA segment and call it. This function is
X:# called only once per routine to be loaded.
X:sub main'dataload {
X:	local($__packname__) = (caller(1))[3];
X:	local($__rpackname__) = $__packname__;
X:	local($__at__) = $@;
X:	$__rpackname__ =~ s/^auto_//;
X:	&perload'load_from_data($__rpackname__);
X:	local($__fun__) = "$__rpackname__";
X:	$__fun__ =~ s/'/'load_/;
X:	eval "*$__packname__ = *$__fun__;";	# Change symbol table entry
X:	die $@ if $@;		# Should not happen
X:	$@ = $__at__;		# Restore value $@ had on entrance
X:	&$__fun__;			# Call newly loaded function
X:}
X:
X:# Load function name given as argument, fatal error if not existent
X:sub perload'load_from_data {
X:	package perload;
X:	local($pos) = $Datapos{$_[0]};			# Offset within DATA
X:	# Avoid side effects by protecting special variables which will be changed
X:	# by the dataloading operation.
X:	local($., $_, $@);
X:	$pos = &fetch_function_code unless $pos;
X:	die "Function $_[0] not found in data section.\n" unless $pos;
X:	die "Cannot seek to $pos into data section.\n"
X:		unless seek(main'DATA, $pos, 0);
X:	local($/) = "\n}";
X:	local($body) = scalar(<main'DATA>);
X:	local($*) = 1;
X:	die "End of file found while loading $_[0].\n" unless $body =~ /^\}$/;
XEOC
X	if ($opt_t) {
X		print &q(<<'EOC');
X:	# Untaint body when running setuid
X:	$body =~ /^([^\0]*)/;
X:	# Now we may safely eval it without getting an insecure dependency
X:	eval $1;		# Load function into perl space
XEOC
X	} else {
X		print &q(<<'EOC');
X:	eval $body;		# Load function into perl space
XEOC
X	}
X	print &q(<<'EOC');
X:	chop($@) && die "$@, while parsing code of $_[0].\n";
X:}
X:
XEOC
X	print &q(<<'EOC') unless $opt_o;
X:# Parse text after the END token and record defined loadable functions (i.e.
X:# those whose name starts with load_) into the %Datapos array. Such function
X:# definitions must be left adjusted. Stop as soon as the function we want
X:# has been found.
X:sub perload'fetch_function_code {
X:	package perload;
X:	local($pos) = tell main'DATA;
X:	local($in_function) = 0;
X:	local($func_name);
X:	local($., $_);
X:	while (<main'DATA>) {
X:		if (/^sub\s+(\w+)'load_(\w+)\s*\{/) {
X:			die "DATA line $.: function $1'$2 defined within $func_name.\n"
X:				if $in_function;
X:			$func_name = $1 . '\'' . $2;
X:			$Datapos{$func_name} = $pos;
X:			$in_function = 1;
X:			next;
X:		}
X:		$in_function = 0 if /^\}/;
X:		next if $in_function;
X:		return $pos if $func_name eq $_[0];
X:		$pos = tell main'DATA;
X:	}
X:	0;		# Function not found
X:}
X:
XEOC
X	print &q(<<'EOC') if $opt_o;
X:# This function is called only once, and fills in the %Datapos array with
X:# the offset of each of the dataloaded routines held in the data section.
X:sub perload'fetch_function_code {
X:	package perload;
X:	local($start) = 0;
X:	local($., $_);
X:	while (<main'DATA>) {			# First move to start of offset table
X:		next if /^#/;
X:		last if /^$/ && ++$start > 2;	# Skip two blank line after end token
X:	}
X:	$start = tell(main'DATA);		# Offsets in table are relative to here
X:	local($key, $value);
X:	while (<main'DATA>) {			# Load the offset table
X:		last if /^$/;				# Ends with a single blank line
X:		($key, $value) = split(' ');
X:		$Datapos{$key} = $value + $start;
X:	}
X:	$Datapos{$_[0]};		# All that pain to get this offset...
X:}
X:
XEOC
X	print &q(<<'EOC');
X:#
X:# The perl compiler stops here.
X:#
X:
X:__END__
X:
X:#
X:# Beyond this point lie functions we may never compile.
X:#
X:
XEOC
X	# Option -o directs us to optimize the function location by emitting an
X	# offset table, which lists all the position within DATA for each possible
X	# dataloaded routine.
X	if ($opt_o) {
X		print &q(<<'EOC');
X:#
X:# DO NOT CHANGE A IOTA BEYOND THIS COMMENT!
X:# The following table lists offsets of functions within the data section.
X:# Should modifications be needed, change original code and rerun perload
X:# with the -o option to regenerate a proper offset table.
X:#
X:
XEOC
X		$trailing_message = &q(<<'EOC');
X:
X:#
X:# End of offset table and beginning of dataloading section.
X:#
X:
XEOC
X		$pos = 0;			# Offset relative to this point (start of table)
X		foreach (@Data) {
X			$Datapos{"$1\'$2"} = $pos - $now
X				if /^sub\s+(\w+)'load_(\w+)\s*\{/;	# } for vi
X			$pos += length;
X		}
X		@poskeys = keys %Datapos;	# Array of routine names (fully qualified)
X
X		# Write out a formatted table, each entry stored on $entry bytes and
X		# formatted with the $format string.
X		($entry, $format) = &get_format(*poskeys);
X
X		# The total size occupied by the table is the size of one item times
X		# the number of items plus the final trailing message at the end of
X		# the table.
X		$table_size = $entry * @poskeys + length($trailing_message);
X
X		# Output formatted table
X		foreach (sort @poskeys) {
X			printf($format, $_, $table_size + $Datapos{$_});
X		}
X		print $trailing_message;
X	}
X
X	# Output code for each dataloaded function
X	foreach (@Data) {
X		print;
X	}
X	print &q(<<'EOC');
X:#
X:# End of dataloading section.
X:#
X:
XEOC
X}
X
Xif (@auto > 0) {
X	mkdir('auto',0755) unless -d 'auto';
X	foreach $file (@auto) {
X		unless (open(AUTO, ">auto/$file")) {
X			warn "Can't create auto/$file: $!\n";
X			next;
X		}
X		print AUTO &q(<<'EOC');
X:# This file was generated by perload
X:
XEOC
X		print AUTO $Auto{$file};
X		close AUTO;
X	}
X}
X
X# Compute optimum format for routine offset table, returning both the size of
X# each entry and the formating string for printf.
Xsub get_format {
X	local(*names) = @_;
X	local($name_len) = 0;
X	local($max_len) = 0;
X	foreach (@names) {
X		$name_len = length;
X		$max_len = $name_len if $name_len > $max_len;
X	}
X	# The size of each entry (preceded by one tab, followed by 12 chars)
X	$name_len = $max_len + 1 + 12;
X	($name_len, "\t%${max_len}s %10d\n");
X}
X
Xsub emit_init {
X	print &q(<<'EOC');
X:#
X:# This perl program uses dynamic loading [generated by perload]
X:#
X:
XEOC
X	$init_emitted = 1;
X}
X
Xsub flush_comment {
X	print @Comment if @Comment > 0;
X	@Comment = ();
X}
X
Xsub q {
X	local($_) = @_;
X	local($*) = 1;
X	s/^://g;
X	$_;
X}
X
X#
X# These next few lines are legal in both perl and nroff.
X#
X
X.00;		# finish .ig
X 
X'di			\" finish diversion--previous line must be blank
X.nr nl 0-1	\" fake up transition to first page again
X.nr % 0		\" start at page 1
X'; __END__	\" the perl compiler stops here
X
X'''
X''' From here on it's a standard manual page.
X'''
X
X.TH PERLOAD 1 "June 20, 1992"
X.AT 3
X.SH NAME
Xperload \- builds up autoloaded and dataloaded perl scripts
X.SH SYNOPSIS
X.B perload
X[ \fB\-ot\fR ]
X[ \fIfile\fR ]
X.SH DESCRIPTION
X.I Perload
Xtakes a perl script as argument (or from stdin if no argument is supplied)
Xand prints out on stdout an equivalent script set-up to perform autoloading
Xor dataloading. The translation is directed by special comments within the
Xoriginal script. Using dynamic loading can drastically improve start-up
Xperformances, both in time and in memory, as perl does not need to compile
Xthe whole script nor store its whole compiled form in memory.
X.PP
X.I Autoloading
Xdelays compilation of some functions until they are needed. The code for these
Xfunctions is loaded dynamically at run-time. The atomicity of loading is a
Xfile, which means that putting more than one function into a file will cause
Xall these functions to be loaded and compiled as soon as one among them is
Xneeded.
X.PP
X.I Dataloading
Xis a form of autoloading where no extra file are needed. The script carries
Xall the functions whose compilation is to be delayed in its data segment
X(in the \fIperl\fR sense, i.e. they are accessible via the DATA filehandle).
XThe scripts parses the data segment and extracts only the code for the needed
Xsubroutine, which means granularity is better than with autloading.
X.PP
XIt is possible for a single script to use both autoloading and dataloading at
Xthe same time. However, it should be noted that a script using only dataloading
Xis self contained and can be moved or shared accross different platforms without
Xfear. On the contrary, a script using only autoloading relies on some externally
Xprovided files. Sharing this script among different platforms requires sharing
Xof these external files. The script itself cannot be redistributed without
Xalso giving the extra files holding the autoloaded functions.
X.PP
XThe major drawback with dataloading is that the DATA filehandle cannot be used
Xfor anything else and may result in code duplication when two scripts could
Xshare the same pieces of code. Autoloading appears as the perfect solution in
Xthis case since two scripts may freely share the same functions without
Xactually duplicating them on the disk (hence saving some precious disk blocks
X:-).
X.SH CRITERIA
XFunctions to be dataloaded or autoloaded must meet the following layout
Xcriteria:
X.TP 5
X\-
XThey must not be one-line functions like \fIsub sorter { $a <=> $b }\fR.
XThose functions are simply output verbatim, as they are already so
Xsmall that it would not be worth to dynamically load them,
X.TP
X\-
XThe first line must be of the form \fIsub routine_name {\fR, with an optional
Xcomment allowed after the '{'.
X.TP
X\-
XThe function definition must end with a single '}' character left aligned.
X.TP
X\-
XPackage directives outside any function must be left aligned.
X.PP
XAll the above restrictions should not be source of a problem if "standard"
Xwriting style is used. There are also some name restrictions: the package
Xname \fIperload\fR is reserved, as is the \fI@AUTO\fR array when autoloading
Xis used. Packages must not start with \fIauto_\fR, as this is prepended to
Xuser's package names when building the stubs. Furthermore, the subroutines
Xnames \fImain'autoload\fR and
X\fImain'dataload\fR must not be used by the original script. Again, these
Xshould not cause any grief.
X.SH DIRECTIVES
XThe translation performed by
X.I Perload
Xis driven by some special comment directives placed directly within the code.
XEnding those directives with a ':' character will actually prevent them from
Xbeing output into the produced script. Case is irrelevant for all the directives
Xand the comment need not be left-aligned, although it must be the first
Xnon-space item on the line.
X.PP
XThe following directives are available:
X.TP 10
X# Perload ON
XTurns on the \fIperload\fR processing. Any function definition which meets
Xthe criteria listed in the previous section will be replaced by two stubs and
Xits actual definition will be rejected into the data segment (default) or a
Xfile when inside an autoloading section.
X.TP
X# Perload OFF
XTurns off any processing. The script is written as-is on the standard output.
X.TP
X# Autoload \fIpath\fR
XRequests autoloading from file \fIpath\fR, which may be an absolute path or
Xa relative path. The file will be located at run-time using the @AUTO array
Xif a non-absolute path is supplied or if the file does not exist as listed.
XAutoloading directives may be nested.
X.TP
X# Offload \fIpath\fR
XThe argument is not required. The directive ends the previous autoloading
Xdirective (the inmost one). This does not turn off the \fIperload\fR processing
Xthough. The \fIpath\fR name is optional here (in fact, it has only a comment
Xvalue).
X.SH OPTIONS
XPerload accepts only two options. Using \fB\-o\fR is meaningful only when
Xdataloading is used. It outputs an offset table which lists the relative
Xoffset of the dataloaded functions within the data section. This will spare
Xperl the run-time parsing needed to locate the function, and results in an good
Xspeed gain. However, it has one major drawback: it prevents people from
Xactually modifying the source beyond the start of the table. But anything
Xbefore can be freely edited, which is particulary useful when tailoring the
Xscript.
X.PP
XThis option should not be used when editing of functions within the data
Xsection is necessary for whatever reason. When \fB\-o\fR is used, any
Xchange in the dataloaded function must be committed by re-running perload
Xon the original script.
X.PP
XThe other option \fB\-t\fR is to be used when producing a script which is
Xgoing to run setuid. The body of the loaded function is untainted before being
Xfed to eval, which slightly slows down loading (the first time the function is
Xcalled), but avoids either an insecure dependency report or weird warnings from
Xtaintperl stating something is wrong (which is the behaviour with 4.0 PL35).
X.SH FILES
X.TP 10
Xauto
Xthe subdirectory where all produced autoloaded files are written.
X.SH ENVIRONMENT
XNo environment variables are used by \fIperload\fR. However, the autoloaded
Xversion of the script pays attention to the \fIAUTOLIB\fR variable as a colon
Xseparated set of directories where the to-be-loaded files are to be found
Xwhen a non-absolute path was specified. If the \fIAUTOLIB\fR variable is not
Xset, the default value 'auto:.' is used (i.e. look first in the auto/
Xsubdirectory, then in the current directory.
X.SH CAVEAT
XSpecial care is required when using an autoloading script, especially when
Xexecuted by the super-user: it would be very easy for someone to leave a
Xspecial version of a routine to be loaded, in the hope the super-user (or
Xanother suitable target) executes the autoloaded version of the script with
Xsome \fIad hoc\fR changes...
X.PP
XThe directory holding the to-be-loaded files should therefore be protected
Xagainst unauthorized access, and no file should have write permission on them.
XThe directory itself should not be world-writable either, or someone might
Xsubstitute his own version.
XIt should also be considered wise to manually set the @AUTO variable to a
Xsuitable value within the script itself.
X.PP
XThe \fB\-o\fR option uses \fIperl\fR's special variable \fI$/\fR with a
Xmulti-character value. I suspect this did not work with versions of \fIperl\fR
Xprior to 4.0, so any script using this optimized form of dataloading will not
Xbe 100% backward compatible.
X.SH AUTHOR
XRaphael Manfredi <ram@acri.fr>
X.SH CREDITS
XValuable input came from Wayne H. Scott <wscott@ecn.purdue.edu>. He is
Xmerely the author of the optimizing offset table (\fB\-o\fR option).
X.PP
X.I Perload
Xis based on an article from Tom Christiansen <tchrist@convex.com>,
X.I Autoloading in Perl,
Xexplaining the concept of dataloading and giving a basic implementation.
X.SH "SEE ALSO"
Xperl(1).
END_OF_FILE
  if test 20820 -ne `wc -c <'bin/perload'`; then
    echo shar: \"'bin/perload'\" unpacked with wrong size!
  fi
  chmod +x 'bin/perload'
  # end of 'bin/perload'
fi
if test -f 'mcon/U/i_pwd.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/i_pwd.U'\"
else
  echo shar: Extracting \"'mcon/U/i_pwd.U'\" \(3671 characters\)
  sed "s/^X//" >'mcon/U/i_pwd.U' <<'END_OF_FILE'
X?RCS: $Id: i_pwd.U,v 3.0 1993/08/18 12:08:25 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: i_pwd.U,v $
X?RCS: Revision 3.0  1993/08/18  12:08:25  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X:
X?X: This unit looks wether there is a pwd system or not
X?X:
X?MAKE:i_pwd d_pwquota d_pwage d_pwchange d_pwclass d_pwexpire d_pwcomment: \
X	test contains rm cppstdin cppflags Findhdr
X?MAKE:	-pick add $@ %<
X?S:i_pwd:
X?S:	This variable conditionally defines I_PWD, which indicates
X?S:	to the C program that it should include <pwd.h>.
X?S:.
X?S:d_pwquota:
X?S:	This varaible conditionally defines PWQUOTA, which indicates
X?S:	that struct passwd contains pw_quota.
X?S:.
X?S:d_pwage:
X?S:	This varaible conditionally defines PWAGE, which indicates
X?S:	that struct passwd contains pw_age.
X?S:.
X?S:d_pwchange:
X?S:	This varaible conditionally defines PWCHANGE, which indicates
X?S:	that struct passwd contains pw_change.
X?S:.
X?S:d_pwclass:
X?S:	This varaible conditionally defines PWCLASS, which indicates
X?S:	that struct passwd contains pw_class.
X?S:.
X?S:d_pwexpire:
X?S:	This varaible conditionally defines PWEXPIRE, which indicates
X?S:	that struct passwd contains pw_expire.
X?S:.
X?S:d_pwcomment:
X?S:	This varaible conditionally defines PWCOMMENT, which indicates
X?S:	that struct passwd contains pw_comment.
X?S:.
X?C:I_PWD:
X?C:	This symbol, if defined, indicates to the C program that it should
X?C:	include <pwd.h>.
X?C:.
X?C:PWQUOTA:
X?C:	This symbol, if defined, indicates to the C program that struct passwd
X?C:	contains pw_quota.
X?C:.
X?C:PWAGE:
X?C:	This symbol, if defined, indicates to the C program that struct passwd
X?C:	contains pw_age.
X?C:.
X?C:PWCHANGE:
X?C:	This symbol, if defined, indicates to the C program that struct passwd
X?C:	contains pw_change.
X?C:.
X?C:PWCLASS:
X?C:	This symbol, if defined, indicates to the C program that struct passwd
X?C:	contains pw_class.
X?C:.
X?C:PWEXPIRE:
X?C:	This symbol, if defined, indicates to the C program that struct passwd
X?C:	contains pw_expire.
X?C:.
X?C:PWCOMMENT:
X?C:	This symbol, if defined, indicates to the C program that struct passwd
X?C:	contains pw_comment.
X?C:.
X?H:#$i_pwd I_PWD		/**/
X?H:#$d_pwquota PWQUOTA	/**/
X?H:#$d_pwage PWAGE	/**/
X?H:#$d_pwchange PWCHANGE	/**/
X?H:#$d_pwclass PWCLASS	/**/
X?H:#$d_pwexpire PWEXPIRE	/**/
X?H:#$d_pwcomment PWCOMMENT	/**/
X?H:.
X?T:xxx
X: see if this is a pwd system
Xecho " "
Xxxx=`./findhdr pwd.h`
Xif $test "$xxx"; then
X	i_pwd="$define"
X	echo "<pwd.h> found." >&4
X	$cppstdin $cppflags < $xxx >$$.h
X	if $contains 'pw_quota' $$.h >/dev/null 2>&1; then
X		d_pwquota="$define"
X	else
X		d_pwquota="$undef"
X	fi
X	if $contains 'pw_age' $$.h >/dev/null 2>&1; then
X		d_pwage="$define"
X	else
X		d_pwage="$undef"
X	fi
X	if $contains 'pw_change' $$.h >/dev/null 2>&1; then
X		d_pwchange="$define"
X	else
X		d_pwchange="$undef"
X	fi
X	if $contains 'pw_class' $$.h >/dev/null 2>&1; then
X		d_pwclass="$define"
X	else
X		d_pwclass="$undef"
X	fi
X	if $contains 'pw_expire' $$.h >/dev/null 2>&1; then
X		d_pwexpire="$define"
X	else
X		d_pwexpire="$undef"
X	fi
X	if $contains 'pw_comment' $$.h >/dev/null 2>&1; then
X		d_pwcomment="$define"
X	else
X		d_pwcomment="$undef"
X	fi
X	$rm -f $$.h
Xelse
X	i_pwd="$undef"
X	d_pwquota="$undef"
X	d_pwage="$undef"
X	d_pwchange="$undef"
X	d_pwclass="$undef"
X	d_pwexpire="$undef"
X	d_pwcomment="$undef"
X	echo "<pwd.h> NOT found." >&4
Xfi
X
END_OF_FILE
  if test 3671 -ne `wc -c <'mcon/U/i_pwd.U'`; then
    echo shar: \"'mcon/U/i_pwd.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/i_pwd.U'
fi
if test -f 'mcon/pl/lint.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/pl/lint.pl'\"
else
  echo shar: Extracting \"'mcon/pl/lint.pl'\" \(27324 characters\)
  sed "s/^X//" >'mcon/pl/lint.pl' <<'END_OF_FILE'
X;# $Id: lint.pl,v 3.0 1993/08/18 12:10:25 ram Exp $
X;#
X;#  Copyright (c) 1991-1993, Raphael Manfredi
X;#  
X;#  You may redistribute only under the terms of the Artistic Licence,
X;#  as specified in the README file that comes with the distribution.
X;#  You may reuse parts of this distribution only within the terms of
X;#  that same Artistic Licence; a copy of which may be found at the root
X;#  of the source tree for dist 3.0.
X;#
X;# $Log: lint.pl,v $
X;# Revision 3.0  1993/08/18  12:10:25  ram
X;# Baseline for dist 3.0 netwide release.
X;#
X;# The list of all available units is held in @ARGV. We shall parse them and
X;# extract the dependencies. A lot of global data structures are filled in
X;# during this phase.
X;#
X# Initialize the extraction process by setting some variables.
X# We return a string to be eval'ed to do more customized initializations.
Xsub init_extraction {
X	$c_symbol = '';				# Current symbol seen in ?C: lines
X	$s_symbol = '';				# Current symbol seen in ?S: lines
X	$last_interpreted = 0;		# True when last line was an '@' one
X	%csym = ();					# C symbols described
X	%ssym = ();					# Shell symbols described
X	%hcsym = ();				# C symbols used by ?H: lines
X	%hssym = ();				# Shell symbols used by ?H: lines
X	%symset = ();				# Records all the shell symbol set
X	%symused = ();				# Records all the shell symbol used
X	%tempseen = ();				# Temporary shell variable seen
X	%defseen = ();				# Symbol defintions claimed
X	%lintseen = ();				# Symbols declared known by a ?LINT: line
X	%lintchange = ();			# Symbols declared changed by a ?LINT: line
X	%lintuse = ();				# Symbols declared used by unit
X	%lintextern = ();			# Symbols known to be externally defined
X	%condseen = ();				# Records conditional dependencies
X	%depseen = ();				# Records full dependencies
X	%shvisible = ();			# Records units making a symbol visible
X	%shspecial = ();			# Records special units listed as wanted
X	%shmaster = ();				# List of units defining a shell symbol
X	%cmaster = ();				# List of units defining a C symbol
X	%symdep = ();				# Records units where symbol is a dependency
X	@make = ();					# Records make dependency lines
X	$body = 'p_body';			# Procedure to handle body
X	$ending = 'p_end';			# Called at the end of each unit
X}
X
X# End the extraction process
Xsub end_extraction {
X}
X
X# Process the ?MAKE: line
Xsub p_make {
X	local($_) = @_;
X	local(@ary);					# Locally defined symbols
X	local(@dep);					# Dependencies
X	local($where) = "\"$file\", line $. (?MAKE:)";
X	return unless /^[\w ]*:/;		# We only want the main dependency rule
X	warn "$where: ignoring duplicate dependency listing line.\n"
X		if $makeseen{$unit}++;
X	return if $makeseen{$unit} > 1;
X	undef %condseen;				# Reset those once for every unit
X	undef %depseen;					# (assuming there is only one depend line)
X	undef %defseen;
X	undef %tempseen;
X	undef %symset;
X	undef %symused;
X	undef %csym;
X	undef %ssym;
X	undef %hcsym;
X	undef %hssym;
X	undef %lintseen;
X	undef %lintchange;
X	undef %lintextern;
X	s|^\s*||;						# Remove leading spaces
X	chop;
X	push(@make, $_);				# Record dependencies for later perusal
X	s/:(.*)//;
X	@dep = split(' ', $1);			# Dependencies
X	@ary = split(' ');				# Locally defined symbols
X	foreach $sym (@ary) {
X		# Only symbols starting with a lowercase letter are to appear in
X		# config.sh, excepted the ones listed in Except.
X		# We record for each shell symbol the list of units which claim to make
X		# it, so as to report duplicates.
X		if ($sym =~ /^[a-z]/ || $Except{$sym}) {
X			$shmaster{"\$$sym"} .= "$unit ";
X			++$defseen{$sym};
X		} else {
X			warn "$where: special unit '$sym' should not be listed as made.\n"
X				unless $sym eq $unit;
X		}
X	}
X	foreach $sym (@dep) {
X		if ($sym =~ /^\+[A-Za-z]/) {
X			$sym =~ s|^\+||;
X			++$condseen{$sym};		# Conditional symbol wanted
X		} else {
X			++$depseen{$sym};		# Full dependency
X		}
X
X		# Each 'wanted' special unit (i.e. one starting with a capital letter)
X		# is remembered, so as to prevent exported symbols from being reported
X		# as "undefined". For instance, Myread exports $dflt, $ans and $rp.
X		$shspecial{$unit} .= "$sym " if substr($sym, 0, 1) =~ /^[A-Z]/;
X
X		# Remember where wanted symbol is defined, so that we can report
X		# stale dependencies later on (i.e. dependencies which refer to non-
X		# existent symbols).
X		$symdep{$sym} .= "$unit ";	# This symbol is wanted here
X	}
X	# Make sure we do not want a symbol twice, nor do we want it once as a full
X	# dependency and once as a conditional dependency.
X	foreach $sym (@dep) {
X		if ($sym =~ /^\+[A-Za-z]/) {
X			$sym =~ s|^\+||;
X			warn "$where: '+$sym' is listed $condseen{$sym} times.\n"
X				if $condseen{$sym} > 1;
X			$condseen{$sym} = 1 if $condseen{$sym};	# Avoid multiple messages
X		} else {
X			warn "$where: '$sym' is listed $depseen{$sym} times.\n"
X				if $depseen{$sym} > 1;
X			$depseen{$sym} = 1 if $depseen{$sym};	# Avoid multiple messages
X		}
X		warn "$where: '$sym' listed as both conditional and full dependency.\n"
X			if $condseen{$sym} && $depseen{$sym};
X	}
X	# Make sure every unit "inherits" from the symbols exported by 'Init'.
X	$shspecial{$unit} .= 'Init ' unless $shspecial{$unit} =~ /Init\b/;
X}
X
X# Process the ?O: line
Xsub p_obsolete {
X	local($_) = @_;
X	chop;
X	$Obsolete{"$unit.U"} = $_;		# Message to print if unit is used
X}
X
X# Process the ?S: lines
Xsub p_shell {
X	local($_) = @_;
X	local($where) = "\"$file\", line $. (?S:)";
X	if (/^(\w+)\s*(\(.*\))*\s*:/) {
X		&check_last_declaration;
X		$s_symbol = $1;
X		print "  ?S: $s_symbol\n" if $opt_d;
X		# Make sure we do not define symbol twice and that the symbol is indeed
X		# listed in the ?MAKE: line.
X		warn "$where: duplicate description for variable '\$$s_symbol'.\n"
X			if $ssym{$s_symbol}++;
X		warn "$where: variable '\$$s_symbol' is not listed on ?MAKE: line.\n"
X			unless $defseen{$s_symbol} || $lintseen{$s_symbol};
X		# Deal with obsolete symbol list (enclosed between parenthesis)
X		&record_obsolete("\$$_") if /\(/;
X	} else {
X		unless ($s_symbol) {
X			warn "$where: syntax error in ?S: construct.\n";
X			return;
X		}
X	}
X
X	m|^\.\s*$| && ($s_symbol = '');		# End of comment
X}
X
X# Process the ?C: lines
Xsub p_c {
X	local($_) = @_;
X	local($where) = "\"$file\", line $. (?C:)";
X	if (s/^(\w+)\s*~\s*(\S+)\s*(.*):/$1 $3:/) {
X		&check_last_declaration;
X		$c_symbol = $2;					# Alias for definition in config.h
X		# Record symbol definition for further duplicate spotting
X		$cmaster{$1} .= "$unit " unless $csym{$1};
X		print "  ?C: $1 ~ $c_symbol\n" if $opt_d;
X		# Make sure we do not define symbol twice
X		warn "$where: duplicate description for symbol '$1'.\n"
X			if $csym{$1}++;
X		# Deal with obsolete symbol list (enclosed between parenthesis)
X		&record_obsolete("$_") if /\(/;
X	} elsif (/^(\w+)\s*(\(.*\))*\s*:/) {
X		&check_last_declaration;
X		$c_symbol = $1;
X		# Record symbol definition for further duplicate spotting
X		$cmaster{$c_symbol} .= "$unit " unless $csym{$c_symbol};
X		print "  ?C: $c_symbol\n" if $opt_d;
X		# Make sure we do not define symbol twice
X		warn "$where: duplicate description for symbol '$c_symbol'.\n"
X			if $csym{$c_symbol}++;
X		# Deal with obsolete symbol list (enclosed between parenthesis)
X		&record_obsolete("$_") if /\(/;
X	} else {
X		unless ($c_symbol) {
X			warn "$where: syntax error in ?C: construct.\n";
X			return;
X		}
X	}
X
X	s|^(\w+)|?$c_symbol:/* $1| ||							# Start of comment
X	(s|^\.\s*$|?$c_symbol: */\n| && ($c_symbol = '', 1)) ||	# End of comment
X	s|^(.*)|?$c_symbol: *$1|;								# Middle of comment
X	&p_config("$_");					# Add comments to config.h.SH
X}
X
X# Process the ?H: lines
Xsub p_config {
X	local($_) = @_;
X	local($where) = "\"$file\", line $. (?H)" unless $where;
X	s/^\?(\w+)://;						# Remove leading '?var:'
X	return unless /^#/;					# Look only for cpp lines
X	if (m|^#\$(\w+)\s+(\w+).*\$(\w+)|) {
X		# Case: #$d_var VAR "$var"
X		warn "$where: symbol '$2' was already defined.\n" if $hcsym{$2}++;
X		&check_definition("$1");
X		&check_definition("$3");
X	} elsif (m|^#\$define\s+(\w+)|) {
X		# Case: #$define VAR
X		warn "$where: symbol '$1' was already defined.\n" if $hcsym{$1}++;
X	} elsif (m|^#\$(\w+)\s+(\w+)|) {
X		# Case: #$d_var VAR
X		warn "$where: symbol '$2' was already defined.\n" if $hcsym{$2}++;
X		&check_definition("$1");
X	} elsif (m|^#define\s+(\w+).*\$(\w+)|) {
X		# Case: #define VAR "$var"
X		warn "$where: symbol '$1' was already defined.\n" if $hcsym{$1}++;
X		&check_definition("$2");
X	} elsif (m|^#define\s+(\w+)|) {
X		# Case: #define VAR
X		$hcsym{$1}++;			# Multiple occurrences may be legitimate
X	}
X}
X
X# Process the ?INIT: lines
Xsub p_init {
X	local($where) = "\"$file\", line $. (?INIT)";
X	&p_body;		# Pass it along as a body line (leading ?INIT: removed)
X}
X
X# Process the ?D: lines
Xsub p_default {
X	local($_) = @_;
X	local($where) = "\"$file\", line $. (?D)";
X	local($sym) = /^(\w+)=/;
X	$hasdefault{$sym}++;
X	&p_body;		# Pass it along as a body line (leading ?D: removed)
X}
X
X# Process the ?V: lines
Xsub p_visible {
X	# A visible symbol can freely be manipulated by any unit which includes the
X	# current unit in its dependencies. Symbols before ':' may be only used for
X	# reading while symbols after ':' may be used for both reading and writing.
X	# The array %shvisible records symbols as keys. Read-only symbols have a
X	# leading '$' while read-write symbols are recorded as-is.
X	local($where) = "\"$file\", line $. (?V)";
X	unless (substr($unit, 0, 1) =~ /^[A-Z]/) {
X		warn "$where: visible declaration in non-special unit ignored.\n";
X		return;
X	}
X	local($read_only) = $_[0] =~ /^([^:]*):?/;
X	local($read_write) = $_[0] =~ /:(.*)/;
X	local(@rsym) = split(' ', $read_only);
X	local(@rwsym) = split(' ', $read_write);
X	local($w);
X	foreach (@rsym) {		# Read only symbols
X		warn "$where: wanted variable '\$$_' made visible.\n" if &wanted($_);
X		warn "$where: defined variable '\$$_' made visible.\n"
X			if &defined($_) && !$lintseen{$_};
X		$w = $shvisible{"\$$_"};
X		warn "$where: variable '\$$_' already made visible by unit $w.\n" if $w;
X		$w = $shvisible{$_};
X		warn "$where: variable '\$$_' already read-write visible in $w.\n" if $w;
X		$shvisible{"\$$_"} = $unit unless $w;
X	}
X	foreach (@rwsym) {		# Read/write symbols
X		warn "$where: wanted variable '\$$_' made visible.\n" if &wanted($_);
X		warn "$where: defined variable '\$$_' made visible.\n"
X			if &defined($_) && !$lintseen{$_};
X		$w = $shvisible{$_};
X		warn "$where: variable '\$$_' already made visible by unit $w.\n" if $w;
X		$w = $shvisible{"\$$_"};
X		warn "$where: variable '\$$_' already read-only visible in $w.\n" if $w;
X		$shvisible{$_} = $unit unless $w;
X	}
X}
X
X# Process the ?W: lines
Xsub p_wanted {
X	local(@symbols) = split(' ', $_[0]);
X	local($where) = "\"$file\", line $. (?W)";
X	# A "?W:symbol" line asks metaconfig to define 'symbol' in the wanted file
X	# as a C target iff that word is found within the sources. This is mainly
X	# intended for the built-in interpreter to check for definedness.
X	local($w);
X	foreach (@symbols) {
X		warn "$where: variable '\$$_' already wanted.\n" if &wanted($_);
X		warn "$where: variable '\$$_' also locally defined.\n" if &defined($_);
X		$w = $cwanted{$_};
X		warn "$where: variable '\$$_' already listed on a ?W: line in '$w'.\n"
X			if $w;
X		$cwanted{$_} = $unit unless $w;
X	}
X}
X
X# Process the ?L: lines
X# There should not be any '-l' in front of the library name
Xsub p_library {
X	&write_out("L:$_");
X}
X
X# Process the ?I: lines
Xsub p_include {
X	&write_out("I:$_");
X}
X
X# Process the ?T: lines
Xsub p_temp {
X	local($_) = @_;
X	local(@sym) = split(' ', $_);
X	local($where) = "\"$file\", line $. (?T:)";
X	foreach $sym (@sym) {
X		warn "$where: temporary symbol '\$$sym' multiply declared.\n"
X			if $tempseen{$sym}++ == 1;
X		$tempmaster{$sym} .= "$unit " if $tempseen{$sym} == 1;
X	}
X}
X
X# Process the ?LINT: lines
Xsub p_lint {
X	local($_) = @_;
X	local(@sym);
X	s/^\s+//;						# Strip leading spaces
X	if (s/^set//) {					# Listed variables are set
X		@sym = split(' ', $_);
X		foreach (@sym) {
X			$symset{$_}++;			# Shell variable set
X		}
X	} elsif (s/^desc\w+//) {		# Listed shell variables are described
X		@sym = split(' ', $_);
X		foreach (@sym) {
X			$ssym{$_}++;			# Shell variable described
X		}
X	} elsif (s/^known//) {			# Listed C variables are described
X		@sym = split(' ', $_);
X		foreach (@sym) {
X			$csym{$_}++;			# C symbol described
X		}
X	} elsif (s/^change//) {			# Shell variable ok to be changed
X		@sym = split(' ', $_);
X		foreach (@sym) {
X			$lintchange{$_}++;		# Do not complain if changed
X		}
X	} elsif (s/^extern//) {			# Variables known to be externally defined
X		@sym = split(' ', $_);
X		foreach (@sym) {
X			$lintextern{$_}++;		# Do not complain if used in a ?H: line
X		}
X	} elsif (s/^use//) {			# Variables declared as used by unit
X		@sym = split(' ', $_);
X		foreach (@sym) {
X			$lintuse{$_}++;			# Do not complain if on ?MAKE and not used
X		}
X	} elsif (s/^def\w+//) {			# Listed variables are defined
X		@sym = split(' ', $_);
X		foreach (@sym) {
X			$lintseen{$_}++;		# Shell variable defined in this unit
X		}
X	}
X}
X
X# Process the body of the unit
Xsub p_body {
X	return unless $makeseen{$unit};
X	local($_) = @_;
X	local($where) = "\"$file\", line $." unless $where;
X	# Ensure there is no control line in the body of the unit
X	local($control) = /^\?([\w\-]+):/;
X	local($known) = $control ? $Depend{$control} : "";
X	warn "$where: control sequence '?$control:' ignored within body.\n"
X		if $known && !/^\?X:|^\?LINT:/;
X	if (s/^\?LINT://) {				# ?LINT directives allowed within body
X		$_ .= &complete_line(FILE) if s/\\\s*$//;
X		&p_lint($_);
X	}
X	return if $known;
X	# Ingnore interpreted lines and their continuations
X	if ($last_interpreted) {
X		return if /\\$/;			# Still part of the interpreted line
X		$last_interpreted = 0;		# End of interpreted lines
X		return;						# This line was the last interpreted
X	}
X	# Look for interpreted lines and ignore them
X	if (/^@/) {
X		$last_interpreted = /\\$/;	# Set flag if line is continued
X		return;						# And skip this line
X	}
X	s/^\s+//;						# Remove leading spaces
X	# Record any attempt made to set a shell variable
X	local($sym);
X	while (s/(\w+)=//) {
X		$sym = $1;
X		next if $sym =~ /^\d+/;		# Ignore $1 and friends
X		$symset{$sym}++;			# Shell variable set
X		# Not part of a $cc -DWHATEVER line and not made nor temporary
X		unless ($sym =~ /^D/ || &defined($sym)) {
X			if (&wanted($sym)) {
X				warn "$where: variable '\$$sym' is changed.\n"
X					unless $lintchange{$sym};
X			} else {
X				# Record that the variable is set but not listed locally.
X				$shset{$unit} .= "$sym " unless $shset{$unit} =~ /\b$sym\b/;
X			}
X		}
X	}
X	# Now look at the shell variable used
X	local($var);
X	while (s/\$(\w+)//) {
X		$var = $1;
X		next if $var =~ /^\d+/;		# Ignore $1 and friends
X		# Record variable as undeclared but do not issue a message right now.
X		# That variable could be exported via ?V: (as $dflt in Myread) or be
X		# defined by a special unit (like $inlibc by unit Inlibc).
X		$shunknown{$unit} .= "$var " unless
X			&declared($var) || $shunknown{$unit} =~ /\b$var\b/;
X		$shused{$unit} .= "\$$var " unless $shused{$unit} =~ /\$$var\b/;
X	}
X}
X
X# Called at the end of each unit
Xsub p_end {
X	local($where) = "\"$file\"";
X	unless ($makeseen{$unit}) {
X		warn "$where: no ?MAKE: line describing dependencies.\n";
X		return;
X	}
X	# Make sure every shell symbol described in ?MAKE had a description
X	foreach $sym (sort keys %defseen) {
X		warn "$where: symbol '\$$sym' was not described.\n"
X			unless $ssym{$sym};
X	}
X	# Ensure all the C symbols defined by ?H: lines have a description
X	foreach $sym (sort keys %hcsym) {
X		warn "$where: C symbol '$sym' was not described.\n"
X			unless $csym{$sym};
X	}
X	# Ensure all the C symbols described by ?C: lines are defined in ?H:
X	foreach $sym (sort keys %csym) {
X		warn "$where: C symbol '$sym' was not defined by any ?H: line.\n"
X			unless $hcsym{$sym};
X	}
X	# Make sure each defined symbol was set, unless it starts with an
X	# upper-case letter in which case it is not a "true" shell symbol.
X	# I don't care about the special symbols defined in %Except as I know
X	# they are handled correctly.
X	foreach $sym (sort keys %defseen) {
X		warn "$where: variable '\$$sym' should have been set.\n"
X			unless $symset{$sym} || substr($sym, 0, 1) =~ /^[A-Z]/;
X	}
X	# Make sure every non-special unit declared as wanted is indeed needed
X	foreach $sym (sort keys %depseen) {
X		warn "$where: unused dependency variable '\$$sym'.\n" unless
X			$shused{$unit} =~ /\$$sym\b/ || substr($sym, 0, 1) =~ /^[A-Z]/ ||
X			$lintchange{$sym} || $lintuse{$sym};
X	}
X	# Idem for conditionally wanted symbols
X	foreach $sym (sort keys %condseen) {
X		warn "$where: unused conditional variable '\$$sym'.\n" unless
X			$shused{$unit} =~ /\$$sym\b/ || substr($sym, 0, 1) =~ /^[A-Z]/ ||
X			$lintchange{$sym} || $lintuse{$sym};
X	}
X	# Idem for temporary symbols
X	foreach $sym (sort keys %tempseen) {
X		warn "$where: unused temporary variable '\$$sym'.\n" unless
X			$shused{$unit} =~ /\$$sym\b/ || $symset{$sym} || $lintuse{$sym};
X	}
X}
X
X# An unknown control line sequence was found (held in $proc)
Xsub p_unknown {
X	warn "\"$file\", line $.: unknown control sequence '?$proc:'.\n";
X}
X
X# Run sanity checks, to make sure every conditional symbol has a suitable
X# default value. Also ensure every symbol was defined once.
Xsub sanity_checks {
X	print "Sanity checks...\n";
X	local($key, $value);
X	local($w);
X	local(%message);		# Record messages on a per-unit basis
X	# Warn about symbols ever used in conditional dependency with no default
X	while (($key, $value) = each(%condseen)) {
X		unless ($hasdefault{$key}) {
X			$w = (split(' ', $shmaster{"\$$key"}))[0];
X			$message{$w} .= "#$key ";
X		}
X	}
X	# Warn about any undeclared variables. They are all listed in %shunknown,
X	# being the values while the unit where they appear is the key. If the
X	# symbol is defined by any of the special units included or made visible,
X	# then no warning is issued.
X	local($defined);		# True if symbol is defined in one unit
X	local($where);			# List of units where symbol is defined
X	local($myself);			# The name of the current unit if itself special
X	local($visible);		# Symbol made visible via a ?V: line
X	foreach $unit (sort keys %shunknown) {
X		foreach $sym (split(' ', $shunknown{$unit})) {
X			$defined = 0;
X			$where = $shmaster{"\$$sym"};
X			$defined = 1 if $tempmaster{"\$$sym"} =~ /$unit\b/;
X			$myself = substr($unit, 0, 1) =~ /^[A-Z]/ ? $unit : '';
X			# Symbol has to be either defined within one of the special units
X			# listed in the dependencies or exported via a ?V: line.
X			$defined = &visible($sym, $unit) unless $defined;
X			$message{$unit} .= "\$$sym " unless $defined;
X		}
X	}
X	# Warn about any set variable which was not listed.
X	foreach $unit (sort keys %shset) {
X		symbol: foreach $sym (split(' ', $shset{$unit})) {
X			next if $shvisible{$sym};
X			$defined = 0;
X			# Symbol has to be either defined within one of the special units
X			# listed in the dependencies or exported read-write via a ?V: line.
X			# If symbol is exported read-only, report the attempt to set it.
X			$where = $shmaster{"\$$sym"};
X			study $where;
X			foreach $special (split(' ', $shspecial{$unit})) {
X				$defined = 1 if $where =~ /\b$special\b/;
X				last if $defined;
X			}
X			$visible = 0;
X			$defined = $visible = &visible($sym, $unit) unless $defined;
X			if ($visible && $shvisible{"\$$sym"} ne '') {
X				# We are allowed to set a read-only symbol in the unit which
X				# declared it...
X				next symbol if $shvisible{"\$$sym"} eq $unit;
X				$message{$unit} .= "\&$sym ";	# Read-only symbol set
X				next symbol;
X			}
X			$message{$unit} .= "$sym " unless $defined;
X		}
X	}
X	# Warn about any obsolete variable which may be used
X	foreach $unit (sort keys %shused) {
X		foreach $sym (split(' ', $shused{$unit})) {
X			$message{$unit} .= "!$sym " if $Obsolete{$sym} ne '';
X		}
X	}
X
X	# Warn about stale dependencies, and prepare successor and predecessor
X	# tables for later topological sort.
X
X	local($targets, $deps);
X	local(%Succ);				# Successors
X	local(%Prec);				# Predecessors
X
X	# Split dependencies and build successors array.
X	foreach $make (@make) {
X		($targets, $deps) = $make =~ m|(.*):\s*(.*)|;
X		$deps =~ s/\+(\w)/$1/g;		# Remove conditional targets
X		foreach $target (split(' ', $targets)) {
X			$Succ{$target} .= $deps . ' ';
X		}
X	}
X
X	# Special setup for the End target, which normally has a $W dependency for
X	# wanted symbols. In order to detect all the possible cycles, we forge a
X	# huge dependency by making ALL the regular symbols (i.e. those whose first
X	# letter is not uppercased) wanted.
X
X	local($allwant) = '';
X	{
X		local($sym, $val);
X		while (($sym, $val) = each %shmaster) {
X			$sym =~ s/^\$//;
X			$allwant .= "$sym " if $val ne '';
X		}
X	}
X
X	$Succ{'End'} =~ s/\$W/$allwant/;
X
X	# Initialize precursors, and spot symbols impossible to 'make', i.e. those
X	# symbols listed in the successors and with no 'make' target. The data
X	# structures %Prec and %Succ will also be used by the cycle lookup code,
X	# in other words, the topological sort.
X	local(%said);
X	foreach $target (keys %Succ) {
X		$Prec{$target} += 0;	# Ensure key is recorded without disturbing.
X		foreach $succ (split(' ', $Succ{$target})) {
X			$Prec{$succ}++;		# Successor has one more precursor
X			unless (defined $Succ{$succ} || $said{$succ}++) {
X				foreach $unit (split(' ', $symdep{$succ})) {
X					$message{$unit} .= "?$succ ";	# Stale ?MAKE: dependency
X				}
X			}
X		}
X	}
X	undef %said;
X	undef %symdep;
X
X	# Now actually emit all the warnings
X	local($uv);			# Unit defining visible symbol
X	local($w);			# Were we are signaling an error
X	foreach $unit (sort keys %message) {
X		undef %said;
X		$w = "\"$unit.U\"";
X		foreach (split(' ', $message{$unit})) {
X			if (s/^#//) {
X				warn "$w: symbol '\$$_' has no default value.\n";
X			} elsif (s/^\?//) {
X				warn "$w: stale ?MAKE: dependency '$_'.\n";
X			} elsif (s/^\$//) {
X				if ($shmaster{"\$$_"} ne '') {
X					warn "$w: symbol '\$$_' missing from ?MAKE.\n";
X				} elsif (($uv = $shvisible{$_}) ne '') {
X					warn "$w: missing $uv from ?MAKE for visible '\$$_'.\n";
X				} elsif (($uv = $shvisible{"\$$_"}) ne '') {
X					warn "$w: missing $uv from ?MAKE for visible '\$$_'.\n";
X				} else {
X					warn "\"$unit.U\": unknown symbol '\$$_'.\n";
X				}
X				++$said{$_};
X			} elsif (s/^\&//) {
X				warn "\"$unit.U\": read-only symbol '\$$_' is set.\n";
X				++$said{$_};
X			} elsif (s/^!//) {
X				warn "\"$unit.U\": obsolete symbol '$_' is used.\n";
X				++$said{$_};
X			} else {
X				warn "\"$unit.U\": undeclared symbol '\$$_' is set.\n"
X					unless $said{$_};
X			}
X		}
X	}
X
X	# Memory cleanup
X	undef %message;
X	undef %said;
X	undef %shused;
X	undef %shset;
X	undef %shspecial;
X	undef %shvisible;
X
X	# Spot multiply defined C symbols
X	foreach $sym (keys %cmaster) {
X		@sym = split(' ', $cmaster{$sym});
X		if (@sym > 1) {
X			warn "C symbol '$sym' is defined in the following units:\n";
X			foreach (@sym) {
X				print STDERR "\t$_\n";
X			}
X		}
X	}
X
X	# Memory cleanup
X	undef %cmaster;
X
X	# Warn about multiply defined symbols. There are three kind of symbols:
X	# target symbols, obsolete symbols and temporary symbols.
X	# For each of these sets, we make sure the intersection with the other sets
X	# is empty. Besides, we make sure target symbols are only defined once.
X
X	local(@sym);
X	foreach $sym (keys %shmaster) {
X		@sym = split(' ', $shmaster{$sym});
X		if (@sym > 1) {
X			warn "Shell symbol '$sym' is defined in the following units:\n";
X			foreach (@sym) {
X				print STDERR "\t$_\n";
X			}
X		}
X		$message{$sym} .= 'so ' if $Obsolete{$sym};
X		$message{$sym} .= 'st ' if $tempmaster{$sym};
X	}
X	foreach $sym (keys %tempmaster) {
X		$message{$sym} .= 'ot ' if $Obsolete{$sym};
X	}
X	local($_);
X	while (($sym, $_) = each %message) {
X		if (/so/) {
X			if (/ot/) {
X				warn "Shell symbol '$sym' is altogether:\n";
X				@sym = split(' ', $shmaster{$sym});
X				@sym = grep(s/$/.U/, @sym);
X				print STDERR "...defined in: ", join(', ', @sym), "\n";
X				print STDERR "...obsoleted by $Obsolete{$sym}.\n";
X				@sym = split(' ', $tempmaster{$sym});
X				@sym = grep(s/$/.U/, @sym);
X				print STDERR "...used as temporary in:", join(', ', @sym), "\n";
X			} else {
X				warn "Shell symbol '$sym' is both defined and obsoleted:\n";
X				@sym = split(' ', $shmaster{$sym});
X				@sym = grep(s/$/.U/, @sym);
X				print STDERR "...defined in: ", join(', ', @sym), "\n";
X				print STDERR "...obsoleted by $Obsolete{$sym}.\n";
X			}
X		} elsif (/st/) {		# Cannot be ot as it would imply so
X			warn "Shell symbol '$sym' is both defined and used as temporary:\n";
X			@sym = split(' ', $shmaster{$sym});
X			@sym = grep(s/$/.U/, @sym);
X			print STDERR "...defined in: ", join(', ', @sym), "\n";
X			@sym = split(' ', $tempmaster{$sym});
X			@sym = grep(s/$/.U/, @sym);
X			print STDERR "...used as temporary in:", join(', ', @sym), "\n";
X		} elsif (/ot/) {
X			warn "Shell symbol '$sym' obsoleted also used as temporary:\n";
X			print STDERR "...obsoleted by $Obsolete{$sym}.\n";
X			@sym = split(' ', $tempmaster{$sym});
X			@sym = grep(s/$/.U/, @sym);
X			print STDERR "...used as temporary in:", join(', ', @sym), "\n";
X		}
X	}
X
X	# Memory cleanup (we still need %shmaster for tsort)
X	undef %message;
X	undef %tempmaster;
X	undef %Obsolete;
X
X	# Make sure there is no dependency cycle
X	print "Looking for dependency cycles...\n";
X	&tsort(*Succ, *Prec);	# Destroys info from %Prec
X}
X
X# Make sure last declaration ended correctly with a ?S:. or ?C:. line.
X# The variable '$where' was correctly positionned by the calling routine.
Xsub check_last_declaration {
X	warn "$where: definition of '\$$s_symbol' not closed by '?S:.'.\n"
X		if $s_symbol ne '';
X	warn "$where: definition of '$c_symbol' not closed by '?C:.'.\n"
X		if $c_symbol ne '';
X	$s_symbol = $c_symbol = '';
X}
X
X# Make sure the variable is mentionned on the ?MAKE line, if possible in the
X# definition section.
X# The variable '$where' was correctly positionned by the calling routine.
Xsub check_definition {
X	local($var) = @_;
X	warn "$where: variable '\$$var' not even listed on ?MAKE: line.\n"
X		unless $defseen{$var} || $condseen{$var} || $depseen{$var};
X	warn "$where: variable '\$$var' is defined externally.\n"
X		if !$lintextern{$var} && !$defseen{$var} && &wanted($var);
X}
X
X# Is symbol declared somewhere?
Xsub declared {
X	&defined($_[0]) || &wanted($_[0]);
X}
X
X# Is symbol defined by unit?
Xsub defined {
X	$tempseen{$_[0]} || $defseen{$_[0]} || $lintseen{$_[0]};
X}
X
X# Is symbol wanted by unit?
Xsub wanted {
X	$depseen{$_[0]} || $condseen{$_[0]};
X}
X
X# Is symbol visible from the unit?
X# Locate visible symbols throughout the special units. Each unit having
X# some special dependencies (special units wanted) have an entry in the
X# %shspecial array, listing all those special dependencies. And each
X# symbol made visible by ONE special unit has an entry in the %shvisible
X# array.
Xsub visible {
X	local($symbol, $unit) = @_;
X	local(%explored);				# Special units we've already explored
X	&explore($symbol, $unit);		# Perform recursive search
X}
X
X# Recursively explore the dependencies to locate a visible symbol
Xsub explore {
X	local($symbol, $unit) = @_;
X	# If unit was already explored, we know it has not been found by following
X	# that path.
X	return 0 if defined $explored{$unit};
X	$explored{$unit} = 0;			# Assume nothing found in this unit
X	local($specials) = $shspecial{$unit};
X	# Don't waste any time if unit does not have any special units listed
X	# in its dependencies.
X	return 0 unless $specials;
X	foreach $special (split(' ', $specials)) {
X		return 1 if (
X			$shvisible{"\$$symbol"} eq $unit ||
X			$shvisible{$symbol} eq $unit ||
X			&explore($symbol, $special)
X		);
X	}
X	0;
X}
X
END_OF_FILE
  if test 27324 -ne `wc -c <'mcon/pl/lint.pl'`; then
    echo shar: \"'mcon/pl/lint.pl'\" unpacked with wrong size!
  fi
  # end of 'mcon/pl/lint.pl'
fi
echo shar: End of archive 5 \(of 28\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Please run PACKNOTES through sh, read REAMDE and then type Configure."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
