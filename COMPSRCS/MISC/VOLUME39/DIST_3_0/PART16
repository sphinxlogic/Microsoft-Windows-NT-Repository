Newsgroups: comp.sources.misc
From: Raphael Manfredi <ram@acri.fr>
Subject: v39i020:  dist-3.0 - Configure script generator and related tools, Part16/28
Message-ID: <1993Aug19.131400.5668@sparky.sterling.com>
X-Md4-Signature: 997ffdb16e1cae8213d7a7ff9f879b6a
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Advanced Computer Research Institute, Lyon, France.
Date: Thu, 19 Aug 1993 13:14:00 GMT
Approved: kent@sparky.sterling.com

Submitted-by: Raphael Manfredi <ram@acri.fr>
Posting-number: Volume 39, Issue 20
Archive-name: dist-3.0/part16
Environment: UNIX, Perl, RCS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  Credits kit/kitsend.SH mcon/U/Cppsym.U mcon/U/d_fd_set.U
#   mcon/U/d_getpagsz.U mcon/U/d_havetlib.U mcon/U/d_sigvec.U
#   mcon/U/mansrc.U mcon/U/nis.U mcon/U/privlib.U mcon/U/scriptdir.U
#   mcon/U/shm_for.U mcon/mlint.SH pat/pat.SH pat/patbase.SH
# Wrapped by ram@soft208 on Wed Aug 18 14:42:22 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 16 (of 28)."'
if test -f 'Credits' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Credits'\"
else
  echo shar: Extracting \"'Credits'\" \(3436 characters\)
  sed "s/^X//" >'Credits' <<'END_OF_FILE'
XINTRO
X
XThis version of dist has been written by Raphael Manfredi based on
Xprevious work from Larry Wall and Harlan Stenn.
X
XHISTORY
X
XI started working on this in September 1990 while I was still a student
Xat the Ecole des Mines de Saint-Etienne, France. From then on, I worked
Xduring two years at ISE (building the Eiffel 3.0 compiler -- the run-time
Xpart and code generation). Since I chose to use metaconfig for the run-time
Xlibrary, which is written in plain C, I had the chance to continue improving
Xthe whole dist package.
X
XBy the end of  1991, I contacted Harlan Stenn <harlan@mumps.pfcs.com> who had
Xbeen working separately on his own dist version. I started the painful merge.
XAt the same time, I started releasing alpha version of dist 3.0.
X
XIn 1992, I started a parallel project: mailagent. The dist 2.0 release upon
Xwhich this work is based included a simple perl script called mailagent, whose
Xsole job was to filter out @SH commands to automatically mail patches to some
Xpeople. I liked the idea of having a perl mail filter and so I extended
Xmailagent up to the point where it became really big and only marginally
Xdist-related. I released it on the net (comp.sources.misc) on July 1992, after
X7 months of hard work.
X
XIn March 1993, I left ISE and returned to France to join ACRI. The dist 3.0
Xpackage was "almost" finished by that time, but the documentation was no
Xlonger accurate and needed a lot of work. My new job does not give me enough
Xfree time, so things have been longer than I expected.
X
XIn July 1993, under the pressure of many of my alpha testers, I decided to
Xgo into the final process, sacrifying nights and week ends to finish up what
Xturns out to have been a 3 years process...
X
XCREDITS
X
XMy first thanks will go to Larry Wall <lwall@netlabs.com> who wrote perl
Xand dist 2.0 in the first place. I would never have dived into dist 2.0
Xif it had not been written in perl.
X
XDuring my work, I had the chance to benefit some useful comments and
Xcontributions from Craig Kolb <craig@weedeater.math.yale.edu> who
Xhas been the very first user of metaconfig (with a rather pre-historic
Xversion). He used it on its rayshade 4.0 release (a ray tracing program).
X
XThen of course, many thanks are due to my co-worker, Harlan Stenn
X<harlan@mumps.pfcs.com>. Although I did the integration of his work all by
Xmyself, I have found many good ideas in his early work. For instance, he wrote
Xthe first implementation of the metalint program, something I could not live
Xwithout today! His remarks, comments and encouragements have always been
Xappreciated, even though we did not always agree on the same things at the
Xsame time...
X
XThen I would like to thank the many contributors to the metaconfig units.
XI hope I'm not forgetting anybody! Here they come, in alphabetical order:
X(sorted on the first name)
X
X	Craig Kolb <craig@weedeater.math.yale.edu>
X	Graham Stoney <greyham@research.canon.oz.au>
X	Harlan Stenn <harlan@mumps.pfcs.com>
X	Jan Djarv <Jan.Djarv@sa.erisoft.se>
X	Larry Wall <lwall@netlabs.com>
X	Scott Grosch <garath@engin.umich.edu>
X	Syd Weinstein <syd@dsi.com>
X	Wayne Davison <davison@borland.com>
X
XIf I forgot your name, please let me know, and accept my apologies (not
Xnecessarily in that order ;-).
X
XFinally, thank you Shigeya Suzuki <shigeya@foretune.co.jp> for hosting the
Xdist-users mailing list. Send mail to majordomo@foretune.co.jp to subscribe.
X
X	Raphael Manfredi <ram@acri.fr>
X	Lyon, France, August 1993
END_OF_FILE
  if test 3436 -ne `wc -c <'Credits'`; then
    echo shar: \"'Credits'\" unpacked with wrong size!
  fi
  # end of 'Credits'
fi
if test -f 'kit/kitsend.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kit/kitsend.SH'\"
else
  echo shar: Extracting \"'kit/kitsend.SH'\" \(3093 characters\)
  sed "s/^X//" >'kit/kitsend.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting kit/kitsend (with variable substitutions)"
Xcat >kitsend <<!GROK!THIS!
X$startperl
X	eval 'exec perl -S \$0 "\$@"'
X		if \$running_under_some_shell;
X
X# $Id: kitsend.SH,v 3.0 1993/08/18 12:04:25 ram Exp $
X#
X#  Copyright (c) 1991-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic Licence,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic Licence; a copy of which may be found at the root
X#  of the source tree for dist 3.0.
X#
X# Original Author: Harlan Stenn <harlan@mumps.pfcs.com>
X#
X# $Log: kitsend.SH,v $
X# Revision 3.0  1993/08/18  12:04:25  ram
X# Baseline for dist 3.0 netwide release.
X#
X
X\$orgname='$orgname';
X\$mailer='$mailer';
X!GROK!THIS!
Xcat >>kitsend <<'!NO!SUBS!'
X
Xchop($orgname = `cat $orgname`) if $orgname =~ m|^/|;
X
X&readpackage;
X
Xwhile ($_ = shift) {
X	if (/^(kit)?[1-9][\d,-]*$/) {
X		s/^kit//;
X		push(@argv, $_);
X	}
X	else {
X		push(@dest, $_);
X	}
X}
X$dest = join(' ',@dest);
Xdie "Usage: kitsend [kits] dest\n" unless $dest;
X
X@ARGV = @argv;
X
Xif (-f "$package.kit10") {
X	@filelist = <$package.kit[0-9][0-9]>;
X}
Xelse {
X	@filelist = <$package.kit[0-9]>;
X}
Xpop(@filelist) =~ /(\d+)$/ && ($maxnum = $1 + 0);
X
Xif ($#ARGV < 0) {
X	$argv = "1-$maxnum";
X	@ARGV = $argv;
X}
X$argv = do rangeargs(@ARGV);
X@ARGV = split(' ',$argv);
X
X$argv =~ s/ $//;
X
Xif ($#ARGV < 0) {
X	die "No kits specified.\n";
X} elsif ($#ARGV) {
X	print "Sending $package $baserev kits $argv to $dest...\n";
X} else {
X	print "Sending $package $baserev kit $argv to $dest...\n";
X}
X
Xfork && exit;
X
X$opt = '-odq' if $mailer =~ /sendmail/;
X
Xuntil ($#ARGV < 0) {
X	$kitnum = shift;
X	open(XHEAD,">.xhead$$") || die "kitsend: can't create temp file: $!.\n";
X	print XHEAD
X"To: $dest
XSubject: $package $baserev kit #$kitnum
XOrganization: $orgname
X
X[There are $maxnum kits for $package version $baserev.]
X
X";
X	$kitnum = "0$kitnum" if $kitnum < 10 && $maxnum >= 10;
X	open(PATCH,"$package.kit$kitnum") ||
X		die "kitsend: can't open $package.kit$kitnum: $!\n";
X	while (<PATCH>) {
X		print XHEAD;
X	}
X	close XHEAD;
X	system "$mailer $opt $dest <.xhead$$";
X}
Xunlink ".xhead$$";
X
Xsub rangeargs {
X	local($result) = '';
X	local($min,$max,$_);
X	while ($#_ >= 0) {
X		$_ = shift(@_);
X		while (/^\s*\d/) {
X			s/^\s*(\d+)//;
X			$min = $1;
X			if (s/^,//) {
X				$max = $min;
X			}
X			elsif (s/^-(\d*)//) {
X				$max = $1;
X				if ($max == 0 && $maxnum) {
X					$max = $maxnum;
X				}
X				s/^[^,],?//;
X			}
X			else {
X				$max = $min;
X			}
X			for ($i = $min; $i <= $max; ++$i) {
X				$result .= $i . ' ';
X			}
X		}
X	}
X	$result;
X}
X
X!NO!SUBS!
X$grep -v '^;#' ../pl/package.pl >>kitsend
Xchmod +x kitsend
X$eunicefix kitsend
END_OF_FILE
  if test 3093 -ne `wc -c <'kit/kitsend.SH'`; then
    echo shar: \"'kit/kitsend.SH'\" unpacked with wrong size!
  fi
  chmod +x 'kit/kitsend.SH'
  # end of 'kit/kitsend.SH'
fi
if test -f 'mcon/U/Cppsym.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/Cppsym.U'\"
else
  echo shar: Extracting \"'mcon/U/Cppsym.U'\" \(3022 characters\)
  sed "s/^X//" >'mcon/U/Cppsym.U' <<'END_OF_FILE'
X?RCS: $Id: Cppsym.U,v 3.0 1993/08/18 12:04:50 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: Cppsym.U,v $
X?RCS: Revision 3.0  1993/08/18  12:04:50  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X: 
X?X: This unit produces a shell script called Cppsym, which can be used to
X?X: determine whether any in a list of symbols is defined by the C preprocessor.
X?X: It can determine the status of any symbol, though the symbols in attrlist
X?X: are more easily determined.  If you want to add to attrlist you can do
X?X: it in Myinit.U.
X?X: 
X?MAKE:Cppsym: eunicefix Guess cppstdin awk cat tr sed grep rm startsh \
X	contains cppminus
X?MAKE:	-pick add $@ %<
X?T:attrlist sym list unknown status
X?X: The attrlist is in alpha order for ease of maintenance...
X?INIT:: list of known cpp symbols
X?INIT:attrlist="__alpha DGUX M_I186 M_I286 M_I386 M_I8086 M_XENIX UTS __DGUX__"
X?INIT:attrlist="$attrlist _AIX __STDC__ __m88k__ ansi bsd4_2 gcos gimpel"
X?INIT:attrlist="$attrlist hp9000s300 hp9000s400 hp9000s500 hp9000s700"
X?INIT:attrlist="$attrlist hp9000s800 hpux"
X?INIT:attrlist="$attrlist i186 i386 i486 i8086 iAPX286 ibm interdata"
X?INIT:attrlist="$attrlist m88k mc300 mc500 mc68000 mc68k mc700 mert"
X?INIT:attrlist="$attrlist mips NeXT ns16000 ns32000 nsc32000 os"
X?INIT:attrlist="$attrlist __osf__ pdp11 posix"
X?INIT:attrlist="$attrlist pyr sinix sony sparc sun tower tower32 tower32_600"
X?INIT:attrlist="$attrlist tower32_800 tss u3b2 u3b20 u3b200 u3b5 ultrix unix"
X?INIT:attrlist="$attrlist __unix__ vax venix xenix z8000"
X?INIT:
X: get C preprocessor symbols handy
Xecho " "
X?X: The following used to be tr '[ - ]' ... but this was rejected by AIX 3.2
X?X: since the endpoints where the same (from patch 12u8 to patch).
Xecho $attrlist | $tr ' ' '\012' >Cppsym.know
X$cat <<EOSS >Cppsym
X$startsh
Xcase "\$1" in
X-l) list=true
X	shift
X	;;
Xesac
Xunknown=''
Xcase "\$list\$#" in
X1|2)
X	for sym do
X		if $contains "^\$1$" Cppsym.true >/dev/null 2>&1; then
X			exit 0
X		elif $contains "^\$1$" Cppsym.know >/dev/null 2>&1; then
X			:
X		else
X			unknown="\$unknown \$sym"
X		fi
X	done
X	set X \$unknown
X	shift
X	;;
Xesac
Xcase \$# in
X0) exit 1;;
Xesac
Xecho \$* | $tr ' ' '\012' | $sed -e 's/\(.*\)/\\
X#ifdef \1\\
Xexit 0; _ _ _ _\1\\	 \1\\
X#endif\\
X/' >Cppsym\$\$
Xecho "exit 1; _ _ _" >>Cppsym\$\$
X$cppstdin $cppminus <Cppsym\$\$ | $grep '^exit [01]; _ _'  >Cppsym2\$\$
Xcase "\$list" in
Xtrue) $awk 'NF > 5 {print substr(\$6,2,100)}' <Cppsym2\$\$ ;;
X*)
X	sh Cppsym2\$\$
X	status=\$?
X	;;
Xesac
X$rm -f Cppsym\$\$ Cppsym2\$\$
Xexit \$status
XEOSS
Xchmod +x Cppsym
X$eunicefix Cppsym
Xecho "Your C preprocessor defines the following symbols:"
XCppsym -l $attrlist >Cppsym.true
X$cat Cppsym.true
X
END_OF_FILE
  if test 3022 -ne `wc -c <'mcon/U/Cppsym.U'`; then
    echo shar: \"'mcon/U/Cppsym.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/Cppsym.U'
fi
if test -f 'mcon/U/d_fd_set.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_fd_set.U'\"
else
  echo shar: Extracting \"'mcon/U/d_fd_set.U'\" \(3288 characters\)
  sed "s/^X//" >'mcon/U/d_fd_set.U' <<'END_OF_FILE'
X?RCS: $Id: d_fd_set.U,v 3.0 1993/08/18 12:06:02 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_fd_set.U,v $
X?RCS: Revision 3.0  1993/08/18  12:06:02  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_fd_set d_fd_macros d_fds_bits: cat +cc +ccflags rm Oldconfig
X?MAKE:	-pick add $@ %<
X?S:d_fd_set:
X?S:	This variable contains the eventual value of the HAS_FD_SET symbol,
X?S:	which indicates if your C compiler knows about the fd_set typedef.
X?S:.
X?S:d_fd_macros:
X?S:	This variable contains the eventual value of the HAS_FD_MACROS symbol,
X?S:	which indicates if your C compiler knows about the macros which
X?S:	manipulate an fd_set.
X?S:.
X?S:d_fds_bits:
X?S:	This variable contains the eventual value of the HAS_FDS_BITS symbol,
X?S:	which indicates if your fd_set typedef contains the fds_bits member.
X?S:	If you have an fd_set typedef, but the dweebs who installed it did
X?S:	a half-fast job and neglected to provide the macros to manipulate
X?S:	an fd_set, HAS_FDS_BITS will let us know how to fix the gaffe.
X?S:.
X?C:HAS_FD_SET:
X?C:	This symbol indicates (lack of) the fd_set typedef in <sys/types.h>
X?C:.
X?C:HAS_FD_MACROS:
X?C:	This symbol indicates (lack of) the macros used to manipulate an
X?C:	fd_set.
X?C:.
X?C:HAS_FDS_BITS:
X?C:	This symbol indicates (lack of) the fds_bits member in fd_set.  This
X?C:	knowledge is useful if fd_set is available but the macros aren't.
X?C:.
X?H:#$d_fd_set HAS_FD_SET	/**/
X?H:#$d_fd_macros HAS_FD_MACROS	/**/
X?H:#$d_fds_bits HAS_FDS_BITS	/**/
X?H:.
X: check for fd_set items
X$cat <<EOM
X
XChecking to see how well your C compiler handles fd_set and friends ...
XEOM
X$cat >fd_set.c <<'EOCP'
X#include <sys/types.h>
Xmain() {
X	fd_set fds;
X
X#ifdef TRYBITS
X	if(fds.fds_bits);
X#endif
X
X#if defined(FD_SET) && defined(FD_CLR) && defined(FD_ISSET) && defined(FD_ZERO)
X	exit(0);
X#else
X	exit(1);
X#endif
X}
XEOCP
Xif $cc $ccflags -DTRYBITS fd_set.c -o fd_set >fd_set.out 2>&1 ; then
X	d_fds_bits="$define"
X	d_fd_set="$define"
X	echo "Well, your system knows about the normal fd_set typedef..." >&4
X	if ./fd_set; then
X		echo "and you have the normal fd_set macros (just as I'd expect)." >&4
X		d_fd_macros="$define"
X	else
X		$cat >&4 <<'EOM'
Xbut not the normal fd_set macros!  Gaaack!  I'll have to cover for you.
XEOM
X		d_fd_macros="$undef"
X	fi
Xelse
X	$cat <<'EOM'
XHmm, your compiler has some difficulty with fd_set.  Checking further...
XEOM
X	if $cc $ccflags fd_set.c -o fd_set >fd_set.out 2>&1 ; then
X		d_fds_bits="$undef"
X		d_fd_set="$define"
X		echo "Well, your system has some sort of fd_set available..." >&4
X		if ./fd_set; then
X			echo "and you have the normal fd_set macros." >&4
X			d_fd_macros="$define"
X		else
X			$cat <<'EOM'
Xbut not the normal fd_set macros!  Gross!  More work for me...
XEOM
X			d_fd_macros="$undef"
X		fi
X	else
X	echo "Well, you got zip.  That's OK, I can roll my own fd_set stuff." >&4
X		d_fd_set="$undef"
X		d_fds_bits="$undef"
X		d_fd_macros="$undef"
X	fi
Xfi
X$rm -f fd_set*
X
END_OF_FILE
  if test 3288 -ne `wc -c <'mcon/U/d_fd_set.U'`; then
    echo shar: \"'mcon/U/d_fd_set.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_fd_set.U'
fi
if test -f 'mcon/U/d_getpagsz.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_getpagsz.U'\"
else
  echo shar: Extracting \"'mcon/U/d_getpagsz.U'\" \(2809 characters\)
  sed "s/^X//" >'mcon/U/d_getpagsz.U' <<'END_OF_FILE'
X?RCS: $Id: d_getpagsz.U,v 3.0 1993/08/18 12:06:14 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_getpagsz.U,v $
X?RCS: Revision 3.0  1993/08/18  12:06:14  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_getpagsz pagesize: Oldconfig Myread Inlibc cat contains +cc +ccflags \
X	libs rm Findhdr
X?MAKE:	-pick add $@ %<
X?S:d_getpagsz:
X?S:	This variable conditionally defines HAS_GETPAGESIZE if getpagesize()
X?S:	is available to get the system page size.
X?S:.
X?S:pagesize (pagsize):
X?S:	This variable holds the size in bytes of a system page.
X?S:.
X?C:HAS_GETPAGESIZE (GETPAGESIZE):
X?C:	This symbol, if defined, indicates that the getpagesize system call
X?C:	is available to get system page size, which is the granularity of
X?C:	many memory management calls.
X?C:.
X?X: Don't name it PAGESIZE, this is sometimes used by <sys/param.h>
X?C:PAGESIZE_VALUE (PAGSIZE):
X?C:	This symbol holds the size in bytes of a system page (obtained via
X?C:	the getpagesize() system call at configuration time or asked to the
X?C:	user if the system call is not available).
X?C:.
X?H:#$d_getpagsz HAS_GETPAGESIZE		/**/
X?H:#define PAGESIZE_VALUE $pagesize	/* System page size, in bytes */
X?H:.
X?T:guess
X?LINT:set d_getpagsz
X: see if getpagesize exists
Xset getpagesize d_getpagsz
Xeval $inlibc
X
X@if pagesize || PAGESIZE_VALUE
X: determine the system page size
Xecho " "
Xguess=' (OK to guess)'
Xcase "$pagesize" in
X'')
X	$cat >page.c <<EOP
Xextern int getpagesize();
Xmain()
X{
X	printf("%d\n", getpagesize());
X}
XEOP
X	echo "Computing the granularity of memory management calls..." >&4
X	dflt='4096'
X	case "$d_getpagsz" in
X	"$define")
X		if $cc $ccflags page.c -o page $libs >/dev/null 2>&1; then
X			dflt=`./page`
X			guess=''
X		else
X			echo "(I can't seem to compile the test program--guessing)"
X		fi
X		;;
X	*)
X		if $cc $ccflags page.c -o page $libs -lPW >/dev/null 2>&1; then
X			dflt=`./page`
X			guess=''
X			echo "(For your eyes only: I used the getpagesize() from -lPW.)"
X		else
X			if $contains PAGESIZE `./findhdr sys/param.h` >/dev/null 2>&1; then
X				$cat >page.c <<EOP
X#include <sys/param.h>
Xmain()
X{
X	printf("%d\n", PAGESIZE);
X}
XEOP
X				if $cc $ccflags page.c -o page $libs >/dev/null 2>&1; then
X					dflt=`./page`
X					guess=''
X					echo "(Using value of PAGESIZE found in <sys/param.h>.)"
X				fi
X			fi
X		fi
X		;;
X	esac
X	;;
X*) dflt="$pagesize"; guess='';;
Xesac
Xrp="What is the system page size, in bytes$guess?"
X. ./myread
Xpagesize=$ans
X$rm -f page.c page
X
X@end
END_OF_FILE
  if test 2809 -ne `wc -c <'mcon/U/d_getpagsz.U'`; then
    echo shar: \"'mcon/U/d_getpagsz.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_getpagsz.U'
fi
if test -f 'mcon/U/d_havetlib.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_havetlib.U'\"
else
  echo shar: Extracting \"'mcon/U/d_havetlib.U'\" \(2799 characters\)
  sed "s/^X//" >'mcon/U/d_havetlib.U' <<'END_OF_FILE'
X?RCS: $Id: d_havetlib.U,v 3.0 1993/08/18 12:06:19 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_havetlib.U,v $
X?RCS: Revision 3.0  1993/08/18  12:06:19  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_havetlib termlib: cat contains Myread Loc Filexp Oldconfig libpth
X?MAKE:	-pick add $@ %<
X?S:d_havetlib:
X?S:	This variable conditionally defines the HAS_TERMLIB symbol, which
X?S:	indicates to the C program that termlib-style routines are available.
X?S:.
X?S:termlib:
X?S:	This variable contains the argument to pass to the loader to get
X?S:	termlib-style routines.  It is up to the Makefile.SH to make sure
X?S:	the value gets to the right command.  Note that on many systems the
X?S:	termlib routines are emulated by the curses or terminfo library.
X?S:.
X?C:HAS_TERMLIB (HAVETERMLIB):
X?C:	This symbol, when defined, indicates that termlib-style routines
X?C:	are available.  There is nothing to include.
X?C:.
X?H:#$d_havetlib	HAS_TERMLIB	/**/
X?H:.
X?T:xxx
X: where do we get termlib routines from
Xecho " "
Xxxx=`./loc libcurses.a x $libpth`
Xcase "$xxx" in
X/*)
X	ar t $xxx >grimble
X	if $contains tputs.o grimble >/dev/null 2>&1; then
X		termlib='-lcurses'
X		d_havetlib="$define"
X		echo "Terminfo library found." >&4
X	else
X		xxx=x
X	fi
X	rm -f grimble
X	;;
Xesac
Xcase "$xxx" in
Xx)
X	xxx=`./loc libtermlib.a x $libpth`
X	case "$xxx" in
X	/usr/lib*|/lib*)
X		termlib='-ltermlib'
X		d_havetlib="$define"
X		echo "Termlib library found." >&4
X		;;
X	/*)
X		termlib="$xxx"
X		d_havetlib="$define"
X		echo "Termlib library found." >&4
X		;;
X	*)
X		xxx=`./loc libtermcap.a x $libpth`
X		case "$xxx" in
X		/usr/lib*|/lib*)
X			termlib='-ltermcap'
X			d_havetlib="$define"
X			echo "Termcap library found." >&4
X			;;
X		/*)
X			termlib="$xxx"
X			d_havetlib="$define"
X			echo "Termcap library found." >&4
X			;;
X		*)
X			case "$termlib" in
X			'')
X				dflt=y
Xrp="Your system appears to NOT have termlib-style routines. Is this true?"
X				. ./myread
X				case "$ans" in
X				n*|f*) d_havetlib="$define"
X					$cat <<'EOM'
XThen where are the termlib-style routines kept? Specify either -llibname
Xor a full pathname (~name ok).
X
XEOM
X					dflt=''
X					rp='Specify termlib path:'
X					. ./myread
X					termlib=`./filexp $ans`
X					;;
X				*)
X					d_havetlib="$undef"
X					termlib=''
X					echo "You will have to play around with term.c then." >&4
X					;;
X				esac
X			echo " ";;
X			*)  echo "You said termlib was $termlib before." >&4;;
X			esac;;
X		esac;;
X	esac;;
Xesac
X
END_OF_FILE
  if test 2799 -ne `wc -c <'mcon/U/d_havetlib.U'`; then
    echo shar: \"'mcon/U/d_havetlib.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_havetlib.U'
fi
if test -f 'mcon/U/d_sigvec.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_sigvec.U'\"
else
  echo shar: Extracting \"'mcon/U/d_sigvec.U'\" \(2938 characters\)
  sed "s/^X//" >'mcon/U/d_sigvec.U' <<'END_OF_FILE'
X?RCS: $Id: d_sigvec.U,v 3.0 1993/08/18 12:07:24 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_sigvec.U,v $
X?RCS: Revision 3.0  1993/08/18  12:07:24  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X: d_sigvec.U, from d_ftime.U 1.0
X?X:
X?MAKE:d_sigvec d_sigvectr d_sigintrp d_sigaction: Csym Inlibc Setvar
X?MAKE:	-pick add $@ %<
X?S:d_sigvec:
X?S:	This variable conditionally defines the HAS_SIGVEC symbol, which indicates
X?S:	that BSD reliable signals are supported.
X?S:.
X?S:d_sigvectr:
X?S:	This variable conditionally defines the HAS_SIGVECTOR symbol, which
X?S:	indicates that the sigvec() routine is called sigvector() instead, for
X?S:	reasons known only to Hewlett-Packard.
X?S:.
X?S:d_sigintrp:
X?S:	This variable conditionally defines the HAS_SIGINTRP symbol, which
X?S:	indicates that the siginterrupt() routine is available.
X?S:.
X?S:d_sigaction:
X?S:	This variable conditionally defines the HAS_SIGACTION symbol, which
X?S:	indicates that the Vr4 sigaction() routine is available.
X?S:.
X?C:HAS_SIGVEC (SIGVEC):
X?C:	This symbol, if defined, indicates that BSD reliable signals are
X?C:	supported.
X?C:.
X?C:HAS_SIGVECTOR (SIGVECTOR):
X?C:	This symbol, if defined, indicates that the sigvec() routine is called
X?C:	sigvector() instead, and that sigspace() is provided instead of
X?C:	sigstack().  This is probably only true for HP-UX.
X?C:.
X?C:HAS_SIGINTRP (SIGINTRP):
X?C:	This symbol, if defined, indicates that the siginterrupt() routine
X?C:	is available.
X?C:.
X?C:HAS_SIGACTION:
X?C:	This symbol, if defined, indicates that Vr4's sigaction() routine
X?C:	is available.
X?C:.
X?H:#$d_sigvec HAS_SIGVEC	/**/
X?H:#$d_sigvectr HAS_SIGVECTOR	/**/
X?H:#$d_sigintrp HAS_SIGINTRP	/**/
X?H:#$d_sigaction HAS_SIGACTION	/**/
X?H:.
X?T:val
X?LINT:set d_sigvec d_sigintrp d_sigaction
X: see if sigvector exists -- since sigvec will match the substring
Xecho " "
Xif set sigvector val -f d_sigvectr; eval $csym; $val; then
X	echo 'sigvector() found--you must be running HP-UX.' >&4
X	val="$define"; set d_sigvectr; eval $setvar
X	val="$define"; set d_sigvec; eval $setvar
Xelse
X: try the original name
X	d_sigvectr="$undef"
X	if set sigvec val -f d_sigvec; eval $csym; $val; then
X		echo 'sigvec() found.' >&4
X		val="$define"; set d_sigvec; eval $setvar
X	else
X		echo 'sigvec() not found--race conditions with signals may occur.' >&4
X		val="$undef"; set d_sigvec; eval $setvar
X	fi
Xfi
X
X@if d_sigintrp || HAS_SIGINTRP
X: see if we have siginterrupt
Xset siginterrupt d_sigintrp
Xeval $inlibc
X
X@end
X@if d_sigaction || HAS_SIGACTION
X: see if we have sigaction
Xset sigaction d_sigaction
Xeval $inlibc
X
X@end
END_OF_FILE
  if test 2938 -ne `wc -c <'mcon/U/d_sigvec.U'`; then
    echo shar: \"'mcon/U/d_sigvec.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_sigvec.U'
fi
if test -f 'mcon/U/mansrc.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/mansrc.U'\"
else
  echo shar: Extracting \"'mcon/U/mansrc.U'\" \(3097 characters\)
  sed "s/^X//" >'mcon/U/mansrc.U' <<'END_OF_FILE'
X?RCS: $Id: mansrc.U,v 3.0 1993/08/18 12:09:14 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: mansrc.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:14  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:mansrc mansrcexp manext installmansrc: afs cat nroff Loc Oldconfig \
X	sysman package test Getfile
X?MAKE:	-pick add $@ %<
X?S:mansrc:
X?S:	This variable contains the name of the directory in which manual
X?S:	source pages are to be put.  It is the responsibility of the
X?S:	Makefile.SH to get the value of this into the proper command.
X?S:	You must be prepared to do the ~name expansion yourself.
X?S:.
X?S:mansrcexp:
X?S:	This variable is the same as the mansrc variable, but is filename
X?S:	expanded at configuration time, for convenient use in makefiles.
X?S:.
X?S:installmansrc:
X?S:	This variable is really the same as mansrcexp, unless you are using
X?S:	AFS in which case it points to the read/write location whereas
X?S:	mansrcexp only points to the read-only access location. For extra
X?S:	portability, you should only use this variable within your makefiles.
X?S:.
X?S:manext:
X?S:	This variable contains the extension that the manual page should
X?S:	have: one of 'n', 'l', or '1'.  The Makefile must supply the '.'.
X?S:	See mansrc.
X?S:.
X?T:lookpath
X: determine where manual pages go
X$cat <<EOM
X
X$package has manual pages available in source form.
XEOM
Xcase "$nroff" in
Xnroff)
X	echo "However, you don't have nroff, so they're probably useless to you."
X	case "$mansrc" in
X	'') mansrc="none";;
X	esac;;
Xesac
Xecho "If you don't want the manual sources installed, answer 'none'."
Xcase "$mansrc" in
X'')
X	lookpath='/usr/local/man/man1 /usr/local/man/man1 /usr/man/manl'
X	lookpath="$lookpath /usr/man/local/man1 /usr/man/l_man/man1"
X	lookpath="$lookpath /usr/local/man/u_man/man1 /usr/local/man/l_man/man1"
X	lookpath="$lookpath /usr/man/man.L"
X	mansrc=`./loc . $lookpath`
X	if $test -d "$mansrc"; then
X		dflt="$mansrc"
X	else
X		dflt="$sysman"
X	fi
X	;;
X*)  dflt="$mansrc"
X	;;
Xesac
Xecho " "
Xfn=dn~
Xrp='Where do the manual pages (source) go?'
X. ./getfile
Xmansrc="$ans"
Xmansrcexp="$ansexp"
Xif $afs; then
X	$cat <<EOM
X
XSince you are running AFS, I need to distinguish the directory in which
Xmanual page reside from the directory in which they are installed (and from
Xwhich they are presumably copied to the former directory by occult means).
X
XEOM
X	case "$installmansrc" in
X	'') dflt=`echo $mansrcexp | sed 's#^/afs/#/afs/.#'`;;
X	*) dflt="$installmansrc";;
X	esac
X	fn=de~
X	rp='Where will public executables be installed?'
X	. ./getfile
X	installmansrc="$ans"
Xelse
X	installmansrc="$mansrcexp"
Xfi
X
X
Xcase "$mansrc" in
X'') manext='0';;
X*l) manext=l;;
X*n) manext=n;;
X*o) manext=l;;
X*p) manext=n;;
X*C) manext=C;;
X*L) manext=L;;
X*) manext=1;;
Xesac
X
END_OF_FILE
  if test 3097 -ne `wc -c <'mcon/U/mansrc.U'`; then
    echo shar: \"'mcon/U/mansrc.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/mansrc.U'
fi
if test -f 'mcon/U/nis.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/nis.U'\"
else
  echo shar: Extracting \"'mcon/U/nis.U'\" \(3395 characters\)
  sed "s/^X//" >'mcon/U/nis.U' <<'END_OF_FILE'
X?RCS: $Id: nis.U,v 3.0 1993/08/18 12:09:24 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: nis.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:24  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:passcat groupcat hostcat: Myread Oldconfig test contains
X?MAKE:	-pick add $@ %<
X?S:passcat:
X?S:	This variable contains a command that produces the text of the
X?S:	/etc/passwd file.  This is normally "cat /etc/passwd", but can be
X?S:	"ypcat passwd" when NIS is used.
X?S:.
X?S:groupcat:
X?S:	This variable contains a command that produces the text of the
X?S:	/etc/group file.  This is normally "cat /etc/group", but can be
X?S:	"ypcat group" when NIS is used.
X?S:.
X?S:hostcat:
X?S:	This variable contains a command that produces the text of the
X?S:	/etc/hosts file.  This is normally "cat /etc/hosts", but can be
X?S:	"ypcat hosts" when NIS is used.
X?S:.
X: see if we have to deal with yellow pages, now NIS.
X?X: NeXT gives us some fun here, as always, by having both NIS (former YP)
X?X: and NetInfo. But since it has both, it's ok to put the test inside the if.
X?X: Contributed by Thomas Neumann <tom@smart.bo.open.de>.
Xif $test -d /usr/etc/yp || $test -d /etc/yp; then
X	if $test -f /usr/etc/nibindd; then
X		echo " "
X		echo "I'm fairly confident you're on a NeXT."
X@if passcat || groupcat
X		echo " "
X		rp='Do you get the passwd file via NetInfo?'
X		dflt=y
X		case "$passcat" in
X		nidump*) ;;
X		'') ;;
X		*) dflt=n;;
X		esac
X		. ./myread
X		case "$ans" in
X		y*) passcat='nidump passwd .'
X@if groupcat
X			echo "(Assuming /etc/group is also distributed.)"
X			groupcat='nidump group .'
X@end
X			;;
X		*)	echo "You told me, so don't blame me."
X			passcat='cat /etc/passwd'
X@if groupcat
X			echo "(Assuming /etc/group is also local.)"
X			groupcat='cat /etc/group'
X@end
X			;;
X		esac
X@end
X@if hostcat
X		echo " "
X		rp='Do you get the hosts file via NetInfo?'
X		dflt=y
X		case "$hostcat" in
X		nidump*) ;;
X		'') ;;
X		*) dflt=n;;
X		esac
X		. ./myread
X		case "$ans" in
X		y*) hostcat='nidump hosts .';;
X		*) hostcat='cat /etc/hosts';;
X		esac
X@end
X	fi
X@if passcat || groupcat
X	case "$passcat" in
X	nidump*) ;;
X	*)
X		case "$passcat" in
X		*ypcat*) dflt=y;;
X		'') if $contains '^\+' /etc/passwd >/dev/null 2>&1; then
X				dflt=y
X			else
X				dflt=n
X			fi;;
X		*) dflt=n;;
X		esac
X		echo " "
X		rp='Are you getting the passwd file via yellow pages?'
X		. ./myread
X		case "$ans" in
X		y*) passcat='ypcat passwd'
X@if groupcat
X			echo "(Assuming /etc/group is also distributed.)"
X			groupcat='ypcat group'
X@end
X			;;
X		*)	passcat='cat /etc/passwd'
X@if groupcat
X			echo "(Assuming /etc/group is also local.)"
X			groupcat='cat /etc/group'
X@end
X			;;
X		esac
X		;;
X	esac
X@end
X@if hostcat
X	case "$hostcat" in
X	nidump*) ;;
X	*)
X		case "$hostcat" in
X		*ypcat*) dflt=y;;
X		'') if $contains '^\+' /etc/passwd >/dev/null 2>&1; then
X				dflt=y
X			else
X				dflt=n
X			fi;;
X		*) dflt=n;;
X		esac
X		echo " "
X		rp='Are you getting the hosts file via yellow pages?'
X		. ./myread
X		case "$ans" in
X		y*) hostcat='ypcat hosts';;
X		*) hostcat='cat /etc/hosts';;
X		esac
X		;;
X	esac
X@end
Xfi
X
END_OF_FILE
  if test 3395 -ne `wc -c <'mcon/U/nis.U'`; then
    echo shar: \"'mcon/U/nis.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/nis.U'
fi
if test -f 'mcon/U/privlib.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/privlib.U'\"
else
  echo shar: Extracting \"'mcon/U/privlib.U'\" \(2819 characters\)
  sed "s/^X//" >'mcon/U/privlib.U' <<'END_OF_FILE'
X?RCS: $Id: privlib.U,v 3.0 1993/08/18 12:09:35 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: privlib.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:35  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:privlib privlibexp installprivlib: afs package test cat Getfile \
X	Oldconfig
X?MAKE:	-pick add $@ %<
X?S:privlib:
X?S:	This variable contains the eventual value of the PRIVLIB symbol,
X?S:	which is the name of the private library for this package.  It may
X?S:	have a ~ on the front. It is up to the makefile to eventually create
X?S:	this directory while performing installation (with ~ substitution).
X?S:.
X?S:privlibexp:
X?S:	This variable is the ~name expanded version of privlib, so that you
X?S:	may use it directly in Makefiles or shell scripts.
X?S:.
X?S:installprivlib:
X?S:	This variable is really the same as privlibexp but may differ on
X?S:	those systems using AFS. For extra portability, only this variable
X?S:	should be used in makefiles.
X?S:.
X?C:PRIVLIB:
X?C:	This symbol contains the name of the private library for this package.
X?C:	The library is private in the sense that it needn't be in anyone's
X?C:	execution path, but it should be accessible by the world.  The program
X?C:	should be prepared to do ~ expansion.
X?C:.
X?C:PRIVLIB_EXP:
X?C:	This symbol contains the ~name expanded version of PRIVLIB, to be used
X?C:	in programs that are not prepared to deal with ~ expansion at run-time.
X?C:.
X?H:#define PRIVLIB "$privlib"		/**/
X?H:#define PRIVLIB_EXP "$privlibexp"		/**/
X?H:.
X: determine where private executables go
Xcase "$privlib" in
X'')
X	dflt=/usr/lib/$package
X	$test -d /usr/local/lib && dflt=/usr/local/lib/$package
X	;;
X*)  dflt="$privlib"
X	;;
Xesac
X$cat <<EOM
X
XThe $package package has some auxiliary files that should be put in a library
Xthat is accessible by everyone.  Where do you want to put these "private" but
Xaccessible files?
X
XEOM
Xfn=d~+
Xrp='Private library path?'
X. ./getfile
Xprivlib="$ans"
Xprivlibexp="$ansexp"
Xif $afs; then
X	$cat <<EOM
X
XSince you are running AFS, I need to distinguish the directory in which
Xprivate file reside from the directory in which they are installed (and from
Xwhich they are presumably copied to the former directory by occult means).
X
XEOM
X	case "$installprivlib" in
X	'') dflt=`echo $privlibexp | sed 's#^/afs/#/afs/.#'`;;
X	*) dflt="$installprivlib";;
X	esac
X	fn=de~
X	rp='Where will private files be installed?'
X	. ./getfile
X	installprivlib="$ans"
Xelse
X	installprivlib="$privlibexp"
Xfi
X
END_OF_FILE
  if test 2819 -ne `wc -c <'mcon/U/privlib.U'`; then
    echo shar: \"'mcon/U/privlib.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/privlib.U'
fi
if test -f 'mcon/U/scriptdir.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/scriptdir.U'\"
else
  echo shar: Extracting \"'mcon/U/scriptdir.U'\" \(3243 characters\)
  sed "s/^X//" >'mcon/U/scriptdir.U' <<'END_OF_FILE'
X?RCS: $Id: scriptdir.U,v 3.0 1993/08/18 12:09:45 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: scriptdir.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:45  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:scriptdir scriptdirexp installscript: afs cat test Getfile Loc \
X	Oldconfig +bin
X?MAKE:	-pick add $@ %<
X?S:scriptdir:
X?S:	This variable holds the name of the directory in which the user wants
X?S:	to put publicly scripts for the package in question.  It is either
X?S:	the same directory as for binaries, or a special one that can be
X?S:	mounted across different architectures, like /usr/share. Programs
X?S:	must be prepared to deal with ~name expansion.
X?S:.
X?S:scriptdirexp:
X?S:	This variable is the same as scriptdir, but is filename expanded
X?S:	at configuration time, for programs not wanting to bother with it.
X?S:.
X?S:installscript:
X?S:	This variable is usually the same as scriptdirexp, unless you are on
X?S:	a system running AFS, in which case they may differ slightly. You
X?S:	should always use this variable within your makefiles for portability.
X?S:.
X?C:SCRIPTDIR:
X?C:	This symbol holds the name of the directory in which the user wants
X?C:	to put publicly executable scripts for the package in question.  It
X?C:	is often a directory that is mounted across diverse architectures.
X?C:	Programs must be prepared to deal with ~name expansion.
X?C:.
X?C:SCRIPTDIR_EXP:
X?C:	This is the same as SCRIPTDIR, but is filename expanded at
X?C:	configuration time, for use in programs not prepared to do
X?C:	~name substitutions at run-time.
X?C:.
X?H:#define SCRIPTDIR "$scriptdir"	/**/
X?H:#define SCRIPTDIR_EXP "$scriptdirexp"	/**/
X?H:.
X: determine where public executables go
Xcase "$scriptdir" in
X'')
X	dflt="$bin"
X	: guess some guesses
X	$test -d /usr/share/scripts && dflt=/usr/share/scripts
X	$test -d /usr/share/bin && dflt=/usr/share/bin
X	$test -d /usr/local/script && dflt=/usr/local/script
X	;;
X*)  dflt="$scriptdir"
X	;;
Xesac
X$cat <<EOM
X 
XSome installations have a separate directory just for executable scripts so
Xthat they can mount it across multiple architectures but keep the scripts in
Xone spot.  You might, for example, have a subdirectory of /usr/share for this.
XOr you might just lump your scripts in with all your other executables.
X 
XEOM
Xfn=d~
Xrp='Where do you keep publicly executable scripts?'
X. ./getfile
Xscriptdir="$ans"
Xscriptdirexp="$ansexp"
Xif $afs; then
X	$cat <<EOM
X
XSince you are running AFS, I need to distinguish the directory in which
Xscripts reside from the directory in which they are installed (and from
Xwhich they are presumably copied to the former directory by occult means).
X
XEOM
X	case "$installscript" in
X	'') dflt=`echo $scriptdirexp | sed 's#^/afs/#/afs/.#'`;;
X	*) dflt="$installscript";;
X	esac
X	fn=de~
X	rp='Where will public scripts be installed?'
X	. ./getfile
X	installscript="$ans"
Xelse
X	installscript="$scriptdirexp"
Xfi
X
END_OF_FILE
  if test 3243 -ne `wc -c <'mcon/U/scriptdir.U'`; then
    echo shar: \"'mcon/U/scriptdir.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/scriptdir.U'
fi
if test -f 'mcon/U/shm_for.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/shm_for.U'\"
else
  echo shar: Extracting \"'mcon/U/shm_for.U'\" \(3044 characters\)
  sed "s/^X//" >'mcon/U/shm_for.U' <<'END_OF_FILE'
X?RCS: $Id: shm_for.U,v 3.0 1993/08/18 12:09:46 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: shm_for.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:46  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:shm_for shm_att shm_lim: Cppsym Myread ipc uname
X?MAKE:	-pick add $@ %<
X?S:shm_for:
X?S:	This variable tells us the type of machine we're expecting the
X?S:	shared memory code to run on.  The value is available to C programs
X?S:	in the C_SHM_FOR manifest.
X?S:.
X?S:shm_att:
X?S:	This variable tells us where a shared memory segment should be
X?S:	attached.  Good values are HIGH, LOW, and ZERO.
X?S:.
X?S:shm_lim:
X?S:	This variable tells us if shared memory attached HIGH should
X?S:	have an upper limit.
X?S:.
X?X:	----------------------------------------------------------
X?X: It's a potential lose to define anything beginning with SHM...
X?X: At least we can think that S_ stands for "String version of ..." -- HMS
X?X:	----------------------------------------------------------
X?C:S_SHM_FOR ~ %<:
X?C:	This symbol identifies what we chose for the target system's
X?C:	default shared memory configuration parameters.
X?C:.
X?C:S_SHM_ATT ~ %<:
X?C:	This symbol holds the default "place" to attach shared memory.
X?C:	Values are "HIGH", "ZERO", and "LOW".
X?C:.
X?C:S_SHM_LIM ~ %<:
X?C:	This symbol holds the default upper bound address limit if shared
X?C:	memory is attached HIGH.  If zero, there is no upper limit.
X?C:.
X?H:?%<:#ifdef SERVE_SHM
X?H:?%<:#define S_SHM_FOR "$shm_for"
X?H:?%<:#define S_SHM_ATT "$shm_att"
X?H:?%<:#define S_SHM_LIM "$shm_lim"
X?H:?%<:#endif
X?H:.
X?W:%<:S_SHM_FOR S_SHM_ATT S_SHM_LIM
X: see how to attach shared memory
Xecho " "
Xecho "Deciding how to attach shared memory..." >&4
X
Xcase "$ipc" in
Xshm)
X	shm_for='Default case'
X	shm_att='HIGH'
X	shm_lim='0x0'
X	if Cppsym tower32 tower32_600; then
X		echo "NCR Towers are usually normal..."
X		: echo "Oh, an NCR Tower."
X		: This works for the 600
X		shm_for='NCR Tower 32'
X		shm_att='LOW'
X	else
X		case "$uname" in
X		*/uname)
X			case "`uname -m`" in
X			ACS??68*)
X				echo "Oh, an Altos 3068."
X				shm_for='Altos 3068:'
X				shm_lim='0x800000'
X				;;
X				esac
X				;;
X		*)
X			echo "Looks normal to me..."
X			;;
X		esac
X	fi
X
X	dflt="$shm_for"
X	rp='Description of shared memory configuration?'
X	. ./myread
X	shm_for="$ans"
X
X	dflt="$shm_att"
X	rp='Where should shared memory be attached?'
X	. ./myread
X	shm_att="$ans"
X
X	case "$shm_att" in
X	HIGH)
X		dflt="$shm_lim"
X		rp='What is the upper address limit for shared memory?'
X		. ./myread
X		shm_lim="$ans"
X		;;
X	*)
X		shm_lim=''
X		;;
X	esac
X	;;
X
X*)
X	echo "but you aren't using shared memory so I won't bother." >&4
X	shm_for='NOT CONFIGURED'
X	shm_att='NONE'
X	shm_lim='-1'
X	;;
Xesac
X
END_OF_FILE
  if test 3044 -ne `wc -c <'mcon/U/shm_for.U'`; then
    echo shar: \"'mcon/U/shm_for.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/shm_for.U'
fi
if test -f 'mcon/mlint.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/mlint.SH'\"
else
  echo shar: Extracting \"'mcon/mlint.SH'\" \(3211 characters\)
  sed "s/^X//" >'mcon/mlint.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting mcon/mlint (with variable substitutions)"
Xcat >mlint <<!GROK!THIS!
X$startperl
X	eval "exec perl -S \$0 \$*"
X		if \$running_under_some_shell;
X
X# $Id: mlint.SH,v 3.0 1993/08/18 12:10:17 ram Exp $
X#
X#  Copyright (c) 1991-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic Licence,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic Licence; a copy of which may be found at the root
X#  of the source tree for dist 3.0.
X#
X# Original Author: Harlan Stenn <harlan@mumps.pfcs.com>
X#
X# $Log: mlint.SH,v $
X# Revision 3.0  1993/08/18  12:10:17  ram
X# Baseline for dist 3.0 netwide release.
X#
X
X# Perload ON
X
X\$MC = '$privlib';
X\$version = '$VERSION';
X\$patchlevel = '$PATCHLEVEL';
X\$grep = '$grep';
X!GROK!THIS!
X
X$spitshell >>mlint <<'!NO!SUBS!'
Xchop($date = `date`);
X$MC = &tilda_expand($MC);		# ~name expansion
Xchop($WD = `pwd`);				# Working directory
Xchdir $MC || die "Can't chdir to $MC: $!\n";
Xchop($MC = `pwd`);				# Real metalint lib path (no symbolic links)
Xchdir $WD || die "Can't chdir back to $WD: $!\n";
X
Xrequire 'getopts.pl';
X&usage unless &Getopts("hklV");
X
Xif ($opt_V) {
X	print STDERR "metalint $version PL$patchlevel\n";
X	exit 0;
X} elsif ($opt_h) {
X	&usage;
X}
X
X&init;									# Various initializations
X`mkdir .MT 2>&1` unless -d '.MT';		# For private temporary files
X
X&locate_units;				# Fill in @ARGV with a unit list
X&extract_dependencies;		# Extract dependencies from units
X&sanity_checks;				# Perform sanity checks
X
Xif ($opt_k) {
X	print "Leaving subdirectory .MT unremoved so you can peruse it.\n"
X		unless $opt_s;
X} else {
X	`rm -rf .MT 2>&1`;
X}
Xprint "Done.\n" unless $opt_s;
X
X# General initializations
Xsub init {
X	&init_except;			# Token which have upper-cased letters
X	&init_depend;			# The %Depend array records control line handling
X}
X
X# Record the exceptions -- all symbols but these are lower case
Xsub init_except {
X	$Except{'Mcc'}++;
X	$Except{'Author'}++;
X	$Except{'Date'}++;
X	$Except{'Header'}++;
X	$Except{'Id'}++;
X	$Except{'Locker'}++;
X	$Except{'Log'}++;
X	$Except{'RCSfile'}++;
X	$Except{'Revision'}++;
X	$Except{'Source'}++;
X	$Except{'State'}++;
X}
X
X# Print out metalint's usage and exits
Xsub usage {
X	print STDERR <<EOM;
XUsage: metalint [-hklsV]
X  -h : print this help message and exits.
X  -k : keep temporary directory.
X  -l : also report problems from library units.
X  -s : silent mode.
X  -V : print version number and exits.
XEOM
X	exit 1;
X}
X
X!NO!SUBS!
X$grep -v '^;#' pl/locate.pl >>mlint 
X$grep -v '^;#' pl/lint.pl >>mlint 
X$grep -v '^;#' pl/init.pl >>mlint 
X$grep -v '^;#' pl/extract.pl >>mlint 
X$grep -v '^;#' pl/obsolete.pl >>mlint 
X$grep -v '^;#' pl/tsort.pl >>mlint 
X$grep -v '^;#' ../pl/tilde.pl >>mlint 
Xchmod +x mlint
X$eunicefix mlint
END_OF_FILE
  if test 3211 -ne `wc -c <'mcon/mlint.SH'`; then
    echo shar: \"'mcon/mlint.SH'\" unpacked with wrong size!
  fi
  # end of 'mcon/mlint.SH'
fi
if test -f 'pat/pat.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pat/pat.SH'\"
else
  echo shar: Extracting \"'pat/pat.SH'\" \(3159 characters\)
  sed "s/^X//" >'pat/pat.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting pat/pat (with variable substitutions)"
Xcat >pat <<!GROK!THIS!
X$startperl
X	eval "exec perl -S \$0 \$*"
X		if \$running_under_some_shell;
X
X# $Id: pat.SH,v 3.0 1993/08/18 12:10:36 ram Exp $
X#
X#  Copyright (c) 1991-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic Licence,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic Licence; a copy of which may be found at the root
X#  of the source tree for dist 3.0.
X#
X# Original Author: Larry Wall <lwall@netlabs.com>
X#
X# $Log: pat.SH,v $
X# Revision 3.0  1993/08/18  12:10:36  ram
X# Baseline for dist 3.0 netwide release.
X#
X
X\$version = '$VERSION';
X\$patchlevel = '$PATCHLEVEL';
X!GROK!THIS!
Xcat >>pat <<'!NO!SUBS!'
X
Xrequire 'getopts.pl';
X&usage unless $#ARGV >= 0;
X&usage unless &Getopts("ahmnV");
X
Xif ($opt_V) {
X	print STDERR "pat $version PL$patchlevel\n";
X	exit 0;
X} elsif ($opt_h) {
X	&usage;
X}
X
X&readpackage;
X
Xif (-f 'patchlevel.h') {
X	open(PL,"patchlevel.h") || die "Can't open patchlevel.h\n";
X	while (<PL>) {
X		$bnum = $1 if /^#define\s+PATCHLEVEL\s+(\d+)/;
X	}
X	die "Malformed patchlevel.h file.\n" if $bnum eq '';
X	++$bnum;
X} else {
X	$bnum=1;
X}
X
X$cpat = $bnum - 1;		# Current patch level
X
Xif ($opt_n) {
X	&newer;				# Look for files newer than patchlevel.h
X} elsif ($opt_a) {
X	open(MANI,"MANIFEST.new") || die "No MANIFEST.new found.\n";
X	@ARGV = ();
X	while (<MANI>) {
X		s|^\./||;
X		next if m|^patchlevel.h|;		# This file is built by hand
X		chop;
X		($_) = split(' ');
X		next if -d;
X		push(@ARGV,$_);
X	}
X	close MANI;
X} elsif ($opt_m) {
X	open(MODS,"bugs/.mods$bnum") || die "No modification found.\n";
X	@ARGV = ();
X	while (<MODS>) {
X		next if m|^patchlevel.h$|;		# This file is built by hand
X		chop;
X		($_) = split(' ');
X		push(@ARGV,$_);
X	}
X	close MODS;
X}
X
Xunlink <bugs/*.$cpat bugs/.logs$cpat bugs/.mods$cpat>;
X
Xsystem 'perl', '-S', 'patcil', '-p', @ARGV;
X
X# Update MANIFEST if necessary, then patcil it.
X
Xif (-f 'MANIFEST' && `diff MANIFEST.new MANIFEST 2>/dev/null` ne '') {
X	system 'cp', 'MANIFEST.new', 'MANIFEST';
X	system 'perl', '-S', 'patcil', '-p', 'MANIFEST';
X	push(@ARGV, 'MANIFEST');
X}
X
Xsystem 'perl', '-S', 'patdiff', @ARGV;
Xsystem 'perl', '-S', 'patmake';
X
Xsub usage {
X	print STDERR "Usage: pat [-ahmnV] [filelist]\n";
X	print STDERR "  -a : all the files in MANIFEST.new\n";
X	print STDERR "  -h : print this message and exit\n";
X	print STDERR "  -m : all the modified files (which have been patciled)\n";
X	print STDERR "  -n : all the files newer than patchlevel.h\n";
X	print STDERR "  -V : print version number and exit\n";
X	exit 1;
X}
X
X!NO!SUBS!
X$grep -v '^;#' ../pl/newer.pl >>pat
X$grep -v '^;#' ../pl/package.pl >>pat
Xchmod +x pat
X$eunicefix pat
END_OF_FILE
  if test 3159 -ne `wc -c <'pat/pat.SH'`; then
    echo shar: \"'pat/pat.SH'\" unpacked with wrong size!
  fi
  # end of 'pat/pat.SH'
fi
if test -f 'pat/patbase.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pat/patbase.SH'\"
else
  echo shar: Extracting \"'pat/patbase.SH'\" \(2870 characters\)
  sed "s/^X//" >'pat/patbase.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting pat/patbase (with variable substitutions)"
Xcat >patbase <<!GROK!THIS!
X$startperl
X	eval "exec perl -S \$0 \$*"
X		if \$running_under_some_shell;
X
X# $Id: patbase.SH,v 3.0 1993/08/18 12:10:38 ram Exp $
X#
X#  Copyright (c) 1991-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic Licence,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic Licence; a copy of which may be found at the root
X#  of the source tree for dist 3.0.
X#
X# Original Author: Larry Wall <lwall@netlabs.com>
X#
X# $Log: patbase.SH,v $
X# Revision 3.0  1993/08/18  12:10:38  ram
X# Baseline for dist 3.0 netwide release.
X#
X
X\$version = '$VERSION';
X\$patchlevel = '$PATCHLEVEL';
X!GROK!THIS!
Xcat >>patbase <<'!NO!SUBS!'
X
X$progname = 'patbase';		# My name
X
Xrequire 'getopts.pl';
X&usage unless $#ARGV >= 0;
X&usage unless &Getopts("ahV");
X
Xif ($opt_V) {
X	print STDERR "$progname $version PL$patchlevel\n";
X	exit 0;
X} elsif ($opt_h) {
X	&usage;
X}
X
X$RCSEXT = ',v' unless $RCSEXT;
X&readpackage;
X
X$RCSEXT = ',v' unless $RCSEXT;
X$TOPDIR = '';			# We are at the top-level directory
X
Xif ($opt_a) {
X	open(MANI,"MANIFEST.new") || die "No MANIFEST.new found.\n";
X	@ARGV = ();
X	while (<MANI>) {
X		chop;
X		s|^\./||;
X		next if m|^patchlevel.h|;		# Special file
X		($_) = split(' ');
X		next if -d;
X		push(@ARGV,$_);
X	}
X	close MANI;
X}
X
Xforeach $file (@ARGV) {
X	$files = &rcsargs($file);
X	@files = split(' ',$files);
X	$revs=0;
X	$rlog = `rlog -r$baserev -r$revbranch $files 2>&1`;
X	($revs) = ($rlog =~ /selected revisions: (\d+)/);
X	if (!$revs) {
X		print "$progname: $file has never been checked in--checking in...\n";
X		system 'perl', '-S', 'patcil', $file;
X	}
X	elsif ($revs == 1) {
X		print "Last revision for $file is $baserev.\n";
X		system 'rcs', "-Nlastpat:$baserev", @files;
X	}
X	else {
X		($lastrev) = ($rlog =~ /revision $revbranch\.(\d+)/);
X		print "Last revision for $file is $revbranch.$lastrev.\n";
X		system 'rcs', "-Nlastpat:$revbranch.$lastrev", @files;
X	}
X}
X
Xsub usage {
X	print STDERR "Usage: $progname [-ahV] [filelist]\n";
X	print STDERR "  -a : all the files in MANIFEST.new\n";
X	print STDERR "  -h : print this message and exit\n";
X	print STDERR "  -V : print version number and exit\n";
X	exit 1;
X}
X
X!NO!SUBS!
X$grep -v '^;#' ../pl/package.pl >>patbase
X$grep -v '^;#' ../pl/rcsargs.pl >>patbase
X$grep -v '^;#' ../pl/comment.pl >>patbase
Xchmod +x patbase
X$eunicefix patbase
END_OF_FILE
  if test 2870 -ne `wc -c <'pat/patbase.SH'`; then
    echo shar: \"'pat/patbase.SH'\" unpacked with wrong size!
  fi
  # end of 'pat/patbase.SH'
fi
echo shar: End of archive 16 \(of 28\).
cp /dev/null ark16isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Please run PACKNOTES through sh, read REAMDE and then type Configure."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
