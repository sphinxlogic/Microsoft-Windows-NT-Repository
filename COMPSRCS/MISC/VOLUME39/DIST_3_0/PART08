Newsgroups: comp.sources.misc
From: Raphael Manfredi <ram@acri.fr>
Subject: v39i012:  dist-3.0 - Configure script generator and related tools, Part08/28
Message-ID: <1993Aug18.184144.17503@sparky.sterling.com>
X-Md4-Signature: 159f83bddf454a6dfd2fa0b17d979ce5
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Advanced Computer Research Institute, Lyon, France.
Date: Wed, 18 Aug 1993 18:41:44 GMT
Approved: kent@sparky.sterling.com

Submitted-by: Raphael Manfredi <ram@acri.fr>
Posting-number: Volume 39, Issue 12
Archive-name: dist-3.0/part08
Environment: UNIX, Perl, RCS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  bin/manilist.man jmake/jmake.SH jmake/jmake.man
#   mcon/pl/wanted.pl pat/pat.man
# Wrapped by ram@soft208 on Wed Aug 18 14:42:19 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 8 (of 28)."'
if test -f 'bin/manilist.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bin/manilist.man'\"
else
  echo shar: Extracting \"'bin/manilist.man'\" \(10961 characters\)
  sed "s/^X//" >'bin/manilist.man' <<'END_OF_FILE'
X''' $Id: manilist.man,v 3.0 1993/08/18 12:04:04 ram Exp $
X'''
X'''  Copyright (c) 1991-1993, Raphael Manfredi
X'''  
X'''  You may redistribute only under the terms of the Artistic Licence,
X'''  as specified in the README file that comes with the distribution.
X'''  You may reuse parts of this distribution only within the terms of
X'''  that same Artistic Licence; a copy of which may be found at the root
X'''  of the source tree for dist 3.0.
X'''
X''' $Log: manilist.man,v $
X''' Revision 3.0  1993/08/18  12:04:04  ram
X''' Baseline for dist 3.0 netwide release.
X'''
X''' 
X.TH MANILIST 1 ram
X.SH NAME
Xmanilist \- report status of files in a source directory
X.SH SYNOPSIS
X.B manilist
X[
X.B \-abcdhnptV
X] [
X.B \-i
X.I extension
X] [
X.B \-f
X.I manifest
X] [
X.B \-p
X.I format
X] [
X.B \-s
X.I string
X] [
X.B \-w
X.I which
X] [
X.B \-x
X.I extension
X] [
X.B \-C
X.I separator
X] [
X.B \-I
X.I included
X] [
X.B \-L
X.I colsize
X] [
X.B \-X
X.I excluded
X] [
X.I files or directories
X]
X.SH DESCRIPTION
X.I Manilist
Xscans a source directory and produces a report on the status of each file:
Xwhether it is up-to-date or not with respect to
X.I patchlevel.h ,
Xif it is missing from MANIFEST.new, and some other useful information which
Xmay be dynamically configured. It can be use to maintain a MANIFEST.new file,
Xproduce a detailed listing and status of a group of directories, etc... The
Xrich set of options concur to make \fImanilist\fR a perfect low-level tool.
X.PP
XUnder its simplest invocation form at the top level directory of a package,
Xwith no arguments, \fImanilist\fR will scan the MANIFEST.new and produce
Xa report on the status of each file listed there. Each line starts with a
Xsingle character flag which indicates the state of the file, followed by the
Xname of the file.
X.PP
XWhat happens in fact is more complex than that. \fIManilist\fR scans the
XMANIFEST.new file and then loops over all the files listed there. Internally,
X\fImanilist\fR maintains an inclusion and an exclusion list, both specifying
Xextensions for files. For instance, the inclusion list could be ('.c', '.h')
Xand the exclusion ('.o', ',v') so that C sources are included and object
Xor RCS files excluded. By default, all files but those excluded are used.
XSome other selections may be applied at this stage, as will be explained later
Xon. For those files which pass this selection process, a report is issued
Xaccording to a report \fIformat\fR, which by default is "\fIA:%c %n\fR".
XThe letter \fIA\fR (or anything before the initial ':' character is the
Xfile selection specification we've been talking about. The remaining is the
Xformatting, a string which is printed as-is, modulo some escape sequences.
XIt so happens that \fI%c\fR is the character flag and \fI%n\fR is the name
Xof the current file.
X.PP
XGenerally speaking, \fImanilist\fR should be regarded as a tool which emits
Xconfigurable reports on a set of files, selectively picking them among a list
Xor by directly scanning the directories to see what's out there...
X.PP
XBy specifying a set of directories or files as arguments on the command line,
Xyou restrict the scanning area, limiting to reports concerning those files
Xor directories. If you do not specify any, manilist restricts its report to
Xthe current directory and its subdirectories, unless the \fB\-t\fR option is
Xgiven.
X.SH OPTIONS
X.I Manilist
Xrecognizes the following options:
X.TP 15
X.B \-a
XMake a report for \fIall\fR the files, regardless of what is specified by
Xthe \fIincluded\fR and \fIexcluded\fR suffix lists.
X.TP
X.B \-b
XAssume current directory is the base (root) of the package tree. When this
Xoption is not specified, \fImanilist\fR will look for a \fI.package\fR file
Xto indicate the root directory of the package (also called the top) and
Xcomplain if it does not find it.
X.TP
X.B \-c
XCheck files against those listed in MANIFEST.new (or whatever file specified
Xvia the \fB\-f\fR option) and report discrepancies via the \fI%c\fR macro.
X.TP
X.B \-d
XDump included and excluded suffix lists on stderr, extensions being space
Xseparated. A good way to know the default lists is to run: \fImanilist
X\-f /dev/null \-bd.
X.TP
X.B \-f\fI manifest
XSpecify an alternate manifest file, the default being to use MANIFEST.new.
X.TP
X.B \-h
XPrint the usage help message and exit.
X.TP
X.B \-i\fI extensions
XAdd new extensions to the included suffix list. The \fIextensions\fR argument
Xmust list the suffixes separated by spaces, as in \fB\-i\fI '.ph .pl'\fR to add
Xboth \fI.ph\fR and \fI.pl\fR to the existing suffixes. Note that the argument
Xneeds to be quoted to protect spaces against shell interpretation.
X.TP
X.B \-n
XDo not use any manifest file. Rather scan the directories and act as with all
Xthe files there were already listed in a manifest.
X.TP
X.B \-p\fI format
XSet the new printing format, which has the form \fIselection\fR:\fIstring\fR,
Xwith \fIselection\fR being a list of single letters specifying which files
Xfrom the manifest are to be used for reports, and \fIstring\fR being a
Xmessage to print as report, with some macro substitutions. It is also possible
Xto have column formatting by specifying a '|' inside the string to delimit
Xthe different columns you wish to see. See also \fB\-C\fR and \fB\-L\fR for
Xmore formatting parameters.
X.TP
X.B \-s\fI string
XSpecify the \fIstring\fR part of the printing format (see \fB\-p for a
Xgeneral description of the \fIformat\fR). Available macros are listed further
Xdown the manual page.
X.TP
X.B \-t
XStart from the top directory (the root directory of the distribution) regardless
Xof the current directory. There must be a \fI.package\fR file to indicate
Xwhat the top directory is.
X.TP
X.B \-w\fI selection
XSpecifiy the \fIselection\fR part of the printing format. Available selections
Xwill be discussed later.
X.TP
X.B \-x\fI extensions
XAdd new extensions to the excluded suffix list. The \fIextensions\fR argument
Xmust list the suffixes separated by spaces, as in \fB\-x\fI '.s .p'\fR to add
Xboth \fI.s\fR and \fI.p\fR to the existing list. Note that the argument
Xneeds to be quoted to protect spaces against shell interpretation.
X.TP
X.B \-C\fI separator
XGive the column separator, which is to be used in place of the '|' character
Xin the report format string. By default, it is a single space.
X.TP
X.B \-I\fI included
XSpecify a new list of suffixes to be included in the reports. This overrides
Xthe original default list (whereas \fB\-i\fR is used to \fIadd\fR suffixes to
Xthe list). Suffixes must be space separated.
X.TP
X.B \-L\fI colsize
XWhen using column formatting (the '|' character being used to denote columns),
Xthis option may be used to specify the maximum column width, separating each
Xwidth by a single ','. Leaving a width unspecified does not impose any limit
Xon its width. For instance, if the format string is \fI%n|%d|%t\fR, one could
Xlimit the middle column (descriptions from MANIFEST.new) to 40 characters and
Xthe name column (first one) to 15 characters, leaving the last one with no
Ximposed limits, by using \fB\-L\fI 15,40,\fR.
X.TP
X.B \-V
XPrint version number and exit.
X.TP
X.B \-I\fX excluded
XSpecify a new list of suffixes to be excluded in the reports. This overrides
Xthe original default list (whereas \fB\-x\fR is used to \fIadd\fR suffixes to
Xthe list). Suffixes must be space separated.
X.SH USING FORMATS
XThe flexibility of \fImanilist\fR is brought by its use of a dynamic formatting
Xstring for providing its reports. It is possible to specify a format via the
X\fB\-p\fR option or just parts of it: the text string via \fB\-s\fR and the
Xfile selection with \fB\-w\fR.
X.SS "File Selection"
X.PP
XThe leading part of the formatting string tells \fImanilist\fR which files you
Xwish to see in the final report. Available selectors are:
X.sp
X.PD 0
X.TP 5
X.B A
XAll the files but the excluded ones (i.e. those files whose suffix is listed
Xin the exclusion list). This is the default action.
X.TP
X.B a
XAll the files included and/or excluded (shortcut for \fIix\fR). Note that files
Xwhich are neither included nor excluded will not appear in the report.
X.TP
X.B d
XReport only for directories.
X.TP
X.B f
XReport only for files.
X.TP
X.B i
XOnly included files are listed.
X.TP
X.B m
XOnly those files or directories found in the manifest are listed.
X.TP
X.B n
XOnly those files or directories \fInot\fR found in the manifest are listed.
X.TP
X.B x
XOnly excluded files are listed.
X.PD
X.PP
XWhen you specify more than one letter, the resulting report depends on the
Xnature of the selection. For \fId\fR, \fIf\fR, \fIm\fR and \fIn\fR, a logical
Xunion is performed. This means specifying \fIfd\fR or \fImn\fR is the same
Xas not specifying anything, but it's less efficient since \fImanilist\fR is
Xforced to perform the checks it would otherwise bypass. The \fIi\fR and \fIx\fR
Xselectors are special: by default, all the files not excluded are reported.
XSpecifying \fIx\fR also asks for excluded files. Specifying \fIi\fR restricts
Xthe report to the included files. Using both at the same time (\fIix\fR) will
Xforce a report for files which are included or excluded.
X.SS "Macro Substitution"
X.PP
XThe string part of the report format can make use of the following macros:
X.sp
X.PD 0
X.TP 5
X%c
XA character coding the status of the file.
X.TP
X%d
XDescription from the manifest file, if any.
X.TP
X%n
XName of the file (its path from the top directory).
X.TP
X%s
XSize of the file, in bytes.
X.TP
X%t
XTime stamp of the last modification.
X.PD
X.SS "File Status"
X.PP
XThe \fI%c\fR macro, giving a single character coding the file status, can
Xexpand into one of the following.
X.PD 0
X.TP 5
X\&.
XThe file is up to date (not newer than \fIpatchlevel.h\fR).
X.TP
X-
XThe file is present in the manifest but is missing.
X.TP
X>
XThe file has been modified since last patch (newer than \fIpatchlevel.h\fR).
X.TP
X+
XThe file exists but is not listed in the manifest.
X.TP
Xo
XThe file exists but is not listed in the manifest and is older than
X\fIpatchlevel.h\fR
X.TP
Xx
XThe file is listed in the manifest and exists, but has been excluded. Naturally,
Xthis will appear in the report only if the \fIx\fR selector is given in the
Xreport format.
X.TP
X?
XThe file is listed in the manifest, does not exist, and was excluded.
X.PD
X.SH EXAMPLES
XThe command
X.in +5
X.nf
X.sp
X\fImanilist -ct -p 'ni:%n'\fR
X.sp
X.fi
X.in -5
Xwill list all the source files from your distribution which are not listed
Xin your MANIFEST.new file. Note that this includes only "source" files, that
Xis to say files whose extension is listed in the inclusion list.
XIf you do not wish this restriction, replace the formatting string with
X\fIn:%n\fR (only the excluded files will not appear).
X.PP
XTo build an initial MANIFEST file, use:
X.in +5
X.nf
X.sp
X\fImanilist -n -p 'Af:%n' > MANIFEST\fR
X.sp
X.fi
X.in -5
Xfrom the top directory. You will eventually want to fill in descriptions for
Xeach file listed in the manifest.
X.SH FILES
X.PD 0
X.TP 20
XMANIFEST.new
XDefault manifest file, listing files and giving a small description for each
Xof them.
X.PD
X.SH AUTHOR
XRaphael Manfredi <ram@acri.fr>
X.SH "SEE ALSO"
Xmanifake(1), makedist(1), pat(1).
END_OF_FILE
  if test 10961 -ne `wc -c <'bin/manilist.man'`; then
    echo shar: \"'bin/manilist.man'\" unpacked with wrong size!
  fi
  # end of 'bin/manilist.man'
fi
if test -f 'jmake/jmake.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jmake/jmake.SH'\"
else
  echo shar: Extracting \"'jmake/jmake.SH'\" \(11339 characters\)
  sed "s/^X//" >'jmake/jmake.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting jmake/jmake (with variable substitutions)"
X$spitshell >jmake <<!GROK!THIS!
X$startperl
X	eval 'exec perl -S \$0 "\$@"'
X		if \$runnning_under_some_shell;
X
X# $Id: jmake.SH,v 3.0 1993/08/18 12:04:17 ram Exp $
X#
X#  Copyright (c) 1991-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic Licence,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic Licence; a copy of which may be found at the root
X#  of the source tree for dist 3.0.
X#
X# $Log: jmake.SH,v $
X# Revision 3.0  1993/08/18  12:04:17  ram
X# Baseline for dist 3.0 netwide release.
X#
X
X\$dir = '$privlib/files';
X\$cpp = '$cpp';
X\$version = '$VERSION';
X\$patchlevel = '$PATCHLEVEL';
X!GROK!THIS!
X$spitshell >>jmake <<'!NO!SUBS!'
X$file = $dir . '/Jmake.tmpl';
X
X$dir = &tilda_expand($dir);		# ~name expansion
X
X$cpp_opt = "-I. ";				# For Jmakefile, which is local
Xwhile ($ARGV[0] =~ /^-/) {
X	$_ = shift;
X	last if /--/;
X	$cpp_opt .= "$_ ";
X}
X$cpp_opt .= "-I$dir";
X
Xopen(CPP, "$cpp $cpp_opt $file |");
Xwhile (<CPP>) {
X	# Record defined symbols in Jmakefile. We won't catch symbols
X	# in conditional commands, but that's ok, I hope.
X	if ($in_symbol) {
X		$val = $_;
X		$in_symbol = 0 if !($val =~ s/\\\s*$//);	# Last line
X		if ($val = /^\|expand/) {		# Found an expand command
X			$in_symbol = 0;				# Stop gathering value
X			$val .= "void::x";			# Stop any incomplete escape sequence
X		}
X		chop($val);
X		$Makesym{$current_symbol} .= $val;
X	} elsif (/^\s*(\w+)\s*=(.*)/ && !$in_symbol) {
X		# Found a makefile's macro declaration
X		$val = $2;
X		$current_symbol = $1;
X		if ($val =~ s/\\\s*$//) {	# Remove final '\'
X			$in_symbol = 1;			# This is a continuation line
X		}
X		$Makesym{$current_symbol} = $val;
X		push(@Order, $current_symbol);	# Keep track of order
X	}
X	# Protect RCS keyword Id or Header from normal substitution
X	s/\$(Id|Header|Log)/\$X-$1/;
X	# Restore possibly escaped C comments
X	s|/#\*|/*|g;
X	s|\*#/|*/|g;
X	# Remove all ^^ (null space character)
X	s|\^\^||g;
X	# Restore escaped ^^ sequence
X	s|\^\\\^|^^|g;
X	if (!/^#\s+\d+/) {		# Not a cpp commment
X		s/^;#/#/;
X		s/@#\s?/\n/g;		# Kept for backward compatibility
X		s/@!\s?/\n/g;
X		s/@@\s?/\n\t/g;
X
X		$* = 1;
X		# A '\r' is added to all lines, in order to let 'split' keep them
X		# As lines ending with '\' won't fit in the next regular
X		# expression (why ?), we have to treat that special case separately
X		s/\n$/\r\n/g;
X		s/\\\s*$/\\\r/g;	# Remove spaces after final '\' and add '\r'
X		$* = 0;
X		@macro = split(/\n/);
X		for ($i = 0; $i <= $#macro; $i++) {
X			chop($_ = $macro[$i]);		# Remove final '\r'
X			s/\s+$//g;					# Remove possible useless spaces
X			if (/^TOP\s*=\s*(\S+)/) {	# Get the top from generated file
X				$top = $1;
X			}
X			if (s/^\s*>//) {			# '>' means "symbol wanted"
X				$symbol{$_} = 1;
X			} elsif (s/^\s*\+//) {		# '+' means "initialization section"
X				if (s/^\+(\w+)//) {		# '++' means add to variable list
X					$added{$1} .= $_;
X				} else {				# A single '+' means "add as is".
X					push(@init, $_);
X				}
X			} elsif (s/^\|//) {			# Command for us
X				if (/suffix\s+(\S+)/) {		# Add suffix
X					push(@suffix, $1) unless $seen{$1};
X					$seen{$1} = 1;
X				} elsif (s/^rule://) {		# Add building rule
X					s/^\s(\s*\S+)/\t$1/;	# Make sure leading tab is there
X					push(@rule, $_);
X				} elsif (/^skip/) {			# Unconditional skip... funny!
X					push(@makefile, "|$_");	# Skip handled in pass 2
X				} elsif (/^expand/) {
X					push(@makefile, "|$_");	# Expand handled in pass 2
X				} elsif (/^once\s+(\S+)/) {	# Once handled in pass 1
X					if ($Once{$1}++) {		# Symbol already seen -- skip
X						for (; $i <= $#macro; $i++) {
X							last if $macro[$i] =~/^-once/;
X						}
X						warn("jmake: -once not found for $1")
X							unless $macro[$i] =~/^-once/;
X					}
X				} else {
X					print "Warning: unknown command $_\n";
X				}
X			} else {
X				next if /^-once/;			# Control statement removed
X				push(@makefile, $_);
X			}
X		}
X	}
X}
Xclose CPP;
X
X@key = keys(%added);
X$last_was_blank = 1;	# To avoid blank line at the top of the file
X$symbol{'INIT'} = 1 if ($#init >= 0 || $#key >=0);		# Initializations
X$symbol{'SUFFIX'} = 1 if ($#suffix >= 0 || $#rule >=0);	# Rules or suffixes
X$symbol{'TOP'} = 1 if $top eq '.';		# If imake invoked for the top
X
Xopen(MAKEFILE, ">Makefile.SH");
X# We have to use for instead of foreach to handle 'skip' easily
Xline: for ($i = 0; $i <= $#makefile; $i++) {
X	$_ = $makefile[$i];
X	next if /^-skip|-expand/;		# They might have made a mistake
X
X	s/<TAG>/[jmake $version PL$patchlevel]/;
X	if (/^\s*$/) {
X		next if ($last_was_blank);
X		$last_was_blank = 1;
X	} else {
X		$last_was_blank = 0;
X	}
X
X	# Lines starting with ?SYMBOL: (resp. %SYMBOL:) are to be processed
X	# only if SYMBOL is defined (resp. undefined).
X
X	# Apply in sequence
X	while (/^\s*\?|\s*%/) {
X		if (s/^\s*\?(\w+)://) {					# Wanted symbol ?
X			next line unless $symbol{$1};
X		} elsif (s/^\s*%(\w+)://) {				# Unwanted symbol ?
X			next line if $symbol{$1};
X		} else {
X			print "Warning: missing ':' in $_\n";
X			last;
X		}
X	}
X
X	s/^\s/\t/;			# Make sure leading tab is there
X	s/^;#/#/;			# Comments in Jmakefile
X
X	if (s/^\|//) {							# Command for us
X		if (/^skip/) {						# Skip until -skip
X			for (; $i <= $#makefile; $i++) {
X				last if $makefile[$i] =~ /^-skip/;
X			}
X		} elsif (s/^expand//) {
X			do init_expand($_);			# Initializes data structures
X			$i++;						# Skip expand line
X			undef @Expand;				# Storage for expanded lines
X			$pattern = '';				# Assume no pattern
X			for (; $i <= $#makefile; $i++) {
X				$_ = $makefile[$i];
X				if (s/^-expand//) {			# Reached end of expansion
X					if (s/^\s*(.*)/$1/) {	# Expand followed by a pattern
X						$pattern = $_;		# Get pattern to be removed
X					}
X					last;
X				}
X				s/^\s/\t/;				# Make sure leading tab is there
X				push(@Expand, $_);		# Line to be expanded
X			}
X			do expand($pattern);		# Expand all lines in buffer
X		} else {
X			print "Warning: unknown command $_\n";
X		}
X	} elsif (/^INIT/) {						# Initialization section
X		# All the initializations are put in the variable substitution
X		# section of the Makefile.SH. Therefore, we have to protect all
X		# the '$' signs that are not followed by an alphanumeric character.
X		foreach (@init) {
X			# Dumps core sometimes with perl 4.0 PL10
X			# do protect_dollars(*_);
X			$_ = do protect_dollars($_);
X			do print_makefile($_);
X		}
X		foreach (@key) {	# @key set earlier to keys(%added)
X			$_ .= " = " . $added{$_};
X			# Dumps core sometimes with perl 4.0 PL10
X			# do protect_dollars(*_);
X			$_ = do protect_dollars($_);
X			do print_makefile($_);
X		}
X	} elsif (/^SUFFIX/) {					# Suffixes/Rules section
X		# Rules and suffixes are put in the variable substitution
X		# section of the Makefile.SH. Therefore, we have to protect all
X		# the '$' signs that are not followed by an alphanumeric character.
X		if ($#suffix >= 0) {
X			print MAKEFILE ".SUFFIXES:";
X			foreach (@suffix) {
X				# Dumps core sometimes with perl 4.0 PL10
X				# do protect_dollars(*_);
X				$_ = do protect_dollars($_);
X				print MAKEFILE " $_";
X			}
X			print MAKEFILE "\n\n";
X		}
X		foreach (@rule) {
X			# Dumps core sometimes with perl 4.0 PL10
X			# do protect_dollars(*_);
X			$_ = do protect_dollars($_);
X			print MAKEFILE "$_\n";
X		}
X	} else {
X		do print_makefile($_);
X	}
X}
Xclose MAKEFILE;
X
Xsub protect_dollars {
X	# Dumps core sometimes with perl 4.0 PL10
X	# local(*_) = shift(@_);
X	s/\\\$/\\=/g;		# Protect already escaped '$'
X	s/(\$\W)/\\$1/g;	# Escape unprotected '$'
X	s/\\=/\\$/g;		# Restore escaped '$'
X	$_;					# Because perl dumps core... :-(
X}
X
X# Initializes data structures for expansion. If we detect Makefile
X# macro in the 'expand' line (the argument), then we write a small
X# makefile that will do the substitution for us -- I'm lazy today :-)
Xsub init_expand {
X	local($_) = shift(@_);
X	undef %Vars;		# Reset array of variables
X	$Vars_len = 0;		# Number of "symbols" in first expanded
X	if (/\$\(\w+\)/) {	# If at least one macro
X		local($make) = "/tmp/mkjm$$";
X		open(MAKE, ">$make") || die "Can't create $make.\n";
X		do gen_variables();			# Generates already computed variables
X		foreach $var (@Order) {		# Print each in order we found them
X			print MAKE "$var = $Makesym{$var}\n" if !$Gvars{$var};
X		}
X		print MAKE "all:\n\t@echo '$_'\n";
X		close MAKE;
X		chop($_ = `make -f $make all`);
X		unlink($make);
X	}
X	while (s/^\s*(\w+)!([^!]*)!//) {
X		$Vars{$1} = $2;
X		# Record only length for _first_ expanded symbol
X		$Vars_len = split(/\s\s*/, $2) unless $Vars_len;
X	}
X}
X
X# Expand lines in the @Expand array. The argument is a pattern which is to
X# be removed from the last chunk of expanded lines.
X# For each symbol s, !s is replaced by the next item, and !s:p=q does the
X# same after having replaced the pattern 'p' by pattern 'q' in the item.
X# Spaces are NOT allowed in 'p' or 'q'. Substitution is done once (no /g).
Xsub expand {
X	local($pattern) = shift;		# To-be-removed pattern for last chunk
X	local($_);
X	local($sub);
X	local($i);
X	local(@expands);
X	for ($i = 0; $i < $Vars_len; $i++) {
X		foreach $line (@Expand) {
X			$_ = $line;		# Don't modify elements in array
X			foreach $sym (keys %Vars) {
X				@expands = split(/\s\s*/, $Vars{$sym});
X				$sub = $expands[$i];
X				$sub =~ s/\/\///g;		# // is a void value
X				while (s/!${sym}:([^\s]*)=([^\s]*)/,x##x,/) {
X					# Replacing item is altered by some pattern
X					local($p) = $1;
X					local($q) = $2;
X					local($subq) = $sub;
X					eval "\$subq =~ s=${p}=${q}=";
X					s/,x##x,/${subq}/;
X				}
X				s/!${sym}/${sub}/g;
X			}
X			# Protect substitution in an 'eval' in case of error
X			eval "s/${pattern}\$//" if $pattern && $i == ($Vars_len - 1);
X			do print_makefile($_);
X		}
X	}
X}
X
X# Prints its argument in MAKEFILE and records it also in Generated
Xsub print_makefile {
X	local($_) = shift(@_);		# Line to be printed
X	print MAKEFILE "$_\n";
X	push(@Generated, "$_\n");
X}
X
X# Generates in MAKE file all the generated variable we have so far for
X# final Makefile. This is mainly intended to allow expansion of variables
X# which are already defined with an expand.
Xsub gen_variables {
X	undef %Gvars;				# Reset already generated variables
X	local ($in_symbol) = 0;		# True when in variable (Makefile's macro)
X	foreach (@Generated) {
X		if ($in_symbol) {
X			if (/^\s*(\w+)\s*=(.*)/) {		# Missed the end of previous macro
X				$in_symbol = 0;
X				$Gvars{$1} = 1;					# Definition of variable seen
X				$in_symbol = 1 if (/\\\s*$/);	# There is a final '\'
X				print MAKE "void::\n";			# Cut incomplete esc sequence
X			} else  {
X				$in_symbol = 0 if !(/\\\s*$/);	# Last line
X			}
X			print MAKE;
X		} elsif (/^\s*(\w+)\s*=(.*)/ && !$in_symbol) {
X			# Found a makefile's macro declaration
X			$Gvars{$1} = 1;					# Definition of variable seen
X			$in_symbol = 1 if (/\\\s*$/);	# There is a final '\'
X			print MAKE;
X		}
X	}
X	print MAKE "void::\n";		# Cut incomplete escape sequence
X}
X
X!NO!SUBS!
X$grep -v '^;#' ../pl/tilde.pl >>jmake 
Xchmod 755 jmake
X$eunicefix jmake
END_OF_FILE
  if test 11339 -ne `wc -c <'jmake/jmake.SH'`; then
    echo shar: \"'jmake/jmake.SH'\" unpacked with wrong size!
  fi
  chmod +x 'jmake/jmake.SH'
  # end of 'jmake/jmake.SH'
fi
if test -f 'jmake/jmake.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jmake/jmake.man'\"
else
  echo shar: Extracting \"'jmake/jmake.man'\" \(10129 characters\)
  sed "s/^X//" >'jmake/jmake.man' <<'END_OF_FILE'
X''' $Id: jmake.man,v 3.0 1993/08/18 12:04:18 ram Exp $
X'''
X'''  Copyright (c) 1991-1993, Raphael Manfredi
X'''  
X'''  You may redistribute only under the terms of the Artistic Licence,
X'''  as specified in the README file that comes with the distribution.
X'''  You may reuse parts of this distribution only within the terms of
X'''  that same Artistic Licence; a copy of which may be found at the root
X'''  of the source tree for dist 3.0.
X'''
X''' $Log: jmake.man,v $
X''' Revision 3.0  1993/08/18  12:04:18  ram
X''' Baseline for dist 3.0 netwide release.
X'''
X.TH JMAKE 1 ram
X.SH NAME
Xjmake \- a generic makefile builder
X.SH SYNOPSIS
X.B jmake
X[
X.I cpp options
X]
X.SH DESCRIPTION
X.I Jmake
Xbuilds a makefile out of a rather high level description held in a
X.I Jmakefile
Xfile. The generated file is a
X.I Makefile.SH
Xrather than a simple makefile, which means it is ready to be used in
Xconjonction with
X.I metaconfig.
XIn particular, parameters such as "where to install executables" will
Xbe automatically determined by
X.I Configure
Xand only the needed parameters will be taken into account.
X.PP
XTo use
X.I jmake
Xyou have to write a
X.I Jmakefile
Xfirst, which describes the way things are to be built. Your
X.I Jmakefile
Xwill be included inside a generic template through the C pre-processor.
XThis means you may use the usual C /**/ comments, but not the shell # comments.
XThe C comments will not appear in the generated
X.I Makefile.SH
Xbut lines starting with ;# will finally appear as shell comments. If you
Xhave to write the string /* in the generated
X.I Makefile.SH
Xthen you have to escape it (otherwise
X.I jmake
Xwill think of it as the start of a C comment). Simply put a # in front
Xof the *, as in /#*.
X.PP
XYou have a set of macros at your disposal, and all these macros are
Xlisted in the Index file, along with the piece of code they will
Xexpand to. Usually, a
X.I Jmakefile
Xis fairly small and thus easier to maintain than a huge
X.I Makefile.
XSome internal powerful commands allow you to write
Xportable makefiles easily, without having to spend many efforts, because
Xsomeone else already did the job for you :-).
X.PP
XWhen you want to generate your makefile, you usually do not run
X.I jmake
Xbut use the
X.I jmkmf
Xscript which is a wrapper and will invoke
X.I jmake
Xwith the correct options.
X.PP
XAll the knowledge of
X.I jmake
Xis held in two files: the template
X.I Jmake.tmpl
Xand the macro definition file
X.I Jmake.rules.
XThe first file includes the second, along with the
X.I Jmakefile.
XIt is sometimes necessary to know how things works to be able to correctly
Xuse all the features provided. For instance, you may have to write your
Xown rules for a specific project. Although you cannot overwrite the
Xpredefined rules, you can extent the
X.I Jmake.rules
Xfile or simply add your macros in your
X.I Jmakefile.
XYou may also use
X.I #include
Xstatements when you want to share these macros and do not want to duplicate
Xthe code.
X.PP
XThe syntax in Jmake.rules is not elegant at all, but:
X.sp
X.PD 0
X.IP -
XIt is easy to parse (like sendmail.cf or troff files).
X.IP -
XThe rules are not supposed to change very often.
X.IP -
XIt is simple enough to be mastered in five minutes. :-)
X.sp
XHere is a small description:
X.sp
X.IP 1)
XTo deal with various \fIcpp\fR implementations:
X.sp
X.RS
X.IP \(bu
XFinal @!\\ means: end of line, next line starts at the left margin.
X.IP \(bu
XFinal @@\\ means: end of line, next line is to be indented by one tab.
X.sp
X.PP
XThere should always be one of @!\\ or @@\\ at the end of each line.
XThe only exception is for macros that are to be used as part of a
Xrule body (e.g. \fIRemoveTargetProgram\fR). In that case, the first
Xline (which holds the \fI#define\fR) should end with a single backslash.
X.RE
X.sp
X.IP 2)
XSymbol definitions:
X.sp
X.RS
X.IP \(bu
X>SYMBOL: defines the symbol.
X.IP \(bu
X?SYMBOL:<text>: keeps <text> iff SYMBOL is defined.
X.IP \(bu
X%SYMBOL:<text>: keeps <text> iff SYMBOL is not defined.
X.sp
X.PP
XThe ?SYM can be nested (logical AND), as in:
X.sp
X.in +5
X?SYMBOL:%TOKEN:text
X.in -5
X.sp
Xwhich will keep text if SYMBOL is defined and TOKEN undefined.
XTo implement a logical OR, see below.
X.RE
X.sp
X.IP 3)
XCommands:
X.sp
X.RS
XCommands can be passed to \fIjmake\fR. They start with a leading '|'.
XAvailable commands are:
X.sp
X.IP \(bu
X|suffix <sx>: adds <sx> to the .SUFFIXES: list in the makefile.
X.IP \(bu
X|rule:<text>: adds <text> to the building rule section.
X.IP \(bu
X|rule: <text>: same as before, with a leading tab.
X.IP \(bu
X|skip: skips text until a line starting with '-skip' is found.
X.IP \(bu
X|expand <pattern>: expand lines until '-expand' with <pattern>. A
Xcomplete example is shown below.
X.IP \(bu
X|once <symbol>: text up to '-once' appears only the first time.
X.sp
X.PP
XHere is a way to implement a logical OR:
X.sp
X.in +5
X.nf
X/* Implements SYMBOL or not TOKEN */
X?SYMBOL:text		/* Keeps text if SYMBOL */
X%SYMBOL:|skip
X	%TOKEN:text		/* Keeps text if not TOKEN */
X-skip
X.fi
X.in -5
X.sp
XActually, this is ugly, because the text has to appear twice.
XFortunately, I did not use it. :-)
X.sp
X.PP
XThe '|' commands cannot be nested. In particular, due to the simple
Ximplementation of \fI|skip\fR, it is impossible to put \fI|skip\fR inside
Xa skipped part. However, a \fI|once\fR section may have \fI|skip\fR sections.
X.sp
XBut actually, as you have surely already guessed, the best way to
Ximplement a logical OR is to use De Morgan's Law:
X.sp
X.in +5
X.nf
Xnot (p or q) <=> not p and not q
X
X/* Implements SYMBOL or not TOKEN (attempt #2) */
X%SYMBOL:?TOKEN:|skip
Xtext					/* If SYMBOL or not TOKEN */
X-skip
X.sp
X.in -5
X.fi
XWho said they don't care ? ;-)
X.sp
X.PP
XExpansion is done with the \fIexpand\fR command.  It has been provided to
Xavoid some cumbersome writings in makefiles when you have to repeat some
Xsilly lines that only differ in file names, for instance.  Let's look at
Xan example first:
X.sp
X.in +5
X.nf
X|expand a!foo bar! b!yes no!
X!a::
X	echo !a, !b
X-expand
X.fi
X.in -5
X.sp
X.PP
XThen two rules will be printed, and the values of (a,b) for the first
Xwill be (foo, yes), for the second (bar, no).  Substitution is controled
Xby the '!' character.  If the word to be substituted is part of another
Xone, detach with the ^^ construct as in:  !b^^c.  It is possible to
Xuse Makefile macros in the <pattern>, and they will be expanded by
Xjmake.  If this is not what you want, escape the first '$' sign (this is
Xa Makefile escape, i.e. you must double the '$', not precede it with a
Xbackslash). A // stands for the null substitution value.
X.sp
X.PP
XHere is another example which shows how the macro Expand can be used.
XIt is defined in \fIJmake.rules\fR as:
X.sp
X.in +5
X.nf
X#define Expand(rule, pattern) @!\\
X|expand pattern @!\\
Xrule @!\\
X-expand
X.sp
X.in -5
X.fi
XSo we can write in the \fIJmakefile\fR:
X.sp
X.in +5
X.nf
X|skip
XA = foo bar
X-skip
X
X#define Rule @!\\
X$(DIR)/!a^^.o: !a^^.o @@\\
X	$(CC) -c !a^^.c @@\\
X	$(MV) !a^^.o $(DIR)
X
XExpand(Rule, a!$(A)!)
X.sp
X.in -5
X.fi
Xwhich will generate in \fIMakefile.SH\fR:
X.sp
X.in +5
X.nf
X$(DIR)/foo.o: foo.o
X	$(CC) -c foo.c
X	$(MV) foo.o $(DIR)
X
X$(DIR)/bar.o: bar.o
X	$(CC) -c bar.c
X	$(MV) bar.o $$(DIR)
X.sp
X.in -5
X.fi
X.sp
X.PP
XThe 'A' declaration has been surrounded by \fIskip\fR, so that it does
Xnot appear in the generated Makefile.SH, but it will be taken into
Xaccount by \fIjmake\fR for the substitution in the pattern.
X.sp
X.PP
XThe number of expansions is determined by the number of possible
Xvalues for the \fBfirst\fR parameter. If other parameters have less
Xsubstitution values, they will get void ones.
X.sp
X.PP
XIt is possible to add a regular expression at the end of '-expand'. This
Xregular expression will be removed from the final set of expansion at the
Xend of each line. It is also possible to do substitutions in the expanded
Xitem, by using the syntax (if 'f' is the expanded variable)
X!f:\fI<p>\fR=\fI<q>\fR
Xwhere \fI<p>\fR and \fI<q>\fR are two regular expressions (without spaces).
XThe pattern \fI<p>\fR will be replaced by the pattern \fI<q>\fR (only the first
Xoccurrence will be replaced).
X.sp
X.PP
XFinally, you may refer in the expanded section to variables whose value is
Xcomputed via another expansion, which makes it easy to define generic
X\fIJmakefiles\fR.
X.sp
XExample:
X.sp
X.in +5
X.nf
XSRC = foo.c bar.c
XOBJ = \\
X|expand f!$(SRC)!
X	!f:\\.c=\\.o \\
X-expand \\\\
XINC = \\
X|expand f!$(OBJ)!
X	!f:\\.o=\\.h \\
X-expand \\\\
X.fi
X.in -5
X.sp
Xwhich will generate in \fIMakefile.SH\fR:
X.sp
X.in +5
X.nf
XSRC = foo.c bar.c
XOBJ = \\
X	foo.o \\
X	bar.o
XINC = \\
X	foo.h \\
X	bar.h
X.in -5
X.fi
X.sp
XDo not forget to protect special characters in your regular expressions such
Xas backslash, point, etc...
X.sp
X.PP
XThe \fIonce\fR command is tagged with a name. The first time the name
Xappears, the once construct is ignored and the text up to '-once' will
Xbe copied in the generated Makefile.SH.  However, future occurences of
Xthe same name will be ignored (\fIonce\fR will behave like \fIskip\fR).
X.sp
XExample:
X.sp
X.in +5
X.nf
X|once this_is_a_name
X<text>
X-once
X.sp
X.in -5
X.fi
X.sp
X.RE
X.IP 4)
XInitializations:
X.sp
X.RS
X.IP \(bu
X+<line>: Puts the whole line in the initialization section.
X.IP \(bu
X++SYMBOL <value>: Adds <value> to the SYMBOL macro.
X.RE
X.sp
X.IP 5)
XUser-defined variables:
X.sp
XThe user may define CFLAGS, LDFLAGS or DPFLAGS as additional flags to be used
Xin C compilation, linking phase or depend target. It is thus possible to add
Xsome extra flags such as -I or libraries for Makefiles in specific
Xsub-directories.
X.sp
X.PD
X.SH AUTHOR
XRaphael Manfredi <ram@acri.fr>
X.SH FILES
X.PD 0
X.TP 20
XJmakefile
XHigh level description of Makefile.SH
X.TP
XJmake.rules
XFile holding the macro definitions
X.TP
XJmake.tmpl
XTemplate used to mould Makefile.SH
X.PD
X.SH BUGS
XOn systems whose
X.I cpp
Xreduces multiple tabs and spaces to a single space,
X.I jmake
Xattempts to put back any necessary tabs (which
X.I make
Xexpects in front of rules) but does not properly formats the
Xbody of the rule itself.
X.PP
XThere is a bootstraping problem when creating the first Makefile.SH, because
Xyou cannot run it through a shell until there is a decent Configure
Xscript, but you can't run \fImetaconfig\fR before there is a Makefile.SH
Xor some needed symbols will not be defined.
X.SH "SEE ALSO"
Xjmkmf(1), metaconfig(1).
END_OF_FILE
  if test 10129 -ne `wc -c <'jmake/jmake.man'`; then
    echo shar: \"'jmake/jmake.man'\" unpacked with wrong size!
  fi
  # end of 'jmake/jmake.man'
fi
if test -f 'mcon/pl/wanted.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/pl/wanted.pl'\"
else
  echo shar: Extracting \"'mcon/pl/wanted.pl'\" \(7414 characters\)
  sed "s/^X//" >'mcon/pl/wanted.pl' <<'END_OF_FILE'
X;# $Id: wanted.pl,v 3.0 1993/08/18 12:10:29 ram Exp $
X;#
X;#  Copyright (c) 1991-1993, Raphael Manfredi
X;#  
X;#  You may redistribute only under the terms of the Artistic Licence,
X;#  as specified in the README file that comes with the distribution.
X;#  You may reuse parts of this distribution only within the terms of
X;#  that same Artistic Licence; a copy of which may be found at the root
X;#  of the source tree for dist 3.0.
X;#
X;# $Log: wanted.pl,v $
X;# Revision 3.0  1993/08/18  12:10:29  ram
X;# Baseline for dist 3.0 netwide release.
X;#
X;# 
X;# These two arrays record the file names of the files which may (or may not)
X;# contain shell or C symbols known by metaconfig.
X;#  @SHlist records the .SH files
X;#  @clist records the C-like files (i.e. .[chyl])
X;#
X;# These files are scanned in turn to see how many symbols known by metaconfig
X;# they have. Those symbols are gathered in a Wanted file. As C symbols are
X;# not true targets for the forthcoming Makefile, a ">" sign is prepended.
X;# Finally, the obsolete symbols are preceded by a "!".
X;#
X;# When obsolete symbols are found, they are dumped in file 'Obsolete'. Two
X;# files are created anyway in the .MT directory. Obsol_h.U and Obsol_sh.U which
X;# respectively list the obsoleted symbols (C and shell ones).
X;#  Obsol_h.U records obsolete C symbols
X;#  Obsol_sh.U records obsolete shell symbols
X;#
X;# The manifake() routine has to be provided externally.
X;#
X# Build a wanted file from the files held in @SHlist and @clist arrays
Xsub build_wanted {
X	# If wanted file is already there, parse it to map obsolete if -o option
X	# was used. Otherwise, built a new one.
X	if (-f 'Wanted') {
X		&map_obsolete if $opt_o;			# Build Obsol*.U files
X		&dump_obsolete;						# Dump obsolete symbols if any
X		return;
X	}
X	&parse_files;
X}
X
Xsub parse_files {
X	print "Building a Wanted file...\n" unless $opt_s;
X	open(WANTED,"| sort | uniq >Wanted") || die "Can't create Wanted.\n";
X	unless (-f $NEWMANI) {
X		&manifake;
X		die "No $NEWMANI--can't build a Wanted file.\n" unless -f $NEWMANI;
X	}
X
X	local($search);							# Where to-be-evaled script is held
X	local($_) = ' ' x 50000 if $opt_m;		# Pre-extend pattern search space
X	local(%visited);						# Records visited files
X	local(%lastfound);						# Where last occurence of key was
X
X	# Now we are a little clever, and build a loop to eval so that we don't
X	# have to recompile our patterns on every file.  We also use "study" since
X	# we are searching the same string for many different things.  Hauls!
X
X	if (@clist) {
X		print "    Scanning .[chyl] files for symbols...\n" unless $opt_s;
X		$search = ' ' x (40 * (@cmaster + @ocmaster));	# Pre-extend
X		$search = "while (<>) {study;\n";				# Init loop over ARGV
X		foreach $key (keys(cmaster)) {
X			$search .= "&cmaster('$key') if /\\b$key\\b/;\n";
X		}
X		foreach $key (grep(!/^\$/, keys %Obsolete)) {
X			$search .= "&ofound('$key') if /\\b$key\\b/;\n";
X		}
X		$search .= "}\n";			# terminate loop
X		print $search if $opt_d;
X		@ARGV = @clist;
X		# Swallow each file as a whole, if memory is available
X		undef $/ if $opt_m;
X		eval $search;
X		eval '';
X		$/ = "\n";
X		while (($key,$value) = each(cmaster)) {
X			print WANTED $cwanted{$key}, "\n", ">$key", "\n" if $value;
X		}
X	}
X
X	# Cannot remove $cmaster as it is used later on when building Configure
X	undef @clist;
X	undef %cwanted;
X	%visited = ();
X	%lastfound = ();
X
X	if (@SHlist) {
X		print "    Scanning .SH files for symbols...\n" unless $opt_s;
X		$search = ' ' x (40 * (@shmaster + @oshmaster));	# Pre-extend
X		$search = "while (<>) {study;\n";
X		# All the keys already have a leading '$'
X		foreach $key (keys(shmaster)) {
X			$search .= "&shmaster('$key') if /\\$key\\b/;\n";
X		}
X		foreach $key (grep (/^\$/, keys %Obsolete)) {
X			$search .= "&ofound('$key') if /\\$key\\b/;\n";
X		}
X		$search .= "}\n";
X		print $search if $opt_d;
X		@ARGV = @SHlist;
X		# Swallow each file as a whole, if memory is available
X		undef $/ if $opt_m;
X		eval $search;
X		eval '';
X		$/ = "\n";
X		while (($key,$value) = each(shmaster)) {
X			if ($value) {
X				$key =~ s/^\$//;
X				print WANTED $key, "\n";
X			}
X		}
X	}
X
X	# Obsolete symbols, if any, are written in the Wanted file preceded by a
X	# '!' character. In case -w is used, we'll thus be able to correctly build
X	# the Obsol_h.U and Obsol_sh.U files.
X
X	&add_obsolete;						# Add obsolete symbols in Wanted file
X
X	close WANTED;
X
X	# If obsolete symbols where found, write an Obsolete file which lists where
X	# each of them appear and the new symbol to be used. Also write Obsol_h.U
X	# and Obsol_sh.U in .MT for later perusal.
X
X	&dump_obsolete;						# Dump obsolete symbols if any
X
X	die "No desirable symbols found--aborting.\n" unless -s 'Wanted';
X
X	# Clean-up memory by freeing useless data structures
X	undef @SHlist;
X	undef %shmaster;
X}
X
X# This routine records matches of C master keys
Xsub cmaster {
X	local($key) = @_;
X	$cmaster{$key}++;					# This symbol is wanted
X	return unless $opt_t;				# Continue if trace option on
X	if ($lastfound{$key} ne $ARGV) {	# Never mentionned for this file ?
X		$visited{$ARGV}++ || print $ARGV,":\n";
X		print "\t$key\n";
X		$lastfound{$key} = $ARGV;
X	}
X}
X
X# This routine records matches of obsolete keys (C or shell)
Xsub ofound {
X	local($key) = @_;
X	local($_) = $Obsolete{$key};		# Value of new symbol
X	$ofound{"$ARGV $key $_"}++;			# Record obsolete match
X	$cmaster{$_}++ unless /^\$/;		# A C hit
X	$shmaster{$_}++ if /^\$/;			# Or a shell one
X	return unless $opt_t;				# Continue if trace option on
X	if ($lastfound{$key} ne $ARGV) {	# Never mentionned for this file ?
X		$visited{$ARGV}++ || print $ARGV,":\n";
X		print "\t$key (obsolete, use $_)\n";
X		$lastfound{$key} = $ARGV;
X	}
X}
X
X# This routine records matches of shell master keys
Xsub shmaster {
X	local($key) = @_;
X	$shmaster{$key}++;					# This symbol is wanted
X	return unless $opt_t;				# Continue if trace option on
X	if ($lastfound{$key} ne $ARGV) {	# Never mentionned for this file ?
X		$visited{$ARGV}++ || print $ARGV,":\n";
X		print "\t$key\n";
X		$lastfound{$key} = $ARGV;
X	}
X}
X
X# Write obsolete symbols into the Wanted file for later perusal by -w.
Xsub add_obsolete {
X	local($file);						# File where obsolete symbol was found
X	local($old);						# Name of this old symbol
X	local($new);						# Value of the new symbol to be used
X	foreach $key (sort keys %ofound) {
X		($file, $old, $new) = ($key =~ /^(\S+)\s+(\S+)\s+(\S+)/);
X		if ($new =~ s/^\$//) {			# We found an obsolete shell symbol
X			print WANTED "!$old\n";
X		} else {						# We found an obsolete C symbol
X			print WANTED "!>$old\n";
X		}
X	}
X}
X
X# Map obsolete symbols from Wanted file into %Obsolete and call dump_obsolete
X# to actually build the Obsol_sh.U and Obsol_h.U files. Those will be needed
X# during the Configure building phase to actually do the remaping.
X# The obsolete symbols found are entered in the %ofound array, tagged as from
X# file 'XXX', which is specially recognized by dump_obsolete.
Xsub map_obsolete {
X	open(WANTED, 'Wanted') || die "Can't open Wanted file.\n";
X	local($new);				# New symbol to be used instead of obsolete one
X	while (<WANTED>) {
X		chop;
X		next unless s/^!//;		# Skip non-obsolete symbols
X		if (s/^>//) {					# C symbol
X			$new = $Obsolete{$_};		# Fetch new symbol
X			$ofound{"XXX $_ $new"}++;	# Record obsolete match (XXX = no file)
X		} else {						# Shell symbol
X			$new = $Obsolete{"\$$_"};	# Fetch new symbol
X			$ofound{"XXX \$$_ $new"}++;	# Record obsolete match (XXX = no file)
X		}
X	}
X	close WANTED;
X}
X
END_OF_FILE
  if test 7414 -ne `wc -c <'mcon/pl/wanted.pl'`; then
    echo shar: \"'mcon/pl/wanted.pl'\" unpacked with wrong size!
  fi
  # end of 'mcon/pl/wanted.pl'
fi
if test -f 'pat/pat.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pat/pat.man'\"
else
  echo shar: Extracting \"'pat/pat.man'\" \(10709 characters\)
  sed "s/^X//" >'pat/pat.man' <<'END_OF_FILE'
X.rn '' }`
X''' $Id: pat.man,v 3.0 1993/08/18 12:10:37 ram Exp $
X'''
X'''  Copyright (c) 1991-1993, Raphael Manfredi
X'''  
X'''  You may redistribute only under the terms of the Artistic Licence,
X'''  as specified in the README file that comes with the distribution.
X'''  You may reuse parts of this distribution only within the terms of
X'''  that same Artistic Licence; a copy of which may be found at the root
X'''  of the source tree for dist 3.0.
X'''
X''' $Log: pat.man,v $
X''' Revision 3.0  1993/08/18  12:10:37  ram
X''' Baseline for dist 3.0 netwide release.
X'''
X.de Sh
X.br
X.ne 5
X.PP
X\fB\\$1\fR
X.PP
X..
X.de Sp
X.if t .sp .5v
X.if n .sp
X..
X'''
X'''     Set up \*(-- to give an unbreakable dash;
X'''     string Tr holds user defined translation string.
X'''
X.ie n \{\
X.tr \(*W-\*(Tr
X.ds -- \(*W-
X.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
X.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
X.ds L" ""
X.ds R" ""
X.ds L' '
X.ds R' '
X'br\}
X.el\{\
X.ds -- \(em\|
X.tr \*(Tr
X.ds L" ``
X.ds R" ''
X.ds L' `
X.ds R' '
X'br\}
X.TH PAT 1 ram
X.SH NAME
Xpat \- patch generator tools
X.SH SYNOPSIS
X.B pat
X[
X.B \-ahmnV
X] [
X.I filelist
X]
X.br
X.B patcil
X[
X.B \-abfhnpqsV
X] [
X.I filelist
X]
X.br
X.B patdiff
X[
X.B \-ahnV
X] [
X.I filelist
X]
X.br
X.B patbase
X[
X.B \-ahV
X] [
X.I filelist
X]
X.br
X.B patmake
X[
X.B \-hV
X]
X.br
X.B patsend
X[
X.B \-hV
X] [
X.I patchlist
X] [
X.I recipients
X]
X.br
X.B patpost
X[
X.B \-hrV
X]
X.I patchlist
X.I newsgroups
X.br
X.B patftp
X[
X.B \-hV
X] [
X.I patchlist
X]
X.br
X.B patname
X[
X.B \-ahnmV
X]
X.B \-v
X.I version
X[
X.I filelist
X]
X.br
X.B patcol
X[
X.B \-achnmsCV
X] [
X.B \-d
X.I directory
X] [
X.I filelist
X]
X.br
X.B patclean
X[
X.B \-ahnmV
X] [
X.I filelist
X]
X.br
X.B patindex
X.SH DESCRIPTION
X.I Pat
Xand its associated programs generate patches for any package that has been
Xstored under RCS.
XThese programs hide many of the details of RCS that get in your way when
Xconstructing and maintaining a package.
XAll you need to do to create a new patch is to edit your files, run pat,
Xand furnish some descriptions to RCS and in the generated patch file.
XDetails such as how to initialize a new RCS file, what the comment string should
Xbe, how create a new branch,
Xhow to deal with subdirectories, how to do diffs and how to
Xorganize the patch file are handled automatically.
X.PP
XBefore using any of the pat programs you must initialize your package by
Xrunning packinit in the top-level directory of your package.
XThis produces a .package file that all of the dist programs make use of.
X.PP
XIn any of the programs that want a filelist, if you specify
X.B \-a
Xinstead,
Xall files in MANIFEST.new will be processed.
XIn any of the programs that want a patchlist, a null patchlist means the
Xcurrent patch.
XYou may use hyphens, commas and spaces to delimit patch numbers.
XIf the right side of a hyphen is the null string, the current patchlevel
Xis assumed as the maximum value. All the programs invoked with \fB\-h\fR
Xwill print a small usage message with the meaning of each available options.
XThe \fB\-V\fR option gives the current version number.
X.PP
XPat itself is a wrapper program that calls patcil, patdiff, and patmake.
XUsually you can just invoke pat and ignore all the others.
XPat will update the MANIFEST file, if necessary (it will be an
Xexact copy of the MANIFEST.new file, provided that a MANIFEST already
Xexisted), eventually calling patcil on it.
X.PP
XIf you specify
X.B \-n
Xinstead of a filelist, pat will find all files that are
Xnewer than patchlevel.h, put you into an editor to trim down the list,
Xthen use that file list.
XIf every file of the list is removed, \fIpat\fR will be aborted.
X.PP
X.I Patcil
Xis used to do a ci -l on any listed files.
X(It is assumed that you always want to keep your files checked out.)
XIn addition to the
X.B \-a
Xswitch, there is a
X.B \-b
Xswitch which does a quick checkin of
Xa set of files.
XInstead of calling rcs on each file, it calls rcs on the whole list of
Xfiles.
XThis is useful for checking in a trunk revision.
XWhen you are checking in a new trunk revision you might also want to use
Xthe
X.B \-s
Xflag which will strip out old RCS Log entries from the previous revision
Xso that you can start over fresh.
XYou probably should also use a
X.B \-f
Xwhich is passed through to the ci to force unchanged files to be checked in.
XTo check in a new trunk revision, I say
X.nf
X
X	patcil -s -f -a
X
X.fi
X.PP
XPatcil will ask for the log entry instead of letting ci do it, and has a little
Xprompter built in that lets you manipulate the message in various ways.
XType h for a listing of what you can do.
XOne of the nicest things is that you can pop up into an editor, optionally
Xwith a diff listing of the changes since the last patch, in case you've
Xforgotten what you changed.
XIf you type a CR as the first thing, it includes the
Xprevious log message.
XExit the prompter with a CR.
X.PP
XThere are two different ways to use patcil.
XYou can either call patcil yourself, or let pat call it for you.
XIt doesn't matter how many times you call patcil before running pat, since
Xpatdiff knows what the last patch base is to compare with.
XPatcil can be called in any of your directories; the other programs must
Xbe called in your top-level directory (or in bugs, when meaningful).
X.PP
XWhen you are creating a new file at a given patchlevel, you must patcil it
Xwith the
X.B \-p
Xoption. Otherwise, it will simply be checked-in as
Xa new trunk revision. The name of the file will be added to the MANIFEST.new
Xif it does not already appear in it. If the name is found along with a
Xdescription, that description will be passed through to rcs to properly
Xinitialize the RCS file.
X.PP
X.I Patbase
Xcan be used to reset the patch base to the current version when
Xyou've scrapped the previous patch sequence and are making a new distribution
Xkit.
XWhat it really does is an rcs -Nlastpat:REV, where REV is the current
Xrevision.
XIf patdiff blows up and you want to set the patch base back to some previous
Xversion, you have to call rcs -Nlastpat:REV yourself.
X.PP
X.I Patdiff
Xactually does the diffs that go into the patch, comparing whatever
Xversion -Nlastpat points to with the most recently checked in version.
XIt then updates -Nlastpat to point to the current version.
XIt leaves the diff sitting in the bugs subdirectory for patmake to pick up.
XIt can either use rcsdiff, or a diff command of your choice specified when
Xyou run packinit, in case your diff is better than rcsdiff.
X.PP
X.I Patmake
Xcombines all the pieces of the patch into one file and invokes
Xan editor so you can add the subject and description.
XIt throws all your log messages in as Subjects and as Description, under
Xthe assumption
Xthat it's easier to delete what you don't want than to remember everything
Xyou did.
XYou'll also want to expand each item in the Description so they don't just
Xrepeat the Subject lines.
X.PP
XBig patches will be split in order to keep size of each patch to a reasonable
Xsize. This is handled automatically, so you don't have to bother with it.
XThe priority of each patch is merely intuited by \fIpatmake\fR, given the
Xassumption that small changes have a great priority.
X.PP
XPatsend, patpost and patftp are used to distribute your patches to the world.
X.I Patsend
Xmails a set of patches to a set of recipients.
X.I Patpost
Xposts a set of patches to a set of newsgroups.
X.I Patftp
Xmerely copies the patch into your public ftp directory.
X.PP
X.I Patname
Xcan be used to tag a set of files with a symbolic name (specified with
X\fB\-v\fR). This will set the name for the most recent revision of each
Xfile.
X.PP
X.I Patcol
Xwill check out a locked version of a file, eventually in an alternate
Xdirectory (specified with \fB\-d\fR, thus mirroring the distribution tree).
XAll the files which have no RCS counterpart (e.g. patchlevel.h) will be
Xsimply copied by patcol. This is used by makedist to fake the distribution
Xbefore making the kits. By default, patcol will not do the copyright expansion
Xprocessing, but clients like \fImakedist\fR force it by using its \fB\-C\fR
Xoption. Alternatively, you may force copying of the checked-out version
Xinto a directory by using the \fB\-c\fR switch in conjunction with \fB\-d\fR
X(or that former switch is simply ignored).
X.PP
X.I Patclean
Xwill remove the working files after having checked in all the
Xchanges. You may  restores your working files by using patcol.
X.PP
X.I Patindex
Xmay be used from the top level directory or within the \fIbugs\fR directory.
XIt will list all the patches and their \fISubject:\fR lines. This program
Xknows about compressed patches and will decompress them while producing
Xthe listing.
X'''
X''' R C S   L a y e r
X'''
X.SH RCS LAYER
XThis section describes the RCS layer, in case  something in the tools breaks,
Xso that you may fix your RCS files and restart the operation.
X.PP
XAll the patch tools get the main RCS trunk revision number out of your
X\&\fI.package\fR files, say it's 2.5. Then, at the time you ran \fIpackinit\fR,
Xyou have chosen a branch for patches, usually number 1, which means all your
Xmodifications will be stored on the 2.5.1 RCS branch. The tools will create
Xthe branch for you when the time comes.
X.PP
XEach last released revision is tagged with an RCS \fIlastpat\fR symbol. When
Xthe patch is built by \fIpatdiff\fR, the lattest version on the 2.5.1 branch
Xis compared with the one tagged as \fIlastpat\fR. This is why you may safely
Xissue more than one \fIpatcil\fR beffore issuing the patch and still have
Xit all worked out. Of course \fIpatdiff\fR will move the \fIlastpat\fR
Xtag to the lattest branch revision after processing a given file.
X.PP
XAll the log messages and the modified files are kept in your \fIbugs\fR
Xdirectory, in hidden files (name starting with a dot). Those logs will be
Xcollected when the patch is issued and the modified files are used by
X\&\fIpat\fR's \fB\-m\fR switch.
X.PP
XIn order to start up a new baseline (i.e. to change the RCS trunk revision
Xnumber), you need to rerun \fIpackinit\fR and change that number. Then issue
Xa new \fIpatcil\fR, probably with the \fB\-s\fR, \fB\-a\fR and \fB\-f\fR
Xoptions...
X.SH FILES
X.PD 0
X.TP 15
Xbugs/*.[0-9]+
XDiffs for each file, gathered by \fIpatmake\fR to create a patch
X.TP
Xbugs/patch*
XIssued patches (can be compressed with \fIcompress\fR only)
X.TP
Xbugs/.logs[0-9]+
XLog messages for that patch
X.TP
Xbugs/.mods[0-9]+
XFiles modified in that patch (checked in with \fIpatcil\fR)
X.PD
X.SH ENVIRONMENT
X.PD 0
X.TP 15
XPAGER
XWhich pager to use in patcil (overwrites default)
X.TP
XEDITOR
XWhat editor should be used (overwrites default)
X.TP
XVISUAL
XSame role as EDITOR but this one is checked first
X.PD
X.SH SEE ALSO
Xmakedist(1), metaconfig(1).
X.SH BUGS
XMost of this should be built into RCS.
X.SH AUTHORS
XLarry Wall (version 2.0).
X.br
XRaphael Manfredi <ram@acri.fr>.
X.rn }` ''
END_OF_FILE
  if test 10709 -ne `wc -c <'pat/pat.man'`; then
    echo shar: \"'pat/pat.man'\" unpacked with wrong size!
  fi
  # end of 'pat/pat.man'
fi
echo shar: End of archive 8 \(of 28\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Please run PACKNOTES through sh, read REAMDE and then type Configure."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
