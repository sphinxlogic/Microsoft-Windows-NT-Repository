Newsgroups: comp.sources.misc
From: Raphael Manfredi <ram@acri.fr>
Subject: v39i022:  dist-3.0 - Configure script generator and related tools, Part18/28
Message-ID: <1993Aug19.131446.5818@sparky.sterling.com>
X-Md4-Signature: f250346bb2f485357de6b12335bb390c
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Advanced Computer Research Institute, Lyon, France.
Date: Thu, 19 Aug 1993 13:14:46 GMT
Approved: kent@sparky.sterling.com

Submitted-by: Raphael Manfredi <ram@acri.fr>
Posting-number: Volume 39, Issue 22
Archive-name: dist-3.0/part18
Environment: UNIX, Perl, RCS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  mcon/U/Chk_MANI.U mcon/U/byteorder.U mcon/U/d_bsdjmp.U
#   mcon/U/d_dosuid.U mcon/U/d_eofpipe.U mcon/U/d_hidnet.U
#   mcon/U/d_nolnbuf.U mcon/U/d_open3.U mcon/U/d_safebcpy.U
#   mcon/U/d_safemcpy.U mcon/U/d_strchr.U mcon/U/d_times.U
#   mcon/U/d_ulimit.U mcon/U/d_usendir.U mcon/U/d_vprintf.U
#   mcon/U/i_dirent.U mcon/U/i_varhdr.U mcon/U/orderlib.U
#   mcon/U/sockopt.U mcon/U/usrinc.U
# Wrapped by ram@soft208 on Wed Aug 18 14:42:22 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 18 (of 28)."'
if test -f 'mcon/U/Chk_MANI.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/Chk_MANI.U'\"
else
  echo shar: Extracting \"'mcon/U/Chk_MANI.U'\" \(2160 characters\)
  sed "s/^X//" >'mcon/U/Chk_MANI.U' <<'END_OF_FILE'
X?RCS: $Id: Chk_MANI.U,v 3.0 1993/08/18 12:04:45 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: Chk_MANI.U,v $
X?RCS: Revision 3.0  1993/08/18  12:04:45  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X:
X?X: This unit checks the package by making sure every file listed in MANIFEST
X?X: is present. It is loaded via contains.U (listed in its dependency line).
X?X:
X?MAKE:Chk_MANI: Myinit c n
X?MAKE:	-pick wipe $@ %<
X?T:filelist ans
X@if {test -f ../MANIFEST}
X: Now test for existence of everything in MANIFEST
Xecho " "
Xif test -f ../MANIFEST; then
X	echo "First let's make sure your kit is complete.  Checking..." >&4
X?X:
X?X: Files spelled uppercased and beginning with PACK are produced by the
X?X: shell archive builder and may be removed by the user. Usually, they are
X?X: not listed in the MANIFEST file, but you never know...
X?X:
X	awk '$1 !~ /PACK[A-Z]+/ {print $1}' ../MANIFEST | split -50
X	rm -f missing
X	for filelist in x??; do
X		(cd ..; ls `cat UU/$filelist` >/dev/null 2>>UU/missing)
X	done
X	if test -s missing; then
X		cat missing >&4
X		cat >&4 <<'EOM'
X
XTHIS PACKAGE SEEMS TO BE INCOMPLETE.
X
XYou have the option of continuing the configuration process, despite the
Xdistinct possibility that your kit is damaged, by typing 'y'es.  If you
Xdo, don't blame me if something goes wrong.  I advise you to type 'n'o
Xand contact the author (<MAINTLOC>).
X
XEOM
X?X: Can't use $echo at this early stage
X		echo $n "Continue? [n] $c" >&4
X		read ans
X		case "$ans" in
X		y*)
X			echo "Continuing..." >&4
X			rm -f missing
X			;;
X		*)
X?X:
X?X: Use kill and not exit, so that the trap gets executed to clean up
X?X:
X			echo "ABORTING..." >&4
X			kill $$
X			;;
X		esac
X	else
X		echo "Looks good..." >&4
X	fi
Xelse
X	echo "There is no MANIFEST file.  I hope your kit is complete !"
Xfi
Xrm -f missing x??
X
X@end
END_OF_FILE
  if test 2160 -ne `wc -c <'mcon/U/Chk_MANI.U'`; then
    echo shar: \"'mcon/U/Chk_MANI.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/Chk_MANI.U'
fi
if test -f 'mcon/U/byteorder.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/byteorder.U'\"
else
  echo shar: Extracting \"'mcon/U/byteorder.U'\" \(2354 characters\)
  sed "s/^X//" >'mcon/U/byteorder.U' <<'END_OF_FILE'
X?RCS: $Id: byteorder.U,v 3.0 1993/08/18 12:05:28 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: byteorder.U,v $
X?RCS: Revision 3.0  1993/08/18  12:05:28  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:byteorder: cat Myread Oldconfig Loc +cc +ccflags rm
X?MAKE:	-pick add $@ %<
X?S:byteorder:
X?S:	This variable holds the byte order. In the following, larger digits
X?S:	indicate more significance.  The variable byteorder is either 4321
X?S:	on a big-endian machine, or 1234 on a little-endian, or 87654321
X?S:	on a Cray ... or 3412 with weird order !
X?S:.
X?C:BYTEORDER:
X?C:	This symbol hold the hexadecimal constant defined in byteorder,
X?C:	i.e. 0x1234 or 0x4321, etc...
X?C:.
X?H:#define BYTEORDER 0x$byteorder	/* large digits for MSB */
X?H:.
X: check for ordering of bytes in a long
Xcase "$byteorder" in
X'')
X	$cat <<'EOM'
X  
XIn the following, larger digits indicate more significance.  A big-endian
Xmachine like a Pyramid or a Motorola 680?0 chip will come out to 4321. A
Xlittle-endian machine like a Vax or an Intel 80?86 chip would be 1234. Other
Xmachines may have weird orders like 3412.  A Cray will report 87654321. If
Xthe test program works the default is probably right.
XI'm now running the test program...
XEOM
X	$cat >try.c <<'EOCP'
X#include <stdio.h>
Xmain()
X{
X	int i;
X	union {
X		unsigned long l;
X		char c[sizeof(long)];
X	} u;
X
X	if (sizeof(long) > 4)
X		u.l = (0x08070605L << 32) | 0x04030201L;
X	else
X		u.l = 0x04030201L;
X	for (i = 0; i < sizeof(long); i++)
X		printf("%c", u.c[i]+'0');
X	printf("\n");
X}
XEOCP
X	if $cc $ccflags try.c -o try >/dev/null 2>&1 ; then
X		dflt=`./try`
X		case "$dflt" in
X		????|????????) echo "(The test program ran ok.)";;
X		*) echo "(The test program didn't run right for some reason.)";;
X		esac
X	else
X		dflt='4321'
X		cat <<'EOM'
X(I can't seem to compile the test program.  Guessing big-endian...)
XEOM
X	fi
X	;;
X*)
X	echo " "
X	dflt="$byteorder"
X	;;
Xesac
Xrp="What is the order of bytes in a long?"
X. ./myread
Xbyteorder="$ans"
X$rm -f try.c try
X
END_OF_FILE
  if test 2354 -ne `wc -c <'mcon/U/byteorder.U'`; then
    echo shar: \"'mcon/U/byteorder.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/byteorder.U'
fi
if test -f 'mcon/U/d_bsdjmp.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_bsdjmp.U'\"
else
  echo shar: Extracting \"'mcon/U/d_bsdjmp.U'\" \(2159 characters\)
  sed "s/^X//" >'mcon/U/d_bsdjmp.U' <<'END_OF_FILE'
X?RCS: $Id: d_bsdjmp.U,v 3.0 1993/08/18 12:05:45 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_bsdjmp.U,v $
X?RCS: Revision 3.0  1993/08/18  12:05:45  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_bsdjmp: Guess Setvar cat +cc libs rm
X?MAKE:	-pick add $@ %<
X?S:d_bsdjmp:
X?S:	This variable conditionally defines USE_BSDJMP if BSD _setjmp and
X?S:	_longjmp routines are available to do non-local gotos without saving
X?S:	or restoring the signal mask flag.
X?S:.
X?C:USE_BSDJMP (BSDJMP):
X?C:	This symbol, if defined, indicates that the BSD _setjmp and _longjmp
X?C:	routines are available to do non-local gotos wihtout saving or restoring
X?C:	the signal mask flag.
X?C:.
X?H:#$d_bsdjmp USE_BSDJMP		/**/
X?H:.
X?LINT:set d_bsdjmp
X: see if _setjmp and _longjmp exists
X?X: We can't check for these symbols with Inlibc because of the leading "_"
Xecho " "
Xcase "$d_bsdjmp" in
X'')
X	$cat >set.c <<EOP
X#include <setjmp.h>
Xjmp_buf env;
Xint set = 1;
Xmain()
X{
X	if (_setjmp(env))
X		exit(set);
X	set = 0;
X	_longjmp(env, 1);
X	exit(1);
X}
XEOP
X	if $cc set.c -o set $libs >/dev/null 2>&1; then
X		if ./set >/dev/null 2>&1; then
X			echo "Good! You have BSD _setjmp and _longjmp routines." >&4
X			val="$define"
X		else
X			$cat <<EOM
XUh-Oh! You have BSD _setjmp and _longjmp, but they do not work properly!!
XEOM
X			val="$undef"
X		fi
X	else
X		if usg; then
X			echo "You do not have _setjmp and _longjmp, but that's fine." >&4
X		else
X			cat <<EOM
XIt sounds strange for a BSD system to miss _setjmp and _longjmp, but that's ok.
XEOM
X		fi
X		val="$undef"
X	fi
X	;;
X*) val="$d_bsdjmp"
X	case "$d_bsdjmp" in
X	$define) echo "Good! You have BSD _setjmp and _longjmp routines." >&4;;
X	$undef) echo "You do not have _setjmp and _longjmp, but that's fine." >&4;;
X	esac
X	;;
Xesac
Xset d_bsdjmp
Xeval $setvar
X$rm -f set.c set
X
END_OF_FILE
  if test 2159 -ne `wc -c <'mcon/U/d_bsdjmp.U'`; then
    echo shar: \"'mcon/U/d_bsdjmp.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_bsdjmp.U'
fi
if test -f 'mcon/U/d_dosuid.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_dosuid.U'\"
else
  echo shar: Extracting \"'mcon/U/d_dosuid.U'\" \(2245 characters\)
  sed "s/^X//" >'mcon/U/d_dosuid.U' <<'END_OF_FILE'
X?RCS: $Id: d_dosuid.U,v 3.0 1993/08/18 12:05:55 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_dosuid.U,v $
X?RCS: Revision 3.0  1993/08/18  12:05:55  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_dosuid: Myread Oldconfig Guess package
X?MAKE:	-pick add $@ %<
X?S:d_dosuid:
X?S:	This variable conditionally defines the symbol DOSUID, which
X?S:	tells the C program that it should insert setuid emulation code
X?S:	on hosts which have setuid #! scripts disabled.
X?S:.
X?C:DOSUID:
X?C:	This symbol, if defined, indicates that the C program should
X?C:	check the script that it is executing for setuid/setgid bits, and
X?C:	attempt to emulate setuid/setgid on systems that have disabled
X?C:	setuid #! scripts because the kernel can't do it securely.
X?C:	It is up to the package designer to make sure that this emulation
X?C:	is done securely.  Among other things, it should do an fstat on
X?C:	the script it just opened to make sure it really is a setuid/setgid
X?C:	script, it should make sure the arguments passed correspond exactly
X?C:	to the argument on the #! line, and it should not trust any
X?C:	subprocesses to which it must pass the filename rather than the
X?C:	file descriptor of the script to be executed.
X?C:.
X?H:#$d_dosuid DOSUID		/**/
X?H:.
X: now see if they want to do setuid emulation
Xcase "$d_dosuid" in
X'') dflt=n;;
X"$undef") dflt=n;;
X*) dflt=y;;
Xesac
Xcat <<EOM
X 
XSome sites have disabled setuid #! scripts because of a bug in the kernel
Xthat prevents them from being secure.  If you are on such a system, the
Xsetuid/setgid bits on scripts are currently useless.  It is possible for
X$package to detect those bits and emulate setuid/setgid in a secure fashion
Xuntil a better solution is devised for the kernel problem.
X
XEOM
Xrp="Do you want to do setuid/setgid emulation?"
X. ./myread
Xcase "$ans" in
Xy*)  d_dosuid="$define";;
X*) d_dosuid="$undef";;
Xesac
X
END_OF_FILE
  if test 2245 -ne `wc -c <'mcon/U/d_dosuid.U'`; then
    echo shar: \"'mcon/U/d_dosuid.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_dosuid.U'
fi
if test -f 'mcon/U/d_eofpipe.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_eofpipe.U'\"
else
  echo shar: Extracting \"'mcon/U/d_eofpipe.U'\" \(2390 characters\)
  sed "s/^X//" >'mcon/U/d_eofpipe.U' <<'END_OF_FILE'
X?RCS: $Id: d_eofpipe.U,v 3.0 1993/08/18 12:05:57 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_eofpipe.U,v $
X?RCS: Revision 3.0  1993/08/18  12:05:57  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_eofpipe: cat +cc +ccflags +libs rm Oldconfig Guess echo n c
X?MAKE:	-pick add $@ %<
X?S:d_eofpipe:
X?S:	This variable conditionally defines the EOFPIPE symbol, which
X?S:	indicates to the C program that select will correctly detect the EOF
X?S:	condition when pipe is closed from the other end.
X?S:.
X?C:EOFPIPE:
X?C:	This symbol, if defined, indicates that EOF condition will be detected
X?C:	by the reader of the pipe when it is closed by the writing process.
X?C:	That is, a select() call on that file descriptor will not block when
X?C:	only an EOF remains (typical behaviour for BSD systems).
X?C:.
X?H:#$d_eofpipe EOFPIPE		/**/
X?H:.
X: see if pipe correctly gives the EOF condition
Xecho " "
Xcase "$d_eofpipe" in
X'')
X	echo "Let's see if your pipes return EOF to select() upon closing..." >&4
X	$cat >pipe.c <<'EOP'
Xmain()
X{
X	int pd[2];
X	int mask;
X
X	pipe(pd);
X	if (0 == fork()) {
X		close(pd[0]);
X		close(pd[1]);
X		exit(0);
X	}
X
X	close(pd[1]);
X	mask = 1 << pd[0];
X	alarm(2);
X	select(32, &mask, (int *) 0, (int *) 0, (char *) 0);
X	if (0 == read(pd[0], &mask, 1))
X		exit(0);
X	
X	exit(1);
X}
XEOP
X	if $cc $ccflags pipe.c -o pipe $libs >/dev/null 2>&1; then
X?X: Use a script to avoid the possible 'alarm call' message
X		echo "./pipe || exit 1" > mpipe
X		chmod +x mpipe
X		./mpipe >/dev/null 2>&1
X		case $? in
X		0) d_eofpipe="$define";;
X		*) d_eofpipe="$undef";;
X		esac
X	else
X		echo "(The test program did not compile correctly -- Guessing.)"
X		if bsd; then
X			d_eofpipe="$define"
X		else
X			d_eofpipe="$undef"
X		fi
X	fi
X	case "$d_eofpipe" in
X	"$define") echo "Yes, they do.";;
X	*) echo "No, they don't! (sigh)";;
X	esac
X	;;
X*)
X	$echo $n "Your pipes $c"
X	case "$d_eofpipe" in
X	"$define") echo "allow select() to see EOF upon closing.";;
X	*) echo "won't let select() see EOF on closing.";;
X	esac
X	;;
Xesac
X$rm -f *pipe* core
X
END_OF_FILE
  if test 2390 -ne `wc -c <'mcon/U/d_eofpipe.U'`; then
    echo shar: \"'mcon/U/d_eofpipe.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_eofpipe.U'
fi
if test -f 'mcon/U/d_hidnet.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_hidnet.U'\"
else
  echo shar: Extracting \"'mcon/U/d_hidnet.U'\" \(2311 characters\)
  sed "s/^X//" >'mcon/U/d_hidnet.U' <<'END_OF_FILE'
X?RCS: $Id: d_hidnet.U,v 3.0 1993/08/18 12:06:20 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_hidnet.U,v $
X?RCS: Revision 3.0  1993/08/18  12:06:20  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_hidnet hiddennet: cat sed myhostname mydomain Myread Oldconfig
X?MAKE:	-pick add $@ %<
X?S:d_hidnet:
X?S:	This variable conditionally defines the symbol HIDDEN_NET, which
X?S:	tells the C program that it should pretend it is on a different
X?S:	host for purposes of advertising a mailing address.
X?S:.
X?S:hiddennet:
X?S:	This variable contains the value eventually given to the symbol
X?S:	HIDDEN_NET, if d_hidnet defines it.  If defined, it's the name
X?S:	of the host which serves as the mail server for a network that
X?S:	is invisible to the outside world.
X?S:.
X?C:HIDDEN_NET (HIDDENNET):
X?C:	This symbol, if defined, contains the host name that you want to
X?C:	advertise to the outside world.  This name can be different from
X?C:	your actual host name, as long as the machine you specify knows
X?C:	how to forward mail to you.
X?C:.
X?H:#$d_hidnet HIDDEN_NET "$hiddennet"	/**/
X?H:.
X: now get the host name to advertise as our mailing address
Xcase "$hiddennet" in
X'') dflt=n;;
X*) dflt=y;;
Xesac
X$cat <<EOM
X 
XSome sites are on "hidden" networks, in the sense that the network appears
Xto the outside world as a single machine.  The advertised name of any host
Xon this hidden network is the name of one machine on the local network which
Xknows how to forward mail to any other host on the hidden network.
X
XDo you wish to advertise a different hostname to the world than the one your
Xown host ($myhostname$mydomain) has?
X
XEOM
Xrp='Use "hidden" network?'
X. ./myread
Xcase "$ans" in
Xn*) d_hidnet="$undef" hiddennet='';;
X*)
X	d_hidnet="$define"
X	echo " "
X	case "$hiddennet" in
X	'') dflt=`echo $mydomain | $sed -e 's/^\.//'`;;
X	*) dflt="$hiddennet";;
X	esac
X	rp='What hostname do you wish to advertise?'
X	. ./myread
X	hiddennet="$ans"
X	;;
Xesac
X
END_OF_FILE
  if test 2311 -ne `wc -c <'mcon/U/d_hidnet.U'`; then
    echo shar: \"'mcon/U/d_hidnet.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_hidnet.U'
fi
if test -f 'mcon/U/d_nolnbuf.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_nolnbuf.U'\"
else
  echo shar: Extracting \"'mcon/U/d_nolnbuf.U'\" \(2292 characters\)
  sed "s/^X//" >'mcon/U/d_nolnbuf.U' <<'END_OF_FILE'
X?RCS: $Id: d_nolnbuf.U,v 3.0 1993/08/18 12:06:43 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_nolnbuf.U,v $
X?RCS: Revision 3.0  1993/08/18  12:06:43  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_nolnbuf: test +cc cat rm Setvar Myread
X?MAKE:	-pick add $@ %<
X?S:d_nolnbuf:
X?S:	This variable conditionally defines the NOLINEBUF symbol, which
X?S:	indicates to the C program that stdout is not buffered, so that
X?S:	the program can call setbuf() or setlinebuf() for efficiency.
X?S:.
X?C:NOLINEBUF:
X?C:	This symbol, if defined, indicates that stdout is not buffered, so that
X?C:	the program can call setbuf() or setlinebuf() for efficiency.
X?C:.
X?H:#$d_nolnbuf	NOLINEBUF	/**/
X?H:.
X?T:xxx
X?LINT:set d_nolnbuf
X: check for buffering of stdout
Xecho " "
Xcase "$d_nolnbuf" in
X'')
X	$cat <<'EOT' >blurfl.c
X#include <stdio.h>
Xmain()
X{
X	int i;
X
X	for (i = 0; i < 5; i++) {
X		putchar(i+'a');
X		sleep(1);
X	}
X	putchar('\n');
X}
XEOT
X	$cc blurfl.c -o blurfl >/dev/null 2>&1;
X	$rm -f blurfl.c
X	$cat >&4 <<'EOM'
XChecking for buffering of stdout to terminal.
X
XObserve the following characters as they are printed out, to see whether they
Xprint out all at once, or with a 1 second pause between each of them.  If they
Xprint out one by one, you don't have buffering.  If they print together (after
Xabout a 5 second pause), you do have buffering.
X
XEOM
X	dflt=''
X	rp="Type return to start printing the test characters:"
X	. ./myread
X	xxx=y
X	while $test "$xxx" = 'y'; do
X		./blurfl 1>&4
X		dflt=n
X		rp='Would you like to see that again?'
X		. ./myread
X	done
X		dflt=y
X		rp="Do you have buffering (printed all at once)?"
X		. ./myread
X		case "$ans" in
X		n*) val="$define";;
X		*)  val="$undef";;
X		esac
X		;;
X*)
X	case "$d_nolnbuf" in
X	"$define") dflt=n;;
X	*) dflt=y;;
X	esac
X	rp="Do you have buffering on stdout to terminals?"
X	. ./myread
X	case "$ans" in
X	n*) val="$define";;
X	*)  val="$undef";;
X	esac
X	;;
Xesac
Xset d_nolnbuf
Xeval $setvar
X
END_OF_FILE
  if test 2292 -ne `wc -c <'mcon/U/d_nolnbuf.U'`; then
    echo shar: \"'mcon/U/d_nolnbuf.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_nolnbuf.U'
fi
if test -f 'mcon/U/d_open3.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_open3.U'\"
else
  echo shar: Extracting \"'mcon/U/d_open3.U'\" \(2399 characters\)
  sed "s/^X//" >'mcon/U/d_open3.U' <<'END_OF_FILE'
X?RCS: $Id: d_open3.U,v 3.0 1993/08/18 12:06:44 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_open3.U,v $
X?RCS: Revision 3.0  1993/08/18  12:06:44  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_open3: test +cc cat +cppflags h_fcntl h_sysfile rm Setvar Findhdr
X?MAKE:	-pick add $@ %<
X?X:	It would be easy to separate the h_O_stuff from this.
X?X:	Is there a reason to do so? -- HMS
X?S:d_open3:
X?S:	This variable conditionally defines the HAS_OPEN3 manifest constant,
X?S:	which indicates to the C program that the 3 argument version of
X?S:	the open(2) function is available.
X?S:.
X?C:HAS_OPEN3 (OPEN3):
X?C:	This manifest constant lets the C program know that the three
X?C:	argument form of open(2) is available.
X?C:.
X?H:#$d_open3 HAS_OPEN3		/**/
X?H:.
X?W:%<:O_RDONLY O_WRONLY O_RDWR O_NDELAY O_APPEND O_SYNC O_CREAT O_TRUNC O_EXCL
X?LINT:set d_open3
X?LINT:change h_fcntl h_sysfile
X: Locate the flags for 'open()'
Xecho " "
X$cat >open3.c <<'EOCP'
X#include <sys/types.h>
X#ifdef I_FCNTL
X#include <fcntl.h>
X#endif
X#ifdef I_SYS_FILE
X#include <sys/file.h>
X#endif
Xmain() {
X	if(O_RDONLY);
X#ifdef O_TRUNC
X	exit(0);
X#else
X	exit(1);
X#endif
X}
XEOCP
X: check sys/file.h first to get FREAD on Sun
Xif $test `./findhdr sys/file.h` && \
X		$cc $cppflags "-DI_SYS_FILE" open3.c -o open3 >/dev/null 2>&1 ; then
X	h_sysfile=true;
X	echo "<sys/file.h> defines the O_* constants..." >&4
X	if ./open3; then
X		echo "and you have the 3 argument form of open()." >&4
X		val="$define"
X	else
X		echo "but not the 3 argument form of open().  Oh, well." >&4
X		val="$undef"
X	fi
Xelif $test `./findhdr fcntl.h` && \
X		$cc "-DI_FCNTL" open3.c -o open3 >/dev/null 2>&1 ; then
X	h_fcntl=true;
X	echo "<fcntl.h> defines the O_* constants..." >&4
X	if ./open3; then
X		echo "and you have the 3 argument form of open()." >&4
X		val="$define"
X	else
X		echo "but not the 3 argument form of open().  Oh, well." >&4
X		val="$undef"
X	fi
Xelse
X	val="$undef"
X	echo "I can't find the O_* constant definitions!  You got problems." >&4
Xfi
Xset d_open3
Xeval $setvar
X$rm -f open3*
X
END_OF_FILE
  if test 2399 -ne `wc -c <'mcon/U/d_open3.U'`; then
    echo shar: \"'mcon/U/d_open3.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_open3.U'
fi
if test -f 'mcon/U/d_safebcpy.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_safebcpy.U'\"
else
  echo shar: Extracting \"'mcon/U/d_safebcpy.U'\" \(2109 characters\)
  sed "s/^X//" >'mcon/U/d_safebcpy.U' <<'END_OF_FILE'
X?RCS: $Id: d_safebcpy.U,v 3.0 1993/08/18 12:06:58 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_safebcpy.U,v $
X?RCS: Revision 3.0  1993/08/18  12:06:58  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_safebcpy: cat d_bcopy +cc +ccflags +libs rm Oldconfig Setvar
X?MAKE:	-pick add $@ %<
X?S:d_safebcpy:
X?S:	This variable conditionally defines the HAS_SAFE_BCOPY symbol if
X?S:	the bcopy() routine can do overlapping copies.
X?S:.
X?C:HAS_SAFE_BCOPY (SAFE_BCOPY):
X?C:	This symbol, if defined, indicates that the bcopy routine is available
X?C:	to copy potentially overlapping memory blocks. Otherwise you should
X?C:	probably use memmove() or memcpy(). If neither is defined, roll your
X?C:	own version.
X?C:.
X?H:#$d_safebcpy HAS_SAFE_BCOPY	/**/
X?H:.
X?LINT: set d_safebcpy
X: can bcopy handle overlapping blocks?
X?X: assume the worst
Xval="$undef"
Xcase "$d_bcopy" in
X"$define")
X	echo " "
X	echo "Checking to see if your bcopy() can do overlapping copies..." >&4
X	$cat >foo.c <<'EOCP'
Xmain()
X{
Xchar buf[128];
Xregister char *b;
Xregister int len;
Xregister int off;
Xregister int align;
X
Xfor (align = 7; align >= 0; align--) {
X	for (len = 36; len; len--) {
X		b = buf+align;
X		bcopy("abcdefghijklmnopqrstuvwxyz0123456789", b, len);
X		for (off = 1; off <= len; off++) {
X			bcopy(b, b+off, len);
X			bcopy(b+off, b, len);
X			if (bcmp(b, "abcdefghijklmnopqrstuvwxyz0123456789", len))
X				exit(1);
X		}
X	}
X}
Xexit(0);
X}
XEOCP
X	if $cc foo.c -o safebcpy $ccflags $libs >/dev/null 2>&1 ; then
X		if ./safebcpy 2>/dev/null; then
X			echo "Yes, it can."
X			val="$define"
X		else
X			echo "It can't, sorry."
X		fi
X	else
X		echo "(I can't compile the test program, so we'll assume not...)"
X	fi
X	;;
Xesac
X$rm -f foo.* safebcpy core
Xset d_safebcpy
Xeval $setvar
X
END_OF_FILE
  if test 2109 -ne `wc -c <'mcon/U/d_safebcpy.U'`; then
    echo shar: \"'mcon/U/d_safebcpy.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_safebcpy.U'
fi
if test -f 'mcon/U/d_safemcpy.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_safemcpy.U'\"
else
  echo shar: Extracting \"'mcon/U/d_safemcpy.U'\" \(2124 characters\)
  sed "s/^X//" >'mcon/U/d_safemcpy.U' <<'END_OF_FILE'
X?RCS: $Id: d_safemcpy.U,v 3.0 1993/08/18 12:06:58 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_safemcpy.U,v $
X?RCS: Revision 3.0  1993/08/18  12:06:58  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_safemcpy: cat d_memcpy +cc +ccflags +libs rm Oldconfig Setvar
X?MAKE:	-pick add $@ %<
X?S:d_safemcpy:
X?S:	This variable conditionally defines the HAS_SAFE_MEMCPY symbol if
X?S:	the memcpy() routine can do overlapping copies.
X?S:.
X?C:HAS_SAFE_MEMCPY (SAFE_MEMCPY):
X?C:	This symbol, if defined, indicates that the memcpy routine is available
X?C:	to copy potentially overlapping memory blocks. Otherwise you should
X?C:	probably use memmove() or memcpy(). If neither is defined, roll your
X?C:	own version.
X?C:.
X?H:#$d_safemcpy HAS_SAFE_MEMCPY	/**/
X?H:.
X?LINT: set d_safemcpy
X: can memcpy handle overlapping blocks?
X?X: assume the worst
Xval="$undef"
Xcase "$d_memcpy" in
X"$define")
X	echo " "
X	echo "Checking to see if your memcpy() can do overlapping copies..." >&4
X	$cat >foo.c <<'EOCP'
Xmain()
X{
Xchar buf[128];
Xregister char *b;
Xregister int len;
Xregister int off;
Xregister int align;
X
Xfor (align = 7; align >= 0; align--) {
X	for (len = 36; len; len--) {
X		b = buf+align;
X		memcpy("abcdefghijklmnopqrstuvwxyz0123456789", b, len);
X		for (off = 1; off <= len; off++) {
X			memcpy(b, b+off, len);
X			memcpy(b+off, b, len);
X			if (memcmp(b, "abcdefghijklmnopqrstuvwxyz0123456789", len))
X				exit(1);
X		}
X	}
X}
Xexit(0);
X}
XEOCP
X	if $cc foo.c -o safemcpy $ccflags $libs >/dev/null 2>&1 ; then
X		if ./safemcpy 2>/dev/null; then
X			echo "Yes, it can."
X			val="$define"
X		else
X			echo "It can't, sorry."
X		fi
X	else
X		echo "(I can't compile the test program, so we'll assume not...)"
X	fi
X	;;
Xesac
X$rm -f foo.* safemcpy core
Xset d_safemcpy
Xeval $setvar
X
END_OF_FILE
  if test 2124 -ne `wc -c <'mcon/U/d_safemcpy.U'`; then
    echo shar: \"'mcon/U/d_safemcpy.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_safemcpy.U'
fi
if test -f 'mcon/U/d_strchr.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_strchr.U'\"
else
  echo shar: Extracting \"'mcon/U/d_strchr.U'\" \(2300 characters\)
  sed "s/^X//" >'mcon/U/d_strchr.U' <<'END_OF_FILE'
X?RCS: $Id: d_strchr.U,v 3.0 1993/08/18 12:07:32 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_strchr.U,v $
X?RCS: Revision 3.0  1993/08/18  12:07:32  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_strchr: contains strings Setvar Myread Oldconfig Csym
X?MAKE:	-pick add $@ %<
X?S:d_strchr (d_index):
X?S:	This variable conditionally defines the index and rindex symbols, which
X?S:	remap those functions onto strchr and strrchr as necessary.
X?S:.
X?C:index:
X?C:	This preprocessor symbol is defined, along with rindex, if the system
X?C:	uses the strchr and strrchr routines instead.
X?C:.
X?C:rindex:
X?C:	This preprocessor symbol is defined, along with index, if the system
X?C:	uses the strchr and strrchr routines instead.
X?C:.
X?H:#$d_strchr	index strchr	/**/
X?H:#$d_strchr	rindex strrchr	/**/
X?H:.
X?LINT:set d_strchr
X: index or strchr
Xecho " "
Xcase "$d_strchr" in
X$define) dflt=n;;
X*) dflt=y;;
Xesac
Xif set index val -f; eval $csym; $val; then
X	if set strchr val -f d_strchr; eval $csym; $val; then
X		if $contains strchr "$strings" >/dev/null 2>&1 ; then
X			if $contains index "$strings" >/dev/null 2>&1 ; then
X?X: has index, strchr, and index and strchr in string header
X				echo "Your system has both index() and strchr()." >&4
X				rp="Shall I use index() rather than strchr()?"
X				. ./myread
X				case "$ans" in
X					n*) val="$define" ;;
X					*)  val="$undef" ;;
X				esac
X			else
X?X: has index, strchr, and strchr in string header
X				val="$define"
X				echo "strchr() found." >&4
X			fi
X		else
X?X: has index, strchr, and no strchr in string header
X			val="$undef"
X			echo "index() found." >&4
X		fi
X	else
X?X: has only index, no strchr, string header is a moot point
X		val="$undef"
X		echo "index() found." >&4
X	fi
Xelse
X	if set strchr val -f d_strchr; eval $csym; $val; then
X		val="$define"
X		echo "strchr() found." >&4
X	else
X		echo "No index() or strchr() found!" >&4
X		val="$undef"
X	fi
Xfi
Xset d_strchr
Xeval $setvar
X
END_OF_FILE
  if test 2300 -ne `wc -c <'mcon/U/d_strchr.U'`; then
    echo shar: \"'mcon/U/d_strchr.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_strchr.U'
fi
if test -f 'mcon/U/d_times.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_times.U'\"
else
  echo shar: Extracting \"'mcon/U/d_times.U'\" \(2403 characters\)
  sed "s/^X//" >'mcon/U/d_times.U' <<'END_OF_FILE'
X?RCS: $Id: d_times.U,v 3.0 1993/08/18 12:07:46 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_times.U,v $
X?RCS: Revision 3.0  1993/08/18  12:07:46  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X:
X?X:	What is the type returned by times() ?
X?X:
X?X: Force inclusion of <sys/types.h>
X?X:INC: i_systypes
X?MAKE:d_times clocktype: contains Csym Findhdr Myread
X?MAKE:	-pick add $@ %<
X?S:d_times:
X?S:	This variable conditionally defines the HAS_TIMES symbol, which indicates
X?S:	that the times() routine exists.  The times() routine is normaly
X?S:	provided on UNIX systems. You may have to include <sys/times.h>.
X?S:.
X?S:clocktype:
X?S:	This variable holds the type returned by times(). It can be long,
X?S:	or clock_t on BSD sites (in which case <sys/types.h> should be
X?S:	included).
X?S:.
X?C:HAS_TIMES (TIMES):
X?C:	This symbol, if defined, indicates that the times() routine exists.
X?C:	Note that this became obsolete on some systems (SUNOS), which now
X?C: use getrusage(). It may be necessary to include <sys/times.h>.
X?C:.
X?C:Clock_t (CLOCKTYPE):
X?C:	This symbol holds the type returned by times(). It can be long,
X?C:	or clock_t on BSD sites (in which case <sys/types.h> should be
X?C:	included).
X?C:.
X?H:#$d_times HAS_TIMES		/**/
X?H:#define Clock_t $clocktype	/* Clock time */
X?H:.
X?T:val
X: see if times exists
Xecho " "
Xif set times val -f d_times; eval $csym; $val; then
X	echo 'times() found.' >&4
X	d_times="$define"
X	case "$clocktype" in
X	'')
X		if $contains 'clock_t;' `./findhdr sys/types.h` >/dev/null 2>&1 ; then
X			dflt='clock_t';
X?X: Silicon graphics machines don't define clock_t in sys/types.h.
X		elif $contains 'clock_t;' `./findhdr sys/times.h` >/dev/null 2>&1; then
X			dflt='clock_t';
X		else
X			dflt='long';
X		fi
X		;;
X	*)  dflt="$clocktype"
X		;;
X	esac
X	echo " "
X	rp="What type is returned by times() on this sytem?"
X	. ./myread
X	clocktype="$ans"
Xelse
X	echo 'times() not found, hope that will do.' >&4
X	d_times="$undef"
X?X: The following is needed for typedef (won't like an empty variable)
X	clocktype='int'
Xfi
X
END_OF_FILE
  if test 2403 -ne `wc -c <'mcon/U/d_times.U'`; then
    echo shar: \"'mcon/U/d_times.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_times.U'
fi
if test -f 'mcon/U/d_ulimit.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_ulimit.U'\"
else
  echo shar: Extracting \"'mcon/U/d_ulimit.U'\" \(997 characters\)
  sed "s/^X//" >'mcon/U/d_ulimit.U' <<'END_OF_FILE'
X?RCS: $Id: d_ulimit.U,v 3.0 1993/08/18 12:07:51 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_ulimit.U,v $
X?RCS: Revision 3.0  1993/08/18  12:07:51  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_ulimit: Inlibc
X?MAKE:	-pick add $@ %<
X?S:d_ulimit:
X?S:	This variable conditionally defines HAS_ULIMIT if ulimit() is
X?S:	available to get the user limits.
X?S:.
X?C:HAS_ULIMIT (ULIMIT):
X?C:	This symbol, if defined, indicates that the ulimit system call is
X?C:	available to get the user limits.
X?C:.
X?H:#$d_ulimit HAS_ULIMIT		/**/
X?H:.
X?LINT:set d_ulimit
X: see if ulimit exists
Xset ulimit d_ulimit
Xeval $inlibc
X
END_OF_FILE
  if test 997 -ne `wc -c <'mcon/U/d_ulimit.U'`; then
    echo shar: \"'mcon/U/d_ulimit.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_ulimit.U'
fi
if test -f 'mcon/U/d_usendir.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_usendir.U'\"
else
  echo shar: Extracting \"'mcon/U/d_usendir.U'\" \(2338 characters\)
  sed "s/^X//" >'mcon/U/d_usendir.U' <<'END_OF_FILE'
X?RCS: $Id: d_usendir.U,v 3.0 1993/08/18 12:07:52 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_usendir.U,v $
X?RCS: Revision 3.0  1993/08/18  12:07:52  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_usendir i_ndir ndirc ndiro ndirlib: test Csym Findhdr
X?MAKE:	-pick add $@ %<
X?S:d_usendir:
X?S:	This variable conditionally defines the EMULATE_NDIR symbol, which
X?S:	indicates to the C program that it should compile the ndir.c code
X?S:	provided with the package.
X?S:.
X?S:i_ndir (d_libndir):
X?S:	This variable conditionally defines the I_NDIR symbol, which
X?S:	indicates to the C program that it should include the system's
X?S:	version of ndir.h, rather than the one with this package.
X?S:.
X?S:ndirlib:
X?S:	The name of the library to include at linking stage to resolve ndir
X?S:	symbols. It is up to the makefile to use this value.
X?S:.
X?C:EMULATE_NDIR (USENDIR):
X?C:	This symbol, if defined, indicates that the program should compile
X?C:	the ndir.c code provided with the package.
X?C:.
X?C:I_NDIR (LIBNDIR):
X?C:	This symbol, if defined, indicates that the program should include the
X?C:	system's version of ndir.h, rather than the one with this package.
X?C:.
X?H:#$d_usendir EMULATE_NDIR		/**/
X?H:#$i_ndir I_NDIR		/**/
X?H:.
X?T:val
X?LINT:describe ndirc ndiro
X: see if there are directory access routines out there
Xecho " "
Xif $test `./findhdr ndir.h` && \
X	  ( $test -r /usr/lib/libndir.a || $test -r /usr/local/lib/libndir.a ); then
X	echo "Ndir library found." >&4
X	if $test -r /usr/lib/libndir.a; then
X		ndirlib='-lndir'
X	else
X		ndirlib="/usr/local/lib/libndir.a"
X	fi
X	i_ndir="$define"
X	d_usendir="$undef"
X	ndirc=''
X	ndiro=''
Xelse
X	ndirlib=''
X	i_ndir="$undef"
X	if set readdir val -f; eval $csym; $val; then
X	echo "No ndir library found, but you have readdir() so we'll use that." >&4
X		d_usendir="$undef"
X		ndirc=''
X		ndiro=''
X	else
X		echo "No ndir library found--using ./ndir.c." >&4
X		d_usendir="$define"
X		ndirc='ndir.c'
X		ndiro='ndir.o'
X	fi
Xfi
X
END_OF_FILE
  if test 2338 -ne `wc -c <'mcon/U/d_usendir.U'`; then
    echo shar: \"'mcon/U/d_usendir.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_usendir.U'
fi
if test -f 'mcon/U/d_vprintf.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_vprintf.U'\"
else
  echo shar: Extracting \"'mcon/U/d_vprintf.U'\" \(2382 characters\)
  sed "s/^X//" >'mcon/U/d_vprintf.U' <<'END_OF_FILE'
X?RCS: $Id: d_vprintf.U,v 3.0 1993/08/18 12:07:59 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_vprintf.U,v $
X?RCS: Revision 3.0  1993/08/18  12:07:59  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_vprintf d_charvspr: Guess cat +cc +ccflags Csym Setvar
X?MAKE:	-pick add $@ %<
X?S:d_vprintf:
X?S:	This variable conditionally defines the HAS_VPRINTF symbol, which
X?S:	indicates to the C program that the vprintf() routine is available
X?S:	to printf with a pointer to an argument list.
X?S:.
X?S:d_charvspr:
X?S:	This variable conditionally defines CHARVSPRINTF if this system
X?S:	has vsprintf returning type (char*).  The trend seems to be to
X?S:	declare it as "int vsprintf()".
X?S:.
X?C:HAS_VPRINTF (VPRINTF):
X?C:	This symbol, if defined, indicates that the vprintf routine is available
X?C:	to printf with a pointer to an argument list.  If unavailable, you
X?C:	may need to write your own, probably in terms of _doprnt().
X?C:.
X?C:USE_CHAR_VSPRINTF (CHARVSPRINTF):
X?C:	This symbol is defined if this system has vsprintf() returning type
X?C:	(char*).  The trend seems to be to declare it as "int vsprintf()".  It
X?C:	is up to the package author to declare vsprintf correctly based on the
X?C:	symbol.
X?C:.
X?H:#$d_vprintf HAS_VPRINTF	/**/
X?H:#$d_charvspr USE_CHAR_VSPRINTF 	/**/
X?H:.
X?T:val2
X?LINT:set d_vprintf d_charvspr
X: see if vprintf exists
Xecho " "
Xif set vprintf val -f d_vprintf; eval $csym; $val; then
X	echo 'vprintf() found.' >&4
X	val="$define"
X	$cat >vprintf.c <<'EOF'
X#include <varargs.h>
X
Xmain() { xxx("foo"); }
X
Xxxx(va_alist)
Xva_dcl
X{
X	va_list args;
X	char buf[10];
X
X	va_start(args);
X	exit((unsigned long)vsprintf(buf,"%s",args) > 10L);
X}
XEOF
X	if $cc $ccflags vprintf.c -o vprintf >/dev/null 2>&1 && ./vprintf; then
X		echo "Your vsprintf() returns (int)." >&4
X		val2="$undef"
X	else
X		echo "Your vsprintf() returns (char*)." >&4
X		val2="$define"
X	fi
Xelse
X	echo 'vprintf() NOT found.' >&4
X		val="$undef"
X		val2="$undef"
Xfi
Xset d_vprintf
Xeval $setvar
Xval=$val2
Xset d_charvspr
Xeval $setvar
X
END_OF_FILE
  if test 2382 -ne `wc -c <'mcon/U/d_vprintf.U'`; then
    echo shar: \"'mcon/U/d_vprintf.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_vprintf.U'
fi
if test -f 'mcon/U/i_dirent.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/i_dirent.U'\"
else
  echo shar: Extracting \"'mcon/U/i_dirent.U'\" \(2202 characters\)
  sed "s/^X//" >'mcon/U/i_dirent.U' <<'END_OF_FILE'
X?RCS: $Id: i_dirent.U,v 3.0 1993/08/18 12:08:17 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: i_dirent.U,v $
X?RCS: Revision 3.0  1993/08/18  12:08:17  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X:
X?X: This unit looks wether there is a dirent system or not
X?X:
X?MAKE:i_dirent d_dirnamlen: test contains Setvar Findhdr
X?MAKE:	-pick add $@ %<
X?S:i_dirent:
X?S:	This variable conditionally defines I_DIRENT, which indicates
X?S:	to the C program that it should include <dirent.h>.
X?S:.
X?S:d_dirnamlen:
X?S:	This variable conditionally defines DIRNAMLEN, which indicates
X?S:	to the C program that the length of directory entry names is
X?S:	provided by a d_namelen field.
X?S:.
X?C:I_DIRENT:
X?C:	This symbol, if defined, indicates to the C program that it should
X?C:	include <dirent.h>.
X?C:.
X?C:DIRNAMLEN:
X?C:	This symbol, if defined, indicates to the C program that the length
X?C:	of directory entry names is provided by a d_namlen field.  Otherwise
X?C:	you need to do strlen() on the d_name field.
X?C:.
X?H:#$i_dirent I_DIRENT		/**/
X?H:#$d_dirnamlen DIRNAMLEN	/**/
X?H:.
X?T:xinc
X?LINT:set i_dirent d_dirnamlen
X: see if this is a dirent system
Xecho " "
Xif xinc=`./findhdr dirent.h`; $test "$xinc"; then
X	val="$define"
X	echo "<dirent.h> found." >&4
Xelse
X	val="$undef"
X	if xinc=`./findhdr sys/dir.h`; $test "$xinc"; then
X		echo "<sys/dir.h> found." >&4
X		echo " "
X	else
X		xinc=`./findhdr sys/ndir.h`
X	fi
X	echo "<dirent.h> NOT found." >&4
Xfi
Xset i_dirent
Xeval $setvar
X
X@if d_dirnamlen || DIRNAMLEN
X: see if the directory entry stores field length
Xecho " "
Xif $contains 'd_namlen' $xinc >/dev/null 2>&1; then
X	echo "Good, your directory entry keeps length information in d_namlen." >&4
X	val="$define"
Xelse
X	echo "Your directory entry does not know about the d_namlen field." >&4
X	val="$undef"
Xfi
Xset d_dirnamlen
Xeval $setvar
X
X@end
END_OF_FILE
  if test 2202 -ne `wc -c <'mcon/U/i_dirent.U'`; then
    echo shar: \"'mcon/U/i_dirent.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/i_dirent.U'
fi
if test -f 'mcon/U/i_varhdr.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/i_varhdr.U'\"
else
  echo shar: Extracting \"'mcon/U/i_varhdr.U'\" \(2135 characters\)
  sed "s/^X//" >'mcon/U/i_varhdr.U' <<'END_OF_FILE'
X?RCS: $Id: i_varhdr.U,v 3.0 1993/08/18 12:08:49 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: i_varhdr.U,v $
X?RCS: Revision 3.0  1993/08/18  12:08:49  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:i_varhdr: cat +cc +ccflags rm i_stdarg i_varargs
X?MAKE:	-pick add $@ %<
X?S:i_varhdr:
X?S:	Contains the name of the header to be included to get va_dcl definition.
X?S:	Typically one of varargs.h or stdarg.h.
X?S:.
X?W:%<:va_dcl
X?LINT:change i_stdarg i_varargs
X: set up the varargs testing programs
X$cat > varargs.c <<EOP
X#ifdef I_STDARG
X#include <stdarg.h>
X#endif
X#ifdef I_VARARGS
X#include <varargs.h>
X#endif
X
X?X: if you have stdarg.h, you need to support prototypes to actually use it;
X?X: but if stdarg.h exists and the compiler doesn't support prototypes (for some
X?X: bizarre reason), we'll fall back to varargs.h anyway so it's not so bad.
X#ifdef I_STDARG
Xint f(char *p, ...)
X#else
Xint f(va_alist)
Xva_dcl
X#endif
X{
X	va_list ap;
X#ifndef I_STDARG
X	char *p;
X#endif
X#ifdef I_STDARG
X	va_start(ap,p);
X#else
X	va_start(ap);
X	p = va_arg(ap, char *);
X#endif
X	va_end(ap);
X}
XEOP
X$cat > varargs <<EOP
Xif $cc -c $ccflags -D\$1 varargs.c >/dev/null 2>&1; then
X	echo "true"
Xelse
X	echo "false"
Xfi
X$rm -f varargs.o
XEOP
Xchmod +x varargs
X
X: now check which varargs header should be included
Xecho " "
Xi_varhdr=''
Xcase "$i_stdarg" in
X"$define")
X	if `./varargs I_STDARG`; then
X		i_varhdr='stdarg.h'
X		i_varargs="$undef"
X	elif `./varargs I_VARARGS`; then
X		i_varhdr='varargs.h'
X		i_stdarg="$undef"
X	fi
X	;;
X*)
X	if `./varargs I_VARARGS`; then
X		i_varhdr='varargs.h'
X	fi
X	;;
Xesac
Xcase "$i_varhdr" in
X'')
Xecho "I could not find the definition for va_dcl... You have problems..." >&4
X	;;
X*) echo "We'll include <$i_varhdr> to get va_dcl definition." >&4;;
Xesac
X$rm -f varargs*
X
END_OF_FILE
  if test 2135 -ne `wc -c <'mcon/U/i_varhdr.U'`; then
    echo shar: \"'mcon/U/i_varhdr.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/i_varhdr.U'
fi
if test -f 'mcon/U/orderlib.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/orderlib.U'\"
else
  echo shar: Extracting \"'mcon/U/orderlib.U'\" \(2197 characters\)
  sed "s/^X//" >'mcon/U/orderlib.U' <<'END_OF_FILE'
X?RCS: $Id: orderlib.U,v 3.0 1993/08/18 12:09:26 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: orderlib.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:26  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:orderlib ranlib: cat test rm +cc
X?MAKE:	-pick add $@ %<
X?S:orderlib:
X?S:	This variable is "true" if the components of libraries must be ordered
X?S:	(with `lorder $* | tsort`) before placing them in an archive.  Set to
X?S:	"false" if ranlib or ar can generate random libraries.
X?S:.
X?S:ranlib:
X?S:	This variable is set to the pathname of the ranlib program, if it is
X?S:	needed to generate random libraries.  Set to ":" if ar can generate
X?S:	random libraries or if random libraries are not supported
X?S:.
X: see if ar generates random libraries by itself
Xecho " "
Xecho "Checking how to generate random libraries on your machine..." >&4
X?X: Some systems (like MIPS) complain when running ar... Others like Ultrix
X?X: need an explicit 'ar ts' to add the table of contents.
X$cat >a.c <<EOP
Xf() { exit(0); }
XEOP
Xcc -c a.c >/dev/null 2>&1
Xar rc ran.a a.o >/dev/null 2>&1
X$cat >b.c <<EOP
Xmain() { f(); }
XEOP
Xcp ran.a lib.a
Xif ar ts ran.a >/dev/null 2>&1; then
X	if $cc -o b b.c lib.a >/dev/null 2>&1; then
X		echo "ar appears to generate random libraries itself."
X		orderlib=false
X		ranlib=":"
X	else
X		echo "a table of contents needs to be added with 'ar ts'."
X		orderlib=false
X		ranlib="ar ts"
X	fi
Xelse
X	if $test -f /usr/bin/ranlib; then
X		ranlib=/usr/bin/ranlib
X	elif $test -f /bin/ranlib; then
X		ranlib=/bin/ranlib
X	fi
X
X	if $test -n "$ranlib"; then
X		echo "your system has $ranlib; we'll use that."
X		orderlib=false
X	else
X		echo "your system doesn't seem to support random libraries"
X		echo "so we'll use lorder and tsort to order the libraries."
X		orderlib=true
X		ranlib=":"
X	fi
Xfi
X$rm -f a.* b.c b.o b ran.a lib.a
X
END_OF_FILE
  if test 2197 -ne `wc -c <'mcon/U/orderlib.U'`; then
    echo shar: \"'mcon/U/orderlib.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/orderlib.U'
fi
if test -f 'mcon/U/sockopt.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/sockopt.U'\"
else
  echo shar: Extracting \"'mcon/U/sockopt.U'\" \(2359 characters\)
  sed "s/^X//" >'mcon/U/sockopt.U' <<'END_OF_FILE'
X?RCS: $Id: sockopt.U,v 3.0 1993/08/18 12:09:48 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: sockopt.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:48  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_keepalive: cat rm contains +cc +ccflags socketlib sockethdr \
X	d_oldsock libs Oldconfig Setvar Findhdr
X?MAKE:	-pick add $@ %<
X?S:d_keepalive:
X?S:	This symbol conditionally defines KEEPALIVE which indicates to the C
X?S:	program that setsockopt SO_KEEPALIVE will work properly.
X?S:.
X?C:KEEPALIVE:
X?C:	This symbol if defined indicates to the C program that the SO_KEEPALIVE
X?C:	option of setsockopt() will work as advertised in the manual.
X?C:.
X?H:#$d_keepalive KEEPALIVE		/**/
X?H:.
X?LINT:set d_keepalive
X: see if setsockopt with SO_KEEPALIVE works as advertised
Xecho " "
Xcase "$d_oldsock" in
X"$undef")
X	if $contains SO_KEEPALIVE `./findhdr sys/socket.h` \
X		/dev/null >/dev/null 2>&1
X	then
X		echo "OK, let's see if SO_KEEPALIVE works as advertised..." >&4
X		$cat > socket.c <<EOP
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <netdb.h>
X
Xmain()
X{
X	int s = socket(AF_INET, SOCK_STREAM, 0);
X	if (s == -1)
X		exit(1);
X	if (-1 == setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, 0, 0))
X		exit(2);
X	exit(0);
X}
XEOP
X		if $cc $ccflags $sockethdr socket.c -o socket $libs \
X			$socketlib >/dev/null 2>&1; then
X			./socket >/dev/null 2>&1
X			case $? in
X			0) echo "Yes, it does!"
X				val="$define";;
X			1) $cat <<EOM
X(Something went wrong -- Assuming SO_KEEPALIVE is broken)
XEOM
X				val="$undef";;
X			2) echo "No, it doesn't.  Don't trust your manuals!!"
X				val="$undef";;
X			esac
X		else
X			cat <<EOM
X(I can't compile the test program -- Assuming SO_KEEPALIVE is broken)
XEOM
X			val="$undef"
X		fi
X	else
X		echo "Strange!! You have BSD 4.2 sockets but no SO_KEEPALIVE option."
X		val="$undef"
X	fi;;
X*) cat <<EOM
XAs you have an old socket interface, you can't have heard of SO_KEEPALIVE.
XEOM
X	val="$undef";;
Xesac
Xset d_keepalive
Xeval $setvar
X$rm -f socket socket.c
X
END_OF_FILE
  if test 2359 -ne `wc -c <'mcon/U/sockopt.U'`; then
    echo shar: \"'mcon/U/sockopt.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/sockopt.U'
fi
if test -f 'mcon/U/usrinc.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/usrinc.U'\"
else
  echo shar: Extracting \"'mcon/U/usrinc.U'\" \(2163 characters\)
  sed "s/^X//" >'mcon/U/usrinc.U' <<'END_OF_FILE'
X?RCS: $Id: usrinc.U,v 3.0 1993/08/18 12:09:58 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: usrinc.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:58  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:usrinc mips incpath mips_type: test cat echo n c +cc Getfile Guess \
X	Oldconfig eunicefix contains rm
X?MAKE:	-pick add $@ %<
X?S:usrinc:
X?S:	This variable holds the path of the include files, which is
X?S:	usually /usr/include. It is mainly used by other Configure units.
X?S:.
X?S:incpath:
X?S:	This variable must preceed the normal include path to get hte
X?S:	right one, as in "$incpath/usr/include" or "$incpath/usr/lib".
X?S:	Value can be "" or "/bsd43" on mips.
X?S:.
X?S:mips_type:
X?S:	This variable holds the environment type for the mips system.
X?S:	Possible values are "BSD 4.3" and "System V".
X?S:.
X?D:usrinc='/usr/include'
X?LINT:describe mips
X?LINT:set mips
X: What should the include directory be ?
Xecho " "
X$echo $n "Hmm...  $c"
Xcase "$usrinc" in
X'') dflt='/usr/include';;
X*) dflt=$usrinc;;
Xesac
Xincpath=''
X?X:	mips_type is used later, to add -DSYSTYPE_BSD43 to cppflags if needed.
Xmips_type=''
X?X:
X?X:	Cannot put the following in Guess, or we get a circular dependency.
X?X:
Xif $test -f /bin/mips && /bin/mips; then
X	echo "Looks like a MIPS system..."
X	$cat >usr.c <<'EOCP'
X#ifdef SYSTYPE_BSD43
X/bsd43
X#endif
XEOCP
X	if $cc -E usr.c > usr.out && $contains / usr.out >/dev/null 2>&1; then
X		dflt='/bsd43/usr/include'
X		incpath='/bsd43'
X		mips_type='BSD 4.3'
X	else
X		mips_type='System V'
X	fi
X	$rm -f usr.c usr.out
X	echo "and you're compiling with the $mips_type compiler and libraries."
Xelse
X	echo "Doesn't look like a MIPS system."
X	echo "exit 1" >mips
X	chmod +x mips
X	$eunicefix mips
Xfi
Xecho " "
Xfn=d/
Xrp='Where are the include files you want to use?'
X. ./getfile
Xusrinc="$ans"
X
END_OF_FILE
  if test 2163 -ne `wc -c <'mcon/U/usrinc.U'`; then
    echo shar: \"'mcon/U/usrinc.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/usrinc.U'
fi
echo shar: End of archive 18 \(of 28\).
cp /dev/null ark18isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Please run PACKNOTES through sh, read REAMDE and then type Configure."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
