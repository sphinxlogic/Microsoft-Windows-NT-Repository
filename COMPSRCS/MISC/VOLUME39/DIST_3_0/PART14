Newsgroups: comp.sources.misc
From: Raphael Manfredi <ram@acri.fr>
Subject: v39i018:  dist-3.0 - Configure script generator and related tools, Part14/28
Message-ID: <1993Aug19.131316.5520@sparky.sterling.com>
X-Md4-Signature: 9533ac3d42d745f432b10e1e30f4b494
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Advanced Computer Research Institute, Lyon, France.
Date: Thu, 19 Aug 1993 13:13:16 GMT
Approved: kent@sparky.sterling.com

Submitted-by: Raphael Manfredi <ram@acri.fr>
Posting-number: Volume 39, Issue 18
Archive-name: dist-3.0/part14
Environment: UNIX, Perl, RCS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  bin/Makefile.SH install.SH mcon/INTRO mcon/U/Findhdr.U
#   mcon/U/Instruct.U mcon/U/d_SHM_MAC.U mcon/U/d_socket.U
#   mcon/U/ipc.U mcon/U/prototype.U mcon/U/randfunc.U
#   mcon/man/Makefile.SH pat/patname.SH
# Wrapped by ram@soft208 on Wed Aug 18 14:42:21 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 14 (of 28)."'
if test -f 'bin/Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bin/Makefile.SH'\"
else
  echo shar: Extracting \"'bin/Makefile.SH'\" \(4320 characters\)
  sed "s/^X//" >'bin/Makefile.SH' <<'END_OF_FILE'
X: Makefile.SH generated from Jmake.tmpl and Jmakefile [jmake 3.0 PL0]
X: $X-Id: Jmake.tmpl,v 2.8.1.2 91/11/18 13:22:54 ram Exp $
X
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
XCURRENT=bin
XDIR=`echo $CURRENT/ | sed -e 's/\.\///g'`
Xecho "Extracting ${DIR}Makefile (with variable substitutions)"
XDATE=`date`
X$spitshell >Makefile <<!GROK!THIS!
X########################################################################
X# Makefile generated from Makefile.SH on $DATE
X
XSHELL = /bin/sh
XJMAKE = jmake
XTOP = ..
XCURRENT = $CURRENT
XDIR = $DIR
XINSTALL = ../install
X
X########################################################################
X# Parameters set by Configure -- edit config.sh if changes are needed
X
XCTAGS = ctags
XL = $manext
XMANSRC = $installmansrc
XMAKE = make
XMV = $mv
XRM = $rm -f
XSCRIPTDIR = $installscript
X
X########################################################################
X# Automatically generated parameters -- do not edit
X
XSCRIPTS =  \$(BIN)
X
X!GROK!THIS!
X$spitshell >>Makefile <<'!NO!SUBS!'
X########################################################################
X# Jmake rules for building libraries, programs, scripts, and data files
X# $X-Id: Jmake.rules,v 2.8.1.4 91/11/18 13:19:07 ram Exp $
X
X########################################################################
X# Start of Jmakefile
X
X# $X-Id: Jmakefile,v 2.8.1.1 91/10/18 10:09:07 ram Exp $
X#
X#  Copyright (c) 1991-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic Licence,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic Licence; a copy of which may be found at the root
X#  of the source tree for dist 3.0.
X#
X# $X-Log:	Jmakefile,v $
X
XBIN = packinit manicheck manilist
X
Xall:: $(BIN)
X
Xlocal_realclean::
X	$(RM) $(BIN)
X
Xpackinit: packinit.SH
X	/bin/sh packinit.SH
X
Xmanicheck: manicheck.SH
X	/bin/sh manicheck.SH
X
Xmanilist: manilist.SH
X	/bin/sh manilist.SH
X
X
Xinstall:: $(SCRIPTS) $(LSCRIPTS)
X	@for file in $(SCRIPTS) $(LSCRIPTS); do \
X		case '${MFLAGS}' in *[i]*) set +e;; esac; \
X		(set -x; $(INSTALL) -c -m 555 $$file $(SCRIPTDIR)); \
X	done
X
Xdeinstall::
X	@for file in $(SCRIPTS) $(LSCRIPTS); do \
X		case '${MFLAGS}' in *[i]*) set +e;; esac; \
X		(set -x; $(RM) $(SCRIPTDIR)/$$file); \
X	done
X
Xinstall.man::
X	@if test "$(MANSRC)"; then \
X		case '${MFLAGS}' in *[i]*) set +e;; esac; \
X		for file in $(SCRIPTS); do \
X			(set -x; \
X			$(INSTALL) -c -m 444 $$file.man $(MANSRC)/$$file.$(L)); \
X		done; \
X	else exit 0; fi
X
Xdeinstall.man::
X	@if test "$(MANSRC)"; then \
X		case '${MFLAGS}' in *[i]*) set +e;; esac; \
X		for file in $(SCRIPTS); do \
X			(set -x; $(RM) $(MANSRC)/$$file.$(L)); \
X		done; \
X	else exit 0; fi
X
X########################################################################
X# Common rules for all Makefiles -- do not edit
X
Xemptyrule::
X
Xclean: local_clean
Xrealclean: local_realclean
Xclobber: local_clobber
X
Xlocal_clean::
X	$(RM) core *~ *.o
X
Xlocal_realclean:: local_clean
X
Xlocal_clobber:: local_realclean
X	$(RM) Makefile config.sh
X
XMakefile.SH: Jmakefile
X	-@if test -f $(TOP)/.package; then \
X		if test -f Makefile.SH; then \
X			echo "	$(RM) Makefile.SH~; $(MV) Makefile.SH Makefile.SH~"; \
X			$(RM) Makefile.SH~; $(MV) Makefile.SH Makefile.SH~; \
X		fi; \
X		echo "	$(JMAKE) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT)" ; \
X		$(JMAKE) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT) ; \
X	else touch $@; exit 0; fi
X
XMakefile: Makefile.SH
X	/bin/sh Makefile.SH
X
Xtags::
X	$(CTAGS) -w *.[ch]
X	$(CTAGS) -xw *.[ch] > tags
X
Xlocal_clobber::
X	$(RM) tags
X
X########################################################################
X# Empty rules for directories with no sub-directories -- do not edit
X
Xinstall::
X	@echo "install in $(CURRENT) done."
X
Xdeinstall::
X	@echo "deinstall in $(CURRENT) done."
X
Xinstall.man::
X	@echo "install.man in $(CURRENT) done."
X
Xdeinstall.man::
X	@echo "deinstall.man in $(CURRENT) done."
X
XMakefiles::
X
XMakefiles.SH::
X
X!NO!SUBS!
Xchmod 644 Makefile
X$eunicefix Makefile
X
END_OF_FILE
  if test 4320 -ne `wc -c <'bin/Makefile.SH'`; then
    echo shar: \"'bin/Makefile.SH'\" unpacked with wrong size!
  fi
  # end of 'bin/Makefile.SH'
fi
if test -f 'install.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'install.SH'\"
else
  echo shar: Extracting \"'install.SH'\" \(3962 characters\)
  sed "s/^X//" >'install.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting install (with variable substitutions)"
X$spitshell >install <<!GROK!THIS!
X$startsh
X# @(#) Installing script accepting bsd-style arguments
X
X# $Id: install.SH,v 3.0 1993/08/18 12:04:08 ram Exp $
X#
X#  Copyright (c) 1991-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic Licence,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic Licence; a copy of which may be found at the root
X#  of the source tree for dist 3.0.
X#
X# $Log: install.SH,v $
X# Revision 3.0  1993/08/18  12:04:08  ram
X# Baseline for dist 3.0 netwide release.
X#
X
Xchown='$chown'
Xchmod='$chmod'
Xchgrp='$chgrp'
Xrm='$rm'
Xmv='$mv'
Xtest='$test'
Xsed='$sed'
X!GROK!THIS!
X$spitshell >>install <<'!NO!SUBS!'
X
Xmode=""
Xdst=""
Xsrc=""
Xdostrip=""
Xnewdir=""
Xuid=""
Xgid=""
X
X# simulates mkdir -p
Xmkdir_p='
Xname=$1;
Xcreate="";
Xwhile $test $name; do
X	if $test ! -d "$name"; then
X		create="$name $create";
X		name=`echo $name | $sed -e "s|^[^/]*$||"`;
X		name=`echo $name | $sed -e "s|\(.*\)/.*|\1|"`;
X	else
X		name="";
X	fi;
Xdone;
Xfor file in $create; do
X	mkdir $file && $test $verbose &&
X	echo "install: created directory $file" >&2;
Xdone
X'
X
Xverbose=''
X
Xwhile $test x$1 != x
Xdo
X	case $1 in 
X	-c) shift
X		continue
X		;;
X	-m) mode="$2 "
X		shift
X		shift
X		continue
X		;;
X	-o) uid="$2 "
X		shift
X		shift
X		continue
X		;;
X	-g) gid="$2 "
X		shift
X		shift
X		continue
X		;;
X	-s) dostrip="strip"
X		shift
X		continue
X		;;
X	-d) newdir="$newdir$2 "
X		shift
X		shift
X		continue
X		;;
X	-v) verbose='true'
X		shift
X		;;
X	*) if $test x$src = x
X		then
X			src=$1
X		else
X			dst=$1
X		fi
X		shift
X		continue
X		;;
X	esac
Xdone
X
X# if -d option is used, we have to create the path given
Xif $test ! x$newdir = x
Xthen
X	for i in $newdir
X	do
X		set x $i
X		shift
X		eval $mkdir_p
X	done
X	exit 0		# -d is the only action
Xfi
X
Xif $test x$src = x
Xthen
X	echo "install: no input file specified" >&2
X	exit 1
Xfi
X
Xif $test x$dst = x
Xthen
X	echo "install: no destination specified" >&2
X	exit 1
Xfi
X
Xsrcbase=`basename $src`
Xdstbase=`basename $dst`
X
X# If the destination is a directory, the target name is srcbase...
Xif $test -d $dst; then
X	dstbase=$srcbase
Xelse
X	dst="`echo $dst | sed 's,^\(.*\)/.*$,\1,'`"
X	if $test ! -d $dst; then
X		dstbase=$dst
X		dst="."
X	fi
Xfi
X
X# If the src has a directory, extract the dir name...
Xif $test "$src" != "$srcbase" -a "$src" != "./$srcbase"; then
X	src="`echo $src | sed 's,^\(.*\)/.*$,\1,'`"
Xelse
X	src="."
Xfi
X
X# dst is the destination directory and dstbase the base name.
X# srcbase is the base name of source and src the source dir.
X
Xsrcpth=`(cd $src; pwd)`/$srcbase
Xdestpth=`(cd $dst; pwd)`/$dstbase
Xif $test x$srcpth = x$destpth; then
X	$test $verbose && \
X	echo "install: destination and source are identical"
X	exit 0
Xfi
X
X# Do the install
X(
X	cd $src
X
X	if $test -f $dst/$dstbase; then
X		$rm -f $dst/$dstbase && $test $verbose &&
X		echo "install: $dst/$dstbase removed"
X	fi
X	if $test -f $dst/$dstbase; then
X		$mv $dst/$dstbase $dst/OLD$dstbase && $test $verbose &&
X		echo "install: $dst/$dstbase renamed as OLD$dstbase"
X	fi
X
X	cp $srcbase $dst/$dstbase && $test $verbose &&
X	echo "install: $srcbase installed as $dst/$dstbase"
X
X	if $test ! x$dostrip = x; then
X		strip $dst/$dstbase 2>/dev/null && $test $verbose &&
X		echo "install: stripped $dst/$dstbase"
X	fi
X
X	if $test ! x$uid = x; then
X		$chown $uid $dst/$dstbase
X	fi
X	if $test ! x$gid = x; then
X		$chgrp $gid $dst/$dstbase
X	fi
X	if $test ! x$mode = x
X	then
X		$chmod $mode $dst/$dstbase
X	fi
X)
X
Xexit 0
X!NO!SUBS!
Xchmod 755 install
X$eunicefix install
END_OF_FILE
  if test 3962 -ne `wc -c <'install.SH'`; then
    echo shar: \"'install.SH'\" unpacked with wrong size!
  fi
  chmod +x 'install.SH'
  # end of 'install.SH'
fi
if test -f 'mcon/INTRO' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/INTRO'\"
else
  echo shar: Extracting \"'mcon/INTRO'\" \(3907 characters\)
  sed "s/^X//" >'mcon/INTRO' <<'END_OF_FILE'
XThis is a quick introduction to metaconfig.
X
XMetaconfig is a combination of a methodology and a program that will
Xhelp you write portable programs.  It is well known that all UN*X
Xsystems are not the same.  Instead of writing lots of #ifdef/#endif for
Xeach machine the program is ported on, it seems better to directly rely
Xon the actual possibilities of the system, without having to consider
Xwhether it comes from HP or SUN.  The idea is to write the program using
Xsome symbols, known by a "unit", for all the hardware- or kernel-
Xspecific parts of code.  A metaconfig unit will automatically define the
Xsymbol or not, depending on the system.  Source files are scanned by
Xmetaconfig and the necessary units are loaded and put into a shell
Xscript called Configure.  Running the Configure script will
Xautomatically determine a suitable value for each symbol.
X
XHow does a Configure script work ? It studies the environment it runs on
Xby extracting names in the C library, by compiling some small sample C
Xprograms, and by asking questions when in doubt, always providing a
Xcomputed default answer.
X
XHere is a small example.
X
XIt is said in the glossary of the symbols that RENAME is defined if the
Xrename routine is available to rename files.  Without metaconfig, we
Xcould write (for each occurrence of a "rename" in the code):
X
X#if defined(HP-UX-7.0) || defined(SUN) || defined(BSD)
X	rename(old, new);
X#else
X	unlink(new);
X	link(old, new);
X	unlink(old);
X#endif
X
XWith the help of metaconfig, we shall write (once !):
X
X#ifndef HAS_RENAME
Xint rename(old, new)
Xchar *old, *new;
X{
X	(void) unlink(new);
X	if (-1 != link(old, new))
X		return unlink(old);
X	else
X		return -1;
X}
X#endif
X
X	....
X
X	rename(old, new);
X
X
XAnd that's all.  The Configure script will check whether `rename' is
Xavailable on the target machine and accordingly define the RENAME
Xsymbol.  It is even more powerful that it may appear on a first glance,
Xbecause "rename" was not there on old SUNOS3 systems or HP-UX older than
X6.5 (for series 800) and 7.0 (for series 300).  You cannot rely on the
Xfact that the target machine has the latest OS release !
X
XAnother problem is to determine whether a C program should include
X<time.h>, <sys/time.h> or <sys/time.h> with KERNEL defined.  With
Xmetaconfig, you simply write:
X
X#ifdef I_TIME
X#	include <time.h>
X#endif
X#ifdef I_SYS_TIME
X#	include <sys/time.h>
X#endif
X#ifdef I_SYS_TIME_KERNEL
X#	define KERNEL
X#	include <sys/time.h>
X#	undef KERNEL
X#endif
X
Xand the Configure script will generate a small C program, compile it,
Xand correctly define one of the three symbols I_TIME, I_SYS_TIME and
XI_SYS_TIME_KERNEL.
X
XAnother kind of precious information can be collected by a Configure
Xscript.  For instance, the symbol USE_STRUCT_COPY will be defined if the
XC compiler can copy structures.  It is up to the programmer to use this
Xinformation, of course.  The symbol VOIDSIG will be defined if the
Xsystem declares "void (*signal())()" instead of "int (*signal())()".
XThus you can say:
X
X#ifdef VOIDSIG
Xextern void (*signal())();
X#else
Xextern int (*signal())();
X#endif
X
Xand no suspicious warning will be emitted by the C compiler.
X
XFinally, Configure can help you in shell scripts or in makefile.  By
Xusing a file called Makefile.SH, which will be run through a shell to
Xproduce a Makefile, you can use the variable substitution feature.  The
Xvariable $ranlib will be set to 'ranlib' or to ': ' (null statement) in
Xa makefile, which is useful for random libraries generation.  Likewise,
Xthe variable $bin will hold the full path for installing binaries (a
Xquestion will be issued by Configure).
X
XNeedless to say, an initial amount of time must be spent before being
Xable to use metaconfig.  The proper symbols must be known, and the
Xprogram must be prepared to deal with all the possible configurations.
XBut likewise, it will adapt itself to a greater number of systems
Xwithout any further source code modification.
X
END_OF_FILE
  if test 3907 -ne `wc -c <'mcon/INTRO'`; then
    echo shar: \"'mcon/INTRO'\" unpacked with wrong size!
  fi
  # end of 'mcon/INTRO'
fi
if test -f 'mcon/U/Findhdr.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/Findhdr.U'\"
else
  echo shar: Extracting \"'mcon/U/Findhdr.U'\" \(3005 characters\)
  sed "s/^X//" >'mcon/U/Findhdr.U' <<'END_OF_FILE'
X?RCS: $Id: Findhdr.U,v 3.0 1993/08/18 12:04:54 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: Original Author: Thomas Neumann <tom@smart.bo.open.de>
X?RCS:
X?RCS: $Log: Findhdr.U,v $
X?RCS: Revision 3.0  1993/08/18  12:04:54  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X:
X?X: This unit produces a findhdr script which is used to locate the header
X?X: files in $usrinc or other stranger places using cpp capabilities. The
X?X: script is given an include file base name, like 'stdio.h' or 'sys/file.h'
X?X: and it returns the full path of the include file and a zero status or an
X?X: empty string with an error status if the file could not be located.
X?X:
X?MAKE:Findhdr: grep test tr rm +usrinc awk cat startsh \
X	cppstdin cppminus +cppflags
X?MAKE:	-pick add $@ %<
X?LINT:define fieldn
X?S:fieldn:
X?S:	This variable is used internally by Configure. It contains the position
X?S:	of the included file name in cpp output. That is to say, when cpp
X?S:	pre-processes a #include <file> line, it replaces it by a # line which
X?S:	contains the original position in the input file and the full name of
X?S:	included file, between "quotes".
X?S:.
X?V:fieldn
X?T:cline pos wanted name awkprg
X: determine filename position in cpp output
Xecho " "
Xecho "Computing filename position in cpp output for #include directives..." >&4
Xecho '#include <stdio.h>' > foo.c
X$cat >fieldn <<EOF
X$startsh
X$cppstdin $cppminus $cppflags <foo.c 2>/dev/null | \
X$grep '^[ 	]*#.*stdio\.h' | \
Xwhile read cline; do
X	pos=1
X	set \$cline
X	while $test \$# -gt 0; do
X		if $test -r \`echo \$1 | $tr -d '"'\`; then
X			echo "\$pos"
X			exit 0
X		fi
X		shift
X		pos=\`expr \$pos + 1\`
X	done
Xdone
XEOF
Xchmod +x fieldn
Xfieldn=`./fieldn`
X$rm -f foo.c fieldn
Xcase $fieldn in
X'') pos='???';;
X1) pos=first;;
X2) pos=second;;
X3) pos=third;;
X*) pos="${fieldn}th";;
Xesac
Xecho "Your cpp writes the filename in the $pos field of the line."
X
X?X: To locate a header file, we cannot simply check for $usrinc/file.h, since
X?X: some machine have the headers in weird places and our only hope is that
X?X: the C pre-processor will know how to find those headers. Thank you NexT!
X: locate header file
X$cat >findhdr <<EOF
X$startsh
Xwanted=\$1
Xname=''
Xif test -f $usrinc/\$wanted; then
X	echo "$usrinc/\$wanted"
X	exit 0
Xfi
Xawkprg='{ print \$$fieldn }'
Xecho "#include <\$wanted>" > foo\$\$.c
X$cppstdin $cppminus $cppflags < foo\$\$.c 2>/dev/null | \
X$grep "^[ 	]*#.*\$wanted" | \
Xwhile read cline; do
X	name=\`echo \$cline | $awk "\$awkprg" | $tr -d '"'\`
X	case "\$name" in
X	*/\$wanted) echo "\$name"; exit 0;;
X	*) name='';;
X	esac;
Xdone;
X$rm -f foo\$\$.c;
Xcase "\$name" in
X'') exit 1;;
Xesac
XEOF
Xchmod +x findhdr
X
END_OF_FILE
  if test 3005 -ne `wc -c <'mcon/U/Findhdr.U'`; then
    echo shar: \"'mcon/U/Findhdr.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/Findhdr.U'
fi
if test -f 'mcon/U/Instruct.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/Instruct.U'\"
else
  echo shar: Extracting \"'mcon/U/Instruct.U'\" \(3887 characters\)
  sed "s/^X//" >'mcon/U/Instruct.U' <<'END_OF_FILE'
X?RCS: $Id: Instruct.U,v 3.0 1993/08/18 12:05:04 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: Instruct.U,v $
X?RCS: Revision 3.0  1993/08/18  12:05:04  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X: 
X?X: This unit spew out the directions that we want everyone to read.  I try to
X?X: keep the first "pagefull" much less than a page since they don't know it
X?X: isn't going to go shooting off the top of the screen, and we don't want
X?X: to panic them yet.
X?X: 
X?MAKE:Instruct: Myread Configdir contains
X?MAKE:	-pick wipe $@ %<
X?T:user needman firsttime
X: general instructions
Xneedman=true
Xfirsttime=true
X?X: need space for ksh--see cf_who.U
Xuser=`( (logname) 2>/dev/null || whoami) 2>&1`
Xif $contains "^$user\$" ../.config/instruct >/dev/null 2>&1; then
X	firsttime=false
X	echo " "
X	rp='Would you like to see the instructions?'
X	dflt=n
X	. ./myread
X	case "$ans" in
X	[yY]*) ;;
X	*) needman=false;;
X	esac
Xfi
Xif $needman; then
X	cat <<EOH
X 
XThis installation shell script will examine your system and ask you questions
Xto determine how the <PACKAGENAME> package should be installed. If you get
Xstuck on a question, you may use a ! shell escape to start a subshell or
Xexecute a command.  Many of the questions will have default answers in square
Xbrackets; typing carriage return will give you the default.
X
XOn some of the questions which ask for file or directory names you are allowed
Xto use the ~name construct to specify the login directory belonging to "name",
Xeven if you don't have a shell which knows about that.  Questions where this is
Xallowed will be marked "(~name ok)".
X
XEOH
X	rp=''
X	dflt='Type carriage return to continue'
X	. ./myread
X	cat <<'EOH'
X
XThe prompter used in this script allows you to use shell variables and
Xbackticks in your answers.  You may use $1, $2, etc...  to refer to the words
Xin the default answer, as if the default line was a set of arguments given to a
Xscript shell.  This means you may also use $* to repeat the whole default line,
Xso you do not have to re-type everything to add something to the default.
X
XEverytime there is a substitution, you will have to confirm.  If there is an
Xerror (e.g. an unmatched backtick), the default answer will remain unchanged
Xand you will be prompted again.
X
XIf you are in a hurry, you may run 'Configure -d'.  This will bypass nearly all
Xthe questions and use the computed defaults (or the previous answers if there
Xwas already a config.sh file). Type 'Configure -h' for a list of options.
X
XEOH
X	. ./myread
X	cat <<EOH
X
XMuch effort has been expended to ensure that this shell script will run on any
XUnix system.  If despite that it blows up on yours, your best bet is to edit
XConfigure and run it again.  Also, let me (<MAINTLOC>)
Xknow how I blew it.  If you can't run Configure for some reason, you'll have to
Xgenerate a config.sh file by hand.
X
XThis installation script affects things in two ways:
X
X1) it may do direct variable substitutions on some of the files included
X   in this kit.
X2) it builds a config.h file for inclusion in C programs.  You may edit
X   any of these files as the need arises after running this script.
X
XIf you make a mistake on a question, there is no easy way to back up to it
Xcurrently.  The easiest thing to do is to edit config.sh and rerun all the SH
Xfiles.  Configure will offer to let you do this before it runs the SH files.
X
XEOH
X?X: In case they played with the prompter...
X	dflt='Type carriage return to continue'
X	. ./myread
X	case "$firsttime" in
X	true) echo $user >>../.config/instruct;;
X	esac
Xfi
X
END_OF_FILE
  if test 3887 -ne `wc -c <'mcon/U/Instruct.U'`; then
    echo shar: \"'mcon/U/Instruct.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/Instruct.U'
fi
if test -f 'mcon/U/d_SHM_MAC.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_SHM_MAC.U'\"
else
  echo shar: Extracting \"'mcon/U/d_SHM_MAC.U'\" \(3859 characters\)
  sed "s/^X//" >'mcon/U/d_SHM_MAC.U' <<'END_OF_FILE'
X?RCS: $Id: d_SHM_MAC.U,v 3.0 1993/08/18 12:05:41 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_SHM_MAC.U,v $
X?RCS: Revision 3.0  1993/08/18  12:05:41  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:d_SHM_MAC d_SHM_PRM d_SHM_SEG d_SHM_IMMU: cat d_shm test rm +cc +ccflags
X?MAKE:	-pick add $@ %<
X?S:d_SHM_MAC:
X?S:	Sometimes, the SHMLBA manifest needs sys/sysmacros.h, usually for
X?S:	the ctob() macro.
X?S:.
X?S:d_SHM_PRM:
X?S:	Sometimes, the SHMLBA manifest needs sys/param.h, usually for the
X?S:	NBPC constant.
X?S:.
X?S:d_SHM_SEG:
X?S:	Sometimes, the SHMLBA manifest needs sys/seg.h, usually for the
X?S:	SNUMSHFT constant.
X?S:.
X?S:d_SHM_IMMU:
X?S:	Sometimes, the SHMLBA manifest needs sys/immu.h, usually for the
X?S:	stob() macro.
X?S:.
X?C:SHMLBA_WANTS_SYSMACROS:
X?C:	This value tells us to include <sys/sysmacros.h> because SHMLBA
X?C:	needs something from there, probably the ctob() macro.
X?C:.
X?C:SHMLBA_WANTS_PARAM:
X?C:	This value tells us to include <sys/param.h> because SHMLBA needs
X?C:	something from there, probably the NBPC constant.
X?C:.
X?C:SHMLBA_WANTS_SEG:
X?C:	This value tells us to include <sys/seg.h> because SHMLBA needs
X?C:	something from there, probably the SNUMSHFT constant.
X?C:.
X?C:SHMLBA_WANTS_IMMU:
X?C:	This value tells us to include <sys/immu.h> because SHMLBA needs
X?C:	something from there, probably the stob() macro.  (tower_600 only?)
X?C:.
X?H:#$d_SHM_MAC	SHMLBA_WANTS_SYSMACROS	/* SHMLBA wants ctob()? */
X?H:#$d_SHM_PRM	SHMLBA_WANTS_PARAM	/* SHMLBA wants NBPC? */
X?H:#$d_SHM_SEG	SHMLBA_WANTS_SEG	/* SHMLBA wants SNUMSHFT? */
X?H:#$d_SHM_IMMU	SHMLBA_WANTS_IMMU	/* SHMLBA wants stob()? */
X?H:.
X?T:flags D_sys_immu D_sys_seg D_sys_sysmacros D_sys_param
X: check for SHMLBA braindamage
Xd_SHM_MAC="$undef"
Xd_SHM_PRM="$undef"
Xd_SHM_SEG="$undef"
Xd_SHM_IMMU="$undef"
Xif $test "$d_shm" = "$define" ; then
X	echo " "
X	$cat >&4 <<EOM
XChecking to see if SHMLBA needs additional headers.
XThe headers I'll be checking are:
X
X    sys/macros.h (for the ctob() macro)
X    sys/param.h  (for NBPC)
X    sys/seg.h    (for SNUMSHFT)
X    sys/immu.h	 (for the stob() macro)
X
XEOM
X	$cat >shm_mac.c <<'EOCP'
X#include <sys/types.h>
X#include <sys/ipc.h>
X#include <sys/shm.h>
X#ifdef I_SYS_IMMU
X#include <sys/immu.h>
X#endif
X#ifdef I_SYS_SYSMACROS
X#include <sys/sysmacros.h>
X#endif
X#ifdef I_SYS_PARAM
X#include <sys/param.h>
X#endif
X#ifdef I_SYS_SEG
X#include <sys/seg.h>
X#endif
X
Xmain() {
X	int foo = SHMLBA ;
X	}
XEOCP
X	flags='xxx'
X	for D_sys_immu in '' '-DI_SYS_IMMU'; do
X	for D_sys_seg in '' '-DI_SYS_SEG'; do
X	for D_sys_sysmacros in '' '-DI_SYS_SYSMACROS'; do
X	for D_sys_param in '' '-DI_SYS_PARAM'; do
X		case "$flags" in
X		'xxx')
X			case "$D_sys_immu$D_sys_param$D_sys_sysmacros$D_sys_seg" in
X			'')
X				echo "Trying it normally..."
X				;;
X			*)
X			echo "Trying $D_sys_immu $D_sys_param $D_sys_sysmacros $D_sys_seg"
X			;;
X			esac
X			if $cc shm_mac.c $ccflags \
X			$D_sys_immu $D_sys_param $D_sys_sysmacros $D_sys_seg \
X			-o shm_mac >/dev/null 2>&1 ; then
X				set X $D_sys_immu $D_sys_param $D_sys_sysmacros $D_sys_seg
X				shift
X				flags="$*"
X				echo "Succeeded with $flags"
X			fi
X			;;
X		esac
X	done
X	done
X	done
X	done
X	case "$flags" in
X	xxx)
X		echo "I don't know how to keep SHMLBA happy.  Good luck!"
X		;;
X	esac
X	case "$flags" in
X	*I_SYS_PARAM*) d_SHM_PRM="$define";;
X	esac
X	case "$flags" in
X	*I_SYS_SYSMACROS*) d_SHM_MAC="$define";;
X	esac
X	case "$flags" in
X	*I_SYS_SEG*) d_SHM_SEG="$define";;
X	esac
X	case "$flags" in
X	*I_SYS_IMMU*) d_SHM_IMMU="$define";;
X	esac
Xfi
X$rm -f shm_mac*
X
END_OF_FILE
  if test 3859 -ne `wc -c <'mcon/U/d_SHM_MAC.U'`; then
    echo shar: \"'mcon/U/d_SHM_MAC.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_SHM_MAC.U'
fi
if test -f 'mcon/U/d_socket.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/d_socket.U'\"
else
  echo shar: Extracting \"'mcon/U/d_socket.U'\" \(3878 characters\)
  sed "s/^X//" >'mcon/U/d_socket.U' <<'END_OF_FILE'
X?RCS: $Id: d_socket.U,v 3.0 1993/08/18 12:07:26 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: d_socket.U,v $
X?RCS: Revision 3.0  1993/08/18  12:07:26  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X: Don't put nm_extract (used internally by Configure)
X?MAKE:d_socket d_oldsock d_sockpair socketlib sockethdr: contains libc \
X	echo n c nm_opt Inlibc Csym
X?MAKE:	-pick add $@ %<
X?S:d_socket:
X?S:	This variable conditionally defines HAS_SOCKET, which indicates
X?S:	that the BSD socket interface is supported.
X?S:.
X?S:d_sockpair:
X?S:	This variable conditionally defines the HAS_SOCKETPAIR symbol, which
X?S:	indicates that the BSD socketpair() is supported.
X?S:.
X?S:d_oldsock:
X?S:	This variable conditionally defines the OLDSOCKET symbol, which
X?S:	indicates that the BSD socket interface is based on 4.1c and not 4.2.
X?S:.
X?S:socketlib:
X?S:	This variable has the names of any libraries needed for socket support.
X?S:.
X?S:sockethdr:
X?S:	This variable has any cpp -I flags needed for socket support.
X?S:.
X?C:HAS_SOCKET (SOCKET):
X?C:	This symbol, if defined, indicates that the BSD socket interface is
X?C:	supported.
X?C:.
X?C:HAS_SOCKETPAIR (SOCKETPAIR):
X?C:	This symbol, if defined, indicates that the BSD socketpair() call is
X?C:	supported.
X?C:.
X?C:USE_OLDSOCKET (OLDSOCKET):
X?C:	This symbol, if defined, indicates that the 4.1c BSD socket interface
X?C:	is supported instead of the 4.2/4.3 BSD socket interface. For instance,
X?C:	there is no setsockopt() call.
X?C:.
X?H:#$d_socket HAS_SOCKET		/**/
X?H:#$d_sockpair HAS_SOCKETPAIR	/**/
X?H:#$d_oldsock USE_OLDSOCKET	/**/
X?H:.
X?T:val
X?LINT:set d_sockpair
Xsocketlib=''
Xsockethdr=''
X: see whether socket exists
Xecho " "
X$echo $n "Hmm... $c" >&4
Xif set socket val -f d_socket; eval $csym; $val; then
X	echo "Looks like you have Berkeley networking support." >&4
X	d_socket="$define"
X?X: now check for advanced features
X	if set setsockopt val -f; eval $csym; $val; then
X		d_oldsock="$undef"
X	else
X		echo "...but it uses the old 4.1c interface, rather than 4.2" >&4
X		d_oldsock="$define"
X	fi
Xelse
X?X: HP-UX, for one, puts all the socket stuff in socklib.o. Note that if we
X?X:	come here on HP-UX, then we must have used nm to get symbols, or we really
X?X: don't have sockets anyway...
X	if $contains socklib libc.list >/dev/null 2>&1; then
X		echo "Looks like you have Berkeley networking support." >&4
X		d_socket="$define"
X		: we will have to assume that it supports the 4.2 BSD interface
X		d_oldsock="$undef"
X	else
X		echo "You don't have Berkeley networking in libc.a..." >&4
X?X: look for an optional networking library
X		if test -f /usr/lib/libnet.a; then
X?X: space between two  '(' needed for ksh
X			( (nm $nm_opt /usr/lib/libnet.a | eval $nm_extract) ||  \
X			ar t /usr/lib/libnet.a) 2>/dev/null >> libc.list
X			if $contains socket libc.list >/dev/null 2>&1; then
X			echo "...but the Wollongong group seems to have hacked it in." >&4
X				socketlib="-lnet"
X				sockethdr="-I/usr/netinclude"
X				d_socket="$define"
X?X: now check for advanced features
X				if $contains setsockopt libc.list >/dev/null 2>&1; then
X					d_oldsock="$undef"
X				else
X					echo "...using the old 4.1c interface, rather than 4.2" >&4
X					d_oldsock="$define"
X				fi
X			else
X				echo "or even in libnet.a, which is peculiar." >&4
X				d_socket="$undef"
X				d_oldsock="$undef"
X			fi
X		else
X			echo "or anywhere else I see." >&4
X			d_socket="$undef"
X			d_oldsock="$undef"
X		fi
X	fi
Xfi
X
X@if HAS_SOCKETPAIR || d_sockpair
X: see if socketpair exists
Xset socketpair d_sockpair
Xeval $inlibc
X
X@end
END_OF_FILE
  if test 3878 -ne `wc -c <'mcon/U/d_socket.U'`; then
    echo shar: \"'mcon/U/d_socket.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/d_socket.U'
fi
if test -f 'mcon/U/ipc.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/ipc.U'\"
else
  echo shar: Extracting \"'mcon/U/ipc.U'\" \(4409 characters\)
  sed "s/^X//" >'mcon/U/ipc.U' <<'END_OF_FILE'
X?RCS: $Id: ipc.U,v 3.0 1993/08/18 12:08:53 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: ipc.U,v $
X?RCS: Revision 3.0  1993/08/18  12:08:53  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:ipc serve_shm serve_msg serve_inet_udp serve_inet_tcp serve_unix_udp \
X	serve_unix_tcp: test Myread Oldconfig d_socket d_msg d_shm d_sem
X?MAKE:	-pick add $@ %<
X?LINT:use d_msg d_sem
X?S:ipc:
X?S:	This variable holds the type of IPC service we'll be using.  Values
X?S:	include "ip", "shm", "msg", "cms" and "os9".  We don't worry about
X?S:	cms or os9 here, because Configure doesn't run in those places--HMS.
X?S:.
X?S:serve_shm:
X?S:	This variable controls the definition of SERVE_SHM, which tells the
X?S:	C program to use USG shared memory for IPC.
X?S:.
X?S:serve_msg:
X?S:	This variable controls the definition of SERVE_MSG, which tells the
X?S:	C program to use USG message queues for IPC.
X?S:.
X?S:serve_inet_udp:
X?S:	This variable controls the definition of SERVE_INET_UDP, which tells
X?S:	the C program to enable InterNet-domain UDP support for IPC.
X?S:.
X?S:serve_inet_tcp:
X?S:	This variable controls the definition of SERVE_INET_TCP, which tells
X?S:	the C program to enable InterNet-domain TCP support for IPC.
X?S:.
X?S:serve_unix_udp:
X?S:	This variable controls the definition of SERVE_UNIX_UDP, which tells
X?S:	the C program to enable Unix-domain UDP support for IPC.
X?S:.
X?S:serve_unix_tcp:
X?S:	This variable controls the definition of SERVE_UNIX_TCP, which tells
X?S:	the C program to enable Unix-domain TCP support for IPC.
X?S:.
X?C:SERVE_SHM:
X?C:	If defined, tells the C program to use USG shared memory for IPC.
X?C:.
X?C:SERVE_MSG:
X?C:	If defined, tells the C program to use USG message queues for IPC.
X?C:.
X?C:SERVE_INET_UDP:
X?C:	If defined, tells the C program to enable InterNet-domain UDP
X?C:	support for IPC.
X?C:.
X?C:SERVE_INET_TCP:
X?C:	If defined, tells the C program to enable InterNet-domain TCP
X?C:	support for IPC.
X?C:.
X?C:SERVE_UNIX_UDP:
X?C:	If defined, tells the C program to enable Unix-domain UDP
X?C:	support for IPC.
X?C:.
X?C:SERVE_UNIX_TCP:
X?C:	If defined, tells the C program to enable Unix-domain TCP
X?C:	support for IPC.
X?C:.
X?H:#$serve_shm	SERVE_SHM	/**/
X?H:#$serve_msg	SERVE_MSG	/**/
X?H:#$serve_inet_udp	SERVE_INET_UDP	/**/
X?H:#$serve_inet_tcp	SERVE_INET_TCP	/**/
X?H:#$serve_unix_udp	SERVE_UNIX_UDP	/**/
X?H:#$serve_unix_tcp	SERVE_UNIX_TCP	/**/
X?H:.
X?X: FIXME -- RAM
X?INIT:serve_shm=''
X?INIT:serve_msg="$undef"
X?INIT:serve_inet_udp=''
X?INIT:serve_inet_tcp=''
X?INIT:serve_unix_udp=''
X?INIT:serve_unix_tcp=''
X: get IPC mechanism
Xecho " "
Xipc=''
Xwhile $test -z "$ipc"
Xdo
X	if $test "$ipc" != "shm" -a "$d_socket" = "$define"; then
X		ipc=''
X		if $test "$serve_inet_udp" = "$undef"; then
X			dflt=n
X		else
X			dflt=y
X		fi
X		rp='Provide InterNet-domain UDP service?'
X		. ./myread
X		dflt=''
X		case "$ans" in
X		n*) serve_inet_udp="$undef";;
X		*)
X			serve_inet_udp="$define"
X			ipc='ip'
X			;;
X		esac
X
X		if $test "$serve_inet_tcp" = "$define"; then
X			dflt=y
X		else
X			dflt=n
X		fi
X		rp='Provide InterNet-domain TCP service?'
X		. ./myread
X		dflt=''
X		case "$ans" in
X		n*) serve_inet_tcp="$undef";;
X		*)
X			serve_inet_tcp="$define"
X			ipc='ip'
X			;;
X		esac
X
X		if $test "$serve_unix_udp" = "$define"; then
X			dflt=y
X		else
X			dflt=n
X		fi
X		rp='Provide Unix-domain UDP service?'
X		. ./myread
X		dflt=''
X		case "$ans" in
X		n*) serve_unix_udp="$undef";;
X		*)
X			serve_unix_udp="$define"
X			ipc='ip'
X			;;
X		esac
X
X		if $test "$serve_unix_tcp" = "$define"; then
X			dflt=y
X		else
X			dflt=n
X		fi
X		rp='Provide Unix-domain TCP service?'
X		. ./myread
X		dflt=''
X		case "$ans" in
X		n*) serve_unix_tcp="$undef";;
X		*)
X			serve_unix_tcp="$define"
X			ipc='ip'
X			;;
X		esac
X	else
X		serve_inet_udp="$undef"
X		serve_inet_tcp="$undef"
X		serve_unix_udp="$undef"
X		serve_unix_tcp="$undef"
X	fi
X	if $test "$ipc" != "ip" -a "$d_shm" = "$define"; then
X		echo "Providing USG shared memory IPC support." >&4
X		serve_shm="$define"
X		ipc='shm'
X	else
X		serve_shm="$undef"
X	fi
X	if $test -z "$ipc"; then
X		echo "You must select an IPC mechanism." >&4
X	fi
Xdone
X
END_OF_FILE
  if test 4409 -ne `wc -c <'mcon/U/ipc.U'`; then
    echo shar: \"'mcon/U/ipc.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/ipc.U'
fi
if test -f 'mcon/U/prototype.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/prototype.U'\"
else
  echo shar: Extracting \"'mcon/U/prototype.U'\" \(3928 characters\)
  sed "s/^X//" >'mcon/U/prototype.U' <<'END_OF_FILE'
X?RCS: $Id: prototype.U,v 3.0 1993/08/18 12:09:36 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: prototype.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:36  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:prototype: Myread Oldconfig cat +cc rm Setvar
X?MAKE:	-pick add $@ %<
X?S:prototype:
X?S:	This variable holds the eventual value of CAN_PROTOTYPE, which
X?S:	indicates the C compiler can handle funciton prototypes.
X?S:.
X?C:CAN_PROTOTYPE ~ %<:
X?C:	If defined, this macro indicates that the C compiler can handle
X?C:	function prototypes.
X?C:.
X?C:DOTS ~ %<:
X?C:	This macro is used to specify the ... in function prototypes which
X?C:	have arbitrary additional arguments.
X?C:.
X?C:NXT_ARG ~ %<:
X?C:	This macro is used to separate arguments in the declared argument list.
X?C:.
X?C:P_FUNC ~ %<:
X?C:	This macro is used to declare "private" (static) functions.
X?C:	It takes three arguments: the function type and name, a parenthesized
X?C:	traditional (comma separated) argument list, and the declared argument
X?C:	list (in which arguments are separated with NXT_ARG, and additional
X?C:	arbitrary arguments are specified with DOTS).  For example:
X?C:
X?C:		P_FUNC(int foo, (bar, baz), int bar NXT_ARG char *baz[])
X?C:.
X?C:P_FUNC_VOID ~ %<:
X?C:	This macro is used to declare "private" (static) functions that have
X?C:	no arguments.  The macro takes one argument: the function type and name.
X?C:	For example:
X?C:
X?C:		P_FUNC_VOID(int subr)
X?C:.
X?C:V_FUNC ~ %<:
X?C:	This macro is used to declare "public" (non-static) functions.
X?C:	It takes three arguments: the function type and name, a parenthesized
X?C:	traditional (comma separated) argument list, and the declared argument
X?C:	list (in which arguments are separated with NXT_ARG, and additional
X?C:	arbitrary arguments are specified with DOTS).  For example:
X?C:
X?C:		V_FUNC(int main, (argc, argv), int argc NXT_ARG char *argv[])
X?C:.
X?C:V_FUNC_VOID ~ %<:
X?C:	This macro is used to declare "public" (non-static) functions that have
X?C:	no arguments.  The macro takes one argument: the function type and name.
X?C:	For example:
X?C:
X?C:		V_FUNC_VOID(int fork)
X?C:.
X?C:_ ~ %< (P):
X?C:	This macro is used to declare function parameters for folks who want
X?C:	to make declarations with prototypes using a different style than
X?C:	the above macros.  Use double parentheses.  For example:
X?C:
X?C:		int main _((int argc, char *argv[]));
X?C:.
X?H:?%<:#$prototype	CAN_PROTOTYPE	/**/
X?H:?%<:#ifdef CAN_PROTOTYPE
X?H:?%<:#define	NXT_ARG ,
X?H:?%<:#define	DOTS , ...
X?H:?%<:#define	V_FUNC(name, arglist, args)name(args)
X?H:?%<:#define	P_FUNC(name, arglist, args)static name(args)
X?H:?%<:#define	V_FUNC_VOID(name)name(VOID)
X?H:?%<:#define	P_FUNC_VOID(name)static name(VOID)
X?H:?%<:#define	_(args) args
X?H:?%<:#else
X?H:?%<:#define	NXT_ARG ;
X?H:?%<:#define	DOTS
X?H:?%<:#define	V_FUNC(name, arglist, args)name arglist args;
X?H:?%<:#define	P_FUNC(name, arglist, args)static name arglist args;
X?H:?%<:#define	V_FUNC_VOID(name)name()
X?H:?%<:#define	P_FUNC_VOID(name)static name()
X?H:?%<:#define	_(args) ()
X?H:?%<:#endif
X?H:.
X?W:%<:NXT_ARGS DOTS V_FUNC P_FUNC V_FUNC_VOID P_FUNC_VOID _
X?LINT:set prototype
X: Cruising for prototypes
Xecho " "
Xecho "Checking out function prototypes..." >&4
X$cat >prototype.c <<'EOCP'
Xmain(int argc, char *argv[]) {
X	exit(0);}
XEOCP
Xif $cc -c prototype.c >prototype.out 2>&1 ; then
X	echo "Your C compiler appears to support function prototypes."
X	val="$define"
Xelse
X	echo "Your C compiler doesn't seem to understand function prototypes."
X	val="$undef"
Xfi
Xset prototype
Xeval $setvar
X$rm -f prototype*
X
END_OF_FILE
  if test 3928 -ne `wc -c <'mcon/U/prototype.U'`; then
    echo shar: \"'mcon/U/prototype.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/prototype.U'
fi
if test -f 'mcon/U/randfunc.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/randfunc.U'\"
else
  echo shar: Extracting \"'mcon/U/randfunc.U'\" \(4249 characters\)
  sed "s/^X//" >'mcon/U/randfunc.U' <<'END_OF_FILE'
X?RCS: $Id: randfunc.U,v 3.0 1993/08/18 12:09:39 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: randfunc.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:39  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X:
X?X:	This is the new unit that should be used when random
X?X:	functions are to be used. It thus makes randbits.U obsolete.
X?X:
X?MAKE:randfunc mrand seedfunc nrandbits: cat +cc rm test Myread Csym
X?MAKE:	-pick add $@ %<
X?S:randfunc:
X?S:	Indicates the name of the random number function to use.
X?S:	Values include drand48, random, and rand. In C programs,
X?S:	the 'nrand' macro is defined to generate uniformly distributed
X?S:	random numbers over the range [0., 1.] (see mrand and nrand).
X?S:.
X?S:mrand:
X?S:	Indicates the macro to be used to generate normalized
X?S:	random numbers.  Uses randfunc, often divided by
X?S:	(double) ((1 << nrandbits) -1) in order to normalize the result.
X?S:	In C programs, the macro 'nrand' is maped on mrand.
X?S:.
X?S:seedfunc:
X?S:	Indicates the random number generating seed function.
X?S:	Values include srand48, srandom, and srand.
X?S:.
X?S:nrandbits:
X?S:	Indicates how many bits are produced by the function used to
X?S:	generate normalized random numbers.
X?S:.
X?C:nrand:
X?C:	This macro is to be used to generate uniformly distributed
X?C:	random numbers over the range [0., 1.].
X?C:.
X?C:seednrand:
X?C:	This symbol defines the macro to be used in seeding the
X?C:	random number generator (see nrand).
X?C:.
X?H:#define nrand()		$mrand		/**/
X?H:#define seednrand(x)	$seedfunc(x)	/**/
X?H:.
X?T:cont val
X: How can we generate normalized random numbers ?
Xecho " "
Xcase "$randfunc" in
X'')
X	if set drand48 val -f; eval $csym; $val; then
X		dflt="drand48"
X		echo "Good, found drand48()." >&4
X	elif set random val -f; eval $csym; $val; then
X		dflt="random"
X		echo "OK, found random()." >&4
X	else
X		dflt="rand"
X		echo "Yick, looks like I have to use rand()." >&4
X	fi
X	echo " "
X	;;
X*)
X	dflt="$randfunc"
X	;;
Xesac
Xcont=true
Xwhile $test "$cont"; do
X	rp="Use which function to generate random numbers?"
X	. ./myread
X?X: Invalidates nrandbits if the answer is not the default so
X?X:	that the value stored in config.sh will not be used when
X?X:	we change our random function.
X	if $test "$ans" = "$dflt"; then
X		: null
X	else
X		nrandbits=''
X	fi
X	randfunc="$ans"
X	if set $ans val -f; eval $csym; $val; then
X		cont=''
X	else
X		dflt=n
X		rp="Function $ans does not exists. Use that name anyway?"
X		. ./myread
X		dflt=rand
X		case "$ans" in
X			[yY]*) cont='';;
X		esac
X	fi
X	case "$cont" in
X	'')
X		case "$randfunc" in
X		drand48)
X			mrand="drand48()"
X			seedfunc="srand48"
X			;;
X		rand*)
X			case "$nrandbits" in
X			'')
Xecho "Checking to see how many bits your $randfunc() function produces..." >&4
X			$cat >try.c <<EOCP
X#include <stdio.h>
Xmain()
X{
X	register int i;
X	register unsigned long tmp;
X	register unsigned long max = 0L;
X	extern long random();
X
X	for (i = 1000; i; i--) {
X		tmp = (unsigned long)$randfunc();
X		if (tmp > max) max = tmp;
X	}
X	for (i = 0; max; i++)
X		max /= 2;
X	printf("%d\n",i);
X}
XEOCP
X			if $cc try.c -o try >/dev/null 2>&1 ; then
X			dflt=`try`
X			else
X			dflt='?'
X			echo "(I can't seem to compile the test program...)"
X			fi
X			;;
X			*)
X				dflt="$nrandbits"
X				;;
X			esac
X			rp="How many bits does your $randfunc() function produce?"
X			. ./myread
X			nrandbits="$ans"
X			$rm -f try.c try
X			mrand="($randfunc() / (double) ((1 << $nrandbits) -1))"
X			seedfunc="srand"
X			;;
X?X:	The following is provided just in case...
X		*)
X			dflt="31"
X			rp="How many bits does your $randfunc() function produce?"
X			. ./myread
X			nrandbits="$ans"
X			seedfunc="s$randfunc"
X			mrand="($randfunc() / (double) ((1 << $nrandbits) -1))"
X			if set $seedfunc val -f; eval $csym; $val; then
X				echo "(Using $seedfunc() to seed random generator)"
X			else
X				echo "(Warning: no $seedfunc() to seed random generator)"
X				seedfunc=rand
X			fi
X			;;
X		esac
X		;;
X	esac
Xdone
X
END_OF_FILE
  if test 4249 -ne `wc -c <'mcon/U/randfunc.U'`; then
    echo shar: \"'mcon/U/randfunc.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/randfunc.U'
fi
if test -f 'mcon/man/Makefile.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/man/Makefile.SH'\"
else
  echo shar: Extracting \"'mcon/man/Makefile.SH'\" \(4082 characters\)
  sed "s/^X//" >'mcon/man/Makefile.SH' <<'END_OF_FILE'
X: Makefile.SH generated from Jmake.tmpl and Jmakefile [jmake 3.0 PL0]
X: $X-Id: Jmake.tmpl,v 2.8.1.2 91/11/18 13:22:54 ram Exp $
X
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
XCURRENT=mcon/man
XDIR=`echo $CURRENT/ | sed -e 's/\.\///g'`
Xecho "Extracting ${DIR}Makefile (with variable substitutions)"
XDATE=`date`
X$spitshell >Makefile <<!GROK!THIS!
X########################################################################
X# Makefile generated from Makefile.SH on $DATE
X
XSHELL = /bin/sh
XJMAKE = jmake
XTOP = ../..
XCURRENT = $CURRENT
XDIR = $DIR
XINSTALL = ../../install
X
X########################################################################
X# Parameters set by Configure -- edit config.sh if changes are needed
X
XCTAGS = ctags
XL = $manext
XMANSRC = $installmansrc
XMAKE = make
XMV = $mv
XRM = $rm -f
X
X########################################################################
X# Automatically generated parameters -- do not edit
X
XMANPAGE =  \$(MPAGES)
X
X########################################################################
X# New suffixes and associated building rules -- edit with care
X
X.SUFFIXES: .SH .$manext
X
X.SH.$manext:
X	/bin/sh \$<
X
X!GROK!THIS!
X$spitshell >>Makefile <<'!NO!SUBS!'
X########################################################################
X# Jmake rules for building libraries, programs, scripts, and data files
X# $X-Id: Jmake.rules,v 2.8.1.4 91/11/18 13:19:07 ram Exp $
X
X########################################################################
X# Start of Jmakefile
X
X# $X-Id: Jmakefile,v 2.9 92/07/14 16:49:04 ram Exp $
X#
X#  Copyright (c) 1991-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic Licence,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic Licence; a copy of which may be found at the root
X#  of the source tree for dist 3.0.
X#
X# $X-Log:	Jmakefile,v $
X# Revision 2.9  92/07/14  16:49:04  ram
X# 3.0 beta baseline.
X#
X
XMPAGES = metaconfig.$(L) metalint.$(L) metaxref.$(L)
X
Xall:: $(MPAGES)
X
Xlocal_realclean::
X	$(RM) $(MPAGES)
X
Xinstall.man::
X	@if test "$(MANSRC)"; then \
X		case '${MFLAGS}' in *[i]*) set +e;; esac; \
X		for file in $(MPAGES); do \
X			(set -x; $(INSTALL) -c -m 444 $$file $(MANSRC)); \
X		done; \
X	else exit 0; fi
X
Xdeinstall.man::
X	@if test "$(MANSRC)"; then \
X		case '${MFLAGS}' in *[i]*) set +e;; esac; \
X		for file in $(MPAGES); do \
X			(set -x; $(RM) $(MANSRC)/$$file); \
X		done; \
X	else exit 0; fi
X
X########################################################################
X# Common rules for all Makefiles -- do not edit
X
Xemptyrule::
X
Xclean: local_clean
Xrealclean: local_realclean
Xclobber: local_clobber
X
Xlocal_clean::
X	$(RM) core *~ *.o
X
Xlocal_realclean:: local_clean
X
Xlocal_clobber:: local_realclean
X	$(RM) Makefile config.sh
X
XMakefile.SH: Jmakefile
X	-@if test -f $(TOP)/.package; then \
X		if test -f Makefile.SH; then \
X			echo "	$(RM) Makefile.SH~; $(MV) Makefile.SH Makefile.SH~"; \
X			$(RM) Makefile.SH~; $(MV) Makefile.SH Makefile.SH~; \
X		fi; \
X		echo "	$(JMAKE) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT)" ; \
X		$(JMAKE) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT) ; \
X	else touch $@; exit 0; fi
X
XMakefile: Makefile.SH
X	/bin/sh Makefile.SH
X
Xtags::
X	$(CTAGS) -w *.[ch]
X	$(CTAGS) -xw *.[ch] > tags
X
Xlocal_clobber::
X	$(RM) tags
X
X########################################################################
X# Empty rules for directories with no sub-directories -- do not edit
X
Xinstall::
X	@echo "install in $(CURRENT) done."
X
Xdeinstall::
X	@echo "deinstall in $(CURRENT) done."
X
Xinstall.man::
X	@echo "install.man in $(CURRENT) done."
X
Xdeinstall.man::
X	@echo "deinstall.man in $(CURRENT) done."
X
XMakefiles::
X
XMakefiles.SH::
X
X!NO!SUBS!
Xchmod 644 Makefile
X$eunicefix Makefile
X
END_OF_FILE
  if test 4082 -ne `wc -c <'mcon/man/Makefile.SH'`; then
    echo shar: \"'mcon/man/Makefile.SH'\" unpacked with wrong size!
  fi
  # end of 'mcon/man/Makefile.SH'
fi
if test -f 'pat/patname.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pat/patname.SH'\"
else
  echo shar: Extracting \"'pat/patname.SH'\" \(4345 characters\)
  sed "s/^X//" >'pat/patname.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting pat/patname (with variable substitutions)"
Xcat >patname <<!GROK!THIS!
X$startperl
X	eval "exec perl -S \$0 \$*"
X		if \$running_under_some_shell;
X
X# $Id: patname.SH,v 3.0 1993/08/18 12:10:46 ram Exp $
X#
X#  Copyright (c) 1991-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic Licence,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic Licence; a copy of which may be found at the root
X#  of the source tree for dist 3.0.
X#
X# $Log: patname.SH,v $
X# Revision 3.0  1993/08/18  12:10:46  ram
X# Baseline for dist 3.0 netwide release.
X#
X
X\$version = '$VERSION';
X\$patchlevel = '$PATCHLEVEL';
X!GROK!THIS!
Xcat >>patname <<'!NO!SUBS!'
X
X$RCSEXT = ',v' unless $RCSEXT;
X$progname = "patname";
X
Xrequire 'getopts.pl';
X&usage unless $#ARGV >= 0;
X&usage() unless &Getopts("ahnmv:V");
X
Xif ($opt_V) {
X	print STDERR "patname $version PL$patchlevel\n";
X	exit 0;
X} elsif ($opt_h) {
X	&usage;
X}
X
X$RCSEXT = ',v' unless $RCSEXT;
Xchop($pwd = `pwd`) unless -f '.package';
Xuntil (-f '.package') {
X	die "No .package file!  Run packinit.\n" unless $pwd;
X	chdir '..' || die "Can't cd ..";
X	$pwd =~ s|(.*)/(.*)|$1|;
X	$prefix = $2 . '/' . $prefix;
X}
Xif ($prefix) {
X	for (@ARGV) {
X		s/^/$prefix/ unless m|^[-/]|;
X	}
X}
X
X# We now are at the top level
X
X&readpackage;
X
Xunless ($opt_v) {
X	print STDERR "Version number must be specified using -v.\n";
X	&usage;
X}
X
Xif ($opt_n) {
X	&newer;				# Look for files newer than patchlevel.h
X} elsif ($opt_a) {
X	open(MANI,"MANIFEST.new") || die "No MANIFEST.new found.\n";
X	@ARGV = ();
X	while (<MANI>) {
X		s|^\./||;
X		next if m|^patchlevel.h|;		# This file is built by hand
X		chop;
X		($_) = split(' ');
X		next if -d;
X		push(@ARGV,$_);
X	}
X	close MANI;
X} elsif ($opt_m) {
X	open(MODS,"bugs/.mods$bnum") || die "No modification found.\n";
X	@ARGV = ();
X	while (<MODS>) {
X		next if m|^patchlevel.h$|;		# This file is built by hand
X		chop;
X		($_) = split(' ');
X		push(@ARGV,$_);
X	}
X	close MODS;
X}
X
X# Now loop over each file specified, doing a 'rcsfreeze'
Xforeach $file (@ARGV) {
X	$files = &rcsargs($file);
X	@files = split(' ', $files);
X	$rlog = `rlog -rlastpat- $files 2>&1`;
X	($revs) = ($rlog =~ /selected revisions: (\d+)/);
X	if (!$revs) {
X		print "$progname: $file has never been checked in--checking in...\n";
X		system 'perl', '-S', 'patcil', '-p', $file;
X		$revs = 2;		# At least null trunk + new fresh revision
X	}
X	# Look whether there is a branch
X	if ($revs == 1) {
X		$rlog = `rlog -r$revbranch $files 2>&1`;
X		($revs) = ($rlog =~ /selected revisions: (\d+)/);
X		$revs++;	# add the base revision
X	}
X	# If working file exists, make sure latest version was checked in
X	if (-f $file) {
X		if ($revs == 1) {
X			$delta = `rcsdiff -r$baserev $files 2>/dev/null`;
X		} else {
X			$delta = `rcsdiff -r$revbranch $files 2>/dev/null`;
X		}
X		if ($delta ne '') {
X			# File changed; check it in.
X			system 'perl', '-S', 'patcil', '-p', $file;
X			if ($revs > 1) {
X				# Have to re-run rlog after a new ci
X				$rlog = `rlog -r$revbranch $files 2>&1`;
X			}
X		}
X	}
X	# Now assign symbolic revision number
X	if ($revs == 1) {
X		system 'rcs', "-N$opt_v:$baserev", @files;
X	} else {
X		($lastrev) = ($rlog =~ /revision $revbranch\.(\d+)/);
X		system 'rcs', "-N$opt_v:$revbranch.$lastrev", @files;
X	}
X}
X
Xsub usage {
X	print STDERR "Usage: $progname [-ahnmV] -v version [filelist]\n";
X	print STDERR "  -a : all the files in MANIFEST.new\n";
X	print STDERR "  -h : print this message and exit\n";
X	print STDERR "  -n : all the files newer than patchlevel.h\n";
X	print STDERR "  -m : all the modified files (which have been patciled)\n";
X	print STDERR "  -v : set version number (mandatory)\n";
X	print STDERR "  -V : print version number and exit\n";
X	exit 1;
X}
X
X!NO!SUBS!
X$grep -v '^;#' ../pl/newer.pl >>patname
X$grep -v '^;#' ../pl/package.pl >>patname
X$grep -v '^;#' ../pl/rcsargs.pl >>patname
Xchmod +x patname
X$eunicefix patname
END_OF_FILE
  if test 4345 -ne `wc -c <'pat/patname.SH'`; then
    echo shar: \"'pat/patname.SH'\" unpacked with wrong size!
  fi
  # end of 'pat/patname.SH'
fi
echo shar: End of archive 14 \(of 28\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Please run PACKNOTES through sh, read REAMDE and then type Configure."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
