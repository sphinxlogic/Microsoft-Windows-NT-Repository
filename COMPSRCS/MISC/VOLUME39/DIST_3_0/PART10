Newsgroups: comp.sources.misc
From: Raphael Manfredi <ram@acri.fr>
Subject: v39i014:  dist-3.0 - Configure script generator and related tools, Part10/28
Message-ID: <1993Aug18.184246.17652@sparky.sterling.com>
X-Md4-Signature: 56d44140ca4857934f18f451ce27d955
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Advanced Computer Research Institute, Lyon, France.
Date: Wed, 18 Aug 1993 18:42:46 GMT
Approved: kent@sparky.sterling.com

Submitted-by: Raphael Manfredi <ram@acri.fr>
Posting-number: Volume 39, Issue 14
Archive-name: dist-3.0/part10
Environment: UNIX, Perl, RCS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  Artistic mcon/U/Oldconfig.U mcon/U/cppfilecom.U
#   mcon/U/myhostname.U mcon/pl/configure.pl mcon/pl/makefile.pl
#   pat/patcol.SH pat/patdiff.SH
# Wrapped by ram@soft208 on Wed Aug 18 14:42:20 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 10 (of 28)."'
if test -f 'Artistic' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Artistic'\"
else
  echo shar: Extracting \"'Artistic'\" \(6203 characters\)
  sed "s/^X//" >'Artistic' <<'END_OF_FILE'
X                      The "Artistic License"
X
X                             Preamble
X
XThe intent of this document is to state the conditions under which a
XPackage may be copied, such that the Copyright Holder maintains some
Xsemblance of artistic control over the development of the Package,
Xwhile giving the users of the package the right to use and distribute
Xthe Package in a more-or-less customary fashion, plus the right to make
Xreasonable modifications.
X
XIt also grants you the rights to reuse parts of a Package in your own
Xprograms without transferring this License to those programs, provided
Xthat you meet some reasonable requirements.
X
XDefinitions:
X
X        "Package" refers to the collection of files distributed by the
X        Copyright Holder, and derivatives of that collection of files
X        created through textual modification.
X
X        "Standard Version" refers to such a Package if it has not been
X        modified, or has been modified in accordance with the wishes
X        of the Copyright Holder as specified below.
X
X        "Copyright Holder" is whoever is named in the copyright or
X        copyrights for the package.
X
X        "You" is you, if you're thinking about copying or distributing
X        this Package.
X
X        "Reasonable copying fee" is whatever you can justify on the
X        basis of media cost, duplication charges, time of people involved,
X        and so on.  (You will not be required to justify it to the
X        Copyright Holder, but only to the computing community at large
X        as a market that must bear the fee.)
X
X        "Freely Available" means that no fee is charged for the item
X        itself, though there may be fees involved in handling the item.
X        It also means that recipients of the item may redistribute it
X        under the same conditions they received it.
X
X1. You may make and give away verbatim copies of the source form of the
XStandard Version of this Package without restriction, provided that you
Xduplicate all of the original copyright notices and associated disclaimers.
X
X2. You may apply bug fixes, portability fixes and other modifications
Xderived from the Public Domain or from the Copyright Holder.  A Package
Xmodified in such a way shall still be considered the Standard Version.
X
X3. You may otherwise modify your copy of this Package in any way, provided
Xthat you insert a prominent notice in each changed file stating how and
Xwhen you changed that file, and provided that you do at least ONE of the
Xfollowing:
X
X    a) place your modifications in the Public Domain or otherwise make them
X    Freely Available, such as by posting said modifications to Usenet or
X    an equivalent medium, or placing the modifications on a major archive
X    site such as uunet.uu.net, or by allowing the Copyright Holder to include
X    your modifications in the Standard Version of the Package.
X
X    b) use the modified Package only within your corporation or organization.
X
X    c) rename any non-standard executables so the names do not conflict
X    with standard executables, which must also be provided, and provide
X    a separate manual page for each non-standard executable that clearly
X    documents how it differs from the Standard Version.
X
X    d) make other distribution arrangements with the Copyright Holder.
X
X4. You may distribute the programs of this Package in object code or
Xexecutable form, provided that you do at least ONE of the following:
X
X    a) distribute a Standard Version of the executables and library files,
X    together with instructions (in the manual page or equivalent) on where
X    to get the Standard Version.
X
X    b) accompany the distribution with the machine-readable source of
X    the Package with your modifications.
X
X    c) give non-standard executables non-standard names, and clearly
X    document the differences in manual pages (or equivalent), together
X    with instructions on where to get the Standard Version.
X
X    d) make other distribution arrangements with the Copyright Holder.
X
X5. You may charge a reasonable copying fee for any distribution of this
XPackage.  You may charge any fee you choose for support of this
XPackage.  You may not charge a fee for this Package itself.  However,
Xyou may distribute this Package in aggregate with other (possibly
Xcommercial) programs as part of a larger (possibly commercial) software
Xdistribution provided that you do not advertise this Package as a
Xproduct of your own.
X
X6. The scripts and library files supplied as input to or produced as
Xoutput from the programs of this Package do not automatically fall
Xunder the copyright of this Package, but belong to whomever generated
Xthem, and may be sold commercially, and may be aggregated with this
XPackage.  If such scripts or library files are aggregated with this
XPackage via the so-called "undump" or "unexec" methods of producing a
Xbinary executable image, then distribution of such an image shall
Xneither be construed as a distribution of this Package nor shall it
Xfall under the restrictions of Paragraphs 3 and 4, provided that you do
Xnot represent such an executable image as a Standard Version of this
XPackage.
X
X7. You may reuse parts of this Package in your own programs, provided that
Xyou explicitly state where you got it from, in the source code (and, left
Xto your courtesy, in the documentation), duplicating all the associated
Xcopyright notices and disclaimers. Besides your changes, if any, must be
Xclearly marked as such. Parts reused that way will no longer fall under this
Xlicense if, and only if, the name of your program(s) have no immediate
Xconnection with the name of the Package itself or its associated programs.
XYou may then apply whatever restrictions you wish on the reused parts or
Xchoose to place them in the Public Domain--this will apply only within the
Xcontext of your package.
X
X8. The name of the Copyright Holder may not be used to endorse or promote
Xproducts derived from this software without specific prior written permission.
X
X9. THIS PACKAGE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR
XIMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
XWARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X
X                                The End
END_OF_FILE
  if test 6203 -ne `wc -c <'Artistic'`; then
    echo shar: \"'Artistic'\" unpacked with wrong size!
  fi
  # end of 'Artistic'
fi
if test -f 'mcon/U/Oldconfig.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/Oldconfig.U'\"
else
  echo shar: Extracting \"'mcon/U/Oldconfig.U'\" \(5959 characters\)
  sed "s/^X//" >'mcon/U/Oldconfig.U' <<'END_OF_FILE'
X?RCS: $Id: Oldconfig.U,v 3.0 1993/08/18 12:05:12 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: Oldconfig.U,v $
X?RCS: Revision 3.0  1993/08/18  12:05:12  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?X: 
X?X: This unit tries to remember what we did last time we ran Configure, mostly
X?X: for the sake of setting defaults.
X?X: 
X?MAKE:Oldconfig hint myuname: Instruct Myread uname sed test cat rm n c \
X	contains Loc
X?MAKE:	-pick wipe $@ %<
X?S:myuname:
X?S: The output of 'uname -a' if available, otherwise the hostname.
X?S:.
X?S:hint:
X?S:	Gives the type of hints used for previous answers. May be one of "default",
X?S:	"recommended" or "previous".
X?S:.
X?T:tmp file oldmyuname tans _
X?LINT:change n c
X: Try to determine whether config.sh was made on this system
Xcase "$config_sh" in
X'')
X?X: indentation wrong on purpose--RAM
X?X: Leave a white space between first two '(' for ksh. The sub-shell is needed
X?X: on some machines to avoid the error message when uname is not found; e.g.
X?X: old SUN-OS 3.2 would not execute hostname in (uname -a || hostname). Sigh!
Xmyuname=`( ($uname -a) 2>/dev/null || hostname) 2>&1`
Xdflt=n
Xif test -f ../config.sh; then
X?X: The value from config.sh will superseed the one we've just computed
X?X: ... but not if we choose to ignore config.sh, so eval oldmyuname here.
X	oldmyuname=''
X	if $contains myuname= ../config.sh >/dev/null 2>&1; then
X		eval "old`grep myuname= ../config.sh`"
X	fi
X	if test "X$myuname" = "X$oldmyuname"; then
X		dflt=y
X	fi
Xfi
X
X@if {test -d ../hints}
X: Get old answers from old config file if Configure was run on the
X: same system, otherwise use the hints.
Xhint=default
Xcd ..
Xif test -f config.sh; then
X	echo " "
X	rp="I see a config.sh file.  Shall I use it to set the defaults?"
X	. UU/myread
X	case "$ans" in
X	n*|N*) echo "OK, I'll ignore it."; mv config.sh config.sh.old;;
X	*)  echo "Fetching default answers from your old config.sh file..." >&4
X		tmp="$n"
X		tans="$c"
X		. ./config.sh
X		cp config.sh UU
X		n="$tmp"
X		c="$tans"
X		hint=previous
X		;;
X	esac
Xfi
Xif test ! -f config.sh; then
X	$cat <<EOM
X
XFirst time through, eh?  I have some defaults handy for the following systems:
X
XEOM
X	cd hints; ls -C *.sh | $sed 's/\.sh/   /g' >&4
X	dflt=''
X	: Half the following guesses are probably wrong... If you have better
X	: tests or hints, please send them to <MAINTLOC>
X	: The metaconfig authors would also appreciate a copy...
X	$test -f /irix && dflt="$dflt sgi"
X	$test -f /xenix && dflt="$dflt sco_xenix"
X	$test -f /dynix && dflt="$dflt dynix"
X	$test -f /dnix && dflt="$dflt dnix"
X	$test -f /bin/mips && /bin/mips && dflt="$dflt mips"
X	$test -d /NextApps && test -f /usr/adm/software_version && dflt="$dflt next"
X	$test -d /usr/include/minix && dflt="$dflt minix"
X	if $test -f $uname; then
X		set `$uname -a | tr '[A-Z]' '[a-z]'`
X
X		$test -f $5.sh && dflt="$dflt $5"
X
X		case "$5" in
X		fps*) dflt="$dflt fps";;
X		mips*)
X			case "$4" in
X			umips) dflt="$dflt umips";;
X			*) dflt="$dflt mips";;
X			esac;;
X		[23]100) dflt="$dflt mips";;
X		next*) dflt="$dflt next" ;;
X		news*) dflt="$dflt news" ;;
X		esac
X
X		case "$1" in
X		aix) dflt="$dflt aix_rs" ;;
X		sunos) case "$3" in
X			3.4) dflt="$dflt sunos_3_4" ;;
X			3.5) dflt="$dflt sunos_3_5" ;;
X			4.0.1) dflt="$dflt sunos_4_0_1" ;;
X			4.0.2) dflt="$dflt sunos_4_0_2" ;;
X			esac
X			;;
X		dnix) dflt="$dflt dnix" ;;
X		dgux) dflt="$dflt dgux" ;;
X		genix) dflt="$dflt genix" ;;
X		hp*ux) dflt="$dflt hpux" ;;
X		next) dflt="$dflt next" ;;
X		irix) dflt="$dflt sgi" ;;
X		ultrix) case "$3" in
X			3*) dflt="$dflt ultrix_3" ;;
X			4*) dflt="$dflt ultrix_4" ;;
X			esac
X			;;
X		uts) dflt="$dflt uts" ;;
X		$2) if test -f /etc/systemid; then
X				set `echo $3 | sed 's/\./ /'` $4
X				if $test -f sco_$1_$2_$3.sh; then
X					dflt="$dflt sco_$1_$2_$3"
X				elif $test -f sco_$1_$2.sh; then
X					dflt="$dflt sco_$1_$2"
X				elif $test -f sco_$1.sh; then
X					dflt="$dflt sco_$1"
X				fi
X			fi
X			;;
X		esac
X	else
X?X: Try to identify sony's NEWS-OS (BSD unix)
X		if test -f /vmunix -a -f news_os.sh; then
X			(what /vmunix | tr '[A-Z]' '[a-z]') > ../UU/kernel.what 2>&1
X			if $contains news-os ../UU/kernel.what >/dev/null 2>&1; then
X				dflt="$dflt news_os"
X			fi
X			$rm -f ../UU/kernel.what
X		fi
X	fi
X	set X `echo $dflt | tr ' ' '\012' | sort | uniq`
X	shift
X	dflt=''
X	for file in $*; do
X		if $test -f "$file.sh"; then
X			dflt="$dflt $file"
X		fi
X	done
X	set X $dflt
X	shift
X	dflt=${1+"$@"}
X	case "$dflt" in
X	'') dflt=none;;
X	esac
X	$cat <<EOM
X
XYou may give one or more space-separated answers, or "none" if appropriate.
XIf your OS version has no hints, DO NOT give a wrong version -- say "none".
X
XEOM
X	rp="Which of these apply, if any?"
X	. ../UU/myread
X	for file in $ans; do
X		if $test -f $file.sh; then
X			. ./$file.sh
X			$cat $file.sh >> ../UU/config.sh
X		fi
X	done
X	hint=recommended
X	cd ..
Xfi
Xcd UU
X@else
X: Get old answers, if there is a config file out there
Xhint=default
Xif test -f ../config.sh; then
X	echo " "
X	rp="I see a config.sh file.  Did Configure make it on THIS system?"
X	. ./myread
X	case "$ans" in
X	n*|N*) echo "OK, I'll ignore it.";;
X	*)  echo "Fetching default answers from your old config.sh file..." >&4
X		tmp="$n"
X		tans="$c"
X		. ../config.sh
X		cp ../config.sh .
X		n="$tmp"
X		c="$tans"
X		hint=previous
X		;;
X	esac
Xfi
X@end
X?X: remember, indentation is wrong--RAM
X;;
X*)
X	echo " "
X	echo "Fetching default answers from $config_sh..." >&4
X	tmp="$n"
X	tans="$c"
X	cd ..
X?X: preserve symbolic links, if any
X	cp $config_sh config.sh 2>/dev/null
X	. ./config.sh
X	cd UU
X	cp ../config.sh .
X	n="$tmp"
X	c="$tans"
X	hint=previous
X	;;
Xesac
X
X: Restore computed paths
Xfor file in $loclist $trylist; do
X	eval $file="\$_$file"
Xdone
X
END_OF_FILE
  if test 5959 -ne `wc -c <'mcon/U/Oldconfig.U'`; then
    echo shar: \"'mcon/U/Oldconfig.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/Oldconfig.U'
fi
if test -f 'mcon/U/cppfilecom.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/cppfilecom.U'\"
else
  echo shar: Extracting \"'mcon/U/cppfilecom.U'\" \(6437 characters\)
  sed "s/^X//" >'mcon/U/cppfilecom.U' <<'END_OF_FILE'
X?RCS: $Id: cppfilecom.U,v 3.0 1993/08/18 12:05:37 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: Orginal Author: Graham Stoney <greyham@research.canon.oz.au>
X?RCS:
X?RCS: $Log: cppfilecom.U,v $
X?RCS: Revision 3.0  1993/08/18  12:05:37  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:cppfilecom cppstdinflags d_cppignhdrs d_cppcanstdin: \
X	contains package test Myread Oldconfig Loc Setvar cpp cc cat rm
X?MAKE:	-pick add $@ %<
X?S:cppfilecom:
X?S:	This variable contains the first part of the string which will invoke
X?S:	the C preprocessor a file and produce to standard output, preserving
X?S:	comments. Typical value of "cc -E -C" or "/lib/cpp -C".
X?S:.
X?S:cppstdinflags:
X?S:	This variable contains any flags necessary to get cppfilecom to read
X?S:	from the standard input.
X?S:.
X?S:d_cppignhdrs:
X?S:	This symbol conditionally defines CPP_IGN_HDRS if CPP_FILE_COM ignores
X?S:	*.h files.
X?S:.
X?S:d_cppcanstdin:
X?S:	This symbol conditionally defines CPP_CAN_STDIN if CPP_FILE_COM can
X?S:	read standard input directly.
X?S:.
X?C:CPP_FILE_COM (CPPFILECOM):
X?C:	This symbol contains the first part of the string which will invoke
X?C:	the C preprocessor a file and produce to standard output, preserving
X?C:	comments. Typical value of "cc -E -C" or "/lib/cpp -C".
X?C:.
X?C:CPP_STDIN_FLAGS (CPPSTDINFLAGS):
X?C:	This variable contains any flags necessary to get CPP_FILE_COM to
X?C:	read from the standard input.
X?C:.
X?C:CPP_IGN_HDRS (CPPIGNHDRS):
X?C:	This symbol is defined if CPP_FILE_COM ignores *.h files.
X?C:.
X?C:CPP_CAN_STDIN (CPPCANSTDIN):
X?C:	This symbol is defined if CPP_FILE_COM can read standard input
X?C:	directly.
X?C:.
X?H:#define CPP_FILE_COM "$cppfilecom"
X?H:#define CPP_STDIN_FLAGS "$cppstdinflags"
X?H:#$d_cppignhdrs CPP_IGN_HDRS		/* does CPP ignore .h files? */
X?H:#$d_cppcanstdin CPP_CAN_STDIN 	/* can CPP read stdin directly? */
X?H:.
X?T:cont
X?LINT:set d_cppcanstdin d_cppignhdrs
X: see how we invoke the C preprocessor
X$cat <<EOM
X
X$package needs to be able to preprocess its input files in a mode which
Xpreserves comments, which is often not the default behaviour.  It should run
Xthe C preprocessor you will use when compiling your own source code, which
Xshould be ISO/ANSI C compliant if you want $package to handle the latest
Xstandard C.  I will try to guess, but I might guess wrongly because it is not
Xnecessarily the same preprocessor used to build $package.
X
XEOM
X$cat <<'EOT' >testcpp.c
X#define ABC abc
X#define XYZ xyz
XABC.XYZ
X/* comment */
XEOT
X:
Xif $test "X$cppfilecom" != "X" && \
X	$cppfilecom testcpp.c </dev/null >testcpp.out 2>/dev/null && \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
X	$contains comment testcpp.out >/dev/null 2>&1
Xthen
X	echo "You used to use $cppfilecom so we'll use that again."
Xelif echo 'Maybe "'$cc' -E -C" will work...' && \
X	$cc -E -C testcpp.c </dev/null >testcpp.out 2>/dev/null && \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
X	$contains comment testcpp.out >/dev/null 2>&1
Xthen
X	echo "It works!"
X	cppfilecom="$cc -E -C"
Xelif echo 'Nope...maybe "'"$cc"' -P -C" will work...' && \
X	$cc -P -C testcpp.c </dev/null >testcpp.out 2>/dev/null && \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
X	$contains comment testcpp.out >/dev/null 2>&1
Xthen
X	echo "Yup, that does."
X	cppfilecom="$cc -P -C"
Xelif echo 'No such luck, maybe "'"$cpp"' -C" will work...' && \
X	$cpp -C testcpp.c </dev/null >testcpp.out 2>/dev/null && \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
X	$contains comment testcpp.out >/dev/null 2>&1
Xthen
X	echo "Yup, it does."
X	cppfilecom="$cpp -C"
Xelse
X	cppfilecom=''
X	$cat <<'EOM'
XI can't find a C preprocessor that will preserve comments. Please name one.
XEOM
Xfi
X:
Xdflt="$cppfilecom"
Xcont=true
Xwhile $test "$cont" ; do
X	echo " "
X	rp="How should $package run your preprocessor preserving comments?"
X	. ./myread
X	cppfilecom="$ans"
X	$cppfilecom testcpp.c >testcpp.out 2>&1
X	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
X		$contains comment testcpp.out >/dev/null 2>&1
X	then
X		echo "OK, that will do."
X		cont=''
X	else
X		echo "Sorry, I can't get that to work."
X	fi
Xdone
X
X@if CPP_IGN_HDRS || d_cppignhdrs
X: Now see if it ignores header files.
Xcp testcpp.c testcpp.h
X$cppfilecom testcpp.h >testcpp.out 2>&1
Xif $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
X	$contains comment testcpp.out >/dev/null 2>&1
Xthen
X	echo "Terrific; it processes .h files passed on the command line too."
X	val="$undef"
Xelse
X	echo "It ignores .h files on the command line; pity."
X	val="$define"
Xfi
Xset d_cppignhdrs
Xeval $setvar
X
X@end
X@if CPP_STDIN_FLAGS || CPP_CAN_STDIN || cppstdinflags || d_cppcanstdin
X: Now see how to send stdin to it.
Xecho " "
Xcp testcpp.c testcpp.h
X$cppfilecom <testcpp.h >testcpp.out 2>&1
Xif $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
X	$contains comment testcpp.out >/dev/null 2>&1
Xthen
X	echo "Great; and it will read stdin if passed no arguments."
X	val="$define"
X	cppstdinflags=''
Xelse
X	$cppfilecom - <testcpp.h >testcpp.out 2>&1
X	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
X		$contains comment testcpp.out >/dev/null 2>&1
X	then
X		echo "Great; and it can read stdin by passing it '-'."
X		val="$define"
X		cppstdinflags='-'
X	else
X		$cat <<FOO
XUnfortunately, I can't find an easy way to get that preprocessor to read from
Xstandard input. Do you know any flags I can pass it to get it to do so?
XIf that preprocessor can't read directly form standard input, answer 'none'.
X
XFOO
X	val='dunno'
X	while $test "$val" = "dunno"; do
X		rp='Flags to get preprocessor to read stdin?'
X		dflt='none'
X		. ./myread
X		if $test $ans = 'none'; then
X			echo "Oh well, if $package wants it done, it will do it for itself."
X			val="$undef"
X		else
X			$cppfilecom $ans <testcpp.h >testcpp.out 2>&1
X			if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
X				$contains comment testcpp.out >/dev/null 2>&1
X			then
X				echo "Good; that works fine."
X				val="$define"
X				cppstdinflags="$ans"
X			else
X				echo "Sorry, I couldn't get that to work."
X			fi
X		fi
X	done
X	fi
Xfi
Xset d_cppcanstdin
Xeval $setvar
X
X@end
X: cleanup cpp test files anyway
X$rm -f testcpp.*
X
END_OF_FILE
  if test 6437 -ne `wc -c <'mcon/U/cppfilecom.U'`; then
    echo shar: \"'mcon/U/cppfilecom.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/cppfilecom.U'
fi
if test -f 'mcon/U/myhostname.U' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/U/myhostname.U'\"
else
  echo shar: Extracting \"'mcon/U/myhostname.U'\" \(6047 characters\)
  sed "s/^X//" >'mcon/U/myhostname.U' <<'END_OF_FILE'
X?RCS: $Id: myhostname.U,v 3.0 1993/08/18 12:09:18 ram Exp $
X?RCS:
X?RCS: Copyright (c) 1991-1993, Raphael Manfredi
X?RCS: 
X?RCS: You may redistribute only under the terms of the Artistic Licence,
X?RCS: as specified in the README file that comes with the distribution.
X?RCS: You may reuse parts of this distribution only within the terms of
X?RCS: that same Artistic Licence; a copy of which may be found at the root
X?RCS: of the source tree for dist 3.0.
X?RCS:
X?RCS: $Log: myhostname.U,v $
X?RCS: Revision 3.0  1993/08/18  12:09:18  ram
X?RCS: Baseline for dist 3.0 netwide release.
X?RCS:
X?MAKE:myhostname phostname mydomain: contains sed test Myread Oldconfig \
X	Guess awk sort uniq +usrinc rm hostcat
X?MAKE:	-pick add $@ %<
X?S:myhostname (hostname):
X?S:	This variable contains the eventual value of the MYHOSTNAME symbol,
X?S:	which is the name of the host the program is going to run on.
X?S:	The domain is not kept with hostname, but must be gotten from mydomain.
X?S:	The dot comes with mydomain, and need not be supplied by the program.
X?S:.
X?S:mydomain:
X?S:	This variable contains the eventual value of the MYDOMAIN symbol,
X?S:	which is the domain of the host the program is going to run on.
X?S:	The domain must be appended to myhostname to form a complete host name.
X?S:	The dot comes with mydomain, and need not be supplied by the program.
X?S:.
X?S:phostname:
X?S:	This variable contains the eventual value of the PHOSTNAME symbol,
X?S:	which is a command that can be fed to popen() to get the host name.
X?S:	The program should probably not presume that the domain is or isn't
X?S:	there already.
X?S:.
X?C:MYHOSTNAME (HOSTNAME):
X?C:	This symbol contains name of the host the program is going to run on.
X?C:	The domain is not kept with hostname, but must be gotten from MYDOMAIN.
X?C:	The dot comes with MYDOMAIN, and need not be supplied by the program.
X?C:	If gethostname() or uname() exist, MYHOSTNAME may be ignored. If MYDOMAIN
X?C:	is not used, MYHOSTNAME will hold the name derived from PHOSTNAME.
X?C:.
X?C:MYDOMAIN:
X?C:	This symbol contains the domain of the host the program is going to
X?C:	run on.  The domain must be appended to HOSTNAME to form a complete
X?C:	host name.  The dot comes with MYDOMAIN, and need not be supplied by
X?C:	the program.  If the host name is derived from PHOSTNAME, the domain
X?C:	may or may not already be there, and the program should check.
X?C:.
X?H:#define MYHOSTNAME "$myhostname"		/**/
X?H:#define MYDOMAIN "$mydomain"		/**/
X?H:.
X?T:cont i tans
X: now get the host name
Xecho " "
Xecho "Figuring out host name..." >&4
Xcase "$myhostname" in
X'') cont=true
X	echo 'Maybe "hostname" will work...'
X	if tans=`sh -c hostname 2>&1` ; then
X		myhostname=$tans
X		phostname=hostname
X		cont=''
X	fi
X	;;
X*) cont='';;
Xesac
Xif $test "$cont"; then
X	if xenix; then
X		echo 'Oh, dear.  Maybe "/etc/systemid" is the key...'
X		if tans=`cat /etc/systemid 2>&1` ; then
X			myhostname=$tans
X			phostname='cat /etc/systemid'
X			echo "Whadyaknow.  Xenix always was a bit strange..."
X			cont=''
X		fi
X	elif $test -r /etc/systemid; then
X		echo "(What is a non-Xenix system doing with /etc/systemid?)"
X	fi
Xfi
Xif $test "$cont"; then
X	echo 'No, maybe "uuname -l" will work...'
X	if tans=`sh -c 'uuname -l' 2>&1` ; then
X		myhostname=$tans
X		phostname='uuname -l'
X	else
X		echo 'Strange.  Maybe "uname -n" will work...'
X		if tans=`sh -c 'uname -n' 2>&1` ; then
X			myhostname=$tans
X			phostname='uname -n'
X		else
X			echo 'Oh well, maybe I can mine it out of whoami.h...'
X			if tans=`sh -c $contains' sysname $usrinc/whoami.h' 2>&1` ; then
X				myhostname=`echo "$tans" | $sed 's/^.*"\(.*\)"/\1/'`
X				phostname="sed -n -e '"'/sysname/s/^.*\"\\(.*\\)\"/\1/{'"' -e p -e q -e '}' <$usrinc/whoami.h"
X			else
X				case "$myhostname" in
X				'') echo "Does this machine have an identity crisis or something?"
X					phostname='';;
X				*)
X					echo "Well, you said $myhostname before..."
X					phostname='echo $myhostname';;
X				esac
X			fi
X		fi
X	fi
Xfi
X: you do not want to know about this
Xset $myhostname
Xmyhostname=$1
X
X: translate upper to lower if necessary
Xcase "$myhostname" in
X*[A-Z]*)
X	myhostname=`echo $myhostname | tr '[A-Z]' '[a-z]'`
X	echo "(Normalizing case in your host name)"
X	;;
Xesac
X
X: verify guess
Xif $test "$myhostname" ; then
X	dflt=y
X	rp='Your host name appears to be "'$myhostname'".'" Right?"
X	. ./myread
X	case "$ans" in
X	y*) ;;
X	*) myhostname='';;
X	esac
Xfi
X
X: bad guess or no guess
Xwhile $test "X$myhostname" = X ; do
X	dflt=''
X	rp="Please type the (one word) name of your host:"
X	. ./myread
X	myhostname="$ans"
Xdone
X
X?X: Do not ask for domain name if this is not used later on. In that
X?X: case, the hostname may keep its domain name, but it doesn't matter.
X@if MYDOMAIN || mydomain
Xcase "$myhostname" in
X*.*)
X	dflt=`expr "X$myhostname" : "X[^.]*\(\..*\)"`
X	myhostname=`expr "X$myhostname" : "X\([^.]*\)\."`
X	echo "(Trimming domain name from host name--host name is now $myhostname)"
X	;;
X*) case "$mydomain" in
X	'')
X?X:
X?X: There is currently no way to say we do not want hostcat if mydomain is not
X?X: used. One way to achieve that would be to put that code in a mydomain.U
X?X: unit. However, we want to stick the sanity checks right after the domain
X?X: name computation, or if none is done, right after the hostname computation.
X?X:
X		$hostcat >hosts
X		dflt=.`$awk "/[0-9].*$myhostname/ {for(i=2; i<=NF;i++) print \\\$i}" \
X			hosts | $sort | $uniq | \
X			$sed -n -e "s/$myhostname\.\([a-zA-Z_.]\)/\1/p"`
X		case "$dflt" in
X		.) echo "(You do not have fully-qualified names in /etc/hosts)"
X			dflt='.uucp';;
X		esac
X		$rm -f hosts
X		;;
X	*) dflt="$mydomain";;
X	esac;;
Xesac
Xecho " "
Xrp="What is your domain name?"
X. ./myread
Xtans="$ans"
Xcase "$ans" in
X'') ;;
X.*) ;;
X*) tans=".$tans";;
Xesac
Xmydomain="$tans"
X
X@end
X: a little sanity check here
Xcase "$phostname" in
X'') ;;
X*)
X	case `$phostname` in
X	$myhostname$mydomain|$myhostname) ;;
X	*)
X		case "$phostname" in
X		sed*)
X			echo "(That doesn't agree with your whoami.h file, by the way.)"
X			;;
X		*)
X			echo "(That doesn't agree with your $phostname command, by the way.)"
X			;;
X		esac
X	;;
X	esac
X	;;
Xesac
X
END_OF_FILE
  if test 6047 -ne `wc -c <'mcon/U/myhostname.U'`; then
    echo shar: \"'mcon/U/myhostname.U'\" unpacked with wrong size!
  fi
  # end of 'mcon/U/myhostname.U'
fi
if test -f 'mcon/pl/configure.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/pl/configure.pl'\"
else
  echo shar: Extracting \"'mcon/pl/configure.pl'\" \(6024 characters\)
  sed "s/^X//" >'mcon/pl/configure.pl' <<'END_OF_FILE'
X;# $Id: configure.pl,v 3.0 1993/08/18 12:10:20 ram Exp $
X;#
X;#  Copyright (c) 1991-1993, Raphael Manfredi
X;#  
X;#  You may redistribute only under the terms of the Artistic Licence,
X;#  as specified in the README file that comes with the distribution.
X;#  You may reuse parts of this distribution only within the terms of
X;#  that same Artistic Licence; a copy of which may be found at the root
X;#  of the source tree for dist 3.0.
X;#
X;# $Log: configure.pl,v $
X;# Revision 3.0  1993/08/18  12:10:20  ram
X;# Baseline for dist 3.0 netwide release.
X;#
X;# 
X;# This file is the heart of metaconfig. We generate a Configure script using
X;# the informations gathered in the @cmdwanted array. A unit is expected to have
X;# its path written in the %Unit array (indexing is done with the unit's name
X;# without the .U extension).
X;#
X;# The units are run through a built-in interpreter before being written to
X;# the Configure script.
X;#
X# Create the Configure script
Xsub create_configure {
X	print "Creating Configure...\n" unless $opt_s;
X	open(CONFIGURE,">Configure") || die "Can't create Configure.\n";
X	open(CONF_H,">config_h.SH") || die "Can't create config_h.SH.\n";
X
X	chdir('.MT') || die "Can't cd to .MT\n";
X	for (@cmdwanted) {
X		&process_command($_);		# Run the makefile command
X	}
X	chdir($WD) || die "Can't cd back to $WD\n";
X	close CONFIGURE;
X	print CONF_H "#endif\n";		# Close the opened #ifdef (see Config_h.U)
X	print CONF_H "!GROK!THIS!\n";
X	close CONF_H;
X	`chmod +x Configure`;
X}
X
X# Process a Makefile 'pick' command
Xsub process_command {
X	local($cmd, $target, $unit_name) = split(' ', $_[0]);
X	local($name) = $unit_name . '.U';	# Restore missing .U
X	local($file) = $name;				# Where unit is located
X	unless ($file =~ m|^\./|) {			# Unit produced earlier by metaconfig
X		$file = $Unit{$unit_name};		# Fetch unit from U directory
X	}
X	if (defined $Obsolete{$name}) {		# Signal use of an obsolete unit
X		warn "\tObsolete unit $name is used:\n";
X		local(@msg) = split(/\n/, $Obsolete{$name});
X		foreach $msg (@msg) {
X			warn "\t    $msg\n";
X		}
X	}
X	die "Can't open $file.\n" unless open(UNIT, $file);
X	print "\t$cmd $file\n" if $opt_v;
X	&init_interp;						# Initializes the interpreter
X
X	# The 'add' command adds the unit to Configure.
X	if ($cmd eq 'add') {
X		while (<UNIT>) {
X			print CONFIGURE unless &skipped || !&interpret($_);
X		}
X	}
X	
X	# The 'weed' command adds the unit to Configure, but
X	# makes some tests for the lines starting with '?' or '%'.
X	# These lines are kept only if the symbol is wanted.
X	elsif ($cmd eq 'weed') {
X		while (<UNIT>) {
X			if (/^\?(\w+):/) {
X				s/^\?\w+:// if $symwanted{$1};
X			}
X			if (/^%(\w+):/) {
X				s/^%\w+:// if $condwanted{$1};
X			}
X			print CONFIGURE unless &skipped || !&interpret($_);
X		}
X	}
X	
X	# The 'wipe' command adds the unit to Configure, but
X	# also substitues some hardwired macros.
X	elsif ($cmd eq 'wipe') {
X		while (<UNIT>) {
X			s/<PACKAGENAME>/$package/g;
X			s/<MAINTLOC>/$maintloc/g;
X			s/<VERSION>/$version/g;			# This is metaconfig's version
X			s/<PATCHLEVEL>/$patchlevel/g;	# And patchlevel information
X			s/<DATE>/$date/g;
X			s/<BASEREV>/$baserev/g;
X			print CONFIGURE unless &skipped || !&interpret($_);
X		}
X	}
X	
X	# The 'add.Null' command adds empty initializations
X	# to Configure for all the shell variable used.
X	elsif ($cmd eq 'add.Null') {
X		for (sort @Master) {
X			if (/^\?(\w+):/) {
X				s/^\?\w+:// if $symwanted{$1};
X			}
X			print CONFIGURE unless &skipped;
X		}
X		for (sort @Cond) {
X			print CONFIGURE "$_=''\n"
X				unless $symwanted{$_} || $hasdefault{$_};
X		}
X		while (<UNIT>) {
X			print CONFIGURE unless &skipped || !&interpret($_);
X		}
X		print CONFIGURE "CONFIG=''\n\n";
X	}
X	
X	# The 'add.Config_sh' command fills in the production of
X	# the config.sh script within Configure. Only the used
X	# variable are added, the conditional ones are skipped.
X	elsif ($cmd eq 'add.Config_sh') {
X		while (<UNIT>) {
X			print CONFIGURE unless &skipped;
X		}
X		for (sort @Master) {
X			if (/^\?(\w+):/) {
X				# Can't use $shmaster, because config.sh must
X				# also contain some internal defaults used by
X				# Configure (e.g. nm_opt, libc, etc...).
X				s/^\?\w+:// if $symwanted{$1};
X			}
X			s/^(\w+)=''/$1='\$$1'/;
X			print CONFIGURE unless &skipped;
X		}
X	}
X	
X	# The 'close.Config_sh' command adds the final EOT line at
X	# the end of the here-document construct which produces the
X	# config.sh file within Configure.
X	elsif ($cmd eq 'close.Config_sh') {
X		print CONFIGURE "EOT\n\n";	# Ends up file
X	}
X
X	# The 'c_h_weed' command produces the config_h.SH file.
X	# Only the necessary lines are kept. If no conditional line is
X	# ever printed, then the file is useless and will be removed.
X	elsif ($cmd eq 'c_h_weed') {
X		$printed = 0;
X		while (<UNIT>) {
X			if (/^\?(\w+):/) {
X				s/^\?\w+:// if $cmaster{$1} || $symwanted{$1};
X			}
X			unless (&skipped || !&interpret($_)) {
X				if (/^$/) {
X					print CONF_H "\n" if $printed;
X					$printed = 0;
X				} else {
X					print CONF_H;
X					++$printed;
X				}
X			}
X		}
X	}
X	
X	# The 'prepend' command will add the content of the target to
X	# the current file (held in $file, the one which UNIT referes to),
X	# if the file is not empty.
X	elsif ($cmd eq 'prepend') {
X		if (! -w $file) {
X			warn("Cannot write into $file.\n");
X		} elsif (!eof(UNIT)) {
X			open(PREPEND, ">.prepend") ||
X				die "Can't create .MT/.prepend.\n";
X			open(TARGET, $Unit{$target}) ||
X				die "Can't open $Unit{$target}.\n";
X			while (<TARGET>) {
X				print PREPEND unless &skipped;
X			}
X			print PREPEND <UNIT>;
X			close PREPEND;
X			close TARGET;
X			rename('.prepend', $file) ||
X				die "Can't rename .prepend into $file.\n";
X		}
X	}
X
X	# Command not found
X	else {
X		die "Unrecognized command from Makefile: $cmd\n";
X	}
X	do check_state();		# Make sure there are no pending statements
X	close UNIT;
X}
X
X# Skip lines starting with ? or %, including all the following continuation
X# lines, if any. Return 0 if the line was not to be skipped, 1 otherwise.
Xsub skipped {
X	return 0 unless /^\?|^%/;
X	&complete_line(UNIT) if /\\\s*$/;	# Swallow continuation lines
X	1;
X}
X
END_OF_FILE
  if test 6024 -ne `wc -c <'mcon/pl/configure.pl'`; then
    echo shar: \"'mcon/pl/configure.pl'\" unpacked with wrong size!
  fi
  # end of 'mcon/pl/configure.pl'
fi
if test -f 'mcon/pl/makefile.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mcon/pl/makefile.pl'\"
else
  echo shar: Extracting \"'mcon/pl/makefile.pl'\" \(6204 characters\)
  sed "s/^X//" >'mcon/pl/makefile.pl' <<'END_OF_FILE'
X;# $Id: makefile.pl,v 3.0 1993/08/18 12:10:26 ram Exp $
X;#
X;#  Copyright (c) 1991-1993, Raphael Manfredi
X;#  
X;#  You may redistribute only under the terms of the Artistic Licence,
X;#  as specified in the README file that comes with the distribution.
X;#  You may reuse parts of this distribution only within the terms of
X;#  that same Artistic Licence; a copy of which may be found at the root
X;#  of the source tree for dist 3.0.
X;#
X;# $Log: makefile.pl,v $
X;# Revision 3.0  1993/08/18  12:10:26  ram
X;# Baseline for dist 3.0 netwide release.
X;#
X;# 
X;# Given a list of wanted symbols in the Wanted file, produce a Makefile which
X;# will compute the transitive closure of dependencies for us and give the
X;# correct layout order in the Configure script. Because some conditional
X;# symbols could indeed be truly wanted symbols, we build the makefile in two
X;# passes. The first one will give us the complete list of units to be loaded,
X;# while the second will determine the correct order.
X;#
X;# The external $saved_dependencies records the original dependencies we got
X;# from the units' ?MAKE: lines while $dependencies is tampered with.
X;#
X;# Note that when the -w option is supplied, the sources are not parsed.
X;# However, the config.h.SH file would be empty, because its building
X;# relies on values in cmaster and shmaster arrays. It is okay for values
X;# in shmaster, because they are true wanted symbols. The cmaster keys
X;# have also been written, but with a leading '>' (because they are
X;# not true targets for Makefile). We thus extract all these keys and
X;# set the cmaster array accordingly.
X;#
X;# Obsolete symbols, if any found, are also part of the Wanted file, written on
X;# a line starting with a '!', eventually followed by a '>' if the obsolete
X;# symbol is a C one.
X;#
X;# These three data structures record wanted things like commands or symbols.
X;#  %symwanted{'sym'} is true when the symbol is wanted (transitive closure)
X;#  %condwanted{'sym'} when the default value of a symbol is requested
X;#  $wanted records the set of wanted shell symbols (as opposed to C ones)
X;#
X# Build the private makefile we use to compute the transitive closure of the
X# previously determined dependencies.
Xsub build_makefile {
X	print "Computing optimal dependency graph...\n" unless $opt_s;
X	chdir('.MT') || die "Can't chdir to .MT\n";
X	local($wanted);			# Wanted shell symbols
X	&build_private;			# Build a first makefile from dependencies
X	&compute_loadable;		# Compute loadable units
X	&update_makefile;		# Update makefile using feedback from first pass
X	chdir($WD) || die "Can't chdir back to $WD\n";
X	# Free memory by removing useless data structures
X	undef $dependencies;
X	undef $saved_dependencies;
X}
X
X# First pass: build a private makefile from the extracted dependency, changing
X# conditional units to truly wanted ones if the symbol is used, removing the
X# dependency otherwise. The original dependencies are saved.
Xsub build_private {
X	print "    Building private make file...\n" unless $opt_s;
X	open(WANTED,"../Wanted") || die "Can't reopen Wanted.\n";
X	$wanted = ' ' x 2000;	# Pre-extend string
X	$wanted = '';
X	while (<WANTED>) {
X		chop;
X		next if /^!/;		# Skip obsolete symbols
X		if (s/^>//) {
X			$cmaster{$_}++;
X		} else {
X			$wanted .= "$_ ";
X		}
X	}
X	close WANTED;
X
X	# The wanted symbols are sorted so that d_* (checking for C library symbol)
X	# come first and i_* (checking for includes) comes at the end. Grouping the
X	# d_* symbols together has good chances of improving the locality of the
X	# other questions and i_* symbols must come last since some depend on h_*
X	# values which prevent incompatible headers inclusions.
X	$wanted = join(' ', sort symbols split(' ', $wanted));
X	
X	# Now generate the first makefile, which will be used to determine which
X	# symbols we really need, so that conditional dependencies may be solved.
X	open(MAKEFILE,">Makefile") || die "Can't create .MT/Makefile.\n";
X	print MAKEFILE "SHELL = /bin/sh\n";
X	print MAKEFILE "W = $wanted\n";
X	$saved_dependencies = $dependencies;
X	$* = 1;
X	foreach $sym (@Cond) {
X		if ($symwanted{$sym}) {
X			$dependencies =~ s/\+($sym\s)/$1/g;
X		} else {
X			$dependencies =~ s/\+$sym(\s)/$1/g;
X		}
X	}
X	$* = 0;
X	print MAKEFILE $dependencies;
X	close MAKEFILE;
X}
X
X# Ordering for symbols. Give higher priority to d_* ones and lower to i_* ones.
Xsub symbols {
X	if ($a =~ /^d_/) {
X		return -1 unless $b =~ /^d_/;
X	} elsif ($b =~ /^d_/) {
X		return 1;
X	} elsif ($a =~ /^i_/) {
X		return 1 unless $b =~ /^i_/;
X	} elsif ($b =~ /^i_/) {
X		return -1;
X	}
X	$a cmp $b;
X}
X
X# Run the makefile produced in the first pass to find the whole set of units we
X# have to load, filling in the %symwanted and %condwanted structures.
Xsub compute_loadable {
X	print "    Determining loadable units...\n" unless $opt_s;
X	open(MAKE, "make -n |") || die "Can't run make";
X	while (<MAKE>) {
X		s|^\s+||;				# Some make print tabs before command
X		if (/^pick/) {
X			print "\t$_" if $opt_v;
X			($pick,$cmd,$symbol,$unit) = split(' ');
X			$symwanted{$symbol}++;
X			$symwanted{$unit}++;
X		} elsif (/^cond/) {
X			print "\t$_" if $opt_v;
X			($pick,@symbol) = split(' ');
X			for (@symbol) {
X				$condwanted{$_}++;	# Default value is requested
X			}
X		}
X	}
X	close MAKE;
X}
X
X# Now that we know all the desirable symbols, we have to rebuild
X# another makefile, in order to have the units in a more optimal
X# way.
X# Actually, if we have both ?MAKE:a:+b and ?MAKE:d:b and 'd' is
X# wanted; then 'b' will be loaded. However, 'b' is a conditional
X# dependency for 'a', and it would be better if 'b' were loaded
X# before 'a' is, though this is not necessary.
X# It is hard to know that 'b' will be loaded *before* the first make.
X
X# Back to the original dependencies, make loadable units truly wanted ones and
X# remove optional ones.
Xsub update_makefile {
X	print "    Updating make file...\n" unless $opt_s;
X	open(MAKEFILE,">Makefile") || die "Can't create .MT/Makefile.\n";
X	print MAKEFILE "SHELL = /bin/sh\n";
X	print MAKEFILE "W = $wanted\n";
X	$* = 1;
X	foreach $sym (@Cond) {
X		if ($symwanted{$sym}) {
X			$saved_dependencies =~ s/\+($sym\s)/$1/g;
X		} else {
X			$saved_dependencies =~ s/\+$sym(\s)/$1/g;
X		}
X	}
X	$* = 0;
X	print MAKEFILE $saved_dependencies;
X	close MAKEFILE;
X}
X
END_OF_FILE
  if test 6204 -ne `wc -c <'mcon/pl/makefile.pl'`; then
    echo shar: \"'mcon/pl/makefile.pl'\" unpacked with wrong size!
  fi
  # end of 'mcon/pl/makefile.pl'
fi
if test -f 'pat/patcol.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pat/patcol.SH'\"
else
  echo shar: Extracting \"'pat/patcol.SH'\" \(5868 characters\)
  sed "s/^X//" >'pat/patcol.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting pat/patcol (with variable substitutions)"
Xcat >patcol <<!GROK!THIS!
X$startperl
X	eval "exec perl -S \$0 \$*"
X		if \$running_under_some_shell;
X
X# $Id: patcol.SH,v 3.0 1993/08/18 12:10:42 ram Exp $
X#
X#  Copyright (c) 1991-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic Licence,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic Licence; a copy of which may be found at the root
X#  of the source tree for dist 3.0.
X#
X# $Log: patcol.SH,v $
X# Revision 3.0  1993/08/18  12:10:42  ram
X# Baseline for dist 3.0 netwide release.
X#
X
X\$version = '$VERSION';
X\$patchlevel = '$PATCHLEVEL';
X!GROK!THIS!
Xcat >>patcol <<'!NO!SUBS!'
X
X$RCSEXT = ',v' unless $RCSEXT;
X$progname = "patcol";
X
Xrequire 'getopts.pl';
X&usage unless $#ARGV >= 0;
X&usage unless &Getopts("acd:f:hnmsCRV");
X
Xif ($opt_V) {
X	print STDERR "$progname $version PL$patchlevel\n";
X	exit 0;
X} elsif ($opt_h) {
X	&usage;
X}
X
X$RCSEXT = ',v' unless $RCSEXT;
X$NEWMANI = 'MANIFEST.new' unless $NEWMANI = $opt_f;
X
Xchop($pwd = `pwd`) unless -f '.package';
Xuntil (-f '.package') {
X	die "No .package file!  Run packinit.\n" unless $pwd;
X	chdir '..' || die "Can't cd ..";
X	$pwd =~ s|(.*)/(.*)|$1|;
X	$prefix = $2 . '/' . $prefix;
X}
Xif ($prefix) {
X	for (@ARGV) {
X		s/^/$prefix/ unless m|^[-/]|;
X	}
X}
X
X# We now are at the top level
X
X&readpackage;
Xundef $opt_C unless -f $copyright;
X&copyright'init($copyright) if $opt_C;
X&makedir($opt_d) if $opt_d;
X
Xundef $opt_c unless $opt_d;		# Disable -c if not -d
Xundef $opt_R unless $opt_d;		# Disable -R if not -d
Xpush(@sw, '-q') if $opt_s;		# Let RCS work quietly
X
Xif ($opt_n) {
X	&newer;				# Look for files newer than patchlevel.h
X} elsif ($opt_a) {
X	open(MANI, $NEWMANI) || die "No $NEWMANI found.\n";
X	@ARGV = ();
X	while (<MANI>) {
X		s|^\./||;
X		next if m|^patchlevel.h| && !$opt_d;	# This file is built by hand
X		chop;
X		($_) = split(' ');
X		next if -d;
X		push(@ARGV,$_);
X	}
X	close MANI;
X} elsif ($opt_m) {
X	open(MODS,"bugs/.mods$bnum") || die "No modification found.\n";
X	@ARGV = ();
X	while (<MODS>) {
X		next if m|^patchlevel.h$|;		# This file is built by hand
X		chop;
X		($_) = split(' ');
X		next if -d;
X		push(@ARGV,$_);
X	}
X	close MODS;
X}
X
X# Now loop over each file specified, doing a 'co -l'
Xforeach $file (@ARGV) {
X	if ($opt_c && -f $file) {
X		&copy_file($file, $opt_d);
X		next;
X	}
X	if (! -f $file || $opt_d) {
X		# Continue only if file does not exist or option -d was used.
X		$files = &rcsargs($file);
X		@files = split(' ', $files);
X		$rlog = `rlog -rlastpat- $files 2>&1`;
X		($revs) = ($rlog =~ /selected revisions: (\d+)/);
X		if (!$revs) {
X			if ($opt_d) {
X				&copy_file($file, $opt_d);
X			} else {
X				print STDERR "$progname: $file has never been checked in\n";
X			}
X		} else {
X			# Look whether there is a branch
X			if ($revs == 1) {
X				$rlog = `rlog -r$revbranch $files 2>&1`;
X				($revs) = ($rlog =~ /selected revisions: (\d+)/);
X				$revs++;	# add the base revision (trunk)
X			}
X			if ($revs == 1) {
X				&col($baserev);
X			} else {
X				&col($revbranch);
X			}
X		}
X			
X	}
X}
X
X# Run co -l on @files, unlock file if it fails and retry.
X# If '-d' option was used, we check out in the specified
X# directory, after having made all the necessary directories
X# in the path name (which should be relative to the top).
Xsub col {
X	local($rev) = shift;	# Revision to be checked out.
X	if (! $opt_d) {
X		if (system 'co',  "-l$rev", @sw, @files) {
X			print "Unlocking and trying again...\n" unless $opt_s;
X			system 'rcs', '-u', @sw, @files;
X			system 'co', "-l$rev", @sw, @files unless $?;
X		}
X	} else {
X		local($name) = $files[0];	# First element is file name
X		$_ = $name;
X		s|(.*)/.*|\1| && &makedir("$opt_d/$_");
X		if ($opt_C) {
X			&copyright'expand("co -p @sw -r$rev $files[1]", "$opt_d/$name");
X		} else {
X			system "co -p -r$rev @sw $files[1] > $opt_d/$name";
X		}
X		system 'perl', '-pi', '-e', 's|Lock[e]r:.*\$|\$|;', "$opt_d/$name"
X			if $opt_R;
X		# If RCS file has x bits set, add them on new file
X		-x $files[1] && chmod(0755, "$opt_d/$name");
X	}
X}
X
X# Copy file into directory, eventually performing copyright expansion...
Xsub copy_file {
X	local($file, $dir) = @_;
X	local($base) = $file =~ m|^(.*)/.*|;
X	&makedir("$dir/$base");
X	if ($opt_C) {
X		&copyright'expand("cat $file", "$dir/$file");
X	} else {
X		system 'cp', "$file", "$dir/$file";
X	}
X	system 'perl', '-pi', '-e', 's|Lock[e]r:.*\$|\$|;', "$dir/$file" if $opt_R;
X	-x $file && chmod(0755, "$dir/$file");
X	print "$progname: $file has been copied\n" unless $opt_s;
X}
X
Xsub usage {
X	print STDERR <<'EOM';
XUsage: patcol [-achnmsCRV] [-d directory] [-f mani] [filelist]
X  -a : all the files in MANIFEST.new (see also -f)
X  -c : copy files if checked-out copy exists (only when -d)
X  -d : check out (or copy) in the specified directory
X  -f : use supplied file instead of MANIFEST.new
X  -h : print this message and exit
X  -n : all the files newer than patchlevel.h
X  -m : all the modified files (which have been patciled)
X  -s : silent mode
X  -C : perform copyright expansion on checked out (or copied) file
X  -R : strip out RCS $Locker marker from checked-out file (only when -d)
X  -V : print version number and exit
XEOM
X	exit 1;
X}
X
X!NO!SUBS!
X$grep -v '^;#' ../pl/newer.pl >>patcol
X$grep -v '^;#' ../pl/package.pl >>patcol
X$grep -v '^;#' ../pl/rcsargs.pl >>patcol
X$grep -v '^;#' ../pl/copyright.pl >>patcol
X$grep -v '^;#' ../pl/makedir.pl >>patcol
Xchmod +x patcol
X$eunicefix patcol
END_OF_FILE
  if test 5868 -ne `wc -c <'pat/patcol.SH'`; then
    echo shar: \"'pat/patcol.SH'\" unpacked with wrong size!
  fi
  # end of 'pat/patcol.SH'
fi
if test -f 'pat/patdiff.SH' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pat/patdiff.SH'\"
else
  echo shar: Extracting \"'pat/patdiff.SH'\" \(5903 characters\)
  sed "s/^X//" >'pat/patdiff.SH' <<'END_OF_FILE'
Xcase $CONFIG in
X'')
X	if test -f config.sh; then TOP=.;
X	elif test -f ../config.sh; then TOP=..;
X	elif test -f ../../config.sh; then TOP=../..;
X	elif test -f ../../../config.sh; then TOP=../../..;
X	elif test -f ../../../../config.sh; then TOP=../../../..;
X	else
X		(echo "Can't find config.sh."; exit 1)
X	fi
X	. $TOP/config.sh
X	;;
Xesac
Xcase "$0" in
X*/*) cd `expr X$0 : 'X\(.*\)/'` ;;
Xesac
Xecho "Extracting pat/patdiff (with variable substitutions)"
Xcat >patdiff <<!GROK!THIS!
X$startperl
X	eval "exec perl -S \$0 \$*"
X		if \$running_under_some_shell;
X
X# $Id: patdiff.SH,v 3.0 1993/08/18 12:10:43 ram Exp $
X#
X#  Copyright (c) 1991-1993, Raphael Manfredi
X#  
X#  You may redistribute only under the terms of the Artistic Licence,
X#  as specified in the README file that comes with the distribution.
X#  You may reuse parts of this distribution only within the terms of
X#  that same Artistic Licence; a copy of which may be found at the root
X#  of the source tree for dist 3.0.
X#
X# Original Author: Larry Wall <lwall@netlabs.com>
X#
X# $Log: patdiff.SH,v $
X# Revision 3.0  1993/08/18  12:10:43  ram
X# Baseline for dist 3.0 netwide release.
X#
X
X\$version = '$VERSION';
X\$patchlevel = '$PATCHLEVEL';
X!GROK!THIS!
Xcat >>patdiff <<'!NO!SUBS!'
X
X$RCSEXT = ',v' unless $RCSEXT;
X$TOPDIR = '';			# We are at top-level directory
X
Xrequire 'getopts.pl';
X&usage unless $#ARGV >= 0;
X&usage unless &Getopts("ahnV");
X
Xif ($opt_V) {
X	print STDERR "patdiff $version PL$patchlevel\n";
X	exit 0;
X} elsif ($opt_h) {
X	&usage;
X}
X
X$RCSEXT = ',v' unless $RCSEXT;
X&readpackage;
X&copyright'init($copyright) if -f $copyright;
X
Xsystem 'mkdir', 'bugs' unless -d 'bugs';
X
Xif (-f 'patchlevel.h') {
X	open(PL,"patchlevel.h") || die "Can't open patchlevel.h\n";
X	while (<PL>) {
X		$bnum = $1 if /^#define\s+PATCHLEVEL\s+(\d+)/;
X	}
X	die "Malformed patchlevel.h file.\n" if $bnum eq '';
X	++$bnum;
X} else {
X	$bnum=1;
X}
X
Xif ($opt_a) {
X	open(MANI,"MANIFEST.new") || die "No MANIFEST.new found.\n";
X	@ARGV = ();
X	while (<MANI>) {
X		chop;
X		($_) = split(' ');
X		next if -d;
X		push(@ARGV,$_);
X	}
X	close MANI;
X}
X
Xforeach $file (@ARGV) {
X	next if ($file =~ /^patchlevel.h$/);		# Skip patchlevel.h
X	if (! -f $file) {
X		print "$file not found.\n";
X		next;
X	}
X	$files = &rcsargs($file);
X	@files = split(' ',$files);
X	$new='';
X	$revs=0;
X	$rlog = `rlog -rlastpat- $files 2>&1`;
X	($lastpat) = ($rlog =~ /lastpat: ([\d.]+)/);
X	($revs) = ($rlog =~ /selected revisions: (\d+)/);
X	if (!$revs) {
X		print "No cil has been done on $file.\n" ;;
X	} elsif ($revs == 1) {
X		($base) = ($rlog =~ /.*\nrevision\s+(\S+)/);
X		($a,$b,$c,$d) = split(/\./,$base);
X		if ($d ne '') {
X			if (!$opt_n) {
X		print "No changes in $file since last patch.  (Did you cil it?)\n";
X				next;		# Skip file with no changes
X			} else {
X				$new='foo';
X			}
X		} else {
X			$revs=0;
X			$rlog = `rlog -r$revbranch- $files 2>&1`;
X			($revs) = ($rlog =~ /selected revisions: (\d+)/);
X			if (!$revs) {
X		print "No changes in $file since base version.  (Did you cil it?)\n";
X				next;		# Skip file with no changes
X			} else {
X				($new) = ($rlog =~ /\nrevision\s*(\d+\.\d+\.\d+\.\d+)/);
X			}
X		}
X	} else {
X		($new) = ($rlog =~ /\nrevision\s*(\d+\.\d+\.\d+\.\d+)/);
X	}
X	if ($new ne '') {
X		($fname = $file) =~ s|.*/||;
X		$fname = substr($fname, 0, 11);		# For filsystems with short names
X		open(PATCH,">>bugs/$fname.$bnum") || die "Can't make patch";
X		print PATCH "\nIndex: $file\n";
X		open(CO,"co -p -rlastpat $files 2>/dev/null |");
X		while (<CO>) {
X			if (/\$Header/ || /\$Id/) {
X				print PATCH "Prereq: $lastpat\n";
X				last;
X			}
X		}
X		close CO;
X		if (!$opt_n) {
X			if ($mydiff eq '') {
X				open(DIFF,"rcsdiff -c -rlastpat -r$new $files |") ||
X				die "Can't run rcsdiff";
X				while (<DIFF>) {
X					if ($. == 1) {s|\*\*\* \S+	|*** $file.old	|;}
X					if ($. == 2) {s|--- \S+	|--- $file	|;}
X					s|Lock[e]r:.*\$|\$|;	# Use [e] to make it safe on itself
X					print PATCH;
X				}
X				close DIFF;
X				system 'rcs', "-Nlastpat:$new", @files;
X			} else {
X				&copyright'expand("co -p -rlastpat $file", "/tmp/pdo$$");
X				&copyright'expand("co -p -r$new $file", "/tmp/pdn$$");
X				open(DIFF, "$mydiff /tmp/pdo$$ /tmp/pdn$$ |") ||
X				die "Can't run $mydiff";
X				while (<DIFF>) {			# Contextual or unified diff
X					if ($. == 1) {
X						s|\*\*\* \S+	|*** $file.old	| ||
X						s|--- \S+	|--- $file.old	|;
X					}
X					if ($. == 2) {
X						s|--- \S+	|--- $file	| ||
X						s|\+\+\+ \S+	|+++ $file	|;
X					}
X					s|Lock[e]r:.*\$|\$|;	# Remove locker mark
X					print PATCH;
X				}
X				close DIFF;
X				system 'rcs', "-Nlastpat:$new", @files;
X				unlink "/tmp/pdn$$", "/tmp/pdo$$";
X			}
X		} else {
X			if ($mydiff eq '') {
X				open(DIFF,"rcsdiff -c -rlastpat $files |") ||
X				die "Can't run rcsdiff";
X				while (<DIFF>) {
X					if ($. == 1) {s|\*\*\* \S+	|*** $file.old	|;}
X					if ($. == 2) {s|--- \S+	|--- $file	|;}
X					s|Lock[e]r:.*\$|\$|;	# Remove locker mark
X					print PATCH;
X				}
X				close DIFF;
X			} else {
X				system "co -p -rlastpat $files >/tmp/pdo$$";
X				system "cp $file /tmp/pdn$$";
X				open(DIFF, "$mydiff /tmp/pdo$$ /tmp/pdn$$ |") ||
X				die "Can't run $mydiff";
X				while (<DIFF>) {
X					# Contextual or unified diff
X					if ($. == 1) {
X						s|\*\*\* \S+	|*** $file.old	|;
X						s|--- \S+	|--- $file.old	|;
X					}
X					if ($. == 2) {
X						s|--- \S+	|--- $file	|;
X						s|\+\+\+ \S+	|+++ $file	|;
X					}
X					s|Lock[e]r:.*\$|\$|;	# Remove locker mark
X					print PATCH;
X				}
X				close DIFF;
X				unlink "/tmp/pdn$$", "/tmp/pdo$$";
X			}
X		}
X	}
X}
X
Xsub usage {
X	print STDERR "Usage: patdiff [-ahnV] [filelist]\n";
X	print STDERR "  -a : all the files in MANIFEST.new\n";
X	print STDERR "  -h : print this message and exit\n";
X	print STDERR "  -n : non update mode\n";
X	print STDERR "  -V : print version number and exit\n";
X	exit 1;
X}
X
X!NO!SUBS!
X$grep -v '^;#' ../pl/package.pl >>patdiff
X$grep -v '^;#' ../pl/rcsargs.pl >>patdiff
X$grep -v '^;#' ../pl/copyright.pl >>patdiff
Xchmod +x patdiff
X$eunicefix patdiff
END_OF_FILE
  if test 5903 -ne `wc -c <'pat/patdiff.SH'`; then
    echo shar: \"'pat/patdiff.SH'\" unpacked with wrong size!
  fi
  # end of 'pat/patdiff.SH'
fi
echo shar: End of archive 10 \(of 28\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 28 archives.
    echo "Please run PACKNOTES through sh, read REAMDE and then type Configure."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0

exit 0 # Just in case...
