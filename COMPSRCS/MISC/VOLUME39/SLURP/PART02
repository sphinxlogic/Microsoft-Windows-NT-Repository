Newsgroups: comp.sources.misc
From: steveh@orbital.demon.co.uk (Stephen Hebditch)
Subject: v39i038:  slurp - A passive NNTP transfer client, v1.08, Part02/03
Message-ID: <1993Aug22.013227.28491@sparky.sterling.com>
X-Md4-Signature: 5f17fc321783aa4745c83a557afbd1eb
Sender: kent@sparky.sterling.com (Kent Landfield)
Organization: Sterling Software
Date: Sun, 22 Aug 1993 01:32:27 GMT
Approved: kent@sparky.sterling.com

Submitted-by: steveh@orbital.demon.co.uk (Stephen Hebditch)
Posting-number: Volume 39, Issue 38
Archive-name: slurp/part02
Environment: ANSI-C, UNIX
Supersedes: slurp: Volume 36, Issue 13-14

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  HISTORY conf.h fakesyslog.c history.c misc.c nntp.h
#   slurp.1 slurp.h sockets.c space.c
# Wrapped by kent@sparky on Sat Aug 21 20:28:15 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 3)."'
if test -f 'HISTORY' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'HISTORY'\"
else
  echo shar: Extracting \"'HISTORY'\" \(6069 characters\)
  sed "s/^X//" >'HISTORY' <<'END_OF_FILE'
XSLURP HISTORY
X-------------
X
XV1.08
X
X    Unlink backup time file before renaming or an error occurs with the
X    rename under SVR3.
X
X
XV1.07 - 23 June 1993
X
X    Added support for a user-defined time file for use on machines with
X    short filenames which were previously having the time backup
X    trashed and couldn't support sub-lists.
X
X    If a history database type (DBZ, DBM, NDBM) is not defined then
X    don't do any history lookups. This is useful for people using slurp
X    on a machine where news is not running - perhaps piping batches to
X    uux for sending on to another machine.
X
X    Fixed problem where if slurp was interrupted before the NEWNEWS
X    section had completed, an invalid time would be written to the
X    slurp.<hostname> file.
X
X    Duplicate socket file descriptor and then carry out a separate
X    fdopen for read and write on each descriptor. This fixes some stdio
X    memory problems that were caused by fdopening read and write
X    streams on the same descriptor.
X
X    Rewrote get_ids function, removing some potential problems with its
X    previous implementation.
X
X    Rewrote read_sys function (again!).
X
X    In process_id when in debug mode print after a message ID if ID
X    discarded due to hitting maximum number of articles or was already
X    present in the tree.
X
X    Removed inclusion of <unistd.h> in time.c and sockets.c - if it is
X    needed then it will be included in slurp.h.
X
X    Replaced bzero and bcopy with ANSI memset and memcpy functions
X    throughout, plus a few other bits of tidying up to make the Keep C
X    Source Tidy Campaign happy.
X
X
XV1.06 - 22 April 1993
X
X    Added signal handler to slurp.c to trap SIGHUP, SIGINT, SIGQUIT and
X    SIGTERM. If they occur then the signal is reported to syslog, any
X    currently open batch is submitted to the news system and the
X    message IDs of any unretrieved articles are dumped to the
X    slurp.<hostname> file.
X
X    Added NOBUFFOUT option. If defined, will turn off stdio buffering
X    for the output stream to the server. This is necessary for ISC, SCO
X    and some other SVR3 implementations which will otherwise give a
X    memory fault when the socket is written to.
X
X    Added UNISTD option. If undefined then slurp won't include
X    <unistd.h> which isn't present on some versions of UNIX.
X
X    If an ERR_ACCESS (code 502) result code is reported by the server
X    when retrieving an article, then it will be treated as a missing
X    article.
X
X    Correctly defined server_time in slurp.h - was long instead of
X    time_t.
X
X
XV1.05 - 1 March 1993
X
X    Completely cleaned up space.c. Added proper support for space
X    checking in SVR4.
X
X    Modified read_sys so that it is possible to have lines in the
X    slurp.sys file which are longer than BUFSIZ.
X
X    Check unretrieved message IDs in the slurp.<hostname> file start
X    and end with chevrons.
X
X    Moved sublist in the command line arguments to being specified
X    after the hostname with a slash separating them, to make things
X    more consistent.
X
X    A few more minor tidy-ups, in particular portability has been
X    improved in a few places.
X
X
XV1.04 - 14 February 1993
X
X    Malloc message id separately from mnode structure as the previous
X    method seemed to cause problems on some architectures.
X
X    Now handles article lines of >= 511 bytes without overwriting
X    memory.
X
X    Support for simple authorisation protocol.
X
X    Support for INN 'MODE READER' command.
X
X    read_sys rewritten to allow command line flags to be specified for
X    servers, support having more than one set of newsgroups to be
X    retrieved from the same server, and provide the username and
X    password for the simple authorisation protocol.
X
X    New choice of piping articles to rnews (possibly in one batch only)
X    or writing article batches to the incoming news / rnews spool
X    directory. This will provide a speed-up for users of INN.
X
X    Replaced slurp.tim file with slurp.<hostname> files, solving
X    locking problems and providing support for the enhancement below.
X
X    If an error occurs during the article fetching stage, then dump the
X    message ids of articles not yet retrieved to slurp.<hostname>.
X    These can then be picked up in the next session, without having to
X    restart the NEWNEWS back at the previous time.
X
X    No requirement for slurp.<hostname> to exist as slurp.tim used to
X    have to be if you wanted a time written out.
X
X    Re-arranged the command line options.
X
X
XV1.03 - 19 December 1992
X
X    Added extra compilation configuration option for machines that
X    don't have strerror().
X
X    If a temporary file was opened for reading a long article into
X    which wouldn't fit in memory, then it was flushed at the end of
X    read_article. Unfortunately, the test wasn't done correctly so if a
X    long article was once read in, it would keep flushing the now
X    invalid file descriptor on future calls. Fixed by removing this
X    altogether as the subsequent rewind would do the job anyway.
X
X    Open syslog *before* we start doing things that might want to write
X    to it... Connected, articles retrieved and speed messages logged
X    as LOG_INFO instead of the previously wrong LOG_NOTICE.
X
X    When mallocing space for the article id tree, only malloc enough
X    room for the article id and left/right node pointers, not the whole
X    structure, saving oodles of memory.
X
X    Corrected the test for the maximum size of a NEWNEWS request line.
X
X    Various minor tidy-ups.
X
X    Added manual page and made various improvements to the
X    documentation.
X
X
XV1.02 - 7 December 1992
X
X    Corrected openlog calls so correct 4.2/4.3 version of syslog is
X    used.
X
X
XV1.01 - 6 December 1992
X
X    Fixed some problems with null-dereferencing of nn_distributions.
X    New slurp.tim not written if maximum number of messages that can
X    be transferred is hit.
X
X    When debugging switched on, print line being sent to server before
X    it is sent rather than after.
X
X    Added documentation on return codes.
X
X
XV1.00 - 2 December 1992
X
X    Initial release.
X
X---- END OF DOCUMENTATION
END_OF_FILE
  if test 6069 -ne `wc -c <'HISTORY'`; then
    echo shar: \"'HISTORY'\" unpacked with wrong size!
  fi
  # end of 'HISTORY'
fi
if test -f 'conf.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'conf.h'\"
else
  echo shar: Extracting \"'conf.h'\" \(6012 characters\)
  sed "s/^X//" >'conf.h' <<'END_OF_FILE'
X/*
X * conf.h - compilation options for slurp
X *
X * Copyright (C) 1992/93 Stephen Hebditch. All rights reserved.
X * TQM Communications, BCM Box 225, London, WC1N 3XX.
X * steveh@orbital.demon.co.uk  +44 836 825962
X *
X * See README for more information and disclaimers
X *
X * $Id: conf.h,v 1.8 1993/08/20 10:36:02 root Exp root $
X *
X * $Log: conf.h,v $
X * Revision 1.8  1993/08/20  10:36:02  root
X * Removed SIGRET definition as unused.
X *
X * Revision 1.7  1993/06/23  10:22:38  root
X * Removed NOBUFFOUT option.
X * Amended description for DBM, NDBM and DBZ as can now have none
X * defined if don't want to do history lookups.
X * Amended RNEWS description to describe how to send batches via UUCP.
X * Upped MAXCACHE value and improved description.
X *
X * Revision 1.6  1993/04/22  18:28:01  root
X * Added new compilation options for NOBUFFOUT and UNISTD.
X *
X * Revision 1.5  1993/03/01  17:41:09  root
X * Changed USG definition to SYSV, now used solely in slurp.h.
X * Added explanation of defines for space.c.
X *
X * Revision 1.4  1993/02/14  14:36:16  root
X * Removed BATCHARTSMAX, MSGIDMAX.
X * Added INDIR, BATCHNAME.
X * Modified TIMFILE, RNEWS.
X *
X * Revision 1.0  1992/10/29
X * Initial coding.
X *
X */
X
X
X/* SLURP CONFIGURATION
X   =================== */
X
X/* Set these to the location of the slurp configuration files - NEWSLIB
X   is usually a good place for them. The hostname will be added to the
X   end of TIMFILE. */
X
X#define SYSFILE			"/usr/lib/news/slurp.sys"
X#define TIMFILE			"/usr/lib/news/slurp."
X
X
X/* If SPEEDUP is defined then there will always be one ARTICLE request
X   stacked up at the NNTP server before the current article has
X   finished being received. Although not strictly conforming to the
X   standard this allows a much greater article throughput. */
X
X#define SPEEDUP
X
X
X/* If defined then the number of characters per second transferred
X   during the article request phase will be logged. */
X
X#define SPEEDSTATS
X
X
X/* MAXCACHE sets the maximum number of articles that may be requested
X   in any one session. If this is exceeded then it noted in the log and
X   the new time for the next NEWNEWS will not be written. If you are
X   transferring a large amount of news then you will probably need to
X   increase this value. */
X
X#define MAXCACHE		8192
X
X
X/* NEWS CONFIGURATION
X   ================== */
X
X/* The location of the news history file. */
X
X#define HISTORY_FILE    "/usr/lib/news/history"
X
X
X/* The database format used by the news history file. For modern C News
X   and INN this will almost certainly be DBZ. If none of these are
X   defined then history lookups will not take place. */
X
X#define DBZ
X#undef	DBM
X#undef	NDBM
X
X
X/* The location of the rnews program - or any other program you wish to
X   receive batches on stdin. If defined, slurp will pipe batches of
X   articles to this program rather than creating batch files in INDIR */
X
X/* #define RNEWS		"/usr/bin/rnews" /* */
X/* #define RNEWS		"compress | uux - -r -glow spooky!rnews" /* */
X
X
X/* The place where incoming batches will be placed if RNEWS is not
X   defined. This is usually /usr/spool/news/in.coming for C News and
X   /var/spool/rnews for INN. */
X
X#define INDIR			"/var/spool/news/in.coming"
X
X
X/* The optimum size of a news batch. Normally this can be left at
X   300000L.  If you are using INN and have RNEWS defined, then set this
X   to 0 so the pipe to rnews (and the socket to innd) is kept open
X   throughout the session. */
X
X#define BATCHSIZEMAX	300000L
X
X
X/* The location of the spool directory holding news articles. This is
X   needed so we can check if there is enough space before starting to
X   build up another batch of articles. */
X
X#define SPOOLDIR        "/var/spool/news"
X
X
X/* If less then MINFREE blocks are available on the disk containing
X   SPOOLDIR or less than MINFILES inodes are available then slurp will
X   be aborted. If MINFREE is not defined then a space check is not
X   carried out. */
X
X#define MINFREE 4000
X/* #define MINFILES 1000 /* */
X                        
X
X/* UNIX VERSION CONFIGURATION
X   ========================== */
X
X/* Define SYSV if you are running a System V derivative and need
X   <string.h>, <time.h> & <fcntl.h>. If it is undefined, then you're
X   BSDish and need <strings.h> & <sys/time.h>. */
X
X#define SYSV
X
X
X/* You may need additional defines to use the correct method of
X   determining how much disk space there is on the file system
X   containing your news spool. space.c understands defines for SVR4,
X   SVR3, sun, hpux, pyr, hp300, __NeXT__, linux, apollo, ultrix,
X   __bsdi__ and CMU_MACH. For other systems you may need to amend
X   space.c. */
X
X#define SVR4
X
X
X/* Define if your system has <unistd.h> */
X
X#define UNISTD
X
X
X/* Define if your system has extern char sys_errlist[], but no strerror() */
X
X#undef SYS_ERRLIST
X
X
X/* The facility name which syslog reports errors and stats under. If
X   you don't want to use syslog for reporting then undefine and the
X   information will be written to stderr instead. */
X
X#define SYSLOG			LOG_NEWS
X
X
X/* If you don't have syslog then you can use the supplied fakesyslog
X   instead. Define FAKESYSLOG to be the name of the file to contain the
X   log. If your host supports the BSD fdopen() function and the
X   O_APPEND flag to open(), you should define FAKEAPPEND with
X   FAKESYSLOG so that multiple copies of nntpd don't trash the log with
X   buffered fprintfs. */
X   
X/* #define FAKESYSLOG      "/usr/lib/news/nntplog" /* */
X/* #define FAKEAPPEND /* */
X
X
X/* STUFF BELOW PROBABLY DOESN'T NEED ALTERING
X   ========================================== */
X
X#define COPYSIZE		16384	/* Articles bigger than this size will
X                                   be written to a temporary file while
X                                   they are being retrieved, rather than
X                                   stored in memory */
X
X#define TIMEOUT			60 * 10	/* Max time to wait for a line from the
X                                   server. */
X
X#define BATCHNAME		"nntp.XXXXXX"	/* Temporary filename for NNTP
X										   batch */
X
X/* END-OF-FILE */
END_OF_FILE
  if test 6012 -ne `wc -c <'conf.h'`; then
    echo shar: \"'conf.h'\" unpacked with wrong size!
  fi
  # end of 'conf.h'
fi
if test -f 'fakesyslog.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fakesyslog.c'\"
else
  echo shar: Extracting \"'fakesyslog.c'\" \(3189 characters\)
  sed "s/^X//" >'fakesyslog.c' <<'END_OF_FILE'
X/*
X * $Id: fakesyslog.c,v 1.7 1993/06/07 11:05:52 root Exp $
X *
X * Fake syslog routines for systems that don't have syslog.
X * Taken from an idea by Paul McKenny, <mckenny@sri-unix.arpa>.
X * (Unfortunately, Paul, I can't distribute the real syslog code
X * as you suggested ... sigh.)
X *
X * Warning: this file contains joe code that may offend you.
X *
X * $Log: fakesyslog.c,v $
X * Revision 1.7  1993/06/07  11:05:52  root
X * Include fcntl.h if SYSV is defined, rather than if FCNTL is.
X *
X * Revision 1.4  1993/02/14  14:51:30  root
X * No changes.
X *
X */
X
X#include "slurp.h"
X
X#ifdef FAKESYSLOG
X
X#include "fakesyslog.h"
X
X#include <stdio.h>
X#include <sys/signal.h>
X#include <sys/types.h>
X
X#ifdef FAKEAPPEND
X#include <sys/file.h>
X#endif
X
X#ifdef SYSV
X#include <fcntl.h>
X#endif
X
Xextern	int	errno;
Xextern	int	sys_nerr;
Xextern	char	*sys_errlist[];
X
Xstatic FILE	*logfp;
Xstatic int	failed = 0;
Xstatic char	*ident = "syslog";
Xstatic int 	opt = 0;
X#ifndef BSD_42
Xstatic int	fac = 0;
X#endif
X
Xextern char	*strcpy(), *strcat(), *ctime();
Xextern time_t	time();
X
Xresetlog()
X{
X	closelog();
X	failed = 0;
X	if (logfp == NULL) {
X#ifdef BSD_42
X		openlog(ident, opt);
X#else
X		openlog(ident, opt, fac);
X#endif
X		if (logfp == NULL) {
X			failed = 1;
X			return;
X		}
X	}
X}
X
X#ifdef BSD_42
Xopenlog(newident,logopt)
X	char *newident;
X	int logopt;
X#else
Xopenlog(newident,logopt,facility)
X	char *newident;
X	int logopt, facility;
X#endif
X{
X#ifdef FAKEAPPEND
X/*
X * why can't stdio give us the capability of O_APPEND?
X */
X	int fd;
X
X	fd = open(FAKESYSLOG, O_WRONLY|O_APPEND, 0664);
X	if (fd < 0)
X		logfp = NULL;
X	else
X		logfp = fdopen(fd, "a");
X#else
X	logfp = fopen(FAKESYSLOG, "a");
X#endif
X
X	(void)signal(SIGHUP, resetlog);
X
X	if (newident && *newident)
X		ident = newident;
X	opt = logopt;
X#ifndef BSD_42
X	fac = facility;
X#endif
X}
X
Xcloselog()
X{
X	if (logfp) {
X		(void)fclose(logfp);
X		failed = 0;
X		logfp = NULL;
X	}
X}
X
X/*ARGSUSED*/
Xsetlogmask(maskpri)
X	int maskpri;
X{
X}
X
Xsyslog(pri, msg, x1, x2, x3, x4, x5, x6)
X	int	pri;
X	char	*msg, *x1, *x2, *x3, *x4, *x5, *x6;
X{
X	char		buf[1024];
X	char		*cp, *bp;
X	time_t		clock;
X
X	if (failed)
X		return;
X
X	if (logfp == NULL) {
X#ifdef BSD_42
X		openlog(ident, opt);
X#else
X		openlog(ident, opt, fac);
X#endif
X		if (logfp == NULL) {
X			failed = 1;
X			return;
X		}
X	}
X
X	(void) time(&clock);
X	(void) strcpy(buf, ctime(&clock)+4);
X	*(bp = buf + 16) = '\0';
X
X	(void) sprintf(bp, "localhost %s", ident ? ident : "");
X	bp += strlen(bp);
X
X	if (opt&LOG_PID) {
X		/* don't cache getpid() - who knows when we'll fork() */
X		(void) sprintf(bp, "[%d]", getpid());
X		bp += strlen(bp);
X	}
X
X	if (ident) {
X		(void) strcat(bp, ": ");
X		bp += 2;
X	} else {
X		(void) strcat(bp, " ");
X		bp ++;
X	}
X
X	for (cp = msg; *cp; cp++) {
X		if (*cp == '%' && cp[1] == 'm') {
X			*bp = '\0';
X			if (errno >= sys_nerr || errno < 0) {
X				char	work[32];
X				(void)sprintf(work, "unknown error #%d", errno);
X				(void)strcat(bp, work);
X			} else
X				(void)strcat(bp, sys_errlist[errno]);
X			bp = buf + strlen(buf);
X			cp++;
X		} else {
X			*bp++ = *cp;
X		}
X	}
X	*bp = '\0';
X	/* Ah, the semantic security of C ... */
X	if (bp[-1] != '\n')
X		(void) strcat(bp, "\n");
X
X	fprintf(logfp, buf, x1, x2, x3, x4, x5, x6);
X	(void) fflush(logfp);
X}
X
X#endif
END_OF_FILE
  if test 3189 -ne `wc -c <'fakesyslog.c'`; then
    echo shar: \"'fakesyslog.c'\" unpacked with wrong size!
  fi
  # end of 'fakesyslog.c'
fi
if test -f 'history.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'history.c'\"
else
  echo shar: Extracting \"'history.c'\" \(2024 characters\)
  sed "s/^X//" >'history.c' <<'END_OF_FILE'
X/*
X * history - handle a news history file
X *
X * Copyright (C) 1992/93 Stephen Hebditch. All rights reserved.
X * TQM Communications, BCM Box 225, London, WC1N 3XX.
X * steveh@orbital.demon.co.uk  +44 836 825962
X *
X * See README for more information and disclaimers
X *
X * Routines to open and close a C-News style history file and determine
X * whether or not a particular message id exists in the history file.
X *
X * $Id: history.c,v 1.7 1993/06/07 11:07:14 root Exp $
X *
X * $Log: history.c,v $
X * Revision 1.7  1993/06/07  11:07:14  root
X * If neither DBZ, DBM or NDBM are defined then don't carry out
X * any history file lookups.
X *
X * Revision 1.6  1993/04/22  18:07:11  root
X * No changes - put back in RCS after the RCS file went missing...
X *
X * Revision 1.4  1993/02/14  14:51:59  root
X * No changes.
X *
X * Revision 1.0  1992/09/92
X * Initial coding.
X *
X */
X
X#include "slurp.h"
X
X#ifdef DBM
X  #undef NULL
X  #include <dbm.h>
X  #undef NULL
X  #define NULL 0
X#endif
X
X#ifdef DBZ
X  #include <dbz.h>
X#endif
X
X#ifdef NDBM
X  #include <ndbm.h>
X  #include <fcntl.h>
X  static DBM *db = NULL;
X#endif
X
X
X/*
X * open_history - Open history file
X */
X
X	int
Xopen_history ()
X	{
X#if defined (DBM) || defined (DBZ)
X	if (dbminit (HISTORY_FILE) < 0)
X		return (1);
X#elif defined (NDBM)
X 	if ((db = dbm_open (HISTORY_FILE, O_RDONLY, 0)) == NULL)
X		return (1);
X#endif
X
X	return (0);
X	}
X
X
X/*
X * close_history - Close history file
X */
X
X	void
Xclose_history ()
X	{
X#if defined (DBM) || defined (DBZ)
X	(void) dbmclose ();
X#elif defined (NDBM)
X 	dbm_close (db);
X#endif
X	}
X
X
X/*
X * Determine if message id already exists in the history file
X */
X
X	int
Xcheck_id (char *message_id)
X	{
X#if defined (DBM) || defined (NDBM) || defined (DBZ)
X	datum k, d;
X
X/* Now check for presence with dbm/ndbm */
X
X	k.dptr = message_id;
X	k.dsize = strlen (message_id) + 1;
X#endif
X
X#if defined (DBM) || defined (DBZ)
X	d = fetch (k);
X	return (d.dptr == NULL);
X#elif defined (NDBM)
X 	d = dbm_fetch (db, k);
X	return (d.dptr == NULL);
X#else
X	return (TRUE);
X#endif
X	}
X
X/* END-OF-FILE */
END_OF_FILE
  if test 2024 -ne `wc -c <'history.c'`; then
    echo shar: \"'history.c'\" unpacked with wrong size!
  fi
  # end of 'history.c'
fi
if test -f 'misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc.c'\"
else
  echo shar: Extracting \"'misc.c'\" \(3335 characters\)
  sed "s/^X//" >'misc.c' <<'END_OF_FILE'
X/*
X * misc - general miscellaneous routines
X *
X * Copyright (C) 1992/93 Stephen Hebditch. All rights reserved.
X * TQM Communications, BCM Box 225, London, WC1N 3XX.
X * steveh@orbital.demon.co.uk  +44 836 825962
X *
X * See README for more information and disclaimers
X *
X * Assorted miscellaneous routines.
X *
X * $Id: misc.c,v 1.7 1993/06/07 11:08:12 root Exp $
X *
X * $Log: misc.c,v $
X * Revision 1.7  1993/06/07  11:08:12  root
X * Added stradd function.
X *
X * Revision 1.6  1993/04/22  18:31:11  root
X * Hey, it's 1993!
X *
X * Revision 1.4  1993/02/14  14:53:27  root
X * In log_sys if any message ids are present, then submit the
X * currently open batch and write out the unretrieved message
X * ids to slurp.<hostname> along with the new time.
X *
X * Revision 1.0  1992/11/27
X * Initial coding.
X *
X */
X
X#include "slurp.h"
X#include <stdarg.h>
X
Xstatic int in_log_sys = FALSE;
X
Xstatic void log_doit (int sysflag, const char *fmt, va_list ap);
X
X
X/*
X * stradd - If string1 is not NULL, then concatenate string1 and
X * string2, remallocing the space the first occupies to provide
X * enough room for them both. If string1 is null, then malloc space
X * for string2 and copy string2 to it. Returns location of string.
X */
X
X	char *
Xstradd (const char *string1, const char *string2)
X	{
X	size_t len;
X	char *new;
X
X	if (string1 == NULL)
X		{
X		len = strlen (string2) + sizeof (char);
X		if ((new = (char *) malloc (len)) == NULL)
X			log_sys ("stradd: malloc %d bytes", len);
X		(void) strcpy (new, string2);
X		}
X	else
X		{
X		len = strlen (string1) + strlen (string2) + sizeof (char);
X		if ((new = (char *) realloc ((void *) string1, len)) == NULL)
X			log_sys ("stradd: realloc %d bytes", len);
X		(void) strcat (new, string2);
X		}
X	return (new);
X	}
X
X
X/*
X * log_ret - Log a message to stderr or syslog related to a system call
X * containing the appropriate system error message and return.
X */
X
X	void
Xlog_ret (const char *fmt, ...)
X	{
X	va_list ap;
X
X	va_start (ap, fmt);
X	log_doit (TRUE, fmt, ap);
X	va_end (ap);
X	return;
X	}
X
X
X/*
X * log_sys - Log a message to stderr or syslog related to a system call.
X * containing the appropriate system error message and exit program.
X * If any message ids in the tree then write out slurp.<hostname> file
X * and close the batch if open.
X */
X
X	void
Xlog_sys (const char *fmt, ...)
X	{
X	va_list ap;
X
X	va_start (ap, fmt);
X	log_doit (TRUE, fmt, ap);
X	va_end (ap);
X	if ((!in_log_sys) && (root != NULL))
X		{
X		in_log_sys = TRUE;
X		enqueue_batch ();
X		if ((!no_time_flag) && (!no_id_load_flag))
X			set_ntime ();
X		}
X	exit (1);
X	}
X
X
X/*
X * log_msg - Log a message to stderr or syslog unrelated to a system call.
X */
X
X	void
Xlog_msg (const char *fmt, ...)
X	{
X	va_list ap;
X
X	va_start (ap, fmt);
X	log_doit (FALSE, fmt, ap);
X	va_end (ap);
X	return;
X	}
X
X
X/*
X * log_doit - Write an error message to stderr if debug_flag is set or
X * syslog if not set. If sysflag is true then the last system error
X * message is appended.
X */
X
X	static void
Xlog_doit (int sysflag, const char *fmt, va_list ap)
X	{
X	int errnosave;
X	char buf [BUFSIZ];
X
X	errnosave = errno;
X	(void) vsprintf (buf, fmt, ap);
X	if (sysflag)
X		(void) sprintf (buf + strlen (buf), ": %s", strerror (errnosave));
X	(void) strcat (buf, "\n");
X#ifdef SYSLOG
X		if (!debug_flag)
X			syslog (LOG_ERR, buf);
X		else
X#endif
X			(void) fprintf (stderr, "%s: %s", pname, buf);
X	}
X
X
X/* END-OF-FILE */
END_OF_FILE
  if test 3335 -ne `wc -c <'misc.c'`; then
    echo shar: \"'misc.c'\" unpacked with wrong size!
  fi
  # end of 'misc.c'
fi
if test -f 'nntp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nntp.h'\"
else
  echo shar: Extracting \"'nntp.h'\" \(3070 characters\)
  sed "s/^X//" >'nntp.h' <<'END_OF_FILE'
X/*
X * Response codes for NNTP server
X *
X * @(#)Header: nntp.h,v 1.8 90/07/05 02:08:31 sob Exp $
X *
X * First digit:
X *
X *	1xx	Informative message
X *	2xx	Command ok
X *	3xx	Command ok so far, continue
X *	4xx	Command was correct, but couldn't be performed
X *		for some specified reason.
X *	5xx	Command unimplemented, incorrect, or a
X *		program error has occurred.
X *
X * Second digit:
X *
X *	x0x	Connection, setup, miscellaneous
X *	x1x	Newsgroup selection
X *	x2x	Article selection
X *	x3x	Distribution
X *	x4x	Posting
X */
X
X#define	CHAR_INF	'1'
X#define	CHAR_OK		'2'
X#define	CHAR_CONT	'3'
X#define	CHAR_ERR	'4'
X#define	CHAR_FATAL	'5'
X
X#define	INF_HELP	100	/* Help text on way */
X#define	INF_AUTH	180	/* Authorization capabilities */
X#define	INF_DEBUG	199	/* Debug output */
X
X#define	OK_CANPOST	200	/* Hello; you can post */
X#define	OK_NOPOST	201	/* Hello; you can't post */
X#define	OK_SLAVE	202	/* Slave status noted */
X#define	OK_GOODBYE	205	/* Closing connection */
X#define	OK_GROUP	211	/* Group selected */
X#define	OK_GROUPS	215	/* Newsgroups follow */
X#define	OK_ARTICLE	220	/* Article (head & body) follows */
X#define	OK_HEAD		221	/* Head follows */
X#define	OK_BODY		222	/* Body follows */
X#define	OK_NOTEXT	223	/* No text sent -- stat, next, last */
X#define	OK_NEWNEWS	230	/* New articles by message-id follow */
X#define	OK_NEWGROUPS	231	/* New newsgroups follow */
X#define	OK_XFERED	235	/* Article transferred successfully */
X#define	OK_POSTED	240	/* Article posted successfully */
X#define	OK_AUTHSYS	280	/* Authorization system ok */
X#define	OK_AUTH		281	/* Authorization (user/pass) ok */
X
X#define	CONT_XFER	335	/* Continue to send article */
X#define	CONT_POST	340	/* Continue to post article */
X#define	NEED_AUTHINFO	380	/* authorization is required */
X#define	NEED_AUTHDATA	381	/* <type> authorization data required */
X
X#define	ERR_GOODBYE	400	/* Have to hang up for some reason */
X#define	ERR_NOGROUP	411	/* No such newsgroup */
X#define	ERR_NCING	412	/* Not currently in newsgroup */
X#define	ERR_NOCRNT	420	/* No current article selected */
X#define	ERR_NONEXT	421	/* No next article in this group */
X#define	ERR_NOPREV	422	/* No previous article in this group */
X#define	ERR_NOARTIG	423	/* No such article in this group */
X#define	ERR_NOART	430	/* No such article at all */
X#define	ERR_GOTIT	435	/* Already got that article, don't send */
X#define	ERR_XFERFAIL	436	/* Transfer failed */
X#define	ERR_XFERRJCT	437	/* Article rejected, don't resend */
X#define	ERR_NOPOST	440	/* Posting not allowed */
X#define	ERR_POSTFAIL	441	/* Posting failed */
X#define	ERR_NOAUTH	480	/* authorization required for command */
X#define	ERR_AUTHSYS	481	/* Authorization system invalid */
X#define	ERR_AUTHREJ	482	/* Authorization data rejected */
X
X#define	ERR_COMMAND	500	/* Command not recognized */
X#define	ERR_CMDSYN	501	/* Command syntax error */
X#define	ERR_ACCESS	502	/* Access to server denied */
X#define	ERR_FAULT	503	/* Program fault, command not performed */
X#define	ERR_AUTHBAD	580	/* Authorization Failed */
X
X/* RFC 977 defines this; don't change it. */
X
X#define	NNTP_STRLEN	512
END_OF_FILE
  if test 3070 -ne `wc -c <'nntp.h'`; then
    echo shar: \"'nntp.h'\" unpacked with wrong size!
  fi
  # end of 'nntp.h'
fi
if test -f 'slurp.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'slurp.1'\"
else
  echo shar: Extracting \"'slurp.1'\" \(8561 characters\)
  sed "s/^X//" >'slurp.1' <<'END_OF_FILE'
X.TH SLURP 1 "20 August 1993" "V1.08"
X
X.SH NAME
X.I slurp
X\- retrieve netnews articles from a remote NNTP server
X
X.SH SYNOPSIS
X.I slurp
X[
X.B \-g
X.I newsgroups/distributions
X]
X[
X.B \-t
X.I time
X]
X[
X.B \-a
X.I username/password
X]
X[
X.B \-d
X]
X[
X.B \-i
X]
X[
X.B \-l
X]
X[
X.B \-r
X]
X[
X.B \-w
X]
X.I hostname[ /sublist ][ :timefile ]
X
X.SH DESCRIPTION
X.PP
X.I Slurp
Xis an advanced passive NNTP client for UNIX. It will connect to a
Xremote NNTP server and retrieve articles in a specified set of Usenet
Xnewsgroups that have arrived after a particular time (typically the
Xlast time it was invoked) for processing by your local news system.
X
X.SH OPTIONS
X.TP
X.BI -g " newsgroups/distributions"
XIf specified then overrides any newsgroups and distributions specification
Xfor
X.I hostname
Xin the 
X.B slurp.sys
Xfile.
X.TP
X.BI -t " time"
XRetrieve articles that have arrived at the server after
X.I time
Xrather than using the time taken from
X.BR slurp.<hostname> .
XThis is in the standard NNTP time format of 'YYMMDD HHMMSS' GMT. For
Xexample, midnight GMT on the 1st of December 1992 will be '921201
X000000'. Note that you will need to use quotes around the time and
Xremember that the time is in GMT, not the local or server time.
X.TP
X.BI -a " username/password"
XIf specified then the username and password combination will be sent to
Xthe server as part of the simple authorisation protocol when the
Xconnection is first made.
X.TP
X.B -d
XEnable debugging. This diverts reporting to stderr instead of syslog
Xand turns on extra debugging output.
X.TP
X.B -i
XNormally if an error occurs while fetching articles from the server,
Xthe remaining message IDs to be fetched are written to
X.B slurp.<hostname>
Xso that they may be retrieved in the next session without having to
Xrestart the NEWNEWS at the same point. With this option selected, no
Xmessage IDs will be read from
X.B slurp.<hostname>
Xand in the event of an error occurring,
X.B slurp.<hostname>
Xwill not be updated.
X.TP
X.B -l
XLocal time is used to set the start time in
X.B slurp.<hostname>
Xfor the next news retrieval, rather than setting the start time through
Xa call to the tcp time service at the remote server.
X.TP
X.B -r
XA 'MODE READER' command is sent to the remote server. This is used when
Xconnecting with an INN site which needs to be switched from innd to
Xnnrpd so the NEWNEWS command can be issued.
X.TP
X.B -w
XThe time for the next news retrieval is not written to
X.BR slurp.<hostname> \.
X.TP
X.I hostname
XThe hostname of the remote NNTP server to connect to. This must be
Xspecified.
X.TP
X.I [/sublist]
XIf this is specified, then the entry in
X.B slurp.sys
Xwhich contains
X.I /sublist
Xafter the hostname will be used. This lets you take different groups
Xfrom the same server at different times.
X.TP
X.I [:timefile]
XUse this to specify an alternate filename to use for the file
Xcontaining the time for the next NEWNEWS at a particular host. Normally
Xslurp will use the hostname, but this can cause problems on file
Xsystems with short filenames.
X
X.SH "CONFIGURATION FILES"
X.PP
XThere are two configuration files used by
X.IR slurp .
X.SS slurp.sys
X.PP
XEntries in
X.B slurp.sys
Xtake the form
X.IP
Xhostname/sublist:groups/distributions:flags:username/password
X.PP
XThis format should be familar to people who have used the C News
X.B sys
Xfile. Entries for a particular host can be continued on more than one
Xline by using a '\\' at the end of the line. e.g.
X.IP
Xhostname:group1,group2,\\
X.br
Xgroup3,group4,group5
X.PP
X.I Slurp
Xis even more picky about the presence of whitespace than C News. It can
Xonly appear in comments. Comments begin with a '#' and continue to the
Xend of the line.
X.PP
XUsing distributions is
X.B not
Xrecommended - they're only really included for completeness. Under
Xcurrent NNTP implementations, setting distributions requires the server
Xto open each article, search through for the distributions line and
Xcheck it against the supplied list. This will not only increase the
Xload on the server substantially, but increase the amount of time for
Xthe connection.
X.PP
XThere are 3 possible flags: i, l and r which have the same meaning as
Xthe command line options. If present, username and password will be
Xsent to the server as part of the simple authorisation protocol when
Xthe connection is first made.
X.SS slurp.<hostname>[.<sublist>]
X.PP
XThe file
X.B slurp.<hostname>
Xcontains the time when
X.I slurp
Xlast connected to the NNTP server at <hostname>. If a sublist has been
Xspecified with the
X.B -s
Xoption then this will be appended with a period to the name.
X.I slurp
Xcan then use this time to pick up all the articles that have arrived at
Xthe server since the last session. It may be followed on subsequent
Xlines by a list of message IDs of articles that are to be retrieved
Xfrom the server in the next session.
X.PP
XEach time
X.I slurp
Xis run and
X.B slurp.<hostname>
Xupdated, the current
X.B slurp.<hostname>
Xwill be backed up in the file
X.BR slurp.<hostname>.o \.
X
X.SH OPERATION
X.PP
XWhen run,
X.I slurp
Xwill first retrieve the appropriate newsgroup list, distribution list
Xand start time for the specified server, either from the configuration
Xfiles or overriding those settings with the command line options.
X.PP
XIf the
X.B -w
Xoption is not set, then the current time will be obtained to use as the
Xstart time for the next session. If the
X.B -l
Xoption is specified, this will be taken from the local machine,
Xotherwise it will be retrieved from the remote server through a call to
Xthe tcp time service there. If
X.B -i
Xis not specified, then the message IDs of any articles which were not
Xretrieved in the last session will be loaded from
X.BR slurp.<hostname> \.
X.PP
X.I Slurp
Xwill now connect to the NNTP server at the remote host. If a username
Xand password for use with the simple authorisation protocol have been
Xsupplied then they will be sent to the server. If the
X.B -r
Xoption is specified, then a 'MODE READER' command will be sent, to
Xensure at INN sites that
X.I slurp
Xis talking to nnrpd.
X.PP
XA NEWNEWS request will now be issued, asking for all the articles that
Xhave arrived in the specified list of newsgroups since the specified
Xtime. The server will respond with a list of message IDs. If a message
XID is not already present in the local history file, then it will be
Xstored in memory. If the list of newsgroups is too large to fit on
Xone line (NNTP has a maximum line length of 512 characters) then a
Xseries of NEWNEWS requests will be carried out, adding further message
XIDs to the memory list if they are not already present.
X.PP
XOnce this has been completed,
X.I slurp
Xmoves into an article retrieval stage. It will go through the list of
Xmessage IDs in memory and request them in turn from the server, adding
Xeach article to the batch of articles being either stored in the
Xincoming news directory or piped to
X.I rnews.
XWhen a batch is found to be larger than the maximum size, it will be
Xsubmitted to the news system.
X.PP
XOnce all the articles have been retrieved, the final batch of articles
Xwill be submitted. If the
X.B -w
Xoption has not been set, then the previously obtained time to use for
Xthe next NEWNEWS will be written to
X.BR slurp.<hostname> .
XIf an error has occurred, then the message IDs of any unretrieved
Xarticles are also written to this file, for retrieval in the next
Xsession.
X.PP
XStatistics on the connection will be logged to syslog (or stderr if
Xsyslog is not available). The new article count is the total number of
Xarticles that have been submitted to the new system. The duplicate
Xcount is how many message IDs were found to already exist on the local
Xsystem. If two NEWNEWS requests are necessary and a message ID was
Xreturned by both requests, then it will be included twice in the
Xduplicate count. The missing count is those articles which were in the
Xserver's history file but didn't exist as actual article files, usually
Xbecause they have been cancelled. If configured, the speed of transfer
Xof the article retrieval stage will also be logged.
X
X.SH "RETURN CODES"
X.PP
XSlurp returns a series of return codes which may be useful to
Xcontrolling programs:-
X.RS
X0 - Successful completion
X.br
X1 - General system error
X.br
X2 - Incorrect arguments supplied or incorrect configuration files.
X.br
X3 - Error occurred during attempt to connect to remote host
X.br
X4 - NNTP Protocol error
X.br
X5 - Insufficient disk space available for news batch.
X.RE
X
X.SH FILES
X/usr/lib/news/slurp.sys
X.br
X/usr/lib/news/slurp.<hostname>
X.SH AUTHOR
XStephen Hebditch <steveh@orbital.demon.co.uk>
X.SH "SEE ALSO"
Xrnews(8)
X.br
XRFC977 \- Network News Transfer Protocol (NNTP),
X.br
XRFC1036 \- Usenet Article Format standard.
END_OF_FILE
  if test 8561 -ne `wc -c <'slurp.1'`; then
    echo shar: \"'slurp.1'\" unpacked with wrong size!
  fi
  # end of 'slurp.1'
fi
if test -f 'slurp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'slurp.h'\"
else
  echo shar: Extracting \"'slurp.h'\" \(3738 characters\)
  sed "s/^X//" >'slurp.h' <<'END_OF_FILE'
X/*
X * slurp.h - common definitions for slurp
X *
X * Copyright (C) 1992/93 Stephen Hebditch. All rights reserved.
X * TQM Communications, BCM Box 225, London, WC1N 3XX.
X * steveh@orbital.demon.co.uk  +44 836 825962
X *
X * See README for more information and disclaimers
X *
X * $Id: slurp.h,v 1.7 1993/06/07 11:17:47 root Exp $
X *
X * $Log: slurp.h,v $
X * Revision 1.7  1993/06/07  11:17:47  root
X * Removed bcopy/bzero definitions and used ANSI memcpy and memset
X * functions throughout the code instead.
X *
X * Revision 1.6  1993/04/22  18:10:09  root
X * Corrected function prototype of server_time - should have been
X * time_t instead of long.
X * Made <unistd.h> a compilation option.
X *
X * Revision 1.5  1993/03/01  17:57:44  root
X * Minor reshuffle, plus USG definition now SYSV.
X *
X * Revision 1.4  1993/02/14  14:40:55  root
X * Added no_id_load_flag.
X * Modified struct mnode to include used flag and remove msgid.
X * New process_id and set_ntime definitions.
X *
X * Revision 1.3  1992/12/15
X * Added SYS_ERRLIST definitions.
X *
X * Revision 1.1  1992/12/06
X * Added no_time flag.
X *
X * Revision 1.0  1992/10/29
X * Initial coding.
X *
X */
X
X/* Local header files */
X
X#include "conf.h"
X#include "nntp.h"
X
X
X/* Standard header files */
X
X#include <sys/types.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <limits.h>
X#include <ctype.h>
X#include <errno.h>
X
X#ifdef SYSLOG
X  #ifdef FAKESYSLOG
X    #include "fakesyslog.h"
X  #else
X    #include <syslog.h>
X  #endif
X#endif
X
X#ifdef UNISTD
X  #include <unistd.h>
X#endif
X
X#ifdef SYSV
X  #include <string.h>
X  #include <time.h>
X#else
X  #include <strings.h>
X  #include <sys/time.h>
X#endif
X
X#ifdef SYS_ERRLIST
X  extern const char *sys_errlist[];
X  #define strerror(x) (sys_errlist[x])
X#endif
X
X
X/* Important variables */
X
Xextern char *hostname;		/* Name of current NNTP server host */
Xextern char *pname;			/* Name of this program */
Xextern int  debug_flag;		/* Write extra debugging output to screen */
Xextern int  no_time_flag;	/* Don't update slurp.<hostname> */
Xextern int  no_id_load_flag;/* Don't dump / load message ids */
X
X/* Article counters */
X
Xextern int  dupart;			/* Number of duplicate articles */
Xextern int  misart;			/* Number of missing articles */
Xextern int  newart;			/* Number of new articles */
X
Xextern long totalsize;		/* Total size of articles tranferred */
X
X/* Details for NEWNEWS */
X
Xextern char *nn_newsgroups;
Xextern char *nn_time;
Xextern char *nn_distributions;
X
X/* Binary tree holding message ids */
X
Xstruct mnode
X	{
X	struct mnode *left;
X	struct mnode *right;
X	char *msgid;
X	int used;
X	};
X                          
Xextern struct mnode *root;
Xextern int entries;
X
X
X/* Slurp function prototypes */
X
Xextern void get_articles ();						/* articles.c */
Xextern void enqueue_batch ();
X
Xextern int  open_history ();						/* history.c */
Xextern void close_history ();
Xextern int  check_id (char *message_id);
X
Xextern void log_ret (const char *fmt, ...);			/* misc.c */
Xextern void log_sys (const char *fmt, ...);
Xextern void log_msg (const char *fmt, ...);
Xextern char *stradd (const char *, const char *);
X
Xextern void get_ids ();								/* newnews.c */
Xextern void process_id (char *msgid);
X
Xextern void set_ntime ();							/* slurp.c */
X
Xextern int  tcp_open (char *host, char *service);	/* sockets.c */
Xextern int  server_init (char *hostname);
Xextern void close_server ();
Xextern void get_server (char *buf, int size);
Xextern void put_server (char *buf);
X
Xextern int  space (int min_free);					/* space.c */
X
Xextern time_t server_time ();						/* time.c */
X
X
X/* The inevitable... */
X
X#if !defined (TRUE) || ((TRUE) != 1)
X  #define TRUE (1)
X#endif
X
X#if !defined (FALSE) || ((FALSE) != 0)
X  #define FALSE (0)
X#endif
X
X#ifndef PATH_MAX
X  #define PATH_MAX 1024
X#endif
X
X/* END-OF-FILE */
END_OF_FILE
  if test 3738 -ne `wc -c <'slurp.h'`; then
    echo shar: \"'slurp.h'\" unpacked with wrong size!
  fi
  # end of 'slurp.h'
fi
if test -f 'sockets.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sockets.c'\"
else
  echo shar: Extracting \"'sockets.c'\" \(6353 characters\)
  sed "s/^X//" >'sockets.c' <<'END_OF_FILE'
X/*
X * sockets - open a socket connection and read/write to nntp server
X *
X * Copyright (C) 1992/93 Stephen Hebditch. All rights reserved.
X * TQM Communications, BCM Box 225, London, WC1N 3XX.
X * steveh@orbital.demon.co.uk  +44 836 825962
X *
X * See README for more information and disclaimers
X *
X * Obtain the current time from the remote server in standard unix time
X * format for use with the next NEWNEWS. If the client is unable to
X * connect to the time server, then local time is used instead.
X *
X * $Id: sockets.c,v 1.7 1993/06/23 10:15:37 root Exp $
X *
X * $Log: sockets.c,v $
X * Revision 1.7  1993/06/23  10:15:37  root
X * Replaced bzero/bcopy definitions with ANSI memcpy and memset.
X * Duplicate fd before using fdopen separately on each fd for read
X * and write, fixing long-standing stdio memory problems.
X *
X * Revision 1.6  1993/04/22  18:25:16  root
X * If NOBUFFOUT defined then turn off stdio buffering for the
X * output stream to the server to get round problem with SVR3s.
X *
X * Revision 1.5  1993/03/01  18:00:18  root
X * Use ferror to detect erros, not return code.
X *
X * Revision 1.4  1993/02/14  16:22:42  root
X * No longer have get_server return a return code. Makes this module
X * no longer compatible with nntp 1.6 client library, but there ya go...
X * Changed error detection in put_server for no other reason than to
X * be consistent with elsewhere.
X *
X * Revision 1.3  1992/12/15
X * Removed unnecessary close() in close_server.
X * Syslog log level for connected message changed to LOG_INFO.
X *
X * Revision 1.1  1992/12/04
X * Print line before it is sent to server when debugging is on.
X *
X * Revision 1.0  1992/11/29
X * Adapted from nntpxfer-e code.
X * Incorporate code to set up a tcp connection, plus cleaned up the
X * existing code.
X *
X */
X
X#include "slurp.h"
X
X#include <signal.h>
X#include <setjmp.h>
X#include <netdb.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <arpa/inet.h>
X
X#ifndef INADDR_NONE
X  #define INADDR_NONE 0xffffffff
X#endif
X
Xstruct sockaddr_in serv_addr;
Xstruct servent serv_info;
Xstruct hostent host_info;
X
Xstatic FILE *server_rd_fp;
Xstatic FILE *server_wr_fp;
X
X
X/*
X * tcp_open - Open a tcp connection to 'host' for service 'service',
X * returning a file descriptor for the socket.
X */
X
X	int
Xtcp_open (char *host, char *service)
X	{
X	int sockfd;
X	int on = 1;
X	unsigned long inaddr;
X	struct servent *sp;
X	struct hostent *hp;
X
X	(void) memset (&serv_addr, 0, sizeof (serv_addr));
X	serv_addr.sin_family = AF_INET;
X
X	/* Get service information */
X	if ((sp = getservbyname (service, "tcp")) == NULL)
X		{
X		log_ret ("tcp_open: Unknown service %s/tcp", service);
X		return (-1);
X		}
X	serv_info = *sp;
X	serv_addr.sin_port = sp->s_port;
X
X	/* Try to convert host name as dotted decimal */
X	if ((inaddr = inet_addr (host)) != INADDR_NONE)
X		{
X		(void) memcpy (&serv_addr.sin_addr, &inaddr, sizeof (inaddr));
X		host_info.h_name = NULL;
X		}
X	/* If that failed, then look up the host name */
X	else
X		{
X		if ((hp = gethostbyname (host)) == NULL)
X			{
X			log_ret ("tcp_open: Host name error: %s", host);
X			return (-1);
X			}
X		host_info = *hp;
X		(void) memcpy (&serv_addr.sin_addr, hp->h_addr, hp->h_length);
X		}
X
X	if ((sockfd = socket (AF_INET, SOCK_STREAM, 0)) < 0)
X		{
X		log_ret ("tcp_open: Can't create TCP socket");
X		return (-1);
X		}
X
X	if (connect (sockfd, (struct sockaddr *) &serv_addr,
X	    sizeof (serv_addr)) < 0)
X		{
X		log_ret ("tcp_open: Can't connect to server %s", host);
X		(void) close (sockfd);
X		return (-1);
X		}
X
X	if (setsockopt (sockfd, SOL_SOCKET, SO_KEEPALIVE, 
X					(char *) &on, sizeof (on)) < 0)
X		log_ret ("tcp_open: Can't set KEEPALIVE on socket");
X
X	return (sockfd);
X	}
X
X/*
X * server_init - Open a connection to the NNTP server. Returns -1 if an
X * error occurs, otherwise the server's initial response code.
X */
X
X	int
Xserver_init (char *hostname)
X	{
X	char line [NNTP_STRLEN];
X	int server_rd_fd;
X	int server_wr_fd;
X
X	/* First try and make the connection */
X	if ((server_rd_fd = tcp_open (hostname, "nntp")) < 0)
X		return (-1);
X	server_wr_fd = dup (server_rd_fd);
X
X	/* Now fdopen to enable buffering of data */
X	if ((server_rd_fp = fdopen (server_rd_fd, "r")) == NULL)
X		{
X		log_ret ("server_init: Can't fdopen socket for reading");
X		return (-1);
X		}
X	if ((server_wr_fp = fdopen (server_wr_fd, "w")) == NULL)
X		{
X		log_ret ("server_init: Can't fdopen socket for writing");
X		return (-1);
X		}
X        
X	/* Inform everyone that we're there */
X#ifdef SYSLOG
X	if (!debug_flag)
X		syslog(LOG_INFO, "Connected to nntp server at %s", hostname);
X	else
X#endif
X		(void) fprintf (stderr, "Connected to nntp server at %s\n", hostname);
X
X	/* Get the greeting herald */
X	get_server (line, sizeof (line));
X	if (debug_flag)
X		(void) fprintf (stderr, "-> %s\n", line);
X
X	/* Return the banner code */
X	return (atoi (line));
X	}
X
X
X/*
X * close_server - Close down the NNTP server connection
X */
X
X	void
Xclose_server ()
X	{
X	char line [NNTP_STRLEN];
X
X	if (debug_flag)
X		(void) fprintf (stderr, "<- QUIT\n");
X	put_server ("QUIT");
X	get_server (line, sizeof (line));
X	if (debug_flag)
X		(void) fprintf (stderr, "-> %s\n", line);
X
X	(void) fclose (server_rd_fp);
X	(void) fclose (server_wr_fp);
X	}
X
X
Xstatic jmp_buf env_alrm;
X
X	static void
Xsig_alrm (int signo)
X	{
X	longjmp (env_alrm, 1);
X	}
X
X/*
X * get_server - Read a line up to CRLF from the socket into a buffer.
X */
X
X	void
Xget_server (char *line, int size)
X	{
X	int esave;
X	char *pos;
X
X	/* Set up an alarm to handle socket timeout */
X	if (setjmp (env_alrm))
X		{
X		(void) alarm (0);					/* Reset alarm clock */
X		(void) signal (SIGALRM, SIG_DFL);
X		errno = EPIPE;
X		log_sys ("get_server: Read error on server socket");
X		}
X
X	(void) signal (SIGALRM, sig_alrm);
X	(void) alarm (TIMEOUT);
X
X	/* Read line */
X	(void) fgets (line, size, server_rd_fp);
X
X	/* Reset the alarm */
X	esave = errno;
X	(void) alarm (0);
X	(void) signal (SIGALRM, SIG_DFL);
X	errno = esave;
X
X	/* Report any error */
X	if (ferror (server_rd_fp))
X		log_sys ("get_server: Read error on server socket");
X
X	/* Kill the CRLF */
X	if (pos = strchr (line, '\r'))
X		*pos = '\0';
X	if (pos = strchr (line, '\n'))
X		*pos = '\0';
X	}
X
X/*
X * put_server - write a line from a linefer to a socket
X */
X
X	void
Xput_server (char *line)
X	{
X
X	(void) fprintf (server_wr_fp, "%s\r\n", line);
X	if (ferror (server_wr_fp))
X		log_sys ("put_server: Write error on server socket");
X	(void) fflush (server_wr_fp);
X	}
X
X/* END-OF-FILE */
END_OF_FILE
  if test 6353 -ne `wc -c <'sockets.c'`; then
    echo shar: \"'sockets.c'\" unpacked with wrong size!
  fi
  # end of 'sockets.c'
fi
if test -f 'space.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'space.c'\"
else
  echo shar: Extracting \"'space.c'\" \(5486 characters\)
  sed "s/^X//" >'space.c' <<'END_OF_FILE'
X/*
X * space - determine free space on a filesystem
X *
X * Copyright (C) 1992/93 Stephen Hebditch and others.
X * TQM Communications, BCM Box 225, London, WC1N 3XX.
X * steveh@orbital.demon.co.uk  +44 836 825962
X *
X * See README for more information and disclaimers
X *
X * This routine determines if there is enough space on the filesystem
X * holding the news spool for a new batch of incoming articles.
X * It is based on space.c in the NNTP reference implementation which
X * credits Stan Barber <sob@bcm.tmc.edu>, Tad Guy <tadguy@cs.odu.edu>,
X * Chris Jepeway <jepeway@utkcs2.cs.utk.edu> and Tom Lane <tgl@cs.cmu.edu>
X * but has been heavily cleaned up and support for SVR4, Linux and
X * BSDI added.
X *
X * $Id: space.c,v 1.7 1993/06/14 15:25:42 root Exp $
X *
X * $Log: space.c,v $
X * Revision 1.7  1993/06/14  15:25:42  root
X * Added routine name to error messages.
X * Made close() consistent with usage elsewhere.
X *
X * Revision 1.6  1993/04/22  18:27:21  root
X * Changed NeXT define to __NeXT__.
X *
X * Revision 1.5  1993/03/01  18:08:20  root
X * Completely reworked from the original and heavily tidied up.
X * Support added for SVR4 and Linux.
X *
X * Revision 1.4  1993/02/14  16:12:20  root
X * Added support for BSDI.
X *
X */
X
X#include "slurp.h"
X
X#ifdef MINFREE
X
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#define DFREE_OK		0
X#define DFREE_INODES	1
X#define DFREE_BLOCKS	2
X#define DFREE_ERR		3
X
X/*
X * Definitions for use with dfree() for various UNIX families.
X *
X * statfilesys		Routine to call when trying to stat a file system
X *					to get the number of free blocks available.
X * statfs_type		The data type into which statfs() wants to return
X *					useful information.
X * bombed			Boolean expression returning 1 if a call to statfs()
X *					fails.
X * blkavail			Given a statfs_type called fs, return number of free
X *					blocks available to a non-superuser.
X * filavail			Given a statfs_type called fs, return number of free
X *					inodes available to a non-superuser.
X */
X
X  #if defined(SVR4)
X	#include <sys/statvfs.h>
X	#define statfilesys		statvfs
X	typedef struct statvfs 	statfs_type;
X	#define bombed(call)	((call) == -1)
X	#define blkavail(fs)	((fs).f_bavail)
X	#define filavail(fs)	((fs).f_favail)
X
X  #elif defined(sun) || defined(hpux) || defined(pyr) || defined(hp300) || defined(__NeXT__) || defined(linux)
X	#include <sys/vfs.h>
X	#define statfilesys		statfs
X	typedef struct statfs 	statfs_type;
X	#define bombed(call)	((call) == -1)
X	#define blkavail(fs)	((fs).f_bavail)
X	#define filavail(fs)	((fs).f_ffree)
X
X  #elif defined(apollo)
X	#include <sys/types.h>
X	#include <sys/statfs.h>
X	#define statfilesys(a,b) statfs (a, b, sizeof (struct statfs), 0)
X	typedef struct statfs 	statfs_type;
X	#define bombed(call)	((call) == -1)
X	#define blkavail(fs)	((fs).f_bfree)
X	#define filavail(fs)	((fs).f_ffree)
X
X  #elif defined(ultrix)
X	#include <sys/mount.h>
X	typedef struct fs_data	statfs_type;
X	#define statfilesys		statfs
X	#define bombed(call)	((call) <= 0)
X	#define blkavail(fs)	((int)((fs).fd_req.bfreen))
X	#define filavail(fs)	((int)((fs).fd_req.gfree))
X
X  #elif defined(__bsdi__)
X	#include <sys/mount.h>
X	typedef struct statfs	statfs_type;
X	#define statfilesys		statfs
X	#define bombed(call)	((call) < 0)
X	#define blkavail(fs)	((int)((fs).f_bfree))
X	#define filavail(fs)	((int)((fs).f_ffree))
X
X  #elif defined(SVR3)
X	#include <ustat.h>
X	typedef struct ustat statfs_type;
X		int
X	statfilesys (char *dir, statfs_type *fs)
X		{
X		struct stat file;
X		if (stat (dir, &file))
X			return (-1);
X		if (ustat (file.st_dev, fs))
X			return (-2);
X		return (0);
X		}
X	#define bombed(call)	(call != 0)
X	#define blkavail(fs)	((fs).f_tfree)
X	#define filavail(fs)	((fs).f_tinode)	
X
X  #elif defined(CMU_MACH)
X	#include <sys/ioctl.h>
X	typedef struct fsparam statfs_type;
X		int
X	statfilesys (char *dir, statfs_type *fs)
X		{
X		int fd;
X		fd = open (dir, O_RDONLY);
X		if (fd < 0)
X			return (-1);
X		if (ioctl (fd, FIOCFSPARAM, fs) < 0)
X			{
X			(void) close (fd);
X			return(-2);
X			}
X		(void) close (fd);
X		return (0);
X		}
X	#define bombed (call)	((call) < 0)
X	#define blkavail (fs)	((fs).fsp_free-((fs).fsp_size*(fs).fsp_minfree+99)/100)
X
X  #else
X	SPACE DEFINITIONS NOT AVAILABLE FOR THIS MACHINE OR NOT SET CORRECTLY
X  #endif
X
X
X/*
X * dfree - Return the free space available on the file system containing
X * the specified directory. Space is measured in kilobytes. A negative
X * value is returned if there is an error.
X */
X
X	static int
Xdfree (char *location, int free_space)
X	{
X	statfs_type fsys;
X
X	/* Return error if can't get file system info */
X	if (bombed (statfilesys (location, &fsys)))
X		return (DFREE_ERR);
X
X	/* If able to test if free inodes then do so */
X#if defined(filfree) && defined(MINFILES)
X	if (filfree (fsys) < MINFILES )
X 		return (DFREE_INODES);
X#endif
X
X	/* Test if blocks are available */
X	if (blkavail (fsys) < free_space)
X		return (DFREE_BLOCKS);
X
X	return (DFREE_OK);
X	}
X
X
X/*
X * space - Returns 1 if there are a sufficient number of free blocks
X * and inodes on the filesystem containing the news spool, or 0 if
X * there are only a small number of blocks / inodes remaining.
X */
X
X	int
Xspace (int min_free)
X	{
X	switch (dfree (SPOOLDIR, min_free))
X		{
X		case DFREE_OK:
X			return (1);
X		case DFREE_ERR:
X			log_ret ("space: dfree failed due to system call error");
X			break;
X		case DFREE_INODES:
X			log_msg ("space: no inodes on %s", SPOOLDIR);
X			break;
X		case DFREE_BLOCKS:
X			log_msg ("space: no space on %s", SPOOLDIR);
X			break;
X		}
X	return (0);
X	}
X
X#endif /* MINFREE */
X
X/* END-OF-FILE */
END_OF_FILE
  if test 5486 -ne `wc -c <'space.c'`; then
    echo shar: \"'space.c'\" unpacked with wrong size!
  fi
  # end of 'space.c'
fi
echo shar: End of archive 2 \(of 3\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
