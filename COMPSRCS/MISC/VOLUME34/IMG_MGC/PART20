Newsgroups: comp.sources.misc
From: cristy@eplrx7.es.duPont.com (John Cristy)
Subject:  v34i048:  imagemagick - X11 image processing and display v2.2, Part20/26
Message-ID: <1992Dec15.035718.22788@sparky.imd.sterling.com>
X-Md4-Signature: 94c5d01e0c7dfba326e7e77563889187
Date: Tue, 15 Dec 1992 03:57:18 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: cristy@eplrx7.es.duPont.com (John Cristy)
Posting-number: Volume 34, Issue 48
Archive-name: imagemagick/part20
Environment: UNIX, VMS, X11, SGI, DEC, Cray, Sun, Vax

#!/bin/sh
# this is Part.20 (part 20 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file ImageMagick/montage.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 20; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping ImageMagick/montage.c'
else
echo 'x - continuing file ImageMagick/montage.c'
sed 's/^X//' << 'SHAR_EOF' >> 'ImageMagick/montage.c' &&
X    if (display)
X      {
X        /*
X          Copy tile label to the composite image.
X        */
X        (void) strcpy(annotate_info.text,image->label);
X        annotate_info.width=XTextWidth(image_window.font_info,
X          annotate_info.text,strlen(annotate_info.text));
X        if (annotate_info.width > (tile_width+border_width*2))
X          {
X            /*
X              Label is too wide-- shorten.
X            */
X            q=annotate_info.text+strlen(annotate_info.text);
X            do
X            {
X              *--q='\0';
X              if ((int) strlen(annotate_info.text) > 2)
X                (void) strcpy(q-2,"...");
X              annotate_info.width=XTextWidth(image_window.font_info,
X                annotate_info.text,strlen(annotate_info.text));
X            } while (annotate_info.width > (tile_width+border_width*2));
X          }
X        (void) sprintf(annotate_info.geometry,"%ux%u%+d%+d\0",
X          annotate_info.width,annotate_info.height,x_offset+
X          ((tile_width+border_width*2) >> 1)-(annotate_info.width >> 1),
X          y_offset+y+(int) image->rows+tile_border_height+2);
X        (void) XAnnotateImage(display,&image_window,&annotate_info,True,
X          montage_image);
X      }
X    DestroyImage(image);
X    if (((tile+1) % tiles_per_row) != 0)
X      x_offset+=tile_width+(tile_border_width+border_width)*2;
X    else
X      {
X        x_offset=tile_border_width;
X        y_offset+=tile_height+(tile_border_height+border_width)*2+
X          (annotate_info.height+4);
X      }
X  }
X  (void) free((char *) annotate_info.text);
X  if (display)
X    {
X      /*
X        Free X resources.
X      */
X      XFreeFont(display,image_window.font_info);
X      XFree((void *) image_window.visual_info);
X    }
X  return(montage_image);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   U s a g e                                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function Usage displays the program command syntax.
%
%  The format of the Usage routine is:
%
%      Usage()
%
%
*/
static void Usage()
{
X  char
X    **p;
X
X  static char
X    *options[]=
X    {
X      "-aspect_ratio         respect aspect ratio of the image",
X      "-clip geometry        preferred size and location of the clipped image",
X      "-colors value         preferred number of colors in the image",
X      "-colorspace type      GRAY, RGB, XYZ, YIQ, or YUV",
X      "-compose operator     composite operator",
X      "-compress type        RunlengthEncoded or QEncoded",
X      "-density geometry     vertical and horizonal density of the image",
X      "-display server       query font from this X server",
X      "-dither               apply Floyd/Steinberg error diffusion to image",
X      "-gamma value          level of gamma correction",
X      "-geometry geometry    preferred tile and border sizes",
X      "-gravity direction    which direction to gravitate towards",
X      "-monochrome           transform image to black and white",
X      "-rotate degrees       apply Paeth rotation to the image",
X      "-tiles_per_row value  number of image tiles per row",
X      "-treedepth value      depth of the color classification tree",
X      "-verbose              print detailed information about the image",
X      (char *) NULL
X    };
X  (void) fprintf(stderr,
X    "Usage: %s [-options ...] file [ [-options ...] file ...] file\n",
X    application_name);
X  (void) fprintf(stderr,"\nWhere options include: \n");
X  for (p=options; *p != (char *) NULL; p++)
X    (void) fprintf(stderr,"  %s\n",*p);
X  (void) fprintf(stderr,
X    "\nIn addition to those listed above, you can specify these standard X\n");
X  (void) fprintf(stderr,
X    "resources as command line options:  -background, -bordercolor,\n");
X  (void) fprintf(stderr,
X    "-borderwidth, -font, -foreground, or -title\n");
X  (void) fprintf(stderr,
X    "\nChange '-' to '+' in any option above to reverse its effect.  For\n");
X  (void) fprintf(stderr,
X    "example, specify +aspect_ratio to ignore the aspect ratio of an image.\n");
X  (void) fprintf(stderr,
X    "\nBy default, the image format of `file' is determined by its magic\n");
X  (void) fprintf(stderr,
X    "number.  To specify a particular image format, precede the filename\n");
X  (void) fprintf(stderr,
X    "with an image format name and a colon (i.e. mtv:image) or specify the\n");
X  (void) fprintf(stderr,
X    "image type as the filename suffix (i.e. image.mtv).  Specify 'file' as\n");
X  (void) fprintf(stderr,"'-' for standard input or output.\n");
X  exit(1);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%    M a i n                                                                  %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
*/
int main(argc,argv)
int
X  argc;
X
char
X  **argv;
{
X  AlienInfo
X    alien_info;
X
X  char
X    *clip_geometry,
X    *option,
X    *server_name,
X    *write_filename;
X
X  Display
X    *display;
X
X  double
X    gamma;
X
X  Image
X    **images,
X    *montage_image;
X
X  int
X    degrees,
X    i,
X    x;
X
X  time_t
X    start_time;
X
X  unsigned int
X    aspect_ratio,
X    compose,
X    compression,
X    display_image,
X    image_number,
X    maximum_images,
X    tiles_per_row,
X    verbose;
X
X  XrmDatabase
X    resource_database;
X
X  XResourceInfo
X    resource_info;
X
X  /*
X    Display usage profile if there are no command line arguments.
X  */
X  application_name=(*argv);
X  if (argc < 3)
X    Usage();
X  /*
X    Set defaults.
X  */
X  GetAlienInfo(&alien_info);
X  aspect_ratio=True;
X  clip_geometry=(char *) NULL;
X  compose=ReplaceCompositeOp;
X  compression=UndefinedCompression;
X  degrees=0;
X  display=(Display *) NULL;
X  display_image=True;
X  gamma=0.0;
X  resource_database=(XrmDatabase) NULL;
X  resource_info.border_width=0;
X  resource_info.colorspace=RGBColorspace;
X  resource_info.dither=False;
X  resource_info.image_geometry=(char *) NULL;
X  resource_info.monochrome=False;
X  resource_info.number_colors=0;
X  resource_info.tree_depth=0;
X  server_name=(char *) NULL;
X  tiles_per_row=0;
X  verbose=False;
X  maximum_images=2048;
X  images=(Image **) malloc(maximum_images*sizeof(Image *));
X  if (images == (Image **) NULL)
X    Error("unable to montage images","memory allocation failed");
X  /*
X    Check for server name specified on the command line.
X  */
X  for (i=1; i < argc; i++)
X  {
X    /*
X      Check command line for server name.
X    */
X    option=argv[i];
X    if (((int) strlen(option) > 1) && ((*option == '-') || (*option == '+')))
X      if (strncmp("display",option+1,3) == 0)
X        {
X          /*
X            User specified server name.
X          */
X          display_image=(*option == '-');
X          if (display_image)
X            {
X              i++;
X              if (i == argc)
X                Error("missing server name on -display",(char *) NULL);
X              server_name=argv[i];
X            }
X          break;
X        }
X  }
X  if (display_image)
X    {
X      char
X        *resource_value;
X
X      XrmDatabase
X        server_database;
X
X      /*
X        Open X server connection.
X      */
X      display=XOpenDisplay(server_name);
X      if (display == (Display *) NULL)
X        Error("unable to connect to X server",XDisplayName(server_name));
X      /*
X        Set our forgiving error handler.
X      */
X      XSetErrorHandler(XError);
X      /*
X        Initialize resource database.
X      */
X      XrmInitialize();
X      resource_database=XrmGetDatabase(display);
X      resource_value=XResourceManagerString(display);
X      if (resource_value == (char *) NULL)
X        resource_value="";
X      server_database=XrmGetStringDatabase(resource_value);
X      XrmMergeDatabases(server_database,&resource_database);
X      /*
X        Get user defaults from X resource database.
X      */
X      XGetResourceInfo(resource_database,application_name,&resource_info);
X      resource_value=XGetResource(resource_database,application_name,
X        "aspect_ratio",(char *) NULL,"True");
X      aspect_ratio=IsTrue(resource_value);
X      clip_geometry=XGetResource(resource_database,application_name,
X        "clipGeometry","ClipGeometry",(char *) NULL);
X      resource_value=XGetResource(resource_database,application_name,
X        "compression",(char *) NULL,"RunlengthEncoded");
X      if (Latin1Compare("qencoded",resource_value) == 0)
X        compression=QEncodedCompression;
X      else
X        compression=RunlengthEncodedCompression;
X      resource_value=XGetResource(resource_database,application_name,"gamma",
X        (char *) NULL,"0.0");
X      gamma=atof(resource_value);
X      resource_value=XGetResource(resource_database,application_name,"rotate",
X        (char *) NULL,"0");
X      degrees=atoi(resource_value);
X      resource_value=XGetResource(resource_database,application_name,
X        "tiles_per_row","TilesPerRow","0");
X      tiles_per_row=atoi(resource_value);
X      resource_value=XGetResource(resource_database,application_name,"verbose",
X        (char *) NULL,"False");
X      verbose=IsTrue(resource_value);
X    }
X  /*
X    Composite image is the last item on the command line.
X  */
X  write_filename=argv[argc-1];
X  if (access(write_filename,0) == 0)
X    {
X      char
X        answer[2];
X
X      (void) fprintf(stderr,"Overwrite %s? ",write_filename);
X      (void) gets(answer);
X      if (!((*answer == 'y') || (*answer == 'Y')))
X        exit(1);
X    }
X  /*
X    Parse command line.
X  */
X  image_number=0;
X  for (i=1; i < (argc-1); i++)
X  {
X    option=argv[i];
X    if (((int) strlen(option) > 1) && ((*option == '-') || (*option == '+')))
X      switch (*(option+1))
X      {
X        case 'a':
X        {
X          aspect_ratio=(*option == '-');
X          break;
X        }
X        case 'b':
X        {
X          if (strncmp("background",option+1,5) == 0)
X            {
X              resource_info.background_color=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing color on -background",(char *) NULL);
X                  resource_info.background_color=argv[i];
X                }
X              break;
X            }
X          if (strncmp("bordercolor",option+1,7) == 0)
X            {
X              resource_info.border_color=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing color on -bordercolor",(char *) NULL);
X                  resource_info.border_color=argv[i];
X                }
X              break;
X            }
X          if (strncmp("borderwidth",option+1,7) == 0)
X            {
X              resource_info.border_width=0;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                    Error("missing width on -borderwidth",(char *) NULL);
X                  resource_info.border_width=atoi(argv[i]);
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'c':
X        {
X          if (strncmp("clip",option+1,2) == 0)
X            {
X              clip_geometry=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing geometry on -clip",(char *) NULL);
X                  clip_geometry=argv[i];
X                }
X              break;
X            }
X          if (strncmp("colors",option+1,7) == 0)
X            {
X              resource_info.number_colors=0;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                    Error("missing colors on -colors",(char *) NULL);
X                  resource_info.number_colors=atoi(argv[i]);
X                }
X              break;
X            }
X          if (strncmp("colorspace",option+1,7) == 0)
X            {
X              resource_info.colorspace=RGBColorspace;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing type on -colorspace",(char *) NULL);
X                  option=argv[i];
X                  resource_info.colorspace=UndefinedColorspace;
X                  if (Latin1Compare("gray",option) == 0)
X                    resource_info.colorspace=GRAYColorspace;
X                  if (Latin1Compare("rgb",option) == 0)
X                    resource_info.colorspace=RGBColorspace;
X                  if (Latin1Compare("yiq",option) == 0)
X                    resource_info.colorspace=YIQColorspace;
X                  if (Latin1Compare("yuv",option) == 0)
X                    resource_info.colorspace=YUVColorspace;
X                  if (Latin1Compare("xyz",option) == 0)
X                    resource_info.colorspace=XYZColorspace;
X                  if (resource_info.colorspace == UndefinedColorspace)
X                    Error("invalid colorspace type on -colorspace",option);
X                }
X              break;
X            }
X          if (strncmp("compress",option+1,5) == 0)
X            {
X              compression=NoCompression;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing type on -compress",(char *) NULL);
X                  option=argv[i];
X                  if (Latin1Compare("runlengthencoded",option) == 0)
X                    compression=RunlengthEncodedCompression;
X                  else
X                    if (Latin1Compare("qencoded",option) == 0)
X                      compression=QEncodedCompression;
X                    else
X                      Error("invalid compression type on -compress",option);
X                }
X              break;
X            }
X          if (strncmp("compose",option+1,5) == 0)
X            {
X              compose=ReplaceCompositeOp;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing type on -compose",(char *) NULL);
X                  option=argv[i];
X                  compose=UndefinedCompositeOp;
X                  if (Latin1Compare("over",option) == 0)
X                    compose=OverCompositeOp;
X                  if (Latin1Compare("in",option) == 0)
X                    compose=InCompositeOp;
X                  if (Latin1Compare("out",option) == 0)
X                    compose=OutCompositeOp;
X                  if (Latin1Compare("atop",option) == 0)
X                    compose=AtopCompositeOp;
X                  if (Latin1Compare("xor",option) == 0)
X                    compose=XorCompositeOp;
X                  if (Latin1Compare("plus",option) == 0)
X                    compose=PlusCompositeOp;
X                  if (Latin1Compare("minus",option) == 0)
X                    compose=MinusCompositeOp;
X                  if (Latin1Compare("add",option) == 0)
X                    compose=AddCompositeOp;
X                  if (Latin1Compare("subtract",option) == 0)
X                    compose=SubtractCompositeOp;
X                  if (Latin1Compare("difference",option) == 0)
X                    compose=DifferenceCompositeOp;
X                  if (Latin1Compare("replace",option) == 0)
X                    compose=ReplaceCompositeOp;
X                  if (compose == UndefinedCompositeOp)
X                    Error("invalid compose type on -compose",option);
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'd':
X        {
X          if (strncmp("density",option+1,3) == 0)
X            {
X              alien_info.density=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing density on -density",(char *) NULL);
X                  alien_info.density=argv[i];
X                }
X              break;
X            }
X          if (strncmp("display",option+1,3) == 0)
X            {
X              server_name=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing server name on -display",(char *) NULL);
X                  server_name=argv[i];
X                }
X              alien_info.server_name=server_name;
X              break;
X            }
X          if (strncmp("dither",option+1,3) == 0)
X            {
X              resource_info.dither=(*option == '-');
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'f':
X        {
X          if (strncmp("font",option+1,3) == 0)
X            {
X              resource_info.font=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing font name on -font",(char *) NULL);
X                  resource_info.font=argv[i];
X                }
X              alien_info.font=resource_info.font;
X              break;
X            }
X          if (strncmp("foreground",option+1,3) == 0)
X            {
X              resource_info.foreground_color=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing foreground on -foreground",(char *) NULL);
X                  resource_info.foreground_color=argv[i];
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'g':
X        {
X          if (strncmp("gamma",option+1,2) == 0)
X            {
X              gamma=0.0;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%f",(float *) &x))
X                    Error("missing gamma on -gamma",(char *) NULL);
X                  gamma=atof(argv[i]);
X                }
X              break;
X            }
X          if (strncmp("geometry",option+1,2) == 0)
X            {
X              resource_info.image_geometry=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing geometry on -geometry",(char *) NULL);
X                  resource_info.image_geometry=argv[i];
X                }
X              break;
X            }
X          if (strncmp("gravity",option+1,2) == 0)
X            {
X              resource_info.gravity=CenterGravity;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing type on -gravity",(char *) NULL);
X                  option=argv[i];
X                  resource_info.gravity=(-1);
X                  if (Latin1Compare("Forget",option) == 0)
X                    resource_info.gravity=ForgetGravity;
X                  if (Latin1Compare("NorthWest",option) == 0)
X                    resource_info.gravity=NorthWestGravity;
X                  if (Latin1Compare("North",option) == 0)
X                    resource_info.gravity=NorthGravity;
X                  if (Latin1Compare("NorthEast",option) == 0)
X                    resource_info.gravity=NorthEastGravity;
X                  if (Latin1Compare("West",option) == 0)
X                    resource_info.gravity=WestGravity;
X                  if (Latin1Compare("Center",option) == 0)
X                    resource_info.gravity=CenterGravity;
X                  if (Latin1Compare("East",option) == 0)
X                    resource_info.gravity=EastGravity;
X                  if (Latin1Compare("SouthWest",option) == 0)
X                    resource_info.gravity=SouthWestGravity;
X                  if (Latin1Compare("South",option) == 0)
X                    resource_info.gravity=SouthGravity;
X                  if (Latin1Compare("SouthEast",option) == 0)
X                    resource_info.gravity=SouthEastGravity;
X                  if (Latin1Compare("Static",option) == 0)
X                    resource_info.gravity=StaticGravity;
X                  if (resource_info.gravity == (-1))
X                    Error("invalid gravity type on -gravity",option);
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'h':
X        {
X          Usage();
X          break;
X        }
X        case 'm':
X        {
X          resource_info.monochrome=(*option == '-');
X          break;
X        }
X        case 'r':
X        {
X          degrees=0;
X          if (*option == '-')
X            {
X              i++;
X              if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                Error("missing degrees on -rotate",(char *) NULL);
X              degrees=atoi(argv[i]);
X            }
X          break;
X        }
X        case 't':
X        {
X          if (strncmp("tiles_per_row",option+1,3) == 0)
X            {
X              tiles_per_row=0;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                    Error("missing value on -tiles_per_row",(char *) NULL);
X                  tiles_per_row=atoi(argv[i]);
X                }
X              break;
X            }
X          if (strncmp("title",option+1,3) == 0)
X            {
X              resource_info.title=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing title on -title",(char *) NULL);
X                  resource_info.title=argv[i];
X                }
X              break;
X            }
X          if (strncmp("treedepth",option+1,2) == 0)
X            {
X              resource_info.tree_depth=0;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                    Error("missing depth on -treedepth",(char *) NULL);
X                  resource_info.tree_depth=atoi(argv[i]);
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'v':
X        {
X          verbose=(*option == '-');
X          alien_info.verbose=verbose;
X          break;
X        }
X        default:
X        {
X          Error("unrecognized option",option);
X          break;
X        }
X      }
X    else
X      {
X        char
X          geometry[2048];
X
X        Image
X          *image,
X          info_image;
X
X        unsigned int
X          scale_factor,
X          tile_height,
X          tile_width;
X
X        /*
X          Option is a file name: begin by reading image from specified file.
X        */
X        start_time=time((time_t *) 0);
X        (void) strcpy(alien_info.filename,option);
X        image=ReadAlienImage(&alien_info);
X        if (image == (Image *) NULL)
X          if (*option == '-')
X            break;
X          else
X            continue;
X        do
X        {
X          if (image->scene == 0)
X            image->scene=image_number;
X          info_image=(*image);
X          /*
X            Allocate and initialize image label.
X          */
X          image->label=(char *)
X            malloc(((strlen(image->filename)+2048)*sizeof(char)));
X          if (image->label == (char *) NULL)
X            Error("unable to montage images","memory allocation failed");
X          (void) sprintf(image->label,"%s %ux%u\0",image->filename,
X            image->columns,image->rows);
X          /*
X            Tile size maintains the aspect ratio of the image.
X          */
X          tile_width=256;
X          tile_height=256;
X          if (resource_info.image_geometry != (char *) NULL)
X            {
X              int
X                y;
X
X              XParseGeometry(resource_info.image_geometry,&x,&y,&tile_width,
X                &tile_height);
X              if ((tile_width == 0) || (tile_height == 0))
X                Error("invalid image geometry",resource_info.image_geometry);
X            }
X          if (aspect_ratio)
X            {
X              /*
X                Respect aspect ratio of the image.
X              */
X              scale_factor=UpShift(tile_width)/image->columns;
X              if (scale_factor > (UpShift(tile_height)/image->rows))
X                scale_factor=UpShift(tile_height)/image->rows;
X              tile_width=DownShift(image->columns*scale_factor);
X              tile_height=DownShift(image->rows*scale_factor);
X            }
X          (void) sprintf(geometry,"%ux%u\0",tile_width,tile_height);
X          TransformImage(&image,clip_geometry,geometry,(char *) NULL);
X          if ((degrees % 360) != 0)
X            {
X              Image
X                *rotated_image;
X
X              /*
X                Rotate image.
X              */
X              rotated_image=RotateImage(image,(double) degrees,False);
X              if (rotated_image != (Image *) NULL)
X                {
X                  DestroyImage(image);
X                  image=rotated_image;
X                }
X            }
X          if (gamma > 0.0)
X            GammaImage(image,gamma);
X          if (verbose)
X            {
X              /*
X                Display detailed info about the image.
X              */
X              (void) fprintf(stderr,"[%u] %s",
X                image->scene == 0 ? image_number : image->scene,
X                image->filename);
X              (void) fprintf(stderr," %ux%u",info_image.columns,
X                info_image.rows);
X              if ((info_image.columns != image->columns) ||
X                  (info_image.rows != image->rows))
X                (void) fprintf(stderr,"=>%ux%u",image->columns,image->rows);
X              if (image->class == DirectClass)
X                (void) fprintf(stderr," DirectClass");
X              else
X                (void) fprintf(stderr," PseudoClass %uc",image->colors);
X              (void) fprintf(stderr," %s\n",image->magick);
X            }
X          /*
X            Pack image data to conserve memory (memory <=> speed).
X          */
X          (void) PackImage(image);
X          (void) free((char *) image->pixels);
X          image->pixels=(RunlengthPacket *) NULL;
X          if (image_number == maximum_images)
X            {
X              /*
X                Increase size of images array.
X              */
X              maximum_images<<=1;
X              images=(Image **)
X                realloc((char *) images,maximum_images*sizeof(Image *));
X              if (images == (Image **) NULL)
X                Error("unable to montage images","memory allocation failed");
X            }
X          images[image_number++]=image;
X          image=image->next;
X        } while (image != (Image *) NULL);
X      }
X    }
X  if (image_number == 0)
X    Error("missing an image file name",(char *) NULL);
X  /*
X    Create composite image.
X  */
X  montage_image=MontageImage(display,&resource_info,compose,tiles_per_row,
X    images,image_number);
X  if (resource_info.colorspace == GRAYColorspace)
X    QuantizeImage(montage_image,256,8,resource_info.dither,GRAYColorspace,True);
X  if (resource_info.monochrome)
X    QuantizeImage(montage_image,2,8,resource_info.dither,GRAYColorspace,True);
X  if (resource_info.number_colors > 0)
X    QuantizeImage(montage_image,resource_info.number_colors,
X      resource_info.tree_depth,resource_info.dither,resource_info.colorspace,
X      True);
X  if (compression != UndefinedCompression)
X    montage_image->compression=compression;
X  strcpy(montage_image->filename,write_filename);
X  (void) WriteAlienImage(montage_image);
X  if (verbose)
X    {
X      /*
X        Display detailed info about the image.
X      */
X      if (montage_image->class == DirectClass)
X        montage_image->colors=NumberColors(montage_image);
X      (void) fprintf(stderr,"[%u] %s %ux%u",montage_image->scene,
X        montage_image->filename,montage_image->columns,montage_image->rows);
X      if (montage_image->class == DirectClass)
X        (void) fprintf(stderr," DirectClass ");
X      else
X        (void) fprintf(stderr," PseudoClass ");
X      (void) fprintf(stderr,"%uc %s %lds\n",montage_image->colors,
X        montage_image->magick,time((time_t *) 0)-start_time+1);
X    }
X  DestroyImage(montage_image);
X  (void) free((char *) images);
X  if (display != (Display *) NULL)
X    XCloseDisplay(display);
X  return(False);
}
SHAR_EOF
echo 'File ImageMagick/montage.c is complete' &&
chmod 0644 ImageMagick/montage.c ||
echo 'restore of ImageMagick/montage.c failed'
Wc_c="`wc -c < 'ImageMagick/montage.c'`"
test 49738 -eq "$Wc_c" ||
	echo 'ImageMagick/montage.c: original size 49738, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/alien.c ==============
if test -f 'ImageMagick/alien.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/alien.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/alien.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/alien.c' &&
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%                        AAA   L      IIIII EEEEE  N   N                      %
%                       A   A  L        I   E      NN  N                      %
%                       AAAAA  L        I   EEE    N N N                      %
%                       A   A  L        I   E      N  NN                      %
%                       A   A  LLLLL  IIIII EEEEE  N   N                      %
%                                                                             %
%                                                                             %
%                  Utility Routines to Read Alien Image Formats               %
%                                                                             %
%                                                                             %
%                                                                             %
%                             Software Design                                 %
%                               John Cristy                                   %
%                              January 1992                                   %
%                                                                             %
%                                                                             %
%  Copyright 1992 E. I. du Pont de Nemours & Company                          %
%                                                                             %
%  Permission to use, copy, modify, distribute, and sell this software and    %
%  its documentation for any purpose is hereby granted without fee,           %
%  provided that the above Copyright notice appear in all copies and that     %
%  both that Copyright notice and this permission notice appear in            %
%  supporting documentation, and that the name of E. I. du Pont de Nemours    %
%  & Company not be used in advertising or publicity pertaining to            %
%  distribution of the software without specific, written prior               %
%  permission.  E. I. du Pont de Nemours & Company makes no representations   %
%  about the suitability of this software for any purpose.  It is provided    %
%  "as is" without express or implied warranty.                               %
%                                                                             %
%  E. I. du Pont de Nemours & Company disclaims all warranties with regard    %
%  to this software, including all implied warranties of merchantability      %
%  and fitness, in no event shall E. I. du Pont de Nemours & Company be       %
%  liable for any special, indirect or consequential damages or any           %
%  damages whatsoever resulting from loss of use, data or profits, whether    %
%  in an action of contract, negligence or other tortious action, arising     %
%  out of or in connection with the use or performance of this software.      %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Functions in this library convert to and from `alien' image formats to the
%  MIFF image format.
%
%
*/
X
/*
X  Include declarations.
*/
#include "display.h"
#include "image.h"
#include "alien.h"
#include "compress.h"
#include "X.h"
X
/*
X  Global declarations.
*/
static char
X  *AlienTypes[]=
X  {
X    "AVS",
X    "CMYK",
X    "FAX",
X    "GIF",
X    "GRAY",
X    "JPEG",
X    "JPG",
X    "MIFF",
X    "MTV",
X    "PNM",
X    "PS",
X    "RGB",
X    "RLE",
X    "SUN",
X    "TEXT",
X    "TIFF",
X    "VICAR",
X    "YUV",
X    "X",
X    "XC",
X    "XBM",
X    "XWD",
X    (char *) NULL,
X  };
X
/*
X  External declarations.
*/
extern char
X  *application_name;
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  M S B F i r s t O r d e r L o n g                                          %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function MSBFirstOrderLong converts a least-significant byte first buffer
%  of long integers to most-significant byte first.
%
%  The format of the MSBFirstOrderLong routine is:
%
%       MSBFirstOrderLong(p,length);
%
%  A description of each parameter follows.
%
%   o  p:  Specifies a pointer to a buffer of integers.
%
%   o  length:  Specifies the length of the buffer.
%
%
*/
static void MSBFirstOrderLong(p,length)
register char
X  *p;
X
register unsigned
X  length;
{
X  register char
X    c,
X    *q,
X    *sp;
X
X  q=p+length;
X  while (p < q)
X  {
X    sp=p+3;
X    c=(*sp);
X    *sp=(*p);
X    *p++=c;
X    sp=p+1;
X    c=(*sp);
X    *sp=(*p);
X    *p++=c;
X    p+=2;
X  }
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  M S B F i r s t O r d e r S h o r t                                        %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function MSBFirstOrderShort converts a least-significant byte first buffer
%  of short integers to most-significant byte first.
%
%  The format of the MSBFirstOrderShort routine is:
%
%       MSBFirstOrderLongShort(p,length);
%
%  A description of each parameter follows.
%
%   o  p:  Specifies a pointer to a buffer of integers.
%
%   o  length:  Specifies the length of the buffer.
%
%
*/
static void MSBFirstOrderShort(p,length)
register char
X  *p;
X
register unsigned
X  length;
{
X  register char
X    c,
X    *q;
X
X  q=p+length;
X  while (p < q)
X  {
X    c=(*p);
X    *p=(*(p+1));
X    p++;
X    *p++=c;
X  }
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  R e a d A V S I m a g e                                                    %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function ReadAVSImage reads an image file and returns it.  It allocates the
%  memory necessary for the new Image structure and returns a pointer to the
%  new image.
%
%  The format of the ReadAVSImage routine is:
%
%      image=ReadAVSImage(alien_info)
%
%  A description of each parameter follows:
%
%    o image:  Function ReadAVSImage returns a pointer to the image after
%      reading. A null image is returned if there is a a memory shortage or if
%      the image cannot be read.
%
%    o alien_info: Specifies a pointer to an AlienInfo structure.
%
%
*/
static Image *ReadAVSImage(alien_info)
AlienInfo
X  *alien_info;
{
X  typedef struct _Rasterfile
X  {
X    int
X      width,
X      height;
X  } Rasterfile;
X
X  Image
X    *image;
X
X  Rasterfile
X    avs_header;
X
X  register int
X    i;
X
X  register unsigned char
X    *p;
X
X  register RunlengthPacket
X    *q;
X
X  unsigned char
X    *avs_pixels;
X
X  unsigned int
X    status;
X
X  /*
X    Allocate image structure.
X  */
X  image=AllocateImage("AVS");
X  if (image == (Image *) NULL)
X    return((Image *) NULL);
X  /*
X    Open image file.
X  */
X  (void) strcpy(image->filename,alien_info->filename);
X  OpenImage(image,"r");
X  if (image->file == (FILE *) NULL)
X    {
X      Warning("unable to open file",image->filename);
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  /*
X    Read AVS image.
X  */
X  status=ReadData((char *) &avs_header,1,sizeof(Rasterfile),image->file);
X  if (status == False)
X    {
X      Warning("not a AVS image file",(char *) NULL);
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  do
X  {
X    avs_pixels=(unsigned char *)
X      malloc(4*avs_header.width*avs_header.height*sizeof(unsigned char));
X    if (avs_pixels == (unsigned char *) NULL)
X      {
X        Warning("memory allocation error",(char *) NULL);
X        DestroyImages(image);
X        return((Image *) NULL);
X      }
X    (void) ReadData((char *) avs_pixels,sizeof(unsigned char),
X      avs_header.width*avs_header.height*4,image->file);
X    /*
X      Create image.
X    */
X    image->alpha=True;
X    image->columns=avs_header.width;
X    image->rows=avs_header.height;
X    image->packets=image->columns*image->rows;
X    image->pixels=(RunlengthPacket *)
X      malloc((unsigned int) image->packets*sizeof(RunlengthPacket));
X    image->comments=(char *)
X      malloc((strlen(image->filename)+2048)*sizeof(char));
X    if ((image->pixels == (RunlengthPacket *) NULL) ||
X        (image->comments == (char *) NULL))
X      {
X        Warning("memory allocation error",(char *) NULL);
X        DestroyImages(image);
X        return((Image *) NULL);
X      }
X    (void) sprintf(image->comments,"\n  Imported from AVS raster image:  %s\n",
X      image->filename);
X    /*
X      Convert AVS raster image to runlength-encoded packets.
X    */
X    p=avs_pixels;
X    q=image->pixels;
X    for (i=0; i < (image->columns*image->rows); i++)
X    {
X      q->index=(unsigned char) (*p++);
X      q->red=(*p++);
X      q->green=(*p++);
X      q->blue=(*p++);
X      q->length=0;
X      q++;
X    }
X    (void) free((char *) avs_pixels);
X    status=ReadData((char *) &avs_header,1,sizeof(Rasterfile),image->file);
X    if (status == True)
X      {
X        /*
X          Allocate image structure.
X        */
X        image->next=AllocateImage("AVS");
X        if (image->next == (Image *) NULL)
X          {
X            DestroyImages(image);
X            return((Image *) NULL);
X          }
X        image->next->file=image->file;
X        (void) sprintf(image->next->filename,"%s.%u\0",alien_info->filename,
X          image->scene+1);
X        image->next->scene=image->scene+1;
X        image->next->last=image;
X        image=image->next;
X      }
X  } while (status == True);
X  while (image->last != (Image *) NULL)
X    image=image->last;
X  CloseImage(image);
X  return(image);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  R e a d C M Y K I m a g e                                                  %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function ReadCMYKImage reads an image file and returns it.  It allocates the
%  memory necessary for the new Image structure and returns a pointer to the
%  new image.
%
%  The format of the ReadCMYKImage routine is:
%
%      image=ReadCMYKImage(alien_info)
%
%  A description of each parameter follows:
%
%    o image:  Function ReadCMYKImage returns a pointer to the image after
%      reading.  A null image is returned if there is a a memory shortage or
%      if the image cannot be read.
%
%    o alien_info: Specifies a pointer to an AlienInfo structure.
%
%
*/
static Image *ReadCMYKImage(alien_info)
AlienInfo
X  *alien_info;
{
X  Image
X    *image;
X
X  int
X    x,
X    y;
X
X  register int
X    i;
X
X  register RunlengthPacket
X    *q;
X
X  register unsigned char
X    *p;
X
X  unsigned char
X    black,
X    *cmyk_pixels,
X    cyan,
X    magenta,
X    yellow;
X
X  unsigned int
X    height,
X    width;
X
X  /*
X    Allocate image structure.
X  */
X  image=AllocateImage("CMYK");
X  if (image == (Image *) NULL)
X    return((Image *) NULL);
X  /*
X    Open image file.
X  */
X  (void) strcpy(image->filename,alien_info->filename);
X  OpenImage(image,"r");
X  if (image->file == (FILE *) NULL)
X    {
X      Warning("unable to open file",image->filename);
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  /*
X    Create image.
X  */
X  width=512;
X  height=512;
X  if (alien_info->geometry != (char *) NULL)
X    (void) XParseGeometry(alien_info->geometry,&x,&y,&width,&height);
X  image->columns=width;
X  image->rows=height;
X  image->packets=image->columns*image->rows;
X  cmyk_pixels=(unsigned char *)
X    malloc((unsigned int) image->packets*4*sizeof(unsigned char));
X  image->pixels=(RunlengthPacket *)
X    malloc((unsigned int) image->packets*sizeof(RunlengthPacket));
X  if ((cmyk_pixels == (unsigned char *) NULL) ||
X      (image->pixels == (RunlengthPacket *) NULL))
X    {
X      Warning("unable to open file",image->filename);
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  /*
X    Convert raster image to runlength-encoded packets.
X  */
X  (void) ReadData((char *) cmyk_pixels,4,(int) (image->columns*image->rows),
X    image->file);
X  p=cmyk_pixels;
X  q=image->pixels;
X  for (i=0; i < (image->columns*image->rows); i++)
X  {
X    cyan=(*p++);
X    magenta=(*p++);
X    yellow=(*p++);
X    black=(*p++);
X    if ((unsigned int) (cyan+black) > MaxRGB)
X      q->red=0;
X    else
X      q->red=MaxRGB-(cyan+black);
X    if ((unsigned int) (magenta+black) > MaxRGB)
X      q->green=0;
X    else
X      q->green=MaxRGB-(magenta+black);
X    if ((unsigned int) (yellow+black) > MaxRGB)
X      q->blue=0;
X    else
X      q->blue=MaxRGB-(yellow+black);
X    q->index=0;
X    q->length=0;
X    q++;
X  }
X  (void) free((char *) cmyk_pixels);
X  CloseImage(image);
X  return(image);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  R e a d G I F I m a g e                                                    %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function ReadGIFImage reads an image file and returns it.  It allocates the
%  memory necessary for the new Image structure and returns a pointer to the
%  new image.
%
%  The format of the ReadGIFImage routine is:
%
%      image=ReadGIFImage(alien_info)
%
%  A description of each parameter follows:
%
%    o image:  Function ReadGIFImage returns a pointer to the image after
%      reading.  A null image is returned if there is a a memory shortage or
%      an error occurs.
%
%    o alien_info: Specifies a pointer to an AlienInfo structure.
%
%
*/
static Image *ReadGIFImage(alien_info)
AlienInfo
X  *alien_info;
{
#define BitSet(byte,bit)  (((byte) & (bit)) == (bit))
#define LSBFirstOrder(x,y)  (((y) << 8) | (x))
X
X  Image
X    *image;
X
X  int
X    pass,
X    status,
X    x,
X    y;
X
X  register int
X    i;
X
X  unsigned char
X    c,
X    *colormap,
X    header[2048],
X    magick[12];
X
X  unsigned int
X    image_count,
X    interlace,
X    local_colormap;
X
X  /*
X    Allocate image structure.
X  */
X  image=AllocateImage("GIF");
X  if (image == (Image *) NULL)
X    return((Image *) NULL);
X  /*
X    Open image file.
X  */
X  (void) strcpy(image->filename,alien_info->filename);
X  OpenImage(image,"r");
X  if (image->file == (FILE *) NULL)
X    {
X      Warning("unable to open file",image->filename);
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  /*
X    Determine if this is a GIF file.
X  */
X  status=ReadData((char *) magick,1,6,image->file);
X  if ((status == False) || ((strncmp((char *) magick,"GIF87",5) != 0) &&
X      (strncmp((char *) magick,"GIF89",5) != 0)))
X    {
X      Warning("not a GIF image file",(char *) NULL);
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  /*
X    Read the screen descriptor.
X  */
X  status=ReadData((char *) header,1,7,image->file);
X  if (status == False)
X    {
X      Warning("failed to read screen descriptor",(char *) NULL );
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  image->colors=1 << ((header[4] & 0x07)+1);
X  if (BitSet(header[4],0x80))
X    {
X      unsigned char
X        *p;
X
X      /*
X        Read global colormap.
X      */
X      image->class=PseudoClass;
X      colormap=(unsigned char *) malloc(3*image->colors*sizeof(unsigned char));
X      image->colormap=(ColorPacket *) malloc(image->colors*sizeof(ColorPacket));
X      if ((colormap == (unsigned char *) NULL) ||
X          (image->colormap == (ColorPacket *) NULL))
X        {
X          Warning("unable to read image colormap","memory allocation failed");
X          DestroyImage(image);
X          return((Image *) NULL);
X        }
X      (void) ReadData((char *) colormap,1,(int) image->colors*3,image->file);
X      p=colormap;
X      for (i=0; i < image->colors; i++)
X      {
X        image->colormap[i].red=(*p++);
X        image->colormap[i].green=(*p++);
X        image->colormap[i].blue=(*p++);
X      }
X      (void) free((char *) colormap);
X    }
X  image_count=0;
X  while (1)
X  {
X    status=ReadData((char *) &c,1,1,image->file);
X    if (status == False)
X      break;
X    if (c == ';')
X      break;  /* terminator */
X    if (c == '!')
X      {
X        /*
X          GIF Extension block.
X        */
X        status=ReadData((char *) &c,1,1,image->file);
X        if (status == False)
X          {
X            Warning("unable to read extention block",(char *) NULL);
X            DestroyImage(image);
X            return((Image *) NULL);
X          }
X        if (c != 0xfe)
X          while (ReadDataBlock((char *) header,image->file) != 0);
X        else
X          while (ReadDataBlock((char *) header,image->file) != 0)
X          {
X            /*
X              Comment extension block.
X            */
X            if (image->comments != (char *) NULL)
X              image->comments=(char *) realloc((char *) image->comments,
X                (unsigned int) (strlen(image->comments)+
X                strlen((char *) header)+1));
X            else
X              {
X                image->comments=(char *)
X                  malloc((strlen((char *) header)+1)*sizeof(char));
X                *image->comments='\0';
X              }
X            if (image->comments == (char *) NULL)
X              {
X                Warning("memory allocation error",(char *) NULL);
X                DestroyImage(image);
X                return((Image *) NULL);
X              }
X            (void) strcat(image->comments,(char *) header);
X          }
X      }
X    if (c != ',')
X      continue;
X    /*
X      Read image attributes.
X    */
X    if (image_count > 0)
X      {
X        /*
X          Allocate image structure.
X        */
X        CompressColormap(image);
X        image->next=AllocateImage("GIF");
X        if (image->next == (Image *) NULL)
X          {
X            DestroyImages(image);
X            return((Image *) NULL);
X          }
X        image->next->file=image->file;
X        (void) sprintf(image->next->filename,"%s.%u\0",alien_info->filename,
X          image->scene+1);
X        image->next->scene=image->scene+1;
X        image->next->last=image;
X        image=image->next;
X      }
X    image_count++;
X    status=ReadData((char *) header,1,9,image->file);
X    if (status == False)
X      {
X        Warning("unable to read left/top/width/height",(char *) NULL);
X        DestroyImage(image);
X        return((Image *) NULL);
X      }
X    interlace=BitSet(header[8],0x40);
X    local_colormap=BitSet(header[8],0x80);
X    /*
X      Allocate image.
X    */
X    image->columns=LSBFirstOrder(header[4],header[5]);
X    image->rows=LSBFirstOrder(header[6],header[7]);
X    image->packets=image->columns*image->rows;
X    if (image->pixels != (RunlengthPacket *) NULL)
X      (void) free((char *) image->pixels);
X    image->pixels=(RunlengthPacket *)
X      malloc((unsigned int) image->packets*sizeof(RunlengthPacket));
X    if (image->pixels == (RunlengthPacket *) NULL)
X      {
X        Warning("memory allocation error",(char *) NULL);
X        DestroyImage(image);
X        return((Image *) NULL);
X      }
X    if (local_colormap)
X      {
X        unsigned char
X          *p;
X
X        /*
X          Read local colormap.
X        */
X        image->class=PseudoClass;
X        image->colors=1 << ((header[8] & 0x07)+1);
X        colormap=(unsigned char *)
X          malloc(3*image->colors*sizeof(unsigned char));
X        if (image->colormap != (ColorPacket *) NULL)
X          (void) free((char *) image->colormap);
X        image->colormap=(ColorPacket *)
X          malloc(image->colors*sizeof(ColorPacket));
X        if ((colormap == (unsigned char *) NULL) ||
X            (image->colormap == (ColorPacket *) NULL))
X          {
X            Warning("unable to read image","memory allocation failed");
X            DestroyImage(image);
X            return((Image *) NULL);
X          }
X        (void) ReadData((char *) colormap,1,(int) image->colors*3,image->file);
X        p=colormap;
X        for (i=0; i < image->colors; i++)
X        {
X          image->colormap[i].red=(*p++);
X          image->colormap[i].green=(*p++);
X          image->colormap[i].blue=(*p++);
X        }
X        (void) free((char *) colormap);
X      }
X    /*
X      Decode image.
X    */
X    status=LZWDecodeImage(image);
X    if (status == False)
X      {
X        Warning("unable to read image data",(char *) NULL);
X        DestroyImage(image);
X        return((Image *) NULL);
X      }
X    if (interlace)
X      {
X        Image
X          *interlaced_image;
X
X        register RunlengthPacket
X          *p,
X          *q;
X
X        static int
X          interlace_rate[4] = { 8, 8, 4, 2 },
X          interlace_start[4] = { 0, 4, 2, 1 };
X
X        /*
X          Interlace image.
X        */
X        interlaced_image=image;
X        image=CopyImage(interlaced_image,interlaced_image->columns,
X          interlaced_image->rows,False);
X        if (image == (Image *) NULL)
X          {
X            Warning("unable to read image","memory allocation failed");
X            DestroyImage(interlaced_image);
X            return((Image *) NULL);
X          }
X        p=interlaced_image->pixels;
X        q=image->pixels;
X        for (pass=0; pass < 4; pass++)
X        {
X          y=interlace_start[pass];
X          while (y < image->rows)
X          {
X            q=image->pixels+(y*image->columns);
X            for (x=0; x < image->columns; x++)
X              *q++=(*p++);
X            y+=interlace_rate[pass];
X          }
X        }
X        DestroyImage(interlaced_image);
X      }
X  }
X  CompressColormap(image);
X  while (image->last != (Image *) NULL)
X    image=image->last;
X  CloseImage(image);
X  return(image);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  R e a d G R A Y I m a g e                                                  %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function ReadGRAYImage reads an image file and returns it.  It allocates the
%  memory necessary for the new Image structure and returns a pointer to the
%  new image.
%
%  The format of the ReadGRAYImage routine is:
%
%      image=ReadGRAYImage(alien_info)
%
%  A description of each parameter follows:
%
%    o image:  Function ReadGRAYImage returns a pointer to the image after
%      reading.  A null image is returned if there is a a memory shortage or
%      if the image cannot be read.
%
%    o alien_info: Specifies a pointer to an AlienInfo structure.
%
%
*/
static Image *ReadGRAYImage(alien_info)
AlienInfo
X  *alien_info;
{
X  Image
X    *image;
X
X  int
X    x,
X    y;
X
X  register int
X    i;
X
X  register RunlengthPacket
X    *q;
X
X  register unsigned char
X    index,
X    *p;
X
X  unsigned char
X    *gray_pixels;
X
X  unsigned int
X    height,
X    width;
X
X  /*
X    Allocate image structure.
X  */
X  image=AllocateImage("GRAY");
X  if (image == (Image *) NULL)
X    return((Image *) NULL);
X  /*
X    Open image file.
X  */
X  (void) strcpy(image->filename,alien_info->filename);
X  OpenImage(image,"r");
X  if (image->file == (FILE *) NULL)
X    {
X      Warning("unable to open file",image->filename);
SHAR_EOF
true || echo 'restore of ImageMagick/alien.c failed'
fi
echo 'End of  part 20'
echo 'File ImageMagick/alien.c is continued in part 21'
echo 21 > _shar_seq_.tmp
exit 0
exit 0 # Just in case...
