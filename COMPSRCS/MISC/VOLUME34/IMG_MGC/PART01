Newsgroups: comp.sources.misc
From: cristy@eplrx7.es.duPont.com (John Cristy)
Subject:  v34i029:  imagemagick - X11 image processing and display v2.2, Part01/26
Message-ID: <1992Dec13.202159.7329@sparky.imd.sterling.com>
X-Md4-Signature: 551984c294828d269ac2b3f185fc6b3a
Date: Sun, 13 Dec 1992 20:21:59 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: cristy@eplrx7.es.duPont.com (John Cristy)
Posting-number: Volume 34, Issue 29
Archive-name: imagemagick/part01
Environment: UNIX, VMS, X11, SGI, DEC, Cray, Sun, Vax

#!/bin/sh
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 12/13/1992 06:16 UTC by kent@sparky.IMD.Sterling.COM
# Source directory /home/kent/mod/csm/queue/image
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   2743 -rw-r--r-- ImageMagick/Imakefile
#   3144 -rw-r--r-- ImageMagick/Makefile
#   4759 -rw-r--r-- ImageMagick/PreRvIcccm.c
#  11672 -rw-r--r-- ImageMagick/README
#  16586 -rw-r--r-- ImageMagick/XtoPS.c
#   6159 -rw-r--r-- ImageMagick/XtoPS.man
#   2589 -rw-r--r-- ImageMagick/Manifest.ps
#   9232 -rw-r--r-- ImageMagick/colors.c
#   3952 -rw-r--r-- ImageMagick/Make.com
#   1270 -rw-r--r-- ImageMagick/display.h
#  30521 -rw-r--r-- ImageMagick/display.man
#   1752 -rw-r--r-- ImageMagick/xtp/Makefile
#   1497 -rw-r--r-- ImageMagick/xtp/Imakefile
#    861 -rw-r--r-- ImageMagick/xtp/xtp.h
#   1876 -rw-r--r-- ImageMagick/xtp/README
#  36656 -rw-r--r-- ImageMagick/xtp/regular.c
#   1299 -rw-r--r-- ImageMagick/xtp/regular.h
#  41314 -rw-r--r-- ImageMagick/xtp/xtp.c
#   6431 -rw-r--r-- ImageMagick/xtp/xtp.man
#    541 -rw-r--r-- ImageMagick/xtp/get
#   5587 -rw-r--r-- ImageMagick/xtp/network.c
# 154352 -rw-r--r-- ImageMagick/image.c
#    186 -rw-r--r-- ImageMagick/scenes/Makefile
#  28655 -rw-r--r-- ImageMagick/scenes/dna.script
#    464 -rw-r--r-- ImageMagick/scenes/README
#  16580 -rw-r--r-- ImageMagick/import.c
#   5476 -rw-r--r-- ImageMagick/import.man
#    295 -rw-r--r-- ImageMagick/images/README
#  60634 -rw-r--r-- ImageMagick/quantize.c
#  29802 -rw-r--r-- ImageMagick/rotate.c
#  44946 -rw-r--r-- ImageMagick/compress.c
#   4107 -rw-r--r-- ImageMagick/image.h
# 187475 -rw-r--r-- ImageMagick/display.c
#   6075 -rw-r--r-- ImageMagick/X.h
#  15842 -rw-r--r-- ImageMagick/animate.man
# 188131 -rw-r--r-- ImageMagick/X.c
#    485 -rw-r--r-- ImageMagick/animate.h
#  72608 -rw-r--r-- ImageMagick/animate.c
#  10068 -rw-r--r-- ImageMagick/miff.man
#  49738 -rw-r--r-- ImageMagick/montage.c
# 191036 -rw-r--r-- ImageMagick/alien.c
#  17572 -rw-r--r-- ImageMagick/montage.man
#   1201 -rw-r--r-- ImageMagick/PreRvIcccm.h
#  11043 -rw-r--r-- ImageMagick/quantize.man
#    368 -rw-r--r-- ImageMagick/compress.h
#   3092 -rw-r--r-- ImageMagick/XWDFile.h
#    403 -rw-r--r-- ImageMagick/alien.h
#   5765 -rw-r--r-- ImageMagick/SYNOPSIS
#  27143 -rw-r--r-- ImageMagick/utilities/mogrify.c
#   2095 -rw-r--r-- ImageMagick/utilities/Imakefile
#   2880 -rw-r--r-- ImageMagick/utilities/Makefile
#  18313 -rw-r--r-- ImageMagick/utilities/convert.c
#   9749 -rw-r--r-- ImageMagick/utilities/mogrify.man
#   7988 -rw-r--r-- ImageMagick/utilities/convert.man
#   8742 -rw-r--r-- ImageMagick/utilities/MIFFtoSTEREO.c
#   2499 -rw-r--r-- ImageMagick/utilities/Make.com
#  17946 -rw-r--r-- ImageMagick/signature.c
#   2264 -rw-r--r-- ImageMagick/ChangeLog
#   2012 -rw-r--r-- ImageMagick/Magick.tmpl
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= ImageMagick/Imakefile ==============
if test ! -d 'ImageMagick'; then
    echo 'x - creating directory ImageMagick'
    mkdir 'ImageMagick'
fi
if test -f 'ImageMagick/Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/Imakefile' &&
#
#  Imakefile for display, animate, montage, XtoPS, and import.
#
#  Copyright 1992 E. I. du Pont de Nemours & Company
#
#  Permission to use, copy, modify, distribute, and sell this software and
#  its documentation for any purpose is hereby granted without fee,
#  provided that the above Copyright notice appear in all copies and that
#  both that Copyright notice and this permission notice appear in
#  supporting documentation, and that the name of E. I. du Pont de Nemours
#  & Company not be used in advertising or publicity pertaining to
#  distribution of the software without specific, written prior
#  permission.  E. I. du Pont de Nemours & Company makes no representations
#  about the suitability of this software for any purpose.  It is provided
#  "as is" without express or implied warranty.
#
#  E. I. du Pont de Nemours & Company disclaims all warranties with regard
#  to this software, including all implied warranties of merchantability
#  and fitness, in no event shall E. I. du Pont de Nemours & Company be
#  liable for any special, indirect or consequential damages or any
#  damages whatsoever resulting from loss of use, data or profits, whether
#  in an action of contract, negligence or other tortious action, arising
#  out of or in connection with the use or performance of this software.
#
X
#include "Magick.tmpl"
X
MagickObjects= X.o image.o rotate.o quantize.o colors.o signature.o compress.o\
X  alien.o PreRvIcccm.o
X
SRCS= display.c X.c image.c rotate.c quantize.c colors.c signature.c\
X  compress.c alien.c PreRvIcccm.c
OBJS= display.o $(MagickObjects)
AnimateObjects= animate.o $(MagickObjects)
ImportObjects= import.o $(MagickObjects)
MontageObjects= montage.o $(MagickObjects)
XXtoPSObjects= XtoPS.o $(MagickObjects)
X
PROGRAMS= display animate montage XtoPS import
X
AllTarget($(PROGRAMS))
X
ComplexProgramTarget(display)
NormalProgramTarget(animate,$(AnimateObjects), , , )
InstallProgram(animate,$(BINDIR))
InstallManPage(animate,$(MANDIR))
NormalProgramTarget(montage,$(MontageObjects), , , )
InstallProgram(montage,$(BINDIR))
InstallManPage(montage,$(MANDIR))
NormalProgramTarget(XtoPS,$(XtoPSObjects), , , )
InstallProgram(XtoPS,$(BINDIR))
InstallManPage(XtoPS,$(MANDIR))
NormalProgramTarget(import,$(ImportObjects), , , )
InstallProgram(import,$(BINDIR))
InstallManPage(import,$(MANDIR))
X
#define InstallMyManPage(file,destdir,suffix)                           @@\
install.man:: file.man                                                  @@\
X	$(INSTALL) -c $(INSTMANFLAGS) file.man $(DESTDIR)destdir/file.suffix
X
InstallMyManPage(quantize,$(MANSOURCEPATH)5,5)
InstallMyManPage(miff,$(MANSOURCEPATH)5,5)
X
#define IHaveSubdirs
X
SUBDIRS= utilities xtp
X
MakeSubdirs($(SUBDIRS))
DependSubdirs($(SUBDIRS))
SHAR_EOF
chmod 0644 ImageMagick/Imakefile ||
echo 'restore of ImageMagick/Imakefile failed'
Wc_c="`wc -c < 'ImageMagick/Imakefile'`"
test 2743 -eq "$Wc_c" ||
	echo 'ImageMagick/Imakefile: original size 2743, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/Makefile ==============
if test -f 'ImageMagick/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/Makefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/Makefile' &&
#
#  Generic makefile for display, animate, montage, XtoPS, and import for
#  computers that do not have xmkmf.
#
#  Copyright 1992 E. I. du Pont de Nemours & Company
#
#  Permission to use, copy, modify, distribute, and sell this software and
#  its documentation for any purpose is hereby granted without fee,
#  provided that the above Copyright notice appear in all copies and that
#  both that Copyright notice and this permission notice appear in
#  supporting documentation, and that the name of E. I. du Pont de Nemours
#  & Company not be used in advertising or publicity pertaining to
#  distribution of the software without specific, written prior
#  permission.  E. I. du Pont de Nemours & Company makes no representations
#  about the suitability of this software for any purpose.  It is provided
#  "as is" without express or implied warranty.
#
#  E. I. du Pont de Nemours & Company disclaims all warranties with regard
#  to this software, including all implied warranties of merchantability
#  and fitness, in no event shall E. I. du Pont de Nemours & Company be
#  liable for any special, indirect or consequential damages or any
#  damages whatsoever resulting from loss of use, data or profits, whether
#  in an action of contract, negligence or other tortious action, arising
#  out of or in connection with the use or performance of this software.
#
X
#
# Uncomment the following lines if you have the JPEG or TIFF libraries.
# See README for more details.
#
#JPEG= -DAlienJPEG
#JPEG_LIBRARIES= -Ljpeg -ljpeg
#JPEG_INCLUDES= -Ijpeg
#TIFF= -DAlienTIFF
#TIFF_LIBRARIES= -Ltiff/libtiff -ltiff
#TIFF_INCLUDES= -Itiff/libtiff
X
XXLIB= -L/usr/lib/X11R4 -lX11
X
CC= cc -O -I/usr/include/X11R4
DESTDIR= /usr/bin/X11
INSTALL = install -c
RM= /bin/rm -f
X
DEFINES= $(JPEG) $(JPEG_INCLUDES) $(TIFF) $(TIFF_INCLUDES)
SYS_LIBRARIES= $(XLIB) $(JPEG_LIBRARIES) $(TIFF_LIBRARIES) -lm
X
MagickObjects= X.o image.o rotate.o quantize.o colors.o signature.o compress.o\
X  alien.o PreRvIcccm.o
X
DisplayObjects= display.o $(MagickObjects)
AnimateObjects= animate.o $(MagickObjects)
ImportObjects= import.o $(MagickObjects)
MontageObjects= montage.o $(MagickObjects)
XXtoPSObjects= XtoPS.o $(MagickObjects)
X
PROGRAMS= display animate montage XtoPS import
X
CFLAGS= $(DEFINES)
X
all: $(PROGRAMS)
X
display: $(DisplayObjects)
X	$(RM) $@
X	$(CC) -o $@ $(DisplayObjects) $(SYS_LIBRARIES)
X
clean::
X	$(RM) display
X
install:: display
X	$(INSTALL) display $(DESTDIR)
X
animate: $(AnimateObjects)
X	$(RM) $@
X	$(CC) -o $@ $(AnimateObjects) $(SYS_LIBRARIES)
X
clean::
X	$(RM) animate
X
install:: animate
X	$(INSTALL) animate $(DESTDIR)
X
montage: $(MontageObjects)
X	$(RM) $@
X	$(CC) -o $@ $(MontageObjects) $(SYS_LIBRARIES)
X
clean::
X	$(RM) montage
X
install:: montage
X	$(INSTALL) montage $(DESTDIR)
X
XXtoPS: $(XtoPSObjects)
X	$(RM) $@
X	$(CC) -o $@ $(XtoPSObjects) $(SYS_LIBRARIES)
X
clean::
X	$(RM) XtoPS
X
install:: XtoPS
X	$(INSTALL) XtoPS $(DESTDIR)
X
import: $(ImportObjects)
X	$(RM) $@
X	$(CC) -o $@ $(ImportObjects) $(SYS_LIBRARIES)
X
clean::
X	$(RM) import
X
install:: import
X	$(INSTALL) import $(DESTDIR)
X
clean::
X	$(RM) *.ln *.bak *.o core errs ,* *~ *.a .emacs_* make.log MakeOut
SHAR_EOF
chmod 0644 ImageMagick/Makefile ||
echo 'restore of ImageMagick/Makefile failed'
Wc_c="`wc -c < 'ImageMagick/Makefile'`"
test 3144 -eq "$Wc_c" ||
	echo 'ImageMagick/Makefile: original size 3144, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/PreRvIcccm.c ==============
if test -f 'ImageMagick/PreRvIcccm.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/PreRvIcccm.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/PreRvIcccm.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/PreRvIcccm.c' &&
#include "display.h"
#include "image.h"
#include "alien.h"
#include "X.h"
X
#ifdef PRE_R5_ICCCM
/*
X  Compatibility routines for pre X11R5 ICCCM.
*/
XXrmDatabase XrmGetDatabase(display)
Display
X  *display;
{
X  return(display->db);
}
#endif
X
#ifdef PRE_R4_ICCCM
/*
X  Compatibility routines for pre X11R4 ICCCM.
*/
XXClassHint *XAllocClassHint()
{
X  return((XClassHint *) malloc(sizeof(XClassHint)));
}
X
XXIconSize *XAllocIconSize()
{
X  return((XIconSize *) malloc(sizeof(XIconSize)));
}
X
XXSizeHints *XAllocSizeHints()
{
X  return((XSizeHints *) malloc(sizeof(XSizeHints)));
}
X
Status XReconfigureWMWindow(display,window,screen_number,value_mask,values)
Display
X  *display;
X
Window
X  window;
X
int
X  screen_number;
X
unsigned int
X  value_mask;
X
XXWindowChanges
X  *values;
{
X  return(XConfigureWindow(display,window,value_mask,values));
}
X
XXStandardColormap *XAllocStandardColormap()
{
X  return((XStandardColormap *) malloc(sizeof(XStandardColormap)));
}
X
XXWMHints *XAllocWMHints()
{
X  return((XWMHints *) malloc(sizeof(XWMHints)));
}
X
Status XGetRGBColormaps(display,window,colormap,count,property)
Display
X  *display;
X
Window
X  window;
X
XXStandardColormap
X  **colormap;
X
int
X  *count;
X
Atom
X  property;
{
X  *count=1;
X  return(XGetStandardColormap(display,window,colormap,property));
}
X
Status XGetWMName(display,window,text_property)
Display
X  *display;
X
Window
X  window;
X
XXTextProperty
X  *text_property;
{
X  char
X    *window_name;
X
X  if (XFetchName(display,window,&window_name) == 0)
X    return(False);
X  text_property->value=(unsigned char *) window_name;
X  text_property->encoding=XA_STRING;
X  text_property->format=8;
X  text_property->nitems=strlen(window_name);
X  return(True);
}
X
char *XResourceManagerString(display)
Display
X  *display;
{
X  return display->xdefaults;
}
X
void XrmDestroyDatabase(database)
XXrmDatabase
X  database;
{
}
X
int XSetWMName(display,window,property)
Display
X  *display;
X
Window
X  window;
X
XXTextProperty
X  *property;
{
X  XStoreName(display,window,property->value);
}
X
int XStringListToTextProperty(argv,argc,property)
char
X  **argv;
X
int
X  argc;
X
XXTextProperty
X  *property;
{
X  register int
X    i;
X
X  register unsigned int
X    number_bytes;
X
X  XTextProperty
X     protocol;
X
X  number_bytes=0;
X  for (i=0; i < argc; i++)
X    number_bytes+=(unsigned int) ((argv[i] ? strlen(argv[i]) : 0)+1);
X  protocol.encoding=XA_STRING;
X  protocol.format=8;
X  protocol.nitems=0;
X  if (number_bytes)
X    protocol.nitems=number_bytes-1;
X  protocol.value=NULL;
X  if (number_bytes <= 0)
X    {
X      protocol.value=(unsigned char *) malloc(sizeof(char));
X      if (!protocol.value)
X        return(False);
X      *protocol.value='\0';
X    }
X  else
X    {
X      register char
X        *buffer;
X
X      buffer=(char *) malloc(number_bytes*sizeof(char));
X      if (buffer == (char *) NULL)
X        return(False);
X      protocol.value=(unsigned char *) buffer;
X      for (i=0; i < argc; i++)
X      {
X        char
X          *argument;
X
X        argument=argv[i];
X        if (!argument)
X          *buffer++='\0';
X        else
X          {
X            (void) strcpy(buffer,argument);
X            buffer+=(strlen(argument)+1);
X          }
X      }
X    }
X  *property=protocol;
X  return(True);
}
X
void XSetWMProperties(display,window,window_name,icon_name,argv,argc,
X  size_hints,manager_hints,class_hint)
Display
X  *display;
X
Window
X  window;
X
XXTextProperty
X  *window_name,
X  *icon_name;
X
char
X  **argv;
X
int
X  argc;
X
XXSizeHints
X  *size_hints;
X
XXWMHints *manager_hints;
X
XXClassHint
X  *class_hint;
{
X  XSetStandardProperties(display,window,window_name->value,icon_name,None,
X    argv,argc,size_hints);
X  XSetWMHints(display,window,manager_hints);
X  XSetClassHint(display,window,class_hint);
}
X
Status XSetWMProtocols(display,window,protocols,count)
Display
X  *display;
X
Window
X  window;
X
Atom
X  *protocols;
X
int
X  count;
{
X  Atom
X    protocols_property;
X
X  protocols_property=XInternAtom(display,"WM_PROTOCOLS",False);
X  XChangeProperty(display,window,protocols_property,XA_ATOM,32,PropModeReplace,
X    (unsigned char *) protocols, count);
X  return(True);
}
X
VisualID XVisualIDFromVisual(visual)
Visual
X  *visual;
{
X  return(visual->visualid);
}
X
Status XWithdrawWindow(display,window,screen)
Display
X  *display;
X
Window
X  window;
X
int
X  screen;
{
X  return(XUnmapWindow(display,window));
}
X
int XWMGeometry(display,screen,user_geometry,default_geometry,border_width,
X  size_hints,x,y,width,height,gravity)
Display
X  *display;
X
int
X  screen;
X
char
X  *user_geometry,
X  *default_geometry;
X
unsigned int
X  border_width;
X
XXSizeHints
X  *size_hints;
X
int
X  *x,
X  *y,
X  *width,
X  *height,
X  *gravity;
{
X  int
X    status;
X
X  status=XGeometry(display,screen,user_geometry,default_geometry,border_width,
X    0,0,0,0,x,y,width,height);
X  *gravity=NorthWestGravity;
X  return(status);
}
#endif
SHAR_EOF
chmod 0644 ImageMagick/PreRvIcccm.c ||
echo 'restore of ImageMagick/PreRvIcccm.c failed'
Wc_c="`wc -c < 'ImageMagick/PreRvIcccm.c'`"
test 4759 -eq "$Wc_c" ||
	echo 'ImageMagick/PreRvIcccm.c: original size 4759, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/README ==============
if test -f 'ImageMagick/README' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/README' &&
AUTHOR
X
X  The author is cristy@dupont.com.  Comments, suggestions, or bug
X  reports are welcome, but be kind.
X
X
AVAILABLILITY
X
X  Anonymous FTP at export.lcs.mit.edu, file contrib/ImageMagick.tar.Z.
X
X
UNIX COMPILATION
X
X  Type:
X
X    uncompress ImageMagick.tar.Z
X    tar xvf ImageMagick.tar
X    cd ImageMagick
X    xmkmf
X    make Makefiles
X    make
X
X  If you do not have 'xmkmf', edit 'Makefile' as required by your
X  hardware environment and type 'make'.
X
X  Finally type:
X
X    display images/aquarium.miff
X    display -monochrome -dither images/aquarium.miff
X
X  If the image colors are not correct use this command:
X
X    display -visual default images/aquarium.miff
X
X  You can find other example images in the 'images' directory.
X
X  Be sure to read the manual pages for the display, animate, montage,
X  XtoPS, import, mogrify, and convert utilities.
X
X  The ImageMagick utilites read and write MIFF images.  Refer to the
X  end of this message for more information about MIFF.  Use `convert'
X  to convert images to and from the MIFF format.
X
X  Some ImageMagick utilities recognizes these `alien' image formats:
X
X    GIF
X    JPEG
X    Postscript
X    PPM
X    RLE
X    SUN Raster
X    TIFF
X    Utah Raster
X    VICAR
X    X Bitmap
X    X Window Dump
X
X  and for your convenience automatically converts the alien image
X  format to MIFF at execution time.  However, the MIFF image format has
X  several advantages over most image formats (i.e. runlength encoding,
X  digital signature on an image colormap, etc.).  ImageMagick is
X  designed to exploit these advantages.  Whenever possible convert an
X  alien image format to the MIFF format before using the various
X  ImageMagick programs.
X
X  Other alien formats are also recognized.  See CONVERT(1) for a list
X  of valid image formats.  You can specify a particular image format by
X  prefixing the image filename with the image type and a colon (i.e.
X  mtv:image.mtv).
X
X  ImageMagick requires GNU's Ghostscript software available via FTP as
X  ftp.uu.net:systems/gnu/ghostscript-2.5.2.tar.Z to read the
X  Postscript format.  For ImageMagick to read Postscript files, `gs'
X  must be in your execution path and the `ppmraw' device must be
X  recognized.  Add it to your 'DEVICE_DEVS' define in your `Makefile'
X  and recompile.
X
X  ImageMagick requires the Independent JPEG Group's software available via 
X  FTP as ftp.uu.net:graphics/jpeg/jpegsrc.v4.tar.Z to read the JPEG image
X  format.
X
X  ImageMagick requires Sam Leffler's TIFF software available via FTP as 
X  sgi.com:graphics/tiff/v3.2beta.tar.Z to read the TIFF image format.
X
X  To display images in the JPEG or TIFF format, get the JPEG and TIFF
X  archives and build ImageMagick as follows:
X
X    cd ImageMagick
X    mkdir jpeg
X    cd jpeg
X    zcat jpegsrc.v4.tar.Z | tar xvf -
X    cp jmemnobs.c jmemsys.c
X    cp makefile.unix Makefile
X    make libjpeg.a
X    cd ..
X    mkdir tiff
X    cd tiff
X    zcat v3.2beta.tar.Z | tar xvf -
X    cd libtiff
X    cp Makefile.sun Makefile
X    make
X    cd ../..
X    < edit Magick.tmpl and uncomment JPEG and TIFF lines as instructed >
X    touch alien.c
X    xmkmf
X    make Makefiles
X    make
X
X  You can now display images in the JPEG or TIFF format.
X
X  If you have a colormapped X server, the number of unique colors in an
X  image must first be reduced to match the requirements of your server
X  before it can be displayed.  ImageMagick tries to make the color reduced
X  image closely resemble the original.  However, this process can be
X  time consuming.  To speed it up, ImageMagick trades image quality for
X  processing time.  For the "best" image possible, type
X
X      display -colors 256 -dither image.jpeg
X
X  or add this to your X resources file:
X
X      display.colors: 256
X
X  This example assumes your server supports 256 colors.  Choose
X  whatever value is appropriate for your X server.  Alternatively if
X  you intend to view the image frequently, reduce the number of colors
X  to match the resolution of your X server once and write to a new
X  image.  Then display this new image.  For example,
X
X      convert -colors 256 -dither image.jpeg image.miff
X      display image.miff
X
X
VMS COMPILATION
X
X  Type
X
X    @make
X    set display/create/node=node_name::
X
X  where node_name is the DECNET X server to contact.
X
X  Finally type:
X
X    display images/aquarium.miff
X    display -monochrome -dither images/aquarium.miff
X
X
ANIMATION
X
X  An example animation sequence is available from anonymous FTP at
X  export.lcs.mit.edu, file contrib/ImageMagick.animation.tar.Z Or
X  alternatively, you can create this sequence yourself.  Just look at
X  README in the scenes directory.
X  
X  To prevent color flashing on visuals that have colormaps, `animate'
X  creates a single colormap from the image sequence.  This can be
X  rather time consuming.  You can speed this operation up by reducing
X  the colors in the image before you `animate' them.  Use `mogrify' to
X  color reduce the images:
X
X    mogrify -colors 256 scenes/dna.[0-9]*
X
X  Note, the image sequence in ImageMagick.animation.tar.Z is already
X  reduced.  Alternatively, you can use a Standard Colormap; or a
X  static, direct, or true color visual.  You can define a Standard
X  Colormap with `xstdcmap'.  For example, to use the "best" Standard
X  Colormap, type:
X
X    xstdcmap -best
X    animate -map best scenes/dna.[0-9]*
X
X  or to use a true color visual:
X
X    animate -visual truecolor scenes/dna.[0-9]*
X
X  Image filenames can appear in any order on the command line if the
X  scene keyword is specified in the MIFF image.  Otherwise the images
X  display in the order they appear on the command line.  A scene is
X  specified when converting from another image format to MIFF by using
X  the "scene" option with any filter.  Be sure to choose a scene number
X  other than zero.  For example, to convert a TIFF image to a MIFF
X  image as scene #2, type:
X
X    convert -scene 2 image.tiff image.miff
X
X
NOTES
X
X  1.  If you get a compile error on XTextProperty in PreRvIcccm.h,
X      change it to _XTextProperty. If you get a compile error on
X      XVisualIDFromVisual in PreRvIcccm.c, change it to
X      _XVisualIDFromVisual.
X
X  2.  24 bit images are reduced to 244 colors on an 8 bit display to
X      help prevent colormap flashing.  If you want all 256 colors, type
X
X        display -colors 256 image.miff
X
X      To further help reduce colormap flashing, do not install the
X      default standard colormap (RGB_DEFAULT_MAP).
X
X  3.  Machine dependancies:
X
X      For MacX, set the DISPLAY variable to host:0.2 for the color
X      rootless window.
X
X      I suspect all the following problems will be fixed when these
X      vendors upgrade to X11R4.  I find conditional compilation
X      statements offensive.  So if you have any of the following
X      problems, the fix must be applied manually.
X
X      MIPS does not always generate exposure events correctly when
X      displaying a monochrome image on their color server.  Holes in the
X      image may appear when an area is blocked then exposed.  I do not
X      currently have a solution for this problem.
X
X      Images do not dislay correctly on the IBM R6000 visual with 4096
X      colors.  However they do display correctly on the visual with 256
X      colors.  Until IBM fixes their server, type xdpyinfo to determine 
X      the ID of the 256 color visual and type
X
X        display -visual 0x???? image.miff
X
X      On the Stardent put
X
X        *installColormap:  on
X
X      in your X resource file.
X
X      Digital and Tektronix has a bug in their servers.  When converting
X      from LSBFirst to MSBFirst X server (or visa-versa) you may get the 
X      error
X
X        Illegal unit size: 8 found in routine: _normalizeimagebits
X
X  4.  On occasion, a window manager (twm) may get in strange state which will 
X      cause the display program to work improperly.  Fix this by restarting the
X      window manager.
X
X  5.  If the image is displayed with incorrect colors, try using a different
X      visual.  Type xdpyinfo and choose an alternative visual (if one exists)
X      by either visual class or visual id.  For example, to specifically 
X      choose a PseudoColor visual on a server that supports it, type
X
X        display -visual pseudocolor image.miff
X
X  6.  Make sure that the include file math.h defines the function atof as
X      type double.  Otherwise the -gamma option will not work properly.
X
X
MIFF IMAGE FORMAT
X
X  MIFF is an image format, which I developed.  I like it because it
X
X    1) It is machine independant.  It can be read on virtually any
X       computer.  No byte swapping is necessary.
X
X    2) It has a text header.  Most image formats are coded in binary
X       and you cannot easily tell attributes about the image.  Use
X       'more' on MIFF image files and the attributes are displayed in
X       text form.
X
X    3) It can handle runlength-encoded images.  Although most scanned
X       images do not benefit from runlength-encoding, most
X       computer-generated images do.  Images of mostly uniform colors
X       have a high compression ratio and therefore take up less memory
X       and disk space.
X
X    4) It allows a scene number to be specified.  This allows you to
X       specify an animation sequence out-of-order on the command line.
X       The correct order is determined by the scene number of each
X       image.
X
X    5) MIFF computes a digital signature for colormapped images.  This
X       is useful for animating a sequence of images on a colormapped X
X       server.  If all signatures match in the image sequence,
X       computing a global colormap is not necessary.
X
X  One way to get an image into MIFF format is to use `convert'.  or
X  read it from an X window using the 'import' program.  Alternatively,
X  type the necessary header information in a file with a text editor.
X  Next, dump the binary bytes into another file.  Finally, type
X
X    cat header binary_image | display -write image.miff -
X
X  For example, suppose you have a raw red, green, blue image file on
X  disk that is 640 by 480.  The header file would look like this:
X
X    id=ImageMagick columns=640 rows=480 :
X
X  The image file would have red, green, blue tuples (rgbrgbrgb...).
X
X  Refer to the 'display' manual page for more details.
X
ACKNOWLEDGEMENTS
X
X  o Dirk Wetzel <wetzel@forwiss.uni-erlangen.de> fixed the select statement 
X    in animate.c.
X
X  o Eric Haines <erich@eye.com> fixed ReadRLEImage in alien.c.  It previously
X    did not check to see if the background color was present in the image.
X
X
COPYRIGHT
X
X  Copyright 1992 E. I. du Pont de Nemours & Company
X
X  Permission to use, copy, modify, distribute, and sell this software and
X  its documentation for any purpose is hereby granted without fee,
X  provided that the above copyright notice appear in all copies and that
X  both that copyright notice and this permission notice appear in
X  supporting documentation, and that the name of E. I. du Pont de Nemours
X  & Company not be used in advertising or publicity pertaining to
X  distribution of the software without specific, written prior
X  permission.  E. I. du Pont de Nemours & Company makes no representations
X  about the suitability of this software for any purpose.  It is provided
X  "as is" without express or implied warranty.
X
X  E. I. du Pont de Nemours & Company disclaims all warranties with regard
X  to this software, including all implied warranties of merchantability
X  and fitness, in no event shall E. I. du Pont de Nemours & Company be
X  liable for any special, indirect or consequential damages or any
X  damages whatsoever resulting from loss of use, data or profits, whether
X  in an action of contract, negligence or other tortious action, arising
X  out of or in connection with the use or performance of this software.
SHAR_EOF
chmod 0644 ImageMagick/README ||
echo 'restore of ImageMagick/README failed'
Wc_c="`wc -c < 'ImageMagick/README'`"
test 11672 -eq "$Wc_c" ||
	echo 'ImageMagick/README: original size 11672, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/XtoPS.c ==============
if test -f 'ImageMagick/XtoPS.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/XtoPS.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/XtoPS.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/XtoPS.c' &&
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                     X   X  TTTTT   OOO   PPPP   SSSSS                       %
%                      X X     T    O   O  P   P  S                           %
%                       X      T    O   O  PPPP    SSS                        %
%                      X X     T    O   O  P          S                       %
%                     X   X    T     OOO   P      SSSSS                       %
%                                                                             %
%                                                                             %
%                  Import X11 image to a Postscript format.                   %
%                                                                             %
%                                                                             %
%                           Software Design                                   %
%                             John Cristy                                     %
%                              July 1992                                      %
%                                                                             %
%                                                                             %
%  Copyright 1992 E. I. du Pont de Nemours & Company                          %
%                                                                             %
%  Permission to use, copy, modify, distribute, and sell this software and    %
%  its documentation for any purpose is hereby granted without fee,           %
%  provided that the above Copyright notice appear in all copies and that     %
%  both that Copyright notice and this permission notice appear in            %
%  supporting documentation, and that the name of E. I. du Pont de Nemours    %
%  & Company not be used in advertising or publicity pertaining to            %
%  distribution of the software without specific, written prior               %
%  permission.  E. I. du Pont de Nemours & Company makes no representations   %
%  about the suitability of this software for any purpose.  It is provided    %
%  "as is" without express or implied warranty.                               %
%                                                                             %
%  E. I. du Pont de Nemours & Company disclaims all warranties with regard    %
%  to this software, including all implied warranties of merchantability      %
%  and fitness, in no event shall E. I. du Pont de Nemours & Company be       %
%  liable for any special, indirect or consequential damages or any           %
%  damages whatsoever resulting from loss of use, data or profits, whether    %
%  in an action of contract, negligence or other tortious action, arising     %
%  out of or in connection with the use or performance of this software.      %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  XtoPS is an X Window System window dumping utility.  XtoPS reads an
%  image from any visible window on an X server and outputs it to an
%  encapsulated Postscript file.  You can view this file with any
%  Postscript compatible viewer or printer.  The image is displayed in
%  color on viewers or printers that support color Postscript, otherwise
%  it is displayed as grayscale.  The target window can be specified by id
%  or name or be selected by clicking the mouse in the desired window.
%  The keyboard bell is rung once at the beginning of the dump and twice
%  when the dump is completed.
%
%  The XtoPS program command syntax is:
%
%  Usage: XtoPS [options ...] file
%
%  Where options include:
%    -border             include image borders in the output image
%    -delay seconds      pause before selecting target window
%    -display server     X server to contact
%    -frame              include window manager frame
%    -geometry geometry  preferred size and location of the image
%    -monochrome         transform image to black and white
%    -rotate degrees     apply Paeth rotation to the image
%    -scale geometry     preferred size factors of the image
%    -screen             select image from root window
%    -verbose            print detailed information about the image
%    -window id          select window with this id or name
%
%  Change '-' to '+' in any option above to reverse its effect.
%  For example, +frame means do not window manager frame.
%
%  Specify 'file' as '-' for standard input or output.
%
%
*/
X
/*
X  Include declarations.
*/
#include "display.h"
#include "image.h"
#include "alien.h"
#include "X.h"
X
/*
X  Global declarations.
*/
char
X  *application_name;
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   E r r o r                                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function Error displays an error message and then terminates the program.
%
%  The format of the Error routine is:
%
%      Error(message,qualifier)
%
%  A description of each parameter follows:
%
%    o message: Specifies the message to display before terminating the
%      program.
%
%    o qualifier: Specifies any qualifier to the message.
%
%
*/
void Error(message,qualifier)
char
X  *message,
X  *qualifier;
{
X  (void) fprintf(stderr,"%s: %s",application_name,message);
X  if (qualifier != (char *) NULL)
X    (void) fprintf(stderr," (%s)",qualifier);
X  (void) fprintf(stderr,".\n");
X  exit(1);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   U s a g e                                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Procedure Usage displays the program usage;
%
%  The format of the Usage routine is:
%
%      Usage()
%
%
*/
static void Usage()
{
X  char
X    **p;
X
X  static char
X    *options[]=
X    {
X      "-border             include image borders in the output image",
X      "-delay seconds      pause before selecting target window",
X      "-display server     X server to contact",
X      "-frame              include window manager frame",
X      "-geometry geometry  preferred size and location of the image",
X      "-monochrome         transform image to black and white",
X      "-rotate degrees     apply Paeth rotation to the image",
X      "-scale geometry     preferred size factors of the image",
X      "-screen             select image from root window",
X      "-verbose            print detailed information about the image",
X      "-window id          select window with this id or name",
X      (char *) NULL
X    };
X  (void) fprintf(stderr,"Usage: %s [options ...] file\n",application_name);
X  (void) fprintf(stderr,"\nWhere options include:\n");
X  for (p=options; *p != (char *) NULL; p++)
X    (void) fprintf(stderr,"  %s\n",*p);
X  (void) fprintf(stderr,
X    "\nChange '-' to '+' in any option above to reverse its effect.\n");
X  (void) fprintf(stderr,
X    "For example, +frame means do not include window manager frame.\n");
X  (void) fprintf(stderr,"\nSpecify 'file' as '-' for standard output.\n");
X  exit(1);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%    M a i n                                                                  %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
*/
int main(argc,argv)
int
X  argc;
X
char
X  *argv[];
{
X  char
X    *filename,
X    *image_geometry,
X    *option,
X    *resource_value,
X    *scale_geometry,
X    *server_name,
X    *target_window;
X
X  Display
X    *display;
X
X  Image
X    *image;
X
X  int
X    degrees,
X    i,
X    x;
X
X  time_t
X    start_time;
X
X  unsigned int
X    borders,
X    frame,
X    screen,
X    verbose;
X
X  XResourceInfo
X    resource_info;
X
X  XrmDatabase
X    resource_database,
X    server_database;
X
X  /*
X    Display usage profile if there are no command line arguments.
X  */
X  application_name=(*argv);
X  if (argc < 2)
X    Usage();
X  /*
X    Connect to X server.
X  */
X  server_name=(char *) NULL;
X  for (i=1; i < argc; i++)
X  {
X    /*
X      Check command line for server name.
X    */
X    option=argv[i];
X    if (((int) strlen(option) > 1) && ((*option == '-') || (*option == '+')))
X      if (strncmp("dis",option+1,3) == 0)
X        {
X          /*
X            User specified server name.
X          */
X          i++;
X          if (i == argc)
X            Error("missing server name on -display",(char *) NULL);
X          server_name=argv[i];
X          break;
X        }
X  }
X  display=XOpenDisplay(server_name);
X  if (display == (Display *) NULL)
X    Error("unable to connect to X server",XDisplayName(server_name));
X  /*
X    Set our forgiving error handler.
X  */
X  XSetErrorHandler(XError);
X  /*
X    Initialize resource database.
X  */
X  XrmInitialize();
X  resource_database=XrmGetDatabase(display);
X  resource_value=XResourceManagerString(display);
X  if (resource_value == (char *) NULL)
X    resource_value="";
X  server_database=XrmGetStringDatabase(resource_value);
X  XrmMergeDatabases(server_database,&resource_database);
X  /*
X    Get user defaults from X resource database.
X  */
X  XGetResourceInfo(resource_database,application_name,&resource_info);
X  resource_value=XGetResource(resource_database,application_name,"borders",
X    (char *) NULL,"False");
X  borders=IsTrue(resource_value);
X  resource_value=XGetResource(resource_database,application_name,"frame",
X    (char *) NULL,"False");
X  frame=IsTrue(resource_value);
X  image_geometry=XGetResource(resource_database,application_name,
X    "imageGeometry","ImageGeometry",(char *) NULL);
X  resource_value=XGetResource(resource_database,application_name,"rotate",
X    (char *) NULL,"False");
X  scale_geometry=XGetResource(resource_database,application_name,
X    "scaleGeometry","ScaleGeometry",(char *) NULL);
X  degrees=atoi(resource_value);
X  resource_value=XGetResource(resource_database,application_name,"screen",
X    (char *) NULL,"False");
X  screen=IsTrue(resource_value);
X  resource_value=XGetResource(resource_database,application_name,"verbose",
X    (char *) NULL,"False");
X  verbose=IsTrue(resource_value);
X  /*
X    Check command syntax.
X  */
X  filename=(char *) NULL;
X  target_window=(char *) NULL;
X  for (i=1; i < argc; i++)
X  {
X    option=argv[i];
X    if (((int) strlen(option) < 2) || ((*option != '-') && (*option != '+')))
X      filename=argv[i];
X    else
X      switch(*(option+1))
X      {
X        case 'b':
X        {
X          borders=(*option == '-');
X          break;
X        }
X        case 'd':
X        {
X          if (strncmp("delay",option+1,2) == 0)
X            {
X              resource_info.delay=0;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                    Error("missing seconds on -delay",(char *) NULL);
X                  resource_info.delay=atoi(argv[i]);
X                }
X              break;
X            }
X          if (strncmp("display",option+1,3) == 0)
X            {
X              server_name=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing server name on -display",(char *) NULL);
X                  server_name=argv[i];
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'g':
X        {
X          /*
X            User specified server name.
X          */
X          i++;
X          if (i == argc)
X            Error("missing geometry on -geometry",(char *) NULL);
X          image_geometry=argv[i];
X          break;
X        }
X        case 'h':
X        {
X          Usage();
X          break;
X        }
X        case 'f':
X        {
X          frame=(*option == '-');
X          break;
X        }
X        case 'm':
X        {
X          resource_info.monochrome=(*option == '-');
X          break;
X        }
X        case 'r':
X        {
X          degrees=0;
X          if (*option == '-')
X            {
X              i++;
X              if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                Error("missing degrees on -rotate",(char *) NULL);
X              degrees=atoi(argv[i]);
X            }
X          break;
X        }
X        case 's':
X        {
X          if (strncmp("scale",option+1,4) == 0)
X            {
X              scale_geometry=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%f",(float *) &x))
X                    Error("missing scale geometry on -scale",(char *) NULL);
X                  scale_geometry=argv[i];
X                }
X              break;
X            }
X          if (strncmp("screen",option+1,4) == 0)
X            {
X              screen=(*option == '-');
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'v':
X        {
X          verbose=(*option == '-');
X          break;
X        }
X        case 'w':
X        {
X          i++;
X          if (i == argc)
X            Error("missing id, name, or 'root' on -window",(char *) NULL);
X          target_window=argv[i];
X          break;
X        }
X        default:
X        {
X          Error("unrecognized option",option);
X          break;
X        }
X      }
X  }
X  if (filename == (char *) NULL)
X    Error("missing an image file name",(char *) NULL);
X  /*
X    Read image from X server.
X  */
X  if (resource_info.delay > 0)
X    (void) sleep(resource_info.delay);
X  start_time=time((time_t *) 0);
X  image=ReadXImage(target_window,server_name,frame,screen,borders);
X  if (image == (Image *) NULL)
X    exit(1);
X  if (image_geometry || scale_geometry)
X    TransformImage(&image,(char *) NULL,image_geometry,scale_geometry);
X  if ((degrees % 360) != 0)
X    {
X      Image
X        *rotated_image;
X
X      /*
X        Rotate image.
X      */
X      rotated_image=RotateImage(image,(double) degrees,False);
X      if (rotated_image != (Image *) NULL)
X        {
X          DestroyImage(image);
X          image=rotated_image;
X        }
X    }
X  if (resource_info.monochrome)
X    QuantizeImage(image,2,8,False,GRAYColorspace,True);
X  (void) strcpy(image->filename,filename);
X  (void) PrintImage(image,image_geometry);
X  if (verbose)
X    {
X      /*
X        Display detailed info about the image.
X      */
X      if (image->class == DirectClass)
X        image->colors=NumberColors(image);
X      (void) fprintf(stderr,"[%u] %s %ux%u",image->scene,image->filename,
X        image->columns,image->rows);
X      if (image->class == DirectClass)
X        (void) fprintf(stderr," DirectClass ");
X      else
X        (void) fprintf(stderr," PseudoClass ");
X      (void) fprintf(stderr,"%uc %s %ds\n",image->colors,image->magick,
X        time((time_t *) 0)-start_time+1);
X    }
X  DestroyImage(image);
X  XCloseDisplay(display);
X  return(False);
}
SHAR_EOF
chmod 0644 ImageMagick/XtoPS.c ||
echo 'restore of ImageMagick/XtoPS.c failed'
Wc_c="`wc -c < 'ImageMagick/XtoPS.c'`"
test 16586 -eq "$Wc_c" ||
	echo 'ImageMagick/XtoPS.c: original size 16586, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/XtoPS.man ==============
if test -f 'ImageMagick/XtoPS.man' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/XtoPS.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/XtoPS.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/XtoPS.man' &&
.ad l
.nh
.TH XTOPS 1 "10 October 1992" "ImageMagick"
.SH NAME
XXtoPS - capture some or all of an X server screen and save as Encapsulated
Postscript
.SH SYNOPSIS
.B "XtoPS"
[ \fIoptions\fP ... ] \fIfile\fP
.SH DESCRIPTION
.PP
.I XtoPS
reads an image from any visible window on an X server and outputs it as
Encapsulated Postscript.  You can capture a single window, the entire
screen, or any rectangular portion of the screen.  You can view the
captured screen with any Postscript compatible viewer or printer.  The
Postscript is displayed in color on viewers or printers that support
color, otherwise it is displayed as grayscale.
.PP
The target window can be specified by id, name, or may be selected by
clicking the mouse in the desired window.  If you press a button and
then drag, a rectangle will form which expands and contracts as
the mouse moves.  To save the portion of the screen defined by the
rectangle, just release the button.  The keyboard bell is rung once at
the beginning of the screen capture and twice it completes.
.SH EXAMPLES
.PP
To select an X window with the mouse and save it as Encapsulated
Postscript in a file on disk titled window.ps, use:
.PP
X     XtoPS window.ps
.PP
To select an X window and save it as Encapsulated Postscript in a file on
disk titled figure.ps to include in another document (i.e. \fBLaTeX\fP), use:
.PP
X     XtoPS -geometry +0+0 figure.ps
.PP
To capture the entire X server screen as Encapsulated Postscript in a file on
disk titled root.ps, use:
.PP
X     XtoPS -window root root.ps
.SH OPTIONS
\fIXtoPS\fP options can appear on the command line or in your X
resources file (see \fBX(1)\fP).  Options on the command line supersede
values specified in your X resources file.
.TP 5
.B "-border"
include image borders in the output image.
.TP 5
.B "-delay \fIseconds\fP"
pause before selecting target window.
X
This option is useful when you need time to ready the target window before
it is captured to a file.
.TP 5
.B "-display \fIhost:display[.screen]\fP"
specifies the X server to contact; see \fBX(1)\fP.
.TP 5
.B "-frame"
include window manager frame.
.TP 5
.B "-geometry \fI<width>x<height>{\+-}<x offset>{\+-}<y offset>\fP"
preferred size and location of the image on the Postscript page.
See \fBX(1)\fP for details about the geometry specification. By default, the
image is scaled and centered to fit on an 612x792 point Postscript page.
X
If the specified image size is smaller than the actual image size, the
image is first reduced to an integral of the specified image size with
an antialias digital filter.  The image is then scaled to the exact
specified image size with pixel replication.  If the specified image
size is greater than the actual image size, the image is first enlarged
to an integral of the specified image size with bilinear
interpolation.  The image is then scaled to the exact specified image
size with pixel replication.
.TP 5
.B "-monochrome"
transform image to black and white.
.TP 5
.B "-rotate \fIdegrees\fP"
apply Paeth image rotation to the image.
X
By default the image is output in portrait mode.  Use \fB-rotate 90\fP to
display the image in landscape mode.
.TP 5
.B "-scale \fI<width factor>x<height factor>\fP"
preferred size factors of the image.
X
This option behaves like \fB-geometry\fP except the width and height values
are relative instead of absolute.  The image size is multiplied by the
width and height factors to obtain the final image dimensions.  If only
one factor is specified, both the width and height factors assume the
value.
X
Factors may be fractional.  For example, a factor of 1.5 will increase the
image size by one and one-half.
.TP 5
.B "-screen"
This option indicates that the GetImage request used to obtain the image
should be done on the root window, rather than directly on the specified
window.  In this way, you can obtain pieces of other windows that overlap
the specified window, and more importantly, you can capture menus or other
popups that are independent windows but appear over the specified window.
.TP 5
.B -verbose
print detailed information about the image.
X 
This information is printed: image scene number;  image name;  image size;
the image class (\fIDirectClass\fP or \fIPseudoClass\fP);  the total
number of unique colors;  and the number of seconds to read and write the
image.
.TP 5
.B "-window \fIid\fP"
select window with this id or name.
X
With this option you can specify the target  window by id or name
rather than using the mouse.  Specify 'root' to select X's root window
as the target window.
.PP
Change \fI-\fP to \fI+\fP in any option above to reverse its effect.  For
example \fB+frame\fP means do not include window manager frame.
.PP
Specify \fIfile\fP as \fI-\fP for standard input or output.
.PP
.SH ENVIRONMENT
.PP
.TP 5
.B DISPLAY
To get the default host, display number, and screen.
.SH SEE ALSO
XX(1)
.SH COPYRIGHT
Copyright 1992 E. I. du Pont de Nemours & Company
.PP
Permission to use, copy, modify, distribute, and sell this software and
its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of E. I. du Pont de Nemours
& Company not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior
permission.  E. I. du Pont de Nemours & Company makes no representations
about the suitability of this software for any purpose.  It is provided
"as is" without express or implied warranty.
.PP
E. I. du Pont de Nemours & Company disclaims all warranties with regard
to this software, including all implied warranties of merchantability
and fitness, in no event shall E. I. du Pont de Nemours & Company be
liable for any special, indirect or consequential damages or any
damages whatsoever resulting from loss of use, data or profits, whether
in an action of contract, negligence or other tortious action, arising
out of or in connection with the use or performance of this software.
.SH AUTHORS
John Cristy, E.I. du Pont De Nemours & Company Incorporated
X
SHAR_EOF
chmod 0644 ImageMagick/XtoPS.man ||
echo 'restore of ImageMagick/XtoPS.man failed'
Wc_c="`wc -c < 'ImageMagick/XtoPS.man'`"
test 6159 -eq "$Wc_c" ||
	echo 'ImageMagick/XtoPS.man: original size 6159, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/Manifest.ps ==============
if test -f 'ImageMagick/Manifest.ps' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/Manifest.ps (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/Manifest.ps (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/Manifest.ps' &&
%!PS-Adobe-2.0 EPSF-2.0
%%Title: (Directory map of ImageMagick)
%%Creator: pstree, (C) 1990 Gisle Aas, NR
%%DocumentFonts: Times-Roman
%%BoundingBox: 60 112 310 742
60.0 0 translate
/s {show} bind def
/m {moveto} bind def
/Times-Roman findfont 10 scalefont setfont
0.1 setlinewidth
90 732 m(ChangeLog)s
90 722 m(Imakefile)s
90 712 m(Magick.tmpl)s
90 702 m(Make.com)s
90 692 m(Makefile)s
90 682 m(Manifest.ps)s
90 672 m(PreRvIcccm.c)s
90 662 m(PreRvIcccm.h)s
90 652 m(README)s
90 642 m(SYNOPSIS)s
90 632 m(X.c)s
90 622 m(X.h)s
90 612 m(XWDFile.h)s
90 602 m(XtoPS.c)s
90 592 m(XtoPS.man)s
90 582 m(alien.c)s
90 572 m(alien.h)s
90 562 m(animate.c)s
90 552 m(animate.h)s
90 542 m(animate.man)s
90 532 m(colors.c)s
90 522 m(compress.c)s
90 512 m(compress.h)s
90 502 m(display.c)s
90 492 m(display.h)s
90 482 m(display.man)s
90 472 m(image.c)s
90 462 m(image.h)s
180 452 m(README)s
180 442 m(aquarium.miff)s
180 432 m(dna.miff)s
180 422 m(montage.miff)s
180 412 m(swan.miff)s
90 432 m(images)s
(images) stringwidth pop 91.0 add 435.3 m
[ 455.3 445.3 435.3 425.3 415.3]
{gsave 176.0 exch lineto stroke grestore} forall
90 402 m(import.c)s
90 392 m(import.man)s
90 382 m(miff.man)s
90 372 m(montage.c)s
90 362 m(montage.man)s
90 352 m(quantize.c)s
90 342 m(quantize.man)s
90 332 m(rotate.c)s
180 322 m(Makefile)s
180 312 m(README)s
180 302 m(dna.script)s
90 312 m(scenes)s
(scenes) stringwidth pop 91.0 add 315.3 m
[ 325.3 315.3 305.3]
{gsave 176.0 exch lineto stroke grestore} forall
90 292 m(signature.c)s
180 282 m(Imakefile)s
180 272 m(MIFFtoSTEREO.c)s
180 262 m(Make.com)s
180 252 m(Makefile)s
180 242 m(convert.c)s
180 232 m(convert.man)s
180 222 m(mogrify.c)s
180 212 m(mogrify.man)s
90 247 m(utilities)s
(utilities) stringwidth pop 91.0 add 250.3 m
[ 285.3 275.3 265.3 255.3 245.3 235.3 225.3 215.3]
{gsave 176.0 exch lineto stroke grestore} forall
180 202 m(Imakefile)s
180 192 m(Makefile)s
180 182 m(README)s
180 172 m(get)s
180 162 m(network.c)s
180 152 m(regular.c)s
180 142 m(regular.h)s
180 132 m(xtp.c)s
180 122 m(xtp.h)s
180 112 m(xtp.man)s
90 157 m(xtp)s
(xtp) stringwidth pop 91.0 add 160.3 m
[ 205.3 195.3 185.3 175.3 165.3 155.3 145.3 135.3 125.3 115.3]
{gsave 176.0 exch lineto stroke grestore} forall
0 444 m(ImageMagick)s
(ImageMagick) stringwidth pop 1.0 add 447.8 m
[ 735.3 725.3 715.3 705.3 695.3 685.3 675.3 665.3 655.3 645.3 635.3 625.3 615.3 605.3 595.3 585.3 575.3 565.3 555.3 545.3 535.3 525.3 515.3 505.3 495.3 485.3 475.3 465.3 435.3 405.3 395.3 385.3 375.3 365.3 355.3 345.3 335.3 315.3 295.3 250.3 160.3]
{gsave 86.0 exch lineto stroke grestore} forall
showpage
SHAR_EOF
chmod 0644 ImageMagick/Manifest.ps ||
echo 'restore of ImageMagick/Manifest.ps failed'
Wc_c="`wc -c < 'ImageMagick/Manifest.ps'`"
test 2589 -eq "$Wc_c" ||
	echo 'ImageMagick/Manifest.ps: original size 2589, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/colors.c ==============
if test -f 'ImageMagick/colors.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/colors.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/colors.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/colors.c' &&
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%                  CCCC   OOO   L       OOO   RRRR    SSSSS                   %
%                 C      O   O  L      O   O  R   R   SS                      %
%                 C      O   O  L      O   O  RRRR     SSS                    %
%                 C      O   O  L      O   O  R R        SS                   %
%                  CCCC   OOO   LLLLL   OOO   R  R    SSSSS                   %
%                                                                             %
%                                                                             %
%                       Count the Colors in an Image                          %
%                                                                             %
%                                                                             %
%                                                                             %
SHAR_EOF
true || echo 'restore of ImageMagick/colors.c failed'
fi
echo 'End of  part 1'
echo 'File ImageMagick/colors.c is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
exit 0 # Just in case...
