Newsgroups: comp.sources.misc
From: cristy@eplrx7.es.duPont.com (John Cristy)
Subject: v34i087: imagemagick - X11 image processing and display v2.2, Patch01c/3
Message-ID: <1992Dec27.225958.635@sparky.imd.sterling.com>
X-Md4-Signature: a2efa0c8570741eb4ed0ed94a75eacc8
Date: Sun, 27 Dec 1992 22:59:58 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: cristy@eplrx7.es.duPont.com (John Cristy)
Posting-number: Volume 34, Issue 87
Archive-name: imagemagick/patch01c
Environment: UNIX, VMS, X11, SGI, DEC, Cray, Sun, Vax
Patch-To: imagemagick: Volume 34, Issue 28-54

#!/bin/sh
# this is magick.03 (part 3 of ImageMagick/patch01)
# do not concatenate these parts, unpack them in order with /bin/sh
# file fix-01 continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 3; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping fix-01'
else
echo 'x - continuing file fix-01'
sed 's/^X//' << 'SHAR_EOF' >> 'fix-01' &&
!           return((Image *) NULL);
!         }
!       rotated_image->columns=image->rows;
!       rotated_image->rows=image->columns;
X      }
X    else
X      {
!       y_width=image->columns+
!         (int) ceil(fabs(x_shear)*(double) (image->rows-1));
!       number_columns=image->columns+2*
!         (int) ceil(fabs(x_shear)*(double) (image->rows-1));
!       number_rows=image->rows+
!         (int) ceil(fabs(y_shear)*(double) (y_width-1));
!       rotated_image=CopyImage(image,number_columns,number_rows,False);
!       if (rotated_image == (Image *) NULL)
!         {
!           Warning("unable to rotate image","memory allocation failed");
!           return((Image *) NULL);
!         }
!       rotated_image->columns=image->columns;
!       rotated_image->rows=image->rows;
X      }
X    /*
!     Initialize rotated image attributes.
X    */
!   rotated_pixels=(ColorPacket *)
!     malloc(number_columns*(number_rows+2)*sizeof(ColorPacket));
!   if (rotated_pixels == (ColorPacket *) NULL)
X      {
X        Warning("unable to rotate image","memory allocation failed");
X        return((Image *) NULL);
X      }
!   if ((x_shear == 0.0) || (y_shear == 0.0))
!     {
!       /*
!         No shearing required; do integral rotation.
!       */
!       x_offset=0;
!       y_offset=0;
!       IntegralRotation(image,rotated_image->columns,rotated_image->rows,
!         rotated_pixels+number_columns,number_columns,x_offset,y_offset,
!         rotations);
!     }
!   else
!     {
!       typedef struct Point
!       {
!         double
!           x,
!           y;
!       } Point;
X  
!       double
!         x_max,
!         x_min,
!         y_max,
!         y_min;
X  
!       Point
!         corners[4];
X  
!       unsigned char
!         *range_limit,
!         *range_table;
X  
!       unsigned int
!         column,
!         row;
X  
!       /*
!         Initialize rotated image buffer to background color.
!       */
!       rotated_image->class=DirectClass;
!       background.red=image->pixels[0].red;
!       background.green=image->pixels[0].green;
!       background.blue=image->pixels[0].blue;
!       p=rotated_pixels;
!       for (i=0; i < (number_columns*(number_rows+2)); i++)
!       {
!         *p=background;
!         p++;
!       }
!       /*
!         Perform an initial integral 90 degree rotation.
!       */
!       x_offset=(number_columns-rotated_image->columns)/2;
!       y_offset=(number_rows-rotated_image->rows)/2;
!       IntegralRotation(image,rotated_image->columns,rotated_image->rows,
!         rotated_pixels+number_columns,number_columns,x_offset,y_offset,
!         rotations);
!       /*
!         Initialize range table.
!       */
!       range_table=(unsigned char *) malloc(3*(MaxRGB+1)*sizeof(unsigned char));
!       if (range_table == (unsigned char *) NULL)
!         {
!           DestroyImage(rotated_image);
!           Warning("unable to rotate image","memory allocation failed");
!           return((Image *) NULL);
!         }
!       for (i=0; i <= MaxRGB; i++)
!       {
!         range_table[i]=0;
!         range_table[i+(MaxRGB+1)]=(unsigned char) i;
!         range_table[i+(MaxRGB+1)*2]=MaxRGB;
!       }
!       range_limit=range_table+(MaxRGB+1);
!       /*
!         Perform a fractional rotation.  First, shear the image rows.
!       */
!       row=(number_rows-rotated_image->rows)/2;
!       for (i=0; i < rotated_image->rows; i++)
!       {
!         RowShear(rotated_pixels+number_columns,number_columns,row,x_offset,
!           rotated_image->columns,x_shear*
!           (((double) i)-(rotated_image->rows-1)/2.0),background,range_limit);
!         row++;
!       }
!       /*
!         Shear the image columns.
!       */
!       column=(number_columns-y_width)/2;
!       for (i=0; i < y_width; i++)
!       {
!         ColumnShear(rotated_pixels+number_columns,number_columns,column,
!           y_offset,rotated_image->rows,y_shear*(((double) i)-(y_width-1)/2.0),
!           background,range_limit);
!         column++;
!       }
!       /*
!         Shear the image rows again.
!       */
!       for (i=0; i < number_rows; i++)
!         RowShear(rotated_pixels+number_columns,number_columns,(unsigned int) i,
!           (number_columns-y_width)/2,y_width,x_shear*
!           (((double) i)-(number_rows-1)/2.0),background,range_limit);
!       (void) free((char *) range_table);
!       /*
!         Calculate the rotated image size.
!       */
!       corners[0].x=(-((int) rotated_image->columns)/2.0);
!       corners[0].y=(-((int) rotated_image->rows)/2.0);
!       corners[1].x=((int) rotated_image->columns)/2.0;
!       corners[1].y=(-((int) rotated_image->rows)/2.0);
!       corners[2].x=(-((int) rotated_image->columns)/2.0);
!       corners[2].y=((int) rotated_image->rows)/2.0;
!       corners[3].x=((int) rotated_image->columns)/2.0;
!       corners[3].y=((int) rotated_image->rows)/2.0;
!       for (i=0; i < 4; i++)
!       {
!         corners[i].x+=x_shear*corners[i].y;
!         corners[i].y+=y_shear*corners[i].x;
!         corners[i].x+=x_shear*corners[i].y;
!         corners[i].x+=(number_columns-1)/2.0;
!         corners[i].y+=(number_rows-1)/2.0;
!       }
!       x_min=corners[0].x;
!       y_min=corners[0].y;
!       x_max=corners[0].x;
!       y_max=corners[0].y;
!       for (i=1; i < 4; i++)
!       {
!         if (x_min > corners[i].x)
!           x_min=corners[i].x;
!         if (y_min > corners[i].y)
!           y_min=corners[i].y;
!         if (x_max < corners[i].x)
!           x_max=corners[i].x;
!         if (y_max < corners[i].y)
!           y_max=corners[i].y;
!       }
!       x_min=floor((double) x_min);
!       x_max=ceil((double) x_max);
!       y_min=floor((double) y_min);
!       y_max=ceil((double) y_max);
!       if (!clip)
!         {
!           /*
!             Rotated image is not clipped.
!           */
!           rotated_image->columns=(unsigned int) (x_max-x_min);
!           rotated_image->rows=(unsigned int) (y_max-y_min);
!         }
!       x_offset=(int) x_min+((int) (x_max-x_min)-rotated_image->columns)/2;
!       y_offset=(int) y_min+((int) (y_max-y_min)-rotated_image->rows)/2;
!     }
X    /*
!     Convert the rectangular array of pixels to runlength packets.
X    */
!   rotated_image->packets=rotated_image->columns*rotated_image->rows;
!   q=rotated_image->pixels;
!   for (y=0; y < rotated_image->rows; y++)
!   {
!     p=rotated_pixels+number_columns+(y+y_offset)*number_columns+x_offset;
!     for (x=0; x < rotated_image->columns; x++)
X      {
!       q->red=p->red;
!       q->green=p->green;
!       q->blue=p->blue;
!       q->index=p->index;
!       q->length=0;
!       q++;
!       p++;
X      }
X    }
!   (void) free((char *) rotated_pixels);
!   return(rotated_image);
X  }
--- 989,1214 ----
X    */
X    x_shear=(-tan(DegreesToRadians(degrees)/2.0));
X    y_shear=sin(DegreesToRadians(degrees));
+   integral_image=IntegralRotateImage(image,rotations);
+   if ((x_shear == 0.0) || (y_shear == 0.0))
+     return(integral_image);
+   /*
+     Initialize range table.
+   */
+   range_table=(unsigned char *) malloc(3*(MaxRGB+1)*sizeof(unsigned char));
+   if (range_table == (unsigned char *) NULL)
+     {
+       DestroyImage(integral_image);
+       Warning("unable to rotate image","memory allocation failed");
+       return((Image *) NULL);
+     }
+   for (i=0; i <= MaxRGB; i++)
+   {
+     range_table[i]=0;
+     range_table[i+(MaxRGB+1)]=(unsigned char) i;
+     range_table[i+(MaxRGB+1)*2]=MaxRGB;
+   }
+   range_limit=range_table+(MaxRGB+1);
+   /*
+     Compute image size.
+   */
X    if ((rotations == 1) || (rotations == 3))
X      {
!       y_width=image->rows+(int) ceil(fabs(x_shear)*(double) (image->columns-1));
!       x_offset=(image->rows+2*
!         (int) ceil(fabs(x_shear)*(double) (image->columns-1))-image->rows)/2;
!       y_offset=(image->columns+
!         (int) ceil(fabs(y_shear)*(double) (y_width-1))-image->columns)/2;
!       width=image->rows;
!       height=image->columns;
X      }
X    else
X      {
!       y_width=image->columns+(int) ceil(fabs(x_shear)*(double) (image->rows-1));
!       x_offset=(image->columns+2*
!         (int) ceil(fabs(x_shear)*(double) (image->rows-1))-image->columns)/2;
!       y_offset=(image->rows+
!         (int) ceil(fabs(y_shear)*(double) (y_width-1))-image->rows)/2;
!       width=image->columns;
!       height=image->rows;
X      }
X    /*
!     Surround image with border of background color.
X    */
!   background.red=image->pixels[0].red;
!   background.green=image->pixels[0].green;
!   background.blue=image->pixels[0].blue;
!   rotated_image=BorderImage(integral_image,x_offset,y_offset+1,background);
!   DestroyImage(integral_image);
!   if (rotated_image == (Image *) NULL)
X      {
X        Warning("unable to rotate image","memory allocation failed");
X        return((Image *) NULL);
X      }
!   rotated_image->class=DirectClass;
!   /*
!     Perform a fractional rotation.  First, shear the image rows.
!   */
!   XShearImage(rotated_image,x_shear,width,height,x_offset,
!     (int) (rotated_image->rows-height-2)/2+1,background,range_limit);
!   /*
!     Shear the image columns.
!   */
!   YShearImage(rotated_image,y_shear,y_width,height,
!     (int) (rotated_image->columns-y_width)/2,y_offset+1,background,range_limit);
!   /*
!     Shear the image rows again.
!   */
!   XShearImage(rotated_image,x_shear,y_width,rotated_image->rows-2,
!     (int) (rotated_image->columns-y_width)/2,1,background,range_limit);
!   (void) free((char *) range_table);
!   clipped_image=ClipShearImage(rotated_image,x_shear,y_shear,width,height,clip);
!   DestroyImage(rotated_image);
!   return(clipped_image);
! }
! 
! /*
! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! %                                                                             %
! %                                                                             %
! %                                                                             %
! %   S h e a r I m a g e                                                       %
! %                                                                             %
! %                                                                             %
! %                                                                             %
! %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! %
! %  Function ShearImage creates a new image that is a sheared copy of an
! %  existing one.  Shearing slides one edge of an image along the X or Y
! %  axis, creating a parallelogram.  An X direction shear slides an edge
! %  along the X axis, while a Y direction shear slides an edge along the Y
! %  axis.  The amount of the shear is controlled by a shear angle.  For X
! %  direction shears, x_shear is measured relative to the Y axis, and
! %  similarly, for Y direction shears y_shear is measured relative to the
! %  X axis.  Empty triangles left over from shearing the image are filled
! %  with the color defined by the pixel at location (0,0).  ShearImage
! %  allocates the memory necessary for the new Image structure and returns
! %  a pointer to the new image.
! %
! %  Function ShearImage is based on the paper "A Fast Algorithm for General
! %  Raster Rotatation" by Alan W. Paeth.  
! %
! %  The format of the ShearImage routine is:
! %
! %      ShearImage(image,x_shear,y_shear,clip)
! %
! %  A description of each parameter follows.
! %
! %    o status: Function ShearImage returns a pointer to the image after
! %      rotating.  A null image is returned if there is a memory shortage.
! %
! %    o image: The address of a structure of type Image;  returned from
! %      ReadImage.
! %
! %    o x_shear, y_shear: Specifies the number of degrees to shear the image.
! %
! %    o clip: A value other than zero clips the corners of the rotated
! %      image and retains the original image size.
! %
! %
! */
! Image *ShearImage(image,x_shear,y_shear,clip)
! Image
!   *image;
X  
! double
!   x_shear,
!   y_shear;
X  
! unsigned int
!   clip;
! {
!   ColorPacket
!     background;
X  
!   Image
!     *clipped_image,
!     *sheared_image;
X  
!   int
!     x_offset,
!     y_offset;
X  
!   register int
!     i;
! 
!   unsigned char
!     *range_limit,
!     *range_table;
! 
!   unsigned int
!     y_width;
! 
X    /*
!     Adjust rotation angle.
X    */
!   while (x_shear < -45.0)
!     x_shear+=360.0;
!   while (x_shear > 45.0)
!     x_shear-=90.0;
!   while (y_shear < -45.0)
!     y_shear+=360.0;
!   while (y_shear > 45.0)
!     y_shear-=90.0;
!   x_shear=tan(DegreesToRadians(x_shear)/2.0);
!   y_shear=(-sin(DegreesToRadians(y_shear)));
!   /*
!     Initialize range table.
!   */
!   range_table=(unsigned char *) malloc(3*(MaxRGB+1)*sizeof(unsigned char));
!   if (range_table == (unsigned char *) NULL)
X      {
!       Warning("unable to rotate image","memory allocation failed");
!       return((Image *) NULL);
X      }
+   for (i=0; i <= MaxRGB; i++)
+   {
+     range_table[i]=0;
+     range_table[i+(MaxRGB+1)]=(unsigned char) i;
+     range_table[i+(MaxRGB+1)*2]=MaxRGB;
X    }
!   range_limit=range_table+(MaxRGB+1);
!   /*
!     Compute image size.
!   */
!   y_width=image->columns+(int) ceil(fabs(x_shear)*(double) (image->rows-1));
!   x_offset=(image->columns+2*
!     (int) ceil(fabs(x_shear)*(double) (image->rows-1))-image->columns)/2;
!   y_offset=(image->rows+
!     (int) ceil(fabs(y_shear)*(double) (y_width-1))-image->rows)/2;
!   /*
!     Surround image with border of background color.
!   */
!   background.red=image->pixels[0].red;
!   background.green=image->pixels[0].green;
!   background.blue=image->pixels[0].blue;
!   sheared_image=BorderImage(image,x_offset,y_offset+1,background);
!   if (sheared_image == (Image *) NULL)
!     {
!       Warning("unable to rotate image","memory allocation failed");
!       return((Image *) NULL);
!     }
!   sheared_image->class=DirectClass;
!   /*
!     Shear the image rows.
!   */
!   if (x_shear != 0.0)
!     XShearImage(sheared_image,x_shear,image->columns,image->rows,x_offset,
!       (int) (sheared_image->rows-image->rows)/2+1,background,range_limit);
!   /*
!     Shear the image columns.
!   */
!   if (y_shear != 0.0)
!     YShearImage(sheared_image,y_shear,y_width,image->rows,(int)
!       (sheared_image->columns-y_width)/2,y_offset+1,background,range_limit);
!   (void) free((char *) range_table);
!   clipped_image=ClipShearImage(sheared_image,x_shear,y_shear,image->columns,
!     image->rows,clip);
!   DestroyImage(sheared_image);
!   return(clipped_image);
X  }
Common subdirectories: ImageMagick/scenes and ImageMagick2.2.1/scenes
diff -r -c ImageMagick/signature.c ImageMagick2.2.1/signature.c
*** ImageMagick/signature.c	Mon Dec  7 09:22:50 1992
--- ImageMagick2.2.1/signature.c	Fri Dec 18 17:07:28 1992
***************
*** 73,79 ****
X    External declarations.
X  */
X  extern char
!   *application_name;
X  
X  /*
X    Forward declarations.
--- 73,79 ----
X    External declarations.
X  */
X  extern char
!   *client_name;
X  
X  /*
X    Forward declarations.
Common subdirectories: ImageMagick/utilities and ImageMagick2.2.1/utilities
Common subdirectories: ImageMagick/xtp and ImageMagick2.2.1/xtp
diff -r -c ImageMagick/utilities/Imakefile ImageMagick2.2.1/utilities/Imakefile
*** ImageMagick/utilities/Imakefile	Wed Nov 25 14:22:33 1992
--- ImageMagick2.2.1/utilities/Imakefile	Fri Dec 18 17:47:54 1992
***************
*** 27,33 ****
X  
X  EXTRA_INCLUDES= -I..
X  
! MagickObjects= ../X.o ../image.o ../rotate.o ../quantize.o ../colors.o \
X    ../signature.o ../compress.o ../alien.o ../PreRvIcccm.o
X  
X  CONVERTObjects= convert.o $(MagickObjects)
--- 27,33 ----
X  
X  EXTRA_INCLUDES= -I..
X  
! MagickObjects= ../X.o ../image.o ../shear.o ../quantize.o ../colors.o \
X    ../signature.o ../compress.o ../alien.o ../PreRvIcccm.o
X  
X  CONVERTObjects= convert.o $(MagickObjects)
diff -r -c ImageMagick/utilities/MIFFtoSTEREO.c ImageMagick2.2.1/utilities/MIFFtoSTEREO.c
*** ImageMagick/utilities/MIFFtoSTEREO.c	Mon Dec  7 09:24:56 1992
--- ImageMagick2.2.1/utilities/MIFFtoSTEREO.c	Fri Dec 18 17:08:24 1992
***************
*** 68,74 ****
X    Global declarations.
X  */
X  char
!   *application_name;
X  
X  /*
X  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- 68,74 ----
X    Global declarations.
X  */
X  char
!   *client_name;
X  
X  /*
X  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
***************
*** 101,107 ****
X    *message,
X    *qualifier;
X  {
!   (void) fprintf(stderr,"%s: %s",application_name,message);
X    if (qualifier != (char *) NULL)
X      (void) fprintf(stderr," (%s)",qualifier);
X    (void) fprintf(stderr,".\n");
--- 101,107 ----
X    *message,
X    *qualifier;
X  {
!   (void) fprintf(stderr,"%s: %s",client_name,message);
X    if (qualifier != (char *) NULL)
X      (void) fprintf(stderr," (%s)",qualifier);
X    (void) fprintf(stderr,".\n");
***************
*** 138,144 ****
X      (void) fprintf(stderr,"Can't continue, %s\n\n",message);
X    (void) fprintf(stderr,
X      "Usage: %s left_image.miff right_image.miff stereo_image.miff\n\n",
!     application_name);
X    (void) fprintf(stderr,"Specify 'left_image.miff' or 'right_image.miff' ");
X    (void) fprintf(stderr,"as '-' for standard input.\n");
X    (void) fprintf(stderr,
--- 138,144 ----
X      (void) fprintf(stderr,"Can't continue, %s\n\n",message);
X    (void) fprintf(stderr,
X      "Usage: %s left_image.miff right_image.miff stereo_image.miff\n\n",
!     client_name);
X    (void) fprintf(stderr,"Specify 'left_image.miff' or 'right_image.miff' ");
X    (void) fprintf(stderr,"as '-' for standard input.\n");
X    (void) fprintf(stderr,
***************
*** 177,183 ****
X    time_t
X      start_time;
X  
!   application_name=argv[0];
X    if (argc < 4)
X      Usage((char *) NULL);
X    start_time=time((time_t *) 0);
--- 177,183 ----
X    time_t
X      start_time;
X  
!   client_name=argv[0];
X    if (argc < 4)
X      Usage((char *) NULL);
X    start_time=time((time_t *) 0);
diff -r -c ImageMagick/utilities/Make.com ImageMagick2.2.1/utilities/Make.com
*** ImageMagick/utilities/Make.com	Wed Jun 24 10:40:27 1992
--- ImageMagick2.2.1/utilities/Make.com	Fri Dec 18 17:08:14 1992
***************
*** 11,17 ****
X  $write sys$output "Making Mogrify..."
X  $call Make mogrify
X  $
! $link'link_options' mogrify,[-]X,[-]image,[-]rotate,[-]quantize,[-]colors, -
X    [-]signature,[-]compress,[-]alien,[-]PreRvIcccm,sys$input:/opt
X  sys$share:decw$xlibshr.exe/share
X  $
--- 11,17 ----
X  $write sys$output "Making Mogrify..."
X  $call Make mogrify
X  $
! $link'link_options' mogrify,[-]X,[-]image,[-]shear,[-]quantize,[-]colors, -
X    [-]signature,[-]compress,[-]alien,[-]PreRvIcccm,sys$input:/opt
X  sys$share:decw$xlibshr.exe/share
X  $
***************
*** 23,29 ****
X  $write sys$output "Making Convert..."
X  $call Make convert
X  $
! $link'link_options' convert,[-]X,[-]image,[-]rotate,[-]quantize,[-]colors, -
X    [-]signature,[-]compress,[-]alien,[-]PreRvIcccm,sys$input:/opt
X  sys$share:decw$xlibshr.exe/share
X  $
--- 23,29 ----
X  $write sys$output "Making Convert..."
X  $call Make convert
X  $
! $link'link_options' convert,[-]X,[-]image,[-]shear,[-]quantize,[-]colors, -
X    [-]signature,[-]compress,[-]alien,[-]PreRvIcccm,sys$input:/opt
X  sys$share:decw$xlibshr.exe/share
X  $
***************
*** 35,41 ****
X  $write sys$output "Making MIFFtoSTEREO..."
X  $call Make MIFFtoSTEREO
X  $
! $link'link_options' MIFFtoSTEREO,[-]X,[-]image,[-]rotate,[-]quantize, -
X    [-]colors,[-]signature,[-]compress,[-]alien,[-]PreRvIcccm,sys$input:/opt
X  sys$share:decw$xlibshr.exe/share
X  $
--- 35,41 ----
X  $write sys$output "Making MIFFtoSTEREO..."
X  $call Make MIFFtoSTEREO
X  $
! $link'link_options' MIFFtoSTEREO,[-]X,[-]image,[-]shear,[-]quantize, -
X    [-]colors,[-]signature,[-]compress,[-]alien,[-]PreRvIcccm,sys$input:/opt
X  sys$share:decw$xlibshr.exe/share
X  $
diff -r -c ImageMagick/utilities/Makefile ImageMagick2.2.1/utilities/Makefile
*** ImageMagick/utilities/Makefile	Fri Sep 11 12:04:48 1992
--- ImageMagick2.2.1/utilities/Makefile	Fri Dec 18 17:08:13 1992
***************
*** 45,51 ****
X  DEFINES= -I.. $(JPEG) $(JPEG_INCLUDES) $(TIFF) $(TIFF_INCLUDES)
X  SYS_LIBRARIES= $(XLIB) $(JPEG_LIBRARIES) $(TIFF_LIBRARIES) -lm
X  
! MagickObjects= ../X.o ../image.o ../rotate.o ../quantize.o ../colors.o \
X    ../signature.o ../compress.o ../alien.o ../PreRvIcccm.o
X  
X  ConvertObjects= convert.o $(MagickObjects)
--- 45,51 ----
X  DEFINES= -I.. $(JPEG) $(JPEG_INCLUDES) $(TIFF) $(TIFF_INCLUDES)
X  SYS_LIBRARIES= $(XLIB) $(JPEG_LIBRARIES) $(TIFF_LIBRARIES) -lm
X  
! MagickObjects= ../X.o ../image.o ../shear.o ../quantize.o ../colors.o \
X    ../signature.o ../compress.o ../alien.o ../PreRvIcccm.o
X  
X  ConvertObjects= convert.o $(MagickObjects)
diff -r -c ImageMagick/utilities/convert.c ImageMagick2.2.1/utilities/convert.c
*** ImageMagick/utilities/convert.c	Tue Dec  8 11:16:29 1992
--- ImageMagick2.2.1/utilities/convert.c	Fri Dec 18 17:08:24 1992
***************
*** 81,87 ****
X    Global declarations.
X  */
X  char
!   *application_name;
X  
X  /*
X  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- 81,87 ----
X    Global declarations.
X  */
X  char
!   *client_name;
X  
X  /*
X  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
***************
*** 114,120 ****
X    *message,
X    *qualifier;
X  {
!   (void) fprintf(stderr,"%s: %s",application_name,message);
X    if (qualifier != (char *) NULL)
X      (void) fprintf(stderr," (%s)",qualifier);
X    (void) fprintf(stderr,".\n");
--- 114,120 ----
X    *message,
X    *qualifier;
X  {
!   (void) fprintf(stderr,"%s: %s",client_name,message);
X    if (qualifier != (char *) NULL)
X      (void) fprintf(stderr," (%s)",qualifier);
X    (void) fprintf(stderr,".\n");
***************
*** 163,169 ****
X        (char *) NULL
X      };
X    (void) fprintf(stderr,"Usage: %s [options ...] input_file output_file\n",
!     application_name);
X    (void) fprintf(stderr,"\nWhere options include:\n");
X    for (p=options; *p != (char *) NULL; p++)
X      (void) fprintf(stderr,"  %s\n",*p);
--- 163,169 ----
X        (char *) NULL
X      };
X    (void) fprintf(stderr,"Usage: %s [options ...] input_file output_file\n",
!     client_name);
X    (void) fprintf(stderr,"\nWhere options include:\n");
X    for (p=options; *p != (char *) NULL; p++)
X      (void) fprintf(stderr,"  %s\n",*p);
***************
*** 239,245 ****
X    /*
X      Initialize program variables.
X    */
!   application_name=argv[0];
X    if (argc < 3)
X      Usage();
X    /*
--- 239,245 ----
X    /*
X      Initialize program variables.
X    */
!   client_name=argv[0];
X    if (argc < 3)
X      Usage();
X    /*
***************
*** 470,476 ****
X            Initialize image error attributes.
X          */
X          if (image->class == DirectClass)
!           image->colors=NumberColors(image);
X          total_colors=image->colors;
X        }
X      if (colorspace == GRAYColorspace)
--- 470,476 ----
X            Initialize image error attributes.
X          */
X          if (image->class == DirectClass)
!           image->colors=NumberColors(image,(FILE *) NULL);
X          total_colors=image->colors;
X        }
X      if (colorspace == GRAYColorspace)
diff -r -c ImageMagick/utilities/convert.man ImageMagick2.2.1/utilities/convert.man
*** ImageMagick/utilities/convert.man	Mon Dec  7 09:26:06 1992
--- ImageMagick2.2.1/utilities/convert.man	Sat Dec 19 23:47:16 1992
***************
*** 41,46 ****
--- 41,48 ----
X  .B GRAY
X  Raw gray bytes.
X  .TP 6
+ .B HISTOGRAM
+ .TP 6
X  .B JPEG
X  .TP 6
X  .B MIFF
***************
*** 80,86 ****
X  select image from X server screen; read only.
X  .TP 6
X  .B XC
! constant image of X server background color.
X  .TP 6
X  .B XBM
X  X11 bitmap.
--- 82,88 ----
X  select image from X server screen; read only.
X  .TP 6
X  .B XC
! constant image of X server border color.
X  .TP 6
X  .B XBM
X  X11 bitmap.
diff -r -c ImageMagick/utilities/mogrify.c ImageMagick2.2.1/utilities/mogrify.c
*** ImageMagick/utilities/mogrify.c	Tue Dec  8 11:16:14 1992
--- ImageMagick2.2.1/utilities/mogrify.c	Sat Dec 19 02:32:01 1992
***************
*** 50,55 ****
--- 50,56 ----
X  %  Usage: mogrify [options ...] file [ [options ...] file ...]
X  %
X  %  Where options include:
+ %    -border geometry    surround image with a border of color
X  %    -clip geometry      preferred size and location of the clipped image
X  %    -colormap filename  transform image colors to match this set of colors
X  %    -colors value       preferred number of colors in the image
***************
*** 65,73 ****
--- 66,76 ----
X  %    -noise              reduce noise with a noise peak elimination filter
X  %    -normalize          tranform image to span the full range of colors
X  %    -reflect            reverse image scanlines
+ %    -roll geometry       roll an image vertically or horizontally
X  %    -rotate degrees     apply Paeth rotation to the image
X  %    -scale geometry     preferred size factors of the image
X  %    -scene value        image scene number
+ %    -shear geomatry     slide one edge of the image along the X or Y axis
X  %    -treedepth value    depth of the color classification tree
X  %    -verbose            print detailed information about the image
X  %
***************
*** 95,101 ****
X    Global declarations.
X  */
X  char
!   *application_name;
X  
X  /*
X  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--- 98,104 ----
X    Global declarations.
X  */
X  char
!   *client_name;
X  
X  /*
X  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
***************
*** 128,134 ****
X    *message,
X    *qualifier;
X  {
!   (void) fprintf(stderr,"%s: %s",application_name,message);
X    if (qualifier != (char *) NULL)
X      (void) fprintf(stderr," (%s)",qualifier);
X    (void) fprintf(stderr,".\n");
--- 131,137 ----
X    *message,
X    *qualifier;
X  {
!   (void) fprintf(stderr,"%s: %s",client_name,message);
X    if (qualifier != (char *) NULL)
X      (void) fprintf(stderr," (%s)",qualifier);
X    (void) fprintf(stderr,".\n");
***************
*** 162,167 ****
--- 165,171 ----
X    static char
X      *options[]=
X      {
+       "-border geometry    surround image with a border of color",
X        "-clip geometry      preferred size and location of the clipped image",
X        "-colormap filename  transform image colors to match this set of colors",
X        "-colors value       preferred number of colors in the image",
***************
*** 177,192 ****
X        "-noise              reduce noise with a noise peak elimination filter",
X        "-normalize          tranform image to span the full range of colors",
X        "-reflect            reflect the image scanlines",
X        "-rotate degrees     apply Paeth rotation to the image",
X        "-scale geometry     preferred size factors of the image",
X        "-scene number       image scene number",
X        "-treedepth value    depth of the color classification tree",
X        "-verbose            print detailed information about the image",
X        (char *) NULL
X      };
X    (void) fprintf(stderr,
!     "Usage: %s [-options ...] file [ [-options ...] file ...]\n",
!     application_name);
X    (void) fprintf(stderr,"\nWhere options include: \n");
X    for (p=options; *p != (char *) NULL; p++)
X      (void) fprintf(stderr,"  %s\n",*p);
--- 181,197 ----
X        "-noise              reduce noise with a noise peak elimination filter",
X        "-normalize          tranform image to span the full range of colors",
X        "-reflect            reflect the image scanlines",
+       "-roll geometry      roll an image vertically or horizontally",
X        "-rotate degrees     apply Paeth rotation to the image",
X        "-scale geometry     preferred size factors of the image",
X        "-scene number       image scene number",
+       "-shear geomatry     slide one edge of the image along the X or Y axis",
X        "-treedepth value    depth of the color classification tree",
X        "-verbose            print detailed information about the image",
X        (char *) NULL
X      };
X    (void) fprintf(stderr,
!     "Usage: %s [-options ...] file [ [-options ...] file ...]\n",client_name);
X    (void) fprintf(stderr,"\nWhere options include: \n");
X    for (p=options; *p != (char *) NULL; p++)
X      (void) fprintf(stderr,"  %s\n",*p);
***************
*** 230,240 ****
X      alien_info;
X  
X    char
X      *clip_geometry,
X      *colormap_filename,
X      *image_geometry,
X      *option,
!     *scale_geometry;
X  
X    double
X      gamma;
--- 235,248 ----
X      alien_info;
X  
X    char
+     *border_geometry,
X      *clip_geometry,
X      *colormap_filename,
X      *image_geometry,
X      *option,
!     *roll_geometry,
!     *scale_geometry,
!     *shear_geometry;
X  
X    double
X      gamma;
***************
*** 244,257 ****
X  
X    int
X      degrees,
X      i,
!     x;
! 
X    unsigned int
X      colorspace,
X      compression,
X      dither,
X      enhance,
X      image_number,
X      inverse,
X      maximum_images,
--- 252,268 ----
X  
X    int
X      degrees,
+     flags,
X      i,
!     x,
!     y;
!          
X    unsigned int
X      colorspace,
X      compression,
X      dither,
X      enhance,
+     height,
X      image_number,
X      inverse,
X      maximum_images,
***************
*** 262,273 ****
X      reflect,
X      scene,
X      tree_depth,
!     verbose;
X  
X    /*
X      Display usage profile if there are no command line arguments.
X    */
!   application_name=(*argv);
X    if (argc < 2)
X      Usage();
X    /*
--- 273,285 ----
X      reflect,
X      scene,
X      tree_depth,
!     verbose,
!     width;
X  
X    /*
X      Display usage profile if there are no command line arguments.
X    */
!   client_name=(*argv);
X    if (argc < 2)
X      Usage();
X    /*
***************
*** 274,279 ****
--- 286,292 ----
X      Set defaults.
X    */
X    GetAlienInfo(&alien_info);
+   border_geometry=(char *) NULL;
X    clip_geometry=(char *) NULL;
X    colormap_filename=(char *) NULL;
X    colorspace=RGBColorspace;
***************
*** 289,295 ****
--- 302,310 ----
X    normalize=False;
X    number_colors=0;
X    reflect=False;
+   roll_geometry=(char *) NULL;
X    scale_geometry=(char *) NULL;
+   shear_geometry=(char *) NULL;
X    scene=0;
X    tree_depth=0;
X    verbose=False;
***************
*** 307,312 ****
--- 322,344 ----
X      if (((int) strlen(option) > 1) && ((*option == '-') || (*option == '+')))
X        switch (*(option+1))
X        {
+         case 'b':
+         {
+           if (strncmp("border",option+1,2) == 0)
+             {
+               border_geometry=(char *) NULL;
+               if (*option == '-')
+                 {
+                   i++;
+                   if (i == argc)
+                     Error("missing geometry on -border",(char *) NULL);
+                   border_geometry=argv[i];
+                 }
+               break;
+             }
+           Error("unrecognized option",option);
+           break;
+         }
X          case 'c':
X          {
X            if (strncmp("clip",option+1,2) == 0)
***************
*** 463,469 ****
X          }
X          case 'h':
X          {
!           Usage();
X            break;
X          }
X          case 'i':
--- 495,506 ----
X          }
X          case 'h':
X          {
!           if (strncmp("help",option+1,2) == 0)
!             {
!               Usage();
!               break;
!             }
!           Error("unrecognized option",option);
X            break;
X          }
X          case 'i':
***************
*** 498,503 ****
--- 535,552 ----
X                reflect=(*option == '-');
X                break;
X              }
+           if (strncmp("roll",option+1,3) == 0)
+             {
+               roll_geometry=(char *) NULL;
+               if (*option == '-')
+                 {
+                   i++;
+                   if (i == argc)
+                     Error("missing geometry on -roll",(char *) NULL);
+                   roll_geometry=argv[i];
+                 }
+               break;
+             }
X            if (strncmp("rotate",option+1,3) == 0)
X              {
X                degrees=0;
***************
*** 539,544 ****
--- 588,605 ----
X                  }
X                break;
X              }
+           if (strncmp("shear",option+1,2) == 0)
+             {
+               shear_geometry=(char *) NULL;
+               if (*option == '-')
+                 {
+                   i++;
+                   if ((i == argc) || !sscanf(argv[i],"%f",(float *) &x))
+                     Error("missing shear geometry on -shear",(char *) NULL);
+                   shear_geometry=argv[i];
+                 }
+               break;
+             }
X            Error("unrecognized option",option);
X            break;
X          }
***************
*** 614,619 ****
--- 675,750 ----
X                    image=reflected_image;
X                  }
X              }
+           if (roll_geometry != (char *) NULL)
+             {
+               Image
+                 *rolled_image;
+ 
+               /*
+                 Roll image.
+               */
+               x=0;
+               y=0;
+               flags=XParseGeometry(roll_geometry,&x,&y,&width,&height);
+               rolled_image=RollImage(image,x,y);
+               if (rolled_image != (Image *) NULL)
+                 {
+                   DestroyImage(image);
+                   image=rolled_image;
+                 }
+             }
+           if (border_geometry != (char *) NULL)
+             {
+               Image
+                 *bordered_image;
+ 
+               /*
+                 Surround image with a border of solid.
+               */
+               bordered_image=ReadXCImage("border",(char *) NULL,"1x1");
+               if (bordered_image != (Image *) NULL)
+                 {
+                   ColorPacket
+                     border_color;
+ 
+                   border_color.red=bordered_image->pixels->red;
+                   border_color.green=bordered_image->pixels->green;
+                   border_color.blue=bordered_image->pixels->blue;
+                   DestroyImage(bordered_image);
+                   width=0;
+                   height=0;
+                   flags=XParseGeometry(border_geometry,&x,&y,&width,&height);
+                   bordered_image=BorderImage(image,width,height,border_color);
+                   if (bordered_image != (Image *) NULL)
+                     {
+                       DestroyImage(image);
+                       bordered_image->class=DirectClass;
+                       image=bordered_image;
+                     }
+                 }
+             }
+           if (shear_geometry != (char *) NULL)
+             {
+               float
+                 x_shear,
+                 y_shear;
+ 
+               Image
+                 *sheared_image;
+ 
+               /*
+                 Shear image.
+               */
+               x_shear=0.0;
+               y_shear=0.0;
+               (void) sscanf(shear_geometry,"%fx%f",&x_shear,&y_shear);
+               sheared_image=ShearImage(image,x_shear,y_shear,False);
+               if (sheared_image != (Image *) NULL)
+                 {
+                   DestroyImage(image);
+                   image=sheared_image;
+                 }
+             }
X            if ((degrees % 360) != 0)
X              {
X                Image
***************
*** 671,677 ****
X                  Initialize image error attributes.
X                */
X                if (image->class == DirectClass)
!                 image->colors=NumberColors(image);
X                total_colors=image->colors;
X              }
X            if (colorspace == GRAYColorspace)
--- 802,808 ----
X                  Initialize image error attributes.
X                */
X                if (image->class == DirectClass)
!                 image->colors=NumberColors(image,(FILE *) NULL);
X                total_colors=image->colors;
X              }
X            if (colorspace == GRAYColorspace)
***************
*** 759,764 ****
--- 890,896 ----
X        /*
X          Global colormap option;  reduce colors then write image.
X        */
+       colormap_image=(Image *) NULL;
X        if (colormap_filename != (char *) NULL)
X          {
X            (void) strcpy(alien_info.filename,colormap_filename);
***************
*** 770,776 ****
X        QuantizeImages(images,maximum_images,colormap_image,number_colors,
X          tree_depth,dither,colorspace,True);
X        if (colormap_image != (Image *) NULL)
! 	DestroyImage(colormap_image);
X        for (image_number=0; image_number < maximum_images; image_number++)
X        {
X          (void) WriteAlienImage(images[image_number]);
--- 902,908 ----
X        QuantizeImages(images,maximum_images,colormap_image,number_colors,
X          tree_depth,dither,colorspace,True);
X        if (colormap_image != (Image *) NULL)
!         DestroyImage(colormap_image);
X        for (image_number=0; image_number < maximum_images; image_number++)
X        {
X          (void) WriteAlienImage(images[image_number]);
diff -r -c ImageMagick/utilities/mogrify.man ImageMagick2.2.1/utilities/mogrify.man
*** ImageMagick/utilities/mogrify.man	Mon Dec  7 09:26:14 1992
--- ImageMagick2.2.1/utilities/mogrify.man	Fri Dec 18 17:08:27 1992
***************
*** 21,26 ****
--- 21,33 ----
X      mogrify -colors 256 scenes/birds.*
X  .SH OPTIONS
X  .TP 5
+ .B "-border \fI<width>x<height>fP"
+ surround the image with a border or color.  See \fBX(1)\fP for details
+ about the geometry specification.
+ 
+ The color of the border is obtained from the X server and is defined as
+ \fBbackground\fP (class \fBBackground\fP).  See \fBX(1)\fP for details.
+ .TP 5
X  .B "-clip \fI<width>x<height>{\+-}<x offset>{\+-}<y offset>\fP"
X  preferred size and location of the clipped image.  See \fBX(1)\fP for details
X  about the geometry specification.
***************
*** 28,33 ****
--- 35,52 ----
X  Use clipping to apply image processing options, or transmogrify, only a
X  particular area of an image.
X  .TP 5
+ .B "-colormap \fIfilename\fP"
+ choose a particular set of colors from this image.
+ 
+ By default, color reduction chooses an optimal set of colors that
+ best represent the original image.  Alternatively, you can choose a
+ particular set of colors with this option.  This is useful when
+ you want to create a sequence of images with one particular set of
+ colors for each image.
+ 
+ The \fB-colors\fP or \fB-monochrome\fP option is required
+ for this option to take effect.
+ .TP 5
X  .B "-colors \fIvalue\fP"
X  preferred number of colors in the image.
X  
***************
*** 39,46 ****
X  If more than one image is specified on the command line, a single
X  colormap is created and saved with each image.
X  
! Note, options \fB-dither\fP, \fB-colorspace\fP, and \fB-treedepth\fP affect
! the color reduction algorithm.
X  .TP 5
X  .B "-colorspace \fIvalue\fP"
X  the type of colorspace: \fIGRAY\fP, \fIRGB\fP, \fIXYZ\fP, \fIYIQ\fP, or
--- 58,65 ----
X  If more than one image is specified on the command line, a single
X  colormap is created and saved with each image.
X  
! Note, options \fB-colormap\fP, \fB-dither\fP, \fB-colorspace\fP, and
! \fB-treedepth\fP affect the color reduction algorithm.
X  .TP 5
X  .B "-colorspace \fIvalue\fP"
X  the type of colorspace: \fIGRAY\fP, \fIRGB\fP, \fIXYZ\fP, \fIYIQ\fP, or
***************
*** 137,144 ****
--- 156,174 ----
X  .B "-reflect"
X  create a "mirror image" by reflecting the image scanlines.
X  .TP 5
+ .B "-roll \fI{\+-}<x offset>{\+-}<y offset>\fP"
+ roll an image vertically or horizontally.  See \fBX(1)\fP for details
+ about the geometry specification.
+  
+ A negative \fIx offset\fP rolls the image left-to-right.  A negative
+ \fIy offset\fP rolls the image top-to-bottom.
+ .TP 5
X  .B "-rotate \fIdegrees\fP"
X  apply Paeth image rotation to the image.
+ 
+ Empty triangles left over from rotating the image are filled with the
+ color defined by the pixel at location (0,0).  Refer to \fB-border\fP
+ to choose a specific color.
X  .TP 5
X  .B "-scale \fI<width factor>x<height factor>\fP"
X  preferred size factors of the image.
***************
*** 149,159 ****
X  one factor is specified, both the width and height factors assume the
X  value.
X  
! Factors may be fractional.  For example, a factor of 1.5 will increase the
! image size by one and one-half.
X  .TP 5
X  .B "-scene \fIvalue\fP"
X  image scene number.
X  .TP 5
X  .B "-treedepth \fIvalue\fP"
X  Normally, this integer value is zero or one.  A zero or one tells
--- 179,204 ----
X  one factor is specified, both the width and height factors assume the
X  value.
X  
! Factors may be fractional.  To increase the size of an image, use a
! scale factor greater than 1.0.  To decrease an image's size, use a
! scale factor less than 1.0.  Default is 1.0.
X  .TP 5
X  .B "-scene \fIvalue\fP"
X  image scene number.
+ .TP 5
+ .B "-shear \fI<x degrees>x<y degrees>\fP"
+ shear the image along the X or Y axis by a positive or negative shear angle.
+ 
+ Shearing slides one edge of an image along the X or Y axis, creating a
+ parallelogram.  An X direction shear slides an edge along the X axis,
+ while a Y direction shear slides an edge along the Y axis.  The amount
+ of the shear is controlled by a shear angle.  For X direction shears,
+ \fIx degrees>\fP is measured relative to the Y axis, and similarly, for
+ Y direction shears \fIy degrees\fP is measured relative to the X axis.
+ 
+ Empty triangles left over from shearing the image are filled with the
+ color defined by the pixel at location (0,0).  Refer to \fB-border\fP
+ to choose a specific color.
X  .TP 5
X  .B "-treedepth \fIvalue\fP"
X  Normally, this integer value is zero or one.  A zero or one tells
diff -r -c ImageMagick/xtp/xtp.c ImageMagick2.2.1/xtp/xtp.c
*** ImageMagick/xtp/xtp.c	Mon Dec  7 09:28:48 1992
--- ImageMagick2.2.1/xtp/xtp.c	Mon Dec 21 12:54:03 1992
***************
*** 88,94 ****
X    Variable declarations.
X  */
X  static char
!   *application_name,
X    slave_tty[16];
X  
X  static int
--- 88,94 ----
X    Variable declarations.
X  */
X  static char
!   *client_name,
X    slave_tty[16];
X  
X  static int
***************
*** 187,193 ****
X    *message,
X    *qualifier;
X  {
!   (void) fprintf(stderr,"%s: %s",application_name,message);
X    if (qualifier != (char *) NULL)
X      (void) fprintf(stderr," (%s)",qualifier);
X    (void) fprintf(stderr,".\n");
--- 187,193 ----
X    *message,
X    *qualifier;
X  {
!   (void) fprintf(stderr,"%s: %s",client_name,message);
X    if (qualifier != (char *) NULL)
X      (void) fprintf(stderr," (%s)",qualifier);
X    (void) fprintf(stderr,".\n");
***************
*** 940,946 ****
X      };
X    (void) fprintf(stderr,
X      "Usage: %s [-options ...] <host/ip address> [ <home directory> ]\n",
!     application_name);
X    (void) fprintf(stderr,"\nWhere options include:\n");
X    for (p=options; *p; p++)
X      (void) fprintf(stderr,"  %s\n",*p);
--- 940,946 ----
X      };
X    (void) fprintf(stderr,
X      "Usage: %s [-options ...] <host/ip address> [ <home directory> ]\n",
!     client_name);
X    (void) fprintf(stderr,"\nWhere options include:\n");
X    for (p=options; *p; p++)
X      (void) fprintf(stderr,"  %s\n",*p);
***************
*** 1072,1078 ****
X    /*
X      Initialize program variables.
X    */
!   application_name=argv[0];
X    binary=False;
X    directory_expression=(RegularExpression *) NULL;
X    exclude_expression=(RegularExpression *) NULL;
--- 1072,1078 ----
X    /*
X      Initialize program variables.
X    */
!   client_name=argv[0];
X    binary=False;
X    directory_expression=(RegularExpression *) NULL;
X    exclude_expression=(RegularExpression *) NULL;
diff -r -c ImageMagick/xtp/xtp.h ImageMagick2.2.1/xtp/xtp.h
*** ImageMagick/xtp/xtp.h	Mon Dec  7 09:29:01 1992
--- ImageMagick2.2.1/xtp/xtp.h	Mon Dec 21 12:53:04 1992
***************
*** 31,37 ****
X  #define True  1
X  #define Warning(message,qualifier)  \
X  {  \
!   (void) fprintf(stderr,"%s: %s",application_name,message);  \
X    if (qualifier != (char *) NULL)  \
X      (void) fprintf(stderr," (%s)",qualifier);  \
X    (void) fprintf(stderr,".\n");  \
--- 31,37 ----
X  #define True  1
X  #define Warning(message,qualifier)  \
X  {  \
!   (void) fprintf(stderr,"%s: %s",client_name,message);  \
X    if (qualifier != (char *) NULL)  \
X      (void) fprintf(stderr," (%s)",qualifier);  \
X    (void) fprintf(stderr,".\n");  \
SHAR_EOF
echo 'File fix-01 is complete' &&
chmod 0600 fix-01 ||
echo 'restore of fix-01 failed'
Wc_c="`wc -c < 'fix-01'`"
test 192393 -eq "$Wc_c" ||
	echo 'fix-01: original size 192393, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
rm -f _shar_seq_.tmp
echo You have unpacked the last part
exit 0
-- 
cristy@dupont.com

exit 0 # Just in case...
