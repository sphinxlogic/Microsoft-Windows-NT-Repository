Newsgroups: comp.sources.misc
From: cristy@eplrx7.es.duPont.com (John Cristy)
Subject:  v34i032:  imagemagick - X11 image processing and display v2.2, Part04/26
Message-ID: <1992Dec13.202628.9134@sparky.imd.sterling.com>
X-Md4-Signature: dec96e78722fbf562d89c95274db03a9
Date: Sun, 13 Dec 1992 20:26:28 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: cristy@eplrx7.es.duPont.com (John Cristy)
Posting-number: Volume 34, Issue 32
Archive-name: imagemagick/part04
Environment: UNIX, VMS, X11, SGI, DEC, Cray, Sun, Vax

#!/bin/sh
# this is Part.04 (part 4 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file ImageMagick/xtp/xtp.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 4; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping ImageMagick/xtp/xtp.c'
else
echo 'x - continuing file ImageMagick/xtp/xtp.c'
sed 's/^X//' << 'SHAR_EOF' >> 'ImageMagick/xtp/xtp.c' &&
%
%  A description of each parameter follows:
%
%    o prune:  Specifies whether to recusively search for files.
%
%    o verbose: An unsigned integer.  A value other than zero dhows all
%      responses from the remote server.
%
%
*/
static void ProcessRequest(prune,verbose)
unsigned int
X  prune,
X  verbose;
{
X  typedef struct _DirectoryNode
X  {
X    char
X      *info,
X      *name;
X
X    struct _DirectoryNode
X      *next;
X  } DirectoryNode;
X
X  char
X    command[2048],
X    directory[2048],
X    *info,
X    *name,
X    *response;
X
X  DirectoryNode
X    *next,
X    *root;
X
X  register char
X    *p;
X
X  register DirectoryNode
X    **last,
X    *node;
X
X  RegularExpression
X    *date_expression,
X    *mode_expression;
X
X  unsigned int
X    unix_filesystem;
X
X  /*
X    Initialize function variables.
X  */
X  root=(DirectoryNode *) NULL;
X  last=(&root);
X  *directory='\0';
X  unix_filesystem=False;
X  if (!prune)
X    {
X      /*
X        Obtain a time sorted recursive directory if available.
X      */
X      (void) strcpy(command,"get ls-ltR.Z |zcat\r");
X      (void) write(master,command,strlen(command));
X      while (response=Wait())
X        if ((status == 0) || (status == 5))
X          break;
X      if (status == 5)
X        {
X          /*
X            Obtain a recursive directory if available.
X          */
X          while (Wait());
X          (void) strcpy(command,"get ls-lR.Z |zcat\r");
X          (void) write(master,command,strlen(command));
X          while (response=Wait())
X            if ((status == 0) || (status == 5))
X              break;
X        }
X      if (status == 5)
X        while (Wait());
X      else
X        {
X          (void) fprintf(stderr,"Using existing directory listing...\n");
X          unix_filesystem=True;
X        }
X    }
X  if (prune || !unix_filesystem)
X    {
X      /*
X        Determine if the FTP server has unix-style filenames.
X      */
X      mode_expression=CompileRegularExpression("^.[rwx-][rwx-][rwx-]");
X      (void) strcpy(command,"dir\r");
X      (void) write(master,command,strlen(command));
X      while (response=Wait())
X        if (!unix_filesystem)
X          if (*response != '\0')
X            unix_filesystem=ExecuteRegularExpression(mode_expression,response);
X      (void) free((char *) mode_expression);
X      /*
X        Obtain recursive directory listing with the FTP directory command.
X      */
X      if (prune)
X        (void) strcpy(command,"dir\r");
X      else
X        if (unix_filesystem)
X          (void) strcpy(command,"ls -ltR\r");
X        else
X          (void) strcpy(command,"ls [...]\r");
X      (void) write(master,command,strlen(command));
X      while (response=Wait())
X        if ((status == 0) || (status == 5))
X          break;
X      if (status == 5)
X        {
X          /*
X            Directory command has limited functionality.
X          */
X          while (Wait());
X          (void) strcpy(command,"dir\r");
X          (void) write(master,command,strlen(command));
X          while (response=Wait())
X            if (status == 0)
X              break;
X        }
X    }
X  status=(-1);
X  if (response == (char *) NULL)
X    return;
X  if (!unix_filesystem)
X    do
X    {
X      /*
X        Link non unix-style file into file list.
X      */
X      if ((status > 0) || (*response == '\0'))
X        continue;
X      while (*response == ' ')
X        response++;
X      /*
X        Extract file name & info.
X      */
X      name=response;
X      info=response;
X      while ((*info != ' ') && *info)
X        info++;
X      *info='\0';
X      node=(DirectoryNode *) malloc(sizeof(DirectoryNode));
X      if (node == (DirectoryNode *) NULL)
X        Error("unable to allocate memory",(char *) NULL);
X      node->name=(char *) malloc((strlen(name)+1)*sizeof(char));
X      node->info=(char *) malloc((strlen(info)+1)*sizeof(char));
X      if ((node->name == (char *) NULL) || (node->info == (char *) NULL))
X        Error("unable to allocate memory",(char *) NULL);
X      (void) strcpy(node->name,name);
X      (void) strcpy(node->info,info);
X      node->next=(DirectoryNode *) NULL;
X      if (exclude_expression)
X        if (ExecuteRegularExpression(exclude_expression,node->name))
X          {
X            /*
X              Free allocated memory for this node.
X            */
X            (void) free((char *) node->info);
X            (void) free((char *) node->name);
X            (void) free((char *) node);
X            continue;
X          }
X      *last=node;
X      last=(&node->next);
X    }
X    while (response=Wait());
X  else
X    {
X      RegularExpression
X        *access_expression;
X
X      access_expression=
X        CompileRegularExpression("Permission denied|not found|cannot access");
X      date_expression=
X        CompileRegularExpression(" [0-9][0-9][0-9][0-9]|[0-9][0-9]:[0-9][0-9]");
X      do
X      {
X        /*
X           Link unix-style file into file list.
X        */
X        if ((status > 0) || (*response == '\0'))
X          continue;
X        while (*response == ' ')
X          response++;
X        p=response+strlen(response)-1;
X        if ((*response == '-') || (*response == 'F'))
X          {
X            if (ExecuteRegularExpression(access_expression,response))
X              continue;
X            /*
X              Extract file info & name.
X            */
X            while (p-- > (response+5))
X              if (*p == ' ')
X                if (!ExecuteRegularExpression(date_expression,p-5))
X                  *p='_';
X                else
X                  break;
X            *p++='\0';
X            while (*p == ' ')
X              p++;
X            name=p;
X            info=response;
X            node=(DirectoryNode *) malloc(sizeof(DirectoryNode));
X            if (node == (DirectoryNode *) NULL)
X              Error("unable to allocate memory",(char *) NULL);
X            node->name=(char *) malloc(strlen(directory)+strlen(name)+1);
X            node->info=(char *) malloc(strlen(info)+1);
X            if ((node->name == (char *) NULL) || (node->info == (char *) NULL))
X              Error("unable to allocate memory",(char *) NULL);
X            (void) strcpy(node->name,directory);
X            (void) strcat(node->name,name);
X            (void) strcpy(node->info,info);
X            node->next=(DirectoryNode *) NULL;
X            if (exclude_expression)
X              if (ExecuteRegularExpression(exclude_expression,node->name))
X                {
X                  /*
X                    Free allocated memory for this node.
X                  */
X                  (void) free((char *) node->info);
X                  (void) free((char *) node->name);
X                  (void) free((char *) node);
X                  continue;
X                }
X            *last=node;
X            last=(&node->next);
X          }
X        else
X          if (*p == ':')
X            {
X              /*
X                File is a directory.
X              */
X              do { p--; } while (*p == ' ');
X              *(++p)='\0';
X              (void) strcpy(directory,response);
X              (void) strcat(directory,"/");
X            }
X      }
X      while (response=Wait());
X      (void) free((char *) access_expression);
X      (void) free((char *) date_expression);
X    }
X  /*
X    Traverse the file list and act on a filename if it matches the regular
X    expression.
X  */
X  status=(-1);
X  node=root;
X  while (node)
X  {
X    if (directory_expression)
X      if (ExecuteRegularExpression(directory_expression,node->name))
X        (void) DirectoryRequest(node->info,node->name);
X    if (print_expression)
X      if (ExecuteRegularExpression(print_expression,node->name))
X        (void) PrintRequest(node->name,verbose);
X    if (retrieve_expression)
X      if (ExecuteRegularExpression(retrieve_expression,node->name))
X        (void) RetrieveRequest(node->name,verbose);
X    /*
X      Free allocated memory for this node.
X    */
X    (void) free((char *) node->info);
X    (void) free((char *) node->name);
X    next=node->next;
X    (void) free((char *) node);
X    node=next;
X  }
X  if (status < 0)
X    Warning("no files matched your expression",(char *) NULL);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   R e t r i e v e R e q u e s t                                             %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function RetrieveRequest retrieves a file from the remote FTP server.
%
%  The format of the RetrieveRequest routine is:
%
%    RetrieveRequest(filename,verbose)
%
%  A description of each parameter follows:
%
%    o filename:  Specifies a pointer to a character array that contains
%      the name of the file to retrieve.
%
%    o verbose: An unsigned integer.  A value other than zero dhows all
%      responses from the remote server.
%
%
*/
static void RetrieveRequest(filename,verbose)
char
X  *filename;
X
unsigned int
X  verbose;
{
X  char
X    command[2048],
X    *response;
X
X  /*
X    get remote-file
X  */
X  (void) MakeDirectory(filename);
X  (void) sprintf(command,"get %s\r",filename);
X  (void) write(master,command,strlen(command));
X  while (response=Wait())
X    if (status == 0)
X      (void) fprintf(stdout,"%s\n",response);
X    else
X      if ((status == 5) || verbose)
X        (void) fprintf(stderr,"%s\n",response);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   S i g n a l C h i l d                                                     %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function SignalChild is called if the status of the child process changes.
%
%  The format of the SignalChild routine is:
%
%    SignalChild()
%
%
*/
static void SignalChild()
{
X  char
X    message[2048];
X
X  int
X    process_status;
X
X  while (waitpid((pid_t) NULL,&process_status,WNOHANG) > 0);
X  (void) sprintf(message,"child died, status %x",process_status);
X  Error(message,(char *) NULL);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   U s a g e                                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Procedure Usage displays the program usage;
%
%  The format of the Usage routine is:
%
%      Usage()
%
%
*/
static void Usage()
{
X  char
X    **p;
X
X  static char
X    *options[]=
X    {
X      "-binary                retrieve files as binary",
X      "-exclude expression    exclude files that match the expression",
X      "-directory expression  list file names that match the expression",
X      "-ident password        specifies password",
X      "-port number           port number of FTP server",
X      "-print expression      print files that match the expression",
X      "-prune                 do not recursively search for files",
X      "-retrieve expression   retrieve files that match the expression",
X      "-send expression       send files that match the expression",
X      "-timeout seconds       specifies maximum seconds of XTP session",
X      "-user name             identify yourself to the remote FTP server",
X      "-verbose               show all responses from the remote server",
X      NULL
X    };
X  (void) fprintf(stderr,
X    "Usage: %s [-options ...] <host/ip address> [ <home directory> ]\n",
X    application_name);
X  (void) fprintf(stderr,"\nWhere options include:\n");
X  for (p=options; *p; p++)
X    (void) fprintf(stderr,"  %s\n",*p);
X  exit(1);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   W a i t                                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function Wait reads a line of output from the remote FTP server.
%
%  The format of the Wait() routine is:
%
%    response=Wait()
%
%  A description of each parameter follows:
%
%    o response:  Function Wait returns this pointer to the output obtained
%      from the remote FTP server.
%
%
*/
static char *Wait()
{
X  register char
X    *p;
X
X  static char
X    buffer[1024],
X    *q;
X
X  static char
X    line[1024];
X
X  static int
X    count=0;
X
X  status=0;
X  p=line;
X  do
X  {
X    if (count <= 0)
X      {
X        /*
X          The buffer is empty;  read output from the remote FTP server.
X        */
X        count=read(master,buffer,sizeof(buffer));
X        q=buffer;
X        if (count <= 0)
X          {
X            if (p == line)
X              return((char *) NULL);
X            break;
X          }
X      }
X    count--;
X    *p=(*q++);
X    if (*p == '\n')
X      break;
X    p++;
X    if ((p-line) >= 5)
X      if (!strncmp(p-5,"ftp> ",5))
X        if (count == 0)
X          return((char *) NULL);
X  } while (p < (line+sizeof(line)));
X  *p='\0';
X  if (isdigit(*line))
X    status=atoi(line)/100;
X  return(line);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   m a i n                                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
*/
main(argc,argv)
int
X  argc;
X
register char
X  **argv;
{
#include <pwd.h>
X
X  char
X    command[2048],
X    *home_directory,
X    *host_info,
X    *host_name,
X    *ident,
X    *port,
X    *send_expression,
X    *user;
X
X  int
X    binary,
X    child,
X    process_status;
X
X  register char
X    *p,
X    *response;
X
X  struct sigaction
X    action;
X
X  unsigned int
X    prune,
X    timeout,
X    verbose;
X
X  /*
X    Initialize program variables.
X  */
X  application_name=argv[0];
X  binary=False;
X  directory_expression=(RegularExpression *) NULL;
X  exclude_expression=(RegularExpression *) NULL;
X  ident=(char *) NULL;
X  port=(char *) NULL;
X  print_expression=(RegularExpression *) NULL;
X  prune=False;
X  retrieve_expression=(RegularExpression *) NULL;
X  send_expression=(char *) NULL;
X  timeout=0;
X  user=(char *) NULL;
X  verbose=False;
X  /*
X    Parse command line arguments.
X  */
X  for (p=(*argv++); *argv && (**argv == '-'); argv++)
X    switch (argv[0][1])
X    {
X      case 'b':
X      {
X        binary=True;
X        break;
X      }
X      case 'd':
X      {
X        directory_expression=CompileRegularExpression(*++argv);
X        if (!directory_expression)
X          exit(1);
X        break;
X      }
X      case 'e':
X      {
X        exclude_expression=CompileRegularExpression(*++argv);
X        if (!exclude_expression)
X          exit(1);
X        break;
X      }
X      case 'i':
X      {
X        ident=(*++argv);
X        break;
X      }
X      case 'p':
X      {
X        if (strncmp("port",*argv+1,2) == 0)
X          port=(*++argv);
X        else
X          if (strncmp("prune",*argv+1,3) == 0)
X            prune=(**argv == '-');
X          else
X            {
X              print_expression=CompileRegularExpression(*++argv);
X              if (!print_expression)
X                exit(1);
X            }
X        break;
X      }
X      case 'r':
X      {
X        retrieve_expression=CompileRegularExpression(*++argv);
X        if (!retrieve_expression)
X          exit(1);
X        break;
X      }
X      case 's':
X      {
X        send_expression=(*++argv);
X        break;
X      }
X      case 't':
X      {
X        timeout=atoi(*++argv);
X        break;
X      }
X      case 'u':
X      {
X        user=(*++argv);
X        break;
X      }
X      case 'v':
X      {
X        verbose=True;
X        break;
X      }
X      default:
X      {
X        Error("unrecognized option",(char *) NULL);
X        break;
X      }
X    }
X  if ((argc < 2) || (*argv == (char *) NULL))
X    Usage();
X  host_name=argv[0];
X  home_directory=argv[1];
X  if ((directory_expression == (RegularExpression *) NULL) &&
X      (print_expression == (RegularExpression *) NULL) &&
X      (retrieve_expression == (RegularExpression *) NULL) &&
X      (send_expression == (char *) NULL))
X    directory_expression=CompileRegularExpression("");
X  if ((ident == (char *) NULL) && (user == (char *) NULL))
X    {
X      static char
X        name[2048];
X
X      struct passwd
X        *user_info;
X
X      /*
X        Identify user as user@host.domain.
X      */
X      user_info=getpwuid(geteuid());
X      if (user_info == (struct passwd *) NULL)
X        (void) strcpy(name,"anonymous");
X      else
X        (void) strcpy(name,user_info->pw_name);
X      p=name+strlen(name);
X      *p++='@';
X      (void) gethostname(p,64);
X      while (*p)
X        p++;
X      *p++='.';
X      (void) getdomainname(p,64);
X      user="anonymous";
X      ident=name;
X    }
X  else
X    if (ident == (char *) NULL)
X      ident=(char *) GetPassword("Password: ");
X    else
X      if (user == (char *) NULL)
X        user="anonymous";
X  host_info=GetHostInfo(host_name);
X  if (host_info == (char *) NULL)
X    Error("unknown host",host_name);
X  if (home_directory == (char *) NULL)
X    (void) fprintf(stdout,"%s\n",host_info);
X  else
X    (void) fprintf(stdout,"%s %s\n",host_info,home_directory);
X  (void) GetPseudoTerminal();
X  /*
X    Connect and logon to host.
X  */
X  action.sa_handler=SignalChild;
X  (void) sigemptyset(&action.sa_mask);
X  action.sa_flags=0;
X  (void) sigaction(SIGCHLD,&action,(struct sigaction *) NULL);
X  if (timeout > 0)
X    (void) alarm(timeout/10);  /* enable login timer. */
X  child=fork();
X  if (child < 0)
X    Error("unable to fork",(char *) NULL);
X  if (child == 0)
X    ExecuteFtp(host_name,port);
X  while (response=Wait())
X    if (verbose)
X      (void) fprintf(stderr,"%s\n",response);
X  (void) sprintf(command,"user %s %s\r",user,ident);
X  (void) write(master,command,strlen(command));
X  while (response=Wait())
X  {
X    if (verbose)
X      (void) fprintf(stderr,"%s\n",response);
X    if (status == 5)
X      Error(response,user);
X  }
X  if (timeout > 0)
X    (void) alarm(timeout);  /* enable session timer. */
X  if (home_directory != (char *) NULL)
X    {
X      /*
X        Change remote working directory.
X      */
X      (void) sprintf(command,"cd %s\r",home_directory);
X      (void) write(master,command,strlen(command));
X      while (response=Wait())
X      {
X        if (verbose)
X          (void) fprintf(stderr,"%s\n",response);
X        if (status == 5)
X          Error("no such directory",home_directory);
X      }
X      (void) strcpy(command,"pwd\r");
X      (void) write(master,command,strlen(command));
X      while (response=Wait())
X        if (verbose)
X          (void) fprintf(stderr,"%s\n",response);
X    }
X  if (binary)
X    {
X      /*
X        Set file transfer type.
X      */
X      (void) strcpy(command,"binary\r");
X      (void) write(master,command,strlen(command));
X      while (response=Wait())
X        if (verbose)
X          (void) fprintf(stderr,"%s\n",response);
X      (void) strcpy(command,"type\r");
X      (void) write(master,command,strlen(command));
X      while (response=Wait())
X        if (verbose)
X          (void) fprintf(stderr,"%s\n",response);
X    }
X  if (retrieve_expression != (RegularExpression *) NULL)
X    {
X      /*
X        Ensure retrieved files are unique.
X      */
X      (void) strcpy(command,"runique\r");
X      (void) write(master,command,strlen(command));
X      while (response=Wait())
X        if (verbose)
X          (void) fprintf(stderr,"%s\n",response);
X    }
X  if (send_expression == (char *) NULL)
X    ProcessRequest(prune,verbose);
X  else
X    {
X      /*
X        Process send request.
X      */
X      (void) strcpy(command,"glob on\r");
X      (void) write(master,command,strlen(command));
X      while (response=Wait())
X        if (verbose)
X          (void) fprintf(stderr,"%s\n",response);
X      (void) sprintf(command,"mput %s\r",send_expression);
X      (void) write(master,command,strlen(command));
X      while (response=Wait())
X        if ((status == 5) || verbose)
X          (void) fprintf(stderr,"%s\n",response);
X    }
X  (void) strcpy(command,"quit\r");
X  (void) write(master,command,strlen(command));
X  /*
X    Wait for child to finish.
X  */
X  action.sa_handler=SIG_DFL;
X  (void) sigemptyset(&action.sa_mask);
X  action.sa_flags=0;
X  (void) sigaction(SIGCHLD,&action,(struct sigaction *) NULL);
X  (void) waitpid(child,&process_status,WNOHANG);
X  (void) close(master);
X  (void) free((char *) directory_expression);
X  (void) free((char *) exclude_expression);
X  (void) free((char *) print_expression);
X  (void) free((char *) retrieve_expression);
X  return(status < 0);
}
SHAR_EOF
echo 'File ImageMagick/xtp/xtp.c is complete' &&
chmod 0644 ImageMagick/xtp/xtp.c ||
echo 'restore of ImageMagick/xtp/xtp.c failed'
Wc_c="`wc -c < 'ImageMagick/xtp/xtp.c'`"
test 41314 -eq "$Wc_c" ||
	echo 'ImageMagick/xtp/xtp.c: original size 41314, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/xtp/xtp.man ==============
if test -f 'ImageMagick/xtp/xtp.man' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/xtp/xtp.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/xtp/xtp.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/xtp/xtp.man' &&
.ad l
.nh
.TH XTP 1 "10 October 1992"
.SH NAME
xtp - file transfer program
.SH SYNOPSIS
.B "xtp"
[ \fI-options\fP ... ] \fI<host/ip address>\fP [ \fI<home directory>\fP ]
.SH DESCRIPTION
.PP
.I Xtp
is a utility for retrieving, listing, or printing files from a remote
network site, or sending files to a remote network site.
.I Xtp
performs most of the same functions as the \fIftp\fP program, but does
not require any interactive commands.  You simply specify the file transfer
task on the command line and \fIxtp\fP performs the task automatically.
.SH EXAMPLES
.PP
To retrieve file display.tar.Z from host wizard.dupont.com, use:
.PP
X     xtp -binary -retrieve display.tar.Z wizard.dupont.com
.PP
To retrieve all the files from directory \fIpublic/documents\fP from host
wizard.dupont.com, use:
.PP
X     xtp -binary -retrieve documents/ wizard.dupont.com public
.PP
.SH OPTIONS
.TP
.B "-binary"
retrieve files as binary.
.TP
.B "-exclude \fIexpression\fP"
exclude files that match the \fIregular expression\fP.
.TP
.B "-directory \fIexpression\fP"
list the names of files and their attributes that match the
\fIregular expression\fP.
.TP
.B "-ident \fIpassword\fP"
specifies password.
.TP
.B "-port \fInumber\fP"
If no port number is specified, xtp attempts to contact a FTP server
at the default port.  Otherwise, the specfied port number is used.
.TP
.B "-print \fIexpression\fP"
print files that match the \fIregular expression\fP.
.TP
.B "-prune"
do not recursively search for files.
.TP
.B "-retrieve \fIexpression\fP"
retrieve files that match the \fIregular expression\fP.
X
Retrieved files are stored on your local host directory as the full
name of the retrieved file.  For example, if the retrieved file is
named \fIdocuments/xtp.man\fP on the remote FTP server, it will appear
in your home directory as \fIdocuments/xtp.man\fP.
.TP
.B "-send \fIexpression\fP"
send files that match the \fIregular expression\fP.
.TP
.B "-timeout \fIseconds\fP"
specifies the maximum seconds to complete your remote FTP server request.
If this time expires, the program terminates.  The program also terminates if
one tenth of this value is exceeded while logging onto the remote FTP
server.
.TP
.B "-user \fIname\fP"
identify yourself to the remote FTP server.
.PP
If \fB-user\fP is specified but not \fB-ident\fP, the password is obtained
from you interactively.
.TP
.B "-verbose"
show all responses from the remote server.
.PP
If neither \fB-print\fP, \fB-retrieve\fP, or \fB-send\fP are specified
on the command line, a directory of files is listed for the remote
network host.
.PP
\fIxtp\fP recursively descends the directory hierarchy from the home
directory. Some remote hosts may have thousands of files causing a
significant delay satisfying your request.  This can be wasteful if the
files you are interested in reside in a known directory.  You can
reduce the searching required by specifying \fI<home directory>\fP on
the command line.  This limits the filename search to the specified
directory and any of its subdirectories.  Alternatively, \fB-prune\fP
restricts the search to the home directory only.
.PP
If only the program name is specified on the command line, the program command
syntax and options are listed.
.SH REGULAR EXPRESSIONS
A \fIregular expression\fP is zero or more branches, separated by
\fB|\fP.  It matches anything that matches one of the branches.
.PP
A branch is zero or more pieces, concatenated.  It matches a match for
the first, followed by a match for the second, etc.
.PP
A piece is an atom possibly followed by \fB*\fP, \fB+\fP, or \fB?\fP.
An atom followed by \fB*\fP matches a sequence of 0 or more matches of
the atom.  An atom followed by \fB+\fP matches a sequence of 1 or more
matches of the atom.  An atom followed by \fB?\fP matches a match of
the atom, or the null pattern.
.PP
An atom is a \fIregular expression\fP in parentheses (matching a match
for the \fIregular expression\fP), a range (see below), \fB.\fP
(matching any single character), \fB^\fP (matching the null pattern at
the beginning of the input pattern), \fB$\fP (matching the null pattern
at the end of the input pattern), a \fB\'\fP followed by a single
character (matching that character), or a single character with no
other significance (matching that character).
.PP
A range is a sequence of characters enclosed in \fB[]\fP.  It normally
matches any single character from the sequence.  If the sequence begins
with \fB^\fP, it matches any single character not from the rest of the
sequence.  If two characters in the sequence are separated by \fB-\fP,
this is shorthand for the full list of ASCII characters between them
(e.g.  \fB[0-9]\fP matches any decimal digit). To include a literal
\fB]\fP in the sequence, make it the first character (following a
possible \fB^\fP).  To include a literal \fB-\fP, make it the first or
last character.
.SH SEE ALSO
ftp(1C)
.SH COPYRIGHT
Copyright 1990 E. I. Dupont de Nemours & Company
.PP
Permission to use, copy, modify, distribute, and sell this software and
its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of E. I. Dupont de Nemours
& Company not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior
permission.  E. I. Dupont de Nemours & Company makes no representations
about the suitability of this software for any purpose.  It is provided
"as is" without express or implied warranty.
.PP
E. I. Dupont de Nemours & Company disclaims all warranties with regard
to this software, including all implied warranties of merchantability
and fitness, in no event shall E. I. Dupont de Nemours & Company be
liable for any special, indirect or consequential damages or any
damages whatsoever resulting from loss of use, data or profits, whether
in an action of contract, negligence or other tortious action, arising
out of or in connection with the use or performance of this software.
.SH ACKNOWLEDGEMENTS
Steve Singles, University of Delaware, for the initial implementation of
this program.
.PP
Henry Spencer, University of Toronto, for the implementation of the
\fIregular expression\fP interpreter and the text in \fBREGULAR
EXPRESSIONS\fP.
.SH AUTHOR
John Cristy, E.I. DuPont De Nemours & Company Incorporated
X
X
SHAR_EOF
chmod 0644 ImageMagick/xtp/xtp.man ||
echo 'restore of ImageMagick/xtp/xtp.man failed'
Wc_c="`wc -c < 'ImageMagick/xtp/xtp.man'`"
test 6431 -eq "$Wc_c" ||
	echo 'ImageMagick/xtp/xtp.man: original size 6431, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/xtp/get ==============
if test -f 'ImageMagick/xtp/get' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/xtp/get (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/xtp/get (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/xtp/get' &&
#!/usr/bin/perl
#
# Retrieve files from remote host using standard 'host: filename' string:
#
#   get export.lcs.mit.edu: contrib/ImageMagick.tar.Z
#
$host=shift || die "Usage: get host/ip-address file\n";
$file=shift || die "Usage: get host/ip-address file\n";
$host=~s/:$//;
$directory=`dirname $file`;
chop($directory);
$file=`basename $file`;
chop($file);
printf("Getting %s in directory %s from host %s...\n",$file,$directory,$host);
$pid=fork;
if ($pid == 0)
X  {
X    exec("xtp -r $file -b $host $directory");
X    exit(0);
X  }
exit(0);
SHAR_EOF
chmod 0644 ImageMagick/xtp/get ||
echo 'restore of ImageMagick/xtp/get failed'
Wc_c="`wc -c < 'ImageMagick/xtp/get'`"
test 541 -eq "$Wc_c" ||
	echo 'ImageMagick/xtp/get: original size 541, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/xtp/network.c ==============
if test -f 'ImageMagick/xtp/network.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/xtp/network.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/xtp/network.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/xtp/network.c' &&
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%             N   N  EEEEE  TTTTT  W   W   OOO   RRRR   K   K                 %
%             NN  N  E        T    W   W  O   O  R   R  K  K                  %
%             N N N  EEE      T    W W W  O   O  RRRR   KKK                   %
%             N  NN  E        T    WW WW  O   O  R R    K  K                  %
%             N   N  EEEEE    T    W   W   OOO   R  R   K   K                 %
%                                                                             %
%                                                                             %
%                          Network Routines.                                  %
%                                                                             %
%                                                                             %
%                           Software Design                                   %
%                             John Cristy                                     %
%                             October 1992                                    %
%                                                                             %
%                                                                             %
%  Copyright 1992 E. I. Dupont de Nemours & Company                           %
%                                                                             %
%  Permission to use, copy, modify, distribute, and sell this software and    %
%  its documentation for any purpose is hereby granted without fee,           %
%  provided that the above Copyright notice appear in all copies and that     %
%  both that Copyright notice and this permission notice appear in            %
%  supporting documentation, and that the name of E. I. Dupont de Nemours     %
%  & Company not be used in advertising or publicity pertaining to            %
%  distribution of the software without specific, written prior               %
%  permission.  E. I. Dupont de Nemours & Company makes no representations    %
%  about the suitability of this software for any purpose.  It is provided    %
%  "as is" without express or implied warranty.                               %
%                                                                             %
%  E. I. Dupont de Nemours & Company disclaims all warranties with regard     %
%  to this software, including all implied warranties of merchantability      %
%  and fitness, in no event shall E. I. Dupont de Nemours & Company be        %
%  liable for any special, indirect or consequential damages or any           %
%  damages whatsoever resulting from loss of use, data or profits, whether    %
%  in an action of contract, negligence or other tortious action, arising     %
%  out of or in connection with the use or performance of this software.      %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
*/
X
#include "xtp.h"
#include "regular.h"
#include <unistd.h>
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   G e t H o s t I n f o                                                     %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function GetHostInfo accepts a host name or address, verifies it is valid,
%  and returns both the host name and address from the network host entry.
%
%  The format of the GetHostInfo routine is:
%
%    info=GetHostInfo(name)
%
%  A description of each parameter follows:
%
%    o info:  Function GetHostInfo returns a pointer to the host name and
%      IP address.  A null pointer is returned if there the host cannot be
%      located.
%
%    o name:  Specifies a pointer to a character array that contains either
%      a name of a host or an IP address.
%
%
*/
char *GetHostInfo(name)
char
X  *name;
{
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
X
X  char
X    info[2048],
X    *p;
X
X  struct in_addr
X    in;
X
X  struct hostent
X    *hp;
X
X  /*
X    Get host name and address.
X  */
X  if (isascii(*name) && isdigit(*name))
X    in.s_addr=inet_addr(name);
X  else
X    {
X      in.s_addr=(unsigned long) -1;
X      hp=gethostbyname(name);
X      if (hp != (struct hostent *) NULL)
X        in.s_addr=(*(int *) hp->h_addr);
X    }
X  hp=gethostbyaddr((char *) &in.s_addr,sizeof(in.s_addr),AF_INET);
X  if (hp == (struct hostent *) NULL)
X    {
X      hp=gethostbyname(name);
X      if (hp == (struct hostent *) NULL)
X        return((char *) NULL);
X    }
X  /*
X    Convert hostname to lower-case characters.
X  */
X  p=hp->h_name;
X  while (*p)
X  {
X    if (isupper(*p))
X      *p=tolower(*p);
X    p++;
X  }
X  (void) sprintf(info,"%s [%s]: \0",hp->h_name,inet_ntoa(in));
X  return(info);
}
SHAR_EOF
chmod 0644 ImageMagick/xtp/network.c ||
echo 'restore of ImageMagick/xtp/network.c failed'
Wc_c="`wc -c < 'ImageMagick/xtp/network.c'`"
test 5587 -eq "$Wc_c" ||
	echo 'ImageMagick/xtp/network.c: original size 5587, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/image.c ==============
if test -f 'ImageMagick/image.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/image.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/image.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/image.c' &&
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%                     IIIII  M   M   AAA   GGGG  EEEEE                        %
%                       I    MM MM  A   A G      E                            %
%                       I    M M M  AAAAA G  GG  EEE                          %
%                       I    M   M  A   A G   G  E                            %
%                     IIIII  M   M  A   A  GGGG  EEEEE                        %
%                                                                             %
%                                                                             %
%                    Utiltity Image Routines for Display                      %
%                                                                             %
%                                                                             %
%                                                                             %
%                           Software Design                                   %
%                             John Cristy                                     %
%                              July 1992                                      %
%                                                                             %
%                                                                             %
%  Copyright 1992 E. I. du Pont de Nemours & Company                          %
%                                                                             %
%  Permission to use, copy, modify, distribute, and sell this software and    %
%  its documentation for any purpose is hereby granted without fee,           %
%  provided that the above Copyright notice appear in all copies and that     %
%  both that Copyright notice and this permission notice appear in            %
%  supporting documentation, and that the name of E. I. du Pont de Nemours    %
%  & Company not be used in advertising or publicity pertaining to            %
%  distribution of the software without specific, written prior               %
%  permission.  E. I. du Pont de Nemours & Company makes no representations   %
%  about the suitability of this software for any purpose.  It is provided    %
%  "as is" without express or implied warranty.                               %
%                                                                             %
%  E. I. du Pont de Nemours & Company disclaims all warranties with regard    %
%  to this software, including all implied warranties of merchantability      %
%  and fitness, in no event shall E. I. du Pont de Nemours & Company be       %
%  liable for any special, indirect or consequential damages or any           %
%  damages whatsoever resulting from loss of use, data or profits, whether    %
%  in an action of contract, negligence or other tortious action, arising     %
%  out of or in connection with the use or performance of this software.      %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
*/
X
/*
X  Include declarations.
*/
#include "display.h"
#include "image.h"
#include "alien.h"
#include "X.h"
#include "compress.h"
X
/*
X  External declarations.
*/
extern char
X  *application_name;
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   A l l o c a t e I m a g e                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function AllocateImage allocates an Image structure and initializes each
%  field to a default value.
%
%  The format of the AllocateImage routine is:
%
%      allocated_image=AllocateImage(magick)
%
%  A description of each parameter follows:
%
%    o allocated_image: Function AllocateImage returns a pointer to an image
%      structure initialized to default values.  A null image is returned if
%      there is a a memory shortage or if the image cannot be read.
%
%    o magick: Specifies the image format (i.e. MIFF, GIF, JPEG, etc.).
%
%
*/
Image *AllocateImage(magick)
char
X  *magick;
{
X  Image
X    *allocated_image;
X
X  /*
X    Allocate image structure.
X  */
X  allocated_image=(Image *) malloc(sizeof(Image));
X  if (allocated_image == (Image *) NULL)
X    {
X      Warning("unable to allocate image","memory allocation error");
X      return((Image *) NULL);
X    }
X  /*
X    Initialize Image structure.
X  */
X  allocated_image->file=(FILE *) NULL;
X  *allocated_image->filename='\0';
X  if (strlen(magick) < sizeof(allocated_image->magick))
X    (void) strcpy(allocated_image->magick,magick);
X  allocated_image->comments=(char *) NULL;
X  allocated_image->label=(char *) NULL;
X  allocated_image->id=UndefinedId;
X  allocated_image->class=DirectClass;
X  allocated_image->alpha=False;
X  allocated_image->compression=RunlengthEncodedCompression;
X  allocated_image->columns=0;
X  allocated_image->rows=0;
X  allocated_image->colors=0;
X  allocated_image->scene=0;
X  allocated_image->quality=75;
X  allocated_image->montage=(char *) NULL;
X  allocated_image->directory=(char *) NULL;
X  allocated_image->colormap=(ColorPacket *) NULL;
X  allocated_image->signature=(char *) NULL;
X  allocated_image->pixels=(RunlengthPacket *) NULL;
X  allocated_image->packet=(RunlengthPacket *) NULL;
X  allocated_image->packets=0;
X  allocated_image->packet_size=0;
X  allocated_image->packed_pixels=(unsigned char *) NULL;
X  allocated_image->orphan=False;
X  allocated_image->last=(Image *) NULL;
X  allocated_image->next=(Image *) NULL;
X  return(allocated_image);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   B o r d e r I m a g e                                                     %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function BorderImage takes an image and puts a border around it of a
%  particular color.  It allocates the memory necessary for the new Image
%  structure and returns a pointer to the new image.
%
%  The format of the BorderImage routine is:
%
%      bordered_image=BorderImage(image,border_width,border_height,
%        border_color)
%
%  A description of each parameter follows:
%
%    o bordered_image: Function BorderImage returns a pointer to the bordered
%      image.  A null image is returned if there is a a memory shortage.
%
%    o image: The address of a structure of type Image.
%
%    o border_width: An integer that specifies the number of pixels in width of
%      the bordered image.
%
%    o border_height: An integer that specifies the number of pixels in height
%      of the bordered image.
%
%    o border_color: A pointer to a ColorPacket which contains the red, green,
%      and blue components of the border color.
%
%
*/
Image *BorderImage(image,border_width,border_height,border_color)
Image
X  *image;
X
unsigned int
X  border_width,
X  border_height;
X
ColorPacket
X  border_color;
{
X  Image
X    *bordered_image;
X
X  register int
X    i,
X    x,
X    y;
X
X  register RunlengthPacket
X    *p,
X    *q;
X
X  /*
X    Initialize bordered image attributes.
X  */
X  bordered_image=CopyImage(image,image->columns+border_width*2,
X    image->rows+border_height*2,False);
X  if (bordered_image == (Image *) NULL)
X    {
X      Warning("unable to border image","memory allocation failed");
X      return((Image *) NULL);
X    }
X  /*
X    Copy image and put border around it.
X  */
X  p=image->pixels;
X  q=bordered_image->pixels;
X  image->runlength=p->length+1;
X  for (i=0; i < (bordered_image->columns*border_height); i++)
X  {
X    q->red=border_color.red;
X    q->green=border_color.green;
X    q->blue=border_color.blue;
X    q->index=border_color.index;
X    q->length=0;
X    q++;
X  }
X  for (y=0; y < image->rows; y++)
X  {
X    /*
X      Initialize scanline with border color.
X    */
X    for (i=0; i < border_width; i++)
X    {
X      q->red=border_color.red;
X      q->green=border_color.green;
X      q->blue=border_color.blue;
X      q->index=border_color.index;
X      q->length=0;
X      q++;
X    }
X    /*
X      Transfer scanline.
X    */
X    for (x=0; x < image->columns; x++)
X    {
X      if (image->runlength > 0)
X        image->runlength--;
X      else
X        {
X          p++;
X          image->runlength=p->length;
X        }
X      q->red=p->red;
X      q->green=p->green;
X      q->blue=p->blue;
X      q->index=p->index;
X      q->length=0;
X      q++;
X    }
X    for (i=0; i < border_width; i++)
X    {
X      q->red=border_color.red;
X      q->green=border_color.green;
X      q->blue=border_color.blue;
X      q->index=border_color.index;
X      q->length=0;
X      q++;
X    }
X  }
X  for (i=0; i < (bordered_image->columns*border_height); i++)
X  {
X    q->red=border_color.red;
X    q->green=border_color.green;
X    q->blue=border_color.blue;
X    q->index=border_color.index;
X    q->length=0;
X    q++;
X  }
X  return(bordered_image);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   C l i p I m a g e                                                         %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function ClipImage creates a new image that is a subregion of an existing
%  one.  It allocates the memory necessary for the new Image structure and
%  returns a pointer to the new image.  The pixels are copied from the source
%  image as defined by the region formed from x_offset, y_offset, width, and
%  height.
%
%  The format of the ClipImage routine is:
%
%      clipped_image=ClipImage(image,x_offset,y_offset,width,height)
%
%  A description of each parameter follows:
%
%    o clipped_image: Function ClipImage returns a pointer to the clipped
%      image.  A null image is returned if there is a a memory shortage or
%      if the image width or height is zero.
%
%    o image: The address of a structure of type Image.
%
%    o x_offset: An integer that specifies the column offset of the
%      clipped image.
%
%    o y_offset: An integer that specifies the row offset of the clipped
%      image.
%
%    o width: An integer that specifies the number of pixels in width of the
%      clipped image.
%
%    o height: An integer that specifies the number of pixels in height of the
%      clipped image.
%
%
*/
Image *ClipImage(image,x_offset,y_offset,width,height)
Image
X  *image;
X
int
X  x_offset,
X  y_offset;
X
unsigned int
X  width,
X  height;
{
X  Image
X    *clipped_image;
X
X  register int
X    x,
X    y;
X
X  register RunlengthPacket
X    *p,
X    *q;
X
X  /*
X    Check clip geometry.
X  */
X  if ((width == 0) || (height == 0))
X    {
X      Warning("unable to clip image","image size is zero");
X      return((Image *) NULL);
X    }
X  if (((x_offset+(int) width) < 0) || ((y_offset+(int) height) < 0) ||
X      (x_offset > (int) image->columns) || (y_offset > (int) image->rows))
X    {
X      Warning("unable to clip image","geometry does not contain image");
X      return((Image *) NULL);
X    }
X  if ((x_offset+(int) width) > (int) image->columns)
X    width=(unsigned int) ((int) image->columns-x_offset);
X  if ((y_offset+(int) height) > (int) image->rows)
X    height=(unsigned int) ((int) image->rows-y_offset);
X  if (x_offset < 0)
X    {
X      width-=(unsigned int) (-x_offset);
X      x_offset=0;
X    }
X  if (y_offset < 0)
X    {
X      height-=(unsigned int) (-y_offset);
X      y_offset=0;
X    }
X  /*
X    Initialize clipped image attributes.
X  */
X  clipped_image=CopyImage(image,width,height,False);
X  if (clipped_image == (Image *) NULL)
X    {
X      Warning("unable to clip image","memory allocation failed");
X      return((Image *) NULL);
X    }
X  /*
X    Skip pixels up to the clipped image.
X  */
X  p=image->pixels;
X  image->runlength=p->length+1;
X  for (x=0; x < (y_offset*image->columns+x_offset); x++)
X    if (image->runlength > 0)
X      image->runlength--;
X    else
X      {
X        p++;
X        image->runlength=p->length;
X      }
X  /*
X    Extract clipped image.
X  */
X  q=clipped_image->pixels;
X  for (y=0; y < clipped_image->rows; y++)
X  {
X    /*
X      Transfer scanline.
X    */
X    for (x=0; x < clipped_image->columns; x++)
X    {
X      if (image->runlength > 0)
X        image->runlength--;
X      else
X        {
X          p++;
X          image->runlength=p->length;
X        }
X      q->red=p->red;
X      q->green=p->green;
X      q->blue=p->blue;
X      q->index=p->index;
X      q->length=0;
X      q++;
X    }
X    /*
X      Skip to next scanline.
X    */
X    for (x=0; x < (image->columns-clipped_image->columns); x++)
X      if (image->runlength > 0)
X        image->runlength--;
X      else
X        {
X          p++;
X          image->runlength=p->length;
X        }
X  }
X  return(clipped_image);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   C l o s e I m a g e                                                       %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function CloseImage closes a file associated with the image.
%
%  The format of the CloseImage routine is:
%
%      CloseImage(image)
%
%  A description of each parameter follows:
%
%    o image: The address of a structure of type Image.
%
%
*/
void CloseImage(image)
Image
X  *image;
{
X  /*
X    Close image file.
X  */
X  if (image->file != (FILE *) NULL)
X    if (((int) strlen(image->filename) < 3) ||
X        (strcmp(image->filename+strlen(image->filename)-2,".Z") != 0))
X      (void) fclose(image->file);
X    else
X      (void) pclose(image->file);
X  image->file=(FILE *) NULL;
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   C o m p r e s s C o l o r m a p                                           %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function CompressColormap compresses an image colormap removing any
%  unused color entries.
%
%  The format of the CompressColormap routine is:
%
%      CompressColormap(image)
%
%  A description of each parameter follows:
%
%    o image: The address of a structure of type Image.
%
%
*/
void CompressColormap(image)
Image
X  *image;
{
X  ColorPacket
X    *colormap;
X
X  int
X    number_colors;
X
X  register int
X    i;
X
X  register RunlengthPacket
X    *p;
X
X  register unsigned short
X    index;
X
X  /*
X    Determine if colormap can be compressed.
X  */
X  if (image->class != PseudoClass)
X    return;
X  number_colors=image->colors;
X  for (i=0; i < image->colors; i++)
X    image->colormap[i].flags=False;
X  image->colors=0;
X  p=image->pixels;
X  for (i=0; i < image->packets; i++)
X  {
X    if (!image->colormap[p->index].flags)
X      {
X        image->colormap[p->index].index=image->colors;
X        image->colormap[p->index].flags=True;
X        image->colors++;
X      }
X    p++;
X  }
X  if (image->colors == number_colors)
X    return;  /* no unused entries */
X  /*
X    Compress colormap.
X  */
X  colormap=(ColorPacket *) malloc(image->colors*sizeof(ColorPacket));
X  if (colormap == (ColorPacket *) NULL)
X    {
X      Warning("unable to compress colormap","memory allocation error");
X      image->colors=number_colors;
X      return;
X    }
X  for (i=0; i < number_colors; i++)
X    if (image->colormap[i].flags)
X      {
X        index=image->colormap[i].index;
X        colormap[index].red=image->colormap[i].red;
X        colormap[index].green=image->colormap[i].green;
X        colormap[index].blue=image->colormap[i].blue;
X      }
X  /*
X    Remap pixels.
X  */
X  p=image->pixels;
X  for (i=0; i < image->packets; i++)
X  {
X    p->index=image->colormap[p->index].index;
X    p++;
X  }
X  (void) free((char *) image->colormap);
X  image->colormap=colormap;
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   C o m p r e s s I m a g e                                                 %
%                                                                             %
%                                                                             %
SHAR_EOF
true || echo 'restore of ImageMagick/image.c failed'
fi
echo 'End of  part 4'
echo 'File ImageMagick/image.c is continued in part 5'
echo 5 > _shar_seq_.tmp
exit 0
exit 0 # Just in case...
