Newsgroups: comp.sources.misc
From: cristy@eplrx7.es.duPont.com (John Cristy)
Subject:  v34i044:  imagemagick - X11 image processing and display v2.2, Part16/26
Message-ID: <1992Dec15.035342.21985@sparky.imd.sterling.com>
X-Md4-Signature: 67108793785958dbf109fa9f6222b620
Date: Tue, 15 Dec 1992 03:53:42 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: cristy@eplrx7.es.duPont.com (John Cristy)
Posting-number: Volume 34, Issue 44
Archive-name: imagemagick/part16
Environment: UNIX, VMS, X11, SGI, DEC, Cray, Sun, Vax

#!/bin/sh
# this is Part.16 (part 16 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file ImageMagick/X.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 16; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping ImageMagick/X.c'
else
echo 'x - continuing file ImageMagick/X.c'
sed 's/^X//' << 'SHAR_EOF' >> 'ImageMagick/X.c' &&
X  }
X  pixel_info->annotate_color=pixel_info->foreground_color;
X  if (image != (Image *) NULL)
X    if (image->class == PseudoClass)
X      {
X        /*
X          Initialize pixel array for images of type PseudoClass.
X        */
X        for (i=0; i < image->colors; i++)
X          pixel_info->pixels[i]=XStandardPixel(map_info,image->colormap[i],8);
X        for (i=0; i < MaxNumberPens; i++)
X          pixel_info->pixels[image->colors+i]=pixel_info->pen_color[i].pixel;
X        pixel_info->colors+=MaxNumberPens;
X      }
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   X G e t R e s o u r c e                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function XGetResource queries the X server for the specified resource name
%  or class.  If the resource name or class is not defined in the database, the
%  supplied default value is returned.
%
%  The format of the XGetResource routine is:
%
%      value=XGetResource(database,application_name,name,class,resource_default)
%
%  A description of each parameter follows:
%
%    o value: Function XGetResource returns the resource value associated with
%      the name or class.  If none is found, the supplied default value is
%      returned.
%
%    o database: Specifies a resource database; returned from
%      XrmGetStringDatabase.
%
%    o application_name:  Specifies the application name used to retrieve
%      resource info from the X server database.
%
%    o name: Specifies the name of the value being retrieved.
%
%    o class: Specifies the class of the value being retrieved.
%
%    o resource_default: Specifies the default value to return if the query
%      fails to find the specified name/class.
%
%
*/
char *XGetResource(database,application_name,name,class,resource_default)
XXrmDatabase
X  database;
X
char
X  *application_name,
X  *name,
X  *class,
X  *resource_default;
{
X  char
X    *resource_type,
X    resource_class[2048],
X    resource_name[2048];
X
X  int
X    status;
X
X  XrmValue
X    resource_value;
X
X  if (database == (XrmDatabase) NULL)
X    return(resource_default);
X  *resource_name='\0';
X  if (name != (char *) NULL)
X    (void) sprintf(resource_name,"%s.%s\0",application_name,name);
X  *resource_class='\0';
X  if (class != (char *) NULL)
X    (void) sprintf(resource_class,"%s.%s\0",application_name,class);
X  status=XrmGetResource(database,resource_name,resource_class,&resource_type,
X    &resource_value);
X  if (status == False)
X    return(resource_default);
X  return(resource_value.addr);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   X G e t R e s o u r c e I n f o                                           %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function XGetResourceInfo initializes the ResourceInfo structure.
%
%  The format of the XGetResourceInfo routine is:
%
%      XGetResourceInfo(resource_database,application_name,resource_info)
%
%  A description of each parameter follows:
%
%    o resource_database: Specifies a resource database; returned from
%      XrmGetStringDatabase.
%
%    o application_name:  Specifies the application name used to retrieve
%      resource info from the X server database.
%
%    o resource_info: Specifies a pointer to a X11 XResourceInfo structure.
%
%
*/
void XGetResourceInfo(resource_database,application_name,resource_info)
XXrmDatabase
X  resource_database;
X
char
X  *application_name;
X
XXResourceInfo
X  *resource_info;
{
X  char
X    *resource_value;
X
X  /*
X    Initialize resource info fields.
X  */
X  resource_value=XGetResource(resource_database,application_name,"backdrop",
X    (char *) NULL,"False");
X  resource_info->backdrop=IsTrue(resource_value);
X  resource_info->background_color=XGetResource(resource_database,
X    application_name,"background","Background","black");
X  resource_info->border_color=XGetResource(resource_database,application_name,
X    "borderColor","BorderColor","white");
X  resource_value=XGetResource(resource_database,application_name,"borderWidth",
X    "BorderWidth","2");
X  resource_info->border_width=atoi(resource_value);
X  resource_value=XGetResource(resource_database,application_name,"colormap",
X    (char *) NULL,"shared");
X  resource_info->colormap=UndefinedColormap;
X  if (Latin1Compare("private",resource_value) == 0)
X    resource_info->colormap=PrivateColormap;
X  if (Latin1Compare("shared",resource_value) == 0)
X    resource_info->colormap=SharedColormap;
X  if (resource_info->colormap == UndefinedColormap)
X    Warning("unrecognized colormap type",resource_value);
X  resource_value=XGetResource(resource_database,application_name,"colors",
X    (char *) NULL,"0");
X  resource_info->number_colors=atoi(resource_value);
X  resource_value=XGetResource(resource_database,application_name,"colorspace",
X    (char *) NULL,"rgb");
X  resource_info->colorspace=UndefinedColorspace;
X  if (Latin1Compare("gray",resource_value) == 0)
X    resource_info->colorspace=GRAYColorspace;
X  if (Latin1Compare("rgb",resource_value) == 0)
X    resource_info->colorspace=RGBColorspace;
X  if (Latin1Compare("yiq",resource_value) == 0)
X    resource_info->colorspace=YIQColorspace;
X  if (Latin1Compare("yuv",resource_value) == 0)
X    resource_info->colorspace=YUVColorspace;
X  if (Latin1Compare("xyz",resource_value) == 0)
X    resource_info->colorspace=XYZColorspace;
X  if (resource_info->colorspace == UndefinedColorspace)
X    Warning("unrecognized colorspace type",resource_value);
X  resource_value=XGetResource(resource_database,application_name,"debug",
X    (char *) NULL,"False");
X  resource_info->debug=IsTrue(resource_value);
X  resource_value=XGetResource(resource_database,application_name,"delay",
X    (char *) NULL,"0");
X  resource_info->delay=atoi(resource_value);
X  resource_value=XGetResource(resource_database,application_name,"dither",
X    (char *) NULL,"False");
X  resource_info->dither=IsTrue(resource_value);
X  resource_info->font=XGetResource(resource_database,application_name,
X    "font","Font",(char *) NULL);
X  resource_info->font_name[0]=XGetResource(resource_database,application_name,
X    "font1","Font1","fixed");
X  resource_info->font_name[1]=XGetResource(resource_database,application_name,
X    "font2","Font2","variable");
X  resource_info->font_name[2]=XGetResource(resource_database,application_name,
X    "font3","Font3","5x8");
X  resource_info->font_name[3]=XGetResource(resource_database,application_name,
X    "font4","Font4","6x10");
X  resource_info->font_name[4]=XGetResource(resource_database,application_name,
X    "font5","Font5","7x13bold");
X  resource_info->font_name[5]=XGetResource(resource_database,application_name,
X    "font6","Font6","8x13bold");
X  resource_info->font_name[6]=XGetResource(resource_database,application_name,
X    "font7","Font7","9x15bold");
X  resource_info->font_name[7]=XGetResource(resource_database,application_name,
X    "font8","Font8","10x20");
X  resource_info->font_name[8]=XGetResource(resource_database,application_name,
X    "font9","Font9","12x24");
X  resource_info->foreground_color=XGetResource(resource_database,
X    application_name,"foreground","Foreground","white");
X  resource_info->icon_geometry=XGetResource(resource_database,
X    application_name,"iconGeometry","IconGeometry",(char *) NULL);
X  resource_value=XGetResource(resource_database,application_name,"gravity",
X    (char *) NULL,"Center");
X  resource_info->gravity=(-1);
X  if (Latin1Compare("Forget",resource_value) == 0)
X    resource_info->gravity=ForgetGravity;
X  if (Latin1Compare("NorthWest",resource_value) == 0)
X    resource_info->gravity=NorthWestGravity;
X  if (Latin1Compare("North",resource_value) == 0)
X    resource_info->gravity=NorthGravity;
X  if (Latin1Compare("NorthEast",resource_value) == 0)
X    resource_info->gravity=NorthEastGravity;
X  if (Latin1Compare("West",resource_value) == 0)
X    resource_info->gravity=WestGravity;
X  if (Latin1Compare("Center",resource_value) == 0)
X    resource_info->gravity=CenterGravity;
X  if (Latin1Compare("East",resource_value) == 0)
X    resource_info->gravity=EastGravity;
X  if (Latin1Compare("SouthWest",resource_value) == 0)
X    resource_info->gravity=SouthWestGravity;
X  if (Latin1Compare("South",resource_value) == 0)
X    resource_info->gravity=SouthGravity;
X  if (Latin1Compare("SouthEast",resource_value) == 0)
X    resource_info->gravity=SouthEastGravity;
X  if (Latin1Compare("Static",resource_value) == 0)
X    resource_info->gravity=StaticGravity;
X  if (resource_info->gravity == (-1))
X    Warning("unrecognized gravity type",resource_value);
X  resource_value=XGetResource(resource_database,application_name,"iconic",
X    "Iconic","False");
X  resource_info->iconic=IsTrue(resource_value);
X  resource_info->image_geometry=XGetResource(resource_database,
X    application_name,"imageGeometry","ImageGeometry",(char *) NULL);
X  resource_value=XGetResource(resource_database,application_name,"magnify",
X    (char *) NULL,"2");
X  resource_info->magnify=atoi(resource_value);
X  resource_info->map_type=XGetResource(resource_database,application_name,"map",
X    "Map",(char *) NULL);
X  resource_value=XGetResource(resource_database,application_name,"monochrome",
X    (char *) NULL,"False");
X  resource_info->monochrome=IsTrue(resource_value);
X  resource_info->name=XGetResource(resource_database,application_name,"name",
X    "Name",(char *) NULL);
X  resource_info->pen_color[0]=XGetResource(resource_database,application_name,
X    "pen1","Pen1","black");
X  resource_info->pen_color[1]=XGetResource(resource_database,application_name,
X    "pen2","Pen2","blue");
X  resource_info->pen_color[2]=XGetResource(resource_database,application_name,
X    "pen3","Pen3","cyan");
X  resource_info->pen_color[3]=XGetResource(resource_database,application_name,
X    "pen4","Pen4","green");
X  resource_info->pen_color[4]=XGetResource(resource_database,application_name,
X    "pen5","Pen5","gray");
X  resource_info->pen_color[5]=XGetResource(resource_database,application_name,
X    "pen6","Pen6","red");
X  resource_info->pen_color[6]=XGetResource(resource_database,application_name,
X    "pen7","Pen7","magenta");
X  resource_info->pen_color[7]=XGetResource(resource_database,application_name,
X    "pen8","Pen8","yellow");
X  resource_info->pen_color[8]=XGetResource(resource_database,application_name,
X    "pen9","Pen9","white");
X  resource_info->print_filename=XGetResource(resource_database,application_name,
X    "printFilename",(char *) NULL,(char *) NULL);
X  resource_info->title=XGetResource(resource_database,application_name,"title",
X    "Title",(char *) NULL);
X  resource_value=XGetResource(resource_database,application_name,"treeDepth",
X    (char *) NULL,"0");
X  resource_info->tree_depth=atoi(resource_value);
X  resource_info->write_filename=XGetResource(resource_database,application_name,
X    "writeFilename",(char *) NULL,(char *) NULL);
X  resource_info->visual_type=XGetResource(resource_database,application_name,
X    "visual","Visual",(char *) NULL);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   X G e t W i n d o w I n f o                                               %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function XGetWindowInfo initializes the XWindowInfo structure.
%
%  The format of the XGetWindowInfo routine is:
%
%      XGetWindowInfo(superclass,window)
%
%  A description of each parameter follows:
%
%    o superclass_window: Specifies a pointer to a XWindowInfo structure.
%
%    o window: Specifies a pointer to a XWindowInfo structure.
%
%
*/
void XGetWindowInfo(superclass_window,window)
XXWindowInfo
X  *superclass_window,
X  *window;
{
X  Window
X    id;
X
X  /*
X    Window is initialized from superclass-- protect window ID.
X  */
X  id=window->id;
X  if (id == (Window) NULL)
X    *window=(*superclass_window);
X  else
X    {
X      Pixmap
X        pixmap;
X
X      XImage
X        *ximage;
X
X      /*
X        Protect X image, and pixmap.
X      */
X      ximage=window->ximage;
X      pixmap=window->pixmap;
X      *window=(*superclass_window);
X      window->ximage=ximage;
X      window->pixmap=pixmap;
X    }
X  window->id=id;
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   X M a k e I m a g e                                                       %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function XMakeImage creates an X11 image.  If the image size differs from
%  the X11 image size, the image is first resized.
%
%  The format of the XMakeImage routine is:
%
%      status=XMakeImage(display,resource_info,window,image,width,height)
%
%  A description of each parameter follows:
%
%    o status: Function XMakeImage returns True if the X image is
%      successfully created.  False is returned is there is a memory shortage.
%
%    o display: Specifies a connection to an X server; returned from
%      XOpenDisplay.
%
%    o resource_info: Specifies a pointer to a X11 XResourceInfo structure.
%
%    o window: Specifies a pointer to a XWindowInfo structure.
%
%    o image: Specifies a pointer to a Image structure;  returned from
%      ReadImage.
%
%    o width: Specifies the width in pixels of the rectangular area to
%      display.
%
%    o height: Specifies the height in pixels of the rectangular area to
%      display.
%
%
*/
unsigned int XMakeImage(display,resource_info,window,image,width,height)
Display
X  *display;
X
XXResourceInfo
X  *resource_info;
X
XXWindowInfo
X  *window;
X
Image
X  *image;
X
unsigned int
X  width,
X  height;
{
X  Image
X    *transformed_image;
X
X  int
X    format;
X
X  XImage
X    *ximage;
X
X  if ((window->width == 0) || (window->height == 0))
X    return(False);
X  /*
X    Display busy cursor.
X  */
X  XDefineCursor(display,window->id,window->busy_cursor);
X  XFlush(display);
X  if (image != (Image *) NULL)
X    {
X      /*
X        Apply user transforms to the image.
X      */
X      image->orphan=True;
X      transformed_image=image;
X      if (window->clip_geometry)
X        {
X          Image
X            *clipped_image;
X
X          int
X            clip_x,
X            clip_y;
X
X          unsigned
X            clip_height,
X            clip_width;
X
X          /*
X            Clip image.
X          */
X          (void) XParseGeometry(window->clip_geometry,&clip_x,&clip_y,
X            &clip_width,&clip_height);
X          clipped_image=
X            ClipImage(transformed_image,clip_x,clip_y,clip_width,clip_height);
X          if (clipped_image != (Image *) NULL)
X            {
X              if (transformed_image != image)
X                DestroyImage(transformed_image);
X              transformed_image=clipped_image;
X            }
X        }
X      if ((width != transformed_image->columns) ||
X          (height != transformed_image->rows))
X        {
X          Image
X            *scaled_image;
X
X          /*
X            Scale image.
X          */
X          scaled_image=ScaleImage(transformed_image,width,height);
X          if (scaled_image != (Image *) NULL)
X            {
X              if (transformed_image != image)
X                DestroyImage(transformed_image);
X              transformed_image=scaled_image;
X            }
X        }
X      width=transformed_image->columns;
X      height=transformed_image->rows;
X      image->orphan=False;
X    }
X  /*
X    Create X image.
X  */
X  format=(window->depth == 1) ? XYBitmap : ZPixmap;
X  ximage=XCreateImage(display,window->visual_info->visual,window->depth,format,
X    0,(char *) NULL,width,height,XBitmapPad(display),0);
X  if (ximage == (XImage *) NULL)
X    {
X      /*
X        Unable to create X image.
X      */
X      XDefineCursor(display,window->id,window->cursor);
X      return(False);
X    }
X  if (resource_info->debug)
X    {
X      (void) fprintf(stderr,"XImage:\n");
X      (void) fprintf(stderr,"  width, height: %dx%d\n",ximage->width,
X        ximage->height);
X      (void) fprintf(stderr,"  format: %d\n",ximage->format);
X      (void) fprintf(stderr,"  byte order: %d\n",ximage->byte_order);
X      (void) fprintf(stderr,"  bitmap unit, bit order, pad: %d %d %d\n",
X        ximage->bitmap_unit,ximage->bitmap_bit_order,ximage->bitmap_pad);
X      (void) fprintf(stderr,"  depth: %d\n",ximage->depth);
X      (void) fprintf(stderr,"  bytes per line: %d\n",ximage->bytes_per_line);
X      (void) fprintf(stderr,"  bits per pixel: %d\n",ximage->bits_per_pixel);
X      (void) fprintf(stderr,"  red, green, blue masks: 0x%lx 0x%lx 0x%lx\n",
X        ximage->red_mask,ximage->green_mask,ximage->blue_mask);
X    }
X  /*
X    Allocate X image pixel data.
X  */
X  if (ximage->format == XYBitmap)
X    ximage->data=(char *)
X      malloc(ximage->bytes_per_line*ximage->height*ximage->depth);
X  else
X    ximage->data=(char *) malloc(ximage->bytes_per_line*ximage->height);
X  if (ximage->data == (char *) NULL)
X    {
X      /*
X        Unable to allocate pixel data.
X      */
X      XDestroyImage(ximage);
X      XDefineCursor(display,window->id,window->cursor);
X      return(False);
X    }
X  if (window->ximage != (XImage *) NULL)
X    XDestroyImage(window->ximage);
X  window->ximage=ximage;
X  if (image == (Image *) NULL)
X    {
X      XDefineCursor(display,window->id,window->cursor);
X      return(True);
X    }
X  /*
X    Convert runlength-encoded pixels to X image data.
X  */
X  if ((ximage->byte_order == LSBFirst) ||
X      ((ximage->format == XYBitmap) && (ximage->bitmap_bit_order == LSBFirst)))
X    XMakeImageLSBFirst(window,transformed_image,ximage);
X  else
X    XMakeImageMSBFirst(window,transformed_image,ximage);
X  if (transformed_image != image)
X    DestroyImage(transformed_image);
X  /*
X    Restore cursor.
X  */
X  XDefineCursor(display,window->id,window->cursor);
X  return(True);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   X M a k e I m a g e L S B F i r s t                                       %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function XMakeImageLSBFirst initializes the pixel data of an X11 Image.
%  The X image pixels are copied in least-significant bit and byte first
%  order.  The server's scanline pad is respected.  Rather than using one or
%  two general cases, many special cases are found here to help speed up the
%  image conversion.
%
%  The format of the XMakeImageLSBFirst routine is:
%
%      XMakeImageLSBFirst(window,image,ximage)
%
%  A description of each parameter follows:
%
%    o window: Specifies a pointer to a XWindowInfo structure.
%
%    o image: Specifies a pointer to a Image structure;  returned from
%      ReadImage.
%
%    o ximage: Specifies a pointer to a XImage structure;  returned from
%      XCreateImage.
%
%
*/
static void XMakeImageLSBFirst(window,image,ximage)
XXWindowInfo
X  *window;
X
Image
X  *image;
X
XXImage
X  *ximage;
{
X  register int
X    i,
X    j,
X    x;
X
X  register RunlengthPacket
X    *p;
X
X  register unsigned char
X    *q;
X
X  register unsigned long
X    pixel;
X
X  unsigned int
X    scanline_pad;
X
X  unsigned long
X    *pixels;
X
X  pixels=window->pixel_info->pixels;
X  p=image->pixels;
X  q=(unsigned char *) ximage->data;
X  x=0;
X  if (ximage->format == XYBitmap)
X    {
X      register unsigned char
X        background,
X        bit,
X        byte,
X        foreground;
X
X      register unsigned short
X        polarity;
X
X      /*
X        Convert image to big-endian bitmap.
X      */
X      background=(Intensity(window->pixel_info->foreground_color) >
X        Intensity(window->pixel_info->background_color) ? 1 : 0) << 7;
X      foreground=(Intensity(window->pixel_info->background_color) >
X        Intensity(window->pixel_info->foreground_color) ? 1 : 0) << 7;
X      polarity=Intensity(image->colormap[0]) > Intensity(image->colormap[1]);
X      scanline_pad=ximage->bytes_per_line-(ximage->width >> 3);
X      bit=0;
X      byte=0;
X      for (i=0; i < image->packets; i++)
X      {
X        for (j=0; j <= ((int) p->length); j++)
X        {
X          byte>>=1;
X          if (p->index == polarity)
X            byte|=foreground;
X          else
X            byte|=background;
X          bit++;
X          if (bit == 8)
X            {
X              *q++=byte;
X              bit=0;
X              byte=0;
X            }
X          x++;
X          if (x == ximage->width)
X            {
X              /*
X                Advance to the next scanline.
X              */
X              if (bit > 0)
X                *q=byte >> (8-bit);
X              q+=scanline_pad;
X              bit=0;
X              byte=0;
X              x=0;
X            }
X        }
X        p++;
X      }
X    }
X  else
X    {
X      XStandardColormap
X        *map_info;
X
X      /*
X        Convert image to little-endian color-mapped X image.
X      */
X      map_info=window->map_info;
X      scanline_pad=ximage->bytes_per_line-
X        ((ximage->width*ximage->bits_per_pixel) >> 3);
X      if (window->pixel_info->colors > 0)
X        switch (ximage->bits_per_pixel)
X        {
X          case 2:
X          {
X            register unsigned int
X              nibble;
X
X            /*
X              Convert to 2 bit color-mapped X image.
X            */
X            nibble=0;
X            for (i=0; i < image->packets; i++)
X            {
X              pixel=pixels[p->index] & 0xf;
X              for (j=0; j <= ((int) p->length); j++)
X              {
X                switch (nibble)
X                {
X                  case 0:
X                  {
X                    *q=(unsigned char) pixel;
X                    nibble++;
X                    break;
X                  }
X                  case 1:
X                  {
X                    *q|=(unsigned char) (pixel << 2);
X                    nibble++;
X                    break;
X                  }
X                  case 2:
X                  {
X                    *q|=(unsigned char) (pixel << 4);
X                    nibble++;
X                    break;
X                  }
X                  case 3:
X                  {
X                    *q|=(unsigned char) (pixel << 6);
X                    q++;
X                    nibble=0;
X                    break;
X                  }
X                }
X                x++;
X                if (x == ximage->width)
X                  {
X                    x=0;
X                    nibble=0;
X                    q+=scanline_pad;
X                  }
X              }
X              p++;
X            }
X            break;
X          }
X          case 4:
X          {
X            register unsigned int
X              nibble;
X
X            /*
X              Convert to 4 bit color-mapped X image.
X            */
X            nibble=0;
X            for (i=0; i < image->packets; i++)
X            {
X              pixel=pixels[p->index] & 0xf;
X              for (j=0; j <= ((int) p->length); j++)
X              {
X                switch (nibble)
X                {
X                  case 0:
X                  {
X                    *q=(unsigned char) pixel;
X                    nibble++;
X                    break;
X                  }
X                  case 1:
X                  {
X                    *q|=(unsigned char) (pixel << 4);
X                    q++;
X                    nibble=0;
X                    break;
X                  }
X                }
X                x++;
X                if (x == ximage->width)
X                  {
X                    x=0;
X                    nibble=0;
X                    q+=scanline_pad;
X                  }
X              }
X              p++;
X            }
X            break;
X          }
X          case 6:
X          case 8:
X          {
X            /*
X              Convert to 8 bit color-mapped X image.
X            */
X            for (i=0; i < image->packets; i++)
X            {
X              pixel=pixels[p->index];
X              for (j=0; j <= ((int) p->length); j++)
X              {
X                *q++=(unsigned char) pixel;
X                x++;
X                if (x == ximage->width)
X                  {
X                    x=0;
X                    q+=scanline_pad;
X                  }
X              }
X              p++;
X            }
X            break;
X          }
X          default:
X          {
X            register int
X              k;
X
X            register unsigned int
X              bytes_per_pixel;
X
X            unsigned char
X              channel[sizeof(unsigned long)];
X
X            /*
X              Convert to multi-byte color-mapped X image.
X            */
X            bytes_per_pixel=ximage->bits_per_pixel >> 3;
X            for (i=0; i < image->packets; i++)
X            {
X              pixel=pixels[p->index];
X              for (k=0; k < bytes_per_pixel; k++)
X              {
X                channel[k]=(unsigned char) pixel;
X                pixel>>=8;
X              }
X              for (j=0; j <= ((int) p->length); j++)
X              {
X                for (k=0; k < bytes_per_pixel; k++)
X                  *q++=channel[k];
X                x++;
X                if (x == ximage->width)
X                  {
X                    x=0;
X                    q+=scanline_pad;
X                  }
X              }
X              p++;
X            }
X            break;
X          }
X        }
X      else
X        {
X          /*
X            Convert image to little-endian continuous-tone X image.
X          */
X          switch (ximage->bits_per_pixel)
X          {
X            case 2:
X            {
X              register unsigned int
X                nibble;
X
X              /*
X                Convert to contiguous 2 bit continuous-tone X image.
X              */
X              nibble=0;
X              for (i=0; i < image->packets; i++)
X              {
X                pixel=XStandardPixel(map_info,(*p),8);
X                pixel&=0xf;
X                for (j=0; j <= ((int) p->length); j++)
X                {
X                  switch (nibble)
X                  {
X                    case 0:
X                    {
X                      *q=(unsigned char) pixel;
X                      nibble++;
X                      break;
X                    }
X                    case 1:
X                    {
X                      *q|=(unsigned char) (pixel << 2);
X                      nibble++;
X                      break;
X                    }
X                    case 2:
X                    {
X                      *q|=(unsigned char) (pixel << 4);
X                      nibble++;
X                      break;
X                    }
X                    case 3:
X                    {
X                      *q|=(unsigned char) (pixel << 6);
X                      q++;
X                      nibble=0;
X                      break;
X                    }
X                  }
X                  x++;
X                  if (x == ximage->width)
X                    {
X                      x=0;
X                      nibble=0;
X                      q+=scanline_pad;
X                    }
X                }
X                p++;
X              }
X              break;
X            }
X            case 4:
X            {
X              register unsigned int
X                nibble;
X
X              /*
X                Convert to contiguous 4 bit continuous-tone X image.
X              */
X              nibble=0;
X              for (i=0; i < image->packets; i++)
X              {
X                pixel=XStandardPixel(map_info,(*p),8);
X                pixel&=0xf;
X                for (j=0; j <= ((int) p->length); j++)
X                {
X                  switch (nibble)
X                  {
X                    case 0:
X                    {
X                      *q=(unsigned char) pixel;
X                      nibble++;
X                      break;
X                    }
X                    case 1:
X                    {
X                      *q|=(unsigned char) (pixel << 4);
X                      q++;
X                      nibble=0;
X                      break;
X                    }
X                  }
X                  x++;
X                  if (x == ximage->width)
X                    {
X                      x=0;
X                      nibble=0;
X                      q+=scanline_pad;
X                    }
X                }
X                p++;
X              }
X              break;
X            }
X            case 6:
X            case 8:
X            {
X              /*
X                Convert to contiguous 8 bit continuous-tone X image.
X              */
X              for (i=0; i < image->packets; i++)
X              {
X                pixel=XStandardPixel(map_info,(*p),8);
X                for (j=0; j <= ((int) p->length); j++)
X                {
X                  *q++=(unsigned char) pixel;
X                  x++;
X                  if (x == ximage->width)
X                    {
X                      x=0;
X                      q+=scanline_pad;
X                    }
X                }
X                p++;
X              }
X              break;
X            }
X            default:
X            {
X              if ((ximage->bits_per_pixel == 32) &&
X                  (map_info->red_max == 255) &&
X                  (map_info->green_max == 255) &&
X                  (map_info->blue_max == 255) &&
X                  (map_info->red_mult == 65536) &&
X                  (map_info->green_mult == 256) &&
X                  (map_info->blue_mult == 1))
X                {
X                  /*
X                    Convert to 32 bit continuous-tone X image.
X                  */
X                  for (i=0; i < image->packets; i++)
X                  {
X                    for (j=0; j <= ((int) p->length); j++)
X                    {
X                      *q++=p->blue;
X                      *q++=p->green;
X                      *q++=p->red;
X                      *q++=0;
X                    }
X                    p++;
X                  }
X                }
X              else
X                {
X                  register int
X                    k;
X
X                  register unsigned int
X                    bytes_per_pixel;
X
X                  unsigned char
X                    channel[sizeof(unsigned long)];
X
X                  /*
X                    Convert to multi-byte continuous-tone X image.
X                  */
X                  bytes_per_pixel=ximage->bits_per_pixel >> 3;
X                  for (i=0; i < image->packets; i++)
X                  {
X                    pixel=XStandardPixel(map_info,(*p),8);
X                    for (k=0; k < bytes_per_pixel; k++)
X                    {
X                      channel[k]=(unsigned char) pixel;
X                      pixel>>=8;
X                    }
X                    for (j=0; j <= ((int) p->length); j++)
X                    {
X                      for (k=0; k < bytes_per_pixel; k++)
X                        *q++=channel[k];
X                      x++;
X                      if (x == ximage->width)
X                        {
X                          x=0;
X                          q+=scanline_pad;
X                        }
X                    }
X                    p++;
X                  }
X                }
X              break;
X            }
X          }
X        }
X    }
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   X M a k e I m a g e M S B F i r s t                                       %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function XMakeImageMSBFirst initializes the pixel data of an X11 Image.
%  The X image pixels are copied in most-significant bit and byte first order.
%  The server's scanline pad is also resprected. Rather than using one or two
%  general cases, many special cases are found here to help speed up the image
%  conversion.
%
%  The format of the XMakeImageMSBFirst routine is:
%
%      XMakeImageMSBFirst(window,image,ximage)
%
%  A description of each parameter follows:
%
%    o window: Specifies a pointer to a XWindowInfo structure.
%
%    o image: Specifies a pointer to a Image structure;  returned from
%      ReadImage.
%
%    o ximage: Specifies a pointer to a XImage structure;  returned from
%      XCreateImage.
%
%
*/
static void XMakeImageMSBFirst(window,image,ximage)
XXWindowInfo
X  *window;
X
Image
X  *image;
X
XXImage
X  *ximage;
{
X  register int
X    i,
X    j,
X    x;
X
X  register RunlengthPacket
X    *p;
X
X  register unsigned char
X    *q;
X
X  register unsigned long
X    pixel;
X
X  unsigned int
X    scanline_pad;
X
X  unsigned long
X    *pixels;
X
X  pixels=window->pixel_info->pixels;
X  p=image->pixels;
X  q=(unsigned char *) ximage->data;
X  x=0;
X  if (ximage->format == XYBitmap)
X    {
X      register unsigned char
X        background,
X        bit,
X        byte,
X        foreground;
X
X      register unsigned short
X        polarity;
X
X      /*
X        Convert image to big-endian bitmap.
X      */
X      background=(Intensity(window->pixel_info->foreground_color) >
X        Intensity(window->pixel_info->background_color));
X      foreground=(Intensity(window->pixel_info->background_color) >
X        Intensity(window->pixel_info->foreground_color));
X      polarity=Intensity(image->colormap[0]) > Intensity(image->colormap[1]);
X      scanline_pad=ximage->bytes_per_line-(ximage->width >> 3);
X      bit=0;
X      byte=0;
X      for (i=0; i < image->packets; i++)
X      {
X        for (j=0; j <= ((int) p->length); j++)
X        {
X          byte<<=1;
X          if (p->index == polarity)
X            byte|=foreground;
X          else
X            byte|=background;
X          bit++;
X          if (bit == 8)
X            {
X              *q++=byte;
X              bit=0;
X              byte=0;
X            }
X          x++;
X          if (x == ximage->width)
X            {
X              /*
X                Advance to the next scanline.
X              */
X              if (bit > 0)
X                *q=byte << (8-bit);
X              q+=scanline_pad;
X              bit=0;
X              byte=0;
X              x=0;
X            }
X        }
X        p++;
X      }
X    }
X  else
X    {
X      XStandardColormap
X        *map_info;
X
X      /*
X        Convert image to big-endian X image.
X      */
X      map_info=window->map_info;
X      scanline_pad=ximage->bytes_per_line-
X        ((ximage->width*ximage->bits_per_pixel) >> 3);
X      if (window->pixel_info->colors > 0)
X        switch (ximage->bits_per_pixel)
X        {
X          case 2:
X          {
X            register unsigned int
X              nibble;
X
X            /*
X              Convert to 2 bit color-mapped X image.
X            */
X            nibble=0;
X            for (i=0; i < image->packets; i++)
X            {
X              pixel=pixels[p->index] & 0xf;
X              for (j=0; j <= ((int) p->length); j++)
X              {
X                switch (nibble)
X                {
X                  case 0:
X                  {
X                    *q=(unsigned char) (pixel << 6);
X                    nibble++;
X                    break;
X                  }
X                  case 1:
X                  {
X                    *q|=(unsigned char) (pixel << 4);
X                    nibble++;
X                    break;
X                  }
X                  case 2:
X                  {
X                    *q|=(unsigned char) (pixel << 2);
X                    nibble++;
X                    break;
X                  }
X                  case 3:
X                  {
X                    *q|=(unsigned char) pixel;
X                    q++;
X                    nibble=0;
X                    break;
X                  }
X                }
X                x++;
X                if (x == ximage->width)
X                  {
X                    x=0;
X                    nibble=0;
X                    q+=scanline_pad;
X                  }
X              }
X              p++;
X            }
X            break;
X          }
X          case 4:
X          {
X            register unsigned int
X              nibble;
X
X            /*
X              Convert to 4 bit color-mapped X image.
X            */
X            nibble=0;
X            for (i=0; i < image->packets; i++)
X            {
X              pixel=pixels[p->index] & 0xf;
X              for (j=0; j <= ((int) p->length); j++)
X              {
X                switch (nibble)
X                {
X                  case 0:
X                  {
X                    *q=(unsigned char) (pixel << 4);
X                    nibble++;
X                    break;
X                  }
X                  case 1:
X                  {
X                    *q|=(unsigned char) pixel;
X                    q++;
X                    nibble=0;
X                    break;
X                  }
X                }
X                x++;
X                if (x == ximage->width)
X                  {
X                    x=0;
X                    nibble=0;
X                    q+=scanline_pad;
X                  }
X              }
X              p++;
X            }
X            break;
X          }
X          case 8:
X          {
X            /*
X              Convert to 8 bit color-mapped X image.
X            */
X            for (i=0; i < image->packets; i++)
X            {
X              pixel=pixels[p->index];
X              for (j=0; j <= ((int) p->length); j++)
X              {
X                *q++=(unsigned char) pixel;
X                x++;
X                if (x == ximage->width)
X                  {
X                    x=0;
X                    q+=scanline_pad;
X                  }
X              }
X              p++;
X            }
X            break;
X          }
X          default:
X          {
X            register int
X              k;
X
X            register unsigned int
X              bytes_per_pixel;
X
X            unsigned char
X              channel[sizeof(unsigned long)];
X
X            /*
X              Convert to 8 bit color-mapped X image.
X            */
X            bytes_per_pixel=ximage->bits_per_pixel >> 3;
X            for (i=0; i < image->packets; i++)
X            {
X              pixel=pixels[p->index];
X              for (k=bytes_per_pixel-1; k >= 0; k--)
X              {
X                channel[k]=(unsigned char) pixel;
X                pixel>>=8;
X              }
X              for (j=0; j <= ((int) p->length); j++)
X              {
X                for (k=0; k < bytes_per_pixel; k++)
X                  *q++=channel[k];
X                x++;
X                if (x == ximage->width)
X                  {
X                    x=0;
X                    q+=scanline_pad;
X                  }
X              }
X              p++;
X            }
X            break;
X          }
X        }
X      else
X        {
X          /*
X            Convert to big-endian continuous-tone X image.
X          */
X          switch (ximage->bits_per_pixel)
X          {
X            case 2:
X            {
X              register unsigned int
X                nibble;
X
X              /*
X                Convert to 4 bit continuous-tone X image.
X              */
X              nibble=0;
X              for (i=0; i < image->packets; i++)
X              {
X                pixel=XStandardPixel(map_info,(*p),8);
X                pixel&=0xf;
X                for (j=0; j <= ((int) p->length); j++)
X                {
X                  switch (nibble)
X                  {
X                    case 0:
X                    {
X                      *q=(unsigned char) (pixel << 6);
X                      nibble++;
X                      break;
X                    }
X                    case 1:
X                    {
X                      *q|=(unsigned char) (pixel << 4);
X                      nibble++;
X                      break;
X                    }
X                    case 2:
X                    {
X                      *q|=(unsigned char) (pixel << 2);
X                      nibble++;
X                      break;
X                    }
X                    case 3:
X                    {
X                      *q|=(unsigned char) pixel;
X                      q++;
X                      nibble=0;
X                      break;
X                    }
X                  }
X                  x++;
X                  if (x == ximage->width)
X                    {
X                      x=0;
X                      nibble=0;
X                      q+=scanline_pad;
X                    }
X                }
X                p++;
X              }
X              break;
X            }
X            case 4:
X            {
X              register unsigned int
X                nibble;
X
X              /*
X                Convert to 4 bit continuous-tone X image.
X              */
X              nibble=0;
X              for (i=0; i < image->packets; i++)
X              {
X                pixel=XStandardPixel(map_info,(*p),8);
X                pixel&=0xf;
X                for (j=0; j <= ((int) p->length); j++)
X                {
X                  switch (nibble)
X                  {
X                    case 0:
X                    {
X                      *q=(unsigned char) (pixel << 4);
X                      nibble++;
X                      break;
X                    }
X                    case 1:
X                    {
X                      *q|=(unsigned char) pixel;
X                      q++;
X                      nibble=0;
X                      break;
X                    }
X                  }
X                  x++;
X                  if (x == ximage->width)
X                    {
X                      x=0;
X                      nibble=0;
X                      q+=scanline_pad;
X                    }
X                }
X                p++;
X              }
X              break;
X            }
X            case 8:
X            {
X              /*
X                Convert to 8 bit continuous-tone X image.
X              */
X              for (i=0; i < image->packets; i++)
X              {
X                pixel=XStandardPixel(map_info,(*p),8);
X                for (j=0; j <= ((int) p->length); j++)
X                {
X                  *q++=(unsigned char) pixel;
X                  x++;
X                  if (x == ximage->width)
X                    {
X                      x=0;
X                      q+=scanline_pad;
X                    }
X                }
X                p++;
X              }
X              break;
X            }
X            default:
X            {
X              if ((ximage->bits_per_pixel == 32) &&
X                  (map_info->red_max == 255) &&
X                  (map_info->green_max == 255) &&
X                  (map_info->blue_max == 255) &&
X                  (map_info->red_mult == 65536) &&
X                  (map_info->green_mult == 256) &&
X                  (map_info->blue_mult == 1))
X                {
X                  /*
X                    Convert to 32 bit continuous-tone X image.
X                  */
X                  for (i=0; i < image->packets; i++)
X                  {
X                    for (j=0; j <= ((int) p->length); j++)
X                    {
X                      *q++=0;
X                      *q++=p->red;
X                      *q++=p->green;
X                      *q++=p->blue;
X                    }
X                    p++;
X                  }
X                }
X              else
X                {
X                  register int
X                    k;
X
X                  register unsigned int
X                    bytes_per_pixel;
X
X                  unsigned char
X                    channel[sizeof(unsigned long)];
X
X                  /*
X                    Convert to multi-byte continuous-tone X image.
X                  */
X                  bytes_per_pixel=ximage->bits_per_pixel >> 3;
X                  for (i=0; i < image->packets; i++)
X                  {
X                    pixel=XStandardPixel(map_info,(*p),8);
X                    for (k=bytes_per_pixel-1; k >= 0; k--)
X                    {
X                      channel[k]=(unsigned char) pixel;
X                      pixel>>=8;
X                    }
X                    for (j=0; j <= ((int) p->length); j++)
X                    {
X                      for (k=0; k < bytes_per_pixel; k++)
X                        *q++=channel[k];
X                      x++;
X                      if (x == ximage->width)
X                        {
X                          x=0;
X                          q+=scanline_pad;
X                        }
X                    }
X                    p++;
X                  }
X                }
X              break;
X            }
X          }
X        }
X    }
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   X M a k e I n v i s i b l e C u r s o r                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function XMakeInvisibleCursor creates an invisible X11 cursor.
%
%  The format of the XMakeInvisibleCursor routine is:
%
%      XMakeInvisibleCursor(display,window)
%
%  A description of each parameter follows:
%
%    o display: Specifies a connection to an X server;  returned from
%      XOpenDisplay.
%
%    o window: Specifies the ID of the window for which the cursor is
%      assigned.
%
%
*/
Cursor XMakeInvisibleCursor(display,window)
Display
X  *display;
X
Window
X  window;
{
X  Cursor
X    cursor;
X
X  Pixmap
X    pixmap;
X
X  XColor
X    color;
X
X  static char
X    bits[]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
X
X  color.red=0;
X  color.green=0;
X  color.blue=0;
X  pixmap=XCreateBitmapFromData(display,window,bits,8,8);
X  cursor=XCreatePixmapCursor(display,pixmap,pixmap,&color,&color,0,0);
X  XFreePixmap(display,pixmap);
X  return(cursor);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   X M a k e P i x m a p                                                     %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function XMakePixmap creates an X11 pixmap.
%
%  The format of the XMakePixmap routine is:
%
%      status=XMakePixmap(display,resource_info,window)
%
%  A description of each parameter follows:
%
%    o status: Function XMakePixmap returns True if the X pixmap is
%      successfully created.  False is returned is there is a memory shortage.
%
%    o resource_info: Specifies a pointer to a X11 XResourceInfo structure.
%
%    o display: Specifies a connection to an X server; returned from
%      XOpenDisplay.
%
%    o window: Specifies a pointer to a XWindowInfo structure.
%
%
*/
unsigned int XMakePixmap(display,resource_info,window)
Display
X  *display;
X
XXResourceInfo
X  *resource_info;
X
XXWindowInfo
X  *window;
{
X  if (window->ximage == (XImage *) NULL)
X    return(False);
X  /*
X    Display busy cursor.
X  */
X  XDefineCursor(display,window->id,window->busy_cursor);
X  XFlush(display);
X  /*
X    Create pixmap.
X  */
X  if (window->pixmap != (Pixmap) NULL)
X    XFreePixmap(display,window->pixmap);
X  window->pixmap=XCreatePixmap(display,window->id,(unsigned int)
X    window->ximage->width,(unsigned int) window->ximage->height,window->depth);
X  if (window->pixmap == (Pixmap) NULL)
X    {
X      /*
X        Unable to allocate pixmap.
X      */
X      XDefineCursor(display,window->id,window->cursor);
X      return(False);
X    }
X  /*
X    Copy X image to pixmap.
X  */
X  XPutImage(display,window->pixmap,window->graphic_context,window->ximage,
X    0,0,0,0,(unsigned int) window->ximage->width,
X    (unsigned int) window->ximage->height);
X  if (resource_info->debug)
X    {
X      (void) fprintf(stderr,"Pixmap:\n");
X      (void) fprintf(stderr,"  width, height: %dx%d\n",window->ximage->width,
X        window->ximage->height);
X    }
X  /*
X    Restore cursor.
X  */
X  XDefineCursor(display,window->id,window->cursor);
X  return(True);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   X M a k e S t a n d a r d C o l o r m a p                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function XMakeStandardColormap creates an X11 Standard Colormap.
%
%  The format of the XMakeStandardColormap routine is:
%
%      XMakeStandardColormap(display,visual_info,resource_info,pixel_info,
%        image,map_info)
%
%  A description of each parameter follows:
%
%    o display: Specifies a connection to an X server; returned from
%      XOpenDisplay.
%
%    o visual_info: Specifies a pointer to a X11 XVisualInfo structure;
%      returned from XGetVisualInfo.
%
%    o resource_info: Specifies a pointer to a X11 XResourceInfo structure.
%
%    o pixel_info: Specifies a pointer to a XPixelInfo structure.
%
%    o image: Specifies a pointer to a Image structure;  returned from
%      ReadImage.
%
%    o map_info: If a Standard Colormap type is specified, this structure is
%      initialized with info from the Standard Colormap.
%
%
*/
static int IntensityCompare(x,y)
const void
X  *x,
X  *y;
{
X  DiversityPacket
X    *color_1,
X    *color_2;
X 
X  color_1=(DiversityPacket *) x;
X  color_2=(DiversityPacket *) y;
X  return((int) Intensity(*color_2)-(int) Intensity(*color_1));
}
X
static int PopularityCompare(x,y)
const void
X  *x,
X  *y;
{
X  DiversityPacket
X    *color_1,
X    *color_2;
X
X  color_1=(DiversityPacket *) x;
X  color_2=(DiversityPacket *) y;
X  return((int) color_2->count-(int) color_1->count);
}
X
void XMakeStandardColormap(display,visual_info,resource_info,pixel_info,image,
X  map_info)
Display
X  *display;
X
XXVisualInfo
X  *visual_info;
X
XXResourceInfo
X  *resource_info;
X
XXPixelInfo
X  *pixel_info;
X
Image
X  *image;
X
XXStandardColormap
X  *map_info;
{
X  Colormap
X    colormap;
X
X  int
X    status;
X
X  register int
X    i;
X
X  unsigned int
X    gray_value,
X    number_colors,
X    retain_colors;
X
X  XColor
X    color,
X    *colors,
X    *p;
X
X  if (resource_info->map_type != (char *) NULL)
X    {
X      /*
X        Standard Colormap is already defined (i.e. xstdcmap).
X      */
X      if (pixel_info->pixels != (unsigned long *) NULL)
X        (void) free((char *) pixel_info->pixels);
X      XGetPixelInfo(display,visual_info,map_info,resource_info,image,
X        pixel_info);
X      return;
X    }
X  if ((visual_info->class != DirectColor) && (visual_info->class != TrueColor))
X    if ((image->class == DirectClass) ||
X        (image->colors > visual_info->colormap_size))
X      {
X        /*
X          Image has more colors than the visual supports.
X        */
X        QuantizeImage(image,(unsigned int) visual_info->colormap_size,
X          resource_info->tree_depth,resource_info->dither,
X          resource_info->colorspace,False);
X        image->class=DirectClass;  /* promote to DirectClass */
X      }
X  /*
X    Free previous and create new colormap.
X  */
X  XFreeStandardColormap(display,visual_info,pixel_info,map_info);
X  colormap=XDefaultColormap(display,visual_info->screen);
X  if (visual_info->visual != XDefaultVisual(display,visual_info->screen))
X    colormap=XCreateColormap(display,
X      XRootWindow(display,visual_info->screen),visual_info->visual,
X      visual_info->class == DirectColor ? AllocAll : AllocNone);
X  if (colormap == (Colormap) NULL)
X    Error("unable to create colormap",(char *) NULL);
X  /*
X    Initialize the Standard Colormap attributes.
X  */
X  map_info->colormap=colormap;
X  map_info->red_max=visual_info->red_mask;
X  map_info->red_mult=map_info->red_max > 0 ? 1 : 0;
X  if (map_info->red_max > 0)
X    while ((map_info->red_max & 0x01) == 0)
X    {
X      map_info->red_max>>=1;
X      map_info->red_mult<<=1;
X    }
X  map_info->green_max=visual_info->green_mask;
X  map_info->green_mult=map_info->green_max > 0 ? 1 : 0;
X  if (map_info->green_max > 0)
X    while ((map_info->green_max & 0x01) == 0)
X    {
X      map_info->green_max>>=1;
X      map_info->green_mult<<=1;
X    }
X  map_info->blue_max=visual_info->blue_mask;
X  map_info->blue_mult=map_info->blue_max > 0 ? 1 : 0;
X  if (map_info->blue_max > 0)
X    while ((map_info->blue_max & 0x01) == 0)
X    {
X      map_info->blue_max>>=1;
X      map_info->blue_mult<<=1;
X    }
X  map_info->base_pixel=0;
X  XGetPixelInfo(display,visual_info,map_info,resource_info,image,pixel_info);
X  /*
X    Allocating colors in server colormap is based on visual class.
X  */
X  switch (visual_info->class)
X  {
X    case StaticGray:
X    case StaticColor:
X    {
X      /*
X        Define Standard Colormap for StaticGray or StaticColor visual.
X      */
X      number_colors=image->colors;
X      colors=(XColor *) malloc(visual_info->colormap_size*sizeof(XColor));
SHAR_EOF
true || echo 'restore of ImageMagick/X.c failed'
fi
echo 'End of  part 16'
echo 'File ImageMagick/X.c is continued in part 17'
echo 17 > _shar_seq_.tmp
exit 0
exit 0 # Just in case...
