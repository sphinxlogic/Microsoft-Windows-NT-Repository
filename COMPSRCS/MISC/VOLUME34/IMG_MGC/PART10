Newsgroups: comp.sources.misc
From: cristy@eplrx7.es.duPont.com (John Cristy)
Subject:  v34i038:  imagemagick - X11 image processing and display v2.2, Part10/26
Message-ID: <1992Dec13.202835.9982@sparky.imd.sterling.com>
X-Md4-Signature: 21d89b01a7161aa8a07ccb13cadbf558
Date: Sun, 13 Dec 1992 20:28:35 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: cristy@eplrx7.es.duPont.com (John Cristy)
Posting-number: Volume 34, Issue 38
Archive-name: imagemagick/part10
Environment: UNIX, VMS, X11, SGI, DEC, Cray, Sun, Vax

#!/bin/sh
# this is Part.10 (part 10 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file ImageMagick/rotate.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 10; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping ImageMagick/rotate.c'
else
echo 'x - continuing file ImageMagick/rotate.c'
sed 's/^X//' << 'SHAR_EOF' >> 'ImageMagick/rotate.c' &&
X          rotated_image->columns,x_shear*
X          (((double) i)-(rotated_image->rows-1)/2.0),background,range_limit);
X        row++;
X      }
X      /*
X        Shear the image columns.
X      */
X      column=(number_columns-y_width)/2;
X      for (i=0; i < y_width; i++)
X      {
X        ColumnShear(rotated_pixels+number_columns,number_columns,column,
X          y_offset,rotated_image->rows,y_shear*(((double) i)-(y_width-1)/2.0),
X          background,range_limit);
X        column++;
X      }
X      /*
X        Shear the image rows again.
X      */
X      for (i=0; i < number_rows; i++)
X        RowShear(rotated_pixels+number_columns,number_columns,(unsigned int) i,
X          (number_columns-y_width)/2,y_width,x_shear*
X          (((double) i)-(number_rows-1)/2.0),background,range_limit);
X      (void) free((char *) range_table);
X      /*
X        Calculate the rotated image size.
X      */
X      corners[0].x=(-((int) rotated_image->columns)/2.0);
X      corners[0].y=(-((int) rotated_image->rows)/2.0);
X      corners[1].x=((int) rotated_image->columns)/2.0;
X      corners[1].y=(-((int) rotated_image->rows)/2.0);
X      corners[2].x=(-((int) rotated_image->columns)/2.0);
X      corners[2].y=((int) rotated_image->rows)/2.0;
X      corners[3].x=((int) rotated_image->columns)/2.0;
X      corners[3].y=((int) rotated_image->rows)/2.0;
X      for (i=0; i < 4; i++)
X      {
X        corners[i].x+=x_shear*corners[i].y;
X        corners[i].y+=y_shear*corners[i].x;
X        corners[i].x+=x_shear*corners[i].y;
X        corners[i].x+=(number_columns-1)/2.0;
X        corners[i].y+=(number_rows-1)/2.0;
X      }
X      x_min=corners[0].x;
X      y_min=corners[0].y;
X      x_max=corners[0].x;
X      y_max=corners[0].y;
X      for (i=1; i < 4; i++)
X      {
X        if (x_min > corners[i].x)
X          x_min=corners[i].x;
X        if (y_min > corners[i].y)
X          y_min=corners[i].y;
X        if (x_max < corners[i].x)
X          x_max=corners[i].x;
X        if (y_max < corners[i].y)
X          y_max=corners[i].y;
X      }
X      x_min=floor((double) x_min);
X      x_max=ceil((double) x_max);
X      y_min=floor((double) y_min);
X      y_max=ceil((double) y_max);
X      if (!clip)
X        {
X          /*
X            Rotated image is not clipped.
X          */
X          rotated_image->columns=(unsigned int) (x_max-x_min);
X          rotated_image->rows=(unsigned int) (y_max-y_min);
X        }
X      x_offset=(int) x_min+((int) (x_max-x_min)-rotated_image->columns)/2;
X      y_offset=(int) y_min+((int) (y_max-y_min)-rotated_image->rows)/2;
X    }
X  /*
X    Convert the rectangular array of pixels to runlength packets.
X  */
X  rotated_image->packets=rotated_image->columns*rotated_image->rows;
X  q=rotated_image->pixels;
X  for (y=0; y < rotated_image->rows; y++)
X  {
X    p=rotated_pixels+number_columns+(y+y_offset)*number_columns+x_offset;
X    for (x=0; x < rotated_image->columns; x++)
X    {
X      q->red=p->red;
X      q->green=p->green;
X      q->blue=p->blue;
X      q->index=p->index;
X      q->length=0;
X      q++;
X      p++;
X    }
X  }
X  (void) free((char *) rotated_pixels);
X  return(rotated_image);
}
SHAR_EOF
echo 'File ImageMagick/rotate.c is complete' &&
chmod 0644 ImageMagick/rotate.c ||
echo 'restore of ImageMagick/rotate.c failed'
Wc_c="`wc -c < 'ImageMagick/rotate.c'`"
test 29802 -eq "$Wc_c" ||
	echo 'ImageMagick/rotate.c: original size 29802, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/compress.c ==============
if test -f 'ImageMagick/compress.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/compress.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/compress.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/compress.c' &&
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%           CCCC   OOO   M   M  PPPP   RRRR   EEEEE   SSSSS  SSSSS            %
%          C      O   O  MM MM  P   P  R   R  E       SS     SS               %
%          C      O   O  M M M  PPPP   RRRR   EEE      SSS    SSS             %
%          C      O   O  M   M  P      R R    E          SS     SS            %
%           CCCC   OOO   M   M  P      R  R   EEEEE   SSSSS  SSSSS            %
%                                                                             %
%                                                                             %
%                      Image Compression Coders                               %
%                                                                             %
%                                                                             %
%                                                                             %
%                           Software Design                                   %
%                             John Cristy                                     %
%                              July 1992                                      %
%                                                                             %
%                                                                             %
%  Copyright 1992 E. I. du Pont de Nemours & Company                          %
%                                                                             %
%  Permission to use, copy, modify, distribute, and sell this software and    %
%  its documentation for any purpose is hereby granted without fee,           %
%  provided that the above Copyright notice appear in all copies and that     %
%  both that Copyright notice and this permission notice appear in            %
%  supporting documentation, and that the name of E. I. du Pont de Nemours    %
%  & Company not be used in advertising or publicity pertaining to            %
%  distribution of the software without specific, written prior               %
%  permission.  E. I. du Pont de Nemours & Company makes no representations   %
%  about the suitability of this software for any purpose.  It is provided    %
%  "as is" without express or implied warranty.                               %
%                                                                             %
%  E. I. du Pont de Nemours & Company disclaims all warranties with regard    %
%  to this software, including all implied warranties of merchantability      %
%  and fitness, in no event shall E. I. du Pont de Nemours & Company be       %
%  liable for any special, indirect or consequential damages or any           %
%  damages whatsoever resulting from loss of use, data or profits, whether    %
%  in an action of contract, negligence or other tortious action, arising     %
%  out of or in connection with the use or performance of this software.      %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Functions HuffmanEncodeImage is based on the CCITT T.4 format
%  specifications.
%
%  Functions LZWEncodeImage and LZWDecodeImage is based on the GIF image
%  format specifications.
%
%  Functions QEncodeImage and QDecodeImage is based on the document
%  "JPEG-9-R6 Working Draft for Development of JPEG CD", January 1992.
%  These routines only implement the lossless JPEG compression algorithm in
%  a non-standard fashion.  They can only be used to code and decode MIFF
%  images.
%
%  Images are compressed using a simple predictive method.  The predictor
%  combines three neighboring samples (A, B, and C) to form a prediction
%  of the sample X:
%
%    C B
%    A X
%
%  The prediction formula is A + B - C.  The prediction is subtracted from
%  from the actual sample X and the difference is encoded by an arithmetic
%  entropy coding method.
%
%
*/
X
/*
X  Include declarations.
*/
#include "display.h"
#include "image.h"
/*
X  Define declarations.
*/
#define LowerBound  0
#define MaxContextStates  121
#define MinimumIntervalD  (unsigned short) 0xf000  /* ~-0.75 */
#define MinimumIntervalE  (unsigned short) 0x1000  /* ~0.75 */
#define No  0
#define UpperBound  2
#define Yes  1
/*
X  State classification.
*/
#define ZeroState  0
#define SmallPostitiveState  1
#define SmallNegativeState  2
#define LargePostitiveState  3
#define LargeNegativeState  4
/*
X  Typedef declarations.
*/
typedef struct _ScanlinePacket
{
X  unsigned char
X    pixel;
X
X  int
X    state;
} ScanlinePacket;
/*
X  Initialized declarations.
*/
static int decrement_less_probable[]=
{
X  0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2,
X  2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, 3, 2, 3, 2
};
X
static int increment_more_probable[]=
{
X  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
X  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0
};
X
static int more_probable_exchange[]=
{
X  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
X  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
X
static int statistics[][5]=
{
X   0,  4,  8, 12, 16,
X  20, 24, 28, 32, 36,
X  40, 44, 48, 52, 56,
X  60, 64, 68, 72, 76,
X  80, 84, 88, 92, 96,
};
X
static unsigned short probability[]=
{
X  0x0ac1, 0x0a81, 0x0a01, 0x0901, 0x0701, 0x0681,
X  0x0601, 0x0501, 0x0481, 0x0441, 0x0381, 0x0301,
X  0x02c1, 0x0281, 0x0241, 0x0181, 0x0121, 0x00e1,
X  0x00a1, 0x0071, 0x0059, 0x0053, 0x0027, 0x0017,
X  0x0013, 0x000b, 0x0007, 0x0005, 0x0003, 0x0001
};
/*
X  Declarations and initializations for predictive arithimetic coder.
*/
static int
X  code,
X  less_probable[MaxContextStates],
X  more_probable[MaxContextStates],
X  probability_estimate[MaxContextStates];
X
static unsigned char
X  *q;
X
static unsigned short
X  interval;
X
/*
X  External declarations.
*/
extern char
X  *application_name;
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   D e c o d e                                                               %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function Decode uncompresses a string.
%
%  The format of the Decode routine is:
%
%      Decode(state,decision)
%
%  A description of each parameter follows:
%
%    o state:  An integer value representing the current state.
%
%    o decision:  A pointer to an integer.  The output of the binary
%      decision (Yes/No) is returned in this value.
%
%
*/
static void Decode(state,decision)
register int
X  state,
X  *decision;
{
X  interval+=probability[probability_estimate[state]];
X  if (((code >> 16) & 0xffff) < ((int) interval))
X    {
X      code-=(interval << 16);
X      interval=(-probability[probability_estimate[state]]);
X      *decision=less_probable[state];
X    }
X  else
X    {
X      *decision=more_probable[state];
X      if (interval <= MinimumIntervalD)
X        return;
X    }
X  do
X  {
X    if ((code & 0xff) == 0)
X      {
X        code&=0xffff0000;
X        if ((*q++) == 0xff)
X          code+=((int) (*q) << 9)+0x02;
X        else
X          code+=((int) (*q) << 8)+0x01;
X      }
X    interval<<=1;
X    code<<=1;
X  } while (interval > MinimumIntervalD);
X  /*
X    Update probability estimates.
X  */
X  if (*decision == more_probable[state])
X    probability_estimate[state]+=
X      increment_more_probable[probability_estimate[state]];
X  else
X    probability_estimate[state]-=
X      decrement_less_probable[probability_estimate[state]];
X  if (more_probable_exchange[probability_estimate[state]] != 0)
X    {
X      /*
X        Exchange sense of most probable and least probable.
X      */
X      less_probable[state]=more_probable[state];
X      more_probable[state]=1-more_probable[state];
X    }
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   E n c o d e                                                               %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function Encode generate compressed data string by encoding yes-no decision
%  given state s.
%
%  The format of the Encode routine is:
%
%      Encode(state,decision)
%
%  A description of each parameter follows:
%
%    o state:  An integer value representing the current state.
%
%    o decision:  An integer value representing a binary decision.
%
%
*/
static void Encode(state,decision)
register int
X  state,
X  decision;
{
X  /*
X    Test on "most-probable-symbol" for state s(more_probable[state])
X  */
X  interval-=probability[probability_estimate[state]];
X  if (more_probable[state] != decision)
X    {
X      code-=interval;
X      interval=probability[probability_estimate[state]];
X    }
X  else
X    if (interval >= MinimumIntervalE)
X      return;
X  /*
X    Encoder renormalization.
X  */
X  do
X  {
X    interval<<=1;
X    if (code >= 0)
X      code<<=1;
X    else
X      {
X        /*
X          Shift unsigned char of data from Code register to compressed string.
X        */
X        code<<=1;
X        if (code > 0)
X          {
X            /*
X              Add eight bits from Code register to compressed data string.
X            */
X            (*q++)--;
X            *q=(unsigned char) (code >> 16);
X            code&=0x0000ffff;
X            code|=0x01800000;
X          }
X        else
X          {
X            code&=0x01ffffff;
X            if ((int) interval > code)
X              {
X                /*
X                  Add eight bits from Code register to compressed data string.
X                */
X                (*q++)--;
X                *q=0xff;
X                code|=0x01810000;
X              }
X            else
X              if ((*q++) == 0xff)
X                {
X                  /*
X                    Add seven bits from Code register plus one stuffed bit to
X                    compressed data string.
X                  */
X                  *q=(unsigned char) (code >> 17);
X                  code&=0x0001ffff;
X                  code|=0x03000000;
X                }
X              else
X                {
X                  /*
X                    Add eight bits from Code register to compressed data string.
X                  */
X                  *q=(unsigned char) (code >> 16);
X                  code&=0x0000ffff;
X                  code|=0x01800000;
X                }
X          }
X      }
X  } while (interval < MinimumIntervalE);
X  /*
X    Update probability estimates
X  */
X  if (decision == more_probable[state])
X    probability_estimate[state]+=
X      increment_more_probable[probability_estimate[state]];
X  else
X    probability_estimate[state]-=
X      decrement_less_probable[probability_estimate[state]];
X  if (more_probable_exchange[probability_estimate[state]] != 0)
X    more_probable[state]=1-more_probable[state];
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   F l u s h                                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function Flush flushes the final bits of data from the Code register to the
%  compressed data string.
%
%  The format of the Flush routine is:
%
%      Flush()
%
%
*/
static void Flush()
{
X  register int
X    extra_bits;
X
X  code-=interval;
X  extra_bits=24;
X  extra_bits--;
X  while (code >= 0)
X  {
X    code<<=1;
X    extra_bits--;
X  }
X  code<<=1;
X  if (code > 0)
X    (*q)--;
X  /*
X    Add the final compressed data unsigned chars to the compressed data string.
X  */
X  do
X  {
X    if ((*q++) == 0xff)
X      {
X        /*
X          Add seven bits of data plus one stuffed bit to the compressed data
X          string during final Flush of Code register.
X        */
X        *q=(unsigned char) (code >> 17);
X        code&=0x0001ffff;
X        code<<=7;
X        extra_bits-=7;
X      }
X    else
X      {
X        /*
X           Add eight bits of data to the compressed data string during final
X           flush of Code register.
X        */
X        *q=(unsigned char) (code >> 16);
X        code&=0x0000ffff;
X        code<<=8;
X        extra_bits-=8;
X      }
X  } while (extra_bits > 0);
X  q++;
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   H u f f m a n E n c o d e I m a g e                                       %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function HuffmanEncodeImage compresses an image via Huffman-coding.
%
%  The format of the HuffmanEncodeImage routine is:
%
%      status=HuffmanEncodeImage(image)
%
%  A description of each parameter follows:
%
%    o status:  Function HuffmanEncodeImage returns True if all the pixels are
%      compressed without error, otherwise False.
%
%    o image: The address of a structure of type Image.
%
%
*/
unsigned int HuffmanEncodeImage(image)
Image
X  *image;
{
#define HuffmanOutputCode(te)  \
{  \
X  mask=1 << (entry->length-1);  \
X  while (mask)   \
X  {  \
X    if (entry->code & mask)  \
X      OutputBit(1)  \
X    else  \
X      OutputBit(0);  \
X    mask>>=1;  \
X  }  \
}
X
#define OutputBit(count)  \
{  \
X  if(count > 0)  \
X    byte=byte | bit;  \
X  bit>>=1;  \
X  if ((bit & 0xff) == 0)   \
X    {  \
X      (void) fwrite((char *) &byte,1,1,image->file);  \
X      byte=0;  \
X      bit=0x80;  \
X    }  \
}
X
X  typedef struct HuffmanTable
X  {
X    int
X      id,
X      code,
X      length,
X      count;
X  } HuffmanTable;
X
X  static HuffmanTable MBTable[]=
X  {
X    { 26, 0x0f, 10, 64 }, { 26, 0xc8, 12, 128 }, { 26, 0xc9, 12, 192 },
X    { 26, 0x5b, 12, 256 }, { 26, 0x33, 12, 320 }, { 26, 0x34, 12, 384 },
X    { 26, 0x35, 12, 448 }, { 26, 0x6c, 13, 512 }, { 26, 0x6d, 13, 576 },
X    { 26, 0x4a, 13, 640 }, { 26, 0x4b, 13, 704 }, { 26, 0x4c, 13, 768 },
X    { 26, 0x4d, 13, 832 }, { 26, 0x72, 13, 896 }, { 26, 0x73, 13, 960 },
X    { 26, 0x74, 13, 1024 }, { 26, 0x75, 13, 1088 }, { 26, 0x76, 13, 1152 },
X    { 26, 0x77, 13, 1216 }, { 26, 0x52, 13, 1280 }, { 26, 0x53, 13, 1344 },
X    { 26, 0x54, 13, 1408 }, { 26, 0x55, 13, 1472 }, { 26, 0x5a, 13, 1536 },
X    { 26, 0x5b, 13, 1600 }, { 26, 0x64, 13, 1664 }, { 26, 0x65, 13, 1728 },
X  };
X
X  static HuffmanTable MWTable[]=
X  {
X    { 24, 0x1b, 5, 64 }, { 24, 0x12, 5, 128 }, { 24, 0x17, 6, 192 },
X    { 24, 0x37, 7, 256 }, { 24, 0x36, 8, 320 }, { 24, 0x37, 8, 384 },
X    { 24, 0x64, 8, 448 }, { 24, 0x65, 8, 512 }, { 24, 0x68, 8, 576 },
X    { 24, 0x67, 8, 640 }, { 24, 0xcc, 9, 704 }, { 24, 0xcd, 9, 768 },
X    { 24, 0xd2, 9, 832 }, { 24, 0xd3, 9, 896 }, { 24, 0xd4, 9, 960 },
X    { 24, 0xd5, 9, 1024 }, { 24, 0xd6, 9, 1088 }, { 24, 0xd7, 9, 1152 },
X    { 24, 0xd8, 9, 1216 }, { 24, 0xd9, 9, 1280 }, { 24, 0xda, 9, 1344 },
X    { 24, 0xdb, 9, 1408 }, { 24, 0x98, 9, 1472 }, { 24, 0x99, 9, 1536 },
X    { 24, 0x9a, 9, 1600 }, { 24, 0x18, 6, 1664 }, { 24, 0x9b, 9, 1728 },
X  };
X
X  static HuffmanTable TBTable[]=
X  {
X    { 25, 0x37, 10, 0 }, { 25, 0x02, 3, 1 }, { 25, 0x03, 2, 2 },
X    { 25, 0x02, 2, 3 }, { 25, 0x03, 3, 4 }, { 25, 0x03, 4, 5 },
X    { 25, 0x02, 4, 6 }, { 25, 0x03, 5, 7 }, { 25, 0x05, 6, 8 },
X    { 25, 0x04, 6, 9 }, { 25, 0x04, 7, 10 }, { 25, 0x05, 7, 11 },
X    { 25, 0x07, 7, 12 }, { 25, 0x04, 8, 13 }, { 25, 0x07, 8, 14 },
X    { 25, 0x18, 9, 15 }, { 25, 0x17, 10, 16 }, { 25, 0x18, 10, 17 },
X    { 25, 0x8, 10, 18 }, { 25, 0x67, 11, 19 }, { 25, 0x68, 11, 20 },
X    { 25, 0x6c, 11, 21 }, { 25, 0x37, 11, 22 }, { 25, 0x28, 11, 23 },
X    { 25, 0x17, 11, 24 }, { 25, 0x18, 11, 25 }, { 25, 0xca, 12, 26 },
X    { 25, 0xcb, 12, 27 }, { 25, 0xcc, 12, 28 }, { 25, 0xcd, 12, 29 },
X    { 25, 0x68, 12, 30 }, { 25, 0x69, 12, 31 }, { 25, 0x6a, 12, 32 },
X    { 25, 0x6b, 12, 33 }, { 25, 0xd2, 12, 34 }, { 25, 0xd3, 12, 35 },
X    { 25, 0xd4, 12, 36 }, { 25, 0xd5, 12, 37 }, { 25, 0xd6, 12, 38 },
X    { 25, 0xd7, 12, 39 }, { 25, 0x6c, 12, 40 }, { 25, 0x6d, 12, 41 },
X    { 25, 0xda, 12, 42 }, { 25, 0xdb, 12, 43 }, { 25, 0x54, 12, 44 },
X    { 25, 0x55, 12, 45 }, { 25, 0x56, 12, 46 }, { 25, 0x57, 12, 47 },
X    { 25, 0x64, 12, 48 }, { 25, 0x65, 12, 49 }, { 25, 0x52, 12, 50 },
X    { 25, 0x53, 12, 51 }, { 25, 0x24, 12, 52 }, { 25, 0x37, 12, 53 },
X    { 25, 0x38, 12, 54 }, { 25, 0x27, 12, 55 }, { 25, 0x28, 12, 56 },
X    { 25, 0x58, 12, 57 }, { 25, 0x59, 12, 58 }, { 25, 0x2b, 12, 59 },
X    { 25, 0x2c, 12, 60 }, { 25, 0x5a, 12, 61 }, { 25, 0x66, 12, 62 },
X    { 25, 0x67, 12, 63 },
X  };
X
X  static HuffmanTable TWTable[]=
X  {
X    { 23, 0x35, 8, 0 }, { 23, 0x07, 6, 1 }, { 23, 0x07, 4, 2 },
X    { 23, 0x08, 4, 3 }, { 23, 0x0b, 4, 4 }, { 23, 0x0c, 4, 5 },
X    { 23, 0x0e, 4, 6 }, { 23, 0x0f, 4, 7 }, { 23, 0x13, 5, 8 },
X    { 23, 0x14, 5, 9 }, { 23, 0x07, 5, 10 }, { 23, 0x08, 5, 11 },
X    { 23, 0x08, 6, 12 }, { 23, 0x03, 6, 13 }, { 23, 0x34, 6, 14 },
X    { 23, 0x35, 6, 15 }, { 23, 0x2a, 6, 16 }, { 23, 0x2b, 6, 17 },
X    { 23, 0x27, 7, 18 }, { 23, 0x0c, 7, 19 }, { 23, 0x08, 7, 20 },
X    { 23, 0x17, 7, 21 }, { 23, 0x03, 7, 22 }, { 23, 0x04, 7, 23 },
X    { 23, 0x28, 7, 24 }, { 23, 0x2b, 7, 25 }, { 23, 0x13, 7, 26 },
X    { 23, 0x24, 7, 27 }, { 23, 0x18, 7, 28 }, { 23, 0x02, 8, 29 },
X    { 23, 0x03, 8, 30 }, { 23, 0x1a, 8, 31 }, { 23, 0x1b, 8, 32 },
X    { 23, 0x12, 8, 33 }, { 23, 0x13, 8, 34 }, { 23, 0x14, 8, 35 },
X    { 23, 0x15, 8, 36 }, { 23, 0x16, 8, 37 }, { 23, 0x17, 8, 38 },
X    { 23, 0x28, 8, 39 }, { 23, 0x29, 8, 40 }, { 23, 0x2a, 8, 41 },
X    { 23, 0x2b, 8, 42 }, { 23, 0x2c, 8, 43 }, { 23, 0x2d, 8, 44 },
X    { 23, 0x04, 8, 45 }, { 23, 0x05, 8, 46 }, { 23, 0x0a, 8, 47 },
X    { 23, 0x0b, 8, 48 }, { 23, 0x52, 8, 49 }, { 23, 0x53, 8, 50 },
X    { 23, 0x54, 8, 51 }, { 23, 0x55, 8, 52 }, { 23, 0x24, 8, 53 },
X    { 23, 0x25, 8, 54 }, { 23, 0x58, 8, 55 }, { 23, 0x59, 8, 56 },
X    { 23, 0x5a, 8, 57 }, { 23, 0x5b, 8, 58 }, { 23, 0x4a, 8, 59 },
X    { 23, 0x4b, 8, 60 }, { 23, 0x32, 8, 61 }, { 23, 0x33, 8, 62 },
X    { 23, 0x34, 8, 63 },
X  };
X
X  HuffmanTable*
X    entry;
X
X  int
X    c,
X    k,
X    n,
X    x;
X
X  register int
X    i,
X    j;
X
X  register RunlengthPacket
X    *p;
X
X  register unsigned char
X    *q;
X
X  register unsigned short
X    polarity;
X
X  unsigned int
X    mask;
X
X  unsigned char
X    bit,
X    byte,
X    *scanline;
X
X  /*
X    Allocate scanline buffer.
X  */
X  scanline=(unsigned char *)
X    malloc(Max(image->columns,1728)*sizeof(unsigned char));
X  if (scanline == (unsigned char *) NULL)
X    {
X      Warning("unable to allocate memory",(char *) NULL);
X      return(False);
X    }
X  /*
X    Compress MIFF to 1D Huffman encoded pixels.
X  */
X  q=scanline;
X  polarity=(Intensity(image->colormap[0]) >
X    Intensity(image->colormap[1]) ? 0 : 1);
X  for (i=0; i < Max(image->columns,1728); i++)
X    *q++=polarity;
X  byte=0;
X  bit=0x80;
X  p=image->pixels;
X  q=scanline;
X  x=0;
X  for (i=0; i < image->packets; i++)
X  {
X    for (j=0; j <= ((int) p->length); j++)
X    {
X      if (p->index == polarity)
X        *q++=(unsigned char) polarity;
X       else
X        *q++=(unsigned char) !polarity;
X      x++;
X      if (x == image->columns)
X        {
X          /*
X            Huffman encode scanline.
X          */
X          q=scanline;
X          n=Max(image->columns,1728);
X          while (n > 0)
X          {
X            /*
X              Find white run.
X            */
X            c=0;
X            while((*q == polarity) && (n > 0))
X            {
X              q++;
X              c++;
X              n--;
X            }
X            /*
X              Output white run.
X            */
X            if (c >= 64)
X              {
X                entry=MWTable+((c/64)-1);
X                c-=entry->count;
X                HuffmanOutputCode(entry);
X              }
X            entry=TWTable+c;
X            HuffmanOutputCode(entry);
X            c=0;
X            if (n == 0)
X              break;
X            /*
X              Find black run.
X            */
X            while ((*q != polarity) && (n > 0))
X            {
X              q++;
X              c++;
X              n--;
X            }
X            /*
X              Output black run.
X            */
X            if (c >= 64)
X              {
X                entry=MBTable+((c/64)-1);
X                c-=entry->count;
X                HuffmanOutputCode(entry);
X              }
X            entry=TBTable+c;
X            HuffmanOutputCode(entry);
X            if (n == 0)
X              break;
X          }
X          /*
X            End of line.
X          */
X          for (k=0; k < 11; k++)
X            OutputBit(0);
X          OutputBit(1);
X          x=0;
X          q=scanline;
X        }
X    }
X    p++;
X  }
X  /*
X    End of page.
X  */
X  for (i=0; i < 6; i++)
X  {
X    /*
X      End of line.
X    */
X    for (k=0; k < 11; k++)
X      OutputBit(0);
X    OutputBit(1);
X  }
X  /*
X    Flush bits.
X  */
X  if (bit != 0x80)
X    (void) fwrite((char *) &byte,1,1,image->file);
X  (void) free((char *) scanline);
X  return(True);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   L Z W D e c o d e I m a g e                                               %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function LZWDecodeImage uncompresses an image via LZW-coding.
%
%  The format of the LZWDecodeImage routine is:
%
%      status=LZWDecodeImage(image)
%
%  A description of each parameter follows:
%
%    o status:  Function LZWDecodeImage returns True if all the pixels are
%      uncompressed without error, otherwise False.
%
%    o image: The address of a structure of type Image.
%
%
*/
unsigned int LZWDecodeImage(image)
Image
X  *image;
{
#define MaxStackSize  4096
#define NullCode  (-1)
X
X  int
X    available,
X    clear,
X    code_mask,
X    code_size,
X    end_of_information,
X    in_code,
X    old_code;
X
X  register int
X    bits,
X    code,
X    count,
X    i;
X
X  register RunlengthPacket
X    *p;
X
X  register unsigned char
X    *c;
X
X  register unsigned int
X    datum;
X
X  short int
X    *prefix;
X
X  unsigned char
X    data_size,
X    first,
X    *packet,
X    *pixel_stack,
X    *suffix,
X    *top_stack;
X
X  unsigned short
X    index;
X
X  /*
X    Allocate decoder tables.
X  */
X  packet=(unsigned char *) malloc(256*sizeof(unsigned char));
X  prefix=(short int *) malloc(MaxStackSize*sizeof(short int));
X  suffix=(unsigned char *) malloc(MaxStackSize*sizeof(unsigned char));
X  pixel_stack=(unsigned char *) malloc(MaxStackSize*sizeof(unsigned char));
X  if ((packet == (unsigned char *) NULL) ||
X      (prefix == (short int *) NULL) ||
X      (suffix == (unsigned char *) NULL) ||
X      (pixel_stack == (unsigned char *) NULL))
X    return(False);
X  /*
X    Initialize LZW data stream decoder.
X  */
X  (void) ReadData((char *) &data_size,1,1,image->file);
X  clear=1 << data_size;
X  end_of_information=clear+1;
X  available=clear+2;
X  old_code=NullCode;
X  code_size=data_size+1;
X  code_mask=(1 << code_size)-1;
X  for (code=0; code < clear; code++)
X  {
X    prefix[code]=0;
X    suffix[code]=code;
X  }
X  /*
X    Decode LZW pixel stream.
X  */
X  datum=0;
X  bits=0;
X  count=0;
X  top_stack=pixel_stack;
X  p=image->pixels;
X  for (i=0; i < image->packets; )
X  {
X    if (top_stack == pixel_stack)
X      {
X        if (bits < code_size)
X          {
X            /*
X              Load bytes until there is enough bits for a code.
X            */
X            if (count == 0)
X              {
X                /*
X                  Read a new data block.
X                */
X                count=ReadDataBlock((char *) packet,image->file);
X                if (count <= 0)
X                  break;
X                c=packet;
X              }
X            datum+=(*c) << bits;
X            bits+=8;
X            c++;
X            count--;
X            continue;
X          }
X        /*
X          Get the next code.
X        */
X        code=datum & code_mask;
X        datum>>=code_size;
X        bits-=code_size;
X        /*
X          Interpret the code
X        */
X        if ((code > available) || (code == end_of_information))
X          break;
X        if (code == clear)
X          {
X            /*
X              Reset decoder.
X            */
X            code_size=data_size+1;
X            code_mask=(1 << code_size)-1;
X            available=clear+2;
X            old_code=NullCode;
X            continue;
X          }
X        if (old_code == NullCode)
X          {
X            *top_stack++=suffix[code];
X            old_code=code;
X            first=code;
X            continue;
X          }
X        in_code=code;
X        if (code == available)
X          {
X            *top_stack++=first;
X            code=old_code;
X          }
X        while (code > clear)
X        {
X          *top_stack++=suffix[code];
X          code=prefix[code];
X        }
X        first=suffix[code];
X        /*
X          Add a new string to the string table,
X        */
X        *top_stack++=first;
X        prefix[available]=old_code;
X        suffix[available]=first;
X        available++;
X        if (((available & code_mask) == 0) && (available < MaxStackSize))
X          {
X            code_size++;
X            code_mask+=available;
X          }
X        old_code=in_code;
X      }
X    /*
X      Pop a pixel off the pixel pixel_stack.
X    */
X    top_stack--;
X    index=(unsigned short) *top_stack;
X    p->red=image->colormap[index].red;
X    p->green=image->colormap[index].green;
X    p->blue=image->colormap[index].blue;
X    p->index=index;
X    p->length=0;
X    p++;
X    i++;
X  }
X  /*
X    Initialize any remaining color packets to a known color.
X  */
X  for ( ; i < image->packets; i++)
X  {
X    p->red=image->colormap[0].red;
X    p->green=image->colormap[0].green;
X    p->blue=image->colormap[0].blue;
X    p->index=0;
X    p->length=0;
X    p++;
X  }
X  /*
X    Free decoder memory.
X  */
X  (void) free((char *) pixel_stack);
X  (void) free((char *) suffix);
X  (void) free((char *) prefix);
X  (void) free((char *) packet);
X  return(True);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   L Z W E n c o d e I m a g e                                               %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function LZWEncodeImage compresses an image via LZW-coding.
%
%  The format of the LZWEncodeImage routine is:
%
%      status=LZWEncodeImage(image,data_size)
%
%  A description of each parameter follows:
%
%    o status:  Function LZWEncodeImage returns True if all the pixels are
%      compressed without error, otherwise False.
%
%    o image: The address of a structure of type Image.
%
%
*/
unsigned int LZWEncodeImage(image,data_size)
Image
X  *image;
X
unsigned int
X  data_size;
{
#define MaxCode(number_bits)  (((short int) (1 << (number_bits)))-1)
#define MaxHashTable  5003
#define MaxLZWBits  12
#define MaxLZWTable  ((short int) 1 << MaxLZWBits)
#define LZWOutputCode(code) \
{ \
X  /*  \
X    Emit a code. \
X  */ \
X  if (bits > 0) \
X    datum|=((long int) code << bits); \
X  else \
X    datum=code; \
X  bits+=number_bits; \
X  while (bits >= 8)  \
X  { \
X    /*  \
X      Add a character to current packet. \
X    */ \
X    byte_count++; \
X    packet[byte_count]=(unsigned char) (datum & 0xff); \
X    if (byte_count >= 255) \
X      { \
X        packet[0]=(unsigned char) byte_count++; \
X        (void) fwrite((char *) packet,1,byte_count,image->file); \
X        byte_count=0; \
X      } \
X    datum>>=8; \
X    bits-=8; \
X  } \
X  if (free_code > max_code)  \
X    { \
X      number_bits++; \
X      if (number_bits == MaxLZWBits) \
X        max_code=MaxLZWTable; \
X      else \
X        max_code=MaxCode(number_bits); \
X    } \
}
X
X  int
X    bits,
X    byte_count,
X    next_pixel,
X    number_bits;
X
X  long int
X    datum;
X
X  register int
X    displacement,
X    i,
X    j,
X    k;
X
X  register RunlengthPacket
X    *p;
X
X  short int
X    clear_code,
X    end_of_information_code,
X    free_code,
X    *hash_code,
X    *hash_prefix,
X    max_code,
X    waiting_code;
X
X  unsigned char
X    *packet,
X    *hash_suffix;
X
X  /*
X    Allocate encoder tables.
X  */
X  packet=(unsigned char *) malloc(256*sizeof(unsigned char));
X  hash_code=(short int *) malloc(MaxHashTable*sizeof(short int));
X  hash_prefix=(short int *) malloc(MaxHashTable*sizeof(short int));
X  hash_suffix=(unsigned char *) malloc(MaxHashTable*sizeof(unsigned char));
X  if ((packet == (unsigned char *) NULL) || (hash_code == (short int *) NULL) ||
X      (hash_prefix == (short int *) NULL) ||
X      (hash_suffix == (unsigned char *) NULL))
X    return(False);
X  /*
X    Initialize LZW encoder.
X  */
X  number_bits=data_size;
X  max_code=MaxCode(number_bits);
X  clear_code=((short int) 1 << (data_size-1));
X  end_of_information_code=clear_code+1;
X  free_code=clear_code+2;
X  byte_count=0;
X  datum=0;
X  bits=0;
X  for (i=0; i < MaxHashTable; i++)
X    hash_code[i]=0;
X  LZWOutputCode(clear_code);
X  /*
X    Encode pixels.
X  */
X  p=image->pixels;
X  waiting_code=(short int) (p->index & 0xff);
X  for (i=0; i < image->packets; i++)
X  {
X    for (j=0; j <= ((int) p->length); j++)
X    {
X      /*
X        Probe hash table.
X      */
X      k=((int) (p->index) << (MaxLZWBits-8))+waiting_code;
X      if (k >= MaxHashTable)
X        k-=MaxHashTable;
X      if (hash_code[k] != 0)
X        {
X          if ((hash_prefix[k] == waiting_code) &&
X              (hash_suffix[k] == (unsigned char) (p->index & 0xff)))
X            {
X              waiting_code=hash_code[k];
X              continue;
X            }
X          if (k == 0)
X            displacement=1;
X          else
X            displacement=MaxHashTable-k;
X          next_pixel=False;
X          while (1)
X          {
X            k-=displacement;
X            if (k < 0)
X              k+=MaxHashTable;
X            if (hash_code[k] == 0)
X              break;
X            if ((hash_prefix[k] == waiting_code) &&
X                (hash_suffix[k] == (unsigned char) (p->index & 0xff)))
X              {
X                waiting_code=hash_code[k];
X                next_pixel=True;
X                break;
X              }
X          }
X          if (next_pixel == True)
X            continue;
X        }
X      LZWOutputCode(waiting_code);
X      if (free_code < MaxLZWTable)
X        {
X          hash_code[k]=free_code++;
X          hash_prefix[k]=waiting_code;
X          hash_suffix[k]=(unsigned char) (p->index & 0xff);
X        }
X      else
X        {
X          /*
X            Fill the hash table with empty entries.
X          */
X          for (k=0; k < MaxHashTable; k++)
X            hash_code[k]=0;
X          /*
X            Reset compressor and issue a clear code.
X          */
X          free_code=clear_code+2;
X          LZWOutputCode(clear_code);
X          number_bits=data_size;
X          max_code=MaxCode(number_bits);
X        }
X      waiting_code=(short int) (p->index & 0xff);
X    }
X    p++;
X  }
X  /*
X    Flush out the buffered code.
X  */
X  LZWOutputCode(waiting_code);
X  LZWOutputCode(end_of_information_code);
X  if (bits > 0)
X    {
X      /*
X        Add a character to current packet.
X      */
X      byte_count++;
X      packet[byte_count]=(unsigned char) (datum & 0xff);
X      if (byte_count >= 255)
X        {
X          packet[0]=(unsigned char) byte_count++;
X          (void) fwrite((char *) packet,1,byte_count,image->file);
X          byte_count=0;
X        }
X    }
X  /*
X    Flush accumulated data.
X  */
X  if (byte_count > 0)
X    {
X      packet[0]=(unsigned char) byte_count++;
X      (void) fwrite((char *) packet,1,byte_count,image->file);
X      byte_count=0;
X    }
X  /*
X    Free encoder memory.
X  */
X  (void) free((char *) hash_suffix);
X  (void) free((char *) hash_prefix);
X  (void) free((char *) hash_code);
X  (void) free((char *) packet);
X  if (i < image->packets)
X    return(False);
X  return(True);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   Q D e c o d e I m a g e                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function QDecodeImage uncompresses an image via Q-coding.
%
%  The format of the QDecodeImage routine is:
%
%      count=QDecodeImage(compressed_pixels,pixels,number_columns,number_rows)
%
%  A description of each parameter follows:
%
%    o count:  The QDecodeImage routine returns this integer value.  It is
%      the actual number of pixels created by the decompression process.
%
%    o compressed_pixels:  The address of a byte (8 bits) array of compressed
%      pixel data.
%
%    o pixels:  The address of a byte (8 bits) array of pixel data created by
%      the uncompression process.  The number of bytes in this array
%      must be at least equal to the number columns times the number of rows
%      of the source pixels.
%
%    o number_columns:  An integer value that is the number of columns or
%      width in pixels of your source image.
%
%    o number_rows:  An integer value that is the number of rows or
%      heigth in pixels of your source image.
%
%
*/
unsigned int QDecodeImage(compressed_pixels,pixels,number_columns,number_rows)
unsigned char
X  *compressed_pixels,
X  *pixels;
X
unsigned int
X  number_columns,
X  number_rows;
{
X  int
X    decision,
X    i,
X    prediction,
X    row;
X
X  register int
X    column,
X    magnitude,
X    sign,
X    state,
X    value;
X
X  register ScanlinePacket
X    *cs,
X    *ls;
X
X  register unsigned char
X    *p;
X
X  ScanlinePacket
X    *scanline;
X
X  for (i=0; i < MaxContextStates; i++)
X  {
X    probability_estimate[i]=0;
X    more_probable[i]=0;
X    less_probable[i]=1;
X  }
X  /*
X    Allocate scanline for row values and states
X  */
X  scanline=(ScanlinePacket *)
X    malloc((2*(number_columns+1)*sizeof(ScanlinePacket)));
X  if (scanline == (ScanlinePacket *) NULL)
X    {
X      Warning("unable to compress image, unable to allocate memory",
X        (char *) NULL);
X      exit(1);
X    }
X  cs=scanline;
X  for (i=0; i < 2*(number_columns+1); i++)
X  {
X    cs->pixel=0;
X    cs->state=ZeroState;
X    cs++;
X  }
X  interval=MinimumIntervalD;
X  p=pixels;
X  q=compressed_pixels+1;
X  /*
X    Add a new unsigned char of compressed data to the Code register.
X  */
X  code=(int) (*q) << 16;
X  if ((*q++) == 0xff)
X    code+=((int) (*q) << 9)+0x02;
X  else
X    code+=((*q) << 8)+0x01;
X  code<<=4;
X  code+=(interval << 16);
X  /*
X    Decode each image scanline.
X  */
X  for (row=0; row < number_rows; row++)
X  {
X    ls=scanline+(number_columns+1)*((row+0) % 2);
X    cs=scanline+(number_columns+1)*((row+1) % 2);
X    for (column=0; column < number_columns; column++)
X    {
X      prediction=(int) cs->pixel-(int) ls->pixel;
X      ls++;
X      prediction+=(int) ls->pixel;
X      state=statistics[cs->state][ls->state];
X      cs++;
X      cs->state=ZeroState;
X      /*
X        Branch for zero code value
X      */
X      Decode(state,&decision);
X      if (decision == No)
X        value=0;
X      else
X        {
X          /*
X            Decode sign information
X          */
X          state++;
X          Decode(state,&decision);
X          if (decision == Yes)
X            sign=(-1);
X          else
X            {
X              sign=1;
X              state++;
X            }
X          state++;
X          /*
X            Branch for value=+-1
X          */
X          Decode(state,&decision);
X          if (decision == No)
X            value=1;
X          else
X            {
X              /*
X                Establish magnitude of value.
X              */
X              magnitude=2;
X              state=100;
X              Decode(state,&decision);
X              while (decision != No)
X              {
X                if (state < 107)
X                  state++;
X                magnitude<<=1;
X                Decode(state,&decision);
X              }
X              /*
X                Code remaining bits.
X              */
X              state+=7;
X              value=1;
X              magnitude>>=2;
X              if (magnitude != 0)
X                {
X                  Decode(state,&decision);
X                  state+=6;
X                  value=(value << 1) | decision;
X                  magnitude>>=1;
X                  while (magnitude != 0)
X                  {
X                    Decode(state,&decision);
X                    value=(value << 1) | decision;
X                    magnitude>>=1;
X                  }
X                }
X              value++;
X            }
X          if (value > LowerBound)
X            if (value <= UpperBound)
X              cs->state=
X                (sign < ZeroState ? SmallPostitiveState : SmallNegativeState);
X            else
X              cs->state=
X                (sign < ZeroState ? LargePostitiveState : LargeNegativeState);
X          if (sign < 0)
X            value=(-value);
X        }
X      cs->pixel=(unsigned char) (value+prediction);
X      *p++=cs->pixel;
X    }
X  }
X  (void) free((char *) scanline);
X  return((unsigned int) (p-pixels));
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   Q E n c o d e I m a g e                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function QEncodeImage compresses an image via q-coding.
%
%  The format of the QEncodeImage routine is:
%
%      count=QEncodeImage(pixels,compressed_pixels,number_columns,
%        number_rows)
%
%  A description of each parameter follows:
%
%    o count:  The QEncodeImage routine returns this integer value.  It is
%      the actual number of compressed pixels created by the compression
%      process.
%
%    o pixels:  The address of a byte (8 bits) array of pixel data.
%
%    o compressed_pixels:  The address of a byte (8 bits) array of pixel data
%      created by the compression process.  The number of bytes in this array
%      must be at least equal to the number columns times the number of rows
%      of the source pixels to allow for the possibility that no compression
%      is possible.  The actual number of bytes used is reflected by the
%      count parameter.
%
%    o number_columns:  An integer value that is the number of columns or
%      width in pixels of your source image.
%
%    o number_rows:  An integer value that is the number of rows or
%      heigth in pixels of your source image.
%
%
%
*/
unsigned int QEncodeImage(pixels,compressed_pixels,number_columns,number_rows)
unsigned char
X  *pixels,
X  *compressed_pixels;
X
unsigned int
X  number_columns,
X  number_rows;
{
X  int
X    i,
X    prediction,
X    row;
X
X  register int
X    column,
X    magnitude,
X    sign,
X    state,
X    value;
X
X  register ScanlinePacket
X    *cs,
X    *ls;
X
X  register unsigned char
X    *p;
X
X  ScanlinePacket
X    *scanline;
X
X  void
X    Flush();
X
X  for (i=0; i < MaxContextStates; i++)
X  {
X    probability_estimate[i]=0;
X    more_probable[i]=0;
X  }
X  /*
X    Allocate scanline for row values and states.
X  */
X  scanline=(ScanlinePacket *)
X    malloc((2*(number_columns+1)*sizeof(ScanlinePacket)));
X  if (scanline == (ScanlinePacket *) NULL)
X    {
X      Warning("unable to compress image, unable to allocate memory",
X        (char *) NULL);
X      exit(1);
X    }
X  cs=scanline;
X  for (i=0; i < 2*(number_columns+1); i++)
X  {
X    cs->pixel=0;
X    cs->state=ZeroState;
X    cs++;
X  }
X  interval=MinimumIntervalE;
X  p=pixels;
X  q=compressed_pixels;
X  (*q)++;
X  code=0x00180000;
X  /*
X    Encode each scanline.
X  */
X  for (row=0; row < number_rows; row++)
X  {
X    ls=scanline+(number_columns+1)*((row+0) % 2);
X    cs=scanline+(number_columns+1)*((row+1) % 2);
X    for (column=0; column < number_columns; column++)
X    {
X      prediction=(int) cs->pixel-(int) ls->pixel;
X      ls++;
X      prediction+=(int) ls->pixel;
X      state=statistics[cs->state][ls->state];
X      cs++;
X      cs->pixel=(*p++);
X      cs->state=ZeroState;
X      value=(int) cs->pixel-prediction;
X      Encode(state,(value == 0 ? No : Yes));
X      if (value != 0)
X        {
X          /*
X            Code sign information
X          */
X          state++;
X          sign=(value < 0 ? -1 : 1);
X          Encode(state,(sign >= 0 ? No : Yes));
X          if (sign < 0)
X            value=(-value);
X          else
X            state++;
X          state++;
X          value--;
X          /*
X            Branch for code=+-1
X          */
X          Encode(state,(value == 0 ? No : Yes));
X          if (value != 0)
X            {
X              /*
X                Establish magnitude of value.
X              */
X              state=100;
X              magnitude=2;
X              while (value >= magnitude)
X              {
X                Encode(state,Yes);
X                if (state < 107)
X                  state++;
X                magnitude<<=1;
X              }
X              Encode(state,No);
X              /*
X                Code remaining bits
X              */
X              state+=7;
X              magnitude>>=2;
X              if (magnitude != 0)
X                {
X                  Encode(state,((magnitude & value) == 0 ? No : Yes));
X                  state+=6;
X                  magnitude>>=1;
X                  while (magnitude != 0)
X                  {
X                    Encode(state,((magnitude & value) == 0 ? No : Yes));
X                    magnitude>>=1;
X                  }
X                }
X            }
X          if (value >= LowerBound)
X            if (value < UpperBound)
X              cs->state=
X                (sign < ZeroState ? SmallPostitiveState : SmallNegativeState);
X            else
X              cs->state=
X                (sign < ZeroState ? LargePostitiveState : LargeNegativeState);
X        }
X    }
X  }
X  Flush();
X  (void) free((char *) scanline);
X  return((unsigned int) (q-compressed_pixels));
}
SHAR_EOF
chmod 0644 ImageMagick/compress.c ||
echo 'restore of ImageMagick/compress.c failed'
Wc_c="`wc -c < 'ImageMagick/compress.c'`"
test 44946 -eq "$Wc_c" ||
	echo 'ImageMagick/compress.c: original size 44946, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/image.h ==============
if test -f 'ImageMagick/image.h' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/image.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/image.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/image.h' &&
/*
X  Image define declarations.
*/
#define AbsoluteValue(x)  ((x) < 0 ? -(x) : (x))
#define Intensity(color)  (unsigned int)  \
X  ((unsigned int) ((color).red*77+(color).green*150+(color).blue*29) >> 8)
#define MaxColormapSize  65535
#define MaxImageSize  (4096*4096)
#define MaxRGB  255
#define MaxRunlength  255
X
/*
X  Image Id's
*/
#define UndefinedId  0
#define ImageMagickId  1
/*
X  Image classes:
*/
#define UndefinedClass  0
#define DirectClass  1
#define PseudoClass  2
/*
X  Image colorspaces:
*/
#define UndefinedColorspace  0
#define RGBColorspace  1
#define GRAYColorspace 2
#define XYZColorspace  3
#define YIQColorspace  4
#define YUVColorspace  5
/*
X  Image compression algorithms:
*/
#define UndefinedCompression  0
#define NoCompression  1
#define RunlengthEncodedCompression  2
#define QEncodedCompression  3
/*
X  Image compositing operations:
*/
#define UndefinedCompositeOp  0
#define OverCompositeOp  1
#define InCompositeOp  2
#define OutCompositeOp  3
#define AtopCompositeOp  4
#define XorCompositeOp  5
#define PlusCompositeOp  6
#define MinusCompositeOp  7
#define AddCompositeOp  8
#define SubtractCompositeOp  9
#define DifferenceCompositeOp  10
#define ReplaceCompositeOp  11
X
/*
X  Typedef declarations for the Display program.
*/
typedef struct _ColorPacket
{
X  unsigned char
X    red,
X    green,
X    blue,
X    flags;
X
X  unsigned short
X    index;
} ColorPacket;
X
typedef struct _RunlengthPacket
{
X  unsigned char
X    red,
X    green,
X    blue,
X    length;
X
X  unsigned short
X    index;
} RunlengthPacket;
X
typedef struct _Image
{
X  FILE
X    *file;
X
X  char
X    filename[2048],
X    magick[12],
X    *comments,
X    *label;
X
X  unsigned int
X    id,
X    class,
X    colorspace,
X    alpha,
X    compression,
X    columns,
X    rows,
X    colors,
X    scene,
X    quality;
X
X  char
X    *montage,
X    *directory;
X
X  ColorPacket
X    *colormap;
X
X  char
X    *signature;
X
X  RunlengthPacket
X    *pixels,
X    *packet;
X
X  unsigned long int
X    packets;
X
X  unsigned int
X    runlength,
X    packet_size;
X
X  unsigned char
X    *packed_pixels;
X
X  unsigned int
X    orphan;
X
X  struct _Image
X    *last,
X    *next;
} Image;
X
/*
X  Image utilities routines.
*/
extern Image
X  *AllocateImage _Declare((char *)),
X  *BorderImage _Declare((Image *,unsigned int,unsigned int,ColorPacket)),
X  *ClipImage _Declare((Image *,int,int,unsigned int,unsigned int)),
X  *CopyImage _Declare((Image *,unsigned int,unsigned int,unsigned int)),
X  *EnhanceImage _Declare((Image *)),
X  *NoisyImage _Declare((Image *)),
X  *ReadImage _Declare((char *)),
X  *ReduceImage _Declare((Image *)),
X  *ReflectImage _Declare((Image *)),
X  *RotateImage _Declare((Image *,double,int)),
X  *ScaleImage _Declare((Image *,unsigned int,unsigned int)),
X  *StereoImage _Declare((Image *,Image *)),
X  *ZoomImage _Declare((Image *));
X
extern int
X  ReadDataBlock _Declare((char *,FILE *));
X
extern unsigned int
X  NumberColors _Declare((Image *)),
X  PackImage _Declare((Image *)),
X  PrintImage _Declare((Image *,char *)),
X  ReadData _Declare((char *,int,int,FILE *)),
X  UncompressImage _Declare((Image *)),
X  UnpackImage _Declare((Image *)),
X  WriteImage _Declare((Image *));
X
extern void
X  CloseImage _Declare((Image *)),
X  ColormapSignature _Declare((Image *)),
X  CompositeImage _Declare((Image *,unsigned int,Image *,int,int)),
X  CompressColormap _Declare((Image *)),
X  CompressImage _Declare((Image *)),
X  DestroyImage _Declare((Image *)),
X  DestroyImages _Declare((Image *)),
X  GammaImage _Declare((Image *,double)),
X  InverseImage _Declare((Image *)),
X  NormalizeImage _Declare((Image *)),
X  OpenImage _Declare((Image *,char *)),
X  QuantizationError _Declare((Image *,unsigned int *,double *,double *)),
X  QuantizeImage _Declare((Image *,unsigned int,unsigned int,unsigned int,
X    unsigned int,unsigned int)),
X  QuantizeImages _Declare((Image **,unsigned int,Image *,unsigned int,
X    unsigned int,unsigned int,unsigned int,unsigned int)),
X  RGBTransformImage _Declare((Image *,unsigned int)),
X  SortColormapByIntensity _Declare((Image *)),
X  TransformImage _Declare((Image **,char *,char *,char *)),
X  TransformRGBImage _Declare((Image *,unsigned int));
SHAR_EOF
chmod 0644 ImageMagick/image.h ||
echo 'restore of ImageMagick/image.h failed'
Wc_c="`wc -c < 'ImageMagick/image.h'`"
test 4107 -eq "$Wc_c" ||
	echo 'ImageMagick/image.h: original size 4107, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/display.c ==============
if test -f 'ImageMagick/display.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/display.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/display.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/display.c' &&
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%             DDDD   IIIII  SSSSS  PPPP   L       AAA   Y   Y                 %
%             D   D    I    SS     P   P  L      A   A   Y Y                  %
%             D   D    I     SSS   PPPP   L      AAAAA    Y                   %
%             D   D    I       SS  P      L      A   A    Y                   %
%             DDDD   IIIII  SSSSS  P      LLLLL  A   A    Y                   %
%                                                                             %
%                                                                             %
%          Display Machine Independent File Format Image via X11.             %
%                                                                             %
%                                                                             %
%                                                                             %
%                           Software Design                                   %
%                             John Cristy                                     %
%                              July 1992                                      %
%                                                                             %
%                                                                             %
%  Copyright 1992 E. I. du Pont de Nemours & Company                          %
%                                                                             %
%  Permission to use, copy, modify, distribute, and sell this software and    %
SHAR_EOF
true || echo 'restore of ImageMagick/display.c failed'
fi
echo 'End of  part 10'
echo 'File ImageMagick/display.c is continued in part 11'
echo 11 > _shar_seq_.tmp
exit 0
exit 0 # Just in case...
