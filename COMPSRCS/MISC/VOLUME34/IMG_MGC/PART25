Newsgroups: comp.sources.misc
From: cristy@eplrx7.es.duPont.com (John Cristy)
Subject:  v34i053:  imagemagick - X11 image processing and display v2.2, Part25/26
Message-ID: <1992Dec15.035938.23162@sparky.imd.sterling.com>
X-Md4-Signature: 64aae8f7bdf9f3af4a6a9f14abf84424
Date: Tue, 15 Dec 1992 03:59:38 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: cristy@eplrx7.es.duPont.com (John Cristy)
Posting-number: Volume 34, Issue 53
Archive-name: imagemagick/part25
Environment: UNIX, VMS, X11, SGI, DEC, Cray, Sun, Vax

#!/bin/sh
# this is Part.25 (part 25 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file ImageMagick/utilities/mogrify.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 25; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping ImageMagick/utilities/mogrify.c'
else
echo 'x - continuing file ImageMagick/utilities/mogrify.c'
sed 's/^X//' << 'SHAR_EOF' >> 'ImageMagick/utilities/mogrify.c' &&
X                  if (Latin1Compare("yiq",option) == 0)
X                    colorspace=YIQColorspace;
X                  if (Latin1Compare("yuv",option) == 0)
X                    colorspace=YUVColorspace;
X                  if (Latin1Compare("xyz",option) == 0)
X                    colorspace=XYZColorspace;
X                  if (colorspace == UndefinedColorspace)
X                    Error("invalid colorspace type on -colorspace",option);
X                }
X              break;
X            }
X          if (strncmp("compress",option+1,3) == 0)
X            {
X              compression=NoCompression;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing type on -compress",(char *) NULL);
X                  option=argv[i];
X                  if (Latin1Compare("runlengthencoded",option) == 0)
X                    compression=RunlengthEncodedCompression;
X                  else
X                    if (Latin1Compare("qencoded",option) == 0)
X                      compression=QEncodedCompression;
X                    else
X                      Error("invalid compression type on -compress",option);
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'd':
X        {
X          if (strncmp("density",option+1,3) == 0)
X            {
X              alien_info.density=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing density on -density",(char *) NULL);
X                  alien_info.density=argv[i];
X                }
X              break;
X            }
X          if (strncmp("display",option+1,3) == 0)
X            {
X              alien_info.server_name=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing server name on -display",(char *) NULL);
X                  alien_info.server_name=argv[i];
X                }
X              break;
X            }
X          if (strncmp("dither",option+1,3) == 0)
X            {
X              dither=(*option == '-');
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'e':
X        {
X          enhance=(*option == '-');
X          break;
X        }
X        case 'g':
X        {
X          if (strncmp("gamma",option+1,2) == 0)
X            {
X              gamma=0.0;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%f",(float *) &x))
X                    Error("missing gamma on -gamma",(char *) NULL);
X                  gamma=atof(argv[i]);
X                }
X              break;
X            }
X          if (strncmp("geometry",option+1,2) == 0)
X            {
X              image_geometry=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing geometry on -geometry",(char *) NULL);
X                  image_geometry=argv[i];
X                }
X              alien_info.geometry=image_geometry;
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'h':
X        {
X          Usage();
X          break;
X        }
X        case 'i':
X        {
X          inverse=(*option == '-');
X          break;
X        }
X        case 'm':
X        {
X          monochrome=(*option == '-');
X          break;
X        }
X        case 'n':
X        {
X          if (strncmp("noise",option+1,3) == 0)
X            {
X              noise=(*option == '-');
X              break;
X            }
X          if (strncmp("normalize",option+1,3) == 0)
X            {
X              normalize=(*option == '-');
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'r':
X        {
X          if (strncmp("reflect",option+1,2) == 0)
X            {
X              reflect=(*option == '-');
X              break;
X            }
X          if (strncmp("rotate",option+1,3) == 0)
X            {
X              degrees=0;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                    Error("missing degrees on -rotate",(char *) NULL);
X                  degrees=atoi(argv[i]);
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 's':
X        {
X          if (strncmp("scale",option+1,3) == 0)
X            {
X              scale_geometry=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%f",(float *) &x))
X                    Error("missing scale geometry on -scale",(char *) NULL);
X                  scale_geometry=argv[i];
X                }
X              break;
X            }
X          if (strncmp("scene",option+1,3) == 0)
X            {
X              scene=0;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                    Error("missing scene number on -scene",(char *) NULL);
X                  scene=atoi(argv[i]);
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 't':
X        {
X          tree_depth=0;
X          if (*option == '-')
X            {
X              i++;
X              if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                Error("missing depth on -treedepth",(char *) NULL);
X              tree_depth=atoi(argv[i]);
X            }
X          break;
X        }
X        case 'v':
X        {
X          verbose=(*option == '-');
X          alien_info.verbose=verbose;
X          break;
X        }
X        default:
X        {
X          Error("unrecognized option",option);
X          break;
X        }
X      }
X    else
X      {
X        Image
X          *image,
X          info_image,
X          *next_image;
X
X        time_t
X          start_time;
X
X        unsigned long
X          total_colors;
X
X        /*
X          Option is a file name: begin by reading image from specified file.
X        */
X        start_time=time((time_t *) 0);
X        (void) strcpy(alien_info.filename,option);
X        image=ReadAlienImage(&alien_info);
X        if (image == (Image *) NULL)
X          if (*option == '-')
X            break;
X          else
X            continue;
X        do
X        {
X          info_image=(*image);
X          if (scene > 0)
X            image->scene=scene;
X          /*
X            Transform image as defined by the clip, image and scale geometries.
X          */
X          TransformImage(&image,clip_geometry,image_geometry,scale_geometry);
X          if (reflect)
X            {
X              Image
X                *reflected_image;
X
X              /*
X                Reverse image scanlines.
X              */
X              reflected_image=ReflectImage(image);
X              if (reflected_image != (Image *) NULL)
X                {
X                  DestroyImage(image);
X                  image=reflected_image;
X                }
X            }
X          if ((degrees % 360) != 0)
X            {
X              Image
X                *rotated_image;
X
X              /*
X                Rotate image.
X              */
X              rotated_image=RotateImage(image,(double) degrees,False);
X              if (rotated_image != (Image *) NULL)
X                {
X                  DestroyImage(image);
X                  image=rotated_image;
X                }
X            }
X          if (enhance)
X            {
X              Image
X                *enhanced_image;
X
X              /*
X                Enhance image.
X              */
X              enhanced_image=EnhanceImage(image);
X              if (enhanced_image != (Image *) NULL)
X                {
X                  DestroyImage(image);
X                  image=enhanced_image;
X                }
X            }
X          if (noise)
X            {
X              Image
X                *noisy_image;
X
X              /*
X                Reduce noise in image.
X              */
X              noisy_image=NoisyImage(image);
X              if (noisy_image != (Image *) NULL)
X                {
X                  DestroyImage(image);
X                  image=noisy_image;
X                }
X            }
X          if (gamma > 0.0)
X            GammaImage(image,gamma);
X          if (inverse)
X            InverseImage(image);
X          if (normalize)
X            NormalizeImage(image);
X          if (verbose)
X            {
X              /*
X                Initialize image error attributes.
X              */
X              if (image->class == DirectClass)
X                image->colors=NumberColors(image);
X              total_colors=image->colors;
X            }
X          if (colorspace == GRAYColorspace)
X            QuantizeImage(image,256,8,dither,GRAYColorspace,True);
X          if (monochrome)
X            QuantizeImage(image,2,8,dither,GRAYColorspace,True);
X          if (number_colors > 0)
X            if ((image->class == DirectClass) ||
X                (image->colors > number_colors))
X              QuantizeImage(image,number_colors,tree_depth,dither,colorspace,
X                True);
X          if (verbose)
X            {
X              /*
X                Display detailed info about the image.
X              */
X              (void) fprintf(stderr,"[%u] %s",
X                image->scene == 0 ? image_number : image->scene,
X                info_image.filename);
X              (void) fprintf(stderr," %ux%u",info_image.columns,
X                info_image.rows);
X              if ((info_image.columns != image->columns) ||
X                  (info_image.rows != image->rows))
X                (void) fprintf(stderr,"=>%ux%u",image->columns,image->rows);
X              if (image->class == DirectClass)
X                (void) fprintf(stderr," DirectClass ");
X              else
X                (void) fprintf(stderr," PseudoClass ");
X              if (total_colors != image->colors)
X                (void) fprintf(stderr,"%lu=>",total_colors);
X              (void) fprintf(stderr,"%uc",image->colors);
X              if ((number_colors > 0) || monochrome)
X                {
X                  double
X                    normalized_maximum_error,
X                    normalized_mean_error;
X
X                  unsigned int
X                    mean_error_per_pixel;
X
X                  /*
X                    Measure quantization error.
X                  */
X                  QuantizationError(image,&mean_error_per_pixel,
X                    &normalized_mean_error,&normalized_maximum_error);
X                  (void) fprintf(stderr," %u/%.6f/%.6fe",mean_error_per_pixel,
X                    normalized_mean_error,normalized_maximum_error);
X                }
X              (void) fprintf(stderr," %s %lds\n",image->magick,
X                time((time_t *) 0)-start_time+1);
X            }
X          if (compression != UndefinedCompression)
X            image->compression=compression;
X          else
X            image->compression=info_image.compression;
X          if (number_colors == 0)
X            (void) WriteAlienImage(image);
X          if (image_number == maximum_images)
X            {
X              /*
X                Increase size of images array.
X              */
X              maximum_images<<=1;
X              images=(Image **)
X                realloc((char *) images,maximum_images*sizeof(Image *));
X              if (images == (Image **) NULL)
X                Error("unable to mogrify images","memory allocation failed");
X            }
X          images[image_number++]=image;
X          next_image=image->next;
X          if (next_image != (Image *) NULL)
X            image=next_image;
X        } while (next_image != (Image *) NULL);
X        if (number_colors == 0)
X          DestroyImages(image);
X      }
X    }
X  if (image_number == 0)
X    Error("missing an image file name",(char *) NULL);
X  if (number_colors > 0)
X    {
X      Image
X        *colormap_image;
X
X      /*
X        Global colormap option;  reduce colors then write image.
X      */
X      if (colormap_filename != (char *) NULL)
X        {
X          (void) strcpy(alien_info.filename,colormap_filename);
X          colormap_image=ReadAlienImage(&alien_info);
X          if (colormap_image == (Image *) NULL)
X            Error("unable to mogrify images","cannot read image colormap");
X        }
X      maximum_images=image_number;
X      QuantizeImages(images,maximum_images,colormap_image,number_colors,
X        tree_depth,dither,colorspace,True);
X      if (colormap_image != (Image *) NULL)
X	DestroyImage(colormap_image);
X      for (image_number=0; image_number < maximum_images; image_number++)
X      {
X        (void) WriteAlienImage(images[image_number]);
X        DestroyImage(images[image_number]);
X      }
X    }
X  (void) free((char *) images);
X  return(False);
}
SHAR_EOF
echo 'File ImageMagick/utilities/mogrify.c is complete' &&
chmod 0644 ImageMagick/utilities/mogrify.c ||
echo 'restore of ImageMagick/utilities/mogrify.c failed'
Wc_c="`wc -c < 'ImageMagick/utilities/mogrify.c'`"
test 27143 -eq "$Wc_c" ||
	echo 'ImageMagick/utilities/mogrify.c: original size 27143, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/utilities/Imakefile ==============
if test -f 'ImageMagick/utilities/Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/utilities/Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/utilities/Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/utilities/Imakefile' &&
#
#  Imakefile for ImageMagick image utilities.
#
#  Copyright 1992 E. I. du Pont de Nemours & Company
#
#  Permission to use, copy, modify, distribute, and sell this software and
#  its documentation for any purpose is hereby granted without fee,
#  provided that the above Copyright notice appear in all copies and that
#  both that Copyright notice and this permission notice appear in
#  supporting documentation, and that the name of E. I. du Pont de Nemours
#  & Company not be used in advertising or publicity pertaining to
#  distribution of the software without specific, written prior
#  permission.  E. I. du Pont de Nemours & Company makes no representations
#  about the suitability of this software for any purpose.  It is provided
#  "as is" without express or implied warranty.
#
#  E. I. du Pont de Nemours & Company disclaims all warranties with regard
#  to this software, including all implied warranties of merchantability
#  and fitness, in no event shall E. I. du Pont de Nemours & Company be
#  liable for any special, indirect or consequential damages or any
#  damages whatsoever resulting from loss of use, data or profits, whether
#  in an action of contract, negligence or other tortious action, arising
#  out of or in connection with the use or performance of this software.
#
X
#include "../Magick.tmpl"
X
EXTRA_INCLUDES= -I..
X
MagickObjects= ../X.o ../image.o ../rotate.o ../quantize.o ../colors.o \
X  ../signature.o ../compress.o ../alien.o ../PreRvIcccm.o
X
CONVERTObjects= convert.o $(MagickObjects)
MOGRIFYObjects= mogrify.o $(MagickObjects)
MIFFtoSTEREOSources= MIFFtoSTEREO.c
MIFFtoSTEREOObjects= MIFFtoSTEREO.o $(MagickObjects)
X
PROGRAMS= mogrify convert MIFFtoSTEREO
X
AllTarget($(PROGRAMS))
X
NormalProgramTarget(mogrify,$(MOGRIFYObjects), , , )
InstallProgram(mogrify,$(LOCALDIR))
InstallManPage(mogrify,$(MANDIR))
NormalProgramTarget(convert,$(CONVERTObjects), , , )
InstallProgram(convert,$(LOCALDIR))
InstallManPage(convert,$(MANDIR))
NormalProgramTarget(MIFFtoSTEREO,$(MIFFtoSTEREOObjects), , , )
InstallProgram(MIFFtoSTEREO,$(LOCALDIR))
DependTarget()
SHAR_EOF
chmod 0644 ImageMagick/utilities/Imakefile ||
echo 'restore of ImageMagick/utilities/Imakefile failed'
Wc_c="`wc -c < 'ImageMagick/utilities/Imakefile'`"
test 2095 -eq "$Wc_c" ||
	echo 'ImageMagick/utilities/Imakefile: original size 2095, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/utilities/Makefile ==============
if test -f 'ImageMagick/utilities/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/utilities/Makefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/utilities/Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/utilities/Makefile' &&
#
#  Generic makefile for convert, mogrify, MIFFtoSTEREO, and import for
#  computers that do not have xmkmf.
#
#  Copyright 1992 E. I. du Pont de Nemours & Company
#
#  Permission to use, copy, modify, distribute, and sell this software and
#  its documentation for any purpose is hereby granted without fee,
#  provided that the above Copyright notice appear in all copies and that
#  both that Copyright notice and this permission notice appear in
#  supporting documentation, and that the name of E. I. du Pont de Nemours
#  & Company not be used in advertising or publicity pertaining to
#  distribution of the software without specific, written prior
#  permission.  E. I. du Pont de Nemours & Company makes no representations
#  about the suitability of this software for any purpose.  It is provided
#  "as is" without express or implied warranty.
#
#  E. I. du Pont de Nemours & Company disclaims all warranties with regard
#  to this software, including all implied warranties of merchantability
#  and fitness, in no event shall E. I. du Pont de Nemours & Company be
#  liable for any special, indirect or consequential damages or any
#  damages whatsoever resulting from loss of use, data or profits, whether
#  in an action of contract, negligence or other tortious action, arising
#  out of or in connection with the use or performance of this software.
#
X
#
# Uncomment the following lines if you have the JPEG or TIFF libraries.
# See README for more details.
#
#JPEG= -DAlienJPEG
#JPEG_LIBRARIES= -L../jpeg -ljpeg
#JPEG_INCLUDES= -I../jpeg
#TIFF= -DAlienTIFF
#TIFF_LIBRARIES= -L../tiff/libtiff -ltiff
#TIFF_INCLUDES= -I../tiff/libtiff
X
XXLIB= -L/usr/lib/X11R4 -lX11
X
CC= cc -O -I/usr/include/X11R4
DESTDIR= /usr/local/bin
INSTALL = install -c
RM= /bin/rm -f
X
DEFINES= -I.. $(JPEG) $(JPEG_INCLUDES) $(TIFF) $(TIFF_INCLUDES)
SYS_LIBRARIES= $(XLIB) $(JPEG_LIBRARIES) $(TIFF_LIBRARIES) -lm
X
MagickObjects= ../X.o ../image.o ../rotate.o ../quantize.o ../colors.o \
X  ../signature.o ../compress.o ../alien.o ../PreRvIcccm.o
X
ConvertObjects= convert.o $(MagickObjects)
MogrifyObjects= mogrify.o $(MagickObjects)
ImportObjects= import.o $(MagickObjects)
MIFFtoSTEREOObjects= MIFFtoSTEREO.o $(MagickObjects)
X
PROGRAMS= convert mogrify MIFFtoSTEREO
X
CFLAGS= $(DEFINES)
X
all: $(PROGRAMS)
X
convert: $(ConvertObjects)
X	$(RM) $@
X	$(CC) -o $@ $(ConvertObjects) $(SYS_LIBRARIES)
X
clean::
X	$(RM) convert
X
install:: convert
X	$(INSTALL) convert $(DESTDIR)
X
mogrify: $(MogrifyObjects)
X	$(RM) $@
X	$(CC) -o $@ $(MogrifyObjects) $(SYS_LIBRARIES)
X
clean::
X	$(RM) mogrify
X
install:: mogrify
X	$(INSTALL) mogrify $(DESTDIR)
X
MIFFtoSTEREO: $(MIFFtoSTEREOObjects)
X	$(RM) $@
X	$(CC) -o $@ $(MIFFtoSTEREOObjects) $(SYS_LIBRARIES)
X
clean::
X	$(RM) MIFFtoSTEREO
X
install:: MIFFtoSTEREO
X	$(INSTALL) MIFFtoSTEREO $(DESTDIR)
X
clean::
X	$(RM) *.ln *.bak *.o core errs ,* *~ *.a .emacs_* make.log MakeOut
SHAR_EOF
chmod 0644 ImageMagick/utilities/Makefile ||
echo 'restore of ImageMagick/utilities/Makefile failed'
Wc_c="`wc -c < 'ImageMagick/utilities/Makefile'`"
test 2880 -eq "$Wc_c" ||
	echo 'ImageMagick/utilities/Makefile: original size 2880, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/utilities/convert.c ==============
if test -f 'ImageMagick/utilities/convert.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/utilities/convert.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/utilities/convert.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/utilities/convert.c' &&
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%                CCCC   OOO   N   N  V   V  EEEEE  RRRR   TTTTT               %
%               C      O   O  NN  N  V   V  E      R   R    T                 %
%               C      O   O  N N N  V   V  EEE    RRRR     T                 %
%               C      O   O  N  NN   V V   E      R R      T                 %
%                CCCC   OOO   N   N    V    EEEEE  R  R     T                 %
%                                                                             %
%                                                                             %
%                 Convert a image from one format to another.                 %
%                                                                             %
%                                                                             %
%                                                                             %
%                              Software Design                                %
%                                John Cristy                                  %
%                                April 1992                                   %
%                                                                             %
%                                                                             %
%  Copyright 1992 E. I. Dupont de Nemours & Company                           %
%                                                                             %
%  Permission to use, copy, modify, distribute, and sell this software and    %
%  its documentation for any purpose is hereby granted without fee,           %
%  provided that the above Copyright notice appear in all copies and that     %
%  both that Copyright notice and this permission notice appear in            %
%  supporting documentation, and that the name of E. I. Dupont de Nemours     %
%  & Company not be used in advertising or publicity pertaining to            %
%  distribution of the software without specific, written prior               %
%  permission.  E. I. Dupont de Nemours & Company makes no representations    %
%  about the suitability of this software for any purpose.  It is provided    %
%  "as is" without express or implied warranty.                               %
%                                                                             %
%  E. I. Dupont de Nemours & Company disclaims all warranties with regard     %
%  to this software, including all implied warranties of merchantability      %
%  and fitness, in no event shall E. I. Dupont de Nemours & Company be        %
%  liable for any special, indirect or consequential damages or any           %
%  damages whatsoever resulting from loss of use, data or profits, whether    %
%  in an action of contract, negligence or other tortious action, arising     %
%  out of or in connection with the use or performance of this software.      %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  The convert program syntax is:
%
%  Usage: convert [options ...] file
%
%  Where options include:
%    -alpha              store alpha channel if the image has one
%    -colors value       preferred number of colors in the image
%    -colorspace type    GRAY, RGB, XYZ, YIQ, or YUV
%    -compress type      RunlengthEncoded or QEncoded
%    -density geometry   vertical and horizonal density of the image
%    -display server     obtain image or font from this X server
%    -dither             apply Floyd/Steinberg error diffusion to image
%    -geometry geometry  width and height of the image
%    -quality value      JPEG quality setting
%    -scene value        image scene number
%    -treedepth value    depth of the color classification tree
%    -verbose            print detailed information about the image
%
%  Change '-' to '+' in any option above to reverse its effect.  For
%  example,  specify +alpha to store the image without its alpha channel.
%
%  By default, the image format of `file' is determined by its magic
%  number.  To specify a particular image format, precede the filename
%  with an image format name and a colon (i.e. mtv:image) or specify the
%  image type as the filename suffix (i.e. image.mtv).  Specify 'file' as
%  '-' for standard input or output.
%
%
*/
X
#include "display.h"
#include "image.h"
#include "alien.h"
#include "X.h"
X
/*
X  Global declarations.
*/
char
X  *application_name;
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   E r r o r                                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function Error displays an error message and then terminates the program.
%
%  The format of the Error routine is:
%
%      Error(message,qualifier)
%
%  A description of each parameter follows:
%
%    o message: Specifies the message to display before terminating the
%      program.
%
%    o qualifier: Specifies any qualifier to the message.
%
%
*/
void Error(message,qualifier)
char
X  *message,
X  *qualifier;
{
X  (void) fprintf(stderr,"%s: %s",application_name,message);
X  if (qualifier != (char *) NULL)
X    (void) fprintf(stderr," (%s)",qualifier);
X  (void) fprintf(stderr,".\n");
X  exit(1);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   U s a g e                                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Procedure Usage displays the program usage;
%
%  The format of the Usage routine is:
%
%      Usage()
%
%
*/
static void Usage()
{
X  char
X    **p;
X
X  static char
X    *options[]=
X    {
X      "-alpha              store alpha channel if the image has one",
X      "-colors value       preferred number of colors in the image",
X      "-colorspace type    GRAY, RGB, XYZ, YIQ, or YUV",
X      "-compress type      RunlengthEncoded or QEncoded",
X      "-density geometry   vertical and horizonal density of the image",
X      "-display server     obtain image or font from this X server",
X      "-dither             apply Floyd/Steinberg error diffusion to image",
X      "-geometry geometry  width and height of the image",
X      "-quality value      JPEG quality setting",
X      "-scene value        image scene number",
X      "-treedepth value    depth of the color classification tree",
X      "-verbose            print detailed information about the image",
X      (char *) NULL
X    };
X  (void) fprintf(stderr,"Usage: %s [options ...] input_file output_file\n",
X    application_name);
X  (void) fprintf(stderr,"\nWhere options include:\n");
X  for (p=options; *p != (char *) NULL; p++)
X    (void) fprintf(stderr,"  %s\n",*p);
X  (void) fprintf(stderr,
X    "\nChange '-' to '+' in any option above to reverse its effect.  For\n");
X  (void) fprintf(stderr,
X    "example,  specify +alpha to store the image without an alpha channel.\n");
X  (void) fprintf(stderr,
X    "\nBy default, the image format of `file' is determined by its magic\n");
X  (void) fprintf(stderr,
X    "number.  To specify a particular image format, precede the filename\n");
X  (void) fprintf(stderr,
X    "with an image format name and a colon (i.e. mtv:image) or specify the\n");
X  (void) fprintf(stderr,
X    "image type as the filename suffix (i.e. image.mtv).  Specify 'file' as\n");
X  (void) fprintf(stderr,"'-' for standard input or output.\n");
X  exit(1);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  M a i n                                                                    %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
*/
int main(argc,argv)
int
X  argc;
X
char
X  *argv[];
{
#define NotInitialized  (~0)
X
X  AlienInfo
X    alien_info;
X
X  char
X    *filename,
X    *option;
X
X  Image
X    *image,
X    *next_image;
X
X  int
X    i,
X    status,
X    x;
X
X  time_t
X    start_time;
X
X  unsigned int
X    alpha,
X    colorspace,
X    compression,
X    dither,
X    number_colors,
X    quality,
X    scene,
X    total_colors,
X    tree_depth,
X    verbose;
X
X  /*
X    Initialize program variables.
X  */
X  application_name=argv[0];
X  if (argc < 3)
X    Usage();
X  /*
X    Read image and convert to MIFF format.
X  */
X  GetAlienInfo(&alien_info);
X  alpha=NotInitialized;
X  colorspace=RGBColorspace;
X  compression=UndefinedCompression;
X  dither=False;
X  number_colors=0;
X  quality=0;
X  scene=0;
X  tree_depth=0;
X  verbose=False;
X  /*
X    Check command syntax.
X  */
X  filename=(char *) NULL;
X  for (i=1; i < (argc-1); i++)
X  {
X    option=argv[i];
X    if (((int) strlen(option) < 2) || ((*option != '-') && (*option != '+')))
X      filename=argv[i];
X    else
X      switch(*(option+1))
X      {
X        case 'a':
X        {
X          alpha=(*option == '-');
X          break;
X        }
X        case 'c':
X        {
X          if (strncmp("colors",option+1,7) == 0)
X            {
X              number_colors=0;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                    Error("missing colors on -colors",(char *) NULL);
X                  number_colors=atoi(argv[i]);
X                }
X              break;
X            }
X          if (strncmp("colorspace",option+1,7) == 0)
X            {
X              colorspace=RGBColorspace;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing type on -colorspace",(char *) NULL);
X                  option=argv[i];
X                  colorspace=UndefinedColorspace;
X                  if (Latin1Compare("gray",option) == 0)
X                    colorspace=GRAYColorspace;
X                  if (Latin1Compare("rgb",option) == 0)
X                    colorspace=RGBColorspace;
X                  if (Latin1Compare("yiq",option) == 0)
X                    colorspace=YIQColorspace;
X                  if (Latin1Compare("yuv",option) == 0)
X                    colorspace=YUVColorspace;
X                  if (Latin1Compare("xyz",option) == 0)
X                    colorspace=XYZColorspace;
X                  if (colorspace == UndefinedColorspace)
X                    Error("invalid colorspace type on -colorspace",option);
X                }
X              break;
X            }
X          if (strncmp("compress",option+1,3) == 0)
X            {
X              compression=NoCompression;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing type on -compress",(char *) NULL);
X                  option=argv[i];
X                  if (Latin1Compare("runlengthencoded",option) == 0)
X                    compression=RunlengthEncodedCompression;
X                  else
X                    if (Latin1Compare("qencoded",option) == 0)
X                      compression=QEncodedCompression;
X                    else
X                      Error("invalid compression type on -compress",option);
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'd':
X        {
X          if (strncmp("density",option+1,3) == 0)
X            {
X              alien_info.density=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing density on -density",(char *) NULL);
X                  alien_info.density=argv[i];
X                }
X              break;
X            }
X          if (strncmp("display",option+1,3) == 0)
X            {
X              alien_info.server_name=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing server name on -display",(char *) NULL);
X                  alien_info.server_name=argv[i];
X                }
X              break;
X            }
X          if (strncmp("dither",option+1,3) == 0)
X            {
X              dither=(*option == '-');
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'f':
X        {
X          alien_info.font=(char *) NULL;
X          if (*option == '-')
X            {
X              i++;
X              if (i == argc)
X                Error("missing font name on -font",(char *) NULL);
X              alien_info.font=argv[i];
X            }
X          break;
X        }
X        case 'g':
X        {
X          alien_info.geometry=(char *) NULL;
X          if (*option == '-')
X            {
X              i++;
X              if (i == argc)
X                Error("missing geometry on -geometry",(char *) NULL);
X              alien_info.geometry=argv[i];
X            }
X          break;
X        }
X        case 'h':
X        {
X          Usage();
X          break;
X        }
X        case 'q':
X        {
X          i++;
X          if ((i == argc) || !sscanf(argv[i],"%d",&x))
X            Error("missing quality on -quality",(char *) NULL);
X          quality=atoi(argv[i]);
X          break;
X        }
X        case 's':
X        {
X          scene=0;
X          if (*option == '-')
X            {
X              i++;
X              if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                Error("missing scene number on -scene",(char *) NULL);
X              scene=atoi(argv[i]);
X            }
X          break;
X        }
X        case 't':
X        {
X          tree_depth=0;
X          if (*option == '-')
X            {
X              i++;
X              if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                Error("missing depth on -treedepth",(char *) NULL);
X              tree_depth=atoi(argv[i]);
X            }
X          break;
X        }
X        case 'v':
X        {
X          verbose=(*option == '-');
X          alien_info.verbose=verbose;
X          break;
X        }
X        default:
X        {
X          Error("unrecognized option",option);
X          break;
X        }
X      }
X  }
X  if (filename == (char *) NULL)
X    Error("missing an image file name",(char *) NULL);
X  start_time=time((time_t *) 0);
X  (void) strcpy(alien_info.filename,filename);
X  image=ReadAlienImage(&alien_info);
X  if (image == (Image *) NULL)
X    exit(1);
X  /*
X    Write images.
X  */
X  do
X  {
X    if (alpha != NotInitialized)
X      image->alpha=alpha;
X    if (compression != UndefinedCompression)
X      image->compression=compression;
X    if (quality > 0)
X      image->quality=quality;
X    if (scene > 0)
X      image->scene=scene;
X    (void) strcpy(image->filename,argv[i]);
X    if (image->last != (Image *) NULL)
X      (void) sprintf(image->filename,"%s.%u\0",argv[i],image->scene);
X    if (verbose)
X      {
X        /*
X          Initialize image error attributes.
X        */
X        if (image->class == DirectClass)
X          image->colors=NumberColors(image);
X        total_colors=image->colors;
X      }
X    if (colorspace == GRAYColorspace)
X      QuantizeImage(image,256,8,dither,GRAYColorspace,True);
X    if (number_colors > 0)
X      if ((image->class == DirectClass) || (image->colors > number_colors))
X        QuantizeImage(image,number_colors,tree_depth,dither,colorspace,True);
X    status=WriteAlienImage(image);
X    if (verbose)
X      {
X        /*
X          Display detailed info about the image.
X        */
X        (void) fprintf(stderr,"[%u] %s=>%s %ux%u",image->scene,filename,
X          image->filename,image->columns,image->rows);
X        if (image->class == DirectClass)
X          (void) fprintf(stderr," DirectClass ");
X        else
X          (void) fprintf(stderr," PseudoClass ");
X        if (total_colors != image->colors)
X          (void) fprintf(stderr,"%u=>",total_colors);
X        (void) fprintf(stderr,"%uc",image->colors);
X        if (number_colors > 0)
X          {
X            double
X              normalized_maximum_error,
X              normalized_mean_error;
X
X            unsigned int
X              mean_error_per_pixel;
X
X            /*
X              Measure quantization error.
X            */
X            QuantizationError(image,&mean_error_per_pixel,
X              &normalized_mean_error,&normalized_maximum_error);
X            (void) fprintf(stderr," %u/%.6f/%.6fe",mean_error_per_pixel,
X              normalized_mean_error,normalized_maximum_error);
X          }
X        (void) fprintf(stderr," %s %lds\n",image->magick,
X          time((time_t *) 0)-start_time+1);
X      }
X    next_image=image->next;
X    DestroyImage(image);
X    image=next_image;
X  } while (image != (Image *) NULL);
X  return(!status);
}
SHAR_EOF
chmod 0644 ImageMagick/utilities/convert.c ||
echo 'restore of ImageMagick/utilities/convert.c failed'
Wc_c="`wc -c < 'ImageMagick/utilities/convert.c'`"
test 18313 -eq "$Wc_c" ||
	echo 'ImageMagick/utilities/convert.c: original size 18313, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/utilities/mogrify.man ==============
if test -f 'ImageMagick/utilities/mogrify.man' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/utilities/mogrify.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/utilities/mogrify.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/utilities/mogrify.man' &&
.ad l
.nh
.TH MOGRIFY 1 "10 October 1992" "ImageMagick"
.SH NAME
mogrify - transform an image or sequence of images
.SH SYNOPSIS
.B "mogrify" [ \fIoptions\fP ...] \fIfile\fP
[ [ \fIoptions\fP ...] \fIfile\fP ...]
.SH DESCRIPTION
\fIMogrify\fP transforms an image or a sequence of images.  These
transforms include image scaling, image rotation, color reduction, and
others.  The transmogrified image overwrites the original image.
.SH EXAMPLES
To scale an image of a cockatoo to exactly 640 pixels in width and 480
pixels in height, use:
.PP
X    mogrify -geometry 640x480 cockatoo.miff
.PP
To create a single colormap for a sequence of bird images, use:
.PP
X    mogrify -colors 256 scenes/birds.*
.SH OPTIONS
.TP 5
.B "-clip \fI<width>x<height>{\+-}<x offset>{\+-}<y offset>\fP"
preferred size and location of the clipped image.  See \fBX(1)\fP for details
about the geometry specification.
X
Use clipping to apply image processing options, or transmogrify, only a
particular area of an image.
.TP 5
.B "-colors \fIvalue\fP"
preferred number of colors in the image.
X
The actual number of colors in the image may be less than your request,
but never more.  Note, this is a color reduction option.  Images with
less unique colors than specified with this option will remain unchanged.
Refer to \fBQuantize(9)\fP for more details.
X
If more than one image is specified on the command line, a single
colormap is created and saved with each image.
X
Note, options \fB-dither\fP, \fB-colorspace\fP, and \fB-treedepth\fP affect
the color reduction algorithm.
.TP 5
.B "-colorspace \fIvalue\fP"
the type of colorspace: \fIGRAY\fP, \fIRGB\fP, \fIXYZ\fP, \fIYIQ\fP, or
\fIYUV\fP.
X
Color reduction, by default, takes place in the RGB color space.
Empirical evidence suggests that distances in color spaces such as YUV
or YIQ correspond to perceptual color differences more closely
than do distances in RGB space.  These color spaces may give better
results when color reducing an image.  Refer to \fBQuantize(9)\fP for
more details.
X
The \fB-colors\fP or \fB-monochrome\fP option is required
for this option to take effect.
.TP 5
.B "-compress \fItype\fP"
the type of image compression: \fIQEncoded\fP or \fIRunlengthEncoded\fP.
X
Specify \fB\+compress\fP to store the binary image in an uncompressed format.
The default is the compression type of the specified image file.
.TP 5
.B "-density \fI<width>x<height>
vertical and horizonal density of the image.
X
This option specifies an image density whose interpretation changes
with the type of image.  The default is 72 dots per inch in the
horizonal and vertical direction for Postscript.  Text files default to
80 characters in width and 60 lines in height.  Use this option to
alter the default density.
.TP 5
.B "-display \fIhost:display[.screen]\fP"
specifies the X server to contact; see \fBX(1)\fP.
.TP 5
.B "-dither"
apply Floyd/Steinberg error diffusion to the image.
X
The basic strategy of dithering is to trade intensity resolution for
spatial resolution by averaging the intensities of several neighboring
pixels.  Images which suffer from severe contouring when reducing colors
can be improved with this option.
X
The \fB-colors\fP or \fB-monochrome\fP option is required for this option
to take effect.
.TP 5
.B "-enhance"
apply a digital filter to enhance a noisy image.
.TP 5
.B "-gamma \fIvalue\fP"
level of gamma correction.
X
The same color image displayed on two different workstations may look
different due to differences in the display monitor.  Use gamma
correction to adjust for this color difference.  Reasonable values
extend from 0.8 to 2.3.
.TP 5
.B "-geometry \fI<width>x<height>\fP"
preferred size of the image window.  See \fBX(1)\fP for details
about the geometry specification.
X
If the specified image size is smaller than the actual image size, the
image is first reduced to an integral of the specified image size with
an antialias digital filter.  The image is then scaled to the exact
specified image size with pixel replication.  If the specified image
size is greater than the actual image size, the image is first enlarged
to an integral of the specified image size with bilinear
interpolation.  The image is then scaled to the exact specified image
size with pixel replication.
.TP 5
.B "-inverse"
apply color inversion to image.
X
The red, green, and blue intensities of an image are negated.
.TP 5
.B "-monochrome"
transform the image to black and white.
X
Monochrome images can benefit from error diffusion.  Use \fB-dither\fP with
this option to diffuse the error.
.TP 5
.B "-noise"
reduce the noise in an image with a noise peak elimination filter.
X
The principal function of noise peak elimination filter is to smooth
the objects within an image without losing edge information and without
creating undesired structures.  The central idea of the algorithm is to
replace a pixel with its next neighbor in value within a 3 x 3 window,
if this pixel has been found to be noise.  A pixel is defined as noise
if and only if this pixel is a maximum or minimum within the 3 x 3 window.
.TP 5
.B "-normalize"
tranform image to span the full range of color values.  This is a contrast
enhancement technique.
.TP 5
.B "-reflect"
create a "mirror image" by reflecting the image scanlines.
.TP 5
.B "-rotate \fIdegrees\fP"
apply Paeth image rotation to the image.
.TP 5
.B "-scale \fI<width factor>x<height factor>\fP"
preferred size factors of the image.
X
This option behaves like \fB-geometry\fP except the width and height values
are relative instead of absolute.  The image size is multiplied by the
width and height factors to obtain the final image dimensions.  If only
one factor is specified, both the width and height factors assume the
value.
X
Factors may be fractional.  For example, a factor of 1.5 will increase the
image size by one and one-half.
.TP 5
.B "-scene \fIvalue\fP"
image scene number.
.TP 5
.B "-treedepth \fIvalue\fP"
Normally, this integer value is zero or one.  A zero or one tells
\fIMogrify\fP to choose a optimal tree depth for the color reduction
algorithm.
X
An optimal depth generally allows the best representation of the source
image with the fastest computational speed and the least amount of
memory.  However, the default depth is inappropriate for some images.
To assure the best representation, try values between 2 and 8 for this
parameter.  Refer to \fBQuantize(9)\fP for more details.
X
The \fB-colors\fP or \fB-monochrome\fP option is required for this option
to take effect.
.TP 5
.B -verbose
print detailed information about the image.
X
This information is printed: image scene number;  image name;  image
size; the image class (\fIDirectClass\fP or \fIPseudoClass\fP); the total
number of unique colors (if known);  and the number of seconds to read and
transform the image.  Refer to \fBMIFF(5)\fP for a description of
the image class.
X
If \fB-colors\fP is also specified, the total unique colors in the image
and color reduction error values are printed.  Refer to \fBQuantize(9)\fP
for a description of these values.
.PP
Any option you specify on the command line remains in effect until it is
explicitly changed by specifying the option again with a different effect.
For example, to mogrify two images, the first with 32 colors and the
second with only 16 colors, use:
.PP
X     mogrify -colors 32 cockatoo.miff -colors 16 macaw.miff
.PP
Change \fI-\fP to \fI\+\fP in any option above to reverse its effect.
For example, specify \fB\+compress\fP to store the binary image in an
uncompressed format.
.PP
To specify a particular image format prefix \fIfile\fP with the image
type and a colon (i.e. mtv:image) or specify the image type as the
filename suffix (i.e. image.mtv).  See \fBCONVERT(1)\fP for a list of
valid image formats.  If \fIfile\fP has the extension \fB.Z\fP, the
file size is reduced using Lempel-Ziv coding with \fBcompress\fP.  If
\fIfile\fP already exists, you will be prompted as to whether it should
be overwritten.
.SH SEE ALSO
display(1), animate(1), import(1), convert(1), Quantize(9), MIFF(5), X(1),
compress(1)
.SH COPYRIGHT
Copyright 1992 E. I. du Pont de Nemours & Company
.PP
Permission to use, copy, modify, distribute, and sell this software and
its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of E. I. du Pont de Nemours
& Company not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior
permission.  E. I. du Pont de Nemours & Company makes no representations
about the suitability of this software for any purpose.  It is provided
"as is" without express or implied warranty.
.PP
E. I. du Pont de Nemours & Company disclaims all warranties with regard
to this software, including all implied warranties of merchantability
and fitness, in no event shall E. I. du Pont de Nemours & Company be
liable for any special, indirect or consequential damages or any
damages whatsoever resulting from loss of use, data or profits, whether
in an action of contract, negligence or other tortious action, arising
out of or in connection with the use or performance of this software.
.SH ACKNOWLEDGEMENTS
Michael Halle, Spatial Imaging Group at MIT, for the initial
implementation of Alan Paeth's image rotation algorithm.
.PP
David Pensak, E. I. du Pont de Nemours & Company, for providing a
computing environment that made this program possible.
.PP
Paul Raveling, USC Information Sciences Institute, for the original
idea of using space subdivision for the color reduction algorithm.
.SH AUTHORS
John Cristy, E.I. du Pont de Nemours & Company Incorporated
SHAR_EOF
chmod 0644 ImageMagick/utilities/mogrify.man ||
echo 'restore of ImageMagick/utilities/mogrify.man failed'
Wc_c="`wc -c < 'ImageMagick/utilities/mogrify.man'`"
test 9749 -eq "$Wc_c" ||
	echo 'ImageMagick/utilities/mogrify.man: original size 9749, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/utilities/convert.man ==============
if test -f 'ImageMagick/utilities/convert.man' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/utilities/convert.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/utilities/convert.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/utilities/convert.man' &&
.ad l
.nh
.TH CONVERT 1 "10 October 1992" "ImageMagick"
.SH NAME
convert - converts an input file using one image format to an output
file with a differing image format.
.SH SYNOPSIS
.B "convert"
[ \fIoptions\fP ... ] \fIfile\fP \fIfile\fP
.SH DESCRIPTION
.PP
.I Convert
converts an input file using one image format to an output file with a
differing image format. By default, the image format is determined by
its magic number. To specify a particular image format, precede the 
filename with an image format name and a colon (i.e.  mtv:image) or specify 
the image type as the filename suffix (i.e. image.mtv).  Specify \fIfile\fP as 
\fI-\fP for standard input or output.  If \fIfile\fP has the extension 
\fB.Z\fP, the file is decoded with \fIuncompress\fP.
X
\fIConvert\fP recognizes the following image formats:
X
.TP 6
.B Tag
\fBDescription\fP
.PP
-------------------------------------------------------------
.TP 6
.B AVS
Advanced Visualization System image file format.
.TP 6
.B CMYK	
Raw cyan, magenta, yellow, and black bytes.
.TP 6
.B FAX
Group 3.
.TP 6
.B GIF
Graphic Image Format.
.TP 6
.B GRAY
Raw gray bytes.
.TP 6
.B JPEG
.TP 6
.B MIFF
Machine Independant file format.
.TP 6
.B MTV
.TP 6
.B PNM
Portable bitmap.
.TP 6
.B PS
Postscript.
.TP 6
.B RGB
Raw red, green, and blue bytes.
.TP 6
.B RLE
Utah Raster Toolkit; read only.
.TP 6
.B SUN
SUN raster.
.TP 6
.B TEXT
raw text file; read only.
.TP 6
.B TIFF
Tagged Image File Format.
.TP 6
.B VICAR
read only.
.TP 6
.B YUV
Raw Y, U, and V bytes.  U and V, normally -0.5 through 0.5, are normalized
to the range 0 through 255 to fit within a byte.
.TP 6
.B X
select image from X server screen; read only.
.TP 6
.B XC
constant image of X server background color.
.TP 6
.B XBM
XX11 bitmap.
.TP 6
.B XWD
XX11 window dump.
.PP
.SH EXAMPLES
.PP
To convert a \fIMIFF\fP image of a cockatoo to a SUN raster image, use:
.PP
X     convert cockatoo.miff sun:cockatoo.ras
.PP
To convert a \fIMTV\fP image of a molecule to a JPEG image, use:
.PP
X     convert molecule.mtv molecule.jpeg
.PP
To convert a raw \fIGRAY\fP image to a portable graymap, use:
.PP
X     convert -geometry 768x512 gray:raw image.pnm
.SH OPTIONS
.TP 5
.B "-alpha"
store alpha channel if the image has one.
.TP 5
.B "-colors \fIvalue\fP"
preferred number of colors in the image.
X
The actual number of colors in the image may be less than your request,
but never more.  Note, this is a color reduction option.  Images with
less unique colors than specified with this option will remain unchanged.
Refer to \fBQuantize(9)\fP for more details.
X
Note, options \fB-dither\fP, \fB-colorspace\fP, and \fB-treedepth\fP affect
the color reduction algorithm.
.TP 5
.B "-colorspace \fIvalue\fP"
the type of colorspace: \fIGRAY\fP, \fIRGB\fP, \fIXYZ\fP, \fIYIQ\fP, or
\fIYUV\fP.
X
Color reduction, by default, takes place in the RGB color space.
Empirical evidence suggests that distances in color spaces such as YUV
or YIQ correspond to perceptual color differences more closely
than do distances in RGB space.  These color spaces may give better
results when color reducing an image.  Refer to \fBQuantize(9)\fP for
more details.
X
The \fB-colors\fP or \fB-monochrome\fP option is required for this option
to take effect.
.TP 5
.B "-compress \fItype\fP"
the type of image compression: \fIQEncoded\fP or \fIRunlengthEncoded\fP.
X
Specify \fB\+compress\fP to store the binary image in an uncompressed format.
The default is the compression type of the specified image file.
.TP 5
.B "-density \fI<width>x<height>
vertical and horizonal density of the image.
X
This option specifies an image density whose interpretation changes
with the type of image.  The default is 72 dots per inch in the
horizonal and vertical direction for Postscript.  Text files default to
80 characters in width and 60 lines in height.  Use this option to
alter the default density.
.TP 5
.B "-display \fIhost:display[.screen]\fP"
specifies the X server to contact; see \fBX(1)\fP.
.TP 5
.B "-dither"
apply Floyd/Steinberg error diffusion to the image.
X
The basic strategy of dithering is to trade intensity resolution for
spatial resolution by averaging the intensities of several neighboring
pixels.  Images which suffer from severe contouring when reducing colors
can be improved with this option.
X
The \fB-colors\fP option is required for dithering to take effect.
.TP 5
.B "-geometry \fI<width>x<height>\fP"
the width and height of the image.  
X
Use this option to specified the width and height of raw images whose
dimensions are unknown such as GRAY, RGB, and CMYK.  This option can
also change the default 8.5 by 11 width and height of the Postscript
canvas.
.TP 5
.B "-quality \fIvalue\fP"
JPEG quality setting.  Quality is 0 (worst) to 100 (best). The default is
75.
.TP 5
.B "-scene \fIvalue\fP"
image scene number.
.TP 5
.B "-treedepth \fIvalue\fP"
Normally, this integer value is zero or one.  A zero or one tells
\fIDisplay\fP to choose a optimal tree depth for the color reduction
algorithm.
X
An optimal depth generally allows the best representation of the source
image with the fastest computational speed and the least amount of
memory.  However, the default depth is inappropriate for some images.
To assure the best representation, try values between 2 and 8 for this
parameter.  Refer to \fBQuantize(9)\fP for more details.
X
The \fB-colors\fP option is required for this option to take effect.
.TP 5
.B -verbose
print detailed information about the image.
X
This information is printed: image scene number;  image name;  converted
image name;  image size;  the image class (\fIDirectClass\fP or 
\fIPseudoClass\fP);  the total number of unique colors;  and the number
of seconds to read and convert the image.
.PP
Change '-' to '+' in any option above to reverse its effect.  For
example, specify +alpha to store the image without its alpha channel.
.PP
To specify a particular image format prefix \fIfile\fP with the image
type and a colon (i.e. mtv:image) or specify the image type as the
filename suffix (i.e. image.mtv).  See the beginning of this document
for a list of valid image formats.  If \fIfile\fP has the extension
\fB.Z\fP, the file size is reduced using Lempel-Ziv coding with
\fBcompress\fP.  If \fIfile\fP already exists, you will be prompted as
to whether it should be overwritten.
X
When you specify \fBX\fP as your image type, the filename has special
meaning.  It specifies an X window by id, name, or \fBroot\fP.  If no
filename is specified, the window is selected by clicking the mouse in
the desired window.
.SH ENVIRONMENT
.PP
.TP 5
.B DISPLAY
To get the default host, display number, and screen.
.SH SEE ALSO
display(1), animate(1), mogrify(1), Quantize(9), X(1), MIFF(5)
.SH COPYRIGHT
SHAR_EOF
true || echo 'restore of ImageMagick/utilities/convert.man failed'
fi
echo 'End of  part 25'
echo 'File ImageMagick/utilities/convert.man is continued in part 26'
echo 26 > _shar_seq_.tmp
exit 0
exit 0 # Just in case...
