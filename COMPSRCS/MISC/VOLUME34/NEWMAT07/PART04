Newsgroups: comp.sources.misc
From: robertd@kauri.vuw.ac.nz (Robert Davies)
Subject: v34i110:  newmat07 - A matrix package in C++, Part04/08
Message-ID: <1993Jan11.153136.2384@sparky.imd.sterling.com>
X-Md4-Signature: 3ad844ba263547ee914107dc1613b003
Date: Mon, 11 Jan 1993 15:31:36 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: robertd@kauri.vuw.ac.nz (Robert Davies)
Posting-number: Volume 34, Issue 110
Archive-name: newmat07/part04
Environment: C++
Supersedes: newmat06: Volume 34, Issue 7-13

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 8)."
# Contents:  newmat1.cxx newmat2.cxx newmat3.cxx newmat4.cxx
#   newmatex.cxx
# Wrapped by robert@kea on Sun Jan 10 23:57:52 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'newmat1.cxx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newmat1.cxx'\"
else
echo shar: Extracting \"'newmat1.cxx'\" \(3276 characters\)
sed "s/^X//" >'newmat1.cxx' <<'END_OF_FILE'
X//$$ newmat1.cxx   Matrix type functions
X
X// Copyright (C) 1991,2,3: R B Davies
X
X
X#include "include.h"
X
X#include "newmat.h"
X
X
X
X/************************* MatrixType functions *****************************/
X
X
XMatrixType MatrixType::operator*(const MatrixType& mt) const
X{
X   int a = attribute & mt.attribute;
X   if ((a & (Upper+Lower)) == (Upper+Lower)) return Dg;
X   else return a & ~Symmetric;
X}
X
XMatrixType MatrixType::t() const
X{
X   int a = attribute & ~(Upper+Lower);
X   if (attribute & Upper) a |= Lower;
X   if (attribute & Lower) a |= Upper;
X   return a;
X}
X
XMatrixType MatrixType::MultRHS() const
X{
X   if ((attribute & (Upper+Lower)) == (Upper+Lower)) return Dg;
X   else return attribute & ~Symmetric;
X}
X
X
X
XMatrixType::operator char*() const
X{
X// make a string with the name of matrix with the given attributes
X   switch (attribute)
X   {
X   case Valid:                              return "Rect ";
X   case Valid+Symmetric:                    return "Sym  ";
X   case Valid+Band:                         return "Band ";
X   case Valid+Symmetric+Band:               return "SmBnd";
X   case Valid+Upper:                        return "UT   ";
X   case Valid+Upper+Lower:
X   case Valid+Band+Upper+Lower:
X   case Valid+Symmetric+Upper:
X   case Valid+Symmetric+Band+Upper:
X   case Valid+Symmetric+Lower:
X   case Valid+Symmetric+Band+Lower:
X   case Valid+Symmetric+Upper+Lower:
X   case Valid+Symmetric+Band+Upper+Lower:   return "Diag ";
X   case Valid+Band+Upper:                   return "UpBnd";
X   case Valid+Lower:                        return "LT   ";
X   case Valid+Band+Lower:                   return "LwBnd";
X   default:
X      if (!(attribute & Valid))             return "UnSp ";
X      if (attribute & LUDeco)
X         return (attribute & Band) ?     "BndLU" : "Crout";
X                                            return "?????";
X   }
X}
X
X
XGeneralMatrix* MatrixType::New(int nr, int nc, BaseMatrix* bm) const
X{
X// make a new matrix with the given attributes
X
X   Tracer tr("New"); GeneralMatrix* gm;
X   switch (attribute)
X   {
X   case Valid:
X      if (nc==1) { gm = new ColumnVector(nr); break; }
X      if (nr==1) { gm = new RowVector(nc); break; }
X      gm = new Matrix(nr, nc); break;
X
X   case Valid+Symmetric:
X      gm = new SymmetricMatrix(nr); break;
X
X   case Valid+Band:
X      {
X         MatrixBandWidth bw = bm->BandWidth();
X         gm = new BandMatrix(nr,bw.lower,bw.upper); break;
X      }
X
X   case Valid+Symmetric+Band:
X      gm = new SymmetricBandMatrix(nr,bm->BandWidth().lower); break;
X
X   case Valid+Upper:
X      gm = new UpperTriangularMatrix(nr); break;
X
X   case Valid+Upper+Lower:
X   case Valid+Band+Upper+Lower:
X   case Valid+Symmetric+Upper:
X   case Valid+Symmetric+Band+Upper:
X   case Valid+Symmetric+Lower:
X   case Valid+Symmetric+Band+Lower:
X   case Valid+Symmetric+Upper+Lower:
X   case Valid+Symmetric+Band+Upper+Lower:
X      gm = new DiagonalMatrix(nr); break;
X
X   case Valid+Band+Upper:
X      gm = new UpperBandMatrix(nr,bm->BandWidth().upper); break;
X
X   case Valid+Lower:
X      gm = new LowerTriangularMatrix(nr); break;
X
X   case Valid+Band+Lower:
X      gm = new LowerBandMatrix(nr,bm->BandWidth().lower); break;
X
X   default:
X      Throw(ProgramException("Invalid matrix type"));
X   }
X   
X   MatrixErrorNoSpace(gm); gm->Protect(); return gm;
X}
X
END_OF_FILE
if test 3276 -ne `wc -c <'newmat1.cxx'`; then
    echo shar: \"'newmat1.cxx'\" unpacked with wrong size!
fi
# end of 'newmat1.cxx'
fi
if test -f 'newmat2.cxx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newmat2.cxx'\"
else
echo shar: Extracting \"'newmat2.cxx'\" \(10973 characters\)
sed "s/^X//" >'newmat2.cxx' <<'END_OF_FILE'
X//$$ newmat2.cxx      Matrix row and column operations
X
X// Copyright (C) 1991,2,3: R B Davies
X
X#define WANT_MATH
X
X#include "include.h"
X
X#include "newmat.h"
X#include "newmatrc.h"
X
X//#define REPORT { static ExeCounter ExeCount(__LINE__,2); ExeCount++; }
X
X#define REPORT {}
X
X//#define MONITOR(what,storage,store) \
X//   { cout << what << " " << storage << " at " << (long)store << "\n"; }
X
X#define MONITOR(what,store,storage) {}
X
X/************************** Matrix Row/Col functions ************************/
X
Xvoid MatrixRowCol::Add(const MatrixRowCol& mrc)
X{
X   REPORT
X   int f = mrc.skip; int l = f + mrc.storage; int lx = skip + storage;
X   if (f < skip) f = skip; if (l > lx) l = lx; l -= f;
X   if (l<=0) return;
X   Real* elx=store+f; Real* el=mrc.store+f;
X   while (l--) *elx++ += *el++;
X}
X
Xvoid MatrixRowCol::AddScaled(const MatrixRowCol& mrc, Real x)
X{
X   REPORT
X   int f = mrc.skip; int l = f + mrc.storage; int lx = skip + storage;
X   if (f < skip) f = skip; if (l > lx) l = lx; l -= f;
X   if (l<=0) return;
X   Real* elx=store+f; Real* el=mrc.store+f;
X   while (l--) *elx++ += *el++ * x;
X}
X
Xvoid MatrixRowCol::Sub(const MatrixRowCol& mrc)
X{
X   REPORT
X   int f = mrc.skip; int l = f + mrc.storage; int lx = skip + storage;
X   if (f < skip) f = skip; if (l > lx) l = lx; l -= f;
X   if (l<=0) return;
X   Real* elx=store+f; Real* el=mrc.store+f;
X   while (l--) *elx++ -= *el++;
X}
X
Xvoid MatrixRowCol::Inject(const MatrixRowCol& mrc)
X// copy stored elements only
X{
X   REPORT
X   int f = mrc.skip; int l = f + mrc.storage; int lx = skip + storage;
X   if (f < skip) f = skip; if (l > lx) l = lx; l -= f;
X   if (l<=0) return;
X   Real* elx = store+f; Real* ely = mrc.store+f;
X   while (l--) *elx++ = *ely++;
X}
X
XReal DotProd(const MatrixRowCol& mrc1, const MatrixRowCol& mrc2)
X{
X   REPORT                                         // not accessed
X   int f = mrc1.skip; int f2 = mrc2.skip;
X   int l = f + mrc1.storage; int l2 = f2 + mrc2.storage;
X   if (f < f2) f = f2; if (l > l2) l = l2; l -= f;
X   if (l<=0) return 0.0;
X   
X   Real* el1=mrc1.store+f; Real* el2=mrc2.store+f;
X   Real sum = 0.0;
X   while (l--) sum += *el1++ * *el2++;
X   return sum;
X}
X
Xvoid MatrixRowCol::Add(const MatrixRowCol& mrc1, const MatrixRowCol& mrc2)
X{
X   int f = skip; int l = skip + storage;
X   int f1 = mrc1.skip; int l1 = f1 + mrc1.storage;
X   if (f1<f) f1=f; if (l1>l) l1=l;
X   int f2 = mrc2.skip; int l2 = f2 + mrc2.storage;
X   if (f2<f) f2=f; if (l2>l) l2=l;
X   Real* el = store + f;
X   Real* el1 = mrc1.store+f1; Real* el2 = mrc2.store+f2;
X   if (f1<f2)
X   {
X      register int i = f1-f; while (i--) *el++ = 0.0;
X      if (l1<=f2)                              // disjoint
X      {
X	 REPORT                                // not accessed
X         i = l1-f1;     while (i--) *el++ = *el1++;
X         i = f2-l1;     while (i--) *el++ = 0.0;
X         i = l2-f2;     while (i--) *el++ = *el2++;
X         i = l-l2;      while (i--) *el++ = 0.0;
X      }
X      else
X      {
X         i = f2-f1;    while (i--) *el++ = *el1++;
X         if (l1<=l2)
X         {
X            REPORT
X            i = l1-f2; while (i--) *el++ = *el1++ + *el2++;
X            i = l2-l1; while (i--) *el++ = *el2++;
X            i = l-l2;  while (i--) *el++ = 0.0;
X         }
X         else
X         {
X            REPORT
X            i = l2-f2; while (i--) *el++ = *el1++ + *el2++;
X            i = l1-l2; while (i--) *el++ = *el1++;
X            i = l-l1;  while (i--) *el++ = 0.0;
X         }
X      }
X   }
X   else
X   {
X      register int i = f2-f; while (i--) *el++ = 0.0;
X      if (l2<=f1)                              // disjoint
X      {
X	 REPORT                                // not accessed
X         i = l2-f2;     while (i--) *el++ = *el2++;
X         i = f1-l2;     while (i--) *el++ = 0.0;
X	 i = l1-f1;     while (i--) *el++ = *el1++;
X	 i = l-l1;      while (i--) *el++ = 0.0;
X      }
X      else
X      {
X         i = f1-f2;    while (i--) *el++ = *el2++;
X         if (l2<=l1)
X         {
X	    REPORT
X            i = l2-f1; while (i--) *el++ = *el1++ + *el2++;
X            i = l1-l2; while (i--) *el++ = *el1++;
X            i = l-l1;  while (i--) *el++ = 0.0;
X         }
X         else
X         {
X	    REPORT
X            i = l1-f1; while (i--) *el++ = *el1++ + *el2++;
X            i = l2-l1; while (i--) *el++ = *el2++;
X            i = l-l2;  while (i--) *el++ = 0.0;
X         }
X      }
X   }
X}
X
Xvoid MatrixRowCol::Sub(const MatrixRowCol& mrc1, const MatrixRowCol& mrc2)
X{
X   int f = skip; int l = skip + storage;
X   int f1 = mrc1.skip; int l1 = f1 + mrc1.storage;
X   if (f1<f) f1=f; if (l1>l) l1=l;
X   int f2 = mrc2.skip; int l2 = f2 + mrc2.storage;
X   if (f2<f) f2=f; if (l2>l) l2=l;
X   Real* el = store + f;
X   Real* el1 = mrc1.store+f1; Real* el2 = mrc2.store+f2;
X   if (f1<f2)
X   {
X      register int i = f1-f; while (i--) *el++ = 0.0;
X      if (l1<=f2)                              // disjoint
X      {
X	 REPORT                                // not accessed
X         i = l1-f1;     while (i--) *el++ = *el1++;
X         i = f2-l1;     while (i--) *el++ = 0.0;
X         i = l2-f2;     while (i--) *el++ = - *el2++;
X         i = l-l2;      while (i--) *el++ = 0.0;
X      }
X      else
X      {
X         i = f2-f1;    while (i--) *el++ = *el1++;
X         if (l1<=l2)
X         {
X	    REPORT
X            i = l1-f2; while (i--) *el++ = *el1++ - *el2++;
X            i = l2-l1; while (i--) *el++ = - *el2++;
X            i = l-l2;  while (i--) *el++ = 0.0;
X         }
X         else
X         {
X	    REPORT
X            i = l2-f2; while (i--) *el++ = *el1++ - *el2++;
X            i = l1-l2; while (i--) *el++ = *el1++;
X            i = l-l1;  while (i--) *el++ = 0.0;
X         }
X      }
X   }
X   else
X   {
X      register int i = f2-f; while (i--) *el++ = 0.0;
X      if (l2<=f1)                              // disjoint
X      {
X	 REPORT                                // not accessed
X         i = l2-f2;     while (i--) *el++ = - *el2++;
X         i = f1-l2;     while (i--) *el++ = 0.0;
X         i = l1-f1;     while (i--) *el++ = *el1++;
X         i = l-l1;      while (i--) *el++ = 0.0;
X      }
X      else
X      {
X         i = f1-f2;    while (i--) *el++ = - *el2++;
X         if (l2<=l1)
X         {
X	    REPORT
X            i = l2-f1; while (i--) *el++ = *el1++ - *el2++;
X            i = l1-l2; while (i--) *el++ = *el1++;
X            i = l-l1;  while (i--) *el++ = 0.0;
X         }
X         else
X         {
X            REPORT
X            i = l1-f1; while (i--) *el++ = *el1++ - *el2++;
X            i = l2-l1; while (i--) *el++ = - *el2++;
X            i = l-l2;  while (i--) *el++ = 0.0;
X         }
X      }
X   }
X}
X
X
Xvoid MatrixRowCol::Add(const MatrixRowCol& mrc1, Real x)
X{
X   REPORT
X   int f = mrc1.skip; int l = f + mrc1.storage; int lx = skip + storage;
X   if (f < skip) { f = skip; if (l < f) l = f; }
X   if (l > lx) { l = lx; if (f > lx) f = lx; }
X
X   Real* elx = store+skip; Real* ely = mrc1.store+f;
X
X   int l1 = f-skip;  while (l1--) *elx++ = x;
X       l1 = l-f;     while (l1--) *elx++ = *ely++ + x;
X       lx -= l;      while (lx--) *elx++ = x;
X}
X
Xvoid MatrixRowCol::RevSub(const MatrixRowCol& mrc1)
X{
X   REPORT
X   int f = mrc1.skip; int l = f + mrc1.storage; int lx = skip + storage;
X   if (f < skip) { f = skip; if (l < f) l = f; }
X   if (l > lx) { l = lx; if (f > lx) f = lx; }
X
X   Real* elx = store+skip; Real* ely = mrc1.store+f;
X
X   int l1 = f-skip;  while (l1--) { *elx = - *elx; elx++; }
X       l1 = l-f;     while (l1--) { *elx = *ely++ - *elx; elx++; }
X       lx -= l;      while (lx--) { *elx = - *elx; elx++; }
X}
X
Xvoid MatrixRowCol::Copy(const MatrixRowCol& mrc1)
X{
X   REPORT
X   int f = mrc1.skip; int l = f + mrc1.storage; int lx = skip + storage;
X   if (f < skip) { f = skip; if (l < f) l = f; }
X   if (l > lx) { l = lx; if (f > lx) f = lx; }
X
X   Real* elx = store+skip; Real* ely = mrc1.store+f;
X
X   int l1 = f-skip;  while (l1--) *elx++ = 0.0;
X       l1 = l-f;     while (l1--) *elx++ = *ely++;
X       lx -= l;      while (lx--) *elx++ = 0.0;
X}
X
Xvoid MatrixRowCol::CopyCheck(const MatrixRowCol& mrc1)
X// Throw an exception this would lead to a loss of data
X{
X   REPORT
X   int f = mrc1.skip; int l = f + mrc1.storage; int lx = skip + storage;
X   if (f < skip || l > lx) Throw(ProgramException("Illegal Conversion"));
X
X   Real* elx = store+skip; Real* ely = mrc1.store+f;
X
X   int l1 = f-skip;  while (l1--) *elx++ = 0.0;
X       l1 = l-f;     while (l1--) *elx++ = *ely++;
X       lx -= l;      while (lx--) *elx++ = 0.0;
X}
X
Xvoid MatrixRowCol::Negate(const MatrixRowCol& mrc1)
X{
X   REPORT
X   int f = mrc1.skip; int l = f + mrc1.storage; int lx = skip + storage;
X   if (f < skip) { f = skip; if (l < f) l = f; }
X   if (l > lx) { l = lx; if (f > lx) f = lx; }
X
X   Real* elx = store+skip; Real* ely = mrc1.store+f;
X
X   int l1 = f-skip;  while (l1--) *elx++ = 0.0;
X       l1 = l-f;     while (l1--) *elx++ = - *ely++;
X       lx -= l;      while (lx--) *elx++ = 0.0;
X}
X
Xvoid MatrixRowCol::Multiply(const MatrixRowCol& mrc1, Real s)
X{
X   REPORT
X   int f = mrc1.skip; int l = f + mrc1.storage; int lx = skip + storage;
X   if (f < skip) { f = skip; if (l < f) l = f; }
X   if (l > lx) { l = lx; if (f > lx) f = lx; }
X
X   Real* elx = store+skip; Real* ely = mrc1.store+f;
X
X   int l1 = f-skip;  while (l1--) *elx++ = 0.0;
X       l1 = l-f;     while (l1--) *elx++ = *ely++ * s;
X       lx -= l;      while (lx--) *elx++ = 0.0;
X}
X
Xvoid DiagonalMatrix::Solver(MatrixRowCol& mrc, const MatrixRowCol& mrc1)
X{
X   REPORT
X   int f = mrc1.skip; int f0 = mrc.skip;
X   int l = f + mrc1.storage; int lx = f0 + mrc.storage;
X   if (f < f0) { f = f0; if (l < f) l = f; }
X   if (l > lx) { l = lx; if (f > lx) f = lx; }
X
X   Real* elx = mrc.store+f0; Real* eld = store+f;
X
X   int l1 = f-f0;    while (l1--) *elx++ = 0.0;
X       l1 = l-f;     while (l1--) *elx++ /= *eld++;
X       lx -= l;      while (lx--) *elx++ = 0.0;
X   // Solver makes sure input and output point to same memory
X}
X
Xvoid MatrixRowCol::Copy(const Real*& r)
X{
X   REPORT
X   Real* elx = store+skip; const Real* ely = r+skip; r += length;
X   int l = storage; while (l--) *elx++ = *ely++;
X}
X
Xvoid MatrixRowCol::Copy(Real r)
X{
X   REPORT
X   Real* elx = store+skip; int l = storage; while (l--) *elx++ = r;
X}
X
XReal MatrixRowCol::SumAbsoluteValue()
X{
X   REPORT
X   Real sum = 0.0; Real* elx = store+skip; int l = storage;
X   while (l--) sum += fabs(*elx++);
X   return sum;
X}
X
Xvoid MatrixRowCol::SubRowCol(MatrixRowCol& mrc, int skip1, int l1) const
X{
X   mrc.length = l1;  mrc.store = store + skip1;  int d = skip - skip1;
X   mrc.skip = (d < 0) ? 0 : d;  d = skip + storage - skip1;
X   d = ((l1 < d) ? l1 : d) - mrc.skip;  mrc.storage = (d < 0) ? 0 : d;
X   mrc.cw = 0;
X}
X
XMatrixRowCol::~MatrixRowCol()
X{
X   int t1 = +(cw*IsACopy); int t2 = !(cw*StoreHere);
X   if (t1 && t2)
X   {
X      Real* f = store+skip;
X      MONITOR_REAL_DELETE("Free    (RowCol)",storage,f) 
X#ifdef Version21
X      delete [] f;
X#else
X      delete [storage] f;
X#endif
X   }
X}
X
XMatrixRow::~MatrixRow() { if (+(cw*StoreOnExit)) gm->RestoreRow(*this); }
X
XMatrixCol::~MatrixCol() { if (+(cw*StoreOnExit)) gm->RestoreCol(*this); }
X
END_OF_FILE
if test 10973 -ne `wc -c <'newmat2.cxx'`; then
    echo shar: \"'newmat2.cxx'\" unpacked with wrong size!
fi
# end of 'newmat2.cxx'
fi
if test -f 'newmat3.cxx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newmat3.cxx'\"
else
echo shar: Extracting \"'newmat3.cxx'\" \(14262 characters\)
sed "s/^X//" >'newmat3.cxx' <<'END_OF_FILE'
X//$$ newmat3.cxx        Matrix get and restore rows and columns
X
X// Copyright (C) 1991,2,3: R B Davies
X
X
X#include "include.h"
X
X#include "newmat.h"
X#include "newmatrc.h"
X
X//#define REPORT { static ExeCounter ExeCount(__LINE__,3); ExeCount++; }
X
X#define REPORT {}
X
X//#define MONITOR(what,storage,store) \
X//   { cout << what << " " << storage << " at " << (long)store << "\n"; }
X
X#define MONITOR(what,store,storage) {}
X
X
X// Control bits codes for GetRow, GetCol, RestoreRow, RestoreCol
X//
X// LoadOnEntry:
X//    Load data into MatrixRow or Col dummy array under GetRow or GetCol
X// StoreOnExit:
X//    Restore data to original matrix under RestoreRow or RestoreCol
X// IsACopy:
X//    Set by GetRow/Col: MatrixRow or Col array is a copy
X// DirectPart:
X//    Load or restore only part directly stored; must be set with StoreOnExit
X//    Still have decide  how to handle this with symmetric
X// StoreHere:
X//    used in columns only - store data at supplied storage address, adjusted
X//    for skip; used for GetCol, NextCol & RestoreCol. No need to fill out
X//    zeros.
X
X
X// These will work as a default
X// but need to override NextRow for efficiency
X
X// Assume pointer arithmetic works for pointers out of range - not strict C++.
X
X
Xvoid GeneralMatrix::NextRow(MatrixRowCol& mrc)
X{
X   REPORT
X   if (+(mrc.cw*StoreOnExit)) { REPORT this->RestoreRow(mrc); }
X   if (+(mrc.cw*IsACopy))
X   {
X      REPORT
X      Real* s = mrc.store + mrc.skip;
X      MONITOR_REAL_DELETE("Free   (NextRow)",mrc.storage,s)
X#ifdef Version21
X      delete [] s;
X#else
X      delete [mrc.storage] s;
X#endif
X   }
X   mrc.rowcol++;
X   if (mrc.rowcol<nrows) { REPORT this->GetRow(mrc); }
X   else { REPORT mrc.cw -= (StoreOnExit+IsACopy); }
X}
X
Xvoid GeneralMatrix::NextCol(MatrixRowCol& mrc)
X{
X   REPORT                                                // 423
X   if (+(mrc.cw*StoreOnExit)) { REPORT this->RestoreCol(mrc); }
X   int t1 = +(mrc.cw*IsACopy); int t2 = !(mrc.cw*StoreHere);
X   if ( t1 && t2 )
X   {
X      REPORT                                             // not accessed
X      Real* s = mrc.store + mrc.skip;
X      MONITOR_REAL_DELETE("Free   (NextCol)",mrc.storage,s) 
X#ifdef Version21
X      delete [] s;
X#else
X      delete [mrc.storage] s;
X#endif
X   }
X   mrc.rowcol++;
X   if (mrc.rowcol<ncols) { REPORT this->GetCol(mrc); }
X   else { REPORT mrc.cw -= (StoreOnExit+IsACopy); }
X}
X
X
X// routines for matrix
X
Xvoid Matrix::GetRow(MatrixRowCol& mrc)
X{
X   REPORT
X   mrc.skip=0; mrc.cw-=IsACopy; mrc.storage=ncols;
X   mrc.store=store+mrc.rowcol*ncols;
X}
X
X
Xvoid Matrix::GetCol(MatrixRowCol& mrc)
X{
X   REPORT
X   mrc.skip=0; mrc.storage=nrows; int t1 = !(mrc.cw*StoreHere);
X   if ( ncols==1 && t1 )
X      { REPORT mrc.cw-=IsACopy; mrc.store=store; }           // not accessed
X   else
X   {
X      mrc.cw+=IsACopy; Real* ColCopy;
X      if ( !(mrc.cw*StoreHere) )
X      {
X         REPORT
X         ColCopy = new Real [nrows]; MatrixErrorNoSpace(ColCopy);
X         MONITOR_REAL_NEW("Make (MatGetCol)",nrows,ColCopy)
X         mrc.store = ColCopy;
X      }
X      else { REPORT ColCopy = mrc.store; }
X      if (+(mrc.cw*LoadOnEntry))
X      {
X         REPORT
X         Real* Mstore = store+mrc.rowcol; int i=nrows;
X         while (i--) { *ColCopy++ = *Mstore; Mstore+=ncols; }
X      }
X   }
X}
X
Xvoid Matrix::RestoreCol(MatrixRowCol& mrc)
X{
X//  if (mrc.cw*StoreOnExit)
X   REPORT                                   // 429
X   if (+(mrc.cw*IsACopy))
X   {
X      REPORT                                // 426
X      Real* Mstore = store+mrc.rowcol; int i=nrows; Real* Cstore = mrc.store;
X      while (i--) { *Mstore = *Cstore++; Mstore+=ncols; }
X   }
X}
X
Xvoid Matrix::NextRow(MatrixRowCol& mrc) { REPORT mrc.IncrMat(); }  // 1808
X
Xvoid Matrix::NextCol(MatrixRowCol& mrc)
X{
X   REPORT                                        // 632
X   if (+(mrc.cw*StoreOnExit)) { REPORT RestoreCol(mrc); }
X   mrc.rowcol++;
X   if (mrc.rowcol<ncols)
X   {
X      if (+(mrc.cw*LoadOnEntry))
X      {
X	 REPORT
X         Real* ColCopy = mrc.store;
X         Real* Mstore = store+mrc.rowcol; int i=nrows;
X         while (i--) { *ColCopy++ = *Mstore; Mstore+=ncols; }
X      }
X   }
X   else { REPORT mrc.cw -= StoreOnExit; }
X}
X
X// routines for diagonal matrix
X
Xvoid DiagonalMatrix::GetRow(MatrixRowCol& mrc)
X{
X   REPORT
X   mrc.skip=mrc.rowcol; mrc.cw-=IsACopy; mrc.storage=1; mrc.store=store;
X}
X
Xvoid DiagonalMatrix::GetCol(MatrixRowCol& mrc)
X{
X   REPORT 
X   mrc.skip=mrc.rowcol; mrc.storage=1;
X   if (+(mrc.cw*StoreHere))
X      { REPORT *(mrc.store+mrc.rowcol)=*(store+mrc.rowcol); mrc.cw+=IsACopy; }
X   else { REPORT mrc.store = store; mrc.cw-=IsACopy; }     // not accessed
X}
X
Xvoid DiagonalMatrix::NextRow(MatrixRowCol& mrc) { REPORT mrc.IncrDiag(); }
X						      // 800
Xvoid DiagonalMatrix::NextCol(MatrixRowCol& mrc)
X{
X   REPORT
X   if (+(mrc.cw*StoreHere))
X   {
X      if (+(mrc.cw*StoreOnExit))
X         { REPORT *(store+mrc.rowcol)=*(mrc.store+mrc.rowcol); }
X      mrc.IncrDiag();
X      int t1 = +(mrc.cw*LoadOnEntry);
X      if (t1 && mrc.rowcol < ncols)
X         { REPORT *(mrc.store+mrc.rowcol)=*(store+mrc.rowcol); }
X   }
X   else { REPORT mrc.IncrDiag(); }                     // not accessed
X}
X
X// routines for upper triangular matrix
X
Xvoid UpperTriangularMatrix::GetRow(MatrixRowCol& mrc)
X{
X   REPORT
X   int row = mrc.rowcol; mrc.skip=row; mrc.cw-=IsACopy;
X   mrc.storage=ncols-row; mrc.store=store+(row*(2*ncols-row-1))/2;
X}
X
X
Xvoid UpperTriangularMatrix::GetCol(MatrixRowCol& mrc)
X{
X   REPORT
X   mrc.skip=0; mrc.cw+=IsACopy; int i=mrc.rowcol+1; mrc.storage=i;
X   Real* ColCopy;
X   if ( !(mrc.cw*StoreHere) )
X   {
X      REPORT                                              // not accessed
X      ColCopy = new Real [i]; MatrixErrorNoSpace(ColCopy);
X      MONITOR_REAL_NEW("Make (UT GetCol)",i,ColCopy) 
X      mrc.store = ColCopy;
X   }
X   else { REPORT ColCopy = mrc.store; }
X   if (+(mrc.cw*LoadOnEntry))
X   {
X      REPORT
X      Real* Mstore = store+mrc.rowcol; int j = ncols;
X      while (i--) { *ColCopy++ = *Mstore; Mstore += --j; }
X   }
X}
X
Xvoid UpperTriangularMatrix::RestoreCol(MatrixRowCol& mrc)
X{
X//  if (mrc.cw*StoreOnExit)
X  {
X     REPORT
X     Real* Mstore = store+mrc.rowcol; int i=mrc.rowcol+1; int j = ncols;
X     Real* Cstore = mrc.store;
X     while (i--) { *Mstore = *Cstore++; Mstore += --j; }
X  }
X}
X
Xvoid UpperTriangularMatrix::NextRow(MatrixRowCol& mrc) { REPORT mrc.IncrUT(); }
X						      // 722
X
X// routines for lower triangular matrix
X
Xvoid LowerTriangularMatrix::GetRow(MatrixRowCol& mrc)
X{
X   REPORT
X   int row=mrc.rowcol; mrc.skip=0; mrc.cw-=IsACopy; mrc.storage=row+1;
X   mrc.store=store+(row*(row+1))/2;
X}
X
Xvoid LowerTriangularMatrix::GetCol(MatrixRowCol& mrc)
X{
X   REPORT
X   int col=mrc.rowcol; mrc.skip=col; mrc.cw+=IsACopy;
X   int i=nrows-col; mrc.storage=i; Real* ColCopy;
X   if ( !(mrc.cw*StoreHere) )
X   {
X      REPORT                                            // not accessed
X      ColCopy = new Real [i]; MatrixErrorNoSpace(ColCopy);
X      MONITOR_REAL_NEW("Make (LT GetCol)",i,ColCopy) 
X      mrc.store = ColCopy-col;
X   }
X   else { REPORT ColCopy = mrc.store+col; }
X   if (+(mrc.cw*LoadOnEntry))
X   {
X      REPORT
X      Real* Mstore = store+(col*(col+3))/2;
X      while (i--) { *ColCopy++ = *Mstore; Mstore += ++col; }
X   }
X}
X
Xvoid LowerTriangularMatrix::RestoreCol(MatrixRowCol& mrc)
X{
X//  if (mrc.cw*StoreOnExit)
X   {
X      REPORT
X      int col=mrc.rowcol; Real* Cstore = mrc.store+col;
X      Real* Mstore = store+(col*(col+3))/2; int i=nrows-col;
X      while (i--) { *Mstore = *Cstore++; Mstore += ++col; }
X   }
X}
X
Xvoid LowerTriangularMatrix::NextRow(MatrixRowCol& mrc) { REPORT mrc.IncrLT(); }
X					                 //712
X// routines for symmetric matrix
X
Xvoid SymmetricMatrix::GetRow(MatrixRowCol& mrc)
X{
X   REPORT                                                //571
X   mrc.skip=0; int row=mrc.rowcol;
X   if (+(mrc.cw*DirectPart))
X   {
X      REPORT
X      mrc.cw-=IsACopy; mrc.storage=row+1; mrc.store=store+(row*(row+1))/2;
X   }
X   else
X   {
X      mrc.cw+=IsACopy; mrc.storage=ncols;
X      Real* RowCopy = new Real [ncols]; MatrixErrorNoSpace(RowCopy);
X      MONITOR_REAL_NEW("Make (SymGetRow)",ncols,RowCopy) 
X      mrc.store = RowCopy;
X      if (+(mrc.cw*LoadOnEntry))
X      {
X	 REPORT                                         // 544
X         Real* Mstore = store+(row*(row+1))/2; int i = row;
X         while (i--) *RowCopy++ = *Mstore++;
X         i = ncols-row;
X	 while (i--) { *RowCopy++ = *Mstore; Mstore += ++row; }
X      }
X   }
X}
X
X// need to check this out under StoreHere
X
Xvoid SymmetricMatrix::GetCol(MatrixRowCol& mrc)
X{
X   REPORT
X   mrc.skip=0; int col=mrc.rowcol;
X   if (+(mrc.cw*DirectPart))
X   {
X      REPORT                                         // not accessed
X      mrc.cw-=IsACopy; mrc.storage=col+1; mrc.store=store+(col*(col+1))/2;
X   }
X   else
X   {
X      mrc.cw+=IsACopy; mrc.storage=ncols; Real* ColCopy;
X      if ( !(mrc.cw*StoreHere) )
X      {
X         REPORT                                      // not accessed
X         ColCopy = new Real [ncols]; MatrixErrorNoSpace(ColCopy);
X         MONITOR_REAL_NEW("Make (SymGetCol)",ncols,ColCopy) 
X         mrc.store = ColCopy;
X      }
X      else { REPORT ColCopy = mrc.store; }
X      if (+(mrc.cw*LoadOnEntry))
X      {
X         REPORT
X         Real* Mstore = store+(col*(col+1))/2; int i = col;
X         while (i--) *ColCopy++ = *Mstore++;
X         i = ncols-col;
X	 while (i--) { *ColCopy++ = *Mstore; Mstore += ++col; }
X      }
X   }
X}
X
X//void SymmetricMatrix::RestoreRow(int row, Real* Rstore)
X//{
X////   if (cw*IsACopy && cw*StoreOnExit)
X//   {
X//      Real* Mstore = store+(row*(row+1))/2; int i = row+1;
X//      while (i--) *Mstore++ = *Rstore++;
X//   }
X//}
X
X//void SymmetricMatrix::RestoreCol(int col, Real* Cstore)
X//{
X////   if (cw*IsACopy && cw*StoreOnExit)
X//   {
X//      Real* Mstore = store+(col*(col+3))/2;
X//      int i = nrows-col; int j = col;
X//      while (i--) { *Mstore = *Cstore++; Mstore+= ++j; }
X//   }
X//}
X
X// routines for row vector
X
Xvoid RowVector::GetCol(MatrixRowCol& mrc)
X{
X   REPORT 
X   mrc.skip=0; mrc.storage=1;
X   if (mrc.cw >= StoreHere)
X   {
X      if (mrc.cw >= LoadOnEntry) { REPORT *(mrc.store) = *(store+mrc.rowcol); }
X      mrc.cw+=IsACopy;
X   }
X   else  { REPORT mrc.store = store+mrc.rowcol; mrc.cw-=IsACopy; }
X                                                         // not accessed
X}
X
Xvoid RowVector::NextCol(MatrixRowCol& mrc) 
X{
X   REPORT
X   if (+(mrc.cw*StoreHere))
X   {
X      if (+(mrc.cw*StoreOnExit)) { REPORT *(store+mrc.rowcol)=*(mrc.store); }
X							 // not accessed
X      mrc.rowcol++;
X      if (mrc.rowcol < ncols)
X      {
X	 if (+(mrc.cw*LoadOnEntry)) { REPORT *(mrc.store)=*(store+mrc.rowcol); }
X      }
X      else { REPORT mrc.cw -= StoreOnExit; }
X   }
X   else  { REPORT mrc.rowcol++; mrc.store++; }             // not accessed
X}
X
Xvoid RowVector::RestoreCol(MatrixRowCol& mrc)
X{
X   REPORT                                            // not accessed
X   if (mrc.cw>=IsACopy)  { REPORT *(store+mrc.rowcol)=*(mrc.store); }
X}
X
X
X// routines for band matrices
X
Xvoid BandMatrix::GetRow(MatrixRowCol& mrc)
X{
X   REPORT
X   mrc.cw -= IsACopy; int r = mrc.rowcol; int w = lower+1+upper;
X   int s = r-lower; mrc.store = store+(r*w-s); if (s<0) { w += s; s = 0; }
X   mrc.skip = s; s += w-ncols; if (s>0) w -= s; mrc.storage = w;
X}
X
X// make special versions of this for upper and lower band matrices
X
Xvoid BandMatrix::NextRow(MatrixRowCol& mrc)
X{
X   REPORT
X   int r = ++mrc.rowcol; mrc.store += lower+upper;
X   if (r<=lower) mrc.storage++; else mrc.skip++;
X   if (r>=ncols-upper) mrc.storage--;
X}
X
Xvoid BandMatrix::GetCol(MatrixRowCol& mrc)
X{
X   REPORT
X   mrc.cw += IsACopy; int c = mrc.rowcol; int n = lower+upper; int w = n+1;
X   int b; int s = c-upper; Real* ColCopy;
X   if (s<=0) { w += s; s = 0; b = c+lower; } else b = s*w+n;
X   mrc.skip = s; s += w-nrows; if (s>0) w -= s; mrc.storage = w;
X   if ( !(mrc.cw*StoreHere) )
X   {
X      REPORT
X      ColCopy = new Real [w]; MatrixErrorNoSpace(ColCopy);
X      MONITOR_REAL_NEW("Make (BMGetCol)",w,ColCopy)
X      mrc.store = ColCopy-mrc.skip;
X   }
X   else { REPORT ColCopy = mrc.store+mrc.skip; }
X   if (+(mrc.cw*LoadOnEntry))
X   {
X      REPORT
X      Real* Mstore = store+b;
X      while (w--) { *ColCopy++ = *Mstore; Mstore+=n; }
X   }
X}
X
Xvoid BandMatrix::RestoreCol(MatrixRowCol& mrc)
X{
X//  if (mrc.cw*StoreOnExit)
X   REPORT
X   int c = mrc.rowcol; int n = lower+upper; int s = c-upper;
X   Real* Mstore = store + ((s<=0) ? c+lower : s*n+s+n);
X   Real* Cstore = mrc.store+mrc.skip; int w = mrc.storage;
X   while (w--) { *Mstore = *Cstore++; Mstore += n; }
X}
X
X// routines for symmetric band matrix
X
Xvoid SymmetricBandMatrix::GetRow(MatrixRowCol& mrc)
X{
X   REPORT
X   int r=mrc.rowcol; int s = r-lower; int w1 = lower+1; int o = r*w1;
X   if (s<0) { w1 += s; o -= s; s = 0; }  mrc.skip = s;
X
X   if (+(mrc.cw*DirectPart))
X      { REPORT  mrc.cw -= IsACopy; mrc.store = store+o-s; mrc.storage = w1; }
X   else
X   {
X      mrc.cw += IsACopy; int w = w1+lower; s += w-ncols;
X      if (s>0) w -= s; mrc.storage = w; int w2 = w-w1;
X      Real* RowCopy = new Real [w]; MatrixErrorNoSpace(RowCopy);
X      MONITOR_REAL_NEW("Make (SmBGetRow)",w,RowCopy) 
X      mrc.store = RowCopy-mrc.skip;
X      if (+(mrc.cw*LoadOnEntry))
X      {
X	 REPORT
X         Real* Mstore = store+o;
X         while (w1--) *RowCopy++ = *Mstore++;   Mstore--;
X         while (w2--) { Mstore += lower; *RowCopy++ = *Mstore; }
X      }
X   }
X}
X
X// need to check this out under StoreHere
X
Xvoid SymmetricBandMatrix::GetCol(MatrixRowCol& mrc)
X{
X   REPORT
X   int c=mrc.rowcol; int s = c-lower; int w1 = lower+1; int o = c*w1;
X   if (s<0) { w1 += s; o -= s; s = 0; }  mrc.skip = s;
X
X   if (+(mrc.cw*DirectPart))
X      { REPORT  mrc.cw -= IsACopy; mrc.store = store+o-s; mrc.storage = w1; }
X   else
X   {
X      mrc.cw += IsACopy; int w = w1+lower; s += w-ncols;
X      if (s>0) w -= s; mrc.storage = w; int w2 = w-w1; Real* ColCopy;
X      if ( !(mrc.cw*StoreHere) )
X      {
X         ColCopy = new Real [w]; MatrixErrorNoSpace(ColCopy);
X         MONITOR_REAL_NEW("Make (SmBGetCol)",w,ColCopy) 
X         mrc.store = ColCopy-mrc.skip;
X      }
X      else { REPORT ColCopy = mrc.store+mrc.skip; }
X      if (+(mrc.cw*LoadOnEntry))
X      {
X	 REPORT
X         Real* Mstore = store+o;
X         while (w1--) *ColCopy++ = *Mstore++;   Mstore--;
X         while (w2--) { Mstore += lower; *ColCopy++ = *Mstore; }
X      }
X   }
X}
X
END_OF_FILE
if test 14262 -ne `wc -c <'newmat3.cxx'`; then
    echo shar: \"'newmat3.cxx'\" unpacked with wrong size!
fi
# end of 'newmat3.cxx'
fi
if test -f 'newmat4.cxx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newmat4.cxx'\"
else
echo shar: Extracting \"'newmat4.cxx'\" \(16990 characters\)
sed "s/^X//" >'newmat4.cxx' <<'END_OF_FILE'
X//$$ newmat4.cxx       Constructors, ReDimension, basic utilities
X
X// Copyright (C) 1991,2,3: R B Davies
X
X#include "include.h"
X
X#include "newmat.h"
X#include "newmatrc.h"
X
X//#define REPORT { static ExeCounter ExeCount(__LINE__,4); ExeCount++; }
X
X#define REPORT {}
X
X//#define REPORT1 { static ExeCounter ExeCount(__LINE__,4); ExeCount++; }
X
X// REPORT1 constructors only - doesn't work in turbo and Borland C++
X
X#define REPORT1 {}
X
X
X/*************************** general utilities *************************/
X
Xstatic int tristore(int n)                      // els in triangular matrix
X{ return (n*(n+1))/2; }
X
X
X/****************************** constructors ***************************/
X
XGeneralMatrix::GeneralMatrix()
X{ store=0; storage=0; nrows=0; ncols=0; tag=-1; }
X
XGeneralMatrix::GeneralMatrix(ArrayLengthSpecifier s)
X{
X   REPORT1
X   storage=s.Value(); tag=-1;
X   if (storage)
X   {
X      store = new Real [storage]; MatrixErrorNoSpace(store);
X      MONITOR_REAL_NEW("Make (GenMatrix)",storage,store)
X   }
X   else store = 0;
X}
X
XMatrix::Matrix(int m, int n) : GeneralMatrix(m*n)
X{ REPORT1 nrows=m; ncols=n; }
X
XSymmetricMatrix::SymmetricMatrix(ArrayLengthSpecifier n)
X   : GeneralMatrix(tristore(n.Value()))
X{ REPORT1 nrows=n.Value(); ncols=n.Value(); }
X
XUpperTriangularMatrix::UpperTriangularMatrix(ArrayLengthSpecifier n)
X   : GeneralMatrix(tristore(n.Value()))
X{ REPORT1 nrows=n.Value(); ncols=n.Value(); }
X
XLowerTriangularMatrix::LowerTriangularMatrix(ArrayLengthSpecifier n)
X   : GeneralMatrix(tristore(n.Value()))
X{ REPORT1 nrows=n.Value(); ncols=n.Value(); }
X
XDiagonalMatrix::DiagonalMatrix(ArrayLengthSpecifier m) : GeneralMatrix(m)
X{ REPORT1 nrows=m.Value(); ncols=m.Value(); }
X
XMatrix::Matrix(const BaseMatrix& M)
X{
X   REPORT1 // CheckConversion(M);
X   MatrixConversionCheck mcc;
X   GeneralMatrix* gmx=((BaseMatrix&)M).Evaluate(MatrixType::Rt);
X   GetMatrix(gmx);
X}
X
XRowVector::RowVector(const BaseMatrix& M) : Matrix(M)
X{
X   if (nrows!=1)
X   {
X      Tracer tr("RowVector");
X      Throw(VectorException(*this));
X   }
X}
X
XColumnVector::ColumnVector(const BaseMatrix& M) : Matrix(M)
X{
X   if (ncols!=1)
X   {
X      Tracer tr("ColumnVector");
X      Throw(VectorException(*this));
X   }
X}
X
XSymmetricMatrix::SymmetricMatrix(const BaseMatrix& M)
X{
X   REPORT1  // CheckConversion(M);
X   MatrixConversionCheck mcc;
X   GeneralMatrix* gmx=((BaseMatrix&)M).Evaluate(MatrixType::Sm);
X   GetMatrix(gmx);
X}
X
XUpperTriangularMatrix::UpperTriangularMatrix(const BaseMatrix& M)
X{
X   REPORT1 // CheckConversion(M);
X   MatrixConversionCheck mcc;
X   GeneralMatrix* gmx=((BaseMatrix&)M).Evaluate(MatrixType::UT);
X   GetMatrix(gmx);
X}
X
XLowerTriangularMatrix::LowerTriangularMatrix(const BaseMatrix& M)
X{
X   REPORT1 // CheckConversion(M);
X   MatrixConversionCheck mcc;
X   GeneralMatrix* gmx=((BaseMatrix&)M).Evaluate(MatrixType::LT);
X   GetMatrix(gmx);
X}
X
XDiagonalMatrix::DiagonalMatrix(const BaseMatrix& M)
X{
X   REPORT1 //CheckConversion(M);
X   MatrixConversionCheck mcc;
X   GeneralMatrix* gmx=((BaseMatrix&)M).Evaluate(MatrixType::Dg);
X   GetMatrix(gmx);
X}
X
XGeneralMatrix::~GeneralMatrix()
X{
X   if (store)
X   {
X      MONITOR_REAL_DELETE("Free (GenMatrix)",storage,store)
X#ifdef Version21
X      delete [] store;
X#else
X      delete [storage] store;
X#endif
X   }
X}
X
XCroutMatrix::CroutMatrix(const BaseMatrix& m)
X{
X   REPORT1
X   Tracer tr("CroutMatrix");
X   GeneralMatrix* gm = ((BaseMatrix&)m).Evaluate(MatrixType::Rt);
X   GetMatrix(gm);
X   if (nrows!=ncols) Throw(NotSquareException(*this));
X   d=TRUE; sing=FALSE;
X   indx=new int [nrows]; MatrixErrorNoSpace(indx);
X   MONITOR_INT_NEW("Index (CroutMat)",nrows,indx)
X   ludcmp();
X}
X
XCroutMatrix::~CroutMatrix()
X{
X   MONITOR_INT_DELETE("Index (CroutMat)",nrows,indx)
X#ifdef Version21
X   delete [] indx;
X#else
X   delete [nrows] indx;
X#endif
X}
X
X//ReturnMatrixX::ReturnMatrixX(GeneralMatrix& gmx)
X//{
X//   REPORT1
X//   gm = gmx.Image(); gm->ReleaseAndDelete();
X//}
X
X#ifndef TEMPS_DESTROYED_QUICKLY
X
XGeneralMatrix::operator ReturnMatrixX() const
X{
X   REPORT
X   GeneralMatrix* gm = Image(); gm->ReleaseAndDelete(); 
X   return ReturnMatrixX(gm);
X}
X
X#else
X
XGeneralMatrix::operator ReturnMatrixX&() const
X{
X   REPORT
X   GeneralMatrix* gm = Image(); gm->ReleaseAndDelete();
X   ReturnMatrixX* x = new ReturnMatrixX(gm);
X   MatrixErrorNoSpace(x); return *x;
X}
X
X#endif
X
X/**************************** ReDimension matrices ***************************/
X
Xvoid GeneralMatrix::ReDimension(int nr, int nc, int s)
X{
X   REPORT 
X   if (store)
X   {
X      MONITOR_REAL_DELETE("Free (ReDimensi)",storage,store)
X#ifdef Version21
X      delete [] store;
X#else
X      delete [storage] store;
X#endif
X   }
X   storage=s; nrows=nr; ncols=nc; tag=-1;
X   if (s)
X   {
X      store = new Real [storage]; MatrixErrorNoSpace(store);
X      MONITOR_REAL_NEW("Make (ReDimensi)",storage,store)
X   }
X   else store = 0;
X}
X
Xvoid Matrix::ReDimension(int nr, int nc)
X{ REPORT GeneralMatrix::ReDimension(nr,nc,nr*nc); }
X
Xvoid SymmetricMatrix::ReDimension(int nr)
X{ REPORT GeneralMatrix::ReDimension(nr,nr,tristore(nr)); }
X
Xvoid UpperTriangularMatrix::ReDimension(int nr)
X{ REPORT GeneralMatrix::ReDimension(nr,nr,tristore(nr)); }
X
Xvoid LowerTriangularMatrix::ReDimension(int nr)
X{ REPORT GeneralMatrix::ReDimension(nr,nr,tristore(nr)); }
X
Xvoid DiagonalMatrix::ReDimension(int nr)
X{ REPORT GeneralMatrix::ReDimension(nr,nr,nr); }
X
Xvoid RowVector::ReDimension(int nc)
X{ REPORT GeneralMatrix::ReDimension(1,nc,nc); }
X
Xvoid ColumnVector::ReDimension(int nr)
X{ REPORT GeneralMatrix::ReDimension(nr,1,nr); }
X
X
X/********************* manipulate types, storage **************************/
X
Xint GeneralMatrix::search(const BaseMatrix* s) const
X{ REPORT return (s==this) ? 1 : 0; }
X
Xint MultipliedMatrix::search(const BaseMatrix* s) const
X{ REPORT return bm1->search(s) + bm2->search(s); }
X
Xint ShiftedMatrix::search(const BaseMatrix* s) const
X{ REPORT return bm->search(s); }
X
Xint NegatedMatrix::search(const BaseMatrix* s) const
X{ REPORT return bm->search(s); }
X
Xint ConstMatrix::search(const BaseMatrix* s) const
X{ REPORT return (s==cgm) ? 1 : 0; }
X
Xint ReturnMatrixX::search(const BaseMatrix* s) const
X{ REPORT return (s==gm) ? 1 : 0; }
X
XMatrixType Matrix::Type() const { return MatrixType::Rt; }
XMatrixType SymmetricMatrix::Type() const { return MatrixType::Sm; }
XMatrixType UpperTriangularMatrix::Type() const { return MatrixType::UT; }
XMatrixType LowerTriangularMatrix::Type() const { return MatrixType::LT; }
XMatrixType DiagonalMatrix::Type() const { return MatrixType::Dg; }
XMatrixType RowVector::Type() const { return MatrixType::RV; }
XMatrixType ColumnVector::Type() const { return MatrixType::CV; }
XMatrixType CroutMatrix::Type() const { return MatrixType::Ct; }
XMatrixType BandMatrix::Type() const { return MatrixType::BM; }
XMatrixType UpperBandMatrix::Type() const { return MatrixType::UB; }
XMatrixType LowerBandMatrix::Type() const { return MatrixType::LB; }
XMatrixType SymmetricBandMatrix::Type() const { return MatrixType::SB; }
X
XMatrixBandWidth BaseMatrix::BandWidth() const { return -1; }
XMatrixBandWidth DiagonalMatrix::BandWidth() const { return 0; }
X
XMatrixBandWidth BandMatrix::BandWidth() const
X   { return MatrixBandWidth(lower,upper); }
X
XMatrixBandWidth AddedMatrix::BandWidth() const
X{ return gm1->BandWidth() + gm2->BandWidth(); }
X
XMatrixBandWidth MultipliedMatrix::BandWidth() const
X{ return gm1->BandWidth() * gm2->BandWidth(); }
X
XMatrixBandWidth SolvedMatrix::BandWidth() const { return -1; }
XMatrixBandWidth ScaledMatrix::BandWidth() const { return gm->BandWidth(); }
XMatrixBandWidth NegatedMatrix::BandWidth() const { return gm->BandWidth(); }
X
XMatrixBandWidth TransposedMatrix::BandWidth() const
X{ return gm->BandWidth().t(); }
X
XMatrixBandWidth InvertedMatrix::BandWidth() const { return -1; }
XMatrixBandWidth RowedMatrix::BandWidth() const { return -1; }
XMatrixBandWidth ColedMatrix::BandWidth() const { return -1; }
XMatrixBandWidth DiagedMatrix::BandWidth() const { return 0; }
XMatrixBandWidth MatedMatrix::BandWidth() const { return -1; }
XMatrixBandWidth ConstMatrix::BandWidth() const { return cgm->BandWidth(); }
XMatrixBandWidth ReturnMatrixX::BandWidth() const { return gm->BandWidth(); }
X
XMatrixBandWidth GetSubMatrix::BandWidth() const
X{
X
X   if (row_skip==col_skip && row_number==col_number) return gm->BandWidth();
X   else return MatrixBandWidth(-1);
X}
X
X/************************ the memory managment tools **********************/
X
X//  Rules regarding tDelete, reuse, GetStore
X//    All matrices processed during expression evaluation must be subject
X//    to exactly one of reuse(), tDelete(), GetStore() or BorrowStore().
X//    If reuse returns TRUE the matrix must be reused.
X//    GetMatrix(gm) always calls gm->GetStore()
X//    gm->Evaluate obeys rules
X//    bm->Evaluate obeys rules for matrices in bm structure
X
Xvoid GeneralMatrix::tDelete()
X{
X   if (tag<0)
X   {
X      if (tag<-1) { REPORT store=0; delete this; return; }  // borrowed
X      else { REPORT return; }
X   }
X   if (tag==1)
X   {
X      REPORT  MONITOR_REAL_DELETE("Free   (tDelete)",storage,store)
X#ifdef Version21
X      if (store) delete [] store;
X#else
X      if (store) delete [storage] store;
X#endif
X      store=0; tag=-1; return;
X   }
X   if (tag==0) { REPORT delete this; return; }
X   REPORT tag--; return;
X}
X
Xstatic void BlockCopy(int n, Real* from, Real* to)
X{
X   REPORT
X   int i = (n >> 3);
X   while (i--)
X   {
X      *to++ = *from++; *to++ = *from++; *to++ = *from++; *to++ = *from++;
X      *to++ = *from++; *to++ = *from++; *to++ = *from++; *to++ = *from++;
X   }
X   i = n & 7; while (i--) *to++ = *from++;
X}
X
XBoolean GeneralMatrix::reuse()
X{
X   if (tag<-1)
X   {
X      REPORT
X      Real* s = new Real [storage]; MatrixErrorNoSpace(s);
X      MONITOR_REAL_NEW("Make     (reuse)",storage,s)
X      BlockCopy(storage, store, s); store=s; tag=0; return TRUE;
X   }
X   if (tag<0) { REPORT return FALSE; }
X   if (tag<=1)  { REPORT return TRUE; }
X   REPORT tag--; return FALSE;
X}
X
XReal* GeneralMatrix::GetStore()
X{
X   if (tag<0 || tag>1)
X   {
X      Real* s;
X      if (storage)
X      {
X         s = new Real [storage]; MatrixErrorNoSpace(s);
X         MONITOR_REAL_NEW("Make  (GetStore)",storage,s)
X         BlockCopy(storage, store, s);
X      }
X      else s = 0;
X      if (tag>1) { REPORT tag--; }
X      else if (tag < -1) { REPORT store=0; delete this; } // borrowed store
X      else { REPORT }
X      return s;
X   }
X   Real* s=store; store=0;
X   if (tag==0) { REPORT delete this; }
X   else { REPORT tag=-1; }
X   return s;
X}
X
X/*
X#ifndef __ZTC__
Xvoid GeneralMatrix::GetMatrixC(const GeneralMatrix* gmx)
X{
X   REPORT tag=-1;
X   nrows=gmx->nrows; ncols=gmx->ncols; storage=gmx->storage;
X   SetParameters(gmx); 
X   store = new Real [storage]; MatrixErrorNoSpace(store);
X   MONITOR_REAL_NEW("Make (GetMatrix)",storage,store)
X   BlockCopy(storage, gmx->store, store);
X}
X#endif
X*/
X
Xvoid GeneralMatrix::GetMatrix(const GeneralMatrix* gmx)
X{
X   REPORT  tag=-1; nrows=gmx->Nrows(); ncols=gmx->Ncols();
X   storage=gmx->storage; SetParameters(gmx);
X   store=((GeneralMatrix*)gmx)->GetStore();
X}
X
XGeneralMatrix* GeneralMatrix::BorrowStore(GeneralMatrix* gmx, MatrixType mt)
X// Copy storage of *this to storage of *gmx. Then convert to type mt.
X// If mt == 0 just let *gmx point to storage of *this if tag==-1.
X{
X   if (!mt)
X   {
X      if (tag == -1) { REPORT gmx->tag = -2; gmx->store = store; }
X      else { REPORT gmx->tag = 0; gmx->store = GetStore(); }
X   }
X   else if (Compare(gmx->Type(),mt))
X   { REPORT  gmx->tag = 0; gmx->store = GetStore(); }
X   else
X   {
X      REPORT gmx->tag = -2; gmx->store = store;
X      gmx = gmx->Evaluate(mt); gmx->tag = 0; tDelete();
X   }
X
X   return gmx;
X}
X
Xvoid GeneralMatrix::Eq(const BaseMatrix& X, MatrixType mt)
X// Count number of references to this in X.
X// If zero delete storage in X;
X// otherwise tag X to show when storage can be deleted
X// evaluate X and copy to current object
X{
X   int counter=X.search(this);
X   if (counter==0)
X   {
X      REPORT
X      if (store)
X      {
X         MONITOR_REAL_DELETE("Free (operator=)",storage,store)
X#ifdef Version21
X         REPORT delete [] store; storage=0;
X#else
X         REPORT delete [storage] store; storage=0;
X#endif
X      }
X   }
X   else { REPORT Release(counter); }
X   GeneralMatrix* gmx = ((BaseMatrix&)X).Evaluate(mt);
X   if (gmx!=this) { REPORT GetMatrix(gmx); }
X   else { REPORT }
X   Protect();
X}
X
Xvoid GeneralMatrix::Inject(const GeneralMatrix& X)
X// copy stored values of X; otherwise leave els of *this unchanged
X{
X   REPORT
X   Tracer tr("Inject");
X   if (nrows != X.nrows || ncols != X.ncols)
X      Throw(IncompatibleDimensionsException());
X   MatrixRow mr((GeneralMatrix*)&X, LoadOnEntry);
X   MatrixRow mrx(this, LoadOnEntry+StoreOnExit+DirectPart);
X   int i=nrows;
X   while (i--) { mrx.Inject(mr); mrx.Next(); mr.Next(); }
X}  
X
X/*************** checking for data loss during conversion *******************/
X
X//void GeneralMatrix::CheckConversion(const BaseMatrix& M)
X//{
X//   if (!(this->Type() >= M.Type()))
X//      Throw(ProgramException("Illegal Conversion"));
X//}
X
XBoolean MatrixConversionCheck::DoCheck = FALSE;
X
Xvoid MatrixConversionCheck::DataLoss()
X   { if (DoCheck) Throw(ProgramException("Illegal Conversion")); }
X
XBoolean Compare(const MatrixType& source, MatrixType& destination)
X{
X   if (!destination) { destination=source; return TRUE; }
X   if (destination==source) return TRUE;
X   if (MatrixConversionCheck::IsOn() && !(destination>=source))
X      Throw(ProgramException("Illegal Conversion"));
X   return FALSE;
X}
X
X/*************** Make a copy of a matrix on the heap *********************/
X
XGeneralMatrix* Matrix::Image() const
X{
X   REPORT
X   GeneralMatrix* gm = new Matrix(*this); MatrixErrorNoSpace(gm);
X   return gm;
X}
X
XGeneralMatrix* SymmetricMatrix::Image() const
X{
X   REPORT
X   GeneralMatrix* gm = new SymmetricMatrix(*this); MatrixErrorNoSpace(gm);
X   return gm;
X}
X
XGeneralMatrix* UpperTriangularMatrix::Image() const
X{
X   REPORT
X   GeneralMatrix* gm = new UpperTriangularMatrix(*this);
X   MatrixErrorNoSpace(gm); return gm;
X}
X
XGeneralMatrix* LowerTriangularMatrix::Image() const
X{
X   REPORT
X   GeneralMatrix* gm = new LowerTriangularMatrix(*this);
X   MatrixErrorNoSpace(gm); return gm;
X}
X
XGeneralMatrix* DiagonalMatrix::Image() const
X{
X   REPORT
X   GeneralMatrix* gm = new DiagonalMatrix(*this); MatrixErrorNoSpace(gm);
X   return gm;
X}
X
XGeneralMatrix* RowVector::Image() const
X{
X   REPORT
X   GeneralMatrix* gm = new RowVector(*this); MatrixErrorNoSpace(gm);
X   return gm;
X}
X
XGeneralMatrix* ColumnVector::Image() const
X{
X   REPORT
X   GeneralMatrix* gm = new ColumnVector(*this); MatrixErrorNoSpace(gm);
X   return gm;
X}
X
XGeneralMatrix* BandMatrix::Image() const
X{
X   REPORT
X   GeneralMatrix* gm = new BandMatrix(*this); MatrixErrorNoSpace(gm);
X   return gm;
X}
X
XGeneralMatrix* UpperBandMatrix::Image() const
X{
X   REPORT
X   GeneralMatrix* gm = new UpperBandMatrix(*this); MatrixErrorNoSpace(gm);
X   return gm;
X}
X
XGeneralMatrix* LowerBandMatrix::Image() const
X{
X   REPORT
X   GeneralMatrix* gm = new LowerBandMatrix(*this); MatrixErrorNoSpace(gm);
X   return gm;
X}
X
XGeneralMatrix* SymmetricBandMatrix::Image() const
X{
X   REPORT
X   GeneralMatrix* gm = new SymmetricBandMatrix(*this); MatrixErrorNoSpace(gm);
X   return gm;
X}
X
XGeneralMatrix* nricMatrix::Image() const
X{
X   REPORT
X   GeneralMatrix* gm = new nricMatrix(*this); MatrixErrorNoSpace(gm);
X   return gm;
X}
X
XGeneralMatrix* GeneralMatrix::Image() const
X{
X   REPORT
X   Throw(InternalException("Cannot apply Image to this matrix type"));
X   return 0;
X}
X
X
X/************************* nricMatrix routines *****************************/
X
Xvoid nricMatrix::MakeRowPointer()
X{
X   row_pointer = new Real* [nrows]; MatrixErrorNoSpace(row_pointer);
X   Real* s = Store() - 1; int i = nrows; Real** rp = row_pointer;
X   while (i--) { *rp++ = s; s+=ncols; }
X}
X
Xvoid nricMatrix::DeleteRowPointer()
X#ifdef Version21
X{ if (nrows) delete [] row_pointer; }
X#else
X{ if (nrows) delete [nrows] row_pointer; }
X#endif
X
Xvoid GeneralMatrix::CheckStore() const
X{
X   if (!store) 
X      Throw(ProgramException("NRIC accessing matrix with unset dimensions"));
X}
X
X
X/***************************** CleanUp routines *****************************/
X
Xvoid GeneralMatrix::CleanUp()
X{
X   // set matrix dimensions to zero, delete storage
X   REPORT
X   if (store && storage)
X   {
X      MONITOR_REAL_DELETE("Free (CleanUp)    ",storage,store)
X#ifdef Version21
X         REPORT delete [] store;
X#else
X         REPORT delete [storage] store;
X#endif
X   }
X   store=0; storage=0; nrows=0; ncols=0;
X}
X
Xvoid nricMatrix::CleanUp()
X{ DeleteRowPointer(); GeneralMatrix::CleanUp(); }
X
Xvoid RowVector::CleanUp()
X{ GeneralMatrix::CleanUp(); nrows=1; }
X
Xvoid ColumnVector::CleanUp()
X{ GeneralMatrix::CleanUp(); ncols=1; }
X
Xvoid CroutMatrix::CleanUp()
X{ 
X#ifdef Version21
X   if (nrows) delete [] indx;
X#else
X   if (nrows) delete [nrows] indx;
X#endif
X   GeneralMatrix::CleanUp();
X}
X
Xvoid BandLUMatrix::CleanUp()
X{ 
X#ifdef Version21
X   if (nrows) delete [] indx;
X   if (storage2) delete [] store2;
X#else
X   if (nrows) delete [nrows] indx;
X   if (storage2) delete [storage2] store2;
X#endif
X   GeneralMatrix::CleanUp();
X}
X
X
END_OF_FILE
if test 16990 -ne `wc -c <'newmat4.cxx'`; then
    echo shar: \"'newmat4.cxx'\" unpacked with wrong size!
fi
# end of 'newmat4.cxx'
fi
if test -f 'newmatex.cxx' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newmatex.cxx'\"
else
echo shar: Extracting \"'newmatex.cxx'\" \(9162 characters\)
sed "s/^X//" >'newmatex.cxx' <<'END_OF_FILE'
X//$$ newmatex.cxx                    Exception handler
X
X// Copyright (C) 1992: R B Davies
X
X#define WANT_STREAM                  // include.h will get stream fns
X
X#include "include.h"                 // include standard files
X#include "newmat.h"
X
X
X// action = -1    print message and exit(1)
X//           0    no message if handler available
X//           1    print message and use handler
X
X
X
Xint SpaceException::action = 1;
Xint DataException::action = 1;
Xint ConvergenceException::action = 1;
Xint ProgramException::action = 1;
Xint InternalException::action = 1;
X
X
Xstatic inline iabs(int i) { return i >= 0 ? i : -i; }
X
X
XMatrixDetails::MatrixDetails(const GeneralMatrix& A)
X   : type(A.Type()), nrows(A.Nrows()), ncols(A.Ncols())
X{ MatrixBandWidth bw = A.BandWidth(); ubw = bw.upper; lbw = bw.lower; }
X
Xvoid MatrixDetails::PrintOut()
X{
X   cout << "MatrixType = " << (char*)type;
X   cout << "  # Rows = " << nrows;
X   cout << "; # Cols = " << ncols;
X   if (lbw >=0) cout << "; lower BW = " << lbw;
X   if (ubw >=0) cout << "; upper BW = " << ubw;
X   cout << "\n";
X}
X
X
X
XSpaceException::SpaceException() : Exception(iabs(action))
X{
X   if (action) cout << "Out of space on heap\n";
X   if (action < 0) exit(1);
X}
X
XMatrixException::MatrixException(int action) : Exception(iabs(action))
X{ if (action) cout << "The exception is from newmat.\n"; }
X
XMatrixException::MatrixException(int action, const GeneralMatrix& A)
X   : Exception(iabs(action))
X{
X   if (action)
X   {
X      cout << "The exception is from newmat: details of matrix follow:\n";
X      MatrixDetails(A).PrintOut();
X   }
X}
X
XMatrixException::MatrixException(int action, const GeneralMatrix& A,
X   const GeneralMatrix& B) : Exception(iabs(action))
X{
X   if (action)
X   {
X      cout << "The exception is from newmat: details of matrices follow:\n";
X      MatrixDetails(A).PrintOut();
X      MatrixDetails(B).PrintOut();
X   }
X}
X
XDataException::DataException(const GeneralMatrix& A)
X   : MatrixException(action, A) {}
X
XNPDException::NPDException(const GeneralMatrix& A)
X   : DataException(A)
X{
X   if (action) cout << "The matrix is not positive definite\n\n";
X   if (action < 0) exit(1);
X}
X
XSingularException::SingularException(const GeneralMatrix& A)
X   : DataException(A)
X{
X   if (action) cout << "The matrix is singular\n\n";
X   if (action < 0) exit(1);
X}
X
XConvergenceException::ConvergenceException(const GeneralMatrix& A)
X   : MatrixException(action,A)
X{
X   if (action) cout << "Process fails to converge\n\n";
X   if (action < 0) exit(1);
X}
X
XProgramException::ProgramException(char* c) : MatrixException(action)
X{
X   if (action) cout << c << "\n\n";
X   if (action < 0) exit(1);
X}
X
XProgramException::ProgramException(char* c, const GeneralMatrix& A)
X   : MatrixException(action,A)
X{
X   if (action) cout << c << "\n\n";
X   if (action < 0) exit(1);
X}
X
XProgramException::ProgramException(char* c, const GeneralMatrix& A,
X   const GeneralMatrix& B) : MatrixException(action,A,B)
X{
X   if (action) cout << c << "\n\n";
X   if (action < 0) exit(1);
X}
X
XProgramException::ProgramException(const GeneralMatrix& A)
X   : MatrixException(action, A) {}
X
XProgramException::ProgramException() : MatrixException(action) {}
X
XVectorException::VectorException() : ProgramException()
X{
X   if (action) cout << "Cannot convert matrix to vector\n\n";
X   if (action < 0) exit(1);
X}
X
XVectorException::VectorException(const GeneralMatrix& A)
X   : ProgramException(A)
X{
X   if (action) cout << "Cannot convert matrix to vector\n\n";
X   if (action < 0) exit(1);
X}
X
XNotSquareException::NotSquareException(const GeneralMatrix& A)
X   : ProgramException(A)
X{
X   if (action) cout << "Matrix is not square\n\n";
X   if (action < 0) exit(1);
X}
X
XSubMatrixDimensionException::SubMatrixDimensionException()
X   : ProgramException()
X{
X   if (action) cout << "Incompatible submatrix dimension\n\n";
X   if (action < 0) exit(1);
X}
X
XIncompatibleDimensionsException::IncompatibleDimensionsException()
X   : ProgramException()
X{
X   if (action) cout << "Incompatible dimensions\n\n";
X   if (action < 0) exit(1);
X}
X
XNotDefinedException::NotDefinedException(char* op, char* matrix)
X   : ProgramException()
X{
X   if (action)
X      cout << "Operation " << op << " not defined for " << matrix << "\n\n";
X   if (action < 0) exit(1);
X}
X
XCannotBuildException::CannotBuildException(char* matrix)
X   : ProgramException()
X{
X   if (action)
X      cout << "Cannot build matrix type " << matrix << "\n\n";
X   if (action < 0) exit(1);
X}
X
XIndexException::IndexException(int i, const GeneralMatrix& A)
X   : ProgramException(A)
X{
X   if (action)
X      { cout << "Index error: requested index = " << i << "\n\n"; }
X   if (action < 0) exit(1);
X}
X
XIndexException::IndexException(int i, int j, const GeneralMatrix& A)
X   : ProgramException(A)
X{
X   if (action)
X   {
X      cout << "Index error: requested indices = " << i << ", " << j << "\n\n";
X   }
X   if (action < 0) exit(1);
X}
X
X
XIndexException::IndexException(int i, const GeneralMatrix& A, Boolean)
X   : ProgramException(A)
X{
X   if (action)
X      { cout << "Element error: requested index (wrt 0) = " << i << "\n\n"; }
X   if (action < 0) exit(1);
X}
X
XIndexException::IndexException(int i, int j, const GeneralMatrix& A, Boolean)
X   : ProgramException(A)
X{
X   if (action)
X   {
X      cout << "Element error: requested indices (wrt 0) = " 
X         << i << ", " << j << "\n\n";
X   }
X   if (action < 0) exit(1);
X}
X
XInternalException::InternalException(char* c) : MatrixException(action)
X{
X   if (action) cout << c << "\n\n";
X   if (action < 0) exit(1);
X}
X
X
X
X
X/************************* ExeCounter functions *****************************/
X
X
X
Xint ExeCounter::nreports = 0;
X
XExeCounter::ExeCounter(int xl, int xf) : line(xl), fileid(xf), nexe(0) {}
X
XExeCounter::~ExeCounter()
X{
X   nreports++;
X   cout << nreports << "  " << fileid << "  " << line << "  " << nexe << "\n";
X}
X
X
X 
X/**************************** error handler *******************************/
X
Xvoid MatrixErrorNoSpace(void* v) { if (!v) Throw(SpaceException()); }
X// throw exception if v is null
X
X
X
X/************************* test type manipulation **************************/
X
X
X
X
X// These functions may cause problems for Glockenspiel 2.0c; they are used
X// only for testing so you can delete them
X
X
Xvoid TestTypeAdd()
X{
X   MatrixType list[] = { MatrixType::UT,
X                         MatrixType::LT,
X                         MatrixType::Rt,
X                         MatrixType::Sm,
X			 MatrixType::Dg,
X                         MatrixType::BM,
X                         MatrixType::UB,
X			 MatrixType::LB,
X			 MatrixType::SB };
X
X   cout << "+     ";
X   for (int i=0; i<MatrixType::nTypes(); i++) cout << (char*)list[i] << " ";
X   cout << "\n";
X   for (i=0; i<MatrixType::nTypes(); i++)
X   {
X      cout << (char*)(list[i]) << " ";
X      for (int j=0; j<MatrixType::nTypes(); j++)
X	 cout << (char*)(list[j]+list[i]) << " ";
X      cout << "\n";
X   }
X   cout << "\n";
X}
X
Xvoid TestTypeMult()
X{
X   MatrixType list[] = { MatrixType::UT,
X                         MatrixType::LT,
X                         MatrixType::Rt,
X                         MatrixType::Sm,
X                         MatrixType::Dg,
X                         MatrixType::BM,
X                         MatrixType::UB,
X                         MatrixType::LB,
X                         MatrixType::SB };
X   cout << "*     ";
X   for (int i=0; i<MatrixType::nTypes(); i++)
X      cout << (char*)list[i] << " ";
X   cout << "\n";
X   for (i=0; i<MatrixType::nTypes(); i++)
X   {
X      cout << (char*)list[i] << " ";
X      for (int j=0; j<MatrixType::nTypes(); j++)
X	 cout << (char*)(list[j]*list[i]) << " ";
X      cout << "\n";
X   }
X   cout << "\n";
X}
X
Xvoid TestTypeOrder()
X{
X   MatrixType list[] = { MatrixType::UT,
X                         MatrixType::LT,
X                         MatrixType::Rt,
X                         MatrixType::Sm,
X                         MatrixType::Dg,
X                         MatrixType::BM,
X                         MatrixType::UB,
X                         MatrixType::LB,
X                         MatrixType::SB };
X   cout << ">=    ";
X   for (int i = 0; i<MatrixType::nTypes(); i++)
X      cout << (char*)list[i] << " ";
X   cout << "\n";
X   for (i=0; i<MatrixType::nTypes(); i++)
X   {
X      cout << (char*)list[i] << " ";
X      for (int j=0; j<MatrixType::nTypes(); j++)
X	 cout << ((list[j]>=list[i]) ? "Yes   " : "No    ");
X      cout << "\n";
X   }
X   cout << "\n";
X}
X
X
X/************************* miscellanous errors ***************************/
X
X
Xvoid CroutMatrix::GetRow(MatrixRowCol&)
X   { Throw(NotDefinedException("GetRow","Crout")); }
Xvoid CroutMatrix::GetCol(MatrixRowCol&)
X   { Throw(NotDefinedException("GetCol","Crout")); }
Xvoid CroutMatrix::operator=(const BaseMatrix&)
X   { Throw(NotDefinedException("=","Crout")); }
Xvoid BandLUMatrix::GetRow(MatrixRowCol&)
X   { Throw(NotDefinedException("GetRow","BandLUMatrix")); }
Xvoid BandLUMatrix::GetCol(MatrixRowCol&)
X   { Throw(NotDefinedException("GetCol","BandLUMatrix")); }
Xvoid BandLUMatrix::operator=(const BaseMatrix&)
X   { Throw(NotDefinedException("=","BandLUMatrix")); }
X#ifdef TEMPS_DESTROYED_QUICKLY
X   ReturnMatrixX::ReturnMatrixX(const ReturnMatrixX& tm)
X     : gm(tm.gm) { Throw(ProgramException("ReturnMatrixX error")); }
X#endif
X
END_OF_FILE
if test 9162 -ne `wc -c <'newmatex.cxx'`; then
    echo shar: \"'newmatex.cxx'\" unpacked with wrong size!
fi
# end of 'newmatex.cxx'
fi
echo shar: End of archive 4 \(of 8\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
