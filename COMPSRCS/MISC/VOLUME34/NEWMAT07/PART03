Newsgroups: comp.sources.misc
From: robertd@kauri.vuw.ac.nz (Robert Davies)
Subject: v34i109:  newmat07 - A matrix package in C++, Part03/08
Message-ID: <1993Jan11.153101.2305@sparky.imd.sterling.com>
X-Md4-Signature: 808bc6c5a49855ab8bd0e2b9325ffdb1
Date: Mon, 11 Jan 1993 15:31:01 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: robertd@kauri.vuw.ac.nz (Robert Davies)
Posting-number: Volume 34, Issue 109
Archive-name: newmat07/part03
Environment: C++
Supersedes: newmat06: Volume 34, Issue 7-13

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 8)."
# Contents:  ex_ms.mak ex_z.mak newmat.h newmatc.txt
# Wrapped by robert@kea on Sun Jan 10 23:57:39 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ex_ms.mak' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ex_ms.mak'\"
else
echo shar: Extracting \"'ex_ms.mak'\" \(6300 characters\)
sed "s/^X//" >'ex_ms.mak' <<'END_OF_FILE'
XORIGIN = PWB
XORIGIN_VER = 2.0
XPROJ = EX_MS
XPROJFILE = EX_MS.MAK
XDEBUG = 0
X
XCC  = cl
XCFLAGS_G  = /W2 /BATCH
XCFLAGS_D  = /f /Zi /Od
XCFLAGS_R  = /f- /Ot /Oi /Ol /Oe /Og /Gs
XCXX  = cl
XCXXFLAGS_G  = /AL /W2 /BATCH
XCXXFLAGS_D  = /f /Od /Zi
XCXXFLAGS_R  = /f- /Ot /Gs
XMAPFILE_D  = NUL
XMAPFILE_R  = NUL
XLFLAGS_G  = /NOI /BATCH /ONERROR:NOEXE
XLFLAGS_D  = /CO /FAR /PACKC
XLFLAGS_R  = /EXE /FAR /PACKC
XLINKER	= link
XILINK  = ilink
XLRF  = echo > NUL
XILFLAGS  = /a /e
X
XFILES  = BANDMAT.CXX CHOLESKY.CXX EXAMPLE.CXX EXCEPT.CXX HHOLDER.CXX\
X	NEWMAT1.CXX NEWMAT2.CXX NEWMAT3.CXX NEWMAT4.CXX NEWMAT5.CXX\
X	NEWMAT6.CXX NEWMAT7.CXX NEWMAT8.CXX NEWMATEX.CXX SUBMAT.CXX SVD.CXX\
X	NEWMATRM.CXX
XOBJS  = BANDMAT.obj CHOLESKY.obj EXAMPLE.obj EXCEPT.obj HHOLDER.obj\
X	NEWMAT1.obj NEWMAT2.obj NEWMAT3.obj NEWMAT4.obj NEWMAT5.obj\
X	NEWMAT6.obj NEWMAT7.obj NEWMAT8.obj NEWMATEX.obj SUBMAT.obj SVD.obj\
X	NEWMATRM.obj
X
Xall: $(PROJ).exe
X
X.SUFFIXES:
X.SUFFIXES:
X.SUFFIXES: .obj .cxx
X
XBANDMAT.obj : BANDMAT.CXX include.h newmat.h newmatrc.h boolean.h except.h\
X	controlw.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoBANDMAT.obj BANDMAT.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoBANDMAT.obj BANDMAT.CXX
X<<
X!ENDIF
X
XCHOLESKY.obj : CHOLESKY.CXX include.h newmat.h boolean.h except.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoCHOLESKY.obj CHOLESKY.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoCHOLESKY.obj CHOLESKY.CXX
X<<
X!ENDIF
X
XEXAMPLE.obj : EXAMPLE.CXX include.h newmatap.h newmat.h boolean.h except.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoEXAMPLE.obj EXAMPLE.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoEXAMPLE.obj EXAMPLE.CXX
X<<
X!ENDIF
X
XEXCEPT.obj : EXCEPT.CXX include.h boolean.h except.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoEXCEPT.obj EXCEPT.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoEXCEPT.obj EXCEPT.CXX
X<<
X!ENDIF
X
XHHOLDER.obj : HHOLDER.CXX include.h newmatap.h newmat.h boolean.h except.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoHHOLDER.obj HHOLDER.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoHHOLDER.obj HHOLDER.CXX
X<<
X!ENDIF
X
XNEWMAT1.obj : NEWMAT1.CXX include.h newmat.h boolean.h except.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoNEWMAT1.obj NEWMAT1.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoNEWMAT1.obj NEWMAT1.CXX
X<<
X!ENDIF
X
XNEWMAT2.obj : NEWMAT2.CXX include.h newmat.h newmatrc.h boolean.h except.h\
X	controlw.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoNEWMAT2.obj NEWMAT2.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoNEWMAT2.obj NEWMAT2.CXX
X<<
X!ENDIF
X
XNEWMAT3.obj : NEWMAT3.CXX include.h newmat.h newmatrc.h boolean.h except.h\
X	controlw.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoNEWMAT3.obj NEWMAT3.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoNEWMAT3.obj NEWMAT3.CXX
X<<
X!ENDIF
X
XNEWMAT4.obj : NEWMAT4.CXX include.h newmat.h newmatrc.h boolean.h except.h\
X	controlw.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoNEWMAT4.obj NEWMAT4.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoNEWMAT4.obj NEWMAT4.CXX
X<<
X!ENDIF
X
XNEWMAT5.obj : NEWMAT5.CXX include.h newmat.h newmatrc.h boolean.h except.h\
X	controlw.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoNEWMAT5.obj NEWMAT5.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoNEWMAT5.obj NEWMAT5.CXX
X<<
X!ENDIF
X
XNEWMAT6.obj : NEWMAT6.CXX include.h newmat.h newmatrc.h boolean.h except.h\
X	controlw.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoNEWMAT6.obj NEWMAT6.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoNEWMAT6.obj NEWMAT6.CXX
X<<
X!ENDIF
X
XNEWMAT7.obj : NEWMAT7.CXX include.h newmat.h newmatrc.h boolean.h except.h\
X	controlw.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoNEWMAT7.obj NEWMAT7.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoNEWMAT7.obj NEWMAT7.CXX
X<<
X!ENDIF
X
XNEWMAT8.obj : NEWMAT8.CXX include.h newmatap.h newmat.h boolean.h except.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoNEWMAT8.obj NEWMAT8.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoNEWMAT8.obj NEWMAT8.CXX
X<<
X!ENDIF
X
XNEWMATEX.obj : NEWMATEX.CXX include.h newmat.h boolean.h except.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoNEWMATEX.obj NEWMATEX.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoNEWMATEX.obj NEWMATEX.CXX
X<<
X!ENDIF
X
XSUBMAT.obj : SUBMAT.CXX include.h newmat.h newmatrc.h boolean.h except.h\
X	controlw.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoSUBMAT.obj SUBMAT.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoSUBMAT.obj SUBMAT.CXX
X<<
X!ENDIF
X
XSVD.obj : SVD.CXX include.h newmat.h newmatrm.h precisio.h boolean.h except.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoSVD.obj SVD.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoSVD.obj SVD.CXX
X<<
X!ENDIF
X
XNEWMATRM.obj : NEWMATRM.CXX include.h newmat.h newmatrm.h boolean.h except.h
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /FoNEWMATRM.obj NEWMATRM.CXX
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /FoNEWMATRM.obj NEWMATRM.CXX
X<<
X!ENDIF
X
X
X$(PROJ).exe : $(OBJS)
X!IF $(DEBUG)
X	$(LRF) @<<$(PROJ).lrf
X$(RT_OBJS: = +^
X) $(OBJS: = +^
X)
X$@
X$(MAPFILE_D)
X$(LIBS: = +^
X) +
X$(LLIBS_G: = +^
X) +
X$(LLIBS_D: = +^
X)
X$(DEF_FILE) $(LFLAGS_G) $(LFLAGS_D);
X<<
X!ELSE
X	$(LRF) @<<$(PROJ).lrf
X$(RT_OBJS: = +^
X) $(OBJS: = +^
X)
X$@
X$(MAPFILE_R)
X$(LIBS: = +^
X) +
X$(LLIBS_G: = +^
X) +
X$(LLIBS_R: = +^
X)
X$(DEF_FILE) $(LFLAGS_G) $(LFLAGS_R);
X<<
X!ENDIF
X	$(LINKER) @$(PROJ).lrf
X
X
X.cxx.obj :
X!IF $(DEBUG)
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_D) /Fo$@ $<
X<<
X!ELSE
X	@$(CXX) @<<$(PROJ).rsp
X/c $(CXXFLAGS_G)
X$(CXXFLAGS_R) /Fo$@ $<
X<<
X!ENDIF
X
X
Xrun: $(PROJ).exe
X	$(PROJ).exe $(RUNFLAGS)
X
Xdebug: $(PROJ).exe
X	CV $(CVFLAGS) $(PROJ).exe $(RUNFLAGS)
END_OF_FILE
if test 6300 -ne `wc -c <'ex_ms.mak'`; then
    echo shar: \"'ex_ms.mak'\" unpacked with wrong size!
fi
# end of 'ex_ms.mak'
fi
if test -f 'ex_z.mak' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ex_z.mak'\"
else
echo shar: Extracting \"'ex_z.mak'\" \(2558 characters\)
sed "s/^X//" >'ex_z.mak' <<'END_OF_FILE'
XC = ztc -c -ml $*.cxx
X
XOBJ = fft.obj evalue.obj submat.obj cholesky.obj hholder.obj          \
X  sort.obj newmatrm.obj jacobi.obj svd.obj example.obj                \
X  newmat8.obj newmat7.obj newmat6.obj                                 \
X  newmat5.obj newmat3.obj newmat4.obj newmat2.obj newmat1.obj         \
X  bandmat.obj except.obj newmatex.obj
X
Xex_z.exe:       $(OBJ) ex_z.lnk
X                blink @ex_z.lnk
X
Xex_z.lnk:       ex_z.mak
X	        echo newmat1.obj+newmat2.obj+newmat3.obj+    > ex_z.lnk
X	        echo newmat4.obj+svd.obj+newmat5.obj+       >> ex_z.lnk
X	        echo newmat6.obj+newmat7.obj+newmat8.obj+   >> ex_z.lnk
X	        echo cholesky.obj+hholder.obj+sort.obj+     >> ex_z.lnk
X	        echo submat.obj+jacobi.obj+newmatrm.obj+    >> ex_z.lnk
X	        echo fft.obj+evalue.obj+bandmat.obj+        >> ex_z.lnk
X	        echo newmatex.obj+except.obj+example.obj    >> ex_z.lnk
X	        echo ex_z.exe                               >> ex_z.lnk
X
Xnewmatxx:       include.h newmat.h boolean.h except.h
X	        echo "main .h files uptodate?" > newmatxx
X
Xexcept.obj:     except.h except.cxx
X	        $C
X
Xnewmatex.obj:   newmatxx newmatex.cxx
X	        $C
X
Xexample.obj:    newmatxx newmatap.h example.cxx
X	        $C
X
Xcholesky.obj:   newmatxx cholesky.cxx
X	        $C
X
Xevalue.obj:     newmatxx newmatrm.h precisio.h evalue.cxx
X	        $C
X
Xfft.obj:        newmatxx newmatap.h fft.cxx
X	        $C
X
Xhholder.obj:    newmatxx newmatap.h hholder.cxx
X	        $C
X
Xjacobi.obj:     newmatxx precisio.h newmatrm.h jacobi.cxx
X	        $C
X
Xbandmat.obj:    newmatxx newmatrc.h controlw.h bandmat.cxx
X	        $C
X
Xnewmat1.obj:    newmatxx newmat1.cxx
X	        $C
X
Xnewmat2.obj:    newmatxx newmatrc.h controlw.h newmat2.cxx
X	        $C
X
Xnewmat3.obj:    newmatxx newmatrc.h controlw.h newmat3.cxx
X	        $C
X
Xnewmat4.obj:    newmatxx newmatrc.h controlw.h newmat4.cxx
X	        $C
X
Xnewmat5.obj:    newmatxx newmatrc.h controlw.h newmat5.cxx
X	        $C
X
Xnewmat6.obj:    newmatxx newmatrc.h controlw.h newmat6.cxx
X	        $C
X
Xnewmat7.obj:    newmatxx newmatrc.h controlw.h newmat7.cxx
X	        $C
X
Xnewmat8.obj:    newmatxx newmatap.h newmat8.cxx
X	        $C
X
Xnewmat9.obj:    newmatxx newmatrc.h controlw.h newmatio.h newmat9.cxx
X	        $C
X
Xnewmatrm.obj:   newmatxx newmatrm.h newmatrm.cxx
X	        $C
X
Xsort.obj:       newmatxx newmatap.h sort.cxx
X	        $C
X
Xsubmat.obj:     newmatxx newmatrc.h controlw.h submat.cxx
X	        $C
X
Xsvd.obj:        newmatxx newmatrm.h precisio.h svd.cxx
X	        $C
X
Xexample.obj:    newmatxx newmatap.h example.cxx 
X	        $C
X
END_OF_FILE
if test 2558 -ne `wc -c <'ex_z.mak'`; then
    echo shar: \"'ex_z.mak'\" unpacked with wrong size!
fi
# end of 'ex_z.mak'
fi
if test -f 'newmat.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newmat.h'\"
else
echo shar: Extracting \"'newmat.h'\" \(47360 characters\)
sed "s/^X//" >'newmat.h' <<'END_OF_FILE'
X//$$ newmat.h           definition file for new version of matrix package
X
X// Copyright (C) 1991,2,3: R B Davies
X
X#ifndef MATRIX_LIB
X#define MATRIX_LIB 0
X
X#ifdef NO_LONG_NAMES
X#define UpperTriangularMatrix UTMatrix
X#define LowerTriangularMatrix LTMatrix
X#define SymmetricMatrix SMatrix
X#define DiagonalMatrix DMatrix
X#endif
X
X#ifndef TEMPS_DESTROYED_QUICKLY
X#define ReturnMatrix ReturnMatrixX
X#else
X#define ReturnMatrix ReturnMatrixX&
X#endif
X
X#include "boolean.h"
X#include "except.h"
X
X/**************************** general utilities ****************************/
X
Xclass GeneralMatrix;
Xvoid MatrixErrorNoSpace(void*);                 // no space handler
X
Xclass LogAndSign
X// Return from LogDeterminant function
X//    - value of the log plus the sign (+, - or 0)
X{
X   Real log_value;
X   int sign;
Xpublic:
X   LogAndSign() { log_value=0.0; sign=1; }
X   LogAndSign(Real);
X   void operator*=(Real);
X   void ChangeSign() { sign = -sign; }
X   Real LogValue() const { return log_value; }
X   int Sign() const { return sign; }
X   Real Value() const;
X   FREE_CHECK(LogAndSign)
X};
X
X// the following class is for counting the number of times a piece of code
X// is executed. It is used for locating any code not executed by test
X// routines. Use turbo GREP locate all places this code is called and
X// check which ones are not accessed.
X// Somewhat implementation dependent as it relies on "cout" still being
X// present when ExeCounter objects are destructed.
X
Xclass ExeCounter
X{
X   int line;                                    // code line number
X   int fileid;                                  // file identifier
X   long nexe;                                   // number of executions
X   static int nreports;                         // number of reports
Xpublic:
X   ExeCounter(int,int);
X   void operator++() { nexe++; }
X   ~ExeCounter();                               // prints out reports
X};
X
X
X/************** Class to show whether to check for loss of data ************/
X
Xclass MatrixConversionCheck : public Janitor
X{
X   static Boolean DoCheck;
Xpublic:
X   MatrixConversionCheck() { DoCheck=TRUE; }          // turn check on
X   ~MatrixConversionCheck() { DoCheck=FALSE; }        // turn check off
X   void CleanUp() { DoCheck=FALSE; }
X   static Boolean IsOn() { return DoCheck; }
X   static void DataLoss();
X};
X
X/**************************** class MatrixType *****************************/
X
X// Is used for finding the type of a matrix resulting from the binary operations
X// +, -, * and identifying what conversions are permissible.
X// This class must be updated when new matrix types are added.
X
Xclass GeneralMatrix;                            // defined later
Xclass BaseMatrix;                               // defined later
Xclass MatrixInput;                              // defined later
X
Xclass MatrixType
X{
Xpublic:
X   enum Attribute {  Valid     = 1,
X                     Symmetric = 2,
X                     Band      = 4,
X                     Upper     = 8,
X                     Lower     = 16,
X                     LUDeco    = 32 };
X
X   enum            { US = 0,
X                     UT = Valid + Upper,
X                     LT = Valid + Lower,
X                     Rt = Valid,
X                     Sm = Valid + Symmetric,
X                     Dg = Valid + Band + Lower + Upper + Symmetric,
X		     RV = Valid,     //   don't separate out
X		     CV = Valid,     //   vectors
X		     BM = Valid + Band,
X		     UB = Valid + Band + Upper,
X		     LB = Valid + Band + Lower,
X		     SB = Valid + Band + Symmetric,
X		     Ct = Valid + LUDeco,
X		     BC = Valid + Band + LUDeco,
X                   };
X
X
X   static nTypes() { return 9; }               // number of different types
X					       // exclude Ct, US, BC
Xpublic:
X   int attribute;
Xpublic:
X   MatrixType () {}
X   MatrixType (int i) : attribute(i) {}
X   int operator+() const { return attribute; }
X   MatrixType operator+(MatrixType mt) const
X      { return MatrixType(attribute & mt.attribute); }
X   MatrixType operator*(const MatrixType&) const;
X   Boolean operator>=(MatrixType mt) const
X      { return ( attribute & mt.attribute ) == attribute; }
X   Boolean operator==(MatrixType t) const
X      { return (attribute == t.attribute); }
X   Boolean operator!=(MatrixType t) const
X      { return (attribute != t.attribute); }
X   Boolean operator!() const { return (attribute & Valid) == 0; }
X   MatrixType i() const                        // type of inverse
X      { return MatrixType(attribute & ~(Band+LUDeco)); }
X   MatrixType t() const;                       // type of transpose
X   MatrixType AddEqualEl() const               // Add constant to matrix
X      { return MatrixType(attribute & (Valid + Symmetric)); }
X   MatrixType MultRHS() const;                 // type for rhs of multiply
X   MatrixType sub() const                      // type of submatrix
X      { return MatrixType(attribute & Valid); }
X   MatrixType ssub() const                     // type of sym submatrix
X      { return MatrixType(attribute); }        // not for selection matrix
X   GeneralMatrix* New() const;                 // new matrix of given type
X   GeneralMatrix* New(int,int,BaseMatrix*) const;
X                                               // new matrix of given type
X   operator char*() const;                     // to print type
X   friend Boolean Rectangular(MatrixType a, MatrixType b, MatrixType c)
X      { return ((a.attribute | b.attribute | c.attribute)
X          & ~MatrixType::Valid) == 0; }
X   friend Boolean Compare(const MatrixType&, MatrixType&);
X                                               // compare and check conv.
X   FREE_CHECK(MatrixType)
X};
X
Xvoid TestTypeAdd();                            // test +
Xvoid TestTypeMult();                           // test *
Xvoid TestTypeOrder();                          // test >=
X
X
X/************************* class MatrixBandWidth ***********************/
X
Xclass MatrixBandWidth
X{
Xpublic:
X   int lower;
X   int upper;
X   MatrixBandWidth(const int l, const int u) : lower(l), upper (u) {}
X   MatrixBandWidth(const int i) : lower(i), upper(i) {}
X   MatrixBandWidth operator+(const MatrixBandWidth&) const;
X   MatrixBandWidth operator*(const MatrixBandWidth&) const;
X   MatrixBandWidth t() const { return MatrixBandWidth(upper,lower); }
X   Boolean operator==(const MatrixBandWidth& bw) const
X      { return (lower == bw.lower) && (upper == bw.upper); }
X   FREE_CHECK(MatrixBandWidth)
X};
X
X
X/*********************** Array length specifier ************************/
X
X// This class is introduced to avoid constructors such as
X//   ColumnVector(int)
X// being used for conversions
X
Xclass ArrayLengthSpecifier
X{
X   int value;
Xpublic:
X   int Value() const { return value; }
X   ArrayLengthSpecifier(int l) : value(l) {}
X   FREE_CHECK(ArrayLengthSpecifier)
X};
X
X/*************************** Matrix routines ***************************/
X
X
Xclass MatrixRowCol;                             // defined later
Xclass MatrixRow;
Xclass MatrixCol;
X
Xclass GeneralMatrix;                            // defined later
Xclass AddedMatrix;
Xclass MultipliedMatrix;
Xclass SubtractedMatrix;
Xclass SolvedMatrix;
Xclass ShiftedMatrix;
Xclass ScaledMatrix;
Xclass TransposedMatrix;
Xclass NegatedMatrix;
Xclass InvertedMatrix;
Xclass RowedMatrix;
Xclass ColedMatrix;
Xclass DiagedMatrix;
Xclass MatedMatrix;
Xclass GetSubMatrix;
Xclass ConstMatrix;
Xclass ReturnMatrixX;
Xclass Matrix;
Xclass nricMatrix;
Xclass RowVector;
Xclass ColumnVector;
Xclass SymmetricMatrix;
Xclass UpperTriangularMatrix;
Xclass LowerTriangularMatrix;
Xclass DiagonalMatrix;
Xclass CroutMatrix;
Xclass BandMatrix;
Xclass LowerBandMatrix;
Xclass UpperBandMatrix;
Xclass SymmetricBandMatrix;
Xclass LinearEquationSolver;
X
X
X
Xstatic MatrixType MatrixTypeUnSp(MatrixType::US);
X						// AT&T needs this
X
Xclass BaseMatrix : public Janitor               // base of all matrix classes
X{
Xprotected:
X   virtual int search(const BaseMatrix*) const = 0;
X						// count number of times matrix
X						// is referred to
Xpublic:
X#ifndef __GNUG__
X   virtual GeneralMatrix* Evaluate(MatrixType mt=MatrixTypeUnSp) = 0;
X						// evaluate temporary
X#else
X   virtual GeneralMatrix* Evaluate(MatrixType mt) = 0;
X   GeneralMatrix* Evaluate() { return Evaluate(MatrixTypeUnSp); }
X#endif
X#ifndef TEMPS_DESTROYED_QUICKLY
X   AddedMatrix operator+(const BaseMatrix&) const;    // results of operations
X   MultipliedMatrix operator*(const BaseMatrix&) const;
X   SubtractedMatrix operator-(const BaseMatrix&) const;
X   ShiftedMatrix operator+(Real) const;
X   ScaledMatrix operator*(Real) const;
X   ScaledMatrix operator/(Real) const;
X   ShiftedMatrix operator-(Real) const;
X   TransposedMatrix t() const;
X//   TransposedMatrix t;
X   NegatedMatrix operator-() const;                   // change sign of elements
X   InvertedMatrix i() const;
X//   InvertedMatrix i;
X   RowedMatrix AsRow() const;
X   ColedMatrix AsColumn() const;
X   DiagedMatrix AsDiagonal() const;
X   MatedMatrix AsMatrix(int,int) const;
X   GetSubMatrix SubMatrix(int,int,int,int) const;
X   GetSubMatrix SymSubMatrix(int,int) const;
X   GetSubMatrix Row(int) const;
X   GetSubMatrix Rows(int,int) const;
X   GetSubMatrix Column(int) const;
X   GetSubMatrix Columns(int,int) const;
X#else
X   AddedMatrix& operator+(const BaseMatrix&) const;    // results of operations
X   MultipliedMatrix& operator*(const BaseMatrix&) const;
X   SubtractedMatrix& operator-(const BaseMatrix&) const;
X   ShiftedMatrix& operator+(Real) const;
X   ScaledMatrix& operator*(Real) const;
X   ScaledMatrix& operator/(Real) const;
X   ShiftedMatrix& operator-(Real) const;
X   TransposedMatrix& t() const;
X//   TransposedMatrix& t;
X   NegatedMatrix& operator-() const;                   // change sign of elements
X   InvertedMatrix& i() const;
X//   InvertedMatrix& i;
X   RowedMatrix& AsRow() const;
X   ColedMatrix& AsColumn() const;
X   DiagedMatrix& AsDiagonal() const;
X   MatedMatrix& AsMatrix(int,int) const;
X   GetSubMatrix& SubMatrix(int,int,int,int) const;
X   GetSubMatrix& SymSubMatrix(int,int) const;
X   GetSubMatrix& Row(int) const;
X   GetSubMatrix& Rows(int,int) const;
X   GetSubMatrix& Column(int) const;
X   GetSubMatrix& Columns(int,int) const;
X#endif
X   Real AsScalar() const;                      // conversion of 1 x 1 matrix
X   virtual LogAndSign LogDeterminant() const;
X   virtual Real SumSquare() const;
X   virtual Real SumAbsoluteValue() const;
X   virtual Real MaximumAbsoluteValue() const;
X   virtual Real Trace() const;
X   Real Norm1() const;
X   Real NormInfinity() const;
X   virtual MatrixBandWidth BandWidth() const;  // bandwidths of band matrix
X   virtual void CleanUp() {}                     // to clear store
X//protected:
X//   BaseMatrix() : t(this), i(this) {}
X
X   friend class GeneralMatrix;
X   friend class Matrix;
X   friend class nricMatrix;
X   friend class RowVector;
X   friend class ColumnVector;
X   friend class SymmetricMatrix;
X   friend class UpperTriangularMatrix;
X   friend class LowerTriangularMatrix;
X   friend class DiagonalMatrix;
X   friend class CroutMatrix;
X   friend class BandMatrix;
X   friend class LowerBandMatrix;
X   friend class UpperBandMatrix;
X   friend class SymmetricBandMatrix;
X   friend class AddedMatrix;
X   friend class MultipliedMatrix;
X   friend class SubtractedMatrix;
X   friend class SolvedMatrix;
X   friend class ShiftedMatrix;
X   friend class ScaledMatrix;
X   friend class TransposedMatrix;
X   friend class NegatedMatrix;
X   friend class InvertedMatrix;
X   friend class RowedMatrix;
X   friend class ColedMatrix;
X   friend class DiagedMatrix;
X   friend class MatedMatrix;
X   friend class GetSubMatrix;
X   friend class ConstMatrix;
X   friend class ReturnMatrixX;
X   friend class LinearEquationSolver;
X   NEW_DELETE(BaseMatrix)
X};
X
X
X/******************************* working classes **************************/
X
Xclass GeneralMatrix : public BaseMatrix         // declarable matrix types
X{
X   virtual GeneralMatrix* Image() const;        // copy of matrix
Xprotected:
X   int tag;                                     // shows whether can reuse
X   int nrows, ncols;                            // dimensions
X   int storage;                                 // total store required
X   Real* store;                                 // point to store (0=not set)
X   GeneralMatrix();                             // initialise with no store
X   GeneralMatrix(ArrayLengthSpecifier);         // constructor getting store
X   void Add(GeneralMatrix*, Real);              // sum of GM and Real
X   void Add(Real);                              // add Real to this
X   void Multiply(GeneralMatrix*, Real);         // product of GM and Real
X   void Multiply(Real);                         // multiply this by Real
X   void Negate(GeneralMatrix*);                 // change sign
X   void Negate();                               // change sign
X   void operator=(Real);                        // set matrix to constant
X   Real* GetStore();                            // get store or copy
X   GeneralMatrix* BorrowStore(GeneralMatrix*, MatrixType);
X                                                // temporarily access store
X   void GetMatrix(const GeneralMatrix*);        // used by = and initialise
X   void Eq(const BaseMatrix&, MatrixType);      // used by =
X   int search(const BaseMatrix*) const;
X   virtual GeneralMatrix* Transpose(TransposedMatrix*, MatrixType);
X   void CheckConversion(const BaseMatrix&);     // check conversion OK
X   void ReDimension(int, int, int);             // change dimensions
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   virtual MatrixType Type() const = 0;       // type of a matrix
X   int Nrows() const { return nrows; }          // get dimensions
X   int Ncols() const { return ncols; }
X   int Storage() const { return storage; }
X   Real* Store() const { return store; }
X   virtual ~GeneralMatrix();                    // delete store if set
X   void tDelete();                              // delete if tag permits
X   Boolean reuse();                                // TRUE if tag allows reuse
X   void Protect() { tag=-1; }                   // can't delete or reuse
X   int Tag() const { return tag; }
X   Boolean IsZero() const;                         // test matrix has all zeros
X   void Release() { tag=1; }                    // del store after next use
X   void Release(int t) { tag=t; }               // del store after t accesses
X   void ReleaseAndDelete() { tag=0; }           // delete matrix after use
X   void operator<<(const Real*);                // assignment from an array
X   void operator<<(const BaseMatrix& X) { Eq(X,this->Type()); }
X                                                // = without checking type
X   void Inject(const GeneralMatrix&);           // copy stored els only
X   virtual GeneralMatrix* MakeSolver();         // for solving
X   virtual void Solver(MatrixRowCol&, const MatrixRowCol&) {}
X   virtual void GetRow(MatrixRowCol&) = 0;      // Get matrix row
X   virtual void RestoreRow(MatrixRowCol&) {}    // Restore matrix row
X   virtual void NextRow(MatrixRowCol&);         // Go to next row
X   virtual void GetCol(MatrixRowCol&) = 0;      // Get matrix col
X   virtual void RestoreCol(MatrixRowCol&) {}    // Restore matrix col
X   virtual void NextCol(MatrixRowCol&);         // Go to next col
X   Real SumSquare() const;
X   Real SumAbsoluteValue() const;
X   Real MaximumAbsoluteValue() const;
X   LogAndSign LogDeterminant() const;
X#ifndef TEMPS_DESTROYED_QUICKLY
X   ConstMatrix c() const;                       // to access constant matrices
X#else
X   ConstMatrix& c() const;                      // to access constant matrices
X#endif
X   void CheckStore() const;                     // check store is non-zero
X   virtual void SetParameters(const GeneralMatrix*) {}
X                                                // set parameters in GetMatrix
X#ifndef TEMPS_DESTROYED_QUICKLY
X   operator ReturnMatrixX() const;              // for building a ReturnMatrix
X#else
X   operator ReturnMatrixX&() const;             // for building a ReturnMatrix
X#endif
X   MatrixInput operator<<(Real);                // for loading a list
X   void CleanUp();                              // to clear store
X
X   friend class Matrix;
X   friend class nricMatrix;
X   friend class SymmetricMatrix;
X   friend class UpperTriangularMatrix;
X   friend class LowerTriangularMatrix;
X   friend class DiagonalMatrix;
X   friend class CroutMatrix;
X   friend class RowVector;
X   friend class ColumnVector;
X   friend class BandMatrix;
X   friend class LowerBandMatrix;
X   friend class UpperBandMatrix;
X   friend class SymmetricBandMatrix;
X   friend class BaseMatrix;
X   friend class AddedMatrix;
X   friend class MultipliedMatrix;
X   friend class SubtractedMatrix;
X   friend class SolvedMatrix;
X   friend class ShiftedMatrix;
X   friend class ScaledMatrix;
X   friend class TransposedMatrix;
X   friend class NegatedMatrix;
X   friend class InvertedMatrix;
X   friend class RowedMatrix;
X   friend class ColedMatrix;
X   friend class DiagedMatrix;
X   friend class MatedMatrix;
X   friend class GetSubMatrix;
X   friend class ConstMatrix;
X   friend class ReturnMatrixX;
X   friend class LinearEquationSolver;
X   NEW_DELETE(GeneralMatrix)
X};
X
Xclass Matrix : public GeneralMatrix             // usual rectangular matrix
X{
X   GeneralMatrix* Image() const;                // copy of matrix
Xpublic:
X   Matrix() {}
X   Matrix(int, int);                            // standard declaration
X   Matrix(const BaseMatrix&);                   // evaluate BaseMatrix
X   void operator=(const BaseMatrix&);
X   void operator=(Real f) { GeneralMatrix::operator=(f); }
X   void operator=(const Matrix& m) { operator=((const BaseMatrix&)m); }
X   MatrixType Type() const;
X   Real& operator()(int, int);                  // access element
X   Real& element(int, int);                     // access element
X#ifdef SETUP_C_SUBSCRIPTS
X   Real* operator[](int m) { return store+m*ncols; }
X   const Real* operator[](int m) const { return store+m*ncols; }
X#endif
X   Matrix(const Matrix& gm) { GetMatrix(&gm); }
X#ifndef __ZTC__
X   Real operator()(int, int) const;             // access element
X#endif
X   GeneralMatrix* MakeSolver();
X   Real Trace() const;
X   void GetRow(MatrixRowCol&);
X   void GetCol(MatrixRowCol&);
X   void RestoreCol(MatrixRowCol&);
X   void NextRow(MatrixRowCol&);
X   void NextCol(MatrixRowCol&);
X   void ReDimension(int,int);                   // change dimensions
X   NEW_DELETE(Matrix)
X};
X
Xclass nricMatrix : public Matrix                // for use with Numerical
X                                                // Recipes in C
X{
X   GeneralMatrix* Image() const;                // copy of matrix
X   Real** row_pointer;                          // points to rows
X   void MakeRowPointer();                       // build rowpointer
X   void DeleteRowPointer();
Xpublic:
X   nricMatrix() {}
X   nricMatrix(int m, int n)                     // standard declaration
X      :  Matrix(m,n) { MakeRowPointer(); }
X   nricMatrix(const BaseMatrix& bm)             // evaluate BaseMatrix
X      :  Matrix(bm) { MakeRowPointer(); }
X   void operator=(const BaseMatrix& bm)
X      { DeleteRowPointer(); Matrix::operator=(bm); MakeRowPointer(); }
X   void operator=(Real f) { GeneralMatrix::operator=(f); }
X   void operator=(const nricMatrix& m) { operator=((const BaseMatrix&)m); }
X   void operator<<(const BaseMatrix& X)
X      { DeleteRowPointer(); Eq(X,this->Type()); MakeRowPointer(); }
X   nricMatrix(const nricMatrix& gm) { GetMatrix(&gm); MakeRowPointer(); }
X   void ReDimension(int m, int n)               // change dimensions
X      { DeleteRowPointer(); Matrix::ReDimension(m,n); MakeRowPointer(); }
X   ~nricMatrix() { DeleteRowPointer(); }
X#ifndef __ZTC__
X   Real** nric() const { CheckStore(); return row_pointer-1; }
X#endif
X   void CleanUp();                                // to clear store
X   NEW_DELETE(nricMatrix)
X};
X
Xclass SymmetricMatrix : public GeneralMatrix
X{
X   GeneralMatrix* Image() const;                // copy of matrix
Xpublic:
X   SymmetricMatrix() {}
X   SymmetricMatrix(ArrayLengthSpecifier);
X   SymmetricMatrix(const BaseMatrix&);
X   void operator=(const BaseMatrix&);
X   void operator=(Real f) { GeneralMatrix::operator=(f); }
X   void operator=(const SymmetricMatrix& m) { operator=((const BaseMatrix&)m); }
X   Real& operator()(int, int);                  // access element
X   Real& element(int, int);                     // access element
X#ifdef SETUP_C_SUBSCRIPTS
X   Real* operator[](int m) { return store+(m*(m+1))/2; }
X   const Real* operator[](int m) const { return store+(m*(m+1))/2; }
X#endif
X   MatrixType Type() const;
X   SymmetricMatrix(const SymmetricMatrix& gm) { GetMatrix(&gm); }
X#ifndef __ZTC__
X   Real operator()(int, int) const;             // access element
X#endif
X   Real SumSquare() const;
X   Real SumAbsoluteValue() const;
X   Real Trace() const;
X   void GetRow(MatrixRowCol&);
X   void GetCol(MatrixRowCol&);
X   GeneralMatrix* Transpose(TransposedMatrix*, MatrixType);
X   void ReDimension(int);                       // change dimensions
X   NEW_DELETE(SymmetricMatrix)
X};
X
Xclass UpperTriangularMatrix : public GeneralMatrix
X{
X   GeneralMatrix* Image() const;                // copy of matrix
Xpublic:
X   UpperTriangularMatrix() {}
X   UpperTriangularMatrix(ArrayLengthSpecifier);
X   void operator=(const BaseMatrix&);
X   void operator=(const UpperTriangularMatrix& m)
X      { operator=((const BaseMatrix&)m); }
X   UpperTriangularMatrix(const BaseMatrix&);
X   UpperTriangularMatrix(const UpperTriangularMatrix& gm) { GetMatrix(&gm); }
X#ifndef __ZTC__
X   Real operator()(int, int) const;             // access element
X#endif
X   void operator=(Real f) { GeneralMatrix::operator=(f); }
X   Real& operator()(int, int);                  // access element
X   Real& element(int, int);                     // access element
X#ifdef SETUP_C_SUBSCRIPTS
X   Real* operator[](int m) { return store+m*ncols-(m*(m+1))/2; }
X   const Real* operator[](int m) const { return store+m*ncols-(m*(m+1))/2; }
X#endif
X   MatrixType Type() const;
X   GeneralMatrix* MakeSolver() { return this; } // for solving
X   void Solver(MatrixRowCol&, const MatrixRowCol&);
X   LogAndSign LogDeterminant() const;
X   Real Trace() const;
X   void GetRow(MatrixRowCol&);
X   void GetCol(MatrixRowCol&);
X   void RestoreCol(MatrixRowCol&);
X   void NextRow(MatrixRowCol&);
X   void ReDimension(int);                       // change dimensions
X   NEW_DELETE(UpperTriangularMatrix)
X};
X
Xclass LowerTriangularMatrix : public GeneralMatrix
X{
X   GeneralMatrix* Image() const;                // copy of matrix
Xpublic:
X   LowerTriangularMatrix() {}
X   LowerTriangularMatrix(ArrayLengthSpecifier);
X   LowerTriangularMatrix(const LowerTriangularMatrix& gm) { GetMatrix(&gm); }
X#ifndef __ZTC__
X   Real operator()(int, int) const;             // access element
X#endif
X   LowerTriangularMatrix(const BaseMatrix& M);
X   void operator=(const BaseMatrix&);
X   void operator=(Real f) { GeneralMatrix::operator=(f); }
X   void operator=(const LowerTriangularMatrix& m)
X      { operator=((const BaseMatrix&)m); }
X   Real& operator()(int, int);                  // access element
X   Real& element(int, int);                     // access element
X#ifdef SETUP_C_SUBSCRIPTS
X   Real* operator[](int m) { return store+(m*(m+1))/2; }
X   const Real* operator[](int m) const { return store+(m*(m+1))/2; }
X#endif
X   MatrixType Type() const;
X   GeneralMatrix* MakeSolver() { return this; } // for solving
X   void Solver(MatrixRowCol&, const MatrixRowCol&);
X   LogAndSign LogDeterminant() const;
X   Real Trace() const;
X   void GetRow(MatrixRowCol&);
X   void GetCol(MatrixRowCol&);
X   void RestoreCol(MatrixRowCol&);
X   void NextRow(MatrixRowCol&);
X   void ReDimension(int);                       // change dimensions
X   NEW_DELETE(LowerTriangularMatrix)
X};
X
Xclass DiagonalMatrix : public GeneralMatrix
X{
X   GeneralMatrix* Image() const;                // copy of matrix
Xpublic:
X   DiagonalMatrix() {}
X   DiagonalMatrix(ArrayLengthSpecifier);
X   DiagonalMatrix(const BaseMatrix&);
X   DiagonalMatrix(const DiagonalMatrix& gm) { GetMatrix(&gm); }
X#ifndef __ZTC__
X   Real operator()(int, int) const;             // access element
X   Real operator()(int) const;
X#endif
X   void operator=(const BaseMatrix&);
X   void operator=(Real f) { GeneralMatrix::operator=(f); }
X   void operator=(const DiagonalMatrix& m) { operator=((const BaseMatrix&)m); }
X   Real& operator()(int, int);                  // access element
X   Real& operator()(int);                       // access element
X   Real& element(int, int);                     // access element
X   Real& element(int);                          // access element
X#ifdef SETUP_C_SUBSCRIPTS
X   Real& operator[](int m) { return store[m]; }
X   const Real& operator[](int m) const { return store[m]; }
X#endif
X   MatrixType Type() const;
X
X   LogAndSign LogDeterminant() const;
X   Real Trace() const;
X   void GetRow(MatrixRowCol&);
X   void GetCol(MatrixRowCol&);
X   void NextRow(MatrixRowCol&);
X   void NextCol(MatrixRowCol&);
X   GeneralMatrix* MakeSolver() { return this; } // for solving
X   void Solver(MatrixRowCol&, const MatrixRowCol&);
X   GeneralMatrix* Transpose(TransposedMatrix*, MatrixType);
X   void ReDimension(int);                       // change dimensions
X#ifndef __ZTC__
X   Real* nric() const
X      { CheckStore(); return store-1; }         // for use by NRIC
X#endif
X   MatrixBandWidth BandWidth() const;
X   NEW_DELETE(DiagonalMatrix)
X};
X
Xclass RowVector : public Matrix
X{
X   GeneralMatrix* Image() const;                // copy of matrix
Xpublic:
X   RowVector() {}
X   RowVector(ArrayLengthSpecifier n) : Matrix(1,n.Value()) {}
X   RowVector(const BaseMatrix&);
X   RowVector(const RowVector& gm) { GetMatrix(&gm); }
X#ifndef __ZTC__
X   Real operator()(int) const;                  // access element
X#endif
X   void operator=(const BaseMatrix&);
X   void operator=(Real f) { GeneralMatrix::operator=(f); }
X   void operator=(const RowVector& m) { operator=((const BaseMatrix&)m); }
X   Real& operator()(int);                       // access element
X   Real& element(int);                          // access element
X#ifdef SETUP_C_SUBSCRIPTS
X   Real& operator[](int m) { return store[m]; }
X   const Real& operator[](int m) const { return store[m]; }
X#endif
X   MatrixType Type() const;
X   void GetCol(MatrixRowCol&);
X   void NextCol(MatrixRowCol&);
X   void RestoreCol(MatrixRowCol&);
X   GeneralMatrix* Transpose(TransposedMatrix*, MatrixType);
X   void ReDimension(int);                       // change dimensions
X#ifndef __ZTC__
X   Real* nric() const
X      { CheckStore(); return store-1; }         // for use by NRIC
X#endif
X   void CleanUp();                                // to clear store
X   NEW_DELETE(RowVector)
X};
X
Xclass ColumnVector : public Matrix
X{
X   GeneralMatrix* Image() const;                // copy of matrix
Xpublic:
X   ColumnVector() {}
X   ColumnVector(ArrayLengthSpecifier n) : Matrix(n.Value(),1) {}
X   ColumnVector(const BaseMatrix&);
X   ColumnVector(const ColumnVector& gm) { GetMatrix(&gm); }
X#ifndef __ZTC__
X   Real operator()(int) const;                  // access element
X#endif
X   void operator=(const BaseMatrix&);
X   void operator=(Real f) { GeneralMatrix::operator=(f); }
X   void operator=(const ColumnVector& m) { operator=((const BaseMatrix&)m); }
X   Real& operator()(int);                       // access element
X   Real& element(int);                          // access element
X#ifdef SETUP_C_SUBSCRIPTS
X   Real& operator[](int m) { return store[m]; }
X   const Real& operator[](int m) const { return store[m]; }
X#endif
X   MatrixType Type() const;
X   GeneralMatrix* Transpose(TransposedMatrix*, MatrixType);
X   void ReDimension(int);                       // change dimensions
X#ifndef __ZTC__
X   Real* nric() const
X      { CheckStore(); return store-1; }         // for use by NRIC
X#endif
X   void CleanUp();                                // to clear store
X   NEW_DELETE(ColumnVector)
X};
X
Xclass CroutMatrix : public GeneralMatrix        // for LU decomposition
X{
X   int* indx;
X   Boolean d;
X   Boolean sing;
X   void ludcmp();
Xpublic:
X   CroutMatrix(const BaseMatrix&);
X   MatrixType Type() const;
X   void lubksb(Real*, int=0);
X   ~CroutMatrix();
X   GeneralMatrix* MakeSolver() { return this; } // for solving
X   LogAndSign LogDeterminant() const;
X   void Solver(MatrixRowCol&, const MatrixRowCol&);
X   void GetRow(MatrixRowCol&);
X   void GetCol(MatrixRowCol&);
X   void operator=(const BaseMatrix&);
X   void operator=(const CroutMatrix& m) { operator=((const BaseMatrix&)m); }
X   void CleanUp();                                // to clear store
X   NEW_DELETE(CroutMatrix)
X};
X
X/******************************* band matrices ***************************/
X
Xclass BandMatrix : public GeneralMatrix         // band matrix
X{
X   GeneralMatrix* Image() const;                // copy of matrix
Xprotected:
X   void CornerClear() const;                    // set unused elements to zero
Xpublic:
X   int lower, upper;                            // band widths
X   BandMatrix() { lower=0; upper=0; CornerClear(); }
X   BandMatrix(int n,int lb,int ub) { ReDimension(n,lb,ub); CornerClear(); }
X                                                // standard declaration
X   BandMatrix(const BaseMatrix&);               // evaluate BaseMatrix
X   void operator=(const BaseMatrix&);
X   void operator=(Real f) { GeneralMatrix::operator=(f); }
X   void operator=(const BandMatrix& m) { operator=((const BaseMatrix&)m); }
X   MatrixType Type() const;
X   Real& operator()(int, int);                  // access element
X   Real& element(int, int);                     // access element
X#ifdef SETUP_C_SUBSCRIPTS
X   Real* operator[](int m) { return store+(upper+lower)*m+lower; }
X   const Real* operator[](int m) const { return store+(upper+lower)*m+lower; }
X#endif
X   BandMatrix(const BandMatrix& gm) { GetMatrix(&gm); }
X#ifndef __ZTC__
X   Real operator()(int, int) const;             // access element
X#endif
X   LogAndSign LogDeterminant() const;
X   GeneralMatrix* MakeSolver();
X   Real Trace() const;
X   Real SumSquare() const { CornerClear(); return GeneralMatrix::SumSquare(); }
X   Real SumAbsoluteValue() const
X      { CornerClear(); return GeneralMatrix::SumAbsoluteValue(); }
X   Real MaximumAbsoluteValue() const
X      { CornerClear(); return GeneralMatrix::MaximumAbsoluteValue(); }
X   void GetRow(MatrixRowCol&);
X   void GetCol(MatrixRowCol&);
X   void RestoreCol(MatrixRowCol&);
X   void NextRow(MatrixRowCol&);
X   void ReDimension(int, int, int);             // change dimensions
X   MatrixBandWidth BandWidth() const;
X   void SetParameters(const GeneralMatrix*);
X   MatrixInput operator<<(Real);                // will give error
X   void operator<<(const Real* r);              // will give error
X      // the next is included because Zortech and Borland
X      // can't find the copy in GeneralMatrix
X   void operator<<(const BaseMatrix& X) { GeneralMatrix::operator<<(X); }
X   NEW_DELETE(BandMatrix)
X};
X
Xclass UpperBandMatrix : public BandMatrix       // upper band matrix
X{
X   GeneralMatrix* Image() const;                // copy of matrix
Xpublic:
X   UpperBandMatrix() {}
X   UpperBandMatrix(int n, int ubw)              // standard declaration
X      : BandMatrix(n, 0, ubw) {}
X   UpperBandMatrix(const BaseMatrix&);          // evaluate BaseMatrix
X   void operator=(const BaseMatrix&);
X   void operator=(Real f) { GeneralMatrix::operator=(f); }
X   void operator=(const UpperBandMatrix& m)
X      { operator=((const BaseMatrix&)m); }
X   MatrixType Type() const;
X   UpperBandMatrix(const UpperBandMatrix& gm) { GetMatrix(&gm); }
X   GeneralMatrix* MakeSolver() { return this; }
X   void Solver(MatrixRowCol&, const MatrixRowCol&);
X   LogAndSign LogDeterminant() const;
X   void ReDimension(int n,int ubw)              // change dimensions
X      { BandMatrix::ReDimension(n,0,ubw); }
X   Real& operator()(int, int);
X   Real& element(int, int);
X#ifdef SETUP_C_SUBSCRIPTS
X   Real* operator[](int m) { return store+upper*m; }
X   const Real* operator[](int m) const { return store+upper*m; }
X#endif
X   NEW_DELETE(UpperBandMatrix)
X};
X
Xclass LowerBandMatrix : public BandMatrix       // upper band matrix
X{
X   GeneralMatrix* Image() const;                // copy of matrix
Xpublic:
X   LowerBandMatrix() {}
X   LowerBandMatrix(int n, int lbw)              // standard declaration
X      : BandMatrix(n, lbw, 0) {}
X   LowerBandMatrix(const BaseMatrix&);          // evaluate BaseMatrix
X   void operator=(const BaseMatrix&);
X   void operator=(Real f) { GeneralMatrix::operator=(f); }
X   void operator=(const LowerBandMatrix& m)
X      { operator=((const BaseMatrix&)m); }
X   MatrixType Type() const;
X   LowerBandMatrix(const LowerBandMatrix& gm) { GetMatrix(&gm); }
X   GeneralMatrix* MakeSolver() { return this; }
X   void Solver(MatrixRowCol&, const MatrixRowCol&);
X   LogAndSign LogDeterminant() const;
X   void ReDimension(int n,int lbw)             // change dimensions
X      { BandMatrix::ReDimension(n,lbw,0); }
X   Real& operator()(int, int);
X   Real& element(int, int);
X#ifdef SETUP_C_SUBSCRIPTS
X   Real* operator[](int m) { return store+lower*(m+1); }
X   const Real* operator[](int m) const { return store+lower*(m+1); }
X#endif
X   NEW_DELETE(LowerBandMatrix)
X};
X
Xclass SymmetricBandMatrix : public GeneralMatrix
X{
X   GeneralMatrix* Image() const;                // copy of matrix
X   void CornerClear() const;                    // set unused elements to zero
Xpublic:
X   int lower;                                   // lower band width
X   SymmetricBandMatrix() { lower=0; CornerClear(); }
X   SymmetricBandMatrix(int n, int lb) { ReDimension(n,lb); CornerClear(); }
X   SymmetricBandMatrix(const BaseMatrix&);
X   void operator=(const BaseMatrix&);
X   void operator=(Real f) { GeneralMatrix::operator=(f); }
X   void operator=(const SymmetricBandMatrix& m)
X      { operator=((const BaseMatrix&)m); }
X   Real& operator()(int, int);                  // access element
X   Real& element(int, int);                     // access element
X#ifdef SETUP_C_SUBSCRIPTS
X   Real* operator[](int m) { return store+lower*(m+1); }
X   const Real* operator[](int m) const { return store+lower*(m+1); }
X#endif
X   MatrixType Type() const;
X   SymmetricBandMatrix(const SymmetricBandMatrix& gm) { GetMatrix(&gm); }
X#ifndef __ZTC__
X   Real operator()(int, int) const;             // access element
X#endif
X   GeneralMatrix* MakeSolver();
X   Real SumSquare() const;
X   Real SumAbsoluteValue() const;
X   Real MaximumAbsoluteValue() const
X      { CornerClear(); return GeneralMatrix::MaximumAbsoluteValue(); }
X   Real Trace() const;
X   LogAndSign LogDeterminant() const;
X   void GetRow(MatrixRowCol&);
X   void GetCol(MatrixRowCol&);
X   GeneralMatrix* Transpose(TransposedMatrix*, MatrixType);
X   void ReDimension(int,int);                       // change dimensions
X   MatrixBandWidth BandWidth() const;
X   void SetParameters(const GeneralMatrix*);
X   NEW_DELETE(SymmetricBandMatrix)
X};
X
Xclass BandLUMatrix : public GeneralMatrix
X// for LU decomposition of band matrix
X{
X   int* indx;
X   Boolean d;
X   Boolean sing;                                   // TRUE if singular
X   Real* store2;
X   int storage2;
X   void ludcmp();
X   int m1,m2;                                   // lower and upper
Xpublic:
X   BandLUMatrix(const BaseMatrix&);
X   MatrixType Type() const;
X   void lubksb(Real*, int=0);
X   ~BandLUMatrix();
X   GeneralMatrix* MakeSolver() { return this; } // for solving
X   LogAndSign LogDeterminant() const;
X   void Solver(MatrixRowCol&, const MatrixRowCol&);
X   void GetRow(MatrixRowCol&);
X   void GetCol(MatrixRowCol&);
X   void operator=(const BaseMatrix&);
X   void operator=(const BandLUMatrix& m) { operator=((const BaseMatrix&)m); }
X   NEW_DELETE(BandLUMatrix)
X   void CleanUp();                                // to clear store
X};
X
X
X/***************************** temporary classes *************************/
X
Xclass MultipliedMatrix : public BaseMatrix
X{
Xprotected:
X   union { const BaseMatrix* bm1; GeneralMatrix* gm1; };
X						  // pointers to summands
X   union { const BaseMatrix* bm2; GeneralMatrix* gm2; };
X   MultipliedMatrix(const BaseMatrix* bm1x, const BaseMatrix* bm2x)
X      : bm1(bm1x),bm2(bm2x) {}
X   int search(const BaseMatrix*) const;
X   friend class BaseMatrix;
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   MatrixBandWidth BandWidth() const;
X   NEW_DELETE(MultipliedMatrix)
X};
X
Xclass AddedMatrix : public MultipliedMatrix
X{
Xprotected:
X   AddedMatrix(const BaseMatrix* bm1x, const BaseMatrix* bm2x)
X      : MultipliedMatrix(bm1x,bm2x) {}
X
X   friend class BaseMatrix;
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   MatrixBandWidth BandWidth() const;
X#ifdef __GNUG__
X   void SelectVersion(MatrixType, int&, int&) const;
X#else
X   void SelectVersion(MatrixType, Boolean&, Boolean&) const;
X#endif
X   NEW_DELETE(AddedMatrix)
X};
X
Xclass SolvedMatrix : public MultipliedMatrix
X{
X   SolvedMatrix(const BaseMatrix* bm1x, const BaseMatrix* bm2x)
X      : MultipliedMatrix(bm1x,bm2x) {}
X   friend class BaseMatrix;
X   friend class InvertedMatrix;                        // for operator*
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   MatrixBandWidth BandWidth() const;
X   NEW_DELETE(SolvedMatrix)
X};
X
Xclass SubtractedMatrix : public AddedMatrix
X{
X   SubtractedMatrix(const BaseMatrix* bm1x, const BaseMatrix* bm2x)
X      : AddedMatrix(bm1x,bm2x) {}
X   friend class BaseMatrix;
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   NEW_DELETE(SubtractedMatrix)
X};
X
Xclass ShiftedMatrix : public BaseMatrix
X{
Xprotected:
X   Real f;
X   union { const BaseMatrix* bm; GeneralMatrix* gm; };
X   ShiftedMatrix(const BaseMatrix* bmx, Real fx) : bm(bmx),f(fx) {}
X   int search(const BaseMatrix*) const;
X   friend class BaseMatrix;
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   NEW_DELETE(ShiftedMatrix)
X};
X
Xclass ScaledMatrix : public ShiftedMatrix
X{
X   ScaledMatrix(const BaseMatrix* bmx, Real fx) : ShiftedMatrix(bmx,fx) {}
X   friend class BaseMatrix;
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   MatrixBandWidth BandWidth() const;
X   NEW_DELETE(ScaledMatrix)
X};
X
Xclass NegatedMatrix : public BaseMatrix
X{
Xprotected:
X   union { const BaseMatrix* bm; GeneralMatrix* gm; };
X   NegatedMatrix(const BaseMatrix* bmx) : bm(bmx) {}
X   int search(const BaseMatrix*) const;
Xprivate:
X   friend class BaseMatrix;
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   MatrixBandWidth BandWidth() const;
X   NEW_DELETE(NegatedMatrix)
X};
X
Xclass TransposedMatrix : public NegatedMatrix
X{
X   TransposedMatrix(const BaseMatrix* bmx) : NegatedMatrix(bmx) {}
X   friend class BaseMatrix;
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   MatrixBandWidth BandWidth() const;
X   NEW_DELETE(TransposedMatrix)
X};
X
Xclass InvertedMatrix : public NegatedMatrix
X{
X   InvertedMatrix(const BaseMatrix* bmx) : NegatedMatrix(bmx) {}
Xpublic:
X#ifndef TEMPS_DESTROYED_QUICKLY
X   SolvedMatrix operator*(const BaseMatrix&) const;  // inverse(A) * B
X#else
X   SolvedMatrix& operator*(const BaseMatrix&);       // inverse(A) * B
X#endif
X   friend class BaseMatrix;
X   GeneralMatrix* Evaluate(MatrixType);
X   MatrixBandWidth BandWidth() const;
X   NEW_DELETE(InvertedMatrix)
X};
X
Xclass RowedMatrix : public NegatedMatrix
X{
X   RowedMatrix(const BaseMatrix* bmx) : NegatedMatrix(bmx) {}
X   friend class BaseMatrix;
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   MatrixBandWidth BandWidth() const;
X   NEW_DELETE(RowedMatrix)
X};
X
Xclass ColedMatrix : public NegatedMatrix
X{
X   ColedMatrix(const BaseMatrix* bmx) : NegatedMatrix(bmx) {}
X   friend class BaseMatrix;
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   MatrixBandWidth BandWidth() const;
X   NEW_DELETE(ColedMatrix)
X};
X
Xclass DiagedMatrix : public NegatedMatrix
X{
X   DiagedMatrix(const BaseMatrix* bmx) : NegatedMatrix(bmx) {}
X   friend class BaseMatrix;
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   MatrixBandWidth BandWidth() const;
X   NEW_DELETE(DiagedMatrix)
X};
X
Xclass MatedMatrix : public NegatedMatrix
X{
X   int nr, nc;
X   MatedMatrix(const BaseMatrix* bmx, int nrx, int ncx)
X      : NegatedMatrix(bmx), nr(nrx), nc(ncx) {}
X   friend class BaseMatrix;
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   MatrixBandWidth BandWidth() const;
X   NEW_DELETE(MatedMatrix)
X};
X
Xclass ConstMatrix : public BaseMatrix
X{
X   const GeneralMatrix* cgm;
X   int search(const BaseMatrix*) const;
X   ConstMatrix(const GeneralMatrix* cgmx) : cgm(cgmx) {}
X   friend class BaseMatrix;
X   friend class GeneralMatrix;
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   MatrixBandWidth BandWidth() const;
X   NEW_DELETE(ConstMatrix)
X};
X
Xclass ReturnMatrixX : public BaseMatrix    // for matrix return
X{
X   GeneralMatrix* gm;
X   int search(const BaseMatrix*) const;
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   friend class BaseMatrix;
X#ifdef TEMPS_DESTROYED_QUICKLY
X   ReturnMatrixX(const ReturnMatrixX& tm);
X#else
X   ReturnMatrixX(const ReturnMatrixX& tm) : gm(tm.gm) {}
X#endif
X   ReturnMatrixX(const GeneralMatrix* gmx) : gm((GeneralMatrix*&)gmx) {}
X//   ReturnMatrixX(GeneralMatrix&);
X   MatrixBandWidth BandWidth() const;
X   NEW_DELETE(ReturnMatrixX)
X};
X
X
X/**************************** submatrices ******************************/
X
Xclass GetSubMatrix : public NegatedMatrix
X{
X   int row_skip;
X   int row_number;
X   int col_skip;
X   int col_number;
X   Boolean IsSym;
X
X   GetSubMatrix
X      (const BaseMatrix* bmx, int rs, int rn, int cs, int cn, Boolean is)
X      : NegatedMatrix(bmx),
X      row_skip(rs), row_number(rn), col_skip(cs), col_number(cn), IsSym(is) {}
X   GetSubMatrix(const GetSubMatrix& g)
X      : NegatedMatrix(g.bm), row_skip(g.row_skip), row_number(g.row_number),
X      col_skip(g.col_skip), col_number(g.col_number), IsSym(g.IsSym) {}
X   void SetUpLHS();
X   friend class BaseMatrix;
Xpublic:
X   GeneralMatrix* Evaluate(MatrixType);
X   void operator=(const BaseMatrix&);
X   void operator=(const GetSubMatrix& m) { operator=((const BaseMatrix&)m); }
X   void operator<<(const BaseMatrix&);
X   void operator<<(const Real*);                // copy from array
X   void operator=(Real);                        // copy from constant
X   void Inject(const GeneralMatrix&);           // copy stored els only
X   MatrixBandWidth BandWidth() const;
X   NEW_DELETE(GetSubMatrix)
X};
X
X/**************************** matrix input *******************************/
X
Xclass MatrixInput          // for reading a list of values into a matrix
X                           // the difficult part is detecting a mismatch
X                           // in the number of elements
X{
X   static int n;           // number values still to be read
X   static Real* r;         // pointer to last thing read
X   static int depth;       // number of objects of this class in existence
Xpublic:
X   MatrixInput() { depth++; }
X   MatrixInput(const MatrixInput&) { depth++; }
X   ~MatrixInput();
X   MatrixInput operator<<(Real);
X                           // could return a reference if we don't have
X                           // TEMPS_DESTROYED_QUICKLY
X   friend GeneralMatrix;                             
X};
X
X/***************************** exceptions ********************************/
X
Xclass MatrixDetails
X{
X   MatrixType type;
X   int nrows;
X   int ncols;
X   int ubw;
X   int lbw;
Xpublic:
X   MatrixDetails(const GeneralMatrix& A);
X   void PrintOut();
X};
X   
X
X
Xclass SpaceException : public Exception
X{
Xpublic:
X   static long st_type() { return 2; }
X   long type() const { return 2; }
X   static int action;
X   SpaceException();
X   static void SetAction(int a) { action=a; }
X};
X
X
Xclass MatrixException : public Exception
X{
Xpublic:
X   static long st_type() { return 3; }
X   long type() const { return 3; }
X   MatrixException(int);
X   MatrixException(int, const GeneralMatrix&);
X   MatrixException(int, const GeneralMatrix&, const GeneralMatrix&);
X};
X
Xclass DataException : public MatrixException
X{
Xpublic:
X   static long st_type() { return 3*53; }
X   long type() const { return 3*53; }
X   static int action;
X   DataException(const GeneralMatrix& A);
X   static void SetAction(int a) { action=a; }
X};
X
Xclass SingularException : public DataException
X{
Xpublic:
X   static long st_type() { return 3*53*109; }
X   long type() const { return 3*53*109; }
X   SingularException(const GeneralMatrix& A);
X};
X
Xclass NPDException : public DataException     // Not positive definite
X{
Xpublic:
X   static long st_type() { return 3*53*113; }
X   long type() const { return 3*53*113; }
X   NPDException(const GeneralMatrix&);
X};
X
Xclass ConvergenceException : public MatrixException
X{
Xpublic:
X   static long st_type() { return 3*59; }
X   long type() const { return 3*59; }
X   static int action;
X   ConvergenceException(const GeneralMatrix& A);
X   static void SetAction(int a) { action=a; }
X};
X
Xclass ProgramException : public MatrixException
X{
Xpublic:
X   static long st_type() { return 3*61; }
X   long type() const { return 3*61; }
X   static int action;
X   ProgramException(char* c);
X   ProgramException(char* c, const GeneralMatrix&);
X   ProgramException(char* c, const GeneralMatrix&, const GeneralMatrix&);
X   ProgramException();
X   ProgramException(const GeneralMatrix&);
X   static void SetAction(int a) { action=a; }
X};
X
Xclass IndexException : public ProgramException
X{
Xpublic:
X   static long st_type() { return 3*61*101; }
X   long type() const { return 3*61*101; }
X   IndexException(int i, const GeneralMatrix& A);
X   IndexException(int i, int j, const GeneralMatrix& A);
X   // next two are for access via element function
X   IndexException(int i, const GeneralMatrix& A, Boolean);
X   IndexException(int i, int j, const GeneralMatrix& A, Boolean);
X};
X
Xclass VectorException : public ProgramException    // can't convert to vector
X{
Xpublic:
X   static long st_type() { return 3*61*107; }
X   long type() const { return 3*61*107; }
X   VectorException();
X   VectorException(const GeneralMatrix& A);
X};
X
Xclass NotSquareException : public ProgramException
X{
Xpublic:
X   static long st_type() { return 3*61*109; }
X   long type() const { return 3*61*109; }
X   NotSquareException(const GeneralMatrix& A);
X};
X
Xclass SubMatrixDimensionException : public ProgramException
X{
Xpublic:
X   static long st_type() { return 3*61*113; }
X   long type() const { return 3*61*113; }
X   SubMatrixDimensionException();
X};
X
Xclass IncompatibleDimensionsException : public ProgramException
X{
Xpublic:
X   static long st_type() { return 3*61*127; }
X   long type() const { return 3*61*127; }
X   IncompatibleDimensionsException();
X};
X
Xclass NotDefinedException : public ProgramException
X{
Xpublic:
X   static long st_type() { return 3*61*131; }
X   long type() const { return 3*61*131; }
X   NotDefinedException(char* op, char* matrix);
X};
X
Xclass CannotBuildException : public ProgramException
X{
Xpublic:
X   static long st_type() { return 3*61*137; }
X   long type() const { return 3*61*137; }
X   CannotBuildException(char* matrix);
X};
X
X
Xclass InternalException : public MatrixException
X{
Xpublic:
X   static long st_type() { return 3*67; }
X   long type() const { return 3*67; }
X   static int action;
X   InternalException(char* c);
X   static void SetAction(int a) { action=a; }
X};
X
X
X/***************************** functions ***********************************/
X
X
Xinline LogAndSign LogDeterminant(const BaseMatrix& B)
X   { return B.LogDeterminant(); }
Xinline Real SumSquare(const BaseMatrix& B) { return B.SumSquare(); }
Xinline Real Trace(const BaseMatrix& B) { return B.Trace(); }
Xinline Real SumAbsoluteValue(const BaseMatrix& B)
X   { return B.SumAbsoluteValue(); }
Xinline Real MaximumAbsoluteValue(const BaseMatrix& B)
X   { return B.MaximumAbsoluteValue(); }
Xinline Real Norm1(const BaseMatrix& B) { return B.Norm1(); }
Xinline Real Norm1(RowVector& RV) { return RV.MaximumAbsoluteValue(); }
Xinline Real NormInfinity(const BaseMatrix& B) { return B.NormInfinity(); }
Xinline Real NormInfinity(ColumnVector& CV)
X   { return CV.MaximumAbsoluteValue(); } 
X
X#endif
END_OF_FILE
if test 47360 -ne `wc -c <'newmat.h'`; then
    echo shar: \"'newmat.h'\" unpacked with wrong size!
fi
# end of 'newmat.h'
fi
if test -f 'newmatc.txt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'newmatc.txt'\"
else
echo shar: Extracting \"'newmatc.txt'\" \(1948 characters\)
sed "s/^X//" >'newmatc.txt' <<'END_OF_FILE'
X//$$ newmatc.txt                                      Testing
X
X                    Testing newmat on your compiler
X                    ===============================
X
XThere are a series of files of the form tmt?.cxx included with some
Xversions of the package. These are used to check that the package is
Xperforming correctly. They consist of a large number of matrix formulae
Xall of which evaluate to zero (except the first one which is used to
Xcheck that we are detecting non-zero matrices). The printout should
Xstate that it has found one non-zero matrix.
X
XVarious versions of the make file (extension .mak) are included with the
Xpackage.
X
XThere is an optional #define DO_FREE_CHECK in include.h. If this is
Xactivated the program will check that the new-s and delete-s are
Xbalanced. There should be no unbalanced new-s or delete-s. You need the
XANSI version of the preprocessor to run DO_FREE_CHECK.
X
XThe program also allocates and deletes a large block and small block of
Xmemory before it starts the main testing and then at the end of the
Xtest. It then checks that the blocks of memory were allocated in the
Xsame place. If not then one suspects that there has been a memory leak.
Xi.e. a piece of memory has been allocated and not deleted.
X
XThis is not completely foolproof. Programs may allocate extra print
Xbuffers while the program is running. I have tried to overcome this by
Xdoing a print before I allocate the first memory block. Programs may
Xallocate memory for different sized items in different places, or might
Xnot allocate items consecutively. Or they might mix the items with memory
Xblocks from other programs. Nevertheless, I seem to get consistent
Xanswers from most of the compilers I am working with, so I think this is
Xa worthwhile test.
X
XGnu 2.2 and Zortech do not pass this test. There may be good reasons for
Xthis, but I think it would be a good idea if the authors of these
Xpackages made sure they knew what was happening.
X
END_OF_FILE
if test 1948 -ne `wc -c <'newmatc.txt'`; then
    echo shar: \"'newmatc.txt'\" unpacked with wrong size!
fi
# end of 'newmatc.txt'
fi
echo shar: End of archive 3 \(of 8\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
