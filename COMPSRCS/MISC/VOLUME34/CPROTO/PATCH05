Newsgroups: comp.sources.misc
From: cthuang@zerosan.canrem.COM (Chin Huang)
Subject:  v34i003:  cproto - generate C function prototypes v3, Patch05
Message-ID: <1992Nov29.220352.6783@sparky.imd.sterling.com>
X-Md4-Signature: 13e7608c99344dc6040f0a256459f5ed
Date: Sun, 29 Nov 1992 22:03:52 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: cthuang@zerosan.canrem.COM (Chin Huang)
Posting-number: Volume 34, Issue 3
Archive-name: cproto/patch05
Environment: UNIX, MS-DOS, getopt, lex, yacc
Patch-To: cproto: Volume 29, Issue 61-62

This patch brings cproto to version 3 patchlevel 5.  This release
includes further bug fixes and enhancements.  Read the CHANGES file for
details.  Thanks to the following people for their suggestions and bug
reports:

    schellen@mprgate.mpr.ca (Neil Schellenberger)
    Phil Kernick <phil@adam.adelaide.edu.au>
    Chris Moran <cjm@trillian.mincom.oz.au>
    jerry@Synopsys.COM (Jerry Huth)
    "Nelson H. F. Beebe" <beebe@math.utah.edu>
    hargen@sybus.com (Bill Hargen)
    lew@gsg.GSG.COM (Paul Lew)
    Masaki Kondo <ms-kondo@nsis.cl.nec.co.jp>

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of shell archive."
# Contents:  patch5
# Wrapped by cthuang@zerosan.UUCP on Sat Nov 28 23:58:06 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f patch5 -a "${1}" != "-c" ; then 
  echo shar: Will not over-write existing file \"patch5\"
else
echo shar: Extracting \"patch5\" \(49845 characters\)
sed "s/^X//" >patch5 <<'END_OF_patch5'
Xdiff  -c2 old/CHANGES new/CHANGES
X*** old/CHANGES	Wed Jun 10 21:03:00 1992
X--- new/CHANGES	Sat Nov 28 23:18:24 1992
X***************
X*** 1,4 ****
X--- 1,46 ----
X  Version 3
X  
X+ Patchlevel 5
X+ 
X+ - Fix: The -v option did not output declarations for function pointers.
X+ - Fix: String literals continued over more than one line messed up the
X+   line number count.
X+ - Fix: The program generated incorrect prototypes for functions that take
X+   a variable argument list using <varargs.h>.
X+ - Fix: When converting functions from the standard input, cproto generated
X+   no output if no functions needed to be converted.
X+ - Fix: Now does not output a warning if an untagged struct is found in a
X+   typedef declaration.
X+ - Added the -b option which rewrites function definition heads to
X+   include both old style and new style declarations separated by a
X+   conditional compilation directive.  For example, the program can
X+   generate
X+ 
X+ 	#ifdef ANSI_FUNC
X+ 
X+ 	int
X+ 	main (int argc, char *argv[])
X+ 	#else
X+ 
X+ 	int
X+ 	main (argc, argv)
X+ 	int argc;
X+ 	char *argv[]
X+ 	#endif
X+ 	{
X+ 	}
X+ 
X+   Added the -B option to set the preprocessor directive that appears
X+   at the beginning of such definitions.
X+ - Added the keyword "interrupt" to the set of type qualifiers when compiled
X+   on a UNIX system.
X+ - The MS-DOS version now recognizes the type modifiers introduced by
X+   Microsoft C/C++ 7.00.
X+ - Now recognizes ANSI C trigraphs (yuck!).
X+ - Now use "#if __STDC__" instead of "#if defined(__STDC__)".
X+ - GNU bison orders the y.tab.c sections differently than yacc, which
X+   resulted in references to variables before they were declared.  The
X+   grammar specification was modified to also be compatible with bison.
X+ 
X  Patchlevel 4
X  
X***************
X*** 7,11 ****
X    For example, for the definition
X  
X!   	typedef char *caddr_t;
X  
X  	int strlen (s)
X--- 49,53 ----
X    For example, for the definition
X  
X! 	typedef char *caddr_t;
X  
X  	int strlen (s)
X***************
X*** 16,20 ****
X    cproto generated the incorrect prototype
X  
X!   	int strlen(int s);
X  
X  - Added implementation of the ANSI function tmpfile() for systems that
X--- 58,62 ----
X    cproto generated the incorrect prototype
X  
X! 	int strlen(int s);
X  
X  - Added implementation of the ANSI function tmpfile() for systems that
X***************
X*** 64,68 ****
X    For example, for the definition
X  
X!   	typedef unsigned short ushort;
X  
X  	void test (x)
X--- 106,110 ----
X    For example, for the definition
X  
X! 	typedef unsigned short ushort;
X  
X  	void test (x)
X***************
X*** 73,81 ****
X    cproto generated the incorrect prototype
X  
X!   	void test(ushort x);
X  
X    while the correct one is
X  
X!   	void test(int x);
X  
X  - Fix: Incorrect prototypes were generated for functions that returned
X--- 115,123 ----
X    cproto generated the incorrect prototype
X  
X! 	void test(ushort x);
X  
X    while the correct one is
X  
X! 	void test(int x);
X  
X  - Fix: Incorrect prototypes were generated for functions that returned
Xdiff  -c2 old/config.h new/config.h
X*** old/config.h	Fri Jul 03 13:37:52 1992
X--- new/config.h	Sat Nov 28 23:27:44 1992
X***************
X*** 1,3 ****
X! /* $Id: config.h 3.4 92/07/03 13:37:48 cthuang Exp $
X   *
X   * cproto configuration and system dependencies
X--- 1,3 ----
X! /* $Id: config.h 3.5 1992/11/29 04:27:30 cthuang Exp $
X   *
X   * cproto configuration and system dependencies
X***************
X*** 43,47 ****
X  #endif
X  
X! #if defined(__STDC__) || defined(MSDOS)
X  #include <stdlib.h>
X  #include <string.h>
X--- 43,47 ----
X  #endif
X  
X! #if __STDC__ || defined(MSDOS)
X  #include <stdlib.h>
X  #include <string.h>
Xdiff  -c2 old/cproto.1 new/cproto.1
X*** old/cproto.1	Wed Jun 10 21:03:02 1992
X--- new/cproto.1	Sat Nov 28 23:34:08 1992
X***************
X*** 1,3 ****
X! .\" $Id: cproto.1 3.6 92/06/10 20:55:39 cthuang Exp $
X  .\"
X  .de EX		\"Begin example
X--- 1,3 ----
X! .\" $Id: cproto.1 3.7 1992/11/29 04:34:05 cthuang Exp $
X  .\"
X  .de EX		\"Begin example
X***************
X*** 14,18 ****
X  .if t .sp .5
X  ..
X! .TH CPROTO 1 "April 7, 1992"
X  .SH NAME
X  cproto \- generate C function prototypes and convert function definitions
X--- 14,18 ----
X  .if t .sp .5
X  ..
X! .TH CPROTO 1 "October 24, 1992"
X  .SH NAME
X  cproto \- generate C function prototypes and convert function definitions
X***************
X*** 31,35 ****
X  Optionally,
X  .B cproto
X! also outputs declarations for any variables defined in the file.
X  If no
X  .I file
X--- 31,35 ----
X  Optionally,
X  .B cproto
X! also outputs declarations for variables defined in the files.
X  If no
X  .I file
X***************
X*** 88,98 ****
X  .SH OPTIONS
X  .TP
X- .B \-a
X- Convert function definitions from the old style to the ANSI C style.
X- .TP
X  .B \-e
X  Output the keyword
X  .B extern
X! in front of every declaration having global scope.
X  .TP
X  .BI \-f n
X--- 88,95 ----
X  .SH OPTIONS
X  .TP
X  .B \-e
X  Output the keyword
X  .B extern
X! in front of every generated prototype or declaration that has global scope.
X  .TP
X  .BI \-f n
X***************
X*** 169,177 ****
X  declarations as well.
X  .TP
X  .B \-t
X  Convert function definitions from the ANSI C style to the traditional style.
X  .TP
X! .B \-v
X! Also output declarations for variables defined in the source.
X  .LP
X  .nf
X--- 166,205 ----
X  declarations as well.
X  .TP
X+ .B \-v
X+ Also output declarations for variables defined in the source.
X+ .TP
X+ .B \-a
X+ Convert function definitions from the old style to the ANSI C style.
X+ .TP
X  .B \-t
X  Convert function definitions from the ANSI C style to the traditional style.
X  .TP
X! .B \-b
X! Rewrite function definition heads to include both old style and new style
X! declarations separated by a conditional compilation directive.
X! For example, the program can generate this function definition:
X! .EX
X! #ifdef ANSI_FUNC
X! 
X! int
X! main (int argc, char *argv[])
X! #else
X! 
X! int
X! main (argc, argv)
X! int argc;
X! char *argv[]
X! #endif
X! {
X! }
X! .EE
X! .TP
X! .BI \-B directive
X! Set the conditional compilation directive to output at the beginning of
X! function definitions generated by the \-b option.
X! The default is
X! .EX
X! #ifdef ANSI_FUNC
X! .EE 
X  .LP
X  .nf
X***************
X*** 185,189 ****
X  The format is specified by a template in the form
X  .EX
X! " int main ( a, b )"
X  .EE
X  but you may replace each space in this string with any number of
X--- 213,217 ----
X  The format is specified by a template in the form
X  .EX
X! " int f ( a, b )"
X  .EE
X  but you may replace each space in this string with any number of
X***************
X*** 191,195 ****
X  For example, the option
X  .EX
X! -F"int main(\\n\\ta,\\n\\tb\\n\\t)"
X  .EE
X  will produce
X--- 219,223 ----
X  For example, the option
X  .EX
X! -F"int f(\\n\\ta,\\n\\tb\\n\\t)"
X  .EE
X  will produce
X***************
X*** 201,205 ****
X  .EE
X  .TP
X! .BI \-D name\[=value\]
X  This option is passed through to the preprocessor and is used to define 
X  symbols for use with conditionals such as
X--- 229,233 ----
X  .EE
X  .TP
X! .BI \-D name[=value]
X  This option is passed through to the preprocessor and is used to define 
X  symbols for use with conditionals such as
Xdiff  -c2 old/cproto.c new/cproto.c
X*** old/cproto.c	Wed Jun 10 21:03:08 1992
X--- new/cproto.c	Sat Nov 28 23:27:52 1992
X***************
X*** 1,3 ****
X! /* $Id: cproto.c 3.6 92/06/10 20:56:26 cthuang Exp $
X   *
X   * C function prototype generator and function definition converter
X--- 1,3 ----
X! /* $Id: cproto.c 3.7 1992/11/29 04:27:49 cthuang Exp $
X   *
X   * C function prototype generator and function definition converter
X***************
X*** 4,8 ****
X   */
X  #ifndef lint
X! static char rcsid[] = "$Id: cproto.c 3.6 92/06/10 20:56:26 cthuang Exp $";
X  #endif
X  #include <stdio.h>
X--- 4,8 ----
X   */
X  #ifndef lint
X! static char rcsid[] = "$Id: cproto.c 3.7 1992/11/29 04:27:49 cthuang Exp $";
X  #endif
X  #include <stdio.h>
X***************
X*** 48,51 ****
X--- 48,54 ----
X  boolean proto_comments = TRUE;
X  
X+ /* Conditional compilation directive output in front of function definitions */
X+ char *func_directive = "#ifdef ANSI_FUNC";
X+ 
X  /* Output formats for function declarators */
X  FuncFormat fmt[] = {
X***************
X*** 111,115 ****
X  put_error ()
X  {
X!     fprintf(stderr, "\"%s\", line %d: ", cur_file_name(), cur_line_num());
X  }
X  
X--- 114,118 ----
X  put_error ()
X  {
X!     fprintf(stderr, "\"%s\", line %u: ", cur_file_name(), cur_line_num());
X  }
X  
X***************
X*** 226,255 ****
X      fprintf(stderr, "usage: %s [ option ... ] [ file ... ]\n", progname);
X      fputs("Options:\n", stderr);
X!     fputs("  -a       Convert function definitions to ANSI style\n", stderr);
X!     fputs("  -c       Omit comments in generated prototypes\n", stderr);
X!     fputs("  -e       Output \"extern\" keyword before global declarations\n",
X! 	stderr);
X!     fputs("  -f n     Set function prototype style (0 to 4)\n", stderr);
X!     fputs("  -p       Disable formal parameter promotion\n", stderr);
X!     fputs("  -q       Disable include file read failure messages\n", stderr);
X!     fputs("  -s       Output static declarations\n", stderr);
X!     fputs("  -t       Convert function definitions to traditional style\n",
X! 	stderr);
X!     fputs("  -v       Output variable declarations\n", stderr);
X!     fputs("  -m name  Set name of prototype macro\n", stderr);
X!     fputs("  -d       Omit prototype macro definition\n", stderr);
X!     fputs("  -P fmt   Set prototype format template \" int main (a, b)\"\n",
X! 	stderr);
X!     fputs("  -F fmt   Set function definition format template \" int main (a, b)\"\n",
X! 	stderr);
X!     fputs("  -C fmt   Set format for function definition with parameter comments\n",
X! 	stderr);
X!     fputs("  -D name[=value]\n", stderr);
X!     fputs("  -U name\n", stderr);
X!     fputs("  -I directory\n", stderr);
X!     fputs("           Set C preprocessor options\n", stderr);
X!     fputs("  -E cpp   Run specified C preprocessor command\n", stderr);
X!     fputs("  -E 0     Do not run any C preprocessor\n", stderr);
X!     fputs("  -V       Print version information\n", stderr);
X      exit(1);
X  }
X--- 229,252 ----
X      fprintf(stderr, "usage: %s [ option ... ] [ file ... ]\n", progname);
X      fputs("Options:\n", stderr);
X!     fputs("  -a, -t           Convert function definitions to ANSI or traditional style\n", stderr);
X!     fputs("  -b               Rewrite function definitions in both styles\n", stderr);
X!     fputs("  -c               Omit comments in generated prototypes\n", stderr);
X!     fputs("  -e               Output \"extern\" keyword before global declarations\n", stderr);
X!     fputs("  -f n             Set function prototype style (0 to 4)\n", stderr);
X!     fputs("  -p               Disable formal parameter promotion\n", stderr);
X!     fputs("  -q               Disable include file read failure messages\n", stderr);
X!     fputs("  -s               Output static declarations\n", stderr);
X!     fputs("  -v               Output variable declarations\n", stderr);
X!     fputs("  -m name          Set name of prototype macro\n", stderr);
X!     fputs("  -d               Omit prototype macro definition\n", stderr);
X!     fputs("  -P template      Set prototype format template \" int f (a, b)\"\n", stderr);
X!     fputs("  -F template      Set function definition format template \" int f (a, b)\"\n", stderr);
X!     fputs("  -C template      Set format for function definition with parameter comments\n", stderr);
X!     fputs("  -D name[=value]  Define C preprocessor symbol\n", stderr);
X!     fputs("  -U name          Undefine C preprocessor symbol\n", stderr);
X!     fputs("  -I directory     Add #include search directory\n", stderr);
X!     fputs("  -E command       Run specified C preprocessor command\n", stderr);
X!     fputs("  -E 0             Do not run any C preprocessor\n", stderr);
X!     fputs("  -V               Print version information\n", stderr);
X      exit(1);
X  }
X***************
X*** 291,295 ****
X  #ifdef CPP
X      /* Allocate buffer for C preprocessor command line. */
X!     n = strlen(CPP) + 1;
X      for (i = 0; i < argc; ++i) {
X  	n += strlen(argv[i]) + 1;
X--- 288,292 ----
X  #ifdef CPP
X      /* Allocate buffer for C preprocessor command line. */
X!     n = strlen(cpp) + 1;
X      for (i = 0; i < argc; ++i) {
X  	n += strlen(argv[i]) + 1;
X***************
X*** 300,304 ****
X  #endif
X  
X!     while ((c = getopt(argc, argv, "aC:cD:dE:eF:f:I:m:P:pqstU:Vv")) != EOF) {
X  	switch (c) {
X  	case 'I':
X--- 297,301 ----
X  #endif
X  
X!     while ((c = getopt(argc, argv, "aB:bC:cD:dE:eF:f:I:m:P:pqstU:Vv")) != EOF) {
X  	switch (c) {
X  	case 'I':
X***************
X*** 319,322 ****
X--- 316,325 ----
X  	    func_style = FUNC_ANSI;
X  	    break;
X+ 	case 'B':
X+ 	    func_directive = optarg;
X+ 	    break;
X+ 	case 'b':
X+ 	    func_style = FUNC_BOTH;
X+ 	    break;
X  	case 'c':
X  	    proto_comments = FALSE;
X***************
X*** 429,433 ****
X  
X      if (proto_style == PROTO_MACRO && define_macro) {
X! 	printf("#if defined(__STDC__) || defined(__cplusplus)\n");
X  	printf("#define %s(s) s\n", macro_name);
X  	printf("#else\n");
X--- 432,436 ----
X  
X      if (proto_style == PROTO_MACRO && define_macro) {
X! 	printf("#if __STDC__ || defined(__cplusplus)\n");
X  	printf("#define %s(s) s\n", macro_name);
X  	printf("#else\n");
Xdiff  -c2 old/cproto.h new/cproto.h
X*** old/cproto.h	Wed Jun 10 21:03:08 1992
X--- new/cproto.h	Sat Nov 28 23:27:46 1992
X***************
X*** 1,3 ****
X! /* $Id: cproto.h 3.5 92/04/11 19:27:44 cthuang Exp $
X   *
X   * Declarations for C function prototype generator
X--- 1,3 ----
X! /* $Id: cproto.h 3.6 1992/11/29 04:27:30 cthuang Exp $
X   *
X   * Declarations for C function prototype generator
X***************
X*** 45,48 ****
X--- 45,49 ----
X  #define FUNC_TRADITIONAL	1	/* traditional style */
X  #define FUNC_ANSI		2	/* ANSI style */
X+ #define FUNC_BOTH		3	/* both styles */
X  typedef int FuncDefStyle;
X  
X***************
X*** 56,59 ****
X--- 57,61 ----
X      FuncDefStyle func_def;		/* style of function definition */
X      ParameterList params;		/* function parameters */
X+     boolean pointer;			/* TRUE if it declares a pointer */
X      struct declarator *head;		/* head function declarator */
X      struct declarator *func_stack;	/* stack of function declarators */
X***************
X*** 79,83 ****
X      Text text;
X      DeclSpec decl_spec;
X!     Parameter parameter;
X      ParameterList param_list;
X      Declarator *declarator;
X--- 81,85 ----
X      Text text;
X      DeclSpec decl_spec;
X!     Parameter *parameter;
X      ParameterList param_list;
X      Declarator *declarator;
X***************
X*** 127,130 ****
X--- 129,133 ----
X  extern boolean proto_comments;
X  extern boolean quiet;
X+ extern char *func_directive;
X  extern int num_inc_dir;
X  extern char *inc_dir[];
X***************
X*** 137,141 ****
X  extern void put_error();
X  extern void init_parser(), process_file(), pop_file();
X! extern char *cur_file_name();
X  extern unsigned cur_line_num();
X  extern FILE *cur_tmp_file();
X--- 140,144 ----
X  extern void put_error();
X  extern void init_parser(), process_file(), pop_file();
X! extern char *cur_file_name(), *cur_text();
X  extern unsigned cur_line_num();
X  extern FILE *cur_tmp_file();
Xdiff  -c2 old/grammar.y new/grammar.y
X*** old/grammar.y	Wed Jun 10 21:03:02 1992
X--- new/grammar.y	Sat Nov 28 23:27:42 1992
X***************
X*** 1,3 ****
X! /* $Id: grammar.y 3.6 92/06/10 20:56:07 cthuang Exp $
X   *
X   * yacc grammar for C function prototype generator
X--- 1,3 ----
X! /* $Id: grammar.y 3.7 1992/11/29 04:27:30 cthuang Exp $
X   *
X   * yacc grammar for C function prototype generator
X***************
X*** 46,49 ****
X--- 46,52 ----
X  	T_ASMARG
X  
X+ 	/* va_dcl from <varargs.h> */
X+ 	T_VA_DCL
X+ 
X  %type <decl_spec> decl_specifiers decl_specifier
X  %type <decl_spec> storage_class type_specifier type_qualifier
X***************
X*** 66,78 ****
X  #define YYMAXDEPTH 150
X  
X! /* Declaration specifier attributes for the typedef statement currently being
X!  * scanned.
X   */
X  static int cur_decl_spec_flags;
X  
X! /* Pointer to parameter list for the current function definition. */
X  static ParameterList *func_params;
X  
X! /* Pointer to current declarator in function parameter declaration. */
X  static Declarator *cur_declarator;
X  
X--- 69,87 ----
X  #define YYMAXDEPTH 150
X  
X! /* declaration specifier attributes for the typedef statement currently being
X!  * scanned
X   */
X  static int cur_decl_spec_flags;
X  
X! /* pointer to parameter list for the current function definition */
X  static ParameterList *func_params;
X  
X! /* A parser semantic action sets this pointer to the current declarator in
X!  * a function parameter declaration in order to catch any comments following
X!  * the parameter declaration on the same line.  If the lexer scans a comment
X!  * and <cur_declarator> is not NULL, then the comment is attached to the
X!  * declarator.  To ignore subsequent comments, the lexer sets this to NULL
X!  * after scanning a comment or end of line.
X!  */
X  static Declarator *cur_declarator;
X  
X***************
X*** 80,88 ****
X  static char buf[MAX_TEXT_SIZE];
X  
X! /* Table of typedef names */
X  static SymbolTable *typedef_names;
X  
X! /* Table of type qualifiers */
X  static SymbolTable *type_qualifiers;
X  %}
X  %%
X--- 89,114 ----
X  static char buf[MAX_TEXT_SIZE];
X  
X! /* table of typedef names */
X  static SymbolTable *typedef_names;
X  
X! /* table of type qualifiers */
X  static SymbolTable *type_qualifiers;
X+ 
X+ /* information about the current input file */
X+ typedef struct {
X+     char *base_name;		/* base input file name */
X+     char *file_name;		/* current file name */
X+     FILE *file; 		/* input file */
X+     unsigned line_num;		/* current line number in input file */
X+     FILE *tmp_file;		/* temporary file */
X+     long begin_comment; 	/* tmp file offset after last written ) or ; */
X+     long end_comment;		/* tmp file offset after last comment */
X+     boolean convert;		/* if TRUE, convert function definitions */
X+     boolean changed;		/* TRUE if conversion done in this file */
X+ } IncludeStack;
X+ 
X+ static IncludeStack *cur_file;	/* current input file */
X+ 
X+ extern void yyerror();
X  %}
X  %%
X***************
X*** 120,124 ****
X--- 146,159 ----
X  linkage_specification
X  	: T_EXTERN T_STRING_LITERAL braces
X+ 	{
X+ 	    /* Provide an empty action here so bison will not complain about
X+ 	     * incompatible types in the default action it normally would
X+ 	     * have generated.
X+ 	     */
X+ 	}
X  	| T_EXTERN T_STRING_LITERAL declaration
X+ 	{
X+ 	    /* empty */
X+ 	}
X  	;
X  
X***************
X*** 130,134 ****
X  	| decl_specifiers init_declarator_list ';'
X  	{
X- 	    check_untagged(&$1);
X  	    if (func_params != NULL) {
X  		set_param_types(func_params, &$1, &$2);
X--- 165,168 ----
X***************
X*** 227,230 ****
X--- 261,265 ----
X  opt_declaration_list
X  	: /* empty */
X+ 	| T_VA_DCL
X  	| declaration_list
X  	;
X***************
X*** 372,376 ****
X  		func_style == FUNC_TRADITIONAL && cur_file->convert) {
X  		gen_func_declarator($1);
X! 		fputs(yytext, cur_file->tmp_file);
X  	    }
X  	    cur_declarator = $$;
X--- 407,411 ----
X  		func_style == FUNC_TRADITIONAL && cur_file->convert) {
X  		gen_func_declarator($1);
X! 		fputs(cur_text(), cur_file->tmp_file);
X  	    }
X  	    cur_declarator = $$;
X***************
X*** 417,420 ****
X--- 452,456 ----
X  	    $$->text = xstrdup(buf);
X  	    $$->begin = $1.begin;
X+ 	    $$->pointer = TRUE;
X  	}
X  	| direct_declarator
X***************
X*** 507,515 ****
X  	: parameter_declaration
X  	{
X! 	    new_param_list(&$$, &$1);
X  	}
X  	| parameter_list ',' parameter_declaration
X  	{
X! 	    add_param_list(&$$, &$1, &$3);
X  	}
X  	;
X--- 543,551 ----
X  	: parameter_declaration
X  	{
X! 	    new_param_list(&$$, $1);
X  	}
X  	| parameter_list ',' parameter_declaration
X  	{
X! 	    add_param_list(&$$, &$1, $3);
X  	}
X  	;
X***************
X*** 519,523 ****
X  	{
X  	    check_untagged(&$1);
X! 	    new_parameter(&$$, &$1, $2);
X  	}
X  	| decl_specifiers abs_declarator
X--- 555,559 ----
X  	{
X  	    check_untagged(&$1);
X! 	    $$ = new_parameter(&$1, $2);
X  	}
X  	| decl_specifiers abs_declarator
X***************
X*** 524,528 ****
X  	{
X  	    check_untagged(&$1);
X! 	    new_parameter(&$$, &$1, $2);
X  	}
X  	| decl_specifiers
X--- 560,564 ----
X  	{
X  	    check_untagged(&$1);
X! 	    $$ = new_parameter(&$1, $2);
X  	}
X  	| decl_specifiers
X***************
X*** 529,533 ****
X  	{
X  	    check_untagged(&$1);
X! 	    new_parameter(&$$, &$1, NULL);
X  	}
X  	;
X--- 565,569 ----
X  	{
X  	    check_untagged(&$1);
X! 	    $$ = new_parameter(&$1, NULL);
X  	}
X  	;
X***************
X*** 628,631 ****
X--- 664,668 ----
X  
X  %%
X+ 
X  #ifdef MSDOS
X  #include "lex_yy.c"
X***************
X*** 650,659 ****
X  {
X      static char *keywords[] = {
X! 	"const", "volatile",
X  #ifdef MSDOS
X  	"_cdecl", "_export", "_far", "_fastcall", "_fortran", "_huge",
X  	"_interrupt", "_loadds", "_near", "_pascal", "_saveregs", "_segment",
X  	"_cs", "_ds", "_es", "_ss", "_seg",
X! 	"cdecl", "far", "huge", "interrupt", "near", "pascal",
X  #endif
X      };
X--- 687,700 ----
X  {
X      static char *keywords[] = {
X! 	"const", "volatile", "interrupt",
X  #ifdef MSDOS
X+ 	"cdecl", "far", "huge", "near", "pascal",
X  	"_cdecl", "_export", "_far", "_fastcall", "_fortran", "_huge",
X  	"_interrupt", "_loadds", "_near", "_pascal", "_saveregs", "_segment",
X  	"_cs", "_ds", "_es", "_ss", "_seg",
X! 	"__cdecl", "__export", "__far", "__fastcall", "__fortran", "__huge",
X! 	"__inline", "__interrupt", "__loadds", "__near", "__pascal",
X! 	"__saveregs", "__segment", "__stdcall", "__syscall",
X! 	"__cs", "__ds", "__es", "__ss", "__seg",
X  #endif
X      };
Xdiff  -c2 old/lex.l new/lex.l
X*** old/lex.l	Wed Jun 10 21:03:02 1992
X--- new/lex.l	Sat Nov 28 23:54:16 1992
X***************
X*** 1,4 ****
X  %{
X! /* $Id: lex.l 3.7 92/06/10 20:56:04 cthuang Exp $
X   *
X   * Lexical analyzer for C function prototype generator
X--- 1,4 ----
X  %{
X! /* $Id: lex.l 3.8 1992/11/29 04:54:14 cthuang Exp $
X   *
X   * Lexical analyzer for C function prototype generator
X***************
X*** 8,32 ****
X  static int ly_count;	/* number of occurances of %% */
X  
X- /* information about the current input file */
X- typedef struct {
X-     char *base_name;		/* base input file name */
X-     char *file_name;		/* current file name */
X-     FILE *file; 		/* input file */
X-     unsigned line_num;		/* current line number in input file */
X-     FILE *tmp_file;		/* temporary file */
X-     long begin_comment; 	/* tmp file offset after last written ) or ; */
X-     long end_comment;		/* tmp file offset after last comment */
X-     boolean convert;		/* if TRUE, convert function definitions */
X-     boolean changed;		/* TRUE if conversion done in this file */
X  #ifdef FLEX_SCANNER
X!     YY_BUFFER_STATE buffer;	/* flex scanner state */
X  #endif
X- } IncludeStack;
X  
X  static int inc_depth;				/* include nesting level */
X  static IncludeStack inc_stack[MAX_INC_DEPTH];	/* stack of included files */
X- static IncludeStack *cur_file;			/* current file */
X  static SymbolTable *included_files;		/* files already included */
X  
X  static void save_text();
X  static void save_text_offset();
X--- 8,21 ----
X  static int ly_count;	/* number of occurances of %% */
X  
X  #ifdef FLEX_SCANNER
X! /* flex scanner state */
X! static YY_BUFFER_STATE buffer_stack[MAX_INC_DEPTH];
X  #endif
X  
X  static int inc_depth;				/* include nesting level */
X  static IncludeStack inc_stack[MAX_INC_DEPTH];	/* stack of included files */
X  static SymbolTable *included_files;		/* files already included */
X  
X+ static void update_line_num();
X  static void save_text();
X  static void save_text_offset();
X***************
X*** 35,42 ****
X  static void do_include();
X  
X  #ifdef yywrap
X  #undef yywrap
X  #endif
X- static int yywrap();
X  %}
X  
X--- 24,31 ----
X  static void do_include();
X  
X+ extern void yyerror();
X  #ifdef yywrap
X  #undef yywrap
X  #endif
X  %}
X  
X***************
X*** 45,49 ****
X  DIGIT		[0-9]
X  ID		{LETTER}({LETTER}|{DIGIT})*
X! STRING		\"(\\\"|[^"\n])*\"
X  QUOTED		({STRING}|\'(\\\'|[^'\n])*\'|\\.)
X  
X--- 34,38 ----
X  DIGIT		[0-9]
X  ID		{LETTER}({LETTER}|{DIGIT})*
X! STRING		\"(\\\"|[^"])*\"
X  QUOTED		({STRING}|\'(\\\'|[^'\n])*\'|\\.)
X  
X***************
X*** 59,66 ****
X  <LEXYACC>^"%%"		{ save_text(); if (++ly_count >= 2) BEGIN INITIAL; }
X  <LEXYACC>^"%{"		{ save_text(); BEGIN INITIAL; }
X! <LEXYACC>{QUOTED}|.	save_text();
X  <INITIAL>^"%}"		{ save_text(); BEGIN LEXYACC; }
X  
X  <INITIAL>#{WS}* 	{ save_text(); BEGIN CPP1; }
X  
X  <CPP1>define{WS}+{ID}	{
X--- 48,57 ----
X  <LEXYACC>^"%%"		{ save_text(); if (++ly_count >= 2) BEGIN INITIAL; }
X  <LEXYACC>^"%{"		{ save_text(); BEGIN INITIAL; }
X! <LEXYACC>{QUOTED}	{ save_text(); update_line_num(); }
X! <LEXYACC>.		save_text();
X  <INITIAL>^"%}"		{ save_text(); BEGIN LEXYACC; }
X  
X  <INITIAL>#{WS}* 	{ save_text(); BEGIN CPP1; }
X+ <INITIAL>"??="{WS}* 	{ save_text(); BEGIN CPP1; }
X  
X  <CPP1>define{WS}+{ID}	{
X***************
X*** 125,129 ****
X  			}
X  <INITIAL>"..."		{ save_text(); return T_ELLIPSIS; }
X! <INITIAL>{STRING}	{ save_text(); return T_STRING_LITERAL; }
X  
X  <INITIAL>asm		{ save_text(); BEGIN ASM; return T_ASM; }
X--- 116,124 ----
X  			}
X  <INITIAL>"..."		{ save_text(); return T_ELLIPSIS; }
X! <INITIAL>{STRING}	{
X! 			    save_text();
X! 			    update_line_num();
X! 			    return T_STRING_LITERAL;
X! 			}
X  
X  <INITIAL>asm		{ save_text(); BEGIN ASM; return T_ASM; }
X***************
X*** 130,136 ****
X  <ASM>"("		save_text();
X  <ASM>")"		{ save_text(); BEGIN INITIAL; return T_ASMARG; }
X! <ASM>{QUOTED}|. 	save_text();
X  
X! <INITIAL>_based[^(]*\([^)]*\)	{ save_text_offset(); return T_TYPE_QUALIFIER; }
X  
X  <INITIAL>auto		{ save_text_offset(); return T_AUTO; }
X--- 125,132 ----
X  <ASM>"("		save_text();
X  <ASM>")"		{ save_text(); BEGIN INITIAL; return T_ASMARG; }
X! <ASM>{QUOTED} 		{ save_text(); update_line_num(); }
X! <ASM>. 			save_text();
X  
X! <INITIAL>__?based[^(]*\([^)]*\)	{ save_text_offset(); return T_TYPE_QUALIFIER; }
X  
X  <INITIAL>auto		{ save_text_offset(); return T_AUTO; }
X***************
X*** 152,155 ****
X--- 148,152 ----
X  <INITIAL>struct 	{ save_text_offset(); return T_STRUCT; }
X  <INITIAL>union		{ save_text_offset(); return T_UNION; }
X+ <INITIAL>va_dcl		{ save_text_offset(); return T_VA_DCL; }
X  
X  <INITIAL>{ID}		{
X***************
X*** 167,177 ****
X  			     * containing a ] appears between the brackets.
X  			     */
X- 			    int i;
X- 
X  			    save_text_offset();
X! 			    for (i = 0; i < yyleng; ++i) {
X! 				if (yytext[i] == '\n')
X! 				    cur_file->line_num++;
X! 			    }
X  			    return T_BRACKETS;
X  			}
X--- 164,174 ----
X  			     * containing a ] appears between the brackets.
X  			     */
X  			    save_text_offset();
X! 			    update_line_num();
X! 			    return T_BRACKETS;
X! 			}
X! <INITIAL>"??("[^?]*"??)"	{
X! 			    save_text_offset();
X! 			    update_line_num();
X  			    return T_BRACKETS;
X  			}
X***************
X*** 184,188 ****
X  			    return T_INITIALIZER;
X  			}
X! <INIT1>{QUOTED}|.	save_text();
X  
X  <INIT2>"{"		{ save_text(); ++curly; }
X--- 181,186 ----
X  			    return T_INITIALIZER;
X  			}
X! <INIT1>{QUOTED}		{ save_text(); update_line_num(); }
X! <INIT1>.		save_text();
X  
X  <INIT2>"{"		{ save_text(); ++curly; }
X***************
X*** 194,198 ****
X  			    }
X  			}
X! <INIT2>{QUOTED}|.	save_text();
X  
X  <INITIAL>"{"		{
X--- 192,197 ----
X  			    }
X  			}
X! <INIT2>{QUOTED}		{ save_text(); update_line_num(); }
X! <INIT2>.		save_text();
X  
X  <INITIAL>"{"		{
X***************
X*** 210,214 ****
X  			    }
X  			}
X! <CURLY>{QUOTED}|.	save_text();
X  
X  [ \t\f]+		save_text();
X--- 209,214 ----
X  			    }
X  			}
X! <CURLY>{QUOTED}		{ save_text(); update_line_num(); }
X! <CURLY>.		save_text();
X  
X  [ \t\f]+		save_text();
X***************
X*** 220,223 ****
X--- 220,236 ----
X  %%
X  
X+ /* If the matched text contains any new line characters, then update the
X+  * current line number.
X+  */
X+ static void
X+ update_line_num ()
X+ {
X+     char *p = yytext;
X+     while (*p != '\0') {
X+ 	if (*p++ == '\n')
X+ 	    cur_file->line_num++;
X+     }
X+ }
X+ 
X  /* Save the matched text in the temporary file.
X   */
X***************
X*** 277,281 ****
X  }
X  
X! /* Scan rest of preprocessor statement.
X   */
X  static void
X--- 290,294 ----
X  }
X  
X! /* Scan rest of preprocessor directive.
X   */
X  static void
X***************
X*** 282,286 ****
X  get_cpp_directive ()
X  {
X!     int c, lastc = '\0';
X  
X      while ((c = input()) != 0) {
X--- 295,301 ----
X  get_cpp_directive ()
X  {
X!     char c, lastc[4];
X!     
X!     lastc[0] = lastc[1] = lastc[2] = lastc[3] = '\0';
X  
X      while ((c = input()) != 0) {
X***************
X*** 290,294 ****
X  	case '\n':
X  	    cur_file->line_num++;
X! 	    if (lastc != '\\') {
X  		BEGIN INITIAL;
X  		return;
X--- 305,309 ----
X  	case '\n':
X  	    cur_file->line_num++;
X! 	    if (lastc[2] != '\\' && strcmp(lastc, "??""/") != 0) {
X  		BEGIN INITIAL;
X  		return;
X***************
X*** 296,304 ****
X  	    break;
X  	case '*':
X! 	    if (lastc == '/')
X  		get_comment();
X  	    break;
X  	}
X! 	lastc = c;
X      }
X  }
X--- 311,321 ----
X  	    break;
X  	case '*':
X! 	    if (lastc[2] == '/')
X  		get_comment();
X  	    break;
X  	}
X! 	lastc[0] = lastc[1];
X! 	lastc[1] = lastc[2];
X! 	lastc[2] = c;
X      }
X  }
X***************
X*** 344,347 ****
X--- 361,372 ----
X  }
X  
X+ /* Return the text of the current lexical token.
X+  */
X+ char *
X+ cur_text ()
X+ {
X+     return yytext;
X+ }
X+ 
X  #ifdef NEED_tmpfile
X  /*
X***************
X*** 356,360 ****
X  tmpfile ()
X  {
X!     char name[1024];
X      char *tmpdir;
X      FILE *f;
X--- 381,385 ----
X  tmpfile ()
X  {
X!     char name[MAX_TEXT_SIZE];
X      char *tmpdir;
X      FILE *f;
X***************
X*** 400,405 ****
X  
X  #ifdef FLEX_SCANNER
X!     cur_file->buffer = yy_create_buffer(yyin, YY_BUF_SIZE);
X!     yy_switch_to_buffer(cur_file->buffer);
X  #endif
X  
X--- 425,430 ----
X  
X  #ifdef FLEX_SCANNER
X!     buffer_stack[inc_depth] = yy_create_buffer(yyin, YY_BUF_SIZE);
X!     yy_switch_to_buffer(buffer_stack[inc_depth]);
X  #endif
X  
X***************
X*** 408,412 ****
X  	cur_file->tmp_file = tmpfile();
X  	if (cur_file->tmp_file == NULL) {
X! 	    fprintf(stderr, "%s: cannot create temporary file %s\n", progname);
X  	    cur_file->convert = FALSE;
X  	}
X--- 433,437 ----
X  	cur_file->tmp_file = tmpfile();
X  	if (cur_file->tmp_file == NULL) {
X! 	    fprintf(stderr, "%s: cannot create temporary file\n", progname);
X  	    cur_file->convert = FALSE;
X  	}
X***************
X*** 449,456 ****
X  
X      if (cur_file->convert) {
X! 	if (cur_file->changed) {
X! 	    if (yyin == stdin) {
X! 		put_file(stdout);
X! 	    } else if ((outf = fopen(cur_file->base_name, "w")) != NULL) {
X  		put_file(outf);
X  		fclose(outf);
X--- 474,481 ----
X  
X      if (cur_file->convert) {
X! 	if (yyin == stdin) {
X! 	    put_file(stdout);
X! 	} else if (cur_file->changed) {
X! 	    if ((outf = fopen(cur_file->base_name, "w")) != NULL) {
X  		put_file(outf);
X  		fclose(outf);
X***************
X*** 457,461 ****
X  	    } else {
X  		fprintf(stderr, "%s: cannot create file %s\n", progname,
X! 		    cur_file->base_name);
X  	    }
X  	}
X--- 482,486 ----
X  	    } else {
X  		fprintf(stderr, "%s: cannot create file %s\n", progname,
X! 		 cur_file->base_name);
X  	    }
X  	}
X***************
X*** 475,479 ****
X  
X  #ifdef FLEX_SCANNER
X! 	yy_switch_to_buffer(cur_file->buffer);
X  #endif
X      }
X--- 500,504 ----
X  
X  #ifdef FLEX_SCANNER
X! 	yy_switch_to_buffer(buffer_stack[inc_depth]);
X  #endif
X      }
X***************
X*** 524,528 ****
X   * nested include file.
X   */
X! static int
X  yywrap ()
X  {
X--- 549,553 ----
X   * nested include file.
X   */
X! int
X  yywrap ()
X  {
Xdiff  -c2 old/Makefile.bc new/Makefile.bc
X*** old/Makefile.bc	Wed Jun 10 21:03:02 1992
X--- new/Makefile.bc	Sat Nov 28 23:27:32 1992
X***************
X*** 1,3 ****
X! # $Id: makefile.bc 3.1 92/03/03 10:45:53 cthuang Exp $
X  #
X  # Borland C++ makefile for C prototype generator
X--- 1,3 ----
X! # $Id: Makefile.bc 3.1 1992/03/03 10:45:53 cthuang Exp $
X  #
X  # Borland C++ makefile for C prototype generator
Xdiff  -c2 old/Makefile.msc new/Makefile.msc
X*** old/Makefile.msc	Wed Jun 10 21:03:02 1992
X--- new/Makefile.msc	Sat Nov 28 23:27:36 1992
X***************
X*** 1,3 ****
X! # $Id: makefile.msc 3.3 92/06/10 20:55:56 cthuang Exp $
X  #
X  # Microsoft C makefile for C prototype generator
X--- 1,3 ----
X! # $Id: Makefile.msc 3.4 1992/11/29 04:27:30 cthuang Exp $
X  #
X  # Microsoft C makefile for C prototype generator
X***************
X*** 11,16 ****
X  CC = cl
X  CFLAGS = -AC $(DEFINES)
X! LIBS = \c6\lib\setargv.obj
X! LDFLAGS = /link /noe /stack:4096
X  
X  DIST1 = README CHANGES cproto.man
X--- 11,16 ----
X  CC = cl
X  CFLAGS = -AC $(DEFINES)
X! LIBS = \c7\lib\setargv.obj
X! LDFLAGS = /F 1000
X  
X  DIST1 = README CHANGES cproto.man
Xdiff  -c2 old/Makefile.uni new/Makefile.uni
X*** old/Makefile.uni	Wed Jun 10 21:03:02 1992
X--- new/Makefile.uni	Sat Nov 28 23:27:36 1992
X***************
X*** 1,3 ****
X! # $Id: makefile.uni 3.5 92/06/10 20:56:00 cthuang Exp $
X  #
X  # UNIX makefile for C prototype generator
X--- 1,3 ----
X! # $Id: Makefile.uni 3.5 1992/06/10 20:56:00 cthuang Exp $
X  #
X  # UNIX makefile for C prototype generator
Xdiff  -c2 old/patchlev.h new/patchlev.h
X*** old/patchlev.h	Wed Jun 10 21:03:08 1992
X--- new/patchlev.h	Fri Jun 26 08:27:12 1992
X***************
X*** 1 ****
X! #define PATCHLEVEL 4
X--- 1 ----
X! #define PATCHLEVEL 5
Xdiff  -c2 old/popen.c new/popen.c
X*** old/popen.c	Wed Jun 10 21:03:08 1992
X--- new/popen.c	Sat Nov 28 23:27:52 1992
X***************
X*** 1,3 ****
X! /* $Id: popen.c 3.3 92/06/10 20:56:30 cthuang Exp $
X   *
X   * Imitate a UNIX pipe in MS-DOS.
X--- 1,3 ----
X! /* $Id: popen.c 3.3 1992/06/10 20:56:30 cthuang Exp $
X   *
X   * Imitate a UNIX pipe in MS-DOS.
Xdiff  -c2 old/semantic.c new/semantic.c
X*** old/semantic.c	Wed Jun 10 21:03:08 1992
X--- new/semantic.c	Sat Nov 28 23:27:56 1992
X***************
X*** 1,3 ****
X! /* $Id: semantic.c 3.6 92/06/10 20:56:35 cthuang Exp $
X   *
X   * Semantic actions executed by the parser of the
X--- 1,3 ----
X! /* $Id: semantic.c 3.7 1992/11/29 04:27:49 cthuang Exp $
X   *
X   * Semantic actions executed by the parser of the
X***************
X*** 11,15 ****
X  static Declarator *func_declarator;
X  
X! /* Where the declarator appears */
X  static int where;
X  
X--- 11,18 ----
X  static Declarator *func_declarator;
X  
X! /* Role of the function declarator
X!  * FUNC_PROTO if it is the declarator in a function prototype.
X!  * FUNC_DEF if it is the declarator in a function definition.
X!  */
X  static int where;
X  
X***************
X*** 105,108 ****
X--- 108,112 ----
X      d->head = d;
X      d->func_stack = NULL;
X+     d->pointer = FALSE;
X      return d;
X  }
X***************
X*** 116,120 ****
X      free(d->text);
X      free(d->name);
X!     free_param_list(&(d->params));
X      if (d->func_stack != NULL)
X  	free_declarator(d->func_stack);
X--- 120,124 ----
X      free(d->text);
X      free(d->name);
X!     free_param_list(&d->params);
X      if (d->func_stack != NULL)
X  	free_declarator(d->func_stack);
X***************
X*** 162,175 ****
X  }
X  
X! /* Initialize the parameter structure.
X   */
X! void
X! new_parameter (param, decl_spec, declarator)
X! Parameter *param;		/* parameter to be initialized */
X  DeclSpec *decl_spec;
X  Declarator *declarator;
X  {
X      if (decl_spec == NULL) {
X! 	new_decl_spec(&(param->decl_spec), "", 0L, DS_JUNK);
X      } else {
X  	param->decl_spec = *decl_spec;
X--- 166,181 ----
X  }
X  
X! /* Create a new parameter structure.
X   */
X! Parameter *
X! new_parameter (decl_spec, declarator)
X  DeclSpec *decl_spec;
X  Declarator *declarator;
X  {
X+     Parameter *param;
X+     param = (Parameter *)xmalloc(sizeof(Parameter));
X+ 
X      if (decl_spec == NULL) {
X! 	new_decl_spec(&param->decl_spec, "", 0L, DS_NONE);
X      } else {
X  	param->decl_spec = *decl_spec;
X***************
X*** 182,185 ****
X--- 188,192 ----
X  
X      param->comment = NULL;
X+     return param;
X  }
X  
X***************
X*** 190,197 ****
X  Parameter *param;
X  {
X!     free_decl_spec(&(param->decl_spec));
X      free_declarator(param->declarator);
X      if (param->comment != NULL)
X  	free(param->comment);
X  }
X  
X--- 197,205 ----
X  Parameter *param;
X  {
X!     free_decl_spec(&param->decl_spec);
X      free_declarator(param->declarator);
X      if (param->comment != NULL)
X  	free(param->comment);
X+     free(param);
X  }
X  
X***************
X*** 213,223 ****
X  Parameter *param;
X  {
X!     Parameter *p;
X! 
X!     p = (Parameter *)xmalloc(sizeof(Parameter));
X!     *p = *param;
X!     
X!     param_list->first = param_list->last = p;
X!     p->next = NULL;
X  
X      param_list->begin_comment = param_list->end_comment = 0;
X--- 221,226 ----
X  Parameter *param;
X  {
X!     param_list->first = param_list->last = param;
X!     param->next = NULL;
X  
X      param_list->begin_comment = param_list->end_comment = 0;
X***************
X*** 237,241 ****
X  	next = p->next;
X  	free_parameter(p);
X- 	free(p);
X  	p = next;
X      }
X--- 240,243 ----
X***************
X*** 245,249 ****
X  }
X  
X! /* Add the function parameter declaration to the list.
X   */
X  void
X--- 247,251 ----
X  }
X  
X! /* Add the parameter to the function parameter list.
X   */
X  void
X***************
X*** 252,264 ****
X  Parameter *param;
X  {
X-     Parameter *p;
X- 
X-     p = (Parameter *)xmalloc(sizeof(Parameter));
X-     *p = *param;
X- 
X      to->first = from->first;
X!     from->last->next = p;
X!     to->last = p;
X!     p->next = NULL;
X  }
X  
X--- 254,261 ----
X  Parameter *param;
X  {
X      to->first = from->first;
X!     from->last->next = param;
X!     to->last = param;
X!     param->next = NULL;
X  }
X  
X***************
X*** 285,291 ****
X      Declarator *declarator;
X  
X-     p = (Parameter *)xmalloc(sizeof(Parameter));
X      declarator = new_declarator(name, name, 0L);
X!     new_parameter(p, NULL, declarator);
X  
X      to->first = from->first;
X--- 282,287 ----
X      Declarator *declarator;
X  
X      declarator = new_declarator(name, name, 0L);
X!     p = new_parameter(NULL, declarator);
X  
X      to->first = from->first;
X***************
X*** 387,392 ****
X      p = declarator->params.first;
X      if (is_void_parameter(p)) {
X! 	if (p != NULL || ((where == FUNC_PROTO || where == FUNC_DEF) &&
X! 	 declarator == func_declarator))
X  	    fputs("void", outf);
X      } else {
X--- 383,387 ----
X      p = declarator->params.first;
X      if (is_void_parameter(p)) {
X! 	if (p != NULL)
X  	    fputs("void", outf);
X      } else {
X***************
X*** 578,586 ****
X  DeclSpec *decl_spec;
X  {
X!     if (extern_out && (decl_spec->flags & DS_STATIC) == 0) {
X! 	if (strstr(decl_spec->text, "extern") == NULL) {
X! 	    fputs("extern ", outf);
X! 	}
X!     }
X      fputs(decl_spec->text, outf);
X      fputc(' ', outf);
X--- 573,579 ----
X  DeclSpec *decl_spec;
X  {
X!     if (extern_out && !(decl_spec->flags & DS_STATIC) &&
X!      strstr(decl_spec->text, "extern") == NULL)
X! 	fputs("extern ", outf);
X      fputs(decl_spec->text, outf);
X      fputc(' ', outf);
X***************
X*** 601,604 ****
X--- 594,598 ----
X  	return;
X  
X+     check_untagged(decl_spec);
X      func_declarator = NULL;
X      where = FUNC_OTHER;
X***************
X*** 605,609 ****
X      format = FMT_OTHER;
X      for (d = decl_list->first; d != NULL; d = d->next) {
X! 	if (d->func_def == FUNC_NONE) {
X  	    fputs(fmt[FMT_PROTO].decl_spec_prefix, stdout);
X  	    put_decl_spec(stdout, decl_spec);
X--- 599,603 ----
X      format = FMT_OTHER;
X      for (d = decl_list->first; d != NULL; d = d->next) {
X! 	if (d->func_def == FUNC_NONE || d->head->func_stack->pointer) {
X  	    fputs(fmt[FMT_PROTO].decl_spec_prefix, stdout);
X  	    put_decl_spec(stdout, decl_spec);
X***************
X*** 614,617 ****
X--- 608,644 ----
X  }
X  
X+ /* Generate a prototype for a function that uses varargs by replacing the
X+  * "va_alist" parameter with an empty parameter list.
X+  */
X+ static void
X+ check_varargs (declarator)
X+ Declarator *declarator;
X+ {
X+     Parameter *p;
X+ 
X+     if ((p = declarator->params.first) != NULL && p->next == NULL &&
X+ 	strcmp(p->declarator->name, "va_alist") == 0)
X+     {
X+ 	free_param_list(&declarator->params);
X+ 	declarator->params.first = NULL;
X+     }
X+ }
X+ 
X+ /* If the parameter list is empty, then replace it with "void".
X+  */
X+ static void
X+ check_void_param (declarator)
X+ Declarator *declarator;
X+ {
X+     DeclSpec decl_spec;
X+     Parameter *p;
X+ 
X+     if (declarator->params.first == NULL) {
X+ 	new_decl_spec(&decl_spec, "void", 0L, DS_NONE);
X+ 	p = new_parameter(&decl_spec, NULL);
X+ 	new_param_list(&declarator->params, p);
X+     }
X+ }
X+ 
X  /* If a parameter name appears in the parameter list of a traditional style
X   * function definition but is not declared in the parameter declarations,
X***************
X*** 646,649 ****
X--- 673,678 ----
X  
X      func_declarator = declarator->head;
X+     check_void_param(func_declarator);
X+     check_varargs(func_declarator);
X      set_param_decl_spec(func_declarator);
X  
X***************
X*** 673,676 ****
X--- 702,728 ----
X  }
X  
X+ /* Output parameter declarations for old style function definition.
X+  */
X+ static void
X+ put_param_decl (declarator)
X+ Declarator *declarator;
X+ {
X+     Parameter *p;
X+ 
X+     p = declarator->params.first;
X+     if (!is_void_parameter(p)) {
X+ 	fputc('\n', cur_tmp_file());
X+ 	put_parameter(cur_tmp_file(), p);
X+ 	fputc(';', cur_tmp_file());
X+ 	p = p->next;
X+ 	while (p != NULL && strcmp(p->declarator->text, "...") != 0) {
X+ 	    fputc('\n', cur_tmp_file());
X+ 	    put_parameter(cur_tmp_file(), p);
X+ 	    fputc(';', cur_tmp_file());
X+ 	    p = p->next;
X+ 	}
X+     }
X+ }
X+ 
X  /* Generate a function definition head.
X   */
X***************
X*** 685,690 ****
X      int comment_len, n;
X  
X!     /* Return if the function is already defined in the desired style. */
X!     if (declarator->func_def == func_style)
X  	return;
X  
X--- 737,743 ----
X      int comment_len, n;
X  
X!     /* Do nothing if the function is already defined in the desired style. */
X!     func_declarator = declarator->head;
X!     if (func_declarator->func_def == func_style)
X  	return;
X  
X***************
X*** 698,706 ****
X      fread(comment, sizeof(char), comment_len, cur_tmp_file());
X  
X-     func_declarator = declarator->head;
X      format = FMT_FUNC;
X! 
X!     /* Save the text before the parameter declarations. */
X!     if (func_style == FUNC_ANSI) {
X  	params = &func_declarator->params;
X  	n = (int)(params->end_comment - params->begin_comment);
X--- 751,757 ----
X      fread(comment, sizeof(char), comment_len, cur_tmp_file());
X  
X      format = FMT_FUNC;
X!     if (func_declarator->func_def == FUNC_TRADITIONAL) {
X! 	/* Save the text before the parameter declarations. */
X  	params = &func_declarator->params;
X  	n = (int)(params->end_comment - params->begin_comment);
X***************
X*** 712,729 ****
X  	    format = FMT_FUNC_COMMENT;
X  	}
X-     }
X  
X!     /* Get the parameter comments. */
X!     for (p = func_declarator->params.first; p != NULL; p = p->next) {
X! 	n = (int)(p->declarator->end_comment - p->declarator->begin_comment);
X! 	if (n > 0) {
X! 	    p->comment = xmalloc(n+1);
X! 	    fseek(cur_tmp_file(), p->declarator->begin_comment, 0);
X! 	    fread(p->comment, sizeof(char), n, cur_tmp_file());
X! 	    p->comment[n] = '\0';
X! 	    format = FMT_FUNC_COMMENT;
X  	}
X      }
X  
X      set_param_decl_spec(func_declarator);
X  
X--- 763,781 ----
X  	    format = FMT_FUNC_COMMENT;
X  	}
X  
X! 	/* Get the parameter comments. */
X! 	for (p = func_declarator->params.first; p != NULL; p = p->next) {
X! 	    n = (int)(p->declarator->end_comment - p->declarator->begin_comment);
X! 	    if (n > 0) {
X! 	        p->comment = xmalloc(n+1);
X! 	        fseek(cur_tmp_file(), p->declarator->begin_comment, 0);
X! 	        fread(p->comment, sizeof(char), n, cur_tmp_file());
X! 	        p->comment[n] = '\0';
X! 	        format = FMT_FUNC_COMMENT;
X! 	    }
X  	}
X      }
X  
X+     check_void_param(func_declarator);
X      set_param_decl_spec(func_declarator);
X  
X***************
X*** 731,760 ****
X       * and overwrite it with the converted function head.
X       */
X      fseek(cur_tmp_file(), decl_spec->begin, 0);
X  
X!     /* Output declarator specifiers. */
X!     fputs(fmt[format].decl_spec_prefix, cur_tmp_file());
X!     fputs(decl_spec->text, cur_tmp_file());
X!     fputc(' ', cur_tmp_file());
X! 
X!     /* Output function declarator. */
X!     where = FUNC_DEF;
X!     put_func_declarator(cur_tmp_file(), declarator);
X  
X!     if (func_style == FUNC_TRADITIONAL) {
X! 	/* Output traditional style parameter declarations. */
X! 	p = func_declarator->params.first;
X! 	if (!is_void_parameter(p)) {
X  	    fputc('\n', cur_tmp_file());
X! 	    put_parameter(cur_tmp_file(), p);
X! 	    fputc(';', cur_tmp_file());
X! 	    p = p->next;
X! 	    while (p != NULL && strcmp(p->declarator->text, "...") != 0) {
X! 		fputc('\n', cur_tmp_file());
X! 		put_parameter(cur_tmp_file(), p);
X! 		fputc(';', cur_tmp_file());
X! 		p = p->next;
X! 	    }
X! 	}
X      }
X  
X--- 783,844 ----
X       * and overwrite it with the converted function head.
X       */
X+     where = FUNC_DEF;
X      fseek(cur_tmp_file(), decl_spec->begin, 0);
X  
X!     if (func_style == FUNC_BOTH) {
X! 	char *cur_func;
X! 	int func_len;
X! 
X! 	/* Save the current function definition head. */
X! 	func_len = (int)(cur_begin_comment() - decl_spec->begin);
X! 	cur_func = xmalloc(func_len);
X! 	fread(cur_func, sizeof(char), func_len, cur_tmp_file());
X! 
X! 	fseek(cur_tmp_file(), decl_spec->begin, 0);
X! 	fprintf(cur_tmp_file(), "%s\n\n", func_directive);
X! 
X! 	/* Output new style function definition head. */
X! 	if (func_declarator->func_def == FUNC_ANSI) {
X! 	    fwrite(cur_func, sizeof(char), func_len, cur_tmp_file());
X! 	} else {
X! 	    fputs(fmt[format].decl_spec_prefix, cur_tmp_file());
X! 	    fputs(decl_spec->text, cur_tmp_file());
X! 	    fputc(' ', cur_tmp_file());
X! 
X! 	    func_style = FUNC_ANSI;
X! 	    put_func_declarator(cur_tmp_file(), declarator);
X! 	}
X! 	fputs("\n#else\n\n", cur_tmp_file());
X! 
X! 	/* Output old style function definition head. */
X! 	if (func_declarator->func_def == FUNC_TRADITIONAL) {
X! 	    fwrite(cur_func, sizeof(char), func_len, cur_tmp_file());
X! 	} else {
X! 	    fputs(fmt[format].decl_spec_prefix, cur_tmp_file());
X! 	    fputs(decl_spec->text, cur_tmp_file());
X! 	    fputc(' ', cur_tmp_file());
X! 
X!  	    format = FMT_FUNC;
X! 	    func_style = FUNC_TRADITIONAL;
X! 	    put_func_declarator(cur_tmp_file(), declarator);
X! 	    put_param_decl(func_declarator);
X! 	}
X  
X! 	fputs("\n#endif", cur_tmp_file());
X! 	if (*comment != '\n')
X  	    fputc('\n', cur_tmp_file());
X! 	func_style = FUNC_BOTH;
X! 	free(cur_func);
X! 
X!     } else {
X! 	/* Output declarator specifiers. */
X! 	fputs(fmt[format].decl_spec_prefix, cur_tmp_file());
X! 	fputs(decl_spec->text, cur_tmp_file());
X! 	fputc(' ', cur_tmp_file());
X! 
X! 	/* Output function declarator. */
X! 	put_func_declarator(cur_tmp_file(), declarator);
X! 	if (func_style == FUNC_TRADITIONAL)
X! 	    put_param_decl(func_declarator);
X      }
X  
Xdiff  -c2 old/semantic.h new/semantic.h
X*** old/semantic.h	Wed Jun 10 21:03:08 1992
X--- new/semantic.h	Sat Nov 28 23:27:48 1992
X***************
X*** 1,3 ****
X! /* $Id: semantic.h 3.3 92/06/10 20:56:19 cthuang Exp $
X   *
X   * Declarations of semantic action routines
X--- 1,3 ----
X! /* $Id: semantic.h 3.4 1992/11/29 04:27:30 cthuang Exp $
X   *
X   * Declarations of semantic action routines
X***************
X*** 22,27 ****
X  extern void add_decl_list(/*
X      DeclaratorList *to, DeclaratorList *from, Declarator *declarator*/);
X! extern void new_parameter(/*
X!     Parameter *param, DeclSpec *decl_spec, Declarator *declarator*/);
X  extern void free_parameter(/*
X      Parameter *param*/);
X--- 22,27 ----
X  extern void add_decl_list(/*
X      DeclaratorList *to, DeclaratorList *from, Declarator *declarator*/);
X! extern Parameter *new_parameter(/*
X!     DeclSpec *decl_spec, Declarator *declarator*/);
X  extern void free_parameter(/*
X      Parameter *param*/);
Xdiff  -c2 old/strstr.c new/strstr.c
X*** old/strstr.c	Wed Jun 10 21:03:08 1992
X--- new/strstr.c	Sat Nov 28 23:27:58 1992
X***************
X*** 1,3 ****
X! /* $Id: strstr.c 3.2 92/03/06 00:51:10 cthuang Exp $
X   *
X   * Simple implementation of the ANSI strstr() function
X--- 1,3 ----
X! /* $Id: strstr.c 3.3 1992/11/29 04:27:49 cthuang Exp $
X   *
X   * Simple implementation of the ANSI strstr() function
X***************
X*** 17,21 ****
X      int keylen;
X  
X!     keylen = strlen(key);
X      s = strchr(src, *key);
X      while (s != NULL) {
X--- 17,23 ----
X      int keylen;
X  
X!     if ((keylen = strlen(key)) == 0)
X! 	return src;
X! 
X      s = strchr(src, *key);
X      while (s != NULL) {
Xdiff  -c2 old/symbol.c new/symbol.c
X*** old/symbol.c	Wed Jun 10 21:03:08 1992
X--- new/symbol.c	Sat Nov 28 23:28:00 1992
X***************
X*** 1,3 ****
X! /* $Id: symbol.c 3.1 92/03/03 10:43:52 cthuang Exp $
X   *
X   * Implements a symbol table abstract data type.
X--- 1,3 ----
X! /* $Id: symbol.c 3.2 1992/11/29 04:27:49 cthuang Exp $
X   *
X   * Implements a symbol table abstract data type.
X***************
X*** 95,99 ****
X  /* If the symbol <name> does not already exist in symbol table <symtab>,
X   * then add the symbol to the symbol table.
X!  * Return a pointer to the symbol or NULL on an error.
X   */
X  Symbol *
X--- 95,99 ----
X  /* If the symbol <name> does not already exist in symbol table <symtab>,
X   * then add the symbol to the symbol table.
X!  * Return a pointer to the symbol.
X   */
X  Symbol *
X***************
X*** 107,117 ****
X  
X      if ((sym = find_symbol(symtab, name)) == NULL) {
X! 	if ((sym = (Symbol *)xmalloc(sizeof(Symbol))) != NULL) {
X! 	    sym->name = xstrdup(name);
X! 	    sym->flags = flags;
X! 	    i = hash(name);
X! 	    sym->next = symtab->bucket[i];
X! 	    symtab->bucket[i] = sym;
X! 	}
X      }
X      return sym;
X--- 107,116 ----
X  
X      if ((sym = find_symbol(symtab, name)) == NULL) {
X! 	sym = (Symbol *)xmalloc(sizeof(Symbol));
X! 	sym->name = xstrdup(name);
X! 	sym->flags = flags;
X! 	i = hash(name);
X! 	sym->next = symtab->bucket[i];
X! 	symtab->bucket[i] = sym;
X      }
X      return sym;
Xdiff  -c2 old/symbol.h new/symbol.h
X*** old/symbol.h	Wed Jun 10 21:03:08 1992
X--- new/symbol.h	Sat Nov 28 23:27:48 1992
X***************
X*** 1,3 ****
X! /* $Id: symbol.h 3.3 92/03/14 11:57:48 cthuang Exp $
X   *
X   * A symbol table is a collection of string identifiers stored in a
X--- 1,3 ----
X! /* $Id: symbol.h 3.3 1992/03/14 11:57:48 cthuang Exp $
X   *
X   * A symbol table is a collection of string identifiers stored in a
END_OF_patch5
if test 49845 -ne `wc -c <patch5`; then
    echo shar: \"patch5\" unpacked with wrong size!
fi
# end of overwriting check
fi
echo shar: End of shell archive.
exit 0

-- 
Chin Huang  cthuang%zerosan@canrem.com  chin.huang@canrem.com

exit 0 # Just in case...
