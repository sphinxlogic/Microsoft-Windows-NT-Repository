Newsgroups: comp.sources.misc
From: jpeg-info@uunet.uu.net (Independent JPEG Group)
Subject:  v34i072:  jpeg - JPEG image compression, Part18/18
Message-ID: <1992Dec17.165222.7031@sparky.imd.sterling.com>
X-Md4-Signature: 4368b6409751dccf6a35226503cd26b5
Date: Thu, 17 Dec 1992 16:52:22 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jpeg-info@uunet.uu.net (Independent JPEG Group)
Posting-number: Volume 34, Issue 72
Archive-name: jpeg/part18
Environment: UNIX, VMS, MS-DOS, Mac, Amiga, Atari, Cray
Supersedes: jpeg: Volume 29, Issue 1-18

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  CHANGELOG djpeg.1 jbsmooth.c jcmaster.c jerror.c
#   jmemansi.c jmemnobs.c jutils.c makcjpeg.st makdjpeg.st
#   makefile.vms makljpeg.st
# Wrapped by kent@sparky on Wed Dec 16 20:52:32 1992
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 18 (of 18)."'
if test -f 'CHANGELOG' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CHANGELOG'\"
else
  echo shar: Extracting \"'CHANGELOG'\" \(5002 characters\)
  sed "s/^X//" >'CHANGELOG' <<'END_OF_FILE'
XCHANGELOG for Independent JPEG Group's JPEG software
X
XVersion 4  10-Dec-92
X--------------------
X
XRevised user interface: switches now use names instead of single letters.
X(Old switch letters are acceptable abbreviations of new switch names, EXCEPT
Xfor djpeg's old -g, -D, -1 switches.)  cjpeg has several new switches.
X
XProvision for smoothing the input image added to cjpeg.  This helps a lot with
Xconverting dithered GIFs to JPEG.
X
XDecoder upsampling now uses interpolation instead of pixel replication; this
Ximproves rendering of sharp colored edges.
X
XThe decompressor will now try to continue after detecting an error in the
Xcompressed data, instead of just aborting.  If the input file has restart
Xmarkers, full synchronization will usually be regained at the next undamaged
Xrestart marker.  (But you're still out of luck if any of the header markers
Xare corrupt.)
X
XSubstantial improvements in speed; DCT accuracy improved too.
X
XNumerous minor changes to improve portability.  egetopt.c, which was by far
Xthe worst portability problem, is gone altogether.
X
XA few bugfixes, sigh (mostly affecting DOS implementations only).
XBugfix: on DOS machines, cjpeg -o would fail on grayscale input files.
XBugfix: one-pass quantization to more than 64 color levels would fail on
X16-bit-int machines.  This could only happen with quantized grayscale output.
X
XA couple of changes affect code that calls the JPEG subroutine library:
X
X1. The parameter struct tag names are now capitalized (Compress_info_struct,
XCompress_methods_struct, Decompress_info_struct, Decompress_methods_struct,
Xand External_methods_struct).  This makes it easier to live with brain-damaged
Xcompilers with short identifier lengths.  (All identifiers used in the JPEG
Xcode are now unique within the first 16 characters.)
X
X2. If you are not calling jselerror(), you need to initialize three new fields
Xin the emethods structure, typically as follows:
X    e_methods.num_warnings = 0; /* no warnings emitted yet */
X    e_methods.first_warning_level = 0; /* display first corrupt-data warning */
X    e_methods.more_warning_level = 3; /* but suppress additional ones */
XThese fields control handling of corrupt-data warnings.
X
X
XVersion 3  17-Mar-92
X--------------------
X
XMemory manager is finally capable of swapping to temp files.  There are
Xseparate versions of jmemsys.c for no temp files (same behavior as older
Xversions), simple temp files with or without tmpfile(), and a DOS-specific
Xversion (including special code for EMS and XMS).  This is probably much more
Xsystem-dependent than any of the older code; some bugs may surface here.
X
XHooks added for user interface to install progress monitoring routine
X(percent-done bar, etc).  See comments with dummy progress_monitor
Xroutines in jcdeflts.c, jddeflts.c.
X
XTwo-pass color quantization (finally!).  This is now the default method when
Xquantizing; say '-1' to djpeg for quick-and-ugly 1-pass method.  There is
Xa test file for checking 2-pass quantization and GIF output.
X
XFixed bug in jcopy_block_row that broke cjpeg -o option and djpeg -b option
Xon MSDOS machines.
X
XMiscellaneous small speedups; notably, DCT computation rearranged so that
XGCC "inline" feature is no longer needed for good code quality.
X
XFile config.c renamed ckconfig.c to avoid name conflict with /etc/config
Xon Unix systems.
X
XAdded example.c to document usage of JPEG subroutines better.
X
XMemory manager now knows how to release all storage during error exit ---
Xavoids memory leak when using JPEG as subroutines.  This implies a couple
Xsmall changes to the subroutine interface: the old free_defaults subroutines
Xare no longer needed, but if you have a replacement error_exit method then it
Xmust call the new free_all method.  Also, jselvirtmem renamed to jselmemmgr.
X
XCode for reading Targa files with 32-bit pixels was incorrect.
X
XColorspace conversion slightly faster and more accurate; because of
Xthis, old "test" files will no longer match bit-for-bit.
X
X
XVersion 2  13-Dec-91
X--------------------
X
XDocumentation improved a little --- there are man pages now.
XInstallation instructions moved from README to a separate file SETUP.
X
XNew program config.c is provided to help you get the configuration options
Xright.  This should make installation a lot more foolproof.
X
XSense of djpeg -D switch reversed: dithering is now ON by default.
X
XRLE image file support added (thanks to Mike Lijewski).
X
XTarga image file support added (thanks to Lee Crocker).
X
XPPM input now accepts all PPM and PGM files.
X
XBug fix: on machines where 'int' is 16 bits, high-Q-setting JPEG files
Xwere not decoded correctly.
X
XNumerous changes to improve portability.  There should be few or no compiler
Xwarnings now.
X
XMakefiles cleaned up; defaults now appropriate for production use rather than
Xdebugging.
X
XSubroutine interface cleaned up.  If you wrote code based on version 1's
Xjcmain/jdmain, you'll need to change it, but it should get a little shorter
Xand simpler.
X
X
XVersion 1   7-Oct-91
X--------------------
X
XInitial public release.
END_OF_FILE
  if test 5002 -ne `wc -c <'CHANGELOG'`; then
    echo shar: \"'CHANGELOG'\" unpacked with wrong size!
  fi
  # end of 'CHANGELOG'
fi
if test -f 'djpeg.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'djpeg.1'\"
else
  echo shar: Extracting \"'djpeg.1'\" \(4520 characters\)
  sed "s/^X//" >'djpeg.1' <<'END_OF_FILE'
X.TH DJPEG 1 "2 August 1992"
X.SH NAME
Xdjpeg \- decompress a JPEG file to an image file
X.SH SYNOPSIS
X.B djpeg
X[
X.BI \-colors " N"
X]
X[
X.B \-gif
X]
X[
X.B \-pnm
X]
X[
X.B \-rle
X]
X[
X.B \-targa
X]
X[
X.B \-blocksmooth
X]
X[
X.B \-grayscale
X]
X[
X.BI \-maxmemory " N"
X]
X[
X.B \-nodither
X]
X[
X.B \-onepass
X]
X[
X.B \-verbose
X]
X[
X.B \-debug
X]
X[
X.I filename
X]
X.LP
X.SH DESCRIPTION
X.LP
X.B djpeg
Xdecompresses the named JPEG file, or the standard input if no file is named,
Xand produces an image file on the standard output.  PBMPLUS (PPM/PGM), GIF,
XTarga, or RLE (Utah Raster Toolkit) output format can be selected.  (RLE is
Xsupported only if the URT library is available.)
X.SH OPTIONS
XAll switch names may be abbreviated; for example,
X.B \-grayscale
Xmay be written
X.B \-gray
Xor
X.BR \-gr .
XMost of the "basic" switches can be abbreviated to as little as one letter.
XUpper and lower case are equivalent (thus
X.B \-GIF
Xis the same as
X.BR \-gif ).
XBritish spellings are also accepted (e.g.,
X.BR \-greyscale ),
Xthough for brevity these are not mentioned below.
X.PP
XThe basic switches are:
X.TP
X.BI \-colors " N"
XReduce image to at most N colors.  This reduces the number of colors used in
Xthe output image, so that it can be displayed on a colormapped display or
Xstored in a colormapped file format.  For example, if you have an 8-bit
Xdisplay, you'd need to reduce to 256 or fewer colors.
X.TP
X.BI \-quantize " N"
XSame as
X.BR \-colors .
X.B \-colors
Xis the recommended name,
X.B \-quantize
Xis provided only for backwards compatibility.
X.TP
X.B \-gif
XSelect GIF output format.  Since GIF does not support more than 256 colors,
X.B \-colors 256
Xis assumed (unless you specify a smaller number of colors).
X.TP
X.B \-pnm
XSelect PBMPLUS (PPM/PGM) output format (this is the default format).
XPGM is emitted if the JPEG file is gray-scale or if
X.B \-grayscale
Xis specified; otherwise PPM is emitted.
X.TP
X.B \-rle
XSelect RLE output format.  (Requires URT library.)
X.TP
X.B \-targa
XSelect Targa output format.  Gray-scale format is emitted if the JPEG file is
Xgray-scale or if
X.B \-grayscale
Xis specified; otherwise, colormapped format is emitted if
X.B \-colors
Xis specified; otherwise, 24-bit full-color format is emitted.
X.PP
XSwitches for advanced users:
X.TP
X.B \-blocksmooth
XPerform cross-block smoothing.  This is quite memory-intensive and only seems
Xto improve the image at very low quality settings (\fB\-quality\fR 10 to 20 or
Xso).  At normal quality settings it may make the image worse.
X.TP
X.B \-grayscale
XForce gray-scale output even if JPEG file is color.
XUseful for viewing on monochrome displays.
X.TP
X.BI \-maxmemory " N"
XSet limit for amount of memory to use in processing large images.  Value is
Xin thousands of bytes, or millions of bytes if "M" is attached to the
Xnumber.  For example,
X.B \-max 4m
Xselects 4000000 bytes.  If more space is needed, temporary files will be used.
X.TP
X.B \-nodither
XDo not use dithering in color quantization.  By default, Floyd-Steinberg
Xdithering is applied when quantizing colors, but on some images dithering may
Xresult in objectionable "graininess".  If that happens, you can turn off
Xdithering with
X.BR \-nodither .
X.B \-nodither
Xis ignored unless you also say
X.B \-colors
X.IR N .
X.TP
X.B \-onepass
XUse one-pass instead of two-pass color quantization.  The one-pass method is
Xfaster and needs less memory, but it produces a lower-quality image.
X.B \-onepass
Xis ignored unless you also say
X.B \-colors
X.IR N .
XAlso, the one-pass method is always used for gray-scale output (the two-pass
Xmethod is no improvement then).
X.TP
X.B \-verbose
XEnable debug printout.  More
X.BR \-v 's
Xgive more output.  Also, version information is printed at startup.
X.TP
X.B \-debug
XSame as
X.BR \-verbose .
X.SH EXAMPLES
X.LP
XThis example decompresses the JPEG file foo.jpg, automatically quantizes to
X256 colors, and saves the output in GIF format in foo.gif:
X.IP
X.B djpeg \-gif
X.I foo.jpg
X.B >
X.I foo.gif
X.SH ENVIRONMENT
X.TP
X.B JPEGMEM
XIf this environment variable is set, its value is the default memory limit.
XThe value is specified as described for the
X.B \-maxmemory
Xswitch.
X.B JPEGMEM
Xoverrides the default value specified when the program was compiled, and
Xitself is overridden by an explicit
X.BR \-maxmemory .
X.SH SEE ALSO
X.BR cjpeg (1)
X.br
X.BR ppm (5),
X.BR pgm (5)
X.br
XWallace, Gregory K.  "The JPEG Still Picture Compression Standard",
XCommunications of the ACM, April 1991 (vol. 34, no. 4), pp. 30-44.
X.SH AUTHOR
XIndependent JPEG Group
X.SH BUGS
XArithmetic coding is not supported for legal reasons.
X.PP
XStill not as fast as we'd like.
END_OF_FILE
  if test 4520 -ne `wc -c <'djpeg.1'`; then
    echo shar: \"'djpeg.1'\" unpacked with wrong size!
  fi
  # end of 'djpeg.1'
fi
if test -f 'jbsmooth.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jbsmooth.c'\"
else
  echo shar: Extracting \"'jbsmooth.c'\" \(3259 characters\)
  sed "s/^X//" >'jbsmooth.c' <<'END_OF_FILE'
X/*
X * jbsmooth.c
X *
X * Copyright (C) 1991, 1992, Thomas G. Lane.
X * This file is part of the Independent JPEG Group's software.
X * For conditions of distribution and use, see the accompanying README file.
X *
X * This file contains cross-block smoothing routines.
X * These routines are invoked via the smooth_coefficients method.
X */
X
X#include "jinclude.h"
X
X#ifdef BLOCK_SMOOTHING_SUPPORTED
X
X
X/*
X * Cross-block coefficient smoothing.
X */
X
XMETHODDEF void
Xsmooth_coefficients (decompress_info_ptr cinfo,
X		     jpeg_component_info *compptr,
X		     JBLOCKROW above,
X		     JBLOCKROW currow,
X		     JBLOCKROW below,
X		     JBLOCKROW output)
X{
X  QUANT_TBL_PTR Qptr = cinfo->quant_tbl_ptrs[compptr->quant_tbl_no];
X  long blocks_in_row = compptr->downsampled_width / DCTSIZE;
X  long col;
X
X  /* First, copy the block row as-is.
X   * This takes care of the first & last blocks in the row, the top/bottom
X   * special cases, and the higher-order coefficients in each block.
X   */
X  jcopy_block_row(currow, output, blocks_in_row);
X
X  /* Now apply the smoothing calculation, but not to any blocks on the
X   * edges of the image.
X   */
X
X  if (above != NULL && below != NULL) {
X    for (col = 1; col < blocks_in_row-1; col++) {
X
X      /* See section K.8 of the JPEG standard.
X       *
X       * As I understand it, this produces approximations
X       * for the low frequency AC components, based on the
X       * DC values of the block and its eight neighboring blocks.
X       * (Thus it can't be used for blocks on the image edges.)
X       */
X
X      /* The layout of these variables corresponds to text and figure in K.8 */
X      
X      JCOEF DC1, DC2, DC3;
X      JCOEF DC4, DC5, DC6;
X      JCOEF DC7, DC8, DC9;
X      
X      long       AC01, AC02;
X      long AC10, AC11;
X      long AC20;
X      
X      DC1 = above [col-1][0];
X      DC2 = above [col  ][0];
X      DC3 = above [col+1][0];
X      DC4 = currow[col-1][0];
X      DC5 = currow[col  ][0];
X      DC6 = currow[col+1][0];
X      DC7 = below [col-1][0];
X      DC8 = below [col  ][0];
X      DC9 = below [col+1][0];
X      
X#define DIVIDE_256(x)	x = ( (x) < 0 ? -((128-(x))/256) : ((x)+128)/256 )
X      
X      AC01 = (36 * (DC4 - DC6));
X      DIVIDE_256(AC01);
X      AC10 = (36 * (DC2 - DC8));
X      DIVIDE_256(AC10);
X      AC20 = (9 * (DC2 + DC8 - 2*DC5));
X      DIVIDE_256(AC20);
X      AC11 = (5 * ((DC1 - DC3) - (DC7 - DC9)));
X      DIVIDE_256(AC11);
X      AC02 = (9 * (DC4 + DC6 - 2*DC5));
X      DIVIDE_256(AC02);
X      
X      /* I think that this checks to see if the quantisation
X       * on the transmitting side would have produced this
X       * answer. If so, then we use our (hopefully better)
X       * estimate.
X       */
X
X#define ABS(x)	((x) < 0 ? -(x) : (x))
X
X#define COND_ASSIGN(_ac,_n,_z)   if ((ABS(output[col][_n] - (_ac))<<1) <= Qptr[_z]) output[col][_n] = (JCOEF) (_ac)
X
X      COND_ASSIGN(AC01,  1, 1);
X      COND_ASSIGN(AC02,  2, 5);
X      COND_ASSIGN(AC10,  8, 2);
X      COND_ASSIGN(AC11,  9, 4);
X      COND_ASSIGN(AC20, 16, 3);
X    }
X  }
X}
X
X
X/*
X * The method selection routine for cross-block smoothing.
X */
X
XGLOBAL void
Xjselbsmooth (decompress_info_ptr cinfo)
X{
X  /* just one implementation for now */
X  cinfo->methods->smooth_coefficients = smooth_coefficients;
X}
X
X#endif /* BLOCK_SMOOTHING_SUPPORTED */
END_OF_FILE
  if test 3259 -ne `wc -c <'jbsmooth.c'`; then
    echo shar: \"'jbsmooth.c'\" unpacked with wrong size!
  fi
  # end of 'jbsmooth.c'
fi
if test -f 'jcmaster.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jcmaster.c'\"
else
  echo shar: Extracting \"'jcmaster.c'\" \(4206 characters\)
  sed "s/^X//" >'jcmaster.c' <<'END_OF_FILE'
X/*
X * jcmaster.c
X *
X * Copyright (C) 1991, 1992, Thomas G. Lane.
X * This file is part of the Independent JPEG Group's software.
X * For conditions of distribution and use, see the accompanying README file.
X *
X * This file contains the main control for the JPEG compressor.
X * The system-dependent (user interface) code should call jpeg_compress()
X * after doing appropriate setup of the compress_info_struct parameter.
X */
X
X#include "jinclude.h"
X
X
XMETHODDEF void
Xc_per_scan_method_selection (compress_info_ptr cinfo)
X/* Central point for per-scan method selection */
X{
X  /* Edge expansion */
X  jselexpand(cinfo);
X  /* Downsampling of pixels */
X  jseldownsample(cinfo);
X  /* MCU extraction */
X  jselcmcu(cinfo);
X}
X
X
XLOCAL void
Xc_initial_method_selection (compress_info_ptr cinfo)
X/* Central point for initial method selection */
X{
X  /* Input image reading method selection is already done. */
X  /* So is output file header formatting (both are done by user interface). */
X
X  /* Gamma and color space conversion */
X  jselccolor(cinfo);
X  /* Entropy encoding: either Huffman or arithmetic coding. */
X#ifdef C_ARITH_CODING_SUPPORTED
X  jselcarithmetic(cinfo);
X#else
X  cinfo->arith_code = FALSE;	/* force Huffman mode */
X#endif
X  jselchuffman(cinfo);
X  /* Pipeline control */
X  jselcpipeline(cinfo);
X  /* Overall control (that's me!) */
X  cinfo->methods->c_per_scan_method_selection = c_per_scan_method_selection;
X}
X
X
XLOCAL void
Xinitial_setup (compress_info_ptr cinfo)
X/* Do computations that are needed before initial method selection */
X{
X  short ci;
X  jpeg_component_info *compptr;
X
X  /* Compute maximum sampling factors; check factor validity */
X  cinfo->max_h_samp_factor = 1;
X  cinfo->max_v_samp_factor = 1;
X  for (ci = 0; ci < cinfo->num_components; ci++) {
X    compptr = &cinfo->comp_info[ci];
X    if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
X	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
X      ERREXIT(cinfo->emethods, "Bogus sampling factors");
X    cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,
X				   compptr->h_samp_factor);
X    cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,
X				   compptr->v_samp_factor);
X
X  }
X
X  /* Compute logical downsampled dimensions of components */
X  for (ci = 0; ci < cinfo->num_components; ci++) {
X    compptr = &cinfo->comp_info[ci];
X    compptr->true_comp_width = (cinfo->image_width * compptr->h_samp_factor
X				+ cinfo->max_h_samp_factor - 1)
X				/ cinfo->max_h_samp_factor;
X    compptr->true_comp_height = (cinfo->image_height * compptr->v_samp_factor
X				 + cinfo->max_v_samp_factor - 1)
X				 / cinfo->max_v_samp_factor;
X  }
X}
X
X
X/*
X * This is the main entry point to the JPEG compressor.
X */
X
X
XGLOBAL void
Xjpeg_compress (compress_info_ptr cinfo)
X{
X  /* Init pass counts to 0 --- total_passes is adjusted in method selection */
X  cinfo->total_passes = 0;
X  cinfo->completed_passes = 0;
X
X  /* Read the input file header: determine image size & component count.
X   * NOTE: the user interface must have initialized the input_init method
X   * pointer (eg, by calling jselrppm) before calling me.
X   * The other file reading methods (get_input_row etc.) were probably
X   * set at the same time, but could be set up by input_init itself,
X   * or by c_ui_method_selection.
X   */
X  (*cinfo->methods->input_init) (cinfo);
X
X  /* Give UI a chance to adjust compression parameters and select */
X  /* output file format based on results of input_init. */
X  (*cinfo->methods->c_ui_method_selection) (cinfo);
X
X  /* Now select methods for compression steps. */
X  initial_setup(cinfo);
X  c_initial_method_selection(cinfo);
X
X  /* Initialize the output file & other modules as needed */
X  /* (entropy_encoder is inited by pipeline controller) */
X
X  (*cinfo->methods->colorin_init) (cinfo);
X  (*cinfo->methods->write_file_header) (cinfo);
X
X  /* And let the pipeline controller do the rest. */
X  (*cinfo->methods->c_pipeline_controller) (cinfo);
X
X  /* Finish output file, release working storage, etc */
X  (*cinfo->methods->write_file_trailer) (cinfo);
X  (*cinfo->methods->colorin_term) (cinfo);
X  (*cinfo->methods->input_term) (cinfo);
X
X  (*cinfo->emethods->free_all) ();
X
X  /* My, that was easy, wasn't it? */
X}
END_OF_FILE
  if test 4206 -ne `wc -c <'jcmaster.c'`; then
    echo shar: \"'jcmaster.c'\" unpacked with wrong size!
  fi
  # end of 'jcmaster.c'
fi
if test -f 'jerror.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jerror.c'\"
else
  echo shar: Extracting \"'jerror.c'\" \(2640 characters\)
  sed "s/^X//" >'jerror.c' <<'END_OF_FILE'
X/*
X * jerror.c
X *
X * Copyright (C) 1991, 1992, Thomas G. Lane.
X * This file is part of the Independent JPEG Group's software.
X * For conditions of distribution and use, see the accompanying README file.
X *
X * This file contains simple error-reporting and trace-message routines.
X * These are suitable for Unix-like systems and others where writing to
X * stderr is the right thing to do.  If the JPEG software is integrated
X * into a larger application, you may well need to replace these.
X *
X * The error_exit() routine should not return to its caller.  Within a
X * larger application, you might want to have it do a longjmp() to return
X * control to the outer user interface routine.  This should work since
X * the portable JPEG code doesn't use setjmp/longjmp.  You should make sure
X * that free_all is called either within error_exit or after the return to
X * the outer-level routine.
X *
X * These routines are used by both the compression and decompression code.
X */
X
X#include "jinclude.h"
X#ifdef INCLUDES_ARE_ANSI
X#include <stdlib.h>		/* to declare exit() */
X#endif
X
X#ifndef EXIT_FAILURE		/* define exit() codes if not provided */
X#define EXIT_FAILURE  1
X#endif
X
X
Xstatic external_methods_ptr methods; /* saved for access to message_parm, free_all */
X
X
XMETHODDEF void
Xtrace_message (const char *msgtext)
X{
X  fprintf(stderr, msgtext,
X	  methods->message_parm[0], methods->message_parm[1],
X	  methods->message_parm[2], methods->message_parm[3],
X	  methods->message_parm[4], methods->message_parm[5],
X	  methods->message_parm[6], methods->message_parm[7]);
X  fprintf(stderr, "\n");
X}
X
X
XMETHODDEF void
Xerror_exit (const char *msgtext)
X{
X  (*methods->trace_message) (msgtext);
X  (*methods->free_all) ();	/* clean up memory allocation */
X  exit(EXIT_FAILURE);
X}
X
X
X/*
X * The method selection routine for simple error handling.
X * The system-dependent setup routine should call this routine
X * to install the necessary method pointers in the supplied struct.
X */
X
XGLOBAL void
Xjselerror (external_methods_ptr emethods)
X{
X  methods = emethods;		/* save struct addr for later access */
X
X  emethods->error_exit = error_exit;
X  emethods->trace_message = trace_message;
X
X  emethods->trace_level = 0;	/* default = no tracing */
X
X  emethods->num_warnings = 0;	/* no warnings emitted yet */
X  /* By default, the first corrupt-data warning will be displayed,
X   * but additional ones will appear only if trace level is at least 3.
X   * A corrupt data file could generate many warnings, so it's a good idea
X   * to suppress additional messages except at high tracing levels.
X   */
X  emethods->first_warning_level = 0;
X  emethods->more_warning_level = 3;
X}
END_OF_FILE
  if test 2640 -ne `wc -c <'jerror.c'`; then
    echo shar: \"'jerror.c'\" unpacked with wrong size!
  fi
  # end of 'jerror.c'
fi
if test -f 'jmemansi.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jmemansi.c'\"
else
  echo shar: Extracting \"'jmemansi.c'\" \(4303 characters\)
  sed "s/^X//" >'jmemansi.c' <<'END_OF_FILE'
X/*
X * jmemansi.c  (jmemsys.c)
X *
X * Copyright (C) 1992, Thomas G. Lane.
X * This file is part of the Independent JPEG Group's software.
X * For conditions of distribution and use, see the accompanying README file.
X *
X * This file provides a simple generic implementation of the system-
X * dependent portion of the JPEG memory manager.  This implementation
X * assumes that you have the ANSI-standard library routine tmpfile().
X * Also, the problem of determining the amount of memory available
X * is shoved onto the user.
X */
X
X#include "jinclude.h"
X#include "jmemsys.h"
X
X#ifdef INCLUDES_ARE_ANSI
X#include <stdlib.h>		/* to declare malloc(), free() */
X#else
Xextern void * malloc PP((size_t size));
Xextern void free PP((void *ptr));
X#endif
X
X#ifndef SEEK_SET		/* pre-ANSI systems may not define this; */
X#define SEEK_SET  0		/* if not, assume 0 is correct */
X#endif
X
X
Xstatic external_methods_ptr methods; /* saved for access to error_exit */
X
Xstatic long total_used;		/* total memory requested so far */
X
X
X/*
X * Memory allocation and freeing are controlled by the regular library
X * routines malloc() and free().
X */
X
XGLOBAL void *
Xjget_small (size_t sizeofobject)
X{
X  total_used += sizeofobject;
X  return (void *) malloc(sizeofobject);
X}
X
XGLOBAL void
Xjfree_small (void * object)
X{
X  free(object);
X}
X
X/*
X * We assume NEED_FAR_POINTERS is not defined and so the separate entry points
X * jget_large, jfree_large are not needed.
X */
X
X
X/*
X * This routine computes the total memory space available for allocation.
X * It's impossible to do this in a portable way; our current solution is
X * to make the user tell us (with a default value set at compile time).
X * If you can actually get the available space, it's a good idea to subtract
X * a slop factor of 5% or so.
X */
X
X#ifndef DEFAULT_MAX_MEM		/* so can override from makefile */
X#define DEFAULT_MAX_MEM		1000000L /* default: one megabyte */
X#endif
X
XGLOBAL long
Xjmem_available (long min_bytes_needed, long max_bytes_needed)
X{
X  return methods->max_memory_to_use - total_used;
X}
X
X
X/*
X * Backing store (temporary file) management.
X * Backing store objects are only used when the value returned by
X * jmem_available is less than the total space needed.  You can dispense
X * with these routines if you have plenty of virtual memory; see jmemnobs.c.
X */
X
X
XMETHODDEF void
Xread_backing_store (backing_store_ptr info, void FAR * buffer_address,
X		    long file_offset, long byte_count)
X{
X  if (fseek(info->temp_file, file_offset, SEEK_SET))
X    ERREXIT(methods, "fseek failed on temporary file");
X  if (JFREAD(info->temp_file, buffer_address, byte_count)
X      != (size_t) byte_count)
X    ERREXIT(methods, "fread failed on temporary file");
X}
X
X
XMETHODDEF void
Xwrite_backing_store (backing_store_ptr info, void FAR * buffer_address,
X		     long file_offset, long byte_count)
X{
X  if (fseek(info->temp_file, file_offset, SEEK_SET))
X    ERREXIT(methods, "fseek failed on temporary file");
X  if (JFWRITE(info->temp_file, buffer_address, byte_count)
X      != (size_t) byte_count)
X    ERREXIT(methods, "fwrite failed on temporary file --- out of disk space?");
X}
X
X
XMETHODDEF void
Xclose_backing_store (backing_store_ptr info)
X{
X  fclose(info->temp_file);
X  /* Since this implementation uses tmpfile() to create the file,
X   * no explicit file deletion is needed.
X   */
X}
X
X
X/*
X * Initial opening of a backing-store object.
X *
X * This version uses tmpfile(), which constructs a suitable file name
X * behind the scenes.  We don't have to use temp_name[] at all;
X * indeed, we can't even find out the actual name of the temp file.
X */
X
XGLOBAL void
Xjopen_backing_store (backing_store_ptr info, long total_bytes_needed)
X{
X  if ((info->temp_file = tmpfile()) == NULL)
X    ERREXIT(methods, "Failed to create temporary file");
X  info->read_backing_store = read_backing_store;
X  info->write_backing_store = write_backing_store;
X  info->close_backing_store = close_backing_store;
X}
X
X
X/*
X * These routines take care of any system-dependent initialization and
X * cleanup required.  Keep in mind that jmem_term may be called more than
X * once.
X */
X
XGLOBAL void
Xjmem_init (external_methods_ptr emethods)
X{
X  methods = emethods;		/* save struct addr for error exit access */
X  emethods->max_memory_to_use = DEFAULT_MAX_MEM;
X  total_used = 0;
X}
X
XGLOBAL void
Xjmem_term (void)
X{
X  /* no work */
X}
END_OF_FILE
  if test 4303 -ne `wc -c <'jmemansi.c'`; then
    echo shar: \"'jmemansi.c'\" unpacked with wrong size!
  fi
  # end of 'jmemansi.c'
fi
if test -f 'jmemnobs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jmemnobs.c'\"
else
  echo shar: Extracting \"'jmemnobs.c'\" \(2263 characters\)
  sed "s/^X//" >'jmemnobs.c' <<'END_OF_FILE'
X/*
X * jmemnobs.c  (jmemsys.c)
X *
X * Copyright (C) 1992, Thomas G. Lane.
X * This file is part of the Independent JPEG Group's software.
X * For conditions of distribution and use, see the accompanying README file.
X *
X * This file provides a really simple implementation of the system-
X * dependent portion of the JPEG memory manager.  This implementation
X * assumes that no backing-store files are needed: all required space
X * can be obtained from malloc().
X * This is very portable in the sense that it'll compile on almost anything,
X * but you'd better have lots of main memory (or virtual memory) if you want
X * to process big images.
X * Note that the max_memory_to_use option is ignored by this implementation.
X */
X
X#include "jinclude.h"
X#include "jmemsys.h"
X
X#ifdef INCLUDES_ARE_ANSI
X#include <stdlib.h>		/* to declare malloc(), free() */
X#else
Xextern void * malloc PP((size_t size));
Xextern void free PP((void *ptr));
X#endif
X
X
Xstatic external_methods_ptr methods; /* saved for access to error_exit */
X
X
X/*
X * Memory allocation and freeing are controlled by the regular library
X * routines malloc() and free().
X */
X
XGLOBAL void *
Xjget_small (size_t sizeofobject)
X{
X  return (void *) malloc(sizeofobject);
X}
X
XGLOBAL void
Xjfree_small (void * object)
X{
X  free(object);
X}
X
X/*
X * We assume NEED_FAR_POINTERS is not defined and so the separate entry points
X * jget_large, jfree_large are not needed.
X */
X
X
X/*
X * This routine computes the total memory space available for allocation.
X * Here we always say, "we got all you want bud!"
X */
X
XGLOBAL long
Xjmem_available (long min_bytes_needed, long max_bytes_needed)
X{
X  return max_bytes_needed;
X}
X
X
X/*
X * Backing store (temporary file) management.
X * This should never be called and we just error out.
X */
X
XGLOBAL void
Xjopen_backing_store (backing_store_ptr info, long total_bytes_needed)
X{
X  ERREXIT(methods, "Backing store not supported");
X}
X
X
X/*
X * These routines take care of any system-dependent initialization and
X * cleanup required.  Keep in mind that jmem_term may be called more than
X * once.
X */
X
XGLOBAL void
Xjmem_init (external_methods_ptr emethods)
X{
X  methods = emethods;		/* save struct addr for error exit access */
X  emethods->max_memory_to_use = 0;
X}
X
XGLOBAL void
Xjmem_term (void)
X{
X  /* no work */
X}
END_OF_FILE
  if test 2263 -ne `wc -c <'jmemnobs.c'`; then
    echo shar: \"'jmemnobs.c'\" unpacked with wrong size!
  fi
  # end of 'jmemnobs.c'
fi
if test -f 'jutils.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jutils.c'\"
else
  echo shar: Extracting \"'jutils.c'\" \(3355 characters\)
  sed "s/^X//" >'jutils.c' <<'END_OF_FILE'
X/*
X * jutils.c
X *
X * Copyright (C) 1991, 1992, Thomas G. Lane.
X * This file is part of the Independent JPEG Group's software.
X * For conditions of distribution and use, see the accompanying README file.
X *
X * This file contains miscellaneous utility routines needed for both
X * compression and decompression.
X * Note we prefix all global names with "j" to minimize conflicts with
X * a surrounding application.
X */
X
X#include "jinclude.h"
X
X
XGLOBAL long
Xjround_up (long a, long b)
X/* Compute a rounded up to next multiple of b; a >= 0, b > 0 */
X{
X  a += b-1;
X  return a - (a % b);
X}
X
X
X/* On normal machines we can apply MEMCOPY() and MEMZERO() to sample arrays
X * and coefficient-block arrays.  This won't work on 80x86 because the arrays
X * are FAR and we're assuming a small-pointer memory model.  However, some
X * DOS compilers provide far-pointer versions of memcpy() and memset() even
X * in the small-model libraries.  These will be used if USE_FMEM is defined.
X * Otherwise, the routines below do it the hard way.  (The performance cost
X * is not all that great, because these routines aren't very heavily used.)
X */
X
X#ifndef NEED_FAR_POINTERS	/* normal case, same as regular macros */
X#define FMEMCOPY(dest,src,size)	MEMCOPY(dest,src,size)
X#define FMEMZERO(target,size)	MEMZERO(target,size)
X#else				/* 80x86 case, define if we can */
X#ifdef USE_FMEM
X#define FMEMCOPY(dest,src,size)	_fmemcpy((void FAR *)(dest), (const void FAR *)(src), (size_t)(size))
X#define FMEMZERO(target,size)	_fmemset((void FAR *)(target), 0, (size_t)(size))
X#endif
X#endif
X
X
XGLOBAL void
Xjcopy_sample_rows (JSAMPARRAY input_array, int source_row,
X		   JSAMPARRAY output_array, int dest_row,
X		   int num_rows, long num_cols)
X/* Copy some rows of samples from one place to another.
X * num_rows rows are copied from input_array[source_row++]
X * to output_array[dest_row++]; these areas should not overlap.
X * The source and destination arrays must be at least as wide as num_cols.
X */
X{
X  register JSAMPROW inptr, outptr;
X#ifdef FMEMCOPY
X  register size_t count = (size_t) (num_cols * SIZEOF(JSAMPLE));
X#else
X  register long count;
X#endif
X  register int row;
X
X  input_array += source_row;
X  output_array += dest_row;
X
X  for (row = num_rows; row > 0; row--) {
X    inptr = *input_array++;
X    outptr = *output_array++;
X#ifdef FMEMCOPY
X    FMEMCOPY(outptr, inptr, count);
X#else
X    for (count = num_cols; count > 0; count--)
X      *outptr++ = *inptr++;	/* needn't bother with GETJSAMPLE() here */
X#endif
X  }
X}
X
X
XGLOBAL void
Xjcopy_block_row (JBLOCKROW input_row, JBLOCKROW output_row, long num_blocks)
X/* Copy a row of coefficient blocks from one place to another. */
X{
X#ifdef FMEMCOPY
X  FMEMCOPY(output_row, input_row, num_blocks * (DCTSIZE2 * SIZEOF(JCOEF)));
X#else
X  register JCOEFPTR inptr, outptr;
X  register long count;
X
X  inptr = (JCOEFPTR) input_row;
X  outptr = (JCOEFPTR) output_row;
X  for (count = num_blocks * DCTSIZE2; count > 0; count--) {
X    *outptr++ = *inptr++;
X  }
X#endif
X}
X
X
XGLOBAL void
Xjzero_far (void FAR * target, size_t bytestozero)
X/* Zero out a chunk of FAR memory. */
X/* This might be sample-array data, block-array data, or alloc_medium data. */
X{
X#ifdef FMEMZERO
X  FMEMZERO(target, bytestozero);
X#else
X  register char FAR * ptr = (char FAR *) target;
X  register size_t count;
X
X  for (count = bytestozero; count > 0; count--) {
X    *ptr++ = 0;
X  }
X#endif
X}
END_OF_FILE
  if test 3355 -ne `wc -c <'jutils.c'`; then
    echo shar: \"'jutils.c'\" unpacked with wrong size!
  fi
  # end of 'jutils.c'
fi
if test -f 'makcjpeg.st' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makcjpeg.st'\"
else
  echo shar: Extracting \"'makcjpeg.st'\" \(1453 characters\)
  sed "s/^X//" >'makcjpeg.st' <<'END_OF_FILE'
X; Project file for Independent JPEG Group's software
X;
X; This project file is for Atari ST/STE/TT systems using Pure C or Turbo C.
X; Thanks to Frank Moehle (Frank.Moehle@arbi.informatik.uni-oldenburg.de)
X; and to Dr. B. Setzepfandt (bernd@gina.uni-muenster.de).
X;
X; To use this file, rename it to CJPEG.PRJ.
X; If you are using Turbo C, change filenames beginning with "PC..." to "TC..."
X; Read SETUP instructions before trying to make the program!
X;
X;
X;      * * * Output file * * *
Xcjpeg.ttp
X;
X;      * * * DEFINES * * * 
X.C[-DHAVE_STDC]
X.C[-DINCLUDES_ARE_ANSI]
X.C[-DNEED_SIGNAL_CATCHER]  ; It's safer to have a signal catcher.
X.C[-DTWO_FILE_COMMANDLINE] ; If you like the UNIX - style with
X                           ; I/O redirection, comment this line out.
X.C[-DPROGRESS_REPORT]      ; This enables the % progress indicator
X;
X; * * * COMPILER OPTIONS * * *  
X.C[-P]        ; absolute calls
X.C[-M]        ; and no string merging, folks
X.C[-w-par]    ; no "parameter xxxx unused"
X.C[-DINCOMPLETE_TYPES_BROKEN] ; suppress warnings about undefined structures
X.C[-wsig]     ; warn if significant digits may be lost
X.C[-w-cln]    ; no "constant is long" warnings
X=
X; * * * * List of modules * * * * 
XPCSTART.O
Xjcmain.c		(jinclude.h,jconfig.h,jpegdata.h,jversion.h)
XJPEG.LIB           ; built by LIB_JPEG.PRJ
X;PCFLTLIB.LIB      ; floating point library -- you shouldn't need this
XPCSTDLIB.LIB       ; standard library
XPCEXTLIB.LIB       ; extended library
END_OF_FILE
  if test 1453 -ne `wc -c <'makcjpeg.st'`; then
    echo shar: \"'makcjpeg.st'\" unpacked with wrong size!
  fi
  # end of 'makcjpeg.st'
fi
if test -f 'makdjpeg.st' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makdjpeg.st'\"
else
  echo shar: Extracting \"'makdjpeg.st'\" \(1453 characters\)
  sed "s/^X//" >'makdjpeg.st' <<'END_OF_FILE'
X; Project file for Independent JPEG Group's software
X;
X; This project file is for Atari ST/STE/TT systems using Pure C or Turbo C.
X; Thanks to Frank Moehle (Frank.Moehle@arbi.informatik.uni-oldenburg.de)
X; and to Dr. B. Setzepfandt (bernd@gina.uni-muenster.de).
X;
X; To use this file, rename it to DJPEG.PRJ.
X; If you are using Turbo C, change filenames beginning with "PC..." to "TC..."
X; Read SETUP instructions before trying to make the program!
X;
X;
X;      * * * Output file * * *
Xdjpeg.ttp
X;
X;      * * * DEFINES * * * 
X.C[-DHAVE_STDC]
X.C[-DINCLUDES_ARE_ANSI]
X.C[-DNEED_SIGNAL_CATCHER]  ; It's safer to have a signal catcher.
X.C[-DTWO_FILE_COMMANDLINE] ; If you like the UNIX - style with
X                           ; I/O redirection, comment this line out.
X.C[-DPROGRESS_REPORT]      ; This enables the % progress indicator
X;
X; * * * COMPILER OPTIONS * * *  
X.C[-P]        ; absolute calls
X.C[-M]        ; and no string merging, folks
X.C[-w-par]    ; no "parameter xxxx unused"
X.C[-DINCOMPLETE_TYPES_BROKEN] ; suppress warnings about undefined structures
X.C[-wsig]     ; warn if significant digits may be lost
X.C[-w-cln]    ; no "constant is long" warnings
X=
X; * * * * List of modules * * * * 
XPCSTART.O
Xjdmain.c		(jinclude.h,jconfig.h,jpegdata.h,jversion.h)
XJPEG.LIB           ; built by LIB_JPEG.PRJ
X;PCFLTLIB.LIB      ; floating point library -- you shouldn't need this
XPCSTDLIB.LIB       ; standard library
XPCEXTLIB.LIB       ; extended library
END_OF_FILE
  if test 1453 -ne `wc -c <'makdjpeg.st'`; then
    echo shar: \"'makdjpeg.st'\" unpacked with wrong size!
  fi
  # end of 'makdjpeg.st'
fi
if test -f 'makefile.vms' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.vms'\"
else
  echo shar: Extracting \"'makefile.vms'\" \(2439 characters\)
  sed "s/^X//" >'makefile.vms' <<'END_OF_FILE'
X$! Makefile for Independent JPEG Group's software
X$!
X$! This is a command procedure for use on VAX/VMS systems that do not have MMS.
X$! It builds the JPEG software by brute force, recompiling everything whether
X$! or not it is necessary.  It then runs the basic self-test.
X$! Thanks to Rick Dyson (dyson@iowasp.physics.uiowa.edu)
X$! and Tim Bell (tbell@netcom.com) for their help.
X$!
X$! Read SETUP instructions before running this!!
X$!
X$ DoCompile := CC /NoDebug /Optimize /Define = (TWO_FILE_COMMANDLINE,HAVE_STDC,INCLUDES_ARE_ANSI)
X$!
X$ DoCompile jcmain.c
X$ DoCompile jdmain.c
X$ DoCompile jcmaster.c
X$ DoCompile jcdeflts.c
X$ DoCompile jcarith.c
X$ DoCompile jccolor.c
X$ DoCompile jcexpand.c
X$ DoCompile jchuff.c
X$ DoCompile jcmcu.c
X$ DoCompile jcpipe.c
X$ DoCompile jcsample.c
X$ DoCompile jfwddct.c
X$ DoCompile jwrjfif.c
X$ DoCompile jrdgif.c
X$ DoCompile jrdppm.c
X$ DoCompile jrdrle.c
X$ DoCompile jrdtarga.c
X$ DoCompile jdmaster.c
X$ DoCompile jddeflts.c
X$ DoCompile jbsmooth.c
X$ DoCompile jdarith.c
X$ DoCompile jdcolor.c
X$ DoCompile jdhuff.c
X$ DoCompile jdmcu.c
X$ DoCompile jdpipe.c
X$ DoCompile jdsample.c
X$ DoCompile jquant1.c
X$ DoCompile jquant2.c
X$ DoCompile jrevdct.c
X$ DoCompile jrdjfif.c
X$ DoCompile jwrgif.c
X$ DoCompile jwrppm.c
X$ DoCompile jwrrle.c
X$ DoCompile jwrtarga.c
X$ DoCompile jutils.c
X$ DoCompile jerror.c
X$ DoCompile jmemmgr.c
X$ DoCompile jmemsys.c
X$!
X$ Library /Create libjpeg.olb  jcmaster.obj,jcdeflts.obj,jcarith.obj, -
X          jccolor.obj,jcexpand.obj,jchuff.obj,jcmcu.obj,jcpipe.obj, -
X          jcsample.obj,jfwddct.obj,jwrjfif.obj,jrdgif.obj,jrdppm.obj, -
X          jrdrle.obj,jrdtarga.obj,jdmaster.obj,jddeflts.obj,jbsmooth.obj, -
X          jdarith.obj,jdcolor.obj,jdhuff.obj,jdmcu.obj,jdpipe.obj, -
X          jdsample.obj,jquant1.obj,jquant2.obj,jrevdct.obj,jrdjfif.obj, -
X          jwrgif.obj,jwrppm.obj,jwrrle.obj,jwrtarga.obj,jutils.obj, -
X          jerror.obj,jmemmgr.obj,jmemsys.obj
X$!
X$ Link /Executable = cjpeg.exe  jcmain.obj,libjpeg.olb/Library,Sys$Disk:[]MAKVMS.OPT/Option
X$!
X$ Link /Executable = djpeg.exe  jdmain.obj,libjpeg.olb/Library,Sys$Disk:[]MAKVMS.OPT/Option
X$!
X$! Run the self-test
X$!
X$ mcr sys$disk:[]djpeg      testorig.jpg testout.ppm
X$ mcr sys$disk:[]djpeg -gif testorig.jpg testout.gif
X$ mcr sys$disk:[]cjpeg      testimg.ppm testout.jpg
X$ Backup /Compare/Log testimg.ppm testout.ppm
X$ Backup /Compare/Log testimg.gif testout.gif
X$ Backup /Compare/Log testimg.jpg testout.jpg
X$!
X$ Exit
END_OF_FILE
  if test 2439 -ne `wc -c <'makefile.vms'`; then
    echo shar: \"'makefile.vms'\" unpacked with wrong size!
  fi
  # end of 'makefile.vms'
fi
if test -f 'makljpeg.st' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makljpeg.st'\"
else
  echo shar: Extracting \"'makljpeg.st'\" \(2548 characters\)
  sed "s/^X//" >'makljpeg.st' <<'END_OF_FILE'
X; Project file for Independent JPEG Group's software
X;
X; This project file is for Atari ST/STE/TT systems using Pure C or Turbo C.
X; Thanks to Frank Moehle (Frank.Moehle@arbi.informatik.uni-oldenburg.de)
X; and to Dr. B. Setzepfandt (bernd@gina.uni-muenster.de).
X;
X; To use this file, rename it to LIB_JPEG.PRJ.
X; Read SETUP instructions before trying to make the library!
X;
X;
X;      * * * Output file * * *
Xjpeg.lib
X;
X;      * * * DEFINES * * * 
X.C[-DHAVE_STDC]
X.C[-DINCLUDES_ARE_ANSI]
X;
X; * * * COMPILER OPTIONS * * *  
X.C[-P]        ; absolute calls
X.C[-M]        ; and no string merging, folks
X.C[-w-par]    ; no "parameter xxxx unused"
X.C[-DINCOMPLETE_TYPES_BROKEN] ; suppress warnings about undefined structures
X.C[-wsig]     ; warn if significant digits may be lost
X.C[-w-cln]    ; no "constant is long" warnings
X.L[-J]        ; link new Obj-format (so we get a library)
X=
X; * * * * List of modules * * * * 
Xjbsmooth.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjcarith.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjccolor.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjcdeflts.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjcexpand.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjchuff.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjcmaster.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjcmcu.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjcpipe.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjcsample.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjdarith.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjdcolor.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjddeflts.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjdhuff.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjdmaster.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjdmcu.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjdpipe.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjdsample.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjerror.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjquant1.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjquant2.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjfwddct.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjrevdct.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjutils.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjmemmgr.c		(jinclude.h,jconfig.h,jpegdata.h,jmemsys.h)
Xjrdjfif.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjrdgif.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjrdppm.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjrdrle.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjrdtarga.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjwrjfif.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjwrgif.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjwrppm.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjwrrle.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjwrtarga.c		(jinclude.h,jconfig.h,jpegdata.h)
Xjmemsys.c		(jinclude.h,jconfig.h,jpegdata.h,jmemsys.h)
END_OF_FILE
  if test 2548 -ne `wc -c <'makljpeg.st'`; then
    echo shar: \"'makljpeg.st'\" unpacked with wrong size!
  fi
  # end of 'makljpeg.st'
fi
echo shar: End of archive 18 \(of 18\).
cp /dev/null ark18isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
