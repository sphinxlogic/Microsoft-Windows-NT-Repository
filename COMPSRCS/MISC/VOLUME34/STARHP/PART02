Newsgroups: comp.sources.misc
From: kirk@sdd.hp.com (Kirk Norton)
Subject:  v34i019:  starhp - HP-GL/2 StarChart driver, Part02/02
Message-ID: <1992Dec8.014548.28558@sparky.imd.sterling.com>
X-Md4-Signature: a4d9db02f5d13b4e9a65ebdc0f353f88
Date: Tue, 8 Dec 1992 01:45:48 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: kirk@sdd.hp.com (Kirk Norton)
Posting-number: Volume 34, Issue 19
Archive-name: starhp/part02
Environment: HP-GL/2, Starchart

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  starhp.1 starhp.c.A
# Wrapped by kent@sparky on Mon Dec  7 19:27:02 1992
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 2)."'
if test -f 'starhp.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'starhp.1'\"
else
  echo shar: Extracting \"'starhp.1'\" \(3527 characters\)
  sed "s/^X//" >'starhp.1' <<'END_OF_FILE'
X.TH STARCHART LOCAL "15 July 1989"
X.ad b
X.SH NAME
Xstarhp \- create astronomical star charts.
X.SH SYNOPSIS
XArguments as in other starchart programs, with the special argument -a:
X.br
X.B \-a
X"\fBm\fR
X[
X.I mag-1
X:
X.I mag0
X:
X.I mag1
X:
X.I mag2
X:
X.I ...
X]
X|
X.B \-a
X\fBs\fR
X[
X.I D0
X[
X.I v0
X[
X.I k
X]]]
X|
X\fBn\fR
X[
X.I rad1
X:
X.I rad2
X:
X.I rad3
X:
X.I rad4
X:
X.I ...
X]
X|
X.BI f " file"
X|
X.B c
X|
X\fBl\fR
X|
X\fBA\fR
X|
X\fBB\fR
X|
X\fBC\fR
X|
X\fBD\fR
X|
X\fBE\fR"
X.br
X
X.SH DESCRIPTION
XSee starchart(1) for details on the starchart programs in general.
X.PP
XSee starpost(1) for details on other supported control options.
X.PP
XAll arguments described for the starpost driver are supported identically in 
Xstarhp, including color support.  Additionally, starhp 
Xwill accept options to specify the desired plot size.  The options \fBA\fR, 
X\fBB\fR, \fBC\fR, \fBD\fR, and \fBE\fR will cause starhp to create either an 
XA, B, C, D, or E size plot file respectively.  These options enable the user 
Xto create star charts of any size, up to the maximum plot size of the device 
X(usually 8.5x11 inches for an A size printer, and 34x44 inches for an E size 
Xplotter). If the target device is a laser printer, no size specification 
Xshould be used, since it will result in an incorrectly scaled and rotated plot.
X.PP
XThe output of this program is HP-GL/2:  a printer and plotter
Xvector graphics language.  Any HP or compatible printer/plotter should work
Xwith this program provided the device supports HP-GL/2.  Older devices,
Xsuch as HP DeskJet, PaintJet, and LaserJets before the IIP are not 
Xcompatible and should not be used, since they are PCL-only (raster-only)
Xdevices and will produce many pages of text garbage.  To generate starcharts
Xon these devices, the starlaser driver should be used instead.
X.PP
XThe older HP-GL (not HP-GL/2) plotters may have some problems with the
Xcharts generated by this driver, since HP-GL varies from device to device.
XFor example, the origin of the plot may be shifted so that only one fourth
Xof the plot appears, the scaling may be incorrect on some devices, and
Xothers may have trouble with text, etc.  Time permitting, future versions of 
Xthis driver may attempt to support HP-GL in addition to HP-GL/2.
X.PP
XOutput quality is dependent on the printing device used.  For example,
Xlaser printers should generate Postscript-quality output, while large format 
Xplotters will probably not support many of the nicer-looking fonts.
X
X.SH EXAMPLE
Xstarhp -r 17.45 -d -29 -t "Galactic Center" -s 10 -m 9 -l 6 
X.br
X(for HP-GL/2 LaserJets)
X.sp1
Xstarhp -a D -a l -a "f orion.HPGL2" -s 45 -b -c ori -g 5
X.br
X(for D or E-size plotters)
X.SH BUGS
XBecause pen plotters are incapable of erasing previously drawn objects,
Xstar haloing will not work on these plotters.  
XNotebook mode will also be
Xaffected by this limitation, since the thumbnail map cannot be erased before
Xthe note prompts are printed.
X.PP
XSome devices may not have enough internal memory to render high density
Xstar charts, and may eject the page when it is only partially printed.
XIn these instances, it will be necessary to reduce the number of objects
Xappearing on the page before it will be printed completely (i.e. reduce
Xthe magnitude limit or the scale parameters).
X
XThis is the first release of this driver, so please report any bugs (or fixes)
Xto the author (kirk@sdd.hp.com).
X.SH AUTHORS/EDITORS
XKirk Norton, HP San Diego Division (kirk@sdd.hp.com)
X.br
XThanks to
X.br
XCraig Counterman
X.br
XAlan Paeth, University of Waterloo <AWPaeth@watCGL>
X.br
XPoul-Henning Kamp
X
END_OF_FILE
  if test 3527 -ne `wc -c <'starhp.1'`; then
    echo shar: \"'starhp.1'\" unpacked with wrong size!
  fi
  # end of 'starhp.1'
fi
if test -f 'starhp.c.A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'starhp.c.A'\"
else
  echo shar: Extracting \"'starhp.c.A'\" \(31028 characters\)
  sed "s/^X//" >'starhp.c.A' <<'END_OF_FILE'
X/*
X * starhp.c
X *    HP-GL/2 driver for producing A to E size star maps, color or monochrome.
X *
X * This driver should support all HP Laserjet IIP's, III's (or higher), and any 
X * other HP-GL/2 (or PCL-5) printers and plotters (pen, electrostatic, etc.).  
X * HP-GL devices (usually the older ones) may have some problems, but
X * I've tried to keep the driver as general as possible.
X *
X * This driver WILL NOT support DeskJet, PaintJet (without the HP-GL/2 option),
X *  or early LaserJets (those before IIP's), since these are PCL-only devices
X *  -- so don't try it (because you will get many, many pages of garbage).
X *
X * Some HP-GL/2 LaserJets and compatibles will not be able to print high density
X * charts (ones with lots of stars) due to insufficient memory, and the page
X * may be only partially printed.  To avoid this, either reduce the scale
X * parameter on the starhp command line or reduce the magnitude limits, thereby
X * reducing the number of objects appearing on the page.
X *
X * HP-GL/2 plotters shouldn't have these problems since they print "on the fly".
X * Of course, "haloing" of objects is not supported on pen plotters, and the 
X * nice looking fonts will probably not be available on most large format 
X * devices or on some HP-GL/2 ink jet printers.
X * 
X *
X * Produced by Kirk Norton (kirk@sdd.hp.com) July, 1991 for StarChart 3.2
X * by Alan Paeth and Craig Counterman.  Leveraged (heavily) from starpost.c.
X *
X * Supports the following enhancements:
X *   1> "bigmaster" chart layout now added
X *   2> extensive rework and subclassing of non-stellar objects, e.g.
X *      galaxies, now have both spiral and irregular variants.
X *   3> star sizes now extended to magnitude 10
X *   4> supports large format devices (up to 44x34 inches) 
X *
X * Default size changed from 8x11 to 8x10 inches to accomodate Laserjets
X *
X * StarChart Version 3.2 copyright (c) March 1990 by Craig Counterman 
X * original StarChart Software Suite copyright (c) 1987 by Alan Paeth
X *
X * All rights reserved. Redistribution granted for non-commercial
X * non-profit use only. Disclaimer: users of this work understand that
X * (a) the authors cannot undertake to support this software (b) users
X * agree to acknowledge the use of the software in any published work
X * arising from its application and (c) any subsequent redistribution of
X * this work retains this warranty placard. 
X *
X * No representation is made about the suitability of this
X * software for any purpose.  It is provided "as is" without express or
X * implied warranty, to the extent permitted by applicable law.
X *
X */
X
Xstatic char rcsid[]="$Header: starhp.c,v 1.0 91/05/25 00:34:23 ccount Exp $";
X#include <stdio.h>
X#include <math.h>
X#ifndef SYSV
X#include <strings.h>
X#else
X#include <string.h>
X#endif
X#include <ctype.h>
X#include "star3.h"
X
X
X/* Externs */
Xextern int g_argc;
Xextern char **g_argv;
X
Xextern char *title;	/* Title of page */
X
Xextern mapwindow *mapwin[MAXWINDOWS];
Xextern int numwins;
X
Xextern int cur_function;
Xextern int cur_map_type;
Xextern int cur_map_tag;
Xextern char *cur_tag_field;
Xextern mapwindow *cur_win;
X
Xextern int chart_type;
X
X/* Set by initxform
X   One could use elements of the mapwindow structure,
X   but these should be faster for the current window */
Xextern double xf_west, xf_east, xf_north, xf_south, xf_bottom;
Xextern int xf_xcen, xf_ycen, xf_ybot;
Xextern int xf_w_left, xf_w_right, xf_w_top, xf_w_bot;
Xextern double xf_c_scale;
X
X/* Scale multiplier, minimum,
X   mangitude change, maximum, for thumbnail,*/
X#define THSMUL 1.2
X#define THSMIN 12.0
X#define THMADJ 2.5
X#define THMMAX 8.0
X
X
X#define ResPT 42          /* Changed from 4 in the Postscript driver         */
X#define InchPT 72*ResPT   /* InchPT will still be 1 inch in units for A-size */
X
X#define MAG_1_RAD 9*ResPT
X#define MAG0_RAD ((int)(8*ResPT))
X#define MAG1_RAD ((int)(7*ResPT))
X#define MAG2_RAD ((int)(6*ResPT))
X/*  if MAG3 is not an integer times ResPT,
X    there is an error reported later using some (non-ansi) compilers */
X#define MAG3_RAD ((int)(5*ResPT))
X#define MAG4_RAD ((int)(4*ResPT))
X#define MAG5_RAD ((int)(3.25*ResPT))
X#define MAG6_RAD ((int)(2.5*ResPT))
X#define MAG7_RAD ((int)(2.0*ResPT))
X#define MAG8_RAD ((int)(1.5*ResPT))
X#define MAG9_RAD ((int)(1.0*ResPT))
X#define MAG10_RAD ((int)(0.5*ResPT))
X#define MAG11_RAD ((int)(0.5*ResPT))
X#define MAG12_RAD ((int)(0.5*ResPT))
X#define MAG13_RAD ((int)(0.5*ResPT))
X#define MAG14_RAD ((int)(0.5*ResPT))
X#define MAG15_RAD ((int)(0.5*ResPT))
X#define MAG16_RAD ((int)(0.5*ResPT))
X#define MAG17_RAD ((int)(0.5*ResPT))
X#define MAG18_RAD ((int)(0.5*ResPT))
X#define MAG19_RAD ((int)(0.5*ResPT))
X#define MAG20_RAD ((int)(0.5*ResPT))
X
X#define MAG_NUMMAGS 40
X/* Large enough to hold to mag. 40 */
X
X/* Many things break if MAG_BRIGHT != -1; sorry, Sirius */
X#define MAG_BRIGHT -1
X#define MAG_DIM 20
X
Xstatic int magsizes[MAG_NUMMAGS]; /* Set in D_open or in D_control_arg */
X
X/* mag10: 10 refers to 1/10th magnitude binning */
X#define MAG_10_NUMMAGS MAG_NUMMAGS*10 + 1
Xstatic int mag10sizes[MAG_10_NUMMAGS];
X
X/* For Young's formula */
Xstatic double young_k = 0.11;
Xstatic double young_D0 = 0.5 * ResPT;
Xstatic double young_v0 = 10.0;
Xstatic int use_v0 = FALSE;
Xstatic int use_young = FALSE;
X
X/* Notebook mode controls */
X/* number of eyepiece/finder views */
X#define NOTE_NUMVIEWS 20
Xstatic double viewrad[NOTE_NUMVIEWS];
Xstatic int numviews;
Xstatic int notebook_mode = FALSE;
X
X/* brightest and faintest magnitudes used in first map */
Xstatic double brightest_used = 100.0, faintest_used = -1.0;
X/* used in legend */
Xmapwindow legend_window;
X
X/* shift thumbscale map magnitude */
Xstatic double thumbshift = 0.0;
X
X#ifndef MAXPATHLEN
X#define MAXPATHLEN 1025
X#endif
X
Xstatic char filname[MAXPATHLEN] = "";
Xstatic FILE *set_out_file = NULL;
Xstatic FILE *outf;
X
X/* Status variables */
Xstatic int cur_colr = -1;
Xstatic int c_font = -1, c_size = -1;
Xstatic int cur_x = -1, cur_y = -1;
Xstatic int cur_sty = SOLID;
Xstatic int radii_set = FALSE;
X
X/* Set value to draw smooth circles with minimum number of chords */
Xstatic int curve_val = ResPT / 3;
X
X
X                       /* Physical Plot Size Constants */
X#define MAX_SIZE  0   
X#define A_SIZE    1
X#define B_SIZE    2  
X#define C_SIZE    3 
X#define D_SIZE    4
X#define E_SIZE    5 
X
X            /* Plot dimensions in HP-GL/2 plotter units (1016 pu/inch) */
X            /* A-size = 8.5"x11" paper (usually an 8"x10" print area)  */
X            /* B-size = 11"x17"   (The print areas of B through E      */
X            /* C-size = 17"x22"    size media is usually about one     */
X            /* D-size = 22"x34"    inch shorter in each axis than the  */
X            /* E-size = 34"x44"    physical paper dimensions.)         */
X
Xstatic int plot_length[] = { -1, 10160, 16256, 21336, 33528, 43688 }; 
Xstatic int plot_width[]  = { -1,  8128, 10160, 16256, 21336, 33528 };
Xstatic int plot_size = MAX_SIZE;
Xstatic double scaling_factor = 1;    /* Used for adjusting plot sizes */
X
X
Xdouble plot_scale()    /* Calculates the scale of the selected plot size */
X     {                 /* relative to an A-size (8.5x11) plot.           */
X     double scale;
X     if( plot_size >= A_SIZE && plot_size <= E_SIZE )
X          {
X          double A_xlen, A_ylen, cur_xlen, cur_ylen;
X          double A_diagonal, cur_diagonal;
X
X          A_xlen = (double) plot_length[ A_SIZE ];
X          A_ylen = (double) plot_width[ A_SIZE ];
X          cur_xlen = (double) plot_length[ plot_size ];
X          cur_ylen = (double) plot_width[ plot_size ];
X
X          A_diagonal = sqrt( A_xlen*A_xlen + A_ylen*A_ylen );
X          cur_diagonal = sqrt( cur_xlen*cur_xlen + cur_ylen*cur_ylen );
X
X          scale = A_diagonal / cur_diagonal;
X          return( scale );
X          }
X     else
X          {
X          scale = 1;
X          return( scale );
X          }
X     }
X
X
X                       /* Constants used in font selection */
X
X#define CS_STANDARD 277     /* Font character set codes */
X#define CS_MATH8    269
X
X#define SW_MEDIUM 0         /* Font stroke weight codes */
X#define SW_BOLD   3
X
X#define FP_UPRIGHT 0        /* Font posture codes */
X#define FP_ITALIC  1
X
X#define TF_TMSRMN  5        /* Font typeface codes */
X#define TF_UNIVERS 25
X#define TF_COURIER 3
X
X#define UNDEFINED (-999)
X
X#define PEN_UP     1
X#define PEN_DOWN   2
X
Xstatic int f_charset = CS_STANDARD; /* Default to standard Times-Roman font */
Xstatic int f_sweight = SW_MEDIUM;
Xstatic int f_posture = FP_UPRIGHT;
Xstatic int f_typeface = TF_TMSRMN;
Xstatic int f_size = 12;
X
Xstatic int c_f_charset = UNDEFINED;
Xstatic int c_f_sweight = UNDEFINED;
Xstatic int c_f_posture = UNDEFINED;
Xstatic int c_f_typeface = UNDEFINED;
Xstatic int c_f_size = UNDEFINED;
X
X
X/* The following dimensional information specifies the number of units */
X/* in each of the x- and y-axes, and the x- and y-offsets for each of  */
X/* the different size maps.  For A-size (8.5"x11") charts, there are   */
X/* 3024 units per inch, each ResPT is 1/72 inch, and each InchPT is    */
X/* one inch.  As page sizes increase, these numbers change.  For       */
X/* E-size (34"x44") plots for instance, there about 760 units per      */
X/* inch, each ResPT about is 1/18 inch, and each InchPT is roughly     */
X/* four inches.                                                        */
X
X/* Exports */
X
X/* Full page map:  7"x9.5", y-offset=1/2 inch, x-offset = 1/4 inch */
Xmapwindow fullpage = { 7*InchPT, 9.5*InchPT, 0.5*InchPT, 0.125*InchPT,
X                       8.0, 3.0, 2.05, FULLPAGEMAP, 0, "String",
X                       SANSONS, FALSE, FALSE, 7.5, 5.0, 0.0, 0.0, FALSE };
X
X/* Main map:       7"x7",   y-offset=1/4 inch, x-offset = 2.75 inches */
Xmapwindow mainmap = {  7*InchPT, 7*InchPT, 0.25*InchPT, 2.75*InchPT,
X                       8.0, 3.0, 2.05, MAINMAP, 0, "String",
X                       SANSONS, FALSE, FALSE, 7.5, 5.0, 0.0, 0.0, FALSE };
X
X/* Thumb map:      3.5"x2",   y-offset=3.57 inches, x-offset = 0.25 inch */
Xmapwindow thumbmap = { 3.5*InchPT, 2*InchPT, 3.75*InchPT, 0.25*InchPT,
X                       6.2+THMADJ, 1.0+THMADJ, 2.05+THMADJ, 
X                       THUMBNAIL, 0,"String", SANSONS, FALSE, FALSE, 7.5, 5.0,
X                       0.0, 0.0, FALSE };
X
X/* h & v tick text controls */
Xint htick_lim = 1*ResPT;
Xint htext_lim = 36*ResPT;
Xint htext_xoff = 0*ResPT;
Xint htext_yoff = 10*ResPT;
Xint vtick_lim = 1*ResPT;
Xint vtext_lim = 10*ResPT;
Xint vtext_xoff = 9*ResPT;
Xint vtext_yoff = 0*ResPT;
X
X/* Variables used for legend generation */
Xint x_nameoffset = MAG0_RAD+ResPT, y_nameoffset = 0;
Xint x_lbloffset = MAG3_RAD, y_lbloffset = MAG3_RAD+ResPT/2;
Xint x_magoffset = MAG3_RAD+ResPT, y_magoffset = -MAG3_RAD-ResPT;
X
X
X/* Scale multiplier, minimum,
X   mangitude change, maximum, for thumbnail,*/
Xdouble th_smul=THSMUL;
Xdouble th_smin=THSMIN;
Xdouble th_madj=THMADJ;
Xdouble th_mmax=THMMAX;
X
X#define MAX(a,b) ((a)>(b)?(a):(b))
X#define MIN(a,b) ((a)<(b)?(a):(b))
X
Xvoid out( s )
Xconst char *s;
X     {
X     fprintf( outf, "%s", s );
X     }
X
X#define UNKNOWN -1
X
Xstatic int use_fine_mag = FALSE;   /* Use 10ths of magnitude */
Xstatic int color_hpgl = FALSE;    
Xstatic int landscape = FALSE;
Xstatic int lost = TRUE;            /* Drawing cursor position unclear */
Xstatic int pen_up = UNKNOWN;
X
X                       /* Define color constants */
X
X#define BLACK 0
X#define WHITE 1
X#define RED 2
X#define ORANGE 3
X#define YELLOW 4
X#define GREEN 5
X#define CYAN 6
X#define BLUE 7
X#define VIOLET 8
X#define BLUE_WHITE 9
X
X                       /* Set up spectral class color index table */
X
Xstatic char *table = "OBAFGKMCRNSrgbycpow";
X
Xstatic int super_spectra[][10] = {
X    /*         0   1   2   3   4   5   6   7   8   9   */
X    /* O */ { 32, 32, 32, 32, 32, 32, 32, 32, 32, 32 },
X    /* B */ {  0,  1,  2,  3,  3,  4,  4,  4,  5,  6 },
X    /* A */ {  7,  7,  8,  9,  9, 10, 10, 10, 10, 10 },
X    /* F */ { 11, 11, 12, 12, 12, 13, 13, 13, 14, 14 },
X    /* G */ { 15, 15, 15, 15, 15, 16, 16, 16, 16, 16 },
X    /* K */ { 17, 17, 18, 18, 18, 19, 19, 19, 19, 19 },
X    /* M */ { 20, 20, 21, 22, 23, 24, 25, 26, 26, 26 },
X    /* C */ { 27, 27, 27, 28, 28, 28, 28, 28, 29, 30 },
X    /* R */ { 27, 27, 27, 28, 28, 28, 28, 28, 29, 30 },
X    /* N */ { 27, 27, 27, 28, 28, 28, 28, 28, 29, 30 },
X    /* S */ { 30, 30, 30, 30, 31, 31, 31, 31, 31, 31 },
X    /* r */ { 33, 33, 33, 34, 34, 34, 35, 35, 35, 36 },
X    /* y */ { 37, 37, 37, 38, 38, 38, 39, 39, 39, 40 },
X    /* g */ { 41, 41, 41, 42, 42, 42, 43, 43, 43, 44 },
X    /* c */ { 45, 45, 45, 46, 46, 46, 47, 47, 47, 48 },
X    /* b */ { 49, 49, 49, 50, 50, 50, 51, 51, 51, 52 },
X    /* p */ { 53, 53, 53, 54, 54, 54, 55, 55, 55, 56 },
X    /* o */ { 57, 57, 57, 58, 58, 58, 59, 59, 59, 60 },
X    /* w */ { 61, 61, 61, 62, 62, 62, 63, 63, 63, 64 }
X          };
X
X/*                     Set up RGB color table */
X
X  static struct {double r, g, b;} ctab[] = {
X
X/*            Red  Grn  Blu       Color        */
X
X/*  0 */    { 1.0, 1.0, 1.0 },   /* BLACK */
X/*  1 */    {   0,   0,   0 },   /* WHITE */
X/*  2 */    { 1.0,   0,   0 },   /* RED */
X/*  3 */    { 1.0, 0.4,   0 },   /* ORANGE */
X/*  4 */    { 1.0, 1.0,   0 },   /* YELLOW */
X/*  5 */    {   0, 1.0,   0 },   /* GREEN */
X/*  6 */    {   0, 1.0, 1.0 },   /* CYAN */
X/*  7 */    {   0,   0, 1.0 },   /* BLUE */
X/*  8 */    { 1.0,   0, 1.0 },   /* VIOLET */
X/*  9 */    { .5, .5, 1.0 },     /* BLUE_WHITE */
X
X/*              Red             Green           Blue          Nameby which
X                                                             type is known */
X/* 10 */    { 0.38937,        0.46526,        0.79493 },    /* B0 */
X/* 11 */    { 0.39501,        0.47146,        0.78847 },    /* B1 */
X/* 12 */    { 0.40103,        0.47792,        0.78151 },    /* B2 */
X/* 13 */    { 0.40640,        0.48355,        0.77526 },    /* B3 */
X/* 14 */    { 0.41341,        0.49071,        0.76701 },    /* B5 */
X/* 15 */    { 0.43251,        0.50914,        0.74412 },    /* B8 */
X/* 16 */    { 0.44342,        0.51897,        0.73079 },    /* B9 */
X/* 17 */    { 0.45181,        0.52618,        0.72042 },    /* A0 */
X/* 18 */    { 0.46931,        0.54026,        0.69847 },    /* A2 */
X/* 19 */    { 0.47958,        0.54792,        0.68541 },    /* A3 */
X/* 20 */    { 0.48538,        0.55205,        0.67797 },    /* A5 */
X/* 21 */    { 0.50879,        0.56731,        0.64752 },    /* F0 */
X/* 22 */    { 0.51732,        0.57231,        0.63627 },    /* F2 */
X/* 23 */    { 0.52348,        0.57573,        0.62810 },    /* F5 */
X/* 24 */    { 0.54076,        0.58447,        0.60496 },    /* F8 */
X/* 25 */    { 0.54853,        0.58799,        0.59446 },    /* G0 */
X/* 26 */    { 0.56951,        0.59623,        0.56584 },    /* G5 */
X/* 27 */    { 0.58992,        0.60244,        0.53765 },    /* K0 */
X/* 28 */    { 0.61098,        0.60693,        0.50828 },    /* K2 */
X/* 29 */    { 0.63856,        0.60977,        0.46950 },    /* K5 */
X/* 30 */    { 0.68698,        0.60595,        0.40110 },    /* M0 */
X/* 31 */    { 0.72528,        0.59434,        0.34744 },    /* M2 */
X/* 32 */    { 0.75182,        0.58144,        0.31097 },    /* M3 */
X/* 33 */    { 0.78033,        0.56272,        0.27282 },    /* M4 */
X/* 34 */    { 0.81066,        0.53676,        0.23394 },    /* M5 */
X/* 35 */    { 0.84247,        0.50195,        0.19570 },    /* M6 */
X/* 36 */    { 0.87512,        0.45667,        0.16004 },    /* M7 */
X/* 37 */    { 0.71033,        0.59983,        0.36829 },    /* N0 */
X/* 38 */    { 0.78625,        0.55816,        0.26507 },    /* N3 */
X/* 39 */    { 0.93792,        0.33011,        0.10649 },    /* N8 */
X/* 40 */    { 0.94897,        0.29906,        0.10012 },    /* N9 */
X/* 41 */    { 0.79832,        0.54811,        0.24950 },    /* S4 */
X/* 42 */    { 0.38241,        0.45743,        0.80282 },    /* O  */
X
X/*                R  G  B             Color and intensity */
X
X/* 43 */    { 0.500, 0, 0},              /* r0 */
X/* 44 */    { 0.750, 0, 0},              /* r3 */
X/* 45 */    { 0.875, 0, 0},              /* r6 */
X/* 46 */    { 1.000, 0, 0},              /* r9 */
X/* 47 */    { 0, 0.500, 0},              /* g0 */
X/* 48 */    { 0, 0.750, 0},              /* g3 */
X/* 49 */    { 0, 0.875, 0},              /* g6 */
X/* 50 */    { 0, 1.000, 0},              /* g9 */
X/* 51 */    { 0, 0, 0.500},              /* b0 */
X/* 52 */    { 0, 0, 0.750},              /* b3 */
X/* 53 */    { 0, 0, 0.875},              /* b6 */
X/* 54 */    { 0, 0, 1.000},              /* b9 */
X/* 55 */    { 0.500, 0.500, 0},          /* y0 */
X/* 56 */    { 0.750, 0.750, 0},          /* y3 */
X/* 57 */    { 0.875, 0.875, 0},          /* y6 */
X/* 58 */    { 1.000, 1.000, 0},          /* y9 */
X/* 59 */    { 0, 0.500, 0.500},          /* c0 */
X/* 60 */    { 0, 0.750, 0.750},          /* c3 */
X/* 61 */    { 0, 0.875, 0.875},          /* c6 */
X/* 62 */    { 0, 1.000, 1.000},          /* c9 */
X/* 63 */    { 0.500, 0, 0.500},          /* p0 */
X/* 64 */    { 0.750, 0, 0.750},          /* p3 */
X/* 65 */    { 0.875, 0, 0.875},          /* p6 */
X/* 66 */    { 1.000, 0, 1.000},          /* p9 */
X/* 67 */    { 0.500, 0.250, 0.000},      /* o0 */
X/* 68 */    { 0.750, 0.375, 0.000},      /* o3 */
X/* 69 */    { 0.875, 0.4375, 0.000},     /* o6 */
X/* 70 */    { 1.000, 0.500, 0.000},      /* o9 */
X/* 71 */    { 0.500, 0.500, 0.500},      /* w0 */
X/* 72 */    { 0.750, 0.750, 0.750},      /* w3 */
X/* 73 */    { 0.875, 0.875, 0.875},      /* w6 */
X/* 74 */    { 1.000, 1.000, 1.000},      /* w9 */
X          };
X
X
X/* Store star RGB color values in HP-GL/2 pen color table */
Xvoid store_colors()
X     {
X     int pen = 0;
X
X     if( color_hpgl == FALSE )
X          return;
X
X     fprintf( outf, "\nCO \"Define star color spectra table:\"\n" );
X     for( pen = 0 ; pen <= 74 ; pen++ )
X          fprintf( outf, "PC%2d,%3.0f,%3.0f,%3.0f;\n", pen, 
X                          ctab[pen].r*255, ctab[pen].g*255, ctab[pen].b*255 );
X     }
X
X
X/* Rotate coordinate (x,y) through angle theta */
Xvoid rotate( x, y, theta )
Xint *x, *y;
Xdouble theta;
X     {
X     double x1, y1, a;
X
X     a = theta * 0.0174532925199;
X     x1 = (double) *x;  
X     y1 = (double) *y;
X
X     *x = (int) (x1 * cos(a) - y1 * sin(a));
X     *y = (int) (y1 * cos(a) + x1 * sin(a));
X     }
X
X
X/* Draw from current pen postition to rotated coordinate position */
Xvoid draw_rot( x, y, theta, state )
Xint x, y, state;
Xdouble theta;
X     {
X     double x1, y1, a;
X  
X     a = theta * 0.0174532925199; 
X     x1 = (double) x * cos(a) - (double) y * sin(a);
X     y1 = (double) y * cos(a) + (double) x * sin(a);
X
X     if( state == PEN_UP )
X          fprintf( outf, "PU%.0f,%.0f", x1, y1 );
X     else
X          fprintf( outf, "PD%.0f,%.0f", x1, y1 );
X     }
X
X
X/* Device control argument */
XD_control_arg(s)
Xchar *s;
X{
X  int i = 0, j, k;
X  int c;
X  char *cp;
X
X  i = 0;
X  while (c = s[i++]) switch (c) {
X  case 'm':
X    /* m [mag-1 : mag0 : mag1 : mag2 : ...] */
X    use_fine_mag = TRUE;
X    if (s[i]) {
X      cp = &s[i];
X      /* Skip leading white space */
X      while ((*cp == ' ') || (*cp == '\t')) {
X        i++;
X        cp++;
X      }
X      j = 0;
X      while (*cp) {
X        radii_set = TRUE;
X        if (j < MAG_NUMMAGS) magsizes[j++] = atof(cp) * ResPT;
X        while (isdigit(*cp) || (*cp == '.')) {
X          i++;
X          cp++;
X        }
X        if (*cp) cp++;
X      }
X      for (k = j;k < MAG_NUMMAGS; k++)
X        magsizes[k] = magsizes[j];
X    }
X    break;
X  case 'f':
X    /* f [file] */
X    if (s[i++] == ' ')
X      if (s[i])
X        strcpy(filname, &s[i]);
X    while ((s[i]) && (s[i] != ' ')) i++;
X    break;
X  case 'c':
X    /* c */
X    color_hpgl = TRUE;
X    break;
X  case 'l':
X    /* l */
X    landscape = TRUE;
X    chart_type = FULLPAGE;
X    break;
X  case 'n':   
X              /* n [rad1 : rad2 : rad3 : ... ] */
X   notebook_mode = TRUE;
X   chart_type = THREEPART;
X   j = 0;
X   if( s[i] )
X        {
X        cp = &s[i];
X        /* Skip leading white spaces */
X        while ((*cp == ' ') || (*cp == '\t')) {
X             i++;
X             cp++;
X             }
X        while ((*cp) && (isdigit(*cp) || (*cp == '.'))) {
X             if (j < NOTE_NUMVIEWS) viewrad[j++] = atof(cp)/2.0;
X                                             /* It's input as diameter */
X             while (isdigit(*cp) || (*cp == '.')) {
X                  i++;
X                  cp++;
X                  }
X             if (*cp) cp++;
X             }
X        }
X   numviews = j;
X   break;
X  case 'A':  /* A size chart */
X    plot_size = A_SIZE;
X    break;
X  case 'B':  /* B size chart */
X    plot_size = B_SIZE;
X    break;
X  case 'C':  /* C size chart */
X    plot_size = C_SIZE;
X    break;
X  case 'D':  /* D size chart */
X    plot_size = D_SIZE;
X    break;
X  case 'E':  /* E size chart */
X    plot_size = E_SIZE;
X    break;
X  case 'L':  /* Scale plot for LaserJets */
X    plot_size = MAX_SIZE;
X    break;
X  default:
X    break;
X  }
X}
X
X
X/* Open the device */
XD_open()
X{
X  int i, j;
X  int hshift, vshift;
X  double young_size;
X
X  if (filname[0] != '\0') {
X    set_out_file = fopen(filname, "w");
X  };
X   if (set_out_file != NULL)
X    outf = set_out_file;
X  else
X    outf = stdout;      /* WARNING: This might not work on some systems */
X
X  /* Need to initialize all variables */
X  cur_colr = -1;
X  c_font = -1;
X  c_size = -1;
X  cur_x = -1;
X  cur_y = -1;
X
X  scaling_factor = plot_scale();
X
X                          /* Initialize plotter for HP-GL/2 mode */
X
X  out( "\033%-1BBPIN;\n\n" );
X  out( "CO \"Star map generated with StarChart version 3.2 \n" );
X  out( "    by Alan Paeth and Craig Counterman \n" );
X  out( "    using the HP-GL/2 driver StarHP version 1.0 \n" );
X  out( "    by Kirk Norton (kirk@sdd.hp.com).\";\n\n" );
X
X                               /* Set page size and scaling */
X  if( A_SIZE <= plot_size && plot_size <= E_SIZE )
X       {
X       fprintf( outf, "PS%d,%d", plot_length[ plot_size ], plot_width[ plot_size ] );
X       curve_val = (int) ((double) curve_val * scaling_factor);
X       if( plot_size > C_SIZE )
X            curve_val = (int) ((double) curve_val / 1.5);
X       }
X
X  if (landscape && notebook_mode == FALSE) { /* Change scaling for landscape */
X       D_comment( "landscape mode" );
X       hshift = (int) (0.5 * InchPT);
X       vshift = (int) -(0.5 * InchPT);
X       if( plot_size == MAX_SIZE )  
X            out( "RO270;" );
X       else
X            out( "RO0;" );
X       fprintf( outf, "IPSC%d,%d,%d,%d,1;\n", 
X                       hshift, 10*InchPT+hshift, vshift, 8*InchPT+vshift ); 
X       i = fullpage.width;
X       fullpage.width = fullpage.height;
X       fullpage.height = i;
X       }
X  else {
X       if( notebook_mode == FALSE )
X            hshift = (int) (0.25 * InchPT);
X       else
X            hshift = (int) -(0.05 * InchPT);
X       if( chart_type == FULLPAGE )
X            vshift = (int) -(0.15 * InchPT);
X       else
X            vshift = (int) 0;
X       if( plot_size == MAX_SIZE )
X            out( "RO0;" );
X       else
X            out( "RO270;" );
X       fprintf( outf, "IPSC%d,%d,%d,%d,1;\n", 
X                       hshift, 8*InchPT+hshift, vshift, 10*InchPT+vshift ); 
X       }
X
X  out( "TR0NP128LA1,4,2,4DT@QL100CT1UL1,50,50PW0.13;\n" ); 
X
X  cur_x = 0;
X  cur_y = 0;
X  lost = FALSE;
X  cur_sty = SOLID;
X  pen_up = UNKNOWN;
X  store_colors();
X  out( "LTPUPA0,0PRSD2,1SSSP1" );
X
X                             /* Adjust text offsets for current plot size */
X  if( A_SIZE <= plot_size && plot_size <= E_SIZE )
X       {
X       htext_xoff = (int) ((double) htext_xoff * scaling_factor); 
X       htext_yoff = (int) ((double) htext_yoff * scaling_factor);
X       vtext_xoff = (int) ((double) vtext_xoff * scaling_factor);
X       vtext_yoff = (int) ((double) vtext_yoff * scaling_factor);
X       x_nameoffset = (int) ((double) x_nameoffset * scaling_factor);
X       y_nameoffset = (int) ((double) y_nameoffset * scaling_factor);
X       x_lbloffset = (int) ((double) x_lbloffset * scaling_factor);
X       y_lbloffset = (int) ((double) y_lbloffset * scaling_factor);
X       x_magoffset = (int) ((double) x_magoffset * scaling_factor);
X       y_magoffset = (int) ((double) y_magoffset * scaling_factor);
X       }
X                             /* set array of magnitude radii */
X  if (radii_set == FALSE)  
X       {
X       magsizes[0] = MAG_1_RAD;
X       magsizes[1] = MAG0_RAD;
X       magsizes[2] = MAG1_RAD;
X       magsizes[3] = MAG2_RAD;
X       magsizes[4] = MAG3_RAD;
X       magsizes[5] = MAG4_RAD;
X       magsizes[6] = MAG5_RAD;
X       magsizes[7] = MAG6_RAD;
X       magsizes[8] = MAG7_RAD;
X       magsizes[9] = MAG8_RAD;
X       magsizes[10] = MAG9_RAD;
X       magsizes[11] = MAG10_RAD;
X       magsizes[12] = MAG11_RAD;
X       magsizes[13] = MAG12_RAD;
X       magsizes[14] = MAG13_RAD;
X       magsizes[15] = MAG14_RAD;
X       magsizes[16] = MAG15_RAD;
X       magsizes[17] = MAG16_RAD;
X       magsizes[18] = MAG17_RAD;
X       magsizes[19] = MAG18_RAD;
X       magsizes[20] = MAG19_RAD;
X       magsizes[21] = MAG20_RAD;
X       for (i = 22; i < MAG_NUMMAGS; i++)
X            {
X            magsizes[i] = MAG10_RAD;
X            }
X       radii_set = TRUE;
X       }
X
X  /* Thumbshift */
X  if ((numwins == 2) && (mapwin[1]->map_type == THUMBNAIL)) {
X    thumbshift = mapwin[0]->maglim - MIN(th_mmax,
X                                         mapwin[1]->maglim - th_madj);
X  }
X
X
X  if (use_fine_mag) {
X    /* use fine (continuous) magnitude scale */
X
X    if (use_young) {
X      /* set magsizes according to Young's formula,
X         Sky and Telescope, March 1990, p. 311 */
X      if (!use_v0) young_v0 = mapwin[0]->maglim;
X      for (i = 0; i < MAG_10_NUMMAGS; i++) {
X        /* magsizes[i] is for magnitude (i - 1) */
X        /* brightest mag10sizes is for mag -1.0 */
X        young_size = young_D0 * exp(log(10.0)*young_k*(young_v0 - (i/10.0-1)));
X        if (young_size <  1) young_size = 1;
X        mag10sizes[i] = (int) (young_size + 0.5);
X      }
X    } 
X    else {
X      for (i = 0; i < (MAG_NUMMAGS-1); i++)
X        for (j = 0; j < 10; j++)
X          mag10sizes[i*10 + j] =
X            magsizes[i] - j*(magsizes[i] - magsizes[i+1])/10.0;
X      mag10sizes[(MAG_NUMMAGS-1)*10] = magsizes[MAG_NUMMAGS-1];
X      }
X    }
X  return TRUE ;				/* open successful */
X}
X
X
X/* Close the device */
XD_close()                               /* Terminate the HP-GL file */
X{
X  if( notebook_mode == TRUE )
X       add_notes();
X  out( ";PUSP0PG;" );
X  fflush( outf );
X  fclose( outf );
X}
X
X
Xset_line_type( style )       /* Select solid, dashed, or dotted lines */
Xint style;
X     {
X     if( style != cur_sty )
X          {
X          switch( style )
X               {
X               case DOTTED:
X               case VECDOT:
X                 out( "LT1,1,1" );
X                 break;
X               case DASHED:
X               case VECDASH:
X                 out( "LT2,3,1" );
X                 break;
X               default:
X                 out( "LT;" );
X               }
X          pen_up = UNKNOWN;
X          }
X     cur_sty = style;
X     }
X
X
X/* Move to (x, y) */
XD_move(x, y)
X     int x, y;
X{
X  int dx, dy;
X
X  dx = x - cur_x;      /* Get coordinates relative to current position */
X  dy = y - cur_y;
X
X  if( dx == 0 && dy == 0 && lost == FALSE )
X    return;
X
X  if( lost == FALSE )   /* Move relative to current position */
X    {
X    if( pen_up != TRUE )
X      out( "PU" );
X    else 
X      out( "," );
X    fprintf( outf, "%d,%d", dx, dy );
X    cur_x += dx;
X    cur_y += dy;
X    }
X  else                  /* Move to absolute coordinates */
X    {
X    if( pen_up != TRUE )
X      out( "PU" );
X    fprintf( outf, "PA%d,%dPR", x, y );
X    lost = FALSE;
X    cur_x = x;
X    cur_y = y;
X    }
X  pen_up = TRUE;
X}
X
X
X/* Line to (x, y) */
Xdraw_line( x, y, style )
X     int x, y, style;
X{
X  int dx, dy;
X
X  dx = x - cur_x;      /* Get coordinates relative to current position */
X  dy = y - cur_y;
X
X  if( cur_function == CHRTVTICK || cur_function == CHRTHTICK )
X    {
X    dx *= (   ResPT / 4 ); /* This is necessary since the tick function sends */
X    dy *= ( - ResPT / 4 ); /* absolute length values instead of scaled ones.  */ 
X                           /*   (It took me forever to track down this one!)  */
X    if( A_SIZE <= plot_size && plot_size <= E_SIZE )
X       {
X       dx = (int) ((double) dx * scaling_factor);
X       dy = (int) ((double) dy * scaling_factor);
X       }
X    }
X
X  set_line_type( style );
X  if( lost == FALSE )   /* Draw relative to current position */
X    {
X    if( pen_up != FALSE )
X      out( "PD" );
X    else 
X      out( "," );
X    fprintf( outf, "%d,%d", dx, dy );
X    cur_x += dx;
X    cur_y += dy;
X    }
X  else                  /* Draw to absolute coordinates */
X    {
X    if( pen_up != FALSE )
X      out( "PD" );
X    fprintf( outf, "PA%d,%dPR", x, y );
X    lost = FALSE;
X    cur_x = x;
X    cur_y = y;
X    }
X  pen_up = FALSE;
X}
X
X
X/* Draw a line of style line_style from the current point to (x, y) */
XD_draw(x, y, line_style)
X     int x, y;
X     int line_style;	/* SOLID, DOTTED, DASHED, etc. */
X{
X  int sty;
X
X  if ((x != cur_x) || (y != cur_y) || (line_style != cur_sty)) {
X    switch(cur_function) {
X    case CHRTOUTLN:
X    case CHRTHTICK:
X    case CHRTVTICK:
X      sty = SOLID;
X      break;
X    case GRID_RA:
X    case GRID_DEC:
X      sty = DOTTED;
X      break;
X    case ECLIPT:
X      sty = DOTTED;
X      break;
X    case CONSTBOUND:
X      sty = DASHED;
X      break;
X    case CONSTPATTRN:
X      sty = SOLID;
X      break;
X    case CONSTNAME:
X    case CHARTFILE:
X    default:
X      sty = line_style;
X      break;
X    }
X  if( cur_colr == UNKNOWN )
X    {
X    out( "SP1" );
X    cur_colr = 1;
X    }
X  draw_line( x, y, sty );
X  }
X}
X/* This routine is encouraged to look at the extern cur_funtion
X   and change the line style drawn as desired */
X
X
X/* Move to (x1, y1) then draw a line of style line_style to (x2, y2) */
XD_movedraw(x1, y1, x2, y2, line_style)
X     int x1, y1, x2, y2;
X     int line_style;	/* SOLID, DOTTED, DASHED, etc. */
X{
X  D_move(x1, y1);
X  D_draw(x2, y2, line_style);
X}
X
Xstatic struct {int x,y;} areapts[1000];
Xstatic int nareapts;
X/* Move to (x, y) to begin an area */
XD_areamove(x, y)
X     int x, y;
X{
X  nareapts = 0;
X  areapts[nareapts].x = x;
X  areapts[nareapts].y = y;
X  nareapts++;
X}
X
X/* Add a segment to the area border */
XD_areaadd(x, y)
X     int x, y;
X{
X  areapts[nareapts].x = x;
X  areapts[nareapts].y = y;
X  nareapts++;
X}
X
X/* Fill the area, after adding the last segment */
XD_areafill(x, y)
X     int x, y;
X{
X  int i;
X
X  areapts[nareapts].x = x;
X  areapts[nareapts].y = y;
X  nareapts++;
X
X
X  D_move(areapts[0].x, areapts[0].y);
X  out( "PM0" );
X
X  for (i = 1; i < nareapts; i++)
X    draw_line( areapts[i].x, areapts[i].y, cur_sty );
X  out( "PM2FP" );
X  pen_up = UNKNOWN;
X
X}
X
X
X
X/* Set the color to be used for lines and text */
X/* color_str is a 2 char (+ '\0') string containing
X   a specification for a color,
X   e.g. "G2" for the color of a star of spectral class G2, or "r7" for
X   red, level seven.  The interpretation of the color string is left to
X   the device driver */
XD_color(color_str)
Xchar *color_str;
X     {
X     int class, subclass, colr;
X     if( color_hpgl == FALSE )
X          {
X          if( cur_colr != 1 )
X               {
X               out( "SP1" );
X               pen_up = UNKNOWN;
X               cur_colr = 1;
X               }
X          return;
X          }
X
END_OF_FILE
  if test 31028 -ne `wc -c <'starhp.c.A'`; then
    echo shar: \"'starhp.c.A'\" unpacked with wrong size!
  elif test -f 'starhp.c.B'; then
    echo shar: Combining  \"'starhp.c'\" \(67818 characters\)
    cat 'starhp.c.A' 'starhp.c.B' > 'starhp.c'
    if test 67818 -ne `wc -c <'starhp.c'`; then
      echo shar: \"'starhp.c'\" combined with wrong size!
    else
      rm starhp.c.A starhp.c.B
    fi
  fi
  # end of 'starhp.c.A'
fi
echo shar: End of archive 2 \(of 2\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
