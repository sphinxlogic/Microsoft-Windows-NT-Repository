Newsgroups: comp.sources.misc
From: sadinoff@unagi.cis.upenn.edu (Danny Sadinoff)
Subject: v34i117:  hebcal - A Jewish calendar generator, Part01/01
Message-ID: <1993Jan18.172015.10848@sparky.imd.sterling.com>
X-Md4-Signature: feea80fc6683d1b8caacff1e44bf6875
Date: Mon, 18 Jan 1993 17:20:15 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: sadinoff@unagi.cis.upenn.edu (Danny Sadinoff)
Posting-number: Volume 34, Issue 117
Archive-name: hebcal/part01
Environment: UNIX
Supersedes: hebcal-1.2: Volume 33, Issue 71

            [ THIS PROGRAM IS SHAREWARE  -Kent+ ]

Hebcal 1.3 - a program for printing Jewish calendars
  by Danny Sadinoff

DESCRIPTION
Hebcal is a program which prints out the days in the Jewish calendar
for a given gregorian year.  Hebcal is fairly flexible in terms of which
events in the Jewish calendar it displays.  Each of the following can
be individualy turned on or off:

  The Hebrew date
  Jewish Holdiays (including Yom Ha'atzmaut and Yom HaShoah etc.)
  The weekly Sedrah
  The day of the week
  The days of the Omer

CHANGES 
  Fixed a critical bug which put Purim on the 15th of Adar, instead of
    the 14th
  Now uses sys/types.h instead of stdlib.h.  This will improve compatability
  Added the rest of the 8 days of Chanukah

DISTRIBUTION
This program is SHAREWARE. 
It may be distributed freely, with a few conditions:
   1) The package must be distributed INTACT with ALL source code, as
   well as this file.  You are welcome to modify the code,
   but DON'T distribute it modified.  This disclaimer should certainly
   appear with every distributed copy.
   
   2) You can use this program for free for one week.  After that
   trial period, if you wish to use this program, drop me a line.
   I'd like to know who you are, how you're using hebcal, and any
   thing else you'd like to tell me.  

   I am NOT demanding payment for the use of my program, but writing
   this program DID take time.  Feel free to send $10 to
   me at my US Mail address. (hint)

   send US Mail to:        send email to:
    Danny Sadinoff	   sadinoff@eniac.seas.upenn.edu
    1 Cove La. 
    Great Neck, NY 11024

   Email respondents will receive notifications of new versions as they
   come out, as will US Mail responents (if they send me postage for a disk).

   If you do not mail me or email me after one week, please don't
   use the program, although you may feel free to distribute it further.
 
COMPILATION
The code has K&R "old style" declarations in it, so it should compile
on most machines.

The distribution includes a "Makefile" so once you've unpacked all the
files, just run the command "make" and that should compile everything
for you.

The file hebcal.l is the manual page.  For information on using man in
conjunction with local manpages, see the manpage for man.  Briefly, to
read a manpage in its original format, type 
nroff -man <filename> | more
--------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  README Makefile danlib.c danlib.h error.c error.h greg.c
#   greg.h hebcal.c hebcal.l test.c
# Wrapped by kent@sparky on Sun Jan 17 15:21:07 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 1)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(5599 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
XHebcal 1.3 - a program for printing Jewish calendars
X  by Danny Sadinoff
X
XDESCRIPTION
XHebcal is a program which prints out the days in the Jewish calendar
Xfor a given gregorian year.  Hebcal is fairly flexible in terms of which
Xevents in the Jewish calendar it displays.  Each of the following can
Xbe individualy turned on or off:
X
X  The Hebrew date
X  Jewish Holdiays (including Yom Ha'atzmaut and Yom HaShoah etc.)
X  The weekly Sedrah
X  The day of the week
X  The days of the Omer
X
XCHANGES 
XSince version 1.1, the following changes were made:
X  Changed usage-- the -p "parshiot" switch was changed to "-s" sedrot switch
X  Fixed certain slippery variable type bugs
X  Changed code to K&R old style
X  Added Manpage
X  Decided to change the "Distribu-Ware" to a normal shareware.
X
XSince version 1.2:
X  Fixed a critical bug which put Purim on the 15th of Adar, instead of
X    the 14th
X  Now uses sys/types.h instead of stdlib.h
X  Added the rest of the 8 days of Chanukah
X
X
XDISTRIBUTION
XThis program is SHAREWARE. 
XIt may be distributed freely, with a few conditions:
X   1) The package must be distributed INTACT with ALL source code, as
X   well as this file.  You are welcome to modify the code,
X   but DON'T distribute it modified.  This disclaimer should certainly
X   appear with every distributed copy.
X   
X   2) You can use this program for free for one week.  After that
X   trial period, if you wish to use this program, drop me a line.
X   I'd like to know who you are, what version you're using, and how
X   you're using hebcal, and anything else you'd like to tell me.  
X
X   I am NOT demanding payment for the use of my program, but writing
X   this program DID take time.  Feel free to send $10 to
X   me at my US Mail address. (hint)
X
X   send US Mail to:        send email to:
X    Danny Sadinoff	   sadinoff@eniac.seas.upenn.edu
X    1 Cove La. 
X    Great Neck, NY 11024
X
X   Email respondents will receive notifications of new versions as they
X   come out, as will US Mail responents (if they send me postage for a disk).
X
X   If you do not mail me or email me after one week, please don't
X   use the program, although you may feel free to distribute it further.
X
X 
XCOMPILATION
XThe code has K&R "old style" declarations in it, so it should compile
Xon most machines.
XThe distribution includes a "Makefile" so once you've unpacked all the
Xfiles, (including this one) just run the command "make" and that
Xshould compile everything for you.
X
XThe file hebcal.l is the manual page.  For information on using man in
Xconjunction with local manpages, see the manpage for man.  Briefly, to
Xread a manpage, type 
Xnroff -man <filename> | more
X
X
XOPERATION:
XThe operation of hebcal is fairly simple.  Hebcal defaults to printing
Xout the holidays for the current gregorian year.  With the
Xcommand-line options, a specific gregorian year, month or date can be
Xspecified.  
X
XGiven one numeric argument, hebcal will print out the calendar 
Xfor that year.  Given two numeric argumetnts mm yyyy, it
Xprints out the calendar for month mm of year yyyy.  Given three
Xnumeric arguments mm dd yyyy, it will print out the hebrew calendar
Xentries for day dd of month mm of year yyyy.  In the last case, the -d
Xoption is automatically enabled.
X
XBe sure to give the whole year to hebcal.  
Xhebcal 92 will return the calendar for a time somewhere in the early
Xchristian era, not in the twentieth century.  Use hebcal 1992 instead.
X
Xusage: hebcal [-dehostTw] [[month [day]] year]  
X       hebcal help --- prints this message. 
X
XOPTIONS:  
X   -d : add hebrew dates
X   -e : use European dates (dd mm yyyy) for OUTPUT ONLY (input format
X        the same)
X   -h : suppress holidays
X   -o : add days of the omer
X   -s : add weekly sedrot
X   -t : only output today's date.  This switch implies the -d switch.
X   -T : only output today's date, suppressing gregorian date. This
X        switch implies the -d and -o switches.
X   -w : add day of the week
X
X
XExamples: 
Xexample% hebcal -ho
X4/19/1992 1st day of the Omer
X4/20/1992 2nd day of the Omer
X4/21/1992 3rd day of the Omer
X4/22/1992 4th day of the Omer
X4/23/1992 5th day of the Omer
X4/24/1992 6th day of the Omer
X.
X.
X6/5/1992 48th day of the Omer
X6/6/1992 49th day of the Omer
X
Xto print out all of the data pertaining to today's date, use
X
Xexample% hebcal -otw
X10/26/1992 Mon, 29 of Tishrei, 5753
X
Xto find out what's happening in today's Jewish calendar, use
X
Xexample% hebcal -T
X19 of Nisan, 5752
XPesach V (CH"M)
X4th day of the Omer
X
X
XDISCLAIMER
XI tried to make this program as accurate as possible.  However, I
Xtake no responsibility for any horrible consequences which may come
Xabout as a result of faulty output from this program.  Remember: never
Xtrust a program with a zero at the end of its revision number.
X
XThe secular dates before september 1752 are off by two weeks due to
Xthe correction that took place then.
X
XThe secular dates before 1522 become progressively meaningless, as I
Xmade no correction for the changeover from julian to gregorian
Xcalendars; but the Hebrew dates and years are correct.
X
XCOMING SOON
XFeatures to be included in future versions:
X  - need to add Yom Yerushalayim
X  - Arba' parshiot
X  - The ability to specify and output a particular HEBREW year, month
X    or date.   The absence of this feature is a serious drawback to
X    hebcal as it now stands.
X  - calendar-like operation with user specified "holidays", 
X       e.g. birthdays, yahrtzeits.
X  - yahrtzeit lists: calculate a list of dates in successive gregorian
X       years with the same Hebrew date.
X
X
XGRIPES
Xsend questions, comments or complaints to:
XDanny Sadinoff
Xsadinoff@eniac.seas.upenn.edu
END_OF_FILE
  if test 5599 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(91 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
XCFLAGS = -O
XOBJ= hebcal.o greg.o error.o danlib.o
Xhebcal:  $(OBJ)
X	 $(CC) $(OBJ) -o hebcal
END_OF_FILE
  if test 91 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'danlib.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'danlib.c'\"
else
  echo shar: Extracting \"'danlib.c'\" \(1227 characters\)
  sed "s/^X//" >'danlib.c' <<'END_OF_FILE'
X#include <sys/types.h>
X#include <ctype.h>
X#include "danlib.h"
X
X/* Some generally useful routines */
X  
Xvoid initStr(s,size)
Xchar **s;
Xint size;
X{
X  /* allocate space for a string */
X  if ((*s = (char *)malloc((size_t) (size + 1) * sizeof(char))) == NULL)
X    die("\n Memory Error: Couldn't allocate string\n","");
X
X  **s = '\0';
X}
X
Xint isAllNums(s)
Xchar * s;
X{
X/* returns true if a string contains only digits, dashes and newlines */
X  int n = 0, len = strlen(s);
X  
X  for(n=0;
X      (n < len)  &&  ( isdigit(s[n]) || (s[n] == '-') || (s[n] == '\n'));
X      n++);
X  return (n == len);
X}
X
Xchar * numSuffix(i)
Xint i;
X{
X/* returns a pointer to the proper ordinal suffix of a number */
X  switch (i % 10) {
X  case 1 : return "st";
X  case 2 : return "nd";
X  case 3 : return "rd";
X  default: return "th";
X  }
X}
X
Xchar * itoa (i) 
Xint i;
X{
X  static char ret[7];
X  int c = 0;
X  char tmp;
X
X  if (i < 0) {			/* is i negative? */
X    ret[c++] = '-';		/* then put a minus */
X    i = abs(i);
X  }
X  
X  while (i >0) {		/* compose the number */
X    ret[c++] = (i % 10) + '0';
X    i /= 10;
X  }
X  i = c-1;
X  
X  for (c =0; c < i; c++) {	/* reverse the number */
X    tmp = ret[c];
X    ret[c] = ret[i-c];
X    ret[i-c] = tmp;
X  } 
X
X  return ret;
X}
X 
X
END_OF_FILE
  if test 1227 -ne `wc -c <'danlib.c'`; then
    echo shar: \"'danlib.c'\" unpacked with wrong size!
  fi
  # end of 'danlib.c'
fi
if test -f 'danlib.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'danlib.h'\"
else
  echo shar: Extracting \"'danlib.h'\" \(135 characters\)
  sed "s/^X//" >'danlib.h' <<'END_OF_FILE'
X#include <stdio.h>
X#include "error.h"
X
X#define CHAR2NUM(x) ((x) - '0')
X
Xint isAllNums();
Xvoid initStr();
Xchar * numSuffix(), *itoa();
X
END_OF_FILE
  if test 135 -ne `wc -c <'danlib.h'`; then
    echo shar: \"'danlib.h'\" unpacked with wrong size!
  fi
  # end of 'danlib.h'
fi
if test -f 'error.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'error.c'\"
else
  echo shar: Extracting \"'error.c'\" \(609 characters\)
  sed "s/^X//" >'error.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "error.h"
X
X
Xextern int errno, sys_nerr;
Xextern char *sys_errlist[], *progname;
X
Xvoid die (s1,s2)	/* print error message and die */
Xchar *s1, *s2;
X{
X  if (progname)
X    fprintf(stderr, "%s: ", progname);
X  fprintf(stderr, s1, s2);
X  if (errno > 0 && errno < sys_nerr)
X    fprintf(stderr, " (%s)\n", sys_errlist[errno]);
X  exit(1);
X}
X
Xvoid warn (s1,s2) /* print error message but don't die */
Xchar *s1, *s2;
X{
X  if (progname)
X    fprintf(stderr, "%s: ", progname);
X  fprintf(stderr, s1, s2);
X  if (errno > 0 && errno < sys_nerr)
X    fprintf(stderr, " (%s)\n", sys_errlist[errno]);
X}
END_OF_FILE
  if test 609 -ne `wc -c <'error.c'`; then
    echo shar: \"'error.c'\" unpacked with wrong size!
  fi
  # end of 'error.c'
fi
if test -f 'error.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'error.h'\"
else
  echo shar: Extracting \"'error.h'\" \(41 characters\)
  sed "s/^X//" >'error.h' <<'END_OF_FILE'
X#include <errno.h>
X
Xvoid die(), warn();
X
END_OF_FILE
  if test 41 -ne `wc -c <'error.h'`; then
    echo shar: \"'error.h'\" unpacked with wrong size!
  fi
  # end of 'error.h'
fi
if test -f 'greg.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'greg.c'\"
else
  echo shar: Extracting \"'greg.c'\" \(2758 characters\)
  sed "s/^X//" >'greg.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <sys/types.h>
X#include "greg.h"
X#include "error.h"
X
X/* greg.c gregorian calendar module for hebrew calendar program
X   By Danny Sadinoff
X   (C) 1992
X
X*/
X
Xchar * eMonths[] = { 
X  "January","February","March","April","May","June","July",
X  "August","September","October","November","December"
X  };
X		      
Xint MonthLengths[][12] ={ 
X  {31,28,31,30,31,30,31,31,30,31,30,31},
X  {31,29,31,30,31,30,31,31,30,31,30,31}
X};
X
Xchar * DayNames[] = {
X  "Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"
X  };
X
Xchar * ShortDayNames[] = {
X  "Sun","Mon","Tue","Wed","Thu","Fri","Sat"
X  };
X
Xstatic void checkRange (dt,routine)
Xdate_t dt;
Xchar * routine;
X{
X  if ((dt.mm > 13)||(dt.dd > 31) || (dt.yy > 7000) || 
X      (dt.mm <0)  ||(dt.dd <0  ) || (dt.yy < -7000))
X    die("Date out of range from routine %s.",routine);
X}
X
Xstatic long int daysSinceOrigin (dt)
Xdate_t dt;
X{
X  int m,y;
X  long int days = 0L;
X
X  checkRange(dt,"daysSinceOrigin");
X
X  for (y =1; y < dt.yy; y++)
X    days += DAYS_IN(y);
X  y = dt.yy;
X  for (m= JAN; m < dt.mm; m++)
X    days += MonthLengths[LEAP(y)][m];
X  days += dt.dd -1;
X  return days;
X}
X
Xint diffDays(d1,d2)
Xdate_t d1, d2;
X{
X  return (int) (daysSinceOrigin(d1) - daysSinceOrigin(d2));
X}
X
Xint exceeds (d1,d2)
Xdate_t d1, d2;
X{
X  if (d1.yy > d2.yy)
X    return 1;
X  else if (d1.yy < d2.yy)
X    return 0;
X  else if (d1.mm > d2.mm)
X    return 1;
X  else if (d1.mm < d2.mm)
X    return 0;
X  else if (d1.dd > d2.dd)
X    return 1;
X  else return 0;
X}
X
Xvoid decDate (dt,n) /* decrements dt by n days */
Xdate_t *dt;
Xint n;
X{
X/*under construction*/
X/*  while (n > 365) {
X    n -= DAYS_IN(dt->yy -1);
X    dt ->yy--;
X  }
X
X
X  if ((dt->mm == FEB) && (dt->dd == 29) && !LEAP(dt->yy))
X    dt->dd--;
X*/
X  
X  while (n--) 
X    if (dt->dd ==1) {
X      if (dt->mm == JAN) {
X	dt->yy--;
X	dt->mm = DEC;
X	dt->dd = 31;
X      }
X      else {
X	dt->mm--;
X	dt->dd = MonthLengths[LEAP(dt->yy)][dt->mm];
X      }
X    }
X    else dt->dd--;
X}
X
Xvoid incDate (dt,n)   /* increments dt by n days */
Xdate_t *dt;
Xint n;
X{
X/*  while (n > 365) {
X    n -= DAYS_IN(dt->yy);
X    dt->yy++;
X  }
X
X  if ((dt->mm == FEB) && (dt->dd == 29) && !LEAP(dt->yy) ) {
X    dt-> mm = MAR;
X    dt-> dd = 1;
X  }
X*/
X  while (n--) 
X   if ((dt->dd + 1) > MonthLengths[LEAP(dt->yy)][dt->mm]) 
X     if (dt->mm == DEC) {
X       dt->yy++;
X       dt->mm = JAN;
X       dt->dd = 1;
X     }
X     else {
X       dt->mm++;
X       dt->dd =1;
X     }
X   else 
X     dt->dd ++;
X}
X
Xint dayOfWeek(d1)  /* sunday = 0 */
Xdate_t d1;
X{
X  return (int) ((daysSinceOrigin(d1) + 1) % 7 ) ;
X}
X
Xvoid setDate (d) 
Xdate_t *d;
X{
X  time_t secs;
X  struct tm *loctm;
X
X  secs = time(NULL);
X  loctm = localtime(&secs);
X  d->yy = 1900 + loctm->tm_year;
X  d->mm = loctm->tm_mon;
X  d->dd = loctm->tm_mday;
X}
X
X
END_OF_FILE
  if test 2758 -ne `wc -c <'greg.c'`; then
    echo shar: \"'greg.c'\" unpacked with wrong size!
  fi
  # end of 'greg.c'
fi
if test -f 'greg.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'greg.h'\"
else
  echo shar: Extracting \"'greg.h'\" \(593 characters\)
  sed "s/^X//" >'greg.h' <<'END_OF_FILE'
X#include <time.h>
X
X#define LEAP(x) (!((x) % 4) && ( ((x) % 100) || !((x) % 400)))
X#define DAYS_IN(x) (LEAP((x))?366:365)
X
Xenum {JAN,FEB,MAR,APR,MAY,JUN,JUL,AUG,SEP,OCT,NOV,DEC};
Xenum {SUN,MON,TUE,WED,THU,FRI,SAT};
Xextern char * eMonths[];
Xextern int MonthLengths[][12] ;
Xextern char * DayNames[] ;
Xextern char * ShortDayNames[];
Xextern char * eDays[] ;
X
Xtypedef struct {
X  int mm;	/* months since january 0,11*/
X  int dd;	/* day of month 1,31 */
X  int yy;	/* years since year 1 BCE i.e. -1 = 2 BCE */
X  } date_t;
X
Xint diffDays(), exceeds(), dayOfWeek();
Xvoid decDate (), incDate(), setDate();
END_OF_FILE
  if test 593 -ne `wc -c <'greg.h'`; then
    echo shar: \"'greg.h'\" unpacked with wrong size!
  fi
  # end of 'greg.h'
fi
if test -f 'hebcal.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hebcal.c'\"
else
  echo shar: Extracting \"'hebcal.c'\" \(20147 characters\)
  sed "s/^X//" >'hebcal.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <string.h>
X#include "error.h"
X#include "danlib.h"
X#include "greg.h"
X  /* hebcal.c main module for hebrew calendar program
X     By Danny Sadinoff
X     (C) 1992
X     
X     $Date: 93/01/11 18:19:58 $
X     $Revision: 1.3 $
X     
X     */ 
X  
X  
X  int sedrot_sw, hebDates_sw, euroDates_sw, specMonth_sw,specDay_sw,
X  weekday_sw, suppressHolidays_sw, suppressGreg_sw, printOmer_sw, omer;
X
Xtypedef struct {
X  
X  char * name;
X  int length;
X  
X  int daysInCheshvan;
X  int daysInKislev;
X  
X  int vayakhelPikudei;	/* double parsha flags */
X  int tazriaMetzorah;
X  int achreiKedoshim;
X  int beharBech;
X  int chukatBalak; 
X  int matotMasei;
X  int nitzavimVayelech;
X  
X} year_t;
X
X
Xyear_t legend[2][8] = {
X  {				/* stam years */
X    {"1BX",353,29,29,1,1,1,1,0,1,1},	/* BX */
X    {"1BS",355,30,30,1,1,1,1,1,1,1},	/* BS */
X    {"2GC",354,29,30,1,1,1,1,1,1,1},	/* GC */
X    {"4HC",354,29,30,1,1,1,1,0,1,0},	/* HC */ 
X    {"0error - HX",354,29,29,1,1,1,1,0,1,0},	/* error! hx */
X    {"4HS",355,30,30,0,1,1,1,0,1,0},	/* HS */
X    {"6ZX",353,29,29,1,1,1,1,0,1,0},	/* ZX */
X    {"6ZS",355,30,30,1,1,1,1,0,1,1},	/* ZS */
X  },
X  {				/* leap years */
X    {"1BX",383,29,29,0,0,0,0,1,1,1},	/* BX */
X    {"1BS",385,30,30,0,0,0,0,0,1,0},	/* BS */
X    {"2GC",384,29,30,0,0,0,0,0,1,0},	/* GC */
X    {"0error - HC",383,29,30,0,0,0,0,0,0,0},	/* error ! hc */
X    {"4HX",383,29,29,0,0,0,0,0,0,0},	/* HX */
X    {"4HS",385,30,30,0,0,0,0,0,0,1},	/* HS */
X    {"6ZX",383,29,29,0,0,0,0,0,1,1},	/* ZX */
X    {"6ZS",385,30,30,0,0,0,0,1,1,1},	/* ZS */
X  }
X};
X
Xint leapYears[] = {0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,0,1,0,1};
X
Xenum {BX,BS,GC,HC,HX,HS,ZX,ZS};
X
Xint luach[][19] = 
X{
X  {HC,BX,HS,HC,BS,ZX,HC,BS,BX,HS,GC,BS,ZX,GC,BS,ZS,HX,GC,ZS},
X  {ZS,HC,BX,ZS,HC,BX,ZS,HS,HC,BX,HS,HC,BS,ZX,HC,BS,ZX,HS,GC},
X  {BS,ZX,GC,BS,ZS,HX,GC,ZS,ZS,HC,BX,ZS,HC,BS,BX,HC,BS,BS,ZX},
X  {HC,HS,ZX,HC,HS,ZS,ZX,GC,BS,ZS,HX,GC,ZS,HS,HC,BX,HS,HC,BX},
X  {ZS,HC,BS,BX,HC,BS,BS,ZX,HC,BS,ZX,HS,GC,ZS,ZS,HC,BX,ZS,HX},
X  {GC,ZS,HS,HC,BX,HS,HC,BX,ZS,HC,BS,BX,HS,GC,BS,ZX,GC,BS,ZS},
X  {ZX,GC,ZS,ZS,HC,BX,ZS,HX,GC,ZS,HS,HC,BX,HS,HC,BS,ZX,HC,BS},
X  {BS,ZX,GC,BS,ZS,HX,GC,ZS,ZX,GC,ZS,ZS,HC,BX,ZS,HC,BS,BX,HS},
X  {HC,BS,ZX,HC,BS,ZX,HS,GC,BS,ZX,GC,BS,ZS,HX,GC,ZS,HS,HC,BX},
X  {ZS,HC,BX,ZS,HC,BS,BX,HS,HC,BS,ZX,HC,BS,ZX,HS,GC,ZS,ZX,GC},
X  {BS,ZS,HX,GC,ZS,HS,HC,BX,ZS,HC,BX,ZS,HC,BS,BX,HS,GC,BS,ZX}, /* 10,11 GX? */
X  {HC,BS,ZS,ZX,GC,ZS,ZS,HX,GC,ZS,HX,GC,ZS,HS,HC,BX,HS,HC,BS},
X  {BX,HC,BS,BS,ZX,GC,BS,ZX,HS,GC,ZS,ZS,HC,BX,ZS,HC,BX,ZS,HS}
X};
X
Xstruct {
X  char * name;
X  int length;
X}hMonths[][14] = {
X  {  
X    {"Tishrei",30}, {"Cheshvan",29}, {"Kislev",30},
X    {"Tevet",29}, {"Shvat",30}, {"Adar",29},
X    {"Nisan",30}, {"Iyyar",29}, {"Sivan",30},
X    {"Tamuz",29}, {"Av",30},{"Elul",29},{"Tishrei",30}},
X  {
X    {"Tishrei",30}, {"Cheshvan",29}, {"Kislev",30},
X    {"Tevet",29}, {"Shvat",30}, {"Adar I",29}, {"Adar II",30},
X    {"Nisan",30}, {"Iyyar",29}, {"Sivan",30},
X    {"Tamuz",29}, {"Av",30},{"Elul",29},{"Tishrei",30}}    
X};
X
Xenum {TISHREI, CHESHVAN, KISLEV, ADAR_2 = 6};
X
Xchar * sedrot[] = { 
X  
X  "Bereshit", "Noach", "Lech Lecha", "Vayera", "Chayei Sara",
X  "Toldot", "Vayetzei", "Vayishlach", "Vayeshev", "Miketz", "Vayigash",
X  "Vayechi",
X  
X  "Sh'mot", "Vaera", "Bo", "Beshalach", "Yitro", "Mishpatim",
X  "Terumah", "Tetzaveh", "Ki Tisa", "Vayakhel", "Pekudei",
X  
X  "Vayikra", "Tzav", "Shmini", "Tazria", "Metzora", "Achrei Mot",
X  "Kedoshim", "Emor", "Behar", "Bechukosai",
X  
X  "Bamidbar", "Nasso", "Beha'aloscha", "Sh'lach", "Korach", "Chukat",
X  "Balak", "Pinchas", "Matot", "Masei",
X  
X  "Devarim", "Vaetchanan", "Eikev", "Re'eh", "Shoftim", 
X  "Ki Teitzei", "Ki Tavo", "Nitzavim", "Vayeilech", "Ha'Azinu", 
X  "V'Zot Habracha"
X  };
X
Xenum { VAYAKHEL = 21, 
X	 TAZRIA = 26, ACHREI = 28,
X	 BEHAR = 31,
X	 CHUKAT = 38, MATOT= 41, 
X	 NITZAVIM = 50
X	 };
X
X#define NM_LEN 30
X
X#define OWNSEDRA 1
X#define NIDCHE 2
X#define MUKDAM 4
X#define MUKDAM2 8
X
Xtypedef struct hnode{
X  date_t date;
X  char *name;
X  int typeMask;
X  struct hnode *next;
X} holiday_t, *holidayp_t;
X
Xholiday_t special[100];
X
Xholiday_t holidays[] = {	/* 5 = Adar I */
X  /* 6 = Adar = Adar II */
X  {{0,1},"Rosh Hashana I",OWNSEDRA},{{0,2},"Rosh Hashana II",OWNSEDRA},
X  {{0,3},"Tzom Gedalia",NIDCHE},
X  {{0,9},"Erev Yom Kippur"},
X  {{0,10},"Yom Kippur",OWNSEDRA},
X  
X  {{0,15},"Sukkot I",OWNSEDRA},{{0,16},"Sukkot II",OWNSEDRA},
X  {{0,17},"Sukkot III (CH\"M)",OWNSEDRA},{{0,18},"Sukkot IV (CH\"M)",OWNSEDRA},
X  {{0,19},"Sukkot V (CH\"M)",OWNSEDRA},{{0,20},"Sukkot VI (CH\"M)",OWNSEDRA},
X  {{0,21},"Sukkot VII (Hoshana Raba)",OWNSEDRA},
X  {{0,22},"Shmini Atzeret",OWNSEDRA},{{0,23},"Simchat Torah",OWNSEDRA},
X  
X  {{2,25},"Chanukah I"},
X  {{2,26},"Chanukah II"},{{2,27},"Chanukah III"},{{2,29},"Chanukah IV"},
X  {{3,10},"Asara B'Tevet",NIDCHE},
X
X  {{4,15},"Tu B'Shevat"}  /*NIDCHE?*/,
X  
X  {{5,15},"Purim katan"},
X  {{6,13},"Ta'anit Esther",MUKDAM},{{6,14},"Purim"},
X  {{6,15},"Shushan Purim"}, 
X  
X  {{7,14},"Erev Pesach - Taanit B'chorot",0},
X#define PESACH2_STR "Pesach II"
X  {{7,15},"Pesach I",OWNSEDRA},{{7,16},PESACH2_STR,OWNSEDRA},
X  {{7,17},"Pesach III (CH\"M)",OWNSEDRA},{{7,18},"Pesach IV (CH\"M)",OWNSEDRA},
X  {{7,19},"Pesach V (CH\"M)",OWNSEDRA},{{7,20},"Pesach VI (CH\"M)",OWNSEDRA},
X  {{7,21},"Pesach VII",OWNSEDRA},
X  {{7,22},"Pesach VIII",OWNSEDRA},
X  
X  {{7,27},"Yom HaShoah"},
X  {{8,4},"Yom HaZikaron",MUKDAM2},
X  {{8,5},"Yom Ha'atzmaut",MUKDAM},
X#define SHAVUOT_STR "Shavuot I"
X  {{9,6},SHAVUOT_STR,OWNSEDRA},{{9,7},"Shavuot II",OWNSEDRA},
X  {{10,17},"Shiva Assar B'Tamuz",NIDCHE},
X  {{11,9},"Tish'a B'Av",NIDCHE},
X  {{12,29},"Erev Rosh Hashana"}
X};
X
Xholiday_t chanukah_arr[5] =
X{
X  {{0,0},""},
X  {{0,0},"Chanukah V"},
X  {{0,0},"Chanukah VI"},
X  {{0,0},"Chanukah VII"},
X  {{0,0},"Chanukah VIII"}
X};
X
Xenum {SIMCHAT_DAY = 23};
X/* = {
X   {{0,0},"Shabbat Shekalim"},
X   {{0,0},"Shabbat Zachor"},
X   {{0,0},"Parshat HaChodesh"},
X   {{0,0},"Parshat Parah"},
X   {{0,0},"Yom Yerushalayim"}
X   };*/
X
X
X#define LEAP_YR_HEB(x) (leapYears[((x) -1) % 19])
X#define MONTHS_IN_HEB(x) (LEAP_YR_HEB(x) ? 13 :12)
X
Xyear_t yearData(yr)
X     int yr;
X{
X  return legend[LEAP_YR_HEB(yr)][luach[((yr-1)/19+7)%13][(yr-1) %19]];
X}
X
X#define LAST_INDEX(x) (sizeof x / sizeof x[0])
X
Xint daysInHebMonth(month, year) 
X     int month, year;
X{
X  year_t theYear;
X  
X  theYear = yearData(year);
X  if (month == CHESHVAN) 
X    return theYear.daysInCheshvan;
X  else if (month == KISLEV)
X    return theYear.daysInKislev;
X  else return hMonths[LEAP_YR_HEB(year)][month].length;
X}
X
Xdate_t nextHebDate (dth) 
X     date_t dth;
X{
X  dth.dd++;
X  if (dth.dd > daysInHebMonth(dth.mm,dth.yy))
X    if (dth.mm ==  MONTHS_IN_HEB(dth.yy)-1){
X      dth.yy++;
X      dth.mm =0;
X      dth.dd =1;
X    }
X    else {
X      dth.mm++;
X      dth.dd =1;
X    }
X  return dth;
X}
X
Xdate_t prevHebDate (dth) 
X     date_t dth;
X{
X  dth.dd--;
X  if (dth.dd == 0)
X    if (dth.mm == 0) {
X      dth.yy--;
X      dth.mm = MONTHS_IN_HEB(dth.yy) -1 ;
X      dth.dd = daysInHebMonth(dth.mm,dth.yy);
X    }
X    else {
X      dth.mm--;
X      dth.dd = daysInHebMonth(dth.mm,dth.yy);
X    }
X  return dth;
X}
X
Xvoid addHoliday(theHoliday, holiList)
X     holiday_t theHoliday, **holiList;
X{
X  
X  holidayp_t newHol, currHol = *holiList;
X  
X  if (currHol) 
X    while (currHol->next)	/* scan to the end of the list */
X      currHol = currHol->next; /* now currhol points to the last */
X  
X  if (!(newHol = (holiday_t *) malloc(sizeof (holiday_t))))
X    die("Mem allocation error in getHebHolidays routine.","");
X  
X  if (currHol)
X    currHol->next = newHol;
X  else *holiList = newHol;
X  
X  *newHol = theHoliday;
X  newHol->next = NULL;
X}
X
Xholidayp_t getHebHolidays (dt,weekday,theYear, holiList) /* returns a linked */
X     date_t dt;			/* list of holidays for that date*/ 
X     int weekday;		
X     year_t theYear;
X     holiday_t ** holiList; 
X{
X  int c, specialCounter=0;
X  holidayp_t tmpholip;
X  static int chanukah_day;
X  
X  *holiList = NULL;
X  
X#define CORRECTION(yy,mm) (LEAP_YR_HEB(yy) ? 0 : (((mm) > 4) ? 1: 0))
X#define MATCH(X,Y) ((X.mm == (Y.mm + CORRECTION(Y.yy,Y.mm)) ) && (X.dd == Y.dd))
X  
X  for (c = 0; c < LAST_INDEX(holidays); c++) 
X    {
X      if (MATCH(holidays[c].date,dt))
X	if (!(weekday == SAT && holidays[c].typeMask & NIDCHE) &&
X	    !(holidays[c].typeMask & MUKDAM &&
X	      (weekday == FRI || weekday == SAT)) &&
X	    !(holidays[c].typeMask & MUKDAM2 &&
X	      (weekday == THU || weekday == FRI)))
X	  {            /* do normal holidays*/
X	    addHoliday(holidays[c],holiList);
X	    if (!strcmp((*holiList)->name,PESACH2_STR)) omer++;
X	    if (omer && holiList && !strcmp((*holiList)->name,SHAVUOT_STR)) omer=0;
X	  }
X      
X      if (holidays[c].typeMask & NIDCHE &&	/* fast days which are */
X	  (MATCH(holidays[c].date,prevHebDate(dt))) && 
X	  (weekday ==SUN)){
X	char *st;
X	
X	initStr(&st,NM_LEN);
X	strncat(st,holidays[c].name,NM_LEN);
X	strncat(st," [nidche]",NM_LEN);
X	addHoliday(holidays[c],holiList); 
X	(*holiList)->name = st;
X      }
X      
X      if (holidays[c].typeMask & MUKDAM && /* if the date actually falls */
X	  (MATCH(holidays[c].date,nextHebDate(nextHebDate(dt))) ||
X	   MATCH(holidays[c].date,nextHebDate(dt))) &&
X	  (weekday == THU))	              /* on friday or shabbat*/
X	addHoliday(holidays[c],holiList);
X      
X      if (holidays[c].typeMask & MUKDAM2 && /* if the date actually falls */
X	  (MATCH(holidays[c].date,nextHebDate(nextHebDate(dt))) ||
X	   MATCH(holidays[c].date,nextHebDate(dt))) && 
X	  (weekday == WED))	              /* on thursday or friday*/
X	addHoliday(holidays[c],holiList);
X    }
X  
X  /* Lag B'Omer Processing */
X  if (omer == 33) {
X    tmpholip = &special[specialCounter++];
X    initStr(&tmpholip->name,NM_LEN); 
X    strncpy(tmpholip->name,"Lag B'Omer",NM_LEN);
X    addHoliday(*tmpholip,holiList);
X  }
X
X  if (chanukah_day) {
X    addHoliday(chanukah_arr[chanukah_day],holiList);
X    if (chanukah_day == 4)
X      chanukah_day = 0;
X    else chanukah_day++;
X  }
X
X  if ((dt.dd == 29) && (dt.mm == 2)) 
X    chanukah_day = 1;
X  
X
X  /* rosh Chodesh Processing... */
X  if (dt.dd == 1 && dt.mm){	/* every 1st of the month except tishrei */
X    tmpholip = &special[specialCounter++];
X    initStr(&tmpholip->name,NM_LEN); 
X    strcat(tmpholip->name,"Rosh Chodesh ");
X    strncat(tmpholip->name,hMonths[LEAP_YR_HEB(dt.yy)][dt.mm].name,NM_LEN);
X    addHoliday(*tmpholip,holiList);
X  }
X  if (dt.dd == 30){
X    tmpholip = &special[specialCounter++];
X    initStr(&tmpholip->name,NM_LEN);
X    strcat(tmpholip->name,"Rosh Chodesh ");
X    strncat(tmpholip->name,hMonths[LEAP_YR_HEB(dt.yy)][dt.mm+1].name,NM_LEN);
X    addHoliday(*tmpholip,holiList);
X  }
X  
X  
X  return *holiList;
X}
X
X
Xvoid incHebJulDate(dth,dtj,wkday)
X     date_t *dth, *dtj;
X     int *wkday;
X{
X  /* increments both hebrew and julian calendars */
X  
X  incDate (dtj,1);
X  *wkday = dayOfWeek(*dtj);
X  *dth = nextHebDate(*dth);
X}   
X
X#define JUL2HEB(x) ((x)+ 3760)
X
Xvoid PrintWeekday (dt) 
X     date_t dt;{
X       printf ("%s, ",ShortDayNames[dayOfWeek(dt)]);
X     }
X     
X     void PrintJulDate (dt) 
X     date_t dt;
X{
X  if (!suppressGreg_sw) 
X    if (euroDates_sw)
X      printf ("%d.%d.%d ",dt.dd,dt.mm+1,dt.yy);
X    else
X      printf ("%d/%d/%d ",dt.mm+1,dt.dd,dt.yy);
X}
X
X
Xchar *DoSedra (sedra, ydat)	/* returns a string "Parshat <parsha>" */
X     int *sedra;		/* based on the current parsha number */
X     year_t ydat;
X{
X#define PLENGTH 40
X  static char s[PLENGTH+1];
X  
X  *s = '\0';
X  strncat(s,"Parshat ",PLENGTH);
X  strncat(s,sedrot[*sedra],PLENGTH);
X  switch (*sedra) {
X  case VAYAKHEL :
X    if (ydat.vayakhelPikudei){
X      strncat(s,"-",PLENGTH);
X      strncat(s,sedrot[*sedra+1],PLENGTH);
X      *sedra += 2;
X    }
X    else {
X      (*sedra)++;
X    }
X    break;
X  case TAZRIA:
X    if (ydat.tazriaMetzorah){
X      strncat(s,"-",PLENGTH);
X      strncat(s,sedrot[*sedra+1],PLENGTH);
X      *sedra += 2;
X    }
X    else (*sedra)++;
X    break;
X  case ACHREI :
X    if (ydat.achreiKedoshim){
X      strncat(s,"-",PLENGTH);
X      strncat(s,sedrot[*sedra+1],PLENGTH);
X      *sedra += 2;
X    }
X    else (*sedra)++;
X    break;
X  case BEHAR :
X    if (ydat.beharBech){
X      strncat(s,"-",PLENGTH);
X      strncat(s,sedrot[*sedra+1],PLENGTH);
X      *sedra += 2;
X    }
X    else (*sedra)++;
X    break;
X  case CHUKAT :
X    if (ydat.chukatBalak){
X      strncat(s,"-",PLENGTH);
X      strncat(s,sedrot[*sedra+1],PLENGTH);
X      *sedra += 2;
X    }
X    else (*sedra)++;
X    break;
X  case MATOT :
X    if (ydat.matotMasei){
X      strncat(s,"-",PLENGTH);
X      strncat(s,sedrot[*sedra+1],PLENGTH);
X      *sedra += 2;
X    }
X    else (*sedra)++; 
X    break;
X  case NITZAVIM :
X    if (ydat.nitzavimVayelech){
X      strncat(s,"-",PLENGTH);
X      strncat(s,sedrot[*sedra+1],PLENGTH);
X      *sedra += 2;
X    }
X    else (*sedra)++; 
X    break;
X  case LAST_INDEX(sedrot)-1:
X    *sedra = 0;
X    break;
X  default:
X    (*sedra)++;
X  }
X  strncat(s,"\n",PLENGTH);
X  return s;
X}
X
X#define CHAR2NUM(x) ((x) - '0')
X
X
Xvoid DoCalendar (roshDt,justMonth,justDay)
X     date_t roshDt;	/* rosh Hashana of preceeding year */
X     int justMonth,/* print this month  */
X       justDay; 
X{ /* print this day */
X	 
X	 
X  int sedra,weekday;
X	 date_t todayj, todayh;
X	 holiday_t *holip;
X	 year_t theYear;
X	 todayj = roshDt;
X	 
X	 todayh.mm = 0;
X	 todayh.dd = 1;
X	 todayh.yy = JUL2HEB(roshDt.yy)+1; /* because it's after R"H */
X	 
X	 
X	 theYear = yearData(todayh.yy);
X	 
X	 if (CHAR2NUM(theYear.name[0]) != dayOfWeek(roshDt))
X	   die ("Bad Day!\n","");  
X	 
X	 /* first scan forward to simchat Torah, keeping track of dates only. */
X	 while (todayh.dd != SIMCHAT_DAY){
X	   incHebJulDate(&todayh, &todayj,&weekday);
X	 }
X	 sedra = 0;		/* initialize sedra */
X	 
X	 /* then continue until january 1st. */
X	 do {
X	   getHebHolidays(todayj,weekday,theYear,&holip);
X	   if ((weekday == SAT) && !(holip && holip->typeMask & OWNSEDRA)) 
X	     DoSedra(&sedra,theYear);
X	   
X	   incHebJulDate(&todayh,&todayj,&weekday);
X	 } while (!((todayj.mm==0) && (todayj.dd==1)));
X	 
X	 /* -------Main Year Loop-------*/
X	 do {
X	   if (hebDates_sw && 
X	       (!specMonth_sw || (justMonth== todayj.mm)) &&
X	       (!specDay_sw   || (justDay == todayj.dd))) {
X	     PrintJulDate(todayj);
X	     if (weekday_sw)
X	       PrintWeekday(todayj);
X	     printf ("%d of %s, %d\n",todayh.dd, /* print the hebrew date */
X		     hMonths[LEAP_YR_HEB(todayh.yy)][todayh.mm].name,
X		     todayh.yy);
X	   }
X	   getHebHolidays(todayh,weekday,theYear,&holip); 
X	   
X	   if ((todayh.mm == TISHREI) && (todayh.dd == 1))
X	     theYear = yearData(todayh.yy); /* if R"H reset YearData */
X	   
X	   if (sedrot_sw && (weekday == SAT) && 
X	       !(holip && holip->typeMask & OWNSEDRA)){
X	     if ((!specMonth_sw || (justMonth == todayj.mm)) &&
X		 (!specDay_sw   || (justDay == todayj.dd))){
X	       PrintJulDate(todayj);	
X	       printf("%s",DoSedra(&sedra,theYear));
X	     }
X	     else DoSedra(&sedra,theYear);
X	   }
X	   
X	   if ((todayh.mm == TISHREI) && /* reset the sedra on simchat torah */
X	       (todayh.dd == SIMCHAT_DAY)) sedra =0; 
X	   
X	   if (!suppressHolidays_sw &&
X	       (!specMonth_sw || (justMonth == todayj.mm)) &&
X	       (!specDay_sw   || (justDay == todayj.dd))) 
X	     for (;holip;holip = holip->next) {
X	       PrintJulDate(todayj);
X	       if (weekday_sw)
X		 PrintWeekday(todayj);
X	       printf ("%s\n",holip->name);
X	     }
X	   
X	   /* print the omer if desired */
X	   if (omer && printOmer_sw && 
X	       (!specMonth_sw || (justMonth == todayj.mm)) &&
X	       (!specDay_sw   || (justDay == todayj.dd))) {
X	     char *omerStr;
X	     initStr(&omerStr,NM_LEN); 
X	     strncat(omerStr,itoa(omer),NM_LEN);
X	     strncat(omerStr,numSuffix(omer),NM_LEN);
X	     strncat(omerStr," day of the Omer",NM_LEN);
X	     PrintJulDate(todayj);
X	     if (weekday_sw) PrintWeekday(todayj);
X	     printf ("%s\n",omerStr);
X	   }
X	   if (omer) omer++;
X	   
X	   
X	   incHebJulDate(&todayh,&todayj,&weekday);
X	 } while (!((todayj.mm==0) && (todayj.dd==1))); /* continue to january 1st */
X	 
X       }
X     
X     void RollBack(dtj,target) /* move rosh hashana dtj back until it's */
X     date_t *dtj;		  /* in the year before target */
X     int target;{
X       
X       int days,theyear;
X       
X       for (days = 0,theyear = dtj->yy ;theyear > target -1; theyear--)
X	 days +=yearData(JUL2HEB(theyear)).length;
X       decDate (dtj,days); 
X       
X     }
X     
X     void RollForward(dtj,target)   /* move rosh hashana dtj forward until it's*/
X     date_t *dtj;		       /*  in the year before target*/
X     int target; {
X       int days,theyear;
X       
X       for (days = 0,theyear = dtj->yy ;theyear < target -1; theyear++)
X	 days +=yearData(JUL2HEB(theyear+1)).length;
X       incDate (dtj,days); 
X       
X     }
X     
X     char * progname;
X     
X     int main (argc, argv)
X     int argc;
X     char *argv[];
X{
X  char *c;
X  date_t startDate,tempdt;
X  int theYear,theMonth,theDay,yearDirty=0;
X  
X  char * usage = "usage: hebcal [-dehostTw] [[month [day]] year]\n               hebcal help\n";  
X  progname = argv[0];
X  
X  startDate.dd = 28;
X  startDate.mm = SEP; /* any ol' rosh hashana */
X  startDate.yy = 1992;
X  
X  setDate(&tempdt);		/* do this year */
X  theYear = tempdt.yy;
X  
X  for (argv++, argc--; argc; argv++, argc--)
X    if (isAllNums(*argv))
X      if ((argc-1) && isAllNums(*(argv+1)) && !yearDirty) 
X	if ((argc-2) && isAllNums(*(argv+2))) {
X	  specMonth_sw =1;
X	  specDay_sw =1;
X	  theMonth = atoi(*argv) -1; /* year and month specified */
X	  theDay = atoi(*++argv); /* print theDay of theMonth */
X	  theYear = atoi(*++argv); /* print theMonth of theYear */
X	  yearDirty =1;
X	  argc -=2;
X	}
X	else {
X	  specMonth_sw =1;
X	  theMonth = atoi(*argv) -1; /* year and month specified */
X	  theYear = atoi(*++argv); /* print theMonth of theYear */
X	  yearDirty =1;
X	  argc--;
X	}
X      else if (!yearDirty) {
X	theYear = atoi(*argv);	/* just year specified */
X	yearDirty = 1;		/* print whole year */
X      }
X      else 	die(usage,"");
X    else if (**argv == '-')
X      for (c = *argv,c++;*c;c++)
X	switch (*c) {
X	case 'd' :		/* print hebrew dates */
X	  hebDates_sw = 1;
X	  break;
X	case 'e':
X	  euroDates_sw =1;
X	  break;
X	case 'h':
X	  suppressHolidays_sw =1;
X	  break;
X	case 't':		/* do hebcal for today. */
X	  specMonth_sw =1;
X	  specDay_sw =1;
X	  theMonth = tempdt.mm; /* year and month specified */
X	  theDay = tempdt.dd; /* print theDay of theMonth */
X	  yearDirty =1;
X	  break;
X	case 'T':		/* do hebcal for today, omit gregorian date. */
X	  suppressGreg_sw = 1;
X	  specMonth_sw =1;
X	  specDay_sw =1;
X	  theMonth = tempdt.mm; /* year and month specified */
X	  theDay = tempdt.dd; /* print theDay of theMonth */
X	  yearDirty =1;
X	  printOmer_sw =1;
X	  break;
X	case 'o':
X	  printOmer_sw =1;
X	  break;
X	case 's' :		/* print sedrot */
X	  sedrot_sw = 1;
X	  break;
X	case 'w' :		/* print days of the week */
X	  weekday_sw = 1;
X	  break;
X	default: die(usage,"");
X	}
X    else if (!strcmp(*argv,"help")) {
X      printf ("Hebcal Version 1.3\n\n");
X      printf ("Hebcal prints out hebrew calendars one solar year at a time.\n");
X      printf ("Given one numeric argument, it will print out the calendar \n");
X      printf ("for that year.  Given two numeric argumetnts mm yyyy, it\n");
X      printf ("prints out the calendar for month mm of year yyyy. \n");
X      printf (usage);
X      printf ("\nOPTIONS:\n   -d : add hebrew dates\n");
X      printf ("   -e : use european dates for OUTPUT ONLY (input format the same)\n");
X      printf ("   -h : suppress holidays\n");
X      printf ("   -o : add days of the omer\n");
X      printf ("   -s : add weekly sedrot \n");
X      printf ("   -t : only output for today's date\n");
X      printf ("   -T : print today's pertinent information, no gregorian date\n");
X      printf ("   -w : add day of the week\n\n");
X      printf ("       hebcal help --- prints this message\n"); 
X      printf ("\nExample: \n");
X      printf ("   hebcal -ho\n");
X      printf ("will just print out the days of the omer for the current year.\n");
X      exit(0);
X    }
X    else die (usage,"");
X  
X  if (specDay_sw) hebDates_sw = 1;
X  
X  if (theYear < startDate.yy +1) /* go to R"H of the year before */
X    RollBack(&startDate,theYear);
X  else if (theYear > startDate.yy +1) /* start from there */
X    RollForward(&startDate,theYear);
X  
X  DoCalendar(startDate,theMonth,theDay);   
X  
X  return 0;
X}
END_OF_FILE
  if test 20147 -ne `wc -c <'hebcal.c'`; then
    echo shar: \"'hebcal.c'\" unpacked with wrong size!
  fi
  # end of 'hebcal.c'
fi
if test -f 'hebcal.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hebcal.l'\"
else
  echo shar: Extracting \"'hebcal.l'\" \(3378 characters\)
  sed "s/^X//" >'hebcal.l' <<'END_OF_FILE'
X.TH HEBCAL 1L "Hebcal Version 1.3" "Danny Sadinoff"
X.SH NAME
Xhebcal - a Jewish calendar generator
X.SH SYNOPSIS
X.B hebcal
X[ 
X\-dehostTw
X] [[
X.I month
X[
X.I day
X]]
X.I year
X]
X.br
X.B hebcal help
X.SH DESCRIPTION
XWith no arguments, 
X.B hebcal
Xwill print to stdout the 
Xdates of the Jewish holidays in the current
Xsecular year.  Each line is prefixed with a gregorian date of the form
Xmm/dd/yy.  
X.sp
XBy specifying 
X.I month,
X.I day,
Xor 
X.I year 
Xoutput can be limited to a particular month or date
Xin a particular year.  
X.sp
X.I year
Xis an integer (it can be negative).  So 92 is in the early Christian
Xera, not the late twentieth century.
X.sp
X.I month
Xis a number from 1..12.
X.sp
X.I day 
Xis a number from 1..31.
X.sp
XFor example, the command
X.nf
X
X	hebcal 10 1992
X
X.fi
Xwill print out the holidays occurring in October of 1992.
X.PP
XA few other bells and whistles include the weekly 
X.I sedrah
Xas well as the day of the week, the count of the 
X.I omer,
Xand the Hebrew date.
X.PP
XOutput from hebcal can be used to drive calendar(1).  
XDay\-to\-day use for hebcal is provided for in the 
X.B -T
X and 
X.B -t
Xswitches, which print out Jewish calendar entries for the current date.
X.PP
X.SH OPTIONS
X.TP 1.0i
X.B "  -d"
XAdd the Hebrew date to the output.
X.TP
X.B "  -e"
XChange the output format to European-style dates: dd/mm/yyyy
X.TP
X.B "  -h"
XSupress holidays in output.
X.TP
X.B "  -o"
XAdd the count of the 
X.I omer
Xto the output.
X.TP
X.B "  -s"
XAdd the weekly sedra to the output.  
X.TP
X.B "  -t"
XPrint calendar entry for today's date only.  -d is asserted with this option.
X.TP
X.B "  -T"
XSame as -t, only without the gregorian date.  This option is useful in
Xlogin scripts, just to see what's happening today in the Jewish calendar.
X.TP
X.B "  -w"
XAdd the day of the week to the output.
X.SH EXAMPLES
X.LP
XTo find the days of the 
X.I omer 
Xin 1997, printing the days of the week:
X.RS
X.nf
X.ft B
Xexample% hebcal -how 1997
X.br
X4/23/97 Wed, 1st day of the Omer
X.br
X4/24/97 Thu, 2nd day of the Omer
X.br
X4/25/97 Fri, 3rd day of the Omer
X.br
X .
X.br
X .
X.br
X .
X.br
X6/9/97 Mon, 48th day of the Omer
X.br
X6/10/97 Tue, 49th day of the Omer
X.RE
X.LP
XTo just print the weekly sedrot of December 2000
X.RS
X.nf
X.ft B
Xexample% hebcal -hp 12 2000
X.br
X12/2/00 Parshat Toldot
X.br
X12/9/00 Parshat Vayetzei
X.br
X12/16/00 Parshat Vayishlach
X.br
X12/23/00 Parshat Vayeshev
X.br
X12/30/00 Parshat Miketz
X.br
X.RE
X.LP 
XTo find out what's happening in the Jewish calendar today, use
X.RS
X.nf
X.ft B
Xexample% hebcal -T
X.br
X19 of Nisan, 5752
X.br
XPesach V (CH"M)
X.br
X4th day of the Omer
X.br
X.RE
X.SH AUTHOR
XDanny Sadinoff, University of Pennsylvania
X.SH SEE ALSO
Xcalendar(1), hcal(1), hdate(1), omer(1), rise(1)
X.sp
XThe motivation for the algorithms in this program is the
X.I "Tur Shulchan Aruch.  "
XA well written treatment of the Jewish calendar is given in 
X.I Understanding the Jewish Calendar
Xby Rabbi Nathan Bushwick.  A more complete bibliography on the topic
Xcan be found there.
X.SH BUGS
XThere are some omissions from the list of included holidays, including
X;Yom Yerushalayim. 
X.sp
XRight now, hebcal dosn't perform enough sanity checking on input
Xdates.
X.sp
XHebcal performs no checking for changes between the julian and
Xgregorian calendar, so secular dates before 1752 are untrustworthy.
X.sp 
XHebcal cannot currently handle date computations before 2 C.E.  sorry.
X.SH BUG REPORTS TO
XDanny Sadinoff	sadinoff@eniac.seas.upenn.edu
X
X
X
END_OF_FILE
  if test 3378 -ne `wc -c <'hebcal.l'`; then
    echo shar: \"'hebcal.l'\" unpacked with wrong size!
  fi
  # end of 'hebcal.l'
fi
if test -f 'test.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'test.c'\"
else
  echo shar: Extracting \"'test.c'\" \(129 characters\)
  sed "s/^X//" >'test.c' <<'END_OF_FILE'
X#include <stdio.h>
X
Xmain()
X{
X  char d,c;
X  d = getchar ();
X  c =  getchar();
X  if (c == 'a' || d == 'b') printf ("success\n");
X}
END_OF_FILE
  if test 129 -ne `wc -c <'test.c'`; then
    echo shar: \"'test.c'\" unpacked with wrong size!
  fi
  # end of 'test.c'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
