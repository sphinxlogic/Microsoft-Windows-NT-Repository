Newsgroups: comp.sources.misc
From: zip-bugs@cs.ucla.edu (Info-ZIP group)
Subject:  v31i104:  unzip50 - Info-ZIP portable UnZip, version 5.0, Part01/14
Message-ID: <csm-v31i104=unzip50.215137@sparky.IMD.Sterling.COM>
X-Md4-Signature: 24bec5aef0397fc9dd575993881bf064
Date: Mon, 24 Aug 1992 02:51:55 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: zip-bugs@cs.ucla.edu (Info-ZIP group)
Posting-number: Volume 31, Issue 104
Archive-name: unzip50/part01
Supersedes: unzip: Volume 29, Issue 31-42
Environment: UNIX, VMS, OS/2, MS-DOS, MACINTOSH, WIN-NT, LINUX, MINIX, COHERENT AMIGA?, !ATARI, symlink, SGI, DEC, Cray, Convex, Amdahl, Sun

 ______________________________________________________________________

  NOTE:  Info-ZIP's mailing addresses and ftp site will be changing
  within the next month.  The current e-mail addresses should hold for
  a while via mail-forwarding, but watch for the new addresses in our
  next release.
 ______________________________________________________________________

  UnZip 5.0 is a decompression and file unpacking utility for use with
  ZIP archives (*.zip) created by Zip or PKZIP.  It is compatible with
  all currently released versions of Zip and PKZIP, and, aside from
  multi-disk archives, it is expected to be compatible with the soon-to-
  be-released PKZIP 2.x.  Info-ZIP's companion to UnZip is called Zip
  (of course); it is being posted concurrently, as are the encryption/
  decryption routines for Zip and UnZip, and a Microsoft Windows add-on 
  to UnZip called WizUnZip.

  This version of UnZip has been ported to a wide array of Unix and other
  mainframes, minis, and micros (as listed above).  Features not found in
  the PKWare version include default extraction of directory trees (with 
  a switch to defeat this, rather than the other way around); VMS, Macin-
  tosh and OS/2 extended file attributes; textfile conversion between MSDOS,
  Unix, VMS and Macintosh; the ZipInfo zipfile information utility; and, 
  of course, the ability to run under most of your favorite operating sys-
  tems.  Plus it's free. :-)  New features in this version include support
  for deflation (the new, higher-performance compression method introduced
  in the PKZIP 1.93a); much faster decompression; relaxed copyright restric-
  tions, due to rewritten code (see COPYING for details); multiple password
  guessing, for encrypted zipfiles; support for options stored in an envi-
  ronment variable, to change the default behavior; and a new Unix filter
  version of UnZip called FUnZip.

-----
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  AMIGA ATARI MAC MSDOS MSDOS/bcc MSDOS/tcc NT OS2
#   OS2/Contents VMS VMS/bilf unzip.doc unzip.h
# Wrapped by kent@sparky on Sun Aug 23 21:09:31 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 14)."'
if test ! -d 'AMIGA' ; then
    echo shar: Creating directory \"'AMIGA'\"
    mkdir 'AMIGA'
fi
if test ! -d 'ATARI' ; then
    echo shar: Creating directory \"'ATARI'\"
    mkdir 'ATARI'
fi
if test ! -d 'MAC' ; then
    echo shar: Creating directory \"'MAC'\"
    mkdir 'MAC'
fi
if test ! -d 'MSDOS' ; then
    echo shar: Creating directory \"'MSDOS'\"
    mkdir 'MSDOS'
fi
if test ! -d 'MSDOS/bcc' ; then
    echo shar: Creating directory \"'MSDOS/bcc'\"
    mkdir 'MSDOS/bcc'
fi
if test ! -d 'MSDOS/tcc' ; then
    echo shar: Creating directory \"'MSDOS/tcc'\"
    mkdir 'MSDOS/tcc'
fi
if test ! -d 'NT' ; then
    echo shar: Creating directory \"'NT'\"
    mkdir 'NT'
fi
if test ! -d 'OS2' ; then
    echo shar: Creating directory \"'OS2'\"
    mkdir 'OS2'
fi
if test -f 'OS2/Contents' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'OS2/Contents'\"
else
  echo shar: Extracting \"'OS2/Contents'\" \(441 characters\)
  sed "s/^X//" >'OS2/Contents' <<'END_OF_FILE'
XContents of the OS2 sub-archive for UnZip 5.0 and later:
X
X  Contents      this file
X  makefile.os2  makefile for MSC, IBM C Set/2, gcc/emx, or Watcom C/386 9.0
X  os2unzip.c    OS/2 HPFS/FAT support routines
X  unzip.def     OS/2 linker definition file
X  zipinfo.def   OS/2 linker definition file
X
XThere is, as yet, no support for the Zortech or gcc2.1 (Michael Johnson port)
Xcompilers, and the Borland 32-bit OS/2 compiler doesn't exist yet.
END_OF_FILE
  if test 441 -ne `wc -c <'OS2/Contents'`; then
    echo shar: \"'OS2/Contents'\" unpacked with wrong size!
  fi
  # end of 'OS2/Contents'
fi
if test ! -d 'VMS' ; then
    echo shar: Creating directory \"'VMS'\"
    mkdir 'VMS'
fi
if test ! -d 'VMS/bilf' ; then
    echo shar: Creating directory \"'VMS/bilf'\"
    mkdir 'VMS/bilf'
fi
if test -f 'unzip.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'unzip.doc'\"
else
  echo shar: Extracting \"'unzip.doc'\" \(9489 characters\)
  sed "s/^X//" >'unzip.doc' <<'END_OF_FILE'
X
XUNZIP(1)                 USER COMMANDS                   UNZIP(1)
X
XNAME
X     unzip - list/test/extract from a ZIP archive file
X
XSYNOPSIS
X     unzip [ -cflptuvxz[ajnoqUV] ] file[.zip] [filespec ...]
X
XARGUMENTS
X     file[.zip]  Path of the ZIP archive.  The suffix ``.zip'' is
X                 applied  if  the  file specified does not exist.
X                 Note that self-extracting  ZIP  files  are  sup-
X                 ported;  just  specify the ``.exe'' suffix your-
X                 self.
X
X     [filespec]  An optional list of archive members to  be  pro-
X                 cessed.  Expressions may be used to match multi-
X                 ple members; be sure to quote  expressions  that
X                 contain  characters interpreted by the operating
X                 system.  See  DESCRIPTION   (below)   for   more
X                 details.
X
XOPTIONS
X     -c  extract files to stdout/screen (``CRT'')
X     -f  freshen existing files (replace if newer); create none
X     -l  list archive files (short format)
X     -p  extract files to pipe; no informational messages
X     -t  test archive files
X     -u  update existing files; create new ones if needed
X     -v  list archive files (verbose format)
X     -x  extract files in archive (default)
X     -z  display only the archive comment
X
XMODIFIERS
X     -a  convert to MS-DOS textfile format (CR  LF),  Mac  format
X         (CR),  Unix/VMS  format  (LF),  OR from ASCII to EBCDIC,
X         depending on your system (only use for TEXT files!)
X     -j  junk paths (don't recreate  archive's  directory  struc-
X         ture)
X     -n  never overwrite existing files; don't prompt
X     -o  OK to overwrite files without prompting
X     -q  perform operations quietly (-qq => even quieter)
X     -s  [OS/2,  MS-DOS]  allow  spaces   in   filenames   (e.g.,
X         ``EA DATA. SF'')
X     -U  leave filenames uppercase if created under MS-DOS,  VMS,
X         etc.
X     -V  retain (VMS) file version numbers
X     -X  [VMS]  restore  owner/protection   info   (may   require
X         privileges)
X
XDESCRIPTION
X     UnZip will list, test, or extract from a ZIP  archive,  com-
X     monly  found on MSDOS systems.  Archive member extraction is
X     implied by the absence of the -c,  -p,  -t,  -l,  -v  or  -z
X
XInfo-ZIP          Last change: 22 Aug 92 (v5.0)                 1
X
XUNZIP(1)                 USER COMMANDS                   UNZIP(1)
X
X     options.    All  archive  members  are  processed  unless  a
X     filespec is provided to specify  a  subset  of  the  archive
X     members.   The  filespec  is similar to an egrep expression,
X     and may contain:
X
X     *      matches a sequence of 0 or more characters
X     ?      matches exactly 1 character
X     \nnn   matches the character having octal code nnn
X     [...]  matches any single character found inside the  brack-
X            ets; ranges are specified by a beginning character, a
X            hyphen, and an ending character.  If  an  exclamation
X            point  or  a  carat  (`!'  or  `^')  follows the left
X            bracket, then the range of characters matched is com-
X            plemented  with  respect  to  the ASCII character set
X            (that is, anything except the characters  inside  the
X            brackets is considered a match).
X
XENVIRONMENT OPTIONS
X     UnZip's default behavior may be modified via options  placed
X     in  an  environment  variable.   This  can  be done with any
X     option, but it is probably most useful with the -q,  -o,  or
X     -n modifiers:  in order to make UnZip quieter by default, or
X     to make it always overwrite or never overwrite files  as  it
X     extracts them.  For example, to make UnZip act as quietly as
X     possible, only reporting errors, one would use  one  of  the
X     following commands:
X
X           setenv UNZIP -qq           Unix C shell
X
X           UNZIP=-qq; export UNZIP    Unix Bourne shell
X
X           set UNZIP=-qq              OS/2 or MS-DOS
X
X           define UNZIP_OPTS "-qq"    VMS (quotes for LOWERCASE)
X
X     Environment options are, in effect, considered  to  be  just
X     like  any  other  command-line options, except that they are
X     effectively the first options on the command line.  To over-
X     ride  an  environment option, one may use the ``minus opera-
X     tor'' to remove it.  For instance, to override  one  of  the
X     quiet-flags in the example above, use the command
X
X           unzip --q[other options] zipfile
X
X     The first hyphen is the normal  switch  character,  and  the
X     second  is  a  minus sign, acting on the q option.  Thus the
X     effect here is to cancel a single quantum of quietness.   To
X     cancel both quiet flags, two (or more) minuses may be used:
X
X           unzip -x--q zipfile
X
XInfo-ZIP          Last change: 22 Aug 92 (v5.0)                 2
X
XUNZIP(1)                 USER COMMANDS                   UNZIP(1)
X
X     or
X
X           unzip ---qx zipfile
X
X     (the two are equivalent).  This may seem awkward or  confus-
X     ing,  but it is reasonably intuitive:  just ignore the first
X     hyphen and go from there.  It is also  consistent  with  the
X     behavior of Unix nice(1).
X
XEXAMPLES
X     To  use  UnZip  to  extract  all  members  of  the   archive
X     letters.zip, creating any directories as necessary:
X
X           unzip letters
X
X     To extract all members of letters.zip to the current  direc-
X     tory:
X
X           unzip -j letters
X
X     To test letters.zip, printing only a summary  message  indi-
X     cating whether the archive is OK or not:
X
X           unzip -tq letters
X
X     To extract to standard output  all  members  of  letters.zip
X     whose  names  end  in ``.tex'', converting to the local end-
X     of-line convention and piping the output into more(1):
X
X           unzip -ca letters \*.tex | more
X
X     (The backslash before the asterisk is only required  if  the
X     shell  expands  wildcards,  as  in Unix; double quotes could
X     have been used instead, as in the source example below.)  To
X     extract  the  binary  file paper1.dvi to standard output and
X     pipe it to a printing program:
X
X           unzip -p articles paper1.dvi | dvips
X
X     To extract all FORTRAN and C source  files--*.f,  *.c,  *.h,
X     Makefile  (the  double quotes are necessary only in Unix and
X     only if globbing is turned on):
X
X           unzip source.zip "*.[fch]" Makefile
X
X     To extract only newer versions of the files already  in  the
X     current  directory,  without  querying (NOTE:  be careful of
X     unzipping in one timezone a zipfile created in  another--ZIP
X     archives  contain  no  timezone information, and a ``newer''
X     file from an eastern timezone may, in fact, be older):
X
XInfo-ZIP          Last change: 22 Aug 92 (v5.0)                 3
X
XUNZIP(1)                 USER COMMANDS                   UNZIP(1)
X
X           unzip -fo sources
X
X     To extract newer  versions  of  the  files  already  in  the
X     current  directory and to create any files not already there
X     (same caveat as previous example):
X
X           unzip -uo sources
X
X     In the last five examples, assume that UNZIP  or  UNZIP_OPTS
X     is set to -q.  To do a singly quiet listing:
X
X           unzip -l file
X
X     To do a doubly quiet listing:
X
X           unzip -ql file
X
X     To do a standard listing:
X
X           unzip --ql file
X
X     or
X
X           unzip -l-q file
X
X     or
X
X           unzip -l--q file
X
X     (extra minuses don't hurt).
X
XTIPS
X     The current maintainer, being a lazy  sort,  finds  it  very
X     useful to define an alias ``tt'' for ``unzip -tq''.  One may
X     then simply type ``tt zipfile'' to test the  archive,  some-
X     thing  which  one  ought  make  a habit of doing.  With luck
X     UnZip will report ``No  errors  detected  in  zipfile.zip,''
X     after which one may breathe a sigh of relief.
X
XSEE ALSO
X     funzip(1),  zip(1),  zipcloak(1),  zipinfo(1),   zipnote(1),
X     zipsplit(1)
X
XAUTHORS
X     Samuel H. Smith, Carl Mascott, David P. Kirschbaum, Greg  R.
X     Roelofs,  Mark  Adler,  Kai  Uwe  Rommel, Igor Mandrichenko,
X     Johnny Lee, Jean-loup Gailly; Glenn  Andrews,  Joel  Aycock,
X     Allan  Bjorklund,  James  Birdsall,  Wim Bonner, John Cowan,
X     Frank da Cruz, Bill Davidsen, Arjan de Vet, James Dugal, Jim
X     Dumser,  Mark  Edwards, David Feinleib, Mike Freeman, Hunter
X     Goatley, Robert Heath, Dave  Heiland,  Larry  Jones,  Kjetil
X     J(o)rgenson,  Bob Kemp, J. Kercheval, Alvin Koh, Bo Kullmar,
X
XInfo-ZIP          Last change: 22 Aug 92 (v5.0)                 4
X
XUNZIP(1)                 USER COMMANDS                   UNZIP(1)
X
X     Johnny Lee, Warner Losh, Fulvio Marino,  Gene  McManus,  Joe
X     Meadows,  Mike  O'Carroll,  Humberto  Ortiz-Zuazaga, Piet W.
X     Plomp, Antonio Querubin Jr., Steve Salisbury, Georg  Sassen,
X     Jon  Saxton,  Hugh Schmidt, Martin Schulz, Charles Scripter,
X     Chris Seaman, Richard Seay, Alex Sergejew,  Cliff  Stanford,
X     Onno  van der Linden, Jim Van Zandt, Antoine Verheijen, Paul
X     Wells.
X
XVERSIONS
X     v1.2  15 Mar 89  Samuel H. Smith
X     v2.0   9 Sep 89  Samuel H. Smith
X     v2.x  fall 1989  many Usenet contributors
X     v3.0   1 May 90  Info-ZIP (DPK, consolidator)
X     v3.1  15 Aug 90  Info-ZIP (DPK, consolidator)
X     v4.0   1 Dec 90  Info-ZIP (GRR, maintainer)
X     v4.1  12 May 91  Info-ZIP
X     v4.2  20 Mar 92  Info-ZIP (zip-bugs subgroup; GRR, maint.)
X     v5.0  21 Aug 92  Info-ZIP (zip-bugs subgroup; GRR, maint.)
X
XInfo-ZIP          Last change: 22 Aug 92 (v5.0)                 5
X
END_OF_FILE
  if test 9489 -ne `wc -c <'unzip.doc'`; then
    echo shar: \"'unzip.doc'\" unpacked with wrong size!
  fi
  # end of 'unzip.doc'
fi
if test -f 'unzip.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'unzip.h'\"
else
  echo shar: Extracting \"'unzip.h'\" \(43208 characters\)
  sed "s/^X//" >'unzip.h' <<'END_OF_FILE'
X/*---------------------------------------------------------------------------
X
X  unzip.h
X
X  This header file is used by all of the unzip source files.  Its contents
X  are divided into seven more-or-less separate sections:  predefined macros,
X  OS-dependent includes, (mostly) OS-independent defines, typedefs, function 
X  prototypes (or "prototypes," in the case of non-ANSI compilers), macros, 
X  and global-variable declarations.
X
X  ---------------------------------------------------------------------------*/
X
X
X
X/*****************************************/
X/*  Predefined, Machine-specific Macros  */
X/*****************************************/
X
X#if (defined(__GO32__) && defined(unix))   /* DOS extender */
X#  undef unix
X#endif
X
X#if (defined(unix) && !defined(UNIX))
X#  define UNIX
X#endif /* unix && !UNIX */
X
X/* Much of the following is swiped from zip's tailor.h: */
X
X/* define MSDOS for Turbo C (unless OS/2) and Power C as well as Microsoft C */
X#ifdef __POWERC
X#  define __TURBOC__
X#  define MSDOS
X#endif /* __POWERC */
X#if (defined(__TURBOC__) && defined(__MSDOS__) && !defined(MSDOS))
X#  define MSDOS
X#endif
X
X/* use prototypes and ANSI libraries if __STDC__, or Microsoft or Borland C,
X * or Silicon Graphics, or Convex, or IBM C Set/2, or GNU gcc under emx, or
X * or Watcom C, or Macintosh, or Windows NT.
X */
X#if (__STDC__ || defined(MSDOS) || defined(sgi) || defined(CONVEX))
X#  ifndef PROTO
X#    define PROTO
X#  endif
X#  define MODERN
X#endif
X#if (defined(__IBMC__) || defined(__EMX__) || defined(__WATCOMC__))
X#  ifndef PROTO
X#    define PROTO
X#  endif
X#  define MODERN
X#endif
X#if (defined(THINK_C) || defined(MPW) || defined(WIN32))
X#  ifndef PROTO
X#    define PROTO
X#  endif
X#  define MODERN
X#endif
X
X/* turn off prototypes if requested */
X#if (defined(NOPROTO) && defined(PROTO))
X#  undef PROTO
X#endif
X
X/* used to remove arguments in function prototypes for non-ANSI C */
X#ifdef PROTO
X#  define OF(a) a
X#else /* !PROTO */
X#  define OF(a) ()
X#endif /* ?PROTO */
X
X#if (defined(ultrix) || defined(bsd4_2) || defined(sun) || defined(pyr))
X#  if (!defined(BSD) && !defined(__SYSTEM_FIVE) && !defined(SYSV))
X#    define BSD
X#  endif /* !BSD && !__SYSTEM_FIVE && !SYSV */
X#endif /* ultrix || bsd4_2 || sun || pyr */
X
X#if (defined(CONVEX) || defined(CRAY) || defined(__SYSTEM_FIVE))
X#  ifndef TERMIO
X#    define TERMIO
X#  endif /* !TERMIO */
X#endif /* CONVEX || CRAY || __SYSTEM_FIVE */
X
X#ifdef pyr  /* Pyramid */
X#  ifndef ZMEM
X#    define ZMEM
X#  endif /* !ZMEM */
X#endif /* pyr */
X
X#ifdef CRAY
X#  ifdef ZMEM
X#    undef ZMEM
X#  endif /* ZMEM */
X#endif /* CRAY */
X
X/* the i386 test below is to catch SCO Unix (which has redefinition
X * warnings if param.h is included), but it probably doesn't hurt if
X * other 386 Unixes get nailed, too...except now that 386BSD and BSDI
X * exist.  Sigh.  <sys/param.h> is mostly included for "BSD", I think.
X * [An alternate fix for SCO Unix is below.]
X */
X#if (defined(MINIX) || (defined(i386) && defined(unix)))
X#  define NO_PARAM_H
X#endif /* MINIX || (i386 && unix) */
X
X
X
X
X
X/***************************/
X/*  OS-Dependent Includes  */
X/***************************/
X
X#ifndef MINIX            /* Minix needs it after all the other includes (?) */
X#  include <stdio.h>
X#endif
X#include <ctype.h>       /* skip for VMS, to use tolower() function? */
X#include <errno.h>       /* used in mapname() */
X#ifndef NO_ERRNO
X#  define DECLARE_ERRNO  /* everybody except MSC 6.0, SCO cc, Watcom C/386 */
X#endif /* !NO_ERRNO */
X#ifdef VMS
X#  include <types.h>     /* (placed up here instead of in VMS section below */
X#  include <stat.h>      /* because types.h is used in some other headers) */
X#else /* !VMS */
X#  if !defined(THINK_C) && !defined(MPW)
X#    include <sys/types.h>                 /* off_t, time_t, dev_t, ... */
X#    include <sys/stat.h>
X#  endif /* !THINK_C && !MPW */
X#endif /* ?VMS */
X
X#ifdef MODERN
X#  if (!defined(M_XENIX) && !(defined(__GNUC__) && defined(sun)))
X#    include <stddef.h>
X#  endif
X#  if (!defined(__GNUC__) && !defined(apollo))   /* both define __STDC__ */
X#    include <stdlib.h>    /* standard library prototypes, malloc(), etc. */
X#  else
X#    ifdef __EMX__
X#      include <stdlib.h>  /* emx IS gcc but has stdlib.h */
X#    endif
X#  endif
X#  include <string.h>      /* defines strcpy, strcmp, memcpy, etc. */
X   typedef size_t extent;
X   typedef void voidp;
X#else /* !MODERN */
X   char *malloc();
X   char *strchr(), *strrchr();
X   long lseek();
X   typedef unsigned int extent;
X#  define void int
X   typedef char voidp;
X#endif /* ?MODERN */
X
X/* this include must be down here for SysV.4, for some reason... */
X#include <signal.h>      /* used in unzip.c, file_io.c */
X
X
X
X/*---------------------------------------------------------------------------
X    Next, a word from our Unix (mostly) sponsors:
X  ---------------------------------------------------------------------------*/
X
X#ifdef UNIX
X#  ifdef AMIGA
X#    include <libraries/dos.h>
X#  else /* !AMIGA */
X#    ifndef NO_PARAM_H
X#if 0  /* [GRR: this is an alternate fix for SCO's redefinition bug] */
X#      ifdef NGROUPS_MAX
X#        undef NGROUPS_MAX     /* SCO bug:  defined again in <param.h> */
X#      endif /* NGROUPS_MAX */
X#endif /* 0 */
X#      include <sys/param.h>   /* conflict with <sys/types.h>, some systems? */
X#    endif /* !NO_PARAM_H */
X#  endif /* ?AMIGA */
X
X#  ifndef BSIZE
X#    ifdef MINIX
X#      define BSIZE   1024
X#    else /* !MINIX */
X#      define BSIZE   DEV_BSIZE  /* assume common for all Unix systems */
X#    endif /* ?MINIX */
X#  endif
X
X#  ifndef BSD
X#    if (!defined(AMIGA) && !defined(MINIX))
X#      define NO_MKDIR           /* for mapname() */
X#    endif /* !AMIGA && !MINIX */
X#    include <time.h>
X     struct tm *gmtime(), *localtime();
X#  else   /* BSD */
X#    include <sys/time.h>
X#    include <sys/timeb.h>
X#    ifdef _AIX
X#      include <time.h>
X#    endif
X#  endif
X
X#else   /* !UNIX */
X#  define BSIZE   512               /* disk block size */
X#endif /* ?UNIX */
X
X#if (defined(V7) || defined(BSD))
X#  define strchr    index
X#  define strrchr   rindex
X#endif
X
X/*---------------------------------------------------------------------------
X    And now, our MS-DOS and OS/2 corner:
X  ---------------------------------------------------------------------------*/
X
X#ifdef __TURBOC__
X#  define DOS_OS2
X#  include <sys/timeb.h>      /* for structure ftime                        */
X#  ifndef __BORLANDC__        /* there appears to be a bug (?) in Borland's */
X#    include <mem.h>          /*   MEM.H related to __STDC__ and far poin-  */
X#  endif                      /*   ters. (dpk)  [mem.h included for memcpy] */
X#  include <dos.h>            /* for REGS macro (at least for Turbo C 2.0)  */
X#else                         /* NOT Turbo C (or Power C)...                */
X#  ifdef MSDOS                /*   but still MS-DOS, so we'll assume it's   */
X#    ifndef MSC               /*   Microsoft's compiler and fake the ID, if */
X#      define MSC             /*   necessary (it is in 5.0; apparently not  */
X#    endif                    /*   in 5.1 and 6.0)                          */
X#    include <dos.h>          /* for _dos_setftime()                        */
X#  endif
X#endif
X
X#if (defined(__IBMC__) && defined(__OS2__))
X#  define DOS_OS2
X#  define S_IFMT 0xF000
X#  define timezone _timezone
X#endif
X
X#ifdef __WATCOMC__
X#  define DOS_OS2
X#  define __32BIT__
X#  ifdef DECLARE_ERRNO
X#    undef DECLARE_ERRNO
X#  endif
X#  undef far
X#  define far
X#endif
X
X#ifdef __EMX__
X#  define DOS_OS2
X#  define __32BIT__
X#  define far
X#endif /* __EMX__ */
X
X#ifdef MSC                    /* defined for all versions of MSC now         */
X#  define DOS_OS2             /* Turbo C under DOS, MSC under DOS or OS/2    */
X#  if (defined(_MSC_VER) && (_MSC_VER >= 600))    /* new with 5.1 or 6.0 ... */
X#    undef DECLARE_ERRNO      /* errno is now a function in a dynamic link   */
X#  endif                      /*   library (or something)--incompatible with */
X#endif                        /*   the usual "extern int errno" declaration  */
X
X#ifdef DOS_OS2                /* defined for all MS-DOS and OS/2 compilers   */
X#  include <io.h>             /* lseek(), open(), setftime(), dup(), creat() */
X#  include <time.h>           /* localtime() */
X#endif
X
X#ifdef OS2                    /* defined for all OS/2 compilers */
X#  ifdef isupper
X#    undef isupper
X#  endif
X#  ifdef tolower
X#    undef tolower
X#  endif
X#  define isupper(x)   IsUpperNLS((unsigned char)(x))
X#  define tolower(x)   ToLowerNLS((unsigned char)(x))
X#endif
X
X#ifdef WIN32
X#  include <io.h>             /* read(), open(), etc. */
X#  include <time.h>
X#  include <memory.h>
X#  include <direct.h>         /* mkdir() */
X#  ifdef FILE_IO_C
X#    include <fcntl.h>
X#    include <conio.h>
X#    include <sys\types.h>
X#    include <sys\utime.h>
X#    include <windows.h>
X#    define DOS_OS2
X#    define getch() getchar()
X#  endif
X#endif
X
X/*---------------------------------------------------------------------------
X    Followed by some VMS (mostly) stuff:
X  ---------------------------------------------------------------------------*/
X
X#ifdef VMS
X#  include <time.h>               /* the usual non-BSD time functions */
X#  include <file.h>               /* same things as fcntl.h has */
X#  include <rms.h>
X#  define _MAX_PATH NAM$C_MAXRSS  /* to define FILNAMSIZ below */
X#  define UNIX                    /* can share most of same code from now on */
X#  define RETURN    return_VMS    /* VMS interprets return codes incorrectly */
X#else /* !VMS */
X#  ifndef THINK_C
X#    define RETURN  return        /* only used in main() */
X#  else
X#    define RETURN(v) { int n;\
X                        n = (v);\
X                        fprintf(stderr, "\npress <return> to continue ");\
X                        while (getc(stdin) != '\n');\
X                        putc('\n', stderr);\
X                        InitCursor();\
X                        goto start;\
X                      }
X#  endif
X#  ifdef V7
X#    define O_RDONLY  0
X#    define O_WRONLY  1
X#    define O_RDWR    2
X#  else /* !V7 */
X#    ifdef MTS
X#      include <sys/file.h>     /* MTS uses this instead of fcntl.h */
X#      include <timeb.h>
X#      include <time.h>
X#    else /* !MTS */
X#      ifdef COHERENT           /* Coherent 3.10/Mark Williams C */
X#        include <sys/fcntl.h>
X#        define SHORT_NAMES
X#        define tzset  settz
X#      else /* !COHERENT */
X#        include <fcntl.h>      /* O_BINARY for open() w/o CR/LF translation */
X#      endif /* ?COHERENT */
X#    endif /* ?MTS */
X#  endif /* ?V7 */
X#endif /* ?VMS */
X
X#if (defined(MSDOS) || defined(VMS))
X#  define DOS_VMS
X#endif
X
X/*---------------------------------------------------------------------------
X    And some Mac stuff for good measure:
X  ---------------------------------------------------------------------------*/
X
X#ifdef THINK_C
X#  define MACOS
X#  ifndef __STDC__            /* if Think C hasn't defined __STDC__ ... */
X#    define __STDC__ 1        /*   make sure it's defined: it needs it */
X#  else /* __STDC__ defined */
X#    if !__STDC__             /* sometimes __STDC__ is defined as 0; */
X#      undef __STDC__         /*   it needs to be 1 or required header */
X#      define __STDC__ 1      /*   files are not properly included. */
X#    endif /* !__STDC__ */
X#  endif /* ?defined(__STDC__) */
X#endif /* THINK_C */
X
X#ifdef MPW
X#  define MACOS
X#  include <Errors.h>
X#  include <Files.h>
X#  include <Memory.h>
X#  include <Quickdraw.h>
X#  include <ToolUtils.h>
X#  define CtoPstr c2pstr
X#  define PtoCstr p2cstr
X#  ifdef CR
X#    undef  CR
X#  endif
X#endif /* MPW */
X
X#ifdef MACOS
X#  define open(x,y) macopen(x,y, gnVRefNum, glDirID)
X#  define close macclose
X#  define read macread
X#  define write macwrite
X#  define lseek maclseek
X#  define creat(x,y) maccreat(x, gnVRefNum, glDirID, gostCreator, gostType)
X#  define stat(x,y) macstat(x,y,gnVRefNum, glDirID)
X
X#  ifndef isascii
X#    define isascii(c) ((unsigned char)(c) <= 0x3F)
X#  endif
X
X#  include "macstat.h"
X
Xtypedef struct _ZipExtraHdr {
X    unsigned short header;    /*    2 bytes */
X    unsigned short data;      /*    2 bytes */
X} ZIP_EXTRA_HEADER;
X
Xtypedef struct _MacInfoMin {
X    unsigned short header;    /*    2 bytes */
X    unsigned short data;      /*    2 bytes */
X    unsigned long signature;  /*    4 bytes */
X    FInfo finfo;              /*   16 bytes */
X    unsigned long lCrDat;     /*    4 bytes */
X    unsigned long lMdDat;     /*    4 bytes */
X    unsigned long flags ;     /*    4 bytes */
X    unsigned long lDirID;     /*    4 bytes */
X                              /*------------*/
X} MACINFOMIN;                 /* = 40 bytes for size of data */
X
Xtypedef struct _MacInfo {
X    unsigned short header;    /*    2 bytes */
X    unsigned short data;      /*    2 bytes */
X    unsigned long signature;  /*    4 bytes */
X    FInfo finfo;              /*   16 bytes */
X    unsigned long lCrDat;     /*    4 bytes */
X    unsigned long lMdDat;     /*    4 bytes */
X    unsigned long flags ;     /*    4 bytes */
X    unsigned long lDirID;     /*    4 bytes */
X    char rguchVolName[28];    /*   28 bytes */
X                              /*------------*/
X} MACINFO;                    /* = 68 bytes for size of data */
X#endif /* MACOS */
X
X/*---------------------------------------------------------------------------
X    And finally, some random extra stuff:
X  ---------------------------------------------------------------------------*/
X
X#ifdef MINIX
X#  include <stdio.h>
X#endif
X
X#ifdef SHORT_NAMES         /* Mark Williams C, ...? */
X#  define extract_or_test_files    xtr_or_tst_files
X#  define extract_or_test_member   xtr_or_tst_member
X#endif
X
X#ifdef MTS
X#  include <unix.h>          /* Some important non-ANSI routines */
X#  define mkdir(s,n) (-1)    /* No "make directory" capability */
X#  define EBCDIC             /* Set EBCDIC conversion on */
X#endif
X
X
X
X
X
X/*************/
X/*  Defines  */
X/*************/
X
X#ifndef WSIZE
X#  define WSIZE 0x8000       /* window size--must be a power of two, and */
X#endif /* !WSIZE */          /*  at least 32K for zip's deflate method */
X
X#define DIR_BLKSIZ    64     /* number of directory entries per block
X                              *  (should fit in 4096 bytes, usually) */
X#ifndef INBUFSIZ
X#  define INBUFSIZ    2048   /* works for MS-DOS small model */
X#endif /* !INBUFSIZ */
X
X/*
X * If <limits.h> exists on most systems, should include that, since it may
X * define some or all of the following:  NAME_MAX, PATH_MAX, _POSIX_NAME_MAX,
X * _POSIX_PATH_MAX.
X */
X#ifdef DOS_OS2
X#  include <limits.h>
X#endif /* DOS_OS2 */
X
X#ifdef _MAX_PATH
X#  define FILNAMSIZ       (_MAX_PATH)
X#else /* !_MAX_PATH */
X#  define FILNAMSIZ       1025
X#endif /* ?_MAX_PATH */
X
X#ifndef PATH_MAX
X#  ifdef MAXPATHLEN                /* defined in <sys/param.h> some systems */
X#    define PATH_MAX      MAXPATHLEN
X#  else
X#    if FILENAME_MAX > 255         /* used like PATH_MAX on some systems */
X#      define PATH_MAX    FILENAME_MAX
X#    else
X#      define PATH_MAX    (FILNAMSIZ - 1)
X#    endif
X#  endif /* ?MAXPATHLEN */
X#endif /* !PATH_MAX */
X
X#define OUTBUFSIZ         INBUFSIZ
X
X#define ZSUFX             ".zip"
X#define CENTRAL_HDR_SIG   "\113\001\002"   /* the infamous "PK" signature */
X#define LOCAL_HDR_SIG     "\113\003\004"   /*  bytes, sans "P" (so unzip */
X#define END_CENTRAL_SIG   "\113\005\006"   /*  executable not mistaken for */
X#define EXTD_LOCAL_SIG    "\113\007\010"   /*  zipfile itself) */
X
X#define SKIP              0    /* choice of activities for do_string() */
X#define DISPLAY           1
X#define FILENAME          2
X#define EXTRA_FIELD       3
X
X#define DOES_NOT_EXIST    -1   /* return values for check_for_newer() */
X#define EXISTS_AND_OLDER  0
X#define EXISTS_AND_NEWER  1
X
X#define DOS_OS2_FAT_      0    /* version_made_by codes (central dir) */
X#define AMIGA_            1
X#define VMS_              2    /* make sure these are not defined on */
X#define UNIX_             3    /*  the respective systems!!  (like, for */
X#define VM_CMS_           4    /*  instance, "VMS", or "UNIX":  CFLAGS = */
X#define ATARI_            5    /*  -O -DUNIX) */
X#define OS2_HPFS_         6
X#define MAC_              7
X#define Z_SYSTEM_         8
X#define CPM_              9
X/* #define TOPS20_   10?  (TOPS20_ is to be defined in PKZIP 2.0...)  */
X#define NUM_HOSTS         10   /* index of last system + 1 */
X
X#define STORED            0    /* compression methods */
X#define SHRUNK            1
X#define REDUCED1          2
X#define REDUCED2          3
X#define REDUCED3          4
X#define REDUCED4          5
X#define IMPLODED          6
X#define TOKENIZED         7
X#define DEFLATED          8
X#define NUM_METHODS       9    /* index of last method + 1 */
X/* don't forget to update list_files() appropriately if NUM_METHODS changes */
X
X#define DF_MDY            0    /* date format 10/26/91 (USA only) */
X#define DF_DMY            1    /* date format 26/10/91 (most of the world) */
X#define DF_YMD            2    /* date format 91/10/26 (a few countries) */
X
X#define UNZIP_VERSION     20   /* compatible with PKUNZIP 2.0 */
X#define VMS_VERSION       42   /* if OS-needed-to-extract is VMS:  can do */
X
X/*---------------------------------------------------------------------------
X    True sizes of the various headers, as defined by PKWare--so it is not
X    likely that these will ever change.  But if they do, make sure both these
X    defines AND the typedefs below get updated accordingly.
X  ---------------------------------------------------------------------------*/
X#define LREC_SIZE     26    /* lengths of local file headers, central */
X#define CREC_SIZE     42    /*  directory headers, and the end-of-    */
X#define ECREC_SIZE    18    /*  central-dir record, respectively      */
X
X#define MAX_BITS      13                 /* used in unShrink() */
X#define HSIZE         (1 << MAX_BITS)    /* size of global work area */
X
X#define LF      10    /* '\n' on ASCII machines.  Must be 10 due to EBCDIC */
X#define CR      13    /* '\r' on ASCII machines.  Must be 13 due to EBCDIC */
X#define CTRLZ   26    /* DOS & OS/2 EOF marker (used in file_io.c, vms.c) */
X
X#ifdef EBCDIC
X#  define ascii_to_native(c)   ebcdic[(c)]
X#  define NATIVE    "EBCDIC"
X#endif
X
X#if MPW
X#  define FFLUSH    putc('\n',stderr);
X#else /* !MPW */
X#  define FFLUSH    fflush(stderr);
X#endif /* ?MPW */
X
X#ifdef VMS
X#  define ENV_UNZIP     "UNZIP_OPTS"      /* name of environment variable */
X#  define ENV_ZIPINFO   "ZIPINFO_OPTS"
X#else /* !VMS */
X#  define ENV_UNZIP     "UNZIP"
X#  define ENV_ZIPINFO   "ZIPINFO"
X#endif /* ?VMS */
X
X#ifdef CRYPT
X#  define PWLEN         80
X#  define DECRYPT(b)    (update_keys(t=((b)&0xff)^decrypt_byte()),t)
X#endif /* CRYPT */
X
X#ifdef QQ  /* Newtware version */
X#  define QCOND   (!quietflg)   /* for no file comments with -vq or -vqq */
X#else      /* (original) Bill Davidsen version  */
X#  define QCOND   (which_hdr)   /* no way to kill file comments with -v, -l */
X#endif
X
X#ifndef TRUE
X#  define TRUE      1   /* sort of obvious */
X#endif
X#ifndef FALSE
X#  define FALSE     0
X#endif
X
X#ifndef SEEK_SET        /* These should all be declared in stdio.h!  But   */
X#  define SEEK_SET  0   /*  since they're not (in many cases), do so here. */
X#  define SEEK_CUR  1
X#  define SEEK_END  2
X#endif
X
X#ifndef S_IRUSR
X#  define S_IRWXU       00700       /* read, write, execute: owner */
X#  define S_IRUSR       00400       /* read permission: owner */
X#  define S_IWUSR       00200       /* write permission: owner */
X#  define S_IXUSR       00100       /* execute permission: owner */
X#  define S_IRWXG       00070       /* read, write, execute: group */
X#  define S_IRGRP       00040       /* read permission: group */
X#  define S_IWGRP       00020       /* write permission: group */
X#  define S_IXGRP       00010       /* execute permission: group */
X#  define S_IRWXO       00007       /* read, write, execute: other */
X#  define S_IROTH       00004       /* read permission: other */
X#  define S_IWOTH       00002       /* write permission: other */
X#  define S_IXOTH       00001       /* execute permission: other */
X#endif /* !S_IRUSR */
X
X#ifdef ZIPINFO      /* these are individually checked because SysV doesn't */
X#  ifndef S_IFBLK   /*  have some of them, Microsoft C others, etc. */
X#    define   S_IFBLK     0060000     /* block special */
X#  endif
X#  ifndef S_IFIFO  /* in Borland C, not MSC */
X#    define   S_IFIFO     0010000     /* fifo */
X#  endif
X#  ifndef S_IFLNK  /* in BSD, not SysV */
X#    define   S_IFLNK     0120000     /* symbolic link */
X#  endif
X#  ifndef S_IFSOCK  /* in BSD, not SysV */
X#    define   S_IFSOCK    0140000     /* socket */
X#  endif
X#  ifndef S_ISUID
X#    define S_ISUID       04000       /* set user id on execution */
X#  endif
X#  ifndef S_ISGID
X#    define S_ISGID       02000       /* set group id on execution */
X#  endif
X#  ifndef S_ISVTX
X#    define S_ISVTX       01000       /* directory permissions control */
X#  endif
X#  ifndef S_ENFMT
X#    define S_ENFMT       S_ISGID     /* record locking enforcement flag */
X#  endif
X#endif /* ZIPINFO */
X
X
X
X
X
X/**************/
X/*  Typedefs  */
X/**************/
X
X#ifndef _BULL_SOURCE                /* Bull has it defined somewhere already */
X   typedef unsigned char  byte;     /* code assumes UNSIGNED bytes */
X#endif /* !_BULL_SOURCE */
X
Xtypedef char              boolean;
Xtypedef long              longint;
Xtypedef unsigned short    UWORD;
Xtypedef unsigned long     ULONG;
X
Xtypedef struct min_info {
X    unsigned unix_attr;
X    unsigned dos_attr;
X    int hostnum;
X    longint offset;
X    ULONG compr_size;        /* compressed size (needed if extended header) */
X    ULONG crc;               /* crc (needed if extended header) */
X    unsigned encrypted : 1;  /* file encrypted: decrypt before uncompressing */
X    unsigned ExtLocHdr : 1;  /* use time instead of CRC for decrypt check */
X    unsigned text : 1;       /* file is text or binary */
X    unsigned lcflag : 1;     /* convert filename to lowercase */
X} min_info;
X
Xtypedef struct VMStimbuf {
X    char *revdate;           /* (both correspond to Unix modtime/st_mtime) */
X    char *credate;
X} VMStimbuf;
X
X/*---------------------------------------------------------------------------
X    Zipfile layout declarations.  If these headers ever change, make sure the
X    xxREC_SIZE defines (above) change with them!
X  ---------------------------------------------------------------------------*/
X
X   typedef byte   local_byte_hdr[ LREC_SIZE ];
X#      define L_VERSION_NEEDED_TO_EXTRACT_0     0
X#      define L_VERSION_NEEDED_TO_EXTRACT_1     1
X#      define L_GENERAL_PURPOSE_BIT_FLAG        2
X#      define L_COMPRESSION_METHOD              4
X#      define L_LAST_MOD_FILE_TIME              6
X#      define L_LAST_MOD_FILE_DATE              8
X#      define L_CRC32                           10
X#      define L_COMPRESSED_SIZE                 14
X#      define L_UNCOMPRESSED_SIZE               18
X#      define L_FILENAME_LENGTH                 22
X#      define L_EXTRA_FIELD_LENGTH              24
X
X   typedef byte   cdir_byte_hdr[ CREC_SIZE ];
X#      define C_VERSION_MADE_BY_0               0
X#      define C_VERSION_MADE_BY_1               1
X#      define C_VERSION_NEEDED_TO_EXTRACT_0     2
X#      define C_VERSION_NEEDED_TO_EXTRACT_1     3
X#      define C_GENERAL_PURPOSE_BIT_FLAG        4
X#      define C_COMPRESSION_METHOD              6
X#      define C_LAST_MOD_FILE_TIME              8
X#      define C_LAST_MOD_FILE_DATE              10
X#      define C_CRC32                           12
X#      define C_COMPRESSED_SIZE                 16
X#      define C_UNCOMPRESSED_SIZE               20
X#      define C_FILENAME_LENGTH                 24
X#      define C_EXTRA_FIELD_LENGTH              26
X#      define C_FILE_COMMENT_LENGTH             28
X#      define C_DISK_NUMBER_START               30
X#      define C_INTERNAL_FILE_ATTRIBUTES        32
X#      define C_EXTERNAL_FILE_ATTRIBUTES        34
X#      define C_RELATIVE_OFFSET_LOCAL_HEADER    38
X
X   typedef byte   ec_byte_rec[ ECREC_SIZE+4 ];
X/*     define SIGNATURE                         0   space-holder only */
X#      define NUMBER_THIS_DISK                  4
X#      define NUM_DISK_WITH_START_CENTRAL_DIR   6
X#      define NUM_ENTRIES_CENTRL_DIR_THS_DISK   8
X#      define TOTAL_ENTRIES_CENTRAL_DIR         10
X#      define SIZE_CENTRAL_DIRECTORY            12
X#      define OFFSET_START_CENTRAL_DIRECTORY    16
X#      define ZIPFILE_COMMENT_LENGTH            20
X
X
X   typedef struct local_file_header {                 /* LOCAL */
X       byte version_needed_to_extract[2];
X       UWORD general_purpose_bit_flag;
X       UWORD compression_method;
X       UWORD last_mod_file_time;
X       UWORD last_mod_file_date;
X       ULONG crc32;
X       ULONG compressed_size;
X       ULONG uncompressed_size;
X       UWORD filename_length;
X       UWORD extra_field_length;
X   } local_file_hdr;
X
X   typedef struct central_directory_file_header {     /* CENTRAL */
X       byte version_made_by[2];
X       byte version_needed_to_extract[2];
X       UWORD general_purpose_bit_flag;
X       UWORD compression_method;
X       UWORD last_mod_file_time;
X       UWORD last_mod_file_date;
X       ULONG crc32;
X       ULONG compressed_size;
X       ULONG uncompressed_size;
X       UWORD filename_length;
X       UWORD extra_field_length;
X       UWORD file_comment_length;
X       UWORD disk_number_start;
X       UWORD internal_file_attributes;
X       ULONG external_file_attributes;
X       ULONG relative_offset_local_header;
X   } cdir_file_hdr;
X
X   typedef struct end_central_dir_record {            /* END CENTRAL */
X       UWORD number_this_disk;
X       UWORD num_disk_with_start_central_dir;
X       UWORD num_entries_centrl_dir_ths_disk;
X       UWORD total_entries_central_dir;
X       ULONG size_central_directory;
X       ULONG offset_start_central_directory;
X       UWORD zipfile_comment_length;
X   } ecdir_rec;
X
X
X
X
X
X/*************************/
X/*  Function Prototypes  */
X/*************************/
X
X#ifndef __
X#  define __   OF
X#endif
X
X/*---------------------------------------------------------------------------
X    Functions in unzip.c and/or zipinfo.c:
X  ---------------------------------------------------------------------------*/
X
Xint    usage                     __((int error));
Xint    process_zipfile           __((void));
Xint    find_end_central_dir      __((void));
Xint    process_end_central_dir   __((void));
Xint    list_files                __((void));                      /* unzip.c */
Xint    process_cdir_file_hdr     __((void));                      /* unzip.c */
Xint    process_local_file_hdr    __((void));                      /* unzip.c */
Xint    process_central_dir       __((void));
Xint    long_info                 __((void));                    /* zipinfo.c */
Xint    short_info                __((void));                    /* zipinfo.c */
Xchar   *zipinfo_time             __((UWORD *datez, UWORD *timez));
X
X/*---------------------------------------------------------------------------
X    Functions in extract.c:
X  ---------------------------------------------------------------------------*/
X
Xint    extract_or_test_files     __((void));
X/* static int   store_info               __((void)); */
X/* static int   extract_or_test_member   __((void)); */
Xint    memextract                __((byte *, ULONG, byte *, ULONG));
Xint    FlushMemory               __((void));
Xint    ReadMemoryByte            __((UWORD *x));
X
X/*---------------------------------------------------------------------------
X    Decompression functions:
X  ---------------------------------------------------------------------------*/
X
Xint    explode                   __((void));                    /* explode.c */
X
Xvoid   inflate                   __((void));                    /* inflate.c */
X
Xvoid   unReduce                  __((void));                   /* unreduce.c */
X/* static void  LoadFollowers    __((void));                    * unreduce.c */
X
Xvoid   unShrink                  __((void));                   /* unshrink.c */
X/* static void  partial_clear    __((void));                    * unshrink.c */
X
X/*---------------------------------------------------------------------------
X    Functions in file_io.c and crypt.c:
X  ---------------------------------------------------------------------------*/
X
Xint    open_input_file           __((void));                    /* file_io.c */
Xint    readbuf                   __((char *buf, register unsigned len));
Xint    create_output_file        __((void));             /* file_io.c, vms.c */
Xint    FillBitBuffer             __((void));                    /* file_io.c */
Xint    ReadByte                  __((UWORD *x));                /* file_io.c */
Xint    FlushOutput               __((void));             /* file_io.c, vms.c */
X/* static int   dos2unix         __((unsigned char *, int));     * file_io.c */
Xvoid   set_file_time_and_close   __((void));                    /* file_io.c */
Xvoid   handler                   __((int signal));              /* file_io.c */
Xint    echo                      __((int opt));                 /* file_io.c */
Xvoid   echoff                    __((int f));                   /* file_io.c */
Xvoid   echon                     __((void));                    /* file_io.c */
Xchar   *getp                     __((char *, char *, int));     /* file_io.c */
X
Xint    decrypt_byte              __((void));                      /* crypt.c */
Xvoid   update_keys               __((int));                       /* crypt.c */
Xvoid   init_keys                 __((char *));                    /* crypt.c */
X
X/*---------------------------------------------------------------------------
X    Macintosh file_io functions:
X  ---------------------------------------------------------------------------*/
X
X#ifdef MACOS
X/* static int   IsHFSDisk        __((int)); */
X   void     macfstest            __((int));
X   int      macmkdir             __((char *, short, long));
X   void     ResolveMacVol        __((short, short *, long *, StringPtr));
X   short    macopen              __((char *, short, short, long));
X   short    maccreat             __((char *, short, long, OSType, OSType));
X   short    macread              __((short, char *, unsigned));
X   short    macwrite             __((short, char *, unsigned));
X   short    macclose             __((short));
X   long     maclseek             __((short, long, short));
X#endif
X
X/*---------------------------------------------------------------------------
X    OS/2 file_io functions:
X  ---------------------------------------------------------------------------*/
X
Xvoid     ChangeNameForFAT  __((char *name));                   /* os2unzip.c */
Xint      IsFileNameValid   __((char *name));                   /* os2unzip.c */
Xint      GetCountryInfo    __((void));                         /* os2unzip.c */
Xlong     GetFileTime       __((char *name));                   /* os2unzip.c */
Xvoid     SetPathInfo __((char *path, UWORD moddate, UWORD modtime, int flags));
Xint      SetLongNameEA     __((char *name, char *longname));   /* os2unzip.c */
Xint      IsEA              __((void *extra_field));            /* os2unzip.c */
XULONG    SizeOfEAs         __((void *extra_field));            /* os2unzip.c */
Xvoid     SetEAs            __((char *path, void *eablock));    /* os2unzip.c */
Xint      IsUpperNLS        __((int nChr));                     /* os2unzip.c */
Xint      ToLowerNLS        __((int nChr));                     /* os2unzip.c */
X
X/*---------------------------------------------------------------------------
X    VMS file_io functions:
X  ---------------------------------------------------------------------------*/
X
Xint      check_format      __((void));                              /* vms.c */
Xint      find_vms_attrs    __((void));                              /* vms.c */
Xint      CloseOutputFile   __((void));                              /* vms.c */
X/* static byte *extract_block __((struct extra_block *, int *, byte *, int));*/
X/* static int  _flush_blocks  __((int final_flag));                  * vms.c */
X/* static int  _flush_records __((int final_flag));                  * vms.c */
X/* static int  WriteBuffer    __((unsigned char *buf, int len));     * vms.c */
X/* static int  WriteRecord    __((unsigned char *rec, int len));     * vms.c */
X/* static void message        __((int string, char *status));        * vms.c */
X
Xint      VMSmunch          __((char *, int, char *));          /* VMSmunch.c */
X
X/*---------------------------------------------------------------------------
X    Functions in match.c, mapname.c, misc.c, etc.:
X  ---------------------------------------------------------------------------*/
X
Xint      match             __((char *string, char *pattern));     /* match.c */
X
Xint      mapname           __((int create_dirs));               /* mapname.c */
X
Xvoid     UpdateCRC         __((register unsigned char *s, register int len));
Xint      do_string         __((unsigned int len, int option));     /* misc.c */
Xtime_t   dos_to_unix_time  __((unsigned ddate, unsigned dtime));   /* misc.c */
Xint      check_for_newer   __((char *filename));                   /* misc.c */
Xint      dateformat        __((void));                             /* misc.c */
XUWORD    makeword          __((byte *b));                          /* misc.c */
XULONG    makelong          __((byte *sig));                        /* misc.c */
Xvoid     return_VMS        __((int zip_error));                    /* misc.c */
X
Xvoid     envargs           __((int *, char ***, char *));       /* envargs.c */
X
X#ifdef AMIGA
X   int   utime             __((char *file, time_t timep[]));      /* utime.c */
X#endif /* AMIGA */
X
X#ifdef ZMEM   /* these MUST be ifdef'd because of conflicts with the std def */
X   char  *memset           __((register char *buf, register char init,
X                               register unsigned int len));        /* misc.c */
X   char  *memcpy           __((register char *dst, register char *src,
X                               register unsigned int len));        /* misc.c */
X#endif /* ZMEM */
X
X
X
X
X
X/************/
X/*  Macros  */
X/************/
X
X#ifndef MAX
X#  define MAX(a,b)   ((a) > (b) ? (a) : (b))
X#endif
X
X#ifndef MIN
X#  define MIN(a,b)   ((a) < (b) ? (a) : (b))
X#endif
X
X
X#define LSEEK(abs_offset) {longint request=(abs_offset)+extra_bytes,\
X   inbuf_offset=request%INBUFSIZ, bufstart=request-inbuf_offset;\
X   if(request<0) {fprintf(stderr, SeekMsg, ReportMsg); return(3);}\
X   else if(bufstart!=cur_zipfile_bufstart)\
X   {cur_zipfile_bufstart=lseek(zipfd,bufstart,SEEK_SET);\
X   if((incnt=read(zipfd,(char *)inbuf,INBUFSIZ))<=0) return(51);\
X   inptr=inbuf+(int)inbuf_offset; incnt-=(int)inbuf_offset;} else\
X   {incnt+=(inptr-inbuf)-(int)inbuf_offset; inptr=inbuf+(int)inbuf_offset;}}
X
X/*
X *  Seek to the block boundary of the block which includes abs_offset,
X *  then read block into input buffer and set pointers appropriately.
X *  If block is already in the buffer, just set the pointers.  This macro
X *  is used by process_end_central_dir (unzip.c) and do_string (misc.c).
X *  A slightly modified version is embedded within extract_or_test_files
X *  (unzip.c).  ReadByte and readbuf (file_io.c) are compatible.
X *
X *  macro LSEEK(abs_offset)
X *      ULONG   abs_offset;
X *  {
X *      longint   request = abs_offset + extra_bytes;
X *      longint   inbuf_offset = request % INBUFSIZ;
X *      longint   bufstart = request - inbuf_offset;
X *
X *      if (request < 0) {
X *          fprintf(stderr, SeekMsg, ReportMsg);
X *          return(3);             /-* 3:  severe error in zipfile *-/
X *      } else if (bufstart != cur_zipfile_bufstart) {
X *          cur_zipfile_bufstart = lseek(zipfd, bufstart, SEEK_SET);
X *          if ((incnt = read(zipfd,inbuf,INBUFSIZ)) <= 0)
X *              return(51);        /-* 51:  unexpected EOF *-/
X *          inptr = inbuf + (int)inbuf_offset;
X *          incnt -= (int)inbuf_offset;
X *      } else {
X *          incnt += (inptr-inbuf) - (int)inbuf_offset;
X *          inptr = inbuf + (int)inbuf_offset;
X *      }
X *  }
X *
X */
X
X
X#define SKIP_(length) if(length&&((error=do_string(length,SKIP))!=0))\
X  {error_in_archive=error; if(error>1) return error;}
X
X/*
X *  Skip a variable-length field, and report any errors.  Used in zipinfo.c
X *  and unzip.c in several functions.
X *
X *  macro SKIP_(length)
X *      UWORD   length;
X *  {
X *      if (length && ((error = do_string(length, SKIP)) != 0)) {
X *          error_in_archive = error;   /-* might be warning *-/
X *          if (error > 1)              /-* fatal *-/
X *              return (error);
X *      }
X *  }
X *
X */
X
X
X#define OUTB(intc) {*outptr++=(byte)(intc); if (++outcnt==OUTBUFSIZ)\
X  FlushOutput();}
X
X/*
X *  macro OUTB(intc)
X *  {
X *      *outptr++ = (byte)(intc);
X *      if (++outcnt == OUTBUFSIZ)
X *          FlushOutput();
X *  }
X *
X */
X
X
X#define READBIT(nbits,zdest) {if(nbits>bits_left) FillBitBuffer();\
X  zdest=(int)((UWORD)bitbuf&mask_bits[nbits]);bitbuf>>=nbits;bits_left-=nbits;}
X
X/*
X * macro READBIT(nbits,zdest)
X *  {
X *      if (nbits > bits_left)
X *          FillBitBuffer();
X *      zdest = (int)((UWORD)bitbuf & mask_bits[nbits]);
X *      bitbuf >>= nbits;
X *      bits_left -= nbits;
X *  }
X *
X */
X
X
X#define PEEKBIT(nbits) (nbits>bits_left? (FillBitBuffer(),\
X  (UWORD)bitbuf & mask_bits[nbits]) : (UWORD)bitbuf & mask_bits[nbits])
X
X
X#define NUKE_CRs(buf,len) {register int i,j; for (i=j=0; j<len;\
X  (buf)[i++]=(buf)[j++]) if ((buf)[j]=='\r') ++j; len=i;}
X
X/*
X *  Remove all the ASCII carriage returns from buffer buf (length len),
X *  shortening as necessary (note that len gets modified in the process,
X *  so it CANNOT be an expression).  This macro is intended to be used
X *  BEFORE A_TO_N(); hence the check for CR instead of '\r'.  NOTE:  The
X *  if-test gets performed one time too many, but it doesn't matter.
X *
X *  macro NUKE_CRs(buf,len)
X *  {
X *      register int   i, j;
X *
X *      for (i = j = 0;  j < len;  (buf)[i++] = (buf)[j++])
X *          if ((buf)[j] == CR)
X *              ++j;
X *      len = i;
X *  }
X *
X */
X
X
X#define TOLOWER(str1,str2) {char *ps1,*ps2; ps1=(str1)-1; ps2=(str2);\
X  while(*++ps1) *ps2++=(char)(isupper((int)(*ps1))?tolower((int)(*ps1)):*ps1);\
X  *ps2='\0';}
X
X/*
X *  Copy the zero-terminated string in str1 into str2, converting any
X *  uppercase letters to lowercase as we go.  str2 gets zero-terminated
X *  as well, of course.  str1 and str2 may be the same character array.
X *
X *  macro TOLOWER( str1, str2 )
X *  {
X *      char  *ps1, *ps2;
X *
X *      ps1 = (str1) - 1;
X *      ps2 = (str2);
X *      while (*++ps1)
X *          *ps2++ = (char)(isupper((int)(*ps1))? tolower((int)(*ps1)) : *ps1);
X *      *ps2='\0';
X *  }
X *
X *  NOTES:  This macro makes no assumptions about the characteristics of
X *    the tolower() function or macro (beyond its existence), nor does it
X *    make assumptions about the structure of the character set (i.e., it
X *    should work on EBCDIC machines, too).  The fact that either or both
X *    of isupper() and tolower() may be macros has been taken into account;
X *    watch out for "side effects" (in the C sense) when modifying this
X *    macro.
X */
X
X
X#ifndef ascii_to_native
X#  define ascii_to_native(c)   (c)
X#  define A_TO_N(str1)
X#else
X#  ifndef NATIVE
X#    define NATIVE     "native chars"
X#  endif
X#  define A_TO_N(str1) {register unsigned char *ps1;\
X     for (ps1=str1; *ps1; ps1++) *ps1=ascii_to_native(*ps1);}
X#endif
X
X/*
X *  Translate the zero-terminated string in str1 from ASCII to the native
X *  character set. The translation is performed in-place and uses the
X *  ascii_to_native macro to translate each character.
X *
X *  macro A_TO_N( str1 )
X *  {
X *      register unsigned char *ps1;
X *
X *      for (ps1 = str1;  *ps1;  ++ps1)
X *          *ps1 = ascii_to_native(*ps1);
X *  }
X *
X *  NOTE:  Using the ascii_to_native macro means that is it the only part of
X *    unzip which knows which translation table (if any) is actually in use
X *    to produce the native character set.  This makes adding new character
X *    set translation tables easy, insofar as all that is needed is an
X *    appropriate ascii_to_native macro definition and the translation
X *    table itself.  Currently, the only non-ASCII native character set
X *    implemented is EBCDIC, but this may not always be so.
X */
X
X
X
X
X
X/*************/
X/*  Globals  */
X/*************/
X
X   extern int       aflag;
X/* extern int       bflag;   reserved */
X   extern int       cflag;
X   extern int       fflag;
X   extern int       jflag;
X   extern int       overwrite_none;
X   extern int       overwrite_all;
X   extern int       force_flag;
X   extern int       quietflg;
X#ifdef DOS_OS2
X   extern int       sflag;
X#endif
X   extern int       tflag;
X   extern int       uflag;
X   extern int       V_flag;
X#ifdef VMS
X   extern int       secinf;
X#endif
X#ifdef MACOS
X   extern int       hfsflag;
X#endif
X   extern int       process_all_files;
X   extern longint   csize;
X   extern longint   ucsize;
X   extern char      *fnames[];
X   extern char      **fnv;
X   extern char      sig[];
X   extern char      answerbuf[];
X   extern min_info  *pInfo;
X   extern char      *key;
X   extern ULONG     keys[];
X
X#ifdef MACOS
X   union work {
X     struct {
X       short *Prefix_of;        /* (8193 * sizeof(short)) */
X       byte *Suffix_of;
X       byte *Stack;
X     } shrink;
X     byte *Slide;
X   };
X#else
X   union work {
X     struct {
X       short Prefix_of[HSIZE + 2];      /* (8194 * sizeof(short)) */
X       byte Suffix_of[HSIZE + 2];       /* also s-f length_nodes (smaller) */
X       byte Stack[HSIZE + 2];           /* also s-f distance_nodes (smaller) */
X     } shrink;
X     byte Slide[WSIZE];
X   };
X#endif
X   extern union work area;
X
X#  define prefix_of area.shrink.Prefix_of
X#  define suffix_of area.shrink.Suffix_of
X#  define stack area.shrink.Stack
X#  define slide area.Slide
X
X   extern ULONG     crc32val;
X   extern UWORD     mask_bits[];
X
X   extern byte      *inbuf;
X   extern byte      *inptr;
X   extern int       incnt;
X   extern ULONG     bitbuf;
X   extern int       bits_left;
X   extern boolean   zipeof;
X   extern int       zipfd;
X#ifdef MSWIN
X   extern char      *zipfn;
X#else
X   extern char      zipfn[];
X#endif
X   extern longint   extra_bytes;
X   extern longint   cur_zipfile_bufstart;
X   extern byte      *extra_field;
X   extern char      local_hdr_sig[];
X   extern char      central_hdr_sig[];
X   extern char      end_central_sig[];
X   extern local_file_hdr  lrec;
X   extern cdir_file_hdr   crec;
X   extern ecdir_rec       ecrec;
X   extern struct stat     statbuf;
X
X   extern byte      *outbuf;
X   extern byte      *outptr;
X#ifdef MSWIN
X   extern byte __far *outout;
X   extern char     *filename;
X#else
X   extern byte      *outout;
X   extern char      filename[];
X#endif
X   extern longint   outpos;
X   extern int       outcnt;
X   extern int       outfd;
X   extern int       mem_mode;
X   extern int       disk_full;
X
X   extern char      *EndSigMsg;
X   extern char      *CentSigMsg;
X   extern char      *SeekMsg;
X   extern char      *ReportMsg;
X
X#ifdef DECLARE_ERRNO
X   extern int       errno;
X#endif
X
X#ifdef EBCDIC
X   extern byte      ebcdic[];
X#endif
X
X#ifdef MACOS
X   extern short     gnVRefNum;
X   extern long      glDirID;
X   extern OSType    gostCreator;
X   extern OSType    gostType;
X   extern boolean   fMacZipped;
X   extern boolean   macflag;
X   extern short     giCursor;
X   extern CursHandle rghCursor[];
X#endif
END_OF_FILE
  if test 43208 -ne `wc -c <'unzip.h'`; then
    echo shar: \"'unzip.h'\" unpacked with wrong size!
  fi
  # end of 'unzip.h'
fi
echo shar: End of archive 1 \(of 14\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
