Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Subject:  v31i023:  mbox - A BBS for UNIX and MINIX v1.6 PL10, Part07/11
Message-ID: <1992Jul10.050400.27638@sparky.imd.sterling.com>
X-Md4-Signature: 2d33d01640f849fcc491fee06a4f794c
Date: Fri, 10 Jul 1992 05:04:00 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Posting-number: Volume 31, Issue 23
Archive-name: mbox/part07
Environment: MINIX, ISC, ESIX, SVR3
Supersedes: mbox: Volume 29, Issue 63-72

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  src/Makefile src/bled.c src/intro.c src/main.c src/mbox.h
# Wrapped by kent@sparky on Thu Jul  9 23:26:02 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 7 (of 11)."'
if test -f 'src/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/Makefile'\"
else
  echo shar: Extracting \"'src/Makefile'\" \(11028 characters\)
  sed "s/^X//" >'src/Makefile' <<'END_OF_FILE'
X#---------------------------------------------------------------------------
X#
X#                      ix/MBox  M A K E F I L E
X#             Bulletin Board System for UNIX(-Derivations)
X#			
X#			   Volker Schuermann
X#		      Wuppertal, FRG, 26.10.1991
X#
X#
X#	  	           Modified for SVR3    
X#		
X#	      Walter Buerger <walterb@weller.ruhr.sub.org>
X#              Ralf Heidelberg <ralf@heibox.ruhr.sub.org>
X#		  Solingen/Wuppertal, FRG, 08.11.1991
X#
X#
X#                        Modified for ISC 2.21
X#
X#	   	   Hergo Pape <hergo@ivcmd.BOERDE.DE>
X#		       Magdeburg, FRG, 16.11.1991
X#
X#		
X#			     DIFF-Support
X#
X#		Ralf Heidelberg <ralf@heibox.ruhr.sub.org>
X#			Wuppertal, FRG, 07.01.1992
X#
X#
X#		       Modified for ST Minix/c86
X#      
X#		      Olaf <olaf@oski.toppoint.de>
X#      		          Kiel, FRG, 14.01.1992
X#
X#
X#                           SVR4 Support by 
X#
X#                Andreas Laumann <andreas@xenox.w.open.de>
X#	               Wuppertal, FRG, 30.05.1992
X#
X#
X#---------------------------------------------------------------------------
X# CFLAGS: 
X# 
X# -D_MBOX         Has to be set ALWAYS!
X# -D_SYS7         UNIX System 7 (MINIX, COHERENT, ...)
X# -D_MINIX        MINIX special stuff
X# -D_ISC          Interactive UNIX goodies
X# -D_SCO          For SCO UNIX only
X# -D_SVR4         For AT&T's System V Rel 4 
X# -D_LONGNAMES    Long filenames allowed (SVR4, BSD, ULTRIX, ...)
X# -D_ESTDIO       Earl Chew's "estdio.h" and GNU C 1.37
X# -D_CORELEFT     To check your memory (-D_CORELEFT=10000)
X# -D_DATESTAMP    Add time&date to console LOGFILE
X# -D_NOINDEX      Index files for NEWS will be created interactive for
X#		  each group that is called by a user
X#		  Otherwise MB-DAEMON has to be called by [cron] daily
X# -D_BAUDRATE     If you've a HST-Modem with FIXED BAUDRATE
X# -D_MULTIMEDIA   Local "Multimedia"-Features (i.e. read RTF-Files etc.)
X# -D_CNEWS	  To prevent problems with C-NEWS' aliasing mechanism
X#---------------------------------------------------------------------------
X# This is a workaround for the System V (not SVR4) /bin/sh bug 
X
XSHELL = /bin/sh
X
X# The following definition tells all ix/MBox BBS parts where they have to 
X# live in the future. 
X
XMBOXHOME=/local/mbox
X
X# All BBS binaries will be stored in the BIN dircetory ... except [mbrsh]
X# NOTE that the path to BIN has to be in all users 'SET'!
X
XBIN=/usr/bin
X
X#---------------------------------------------------------------------------
X# And now some predefined settings for various compilers/systems:
X#
X# MINIX 386 (BCC)
X CC= bcc
X LN= ln
X CHMEM= chmem
X CFLAGS= -D_MINIX -D_SYS7 -D_MBOX -D_BAUDRATE -D_MULTIMEDIA \
X	-DHOME="\"$(MBOXHOME)"\" -DADDRMODE
X LIB=
X CONVERT= mv a.out $@
X CHOWN= chown $(OWNER).$(GROUP) 
X CHGRP= :
X STRIP= strip $@
X#
X#
X# MINIX 386 & ESTDIO.H
X# CC= cc
X# LN= ln
X# CHMEM= chmem
X# CFLAGS= -D_MINIX -D_SYS7 -D_ESTDIO -D_MBOX -DHOME="\"$(MBOXHOME)"\"
X# LIB= -lestdio
X# CONVERT= mv a.out $@
X# CHOWN= chown $(OWNER).$(GROUP) 
X# CHGRP= :
X# STRIP= strip $@
X#
X#
X# MINIX 386 (GCC 1.37)
X# CC= gcc
X# LN= ln
X# CHMEM= : 
X# CFLAGS= -O -D_MINIX -D_SYS7 -D_MBOX -D_ESTDIO -DHOME="\"$(MBOXHOME)"\" \
X#	-D_BAUDRATE -D_MULTIMEDIA	
X# LIB=
X# CONVERT= /usr/local/bin/gcc2minix < a.out > $@
X# CHOWN= chown $(OWNER).$(GROUP) 
X# CHGRP= :
X# STRIP= strip $@
X#
X#
X# ESIX SVR3 
X# CC= cc
X# LN= ln
X# CHMEM= :
X# CFLAGS= -O -D_MBOX -DHOME="\"$(MBOXHOME)"\"
X# LIB= -lcurses -s
X# CONVERT= mv a.out $@
X# CHOWN= chown $(OWNER) 
X# CHGRP= chgrp $(GROUP)
X# STRIP= $@
X#
X#
X# ISC 2.21 & "Shared Libs" 
X# CC= gcc
X# LN= ln
X# CHMEM= :
X# CFLAGS= -O -D_MBOX -D_ISC -traditional -DHOME="\"$(MBOXHOME)"\"
X# LIB= -ltermcap -lcurses -lc_s -s
X# CONVERT= mv a.out $@
X# CHOWN= chown $(OWNER) 
X# CHGRP= chgrp $(GROUP)
X# STRIP= :
X#
X#
X# Dell 2.1 (SVR4) & GCC 2.1
X# CC= gcc
X# LN= ln
X# CHMEM= :
X# CFLAGS= -traditional -g -D_MBOX -D_SVR4 -D_DATESTAMP -D_BAUDRATE \
X#	 -D_LONGNAMES -D_MULTIMEDIA -D_CNEWS -DHOME="\"$(MBOXHOME)"\"
X# LIB= -ltermlib
X# DBM= 
X# CONVERT= mv a.out $@
X# CHOWN= chown $(OWNER) 
X# CHGRP= chgrp $(GROUP)
X# STRIP= :
X
X# This is the pager which BLED uses to display his helpfile 
XBLPAGER=/bin/cat
X
X# In this directory, you hide your helpfiles and manuals
XHELPDIR=/usr/doc
X
X
X# Sorry, but SETUID root.root is still necessary ...
XOWNER=root
XGROUP=root
X
X
XMBOX.OBJ=main.o getch.o tools.o getline.o \
X	intro.o nerror.o show.o	loop.o help.o admin.o mail.o control.o \
X	misc.o lesen.o lesen2.o pd.o portinfo.o befehl.o misc2.o \
X	postfach.o ctrlx.o makro.o weiterl.o coreleft.o games.o suchen.o \
X	baudrate.o outdial.o faces.o
X
XBLED.OBJ=bled.o getch.o bltools.o blgetline.o derror.o
X
XXMD.OBJ=xmd.o tools.o derror.o
X
XMBRSH.OBJ=mbrsh.o
X
XMBD.OBJ=tools.o mb-daemon.o derror.o
X
XDIFF_FILES=admin.c befehl.c bled.c control.c coreleft.c \
X	ctrlx.c defs.h derror.c games.c getch.c getline.c help.c intro.c \
X	lesen.c lesen2.c loop.c mail.c main.c makro.c mb-daemon.c mbox.h \
X	mbrsh.c misc.c misc2.c nerror.c patchlevel.h pd.c portinfo.c \
X	postfach.c show.c suchen.c tools.c weiterl.c xmd.c baudrate.c \
X	outdial.c faces.c
X
XPROGS=mbox bled mb-daemon mbrsh xmd
X
Xdefault:; @echo ''
X	  @echo 'One of the following:'
X	  @echo ''
X	  @echo 'make all       <-   Create every object file'
X	  @echo 'make world     <-   Make directories and set permissions'
X	  @echo 'make inst      <-   Install the BBS (make all, world, etc.)'
X	  @echo 'make english   <-   Prepare for english version'
X	  @echo 'make german    <-   Prepare for german version'
X	  @echo 'make clean     <-   Remove object files'
X	  @echo 'make mbox      <-   Make the BBS itself (ix/MBox BBS)'
X	  @echo 'make mb-daemon <-   Compile "mb-daemon" (NEWS Scanner)'
X	  @echo 'make xmd       <-   Create "xmd" (Mailing Agent)'
X	  @echo 'make mbrsh     <-   Build "mbrsh" (External Shell)'
X	  @echo 'make bled      <-   Make "bled" (B[etter] L[ine] ED[itor])'
X	  @echo ''
X	  @echo 'Active definitions:'
X	  @echo ''
X	  @echo 'Compiler [$(CC)]'
X	  @echo 'CFLAGS   [$(CFLAGS)]'
X	  @echo 'Lib(s)   [$(LIB)]'
X	  @echo 'Root-ID  [$(OWNER).$(GROUP)]'
X	  @echo ''
X
Xall: $(PROGS)
X	@echo ''
X	@echo '- All files are made' 
X	@echo ''
X
Xmbox:	$(MBOX.OBJ)
X	@echo ''
X	@echo '- The BBS is going to be compiled...'
X	@echo ''
X	$(CC) $(CFLAGS) $(MBOX.OBJ) $(LIB) 
X	@$(CONVERT)
X	@$(CHGRP) $@
X	@$(CHOWN) $@
X	@chmod +x mbox
X	@chmod ug+s mbox
X	@$(CHMEM) +250000 mbox
X	@$(STRIP)
X
Xbled:	$(BLED.OBJ) 
X	@echo ''
X	@echo '- The Editor (BLED) is going to be compiled...'
X	@echo ''
X	$(CC) $(CFLAGS) $(BLED.OBJ) $(LIB) 
X	@$(CONVERT)
X	@$(CHMEM) +10000 bled	
X	@$(STRIP)
X	@chmod +x bled
X
Xxmd:    $(XMD.OBJ) 
X	@echo ''
X	@echo '- The Mailing Agent (xmd) is going to be compiled...'
X	@echo ''
X	$(CC) $(CFLAGS) $(XMD.OBJ) $(LIB) 
X	@$(CONVERT)
X	@$(STRIP)
X	@chmod +x xmd
X
Xmbrsh:  $(MBRSH.OBJ) 
X	@echo ''
X	@echo '- The external SHELL (mbrsh) is going to be compiled...'
X	@echo ''
X	$(CC) $(CFLAGS) $(MBRSH.OBJ) $(LIB) 
X	@$(CONVERT)
X	@$(STRIP)
X	@chmod +x mbrsh
X
Xmb-daemon:    $(MBD.OBJ) 
X	@echo ''
X	@echo '- The NEWS Scanner (mb-daemon) is going to be compiled...'
X	@echo ''
X	$(CC) $(CFLAGS) $(MBD.OBJ) $(LIB) 
X	@$(CONVERT)
X	@chmod +x mb-daemon
X	@chmod ug+s mb-daemon
X	@$(CHMEM) +64000 mb-daemon		
X	@$(STRIP)
X
Xinst:	world all
X	@echo
X	@echo -n '- The BBS is going to be installed...'
X	@cp mbox $(BIN)
X	@cp bled $(BIN)
X	@cp mbrsh $(MBOXHOME)
X	@cp mb-daemon $(BIN)
X	@cp xmd $(BIN)
X	@cp bled.doc $(HELPDIR)
X	@$(CHOWN) $(MBOXHOME)/* $(MBOXHOME)/etc/*
X	@$(CHGRP) $(MBOXHOME)/* $(MBOXHOME)/etc/*
X	@chmod +s $(BIN)/mbox
X	@chmod +s $(BIN)/mb-daemon
X	@echo  'done.'
X	@echo
X
Xcopy:
X	cp mbox bled mb-daemon xmd $(BIN)
X	cp mbrsh $(MBOXHOME)
X
Xenglish:;
X	@echo
X	@echo -n '- Preparing english version...'
X	@rm $(MBOXHOME)/src/mbox.msg
X	@ln $(MBOXHOME)/src/mbox.english $(MBOXHOME)/src/mbox.msg
X	@rm $(MBOXHOME)/etc/help.*
X	@ln $(MBOXHOME)/etc/english.befehle $(MBOXHOME)/etc/help.befehle
X	@ln $(MBOXHOME)/etc/english.hilfe $(MBOXHOME)/etc/help.hilfe
X	@ln $(MBOXHOME)/etc/english.shorthelp $(MBOXHOME)/etc/help.shorthelp
X	@echo 'done.'
X	@echo ''
X
Xgerman:;
X	@echo
X	@echo -n '- Preparing german version...'
X	@rm $(MBOXHOME)/src/mbox.msg
X	@ln $(MBOXHOME)/src/mbox.deutsch $(MBOXHOME)/src/mbox.msg
X	@rm $(MBOXHOME)/etc/help.*
X	@ln $(MBOXHOME)/etc/deutsch.befehle $(MBOXHOME)/etc/help.befehle
X	@ln $(MBOXHOME)/etc/deutsch.hilfe $(MBOXHOME)/etc/help.hilfe
X	@ln $(MBOXHOME)/etc/deutsch.shorthelp $(MBOXHOME)/etc/help.shorthelp
X	@echo 'done.'
X	@echo ''
X
Xworld:;	@echo
X	@echo -n '- Making directories...'
X	@if test -d $(MBOXHOME) ; then echo -n ''; else mkdir $(MBOXHOME) ; fi
X	@if test -d $(BIN) ; then echo -n ''; else mkdir $(BIN) ; fi
X	@if test -d $(MBOXHOME)/etc ; then echo -n ''; \
X		else mkdir $(MBOXHOME)/etc ; fi
X	@if test -d $(MBOXHOME)/lib ; then echo -n ''; \
X		else mkdir $(MBOXHOME)/lib ; fi
X	@if test -d $(MBOXHOME)/src ; then echo -n ''; \
X		else mkdir $(MBOXHOME)/src ; fi
X	@if test -d $(MBOXHOME)/usr ; then echo -n ''; \
X		else mkdir $(MBOXHOME)/usr ; fi
X	@$(CHOWN) $(MBOXHOME) $(MBOXHOME)/*
X	@$(CHGRP) $(MBOXHOME) $(MBOXHOME)/*
X	@chmod ug+rwx $(MBOXHOME)/lib
X	@chmod o-rwx $(MBOXHOME)/lib
X	@chmod ug+rwx $(MBOXHOME)/src
X	@chmod o-rwx $(MBOXHOME)/src
X	@chmod ug+rwx $(MBOXHOME)/etc
X	@chmod o-rwx $(MBOXHOME)/etc
X	@chmod ug+rwx $(MBOXHOME)/usr
X	@chmod o-rwx $(MBOXHOME)/usr
X	@echo 'done.'
X	@echo ''
X
X
Xclean:;	
X	@echo ''
X	@echo -n '- Old stuff is going to be deleted...' 
X	@rm -f *.o mbox mbrsh bled xmd mb-daemon bltools.c blgetline.c
X	@echo 'done.'
X	@echo ''
X
Xblgetline.o:	mbox.h patchlevel.h
X	@if test -f blgetline.c ; then echo -n '' ; \
X		else $(LN) getline.c blgetline.c ; fi
X	$(CC) -c $(CFLAGS) blgetline.c
X
Xbltools.o:	mbox.h patchlevel.h
X	@rm -f bltools.c
X	@cat undef.c > bltools.c
X	@cat tools.c >> bltools.c
X	$(CC) -c $(CFLAGS) bltools.c
X
Xbled.o:	mbox.h patchlevel.h
X	$(CC) -c $(CFLAGS) -DHILFE="\"$(BLPAGER) $(HELPDIR)/bled.doc"\" bled.c
X
X
X
X# For automagic update service (Beta-Testers only) ...
XDIFF	 = /usr/bin/cdiff
XSRC      = /mbox/src
XSRC_ORIG = /mbox/1.6
XADRESSE  = "volkers@unnet.w.open.DE"
X
X
Xdiff: $(DIFF_FILES)
X	@echo DiffMailer by ralf@heibox.ruhr.sub.org >$@
X	@echo Project: ix/MBox 1.6 >>$@
X	@echo Adresse: $(ADRESSE)
X	@echo Folgende Aenderungen sind in $? vorzunehmen >>$@
X	@date >>$@
X	@echo >>$@
X	@for f in $? ; do \
X	echo ----- $$f -----; \
X	echo ----- $$f ----- >>$@; \
X	$(DIFF) $(SRC)/$$f $(SRC_ORIG) | cat >>$@; \
X	done
X	@cat diff | mail -s "ix/MBox PATCHES" volkers@unnet.w.open.de
X
X
Xadmin.o:		mbox.h defs.h
Xbefehl.o:		mbox.h defs.h
Xbled.o:			mbox.h defs.h
Xbaudrate.o:		mbox.h defs.h
Xcontrol.o:		mbox.h defs.h
Xderror.o:		mbox.h defs.h
Xfaces.o:		mbox.h defs.h
Xgames.o:		mbox.h defs.h
Xgetline.o:		mbox.h defs.h
Xhelp.o:			mbox.h defs.h
Xintro.o:		mbox.h defs.h
Xlesen:			mbox.h defs.h
Xlesen2.o:		mbox.h defs.h
Xloop.o:			mbox.h defs.h
Xmail.o:			mbox.h defs.h
Xmain.o:			mbox.h defs.h
Xmakro.o:		mbox.h defs.h
Xmbd.o:			mbox.h defs.h
Xmbrsh.o:		mbox.h defs.h
Xmisc.o:			mbox.h defs.h
Xmisc2.o:		mbox.h defs.h
Xnerror.o:		mbox.h defs.h
Xoutdial.o:		mbox.h defs.h
Xpd.o:			mbox.h defs.h
Xportinfo.o:		mbox.h defs.h
Xpostfach.o:		mbox.h defs.h
Xshow.o:			mbox.h defs.h
Xsuchen.o:		mbox.h defs.h
Xtools.o:		mbox.h defs.h
Xweiterl.o:		mbox.h defs.h
Xxmd.o:			mbox.h defs.h
X
X
END_OF_FILE
  if test 11028 -ne `wc -c <'src/Makefile'`; then
    echo shar: \"'src/Makefile'\" unpacked with wrong size!
  fi
  # end of 'src/Makefile'
fi
if test -f 'src/bled.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/bled.c'\"
else
  echo shar: Extracting \"'src/bled.c'\" \(11315 characters\)
  sed "s/^X//" >'src/bled.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <setjmp.h>
X#include <signal.h>
X
X#define VERSION "LED 3.5 (Unix)"
X#define AUTOR   "Volker.Schuermann@unnet.w.open.de"
X
X#ifndef STRING
X#define STRING 85
X#endif
X
X#include "mbox.msg"
X
X
X#define CR     13
X#define LF     10
X#define BS      8
X#define CTRL_X 24
X#define CTRL_D  4
X
X
X#define TMP "/tmp"
X
X#define APPEND 1
X#define INSERT 2
X#define FINISH 3
X#define QUIT   4
X#define UPLOAD 5
X
X#ifdef _MBOX
X#undef _MBOX
X#endif
X
Xstatic int melted;
X
Xstatic char tmp1[STRING];
Xstatic char tmp2[STRING];
X
Xstatic int von, bis;
Xstatic int max_line;
X
Xstatic char imode;
X
Xstatic char THE_FILE[STRING];
Xstatic int  THE_LINE;
X
X
Xint melt(startlin)
Xint startlin;
X{
X  FILE *fp;
X  FILE *ff;
X  FILE *fg;
X  char s[255];
X  char tmp3[STRING];
X  int i;
X
X
X  if (melted == 0) return 0;
X
X  sprintf(tmp3, "%s/bled3.%d", TMP, getpid());
X
X  fg = fopen(tmp3, "w");
X  if (fg == NULL) {
X	printf("\n%s\n", tmp3);
X	exit(-1);
X  }
X  fp = fopen(tmp1, "r");
X  if (fp == NULL) {
X	printf("\n%s\n", tmp1);
X	exit(-1);
X  }
X  i = 0;
X  while ((i < startlin) && (fgets(s, 250, fp) != NULL)) {
X	fputs(s, fg);
X	i++;
X  }
X  ff = fopen(tmp2, "r");
X  if (ff != NULL) {
X	while (fgets(s, 250, ff) != NULL) {
X		fputs(s, fg);
X		i++;
X	}
X	fclose(ff);
X  }
X  while (fgets(s, 250, fp) != NULL) {
X	fputs(s, fg);
X  }
X  fclose(fg);
X  fclose(fp);
X
X  unlink(tmp1);
X  rename(tmp3, tmp1);
X  unlink(tmp3);
X
X  return 0;
X}
X
X
X
Xbledmove(from, to)
Xchar from[], to[];
X{
X  FILE *fp;
X  FILE *ff;
X  char s[255];
X
X
X  fp = fopen(from, "r");
X  if (fp == NULL) {
X	printf("\n%s\n", from);
X	exit(-1);
X  }
X  ff = fopen(to, "w");
X  if (ff == NULL) {
X	printf("\n%s\n", from);
X	exit(-1);
X  }
X  while (fgets(s, 250, fp) != NULL) {
X	fputs(s, ff);
X  }
X  fclose(fp);
X  fclose(ff);
X}
X
X
X
X
X
Xzeigen(mode)
Xchar mode;
X{
X  FILE *fp;
X  char t[STRING];
X  char s[255];
X  int i;
X
X  if ((von != 0) && (bis == 0)) bis = von;
X  if ((von == 0) && (bis == 0)) bis = 32000;
X
X  if (von > bis) {
X	/*
X	printf("\n\nLED: Fehler bei der Zeilenangabe.\n");
X	*/	
X	printf("\n\nLED: %s\n", BLD01_MSG);
X	return;
X  }
X  fp = fopen(tmp1, "r");
X  if (fp == NULL) {
X	printf("\n%s\n", tmp1);
X	exit(-1);
X  }
X  i = 1;
X  printf("\n\n");
X  while (fgets(s, 250, fp) != NULL) {
X	if ((i >= von) && (i <= bis)) {
X		if (mode == 'l')
X			printf("L%04.4d %s", i, s);
X		else
X			printf("%s", s);
X	}
X	i++;
X  }
X  fclose(fp);
X}
X
X
X
Xloeschen()
X{
X  FILE *fp;
X  FILE *ff;
X  char t[STRING];
X  char s[255];
X  int i;
X
X  if ((von != 0) && (bis == 0)) bis = von;
X  if ((von == 0) && (bis == 0)) bis = 32000;
X
X  if (von > bis) {
X	/*
X	printf("\n\nLED: Fehler bei der Zeilenangabe.\n");
X	*/	
X	printf("\n\nLED: %s\n", BLD01_MSG);
X	return;
X  }
X  ff = fopen(tmp2, "w");
X  if (ff == NULL) {
X	printf("\n%s\n", tmp2);
X	exit(-1);
X  }
X  fp = fopen(tmp1, "r");
X  if (fp == NULL) {
X	printf("\n%s\n", tmp1);
X	exit(-1);
X  }
X  i = 1;
X  printf("\n\n");
X  while (fgets(s, 250, fp) != 0) {
X	if ((i < von) || (i > bis)) {
X		fputs(s, ff);
X	}
X	i++;
X  }
X  fclose(fp);
X  fclose(ff);
X
X  unlink(tmp1);
X  rename(tmp2, tmp1);
X}
X
X
X
Xupload()
X{
X  FILE *fp;
X  char c;
X  char lf;
X
X  fp = fopen(tmp2, "w");
X  if (fp == NULL) {
X	printf("\n%s\n", tmp2);
X	exit(-1);
X  }
X  /*
X  printf("\n\nLED: Uebertragung beginnt. (Beenden mit CTRL-X !)\n\n");
X  */
X  printf("\n\nLED: %s\n\n", BLD02_MSG);
X
X  c = 0;
X  lf = CR;
X
X
X  while ((c != CTRL_X) && (c != CTRL_D)) {
X
X        c = getint();
X
X	if ((c == CR) && (lf == CR)) fputc(LF, fp);
X	if (c == CR) lf = CR;
X	if (c == LF) lf = LF;
X	if ((c != CTRL_X) && (c != CTRL_D) && (c != CR)) {
X		fputc(c, fp);
X	}
X  }
X  fclose(fp);
X}
X
X
X
Xkorrigieren()
X{
X  FILE *fp;
X  FILE *ff;
X  char s[255];
X  char t[255];
X  int i, z;
X
X  if (von == 0) {
X	/*
X	printf("\n\nLED: Fehler bei der Zeilenangabe.\n");
X	*/	
X	printf("\n\nLED: %s\n", BLD01_MSG);
X	return;
X  }
X  fp = fopen(tmp1, "r");
X  if (fp == NULL) {
X	printf("\n%s\n", tmp1);
X	exit(-1);
X  }
X  ff = fopen(tmp2, "w");
X  if (ff == NULL) {
X	printf("\n%s\n", tmp1);
X	exit(-1);
X  }
X  i = 1;
X  while (fgets(s, 250, fp) != NULL) {
X	if (i == von) {
X		t[0] = '\0';
X		strcpy(t, s); 
X		z = strlen(t);
X		while(t[z] < 33) z--;
X		z++;
X		t[z] = '\0';
X		s[0] = '\0';
X		if (length(t) < 74)
X			printf("\n\nK%04.4d ", i);
X		else
X			printf("\n\n");
X		strcat(s, getline(74, 1001, ' ', t));
X		strcat(s, "\n");
X		printf("\n");
X	}
X	fputs(s, ff);
X	i++;
X  }
X  fclose(ff);
X  fclose(fp);
X  unlink(tmp1);
X  rename(tmp2, tmp1);
X}
X
X
X
X
Xcrunch(s)
Xchar s[];
X{
X  char t[STRING];
X  int i = 0, a = 0;
X
X  von = 0;
X  bis = 0;
X
X  while (s[i] != '\0') {
X	if ((s[i] == ',') || (s[i] == '-')) a = i;
X	i++;
X  }
X  if (a == 0) a = i;
X  t[0] = '\0';
X  strcat(t, strcopy(s, 3, (a - 1)));
X  von = atoi(t);
X  t[0] = '\0';
X  strcat(t, strcopy(s, (a + 1), i));
X  bis = atoi(t);
X  if ((a != i) && (bis == 0)) bis = 32000;
X}
X
X
X
X
X
Xint befehl(s)
Xchar s[];
X{
X  char c = s[1];
X
X  if ((s[2] != ' ') && (s[2] != '\0') && (s[1] != '\0')) {
X	/*
X	printf("\n\nLED: Syntax-Fehler.\n");
X	*/
X	printf("\n\nLED: %s\n", BLD03_MSG);
X	return 0;
X  }
X  crunch(s);
X
X  switch (c) {
X      case '\0':
X			return FINISH;
X			break;
X      case '?':
X			printf("\n\n%c", CR);
X			ansi("mr");
X			/*
X			printf(" %s  -  Befehlsuebersicht ", VERSION);
X			*/
X			printf(" %s  -  %s ", VERSION, BLD04_MSG);
X			ansi("me");
X			printf("\n\n");
X			/*
X			printf(".l [ZEILE]|[VON,BIS]   lesen\n");
X			printf(".L [ZEILE]|[VON,BIS]   lesen (keine Zeilennummern)\n");
X			printf(".i AB                  einfuegen\n");
X			printf(".a                     anhaengen (beendet einfuegen)\n");
X			printf(".k ZEILE               korrigieren\n");
X			printf(".d [ZEILE]|[VON,BIS]   loeschen\n");
X			printf(".u                     uebertragen (ASCII-Upload)\n");
X			printf(".q                     abbrechen\n");
X			printf(".h                     ausfuehrliche Hilfe\n");
X			printf(".                      sichern & beenden\n\n");
X			printf("ZEILE, VON, BIS, AB sind gueltige Zeilennummern.\n");
X			printf("Angaben in [KLAMMERN] sind optional. Werden\n");
X			printf("keine Angaben gemacht gilt AB=1, VON=1, BIS=32000.\n");
X			*/
X			printf("%s\n", BLD05_MSG);
X			printf("%s\n", BLD06_MSG);
X			printf("%s\n", BLD07_MSG);
X			printf("%s\n", BLD08_MSG);
X			printf("%s\n", BLD09_MSG);
X			printf("%s\n", BLD10_MSG);			
X			printf("%s\n", BLD11_MSG);
X			printf("%s\n", BLD12_MSG);
X			printf("%s\n", BLD13_MSG);
X			printf("%s\n", BLD14_MSG);
X			printf("\n");
X			printf("%s\n", BLD15_MSG);
X			printf("%s\n", BLD16_MSG);
X			printf("%s\n", BLD17_MSG);
X			break;
X      case 'h':	        printf("\n\n%c", CR);
X			ansi("mr");
X			/*
X			printf(" %s  -  Hilfe ", VERSION);
X			*/
X			printf(" %s  -  %s ", VERSION, BLD18_MSG);
X			ansi("me");
X			printf("\n\n");
X			system( HILFE );
X			break;
X      case 'a':	
X			return APPEND;	
X			break;
X      case 'i':
X			return INSERT;	
X			break;
X      case 'l':
X      case 'L':
X			zeigen(c);
X			return APPEND;
X			break;
X      case 'd':
X			loeschen();
X			return APPEND;
X			break;
X      case 'k':
X      case 'c':
X			korrigieren();
X			return APPEND;
X      case 'u':
X			upload();
X			return UPLOAD;
X      case 'q':
X			unlink(tmp1);
X			unlink(tmp2);
X			/*
X			printf("\n\nLED: Abgebrochen. Datei NICHT gesichert.\n\n");
X			*/
X			printf("\n\nLED: %s\n\n", BLD19_MSG);
X			exit(0);
X			break;
X      default:		/*
X			printf("\n\nLED: Befehl unbekannt.\n");
X			*/
X			printf("\n\nLED: %s\n", BLD20_MSG);
X}
X  return 0;
X}
X
X
X
X
X
Xint erfassen(line, mode)
Xint line, mode;
X{
X  FILE *fp;
X  char s[STRING];
X  char t[STRING];
X  char def[STRING];
X  int ok = 0;
X  int elin = line;
X  int startlin = line - 1;
X  int a, b;
X
X  melted = 1;			/* Sicher ist sicher ... */
X  THE_LINE = startlin;
X
X  fp = fopen(tmp2, "w");
X  if (fp == NULL) return -1;
X
X  def[0] = '\0';
X
X  do {
X	if (elin > max_line) max_line = elin;
X	printf("\n%c%04.4d ", imode, elin);
X	s[0] = '\0';
X	if (def[0] == '\0')
X		strcat(s, getline(73, 1, ' ', " "));
X	else
X		strcat(s, getline(73, 1001, ' ', def));
X
X	if (strcomp("<BREAK>", s) == 0) {
X		sprintf(s, ".?");
X	}
X	if (s[0] == '.') {
X		fclose(fp);
X		melted = melt(startlin);
X
X		ok = befehl(s);
X
X		if (ok == UPLOAD) {
X			melted = 1;
X			melted = melt(startlin);
X			ok = APPEND;
X		}
X		if (ok == INSERT) {
X			imode = 'I';
X			if (von < 1) von = 1;
X			if (von > max_line) {
X				ok = APPEND;
X			}
X			 else {
X				startlin = von - 1;
X				THE_LINE = startlin;
X				elin = von;
X			}
X		}
X		if (ok == APPEND) {
X			imode = 'A';
X			unlink(tmp2);
X			rename(tmp1, tmp2);
X			startlin = getfile(tmp2);
X			if (startlin < 1) startlin = 0;
X			elin = startlin + 1;
X			THE_LINE = startlin;
X		}
X		fp = fopen(tmp2, "w");
X		if (fp == NULL) return -1;
X
X	} else {
X		def[0] = '\0';
X		a = length(s);
X		if (a == 73) {
X			while ((s[a] != ' ') && (a > 40)) a--;
X			if (s[a] == ' ') {
X				strcat(def, strcopy(s, (a + 1), 73));
X				s[a] = '\0';
X				for (b = a; b < 73; b++) printf("%c", BS);
X				for (b = a; b < 73; b++) printf(" ");
X			}
X		}
X		fprintf(fp, "%s\n", s);
X		elin++;
X		melted++;
X	}
X  } while (ok != FINISH);
X  return elin;
X}
X
X
X
Xsigcatch(sig)
Xint sig;
X{
X
X  switch (sig) {
X      case SIGINT:
X      case SIGQUIT:
X      case SIGHUP:
X      case SIGABRT:
X      case SIGTERM:
X	melted++;
X	melt(THE_LINE);
X	bledmove(tmp1, THE_FILE);
X	unlink(tmp1);
X	unlink(tmp2);
X	/*
X	printf("\n\nLED: Prozess terminiert. Datei gesichert.\n\n");
X	*/
X	printf("\n\nLED: %s\n\n", BLD21_MSG);
X	exit(-1);
X	break;
X  }
X}
X
X
X
Xint getfile(path)
Xchar path[];
X{
X  FILE *fp;
X  FILE *ff;
X  int i = 0;
X  char s[STRING];
X
X  ff = fopen(tmp1, "w");
X  if (ff == NULL) {
X	printf("\n%s\n", tmp1);
X  }
X  fp = fopen(path, "r");
X  if (fp == NULL) {
X	fclose(ff);
X	return -1;
X  }
X  if (fgets(s, STRING, fp) != 0) i++;
X  if ((s[0] == 1) && (s[1] == 3)) {	/* MAGIC NUMBER */
X	return -2;
X  }
X  fputs(s, ff);
X
X  while (fgets(s, STRING, fp) != NULL) {
X	fputs(s, ff);
X	i++;
X  }
X  fclose(fp);
X  fclose(ff);
X
X  return i;
X}
X
X
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X  char s[STRING];
X
X  int eof = 0;
X
X
X  if (argc < 2) {
X	/*
X	printf("\nLED: Keine Datei angegeben.\n\n");
X	*/
X	printf("\nLED: %s\n\n", BLD22_MSG);
X	return;
X  }
X  /*
X  signal(SIGINT, sigcatch);
X  signal(SIGQUIT, sigcatch);
X  signal(SIGHUP, sigcatch);
X  signal(SIGABRT, sigcatch);
X  signal(SIGTERM, sigcatch);
X  */
X  signal(SIGINT,  SIG_IGN);
X  signal(SIGQUIT, SIG_IGN);
X  signal(SIGHUP,  SIG_IGN);
X  signal(SIGABRT, SIG_IGN);
X  signal(SIGTERM, SIG_IGN);
X
X#ifndef _SYS7
X
X  setbuf(stdout, NULL);
X
X#endif
X
X  ansi( "INIT" );
X
X  sprintf(s, " %s ", VERSION);
X  headline(s);
X 
X  /*
X  printf("\nMomentchen ...");
X  */
X  printf("\n%s", BLD23_MSG);
X
X  sprintf(tmp1, "%s/bled1.%d", TMP, getpid());
X  sprintf(tmp2, "%s/bled2.%d", TMP, getpid());
X
X  sprintf(THE_FILE, "%s", argv[1]);
X  THE_LINE = 0;
X
X  eof = getfile(THE_FILE);
X  printf("%c", CR);
X  if (eof == -2) {
X	/*
X	printf("Datei \"%s\" enthaelt ein ausfuehrbares Programm.\n\n", THE_FILE);
X	*/
X	printf("%s \"%s\" %s\n\n", BLD24_MSG, THE_FILE, BLD25_MSG);
X	return;
X  }
X  if (eof == -1)
X	/*
X	printf("Datei wird angelegt.");
X	*/
X	printf("%s", BLD26_MSG);
X  else
X	/*
X	printf("Datei enthaelt %d Zeilen.", eof);
X	*/
X	printf("%s %d %s", BLD27_MSG, eof, BLD28_MSG);
X  
X  /*
X  printf(" Befehlsuebersicht: \".?\"\n");
X  */
X  printf(" %s: \".?\"\n", BLD04_MSG);
X
X  if (eof < 1) eof = 0;
X  melted = 0;
X  max_line = eof;
X  eof++;
X
X  imode = 'A';
X
X  if (erfassen(eof, APPEND) < 1) {
X	/*
X	printf("\n\nLED: Probleme ...\n\n");
X	*/
X	printf("\n\nLED: %s\n\n", BLD29_MSG);
X  }
X  bledmove(tmp1, THE_FILE);
X  unlink(tmp1);
X  unlink(tmp2);
X
X  /*
X  printf("\n\nUnd 'tschuess ...\n\n");
X  */
X  printf("\n\n%s\n\n", BLD30_MSG);
X}
END_OF_FILE
  if test 11315 -ne `wc -c <'src/bled.c'`; then
    echo shar: \"'src/bled.c'\" unpacked with wrong size!
  fi
  # end of 'src/bled.c'
fi
if test -f 'src/intro.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/intro.c'\"
else
  echo shar: Extracting \"'src/intro.c'\" \(13861 characters\)
  sed "s/^X//" >'src/intro.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  intro.c						   */
X/*        FUNKTIONEN  intro(), init_user()				   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  11.07.1992					   */
X/***************************************************************************/
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <unistd.h>
X#include <fcntl.h>
X#include <stdio.h>
X#include <time.h>
X
X#include "mbox.h"
X
Xtime_t time_start, time_now;
X
X
Xvoid init_user();
X
X/***************************************************************************/
X/*      FUNKTION  intro()						   */
X/*  BESCHREIBUNG  Teilnehmer melden sich an. Beim Aufruf von SHELL, wird   */
X/*		  die Prozedur automagisch abgewickelt. Gaeste koennen     */
X/*		  ausserdem in dieser Funktion ein Terminal auswaehlen.    */
X/*     PARAMETER  keine                                                    */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid intro()
X{
X  FILE *fp;
X  FILE *ff;
X  int fd;
X  char s[LSTRING];
X  char t[STRING];
X  char f[STRING];
X  char tmp[STRING];
X  char crypt_pw[STRING];
X  char ex[255];
X  char tmpuser[STRING];
X  char moreLASTLOG[STRING];
X  int i, calls;
X  char c;
X  int ok;
X  int a, b;
X  long ll, lalo;
X  struct userdaten LOOSER;
X
X  struct tm *timeptr;
X  time_t timer;
X 
X  struct stat fst;
X
X  umask(0007);
X
X  sprintf(TERMINAL, "ansi");
X  ansi("INIT");
X
X  time(&time_start);
X
X  fp = fopen( LOGO, "r" );
X  if(fp != NULL){
X	fclose(fp);
X	printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
X	ansi("cl");
X	ansi("md");
X        show( LOGO, 24, 0 );
X	ansi("me");
X	c = getint();	
X  }
X
X  printf("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
X  ansi("cl");
X
X  ansi("md");
X  printf("\n%s ", INT01_MSG);
X  ansi("me");
X  printf("%s", ORGANIZATION);
X	
X  ansi("md");
X  printf("\n%s ", INT02_MSG);
X  ansi("me");
X  printf("%s %s %s", VERSION, PATCHLEVEL, AUTOR);
X
X  ansi("md");
X  printf("\n%s ", INT03_MSG);
X  ansi("me");
X  printf("%s", SYSTEM);
X
X  BAUDRATE = (int) 0;
X
X  if (OLDGID == GUEST_GID) {	/* GAESTE */
X
X        TRY_AGAIN:
X
X	printf("\n\n%s ", GBL04_MSG);
X	strcpy(LOOSER.name, (char *) getline(30, 11, '.', ""));
X	if (LOOSER.name[0] == '\0') goto TRY_AGAIN;
X
X	strcpy(s, (char *) upcased(LOOSER.name));
X
X	if (strcomp(GUEST, s) != 0) {
X
X		printf("\n%s ", GBL09_MSG);
X		strcpy(LOOSER.passwort, (char *) getline(10, 12, '.', ""));
X		strcpy(crypt_pw, (char *) crypted(LOOSER.passwort));
X
X		maybe_locked(UDBASE, "r"); mblock(UDBASE);
X		fd = open(UDBASE, O_RDONLY);
X		if (fd == -1) {
X			nerror("intro.c", 78, "intro", "Datei-Lesefehler", UDBASE);
X		}
X		ok = 0;
X		while ((ok == 0) && (read(fd, &USER, sizeof(USER)) == sizeof(USER))) {
X			if (((strcomp(LOOSER.name, USER.name) == 0) ||
X		  	     (strcomp(LOOSER.name, USER.nick) == 0)) &&
X			    ((strcomp(USER.passwort, (char *) crypt_pw) == 0) ||
X			     (strcomp(USER.passwort, LOOSER.passwort) == 0)))
X				ok = 1;
X		}
X		close(fd);
X		mbunlock(UDBASE);
X
X		if (ok == 1) goto WELL_DONE;
X		goto TRY_AGAIN;
X	}
X	strcpy(LOOSER.name, (char *) upcased(s));
X
X	maybe_locked(UDBASE, "r"); mblock(UDBASE);
X	fd = open(UDBASE, O_RDONLY);
X	if (fd == -1) {
X		nerror("intro.c", 98, "intro", "Datei-Lesefehler", UDBASE);
X	}
X	ok = 0;
X	while ((ok == 0) && (read(fd, &USER, sizeof(USER)) == sizeof(USER))) {
X		if (strcomp(LOOSER.name, USER.name) == 0) ok = 1;
X	}
X	close(fd);
X	mbunlock(UDBASE);
X
X	ansi("md");
X	printf("\n\n%s\n\n", INT04_MSG);
X	ansi("me");
X	printf("%s\n", INT05_MSG);
X	ansi("md");
X	printf("\n%s > ", INT06_MSG);
X	ansi("me");
X
X	do {
X		c = getint();
X	} while ((c < '1') || (c > '4'));
X	printf("%c", c);
X	USER.terminal = c - 48;
X
X	strcpy(USER.name, (char *) GUEST);
X	sprintf(USER.passwort, "%s", "*****");
X
X	USER.level	   =  0;
X	USER.prompt        =  2;
X	USER.bell          =  0;
X	USER.intro         =  1;
X	USER.more          =  3;
X	USER.editor        =  1;
X	USER.lastmode      =  2;
X	USER.leserichtung  =  2;
X	USER.tlines        = 23;
X	USER.schluessel[0] =  1;
X	USER.schluessel[1] =  3;
X
X	sprintf(USER.newsgrps, "%s", NEWS_MINIMUM);
X
X	LASTLOG = (long) 19700101;
X	LASTTIME = 0;
X	sprintf(moreLASTLOG, "%s", "01.01.1970");
X  }
X  else {			/* USER */
X
X	printf("\n\n%s ....................", GBL04_MSG);
X	for (i = 0; i < 20; i++) printf("%c", BS);
X
X	strcpy(tmpuser, (char *) whoami());
X	printf("%s", tmpuser);
X
X	printf("\n%s ..........", GBL09_MSG);
X
X	for (i = 0; i < 10; i++) printf("%c", BS);
X	for (i = 0; i < 10; i++) printf("*");
X
X	if (strcomp(tmpuser, "root") == 0) {
X		strcpy(tmpuser, (char *) POSTMASTER);
X
X		strcpy(s, (char *) ttyname(0));
X		if(strcomp(PMS_TTY, s) != 0){
X			printf("\n\n");
X			ansi("mr");
X			printf("%s", INT07_MSG);
X			ansi("me");
X			printf("\n\n");
X			exit(-1);
X		}
X		else {
X			USER.level = 10;
X		}
X	}
X	maybe_locked(UDBASE, "r"); mblock(UDBASE);
X	fd = open(UDBASE, O_RDONLY);
X	if (fd == -1) {
X		nerror("intro.c", 156, "intro", "Datei-Lesefehler", UDBASE);
X	}
X	ok = 0;
X	while ((ok == 0) && (read(fd, &USER, sizeof(USER)) == sizeof(USER))) {
X		if ((strcomp(tmpuser, USER.sh_name) == 0)) ok = 1;
X	}
X	close(fd);
X	mbunlock(UDBASE);
X
X	if (ok == 0) postfach(tmpuser);
X
X  }
X
X  WELL_DONE:
X
X  setuid( ROOT_UID );
X  setgid( ROOT_GID ); 
X
X  if (strcomp(GUEST, USER.name) != 0) {
X	LASTLOG = (long) dateconv(USER.lastlog);
X	LASTTIME = USER.lasttime;
X	sprintf(moreLASTLOG, "%s", USER.lastlog);
X  }
X  if (USER.lastmode == 2) LASTTIME = 0;
X
X  sprintf(UGROUPS, "%s/usr/%d/.active", HOME, USER.id);
X
X  maybe_locked( AGROUPS, "r" );
X  fp = fopen(AGROUPS, "r");
X  if (fp == NULL) {
X	nerror("intro.c", 182, "intro", "Datei-Lesefehler", AGROUPS);
X  }
X  ff = fopen(UGROUPS, "w");
X  if (ff == NULL) {
X	nerror("intro.c", 195, "intro", "Datei-Schreibfehler", UGROUPS);
X  }
X  while (fscanf(fp, "%s %ld", s, &lalo) > 0) {
X	if (LASTLOG < lalo) {
X		sprintf(t, "%s 00000 00000 y\n", s);
X		fputs(t, ff);
X	}
X	if (LASTLOG == lalo) {
X	}
X  }
X  fclose(ff);
X  fclose(fp);
X
X  sprintf(s, "%s \"%s\" (%d) %s", INT08_MSG, USER.name, USER.id, INT09_MSG);
X  control(s, 3);
X  whodo( INT10_MSG );
X
X  printf("\n\n");
X
X  if ((USER.level < 10) && (strcomp(MYNAME, USER.name) != 0)) {
X
X	maybe_locked(SEQ, "r"); mblock(SEQ);
X	fp = fopen(SEQ, "r");
X	if (fp == NULL) {
X		nerror("intro.c", 223, "intro", "Datei-Lesefehler", SEQ);
X	}
X	fscanf(fp, "%d", &calls);
X	fclose(fp);
X	calls++;
X
X	fp = fopen(SEQ, "w");
X	if (fp == NULL) {
X		nerror("intro.c", 227, "intro", "Datei-Schreibfehler", SEQ);
X	}
X	fprintf(fp, "%d\n", calls);
X	fclose(fp);
X	mbunlock(SEQ);
X
X	sprintf(tmp, "%s/%dT", TMP, getpid());
X
X	fp = fopen(tmp, "w");
X	if (fp == NULL) {
X		nerror("intro.c", 236, "intro", "Datei-Schreibfehler", tmp);
X	}
X	maybe_locked(CALLS, "r"); mblock(CALLS);
X	ff = fopen(CALLS, "r");
X	if (ff == NULL) {
X		nerror("intro.c", 239, "intro", "Datei-Lesefehler", CALLS);
X	}
X	sprintf(s, "%s (%s)", USER.name, USER.nick);
X	sprintf(t, "%s", numstripped(USER.wohnort));
X	if (t[0] == '\0') sprintf(t, "%s", "   ");
X
X	sprintf(f, "%s", (char *) ttyna());
X
X	fprintf(fp, "%5.d  %-28.28s  %-17.17s%8.8s  %s  %s\n",
X		calls, s, stripped(t), f, (char *) mydate(1), (char *) mytime(1));
X
X	if(PRO_ENTRIES < 10){
X		nerror("intro.c", 291, "intro", "PRO_ENTRIES zu klein dimensioniert", "mbox.h");			
X	}
X
X	i = 1;
X	while ((fgets(s, 84, ff) != NULL) && (i <= PRO_ENTRIES)) {
X		fputs(s, fp);
X		i++;
X	}
X
X	fclose(ff);
X	fclose(fp);
X
X	sprintf(s, "cp %s %s > /dev/null", tmp, CALLS);
X	system(s);
X
X	unlink(tmp);
X	mbunlock(CALLS);
X  }
X
X  sprintf(s, "%s/usr/%d/INDEX", HOME, USER.id);  
X  if(atol(USER.abused) == 0L){
X	  stat(s, &fst);
X	  IDX_SIZE = (long) fst.st_size;
X  }
X  else IDX_SIZE = atol(USER.abused);
X
X  init_user( INT11_MSG );
X
X  if (USER.intro < 3) {
X
X	a = 0;
X	fp = fopen(UGROUPS, "r");
X	if (fp == NULL) {
X		nerror("intro.c", 283, "intro", "Datei-Lesefehler", AGROUPS);
X	}
X	while (fgets(ex, 200, fp) != NULL) a++;
X	fclose(fp);
X
X	b = 0;
X	sprintf(s, "%s/usr/%d/INDEX", HOME, USER.id);  
X	
X	fp = fopen(s, "r");
X	if (fp == NULL) {
X		nerror("intro.c", 291, "intro", "Datei-Lesefehler", s);
X	}
X	while (fgets(ex, 200, fp) != NULL){
X		if(ex[0] < 65) b++;
X	}
X	fclose(fp);
X	b -= 1;
X
X	ansi("md");
X	printf("%s %d. %s %s %s.\n", 
X		INT12_MSG, USER.seq, INT13_MSG, moreLASTLOG, INT14_MSG);
X	printf("%s %d %s %d %s.\n", 
X		INT15_MSG, a, INT16_MSG, b, INT17_MSG);
X	ansi("me");
X	printf("\n");
X  }
X  if ((USER.intro != 2) && (USER.intro != 4)) show(INTRO, 9999, 1);
X
X
X
X  
X  fp = fopen(WHO, "a");
X  if (fp == NULL) {
X	nerror("intro.c", 309, "intro", "Datei-Lesefehler", WHO);
X  }
X  strcpy(s, (char *) USER.sh_name);
X  if (s[0] == '\0') strcpy(s, (char *) USER.nick);
X  if (s[0] == '\0') strcpy(s, (char *) GBL10_MSG);
X  sprintf(ex, "%-8.8s %s (%s)                                               ",
X	(char *) ttyna(), USER.name, s);
X
X  ex[39] = '\0';
X  fputs(ex, fp);
X
X  sprintf(ex, "%8.8s", (char *) ttyna());
X  fputs(ex, fp);
X
X  strcpy(s, (char *) mytime(1));
X  if (USER.level < 10)
X	sprintf(ex, "   %s   [%d] MBox: %s\n", s, USER.level, INT10_MSG);
X  else
X	sprintf(ex, "   %s   [%d] MBox: %s\n", s, ADMIN_LEV, INT10_MSG);
X
X  fputs(ex, fp);
X  fclose(fp);
X  
X
X
X  sprintf(MYNAME, "%s", USER.name);
X
X  sprintf(s, "%s", (char *) mydate(0));
X  s[5] = '\0';
X  if (strcomp(s, USER.geburtsdatum) == 0) {
X	ansi("md");
X	printf("\n\n%s\n", INT18_MSG);
X	printf("%s\n\n", INT19_MSG);
X	ansi("me");
X  }
X  if (strcomp("24.12.", s) == 0) {
X	ansi("md");
X	printf("\n\n%s\n", INT20_MSG);
X	printf("%s\n\n", INT21_MSG);
X	ansi("me");
X  }
X  if (strcomp("06.12.", s) == 0) {
X	ansi("md");
X	printf("\n\n%s\n", INT22_MSG);
X	printf("\n%s\n\n", INT23_MSG);
X	ansi("me");
X  }
X  if (strcomp("01.01.", s) == 0) {
X	ansi("md");
X	printf("\n\n%s\n", INT24_MSG);
X	printf("%s\n\n", INT25_MSG);
X	ansi("me");
X  }
X  if ((calls == 1000) || (calls == 10000) || (calls == 100000)) {
X	ansi("md");
X	printf("\n\n%s %d%s\n\n", INT26_MSG, calls, INT27_MSG);
X	ansi("me");
X  }
X
X
X  /* Strict Accounting ... decrease Level if User doesn't pay */
X
X  strcpy(s, (char *) mydate( 0 ));
X  lalo = dateconv(s);  
X  
X  strcpy(s, (char *) USER.account);
X  s[10] = '\0';
X  ll = dateconv(s);
X
X  if((ll <= lalo) && (ll > 19000000L)){
X	ansi( "md" );
X	printf("\n%s %s %s\n", INT28_MSG, s, INT29_MSG);
X	ansi( "me" );
X	printf("%s\n", INT30_MSG);
X
X	if(lalo > (ll + 21)){
X		USER.level = WRITE_INTERNAT - 1;
X	}
X  }
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  init_user()						   */
X/*  BESCHREIBUNG  Teilnehmer-Parameter werden zugewiesen, Rechte verteilt  */
X/*		  und die Daten aktualisiert.                              */
X/*     PARAMETER  info  =  Ansage-Text                                     */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid init_user(info)
Xchar info[];
X{
X  FILE *fp;
X  FILE *ff;
X  int fd;
X  char s[STRING];
X  char t[STRING];
X  int i;
X  struct userdaten DUMMY;
X  int dummy = sizeof(DUMMY);
X  long ll, lalo;
X  int lati;
X  int ok;
X
X  printf("%s ..", info);
X
X  switch (USER.terminal) {
X      case 1:
X		sprintf(s, "eval '%s ansi' ", TSET);
X		sprintf(TERMINAL, "ansi");
X		break;
X      case 2:
X		sprintf(s, "eval '%s vt100' ", TSET);
X		sprintf(TERMINAL, "vt100");
X		break;
X      case 3:
X		sprintf(s, "eval '%s vt52' ", TSET);
X		sprintf(TERMINAL, "vt52");
X		break;
X      case 4:
X		sprintf(s, "eval '%s vt52' ", TSET);
X		sprintf(TERMINAL, "vt52");
X		break;
X  }
X  printf(".");
X
X  ansi("INIT");
X
X  fp = fopen(EDITORS, "r");
X  if (fp == NULL) {
X	nerror("intro.c", 487, "intro", "Datei-Lesefehler", EDITORS);
X  }
X  i = 0;
X  while((fgets(s, 80, fp) != NULL) && (s[0] == '/'));
X  while ((i != USER.editor) && (fscanf(fp, "%s %s", s, EDDY) > 0)) i++;
X  fclose(fp);
X
X  printf(".");
X
X  if (USER.leserichtung == 0) USER.leserichtung = 2;
X
X  USER.seq++;
X
X  maybe_locked(UDBASE, "r"); mblock(UDBASE);
X  fd = open(UDBASE, O_RDWR);
X  if (fd == -1) {
X	nerror("intro.c", 395, "init_user", "Datei-Schreib/-Lesefehler", UDBASE);
X  }
X  while (read(fd, &DUMMY, dummy) == dummy) {
X	if (USER.id == DUMMY.id) {
X		ll = lseek(fd, 0L, SEEK_CUR) - dummy;
X	}
X  }
X  lseek(fd, ll, SEEK_SET);
X  write(fd, &USER, sizeof(USER));
X  close(fd);
X  mbunlock(UDBASE);
X
X  printf(".");
X
X  sprintf(UGROUPS, "%s/usr/%d/.active", HOME, USER.id);
X  sprintf(MAKRO, "%s/usr/%d/.makro", HOME, USER.id);
X
X  maybe_locked( AGROUPS, "r" );
X  fp = fopen(AGROUPS, "r");
X  if (fp == NULL) {
X	nerror("intro.c", 412, "intro", "Datei-Lesefehler", AGROUPS);
X  }
X  ff = fopen(UGROUPS, "w");
X  if (ff == NULL) {
X	nerror("intro.c", 442, "intro", "Datei-Schreibfehler", UGROUPS);
X  }
X  while (fscanf(fp, "%s %ld %d", s, &lalo, &lati) > 0) {
X	if (LASTLOG < lalo) {
X		sprintf(t, "%s 00000 00000 y\n", s);
X		fputs(t, ff);
X	}
X	if (LASTLOG == lalo) {
X		if (LASTTIME <= lati) {
X			sprintf(t, "%s 00000 00000 y\n", s);
X			fputs(t, ff);
X		}
X	}
X  }
X  fclose(ff);
X  fclose(fp);
X
X  printf(".");
X
X  strcpy(BRETT, "PM");
X  sprintf(NG, "%s.PM", USER.name);
X  sprintf(INHALT, "%s/usr/%d/INDEX", HOME, USER.id);
X
X  printf(".");
X
X  if (USER.newsgrps[0] == '\0') sprintf(USER.newsgrps, "%s", NEWS_MINIMUM);
X
X  sscanf(USER.newsgrps, "%s %s %s %s %s %s %s %s %s %s %s %s %s %s %s",
X	newsgrp[1], newsgrp[2], newsgrp[3], newsgrp[4], newsgrp[5],
X	newsgrp[6], newsgrp[7], newsgrp[8], newsgrp[9], newsgrp[10],
X	newsgrp[11], newsgrp[12], newsgrp[13], newsgrp[14], newsgrp[15]);
X 
X
X  if((USER.tlines < 22) || (USER.tlines > 23)){
X	MAX_SCR_LINES = DEF_MAX_SCR_LINES;
X	USER.tlines = DEF_MAX_SCR_LINES;
X  }
X  else 
X	MAX_SCR_LINES = USER.tlines;
X
X
X  if(USER.schluessel[0] == 32)
X	SHORT_HEADER = 1;
X  else
X	SHORT_HEADER = 0;
X
X  if(USER.schluessel[1] == 0)
X	USER.schluessel[1] = 4;
X
X  if(USER.level >= WRITE_INTERNAT){
X	strcpy(UUCPID, UUCPID2);
X  }
X  else{
X	strcpy(UUCPID, UUCPID1);
X  }
X
X  if(USER.account[0] == '\0') strcpy(USER.account, "00.00.0000 000.00");
X  
X  printf("%c", CR);
X}
END_OF_FILE
  if test 13861 -ne `wc -c <'src/intro.c'`; then
    echo shar: \"'src/intro.c'\" unpacked with wrong size!
  fi
  # end of 'src/intro.c'
fi
if test -f 'src/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/main.c'\"
else
  echo shar: Extracting \"'src/main.c'\" \(7037 characters\)
  sed "s/^X//" >'src/main.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  main.c						   */
X/*        FUNKTIONEN  logout(), init(), fixoutput(), main()		   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  13.06.1992					   */
X/***************************************************************************/
X   
X#include <sys/types.h>
X#include <unistd.h>
X#include <stdio.h>
X#include <time.h>
X#include <fcntl.h>
X
X#include "mbox.h"
X
Xextern time_t time_start, time_now;
X
X
X
X/***************************************************************************/
X/*      FUNKTION  logout()						   */
X/*  BESCHREIBUNG  Entfernt den User aus "WHO" und reorganisiert seine      */
X/*		  Teilnehmerdaten.                                         */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine							   */
X/***************************************************************************/
X
Xvoid logout()
X{
X  FILE *fp;
X  FILE *ff;
X  char s[STRING];
X  char t[STRING];
X  char u[STRING];
X  char f[STRING];
X  long ll;
X  int a, b;
X  int fd;
X  struct tm *timeptr;
X  struct userdaten DUMMY;
X  int dummy = sizeof(DUMMY);
X
X  printf("\n");
X
X
X  time(&time_now);
X  USER.elapsed += (long) (time_now - time_start);
X
X  sprintf(f, "%s/who%d", TMP, getpid());
X  maybe_locked(WHO, "r"); mblock(WHO);
X  fp = fopen(WHO, "r");
X  if (fp == NULL) {
X	nerror("main.c", 34, "logout", "Datei-Lesefehler", WHO);
X  }
X 
X  strcpy(t, (char *) ttyna()); t[9] = '\0';
X
X  ff = fopen(f, "w");
X  if (ff == NULL) {
X	nerror("main.c", 38, "logout", "Datei-Schreibfehler", f);
X  }
X  while (fgets(s, 80, fp) != NULL) {
X	if(strcomp(t, s) != 0) fputs(s, ff);
X  }
X  fclose(ff);
X  fclose(fp);
X  sprintf(s, "cp %s %s", f, WHO);
X  system(s);
X  unlink(f);
X  mbunlock(WHO);
X
X  strcpy(s, HOME); strcat(s, "/etc/");
X  strcat(s, (char *) ttyna()); strcat(s, ".");
X  unlink( s );
X
X  sprintf(USER.abused, "%ld", IDX_SIZE);
X
X  USER.seq--;		
X  printf("\n");
X  init_user( MAI01_MSG );
X
X#ifdef _NOINDEX
X  sprintf(s, "%s/inhalt.%d", TMP, getpid());
X  unlink(s);
X#endif
X
X  control(MAI02_MSG, 3);
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  init()						   */
X/*  BESCHREIBUNG  Liest die Befehle aus "BEFEHLE", fuellt die Befehl-      */
X/*		  Stuktur und verteilt die Level-Vorgaben.                 */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine							   */
X/***************************************************************************/
X
Xvoid init()
X{
X  FILE *fp;
X  FILE *ff;
X  char s[STRING];
X  char t[STRING];
X  char udcc[STRING];
X  int udcl;
X  char udcp[STRING];
X  int b = 0;
X  int ok = 0;
X
X  ff = fopen(UDCS, "r");
X  if (ff == NULL) {
X	nerror("main.c", 115, "init", "Datei-Lesefehler", "./etc/mbox.udc");
X	exit(0);
X  }  
X  while((fgets(s, 80, ff) != NULL) && (s[0] == '/'));
X  if(fgets(s, 80, ff) != NULL) ok = 1;
X  sscanf(s, "%s %d %s %s", udcc, &udcl, udcp, t);
X  if(udcc[0] > 96) udcc[0] -= 32;
X  strcat(udcp, " "); strcat(udcp, t);
X
X  fp = fopen(BEFEHLE, "r");
X  if (fp == NULL) {
X	nerror("main.c", 68, "init", "Datei-Lesefehler", BEFEHLE);
X  }
X  while((fgets(s, 80, fp) != NULL) && (s[0] == '/'));
X  
X  fgets(s, 80, fp); /* 3 Zeilen nach dem Kommentar (exakt 3 Zeilen !!!) */
X  fgets(s, 80, fp);
X
X  while (fscanf(fp, "%d %d %d %d %s", &BEF[b].id, &BEF[b].in, &BEF[b].ex, &BEF[b].prototyp, BEF[b].befehl) > 0) {
X
X	if (BEF[b].id == 160) MAILOUT_LEV = BEF[b].ex;
X	if (BEF[b].id == 125) ADMIN_LEV = BEF[b].ex;
X	if (BEF[b].id == 230) WRITE_EX_LEV = BEF[b].ex;
X	if (BEF[b].id == 230) WRITE_IN_LEV = BEF[b].in;
X	if (BEF[b].id == 998) WRITE_INTERNAT = BEF[b].in;
X	if (BEF[b].id == 195) PD_D_LEV = BEF[b].in;
X	if (BEF[b].id == 195) PD_U_LEV = BEF[b].ex;
X	if (BEF[b].id == 240) EXE_LEV = BEF[b].ex;
X	if (BEF[b].id == 320) GUEST_LEV = BEF[b].in;
X	if (BEF[b].id == 130) BB1 = b;
X	if (BEF[b].id == 150) BB2 = b;
X	if (BEF[b].id == 160) BB3 = b;
X	if (BEF[b].id == 170) BB4 = b;
X	if (BEF[b].id == 210) BB5 = b;
X	if (BEF[b].id == 180) BB6 = b;
X	if (BEF[b].id == 190) BB7 = b;
X	if (BEF[b].id == 200) BB8 = b;
X	if (BEF[b].id == 270) BB9 = b;
X
X	if((ok == 1) && (BEF[b].prototyp == 1) && (udcc[0] < BEF[b].befehl[0])){
X		BEF[(b+1)].id = BEF[b].id;
X		BEF[(b+1)].in = BEF[b].in;
X		BEF[(b+1)].ex = BEF[b].ex;
X		BEF[(b+1)].prototyp = BEF[b].prototyp;
X		strcpy(BEF[(b+1)].befehl, (char *) BEF[b].befehl);
X		BEF[b].id = 1000;
X		BEF[b].in = udcl;
X		BEF[b].ex = udcl;
X		BEF[b].prototyp = 1;
X		strcpy(BEF[b].befehl, (char *) udcc);
X		strcpy(BEF[b].pfad, (char *) udcp);
X		b++;
X		if(fgets(s, 80, ff) == NULL) ok = 0;
X		sscanf(s, "%s %d %s %s", udcc, &udcl, udcp, t);
X		if(udcc[0] > 96) udcc[0] -= 32;
X		strcat(udcp, " "); strcat(udcp, t);
X	}
X
X	b++;
X	if (b >= MAX_BEF) {
X		nerror("main.c", 85, "init", "MAX_BEF ueberschritten !!", "???");
X	}
X  }
X  BEF[b].id = -1;
X
X  fclose(fp);
X  fclose(ff);
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  fixoutput()						   */
X/*  BESCHREIBUNG  Legt fest an welches Geraet, oder in welche Datei, die   */
X/*		  Logbuch-Eintraege geschickt werden.			   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine							   */
X/***************************************************************************/
X
Xvoid fixoutput()
X{
X  char s[STRING];
X
X  FILE *fp;
X
X  strcpy(s, CONSOLE); CONSOLE_REDIRECT[0] = '\0';
X
X  if(strcomp("REDIRECT", CONSOLE) == 0){
X	fp = fopen( CDIRECTFL, "r" );
X	if(fp != NULL){
X		fgets(s, STRING, fp);
X		fclose(fp);
X		
X	}
X   }
X   strcat(CONSOLE_REDIRECT, (char *) stripped(s));
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  main()						   */
X/*  BESCHREIBUNG  Hauptfunktion. Rettet UID/GID, initialisiert, startet    */
X/*		  die MBox-Funktionen und terminiert.                      */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  "Exit-Status"						   */
X/***************************************************************************/
X
Xint main(argc, argv)
Xint argc;
Xchar *argv[];
X{
X  FILE *fp;
X  int i;
X
X#if defined(_ESTDIO) || !defined(_SYS7)
X  setbuf(stdout, NULL);
X#endif
X
X
X  chdir(HOME);
X
X  OLDUID = getuid();
X  OLDGID = getgid();
X
X  sprintf(MYNAME, "%s", "J. Random Looser");
X
X  fp = fopen( UDBASE, "r" );
X  if(fp == NULL){
X	strcpy(TERMINAL, "ansi");
X	ansi("INIT");
X
X	headline( MAI03_MSG );
X	ansi("md");
X	printf("\n%s", MAI04_MSG);
X	printf("\n%s", MAI05_MSG);
X	printf("\n%s", MAI06_MSG);
X	printf("\n");
X	printf("\n%s", MAI07_MSG);
X	printf("\n%s", MAI08_MSG);
X	printf("\n%s\n\n", MAI09_MSG);
X	ansi("me");
X
X	postfach( "#1" );
X	postfach( "#2" );
X
X	ansi("md");
X	printf("\n%s\n\n", MAI10_MSG);
X	ansi("me");
X	return 0;
X  }
X  fclose(fp);
X
X  fixoutput();
X  init();  
X  intro();
X  get_makros();
X  ctrlx();
X
X  loop();
X
X  logout();
X  noctrlx();
X  ansi("md");
X  printf("\n\n%s\n\n", MAI11_MSG);
X  ansi("me");
X
X  return 0;
X}
END_OF_FILE
  if test 7037 -ne `wc -c <'src/main.c'`; then
    echo shar: \"'src/main.c'\" unpacked with wrong size!
  fi
  # end of 'src/main.c'
fi
if test -f 'src/mbox.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/mbox.h'\"
else
  echo shar: Extracting \"'src/mbox.h'\" \(13062 characters\)
  sed "s/^X//" >'src/mbox.h' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/MBox						   */
X/*             DATEI  mbox.h						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  10.05.1992					   */
X/***************************************************************************/
X 
X#include "mbox.msg"
X#include "defs.h"
X#include "patchlevel.h"
X
X
X 
X/***************************************************************************/
X/* >ORGANIZATION  -  frei waehlbar (moeglichst identisch mit dem ent-      */
X/*		     sprechenden Eintrag fuer NEWS)			   */
X/* >SYSTEM        -  frei waehlbar (Name der Mailbox)     	  	   */
X/***************************************************************************/
X
X#define ORGANIZATION 	"THE UNDERGROUND NETWORK"
X#define SYSTEM       	"The Time Traveling Agency"  
X
X
X
X/***************************************************************************/
X/*  VERSION       -  wird vom Autor (und nur vom dem) geandert		   */
X/*                   Co-Autoren, Portierer etc. koennen sich gefaelligst   */
X/*		     ihren eigenen Eintrag basteln.		           */
X/*  AUTOR         -  das bin ich - Hallo auch !				   */
X/***************************************************************************/
X
X#define VERSION	     	"ix/MBox 1.6"
X#define AUTOR        	"by <volkers@unnet.w.open.DE>"
X
X
X
X
X/***************************************************************************/
X/* >UUCPSITE       - Systemname innerhalb der UUCP-Netze		   */
X/* >UUCPID2        - Adresse (Domain-) im Internet			   */
X/* >UUCPID1        - Adresse (Domain-) im lokalen UUCP-Netz 		   */
X/* >UUCPBANG       - Adresse als BANG-Pfad				   */
X/*  UUCPCOSTS      - Gebuehrenaufstellung				   */
X/* >SMARTHOST	   - 							   */
X/***************************************************************************/
X
X#define UUCPSITE     	"unnet"
X#define UUCPID2      	"unnet.w.open.DE"        
X#define UUCPID1	     	"unnet.ruhr.SUB.ORG"
X#define UUCPBANG     	"~!unido!horga!xenox!unnet!"
X#define UUCPCOSTS    	"/usr/spool/uucp/.costs"
X#define SMARTHOST	"xenox"
X
X
X
X/***************************************************************************/
X/*  X_MAIL_DEMON    - Name des X-Mail-Daemons (HAENDE WEG !!!) 		   */
X/***************************************************************************/
X
X#define X_MAIL_DEMON 	"X-Mail-Daemon"
X
X
X
X
X/***************************************************************************/
X/*  LIB		     - Pfad zum MBox-Directory LIB			   */
X/*  TMP              - Directory fuer temporaere Dateien		   */
X/* >NEWS	     - Pfad zum SPOOL-Directory fuer NEWS		   */
X/*  NEWSGROUPS       - Pfad zur Datei mit den Erlaeuterungen der Gruppen   */
X/*  ERRMBOX          - Mailbox des Error-Users (POSTMASTER)		   */
X/*  MAILDROP         - Pfad zu den Maildrops der SH-User		   */
X/* >NGROUPS          - Pfad zur "active"-Datei von NEWS			   */
X/*  AGROUPS	     - Pfad zur MBox-"active"-Datei			   */
X/***************************************************************************/
X
X#define LIB	     	"./lib"
X#define TMP	     	"/tmp"
X#define NEWS         	"/usr/spool/news"
X#define NEWSGROUPS	"/usr/lib/news/newsgroups"
X#define ERRMBOX      	"/usr/spool/mail/postmaster"
X#define MAILDROP     	"/usr/spool/mail"
X#define NGROUPS      	"/usr/lib/news/active"
X#define AGROUPS      	"./etc/active"
X
X
X
X
X
X/***************************************************************************/
X/* >CONSOLE	      - Geraet/Datei fuer die Logbuch-Ausgaben		   */
X/*			Ist CONSOLE als "REDIRECT" definiert, wird aus der */
X/*                      Datei CDIRECTFL der Name der Ausgabedatei gelesen  */
X/*			gelesen					           */
X/*  CDIRECTFL         - Geraet/Datei wohin CONSOLE-Info ausgeben wird	   */
X/*		        Die Datei ENTHAELT DEN NAMEN der Ausgabedatei !!!  */
X/* >CPRN              - Geraet/Datei fuer Fehler-Ausgaben		   */
X/* >POSTMASTER        - Name des SYSOPs (identisch mit dessen SH-Account)  */
X/*  MAX_BPS           - Maximale Modem-Ubertragungsrate in BPS             */
X/* >PMS_TTY           - Nummer des einzigen Terminals, auf dem sich "root" */
X/*			anmelden darf					   */
X/*  GUEST             - MBox-Account fuer Besucher			   */
X/*  UDBASE            - Pfad zur Teilnehmer-Datenbank			   */
X/*  UDSEQ             - Pfad zur Teilnehmer-SEQ-Datei			   */
X/***************************************************************************/
X
X#define CONSOLE	     	"REDIRECT"
X#define CDIRECTFL    	"/etc/mbox.out"
X#define CPRN	     	"/tmp/errlog"
X#define POSTMASTER   	"volkers"
X#define PMS_TTY      	"/dev/tty4"
X#define MAX_BPS      	19200
X#define GUEST        	"GAST"
X#define UDBASE       	"./etc/users.data"
X#define UDSEQ        	"./etc/users.seq"
X
X
X
X
X/***************************************************************************/
X/*  BEFEHLE 	   - Pfad zur Befehls-Tabelle				   */
X/*  HILFE          - Pfad zu den HELP-Texten				   */
X/*  KURZHILFE	   - Kurzuebersicht					   */
X/*  INTRO          - Pfad zur INTRO-Meldung				   */
X/*  LOGO           - Optionaler Text als Mailbox-LOGO 			   */
X/*  SYSINFO	   - Allgemeine Infos zur MBox				   */
X/***************************************************************************/
X
X#define BEFEHLE	     	"./etc/help.befehle"  
X#define HILFE	     	"./etc/help.hilfe"
X#define KURZHILFE    	"./etc/help.shorthelp"
X#define INTRO        	"./etc/intro"
X#define LOGO         	"./etc/logo"
X#define SYSINFO		"./etc/sysinfo"
X
X
X
X/***************************************************************************/
X/*  SEQ             - Pfad zur MBox-SEQ-Datei (Anzahl der Anrufe)	   */
X/*  CALLS           - Pfad zur MBox-CALLS-Datei (Logfile)		   */
X/*  WHO             - Pfad zur MBox-WHO-Datei (gerade aktive User)	   */
X/***************************************************************************/
X
X#define SEQ          	"./etc/mbox.seq"
X#define CALLS        	"./etc/mbox.calls"
X#define WHO          	"./etc/mbox.who"
X
X
X
X
X/***************************************************************************/
X/*  EDITORS          - Pfad zur Liste der verfuegbaren Eddies		   */
X/*  GAMES            - Pfad zur Liste der Online-Spiele			   */
X/*  MAX_GAMES 	     - Anzahl der max. angebotenen Spiele		   */
X/* >CHAT             - Pfad zum CHAT-Programm				   */
X/*  RSH              - MBox-RSH; NICHT identisch mit RemoteSH/RestrictedSH */
X/*  UDCS	     - Pfad zur Liste der 'User defined Commands'	   */
X/*  PACKERS	     - Pfad zur Liste der Komprimierer/Archivierer         */
X/***************************************************************************/
X
X#define EDITORS      	"./etc/mbox.editors"
X#define GAMES	     	"./etc/mbox.games"
X#define MAX_GAMES	10
X#define CHAT         	"/usr/bin/chat"
X#define RSH          	"./mbrsh"
X#define UDCS		"./etc/mbox.udc"
X#define PACKERS		"./etc/mbox.packers"
X
X
X
X
X/***************************************************************************/
X/*  ROOT_UID          - siehe "/etc/passwd"				   */
X/*  ROOT_GID          - dito						   */
X/*  GUEST_GID 	      - dito (unbedingt != GID fuer "normale" User)        */
X/***************************************************************************/
X
X#define ROOT_UID      	0
X#define ROOT_GID      	0
X#define GUEST_GID     	1
X
X
X
X
X
X/***************************************************************************/
X/* >FIRST_EX_TTY       - Nummer des ersten seriellen Terminals		   */
X/*  MAX_TERMINALS      - Max. Anzahl der aktiven Terminals 		   */
X/***************************************************************************/
X
X#define FIRST_EX_TTY	64
X#define MAX_TERMINALS	20
X
X
X
X
X/***************************************************************************/
X/* >SIGNATURE          - Name des '.signature'-File im $HOME eins SH-Users */
X/* >TSET               - Pfad zum TSET-Programm				   */
X/* >EXPIRE             - Pfad zum EXPIRE-Programm			   */
X/*  MB-DAEMON          - Pfad zum MB-DAEMON-Programm			   */
X/*  MB_DLOG            - Pfad zum MB-DAEMON-Statistik-File		   */
X/*  XMDLOG	       - Pfad zum XMD-Protokoll-File		           */
X/*  XMD_ALIAS	       - Pfad zur Alias-Datei des XMD			   */
X/***************************************************************************/
X
X#define SIGNATURE    	".wmailsign"
X#define TSET         	"./etc/tset"
X#define EXPIRE       	"/usr/lib/news/expire"
X#define MB_DAEMON    	"/usr/bin/mb-daemon"
X#define MB_DLOG      	"./etc/mbd.log"
X#define XMDLOG	     	"/usr/adm/xmd.log"
X#define XMD_ALIAS	"./etc/xmd.alias"
X
X
X
X
X/***************************************************************************/
X/* >COMPRESS		- Pfad zum Standard-COMPRESS			   */
X/* >GREP 		- Pfad zum SUCH-Programm (GREP -L: Filename only !)*/
X/* >SORTEDCUT           - Zaehlt die Downloads pro File			   */
X/* >SECONDCUT           - Zaehlt die Anrufe pro User			   */
X/* >UUX                 - Fuehrt Kommandos auf fremden Sites aus	   */
X/*  TAR			- Tar-Synopsis zum bilden eines neuen Archives     */
X/***************************************************************************/
X
X#define COMPRESS     	"/usr/bin/compress"
X#define GREP         	"/usr/bin/grep -l"
X#define SORTEDCUT       "cut -d' ' -i2 -f3 %s | sort - | uniq -c | sort -r - | sed '/ \\//s//   \\//g' > %s"
X#define SECONDCUT	"cut -c6-35 %s | sed '/  /s//    /g' | sort - | uniq -c | sort -r - > %s"
X#define UUX		"uux -r"
X#define TAR		"/usr/bin/tar cf"
X
X
X
X/***************************************************************************/
X/*  PDNG		 - Name der Freeware/Shareware/PD-NG		   */
X/*  PDLOG                - PD-Download-Protokoll			   */
X/*  PDSCRIPT		 - Pfad zum Protokoll der UPLOADs		   */
X/* >NEWS_MINIMUM         - Mindestens verfuegbare NGs			   */
X/*  MAX_PER_NG           - Maximale Anzahl der Eintraege pro NG		   */
X/*  EXPIRE_DAYS          - Ab wann loeschen, wenn MAX_PER_NG erreicht ist  */
X/*  MAX_XMD_ALIAS	 - Wieviele Namen kann XMD "umleiten"              */
X/*  NAT_DOMAIN1          - Nationale Domains (gebuehrenfrei)		   */
X/*  NAT_DOMAIN2          - (dito)					   */
X/*  NAT_DOMAIN3          - (dito)					   */
X/***************************************************************************/
X
X#define PDNG	     	"local.pd"
X#define PDLOG	     	"./etc/pd.log"
X#define PDSCRIPT     	"./etc/pd.script"
X#define NEWS_MINIMUM 	"local xenox de"
X#define MAX_PER_NG   	1000
X#define EXPIRED_DAYS 	32
X#define MAX_XMD_ALIAS   20
X#define NAT_DOMAIN1  	".de"
X#define NAT_DOMAIN2  	".sub.org"
X#define NAT_DOMAIN3  	".de" 
X
X
X
X
X
X/***************************************************************************/
X/*  SZ  		  - ZModem Download				   */
X/*  SX			  - X-Modem					   */
X/*  SB		          - Y-Modem					   */
X/*  RZ			  - ZModem Upload				   */
X/*  RX                    - X-Modem 					   */
X/*  RB                    - Y-Modem					   */
X/***************************************************************************/
X
X#define SZ           	"/usr/bin/sz"
X#define SX           	"/usr/bin/sx"
X#define SB 	     	"/usr/bin/sb"
X
X#define RZ           	"/usr/bin/rz"
X#define RX	     	"/usr/bin/rx"
X#define RB	     	"/usr/bin/rb"
X
X
X
X
X
X/***************************************************************************/
X/*  TARIF           	  - Pfennige pro Einheit (Telefongebuehren)	   */
X/*  NZNT                  - Sekunden pro Einheit Nahzone/Normal-Tarif	   */
X/*  NZBT                  -                      Nahzone/Billig-Tarif	   */
X/*  RZNT                  - 		         Regionalzone/Normal-Tarif */
X/*  RZBT		  -			 Regionalzone/Billig-Tarif */
X/*  WZNT		  -			 Weitzone/Normal-Tarif     */
X/*  WZBT		  -			 Weitzone/Billig-Tarif     */
X/***************************************************************************/
X
X#define TARIF        	23
X#define NZNT         	360
X#define NZBT         	720
X#define RZNT 	     	60
X#define RZBT	    	120
X#define WZNT	     	21
X#define WZBT	     	42
X
X
X
X
X/***************************************************************************/
X/*  PRO_ENTRIES    	  - Maximal Eintraege in MBOX.CALLS      	   */
X/*  MAX_TAGE		  - Max. Eintraege im PRO-Diagramm		   */
X/***************************************************************************/
X
X#define PRO_ENTRIES  	999
X#define MAX_TAGE	16
X
X
X
X/***************************************************************************/
X/*  MVERSION		  - Version des MB-DAEMON			   */
X/*  REFLECT_NG		  - Auf diese Gruppe wird "reflektiert"		   */
X/*  REFLECT_LOG		  - LOG-File des Reflektors			   */
X/*  DIRLIST		  - Wird gesendet bei DIRLIST-Request 		   */
X/*  REFLECTUID		  - UID des Reflektors (siehe /etc/passwd)         */
X/*  TZS			  - ?? Fehler in der Zeitberechnung ??		   */
X/***************************************************************************/
X
X#define MVERSION    	"+++ Un.Net Reflecting Device - Version 1.6 / MB-DAEMON +++"
X#define REFLECT_NG  	"xenox.test"
X#define REFLECT_LOG 	"/local/mbox/etc/reflector.log"
X#define DIRLIST     	"/public/pd/DIRLIST"
X#define REFLECTUID  	22
X#define TZS		1
X
X
X/***************************************************************************/
X/*  MIME-VERSION	  - MIME Versionsnummer (f. MultiMedia-Mail)	   */
X/***************************************************************************/
X
X#define MIME_VERSION	"1.0"
X
X
X
END_OF_FILE
  if test 13062 -ne `wc -c <'src/mbox.h'`; then
    echo shar: \"'src/mbox.h'\" unpacked with wrong size!
  fi
  # end of 'src/mbox.h'
fi
echo shar: End of archive 7 \(of 11\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
