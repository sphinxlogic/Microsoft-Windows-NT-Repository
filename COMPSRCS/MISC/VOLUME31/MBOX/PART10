Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Subject:  v31i026:  mbox - A BBS for UNIX and MINIX v1.6 PL10, Part10/11
Message-ID: <1992Jul10.050515.27860@sparky.imd.sterling.com>
X-Md4-Signature: 315841a031b722ba6895c0f4d7e5abda
Date: Fri, 10 Jul 1992 05:05:15 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Posting-number: Volume 31, Issue 26
Archive-name: mbox/part10
Environment: MINIX, ISC, ESIX, SVR3
Supersedes: mbox: Volume 29, Issue 63-72

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  Announcement FAQ etc/alias.sh etc/english.befehl
#   etc/help.befehle etc/logo~ etc/mbox.games etc/mbox.packers
#   etc/mbox.udc etc/rmail.sh etc/sysinfo etc/xmd.alias rz.cdiff
#   src/CROSSREF src/HISTORY src/baudrate.c src/befehl.c src/control.c
#   src/ctrlx.c src/derror.c src/faces.c src/games.c src/getch.c
#   src/help.c src/nerror.c src/outdial.c src/weiterl.c
# Wrapped by kent@sparky on Thu Jul  9 23:26:04 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 10 (of 11)."'
if test -f 'Announcement' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Announcement'\"
else
  echo shar: Extracting \"'Announcement'\" \(1121 characters\)
  sed "s/^X//" >'Announcement' <<'END_OF_FILE'
XThis is the ix/MBox BBS for MINIX-386 (1.5.10 patched by BDE) and other
XUNIX-Systems (SYSV/Sys7) without 64k segment limitation.
X
XRead the ANNOUNCEMENT (Message-ID: <295A0201.18@unnet.w.open.de> 26. Dec. 91)
Xto get further information.
X
XHow to unpack:
X
X1. UUD the following 5 articles (you should get 'mbox.xa*')
X2. Use the script ...
X
X--- cut here  ---
X
Xcat mbox.x* > mbox.tar.Z
Xmkdir /mbox			# Use this directory to minimize problems
Xcp *.Z /mbox			
Xcd /mbox
Xuncompress *.Z
Xtar ovx *.tar
X. Quick.Start
X
X--- cut again ---
X
XDon't blame me for not using SHAR etc. ... primary this source was made and
Xposted for MINIX-Freaks and so I use pure MINIX-Stuff to offer this package!
X
XRegard(s|less), Volker
X
X---------------------------------------------------------------------------
X
XSat Jun 6 14:11:01 CET 1992, Volker Schuermann <volkers@unnet.w.open.DE>
X
Xix/MBox 1.6 PL10a::
X
X -  Der Befehl "BRETT !" wurde erweitert: Er zeigt jetzt neben dem
X    Namen eines Brettes auch den entsprechenden Informationstext an
X
X -  Es gibt jetzt eine Moeglichkeit externe Kommandos direkt in die
X    Befehls-Struktur der MBox einzubinden
X
END_OF_FILE
  if test 1121 -ne `wc -c <'Announcement'`; then
    echo shar: \"'Announcement'\" unpacked with wrong size!
  fi
  # end of 'Announcement'
fi
if test -f 'FAQ' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'FAQ'\"
else
  echo shar: Extracting \"'FAQ'\" \(2295 characters\)
  sed "s/^X//" >'FAQ' <<'END_OF_FILE'
XFAQs // ix/MBox BBS 1.6 PL 10e // 04.07.1992
X
X
XQ: Why does the BBS 'core', when I try to start it the FIRST time?
XA: Maybe you've forgotten to 'make world' first?
X
XQ: Why does the BBS speak german?
XA: You have to 'make english' to get the english version.
X
XQ: Why doesn't the BBS report any boards with OLD articles?
XA: Type in 'mb-daemon all -x' and be patient ... (you have to be ROOT !)
X   Check your 'Boards'-Entry with the 'admin' command!
X
XQ: Why doesn't the BBS report any boards with NEW articles?
XA: Check your scanner-date. Use 'setup'!
X
XQ: Why do I always get problems if I try to mail or write something?
XA: It sounds like you've forgotten to use SETUID root.root for [mbox].
X
XQ: Why does the BBS terminate everytime I try to get in as ROOT?
XA: You've defined the ONE AND ONLY terminal, which ROOT may use, in
X   [mbox.h], do you remember??
X
XQ: Why do I never see new NEWS in the boards of BBS?
XA: Maybe you never start MB-DAEMON by cron!?
X
XQ: Why do I have trillions of mails in postmasters maildrop?
XA: You should start XMD by cron hourly!
X
XQ: Why does XMD crash instead of delivering mails?
XA: It has to be owned by 'root.root'!
X
XQ: Why seems MB-DAEMON to be sooooo slow?
XA: Spend a TMP-directory on the same FS as HOME|MBOXHOME!
X
XQ: Why do I get addresses like this in UUCP-Spoolfiles:
X   From: unnet!Volker.Schuermann@unnet.w.open.DE
XA: It's a problem with RMAIL. Have a look at README.addrpatch to fix it!
X
XQ: How can I include ELM etc. to the BBS command set?
XA: Have a look at README, Section: User defined Commands!
X
XQ: Why does the BBS blow up, when I use C-NEWS?
XA: Maybe I haven't implemented the aliasing mechanism correct - please
X   tell me, how it works!
X
XQ: Is there any risk to loose one of my system-files?
XA: Yes, If you play around with MB-DAEMON, you may destroy [~/news/active]!
X   Be clever: Copy first, destroy later ;-)
X
XQ: Why does my SMAIL create a second Message-ID & Received-Field ?
XA: Just set the SMAIL-Flag "-received_field". To make live easier, append
X   the flag "error_copy_postmaster", too! 
X
XQ: It it possible to port the BBS to system XYZ?
XA: Just try it :-) If you've done so, send the DIFFs to me!
X
XQ: Are there any plans to develope further versions of this BBS?
XA: Surely! Join our Mailing-List to stay put - see README how to do that!
X
X
END_OF_FILE
  if test 2295 -ne `wc -c <'FAQ'`; then
    echo shar: \"'FAQ'\" unpacked with wrong size!
  fi
  # end of 'FAQ'
fi
if test -f 'etc/alias.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/alias.sh'\"
else
  echo shar: Extracting \"'etc/alias.sh'\" \(907 characters\)
  sed "s/^X//" >'etc/alias.sh' <<'END_OF_FILE'
X#---------------------------------------------------------------------------
X#
X#                       ix/MBox  A L I A S . S H
X#		  Mailbox-Programm fuer UNIX(-Derivate)
X#			
X#			   Volker Schuermann
X#		      Wuppertal, FRG, 08.12.1991
X#
X#---------------------------------------------------------------------------
X# Dieses Script fuegt einen Eintrag fuer jeden neuen User der ix/MBox an die
X# Alias-Datei von SMAIL (etc.) an und erzeugt einen neue Alias-Datenbank. 
X#
X# Wird UMAIL statt SMAIL verwendet, sollten alle Zeilen dieses Scripts' aus-
X# kommentiert werden.
X#---------------------------------------------------------------------------
X# Parameter:
X#
X# $1  ->  Name des neuen Users im Format "Vorname.Nachname"
X# 
X# Beispiel:
X#
X# echo $1 "		" \"\|/usr/bin/xmd $1 -\" >> /usr/lib/smail/aliases
X# /usr/bin/mkaliases
X
Xecho $1 "		" \"\|/usr/bin/xmd $1 -\" >> /usr/lib/smail/aliases
X/usr/bin/mkaliases
END_OF_FILE
  if test 907 -ne `wc -c <'etc/alias.sh'`; then
    echo shar: \"'etc/alias.sh'\" unpacked with wrong size!
  fi
  # end of 'etc/alias.sh'
fi
if test -f 'etc/english.befehl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/english.befehl'\"
else
  echo shar: Extracting \"'etc/english.befehl'\" \(2128 characters\)
  sed "s/^X//" >'etc/english.befehl' <<'END_OF_FILE'
X/***************************************************************************/
X/* Please make changes to this file VERY wisely! Remember that you have to */
X/* list D(ir) before DA(te) and M(ail) before MA(cro) to stay conform with */
X/* GEONET etc. ...							   */
X/*								           */
X/*                 Description						   */
X/* ======================================================================= */
X/* ID            - Number of command (see 'loop.c')			   */
X/* Intern        - Need Userlevel X to execute the command		   */
X/* Extern        - Oldfashioned diff between int. & ext. access		   */
X/* Prototyp      - If this value is '1', the command is shown in helpfile  */
X/* Befehl        - That's the name of the command			   */
X/*									   */
X/*									   */
X/* NOTE: Leave ONE blank line between this comment-box and the ID-Line!    */
X/***************************************************************************/
X
XID    Intern  Extern  Prototyp  Befehl 
X===============================================
X110	0	0	1	+
X120	0	0	1	-
X260	0	0	1	Account
X125	9	9	0	Admin
X460	0	0	1	Area
X150	0	0	1	Board
X170	0	0	1	Chat
X200	0	0	1	Dir
X370	0	0	1	Date
X220	1	1	1	Delete
X440	0	0	1	Download
X150	0	0	0	Cd
X400     0       0       1       Direction
X180	0	0	0	End
X480  	1	1	1	Edit
X300	1	1	1	Finger
X340	1	1	1	Forward
X390 	0	0	1	Games
X180	0	0	1	Goodbye
X180	0	0	0	Quit
X180	0	0	0	Bye
X190	0	0	1	Help
X160	0	2	1	Mail
X330     0       0       1       Macro
X140	0	0	1	Message
X240	6	6	1	Minix
X240	6	6	0	Execute
X450 	7	7	0	Outdial
X270	0	0	1	Portinfo
X130	0	0	1	Protocol
X250	0	0	1	PM
X210	0	0	1	Read
X280	0	0	1	Setup
X470	0	0	1	Sysinfo
X280	0	0	0	Password
X280	0	0	0	Ansi
X280	0	0	0	Bell
X280	0	0	0	Address
X310	1	0	1	Signature
X290	0	0	1	State
X410     0       0       1       Statistics
X430     1       1       1       Search
X380	0	0	1	Time
X300	0	0	1	Users
X320	0	0	1	Version        
X230	0	5	1	Write
X270	0	0	0	Who
X420	0	0	0	RING
X195	0	1	0	~PD
X215	0	0	0	Level
X275	9	9	0	Relogin
X350     0       0       0       Sleep
X360     0       0       0       Keypressed
X230     0       5       1       Upload
X180     0       0       0       RING
X998	2	2	0	~MAIL_DUMMY
END_OF_FILE
  if test 2128 -ne `wc -c <'etc/english.befehl'`; then
    echo shar: \"'etc/english.befehl'\" unpacked with wrong size!
  fi
  # end of 'etc/english.befehl'
fi
if test -f 'etc/help.befehle' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/help.befehle'\"
else
  echo shar: Extracting \"'etc/help.befehle'\" \(2848 characters\)
  sed "s/^X//" >'etc/help.befehle' <<'END_OF_FILE'
X/***************************************************************************/
X/* Wer diese Datei aendert sollte GENAU wissen was er tut. Die Reihen-     */
X/* folge der Befehle ist NICHT willkuerlich festgelegt worden, sondern     */
X/* entspricht der Vorgabe fuer GEOnet-Befehle und deren Abkuerzungen.      */
X/*									   */
X/* S(chreiben) kommt vor SE(tup) und L(esen) vor LOE(schen) etc. ... wer   */
X/* sich nicht voellig sicher ist, sollte die Datei einfach im Urzustand    */
X/* belassen.								   */
X/*								           */
X/*                 Die Bedeutung der versch. Spalten 			   */
X/* ======================================================================= */
X/* ID            - Nummer des Befehls (siehe "loop()")			   */
X/* Intern        - Benoetigtes Userlevel				   */
X/* Extern        - Bei einigen Befehle wird unterscheiden zwischen intern  */
X/*		   und extern. Z.B. beim Befehl "schreiben" wird diese     */
X/*		   Regelung angewendet, damit User zwar an die lokalen     */
X/*		   Bretter senden duerfen, nicht aber an die externen.     */
X/* Prototyp      - Enthaelt diese Spalte eine '1', wird der Befehl bei der */
X/*		   Befehlsuebersicht angezeigt.				   */
X/* Befehl        - Unter diesem Namen wird der Befehl aufgerufen           */
X/*									   */
X/*									   */
X/* ACHTUNG: Zwischen Kommentar und Ueberschrift EINE Leerzeile einfuegen ! */
X/***************************************************************************/
X
XID    Intern  Extern  Prototyp  Befehl 
X===============================================
X110	0	0	1	+
X120	0	0	1	-
X130	0	0	1	Anrufer
X140	1	0	1	Ansage
X150	0	0	1	Brett
X160	0	2	1	Brief
X170	0	0	1	Chat
X170	0	0	0	Dialog
X370	0	0	0	Datum
X170	0	0	0	Co
X999	0	0	1	Demo
X440     0       0       1       Download
X210	0	0	1	Lesen
X480	1	1	1	Edit
X180	0	0	1	Ende
X180	0	0	0	Quit
X180	0	0	0	Log
X460	0	0	0	Area
X460	0	0	1	Gruppe
X180	0	0	0	Goodbye
X190	0	0	1	Hilfe
X195	0	1	0	~PD
X200	0	0	1	Inhalt
X200	0	0	0	Dir
X205	0	0	0	Id
X215	0	0	0	Level
X220	1	1	1	Loeschen
X330     0       0       1       Makro
X240	6	6	1	Minix
X240	6	6	0	Execute
X450	1	1	1	Outdial
X450	1	1	0	Od
X270	0	0	1	Portinfo
X270	0	0	0	Who
X270	0	0	0	Wer
X260	0	0	1	Postfach
X260	0	0	0	Antrag
X275	9	9	0	Relogin
X400     0       0       1       Richtung
X230	0	5	1	Schreiben
X280	0	0	1	Setup
X390 	0	0	1	Spiele
X430	1	1	1	Suchen
X470	0	0	1	Sysinfo
X280	0	0	0	Passwort
X280	0	0	0	Ansi
X280	0	0	0	Bell
X280	0	0	0	Anschrift
X290	0	0	1	Status
X410     0       0       1       Statistik
X300	0	0	1	User
X310	1	0	1	Unterschrift
X230     0       5       1       Upload
X320	0	0	1	Version        
X340	1	1	1	Weiterleiten
X380	0	0	0	Zeit
X125	1	9	0	Admin
X130	0	0	0	Protokoll
X250	0	0	1	PM
X150	0	0	0	Cd
X300	0	0	0	Finger
X160	0	2	0	Mail
X180	0	0	0	Quit
X180	0	0	0	Exit
X180	0	0	0	Logout
X420	0	0	0	RING
X350     0       0       0       Sleep
X360     0       0       0       Keypressed
X998	7	7	0	~MAIL_DUMMY
END_OF_FILE
  if test 2848 -ne `wc -c <'etc/help.befehle'`; then
    echo shar: \"'etc/help.befehle'\" unpacked with wrong size!
  fi
  # end of 'etc/help.befehle'
fi
if test -f 'etc/logo~' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/logo~'\"
else
  echo shar: Extracting \"'etc/logo~'\" \(243 characters\)
  sed "s/^X//" >'etc/logo~' <<'END_OF_FILE'
X
X
X
Xooo o o ooo   ooo o ooo ooo   ooo oo   o  o o ooo o      o  oo  ooo ooo ooo o o
X o  ooo oo     o  o ooo oo     o  ooo ooo o o oo  o     ooo o o oo  ooo o    o
X o  o o ooo    o  o o o ooo    o  o o o o  o  ooo ooo   o o ooo ooo ooo ooo  o
X
X
END_OF_FILE
  if test 243 -ne `wc -c <'etc/logo~'`; then
    echo shar: \"'etc/logo~'\" unpacked with wrong size!
  fi
  # end of 'etc/logo~'
fi
if test -f 'etc/mbox.games' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/mbox.games'\"
else
  echo shar: Extracting \"'etc/mbox.games'\" \(734 characters\)
  sed "s/^X//" >'etc/mbox.games' <<'END_OF_FILE'
X/***************************************************************************/
X/* Diese Datei enthaelt die Liste der verfuegbaren Spiele. Die Struktur    */
X/* ist folgende:							   */
X/*									   */
X/* Name		Pfad zum Spiel						   */
X/* ======================================================================= */
X/* animals   	/usr/bin/animals					   */
X/* ttt		/usr/bin/ttt						   */
X/*									   */
X/* ACHTUNG: Zwischen Kommentar und Liste EINE Leerzeile einfuegen !	   */
X/***************************************************************************/
X
XAnimals	/usr/bin/animals
XDiepbom /usr/games/diepbom
XEmpire	/usr/games/empire
XKiller	/usr/games/killer
XSokoban	/usr/games/sokoban
XRogue	/usr/bin/rogue
XRobots  /usr/games/robots
END_OF_FILE
  if test 734 -ne `wc -c <'etc/mbox.games'`; then
    echo shar: \"'etc/mbox.games'\" unpacked with wrong size!
  fi
  # end of 'etc/mbox.games'
fi
if test -f 'etc/mbox.packers' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/mbox.packers'\"
else
  echo shar: Extracting \"'etc/mbox.packers'\" \(798 characters\)
  sed "s/^X//" >'etc/mbox.packers' <<'END_OF_FILE'
X/***************************************************************************/
X/* In dieser Datei befindet sich eine Liste von Komprimieren und Archi-    */
X/* vierern ueber die Artikel im Download-Modus gepackt werden koennen.	   */
X/*									   */
X/* Packer	Kommando	     Befehl TAR-Archiv 	Endung		   */
X/* ======================================================================= */
X/* Compress4.3	/usr/bin/compress	?	+	  .Z		   */
X/* Lharc1.02	/usr/bin/lharc a	-a	-	  .lzh	   	   */
X/*									   */
X/* ACHTUNG: Zwischen Kommentar und Liste EINE Leerzeile einfuegen !	   */
X/***************************************************************************/
X
XCompress4.3	/usr/bin/compress	?	+	.Z
XLharc1.02	/usr/bin/lharc		a	-	.lzh
XZoo2.1		/usr/bin/zoo		-add	-	.zoo
XFreeze1.1	/usr/bin/freeze		?	+	.F
X
X
END_OF_FILE
  if test 798 -ne `wc -c <'etc/mbox.packers'`; then
    echo shar: \"'etc/mbox.packers'\" unpacked with wrong size!
  fi
  # end of 'etc/mbox.packers'
fi
if test -f 'etc/mbox.udc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/mbox.udc'\"
else
  echo shar: Extracting \"'etc/mbox.udc'\" \(780 characters\)
  sed "s/^X//" >'etc/mbox.udc' <<'END_OF_FILE'
X/***************************************************************************/
X/* Die Datei enthaelt eine Liste von Befehlen, die vom jeweiligen Betrei-  */
X/* ber der ix/MBox zusaetzlich angeboten werden.			   */
X/*									   */
X/* Befehl	Level	Programm					   */
X/* ======================================================================= */
X/* metamail	  1	/usr/local/bin/metamail	 			   */
X/* nn		  5	/usr/bin/nn				  	   */
X/* ps		  2	/usr/bin/ps -edalf				   */
X/*									   */
X/* ACHTUNG: Zwischen Kommentar und Liste EINE Leerzeile einfuegen !	   */
X/*          Die Eintraege MUESSEN unbedingt in alphabetischer Reihenfolge  */
X/*          sortiert sein ! 						   */
X/***************************************************************************/
X
Xelm	3	/usr/local/bin/elm
END_OF_FILE
  if test 780 -ne `wc -c <'etc/mbox.udc'`; then
    echo shar: \"'etc/mbox.udc'\" unpacked with wrong size!
  fi
  # end of 'etc/mbox.udc'
fi
if test -f 'etc/rmail.sh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/rmail.sh'\"
else
  echo shar: Extracting \"'etc/rmail.sh'\" \(993 characters\)
  sed "s/^X//" >'etc/rmail.sh' <<'END_OF_FILE'
X#---------------------------------------------------------------------------
X#
X#                       ix/MBox  R M A I L . S H
X#		  Mailbox-Programm fuer UNIX(-Derivate)
X#			
X#			   Volker Schuermann
X#		      Wuppertal, FRG, 08.12.1991
X#
X#---------------------------------------------------------------------------
X# Dieses Script uebergibt eine "persoenliche Mail" und eine Empfaenger-
X# Adresse an das Programm RMAIL. Die "persoenliche Mail" enthaelt bereits
X# einen (fast) kompletten Header !
X#
X# Bei Verwendung von SMAIL sollte "config.mbox" speziell fuer die Unter-
X# drueckung der SMAIL-Message-ID etc. konfiguriert werden.
X#---------------------------------------------------------------------------
X# Parameter:
X#
X# $1  ->  Name der Datei ("persoenliche Mail" s.o.)
X# $2  ->  Empfaenger der Mail
X# 
X# Beispiel:
X#
X# rmail -d -i $1 $2
X#
X# Oder:
X# 
X# smail -i -C /usr/local/lib/smail/config.mbox $2 < $1
X#
X# config.mbox ->
X# -recieved_field
X# copy_error_postmaster   
X
Xrmail -d -i $1 $2
END_OF_FILE
  if test 993 -ne `wc -c <'etc/rmail.sh'`; then
    echo shar: \"'etc/rmail.sh'\" unpacked with wrong size!
  fi
  # end of 'etc/rmail.sh'
fi
if test -f 'etc/sysinfo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/sysinfo'\"
else
  echo shar: Extracting \"'etc/sysinfo'\" \(1906 characters\)
  sed "s/^X//" >'etc/sysinfo' <<'END_OF_FILE'
XContent-Type: text/richtext
XDiese Mailbox laeuft auf einem 20 MHz 386er iNTEL-Rechner mit ca. 240 MB<nl>
XPlattenkapazitaet und 8 MB Hauptspeicher.<nl>
X<nl>
XEingesetzt wird das Betriebssystem MINIX in der 386er Version. Das Mail-<nl>
Xboxprogramm ist ix/MBox, eine Produkt aus der Public Domain.<nl>
X<nl>
XEs werden zwei Modem-Ports angeboten:<nl>
X<nl>
XPort1: USRobotics Courier HST 300-19.2k    0202  462114<nl>
XPort2: Dicovery 2400C         300-2400     0202  4660234<nl>
X<nl>
X<Center><Bold>--------------------------</Bold></Center><nl>
X<nl>
XObwohl diese Mailbox nicht kommerziell betrieben wird, sind einige der<nl>
Xangebotenen Dienste gebuehrenpflichtig.<nl>
X<nl>
X	<Bold>GEBUEHRENFREI</Bold> ist:<nl>
X<nl>
X	o  die Benutztung der Mailbox<nl>
X	o  das private Postfach<nl>
X	o  die Nutzung der verschienden PD-Archive<nl> 
X	o  die private Post an Teilnehmer innerhalb des SUBnet<nl>
X	o  die Teilnahme an den NEWS-Gruppen "de.*"<nl>
X<nl>
X	<Bold>GEBUEHRENPFLICHTIG</Bold> ist:<nl>
X<nl>
X	o  der <Bold>OUTDIAL</Bold>-Service - Verbindung zu Mailboxen<nl>
X	   und Datenbanken im In- und Ausland<nl>
X	o  die private Post an Teilnehmer ausserhalb des SUBnet<nl>
X	o  die Teilnahme an den internationalen NEWS-Gruppen<nl>   
X<nl>    
XGenauere Informationen und aktuelle Aenderungen werden regelmaessig im<nl>
XBrett 'local.talk' bekanntgegeben.<nl>
X<nl>
X<Center><Bold>--------------------------</Bold></Center><nl>
X<nl>
XDie Gebuehren fuer den internationalen MAIL- und NEWS-Zugriff betragen<nl>
Xpro Quartal/User 19.50 DM. Sie sind auf untenstehendes Konto zu ueber-<nl>
Xweisen.<nl>
X<nl>
X	Volker Schuermann<nl>
X	Kto. 4131363<nl>
X	Blz. 330 500 00 / Stadtsparkasse Wuppertal<nl>
X	<Bold>STICHWORT</Bold> "Acct. Username"<nl>       
X<nl>
XBitte das <Bold>STICHWORT</Bold> unbedingt angeben, da die Buchung sonst evtl. als<nl>
XSpende gewertet wird!<nl>
X<nl>
X<Center><Bold>--------------------------</Bold></Center><nl>
X<nl>
X
END_OF_FILE
  if test 1906 -ne `wc -c <'etc/sysinfo'`; then
    echo shar: \"'etc/sysinfo'\" unpacked with wrong size!
  fi
  # end of 'etc/sysinfo'
fi
if test -f 'etc/xmd.alias' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/xmd.alias'\"
else
  echo shar: Extracting \"'etc/xmd.alias'\" \(1057 characters\)
  sed "s/^X//" >'etc/xmd.alias' <<'END_OF_FILE'
X#---------------------------------------------------------------------------
X#
X#                       ix/MBox  X M D . A L I A S
X#		  Mailbox-Programm fuer UNIX(-Derivate)
X#			
X#			   Volker Schuermann
X#		      Wuppertal, FRG, 15.02.1992
X#
X#---------------------------------------------------------------------------
X# In dieser Datei werden Empfaenger-Adressen und deren Alias gespeichert.
X#
X# Das Format der Eintraege ist folgendes:
X#
X# To: (1) Adresse, die per RMAIL uebertragen wurde
X# To: (2) Adresse, die innerhalb der ix/MBox verwendet werden soll
X# <LEERZEILE>
X# To: (1) etc.
X# To: (2) etc.
X# <LEERZEILE>
X#
X#---------------------------------------------------------------------------
X# Parameter: -keine-
X
XTo: Multiple recipients of <TEX-D-L@dearn.bitnet>
XTo: Christian.Boehm@unnet.w.open.DE
X
XTo: Multiple recipients of <TEX-D-L@DEARN.uucp>
XTo: Christian.Boehm@unnet.w.open.DE
X
XTo: Postmaster@unnet.w.open.DE
XTo: Volker.Schuermann@unnet.w.open.DE
X
XTo: Multiple recipients of list <386bsd-list@compuram.bbt.se>
XTo: Christian.Boehm@unnet.w.open.DE
X
X
END_OF_FILE
  if test 1057 -ne `wc -c <'etc/xmd.alias'`; then
    echo shar: \"'etc/xmd.alias'\" unpacked with wrong size!
  fi
  # end of 'etc/xmd.alias'
fi
if test -f 'rz.cdiff' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rz.cdiff'\"
else
  echo shar: Extracting \"'rz.cdiff'\" \(1562 characters\)
  sed "s/^X//" >'rz.cdiff' <<'END_OF_FILE'
X*** rz.c~	Sat Aug 10 13:39:34 1991
X--- rz.c	Sat Aug 10 13:13:54 1991
X***************
X*** 1,6 ****
X--- 1,8 ----
X  #define VERSION "2.03 05-17-88"
X  #define PUBDIR "/usr/spool/uucppublic"
X  
X+ /* Unnet == Modified for ix/MBox-Use !!! */
X+ 
X  /*% cc -compat -M2 -Ox -K -i -DMD -DOMEN % -o rz; size rz;
X  <-xtx-*> cc386 -Ox -DMD -DOMEN -DSEGMENTS=8 rz.c -o $B/rz;  size $B/rz
X   *
X***************
X*** 390,395 ****
X--- 392,399 ----
X  {
X  	register c;
X  
X+ 	strcpy(Pathname, *argp); checkpath(Pathname);  /* Unnet */
X+ 
X  	if (Batch || argc==0) {
X  		Crcflg=1;
X  		if ( !Quiet)
X***************
X*** 432,439 ****
X  		pclose(fout);  return ERROR;
X  	}
X  #endif
X! 	if (fout)
X! 		fclose(fout);
X  #ifndef vax11c
X  	if (Restricted) {
X  		unlink(Pathname);
X--- 436,445 ----
X  		pclose(fout);  return ERROR;
X  	}
X  #endif
X! 	if (fout){
X! 		fflush(fout); /* Unnet */
X! 		fclose(fout);
X! 	}
X  #ifndef vax11c
X  	if (Restricted) {
X  		unlink(Pathname);
X***************
X*** 915,922 ****
X  register n;
X  {
X  	register char *p;
X! 	if (n == 0)
X! 		return OK;
X  
X  	if (Thisbinary) {
X  		for (p=buf; --n>=0; ) 	
X--- 921,931 ----
X  register n;
X  {
X  	register char *p;
X!                                                       
X! 	if (n == 0)
X! 		return OK;
X!        
X! 	if (fout == 0) fout = fopen( Pathname, "a" );     /* Unnet */
X  
X  	if (Thisbinary) {
X  		for (p=buf; --n>=0; ) 	
X***************
X*** 1436,1441 ****
X--- 1445,1451 ----
X  		return OK;
X  	}
X  #endif
X+ 	fflush(fout);  /* Unnet */
X  	if (fclose(fout)==ERROR) {
X  		fprintf(stderr, "file close ERROR\n");
X  		return ERROR;
END_OF_FILE
  if test 1562 -ne `wc -c <'rz.cdiff'`; then
    echo shar: \"'rz.cdiff'\" unpacked with wrong size!
  fi
  # end of 'rz.cdiff'
fi
if test -f 'src/CROSSREF' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/CROSSREF'\"
else
  echo shar: Extracting \"'src/CROSSREF'\" \(2421 characters\)
  sed "s/^X//" >'src/CROSSREF' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  CROSSREF						   */
X/*        FUNKTIONEN  Cross-Referenz-Liste der Funktionen		   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  28.05.1992					   */
X/***************************************************************************/
X
Xadmin()				admin.c
Xansage()			lesen.c
Xansi()		 		tools.c
Xanzeigen()			lesen2.c
Xbaudrate()			baudrate.c
Xbef()				befehl.c
Xbrett()				misc2.c
Xbrief()				mail.c
Xbigcopy()			tools.c
Xcarboncopy()			weiterl.c
Xcheckdomaintype()		lesen.c
Xchk_newsgrp()			misc2.c
Xclearline()			tools.c
Xcontrol()			control.c
Xcrypted()			tools.c
Xctrlx()				ctrlx.c
Xcut_arg()			loop.c
Xcut_bef()			loop.c
Xdateconv()			tools.c
Xdatereconv()			tools.c
Xdownload()			pd.c
Xedit()				suchen.c
Xfaces()				faces.c
Xfetch_receipy()			mail.c
Xfinger()			portinfo.c
Xfixoutput()			main.c
Xgames()				games.c
Xgetch()				getch.c
Xgetint()			getline.c
Xgetline()			getline.c
Xgetsite()			lesen.c
Xheadline()			tools.c
Xhelp()				help.c
Xinhalt2()			lesen2.c
Xinit()				main.c
Xinit_user()			intro.c
Xintro()				intro.c
Xisin()				tools.c
Xlength()			tools.c
Xlesen()				lesen.c
Xlesen2()			lesen2.c
Xloeschen()			misc2.c
Xloeschen2()			lesen2.c
Xlogout()			main.c
Xloop()				loop.c
Xmain()				main.c
Xmaybe_locked()			tools.c
Xmblock()			tools.c
Xmbunlock()			tools.c
Xmore()				more.c
Xmkix()				pd.c
Xmydate()			tools.c
Xmytime()			tools.c
Xnerror()			nerror.c & derror.c
Xnoctrlx()			ctrlx.c
Xnum_stripped()			tools.c
Xoutdial()			outdial.c
Xpd()				pd.c
Xperms()				tools.c
Xport()				portinfo.c
Xpostfach()			postfach.c
Xprf()				misc.c
Xpruefe()			misc.c
Xquoted_printable()		show.c
Xrates()				loop.c
Xrename()			tools.c
Xrichtext()			show.c
Xscanner()			misc.c
Xschreiben()			misc.c
Xsetup()		  		admin.c
Xsetup_get()			admin.c
Xshortname()			tools.c
Xshow()				show.c
Xshow_level()			portinfo.c
Xsigcatch()			loop.c
Xstatus()			pd.c
Xstatistik()			pd.c
Xstrcomp()			tools.c
Xstrcopy()			tools.c
Xstripped()			tools.c
Xsubb()				misc2.c
Xsuchen()			suchen.c
Xtimeconv()			tools.c
Xtimereconv()			tools.c
Xtty()		 		tools.c
Xttyna()				tools.c
Xunterschrift()			lesen.c
Xupcased()			tools.c
Xuser_aendern()			admin.c
Xuser_anzeigen()			admin.c
Xuser_loeschen()			admin.c
Xuserliste()			portinfo.c
Xwait_until_keypressed()		admin.c
Xweiterleiten()			weiterl.c
Xwhoami()			tools.c
Xwhodo()				control.c
Xyesno()				getline.c
END_OF_FILE
  if test 2421 -ne `wc -c <'src/CROSSREF'`; then
    echo shar: \"'src/CROSSREF'\" unpacked with wrong size!
  fi
  # end of 'src/CROSSREF'
fi
if test -f 'src/HISTORY' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/HISTORY'\"
else
  echo shar: Extracting \"'src/HISTORY'\" \(2029 characters\)
  sed "s/^X//" >'src/HISTORY' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  HISTORY						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  20.02.1992					   */
X/***************************************************************************/
X
X20.04.1991  ->  Erste Versuche einen NEWS-Reader im Stil der alten "PC-Boxen"
X		zu basteln (sind positiv verlaufen)
X
X21.04.1991  ->  Schreiben an NGs via PNEWS 				
X
X22.04.1991  ->  REPLY via PNEWS
X
X23.04.1991  ->  SH-unabhaengiges Accounting
X
X26.04.1991  ->  Persoenliche Mail lesen, schreiben, beantworten
X
X11.05.1991  ->  Inhalt/Datum, Status
X
X01.06.1991  ->  Vorbereitung fuer die Portierung
X
X02.06.1991  ->  Erste BETA-Test Version an die Portierer/Tester verschickt
X
X18.06.1991  ->  Makro-Befehle implementiert
X
X15.08.1991  ->  SVR3 einigermassen angepasst, LOCK-Mechanismus eingebaut,
X		NNPOST und RMAIL ermoeglicht, versuchweise _SYS_ACCOUNT
X		integriert
X
X21.09.1991  ->  Scanner-Datum beim LOGOUT aktuallisieren, nicht mehr bei
X		init_user()
X
X21.10.1991  ->  Option fuer Online-Spiele implementiert
X
X26.10.1991  ->  Endlich ein "anstaendiges" Makefile:-)
X
X12.11.1991  ->  Die Anspassung an SVR3 laeuft auf Hochtouren
X
X16.11.1991  ->  Referenzversion 1.6.0 ueber "sub.os.minix" gepostet
X
X17.11.1991  ->  Patchlevel PL1 fertiggestellt
X           
X27.11.1991  ->  Patchlevel PL3 mit schnellerem MB-DAEMON ausgeliefert
X
X06.12.1991  ->  Umgestellt auf RMAIL & INEWS (Header mit Refs. etc.)
X
X28.12.1991  ->  Internationale Version (DEFINES, README, etc.) ausgeliefert
X
X04.01.1992  ->  MAIL- & NEWS-Header editierbar (Followup etc.)
X
X20.02.1992  ->  Eigener DOWNLOAD-Befehl. MB-DAEMON erstellt LIB online (opt.)
X
X09.05.1992  ->  RTF (Richtext Format) implementiert
X
X24.05.1992  ->  Strict-Accounting eingebaut / SVR4-Port funxt (!) / 1.6 PL9f
X
X06.06.1992  ->  Version 1.6 PL10 ausgeliefert
X
X06.06.1992  ->  Version 1.6 PL10 ausgeliefert
X
X06.06.1992  ->  Version 1.6 PL10 ausgeliefert
END_OF_FILE
  if test 2029 -ne `wc -c <'src/HISTORY'`; then
    echo shar: \"'src/HISTORY'\" unpacked with wrong size!
  fi
  # end of 'src/HISTORY'
fi
if test -f 'src/baudrate.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/baudrate.c'\"
else
  echo shar: Extracting \"'src/baudrate.c'\" \(1710 characters\)
  sed "s/^X//" >'src/baudrate.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  baudrate.c					   */
X/*        FUNKTIONEN  baudrate()					   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.03.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X#include <time.h>
X
X#include "mbox.h"
X
X
X#ifdef _SYS7	/* UNIX System 7  (MINIX, COHERENT, ...) */
X
X#include  <sgtty.h>
Xstatic struct sgttyb told;
X
X#else		/* UNIX System V  (UNIX, XENIX, ESIX, ...) */
X
X#include  <sys/termio.h> 
Xstatic struct termio told;
X
X#endif
X
X
X#define BYTE	0377	/* Don't ask me, ask Andy !! */
X
X
Xint baudrate( try )
Xint try;
X{
X  int i, j = 0;
X  int guess = -1;
X  long ts, tn;
X
X
X  if(BAUDRATE != 0) return BAUDRATE;
X
X#ifdef _SYS7
X  
X  ioctl( 0, TIOCGETP, &told );
X  guess = (int) (100 * (told.sg_ospeed & BYTE));
X
X#else
X
X  ioctl( 0, TCGETA, &told );
X
X  if(told.c_cflag &=    B300) guess = (int)   300;
X  if(told.c_cflag &=   B1200) guess = (int)  1200;
X  if(told.c_cflag &=   B2400) guess = (int)  2400;
X  if(told.c_cflag &=   B4800) guess = (int)  4800;
X  if(told.c_cflag &=   B9600) guess = (int)  9600;
X  /*
X  if(told.c_cflag &=  B14400) guess = (int) 14400;
X  */
X  if(told.c_cflag &=  B19200) guess = (int) 19200;
X  if(told.c_cflag &=  B38400) guess = (int) 38400;
X
X#endif
X
X#ifdef _BAUDRATE  	/* HST mit 'fixed baudrate 19.2k' */
X	
X  if((guess == MAX_BPS) || (guess == 0)){
X
X	guess = 300;
X
X	if(try >   300) guess =  1200;
X	if(try >  1200) guess =  2400;
X	if(try >  2400) guess =  9600;
X	if(try >  9600) guess = 14400;
X	if(try > 14400) guess = 19200;
X  }
X
X#endif
X
X  return guess;
X
X}
END_OF_FILE
  if test 1710 -ne `wc -c <'src/baudrate.c'`; then
    echo shar: \"'src/baudrate.c'\" unpacked with wrong size!
  fi
  # end of 'src/baudrate.c'
fi
if test -f 'src/befehl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/befehl.c'\"
else
  echo shar: Extracting \"'src/befehl.c'\" \(2060 characters\)
  sed "s/^X//" >'src/befehl.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  befehl.c						   */
X/*        FUNKTIONEN  bef()						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  06.06.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
X/***************************************************************************/
X/*      FUNKTION  bef()							   */
X/*  BESCHREIBUNG  Sucht entweder die Befehlsnummer zu einem bekannten      */
X/*		  Befehl, oder zeigt die Befehle als Uebersicht an.        */
X/*		  Dabei wird das Userlevel beruecksichtigt.                */
X/*     PARAMETER  befehl  =  Befehl  =  Befehl, der gesucht werden soll    */
X/*			     '?'     =  Befehle anzeigen (levelabhaengig)  */
X/*		  arg     =  '*'     =  ALLE Befehle anzeigen 	           */
X/*     RUECKGABE  -1  =  Userlevel reicht nicht aus			   */
X/*     		  -9  =  Befehl nicht gefunden				   */
X/*		   n  =  Befehlsnummer (siehe Datei BEFEHLE und loop.c)	   */
X/***************************************************************************/
X
Xint bef(befehl, arg)
Xchar befehl[];
Xchar arg[];
X{
X  char s[STRING];
X  int b = 0, i = 0, l;
X
X  l = USER.level;
X
X  if (befehl[0] == '?') {
X
X	if (arg[0] == '*') l = 9999;
X
X	while (BEF[b].id != -1) {
X		if ((BEF[b].prototyp == 1) && (BEF[b].in <= l)) {
X			printf("%-14.14s ", BEF[b].befehl);
X			i++;
X			if (i == 5) {
X				printf("\n");
X				i = 0;
X			}
X		}
X		b++;
X	}
X	printf("\n\n");
X	return 0;
X  }
X  else {
X	while (BEF[b].id != -1) {
X		if (strcomp(befehl, BEF[b].befehl) == 0) {
X			if (BEF[b].in <= USER.level){
X				if(BEF[b].id == 1000){
X					printf("\n\n");
X					if(arg[0] == '\0')
X						sprintf(s, "exec %s %s %d %d", RSH, BEF[b].pfad, OLDUID, OLDGID);
X					else
X						sprintf(s, "exec %s %s \"%s\" %d %d", RSH, BEF[b].pfad, arg, OLDUID, OLDGID);			
X					system(s);
X				}
X				return BEF[b].id;
X			}
X			else{
X				return -1;
X			}
X		}
X		b++;
X	}
X	return -9;
X  }
X}
END_OF_FILE
  if test 2060 -ne `wc -c <'src/befehl.c'`; then
    echo shar: \"'src/befehl.c'\" unpacked with wrong size!
  fi
  # end of 'src/befehl.c'
fi
if test -f 'src/control.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/control.c'\"
else
  echo shar: Extracting \"'src/control.c'\" \(2590 characters\)
  sed "s/^X//" >'src/control.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  control.c						   */
X/*        FUNKTIONEN  control(), whodo()				   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  24.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
X
X/***************************************************************************/
X/*      FUNKTION  control()						   */
X/*  BESCHREIBUNG  Fuehrt ein "Logbuch" in zwei versch. Dateien/auf zwei    */
X/*		  versch. Geraeten (CONSOLE & CPRN).                       */
X/*     PARAMETER  text  =  Ansage-Text                                     */
X/*		  mode  =  '< 99'  =  Ausgabe auf CONSOLE                  */
X/*		  mode  =  '= 99'  =  Ausgabe auf CPRN                     */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
XFILE *contfp = NULL;
X
Xvoid control(text, mode)
Xchar text[];
Xint mode;
X{
X  if (mode < 99) {
X
X#ifdef _MINIX
X	if(tty() >= FIRST_EX_TTY){
X#endif
X		contfp = fopen(CONSOLE_REDIRECT, "a");
X		if (contfp == NULL) {
X			printf("\n\n%s [%s]\n\n", CTL01_MSG, CONSOLE_REDIRECT);
X			exit(-1);
X		}
X#ifdef _DATESTAMP
X		fprintf(contfp, "%s %s <%s>  %s\n", mydate(1), mytime(1), ttyna(), text);
X#else
X		fprintf(contfp, "MBOX: (%s:) %s\n", ttyna(), text);
X#endif
X		fflush(contfp);
X		fclose(contfp);
X#ifdef _MINIX
X	}
X#endif
X
X  }
X  if (mode == 99) {
X	contfp = fopen(CPRN, "a");
X	if (contfp == NULL) {
X		printf("\n\n%s [%s]\n\n", CTL01_MSG, CPRN);
X		exit(-1);
X	}
X	fprintf(contfp, "\n%s  -  %s\n", mydate(1), mytime(1));
X	fprintf(contfp, "MBOX: (%s:) %s\n", ttyna(), text);
X	fflush(contfp);
X	fclose(contfp);
X  }
X}
X
X
X
X/***************************************************************************/
X/*      FUNKTION  whodo()						   */
X/*  BESCHREIBUNG  Erstellt eine Datei fuer die "portinfo()"-Routine.       */
X/*     PARAMETER  text = Ansage-Text (aktiver Befehl etc.)                 */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid whodo(text)
Xchar text[];
X{
X  FILE *fp;
X  char s[STRING];
X
X  s[0] = '\0'; strcat(s, HOME); strcat(s, "/etc/");
X  strcat(s, (char *) ttyna()); strcat(s, ".");
X
X  fp = fopen(s, "w");
X  if (fp == NULL) {
X	nerror("control.c", 44, "whodo", "Datei-Schreibfehler", s);
X  }
X  fputs(text, fp);
X  fclose(fp);
X}
END_OF_FILE
  if test 2590 -ne `wc -c <'src/control.c'`; then
    echo shar: \"'src/control.c'\" unpacked with wrong size!
  fi
  # end of 'src/control.c'
fi
if test -f 'src/ctrlx.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/ctrlx.c'\"
else
  echo shar: Extracting \"'src/ctrlx.c'\" \(2077 characters\)
  sed "s/^X//" >'src/ctrlx.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  ctrlx.c						   */
X/*        FUNKTIONEN  ctrlx(), noctrlx()				   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.11.1991					   */
X/***************************************************************************/
X
X#ifdef _SYS7	/* UNIX System 7  (MINIX, COHERENT, ...) */
X
X#include  <sgtty.h>
Xstatic struct tchars newtc, oldtc;
X
X#else		/* UNIX System V  (UNIX, XENIX, ESIX, ...) */
X
X#include  <sys/termio.h> 
Xstatic struct termio newtc, oldtc;
X
X#endif
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  ctrlx()						   */
X/*  BESCHREIBUNG  Das QUIT-Zeichen wird auf (int) 24 gesetzt - das ent-	   */
X/*		  spricht einem CTRL-X. Wird nun CTRL-X gedrueckt, loest   */
X/*		  UNIX das Signal SIGABRT aus ...                          */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid ctrlx()
X{
X
X#ifdef _SYS7
X
X  ioctl(0, TIOCGETC, (struct sgttyb *) &oldtc);
X  newtc = oldtc;
X  newtc.t_quitc = 24;
X  ioctl(0, TIOCSETC, (struct sgttyb *) &newtc);
X
X#else
X
X  ioctl(0, TCGETA, (struct termio *) &oldtc);
X  newtc = oldtc;
X  newtc.c_cc[VQUIT] = 24;
X  ioctl(0, TCSETA, (struct termio *) &newtc);
X
X#endif
X
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  noctrlx()						   */
X/*  BESCHREIBUNG  Das QUIT-Zeichen wird "restauriert" ...		   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid noctrlx()
X{
X
X#ifdef _SYS7
X
X  ioctl(0, TIOCSETC, (struct sgttyb *) &oldtc);
X
X#else
X
X  ioctl(0, TCSETA, (struct termio *) &oldtc);
X
X#endif
X
X}
END_OF_FILE
  if test 2077 -ne `wc -c <'src/ctrlx.c'`; then
    echo shar: \"'src/ctrlx.c'\" unpacked with wrong size!
  fi
  # end of 'src/ctrlx.c'
fi
if test -f 'src/derror.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/derror.c'\"
else
  echo shar: Extracting \"'src/derror.c'\" \(1740 characters\)
  sed "s/^X//" >'src/derror.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  dummy_nerror.c					   */
X/*        FUNKTIONEN  nerror						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "defs.h"
X#include "mbox.msg"
X
X/***************************************************************************/
X/*      FUNKTION  nerror()						   */
X/*  BESCHREIBUNG  Zeigt Systemfehler (Dateien koennen nicht gefunden o.    */
X/*		  geoeffnet werden, etc.) an. Anschliessend wie die        */
X/*		  Befehlseingabe aufgerufen.                               */
X/*			                                                   */
X/*		  ACHTUNG: Nach "nerror()" laeuft die MBox zwar weiter,    */
X/*		  aber beim Terminieren wird ein "core" ausgegeben.        */
X/*     PARAMETER  file     = Datei in der der Fehler aufgetreten ist	   */
X/*		  line     = Zeile in der Datei                            */
X/*		  function = Funktion in der Datei                         */
X/*		  descr    = Fehlerbeschreibung	                           */
X/*		  er       = Datei/Variable                                */
X/*     RUECKGABE  keine 						   */
X/***************************************************************************/
X
Xvoid nerror(file, line, function, descr, er)
Xchar file[];
Xint line;
Xchar function[], descr[], er[];
X{
X  char s[80];
X
X  printf("%c%s %s (%s) - %s \"%s\"\n", CR, DER01_MSG, function, file, descr, er);
X
X  sprintf(s, "[%s] %s, %d\n***** %s, %s, %s ... %s !!!",
X	DER02_MSG, file, line, function, descr, er, DER03_MSG);
X  
X}
X
X
END_OF_FILE
  if test 1740 -ne `wc -c <'src/derror.c'`; then
    echo shar: \"'src/derror.c'\" unpacked with wrong size!
  fi
  # end of 'src/derror.c'
fi
if test -f 'src/faces.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/faces.c'\"
else
  echo shar: Extracting \"'src/faces.c'\" \(3548 characters\)
  sed "s/^X//" >'src/faces.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  faces.c						   */
X/*        FUNKTIONEN  faces()						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  08.06.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X/* There were plans to implement the X-Face: Headlines, but the resulting
X   overhead is much to big, to realize it! */
X
X
X#define a1	219
X#define a2	223
X#define a3	220
X#define a4	32
X
X#define b1	'8'
X#define b2	'9'
X#define b3	'6'
X#define b4	32
X
X
Xvoid faces( fname )
Xchar fname[];
X{
X  int x, y;
X  int x1, y1;
X  int Z1, Z2, Z3, Z4;
X  FILE *fp;
X  int c, i;
X  char s[STRING];
X  int tog = 0;
X  char t[STRING];
X
X
X
X  ansi("mr");
X  printf("[Bild des Autors ansehen?] G, A, %c, ? > ", GBL07_MSG);
X  ansi("me");
X  printf("G%c", BS);
X
X  do {
X	c = getint();
X	if (c >= 97) c -= 32;
X	if (c == ENTER) c = 'G';
X	if (c == '?') {
X		clearline();
X		ansi("mr");
X		printf("%c%s > ", CR, "Bild des Autors anzeigen als Grafik, Ascii-Bild oder lieber Nicht ?");
X		ansi("me");
X	}
X	if ((c != 'G') && (c != 'A') && (c != GBL07_MSG)) c = 0;
X  } while (c == 0);
X
X  printf("%c\n\n", c);
X
X  if (c == GBL07_MSG) return;
X
X  if(c == 'G'){
X	Z1 = a1;
X	Z2 = a2;
X	Z3 = a3;
X	Z4 = a4;
X  }
X  if(c == 'A'){
X	Z1 = b1;
X	Z2 = b2;
X	Z3 = b3;
X	Z4 = b4;
X  }
X
X  sprintf(s, "%s/etc/face.put", HOME);
X
X  fp = fopen( s, "r" );
X  
X  x1 = fgetc(fp); c = fgetc(fp);
X  y1 = fgetc(fp); c = fgetc(fp);
X
X  for(y = 0; y < y1; y++){
X	i = 0;
X	for(x = 0; x < x1; x += 8){
X		c = fgetc(fp);
X		if(tog == 0) s[i] = c;
X		else t[i] = c;
X		i++;
X	}
X	tog++;
X	if(tog == 2){
X		tog = 0;
X		i = (int) x/8;
X		for(x = 0; x < i; x ++){
X			if( (s[x] & 128) &&  (t[x] & 128)) printf("%c", Z1);
X			if( (s[x] & 128) && !(t[x] & 128)) printf("%c", Z2);
X			if(!(s[x] & 128) &&  (t[x] & 128)) printf("%c", Z3);
X			if(!(s[x] & 128) && !(t[x] & 128)) printf("%c", Z4);
X
X			if( (s[x] & 64) &&  (t[x] & 64)) printf("%c", Z1);
X			if( (s[x] & 64) && !(t[x] & 64)) printf("%c", Z2);
X			if(!(s[x] & 64) &&  (t[x] & 64)) printf("%c", Z3);
X			if(!(s[x] & 64) && !(t[x] & 64)) printf("%c", Z4);
X
X			if( (s[x] & 32) &&  (t[x] & 32)) printf("%c", Z1);
X			if( (s[x] & 32) && !(t[x] & 32)) printf("%c", Z2);
X			if(!(s[x] & 32) &&  (t[x] & 32)) printf("%c", Z3);
X			if(!(s[x] & 32) && !(t[x] & 32)) printf("%c", Z4);
X
X			if( (s[x] & 16) &&  (t[x] & 16)) printf("%c", Z1);
X			if( (s[x] & 16) && !(t[x] & 16)) printf("%c", Z2);
X			if(!(s[x] & 16) &&  (t[x] & 16)) printf("%c", Z3);
X			if(!(s[x] & 16) && !(t[x] & 16)) printf("%c", Z4);
X
X			if( (s[x] & 8) &&  (t[x] & 8)) printf("%c", Z1);
X			if( (s[x] & 8) && !(t[x] & 8)) printf("%c", Z2);
X			if(!(s[x] & 8) &&  (t[x] & 8)) printf("%c", Z3);
X			if(!(s[x] & 8) && !(t[x] & 8)) printf("%c", Z4);
X
X			if( (s[x] & 4) &&  (t[x] & 4)) printf("%c", Z1);
X			if( (s[x] & 4) && !(t[x] & 4)) printf("%c", Z2);
X			if(!(s[x] & 4) &&  (t[x] & 4)) printf("%c", Z3);
X			if(!(s[x] & 4) && !(t[x] & 4)) printf("%c", Z4);
X
X			if( (s[x] & 2) &&  (t[x] & 2)) printf("%c", Z1);
X			if( (s[x] & 2) && !(t[x] & 2)) printf("%c", Z2);
X			if(!(s[x] & 2) &&  (t[x] & 2)) printf("%c", Z3);
X			if(!(s[x] & 2) && !(t[x] & 2)) printf("%c", Z4);
X
X			if( (s[x] & 1) &&  (t[x] & 1)) printf("%c", Z1);
X			if( (s[x] & 1) && !(t[x] & 1)) printf("%c", Z2);
X			if(!(s[x] & 1) &&  (t[x] & 1)) printf("%c", Z3);
X			if(!(s[x] & 1) && !(t[x] & 1)) printf("%c", Z4);
X		}
X		printf("\n");
X	}
X  }
X  fclose(fp);
X
X  c = getint();
X}
X
X
X
END_OF_FILE
  if test 3548 -ne `wc -c <'src/faces.c'`; then
    echo shar: \"'src/faces.c'\" unpacked with wrong size!
  fi
  # end of 'src/faces.c'
fi
if test -f 'src/games.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/games.c'\"
else
  echo shar: Extracting \"'src/games.c'\" \(1155 characters\)
  sed "s/^X//" >'src/games.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  games.c						   */
X/*        FUNKTIONEN  games()						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  25.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X#include "mbox.h"
X
X
Xgames()
X{
X  FILE *fp;
X  int i, c;
X
X  char s[STRING];
X  char GAME[MAX_GAMES][STRING];
X
X
X  headline( GA01_MSG );
X  printf("\n");
X
X  fp = fopen(GAMES, "r");
X  if (fp == NULL) {
X	nerror("games.c", 19, "games", "Datei-Lesefehler", GAMES);
X  }
X  i = 0;
X  while((fgets(s, 80, fp) != NULL) && (s[0] == '/'));
X  while((i < MAX_GAMES) && (fscanf(fp, "%s %s", s, GAME[i]) > 0)){
X	i++;
X	printf("  %d - %s\n\n", i, s); 
X  }
X  fclose(fp);
X
X  ansi("md");
X  printf("\n%s > ", GA02_MSG);
X  ansi("me");
X
X  c = getint();
X  if(c > 32) printf("%c", c);
X  c -= 49;
X
X  if((c >= 0) && (c < i)){
X	printf("\n\n");
X	sprintf(s, "%s %s %d %d", RSH, GAME[c], OLDUID, OLDGID);
X	system(s);	
X  }
X  else{
X	ansi("md");
X	printf(" %s\n", GA03_MSG);
X	ansi("me");
X  }
X}
X
END_OF_FILE
  if test 1155 -ne `wc -c <'src/games.c'`; then
    echo shar: \"'src/games.c'\" unpacked with wrong size!
  fi
  # end of 'src/games.c'
fi
if test -f 'src/getch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/getch.c'\"
else
  echo shar: Extracting \"'src/getch.c'\" \(1934 characters\)
  sed "s/^X//" >'src/getch.c' <<'END_OF_FILE'
X/*
X *	%Z% %M%	%I% %D% %Q%
X *
X *	Copyright (C) 1990 by Christian Schlichtherle
X *			      (chriss@attron.ruhr.sub.org)
X *
X *	%M% - C module for getch(S).
X *
X *	"getch" is a DOS and curses(S) like function which reads
X *	a character and returns immediately without waiting for
X *	newline.
X *
X * 	getch() - Gets a character.
X * 	This function gets one character and immediately returns
X * 	without waiting for newline. The character is not echoed.
X * 	This function can be used best when you want to input only one
X * 	character within canonical input or if you need this function
X * 	only very rarely.
X * 	EOF is returned on errors or if an ignored signal occured.
X *	
X *	Modificated by andreas@xenox.w.open.de 06/20/92 Xenox
X */
X
X#include "defs.h"
X#include <sys/types.h>
X#include <stdio.h>    
X#include <errno.h>
X#ifndef _SYS7
X#include <sys/ioctl.h>
X#include <termio.h>
X#else
X#include <sgtty.h>
X#endif 
X
X#ifndef _SYS7
Xstatic struct termio	told, tnew;
X
X#define	get_oldmode()	ioctl(0,TCGETA, &told)
X#define	set_oldmode()	ioctl(0,TCSETA, &told)
X#define	set_newmode()	(tnew.c_cc[VMIN] = 1,tnew.c_cc[VTIME] = 0,\
X			 tnew.c_lflag &= ~(ICANON | ECHO),\
X			 ioctl(0, TCSETA, &tnew))
X
X#else
Xstatic struct sgttyb	told, tnew;
X
X#define	get_oldmode()	ioctl(0,TIOCGETP, &told)
X#define	set_oldmode()	ioctl(0,TIOCSETP, &told)
X#define	set_newmode()	(tnew.sg_flags |= RAW,tnew.sg_flags &= ~ECHO,\
X			 ioctl(0, TIOCSETP, &tnew))
X
X#endif
X
Xint	getch()
X{
X	static int	set = 0;
X	int	rstat;
X	char	c;
X
X	if (!set) {
X			/* Get old terminal mode. */
X		if (get_oldmode() == -1)
X			return (EOF);
X
X		tnew = told;
X			/* Don't execute this part anymore. */
X		set = 1;
X	}
X
X		/* Set new terminal mode. */
X	if (set_newmode() == -1)
X		return (EOF);
X
X		/* 
X		 * Read one character. The orginal function used 
X		 * read(0, &c, 1) but getchar is a macro 
X		 * and faster. Xenox Fri Jun 19 20:44:46 DST 1992
X		 */
X	c = getchar();
X
X        set_oldmode();
X
X	return ((int)c);
X}
X
END_OF_FILE
  if test 1934 -ne `wc -c <'src/getch.c'`; then
    echo shar: \"'src/getch.c'\" unpacked with wrong size!
  fi
  # end of 'src/getch.c'
fi
if test -f 'src/help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/help.c'\"
else
  echo shar: Extracting \"'src/help.c'\" \(2401 characters\)
  sed "s/^X//" >'src/help.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  help.c						   */
X/*        FUNKTIONEN  help()						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
X/***************************************************************************/
X/*      FUNKTION  help() 						   */
X/*  BESCHREIBUNG  Der Inhalt der Datei HILFE wird entweder komplett ange-  */
X/*		  zeigt, oder aber in Abhaengigkeit von 'cmd' in Auszuegen */
X/*		  ausgegeben.                                              */
X/*     PARAMETER  cmd  =  '*'      =  HILFE wird komplett ausgegeben       */
X/*                        '='      =  SHORTHELP                            */
X/*		  #Befehl  	   =  HILFE zu "Befehl" wird ausgegeben    */
X/*     RUECKGABE  0  =  Keinen Eintrag gefunden                            */
X/*                n  =  Anzahl der Eintraege				   */
X/***************************************************************************/
X
Xint help(cmd)
Xchar cmd[];
X{
X  FILE *fp;
X  char s[255];
X  int ende = 0, ok = 0, found = 0, toggle = 0, lines = 0;
X
X  show(KURZHILFE, 99, 99); /* RESET */
X  
X  if(cmd[0] == '='){
X	headline( HLP01_MSG );
X	show(KURZHILFE, 9999, USER.more);	
X	return 9999;
X  }
X
X  maybe_locked(HILFE, "r");
X  fp = fopen(HILFE, "r");
X  if (fp == NULL) {
X	nerror("help.c", 14, "help", "Datei-Lesefehler", HILFE);
X  }
X  if (cmd[0] != '#') {
X	ok = 2;
X	found++;
X  }
X  headline( HLP01_MSG );
X  lines = 0;
X
X  while ((fgets(s, 85, fp) != NULL) && !ende) {
X
X	if (USER.more > 0) {
X		if (lines >= MAX_SCR_LINES) {
X			lines = 0;
X			if (more() != 0) return 1;
X		}
X	}
X	if (ok == 2) {
X		if (s[0] != '#') {
X			printf("%s", s);
X			lines++;
X			if (toggle > 0) {
X				ansi("me");
X				toggle = 0;
X			}
X		}
X		else {
X			printf("\n");
X			lines++;
X			ansi("md");
X			toggle++;
X		}
X	}
X	else {
X		if ((ok == 1) && (s[0] == '#')) {
X			ok = 0;
X			printf("\n");
X			lines++;
X		}
X		if ((ok == 1) && (s[0] != '#')) {
X			printf("%s", s);
X			lines++;
X			if (toggle > 0) {
X				ansi("me");
X				toggle == 0;
X			}
X		}
X		if ((ok == 0) && (s[0] == '#')) {
X			if (strcomp(cmd, s) == 0) {
X				ok = 1;
X				found++;
X				ansi("md");
X				toggle++;
X			}
X		}
X	}
X  }
X  fclose(fp);
X
X  return found;
X}
END_OF_FILE
  if test 2401 -ne `wc -c <'src/help.c'`; then
    echo shar: \"'src/help.c'\" unpacked with wrong size!
  fi
  # end of 'src/help.c'
fi
if test -f 'src/nerror.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/nerror.c'\"
else
  echo shar: Extracting \"'src/nerror.c'\" \(1859 characters\)
  sed "s/^X//" >'src/nerror.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  nerror.c						   */
X/*        FUNKTIONEN  nerror						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  16.11.1991					   */
X/***************************************************************************/
X
X#include <stdio.h>
X#include <setjmp.h>
X
X#include "mbox.h"
X
X
Xextern jmp_buf jmpenv;
X
X
X/***************************************************************************/
X/*      FUNKTION  nerror()						   */
X/*  BESCHREIBUNG  Zeigt Systemfehler (Dateien koennen nicht gefunden o.    */
X/*		  geoeffnet werden, etc.) an. Anschliessend wird die       */
X/*		  Befehlseingabe aufgerufen.                               */
X/*			                                                   */
X/*		  ACHTUNG: Nach "nerror()" laeuft die MBox zwar weiter,    */
X/*		  aber beim Terminieren wird ein "core" ausgegeben.        */
X/*     PARAMETER  file     = Datei in der der Fehler aufgetreten ist	   */
X/*		  line     = Zeile in der Datei                            */
X/*		  function = Funktion in der Datei                         */
X/*		  descr    = Fehlerbeschreibung	                           */
X/*		  er       = Datei/Variable                                */
X/*     RUECKGABE  keine 						   */
X/***************************************************************************/
X
Xvoid nerror(file, line, function, descr, er)
Xchar file[];
Xint line;
Xchar function[], descr[], er[];
X{
X  char s[80];
X
X  ansi("md");
X  printf("%c%s ", CR, NER01_MSG);
X  ansi("me");
X
X  printf("%s (%s) - %s \"%s\"\n", function, file, descr, er);
X
X  sprintf(s, "[%s] %s, %d\n***** %s, %s, %s ... %s !!!",
X	NER02_MSG, file, line, function, descr, er, NER03_MSG);
X
X  control(s, 99);
X  control(s, 3);
X
X  longjmp(jmpenv, 1);
X}
X
END_OF_FILE
  if test 1859 -ne `wc -c <'src/nerror.c'`; then
    echo shar: \"'src/nerror.c'\" unpacked with wrong size!
  fi
  # end of 'src/nerror.c'
fi
if test -f 'src/outdial.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/outdial.c'\"
else
  echo shar: Extracting \"'src/outdial.c'\" \(991 characters\)
  sed "s/^X//" >'src/outdial.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  outdial.c						   */
X/*        FUNKTIONEN  outdial()						   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  02.04.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
Xvoid outdial()
X{
X  FILE *fp;
X  
X  char s[STRING];
X  char t[STRING];
X  int a, b;
X
X  
X  fp = fopen( "/tmp/door", "w" );
X  fprintf(fp, "%s\n%s\n%d\n%d\n", 
X	  USER.name, USER.account, USER.id, USER.terminal);
X  fclose(fp);
X
X  printf("\n\n");
X
X  system( "outdial" );
X
X  fp = fopen( "/tmp/acct", "r" );
X  if(fp != NULL){
X     fgets(s, 80, fp);	
X     fclose(fp);
X     unlink( "/tmp/acct" );
X  }
X  strcpy(t, (char *) strcopy(USER.account, 11, 16));
X  a = atoi(t);
X  b = atoi(s);
X  a -= b;
X
X  USER.account[11] = '\0';
X  sprintf(s, "%d", a);
X  strcat(USER.account, s);
X}
X
END_OF_FILE
  if test 991 -ne `wc -c <'src/outdial.c'`; then
    echo shar: \"'src/outdial.c'\" unpacked with wrong size!
  fi
  # end of 'src/outdial.c'
fi
if test -f 'src/weiterl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/weiterl.c'\"
else
  echo shar: Extracting \"'src/weiterl.c'\" \(3587 characters\)
  sed "s/^X//" >'src/weiterl.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  weiterleiten.c					   */
X/*        FUNKTIONEN  weiterleiten(), carboncopy()			   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  05.01.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#include "mbox.h"
X
X
X/***************************************************************************/
X/*      FUNKTION  weiterleiten()					   */
X/*  BESCHREIBUNG  Je nach Parameter wird entweder ein Artikel an einen     */
X/*		  User weitergeleitet, oder aber die letzte PM nochmal     */
X/*		  mit einer anderen Adresse verschickt.                    */
X/*     PARAMETER  arg = Nummer des Artikel, Empfaenger, etc.               */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid weiterleiten( arg )
Xchar arg[];
X{
X  FILE *fp;
X  char s[STRING];
X  char t[STRING];
X  char subject[STRING];
X  int i, a, num;
X  char empf[STRING];
X
X  subject[0] = '\0';
X
X  sprintf(s, "%s/usr/%d/.lastsubject", HOME, USER.id);
X  fp = fopen( s, "r" );
X  if(fp != NULL){
X	fgets(subject, 80, fp);
X	fclose(fp);
X  }
X
X  if((subject[0] == '\0') && ((arg[0] > 64) || (arg[0] == '?'))){
X	ansi("md");
X	printf(" %s\n", WEI01_MSG);
X	ansi("me");
X	return;
X  }
X
X  if(arg[0] == '\0'){
X	printf("\n\n%s\n\n", WEI02_MSG);
X	ansi("md");
X	printf("%s %s\n\n", WEI03_MSG, subject);
X	ansi("me");
X	return;
X  }
X
X  num = 0;
X
X  if(arg[0] < 65){
X	i = 0;
X	while((arg[i] > 32) && (arg[i] != '\0')) i++;
X	strcpy(s, (char *) strcopy(arg, 0, (i-1)));
X	num = atoi(s);
X	strcpy(empf, (char *) strcopy(arg, (i+1), length(arg)));
X	strcat(empf, "$");
X  }
X  else{
X	sprintf(empf, "%s$", arg);
X  }  
X
X  if(num != 0){
X	if(strcomp(BRETT, "PM") != 0){
X		sprintf(t, "%s/%d", BRETT, num);
X		sprintf(s, "cp %s/%d %s/usr/%d/.lastletter", BRETT, num, HOME, USER.id);
X	}
X	else{
X		sprintf(t, "%s/usr/%d/%d", HOME, USER.id, num);
X		sprintf(s, "cp %s/usr/%d/%d %s/usr/%d/.lastletter", HOME, USER.id, num, HOME, USER.id);
X	}
X	fp = fopen( t, "r" );
X	if(fp == NULL){
X		ansi("md");
X		printf(" %s\n", WEI04_MSG);
X		ansi("me");
X	return;
X	}
X	fclose(fp);
X	system(s);
X	sprintf(s, "%s/usr/%d/.lastletter", HOME, USER.id);
X
X	sprintf(s, "%s/usr/%d/.lastsubject", HOME, USER.id);
X	fp = fopen( s, "w" );
X	if(fp == NULL){
X		nerror("weiterl.c", 76, "weiterleiten", "Datei_Schreibfehler", s);
X	}
X	fprintf(fp, "%d <%s>", num, NG);
X	fclose(fp);
X  }
X
X  brief(empf);
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  carboncopy()						   */
X/*  BESCHREIBUNG  Kopien einer MAIL an mehrer Empfaenger versenden	   */
X/*     PARAMETER  cc  = Empfaenger einer Kopie (im Header sichtbar)	   */
X/*		  bcc = Empfaenger einer Kopie (im Header unsichtbar)	   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid carboncopy( cc, bcc )
Xchar cc[], bcc[];
X{
X  char ex[LONGSTRING];
X  char ef[LONGSTRING];
X  char s[STRING];
X
X  int a = 0, i = 0;
X  int ok = 0;
X
X  printf("\n");
X
X  sprintf(ex, "%s,%s ", (char *) stripped(cc), bcc);
X
X  if(ex[0] == '\0') return;
X
X  while(ok == 0){
X	while((ex[i] != ',') && (ex[i] != '\0')) i++;
X
X	if(ex[i] == '\0') ok++;
X
X	strcpy(ef, (char *) bigcopy(ex, a, (i-1)));
X	strcpy(s, (char *) stripped(ef));
X
X	if(strlen(s) > 1){
X		weiterleiten( s );
X	}
X	a = i + 1;
X	i++;
X  }
X  
X}
END_OF_FILE
  if test 3587 -ne `wc -c <'src/weiterl.c'`; then
    echo shar: \"'src/weiterl.c'\" unpacked with wrong size!
  fi
  # end of 'src/weiterl.c'
fi
echo shar: End of archive 10 \(of 11\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
