Newsgroups: comp.sources.misc
From: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Subject:  v31i025:  mbox - A BBS for UNIX and MINIX v1.6 PL10, Part09/11
Message-ID: <1992Jul10.050454.27784@sparky.imd.sterling.com>
X-Md4-Signature: 36fba9a16b021e51687011cc478594cd
Date: Fri, 10 Jul 1992 05:04:54 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Volker.Schuermann@unnet.w.open.de@unnet (Volker Schuermann)
Posting-number: Volume 31, Issue 25
Archive-name: mbox/part09
Environment: MINIX, ISC, ESIX, SVR3
Supersedes: mbox: Volume 29, Issue 63-72

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  Announce10a Installation etc/deutsch.shorth
#   etc/english.shorth src/defs.h src/getline.c src/postfach.c
#   src/proto.h src/suchen.c src/xmd.c
# Wrapped by kent@sparky on Thu Jul  9 23:26:03 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 9 (of 11)."'
if test -f 'Announce10a' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Announce10a'\"
else
  echo shar: Extracting \"'Announce10a'\" \(4767 characters\)
  sed "s/^X//" >'Announce10a' <<'END_OF_FILE'
XAnnouncement for the BBS-package ix/MBox 1.6 PL10a                 14.06.1992
X
X
XThe package includes a BBS for UNIX. The following derivations and compilers
Xhave been tested:
X
X- MINIX 386 (You have to have the 386 version!) with BCC
X
X- MINIX 386 with GCC 1.37 (with or w/o ESTDIO-patches)
X
X- ESIX SVR3 with CC (MSC) or GCC
X
X- ISC 2.21 with "Shared Libs"
X
X- DELL UNIX 2.1 SVR4 with GCC 2.1
X
XIf you don't have one of those systems or anything that's compatible to
Xany of them, you may stop reading now!
X
XNOTE: The 64+64 limitation of Coherent and plain MINIX makes it impossible
X      to run ix/MBox BBS! The BBS itself needs more than 170kB of memory!
X
X
XFor all who are still reading, some other requirements. The ix/MBox uses
Xsome UNIX services to stay compatible to the UNIX world and to make updates
Xmore easy. You need:
X
X- a mailer like SMAIL (RMAIL) or UMAIL 
X
X- a news-package B/C-NEWS (INEWS) or WNEWS
X
X- a uucp-system like HDB, Taylor or MNXUUCP or UUCP1.2
X
X(The packages UMAIL and WNEWS are MINIX stuff by Fred v. Kempen, UUCP1.2
Xis the (best) UUCP-package for MINIX by Will Rose)
X
X
X  
XYou're STILL (!) reading? Ok, now the features of the BBS. If you're missing
Xa feature that is important for you, just talk to me. Maybe I've forgotten
Xto mention it, or I'm able to offer it with the next patchlevel!
X
XThe BBS ...
X
X... uses NEWS to handle all boards/articles. You may use the BBS or your
X    prevered newsreader to maintain the articles.
X
X... uses an internal mailer for mails between BBS-users.
X
X... uses (R/S)MAIL to receive/deliver mails from BBS-users to system-users
X    of the same or foreigen sites and vice versa.
X
X... uses a variable command set. If you don't like the presetted commands,
X    just change the config-file to have your own commands set.
X
X... all commands are fitted out with a user-level and a prototype-flag.
X    You may have several commands with the same function, but only the
X    commands with the prototype-flag set will be shown in the command-
X    survey.
X
X... has "user defined commands". If you like to offer an external newsreader
X    or mailer to your users, you only have to state that in a config-file.
X
X... is able to communicate in various languages. A german and an english
X    language-file are delivered with this package. It takes about two or
X    three hours to build language- and help-files for other countries.
X
X... offers PD-areas like all other boards. The trick is, that the articles
X    in the PD-boards are including a pointer to the real PD-package. You
X    are able to maintain that areas like all other boards. You don't have to
X    copy your PD-directories!
X   
X... uses SX/SZ/SB and RX/RZ/RB as filetransfer protocols. Also ASCII up- 
X    and download are available for text and PD transfer.
X
X... has it's own line-editor (B)LED. Users with higher level may use
X    fullscreen-editors, of course. You only have to put all offered editors
X    in a config-file.
X
X... offers games to the users. Again, there's a config-file, which
X    includes the list of your online-games (rogue/nethack etc.).
X
X... may call a CHAT-program. If you don't have one, please tell me. I've
X    a PD-mutliport-chat program, too. Otherwise you can use TALK or
X    phone as a two-person chat.
X
X... is able to read Bellcore RTF (Richtext Format) and Qouted-Printable.
X
X... creates MIME-Headers. This, and the RTF-feature are the first steps to
X    multimedia-mail. 
X
X... allows to change the headerfield of news-articles and mails. (Depending
X    on userlevel, of course!)
X
X... allows to reedit articles, if you are the autor. If you are the sysop,
X    you may reedit everything ;-)
X
X... is able to generate statistics on calls, downloads, news-articles.
X
X... builds hitlists on calls per user, downloads per file, etc.
X
X... contains a users database with online-maintenance-facility.
X
X... allows users to setup the BBS to hit their preferences. They may
X    choose:
X
X    - TERMINAL      ANSI X3.64, VT100, VT52, Dump (have a look at TERMCAP)
X
X    - EDITOR        LED, VI, EMACS, PED, MINED (or whatever you offer)
X
X    - PROMPT        BOARD, TIME, RATES (with or w/o BELL)
X
X    - OUTPUT        TYPE, MORE, MORE with marks, direction, lines, etc. ...
X
X    - INTRO         INFOTEXT, STATE, both
X       
X    - SCANNER       DATE&TIME, DATE, change scanner date
X
X
X... supports the following commands by default:
X
X    +, -, ACCOUNT, AREA, BOARD, CHAT, DIR, DATE, DELETE, DOWNLOAD, DIRECTION,
X    EDIT, FINGER, FORWARD, GAMES, GOODBYE, HELP, MAIL, MACRO, MESSAGE, MINIX,
X    PORTINFO, PROTOCOL, PM, READ, SETUP, SYSINFO, SIGNATURES, STATE,
X    STATISTICS, SEARCH, TIME, USERS, UPLOAD, VERSION, WRITE
X
X
X
XLet's stop this list here. If you're interested, let me have a mail. I'll
Xsend the package in six UUE-parts (each 60kB) to you.
END_OF_FILE
  if test 4767 -ne `wc -c <'Announce10a'`; then
    echo shar: \"'Announce10a'\" unpacked with wrong size!
  fi
  # end of 'Announce10a'
fi
if test -f 'Installation' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Installation'\"
else
  echo shar: Extracting \"'Installation'\" \(4213 characters\)
  sed "s/^X//" >'Installation' <<'END_OF_FILE'
X
X
X
X
X
X
X
X			
X
X		         ix/MBox  R E A D M E
X		  Mailbox-Programm fuer UNIX(-Derivate)
X			
X			   Volker Schuermann
X		      Wuppertal, FRG, 07.12.1991
X
X
X
X
X
X
X
X
X
X
XFolgendes wird jetzt als bereits geschehen (!) vorausgesetzt:
X
X1. Wir befinden uns im zukuenftigen "Mailbox-HOME"-Verzeichnis (~HOME)
X
X2. Wir haben "root.root"-Permissions (sprich sind als "root" aktiv)
X
X3. Wir haben das Archiv "mbox.tar.Z" komplett ausgepackt und in etwa
X   diese Verzeichnisse/Dateien erhalten:
X
X   ./TUTORIAL
X   ./README
X
X   ./src/*.c
X   ./src/*.h
X   ./src/Makefile
X   ./src/CROSSREF
X
X   ./etc/active
X   .  
X   .  
X   .
X   ./etc/users.data
X
X
X   Das heisst "src" und "etc" sind Unterverzeichnisse von (~HOME) und
X   "TUTORIAL" etc. befinden sich in (~HOME). Sollte das nicht der Fall
X   sein, muessen wir diese Stuktur im (~HOME) entweder von Hand
X   herstellen, oder das Archiv "mbox.tar.Z" nochmal an entsprechender
X   Stelle auspacken!
X
X
X
XWir wechseln jetzt ins "./src"-Verzeichnis, um die MBox an ihre neue
XUmgebung anzupassen. Zwei Dateien muessen bearbeitet werden:
X
X1. Das "Makefile", das einige Informationen zum verwendeten Betriebs-
X   system erhalten muss. Es sollte genuegen die entsprechenden 
X   Eintraege durch Entfernen des "#" in der ersten Spalte zu aktivieren
X   bzw. durch Voranstellen eines "#" auszukommentieren.
X
X   Die Variablen OWNER und GROUP muessen auf Werte gesetzt werden, die
X   z.B. denen von "/bin/su" entsprechen - OWNER.GROUP muss Zugriff auf
X   alle NEWS-, MAIL- und UUCP-Dateien/Verzeichnisse haben ... maximale
X   Prioritaet ist also Voraussetzung!
X
X   Wenn SETUID "root" fuer die MBox NICHT gewuenscht wird, haben wir
X   viel, viel Arbeit vor uns. Offiziell MUSS die MBox mit SETUID
X   "root" gefahren werden !
X
X
X
X2. Das Definitions-File "mbox.h", in dem alle system-spezifischen
X   Informationen gespeichert werden. Alle Eintraege, deren Kommentar
X   mit einem ">" beginnt, muessen geprueft bzw. geaendert werden -
X   bei allen anderen ist Vorsicht angebracht!
X
X   Es empfielt sich von "mbox.h" eine Kopie anzufertigen, um bei evtl.
X   Fehlschlaegen das Original zu Rate ziehen zu koennen!
X   
X
X
XJetzt kommen wir zum spannenden Teil der Aktion. Wir starten "make"
Xund hoffen (den ueblichen Zauber lassen wir mal weg, denn Aberglaube
Xist ganz, ganz schlecht - bringt Unglueck :-)
X
XWenn wir nicht allzuviel falsch gemacht haben bei der Anpassung der
Xbeiden Dateien, sollte sich das "Makefile" irgendwann kommentarlos
Xverabschieden und uns mit einem Schwung neuer Programme in $(BIN) 
Xzuruecklassen:
X
X$(BIN)/mbox		die Mailbox 
X$(BIN)/mb-daemon        ein Daemon der INDEX-Dateien aus NEWS bildet
X$(BIN)/xmd              ein Programm das Post an Mailbox-User zustellt
X$(BIN)/bled             ein "anstaendiger" Zeileneditor
X
Xmbrsh                   eine neue SHELL, die von der Mailbox genutzt wird
X
XSollten diese Programme nicht vorhanden sein, geht's zurueck an den Start.
XEntweder haben wir uns einen "Make error" eingefangen (dann muessen wir
Xuns "Makefile" nochmal vornehmen), oder wir haben in "mbox.h" einen dieser
Xklassischen Syntax-Fehler fabriziert ... viel Spass beim Suchen!
X
X
XSo, wenn wir hier angekommen sind, sollten wir uns ein paar Stunden Pause
Xgoennen, denn jetzt kommt Arbeit auf uns zu. Herumexperimentieren wuerde
Xuns nicht weit bringen, wir sollten in aller Ruhe das "TUTORIAL" lesen
Xund versuchen die dort beschrieben Dateien anzupassen ...
X
XTrotzdem duerfen wir uns schonmal auf die Schulter klopfen, die erste
XHuerde ist genommen!
X
XMfG Volker
X
X
X
XNachschlag: Die MINIX-Mailbox kommt mit der Version "rz 2.30" von Chuck
XForsbergs RZ/SZ nicht klar. Auch wenn's uns nicht gefaellt, in diesem
Xspeziellen Fall kommen wir um einen kleinen Patch nicht herum:
X
X1. Wir kopieren "rz.cdiff" nach "/usr/src/commands/zmodem"
X
X2. Wir wechseln ins "/usr/src/commands/zmodem"-Verzeichnis
X
X3. Mit dem Befehl "patch -cf rz.c rz.cdiff" bringen wir den Patch an
X
X4. Um sicher zu gehen kopieren wir wie folgt: "mv rz.c rz.c.old" und
X   "mv rz.c~ rc.c"
X
X5. Ein "make" sorgt dafuer, dass die neue RZ/SZ-Version erstellt wird.
X   Da RB/SB und RX/RX Links auf RZ/SZ sind, muessen diese Protokolle
X   nicht gesondert behandelt werden.
X
XVORSICHT: Das gilt ausschliesslich fuer die Version "rz 2.30" !
END_OF_FILE
  if test 4213 -ne `wc -c <'Installation'`; then
    echo shar: \"'Installation'\" unpacked with wrong size!
  fi
  # end of 'Installation'
fi
if test -f 'etc/deutsch.shorth' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/deutsch.shorth'\"
else
  echo shar: Extracting \"'etc/deutsch.shorth'\" \(4720 characters\)
  sed "s/^X//" >'etc/deutsch.shorth' <<'END_OF_FILE'
X?                          Befehlsuebersicht (levelabhaengig)
X? *                        Befehlsuebersicht (alle Befehle)
XBefehl ?                   Informationen zu "Befehl"
X
X0                          Inhalt des Befehlspuffers
X1-9                        Befehl aus dem Puffer abrufen
X
X+                          Wechseln ins naechste Brett mit neuen Artikeln
X
X-                          Wechseln ins vorherige Brett mit neuen Artikeln
X
XANRUFER                    Anruferprotokoll
XANRUFER *                  Anruferprotokoll (komplett)
XANRUFER #                  Statistik der Anrufe
XANRUFER %                  Statistik der Anrufer (Hitliste)
X
XANSAGE                     Mitteilungstext anzeigen/aendern
X
XBRETT                      Bretter mit aktuellen Artikeln anzeigen
XBRETT *                    Alle Bretter anzeigen (levelabhaengig)
XBRETT **                   ALLE Bretter anzeigen             	
XBRETT +                    Wechseln ins naechste Brett
XBRETT -                    Wechseln ins vorherige Brett
XBRETT !                    Aktuellen Brettnamen ausgeben
XBRETT #                    Gruppen (Areas) ausgeben
XBRETT ..		   Innerhalb einer Gruppe ins vorherige Brett wechseln
XBRETT Brettname            Ins Brett "Brettname" wechseln
X
XBRIEF User                 Persoenliche Nachricht an "User" senden
XBRIEF Host!User            Persoenliche Nachricht an "User" auf "Host"
X
XCHAT                       Multiport Chatsystem
X
XDOWNLOAD                   Diese Funktion erlaubt es, Artikel und Programme
X                           unter Protokoll-Kontrollen zu empfangen
X
XEDIT Artikel               Der Artikel mit der Nummer "Artikel" kann
X                           nachtraeglich editiert werden 
X
XENDE			   Mailbox verlassen
XENDE *                     Mailbox verlassen (Scanner nicht aktuallisieren)
X
XGRUPPE +                   Zur nexten Gruppe einer Untergruppe
XGRUPPE ++                  Zur nexten Gruppe
XGRUPPE -                   Zur vorherigen Gruppe einer Untergruppe
XGRUPPE --                  Zur vorherigen Gruppe
X
XHILFE                      Diese Kurzhilfe anzeigen
XHILFE *                    Hilfstexte komplett ausgeben
XHILFE Befehl               Hilfstext zum Befehl "Befehl" zeigen
X
XINHALT                     Index der aktuellen Artikel ausgeben
XINHALT *                   Alle Artikel eines Brettes anzeigen
X
XLESEN                      Neue Artikel listen
XLESEN *                    Alle Artikel listen
XLESEN Artikel              Artikel mit der Nummer "Artikel" ausgeben
XLESEN Artikel-Artikel      Artikel von Nummer "Artikel" bis "Artikel" zeigen
X
XLOESCHEN Artikel           Artikel Nummer "Artikel" loeschen
XLOESCHEN Artikel-Artikel   Loeschen von "Artikel" bis "Artikel"
X
XMAKRO                      Makrovereinbarungen zeigen/aendern
X
XMINIX Shell-Befehl         Externes Kommando "Shell-Befehl" ausfuehren
X
XOUTDIAL                    Verbindung zu externen Hosts via Datex-P
X
XPM                         Ins persoenliche Verzeichnis wechseln
X
XPORTINFO                   Aktivitaeten der verschiedenen Terminals zeigen
X
XPOSTFACH                   Postfach einrichten
X
XRICHTUNG                   Leserichtung (alt <-> neu) aendern
X
XSCHREIBEN                  Artikel erfassen und speichern
X
XSETUP                      Persoenliche Anpassungen
X
XSPIELE			   Verschiedene Spiele werden aufgelistet/aufgerufen
X
XSTATUS                     Ausgabe der eigenen Anpassungen
X
XSTATISTIK                  Datei-Statistik der versch. Bretter anzeigen
XSTATISTIK *                Statistik komplett ausgeben
XSTATISTIK $                Uebersicht der UUCP-Gebuehren 
XSTATISTIK #                Protokoll der Downloads (PD-Bretter)
XSTATISTIK %                Protokoll der Downloads (HITLISTE)
X
XSUCHEN Muster              Artikel eines Brettes nach "Muster" durchsuchen	
X
XSYSINFO                    Allgemeine Informationen zur Mailbox
X
XUNTERSCHRIFT               Unterschrift anzeigen/aendern
X
XUPLOAD                     Diese Funktion wird ueber den Befehl SCHREIBEN
X                           automatisch aufgerufen
X
XUSER                       Userliste ausgeben
XUSER *                     Userliste mit erweiteren Informationen
XUSER #                     Userliste mit Up-/Download Verhaeltnis
XUSER %                     Userliste zur Gebuehrenabrechnung
XUSER Name                  Informationen ueber den Teilnehmern "Name"
X
XVERSION                    Versionsnummer ausgeben
XVERSION *                  Versionsnummer und Definitionen ausgeben
XVERSION #                  Versionsnummer und "Hall of Fame" ausgeben
X
XWEITERLEITEN               Weiterleitbare PMs anzeigen
XWEITERLEITEN User          Weiterleitbare PM an "User" senden
XWEITERLEITEN Artikel User  Artikel Nummer "Artikel" an "User" senden
END_OF_FILE
  if test 4720 -ne `wc -c <'etc/deutsch.shorth'`; then
    echo shar: \"'etc/deutsch.shorth'\" unpacked with wrong size!
  fi
  # end of 'etc/deutsch.shorth'
fi
if test -f 'etc/english.shorth' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'etc/english.shorth'\"
else
  echo shar: Extracting \"'etc/english.shorth'\" \(4190 characters\)
  sed "s/^X//" >'etc/english.shorth' <<'END_OF_FILE'
X?                          reachable commands are shown 
X? *                        all commands are shown
Xcommand ?                  help on "command"
X
X0                          list command-buffers contents
X1-9                        execute one of nine buffered commands 
X
X+                          go to the next board/group with NEW articles
X
X-                          go to the previous board/group with NEW articles
X
XACCOUNT			   establish an account & a maildrop for a new user
X
XAREA +                     go to the next group of a subgroup
XAREA ++                    go to the next group
XAREA -                     go to a previous group of a subgroup
XAREA --                    go to a previous group
X
XBOARD                      list boards with new articles
XBOARD *                    list all boards depending on userlevel
XBOARD **                   list ALL boards
XBOARD +                    go to the next board
XBOARD -                    go to the previous board
XBOARD !                    display the name of the current board
XBOARD #                    list areas in board
XBOARD ..		   step from one area to the previous one
XBOARD boardname            jump to board "boardname"
X
XCHAT                       multiport chatsystem
X
XDATE			   display current date
X
XDELETE			   delete all your mail
XDELETE article		   delete article no. "article"
XDELETE article-article	   delete from "article" to "article"
X
XDIR                        index new articles
XDIR *                      index ALL articles (of a board)
X
XDIRECTION                  reading direction OLD <> NEW ?
X
XDOWNLOAD                   receive a couple of articles under X-, Y-, Z-
X                           or NONE-protocol 
X
XEDIT article               re-edit article no. "article"
X
XFINGER name                list infos about user "name"
X
XFORWARD                    list stored mails
XFORWARD user               forward a stored mail to "user"
XFORWARD article user       forward "article" to "user"
X
XGAMES			   offer a (list of) game(s)
X
XGOODBYE			   leave the BBS 
X
XHELP                       this shorthelp
XHELP *                     display some pages of helpful descriptions
XHELP command               show information on "command"
X
XMAIL user                  send mail to "user" 
XMAIL host!user             send mail to "user" on system "host"
XMAIL user@host.domain      send mail to "user" on system "host.domain"
X
XMACRO			   display/declare macros
X
XMESSAGE                    show/change "hello" message
X
XMINIX OS-command           execute "OS-command" on MINIX-shell
X
XPORTINFO                   list all terminals, users, activities
X
XPROTOCOL                   protocol of all call(s/ers)
XPROTOCOL *                 protocol (complete)
XPROTOCOL #                 statistics of these calls
XPROTOCOL %                 callers statistics (hitlist)
X
XPM                         move to your maildrop
X
XREAD                       read NEW articles
XREAD *                     real ALL articles (of a board)
XREAD article               show article no. "article"
XREAD article-article       display from "article" to "article"
X
XSEARCH pattern             search for "pattern" in all articles of a group
X
XSETUP                      configure the BBS to your favor
X
XSIGNATURE		   show/change your signature
X
XSTATE                      list your BBS-configuration
X
XSTATISTICS                 table containing NEWS-statistics
XSTATISTICS *               table containing more NEWS-statistics
XSTATISTICS $               UUCP-rates (only if UUCP supports this)
XSTATISTICS #               download-statistics 
XSTATISTICS %               download-statistics (hitlist)
X
XTIME                       local time and your online-time in seconds
X
XUSERS                      show users list
XUSERS *                    show users list (more detailed)
XUSERS #                    users up-/download ratio
XUSERS %                    accounting information (payload ;-)
XUSERS name                 list infos about user "name"
X
XVERSION                    print version
XVERSION *                  display compiling definitions
XVERSION #                  the "Hall of Fame"
X
XWRITE                      create a new article and post it 
END_OF_FILE
  if test 4190 -ne `wc -c <'etc/english.shorth'`; then
    echo shar: \"'etc/english.shorth'\" unpacked with wrong size!
  fi
  # end of 'etc/english.shorth'
fi
if test -f 'src/defs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/defs.h'\"
else
  echo shar: Extracting \"'src/defs.h'\" \(3235 characters\)
  sed "s/^X//" >'src/defs.h' <<'END_OF_FILE'
X/***************************************************************************/
X/* Was jetzt folgt, ist fuer Experimente voellig ungeeignet. Jegliche Aen- */
X/* derung bringt ueber kurz oder lang ernste Probleme fuer die Konsistenz  */
X/* der ix/MBox.						 	           */
X/*									   */
X/* Auch wenn Aenderungen (zufaellig) erfolgreich sein sollten, duerfen sie */
X/* nicht an dritte weitergeleitet werden.				   */
X/*									   */
X/* Wer globale Variablen/Strukturen nicht akzeptiert, sollte jetzt auf der */
X/* Stelle diese Datei verlassen !					   */
X/***************************************************************************/
X
X  
X#ifndef EXTERN
X#define EXTERN extern
X#endif
X
X/* --------------------------- HAENDE WEG !!! ---------------------------- */
X
X#include "proto.h"
X
X#define STRING	     81
X#define LSTRING	     STRING + 4
X#define LONGSTRING  256
X#define BS            8
X#define CR           13
X#define LF           10
X#define TAB           9
X#define BELL          7
X#define DEL         127
X#define CTRL_X	     24
X#define CTRL_Z       26
X#define CTRL_D        4
X#define ESC          27
X
X#if defined( _SYS7) || defined(_SCO)
X#define ENTER        13
X#else
X#define ENTER        10
X#endif
X
X
X#define fix( II )  ( II / 100 )
X#define flt( II )  ( II - (fix( II ) * 100 ))
X
X#define MAKRO_MAX_REK 30
X
X#define DEF_MAX_SCR_LINES 23
X
XEXTERN int MAX_SCR_LINES;
X
XEXTERN int OLDUID;
XEXTERN int OLDGID;
X
XEXTERN char PROMPT[STRING];
XEXTERN char TERMINAL[STRING];
X
XEXTERN char EDDY[STRING];
X
XEXTERN char BRETT[STRING];
XEXTERN char INHALT[STRING];
XEXTERN char NG[STRING];
X
XEXTERN char UGROUPS[STRING];
XEXTERN char MAKRO[STRING];
X
XEXTERN char MYNAME[STRING];
X
XEXTERN long LASTLOG;
XEXTERN int LASTTIME;
X
XEXTERN int IS_BUFFERED;
X
XEXTERN int SHORT_HEADER;
X
XEXTERN long IDX_SIZE;
X
XEXTERN struct userdaten {
X	int id;
X	char name[31];
X	char passwort[11];
X	char sh_name[15];
X	char nick[31];
X	char wohnort[31];
X	char strasse[31];
X	char telefon1[31];
X	char telefon2[31];
X	char geburtsdatum[31];
X        int terminal;
X	int editor;
X	int level;
X        int bell;
X	int prompt;
X	int more;
X	char lastlog[11]; 
X	int seq;
X        int intro;
X	int lasttime;
X 	int lastmode;
X	int leserichtung;
X	int tlines;
X	long upratio;
X	long downratio;
X	long elapsed;
X	char newsgrps[STRING];
X	char schluessel[STRING];
X	char abused[STRING];
X	char account[STRING]; 		
X} USER;
X
X
X
X#define MAX_BEF 80
X
XEXTERN struct bef_struct {
X	int id;
X	int in;
X 	int ex;
X	int prototyp;
X	char befehl[(STRING/2)];
X	char pfad[STRING];
X} BEF[MAX_BEF];
X
X
X#define MAX_MAK 30
X
XEXTERN struct mak_struct {
X	char makname[STRING];
X	char makwert[(STRING * 2)];
X} MAK[MAX_MAK];
X
X
X
X#define MAX_NEWSGRPS 20
X
XEXTERN char newsgrp[MAX_NEWSGRPS][(STRING/3)];
XEXTERN int newsgrpptr;
X
XEXTERN int MAILOUT_LEV;
XEXTERN int ADMIN_LEV;
XEXTERN int WRITE_EX_LEV;
XEXTERN int WRITE_IN_LEV;
XEXTERN int WRITE_INTERNAT;
XEXTERN int PD_D_LEV;
XEXTERN int PD_U_LEV;
XEXTERN int EXE_LEV; 
XEXTERN int GUEST_LEV;
X
XEXTERN char CONSOLE_REDIRECT[STRING];
X
XEXTERN int BB1;
XEXTERN int BB2;
XEXTERN int BB3;
XEXTERN int BB4;
XEXTERN int BB5;
XEXTERN int BB6;
XEXTERN int BB7;
XEXTERN int BB8;
XEXTERN int BB9;
X
XEXTERN char UUCPID[STRING];
X
XEXTERN int BAUDRATE;
X
X
X/* --------------------------- HAENDE WEG !!! ---------------------------- */
X
X
X
X
X
X
X
X
END_OF_FILE
  if test 3235 -ne `wc -c <'src/defs.h'`; then
    echo shar: \"'src/defs.h'\" unpacked with wrong size!
  fi
  # end of 'src/defs.h'
fi
if test -f 'src/getline.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/getline.c'\"
else
  echo shar: Extracting \"'src/getline.c'\" \(6790 characters\)
  sed "s/^X//" >'src/getline.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  getline.c						   */
X/*        FUNKTIONEN  getline(), getint(), yesno()			   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG   09.02.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X
X#ifdef _MBOX
X#include "mbox.h"
X#else
X#define BS		8
X#define CR		13
X#define LF		10
X#define CTRL_X		24
X#define CTRL_D		4
X#define BELL		7
X#define ESC		27
X#define DEL		127
X#define GBL06_MSG	'J' 	
X#define GBL07_MSG	'N'	
X#ifdef _SYS7
X#define ENTER		13
X#else
X#define ENTER	 	10
X#endif
X#endif
X
X#ifndef STRING
X#define STRING 85
X#endif
X
X/***************************************************************************/
X/*      FUNKTION  getline()						   */
X/*  BESCHREIBUNG  Eine Zeile (STRING) einlesen. Beendet wird mit ENTER,	   */
X/*		  oder wenn die max. zulaessige Anzahl von Zeichen er-     */
X/*		  reicht ist.	                                           */
X/*     PARAMETER  siehe unten                                              */
X/*     RUECKGABE  Eingelesene Zeile (STRING)				   */
X/*  ---------------------------------------------------------------------  */
X/*  len     -> Anzahl der max. einzulesenden Zeichen     		   */
X/*									   */
X/*  mode    ->       0 = Kein Echo					   */
X/*	   	     1 = Mit Echo				           */
X/*       	     2 = '*' als Echo				           */
X/*		     3 = ':' als drittes & sechstes Zeichen (Uhrzeit)      */
X/*	             4 = '.' als drittes & sechstes Zeichen (Datum)        */
X/*	 	     5 = Ausschliesslich BUCHSTABEN			   */
X/*		    10 = "bsc" vor der Eingabe "len"-mal ausgeben          */
X/*		   100 = nur Zahlen (und '.', ':')                         */
X/*	 	  1000 = String "deftext" + "bsc" ausgeben                 */
X/*		 10000 = bei "0-9" als erstes Zeichen -> sofort zurueck    */
X/*								           */
X/*  bsc     -> Mit diesem Zeichen wird geloescht			   */
X/*								           */
X/*  deftext -> Text-Vorgabe                                                */
X/*			                                                   */
X/***************************************************************************/
X
Xstatic int endless;
X
Xchar *getline(len, mode, bsc, deftext)
Xint len, mode;
Xchar bsc;
Xchar deftext[];
X{
X  static char gls[STRING];
X  char c;
X  int gli, gll;
X  char delim = '\0';
X  int matrix = 0;
X  int echo = 1, numerics = 0, defmode = 0, letters = 0;
X  int escape = 0;
X  int lenmem = len;
X  int lastwasblank = 0;
X
X
X  if (mode > 10000) {
X	escape++;
X	mode -= 10000;
X  }
X  if (mode > 1000) {
X	mode -= 1000;
X	defmode++;
X  }
X  if (mode > 100) {
X	mode -= 100;
X	numerics++;
X  }
X  if (mode > 10) {
X	mode -= 10;
X	matrix++;
X  }
X  if (mode > 2) {
X	switch(mode){
X		case 3	: delim = ':';
X			  break;
X		case 4  : delim = '.';		
X			  break;
X	 	case 5  : letters++;
X			  break;
X	}
X	mode = 1;
X  }
X  echo = mode;
X
X  if (defmode != 0) {
X	if((deftext[0] < 32) || (deftext[0] > 126)) deftext[0] = '\0';
X	gll = length(deftext);
X	lenmem = len - gll;
X	if(deftext[0] != '\0'){
X		sprintf(gls, "%s", deftext);
X		printf("%s", deftext);
X	}
X	else gls[0] = '\0';
X  }
X  else {
X	gll = 0;
X	gls[gll] = '\0';
X	strcat(gls, "OOPS");
X  }
X
X  if (matrix != 0) {
X	for (gli = 0; gli < lenmem; gli++) {
X		if (((gli == 2) || (gli == 5)) && (delim != '\0') && (gli != len)) {
X			printf("%c", delim);
X		}
X		else {
X			printf("%c", bsc);
X		}
X	}
X	for (gli = 0; gli < lenmem; gli++) printf("%c", BS);
X  }
X
X  do {
X
X	if (delim != '\0') {
X		if (((gll == 2) || (gll == 5)) && (gll < len)){
X			c = delim;
X		}
X		else {
X			c = getint();  
X		}
X	}
X	else {
X		c = getint();  
X	}        
X	if (c > 127) c -= 128;	/* 7 BIT !! */
X
X	if (c == ESC) {
X		c = getint();  
X		c = getint();  
X		if ((c == 'A') || (c == 'B')) {
X			if (c == 'A') endless++;
X			if (c == 'B') endless--;
X			if (endless < 1) endless = 9;
X			if (endless > 9) endless = 1;
X			sprintf(gls, "%d", endless);
X			return (char *) gls;
X		}
X		if (c == 'D') c = BS;
X		if (c == 'C') c = ENTER;
X	}
X	if ((c == CTRL_X) || (c == CTRL_D) || (c == DEL)) {
X		return("<BREAK>");
X	}
X	if (c != ENTER) {
X		if ((c == BS) && (gll > 0)) {
X			if (((gll == 3) || (gll == 6)) && (delim != '\0')) {
X				gll -= 2;
X				printf("%c%c%c%c", BS, BS, bsc, BS);
X			} else {
X				gll--;
X				printf("%c%c%c", BS, bsc, BS);
X			}
X		}
X		if (numerics == 0) {
X			if (c >= 32) {
X				if(letters != 0){
X					if((c < 'A') && (c != ' ')) c = 0;
X					if(c > 'z') c = 0;
X					if((c > 'Z') && (c < 'a')) c = 0;
X
X					if(c == ' '){
X						if(lastwasblank != 0) c = 0;
X						lastwasblank++;
X					}
X					else{
X						if(c != 0) lastwasblank = 0;
X					}				
X
X					/*
X					if((c == 0) && (USER.bell == 1))
X						printf("%c", BELL);
X					*/
X					if(c == 0)
X						printf("%c", BELL);
X				}
X				if(c != 0){
X					gls[gll] = c;
X					gll++;
X				}
X			}
X			else {
X				c = 0;
X			}
X		}
X		else {
X			if ((c == '.') || (c == ':') || ((c >= '0') && (c <= '9'))) {
X				if (((delim != '\0') && ((c == '.') || (c == ':'))) &&
X				    ((gll != 2) && (gll != 5))) {
X					printf("%c", BELL);
X					c = 0;
X				}
X				else {
X					gls[gll] = c;
X					gll++;
X					gls[gll] = '\0';
X				}
X			}
X			else {
X				if (c != BS) printf("%c", BELL);
X				c = 0;
X			}
X		}
X		if (c != 0) {
X			if (echo == 1) printf("%c", c);
X			if (echo == 2) printf("*");
X		}
X	}
X	if (gll == 1) {
X		if ((escape != 0) && ((c > 47) && (c < 58))) {
X			gls[gll] = '\0';
X			return (char *) gls;
X		}
X	}
X
X  } while ((c != ENTER) && (gll < len));
X
X  gls[gll] = '\0';
X
X  return (char *) gls;
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  getint() 						   */
X/*  BESCHREIBUNG  Ein Zeichen wird mit Hilfe der "getch"-Funktion einge-   */
X/*		  lesen. Es wird gewartet bis ein Zeichen erfasst ist.     */
X/*     PARAMETER  keine                                                    */
X/*     RUECKGABE  Eingelesenes Zeichen (INT)				   */
X/***************************************************************************/
X
Xint getint()
X{
X  int c;
X
X  do{
X	c = (int)getch();
X  }while((c == 0) || (c > 127));
X
X  return (int) c;
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  yesno()						   */
X/*  BESCHREIBUNG  Die Zeichen "j", "J", "n" oder "N" werden ausschliess-   */
X/*		  lich eingelesen und zurueckgegeben.	                   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  Eines der Zeichen (siehe oben) (INT)			   */
X/***************************************************************************/
X
Xint yesno()
X{
X  int c;
X
X  do {
X	c = getint();
X	if (c >= 97) c -= 32;
X	if ((c != GBL06_MSG) && (c != GBL07_MSG)) c = 0;
X  } while (c == 0);
X
X  printf("%c", c);
X
X  return (int) c;
X}
X
X
END_OF_FILE
  if test 6790 -ne `wc -c <'src/getline.c'`; then
    echo shar: \"'src/getline.c'\" unpacked with wrong size!
  fi
  # end of 'src/getline.c'
fi
if test -f 'src/postfach.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/postfach.c'\"
else
  echo shar: Extracting \"'src/postfach.c'\" \(8515 characters\)
  sed "s/^X//" >'src/postfach.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  postfach.c					   */
X/*        FUNKTIONEN  postfach()					   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  18.03.1991					   */
X/***************************************************************************/
X  
X#include <stdio.h>
X#include <sys/types.h>
X#include <fcntl.h>
X#include <unistd.h>
X#include <ctype.h>
X
X#include "mbox.h"
X
X
X
X/***************************************************************************/
X/*      FUNKTION  postfach()						   */
X/*  BESCHREIBUNG  Postfach und versch. Dateien fuer einen neuen Teil-      */
X/*		  nehmer einrichten.                                       */
X/*     PARAMETER  arg  =  '*'  =  normaler Aufruf, wird geprueft	   */
X/*			       =  Aufruf von ADMIN                         */
X/*		       =  '#'  =  Neuinstallation der UDBASE		   */
X/*     RUECKGABE  keine	                                                   */
X/***************************************************************************/
X
Xvoid postfach(arg)
Xchar arg[];
X{
X  int fd;
X  FILE *fp;
X  char s[STRING*2];
X  char t[STRING*2];
X  struct userdaten LOOSER;
X  struct userdaten POSTER;
X  int ok, i, j, c;
X  long ll;
X
X
X  if (arg[0] == '*') {
X	if ((strcomp(GUEST, USER.name) != 0) &&
X	    (strcomp(POSTMASTER, USER.sh_name) != 0)) {
X		ansi("md");
X		printf(" %s\n", POS01_MSG);
X		ansi("me");
X		return;
X	}
X  }
X  
X  if (arg[0] == '#') {
X
X	if (arg[1] == '1') { /* ADMINISTRATION */
X
X		strcpy(USER.name, "Administration");
X		strcpy(USER.sh_name, POSTMASTER);
X		strcpy(USER.nick, "Sysop");
X
X		USER.id = 1;
X		USER.level = 10;
X
X		printf("%s - %s (%s)\n", POS04_MSG, USER.name, USER.sh_name);
X
X		fp = fopen(UDSEQ, "w");
X		if (fp == NULL) {
X			nerror("postfach.c", 63, "postfach", "Datei-Schreibfehler", UDSEQ);
X		}
X		fputs("1", fp);
X		fclose(fp);
X		
X		fp = fopen(UDBASE, "w");
X		fclose(fp);
X	}	 
X	if (arg[1] == '2') { /* GUEST */
X	
X		strcpy(USER.name, GUEST);
X		strcpy(USER.sh_name, GBL10_MSG);
X		strcpy(USER.nick, POS03_MSG);
X
X		USER.id = 2;
X		USER.level = 0;
X	
X		printf("%s - %s (%s)\n", POS05_MSG, USER.name, USER.sh_name);
X	}
X
X	strcpy(USER.passwort, "*****");
X	strcpy(USER.wohnort, "");
X	strcpy(USER.strasse, "???");
X	strcpy(USER.telefon1, "???");
X	strcpy(USER.telefon2, "???");
X	strcpy(USER.geburtsdatum, "00.00.0000");
X	strcpy(USER.account, "00.00.0000 000.00");
X
X	goto INIT_UDBASE;
X  }
X
X  maybe_locked(UDBASE, "r"); 
X  fd = open(UDBASE, O_RDONLY);
X  if (fd == -1) {
X	nerror("postfach.c", 51, "postfach", "Datei-Lesefehler", UDBASE);
X  }
X  headline( POS06_MSG );
X  ansi("md");
X  printf("\n%s\n%s\n%s\n\n", POS07_MSG, POS08_MSG, POS09_MSG);
X  ansi("me");
X
X  RETRY_1:
X
X  printf("\n%s ", POS10_MSG);
X  strcpy(s, POSTER.name);
X  strcpy(POSTER.name, (char *) getline(30, 15, '.', ""));
X  if ((strcomp("<BREAK>", POSTER.name) == 0) || (POSTER.name[0] < 64) || (POSTER.name[1] < 64)) {
X	strcpy(POSTER.name, s);
X	printf("\n\n");
X	ansi("md");
X	printf("%s", POS11_MSG);
X	ansi("me");
X	printf("\n");
X	return;
X  }
X  ansi("md");
X  printf("\n%s", POS12_MSG);
X  ok = 0;
X  strcpy(POSTER.name, (char *) stripped(POSTER.name));
X  lseek(fd, 0L, SEEK_SET);
X  while ((read(fd, &LOOSER, sizeof(LOOSER)) == sizeof(LOOSER)) && (ok == 0)) {
X	if (strcomp(POSTER.name, LOOSER.name)    == 0) ok = 1;
X	if (strcomp(POSTER.name, LOOSER.nick)    == 0) ok = 1;
X	if (strcomp(POSTER.name, LOOSER.sh_name) == 0) ok = 1;
X  }
X
X  if (USER.level < ADMIN_LEV){
X	  if ((strcomp("SYSOP", POSTER.name) == 0) ||
X	      (strcomp("POST",  POSTER.name) == 0) ||
X	      (strcomp("GAST",  POSTER.name) == 0) ||
X	      (strcomp("ADMIN", POSTER.name) == 0) ||
X	      (strcomp("COSYS", POSTER.name) == 0)) ok = 1;
X  }
X
X  if (ok == 1) {
X	printf(" %s\n", POS13_MSG);
X	ansi("me");
X	sprintf(POSTER.name, "%s", s);
X	goto RETRY_1;
X  }
X  ansi("me");
X
X  do {
X	printf("%c%s ", CR, POS14_MSG);
X	strcpy(s, (char *) getline(10, 11, '.', ""));
X	if (strcomp("<BREAK>", s) == 0) s[0] = '\0';
X	strcpy(POSTER.passwort, (char *) crypted(s));
X	if (length(POSTER.passwort) < 5) {
X		ansi("md");
X		printf("\n%s", POS15_MSG);		
X		ansi("me");
X	}
X  } while (length(POSTER.passwort) < 5);
X
XRETRY_2:
X
X  printf("\n%s ", POS16_MSG);
X  strcpy(s, getline(30, 15, '.', ""));
X  if (strcomp("<BREAK>", s) == 0) {
X	strcpy(s, "John Doe");
X  }
X  strcpy(POSTER.nick, (char *) stripped(s));
X
X  ansi("md");
X  printf("\n%s", POS12_MSG);
X  ok = 0;
X  lseek(fd, 0L, SEEK_SET);
X  while ((read(fd, &LOOSER, sizeof(LOOSER)) == sizeof(LOOSER)) && (ok == 0)) {
X	if (strcomp(POSTER.nick, LOOSER.nick)    == 0) ok = 1;
X	if (strcomp(POSTER.nick, LOOSER.name)    == 0) ok = 1;
X	if (strcomp(POSTER.nick, LOOSER.sh_name) == 0) ok = 1;
X  }
X
X  if (USER.level < ADMIN_LEV){
X	  if ((strcomp("SYSOP", POSTER.nick) == 0) ||
X	      (strcomp("POST",  POSTER.nick) == 0) ||
X	      (strcomp("GAST",  POSTER.nick) == 0) ||
X	      (strcomp("ADMIN", POSTER.nick) == 0) ||
X	      (strcomp("COSYS", POSTER.nick) == 0)) ok = 1;
X  }
X
X  if (ok == 1) {
X	printf(" %s\n", POS13_MSG);
X	ansi("me");
X	goto RETRY_2;
X  }
X  ansi("me");
X
X
X  printf("%c%s ", CR, POS17_MSG);
X  strcpy(POSTER.wohnort, (char *) getline(30, 11, '.', ""));
X
X  printf("\n%s ", POS18_MSG);
X  strcpy(POSTER.strasse, (char *) getline(30, 11, '.', ""));
X
X  printf("\n%s ", POS19_MSG);
X  strcpy(POSTER.telefon1, (char *) getline(20, 11, '.', ""));
X
X  printf("\n%s ", POS20_MSG);
X  strcpy(POSTER.telefon2, (char *) getline(20, 11, '.', ""));
X
X  printf("\n%s ", POS21_MSG);
X  strcpy(POSTER.geburtsdatum, (char *) getline(10, 114, '?', ""));
X
X  close(fd);
X
X  ansi("md");
X  printf("\n\n%s\n%s\n\n", POS22_MSG, POS23_MSG);
X  ansi("me");
X
X  USER.level = 0;
X  if(USER.id == 1) USER.level = 10; /* POSTMASTER-Account */
X
X  if (arg[0] != '*') {
X	sprintf(s, "%s", arg);
X	s[14] = '\0';
X	strcpy(USER.sh_name, s);
X	USER.level = WRITE_EX_LEV;
X  }
X  else USER.sh_name[0] = '\0';
X
X  sprintf(USER.name, "%s", POSTER.name);
X  sprintf(USER.passwort, "%s", POSTER.passwort);
X  sprintf(USER.nick, "%s", POSTER.nick);
X  sprintf(USER.wohnort, "%s", POSTER.wohnort);
X  sprintf(USER.strasse, "%s", POSTER.strasse);
X  sprintf(USER.telefon1, "%s", POSTER.telefon1);
X  sprintf(USER.telefon2, "%s", POSTER.telefon2);
X  sprintf(USER.geburtsdatum, "%s", POSTER.geburtsdatum);   
X
X
X  INIT_UDBASE:
X
X  
X  USER.terminal = 1;
X  USER.editor = 1;
X  USER.prompt = 2;
X  USER.bell = 0;
X  USER.more = 1;
X  USER.seq = 0;
X  USER.intro = 3;
X  strcpy(USER.lastlog, (char *) "01.01.1970");
X  USER.lasttime = 0;
X  USER.lastmode = 2;
X  USER.leserichtung = 1;
X  USER.upratio = 0L;
X  USER.downratio = 0L;
X  USER.elapsed = 0L;
X  sprintf(USER.newsgrps, "%s", NEWS_MINIMUM);
X  strcpy(USER.account, "00.00.0000 000.00");
X
X  maybe_locked(UDSEQ, "r"); mblock(UDSEQ);
X  fp = fopen(UDSEQ, "r");
X  if (fp == NULL) {
X	nerror("postfach.c", 188, "postfach", "Datei-Lesefehler", UDSEQ);
X  }
X  fscanf(fp, "%d", &USER.id);
X  fclose(fp);
X  mbunlock(UDSEQ);
X
X  if(USER.id < 1) USER.id = 1;
X
X  maybe_locked(UDSEQ, "r"); mblock(UDSEQ);
X  fp = fopen(UDSEQ, "w");
X  if (fp == NULL) {
X	nerror("postfach.c", 196 , "postfach", "Datei-Schreibfehler", UDSEQ);
X  }
X  fprintf(fp, "%d\n", (USER.id + 1));
X  fclose(fp);
X  mbunlock(UDSEQ);
X
X  maybe_locked(UDBASE, "r"); mblock(UDBASE);
X  fd = open(UDBASE, O_RDWR);
X  if (fd == -1) {
X	nerror("postfach.c", 204, "postfach", "Datei-Lesefehler", UDBASE);
X  }
X  ll = lseek(fd, 0L, SEEK_END);
X  write(fd, &USER, sizeof(USER));
X  close(fd);
X  mbunlock(UDBASE);
X
X  sprintf(s, "%s/usr/%d", HOME, USER.id);
X  mkdir(s, 0777);
X
X  sprintf(s, "%s/usr/%d/seq", HOME, USER.id);
X  fp = fopen(s, "w");
X  fputs("1\n", fp);
X  fclose(fp);
X
X  sprintf(s, "%s/usr/%d/.hello", HOME, USER.id);
X  fp = fopen(s, "w");
X  fputs("\n", fp);
X  fclose(fp);
X
X  sprintf(s, "%s/usr/%d/.signature", HOME, USER.id);
X  fp = fopen(s, "w");
X  fputs("\n", fp);
X  fclose(fp);
X
X  if (arg[0] != '*') {
X	sprintf(s, "cp /usr/%s/%s %s/usr/%d/.signature &", USER.sh_name, SIGNATURE,
X		HOME, USER.id);
X	system(s);
X  }
X  sprintf(s, "%s/usr/%d/INDEX", HOME, USER.id);
X  fp = fopen(s, "w");
X  fprintf(fp, "%s\n", GBL05_MSG);
X  fputs("===============================================================================\n", fp);
X  fclose(fp);
X
X  if (arg[0] == '#') {
X	return; /* UDBASE installiert */
X  }
X
X  i = 0;
X  strcpy(t, USER.name);
X  while(t[i] != '\0'){
X	if(t[i] == ' ') t[i] = '.';
X	i++;
X  }
X
X  sprintf(s, "/bin/sh ./etc/alias.sh \"%s\"", t);
X  system( s );
X
X
X  sprintf(s, "%s \"%s\" (%d)", POS24_MSG, USER.name, USER.id);
X  control(s, 3);
X
X  printf("\n");
X  init_user( POS25_MSG );
X  
X}
X
END_OF_FILE
  if test 8515 -ne `wc -c <'src/postfach.c'`; then
    echo shar: \"'src/postfach.c'\" unpacked with wrong size!
  fi
  # end of 'src/postfach.c'
fi
if test -f 'src/proto.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/proto.h'\"
else
  echo shar: Extracting \"'src/proto.h'\" \(4491 characters\)
  sed "s/^X//" >'src/proto.h' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  proto.h						   */
X/*        FUNKTIONEN  Prototypen der Funktionen				   */
X/*             AUTOR  Olaf's CPROTO					   */
X/*  LETZTE AENDERUNG  28.05.1992					   */
X/***************************************************************************/
X
X#if defined(__STDC__) || defined(__cplusplus)
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
X/* admin.c */
Xvoid user_aendern P_((void));
Xvoid user_anzeigen P_((void));
Xvoid user_loeschen P_((void));
Xint setup_get P_((int max));
Xvoid wait_until_keypressed P_((void));
Xvoid admin P_((void));
Xvoid setup P_((void));
X
X/* befehl.c */
Xint bef P_((char befehl[], char arg[]));
X
X/* baudrate.c */
Xint baudrate P_((int try));
X
X/* control.c */
Xvoid control P_((char text[], int mode));
Xvoid whodo P_((char text[]));
X
X/* coreleft.c */
Xint coreleft P_((void));
X
X/* ctrlx.c */
Xvoid ctrlx P_((void));
Xvoid noctrlx P_((void));
X
X/* derror.c */
Xvoid nerror P_((char file[], int line, char function[], char descr[], char er[]));
X
X/* games.c */
Xint games P_((void));
X
X/* getch.c */
Xint getch P_((void));
X
X/* getline.c */
Xchar *getline P_((int len, int mode, int bsc, char deftext[]));
Xint getint P_((void));
Xint yesno P_((void));
X
X/* help.c */
Xint help P_((char cmd[]));
X
X/* intro.c */
Xvoid intro P_((void));
Xvoid init_user P_((char info[]));
X
X/* lesen.c */
Xchar *getsite P_((char arg[]));
Xint checkdomaintype P_((char arg[]));
Xvoid ansage P_((void));
Xvoid unterschrift P_((void));
Xvoid lesen P_((char arg[]));
X
X/* lesen2.c */
Xint anzeigen P_((int art, int von, int bis));
Xvoid lesen2 P_((char arg[], int mode));
Xvoid inhalt2 P_((char arg[], int mode));
Xvoid loeschen2 P_((char arg[], int mode));
X
X/* loop.c */
Xvoid sigcatch P_((int sig));
Xchar *cut_bef P_((char s[]));
Xchar *cut_arg P_((char s[]));
Xchar *rates P_((void));
Xvoid loop P_((void));
X
X/* mail.c */
Xchar *fetch_reciepy P_((char REP[]));
Xint brief P_((char arg[]));
X
X/* main.c */
Xvoid logout P_((void));
Xvoid init P_((void));
Xvoid fixoutput P_((void));
X/* int main P_((void)); */
X
X/* makro.c */
Xchar *makro P_((char s[]));
Xvoid set_makros P_((void));
Xvoid get_makros P_((void));
Xvoid add_makro P_((char s[]));
Xint makro_definition P_((char s[]));
X
X/* mb-daemon.c */
Xint reflector P_((char arg[], char msg[]));
Xint pdsize P_((char arg[]));
Xchar *scan P_((char arg[]));
Xvoid mix P_((char s[], char t[]));
Xint main P_((int argc, char *argv[]));
X
X/* mbrsh.c */
Xint main P_((int argc, char *argv[]));
X
X/* misc.c */
Xvoid scanner P_((int mode));
Xvoid schreiben P_((char arg[]));
Xint prf P_((char arg[]));
Xint pruefe P_((char arg[]));
X
X/* misc2.c */
Xint chk_newsgrp P_((char s[]));
Xint subb P_((char s[]));
Xvoid loeschen P_((char arg[]));
Xint brett P_((char arg[]));
X
X/* nerror.c */
Xvoid nerror P_((char file[], int line, char function[], char descr[], char er[]));
X
X/* outdial.c */
Xvoid outdial P_((void));
X
X/* pd.c */
Xvoid pd P_((char arg[], char keywds[]));
Xvoid status P_((void));
Xvoid mkix P_((char pfad[]));
Xvoid statistik P_((void));
Xvoid download P_((char arg[]));
X
X/* portinfo.c */
Xvoid port P_((char arg[]));
Xvoid show_level P_((void));
Xvoid userliste P_((char arg[]));
Xvoid finger P_((char arg[]));
X
X/* postfach.c */
Xvoid postfach P_((char arg[]));
X
X/* show.c */
Xint show P_((char fname[], int maxlines, int mode));
Xint more P_((void));
X
X/* suchen.c */
Xvoid suchen P_((char muster[]));
X
X/* tools.c */
Xchar *whoami P_((void));
Xchar *stripped P_((char st[]));
Xchar *upcased P_((char st[]));
Xint length P_((char st[]));
Xchar *strcopy P_((char st[], int v, int b));
Xchar *bigcopy P_((char st[], int v, int b));
Xint strcomp P_((char s[], char t[]));
Xint ansi P_((char code[]));
X/* char *termansi P_((char code[])); */
Xchar *mydate P_((int mode));
Xchar *mytime P_((int mode));
Xchar *crypted P_((char s[]));
Xlong dateconv P_((char d[]));
Xchar *datereconv P_((long l));
Xint timeconv P_((char t[]));
Xchar *timereconv P_((int i));
Xchar *shortname P_((char longname[]));
Xint maybe_locked P_((char name[], char mode[]));
Xchar *numstripped P_((char s[]));
Xvoid headline P_((char line[]));
Xvoid mblock P_((char path[]));
Xvoid mbunlock P_((char path[]));
Xint tty P_((void));
Xchar *ttyna P_((void));
Xvoid clearline P_((void));
Xint isin P_((char pattern[], int c)); 
X
X/* weiterl.c */
Xvoid weiterleiten P_((char arg[]));
Xvoid carboncopy P_((char cc[], char bcc[]));
X
X/* xmd.c */
Xint brief P_((char arg[]));
Xint mailing P_((void));
Xint main P_((int argc, char *argv[]));
X
X#undef P_
X
X
X
END_OF_FILE
  if test 4491 -ne `wc -c <'src/proto.h'`; then
    echo shar: \"'src/proto.h'\" unpacked with wrong size!
  fi
  # end of 'src/proto.h'
fi
if test -f 'src/suchen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/suchen.c'\"
else
  echo shar: Extracting \"'src/suchen.c'\" \(4622 characters\)
  sed "s/^X//" >'src/suchen.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  suchen.c						   */
X/*        FUNKTIONEN  suchen(), edit()					   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  13.06.1992					   */
X/***************************************************************************/
X
X#include <stdio.h>
X#include <signal.h>
X
X#include "mbox.h"
X
X
X/***************************************************************************/
X/*      FUNKTION  suchen()						   */
X/*  BESCHREIBUNG  Artikel im aktuellen Brett mit GREP nach muster durch-   */
X/* 		  suchen und entsprechende Artikel anzeigen.		   */
X/*     PARAMETER  muster = Suchbegriff				           */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid suchen( muster )
Xchar muster[];
X{
X  FILE *fp;
X
X  char s[STRING];
X  char t[STRING];
X  char tmp[STRING];
X  char ex[LONGSTRING];
X
X  int fpid;
X  int found = 0;
X  int ok = 0;
X  int i;
X  
X
X  if(muster[0] == '\0'){
X	ansi( "md" );
X	printf("\n\n%s ", SUC01_MSG);
X	ansi( "me" );
X	strcpy(muster, (char *) getline(60, 1, 32, ""));
X	if(muster[0] == '\0'){
X		printf(" <- %s\n", SUC02_MSG);
X		return;
X	}
X  }
X
X  i = 0;
X  while(muster[i] != '\0'){
X	if(muster[i] == '"') muster[i] = ' ';
X	i++;
X  }
X
X  sprintf(s, " %s \"%s\" %s [%s] ", SUC03_MSG, (char *) stripped(muster), SUC04_MSG, NG);
X  headline( s );
X
X  printf("%s .", SUC05_MSG);
X
X  sprintf(tmp, "%s/such.%d", TMP, getpid());
X
X  if(strcomp("PM", BRETT) == 0){
X	sprintf(t, "%s/usr/%d", HOME, USER.id);
X	chdir( t );
X  }
X  else{
X	chdir( BRETT );
X  }
X
X  switch( (fpid = fork()) ){
X		case -1 :
X				break;
X		case  0 :	while(1){
X					printf(".");
X					sleep(3);
X				}	
X				break;
X  }
X
X  sprintf(s, "%s \"%s\" * > %s 2> %s", GREP, (char *) stripped(muster), tmp, CPRN);
X  system( s );
X
X  kill( fpid, SIGKILL );
X  wait( fpid );
X
X  printf("%c", CR);
X
X
X  fp = fopen( tmp, "r" );
X  if(fp == 0){
X	
X  }
X  while((fgets(ex, LONGSTRING, fp) != NULL) && (ok == 0)){
X	if(atoi(ex) != 0){	
X		if(show( (char *) stripped(ex), 9999, USER.more ) == -1) ok++;
X		found++;
X	}
X  }
X  fclose(fp);
X
X  chdir( HOME );
X
X  if(found == 0){
X	printf("%s \"%s\" %s\n", SUC06_MSG, (char *) stripped(muster), SUC07_MSG);
X  }
X
X  unlink( tmp );
X}
X
X
X/***************************************************************************/
X/*      FUNKTION  edit()						   */
X/*  BESCHREIBUNG  							   */
X/*     PARAMETER  						           */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xvoid edit( arg )
Xchar arg[];
X{
X  FILE *fp;
X  FILE *ff;
X
X  char s[STRING];
X  char t[STRING];
X  char d[STRING];
X  char p1[STRING];
X  char p2[STRING];
X
X  int ok = 0;
X  int yet = 0;
X
X  if (arg[0] == '\0') {
X	ansi( "md" );
X	printf(" <- %s\n", SUC07aMSG);
X	ansi( "me" ); 
X	return;
X  }
X
X  if (strcomp(BRETT, "PM") != 0) {
X        sprintf(t, "%s/%s", BRETT, arg); 
X  }
X  else {
X	sprintf(t, "%s/usr/%d/%s", HOME, USER.id, arg);
X	/*
X	ansi( "md" );
X	printf(" <- %s\n", SUC08_MSG);
X	ansi( "me" ); 
X	return;
X	*/
X  }
X  
X  if((USER.level < ADMIN_LEV) && (USER.level >= EXE_LEV)){
X 	fp = fopen( t, "r" );
X	if(fp == NULL){
X		ansi( "md" );
X		printf(" <- %s\n", SUC10_MSG);
X		ansi( "me" ); 
X		return;
X	}
X	while((fgets(s, 80, fp) != 0) && (ok == 0)){
X		if(strcomp("From: ", s) == 0){
X			strcpy(d, (char *) strcopy(s, 6, 80));
X			if(strcomp(USER.name, d) == 0) ok++;
X		}
X	}
X	fclose(fp);
X	if(ok == 0){
X		ansi( "md" );
X		printf(" <- %s\n", SUC09_MSG);
X		ansi( "me" ); 
X		return;
X	}
X  }
X
X  if(USER.level >= EXE_LEV){
X	sprintf(s, "%s %s", EDDY, t);
X	noctrlx();
X	system(s);
X	ctrlx();
X  }
X  else{
X	sprintf(p1, "%s/%dED1", TMP, getpid());
X	sprintf(p2, "%s/%dED2", TMP, getpid());
X
X	fp = fopen( t, "r" );
X	if(fp == NULL){
X		ansi( "md" );
X		printf(" <- %s\n", SUC08_MSG);
X		ansi( "me" ); 
X		return;
X	}
X 	ff = fopen( p1, "w" );
X	while(fgets(s, 80, fp) != NULL){
X		fputs(s, ff);
X		if(strcomp("From: ", s) == 0){
X			strcpy(d, (char *) strcopy(s, 6, 80));
X			if(strcomp(USER.name, d) == 0) ok++;
X		}
X		if((strlen(s) < 3) && (yet == 0)){
X			fclose(ff);
X			ff = fopen( p2, "w" );
X			yet++;
X		}
X	}
X	fclose(fp);
X	fclose(ff);
X
X	if(ok == 0){
X		ansi( "md" );
X		printf(" <- %s\n", SUC09_MSG);
X		ansi( "me" ); 
X		unlink( p1 );
X		unlink( p2 );
X		return;
X	}
X
X	sprintf(s, "%s %s", EDDY, p2);
X	noctrlx();
X	system(s);
X	ctrlx();
X
X	sprintf(s, "cat %s > %s", p1, t);
X	system( s );
X	sprintf(s, "cat %s >> %s", p2, t);
X	system( s );
X
X	unlink( p1 );
X	unlink( p2 );
X  }
X}
END_OF_FILE
  if test 4622 -ne `wc -c <'src/suchen.c'`; then
    echo shar: \"'src/suchen.c'\" unpacked with wrong size!
  fi
  # end of 'src/suchen.c'
fi
if test -f 'src/xmd.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/xmd.c'\"
else
  echo shar: Extracting \"'src/xmd.c'\" \(8786 characters\)
  sed "s/^X//" >'src/xmd.c' <<'END_OF_FILE'
X/***************************************************************************/
X/*	    PROGRAMM  ix/Mbox						   */
X/*             DATEI  xmd.c						   */
X/*        FUNKTIONEN  brief(), mailing(), main()			   */
X/*             AUTOR  vs (Volker Schuermann/MINIX-Version)		   */
X/*  LETZTE AENDERUNG  15.02.1992					   */
X/***************************************************************************/
X
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <unistd.h>
X#include <stdio.h>
X#include <fcntl.h>
X#include <time.h>
X
X#include "mbox.h"
X
X
Xchar tmp[STRING];
Xchar alias[MAX_XMD_ALIAS][2][STRING];
Xint INTERACT;
X
X
X
X/***************************************************************************/
X/*      FUNKTION  brief()						   */
X/*  BESCHREIBUNG  Leitet einen Brief weiter an einen MBox-Account.	   */
X/*		  Auf diese Weise ist der Mbox-User auch unter der         */
X/*		  Adresse 'Real.Name@UUCPID' erreichbar.		   */
X/*     PARAMETER  arg  =  Mbox-User-Name                                   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xbrief(arg)
Xchar arg[];
X{
X  FILE *fp;
X  FILE *ff;
X  int fd;
X  int i;
X  int ok;
X  struct userdaten LOOSER;
X
X  struct tm *timeptr;
X  time_t timer;
X
X  int receiver;
X  static int mail_id;
X  int EX_PM = 0;
X  int REPLY = 0;
X  int lines = 0;
X  int local = 0;
X
X
X  char s[STRING];
X  char t[STRING];
X  char top[STRING];
X  char subject[STRING];
X  char autor[STRING];
X  char rec_char[STRING];
X  char ex[255];
X  char user[STRING];
X  char c;
X  char protokoll;
X  char destination[STRING];
X
X  i = 0;
X  ok = 0;
X
X  strcpy(user, (char *) stripped(arg));
X  strcpy(subject, XMD01_MSG);
X
X  JUNK:	receiver = 0;
X
X  fd = open(UDBASE, O_RDONLY);
X  if (fd == -1) {
X	printf("\nSHIT!\n");
X	exit(-1);
X  }
X  lseek(fd, 0L, SEEK_SET);
X  while ((read(fd, &LOOSER, sizeof(LOOSER)) == sizeof(LOOSER)) && (receiver == 0)) {
X	if ((strcomp(user, LOOSER.name) == 0) ||
X	    (strcomp(LOOSER.name, user) == 0) ||
X	    (strcomp(user, LOOSER.nick) == 0) ||
X	    (strcomp(user, LOOSER.sh_name) == 0)) {
X		receiver = LOOSER.id;
X		strcpy(rec_char, LOOSER.name);
X	}
X  }
X  close(fd);
X
X  if (receiver == 0) {
X	sprintf(subject, "[xmd:] '%s' ???   ", user);
X	strcpy(user, POSTMASTER);
X	goto JUNK;
X  }
X  sprintf(s, "%s/usr/%d/seq", HOME, receiver);
X  fp = fopen(s, "r");
X  fgets(s, 80, fp);
X  mail_id = atoi( s );
X  fclose(fp);
X
X  sprintf(destination, "%s/usr/%d/%d", HOME, receiver, mail_id);
X  fp = fopen(destination, "w");
X
X  sprintf(s, "%s %s (%s)\n", GBL01_MSG, X_MAIL_DEMON, "xmd");
X  fputs(s, fp);
X
X  time(&timer);
X  timeptr = localtime(&timer);
X  strcpy(t, (char *) asctime(timeptr));
X
X  sprintf(s, "%s %s", GBL02_MSG, t);
X  fputs(s, fp);
X
X  sprintf(s, "%s %s\n\n", GBL03_MSG, subject);
X  fputs(s, fp);
X
X  fprintf(fp, "%s\n\n", XMD02_MSG);
X
X  lines = 7;
X
X  autor[0] = '\0';
X  subject[0] = '\0';
X
X  ff = fopen(tmp, "r");
X  if (ff == NULL) {
X	return;
X  }
X  while (fgets(s, 80, ff) != NULL) {
X	i = 0;
X	while(s[i] != '\0'){
X		if(s[i] > 127){
X			s[i] = '?';
X		}
X		i++;
X	}
X	fputs(s, fp);
X	lines++;
X	if((strcomp("Subject: ", s) == 0) && (subject[0] == '\0')){
X		strcpy(subject, (char *) stripped(strcopy(s, 9, 80)));
X	}
X	if((strcomp("From: ", s) == 0) && ((autor[0] == '\0') || (local = 1))){
X		strcpy(autor, (char *) stripped(strcopy(s, 6, 80)));
X		local = 0;
X	}
X	if(strcomp("From ", s) == 0){
X		strcpy(autor, (char *) stripped(strcopy(s, 5, 80)));
X		local = 1;
X	}
X  }
X  fclose(ff);
X  fclose(fp);
X
X  i = 0; 
X  while(autor[i] != '\0'){
X	if(autor[i] == '(') autor[(i-1)] = '\0';
X	i++;
X  }
X
X  if((local == 1) && (strcomp("postmaster", autor) == 0)){
X	fclose(fp);
X	unlink(destination);
X	if(INTERACT == 0) printf("[%s]\n", arg);
X	fp = fopen( XMDLOG, "a" );
X	fprintf(fp, "-%-30.30s%s\n", (char *) stripped(arg), subject);
X	fclose(fp);
X	return;
X  }
X
X  sprintf(s, "%s/usr/%d/INDEX", HOME, receiver);
X  fp = fopen(s, "a");
X
X  sprintf(s, "%d              ", mail_id);
X  s[6] = '\0';
X  fputs(s, fp);
X
X  sprintf(ex, "%s                                  ", subject);
X  ex[26] = '\0';
X  fputs(ex, fp);
X
X  sprintf(ex, "  %s                                        ", autor);
X  ex[22] = '\0';
X  fputs(ex, fp);
X
X
X  strcpy(s, (char *) mydate(1));
X  strcpy(t, (char *) mytime(1));
X  sprintf(ex, "  %s  %s         ", s, t);
X  ex[19] = '\0';
X  fputs(ex, fp);
X
X  sprintf(s, "%-5.d\n", lines);
X  fputs(s, fp);
X
X  fclose(fp);
X
X  sprintf(s, "%s/usr/%d/seq", HOME, receiver);
X  fp = fopen(s, "w");
X  rewind(fp);
X  fprintf(fp, "%d\n", (int) (mail_id + 1));
X  fclose(fp);
X
X  if(INTERACT == 0) printf("%s\n", arg);
X
X  ff = fopen( XMDLOG, "a" );
X  fprintf(ff, " %-30.30s%s\n", (char *) stripped(arg), subject);
X  fclose(ff);
X}
X
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  mailing()						   */
X/*  BESCHREIBUNG  Isoliert den Mbox-User-Namen aus der UUCP-Adresse und	   */
X/*                ruft mit diesem Namen die Routine "brief()" auf.	   */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xmailing()
X{
X  FILE *fp;
X  char s[255];
X  char t[STRING];
X  int i, j;
X
X  fp = fopen(tmp, "r");
X  if (fp == NULL) {
X	printf("\nPuhhh???\n");
X	exit(-1);
X  }
X  while (fgets(s, 80, fp) != NULL) {
X	if (strcomp("To:", s) == 0) {
X
X		i = 1;
X		while(strcomp("EOL", alias[i][1]) != 0){	
X			if(strcomp(alias[i][1], s) == 0) strcpy(s, alias[i][2]);
X			i++;
X		}
X
X		i = 0;
X		j = 0;
X		while ((s[i] != '\0') && (s[i] != '@')) {
X			if (s[i] == '!') j = i;
X			if ((s[i] == '.') || (s[i] == '%')) s[i] = ' ';
X			i++;
X		}
X		i--;
X		if (j == 0) {
X			strcpy(t, (char *) strcopy(s, 4, i));
X		} else {
X			strcpy(t, (char *) strcopy(s, (j + 1), length(s)));
X		}
X		brief(t);
X	}
X  }
X
X  fclose(fp);
X
X
X  unlink(tmp);
X
X}
X
X
X
X
X/***************************************************************************/
X/*      FUNKTION  main() (xmd)						   */
X/*  BESCHREIBUNG  Der Briefkasten des ERRORUSERS (POSTMASTER) wird ge-	   */
X/*		  scannt. Alle Eintraege fuer Mbox-User, deren Adresse     */
X/*		  im Format 'Real.Name@UUCPID' vorliegen, werden zuge-	   */
X/*		  stellt.                                                  */
X/*     PARAMETER  keine	                                                   */
X/*     RUECKGABE  keine                                                    */
X/***************************************************************************/
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X  FILE *fp;
X  FILE *ff;
X  char s[255];
X  char t[255];
X  char dump[STRING];
X  char maildrop[STRING];
X  int toggle = 0;
X  int l;
X  int c;
X
X  setuid(0);
X  setgid(0);
X  umask(0000);
X
X  chdir(HOME);
X
X  ff = fopen( XMDLOG, "a" );
X  fprintf(ff, "\n\n========================== %s - %s ==============================\n\n", (char *) mydate( 1 ), (char *) mytime( 0 ));
X  fclose(ff);
X
X  if(argc < 2){
X	fp = fopen(ERRMBOX, "r");
X	INTERACT = 0;
X  }
X  else{
X	if(argv[2][0] == '-'){
X		sprintf(maildrop, "%s/%dPIP", TMP, getpid());
X		fp = fopen(maildrop, "w");
X		c = 0;
X		do{
X			c = fgetc(stdin);
X			if((c != EOF) && (c != 4)){
X				fputc(c, fp);
X				printf("%c", c);
X			}
X		}while((c != EOF) && (c != 4));
X		fclose(fp);
X		fp = fopen(maildrop, "r");
X		INTERACT = 1;	
X	}
X	else{
X		sprintf(maildrop, "%s/%s", MAILDROP, argv[1]);
X		fp = fopen(maildrop, "r");
X		INTERACT = 1;
X	}
X  }
X  if(INTERACT == 0) printf("\n");
X
X  if (fp == NULL) {
X	if(INTERACT == 0) printf("\nNo mail.\n");
X	return;
X  }
X
X  l = 1; 
X  ff = fopen( XMD_ALIAS, "r" );
X  if(ff != 0){
X	while(fgets(s, 80, ff) != 0){
X		if((s[0] > 64) && (l < MAX_XMD_ALIAS)){
X			strcpy(alias[l][1], (char *) stripped(s));
X			fgets(s, 80, ff);
X			strcpy(alias[l][2], (char *) stripped(s));
X			l++;
X		}
X	}
X	fclose(ff);
X  }
X  strcpy(alias[l][1], "EOL");
X
X  sprintf(dump, "%s/%d.DUMP", TMP, getpid());
X  ff = fopen(dump, "w");
X
X  while (fgets(s, 80, fp) != NULL) {
X	l = 2;
X	if (s[0] == '>') {
X		if(s[1] != ' ') l = 1;
X		strcpy(t, (char *) strcopy(s, l, length(s)));
X		strcpy(s, t);
X		if (strcomp("OOPS", s) != 0) {
X			fputs(s, ff);
X		}
X	}
X	else{
X		fputs(s, ff);
X	}
X  }
X  fclose(ff);
X  fclose(fp);
X
X  fp = fopen(dump, "r");
X
X  sprintf(tmp, "%s/%d.XMD", TMP, getpid());
X
X  ff = fopen(tmp, "w");
X
X  while (fgets(s, 80, fp) != NULL) {
X	if ((strcomp("From ", s) == 0) || (strcomp("From: ", s) == 0)){
X		if (toggle == 1) {
X			if (ff != 0) fclose(ff);
X			mailing();
X			ff = fopen(tmp, "w");
X		}
X		toggle = 1;
X	}
X	if (toggle == 1) fputs(s, ff);
X  }
X  if (ff != 0) fclose(ff);
X  if (toggle == 1) mailing();
X  fclose(fp);
X  
X  unlink(tmp);
X  unlink(dump);
X  
X  if(INTERACT == 0)
X 	sprintf(s, "> %s", ERRMBOX);
X  else{
X	if(getgid() == GUEST_GID){
X	 	sprintf(s, "> %s", maildrop);
X	}
X  }
X  system(s);
X}
END_OF_FILE
  if test 8786 -ne `wc -c <'src/xmd.c'`; then
    echo shar: \"'src/xmd.c'\" unpacked with wrong size!
  fi
  # end of 'src/xmd.c'
fi
echo shar: End of archive 9 \(of 11\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
