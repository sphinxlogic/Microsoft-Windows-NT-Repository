Newsgroups: comp.sources.misc
From: iain%anl433.uucp@Germany.EU.net (Iain Lea)
Subject:  v31i007:  tin - threaded full screen newsreader v1.1 PL4, Part07/15
Message-ID: <1992Jul7.181655.7489@sparky.imd.sterling.com>
X-Md4-Signature: 199428a450d4ac8b840e05bce76b730b
Date: Tue, 7 Jul 1992 18:16:55 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: iain%anl433.uucp@Germany.EU.net (Iain Lea)
Posting-number: Volume 31, Issue 7
Archive-name: tin/part07
Environment: BSD, SCO, ISC, SUNOS, SYSVR3, SYSVR4, ULTRIX, XENIX
Supersedes: tin: Volume 30, Issue 1-14

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  page.c proto.h
# Wrapped by kent@sparky on Mon Jun 29 23:35:12 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 7 (of 15)."'
if test -f 'page.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'page.c'\"
else
  echo shar: Extracting \"'page.c'\" \(22481 characters\)
  sed "s/^X//" >'page.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : page.c
X *  Author    : I.Lea & R.Skrenta
X *  Created   : 01-04-91
X *  Updated   : 20-06-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
Xextern int cur_groupnum;
X
Xchar note_h_path[LEN];			/* Path:	*/
Xchar note_h_date[LEN];			/* Date:	*/
Xchar note_h_subj[LEN];			/* Subject:	*/
Xchar note_h_org[LEN];			/* Organization: */
Xchar note_h_newsgroups[LEN];		/* Newsgroups:	*/
Xchar note_h_messageid[LEN];		/* Message-ID:	*/
Xchar note_h_distrib[LEN];		/* Distribution: */
Xchar note_h_followup[LEN];		/* Followup-To: */
X
Xchar *glob_page_group;
X
XFILE *note_fp;					/* the body of the current article */
X
Xint glob_respnum;
Xint last_resp;					/* current & previous article for - command */
Xint note_end;					/* we're done showing this article */
Xint note_line;
Xint note_page;					/* what page we're on */
Xint rotate;						/* 0=normal, 13=rot13 decode */
Xint this_resp;
X
Xlong note_mark[MAX_PAGES];		/* ftells on beginnings of pages */
Xlong note_size;					/* stat size in bytes of article */
X
X
Xint show_page (respnum, threadnum, group, group_path)
X	int respnum;
X	int *threadnum;		/* to allow movement in thread mode */
X	char *group;
X	char *group_path;
X{
X#ifndef INDEX_DAEMON
X
X	char ch;
X	int i, n = 0;
X	int copy_text;
X	int kill_state = NO_KILLING;
X	int old_sort_art_type = sort_art_type;
X	int old_top;
X	int posted;
X	int ret_code;
X	long old_artnum;
X	long art;
X
Xrestart:
X
X	glob_respnum = respnum;
X	glob_page_group = group;
X
X	set_signals_page ();
X	
X	if (respnum != this_resp) {	   /* remember current & previous */
X		last_resp = this_resp;	   /* articles for - command */
X		this_resp = respnum;
X	}
X
X	rotate = 0;			/* normal mode, not rot13 */
X	art = arts[respnum].artnum;
X	arts[respnum].unread = ART_READ;	/* mark article as read */
X
X	if ((note_page = art_open (art, group_path)) == ART_UNAVAILABLE) {
X		sprintf (msg, txt_art_unavailable, art);
X		error_message (msg, "");
X		return (which_thread (respnum));
X	} else {
X		show_note_page (respnum, group);
X	}
X
X	while (TRUE) {
X		ch = (char) ReadCh();
X
X		if (ch >= '0' && ch <= '9') {
X			n = prompt_response (ch, respnum);
X			if (n != -1) {
X				respnum = n;
X				goto restart;
X			}
X			continue;
X		}
X		switch (ch) {
X			case ESC:
X				switch (get_arrow_key ()) {
X					case KEYMAP_PAGE_UP:
X						goto page_up;
X
X					case KEYMAP_PAGE_DOWN:
X						goto page_down;
X
X					case KEYMAP_HOME:
X						goto begin_of_article;
X
X					case KEYMAP_END:
X						goto end_of_article;
X				}
X				break;
X
X#ifndef NO_SHELL_ESCAPE
X			case '!':
X				shell_escape ();
X				redraw_page (respnum, group);
X				break;
X#endif
X
X			case '$':	/* goto end of article */
X			case 'G':	/* 'less' compatible */
Xend_of_article:			
X				if (show_last_page ()) {
X					show_note_page (respnum, group);
X				}
X				break;
X
X			case '-':	/* show last viewed article */
X				if (last_resp < 0) {
X					info_message (txt_no_last_message);
X					break;
X				}
X				art_close ();
X				respnum = last_resp;
X				goto restart;
X
X			case '|':	/* pipe article/thread/tagged arts to command */
X				feed_articles (FEED_PIPE, PAGE_LEVEL, "Pipe", respnum, group_path);
X				break;
X
X			case '/':	/* search forwards in article */
X				if (search_article (TRUE)) {
X					show_note_page (respnum, group);
X				}
X				break;
X
X			case '<':	/* goto first article in current thread */
X				if (arts[respnum].inthread) {
X					n = which_thread (respnum);
X					if (n >= 0 && base[n] != respnum) {
X						assert (n < top_base);
X						respnum = base[n];
X						art_close ();
X						goto restart;
X					}
X				}
X				break;
X
X			case '>':	/* goto last article in current thread */
X				for (i = respnum; i >= 0; i = arts[i].thread) {
X					n = i;
X				}
X				if (n != respnum) {
X					respnum = n;
X					art_close ();
X					goto restart;
X				}
X				break;
X
X			case ' ':		/* page down or next response */
X			case ctrl('D'):
X			case ctrl('F'):		/* vi style */
Xpage_down:
X				if (note_page == ART_UNAVAILABLE) {
X					n = next_response (respnum);
X					if (n == -1) {
X						return (which_thread (respnum));
X					}
X					respnum = n;
X					goto restart;
X				} else if (note_end) {
X					art_close ();
X					n = next_response (respnum);
X					if (n == -1) {
X						return (which_thread (respnum));
X					}
X					respnum = n;
X					goto restart;
X				} else
X					show_note_page (respnum, group);
X				break;
X
X			case '\r':
X			case '\n':	/* go to start of next thread */
X				art_close ();
X				n = next_thread (respnum);
X				if (n == -1)
X					return (which_thread (respnum));
X				respnum = n;
X				goto restart;
X
X			case '\t': 	/* goto next unread article */
X#ifndef TAB_GOTO_NEXT_UNREAD
X				if (note_page == ART_UNAVAILABLE) {
X					n = next_unread (next_response (respnum));
X					if (n == -1) {
X						return (which_thread (respnum));
X					}
X					respnum = n;
X					goto restart;
X				} else if (note_end) {
X					art_close ();
X					n = next_unread (next_response (respnum));
X					if (n == -1) {
X						return (which_thread (respnum));
X					}
X					respnum = n;
X					goto restart;
X				} else {
X					show_note_page (respnum, group);
X				}	
X#else
X				if (note_page != ART_UNAVAILABLE) {
X					art_close();
X				}
X				n = next_unread (next_response (respnum));
X				if (n == -1) {
X					return (which_thread (respnum));
X				}
X				respnum = n;
X				goto restart;
X#endif
X				break;
X
X			case ctrl('H'):	/* show article headers */
X				if (note_page == ART_UNAVAILABLE) {
X					n = next_response (respnum);
X					if (n == -1)
X						return (which_thread (respnum));
X					respnum = n;
X					goto restart;
X				} else {
X					note_page = 0;
X					note_end = FALSE;
X					fseek(note_fp, 0L, 0);
X					show_note_page(respnum, group);
X				}
X				break;
X
X			case ctrl('K'):		/* kill article */
X				if (kill_art_menu (group, respnum)) {
X					i = which_thread (respnum);
X					if (kill_any_articles (group)) {
X						make_threads (FALSE);
X						find_base (show_only_unread);
X						if (i >= top_base)
X							i = top_base - 1;
X						respnum = base[i];	
X					}
X				}
X				redraw_page (respnum, group);
X				break;
X
X			case ctrl('L'):		/* redraw current page of article */
X				redraw_page (respnum, group);
X				break;
X
X			case ctrl('R'):		/* redraw beginning of article */
X			case 'g':			/* 'less' compatible */
Xbegin_of_article:			
X				if (note_page == ART_UNAVAILABLE) {
X					ClearScreen ();
X					printf (txt_art_unavailable, arts[respnum].artnum);
X					fflush (stdout);
X				} else {
X					note_page = 0;
X					note_end = FALSE;
X					fseek (note_fp, note_mark[0], 0);
X					show_note_page (respnum, group);
X				}
X				break;
X
X			case ctrl('X'):
X			case '%':
X			case 'd':	/* toggle rot-13 mode */
X				if (rotate)
X					rotate = 0;
X				else
X					rotate = 13;
X				redraw_page (respnum, group);
X				info_message (txt_toggled_rot13);
X				break;
X
X			case 'a':	/* author search forward */
X			case 'A':	/* author search backward */
X				i = (ch == 'a');
X				n = search_author (show_only_unread, respnum, i);
X				if (n < 0)
X					break;
X				respnum = n;
X				goto restart;
X				/* NOTREACHED */
X
X			case 'b':		/* page up */
X			case ctrl('U'):
X			case ctrl('B'):		/* vi style */
Xpage_up:
X				if (note_page == ART_UNAVAILABLE) {
X					art_close ();
X					n = prev_response (respnum);
X					if (n == -1)
X						return (which_response (respnum));
X					respnum = n;
X					goto restart;
X
X				} else {
X					if (note_page <= 1) {
X						info_message (txt_begin_of_art);
X					} else {
X						note_page -= 2;
X						note_end = FALSE;
X						fseek (note_fp, note_mark[note_page], 0);
X						show_note_page (respnum, group);
X					}
X				}
X				break;
X
X			case 'B':	/* bug/gripe/comment mailed to author */
X				mail_bug_report ();
X				redraw_page (respnum, group);
X				break;
X				
X			case 'c':	/* catchup--mark all articles as read */
X				if (!confirm_action || prompt_yn (LINES, txt_mark_all_read, 'y')) {
X					for (n = 0; n < top; n++) {
X						arts[n].unread = ART_READ;
X					}
X					fix_new_highest (cur_groupnum);
X					if (cur_groupnum + 1 < group_top) {
X						cur_groupnum++;
X					}
X					art_close ();
X					return -1;
X				}
X				break;
X
X			case 'C':	/* cancel an article */
X				if (cancel_article (group, respnum)) {
X					redraw_page (respnum, group);
X				}
X				break;
X	
X			case 'f':	/* post a followup to this article */
X			case 'F':
X				if (! can_post) {
X					info_message (txt_cannot_post);
X					break;
X				}
X				copy_text = (ch == 'f' ? FALSE : TRUE);
X				ret_code = post_response (group, respnum, copy_text);
X				redraw_page (respnum, group);
X				break;
X
X			case 'h':	/* help */
X				show_info_page (HELP_INFO, help_page, txt_art_pager_com);
X				redraw_page (respnum, group);
X				break;
X
X			case 'q':	/* return to index page */
Xreturn_to_index:
X				art_close ();
X				if (kill_state == NO_KILLING &&
X					sort_art_type != old_sort_art_type) {
X					make_threads (TRUE);
X					find_base (show_only_unread);
X				}
X				i = which_thread (respnum);
X				*threadnum = which_response (respnum);
X				if (kill_state == KILLING) {
X					old_top = top;
X					old_artnum = arts[respnum].artnum;
X					kill_any_articles (group);
X					make_threads (FALSE);
X					find_base (show_only_unread);
X					i = find_new_pos (old_top, old_artnum, i);
X				}
X				return (i);
X
X			case 'I':	/* toggle inverse video */
X				toggle_inverse_video ();
X				redraw_page (respnum, group);
X				break;
X
X			case 'k':
X				if (note_page == ART_UNAVAILABLE) {
X					n = next_unread (next_response(respnum));
X					if (n == -1)
X						return (which_thread (respnum));
X				} else {
X					art_close ();
X					n = next_unread (next_response (respnum));
X					if (n == -1)
X						return (which_thread (respnum));
X				}
X				respnum = n;
X				goto restart;
X				/* NOTREACHED */
X
X			case 'K':	/* mark rest of thread as read */
X				for (n = respnum; n >= 0; n = arts[n].thread)
X					arts[n].unread = ART_READ;
X				n = next_unread (next_response (respnum));
X				if (n == -1)
X					goto return_to_index;
X				art_close ();
X				respnum = n;
X				goto restart;
X				/* NOTREACHED */
X
X			case 'm':	/* mail article/thread/tagged articles to somebody */
X				feed_articles (FEED_MAIL, PAGE_LEVEL, "Mail", respnum, group_path);
X				break;
X
X			case 'M':	/* options menu */
X				if (change_rcfile (group, FALSE) == KILLING) {
X					kill_state = KILLING;
X				} 
X				redraw_page (respnum, group);
X			    break;
X
X			case 'n':	/* skip to next article */
X				art_close ();
X				n = next_response (respnum);
X				if (n == -1)
X					return (which_thread(respnum));
X				respnum = n;
X				goto restart;
X				/* NOTREACHED */
X				
X			case 'N':	/* next unread article */
X				n = next_unread (next_response (respnum));
X				if (n == -1)
X					info_message (txt_no_next_unread_art);
X				else {
X					art_close ();
X					respnum = n;
X					goto restart;
X				}
X				break;
X
X			case 'o':	/* output art/thread/tagged arts to printer */
X				feed_articles (FEED_PRINT, PAGE_LEVEL, "Print", respnum, group_path);
X				break;
X
X			case 'p':	/* previous article */
X				art_close ();
X				n = prev_response (respnum);
X				if (n == -1)
X					return (which_response (respnum));
X				respnum = n;
X				goto restart;
X
X			case 'P':	/* previous unread article */
X				n = prev_unread (prev_response (respnum));
X				if (n == -1)
X				    info_message (txt_no_prev_unread_art);
X				else {
X					art_close ();
X					respnum = n;
X					goto restart;
X				}
X				break;
X
X			case 'Q':	/* quit */
X				return -2;
X				break;
X	
X			case 'r':	/* reply to author through mail */
X			case 'R':
X				copy_text = (ch == 'r' ? FALSE : TRUE);
X				mail_to_author (group, respnum, copy_text);
X				redraw_page (respnum, group);
X				break;
X
X			case 's':	/* save article/thread/tagged articles */
X				feed_articles (FEED_SAVE, PAGE_LEVEL, "Save", respnum, group_path);
X				break;
X
X			case 't':	/* return to group selection page */
X				art_close ();
X				if (kill_state == KILLING) {
X					kill_any_articles (group);
X					make_threads (FALSE);
X					find_base (show_only_unread);
X				}
X				update_newsrc (group, my_group[cur_groupnum], FALSE);
X				fix_new_highest (cur_groupnum);
X				return -1;
X
X			case 'T':	/* tag/untag article for saving */
X				if (arts[respnum].tagged) {
X					arts[respnum].tagged = 0;
X					info_message (txt_untagged_art);
X				} else {
X					arts[respnum].tagged = ++num_of_tagged_arts;
X					info_message (txt_tagged_art);
X				}
X				break;
X
X			case 'v':
X				info_message (cvers);
X				break;
X
X			case 'w':	/* post a basenote */
X				if (! can_post) {
X					info_message (txt_cannot_post);
X					break;
X				}
X				if (post_base (group, &posted)) {
X					redraw_page (respnum, group);
X				}
X				break;
X
X			case 'W':	/* display messages posted by user */
X				if (user_posted_messages ()) {
X					redraw_page (respnum, group);
X				}
X				break;
X
X			case 'x':	/* crosspost current article */
X				feed_articles (FEED_XPOST, PAGE_LEVEL, "Crosspost", respnum, group_path);
X				break;
X
X			case 'z':	/* mark article as unread (to return) */
X				arts[respnum].unread = ART_WILL_RETURN;
X				info_message (txt_art_marked_as_unread);
X				break;
X
X			default:
X			    info_message(txt_bad_command);
X		}
X	}
X
X#endif /* INDEX_DAEMON */
X}
X
X
Xvoid redraw_page (respnum, group)
X	int respnum;
X	char *group;
X{
X	if (note_page == ART_UNAVAILABLE) {
X		ClearScreen ();
X		printf (txt_art_unavailable, arts[respnum].artnum);
X		fflush (stdout);
X	} else if (note_page > 0) {
X		note_page--;
X		fseek (note_fp, note_mark[note_page], 0);
X		show_note_page (respnum, group);
X	}
X}
X
X
Xvoid show_note_page (respnum, group)
X	int respnum;
X	char *group;
X{
X#ifndef INDEX_DAEMON
X
X	char buf[LEN];
X	char buf2[LEN+50];
X	char *p, *q;
X	int i, j;
X	int ctrl_L;		/* form feed character detected */
X	long tmp_pos;
X
X	ClearScreen ();
X
X	note_line = 1;
X
X	if (note_size == 0L) {
X		tmp_pos = ftell (note_fp);
X		fseek (note_fp, 0L, 2);			/* goto end of article */
X		note_size = ftell (note_fp);
X		fseek (note_fp, tmp_pos, 0);	/* goto old position */
X	}
X	
X	if (note_page == 0)
X		show_first_header (respnum, group);
X	else
X		show_cont_header (respnum);
X
X	ctrl_L = FALSE;
X	while (note_line < LINES) {
X		if (fgets (buf, sizeof (buf), note_fp) == NULL) {
X			note_end = TRUE;
X			break;
X		}
X
X		buf[LEN-1] = '\0';
X		if (rotate)
X			for (p = buf, q = buf2; *p && *p != '\n' && q < &buf2[LEN]; p++) {
X				if (*p == '\b' && q > buf2) {
X					q--;
X				} else if (*p == 12) {		/* ^L */
X					*q++ = '^';
X					*q++ = 'L';
X					ctrl_L = TRUE;
X				} else if (*p == '\t') {
X					i = q - buf2;
X					j = (i|7) + 1;
X
X					while (i++ < j)
X						*q++ = ' ';
X				} else if (((*p) & 0xFF) < ' ') {
X					*q++ = '^';
X					*q++ = ((*p) & 0xFF) + '@';
X				} else if (*p >= 'A' && *p <= 'Z')
X					*q++ = 'A' + (*p - 'A' + rotate) % 26;
X				else if (*p >= 'a' && *p <= 'z')
X					*q++ = 'a' + (*p - 'a' + rotate) % 26;
X				else
X					*q++ = *p;
X			}
X		else
X			for (p = buf, q = buf2; *p && *p != '\n' && q < &buf2[LEN]; p++) {
X				if (*p == '\b' && q > buf2) {
X					q--;
X				} else if (*p == 12) {		/* ^L */
X					*q++ = '^';
X					*q++ = 'L';
X					ctrl_L = TRUE;
X				} else if (*p == '\t') {
X					i = q - buf2;
X					j = (i|7) + 1;
X
X					while (i++ < j)
X						*q++ = ' ';
X				} else if (((*p) & 0xFF) < ' ') {
X					*q++ = '^';
X					*q++ = ((*p) & 0xFF) + '@';
X				} else
X					*q++ = *p;
X			}
X
X		*q = '\0';
X
X		printf("%s\r\n", buf2);
X
X		note_line += ((int) strlen (buf2) / COLS) + 1;
X
X		if (ctrl_L) {
X			break;
X		}
X	}
X
X	note_mark[++note_page] = ftell (note_fp);
X
X	if (note_mark[note_page] == note_size) {
X		note_end = TRUE;
X	}
X
X	if (note_end) {
X		MoveCursor (LINES, MORE_POS-(5+BLANK_PAGE_COLS));
X		StartInverse ();	
X		if (arts[respnum].thread != -1) {
X			fputs (txt_next_resp, stdout);
X			fflush (stdout);
X		} else {
X			fputs (txt_last_resp, stdout);
X			fflush (stdout);
X		}
X		EndInverse ();
X	} else {
X		if (note_size > 0) {
X			draw_percent_mark ((int) note_mark[note_page], (int) note_size);
X		} else {
X			MoveCursor (LINES, MORE_POS-BLANK_PAGE_COLS);
X			StartInverse ();	
X			fputs (txt_more, stdout);
X			fflush (stdout);
X			EndInverse ();
X		}
X	}
X	MoveCursor (LINES, 0);
X
X#endif /* INDEX_DAEMON */
X}
X
X
Xvoid show_first_header (respnum, group)
X	int respnum;
X	char *group;
X{
X	int whichresp;
X	int x_resp;
X	char buf[LEN];
X	char tmp[LEN];
X	int pos, i;
X	int n;
X
X	whichresp = which_response (respnum);
X	x_resp = num_of_responses (which_thread (respnum));
X
X	ClearScreen ();
X
X	strcpy (buf, note_h_date);
X	pos = (COLS - (int) strlen (group)) / 2;
X	for (i = strlen(buf); i < pos; i++)
X		buf[i] = ' ';
X	buf[i] = '\0';
X
X	strcat (buf, group);
X
X	for (i = strlen(buf); i < RIGHT_POS ; i++)
X		buf[i] = ' ';
X	buf[i] = '\0';
X
X	printf (txt_thread_x_of_n, buf, which_thread (respnum) + 1, top_base);
X
X	sprintf (buf, txt_art, arts[respnum].artnum);
X	n = strlen (buf);
X	fputs (buf, stdout);
X
X	strcpy (buf, note_h_subj);
X	buf[RIGHT_POS - 5 - n] = '\0';
X
X	pos = ((COLS - (int) strlen (buf)) / 2) - 2;
X
X	if (pos > n) {
X		MoveCursor (1, pos);
X	} else {
X		MoveCursor (1, n);
X	}
X
X	StartInverse ();
X	fputs (buf, stdout);
X	EndInverse ();
X
X	MoveCursor (1, RIGHT_POS);
X	if (whichresp)
X		printf (txt_resp_x_of_n, whichresp, x_resp);
X	else {
X		if (x_resp == 0)
X			fputs (txt_no_resp, stdout);
X		else if (x_resp == 1)
X			fputs (txt_1_resp, stdout);
X		else
X			printf (txt_x_resp, x_resp);
X	}
X
X	if (*note_h_org) {
X		if (strcmp (arts[respnum].from, arts[respnum].name) == 0) {
X			strcpy (tmp, note_h_org);
X		} else {
X			sprintf (tmp, txt_s_at_s, arts[respnum].name, note_h_org);
X		}
X	} else {
X		strcpy (tmp, arts[respnum].name);
X	}
X
X	tmp[LEN-1] = '\0';
X
X	sprintf (buf, "%s  ", arts[respnum].from);
X
X	pos = COLS - 1 - (int) strlen(tmp);
X	if ((int) strlen (buf) + (int) strlen (tmp) >= COLS - 1) {
X		strncat (buf, tmp, COLS - 1 - (int) strlen(buf));
X		buf[COLS-1] = '\0';
X	} else {
X		for (i = strlen(buf); i < pos; i++)
X			buf[i] = ' ';
X		buf[i] = '\0';
X		strcat (buf, tmp);
X	}
X	printf ("%s\r\n\r\n", buf);
X
X	note_line += 4;
X}
X
X
Xvoid show_cont_header (respnum)
X	int respnum;
X{
X	int whichresp;
X	int whichbase;
X	char buf[LEN];
X
X	whichresp = which_response (respnum);
X	whichbase = which_thread (respnum);
X
X	assert (whichbase < top_base);
X
X	if (whichresp)
X		sprintf(buf, txt_thread_resp_page,
X			whichbase + 1,
X			top_base,
X			whichresp,
X			note_page + 1,
X			note_h_subj);
X	else
X		sprintf(buf, txt_thread_page,
X			whichbase + 1,
X			top_base,
X			note_page + 1,
X			note_h_subj);
X
X	buf[COLS-1] = '\0';
X	printf("%s\r\n\r\n", buf);
X
X	note_line += 2;
X}
X
X
Xint art_open (art, group_path)
X	long art;
X	char *group_path;
X{
X	char buf[1025];
X	char *p;
X
X	note_page = 0;
X
X	art_close ();	/* just in case */
X
X	if ((note_fp = open_art_fp (group_path, art)) == NULL) {
X		return (ART_UNAVAILABLE);
X	}
X
X	note_h_path[0] = '\0';
X	note_h_subj[0] = '\0';
X	note_h_org[0] = '\0';
X	note_h_date[0] = '\0';
X	note_h_newsgroups[0] = '\0';
X	note_h_messageid[0] = '\0';
X	note_h_distrib[0] = '\0';
X	note_h_followup[0] = '\0';
X
X	while (fgets(buf, sizeof buf, note_fp) != NULL) {
X		buf[1024] = '\0';
X
X		for (p=buf ; *p && *p != '\n' ; p++) {
X			if (((*p) & 0xFF) < ' ')
X				*p = ' ';
X		}
X		*p = '\0';
X		
X		if (*buf == '\0')
X			break;
X
X  		if (match_header (buf, "Path", note_h_path, LEN))
X  			continue;
X  		if (match_header (buf, "Subject", note_h_subj, LEN))
X  			continue;
X  		if (match_header (buf, "Organization", note_h_org, LEN))
X  			continue;
X  		if (match_header (buf, "Date", note_h_date, LEN))
X  			continue;
X  		if (match_header (buf, "Newsgroups", note_h_newsgroups, LEN))
X  			continue;
X  		if (match_header (buf, "Message-ID", note_h_messageid, LEN))
X  			continue;
X  		if (match_header (buf, "Message-Id", note_h_messageid, LEN))
X  			continue;
X  		if (match_header (buf, "Distribution", note_h_distrib, LEN))
X  			continue;
X  		if (match_header (buf, "Followup-To", note_h_followup, LEN))
X  			continue;
X	}
X
X	note_mark[0] = ftell (note_fp);
X	note_end = FALSE;
X
X	return (0);
X}
X
X
Xvoid art_close ()
X{
X	if (note_fp && note_page != ART_UNAVAILABLE) {
X		fclose (note_fp);
X		note_fp = (FILE *) 0;
X	}
X}
X
X
Xint prompt_response (ch, respnum)
X	int ch;
X	int respnum;
X{
X	int num;
X
X	clear_message ();
X
X	if ((num = prompt_num (ch, txt_read_resp)) == -1) {
X		clear_message ();
X		return -1;
X	}
X
X	return choose_response (which_thread (respnum), num);
X}
X
X
Xvoid yank_to_addr (orig, addr)
X	char *orig;
X	char *addr;
X{
X	char *p;
X
X	for (p = orig; *p; p++)
X		if (((*p) & 0xFF) < ' ')
X			*p = ' ';
X
X	while (*addr)
X		addr++;
X
X	while (*orig) {
X		while (*orig && (*orig == ' ' || *orig == '"' || *orig == ','))
X			orig++;
X		*addr++ = ' ';
X		while (*orig && (*orig != ' ' && *orig != ',' && *orig != '"'))
X			*addr++ = *orig++;
X		while (*orig && (*orig == ' ' || *orig == '"' || *orig == ','))
X			orig++;
X		if (*orig == '(') {
X			while (*orig && *orig != ')')
X				orig++;
X			if (*orig == ')')
X				orig++;
X		}
X	}
X	*addr = '\0';
X}
X
X
Xint show_last_page ()
X{
X	char buf[LEN];
X	char buf2[LEN+50];
X	char *p, *q;
X	int ctrl_L;		/* form feed character detected */
X	int i, j;
X	long tmp_pos;
X	
X	if (note_end) {
X		return FALSE;
X	}
X
X	if (note_size == 0L) {
X		tmp_pos = ftell (note_fp);
X		fseek (note_fp, 0L, 2);			/* goto end of article */
X		note_size = ftell (note_fp);
X		fseek (note_fp, tmp_pos, 0);	/* goto old position */
X	}
X
X	while (! note_end) {
X		note_line = 1;
X		ctrl_L = FALSE;
X
X		if (note_page == 0) {
X			note_line += 4;
X		} else {
X			note_line += 2;
X		}
X		while (note_line < LINES) {
X			if (fgets (buf, sizeof buf, note_fp) == NULL) {
X				note_end = TRUE;
X				break;
X			}
X			buf[LEN-1] = '\0';
X			for (p = buf, q = buf2;	*p && *p != '\n' && q<&buf2[LEN]; p++) {
X				if (*p == '\b' && q > buf2) {
X					q--;
X				} else if (*p == 12) {		/* ^L */
X					*q++ = '^';
X					*q++ = 'L';
X					ctrl_L = TRUE;
X				} else if (*p == '\t') {
X					i = q - buf2;
X					j = (i|7) + 1;
X
X					while (i++ < j) {
X						*q++ = ' ';
X					}
X				} else if (((*p) & 0xFF) < ' ') {
X					*q++ = '^';
X					*q++ = ((*p) & 0xFF) + '@';
X				} else {
X					*q++ = *p;
X				}
X			}
X			*q = '\0';
X			note_line += ((int) strlen (buf2) / COLS) + 1;
X
X			if (ctrl_L) {
X				break;
X			}
X		}
X		if (note_mark[note_page] == note_size) {
X			note_end = TRUE;
X			note_page--;
X			break;
X		} else if (! note_end) {
X			note_mark[++note_page] = ftell(note_fp);
X		}
X	}
X	fseek (note_fp, note_mark[note_page], 0);
X	return TRUE;
X}
X
X
Xint match_header (buf, pat, body, len)
X	char *buf;
X	char *pat;
X	char *body;
X	int	len;
X{
X	int	plen = strlen (pat);
X
X	if(strncmp (buf, pat, plen) == 0 && buf[plen] == ':' && buf[plen + 1] == ' ') {
X		plen += 2;
X		while (buf[plen] == ' ')
X			plen++;
X		strncpy (body, &buf[plen], len);
X		body[len - 1] = '\0';
X		return TRUE;
X	}
X	return FALSE;
X}
END_OF_FILE
  if test 22481 -ne `wc -c <'page.c'`; then
    echo shar: \"'page.c'\" unpacked with wrong size!
  fi
  # end of 'page.c'
fi
if test -f 'proto.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'proto.h'\"
else
  echo shar: Extracting \"'proto.h'\" \(28626 characters\)
  sed "s/^X//" >'proto.h' <<'END_OF_FILE'
X#if __STDC__
X 
X/* active.c */
Xextern void resync_active_file(void);
Xextern int read_active_file(void);
Xextern int backup_active(int create);
Xextern void notify_groups(void);
Xextern void mark_unthreaded_groups(void);
Xextern void read_newsgroups_file(void);
X/* art.c */
Xextern void find_base(int only_unread);
Xextern int num_of_arts(void);
Xextern int valid_artnum(long art);
Xextern int purge_needed(void);
Xextern void index_group(char *group, char *group_path);
Xextern int read_group(char *group, char *group_path);
Xextern void make_threads(int rethread);
Xextern int parse_headers(FILE *fp, struct article_t *h);
Xextern void write_index_file(char *group);
Xextern int read_index_file(char *group_name);
Xextern void find_index_file(char *group);
Xextern void do_update(void);
Xextern char *parse_date(char *date, char *str);
Xextern int artnum_comp(char *p1, char *p2);
Xextern int subj_comp(char *p1, char *p2);
Xextern int from_comp(char *p1, char *p2);
Xextern int date_comp(char *p1, char *p2);
Xextern void set_article(struct article_t *art);
X/* curses.c */
Xextern int InitScreen(void);
Xextern void ScreenSize(int *num_lines, int *num_columns);
Xextern void InitWin(void);
Xextern void EndWin(void);
Xextern void set_keypad_on(void);
Xextern void set_keypad_off(void);
Xextern void ClearScreen(void);
Xextern void MoveCursor(int row, int col);
Xextern void CleartoEOLN(void);
Xextern void CleartoEOS(void);
Xextern void StartInverse(void);
Xextern void EndInverse(void);
Xextern void ToggleInverse(void);
Xextern int RawState(void);
Xextern void Raw(int state);
Xextern int ReadCh(void);
Xextern int outchar(int c);
X/* debug.c */
Xextern void debug_nntp(char *func, char *line);
Xextern void debug_nntp_respcode(int respcode);
Xextern void debug_print_arts(void);
Xextern void debug_print_header(struct article_t *s);
Xextern void debug_print_comment(char *comment);
Xextern void debug_print_base(void);
Xextern void debug_print_active(void);
X/* feed.c */
Xextern void feed_articles(int function, int level, char *prompt, int respnum, char *group_path);
Xextern int print_file(char *command, int respnum, int count);
X/* getline.c */
Xextern char *getline(char *prompt, int number_only, char *str);
X/* group.c */
Xextern void group_page(char *group);
Xextern void fix_new_highest(int groupnum);
Xextern void show_group_page(char *group);
Xextern void update_group_page(char *group);
Xextern void draw_subject_arrow(void);
Xextern void erase_subject_arrow(void);
Xextern void prompt_subject_num(int ch, char *group);
Xextern void clear_note_area(void);
Xextern int find_new_pos(int old_top, long old_artnum, int cur_pos);
Xextern void mark_screen(int level, int screen_row, int screen_col, char *value);
Xextern void set_subj_from_size(int num_cols);
Xextern void toggle_subject_from(void);
X/* hashstr.c */
Xextern char *hash_str(char *s);
Xextern struct hashnode *add_string(char *s);
Xextern void hash_init(void);
Xextern void hash_reclaim(void);
X/* help.c */
Xextern void show_info_page(int type, char *help[], char *title);
X/* inews.c */
Xextern int submit_inews(char *name);
Xextern void get_host_name(char *host_name);
Xextern void get_from_name(char *from_name);
X/* init.c */
Xextern void init_selfinfo(void);
Xextern void set_tindir(void);
Xextern int create_mail_save_dirs(void);
X/* kill.c */
Xextern int read_kill_file(void);
Xextern void write_kill_file(void);
Xextern int kill_art_menu(char *group_name, int index);
Xextern int unkill_all_articles(void);
Xextern int kill_any_articles(char *group);
Xextern int auto_select_articles(char *group);
X/* lang.c */
X/* main.c */
Xextern void main(int argc, char *argv[]);
Xextern void read_cmd_line_options(int argc, char *argv[]);
Xextern void usage(char *progname);
Xextern int check_for_any_new_news(int check_any_unread, int start_any_unread);
Xextern void save_or_mail_new_news(void);
Xextern void update_index_files(void);
Xextern void show_intro_page(void);
X/* memory.c */
Xextern void init_alloc(void);
Xextern void expand_art(void);
Xextern void expand_active(void);
Xextern void expand_kill(void);
Xextern void expand_save(void);
Xextern void init_screen_array(int allocate);
Xextern void free_all_arrays(void);
Xextern void free_art_array(void);
Xextern void free_active_arrays(void);
Xextern void free_kill_array(void);
Xextern void free_save_array(void);
Xextern char *my_malloc(unsigned size);
Xextern char *my_realloc(char *p, unsigned size);
X/* misc.c */
Xextern void asfail(char *file, int line, char *cond);
Xextern void copy_fp(FILE *fp_ip, FILE *fp_op, char *prefix);
Xextern char *get_val(char *env, char *def);
Xextern int invoke_editor(char *nam);
Xextern void shell_escape(void);
Xextern void tin_done(int ret);
Xextern long hash_groupname(char *group);
Xextern void rename_file(char *old_filename, char *new_filename);
Xextern char *str_dup(char *str);
Xextern int invoke_cmd(char *nam);
Xextern void draw_percent_mark(int cur_num, int max_num);
Xextern void set_real_uid_gid(void);
Xextern void set_tin_uid_gid(void);
Xextern void basename(char *dirname, char *program);
Xextern void mail_setup(void);
Xextern int mail_check(void);
Xextern void parse_from(char *str, char *addr, char *name);
Xextern long my_atol(char *s, int n);
Xextern int my_stricmp(char *p, char *q);
Xextern char *eat_re(char *s);
Xextern long hash_s(char *s);
Xextern void my_strncpy(char *p, char *q, int n);
Xextern int untag_all_articles(void);
Xextern char *str_str(char *text, char *pattern, int patlen);
Xextern void get_author(int thread, int respnum, char *str);
Xextern void toggle_inverse_video(void);
Xextern int get_arrow_key(void);
X/* newsrc.c */
Xextern int auto_subscribe_groups(void);
Xextern void backup_newsrc(void);
Xextern void read_newsrc(int sub_only);
Xextern void write_newsrc(void);
Xextern void rewrite_newsrc(void);
Xextern void read_newsrc_line(char *group);
Xextern void update_newsrc(char *group, int groupnum, int mark_unread);
Xextern void subscribe(char *group, int ch, int num, int out_seq);
Xextern void reset_newsrc(void);
Xextern void delete_group(char *group);
Xextern int undel_group(void);
Xextern void mark_group_read(char *group, int groupnum);
Xextern void parse_seq(char *s);
Xextern int parse_unread(char *s, int groupnum);
Xextern int get_line_unread(char *group, int groupnum);
Xextern void print_seq(FILE *fp, int groupnum);
Xextern int pos_group_in_newsrc(char *group, int pos);
Xextern void mark_all_xref_read(char *xref_line);
X/* nntplib.c */
Xextern char *getserverbyfile(char *file);
Xextern int server_init(char *machine);
Xextern int get_tcp_socket(char *machine);
Xextern int handle_server_response(int response, char *nntpserver);
Xextern void put_server(char *string);
Xextern int get_server(char *string, int size);
Xextern void close_server(void);
X/* open.c */
Xextern void nntp_open(void);
Xextern void nntp_close(void);
Xextern FILE *open_active_fp(void);
Xextern FILE *open_subscription_fp(void);
Xextern FILE *open_newsgroups_fp(void);
Xextern FILE *open_index_fp(char *group_name);
Xextern FILE *open_art_fp(char *group_path, long art);
Xextern FILE *open_header_fp(char *group_path, long art);
Xextern int base_comp(char *p1, char *p2);
Xextern void setup_base(char *group, char *group_path);
Xextern int get_respcode(void);
Xextern int stuff_nntp(char *fnam);
Xextern FILE *nntp_to_fp(void);
Xextern void log_user(void);
Xextern char *nntp_respcode(int respcode);
X/* page.c */
Xextern int show_page(int respnum, int *threadnum, char *group, char *group_path);
Xextern void redraw_page(int respnum, char *group);
Xextern void show_note_page(int respnum, char *group);
Xextern void show_first_header(int respnum, char *group);
Xextern void show_cont_header(int respnum);
Xextern int art_open(long art, char *group_path);
Xextern void art_close(void);
Xextern int prompt_response(int ch, int respnum);
Xextern void yank_to_addr(char *orig, char *addr);
Xextern int show_last_page(void);
Xextern int match_header(char *buf, char *pat, char *body, int len);
X/* post.c */
Xextern int user_posted_messages(void);
Xextern void update_art_posted_file(char *group, int action, char *subj);
Xextern int post_header_ok(char *article);
Xextern int post_base(char *group, int *posted);
Xextern int post_response(char *group, int respnum, int copy_text);
Xextern int mail_to_someone(char *address, int mail_to_poster, int confirm_to_mail, int *mailed_ok);
Xextern int mail_bug_report(void);
Xextern int mail_to_author(char *group, int respnum, int copy_text);
Xextern void find_mail_header(int header, char *file, char *value);
Xextern int cancel_article(char *group, int respnum);
Xextern int crosspost_article(char *group, int respnum);
Xextern int submit_file(char *name);
Xextern void add_signature(FILE *fp, int flag);
Xextern void insert_x_headers(char *infile);
Xextern void find_reply_to_addr(int respnum, char *from_addr);
X/* prompt.c */
Xextern int prompt_num(int ch, char *prompt);
Xextern int prompt_string(char *prompt, char *buf);
Xextern int prompt_menu_string(int line, int col, char *var);
Xextern int prompt_yn(int line, char *prompt, int prompt_ch);
Xextern void prompt_on_off(int row, int col, int *var, char *help_text, char *prompt_text);
Xextern void continue_prompt(void);
X/* rcfile.c */
Xextern int read_rcfile(void);
Xextern void write_rcfile(void);
Xextern int change_rcfile(char *group, int kill_at_once);
Xextern void show_rcfile_menu(void);
Xextern void expand_rel_abs_pathname(int line, int col, char *str);
Xextern void show_menu_help(char *help_message);
Xextern int match_boolean(char *line, char *pat, int *dst);
Xextern int match_number(char *line, char *pat, int *dst);
Xextern int match_string(char *line, char *pat, char *dst, int dstlen);
X/* save.c */
Xextern int check_start_save_any_news(int check_start_save);
Xextern int save_art_to_file(int respnum, int index, int mailbox, char *filename);
Xextern int save_thread_to_file(int is_mailbox, char *group_path);
Xextern int save_regex_arts(int is_mailbox, char *group_path);
Xextern int append_to_existing_file(int i);
Xextern int create_path(char *path);
Xextern int create_sub_dir(int i);
Xextern void add_to_save_list(int index, struct article_t *article, int is_mailbox, char *path);
Xextern void sort_save_list(void);
Xextern int save_comp(char *p1, char *p2);
Xextern char *save_filename(int i);
Xextern char *get_first_savefile(void);
Xextern char *get_last_savefile(void);
Xextern int post_process_files(int proc_type_ch);
Xextern void post_process_uud(int pp);
Xextern void post_process_sh(void);
Xextern char *get_archive_file(char *dir, char *ext);
Xextern void delete_processed_files(void);
X/* screen.c */
Xextern void info_message(char *str);
Xextern void wait_message(char *str);
Xextern void error_message(char *template, char *str);
Xextern void perror_message(char *template, char *str);
Xextern void clear_message(void);
Xextern void center_line(int line, int inverse, char *str);
Xextern void draw_arrow(int line);
Xextern void erase_arrow(int line);
Xextern void show_title(char *title);
Xextern void ring_bell(void);
X/* search.c */
Xextern int search_author(int only_unread, int current_art, int forward);
Xextern void search_group(int forward);
Xextern void search_subject(int forward, char *group);
Xextern int search_article(int forward);
Xextern void make_lower(char *s, char *t);
X/* select.c */
Xextern void selection_index(int start_groupnum);
Xextern void group_selection_page(void);
Xextern int prompt_group_num(int ch);
Xextern void erase_group_arrow(void);
Xextern void draw_group_arrow(void);
Xextern int choose_new_group(void);
Xextern int add_group(char *s, int get_unread);
Xextern int reposition_group(char *group, int default_num);
Xextern void catchup_group(int goto_next_unread_group);
Xextern void next_unread_group(int enter_group);
Xextern void set_groupname_len(int all_groups);
X/* signal.c */
Xextern sigtype_t (*sigdisp(int sig, sigtype_t (*func)()))();
Xextern void set_signal_handlers(void);
Xextern void set_alarm_signal(void);
Xextern void set_alarm_clock_on(void);
Xextern void set_alarm_clock_off(void);
Xextern void signal_handler(int sig);
Xextern int set_win_size(int *num_lines, int *num_cols);
Xextern void set_signals_art(void);
Xextern void set_signals_group(void);
Xextern void set_signals_page(void);
Xextern void set_signals_select(void);
Xextern void set_signals_spooldir(void);
Xextern void set_signals_thread(void);
Xextern void art_suspend(int sig);
Xextern void main_suspend(int sig);
Xextern void select_suspend(int sig);
Xextern void spooldir_suspend(int sig);
Xextern void group_suspend(int sig);
Xextern void page_suspend(int sig);
Xextern void thread_suspend(int sig);
Xextern void rcfile_suspend(int sig);
Xextern void art_resize(int sig);
Xextern void main_resize(int sig);
Xextern void select_resize(int sig);
Xextern void spooldir_resize(int sig);
Xextern void group_resize(int sig);
Xextern void page_resize(int sig);
Xextern void thread_resize(int sig);
X/* spooldir.c */
Xextern int spooldir_index(void);
Xextern void show_spooldir_page(void);
Xextern int prompt_spooldir_num(int ch);
Xextern void erase_spooldir_arrow(void);
Xextern void draw_spooldir_arrow(void);
Xextern int load_spooldirs(void);
Xextern void get_spooldir(void);
Xextern int set_spooldir(char *name);
X/* thread.c */
Xextern int show_thread(int respnum, char *group, char *group_path);
Xextern void show_thread_page(void);
Xextern void update_thread_page(void);
Xextern void draw_thread_arrow(void);
Xextern void erase_thread_arrow(void);
Xextern int prompt_thread_num(int ch);
Xextern int new_responses(int thread);
Xextern int which_thread(int n);
Xextern int which_response(int n);
Xextern int num_of_responses(int n);
Xextern int stat_thread(int n, struct art_stat_t *sbuf);
Xextern int next_response(int n);
Xextern int next_thread(int n);
Xextern int prev_response(int n);
Xextern int choose_response(int i, int n);
Xextern int next_unread(int n);
Xextern int prev_unread(int n);
X/* wildmat.c */
Xextern int wildmat(char *text, char *p);
X 
X#else
X 
X/* active.c */
Xextern void resync_active_file(/*void*/);
Xextern int read_active_file(/*void*/);
Xextern int backup_active(/*int create*/);
Xextern void notify_groups(/*void*/);
Xextern void mark_unthreaded_groups(/*void*/);
Xextern void read_newsgroups_file(/*void*/);
X/* art.c */
Xextern void find_base(/*int only_unread*/);
Xextern int num_of_arts(/*void*/);
Xextern int valid_artnum(/*long art*/);
Xextern int purge_needed(/*void*/);
Xextern void index_group(/*char *group, char *group_path*/);
Xextern int read_group(/*char *group, char *group_path*/);
Xextern void make_threads(/*int rethread*/);
Xextern int parse_headers(/*FILE *fp, struct article_t *h*/);
Xextern void write_index_file(/*char *group*/);
Xextern int read_index_file(/*char *group_name*/);
Xextern void find_index_file(/*char *group*/);
Xextern void do_update(/*void*/);
Xextern char *parse_date(/*char *date, char *str*/);
Xextern int artnum_comp(/*char *p1, char *p2*/);
Xextern int subj_comp(/*char *p1, char *p2*/);
Xextern int from_comp(/*char *p1, char *p2*/);
Xextern int date_comp(/*char *p1, char *p2*/);
Xextern void set_article(/*struct article_t *art*/);
X/* curses.c */
Xextern int InitScreen(/*void*/);
Xextern void ScreenSize(/*int *num_lines, int *num_columns*/);
Xextern void InitWin(/*void*/);
Xextern void EndWin(/*void*/);
Xextern void set_keypad_on(/*void*/);
Xextern void set_keypad_off(/*void*/);
Xextern void ClearScreen(/*void*/);
Xextern void MoveCursor(/*int row, int col*/);
Xextern void CleartoEOLN(/*void*/);
Xextern void CleartoEOS(/*void*/);
Xextern void StartInverse(/*void*/);
Xextern void EndInverse(/*void*/);
Xextern void ToggleInverse(/*void*/);
Xextern int RawState(/*void*/);
Xextern void Raw(/*int state*/);
Xextern int ReadCh(/*void*/);
Xextern int outchar(/*int c*/);
X/* debug.c */
Xextern void debug_nntp(/*char *func, char *line*/);
Xextern void debug_nntp_respcode(/*int respcode*/);
Xextern void debug_print_arts(/*void*/);
Xextern void debug_print_header(/*struct article_t *s*/);
Xextern void debug_print_comment(/*char *comment*/);
Xextern void debug_print_base(/*void*/);
Xextern void debug_print_active(/*void*/);
X/* feed.c */
Xextern void feed_articles(/*int function, int level, char *prompt, int respnum, char *group_path*/);
Xextern int print_file(/*char *command, int respnum, int count*/);
X/* getline.c */
Xextern char *getline(/*char *prompt, int number_only, char *str*/);
X/* group.c */
Xextern void group_page(/*char *group*/);
Xextern void fix_new_highest(/*int groupnum*/);
Xextern void show_group_page(/*char *group*/);
Xextern void update_group_page(/*char *group*/);
Xextern void draw_subject_arrow(/*void*/);
Xextern void erase_subject_arrow(/*void*/);
Xextern void prompt_subject_num(/*int ch, char *group*/);
Xextern void clear_note_area(/*void*/);
Xextern int find_new_pos(/*int old_top, long old_artnum, int cur_pos*/);
Xextern void mark_screen(/*int level, int screen_row, int screen_col, char *value*/);
Xextern void set_subj_from_size(/*int num_cols*/);
Xextern void toggle_subject_from(/*void*/);
X/* hashstr.c */
Xextern char *hash_str(/*char *s*/);
Xextern struct hashnode *add_string(/*char *s*/);
Xextern void hash_init(/*void*/);
Xextern void hash_reclaim(/*void*/);
X/* help.c */
Xextern void show_info_page(/*int type, char *help[], char *title*/);
X/* inews.c */
Xextern int submit_inews(/*char *name*/);
Xextern void get_host_name(/*char *host_name*/);
Xextern void get_from_name(/*char *from_name*/);
X/* init.c */
Xextern void init_selfinfo(/*void*/);
Xextern void set_tindir(/*void*/);
Xextern int create_mail_save_dirs(/*void*/);
X/* kill.c */
Xextern int read_kill_file(/*void*/);
Xextern void write_kill_file(/*void*/);
Xextern int kill_art_menu(/*char *group_name, int index*/);
Xextern int unkill_all_articles(/*void*/);
Xextern int kill_any_articles(/*char *group*/);
Xextern int auto_select_articles(/*char *group*/);
X/* lang.c */
X/* main.c */
Xextern void main(/*int argc, char *argv[]*/);
Xextern void read_cmd_line_options(/*int argc, char *argv[]*/);
Xextern void usage(/*char *progname*/);
Xextern int check_for_any_new_news(/*int check_any_unread, int start_any_unread*/);
Xextern void save_or_mail_new_news(/*void*/);
Xextern void update_index_files(/*void*/);
Xextern void show_intro_page(/*void*/);
X/* memory.c */
Xextern void init_alloc(/*void*/);
Xextern void expand_art(/*void*/);
Xextern void expand_active(/*void*/);
Xextern void expand_kill(/*void*/);
Xextern void expand_save(/*void*/);
Xextern void init_screen_array(/*int allocate*/);
Xextern void free_all_arrays(/*void*/);
Xextern void free_art_array(/*void*/);
Xextern void free_active_arrays(/*void*/);
Xextern void free_kill_array(/*void*/);
Xextern void free_save_array(/*void*/);
Xextern char *my_malloc(/*unsigned size*/);
Xextern char *my_realloc(/*char *p, unsigned size*/);
X/* misc.c */
Xextern void asfail(/*char *file, int line, char *cond*/);
Xextern void copy_fp(/*FILE *fp_ip, FILE *fp_op, char *prefix*/);
Xextern char *get_val(/*char *env, char *def*/);
Xextern int invoke_editor(/*char *nam*/);
Xextern void shell_escape(/*void*/);
Xextern void tin_done(/*int ret*/);
Xextern long hash_groupname(/*char *group*/);
Xextern void rename_file(/*char *old_filename, char *new_filename*/);
Xextern char *str_dup(/*char *str*/);
Xextern int invoke_cmd(/*char *nam*/);
Xextern void draw_percent_mark(/*int cur_num, int max_num*/);
Xextern void set_real_uid_gid(/*void*/);
Xextern void set_tin_uid_gid(/*void*/);
Xextern void basename(/*char *dirname, char *program*/);
Xextern void mail_setup(/*void*/);
Xextern int mail_check(/*void*/);
Xextern void parse_from(/*char *str, char *addr, char *name*/);
Xextern long my_atol(/*char *s, int n*/);
Xextern int my_stricmp(/*char *p, char *q*/);
Xextern char *eat_re(/*char *s*/);
Xextern long hash_s(/*char *s*/);
Xextern void my_strncpy(/*char *p, char *q, int n*/);
Xextern int untag_all_articles(/*void*/);
Xextern char *str_str(/*char *text, char *pattern, int patlen*/);
Xextern void get_author(/*int thread, int respnum, char *str*/);
Xextern void toggle_inverse_video(/*void*/);
Xextern int get_arrow_key(/*void*/);
X/* newsrc.c */
Xextern int auto_subscribe_groups(/*void*/);
Xextern void backup_newsrc(/*void*/);
Xextern void read_newsrc(/*int sub_only*/);
Xextern void write_newsrc(/*void*/);
Xextern void rewrite_newsrc(/*void*/);
Xextern void read_newsrc_line(/*char *group*/);
Xextern void update_newsrc(/*char *group, int groupnum, int mark_unread*/);
Xextern void subscribe(/*char *group, int ch, int num, int out_seq*/);
Xextern void reset_newsrc(/*void*/);
Xextern void delete_group(/*char *group*/);
Xextern int undel_group(/*void*/);
Xextern void mark_group_read(/*char *group, int groupnum*/);
Xextern void parse_seq(/*char *s*/);
Xextern int parse_unread(/*char *s, int groupnum*/);
Xextern int get_line_unread(/*char *group, int groupnum*/);
Xextern void print_seq(/*FILE *fp, int groupnum*/);
Xextern int pos_group_in_newsrc(/*char *group, int pos*/);
Xextern void mark_all_xref_read(/*char *xref_line*/);
X/* nntplib.c */
Xextern char *getserverbyfile(/*char *file*/);
Xextern int server_init(/*char *machine*/);
Xextern int get_tcp_socket(/*char *machine*/);
Xextern int handle_server_response(/*int response, char *nntpserver*/);
Xextern void put_server(/*char *string*/);
Xextern int get_server(/*char *string, int size*/);
Xextern void close_server(/*void*/);
X/* open.c */
Xextern void nntp_open(/*void*/);
Xextern void nntp_close(/*void*/);
Xextern FILE *open_active_fp(/*void*/);
Xextern FILE *open_subscription_fp(/*void*/);
Xextern FILE *open_newsgroups_fp(/*void*/);
Xextern FILE *open_index_fp(/*char *group_name*/);
Xextern FILE *open_art_fp(/*char *group_path, long art*/);
Xextern FILE *open_header_fp(/*char *group_path, long art*/);
Xextern int base_comp(/*char *p1, char *p2*/);
Xextern void setup_base(/*char *group, char *group_path*/);
Xextern int get_respcode(/*void*/);
Xextern int stuff_nntp(/*char *fnam*/);
Xextern FILE *nntp_to_fp(/*void*/);
Xextern void log_user(/*void*/);
Xextern char *nntp_respcode(/*int respcode*/);
X/* page.c */
Xextern int show_page(/*int respnum, int *threadnum, char *group, char *group_path*/);
Xextern void redraw_page(/*int respnum, char *group*/);
Xextern void show_note_page(/*int respnum, char *group*/);
Xextern void show_first_header(/*int respnum, char *group*/);
Xextern void show_cont_header(/*int respnum*/);
Xextern int art_open(/*long art, char *group_path*/);
Xextern void art_close(/*void*/);
Xextern int prompt_response(/*int ch, int respnum*/);
Xextern void yank_to_addr(/*char *orig, char *addr*/);
Xextern int show_last_page(/*void*/);
Xextern int match_header(/*char *buf, char *pat, char *body, int len*/);
X/* post.c */
Xextern int user_posted_messages(/*void*/);
Xextern void update_art_posted_file(/*char *group, int action, char *subj*/);
Xextern int post_header_ok(/*char *article*/);
Xextern int post_base(/*char *group, int *posted*/);
Xextern int post_response(/*char *group, int respnum, int copy_text*/);
Xextern int mail_to_someone(/*char *address, int mail_to_poster, int confirm_to_mail, int *mailed_ok*/);
Xextern int mail_bug_report(/*void*/);
Xextern int mail_to_author(/*char *group, int respnum, int copy_text*/);
Xextern void find_mail_header(/*int header, char *file, char *value*/);
Xextern int cancel_article(/*char *group, int respnum*/);
Xextern int crosspost_article(/*char *group, int respnum*/);
Xextern int submit_file(/*char *name*/);
Xextern void add_signature(/*FILE *fp, int flag*/);
Xextern void insert_x_headers(/*char *infile*/);
Xextern void find_reply_to_addr(/*int respnum, char *from_addr*/);
X/* prompt.c */
Xextern int prompt_num(/*int ch, char *prompt*/);
Xextern int prompt_string(/*char *prompt, char *buf*/);
Xextern int prompt_menu_string(/*int line, int col, char *var*/);
Xextern int prompt_yn(/*int line, char *prompt, int prompt_ch*/);
Xextern void prompt_on_off(/*int row, int col, int *var, char *help_text, char *prompt_text*/);
Xextern void continue_prompt(/*void*/);
X/* rcfile.c */
Xextern int read_rcfile(/*void*/);
Xextern void write_rcfile(/*void*/);
Xextern int change_rcfile(/*char *group, int kill_at_once*/);
Xextern void show_rcfile_menu(/*void*/);
Xextern void expand_rel_abs_pathname(/*int line, int col, char *str*/);
Xextern void show_menu_help(/*char *help_message*/);
Xextern int match_boolean(/*char *line, char *pat, int *dst*/);
Xextern int match_number(/*char *line, char *pat, int *dst*/);
Xextern int match_string(/*char *line, char *pat, char *dst, int dstlen*/);
X/* save.c */
Xextern int check_start_save_any_news(/*int check_start_save*/);
Xextern int save_art_to_file(/*int respnum, int index, int mailbox, char *filename*/);
Xextern int save_thread_to_file(/*int is_mailbox, char *group_path*/);
Xextern int save_regex_arts(/*int is_mailbox, char *group_path*/);
Xextern int append_to_existing_file(/*int i*/);
Xextern int create_path(/*char *path*/);
Xextern int create_sub_dir(/*int i*/);
Xextern void add_to_save_list(/*int index, struct article_t *article, int is_mailbox, char *path*/);
Xextern void sort_save_list(/*void*/);
Xextern int save_comp(/*char *p1, char *p2*/);
Xextern char *save_filename(/*int i*/);
Xextern char *get_first_savefile(/*void*/);
Xextern char *get_last_savefile(/*void*/);
Xextern int post_process_files(/*int proc_type_ch*/);
Xextern void post_process_uud(/*int pp*/);
Xextern void post_process_sh(/*void*/);
Xextern char *get_archive_file(/*char *dir, char *ext*/);
Xextern void delete_processed_files(/*void*/);
X/* screen.c */
Xextern void info_message(/*char *str*/);
Xextern void wait_message(/*char *str*/);
Xextern void error_message(/*char *template, char *str*/);
Xextern void perror_message(/*char *template, char *str*/);
Xextern void clear_message(/*void*/);
Xextern void center_line(/*int line, int inverse, char *str*/);
Xextern void draw_arrow(/*int line*/);
Xextern void erase_arrow(/*int line*/);
Xextern void show_title(/*char *title*/);
Xextern void ring_bell(/*void*/);
X/* search.c */
Xextern int search_author(/*int only_unread, int current_art, int forward*/);
Xextern void search_group(/*int forward*/);
Xextern void search_subject(/*int forward, char *group*/);
Xextern int search_article(/*int forward*/);
Xextern void make_lower(/*char *s, char *t*/);
X/* select.c */
Xextern void selection_index(/*int start_groupnum*/);
Xextern void group_selection_page(/*void*/);
Xextern int prompt_group_num(/*int ch*/);
Xextern void erase_group_arrow(/*void*/);
Xextern void draw_group_arrow(/*void*/);
Xextern int choose_new_group(/*void*/);
Xextern int add_group(/*char *s, int get_unread*/);
Xextern int reposition_group(/*char *group, int default_num*/);
Xextern void catchup_group(/*int goto_next_unread_group*/);
Xextern void next_unread_group(/*int enter_group*/);
Xextern void set_groupname_len(/*int all_groups*/);
X/* signal.c */
Xextern sigtype_t (*sigdisp(/*int sig, sigtype_t (*func)()*/))();
Xextern void set_signal_handlers(/*void*/);
Xextern void set_alarm_signal(/*void*/);
Xextern void set_alarm_clock_on(/*void*/);
Xextern void set_alarm_clock_off(/*void*/);
Xextern void signal_handler(/*int sig*/);
Xextern int set_win_size(/*int *num_lines, int *num_cols*/);
Xextern void set_signals_art(/*void*/);
Xextern void set_signals_group(/*void*/);
Xextern void set_signals_page(/*void*/);
Xextern void set_signals_select(/*void*/);
Xextern void set_signals_spooldir(/*void*/);
Xextern void set_signals_thread(/*void*/);
Xextern void art_suspend(/*int sig*/);
Xextern void main_suspend(/*int sig*/);
Xextern void select_suspend(/*int sig*/);
Xextern void spooldir_suspend(/*int sig*/);
Xextern void group_suspend(/*int sig*/);
Xextern void page_suspend(/*int sig*/);
Xextern void thread_suspend(/*int sig*/);
Xextern void rcfile_suspend(/*int sig*/);
Xextern void art_resize(/*int sig*/);
Xextern void main_resize(/*int sig*/);
Xextern void select_resize(/*int sig*/);
Xextern void spooldir_resize(/*int sig*/);
Xextern void group_resize(/*int sig*/);
Xextern void page_resize(/*int sig*/);
Xextern void thread_resize(/*int sig*/);
X/* spooldir.c */
Xextern int spooldir_index(/*void*/);
Xextern void show_spooldir_page(/*void*/);
Xextern int prompt_spooldir_num(/*int ch*/);
Xextern void erase_spooldir_arrow(/*void*/);
Xextern void draw_spooldir_arrow(/*void*/);
Xextern int load_spooldirs(/*void*/);
Xextern void get_spooldir(/*void*/);
Xextern int set_spooldir(/*char *name*/);
X/* thread.c */
Xextern int show_thread(/*int respnum, char *group, char *group_path*/);
Xextern void show_thread_page(/*void*/);
Xextern void update_thread_page(/*void*/);
Xextern void draw_thread_arrow(/*void*/);
Xextern void erase_thread_arrow(/*void*/);
Xextern int prompt_thread_num(/*int ch*/);
Xextern int new_responses(/*int thread*/);
Xextern int which_thread(/*int n*/);
Xextern int which_response(/*int n*/);
Xextern int num_of_responses(/*int n*/);
Xextern int stat_thread(/*int n, struct art_stat_t *sbuf*/);
Xextern int next_response(/*int n*/);
Xextern int next_thread(/*int n*/);
Xextern int prev_response(/*int n*/);
Xextern int choose_response(/*int i, int n*/);
Xextern int next_unread(/*int n*/);
Xextern int prev_unread(/*int n*/);
X/* wildmat.c */
Xextern int wildmat(/*char *text, char *p*/);
X 
X#endif
END_OF_FILE
  if test 28626 -ne `wc -c <'proto.h'`; then
    echo shar: \"'proto.h'\" unpacked with wrong size!
  fi
  # end of 'proto.h'
fi
echo shar: End of archive 7 \(of 15\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
