Newsgroups: comp.sources.misc
From: iain%anl433.uucp@Germany.EU.net (Iain Lea)
Subject:  v31i012:  tin - threaded full screen newsreader v1.1 PL4, Part12/15
Message-ID: <1992Jul7.181957.7872@sparky.imd.sterling.com>
X-Md4-Signature: f819ab6f185de78ee8eef31ffa05e6eb
Date: Tue, 7 Jul 1992 18:19:57 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: iain%anl433.uucp@Germany.EU.net (Iain Lea)
Posting-number: Volume 31, Issue 12
Archive-name: tin/part12
Environment: BSD, SCO, ISC, SUNOS, SYSVR3, SYSVR4, ULTRIX, XENIX
Supersedes: tin: Volume 30, Issue 1-14

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  FAQ INSTALL kill.c tin.h
# Wrapped by kent@sparky on Mon Jun 29 23:35:14 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 12 (of 15)."'
if test -f 'FAQ' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'FAQ'\"
else
  echo shar: Extracting \"'FAQ'\" \(14588 characters\)
  sed "s/^X//" >'FAQ' <<'END_OF_FILE'
X[ NOTE: IGNORE THIS DOCUMENT UNTIL A LATER DATE - IT IS NOT COMPLETE - Iain ]
X[ THIS DOCUMENT USES THE NN FAQ AS ITS BASE WITH PERMISSION FROM BILL WOHLER]
X
XSubject: TIN Frequently Asked Questions (FAQ) with Answers
XSummary: This document answers Frequently Asked Questions about TIN,
X	 a menu-based, point and shoot, USENET news reader.
XKeywords: FAQ tin news question answer newsrc digest article nntp
X          newsgroup cancel mail signature header netnews usenet kill
XFollowup-To: poster
X
XArchive-name: tin-faq/part01
XLast-modified: 01/05/92
X  
X  This is a living list of frequently asked questions on the Usenet
X  news reader TIN (Tass & Iain's Newsreader). The point of this is to
X  circulate existing information, and avoid rehashing old answers.
X  Better to build on top than start again.  Please read this document
X  before posting to a newsgroup concerning tin.
X  
X  This article is posted monthly.  If it has already expired and
X  you're not reading this, you can hope that you saved the last bit of
X  question 3 so that you can get a copy yourself.
X  
X  When someone posts a frequently-asked question, I will point out to
X  them that the answer is here to ensure that everybody gets their
X  question answered fully and to eliminate unnecessary traffic in this
X  newsgroup.  Posted answers that are in the FAQ are just as annoying as
X  posted questions that are in the FAQ!
X  
X  Your comments, additions and fixes to this list are welcome: please
X  send them to Iain Lea (iain%anl433.uucp@Germany.EU.net).  Complete, 
X  accurate and grammatically correct answers are appreciated to reduce 
X  the time I have to take to test or edit your answers.
X  
X
XFrom: Preface
XSubject: Table of Contents
X
XLegend: + new, - deleted, ! changed
X
XIntroductory
X
X 1.  Why should I use tin?
X 2.  Where can I get tin?
X 3.  What references exist for tin?
X 4.  How should I report bugs?
X 5.  How can I convert from rn to nn?
X 6.  How can I make life simpler when starting nn for the first time?
X 7.  Is there an X interface to tin?
X
XBuilding tin
X
X 10. What machines does tin run on?
X
XUsing tin
X
X 20. How do I save files that I can read later with MH, elm, Mail, ...?
X 21. How come nn doesn't show the Lines count?
X 22. How can I find all articles having to do with a certain topic?
X 23. How can I set a different Organization name?
X 24. Can all non-selected subjects be automatically placed in my kill file?
X 25. Can I automatically kill articles based on the Newsgroups header?
X 26. How can I select one article in a thread with auto-select-subject set?
X 27. Is there a library of macros and other nn features?
X 28. Can one search for patterns in the entire article from the menu?
X 29. How can I remove old articles from folders?
X 30. What's the best way to save multi-part articles?
X 31. When saving in +a/b/c keeps you from saving in +a/b.
X 32. Can I use my mailer to send mail?
X 33. How can I see the original article with the current subject?
X 34. Can I choose newsgroups as I do articles, ie. with a menu?
X 35. How can I post prewritten articles with nn?
X 36. How do I eliminate double signatures?
X 37. How can I make mail replies go to a different machine?
X 38. How come more articles get selected than I expect?  
X 39. Any plans for trn-ish thread following?  
X 40. Setting new-group-action to "ask before adding" doesn't work.
X 41. Why does nn crash when a letter one past the highest letter is selected?
X 42. Why do articles without a Lines header appear empty?
X
XFrom: Preface
XSubject: Viewing This Article
X  
X  To skip to a particular question numbered xx, use "/^F.*xx" with most
X  pagers.  In GNU Emacs type "M-C-s ^F.*xx", (or C-r to search backwards),
X  followed by ESC to end the search.
X  
X  To skip to new or changed questions, use "/^F.*[!+]" with most pagers and
X  "M-C-s ^F.*[!+]" in GNU Emacs.
X  
X  This article is in digest format.  Nn may have already broken this
X  message into separate articles; if not, then type "G %".  In rn, use
X  ^G to skip sections.
X  
X  To get an overview of just the questions in GNU Emacs, type "M-2 C-x $".
X  Use "C-x $" to display the text again ("M-0 C-l C-x $" ensures that
X  the current cursor location remains on the screen).
X  
X  Contributer's E-Mail addresses can be found at the bottom of this article.
X  
X  
XFrom: Intro-1
XSubject: Why should I use tin?
X  
X  tin is a menu based (point and shoot) netnews reader with a complete
X  set of features especially suited to the novice user.  Since its first
X  release in Aug 1991 it has started to replace rn and other well-known
X  news readers at many sites.
X  
X  Some of the key features of tin are:
X  
X  * Automatic kill & selection of articles based on subject or author.
X  
X  *  Based more on Notes and tass than rn type newreaders.
X  *  Full screen, easy to use with on-line help at all levels.
X  *  Reads news locally (ie. /usr/spool/news) and/or via NNTP/INN.
X  *  Threads on Subject: and/or Archive-name: mail headers.
X  *  Four different operating levels:
X     -  Group selection level
X     -  Thread selection level
X     -  Article selection level
X     -  Article viewer
X  *  Same interface to mail, pipe, print & save articles.
X  *  Auto unpacking of multi-part shar & uuencoded articles.
X  *  Auto kill & selection of articles based on subject or author.
X  *  Batch mode to mail/save new news when user is on holiday.
X  *  Builtin NNTP mini-inews & clientlib.c
X  *  NNTP extensions XUSER & XINDEX allow central index files. 
X  
X  
XFrom: Intro-2
XSubject: Where can I get tin?
X  
X  The current version of tin is 1.1 PL3.
X  
X  via anonymous ftp:
X    ftp.Germany.EU.net []
X      pub/news/tin/tin.tar.Z			~250k
X  
X  via mail:
X    Send a note to ftpmail@decwrl.dec.com whose body contains "help"
X    on a line by itself get information on getting ftp sources by
X    mail.
X  
X  
XFrom: Intro-3 !
XSubject: What references exist for tin?
X  
X  Usenet:
X    news.software.readers
X    news.software.notes
X  
X  Mailing list:
X    none
X  
X  
XFrom: Intro-4
XSubject: How should I report bugs?
X  
X  Either mail them to  iain%anl433.uucp@Germany.EU.net  and be sure
X  to include the version number as well as what hardware and operating
X  system you are using, or better yet, use the 'B' bug command within tin.
X  
X  
XFrom: Intro-6
XSubject: How can I make life simpler when starting tin for the first time?
X  
X  tin -c
X  sysadmin can set interesting groups in LIBDIR/subscriptions
X  Subscribe/unsubscribe from uninteresting groups with sSuU commands at
X  group selection level.  
X
X
XFrom: Intro-7 
XSubject: Is there an X interface to tin?
X  
X  No.
X  
X  
XFrom: Building nn-10
XSubject: What machines does tin run on?
X
X  * 386/486 PC & Xenix 2.3.2/SCO SysVR3.2/ISC SysVR3.2/ATT SysVr4.0
X    386 PC & Minix 386 
X    Amdahl & SysVR3
X  * Apollo DN4500 & DomainOS 10.3
X    Apricot VX/FT & SCO 3.2.2
X    Atari STe & Minix 1.5.10.3b
X    Convex C220 & Convex Un*x
X  * Dec 5000/Vax & Ultrix 4.1/4.2
X    DIAB DS90 & D-NIX 5.3
X  * DG Aviion 300 & DG-UX 4.30
X    Harris HCX & CX/UX
X    HP 720/845 & HP-UX 7.0
X    IBM RS/6000 & AIX 3.1.5
X    ICL DRS6000 & SysVR4.0 
X    NCR Tower & SysV
X    Powerbook 140 & MacMinix
X    Sequent S81 & PTX 1.3 / Dynix
X    SGI 4D/35 & IRIX 4.0.1
X  * SNI MX300/MX500 & Sinix 5.22/5.23/5.24/5.4
X  * Sony News & NewsOS 4.1
X  * Sun 3/4/IPC/SS1/SS2 & SunOS 4.0.3/4.1/4.1.1 
X  * Vax 11/785 & BSD 4.3
X
X  * donates that the author has compiled & used tin on that machine.
X
X  
XFrom: Using nn-22
XSubject: How can I find all articles having to do with a certain topic?
X  
X  nngrab invokes nn on all articles whose subject or keyword fields
X  contain a desired keyword.  This shows one how important it is to
X  use descriptive subjects and keywords when posting articles.  For
X  more information, read the manual page.
X  
X  
XFrom: Using nn-23 
XSubject: How can I set a different Organization name?
X  
X  This header (along with the Reply-To:) are user-specified in the
X  init file.  An init file may include the lines:
X  
X  set mail-header Reply-To: steven@Transact.COM;Organization: Transact Software
X  set news-header Reply-To: steven@Transact.COM;Organization: Transact Software
X  
X  You can include any headers that you want in the headers, either in
X  mail or news postings, and they may be different.  --Steven M. List
X  
X  A Reply-To header is useful when your system generates either an
X  unwanted or blatantly wrong return address for you.  If this header
X  is present, then mailers use it instead of the system generated From
X  header.  --Bill Wohler
X  
X  
XFrom: Using nn-28
XSubject: Is the Xref: header used to mark crosposted articles read?
X  
X  No. On the TODO list.
X  
X  
XFrom: Using nn-28
XSubject: Can one search for patterns in the entire article from the menu?
X  
X  No.
X  
X  
XFrom: Using nn-29
XSubject: How can I remove old articles from folders?
X  
X  Just open the folder in the usual way and C(ancel) the articles you
X  want to remove from the folder.  When you leave the folder, nn will
X  rewrite the folder with the "cancel"ed articles removed.  --Kim Storm
X  
X  
XFrom: Using nn-30
XSubject: What's the best way to save multi-part articles?
X  
X  This is VERY easy - all you have to do is to save the articles from
X  the menu, e.g.
X  
X	W(rite) +file.* a b c d... <space>
X  
X  where a b c d... are the articles on the menu you want to save.  You
X  can also save the selected articles on the menu with * (only on
X  current page) or + (on all menu pages).  --Kim Storm
X  
X  
XFrom: Using nn-31 
XSubject: When saving in +a/b/c keeps you from saving in +a/b.
X  
X  This happens when default-save-file is $F.  Try changing
X  default-save-file to $F/$N (my favorite) to get, for example,
X  +news/software/nn/1022, or $G to put everything in
X  +news.software.nn.  Finally, if you really did want the behavior of
X  +$F, a compromise would be to use +$F. (Andrew's favorite) instead
X  (one can use anything other than '.'). --Bill Wohler & Andrew Swann
X  
X  Alternatively, use +$F/$L, to place articles for news.software.nn in
X  the file +/news/software/nn/nn.  This has two advantages:
X  1) You can later read through the folder "nn" and save some of the
X    articles under new folder names having to do with the topic.  For
X    example, you might save auto-select topics under +$F/auto-sel,
X    that is, +/news/software/nn/auto-sel.
X  2) If at a later date, a new newsgroup is added below nn, articles
X    can still be saved under that subgroup since +/news/software/nn is
X    already a directory, not a folder.  --Harry Herman
X  
X  
XFrom: Using nn-33 
XSubject: How can I see the original article with the current subject?
X  
X  While reading an article, use "G RET RET RET".  --Bill Wohler
X  
X  
XFrom: Using nn-35
XSubject: How can I post prewritten articles with nn?
X  
X  nnpost will construct the header for the posted article, so it
X  requires several arguments to be specified before the article is
X  posted, e.g. a newsgroup name and a subject.  If some arguments are
X  missing, nnpost will prompt for the missing arguments.
X  
X  If your pre-written article includes a full header, then you should
X  not use nnpost; instead you should feed the article to "inews -h"
X  directly (which is what nnpost does after building the header from
X  the arguments).  --Kim Storm
X  
X  
XFrom: Using nn-36
XSubject: How do I eliminate double signatures?
X  
X  Double signatures occur when both nn and inews append your .signature
X  file. 
X  
X  If you want inews to append your .signature file, use:
X  
X	unset append-signature-post
X  
X  If you want nn to append your .signature file, you can copy nn's aux
X  file (ie. /usr/local/lib/nn/aux) to your .nn directory and set the
X  mail-script and news-script variables to ~/.nn/aux.  In your copy of
X  the aux script, you can either specify a different place for your
X  .signature file (like $HOME/.nn/signature) or you can get fancy: you
X  can use specific .signatures for certain groups, or use the output of
X  a program.
X  
X  
XFrom: Using nn-37 
XSubject: How can I make mail replies go to a different machine?
X  
X  See "How can I set a different Organization name?"
X  
X  
XFrom: Using nn-39 
XSubject: Any plans for trn-ish thread following?  
X  
X  At the moment, no.
X  
X  
XFrom: Using nn-42 +  
XSubject: Why do articles without a Lines header appear empty?
X  
X  I discovered that this problem only shows up if you have
X  header-lines set to a string that includes "L".  I suspect having
X  the line count patch sets something that makes nn think there is a
X  Lines header and then the header-string is telling it to display the
X  Lines header but there isn't one and things get messed up.  --Gary
X  Morris
X  
X  
XFrom: Appendix
XSubject: Glossary
X  
X  NNTP		Network News Transport Protocol (see RFC 977)
X  
X  
XFrom: Appendix
XSubject: Acknowledgements
X
XI'd like to thank the following people for providing ideas on the
Xlayout of this article:
X
XJoe Wells <jbw@bigbird.bu.edu>	      Richard M. Stallman <rms@gnu.ai.mit.edu>
XDavid Elliott <dce@smsc.sony.com>     Tom Christiansen <tchrist@convex.com>
XEugene N. Miya <eugene@nas.nasa.gov>
X
X
XWe are also grateful to the following individuals that have provided
Xanswers or other information to make this a better document.  The
Xactual list is undoubtedly larger.
X
XF.F. Jacot Guillarmod <ccfj@hippo.ru.ac.za>  Mr. Kim F. Storm <storm@texas.dk>
XSteven M. List <itkin@mrspoc.transact.com>   Steven Grady <grady@fx.com>
XRichard M. Mathews <richard@locus.com>	     Ian Taylor <ian@airs.com>
XDave Shaver <shaver@convex.com>		     Paul Eggert <eggert@twinsun.com>
XMichael Rawdon <rawdon@rex.cs.tulane.edu>    Joerg Napp <napp@uni-paderborn.de>
XDave Hayes <dave@elxr.jpl.nasa.gov>	     Gary Morris <garym@telesoft.com>
XAndrew Swann <swann@imada.ou.dk>	     Alexis Rosen <alexis@panix.com>
XDavid B. Thomas <dt@yenta.alb.nm.us>	     Jeffery Small <jeff@cjsa.wa.com>
XRichard Reiner <rreiner@nexus.yorku.ca>	     Max Heffler <max@compaq.com>
XHarry Herman <herman@corpane.uucp>	     Luc Rooijakkers <lwj@cs.kun.nl>
XPaul Bickerstaff <pbickers@tamaluit.phys.uidaho.edu>
X
X
XFrom: Appendix
XSubject: Warranty
X
X[The following statement epitomizes the ridiculous state of 
Xaffairs in America and can be ignored outside of America...]
X
XNo Warranty: Because this article is provided free of charge as a
Xservice to news.software.readers readers, we provide absolutely no
Xwarranty, to the extent permitted by applicable state law.  This
Xarticle is provided "as is" without warranty of any kind, either
Xexpressed or implied, including, but not limited to, the implied
Xwarranties of merchantability and fitness for a particular purpose.
XShould the information prove defective, you assume the cost of all
Xnecessary servicing, repair or correction.
END_OF_FILE
  if test 14588 -ne `wc -c <'FAQ'`; then
    echo shar: \"'FAQ'\" unpacked with wrong size!
  fi
  # end of 'FAQ'
fi
if test -f 'INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INSTALL'\"
else
  echo shar: Extracting \"'INSTALL'\" \(9003 characters\)
  sed "s/^X//" >'INSTALL' <<'END_OF_FILE'
XCompilation and installation notes for tin - 23-06-92 
X-----------------------------------------------------
X
XTin has been compiled on a wide range of Un*x machines with cc and gcc.
XA list of these machines can be found at the end of this file.
X
XThis file is long (so was the yellow brick road) but please read it all
Xas it could save you problems later and we don't want an unhappy ending
Xdo we? :-)  
X
XTin can be compiled to read news in any of the following ways:
X
X  o  locally from your machines news spool dir (default /usr/spool/news).
X
X  o  locally and remotely (rtin or tin -r option) (-DNNTP_ABLE).
X
X  o  remotely from another machine via NNTP but creating tin index files
X     on local machine for each user in $HOME/.tin/.index (-DNNTP_ONLY).
X
X  o  remotely from another machine via NNTP and also retreiving tin index
X     files from remote machine via NNTP (-DNNTP_ONLY). This
X     option requires that MY NNTP XUSER & XINDEX patches be applied to
X     your NNTP server nntpd. On the NNTP server the index daemon of tin
X     'tind' needs to be run from cron to update the index files at 
X     regular inetervals.
X
X  o  locally from you machines news spool dir (defult /usr/spool/news)
X     and via CD-ROM using pseudo NNTP library with XSPOOLDIR command.
X     (-DCDROM_ABLE) must be defined and tin must be linked with the
X     pseudo NNTP CD-ROM library libcllib.a.
X 
X  o  via CD-ROM only using pseudo NNTP library with XSPOOLDIR command.
X     (-DCDROM_ONLY) must be defined and tin must be linked with the
X     pseudo NNTP CD-ROM library libcllib.a.
X 
XThe -DNNTP_ABLE or -DNNTP_ONLY define must be added to CFLAGS in 
XMakefile and the correct libraries need to be linked to produce
Xan NNTP aware tin.
X
XIf -DCDROM_ABLE is defined tin will not work with normal NNTP. This
Xmay change as the CD-ROM library is further developed.
X
XBuilding Tin (Normal & Daemon versions) 
X---------------------------------------
X
XNormal version
X1)  Type 'make' and a few system types will be displayed.
X2)  Edit Makefile if you want to add/change -D<defines>.
X3)  Type 'make <system type>' to compile for your system.
X4)  Type 'make install' / 'make install_setuid' to install.
X
XNote1: If you want to retreive tin index files from your NNTP server
X      you will have to compile the tind index file daemon so do the
X      following steps:
X
X  1)  Build 'Normal version' of tin as specified by the above 4 points.
X  2)  The tind index daemon needs to be installed on your NNTP server.
X  3)  Apply my NNTP XUSER & XINDEX patches to your nntpd server or this
X      will not work!!!. (If you want tind locally read Note3).  
X  4)  Edit the Makefile and add -DINDEX_DAEMON to your CFLAGS entry and
X      remove any -DNNTP_* defines. Also remove any -lcurses screen type
X      libs as tind does not need to be linked with curses and it will
X      save a good 30-50K on the size of tind.
X  5)  Type 'make <system type>' to compile tind daemon for your NNTP server.
X  6)  Type 'make install_daemon' to install tind daemon on your NNTP server.
X  7)  Add the following line to your system cron to run tind every 30 mins:
X        00,30 * * * * su news -c '/usr/lib/news/tind'
X        
X  Note2: tind must be run as user 'news' and the normal tin must have 
X         the correct permissions to read the central index files!
X  Note3: tind can also be used to update a copy of all index files
X         centrally so each user does not have duplicate files.
X 
X    
XCompiler flags (-D<name> define directives)
X-------------------------------------------
XNews directory structure
X------------------------
X
XLIBDIR
XDefine if news software is not in /usr/lib/news.
X
XINEWSDIR
XDefine if bnews/cnews program 'inews' is not in LIBDIR.
X
XSPOOLDIR
XDefine if news articles are not in /usr/spool/news.
X
X
XReading/posting news via NNTP
X----------------------------- 
X
XNNTP_ABLE
XDefine if you wish to read news locally and remotely via an NNTP server.
X
XNNTP_ONLY
XDefine if you [want to | can] ONLY read news remotely via an NNTP server.
X
XNNTP_INEWS
XDefine if you want to use my builtin NNTP POST routine so that you no
Xlonger have to rely on the mini-inews from NNTP to be installed on each
Xclient machine. Also check that NNTP_INEWS_GATEWAY & NNTP_INEWS_DOMAIN 
Xare correctly set to produce correct From: headers for your site.
X
XNO_NNTP_EXTS
XDefine if you have a *virgin* NNTP server with no extensions. This is just
Xa nicety that will stop tin asking the server if it supports my NNTP server
Xextensions XUSER & XINDEX.
X
XNNTP_INEWS_GATEWAY
XDefines the name of your news gateway machine. Useful if you don't want 
Xyour internal network visable to the outside world.
XExample: I use this define to make all my net postings appear from our news
Xgateway machine 'anl433' even though I post from my own workstation 'sony01'
Xie. -DNNTP_INEWS_GATEWAY=\"anl433\"
XIf the first letter of the string is '/' the gateway name will be read from 
Xthe specified file.
X
XNNTP_INEWS_DOMAIN
XDefines the name of your network domain. 
XExample: I use this define to add our uucp domain '.uucp' to our news 
Xgateways machine address 'anl433.uucp'.
Xie. -DNNTP_INEWS_DOMAIN=\".uucp\"
XIf the first letter of the string is '/' the domain name will be read from 
Xthe specified file.
X
XNNTP_SERVER_FILE
XOnly define if your nntpserver file is other than /etc/nntpserver.
X
XNETLIBS
XContains the networking libraries needed to link with clientlib.o file.
X
X
XReading news via CD-ROM
X-----------------------
X
XCDROM_ABLE
XDefine if you wish to read news locally and from CD-ROM.
X
XCDROM_ONLY
XDefine if you [want to | can] ONLY read news from CD-ROM.
X
X
XDaemon options
X--------------
X
XINDEX_DAEMON
XDefine to make an index file updating daemon version of tin. Note that
Xno -lcurses or screen libraries need to be linked with tin when this
X#define is specified. If defined this will automatically undefine all
XNNTP_* defines as the daemon has to be installed on the NNTP server.
X
X
XMiscellaneous options
X---------------------
X
XSIGTYPE=[void | int]
XDefine only if incorrect pointer type warnings occur during compilition.
XSIGTYPE is already defined in tin.h for most compilers signal() call.
XBy defining this you will override the default action in tin.h.
X 
XPOSIX_JOB_CONTROL
XDefine if your machine uses Posix style sigaction() signal handling.
X
XUSE_MKDIR
XDefine if your machine does not have the mkdir() system call.
X
XUSE_LONG_FILENAMES
XDefine if your machines filesystem supports filenames longer than 14
Xchars (default for BSD type systems).
X
XUSE_INVERSE_HACK
XDefine if you want inverse video and highlighted bar disabled. (default
Xfor SCO Unix & SysVR4).  Can be toggled in tin by the 'I' command and
Xhighlight bar by 'M' command.
X
XUSE_CLEARSCREEN
XDefine if the you wish screen to use ClearScreen() and not MoveCursor()
Xand CleartoEOLN(). This is perhaps faster on slow terminals but I have
Xnot really run any speed tests recently.
X
XUSE_SETREUID
XDefine if problems occur when runnung tin as setuid news. Only define if
Xyour system supports the setreuid() system call.
X
XSLOW_SCREEN_UPDATE
XDefine if running over a low speed connection (ie. 2400baud). It stops
Xthe percentage info being shown at bottom of select and group menus and
Xstops the groupname being displayed at the bottom of the screen as it is
Xsubscribed/unsubscribed.
X
XSMALL_MEMORY_MACHINE
XDefine if you are running a machine with little memory (<4MB). Tin will
Xrun slightly slower but be more efficent in how memory is allocated and
Xreclaimed.
X 
XNO_REGEX
XDefine if you do not want to use regular expression pattern matching.
X
XNO_SHELL_ESCAPE
XDo not allow shell escapes.
X
XNO_POSTING
XDo not allow posting/followup of articles.
X
XNO_RESYNC_ACTIVE_FILE
XDo not reread active every RESYNC_ACTIVE_SECS.
X
XLOG_USER
XLog username & info to /tmp/.tin_log for usage statistics. If reading via
XNNTP the NNTP XUSER extended command will log user info to NNTP server.
XIf -DNNTP_XUSER is defined it will define LOG_USER automatically.
X
XDEBUG
XDefine if you want tin to log debug info. to files in /tmp. Activated
Xby tin -Dn where n is 1 for NNTP only debug logging and n is 2 for 
Xlogging all debug info. Debug files written to /tmp are ARTS, ACTIVE,
XBASE and NNTP.
X
X
XCompiled & installed on the following machines
X----------------------------------------------
X
X1) * 386 PC & Xenix 2.3.2/SCO SysVR3.2/ISC SysVR3.2/ATT SysVr4.0
X2) * Sony News & NewsOS 4.1
X3) * SNI MX300/MX500 & Sinix 5.22/5.23/5.24/5.4
X4) * Sun 3/4/IPC/SS1/SS2 & SunOS 4.0.3/4.1/4.1.1 
X5) * Dec 5000/Vax & Ultrix 4.1/4.2
X6) * Vax 11/785 & BSD 4.3
X7) * DG Aviion 300 & DG-UX 4.30
X8) * Apollo DN4500 & DomainOS 10.3
X9)   ICL DRS6000 & SysVR4.0 
X10)  Apricot VX/FT & SCO 3.2.2
X11)  DIAB DS90 & D-NIX 5.3
X12)  Amdahl & SysVR3
X13)  HP 720/845 & HP-UX 7.0
X14)  IBM RS/6000 & AIX 3.1.5
X15)  NCR Tower & SysV
X16)  Atari STe & Minix 1.5.10.3b
X17)  Powerbook 140 & MacMinix
X18)  386 PC & Minix 386
X19)  Sequent S81 & PTX 1.3 / Dynix
X20)  Convex C220 & Convex Un*x
X21)  Harris HCX & CX/UX
X22)  SGI 4D/35 & IRIX 4.0.1
X23)  Pyramid 9810 & OSx96N
X
X* = compiled, installed and used by author 
END_OF_FILE
  if test 9003 -ne `wc -c <'INSTALL'`; then
    echo shar: \"'INSTALL'\" unpacked with wrong size!
  fi
  # end of 'INSTALL'
fi
if test -f 'kill.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kill.c'\"
else
  echo shar: Extracting \"'kill.c'\" \(13051 characters\)
  sed "s/^X//" >'kill.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : kill.c
X *  Author    : I.Lea & J.Robinson
X *  Created   : 01-04-91
X *  Updated   : 20-06-92
X *  Notes     : kill & auto select (hot) articles
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Jim Robinson
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
X#ifdef NO_REGEX 
Xchar *stars = "";
X#else		
Xchar *stars = "*";
X#endif
X
X#define SET_KILLED(i)		(arts[i].unread = ART_READ, arts[i].killed = 1, num_of_killed_arts++)
X#define SET_HOT(i)		(arts[i].hot = 1)
X#define IS_READ(i)		(arts[i].unread == ART_READ)
X#define IS_KILLED(i)		(arts[i].killed == 1)
X
X#define KILL_CHAR	'K'
X#define HOT_CHAR	'H'
X
X#define K_KILL		0
X#define K_HOT		1
X
Xint kill_level = 1;
Xint kill_num = 0;
Xint max_kill;
Xstruct kill_t *killf;
X
X/*
X *  read_kill_file - read ~/.tin/kill file contents into kill array
X */
X
Xint read_kill_file ()
X{
X	char buf[LEN];
X	FILE *fp;
X	int n;
X	char c;
X	unsigned int type;
X
X	free_kill_array ();
X	
X	if ((fp = fopen (killfile, "r")) == NULL) {
X		return FALSE;
X	}
X
X	kill_num=0;
X	while (fgets (buf, sizeof buf, fp) != NULL) {
X		if (buf[0] == '#') {
X			continue;
X		}	
X		if (kill_num == max_kill-1) {
X			expand_kill ();
X		}
X		n = sscanf(buf, "%d %c", &type, &c);
X		if (n == 0) {
X			goto corrupt_killfile;
X		}	
X		if (n > 1 && c == HOT_CHAR) {	/* hot */
X			 killf[kill_num].kill_how = K_HOT;
X		} else {
X			 killf[kill_num].kill_how = K_KILL;
X		}	 
X		killf[kill_num].kill_type = type;
X
X		if (fgets (buf, sizeof buf, fp) == NULL)  {
X			goto corrupt_killfile;
X		}
X		
X		killf[kill_num].kill_group = (long) atol (buf);
X
X		switch (killf[kill_num].kill_type) {
X		case KILL_SUBJ:
X			if (fgets (buf, sizeof buf, fp) != NULL) {
X				buf[strlen (buf)-1] = '\0';
X				killf[kill_num].kill_subj = str_dup (buf);
X			}
X			break;
X		case KILL_FROM:
X			if (fgets (buf, sizeof buf, fp) != NULL) {
X				buf[strlen (buf)-1] = '\0';
X				killf[kill_num].kill_from = str_dup (buf);
X			}
X			break;
X		case KILL_BOTH:
X			if (fgets (buf, sizeof buf, fp) != NULL) {
X				buf[strlen (buf)-1] = '\0';
X				killf[kill_num].kill_subj = str_dup (buf);
X			}
X			if (fgets (buf, sizeof buf, fp) != NULL) {
X				buf[strlen (buf)-1] = '\0';
X				killf[kill_num].kill_from = str_dup (buf);
X			}
X			break;
X		default:
X			goto corrupt_killfile;
X		}
X		kill_num++;
X	}
X
X	fclose (fp);
X	return (kill_num);
X
Xcorrupt_killfile:
X	fclose (fp);
X	killf[kill_num].kill_type = 0;
X	error_message (txt_corrupt_kill_file, killfile);
X	return FALSE;
X}
X
X/*
X *  write_kill_file - write kill strings to ~/.tin/kill
X */
X
Xvoid write_kill_file ()
X{
X	FILE *fp;
X	int i;
X	
X	if (kill_num == 0 || (fp = fopen (killfile, "w")) == NULL) {
X		return;
X	}
X
X	wait_message (txt_saving);
X	fprintf (fp, "# 1st line  1=(Subject: only)  2=(From: only)  3=(Subject: & From:)\n");
X	fprintf (fp, "#           %c=(kill) %c=(auto-selection)\n", KILL_CHAR, HOT_CHAR);
X	fprintf (fp, "# 2nd line  0=(kill on all newsgroups)  >0=(kill on specific newsgroup)\n");
X	for (i=0 ; i < kill_num ; i++) {
X		if (killf[i].kill_type == 0 || (killf[i].kill_subj == 0 
X		    &&  killf[i].kill_from == 0)) 
X			continue;
X
X		if (killf[i].kill_how == K_KILL) {
X			fprintf (fp, "#\n# %03d KILL\n", i+1);
X			fprintf (fp, "%d\t%c\n", killf[i].kill_type, KILL_CHAR);
X		} else {
X			fprintf (fp, "#\n# %03d HOT\n", i+1);
X			fprintf (fp, "%d\t%c\n", killf[i].kill_type, HOT_CHAR);
X		}	
X		fprintf (fp, "%ld\n", killf[i].kill_group);
X
X		switch (killf[i].kill_type) {
X			case KILL_SUBJ:
X				fprintf (fp, "%s\n", killf[i].kill_subj);
X				break;
X			case KILL_FROM:
X				fprintf (fp, "%s\n", killf[i].kill_from);
X				break;
X			case KILL_BOTH:
X				fprintf (fp, "%s\n", killf[i].kill_subj);
X				fprintf (fp, "%s\n", killf[i].kill_from);
X				break;
X		}
X	}
X
X	fclose (fp);
X	chmod (killfile, 0600);
X
X	set_tin_uid_gid ();
X}
X
Xstatic int get_choice (x, help, prompt, opt1, opt2, opt3, opt4)
X	int x;
X	char *help, *prompt, *opt1, *opt2, *opt3, *opt4;
X{
X	int ch, n = 0, i = 0;
X	char *argv[4];
X	
X	if (opt1)
X		argv[n++] = opt1;
X	if (opt2)
X		argv[n++] = opt2;
X	if (opt3)
X		argv[n++] = opt3;
X	if (opt4)
X		argv[n++] = opt4;
X	assert(n > 0);
X
X	if (help)
X		show_menu_help (help);
X		
X	do {
X		MoveCursor(x, (int) strlen (prompt));
X		fputs (argv[i], stdout);
X		fflush (stdout);
X		CleartoEOLN (); 
X		if ((ch = ReadCh ()) != ' ')
X			continue;
X		if (++i == n)
X			i = 0;
X	} while (ch != CR && ch != ESC);
X
X	if (ch == ESC)
X		return (-1);
X	return (i);
X}
X
X/*
X *  options menu so that the user can dynamically change parameters
X */
X 
Xint kill_art_menu (group_name, index)
X	char *group_name;
X	int index;
X{
X	char buf[LEN];
X	char text[LEN];
X	char kill_from[LEN];
X	char kill_subj[LEN];
X	char kill_group[LEN];
X	char ch_default = 's';
X	int ch;
X	int counter = 0;
X	int killed = TRUE;
X	int kill_from_ok = FALSE;
X	int kill_subj_ok = FALSE;
X	int kill_every_group = FALSE;
X	int i;
X	int kill_how;
X
X#ifdef SIGTSTP
X	sigtype_t (*susp)();
X	
X	susp = (sigtype_t *) 0;
X
X	if (do_sigtstp) {
X		susp = sigdisp (SIGTSTP, SIG_DFL);
X		sigdisp (SIGTSTP, SIG_IGN);
X	}
X#endif
X	
X	sprintf (kill_group, "%s only", group_name);
X	sprintf (kill_subj, txt_kill_subject, COLS-35, COLS-35, arts[index].subject);
X	if (arts[index].name != (char *) 0) {
X		sprintf (text, "%s (%s)", arts[index].from, arts[index].name);
X	} else {
X		strcpy (text, arts[index].from);
X	}
X	sprintf (kill_from, txt_kill_from, COLS-35, COLS-35, text);
X	text[0] = '\0';
X	
X	ClearScreen ();
X
X	center_line (0, TRUE, txt_kill_menu);
X	
X	MoveCursor (INDEX_TOP, 0);
X	printf ("%s\r\n\r\n\r\n", txt_kill_how);
X	printf ("%s\r\n\r\n", txt_kill_text);
X	printf ("%s\r\n\r\n\r\n", txt_kill_text_type);
X	printf ("%s\r\n\r\n", kill_subj);
X	printf ("%s\r\n\r\n\r\n", kill_from);
X	printf ("%s%s", txt_kill_group, kill_group);
X	fflush (stdout);
X
X	i = get_choice (INDEX_TOP, txt_help_kill_how, txt_kill_how, 
X		       "Kill       ", "Auto Select", NULL, NULL);
X	if (i == -1) {
X		return FALSE;
X	}	
X	kill_how = (i == 0 ? K_KILL : K_HOT);
X
X	show_menu_help (txt_help_kill_text);
X	
X	if (! prompt_menu_string (INDEX_TOP+3, (int) strlen (txt_kill_text), text)) {
X		return FALSE;
X	}
X
X	if (text[0]) {
X		i = get_choice(INDEX_TOP+5, txt_help_kill_text_type, 
X			       txt_kill_text_type, "Subject: line only    ", 
X			       "From: line only       ", "Subject: & From: lines", 
X			       NULL);
X		if (i == -1) {
X			return FALSE;
X		}	
X		counter = ((i == 0 ? KILL_SUBJ : (i == 1 ? KILL_FROM : KILL_BOTH)));
X	}
X
X	if (! text[0]) {
X		i = get_choice (INDEX_TOP+8, txt_help_kill_subject, 
X			        kill_subj, "Yes", "No ", NULL, NULL);
X		if (i == -1) {
X			return FALSE;
X		} else {
X			kill_subj_ok = (i ? FALSE : TRUE);
X		}
X		i = get_choice (INDEX_TOP+10, txt_help_kill_from, 
X			        kill_from, "No ", "Yes", NULL, NULL);
X		if (i == -1) {
X			return FALSE;
X		} else {
X			kill_from_ok = (i ? TRUE : FALSE);
X		}
X	}
X
X	if (text[0] || kill_subj_ok || kill_from_ok) {
X		i = get_choice (INDEX_TOP+13, txt_help_kill_group, 
X			       txt_kill_group, kill_group, "All groups", 
X			       NULL, NULL);
X		if (i == -1) {
X			return FALSE;
X		}	
X		kill_every_group = (i == 0 ? FALSE : TRUE);
X	}
X
X	while (1) {
X		do {
X			sprintf (msg, "%s%c", txt_quit_edit_save_killfile, ch_default);
X			wait_message (msg);
X			MoveCursor (LINES, (int) strlen (txt_quit_edit_save_killfile));
X			if ((ch = ReadCh ()) == CR)
X				ch = ch_default;
X		} while (ch != ESC && ch != 'q' && ch != 'e' && ch != 's');
X		switch (ch) {
X		case 'e':
X			start_line_offset = 2;
X			invoke_editor (killfile);
X			unkill_all_articles ();
X			killed_articles = read_kill_file ();
X			killed = TRUE;
X			goto kill_done;
X
X		case 'a':
X		case ESC:
X			killed = FALSE;
X			goto kill_done;
X			
X		case 's':
X			if (kill_num > max_kill-1) {
X				expand_kill ();
X			}
X
X			killf[kill_num].kill_how = kill_how;
X
X			if (text[0]) {
X				sprintf (buf, "%s%s%s", stars, text, stars);
X				switch (counter) {
X				case KILL_SUBJ:
X					killf[kill_num].kill_subj = str_dup (buf);
X					break;
X				case KILL_FROM:
X					killf[kill_num].kill_from = str_dup (buf);
X					break;
X				case KILL_BOTH:
X					killf[kill_num].kill_subj = str_dup (buf);
X					killf[kill_num].kill_from = killf[kill_num].kill_subj; 
X					break;
X				}
X				killf[kill_num].kill_type = counter;
X				if (kill_every_group) {
X					killf[kill_num].kill_group = 0L;
X				} else {
X					killf[kill_num].kill_group = hash_s (group_name);
X				}
X				kill_num++;
X			} else {
X				if (kill_subj_ok) {
X					killf[kill_num].kill_type = KILL_SUBJ;
X					sprintf (buf, "%s%s%s", 
X						stars, arts[index].subject, stars);
X					killf[kill_num].kill_subj = str_dup (buf);
X				}
X				if (kill_from_ok) {
X					killf[kill_num].kill_type |= KILL_FROM;
X					if (arts[index].name != (char *) 0) {
X						sprintf (buf, "%s%s (%s)%s", 
X							stars, arts[index].from, arts[index].name, stars);
X					} else {
X						sprintf (buf, "%s%s%s", 
X							stars, arts[index].from, stars);
X					}
X					killf[kill_num].kill_from = str_dup (buf);
X				}
X				if (killf[kill_num].kill_type) {		
X					if (kill_every_group) {
X						killf[kill_num].kill_group= 0L;
X					} else {
X						killf[kill_num].kill_group= hash_s (group_name);
X					}
X					kill_num++;
X				}
X			}
X			write_kill_file ();
X			
X		kill_done:
X			
X#ifdef SIGTSTP
X			if (do_sigtstp) {
X				sigdisp (SIGTSTP, susp);
X			}
X#endif
X			return (killed);
X		}	
X	}
X	/* NOTREACHED */
X}
X
X
X/*
X * We assume that any articles which are tagged as killed are also
X * tagged as being read BECAUSE they were killed. So, we retag
X * them as being unread.
X */
X 
Xint unkill_all_articles ()
X{
X	int unkilled = FALSE;
X	register int i;
X
X	for (i=0 ; i < top ; i++) {
X		if (arts[i].killed) {
X			arts[i].killed = FALSE;
X			arts[i].unread = ART_UNREAD;
X			unkilled = TRUE;
X		}
X	}
X	num_of_killed_arts = 0;
X
X	return (unkilled);
X}
X
X
Xint kill_any_articles (group)
X	char *group;
X{
X	char buf[LEN];
X	int killed = FALSE;
X	int run_ok = FALSE;
X	int is_hot;
X	long newsgroup_hash;
X	register int i, j;
X
X	if (! kill_num) {
X		return (killed);
X	}
X
X	num_of_killed_arts = 0;
X	num_of_hot_arts = 0;
X
X	newsgroup_hash = hash_s (group);
X
X	for (i=0 ; i < kill_num ; i++) {
X		if (killf[i].kill_group == 0L ||
X		    killf[i].kill_group == newsgroup_hash) {
X			run_ok = TRUE;	
X		}
X	}
X	if (! run_ok) {
X		return (killed);
X	}
X	if (debug && ! update) {
X		wait_message (txt_killing_arts);
X	}
X	for (i=0 ; i < top ; i++) {
X		if (IS_READ(i) && kill_level == 0) {
X			continue;
X		}	
X		for (j=0 ; j < kill_num ; j++) {
X			if (killf[j].kill_group != 0L &&
X			    killf[j].kill_group != newsgroup_hash)
X				continue;
X
X			is_hot = (killf[j].kill_how == K_HOT ? TRUE : FALSE);
X			switch (killf[j].kill_type) {
X			case KILL_SUBJ:
X				if (STR_MATCH (arts[i].subject, killf[j].kill_subj)) {
X					if (! is_hot) {
X						SET_KILLED(i);
X					} else {
X						SET_HOT(i);
X						if (show_only_unread) {
X							if (arts[i].unread == ART_UNREAD) {
X								num_of_hot_arts++;
X							}
X						} else {
X							num_of_hot_arts++;
X						}
X					}	
X				}
X				break;
X			case KILL_FROM:
X				if (arts[i].name != (char *) 0) {
X					sprintf (buf, "%s (%s)", arts[i].from, arts[i].name);
X				} else {
X					strcpy (buf, arts[i].from);
X				}
X				if (STR_MATCH (buf, killf[j].kill_from)) {
X					if (! is_hot) {
X						SET_KILLED(i);
X					} else {
X						SET_HOT(i);
X						if (show_only_unread) {
X							if (arts[i].unread == ART_UNREAD) {
X								num_of_hot_arts++;
X							}
X						} else {
X							num_of_hot_arts++;
X						}
X					}	
X				}
X				break;
X			case KILL_BOTH:
X				if (STR_MATCH (arts[i].subject, killf[j].kill_subj)) {
X					if (! is_hot) {
X						SET_KILLED(i);
X					} else {
X						SET_HOT(i);
X						if (show_only_unread) {
X							if (arts[i].unread == ART_UNREAD) {
X								num_of_hot_arts++;
X							}
X						} else {
X							num_of_hot_arts++;
X						}
X					}	
X					break;
X				}
X				if (arts[i].name != (char *) 0) {
X					sprintf (buf, "%s (%s)", arts[i].from, arts[i].name);
X				} else {
X					strcpy (buf, arts[i].from);
X				}
X
X				if (STR_MATCH (buf, killf[j].kill_from)) {
X					if (! is_hot) {
X						SET_KILLED(i);
X					} else {
X						SET_HOT(i);
X						if (show_only_unread) {
X							if (arts[i].unread == ART_UNREAD) {
X								num_of_hot_arts++;
X							}
X						} else {
X							num_of_hot_arts++;
X						}
X					}	
X				}
X				break;
X			}
X			if (IS_KILLED(i) || ! killed)
X				killed = TRUE;
X		}
X	}
X	return (killed);
X}
X
X/*
X * Auto select articles.
X * WARNING - this routinely is presently a kludge. It calls
X * kill_any_articles() which also kills articles. It also always returns
X * true in order to fake out the display code (cause it doesn't know
X * if any articles were actually selected)
X * The correct way to do this is to modify kill_any_articles() to take
X * another arg to specify whether killing, auto-selecting, or both is to be 
X * done, rename it to something else, and then have a new kill_any_articles()
X * and auto_select_articles() call this new routine with the appropriate 
X * arguments.
X */
X
Xint auto_select_articles (group)
X	char *group;
X{
X	kill_any_articles (group);
X	return (TRUE);
X}
END_OF_FILE
  if test 13051 -ne `wc -c <'kill.c'`; then
    echo shar: \"'kill.c'\" unpacked with wrong size!
  fi
  # end of 'kill.c'
fi
if test -f 'tin.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tin.h'\"
else
  echo shar: Extracting \"'tin.h'\" \(14455 characters\)
  sed "s/^X//" >'tin.h' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : tin.h
X *  Author    : I.Lea & R.Skrenta
X *  Created   : 01-04-91
X *  Updated   : 22-06-92
X *  Notes     : #include files, #defines & struct's
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	<stdio.h>
X#include	<signal.h>
X#include	<errno.h>
X#ifdef apollo
X#	include </bsd4.3/usr/include/sys/types.h>
X#else
X#	include <sys/types.h>
X#endif
X#include	<sys/stat.h>
X#include	<pwd.h>
X#include	<ctype.h>
X#include	<time.h>
X#if !defined(apollo) && !defined(__NeXT__)
X#	include	<unistd.h>
X#endif
X
X#ifdef BSD
X#	include	<strings.h>
X#	include	<fcntl.h>
X#else
X#	ifndef apollo
X#		include	<stdlib.h>
X#	endif
X#	include	<string.h>
X#endif
X
X#ifndef MINIX
X#	include <sys/ioctl.h>
X#endif
X
X#ifdef M_XENIX
X#	include	<prototypes.h>
X#endif
X
X#ifdef SVR4
X#	include <locale.h>
X#endif
X
X#if !defined(BSD) && !defined(sinix) && !defined(RS6000)
X#	include	<sys/utsname.h>
X#endif
X
X/*
X * Needed for catching child processes
X */
X
X#ifdef SIGCHLD
X#	include	<sys/wait.h>
X#endif
X
X/*
X * Needed for resizing under an xterm
X */
X
X#if defined(SIGWINCH)
X#	ifndef SCO_UNIX
X#		include <termios.h>
X#	endif
X#	if !defined(TIOCGWINSZ) && !defined(TIOCGSIZE)
X#		if !defined(sinix) && !defined(nsc)
X#			include <sys/stream.h>
X#			ifdef PTX
X#				include <termio.h>
X#			else
X#				ifndef apollo
X#					include <sys/ptem.h>
X#					include <sys/tty.h>
X#				endif
X#				if !defined(SCO_UNIX) && !defined(SVR4) && !defined(apollo)
X#					ifndef _h_BSDTYPES
X#						include <sys/bsdtypes.h>
X#					endif
X#					include <sys/pty.h>
X#				endif
X#			endif
X#		endif
X#	endif
X#endif
X
X/*
X * Setup support for reading from CD-ROM
X */
X
X#ifdef CDROM_ONLY
X#	define CDROM_ABLE
X#endif
X 
X#ifdef CDROM_ABLE
X#	define XSPOOLDIR
X#	define NNTP_ABLE
X#	undef NNTP_ONLY
X#	undef NNTP_INEWS
X#endif
X
X/*
X * Setup support for reading from NNTP
X */
X 
X#if defined(NNTP_ABLE) || defined(NNTP_ONLY)
X#	ifndef NNTP_ABLE
X#		define	NNTP_ABLE
X#	endif
X#	ifndef NNTP_INEWS
X#		define	NNTP_INEWS
X#	endif
X#endif
X
X/*
X * Index file daemon version of tin. Will create/update index files from cron
X * on NNTP server machine so clients can retreive index file with NNTP XINDEX
X * command from server. Also can be used on machines that just want one copy
X * of all the index files in one place. In this case the normal tin must have
X * access to the index directory (-I dir option) or be setuid news.
X */
X 
X#ifdef INDEX_DAEMON
X#	define	LOCK_FILE "/tmp/tind.LCK"
X#	undef	NNTP_ABLE
X#	undef	NNTP_ONLY
X#	undef	NNTP_INEWS
X#endif
X
X/*
X * Determine signal return type
X */
X 
X#if defined(__GNUC__) || defined(POSIX_JOB_CONTROL)
Xtypedef void sigtype_t;
X#else	
X#	if defined(sony)
Xtypedef int sigtype_t;
X#	else
X#		if __STDC__ || defined(SVR4) || defined(sinix) || defined(sun) || \
X		   defined(ultrix) || defined(atthcx) || defined(PTX) || defined(sgi)
Xtypedef void sigtype_t;
X#		else
Xtypedef int sigtype_t;
X#		endif
X#	endif
X#endif
X
X/*
X * Specify News spool & control directories
X */
X 
X#ifndef SPOOLDIR
X#	define		SPOOLDIR	"/usr/spool/news"
X#endif
X#ifndef LIBDIR
X#	define		LIBDIR		"/usr/lib/news"
X#endif
X#ifndef INEWSDIR
X#	define		INEWSDIR	LIBDIR
X#endif
X
X/*
X * Determine machine configuration for external programs & directories
X */
X
X#ifdef BSD
X#	if defined(_SEQUENT_) || defined(pyr)
X#		define		memcmp(s1, s2, n)	bcmp(s2, s1, n)
X#	endif
X#	define		strchr(str, ch)	index(str, ch)
X#	define		DEFAULT_SHELL	"/bin/csh"
X#	define		DEFAULT_EDITOR	"/usr/ucb/vi"
X#	define		DEFAULT_PRINTER	"/usr/ucb/lpr"
X#	define		DEFAULT_SUM	"sum"
X#	ifdef DGUX
X#		define		DEFAULT_MAILER	"/bin/mail"
X#		define		DEFAULT_MAILBOX	"/usr/mail"
X#		define		POSIX_JOB_CONTROL
X#		define		USE_INVERSE_HACK
X#	endif
X#	ifdef pyr
X#		define		DEFAULT_MAILER	"/usr/.attbin/mailx"
X#	endif
X#	ifndef DEFAULT_MAILER
X#		define		DEFAULT_MAILER	"/usr/ucb/Mail"
X#	endif
X#	ifndef DEFAULT_MAILBOX
X#		define		DEFAULT_MAILBOX	"/usr/spool/mail"
X#	endif
X#	ifndef USE_LONG_FILENAMES
X#		define USE_LONG_FILENAMES
X#	endif
X#else
X#	ifdef M_XENIX
X#		define		DEFAULT_EDITOR	"/bin/vi"
X#		define		DEFAULT_MAILER	"/usr/bin/mail"
X#		define		DEFAULT_MAILBOX	"/usr/spool/mail"
X#	endif
X#	if defined(NCR) || defined(atthcx) || defined(HPUX)
X#		define		DEFAULT_MAILER	"/usr/bin/mailx"
X#	endif
X#	ifdef PTX
X#		define		DEFAULT_MAILER	"/usr/bin/mailx"
X#		ifndef USE_LONG_FILENAMES
X#			define	USE_LONG_FILENAMES
X#		endif
X#	endif
X#	ifdef RS6000
X#		define		DEFAULT_MAILER	"/usr/bin/mail"
X#		define		DEFAULT_PRINTER	"/bin/lp"
X#	endif
X#	ifdef sinix
X#		define		DEFAULT_MAILER	"/bin/rmail"
X#		define		DEFAULT_PRINTER	"/bin/lpr"
X#		ifndef USE_LONG_FILENAMES
X#			define USE_LONG_FILENAMES
X#		endif
X#	endif
X#	ifdef SVR4
X#		define		POSIX_JOB_CONTROL
X#		ifndef USE_LONG_FILENAMES
X#			define	USE_LONG_FILENAMES
X#		endif
X#	endif
X#	ifdef UNIXPC
X#		define		DEFAULT_MAILER	"/bin/rmail"
X#	endif
X#	ifndef DEFAULT_SHELL
X#		define		DEFAULT_SHELL	"/bin/sh"
X#	endif
X#	ifndef DEFAULT_EDITOR
X#		define		DEFAULT_EDITOR	"/usr/bin/vi"
X#	endif
X#	ifndef DEFAULT_MAILBOX
X#		define		DEFAULT_MAILBOX	"/usr/mail"
X#	endif
X#	ifndef DEFAULT_MAILER
X#		define		DEFAULT_MAILER	"/bin/mail"
X#	endif
X#	ifndef DEFAULT_PRINTER
X#		define		DEFAULT_PRINTER	"/usr/bin/lp"
X#	endif
X#	define		DEFAULT_SUM		"sum -r"
X#endif
X
X#ifdef USE_LONG_FILENAMES
X#	define		LONG_PATH_PART	"part"
X#	define		LONG_PATH_PATCH	"patch"
X#else
X#	define		LONG_PATH_PART	""
X#	define		LONG_PATH_PATCH	"p"
X#endif
X
X/*
X * Useful for logging user usage
X */
X 
X#ifdef LOG_USER
X#	define		LOG_USER_FILE	"/tmp/.tin_log" 
X#endif
X
X/*
X * Should active file be rereaf for new news & if so how often
X */
X 
X#ifndef NO_RESYNC_ACTIVE_FILE
X#	ifndef RESYNC_ACTIVE_SECS
X#		define	RESYNC_ACTIVE_SECS	300	/* reread active every n secs */
X#	endif
X#endif
X
X/*
X * Initial sizes of internal arrays for small (<4MB) & large memory machines
X */
X 
X#ifdef SMALL_MEMORY_MACHINE
X#	define		DEFAULT_ACTIVE_NUM	1800	
X#	define		DEFAULT_ARTICLE_NUM	400	
X#	define		DEFAULT_KILL_NUM	10	
X#	define		DEFAULT_SAVE_NUM	10	
X#else
X#	define		DEFAULT_ACTIVE_NUM	1800	
X#	define		DEFAULT_ARTICLE_NUM	1200	
X#	define		DEFAULT_KILL_NUM	30	
X#	define		DEFAULT_SAVE_NUM	30	
X#endif
X
X#define		RCDIR			".tin"
X#define		RCFILE			"tinrc"
X#define		INDEXDIR		".index"
X#define		KILLFILE		"kill"
X#define		POSTFILE		"posted"
X#define		UNTHREADFILE	"unthread"
X#define		DEFAULT_MAILDIR	"Mail"
X
X#define BUG_REPORT_ADDRESS	"iain%anl433.uucp@Germany.EU.net"
X
X#ifdef TRUE
X#	undef TRUE
X#endif
X#define		TRUE		1
X
X#ifdef FALSE
X#	undef FALSE
X#endif
X#define		FALSE		0
X
X#define		LEN				1024
X#define		PATH_LEN			256
X#define		HEADER_LEN			1024
X#define		MODULO_COUNT_NUM		5
X#define		TABLE_SIZE			1409
X#define		MAX_PAGES			1000
X#define		ctrl(c)				((c) & 0x1F)
X
X#ifndef DEFAULT_COMMENT
X#	define		DEFAULT_COMMENT	": "	/* used when by follow-ups & replys */
X#endif
X#ifndef UNREAD_ART_MARK
X#	define		UNREAD_ART_MARK	'+'	/* used to show that an art is unread */
X#endif
X#ifndef RETURN_ART_MARK
X#	define		RETURN_ART_MARK	'-'	/* used to show that an art will return */
X#endif
X#ifndef HOT_ART_MARK
X#	define		HOT_ART_MARK	'*'	/* used to show that an art was auto selected */
X#endif
X#ifndef READ_ART_MARK
X#	define		READ_ART_MARK	' '	/* used to show that an art was not read or seen  */
X#endif
X
X#ifdef USE_INVERSE_HACK
X#	define		SELECT_MISC_COLS	21
X#	define		BLANK_GROUP_COLS	2
X#	define		BLANK_PAGE_COLS		2
X#else
X#	define		SELECT_MISC_COLS	21
X#	define		BLANK_GROUP_COLS	0
X#	define		BLANK_PAGE_COLS		0
X#endif
X
X#define		SCREEN_READ_UNREAD		6		/* position for "  +" / "   " */
X#define		INDEX_TOP				2
X
X#ifdef NO_REGEX 
X#	define STR_MATCH(s1,s2)	(str_str (s1, s2, strlen (s2)) != 0)
X#else		
X#	define STR_MATCH(s1,pat)	(wildmat (s1, pat))
X#endif
X
X#define IGNORE_ART(i)	((arts[i].thread == ART_EXPIRED) || \
X			 (arts[i].killed && kill_level > 0))
X
X/*
X *  used by get_arrow_key()
X */
X
X#define		KEYMAP_UNKNOWN			0
X#define		KEYMAP_UP				1
X#define		KEYMAP_DOWN				2
X#define		KEYMAP_PAGE_UP			3
X#define		KEYMAP_PAGE_DOWN		4
X#define		KEYMAP_HOME				5
X#define		KEYMAP_END				6
X
X/*
X *  used by feed.c - feed_articles()
X */
X 
X#define		SELECT_LEVEL				1
X#define		GROUP_LEVEL				2
X#define		PAGE_LEVEL				3
X
X#define		FEED_MAIL				1
X#define		FEED_PIPE				2
X#define		FEED_PRINT				3
X#define		FEED_SAVE				4
X#define		FEED_XPOST				5
X
X/*
X *  used in art.c & rcfile.c
X */
X 
X#define		SORT_BY_NOTHING			0		/* sort types on arts[] array */
X#define		SORT_BY_SUBJ_DESCEND	1
X#define		SORT_BY_SUBJ_ASCEND		2
X#define		SORT_BY_FROM_DESCEND	3
X#define		SORT_BY_FROM_ASCEND		4
X#define		SORT_BY_DATE_DESCEND	5
X#define		SORT_BY_DATE_ASCEND		6
X
X#define		SHOW_FROM_NONE			0
X#define		SHOW_FROM_ADDR			1
X#define		SHOW_FROM_NAME			2
X#define		SHOW_FROM_BOTH			3
X
X/*
X *  used in help.c
X */
X
X#define		HELP_INFO				0
X#define		POST_INFO				1
X
X/*
X *  used in save.c
X */
X
X#define		CHECK_ANY_NEWS			0
X#define		START_ANY_NEWS			1
X#define		MAIL_ANY_NEWS			2
X#define		SAVE_ANY_NEWS			3
X
X/*
X *  used in help.c
X */
X
X#define		HEADER_TO				0
X#define		HEADER_SUBJECT			1
X
X/*
X *  used in page.c & post.c
X */
X
X#define		POSTED_NONE				0
X#define		POSTED_REDRAW			1
X#define		POSTED_OK				2
X
X/*
X *  Assertion verifier
X */
X
X#if __STDC__ && !defined(apollo)
X#	define	assert(p)	if(! (p)) asfail(__FILE__, __LINE__, #p); else
X#else
X#	define	assert(p)	if(! (p)) asfail(__FILE__, __LINE__, "p"); else
X#endif
X
X#define		ESC		27
X#if defined(BSD) || defined(MINIX) || defined(apollo)
X#	define		CR		'\r'
X#else
X#	define		CR		10
X#endif
X
X/*
X * return codes for change_rcfile ()
X */
X
X#define		NO_KILLING		0
X#define		KILLING			1
X
X/*
X *  art.thread
X */
X
X#define		ART_NORMAL		-1
X#define		ART_EXPIRED		-2
X
X/*
X *  art.unread
X */
X
X#define		ART_READ		0
X#define		ART_UNREAD		1
X#define		ART_WILL_RETURN	2
X
X/*
X * used by group_t & my_group[]
X */
X 
X#define		UNSUBSCRIBED	0x01	/* haven't put in my_group[] yet */
X#define		SUBSCRIBED		0x02	/* subscribed to */
X
X/*
X * kill_type used in struct kill_t
X */
X 
X#define KILL_SUBJ	1
X#define KILL_FROM	2
X#define KILL_BOTH	3
X
X/*
X * usedin group.c & page.c
X */
X 
X#define	ART_UNAVAILABLE	-1
X
X
X/*
X * used in feed.c & save.c
X */
X 
X#define POST_PROC_NONE			0
X#define POST_PROC_SHAR			1
X#define POST_PROC_UUDECODE		2
X#define POST_PROC_UUD_LST_ZOO	3
X#define POST_PROC_UUD_EXT_ZOO	4
X
X/*
X *  struct article_t - article header
X *
X *  article.artnum:
X *	article number in spool directory for group
X *
X *  article.thread:
X *	-1 initial default
X *	-2 means article has expired (wasn't found in file search
X *	of spool directory for the group)
X *	>=0 points to another arts[] (struct article_t)
X *
X *  article.inthread:
X *	FALSE for the first article in a thread, TRUE for all
X *	following articles in thread
X *
X *  article.unread:
X *	boolean, has this article been read or not
X *
X *  article.killed:
X *	boolean, has this article been killed
X *
X *  article.hot:
X *	boolean, has this article been auto-selected
X *
X *  article.tagged:
X *	count, has this article been tagged for saving (>0) or not (=0)
X *
X *  article.date
X *	date: line used for sorting articles by date order
X *
X *  article.archive:
X *	archive name used in *source* groups
X *
X *  article.part:
X *	part no. of archive
X *
X *  article.patch:
X *	patch no. of archive
X *
X */
X
Xstruct article_t {
X	long artnum;
X	char *subject;		/* Subject: line from mail header */
X	char *from;		/* From: line from mail header (address) */
X	char *name;		/* From: line from mail header (full name) */
X	int thread;
X	unsigned int inthread:1;/* 0 = thread head, 1 = thread follower */
X	unsigned int unread:2;	/* 0 = read, 1 = unread, 2 = will return */
X	unsigned int killed:1;	/* 0 = not killed, 1 = killed */
X	unsigned int hot:1;	/* 0 = not hot, 1 = hot */
X	unsigned int zombie:1;	/* 1 = was alive (unread) before 'X' command */
X	unsigned int o_unread:2;/* original value of unread - used in xref */
X	int tagged;		/* 0 = not tagged, >0 = tagged */
X	char date[16];		/* Date: line from mail header */
X	char *archive;		/* Archive-name: line from mail header */
X	char *part;		/* part no. of archive */
X	char *patch;		/* patch no. of archive */
X	char *xref;		/* cross reference line */
X};
X
X/*
X *  struct attribute_t - configurable attributes on a per group basis
X */
X
Xstruct attribute_t {
X	char *server;			/* read group locally/via nntp server */
X	char *maildir;			/* mail dir if other than ~/Mail */
X	char *savedir;			/* save dir if other than ~/News */
X	char *sigfile;			/* sig file if other than ~/.Sig */
X	unsigned int read:1;		/* marked TRUE if group was entered during session */
X	unsigned int showall:1;		/* 0 = only unread, 1 = all */
X	unsigned int thread:1;		/* 0 = unthread, 1 = thread */
X	unsigned int sortby:4;		/* 0 = none, 1 = , 2 = , 3 = , 4 = , */
X	unsigned int author:4;		/* 0 = none, 1 = name, 2 = addr, 3 = both */
X	unsigned int autosave:1;	/* 0 = none, 1 = save */
X	unsigned int process:4;		/* 0 = none, 1 = shar, 2 = uudecode, 
X				  	   3 = uud & list zoo, 4 = uud & ext zoo*/
X};
X
X/*
X *  struct group_t - newsgroup info from active file
X */
X
Xstruct group_t {
X	char *name;
X	char *description;		/* text from LIBDIR/newsgroups file */
X	long max;
X	long min;
X	char moderated;
X	int next;			/* next active entry in hash chain */
X	int flag;
X	struct attribute_t attribute;	/* per group attributes */ 
X};
X
X/*
X *  used in hashstr.c
X */
X 
Xstruct hashnode {
X	char *s;						/* the string we're saving */
X	struct hashnode *next;			/* chain for spillover */
X};
X
X/*
X *  used in kill.c
X */
X 
Xstruct kill_t {
X	unsigned int kill_type:8;
X	unsigned int kill_how:8;	/* kill/auto select */
X	long kill_group;
X	char *kill_subj;
X	char *kill_from;
X};
X
Xstruct save_t {
X	char *subject;
X	char *dir;
X	char *file;
X	char *archive;
X	char *part;
X	char *patch;
X	int index;	
X	int saved;	
X	int is_mailbox;	
X};
X
Xstruct screen_t {
X	char *col;
X};
X
Xstruct posted_t {
X	char date[10];
X	char group[80];
X	char action;
X	char subj[120];
X};
X
Xstruct art_stat_t {
X	int total;	/* total article count */
X	int unread;	/* number of unread articles (does not include seen) arts */
X	int seen;	/* number of seen articles (ART_WILL_RETURN) */
X	int hot_total;	/* total hot count */
X	int hot_unread; /* hot and unread */
X	int hot_seen;	/* hot and seen */
X	char art_mark;	/* mark to use for this thread - not used for groups */
X};
X
Xstruct spooldir_t {
X	int state;
X	char *name;
X	char *comment;
X};
X
X/*
X *  function prototypes	& extern definitions	
X */ 
X
X#include	"patchlev.h"
X#include	"extern.h"
X#include	"nntplib.h"
X#include	"proto.h"
END_OF_FILE
  if test 14455 -ne `wc -c <'tin.h'`; then
    echo shar: \"'tin.h'\" unpacked with wrong size!
  fi
  # end of 'tin.h'
fi
echo shar: End of archive 12 \(of 15\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
