Newsgroups: comp.sources.misc
From: iain%anl433.uucp@Germany.EU.net (Iain Lea)
Subject:  v31i009:  tin - threaded full screen newsreader v1.1 PL4, Part09/15
Message-ID: <1992Jul7.181746.7648@sparky.imd.sterling.com>
X-Md4-Signature: f5cb28a35600b63580f76655b35eb952
Date: Tue, 7 Jul 1992 18:17:46 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: iain%anl433.uucp@Germany.EU.net (Iain Lea)
Posting-number: Volume 31, Issue 9
Archive-name: tin/part09
Environment: BSD, SCO, ISC, SUNOS, SYSVR3, SYSVR4, ULTRIX, XENIX
Supersedes: tin: Volume 30, Issue 1-14

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  kill lang.c rcfile.c
# Wrapped by kent@sparky on Mon Jun 29 23:35:13 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 9 (of 15)."'
if test -f 'kill' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kill'\"
else
  echo shar: Extracting \"'kill'\" \(489 characters\)
  sed "s/^X//" >'kill' <<'END_OF_FILE'
X# 1st line  1=(Subject: only)  2=(From: only)  3=(Subject: & From:)
X#           K=(kill) H=(auto-selection)
X# 2nd line  0=(kill on all newsgroups)  >0=(kill on specific newsgroup)
X#
X# 001 HOT
X2	H
X0
X*Chris Torek*
X#
X# 002 HOT
X2	H
X0
X*Stallman*
X#
X# 003 HOT
X2	H
X0
X*Randal L. Schwartz*
X#
X# 004 HOT
X2	H
X0
X*Larry Wall*
X#
X# 005 HOT
X2	H
X0
X*Syd Weinstein*
X#
X# 006 HOT
X2	H
X0
X*Tom Christiansen*
X#
X# 007 HOT
X2	H
X0
X*Geoff Collyer*
X#
X# 008 HOT
X2	H
X0
X*Michael I Bushnell*
X#
X# 009 HOT
X2	H
X0
X*Henry Spencer*
END_OF_FILE
  if test 489 -ne `wc -c <'kill'`; then
    echo shar: \"'kill'\" unpacked with wrong size!
  fi
  # end of 'kill'
fi
if test -f 'lang.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lang.c'\"
else
  echo shar: Extracting \"'lang.c'\" \(24092 characters\)
  sed "s/^X//" >'lang.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : lang.c
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 20-06-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X/*
X * active.c
X */
X 
Xchar txt_subscribe_to_new_group[] = "Subscribe to %s (y/n): ";
Xchar txt_delete_bogus_group[] = "Remove bogus group %s (y/n): ";
Xchar txt_reading_active_file[] = "Reading active file...";
Xchar txt_reading_newsgroups_file[] = "Reading newsgroups file...";
X
X/*
X *  art.c
X */
X
Xchar txt_group[] = "Group %s...";
Xchar txt_cannot_open_art[] = "can't open article %s: ";
Xchar txt_indexing[] = "Indexing %s...";
Xchar txt_indexing_num[] = "Indexing %s...%4d";
Xchar txt_corrupt_index[] = "Index file %s corrupted. error %d on article %d";
Xchar txt_checking_for_news[] = "Checking for news...";
Xchar txt_there_is_no_news[] = "There is no news\n";
Xchar txt_killing_arts[] = "Selecting articles...";
Xchar txt_unkilling_arts[] = "Unselecting articles...";
X
X/*
X *  feed.c
X */
X
Xchar txt_art_thread_regex_tag[] = " a)rticle, t)hread, h)ot, p)attern, T)agged articles, q)uit: ";
Xchar txt_post_process_type[] = "Process n)one, s)har, u)udecode, U)udecode & zoo: ";
X#ifdef NO_REGEX 
Xchar txt_feed_pattern[] = "Enter pattern [%s]> ";
X#else
Xchar txt_feed_pattern[] = "Enter regex pattern [%s]> ";
X#endif
Xchar txt_no_command[] = "No command";
Xchar txt_piping[] = "Piping...";
Xchar txt_saved[] = "-- %d Article(s) saved --";
X
X/*
X *  group.c
X */
X
Xchar txt_cannot_post[] = "*** Posting not allowed ***";
Xchar txt_tagged_art[] = "Tagged article";
Xchar txt_untagged_art[] = "Uuntagged article";
Xchar txt_inverse_on[] = "Inverse video enabled";
Xchar txt_inverse_off[] = "Inverse video disabled";
Xchar txt_subscribed_to[] = "Subscribed to %s";
Xchar txt_unsubscribed_to[] = "Unsubscribed from %s";
Xchar txt_mark_all_read[] = "Mark all articles as read? (y/n): ";
Xchar txt_mark_thread_read[] = "Mark thread as read? (y/n): ";
Xchar txt_no_more_groups[] = "No more groups";
Xchar txt_no_prev_group[] = "No previous group";
Xchar txt_no_arts[] = "*** No Articles ***";
Xchar txt_no_groups[] = "*** No Groups ***";
Xchar txt_not_active_newsfeed[] = "Command only allowed on active news";
Xchar txt_end_of_thread[] = "*** End of Thread ***";
Xchar txt_end_of_arts[] = "*** End of Articles ***";
Xchar txt_end_of_groups[] = "*** End of Groups ***";
Xchar txt_no_next_unread_art[] = "No next unread article";
Xchar txt_no_prev_unread_art[] = "No previous unread article";
Xchar txt_no_last_message[] = "No last message";
Xchar txt_bad_command[] = "Bad command.  Type 'h' for help.";
Xchar txt_you_have_mail[] = "    You have mail\n";
Xchar txt_type_h_for_help[] = "           h=help\n";
Xchar txt_read_art[] = "Read article> ";
Xchar txt_search_forwards[] = "Search forwards [%s]> ";
Xchar txt_search_backwards[] = "Search backwards [%s]> ";
Xchar txt_author_search_forwards[] = "Author search forwards [%s]> ";
Xchar txt_author_search_backwards[] = "Author search backwards [%s]> ";
Xchar txt_no_search_string[] = "No search string";
Xchar txt_no_match[] = "No match";
Xchar txt_post_subject[] = "Post subject [%s]> ";
Xchar txt_no_subject[] = "No subject";
Xchar txt_cannot_open[] = "can't open %s";
Xchar txt_posting[] = "Posting article...";
Xchar txt_art_posted[] = "-- Article posted --";
Xchar txt_art_rejected[] = "-- Article rejected (saved to %s) --";
Xchar txt_quit_edit_post[] = "q)uit, e)dit, p)ost: ";
Xchar txt_help_4[] = "4$       Goto spooldir 4 ($=goto last spooldir)\r\n";
Xchar txt_help_i_4[] = "4$       Goto article 4 ($=goto last article)\r\n";
Xchar txt_help_ctrl_k[] = "^K       Kill / Auto select (hot) current article\r\n";
Xchar txt_help_ctrl_l[] = "^L       Redraw page\r\n";
Xchar txt_help_ctrl_d[] = "^D^U     Down (^U=up) a page\r\n";
Xchar txt_help_ctrl_f[] = "^F^B     Down (^B=up) a page\r\n";
Xchar txt_help_i_cr[] = "<CR>     Read current article\r\n";
Xchar txt_help_cr[] = "<CR>     Read news from selected spooldir\r\n";
Xchar txt_help_i_tab[] = "<TAB>    Goto next unread article or group\r\n";
Xchar txt_help_d[] = "d        Toggle display of subject only & subject/author\r\n";
Xchar txt_help_l[] = "l        List articles within current thread\r\n";
Xchar txt_help_m[] = "m        Move current group within group selection list\r\n";
Xchar txt_help_M[] = "M        Menu of configurable options\r\n";
Xchar txt_help_a[] = "aA       Author forward (A=backward) search\r\n";
Xchar txt_help_sel_c[] = "cC       Mark group read (C=and goto next unread group)\r\n";
Xchar txt_help_c[] = "c        Mark all articles as read and goto group selection menu\r\n";
Xchar txt_help_g[] = "g        Choose a new group by name\r\n";
Xchar txt_help_I[] = "I        Toggle inverse video\r\n";
Xchar txt_help_K[] = "K        Mark article/thread as read & goto next unread\r\n";
Xchar txt_help_j[] = "jk       Down (k=up) a line\r\n";
Xchar txt_help_i_n[] = "np       Goto next (p=previous) group\r\n";
Xchar txt_help_i_p[] = "NP       Goto next (P=previous) unread article\r\n";
Xchar txt_help_q[] = "Q        Quit\r\n";
Xchar txt_help_r[] = "r        Toggle display to show all / only unread articles\r\n";
Xchar txt_help_s[] = "su       Subscribe (u=unsubscribe) to current group\r\n";
Xchar txt_help_S[] = "SU       Subscribe (U=unsubscribe) to groups that match pattern\r\n";
Xchar txt_help_t[] = "t        Return to group selection level\r\n";
Xchar txt_help_T[] = "T        Tag current article for crossposting/mailing/piping/printing/saving\r\n";
Xchar txt_help_u[] = "u        Toggle display of unthreaded & threaded articles\r\n";
Xchar txt_help_U[] = "U        Untag all tagged articles\r\n";
Xchar txt_help_v[] = "v        Show version information\r\n";
Xchar txt_help_w[] = "w        Post an article to current group\r\n";
Xchar txt_help_x[] = "x        Crosspost current article to another group\r\n";
Xchar txt_help_i_search[] = "/?       Subject forward (?=backward) search\r\n";
Xchar txt_help_thread[] = "<>       Goto first (>=last) article in current thread\r\n";
X#ifndef NO_SHELL_ESCAPE
Xchar txt_help_shell[] = "!        Shell escape\r\n";
X#endif
Xchar txt_help_dash[] = "-        Show last message\r\n";
Xchar txt_help_i_star[] = "*        Select thread\r\n";
Xchar txt_help_i_dot[] = ".        Toggle selection of thread\r\n";
Xchar txt_help_i_coma[] = "@        Reverse all selections (all articles)\r\n";
Xchar txt_help_i_tilda[] ="~        Undo all selections (all articles)\r\n";
Xchar txt_help_X[] = "X        Mark all unread articles that have not been selected as read\r\n";
Xchar txt_help_plus[] = "+        Perform auto-selection on group\r\n";
Xchar txt_help_equal[] = "=        Mark threads selected if at least one unread art is selected\r\n";
Xchar txt_help_semicolon[] = ";        Mark threads selected if at least one unread art is selected\r\n";
X#ifdef NO_REGEX 
Xchar txt_save_pattern[] = "Enter save pattern [%s]> ";
X#else
Xchar txt_save_pattern[] = "Enter regex save pattern [%s]> ";
X#endif
Xchar txt_saved_pattern_to[] = "-- Saved pattern to %s - %s --";
Xchar txt_saved_to_mailbox[] = "-- Saved to mailbox %s --";
Xchar txt_threading_arts[] = "Threading articles...";
Xchar txt_unthreading_arts[] = "Unthreading articles...";
Xchar txt_select_pattern[] = "Enter selection pattern [%s]> ";
X
X/* 
X *  help.c:
X */
X
Xchar txt_group_select_com[] = "Group Selection Commands (page %d of %d)";
Xchar txt_spooldir_com[] = "Spooldir Selection Commands (page %d of %d)";
Xchar txt_index_page_com[] = "Index Page Commands (page %d of %d)";
Xchar txt_thread_com[] = "Thread Commands (page %d of %d)";
Xchar txt_art_pager_com[] = "Article Pager Commands (page %d of %d)";
Xchar txt_hit_space_for_more[] = "PgDn,End,<SPACE>,^D - page down. PgUp,Home,b,^U - page up. <CR>,q - quit";
Xchar txt_post_history_menu[] = "Posted articles history (page %d of %d)";
X
X/* 
X *  kill.c:
X */
X
Xchar txt_corrupt_kill_file[] = "Corrupt kill file %s";
Xchar txt_kill_menu[] = "Kill Article Menu";
Xchar txt_kill_how[] = "Kill type : ";
Xchar txt_kill_subject[] = "Kill Subject [%-*.*s] (y/n): ";
Xchar txt_kill_from[] =    "Kill From    [%-*.*s] (y/n): ";
Xchar txt_kill_text[] = "Kill text pattern : ";
Xchar txt_kill_text_type[] = "Apply pattern to  : ";
Xchar txt_kill_group[] =     "Kill pattern scope: ";
Xchar txt_help_kill_how[] = "Choose kill or auto select. <SPACE> toggles & <CR> sets.";
Xchar txt_help_kill_subject[] = "Subject: line to add to kill file. <SPACE> toggles & <CR> sets.";
Xchar txt_help_kill_from[] = "From: line to add to kill file. <SPACE> toggles & <CR> sets.";
Xchar txt_help_kill_text[] = "Enter text pattern to kill if Subject: & From: lines are not what you want.";
Xchar txt_help_kill_text_type[] = "Select where text pattern should be applied. <SPACE> toggles & <CR> sets.";
Xchar txt_help_kill_group[] = "Kill/auto-select only current group or all groups. <SPACE> toggles & <CR> sets.";
Xchar txt_quit_edit_save_killfile[] = "q)uit e)dit s)ave kill/hot description: ";
X
X
X/* 
X *  main.c:
X */
X
Xchar txt_option_not_enabled[] = "Option not enabled. Recompile with %s.";
Xchar txt_not_in_active_file[] = "Group %s not found in active file";
Xchar txt_screen_init_failed[] = "%s: Screen initialization failed";
Xchar txt_bad_active_file[] = "Active file corrupt - %s";
X
X/*
X *  misc.c
X */
X
Xchar txt_cannot_open_active_file[] = "Cannot open %s. Try %s -r to read news via NNTP.\n";
Xchar txt_active_file_is_empty[] = "%s contains no newsgroups. Exiting.";
Xchar txt_checking_active_file[] = "Checking for new newsgroups...";
Xchar txt_checking[] = "Checking...";
Xchar txt_cannot_find_base_art[] = "Cannot find base article %s";
Xchar txt_out_of_memory[] = "%s: out of memory";
Xchar txt_rename_error[] = "Error: rename %s to %s";
Xchar txt_shell_escape[] = "Enter shell command [%s]> ";
X
X/*
X *  newsrc.c
X */
X
Xchar txt_creating_newsrc[] = "Creating .newsrc...\n";
Xchar txt_deleting_from_newsrc[] = "Group %s not in active file. Deleting.";
X
X/*
X *  open.c
X */
X 
Xchar txt_connecting[] = "Connecting to %s...";
Xchar txt_cannot_get_nntp_server_name[] = "Cannot find NNTP server name";
Xchar txt_server_name_in_file_env_var[] = "Put the server name in the file %s,\nor set the environment variable NNTPSERVER";
Xchar txt_failed_to_connect_to_server[] = "Failed to connect to (%s) server";
Xchar txt_rejected_by_nntpserver[] = "Rejected by server, nntp error %d";
Xchar txt_connection_to_server_broken[] = "Connection to server broken";
Xchar txt_stuff_nntp_cannot_open[] = "stuff_nntp: can't open %s: ";
Xchar txt_nntp_to_fp_cannot_reopen[] = "nntp_to_fp: can't reopen %s: ";
Xchar txt_nntp_to_fd_cannot_reopen[] = "nntp_to_fd: can't reopen %s: ";
X
X/*
X *  page.c
X */
X
Xchar txt_quit[] = "Do you really want to quit? (y/n): ";
Xchar txt_art_unavailable[] = "Article %ld unavailable";
Xchar txt_art_marked_as_unread[] = "Article marked as unread";
Xchar txt_thread_marked_as_unread[] = "Thread marked as unread";
Xchar txt_begin_of_art[] = "*** Beginning of article ***";
Xchar txt_next_resp[] = "-- Next response --";
Xchar txt_last_resp[] = "-- Last response --";
Xchar txt_more[] = "--More--";
Xchar txt_more_percent[] = "--More--(%d%%) [%ld/%ld]";
Xchar txt_thread_x_of_n[] = "%sThread %4d of %4d\r\n";
Xchar txt_art[] = "Article %ld  ";
Xchar txt_resp_x_of_n[] = "Respno %3d of %3d\r\n";
Xchar txt_no_resp[] = "No responses\r\n";
Xchar txt_1_resp[] = "1 Response\r\n";
Xchar txt_x_resp[] = "%d Responses\r\n";
Xchar txt_s_at_s[] = "%s at %s";
Xchar txt_thread_resp_page[] = "Thread %d of %d, Resp %d (page %d):  %s";
Xchar txt_thread_page[] = "Thread %d of %d (page %d):  %s";
Xchar txt_read_resp[] = "Read response> ";
Xchar txt_help_p_0[] = "0        Read the base article in current thread\r\n";
Xchar txt_help_p_4[] = "4        Read response 4 in current thread\r\n";
Xchar txt_help_p_cr[] = "<CR>     Goto to next thread\r\n";
Xchar txt_help_p_tab[] = "<TAB>    Goto next unread article\r\n";
Xchar txt_help_b[] = "b<SPACE> Back (<SPACE>=forward) a page\r\n";
Xchar txt_help_bug[] = "B        Mail bug/comment to %s\r\n";
Xchar txt_help_p_f[] = "fF       Post (F=copy text) a followup\r\n";
Xchar txt_help_C[] = "C        Cancel current article that must have been posted by you\r\n";
Xchar txt_help_ctrl_h[] = "^H       Show articles header\r\n";
Xchar txt_help_h[] = "h        Command help\r\n";
Xchar txt_help_i[] = "q        Return to previous level\r\n";
Xchar txt_help_ck[] = "ck       Mark thread as read & return to previous level\r\n";
Xchar txt_help_p_k[] = "kK       Mark article (K=thread) as read & advance to next unread\r\n";
Xchar txt_help_p_m[] = "m        Mail article/thread/hot/pattern/tagged articles to someone\r\n";
Xchar txt_help_p_n[] = "nN       Goto to the next (N=unread) article\r\n";
Xchar txt_help_o[] = "o        Output article/thread/hot/pattern/tagged articles to printer\r\n";
Xchar txt_help_p_p[] = "pP       Goto the previous (P=unread) article\r\n";
Xchar txt_help_p_r[] = "rR       Reply through mail (R=copy text) to author\r\n";
Xchar txt_help_p_s[] = "s        Save article/thread/hot/pattern/tagged articles to file\r\n";
Xchar txt_help_p_z[] = "zZ       Mark article (Z=thread) as unread\r\n";
Xchar txt_help_p_ctrl_r[] = "^R$      Redisplay first ($=last) page of article\r\n";
Xchar txt_help_p_g[] = "gG       Goto first (G=last) page of article\r\n";
Xchar txt_help_p_d[] = "d        Toggle rot-13 decoding for current article\r\n";
Xchar txt_help_pipe[] = "|        Pipe article/thread/hot/pattern/tagged articles into command\r\n";
Xchar txt_help_p_search[] = "/        Article forward search\r\n";
Xchar txt_help_p_star[] = "*        Select article\r\n";
Xchar txt_help_p_dot[] = ".        Toggle article selection\r\n";
Xchar txt_help_p_coma[] = "@        Reverse aarticle selections\r\n";
Xchar txt_help_p_tilda[] = "~        Undo all selections in thread\r\n";
Xchar txt_mail_art_to[] = "Mail article to [%.*s]> ";
Xchar txt_no_mail_address[] = "No mail address";
Xchar txt_quit_edit_send[] = "q)uit, e)dit, s)end";
Xchar txt_quit_edit_cancel[] = "q)uit, e)dit, c)ancel";
Xchar txt_mailing_to[] = "Mailing to %s...";
Xchar txt_mailed[] = "-- %d Article(s) mailed --";
Xchar txt_command_failed_s[] = "Command failed: %s\n";
Xchar txt_in_art_you_write[] = "In article %s you write:\n";
Xchar txt_resp_to_poster[] = "Responses have been directed to the poster. Post anyway? (y/n): ";
Xchar txt_resp_redirect[] = "Responses have been directed to the following newsgroups";
Xchar txt_continue[] = "Continue? (y/n): ";
Xchar txt_writes[] = "%s writes:\n";
Xchar txt_writes_name[] = "%s (%s) writes:\n";
Xchar txt_save_filename[] = "Save filename [%s]> ";
Xchar txt_art_not_saved[] = "-- Article not saved --";
Xchar txt_no_filename[] = "No filename";
Xchar txt_saving[] = "Saving...";
Xchar txt_art_saved_to[] = "-- Article saved to %s --";
Xchar txt_thread_not_saved[] = "-- Thread not saved --";
Xchar txt_thread_saved_to_many[] = "-- Thread saved to %s - %s --";
Xchar txt_thread_saved_to[] = "-- Thread saved to %s --";
Xchar txt_pipe_to_command[] = "Pipe to command [%.*s]> ";
Xchar txt_printing[] = "Printing...";
Xchar txt_printed[] = "-- %d Article(s) printed --";
Xchar txt_append_to_file[] = "File %s exists. Append? (y/n): ";
Xchar txt_toggled_rot13[] = "Toggled rot13 encoding";
X
X/*
X *  post.c
X */
X
Xchar txt_no_arts_posted[] = "No articles have been posted";
Xchar txt_post_an_article[] = "Post an article...";
Xchar txt_post_a_followup[] = "Post a followup...";
Xchar txt_mail_bug_report[] = "Mail bug report...";
Xchar txt_crosspost_group[] = "Crosspost article to group(s) [%s]> ";
Xchar txt_no_group[] = "No group";
Xchar txt_crosspost_an_article[] = "Crossposting article...";
Xchar txt_mail_bug_report_confirm[] = "Mail bug report to %s%s? (y/n): ";
Xchar txt_reply_to_author[] = "Reply to author...";
Xchar txt_no_blank_line[] = "No blank line found after header information. q)uit, e)dit: ";
Xchar txt_cancelling[] = "Cancelling article...";
Xchar txt_art_cancelled[] = "Article cancelled";
Xchar txt_art_cannot_cancel[] = "Article cannot be cancelled";
Xchar txt_quit_edit_xpost[] = "q)uit, e)dit, p)ost [%.*s]: %c";
X
X/*
X *  prompt.c
X */
X
Xchar txt_hit_any_key[] = "-- Press any key to continue --";
X
X/*
X *  rcfile.c
X */
X 
Xchar txt_opt_autosave[] = "1. Auto save       : ";
Xchar txt_opt_start_editor_offset[] = "2. Editor Offset   : ";
Xchar txt_opt_mark_saved_read[] = "3. Mark saved read : ";
Xchar txt_opt_confirm_action[] =  "4. Confirm command : ";
Xchar txt_opt_draw_arrow[] = "5. Draw arrow      : ";
Xchar txt_opt_print_header[] = "6. Print header    : ";
Xchar txt_opt_pos_first_unread[] = "7. Goto 1st unread : ";
Xchar txt_opt_page_scroll[] = "8. Scroll full page: ";
Xchar txt_opt_catchup_groups[] = "9. Catchup on quit : ";
Xchar txt_opt_thread_arts[] =   "10 Thread articles : ";
Xchar txt_opt_show_only_unread[] = "11 Show only unread: ";
Xchar txt_opt_show_description[] = "12 Show description: ";
Xchar txt_opt_show_author[] = "13 Show author     : ";
Xchar txt_opt_process_type[] = "14 Process type    : ";
Xchar txt_opt_sort_type[] = "15 Sort article by : ";
Xchar txt_opt_savedir[] = "16 Save directory  : ";
Xchar txt_opt_maildir[] = "17 Mail directory  : ";
Xchar txt_opt_printer[] = "18 Printer         : ";
Xchar txt_options_menu[] = "Options Menu";
Xchar txt_show_from_none[] = "None";
Xchar txt_show_from_addr[] = "Addr";
Xchar txt_show_from_name[] = "Name";
Xchar txt_show_from_both[] = "Both";
Xchar txt_post_process_none[] = "None";
Xchar txt_post_process_sh[] = "Shell archive";
Xchar txt_post_process_uudecode[] = "Uudecode";
Xchar txt_post_process_uud_lst_zoo[] = "Uudecode & list zoo archive";
Xchar txt_post_process_uud_ext_zoo[] = "Uudecode & extract zoo archive";
Xchar txt_sort_by_nothing[] = "Nothing";
Xchar txt_sort_by_subj_descend[] = "Subject: field (descending)";
Xchar txt_sort_by_subj_ascend[] = "Subject: field (ascending)";
Xchar txt_sort_by_from_descend[] = "From: field (descending)";
Xchar txt_sort_by_from_ascend[] = "From: field (ascending)";
Xchar txt_sort_by_date_descend[] = "Date: field (descending)";
Xchar txt_sort_by_date_ascend[] = "Date: field (ascending)";
Xchar txt_help_autosave[] = "Auto save article/thread by Archive-name: header. <SPACE> toggles & <CR> sets.";
Xchar txt_help_start_editor_offset[] = "Start editor with line offset. <SPACE> toggles & <CR> sets.";
Xchar txt_help_confirm_action[] = "Ask for command confirmation. <SPACE> toggles & <CR> sets.";
Xchar txt_help_print_header[] = "By printing print all/part of header. <SPACE> toggles & <CR> sets.";
Xchar txt_help_pos_first_unread[] = "Put cursor at first/last unread art in groups. <SPACE> toggles & <CR> sets.";
Xchar txt_help_show_author[] = "Show Subject & From (author) fields in group menu. <SPACE> toggles & <CR> sets.";
Xchar txt_help_draw_arrow[] = "Draw -> or highlighted bar for selection. <SPACE> toggles & <CR> sets.";
Xchar txt_help_mark_saved_read[] = "Mark saved articles/threads as read. <SPACE> toggles & <CR> sets."; 
Xchar txt_help_page_scroll[] = "Scroll half/full page of groups/articles. <SPACE> toggles & <CR> sets."; 
Xchar txt_help_catchup_groups[] = "Ask to mark groups read when quiting. <SPACE> toggles & <CR> sets."; 
Xchar txt_help_thread_arts[] = "Enable/disable threading of articles in all groups. <SPACE> toggles & <CR> sets."; 
Xchar txt_help_show_only_unread[] = "Show all articles or only unread articles. <SPACE> toggles & <CR> sets."; 
Xchar txt_help_show_description[] = "Show short description for each newsgroup. <SPACE> toggles & <CR> sets."; 
Xchar txt_help_post_proc_type[] = "Post process (ie. unshar) saved article/thread. <SPACE> toggles & <CR> sets."; 
Xchar txt_help_sort_type[] = "Sort articles by Subject, From or Date fields. <SPACE> toggles & <CR> sets.";
Xchar txt_help_savedir[] = "The directory where you want articles/threads saved.";
Xchar txt_help_maildir[] = "The directory where articles/threads are to be saved in mailbox format.";
Xchar txt_help_printer[] = "The printer program with options that is to be used to print articles/threads.";
Xchar txt_select_rcfile_option[] = "Select option by entering number before text. Any other key to save.";
X
X/*
X *  save.c
X */
X
Xchar txt_post_processing[] = "Post processing...";
Xchar txt_post_processing_finished[] = "-- post processing completed --";
Xchar txt_deleting[] = "Deleting...";
Xchar txt_uudecoding[] = "Uudecoding...";
Xchar txt_extracting_shar[] ="\r\nExtracting %s...\r\n";
Xchar txt_delete_processed_files[] = "Delete saved files that have been post processed? (y/n): ";
Xchar txt_post_processing_failed[] = "Post processing failed";
Xchar txt_listing_archive[] = "\r\n\r\nListing %s archive...\r\n"; 
Xchar txt_extracting_archive[] = "\r\n\r\nExtracting %s archive...\r\n";
Xchar txt_checksum_of_file[] = "\r\n\r\nChecksum of %s...\r\n\r\n"; 
X
X/*
X *  search.c
X */
X
Xchar txt_searching[] = "Searching...";
X
X/*
X *  select.c
X */
X
Xchar txt_moving[] = "Moving %s...";
X#ifdef NO_REGEX
Xchar txt_subscribe_pattern[] = "Enter subscribe pattern> ";
Xchar txt_unsubscribe_pattern[] = "Enter unsubscribe pattern> ";
X#else
Xchar txt_subscribe_pattern[] = "Enter regex subscribe pattern> ";
Xchar txt_unsubscribe_pattern[] = "Enter regex unsubscribe pattern> ";
X#endif
Xchar txt_subscribing[] = "Subscribing...";
Xchar txt_subscribing_to[] = "Subscribing to %s...";
Xchar txt_unsubscribing[] = "Unsubscribing...";
Xchar txt_unsubscribing_from[] = "Unsubscribing from %s...";
Xchar txt_subscribed_num_groups[] = "subscribed to %d groups";
Xchar txt_unsubscribed_num_groups[] = "unsubscribed from %d groups";
Xchar txt_del_group_in_newsrc[] = "Delete %s from .newsrc? (y/n): ";
Xchar txt_group_deleted[] = "Group %s deleted";
Xchar txt_group_undeleted[] = "Group undeleted";
Xchar txt_mark_group_read[] = "Mark group %s as read? (y/n): ";
Xchar txt_no_groups_to_delete[] = "No groups to delete";
Xchar txt_reset_newsrc[] = "Reset newsrc? (y/n): ";
Xchar txt_post_newsgroup[] = "Post newsgroup> ";
Xchar txt_yanking_all_groups[] = "Yanking in all groups...";
Xchar txt_yanking_sub_groups[] = "Yanking in subscribed to groups...";
Xchar txt_no_groups_to_read[] = "No more groups to read";
Xchar txt_added_groups[] = "Added %d group%s";
Xchar txt_plural[] = "s";
Xchar txt_no_groups_to_yank_in[] = "No more groups to yank in";
Xchar txt_group_selection[] = "Group Selection";
Xchar txt_spooldir_selection[] = "Spooldir Selection (%d)";
Xchar txt_select_group[] = "Select group> ";
Xchar txt_select_spooldir[] = "Select spooldir> ";
Xchar txt_help_g_4[] = "4$       Select group 4 ($=select last group)\r\n";
Xchar txt_help_g_ctrl_r[] = "^R       Reset .newsrc\r\n";
Xchar txt_help_g_ctrl_k[] = "^KZ      Delete (Z=undelete) group from .newsrc\r\n";
Xchar txt_help_g_cr[] = "<CR>     Read current group\r\n";
Xchar txt_help_g_c[] = "c        Mark group as all read\r\n";
Xchar txt_help_g_l[] = "l        List & select another spooldir\r\n";
Xchar txt_help_g_tab[] =   "n<TAB>   Goto next group with unread news and enter it\r\n";
Xchar txt_help_n[] = "N        Goto next group with unread news\r\n";
Xchar txt_help_g_q[] = "qQ       Quit\r\n";
Xchar txt_help_W[] = "W        List articles posted by user\r\n";
Xchar txt_help_g_y[] = "y        Yank in subscribed/unsubscribed from .newsrc\r\n";
Xchar txt_help_g_z[] = "z        Mark current group as unread\r\n";
Xchar txt_help_y[] = "Y        Yank in active file to see any new news\r\n";
Xchar txt_help_g_search[] = "/?       Group forward (?=backward) search\r\n";
Xchar txt_newsgroup[] = "Goto newsgroup [%s]> ";
Xchar txt_newsgroup_position[] = "Position %s in group list (1,2,..,$) [%d]> ";
X
X/*
X *  signal.c
X */
X
Xchar txt_resizing_window[] = "resizing window";
Xchar txt_suspended_message[] = "\nStopped. Type 'fg' to restart TIN\n";
X
X/*
X *  thread.c
X */
X
Xchar txt_no_resps_in_thread[] = "No responses to list in current thread";
Xchar txt_help_t_0[] = "0        Goto the base article in current thread\r\n";
Xchar txt_help_t_4[] = "4$       Goto response 4 ($=goto last response) in current thread\r\n";
Xchar txt_help_t_cr[] = "<CR>     Read current response\r\n";
Xchar txt_help_t_tab[] = "<TAB>    Goto next unread response\r\n";
Xchar txt_help_t_K[] =   "K        Mark thread as read & return\r\n";
END_OF_FILE
  if test 24092 -ne `wc -c <'lang.c'`; then
    echo shar: \"'lang.c'\" unpacked with wrong size!
  fi
  # end of 'lang.c'
fi
if test -f 'rcfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rcfile.c'\"
else
  echo shar: Extracting \"'rcfile.c'\" \(24690 characters\)
  sed "s/^X//" >'rcfile.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : rcfile.c
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 20-06-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
Xextern int index_point;
X
Xstatic int COL1;
Xstatic int COL2;
Xstatic int COL3;
X
X/*
X *  read_rcfile - read defaults from ~/.tin/tinrc
X */
X
Xint read_rcfile ()
X{
X	char buf[LEN];
X	FILE *fp;
X
X	if ((fp = fopen (rcfile, "r")) == NULL) {
X		return (FALSE);
X	}	
X
X	while (fgets (buf, sizeof (buf), fp) != NULL) {
X		if (buf[0] == '#' || buf[0] == '\n') { 
X			continue;
X		}	
X		if (match_boolean (buf, "save_archive=", &save_archive_name)) {
X			continue;
X		}	
X		if (match_boolean (buf, "start_editor_offset=", &start_editor_offset)) {
X			continue;
X		}	
X		if (match_boolean (buf, "mark_saved_read=", &mark_saved_read)) {
X			continue;
X		}	
X		if (match_boolean (buf, "draw_arrow=", &draw_arrow_mark)) {
X			if (draw_arrow_mark == FALSE && inverse_okay == FALSE) {
X				inverse_okay = TRUE;
X			}
X			continue;
X		}	
X		if (match_boolean (buf, "print_header=", &print_header)) {
X			continue;
X		}
X		if (match_number (buf, "kill_level=", &kill_level)) {
X			continue;
X		}
X		if (match_boolean (buf, "pos_first_unread=", &pos_first_unread)) {
X			continue;
X		}	
X		if (match_boolean (buf, "full_page_scroll=", &full_page_scroll)) {
X			continue;
X		}	
X		if (match_boolean (buf, "catchup_read_groups=", &catchup_read_groups)) {
X			continue;
X		}	
X		if (match_boolean (buf, "thread_articles=", &thread_arts)) {
X			continue;
X		}	
X		if (match_boolean (buf, "unlink_article=", &unlink_article)) {
X			continue;
X		}	
X		if (match_boolean (buf, "show_only_unread=", &show_only_unread)) {
X			continue;
X		}	
X		if (match_boolean (buf, "confirm_action=", &confirm_action)) {
X			continue;
X		}
X		if (match_boolean (buf, "show_description=", &show_description)) {
X			continue;
X		}
X		if (match_number (buf, "show_author=", &default_show_author)) {
X			continue;
X		}	
X		if (match_number (buf, "post_process_type=", &post_proc_type)) {
X			switch (post_proc_type) {
X				case POST_PROC_SHAR:
X					proc_ch_default = 's';
X					break;
X				case POST_PROC_UUDECODE:
X					proc_ch_default = 'u';
X					break;
X				case POST_PROC_UUD_LST_ZOO:
X					proc_ch_default = 'U';
X					break;
X				case POST_PROC_UUD_EXT_ZOO:
X					proc_ch_default = 'U';
X					break;
X				case POST_PROC_NONE:
X				default:
X					proc_ch_default = 'n';
X					break;
X			}
X			continue;
X		}	
X		if (match_number (buf, "sort_article_type=", &sort_art_type)) {
X			continue;
X		}	
X		if (match_string (buf, "savedir=", default_savedir, sizeof (default_savedir))) {
X			if (default_savedir[0] == '.' && strlen (default_savedir) == 1) {
X#if defined(BSD) && ! defined(sinix)
X				getwd (buf);	
X#else
X				getcwd (buf, LEN);
X#endif
X				my_strncpy (default_savedir, buf, sizeof (default_savedir));
X			}
X			continue;
X		}	
X		if (match_string (buf, "maildir=", default_maildir, sizeof (default_maildir))) {
X			continue;
X		}
X		if (match_string (buf, "printer=", printer, sizeof (printer))) {
X			continue;
X		}
X		if (match_string (buf, "default_spooldir_alias=", spooldir_alias, sizeof (spooldir_alias))) {
X			continue;
X		}
X		if (match_string (buf, "default_author_search=", default_author_search, sizeof (default_author_search))) {
X			continue;
X		}
X		if (match_string (buf, "default_goto_group=", default_goto_group, sizeof (default_goto_group))) {
X			continue;
X		}
X		if (match_string (buf, "default_group_search=", default_group_search, sizeof (default_group_search))) {
X			continue;
X		}
X		if (match_string (buf, "default_subject_search=", default_subject_search, sizeof (default_subject_search))) {
X			continue;
X		}
X		if (match_string (buf, "default_art_search=", default_art_search, sizeof (default_art_search))) {
X			continue;
X		}
X		if (match_string (buf, "default_crosspost_group=", default_crosspost_group, sizeof (default_crosspost_group))) {
X			continue;
X		}
X		if (match_string (buf, "default_mail_address=", default_mail_address, sizeof (default_mail_address))) {
X			continue;
X		}
X		if (match_number (buf, "default_move_group=", &default_move_group)) {
X			continue;
X		}
X		if (match_string (buf, "default_pipe_command=", default_pipe_command, sizeof (default_pipe_command))) {
X			continue;
X		}
X		if (match_string (buf, "default_post_subject=", default_post_subject, sizeof (default_post_subject))) {
X			continue;
X		}
X		if (match_string (buf, "default_regex_pattern=", default_regex_pattern, sizeof (default_regex_pattern))) {
X			continue;
X		}
X		if (match_string (buf, "default_save_file=", default_save_file, sizeof (default_save_file))) {
X			continue;
X		}
X		if (match_string (buf, "default_select_pattern=", default_select_pattern, sizeof (default_select_pattern))) {
X			continue;
X		}
X		if (match_string (buf, "default_shell_command=", default_shell_command, sizeof (default_shell_command))) {
X			continue;
X		}
X	}
X	fclose (fp);
X	return TRUE;		
X}
X
X
X/*
X *  write_rcfile - write defaults to ~/.tin/tinrc
X */
X
Xvoid write_rcfile ()
X{
X	FILE *fp;
X
X	if ((fp = fopen (rcfile, "w")) == NULL) {
X		return;
X	}	
X	
X	if (! cmd_line) {
X		wait_message (txt_saving);
X	}
X	fprintf (fp, "# if ON articles/threads with Archive-name: in mail header will\n");
X	fprintf (fp, "# be automatically saved with the Archive-name & part/patch no.\n");
X	fprintf (fp, "save_archive=%s\n\n", (save_archive_name ? "ON" : "OFF"));
X	fprintf (fp, "# if ON editor will be started with cursor offset into the file\n");
X	fprintf (fp, "# otherwise the cursor will be positioned at the first line\n");
X	fprintf (fp, "start_editor_offset=%s\n\n", (start_editor_offset ? "ON" : "OFF"));
X	fprintf (fp, "# if ON mark articles that are saved as read\n");
X	fprintf (fp, "mark_saved_read=%s\n\n", (mark_saved_read ? "ON" : "OFF"));
X	fprintf (fp, "# if 0 killed articles are simply marked as being read\n");
X	fprintf (fp, "# if 1 killed articles are removed and never seen\n");
X	fprintf (fp, "kill_level=%d\n\n", kill_level);
X	fprintf (fp, "# if ON use -> otherwise highlighted bar for selection\n");
X	fprintf (fp, "draw_arrow=%s\n\n", (draw_arrow_mark ? "ON" : "OFF"));
X	fprintf (fp, "# if ON print all of mail header otherwise Subject: & From: lines\n");
X	fprintf (fp, "print_header=%s\n\n", (print_header ? "ON" : "OFF"));
X	fprintf (fp, "# if ON put cursor at first unread art in group otherwise last art\n");
X	fprintf (fp, "pos_first_unread=%s\n\n", (pos_first_unread ? "ON" : "OFF"));
X	fprintf (fp, "# if ON scroll full page of groups/articles otherwise half a page\n");
X	fprintf (fp, "full_page_scroll=%s\n\n", (full_page_scroll ? "ON" : "OFF"));
X	fprintf (fp, "# if ON ask user if read groups should all be marked read\n");
X	fprintf (fp, "catchup_read_groups=%s\n\n", (catchup_read_groups ? "ON" : "OFF"));
X	fprintf (fp, "# if ON confirm certain commands with y/n before executing\n");
X	fprintf (fp, "confirm_action=%s\n\n", (confirm_action ? "ON" : "OFF"));
X	fprintf (fp, "# if ON show group description text after newsgroup name at\n");
X	fprintf (fp, "# group selection level\n");
X	fprintf (fp, "show_description=%s\n\n", (show_description ? "ON" : "OFF"));
X	fprintf (fp, "# part of from field to display 0) none 1) address 2) full name 3) both\n");
X	fprintf (fp, "show_author=%d\n\n", default_show_author);
X	fprintf (fp, "# type of post processing to perform after saving articles.\n");
X	fprintf (fp, "# 0=(none) 1=(shar) 2=(uudecode) 3=(uud & list zoo) 4=(uud & extract zoo) 5=(patch).\n");
X	fprintf (fp, "post_process_type=%d\n\n", post_proc_type);
X	fprintf (fp, "# if ON and group not in ~/.tin/unthread articles will be threaded.\n");
X	fprintf (fp, "thread_articles=%s\n\n", (thread_arts ? "ON" : "OFF"));
X	fprintf (fp, "# if ON remove ~/.article after posting.\n");
X	fprintf (fp, "unlink_article=%s\n\n", (unlink_article ? "ON" : "OFF"));
X	fprintf (fp, "# if ON show only new/unread articles otherwise show all.\n");
X	fprintf (fp, "show_only_unread=%s\n\n", (show_only_unread ? "ON" : "OFF"));
X	fprintf (fp, "# sort articles by 0=(nothing) 1=(Subject descend) 2=(Subject ascend)\n");
X	fprintf (fp, "# 3=(From descend) 4=(From ascend) 5=(Date descend) 6=(Date ascend).\n");
X	fprintf (fp, "sort_article_type=%d\n\n", sort_art_type);
X	fprintf (fp, "# (-d) directory where articles/threads are saved\n");
X	fprintf (fp, "savedir=%s\n\n", default_savedir);
X	fprintf (fp, "# (-M) directory where articles/threads are saved in mailbox format\n");	
X	fprintf (fp, "maildir=%s\n\n", default_maildir);	
X	fprintf (fp, "# (-p) print program with parameters used to print articles/threads\n");
X	fprintf (fp, "printer=%s\n\n", printer);
X
X	fprintf (fp, "# default actions/prompt strings for questions\n");
X	fprintf (fp, "default_spooldir_alias=%s\n", spooldir_alias);
X	fprintf (fp, "default_author_search=%s\n", default_author_search);
X	fprintf (fp, "default_goto_group=%s\n", default_goto_group);
X	fprintf (fp, "default_group_search=%s\n", default_group_search);
X	fprintf (fp, "default_subject_search=%s\n", default_subject_search);
X	fprintf (fp, "default_art_search=%s\n", default_art_search);
X	fprintf (fp, "default_crosspost_group=%s\n", default_crosspost_group);
X	fprintf (fp, "default_mail_address=%s\n", default_mail_address);
X	fprintf (fp, "default_move_group=%d\n", default_move_group);
X	fprintf (fp, "default_pipe_command=%s\n", default_pipe_command);
X	fprintf (fp, "default_post_subject=%s\n", default_post_subject);
X	fprintf (fp, "default_regex_pattern=%s\n", default_regex_pattern);
X	fprintf (fp, "default_save_file=%s\n", default_save_file);
X	fprintf (fp, "default_select_pattern=%s\n", default_select_pattern);
X	fprintf (fp, "default_shell_command=%s\n", default_shell_command);
X
X	fclose (fp);
X	chmod (rcfile, 0600);
X}
X
X/*
X *  options menu so that the user can dynamically change parameters
X */
X 
Xint change_rcfile (group, kill_at_once)
X	char *group;
X	int kill_at_once;
X{
X	char *str = (char *) 0;
X	int ch, i;
X	int kill_changed = FALSE;
X	int orig_show_only_unread;
X	int orig_thread_arts;
X	int option;
X	int ret_code = NO_KILLING;
X	int var_orig;
X	
X#ifdef SIGTSTP
X	sigtype_t (*susp)();
X	
X	susp = (sigtype_t *) 0;
X
X	if (do_sigtstp) {
X		susp = sigdisp (SIGTSTP, SIG_DFL);
X	}
X#endif
X
X	COL1 = 0;
X	COL2 = ((COLS / 3) * 1) + 1;
X	COL3 = ((COLS / 3) * 2) + 2;
X
X	show_rcfile_menu ();
X
X	while (1) {
X
X#ifdef SIGTSTP
X		if (do_sigtstp) {
X			sigdisp (SIGTSTP, rcfile_suspend);
X		}
X#endif
X		MoveCursor (LINES, 0);
X		ch = ReadCh ();
X		if (ch >= '1' && ch <= '9') {
X			option = prompt_num (ch, "Enter option number> ");
X		} else {
X			if (ch == 'q' || ch == ESC) {
X				option = -1;
X			} else {
X				option = 0;
X			}
X		}
X#ifdef SIGTSTP
X		if (do_sigtstp) {
X			sigdisp (SIGTSTP, SIG_IGN);
X		}
X#endif
X		switch (option) {
X			case 0:
X				write_rcfile ();
X				/* FALLTHRU */
X			case -1:
X				if (kill_changed) {
X					if (kill_at_once) {
X						if (killed_articles = read_kill_file ()) {
X							if (kill_any_articles (group)) {
X								make_threads (FALSE);
X								find_base (show_only_unread);
X							}
X						} else {
X							if (unkill_all_articles()) {
X								make_threads (FALSE);
X								find_base (show_only_unread);
X							}
X						}
X					}
X					ret_code = KILLING;
X				}
X
X				clear_note_area ();
X#ifdef SIGTSTP
X				if (do_sigtstp) {
X					sigdisp (SIGTSTP, susp);
X				}
X#endif
X				return ret_code;
X			
X			case 1:		/* auto save */
X				prompt_on_off (INDEX_TOP, COL1, &save_archive_name, 
X					txt_help_autosave, txt_opt_autosave);
X				break;
X
X			case 2:		/* start editor with line offset */
X				prompt_on_off (INDEX_TOP, COL2, &start_editor_offset, 
X					txt_help_start_editor_offset, txt_opt_start_editor_offset);
X				break;
X			
X			case 3:		/* mark saved articles read */
X				prompt_on_off (INDEX_TOP, COL3, &mark_saved_read, 
X					txt_help_mark_saved_read, txt_opt_mark_saved_read);
X				break;
X
X			case 4:		/* confirm action */
X				prompt_on_off (INDEX_TOP+2, COL1, &confirm_action, 
X					txt_help_confirm_action, txt_opt_confirm_action);
X				break;
X
X			case 5:		/* draw -> / highlighted bar */
X				prompt_on_off (INDEX_TOP+2, COL2, &draw_arrow_mark, 
X					txt_help_draw_arrow, txt_opt_draw_arrow);
X				if (draw_arrow_mark == FALSE && inverse_okay == FALSE) {
X					inverse_okay = TRUE;
X				}
X				break;
X
X			case 6:		/* print header */
X				prompt_on_off (INDEX_TOP+2, COL3, &print_header, 
X					txt_help_print_header, txt_opt_print_header);
X				break;
X			
X			case 7:		/* position cursor at first / last unread art */
X				prompt_on_off (INDEX_TOP+4, COL1, &pos_first_unread, 
X					txt_help_pos_first_unread, txt_opt_pos_first_unread);
X				break;
X
X			case 8:		/* scroll half/full page of groups/articles */
X				prompt_on_off (INDEX_TOP+4, COL2, &full_page_scroll, 
X					txt_help_page_scroll, txt_opt_page_scroll);
X				break;
X
X			case 9:		/* catchup read groups when quitting */
X				prompt_on_off (INDEX_TOP+4, COL3, &catchup_read_groups, 
X					txt_help_catchup_groups, txt_opt_catchup_groups);
X				break;
X
X			case 10:	/* thread/unthread all groups except those in ~/.tin/unthreaded */
X				orig_thread_arts = thread_arts;	
X				prompt_on_off (INDEX_TOP+6, COL1, &thread_arts, 
X					txt_help_thread_arts, txt_opt_thread_arts);
X				if (thread_arts != orig_thread_arts || group != (char *) 0) {
X					make_threads (TRUE);
X					find_base (show_only_unread);
X				}
X				break;
X
X			case 11:	/* show all arts or just new/unread arts */
X				orig_show_only_unread = show_only_unread;	
X				prompt_on_off (INDEX_TOP+6, COL2, &show_only_unread, 
X					txt_help_show_only_unread, txt_opt_show_only_unread);
X				if (show_only_unread != orig_show_only_unread || group != (char *) 0) {
X					make_threads (TRUE);
X					find_base (show_only_unread);
X					if (space_mode) {
X						for (i = 0; i < top_base; i++) {
X							if (new_responses (i)) {
X								break;
X							}
X						}
X						if (i < top_base) {
X							index_point = i;
X						} else {
X							index_point = top_base - 1;
X						}
X					} else {
X						index_point = top_base - 1;
X					}
X				}
X				break;
X
X			case 12:	/* show newsgroup description text next to newsgroups */
X				prompt_on_off (INDEX_TOP+6, COL3, &show_description, 
X					txt_help_show_description, txt_opt_show_description);
X				if (show_description) {	/* force reread of newgroups file */
X					reread_active_file = TRUE;
X				}
X				break;
X
X			case 13:		/* show subject & author / subject only */
X				var_orig = show_author;
X				show_menu_help (txt_help_show_author);
X				do {
X					MoveCursor (INDEX_TOP+8, COL1 + (int) strlen (txt_opt_show_author));
X					if ((ch	= ReadCh()) == ' ') {
X						if (show_author + 1 > SHOW_FROM_BOTH) {
X							show_author = SHOW_FROM_NONE;
X						} else {
X							show_author++;
X						}
X						switch (show_author) {
X							case SHOW_FROM_NONE:
X								str = txt_show_from_none;
X								break;
X							case SHOW_FROM_ADDR:
X								str = txt_show_from_addr;
X								break;
X							case SHOW_FROM_NAME:
X								str = txt_show_from_name;
X								break;
X							case SHOW_FROM_BOTH:
X								str = txt_show_from_both;
X								break;
X						}
X						fputs (str, stdout);
X						fflush (stdout);
X					}
X				} while (ch != CR && ch != ESC);
X
X				if (ch == ESC) {	/* restore original value */
X					show_author = var_orig;
X					switch (show_author) {
X						case SHOW_FROM_NONE:
X							str = txt_show_from_none;
X							break;
X						case SHOW_FROM_ADDR:
X							str = txt_show_from_addr;
X							break;
X						case SHOW_FROM_NAME:
X							str = txt_show_from_name;
X							break;
X						case SHOW_FROM_BOTH:
X							str = txt_show_from_both;
X							break;
X					}
X					fputs (str, stdout);
X					fflush (stdout);
X				} else {
X					default_show_author = show_author;
X					set_subj_from_size (COLS);
X				}
X				break;
X
X			case 14:
X				var_orig = post_proc_type;
X				show_menu_help (txt_help_post_proc_type);
X				do {
X					MoveCursor (INDEX_TOP+8, COL2 + (int) strlen (txt_opt_process_type));
X					if ((ch	= ReadCh()) == ' ') {
X						if (post_proc_type + 1 > POST_PROC_UUD_EXT_ZOO) {
X							post_proc_type = POST_PROC_NONE;
X						} else {
X							post_proc_type++;
X						}
X						switch (post_proc_type) {
X							case POST_PROC_NONE:
X								str = txt_post_process_none;
X								proc_ch_default = 'n';
X								break;
X							case POST_PROC_SHAR:
X								str = txt_post_process_sh;
X								proc_ch_default = 's';
X								break;
X							case POST_PROC_UUDECODE:
X								str = txt_post_process_uudecode;
X								proc_ch_default = 'u';
X								break;
X							case POST_PROC_UUD_LST_ZOO:
X								str = txt_post_process_uud_lst_zoo;
X								proc_ch_default = 'U';
X								break;
X							case POST_PROC_UUD_EXT_ZOO:
X								str = txt_post_process_uud_ext_zoo;
X								proc_ch_default = 'U';
X								break;
X						}
X						CleartoEOLN (); 
X						fputs (str, stdout);
X						fflush (stdout);
X					}
X				} while (ch != CR && ch != ESC);
X
X				if (ch == ESC) {	/* restore original value */
X					post_proc_type = var_orig;
X					switch (post_proc_type) {
X						case POST_PROC_NONE:
X							str = txt_post_process_none;
X							proc_ch_default = 'n';
X							break;
X						case POST_PROC_SHAR:
X							str = txt_post_process_sh;
X							proc_ch_default = 's';
X							break;
X						case POST_PROC_UUDECODE:
X							str = txt_post_process_uudecode;
X							proc_ch_default = 'u';
X							break;
X						case POST_PROC_UUD_LST_ZOO:
X							str = txt_post_process_uud_lst_zoo;
X							proc_ch_default = 'U';
X							break;
X						case POST_PROC_UUD_EXT_ZOO:
X							str = txt_post_process_uud_ext_zoo;
X							proc_ch_default = 'U';
X							break;
X					}
X					CleartoEOLN (); 
X					fputs (str, stdout);
X					fflush (stdout);
X				}
X				break;
X
X			case 15:
X				var_orig = sort_art_type;
X				show_menu_help (txt_help_sort_type);
X				do {
X					MoveCursor (INDEX_TOP+10, COL1 + (int) strlen (txt_opt_sort_type));
X					if ((ch	= ReadCh()) == ' ') {
X						if (sort_art_type + 1 > SORT_BY_DATE_ASCEND) {
X							sort_art_type = SORT_BY_NOTHING;
X						} else {
X							sort_art_type++;
X						}
X						switch (sort_art_type) {
X							case SORT_BY_NOTHING:
X								str = txt_sort_by_nothing;
X								break;
X							case SORT_BY_SUBJ_DESCEND:
X								str = txt_sort_by_subj_descend;
X								break;
X							case SORT_BY_SUBJ_ASCEND:
X								str = txt_sort_by_subj_ascend;
X								break;
X							case SORT_BY_FROM_DESCEND:
X								str = txt_sort_by_from_descend;
X								break;
X							case SORT_BY_FROM_ASCEND:
X								str = txt_sort_by_from_ascend;
X								break;
X							case SORT_BY_DATE_DESCEND:
X								str = txt_sort_by_date_descend;
X								break;
X							case SORT_BY_DATE_ASCEND:
X								str = txt_sort_by_date_ascend;
X								break;
X						}
X						CleartoEOLN (); 
X						fputs (str, stdout);
X						fflush (stdout);
X					}
X				} while (ch != CR && ch != ESC);
X
X				if (ch == ESC) {	/* restore original value */
X					sort_art_type = var_orig;
X					switch (sort_art_type) {
X						case SORT_BY_NOTHING:
X							str = txt_sort_by_nothing;
X							break;
X						case SORT_BY_SUBJ_DESCEND:
X							str = txt_sort_by_subj_descend;
X							break;
X						case SORT_BY_SUBJ_ASCEND:
X							str = txt_sort_by_subj_ascend;
X							break;
X						case SORT_BY_FROM_DESCEND:
X							str = txt_sort_by_from_descend;
X							break;
X						case SORT_BY_FROM_ASCEND:
X							str = txt_sort_by_from_ascend;
X							break;
X						case SORT_BY_DATE_DESCEND:
X							str = txt_sort_by_date_descend;
X							break;
X						case SORT_BY_DATE_ASCEND:
X							str = txt_sort_by_date_ascend;
X							break;
X					}
X					CleartoEOLN (); 
X					fputs (str, stdout);
X					fflush (stdout);
X				}
X				break;
X
X			case 16:
X				show_menu_help (txt_help_savedir);
X				prompt_menu_string (INDEX_TOP+12, COL1 + (int) strlen (txt_opt_savedir), default_savedir);
X				expand_rel_abs_pathname (INDEX_TOP+12, COL1 + (int) strlen (txt_opt_savedir), default_savedir);
X				break;
X
X			case 17:
X				show_menu_help (txt_help_maildir);
X				prompt_menu_string (INDEX_TOP+14, COL1 + (int) strlen (txt_opt_maildir), default_maildir);
X				expand_rel_abs_pathname (INDEX_TOP+14, COL1 + (int) strlen (txt_opt_maildir), default_maildir);
X				break;
X
X			case 18:
X				show_menu_help (txt_help_printer);
X				prompt_menu_string (INDEX_TOP+16, COL1 + (int) strlen (txt_opt_printer), printer);
X				expand_rel_abs_pathname (INDEX_TOP+16, COL1 + (int) strlen (txt_opt_printer), printer);
X				break;
X		}
X		show_menu_help (txt_select_rcfile_option);
X	}
X}
X
X
Xvoid show_rcfile_menu ()
X{
X	char *str = (char *) 0;
X
X	ClearScreen ();
X
X	center_line (0, TRUE, txt_options_menu);
X	
X	MoveCursor (INDEX_TOP, 0);
X	printf ("%s%s\r\n\r\n", txt_opt_autosave, (save_archive_name ? "ON " : "OFF"));
X	printf ("%s%s\r\n\r\n", txt_opt_confirm_action, (confirm_action ? "ON " : "OFF"));
X	printf ("%s%s\r\n\r\n", txt_opt_pos_first_unread, (pos_first_unread ? "ON " : "OFF"));
X	printf ("%s%s", txt_opt_thread_arts, (thread_arts ? "ON " : "OFF"));
X
X	MoveCursor(INDEX_TOP, COL2);
X	printf ("%s%s", txt_opt_start_editor_offset, (start_editor_offset ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+2, COL2);
X	printf ("%s%s", txt_opt_draw_arrow, (draw_arrow_mark ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+4, COL2);
X	printf ("%s%s", txt_opt_page_scroll, (full_page_scroll ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+6, COL2);
X	printf ("%s%s", txt_opt_show_only_unread, (show_only_unread ? "ON " : "OFF"));
X
X	MoveCursor(INDEX_TOP, COL3);
X	printf ("%s%s", txt_opt_mark_saved_read, (mark_saved_read ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+2, COL3);
X	printf ("%s%s", txt_opt_print_header, (print_header ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+4, COL3);
X	printf ("%s%s", txt_opt_catchup_groups, (catchup_read_groups ? "ON " : "OFF"));
X	MoveCursor(INDEX_TOP+6, COL3);
X	printf ("%s%s", txt_opt_show_description, (show_description ? "ON " : "OFF"));
X
X	MoveCursor(INDEX_TOP+8, COL1);
X	switch (show_author) {
X		case SHOW_FROM_NONE:
X			str = txt_show_from_none;
X			break;
X		case SHOW_FROM_ADDR:
X			str = txt_show_from_addr;
X			break;
X		case SHOW_FROM_NAME:
X			str = txt_show_from_name;
X			break;
X		case SHOW_FROM_BOTH:
X			str = txt_show_from_both;
X			break;
X	}
X	printf ("%s%s", txt_opt_show_author, str);
X	MoveCursor(INDEX_TOP+8, COL2);
X	switch (post_proc_type) {
X		case POST_PROC_NONE:
X			str = txt_post_process_none;
X			break;
X		case POST_PROC_SHAR:
X			str = txt_post_process_sh;
X			break;
X		case POST_PROC_UUDECODE:
X			str = txt_post_process_uudecode;
X			break;
X		case POST_PROC_UUD_LST_ZOO:
X			str = txt_post_process_uud_lst_zoo;
X			break;
X		case POST_PROC_UUD_EXT_ZOO:
X			str = txt_post_process_uud_ext_zoo;
X			break;
X	}
X
X	printf ("%s%s\r\n\r\n", txt_opt_process_type, str);
X	
X	MoveCursor(INDEX_TOP+10, COL1);
X	switch (sort_art_type) {
X		case SORT_BY_NOTHING:
X			str = txt_sort_by_nothing;
X			break;
X		case SORT_BY_SUBJ_DESCEND:
X			str = txt_sort_by_subj_descend;
X			break;
X		case SORT_BY_SUBJ_ASCEND:
X			str = txt_sort_by_subj_ascend;
X			break;
X		case SORT_BY_FROM_DESCEND:
X			str = txt_sort_by_from_descend;
X			break;
X		case SORT_BY_FROM_ASCEND:
X			str = txt_sort_by_from_ascend;
X			break;
X		case SORT_BY_DATE_DESCEND:
X			str = txt_sort_by_date_descend;
X			break;
X		case SORT_BY_DATE_ASCEND:
X			str = txt_sort_by_date_ascend;
X			break;
X	}
X	printf ("%s%s\r\n\r\n", txt_opt_sort_type, str);
X
X	printf ("%s%s\r\n\r\n", txt_opt_savedir, default_savedir);
X	printf ("%s%s\r\n\r\n", txt_opt_maildir, default_maildir);
X	printf ("%s%s\r\n\r\n", txt_opt_printer, printer);
X	fflush(stdout);
X
X	show_menu_help (txt_select_rcfile_option);
X	MoveCursor (LINES, 0);
X}
X
X/*
X *  expand ~/News to /usr/username/News and print to screen
X */
X 
Xvoid expand_rel_abs_pathname (line, col, str)
X	int line;
X	int col;
X	char *str;
X{
X	char buf[LEN];
X	
X	if (str[0] == '~') {
X		if (strlen (str) == 1) {
X			strcpy (str, homedir);
X		} else {
X			sprintf (buf, "%s%s", homedir, str+1);
X			strcpy (str, buf);
X		}
X	}
X	MoveCursor (line, col);
X	CleartoEOLN ();
X	puts (str);
X	fflush (stdout);
X}
X
X/*
X *  show_menu_help
X */
X 
Xvoid show_menu_help (help_message)
X	char *help_message;
X{
X	 MoveCursor (LINES-2, 0);
X	 CleartoEOLN ();
X	 center_line (LINES-2, FALSE, help_message);
X}
X
X
Xint match_boolean (line, pat, dst)
X	char *line;
X	char *pat;
X	int *dst;
X{
X	int	patlen = strlen (pat);
X
X	if (strncmp (line, pat, patlen) == 0) {
X		*dst = (strncmp (&line[patlen], "ON", 2) == 0 ? TRUE : FALSE);
X		return TRUE;
X	}
X	return FALSE;
X}
X
X
Xint match_number (line, pat, dst)
X	char *line;
X	char *pat;
X	int *dst;
X{
X	int	patlen = strlen (pat);
X
X	if (strncmp (line, pat, patlen) == 0) {
X		*dst = atoi (&line[patlen]);
X		return TRUE;
X	}
X	return FALSE;
X}
X
X
Xint match_string (line, pat, dst, dstlen)
X	char *line;
X	char *pat;
X	char *dst;
X	int dstlen;
X{
X	int	patlen = strlen (pat);
X
X	if (strncmp (line, pat, patlen) == 0) {
X		strncpy (dst, &line[patlen], dstlen);
X		dst[strlen (dst) - 1] = '\0';
X		return TRUE;
X	}
X	return FALSE;
X}
X
END_OF_FILE
  if test 24690 -ne `wc -c <'rcfile.c'`; then
    echo shar: \"'rcfile.c'\" unpacked with wrong size!
  fi
  # end of 'rcfile.c'
fi
echo shar: End of archive 9 \(of 15\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
