Newsgroups: comp.sources.misc
From: iain%anl433.uucp@Germany.EU.net (Iain Lea)
Subject:  v31i003:  tin - threaded full screen newsreader v1.1 PL4, Part03/15
Message-ID: <1992Jul7.181334.6547@sparky.imd.sterling.com>
X-Md4-Signature: 02bc86fb5ac6ed23b8584c6c183203a9
Date: Tue, 7 Jul 1992 18:13:34 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: iain%anl433.uucp@Germany.EU.net (Iain Lea)
Posting-number: Volume 31, Issue 3
Archive-name: tin/part03
Environment: BSD, SCO, ISC, SUNOS, SYSVR3, SYSVR4, ULTRIX, XENIX
Supersedes: tin: Volume 30, Issue 1-14

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  MANIFEST misc.c server.patch
# Wrapped by kent@sparky on Mon Jun 29 23:35:09 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 15)."'
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
  echo shar: Extracting \"'MANIFEST'\" \(953 characters\)
  sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
XMANIFEST for tin newsreader (Tue Jun 23 07:17:54 MET DST 1992)
X----------------------------------------------------------
X   13853 Makefile
X     122 MANIFEST
X    3338 README
X    8432 CHANGES
X    9003 INSTALL
X    5083 TODO
X   14588 FAQ
X    2568 FTP
X   40703 tin.1
X    2247 wildmat.3
X   50832 tin.nrf
X     489 kill
X   14455 tin.h
X   18278 extern.h
X    4658 nntplib.h
X   28626 proto.h
X     585 patchlev.h
X   10048 active.c
X   22975 art.c
X    8719 curses.c
X    4317 debug.c
X   14656 feed.c
X   11458 getline.c
X   29136 group.c
X    2510 hashstr.c
X    5901 help.c
X    4721 inews.c
X   15082 init.c
X   13051 kill.c
X   24092 lang.c
X   12528 main.c
X    7855 memory.c
X   16344 misc.c
X   20406 newsrc.c
X   14736 nntplib.c
X   14367 open.c
X   22481 page.c
X   28095 post.c
X    3150 prompt.c
X   24690 rcfile.c
X   25838 save.c
X    2916 screen.c
X    7173 search.c
X   24921 select.c
X   10115 signal.c
X   14375 spooldir.c
X   20862 thread.c
X    4798 wildmat.c
X  660176 total
END_OF_FILE
  if test 953 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
  fi
  # end of 'MANIFEST'
fi
if test -f 'misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc.c'\"
else
  echo shar: Extracting \"'misc.c'\" \(16344 characters\)
  sed "s/^X//" >'misc.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : misc.c
X *  Author    : I.Lea & R.Skrenta
X *  Created   : 01-04-91
X *  Updated   : 20-06-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
Xstatic char *mailbox_name = (char *) 0;
Xstatic int  mailbox_size;
X
X
Xvoid asfail (file, line, cond)
X	char	*file;
X	int	line;
X	char	*cond;
X{
X  	fprintf (stderr, "%s: assertion failure: %s (%d): %s\n",
X  		progname, file, line, cond);
X  	fflush (stderr);
X  	
X 	/*
X 	 * create a core dump
X 	 */
X#ifdef SIGABRT	
X	sigdisp(SIGABRT, SIG_DFL);
X 	kill (process_id, SIGABRT);
X#else
X#	ifdef SIGILL
X		sigdisp(SIGILL, SIG_DFL);
X 		kill (process_id, SIGILL);
X#	else
X#		ifdef SIGIOT
X			sigdisp(SIGIOT, SIG_DFL);
X		 	kill (process_id, SIGIOT);
X#		endif
X#	endif
X#endif
X 
X	exit(1);
X}
X
X
Xvoid copy_fp (fp_ip, fp_op, prefix)
X	FILE *fp_ip;
X	FILE *fp_op;
X	char *prefix;
X{
X	extern int errno;
X	char buf[8192];
X
X	while (fgets (buf, sizeof (buf), fp_ip) != NULL) {
X		if (fprintf (fp_op, "%s%s", prefix, buf) == EOF) {
X			if (errno == EPIPE) {
X				return;
X			}
X			sprintf (msg, "Error: fprintf() failed in copy_fp(). errno=%d", errno);
X			perror_message (msg, "");
X		}
X	}
X}
X
X
Xchar *get_val (env, def)
X	char *env;		/* Environment variable we're looking for	*/
X	char *def;		/* Default value if no environ value found	*/
X{
X	char *ptr;
X
X	if ((ptr = (char *) getenv(env)) != NULL)
X		return (ptr);
X	else
X		return (def);
X}
X
X
Xint invoke_editor (nam)
X	char *nam;
X{
X	char buf[LEN];
X	char *my_editor;
X	static char editor[LEN];
X	static int first = TRUE;
X
X	if (first) {
X		my_editor = (char *) getenv ("VISUAL");
X
X		strcpy (editor, my_editor != NULL ? my_editor : get_val ("EDITOR", DEFAULT_EDITOR));
X		first = FALSE;
X	}
X
X	if (start_editor_offset) {
X		sprintf (buf, "%s +%d %s", editor, start_line_offset, nam);
X	} else {
X		sprintf (buf, "%s %s", editor, nam);
X	}
X
X	wait_message (buf);
X
X	return invoke_cmd (buf);
X}
X
X
Xvoid shell_escape ()
X{
X	char shell[LEN];
X	char *p;
X
X#ifdef SIGTSTP
X	sigtype_t (*susp)();
X	susp = (sigtype_t *) 0;
X#endif
X
X	sprintf (msg, txt_shell_escape, default_shell_command);
X	
X	if (! prompt_string (msg, shell))
X		my_strncpy (shell, get_val ("SHELL", DEFAULT_SHELL), sizeof (shell));
X
X	for (p = shell; *p && (*p == ' ' || *p == '\t'); p++)
X		continue;
X
X	if (*p) {
X		my_strncpy (default_shell_command, p, sizeof (default_shell_command));
X	} else {
X		if (default_shell_command[0]) {
X			my_strncpy (shell, default_shell_command, sizeof (shell));
X		} else {
X			my_strncpy (shell, get_val ("SHELL", DEFAULT_SHELL), sizeof (shell));
X		}
X		p = shell;
X	}
X
X	ClearScreen ();
X	sprintf (msg, "Shell Command (%s)", p);
X	center_line (0, TRUE, msg);
X	MoveCursor (INDEX_TOP, 0);
X	
X	EndWin ();
X	Raw (FALSE);
X
X#ifdef SIGTSTP
X	if (do_sigtstp)
X		susp = signal (SIGTSTP, SIG_DFL);
X#endif
X
X	system (p);
X
X#ifdef SIGTSTP
X	if (do_sigtstp)
X		signal (SIGTSTP, susp);
X#endif
X
X	Raw (TRUE);
X	InitWin ();
X
X	mail_setup ();
X
X	continue_prompt ();
X
X	if (draw_arrow_mark) {
X		ClearScreen ();
X	}
X}
X
X
Xvoid tin_done (ret)
X	int ret;
X{
X	extern char index_file[PATH_LEN];
X	char group_path[PATH_LEN], *p;
X	int ask = TRUE;
X	register int i, j;
X	
X	/*
X	 * check if any groups were read & ask if they should marked read
X	 */
X	if (catchup_read_groups) {
X		for (i = 0 ; i < group_top ; i++) {
X			if (active[my_group[i]].attribute.read) {
X				if (ask) {
X					if (prompt_yn (LINES, "Catchup all groups entered during this session? (y/n): ", 'n')) {
X						ask = FALSE;
X						thread_arts = FALSE;	/* speeds up index loading */
X					} else {
X						break;
X					}
X				}
X				sprintf (msg, "Catchup %s...", active[my_group[i]].name);
X				wait_message (msg);
X				my_strncpy (group_path, active[my_group[i]].name, sizeof (group_path));
X				for (p = group_path ; *p ; p++) {
X					if (*p == '.') {
X						*p = '/';
X					}
X				}
X				index_group (active[my_group[i]].name, group_path);
X				for (j = 0; j < top; j++) {
X					arts[j].unread = ART_READ;
X				}
X				update_newsrc (active[my_group[i]].name, my_group[i], FALSE);
X			}
X		}
X	}
X	nntp_close ();			/* disconnect from NNTP server */
X	free_all_arrays ();		/* deallocate all arrays */
X	ClearScreen ();
X	EndWin ();
X	Raw (FALSE);
X
X	if (read_news_via_nntp && xindex_supported) {
X		unlink (index_file);
X	}
X
X#ifdef INDEX_DAEMON
X	unlink (LOCK_FILE);
X#endif
X
X	exit (ret);
X}
X
X#ifdef USE_MKDIR
Xmkdir (path, mode)
X	char *path;
X	int mode;
X{
X	char buf[LEN];
X	struct stat sb;
X
X	sprintf(buf, "mkdir %s", path);
X	if (stat (path, &sb) == -1) {
X		system (buf);
X		chmod (path, mode);
X	}
X}
X#endif
X
X/*
X * hash group name for fast lookup later 
X */
X
Xlong hash_groupname (group)
X	char *group;
X{
X	unsigned long hash_value;
X	unsigned char *ptr = (unsigned char *) group;
X
X	hash_value = *ptr++;
X
X	while (*ptr)
X		hash_value = ((hash_value << 1) ^ *ptr++) % TABLE_SIZE;
X
X	return (hash_value);
X}
X
X
Xvoid rename_file (old_filename, new_filename)
X	char *old_filename;
X	char *new_filename;
X{	
X	char buf[1024];
X	FILE *fp_old, *fp_new;
X	
X	unlink (new_filename);
X	
X	if (link (old_filename, new_filename) == -1) {
X		if (errno == EXDEV) {	/* create & copy file across filesystem */
X			if ((fp_old = fopen (old_filename, "r")) == (FILE *) 0) {
X				sprintf (buf, txt_cannot_open, old_filename);
X				perror_message (buf, "ONE");
X				return;
X			}
X			if ((fp_new = fopen (new_filename, "w")) == (FILE *) 0) {
X				sprintf (buf, txt_cannot_open, new_filename);
X				perror_message (buf, "ONE");
X				return;
X			}
X			copy_fp (fp_old, fp_new, "");
X			fclose (fp_new);	
X			fclose (fp_old);	
X			errno = 0;
X		} else {
X			sprintf (buf, txt_rename_error, old_filename, new_filename);
X			perror_message (buf, "THREE");
X			return;
X		}	
X	}
X	if (unlink (old_filename) == -1) {
X		sprintf (buf, txt_rename_error, old_filename, new_filename);
X		perror_message (buf, "TWO");
X		return;
X	}
X}
Xchar *str_dup (str)
X	char *str;
X{
X	char *dup = (char *) 0;
X
X	if (str) {
X		dup = my_malloc (strlen (str)+1);
X		strcpy (dup, str);
X	}
X	return dup;
X}
X
X
Xint invoke_cmd (nam)
X	char *nam;
X{
X	int ret;
X#ifdef SIGTSTP
X	sigtype_t (*susp)();
X	susp = (sigtype_t *) 0;
X#endif
X
X	set_alarm_clock_off ();
X
X	EndWin ();
X	Raw (FALSE);
X
X#ifdef SIGTSTP
X	if (do_sigtstp)
X		susp = signal(SIGTSTP, SIG_DFL);
X#endif
X
X#ifdef SIGCHLD
X	system (nam);
X	ret = system_status;
X#else
X	ret = system (nam);
X#endif
X
X#ifdef SIGTSTP
X	if (do_sigtstp)
X		signal (SIGTSTP, susp);
X#endif
X
X	Raw (TRUE);
X	InitWin ();
X
X	set_alarm_clock_on ();
X	
X	return ret == 0;
X}
X
X
Xvoid draw_percent_mark (cur_num, max_num)
X	int cur_num;
X	int max_num;
X{
X	char buf[32];
X	int percent = 0;
X
X	if (NOTESLINES <= 0) {
X		return;
X	}
X
X	if (cur_num <= 0 && max_num <= 0) {
X		return;
X	}
X		
X	percent = cur_num * 100 / max_num;
X	sprintf (buf, "%s(%d%%) [%d/%d]", txt_more, percent, cur_num, max_num);
X	MoveCursor (LINES, (COLS - (int) strlen (buf))-(1+BLANK_PAGE_COLS));
X	StartInverse ();	
X	fputs (buf, stdout);
X	fflush (stdout);
X	EndInverse ();
X}
X
Xvoid set_real_uid_gid ()
X{
X	if (local_index)
X		return;
X
X	umask (real_umask);
X	
X#ifdef USE_SETREUID
X	if (setreuid (-1, real_uid) == -1) {
X		perror_message ("Error setreuid(real) failed", "");
X	}
X	if (setregid (-1, real_gid) == -1) {
X		perror_message ("Error setregid(real) failed", "");
X	}
X#else	
X#  if defined(BSD) && ! defined(sinix)
X#    ifdef sun
X	if (seteuid (real_uid) == -1) {
X		perror_message ("Error setreuid(real) failed", "");
X	}
X	if (setegid (real_gid) == -1) {
X		perror_message ("Error setregid(real) failed", "");
X	}
X#    else
X	if (setreuid (tin_uid, real_uid) == -1) {
X		perror_message ("Error setreuid(real) failed", "");
X	}
X	if (setregid (tin_gid, real_gid) == -1) {
X		perror_message ("Error setregid(real) failed", "");
X	}
X#    endif	/* sun */	
X#  else
X	if (setuid (real_uid) == -1) {
X		perror_message ("Error setuid(real) failed", "");
X	}
X	if (setgid (real_gid) == -1) {
X		perror_message ("Error setgid(real) failed", "");
X	}
X#  endif
X#endif
X}
X
X
Xvoid set_tin_uid_gid ()
X{
X	if (local_index)
X		return;
X
X	umask (0);
X
X#ifdef USE_SETREUID
X	if (setreuid (-1, tin_uid) == -1) {
X		perror_message ("Error setreuid(tin) failed", "");
X	}
X	if (setregid (-1, tin_gid) == -1) {
X		perror_message ("Error setregid(tin) failed", "");
X	}
X#else	
X#  if defined(BSD) && ! defined(sinix)
X#    ifdef sun
X	if (seteuid (tin_uid) == -1) {
X		perror_message ("Error setreuid(real) failed", "");
X	}
X	if (setegid (tin_gid) == -1) {
X		perror_message ("Error setregid(real) failed", "");
X	}
X#    else
X	if (setreuid (real_uid, tin_uid) == -1) {
X		perror_message ("Error setreuid(tin) failed", "");
X	}
X	if (setregid (real_gid, tin_gid) == -1) {
X		perror_message ("Error setregid(tin) failed", "");
X	}
X#    endif	/* sun */	
X#  else
X	if (setuid (tin_uid) == -1) {
X		perror_message ("Error setuid(tin) failed", "");
X	}
X	if (setgid (tin_gid) == -1) {
X		perror_message ("Error setgid(tin) failed", "");
X	}
X#  endif
X#endif
X}
X
X
Xvoid basename (dirname, program)
X	char *dirname;		/* argv[0] */
X	char *program;		/* progname is returned */
X{
X	int i;
X	
X	strcpy (program, dirname);
X	
X	for (i=(int) strlen (dirname)-1 ; i ; i--) {
X		if (dirname[i] == '/') {
X			strcpy (program, dirname+(i+1));
X			break;
X		}
X	}
X}
X
X
X/*
X *  Record size of mailbox so we can detect if new mail has arrived
X */
X
Xvoid mail_setup ()
X{
X	struct stat buf;
X
X	mailbox_name = get_val ("MAIL", mailbox);
X
X	if (stat (mailbox_name, &buf) >= 0) {
X		mailbox_size = buf.st_size;
X	} else {
X		mailbox_size = 0;
X	}
X}
X
X/*
X *  Return TRUE if new mail has arrived
X */
X
Xint mail_check ()
X{
X	struct stat buf;
X
X	if (mailbox_name != (char *) 0 &&
X		stat (mailbox_name, &buf) >= 0 &&
X		mailbox_size < buf.st_size) {
X		return TRUE;
X	}
X
X	return FALSE;
X}
X
X/*
X *  Parse various From: lines into the component mail addresses and
X *  real names
X */
X
Xvoid parse_from (str, addr, name)
X	char *str;
X	char *addr;
X	char *name;
X{
X	register int c;
X	register char *cp, *ncp;
X	int gotlt, lastsp, level;
X
X	gotlt = 0;
X	lastsp = 0;
X	cp = addr;
X	ncp = name;
X	while (*str == ' ')
X		++str;
X	while (c = *str++)
X		switch (c) {
X		case '(':
X			ncp = name;
X			level = 1;
X			while (*str != '\0' && level) {
X				switch (c = *str++) {
X					case '(':
X						*ncp++ = c;
X						level++;
X						break;
X					case ')':
X						level--;
X						if (level > 0)
X							*ncp++ = c;
X						break;
X					default:
X						if (c != '"') {	/* IL */
X							*ncp++ = c;
X						}	
X						break;
X				}
X			}
X			if (*str)
X				str++;
X			lastsp = 0;
X			break;
X		case ' ':
X			if (str[0] == 'a' && str[1] == 't' && str[2] == ' ')
X				str += 3, *cp++ = '@';
X			else if (str[0] == '@' && str[1] == ' ')
X				str += 2, *cp++ = '@';
X			else
X				lastsp = 1;
X			if (ncp > name)
X				*ncp++ = ' ';
X			break;
X		case '<':
X			cp = addr;
X			gotlt++;
X			lastsp = 0;
X			break;
X		case '>':
X			if (gotlt)
X				goto done;
X			/* FALL THROUGH CASE */
X		default:
X			if (lastsp) {
X				lastsp = 0;
X				*cp++ = ' ';
X			}
X			*cp++ = c;
X			if (! gotlt)
X				*ncp++ = c;
X			break;
X		}
Xdone:
X	*cp = 0;
X	while (ncp>name && ncp[-1]==' ')
X		--ncp;
X	*ncp = 0;
X	if (*addr == '@') {
X		char buf [512];
X
X		strcpy (buf, addr);
X		strcpy (addr, "root");
X		strcat (addr, buf);
X	}
X}
X
X/*
X *  Convert a string to a long, only look at first n characters
X */
X
Xlong my_atol (s, n)
X	char *s;
X	int n;
X{
X	long ret = 0;
X
X	while (*s && n--) {
X		if (*s >= '0' && *s <= '9')
X			ret = ret * 10 + (*s - '0');
X		else
X			return -1;
X		s++;
X	}
X
X	return ret;
X}
X
X/*
X *  strcmp that ignores case
X */
X
X#define FOLD_TO_UPPER(a)	(islower ((int) (a)) ? toupper ((int) (a)) : (a))
X
Xint my_stricmp (p, q)
X	char *p;
X	char *q;
X{
X	for (; FOLD_TO_UPPER (*p) == FOLD_TO_UPPER (*q); ++p, ++q) {
X		if (*p == '\0') {
X			return (0);
X		}
X	}		
X
X	return (FOLD_TO_UPPER (*p) - FOLD_TO_UPPER (*q));
X}
X
X/*
X *  Return a pointer into s eliminating any leading Re:'s.  Example:
X *
X *	  Re: Reorganization of misc.jobs
X *	  ^   ^
X */
X
Xchar *eat_re (s)
X	char *s;
X{
X
X	while (*s == 'r' || *s == 'R') {
X		if ((*(s+1) == 'e' || *(s+1) == 'E')) {
X			if (*(s+2) == ':')
X				s += 3;
X			else if (*(s+2) == '^' && isdigit(*(s+3)) && *(s+4) == ':')
X				s += 5;			/* hurray nn */
X			else
X				break;
X		} else
X			break;
X		while (*s == ' ')
X			s++;
X	}
X
X	return s;
X}
X
X/*
X *  Hash the subjects (after eating the Re's off) for a quicker
X *  thread search later.  We store the hashes for subjects in the
X *  index file for speed.
X */
X
Xlong hash_s (s)
X	char *s;
X{
X	long h = 0;
X	unsigned char *t = (unsigned char *) s;
X
X	while (*t)
X		h = h * 64 + *t++;
X
X	return h;
X}
X
X/*
X *  strncpy that stops at a newline and null terminates
X */
X
Xvoid my_strncpy (p, q, n)
X	char *p;
X	char *q;
X	int n;
X{
X	while (n--) {
X		if (! *q || *q == '\n')
X			break;
X		*p++ = *q++;
X	}
X	*p = '\0';
X}
X
X
Xint untag_all_articles ()
X{
X	int untagged = FALSE;
X	register int i;
X
X	for (i=0 ; i < top ; i++) {
X		if (arts[i].tagged) {
X			arts[i].tagged = FALSE;
X			untagged = TRUE;
X		}
X	}
X	num_of_tagged_arts = 0;
X
X	return (untagged);
X}
X
X
X/*
X * ANSI C strstr () - Uses Boyer-Moore algorithm.
X */
X 
Xchar *str_str (text, pattern, patlen)
X	char *text;
X	char *pattern;
X	int patlen;
X{
X	register unsigned char *p, *t;
X	register int i, p1, j, *delta;
X	int deltaspace[256];
X	int textlen;
X
X	textlen = strlen (text);
X
X	/* algorithm fails if pattern is empty */
X	if ((p1 = patlen) == 0)
X		return (text);
X
X	/* code below fails (whenever i is unsigned) if pattern too long */
X	if (p1 > textlen)
X		return (NULL);
X
X	/* set up deltas */
X	delta = deltaspace;
X	for (i = 0; i <= 255; i++)
X		delta[i] = p1;
X	for (p = (unsigned char *) pattern, i = p1; --i > 0;)
X		delta[*p++] = i;
X
X	/*
X	 * From now on, we want patlen - 1.
X	 * In the loop below, p points to the end of the pattern,
X	 * t points to the end of the text to be tested against the
X	 * pattern, and i counts the amount of text remaining, not
X	 * including the part to be tested.
X	 */
X	p1--;
X	p = (unsigned char *) pattern + p1;
X	t = (unsigned char *) text + p1;
X	i = textlen - patlen;
X	for (;;) {
X		if (*p == *t && memcmp ((p - p1), (t - p1), p1) == 0)
X			return ((char *)t - p1);
X		j = delta[*t];
X		if (i < j)
X			break;
X		i -= j;
X		t += j;
X	}
X	return (NULL);
X}
X
X
X
Xvoid get_author (thread, respnum, str)
X	int thread;
X	int respnum;
X	char *str;
X{	
X	extern int threaded_on_subject;
X	int author;
X/*
X	int len_from = max_from;
X
X	if (thread) {
X		if (threaded_on_subject) {
X			len_from = max_subj+max_from;
X		} else {
X			len_from = max_from;
X		}
X		author = SHOW_FROM_BOTH;
X	} else {
X		author = show_author;
X	} 
X*/
X	if (thread) {
X		if (threaded_on_subject) {
X			author = SHOW_FROM_BOTH;
X		} else {
X			author = show_author;
X		}
X	} else {
X		author = show_author;
X	} 
X	
X	switch (author) { 
X		case SHOW_FROM_NONE:
X			str[0] = '\0';
X			break;
X		case SHOW_FROM_ADDR:
X			strcpy (str, arts[respnum].from);
X			break;
X		case SHOW_FROM_NAME:
X			strcpy (str, arts[respnum].name);
X			break;
X		case SHOW_FROM_BOTH:
X			if (arts[respnum].name != arts[respnum].from) { 
X				sprintf (str, "%s (%s)", arts[respnum].name, arts[respnum].from);
X			} else { 
X				strcpy (str, arts[respnum].from);
X			}
X			break;
X	}
X}
X
X
Xvoid toggle_inverse_video ()
X{
X	inverse_okay = !inverse_okay;
X	if (inverse_okay) {
X#ifndef USE_INVERSE_HACK	
X		draw_arrow_mark = FALSE;
X#endif		
X		info_message (txt_inverse_on);
X	} else {
X		draw_arrow_mark = TRUE;
X		info_message (txt_inverse_off);
X	}
X}
X
X
Xint get_arrow_key ()
X{
X	int ch;
X	
X	ch = ReadCh ();
X	if (ch == '[' || ch == 'O')
X		ch = ReadCh();
X	switch (ch) {
X		case 'A':
X		case 'D':
X		case 'i':
X			return KEYMAP_UP;
X
X		case 'B':
X		case 'C':
X			return KEYMAP_DOWN;
X
X		case 'I':		/* ansi  PgUp */
X		case 'V':		/* at386 PgUp */
X		case 'S':		/* 97801 PgUp */
X		case 'v':		/* emacs style */
X			return KEYMAP_PAGE_UP;
X
X		case 'G':		/* ansi  PgDn */
X		case 'U':		/* at386 PgDn */
X		case 'T':		/* 97801 PgDn */
X			return KEYMAP_PAGE_DOWN;
X
X		case 'H':		/* at386  Home */
X			return KEYMAP_HOME;
X					
X		case 'F':		/* ansi   End */
X		case 'Y':		/* at386  End */
X			return KEYMAP_END;
X
X		case '5':		/* vt200 PgUp */
X			ch = ReadCh ();	/* eat the ~  */
X			return KEYMAP_PAGE_UP;
X
X		case '6':		/* vt200 PgUp */
X			ch = ReadCh ();	/* eat the ~  */
X			return KEYMAP_PAGE_DOWN;
X
X		case '1':		/* vt200 PgUp */
X			ch = ReadCh ();	/* eat the ~  */
X			return KEYMAP_HOME;
X					
X		case '4':		/* vt200 PgUp */
X			ch = ReadCh ();	/* eat the ~  */
X			return KEYMAP_END;
X
X		default:
X			return KEYMAP_UNKNOWN;
X	}
X}
END_OF_FILE
  if test 16344 -ne `wc -c <'misc.c'`; then
    echo shar: \"'misc.c'\" unpacked with wrong size!
  fi
  # end of 'misc.c'
fi
if test -f 'server.patch' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server.patch'\"
else
  echo shar: Extracting \"'server.patch'\" \(34102 characters\)
  sed "s/^X//" >'server.patch' <<'END_OF_FILE'
Xdiff -rcs server.old/Makefile server/Makefile
X*** server.old/Makefile	Mon May  4 07:03:54 1992
X--- server/Makefile	Mon May  4 07:16:35 1992
X***************
X*** 6,18 ****
X  	ahbs.o globals.o group.o help.o ihave.o list.o misc.o netaux.o \
X  	newgroups.o newnews.o nextlast.o ngmatch.o post.o parsit.o scandir.o \
X  	slave.o spawn.o strcasecmp.o subnet.o time.o xhdr.o fakesyslog.o \
X! 	batch.o auth.o timer.o ../common/version.o
X  
X  SRVRSRC = main.c serve.c access.c access_inet.c access_dnet.c active.c \
X  	ahbs.c globals.c group.c help.c ihave.c list.c misc.c netaux.c \
X  	newgroups.c newnews.c nextlast.c ngmatch.c post.c parsit.c scandir.c \
X  	slave.c spawn.c strcasecmp.c subnet.c time.c xhdr.c fakesyslog.c \
X! 	batch.c auth.c timer.c ../common/version.c
X  
X  SRVRINC = common.h ../common/conf.h ../common/nntp.h timer.h
X  
X--- 6,18 ----
X  	ahbs.o globals.o group.o help.o ihave.o list.o misc.o netaux.o \
X  	newgroups.o newnews.o nextlast.o ngmatch.o post.o parsit.o scandir.o \
X  	slave.o spawn.o strcasecmp.o subnet.o time.o xhdr.o fakesyslog.o \
X! 	batch.o auth.o timer.o ../common/version.o xuser.o xindex.o
X  
X  SRVRSRC = main.c serve.c access.c access_inet.c access_dnet.c active.c \
X  	ahbs.c globals.c group.c help.c ihave.c list.c misc.c netaux.c \
X  	newgroups.c newnews.c nextlast.c ngmatch.c post.c parsit.c scandir.c \
X  	slave.c spawn.c strcasecmp.c subnet.c time.c xhdr.c fakesyslog.c \
X! 	batch.c auth.c timer.c ../common/version.c xuser.c xindex.c
X  
X  SRVRINC = common.h ../common/conf.h ../common/nntp.h timer.h
X  
XFiles server.old/README and server/README are identical
XFiles server.old/SYSLOG and server/SYSLOG are identical
Xdiff -rcs server.old/access.c server/access.c
X*** server.old/access.c	Mon May  4 07:03:55 1992
X--- server/access.c	Sat Mar  7 11:46:00 1992
X***************
X*** 44,50 ****
X  
X  #ifdef AUTH
X  extern	int Needauth;
X! #endif AUTH
X  
X  host_access(canread, canpost, canxfer, gdlist)
X  	int		*canread, *canpost, *canxfer;
X--- 44,50 ----
X  
X  #ifdef AUTH
X  extern	int Needauth;
X! #endif /* AUTH */
X  
X  host_access(canread, canpost, canxfer, gdlist)
X  	int		*canread, *canpost, *canxfer;
X***************
X*** 230,236 ****
X  	/* do we require a userid and password for this guy? */
X  	if (isupper(readperm[0]) || isupper(postperm[0]))
X  		Needauth = 1;
X! #endif AUTH
X  }
X  
X  #ifdef DOMAINMATCH
X--- 230,236 ----
X  	/* do we require a userid and password for this guy? */
X  	if (isupper(readperm[0]) || isupper(postperm[0]))
X  		Needauth = 1;
X! #endif /* AUTH */
X  }
X  
X  #ifdef DOMAINMATCH
X***************
X*** 267,270 ****
X  
X  	return (0);
X  }
X! #endif DOMAINMATCH
X--- 267,270 ----
X  
X  	return (0);
X  }
X! #endif /* DOMAINMATCH */
XFiles server.old/access_dnet.c and server/access_dnet.c are identical
Xdiff -rcs server.old/access_inet.c server/access_inet.c
X*** server.old/access_inet.c	Mon May  4 07:03:55 1992
X--- server/access_inet.c	Sat Mar  7 11:46:00 1992
X***************
X*** 77,83 ****
X  	}
X  #else
X  	subnet_name[0] = '\0';
X! #endif SUBNET
X  
X  	hp = gethostbyaddr((char *) &sin->sin_addr.s_addr,
X  		sizeof (sin->sin_addr.s_addr), AF_INET);
X--- 77,83 ----
X  	}
X  #else
X  	subnet_name[0] = '\0';
X! #endif /* SUBNET */
X  
X  	hp = gethostbyaddr((char *) &sin->sin_addr.s_addr,
X  		sizeof (sin->sin_addr.s_addr), AF_INET);
XFiles server.old/active.c and server/active.c are identical
XFiles server.old/ahbs.c and server/ahbs.c are identical
Xdiff -rcs server.old/auth.c server/auth.c
X*** server.old/auth.c	Mon May  4 07:03:55 1992
X--- server/auth.c	Sat Mar  7 11:46:00 1992
X***************
X*** 149,152 ****
X  	Needauth = 0;
X  }
X  
X! #endif AUTH
X--- 149,152 ----
X  	Needauth = 0;
X  }
X  
X! #endif /* AUTH */
Xdiff -rcs server.old/batch.c server/batch.c
X*** server.old/batch.c	Mon May  4 07:03:55 1992
X--- server/batch.c	Sat Mar  7 11:46:00 1992
X***************
X*** 255,265 ****
X  #ifdef SYSLOG
X  #ifdef LOG
X  	syslog(LOG_ERR, "%s transfer_timeout", hostname);
X! #endif LOG
X  #endif
X  	(void) unlink(tempfile);
X  	exit(1);
X! #endif XFER_TIMEOUT
X  }
X  
X  /*
X--- 255,265 ----
X  #ifdef SYSLOG
X  #ifdef LOG
X  	syslog(LOG_ERR, "%s transfer_timeout", hostname);
X! #endif /* LOG */
X  #endif
X  	(void) unlink(tempfile);
X  	exit(1);
X! #endif /* XFER_TIMEOUT */
X  }
X  
X  /*
Xdiff -rcs server.old/common.h server/common.h
X*** server.old/common.h	Mon May  4 07:03:55 1992
X--- server/common.h	Sun Mar  8 11:26:19 1992
X***************
X*** 48,53 ****
X--- 48,56 ----
X  #endif
X  #else /* not NDIR */
X  # include <sys/dir.h>
X+ # ifdef ISC
X+ #  include <sys/dirent.h>
X+ # endif
X  #endif /* not NDIR */
X  
X  #ifdef FCNTL
X***************
X*** 157,162 ****
X--- 160,166 ----
X  extern	char	spooldir[];
X  extern	char	activefile[];
X  extern	char	distributionsfile[];
X+ extern	char	subscriptionsfile[];
X  extern	char	newsgroupsfile[];
X  extern	char	accessfile[];
X  extern	char	historyfile[];
XOnly in server: cscope.out
Xdiff -rcs server.old/fakesyslog.c server/fakesyslog.c
X*** server.old/fakesyslog.c	Mon May  4 07:03:55 1992
X--- server/fakesyslog.c	Sat Mar  7 11:46:00 1992
X***************
X*** 138,144 ****
X  	(void) strcpy(buf, ctime(&clock)+4);
X  	*(bp = buf + 16) = '\0';
X  
X! 	(void) sprintf(bp, "localhost %s", ident ? ident : "");
X  	bp += strlen(bp);
X  
X  	if (opt&LOG_PID) {
X--- 138,145 ----
X  	(void) strcpy(buf, ctime(&clock)+4);
X  	*(bp = buf + 16) = '\0';
X  
X! /*	(void) sprintf(bp, "localhost %s", ident ? ident : ""); */
X! 	(void) sprintf(bp, "local %s", ident ? ident : "");
X  	bp += strlen(bp);
X  
X  	if (opt&LOG_PID) {
Xdiff -rcs server.old/fakesyslog.h server/fakesyslog.h
X*** server.old/fakesyslog.h	Mon May  4 07:03:55 1992
X--- server/fakesyslog.h	Thu Feb 20 08:27:03 1992
X***************
X*** 62,65 ****
X  #define LOG_NDELAY	0
X  #define LOG_NOWAIT	0
X  
X! #endif FAKESYSLOG
X--- 62,65 ----
X  #define LOG_NDELAY	0
X  #define LOG_NOWAIT	0
X  
X! #endif /* FAKESYSLOG */
Xdiff -rcs server.old/globals.c server/globals.c
X*** server.old/globals.c	Mon May  4 07:03:56 1992
X--- server/globals.c	Sun Mar  8 11:25:47 1992
X***************
X*** 16,21 ****
X--- 16,22 ----
X  char	activefile[] = ACTIVE_FILE;
X  char	accessfile[] = ACCESS_FILE;
X  char	distributionsfile[] = DISTRIBUTIONS_FILE;
X+ char	subscriptionsfile[] = SUBSCRIPTIONS_FILE;
X  char	newsgroupsfile[] = NEWSGROUPS_FILE;
X  char	historyfile[] = HISTORY_FILE;
X  #ifdef ACTIVE_TIMES_FILE
X***************
X*** 54,60 ****
X  #ifdef AUTH
X  int	Needauth;	/* 1 if we need to do authorization */
X  char	User[10];	/* username for authentication */
X! #endif AUTH
X  
X  #ifdef LOG
X  int	arts_acsd;
X--- 55,61 ----
X  #ifdef AUTH
X  int	Needauth;	/* 1 if we need to do authorization */
X  char	User[10];	/* username for authentication */
X! #endif /* AUTH */
X  
X  #ifdef LOG
X  int	arts_acsd;
Xdiff -rcs server.old/group.c server/group.c
X*** server.old/group.c	Mon May  4 07:03:56 1992
X--- server/group.c	Sat Mar  7 11:46:00 1992
X***************
X*** 49,54 ****
X--- 49,55 ----
X  		return;
X  	}
X  
X+ 
X  	reqlist[0] = argv[1];
X  	reqlist[1] = NULL;
X  
X***************
X*** 70,79 ****
X  	close_crnt();
X  	(void) chdir(spooldir);
X  
X- #ifdef LOG
X- 	syslog(LOG_INFO, "%s group %s", hostname, argv[1]);
X- #endif
X- 
X  	while ((cp = index(argv[1], '.')) != (char *) NULL)
X  		*cp = '/';
X  
X--- 71,76 ----
X***************
X*** 96,101 ****
X--- 93,103 ----
X  	art_ptr = 0;
X  
X  	ingroup = 1;
X+ 	
X+ #ifdef LOG	
X+ 	syslog(LOG_INFO, "%s group=%s  high=%d  low=%d  arts=%d",
X+ 		 hostname, argv[1], high_msg, low_msg, num_arts);
X+ #endif
X  
X  	while ((cp = index(argv[1], '/')) != (char *) NULL)
X  		*cp = '.';
Xdiff -rcs server.old/help.c server/help.c
X*** server.old/help.c	Mon May  4 07:03:56 1992
X--- server/help.c	Tue Mar 10 08:55:29 1992
X***************
X*** 21,28 ****
X  	printf("NEXT        POST         QUIT\r\n");
X  	printf("STAT        NEWGROUPS    HELP\r\n");
X  	printf("IHAVE       NEWNEWS      SLAVE\r\n");
X! 	printf("\r\nAdditionally, the following extention is supported:\r\n\r\n");
X  	printf("XHDR        Retrieve a single header line from a range of articles.\r\n");
X  	printf("\r\n");
X  	printf("Bugs to Stan Barber (Internet: nntp@tmc.edu; UUCP: ...!bcm!nntp)\r\n");
X  	printf(".\r\n");
X--- 21,38 ----
X  	printf("NEXT        POST         QUIT\r\n");
X  	printf("STAT        NEWGROUPS    HELP\r\n");
X  	printf("IHAVE       NEWNEWS      SLAVE\r\n");
X! #if defined(XHDR) || defined(XUSER) || defined(XINDEX)
X! 	printf("\r\nAdditionally, the following extentions are supported:\r\n\r\n");
X! #  ifdef XHDR
X  	printf("XHDR        Retrieve a single header line from a range of articles.\r\n");
X+ #  endif
X+ #  ifdef XUSER	
X+ 	printf("XUSER       Log a clients username to nntp logfile.\r\n");
X+ #  endif	
X+ #  ifdef XINDEX
X+ 	printf("XINDEX      Retrieve a tin group index file.\r\n");
X+ #  endif	
X+ #endif	
X  	printf("\r\n");
X  	printf("Bugs to Stan Barber (Internet: nntp@tmc.edu; UUCP: ...!bcm!nntp)\r\n");
X  	printf(".\r\n");
Xdiff -rcs server.old/ihave.c server/ihave.c
X*** server.old/ihave.c	Mon May  4 07:03:56 1992
X--- server/ihave.c	Sat Mar  7 11:46:00 1992
X***************
X*** 8,14 ****
X  int	ih_accepted;
X  int	ih_rejected;
X  int	ih_failed;
X! #endif LOG
X  
X  /*
X   * IHAVE <messageid>
X--- 8,14 ----
X  int	ih_accepted;
X  int	ih_rejected;
X  int	ih_failed;
X! #endif /* LOG */
X  
X  /*
X   * IHAVE <messageid>
X***************
X*** 50,57 ****
X  		ih_rejected++;
X  #ifdef IHAVE_DEBUG
X  		syslog(LOG_DEBUG, "%s ihave %s rejected", hostname, argv[1]);
X! #endif IHAVE_DEBUG
X! #endif LOG
X  		return;
X  	}
X  
X--- 50,57 ----
X  		ih_rejected++;
X  #ifdef IHAVE_DEBUG
X  		syslog(LOG_DEBUG, "%s ihave %s rejected", hostname, argv[1]);
X! #endif /* IHAVE_DEBUG */
X! #endif /* LOG */
X  		return;
X  	}
X  
X***************
X*** 100,106 ****
X  #ifdef IHAVE_DEBUG
X  	syslog(LOG_DEBUG, "%s ihave %s accepted %s",
X  		hostname, argv[1], retcode == 1 ? "succeeded" : "failed");
X! #endif IHAVE_DEBUG
X! #endif LOG
X  
X  }
X--- 100,106 ----
X  #ifdef IHAVE_DEBUG
X  	syslog(LOG_DEBUG, "%s ihave %s accepted %s",
X  		hostname, argv[1], retcode == 1 ? "succeeded" : "failed");
X! #endif /* IHAVE_DEBUG */
X! #endif /* LOG */
X  
X  }
Xdiff -rcs server.old/list.c server/list.c
X*** server.old/list.c	Mon May  4 07:03:56 1992
X--- server/list.c	Sun Mar  8 11:24:24 1992
X***************
X*** 7,14 ****
X  /*
X   * LIST
X   *
X!  * List active newsgroups, newsgroup descriptions, and distributions.
X   *
X   */
X  
X  list(argc, argv)
X--- 7,17 ----
X  /*
X   * LIST
X   *
X!  * List active newsgroups, newsgroup descriptions, distributions
X!  * and subscriptions.
X   *
X+  *
X+  *
X   */
X  
X  list(argc, argv)
X***************
X*** 45,52 ****
X  		filename = newsgroupsfile;
X  		items = "newsgroup descriptions";
X  		format = "Descriptions in form \"group description\".";
X  	} else {
X! 		printf("%d Usage: LIST [ACTIVE|NEWSGROUPS|DISTRIBUTIONS]\r\n",
X  			ERR_CMDSYN);
X  		(void) fflush(stdout);
X  		return;
X--- 48,59 ----
X  		filename = newsgroupsfile;
X  		items = "newsgroup descriptions";
X  		format = "Descriptions in form \"group description\".";
X+ 	} else if (argc == 2 && !strcasecmp(argv[1],"subscriptions")){
X+ 		filename = subscriptionsfile;
X+ 		items = "automatic group subscriptions";
X+ 		format = "Subscriptions in form \"group\".";
X  	} else {
X! 		printf("%d Usage: LIST [ACTIVE|NEWSGROUPS|DISTRIBUTIONS|SUBSCRIPTIONS]\r\n",
X  			ERR_CMDSYN);
X  		(void) fflush(stdout);
X  		return;
XFiles server.old/main.c and server/main.c are identical
Xdiff -rcs server.old/misc.c server/misc.c
X*** server.old/misc.c	Mon May  4 07:03:56 1992
X--- server/misc.c	Sat Mar  7 11:46:00 1992
X***************
X*** 90,98 ****
X  # ifndef DBM
X  #  ifndef USGHIST
X  #   define USGHIST
X! #  endif not USGHIST
X! # endif not DBM
X! #endif not DBM
X  
X  char *
X  gethistent(msg_id, lookup)
X--- 90,98 ----
X  # ifndef DBM
X  #  ifndef USGHIST
X  #   define USGHIST
X! #  endif /* not USGHIST */
X! # endif /* not DBM */
X! #endif /* not DBM */
X  
X  char *
X  gethistent(msg_id, lookup)
X***************
X*** 107,121 ****
X  #ifdef USGHIST
X  	char		*histfile();
X  	register int	len;
X! #else not USGHIST
X  #ifdef DBM
X  	static int	dbopen = 0;
X  	datum		fetch();
X! #else not DBM
X  	static DBM	*db = NULL;	/* History file, dbm version */
X! #endif DBM
X! 	datum		 key, content;
X! #endif USGHIST
X  	static FILE	*hfp = NULL;	/* history file, text version */
X  
X  #ifdef CNEWS
X--- 107,121 ----
X  #ifdef USGHIST
X  	char		*histfile();
X  	register int	len;
X! #else /* not USGHIST */
X  #ifdef DBM
X  	static int	dbopen = 0;
X  	datum		fetch();
X! #else /* not DBM */
X  	static DBM	*db = NULL;	/* History file, dbm version */
X! #endif /* DBM */
X!  	datum		 key, content;
X! #endif /* USGHIST */
X  	static FILE	*hfp = NULL;	/* history file, text version */
X  
X  #ifdef CNEWS
X***************
X*** 140,146 ****
X  	if (hfp == NULL) {
X  #ifdef SYSLOG
X  		syslog(LOG_ERR, "gethistent: histfile: %m");
X! #endif SYSLOG
X  		return (NULL);
X  	}
X  
X--- 140,146 ----
X  	if (hfp == NULL) {
X  #ifdef SYSLOG
X  		syslog(LOG_ERR, "gethistent: histfile: %m");
X! #endif /* SYSLOG */
X  		return (NULL);
X  	}
X  
X***************
X*** 153,159 ****
X  		(void) fclose(hfp);
X  		return (NULL);
X  	}
X! #else not USGHIST
X  #ifdef DBM
X  	if (!dbopen) {
X  		if (dbminit(historyfile) < 0) {
X--- 153,159 ----
X  		(void) fclose(hfp);
X  		return (NULL);
X  	}
X! #else /* not USGHIST */
X  #ifdef DBM
X  	if (!dbopen) {
X  		if (dbminit(historyfile) < 0) {
X***************
X*** 160,166 ****
X  #ifdef SYSLOG
X  			syslog(LOG_ERR, "openartbyid: dbminit %s: %m",
X  				historyfile);
X! #endif SYSLOG
X  			return (NULL);
X  		} else
X  			dbopen = 1;
X--- 160,166 ----
X  #ifdef SYSLOG
X  			syslog(LOG_ERR, "openartbyid: dbminit %s: %m",
X  				historyfile);
X! #endif /* SYSLOG */
X  			return (NULL);
X  		} else
X  			dbopen = 1;
X***************
X*** 172,182 ****
X  #ifdef SYSLOG
X  			syslog(LOG_ERR, "openartbyid: dbm_open %s: %m",
X  				historyfile);
X! #endif SYSLOG
X  			return (NULL);
X  		}
X  	}
X! #endif DBM
X  
X  	key.dptr = msg_id;
X  	key.dsize = strlen(msg_id) + 1;
X--- 172,182 ----
X  #ifdef SYSLOG
X  			syslog(LOG_ERR, "openartbyid: dbm_open %s: %m",
X  				historyfile);
X! #endif /* SYSLOG */
X  			return (NULL);
X  		}
X  	}
X! #endif /* DBM */
X  
X  	key.dptr = msg_id;
X  	key.dsize = strlen(msg_id) + 1;
X***************
X*** 185,191 ****
X  	content = fetch(key);
X  #else	/* ndbm */
X  	content = dbm_fetch(db, key);
X! #endif DBM
X  	if (content.dptr == NULL)
X  		return (NULL);
X  
X--- 185,191 ----
X  	content = fetch(key);
X  #else	/* ndbm */
X  	content = dbm_fetch(db, key);
X! #endif /* DBM */
X  	if (content.dptr == NULL)
X  		return (NULL);
X  
X***************
X*** 202,208 ****
X  #ifdef SYSLOG
X  			syslog(LOG_ERR, "message: fopen %s: %m",
X  				historyfile);
X! #endif SYSLOG
X  			return (NULL);
X  		}
X  	} else {
X--- 202,208 ----
X  #ifdef SYSLOG
X  			syslog(LOG_ERR, "message: fopen %s: %m",
X  				historyfile);
X! #endif /* SYSLOG */
X  			return (NULL);
X  		}
X  	} else {
X***************
X*** 215,226 ****
X  #ifdef SYSLOG
X  		syslog(LOG_ERR, "message: %s: fseek to %ld on %d: %m", 
X  		       historyfile, ltmp, hfp);
X! #endif SYSLOG
X  		return (NULL);
X  	}
X  
X  	(void) fgets(line, sizeof(line), hfp);
X! #endif USGHIST
X  
X  	if ((cp = index(line, '\n')) != NULL)
X  		*cp = '\0';
X--- 215,226 ----
X  #ifdef SYSLOG
X  		syslog(LOG_ERR, "message: %s: fseek to %ld on %d: %m", 
X  		       historyfile, ltmp, hfp);
X! #endif /* SYSLOG */
X  		return (NULL);
X  	}
X  
X  	(void) fgets(line, sizeof(line), hfp);
X! #endif /* USGHIST */
X  
X  	if ((cp = index(line, '\n')) != NULL)
X  		*cp = '\0';
X***************
X*** 232,238 ****
X  	    syslog(LOG_ERR,
X  		"message: malformed line in history file at %ld bytes, id %s",
X  			ltmp, msg_id);
X! #endif SYSLOG
X  	if (cp == NULL) return(NULL); /* this article has expired */
X  	tmp = cp+1;
X  
X--- 232,238 ----
X  	    syslog(LOG_ERR,
X  		"message: malformed line in history file at %ld bytes, id %s",
X  			ltmp, msg_id);
X! #endif /* SYSLOG */
X  	if (cp == NULL) return(NULL); /* this article has expired */
X  	tmp = cp+1;
X  
X***************
X*** 613,619 ****
X  		chr = '0';
X  	return chr;
X  }
X! #endif USGHIST
X  #ifdef USG
X  #ifndef GAZETTE
X  bcopy(s, d, l)
X--- 613,619 ----
X  		chr = '0';
X  	return chr;
X  }
X! #endif /* USGHIST */
X  #ifdef USG
X  #ifndef GAZETTE
X  bcopy(s, d, l)
X***************
X*** 775,781 ****
X  #define blkavail(fs)	((fs).f_tfree)
X  				/* USG doesn't reserve blocks for root */
X  #define filfree(fs)	((fs).f_tinode)	
X! #endif USG
X  
X  #ifdef CMU_MACH
X  /* This code supplied by Tom Lane <tgl@cs.cmu.edu> */
X--- 775,781 ----
X  #define blkavail(fs)	((fs).f_tfree)
X  				/* USG doesn't reserve blocks for root */
X  #define filfree(fs)	((fs).f_tinode)	
X! #endif /* USG */
X  
X  #ifdef CMU_MACH
X  /* This code supplied by Tom Lane <tgl@cs.cmu.edu> */
X***************
X*** 799,805 ****
X  #define bombed(call)	((call) < 0)
X  #define blkfree(fs)	((fs).fsp_free-((fs).fsp_size*(fs).fsp_minfree+99)/100)
X  #define blkavail(fs)	(-1)
X! #endif MACH
X  
X  dfree(spool,free_space)
X  char *spool;
X--- 799,805 ----
X  #define bombed(call)	((call) < 0)
X  #define blkfree(fs)	((fs).fsp_free-((fs).fsp_size*(fs).fsp_minfree+99)/100)
X  #define blkavail(fs)	(-1)
X! #endif /* MACH */
X  
X  dfree(spool,free_space)
X  char *spool;
X***************
X*** 825,831 ****
X      return( DFREE_OK );
X  }
X  
X! #else READ_SUPER
X  /*
X   * This code is used if you've got to directly read the superblock
X   * to determine how much space you've got left.  It's copied from
X--- 825,831 ----
X      return( DFREE_OK );
X  }
X  
X! #else /* READ_SUPER */
X  /*
X   * This code is used if you've got to directly read the superblock
X   * to determine how much space you've got left.  It's copied from
X***************
X*** 919,925 ****
X     return( DFREE_OK );
X  }
X  
X! #endif READ_SUPER
X  
X  #ifdef LOAD
X  /*
X--- 919,925 ----
X     return( DFREE_OK );
X  }
X  
X! #endif /* READ_SUPER */
X  
X  #ifdef LOAD
X  /*
X***************
X*** 987,990 ****
X  # endif
X  }
X  #endif
X! #endif LOAD
X--- 987,990 ----
X  # endif
X  }
X  #endif
X! #endif /* LOAD */
Xdiff -rcs server.old/netaux.c server/netaux.c
X*** server.old/netaux.c	Mon May  4 07:03:56 1992
X--- server/netaux.c	Sat Mar  7 11:46:00 1992
X***************
X*** 12,25 ****
X  #include <netinet/in.h>
X  #ifndef EXCELAN
X  #include <netdb.h>
X! #endif not EXCELAN
X  #include <sys/ioctl.h>
X  #include <signal.h>
X  #ifdef USG
X  #include <time.h>
X! #else not USG
X  #include <sys/time.h>
X! #endif USG
X  
X  #ifdef ALONE
X  
X--- 12,25 ----
X  #include <netinet/in.h>
X  #ifndef EXCELAN
X  #include <netdb.h>
X! #endif /* not EXCELAN */
X  #include <sys/ioctl.h>
X  #include <signal.h>
X  #ifdef USG
X  #include <time.h>
X! #else /* not USG */
X  #include <sys/time.h>
X! #endif /* USG */
X  
X  #ifdef ALONE
X  
X***************
X*** 211,217 ****
X  	if (setitimer(ITIMER_REAL, &new, &old) < 0) {
X  #ifdef SYSLOG
X  		syslog(LOG_ERR, "set_timer: setitimer: %m\n");
X! #endif SYSLOG
X  		exit(1);
X  	}
X  #endif /* not USG */
X--- 211,217 ----
X  	if (setitimer(ITIMER_REAL, &new, &old) < 0) {
X  #ifdef SYSLOG
X  		syslog(LOG_ERR, "set_timer: setitimer: %m\n");
X! #endif /* SYSLOG */
X  		exit(1);
X  	}
X  #endif /* not USG */
XFiles server.old/newgroups.c and server/newgroups.c are identical
Xdiff -rcs server.old/newnews.c server/newnews.c
X*** server.old/newnews.c	Mon May  4 07:03:57 1992
X--- server/newnews.c	Sat Mar  7 11:49:07 1992
X***************
X*** 39,45 ****
X  	FILE		*tmplst;
X  	int		i;
X  	char		*tmpfile;
X! #endif USGHIST
X  
X  	if (argc < 4) {
X  		printf("%d Usage: NEWNEWS newsgroups yymmdd hhmmss [\"GMT\"] [<distributions>].\r\n",
X--- 39,45 ----
X  	FILE		*tmplst;
X  	int		i;
X  	char		*tmpfile;
X! #endif /* USGHIST */
X  
X  	if (argc < 4) {
X  		printf("%d Usage: NEWNEWS newsgroups yymmdd hhmmss [\"GMT\"] [<distributions>].\r\n",
X***************
X*** 131,137 ****
X  
X      for (i = 0; i < 9; i++) {
X  		sprintf(historyfile, "%s.d/%d", HISTORY_FILE, i);
X! #endif USGHIST
X  
X  	fp = fopen(historyfile, "r");
X  	if (fp == NULL) {
X--- 131,137 ----
X  
X      for (i = 0; i < 9; i++) {
X  		sprintf(historyfile, "%s.d/%d", HISTORY_FILE, i);
X! #endif /* USGHIST */
X  
X  	fp = fopen(historyfile, "r");
X  	if (fp == NULL) {
X***************
X*** 142,167 ****
X  		printf("%d Cannot open history file.\r\n", ERR_FAULT);
X  		(void) fflush(stdout);
X  		return;
X! #else USGHIST
X  		continue;
X! #endif USGHIST
X  	}
X  
X  #ifndef USGHIST
X  	printf("%d New news by message id follows\r\n", OK_NEWNEWS);
X! #endif not USGHIST
X  
X  	if (seekuntil(fp, key, line, sizeof (line)) < 0) {
X  #ifndef USGHIST
X  		printf(".\r\n");
X  		(void) fflush(stdout);
X! #endif not USGHIST
X  		(void) fclose(fp);
X  #ifndef USGHIST
X  		return;
X! #else USGHIST
X  		continue;
X! #endif USGHIST
X  	}
X  
X  /*
X--- 142,167 ----
X  		printf("%d Cannot open history file.\r\n", ERR_FAULT);
X  		(void) fflush(stdout);
X  		return;
X! #else /* USGHIST */
X  		continue;
X! #endif /* USGHIST */
X  	}
X  
X  #ifndef USGHIST
X  	printf("%d New news by message id follows\r\n", OK_NEWNEWS);
X! #endif /* not USGHIST */
X  
X  	if (seekuntil(fp, key, line, sizeof (line)) < 0) {
X  #ifndef USGHIST
X  		printf(".\r\n");
X  		(void) fflush(stdout);
X! #endif /* not USGHIST */
X  		(void) fclose(fp);
X  #ifndef USGHIST
X  		return;
X! #else /* USGHIST */
X  		continue;
X! #endif /* USGHIST */
X  	}
X  
X  /*
X***************
X*** 208,216 ****
X  #ifdef USGHIST
X  		fputs(line, tmplst);
X  		fputc('\n', tmplst);
X! #else not USGHIST
X  		putline(line);
X! #endif not USGHIST
X  #ifdef LOG
X  		nn_told++;
X  #endif
X--- 208,216 ----
X  #ifdef USGHIST
X  		fputs(line, tmplst);
X  		fputc('\n', tmplst);
X! #else /* not USGHIST */
X  		putline(line);
X! #endif /* not USGHIST */
X  #ifdef LOG
X  		nn_told++;
X  #endif
X***************
X*** 235,241 ****
X      (void) fflush(stdout);
X      (void) fclose(tmplst);
X      (void) unlink(tmpfile);
X! #endif USGHIST
X  }
X  
X  
X--- 235,241 ----
X      (void) fflush(stdout);
X      (void) fclose(tmplst);
X      (void) unlink(tmpfile);
X! #endif /* USGHIST */
X  }
X  
X  
XFiles server.old/nextlast.c and server/nextlast.c are identical
XFiles server.old/ngmatch.c and server/ngmatch.c are identical
XFiles server.old/parsit.c and server/parsit.c are identical
XFiles server.old/post.c and server/post.c are identical
XFiles server.old/profile.c and server/profile.c are identical
Xdiff -rcs server.old/scandir.c server/scandir.c
X*** server.old/scandir.c	Mon May  4 07:03:57 1992
X--- server/scandir.c	Sat Mar  7 11:46:00 1992
X***************
X*** 4,9 ****
X--- 4,13 ----
X  
X  #include "common.h"
X  
X+ #ifdef ISC
X+ #	include <dirent.h>
X+ #endif
X+ 
X  /*
X   * scan_dir -- scan the current directory for news articles,
X   *	loading the article numbers into art_array.  Return
X***************
X*** 26,32 ****
X--- 30,40 ----
X  scan_dir(low_msg, high_msg)
X  int	low_msg, high_msg;
X  {
X+ #ifdef ISC
X+ 	register struct dirent	*dirent;
X+ #else
X  	register struct direct	*dirent;
X+ #endif
X  	register DIR		*dirp;
X  	int			artnum;
X  
X***************
X*** 34,43 ****
X  
X  	dirp = opendir(".");
X  
X! 	if (dirp == NULL)
X  		return (0);
X  
X  	while ((dirent = readdir(dirp)) != NULL) {
X  		artnum = atoi(dirent->d_name);
X  #ifdef DYNAMIC_ART_ARRAY
X  		if (artnum == 0 || artnum < low_msg || artnum > high_msg)
X--- 42,73 ----
X  
X  	dirp = opendir(".");
X  
X! 	if (dirp == NULL) {
X! #ifdef LOG
X! 		syslog(LOG_ERR, "scan_dir(): opendir() failed. Returning num_arts=0");
X! #endif
X  		return (0);
X+ 	}
X  
X  	while ((dirent = readdir(dirp)) != NULL) {
X+ 
X+ #ifdef LOG
X+ /*
X+ {
X+ 		char pwd[256];
X+ 	
X+ 		getcwd (pwd, 255);
X+ #ifdef ISC
X+ 		syslog(LOG_INFO, "%s: d->d_name=%s  d->d_ino=%d  d->d_reclen=%d",
X+ 			pwd, dirent->d_name, dirent->d_ino, dirent->d_reclen);
X+ #else		
X+ 		syslog(LOG_INFO, "%s: d->d_name=%s  d->d_ino=%d",
X+ 			pwd, dirent->d_name, dirent->d_ino);
X+ #endif
X+ }
X+ */			
X+ #endif
X+ 	
X  		artnum = atoi(dirent->d_name);
X  #ifdef DYNAMIC_ART_ARRAY
X  		if (artnum == 0 || artnum < low_msg || artnum > high_msg)
X***************
X*** 70,75 ****
X--- 100,110 ----
X  		}
X  		art_array[num_arts] = artnum;
X   		++num_arts;
X+ 
X+ #ifdef LOG
X+ 		syslog(LOG_INFO, "scan_dir(): artnum=%d  num_arts=%d", artnum, num_arts);
X+ #endif
X+ 
X  #else
X  		if (artnum != 0 && artnum >= low_msg && artnum <= high_msg)
X  			art_array[num_arts++] = artnum;
Xdiff -rcs server.old/serve.c server/serve.c
X*** server.old/serve.c	Mon May  4 07:03:57 1992
X--- server/serve.c	Tue Mar 10 09:32:32 1992
X***************
X*** 17,23 ****
X  #ifdef LOG
X  # ifndef USG
X  #  include <sys/resource.h>
X! # endif not USG
X  #endif
X  
X  #ifdef TIMERS
X--- 17,23 ----
X  #ifdef LOG
X  # ifndef USG
X  #  include <sys/resource.h>
X! # endif /* not USG */
X  #endif
X  
X  #ifdef TIMERS
X***************
X*** 27,38 ****
X  extern	int	ahbs(), group(), help(), ihave();
X  extern	int	list(), newgroups(), newnews(), nextlast(), post();
X  extern	int	slave(), stat(), xhdr();
X  
X  extern int errno;
X  
X  #ifdef AUTH
X  extern	int	doauth();
X! #endif AUTH
X  
X  static struct cmdent {
X  	char	*cmd_name;
X--- 27,44 ----
X  extern	int	ahbs(), group(), help(), ihave();
X  extern	int	list(), newgroups(), newnews(), nextlast(), post();
X  extern	int	slave(), stat(), xhdr();
X+ #ifdef XUSER
X+ extern	int	xuser();
X+ #endif
X+ #ifdef XINDEX
X+ extern	int	xindex();
X+ #endif
X  
X  extern int errno;
X  
X  #ifdef AUTH
X  extern	int	doauth();
X! #endif /* AUTH */
X  
X  static struct cmdent {
X  	char	*cmd_name;
X***************
X*** 43,49 ****
X  	"authcap",	0,	doauth,
X  	"authinfo",	0,	doauth,
X  	"authsys",	0,	doauth,
X! #endif AUTH
X  	"article",	0,	ahbs,
X  	"body",		0,	ahbs,
X  	"group",	0,	group,
X--- 49,55 ----
X  	"authcap",	0,	doauth,
X  	"authinfo",	0,	doauth,
X  	"authsys",	0,	doauth,
X! #endif /* AUTH */
X  	"article",	0,	ahbs,
X  	"body",		0,	ahbs,
X  	"group",	0,	group,
X***************
X*** 60,66 ****
X  	"stat",		0,	ahbs,
X  #ifdef XHDR
X  	"xhdr",		0,	xhdr,
X! #endif XHDR
X  };
X  #define NUMCMDS (sizeof(cmdtbl) / sizeof(struct cmdent))
X  
X--- 66,78 ----
X  	"stat",		0,	ahbs,
X  #ifdef XHDR
X  	"xhdr",		0,	xhdr,
X! #endif /* XHDR */
X! #ifdef XUSER
X! 	"xuser",	0,	xuser,
X! #endif /* XUSER */
X! #ifdef XINDEX
X! 	"xindex",	0,	xindex,
X! #endif /* XINDEX */
X  };
X  #define NUMCMDS (sizeof(cmdtbl) / sizeof(struct cmdent))
X  
X***************
X*** 98,104 ****
X  #ifdef AUTH
X  extern int	Needauth;
X  extern char	User[];
X! #endif AUTH
X  
X  /*
X   * serve -- given a connection on stdin/stdout, serve
X--- 110,116 ----
X  #ifdef AUTH
X  extern int	Needauth;
X  extern char	User[];
X! #endif /* AUTH */
X  
X  /*
X   * serve -- given a connection on stdin/stdout, serve
X***************
X*** 152,158 ****
X  #ifdef ALONE
X  #ifndef USG
X  	(void) signal(SIGCHLD, SIG_IGN);
X! #endif not USG
X  #endif
X  
X  	/* Ignore SIGPIPE, since we'll see closed connections with read */
X--- 164,170 ----
X  #ifdef ALONE
X  #ifndef USG
X  	(void) signal(SIGCHLD, SIG_IGN);
X! #endif /* not USG */
X  #endif
X  
X  	/* Ignore SIGPIPE, since we'll see closed connections with read */
X***************
X*** 163,169 ****
X  #ifdef AUTH
X  	Needauth = 1;
X  	strcpy(User,"");
X! #endif AUTH
X  	host_access(&canread, &canpost, &canxfer, gdbuf);
X  
X  	if (gethostname(host, sizeof(host)) < 0)
X--- 175,181 ----
X  #ifdef AUTH
X  	Needauth = 1;
X  	strcpy(User,"");
X! #endif /* AUTH */
X  	host_access(&canread, &canpost, &canxfer, gdbuf);
X  
X  	if (gethostname(host, sizeof(host)) < 0)
X***************
X*** 302,308 ****
X  				(void) fflush(stdout);
X  				continue;
X  				}
X! #endif AUTH
X  			(*cmdtbl[i].cmd_fctn)(argnum, argp);
X  		} else {
X  #ifdef SYSLOG
X--- 314,320 ----
X  				(void) fflush(stdout);
X  				continue;
X  				}
X! #endif /* AUTH */
X  			(*cmdtbl[i].cmd_fctn)(argnum, argp);
X  		} else {
X  #ifdef SYSLOG
X***************
X*** 490,493 ****
X  		user, sys, Tfinish - Tstart);
X  	syslog(LOG_INFO, "%s times %s", hostname, buf);
X  }
X! #endif LOG
X--- 502,505 ----
X  		user, sys, Tfinish - Tstart);
X  	syslog(LOG_INFO, "%s times %s", hostname, buf);
X  }
X! #endif /* LOG */
XFiles server.old/slave.c and server/slave.c are identical
Xdiff -rcs server.old/spawn.c server/spawn.c
X*** server.old/spawn.c	Mon May  4 07:03:58 1992
X--- server/spawn.c	Sat Mar  7 11:46:00 1992
X***************
X*** 65,73 ****
X  #endif
X  #ifdef USG
X  	int		status;
X! #else not USG
X  	union wait	status;
X! #endif not USG
X  	register FILE	*fp;
X  
X  #ifdef CNEWS
X--- 65,73 ----
X  #endif
X  #ifdef USG
X  	int		status;
X! #else /* not USG */
X  	union wait	status;
X! #endif /* not USG */
X  	register FILE	*fp;
X  
X  #ifdef CNEWS
X***************
X*** 91,97 ****
X  	*/
X  	if (cont_code == CONT_POST)
X  		fprintf(fp, "Nntp-Posting-Host: %s\n", hostname);
X! #endif AUTH
X  
X  	printf("%d Ok\r\n", cont_code);
X  	(void) fflush(stdout);
X--- 91,97 ----
X  	*/
X  	if (cont_code == CONT_POST)
X  		fprintf(fp, "Nntp-Posting-Host: %s\n", hostname);
X! #endif /* AUTH */
X  
X  	printf("%d Ok\r\n", cont_code);
X  	(void) fflush(stdout);
X***************
X*** 332,338 ****
X  
X  #ifdef LOG
X  	syslog(LOG_ERR, "%s transfer_timeout", hostname);
X! #endif LOG
X  
X  	(void) unlink(tempfile);
X  
X--- 332,338 ----
X  
X  #ifdef LOG
X  	syslog(LOG_ERR, "%s transfer_timeout", hostname);
X! #endif /* LOG */
X  
X  	(void) unlink(tempfile);
X  
X***************
X*** 339,343 ****
X  	exit(1);
X  }
X  
X! #endif XFER_TIMEOUT
X  
X--- 339,343 ----
X  	exit(1);
X  }
X  
X! #endif /* XFER_TIMEOUT */
X  
XFiles server.old/strcasecmp.c and server/strcasecmp.c are identical
Xdiff -rcs server.old/subnet.c server/subnet.c
X*** server.old/subnet.c	Mon May  4 07:03:58 1992
X--- server/subnet.c	Sat Mar  7 11:46:00 1992
X***************
X*** 1,5 ****
X  #ifndef lint
X! static	char	*sccsid = "@(#)$Header: subnet.c,v 1.8 90/12/12 02:21:38 sob Exp $";
X  #endif
X  
X  #include "../common/conf.h"
X--- 1,5 ----
X  #ifndef lint
X! static	char	*sccsid = "@(#)$Header: subnet.c,v 1.9 91/03/19 03:02:30 sob Exp $";
X  #endif
X  
X  #include "../common/conf.h"
X***************
X*** 7,19 ****
X  #ifdef SUBNET
X  
X  #include <sys/types.h>
X  #include <sys/socket.h>
X  #include <netinet/in.h>
X  #ifndef NETMASK
X  #include <net/if.h>
X  #endif
X  #include <sys/ioctl.h>
X! 
X  /*
X   * The following routines provide a general interface for
X   * subnet support.  Like the library function "inet_netof",
X--- 7,26 ----
X  #ifdef SUBNET
X  
X  #include <sys/types.h>
X+ #ifdef LAI_TCP
X+ #include <sys/bsdtypes.h>
X+ #include <sys/stream.h>
X+ #endif
X  #include <sys/socket.h>
X  #include <netinet/in.h>
X  #ifndef NETMASK
X  #include <net/if.h>
X  #endif
X+ #ifdef LAI_TCP
X+ #include <sys/sioctl.h>
X+ #else
X  #include <sys/ioctl.h>
X! #endif
X  /*
X   * The following routines provide a general interface for
X   * subnet support.  Like the library function "inet_netof",
Xdiff -rcs server.old/time.c server/time.c
X*** server.old/time.c	Mon May  4 07:03:58 1992
X--- server/time.c	Sat Mar  7 11:46:00 1992
X***************
X*** 10,18 ****
X  #include "common.h"
X  #ifdef USG
X  #include <time.h>
X! #else not USG
X  #include <sys/time.h>
X! #endif not USG
X  
X  /*
X   * dtol -- convert date to long integer.  This is not implicitly
X--- 10,18 ----
X  #include "common.h"
X  #ifdef USG
X  #include <time.h>
X! #else /* not USG */
X  #include <sys/time.h>
X! #endif /* not USG */
X  
X  /*
X   * dtol -- convert date to long integer.  This is not implicitly
XFiles server.old/time.h and server/time.h are identical
Xdiff -rcs server.old/timer.c server/timer.c
X*** server.old/timer.c	Mon May  4 07:03:58 1992
X--- server/timer.c	Sat Mar  7 11:46:00 1992
X***************
X*** 6,17 ****
X  #ifdef TIMERS
X  #ifndef lint
X  static char rcsid[] =
X!     "@(#) $Header: timer.c,v 1.2 90/12/27 22:16:27 sob Exp $ (NNTP with TIMERS)";
X  #endif
X  #else
X  #ifndef lint
X  static char rcsid[] =
X!     "@(#) $Header: timer.c,v 1.2 90/12/27 22:16:27 sob Exp $ (NNTP without TIMERS)";
X  #endif
X  #endif
X  
X--- 6,17 ----
X  #ifdef TIMERS
X  #ifndef lint
X  static char rcsid[] =
X!     "@(#) $Header: timer.c,v 1.3 91/03/19 03:02:41 sob Exp $ (NNTP with TIMERS)";
X  #endif
X  #else
X  #ifndef lint
X  static char rcsid[] =
X!     "@(#) $Header: timer.c,v 1.3 91/03/19 03:02:41 sob Exp $ (NNTP without TIMERS)";
X  #endif
X  #endif
X  
X***************
X*** 18,24 ****
X  #ifdef TIMERS
X  #include <sys/time.h>
X  #include "timer.h"
X! #ifndef USG
X  #ifndef FD_SETSIZE
X  /* Forward compatability */
X  #define FD_SET(n, p)    ((p)->fds_bits[0] |= (1<<(n)))
X--- 18,29 ----
X  #ifdef TIMERS
X  #include <sys/time.h>
X  #include "timer.h"
X! #ifdef USG
X! #ifdef LAI_TCP
X! #include <sys/bsdtypes.h>
X! #define BSDSELECT
X! #endif
X! #else
X  #ifndef FD_SETSIZE
X  /* Forward compatability */
X  #define FD_SET(n, p)    ((p)->fds_bits[0] |= (1<<(n)))
X***************
X*** 25,30 ****
X--- 30,36 ----
X  #define FD_CLR(n, p)    ((p)->fds_bits[0] &= ~(1<<(n)))
X  #define FD_ISSET(n, p)  ((p)->fds_bits[0] & (1<<(n)))
X  #define FD_ZERO(p)      ((p)->fds_bits[0] = 0)
X+ #define BSDSELECT
X  #endif
X  #endif
X  /* non-portable */
X***************
X*** 69,75 ****
X  	register int i, n;
X  	register struct timer *tp;
X  	register long secs;
X! #ifdef USG
X  	long timeout;
X  	long readfds;
X  #else
X--- 75,81 ----
X  	register int i, n;
X  	register struct timer *tp;
X  	register long secs;
X! #ifndef BSDSELECT
X  	long timeout;
X  	long readfds;
X  #else
X***************
X*** 83,89 ****
X  		return(1);
X  
X  	/* Length of next timeout is minimum of all "timers" */
X! #ifdef USG
X  	timeout = -1;
X  	for (i = ntimer, tp = timers; i > 0; --i, ++tp)
X  		if (tp->left >= 0 &&
X--- 89,95 ----
X  		return(1);
X  
X  	/* Length of next timeout is minimum of all "timers" */
X! #ifndef BSDSELECT
X  	timeout = -1;
X  	for (i = ntimer, tp = timers; i > 0; --i, ++tp)
X  		if (tp->left >= 0 &&
X***************
X*** 114,122 ****
X  	/* Do select */
X  	FD_ZERO(&readfds);
X  	FD_SET(fileno(stdin), &readfds);
X! #endif /* !USG */
X  	errno = 0;
X! #ifdef EXCELAN
X  	n = select(fileno(stdin) + 1, &readfds, (long*)0, timeout);
X  #else
X  	n = select(fileno(stdin) + 1,
X--- 120,128 ----
X  	/* Do select */
X  	FD_ZERO(&readfds);
X  	FD_SET(fileno(stdin), &readfds);
X! #endif /* BSDSELECT */
X  	errno = 0;
X! #if defined(EXCELAN) || defined(ULTRIX)
X  	n = select(fileno(stdin) + 1, &readfds, (long*)0, timeout);
X  #else
X  	n = select(fileno(stdin) + 1,
XFiles server.old/timer.h and server/timer.h are identical
Xdiff -rcs server.old/xhdr.c server/xhdr.c
X*** server.old/xhdr.c	Mon May  4 07:03:58 1992
X--- server/xhdr.c	Sat Mar  7 11:46:00 1992
X***************
X*** 158,164 ****
X  	}
X  }
X  
X! #else not XHDR
X  
X  /* Kludge to get around Greenhills C compiler */
X  
X--- 158,164 ----
X  	}
X  }
X  
X! #else /* not XHDR */
X  
X  /* Kludge to get around Greenhills C compiler */
X  
X***************
X*** 166,169 ****
X  {
X  }
X  
X! #endif not XHDR
X--- 166,169 ----
X  {
X  }
X  
X! #endif /* not XHDR */
XOnly in server: xindex.c
XOnly in server: xuser.c
END_OF_FILE
  if test 34102 -ne `wc -c <'server.patch'`; then
    echo shar: \"'server.patch'\" unpacked with wrong size!
  fi
  # end of 'server.patch'
fi
echo shar: End of archive 3 \(of 15\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
