Newsgroups: comp.sources.misc
From: iain%anl433.uucp@Germany.EU.net (Iain Lea)
Subject:  v31i085:  tin - threaded full screen newsreader v1.1, Patch05f/7
Message-ID: <1992Aug16.012743.12875@sparky.imd.sterling.com>
X-Md4-Signature: 8abe47c4b713f9c28961df79a6347391
Date: Sun, 16 Aug 1992 01:27:43 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: iain%anl433.uucp@Germany.EU.net (Iain Lea)
Posting-number: Volume 31, Issue 85
Archive-name: tin/patch05f
Environment: BSD, SCO, ISC, SUNOS, SYSVR3, SYSVR4, ULTRIX, XENIX
Patch-To: tin: Volume 31, Issue 1-15

#!/bin/sh
# this is patch-1.15.shar.06 (part 6 of tin-1.15)
# do not concatenate these parts, unpack them in order with /bin/sh
# file tin-1.15.patch continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 6; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping tin-1.15.patch'
else
echo 'x - continuing file tin-1.15.patch'
sed 's/^X//' << 'SHAR_EOF' >> 'tin-1.15.patch' &&
*** 560,576 ****
X  				break;
X  
X  			case 15:
! 				var_orig = sort_art_type;
X  				show_menu_help (txt_help_sort_type);
X  				do {
X  					MoveCursor (INDEX_TOP+10, COL1 + (int) strlen (txt_opt_sort_type));
X  					if ((ch	= ReadCh()) == ' ') {
! 						if (sort_art_type + 1 > SORT_BY_DATE_ASCEND) {
! 							sort_art_type = SORT_BY_NOTHING;
X  						} else {
! 							sort_art_type++;
X  						}
! 						switch (sort_art_type) {
X  							case SORT_BY_NOTHING:
X  								str = txt_sort_by_nothing;
X  								break;
--- 639,655 ----
X  				break;
X  
X  			case 15:
! 				var_orig = default_sort_art_type;
X  				show_menu_help (txt_help_sort_type);
X  				do {
X  					MoveCursor (INDEX_TOP+10, COL1 + (int) strlen (txt_opt_sort_type));
X  					if ((ch	= ReadCh()) == ' ') {
! 						if (default_sort_art_type + 1 > SORT_BY_DATE_ASCEND) {
! 							default_sort_art_type = SORT_BY_NOTHING;
X  						} else {
! 							default_sort_art_type++;
X  						}
! 						switch (default_sort_art_type) {
X  							case SORT_BY_NOTHING:
X  								str = txt_sort_by_nothing;
X  								break;
***************
*** 600,607 ****
X  				} while (ch != CR && ch != ESC);
X  
X  				if (ch == ESC) {	/* restore original value */
! 					sort_art_type = var_orig;
! 					switch (sort_art_type) {
X  						case SORT_BY_NOTHING:
X  							str = txt_sort_by_nothing;
X  							break;
--- 679,686 ----
X  				} while (ch != CR && ch != ESC);
X  
X  				if (ch == ESC) {	/* restore original value */
! 					default_sort_art_type = var_orig;
! 					switch (default_sort_art_type) {
X  						case SORT_BY_NOTHING:
X  							str = txt_sort_by_nothing;
X  							break;
***************
*** 662,671 ****
X  	center_line (0, TRUE, txt_options_menu);
X  	
X  	MoveCursor (INDEX_TOP, 0);
! 	printf ("%s%s\r\n\r\n", txt_opt_autosave, (save_archive_name ? "ON " : "OFF"));
X  	printf ("%s%s\r\n\r\n", txt_opt_confirm_action, (confirm_action ? "ON " : "OFF"));
X  	printf ("%s%s\r\n\r\n", txt_opt_pos_first_unread, (pos_first_unread ? "ON " : "OFF"));
! 	printf ("%s%s", txt_opt_thread_arts, (thread_arts ? "ON " : "OFF"));
X  
X  	MoveCursor(INDEX_TOP, COL2);
X  	printf ("%s%s", txt_opt_start_editor_offset, (start_editor_offset ? "ON " : "OFF"));
--- 741,750 ----
X  	center_line (0, TRUE, txt_options_menu);
X  	
X  	MoveCursor (INDEX_TOP, 0);
! 	printf ("%s%s\r\n\r\n", txt_opt_autosave, (default_auto_save ? "ON " : "OFF"));
X  	printf ("%s%s\r\n\r\n", txt_opt_confirm_action, (confirm_action ? "ON " : "OFF"));
X  	printf ("%s%s\r\n\r\n", txt_opt_pos_first_unread, (pos_first_unread ? "ON " : "OFF"));
! 	printf ("%s%s", txt_opt_thread_arts, (default_thread_arts ? "ON " : "OFF"));
X  
X  	MoveCursor(INDEX_TOP, COL2);
X  	printf ("%s%s", txt_opt_start_editor_offset, (start_editor_offset ? "ON " : "OFF"));
***************
*** 674,680 ****
X  	MoveCursor(INDEX_TOP+4, COL2);
X  	printf ("%s%s", txt_opt_page_scroll, (full_page_scroll ? "ON " : "OFF"));
X  	MoveCursor(INDEX_TOP+6, COL2);
! 	printf ("%s%s", txt_opt_show_only_unread, (show_only_unread ? "ON " : "OFF"));
X  
X  	MoveCursor(INDEX_TOP, COL3);
X  	printf ("%s%s", txt_opt_mark_saved_read, (mark_saved_read ? "ON " : "OFF"));
--- 753,759 ----
X  	MoveCursor(INDEX_TOP+4, COL2);
X  	printf ("%s%s", txt_opt_page_scroll, (full_page_scroll ? "ON " : "OFF"));
X  	MoveCursor(INDEX_TOP+6, COL2);
! 	printf ("%s%s", txt_opt_show_only_unread, (default_show_only_unread ? "ON " : "OFF"));
X  
X  	MoveCursor(INDEX_TOP, COL3);
X  	printf ("%s%s", txt_opt_mark_saved_read, (mark_saved_read ? "ON " : "OFF"));
***************
*** 686,692 ****
X  	printf ("%s%s", txt_opt_show_description, (show_description ? "ON " : "OFF"));
X  
X  	MoveCursor(INDEX_TOP+8, COL1);
! 	switch (show_author) {
X  		case SHOW_FROM_NONE:
X  			str = txt_show_from_none;
X  			break;
--- 765,771 ----
X  	printf ("%s%s", txt_opt_show_description, (show_description ? "ON " : "OFF"));
X  
X  	MoveCursor(INDEX_TOP+8, COL1);
! 	switch (default_show_author) {
X  		case SHOW_FROM_NONE:
X  			str = txt_show_from_none;
X  			break;
***************
*** 702,708 ****
X  	}
X  	printf ("%s%s", txt_opt_show_author, str);
X  	MoveCursor(INDEX_TOP+8, COL2);
! 	switch (post_proc_type) {
X  		case POST_PROC_NONE:
X  			str = txt_post_process_none;
X  			break;
--- 781,787 ----
X  	}
X  	printf ("%s%s", txt_opt_show_author, str);
X  	MoveCursor(INDEX_TOP+8, COL2);
! 	switch (default_post_proc_type) {
X  		case POST_PROC_NONE:
X  			str = txt_post_process_none;
X  			break;
***************
*** 723,729 ****
X  	printf ("%s%s\r\n\r\n", txt_opt_process_type, str);
X  	
X  	MoveCursor(INDEX_TOP+10, COL1);
! 	switch (sort_art_type) {
X  		case SORT_BY_NOTHING:
X  			str = txt_sort_by_nothing;
X  			break;
--- 802,808 ----
X  	printf ("%s%s\r\n\r\n", txt_opt_process_type, str);
X  	
X  	MoveCursor(INDEX_TOP+10, COL1);
! 	switch (default_sort_art_type) {
X  		case SORT_BY_NOTHING:
X  			str = txt_sort_by_nothing;
X  			break;
***************
*** 841,843 ****
--- 920,955 ----
X  	return FALSE;
X  }
X  
+ /*
+  *  convert underlines to spaces in a string
+  */
+ 
+ void quote_dash_to_space (s)
+ 	char *s;
+ {
+ 	int i;
+ 
+ 	for (i=0 ; i < strlen (s) ; i++) {
+ 		if (s[i] == '_') {
+ 			s[i] = ' ';
+ 		}
+ 	}
+ }
+ 
+ /*
+  *  convert spaces to underlines in a string
+  */
+ 
+ char *quote_space_to_dash (s)
+ 	char *s;
+ {
+ 	int i;
+ 	static char ds[PATH_LEN];
+ 
+ 	for (i=0 ; i < strlen (s) ; i++) {
+ 		(s[i] == ' ') ? (ds[i] = '_') : (ds[i] = s[i]);
+ 	}	
+ 	ds[i] = '\0';
+ 
+ 	return ds;
+ }
diff -rcs ../1.14/save.c ./save.c
*** ../1.14/save.c	Tue Aug 11 21:23:20 1992
--- ./save.c	Thu Jul 23 08:26:19 1992
***************
*** 3,9 ****
X   *  Module    : save.c
X   *  Author    : I.Lea & R.Skrenta
X   *  Created   : 01-04-91
!  *  Updated   : 09-05-92
X   *  Notes     :
X   *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X   *              You may  freely  copy or  redistribute  this software,
--- 3,9 ----
X   *  Module    : save.c
X   *  Author    : I.Lea & R.Skrenta
X   *  Created   : 01-04-91
!  *  Updated   : 23-07-92
X   *  Notes     :
X   *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X   *              You may  freely  copy or  redistribute  this software,
***************
*** 22,33 ****
X  extern int cur_groupnum;
X  
X  int create_subdir = TRUE;
- int save_num=0;
- int max_save;
X  
- struct save_t *save;
X  
- 
X  /*
X   * types of archive programs
X   * 0=archiver, 1=extension, 2=extract option, 3=list option
--- 22,29 ----
***************
*** 79,85 ****
X  	char group_path[LEN];
X  	char savefile[LEN];
X  	extern FILE *note_fp;
! 	FILE *fp;
X  	FILE *fp_log = (FILE *) 0;
X  	int i, j, print_group;
X  	int check_arts = 0;
--- 75,81 ----
X  	char group_path[LEN];
X  	char savefile[LEN];
X  	extern FILE *note_fp;
! 	FILE *fp = (FILE *) 0; 
X  	FILE *fp_log = (FILE *) 0;
X  	int i, j, print_group;
X  	int check_arts = 0;
***************
*** 155,166 ****
X  								create_path (buf);
X  							}
X  						}
- 						sprintf (buf, "[%5ld]  %s\n", arts[j].artnum, arts[j].subject);
- 						fprintf (fp_log, "%s", buf);
- 						if (verbose) {
- 							wait_message (buf);
- 						}
- 						saved_arts++;
X  
X  						if (check_start_save == MAIL_ANY_NEWS) {
X  							sprintf (savefile, "/tmp/tin.%d", process_id);
--- 151,156 ----
***************
*** 169,174 ****
--- 159,172 ----
X  									 group_path, arts[j].artnum);
X  						}
X  
+ 						if (check_start_save == MAIL_ANY_NEWS) {
+ 							fprintf (fp, "To: %s\n", mail_news_user);
+ 						}
+ 
+ 						note_page = art_open (arts[j].artnum, group_path);	
+ 						if (note_page == ART_UNAVAILABLE) {
+ 							continue;
+ 						}
X  						if ((fp = fopen (savefile, "w")) == NULL) {
X  							fprintf (fp_log, txt_cannot_open, savefile);
X  							if (verbose) {
***************
*** 176,191 ****
X  							}
X  							continue;
X  						}
! 				
! 						if (check_start_save == MAIL_ANY_NEWS) {
! 							fprintf (fp, "To: %s\n", mail_news_user);
X  						}
- 
- 						note_page = art_open (arts[j].artnum, group_path);	
X  						fseek (note_fp, 0L, 0);
X  						copy_fp (note_fp, fp, "");
X  						art_close ();
X  						fclose (fp);
X  
X  						if (check_start_save == MAIL_ANY_NEWS) {
X  							sprintf (buf, "%s \"%s\" < %s", mailer,
--- 174,189 ----
X  							}
X  							continue;
X  						}
! 						sprintf (buf, "[%5ld]  %s\n", arts[j].artnum, arts[j].subject);
! 						fprintf (fp_log, "%s", buf);
! 						if (verbose) {
! 							wait_message (buf);
X  						}
X  						fseek (note_fp, 0L, 0);
X  						copy_fp (note_fp, fp, "");
X  						art_close ();
X  						fclose (fp);
+ 						saved_arts++;
X  
X  						if (check_start_save == MAIL_ANY_NEWS) {
X  							sprintf (buf, "%s \"%s\" < %s", mailer,
***************
*** 285,291 ****
X  		my_strncpy (file, filename, sizeof (file));
X  		is_mailbox = mailbox;
X  		i = index;
! 	} else if (save_archive_name && arts[respnum].archive) {
X  		my_strncpy (file, arts[respnum].archive, sizeof (file));
X  	}
X  
--- 283,289 ----
X  		my_strncpy (file, filename, sizeof (file));
X  		is_mailbox = mailbox;
X  		i = index;
! 	} else if (default_auto_save && arts[respnum].archive) {
X  		my_strncpy (file, arts[respnum].archive, sizeof (file));
X  	}
X  
***************
*** 342,348 ****
X  	int count = 0;
X  	int i, ret_code = FALSE;
X  
! 	for (i=0 ; i < save_num ; i++) {
X  		sprintf (msg, "%s%d", txt_saving, ++count);
X  		wait_message (msg);
X  
--- 340,346 ----
X  	int count = 0;
X  	int i, ret_code = FALSE;
X  
! 	for (i=0 ; i < num_save ; i++) {
X  		sprintf (msg, "%s%d", txt_saving, ++count);
X  		wait_message (msg);
X  
***************
*** 353,360 ****
X  		}
X  
X  		note_page = art_open (arts[save[i].index].artnum, group_path);
! 		ret_code = save_art_to_file (save[i].index, i, is_mailbox, file);
! 		art_close ();			
X  	}
X  	
X  	first_savefile = get_first_savefile ();
--- 351,360 ----
X  		}
X  
X  		note_page = art_open (arts[save[i].index].artnum, group_path);
! 		if (note_page != ART_UNAVAILABLE) {
! 			ret_code = save_art_to_file (save[i].index, i, is_mailbox, file);
! 			art_close ();			
! 		}
X  	}
X  	
X  	first_savefile = get_first_savefile ();
***************
*** 365,371 ****
X  		if (is_mailbox) {
X  			sprintf (save_thread_info, txt_saved_to_mailbox, first_savefile);
X  		} else {
! 			if (save_num == 1) {
X  				sprintf (save_thread_info, txt_art_saved_to, first_savefile);
X  			} else {
X  				sprintf (save_thread_info, txt_thread_saved_to_many,
--- 365,371 ----
X  		if (is_mailbox) {
X  			sprintf (save_thread_info, txt_saved_to_mailbox, first_savefile);
X  		} else {
! 			if (num_save == 1) {
X  				sprintf (save_thread_info, txt_art_saved_to, first_savefile);
X  			} else {
X  				sprintf (save_thread_info, txt_thread_saved_to_many,
***************
*** 395,401 ****
X  	char buf[PATH_LEN];
X  	int i, ret_code = FALSE; 	
X  	
! 	for (i=0 ; i < save_num ; i++) {
X  		sprintf(msg, "%s%d", txt_saving, i+1);
X  		wait_message (msg);
X  
--- 395,401 ----
X  	char buf[PATH_LEN];
X  	int i, ret_code = FALSE; 	
X  	
! 	for (i=0 ; i < num_save ; i++) {
X  		sprintf(msg, "%s%d", txt_saving, i+1);
X  		wait_message (msg);
X  
***************
*** 406,416 ****
X  		}
X  
X  		note_page = art_open (arts[save[i].index].artnum, group_path);
! 		ret_code = save_art_to_file (save[i].index, i, is_mailbox, buf);
! 		art_close ();			
X  	}
X  
! 	if (! save_num) {	
X  		info_message (txt_no_match);
X  	} else {
X  		if (is_mailbox) {
--- 406,418 ----
X  		}
X  
X  		note_page = art_open (arts[save[i].index].artnum, group_path);
! 		if (note_page != ART_UNAVAILABLE) {
! 			ret_code = save_art_to_file (save[i].index, i, is_mailbox, buf);
! 			art_close ();			
! 		}
X  	}
X  
! 	if (! num_save) {	
X  		info_message (txt_no_match);
X  	} else {
X  		if (is_mailbox) {
***************
*** 602,629 ****
X  	dir[0] = '\0';
X  	file[0] = '\0';
X  
! 	if (save_num == max_save-1) {
X  		expand_save ();
X  	}
X  
! 	save[save_num].index   = index;
! 	save[save_num].saved   = FALSE;
! 	save[save_num].is_mailbox = is_mailbox;
! 	save[save_num].dir     = (char *) 0;
! 	save[save_num].file    = (char *) 0;
! 	save[save_num].archive = (char *) 0;
! 	save[save_num].part    = (char *) 0;
! 	save[save_num].patch   = (char *) 0;
X  
! 	save[save_num].subject = str_dup (article->subject);
X  	if (article->archive) {
! 		save[save_num].archive = str_dup (article->archive);
X  	}
X  	if (article->part) {
! 		save[save_num].part = str_dup (article->part);
X  	}
X  	if (article->patch) {
! 		save[save_num].patch = str_dup (article->patch);
X  	}
X  
X  	if (is_mailbox) {
--- 604,631 ----
X  	dir[0] = '\0';
X  	file[0] = '\0';
X  
! 	if (num_save == max_save-1) {
X  		expand_save ();
X  	}
X  
! 	save[num_save].index   = index;
! 	save[num_save].saved   = FALSE;
! 	save[num_save].is_mailbox = is_mailbox;
! 	save[num_save].dir     = (char *) 0;
! 	save[num_save].file    = (char *) 0;
! 	save[num_save].archive = (char *) 0;
! 	save[num_save].part    = (char *) 0;
! 	save[num_save].patch   = (char *) 0;
X  
! 	save[num_save].subject = str_dup (article->subject);
X  	if (article->archive) {
! 		save[num_save].archive = str_dup (article->archive);
X  	}
X  	if (article->part) {
! 		save[num_save].part = str_dup (article->part);
X  	}
X  	if (article->patch) {
! 		save[num_save].patch = str_dup (article->patch);
X  	}
X  
X  	if (is_mailbox) {
***************
*** 636,643 ****
X  		} else {
X  			my_strncpy (file, glob_group, sizeof (file));
X  		}
! 		save[save_num].dir = str_dup (active[my_group[cur_groupnum]].attribute.maildir);
! 		save[save_num].file = str_dup (file);
X  	} else {
X  		if (path[0]) {
X  			for (i=strlen (path) ; i ; i--) {
--- 638,645 ----
X  		} else {
X  			my_strncpy (file, glob_group, sizeof (file));
X  		}
! 		save[num_save].dir = str_dup (active[my_group[cur_groupnum]].attribute.maildir);
! 		save[num_save].file = str_dup (file);
X  	} else {
X  		if (path[0]) {
X  			for (i=strlen (path) ; i ; i--) {
***************
*** 651,672 ****
X  		}
X  		
X  		if (dir[0]) {
! 			save[save_num].dir = str_dup (dir);
X  		} else {
! 			save[save_num].dir = str_dup (active[my_group[cur_groupnum]].attribute.savedir);
X  		}
X  
X  		if (file[0]) {
! 			save[save_num].file = str_dup (file);
X  		} else {
X  			if (path[0]) {
! 				save[save_num].file = str_dup (path);
X  			} else {
! 				save[save_num].file = str_dup (save[save_num].archive);
X  			}
X  		}
X  	}
! 	save_num++;
X  
X  #endif /* INDEX_DAEMON */
X  }
--- 653,674 ----
X  		}
X  		
X  		if (dir[0]) {
! 			save[num_save].dir = str_dup (dir);
X  		} else {
! 			save[num_save].dir = str_dup (active[my_group[cur_groupnum]].attribute.savedir);
X  		}
X  
X  		if (file[0]) {
! 			save[num_save].file = str_dup (file);
X  		} else {
X  			if (path[0]) {
! 				save[num_save].file = str_dup (path);
X  			} else {
! 				save[num_save].file = str_dup (save[num_save].archive);
X  			}
X  		}
X  	}
! 	num_save++;
X  
X  #endif /* INDEX_DAEMON */
X  }
***************
*** 677,683 ****
X  
X  void sort_save_list ()
X  {
! 	qsort ((char *) save, save_num, sizeof (struct save_t), save_comp);
X  }
X  
X  /*
--- 679,686 ----
X  
X  void sort_save_list ()
X  {
! 	qsort ((char *) save, num_save, sizeof (struct save_t), save_comp);
! 	debug_save_comp ();
X  }
X  
X  /*
***************
*** 697,702 ****
--- 700,729 ----
X  	 */
X  	if (s1->archive != (char *) 0) {
X  		if (s1->part != (char *) 0) {
+ 			if (s2->part != (char *) 0) {
+ 				if (strcmp (s1->part, s2->part) < 0) {
+ 					return -1;
+ 				}
+ 				if (strcmp (s1->part, s2->part) > 0) {
+ 					return 1;
+ 				}
+ 			} else {
+ 				return 0;
+ 			}	
+ 		} else if (s1->patch != (char *) 0) {
+ 			if (s2->patch != (char *) 0) {
+ 				if (strcmp (s1->patch, s2->patch) < 0) {
+ 					return -1;
+ 				}
+ 				if (strcmp (s1->patch, s2->patch) > 0) {
+ 					return 1;
+ 				}
+ 			} else {
+ 				return 0;
+ 			}	
+ 		}	
+ #if 0
+ 		if (s1->part != (char *) 0) {
X  			if (strcmp (s1->part, s2->part) < 0) {
X  				return -1;
X  			}
***************
*** 711,716 ****
--- 738,744 ----
X  				return 1;
X  			}
X  		}	
+ #endif
X  	} else {
X  		if (strcmp (s1->subject, s2->subject) < 0) {
X  			return -1;
***************
*** 736,743 ****
X  		return (filename);
X  	}
X  	
! 	if (! save_archive_name || (! save[i].part && ! save[i].patch)) {
! 		if (save_num == 1) {
X  			sprintf (filename, "%s/%s", save[i].dir, save[i].file);
X  		} else {
X  			sprintf (filename, "%s/%s.%02d", save[i].dir, save[i].file, i+1);
--- 764,771 ----
X  		return (filename);
X  	}
X  	
! 	if (! default_auto_save || (! save[i].part && ! save[i].patch)) {
! 		if (num_save == 1) {
X  			sprintf (filename, "%s/%s", save[i].dir, save[i].file);
X  		} else {
X  			sprintf (filename, "%s/%s.%02d", save[i].dir, save[i].file, i+1);
***************
*** 771,777 ****
X  	char *file;
X  	int i;
X  
! 	for (i=0 ; i < save_num ; i++) {
X  		if (save[i].saved) {
X  			file = (char *) my_malloc (PATH_LEN);
X  			if (save[i].is_mailbox) {
--- 799,805 ----
X  	char *file;
X  	int i;
X  
! 	for (i=0 ; i < num_save ; i++) {
X  		if (save[i].saved) {
X  			file = (char *) my_malloc (PATH_LEN);
X  			if (save[i].is_mailbox) {
***************
*** 778,784 ****
X  				sprintf (file, "%s/%s", save[i].dir, save[i].file);
X  				return (file);
X  			} else {
! 				if (save[i].archive && save_archive_name) {
X  					if (save[i].part) {
X  						if (create_subdir) {
X  							sprintf (file, "%s/%s.%s%s", save[i].archive, save[i].archive, LONG_PATH_PART, save[i].part);
--- 806,812 ----
X  				sprintf (file, "%s/%s", save[i].dir, save[i].file);
X  				return (file);
X  			} else {
! 				if (save[i].archive && default_auto_save) {
X  					if (save[i].part) {
X  						if (create_subdir) {
X  							sprintf (file, "%s/%s.%s%s", save[i].archive, save[i].archive, LONG_PATH_PART, save[i].part);
***************
*** 793,799 ****
X  						}
X  					}
X  				} else {
! 					if (save_num == 1) {
X  						sprintf (file, "%s", save[i].file);
X  					} else {
X  						sprintf (file, "%s.%02d", save[i].file, i+1);
--- 821,827 ----
X  						}
X  					}
X  				} else {
! 					if (num_save == 1) {
X  						sprintf (file, "%s", save[i].file);
X  					} else {
X  						sprintf (file, "%s.%02d", save[i].file, i+1);
***************
*** 812,818 ****
X  	char *file;
X  	int i;
X  	
! 	for (i=save_num-1 ; i >= 0 ; i--) {
X  		if (save[i].saved) {
X  			file = (char *) my_malloc (PATH_LEN);
X  			if (save[i].is_mailbox) {
--- 840,846 ----
X  	char *file;
X  	int i;
X  	
! 	for (i=num_save-1 ; i >= 0 ; i--) {
X  		if (save[i].saved) {
X  			file = (char *) my_malloc (PATH_LEN);
X  			if (save[i].is_mailbox) {
***************
*** 819,825 ****
X  				sprintf (file, "%s/%s", save[i].dir, save[i].file);
X  				return (file);
X  			} else {
! 				if (save[i].archive && save_archive_name) {
X  					if (save[i].part) {
X  						if (create_subdir) {
X  							sprintf (file, "%s/%s.%s%s", save[i].archive, save[i].archive, LONG_PATH_PART, save[i].part);
--- 847,853 ----
X  				sprintf (file, "%s/%s", save[i].dir, save[i].file);
X  				return (file);
X  			} else {
! 				if (save[i].archive && default_auto_save) {
X  					if (save[i].part) {
X  						if (create_subdir) {
X  							sprintf (file, "%s/%s.%s%s", save[i].archive, save[i].archive, LONG_PATH_PART, save[i].part);
***************
*** 834,840 ****
X  						}
X  					}
X  				} else {
! 					if (save_num == 1) {
X  						sprintf (file, "%s", save[i].file);
X  					} else {
X  						sprintf (file, "%s.%02d", save[i].file, i+1);
--- 862,868 ----
X  						}
X  					}
X  				} else {
! 					if (num_save == 1) {
X  						sprintf (file, "%s", save[i].file);
X  					} else {
X  						sprintf (file, "%s.%02d", save[i].file, i+1);
***************
*** 851,857 ****
X  int post_process_files (proc_type_ch)
X  	char proc_type_ch;
X  {
! 	if (save_num) {
X  		wait_message (txt_post_processing);
X  
X  		switch (proc_type_ch) {
--- 879,885 ----
X  int post_process_files (proc_type_ch)
X  	char proc_type_ch;
X  {
! 	if (num_save) {
X  		wait_message (txt_post_processing);
X  
X  		switch (proc_type_ch) {
***************
*** 864,870 ****
X  				break;
X  
X  			case 'U':
! 				if (post_proc_type == POST_PROC_UUD_EXT_ZOO) {
X  					post_process_uud (POST_PROC_UUD_EXT_ZOO);
X  				} else {
X  					post_process_uud (POST_PROC_UUD_LST_ZOO);
--- 892,898 ----
X  				break;
X  
X  			case 'U':
! 				if (default_post_proc_type == POST_PROC_UUD_EXT_ZOO) {
X  					post_process_uud (POST_PROC_UUD_EXT_ZOO);
X  				} else {
X  					post_process_uud (POST_PROC_UUD_LST_ZOO);
***************
*** 913,919 ****
X  	}
X  
X  
! 	for (i=0 ; i < save_num ; i++) {
X  		my_strncpy (buf, save_filename (i), sizeof (buf));
X  
X  		if ((fp_in = fopen (buf, "r")) != NULL) {
--- 941,947 ----
X  	}
X  
X  
! 	for (i=0 ; i < num_save ; i++) {
X  		my_strncpy (buf, save_filename (i), sizeof (buf));
X  
X  		if ((fp_in = fopen (buf, "r")) != NULL) {
***************
*** 1086,1092 ****
X  
X  	sprintf (file_out, "%s/tin.%05d", file_out_dir, process_id);
X  
! 	for (j=0 ; j < save_num ; j++) {
X  		my_strncpy (file_in, save_filename (j), sizeof (file_in));
X  
X  		printf (txt_extracting_shar, file_in);
--- 1114,1120 ----
X  
X  	sprintf (file_out, "%s/tin.%05d", file_out_dir, process_id);
X  
! 	for (j=0 ; j < num_save ; j++) {
X  		my_strncpy (file_in, save_filename (j), sizeof (file_in));
X  
X  		printf (txt_extracting_shar, file_in);
***************
*** 1173,1179 ****
X  	if (prompt_yn (LINES, txt_delete_processed_files, 'y')) {
X  		wait_message (txt_deleting);
X  
! 		for (i=0 ; i < save_num ; i++) {
X  			unlink (save_filename (i));
X  		}
X  	}
--- 1201,1207 ----
X  	if (prompt_yn (LINES, txt_delete_processed_files, 'y')) {
X  		wait_message (txt_deleting);
X  
! 		for (i=0 ; i < num_save ; i++) {
X  			unlink (save_filename (i));
X  		}
X  	}
diff -rcs ../1.14/screen.c ./screen.c
*** ../1.14/screen.c	Tue Aug 11 21:23:21 1992
--- ./screen.c	Mon Jul 20 12:51:09 1992
***************
*** 56,62 ****
X  		fflush (stderr);
X  	} else {
X  		MoveCursor (LINES, 0);
! 		sleep (2);
X  	}
X  }
X  
--- 56,62 ----
X  		fflush (stderr);
X  	} else {
X  		MoveCursor (LINES, 0);
! 		sleep (3);
X  	}
X  }
X  
***************
*** 65,76 ****
X  	char *template;
X  	char *str;
X  {
X  	char str2[512];
X  
X  	clear_message ();	  /* Clear any old messages hanging around */
! 	
X  	sprintf (str2, template, str);
X  	perror (str2);
X  	errno = 0;
X  
X  	if (cmd_line) {
--- 65,84 ----
X  	char *template;
X  	char *str;
X  {
+ 	extern char *sys_errlist[];
X  	char str2[512];
+ 	int err = 0;
+ 	
+ 	err = errno;
X  
X  	clear_message ();	  /* Clear any old messages hanging around */
! 
X  	sprintf (str2, template, str);
+ /*	
X  	perror (str2);
+ */
+ 	err = errno;
+ 	fprintf (stderr, "%s: %s", str2, sys_errlist[err]);
X  	errno = 0;
X  
X  	if (cmd_line) {
***************
*** 78,84 ****
X  		fflush (stderr);
X  	} else {
X  		MoveCursor (LINES, 0);
! 		sleep (2);
X  	}
X  }
X  
--- 86,92 ----
X  		fflush (stderr);
X  	} else {
X  		MoveCursor (LINES, 0);
! 		sleep (3);
X  	}
X  }
X  
diff -rcs ../1.14/search.c ./search.c
*** ../1.14/search.c	Tue Aug 11 21:23:22 1992
--- ./search.c	Fri Jul 24 21:00:05 1992
***************
*** 3,9 ****
X   *  Module    : search.c
X   *  Author    : I.Lea & R.Skrenta
X   *  Created   : 01-04-91
!  *  Updated   : 13-03-92
X   *  Notes     :
X   *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X   *              You may  freely  copy or  redistribute  this software,
--- 3,9 ----
X   *  Module    : search.c
X   *  Author    : I.Lea & R.Skrenta
X   *  Created   : 01-04-91
!  *  Updated   : 24-07-92
X   *  Notes     :
X   *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X   *              You may  freely  copy or  redistribute  this software,
***************
*** 40,47 ****
X   *  group.c & page.c
X   */
X   
! int search_author (only_unread, current_art, forward)
! 	int only_unread;
X  	int current_art;
X  	int forward;
X  {
--- 40,47 ----
X   *  group.c & page.c
X   */
X   
! int search_author (index, current_art, forward)
! 	int index;
X  	int current_art;
X  	int forward;
X  {
***************
*** 92,98 ****
X  					num_of_responses (top_base - 1);
X  		}
X  
! 		if (only_unread && arts[i].unread != ART_UNREAD) {
X  			continue;
X  		}
X  			
--- 92,99 ----
X  					num_of_responses (top_base - 1);
X  		}
X  
! 		if (active[index].attribute.show_only_unread && 
! 		    arts[i].unread != ART_UNREAD) {
X  			continue;
X  		}
X  			
diff -rcs ../1.14/select.c ./select.c
*** ../1.14/select.c	Tue Aug 11 21:23:23 1992
--- ./select.c	Tue Jul 28 07:10:01 1992
***************
*** 3,9 ****
X   *  Module    : select.c
X   *  Author    : I.Lea & R.Skrenta
X   *  Created   : 01-04-91
!  *  Updated   : 18-06-92
X   *  Notes     :
X   *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X   *              You may  freely  copy or  redistribute  this software,
--- 3,9 ----
X   *  Module    : select.c
X   *  Author    : I.Lea & R.Skrenta
X   *  Created   : 01-04-91
!  *  Updated   : 27-07-92
X   *  Notes     :
X   *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X   *              You may  freely  copy or  redistribute  this software,
***************
*** 57,68 ****
X  	set_alarm_signal ();		/* set alarm signal for resync_active_file () */
X  	
X  	while (TRUE) {
! #ifndef NO_RESYNC_ACTIVE_FILE
X  		resync_active_file ();	/* reread active file if alarm set */
X  #endif
X  		ch = ReadCh ();
! #ifndef NO_RESYNC_ACTIVE_FILE
! 		resync_active_file ();	/* reread active file if alarm set */
X  #endif
X  
X  		if (ch > '0' && ch <= '9') {
--- 57,69 ----
X  	set_alarm_signal ();		/* set alarm signal for resync_active_file () */
X  	
X  	while (TRUE) {
! #ifndef NO_REREAD_ACTIVE_FILE
X  		resync_active_file ();	/* reread active file if alarm set */
X  #endif
X  		ch = ReadCh ();
! #ifndef NO_REREAD_ACTIVE_FILE
! 		if (ch != 'q' && ch != 'Q')
! 			resync_active_file ();
X  #endif
X  
X  		if (ch > '0' && ch <= '9') {
***************
*** 151,157 ****
X  						n = my_group[cur_groupnum];
X  						group_page (active[n].name);
X  					} while (index_point == -3);
! #ifndef NO_RESYNC_ACTIVE_FILE					
X  					if (! reread_active_file)
X  #endif					
X  						group_selection_page ();
--- 152,158 ----
X  						n = my_group[cur_groupnum];
X  						group_page (active[n].name);
X  					} while (index_point == -3);
! #ifndef NO_REREAD_ACTIVE_FILE					
X  					if (! reread_active_file)
X  #endif					
X  						group_selection_page ();
***************
*** 217,228 ****
X  				sprintf (msg, txt_del_group_in_newsrc, buf);
X  				if (prompt_yn (LINES, msg, 'y')) {
X  					delete_group (active[my_group[cur_groupnum]].name);
! 					active[my_group[cur_groupnum]].flag = UNSUBSCRIBED;	
X  
X  					group_top--;
X  					for (i = cur_groupnum; i < group_top; i++) {
X  						my_group[i] = my_group[i+1];
- 						unread[i] = unread[i+1];
X  					}
X  					if (cur_groupnum >= group_top)
X  						cur_groupnum = group_top - 1;	
--- 218,232 ----
X  				sprintf (msg, txt_del_group_in_newsrc, buf);
X  				if (prompt_yn (LINES, msg, 'y')) {
X  					delete_group (active[my_group[cur_groupnum]].name);
! 					active[my_group[cur_groupnum]].my_group = UNSUBSCRIBED;	
X  
X  					group_top--;
X  					for (i = cur_groupnum; i < group_top; i++) {
+ #if 0
+ 						active[my_group[i]].unread = 
+ 							active[my_group[i+1]].unread;
+ #endif							
X  						my_group[i] = my_group[i+1];
X  					}
X  					if (cur_groupnum >= group_top)
X  						cur_groupnum = group_top - 1;	
***************
*** 374,380 ****
X  
X  			case 'g':	/* prompt for a new group name */
X  				if ((n = choose_new_group ()) >= 0) {
! 					if (active[my_group[n]].flag != SUBSCRIBED) {
X  						subscribe (active[my_group[n]].name, ':',
X  							my_group[n], FALSE);
X  					}
--- 378,384 ----
X  
X  			case 'g':	/* prompt for a new group name */
X  				if ((n = choose_new_group ()) >= 0) {
! 					if (active[my_group[n]].my_group != SUBSCRIBED) {
X  						subscribe (active[my_group[n]].name, ':',
X  							my_group[n], FALSE);
X  					}
***************
*** 411,417 ****
X  				break;
X  
X  			case 'm':	/* reposition group within group list */
! 				if (active[my_group[cur_groupnum]].flag == SUBSCRIBED) {
X  					n = cur_groupnum;
X  					cur_groupnum = reposition_group (active[my_group[n]].name, n);
X  					if (cur_groupnum < first_group_on_screen ||
--- 415,421 ----
X  				break;
X  
X  			case 'm':	/* reposition group within group list */
! 				if (active[my_group[cur_groupnum]].my_group == SUBSCRIBED) {
X  					n = cur_groupnum;
X  					cur_groupnum = reposition_group (active[my_group[n]].name, n);
X  					if (cur_groupnum < first_group_on_screen ||
***************
*** 432,437 ****
--- 436,443 ----
X  			case 'M':	/* options menu */
X  				set_alarm_clock_off ();
X  				change_rcfile ("", TRUE);
+ 				free_attributes_array ();
+ 				read_attributes_file ();
X  				group_selection_page ();
X  				set_alarm_clock_on ();
X  				break;
***************
*** 441,456 ****
X  				break;
X  
X  			case 'q':	/* quit */
! 			case 'Q':	/* quit */
X  				write_rcfile ();
X  				tin_done (0);
X  				break;
X  
X  			case 's':	/* subscribe to current group */
X  				if (group_top == 0) {
X  					break;
X  				}
! 				if (active[my_group[cur_groupnum]].flag != SUBSCRIBED) {
X  					MoveCursor (INDEX_TOP + (cur_groupnum-first_group_on_screen), 2);
X  					if (draw_arrow_mark) {
X  						fputc (' ', stdout);
--- 447,474 ----
X  				break;
X  
X  			case 'q':	/* quit */
! 			case 'Q':
X  				write_rcfile ();
X  				tin_done (0);
X  				break;
X  
+ 			case 'r':
+ 	 			/* 
+ 	 			 * If in show_only_unread_groups mode toggle
+ 	 			 * all subscribed to groups and only  groups
+ 	 			 * that contain unread articles
+ 	 			 */
+ 	 			show_only_unread_groups = !show_only_unread_groups;
+ 				toggle_my_groups (show_only_unread_groups);
+ 				set_groupname_len (FALSE);
+ 				group_selection_page ();
+ 				break;
+ 
X  			case 's':	/* subscribe to current group */
X  				if (group_top == 0) {
X  					break;
X  				}
! 				if (active[my_group[cur_groupnum]].my_group != SUBSCRIBED) {
X  					MoveCursor (INDEX_TOP + (cur_groupnum-first_group_on_screen), 2);
X  					if (draw_arrow_mark) {
X  						fputc (' ', stdout);
***************
*** 478,484 ****
X  #else		
X  						if (wildmat (active[my_group[i]].name, buf)) {
X  #endif		
! 			   		 		if (active[my_group[i]].flag != SUBSCRIBED) {
X  #ifndef SLOW_SCREEN_UPDATE
X  								sprintf (msg, txt_subscribing_to, active[my_group[i]].name);
X  								wait_message (msg);
--- 496,502 ----
X  #else		
X  						if (wildmat (active[my_group[i]].name, buf)) {
X  #endif		
! 			   		 		if (active[my_group[i]].my_group != SUBSCRIBED) {
X  #ifndef SLOW_SCREEN_UPDATE
X  								sprintf (msg, txt_subscribing_to, active[my_group[i]].name);
X  								wait_message (msg);
***************
*** 505,511 ****
X  				if (group_top == 0) {
X  					break;
X  				}
! 			    if (active[my_group[cur_groupnum]].flag == SUBSCRIBED) {
X  				    MoveCursor(INDEX_TOP + (cur_groupnum-first_group_on_screen), 2);
X  					if (draw_arrow_mark) {
X  						fputc ('u', stdout);
--- 523,529 ----
X  				if (group_top == 0) {
X  					break;
X  				}
! 			    if (active[my_group[cur_groupnum]].my_group == SUBSCRIBED) {
X  				    MoveCursor(INDEX_TOP + (cur_groupnum-first_group_on_screen), 2);
X  					if (draw_arrow_mark) {
X  						fputc ('u', stdout);
***************
*** 533,539 ****
X  #else		
X  						if (wildmat (active[my_group[i]].name, buf)) {
X  #endif		
! 			   		 		if (active[my_group[i]].flag == SUBSCRIBED) {
X  #ifndef SLOW_SCREEN_UPDATE
X  								sprintf (msg, txt_unsubscribing_from, active[my_group[i]].name);
X  								wait_message (msg);
--- 551,557 ----
X  #else		
X  						if (wildmat (active[my_group[i]].name, buf)) {
X  #endif		
! 			   		 		if (active[my_group[i]].my_group == SUBSCRIBED) {
X  #ifndef SLOW_SCREEN_UPDATE
X  								sprintf (msg, txt_unsubscribing_from, active[my_group[i]].name);
X  								wait_message (msg);
***************
*** 588,603 ****
X  			case 'y':	/* pull in rest of groups from active */
X  				if (yank_active_file) {
X  					wait_message (txt_yanking_all_groups);
X  					n = group_top;
X  					for (i = 0; i < num_active; i++) {
! 						active[i].flag = UNSUBSCRIBED;
X  					}
X  					read_newsrc (FALSE);
X  					for (i = 0; i < num_active; i++) {
! 						if (active[i].flag & UNSUBSCRIBED) {
! 							active[i].flag &= ~UNSUBSCRIBED;
X  							my_group[group_top] = i;
- 							unread[group_top] = -1;
X  							group_top++;
X  						}
X  					}
--- 606,622 ----
X  			case 'y':	/* pull in rest of groups from active */
X  				if (yank_active_file) {
X  					wait_message (txt_yanking_all_groups);
+ 					set_alarm_clock_off ();
X  					n = group_top;
X  					for (i = 0; i < num_active; i++) {
! 						active[i].my_group = UNSUBSCRIBED;
X  					}
X  					read_newsrc (FALSE);
X  					for (i = 0; i < num_active; i++) {
! 						if (active[i].my_group & UNSUBSCRIBED) {
! 							active[i].my_group &= ~UNSUBSCRIBED;
! 							active[i].unread = -1;
X  							my_group[group_top] = i;
X  							group_top++;
X  						}
X  					}
***************
*** 618,623 ****
--- 637,643 ----
X  					set_groupname_len (yank_active_file);
X  					group_selection_page ();
X  					yank_active_file = TRUE;
+ 					set_alarm_clock_on ();
X  				}
X  				break;
X  
***************
*** 636,643 ****
X  				group_top = 0;
X  				read_newsrc (TRUE);			
X  				cur_groupnum = n;
! 				if (unread[cur_groupnum]) {
! 					sprintf (msg, "%5d", unread[cur_groupnum]);
X  				} else {	
X  					strcpy (msg, "     ");
X  				}
--- 656,663 ----
X  				group_top = 0;
X  				read_newsrc (TRUE);			
X  				cur_groupnum = n;
! 				if (active[my_group[cur_groupnum]].unread) {
! 					sprintf (msg, "%5d", active[my_group[cur_groupnum]].unread);
X  				} else {	
X  					strcpy (msg, "     ");
X  				}
***************
*** 687,695 ****
X  #endif
X  
X  	if (xspooldir_supported) {
! 		sprintf (buf, "%s (%s  %d)", txt_group_selection, spooldir_alias, group_top);
X  	} else {
! 		sprintf (buf, "%s (%d)", txt_group_selection, group_top);
X  	}	
X  	show_title (buf);
X  
--- 707,718 ----
X  #endif
X  
X  	if (xspooldir_supported) {
! 		sprintf (buf, "%s (%s  %d%s)", 
! 			txt_group_selection, spooldir_alias, group_top,
! 			(show_only_unread_groups ? " R" : ""));
X  	} else {
! 		sprintf (buf, "%s (%d%s)", txt_group_selection, group_top,
! 			(show_only_unread_groups ? " R" : ""));
X  	}	
X  	show_title (buf);
X  
***************
*** 739,746 ****
X  
X  	blank_len = (COLS - (groupname_len + SELECT_MISC_COLS)) + 2;
X  	
! 	for (j=0, i = first_group_on_screen; i < last_group_on_screen; i++,j++) {
! 		switch (unread[i]) {
X  			case -2:
X  				strcpy (new, "    ?");
X  				break;
--- 762,769 ----
X  
X  	blank_len = (COLS - (groupname_len + SELECT_MISC_COLS)) + 2;
X  	
! 	for (j=0, i=first_group_on_screen; i < last_group_on_screen; i++, j++) {
! 		switch (active[my_group[i]].unread) {
X  			case -2:
X  				strcpy (new, "    ?");
X  				break;
***************
*** 754,764 ****
X  				break;
X  
X  			default:
! 				sprintf (new, "%5.d", unread[i]);
X  		}
X  		
X  		n = my_group[i];
! 		if (active[n].flag & SUBSCRIBED) {	/* subscribed? */
X  			subs = ' ';
X  		} else {
X  			subs = 'u';	/* u next to unsubscribed groups */
--- 777,787 ----
X  				break;
X  
X  			default:
! 				sprintf (new, "%5.d", active[my_group[i]].unread);
X  		}
X  		
X  		n = my_group[i];
! 		if (active[n].my_group & SUBSCRIBED) {	/* subscribed? */
X  			subs = ' ';
X  		} else {
X  			subs = 'u';	/* u next to unsubscribed groups */
***************
*** 892,898 ****
X  }
X  
X  /*
!  *  Add a group to the selection list (my_group[])
X   *  Return the index of my_group[] if group is added or was already
X   *  there.  Return -1 if named group is not in active[].
X   */
--- 915,921 ----
X  }
X  
X  /*
!  *  Add a group to the users selection list (my_group[])
X   *  Return the index of my_group[] if group is added or was already
X   *  there.  Return -1 if named group is not in active[].
X   */
***************
*** 914,929 ****
X  				}
X  			}
X  
! 			active[i].flag &= ~UNSUBSCRIBED;   /* mark that we got it */
! 			my_group[group_top] = i;
X  
! 			if (get_unread)
! 				unread[group_top] = get_line_unread (s, i);
! 			else
! 				unread[group_top] = -2;
X  
X  			group_top++;
! 			return group_top - 1;
X  		}
X  	}
X  
--- 937,954 ----
X  				}
X  			}
X  
! 			active[i].my_group &= ~UNSUBSCRIBED;   /* mark that we got it */
X  
! 			my_group[group_top] = i;
X  
+ 			if (get_unread) {
+ 				active[my_group[group_top]].unread = get_line_unread (s, i);
+ 			} else {
+ 				active[my_group[group_top]].unread = -1;
+ 			}
X  			group_top++;
! 
! 			return (group_top - 1);
X  		}
X  	}
X  
***************
*** 984,991 ****
X  	int goto_next_unread_group;
X  {	
X  	sprintf (msg, txt_mark_group_read, active[my_group[cur_groupnum]].name);
! 	if (!confirm_action || prompt_yn (LINES, msg, 'y')) {
! 		unread[cur_groupnum] = 0;
X  		mark_group_read (active[my_group[cur_groupnum]].name,
X  			my_group[cur_groupnum]);
X  		
--- 1009,1016 ----
X  	int goto_next_unread_group;
X  {	
X  	sprintf (msg, txt_mark_group_read, active[my_group[cur_groupnum]].name);
! 	if (! confirm_action || prompt_yn (LINES, msg, 'y')) {
! 		active[my_group[cur_groupnum]].unread = 0;
X  		mark_group_read (active[my_group[cur_groupnum]].name,
X  			my_group[cur_groupnum]);
X  		
***************
*** 1014,1034 ****
X  void next_unread_group (enter_group)
X  	int enter_group;
X  {
! 	int i;
! 	
! 	for (i = cur_groupnum; i < group_top; i++) {
! 		if (unread[i] != 0) {
X  			break;
X  		}
X  	}
! 	if (i >= group_top) {
X  		info_message (txt_no_groups_to_read);
X  		return;
X  	}
X  
! 	erase_group_arrow ();
X  	cur_groupnum = i;
! 	if (cur_groupnum >= last_group_on_screen) {
X  		group_selection_page ();
X  	} else {
X  		draw_group_arrow ();
--- 1039,1074 ----
X  void next_unread_group (enter_group)
X  	int enter_group;
X  {
! 	int i, all_groups_read = TRUE;
! 
! 	for (i = cur_groupnum ; i < group_top ; i++) {
! 		if (active[my_group[i]].unread != 0) {
! 			all_groups_read = FALSE;
! 			erase_group_arrow ();
X  			break;
X  		}
X  	}
! 
! 	if (all_groups_read) {
! 		for (i = 0 ; i < cur_groupnum ; i++) {
! 			if (active[my_group[i]].unread != 0) {
! 				all_groups_read = FALSE;
! 				break;
! 			}
! 		}
! 	}
! 	
! 	if (all_groups_read) {
X  		info_message (txt_no_groups_to_read);
X  		return;
X  	}
X  
! 	if (i != cur_groupnum) {
! 		erase_group_arrow ();
! 	}
X  	cur_groupnum = i;
! 	if (cur_groupnum < first_group_on_screen ||
! 	    cur_groupnum >= last_group_on_screen) {
X  		group_selection_page ();
X  	} else {
X  		draw_group_arrow ();
***************
*** 1081,1093 ****
X  			groupname_len = 0;
X  		}	
X  	}
X  
! /*	
! 	if (groupname_len > (COLS - SELECT_MISC_COLS)) {
! 		groupname_len = COLS - SELECT_MISC_COLS;
! 		if (groupname_len < 0) {
! 			groupname_len = 0;
! 		}	
X  	}
! */		
X  }
--- 1121,1158 ----
X  			groupname_len = 0;
X  		}	
X  	}
+ }
X  
! 
! void toggle_my_groups (only_unread_groups)
! 	int only_unread_groups;
! {
! #ifndef INDEX_DAEMON
! 	char buf[8192];
! 	char *ptr;
! 	FILE *fp;
! 	int i;
! 
! 	if ((fp = fopen (newsrc, "r")) != (FILE *) 0) {
! 		group_top = 0;
! 		while (fgets (buf, sizeof (buf), fp) != (char *) 0) {
! 			if (ptr = strchr (buf, ':')) {
! 				*ptr = '\0';
! 				if (i = find_group_index (buf)) {
! 					if (only_unread_groups) {					
! 						if (active[i].unread) {
! 							my_group[group_top] = i;
! 							group_top++;
! 						}
! 					} else {
! 						my_group[group_top] = i;
! 						group_top++;
! 					}	
! 				}
! 			}
! 		}		
! 		fclose (fp);
X  	}
! 
! #endif	/* INDEX_DAEMON */
X  }
Files ../1.14/server.patch and ./server.patch are identical
diff -rcs ../1.14/signal.c ./signal.c
*** ../1.14/signal.c	Tue Aug 11 21:23:23 1992
--- ./signal.c	Mon Jul 20 12:51:09 1992
***************
*** 3,9 ****
X   *  Module    : signal.c
X   *  Author    : I.Lea
X   *  Created   : 01-04-91
!  *  Updated   : 22-06-92
X   *  Notes     : signal handlers for different modes and window resizing
X   *  Copyright : (c) Copyright 1991-92 by Iain Lea
X   *              You may  freely  copy or  redistribute  this software,
--- 3,9 ----
X   *  Module    : signal.c
X   *  Author    : I.Lea
X   *  Created   : 01-04-91
!  *  Updated   : 20-07-92
X   *  Notes     : signal handlers for different modes and window resizing
X   *  Copyright : (c) Copyright 1991-92 by Iain Lea
X   *              You may  freely  copy or  redistribute  this software,
***************
*** 105,117 ****
X  
X  void set_alarm_signal ()
X  {
! #ifndef NO_RESYNC_ACTIVE_FILE
X  	/*
X  	 * Only reread active file if news is not static (ie. CD-ROM)
X  	 */
X  	if (strcmp (spooldir_alias, "news") == 0) {
X  		signal (SIGALRM, signal_handler);
! 		alarm (RESYNC_ACTIVE_SECS);
X  	}	
X  	reread_active_file = FALSE;
X  #endif
--- 105,118 ----
X  
X  void set_alarm_signal ()
X  {
! #ifndef NO_REREAD_ACTIVE_FILE
X  	/*
X  	 * Only reread active file if news is not static (ie. CD-ROM)
X  	 */
+ 	(void) alarm (0);
X  	if (strcmp (spooldir_alias, "news") == 0) {
X  		signal (SIGALRM, signal_handler);
! 		alarm (reread_active_file_secs);
X  	}	
X  	reread_active_file = FALSE;
X  #endif
***************
*** 120,126 ****
X  
X  void set_alarm_clock_on ()
X  {
! #ifndef NO_RESYNC_ACTIVE_FILE
X  	alarm (time_remaining);
X  #endif
X  }
--- 121,127 ----
X  
X  void set_alarm_clock_on ()
X  {
! #ifndef NO_REREAD_ACTIVE_FILE
X  	alarm (time_remaining);
X  #endif
X  }
***************
*** 128,134 ****
X  
X  void set_alarm_clock_off ()
X  {
! #ifndef NO_RESYNC_ACTIVE_FILE
X  	time_remaining = alarm (0);
X  #endif
X  }
--- 129,135 ----
X  
X  void set_alarm_clock_off ()
X  {
! #ifndef NO_REREAD_ACTIVE_FILE
X  	time_remaining = alarm (0);
X  #endif
X  }
***************
*** 176,182 ****
X  		case SIGSEGV:
X  			sigtext = "SIGSEGV ";
X  			break;
! #ifndef NO_RESYNC_ACTIVE_FILE
X  		case SIGALRM:
X  			set_alarm_signal ();
X  			reread_active_file = TRUE;
--- 177,183 ----
X  		case SIGSEGV:
X  			sigtext = "SIGSEGV ";
X  			break;
! #ifndef NO_REREAD_ACTIVE_FILE
X  		case SIGALRM:
X  			set_alarm_signal ();
X  			reread_active_file = TRUE;
***************
*** 200,208 ****
X  		unlink (index_file);
X  	}
X  
! #ifdef INDEX_DAEMON
! 	unlink (LOCK_FILE);
! #endif
X  	exit (1);
X  }
X  
--- 201,208 ----
X  		unlink (index_file);
X  	}
X  
! 	unlink (lock_file);
! 
X  	exit (1);
X  }
X  
***************
*** 296,301 ****
--- 296,315 ----
X  }
X  
X  
+ void set_signals_help ()
+ {
+ #ifdef SIGTSTP
+ 	if (do_sigtstp) {
+ 		sigdisp (SIGTSTP, help_suspend);
+ 	}
+ #endif
+ 
+ #ifdef SIGWINCH
+ 	signal (SIGWINCH, help_resize);
+ #endif
+ }
+ 
+ 
X  void set_signals_page ()
X  {
X  #ifdef SIGTSTP
***************
*** 455,460 ****
--- 469,494 ----
X  
X  
X  /* ARGSUSED0 */
+ void help_suspend (sig)
+ 	int sig;
+ {
+ 	set_keypad_off ();
+ 	Raw (FALSE);
+ 	wait_message (txt_suspended_message);
+ 
+ 	kill (0, SIGSTOP);
+ 
+ 	sigdisp (SIGTSTP, help_suspend);
+ 
+ 	if (! update) {
+ 		Raw (TRUE);
+ 		help_resize (0);		
+ 	}
+ 	set_keypad_on ();
+ }
+ 
+ 
+ /* ARGSUSED0 */
X  void page_suspend (sig)
X  	int sig;
X  {
***************
*** 558,564 ****
X  	ClearScreen ();
X  #endif
X  	mail_setup ();
! 	if (resized) {
X  		group_selection_page ();
X  	}	
X  }
--- 592,598 ----
X  	ClearScreen ();
X  #endif
X  	mail_setup ();
! 	if (resized || sig == 0) {
X  		group_selection_page ();
X  	}	
X  }
***************
*** 579,585 ****
X  	ClearScreen ();
X  #endif
X  	mail_setup ();
! 	if (resized) {
X  		show_spooldir_page ();
X  	}
X  }
--- 613,619 ----
X  	ClearScreen ();
X  #endif
X  	mail_setup ();
! 	if (resized || sig == 0) {
X  		show_spooldir_page ();
X  	}
X  }
***************
*** 600,606 ****
X  	ClearScreen ();
X  #endif
X  	mail_setup ();
! 	if (resized) {
X  		show_group_page (glob_group);
X  	}	
X  }
--- 634,640 ----
X  	ClearScreen ();
X  #endif
X  	mail_setup ();
! 	if (resized || sig == 0) {
X  		show_group_page (glob_group);
X  	}	
X  }
***************
*** 607,612 ****
--- 641,662 ----
X  
X  
X  /* ARGSUSED0 */
+ void help_resize (sig)
+ 	int sig;
+ {
+ 	int resized = TRUE;
+ 	
+ #ifdef SIGWINCH
+ 	resized = set_win_size (&LINES, &COLS);
+ 	signal (SIGWINCH, help_resize);
+ #endif
+ 	
+ 	if (resized || sig == 0) {
+ 		display_info_page ();
+ 	}
+ }
+ 
+ /* ARGSUSED0 */
X  void page_resize (sig)
X  	int sig;
X  {
***************
*** 621,627 ****
X  	ClearScreen ();
X  #endif
X  	mail_setup ();
! 	if (resized) {
X  		redraw_page (glob_respnum, glob_page_group);
X  	}	
X  }
--- 671,677 ----
X  	ClearScreen ();
X  #endif
X  	mail_setup ();
! 	if (resized || sig == 0) {
X  		redraw_page (glob_respnum, glob_page_group);
X  	}	
X  }
***************
*** 642,648 ****
X  	ClearScreen ();
X  #endif
X  	mail_setup ();
! 	if (resized) {
X  		show_thread_page ();
X  	}	
X  }
--- 692,698 ----
X  	ClearScreen ();
X  #endif
X  	mail_setup ();
! 	if (resized || sig == 0) {
X  		show_thread_page ();
X  	}	
X  }
diff -rcs ../1.14/spooldir.c ./spooldir.c
*** ../1.14/spooldir.c	Tue Aug 11 21:23:24 1992
--- ./spooldir.c	Mon Jul 20 12:51:09 1992
***************
*** 3,9 ****
X   *  Module    : spooldir.c
X   *  Author    : I.Lea & Tom Theel
X   *  Created   : 08-05-92
!  *  Updated   : 20-06-92
X   *  Notes     : Changes spooldir to read news from (ie. news, nntp, cdrom)
X   *  Copyright : (c) Copyright 1991-92 by Iain Lea & Tom Theel
X   *              You may  freely  copy or  redistribute  this software,
--- 3,9 ----
X   *  Module    : spooldir.c
X   *  Author    : I.Lea & Tom Theel
X   *  Created   : 08-05-92
!  *  Updated   : 30-06-92
X   *  Notes     : Changes spooldir to read news from (ie. news, nntp, cdrom)
X   *  Copyright : (c) Copyright 1991-92 by Iain Lea & Tom Theel
X   *              You may  freely  copy or  redistribute  this software,
***************
*** 14,34 ****
X  
X  #include	"tin.h"
X  
- #define NUM_SPOOLDIRS	50
- 
X  int cur_spoolnum = 0;
X  int first_spooldir_on_screen;
X  int last_spooldir_on_screen;
- int num_spooldirs = 0;
X  int spool_top = 0;
X  
X  /*
-  * needs to be dynamic but no time 
-  */
- struct spooldir_t spooldirs[NUM_SPOOLDIRS];
- 
- 
- /*
X   * Change spooldir via menu of available choices
X   */
X  
--- 14,25 ----
***************
*** 40,54 ****
X  	int n;
X  	int scroll_lines;
X  	
! 	spool_top = num_spooldirs;
X  
X  	if (! xspooldir_supported) {
! 		info_message ("Multiple spooldirs are not supported");
X  		return FALSE;
X  	}
X  
X  	if (! spool_top) {
! 		info_message ("No spooldirs");
X  		return FALSE;
X  	}
X  
--- 31,45 ----
X  	int n;
X  	int scroll_lines;
X  	
! 	spool_top = num_spooldir;
X  
X  	if (! xspooldir_supported) {
! 		info_message (txt_spooldirs_not_supported);
X  		return FALSE;
X  	}
X  
X  	if (! spool_top) {
! 		info_message (txt_no_spooldirs);
X  		return FALSE;
X  	}
X  
***************
*** 300,306 ****
X  
X  			case 'q':	/* quit */
X  				return TRUE;
- 				break;
X  				
X  			case 'Q':	/* quit */
X  				write_rcfile ();
--- 291,296 ----
***************
*** 337,343 ****
X  	CleartoEOLN ();
X  #endif
X  
! 	sprintf (buf, txt_spooldir_selection, num_spooldirs);
X  	show_title (buf);
X  
X  #ifndef USE_CLEARSCREEN
--- 327,333 ----
X  	CleartoEOLN ();
X  #endif
X  
! 	sprintf (buf, txt_spooldir_selection, num_spooldir);
X  	show_title (buf);
X  
X  #ifndef USE_CLEARSCREEN
***************
*** 462,476 ****
X  	char *ptr;
X  	int i, state;
X  
! #if 0
! 	spooldirs = (struct spooldir_t *) 0;
! #else
! 	for (i = 0 ; i < NUM_SPOOLDIRS ; i++) {
X  		spooldirs[i].state = 0;
X  		spooldirs[i].name = (char *) 0;
X  	}
- #endif
X  
X  	xspooldir_supported = FALSE;
X  	
X  	if (! read_news_via_nntp) {
--- 452,464 ----
X  	char *ptr;
X  	int i, state;
X  
! 	for (i = 0 ; i < max_spooldir ; i++) {
X  		spooldirs[i].state = 0;
X  		spooldirs[i].name = (char *) 0;
+ 		spooldirs[i].comment = (char *) 0;
X  	}
X  
+ 	num_spooldir = 0;
X  	xspooldir_supported = FALSE;
X  	
X  	if (! read_news_via_nntp) {
***************
*** 483,490 ****
X  		xspooldir_supported = FALSE;
X  		if (debug > 0) {
X  			fprintf (stderr, "%s", line);
! 			fprintf (stderr, "Server does not appear to support the spooldir command\n");
! 			fprintf (stderr, "Reconfigure the news reader or the server & try again.\n");
X  		}
X  		return (xspooldir_supported);
X  	}
--- 471,478 ----
X  		xspooldir_supported = FALSE;
X  		if (debug > 0) {
X  			fprintf (stderr, "%s", line);
! 			fprintf (stderr, txt_spooldir_server_error_1);
! 			fprintf (stderr, txt_spooldir_server_error_2);
X  		}
X  		return (xspooldir_supported);
X  	}
***************
*** 514,540 ****
X  				*ptr = '\0';				
X  			}
X  
! /*				
! 			spooldirs = (struct spooldir_t *) my_realloc ((char *) spooldirs,
! 				(unsigned) sizeof (struct spooldir_t) * num_spooldirs + 1);
! 			if (spooldirs != (struct spooldir_t *) 0) {
! 				spooldirs[num_spooldirs].state = state;
! 				spooldirs[num_spooldirs].name = str_dup (name);
! 				spooldirs[num_spooldirs].comment = str_dup (comment);
! 				num_spooldirs++;
! 			}	
! */				
X  
! 			spooldirs[num_spooldirs].state = state;
! 			spooldirs[num_spooldirs].name = str_dup (name);
! 			spooldirs[num_spooldirs].comment = str_dup (comment);
X  
X  			if (debug == 1) {
! 				printf ("ALIAS=[%s] COMMENT=[%s]\n", 
! 					spooldirs[num_spooldirs].name,
! 					spooldirs[num_spooldirs].comment);
X  			}
! 			num_spooldirs++;
X  		}
X  	} while (!((line[0] == '.') && ((line[1] == '\0') || (line[1] == '\r'))));
X  
--- 502,522 ----
X  				*ptr = '\0';				
X  			}
X  
! 			if (num_spooldir > max_spooldir) {
! 				expand_spooldirs ();
! 			}
X  
! 			spooldirs[num_spooldir].state = state;
! 			spooldirs[num_spooldir].name = str_dup (name);
! 			spooldirs[num_spooldir].comment = str_dup (comment);
X  
X  			if (debug == 1) {
! 				printf ("STATE=[%d] ALIAS=[%s] COMMENT=[%s]\n", 
! 					spooldirs[num_spooldir].state,
! 					spooldirs[num_spooldir].name,
! 					spooldirs[num_spooldir].comment);
X  			}
! 			num_spooldir++;
X  		}
X  	} while (!((line[0] == '.') && ((line[1] == '\0') || (line[1] == '\r'))));
X  
***************
*** 549,556 ****
--- 531,540 ----
X  void get_spooldir ()
X  {
X  #ifdef NNTP_ABLE
+ #if 0
X  	char line[NNTP_STRLEN];
X  	char alias[32];
+ #endif	
X  	char default_alias[32];
X  	int i, set_alias = FALSE;
X  	
***************
*** 585,591 ****
X  			}
X  		}
X  		if (! set_alias) {
! 			error_message ("%s: Cannot change to valid spooldir. Exiting...", progname);
X  			exit (1);			
X  		}
X  	}
--- 569,575 ----
X  			}
X  		}
X  		if (! set_alias) {
! 			error_message (txt_cannot_change_spooldir, progname);
X  			exit (1);			
X  		}
X  	}
***************
*** 625,633 ****
X  	int respcode;
X  
X  	if (cmd_line) {
! 		sprintf (line, "Changing spooldir to %s...\n", name);
X  	} else {
! 		sprintf (line, "Changing spooldir to %s...", name);
X  	}	
X  	wait_message (line);
X  
--- 609,617 ----
X  	int respcode;
X  
X  	if (cmd_line) {
! 		sprintf (line, "%s %s...\n", txt_changing_sppoldir_to, name);
X  	} else {
! 		sprintf (line, "%s %s...", txt_changing_sppoldir_to, name);
X  	}	
X  	wait_message (line);
X  
***************
*** 642,654 ****
X  			my_strncpy (spooldir_alias, name, sizeof (spooldir_alias));
X  			set_tindir ();
X  			return TRUE;
- 			break;
X  		case OK_SPNOCHANGE:	/* Still using same spooldir */
X  			break;
X  		default:
X  			error_message ("%s", nntp_respcode (respcode));
X  			clear_message ();
! 			return FALSE;
! 			break;		
X  	}
X  }
--- 626,637 ----
X  			my_strncpy (spooldir_alias, name, sizeof (spooldir_alias));
X  			set_tindir ();
X  			return TRUE;
X  		case OK_SPNOCHANGE:	/* Still using same spooldir */
X  			break;
X  		default:
X  			error_message ("%s", nntp_respcode (respcode));
X  			clear_message ();
! 			break;
X  	}
+ 	return FALSE;
X  }
diff -rcs ../1.14/thread.c ./thread.c
*** ../1.14/thread.c	Tue Aug 11 21:23:25 1992
--- ./thread.c	Fri Aug  7 19:10:52 1992
***************
*** 3,9 ****
X   *  Module    : thread.c
X   *  Author    : I.Lea
X   *  Created   : 01-04-91
!  *  Updated   : 20-06-92
X   *  Notes     :
X   *  Copyright : (c) Copyright 1991-92 by Iain Lea
X   *              You may  freely  copy or  redistribute  this software,
--- 3,9 ----
X   *  Module    : thread.c
X   *  Author    : I.Lea
X   *  Created   : 01-04-91
!  *  Updated   : 24-07-92
X   *  Notes     :
X   *  Copyright : (c) Copyright 1991-92 by Iain Lea
X   *              You may  freely  copy or  redistribute  this software,
***************
*** 35,50 ****
X  	int i;
X  {
X  #ifndef INDEX_DAEMON
! 	int j;
X  	char mark;
X  	char new_resps[8];
X  	char from[LEN];
! 
X  	int len_from;
X  	int len_subj = 0;
X  	int off_subj = 0;
X  	int off_both = 0;
- 	char *spaces = "XXX";
X  
X  	if (! draw_arrow_mark) {
X  		off_subj = 2;
--- 35,50 ----
X  	int i;
X  {
X  #ifndef INDEX_DAEMON
! 	extern int cur_groupnum;
X  	char mark;
X  	char new_resps[8];
X  	char from[LEN];
! 	char *spaces = "XXX";
! 	int j;
X  	int len_from;
X  	int len_subj = 0;
X  	int off_subj = 0;
X  	int off_both = 0;
X  
X  	if (! draw_arrow_mark) {
X  		off_subj = 2;
***************
*** 72,80 ****
X  		sprintf (new_resps, "%3d", arts[i].tagged);
X  	} else {
X  		if (arts[i].unread == ART_UNREAD) {
! 			mark = (arts[i].hot ? HOT_ART_MARK : UNREAD_ART_MARK);
X  		} else if (arts[i].unread == ART_WILL_RETURN) {
! 			mark =  RETURN_ART_MARK;
X  		} else {
X  			mark = READ_ART_MARK;
X  		}
--- 72,80 ----
X  		sprintf (new_resps, "%3d", arts[i].tagged);
X  	} else {
X  		if (arts[i].unread == ART_UNREAD) {
! 			mark = (arts[i].hot ? hot_art_mark : unread_art_mark);
X  		} else if (arts[i].unread == ART_WILL_RETURN) {
! 			mark =  return_art_mark;
X  		} else {
X  			mark = READ_ART_MARK;
X  		}
***************
*** 82,89 ****
X  	}
X  	
X  	from[0] = '\0';
! 	if (threaded_on_subject || show_author != SHOW_FROM_NONE)
X  		get_author (TRUE, i, from);
X  
X  	sprintf (screen[j].col, "  %4d%3s  %-*.*s%s%-*.*s",
X  		 l, new_resps, len_subj, len_subj, arts[i].subject, 
--- 82,90 ----
X  	}
X  	
X  	from[0] = '\0';
! 	if (threaded_on_subject || show_author != SHOW_FROM_NONE) {
X  		get_author (TRUE, i, from);
+ 	}	
X  
X  	sprintf (screen[j].col, "  %4d%3s  %-*.*s%s%-*.*s",
X  		 l, new_resps, len_subj, len_subj, arts[i].subject, 
***************
*** 121,127 ****
X  	/* it is somewhat less efficient to go back and redo that art mark
X  	 * if hot, but it is quite readable as to what is happening 
X  	 */
! 	if (screen[j].col[k] == HOT_ART_MARK) {
X  		MoveCursor (INDEX2LNUM(i), k);
X  		ToggleInverse ();
X  		fputc (screen[j].col[k], stdout);
--- 122,128 ----
X  	/* it is somewhat less efficient to go back and redo that art mark
X  	 * if hot, but it is quite readable as to what is happening 
X  	 */
! 	if (screen[j].col[k] == hot_art_mark) {
X  		MoveCursor (INDEX2LNUM(i), k);
X  		ToggleInverse ();
X  		fputc (screen[j].col[k], stdout);
***************
*** 168,174 ****
X  
X  	thread_index_point = top_thread;
X  	if (space_mode) {
! 		if (i = new_responses (thread_basenote)) {
X  			for (n=0, i = base[thread_basenote]; i >= 0 ;
X  				 i = arts[i].thread, n++) {
X  				if (arts[i].unread == ART_UNREAD) {
--- 169,176 ----
X  
X  	thread_index_point = top_thread;
X  	if (space_mode) {
! 		i = new_responses (thread_basenote);
! 		if (i) {
X  			for (n=0, i = base[thread_basenote]; i >= 0 ;
X  				 i = arts[i].thread, n++) {
X  				if (arts[i].unread == ART_UNREAD) {
***************
*** 446,452 ****
X  					arts[i].unread = ART_READ;
X  				}
X  				goto thread_done;
- 				break;
X  
X  			case 'd':	/* toggle display of subject & subj/author */
X  				if (! threaded_on_subject) {
--- 448,453 ----
***************
*** 500,508 ****
--- 501,519 ----
X  			case 'Z':	/* mark thread as unread */
X  				n = choose_response (thread_basenote, thread_index_point);
X  				if (ch == 'z') {
+ 					if (arts[n].unread == ART_READ) {
+ 						if (arts[n].hot) {
+ 							num_of_hot_arts++;
+ 						}
+ 					}
X  					arts[n].unread = ART_UNREAD;
X  				} else {
X  					for (i = (int) base[thread_basenote] ; i != -1; i = arts[i].thread) {
+ 						if (arts[n].unread == ART_READ) {
+ 							if (arts[n].hot) {
+ 								num_of_hot_arts++;
+ 							}
+ 						}
X  						arts[i].unread = ART_UNREAD;
X  					}
X  				}
***************
*** 571,583 ****
X  #ifndef INDEX_DAEMON
X  
X  	extern int index_point;
- 	char new_resps[8];
- 	char from[LEN];
X  	int i, j;
- 	int len_from;
- 	int len_subj = 0;
- 	int off_subj = 0;
- 	int off_both = 0;
X  	static int index = 0;
X  
X  	set_signals_thread ();
--- 582,588 ----
***************
*** 629,651 ****
X  	index = choose_response (thread_basenote, first_thread_on_screen);
X  	assert(first_thread_on_screen != 0 || index == thread_respnum);
X  
- 	if (! draw_arrow_mark) {
- 		off_subj = 2;
- 		off_both = 5;
- 	}	
- 
- 	if (threaded_on_subject) {
- 		len_from = max_subj+max_from+off_both;
- 	} else {
- 		if (show_author != SHOW_FROM_NONE) {
- 			len_from = max_from;
- 			len_subj = max_subj+off_subj;
- 		} else {
- 			len_from = 0;
- 			len_subj = max_from+max_subj+off_subj;
- 		}
- 	}	
- 
X  	for (j=0, i = first_thread_on_screen; j < NOTESLINES && i < last_thread_on_screen; i++, j++) {
X  		bld_tline (i, index);
X  		draw_tline (i, TRUE);
--- 634,639 ----
***************
*** 759,765 ****
X  	int sum = 0;
X  
X  	for (i = (int) base[thread]; i >= 0; i = arts[i].thread) {
! 		if (arts[i].unread) {
X  			sum++;
X  		}
X  	}
--- 747,753 ----
X  	int sum = 0;
X  
X  	for (i = (int) base[thread]; i >= 0; i = arts[i].thread) {
! 		if (arts[i].unread != ART_READ) {
X  			sum++;
X  		}
X  	}
***************
*** 885,895 ****
X  
X  
X  	if (sbuf->hot_unread)
! 		sbuf->art_mark = HOT_ART_MARK;
X  	else if (sbuf->unread)
! 		sbuf->art_mark = UNREAD_ART_MARK;
X  	else if (sbuf->seen)
! 		sbuf->art_mark = RETURN_ART_MARK;
X  	else
X  		sbuf->art_mark = READ_ART_MARK;
X  
--- 873,883 ----
X  
X  
X  	if (sbuf->hot_unread)
! 		sbuf->art_mark = hot_art_mark;
X  	else if (sbuf->unread)
! 		sbuf->art_mark = unread_art_mark;
X  	else if (sbuf->seen)
! 		sbuf->art_mark = return_art_mark;
X  	else
X  		sbuf->art_mark = READ_ART_MARK;
X  
***************
*** 907,920 ****
X  {
X  	int i;
X  
! 	if (arts[n].thread >= 0)
X  		return arts[n].thread;
! 
X  	i = which_thread (n) + 1;
X  
! 	if (i >= top_base)
X  		return -1;
! 
X  	return (int) base[i];
X  }
X  
--- 895,910 ----
X  {
X  	int i;
X  
! 	if (arts[n].thread >= 0) {
X  		return arts[n].thread;
! 	}
! 	
X  	i = which_thread (n) + 1;
X  
! 	if (i >= top_base) {
X  		return -1;
! 	}
! 	
X  	return (int) base[i];
X  }
X  
***************
*** 979,990 ****
X  }
X  
X  /*
!  *  Find the next unread response in this group 
X   */
X  
X  int next_unread (n)
X  	int n;
X  {
X  	while (n >= 0) {
X  		if (arts[n].unread == ART_UNREAD) {
X  			return n;
--- 969,983 ----
X  }
X  
X  /*
!  *  Find the next unread response in this group. If no response is found
!  *  from current point to the end restart from beginning of articles.
X   */
X  
X  int next_unread (n)
X  	int n;
X  {
+ 	int cur_base_art = n;
+ 	
X  	while (n >= 0) {
X  		if (arts[n].unread == ART_UNREAD) {
X  			return n;
***************
*** 992,1000 ****
X  		n = next_response (n);
X  	}
X  
X  	return -1;
X  }
- 
X  
X  /*
X   *  Find the previous unread response in this thread
--- 985,1000 ----
X  		n = next_response (n);
X  	}
X  
+ 	n = base[0];
+ 	while (n != cur_base_art) {
+ 		if (arts[n].unread == ART_UNREAD) {
+ 			return n;
+ 		}
+ 		n = next_response (n);
+ 	}
+ 	
X  	return -1;
X  }
X  
X  /*
X   *  Find the previous unread response in this thread
Only in .: tin-1.15.diff
diff -rcs ../1.14/tin.1 ./tin.1
*** ../1.14/tin.1	Tue Aug 11 21:22:58 1992
--- ./tin.1	Tue Aug 11 20:52:10 1992
***************
*** 6,12 ****
X  .if t .ll 6.85i
X  .if n .ll 7.2i
X  .if \n(mo=1 .ds mo January
! .if \n(mo=2 .ds mo Febraury
X  .if \n(mo=3 .ds mo March
X  .if \n(mo=4 .ds mo April
X  .if \n(mo=5 .ds mo May
--- 6,12 ----
X  .if t .ll 6.85i
X  .if n .ll 7.2i
X  .if \n(mo=1 .ds mo January
! .if \n(mo=2 .ds mo February
X  .if \n(mo=3 .ds mo March
X  .if \n(mo=4 .ds mo April
X  .if \n(mo=5 .ds mo May
***************
*** 17,23 ****
X  .if \n(mo=10 .ds mo October
X  .if \n(mo=11 .ds mo November
X  .if \n(mo=12 .ds mo December
! .TH TIN 1 "Version 1.1 PL4" "" "LOCAL"
SHAR_EOF
true || echo 'restore of tin-1.15.patch failed'
fi
echo 'End of tin-1.15 part 6'
echo 'File tin-1.15.patch is continued in part 7'
echo 7 > _shar_seq_.tmp
exit 0

--
NAME   Iain Lea 
EMAIL  iain%anl433.uucp@Germany.EU.net
SNAIL  Siemens AG, ANL A433SZ, Gruendlacher Str. 248, 8510 Fuerth, Germany.
PHONE  +49-911-3089-407 (work) +49-911-331963 (home) +49-911-3089-290 (FAX)  
exit 0 # Just in case...
