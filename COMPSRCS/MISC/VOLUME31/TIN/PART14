Newsgroups: comp.sources.misc
From: iain%anl433.uucp@Germany.EU.net (Iain Lea)
Subject:  v31i014:  tin - threaded full screen newsreader v1.1 PL4, Part14/15
Message-ID: <1992Jul7.182101.8177@sparky.imd.sterling.com>
X-Md4-Signature: f0a2c1fdbf89b4e5a840df7cf7412fff
Date: Tue, 7 Jul 1992 18:21:01 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: iain%anl433.uucp@Germany.EU.net (Iain Lea)
Posting-number: Volume 31, Issue 14
Archive-name: tin/part14
Environment: BSD, SCO, ISC, SUNOS, SYSVR3, SYSVR4, ULTRIX, XENIX
Supersedes: tin: Volume 30, Issue 1-14

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  CHANGES curses.c hashstr.c inews.c memory.c nntplib.h
#   search.c wildmat.c
# Wrapped by kent@sparky on Mon Jun 29 23:35:15 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 14 (of 15)."'
if test -f 'CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CHANGES'\"
else
  echo shar: Extracting \"'CHANGES'\" \(8432 characters\)
  sed "s/^X//" >'CHANGES' <<'END_OF_FILE'
XCHANGES tin v1.1 PL3 -> tin 1.1 PL4
X-----------------------------------
X
X1)  Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    ADD. Makefile - added entry for Stratus FTX machines.
X
X2)  Hakan Lennestal (hakanl@lulea.telesoft.se)
X    BUG. Certain setuid() & setgid() no longer needed & should be removed.
X    FIX. Applied supplied patch.
X
X3)  Hakan Lennestal (hakanl@lulea.telesoft.se)
X    BUG. Follows to articles should be checked that the header is seperated 
X         from the body by a blank line.
X    FIX. Applied supplied patch.
X
X4)  Ken Taylor (ken@cujo.curtin.edu.au)
X    BUG. Moving up a line in a group with no arts in group causes SIGSEGV(11).
X    FIX. group.c - added check to see if any articles before moving up a line.
X    
X5)  Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    ADD.  post.c - added setuid info to bug report entry sent with 'B' command.
X
X6)  Doug Sewell (doug@cc.ysu.edu)
X    BUG. #include file unistd.h does not exist on NeXT machines.
X    FIX. tin.h - applied supplied patch.
X
X7)  Doug Sewell (doug@cc.ysu.edu)
X    BUG. Every time tin starts via NNTP 5 unknown command errors are written
X         to the NNTP logfile.
X    FIX. open.c - added #ifdef NO_NNTP_EXTS to stop tin asking NNTP server
X         which extensions it supports so that it can auto configure itself.
X         This addition is just a nicety - it is not really necessary.
X
X8)  Doug Sewell (doug@cc.ysu.edu)
X    BUG. Makefile does not work correctly on NeXT machines.
X    FIX. tin.h - applied supplied patch.
X
X9)  Wolfgang Prediger (wp@orion.erls01.siemens.de)
X    BUG. Does not resize in xterm under SVR4.
X    FIX. tin.h - applied supplied patch.
X
X10) Paul Vickers (Paul.Vickers@barclays.co.uk)
X    BUG. IBM RS6000 needs #include file netdb.h 
X    FIX. inews.c - applied supplied patch.
X
X11) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. -c catchup option does not work when reading index files via NNTP.
X    FIX. main.c - added condition to check if -c flag is specified.
X
X12) Tom Hite (thite@micrografix.com)
X    BUG. Wrong logic is used for freeing active attributes in memory.c
X    FIX. memory.c - applied supplied patch.
X
X13) Sean Brady (brady@sed.stel.com)
X    BUG. Hitting End/Home key causes SIGSEGV(11) at group index level.
X    FIX. group.c - added checks to see if any articles are displayed.
X
X14) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. SVR4 does not compile because SIGTYPE is wrong.
X    FIX. tin.h - changed SIGTYPE to void if SVR4 defined. 
X
X15) Jim Morris (jegm@cody.esd.sgi.com)
X    ADD. Makefile - added support for SGI Irix machines.
X
X16) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. Stratus FTX entry duplicates SVR4 entry.
X    FIX. Makefile - deleted stratus entry because its the same as the SVR4 entry.
X
X17) Greg Woods (woods%robohack.uucp@uunet.UU.NET)
X    BUG. Man page is not correctly formatted.
X    FIX. tin.1 - applied supllied patch. 
X
X18) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. Compile options are spread all over Makefile. Should be in one place.
X    FIX. Makefile - made configuration easier.
X
X19) Dean Schrimpf (ds11129@medtronic.com)
X    BUG. Multiple copies of tind index daemon can be running simultaneously.
X    FIX. init.c - added check to see if tind index daemon is already running.
X
X20) Jeb Palmer (jpalmer@sierra.com)
X    BUG. When posting an article with vi as editor vi always complains that
X         the file is not long enough to position the cursor at line n.
X    FIX. post.c - applied supplied patch.
X
X21) Paul Bauwens (paul@pphbau.hobby.nl)
X    BUG. Indexing of group sometimes hangs requiring tin to be killed. 
X    FIX. art.c - applied supplied patch.
X
X22) James Nugen (jcn@jcnpc.uucp)
X    BUG. Group select screen is redrawn double spaced when yanking in groups
X         with long filenames.
X    FIX. select.c - applied supplied patch.
X
X23) Chris Davies (chris@visionware.co.uk)
X    BUG. Subdomains should be hidable. If NNTP_INEWS_DOMAIN is ".vision.co.uk"
X         then use "chris@host.vision.co.uk", but if not with leading '.' hid
X         local hostname ie. "chris@vision.co.uk"
X    FIX. inews.c - applied supplied patch.
X
X24) Tom Parry (parry@yoyo.cc.monash.edu.au)
X    BUG. screen does not create utmp entries which causes username not to be 
X         found.
X    FIX. init.c - applied supplied patch.
X
X25) Alex Pakter (alex@brt.com)
X    BUG. Mismatched protypes cause compile warning on ?? machine.
X    FIX. prompt.c - changed char parameter to int in prompt_num(). 
X
X26) Jim Robinson (robinson@mdivax1.mdd.comm.mot.com)
X    FIXES. art.c - parse_headers() bug whereby if errno had previous 
X           value of EINTR and article was less than sizeof(buf) bytes
X           would get infinite loop.
X           group.c - group_page() removed unnecessary make_threads() 
X           in 'r' command resulting in substantial toggle speed up in
X           large groups.
X    ENHANCEMENTS curses.c - added ToggleInverse() routine.
X           kill.c - added auto_select_articles() to perform auto selection.
X           NOTE: this routine is presently a kludge, but exists to make 
X           future changes a touch easier
X           group.c thread.c - Added coded to highlight selected (hot) arts. 
X
X           Added a bunch of commands to manipulate selected articles. 
X           Note that the characters  associated with each new command were
X           chosen to correspond to a trn or nn equivalent command.
X
X27) Bill Poitras (bill@polygen.com)
X    BUG. Unthreading groups at startup causes SIGSEGV error.
X    FIX. active.c - check that array index variable is not less than 0.
X
X28) Hakan Lennestal (hakanl@lulea.telesoft.se)
X    BUG. Certain systems use the setreuid() call to set real & effective uid.
X    FIX. misc.c INSTALL - Applied supplied patch.
X
X29) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. Major outcry from users about 'i' command being removed at group level
X    FIX. group.c - readded the 'i' command. It *WILL* be removed *FOREVER* in 
X         a future version.        
X
X30) Callum Gibson (callum@bain3.bain.oz.au)
X    BUG. Does not compile on Pyramid machines.
X    FIX. tin.h - applied supplied patch.
X
X31) Tony Travis (ajt@doc.ic.ac.uk)
X    BUG. Sequent Dynix requires -lseq lib because of getopt().
X    FIX. Makefile - added dynix make entry to Makefile.
X
X32) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. Last group in chain is not accessed because of wrong test logic.
X    FIX. active.c - changed code so that last group in chain is marked.
X
X33) Dean Schrimpf (ds11129@medtronic.com)
X    BUG. Cross device renaming fails and trashes .newsrc file.
X    FIX. misc.c - changed rename_file() to handle cross-device filenames.
X
X34) Marty Leisner (leisner@eso.mc.xerox.com)
X    BUG. Add address is not added to bug address if on internal network.
X    FIX. post.c - added code to add add_addr varaible contents to bug address.
X
X35) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. Saving, mailing etc. an expired article within a thread caused 
X         SIGSEGV error.
X    FIX. feed.c - check if article is available before accessing it.
X
X36) Hakan Lennestal (hakanl@lulea.telesoft.se)
X    BUG. Child processes are not waited for and therefore cause zombies.
X    FIX. Applied supplied patch.
X
X37) Daniel Hermans (dmh@superb.mel.cocam.oz.au)
X    BUG. Arrow keys on HP type terminals don't work.
X    FIX. curses.c - Applied supplied patch.
X
X38) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    ADD. kill - added kill/hot file of people that I find interesting
X         (ie. Larry Wall , Chris Torek etc.) so that the auto-selection
X         of interesting people can be shown automatically to new users.
X         The file requires installing in ~/.tin
X
X39) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. Temp index files are not deleted from /tmp if a crash occurs.
X    FIX. signal.c - delete temp index files from the signal handler.
X
X40) Iain Lea (iain%anl433.uucp@Germany.EU.net)
X    BUG. Default mailer for DG Aviion is wrong (/usr/ucb/Mail).
X    FIX. tin.h - changed default mailer to /bin/mail
X
X41) John Scmitz (schmitz@scd.hp.com)
X    BUG. 'sigtype_t (*susp)() = (sigtype_t *) 0;' causes compiler problem 
X         under HP-UX 7.0
X    FIX. kill.c misc.c rcfile.c - set default value after variable declaration.
X
X42) David Ross (dave@naskiska.ucs.ualberta.ca)
X    BUG. Vi users are used to Ctrl-F & Ctrl-B to page forwards & backwards. 
X    FIX. Added key code to recognize Ctrl-F & Ctrl-B at all levels.
X
END_OF_FILE
  if test 8432 -ne `wc -c <'CHANGES'`; then
    echo shar: \"'CHANGES'\" unpacked with wrong size!
  fi
  # end of 'CHANGES'
fi
if test -f 'curses.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'curses.c'\"
else
  echo shar: Extracting \"'curses.c'\" \(8719 characters\)
  sed "s/^X//" >'curses.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : curses.c
X *  Author    : D.Taylor & I.Lea
X *  Created   : ??-??-86
X *  Updated   : 20-06-92
X *  Notes     : This is a screen management library borrowed with permission
X *              from the Elm mail system (a great mailer--I highly recommend
X *              it!).This library was hacked to provide what tin needs.
X *  Copyright : Copyright (c) 1986-92 Dave Taylor & Iain Lea
X *              The Elm Mail System  -  $Revision: 2.1 $   $State: Exp $
X */
X
X#include <stdio.h>
X#include <curses.h>
X#include <sys/errno.h>
X
X#define DEFAULT_LINES_ON_TERMINAL	24
X#define DEFAULT_COLUMNS_ON_TERMINAL	80
X
Xint LINES = 23;
Xint COLS  = 80;
Xint inverse_okay = TRUE;
Xstatic int _inraw = FALSE;                  /* are we IN rawmode?    */
X
X
X#ifndef INDEX_DAEMON
X
X#define		BACKSPACE	'\b'
X#define		VERY_LONG_STRING	2500
X
X#ifdef BSD 
X#	ifndef BSD4_1
X#		include <sgtty.h>
X#	else
X#		include <termio.h>
X#	endif
X#else
X#	ifndef SYSV
X#		ifndef MINIX
X#			ifdef sinix
X#				include <termios.h>
X#			else
X#				include <termio.h>
X#			endif
X#		else
X#			include <sgtty.h>
X#		endif
X#	endif
X#endif
X
X#define TTYIN	0
X
X#ifdef SHORTNAMES
X# define _clearinverse	_clrinv
X# define _cleartoeoln	_clrtoeoln
X# define _cleartoeos	_clr2eos
X#endif
X
X#if defined(BSD) || defined(MINIX)
X#	define TCGETA	TIOCGETP
X#	define TCSETAW	TIOCSETP
X
Xstruct sgttyb _raw_tty,
X	      _original_tty;
X#else
X#	ifdef sinix
X#		ifndef TCGETA
X#			define TCGETA	STCGETA
X#		endif
X#		ifndef TCSETA
X#			define TCSETAW	STCSETAW
X#		endif
Xstruct termios _raw_tty, 
X              _original_tty;
X#	else
Xstruct termio _raw_tty, 
X              _original_tty;
X#	endif
X#endif
X
Xstatic char *_clearscreen, *_moveto, *_cleartoeoln, *_cleartoeos,
X			*_setinverse, *_clearinverse, *_setunderline, *_clearunderline,
X			*_terminalinit, *_terminalend, *_keypadlocal, *_keypadxmit;
X
Xstatic int _lines,_columns;
X
Xstatic char _terminal[1024];              /* Storage for terminal entry */
Xstatic char _capabilities[1024];           /* String for cursor motion */
X
Xstatic char *ptr = _capabilities;	/* for buffering         */
X
Xstatic int in_inverse;			/* 1 when in inverse, 0 otherwise */
X
Xint	outchar ();			/* char output for tputs */
Xextern char	*tgetstr ();		/* Get termcap capability */
Xextern char	*tgoto ();		/* and the goto stuff    */
X
X#endif /* INDEX_DAEMON */
X
X#include "tin.h"
X
X
Xint InitScreen ()
X{
X#ifndef INDEX_DAEMON
X
X	extern int tgetent();      /* get termcap entry */
X	char termname[40], *p;
X	
X	if ((p = (char *) getenv ("TERM")) == NULL) {
X		fprintf (stderr, "%s: TERM variable must be set to use screen capabilities\n", progname);
X		return (FALSE);
X	}
X	if (strcpy (termname, p) == NULL) {
X		fprintf (stderr,"%s: Can't get TERM variable\n", progname);
X		return (FALSE);
X	}
X	if (tgetent (_terminal, termname) != 1) {
X		fprintf (stderr,"%s: Can't get entry for TERM\n", progname);
X		return (FALSE);
X	}
X
X	/* load in all those pesky values */
X	_clearscreen    = tgetstr ("cl", &ptr);
X	_moveto         = tgetstr ("cm", &ptr);
X	_cleartoeoln    = tgetstr ("ce", &ptr);
X	_cleartoeos     = tgetstr ("cd", &ptr);
X	_lines          = tgetnum ("li");
X	_columns        = tgetnum ("co");
X	_setinverse     = tgetstr ("so", &ptr);
X	_clearinverse   = tgetstr ("se", &ptr);
X	_setunderline   = tgetstr ("us", &ptr);
X	_clearunderline = tgetstr ("ue", &ptr);
X	_terminalinit   = tgetstr ("ti", &ptr);
X	_terminalend    = tgetstr ("te", &ptr);
X	_keypadlocal    = tgetstr ("ke", &ptr);
X	_keypadxmit     = tgetstr ("ks", &ptr);
X
X	InitWin ();
X
X	if (!_clearscreen) {
X		fprintf (stderr,
X			"%s: Terminal must have clearscreen (cl) capability\n",progname);
X		return (FALSE);
X	}
X	if (!_moveto) {
X		fprintf (stderr,
X			"%s: Terminal must have cursor motion (cm)\n", progname);
X		return (FALSE);
X	}
X	if (!_cleartoeoln) {
X		fprintf (stderr,
X			"%s: Terminal must have clear to end-of-line (ce)\n", progname);
X		return (FALSE);
X	}
X	if (!_cleartoeos) {
X		fprintf (stderr,
X			"%s: Terminal must have clear to end-of-screen (cd)\n", progname);
X		return (FALSE);
X	}
X	if (_lines == -1)
X		_lines = DEFAULT_LINES_ON_TERMINAL;
X	if (_columns == -1)
X		_columns = DEFAULT_COLUMNS_ON_TERMINAL;
X	/* kludge to workaround no inverse */
X	if (_setinverse == 0) {
X		_setinverse = _setunderline;
X		_clearinverse = _clearunderline;
X		if (_setinverse == 0)
X			draw_arrow_mark = 1;
X	}
X	return (TRUE);
X
X#else
X
X	return (FALSE);
X
X#endif /* INDEX_DAEMON */
X}
X
X/*
X *  returns the number of lines and columns on the display.
X */
X 
Xvoid ScreenSize (num_lines, num_columns)
X	int *num_lines, *num_columns;
X{
X#ifndef INDEX_DAEMON
X
X	if (_lines == 0) _lines = DEFAULT_LINES_ON_TERMINAL;
X	if (_columns == 0) _columns = DEFAULT_COLUMNS_ON_TERMINAL;
X
X	*num_lines = _lines - 1;		/* assume index from zero*/
X	*num_columns = _columns;		/* assume index from one */
X
X#endif /* INDEX_DAEMON */
X}
X
Xvoid InitWin ()
X{
X#ifndef INDEX_DAEMON
X
X	if (_terminalinit) {
X		tputs (_terminalinit, 1, outchar);
X		fflush (stdout);
X	}	
X	set_keypad_on ();
X
X#endif /* INDEX_DAEMON */
X}
X
Xvoid EndWin ()
X{
X#ifndef INDEX_DAEMON
X
X	if (_terminalend) {
X		tputs (_terminalend, 1, outchar);
X		fflush (stdout);
X	}
X	set_keypad_off ();
X	
X	
X#endif /* INDEX_DAEMON */
X}
X
Xvoid set_keypad_on ()
X{
X#ifndef INDEX_DAEMON
X/*
X 	if (_keypadxmit) {
X		tputs (_keypadxmit, 1, outchar);
X		fflush (stdout);
X	}
X*/
X#endif /* INDEX_DAEMON */
X}
X
Xvoid set_keypad_off ()
X{
X#ifndef INDEX_DAEMON
X/*
X	if (_keypadlocal) {
X		tputs (_keypadlocal, 1, outchar);
X		fflush (stdout);
X	}
X*/
X#endif /* INDEX_DAEMON */
X}
X
X/*
X *  clear the screen: returns -1 if not capable
X */
X
Xvoid ClearScreen ()
X{
X#ifndef INDEX_DAEMON
X
X	tputs (_clearscreen, 1, outchar);
X	fflush (stdout);      /* clear the output buffer */
X
X#endif /* INDEX_DAEMON */
X}
X
X/*
X *  move cursor to the specified row column on the screen.
X *  0,0 is the top left!
X */
X
Xvoid MoveCursor (row, col)
X	int row, col;
X{
X#ifndef INDEX_DAEMON
X
X	char *stuff, *tgoto();
X
X	stuff = tgoto (_moveto, col, row);
X	tputs (stuff, 1, outchar);
X	fflush (stdout);
X
X#endif /* INDEX_DAEMON */
X}
X
X/*
X *  clear to end of line
X */
X
Xvoid CleartoEOLN ()
X{
X#ifndef INDEX_DAEMON
X
X	tputs (_cleartoeoln, 1, outchar);
X	fflush (stdout);  /* clear the output buffer */
X
X#endif /* INDEX_DAEMON */
X}
X
X/*
X *  clear to end of screen
X */
X
Xvoid CleartoEOS ()
X{
X#ifndef INDEX_DAEMON
X
X	int i;
X	
X	if (_cleartoeos) {
X		tputs (_cleartoeos, 1, outchar);
X	} else {
X		for (i=_lines ; i < _lines ; i++) {
X			MoveCursor (i, 0);
X			CleartoEOLN ();
X		}
X	}
X	fflush (stdout);  /* clear the output buffer */
X
X#endif /* INDEX_DAEMON */
X}
X
X/*
X *  set inverse video mode
X */
X
Xvoid StartInverse ()
X{
X#ifndef INDEX_DAEMON
X
X	in_inverse = 1;
X	if (_setinverse && inverse_okay)
X		tputs (_setinverse, 1, outchar);
X	fflush (stdout);
X
X#endif /* INDEX_DAEMON */
X}
X
X/*
X *  compliment of startinverse
X */
X
Xvoid EndInverse ()
X{
X#ifndef INDEX_DAEMON
X
X	in_inverse = 0;
X	if (_clearinverse && inverse_okay)
X		tputs (_clearinverse, 1, outchar);
X	fflush (stdout);
X
X#endif /* INDEX_DAEMON */
X}
X
X/*
X *  toggle inverse video mode
X */
X
Xvoid ToggleInverse ()
X{
X#ifndef INDEX_DAEMON
X
X	if (in_inverse == 0)
X		StartInverse();
X	else
X		EndInverse();
X
X#endif /* INDEX_DAEMON */
X}
X
X/*
X *  returns either 1 or 0, for ON or OFF
X */
X
Xint RawState()
X{
X	return (_inraw);
X}
X
X/*
X *  state is either TRUE or FALSE, as indicated by call
X */
X
Xvoid Raw(state)
X	int state;
X{
X#ifndef INDEX_DAEMON
X
X	if (state == FALSE && _inraw) {
X	  (void) ioctl(TTYIN, TCSETAW, &_original_tty);
X	  _inraw = 0;
X	}
X	else if (state == TRUE && ! _inraw) {
X
X	  (void) ioctl(TTYIN, TCGETA, &_original_tty);	/** current setting **/
X
X	  (void) ioctl(TTYIN, TCGETA, &_raw_tty);    /** again! **/
X#if defined(BSD) || defined(MINIX)
X	  _raw_tty.sg_flags &= ~(ECHO | CRMOD);	/* echo off */
X	  _raw_tty.sg_flags |= CBREAK;	/* raw on    */
X#else
X	  _raw_tty.c_lflag &= ~(ICANON | ECHO);	/* noecho raw mode        */
X
X	  _raw_tty.c_cc[VMIN] = '\01';	/* minimum # of chars to queue    */
X	  _raw_tty.c_cc[VTIME] = '\0';	/* minimum time to wait for input */
X#endif
X
X	  (void) ioctl(TTYIN, TCSETAW, &_raw_tty);
X
X	  _inraw = 1;
X	}
X	
X#endif /* INDEX_DAEMON */
X}
X
X/*
X *  read a character with Raw mode set!
X */
X
Xint ReadCh()
X{
X#ifndef INDEX_DAEMON
X	extern int errno;
X	char ch;
X	register int result = 0;
X	
X#ifdef READ_CHAR_HACK
X#undef getc
X	while ((result = getc(stdin)) == EOF) {
X		if (feof(stdin))
X			break;
X
X		if (ferror(stdin) && errno != EINTR)
X			break;
X
X		clearerr(stdin);
X	}
X
X	return ((result == EOF) ? EOF : result & 0xFF);
X#else
X
X	while ((result = read(0, &ch, 1)) < 0 && errno == EINTR)
X		;	/* spin on signal interrupts */
X
X        return((result <= 0 ) ? EOF : ch & 0xFF);
X#endif		
X
X#endif /* INDEX_DAEMON */
X}
X
X/*
X *  output a character. From tputs... (Note: this CANNOT be a macro!)
X */
X
Xint outchar(c)
X	char c;
X{
X	fputc (c, stdout);
X}
END_OF_FILE
  if test 8719 -ne `wc -c <'curses.c'`; then
    echo shar: \"'curses.c'\" unpacked with wrong size!
  fi
  # end of 'curses.c'
fi
if test -f 'hashstr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hashstr.c'\"
else
  echo shar: Extracting \"'hashstr.c'\" \(2510 characters\)
  sed "s/^X//" >'hashstr.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : hashstr.c
X *  Author    : I.Lea & R.Skrenta
X *  Created   : 01-04-91
X *  Updated   : 21-03-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
X/*
X *  Maintain a table of all strings we have seen.
X *  If a new string comes in, add it to the table and return a pointer
X *  to it.  If we've seen it before, just return the pointer to it.
X *
X *  Usage:  hash_str("some string") returns char *
X *
X *  Spillovers are chained on the end
X */
X
X/*
X *  Arbitrary table size, but make sure it's prime!
X */
X
X#define		HASHNODE_TABLE_SIZE	2411
X
Xstruct hashnode *table[HASHNODE_TABLE_SIZE];
X
X
Xchar *hash_str (s)
X	char *s;
X{
X	long h;				/* result of hash:  index into hash table */
X	struct hashnode *p;	/* used to descend the spillover structs */
X
X	if (s == (char *) 0) {
X		return ((char *) 0);
X	}
X
X	{
X		unsigned char *t = (unsigned char *) s;
X
X		h = *t++;
X		while (*t)
X			h = ((h << 1) ^ *t++) % (long) HASHNODE_TABLE_SIZE;
X	}
X
X	p = table[h];
X
X	if (p == (struct hashnode *) 0) {
X		table[h] = add_string (s);
X		return table[h]->s;
X	}
X
X	while (1) {
X		if (strcmp (s, p->s) == 0) {
X			return (p->s);
X		}
X
X		if (p->next == (struct hashnode *) 0) {
X			p->next = add_string (s);
X			return p->next->s;
X		} else {
X			p = p->next;
X		}
X	}
X	/* NOTREACHED */
X}
X
X
Xstruct hashnode *add_string (s)
X	char *s;
X{
X	int *iptr;
X	struct hashnode *p;
X
X	p = (struct hashnode *) my_malloc ((unsigned) sizeof (struct hashnode));
X
X	p->next = (struct hashnode *) 0;
X	iptr = (int *) my_malloc ((unsigned) strlen (s) + sizeof (int) + 1);
X	*iptr++ = -1;
X	p->s = (char *) iptr;
X	strcpy (p->s, s);
X	return (p);
X}
X
X
Xvoid hash_init ()
X{
X	int i;
X
X	for (i = 0; i < HASHNODE_TABLE_SIZE; i++) {
X		table[i] = (struct hashnode *) 0;
X	}
X}
X
X
Xvoid hash_reclaim ()
X{
X	int i;
X	int *iptr;
X	struct hashnode *p, *next;
X
X	for (i = 0; i < HASHNODE_TABLE_SIZE; i++)
X		if (table[i] != (struct hashnode *) 0) {
X			p = table[i];
X			while (p != (struct hashnode *) 0) {
X				next = p->next;
X				if (p->s != (char *) 0) {
X					iptr = (int *) p->s;
X					iptr--;
X					free ((char *) iptr);
X				}
X				free ((char *) p);
X				p = next;
X			}
X			table[i] = (struct hashnode *) 0;
X		}
X}
END_OF_FILE
  if test 2510 -ne `wc -c <'hashstr.c'`; then
    echo shar: \"'hashstr.c'\" unpacked with wrong size!
  fi
  # end of 'hashstr.c'
fi
if test -f 'inews.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'inews.c'\"
else
  echo shar: Extracting \"'inews.c'\" \(4721 characters\)
  sed "s/^X//" >'inews.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : inews.c
X *  Author    : I.Lea
X *  Created   : 17-03-92
X *  Updated   : 20-06-92
X *  Notes     : NNTP builtin version of inews
X *  Copyright : (c) Copyright 1991-92 by Iain Lea
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
X#if defined(BSD) || defined(RS6000)
X#	ifdef apollo
X#		include	</bsd4.3/usr/include/netdb.h>
X#	else
X#		include	<netdb.h>
X#	endif
X#endif
X
X
Xint submit_inews (name)
X	char *name;
X{
X	int	ret_code = FALSE;
X
X#if !defined(INDEX_DAEMON) && !defined(XSPOOLDIR)
X
X#ifdef NNTP_INEWS
X	char	from_name[256];
X	char	host_name[128];
X	char	line[NNTP_STRLEN];
X	FILE	*fp;
X	int	len = 0;
X	int	respcode;
X
X	if ((fp = fopen (name, "r")) == NULL) {
X		return (ret_code);
X	}
X
X	/*
X	 * Send POST command to NNTP server
X	 */
X	put_server ("post");
X
X	/*
X	 * Receive CONT_POST or ERROR response code from NNTP server
X	 */
X	if ((respcode = get_respcode ()) != CONT_POST) {
X		error_message ("%s", nntp_respcode (respcode));
X		debug_nntp ("submit_inews", nntp_respcode (respcode));
X		return (ret_code);
X	}
X
X	get_host_name (host_name);	
X	get_from_name (from_name);
X	
X	/*
X	 * Send Path: and From: article headers
X	 */
X#ifdef NNTP_INEWS_GATEWAY
X	sprintf (line, "Path: %s", userid);
X#else
X	sprintf (line, "Path: %s!%s", host_name, userid);
X#endif	
X	put_server (line);
X	sprintf (line, "From: %s", from_name);
X	put_server (line);
X
X	/*
X	 * Send article 1 line at a time ending with "."
X	 */
X	while (fgets (line, sizeof (line), fp) != NULL) {
X		len = strlen (line);
X		line[len-1] = '\0';
X		fprintf (ser_wr_fp, "%s\r\n", line);
X	}
X	
X	put_server (".");
X
X	/*
X	 * Receive OK_POSTED or ERROR response code from NNTP server
X	 */
X	if ((respcode = get_respcode ()) != OK_POSTED) {
X		error_message ("%s", nntp_respcode (respcode));
X		debug_nntp ("submit_inews", nntp_respcode (respcode));
X		return (ret_code);
X  	}
X  	
X	ret_code = TRUE;
X
X#endif /* NNTP_ABLE */
X
X#endif /* INDEX_DAEMON */
X
X	return (ret_code);
X}
X
X/*
X * Find real hostname / substitute hostname if news gateway name 
X */
X 
Xvoid get_host_name (host_name)
X	char *host_name;
X{
X#ifndef INDEX_DAEMON
X
X	char host[PATH_LEN];
X
X#ifdef NNTP_INEWS_GATEWAY	
X	FILE *fp;
X
X	host_name[0] = '\0';
X
X	/*
X	 * If 1st letter is '/' read gateway name from specified file
X	 */
X	if (*(NNTP_INEWS_GATEWAY) == '/') {
X		if ((fp = fopen (NNTP_INEWS_GATEWAY, "r")) != (FILE *) 0) {
X			if (fgets (host, sizeof (host), fp) != (char *) 0) {
X				my_strncpy (host_name, host, strlen (host)-1);
X			}	
X			fclose (fp);
X		}
X		if (! host_name[0]) {
X			strcpy(host_name, "PROBLEM_WITH_INEWS_GATEWAY_FILE");
X		}
X	} else {
X		strcpy (host_name, NNTP_INEWS_GATEWAY);
X	}	
X#else
X#	if defined(BSD) || defined(sinix) || defined(RS6000) || defined(HPUX)
X	{
X		struct hostent *host_entry;
X
X		gethostname (host, sizeof (host)); 
X		host_entry = gethostbyname (host);
X		my_strncpy (host, host_entry->h_name, sizeof (host)); 
X	}	
X#	else	
X	{
X		struct utsname uts_name;
X
X		uname (&uts_name);
X		my_strncpy (host, uts_name.nodename, sizeof (host));
X	}
X#	endif
X
X	strcpy (host_name, host);
X#endif
X
X#endif /* INDEX_DAEMON */
X}
X
X/*
X * Find users & hosts name
X */
X
Xvoid get_from_name (from_name)
X	char *from_name;
X{
X#ifndef INDEX_DAEMON
X
X	char domain[256];
X	char full_name[128];
X	char host_name[256];
X	char *ptr;
X#ifdef NNTP_INEWS_DOMAIN
X	FILE *fp;
X#endif
X	
X	domain[0] = '\0';
X	
X	if ((ptr = (char *) getenv ("NAME")) != (char *) 0) {
X		my_strncpy (full_name, ptr, sizeof (full_name));
X	} else {	
X		my_strncpy (full_name, myentry->pw_gecos, sizeof (full_name));
X		if ((ptr = (char *) strchr (full_name, ','))) {
X			*ptr = '\0';			
X		}
X	}
X
X	get_host_name (host_name);
X
X#ifdef NNTP_INEWS_DOMAIN
X	/*
X	 * If 1st letter is '/' read domain name from specified file
X	 */
X	if (*(NNTP_INEWS_DOMAIN) == '/') {
X		if ((fp = fopen (NNTP_INEWS_DOMAIN, "r")) != (FILE *) 0) {
X			if (fgets (domain, sizeof (domain), fp) != (char *) 0) {
X				if (ptr = (char *) strchr (domain, '\n')) {
X					*ptr = '\0';
X				}
X			}
X			fclose (fp);
X		}
X		if (! domain[0]) {
X			strcpy (domain, "PROBLEM_WITH_INEWS_DOMAIN_FILE");
X		}
X	} else {
X		my_strncpy (domain, NNTP_INEWS_DOMAIN, sizeof (domain));
X	}
X	
X	if (domain[0] == '.') {
X		sprintf (from_name, "%s@%s%s (%s)",
X			userid, host_name, domain, full_name);
X	} else {	
X		sprintf (from_name, "%s@%s (%s)", userid, domain, full_name);
X	}		
X#else	
X	sprintf (from_name, "%s@%s (%s)", userid, host_name, full_name);
X#endif
X
X	if (debug == 2) {
X		error_message ("FROM: %s", from_name);
X	}	
X
X#endif /* INDEX_DAEMON */
X}
END_OF_FILE
  if test 4721 -ne `wc -c <'inews.c'`; then
    echo shar: \"'inews.c'\" unpacked with wrong size!
  fi
  # end of 'inews.c'
fi
if test -f 'memory.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'memory.c'\"
else
  echo shar: Extracting \"'memory.c'\" \(7855 characters\)
  sed "s/^X//" >'memory.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : memory.c
X *  Author    : I.Lea & R.Skrenta
X *  Created   : 01-04-91
X *  Updated   : 03-06-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
Xint *my_group;					/* .newsrc --> active[] */
Xint *unread;					/* highest art read in group */
Xlong *base;
Xstruct group_t *active;			/* active file */
Xstruct article_t *arts;
X
X/*
X *  Dynamic table management
X *  These settings are memory conservative:  small initial allocations
X *  and a 50% expansion on table overflow.  A fast vm system with
X *  much memory might want to start with higher initial allocations
X *  and a 100% expansion on overflow, especially for the arts[] array.
X */
X
Xvoid init_alloc ()
X{
X	max_active = DEFAULT_ACTIVE_NUM;
X	max_art = DEFAULT_ARTICLE_NUM;
X
X	active = (struct group_t *) my_malloc ((unsigned) sizeof(*active) * max_active);
X	my_group = (int *) my_malloc ((unsigned) sizeof(int) * max_active);
X	unread = (int *) my_malloc ((unsigned) sizeof(int) * max_active);
X
X	arts = (struct article_t *) my_malloc ((unsigned) sizeof(*arts) * max_art);
X	base = (long *) my_malloc ((unsigned) sizeof(long) * max_art);
X
X	max_kill = DEFAULT_KILL_NUM;
X	
X	killf = (struct kill_t *) my_malloc ((unsigned) sizeof(*killf) * max_kill);
X
X	max_save = DEFAULT_SAVE_NUM;
X	
X	save = (struct save_t *) my_malloc ((unsigned) sizeof(*save) * max_save);
X
X	screen = (struct screen_t *) 0;
X}
X
X
Xvoid expand_art()
X{
X	max_art += max_art / 2;		/* increase by 50% */
X
X	arts = (struct article_t *) my_realloc ((char *) arts, (unsigned) sizeof(*arts) * max_art);
X	base = (long *) my_realloc ((char *) base, (unsigned) sizeof(long) * max_art);
X}
X
X
Xvoid expand_active()
X{
X	max_active += max_active / 2;		/* increase by 50% */
X
X	if (active == (struct group_t *) 0) {
X		active = (struct group_t *) my_malloc ((unsigned) sizeof(*active) * max_active);
X		my_group = (int *) my_malloc ((unsigned) sizeof(int) * max_active);
X		unread = (int *) my_malloc ((unsigned) sizeof(int) * max_active);
X	} else {
X		active = (struct group_t *) my_realloc((char *) active,
X				 (unsigned) sizeof(*active) * max_active);
X		my_group = (int *) my_realloc((char *) my_group, (unsigned) sizeof(int) * max_active);
X		unread = (int *) my_realloc((char *) unread, (unsigned) sizeof(int) * max_active);
X	}
X}
X
X
Xvoid expand_kill()
X{
X	max_kill += max_kill / 2;		/* increase by 50% */
X
X	killf = (struct kill_t *) my_realloc((char *) killf, (unsigned) sizeof(struct kill_t) * max_kill);
X}
X
X
Xvoid expand_save()
X{
X	max_save += max_save / 2;		/* increase by 50% */
X
X	save = (struct save_t *) my_realloc((char *) save, (unsigned) sizeof(struct save_t) * max_save);
X}
X
X
Xvoid init_screen_array (allocate)
X	int allocate;
X{
X	int i;
X
X	if (allocate) {
X		screen = (struct screen_t *) my_malloc(
X			(unsigned) sizeof(struct screen_t) * LINES+1);
X
X		for (i=0 ; i < LINES ; i++) {
X			screen[i].col = (char *) my_malloc ((unsigned) COLS+2);
X		}
X	} else {
X		if (screen != (struct screen_t *) 0) {
X			for (i=0 ; i < LINES ; i++) {
X				if (screen[i].col != (char *) 0) {
X					free ((char *) screen[i].col);
X					screen[i].col = (char *) 0;
X				}
X			}	
X
X			free ((char *) screen);
X			screen = (struct screen_t *) 0;
X		}
X	}
X}
X
X
Xvoid free_all_arrays ()
X{
X	hash_reclaim ();
X	
X	init_screen_array (FALSE);
X
X	free_art_array ();
X
X	if (arts != (struct article_t *) 0) {
X		free ((char *) arts);
X		arts = (struct article_t *) 0;
X	}
X
X	free_active_arrays ();
X
X	if (base != (long *) 0) {
X		free ((char *) base);
X		base = (long *) 0;
X	}
X
X	if (killf != (struct kill_t *) 0) {
X		free_kill_array ();
X		if (killf != (struct kill_t *) 0) {
X			free ((char *) killf);
X			killf = (struct kill_t *) 0;
X		}
X	}
X
X	if (save != (struct save_t *) 0) {
X		free_save_array ();
X		if (save != (struct save_t *) 0) {
X			free ((char *) save);
X			save = (struct save_t *) 0;
X		}
X	}
X}
X
X
Xvoid free_art_array ()
X{
X	register int i;
X
X	for (i=0 ; i < top ; i++) {
X		arts[i].artnum = 0L;
X		arts[i].thread = ART_EXPIRED;
X		arts[i].inthread = FALSE;
X		arts[i].unread = ART_UNREAD;
X		arts[i].killed = FALSE;
X		arts[i].tagged = FALSE;
X		arts[i].hot = FALSE;
X		arts[i].date[0] = '\0';
X		if (arts[i].part != (char *) 0) {
X			free ((char *) arts[i].part);
X			arts[i].part = (char *) 0;
X		}
X		if (arts[i].patch != (char *) 0) {
X			free ((char *) arts[i].patch);
X			arts[i].patch = (char *) 0;
X		}
X		if (arts[i].xref != NULL) {
X			free ((char *) arts[i].xref);
X			arts[i].xref = NULL;
X		}
X	}
X}
X
X
Xvoid free_active_arrays ()
X{
X	register int i;
X	
X	if (my_group != (int *) 0) {			/* my_group[] */
X		free ((char *) my_group);
X		my_group = (int *) 0;
X	}
X
X	if (unread != (int *) 0) {				/* unread[] */
X		free ((char *) unread);
X		unread = (int *) 0;
X	}
X
X	if (active != (struct group_t *) 0) {	/* active[] */
X		for (i=0 ; i < num_active ; i++) {
X			if (active[i].name != (char *) 0) {
X				free ((char *) active[i].name);
X				active[i].name = (char *) 0;
X			}
X			if (active[i].description != (char *) 0) {
X				free ((char *) active[i].description);
X				active[i].description = (char *) 0;
X			}
X			if (active[i].attribute.server != (char *) 0) {
X				free ((char *) active[i].attribute.server);
X				active[i].attribute.server = (char *) 0;
X			}
X			if (active[i].attribute.maildir != (char *) 0 &&
X			    active[i].attribute.maildir != default_maildir) {
X				free ((char *) active[i].attribute.maildir);
X				active[i].attribute.maildir = (char *) 0;
X			}
X			if (active[i].attribute.savedir != (char *) 0 &&
X			    active[i].attribute.savedir != default_savedir) {
X				free ((char *) active[i].attribute.savedir);
X				active[i].attribute.savedir = (char *) 0;
X			}
X			if (active[i].attribute.sigfile != (char *) 0 &&
X			    active[i].attribute.sigfile != default_sigfile) {
X				free ((char *) active[i].attribute.sigfile);
X				active[i].attribute.sigfile = (char *) 0;
X			}
X		}
X		if (active != (struct group_t *) 0) {
X			free ((char *) active);
X			active = (struct group_t *) 0;
X		}
X	}
X}
X
X
Xvoid free_kill_array ()
X{
X	int i;
X	
X	for (i=0 ; i < kill_num ; i++) {
X		if (killf[i].kill_subj != (char *) 0) {
X			free ((char *) killf[i].kill_subj);
X			killf[i].kill_subj = (char *) 0;
X		}
X		if (killf[i].kill_from != (char *) 0) {
X			free ((char *) killf[i].kill_from);
X			killf[i].kill_from = (char *) 0;
X		}
X	}
X}
X
X
X/*
X *  reset save list array to 0 and free's all its allocated memory
X */
X 
Xvoid free_save_array ()
X{
X	int i;
X	
X	for (i=0 ; i < save_num ; i++) {
X		if (save[i].subject != (char *) 0) {
X			free ((char *) save[i].subject);
X			save[i].subject = (char *) 0;
X		}
X		if (save[i].archive != (char *) 0) {
X			free ((char *) save[i].archive);
X			save[i].archive = (char *) 0;
X		}
X		if (save[i].dir != (char *) 0) {
X			free ((char *) save[i].dir);
X			save[i].dir = (char *) 0;
X		}
X		if (save[i].file != (char *) 0) {
X			free ((char *) save[i].file);
X			save[i].file = (char *) 0;
X		}
X		if (save[i].part != (char *) 0) {
X			free ((char *) save[i].part);
X			save[i].part = (char *) 0;
X		}
X		if (save[i].patch != (char *) 0) {
X			free ((char *) save[i].patch);
X			save[i].patch = (char *) 0;
X		}
X		save[i].index   = -1;
X		save[i].saved   = FALSE;
X		save[i].is_mailbox = FALSE;
X	}
X	
X	save_num = 0;
X}
X
X
Xchar *my_malloc (size)
X	unsigned size;
X{
X	char *p;
X
X	if ((p = (char *) calloc (1, (int) size)) == NULL) {
X		error_message (txt_out_of_memory, progname);
X		tin_done (1);
X	}
X	return p;
X}
X
X
Xchar *my_realloc (p, size)
X	char *p;
X	unsigned size;
X{
X	if (! p) {
X		p = (char *) calloc (1, (int) size);
X	} else {
X		p = (char *) realloc (p, (int) size);
X	}
X
X	if (! p) {
X		error_message (txt_out_of_memory, progname);
X		tin_done (1);
X	}
X	return p;
X}
END_OF_FILE
  if test 7855 -ne `wc -c <'memory.c'`; then
    echo shar: \"'memory.c'\" unpacked with wrong size!
  fi
  # end of 'memory.c'
fi
if test -f 'nntplib.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nntplib.h'\"
else
  echo shar: Extracting \"'nntplib.h'\" \(4658 characters\)
  sed "s/^X//" >'nntplib.h' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : nntplib.h
X *  Author    : I.Lea
X *  Created   : 01-04-91
X *  Updated   : 03-06-92
X *  Notes     : nntp.h 1.5.11/1.6 with extensions for tin & CD-ROM
X *  Copyright : You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#ifndef	NNTP_SERVER_FILE
X#	define	NNTP_SERVER_FILE	"/etc/nntpserver"
X#endif
X
X/*
X *  External routine declarations
X */
X
Xextern char *getserverbyfile();
Xextern int server_init();
Xextern int get_tcp_socket();
Xextern int handle_server_response();
Xextern void put_server();
Xextern int get_server();
Xextern void close_server();
X
X/*
X *  External file descriptors for the server connection
X */
X
Xextern FILE *ser_wr_fp;
X
X/*
X * Response codes for NNTP server
X *
X * @(#)Header: nntp.h,v 1.81 92/03/12 02:08:31 sob Exp $
X *
X * First digit:
X *
X *	1xx	Informative message
X *	2xx	Command ok
X *	3xx	Command ok so far, continue
X *	4xx	Command was correct, but couldn't be performed
X *		for some specified reason.
X *	5xx	Command unimplemented, incorrect, or a
X *		program error has occured.
X *
X * Second digit:
X *
X *	x0x	Connection, setup, miscellaneous
X *	x1x	Newsgroup selection
X *	x2x	Article selection
X *	x3x	Distribution
X *	x4x	Posting
X */
X
X#define	CHAR_INF	'1'
X#define	CHAR_OK		'2'
X#define	CHAR_CONT	'3'
X#define	CHAR_ERR	'4'
X#define	CHAR_FATAL	'5'
X
X#define	INF_HELP		100	/* Help text on way */
X#define	INF_AUTH		180	/* Authorization capabilities */
X#define	INF_DEBUG		199	/* Debug output */
X
X#define	OK_CANPOST		200	/* Hello; you can post */
X#define	OK_NOPOST		201	/* Hello; you can't post */
X#define	OK_SLAVE		202	/* Slave status noted */
X#define	OK_GOODBYE		205	/* Closing connection */
X#define	OK_GROUP		211	/* Group selected */
X#define	OK_GROUPS		215	/* Newsgroups follow */
X
X#define OK_XINDEX		218	/* Tin index follows */
X
X#define	OK_ARTICLE		220	/* Article (head & body) follows */
X#define	OK_HEAD			221	/* Head follows */
X#define	OK_BODY			222	/* Body follows */
X#define	OK_NOTEXT		223	/* No text sent -- stat, next, last */
X#define	OK_NEWNEWS		230	/* New articles by message-id follow */
X#define	OK_NEWGROUPS		231	/* New newsgroups follow */
X#define	OK_XFERED		235	/* Article transferred successfully */
X#define	OK_POSTED		240	/* Article posted successfully */
X#define	OK_AUTHSYS		280	/* Authorization system ok */
X#define	OK_AUTH			281	/* Authorization (user/pass) ok */
X#define OK_BIN			282	/* binary data follows */
X#define OK_SPLIST		283	/* spooldir list follows */
X#define OK_SPSWITCH		284	/* Switching to a different spooldir */
X#define OK_SPNOCHANGE		285	/* Still using same spooldir */
X#define OK_SPLDIRCUR		286	/* Current spooldir */
X#define OK_SPLDIRAVL		287	/* Available spooldir */
X#define OK_SPLDIRERR		288	/* Unavailable spooldir or invalid entry */
X
X#define CONT_XFER		335	/* Continue to send article */
X#define	CONT_POST		340	/* Continue to post article */
X#define	NEED_AUTHINFO		380	/* authorization is required */
X#define	NEED_AUTHDATA		381	/* <type> authorization data required */
X
X#define	ERR_GOODBYE		400	/* Have to hang up for some reason */
X#define	ERR_NOGROUP		411	/* No such newsgroup */
X#define	ERR_NCING		412	/* Not currently in newsgroup */
X
X#define ERR_XINDEX		418	/* No tin index for this group */
X
X#define	ERR_NOCRNT		420	/* No current article selected */
X#define	ERR_NONEXT		421	/* No next article in this group */
X#define	ERR_NOPREV		422	/* No previous article in this group */
X#define	ERR_NOARTIG		423	/* No such article in this group */
X#define ERR_NOART		430	/* No such article at all */
X#define ERR_GOTIT		435	/* Already got that article, don't send */
X#define ERR_XFERFAIL		436	/* Transfer failed */
X#define	ERR_XFERRJCT		437	/* Article rejected, don't resend */
X#define	ERR_NOPOST		440	/* Posting not allowed */
X#define	ERR_POSTFAIL		441	/* Posting failed */
X#define	ERR_NOAUTH		480	/* authorization required for command */
X#define	ERR_AUTHSYS		481	/* Authorization system invalid */
X#define	ERR_AUTHREJ		482	/* Authorization data rejected */
X#define ERR_INVALIAS		483	/* Invalid alias on spooldir cmd */
X#define ERR_INVNOSPDIR		484	/* No spooldir file found */
X
X#define	ERR_COMMAND		500	/* Command not recognized */
X#define	ERR_CMDSYN		501	/* Command syntax error */
X#define	ERR_ACCESS		502	/* Access to server denied */
X#define ERR_FAULT		503	/* Program fault, command not performed */
X#define	ERR_AUTHBAD		580	/* Authorization Failed */
X	
X/*
X * RFC 977 defines this; don't change it.
X */
X
X#define	NNTP_STRLEN		512
X
END_OF_FILE
  if test 4658 -ne `wc -c <'nntplib.h'`; then
    echo shar: \"'nntplib.h'\" unpacked with wrong size!
  fi
  # end of 'nntplib.h'
fi
if test -f 'search.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'search.c'\"
else
  echo shar: Extracting \"'search.c'\" \(7173 characters\)
  sed "s/^X//" >'search.c' <<'END_OF_FILE'
X/*
X *  Project   : tin - a threaded Netnews reader
X *  Module    : search.c
X *  Author    : I.Lea & R.Skrenta
X *  Created   : 01-04-91
X *  Updated   : 13-03-92
X *  Notes     :
X *  Copyright : (c) Copyright 1991-92 by Iain Lea & Rich Skrenta
X *              You may  freely  copy or  redistribute  this software,
X *              so  long as there is no profit made from its use, sale
X *              trade or  reproduction.  You may not change this copy-
X *              right notice, and it must be included in any copy made
X */
X
X#include	"tin.h"
X
Xextern FILE *note_fp;
Xextern int cur_groupnum;
Xextern int first_group_on_screen;
Xextern int last_group_on_screen;
Xextern int first_subj_on_screen;
Xextern int last_subj_on_screen;
Xextern int index_point;
Xextern int note_line;
Xextern int note_page;
Xextern int note_end;
Xextern long note_mark[MAX_PAGES];
X
X/*
X * last search patterns
X */
X
Xchar default_author_search[LEN];
Xchar default_group_search[LEN];
Xchar default_subject_search[LEN];
Xchar default_art_search[LEN];
X
X
X/*
X *  group.c & page.c
X */
X 
Xint search_author (only_unread, current_art, forward)
X	int only_unread;
X	int current_art;
X	int forward;
X{
X	char buf[LEN];
X	char buf2[LEN];
X	int i, patlen;
X
X	clear_message ();
X
X	if (forward) {
X		sprintf (buf2, txt_author_search_forwards, default_author_search);
X	} else {
X		sprintf (buf2, txt_author_search_backwards, default_author_search);
X	}
X	
X	if (! prompt_string (buf2, buf)) {
X		return -1;
X	}
X	
X	if (strlen (buf)) {
X		strcpy (default_author_search, buf);
X	} else {
X		if (default_author_search[0]) {
X			strcpy (buf, default_author_search);
X		} else {
X			info_message (txt_no_search_string);	
X			return -1;
X		}
X	}
X
X	wait_message (txt_searching);
X
X	make_lower (default_author_search, buf);
X
X	patlen = strlen (default_author_search);
X
X	i = current_art;
X
X	do {
X		if (forward) {
X			i = next_response (i);
X			if (i < 0)
X				i = base[0];
X		} else {
X			i = prev_response (i);
X			if (i < 0)
X				i = base[top_base - 1] + 
X					num_of_responses (top_base - 1);
X		}
X
X		if (only_unread && arts[i].unread != ART_UNREAD) {
X			continue;
X		}
X			
X		if (arts[i].name == (char *) 0) {
X			make_lower (arts[i].from, buf2);
X		} else {
X			sprintf (msg, "%s (%s)", arts[i].from, arts[i].name);
X			make_lower (msg, buf2);
X		}
X
X		if (str_str (buf2, buf, patlen) != 0) {
X			clear_message ();
X			return i;
X		}
X	} while (i != current_art);
X
X	info_message (txt_no_match);
X	return -1;
X}
X
X/*
X * select.c
X */
X 
Xvoid search_group (forward)
X	int forward;
X{
X	char buf[LEN];
X	char buf2[LEN];
X	int i, patlen;
X
X	clear_message ();
X
X	if (forward) {
X		sprintf (buf2, txt_search_forwards, default_group_search);
X	} else {
X		sprintf (buf2, txt_search_backwards, default_group_search);
X	}
X
X	if (! prompt_string (buf2, buf)) {
X		return;
X	}
X
X	if (strlen (buf)) {
X		strcpy (default_group_search, buf);
X	} else {
X		if (default_group_search[0]) {
X			strcpy (buf, default_group_search);
X		} else {
X			info_message (txt_no_search_string);	
X			return;
X		}
X	}
X
X	wait_message (txt_searching);
X
X	make_lower (default_group_search, buf);
X
X	patlen = strlen (default_group_search);
X
X	i = cur_groupnum;
X
X	do {
X		if (forward)
X			i++;
X		else
X			i--;
X
X		if (i >= group_top)
X			i = 0;
X		if (i < 0)
X			i = group_top - 1;
X
X		make_lower (active[my_group[i]].name, buf2);
X
X		if (str_str (buf2, buf, patlen) != 0) {
X			if (i >= first_group_on_screen
X			&&  i < last_group_on_screen) {
X				clear_message ();
X				erase_group_arrow ();
X				cur_groupnum = i;
X				draw_group_arrow ();
X			} else {
X				cur_groupnum = i;
X				group_selection_page ();
X			}
X			return;
X		}
X	} while (i != cur_groupnum);
X
X	info_message (txt_no_match);
X}
X
X/*
X * group.c
X */
X
Xvoid search_subject (forward, group)
X	int forward;
X	char *group;
X{
X	char buf[LEN];
X	char buf2[LEN];
X	int i, j, patlen;
X
X	if (index_point < 0) {
X		info_message (txt_no_arts);
X		return;
X	}
X	
X	clear_message ();
X
X	if (forward) {
X		sprintf (buf2, txt_search_forwards, default_subject_search);
X	} else {
X		sprintf (buf2, txt_search_backwards, default_subject_search);
X	}
X
X	if (! prompt_string (buf2, buf)) {
X		return;
X	}
X
X	if (strlen (buf)) {
X		strcpy (default_subject_search, buf);
X	} else {
X		if (default_subject_search[0]) {
X			strcpy (buf, default_subject_search);
X		} else {
X			info_message (txt_no_search_string);	
X			return;
X		}
X	}
X
X	wait_message (txt_searching);
X
X	make_lower (default_subject_search, buf);
X
X	patlen = strlen (default_subject_search);
X
X	i = index_point;
X
X	do {
X		if (forward)
X			i++;
X		else
X			i--;
X
X		if (i >= top_base)
X			i = 0;
X		if (i < 0)
X			i = top_base - 1;
X
X		j = (int) base[i];
X
X		make_lower (arts[j].subject, buf2);
X
X		if (str_str (buf2, buf, patlen) != 0) {
X			if (i >= first_subj_on_screen
X			    &&  i < last_subj_on_screen) {
X				clear_message ();
X				erase_subject_arrow ();
X				index_point = i;
X				draw_subject_arrow ();
X			} else {
X				index_point = i;
X				show_group_page (group);
X			}
X			return;
X		}
X	} while (i != index_point);
X
X	info_message (txt_no_match);
X}
X
X/*
X *  page.c (search article body)
X */
X
Xint search_article (forward)
X	int forward;
X{
X	char buf[LEN];
X	char buf2[LEN];
X	char string[LEN];
X	char pattern[LEN];
X	char *p, *q;
X	int ctrl_L;
X	int i, j, patlen;
X	int orig_note_end;
X	int orig_note_page;
X
X	clear_message ();
X
X	if (forward) {
X		sprintf (buf2, txt_search_forwards, default_art_search);
X	} else {
X		sprintf (buf2, txt_search_backwards, default_art_search);
X	}
X
X	if (! prompt_string (buf2, buf)) {
X		return FALSE;
X	}
X
X	if (strlen (buf)) {
X		strcpy (default_art_search, buf);
X	} else {
X		if (default_art_search[0]) {
X			strcpy (buf, default_art_search);
X		} else {
X			info_message (txt_no_search_string);	
X			return FALSE;
X		}
X	}
X
X	wait_message (txt_searching);
X	
X	make_lower (default_art_search, pattern);
X
X	patlen = strlen (default_art_search);
X
X	/*
X	 *  save current position in article
X	 */
X	orig_note_end = note_end;
X	orig_note_page = note_page;
X	
X	while (! note_end) {
X		note_line = 1;
X		ctrl_L = FALSE;
X
X		if (note_page == 0) {
X			note_line += 4;
X		} else {
X			note_line += 2;
X		}
X		while (note_line < LINES) {
X			if (fgets (buf, sizeof buf, note_fp) == NULL) {
X				note_end = TRUE;
X				break;
X			}
X			buf[LEN-1] = '\0';
X			for (p = buf, q = buf2;	*p && *p != '\n' && q<&buf2[LEN]; p++) {
X				if (*p == '\b' && q > buf2) {
X					q--;
X				} else if (*p == '\f') {		/* ^L */
X					*q++ = '^';
X					*q++ = 'L';
X					ctrl_L = TRUE;
X				} else if (*p == '\t') {
X					i = q - buf2;
X					j = (i|7) + 1;
X
X					while (i++ < j) {
X						*q++ = ' ';
X					}
X				} else if (((*p) & 0xFF) < ' ') {
X					*q++ = '^';
X					*q++ = ((*p) & 0xFF) + '@';
X				} else {
X					*q++ = *p;
X				}
X			}
X			*q = '\0';
X
X			make_lower (buf2, string);
X
X			if (str_str (string, pattern, patlen) != 0) {
X				fseek (note_fp, note_mark[note_page], 0);
X				return TRUE;
X			}
X
X			note_line += ((int) strlen(buf2) / COLS) + 1;
X
X			if (ctrl_L) {
X				break;
X			}
X		}
X		if (! note_end) {
X			note_mark[++note_page] = ftell (note_fp);
X		}
X	}
X
X	note_end = orig_note_end;
X	note_page = orig_note_page;
X	fseek (note_fp, note_mark[note_page], 0);
X	info_message (txt_no_match);
X	return FALSE;
X}
X
X
Xvoid make_lower (s, t)
X	char *s;
X	char *t;
X{
X
X	while (*s) {
X		if (isupper(*s))
X			*t = tolower(*s);
X		else
X			*t = *s;
X		s++;
X		t++;
X	}
X	*t = 0;
X}
END_OF_FILE
  if test 7173 -ne `wc -c <'search.c'`; then
    echo shar: \"'search.c'\" unpacked with wrong size!
  fi
  # end of 'search.c'
fi
if test -f 'wildmat.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'wildmat.c'\"
else
  echo shar: Extracting \"'wildmat.c'\" \(4798 characters\)
  sed "s/^X//" >'wildmat.c' <<'END_OF_FILE'
X/*  $Revision: 1.5 $
X**
X**  Do shell-style pattern matching for ?, \, [], and * characters.
X**  Might not be robust in face of malformed patterns; e.g., "foo[a-"
X**  could cause a segmentation violation.  It is 8bit clean.
X**
X**  Written by Rich $alz, mirror!rs, Wed Nov 26 19:03:17 EST 1986.
X**  Rich $alz is now <rsalz@bbn.com>.
X**  April, 1991:  Replaced mutually-recursive calls with in-line code
X**  for the star character.
X**
X**  Special thanks to Lars Mathiesen <thorinn@diku.dk> for the ABORT code.
X**  This can greatly speed up failing wildcard patterns.  For example:
X**	pattern: -*-*-*-*-*-*-12-*-*-*-m-*-*-*
X**	text 1:	 -adobe-courier-bold-o-normal--12-120-75-75-m-70-iso8859-1
X**	text 2:	 -adobe-courier-bold-o-normal--12-120-75-75-X-70-iso8859-1
X**  Text 1 matches with 51 calls, while text 2 fails with 54 calls.  Without
X**  the ABORT, then it takes 22310 calls to fail.  Ugh.  The following
X**  explanation is from Lars:
X**  The precondition that must be fulfilled is that DoMatch will consume
X**  at least one character in text.  This is true if *p is neither '*' nor
X**  '\0'.)  The last return has ABORT instead of FALSE to avoid quadratic
X**  behaviour in cases like pattern "*a*b*c*d" with text "abcxxxxx".  With
X**  FALSE, each star-loop has to run to the end of the text; with ABORT
X**  only the last one does.
X**
X**  Once the control of one instance of DoMatch enters the star-loop, that
X**  instance will return either TRUE or ABORT, and any calling instance
X**  will therefore return immediately after (without calling recursively
X**  again).  In effect, only one star-loop is ever active.  It would be
X**  possible to modify the code to maintain this context explicitly,
X**  eliminating all recursive calls at the cost of some complication and
X**  loss of clarity (and the ABORT stuff seems to be unclear enough by
X**  itself).  I think it would be unwise to try to get this into a
X**  released version unless you have a good test data base to try it out
X**  on.
X*/
X
X#define TRUE			1
X#define FALSE			0
X#define ABORT			-1
X
X
X    /* What character marks an inverted character class? */
X#define NEGATE_CLASS		'^'
X    /* Is "*" a common pattern? */
X#define OPTIMIZE_JUST_STAR
X    /* Do tar(1) matching rules, which ignore a trailing slash? */
X#undef MATCH_TAR_PATTERN
X
X
X/*
X**  Match text and p, return TRUE, FALSE, or ABORT.
X*/
Xstatic int
XDoMatch(text, p)
X    register char	*text;
X    register char	*p;
X{
X#ifndef INDEX_DAEMON
X
X    register int	last;
X    register int	matched;
X    register int	reverse;
X
X    for ( ; *p; text++, p++) {
X	if (*text == '\0' && *p != '*')
X	    return ABORT;
X	switch (*p) {
X	case '\\':
X	    /* Literal match with following character. */
X	    p++;
X	    /* FALLTHROUGH */
X	default:
X	    if (*text != *p)
X		return FALSE;
X	    continue;
X	case '?':
X	    /* Match anything. */
X	    continue;
X	case '*':
X	    while (*++p == '*')
X		/* Consecutive stars act just like one. */
X		continue;
X	    if (*p == '\0')
X		/* Trailing star matches everything. */
X		return TRUE;
X	    while (*text)
X		if ((matched = DoMatch(text++, p)) != FALSE)
X		    return matched;
X	    return ABORT;
X	case '[':
X	    reverse = p[1] == NEGATE_CLASS ? TRUE : FALSE;
X	    if (reverse)
X		/* Inverted character class. */
X		p++;
X	    matched = FALSE;
X	    if (p[1] == ']' || p[1] == '-')
X		if (*++p == *text)
X		    matched = TRUE;
X	    for (last = *p; *++p && *p != ']'; last = *p)
X		/* This next line requires a good C compiler. */
X		if (*p == '-' && p[1] != ']'
X		    ? *text <= *++p && *text >= last : *text == *p)
X		    matched = TRUE;
X	    if (matched == reverse)
X		return FALSE;
X	    continue;
X	}
X    }
X
X#ifdef	MATCH_TAR_PATTERN
X    if (*text == '/')
X	return TRUE;
X#endif	/* MATCH_TAR_ATTERN */
X    return *text == '\0';
X
X#endif	/* INDEX_DAEMON */
X}
X
X
X/*
X**  User-level routine.  Returns TRUE or FALSE.
X*/
Xint
Xwildmat(text, p)
X    char	*text;
X    char	*p;
X{
X#ifdef	OPTIMIZE_JUST_STAR
X    if (p[0] == '*' && p[1] == '\0')
X	return TRUE;
X#endif	/* OPTIMIZE_JUST_STAR */
X    return DoMatch(text, p) == TRUE;
X}
X
X
X
X#ifdef	TEST
X#include <stdio.h>
X
X/* Yes, we use gets not fgets.  Sue me. */
Xextern char	*gets();
X
X
Xmain()
X{
X    char	 p[80];
X    char	 text[80];
X
X    printf("Wildmat tester.  Enter pattern, then strings to test.\n");
X    printf("A blank line gets prompts for a new pattern; a blank pattern\n");
X    printf("exits the program.\n");
X
X    for ( ; ; ) {
X	printf("\nEnter pattern:  ");
X	(void)fflush(stdout);
X	if (gets(p) == NULL || p[0] == '\0')
X	    break;
X	for ( ; ; ) {
X	    printf("Enter text:  ");
X	    (void)fflush(stdout);
X	    if (gets(text) == NULL)
X		exit(0);
X	    if (text[0] == '\0')
X		/* Blank line; go back and get a new pattern. */
X		break;
X	    printf("      %s\n", wildmat(text, p) ? "YES" : "NO");
X	}
X    }
X
X    exit(0);
X    /* NOTREACHED */
X}
X#endif	/* TEST */
END_OF_FILE
  if test 4798 -ne `wc -c <'wildmat.c'`; then
    echo shar: \"'wildmat.c'\" unpacked with wrong size!
  fi
  # end of 'wildmat.c'
fi
echo shar: End of archive 14 \(of 15\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
