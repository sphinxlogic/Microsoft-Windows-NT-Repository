Newsgroups: comp.sources.misc
From: julian@vscn08.cern.ch (Julian James Bunn)
Subject:  v31i067:  flow - Fortran Structure Analysers, Part04/05
Message-ID: <1992Jul31.052643.466@sparky.imd.sterling.com>
X-Md4-Signature: d5759f357c5a92b40340a4ceeb85184e
Date: Fri, 31 Jul 1992 05:26:43 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: julian@vscn08.cern.ch (Julian James Bunn)
Posting-number: Volume 31, Issue 67
Archive-name: flow/part04
Environment: fortran, ffccc

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  Copyright Readme caschg.for chtbox.for chtlin.for
#   cmsflow.for floppy.h flow.cld flow.helpcms flow.hlp flow.l
#   flow.panel grinit.for iniarr.for make_cms.com make_vms.com
#   params.h procom.for prodes.for proqry.for tabent.for tables.h
#   trecom.h vmsflow.for
# Wrapped by kent@sparky on Thu Jul 30 23:38:14 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 5)."'
if test -f 'Copyright' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Copyright'\"
else
  echo shar: Extracting \"'Copyright'\" \(2847 characters\)
  sed "s/^X//" >'Copyright' <<'END_OF_FILE'
X************************************************************************
X*                                                                      *
X*                           CERN                                       *
X*                                                                      *
X*     EUROPEAN ORGANIZATION FOR PARTICLE PHYSICS                       *
X*                                                                      *
X*     Program name: FLOW   : Fortran Structure Analyzers               *
X*                                                                      *
X*     Author               : J.J.Bunn                                  *
X*                            CERN                                      *
X*                            CH-1211 GENEVA 23                         *
X*                            SWITZERLAND                               *
X*                            JULIAN at CERNVM (BITNET)                 *
X*                            VXCERN::JULIAN (DECNET) node 22.47        *
X*                            julian@vxcern.cern.ch (IP)                *
X*                                                                      *
X*     Copyright  CERN,  Geneva  1992  -  Copyright  and  any   other   *
X*     appropriate  legal  protection  of this computer program and     *
X*     associated documentation reserved  in  all  countries  of  the   *
X*     world.                                                           *
X*                                                                      *
X*     CERN undertakes no obligation  for  the  maintenance  of  this   *
X*     program  or  package,  nor responsibility for its correctness,   *
X*     and accepts no liability whatsoever resulting from the use  of   *
X*     it.                                                              *
X*                                                                      *
X*     Programs and documentation are provided solely for the use  of   *
X*     the organization to which they are distributed.                  *
X*     The program may be obtained from CERN subject to CERN            *
X*     distribution rules.                                              *
X*                                                                      *
X*     This program  may  not  be  copied  or  otherwise  distributed   *
X*     without  permission. This message must be retained on this and   *
X*     any other authorized copies.                                     *
X*                                                                      *
X*     The material cannot be sold. CERN should be  given  credit  in   *
X*     all references.                                                  *
X*                                                                      *
X************************************************************************
END_OF_FILE
  if test 2847 -ne `wc -c <'Copyright'`; then
    echo shar: \"'Copyright'\" unpacked with wrong size!
  fi
  # end of 'Copyright'
fi
if test -f 'Readme' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Readme'\"
else
  echo shar: Extracting \"'Readme'\" \(4330 characters\)
  sed "s/^X//" >'Readme' <<'END_OF_FILE'
XFLOW - Fortran Structure Analysers
X==================================
X
XThis file describes how to install Flow on VMS, Unix
Xand IBM/VM/CMS machines. 
X
XPlease read the COPYRIGHT file.
X
XThe posting includes a new version of the user guide for
XFloppy and Flow. This contains a detailed description of
Xthe various possibilities. The help files for the various
Xsystems (flow.hlp, flow.helpcms, and flow.l) should, however,
Xbe adequate for most uses.
X
XNote that Floppy is available on various archive servers for
Xanonymous ftp. For example, gatekeeper.dec.com has it in
Xdirectory pub/comp.sources.misc/volume12/ffccc .
X
X1) Unix Installation
X
X   To use Flow, you will need to already have installed Floppy.
X
X   This posting of Flow contains a new version of floppy.f
X   and floppy.l which you should move to the Floppy directory
X   and then re-invoke make. The new floppy.f just enables
X   the -t qualifier to allow an output for Flow to be written.
X   The new floppy.l man page describes the new option.
X
X   How to procede
X   ==============
X   Put all the distribution files in a subdirectory called
X   flow. Type make. This should generate a flow executable.
X   If your Fortran 77 compiler is not invoked by "f77" then
X   you will have to edit the makefile and change it accordingly.
X   (If you are building Flow in AIX, then the xlf compiler
X   may not allow .for suffixes. There is a suggested mod in
X   the makefile which takes care of this.)
X   
X   To test Flow, generate an input file for it using Floppy.
X   For example, using a source Fortran file called myfile.f :
X
X   floppy -t -cn myfile.f
X
X   flow -q myfile.f.floptre
X
X   If you are satisfied, move the man page flow.l to the right 
X   place on your system, and put flow in the appropriate place too.
X
X2) VMS Installation   
X
X   To use Flow, you will need to already have installed Floppy.
X
X   How to procede
X   ==============
X   Put all the distribution files in a subdirectory called
X   [.FLOW]. Set default to that directory, and type @MAKE_VMS.
X   This should generate a flow excutable, and a flow library.
X
X   To add the command for testing, edit the file FLOW.CLD.
X   Change the filename of the FLOW.EXE image so that it
X   corresponds to where FLOW.EXE actually is on your machine.
X   Exit the editor. Type SET COMMAND FLOW.
X
X   To test Flow, generate an input file for it using Floppy.
X   For example, using a source Fortran file called MYFILE.FOR :
X
X   FLOPPY /TREE /NOCHECKS MYFILE
X
X   FLOW /QUERY MYFILE
X
X   If you are satisfied, then add the command to the system
X   DCLTABLES (this requires privilege), by using the commands
X   SET COMM/TABLE=SYS$COMMON:[SYSLIB]DCLTABLES -
X       /OUT=SYS$COMMON:[SYSLIB]DCLTABLES FLOW
X   INSTALL REPLACE SYS$LIBRARY:DCLTABLES
X
X   This makes the command available for all newly logging in
X   users. Then add the FLOW.HLP to your user help library, using
X   a command of the form LIBRARY/INS SYS$HELP:USER.HLB FLOW.HLP
X
X3) VM/CMS Installation
X
X   To use Flow, you will need to already have installed Floppy.
X
X   How to procede
X   ==============
X   The Flow source makes use of INCLUDE directives; the filename
X   format of the target files is not compatible with the form
X   required for a GLOBAL MACLIB. This means that you will have to
X   expand the include files in all the modules. A procedure for
X   doing this (on a VMS machine!) is included in the posting as
X   MAKE_CMS.COM. This generates one large file called CMSFLOW FORTRAN
X   which should be then moved to the VM/CMS environment and compiled.
X   
X   The FLOW EXEC Rexx file is intended to be used either in line mode,
X   or via an IOS3270 panel. The panel for the latter option is
X   included as FLOW PANEL in the posting. But you don't need IOS3270
X   to run FLOW.
X
X   Once the CMSFLOW FORTRAN has been compiled, you should have a
X   CMSFLOW TEXT file. This is the program that will be loaded by
X   FLOW EXEC. Note that you will need a virtual machine of at least
X   12 MBytes to run FLOW. 
X
X   To test FLOW, generate an input file for it using FLOPPY. For
X   example, type:
X
X   FLOPPY myfile (NOCHECKS TREE
X   FLOW myfile (QUERY
X
X4) Problems and Bugs
X
X   If you find bugs in Flow, or have installation problems on a
X   specific machine, I would like to hear about them, although
X   I cannot guarantee to be able to help. Please mail
X   julian@vxcern.cern.ch.
X   
END_OF_FILE
  if test 4330 -ne `wc -c <'Readme'`; then
    echo shar: \"'Readme'\" unpacked with wrong size!
  fi
  # end of 'Readme'
fi
if test -f 'caschg.for' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'caschg.for'\"
else
  echo shar: Extracting \"'caschg.for'\" \(729 characters\)
  sed "s/^X//" >'caschg.for' <<'END_OF_FILE'
X      SUBROUTINE CASCHG(CINP,COUT)
XC! Convert any lower case to upper
X      INCLUDE 'params.h'
X      CHARACTER*(*) CINP
X      CHARACTER*(*) COUT
X      CHARACTER*1 CUP(26),CLO(26)
X      DATA CUP /'A','B','C','D','E','F','G','H','I','J','K','L','M',
X     &          'N','O','P','Q','R','S','T','U','V','W','X','Y','Z'/
X      DATA CLO /'a','b','c','d','e','f','g','h','i','j','k','l','m',
X     &          'n','o','p','q','r','s','t','u','v','w','x','y','z'/
X      LEN = LENOCC(CINP)
X      COUT = CINP
X      DO 1 I=1,LEN
X        DO 2 J=1,26
X          IF(CINP(I:I).EQ.CLO(J)) THEN
X            COUT(I:I) = CUP(J)
X            GOTO 3
X          ENDIF
X   2    CONTINUE
X        COUT(I:I) = CINP(I:I)
X   3  CONTINUE
X   1  CONTINUE
X      END
END_OF_FILE
  if test 729 -ne `wc -c <'caschg.for'`; then
    echo shar: \"'caschg.for'\" unpacked with wrong size!
  fi
  # end of 'caschg.for'
fi
if test -f 'chtbox.for' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'chtbox.for'\"
else
  echo shar: Extracting \"'chtbox.for'\" \(375 characters\)
  sed "s/^X//" >'chtbox.for' <<'END_OF_FILE'
X      SUBROUTINE CHTBOX(PXL,PYL,PXH,PYH)
XC! Plots a box 
X      INCLUDE 'lunits.h'
XC
X      WRITE(LOUTCH,*) pxl,' xrel ',pyl,' yrel moveto'
X      WRITE(LOUTCH,*) pxh,' xrel ',pyl,' yrel lineto'
X      WRITE(LOUTCH,*) pxh,' xrel ',pyh,' yrel lineto'
X      WRITE(LOUTCH,*) pxl,' xrel ',pyh,' yrel lineto'
X      WRITE(LOUTCH,*) 'closepath'
X      WRITE(LOUTCH,*) 'stroke'
X      END
END_OF_FILE
  if test 375 -ne `wc -c <'chtbox.for'`; then
    echo shar: \"'chtbox.for'\" unpacked with wrong size!
  fi
  # end of 'chtbox.for'
fi
if test -f 'chtlin.for' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'chtlin.for'\"
else
  echo shar: Extracting \"'chtlin.for'\" \(795 characters\)
  sed "s/^X//" >'chtlin.for' <<'END_OF_FILE'
X      SUBROUTINE CHTLIN(X1,Y1,X2,Y2,BX,BY)
XC! Calculate and plot box intersections
XC X1,Y1 coords of 1st box centre
XC X2,Y2 coords of 2nd box centre
XC BX,BY dimensions of the boxes
XC XS,YS coords of intersection with 1st box
XC XF,YF coords of intersection with 2nd box
X      INCLUDE 'lunits.h'
XC
X      RAT1 = 9999.
X      IF(Y1-Y2.NE.0.) RAT1 = (X2-X1)/(Y1-Y2)
X      RAT2 = 9999.
X      IF(RAT1.NE.0.) RAT2 = 1./RAT1
X      XD = BX*0.5*MIN(ABS(RAT1),1.)
X      YD = BY*0.5*MIN(ABS(RAT2),1.)
X      IF(RAT1.LT.0.) XD = -XD
X      YS=Y1-YD
X      YF=Y2+YD
X      XS=X1+XD
X      XF=X2-XD
X      WRITE(LOUTCH,100) XS,' xrel ',YS,' yrel moveto'
X      WRITE(LOUTCH,100) XF,' xrel ',YF,' yrel lineto'
X  100 FORMAT(1X,F10.5,A,F10.5,A)
X      WRITE(LOUTCH,*) 'closepath'  
X      WRITE(LOUTCH,*) 'stroke'
X      END
END_OF_FILE
  if test 795 -ne `wc -c <'chtlin.for'`; then
    echo shar: \"'chtlin.for'\" unpacked with wrong size!
  fi
  # end of 'chtlin.for'
fi
if test -f 'cmsflow.for' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cmsflow.for'\"
else
  echo shar: Extracting \"'cmsflow.for'\" \(946 characters\)
  sed "s/^X//" >'cmsflow.for' <<'END_OF_FILE'
X      PROGRAM FLOW
X      INCLUDE 'params.h'
X      INCLUDE 'lunits.h'               
X      INCLUDE 'jobcom.h'
X      INCLUDE 'trecom.h'
X      CHARACTER*80 CLINE
X      LOUT = 6
X      LINTRE = 50
X      LOUTCO = 60
X      LOUTRE = 61
X      LOUTCH = 96
X      LQERY = .FALSE.
X      LEXT = .FALSE.                               
X      LCHRT = .FALSE.
X      LTREE = .FALSE.
X      LCOMM = .FALSE.
X      READ(1,'(A)',END=999,ERR=999) CLINE
X      IF(INDEX(CLINE,'query').NE.0) LQERY = .TRUE.
X      IF(INDEX(CLINE,'externals').NE.0) LEXT = .TRUE.
X      IF(INDEX(CLINE,'graphics').NE.0) LCHRT = .TRUE.
X      IF(INDEX(CLINE,'chart').NE.0) LTREE = .TRUE.
X      IF(INDEX(CLINE,'common').NE.0) LCOMM = .TRUE.
X      IF(INDEX(CLINE,'node').NE.0) THEN
X         CLINE = CLINE(INDEX(CLINE,'node')+5:)
X         CTREE = CLINE(:INDEX(CLINE,' ')-1)
X      ENDIF
X      CALL PRODES
X      STOP
X  999 WRITE(LOUT,'(A)') ' FLOW: Error reading control file.'
X      STOP 1
X      END
END_OF_FILE
  if test 946 -ne `wc -c <'cmsflow.for'`; then
    echo shar: \"'cmsflow.for'\" unpacked with wrong size!
  fi
  # end of 'cmsflow.for'
fi
if test -f 'floppy.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'floppy.h'\"
else
  echo shar: Extracting \"'floppy.h'\" \(536 characters\)
  sed "s/^X//" >'floppy.h' <<'END_OF_FILE'
X      COMMON /FLOPPY/ CALLER(MXENT),CRABUF(MXENT),
X     &                TYPE(MXENT),CALLED(MXALL),CDABUF(MXALL),
X     &                CNAMES(MXCOM),UNUSED(MXCOM),CMMNT,
X     &                CARGNM(MARGS),CARGTY(MARGS),CARGDI(MARGD,2,MARGS),
X     &                CKALLN(MKALL)
X      COMMON /FLOPP1/ NENT,KALL,NCOM,NARGS,NKALL,NARGDI(MARGS),
X     &                KALLIF(MKALL),KALLDO(MKALL)
X      CHARACTER*50 CRABUF,CDABUF,CMMNT,CARGTY,CARGDI
X      CHARACTER*(MXNAM) CALLER,CALLED,CNAMES,CARGNM,CKALLN
X      CHARACTER*1 TYPE,UNUSED
END_OF_FILE
  if test 536 -ne `wc -c <'floppy.h'`; then
    echo shar: \"'floppy.h'\" unpacked with wrong size!
  fi
  # end of 'floppy.h'
fi
if test -f 'flow.cld' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flow.cld'\"
else
  echo shar: Extracting \"'flow.cld'\" \(564 characters\)
  sed "s/^X//" >'flow.cld' <<'END_OF_FILE'
X DEFINE VERB FLOW
X        IMAGE disk$cern:[JULIAN.FLOW.PRO]FLOW.EXE 
X        PARAMETER P1, PROMPT="Input data file from Floppy ",VALUE(TYPE=$FILE,REQUIRED)
X        QUALIFIER QUERY
X        QUALIFIER EXTERNALS
X        QUALIFIER COMMON_TABLE, VALUE(TYPE=$FILE)
X        QUALIFIER STRUCTURE_CHART, VALUE(TYPE=$FILE)
X        QUALIFIER IGNORE, VALUE(LIST)
X        QUALIFIER GRAPHICS, VALUE(TYPE=$FILE)
X        QUALIFIER NODE, VALUE,DEFAULT
X        QUALIFIER LOG
X
X        DISALLOW NODE AND NOT (STRUCTURE_CHART OR GRAPHICS)
X        DISALLOW IGNORE AND NOT STRUCTURE_CHART
END_OF_FILE
  if test 564 -ne `wc -c <'flow.cld'`; then
    echo shar: \"'flow.cld'\" unpacked with wrong size!
  fi
  # end of 'flow.cld'
fi
if test -f 'flow.helpcms' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flow.helpcms'\"
else
  echo shar: Extracting \"'flow.helpcms'\" \(5302 characters\)
  sed "s/^X//" >'flow.helpcms' <<'END_OF_FILE'
X.cm CAT:CMS
X.cm NAM:FLOW
X.cm EXP: Fortran Code Structure Analyser
X.cm DAT: 92.15.07
X.cm A/R: J.J.Bunn
X.cm KEY: FLOPPY FORTRAN STRUCTURE CHART STRUCTURE_CHART
X.cm KEY: SC SASD FLOP CODE
X.cm ABS: A program which allows the user to plot the subroutine
X.cm ABS: calling tree of a Fortran program passed through FLOPPY.
X.cm ABS: The calling tree may also be explored interactively.
X.cm ABS: Other options include the production of a table
X.cm ABS: of COMMON block names and the routines in which
X.cm ABS: each is used.
X.cm FLG: LOCAL
X.cm END:
X 
X 
XFLOW  (Structure Analysers)
X 
XUsers are referred to the FLOPPY writeup (DD/US/112) available in the UCO
Xfor full details of the use of FLOW.
X 
XFLOW is used to produce subroutine calling trees, COMMON block usage
Xtables, and to interactively explore subroutine calling trees.
XIt is used after a FORTRAN program has been passed through FLOPPY.
XVarious options are available, including suppression of external
Xmodule names from the produced tree, and specification of the top
Xnode module name.
XGraphics output is in the form of a file of PostScript.
XThis graphics output is intended to represent the SASD Structure
XChart corresponding to the source FORTRAN, and, as such, may be used
Xas a "backward engineering" tool.
X 
XNote: You need at least a 12 M machine to run FLOW.
X 
XFLOW is invoked via a panel or from the command line as follows:
X 
X+--------+--------------------------------------------------------------+
X|        |                                                              |
X| FLOW   | [ ? | [fn [ft [fm]]]  [( Options ]]                          |
X|        |                                                              |
X|        | Options:                                                     |
X|        |                                                              |
X|        | [QUERY]                                                      |
X|        | [EXTERNALS]                                                  |
X|        | [STRUCTURE_CHART   fn [ft [fm]]]                             |
X|        | [GRAPHICS          fn [ft [fm]]]                             |
X|        | [NODE              nodename]                                 |
X|        | [COMMON_TABLE      fn [ft [fm]]]                             |
X+--------+--------------------------------------------------------------+
X 
Xwhere:
X 
X          When FLOW is entered without any operands or options,
X          a panel will be displayed in which details of the FLOW
X          job may be entered.
X 
X?         If this is the only operand this HELP file will be displayed.
X 
Xfn ft fm
X          Specifies the name of a binary file produced using the
X          TREE option in FLOPPY.
X 
XQUERY     Enter the interactive exploration facility of FLOW !
X          You will be shown the full list of module names in the
X          source, and can then specify one of them to see which
X          modules it calls, and which modules call it. In this
X          way you can move freely around the tree.
X 
XSTRUCTURE_CHART    fn ft fm
X          Specifies that a text file be written containing the
X          calling tree of the source FORTRAN. The tree shows modules
X          local to the code and external, and indicates whether they
X          appear in IF or DO clauses. Stub modules (no calls), external
X          modules (not local), multiply-called modules and sub-trees
X          are all clearly indicated. If the FORTRAN source contained
X          lines after each module declaration of the form:
X          C! This is a short comment
X          then these comments are shown against each module name in the
X          tree.
X 
XGRAPHICS  fn ft fm
X          Specifies that a graphics metafile (either GKS or PostScript)
X          be written, which, when interpreted, will show the SASD-like
X          structure chart of the source FORTRAN. It is recommended
X          NOT to ask for EXTERNALS with this option. An attempt
X          is made to optimize the positions of modules on the page,
X          in order to minimise line crossings etc.. But this is often
X          unsuccessful!
X 
XNODE      nodename
X          Specifies the top node in either the text or graphics
X          structure chart. This is useful for restricting the output
X          to a particular sub-tree of interest. The value nodename
X          must be a PROGRAM, SUBROUTINE or FUNCTION name in the
X          source FORTRAN.
X 
XEXTERNALS Specifies that modules external to the source FORTRAN
X          (e.g. SIN, COS, UCOPY, HBOOK1 etc.) be shown in the tree.
X 
XCOMMON_TABLE    fn ft fm
X          Specifies that a table be written containing, on the y-axis
X          the names of all COMMON blocks, and on the x-axis all the
X          module names, contained in the source FORTRAN. At each
X          place in the table a 'Y' indicates that the COMMON block
X          appears in that module, and at least one variable from it
X          is used in the module, a 'N' indicates that the COMMON
X          block is declared but not used, and a blank indicates that
X          the COMMON block is not declared in that module.
X 
XExample
X          To interactively explore the calling tree of your program
X          MCARLO FORTRAN, use the following two commands:
X 
X          FLOPPY MCARLO (CHECKS NONE TREE DISK
X          FLOW MCARLO (QUERY
END_OF_FILE
  if test 5302 -ne `wc -c <'flow.helpcms'`; then
    echo shar: \"'flow.helpcms'\" unpacked with wrong size!
  fi
  # end of 'flow.helpcms'
fi
if test -f 'flow.hlp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flow.hlp'\"
else
  echo shar: Extracting \"'flow.hlp'\" \(4030 characters\)
  sed "s/^X//" >'flow.hlp' <<'END_OF_FILE'
X1 FLOW
X 
X FLOW uses a file produced by Floppy (see HELP FLOPPY) to produce reports 
X on the structure of the Fortran program on which Floppy was used.
X
X There is a "FLOPPY User Guide" DD/US/112 which describes the use
X of FLOW and FLOPPY, available in the UCO Batiment 513.
X
X Syntax:
X  
X FLOW input_file /qualifier [/qualifiers] 
X 
X Note that at least one qualifier must be given.
X
X If you have problems or questions about FLOW or FLOPPY, then please
X mail JULIAN@VXCERN.CERN.CH.
X
X FLOW is based on an original idea by P.Palazzi.
X
X2 Parameter
Xinput_file
X
X  The input file is a file of type .FLOPTRE produced by Floppy.
X  This file is easily created by using a Floppy command like:
X
X  $ floppy myfile /nochecks /tree
X
X  This file is a binary file, and cannot be viewed on the
X  terminal. It can only be processed by Flow. The default
X  file type is .floptre. A Flow command to operate on the
X  floptre file produced above might thus be:
X
X  $ flow myfile /structure
X
X 
X2 Qualifiers
X 
X/QUERY
X 
X  /QUERY
X 
X  Enter an interactive FLOW session, where the routine calling
X  tree can be explored by specifying the node name, and seeing
X  all routines calling the node and all routines that are called
X  by the node. 
X
X/STRUCTURE_CHART 
X
X  /STRUCTURE_CHART[=(filename)]
X  
X  Create a file containing the calling tree of the source
X  program. Each SUBROUTINE, PROGRAM or FUNCTION in the 
X  source is a node in the calling tree. Each node is
X  displayed in the chart so that one can see a) which
X  other nodes call it, b) which nodes it calls, c) whether
X  the node is external, a stub, a subtree node, d) the
X  IF or DO level if the node is in an IF or DO clause.
X  
X  In addition, if the source FORTRAN contains a comment
X  line IMMEDIATELY after each procedure declaration, e.g.
X        SUBROUTINE INIJOB
X  C! This subroutine initialises the job
X 
X  (the ! sign is important), then this comment is extracted
X  and put as a label to the node name in the structure 
X  chart. 
X
X/GRAPHICS
X 
X  /GRAPHICS=(filename)
X 
X  Cause a picture file to be written, which may afterwards
X  be viewed using a PostScript previewer (if /POSTSCRIPT
X  is also specified). The picture file contains an approximate
X  representation of the equivalent SASD structure chart that
X  corresponds to the existing state of the Fortran code.
X  An effort is made to position the modules (SUBROUTINEs, 
X  FUNCTIONs, etc.) on the plot so that line crossing is 
X  minimised, but this is not always successful! 
X
X  It is recommended to use the /NOEXTERNAL qualifier together 
X  with the /GRAPHICS qualifier: this helps to minimise the 
X  complexity of the plot.
X
X/NODE 
X
X  /NODE=(nodename)
X 
X  Specify the name of the node in the program calling tree
X  from which the flow should begin.
X  
X  NB This qualifier MUST only be used with the STRUCTURE_CHART 
X     and GRAPHICS qualifiers.
X
X/EXTERNALS 
X
X  /EXTERNALS  (D)
X  /NOEXTERNALS
X  
X  Specify whether the calling tree should contain the names
X  of procedures external to the program or not. You should
X  use this if you wish to suppress nodes such as SIN, COS,
X  UCOPY etc from the flow.
X
X  NB This qualifier can only be used with the STRUCTURE_CHART,
X     GRAPHICS and QUERY qualifiers.
X
X/COMMON_TABLE 
X
X  /COMMON_TABLE[=(filename)]
X
X  Create a table containing procedure names on one axis, and
X  COMMON block names on the other, and indicate for each
X  procedure/COMMON intersection whether the COMMON block is
X  used or not in the procedure.  
X 
X/LOG
X 
X  /LOG  (D)
X  /NOLOG
X 
X  Show a summary of the FLOW command parsing, or not.
X
X2 Examples
X 
X  You must have a data file obtained using FLOPPY:
X 
X  $ FLOPPY /TREE /NOCHECKS  myfile.FOR
X 
X  the FLOPPY data will be called "myfile.FLOPTRE".
X 
X  Create a structure chart called STRUCTURE.CHT showing
X  the calling sequence in myfile.FOR:
X 
X  $ FLOW myfile /STRUCTURE=STRUCTURE.CHT
X
X  Ignore all externals, and start from the routine called INIJOB :
X 
X  $ FLOW myfile /STRUC /NOEXT /NODE=INIJOB
X 
X  Enter the interactive exploration facility of FLOW
X 
X  $ FLOW myfile /QUERY
X
END_OF_FILE
  if test 4030 -ne `wc -c <'flow.hlp'`; then
    echo shar: \"'flow.hlp'\" unpacked with wrong size!
  fi
  # end of 'flow.hlp'
fi
if test -f 'flow.l' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flow.l'\"
else
  echo shar: Extracting \"'flow.l'\" \(3388 characters\)
  sed "s/^X//" >'flow.l' <<'END_OF_FILE'
X.TH flow 1 "16th July 1992"  "CERN"
X.SH NAME
Xflow \- Fortran Structure Analysers 
X.SH SYNOPSIS
X.B flow 
X[
X.B \-l
X] [
X.B \-c common-text
X] [
X.B \-q
X] [
X.B \-n node
X] [
X.B \-s text-chart
X] [
X.B \-g graphics-chart
X] [
X.B \-E
X] [
X.B \-i ignore-list
X] [ file ]
X.SH DESCRIPTION
X.I Flow
Xis a companion tool to Floppy, which operates on a file produced
Xwith the -t option of Floppy. Using Flow, one can generate various
Xreports which describe the structure of the original Fortran program
Xanalysed by Floppy.
X.SH PARAMETERS
XThe input 
X.I file 
Xis a file of type .floptre produced by Floppy.
XThis file is easily created by using a Floppy command like:
X.PP
Xfloppy -t -cn myfile.f 
X.PP
XThis file is a binary file, and cannot be viewed on the
Xterminal. It can only be processed by Flow. 
XA Flow command to operate on the floptre file produced above 
Xmight thus be:
X.PP
Xflow -s myfile.f.floptre 
X.PP
X.SH OPTIONS
X.IP \fB\-l\fR 12
XThe
X.I logging
Xoption causes Flow to produce a verbose description of the parsing
Xof the selected options.
X.IP \fB\-c\ common-text \fR 12
XThe 
X.I common
Xoption creates a table containing procedure names on one axis, and
XCOMMON block names on the other, and indicates for each
Xprocedure/COMMON intersection whether the COMMON block is
Xused or not in the procedure.  
X.IP \fB\-E\fR 12
XThe
X.I no Externals
Xoption specifies that external routines are not to be included
Xin any output selected.
X.IP \fB\-s\ text-chart\fR 12
XThe
X.I structure-chart
Xoption creates a file containing the calling tree of the source
Xprogram. Each SUBROUTINE, PROGRAM or FUNCTION in the 
Xsource is a node in the calling tree. Each node is
Xdisplayed in the chart so that one can see a) which
Xother nodes call it, b) which nodes it calls, c) whether
Xthe node is external, a stub, a subtree node, d) the
XIF or DO level if the node is in an IF or DO clause.
X.br
XIn addition, if the source FORTRAN contains a comment
Xline IMMEDIATELY after each procedure declaration, e.g.
X.br
X        SUBROUTINE INIJOB
X  C! This subroutine initialises the job
X.br 
X(the ! sign is used as the trigger), then this comment is extracted
Xand put as a label to the node name in the structure chart.
X.IP \fB\-i\ ignore-list\fR 12
XThe
X.I ignore
Xoption specifies that, for the -s option, the given list
Xof module names are to be excluded from the calling tree output.
XSpecify the module names separated by commas, for example:
X.br
X-iFRED,BILL,HARRY,SUSAN
X.IP \fB\-g graphics-chart\fR 12
XThe
X.I graphics
Xoption causes a picture file to be written, which may afterwards
Xbe viewed using a PostScript previewer.
XThe picture file contains an approximate
Xrepresentation of the equivalent SASD structure chart that
Xcorresponds to the existing state of the Fortran code.
XAn effort is made to position the modules (SUBROUTINEs, 
XFUNCTIONs, etc.) on the plot so that line crossing is 
Xminimised, but this is not always successful! 
X.br
XIt is recommended to use the -E option together 
Xwith the -g option: this helps to minimise the 
Xcomplexity of the plot.
X.br
XIf the -n option has not been specified, then Flow will search
Xfor the module that calls the most other modules, and use this
Xas the root of the tree.
X.IP \fB\-n node\fR 12
XThe
X.I node
Xoption specifies the name of the module from which the tree
Xshould begin. The node name given should thus correspond to
Xa module name in the source Fortran. 
X
X.SH SEE ALSO
X.PP
Xfloppy(l), f77(1)
END_OF_FILE
  if test 3388 -ne `wc -c <'flow.l'`; then
    echo shar: \"'flow.l'\" unpacked with wrong size!
  fi
  # end of 'flow.l'
fi
if test -f 'flow.panel' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flow.panel'\"
else
  echo shar: Extracting \"'flow.panel'\" \(658 characters\)
  sed "s/^X//" >'flow.panel' <<'END_OF_FILE'
X;PANEL1
X.CYF HELP CMS QUIT
X====> FLOW VERSION 2.00 <=========> Analyse Fortran Code <==============>
X 
X%&err
X 
X%Input for @FLOW
X       Binary file from FLOPPY          %==>  ^20&filename
X 
X%Interactively explore the calling tree %==>  ^3&query
X 
X%Structure %Chart
X        Node name at top of chart       %==>  ^8&node
X         (Default is main program)
X        File for text chart             %==>  ^20&structure_chart
X        File for graphical chart        %==>  ^20&graphics
X        Include EXTERNALs in chart ?    %==>  ^3&externals
X 
X%COMMON block table file                %==>  ^20&common_table
X 
XPF1:%Help   PF2:%Enter %a %CMS %Command     PF3:%Exit
END_OF_FILE
  if test 658 -ne `wc -c <'flow.panel'`; then
    echo shar: \"'flow.panel'\" unpacked with wrong size!
  fi
  # end of 'flow.panel'
fi
if test -f 'grinit.for' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'grinit.for'\"
else
  echo shar: Extracting \"'grinit.for'\" \(1620 characters\)
  sed "s/^X//" >'grinit.for' <<'END_OF_FILE'
X      SUBROUTINE GRINIT(SIZEX,SIZEY,TITLE)
XC! Initialise the graphics package
XC SIZEX is the (real) width of the plot (world coords)
XC SIZEY               height
XC TITLE is the text of the title
XC
XC The purpose of the routine is to initialise the
XC graphics environment to a plot of dimensions
XC sizex,sizey, with appropriate text height .
XC At the end of processing, ENTRY GRCLOSE is called
XC to terminate the plot.
XC
X      INCLUDE 'jobcom.h'
X      INCLUDE 'lunits.h'
X      CHARACTER*(*) TITLE
XC
X      FACX = SIZEX/7.
X      FACY = SIZEY/7.
X      L = LENOCC(TITLE)
X      WRITE(LOUTCH,'(A)') '%! PostScript output from FLOW'
X      WRITE(LOUTCH,'(A)') '/inch { 72 mul } def'
X      WRITE(LOUTCH,*) '/xrel { ',facx,' div inch } def'
X      WRITE(LOUTCH,*) '/yrel { ',facy,' div inch } def'
X      WRITE(LOUTCH,*) '/Helvetica-Bold findfont 14 scalefont setfont'
X      WRITE(LOUTCH,'(A)') '3.2 inch 7.7 inch moveto'
X      WRITE(LOUTCH,'(3A)') '(Flow for node ',TITLE(:L),') show'
X      WRITE(LOUTCH,'(A)') '.1 inch setlinewidth'
X      WRITE(LOUTCH,'(A)') '0.5 inch 0.5 inch moveto'
X      WRITE(LOUTCH,'(A)') '7.5 inch 0.5 inch lineto'
X      WRITE(LOUTCH,'(A)') '7.5 inch 7.5 inch lineto'
X      WRITE(LOUTCH,'(A)') '0.5 inch 7.5 inch lineto'
X      WRITE(LOUTCH,'(A)') 'closepath'
X      WRITE(LOUTCH,'(A)') 'stroke'
X      WRITE(LOUTCH,'(A)') '0.5 inch 0.5 inch translate'
X      WRITE(LOUTCH,'(A)') '.01 inch setlinewidth'
X      WRITE(LOUTCH,*) '/Helvetica-Bold findfont 8 scalefont setfont'
X      RETURN
XC
XC ENTRY GRCLOSE
XC
X      ENTRY GRCLOSE
XC! Close the graphics package
X      WRITE(LOUTCH,'(A)') 'showpage grestore'
X      END
END_OF_FILE
  if test 1620 -ne `wc -c <'grinit.for'`; then
    echo shar: \"'grinit.for'\" unpacked with wrong size!
  fi
  # end of 'grinit.for'
fi
if test -f 'iniarr.for' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'iniarr.for'\"
else
  echo shar: Extracting \"'iniarr.for'\" \(357 characters\)
  sed "s/^X//" >'iniarr.for' <<'END_OF_FILE'
X      SUBROUTINE INIARR
XC! Initialise arrays
X      INCLUDE 'params.h'
X      INCLUDE 'tables.h'
XC
X      NPROC = 0
X      NCOMM = 0
X      DO 5 IP=1,MAXPRO
X         PROCED_DONE(IP) = .FALSE.
X         PROCED_EXTERN(IP) = .FALSE.
X         PROCED_LEVEL(IP) = 0
X         DO 6 IC=1,MAXCOM
X            COMMON_USED(IP,IC) = ' '
X   6  CONTINUE
X   5  CONTINUE
X      END
END_OF_FILE
  if test 357 -ne `wc -c <'iniarr.for'`; then
    echo shar: \"'iniarr.for'\" unpacked with wrong size!
  fi
  # end of 'iniarr.for'
fi
if test -f 'make_cms.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make_cms.com'\"
else
  echo shar: Extracting \"'make_cms.com'\" \(728 characters\)
  sed "s/^X//" >'make_cms.com' <<'END_OF_FILE'
X$! This procedure makes a complete FLOW program for
X$! compilation on IBM/CMS.
X$ copy *.for/excl=(vmsflow.for,unixflow.for) flow.fortran/log
X$ purge flow.fortran
X$ open/read in flow.fortran
X$ open/write out cmsflow.fortran
X$loop:
X$ read/end=end_loop/err=end_loop in line
X$ if f$locate("INCLUDE '",line) .eq. f$length(line)
X$ then
X$   write out "''line'"
X$   goto loop
X$ endif
X$ file = f$element(1,"'",line) - "'"
X$ write sys$output "Including ''file'"
X$ open/read infile 'file
X$loop2:
X$ read/end=end_loop2/err=end_loop2 infile linein
X$ write out "''linein'"
X$ goto loop2
X$end_loop2:
X$ close infile
X$ goto loop
X$end_loop:
X$ close in
X$ close out
X$ purge cmsflow.fortran
X$ delete flow.fortran.
X$ write sys$output "Finished"
X$ exit
END_OF_FILE
  if test 728 -ne `wc -c <'make_cms.com'`; then
    echo shar: \"'make_cms.com'\" unpacked with wrong size!
  fi
  # end of 'make_cms.com'
fi
if test -f 'make_vms.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'make_vms.com'\"
else
  echo shar: Extracting \"'make_vms.com'\" \(521 characters\)
  sed "s/^X//" >'make_vms.com' <<'END_OF_FILE'
X$! This procedure creates FLOW.EXE from its component Fortran
X$! source files.
X$! It assumes it is being executed in a dedicated [.flow] subdirectory.
X$loop1:
X$ file = f$search("*.for")
X$ if file .eqs. "" then goto end_loop1
X$ fortran 'file
X$ goto loop1
X$end_loop1:
X$ library/create flow.olb
X$loop2:
X$ file = f$search("*.obj")
X$ if file .eqs. "" then goto end_loop2
X$ library/insert flow 'file
X$ goto loop2
X$end_loop2:
X$ library/delete=flow flow
X$ link/exe=flow.exe vmsflow,flow/lib
X$ write sys$output "Finished."
X$ exit
END_OF_FILE
  if test 521 -ne `wc -c <'make_vms.com'`; then
    echo shar: \"'make_vms.com'\" unpacked with wrong size!
  fi
  # end of 'make_vms.com'
fi
if test -f 'params.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'params.h'\"
else
  echo shar: Extracting \"'params.h'\" \(337 characters\)
  sed "s/^X//" >'params.h' <<'END_OF_FILE'
X      PARAMETER (MXCHR=130,MXNAM=8,NDIS=4,MTITL=5,MPAGL=60)
X      PARAMETER (MNLEV=200,MLEV=20,MSUBT=2000,MXIGN=100,MXOFF=6)
X      PARAMETER (LCDOIF=32,MXLIN=130,LPSTA=80,MLEN=256)
X      PARAMETER (MAXPRO=1200,MAXCALL=200,MAXCOM=200,LCMMNT=64)
X      PARAMETER (MXENT=50,MXALL=100,MXCOM=100)
X      PARAMETER (MARGS=50,MARGD=50,MKALL=100)
END_OF_FILE
  if test 337 -ne `wc -c <'params.h'`; then
    echo shar: \"'params.h'\" unpacked with wrong size!
  fi
  # end of 'params.h'
fi
if test -f 'procom.for' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procom.for'\"
else
  echo shar: Extracting \"'procom.for'\" \(2805 characters\)
  sed "s/^X//" >'procom.for' <<'END_OF_FILE'
X      SUBROUTINE PROCOM
XC! Produce the COMMON block table
X      INCLUDE 'params.h'
X      INCLUDE 'lunits.h'
X      INCLUDE 'trecom.h'
X      INCLUDE 'tables.h'
X      PARAMETER (LLINE=130,LOFF=10,MLINE=(LLINE-LOFF)/2,LPAGE=50)
X      CHARACTER*(LLINE) CLINE
X      CHARACTER*(LLINE+1) CTEMP
XC
X      CTEMP(:LOFF) = ' '
X      CTEMP(LOFF+1:LOFF+1) = '+'
X      DO 7 I=1,LLINE-LOFF-1
X        CTEMP(LOFF+1+I:LOFF+1+I) = '-'
X    7 CONTINUE
X      CTEMP(LLINE+1:LLINE+1) = '+'
XC
XC
X      WRITE(LOUT,'(A)') ' '
X      WRITE(LOUT,'(A)') ' PROCOM Begins ....'
X      WRITE(LOUT,'(A)') ' '
XC
XC write top page
XC
X      WRITE(LOUTCO,666)
X  666 FORMAT(1X,20('*'),'              ProCom             ',20('*'),
X     &     /,1X,20(' '),'              ======             ',20(' '),
X     &     ///,1X,20(' '),' Module names appear along x-axis',
X     &     /,1X,20(' '),' COMMON block names along y-axis',
X     &     /,
X     &     /,1X,20(' '),' <Y>  ==> COMMON used in module'
X     &     /,1X,20(' '),' <N>  ==> COMMON not used (but is DECLARED)',
X     &     /,1X,20(' '),' < >  ==> COMMON not DECLARED',
X     &     /,1X,20('*'),'*********************************',20('*'))
X      NPAGE = 0
X      NCOLS = 0
X    1 CONTINUE
X      IF(NPAGE*LPAGE/2.GE.NCOMM) GOTO 110
X    2 CONTINUE
X      IF(NCOLS.GE.NPROC) GOTO 100
XC
XC move to new page
XC
X      WRITE(LOUTCO,490)
X  490 FORMAT(1H1)
X      DO 5 ILET = 1,6
X        CLINE(:) = ' '
X        DO 10 IPRO=1,MIN(NPROC,MLINE)
X          IPRO1 = IPRO+NCOLS
X          IF(IPRO1.GT.NPROC) GOTO 11
X          IPOS = IPRO*2 + LOFF
X          IF(LENOCC(PROCED_NAME(IPRO1)).LT.ILET) THEN
X            CLINE(IPOS:IPOS) = ' '
X          ELSE
X            CLINE(IPOS:IPOS) = PROCED_NAME(IPRO1)(ILET:ILET)
X          ENDIF
X   10   CONTINUE
X   11   CONTINUE
X        WRITE(LOUTCO,'(A)') CLINE(:LLINE)
X    5 CONTINUE
XC
XC now loop over all common names
XC
X      WRITE(LOUTCO,'(A)') CTEMP(:LLINE)
X      DO 15 ICOM=1,MIN(NCOMM,LPAGE/2)
X        ICOM1 = ICOM+NPAGE*LPAGE/2
X        IF(ICOM1.GT.NCOMM) GOTO 16
X        CLINE = COMMON_NAME(ICOM1)
X        LINE = LENOCC(CLINE)
XC
XC now find procedures using this common
XC loop over them, constructing cline
XC
X        DO 20 IPROC=NCOLS+1,MIN(NCOLS+MLINE,NPROC)
X          IPOS1 = IPROC - NCOLS
X          IPOS = IPOS1*2 + LOFF -1
X          CLINE(IPOS:IPOS) = COMMON_USED(IPROC,ICOM)
X   20   CONTINUE
X        CLINE(10:10) = '|'
X        CLINE(LLINE:LLINE) = '|'
X        WRITE(LOUTCO,'(1X,A)') CLINE(:LLINE)
X        CLINE = ' '
X        CLINE(10:10) = '|'
X        CLINE(LLINE:LLINE) = '|'
XC       WRITE(LOUTCO,'(1X,A)') CLINE(:LLINE)
X   15 CONTINUE
X   16 CONTINUE
X      WRITE(LOUTCO,'(A)') CTEMP(:LLINE)
X   90 CONTINUE
X      NCOLS = NCOLS+MLINE
X      GOTO 2
X  100 CONTINUE
X      NPAGE = NPAGE+1
X      NCOLS = 0
X      GOTO 1
X  110 CONTINUE
X      WRITE(LOUT,'(A)') ' PROCOM Finished'
X      END
END_OF_FILE
  if test 2805 -ne `wc -c <'procom.for'`; then
    echo shar: \"'procom.for'\" unpacked with wrong size!
  fi
  # end of 'procom.for'
fi
if test -f 'prodes.for' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'prodes.for'\"
else
  echo shar: Extracting \"'prodes.for'\" \(675 characters\)
  sed "s/^X//" >'prodes.for' <<'END_OF_FILE'
X      SUBROUTINE PRODES
XC! Steer the FLOW program
X      INCLUDE 'jobcom.h'
X      INCLUDE 'lunits.h'
X      LOUT  = 6
X      LINTRE = 50
XC
XC Initialise some arrays
XC
X      CALL INIARR
XC
XC process the input data from FLOP into tables
XC
X      IPASS = 1
X      CALL RDFLOP(IPASS)
XC
XC find the external routine names
XC
X      CALL EXTERN
XC
XC produce the tree chart
XC
X      IF(LTREE) CALL PROTRE
XC
XC produce the graphical structure chart
XC
X      IF(LCHRT) CALL PROCHT
XC
XC produce the subroutine headers
XC
XC      IF(LSUBS) CALL PROSUB
XC
XC produce the common block table
XC
X      IF(LCOMM) CALL PROCOM
XC
XC enter the subroutine tree query routine
XC
X      IF(LQERY) CALL PROQRY
XC
X      END
END_OF_FILE
  if test 675 -ne `wc -c <'prodes.for'`; then
    echo shar: \"'prodes.for'\" unpacked with wrong size!
  fi
  # end of 'prodes.for'
fi
if test -f 'proqry.for' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'proqry.for'\"
else
  echo shar: Extracting \"'proqry.for'\" \(4274 characters\)
  sed "s/^X//" >'proqry.for' <<'END_OF_FILE'
X      SUBROUTINE PROQRY
XC! Interactively look at the tree
X      PARAMETER (ICOMM=40,LLINE=80)
X      INCLUDE 'params.h'
X      INCLUDE 'tables.h'
X      INCLUDE 'floppy.h'
X      INCLUDE 'lunits.h'
X      INCLUDE 'trecom.h'
X      CHARACTER*(MXNAM) CNAM,CNAM2,CIN,CTEMP,CROUT(MAXPRO)
X      CHARACTER*(LLINE) CLINE(MAXPRO)
X      INTEGER SEARCH
X      EXTERNAL SEARCH
X      LOGICAL OK
XC
X      WRITE(LOUT,'(A)') ' '
X      WRITE(LOUT,'(A)') ' PROQRY Begins ....'
X      WRITE(LOUT,'(A)') ' '
XC
X      IDONE = 0
X      WRITE(LOUT,'(A)') ' Show list of routines ? '
X      READ(5,'(A)') CTEMP
X      CALL CASCHG(CTEMP,CIN)
X    8 CONTINUE
X      IF(CIN(:1).EQ.'Y') THEN
X         WRITE(6,'(A)') ' Routines in the tree (in source order)'
X         IF(.NOT.LEXT) WRITE(6,'(A)') ' (Excluding externals)'
X         WRITE(6,'(A)') ' --------------------------------------'
X         IF(LEXT) THEN
X            WRITE(6,100) (PROCED_NAME(I),I=1,NPROC)
X         ELSE IF(IDONE.EQ.0) THEN
X            IOUT = 0
X            DO 22 I=1,NPROC
X               IF(PROCED_EXTERN(I)) GOTO 22
X               IOUT = IOUT + 1
X               CROUT(IOUT) = PROCED_NAME(I)
X   22       CONTINUE
X            WRITE(6,100) (CROUT(I),I=1,IOUT)
X            IDONE = 1
X         ELSE
X            WRITE(6,100) (CROUT(I),I=1,IOUT)
X         ENDIF
X  100    FORMAT((1X,10A))
X      ENDIF
XC
X    2 CONTINUE
X      WRITE(LOUT,'(A)') ' Which routine ? (? for list) '
X      READ(5,'(A)') CTEMP
X      CALL CASCHG(CTEMP,CIN)
X      IF(INDEX(CIN,' ').EQ.1) GOTO 999
X      IF(CIN.EQ.'?') THEN
X         CIN = 'Y'
X         GOTO 8
X      ENDIF
X    9 CNAM = CIN
X      L = INDEX(CIN,' ')-1
X      IF(L.EQ.1.AND.CIN.EQ.'Q') GOTO 999
X      IFOUN = SEARCH(CNAM)
X      IF(IFOUN.EQ.0) THEN
X         WRITE(6,'(1X,A,A)') CNAM,' is not in the source !'
X         GOTO 2
X      ENDIF
X      IPNAM = IFOUN
XC
X      IOFF  = 0
X      ILINE = 0
X      IF(PROCED_NCALLEDBY(IPNAM).LE.0) THEN
XC NO CALLERS
X         ILINE = ILINE + 1
X         CLINE(ILINE)(:LLINE) = ' '
X      ELSE 
XC CALLERS ... FIND THEM
X         DO 5 IPNAM2=1,NPROC
X            IF(PROCED_NCALLS(IPNAM2).LE.0) GOTO 5
X            DO 6 IC=1,PROCED_NCALLS(IPNAM2)
X               IF(PROCED_CALLS(IPNAM2,IC).NE.IPNAM) GOTO 6            
X               ILINE = ILINE + 1
X               CLINE(ILINE)(:LLINE) = ' '
X               CLINE(ILINE)(:MXNAM) = PROCED_NAME(IPNAM2)
X               CLINE(ILINE)(ICOMM:LLINE) = PROCED_DESCRIP(IPNAM2)
X               GOTO 5
X    6       CONTINUE
X    5    CONTINUE
X      ENDIF
XC
X      ICENT = MXNAM/2+ 2 + IOFF
X      ILINE = ILINE + 1
X      CLINE(ILINE)(:LLINE) = ' '
X      IF(PROCED_NCALLEDBY(IPNAM).GE.1) THEN
X         CLINE(ILINE)(ICENT:ICENT+5) = '|---- '
X      ENDIF
X      IOFF = ICENT + 6
XC
X      CLINE(ILINE)(IOFF:IOFF+MXNAM) = CNAM
X      CLINE(ILINE)(ICOMM:LLINE) = PROCED_DESCRIP(IPNAM)
X      IOFF = ICENT + 7 + MXNAM/2
X      IF(PROCED_NCALLS(IPNAM).EQ.0) THEN
X        CLINE(ILINE)(IOFF+1:IOFF+1) = '.'
X        IF(PROCED_EXTERN(IPNAM)) 
X     &     CLINE(ILINE)(IOFF+1:IOFF+1) = '*'
X      ELSE IF(PROCED_NCALLS(IPNAM).GE.1) THEN
X        DO 7 IC=1,PROCED_NCALLS(IPNAM)
X          IPNAM2 = PROCED_CALLS(IPNAM,IC)
X          IF(.NOT.LEXT.AND.PROCED_EXTERN(IPNAM2)) GOTO 7
X          ILINE = ILINE + 1
X          CLINE(ILINE)(:LLINE) = ' '
X          CLINE(ILINE)(IOFF:IOFF+6) = '|---- '
X          INOFF = IOFF + 7
X          CLINE(ILINE)(INOFF:INOFF+MXNAM) = PROCED_NAME(IPNAM2)
X          CLINE(ILINE)(ICOMM:LLINE) = PROCED_DESCRIP(IPNAM2)
X    7   CONTINUE
X      ENDIF
XC
XC WRITE OUT TREE
XC
X      WRITE(6,200)
X  200 FORMAT(1X,79('-'),/,1X,'Caller(s)  Node        Calls   ',
X     &       '              Description',
X     &     /,1X,79('-'))
X      WRITE(6,210) (CLINE(I),I=1,ILINE)
X  210 FORMAT(1X,A)
X      WRITE(6,220)
X  220 FORMAT(1X,79('-'))
XC
X      WRITE(6,'(A)') ' '
X      WRITE(6,'(A,A)') ' What next ? [L=list routines,Q=quit,',
X     &      'or enter routine name]'
X      READ(5,'(A)') CTEMP
X      CALL CASCHG(CTEMP,CIN)
X      IF(INDEX(CIN,' ').EQ.1) GOTO 999
X      IF(INDEX(CIN,' ').EQ.2) THEN
X         IF(INDEX(CIN,'Q').EQ.1.OR.INDEX(CIN,'q').EQ.1) GOTO 999
X         IF(INDEX(CIN,'L').EQ.1.OR.INDEX(CIN,'l').EQ.1) THEN
X            CIN = 'Y'
X            GOTO 8
X         ENDIF
X      ENDIF
X      GOTO 9
X  900 CONTINUE
X  999 CONTINUE
X      WRITE(6,'(A)') ' PROQRY Finished'
X      END
END_OF_FILE
  if test 4274 -ne `wc -c <'proqry.for'`; then
    echo shar: \"'proqry.for'\" unpacked with wrong size!
  fi
  # end of 'proqry.for'
fi
if test -f 'tabent.for' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tabent.for'\"
else
  echo shar: Extracting \"'tabent.for'\" \(2662 characters\)
  sed "s/^X//" >'tabent.for' <<'END_OF_FILE'
X      SUBROUTINE TABENT(IPASS)
XC! Enter data into tables
X      INCLUDE 'params.h'
X      INCLUDE 'tables.h'
X      INCLUDE 'floppy.h'
X      INCLUDE 'lunits.h'
X      INTEGER SEARCH
X      EXTERNAL SEARCH
X      CHARACTER*(LCDOIF) CMNT,CDOIF
XC
X      IF(IPASS.NE.1) GOTO 100
X      IF(NPROC+NENT.GT.MAXPRO) GOTO 900
X      IF(NCOMM+NCOM.GT.MAXCOM) GOTO 910
X      DO 10 IN=1,NENT
X        PROCED_NAME(NPROC+IN) = CALLER(IN)
X        CMNT = '      '
X        IF(LENOCC(CMMNT).NE.0) THEN
X          CMNT = ' '
X          DO 55 IC=1,LENOCC(CMMNT)
X            IF(CMMNT(IC:IC).NE.' ') THEN
X              IF(IC.LT.LENOCC(CMMNT)) CMNT = CMMNT(IC:)
X              GOTO 56
X            ENDIF
X   55     CONTINUE
X   56     CONTINUE
X        ENDIF
X        PROCED_DESCRIP(NPROC+IN) = CMNT
XC
XC loop over common block names
XC
X        DO 20 IC=1,NCOM
X          DO 21 ICO=1,NCOMM
X            IF(COMMON_NAME(ICO).EQ.CNAMES(IC)) THEN
X              COMMON_USED(NPROC+IN,ICO) = 'Y'
X              IF(UNUSED(IC).EQ.'!')
X     &            COMMON_USED(NPROC+IN,ICO) = 'N'
X              GOTO 22
X            ENDIF
X   21     CONTINUE
X          NCOMM = NCOMM + 1
X          COMMON_NAME(NCOMM) = CNAMES(IC)
X          COMMON_USED(NPROC+IN,NCOMM) = 'Y'
X          IF(UNUSED(IC).EQ.'!')
X     &       COMMON_USED(NPROC+IN,NCOMM) = 'N'
X   20   CONTINUE
X   22   PROCED_NCALLS(NPROC+IN) = KALL
X        DO 50 ICL=1,KALL
XC
XC compose doif string
XC
X          CDOIF(:) = ' '
X          ILDO = MIN(KALLDO(ICL),LCDOIF)
X          DO 30 IDO=1,ILDO
X            CDOIF(IDO:IDO) = '('
X   30     CONTINUE
X          ILIF = MIN(LCDOIF-ILDO,KALLIF(ICL))
X          DO 31 IIF=1,ILIF
X            CDOIF(ILDO+IIF:ILDO+IIF) = '?'
X   31     CONTINUE
X          PROCED_DOIF(NPROC+IN,ICL) = CDOIF
X   50   CONTINUE
X   10 CONTINUE
X      NPROC = NPROC + NENT
X      RETURN
XC
XC second pass for external names
XC
X  100 CONTINUE
X      DO 110 IN=1,NENT
X        IF(KALL.LE.0) GOTO 110
X        IPNAM = SEARCH(CALLER(IN))
X        DO 120 IC=1,KALL
X          IPNAM2 = SEARCH(CALLED(IC))
X          IF(IPNAM2.EQ.0) THEN
X            NPROC = NPROC + 1
X            IPNAM2 = NPROC
X            PROCED_NAME(NPROC) = CALLED(IC)
X            PROCED_DESCRIP(NPROC) = 'External'
X            PROCED_EXTERN(NPROC) = .TRUE.
X            PROCED_NCALLS(NPROC) = 0
X            PROCED_NCALLEDBY(NPROC) = 0
X          ENDIF
X          PROCED_CALLS(IPNAM,IC) = IPNAM2
X          NCALLEDBY = PROCED_NCALLEDBY(IPNAM2) + 1
X          PROCED_NCALLEDBY(IPNAM2) = NCALLEDBY
X  120   CONTINUE
X  110 CONTINUE
X      RETURN
X  900 WRITE(LOUT,'(A)') ' TABENT : MAXIMUM NO. OF PROCEDURES EXCEEDED'
X      STOP 2
X  910 WRITE(LOUT,'(A)') ' TABENT : MAXIMUM NO. OF COMMONS EXCEEDED'
X      STOP 3
X      END
END_OF_FILE
  if test 2662 -ne `wc -c <'tabent.for'`; then
    echo shar: \"'tabent.for'\" unpacked with wrong size!
  fi
  # end of 'tabent.for'
fi
if test -f 'tables.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tables.h'\"
else
  echo shar: Extracting \"'tables.h'\" \(876 characters\)
  sed "s/^X//" >'tables.h' <<'END_OF_FILE'
X      COMMON /TABLES/ PROCED_NAME(MAXPRO),
X     &                PROCED_DESCRIP(MAXPRO),
X     &                PROCED_DOIF(MAXPRO,MAXCALL),
X     &                COMMON_NAME(MAXCOM),
X     &                COMMON_USED(MAXPRO,MAXCOM)
X      COMMON /TABLE1/ NPROC,NCOMM,
X     &                PROCED_EXTERN(MAXPRO),
X     &                PROCED_NCALLS(MAXPRO),
X     &                PROCED_CALLS(MAXPRO,MAXCALL),
X     &                PROCED_NCALLEDBY(MAXPRO),
X     &                PROCED_LEVEL(MAXPRO),
X     &                PROCED_DONE(MAXPRO) 
X      CHARACTER*(MXNAM) PROCED_NAME
X      CHARACTER*(MXNAM) COMMON_NAME
X      CHARACTER*(LCDOIF) PROCED_DOIF
X      CHARACTER*(LCMMNT) PROCED_DESCRIP
X      CHARACTER*1 COMMON_USED
X      INTEGER NPROC,NCOMM,PROCED_NCALLS,PROCED_CALLS,PROCED_NCALLEDBY
X      INTEGER PROCED_CALLEDBY,PROCED_LEVEL
X      LOGICAL PROCED_DONE,PROCED_EXTERN
END_OF_FILE
  if test 876 -ne `wc -c <'tables.h'`; then
    echo shar: \"'tables.h'\" unpacked with wrong size!
  fi
  # end of 'tables.h'
fi
if test -f 'trecom.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'trecom.h'\"
else
  echo shar: Extracting \"'trecom.h'\" \(131 characters\)
  sed "s/^X//" >'trecom.h' <<'END_OF_FILE'
X      COMMON /TRECOM/ LEXT,CTREE,NSUBNM,LSUBNM(MSUBT),CSUBNM(MSUBT)
X      CHARACTER*(MXNAM) CTREE,CSUBNM
X      LOGICAL LSUBNM,LEXT
END_OF_FILE
  if test 131 -ne `wc -c <'trecom.h'`; then
    echo shar: \"'trecom.h'\" unpacked with wrong size!
  fi
  # end of 'trecom.h'
fi
if test -f 'vmsflow.for' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vmsflow.for'\"
else
  echo shar: Extracting \"'vmsflow.for'\" \(5375 characters\)
  sed "s/^X//" >'vmsflow.for' <<'END_OF_FILE'
X      PROGRAM FLOW
X      INCLUDE 'params.h'
X      INCLUDE 'jobcom.h'
X      INCLUDE 'lunits.h'
X      INCLUDE 'trecom.h'
X      INCLUDE 'ignore.h'
XC
X      INTEGER*4 STATUS,CLI$GET_VALUE,CLI$PRESENT
X      INTEGER*4 LIB$FIND_FILE,LIB$FIND_FILE_END
X      INCLUDE '($SSDEF)'
X      INCLUDE '($RMSDEF)'
X      INCLUDE '($LBRDEF)'
X      EXTERNAL CLI$_PRESENT,CLI$_DEFAULTED,CLI$_ABSENT,CLI$_NEGATED
X      CHARACTER*(MXLIN) CIN
X      CHARACTER*(MXLIN) CFLOP
X      CHARACTER*(MXLIN) CTEMPL
X      CHARACTER*1024 CLONG
X      LOGICAL LOG
X      CHARACTER*(MLEN) CMMND
XC
X      LOG = .FALSE.
X      LPRINT = .FALSE.
X      LDEBUG = .FALSE.
X      NIGNO = 0
XC
XC LOG
XC
X      STATUS = CLI$PRESENT('LOG')
X      IF(STATUS.EQ.%LOC(CLI$_PRESENT).OR.
X     &   STATUS.EQ.%LOC(CLI$_DEFAULTED)) THEN
X        LOG = .TRUE.
X      ENDIF
XC
XC INPUT TREE FROM FLOPPY
XC
X      ITREE = 0
X      STATUS = CLI$PRESENT('P1')
X      IF(STATUS.EQ.%LOC(CLI$_PRESENT)) THEN
X        STATUS = CLI$GET_VALUE('P1',CIN)
X        IF(.NOT.STATUS) STATUS = LIB$STOP(%VAL(STATUS))
X        STATUS = LIB$FIND_FILE(CIN,CFLOP,I,'flow.floptre')
X        IF(.NOT.STATUS) STATUS = LIB$STOP(%VAL(STATUS))
X        STATUS = LIB$FIND_FILE_END(I)
X        ITREE = 1
X        IF(LOG)WRITE(6,'(A,A)')' Flow --> Input FLOPPY data:',
X     &  CFLOP(:LENOCC(CFLOP))
X        LINTRE = 50
X        OPEN(LINTRE,FILE=CFLOP,ACCESS='SEQUENTIAL',READONLY,
X     &  FORM='UNFORMATTED',STATUS='OLD',ERR=999)
X      ENDIF
XC
XC QUERY TREE
XC
X      LQERY = .FALSE.
X      STATUS = CLI$PRESENT('QUERY')
X      IF(STATUS.EQ.%LOC(CLI$_PRESENT)) THEN
X        LQERY = .TRUE.
X        IF(LOG)WRITE(6,'(A)') ' Flow --> Queries on the tree'
X      ENDIF
XC
XC COMMON BLOCK TABLE
XC
X      LCOMM = .FALSE.
X      STATUS = CLI$PRESENT('COMMON_TABLE')
X      IF(STATUS.EQ.%LOC(CLI$_PRESENT)) THEN
X        LCOMM = .TRUE.
X        IF(LOG)WRITE(6,'(A)') ' Flow --> Produce COMMON table'
X        STATUS = CLI$GET_VALUE('COMMON_TABLE',CIN)
X        CCOMM = 'PROCOM.DAT'
X        IF(STATUS.NE.%LOC(CLI$_ABSENT)) CCOMM = CIN
X        IF(LOG)WRITE(6,'(A,A)')
X     &' Flow --> write COMMON table to:',CCOMM(:LENOCC(CCOMM))
X        LOUTCO = 60
X        OPEN(LOUTCO,FILE=CCOMM,STATUS='NEW',ERR=999)
X      ENDIF
XC
XC TREE
XC
X      LTREE = .FALSE.
X      STATUS = CLI$PRESENT('STRUCTURE_CHART')
X      IF(STATUS.EQ.%LOC(CLI$_PRESENT)) THEN
X        LTREE = .TRUE.
X        IF(LOG)WRITE(6,'(A)') ' Flow --> Produce Text Structure Chart'
X        STATUS = CLI$GET_VALUE('STRUCTURE_CHART',CIN)
X        CHART = 'PROTRE.DAT'
X        IF(STATUS.NE.%LOC(CLI$_ABSENT)) CHART = CIN
X        IF(LOG)WRITE(6,'(A,A)')
X     &' Flow --> write Structure Chart to: ',CHART(:LENOCC(CHART))
X        LOUTRE = 61
X        OPEN(LOUTRE,FILE=CHART,STATUS='NEW',ERR=999)
X      ENDIF
XC
XC IGNORE NAMES
XC
X      STATUS = CLI$PRESENT('IGNORE')
X      IF(STATUS.EQ.%LOC(CLI$_PRESENT)) THEN
X   60   STATUS = CLI$GET_VALUE('IGNORE',CLONG)
X        IF(STATUS.NE.%LOC(CLI$_ABSENT)) THEN
X           NIGNO = NIGNO + 1
X           LLONG = LENOCC(CLONG)
X           CIGNO(NIGNO) = CLONG(:LLONG) 
X           LIGNO(NIGNO) = LLONG
X           GOTO 60
X        ENDIF
X        IF(LOG) WRITE(6,'(A)') ' Flow --> Ignore modules:'
X        IF(LOG) WRITE(6,'(10X,6A8)') (CIGNO(IG),IG=1,NIGNO)
X      ENDIF
XC
XC Graphics Structure Chart
XC
X      LCHRT = .FALSE.
X      STATUS = CLI$PRESENT('GRAPHICS')
X      IF(STATUS.EQ.%LOC(CLI$_PRESENT)) THEN
X        STATUS = CLI$GET_VALUE('GRAPHICS',CIN)
X        LOUTCH = 96
X        CGRAPH = 'FLOW.PS'
X        IF(STATUS) CGRAPH = CIN
X        IF(LOG)WRITE(6,'(A,A)') ' Flow --> Chart name:',
X     &                 CGRAPH(:LENOCC(CGRAPH))
X        LCHRT = .TRUE.
X        OPEN(LOUTCH,FILE=CGRAPH(:LENOCC(CGRAPH)),STATUS='NEW',
X     &       CARRIAGECONTROL='LIST',ERR=999)
X      ENDIF
XC
XC NOEXTERNALS
XC
X      LEXT =.FALSE.
XC
X      IF(.NOT.LTREE.AND..NOT.LCHRT) GOTO 5
XC
X      STATUS = CLI$PRESENT('EXTERNALS')
X      IF(STATUS.EQ.%LOC(CLI$_NEGATED)) THEN
X        IF(LOG)WRITE(6,'(A)')
X     &  ' Flow --> Suppress external routines from the chart'
X        LEXT = .FALSE.
X      ELSE
XC
XC EXTERNALS
XC
X        IF(LOG)WRITE(6,'(A)')
X     &  ' Flow --> Include external routines in the chart'
X        LEXT = .TRUE.
X      ENDIF
XC
XC NODE
XC
X      STATUS = CLI$PRESENT('NODE')
X      IF(STATUS.EQ.%LOC(CLI$_DEFAULTED)) THEN
X        CTREE = '$$$$'
X        IF(LOG)WRITE(6,'(A)') ' Flow --> Take first node found'
X      ELSE IF(STATUS.EQ.%LOC(CLI$_PRESENT)) THEN
X        STATUS = CLI$GET_VALUE('NODE',CIN)
X        IF(STATUS.NE.%LOC(CLI$_ABSENT)) THEN
X          CTREE = CIN(:LENOCC(CIN))
X          IF(LOG)WRITE(6,'(A,A)')' Flow --> Start chart from:',
X     &    CTREE(:LENOCC(CTREE))
X        ELSE
X          CTREE = '$$$$'
X          IF(LOG)WRITE(6,'(A)') ' Flow --> Take first node found'
X        ENDIF
X      ENDIF
X    5 CONTINUE
XC
X      IF(LOG)WRITE(6,'(A)')
X     &' Flow --> Finished parsing command string'
XC
X      CALL PRODES
XC
X      IF(LCHRT) CLOSE(LOUTCH)
X      IF(LCOMM) CLOSE(LOUTCO)
X      IF(LTREE) CLOSE(LOUTRE)
X      CLOSE(LINTRE)
XC
X      GOTO 1000
X  999 CONTINUE
X      WRITE(6,500)
X  500 FORMAT(//,1X,'***********************************************',
X     &        /,1X,'*                 F  L  O  W                  *',
X     &        /,1X,'*                   ABORTED                   *',
X     &        /,1X,'*          in job preparation stage.          *',
X     &        /,1X,'***********************************************')
X 1000 CONTINUE
X      END
END_OF_FILE
  if test 5375 -ne `wc -c <'vmsflow.for'`; then
    echo shar: \"'vmsflow.for'\" unpacked with wrong size!
  fi
  # end of 'vmsflow.for'
fi
echo shar: End of archive 4 \(of 5\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
