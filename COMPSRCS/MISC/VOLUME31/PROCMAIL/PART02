Newsgroups: comp.sources.misc
From: berg@pool.informatik.rwth-aachen.de (Stephen R. van den Berg)
Subject:  v31i041:  procmail - mail processing program v2.71, Part02/05
Message-ID: <1992Jul16.204513.20231@sparky.imd.sterling.com>
X-Md4-Signature: 85e8b87917e788369eabc607d5ca59f5
Date: Thu, 16 Jul 1992 20:45:13 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: berg@pool.informatik.rwth-aachen.de (Stephen R. van den Berg)
Posting-number: Volume 31, Issue 41
Archive-name: procmail/part02
Environment: UNIX, sendmail, smail, MMDF
Supersedes: procmail: Volume 29, Issue 90-94

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 5)."
# Contents:  procmail/FAQ procmail/FEATURES procmail/INSTALL
#   procmail/Makefile procmail/includes.h procmail/man/formail.man
#   procmail/man/manconf.c procmail/man/procmailex.man
#   procmail/nonint.c procmail/strpbrk.h
# Wrapped by berg@minipicc on Thu Jul 16 14:34:21 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'procmail/FAQ' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/FAQ'\"
else
echo shar: Extracting \"'procmail/FAQ'\" \(5018 characters\)
sed "s/^X//" >'procmail/FAQ' <<'END_OF_FILE'
X------------------------------------------------------------------------------
X---------------------- Frequently Asked Questions ----------------------------
X------------------------------------------------------------------------------
X
X1. How do I go about setting up a mailinglist?
X
X	Look in the examples/mailinglist file, it describes it in detail.
X
X2. I installed procmail (i.e. typed 'make install'), but how am I supposed to
X   use it?  When I type procmail on the command line it simply does nothing.
X
X	You're not supposed to start procmail from the command line.
X	Be sure to have a .forward and a .procmailrc file in your home
X	directory (see the examples subdirectory or the man page).
X	MMDF users should note that they need a .maildelivery file *instead*
X	of a .forward file (see the man page for more detailed information).
X
X	If however, procmail has been integrated in the maildelivery system
X	(i.e. if your system administrator installed it that way, ask him/her),
X	then you no longer need the .forward files in your home directory,
X	having a .procmailrc file will suffice.
X
X	On some systems .forward files are not checked, in this case it might
X	be worth trying to put a line looking like this:
X		Pipe to /usr/local/bin/procmail
X	as the only line in your mail spool file (e.g. /usr/mail/$USER), as
X	well as doing a "chmod 04600 /usr/mail/$USER".	For more information
X	on such systems, do a "man mail".
X
X3. When I compile everything the compiler complains about invalid or illegal
X   pointer combinations, but it produces the executables anyway.
X   Should I be concerned?
X
X	Ignore these warnings, they simply indicate that either your compiler
X	or your system include files are not ANSI/POSIX compliant.
X	The compiler will produce correct code regardless of these warnings.
X
X4. The compiler seems to issue warnings about "loop not entered at top",
X   is that a problem?
X
X	No, no problem at all, it just means I wrote the code :-)
X	That's just about the only uncommon coding technique I use (don't
X	think I don't try to avoid those jumps in loops, it's just that
X	sometimes they are the best way to code it).  Use gcc if you want
X	to avoid these warnings.
X
X5. The compiler complains about unmodifiable lvalues or assignments to const
X   variables.  Now what?
X
X	Well, if the compiler produces the executables anyway everything
X	probably is all right.	If it doesn't, you might try inserting a
X	"#define const" in the autoconf.h file by hand.	 However in any case,
X	your compiler is broken; I would recommend submitting this as a
X	compiler bug to your vendor.  In any case, if this should occur, I'd
X	appreciate a mail from you (so I can try to fix the autoconf script
X	to recognise your compiler).
X
X6. The compiler refuses to compile regexp.c, what is the problem?
X
X	Try compiling that module with optimisation turned off.
X
X7. When I send myself a testmail, the mail bounces with the message: cannot
X   execute binary file.	 What am I doing wrong?
X
X	It is very well possible that mail is processed on a different
X	machine from that where you usually read your mail.  Therefore you
X	have to make sure that procmail has the right binary format to
X	execute on those machines on which mail could arrive.  In order to
X	get this right you might need to do some .forward file tweaking,
X	look at the examples/advanced file for some suggestions.
X
X8. Where do I look for examples about:
X	One home directory, several machine architectures?
X	Procmail as an integrated local mail delivery agent?
X	Security considerations (when installing procmail suid root)
X	How to generate autoreplies?
X	`Vacation' functionality
X	Exorbitant rcfile formats?
X	The 'A' flag?
X
X	Well, this probably is your lucky day :-), all these topics are covered
X	in the examples/advanced file.
X
X9. Why do I have to insert my login name after the '#' in the .forward or
X   .maildelivery file?
X
X	Some mailers 'optimise' maildelivery and take out duplicates from
X	Cc:, Bcc: and alias lists before delivery.  If two or more persons on
X	such a list would have identical .forward files, then the mailer will
X	eliminate all but one.	Adding a '#' with your login name following
X	it will make the .forward files unique, and will ensure that the mailer
X	does optimise away some addresses.
X
X10. How do I view the man pages?
X
X	If the man(1) program on your system understands the MANPATH
X	environment variable, make sure that the installation directory listed
X	in the Makefile for the manpages is included in your MANPATH.  If your
X	man program does not support MANPATH, make sure that the man pages
X	are installed in one of the standard man directories, like under
X	/usr/man.  If you do not want to install the man pages before viewing
X	them, you can view an individual man file by typing something like:
X	nroff -man procmail.1 | more
X
X11. None of the above topics cover my problem.	Should I panic?
X
X	Let me ask you a question :-), have you examined the CAVEATS, WARNINGS,
X	BUGS and NOTES sections of the manual pages *closely* ?
X	If you have, well, then panic.
END_OF_FILE
if test 5018 -ne `wc -c <'procmail/FAQ'`; then
    echo shar: \"'procmail/FAQ'\" unpacked with wrong size!
fi
# end of 'procmail/FAQ'
fi
if test -f 'procmail/FEATURES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/FEATURES'\"
else
echo shar: Extracting \"'procmail/FEATURES'\" \(3206 characters\)
sed "s/^X//" >'procmail/FEATURES' <<'END_OF_FILE'
XFeature summary for procmail:
X	+ It's small
X	+ Very easy to install (rated PG6 :-)
X	+ Simple to maintain and configure because
X	  all you need is actually only ONE executable (procmail)
X	  and ONE configuration file (.procmailrc)
X	+ Is event driven (i.e. gets invoked automagically when mail arrives)
X	+ Does not use *any* temporary files
X	+ Uses standard egrep regular expressions
X	+ Allows for very-easy-to-use yes-no decisions on where the mail
X	  should go (can take the size of the mail into consideration)
X	+ Filters, delivers and forwards mail *reliably*
X	+ Provides a reliable hook (you might even say anchor :-) for any
X	  programs or shell scripts you may wish to start upon mail arrival
X	+ Performs heroically under even the worst conditions
X	  (file system full, out of swap space, process table full,
X	  file table full, missing support files, unavailable executables,
X	  denied permissions) and tries to deliver the mail somehow anyway
X	+ Absolutely undeliverable mail (after trying every trick in the book)
X	  will bounce back to the sender (or not, your choice)
X	+ Is one of the few mailers to perform reliable mailbox locking across
X	  NFS as well (DON'T use NFS mounted mailboxes WITHOUT installing
X	  procmail, you may use valuable mail one day)
X	+ Supports four mailfolder standards: single file folders (standard
X	  and nonstandard VNIX format), directory folders that contain one file
X	  per message, or the similar MH directory folders (numbered files)
X	+ Variable assignment and substitution is an extremely complete subset
X	  of the standard /bin/sh syntax
X	+ Provides a mail log file, which logs all mail arrival, shows
X	  in summary whence it came from, what it was about, where it went
X	  (what folder) and how long (in bytes) it was
X	+ Uses this log file to display a wide range of diagnostic and error
X	  messages (if something went wrong)
X	+ Does not impose *any* limits on line lenghts, mail length (as long
X	  as memory permits), or the use of any character (any 8-bit character,
X	  including '\0' is allowed) in the mail
X	+ It has man pages (boy, does *it* have man pages)
X	+ Procmail can be used as a local delivery agent (a completely
X	  integrated substitute for /bin/mail), in which case it can heal
X	  your system mailbox, if something messes up the permissions
X	+ It runs on virtually all (old and future) operating systems which
X	  names start with a 'U' or end in an 'X' :-) (i.e. extremely portable
X	  code; POSIX, ANSI C and K&R conforming)
X	+ Is clock skew immune (e.g. in the case of NFS mounted mailboxes)
X	+ Works with (among others?) sendmail, smail and MMDF
X
XFeature summary for formail:
X	+ Can generate auto-reply headers
X	+ Can convert mail into standard mailbox format (so that you can
X	  process it with standard mail programs)
X	+ Can split up mailboxes into the individual messages
X	+ Can split up digests into the individual messages
X	+ Can split up saved articles into the individual articles
X	+ Can do simple header munging/extraction
X
XFeature summary for lockfile:
X	+ Provides NFS-secure lockfiles to shell script programmers
X	+ Gives normal users the ability to lock their system mailbox,
X	  regardless of permissions on the mail-spool directory
END_OF_FILE
if test 3206 -ne `wc -c <'procmail/FEATURES'`; then
    echo shar: \"'procmail/FEATURES'\" unpacked with wrong size!
fi
# end of 'procmail/FEATURES'
fi
if test -f 'procmail/INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/INSTALL'\"
else
echo shar: Extracting \"'procmail/INSTALL'\" \(5027 characters\)
sed "s/^X//" >'procmail/INSTALL' <<'END_OF_FILE'
XDiscusses:
X		1. Getting the lot to compile
X		2. DEBUGGING AID
X		3. Setting up the environment
X		4. Extra options if you are a system administrator
X
X				---
X
X1. Getting the lot to compile
X   --------------------------
X
XTo install procmail, lockfile and formail: edit Makefile & config.h accordingly
Xand type 'make install'.
XIntended configurable options in Makefile are: the install-destinations
XIntended configurable options in config.h are: KERNEL_LOCKS and MMDF support,
X standard environment presettings, trusted user ids.
X
X'make install' will:
X      - execute autoconf (a shell script that repeatedly calls the C compiler
X	to determine if certain features/symbols are supported), which will
X	create a file named autoconf.h
X      - compile the *.c files, create the three stripped binaries:
X	procmail, lockfile and formail
X      - copy the shell script examples/mailstat to mailstat
X      - copy these binaries and mailstat to $(BINDIR)
X      - copy the man pages to $(MAN1DIR) and $(MAN5DIR)
X
X'make deinstall' will:
X      - remove the just installed files in $(BINDIR)
X      - remove the just installed files in $(MAN1DIR) and $(MAN5DIR)
X
X
XMinimal requirements:
X
Xprocmail must be installed.
X
XOptional files (depending on your requirements):
X
Xlockfile needs only to be installed if you plan to read several mailboxes
X	with one of the standard mailers that don't support lockfiles.
Xformail needs only to be installed if mail sometimes arrives in nonstandard
X	mailbox format (or if you want to generate auto replies, split up
X	mailboxes/digests etc., see the man page of formail for more info).
X	Formail is not called by procmail unless *you* tell it to.
Xmailstat is an "example" shell script that can be used as is to produce
X	summaries of the procmail generated logfiles; it is not needed by
X	procmail itself in any way.
X
XIf things don't compile automagically, I suggest you take a look at:
Xautoconf, autoconf.h, config.h, includes.h
X
XFor autoconf to work as intended, your compiler should either be fully ANSI
Xcompliant, or you should NOT turn off all warnings; enabling all warnings
Xshouldn't hurt.	 In most cases the default options in the Makefile will do.
X
XThe sources are supposed to be fully ANSI, K&R and POSIX compliant.
X
X				---
X
X2. DEBUGGING AID
X   -------------
X
XSince procmail is intended to run completely independent of any terminals, it
Xdoesn't use the stderr output to display error messages.  It is recommended,
Xespecially during debugging, to specify a LOGFILE (see man page) in the
Xrcfile or on the command line.	Procmail will log all serious problems it
Xencounters.  Of course, instead of a regular file, one could also specify a
Xterminal as the default logfile.
X
XAlso, procmail can be persuaded to be a lot more verbose by preceding the
Xlogfile name by a colon.
XTherefore a suggested command line for your first trial run would be:
Xprocmail LOGFILE=:/dev/tty
X(now type in a pseudo mail-message)
X
XIf all else fails, you can try uncommenting the "#define console" entry
Xin the config.h file.  This will provide you with the most verbose procmail
Xyou can make.  It is of course a good idea to comment out this line again
Xafter your troubles have been solved.
X
XIf you run procmail by hand and pipe in some sample mail, then make
Xsure that if you kill procmail, you use "kill pid" and NOT "kill -9 pid".
XShould procmail seem to hang, check if the $LOCKFILE is still present.
XIf you kill procmail with "kill pid" it will clean up the $LOCKFILE
Xitself.
X
X				---
X
X3. Setting up the environment
X   --------------------------
X
XEvery user that wants to use procmail should have a .forward and a
X.procmailrc file in his HOME directory.	 For starters, you can look
Xat the supplied example files in "examples".
X(BTW, be sure to make .forward *world* readable).
XMMDF users should note that they need a .maildelivery file *instead* of the
X.forward file (see the man page for more information).
X
X				---
X
X4. Extra options if you are a system administrator
X   -----------------------------------------------
X
XIf you are a system administrator you can decide to install procmail
Xglobally (i.e. as an equivalent substitute for the local-maildelivery-
Xcapabilities of /bin/mail), this has the advantage that users do not need to
Xhave a .forward file anymore that calls up procmail.  Simply having a
X.procmailrc file in the $HOME directory will suffice.  Operation is transparent
Xin this case (i.e. if no .procmailrc file is present in the $HOME directory,
Xmail will be delivered as usual).
X
XFor direct examples on how to do this, look at the examples/advanced file.
X
X*******************************************************************************
XHIGHLY RECOMMENDED: install procmail setuid root (and/or setgid maildeamon)
X		    install lockfile setgid maildaemon (and/or setuid root)
X
XTo obtain specific instructions on the best installation, type "make recommend"
X*******************************************************************************
X
X				---
X
XFor more info about the program, see the man page or the FAQ list.
END_OF_FILE
if test 5027 -ne `wc -c <'procmail/INSTALL'`; then
    echo shar: \"'procmail/INSTALL'\" unpacked with wrong size!
fi
# end of 'procmail/INSTALL'
fi
if test -f 'procmail/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/Makefile'\"
else
echo shar: Extracting \"'procmail/Makefile'\" \(6512 characters\)
sed "s/^X//" >'procmail/Makefile' <<'END_OF_FILE'
X#$Id: Makefile,v 2.23 1992/07/01 18:04:38 berg Rel $
X
X# change BASENAME to your home directory if need be
XBASENAME = /usr/local
X
X# You can predefine ARCHITECTURE to a bin directory suffix
X#ARCHITECTURE=.sun4
X
XBINDIR	  = $(BASENAME)/bin$(ARCHITECTURE)
XMANDIR	  = $(BASENAME)/man
XMAN1SUFFIX= 1
XMAN5SUFFIX= 5
XMAN1DIR	  = $(MANDIR)/man$(MAN1SUFFIX)
XMAN5DIR	  = $(MANDIR)/man$(MAN5SUFFIX)
X
X# Things that can be made are:
X
X# procmail formail lockfile		These are the three programs contained
X#					in this package
X
X# all			Makes all three binaries and the man pages
X# install.man		Installs the man pages to $(MAN1DIR) and $(MAN5DIR)
X# install		Is a "make all" followed by copying all the binaries
X#			and man pages to $(BINDIR), $(MAN1DIR) and $(MAN5DIR)
X#			respectively
X# recommend		Show some recommended suid/sgid modes
X# suid			Install the by-'make recommend'-shown modes
X# clean			Restores the package to pre-make state
X# deinstall		Removes the previously installed binaries and man
X#			pages by careful surgery
X
X########################################################################
X# Only edit below this line if you *think* you know what you are doing #
X########################################################################
X
X# Directory for the standard include files
XUSRINCLUDE = /usr/include
X
XOCFLAGS = -O #-ansi -pedantic -Wid-clash-6
XOLDFLAGS= -s
X
XCFLAGS	= $(OCFLAGS) #-D_POSIX_SOURCE
XLDFLAGS = $(OLDFLAGS) #-lcposix
X
XCC	= cc # gcc
XMAKE	= make
XSHELL	= /bin/sh
XO	= o
XRM	= /bin/rm -f
XINSTALL = cp
XDEVNULL = /dev/null
X
XBINS=procmail lockfile formail mailstat
X
XMANS=man/procmail.1 man/procmailrc.5 man/procmailex.5 man/formail.1 \
X	man/lockfile.1
X
XMANS1=procmail.$(MAN1SUFFIX) formail.$(MAN1SUFFIX) lockfile.$(MAN1SUFFIX)
XMANS5=procmailrc.$(MAN5SUFFIX) procmailex.$(MAN5SUFFIX)
X
XOBJ=nonint.$(O) goodies.$(O) regexp.$(O)
X
XDEP=shell.h procmail.h config.h
X
Xall:	everything recommend
X
Xeverything: autoconf.h $(BINS) $(MANS)
X
Xprocmail: procmail.$(O) $(OBJ) exopen.$(O) common.$(O) retint.$(O) strpbrk.$(O)
X	$(CC) $(CFLAGS) -o procmail procmail.$(O) $(OBJ) exopen.$(O) \
X	 common.$(O) retint.$(O) strpbrk.$(O) $(LDFLAGS)
X
Xlockfile: lockfile.$(O) exopen.$(O) strpbrk.$(O)
X	$(CC) $(CFLAGS) -o lockfile lockfile.$(O) exopen.$(O) strpbrk.$(O) \
X	 ${LDFLAGS}
X
Xformail: formail.$(O) common.$(O) strpbrk.$(O)
X	$(CC) $(CFLAGS) -o formail formail.$(O) common.$(O) strpbrk.$(O) \
X	 ${LDFLAGS}
X
Xmailstat: examples/mailstat
X	cp examples/mailstat mailstat
X
X_autotst: _autotst.$(O)
X	$(CC) $(CFLAGS) -o _autotst _autotst.$(O) $(LDFLAGS)
X
Xautoconf.h: autoconf Makefile
X	$(SHELL) ./autoconf $(O) "$(MAKE)" autoconf.h "$(SHELL)" "$(RM)" \
X$(USRINCLUDE)
X
XMakefile: Manifest
X
XManifest: config.h
X	@touch Manifest
X	@-if fgrep -n -e '`' config.h $(DEVNULL) | fgrep -v -e EOFName ; then \
X	 echo;echo '	^^^^^^^^^^^^^^^^^^^^ WARNING ^^^^^^^^^^^^^^^^^^^^^';\
X	      echo '	* Having backquotes in there could be unhealthy! *';\
X	 echo;fi;exit 0
X
X$(OBJ): $(DEP)
X
Xretint.$(O): $(DEP)
X
Xprocmail.$(O): $(DEP) patchlevel.h
X
Xexopen.$(O): config.h includes.h exopen.h strpbrk.h
X
Xformail.$(O): config.h includes.h shell.h strpbrk.h
X
Xlockfile.$(O): config.h includes.h exopen.h strpbrk.h
X
Xcommon.$(O): includes.h shell.h
X
Xrecommend.$(O): config.h includes.h strpbrk.h
X	@$(CC) -c $(CFLAGS) recommend.c
X
Xstrpbrk.$(O): strpbrk.h includes.h
X
Xprocmail.h: includes.h exopen.h strpbrk.h
X	touch procmail.h
X
Xincludes.h: autoconf.h
X	touch includes.h
X
X.c.$(O):
X	$(CC) -c $(CFLAGS) $*.c
X
Xman/man.sed: man/manconf.c config.h procmail.h
X	$(CC) $(CFLAGS) -o man/manconf man/manconf.c ${LDFLAGS}
X	man/manconf >man/man.sed
X	rm -f man/manconf
X
Xman/procmail.1: man/man.sed man/procmail.man man/mansed
X	$(SHELL) man/mansed man/procmail.man man/procmail.1 $(SHELL)
X
Xman/procmailrc.5: man/man.sed man/procmailrc.man man/mansed
X	$(SHELL) man/mansed man/procmailrc.man man/procmailrc.5 $(SHELL)
X
Xman/procmailex.5: man/man.sed man/procmailex.man man/mansed
X	$(SHELL) man/mansed man/procmailex.man man/procmailex.5 $(SHELL)
X
Xman/formail.1: man/man.sed man/formail.man man/mansed
X	$(SHELL) man/mansed man/formail.man man/formail.1 $(SHELL)
X
Xman/lockfile.1: man/man.sed man/lockfile.man man/mansed
X	$(SHELL) man/mansed man/lockfile.man man/lockfile.1 $(SHELL)
X
Xrecommend: recommend.$(O) strpbrk.$(O)
X	@echo ----------------------------------------------------------------\
X---------------
X	@echo If you are a system administrator you should consider \
Xintegrating procmail
X	@echo into the mail-delivery system -- for advanced functionality \
XAND SECURITY --.
X	@echo For more information about this topic you should look in the \
Xexamples/advanced
X	@echo file.
X	@echo
X	@echo "Also, HIGLY RECOMMENDED (type 'make suid' to execute it):"
X	@echo
X	@$(CC) $(CFLAGS) -o _autotst recommend.$(O) strpbrk.$(O) ${LDFLAGS}
X	@./_autotst $(BINDIR)/procmail $(BINDIR)/lockfile >suid.sh
X	@./_autotst $(BINDIR)/procmail $(BINDIR)/lockfile
X	@$(RM) _autotst
X	@echo ----------------------------------------------------------------\
X---------------
X
Xsuid.sh: recommend
X
Xsuid:	suid.sh install.bin
X	@cat suid.sh
X	@$(SHELL) ./suid.sh
X	@cd $(BINDIR); echo Installed in $(BINDIR); ls -l $(BINS)
X
Xinstall.man: $(MANS)
X	@-mkdir $(MANDIR) 2>$(DEVNULL); exit 0
X	@-mkdir $(MAN1DIR) 2>$(DEVNULL); exit 0
X	@-mkdir $(MAN5DIR) 2>$(DEVNULL); exit 0
X	@chmod 0644 man/*.1 man/*.5
X	$(INSTALL) man/procmail.1 $(MAN1DIR)/procmail.$(MAN1SUFFIX)
X	$(INSTALL) man/procmailrc.5 $(MAN5DIR)/procmailrc.$(MAN5SUFFIX)
X	$(INSTALL) man/procmailex.5 $(MAN5DIR)/procmailex.$(MAN5SUFFIX)
X	$(INSTALL) man/lockfile.1 $(MAN1DIR)/lockfile.$(MAN1SUFFIX)
X	$(INSTALL) man/formail.1 $(MAN1DIR)/formail.$(MAN1SUFFIX)
X
Xinstall.bin: everything
X	@-mkdir $(BINDIR) 2>$(DEVNULL); exit 0
X	@chmod 0755 $(BINS)
X	$(INSTALL) $(BINS) $(BINDIR)
X
Xinstall: everything install.man install.bin
X	@echo
X	@cd $(BINDIR); echo Installed in $(BINDIR); ls -l $(BINS)
X	@cd $(MAN1DIR); echo Installed in $(MAN1DIR); ls -l $(MANS1)
X	@cd $(MAN5DIR); echo Installed in $(MAN5DIR); ls -l $(MANS5)
X	@$(MAKE) recommend
X
Xdeinstall:
X	@echo ----------------------------- Deinstalling the procmail package.
X	@echo ----------------------------- Checking if everything was removed:
X	@-cd $(BINDIR); $(RM) $(BINS); ls -l $(BINS)
X	@-cd $(MAN1DIR); $(RM) $(MANS1); ls -l $(MANS1)
X	@-cd $(MAN5DIR); $(RM) $(MANS5); ls -l $(MANS5)
X	@echo ----------------------------- Ready.
X
Xclean:
X	$(RM) $(OBJ) common.$(O) lockfile.$(O) exopen.$(O) retint.$(O) \
X	 strpbrk.$(O) formail.$(O) procmail.$(O) $(BINS) autoconf.h _autotst* \
X	 lookfor grepfor $(MANS) man/man.sed recommend.$(O) suid.sh
END_OF_FILE
if test 6512 -ne `wc -c <'procmail/Makefile'`; then
    echo shar: \"'procmail/Makefile'\" unpacked with wrong size!
fi
# end of 'procmail/Makefile'
fi
if test -f 'procmail/includes.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/includes.h'\"
else
echo shar: Extracting \"'procmail/includes.h'\" \(5328 characters\)
sed "s/^X//" >'procmail/includes.h' <<'END_OF_FILE'
X/*$Id: includes.h,v 2.20 1992/06/30 16:42:26 berg Rel $*/
X
X#include "autoconf.h"
X	/* not all the "library identifiers" specified here need to be
X	   available for all programs in this package; some have substitutes
X	   as well (see autoconf); this is just an informal list */
X
X#include <sys/types.h>		/* pid_t mode_t uid_t gid_t */
X#ifndef UNISTD_H_MISSING
X#include <unistd.h>		/* open() read() write() close() dup() pipe()
X				   fork() getuid() getpid() execve()
X				   execvp() sleep() */
X#endif
X#include <stdio.h>		/* setbuf() fclose() stdin stdout stderr
X				   fopen() fread() fwrite() fgetc() getc()
X				   putc() fputs() FILE EOF */
X#ifndef STDDEF_H_MISSING
X#include <stddef.h>		/* ptrdiff_t size_t sigatomic_t */
X#endif
X#ifndef STDLIB_H_MISSING
X#include <stdlib.h>		/* getenv() malloc() realloc() free()
X				   strtol() */
X#endif
X#include <time.h>		/* time() ctime() time_t */
X#include <fcntl.h>		/* O_RDONLY O_WRONLY O_APPEND O_CREAT O_EXCL */
X#include <pwd.h>		/* getpwuid() getpwnam() struct passwd */
X#include <grp.h>		/* getgrgid() struct group */
X#ifndef DIRENT_H_MISSING
X#include <dirent.h>		/* opendir() readdir() closedir() DIR
X				   struct dirent */
X#endif
X#ifndef SYS_WAIT_H_MISSING
X#include <sys/wait.h>		/* wait() WIFEXITED() WIFSTOPPED()
X				   WEXITSTATUS() */
X#endif
X#ifndef SYS_UTSNAME_H_MISSING
X#include <sys/utsname.h>	/* uname() utsname */
X#endif
X#include <sys/stat.h>		/* stat() S_ISDIR() struct stat */
X#include <signal.h>		/* signal() kill() alarm() SIG_IGN SIGHUP
X				   SIGINT SIGQUIT SIGALRM SIGTERM */
X#ifndef STRING_H_MISSING
X#include <string.h>		/* strcpy() strncpy() strcat() strlen()
X				   strspn() strcspn() strchr() strcmp()
X				   strncmp() strpbrk() memmove() */
X#endif
X#include <errno.h>		/* EINTR EEXIST EMFILE ENFILE */
X#ifndef SYSEXITS_H_MISSING
X#include <sysexits.h>		/* EX_OK EX_UNAVAILABLE EX_OSERR EX_OSFILE
X				   EX_CANTCREAT EX_IOERR EX_TEMPFAIL */
X#endif
X
X#ifdef STDLIB_H_MISSING
Xvoid*malloc(),*realloc();
Xconst char*getenv();
X#endif
X#ifdef DIRENT_H_MISSING
X#ifndef SYS_DIRENT_H_MISSING
X#include <sys/dirent.h>
X#else
X#ifndef NDIR_H_MISSING
X#include <ndir.h>
X#define dirent	direct
X#else
X#ifndef SYS_DIR_H_MISSING
X#include <sys/dir.h>
X#define dirent	direct
X#else
X/* I give up, I can only hope that your system defines DIR and struct dirent */
X#endif
X#endif
X#endif
X#endif /* DIRENT_H_MISSING */
X#ifdef STRING_H_MISSING
X#include <strings.h>
X#ifndef strchr
Xchar*strchr();
X#endif
Xchar*strpbrk();
X#endif
X#ifdef SYS_UTSNAME_H_MISSING
X#define NOuname
X#endif
X#ifdef SYSEXITS_H_MISSING
X		/* Standard exit codes, original list maintained
X		   by Eric Allman (eric@berkeley, ucbvax!eric)	 */
X#define EX_OK		0
X#define EX_USAGE	64
X#define EX_UNAVAILABLE	69
X#define EX_OSERR	71
X#define EX_OSFILE	72
X#define EX_CANTCREAT	73
X#define EX_IOERR	74
X#define EX_TEMPFAIL	75
X#endif
X
X#if O_SYNC
X#else
X#undef O_SYNC
X#define O_SYNC		0
X#endif
X#ifndef O_RDONLY
X#define O_RDONLY	0
X#define O_WRONLY	1
X#endif
X#ifndef SEEK_SET
X#define SEEK_SET	0
X#define SEEK_CUR	1
X#define SEEK_END	2
X#endif
X#ifndef tell
X#define tell(fd)	lseek(fd,0L,SEEK_CUR)
X#endif
X
X#ifndef EOF
X#define EOF	(-1)
X#endif
X
X#ifndef S_ISDIR
X#define S_ISDIR(mode)	(((mode)&S_IFMT)==S_IFDIR)
X#ifndef S_IFDIR
X#define S_IFDIR 0040000
X#endif
X#endif
X
X#ifndef S_ISLNK
X#ifndef S_IFLNK
X#define lstat(path,stbuf)	stat(path,stbuf)
X#define S_ISLNK(mode)	0
X#else
X#define S_ISLNK(mode)	(((mode)&S_IFMT)==S_IFLNK)
X#endif
X#endif
X
X#ifndef S_IFMT
X#define S_IFMT	0170000
X#endif
X
X#ifndef S_IRWXU
X#define S_IRWXU 00700
X#define S_IRWXG 00070
X#define S_IRWXO 00007
X#endif
X#ifndef S_IWUSR
X#ifdef S_IREAD
X#define S_IRUSR	 S_IREAD
X#define S_IWUSR	 S_IWRITE
X#define S_IXUSR	 S_IEXEC
X#else
X#define S_IRUSR	 0400
X#define S_IWUSR	 0200
X#define S_IXUSR	 0100
X#endif /* S_IREAD */
X#define S_IRGRP	 0040
X#define S_IWGRP	 0020
X#define S_IXGRP	 0010
X#define S_IROTH	 0004
X#define S_IWOTH	 0002
X#define S_IXOTH	 0001
X#endif /* S_IWUSR */
X#ifndef S_ISGID
X#define S_ISUID 04000
X#define S_ISGID 02000
X#endif
X
X#ifdef WMACROS_NON_POSIX
X#ifdef WIFEXITED
X#undef WIFEXITED
X#endif
X#ifdef WIFSTOPPED
X#undef WIFSTOPPED
X#endif
X#ifdef WEXITSTATUS
X#undef WEXITSTATUS
X#endif
X#endif /* WMACROS_NON_POSIX */
X
X#ifndef WIFEXITED
X#define WIFEXITED(waitval)	(!((waitval)&255))
X#endif
X#ifndef WIFSTOPPED
X#define WIFSTOPPED(waitval)	(((waitval)&255)==127)
X#endif
X#ifndef WEXITSTATUS
X#define WEXITSTATUS(waitval)	((waitval)>>8&255)
X#endif
X
Xextern /*const*/char**environ;
Xextern errno;
X
X#ifndef STDIN_FILENO
X#define STDIN	0
X#define STDOUT	1
X#define STDERR	2
X#else
X#define STDIN	STDIN_FILENO
X#define STDOUT	STDOUT_FILENO
X#define STDERR	STDERR_FILENO
X#endif
X
X#ifdef NOrename
X#define rename(old,new) (-(link(old,new)||unlink(old)))
X#endif
X
X#ifdef NOmemmove
X#define memmove(to,from,count) smemmove(to,from,count)
X#endif
X
X#ifndef NOuname
X#ifndef const		    /* SINIX V5.23 has the wrong prototype for uname */
Xextern int uname();					 /* so we fix it :-) */
X#define uname_(name)	((int(*)(struct utsname*))uname)(name)
X#else
X#define uname_(name)	uname(name)			    /* no fix needed */
X#endif /* const */
X#endif /* NOuname */
X
X#ifdef oBRAIN_DAMAGE
X#undef offsetof
X#endif
X#ifndef offsetof
X#define offsetof(s,m) ((char*)&(((s*)0)->m)-(char*)0)
X#endif
X
X#define maxindex(x)	(sizeof(x)/sizeof((x)[0])-1)
X#define STRLEN(x)	(sizeof(x)-1)
X#define ioffsetof(s,m)	((int)offsetof(s,m))
X
X#define mx(a,b)		((a)>(b)?(a):(b))
END_OF_FILE
if test 5328 -ne `wc -c <'procmail/includes.h'`; then
    echo shar: \"'procmail/includes.h'\" unpacked with wrong size!
fi
# end of 'procmail/includes.h'
fi
if test -f 'procmail/man/formail.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/man/formail.man'\"
else
echo shar: Extracting \"'procmail/man/formail.man'\" \(6490 characters\)
sed "s/^X//" >'procmail/man/formail.man' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X..
X.Id $Id: formail.man,v 2.18 1992/06/03 14:40:24 berg Rel $
X.de Sh
X.br
X.ne 11
X.SH "\\$1"
X..
X.de Ss
X.br
X.ne 10
X.SS "\\$1"
X..
X.de Tp
X.br
X.ne 9
X.TP \\$1
X..
X.de Rs
X.na
X.nf
X.RS
X..
X.de Re
X.RE
X.fi
X.ad
X..
X.TH FORMAIL 1 \*(Dt BuGless
X.SH NAME
X.na
Xformail \- mail (re)formatter
X.SH SYNOPSIS
X.B formail
X.RI [ "\fB\+FM_SKIP+\fPskip" ]
X.RI [ "\fB\+FM_TOTAL+\fPtotal" ]
X.RB [ \-+FM_BOGUS++FM_FORCE++FM_REPLY++FM_KEEPB++FM_TRUST++FM_NOWAIT++FM_EVERY++FM_DIGEST++FM_QUIET+ ]
X.RB [ \-+FM_MINFIELDS+
X.IR "min fields" ]
X.if n .ti +0.5i
X.RB [ \-+FM_EXTRACT+
X.IR "header field" ]
X.RB [ \-+FM_ADD_IFNOT+
X.IR "header field" ]
X.if n .ti +0.5i
X.RB [ \-+FM_ADD_ALWAYS+
X.IR "header field" ]
X.RB [ \-+FM_REN_INSERT+
X.IR "header field" ]
X.if n .ti +0.5i
X.RB [ \-+FM_DEL_INSERT+
X.IR "header field" ]
X.RB [ \-+FM_SPLIT+
X.I command
X.I arg
X\&.\|.\|.\|]
X.ad
X.Sh DESCRIPTION
X.B formail
Xis a filter that can be used to force mail into mailbox format, perform
X`+FROM+' escaping, generate auto-replying headers, do simple
Xheader munging/extracting or split up a
Xmailbox/digest/articles file.  The mail/mailbox/article contents will be
Xexpected on stdin.
X.PP
XIf formail is supposed to determine the sender of the mail, but is unable
Xto find any, it will substitute `+UNKNOWN+'.
X.PP
XIf formail is started without any command line options, it will force any
Xmail coming from stdin into mailbox format and will escape
X.B all
Xbogus `+FROM+' lines with a `+ESCAP+'.
X.Sh OPTIONS
X.Tp 0.5i
X.B \-+FM_BOGUS+
XDon't escape any bogus mailbox headers (i.e. lines starting with `+FROM+').
X.Tp
X.B \-+FM_FORCE+
XForce formail to simply pass along any non-mailbox format (i.e. don't
Xgenerate a `+FROM+' line as the first line).
X.Tp
X.B \-+FM_REPLY+
XGenerate an auto-reply header.  This will normally throw away all the existing
Xfields in the original message, fields you wish to preserve need to be named
Xusing the
X.B \-+FM_REN_INSERT+
Xoption.
X.Tp
X.B \-+FM_KEEPB+
XWhen generating the auto-reply header, keep the body as well.  If used
Xtogether with the
X.B \-+FM_BOGUS+
Xoption then the body will not be escaped.
X.Tp
X.B \-+FM_TRUST+
XTrust the sender to have used a valid return address in his header.  This
Xoption will be most useful when generating auto-reply headers from news
Xarticles.  If this option is not turned on, formail tries to digest the most
Xprobable valid return address itself.
X.Tp
X.B \-+FM_SPLIT+
XThe input will be split up into seperate mail messages, and piped into
Xa program one by one (a new program is started for every part).
X.B \-+FM_SPLIT+
Xhas to be the last option specified, the first argument following it
Xis expected to be the name of a program, any other arguments will be passed
Xalong to it.
X.Tp
X.B \-+FM_NOWAIT+
XTell formail not to wait for every program to finish before starting the next.
X.Tp
X.B \-+FM_EVERY+
XDo not require empty lines preceding the header of a new message (i.e. the
Xmessages could start on every line).
X.Tp
X.B \-+FM_DIGEST+
XTell formail that the messages it is supposed to split need not be in strict
Xmailbox format (i.e. allows you to split digests/articles or non-standard
Xmailbox formats).
X.Tp
X.I "\fB\-+FM_MINFIELDS+\fP min fields"
XAllows you to specify the number of consecutive fields formail needs to find
Xbefore it decides it found the start of a new message, it defaults to
X+DEFminfields+.
X.Tp
X.B \-+FM_QUIET+
XTells formail to ignore any write errors on stdout.
X.Tp
X.I "\fB\-+FM_EXTRACT+\fP header field"
XExtract this
X.I header field
Xfrom the header, display it as a single line.
X.Tp
X.I "\fB\-+FM_ADD_IFNOT+\fP header field"
XAppend a custom
X.I header field
Xonto the header; but only if a similar field does not exist yet.
X.Tp
X.I "\fB\-+FM_ADD_ALWAYS+\fP header field"
XAppend a custom
X.I header field
Xonto the header in any case.
X.Tp
X.I "\fB\-+FM_REN_INSERT+\fP header field"
XSame as
X.BR \-+FM_ADD_IFNOT+ ,
Xexcept that any existing similar fields are renamed by prepending
Xan ``+OLD_PREFIX+'' prefix.  If
X.I header field
Xconsists only of a field-name, it will not be appended.
X.Tp
X.I "\fB\-+FM_DEL_INSERT+\fP header field"
XSame as
X.BR \-+FM_REN_INSERT+ ,
Xexcept that any existing similar fields are simply removed.
X.Tp
X.I "\fB\+FM_SKIP+\fPskip"
XSkip the first
X.I skip
Xmessages while splitting.
X.Tp
X.I "\fB\+FM_TOTAL+\fPtotal"
XOutput at most
X.I total
Xmessages while splitting.
X.Sh EXAMPLES
XTo split up a digest one usually uses:
X.Rs
Xformail +FM_SKIP+1 -+FM_DIGEST++FM_SPLIT+ cat >>the_mailbox_of_your_choice
X.Re
Xor
X.Rs
Xformail +FM_SKIP+1 -+FM_DIGEST++FM_SPLIT+ procmail
X.Re
X.PP
XTo supersede the Reply-To: field in a header you could use:
X.Rs
Xformail \-+FM_REN_INSERT+ "Reply-To: foo@bar"
X.Re
X.PP
XTo convert a non-standard mailbox file into a standard mailbox file you can
Xuse:
X.Rs
Xformail -+FM_DIGEST++FM_SPLIT+ cat <old_mailbox >>new_mailbox
X.Re
X.Sh MISCELLANEOUS
XThe regular expression that is used to find `real' postmarks is:
X.Rs
X"\\n\\n+FROM+[\\t ]*[^\\t\\n ]+[\\t ]+[^\\n\\t ]"
X.Re
X.PP
XIn order to make postprocessing of mail easier, formail concatenates any
Xcontinued header fields.
X.Sh "SEE ALSO"
X.na
X.BR mail (1),
X.BR binmail (1),
X.BR sendmail (8),
X.BR procmail (1),
X.BR sh (1)
X.ad
X.Sh DIAGNOSTICS
X.Tp 2.3i
XCan't fork
XToo many processes on this machine.
X.Tp
XCouldn't write to stdout
XThe program that formail was trying to pipe into didn't accept all the data
Xformail sent to it; this diagnostic can be disabled by the
X.B \-+FM_QUIET+
Xoption.
X.Tp
XFailed to execute "x"
XProgram not in path, or not executable.
X.Tp
XFile table full
XToo many open files on this machine.
X.Tp
XInvalid field-name: "x"
XThe specified field-name "x" does not contain a colon or contains control
Xcharacters.
X.Sh WARNINGS
XYou can save yourself and others a lot of mischief if you try to avoid using
Xthis autoreply feature on mails coming through mailinglists.  Depending
Xon the format of the incoming mail (which in turn depends on both the
Xoriginal sender's mail agent and the mailinglist setup) formail could
Xdecide to generate an autoreply header that replies to the list (if
Xthe original sender was careful enough though, formail will be able to pick
Xhis/her address, instead of the list's).  Now if the list is not intelligent
Xenough (most aren't) this autoreply will be widely distributed.
X.Sh BUGS
XNone.  It's perfect :-).
X.Sh
XCalling up formail with the \-+HELPOPT1+ or \-+HELPOPT2+ options will cause
Xit to display a command-line help page.
X.Sh AUTHOR
XStephen R. van den Berg at RWTH-Aachen, Germany
X.Rs
Xberg@pool.informatik.rwth-aachen.de
Xberg@physik.tu-muenchen.de
X.Re
END_OF_FILE
if test 6490 -ne `wc -c <'procmail/man/formail.man'`; then
    echo shar: \"'procmail/man/formail.man'\" unpacked with wrong size!
fi
# end of 'procmail/man/formail.man'
fi
if test -f 'procmail/man/manconf.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/man/manconf.c'\"
else
echo shar: Extracting \"'procmail/man/manconf.c'\" \(4971 characters\)
sed "s/^X//" >'procmail/man/manconf.c' <<'END_OF_FILE'
X/* A sed script generator (for transmogrifying the man pages automagically) */
X
X/*$Id: manconf.c,v 2.17 1992/06/03 14:40:24 berg Rel $*/
X
X#include "../config.h"
X#include "../procmail.h"
X
X#define pn(name,val)	pnr(name,(long)(val))
X
Xconst char devnull[]=DevNull;
Xconst char*const keepenv[]=KEEPENV,*const prestenv[]=PRESTENV,
X *const trusted_ids[]=TRUSTED_IDS;
X
Xmain()
X{
X#ifndef MAILBOX_SEPARATOR
X  ps("DOT_FORWARD",".forward");
X  ps("FW_content","\"|IFS=' ';exec /usr/local/bin/procmail #YOUR_LOGIN_NAME\"");
X#else
X  ps("DOT_FORWARD",".maildelivery");
X  ps("FW_content",
X   "* - | ? \"IFS=' ';exec /usr/local/bin/procmail #YOUR_LOGIN_NAME\"");
X#endif
X  plist("PRESTENV","\1.PP\1Other preset environment variables are "
X   ,prestenv,".\1",""," and ");
X  plist("KEEPENV",", except for the values of ",keepenv,"",""," and ");
X  plist("TRUSTED_IDS",", and procmail is invoked with one of the following\
X user or group ids: ",trusted_ids,",",""," or ");
X#ifdef LD_ENV_FIX
X  ps("LD_ENV_FIX","\1.PP\1For security reasons, procmail will wipe out all\
X environment variables starting with LD_ upon startup.");
X#else
X  ps("LD_ENV_FIX","");
X#endif
X#ifdef NO_USER_TO_LOWERCASE_HACK
X  ps("UPPERCASE_USERNAMES","\1.PP\1If the standard\1.BR getpwnam() (3)\1\
Xis case sensitive, and some users have login names with uppercase letters in\
X them, procmail will be unable to deliver mail to them, unless started with\
X their uid.");
X#else
X  ps("UPPERCASE_USERNAMES","");
X#endif
X  ps("SYSTEM_MBOX",SYSTEM_MBOX);
X#ifdef console
X  ps("console",console);
X#else
X  ps("console",vconsole);
X#endif
X  pname("INIT_UMASK");printf("0%lo/g\n",INIT_UMASK);
X  pn("DEFlinebuf",DEFlinebuf);
X  ps("BOGUSprefix",BOGUSprefix);
X  ps("PROCMAILRC",PROCMAILRC);
X  pn("HOSTNAMElen",HOSTNAMElen);
X  pn("DEFsuspend",DEFsuspend);
X  pn("DEFlocksleep",DEFlocksleep);
X  ps("TOkey",TOkey);
X  ps("TOsubstitute",TOsubstitute);
X  ps("DEFshellmetas",DEFshellmetas);
X  ps("DEFmaildir",DEFmaildir);
X  ps("DEFdefault",DEFdefault);
X  ps("DEFdefaultlock",strchr(DEFdefaultlock,'=')+1);
X  ps("DEFmsgprefix",DEFmsgprefix);
X  ps("DEFsendmail",DEFsendmail);
X  ps("DEFlockext",DEFlockext);
X  ps("DEFshellflags",DEFshellflags);
X  pn("DEFlocktimeout",DEFlocktimeout);
X  pn("DEFtimeout",DEFtimeout);
X  ps("Tmp",Tmp);
X  pc("DEBUGPREFIX",DEBUGPREFIX);
X  pc("HELPOPT1",HELPOPT1);
X  pc("HELPOPT2",HELPOPT2);
X  pc("VERSIONOPT",VERSIONOPT);
X  pc("PRESERVOPT",PRESERVOPT);
X  pc("TEMPFAILOPT",TEMPFAILOPT);
X  pc("FROMWHOPT",FROMWHOPT);
X  pc("ALTFROMWHOPT",ALTFROMWHOPT);
X  pc("DELIVEROPT",DELIVEROPT);
X  pn("MINlinebuf",MINlinebuf);
X  ps("FROM",FROM);
X  pc("HEAD_GREP",RECFLAGS[HEAD_GREP]);
X  pc("BODY_GREP",RECFLAGS[BODY_GREP]);
X  pc("DISTINGUISH_CASE",RECFLAGS[DISTINGUISH_CASE]);
X  pc("ALSO_NEXT_RECIPE",RECFLAGS[ALSO_NEXT_RECIPE]);
X  pc("ALSO_N_IF_SUCC",RECFLAGS[ALSO_N_IF_SUCC]);
X  pc("PASS_HEAD",RECFLAGS[PASS_HEAD]);
X  pc("PASS_BODY",RECFLAGS[PASS_BODY]);
X  pc("FILTER",RECFLAGS[FILTER]);
X  pc("CONTINUE",RECFLAGS[CONTINUE]);
X  pc("WAIT_EXIT",RECFLAGS[WAIT_EXIT]);
X  pc("WAIT_EXIT_QUIET",RECFLAGS[WAIT_EXIT_QUIET]);
X  pc("IGNORE_WRITERR",RECFLAGS[IGNORE_WRITERR]);
X  ps("FROM_EXPR",FROM_EXPR);
X  pc("UNIQ_PREFIX",UNIQ_PREFIX);
X  pc("ESCAP",ESCAP);
X  ps("UNKNOWN",UNKNOWN);
X  ps("OLD_PREFIX",OLD_PREFIX);
X  pc("FM_SKIP",FM_SKIP);
X  pc("FM_TOTAL",FM_TOTAL);
X  pc("FM_BOGUS",FM_BOGUS);
X  pc("FM_FORCE",FM_FORCE);
X  pc("FM_REPLY",FM_REPLY);
X  pc("FM_KEEPB",FM_KEEPB);
X  pc("FM_TRUST",FM_TRUST);
X  pc("FM_SPLIT",FM_SPLIT);
X  pc("FM_NOWAIT",FM_NOWAIT);
X  pc("FM_EVERY",FM_EVERY);
X  pc("FM_MINFIELDS",FM_MINFIELDS);
X  pn("DEFminfields",DEFminfields);
X  pc("FM_DIGEST",FM_DIGEST);
X  pc("FM_QUIET",FM_QUIET);
X  pc("FM_EXTRACT",FM_EXTRACT);
X  pc("FM_ADD_IFNOT",FM_ADD_IFNOT);
X  pc("FM_ADD_ALWAYS",FM_ADD_ALWAYS);
X  pc("FM_REN_INSERT",FM_REN_INSERT);
X  pc("FM_DEL_INSERT",FM_DEL_INSERT);
X  pn("EX_OK",EX_OK);
X  return EX_OK;
X}
X
Xpname(name)const char*const name;
X{ putchar('s');putchar('/');putchar('\\');putchar('+');putsesc(name);
X  putchar('\\');putchar('+');putchar('/');
X}
X
Xpnr(name,value)const char*const name;const long value;
X{ pname(name);printf("%ld/g\n",value);
X}
X
Xplist(name,preamble,list,postamble,ifno,andor)const char*const name,
X *const preamble,*const postamble,*const ifno,*const andor;
X const char*const*list;
X{ pname(name);
X  if(!*list)
X     putsesc(ifno);
X  else
X   { putsesc(preamble);goto jin;
X     do
X      { putsesc(list[1]?", ":andor);
Xjin:	putsesc(*list);
X      }
X     while(*++list);
X     putsesc(postamble);
X   }
X  puts("/g");
X}
X
Xps(name,value)const char*const name,*const value;
X{ pname(name);putsesc(value);puts("/g");
X}
X
Xpc(name,value)const char*const name;const int value;
X{ pname(name);putcesc(value);puts("/g");
X}
X
Xputcesc(i)
X{ switch(i)
X   { case '\1':i='\n';goto singesc;
X     case '\t':i='t';goto fin;
X     case '\n':i='n';
Xfin:	putchar('\\');
X     case '\\':putchar('\\');putchar('\\');
Xsingesc:
X     case '&':case '/':putchar('\\');
X   }
X  putchar(i);
X}
X
Xputsesc(a)const char*a;
X{ while(*a)
X     putcesc(*a++);
X}
END_OF_FILE
if test 4971 -ne `wc -c <'procmail/man/manconf.c'`; then
    echo shar: \"'procmail/man/manconf.c'\" unpacked with wrong size!
fi
# end of 'procmail/man/manconf.c'
fi
if test -f 'procmail/man/procmailex.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/man/procmailex.man'\"
else
echo shar: Extracting \"'procmail/man/procmailex.man'\" \(6636 characters\)
sed "s/^X//" >'procmail/man/procmailex.man' <<'END_OF_FILE'
X.de Id
X.ds Rv \\$3
X.ds Dt \\$4
X..
X.Id $Id: procmailex.man,v 2.7 1992/06/03 12:58:50 berg Rel $
X.de Sh
X.br
X.ne 11
X.SH "\\$1"
X..
X.de Ss
X.br
X.ne 10
X.SS "\\$1"
X..
X.de Tp
X.br
X.ne 9
X.TP \\$1
X..
X.de Rs
X.na
X.nf
X.RS
X..
X.de Re
X.RE
X.fi
X.ad
X..
X.de Sx
X.PP
X.ne \\$1
X.Rs
X..
X.de Ex
X.Re
X.PP
X..
X.TH PROCMAILRC 5 \*(Dt BuGless
X.SH NAME
X.na
Xprocmailex \- procmail rcfile examples
X.SH SYNOPSIS
X.B $HOME/+PROCMAILRC+ examples
X.ad
X.Sh DESCRIPTION
XFor a description of the rcfile format see
X.BR procmailrc (5).
X.PP
XThis man page shows several example recipes.  For examples of complete rcfiles
Xyou can check the NOTES section in
X.BR procmail (1),
Xor look at the example rcfiles part of the procmail source distribution
X(procmail/examples/?procmailrc).
X.Sh EXAMPLES
XSort out all mail coming from the scuba-dive mailling list into the mailfolder
Xscubafile (uses the locallockfile scubafile.lock).
X.Sx 3
X::
X^TOscuba
Xscubafile
X.Ex
XForward all mail from peter about compilers to william (and keep a copy
Xof it here in petcompil).
X.Sx 7
X:2 +CONTINUE+
X^From.*peter
X^Subject:.*compilers
X! william@somewhere.edu
X
X   :+ALSO_NEXT_RECIPE+
X   petcompil
X.Ex
XAn equivalent, but slightly slower solution that accomplishes the same:
X.Sx 9
X:2 +CONTINUE+
X^From.*peter
X^Subject:.*compilers
X! william@somewhere.edu
X
X   :2
X   ^From.*peter
X   ^Subject:.*compilers
X   petcompil
X.Ex
XAdd the headers of all messages that didn't come from the postmaster
Xto your private header collection (for
Xstatistics or mail debugging); and use the lockfile `headc.lock'.  In order
Xto make sure the lockfile is not removed until the pipe has finished,
Xyou have to specify option `+WAIT_EXIT+'; otherwise the lockfile would be
Xremoved as soon as the pipe has accepted the mail.
X.Sx 3
X:+PASS_HEAD++WAIT_EXIT++CONTINUE+:
X!From +[^ ]*(postmaster|Mailer)
X| uncompress headc.Z; cat >>headc; compress headc
X.Ex
XForward all mails shorter than 1000 bytes to my home address (no lockfile
Xneeded on this recipe).
X.Sx 3
X:
X< 1000
X! myname@home
X.Ex
XSplit up incoming digests from the surfing mailing list into their individual
Xmessages, and store them into surfing, using surfing.lock as the locallockfile.
X.Sx 3
X::
X^Subject:.*surfing.*Digest
X| formail +FM_SKIP+1 \-+FM_DIGEST++FM_SPLIT+ cat >>surfing
X.Ex
XStore everything coming from the postmaster or mailer-daemon (like bounced
Xmail) into the file postm, using postm.lock as the locallockfile.
X.Sx 3
X::
X^From +[^ ]*(postmaster|Mailer)
Xpostm
X.Ex
XA simple autoreply recipe.  It makes sure that neither bouncing mail (from
Xpostmaster or the mailer-daemon), nor mail coming from yourself will be
Xautoreplied.  If this precaution would not be taken, disaster could result
X("ringing" mail).  In order for this recipe to autoreply to all the incoming
Xmail, you should of course insert it before all other recipes in your rcfile.
XHowever, it is advisable to put it
X.I after
Xany recipes that process the mails from subscribed mailinglists; it generally
Xis not a good idea to generate autoreplies to mailinglists.
X.Sx 4
X: 2 +PASS_HEAD+ +CONTINUE+
X!^From +[^ ]*(postmaster|Mailer)
X!^From +YOUR_LOGIN_NAME
X| (formail \-+FM_REPLY+ ; echo "Mail received.") | $SENDMAIL \-t
X.Ex
XA more complicated autoreply recipe, that implements the functional equivalent
Xof the well known
X.BR vacation (1)
Xprogram.  This recipe is based on the same principles as the last one (prevent
X"ringing" mail).  In addition to that however, it maintains a vacation database
Xby extracting the name of the sender and appending it the file $ALREADYSENT, if
Xthe name is
X.B not
Xalready in there.  If the name was new, an autoreply will be sent (using the
X`+ALSO_N_IF_SUCC+' flag functionality).  To reliably extract the name of the
Xsender, I let formail generate an autoreply header (thereby making it figure
Xout the most appropriate sender address), and then telling it to extract the
Xvalue of the `To:' field.
X.Sx 14
XSHELL=/bin/sh    # for other shells, this might need adjustment
XALREADYSENT=$MAILDIR/vacation     # the vacation database
X
X: 2 +PASS_HEAD++WAIT_EXIT_QUIET++CONTINUE+:                          # the lockfile is important
X!^From +[^ ]*(postmaster|Mailer)
X!^From +YOUR_LOGIN_NAME
X| FROM="`formail \-+FM_REPLY++FM_EXTRACT+ To:`" ;\\
X  if fgrep \-e "$FROM" <$ALREADYSENT ;\\
X  then exit 1 ;\\
X  else echo "$FROM" >>$ALREADYSENT ;\\
X  fi
X
X   :+ALSO_N_IF_SUCC++PASS_HEAD++CONTINUE+
X   | (formail \-+FM_REPLY+ ; echo "Mail received.") | $SENDMAIL \-t
X.Ex
XStore all messages concerning TeX in separate, unique filenames, in a directory
Xnamed texmail (this directory has to exist); there is no need to use lockfiles
Xin this case, so we won't.
X.Sx 3
X:
X^(To|Apparently-To|Cc|Subject):.*tex[^t]
Xtexmail
X.Ex
XThe same as above, except now we store the mails in numbered files (MH mail
Xfolder), again the texmail directory has to exist already.
X.Sx 3
X:
X^(To|Apparently-To|Cc|Subject):.*tex[^t]
Xtexmail/.
X.Ex
XSuppose you have two accounts, you use both accounts regularly, but they are
Xin very distinct places (i.e. you can only read mail that arrived at either one
Xof the accounts).  You would like to forward mail arriving at account one to
Xaccount two, and the other way around.  The first thing that comes to mind is
Xusing .forward files at both sites; this won't work of course, since you will
Xbe creating a mail loop.  This mail loop can be avoided by inserting the
Xfollowing recipe in front of all other recipes in the +PROCMAILRC+ files on
Xboth sites.  If you make sure that you add the same X-Loop: field at both
Xsites, mail can now safely be forwarded to the other account from either of
Xthem.
X.Sx 4
X:+CONTINUE+
X!^X-Loop: yourname@your.main.mail.address
X| formail \-+FM_ADD_ALWAYS+ "X-Loop: yourname@your.main.mail.address" | \\
X   $SENDMAIL \-oi yourname@the.other.account
X.Ex
XThe following one is rather exotic, but it only serves to demonstrate a
Xfeature.  Suppose you have a file in your HOME directory called ".urgent",
Xand the (one) person named in that file is the sender of an incoming mail,
Xyou'd like that mail to be stored in $MAILDIR/urgent instead of in any of the
Xnormal mailfolder it would have been sorted in.  Then this is what you could do
X(beware, the filelength of $HOME/.urgent should be well below $LINEBUF,
Xincrease LINEBUF if necessary):
X.Sx 5
XURGMATCH=`cat $HOME/.urgent`
X
X:+BODY_GREP+:
X$^From.*${URGMATCH}.*
Xurgent
X.Re
X.Sh "SEE ALSO"
X.na
X.BR procmail (1),
X.BR procmailrc (5),
X.BR sh (1),
X.BR csh (1),
X.BR mail (1),
X.BR binmail (1),
X.BR uucp (1C),
X.BR aliases (5),
X.BR sendmail (8),
X.BR egrep (1V),
X.BR lockfile (1),
X.BR formail (1)
X.ad
X.Sh AUTHOR
XStephen R. van den Berg at RWTH-Aachen, Germany
X.Rs
Xberg@pool.informatik.rwth-aachen.de
Xberg@physik.tu-muenchen.de
X.Re
END_OF_FILE
if test 6636 -ne `wc -c <'procmail/man/procmailex.man'`; then
    echo shar: \"'procmail/man/procmailex.man'\" unpacked with wrong size!
fi
# end of 'procmail/man/procmailex.man'
fi
if test -f 'procmail/nonint.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/nonint.c'\"
else
echo shar: Extracting \"'procmail/nonint.c'\" \(7510 characters\)
sed "s/^X//" >'procmail/nonint.c' <<'END_OF_FILE'
X/************************************************************************
X *	Collection of routines that don't return int			*
X *									*
X *	Copyright (c) 1990-1992, S.R. van den Berg, The Netherlands	*
X *	The sources can be freely copied for non-commercial use.	*
X *	#include "README"						*
X *									*
X ************************************************************************/
X#ifdef RCS
Xstatic char rcsid[]="$Id: nonint.c,v 2.19 1992/04/09 16:16:41 berg Rel $";
X#endif
X#include "config.h"
X#include "procmail.h"
X
X#define nomemretry	noresretry
X#define noforkretry	noresretry
X
Xvoid*tmalloc(len)const size_t len;    /* this malloc can survive a temporary */
X{ void*p;int i;				    /* "out of swap space" condition */
X  lcking|=lck_ALLOCLIB;
X  if(p=malloc(len))
X     goto ret;
X  lcking|=lck_MEMORY;
X  if(p=malloc(1))
X     free(p);			   /* works on some systems with latent free */
X  for(i=nomemretry;i<0||i--;)
X   { suspend();		     /* problems?  don't panic, wait a few secs till */
X     if(p=malloc(len))	     /* some other process has paniced (and died 8-) */
Xret:  { lcking&=~(lck_MEMORY|lck_ALLOCLIB);return p;
X      }
X   }
X  nomemerr();
X}
X
Xvoid*trealloc(old,len)void*const old;const size_t len;
X{ void*p;int i;
X  lcking|=lck_ALLOCLIB;
X  if(p=realloc(old,len))
X     goto ret;				    /* for comment see tmalloc above */
X  lcking|=lck_MEMORY;
X  if(p=malloc(1))
X    free(p);
X  for(i=nomemretry;i<0||i--;)
X   { suspend();
X     if(p=realloc(old,len))
Xret:  { lcking&=~(lck_MEMORY|lck_ALLOCLIB);return p;
X      }
X   }
X  nomemerr();
X}
X
Xtfree(p)void*const p;
X{ lcking|=lck_ALLOCLIB;free(p);lcking&=~lck_ALLOCLIB;
X}
X		       /* line buffered to keep concurrent entries untangled */
Xlog(newt)const char*const newt;
X{ int lnew,i;static lold;static char*old;char*p;
X#ifndef O_CREAT
X  lseek(STDERR,0L,SEEK_END);		  /* locking should be done actually */
X#endif
X  if(!(lnew=strlen(newt))||nextexit)			     /* force flush? */
X     goto flush;
X  i=lold+lnew;
X  if(p=lold?realloc(old,i):malloc(i))			 /* unshelled malloc */
X   { memmove((old=p)+lold,newt,(size_t)lnew);			   /* append */
X     if(p[(lold=i)-1]=='\n')					     /* EOL? */
X	rwrite(STDERR,p,i),lold=0,free(p);		/* flush the line(s) */
X   }
X  else						   /* no memory, force flush */
Xflush:
X   { if(lold)
X      { rwrite(STDERR,old,lold);lold=0;
X	if(!nextexit)
X	   free(old);			/* don't use free in signal handlers */
X      }
X     if(lnew)
X	rwrite(STDERR,newt,lnew);
X   }
X}
X
X#include "shell.h"
X
Xpid_t sfork()				/* this fork can survive a temporary */
X{ pid_t i;int r;			   /* "process table full" condition */
X  log("");r=noforkretry;			  /* flush log, just in case */
X  while((i=fork())==-1)
X   { lcking|=lck_FORK;
X     if(!(r<0||r--))
X	break;
X     suspend();
X   }
X  lcking&=~lck_FORK;return i;
X}
X
Xvoid srequeue()
X{ retval=EX_TEMPFAIL;sterminate();
X}
X
Xvoid slose()
X{ fakedelivery=2;sterminate();
X}
X
Xvoid sbounce()
X{ retval=EX_CANTCREAT;sterminate();
X}
X
Xextern char*lastexec,*backblock;		/* see retint.c for comment */
Xextern long backlen;
Xextern pid_t pidfilt;
Xextern pbackfd[2];
X
Xvoid stermchild()
X{ if(pidfilt>0)		    /* don't kill what is not ours, we might be root */
X     kill(pidfilt,SIGTERM);
X  log("Rescue of unfiltered data ");
X  if(dump(PWRB,backblock,backlen))    /* pump back the data via the backpipe */
X     log("failed\n");
X  else
X     log("succeeded\n");
X  exit(EX_UNAVAILABLE);
X}
X
Xvoid ftimeout()
X{ alarm(0);alrmtime=0;
X  if(pidchild>0&&!kill(pidchild,SIGTERM))	   /* careful, killing again */
X	log("Timeout, terminating"),logqnl(lastexec);
X  signal(SIGALRM,ftimeout);
X}
X
Xlong dump(s,source,len)const int s;const char*source;long len;
X{ int i= -1;
X  if(s>=0)
X   { fdlock(s);lastdump=len;smboxseparator(s); /* prepend optional separator */
X#ifndef O_CREAT
X     lseek(s,0L,SEEK_END);
X#endif
X#ifndef NO_NFS_ATIME_HACK
X     if(len&&tofile)		       /* if it is a file, trick NFS into an */
X	--len,rwrite(s,source++,1),sleep(1);		    /* a_time<m_time */
X#endif
X     while(i=rwrite(s,source,BLKSIZ<len?BLKSIZ:(int)len))
X      { if(i<0)
X	 { i=0;goto writefin;
X	 }
X	len-=i;source+=i;
X      }
X     if(!len&&(lastdump<2||!(source[-1]=='\n'&&source[-2]=='\n')))
X	lastdump++,rwrite(s,newline,1);	       /* message always ends with a */
X     emboxseparator(s);		 /* newline and an optional custom separator */
Xwritefin:
X     fdunlock();len-=i;i=rclose(s);
X   }						  /* return an error even if */
X  return ignwerr?(ignwerr=0):i&&!len?-1:len;	   /* nothing was to be sent */
X}
X
Xlong pipin(line,source,len)char*const line;char*source;long len;
X{ int poutfd[2];
X  rpipe(poutfd);
X  if(!(pidchild=sfork()))				    /* spawn program */
X     rclose(PWRO),rclose(rc),getstdin(PRDO),callnewprog(line);
X  rclose(PRDO);
X  if(forkerr(pidchild,line))
X     return 1;
X  if(len=dump(PWRO,source,len))			    /* dump mail in the pipe */
X     writeerr(line);		       /* pipe was shut in our face, get mad */
X  if(pwait&&waitfor(pidchild)!=EX_OK)	    /* optionally check the exitcode */
X   { if(!(pwait&2))				  /* do we put in on report? */
X	progerr(line);
X     len=1;
X   }
X  pidchild=0;
X  if(!sh)
X     concatenate(line);
X  lastfolder=cstr(lastfolder,line);return len;
X}
X
Xchar*readdyn(bf,filled)char*bf;long*const filled;
X{ int i;long oldsize;
X  oldsize= *filled;goto jumpin;
X  do
X   { *filled+=i;				/* change listed buffer size */
Xjumpin:
X#ifdef SMALLHEAP
X     if((size_t)*filled>=(size_t)(*filled+BLKSIZ))
X	lcking|=lck_MEMORY,nomemerr();
X#endif
X     bf=realloc(bf,*filled+BLKSIZ);    /* dynamically adjust the buffer size */
Xjumpback:;
X   }
X  while(0<(i=rread(STDIN,bf+*filled,BLKSIZ)));			/* read mail */
X  if(pidchild>0)
X   { pidchild=0;getstdin(PRDB);		       /* filter ready, get backpipe */
X     if(1==rread(STDIN,buf,1))			      /* backup pipe closed? */
X      { bf=realloc(bf,(*filled=oldsize+1)+BLKSIZ);bf[oldsize]= *buf;
X	 goto jumpback;			       /* filter goofed, rescue data */
X      }
X   }
X  pidchild=0;					/* child must be gone by now */
X  if(!*filled)
X     return realloc(bf,1);		     /* +1 for housekeeping purposes */
X  return realloc(bf,*filled+1);			/* minimise the buffer space */
X}
X
Xchar*fromprog(name,dest)char*const name;char*dest;
X{ int pinfd[2];long nls;
X  rpipe(pinfd);inittmout(name);
X  if(!(pidchild=sfork()))				    /* spawn program */
X   { rclose(STDIN);opena(devnull);rclose(PRDI);rclose(rc);rclose(STDOUT);
X     rdup(PWRI);rclose(PWRI);callnewprog(name);
X   }
X  rclose(PWRI);nls=0;
X  if(!forkerr(pidchild,name))
X   { while(0<rread(PRDI,dest,1))			    /* read its lips */
X	if(*dest=='\n')				    /* careful with newlines */
X	   nls++;		    /* trailing newlines should be discarded */
X	else
X	 { if(nls)
X	      for(dest[nls]= *dest;*dest++='\n',--nls;);     /* fill them in */
X	   dest++;
X	 }
X     waitfor(pidchild);
X   }
X  pidchild=0;rclose(PRDI);*dest='\0';return dest;
X}
X
Xchar*cat(a,b)const char*const a,*const b;
X{ return strcat(strcpy(buf,a),b);
X}
X
Xchar*tstrdup(a)const char*const a;
X{ int i;
X  i=strlen(a)+1;return tmemmove(malloc(i),a,i);
X}
X
Xconst char*tgetenv(a)const char*const a;
X{ const char*b;
X  return(b=getenv(a))?b:"";
X}
X
Xchar*cstr(a,b)char*const a;const char *const b; /* dynamic buffer management */
X{ if(a)
X     free(a);
X  return tstrdup(b);
X}
X
Xlong renvint(i,env)const long i;const char*const env;
X{ const char*p;long t;
X  t=strtol(env,(char**)&p,10);return p==env?i:t;  /* parse like a decimal nr */
X}
X
Xchar*egrepin(expr,source,len,casesens)char*expr;const char*source;
X const long len;
X{ source=bregexec(expr=bregcomp(expr,!casesens),
X   source,len>0?(size_t)len:(size_t)0,!casesens);
X  free(expr);return(char*)source;
X}
END_OF_FILE
if test 7510 -ne `wc -c <'procmail/nonint.c'`; then
    echo shar: \"'procmail/nonint.c'\" unpacked with wrong size!
fi
# end of 'procmail/nonint.c'
fi
if test -f 'procmail/strpbrk.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/strpbrk.h'\"
else
echo shar: Extracting \"'procmail/strpbrk.h'\" \(96 characters\)
sed "s/^X//" >'procmail/strpbrk.h' <<'END_OF_FILE'
X/*$Id: strpbrk.h,v 1.1 1992/04/16 12:57:55 berg Rel $*/
X#ifdef NOstrpbrk
Xchar*strpbrk();
X#endif
END_OF_FILE
if test 96 -ne `wc -c <'procmail/strpbrk.h'`; then
    echo shar: \"'procmail/strpbrk.h'\" unpacked with wrong size!
fi
# end of 'procmail/strpbrk.h'
fi
echo shar: End of archive 2 \(of 5\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Sincerely,                                  berg@pool.informatik.rwth-aachen.de
           Stephen R. van den Berg (AKA BuGless).    berg@physik.tu-muenchen.de

He did a quarter of the work in *half* the time!

exit 0 # Just in case...
