Newsgroups: comp.sources.misc
From: berg@pool.informatik.rwth-aachen.de (Stephen R. van den Berg)
Subject:  v31i040:  procmail - mail processing program v2.71, Part01/05
Message-ID: <csm-v31i040=procmail.154351@sparky.IMD.Sterling.COM>
X-Md4-Signature: 97edcbfa4ec767b6b7f96a42e4f129eb
Date: Thu, 16 Jul 1992 20:44:25 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: berg@pool.informatik.rwth-aachen.de (Stephen R. van den Berg)
Posting-number: Volume 31, Issue 40
Archive-name: procmail/part01
Environment: UNIX, sendmail, smail, MMDF
Supersedes: procmail: Volume 29, Issue 90-94

The procmail mail processing program. (v2.71 1992/07/01)

Can be used to create mail-servers, mailing lists, sort your incoming mail
into separate folders/files (real convenient when subscribing to one or more
mailing lists or for prioritising your mail), preprocess your mail, start
any programs upon mail arrival (e.g. to generate different chimes on your
workstation for different types of mail) or selectively forward certain
incoming mail automatically to someone.

The accompanying formail program enables you to generate autoreplies, split up
digests/mailboxes into the original messages, do some very simple
header-munging/extraction, or force mail into mail-format (with leading From
line).
 -- 
Sincerely,                                  berg@pool.informatik.rwth-aachen.de
           Stephen R. van den Berg (AKA BuGless).    berg@physik.tu-muenchen.de
 ----------------------
A recent version can be picked up at various comp.sources.misc archives.
The latest version can be obtained directly from the ftp-archive at:

	ftp.informatik.rwth-aachen.de (137.226.112.31)

	as compressed tar file:		pub/unix/procmail.tar.Z		<128KB
	or in compressed shar format:	pub/unix/procmail.0?.Z
 ----------------------
Feature summary for procmail:
	+ It's small
	+ Very easy to install (rated PG6 :-)
	+ Simple to maintain and configure because
	  all you need is actually only ONE executable (procmail)
	  and ONE configuration file (.procmailrc)
	+ Is event driven (i.e. gets invoked automagically when mail arrives)
	+ Does not use *any* temporary files
	+ Uses standard egrep regular expressions
	+ Allows for very-easy-to-use yes-no decisions on where the mail
	  should go (can take the size of the mail into consideration)
	+ Filters, delivers and forwards mail *reliably*
	+ Provides a reliable hook (you might even say anchor :-) for any
	  programs or shell scripts you may wish to start upon mail arrival
	+ Performs heroically under even the worst conditions
	  (file system full, out of swap space, process table full,
	  file table full, missing support files, unavailable executables,
	  denied permissions) and tries to deliver the mail somehow anyway
	+ Absolutely undeliverable mail (after trying every trick in the book)
	  will bounce back to the sender (or not, your choice)
	+ Is one of the few mailers to perform reliable mailbox locking across
	  NFS as well (DON'T use NFS mounted mailboxes WITHOUT installing
	  procmail, you may use valuable mail one day)
	+ Supports four mailfolder standards: single file folders (standard
	  and nonstandard VNIX format), directory folders that contain one file
	  per message, or the similar MH directory folders (numbered files)
	+ Variable assignment and substitution is an extremely complete subset
	  of the standard /bin/sh syntax
	+ Provides a mail log file, which logs all mail arrival, shows
	  in summary whence it came from, what it was about, where it went
	  (what folder) and how long (in bytes) it was
	+ Uses this log file to display a wide range of diagnostic and error
	  messages (if something went wrong)
	+ Does not impose *any* limits on line lenghts, mail length (as long
	  as memory permits), or the use of any character (any 8-bit character,
	  including '\0' is allowed) in the mail
	+ It has man pages (boy, does *it* have man pages)
	+ Procmail can be used as a local delivery agent (a completely
	  integrated substitute for /bin/mail), in which case it can heal
	  your system mailbox, if something messes up the permissions
	+ It runs on virtually all (old and future) operating systems which
	  names start with a 'U' or end in an 'X' :-) (i.e. extremely portable
	  code; POSIX, ANSI C and K&R conforming)
	+ Is clock skew immune (e.g. in the case of NFS mounted mailboxes)
	+ Works with (among others?) sendmail, smail and MMDF

Feature summary for formail:
	+ Can generate auto-reply headers
	+ Can convert mail into standard mailbox format (so that you can
	  process it with standard mail programs)
	+ Can split up mailboxes into the individual messages
	+ Can split up digests into the individual messages
	+ Can split up saved articles into the individual articles
	+ Can do simple header munging/extraction

Feature summary for lockfile:
	+ Provides NFS-secure lockfiles to shell script programmers
	+ Gives normal users the ability to lock their system mailbox,
	  regardless of permissions on the mail-spool directory
-----------------------------cut here-------------------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 5)."
# Contents:  procmail procmail/HISTORY procmail/Manifest
#   procmail/README procmail/common.c procmail/examples
#   procmail/examples/1procmailrc procmail/examples/2procmailrc
#   procmail/examples/2rmail procmail/examples/3rmail
#   procmail/examples/forward procmail/examples/listrc
#   procmail/examples/mailstat procmail/exopen.c procmail/exopen.h
#   procmail/lockfile.c procmail/man procmail/man/mansed
#   procmail/patchlevel.h procmail/procmail.h procmail/recommend.c
#   procmail/shell.h procmail/strpbrk.c
# Wrapped by berg@minipicc on Thu Jul 16 14:34:20 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'procmail' ; then
    echo shar: Creating directory \"'procmail'\"
    mkdir 'procmail'
fi
if test -f 'procmail/HISTORY' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/HISTORY'\"
else
echo shar: Extracting \"'procmail/HISTORY'\" \(6202 characters\)
sed "s/^X//" >'procmail/HISTORY' <<'END_OF_FILE'
X	Only the last entry is complete, the others might have been condensed.
X
X1990/12/07: v1.00
X1990/12/12: v1.01
X1991/02/04: v1.02
X1991/02/13: v1.10
X1991/02/21: v1.20
X1991/02/22: v1.21
X1991/03/01: v1.30
X1991/03/15: v1.35
X	    Started using RCS to manage the source
X1991/06/04: v1.99
X1991/06/10: v2.00
X1991/06/11: v2.01
X1991/06/12: v2.02
X1991/06/20: v2.03
X1991/07/04: v2.10
X1991/07/12: v2.11
X1991/10/02: v2.20 (never released)
X1991/10/18: v2.30
X	    Implemented a custom regular expression library (fully egrep
X	       compatible), should eliminate the annoyances with incompatible
X	       egreps
X	    Accomplished the doubtful milestone of having a source file
X	       (regexp.c) which provokes a compiler error on an old compiler
X	       (if using the optimiser)
X	    Ignoring leading spaces on condition lines now (means that
X	       everything can be indented in the rcfile)
X1991/10/22: v2.31
X1991/12/05: v2.40
X	    Made a clear debugging-aid entry in the INSTALL file
X	    Made procmail capable of healing the recipient's mail spool file
X	    Tricked NFS into supplying an access_time<modification_time for the
X	       folders written
X1991/12/13: v2.50
X1992/01/22: v2.60
X	    Enhanced the response to signals (SIGTERM and SIGQUIT now have
X	       different meanings)
X1992/01/31: v2.61
X	    Updated the directions for .forward file contents
X	    Fixed the EDQUOT define (some machines didn't define it)
X	    Eliminated a rare (no report of it occuring yet) inconvenience,
X	       a temporary file could be left lying around if procmail would
X	       be killed in a very small window after an open()
X	    Kludge the username into lowercase after the -d option
X	    Added specific directions for sites running smail (see
X	       examples/advanced)
X	    Added a search for sendmail in autoconf
X	    Fixed a problem in the implicit-lockfile-searching code
X	    Added the ARCHITECTURE variable to the Makefile (for convenience)
X1992/04/30: v2.70
X	    Added NO_USER_TO_LOWERCASE_HACK and NO_NFS_ATIME_HACK defines to
X	       config.h
X	    Added LD_LIBRARY_PATH protection (would have been a security hole
X	       on some machines)
X	    Fixed mistakenly default usage of KERNEL_LOCKS (was enabled
X	       regardless of the definition of KERNEL_LOCKS in config.h), if
X	       your system is running buggy lockd's, problems could have
X	       occurred
X	    Inserted some casts to shut up systems with ANSI compilers and
X	       prototyped include files
X	    Made sure logfile is flushed before forking
X	    Made sure no library calls are made in signal handlers
X	    Added a `vacation'-autoreply sample in examples/advanced
X	    Worked around a `PATH' bug in some Bourne shells
X	    Sped up sputenv, the smart environment handler routine
X	    Made sure procmail checks the return value from close()
X	    Made the man pages yet more portable (.LP->.PP)
X	    Made it possible for lockfile to be setuid or setgid, so that
X	       it is able to create and unlink lockfiles in the mail
X	       spool directory, even if normal users cannot
X	    Created the targets 'recommend' and 'suid' in Makefile, in
X	       order to make suid/sgid recommendations even more obvious,
X	       not easily overlooked and automatic
X	    Worked around bugs in some compilers not accepting:
X	       - struct eps const*const something;
X	       - char a[2]; &a;
X	    Worked around a bug in the SINIX include files (wrong protype for
X	       uname)
X	    Made procmail & lockfile clock skew independent (during LOCKTIMEOUT)
X	    By popular demand: added possibility to select mails on size
X	    Made procmail accept multiple recipients (this was not as trivial
X	       as it sounds!), in order for complete compatibility with mailers
X	       like smail 2.x
X	    Expanded the mail-delivery-agent instructions in examples/advanced,
X	       this includes specific intstructions for smail 2.x
X	    Made special entries in config.h for semi-permanent environment-
X	       variable overrides
X	    Made formail more intelligent, it can now parse full-fledged
X	       RFC822 addresses (quoting et al)
X	    Let formail look at the Date: field when reconstructing the date
X	    Changed stdin handling in forks in formail, to circumvent a bug in
X	       HP/UX
X	    A complete rewrite of formail, the code got bigger, the runtime
X	       requirement got bigger, it got slower, but, it's more structured
X	       (so much for structured programming :-)
X	    Provide a separate strpbrk.c file, since I use it in several
X	       programs now
X	    Made procmail check the permissions of its invoker, generate
X	       an overriding From_ line if necessary, and consequently made it
X	       accept the -f option (fromwhom), and also the alternate obsolete
X	       -r option of course
X	    Wiped out the ./include tree, made autoconf check it instead (the
X	       compile line looks so terribly clean now :-)
X	    Procmail makes an additional security check on the rcfiles before
X	       accepting them (owner and permissions, see man page)
X	    Fixed the `spurious' 0660 permissions on system-mailboxes
X1992/07/01: v2.71
X	    Sharpened the autoconf "const" check, to catch buggy AIX compilers
X	    Made the MAILBOX_SEPARATORS more orthogonal (i.e. you can define
X	       one or both now)
X	    Added the -A option to formail, the only option that was missing
X	       (to be able to boldly add header fields)
X	    Fixed some typos and extended the procmailex man page by a popular
X	       example
X	    Enhanced the MH directory delivery mode, procmail uses the MH
X	       method of finding the next number now (this requires procmail
X	       to read the directory)
X	    Fixed a typo in the WIFEXITED substitute macro (for non-posix
X	       systems), should fix all erroneous "program failed" messages
X	    Fixed a problem on byte-aligned machines with the 'i' flag
X	    Now throwing away all environment variables starting with LD_
X	       (not just LD_LIBRARY_PATH), but only on those machines that
X	       have the security hole (i.e. SunOS)
X	    Created logfile summariser (in shell-script form), by popular
X	       demand (examples/mailstat)
X	    Gave procmail, formail, lockfile and mailstat a more verbose
X	       command line help (called up by -h or -?)
END_OF_FILE
if test 6202 -ne `wc -c <'procmail/HISTORY'`; then
    echo shar: \"'procmail/HISTORY'\" unpacked with wrong size!
fi
# end of 'procmail/HISTORY'
fi
if test -f 'procmail/Manifest' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/Manifest'\"
else
echo shar: Extracting \"'procmail/Manifest'\" \(2268 characters\)
sed "s/^X//" >'procmail/Manifest' <<'END_OF_FILE'
XMakefile	We all know what that is.
XREADME		Important, read it.
XINSTALL		A description of what has to be done to install procmail.
XFAQ		Lists the things you are too lazy to figure out yourself.
XHISTORY		Recent and ancient changes, features (or bugs) documented.
XFEATURES	A summary of all the things procmail is particularly good at.
Xlockfile.c	main program for lockfile
Xformail.c	main program for formail
XManifest	You guessed it.
Xprocmail.c	main program for procmail.
Xnonint.c	Collection of routines that don't return ints.
Xretint.c	Collection of routines that return ints.
Xgoodies.c	Some real nice routines, deserve to be put in a library.
Xregexp.c	Custom regular expression library, *fully* egrep compatible.
Xcommon.c	Some routines that are used by procmail and formail.
Xexopen.c	Collection of routines about an NFS secure excl. open.
Xexopen.h	The very same.
Xstrpbrk.c	A substitute for a possibly missing strpbrk() library function.
Xstrpbrk.h	Yes.
Xprocmail.h	Include file with all declarations for procmail.
X
Xincludes.h	System include files are all referenced here.
Xconfig.h	The file to edit if you want to change, yes, the configuration.
Xautoconf	The shell script that seizes your compiler and machine,
X		and then creates a file called autoconf.h describing the
X		kludges that are going to be applied for your installation.
Xrecommend.c	A program showing the best configuration for you.
X
Xshell.h		Defines a few 'shell' macros for malloc and the like.
Xman/*		Yes, the man pages (made in a labour camp) and two additional
X		files which make these man pages auto-adapting.
Xexamples/mailstat
X		A summary generator for procmail generated logfiles.
Xexamples/?procmailrc
X		Sample .procmailrc files.
Xexamples/?rmail
X		Sample shell scripts that demonstrate how to use
X		lockfiles while reading the mail (to ensure mail integrity
X		as soon as you exit the mail program).
Xexamples/forward
X		A sample .forward file (MMDF users should disregard this file
X		and look in the man page).
Xexamples/advanced
X		Some extra info for network mounted mailboxes, examples of
X		advanced .procmailrc expressions and using procmail as
X		a local delivery agent.
Xexamples/mailinglist
X		Comprehensive instructions on maintaining a mailinglist.
Xexamples/listrc Model-rcfile for use in mailinglists.
END_OF_FILE
if test 2268 -ne `wc -c <'procmail/Manifest'`; then
    echo shar: \"'procmail/Manifest'\" unpacked with wrong size!
fi
# end of 'procmail/Manifest'
fi
if test -f 'procmail/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/README'\"
else
echo shar: Extracting \"'procmail/README'\" \(4205 characters\)
sed "s/^X//" >'procmail/README' <<'END_OF_FILE'
XFor installation instructions see the INSTALL file.
X----------------------
XProcmail & formail mail processing package.
XCopyright (c) 1990-1992, S.R. van den Berg, The Netherlands.
X
XSome legal stuff:
X
XUse this software package at your own risk.  The programmer cannot
Xbe held liable for any incurred damages, directly or indirectly due to
Xthe use or inability to use this software.
X
XYou are encouraged to distribute this package freely.  This package is
Xhowever not to be sold (minor transfer costs excepted) or included in
Xany commercially sold software package (if you want to do this anyway,
Xcontact me (address below), and we'll work something out).
X
XIf you distribute it, please leave the package intact.	You are allowed to
Xtake parts from this distribution and distribute these separately as long
Xas you retain the copyright messages.  If you redistribute any part of this
Xpackage in a modified form, be sure to mark the parts you changed.
XIf you have some important changes that might be useful to the rest of the
Xworld, contact me instead.
X
X-------------------------- SYSTEM REQUIREMENTS -------------------------------
X
XAny *NIX-alike system.
X
XSendmail, smail, MMDF or compatible mailers (in effect any mailer that can
Xprocess RFC-822 compliant mails).
X
XThe most important system calls that need to be supported (among others):
Xdup(),wait(),getpwnam(),fork(),pipe()
X
XFor a more complete list of all library references see "includes.h"
X
X------------------------------ DESCRIPTION -----------------------------------
X
XThe procmail mail processing program. (v2.71 1992/07/01)
X
XCan be used to create mail-servers, mailing lists, sort your incoming mail
Xinto separate folders/files (real convenient when subscribing to one or more
Xmailing lists or for prioritising your mail), preprocess your mail, start
Xany programs upon mail arrival (e.g. to generate different chimes on your
Xworkstation for different types of mail) or selectively forward certain
Xincoming mail automatically to someone.
X
XThe accompanying formail program enables you to generate autoreplies, split up
Xdigests/mailboxes into the original messages, do some very simple
Xheader-munging/extraction, or force mail into mail-format (with leading From
Xline).
X
X----------------------
X
XI made the utmost effort to make procmail as robust as any program can be
X(every conceivable system error is caught *and* handled).
X
XProcmail was designed to deliver the mail under the worst conditions
X(file system full, out of swap space, process table full, file table full,
Xmissing support files, unavailable executables; it all doesn't matter).
XShould (in the unlikely event) procmail be unable to deliver your mail
Xsomewhere, the mail will bounce back to the sender or reenter the mailqueue
X(your choice).
X
XFor a more extensive list of features see the FEATURES file.
X
X----------------------
X
XHowever, as with any program, bugs cannot be completely ruled out.
XI tested the program extensively, and believe it should be relatively
Xbug free (no known bug at the time).  Should, however, anyone find any
Xbugs (highly unlikely :-), I would be pleased (well, sort of :-) to hear
Xabout it.  Please send me the patches or bug report.
XI'll look at them and will try to fix it in a future release.
X(BTW, if you should find any spelling or grammar errors in these files,
Xdon't hesitate to point them out to me; I like correct English just as much
Xas you do).
X
XPlease note that this program essentially is supposed to be static, that
Xmeans no extra features (honouring the VNIX spirit) are supposed to be
Xadded (though any useful suggestions will be appreciated and evaluated if
Xtime permits).
X
XCheers,
X       Stephen R. van den Berg	at RWTH-Aachen, Germany.
X
XInternet E-mail:		berg@pool.informatik.rwth-aachen.de
X				berg@physik.tu-muenchen.de
X
XSnail-Mail:	P.O.Box 21074
X		6369 ZG Simpelveld
X		The Netherlands
X
X----------------------
XA recent version can be picked up at various comp.sources.misc archives.
XThe latest version can be obtained directly from the ftp-archive at:
X
X	ftp.informatik.rwth-aachen.de (137.226.112.31)
X
X	as compressed tar file:		pub/unix/procmail.tar.Z		<128KB
X	or in compressed shar format:	pub/unix/procmail.0?.Z
X----------------------
END_OF_FILE
if test 4205 -ne `wc -c <'procmail/README'`; then
    echo shar: \"'procmail/README'\" unpacked with wrong size!
fi
# end of 'procmail/README'
fi
if test -f 'procmail/common.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/common.c'\"
else
echo shar: Extracting \"'procmail/common.c'\" \(2031 characters\)
sed "s/^X//" >'procmail/common.c' <<'END_OF_FILE'
X/************************************************************************
X *	A some common routines for procmail and formail			*
X *									*
X *	Copyright (c) 1990-1992, S.R. van den Berg, The Netherlands	*
X *	The sources can be freely copied for non-commercial use.	*
X *	#include "README"						*
X *									*
X ************************************************************************/
X#ifdef RCS
Xstatic char rcsid[]="$Id: common.c,v 2.11 1992/03/19 14:00:28 berg Rel $";
X#endif
X#include "includes.h"
X
Xvoid*tmalloc();
Xextern const char binsh[];
X
X#ifdef NOmemmove
Xvoid*smemmove(To,From,count)void*To,*From;register size_t count;
X#ifdef NObcopy
X{ register char*to=To,*from=From;/*void*old;*/	  /* silly compromise, throw */
X  /*old=to;*/count++;--to;--from;  /* away space to be syntactically correct */
X  if(to<=from)
X   { goto jiasc;
X     do
X      { *++to= *++from;					  /* copy from above */
Xjiasc:;
X      }
X     while(--count);
X   }
X  else
X   { to+=count;from+=count;goto jidesc;
X     do
X      { *--to= *--from;					  /* copy from below */
Xjidesc:;
X      }
X     while(--count);
X   }
X  return To/*old*/;
X#else
X{ bcopy(From,To,count);return To;
X#endif /* NObcopy */
X}
X#endif /* NOmemmove */
X
X#include "shell.h"
X
Xshexec(argv)char*const*argv;
X{ int i;char**newargv;const char**p;
X#ifdef SIGXCPU
X  signal(SIGXCPU,SIG_DFL);signal(SIGXFSZ,SIG_DFL);
X#endif
X  signal(SIGPIPE,SIG_DFL);execvp(*argv,argv);	/* or is it a shell script ? */
X  for(p=(const char**)argv,i=1;i++,*p++;);	      /* count the arguments */
X  newargv=malloc(i*sizeof*p);
X  for(*(p=(const char**)newargv)=binsh;*++p= *argv++;);
X  execve(*newargv,newargv,environ);	      /* no shell script? -> trouble */
X  log("Failed to execute");logqnl(*argv);exit(EX_UNAVAILABLE);
X}
X
Xchar*pstrspn(whole,sub)const char*whole,*const sub;
X{ while(*whole&&strchr(sub,*whole))
X     whole++;
X  return(char*)whole;
X}
X
X#ifdef NOstrcspn
Xstrcspn(whole,sub)const char*const whole,*const sub;
X{ const register char*p;
X  p=whole;
X  while(*p&&!strchr(sub,*p))
X     p++;
X  return p-whole;
X}
X#endif
END_OF_FILE
if test 2031 -ne `wc -c <'procmail/common.c'`; then
    echo shar: \"'procmail/common.c'\" unpacked with wrong size!
fi
# end of 'procmail/common.c'
fi
if test ! -d 'procmail/examples' ; then
    echo shar: Creating directory \"'procmail/examples'\"
    mkdir 'procmail/examples'
fi
if test -f 'procmail/examples/1procmailrc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/examples/1procmailrc'\"
else
echo shar: Extracting \"'procmail/examples/1procmailrc'\" \(634 characters\)
sed "s/^X//" >'procmail/examples/1procmailrc' <<'END_OF_FILE'
X# Please check if all the paths in PATH are reachable, remove the ones that
X# are not.
X
XPATH=$HOME/bin:/usr/bin:/usr/ucb:/bin:/usr/local/bin:
XMAILDIR=$HOME/Mail	# You'd better make sure it exists
XDEFAULT=$MAILDIR/mbox
XLOGFILE=$MAILDIR/from
XLOCKFILE=$HOME/.lockmail
X
X:				# Anything from thf
X^From.*thf@somewhere.someplace
Xtodd				# will go to $MAILDIR/todd
X
X:				# Anything from people at uunet
X^From.*@uunet
Xuunetbox			# will go to $MAILDIR/uunetbox
X
X:				# Anything from Henry
X^From.*henry
Xhenries				# will go to $MAILDIR/henries
X
X# Anything that has not been delivered by now will go to $DEFAULT
X# using LOCKFILE=$DEFAULT$LOCKEXT
END_OF_FILE
if test 634 -ne `wc -c <'procmail/examples/1procmailrc'`; then
    echo shar: \"'procmail/examples/1procmailrc'\" unpacked with wrong size!
fi
# end of 'procmail/examples/1procmailrc'
fi
if test -f 'procmail/examples/2procmailrc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/examples/2procmailrc'\"
else
echo shar: Extracting \"'procmail/examples/2procmailrc'\" \(1970 characters\)
sed "s/^X//" >'procmail/examples/2procmailrc' <<'END_OF_FILE'
X# Please check if all the paths in PATH are reachable, remove the ones that
X# are not.
X
XPATH=$HOME/bin:/usr/bin:/usr/ucb:/bin:/usr/local/bin:
XMAILDIR=$HOME/Mail	# You'd better make sure it exists
XDEFAULT=$MAILDIR/mbox
X			# We don't use a global lockfile here now.
X			# Instead we use local lockfiles everywhere.
X			# This allows mail to arrive in all mailboxes
X			# concurrently, or allows you to read one mailbox
X			# while mail arrives in another.
X
X# The next recipe will split up Digests into their individual messages.
X# Don't do this if you use a global lockfile before this recipe (deadlock)
X
X:
X^Subject:.*Digest
X|formail +1 -d -s procmail
X
XLOGFILE=$MAILDIR/from		# Put it here, in order to avoid logging
X				# the arrival of the digest.
X
X# An alternative and probably more efficient solution to splitting up a digest
X# would be (only works for standard format mailbox files though):
X
X::
X^Subject:.*Other Digest
X|formail +1 -ds cat >>this_lists_mailbox
X
X# Notice the double : in the next recipe, this will cause a lockfile
X# named "$MAILDIR/todd.lock" to be used if and only if this mail is going
X# into the file "todd".
X
X::				# Anything from thf
X^From.*thf@somewhere.someplace
Xtodd				# will go to $MAILDIR/todd
X
X
X# The next recipe will likewise use $MAILDIR/uunetbox.lock as a lock file.
X
X::				# Anything from people at uunet
X^From.*@uunet
Xuunetbox			# will go to $MAILDIR/uunetbox
X
X
X# And here the lockfile will be $MAILDIR/henries.lock of course.
X
X::				# Anything from Henry
X^From.*henry
Xhenries				# will go to $MAILDIR/henries
X
X
X# But you can specify any lockfile you want, like "myfile".  The following
X# recipe will use "$MAILDIR/myfile" as the lock file.
X
X::myfile			# All 'questions' will go to
X^Subject:.*questions
Xtoread				# $MAILDIR/toread
X
X# Anything that has not been delivered by now will go to $DEFAULT
X
X# After procmail sees the end of the rcfile, it pretends that it sees a
X# LOCKFILE=$DEFAULT$LOCKEXT
X# Therefore $DEFAULT is always locked.
END_OF_FILE
if test 1970 -ne `wc -c <'procmail/examples/2procmailrc'`; then
    echo shar: \"'procmail/examples/2procmailrc'\" unpacked with wrong size!
fi
# end of 'procmail/examples/2procmailrc'
fi
if test -f 'procmail/examples/2rmail' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/examples/2rmail'\"
else
echo shar: Extracting \"'procmail/examples/2rmail'\" \(392 characters\)
sed "s/^X//" >'procmail/examples/2rmail' <<'END_OF_FILE'
X#!/bin/sh
X#
X# specify the mailbox file you want to read on the command line
X#
XMAILDIR=$HOME/Mail
Xcd $MAILDIR
XLOCKFILE=$1.lock
Xif lockfile -! -r1 $LOCKFILE
Xthen
X echo Mail is currently arriving, please wait...
X while
X   lockfile -! -4 -r2 $LOCKFILE
X do
X echo Mail is still arriving...
X done
Xfi
Xtrap "rm -f $LOCKFILE;exit 0" 0 1 2 3 15
X#
X# Call you favourite mailer here.
X#
X/usr/ucb/mail -f $*
END_OF_FILE
if test 392 -ne `wc -c <'procmail/examples/2rmail'`; then
    echo shar: \"'procmail/examples/2rmail'\" unpacked with wrong size!
fi
# end of 'procmail/examples/2rmail'
fi
if test -f 'procmail/examples/3rmail' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/examples/3rmail'\"
else
echo shar: Extracting \"'procmail/examples/3rmail'\" \(757 characters\)
sed "s/^X//" >'procmail/examples/3rmail' <<'END_OF_FILE'
X#!/bin/sh
X#
X# specify the mailbox file you want to read on the command line
X# Use a relative path from your $HOME directory
X#
X# For this kind of chaotic procmailrc there is no uniform neat solution
X# to determine which lockfiles to use.	I'll give just one (suboptimal)
X# solution here.  Use your imagination to extend it :-).
X#
XMAILDIR=$HOME/Mail
Xcd $HOME			# this means all paths are relative to $HOME
XLOCKFILE=$HOME/.lockmail
XLOCKFILE2=$HOME/Mail/whatever
Xif lockfile -! -r1 $LOCKFILE $LOCKFILE2
Xthen
X echo Mail is currently arriving, please wait...
X while
X   lockfile -! -4 -r2 $LOCKFILE $LOCKFILE2
X do
X echo Mail is still arriving...
X done
Xfi
Xtrap "rm -f $LOCKFILE $LOCKFILE2;exit 0" 0 1 2 3 15
X#
X# Call you favourite mailer here.
X#
X/usr/ucb/mail -f $*
END_OF_FILE
if test 757 -ne `wc -c <'procmail/examples/3rmail'`; then
    echo shar: \"'procmail/examples/3rmail'\" unpacked with wrong size!
fi
# end of 'procmail/examples/3rmail'
fi
if test -f 'procmail/examples/forward' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/examples/forward'\"
else
echo shar: Extracting \"'procmail/examples/forward'\" \(57 characters\)
sed "s/^X//" >'procmail/examples/forward' <<'END_OF_FILE'
X"|IFS=' ';exec /usr/local/bin/procmail #YOUR_LOGIN_NAME"
END_OF_FILE
if test 57 -ne `wc -c <'procmail/examples/forward'`; then
    echo shar: \"'procmail/examples/forward'\" unpacked with wrong size!
fi
# end of 'procmail/examples/forward'
fi
if test -f 'procmail/examples/listrc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/examples/listrc'\"
else
echo shar: Extracting \"'procmail/examples/listrc'\" \(2076 characters\)
sed "s/^X//" >'procmail/examples/listrc' <<'END_OF_FILE'
XPATH=/bin:/usr/bin:/usr/local/bin	# add more if appropriate
XSHELL=/bin/sh
X
X# list		should contain the submitting address of the list
X#		since this adress is used to create the X-Loop: field, and
X#		is also grepped for, make sure that it does not contain
X#		any egrep-magic characters (or change the definition and
X#		detection of the X-Loop: field).
X# listreq	should contain the request address of the list
X# subscribers	should name the file which contains the list of subscribers
X#		separated by whitespace
X
X:3wfh
X!^Subject:.*((add|remove).*list|subscribe)
X!^From +(postmaster|Mailer)
X$!^X-Loop: $list
X| formail -b -IReturn-Receipt-To: -I"Errors-To: $listreq" \
X  -I "Sender: $listreq" -I"Precedence: bulk" -IReceived: -I"X-Loop: $list"\
X# -i "Reply-To: $list"			# uncomment if you want, many people
X					# consider this a bad idea.
X
X# If memberlist is longer than 2048 bytes, you will have to insert a
X# LINEBUF=some_big_number here because procmail uses a buffer of size
X# $LINEBUF to expand the inline 'cat'
X
X:Aw
X! -f$listreq `cat $subscribers`		# the -f and -oi are sendmail options
X					# omit if not applicable
X	# the -f flag will only take effect if the sender is not local
X
X# Alternatively you could have put the burden on the shell for expanding the
X# 'cat' by providing the following action line instead:
X# | $SENDMAIL -oi `cat $subscribers`;	# the ; forces the procmail to pass
X					# on the line to the shell unparsed
X
X# Anything not delivered yet (either because it was from the postmaster
X# or mailer-daemon, or because it might be a request-message) will be forwarded
X# to the list maintainer:
X:0w
X! -oi $listreq
X
X# In case not even this works, the mail will be appended to the
X# following last-resort files
X
XUMASK=666	# this is probably inevitable since procmail (in this case)
X		# could be running under the local-sender's uid or the
X		# daemon or mailer-uid (in the remote-sender's case)
X
XDEFAULT=/usr/tmp/${listreq}s		# first-choice
XORGMAIL=/tmp/${listreq}s		# a last-last-resort-file in case the
X			# filesystem for /usr/tmp/mylist-request should be full
END_OF_FILE
if test 2076 -ne `wc -c <'procmail/examples/listrc'`; then
    echo shar: \"'procmail/examples/listrc'\" unpacked with wrong size!
fi
# end of 'procmail/examples/listrc'
fi
if test -f 'procmail/examples/mailstat' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/examples/mailstat'\"
else
echo shar: Extracting \"'procmail/examples/mailstat'\" \(4809 characters\)
sed "s/^X//" >'procmail/examples/mailstat' <<'END_OF_FILE'
X#!/bin/sh
X#################################################################
X#	mailstat	shows mail-arrival statistics		#
X#								#
X#	Parses a procmail-generated $LOGFILE and displays	#
X#	a summary about the messages delivered to all folders	#
X#	(total size, average size, nr of messages).		#
X#	Exit code 0 if mail arrived, 1 if no mail arrived.	#
X#								#
X#	For help try, "mailstat -h"				#
X#								#
X#	Customise to your heart's content, this file is only	#
X#	provided as a guideline.				#
X#								#
X#	Created by S.R. van den Berg, The Netherlands		#
X#	This file can be freely copied for any use.		#
X#								#
X#################################################################
X#$Id: mailstat,v 2.2 1992/06/03 12:54:42 berg Rel $
X
X#	This shell script expects the following programs to be in the
X#	PATH (paths given here are the standard locations, your mileage
X#	may vary (if the programs can not be found, extend the PATH or
X#	put their absolute pathnames in here):
X
Xtest=test		# /bin/test	(or built-in in /bin/sh)
Xexpr=expr		# /bin/expr
Xtty=tty			# /bin/tty
Xsed=sed			# /bin/sed
Xsort=sort		# /bin/sort
Xawk=awk			# /bin/awk
X
XPATH=/bin:/usr/bin
XSHELL=/bin/sh		# just in case
Xexport SHELL PATH
X
Xumask 077		# we don't allow everyone to read the tmpfiles
XOLDSUFFIX=.old
X
XDEVNULL=/dev/null
XEX_USAGE=64
X
X########
X#	(Concatenated) flags parsing in pure, portable, structured (it
X#	would have been more elegant if gotos were permitted) shellscript
X#	language.  For added pleasure: a quick demonstration of the shell's
X#	quoting capabilities :-).
X########
X
Xwhile $test $# != 0 -a \( 0 != `$expr match a"$1" a-.` -o $# != 1 \)
Xdo
X  if $expr match "$1" -. >$DEVNULL	# structured programming spaghetti
X  then
X     flags="$1"; shift
X  else
X     flags=-h				# force help page
X  fi
X  while flags="`$expr match "$flags" '.\\(.*\\)'`"; $test ."$flags" != .
X  do
X     case "$flags" in
X	 k*) MSkeeplogfile=1;;
X	 l*) MSlong=1;;
X	 m*) MSmergerror=1;;
X	 o*) MSoldlog=1; MSkeeplogfile=1;;
X	 t*) MSterse=1;;
X	 s*) MSsilent=1;;
X	 h*|\?*) echo 'Usage: mailstat [-klmots] [logfile]' 1>&2
X	    echo '	-k	keep logfile intact' 1>&2
X	    echo '	-l	long display format' 1>&2
X	    echo '	-m	merge any errors into one line' 1>&2
X	    echo '	-o	use the old logfile' 1>&2
X	    echo '	-t	terse display format' 1>&2
X	    echo '	-s	silent in case of no mail' 1>&2
X	    exit $EX_USAGE;;
X	 *) echo 'Usage: mailstat [-klmots] [logfile]' 1>&2; exit $EX_USAGE;;
X     esac
X  done
Xdone
X
XLOGFILE="$1"
X
Xcase "$LOGFILE" in
X  *"$OLDSUFFIX") MSkeeplogfile=1; OLDLOGFILE="$LOGFILE";;
X  *) OLDLOGFILE="$LOGFILE$OLDSUFFIX";;
Xesac
X
Xif test .$MSoldlog = .1
Xthen
X  LOGFILE="$OLDLOGFILE"
Xfi
X
Xif $test ."$LOGFILE" != .- -a ."$LOGFILE" != .
Xthen
X  if $test ! -s "$LOGFILE"
X  then
X     if $test .$MSsilent = .
X     then
X	if $test -f "$LOGFILE"
X	then
X	   echo No mail arrived since `$expr match "\`ls -l \"$OLDLOGFILE\"\`"\
X	    '.*[0-9] \\([A-Z][a-z][a-z] .. .....\\) [^ ]'`
X	else
X	   echo "Can't find your LOGFILE=$LOGFILE"
X	fi
X     fi
X     exit 1
X  fi
Xelse
X  if $test ."$LOGFILE" != .- && $tty -s
X  then
X     echo \
X      "Most people don't type their own logfiles;  but, what do I care?" 1>&2
X     MSterse=1
X  fi
X  MSkeeplogfile=1; LOGFILE=
Xfi
X
Xif $test .$MSkeeplogfile = .
Xthen mv "$LOGFILE" "$OLDLOGFILE"; touch "$LOGFILE"
Xelse OLDLOGFILE="$LOGFILE"
Xfi
X
Xif $test .$MSterse = .
Xthen
X  if $test .$MSlong = .1
X  then
X     echo ""
X     echo "  Total Average  Number Folder"
X     echo "  ----- -------  ------ ------"
X  else
X     echo ""
X     echo "  Total  Number Folder"
X     echo "  -----  ------ ------"
X  fi
Xfi
X
Xif $test .$MSlong = .1
Xthen MSlong='"%7d %7d %7d %s\n",total,total/messages,messages,folder'
Xelse MSlong='"%7d %7d %s\n",total,messages,folder'
Xfi
X
XTMPF=/tmp/maillog.$$
X
Xtrap "rm -f $TMPF; exit 2" 1 2 3 15
Xtrap "rm -f $TMPF; exit 0" 0
X
X########
X#	And now we descend into the wonderful mix if shell-quoting and
X#	portable awk-programming :-)
X########
X
Xcat >$TMPF <<HERE
XBEGIN {
X   FS="\\t";
X  }
X  { if(folder!=\$1)
X     { if(folder!="")
X	{ printf $MSlong;
X	}
X       messages=0;total=0;folder=\$1;
X     }
X    ++messages;total+=\$2;
X  }
XEND {
X    if(folder!="")
X     { printf $MSlong;
X     }
X  }
XHERE
X
X########
X#	Only to end in a grand finale with your average sed script
X########
X
Xif $test .$MSmergerror = .
Xthen
X  $sed	-e '/^From /d' -e '/^ [Ss][uU][bB][jJ][eE][cC][tT]:/d' \
X   -e '/^  Folder/s/		*/	/' -e 's/^  Folder: \(.*\)/\1/' \
X   -e t -e 's/	/\\t/g' -e 's/^/ ## /' $OLDLOGFILE | $sort | $awk -f $TMPF -
Xelse
X  $sed	-e '/^From /d' -e '/^ [Ss][uU][bB][jJ][eE][cC][tT]:/d' \
X   -e '/^  Folder/s/		*/	/' -e 's/^  Folder: \(.*\)/\1/' \
X   -e t -e 's/.*/ ## diagnostic messages ##/' $OLDLOGFILE | \
X   $sort | $awk -f $TMPF -
Xfi
X
X########
X#	Nifty little script, isn't it?
X#	Now why didn't *you* come up with this truly trivial script? :-)
X########
END_OF_FILE
if test 4809 -ne `wc -c <'procmail/examples/mailstat'`; then
    echo shar: \"'procmail/examples/mailstat'\" unpacked with wrong size!
fi
chmod +x 'procmail/examples/mailstat'
# end of 'procmail/examples/mailstat'
fi
if test -f 'procmail/exopen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/exopen.c'\"
else
echo shar: Extracting \"'procmail/exopen.c'\" \(2227 characters\)
sed "s/^X//" >'procmail/exopen.c' <<'END_OF_FILE'
X/************************************************************************
X *	Collection of NFS secure exclusive open routines		*
X *									*
X *	Copyright (c) 1990-1992, S.R. van den Berg, The Netherlands	*
X *	The sources can be freely copied for non-commercial use.	*
X *	#include "README"						*
X *									*
X ************************************************************************/
X#ifdef RCS
Xstatic char rcsid[]="$Id: exopen.c,v 2.11 1992/04/21 15:27:50 berg Rel $";
X#endif
X#include "config.h"
X#include "includes.h"
X#include "exopen.h"
X#include "strpbrk.h"
X
Xconst char*hostname();
Xextern pid_t thepid;
Xextern const char dirsep[];
X
Xconst char*hostname()
X{ static char name[HOSTNAMElen+1];
X#ifdef	NOuname
X  gethostname(name,HOSTNAMElen+1);
X#else
X  struct utsname names;
X  uname_(&names);strncpy(name,names.nodename,HOSTNAMElen);
X#endif
X  name[HOSTNAMElen]='\0';return name;
X}
X
Xultoan(val,dest)unsigned long val;char*dest;	      /* convert to a number */
X{ register i;				     /* within the set [0-9A-Za-z-_] */
X  do
X   { i=val&0x3f;
X     *dest++=i+(i<10?'0':i<10+26?'A'-10:i<10+26+26?'a'-10-26:
X      i==10+26+26?'-'-10-26-26:'_'-10-26-27);
X   }
X  while(val>>=6);
X  *dest='\0';
X}
X
Xunique(full,p,mode)const char*const full;char*const p;const mode_t mode;
X{ unsigned long retry=mrotbSERIAL;int i;	  /* create unique file name */
X  do
X   { ultoan(maskSERIAL&(retry<<bitsSERIAL-mrotbSERIAL)+
X      (unsigned long)thepid,p+1);
X     *p=UNIQ_PREFIX;strcat(p,hostname());
X   }
X#ifndef O_CREAT
X#define ropen(path,type,mode)	creat(path,mode)
X#endif
X  while(0>(i=ropen(full,O_WRONLY|O_CREAT|O_EXCL|O_SYNC,mode))&&errno==EEXIST&&
X   retry--);	    /* casually check if it already exists (highly unlikely) */
X  if(i<0)
X   { writeerr(full);return 0;
X   }
X  rclose(i);return 1;
X}
X				     /* rename MUST fail if already existent */
Xmyrename(old,newn)const char*const old,*const newn;
X{ int i,serrno;struct stat stbuf;
X  link(old,newn);serrno=errno;i=stat(old,&stbuf);unlink(old);errno=serrno;
X  return stbuf.st_nlink==2?i:-1;
X}
X
Xchar*lastdirsep(filename)const char*filename;	 /* finds the next character */
X{ const char*p;					/* following the last DIRSEP */
X  while(p=strpbrk(filename,dirsep))
X     filename=p+1;
X  return(char*)filename;
X}
END_OF_FILE
if test 2227 -ne `wc -c <'procmail/exopen.c'`; then
    echo shar: \"'procmail/exopen.c'\" unpacked with wrong size!
fi
# end of 'procmail/exopen.c'
fi
if test -f 'procmail/exopen.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/exopen.h'\"
else
echo shar: Extracting \"'procmail/exopen.h'\" \(284 characters\)
sed "s/^X//" >'procmail/exopen.h' <<'END_OF_FILE'
X/*$Id: exopen.h,v 2.4 1992/04/21 15:27:50 berg Rel $*/
X#define charsSERIAL	4
X#define UNIQnamelen	(1+charsSERIAL+HOSTNAMElen+1)
X#define bitsSERIAL	(6*charsSERIAL)
X#define maskSERIAL	((1L<<bitsSERIAL)-1)
X#define rotbSERIAL	2
X#define mrotbSERIAL	((1L<<rotbSERIAL)-1)
X
Xchar*lastdirsep();
END_OF_FILE
if test 284 -ne `wc -c <'procmail/exopen.h'`; then
    echo shar: \"'procmail/exopen.h'\" unpacked with wrong size!
fi
# end of 'procmail/exopen.h'
fi
if test -f 'procmail/lockfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/lockfile.c'\"
else
echo shar: Extracting \"'procmail/lockfile.c'\" \(4283 characters\)
sed "s/^X//" >'procmail/lockfile.c' <<'END_OF_FILE'
X/************************************************************************
X *	lockfile.c	a conditional semaphore-file creator		*
X *									*
X *	It has been designed to be able to be run suid/sgid root or	*
X *	any id you see fit (in case your mail spool area is *not*	*
X *	world writeable), without creating security holes.		*
X *									*
X *	Seems to be perfect.						*
X *									*
X *	Created by S.R. van den Berg, The Netherlands			*
X *	This file can be freely copied for any use.			*
X *									*
X ************************************************************************/
X#ifdef RCS
Xstatic char rcsid[]="$Id: lockfile.c,v 2.15 1992/06/30 16:42:26 berg Rel $";
X#endif
Xstatic char rcsdate[]="$Date: 1992/06/30 16:42:26 $";
X#include "config.h"
X#include "includes.h"
X#include "exopen.h"
X#include "strpbrk.h"
X
X#ifndef SYSTEM_MBOX
X#define SYSTEM_MBOX	SYSTEM_MAILBOX
X#endif
X
Xvolatile int exitflag;
Xpid_t thepid;
Xchar systm_mbox[]=SYSTEM_MBOX;
Xconst char dirsep[]=DIRSEP,lockext[]=DEFlockext,nameprefix[]="lockfile: ";
X
Xvoid failure()
X{ exitflag=1;
X}
X
Xmain(argc,argv)const char*const argv[];
X{ const char*const*p,*cp;uid_t uid;
X  int sleepsec,retries,invert,force,suspend,retval=0,virgin=0;
X  static const char usage[]=
X  "Usage: lockfile -nnn | -rnnn | -! | -lnnn | -snnn | -ml | -mu | file ...\n";
X  sleepsec=8;force=retries=invert=0;suspend=16;thepid=getpid();uid=getuid();
X  *lastdirsep(systm_mbox)='\0';
X  if(--argc<=0)
X   { putse(usage);return EX_USAGE;
X   }
Xagain:
X  p=argv;signal(SIGHUP,(void(*)())failure);signal(SIGINT,(void(*)())failure);
X  signal(SIGQUIT,(void(*)())failure);signal(SIGTERM,(void(*)())failure);
X  while(argc--)
X     if(*(cp= *++p)=='-')
X	switch(cp[1])
X	 { case '!':invert=1;break;
X	   case 'r':retries=strtol(cp+2,(char**)0,10);break;
X	   case 'l':force=strtol(cp+2,(char**)0,10);break;
X	   case 's':suspend=strtol(cp+2,(char**)0,10);break;
X	   case 'm':
X	    { struct passwd*pass;char*ma;
X	      if(virgin||!(pass=getpwuid(uid))||
X	       !(ma=malloc(strlen(systm_mbox)+strlen(pass->pw_name)+
X	       STRLEN(lockext)+1)))
X		 goto eusg;
X	      strcpy(ma,systm_mbox);strcat(ma,pass->pw_name);
X	      strcat(ma,lockext);
X	      if(cp[2]=='u')
X	       { unlink(ma);break;
X	       }
X	      if(cp[2]=='l')
X	       { cp=ma;goto stilv;
X	       }
X	      goto eusg;
X	    }
X	   case HELPOPT1:case HELPOPT2:putse(usage);
X	      putse(
X "\t-nnn\twait nnn seconds (default 8) between locking attempts\
X\n\t-rnnn\tmake nnn retries before giving up on a lock\
X\n\t-!\tinvert the exit code of lockfile\
X\n\t-lnnn\tset locktimeout to nnn seconds\
X\n\t-snnn\tsuspend nnn seconds (default 16) after a locktimeout occurred\
X\n\t-ml\tlock your system mail-spool file\
X\n\t-mu\tunlock your system mail-spool file\n");goto xusg;
X	   default:
X	      if(cp[1]-'0'>(unsigned)9)
Xeusg:	       { putse(usage);
Xxusg:		 retval=EX_USAGE;goto lfailure;
X	       }
X	      if(sleepsec>=0)
X		 sleepsec=strtol(cp+1,(char**)0,10);
X	 }
X     else if(sleepsec<0)
X	unlink(cp);
X     else
X      { time_t t;
X	setgid(getgid());setuid(uid);
Xstilv:	virgin=1;
X	while(0>NFSxopen(cp,&t))
X	 { struct stat buf;
X	   if(exitflag||retries==1)
X	    { putse(nameprefix);putse("Sorry, giving up\n");
Xlfailure:     sleepsec= -1;argc=p-argv-1;goto again;
X	    }
X	   if(force&&!stat(cp,&buf)&&force<t-buf.st_mtime)
X	    { unlink(cp);putse(nameprefix);putse("Forcing lock on \"");
X	      putse(cp);putse("\"\n");sleep(suspend);
X	    }
X	   else
X	      sleep(sleepsec);
X	   if(retries)
X	      retries--;
X	 }
X      }
X  return retval?retval:invert^(sleepsec<0)?EX_CANTCREAT:EX_OK;
X}
X
Xputse(a)char*a;
X{ char*b;
X  b=a-1;
X  while(*++b);
X  write(STDERR,a,(size_t)(b-a));
X}
X
XNFSxopen(name,tim)char*name;time_t*const tim;
X{ char*p,*q;int j= -1,i;struct stat stbuf;
X  for(q=name;p=strpbrk(q,dirsep);q=p+1);
X  i=q-name;
X  if(!(p=malloc(i+UNIQnamelen)))
X     return exitflag=1;
X  strncpy(p,name,i);
X  if(unique(p,p+i,0))
X     stat(p,&stbuf),*tim=stbuf.st_mtime,j=myrename(p,name);
X  free(p);return j;
X}
X
Xvoid*tmalloc(len)const size_t len;				     /* stub */
X{ return malloc(len);
X}
X
Xropen(name,mode,mask)const char*const name;const int mode;const mode_t mask;
X{ return open(name,mode,mask);					     /* stub */
X}
X
Xrclose(fd)const int fd;						     /* stub */
X{ return close(fd);
X}
X
Xwriteerr(a)const char*const a;					     /* stub */
X{
X}
END_OF_FILE
if test 4283 -ne `wc -c <'procmail/lockfile.c'`; then
    echo shar: \"'procmail/lockfile.c'\" unpacked with wrong size!
fi
# end of 'procmail/lockfile.c'
fi
if test ! -d 'procmail/man' ; then
    echo shar: Creating directory \"'procmail/man'\"
    mkdir 'procmail/man'
fi
if test -f 'procmail/man/mansed' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/man/mansed'\"
else
echo shar: Extracting \"'procmail/man/mansed'\" \(283 characters\)
sed "s/^X//" >'procmail/man/mansed' <<'END_OF_FILE'
X
X#$Id: mansed,v 2.2 1992/03/06 12:40:16 berg Rel $
X
XSHELL=$3 || exec $3 man/mansed $* # we're in a csh, feed myself to sh
Xexport SHELL
XRM="$4"
X
Xif test ! -f "$2"
Xthen
X trap "$RM \"$2\";exit 1" 1 2 3 15
Xfi
X
Xsed -f man/man.sed <"$1" >"$2"
X
Xif test -f "$2"
Xthen
X exit 0
Xelse
X exit 1
Xfi
END_OF_FILE
if test 283 -ne `wc -c <'procmail/man/mansed'`; then
    echo shar: \"'procmail/man/mansed'\" unpacked with wrong size!
fi
# end of 'procmail/man/mansed'
fi
if test -f 'procmail/patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/patchlevel.h'\"
else
echo shar: Extracting \"'procmail/patchlevel.h'\" \(168 characters\)
sed "s/^X//" >'procmail/patchlevel.h' <<'END_OF_FILE'
X#define VERSION \
X"procmail v2.71 1992/07/01 written by Stephen R. van den Berg\n\
X\t\t\t\tberg@pool.informatik.rwth-aachen.de\n\
X\t\t\t\tberg@physik.tu-muenchen.de\n"
END_OF_FILE
if test 168 -ne `wc -c <'procmail/patchlevel.h'`; then
    echo shar: \"'procmail/patchlevel.h'\" unpacked with wrong size!
fi
# end of 'procmail/patchlevel.h'
fi
if test -f 'procmail/procmail.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/procmail.h'\"
else
echo shar: Extracting \"'procmail/procmail.h'\" \(3161 characters\)
sed "s/^X//" >'procmail/procmail.h' <<'END_OF_FILE'
X/*$Id: procmail.h,v 2.20 1992/06/03 12:55:50 berg Rel $*/
X
X#include "includes.h"
X#include "exopen.h"
X#include "strpbrk.h"
X
Xtypedef unsigned char uschar;	     /* sometimes uchar is already typedef'd */
X#ifdef uchar
X#undef uchar
X#endif
X#define uchar uschar
X
X#ifdef console
X#define vconsole (verbose=1,console)
X#else
X#define vconsole devnull
X#endif
X
X#ifndef DEFsendmail
X#define DEFsendmail SENDMAIL
X#endif
X
X#ifndef SYSTEM_MBOX
X#define SYSTEM_MBOX	SYSTEM_MAILBOX
X#endif
X
X#ifdef sMAILBOX_SEPARATOR
X#define smboxseparator(fd)	\
X (tofolder?rwrite(fd,sMAILBOX_SEPARATOR,STRLEN(sMAILBOX_SEPARATOR)):0)
X#define MAILBOX_SEPARATOR
X#else
X#define smboxseparator(fd)
X#endif /* sMAILBOX_SEPARATOR */
X#ifdef eMAILBOX_SEPARATOR
X#define emboxseparator(fd)	\
X (tofolder?rwrite(fd,eMAILBOX_SEPARATOR,STRLEN(eMAILBOX_SEPARATOR)):0)
X#ifndef MAILBOX_SEPARATOR
X#define MAILBOX_SEPARATOR
X#endif
X#else
X#define emboxseparator(fd)
X#endif /* eMAILBOX_SEPARATOR */
X
X#ifndef KERNEL_LOCKS
X#define fdlock(fd)	0
X#define fdunlock()	0
X#else
X#ifndef SYS_FILE_H_MISSING
X#include <sys/file.h>
X#endif
X#endif
X
X#define XTRAlinebuf	2	     /* surplus of LINEBUF (see readparse()) */
X#define TMNATE		'\377'		     /* terminator (see readoarse()) */
X
X#define PRDO	poutfd[0]
X#define PWRO	poutfd[1]
X#define PRDI	pinfd[0]
X#define PWRI	pinfd[1]
X#define PRDB	pbackfd[0]
X#define PWRB	pbackfd[1]
X#define LENoffset	(TABWIDTH*LENtSTOP)
X#define MAXfoldlen	(LENoffset-STRLEN(sfolder)-1)
X#define MCDIRSEP	(dirsep+STRLEN(dirsep)-1)      /* most common DIRSEP */
X
X#define lck_LOCKFILE	1	  /* crosscheck the order of this with msg[] */
X#define lck_ALLOCLIB	2		      /* in sterminate() in retint.c */
X#define lck_MEMORY	4
X#define lck_FORK	8
X#define lck_FILDES	16
X#define lck_KERNELL	32
X
Xstruct varval{const char*const name;long val;};
X#define locksleep	(strenvvar[0].val)
X#define locktimeout	(strenvvar[1].val)
X#define suspendv	(strenvvar[2].val)
X#define noresretry	(strenvvar[3].val)
X#define timeoutv	(strenvvar[4].val)
X#define MAXvarvals	maxindex(strenvvar)
X
X#ifndef MAIN
Xextern char*buf,*buf2,*globlock,*loclock,*tolock,*lastfolder;
Xextern const char shellflags[],shell[],lockext[],newline[],binsh[],
X unexpeof[],shellmetas[],*const*gargv,*sgetcp,*rcfile,dirsep[],msgprefix[],
X devnull[],executing[],oquote[],cquote[],whilstwfor[],procmailn[],Mail[];
Xextern struct varval strenvvar[];
Xextern long lastdump;
Xextern sh,pwait,retval,retvl2,lcking,locknext,verbose,linebuf,rc,tofolder,
X tofile,ignwerr,fakedelivery;
Xextern volatile nextexit;
Xextern volatile time_t alrmtime;
Xextern pid_t thepid,pidchild;
X#endif
X
X#ifdef NOmemmove
Xvoid*smemmove();
X#endif
X#ifdef strtol
X#undef strtol
X#define NOstrtol
Xlong strtol();
X#endif
X
Xvoid*tmalloc(),*trealloc(),*bregcomp(),srequeue(),slose(),sbounce(),
X stermchild(),ftimeout();
Xpid_t sfork();
Xlong dump(),pipin(),renvint();
Xchar*readdyn(),*fromprog(),*cat(),*tstrdup(),*cstr(),*pstrspn(),
X *bregexec(),*egrepin();
Xconst char*tgetenv(),*hostname();
Xint sgetc(),getb();
X
X/*
X *	External variables that are checked/changed by the signal handlers:
X *	volatile time_t alrmtime;
X *	pid_t pidfilt,pidchild;
X *	volatile int nextexit;
X *	int lcking;
X *	static volatile mailread;	in procmail.c
X */
END_OF_FILE
if test 3161 -ne `wc -c <'procmail/procmail.h'`; then
    echo shar: \"'procmail/procmail.h'\" unpacked with wrong size!
fi
# end of 'procmail/procmail.h'
fi
if test -f 'procmail/recommend.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/recommend.c'\"
else
echo shar: Extracting \"'procmail/recommend.c'\" \(2223 characters\)
sed "s/^X//" >'procmail/recommend.c' <<'END_OF_FILE'
X/************************************************************************
X *	recommend.c	analyses the installation, and makes		*
X *			recommendations about suid/sgid modes		*
X ************************************************************************/
X/*$Id: recommend.c,v 2.4 1992/06/30 16:42:26 berg Rel $*/
X#include "config.h"
X#include "includes.h"				       /* also for fprintf() */
X#include "strpbrk.h"
X
X#ifndef SYSTEM_MBOX
X#define SYSTEM_MBOX	SYSTEM_MAILBOX
X#endif
X
X#define PERMIS	(S_IRWXU|S_IRWXG&~S_IWGRP|S_IRWXO&~S_IWOTH)
X
Xchar systm_mbox[]=SYSTEM_MBOX;
Xconst char dirsep[]=DIRSEP,
X *const checkf[]={"/bin/mail","/bin/lmail","/usr/lib/sendmail",
X "/usr/lib/smail",0};
X			     /* lastdirsep() has been lifted out of exopen.c */
Xchar*lastdirsep(filename)const char*filename;	 /* finds the next character */
X{ const char*p;					/* following the last DIRSEP */
X  while(p=strpbrk(filename,dirsep))
X     filename=p+1;
X  return(char*)filename;
X}
X
Xmain(argc,argv)const int argc;const char*const argv[];
X{ struct passwd*pass;struct group*grp;struct stat stbuf;
X  uid_t uid=ROOT_uid;gid_t gid=NOBODY_gid;const char*const*p;
X  mode_t suid=0,sgid=0;
X  if(argc!=3)
X   { fprintf(stderr,"Please run this program via 'make recommend'\n");
X     return EX_USAGE;
X   }
X  *lastdirsep(systm_mbox)='\0';
X  for(p=checkf;*p;++p)
X     if(!stat(*p,&stbuf)&&stbuf.st_mode&(S_ISUID|S_ISGID))
X      { if(stbuf.st_mode&S_ISUID&&stbuf.st_uid!=ROOT_uid)
X	   suid=S_ISUID,uid=stbuf.st_uid;
X	if(stbuf.st_mode&S_ISGID)
X	   sgid=S_ISGID,gid=stbuf.st_gid;
X	break;
X      }
X  if(!stat(systm_mbox,&stbuf)&&!(stbuf.st_mode&S_IWOTH))
X     if(stbuf.st_mode&S_IWGRP)
X	sgid=S_ISGID,gid=stbuf.st_gid;
X     else
X	suid=S_ISUID,uid=stbuf.st_uid;
X  if(gid!=stbuf.st_gid)
X     sgid=0;
X  printf("chown root %s\n",argv[1]);
X  if(suid)
X     if(pass=getpwuid(uid))
X	printf("chown %s %s\n",pass->pw_name,argv[2]);
X     else
X	printf("chown %u %s\n",(int)uid,argv[2]);
X  if(sgid)
X     if(grp=getgrgid(gid))
X	printf("chgrp %s %s %s\n",grp->gr_name,argv[1],argv[2]);
X     else
X	printf("chgrp %u %s %s\n",(int)gid,argv[1],argv[2]);
X  printf("chmod %o %s\n",sgid|S_ISUID|PERMIS,argv[1]);
X  if(suid||sgid)
X     printf("chmod %o %s\n",suid|sgid|PERMIS,argv[2]);
X  return EX_OK;
X}
END_OF_FILE
if test 2223 -ne `wc -c <'procmail/recommend.c'`; then
    echo shar: \"'procmail/recommend.c'\" unpacked with wrong size!
fi
# end of 'procmail/recommend.c'
fi
if test -f 'procmail/shell.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/shell.h'\"
else
echo shar: Extracting \"'procmail/shell.h'\" \(214 characters\)
sed "s/^X//" >'procmail/shell.h' <<'END_OF_FILE'
X/*$Id: shell.h,v 2.1 1992/03/19 14:00:28 berg Rel $*/
X
X#define malloc(n)	tmalloc((size_t)(n))
X#define realloc(p,n)	trealloc(p,(size_t)(n))
X#define free(p)		tfree(p)
X#define tmemmove(t,f,n) memmove(t,f,(size_t)(n))
END_OF_FILE
if test 214 -ne `wc -c <'procmail/shell.h'`; then
    echo shar: \"'procmail/shell.h'\" unpacked with wrong size!
fi
# end of 'procmail/shell.h'
fi
if test -f 'procmail/strpbrk.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'procmail/strpbrk.c'\"
else
echo shar: Extracting \"'procmail/strpbrk.c'\" \(344 characters\)
sed "s/^X//" >'procmail/strpbrk.c' <<'END_OF_FILE'
X/*$Id: strpbrk.c,v 1.3 1992/04/23 16:46:41 berg Rel $*/
X#include "includes.h"
X#include "strpbrk.h"
X
X#ifdef NOstrpbrk
Xchar*strpbrk(st,del)const char*const st,*del;
X{ const char*f=0,*t;
X  for(f=0;*del;)
X     if((t=strchr(st,*del++))&&(!f||t<f))
X	f=t;
X  return(char*)f;
X}
X#else
Xchar dummy_strpbrk;			/* to keep some linkers from choking */
X#endif
END_OF_FILE
if test 344 -ne `wc -c <'procmail/strpbrk.c'`; then
    echo shar: \"'procmail/strpbrk.c'\" unpacked with wrong size!
fi
# end of 'procmail/strpbrk.c'
fi
echo shar: End of archive 1 \(of 5\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Sincerely,                                  berg@pool.informatik.rwth-aachen.de
           Stephen R. van den Berg (AKA BuGless).    berg@physik.tu-muenchen.de

He did a quarter of the work in *half* the time!

exit 0 # Just in case...
