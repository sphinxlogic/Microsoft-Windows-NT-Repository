Newsgroups: comp.sources.misc
From: brad@hcx1.ssd.csd.harris.com (Brad Appleton)
Subject:  v31i048:  cmdline - C++ Library for parsing command-line arguments, Part01/07
Message-ID: <1992Jul27.020134.28965@sparky.imd.sterling.com>
X-Md4-Signature: a7697c8b30038458111b360d90ac410a
Date: Mon, 27 Jul 1992 02:01:34 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: brad@hcx1.ssd.csd.harris.com (Brad Appleton)
Posting-number: Volume 31, Issue 48
Archive-name: cmdline/part01
Environment: C++

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 7)."
# Contents:  MANIFEST Makefile README doc doc/Makefile doc/bugs.man
#   doc/caveats.man doc/environ.man doc/example.man doc/files.man
#   doc/macros.man src src/Makefile src/cmd src/cmd/Makefile
#   src/cmd/cmdparse.h src/cmd/cmdparse.tcl src/cmd/fsm.h
#   src/cmd/main.c src/cmd/quoted.h src/cmd/shell_arg.c
#   src/cmd/shell_arg.h src/cmd/syntax.h src/lib src/lib/Makefile
#   src/lib/arglist.h src/lib/exits.h src/lib/fifolist.c
#   src/lib/patchlevel.c src/lib/states.h
# Wrapped by brad@hcx1 on Mon Jul 20 10:41:25 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(3979 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X Config.mk                  2	Make flags for the product
X MANIFEST                   1	This shipping list
X Makefile                   1	Makefile for the product
X Overview                   3	A brief overview of the product
X README                     1	Read this file first
X doc                        1	Documentation directory
X doc/Makefile               1	Makefile for the documentation
X doc/bugs.man               1	documents known bugs
X doc/caveats.man            1	documents known peculiarities
X doc/classes.man            4	documents the basics of the most common classes
X doc/cmdargs.man3           2	documents <cmdargs.h>
X doc/cmdline.man3           2	documents <cmdline.h>
X doc/cmdparse.man1          5	documents cmdparse(1)
X doc/environ.man            1	documents the use of environment variables
X doc/example.man            1	documents example use of CmdLine(3C++)
X doc/files.man              1	documents files used by CmdLine(3C++)
X doc/macros.man             1	some common (n|t)roff macros
X doc/parsing.man            2	documents parsing behavior
X src                        1	Source code directory
X src/Makefile               1	Makefile for the source directories
X src/cmd                    1	cmdparse program subdirectory
X src/cmd/Makefile           1	Makefile for the program
X src/cmd/argtypes.c         2	implementation of shell-script arguments
X src/cmd/argtypes.h         2	definition of shell-script arguments
X src/cmd/cmdparse.c         6	the guts of the cmdparse program
X src/cmd/cmdparse.h         1	the specification of the cmdparse program
X src/cmd/cmdparse.pl        2	cmdparse for Perl programmers
X src/cmd/cmdparse.tcl       1	cmdparse for Tcl programmers
X src/cmd/fsm.c              2	finite-state-machine for parsing arg-syntax
X src/cmd/fsm.h              1	finite-state-machine specification
X src/cmd/main.c             1	main program for cmdparse(1)
X src/cmd/quoted.c           2	implementation of quoted-strings
X src/cmd/quoted.h           1	definition of a quoted-string class
X src/cmd/shell_arg.c        1	implementation of an abstract shell-script arg
X src/cmd/shell_arg.h        1	definition of an abstract shell-script argument
X src/cmd/shells.c           4	implementation of command-interpreters
X src/cmd/shells.h           4	definitions of various command-interpreters
X src/cmd/syntax.c           4	implementation of an argument-syntax object
X src/cmd/syntax.h           1	definition of an argument-syntax object
X src/lib                    1	CmdLine library directory
X src/lib/Makefile           1	Makefile for the library
X src/lib/argiter.c          2	command line argument iterator implementation
X src/lib/arglist.h          1	command argument list type definitions
X src/lib/cmdarg.c           3	implementation of base class CmdArg
X src/lib/cmdargs.c          5	implementation of the various argument types
X src/lib/cmdargs.h          7	include file for the various argument types
X src/lib/cmdline.c          3	constructors/destructors for CmdLine objects
X src/lib/cmdline.h          7	include file for the library
X src/lib/cmdtest.c          3	test program for the library
X src/lib/dump.c             3	dumping/debugging member functions
X src/lib/exits.h            1	definition of exit codes used for exit(3C)
X src/lib/fifolist.c         1	implementation of a generic FIFO linked list
X src/lib/fifolist.h         2	definition of a generic FIFO linked list
X src/lib/parse.c            2	public parsing functions for CmdLine
X src/lib/patchlevel.c       1	functions to return version information
X src/lib/private.c          5	private/protected functions for a CmdLine
X src/lib/states.h           1	state enumeration definitions
X src/lib/strindent.c        3	function to print a hanging indented paragraph
X src/lib/unix.c             6	Unix specific parts of a CmdLine
X src/lib/usage.c            3	usage-message specific parts of a CmdLine
END_OF_FILE
if test 3979 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(1290 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X##########################################################################
X## ^FILE: Makefile - make file for the CmdLine product
X##
X## ^DESCRIPTION:
X##    This is the makefile that is used to build and install the CmdLine
X##    product.
X##
X## ^HISTORY:
X##    04/28/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X###^^#####################################################################
X
Xinclude Config.mk
X
XSUBDIRS = src doc
XSRCDIRS = src
XDOCDIRS = doc
X
X###
X# target dependencies
X###
Xhelp:
X	@$(ECHO) "Usage: make <target>"
X	@$(ECHO) ""
X	@$(ECHO) "where <target> is one of the following:"
X	@$(ECHO) ""
X	@$(ECHO) "    all        -- build (but do not install) the product"
X	@$(ECHO) "    install    -- install the product"
X	@$(ECHO) "    library    -- build the cmdline library"
X	@$(ECHO) "    program    -- build the cmdparse program"
X	@$(ECHO) "    docs       -- build the documentation"
X	@$(ECHO) "    clean      -- remove all intermediate files"
X	@$(ECHO) "    clobber    -- remove all generated files"
X	@$(ECHO) ""
X
Xall install clean clobber:
X	for i in $(SUBDIRS) ; do \
X		( $(CHDIR) $$i ; $(BUILD) $@ ) ; \
X	done
X
Xlibrary program:
X	for i in $(SRCDIRS) ; do \
X		( $(CHDIR) $$i ; $(BUILD) $@ ) ; \
X	done
X
Xdocs:
X	for i in $(DOCDIRS) ; do \
X		( $(CHDIR) $$i ; $(BUILD) all ) ; \
X	done
X
END_OF_FILE
if test 1290 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(6030 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X
X WHAT IS THIS?
X =============
X This is CmdLine, a C++ library for parsing command arguments and assigning
X the corresponding values to program variables. Also included is cmdparse,
X a program to provide an interface to CmdLine for shell-scripts. See the 
X file named "Overview" for a more thorough introduction!
X
X
X AUTHOR
X ======
X Brad Appleton                     Harris Corp., Computer Systems Division
X   Senior Software Engineer        2101 West Cypress Creek Road,  M/S 161 
X     brad@ssd.csd.harris.com       Fort Lauderdale, FL  33309-1892  USA
X       ...!uunet!travis!brad              Phone: (305) 973-5190
X
X
X COPY/REUSE POLICY
X =================
X Permission is hereby granted to freely copy and redistribute this
X software, provided that the author is clearly credited in all copies
X and derivations. Neither the names of the authors nor that of their
X employers may be used to endorse or promote products derived from this
X software without specific written permission.
X
X
X DISCLAIMER
X ==========
X This software is provided ``As Is'' and without any express or implied
X warranties.  Neither the authors nor any of their employers (including
X any of their subsidiaries and subdivisions) are responsible for maintaining
X or supporting this software or for any consequences resulting from the
X use of this software, no matter how awful, even if they arise from flaws
X in the software.
X
X
X CONTENTS
X ========
X See the file "MANIFEST" in the distribution for a complete list and
X description of all the files included in this release.
X
X
X REQUIREMENTS
X ============
X This software should compile on most Unix platforms with a C++ compiler
X with little or no difficulty.
X
X You will need to tweak the Makefiles a tad in order to make them work
X for your C++ compiler.
X
X CmdLine makes extensive use of the "new" operator but makes no attempt
X to see if allocation failed!  CmdLine assumes that any such desired
X error-checking will be taken care of by the programmer by #including
X the header file <new.h> and using the set_new_handler() function.
X
X COMPILATION OPTIONS
X ===================
X The following names may be `#define'd when building CmdLine.
X
X unix            Needed for unix systems
X vms             Needed for vms systems
X msdos           Needed for MS-DOS systems.
X os2             Needed for OS/2 Systems.
X
X unix_style      (This is the default) Use this to have CmdLine parse
X                 command-lines using traditional Unix command-line syntax.
X
X vms_style       (Not yet supported) Use this to have CmdLine parse
X                 command-lines using traditional VAX/VMS DCL syntax.
X
X USE_PLUS        Makes CmdLine use "+" instead of "--" as the keyword prefix
X                 when -Dunix_style is used.
X
X DEBUG_CMDLINE   Enables use of the "dump" member functions in the CmdLine
X                 library.
X
X TEMPLATES       #define this if your C++ compiler supports templates.
X
X GNU_READLINE    Use this if you want CmdLine to use the readline library
X                 (from the FSF) when prompting the user for arguments.
X                 You will probably also need to link with this library.
X
X
X PORTING
X =======
X You may need to tweak the makefiles a bit in order to get CmdLine to build
X properly.  First look at "Config.mk" and change the make-variables to what-
X ever is appropriate for your operating system and compilation environment.
X If you are on an operating system other than Unix, you will also need to
X change all of the "include" statements in the Makefiles to use the proper
X pathname syntax.  If you change the definitions of $(LIBDIR) and $(INCDIR)
X in Config.mk then you should also modify the file doc/macros.man to indicate
X the new locations for where these files are installed.
X
X You should be aware of the following when porting CmdLine to other platforms.
X
X 1) CmdLine assumes that at least one of __STDC__ or __ANSI_CPP__ will be
X    #defined if your C++ compiler uses an ANSI-C preprocessor.
X
X 2) CmdLine uses <stdarg.h> (not <varargs.h>) to handle functions that may
X    take a variable number of arguments.
X 
X 3) Not all systems have the strtod() function used in src/lib/cmdargs.c,
X    If your system DOES have strtod but it is NOT in <stdlib.h> then you
X    will need to add a prototype for it in src/lib/cmdargs.c.  It is possible
X    (but less likely) that you may have similar problems with strtol().
X
X 4) CmdLine uses the AT&T C++ iostream library.  Beyond that, all the
X    #include files it uses are assumed to have the contents specified by
X    the ANSI-C standard and are assumed to have #ifdef __cplusplus statements
X    for when they are being included by C++ files.  CmdLine assumes the
X    existence of the following system header files:
X
X         <stdarg.h>
X         <stdlib.h>
X         <string.h>
X         <ctype.h>
X         <iostream.h>
X         <fstream.h>
X         <strstream.h>
X         <malloc.h>    <--- only used on Unix systems
X
X
X BUGS
X ====
X Please send all bug reports to Brad Appleton <brad@ssd.csd.harris.com>.
X Dont forget to mention which version of CmdLine you have and which
X operating system and C++ compiler you are using.
X
X
X ACKNOWLEDGEMENTS
X ================
X CmdLine is a C++ rewrite of ParseArgs.  The author of this software would
X like to thank Eric Allman and Peter da Silva for their great ideas.
X
X
X FURTHER INFORMATION
X ===================
X For an introduction -- look at the file "Overview" in the distribution!
X
X The documentation is in Unix manpage format (troff with the -man macros)
X and may be found in the "doc" directory but you should be able to find
X out quite a bit by reading the comments in the source files (especially
X in <cmdline.h> and <cmdargs.h>) and by looking at the sample test-program(s).
X
X
X HISTORY
X =======
X Look at the file src/lib/patchlevel.c to see what version of CmdLine you
X have.  Any changes made to the CmdLine product should be documented here:
X
X
X 07/21/92		Brad Appleton		<brad@ssd.csd.harris.com>
X -----------------------------------------------------------------------------
X First release.
X
END_OF_FILE
if test 6030 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test ! -d 'doc' ; then
    echo shar: Creating directory \"'doc'\"
    mkdir 'doc'
fi
if test -f 'doc/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/Makefile'\"
else
echo shar: Extracting \"'doc/Makefile'\" \(2902 characters\)
sed "s/^X//" >'doc/Makefile' <<'END_OF_FILE'
X##########################################################################
X## ^FILE: Makefile - make file for the documentation for CmdLine product
X##
X## ^DESCRIPTION:
X##    This is the makefile that is used to build and install the
X##    documentation CmdLine product.
X##
X## ^HISTORY:
X##    04/28/92  Brad Appleton   <brad@ssd.csd.harris.com>   Created
X###^^#####################################################################
X
Xinclude ../Config.mk
X
X###
X# give a usage message if no target is given
X###
Xusage:
X	@echo "Usage: make <target>"
X	@echo " "
X	@echo "where <target> is one of the following: "
X	@echo " "
X	@echo "   install  -- to install the documentation"
X	@echo "   installman  -- to install the unpacked documentation"
X	@echo "   installcatman  -- to install the packed documentation"
X	@echo "   print  -- to print the documentation"
X	@echo "   view   -- to view the documentation"
X	@echo "   text   -- to build text copies of the documentation"
X	@echo "   spell  -- to spell check the documentation"
X	@echo "   clean  -- to remove all intermediate files"
X	@echo "   clobber  -- to remove all created files"
X
X###
X# files used
X###
XINCLUDES=bugs.man caveats.man environ.man example.man files.man \
X         macros.man parsing.man
XDOCS=cmdparse.man1 cmdline.man3 cmdargs.man3
XMAN3FILES=cmdline.3 cmdargs.3
XMAN1FILES=cmdparse.1
XCATMAN3FILES=cmdline.3.z cmdargs.3.z
XCATMAN1FILES=cmdparse.1.z
X
X###
X# target dependencies
X###
X.SUFFIXES: .man1 .man3 .1 .3
X
X.man1.1:
X	$(SOELIM) $< >$*.1
X	$(MANTOCATMAN) $*.1
X
X.man3.3:
X	$(SOELIM) $< >$*.3
X	$(MANTOCATMAN) $*.3
X
X###
X# installation dependencies
X###
Xall:
X
Xinstall: installman installcatman
X
Xinstallman: installman1 installman3
X
Xinstallcatman: installcatman1 installcatman3
X
Xinstallman1: $(MAN1FILES)
X	( $(CHDIR) $(MANDIR)$(MAN1DIR) ; $(RM) $(MAN1FILES) )
X	$(CP) $(MAN1FILES) $(MANDIR)$(MAN1DIR)
X
Xinstallcatman1: $(CATMAN1FILES)
X	( $(CHDIR) $(CATMANDIR)$(MAN1DIR) ; $(RM) $(CATMAN1FILES) )
X	$(CP) $(CATMAN1FILES) $(CATMANDIR)$(MAN1DIR)
X
Xinstallman3: $(MAN3FILES)
X	( $(CHDIR) $(MANDIR)$(MAN3DIR) ; $(RM) $(MAN3FILES) )
X	$(CP) $(MAN3FILES) $(MANDIR)$(MAN3DIR)
X
Xinstallcatman3: $(CATMAN3FILES)
X	( $(CHDIR) $(CATMANDIR)$(MAN3DIR) ; $(RM) $(CATMAN3FILES) )
X	$(CP) $(CATMAN3FILES) $(CATMANDIR)$(MAN3DIR)
X
X###
X# maintenance dependencies
X###
Xclean:
X	$(RM) $(MAN1FILES) $(MAN3FILES) $(CATMAN1FILES) $(CATMAN3FILES) CmdLine.3.z
X
Xclobber: clean
X	$(RM) *.txt
X
Xspell: $(DOCS) $(INCLUDES)
X	$(SPELL) $(DOCS) $(INCLUDES)
X
Xprint: $(MANFILES)
X	$(TROFF) $(TRFLAGS) $(DOCS)
X
Xtext: ascii
Xtxt: ascii
Xascii:
X	$(NROFF) $(NRFLAGS) cmdparse.man1 | $(COL) > cmdparse1.txt
X	$(NROFF) $(NRFLAGS) cmdline.man3  | $(COL) > cmdline3.txt
X	$(NROFF) $(NRFLAGS) cmdargs.man3  | $(COL) > cmdargs3.txt
X
Xview: $(MANFILES)
X	$(NROFF) $(NRFLAGS) $(DOCS)
X
X##
X# include dependencies
X##
Xcmdparse.1: cmdparse.man1 $(INCLUDES)
X
Xcmdline.3: cmdline.man3 $(INCLUDES)
X
Xcmdargs.3: cmdargs.man3 $(INCLUDES)
X
END_OF_FILE
if test 2902 -ne `wc -c <'doc/Makefile'`; then
    echo shar: \"'doc/Makefile'\" unpacked with wrong size!
fi
# end of 'doc/Makefile'
fi
if test -f 'doc/bugs.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/bugs.man'\"
else
echo shar: Extracting \"'doc/bugs.man'\" \(677 characters\)
sed "s/^X//" >'doc/bugs.man' <<'END_OF_FILE'
X.SH BUGS
XWhen a non-multivalued argument appears more than once on the command-line
Xthen only the last value supplied is used. A problem occurs however in the
Xfollowing scenario: suppose `\fB\-s\fP' is an option that takes an optional
Xstring argument (and suppose `\fB\-x\fP' is some boolean flag). Now, if the
Xfollowing command-line is issued:
X
X.XS
Xcommand  \-s string  \-x  \-s
X.XE
X
Xthen, even though it may appear as if the value used will properly correspond
Xto the second instance of the `\fB\-s\fP' option, the value associated with
Xthe option will be ``\fIstring\fP'' (because the first instance overwrote
Xthe default and the second instance left the value untouched).
X
END_OF_FILE
if test 677 -ne `wc -c <'doc/bugs.man'`; then
    echo shar: \"'doc/bugs.man'\" unpacked with wrong size!
fi
# end of 'doc/bugs.man'
fi
if test -f 'doc/caveats.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/caveats.man'\"
else
echo shar: Extracting \"'doc/caveats.man'\" \(1292 characters\)
sed "s/^X//" >'doc/caveats.man' <<'END_OF_FILE'
X.SH CAVEATS
XWhen an argument takes a required value and the value is in a separate
Xtoken from the argument (as in "\fB\-c\ \ \fIvalue\fR") then the next
Xtoken on the command-line is assumed to be the value for that argument
X(even if the token \fIlooks\fP like an option because its starts with
Xa `\-' character).
X
XIf however, an argument takes an \fIoptional\fP value and the value is
Xin a separate token from the argument, the next token on the command-line
Xis assumed to be the value for that argument \fIonly if the next token
Xdoes \s-1NOT\s+1 look like an option\fP.  In order to specify a value
Xthat looks like an option to an argument that takes an optional value,
Xit is recommended that the value occur in the same token as the argument
Xitself (as in "\fB\-c\fI\-value\fR").
X
XThe above also applies to non-positional lists.  A non-positional list
Xis automatically terminated by another option, or by the token ``\*(--''.
XIt is a "feature" of \*(NM that the following are equivalent (assuming
Xthat \fB\-l\fP takes a list of one or more values):
X
X.XS
Xcmdname \-l value1 value2 
Xcmdname \-lvalue1 \-lvalue2
X.XE
X
XHence, to supply values that look like options to non-positional list
Xarguments, it is recommended that the following syntax be used:
X
X.XS
Xcmdname \-l\-value1 \-l\-value2
X.XE
X
END_OF_FILE
if test 1292 -ne `wc -c <'doc/caveats.man'`; then
    echo shar: \"'doc/caveats.man'\" unpacked with wrong size!
fi
# end of 'doc/caveats.man'
fi
if test -f 'doc/environ.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/environ.man'\"
else
echo shar: Extracting \"'doc/environ.man'\" \(616 characters\)
sed "s/^X//" >'doc/environ.man' <<'END_OF_FILE'
X.SH ENVIRONMENT
XThe following two environment variables (if defined) are used
Xby \*(NM:
X
X.IP "$PROMPT_USER"
XIf this variable exists and is non-empty, then the user will be
Xinteractively prompted for any missing required arguments.
X
X.IP "$USAGE_LEVEL"
XThis variable controls the verboseness of usage messages that are printed.
XIf This variable is empty or is undefined, then verbose messages are printed.
XIf this variable exists and is non-empty, it may be set to one of the
Xfollowing values:
X.RS
X.IP 0
XNo usage message is printed.
X.IP 1
XA terse usage message is printed
X.IP 2
XA verbose usage message is printed.
X.RE
END_OF_FILE
if test 616 -ne `wc -c <'doc/environ.man'`; then
    echo shar: \"'doc/environ.man'\" unpacked with wrong size!
fi
# end of 'doc/environ.man'
fi
if test -f 'doc/example.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/example.man'\"
else
echo shar: Extracting \"'doc/example.man'\" \(1994 characters\)
sed "s/^X//" >'doc/example.man' <<'END_OF_FILE'
X.SH EXAMPLE
X.PP
XUsing the \*(NM library is relatively easy \- you need to construct your
Xarguments, your command-line, and your argument iterator.  Then all that is
Xleft to do is call the \f4parse\fP member function of your \*(NM object.
XThe following is a simple example:
X
X.XS
X#include <stdlib.h>
X#include <iostream.h>
X#include <cmdargs.h>
X
Xint  main(int argc, char * argv[])
X{
X      // Declare arguments
X   CmdArgInt  count('c', "count", "number",
X                       "number of copies to print.");
X.sp 4p
X   CmdArgBool xflag('x', "xmode",
X                       "turn on 'x'-mode.");
X.sp 4p
X   CmdArgChar fdsep('s', "separator", "char",
X                       "field-separator to use.");
X.sp 4p
X   CmdArgStr  input("input-file",
X                       "input file to read.");
X.sp 4p
X   CmdArgStrList  output("[output-file \*(..]",
X                            "where to print output.");
X
X      // Declare the command and the argument-iterator
X   CmdLine  cmd(*argv,
X                   &count, &xflag, &fdsep,
X                   &input, &output, NULL);
X.sp 4p
X   CmdArgvIter  arg_iter(--argc, ++argv);
X
X      // Initialize arguments to appropriate default values.
X   count = 1;
X   xflag = 0;
X   fdsep = ',';
X
X      // Parse arguments
X   cmd.parse(arg_iter);
X
X      // Print arguments
X   cout << "count=" << count << endl ;
X   cout << "xflag=" << (xflag ? "ON" : "OFF") << endl ;
X   cout << "fdsep='" << (char) fdsep << "'" << endl ;
X   cout << "input=\\"" << input << "\\"" << endl ;
X   
X   for (int i = 0 ; i < output.count() ; i++) {
X      cout << "output[" << i << "]=" << output[i] << endl ;
X   }
X
X   return  0;
X}
X.XE
X
XThe Unix command-line syntax for the above program would be as follows:
X
X.XS
Xprogname [\-c number] [\-x] [\-s char] input-file [output-file \*(..]
X.XE
X
XThe Unix command-line syntax using long-options (keywords) for the above
Xprogram would be as follows:
X
X.XS
Xprogname [\*(--count number] [\*(--xmode] [\*(--separator char]
X         input-file [output-file \*(..]
X.XE
END_OF_FILE
if test 1994 -ne `wc -c <'doc/example.man'`; then
    echo shar: \"'doc/example.man'\" unpacked with wrong size!
fi
# end of 'doc/example.man'
fi
if test -f 'doc/files.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/files.man'\"
else
echo shar: Extracting \"'doc/files.man'\" \(584 characters\)
sed "s/^X//" >'doc/files.man' <<'END_OF_FILE'
X.SH FILES
X.PP
X.IP \f4\*i/cmdline.h\fP
X\*(C+ include file which contains the definition of a command-argument class,
Xa command-line class, and argument-iterator classes.
X
X.IP \f4\*i/cmdargs.h\fP
X\*(C+ include file which contains the definitions of some predefined
Xcommand-argument subclasses.
X
X.IP \f4\*l/libcmdline.a\fP
XThe object library for \*(NM(3\*(C+).
X
X.PP
XWhen compiling your source (on Unix systems), you may need to use
Xthe \fB\-I\f4\*i\fR option. When linking your objects,
Xyou may need to use the \fB\-L\f4\*l\fR option in conjunction
Xwith the \fB\-l\f4cmdline\fR option.
X
END_OF_FILE
if test 584 -ne `wc -c <'doc/files.man'`; then
    echo shar: \"'doc/files.man'\" unpacked with wrong size!
fi
# end of 'doc/files.man'
fi
if test -f 'doc/macros.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/macros.man'\"
else
echo shar: Extracting \"'doc/macros.man'\" \(839 characters\)
sed "s/^X//" >'doc/macros.man' <<'END_OF_FILE'
X.\"=========================================
X.\" This file contains some user defined (n|t)roff macros for general use
X.\"=========================================
X.de XS
X. RS
X. nf
X. ft 4
X..
X.de XE
X. ft R
X. fi
X. RE
X..
X.ds -- \-\|\-
X.ds C+ C\s-2\v'-1.5p'\(pl\(pl\v'+1.5p'\s+2
X.ds .. .\^.\^.
X.\"-------------------------------------------
X.\" The following "strings" should correspond to where the CmdLine files
X.\" have been installed.  "b" is where executable files are installed.
X.\" "i" is where the include files where installed and "l" is where the
X.\" object-library is installed. You should change the definition of
X.\" these macros if they are not installed in the places indicated below.
X.\"-------------------------------------------
X.ds b /usr/local/bin
X.ds i /usr/local/include
X.ds l /usr/local/lib
X.ds p \*l/perl
X.ds t \*l/tcl
END_OF_FILE
if test 839 -ne `wc -c <'doc/macros.man'`; then
    echo shar: \"'doc/macros.man'\" unpacked with wrong size!
fi
# end of 'doc/macros.man'
fi
if test ! -d 'src' ; then
    echo shar: Creating directory \"'src'\"
    mkdir 'src'
fi
if test -f 'src/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/Makefile'\"
else
echo shar: Extracting \"'src/Makefile'\" \(1278 characters\)
sed "s/^X//" >'src/Makefile' <<'END_OF_FILE'
X##########################################################################
X## ^FILE: Makefile - make file for the CmdLine product
X##
X## ^DESCRIPTION:
X##    This is the makefile that is used to build and install the CmdLine
X##    library and the cmdparse program.
X##
X## ^HISTORY:
X##    04/28/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X###^^#####################################################################
X
Xinclude ../Config.mk
X
XSUBDIRS = lib cmd 
XLIBDIRS = lib
XPROGDIRS = cmd
X
X###
X# target dependencies
X###
Xhelp:
X	@$(ECHO) "Usage: make <target>"
X	@$(ECHO) ""
X	@$(ECHO) "where <target> is one of the following:"
X	@$(ECHO) ""
X	@$(ECHO) "    all        -- build (but do not install) the product"
X	@$(ECHO) "    install    -- install CmdLine(3C++) and cmdparse(1)
X	@$(ECHO) "    library    -- build the cmdline library"
X	@$(ECHO) "    program    -- build the cmdparse program"
X	@$(ECHO) "    clean      -- remove all intermediate files"
X	@$(ECHO) "    clobber    -- remove all generated files"
X	@$(ECHO) ""
X
Xall install clean clobber:
X	for i in $(SUBDIRS) ; do \
X		( $(CHDIR) $$i ; $(BUILD) $@ ) ; \
X	done
X
Xprogram:
X	for i in $(PROGDIRS) ; do \
X		( $(CHDIR) $$i ; $(BUILD) $@ ) ; \
X	done
X
Xlibrary:
X	for i in $(LIBDIRS) ; do \
X		( $(CHDIR) $$i ; $(BUILD) $@ ) ; \
X	done
X
END_OF_FILE
if test 1278 -ne `wc -c <'src/Makefile'`; then
    echo shar: \"'src/Makefile'\" unpacked with wrong size!
fi
# end of 'src/Makefile'
fi
if test ! -d 'src/cmd' ; then
    echo shar: Creating directory \"'src/cmd'\"
    mkdir 'src/cmd'
fi
if test -f 'src/cmd/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/cmd/Makefile'\"
else
echo shar: Extracting \"'src/cmd/Makefile'\" \(3253 characters\)
sed "s/^X//" >'src/cmd/Makefile' <<'END_OF_FILE'
X##########################################################################
X## ^FILE: Makefile - make file for the cmdparse program
X##
X## ^DESCRIPTION:
X##    This is the makefile that is used to build and install the "cmdparse"
X##    program. In order to get cmdparse to build on your system you may
X##    need to change some of the "variables" mentioned below. You may also
X##    need to redefine some of the commands that are used.
X##
X## ^TARGETS:
X##    all     : make the cmdparse program
X##    program : same as "all"
X##    install : build and install the cmdparse program
X##    clean   : remove all intermediate files generated by the build
X##    clobber : remove all files generated by the build
X##
X## ^VARIABLES:
X##    OS         : specify the host operating system (default=unix)
X##    FLAG       : debugging/optimization flags to the compiler (default=-g)
X##    TESTDEFS   : #defines used for testing
X##    USRDEFS    : #defines flags used for building (default=unix)
X##    OPTIONS    : any other compiler flags to use
X##
X## ^HISTORY:
X##    04/10/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X###^^#####################################################################
X
Xinclude ../../Config.mk
X
X###
X# operating-system dependent stuff
X###
XOS=unix
X# OSDEFS=$(DEF)$(OS) $(DEF)$(.UNIVERSE)_universe
X
X##
X# Programs
X##
XPROGRAM=$(PROGNAME)$(EXECEXT)
X
X###
X# Program Libraries
X###
XPROGLIB=$(PROGLIBDIR)lib$(LIBNAME)$(LIBEXT)
X
X###
X# compilation options
X###
XINCLUDES=$(INC)$(PROGLIBDIR)
XFLAG=$(OPT)
X# FLAG=$(DBG)
XTESTDEFS=
XUSRDEFS=
XDEFINES=$(OSDEFS) $(USRDEFS) $(TESTDEFS)
XOPTIONS=
XCFLAGS=$(FLAG) $(INCLUDES) $(DEFINES) $(OPTIONS)
X
X###
X# files used
X###
XOBJS= argtypes$(OBJEXT) cmdparse$(OBJEXT) fsm$(OBJEXT) main$(OBJEXT) \
X   quoted$(OBJEXT) shell_arg$(OBJEXT) shells$(OBJEXT) syntax$(OBJEXT)
X
XPROGLIB=$(PROGLIBDIR)libcmdline$(LIBEXT)
X
X###
X# target dependencies
X###
Xall: program
X
Xprogram: library $(PROGRAM)
X
Xlibrary:
X	( $(CHDIR) $(PROGLIBDIR) ; $(BUILD) $@ ; )
X
X$(PROGRAM): $(OBJS)
X	$(CC) $(EXE)$@ $(OBJS) $(PROGLIB)
X
X###
X# maintenance dependencies
X###
Xinstall: $(PROGRAM) $(BINDIR) $(PROGRAM).pl
X	-$(RM) $(BINDIR)$(PROGRAM) $(PERLLIB)$(PROGRAM).pl $(TCLLIB)$(PROGRAM).tcl
X	$(CP) $(PROGRAM)  $(BINDIR)$(PROGRAM)
X	$(STRIP) $(BINDIR)$(PROGRAM)
X	-$(CP) $(PROGRAM).pl $(PERLLIB)$(PROGRAM).pl
X	-$(CP) $(PROGRAM).tcl $(TCLLIB)$(PROGRAM).tcl
X
Xclean:
X	-$(RM) *$(OBJEXT) core .exrc *~ \#*\#
X
Xclobber: clean
X	-$(RM) *$(LIBEXT) $(PROGRAM) tags TAGS
X
X###
X# object dependencies
X###
Xargtypes$(OBJEXT) : argtypes$(CEXT) argtypes.h shell_arg.h \
X   $(PROGLIBDIR)cmdargs.h $(PROGLIBDIR)cmdline.h shells.h
X
Xcmdparse$(OBJEXT) : cmdparse$(CEXT) argtypes.h shell_arg.h \
X   $(PROGLIBDIR)cmdargs.h $(PROGLIBDIR)cmdline.h shells.h cmdparse.h \
X   syntax.h fsm.h quoted.h
X
Xfsm$(OBJEXT) : fsm$(CEXT) fsm.h
X
Xmain$(OBJEXT) : main$(CEXT) $(PROGLIBDIR)cmdline.h cmdparse.h \
X   $(PROGLIBDIR)cmdargs.h
X
Xquoted$(OBJEXT) : quoted$(CEXT) quoted.h
X
Xshell_arg$(OBJEXT) : shell_arg$(CEXT) shell_arg.h $(PROGLIBDIR)cmdargs.h \
X   $(PROGLIBDIR)cmdline.h shells.h
X
Xshells$(OBJEXT) : shells$(CEXT) $(PROGLIBDIR)fifolist.h shells.h \
X   argtypes.h shell_arg.h $(PROGLIBDIR)cmdargs.h $(PROGLIBDIR)cmdline.h
X
Xsyntax$(OBJEXT) : syntax$(CEXT) $(PROGLIBDIR)cmdline.h syntax.h fsm.h \
X   quoted.h
END_OF_FILE
if test 3253 -ne `wc -c <'src/cmd/Makefile'`; then
    echo shar: \"'src/cmd/Makefile'\" unpacked with wrong size!
fi
# end of 'src/cmd/Makefile'
fi
if test -f 'src/cmd/cmdparse.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/cmd/cmdparse.h'\"
else
echo shar: Extracting \"'src/cmd/cmdparse.h'\" \(3484 characters\)
sed "s/^X//" >'src/cmd/cmdparse.h' <<'END_OF_FILE'
X//------------------------------------------------------------------------
X// ^FILE: cmdparse.h - define the interface to cmdparse(1)
X//
X// ^DESCRIPTION:
X//    This file defines a class that carries out the services provided
X//    by cmdparse(1).
X//
X// ^HISTORY:
X//    05/01/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X//-^^---------------------------------------------------------------------
X
X#ifndef _cmdparse_h
X#define _cmdparse_h
X
X#include <cmdargs.h>
X
X
X   // Exit values used
Xenum  ExitValues {
X   e_SUCCESS   = 0,      // no errors
X   e_USAGE     = 1,      // no errors - usage printed
X   e_VERSION   = 1,      // no errors - version printed
X   e_CMDSYNTAX = 2,      // command-line syntax error
X   e_BADSHELL  = 3,      // invalid shell specified
X   e_BADDECLS  = 4,      // invalid declaration(s) given
X} ;
X
X
X   // CmdArgVers is a class that simply prints (on cerr) the version
X   // information for this command.
X   //
Xclass  CmdArgVers : public CmdArg {
Xpublic:
X   CmdArgVers(char optchar, const char * keyword, const char * description);
X
X   virtual ~CmdArgVers(void);
X
X   virtual  int
X   operator()(const char * & arg, CmdLine & cmd);
X} ;
X
X
Xclass  istream ;
Xclass  ArgSyntax ;
Xclass  UnixShell ;
Xclass  CmdParseCommand : public CmdLine {
Xpublic:
X
X   CmdParseCommand(const char * name);
X
X   virtual  ~CmdParseCommand(void);
X
X      // Do whatever it is we need to do!
X   int
X   operator()(CmdLineArgIter & iter) ;
X
Xprivate:
X      // Dont allow copying or assignment
X   CmdParseCommand(const CmdParseCommand &);
X   CmdParseCommand & operator=(const CmdParseCommand &);
X
X      // Set the users arguments
X   void
X   set_args(UnixShell * shell);
X
X      // Parse the users argument declarations
X   int
X   parse_declarations(void);
X
X   int
X   parse_declarations(const char * input);
X
X   int
X   parse_declarations(istream & input);
X
X      // Add a parsed declaration to the user's argument list
X   int
X   usr_append(const char * type,
X              const char * varname,
X              ArgSyntax  & arg,
X              const char * description);
X
X   //------------------------------------------------ arguments to cmdparse(1)
X
X   CmdArgBool     anywhere;         // clear OPTS_FIRST
X   CmdArgBool     anycase;          // set ANY_CASE_OPTS
X   CmdArgBool     no_abort;         // set NO_ABORT
X   CmdArgBool     no_guessing;      // set NO_GUESSING
X   CmdArgBool     prompt;           // set PROMPT_USER
X   CmdArgBool     opts_only;        // set OPTS_ONLY
X   CmdArgBool     kwds_only;        // set KWDS_ONLY
X   CmdArgBool     quiet;            // set QUIET
X
X   CmdArgVers     version;          // print version and exit
X   CmdArgBool     usage;            // print usage and exit
X
X   CmdArgBool     array_variant;    // use alternate array syntax
X   CmdArgStr      true_str;         // TRUE for booleans
X   CmdArgStr      false_str;        // FALSE for booleans
X   CmdArgStr      suffix_str;       // suffix for missing optional-values
X   CmdArgStr      usr_shell;        // the shell (command interpreter)
X
X   CmdArgStr      input_file;       // read declarations from file
X   CmdArgStr      input_var;        // read declarations environment variable
X   CmdArgStr      input_str;        // read declarations from string
X
X   CmdArgDummy    dummy_arg;        // "--"
X
X   CmdArgStr      usr_prog;         // program name
X   CmdArgStrList  usr_args;         // program arguments
X
X   CmdLine        usr_cmd;          // the user's CmdLine object
X} ;
X
X#endif  /* _cmdparse_h */
X
END_OF_FILE
if test 3484 -ne `wc -c <'src/cmd/cmdparse.h'`; then
    echo shar: \"'src/cmd/cmdparse.h'\" unpacked with wrong size!
fi
# end of 'src/cmd/cmdparse.h'
fi
if test -f 'src/cmd/cmdparse.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/cmd/cmdparse.tcl'\"
else
echo shar: Extracting \"'src/cmd/cmdparse.tcl'\" \(3672 characters\)
sed "s/^X//" >'src/cmd/cmdparse.tcl' <<'END_OF_FILE'
X#########################################################################
X# ^FILE: cmdparse.tcl - cmdparse for tcl scripts
X#
X# ^DESCRIPTION:
X#    This file defines a tcl procedure named cmdparse to parse
X#    command-line arguments for tcl scripts.
X#
X# ^HISTORY:
X#    05/07/92  Brad Appleton   <brad@ssd.csd.harris.com>   Created
X##^^#####################################################################
X
X########
X# ^PROCEDURE: cmdparse - parse command-line argument lists
X#
X# ^SYNOPSIS:
X#    cmdparse <options> -- $scriptName $list
X#
X#        where <options> is any valid option combination for cmdparse(1),
X#        $scriptName is the name of the user's tcl script (or procedure),
X#        and $list is a list (which will usually be $argv for scripts, and
X#        and $args for procedures).
X#
X# ^DESCRIPTION:
X#    Parseargs will invoke cmdparse(1) with the options and arguments
X#    specified by the caller.
X#
X# ^REQUIREMENTS:
X#    Any desired initial values for variables from the argument-description
X#    string should be assigned BEFORE calling this procedure.
X#
X# ^SIDE-EFFECTS:
X#    If cmdparse(1) exits with a non-zero status, then execution
X#    is terminated.
X#
X# ^RETURN-VALUE:
X#    A string of variable settings for the caller to evaluate.
X#
X# ^EXAMPLE:
X#     #!/usr/local/bin/tcl
X#
X#     load  "cmdparse.tcl"
X#
X#     set arguments {
X#        ArgStr   string  "[S|Str [string]]"          "optional string arg"
X#        ArgStr   groups  "[g|groups newsgroups ...]" "newsgroups to test"
X#        ArgInt   count   "[c|count integer]"         "group repeat count"
X#        ArgStr   dirname "[d|directory pathname]"    "working directory"
X#        ArgBool  xflag   "[x|xflag]"                 "turn on x-mode"
X#        ArgClear yflag   "[y|yflag]"                 "turn off y-mode"
X#        ArgChar  sepch   "[s|separator char]"        "field separator"
X#        ArgStr   files   "[f|files filename ...]"    "files to process"
X#        ArgStr   name    "[n|name] name"             "name to use"
X#        ArgStr   argv    "[arguments ...]"           "remaining arguments"
X#     }
X#
X#     set count 1 ;    set dirname "." ;   set sepch "," ;
X#     set xflag 0 ;    set yflag 1 ;
X#     set files {} ;   set groups {} ;
X#     set string "" ;
X#
X#     eval [ cmdparse -decls $arguments -- $scriptName $argv ]
X#
X###^^####
Xproc cmdparse args {
X      ## set temp-file name
X   if {( ! [info exists env(TMP)] )}  { set env(TMP) "/tmp" }
X   if {( $env(TMP) == "" )}  { set env(TMP) "/tmp" }
X   set tmpFileName "$env(TMP)/tmp[id process]"
X
X       ## isolate the last argument (a list) from the rest
X   set last [expr {[llength $args] - 1}]
X   set cmdArgs [lindex $args $last]
X   set cmdOpts [lrange $args 0 [expr {$last - 1}]]
X
X      ## fork and exec
X   if {( [set childPid [fork]] == 0 )} {
X         ## This is the child ...
X         ##    redirect stdout to temp-file and exec cmdparse(1)
X         ##
X      set tmpFile [open $tmpFileName "w"]
X      close stdout
X      dup $tmpFile stdout
X      close $tmpFile
X      execl cmdparse [concat -shell=tcl $cmdOpts $cmdArgs]
X   } else {
X         ## This is the parent ...
X         ##    wait for the child, check its status, then return its output
X         ##    dont forget to remove the temp-file.
X         ##
X      set childStatus [wait $childPid]
X      set how [lindex $childStatus 1]
X      set ret [lindex $childStatus 2]
X      if {( ($how == "EXIT")  &&  ($ret == 0) )} {
X         set variableSettings [exec cat $tmpFileName]
X         unlink -nocomplain $tmpFileName
X         return $variableSettings
X      } else {
X         unlink -nocomplain $tmpFileName
X         exit [expr {$how == "EXIT" ? $ret : 127}]
X      }
X   }
X}
X
END_OF_FILE
if test 3672 -ne `wc -c <'src/cmd/cmdparse.tcl'`; then
    echo shar: \"'src/cmd/cmdparse.tcl'\" unpacked with wrong size!
fi
# end of 'src/cmd/cmdparse.tcl'
fi
if test -f 'src/cmd/fsm.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/cmd/fsm.h'\"
else
echo shar: Extracting \"'src/cmd/fsm.h'\" \(2265 characters\)
sed "s/^X//" >'src/cmd/fsm.h' <<'END_OF_FILE'
X//------------------------------------------------------------------------
X// ^FILE: fsm.h - define a finite state machine
X//
X// ^DESCRIPTION:
X//     This file defines a finite state machine tailored to the task of
X//     parsing syntax strings for command-line arguments.
X//
X// ^HISTORY:
X//    03/27/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X//-^^---------------------------------------------------------------------
X
Xclass SyntaxFSM {
Xpublic:
X   enum state_t {
X      START,    // start-state
X      OPTION,   // just parsed an option-spec
X      KEYWORD,  // just parsed a keyword-spec
X      VALUE,    // just parsed a value-spec
X      LIST,     // just parsed "..."
X      FINAL,    // final-state
X      ERROR,    // syntax error encountered
X   } ;
X
X   struct token_t {
X      const char * start;  // start address of token
X      unsigned     len;    // length of token
X
X      token_t(void) : start(0), len(0) {}
X
X      void
X      set(const char * s, unsigned l) { start = s, len = l; }
X   } ;
X
X   SyntaxFSM(void) : ntoks(0), nbpairs(0), lev(0), fsm_state(START) {}
X
X      // Reset the FSM 
X   void
X   reset(void) { ntoks = 0; nbpairs = 0; lev = 0; fsm_state = START; }
X
X      // Return the number of tokens parsed thus far.
X   unsigned
X   num_tokens(void) const  { return  ntoks; }
X
X      // Return the number of balanced brace-pairs parsed thus far.
X   unsigned
X   num_braces(void) const  { return  nbpairs; }
X
X      // Return the current nesting level of brace-pairs
X   int
X   level(void) const  { return  lev; }
X
X      // Return the current machine state
X   state_t
X   state(void) const  { return  fsm_state; }
X
X      // Get the next token from "input" and place it in "token"
X      // (consuming characters from "input").
X      //
X      // Return 0 if the resulting state is FINAL;
X      // otherwise return NON-zero.
X      //
X   int
X   operator()(const char * & input, token_t & token);
X
Xprotected:
X   unsigned  ntoks;      // number of tokens parsed thus far
X   unsigned  nbpairs;    // number of balanced brace-pairs parsed thus far
X   int       lev;        // current nesting level of brace-pairs
X   state_t   fsm_state;  // current machine state
X
Xprivate:
X   void
X   skip(const char * & input);
X
X   void
X   parse_token(const char * & input);
X} ;
X
END_OF_FILE
if test 2265 -ne `wc -c <'src/cmd/fsm.h'`; then
    echo shar: \"'src/cmd/fsm.h'\" unpacked with wrong size!
fi
# end of 'src/cmd/fsm.h'
fi
if test -f 'src/cmd/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/cmd/main.c'\"
else
echo shar: Extracting \"'src/cmd/main.c'\" \(854 characters\)
sed "s/^X//" >'src/cmd/main.c' <<'END_OF_FILE'
X//------------------------------------------------------------------------
X// ^FILE: main.c - main program for cmdparse(1)
X//
X// ^DESCRIPTION:
X//     Instantiate a CmdParseCommand object and let it go do its stuff!
X//
X// ^HISTORY:
X//    05/03/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X//-^^---------------------------------------------------------------------
X
X#include <new.h>
X#include <iostream.h>
X#include <stdlib.h>
X
X#include "cmdparse.h"
X
X//
X//  cmdparse_new_handler -- allocation error handler for cmdparse(1).
X//
Xvoid  cmdparse_new_handler(void)
X{
X   cerr << "cmdparse: free-store allocation error." << endl ;
X   ::exit(127);
X}
X
Xint
Xmain(int argc, const char * argv[])
X{
X   set_new_handler(cmdparse_new_handler);
X
X   CmdParseCommand  cmdparse_cmd(*argv);
X   CmdArgvIter  argv_iter(--argc, ++argv);
X
X   return  cmdparse_cmd(argv_iter);
X}
X
END_OF_FILE
if test 854 -ne `wc -c <'src/cmd/main.c'`; then
    echo shar: \"'src/cmd/main.c'\" unpacked with wrong size!
fi
# end of 'src/cmd/main.c'
fi
if test -f 'src/cmd/quoted.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/cmd/quoted.h'\"
else
echo shar: Extracting \"'src/cmd/quoted.h'\" \(1637 characters\)
sed "s/^X//" >'src/cmd/quoted.h' <<'END_OF_FILE'
X//------------------------------------------------------------------------
X// ^FILE: quoted.h - a class for "quoted" strings
X//
X// ^DESCRIPTION:
X//    This file implements a quoted-string class.  The main purpose of
X//    this class is the input extraction operator (operator>>) which
X//    reads a quoted string from input (enclosed in either single or
X//    double quotes) and places the result (minus containing quotes)
X//    into a character string.  Single and double quotes may be made part
X//    of the string be preceding them with a backslash ('\') in the input
X//    stream.
X//
X// ^HISTORY:
X//    05/01/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X//-^^---------------------------------------------------------------------
X
X#ifndef _quoted_h
X#define _quoted_h
X
Xclass  istream ;
Xclass  QuotedString {
Xpublic:
X      // constructors and destructors
X   QuotedString(unsigned  max_size);
X
X   QuotedString(const char * str);
X
X   QuotedString(const char * str, unsigned  max_size);
X
X   QuotedString(const QuotedString & qstr);
X
X   virtual ~QuotedString(void);
X
X      // assignment
X   QuotedString &
X   operator=(const QuotedString & qstr);
X
X   QuotedString &
X   operator=(const char * str);
X
X      // convert to a string
X   operator  char*(void) { return  buffer; }
X
X      // operator >> reads a quoted string from input.
X      // If no beginning or ending quote is seen, than
X      // a message is printed on cerr and the failbit
X      // of the input stream is set.
X      //
X   friend  istream &
X   operator>>(istream & is, QuotedString & qstr);
X
Xprivate:
X   unsigned  size;
X   char    * buffer;
X} ;
X
X#endif  /* _quoted_h */
X
END_OF_FILE
if test 1637 -ne `wc -c <'src/cmd/quoted.h'`; then
    echo shar: \"'src/cmd/quoted.h'\" unpacked with wrong size!
fi
# end of 'src/cmd/quoted.h'
fi
if test -f 'src/cmd/shell_arg.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/cmd/shell_arg.c'\"
else
echo shar: Extracting \"'src/cmd/shell_arg.c'\" \(2891 characters\)
sed "s/^X//" >'src/cmd/shell_arg.c' <<'END_OF_FILE'
X//------------------------------------------------------------------------
X// ^FILE: shell_arg.c - implement a shell-script argument
X//
X// ^DESCRIPTION:
X//    This file implements the base class that is used for all
X//    shell-script command arguments.
X//
X// ^HISTORY:
X//    04/22/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X//-^^---------------------------------------------------------------------
X
X#include <stdlib.h>
X#include <iostream.h>
X#include <string.h>
X#include <ctype.h>
X
X#include "shell_arg.h"
X
X//----------------------------------------------------------------- initialize
X
Xvoid
XShellCmdArg::initialize(const char * variable_name)
X{
X   if (is_array()) {
X      shell_array = new ShellArray(variable_name) ;
X   } else {
X      shell_variable = new ShellVariable(variable_name) ;
X   }
X}
X
X//---------------------------------------------------------------- constructors
X
XShellCmdArg::ShellCmdArg(char    * variable_name,
X                         char      optchar,
X                         char    * keyword,
X                         char    * value,
X                         char    * description,
X                         unsigned  syntax_flags)
X   : CmdArg(optchar, keyword, value, description, syntax_flags),
X     sca_name(variable_name), sca_keyword(keyword),
X     sca_value(value), sca_description(description)
X{
X   initialize(variable_name);
X}
X
XShellCmdArg::ShellCmdArg(char    * variable_name,
X                         char      optchar,
X                         char    * keyword,
X                         char    * description,
X                         unsigned  syntax_flags)
X   : CmdArg(optchar, keyword, description, syntax_flags),
X     sca_name(variable_name), sca_keyword(keyword),
X     sca_value(NULL), sca_description(description)
X{
X   initialize(variable_name);
X}
X
XShellCmdArg::ShellCmdArg(char    * variable_name,
X                         char    * value,
X                         char    * description,
X                         unsigned  syntax_flags)
X   : CmdArg(value, description, syntax_flags),
X     sca_name(variable_name), sca_keyword(NULL),
X     sca_value(value), sca_description(description)
X{
X   initialize(variable_name);
X}
X
X//------------------------------------------------------------------ destructor
X
XShellCmdArg::~ShellCmdArg(void)
X{
X   if (is_array()) {
X      delete  shell_array ;
X   } else {
X      delete  shell_variable ;
X   }
X   delete [] sca_name ;
X   delete [] sca_keyword ;
X   delete [] sca_value ;
X   delete [] sca_description ;
X}
X
X//-------------------------------------------------------------------- is_array
X
Xint
XShellCmdArg::is_array(void) const
X{
X   return  (syntax() & CmdArg::isLIST) ;
X}
X
X//------------------------------------------------------------------------- set
X
Xvoid
XShellCmdArg::set(const char * value)
X{
X   if (is_array()) {
X      shell_array->append(value);
X   } else {
X      shell_variable->set(value);
X   }
X}
X
END_OF_FILE
if test 2891 -ne `wc -c <'src/cmd/shell_arg.c'`; then
    echo shar: \"'src/cmd/shell_arg.c'\" unpacked with wrong size!
fi
# end of 'src/cmd/shell_arg.c'
fi
if test -f 'src/cmd/shell_arg.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/cmd/shell_arg.h'\"
else
echo shar: Extracting \"'src/cmd/shell_arg.h'\" \(2791 characters\)
sed "s/^X//" >'src/cmd/shell_arg.h' <<'END_OF_FILE'
X//------------------------------------------------------------------------
X// ^FILE: shell_arg.h - define a shell-script command-line argument
X//
X// ^DESCRIPTION:
X//    This file defines the base class for all shell-script command
X//    line arguments.  In addition to inheriting from class CmdArg,
X//    a ShellCmdArg must also contain a variable-name, and its value.
X//
X// ^HISTORY:
X//    04/22/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X//-^^---------------------------------------------------------------------
X
X#ifndef  _shell_arg_h
X#define  _shell_arg_h
X
X#include  <cmdargs.h>
X
X#include  "shells.h"
X
X   // All of our shell-script args will be ShellCmdArgs with two possible
X   // exceptions:
X   //   1) We may have a CmdArgUsage or
X   //   2) CmdArg::is_dummy() may return TRUE
X   //
X   // Hence, before we can downcast a CmdArg * to a ShellCmdArg *
X   // we must first make sure of the following:
X   //   1) is_dummy returns FALSE and that
X   //   2) CmdArg::GIVEN is set (if a CmdArgUsage was given then we would have
X   //      already exited!).
X   //
X
Xclass  ShellCmdArg : public CmdArg {
Xpublic:
X   ShellCmdArg(char    * variable_name,
X               char      optchar,
X               char    * keyword,
X               char    * value,
X               char    * description,
X               unsigned  syntax_flags =CmdArg::isOPTVALREQ);
X
X   ShellCmdArg(char    * variable_name,
X               char      optchar,
X               char    * keyword,
X               char    * description,
X               unsigned  syntax_flags =CmdArg::isOPT);
X
X   ShellCmdArg(char    * variable_name,
X               char    * value,
X               char    * description,
X               unsigned  syntax_flags =CmdArg::isPOSVALREQ);
X
X   virtual ~ShellCmdArg(void);
X
X      // Return the name of this variable/array
X   const char *
X   name(void) const { return  sca_name; }
X
X      // Are we an array or a variable?
X   int
X   is_array(void) const;
X
X      // Return the variable portion
X   ShellVariable &
X   variable(void)  { return  *shell_variable; }
X
X      // Return the array portion
X   ShellArray &
X   array(void)  { return  *shell_array; }
X
X      // If we are a variable then the "set" member function sets the
X      // value of the variable, otherwise it appends to the list of
X      // values of the array
X      //
X   void
X   set(const char * value);
X
X   virtual  int
X   operator()(const char * & arg, CmdLine & cmd) = 0;
X
Xprivate:
X   ShellCmdArg(const ShellCmdArg & cp);
X
X   ShellCmdArg &
X   operator=(const ShellCmdArg & cp);
X
X   void
X   initialize(const char * name);
X
X   union { 
X      ShellVariable *  shell_variable;
X      ShellArray    *  shell_array;
X   } ;
X
X   char * sca_name;
X   char * sca_keyword;
X   char * sca_value;
X   char * sca_description;
X} ;
X
X#endif  /* _shell_arg_h */
X
END_OF_FILE
if test 2791 -ne `wc -c <'src/cmd/shell_arg.h'`; then
    echo shar: \"'src/cmd/shell_arg.h'\" unpacked with wrong size!
fi
# end of 'src/cmd/shell_arg.h'
fi
if test -f 'src/cmd/syntax.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/cmd/syntax.h'\"
else
echo shar: Extracting \"'src/cmd/syntax.h'\" \(1455 characters\)
sed "s/^X//" >'src/cmd/syntax.h' <<'END_OF_FILE'
X//------------------------------------------------------------------------
X// ^FILE: syntax.h - define an object to represent the syntax of a
X//                   command-line argument.
X//
X// ^DESCRIPTION:
X//    This file defines an object that parses and records the syntax of
X//    a command-line argument.
X//
X// ^HISTORY:
X//    04/29/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X//-^^---------------------------------------------------------------------
X
X#ifndef _syntax_h
X#define _syntax_h
X
X#include  "fsm.h"
X
Xclass  istream;
Xclass  ArgSyntax {
Xpublic:
X   ArgSyntax(void)
X      : arg_syntax(0), arg_char(0), arg_keyword(0), arg_value(0)
X      {}
X
X      // Return the syntax flags
X   unsigned
X   syntax(void) const { return  arg_syntax; }
X
X      // Return the option character
X   char
X   optchar(void) const { return  arg_char; }
X
X      // Return the keyword name
X   const char *
X   keyword(void) const { return  arg_keyword; }
X
X      // Return the value name
X   const char *
X   value(void) const { return  arg_value; }
X
X      // Extract the syntax (compile it) from an input stream
X   friend  istream &
X   operator>>(istream & is, ArgSyntax & arg);
X
Xprivate:
X   unsigned     arg_syntax ;
X   char         arg_char;
X   const char * arg_keyword;
X   const char * arg_value;
X
Xprivate:
X   int
X   parse_syntax(const char * syntax);
X
X   void
X   parse_value(const SyntaxFSM & fsm);
X
X   istream &
X   parse_flag(istream & is);
X} ;
X
X#endif  /* _syntax_h */
END_OF_FILE
if test 1455 -ne `wc -c <'src/cmd/syntax.h'`; then
    echo shar: \"'src/cmd/syntax.h'\" unpacked with wrong size!
fi
# end of 'src/cmd/syntax.h'
fi
if test ! -d 'src/lib' ; then
    echo shar: Creating directory \"'src/lib'\"
    mkdir 'src/lib'
fi
if test -f 'src/lib/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lib/Makefile'\"
else
echo shar: Extracting \"'src/lib/Makefile'\" \(3443 characters\)
sed "s/^X//" >'src/lib/Makefile' <<'END_OF_FILE'
X##########################################################################
X## ^FILE: Makefile - make file for the CmdLine C++ library
X##
X## ^DESCRIPTION:
X##    This is the makefile that is used to build and install the CmdLine
X##    library. In order to get CmdLine to build on your system you may
X##    need to change some of the "variables" mentioned below. You may also
X##    need to redefine some of the commands that are used.
X##
X## ^TARGETS:
X##    all     : make the library and the test program
X##    library : make the library
X##    test    : make the test program
X##    install : build and install the library and its include files
X##    clean   : remove all intermediate files generated by the build
X##    clobber : remove all files generated by the build
X##
X## ^VARIABLES:
X##    OS         : specify the host operating system (default=unix)
X##    STYLE      : specify the desired command-line syntax (default=unix)
X##    FLAG       : debugging/optimization flags to the compiler (default=-g)
X##    TESTDEFS   : #defines used for testing
X##    USRDEFS    : #defines used for building (default=unix)
X##    OPTIONS    : any other compiler flags to use
X##
X## ^HISTORY:
X##    04/10/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X###^^#####################################################################
X
Xinclude ../../Config.mk
X
X###
X# operating-system dependent stuff
X###
X# OSDEFS=$(DEF)$(OS) $(DEF)$(.UNIVERSE)_universe
XSTYLE=$(OS)
X
X###
X# compilation options
X###
XINCLUDES=$(INC)$(CURDIR)
XFLAG=$(OPT)
X# FLAG=$(DBG)
XTESTDEFS=
X# USRDEFS=$(DEF)DEBUG_CMDLINE
XDEFINES=$(OSDEFS) $(USRDEFS) $(TESTDEFS) $(DEF)$(STYLE)_style
XOPTIONS=
XCFLAGS=$(FLAG) $(INCLUDES) $(DEFINES) $(OPTIONS)
X
X###
X# libraries
X###
XLIBRARY=lib$(LIBNAME)$(LIBEXT)
X
X###
X# files used
X###
XOBJS=argiter$(OBJEXT) cmdarg$(OBJEXT) cmdargs$(OBJEXT) \
X   cmdline$(OBJEXT) dump$(OBJEXT)  fifolist$(OBJEXT) \
X   parse$(OBJEXT) patchlevel$(OBJEXT) private$(OBJEXT) \
X   strindent$(OBJEXT) $(STYLE)$(OBJEXT) usage$(OBJEXT)
X
X###
X# target dependencies
X###
Xall: library test
X
Xlibrary: $(LIBRARY)
X
Xtest: cmdtest$(EXECEXT)
X
Xcmdtest$(EXECEXT): cmdtest$(OBJEXT) $(OBJS)
X	$(CC) $(EXE)$@ cmdtest$(OBJEXT) $(LIBRARY)
X
X$(LIBRARY): $(OBJS)
X	$(AR) $@ $(OBJS)
X	$(RANLIB) $@
X
X###
X# maintenance dependencies
X###
Xinstall: $(LIBRARY) $(LIBDIR) $(INCDIR) cmdline.h cmdargs.h
X	-$(RM) $(LIBDIR)$(LIBRARY) $(INCDIR)cmdline.h $(INCDIR)cmdargs.h
X	$(CP) $(LIBRARY) $(LIBDIR)$(LIBRARY)
X	$(CP) cmdline.h $(INCDIR)cmdline.h
X	$(CP) cmdargs.h $(INCDIR)cmdargs.h
X
Xclean:
X	-$(RM) *$(OBJEXT) core .exrc *~ \#*\#
X
Xclobber: clean
X	-$(RM) *$(LIBEXT) cmdtest tags TAGS
X
X###
X# object dependencies
X###
Xargiter$(OBJEXT) : argiter$(CEXT) cmdline.h
X
Xcmdarg$(OBJEXT) : cmdarg$(CEXT) cmdline.h
X
Xcmdargs$(OBJEXT) : cmdargs$(CEXT) cmdargs.h cmdline.h exits.h fifolist.h
X
Xcmdline$(OBJEXT) : cmdline$(CEXT) cmdline.h cmdargs.h arglist.h fifolist.h \
X   states.h
X
Xcmdtest$(OBJEXT) : cmdtest$(CEXT) cmdargs.h cmdline.h
X
Xdump$(OBJEXT) : dump$(CEXT) cmdline.h arglist.h fifolist.h states.h
X
Xfifolist$(OBJEXT) : fifolist$(CEXT) cmdline.h fifolist.h
X
Xparse$(OBJEXT) : parse$(CEXT) exits.h states.h cmdline.h arglist.h \
X   fifolist.h
X
Xpatchlevel$(OBJEXT) : patchlevel$(CEXT) cmdline.h
X
Xprivate$(OBJEXT) : private$(CEXT) cmdline.h states.h arglist.h fifolist.h
X
Xstrindent$(OBJEXT) : strindent$(CEXT) cmdline.h
X
Xunix$(OBJEXT) : unix$(CEXT) exits.h cmdline.h states.h
X
Xusage$(OBJEXT) : usage$(CEXT) cmdline.h states.h arglist.h fifolist.h
END_OF_FILE
if test 3443 -ne `wc -c <'src/lib/Makefile'`; then
    echo shar: \"'src/lib/Makefile'\" unpacked with wrong size!
fi
# end of 'src/lib/Makefile'
fi
if test -f 'src/lib/arglist.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lib/arglist.h'\"
else
echo shar: Extracting \"'src/lib/arglist.h'\" \(834 characters\)
sed "s/^X//" >'src/lib/arglist.h' <<'END_OF_FILE'
X//------------------------------------------------------------------------
X// ^FILE: arglist.h - lists to hold CmdArgs
X//
X// ^DESCRIPTION:
X//   This file declares the types that are used by a CmdLine to hold the
X//   arguments associated with it.  What we do is keep a list of lists
X//   of CmdArgs. The first list is the arguments that were specified
X//   by the user/programmer, The second list is the list of default
X//   arguments for this command. Only two lists are used at present.
X//
X// ^HISTORY:
X//    03/21/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X//-^^---------------------------------------------------------------------
X
X#ifndef _arglist_h
X#define _arglist_h
X
X#include "fifolist.h"
X
Xclass CmdArg;
X
XDECLARE_FIFO_LIST(CmdArgList, CmdArg);
X
XDECLARE_FIFO_LIST(CmdArgListList, CmdArgList);
X
X#endif /* _arglist_h */
X
END_OF_FILE
if test 834 -ne `wc -c <'src/lib/arglist.h'`; then
    echo shar: \"'src/lib/arglist.h'\" unpacked with wrong size!
fi
# end of 'src/lib/arglist.h'
fi
if test -f 'src/lib/exits.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lib/exits.h'\"
else
echo shar: Extracting \"'src/lib/exits.h'\" \(1075 characters\)
sed "s/^X//" >'src/lib/exits.h' <<'END_OF_FILE'
X//------------------------------------------------------------------------
X// ^FILE: exits.h - define exit codes used by the CmdLine library
X//
X// ^DESCRIPTION:
X//    When we call exit(3C), we want to use a value that is appropriate
X//    for the operating system that we are on.  Here are the values
X//    that we need to define:
X//
X//       e_SUCCESS  -- no errors everything is fine
X//       e_USAGE    -- no errors but we didnt parse the command-line
X//                     because we saw a CmdArgUsage argument
X//       e_SYNTAX   -- a syntax error occurred
X//       e_INTERNAL -- an internal error occurred
X//
X// ^HISTORY:
X//    04/13/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X//-^^---------------------------------------------------------------------
X
X#ifndef e_SUCCESS
X
X#ifdef vms
X# include <ssdef.h>
X# define  e_SUCCESS   SS$_NORMAL
X# define  e_USAGE     SS$_NOTMODIFIED
X# define  e_SYNTAX    SS$_BADPRAM
X# define  e_INTERNAL  SS$_CANCEL
X#else
X# define  e_SUCCESS   0
X# define  e_USAGE     1
X# define  e_SYNTAX    2
X# define  e_INTERNAL  127
X#endif
X
X#endif
END_OF_FILE
if test 1075 -ne `wc -c <'src/lib/exits.h'`; then
    echo shar: \"'src/lib/exits.h'\" unpacked with wrong size!
fi
# end of 'src/lib/exits.h'
fi
if test -f 'src/lib/fifolist.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lib/fifolist.c'\"
else
echo shar: Extracting \"'src/lib/fifolist.c'\" \(3127 characters\)
sed "s/^X//" >'src/lib/fifolist.c' <<'END_OF_FILE'
X//------------------------------------------------------------------------
X// ^FILE: fifolist.c - implementation of FIFO linked lists
X//
X// ^DESCRIPTION:
X//    This file implements the classes declared in fifolist.h
X//
X// ^HISTORY:
X//    03/21/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X//-^^---------------------------------------------------------------------
X
X#include <stdlib.h>
X#include "cmdline.h"
X#include "fifolist.h"
X
X//------------------------------------------------------------- GenericFifoList
X
X   // Destructor
XGenericFifoList::~GenericFifoList(void) {
X   GenericFifoListNode * nd = head;
X   head = NULL;
X   while (nd) {
X      GenericFifoListNode * to_delete = nd;
X      nd = nd->next;
X      if (del_items)  delete  to_delete->contents;
X      delete  to_delete;
X   }
X}
X
X   // Add an item to the end
Xvoid
XGenericFifoList::add(void * item) {
X   if (item) {
X      GenericFifoListNode * nd = new GenericFifoListNode(NULL, item);
X      if (head == NULL) {
X         head = tail = nd;
X      } else {
X         tail->next = nd;
X         tail = nd;
X      }
X      ++num_items;
X      mod = 1;
X   }
X}
X
X   // Remove an item off the front
Xvoid *
XGenericFifoList::remove(void) {
X   if (head == NULL)  return  NULL;
X   GenericFifoListNode * nd = head;
X   void * result = head->contents;
X   head = head->next;
X   delete  nd;
X   --num_items;
X   mod = 1;
X   return  result;
X}
X
X//--------------------------------------------------------- GenericFifoListIter
X
XGenericFifoListIter::~GenericFifoListIter(void) {}
X
Xvoid *
XGenericFifoListIter::operator()(void) {
X   void * result = NULL;
X   if (current) {
X      result  = current->contents;
X      current = current->next;
X   }
X   return  result;
X}
X
X//-------------------------------------------------------- GenericFifoListArray
X
XGenericFifoListArray::~GenericFifoListArray(void) {}
X
Xvoid *
XGenericFifoListArray::operator[](unsigned  ndx) {
X   unsigned  max_index = count();
X   if (! max_index--)  return  NULL;     // check for underflow
X   if (ndx > max_index)  return  NULL;  // check for overflow
X
X   // if we want the first element -- just return the head
X   if (ndx == 0)  return  list.head->contents;
X
X   // if we want the last element -- just return the tail
X   if (ndx == max_index)  return  list.tail->contents;
X
X   // If we are going backward or stuff has been modified, then rewind
X   if ((ndx < index) || list.modified()) {
X      index = 0;
X      current = list.head;
X   }
X
X   // Skip from current to the desired element
X   while (index < ndx) {
X      current = current->next;
X      ++index;
X   }
X
X   return  current->contents;
X}
X
X//-------------------------------------------------------------------- FifoList
X
X#ifdef TEMPLATES
X
X   // Destructor
Xtemplate <class Type>
XFifoList<Type>::~FifoList(void) {
X   GenericFifoListNode * nd = head;
X   head = NULL;
X   while (nd) {
X      GenericFifoListNode * to_delete = nd;
X      nd = nd->next;
X      if (del_items)  delete (Type *)to_delete->contents;
X      delete  to_delete;
X   }
X}
X
Xtemplate <class Type>
XFifoListIter<Type>::~FifoListIter(void) {}
X
Xtemplate <class Type>
XFifoListArray<Type>::~FifoListArray(void) {}
X
X#endif
END_OF_FILE
if test 3127 -ne `wc -c <'src/lib/fifolist.c'`; then
    echo shar: \"'src/lib/fifolist.c'\" unpacked with wrong size!
fi
# end of 'src/lib/fifolist.c'
fi
if test -f 'src/lib/patchlevel.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lib/patchlevel.c'\"
else
echo shar: Extracting \"'src/lib/patchlevel.c'\" \(1335 characters\)
sed "s/^X//" >'src/lib/patchlevel.c' <<'END_OF_FILE'
X//------------------------------------------------------------------------
X// ^FILE: patchlevel.c - version specific information
X//
X// ^DESCRIPTION:
X//    This file contains all the version specific information of this
X//    particular release of the CmdLine library.  It also implements
X//    the static member functions of a CmdLine that return version
X//    specific information.
X//
X// ^HISTORY:
X//    04/03/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X//-^^---------------------------------------------------------------------
X
X#include "cmdline.h"
X
X   // Record the version-identifier for this project.
X   //
X   // My source-code management system lets me use a symbolic-name
X   // to identify a given configuration of the project. From this
X   // symbolic-name I can easily find out the exact version of each
X   // file that makes up this version of the project.
X   //
Xstatic const char ident[] =
X   "@(#)SMS  task: cmdline-1.00" ;
X
X
X   // Release and patchlevel information
X#define  CMDLINE_RELEASE     1
X#define  CMDLINE_PATCHLEVEL  0
X#define  CMDLINE_IDENT       "@(#)CmdLine	1.00"
X
Xunsigned
XCmdLine::release(void)  { return  CMDLINE_RELEASE; }
X
Xunsigned
XCmdLine::patchlevel(void)  { return  CMDLINE_PATCHLEVEL; }
X
Xconst char *
XCmdLine::ident(void) {
X   static const char Ident[] = CMDLINE_IDENT ;
X
X   return  Ident;
X}
X
END_OF_FILE
if test 1335 -ne `wc -c <'src/lib/patchlevel.c'`; then
    echo shar: \"'src/lib/patchlevel.c'\" unpacked with wrong size!
fi
# end of 'src/lib/patchlevel.c'
fi
if test -f 'src/lib/states.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lib/states.h'\"
else
echo shar: Extracting \"'src/lib/states.h'\" \(2443 characters\)
sed "s/^X//" >'src/lib/states.h' <<'END_OF_FILE'
X//------------------------------------------------------------------------
X// ^FILE: states.h - state definitions for the CmdLine library
X//
X// ^DESCRIPTION:
X//     This file contains the definitions for the various values of the
X//  state and parse-state of a command-line object. It also contains
X//  any definitions that are dependent upon the command-line syntax
X//  (i.e. unix_style or vms_style).
X//
X// ^HISTORY:
X//    03/26/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X//-^^---------------------------------------------------------------------
X
X#ifndef _states_h
X#define _states_h
X
X#include "cmdline.h"
X
X#ifdef unix_style
X   // Default command-flags for a unix-command
X   static const unsigned DEFAULT_CMDFLAGS = CmdLine::OPTS_FIRST ;
X#endif
X
X#ifdef vms_style
X   // Default command-flags for a vms-command
X   static const unsigned DEFAULT_CMDFLAGS = CmdLine::TEMP ;
X#endif
X
X//
X// cmd_state_t -- Define the bitmasks used to record the command state
X//
Xenum cmd_state_t {
X   cmd_END_OF_OPTIONS  = 0x01,  // no more options/keywords?
X   cmd_OPTIONS_USED    = 0x02,  // were options used on cmdline?
X   cmd_KEYWORDS_USED   = 0x04,  // were keywords used on cmdline?
X   cmd_GUESSING        = 0x08,  // are we currently trying to guess?
X} ;
X
X//
X// cmd_parse_state_t -- Define the possible parse-states for the command
X//
X// We use "START_STATE" to reset the state. Only one of the NEED*
X// states may be set at a time. For any of the NEED* states, TOK_REQUIRED
X// may or may not be set. TOK_REQUIRED should NOT be set if none of the
X// NEED* states is set.
X//
X// Note: we have the "states" set up so that one can test for WANT or NEED
X// by a bitwise & with a WANT flag. One can test if the particular "WANT"
X// is truly "NEEDED" by a bitwise & with the TOK_REQUIRED_FLAG. For
X// convenience, each WANT_XXX that is truly REQUIRED may also be
X// represented by NEED_XXX.
X//
Xenum cmd_parse_state_t {
X   cmd_START_STATE  = 0x00,  // start-state (this MUST be 0)
X
X   cmd_TOK_REQUIRED = 0x01,  // is the "wanted" token required?
X
X   cmd_WANT_VAL     = 0x02,  // are we expecting a value?
X   cmd_NEED_VAL     = (cmd_WANT_VAL | cmd_TOK_REQUIRED),
X
X#ifdef vms_style
X   cmd_WANT_VALSEP  = 0x04,  // are we expecting ':' or '='
X   cmd_NEED_VALSEP  = (cmd_WANT_VALSEP | cmd_TOK_REQUIRED),
X
X   cmd_WANT_LISTSEP = 0x08,  // are we expecting ',' or '+'
X   cmd_NEED_LISTSEP = (cmd_WANT_LISTSEP | cmd_TOK_REQUIRED),
X#endif
X} ;
X
X
X#endif /* _states_h */
END_OF_FILE
if test 2443 -ne `wc -c <'src/lib/states.h'`; then
    echo shar: \"'src/lib/states.h'\" unpacked with wrong size!
fi
# end of 'src/lib/states.h'
fi
echo shar: End of archive 1 \(of 7\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
