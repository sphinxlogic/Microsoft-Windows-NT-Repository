Newsgroups: comp.sources.misc
From: zip-bugs@cs.ucla.edu (Info-ZIP group)
Subject:  v31i096:  zip19 - Info-ZIP portable Zip, version 1.9, Part04/11
Message-ID: <1992Aug23.064628.29121@sparky.imd.sterling.com>
X-Md4-Signature: fb99faa1e8171758728591c8da715b75
Date: Sun, 23 Aug 1992 06:46:28 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: zip-bugs@cs.ucla.edu (Info-ZIP group)
Posting-number: Volume 31, Issue 96
Archive-name: zip19/part04
Supersedes: zip: Volume 23, Issue 88-96
Environment: UNIX, VMS, OS/2, MS-DOS, MACINTOSH, WIN-NT, LINUX, MINIX, XOS, !AMIGA, ATARI, symlink, SGI, DEC, Cray, Convex, Amdahl, Sun, PC

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  mac/macstat.h zip.c zip.doc
# Wrapped by kent@sparky on Sun Aug 23 01:00:44 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 11)."'
if test -f 'mac/macstat.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/macstat.h'\"
else
  echo shar: Extracting \"'mac/macstat.h'\" \(974 characters\)
  sed "s/^X//" >'mac/macstat.h' <<'END_OF_FILE'
X/*****************************************************************
X *
X *                stat.h
X *
X *****************************************************************/
X
X#include <time.h>
Xextern int macstat(char *path, struct stat *buf, short nVRefNum, long lDirID );
Xtypedef long dev_t;
Xtypedef long ino_t;
Xtypedef long off_t;
X
Xstruct stat {
X    dev_t    st_dev;
X    ino_t    st_ino;
X    unsigned short    st_mode;
X    short    st_nlink;
X    short    st_uid;
X    short    st_gid;
X    dev_t    st_rdev;
X    off_t    st_size;
X    time_t   st_atime, st_mtime, st_ctime;
X    long     st_blksize;
X    long     st_blocks;
X};
X
X#define S_IFMT     0xF000
X#define S_IFIFO    0x1000
X#define S_IFCHR    0x2000
X#define S_IFDIR    0x4000
X#define S_IFBLK    0x6000
X#define S_IFREG    0x8000
X#define S_IFLNK    0xA000
X#define S_IFSOCK   0xC000
X#define S_ISUID    0x800
X#define S_ISGID    0x400
X#define S_ISVTX    0x200
X#define S_IREAD    0x100
X#define S_IWRITE   0x80
X#define S_IEXEC    0x40
END_OF_FILE
  if test 974 -ne `wc -c <'mac/macstat.h'`; then
    echo shar: \"'mac/macstat.h'\" unpacked with wrong size!
  fi
  # end of 'mac/macstat.h'
fi
if test -f 'zip.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zip.c'\"
else
  echo shar: Extracting \"'zip.c'\" \(32880 characters\)
  sed "s/^X//" >'zip.c' <<'END_OF_FILE'
X/*
X
X Copyright (C) 1990-1992 Mark Adler, Richard B. Wales, Jean-loup Gailly,
X Kai Uwe Rommel and Igor Mandrichenko.
X Permission is granted to any individual or institution to use, copy, or
X redistribute this software so long as all of the original files are included
X unmodified, that it is not sold for profit, and that this copyright notice
X is retained.
X
X*/
X
X/*
X *  zip.c by Mark Adler.
X */
X
X#include "revision.h"
X#include "zip.h"
X#ifdef VMS
X#  include "VMSmunch.h"
X#  define echon() echo(1)
X#endif
X#include <signal.h>
X
X#ifdef MACOS
X#  include <console.h>
X#endif
X
X#define PWLEN 80        /* Input buffer size for reading encryption key */
X#define MAXCOM 256      /* Maximum one-line comment size */
X
X
X/* Local option flags */
X#define DELETE  0
X#define ADD     1
X#define UPDATE  2
X#define FRESHEN 3
Xlocal int action = ADD; /* one of ADD, UPDATE, FRESHEN, or DELETE */
Xlocal int comadd = 0;   /* 1=add comments for new files */
Xlocal int zipedit = 0;  /* 1=edit zip comment and all file comments */
Xlocal int dispose = 0;  /* 1=remove files after put in zip file */
Xlocal int latest = 0;   /* 1=set zip file time to time of latest file */
Xlocal ulg before = 0;   /* 0=ignore, else exclude files before this time */
X
X
X/* Temporary zip file name and file pointer */
Xlocal char *tempzip;
Xlocal FILE *tempzf;
X
X
X/* Local functions */
X#ifdef PROTO
X   local void freeup(void);
X   local void leave(int);
X   local void handler(int);
X   local void license(void);
X   local void help(void);
X   local void zipstdout(void);
X   void main(int, char **);
X   local int count_args(char *s);
X   local void envargs(int *Pargc, char ***Pargv, char *envstr);
X#endif /* PROTO */
X
X
X
Xlocal void freeup()
X/* Free all allocations in the found list and the zfiles list */
X{
X  struct flist far *f;  /* steps through found list */
X  struct zlist far *z;  /* pointer to next entry in zfiles list */
X
X  for (f = found; f != NULL; f = fexpel(f))
X    ;
X  while (zfiles != NULL)
X  {
X    z = zfiles->nxt;
X    free((voidp *)(zfiles->name));
X    free((voidp *)(zfiles->zname));
X    if (zfiles->ext)
X      free((voidp *)(zfiles->extra));
X    if (zfiles->cext && zfiles->cextra != zfiles->extra)
X      free((voidp *)(zfiles->cextra));
X    if (zfiles->com)
X      free((voidp *)(zfiles->comment));
X    farfree((voidp far *)zfiles);
X    zfiles = z;
X    zcount--;
X  }
X}
X
X
Xlocal void leave(e)
Xint e;                  /* exit code */
X/* Process -o and -m options (if specified), free up malloc'ed stuff, and
X   exit with the code e. */
X{
X  int r;                /* return value from trash() */
X  ulg t;                /* latest time in zip file */
X  struct zlist far *z;  /* pointer into zfile list */
X
X  /* If latest, set time to zip file to latest file in zip file */
X  if (latest && strcmp(zipfile, "-"))
X  {
X    diag("changing time of zip file to time of latest file in it");
X    /* find latest time in zip file */
X    if (zfiles == NULL)
X       warn("zip file is empty, can't make it as old as latest entry", "");
X    else {
X      t = zfiles->tim;
X      for (z = zfiles->nxt; z != NULL; z = z->nxt)
X        if (t < z->tim)
X          t = z->tim;
X      /* set modified time of zip file to that time */
X      stamp(zipfile, t);
X    }
X  }
X  if (tempath != NULL)
X  {
X    free((voidp *)tempath);
X    tempath = NULL;
X  }
X  if (zipfile != NULL)
X  {
X    free((voidp *)zipfile);
X    zipfile = NULL;
X  }
X
X
X  /* If dispose, delete all files in the zfiles list that are marked */
X  if (dispose)
X  {
X    diag("deleting files that were added to zip file");
X    if ((r = trash()) != ZE_OK)
X      err(r, "was deleting moved files and directories");
X  }
X
X
X  /* Done! */
X  freeup();
X#ifdef VMS
X  exit(0);
X#else /* !VMS */
X  exit(e);
X#endif /* ?VMS */
X}
X
X
Xvoid err(c, h)
Xint c;                  /* error code from the ZE_ class */
Xchar *h;                /* message about how it happened */
X/* Issue a message for the error, clean up files and memory, and exit. */
X{
X  static int error_level;
X  if (error_level++ > 0) exit(0);  /* avoid recursive err() */
X
X  if (PERR(c))
X    perror("zip error");
X  fprintf(stderr, "zip error: %s (%s)\n", errors[c-1], h);
X  if (tempzip != NULL)
X  {
X    if (tempzip != zipfile) {
X      if (tempzf != NULL)
X        fclose(tempzf);
X#ifndef DEBUG
X      destroy(tempzip);
X#endif
X      free((voidp *)tempzip);
X    } else {
X      /* -g option, attempt to restore the old file */
X      int k = 0;                        /* keep count for end header */
X      ulg cb = cenbeg;                  /* get start of central */
X      struct zlist far *z;  /* steps through zfiles linked list */
X
X      fprintf(stderr, "attempting to restore %s to its previous state\n",
X         zipfile);
X      fseek(tempzf, cenbeg, SEEK_SET);
X      tempzn = cenbeg;
X      for (z = zfiles; z != NULL; z = z->nxt)
X      {
X        putcentral(z, tempzf);
X        tempzn += 4 + CENHEAD + z->nam + z->cext + z->com;
X        k++;
X      }
X      putend(k, tempzn - cb, cb, zcomlen, zcomment, tempzf);
X      tempzf = NULL;
X      fclose(tempzf);
X    }
X  }
X  if (key != NULL)
X    free((voidp *)key);
X  if (tempath != NULL)
X    free((voidp *)tempath);
X  if (zipfile != NULL)
X    free((voidp *)zipfile);
X  freeup();
X#ifdef VMS
X  c = 0;
X#endif
X  exit(c);
X}
X
X
Xvoid error(h)
X  char *h;
X/* Internal error, should never happen */
X{
X  err(ZE_LOGIC, h);
X}
X
Xlocal void handler(s)
Xint s;                  /* signal number (ignored) */
X/* Upon getting a user interrupt, turn echo back on for tty and abort
X   cleanly using err(). */
X{
X#ifndef MSDOS
X# ifdef CRYPT
X   echon();
X# endif
X  putc('\n', stderr);
X#endif /* !MSDOS */
X  err(ZE_ABORT, "aborting");
X  s++;                                  /* keep some compilers happy */
X}
X
X
Xvoid warn(a, b)
Xchar *a, *b;            /* message strings juxtaposed in output */
X/* Print a warning message to stderr and return. */
X{
X  fprintf(stderr, "zip warning: %s%s\n", a, b);
X}
X
X
Xlocal void license()
X/* Print license information to stdout. */
X{
X  extent i;             /* counter for copyright array */
X
X  for (i = 0; i < sizeof(copyright)/sizeof(char *); i++) {
X    printf(copyright[i], "zip");
X    putchar('\n');
X  }
X  for (i = 0; i < sizeof(disclaimer)/sizeof(char *); i++)
X    puts(disclaimer[i]);
X}
X
X
Xlocal void help()
X/* Print help (along with license info) to stdout. */
X{
X  extent i;             /* counter for help array */
X
X  /* help array */
X  static char *text[] = {
X"",
X"Zip %d.%d (%s). Usage:",
X"zip [-options] [-b path] [-t mmddyy] [-n suffixes] [zipfile list] [-x list]",
X"  The default action is to add or replace zipfile entries from list, which",
X"  can include the special name - to compress standard input.",
X"  If zipfile and list are ommitted, zip compresses stdin to stdout.",
X"  -f   freshen: only changed files  -u   update: only changed or new files",
X"  -d   delete entries in zipfile    -m   move into zipfile (delete files)",
X"  -k   simulate PKZIP made zipfile  -g   allow growing existing zipfile",
X"  -h   show this help               -L   show software license",
X"  -r   recurse into directories     -j   junk (don't record) directory names",
X"  -0   store only                   -l   translate end-of-line",
X"  -1   compress faster              -9   compress better",
X"  -q   quiet operation              -n   don't compress these suffixes",
X"  -c   add one-line comments        -z   add zipfile comment",
X"  -b   use \"path\" for temp files    -t   only do files after \"mmddyy\"",
X"  -@   read names from stdin        -o   make zipfile as old as latest entry",
X#ifdef CRYPT
X"  -e   encrypt  (-ee verify key)",
X#endif
X#ifdef VMS
X"  -w   append the VMS version number to the name stored in the zip file",
X"  -V   save VMS file attributes",
X#endif /* VMS */
X#ifdef OS2
X"  -E   use the .LONGNAME Extended attribute (if found) as filename",
X#endif /* OS2 */
X#ifdef S_IFLNK
X"  -y   store symbolic links as the link instead of the referenced file",
X#endif /* !S_IFLNK */
X"  -x   exclude the names that follow from those operated on"
X  };
X
X  for (i = 0; i < sizeof(copyright)/sizeof(char *); i++)
X  {
X    printf(copyright[i], "zip");
X    putchar('\n');
X  }
X  for (i = 0; i < sizeof(text)/sizeof(char *); i++)
X  {
X    printf(text[i], REVISION / 10, REVISION % 10, REVDATE);
X    putchar('\n');
X  }
X}
X
X
X/* Do command line expansion for MSDOS and VMS */
X#if defined(MSVMS) && !defined(__GO32__)
X#  define PROCNAME(n) (action==ADD||action==UPDATE?wild(n):procname(n))
X#else /* !MSVMS */
X#  define PROCNAME(n) procname(n)
X#endif /* ?MSVMS */
X
Xlocal void zipstdout()
X/* setup for writing zip file on stdout */
X{
X  int r;
X  mesg = stderr;
X  if (isatty(1))
X    err(ZE_PARMS, "no zip file provided");
X  if ((zipfile = malloc(4)) == NULL)
X    err(ZE_MEM, "was processing arguments");
X  strcpy(zipfile, "-");
X  if ((r = readzipfile()) != ZE_OK)
X    err(r, zipfile);
X}
X
X
Xvoid main(argc, argv)
Xint argc;               /* number of tokens in command line */
Xchar **argv;            /* command line tokens */
X/* Add, update, freshen, or delete zip entries in a zip file.  See the
X   command help in help() above. */
X{
X  int a;                /* attributes of zip file */
X  ulg c;                /* start of central directory */
X  int d;                /* true if just adding to a zip file */
X  char *e;              /* malloc'd comment buffer */
X  struct flist far *f;  /* steps through found linked list */
X  int i;                /* arg counter, root directory flag */
X  int k;                /* next argument type, marked counter,
X                           comment size, entry count */
X  ulg n;                /* total of entry len's */
X  int o;                /* true if there were any ZE_OPEN errors */
X  char *p;              /* steps through option arguments */
X  char *pp;             /* temporary pointer */
X  int r;                /* temporary variable */
X  ulg t;                /* file time, length of central directory */
X  struct zlist far *v;  /* temporary variable */
X  struct zlist far * far *w;    /* pointer to last link in zfiles list */
X  FILE *x, *y;          /* input and output zip files */
X  struct zlist far *z;  /* steps through zfiles linked list */
X  char *zipbuf;         /* stdio buffer for the zip file */
X
X  mesg = (FILE *) stdout; /* cannot be made at link time for VMS */
X  init_upper();           /* build case map table */
X
X#ifdef MACOS
X   argc = ccommand(&argv);
X#endif
X
X  /* Process arguments */
X  diag("processing arguments");
X  if (argc == 1 && isatty(1))
X  {
X    help();
X    exit(0);
X  }
X  envargs(&argc, &argv, "ZIPOPT"); /* get options from environment */
X
X  zipfile = tempzip = NULL;
X  tempzf = NULL;
X  d = 0;                        /* disallow adding to a zip file */
X  signal(SIGINT, handler);
X  signal(SIGTERM, handler);
X  k = 0;                        /* Next non-option argument type */
X  for (i = 1; i < argc; i++)
X  {
X    if (argv[i][0] == '-')
X      if (argv[i][1])
X        for (p = argv[i]+1; *p; p++)
X          switch(*p)
X          {
X            case '0':
X              method = STORE; level = 0; break;
X            case '1':  case '2':  case '3':  case '4':
X            case '5':  case '6':  case '7':  case '8':  case '9':
X                        /* Set the compression efficacy */
X              level = *p - '0';  break;
X            case 'b':   /* Specify path for temporary file */
X              if (k != 0)
X                err(ZE_PARMS, "use -b before zip file name");
X              else
X                k = 1;          /* Next non-option is path */
X              break;
X            case 'c':   /* Add comments for new files in zip file */
X              comadd = 1;  break;
X            case 'd':   /* Delete files from zip file */
X              if (action != ADD)
X                err(ZE_PARMS, "specify just one action");
X              action = DELETE;
X              break;
X#ifdef CRYPT
X            case 'e':   /* Encrypt */
X              e = key == NULL ? (char *)NULL : key;
X              if ((key = malloc(PWLEN+1)) == NULL)
X                err(ZE_MEM, "was getting encryption password");
X              if (getp(e == NULL ? "Enter password: " : "Verify password: ",
X                       key, PWLEN+1) == NULL)
X                err(ZE_PARMS, "stderr is not a tty");
X              if (e != NULL)
X              {
X                r = strcmp(key, e);
X                free((voidp *)e);
X                if (r)
X                  err(ZE_PARMS, "password not verified");
X              }
X              latest = 1;               /* to make breaking the code harder */
X              break;
X#endif /* CRYPT */
X            case 'f':   /* Freshen zip file--overwrite only */
X              if (action != ADD)
X                err(ZE_PARMS, "specify just one action");
X              action = FRESHEN;
X              break;
X            case 'g':   /* Allow appending to a zip file */
X              d = 1;  break;
X            case 'h': case 'H': case '?':  /* Help */
X              help();
X              leave(ZE_OK);
X            case 'j':   /* Junk directory names */
X              pathput = 0;  break;
X            case 'k':   /* Make entries using DOS names (k for Katz) */
X              dosify = 1;  break;
X            case 'l':   /* Translate end-of-line */
X              translate_eol = 1; break;
X            case 'L':   /* Show license, version */
X              license();
X              leave(ZE_OK);
X            case 'm':   /* Delete files added or updated in zip file */
X              dispose = 1;  break;
X            case 'n':   /* Don't compress files with a special suffix */
X              special = NULL;
X              break;
X            case 'o':   /* Set zip file time to time of latest file in it */
X              latest = 1;  break;
X            case 'p':   /* Store path with name */
X              break;            /* (do nothing as annoyance avoidance) */
X            case 'q':   /* Quiet operation */
X              noisy = 0;  break;
X            case 'r':   /* Recurse into subdirectories */
X              recurse = 1;  break;
X            case 't':   /* Exclude files earlier than specified date */
X              if (before)
X                err(ZE_PARMS, "can only have one -t");
X              k = 2;  break;
X            case 'u':   /* Update zip file--overwrite only if newer */
X              if (action != ADD)
X                err(ZE_PARMS, "specify just one action");
X              action = UPDATE;
X              break;
X            case 'v':   /* Mention oddities in zip file structure */
X              verbose++;
X              break;
X#ifdef VMS
X            case 'w':   /* Append the VMS version number */
X              vmsver = 1;  break;
X            case 'V':   /* Store in VMS format */
X              vms_native = 1; break;
X#endif /* VMS */
X            case 'x':   /* Exclude following files */
X              if (k != 4 &&
X                  (k != 3 || (action != UPDATE && action != FRESHEN)))
X                err(ZE_PARMS, "nothing to exclude (-x) from");
X              if (k == 3)       /* must be -u or -f */
X                for (z = zfiles; z != NULL; z = z->nxt)
X                  z->mark = 1;  /* mark all of them */
X              k = 5;
X              if ((r = exclude()) != ZE_OK)
X                if (r == ZE_PARMS)
X                  err(r, "cannot repeat names in zip file");
X                else
X                  err(r, "was processing list of files");
X              break;
X#ifdef S_IFLNK
X            case 'y':   /* Store symbolic links as such */
X              linkput = 1;  break;
X#endif /* S_IFLNK */
X            case 'z':   /* Edit zip file comment */
X              zipedit = 1;  break;
X            case '@':   /* read file names from stdin */
X              while ((pp = getnam(errbuf)) != NULL)
X              {
X                if ((r = PROCNAME(pp)) != ZE_OK)
X                  if (r == ZE_MISS)
X                    warn("name not matched: ", pp);
X                  else
X                    err(r, pp);
X              }
X              break;
X#ifdef OS2
X            case 'E':
X              /* use the .LONGNAME EA (if any) as the file's name. */
X              use_longname_ea = 1;
X              break;
X#endif
X            default:
X            {
X              sprintf(errbuf, "no such option: %c", *p);
X              err(ZE_PARMS, errbuf);
X            }
X          }
X      else              /* just a dash */
X        switch (k)
X        {
X        case 0:
X          zipstdout();
X          k = 3;
X          break;
X        case 1:
X          err(ZE_PARMS, "invalid path");
X          break;
X        case 2:
X          err(ZE_PARMS, "invalid time");
X          break;
X        case 3:  case 4:  case 5:
X          if ((r = PROCNAME(argv[i])) != ZE_OK)
X            if (r == ZE_MISS)
X              warn("name not matched: ", argv[i]);
X            else
X              err(r, argv[i]);
X          if (k == 3)
X            k = 4;
X        }
X    else                /* not an option */
X    {
X      if (special == NULL)
X        special = argv[i];
X      else
X        switch (k)
X      {
X        case 0:
X          if ((zipfile = ziptyp(argv[i])) == NULL)
X            err(ZE_MEM, "was processing arguments");
X          if ((r = readzipfile()) != ZE_OK)
X            err(r, zipfile);
X          k = 3;
X          break;
X        case 1:
X          if ((tempath = malloc(strlen(argv[i]) + 1)) == NULL)
X            err(ZE_MEM, "was processing arguments");
X          strcpy(tempath, argv[i]);
X          k = 0;
X          break;
X        case 2:
X        {
X          int yy, mm, dd;       /* results of sscanf() */
X
X          if (sscanf(argv[i], "%2d%2d%2d", &mm, &dd, &yy) != 3 ||
X              mm < 1 || mm > 12 || dd < 1 || dd > 31)
X            err(ZE_PARMS, "invalid date entered for -t option");
X          before = dostime(yy + (yy < 80 ? 2000 : 1900), mm, dd, 0, 0, 0);
X          k = 0;
X          break;
X        }
X        case 3:  case 4:  case 5:
X          if ((r = PROCNAME(argv[i])) != ZE_OK)
X            if (r == ZE_MISS)
X              warn("name not matched: ", argv[i]);
X            else
X              err(r, argv[i]);
X          if (k == 3)
X            k = 4;
X      }
X    }
X  }
X  if (k < 3) {               /* zip used as filter */
X    zipstdout();
X    if ((r = procname("-")) != ZE_OK)
X      if (r == ZE_MISS)
X        warn("name not matched: ", "-");
X      else
X        err(r, "-");
X    k = 4;
X  }
X
X  if (k != 5)                   /* Clean up selections */
X  {
X    if (k == 3 && (action == UPDATE || action == FRESHEN))
X      for (z = zfiles; z != NULL; z = z->nxt)
X        z->mark = 1;                    /* if -u or -f with no args, do all */
X    if ((r = exclude()) != ZE_OK)       /* remove duplicates in found list */
X      if (r == ZE_PARMS)
X        err(r, "cannot repeat names in zip file");
X      else
X        err(r, "was processing list of files");
X  }
X  if (zcount)
X    free((voidp *)zsort);
X
X  /* Check option combinations */
X  if (action == DELETE && (method != BEST || dispose || recurse ||
X      key != NULL || comadd || zipedit))
X    err(ZE_PARMS, "invalid option(s) used with -d");
X  if (linkput && dosify)
X    err(ZE_PARMS, "can't use -y with -k");
X  if ((action != ADD || d) && !strcmp(zipfile, "-"))
X    err(ZE_PARMS, "can't use -d,-f,-u or -g on standard output");
X#ifdef VMS
X  if (vms_native && translate_eol)
X    err(ZE_PARMS, "can't use -V with -l");
X#endif
X  if (zcount == 0 && (action != ADD || d))
X    warn(zipfile, " not found or empty");
X
X
X  /* If -b not specified, make temporary path the same as the zip file */
X#ifdef MSDOS
X  if (tempath == NULL && ((p = strrchr(zipfile, '/')) != NULL ||
X                          (p = strrchr(zipfile, '\\')) != NULL ||
X                          (p = strrchr(zipfile, ':')) != NULL))
X  {
X    if (*p == ':')
X      p++;
X#else /* !MSDOS */
X  if (tempath == NULL && (p = strrchr(zipfile, '/')) != NULL)
X  {
X#endif /* ?MSDOS */
X    if ((tempath = malloc((int)(p - zipfile) + 1)) == NULL)
X      err(ZE_MEM, "was processing arguments");
X    r = *p;  *p = 0;
X    strcpy(tempath, zipfile);
X    *p = (char)r;
X  }
X
X  /* For each marked entry, if not deleting, check if it exists, and if
X     updating or freshening, compare date with entry in old zip file.
X     Unmark if it doesn't exist or is too old, else update marked count. */
X  diag("stating marked entries");
X  k = 0;                        /* Initialize marked count */
X  for (z = zfiles; z != NULL; z = z->nxt)
X    if (z->mark)
X      if (action != DELETE &&
X                ((t = filetime(z->name, (ulg *)NULL, (long *)NULL)) == 0 ||
X                 t < before ||
X                 ((action == UPDATE || action == FRESHEN) && t <= z->tim)))
X      {
X        z->mark = 0;
X        z->trash = t && t >= before;    /* delete if -um or -fm */
X        if (verbose)
X          fprintf(mesg, "zip diagnostic: %s %s\n", z->name,
X                 z->trash ? "up to date" : "missing or early");
X      }
X      else
X        k++;
X
X
X  /* Remove entries from found list that do not exist or are too old */
X  diag("stating new entries");
X  for (f = found; f != NULL;)
X    if (action == DELETE || action == FRESHEN ||
X        (t = filetime(f->name, (ulg *)NULL, (long *)NULL)) == 0 ||
X        t < before || (namecmp(f->name, zipfile) == 0 && strcmp(zipfile, "-")))
X      f = fexpel(f);
X    else
X      f = f->nxt;
X
X  /* Make sure there's something left to do */
X  if (k == 0 && found == NULL && !(zfiles != NULL && (latest || zipedit)))
X    if (action == UPDATE || action == FRESHEN)
X      leave(ZE_OK);
X    else if (zfiles == NULL && latest)
X      err(ZE_NAME, zipfile);
X    else
X      err(ZE_NONE, zipfile);
X  d = (d && k == 0 && (zipbeg || zfiles != NULL)); /* d true if appending */
X
X
X  /* Before we get carried away, make sure zip file is writeable */
X  if (strcmp(zipfile, "-"))
X  {
X    x = zfiles == NULL && zipbeg == 0 ? fopen(zipfile, FOPW) : 
X                                        fopen(zipfile, FOPM);
X    /* Note: FOPW and FOPM expand to several parameters for VMS */
X    if (x == NULL)
X      err(ZE_CREAT, zipfile);
X    fclose(x);
X    a = getfileattr(zipfile);
X    if (zfiles == NULL && zipbeg == 0)
X      destroy(zipfile);
X  }
X  else
X    a = 0;
X
X
X  /* Open zip file and temporary output file */
X  diag("opening zip file and creating temporary zip file");
X  x = NULL;
X  tempzn = 0;
X  if (strcmp(zipfile, "-") == 0)
X  {
X#ifdef MSDOS
X    /* Set stdout mode to binary for MSDOS systems */
X    setmode(fileno(stdout), O_BINARY);
X    tempzf = y = fdopen(fileno(stdout), FOPW);
X#else
X    tempzf = y = stdout;
X#endif
X    tempzip = "-";
X  }
X  else if (d) /* d true if just appending (-g) */
X  {
X    if ((y = fopen(zipfile, FOPM)) == NULL)
X      err(ZE_NAME, zipfile);
X    tempzip = zipfile;
X    tempzf = y;
X    if (fseek(y, cenbeg, SEEK_SET))
X      err(ferror(y) ? ZE_READ : ZE_EOF, zipfile);
X    tempzn = cenbeg;
X  }
X  else
X  {
X    if ((zfiles != NULL || zipbeg) && (x = fopen(zipfile, FOPR_EX)) == NULL)
X      err(ZE_NAME, zipfile);
X    if ((tempzip = tempname(zipfile)) == NULL)
X      err(ZE_MEM, tempzip);
X    if ((tempzf = y = fopen(tempzip, FOPW)) == NULL)
X      err(ZE_TEMP, tempzip);
X    if (zipbeg && (r = fcopy(x, y, zipbeg)) != ZE_OK)
X      err(r, r == ZE_TEMP ? tempzip : zipfile);
X    tempzn = zipbeg;
X  }
X#ifndef VMS
X  /* Use large buffer to speed up stdio: */
X  zipbuf = (char *)malloc(ZBSZ);
X  if (zipbuf == NULL)
X    err(ZE_MEM, tempzip);
X# ifdef _IOFBF
X  setvbuf(y, zipbuf, _IOFBF, ZBSZ);
X# else
X  setbuf(y, zipbuf);
X# endif /* _IOBUF */
X#endif /* VMS */
X  o = 0;                                /* no ZE_OPEN errors yet */
X
X
X  /* Process zip file, updating marked files */
X  if (zfiles != NULL)
X    diag("going through old zip file");
X  w = &zfiles;
X  while ((z = *w) != NULL)
X    if (z->mark)
X    {
X      /* if not deleting, zip it up */
X      if (action != DELETE)
X      {
X        if (noisy)
X        {
X          fprintf(mesg, "updating %s", z->zname);
X          fflush(mesg);
X        }
X        if ((r = zipup(z, y)) != ZE_OK && r != ZE_OPEN)
X        {
X          if (noisy)
X          {
X            putc('\n', mesg);
X            fflush(mesg);
X          }
X          sprintf(errbuf, "was zipping %s", z->name);
X          err(r, errbuf);
X        }
X        if (r == ZE_OPEN)
X        {
X          o = 1;
X          if (noisy)
X          {
X            putc('\n', mesg);
X            fflush(mesg);
X          }
X          perror("zip warning");
X          warn("could not open for reading: ", z->name);
X          warn("will just copy entry over: ", z->zname);
X          if ((r = zipcopy(z, x, y)) != ZE_OK)
X          {
X            sprintf(errbuf, "was copying %s", z->zname);
X            err(r, errbuf);
X          }
X          z->mark = 0;
X        }
X        w = &z->nxt;
X      }
X      else
X      {
X        if (noisy)
X        {
X          fprintf(mesg, "deleting %s\n", z->zname);
X          fflush(mesg);
X        }
X        v = z->nxt;                     /* delete entry from list */
X        free((voidp *)(z->name));
X        free((voidp *)(z->zname));
X        if (z->ext)
X          free((voidp *)(z->extra));
X        if (z->cext && z->cextra != z->extra)
X          free((voidp *)(z->cextra));
X        if (z->com)
X          free((voidp *)(z->comment));
X        farfree((voidp far *)z);
X        *w = v;
X        zcount--;
X      }
X    }
X    else
X    {
X      /* copy the original entry verbatim */
X      if (!d && (r = zipcopy(z, x, y)) != ZE_OK)
X      {
X        sprintf(errbuf, "was copying %s", z->zname);
X        err(r, errbuf);
X      }
X      w = &z->nxt;
X    }
X
X
X  /* Process the edited found list, adding them to the zip file */
X  diag("zipping up new entries, if any");
X  for (f = found; f != NULL; f = fexpel(f))
X  {
X    /* add a new zfiles entry and set the name */
X    if ((z = (struct zlist far *)farmalloc(sizeof(struct zlist))) == NULL)
X      err(ZE_MEM, "was adding files to zip file");
X    z->nxt = NULL;
X    z->name = f->name;
X    f->name = NULL;
X    z->zname = f->zname;
X    f->zname = NULL;
X    z->ext = z->cext = z->com = 0;
X    z->mark = 1;
X    z->dosflag = f->dosflag;
X    /* zip it up */
X    if (noisy)
X    {
X      fprintf(mesg, "adding %s", z->zname);
X      fflush(mesg);
X    }
X    if ((r = zipup(z, y)) != ZE_OK  && r != ZE_OPEN)
X    {
X      if (noisy)
X      {
X        putc('\n', mesg);
X        fflush(mesg);
X      }
X      sprintf(errbuf, "was zipping %s", z->name);
X      err(r, errbuf);
X    }
X    if (r == ZE_OPEN)
X    {
X      o = 1;
X      if (noisy)
X      {
X        putc('\n', mesg);
X        fflush(mesg);
X      }
X      perror("zip warning");
X      warn("could not open for reading: ", z->name);
X      free((voidp *)(z->name));
X      free((voidp *)(z->zname));
X      farfree((voidp far *)z);
X    }
X    else
X    {
X      *w = z;
X      w = &z->nxt;
X      zcount++;
X    }
X  }
X  if (key != NULL)
X  {
X    free((voidp *)key);
X    key = NULL;
X  }
X
X
X  /* Get one line comment for each new entry */
X  if (comadd)
X  {
X    if ((e = malloc(MAXCOM + 1)) == NULL)
X      err(ZE_MEM, "was reading comment lines");
X    for (z = zfiles; z != NULL; z = z->nxt)
X      if (z->mark)
X      {
X        if (noisy)
X          fprintf(mesg, "Enter comment for %s:\n", z->name);
X        /* ??? reopen /dev/tty if one file was zipped from stdin
X         * or if file names were read from stdin.
X         */
X        if (fgets(e, MAXCOM+1, stdin) != NULL)
X        {
X          if ((p = malloc((k = strlen(e))+1)) == NULL)
X          {
X            free((voidp *)e);
X            err(ZE_MEM, "was reading comment lines");
X          }
X          strcpy(p, e);
X          if (p[k-1] == '\n')
X            p[--k] = 0;
X          z->comment = p;
X          z->com = k;
X        }
X      }
X    free((voidp *)e);
X  }
X
X  /* Get multi-line comment for the zip file */
X  if (zipedit)
X  {
X    if ((e = malloc(MAXCOM + 1)) == NULL)
X      err(ZE_MEM, "was reading comment lines");
X    if (noisy && zcomlen)
X    {
X      fputs("current zip file comment is:\n", mesg);
X      fwrite(zcomment, 1, zcomlen, mesg);
X      if (zcomment[zcomlen-1] != '\n')
X        putc('\n', mesg);
X      free((voidp *)zcomment);
X    }
X    zcomment = malloc(1);
X    *zcomment = 0;
X    if (noisy)
X      fputs("enter new zip file comment (end with .):\n", mesg);
X     /* ??? reopen /dev/tty if one file was zipped from stdin
X      * or if file names were read from stdin.
X      */
X    while (fgets(e, MAXCOM+1, stdin) != NULL && strcmp(e, ".\n"))
X    {
X      if (e[(r = strlen(e)) - 1] == '\n')
X        e[--r] = 0;
X      if ((p = malloc((*zcomment ? strlen(zcomment) + 3 : 1) + r)) == NULL)
X      {
X        free((voidp *)e);
X        err(ZE_MEM, "was reading comment lines");
X      }
X      if (*zcomment)
X        strcat(strcat(strcpy(p, zcomment), "\r\n"), e);
X      else
X        strcpy(p, *e ? e : "\r\n");
X      free((voidp *)zcomment);
X      zcomment = p;
X    }
X    zcomlen = strlen(zcomment);
X    free((voidp *)e);
X  }
X
X
X  /* Write central directory and end header to temporary zip */
X  diag("writing central directory");
X  k = 0;                        /* keep count for end header */
X  c = tempzn;                   /* get start of central */
X  n = t = 0;
X  for (z = zfiles; z != NULL; z = z->nxt)
X  {
X    if ((r = putcentral(z, y)) != ZE_OK)
X      err(r, tempzip);
X    tempzn += 4 + CENHEAD + z->nam + z->cext + z->com;
X    n += z->len;
X    t += z->siz;
X    k++;
X  }
X  if (k == 0)
X    warn("zip file empty", "");
X  if (verbose)
X    fprintf(mesg, "total bytes=%lu, compressed=%lu -> %d%% savings\n",
X           n, t, percent(n, t));
X  t = tempzn - c;               /* compute length of central */
X  diag("writing end of central directory");
X  if ((r = putend(k, t, c, zcomlen, zcomment, y)) != ZE_OK)
X    err(r, tempzip);
X  tempzf = NULL;
X  if (fclose(y))
X    err(d ? ZE_WRITE : ZE_TEMP, tempzip);
X  if (x != NULL)
X    fclose(x);
X
X
X  /* Replace old zip file with new zip file, leaving only the new one */
X  if (strcmp(zipfile, "-") && !d)
X  {
X    diag("replacing old zip file with new zip file");
X    if ((r = replace(zipfile, tempzip)) != ZE_OK)
X    {
X      warn("new zip file left as: ", tempzip);
X      free((voidp *)tempzip);
X      tempzip = NULL;
X      err(r, "was replacing the original zip file");
X    }
X    free((voidp *)tempzip);
X  }
X  tempzip = NULL;
X  if (strcmp(zipfile, "-")) {
X    setfileattr(zipfile, a);
X#ifdef VMS
X    /* If the zip file existed previously, restore its record format: */
X    if (x != NULL)
X      VMSmunch(zipfile, RESTORE_RTYPE, NULL);
X#endif
X  }
X
X  /* Finish up (process -o, -m, clean up).  Exit code depends on o. */
X  leave(o ? ZE_OPEN : ZE_OK);
X}
X
X/*****************************************************************
X | envargs - add default options from environment to command line
X |----------------------------------------------------------------
X | Author: Bill Davidsen, original 10/13/91, revised 23 Oct 1991.
X | This program is in the public domain.
X |----------------------------------------------------------------
X | Minor program notes:
X |  1. Yes, the indirection is a tad complex
X |  2. Parenthesis were added where not needed in some cases
X |     to make the action of the code less obscure.
X ****************************************************************/
X
Xlocal void
Xenvargs(Pargc, Pargv, envstr)
Xint *Pargc;
Xchar ***Pargv;
Xchar *envstr;
X{
X    char *getenv();
X    char *envptr;                               /* value returned by getenv */
X    char *bufptr;                               /* copy of env info */
X    int argc = 0;                               /* internal arg count */
X    int ch;                                             /* spare temp value */
X    char **argv;                                /* internal arg vector */
X    char **argvect;                             /* copy of vector address */
X
X    /* see if anything in the environment */
X    envptr = getenv(envstr);
X    if (envptr == NULL || *envptr == 0) return;
X
X    /* count the args so we can allocate room for them */
X    argc = count_args(envptr);
X    bufptr = malloc(1+strlen(envptr));
X    if (bufptr == NULL)
X        err(ZE_MEM, "Can't get memory for arguments");
X
X    strcpy(bufptr, envptr);
X
X    /* allocate a vector large enough for all args */
X    argv = (char **)malloc((argc+*Pargc+1)*sizeof(char *));
X    if (argv == NULL)
X        err(ZE_MEM, "Can't get memory for arguments");
X    argvect = argv;
X
X    /* copy the program name first, that's always true */
X    *(argv++) = *((*Pargv)++);
X
X    /* copy the environment args first, may be changed */
X    do {
X        *(argv++) = bufptr;
X        /* skip the arg and any trailing blanks */
X        while ((ch = *bufptr) != '\0' && ch != ' ') ++bufptr;
X        if (ch == ' ') *(bufptr++) = '\0';
X        while ((ch = *bufptr) != '\0' && ch == ' ') ++bufptr;
X    } while (ch);
X
X    /* now save old argc and copy in the old args */
X    argc += *Pargc;
X    while (--(*Pargc)) *(argv++) = *((*Pargv)++);
X
X    /* finally, add a NULL after the last arg, like UNIX */
X    *argv = NULL;
X
X    /* save the values and return */
X    *Pargv = argvect;
X    *Pargc = argc;
X}
X
Xstatic int
Xcount_args(s)
Xchar *s;
X{
X    int count = 0;
X    int ch;
X
X    do {
X        /* count and skip args */
X        ++count;
X        while ((ch = *s) != '\0' && ch != ' ') ++s;
X        while ((ch = *s) != '\0' && ch == ' ') ++s;
X    } while (ch);
X
X    return count;
X}
END_OF_FILE
  if test 32880 -ne `wc -c <'zip.c'`; then
    echo shar: \"'zip.c'\" unpacked with wrong size!
  fi
  # end of 'zip.c'
fi
if test -f 'zip.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zip.doc'\"
else
  echo shar: Extracting \"'zip.doc'\" \(23559 characters\)
  sed "s/^X//" >'zip.doc' <<'END_OF_FILE'
X
XZIP(1)                   USER COMMANDS                     ZIP(1)
X
XNAME
X     zip, zipcloak, zipnote,  zipsplit  -  package  and  compress
X     (archive) files
X
XSYNOPSIS
X     zip [ -cdeEfghjklmoqruwyz@ ] [ -b temppath ] [ -n suffixes ]
X     [ -t mmddyy ] [ zipfile list ] [ -x list ]
X
X     zipcloak [ -d ] [ -b path ] zipfile
X
X     zipnote [ -w ] [ -b path ] zipfile
X
X     zipsplit [ -ti ] [ -n size ] [ -b path ] zipfile
X
XDESCRIPTION
X     zip is a compression and file packaging  utility  for  Unix,
X     VMS,  MSDOS,  OS/2,  Windows NT, Minix, Atari and Macintosh.
X     It is analogous to a combination of tar and compress and  is
X     compatible with PKZIP (Phil Katz ZIP) for MSDOS systems.
X
X     There is a companion to zip called unzip (of  course)  which
X     you  should  be able to find the same place you got zip. zip
X     and unzip can work with files produced by PKZIP under MSDOS,
X     and PKZIP and PKUNZIP can work with files produced by zip.
X
X     zip version 1.9 is compatible with pkzip 1.93a.   Note  that
X     pkunzip 1.10 cannot extract files produced by pkzip 1.93a or
X     zip 1.9b. You must use pkunzip 1.93a or unzip 5.0 to extract
X     them.
X
X     For a brief help on zip and unzip, run each without specify-
X     ing any parameters on the command line.
X
X     zip puts one or more compressed files  into  a  single  "zip
X     file"  along with information about the files, including the
X     name, path if requested, date and time last  modified,  pro-
X     tection,  and  check  information  to verify the fidelity of
X     each entry.  zip can also be used as a  filter,  compressing
X     standard  input  to standard output.  zip can pack an entire
X     directory structure in a zip file  with  a  single  command.
X     Compression  ratios of 2:1 to 3:1 are common for text files.
X     zip has one compression  method  (deflation)  and  can  also
X     store  files  without  compression. It automatically chooses
X     the better of the two for each file to be compressed.
X
X     zip is useful for packaging a set of files to send to  some-
X     one  or for distribution; for archiving or backing up files;
X     and for saving disk space by temporarily compressing  unused
X     files or directories.
X
XHOW TO USE ZIP
X     The simplest use of zip is as follows:
X
X          zip stuff *
X
X     This will create the file "stuff.zip" (assuming it does  not
X     exist)  and  put  all  the files in the current directory in
X     stuff.zip in a compressed form.  The .zip  suffix  is  added
X     automatically,  unless  that  file name given contains a dot
X     already.  This allows specifying suffixes other than ".zip".
X
X     Because of the way the  shell  does  filename  substitution,
X     files  that  start  with a "." are not included.  To include
X     those as well, you can:
X
X          zip stuff .* *
X
X     Even this will not include any subdirectories  that  are  in
X     the  current  directory.  To zip up an entire directory, the
X     command:
X
X          zip -r foo foo
X
X     will create the file "foo.zip" containing all the files  and
X     directories  in  the  directory "foo" that is in the current
X     directory. (The first "foo" denotes the zip file, the second
X     one  denotes  the  directory.)  The "r" option means recurse
X     through the directory structure.   In  this  case,  all  the
X     files  and directories in foo are zipped, including the ones
X     that start with a ".", since the recursion does not use  the
X     shell's  file-name substitution.  You should not use -r with
X     the name ".*", since that matches ".." which will attempt to
X     zip up the parent directory--probably not what was intended.
X
X     You may want to make a zip file that contains the  files  in
X     foo,  but  not  record the directory name, foo.  You can use
X     the -j (junk path) option to leave off the path:
X
X          zip -j foo foo/*
X
X     The -y option (only under Unix) will store symbolic links as
X     such in the zip file, instead of compressing and storing the
X     file referred to in the link.
X
X     You might be zipping to save disk space, in which  case  you
X     could:
X
X          zip -rm foo foo
X
X     where the "m" option means "move".  This will delete foo and
X     its  contents  after  making  foo.zip.  No deletions will be
X     done until the zip  has  completed  with  no  errors.   This
X     option  is  obviously more dangerous and should be used with
X     care.
X
X     If the zip file already exists, these commands will  replace
X     existing  or  add new entries to the zip file.  For example,
X     if you were really short on disk space, you might  not  have
X     enough room simultaneously to hold the directory foo and the
X     compressed foo.zip.  In this case, you could do it in steps.
X     If  foo  contained  the subdirectories tom, dick, and harry,
X     then you could:
X
X          zip -rm foo foo/tom
X          zip -rm foo foo/dick
X          zip -rm foo foo/harry
X
X     where the first command would create foo.zip, and  the  next
X     two would add to it.  At the completion of each zip command,
X     the directory just zipped would be deleted, making  room  in
X     which the next zip command could work.
X
X     zip will also accept a single dash ("-")  as  the  zip  file
X     name,  in  which  case it will write the zip file to stdout,
X     allowing the output to be  piped  to  another  program.  For
X     example:
X
X          zip -r - . | dd of=/dev/nrst0 obs=16k
X
X     would write the zip output  directly  to  a  tape  with  the
X     specified  block  size  for  the  purpose  of backing up the
X     current directory.
X
X     zip also accepts a single dash ("-") as the name of  a  file
X     to  be  compressed,  in which case it will read the zip file
X     from stdin, allowing zip to take input from another program.
X     For example:
X
X          tar cf - . | zip backup -
X
X     would compress the output of the tar command for the purpose
X     of backing up the current directory. This generally produces
X     better compression than the previous example  using  the  -r
X     option, because zip can take advantage of redundancy between
X     files. The backup can be restored using the command
X
X          unzip -p backup | tar xf -
X
X     When no zip file name is given and stdout is not a terminal,
X     zip acts as a filter, compressing standard input to standard
X     output.  For example,
X
X          tar cf - . | zip | dd of=/dev/nrst0
X
X     is equivalent to
X
X          tar cf - . | zip - - | dd of=/dev/nrst0
X
X     Zip archives created in this manner can  be  extracted  with
X     the  program  funzip which is provided in the unzip package.
X     For example,
X
X             dd if=/dev/nrst0 | funzip | tar xvf -
X
XMODIFYING EXISTING ZIP FILES
X     When given the name of an existing zip file with  the  above
X     commands,  zip will replace identically named entries in the
X     zip file or add entries for  new  names.   For  example,  if
X     foo.zip exists and contains foo/file1 and foo/file2, and the
X     directory foo contains the files  foo/file1  and  foo/file3,
X     then:
X
X          zip -r foo foo
X
X     will replace foo/file1  in  foo.zip  and  add  foo/file3  to
X     foo.zip.  After this, foo.zip contains foo/file1, foo/file2,
X     and foo/file3, with foo/file2 unchanged from before.
X
X     When changing an existing zip file, zip will  write  a  tem-
X     porary  file with the new contents, and only replace the old
X     one when the zip has completed with no errors. You  can  use
X     the  -b  option  to specify a different path (usually a dif-
X     ferent device) to put the temporary file in.  For example:
X
X          zip -b /tmp stuff *
X
X     will put the temporary zip file and the  temporary  compres-
X     sion  files  in the directory "/tmp", copying over stuff.zip
X     in the current directory when done.
X
X     If you are only adding entries to a zip file, not replacing,
X     and  the -g option is given, then zip grows (appends to) the
X     file instead of copying it.  The danger of this is  that  if
X     the  operation fails, the original zip file is corrupted and
X     lost.
X
X     There are two other ways to change or add entries in  a  zip
X     file  that  are  restrictions of simple addition or replace-
X     ment.  The first is -u (update) which will add  new  entries
X     to  the zip file as before but will replace existing entries
X     only if the modified date of the file is  more  recent  than
X     the  date recorded for that name in the zip file.  For exam-
X     ple:
X
X          zip -u stuff *
X
X     will add any new files in the current directory, and  update
X     any  changed files in the zip file stuff.zip.  Note that zip
X     will not try to pack stuff.zip into itself when you do this.
X     zip will always exclude the zip file from the files on which
X     to be operated.
X
X     The second restriction is -f (freshen) which,  like  update,
X     will  only  replace entries with newer files; unlike update,
X     will not add files that are not already  in  the  zip  file.
X     For  this  option, you may want to simply freshen all of the
X     files that are in the specified zip file.  To  do  this  you
X     would simply:
X
X          zip -f foo
X
X     Note that the -f option with no arguments freshens  all  the
X     entries  in the zip file.  The same is true of -u, and hence
X     "zip -u foo" and "zip -f foo" both do the same thing.
X
X     This command should be run  from  the  same  directory  from
X     which  the  original zip command was run, since paths stored
X     in zip files are always relative.
X
X     Another restriction that can be used with adding,  updating,
X     or  freshening is -t (time), which will not operate on files
X     modified earlier than the specified date.  For example:
X
X          zip -rt 120791 infamy foo
X
X     will add all the files in foo and  its  subdirectories  that
X     were  last modified on December 7, 1991, or later to the zip
X     file infamy.zip.
X
X     Also, files can be explicitly excluded using the -x option:
X
X          zip -r foo foo -x \*.o
X
X     which will zip up the  contents  of  foo  into  foo.zip  but
X     exclude  all the files that end in ".o".  Here the backslash
X     causes zip to match file names that were found when foo  was
X     searched.
X
X     The last operation is -d (delete) which will remove  entries
X     from a zip file.  An example might be:
X
X          zip -d foo foo/tom/junk foo/harry/\* \*.o
X
X     which will remove the entry foo/tom/junk, all of  the  files
X     that  start with "foo/harry/", and all of the files that end
X     with ".o" (in any path).  Note that once  again,  the  shell
X     expansion  has  been inhibited with backslashes, so that zip
X     can see the asterisks. zip can then match on the contents of
X     the  zip  file instead of the contents of the current direc-
X     tory.
X
X     Under MSDOS, -d is case sensitive when it matches  names  in
X     the  zip  file.  This allows deleting names that were zipped
X     on other systems, but requires that the names be entered  in
X     upper  case  if they were zipped on an MSDOS system, so that
X     the names can be found in the zip file and deleted.
X
XMORE OPTIONS
X     As mentioned before, zip will use the best of  two  methods:
X     deflate or store.
X
X     The option -0 will force zip to use store on all files.  For
X     example:
X
X          zip -r0 foo foo
X
X     will zip up the directory foo into foo.zip using only store.
X
X     The speed of deflation can also be controlled  with  options
X     -1  (fastest  method  but  less  compression)  to  -9  (best
X     compression but slower). The default value is -5. For  exam-
X     ple:
X
X          zip -r8 foo foo
X
X     In nearly all cases, a file that is already compressed  can-
X     not  be  compressed further by zip, or if it can, the effect
X     is minimal.  The -n  option  prevents  zip  from  trying  to
X     compress files that have the given suffixes.  Such files are
X     simply stored (0% compression) in the output  zip  file,  so
X     that  zip  doesn't  waste  its time trying to compress them.
X     The suffixes are separated by either colons  or  semicolons.
X     For example:
X
X          zip -rn ".Z:.zip:.tiff:.gif:.snd"  foo foo
X
X     will put everything in foo into foo.zip, but will store  any
X     files  that  end  in  .Z, .zip, .tiff, .gif, or .snd without
X     trying to compress them.  (Image and sound files often  have
X     their own specialized compression methods.) The default suf-
X     fix list is ".Z:.zip;.zoo:.arc:.lzh:.arj".  The  environment
X     variable  ZIPOPT  can  be  used  to change this default. For
X     example under Unix with csh:
X
X          setenv ZIPOPT "-n .gif:.zip"
X
X     The variable ZIPOPT can be  used  for  any  option  and  can
X     include several options.
X
X     Under Unix and  under  OS/2  (if  files  from  an  HPFS  are
X     stored),  zip  will  store  the  full  path (relative to the
X     current path) and name of the file (or just the name  if  -j
X     is   specified)   in  the  zip  file  along  with  the  Unix
X     attributes, and it will mark the entry as made  under  Unix.
X     If  the  zip  file is intended for PKUNZIP under MSDOS, then
X     the -k (Katz) option should be used to  attempt  to  convert
X     the  names  and  paths  to  conform to MSDOS, store only the
X     MSDOS attribute (just the user write attribute  from  Unix),
X     and  mark  the  entry  as  made  under MSDOS (even though it
X     wasn't).
X
X     The -o (older) option will set the "last modified"  time  of
X     the  zip  file  to  the  latest  "last modified" time of the
X     entries in the zip file.  This can be used without any other
X     operations, if desired.  For example:
X
X          zip -o foo
X
X     will change the last modified time of foo.zip to the  latest
X     time of the entries in foo.zip.
X
X     The -e and -c options operate on all files updated or  added
X     to the zip file.  Encryption (-e) will prompt for a password
X     on the terminal and will not echo  the  password  as  it  is
X     typed (if stderr is not a TTY, zip will exit with an error).
X     New zip entries will be encrypted using that password.   For
X     added  peace of mind, you can use -ee, which will prompt for
X     the password twice, checking  that  the  two  are  the  same
X     before   using   it.  The  encryption  code  is  distributed
X     separately, so the -e option may not be  available  in  your
X     version.
X
X     One-line comments can be added for each  file  with  the  -c
X     option.   The  zip file operations (adding or updating) will
X     be done first, and you will then be prompted for a  one-line
X     comment  for each file.  You can then enter the comment fol-
X     lowed by return, or just return for no comment.
X
X     The -z option will prompt you for a multi-line  comment  for
X     the  entire zip file.  This option can be used by itself, or
X     in combination with other options.  The comment is ended  by
X     a line containing just a period, or an end of file condition
X     (^D on Unix, ^Z on MSDOS,  OS/2,  and  VAX/VMS).   Since  -z
X     reads  the lines from stdin, you can simply take the comment
X     from a file:
X
X          zip -z foo < foowhat
X
X     The -q (quiet) option eliminates the informational  messages
X     and  comment  prompts while zip is operating.  This might be
X     used in shell scripts, for example, or if the zip  operation
X     is  being  performed  as  a background task ("zip -q foo *.c
X     &").
X
X     zip can take a list of file names to operate on  from  stdin
X     using  the -@ option.  In Unix, this option can be used with
X     the find command to extend greatly the functionality of zip.
X     For example, to zip up all the C source files in the current
X     directory and its subdirectories, you can:
X
X          find . -type f -name "*.[ch]" -print | zip source -@
X
X     Note that the pattern must be quoted to keep the shell  from
X     expanding it.
X
X     Under VMS only, the -w option will append the version number
X     of  the  files  to  the name and zip up multiple versions of
X     files.  Without -w, zip will only use the most  recent  ver-
X     sion of the specified file(s).
X
X     The -l option translates the Unix end-of-line  character  LF
X     into  the  MSDOS convention CR LF. This option should not be
X     used on binary files.  This option can be used  on  Unix  if
X     the  zip  file  is  intended for PKUNZIP under MSDOS. If the
X     input files already contain CR LF, this option adds an extra
X     CR.  This  ensure  that  "unzip -a" on Unix will get back an
X     exact copy of the original file, to undo the effect of  "zip
X     -l".
X
X     If zip is run with the -h option, or with no  arguments  and
X     standard  output is a terminal, the license and the command-
X     argument and option help is shown.  The -L option just shows
X     the license.
X
XABOUT PATTERN MATCHING
X     (Note: this section applies to Unix.  Watch this  space  for
X     details on MSDOS and VMS operation.)
X
X     The Unix shell (sh or csh)  does  filename  substitution  on
X     command  arguments.   The  special  characters  are ?, which
X     matches any single character; * which matches any number  of
X     characters  (including none); and [] which matches any char-
X     acter in the  range  inside  the  brackets  (like  [a-f]  or
X     [0-9]).   When  these  characters  are  encountered (and not
X     escaped with a backslash or quotes), the shell will look for
X     files  relative  to the current path that match the pattern,
X     and replace the argument with  a  list  of  the  names  that
X     matched.
X
X     zip can do the same matching on names that are  in  the  zip
X     file  being  modified  or,  in  the case of the -x (exclude)
X     option, on the list of files to be  operated  on,  by  using
X     backslashes  or  quotes to tell the shell not to do the name
X     expansion.  In general, when zip encounters a  name  in  the
X     list of files to do, it first looks for the name in the file
X     system.  If it finds it, it then adds  it  to  the  list  of
X     files  to  do.  If it does not find it, it will look for the
X     name in the zip file being modified (if  it  exists),  using
X     the  pattern  matching  characters  above, if any.  For each
X     match, it will add that name to the list  of  files  to  do.
X     After  -x  (exclude),  the  names are removed from the to-do
X     list instead of added.
X
X     The pattern matching includes the path, and so patterns like
X     \*.o  match  names that end in ".o", no matter what the path
X     prefix is.  Note that the backslash must precede every  spe-
X     cial  character  (i.e. ?*[]), or the entire argument must be
X     enclosed in double quotes ("").
X
X     In general, using backslash  to  make  zip  do  the  pattern
X     matching  is  used  with  the  -f  (freshen) and -d (delete)
X     options, and sometimes after the -x  (exclude)  option  when
X     used  with  any  operation  (add,  -u, -f, or -d).  zip will
X     never use pattern matching to search the  file  system.   If
X     zip has recursed into a directory, all files (and all direc-
X     tories) in there are fair game.
X
XCOPYRIGHT
X     Copyright (C) 1990-1992 Mark Adler, Richard B. Wales,  Jean-
X     loup  Gailly, Kai Uwe Rommel and Igor Mandrichenko.  Permis-
X     sion is granted to any individual  or  institution  to  use,
X     copy,  or  redistribute  this software so long as all of the
X     original files are included unmodified, that it is not  sold
X     for profit, and that this copyright notice is retained.
X
XACKNOWLEDGEMENTS
X     Thanks to R. P.  Byrne  for  his  Shrink.Pas  program  which
X     inspired  this project; to Phil Katz for making the zip file
X     format, compression format, and .zip filename extension  all
X     public  domain;  to  Steve  Burg  and  Phil Katz for help on
X     unclear points of the deflate format; to Keith Petersen  and
X     Rich Wales for providing a mailing list and ftp site for the
X     INFO-ZIP group to use; and most importantly, to the INFO-ZIP
X     group  itself (listed in the file infozip.who) without whose
X     tireless testing and bug-fixing efforts a portable zip would
X     not have been possible.  Finally we should thank (blame) the
X     INFO-ZIP moderator, David Kirschbaum  for  getting  us  into
X     this mess in the first place.
X
XSEE ALSO
X     unzip(1), tar(1), compress(1)
X
XBUGS
X     WARNING: zip files produced by this version of zip must  not
X     be  *updated*  by  zip  1.0 or pkzip 1.10 or pkzip 1.93a, if
X     they contain encrypted members, or if they  have  been  pro-
X     duced  in  a  pipe or on a non seekable device. The old ver-
X     sions of zip or pkzip would destroy the zip  structure.  The
X     old  versions can list the contents of the zip file but can-
X     not extract it anyway (because of the new compression  algo-
X     rithm).   If  you do not use encryption and use regular disk
X     files, you do not have to care about this problem.
X
X     zip 1.9 is compatible with  pkzip  1.93a,  except  when  two
X     features  are used: encryption or zip file created in a pipe
X     or on a non seekable device. pkzip versions above  2.0  will
X     support such files, and unzip 5.0 already supports them.
X
X     Without -y, when zip must compress a symbolic link to an non
X     existing   file,  it  only  displays  a  warning  "name  not
X     matched". A better warnign should be given.
X
X     Under VMS, not all of the odd file formats are treated prop-
X     erly.   Only  zip files of format stream-LF and fixed length
X     512 are expected to work with zip.  Others can be  converted
X     using  Rahul Dhesi's BILF program.  This version of zip does
X     handle some of the conversion internally.  When using Kermit
X     to transfer zip files from Vax to MSDOS, type "set file type
X     block" on the Vax.  When transfering from MSDOS to Vax, type
X     "set  file type fixed" on the Vax.  In both cases, type "set
X     file type binary" on MSDOS.
X
X     Under VMS, zip hangs for file specification that uses DECnet
X     syntax (foo::*.*).
X
X     Under OS/2, the amount of External Attributes  displayed  by
X     DIR is (for compatibility) the amount returned by the 16-bit
X     version of DosQueryPathInfo(). Otherwise OS/2  1.3  and  2.0
X     would  report  different  EA sizes when DIRing a file.  How-
X     ever,  the  structure  layout   returned   by   the   32-bit
X     DosQueryPathInfo() is a bit different, it uses extra padding
X     bytes and link pointers (it's a linked  list)  to  have  all
X     fields  on  4-byte boundaries for portability to future RISC
X     OS/2 versions. Therefore the value reported  by  ZIP  (which
X     uses  this  32-bit-mode  size) differs from that reported by
X     DIR.  ZIP stores the 32-bit format for portability, even the
X     16-bit  MS-C-compiled  version  running on OS/2 1.3, so even
X     this one shows the 32-bit-mode size.
X
X     LIKE ANYTHING ELSE THAT'S FREE, ZIP AND ITS ASSOCIATED UTIL-
X     ITIES  ARE  PROVIDED  AS IS AND COME WITH NO WARRANTY OF ANY
X     KIND, EITHER EXPRESSED OR IMPLIED.  IN  NO  EVENT  WILL  THE
X     COPYRIGHT  HOLDERS  BE LIABLE FOR ANY DAMAGES RESULTING FROM
X     THE USE OF THIS SOFTWARE.
X
X     That having been said, please send any problems or  comments
X     via email to the Internet address zip-bugs@cs.ucla.edu.  For
X     bug reports, please include the version  of  zip,  the  make
X     options  you  used  to compile it, the machine and operating
X     system you are using, and as much additional information  as
X     possible.  Thank you for your support.
END_OF_FILE
  if test 23559 -ne `wc -c <'zip.doc'`; then
    echo shar: \"'zip.doc'\" unpacked with wrong size!
  fi
  # end of 'zip.doc'
fi
echo shar: End of archive 4 \(of 11\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
