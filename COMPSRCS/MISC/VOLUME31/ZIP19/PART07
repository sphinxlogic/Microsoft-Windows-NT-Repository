Newsgroups: comp.sources.misc
From: zip-bugs@cs.ucla.edu (Info-ZIP group)
Subject:  v31i099:  zip19 - Info-ZIP portable Zip, version 1.9, Part07/11
Message-ID: <1992Aug23.064739.29343@sparky.imd.sterling.com>
X-Md4-Signature: 78834c85a8bc38b5c3e178b5fc3ec576
Date: Sun, 23 Aug 1992 06:47:39 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: zip-bugs@cs.ucla.edu (Info-ZIP group)
Posting-number: Volume 31, Issue 99
Archive-name: zip19/part07
Supersedes: zip: Volume 23, Issue 88-96
Environment: UNIX, VMS, OS/2, MS-DOS, MACINTOSH, WIN-NT, LINUX, MINIX, XOS, !AMIGA, ATARI, symlink, SGI, DEC, Cray, Convex, Amdahl, Sun, PC

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  msdos/makefile.gcc.UU vms/vms.c vms/vms_zip.rnh zipsplit.c
# Wrapped by kent@sparky on Sun Aug 23 01:00:45 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 7 (of 11)."'
if test -f 'msdos/makefile.gcc.UU' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'msdos/makefile.gcc.UU'\"
else
  echo shar: Extracting \"'msdos/makefile.gcc.UU'\" \(2879 characters\)
  sed "s/^X//" >'msdos/makefile.gcc.UU' <<'END_OF_FILE'
Xbegin 666 msdos/makefile.gcc
XM(R!-86ME9FEL92!F;W(@6FEP+"!::7!#;&]A:RP@6FEP3F]T92!A;F0@6FEP
XM4W!L:70@9F]R#0HC(&1J9V-C(#$N,#8-"@T*0U)94%1//0T*0TQ/04L]#0I#
XM4D9,04<]#0H-"B,@("HJ*B!&;W(@96YC<GEP=&EO;B!V97)S:6]N+"!R96UO
XM=F4@=&AE(",@870@=&AE(&9R;VYT(&]F(&YE>'0@,R!L:6YE<R J*BH-"B-#
XM4EE05$\]8W)Y<'0N;PT*(T-,3T%+/7II<&-L;V%K+F5X90T*(T-21DQ!1STM
XM1$-265!4#0H-"B,@+2TM+2TM+2TM+2TM+2!D:F=C8R M+2TM+2TM+2TM+2TM
XM#0I#1DQ!1U,]+5=A;&P@+4\R("U$3D]?05--("0H0U)&3$%'*0T*551)3$9,
XM04=3/2U$551)3" D*$-&3$%'4RD@+6\-"D-#/6=C8PT*3$0]9V-C#0I,1$9,
XM04=3/2US#0H-"B,@=F%R:6%B;&5S#0I/0DI:(#T@>FEP+F\@>FEP9FEL92YO
XM('II<'5P+F\@9FEL96EO+F\@=71I;"YO(&=L;V)A;',N;R D*$-265!43RD-
XM"@T*3T)*52 ]('II<&9I;&5?+F\@>FEP=7!?+F\@9FEL96EO7RYO('5T:6Q?
XM+F\@9VQO8F%L<RYO#0I/0DI.(#T@>FEP;F]T92YO(" D*$]"2E4I#0I/0DI#
XM(#T@>FEP8VQO86LN;R D*$]"2E4I(&-R>7!T7RYO#0I/0DI3(#T@>FEP<W!L
XM:70N;R D*$]"2E4I#0H-"GII<',Z"7II<"!Z:7!N;W1E('II<'-P;&ET("0H
XM0TQ/04LI#0H-"GII<"YO.@D@(" @("!Z:7 N:"!Z:7!E<G(N:"!T86EL;W(N
XM:"!R979I<VEO;BYH('II<"YC#0H-"GII<&9I;&4N;SH@(" @>FEP+F@@>FEP
XM97)R+F@@=&%I;&]R+F@@>FEP9FEL92YC#0H-"GII<'5P+F\Z(" @(" @>FEP
XM+F@@>FEP97)R+F@@=&%I;&]R+F@@<F5V:7-I;VXN:"!Z:7!U<"YC#0H-"F9I
XM;&5I;RYO.B @(" @>FEP+F@@>FEP97)R+F@@=&%I;&]R+F@@9FEL96EO+F,-
XM"@T*=71I;"YO.B @(" @("!Z:7 N:"!Z:7!E<G(N:"!T86EL;W(N:"!U=&EL
XM+F,-"@T*9VQO8F%L<RYO.B @("!Z:7 N:"!Z:7!E<G(N:"!T86EL;W(N:"!G
XM;&]B86QS+F,-"@T*9&5F;&%T92YO.B @("!Z:7 N:"!Z:7!E<G(N:"!T86EL
XM;W(N:"!D969L871E+F,-"@T*=')E97,N;SH@(" @("!Z:7 N:"!Z:7!E<G(N
XM:"!T86EL;W(N:"!T<F5E<RYC#0H-"F)I=',N;SH@(" @(" @>FEP+F@@>FEP
XM97)R+F@@=&%I;&]R+F@@8FET<RYC#0H-"F-R>7!T+F\Z(" @(" @>FEP+F@@
XM>FEP97)R+F@@=&%I;&]R+F@@8W)Y<'0N8PT*#0IZ:7!C;&]A:RYO.B @('II
XM<"YH('II<&5R<BYH('1A:6QO<BYH(')E=FES:6]N+F@@>FEP8VQO86LN8PT*
XM#0IZ:7!N;W1E+F\Z(" @('II<"YH('II<&5R<BYH('1A:6QO<BYH(')E=FES
XM:6]N+F@@>FEP;F]T92YC#0H-"GII<'-P;&ET+F\Z(" @>FEP<W!L:70N8R!Z
XM:7 N:"!Z:7!E<G(N:"!T86EL;W(N:"!R979I<VEO;BYH#0H-"GII<&9I;&5?
XM+F\Z(" @>FEP9FEL92YC('II<"YH('II<&5R<BYH('1A:6QO<BYH#0H))"A#
XM0RD@+6,@)"A55$E,1DQ!1U,I("1 ('II<&9I;&4N8PT*#0IZ:7!U<%\N;SH@
XM(" @('II<'5P+F,@>FEP+F@@>FEP97)R+F@@=&%I;&]R+F@-"@DD*$-#*2 M
XM8R D*%5424Q&3$%'4RD@)$ @>FEP=7 N8PT*#0IF:6QE:6]?+F\Z(" @(&9I
XM;&5I;RYC('II<"YH('II<&5R<BYH('1A:6QO<BYH#0H))"A#0RD@+6,@)"A5
XM5$E,1DQ!1U,I("1 (&9I;&5I;RYC#0H-"G5T:6Q?+F\Z(" @('5T:6PN8R!Z
XM:7 N:"!Z:7!E<G(N:"!T86EL;W(N: T*"20H0T,I("UC("0H551)3$9,04=3
XM*2 D0"!F:6QE:6\N8PT*#0IC<GEP=%\N;SH@(" @(&-R>7!T+F,@>FEP+F@-
XM"@DD*$-#*2 M8R D*%5424Q&3$%'4RD@)$ @8W)Y<'0N8PT*#0IZ:7 Z("0H
XM3T)*6BD@)"A/0DI)*0T*"20H3$0I("0H3$1&3$%'4RD@)"A/0DI:*2 D*$]"
XM2DDI("UO("1 #0H)86]U=#)E>&4@)$ -"@ED96P@)$ -"@T*>FEP8VQO86LZ
XM("0H3T)*0RD-"@DD*$Q$*2 D*$Q$1DQ!1U,I("0H3T)*0RD@+6\@)$ -"@EA
XM;W5T,F5X92 D0 T*"61E;" D0 T*#0IZ:7!N;W1E.B D*$]"2DXI#0H))"A,
XM1"D@)"A,1$9,04=3*2 D*$]"2DXI("UO("1 #0H)86]U=#)E>&4@)$ -"@ED
XM96P@)$ -"@T*>FEP<W!L:70Z("0H3T)*4RD-"@DD*$Q$*2 D*$Q$1D%'4RD@
XF)"A/0DI3*2 M;R D0 T*"6%O=70R97AE("1 #0H)9&5L("1 #0I$
X 
Xend
END_OF_FILE
  if test 2879 -ne `wc -c <'msdos/makefile.gcc.UU'`; then
    echo shar: \"'msdos/makefile.gcc.UU'\" unpacked with wrong size!
  else
    echo shar: Uudecoding \"'msdos/makefile.gcc'\" \(2063 characters\)
    cat msdos/makefile.gcc.UU | uudecode
    if test 2063 -ne `wc -c <'msdos/makefile.gcc'`; then
      echo shar: \"'msdos/makefile.gcc'\" uudecoded with wrong size!
    else
      rm msdos/makefile.gcc.UU
    fi
  fi
  # end of 'msdos/makefile.gcc.UU'
fi
if test -f 'vms/vms.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/vms.c'\"
else
  echo shar: Extracting \"'vms/vms.c'\" \(18616 characters\)
  sed "s/^X//" >'vms/vms.c' <<'END_OF_FILE'
X/*************************************************************************
X *                                                                       *
X * VMS portions copyright (C) 1992 Igor Mandrichenko.                    *
X * Permission is granted to any individual or institution to use, copy,  *
X * or redistribute this software so long as all of the original files    *
X * are included unmodified, that it is not sold for profit, and that     *
X * this copyright notice is retained.                                    *
X *                                                                       *
X *************************************************************************/
X
X/*
X *  vms.c (zip) by Igor Mandrichenko    Version 2.1-1
X *
X *  Revision history:
X *  ...
X *  2.1-1       16-feb-1992     I.Mandrichenko  
X *      Get file size from XABFHC and check bytes rest in file before
X *      reading. 
X *  2.1-2       2-mar-1992      I.Mandrichenko
X *      Make code more standard
X *  2.2         21-jun-1992     I.Mandrichenko
X *      Free all allocated space, use more static storage.
X *      Use memcompress() from bits.c (deflation) for block compression.
X *      To revert to old compression method #define OLD_COMPRESS
X */
X
X#ifdef VMS                      /* For VMS only ! */
X
X#define OLD_COMPRESS    /*To use old compression method define it.*/
X
X#include <rms.h>
X#include <descrip.h>
X#include <syidef.h>
X
X#ifndef VAXC
X                                /* This definition may be missed */
Xstruct XAB {
X    unsigned char xab$b_cod;
X    unsigned char xab$b_bln;
X    short int xabdef$$_fill_1;
X    char *xab$l_nxt;
X};
X
X#endif
X
X#ifndef SYI$_VERSION
X#define SYI$_VERSION 4096       /* VMS 5.4 definition */
X#endif
X
X#include "zip.h"
X
X#define ERR(s)  !((s)&1)
X
X#define RET_ERROR 1
X#define RET_SUCCESS 0
X#define RET_EOF 0
X
X#define Kbyte 1024
X
Xtypedef struct XAB *xabptr;
X
X/*
X*   Extra record format
X*   ===================
X*   signature       (2 bytes)   = 'I','M'
X*   size            (2 bytes)
X*   block signature (4 bytes)
X*   flags           (2 butes)
X*   uncomprssed size(2 bytes)
X*   reserved        (4 bytes)
X*   data            (size-12 bytes)
X*   ....
X*/
X
X
X/*
X*   Extra field signature and block signatures
X*/
X#define SIGNATURE "IM"
X#define EXTBSL  4               /* Block signature length   */
X#define RESL    8
X
X#define BC_MASK         07      /* 3 bits for compression type */       
X#define BC_STORED       0       /* Stored */
X#define BC_00           1       /* 0byte -> 0bit compression */
X#define BC_DEFL         2       /* Deflated */
X
Xstruct extra_block
X{       ush     im_sig;
X        ush     size;
X        ulg     block_sig;
X        ush     flags;
X        ush     length;
X        ulg     reserved;
X        uch     body[1];        /* The actual size is unknown */
X};
X
X#define FABSIG  "VFAB"
X#define XALLSIG "VALL"
X#define XFHCSIG "VFHC"
X#define XDATSIG "VDAT"
X#define XRDTSIG "VRDT"
X#define XPROSIG "VPRO"
X#define XKEYSIG "VKEY"
X#define VERSIG  "VMSV"
X/*
X*   Block sizes
X*/
X#define FABL    (cc$rms_fab.fab$b_bln)
X#define RABL    (cc$rms_rab.rab$b_bln)
X#define XALLL   (cc$rms_xaball.xab$b_bln)
X#define XDATL   (cc$rms_xabdat.xab$b_bln)
X#define XFHCL   (cc$rms_xabfhc.xab$b_bln)
X#define XKEYL   (cc$rms_xabkey.xab$b_bln)
X#define XPROL   (cc$rms_xabpro.xab$b_bln)
X#define XRDTL   (cc$rms_xabrdt.xab$b_bln)
X#define XSUML   (cc$rms_xabsum.xab$b_bln)
X#define EXTHL   (4+EXTBSL+RESL)
X#define EXTL0   ((FABL + EXTHL)+        \
X                (XFHCL + EXTHL)+        \
X                (XPROL + EXTHL)+        \
X                (XDATL + EXTHL)+        \
X                (XRDTL + EXTHL))
X
X#ifdef OLD_COMPRESS
X#define PAD     sizeof(uch)
X#else
X#define PAD     10*sizeof(ush)          /* Two extra bytes for compr. header */
X#endif
X
X#define PAD0    (5*PAD)                 /* Reserve space for the case when
X                                        *  compression failes */
Xstatic int _compress();
X
X/***********************************
X *   Function get_vms_attributes   *
X ***********************************/
X
Xstatic uch *_compress_block();
Xstatic int get_vms_version();
X
Xint get_vms_attributes(z)
X  struct zlist *z;
X/*
X *      Get file VMS file attributes and store them into extent fields.
X *      Store VMS version also.
X *      On error leave z intact.
X */
X{
X    int status;
X    uch *extra=(uch*)NULL, *scan;
X    extent extra_l;
X    static struct FAB fab;
X    static struct XABSUM xabsum;
X    static struct XABFHC xabfhc;
X    static struct XABDAT xabdat;
X    static struct XABPRO xabpro;
X    static struct XABRDT xabrdt;
X    xabptr x = (xabptr)NULL, xab_chain = (xabptr)NULL, last_xab = (xabptr)NULL;
X    int nk, na;
X    int i;
X    int rc=RET_ERROR;
X    char verbuf[80];
X    int verlen = 0;
X
X    /*
X    *   Initialize RMS control blocks and link them
X    */
X
X    fab =    cc$rms_fab;
X    xabsum = cc$rms_xabsum;
X    xabdat = cc$rms_xabdat;
X    xabfhc = cc$rms_xabfhc;
X    xabpro = cc$rms_xabpro;
X    xabrdt = cc$rms_xabrdt;
X
X
X    fab.fab$l_xab = (char*)&xabsum;
X    /*
X    *   Open the file and read summary information.
X    */
X    fab.fab$b_fns = strlen(z->name);
X    fab.fab$l_fna = z->name;
X
X    status = sys$open(&fab);
X    if (ERR(status))
X    {
X#ifdef DEBUG
X        printf("get_vms_attributes: sys$open for file %s:\n  error status = %d\n",
X               z->name, status);
X#endif
X        goto err_exit;
X    }
X
X    nk = xabsum.xab$b_nok;
X    na = xabsum.xab$b_noa;
X#ifdef DEBUG
X    printf("%d keys, %d alls\n", nk, na);
X#endif
X
X    /*
X    *   Allocate XABKEY and XABALL blocks ind link them
X    */
X
X    xabfhc.xab$l_nxt = (char*)&xabdat;
X    xabdat.xab$l_nxt = (char*)&xabpro;
X    xabpro.xab$l_nxt = (char*)&xabrdt;
X    xabrdt.xab$l_nxt = (char*)0L;
X
X    xab_chain = (xabptr)(&xabfhc);
X    last_xab  = (xabptr)(&xabrdt);
X
X#define INIT(ptr,size,init)     \
X        if( (ptr = (uch*)malloc(size)) == NULL )        \
X        {                                               \
X              printf( "get_vms_attributes: Insufficient memory.\n" );   \
X                      goto err_exit;                    \
X        }                                               \
X        *(ptr) = (init);
X    /*
X    *   Allocate and initialize all needed XABKEYs and XABALLs
X    */
X    for (i = 0; i < nk; i++)
X    {
X        struct XABKEY *k;
X        INIT(k, XKEYL, cc$rms_xabkey);
X        k->xab$b_ref = i;
X        if (last_xab != 0L)
X            last_xab->xab$l_nxt = (char*)k;
X        last_xab = (xabptr)k;
X    }
X    for (i = 0; i < na; i++)
X    {
X        struct XABALL *a;
X        INIT(a, XALLL, cc$rms_xaball);
X        a->xab$b_aid = i;
X        if (last_xab != 0L)
X            last_xab->xab$l_nxt = (char*)a;
X        last_xab = (xabptr)a;
X    }
X
X    fab.fab$l_xab = (char*)xab_chain;
X#ifdef DEBUG
X    printf("Dump of XAB chain before DISPLAY:\n");
X    for (x = xab_chain; x != 0L; x = x->xab$l_nxt)
X        dump_rms_block(x);
X#endif
X    /*
X    *   Get information on the file structure etc.
X    */
X    status = sys$display(&fab, 0, 0);
X    if (ERR(status))
X    {
X#ifdef DEBUG
X        printf("get_vms_attributes: sys$display for file %s:\n  error status = %d\n",
X               z->name, status);
X#endif
X        goto err_exit;
X    }
X
X#ifdef DEBUG
X    printf("\nDump of XAB chain after DISPLAY:\n");
X    for (x = xab_chain; x != 0L; x = x->xab$l_nxt)
X        dump_rms_block(x);
X#endif
X
X    fab.fab$l_xab = 0;  /* Keep XABs */
X    status = sys$close(&fab);
X    if (ERR(status))
X    {
X#ifdef DEBUG
X        printf("get_vms_attributes: sys$close for file %s:\n  error status = %d\n",
X               z->name, status);
X#endif
X        goto err_exit;
X    }
X
X    extra_l = EXTL0 + nk * (XKEYL + EXTHL) + na * (XALLL + EXTHL);
X#ifndef OLD_COMPRESS
X    extra_l += PAD0 + (nk+na) * PAD;
X#endif
X
X    if( verlen = get_vms_version(verbuf,sizeof(verbuf)) )
X    {   extra_l += verlen + EXTHL;
X#ifndef OLD_COMPRESS
X        extra_l += PAD;
X#endif
X    }
X
X    if ((scan = extra = (uch *) malloc(extra_l)) == (uch*)NULL)
X    {
X#ifdef DEBUG
X        printf("get_vms_attributes: Insufficient memory to allocate extra buffer\n");
X#endif
X        goto err_exit;
X    }
X
X
X    if( verlen > 0 )
X        scan = _compress_block(scan,verbuf, verlen, VERSIG);
X
X    /*
X     *  Zero all unusable fields to improve compression
X     */
X    fab.fab$b_fns = fab.fab$b_shr = fab.fab$b_dns = fab.fab$b_fac = 0;
X    fab.fab$w_ifi = 0;
X    fab.fab$l_stv = fab.fab$l_sts = fab.fab$l_ctx = 0;
X    fab.fab$l_fna = fab.fab$l_nam = fab.fab$l_xab = fab.fab$l_dna = (char*)0L;
X
X#ifdef DEBUG
X    dump_rms_block( &fab );
X#endif
X    scan = _compress_block(scan,&fab, FABL, FABSIG);
X    for (x = xab_chain; x != 0L;)
X    {
X        int bln;
X        char *sig;
X        xabptr next;
X
X        next = (xabptr)(x->xab$l_nxt);
X        x->xab$l_nxt = 0;
X
X        switch (x->xab$b_cod)
X        {
X            case XAB$C_ALL:
X                bln = XALLL;
X                sig = XALLSIG;
X                break;
X            case XAB$C_KEY:
X                bln = XKEYL;
X                sig = XKEYSIG;
X                break;
X            case XAB$C_PRO:
X                bln = XPROL;
X                sig = XPROSIG;
X                break;
X            case XAB$C_FHC:
X                bln = XFHCL;
X                sig = XFHCSIG;
X                break;
X            case XAB$C_DAT:
X                bln = XDATL;
X                sig = XDATSIG;
X                break;
X            case XAB$C_RDT:
X                bln = XRDTL;
X                sig = XRDTSIG;
X                break;
X            default:
X                bln = 0;
X                sig = 0L;
X                break;
X        }
X        if (bln > 0)
X            scan = _compress_block(scan,x, bln, sig);
X        x = next;
X    }
X
X    z->ext = z->cext = scan-extra;
X    z->extra = z->cextra = (char*)extra;
X    rc = RET_SUCCESS;
X
Xerr_exit:
X    /*
X    * Give up all allocated blocks
X    */
X    for(x = (struct XAB *)xab_chain; x != 0L; )
X    {   struct XAB *next;
X        next = (xabptr)(x->xab$l_nxt);
X        if( x->xab$b_cod == XAB$C_ALL || x->xab$b_cod == XAB$C_KEY )
X                free(x);
X        x = next;
X    }
X    return rc;
X}
X
Xstatic int get_vms_version(verbuf,len)
Xchar *verbuf;
Xint len;
X{   int i = SYI$_VERSION;
X    int verlen = 0;
X    struct dsc$descriptor version;
X    char *m;
X
X    version.dsc$a_pointer = verbuf;
X    version.dsc$w_length  = len-1;
X    version.dsc$b_dtype   = DSC$K_DTYPE_B;
X    version.dsc$b_class   = DSC$K_CLASS_S;
X
X    if (ERR(lib$getsyi(&i, 0, &version, &verlen, 0, 0)) || verlen == 0)
X        return 0;
X
X    /* Cut out trailing spaces "V5.4-3   " -> "V5.4-3" */
X    for(m=verbuf+verlen,i=verlen-1; i>0 && verbuf[i]==' '; --i) 
X        --m;
X    *m = 0;
X
X    /* Cut out release number "V5.4-3" -> "V5.4" */
X    if( (m=strrchr(verbuf,'-')) != (char*)NULL )
X        *m = 0;
X    return strlen(verbuf)+1;    /* Transmit ending 0 too */
X}
X
X#define CTXSIG ((ulg)('CtXx'))
X
Xtypedef struct user_context
X{
X    ulg sig;
X    struct FAB *fab;
X    struct RAB *rab;
X    ulg size,rest;
X    int status;
X} Ctx, *Ctxptr;
X
XCtx init_ctx =  
X{       CTXSIG,
X        0L,
X        0L,
X        0L,
X        0L,
X        0
X};
X
X#define CTXL    sizeof(Ctx)
X#define CHECK_RAB(_r) ( (_r) != 0 &&                            \
X                        (_r) -> rab$b_bid == RAB$C_BID &&       \
X                        (_r) -> rab$b_bln == RAB$C_BLN &&       \
X                        (_r) -> rab$l_ctx != 0L     &&          \
X                        (_r) -> rab$l_fab != 0L )
X
X/**************************
X *   Function vms_open    *
X **************************/
Xstruct RAB *vms_open(name)
X    char *name;
X{
X    struct RAB *rab;
X    struct FAB *fab;
X    struct XABFHC *fhc;
X    Ctxptr ctx;
X
X    if ((fab = (struct FAB *) malloc(FABL)) == (struct FAB *)NULL)
X        return 0;
X    if ((rab = (struct RAB *) malloc(RABL)) == (struct RAB *)NULL)
X    {
X        free(fab);
X        return 0;
X    }
X    if ((fhc = (struct XABFHC *) malloc(XFHCL)) == (struct XABFHC *)NULL)
X    {
X        free(rab);
X        free(fab);
X        return 0;
X    }
X    if ((ctx = (Ctxptr) malloc(CTXL)) == (Ctxptr)NULL)
X    {
X        free(fhc);
X        free(fab);
X        free(rab);
X        return 0;
X    }
X    *fab = cc$rms_fab;
X    *rab = cc$rms_rab;
X    *fhc = cc$rms_xabfhc;
X
X    fab->fab$l_fna = name;
X    fab->fab$b_fns = strlen(name);
X    fab->fab$b_fac = FAB$M_GET | FAB$M_BIO;
X    fab->fab$l_xab = (char*)fhc;
X
X    if (ERR(sys$open(fab)))
X    {
X        sys$close(fab);
X        free(fhc);
X        free(fab);
X        free(rab);
X        free(ctx);
X        return 0;
X    }
X
X    rab->rab$l_fab = fab;
X    rab->rab$l_rop = RAB$M_BIO;
X
X    if (ERR(sys$connect(rab)))
X    {
X        sys$close(fab);
X        free(fab);
X        free(rab);
X        free(ctx);
X        return 0;
X    }
X
X    *ctx = init_ctx;
X    ctx->rab = rab;
X    ctx->fab = fab;
X
X    if( fhc->xab$l_ebk > 0 )
X        ctx->size = ctx->rest = ( fhc->xab$l_ebk-1 ) * 512 + fhc->xab$w_ffb;
X    else
X        ctx->size = ctx->rest = 0;
X    free(fhc);
X    fab -> fab$l_xab = 0;
X    rab->rab$l_ctx = (long)ctx;
X    return rab;
X}
X
X/**************************
X *   Function vms_close   *
X **************************/
Xint vms_close(rab)
X    struct RAB *rab;
X{
X    struct FAB *fab;
X    Ctxptr ctx;
X
X    if (!CHECK_RAB(rab))
X        return RET_ERROR;
X    fab = (ctx = (Ctxptr)(rab->rab$l_ctx))->fab;
X    sys$close(fab);
X
X    free(fab);
X    free(rab);
X    free(ctx);
X
X    return RET_SUCCESS;
X}
X
X/**************************
X *   Function vms_rewind  *
X **************************/
Xint vms_rewind(rab)
X    struct RAB *rab;
X{
X    Ctxptr ctx;
X
X    int status;
X    if (!CHECK_RAB(rab))
X        return RET_ERROR;
X
X    ctx = (Ctxptr) (rab->rab$l_ctx);
X    if (ERR(status = sys$rewind(rab)))
X    {
X        ctx->status = status;
X        return RET_ERROR;
X    }
X
X    ctx->status = 0;
X    ctx->rest = ctx->size;
X    
X    return RET_SUCCESS;
X}
X
X/**************************
X *   Function vms_read    *
X **************************/
Xint vms_read(rab, buf, size)
X    struct RAB *rab;
Xchar *buf;
Xint size;
X/*
X*       size must be greater or equal to 512 !
X*/
X{
X    int status;
X    Ctxptr ctx;
X
X    ctx = (Ctxptr)rab->rab$l_ctx;
X
X    if (!CHECK_RAB(rab))
X        return 0;
X
X    if (ctx -> rest <= 0)
X        return 0;               /* Eof */
X
X    if(size > 16*Kbyte)         /* RMS can not read too much */
X        size = 16*Kbyte;
X    else
X        size &= ~511L;
X
X    rab->rab$l_ubf = buf;
X    rab->rab$w_usz = size;
X    status = sys$read(rab);
X    if (!ERR(status) && rab->rab$w_rsz > 0)
X    {
X        ctx -> status = 0;
X        ctx -> rest -= rab->rab$w_rsz;
X        return rab->rab$w_rsz;
X    }
X    else
X    {
X        ctx->status = (status==RMS$_EOF ? 0:status);
X        if(status == RMS$_EOF)
X                ctx -> rest = 0L;
X        return 0;
X    }
X}
X
X/**************************
X *   Function vms_error   *
X **************************/
Xint vms_error(rab)
X    struct RAB *rab;
X{
X    if (!CHECK_RAB(rab))
X        return RET_ERROR;
X    return ((Ctxptr) (rab->rab$l_ctx))->status;
X}
X
X
Xdump_rms_block(p)
X    unsigned char *p;
X{
X    unsigned char bid, len;
X    int err;
X    char *type;
X    char buf[132];
X    int i;
X
X    err = 0;
X    bid = p[0];
X    len = p[1];
X    switch (bid)
X    {
X        case FAB$C_BID:
X            type = "FAB";
X            break;
X        case XAB$C_ALL:
X            type = "xabALL";
X            break;
X        case XAB$C_KEY:
X            type = "xabKEY";
X            break;
X        case XAB$C_DAT:
X            type = "xabDAT";
X            break;
X        case XAB$C_RDT:
X            type = "xabRDT";
X            break;
X        case XAB$C_FHC:
X            type = "xabFHC";
X            break;
X        case XAB$C_PRO:
X            type = "xabPRO";
X            break;
X        default:
X            type = "Unknown";
X            err = 1;
X            break;
X    }
X    printf("Block @%08X of type %s (%d).", p, type, bid);
X    if (err)
X    {
X        printf("\n");
X        return;
X    }
X    printf(" Size = %d\n", len);
X    printf(" Offset - Hex - Dec\n");
X    for (i = 0; i < len; i += 8)
X    {
X        int j;
X        printf("%3d - ", i);
X        for (j = 0; j < 8; j++)
X            if (i + j < len)
X                printf("%02X ", p[i + j]);
X            else
X                printf("   ");
X        printf(" - ");
X        for (j = 0; j < 8; j++)
X            if (i + j < len)
X                printf("%03d ", p[i + j]);
X            else
X                printf("    ");
X        printf("\n");
X    }
X}
X
X#ifdef OLD_COMPRESS
X# define BC_METHOD      BC_00
X# define        COMP_BLK(to,tos,from,froms) _compress( from,to,froms )
X#else
X# define BC_METHOD      BC_DEFL
X# define        COMP_BLK(to,tos,from,froms) memcompress(to,tos,from,froms)
X#endif
X
Xstatic uch *_compress_block(to,from,size,sig)
Xregister struct extra_block *to;
Xuch *from,*sig;
Xint size;
X{                               
X        ulg cl;
X        to -> im_sig =  *(ush*)SIGNATURE;
X        to -> block_sig =       *(ulg*)(sig);
X        to -> flags =           BC_METHOD;
X        to -> length =  size;
X#ifdef DEBUG
X        printf("\nmemcompr(%d,%d,%d,%d)\n",&(to->body[0]),size+PAD,from,size);
X#endif
X        cl = COMP_BLK( &(to->body[0]), size+PAD, from, size );
X#ifdef DEBUG
X        printf("Compressed to %d\n",cl);
X#endif
X        if( cl >= size )
X        {       memcpy(&(to->body[0]), from, size);
X                to->flags = BC_STORED;
X                cl = size;
X#ifdef DEBUG
X                printf("Storing block...\n");
X#endif
X        }
X        return (uch*)(to) + (to->size = cl + EXTBSL + RESL) + 4;
X}
X
X#define NBITS 32
X
Xstatic int _compress(from,to,size)
Xuch *from,*to;
Xint size;
X{
X    int off=0;
X    ulg bitbuf=0;
X    int bitcnt=0;
X    int i;
X
X#define _BIT(val,len)   {                       \
X        if(bitcnt + (len) > NBITS)              \
X            while(bitcnt >= 8)                  \
X            {                                   \
X                to[off++] = (uch)bitbuf;        \
X                bitbuf >>= 8;                   \
X                bitcnt -= 8;                    \
X            }                                   \
X        bitbuf |= ((ulg)(val))<<bitcnt;         \
X        bitcnt += len;                          \
X    }
X
X#define _FLUSH  {                               \
X            while(bitcnt>0)                     \
X            {                                   \
X                to[off++] = (uch)bitbuf;        \
X                bitbuf >>= 8;                   \
X                bitcnt -= 8;                    \
X            }                                   \
X        }
X
X    for(i=0; i<size; i++)
X    {
X        if( from[i] )
X        {
X                _BIT(1,1);
X                _BIT(from[i],8);
X        }
X        else
X            _BIT(0,1);
X    }
X    _FLUSH;
X    return off;
X}
X
X#endif                          /* ?VMS */
END_OF_FILE
  if test 18616 -ne `wc -c <'vms/vms.c'`; then
    echo shar: \"'vms/vms.c'\" unpacked with wrong size!
  fi
  # end of 'vms/vms.c'
fi
if test -f 'vms/vms_zip.rnh' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/vms_zip.rnh'\"
else
  echo shar: Extracting \"'vms/vms_zip.rnh'\" \(18026 characters\)
  sed "s/^X//" >'vms/vms_zip.rnh' <<'END_OF_FILE'
X.!
X.!  File:	ZIP.RNH
X.!
X.!  Author:	Hunter Goatley
X.!
X.!  Date:	October 22, 1991
X.!
X.!  Description:
X.!
X.!	RUNOFF source file for portable ZIP on-line help for VMS.
X.!	Adapted from ZIP.DOC, distributed with ZIP.
X.!
X.!	To build:	$ RUNOFF ZIP.RNH
X.!			$ LIBR/HELP/INSERT libr ZIP
X.!
X.!  Modification history:
X.!
X.!	Hunter Goatley		22-OCT-1991 20:45
X.!		Genesis.
X.!	Jean-loup Gailly	25 March 92
X.!		Adaptation to zip 1.6.
X.!	Igor Mandrichenko	9-JUN-1992
X.!		Added explanation of -V option.
X.!	Jean-loup Gailly	14 June 92
X.!		Adaptation to zip 1.8.
X.!	Jean-loup Gailly	20 Aug 92
X.!		Adaptation to zip 1.9.
X.!
X.noflags
X.lm4 .rm72
X.indent -4
X1 ZIP
X.br
XZip is a compression and file packaging utility for Unix, MSDOS, OS/2, and
XVMS.  It is analogous to a combination of tar and compress and is
Xcompatible with PKZIP (Phil Katz ZIP) for MSDOS systems.
X.sk
XThere is a companion to Zip called UnZip (of course).  Zip and UnZip can
Xwork with files produced by PKZIP under MSDOS, and PKZIP and PKUNZIP can
Xwork with files produced by Zip.
X.sk
XZip 1.9 is compatible with PKZIP 1.93a.
XNote that pkunzip 1.10 cannot extract files produced by pkzip 1.93a
Xor zip 1.9. You must use pkzip 1.93a or unzip 5.0 to extract them.
X.sk
XFor a brief help on Zip and Unzip, run each without specifying any
Xparameters on the command line.
X.sk
XZip puts one or more compressed files into a single "zip file" along with
Xinformation about the files, including the name, path if requested, date
Xand time last modified, protection, and check information to verify the
Xfidelity of each entry.  Zip can pack an entire directory structure in a
Xzip file with a single command.  Compression ratios of 2:1 to 3:1 are
Xcommon for text files.  Zip has has one compression method (deflation) and
Xcan also store files without compression. It automatically chooses the better
Xof the two for each file to be compressed.
X.sk
XZip is useful for packaging a set of files to send to someone or for
Xdistribution; for archiving or backing up files; and for saving disk space
Xby temporarily compressing unused files or directories.
X.sk
XFormat:
X.sk;.lm+1;.literal
XZIP [-options] [-b path] [-n suffixes] [-t mmddyy] zipfile file(s) [-x list]
X.end literal;.lm-1
X.!------------------------------------------------------------------------------
X.indent -4
X2 Options
X.br
XThe default action of Zip is to add or replace zipfile entries from list, which
Xcan include the special name -@ to read names from SYS$INPUT.  The following
Xlist of options was taken from the on-line help generated when Zip is run
Xwithout any command-line parameters:
X.sk
X.literal
X  -f   freshen: only changed files
X  -d   delete entries in zipfile
X  -k   simulate PKZIP made zipfile
X  -h   show this help
X  -r   recurse into directories
X  -q   quiet operation
X  -c   add one-line comments
X  -b   use "path" for temp files
X  -o   make zipfile as old as latest entry
X  -w   append the VMS version number to name stored in zip file
X  -x   exclude the names that follow from those operated on
X  -u   update: only changed or new files
X  -m   move into zipfile (delete files)
X  -g   allow growing existing zipfile
X  -l   translate end-of-lines
X  -j   junk (don't record) directory names
X  -0   store only
X  -1   compress faster
X  -9   compress better
X  -n   don't compress theses suffixes
X  -z   add zipfile comment
X  -t   only do files after "mmddyy"
X  -L   show software license
X  -V   save VMS file attributes
X.end literal
X.!------------------------------------------------------------------------------
X.indent -4
X2 How_To_Use_Zip
X.br
XThe simplest use of Zip is as follows:
X.sk;.indent 10;$ zip stuff *
X.sk
XThis will create the file "STUFF.ZIP" (assuming it does not exist) and put
Xall the files in the current directory in STUFF.ZIP in a compressed form.
XThe .ZIP suffix is added automatically, unless that file name given
Xcontains a dot already.  This allows specifying suffixes other than ".ZIP".
X.sk
XTo zip up an entire directory, the command:
X.sk;.indent 10
X$ zip -r foo *.*
X.sk
Xwill create the file "FOO.ZIP" containing all the files and directories in
Xthe in the current directory.  The "r" option means recurse through the
Xdirectory structure.
X.sk
XYou may want to make a zip file that contains the files in [.FOO], but not
Xrecord the directory name, FOO.  You can use the -j (junk path) option to
Xleave off the path:
X.sk;.indent 10
X$ zip -j foo [.foo]*.*
X.sk
XYou might be zipping to save disk space, in which case you could:
X.sk;.indent 10
X$ zip -rm foo *.txt
X.sk
Xwhere the "m" option means "move".  This will delete all files matching
X*.txt after making FOO.ZIP.  No deletions will be done until the zip has
Xcompleted with no errors.  This option is obviously more dangerous and
Xshould be used with care.
X.sk
XIf the zip file already exists, these commands will replace existing or add
Xnew entries to the zip file.  For example, if you were really short on disk
Xspace, you might not have enough room simultaneously to hold the directory
X[.FOO] and the compressed FOO.ZIP.  In this case, you could do it in steps.
XIf [.FOO] contained the subdirectories [.TOM], [.DICK], and [.HARRY], then
Xyou could:
X.sk;
X.indent 10;$ zip -rm foo [.foo.tom]
X.indent 10;$ zip -rm foo [.foo.dick]
X.indent 10;$ zip -rm foo [.foo.harry]
X.sk
Xwhere the first command would create FOO.ZIP, and the next two would add to
Xit.  At the completion of each zip command, the files in the directory just
Xzipped would be deleted, making room in which the next Zip command could
Xwork.
X.!------------------------------------------------------------------------------
X.indent -4
X2 Modifying_Existing_Zip_Files
X.br
XWhen given the name of an existing zip file with the above commands, Zip
Xwill replace identically named entries in the Zip file or add entries for
Xnew names.  For example, if FOO.ZIP exists and contains foo/file1 and
Xfoo/file2, and the directory [.FOO] contains the files foo/file1 and
Xfoo/file3, then:
X.sk;.indent 10
X$ zip -r foo foo
X.sk
Xwill replace foo/file1 in foo.zip and add foo/file3 to FOO.ZIP.  After
Xthis, FOO.ZIP contains foo/file1, foo/file2, and foo/file3, with foo/file2
Xunchanged from before.
X.sk
XWhen changing an existing zip file, Zip will write a temporary file with
Xthe new contents, and only replace the old one when the zip has completed
Xwith no errors. You can use
Xthe -b option to specify a different path (usually a different dev- ice) to
Xput the temporary files in.  For example:
X.sk;.indent 10
X$ zip -b scratch$:[tmp] stuff *
X.sk
Xwill put the temporary zip file and the temporary compression files in the
Xdirectory "SCRATCH$:[TMP]", copying over STUFF.ZIP in the current directory
Xwhen done.
X.sk
XIf you are only adding entries to a zip file, not replacing, and the -g
Xoption is given, then Zip grows (appends to) the file instead of copying
Xit.  The danger of this is that if the operation fails, the original zip
Xfile is corrupted and lost.
X.sk
XThere are two other ways to change or add entries in a zip file that are
Xrestrictions of simple addition or replacement.  The first is -u (update)
Xwhich will add new entries to the zip file as before but will replace
Xexisting entries only if the modified date of the file is more recent than
Xthe date recorded for that name in the zip file.  For example:
X.sk;.indent 10
X$ zip -u stuff *
X.sk
Xwill add any new files in the current directory, and update any changed
Xfiles in the zip file STUFF.ZIP.  Note that Zip will not try to pack
XSTUFF.ZIP into itself when you do this. Zip will always exclude the zip
Xfile from the files on which to be operated.
X.sk
XThe second restriction is -f (freshen) which, like update, will only
Xreplace entries with newer files; unlike update, will not add files that
Xare not already in the zip file. For this option, you may want to simply
Xfreshen all of the files that are in the specified zip file.  To do this
Xyou would simply:
X.sk;.indent 10
X$ zip -f foo
X.sk
XNote that the -f option with no arguments freshens all the entries in the
Xzip file.  The same is true of -u, and hence "zip -u foo" and "zip -f foo"
Xboth do the same thing.
X.sk
XThis command should be run from the same directory from which the original
Xzip command was run, since paths stored in zip files are always relative.
X.sk
XAnother restriction that can be used with adding, updating, or freshening
Xis -t (time), which will not operate on files modified earlier than the
Xspecified date.  For example:
X.sk;.indent 10
X$ zip -rt 120791 infamy [.FOO]*.*
X.sk
Xwill add all the files in [.FOO] and its subdirectories that were last
Xmodified on December 7, 1991, or later to the zip file INFAMY.ZIP.
X.sk
XAlso, files can be explicitly excluded using the -x option:
X.sk;.indent 10
X$ zip -r foo [.FOO] -x *.obj
X.sk
Xwhich will zip up the contents of [.FOO] into FOO.ZIP but exclude all the
Xfiles that end in ".OBJ".
X.sk
XThe last operation is -d (delete) which will remove entries from a zip
Xfile.  An example might be:
X.sk;.indent 10
X$ zip -d foo foo/harry/*.* *.obj
X.sk
Xwhich will remove all of the files that start with "foo/harry/" and all of
Xthe files that end with ".OBJ" (in any path).
X.sk
XUnder MSDOS, -d is case sensitive when it matches names in the zip file.
XThis allows deleting names that were zipped on other systems, but requires
Xthat the names be entered in upper case if they were zipped on an MSDOS
Xsystem, so that the names can be found in the zip file and deleted.
X.!------------------------------------------------------------------------------
X.indent -4
X2 More_Options
X.br
XAs mentioned before, Zip will use the best of two methods: deflate or store.
XThe option -0 will force Zip to use store on all files. For example:
X.sk;.indent 10
Xzip -r0 foo foo
X.sk
Xwill zip up the directory foo into foo.zip using only store.
X.sk
XThe speed of deflation can also be controlled with options -1 (fastest
Xmethod but less compression) to -9 (best compression but slower). The
Xdefault value is -5. For example:
X.sk;.indent 10
Xzip -r8 foo foo
X.sk
XIn nearly all cases, a file that is already compressed cannot be compressed
Xfurther by Zip, or if it can, the effect is minimal.  The -n option
Xprevents Zip from trying to compress files that have the
Xgiven suffixes.  Such files are simply stored (0%
Xcompression) in the
Xoutput zip file, so that Zip doesn't waste its time trying to compress
Xthem. The suffixes are separated by
Xeither colons or semicolons.  For example, in DCL:
X.sk
X.indent 10;$ zip -rn ".Z:.zip:.tiff:.gif:.snd" foo [.FOO]*.*
X.sk
Xwill put everything in [.FOO] into FOO.ZIP, but will store any files that end
Xin .Z, .ZIP, .TIFF, .GIF, or .SND without trying to compress them.  (Image and
Xsound files often have their own specialized compression methods.)
XThe default suffix list is ".Z:.zip;.zoo:.arc:.lzh:.arj".
XThe environment variable ZIPOPT can be used to change this default. For
Xexample:
X.sk
X.indent 10;$ ZIPOPT == "-n .Z:.zip:.tiff:.gif:.snd"
X.sk
XThe variable ZIPOPT can be used for any option and can include several
Xoptions.
X.sk
XUnder Unix and under OS/2 (if files from a HPFS are stored), Zip will store
Xthe full path (relative to the current path) and name of the file (or just
Xthe name if -j is specified) in the zip file along with the Unix
Xattributes, and it will mark the entry as made under Unix.  If the zip file
Xis intended for PKUNZIP under MSDOS, then the -k (Katz) option should be
Xused to attempt to convert the names and paths to conform to MSDOS, store
Xonly the MSDOS attribute (just the user write attribute from Unix), and
Xmark the entry as made under MSDOS (even though it wasn't).
X.sk
XThe -o (older) option will set the "last modified" time of the zip file to
Xthe latest "last modified" time of the entries in the zip file.  This can
Xbe used without any other operations, if desired.  For example:
X.sk;.indent 10
X$ zip -o foo
X.sk
Xwill change the last modified time of FOO.ZIP to the latest time of the
Xentries in FOO.ZIP.
X.sk
XThe -e and -c options operate on all files updated or added to the zip
Xfile.  Encryption (-e) will prompt for a password on the terminal and will
Xnot echo the password as it is typed (if stderr is not a TTY, Zip will exit
Xwith an error). New zip entries will be encrypted using that password.  For
Xadded peace of mind, you can use -ee, which will prompt for the password
Xtwice, checking that the two are the same before using it.
X.sk
XOne-line comments can be added for each file with the -c option.  The zip
Xfile operations (adding or updating) will be done first, and you will then
Xbe prompted for a one-line comment for each file.  You can then enter the
Xcomment followed by return, or just return for no comment.
X.sk
XThe -z option will prompt you for a multi-line comment for the entire zip
Xfile.  This option can be used by itself, or in combination with other
Xoptions.  The comment is ended by a line containing just a period, or an
Xend of file condition (^D on Unix, ^Z on MSDOS, OS/2, and VAX/VMS).
X.sk
XThe -q (quiet) option eliminates the informational messages and comment
Xprompts while Zip is operating.  This might be used in shell scripts, for
Xexample, or if the zip operation is being performed as a background task
X("$ spawn/nowait zip -q foo *.c").
X.sk
XZip can take a list of file names to operate on from SYS$INPUT using the
X"-@"
Xoption.
X.!  In Unix, this option can be used with the find command to extend
X.!greatly the functionality of Zip. For example, to zip up all the C source
X.!files in the current directory and its subdirectories, you can:
X.!.sk
X.!find . -type f -name "*.[ch]" -print | zip source -@
X.!.sk
X.!Note that the pattern must be quoted to keep the shell from expanding it.
X.sk
XUnder VMS only, the -w option will append the version number of the files
Xto the name and zip up multiple versions of files.  Without -w, Zip will
Xonly use the most recent version of the specified file(s).
X.sk
XOne more option that valid only under VMS is -V option. This option saves
Xall (hopefully) file attributes needed to make EXACT copy of the
Xfile after extraction from archive. To extract a file with saved attributes
Xuse UnZip version 4.2 or later. Note that to specify this option you should
Xquote it ("-V"). Be carefull: it's rather hard (if possible at all) to extract
Xa file archived on VMS with this option specified on other systems. See 
Xdocumentation on UnZip for further information.
X.sk
XThe -l option translates the Unix end-of-line character LF into the
XMSDOS convention CR LF. This option should not be used on binary files.
XThis option can be used on Unix if the zip file is intended for PKUNZIP
Xunder MSDOS.
X.sk
XIf Zip is run with the -h option, or with no arguments and standard output is
Xa terminal, the license and the command-argument and option help is shown.
XThe -L option just shows the license.
X.!------------------------------------------------------------------------------
X.indent -4
X2 Copyright
X.br
X     Copyright (C) 1990,1991 Mark Adler, Richard B. Wales, Jean-loup Gailly,
X     Igor Mandrichenko and Kai Uwe Rommel. Permission is granted to any
X     individual or institution to use, copy, or redistribute this software
X     so long as all of the original files are included unmodified,
X     that it is not sold for profit, and that this copyright
X     notice is retained.
X.!------------------------------------------------------------------------------
X.indent -4
X2 Acknowledgements
X.br
X     Thanks to R. P. Byrne for his Shrink.Pas program which
X     inspired this project; to Phil Katz for making the zip file format,
X     compression format, and .ZIP filename extension all public
X     domain; to Steve Burg and Phil Katz for help on unclear points of
X     the deflate format; to Keith Petersen for providing a mailing list and
X     ftp site for the INFO-ZIP group to use; and most importantly, to
X     the INFO-ZIP group itself (listed in the file
X     infozip.who) without whose tireless testing and bug-fixing
X     efforts a portable Zip would not have been possible.
X     Finally we should thank (blame) the INFO-ZIP moderator,
X     David Kirschbaum for getting us into this mess in the first
X     place.
X.!------------------------------------------------------------------------------
X.indent -4
X2 Bugs
X.sk
X     WARNING: zip files produced by this version of zip must not be
X     *updated* by zip 1.0 or pkzip 1.10 or pkzip 1.93a, if they contain
X     encrypted members, or if they have been produced in a pipe or on a non
X     seekable device. The old versions of zip or pkzip would destroy the
X     zip structure. The old versions can list the contents of the zip file
X     but cannot extract it anyway (because of the new compression algorithm).
X     If you do not use encryption and use regular disk files, you do
X     not have to care about this problem.
X.sk
X     Under VMS, not all of the odd file formats are treated properly.  Only
X     zip files of format stream-LF and fixed length 512 are expected to work
X     with Zip.  Others can be converted using Rahul Dhesi's BILF
X     program.  This version of Zip does handle some of the
X     conversion internally.
X     When using Kermit to transfer zip files from Vax to MSDOS, type "set
X     file type block" on the Vax.  When transfering from MSDOS to Vax, type
X     "set file type fixed" on the Vax.  In both cases, type "set file type
X     binary" on MSDOS.
X.sk
X     Under VMS, zip hangs for file specification that uses DECnet
X     syntax (foo::*.*).
X.sk
X     LIKE ANYTHING ELSE THAT'S FREE, ZIP AND ITS ASSOCIATED UTILITIES
X     ARE PROVIDED AS IS AND COME WITH NO WARRANTY OF ANY
X     KIND, EITHER EXPRESSED OR IMPLIED. IN NO EVENT WILL THE
X     COPYRIGHT HOLDERS BE LIABLE FOR ANY DAMAGES RESULTING FROM
X     THE USE OF THIS SOFTWARE.
X.sk
X     That having been said, please send any problems or comments
X     via email to the Internet address zip-bugs@cs.ucla.edu.  For
X     bug reports, please include the version of Zip, the make
X     options you used to compile it, the machine and operating
X     system you are using, and as much additional information as
X     possible.  Thank you for your support.
X.!------------------------------------------------------------------------------
END_OF_FILE
  if test 18026 -ne `wc -c <'vms/vms_zip.rnh'`; then
    echo shar: \"'vms/vms_zip.rnh'\" unpacked with wrong size!
  fi
  # end of 'vms/vms_zip.rnh'
fi
if test -f 'zipsplit.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zipsplit.c'\"
else
  echo shar: Extracting \"'zipsplit.c'\" \(17114 characters\)
  sed "s/^X//" >'zipsplit.c' <<'END_OF_FILE'
X/*
X
X Copyright (C) 1990-1992 Mark Adler, Richard B. Wales, Jean-loup Gailly,
X Kai Uwe Rommel and Igor Mandrichenko.
X Permission is granted to any individual or institution to use, copy, or
X redistribute this software so long as all of the original files are included
X unmodified, that it is not sold for profit, and that this copyright notice
X is retained.
X
X*/
X
X/*
X *  zipsplit.c by Mark Adler.
X */
X
X#define UTIL
X#include "revision.h"
X#include "zip.h"
X#include <signal.h>
X
X#define DEFSIZ 36000L   /* Default split size (change in help() too) */
X#ifdef MSDOS
X#  define NL 2          /* Number of bytes written for a \n */
X#else /* !MSDOS */
X#  define NL 1          /* Number of bytes written for a \n */
X#endif /* ?MSDOS */
X#define INDEX "zipsplit.idx"    /* Name of index file */
X
X
X/* Local functions */
X#ifdef PROTO
X   local void handler(int);
X   local void license(void);
X   local void help(void);
X   local extent simple(ulg *, extent, ulg, ulg);
X   local int descmp(voidp *, voidp *);
X   local extent greedy(ulg *, extent, ulg, ulg);
X   void main(int, char **);
X#endif /* PROTO */
X
X
X/* Output zip files */
Xlocal char template[16];        /* name template for output files */
Xlocal int zipsmade = 0;         /* number of zip files made */
Xlocal int indexmade = 0;        /* true if index file made */
Xlocal char *path = NULL;        /* space for full name */
Xlocal char *name;               /* where name goes in path[] */
X
X
Xvoid err(c, h)
Xint c;                  /* error code from the ZE_ class */
Xchar *h;                /* message about how it happened */
X/* Issue a message for the error, clean up files and memory, and exit. */
X{
X  if (PERR(c))
X    perror("zipsplit error");
X  fprintf(stderr, "zipsplit error: %s (%s)\n", errors[c-1], h);
X  if (indexmade)
X  {
X    strcpy(name, INDEX);
X    destroy(path);
X  }
X  for (; zipsmade; zipsmade--)
X  {
X    sprintf(name, template, zipsmade);
X    destroy(path);
X  }
X  if (path != NULL)
X    free((voidp *)path);
X  if (zipfile != NULL)
X    free((voidp *)zipfile);
X#ifdef VMS
X  exit(0);
X#else /* !VMS */
X  exit(c);
X#endif /* ?VMS */
X}
X
X
X
Xlocal void handler(s)
Xint s;                  /* signal number (ignored) */
X/* Upon getting a user interrupt, abort cleanly using err(). */
X{
X#ifndef MSDOS
X  putc('\n', stderr);
X#endif /* !MSDOS */
X  err(ZE_ABORT, "aborting");
X  s++;                                  /* keep some compilers happy */
X}
X
X
Xvoid warn(a, b)
Xchar *a, *b;            /* message strings juxtaposed in output */
X/* Print a warning message to stderr and return. */
X{
X  fprintf(stderr, "zipsplit warning: %s%s\n", a, b);
X}
X
X
Xlocal void license()
X/* Print license information to stdout. */
X{
X  extent i;             /* counter for copyright array */
X
X  for (i = 0; i < sizeof(copyright)/sizeof(char *); i++) {
X    printf(copyright[i], "zipsplit");
X    putchar('\n');
X  }
X  for (i = 0; i < sizeof(disclaimer)/sizeof(char *); i++)
X    puts(disclaimer[i]);
X}
X
X
Xlocal void help()
X/* Print help (along with license info) to stdout. */
X{
X  extent i;             /* counter for help array */
X
X  /* help array */
X  static char *text[] = {
X"",
X"ZipSplit %d.%d (%s)",
X"Usage:  zipsplit [-ti] [-n size] [-b path] zipfile",
X"  -t   report how many files it will take, but don't make them",
X"  -i   make index (zipsplit.idx) and count its size against first zip file",
X"  -n   make zip files no larger than \"size\" (default = 36000)",
X"  -b   use \"path\" for the output zip files",
X"  -s   do a sequential split even if it takes more zip files",
X"  -h   show this help               -L   show software license"
X  };
X
X  for (i = 0; i < sizeof(copyright)/sizeof(char *); i++) {
X    printf(copyright[i], "zipsplit");
X    putchar('\n');
X  }
X  for (i = 0; i < sizeof(text)/sizeof(char *); i++)
X  {
X    printf(text[i], REVISION / 10, REVISION % 10, REVDATE);
X    putchar('\n');
X  }
X}
X
X
Xlocal extent simple(a, n, c, d)
Xulg *a;         /* items to put in bins, return value: destination bins */
Xextent n;       /* number of items */
Xulg c;          /* capacity of each bin */
Xulg d;          /* amount to deduct from first bin */
X/* Return the number of bins of capacity c that are needed to contain the
X   integers in a[0..n-1] placed sequentially into the bins.  The value d
X   is deducted initially from the first bin (space for index).  The entries
X   in a[] are replaced by the destination bins. */
X{
X  extent k;     /* current bin number */
X  ulg t;        /* space used in current bin */
X
X  t = k = 0;
X  while (n--)
X  {
X    if (*a + t > c - (k == 0 ? d : 0))
X    {
X      k++;
X      t = 0;
X    }
X    t += *a;
X    *(ulg huge *)a++ = k;
X  }
X  return k + 1;
X}
X
X
Xlocal int descmp(a, b)
Xvoidp *a, *b;           /* pointers to pointers to ulg's to compare */
X/* Used by qsort() in greedy() to do a descending sort. */
X{
X  return **(ulg **)a < **(ulg **)b ? 1 : (**(ulg **)a > **(ulg **)b ? -1 : 0);
X}
X
X
Xlocal extent greedy(a, n, c, d)
Xulg *a;         /* items to put in bins, return value: destination bins */
Xextent n;       /* number of items */
Xulg c;          /* capacity of each bin */
Xulg d;          /* amount to deduct from first bin */
X/* Return the number of bins of capacity c that are needed to contain the
X   items with sizes a[0..n-1] placed non-sequentially into the bins.  The
X   value d is deducted initially from the first bin (space for index).
X   The entries in a[] are replaced by the destination bins. */
X{
X  ulg *b;       /* space left in each bin (malloc'ed for each m) */
X  ulg *e;       /* copy of argument a[] (malloc'ed) */
X  extent i;     /* steps through items */
X  extent j;     /* steps through bins */
X  extent k;     /* best bin to put current item in */
X  extent m;     /* current number of bins */
X  ulg **s;      /* pointers to e[], sorted descending (malloc'ed) */
X  ulg t;        /* space left in best bin (index k) */
X
X  /* Algorithm:
X     1. Copy a[] to e[] and sort pointers to e[0..n-1] (in s[]), in
X        descending order.
X     2. Compute total of s[] and set m to the smallest number of bins of
X        capacity c that can hold the total.
X     3. Allocate m bins.
X     4. For each item in s[], starting with the largest, put it in the
X        bin with the smallest current capacity greater than or equal to the
X        item's size.  If no bin has enough room, increment m and go to step 4.
X     5. Else, all items ended up in a bin--return m.
X  */
X
X  /* Copy a[] to e[], put pointers to e[] in s[], and sort s[].  Also compute
X     the initial number of bins (minus 1). */
X  if ((e = (ulg *)malloc(n * sizeof(ulg))) == NULL ||
X      (s = (ulg **)malloc(n * sizeof(ulg *))) == NULL)
X  {
X    if (e != NULL)
X      free((voidp *)e);
X    err(ZE_MEM, "was trying a smart split");
X    return 0;                           /* only to make compiler happy */
X  }
X  memcpy((char *)e, (char *)a, n * sizeof(ulg));
X  for (t = i = 0; i < n; i++)
X    t += *(s[i] = e + i);
X  m = (extent)((t + c - 1) / c) - 1;    /* pre-decrement for loop */
X  qsort((char *)s, n, sizeof(ulg *), descmp);
X
X  /* Stuff bins until successful */
X  do {
X    /* Increment the number of bins, allocate and initialize bins */
X    if ((b = (ulg *)malloc(++m * sizeof(ulg))) == NULL)
X    {
X      free((voidp *)s);
X      free((voidp *)e);
X      err(ZE_MEM, "was trying a smart split");
X    }
X    b[0] = c - d;                       /* leave space in first bin */
X    for (j = 1; j < m; j++)
X      b[j] = c;
X
X    /* Fill the bins greedily */
X    for (i = 0; i < n; i++)
X    {
X      /* Find smallest bin that will hold item i (size s[i]) */
X      t = c + 1;
X      for (k = j = 0; j < m; j++)
X        if (*s[i] <= b[j] && b[j] < t)
X          t = b[k = j];
X
X      /* If no bins big enough for *s[i], try next m */
X      if (t == c + 1)
X        break;
X
X      /* Diminish that bin and save where it goes */
X      b[k] -= *s[i];
X      a[(int)((ulg huge *)(s[i]) - (ulg huge *)e)] = k;
X    }
X
X    /* Clean up */
X    free((voidp *)b);
X
X    /* Do until all items put in a bin */
X  } while (i < n);
X
X  /* Done--clean up and return the number of bins needed */
X  free((voidp *)s);
X  free((voidp *)e);
X  return m;
X}
X
X
Xvoid main(argc, argv)
Xint argc;               /* number of tokens in command line */
Xchar **argv;            /* command line tokens */
X/* Split a zip file into several zip files less than a specified size.  See
X   the command help in help() above. */
X{
X  ulg *a;               /* malloc'ed list of sizes, dest bins */
X  extent *b;            /* heads of bin linked lists (malloc'ed) */
X  ulg c;                /* bin capacity, start of central directory */
X  int d;                /* if true, just report the number of disks */
X  FILE *e;              /* input zip file */
X  FILE *f;              /* output index and zip files */
X  extent g;             /* number of bins from greedy(), entry to write */
X  int h;                /* how to split--true means simple split, counter */
X  ulg i;                /* size of index file or zero if none */
X  extent j;             /* steps through zip entries, bins */
X  int k;                /* next argument type */
X  ulg *p;               /* malloc'ed list of sizes, dest bins for greedy() */
X  char *q;              /* steps through option characters */
X  int r;                /* temporary variable, counter */
X  extent s;             /* number of bins needed */
X  ulg t;                /* total of sizes, end of central directory */
X  struct zlist far **w; /* malloc'ed table for zfiles linked list */
X  int x;                /* if true, make an index file */
X  struct zlist far *z;  /* steps through zfiles linked list */
X
X
X  /* If no args, show help */
X  if (argc == 1)
X  {
X    help();
X    exit(0);
X  }
X
X  init_upper();           /* build case map table */
X
X  /* Go through args */
X  signal(SIGINT, handler);
X  signal(SIGTERM, handler);
X  k = h = x = d = 0;
X  c = DEFSIZ;
X  for (r = 1; r < argc; r++)
X    if (*argv[r] == '-')
X      if (argv[r][1])
X        for (q = argv[r]+1; *q; q++)
X          switch(*q)
X          {
X            case 'b':   /* Specify path for output files */
X              if (k)
X                err(ZE_PARMS, "options are separate and precede zip file");
X              else
X                k = 1;          /* Next non-option is path */
X              break;
X            case 'h':   /* Show help */
X              help();  exit(0);
X            case 'i':   /* Make an index file */
X              x = 1;
X              break;
X            case 'l': case 'L':  /* Show copyright and disclaimer */
X              license();  exit(0);
X            case 'n':   /* Specify maximum size of resulting zip files */
X              if (k)
X                err(ZE_PARMS, "options are separate and precede zip file");
X              else
X                k = 2;          /* Next non-option is size */
X              break;
X            case 's':
X              h = 1;    /* Only try simple */
X              break;
X            case 't':   /* Just report number of disks */
X              d = 1;
X              break;
X            default:
X              err(ZE_PARMS, "unknown option");
X          }
X      else
X        err(ZE_PARMS, "zip file cannot be stdin");
X    else
X      if (k == 0)
X        if (zipfile == NULL)
X        {
X          if ((zipfile = ziptyp(argv[r])) == NULL)
X            err(ZE_MEM, "was processing arguments");
X        }
X        else
X          err(ZE_PARMS, "can only specify one zip file");
X      else if (k == 1)
X      {
X        tempath = argv[r];
X        k = 0;
X      }
X      else              /* k must be 2 */
X      {
X        if ((c = (ulg)atol(argv[r])) < 100)     /* 100 is smallest zip file */
X          err(ZE_PARMS, "invalid size given");
X        k = 0;
X      }
X  if (zipfile == NULL)
X    err(ZE_PARMS, "need to specify zip file");
X
X
X  /* Read zip file */
X  if ((r = readzipfile()) != ZE_OK)
X    err(r, zipfile);
X  if (zfiles == NULL)
X    err(ZE_NAME, zipfile);
X
X  /* Make a list of sizes and check against capacity.  Also compute the
X     size of the index file. */
X  c -= ENDHEAD + 4;                     /* subtract overhead/zipfile */
X  if ((a = (ulg *)malloc(zcount * sizeof(ulg))) == NULL ||
X      (w = (struct zlist far **)malloc(zcount * sizeof(struct zlist far *))) ==
X       NULL)
X  {
X    if (a != NULL)
X      free((voidp *)a);
X    err(ZE_MEM, "was computing split");
X    return;
X  }
X  i = t = 0;
X  for (j = 0, z = zfiles; j < zcount; j++, z = z->nxt)
X  {
X    w[j] = z;
X    if (x)
X      i += z->nam + 6 + NL;
X    t += a[j] = 8 + LOCHEAD + CENHEAD +
X           2 * (ulg)z->nam + 2 * (ulg)z->ext + z->com + z->siz;
X    if (a[j] > c)
X    {
X      free((voidp *)w);  free((voidp *)a);
X      err(ZE_BIG, z->zname);
X    }
X  }
X
X  /* Decide on split to use, report number of files */
X  if (h)
X    s = simple(a, zcount, c, i);
X  else
X  {
X    if ((p = (ulg *)malloc(zcount * sizeof(ulg))) == NULL)
X    {
X      free((voidp *)w);  free((voidp *)a);
X      err(ZE_MEM, "was computing split");
X    }
X    memcpy((char *)p, (char *)a, zcount * sizeof(ulg));
X    s = simple(a, zcount, c, i);
X    g = greedy(p, zcount, c, i);
X    if (s <= g)
X      free((voidp *)p);
X    else
X    {
X      free((voidp *)a);
X      a = p;
X      s = g;
X    }
X  }
X  printf("%d zip files w%s be made (%d%% efficiency)\n",
X         s, d ? "ould" : "ill", ((200 * ((t + c - 1)/c)) / s + 1) >> 1);
X  if (d)
X  {
X    free((voidp *)w);  free((voidp *)a);
X    free((voidp *)zipfile);
X    zipfile = NULL;
X    return;
X  }
X
X  /* Set up path for output files */
X  if ((path = malloc(tempath == NULL ? 13 : strlen(tempath) + 14)) == NULL)
X    err(ZE_MEM, "was making output file names");
X  if (tempath == NULL)
X     name = path;
X  else
X  {
X    strcpy(path, tempath);
X    if (path[0] && path[strlen(path) - 1] != '/')
X      strcat(path, "/");
X    name = path + strlen(path);
X  }
X
X  /* Write the index file */
X  if (x)
X  {
X    strcpy(name, INDEX);
X    printf("creating %s\n", path);
X    indexmade = 1;
X    if ((f = fopen(path, "w")) == NULL)
X    {
X      free((voidp *)w);  free((voidp *)a);
X      err(ZE_CREAT, path);
X    }
X    for (j = 0; j < zcount; j++)
X      fprintf(f, "%5ld %s\n", a[j] + 1, w[j]->zname);
X    if ((j = ferror(f)) != 0 || fclose(f))
X    {
X      if (j)
X        fclose(f);
X      free((voidp *)w);  free((voidp *)a);
X      err(ZE_WRITE, path);
X    }
X  }
X
X  /* Make linked lists of results */
X  if ((b = (extent *)malloc(s * sizeof(extent))) == NULL)
X  {
X    free((voidp *)w);  free((voidp *)a);
X    err(ZE_MEM, "was computing split");
X  }
X  for (j = 0; j < s; j++)
X    b[j] = (extent)-1;
X  j = zcount;
X  while (j--)
X  {
X    g = (extent)a[j];
X    a[j] = b[g];
X    b[g] = j;
X  }
X
X  /* Make a name template for the zip files that is eight or less characters
X     before the .zip, and that will not overwrite the original zip file. */
X  for (k = 1, j = s; j >= 10; j /= 10)
X    k++;
X  if (k > 7)
X  {
X    free((voidp *)b);  free((voidp *)w);  free((voidp *)a);
X    err(ZE_PARMS, "way too many zip files must be made");
X  }
X#ifdef VMS
X  if ((q = strrchr(zipfile, ']')) != NULL)
X#else /* !VMS */
X  if ((q = strrchr(zipfile, '/')) != NULL)
X#endif /* ?VMS */
X    q++;
X  else
X    q = zipfile;
X  r = 0;
X  while ((g = *q++) != 0 && g != '.' && r < 8 - k)
X    template[r++] = (char)g;
X  if (r == 0)
X    template[r++] = '_';
X  else if (g >= '0' && g <= '9')
X    template[r - 1] = (char)(template[r - 1] == '_' ? '-' : '_');
X  sprintf(template + r, "%%0%dd.zip", k);
X
X  /* Make the zip files from the linked lists of entry numbers */
X  if ((e = fopen(zipfile, FOPR)) == NULL)
X  {
X    free((voidp *)b);  free((voidp *)w);  free((voidp *)a);
X    err(ZE_NAME, zipfile);
X  }
X  free((voidp *)zipfile);
X  zipfile = NULL;
X  for (j = 0; j < s; j++)
X  {
X    sprintf(name, template, j + 1);
X    printf("creating %s\n", path);
X    zipsmade = j + 1;
X    if ((f = fopen(path, FOPW)) == NULL)
X    {
X      free((voidp *)b);  free((voidp *)w);  free((voidp *)a);
X      err(ZE_CREAT, path);
X    }
X    tempzn = 0;
X    for (g = b[j]; g != (extent)-1; g = (extent)a[g])
X    {
X      if (fseek(e, w[g]->off, SEEK_SET))
X      {
X        free((voidp *)b);  free((voidp *)w);  free((voidp *)a);
X        err(ferror(e) ? ZE_READ : ZE_EOF, zipfile);
X      }
X      if ((r = zipcopy(w[g], e, f)) != ZE_OK)
X      {
X        free((voidp *)b);  free((voidp *)w);  free((voidp *)a);
X        if (r == ZE_TEMP)
X          err(ZE_WRITE, path);
X        else
X          err(r, zipfile);
X      }
X    }
X    if ((c = ftell(f)) == -1L)
X    {
X      free((voidp *)b);  free((voidp *)w);  free((voidp *)a);
X      err(ZE_WRITE, path);
X    }
X    for (g = b[j], k = 0; g != (extent)-1; g = (extent)a[g], k++)
X      if ((r = putcentral(w[g], f)) != ZE_OK)
X      {
X        free((voidp *)b);  free((voidp *)w);  free((voidp *)a);
X        err(ZE_WRITE, path);
X      }
X    if ((t = ftell(f)) == -1L)
X    {
X      free((voidp *)b);  free((voidp *)w);  free((voidp *)a);
X      err(ZE_WRITE, path);
X    }
X    if ((r = putend(k, t - c, c, (extent)0, (char *)NULL, f)) != ZE_OK)
X    {
X      free((voidp *)b);  free((voidp *)w);  free((voidp *)a);
X      err(ZE_WRITE, path);
X    }
X    if (ferror(f) || fclose(f))
X    {
X      free((voidp *)b);  free((voidp *)w);  free((voidp *)a);
X      err(ZE_WRITE, path);
X    }
X  }
X  free((voidp *)b);  free((voidp *)w);  free((voidp *)a);
X  fclose(e);
X
X  /* Done! */
X  exit(0);
X}
END_OF_FILE
  if test 17114 -ne `wc -c <'zipsplit.c'`; then
    echo shar: \"'zipsplit.c'\" unpacked with wrong size!
  fi
  # end of 'zipsplit.c'
fi
echo shar: End of archive 7 \(of 11\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
