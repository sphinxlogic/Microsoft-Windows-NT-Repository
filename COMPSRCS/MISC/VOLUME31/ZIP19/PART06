Newsgroups: comp.sources.misc
From: zip-bugs@cs.ucla.edu (Info-ZIP group)
Subject:  v31i098:  zip19 - Info-ZIP portable Zip, version 1.9, Part06/11
Message-ID: <1992Aug23.064718.29270@sparky.imd.sterling.com>
X-Md4-Signature: cc24ed17dbea073912fe1473810d2c72
Date: Sun, 23 Aug 1992 06:47:18 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: zip-bugs@cs.ucla.edu (Info-ZIP group)
Posting-number: Volume 31, Issue 98
Archive-name: zip19/part06
Supersedes: zip: Volume 23, Issue 88-96
Environment: UNIX, VMS, OS/2, MS-DOS, MACINTOSH, WIN-NT, LINUX, MINIX, XOS, !AMIGA, ATARI, symlink, SGI, DEC, Cray, Convex, Amdahl, Sun, PC

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  os2/zip.def.UU zip.1 zip.h zipfile.c
# Wrapped by kent@sparky on Sun Aug 23 01:00:45 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 6 (of 11)."'
if test -f 'os2/zip.def.UU' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os2/zip.def.UU'\"
else
  echo shar: Extracting \"'os2/zip.def.UU'\" \(152 characters\)
  sed "s/^X//" >'os2/zip.def.UU' <<'END_OF_FILE'
Xbegin 666 os2/zip.def
XM3D%-12!724Y$3U=#3TU0050@3D571DE,15,-"D1%4T-225!424].("=4:&4@
XK=V]R;&0M9F%M;W5S('II<"!U=&EL:71I97,@9G)O;2!);F9O+5I)4"<-"F4@
X 
Xend
END_OF_FILE
 if test 152 -ne `wc -c <'os2/zip.def.UU'`; then
    echo shar: \"'os2/zip.def.UU'\" unpacked with wrong size!
  else
    echo shar: Uudecoding \"'os2/zip.def'\" \(88 characters\)
    cat os2/zip.def.UU | uudecode
    if test 88 -ne `wc -c <'os2/zip.def'`; then
      echo shar: \"'os2/zip.def'\" uudecoded with wrong size!
    else
      rm os2/zip.def.UU
    fi
  fi
  # end of 'os2/zip.def.UU'
fi
if test -f 'zip.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zip.1'\"
else
  echo shar: Extracting \"'zip.1'\" \(21796 characters\)
  sed "s/^X//" >'zip.1' <<'END_OF_FILE'
X.\" Copyright (C) 1990-1992 Mark Adler, Richard B. Wales, Jean-loup Gailly,
X.\" Kai Uwe Rommel and Igor Mandrichenko.
X.\" Permission is granted to any individual or institution to use, copy, or
X.\" redistribute this software so long as all of the original files are included
X.\" unmodified, that it is not sold for profit, and that this copyright notice
X.\" is retained.
X.\"
X.\" zip.1 by Mark Adler.
X.\"
X.TH ZIP 1
X.SH NAME
Xzip, zipcloak, zipnote, zipsplit \- package and compress (archive) files
X.SH SYNOPSIS
X.B zip
X[
X.B \-cdeEfghjklmoqruwyz@
X] [
X.B \-b
Xtemppath ] [
X.B \-n
Xsuffixes ] [
X.B \-t
Xmmddyy ] [ zipfile list ] [
X.B \-x
Xlist ]
X.PP
X.B zipcloak
X[
X.B \-d
X] [
X.BI -b " path"
X]
X.I zipfile
X.PP
X.B zipnote
X[
X.B -w
X] [
X.BI \-b " path"
X]
X.I zipfile
X.PP
X.B zipsplit
X[
X.B \-ti
X] [
X.BI \-n " size"
X] [
X.BI \-b " path"
X]
X.I zipfile
X.br
X.SH DESCRIPTION
X.I zip
Xis a compression and file packaging utility for Unix, VMS, MSDOS,
XOS/2, Windows NT, Minix, Atari and Macintosh.  It is analogous to a
Xcombination of tar and compress and is compatible with PKZIP (Phil
XKatz ZIP) for MSDOS systems.
X.PP
XThere is a companion to
X.I zip
Xcalled
X.I unzip
X(of course) which you should be able
Xto find the same place you got
X.I zip.  zip
Xand
X.I unzip
Xcan work with files
Xproduced by PKZIP under MSDOS, and PKZIP and PKUNZIP can work with files
Xproduced by
X.I zip.
X.PP
X.I zip
Xversion 1.9 is compatible with pkzip 1.93a.
XNote that pkunzip 1.10 cannot extract files produced by pkzip 1.93a
Xor zip 1.9. You must use pkunzip 1.93a or unzip 5.0 to extract them.
X.PP
XFor a brief help on
X.I zip
Xand
X.I unzip,
Xrun each without specifying any parameters on the command line.
X.PP
X.I zip
Xputs one or more compressed files into a single "zip file" along with
Xinformation about the files, including the name, path if requested, date
Xand time last modified, protection, and check information to verify the
Xfidelity of each entry.
X.I zip
Xcan also be used as a filter, compressing standard input to standard output.
X.I zip
Xcan pack an entire directory structure in a
Xzip file with a single command.  Compression ratios of 2:1 to 3:1 are
Xcommon for text files.
X.I zip
Xhas one compression method (deflation) and can also store files without
Xcompression. It automatically chooses the better of the two for each file
Xto be compressed.
X.PP
X.I zip
Xis useful for packaging a set of files to send to someone or for distribution;
Xfor archiving or backing up files; and for saving disk space by temporarily
Xcompressing unused files or directories.
X.SH "HOW TO USE ZIP"
XThe simplest use of
X.I zip
Xis as follows:
X.PP
X.ti +5n
Xzip stuff *
X.PP
XThis will create the file "stuff.zip" (assuming it does not exist) and put
Xall the files in the current directory in stuff.zip in a compressed form.
XThe .zip suffix is added automatically, unless that file name given contains
Xa dot already.  This allows specifying suffixes other than ".zip".
X.PP
XBecause of the way the shell does filename substitution, files that start
Xwith a "." are not included.  To include those as well, you can:
X.PP
X.ti +5n
Xzip stuff .* *
X.PP
XEven this will not include any subdirectories that are in the current
Xdirectory.  To zip up an entire directory, the command:
X.PP
X.ti +5n
Xzip -r foo foo
X.PP
Xwill create the file "foo.zip" containing all the files and directories in
Xthe directory "foo" that is in the current directory. (The first "foo" denotes
Xthe zip file, the second one denotes the directory.)  The "r" option means
Xrecurse through the directory structure.  In this case, all the
Xfiles and directories in foo are zipped, including the ones that start with
Xa ".", since the recursion does not use the shell's file-name substitution.
XYou should not use -r with the name ".*", since that matches ".." which will
Xattempt to zip up the parent directory--probably not what was intended.
X.PP
XYou may want to make a zip file that contains the files in foo, but not record
Xthe directory name, foo.  You can use the -j (junk path) option to leave off
Xthe path:
X.PP
X.ti +5n
Xzip -j foo foo/*
X.PP
XThe -y option (only under Unix) will store symbolic links as such in the
Xzip file, instead of compressing and storing the file referred to in the link.
X.PP
XYou might be zipping to save disk space, in which case you could:
X.PP
X.ti +5n
Xzip -rm foo foo
X.PP
Xwhere the "m" option means "move".  This will delete foo and its contents
Xafter making foo.zip.  No deletions will be done until the zip has completed
Xwith no errors.  This option is obviously more dangerous and should be
Xused with care.
X.PP
XIf the zip file already exists, these commands will replace existing or add
Xnew entries to the zip file.  For example, if you were really short on disk
Xspace, you might not have enough room simultaneously to hold the directory
Xfoo and the compressed foo.zip.  In this case, you could do it in steps.  If
Xfoo contained the subdirectories tom, dick, and harry, then you could:
X.PP
X.ti +5n
Xzip -rm foo foo/tom
X.ti +5n
Xzip -rm foo foo/dick
X.ti +5n
Xzip -rm foo foo/harry
X.PP
Xwhere the first command would create foo.zip, and the next two would add to
Xit.  At the completion of each zip command, the directory just zipped would
Xbe deleted, making room in which the next
X.I zip
Xcommand could work.
X.PP
X.I zip
Xwill also accept a single dash ("-") as the zip file name, in which case it
Xwill write the zip file to stdout, allowing the output to be piped to another
Xprogram. For example:
X.PP
X.ti +5n
Xzip -r - . | dd of=/dev/nrst0 obs=16k
X.PP
Xwould write the zip output directly to a tape with the specified block size
Xfor the purpose of backing up the current directory.
X.PP
X.I zip
Xalso accepts a single dash ("-") as the name of a file to be compressed, in
Xwhich case it will read the zip file from stdin, allowing zip to take
Xinput from another program. For example:
X.PP
X.ti +5n
Xtar cf - . | zip backup -
X.PP
Xwould compress the output of the tar command for the purpose of backing up
Xthe current directory. This generally produces better compression than
Xthe previous example using the -r option, because
X.I zip
Xcan take advantage of redundancy between files. The backup can be restored
Xusing the command
X.PP
X.ti +5n
Xunzip -p backup | tar xf -
X.PP
XWhen no zip file name is given and stdout is not a terminal,
X.I zip
Xacts as a filter, compressing standard input to standard output.
XFor example,
X.PP
X.ti +5n
Xtar cf - . | zip | dd of=/dev/nrst0
X.PP
Xis equivalent to
X.PP
X.ti +5n
Xtar cf - . | zip - - | dd of=/dev/nrst0
X.PP
XZip archives created in this manner can be extracted with the program
X.I funzip
Xwhich is provided in the
X.I unzip
Xpackage. For example,
X.PP
X.ti +5n
X   dd if=/dev/nrst0 | funzip | tar xvf -
X.SH "MODIFYING EXISTING ZIP FILES"
XWhen given the name of an existing zip file with the above commands,
X.I zip
Xwill replace identically named entries in the
X.I zip
Xfile or add entries for
Xnew names.  For example, if foo.zip exists and contains foo/file1 and
Xfoo/file2, and the directory foo contains the files foo/file1 and foo/file3,
Xthen:
X.PP
X.ti +5n
Xzip -r foo foo
X.PP
Xwill replace foo/file1 in foo.zip and add foo/file3 to foo.zip.  After
Xthis, foo.zip contains foo/file1, foo/file2, and foo/file3, with foo/file2
Xunchanged from before.
X.PP
XWhen changing an existing zip file,
X.I zip
Xwill write a temporary file with
Xthe new contents, and only replace the old one when the zip has completed
Xwith no errors. You can use
Xthe -b option to specify a different path (usually a different device) to
Xput the temporary file in.  For example:
X.PP
X.ti +5n
Xzip -b /tmp stuff *
X.PP
Xwill put the temporary zip file and the temporary compression files in the
Xdirectory "/tmp", copying over stuff.zip in the current directory when
Xdone.
X.PP
XIf you are only adding entries to a zip file, not replacing, and the
X-g option is given, then
X.I zip
Xgrows (appends to) the file instead of copying it.  The danger of this is that
Xif the operation fails, the original zip file is corrupted and lost.
X.PP
XThere are two other ways to change or add entries in a zip file that are
Xrestrictions of simple addition or replacement.  The first is -u (update)
Xwhich will add new entries to the zip file as before but will replace
Xexisting entries only if the modified date of the file is more recent than
Xthe date recorded for that name in the zip file.  For example:
X.PP
X.ti +5n
Xzip -u stuff *
X.PP
Xwill add any new files in the current directory, and update any changed files
Xin the zip file stuff.zip.  Note that
X.I zip
Xwill not try to pack stuff.zip into
Xitself when you do this. 
X.I zip
Xwill always exclude the zip file from the files on which to be operated.
X.PP
XThe second restriction is -f (freshen) which, like update, will only replace
Xentries with newer files; unlike update, will not add files that are not
Xalready in the zip file.  For this option, you may want to simply freshen all
Xof the files that are in the specified zip file.  To do this you would simply:
X.PP
X.ti +5n
Xzip -f foo
X.PP
XNote that the -f option with no arguments freshens all the entries in the
Xzip file.  The same is true of -u, and hence "zip -u foo" and "zip -f foo"
Xboth do the same thing.
X.PP
XThis command should
Xbe run from the same directory from which the original zip command was run,
Xsince paths stored in zip files are always relative.
X.PP
XAnother restriction that can be used with adding, updating, or freshening is
X-t (time), which will not operate on files modified earlier than the specified
Xdate.  For example:
X.PP
X.ti +5n
Xzip -rt 120791 infamy foo
X.PP
Xwill add all the files in foo and its subdirectories that were last modified
Xon December 7, 1991, or later to the zip file infamy.zip.
X.PP
XAlso, files can be explicitly excluded using the -x option:
X.PP
X.ti +5n
Xzip -r foo foo -x \\*.o
X.PP
Xwhich will zip up the contents of foo into foo.zip but exclude all the
Xfiles that end in ".o".  Here the backslash causes
X.I zip
Xto match file names
Xthat were found when foo was searched.
X.PP
XThe last operation is -d (delete) which will remove entries from a zip file.
XAn example might be:
X.PP
X.ti +5n
Xzip -d foo foo/tom/junk foo/harry/\\* \\*.o
X.PP
Xwhich will remove the entry foo/tom/junk, all of the files that start with
X"foo/harry/", and all of the files that end with ".o" (in any path).  Note
Xthat once again, the shell expansion has been inhibited with backslashes, so
Xthat
X.I zip
Xcan see the asterisks.  
X.I zip
Xcan then match on the contents of the zip
Xfile instead of the contents of the current directory.
X.PP
XUnder MSDOS, -d is case sensitive when it matches names in the zip file.
XThis allows deleting names that were zipped on other systems, but requires
Xthat the names be entered in upper case if they were zipped on an MSDOS
Xsystem, so that the names can be found in the zip file and deleted.
X.SH "MORE OPTIONS"
XAs mentioned before,
X.I zip
Xwill use the best of two methods: deflate or store.
X.PP
XThe option -0 will force
X.I zip
Xto use store on all files. For example:
X.PP
X.ti +5n
Xzip -r0 foo foo
X.PP
Xwill zip up the directory foo into foo.zip using only store.
X.PP
XThe speed of deflation can also be controlled with options -1 (fastest
Xmethod but less compression) to -9 (best compression but slower). The
Xdefault value is -5. For example:
X.PP
X.ti +5n
Xzip -r8 foo foo
X.PP
XIn nearly all cases, a file that is already compressed cannot be compressed
Xfurther by
X.I zip,
Xor if it can, the effect is minimal.  The -n option prevents
X.I zip
Xfrom trying to compress files that have the given suffixes.
XSuch files are simply stored (0% compression) in the output zip file,
Xso that
X.I zip
Xdoesn't waste its time trying to compress them.
XThe suffixes are separated by
Xeither colons or semicolons.  For example:
X.PP
X.ti +5n
Xzip -rn ".Z:.zip:.tiff:.gif:.snd"  foo foo
X.PP
Xwill put everything in foo into foo.zip, but will store any files that end
Xin .Z, .zip, .tiff, .gif, or .snd without trying to compress them.  (Image
Xand sound files often have their own specialized compression methods.)
XThe default suffix list is ".Z:.zip;.zoo:.arc:.lzh:.arj".
XThe environment variable ZIPOPT can be used to change this default. For
Xexample under Unix with csh:
X.PP
X.ti +5n
Xsetenv ZIPOPT "-n .gif:.zip"
X.PP
XThe variable ZIPOPT can be used for any option and can include several
Xoptions.
X.PP
XUnder Unix and under OS/2 (if files from an HPFS are stored),
X.I zip
Xwill store the full path (relative to the current path) and name of the
Xfile (or just the name if -j is specified) in the zip file along with the
XUnix attributes, and it will mark
Xthe entry as made under Unix.  If the zip file is intended for PKUNZIP under
XMSDOS, then the -k (Katz) option should be used to attempt to convert the
Xnames and paths to conform to MSDOS, store only the MSDOS attribute (just
Xthe user write attribute from Unix), and mark the entry as made under MSDOS
X(even though it wasn't).
X.PP
XThe -o (older) option will set the "last modified" time of the zip file to
Xthe latest "last modified" time of the entries in the zip file.  This can
Xbe used without any other operations, if desired.  For example:
X.PP
X.ti +5n
Xzip -o foo
X.PP
Xwill change the last modified time of foo.zip to the latest time of the
Xentries in foo.zip.
X.PP
XThe -e and -c options operate on all files updated or added to the zip file.
XEncryption (-e) will prompt for a password on the terminal and will
Xnot echo the password as it is typed (if stderr is not a TTY, zip will exit
Xwith an error).  New zip entries will be encrypted using that password.  For
Xadded peace of mind, you can use -ee, which will prompt for the password
Xtwice, checking that the two are the same before using it. The encryption
Xcode is distributed separately, so the -e option may not be available
Xin your version.
X.PP
XOne-line comments can be added for each file with the -c option.  The zip
Xfile operations (adding or updating) will be done first, and you will then be
Xprompted for a one-line comment for each file.  You can then enter the comment
Xfollowed by return, or just return for no comment.
X.PP
XThe -z option will prompt you for a multi-line comment for the entire zip
Xfile.  This option can be used by itself, or in combination with other
Xoptions.  The comment is ended by a line containing just a period, or an end
Xof file condition (^D on Unix, ^Z on MSDOS, OS/2, and VAX/VMS).
XSince -z reads the
Xlines from stdin, you can simply take the comment from a file:
X.PP
X.ti +5n
Xzip -z foo < foowhat
X.PP
XThe -q (quiet) option eliminates the informational messages and comment prompts
Xwhile
X.I zip
Xis operating.  This might be used in shell scripts, for example, or if the
Xzip operation is being performed as a background task ("zip -q foo *.c &").
X.PP
X.I zip
Xcan take a list of file names to operate on from stdin using the -@ option.
XIn Unix, this option can be used with the find command to extend greatly
Xthe functionality of
X.I zip.
XFor example, to zip up all the C source files in the current directory and
Xits subdirectories, you can:
X.PP
X.ti +5n
Xfind . -type f -name "*.[ch]" -print | zip source -@
X.PP
XNote that the pattern must be quoted to keep the shell from expanding it.
X.PP
XUnder VMS only, the -w option will append the version number of the files to
Xthe name and zip up multiple versions of files.  Without -w,
X.I zip
Xwill only use the most recent version of the specified file(s).
X.PP
XThe -l option translates the Unix end-of-line character LF into the
XMSDOS convention CR LF. This option should not be used on binary files.
XThis option can be used on Unix if the zip file is intended for PKUNZIP
Xunder MSDOS. If the input files already contain CR LF, this option adds
Xan extra CR. This ensure that "unzip -a" on Unix will get back an exact
Xcopy of the original file, to undo the effect of "zip -l".
X.PP
XIf
X.I zip
Xis run with the -h option, or with no arguments and standard output is
Xa terminal, the license and the command-argument and option help is shown.
XThe -L option just shows the license.
X.SH "ABOUT PATTERN MATCHING"
X(Note: this section applies to Unix.  Watch this space for details on MSDOS
Xand VMS operation.)
X.PP
XThe Unix shell (sh or csh) does filename substitution on command arguments.
XThe special characters are ?, which matches any single character; * which
Xmatches any number of characters (including none); and [] which matches any
Xcharacter in the range inside the brackets (like [a\-f] or [0\-9]).  When
Xthese characters are encountered (and not escaped with a backslash or
Xquotes), the
Xshell will look for files relative to the current path that match the
Xpattern, and replace the argument with a list of the names that matched.
X.PP
X.I zip
Xcan do the same matching on names that are in the zip file being
Xmodified or, in the case of the -x (exclude) option, on the list of
Xfiles to be operated on, by using backslashes or quotes
Xto tell the shell not to do the name expansion.  In general, when
X.I zip
Xencounters a name in the list
Xof files to do, it first looks for the name in the file system.  If it
Xfinds it, it then adds it to the list of files to do.  If it does not
Xfind it, it will look for the name in the zip file being modified (if it
Xexists), using the pattern matching characters above, if any.  For each
Xmatch, it will add that name to the list of files to do.  After -x
X(exclude), the names are removed from the to-do list instead of added.
X.PP
XThe pattern matching includes the path, and so patterns like \\*.o match
Xnames that end in ".o", no matter what the path prefix is.  Note that the
Xbackslash must precede every special character (i.e. ?*[]), or the entire
Xargument must be enclosed in double quotes ("").
X.PP
XIn general, using backslash to make
X.I zip
Xdo the pattern matching is used
Xwith the -f (freshen) and -d (delete) options, and sometimes after the
X-x (exclude) option when used with any operation (add, -u, -f, or -d).
X.I zip
Xwill never use pattern matching to search the file system.  If
X.I zip
Xhas recursed into a directory, all files (and all directories) in there
Xare fair game.
X.SH COPYRIGHT
XCopyright (C) 1990-1992 Mark Adler, Richard B. Wales, Jean-loup Gailly,
XKai Uwe Rommel and Igor Mandrichenko.
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as all of the original files are included
Xunmodified, that it is not sold for profit, and that this copyright notice
Xis retained.
X.SH ACKNOWLEDGEMENTS
XThanks to R. P. Byrne for his Shrink.Pas program which inspired this project;
Xto Phil Katz for making the zip
Xfile format, compression format, and .zip filename extension all public domain;
Xto Steve Burg and Phil Katz for help on unclear points of the deflate format;
Xto Keith Petersen and Rich Wales for providing a mailing list and ftp site for
Xthe INFO-ZIP group to use; and most importantly, to the INFO-ZIP group itself
X(listed in the file infozip.who) without whose tireless testing and bug-fixing
Xefforts a portable
X.I zip
Xwould not have been possible.  Finally we should thank (blame) the INFO-ZIP
Xmoderator, David Kirschbaum for getting us into this mess in the first place.
X.SH "SEE ALSO"
Xunzip(1), tar(1), compress(1)
X.SH BUGS
XWARNING: zip files produced by zip 1.9 must not be
X*updated* by zip 1.0 or pkzip 1.10 or pkzip 1.93a, if they contain
Xencrypted members, or if they have been produced in a pipe or on a non
Xseekable device. The old versions of zip or pkzip would destroy the
Xzip structure. The old versions can list the contents of the zip file
Xbut cannot extract it anyway (because of the new compression algorithm).
XIf you do not use encryption and use regular disk files, you do
Xnot have to care about this problem.
X.PP
Xzip 1.9 is compatible with pkzip 1.93a, except when two features
Xare used: encryption or zip file created in a pipe or on a non
Xseekable device. pkzip versions above 2.0 will support such files, and
Xunzip 5.0 already supports them.
X.PP
XWithout -y, when zip must compress a symbolic link to an non existing file,
Xit only displays a warning "name not matched". A better warnign should be
Xgiven.
X.PP
XUnder VMS, not all of the odd file formats are treated properly.  Only
Xzip files of format stream-LF and fixed length 512 are expected to work
Xwith zip.  Others can be converted using Rahul Dhesi's BILF program.
XThis version of zip does handle some of the conversion internally.
XWhen using Kermit to transfer zip files from Vax to MSDOS, type "set
Xfile type block" on the Vax.  When transfering from MSDOS to Vax, type
X"set file type fixed" on the Vax.  In both cases, type "set file type
Xbinary" on MSDOS.
X.PP
XUnder VMS, zip hangs for file specification that uses DECnet syntax (foo::*.*).
X.PP
XUnder OS/2, the amount of External Attributes displayed by DIR is (for
Xcompatibility) the amount returned by the 16-bit version of
XDosQueryPathInfo(). Otherwise OS/2 1.3 and 2.0 would report different
XEA sizes when DIRing a file.
XHowever, the structure layout returned by the 32-bit DosQueryPathInfo()
Xis a bit different, it uses extra padding bytes and link pointers (it's
Xa linked list) to have all fields on 4-byte boundaries for portability
Xto future RISC OS/2 versions. Therefore the value reported by ZIP
X(which uses this 32-bit-mode size) differs from that reported by DIR.
XZIP stores the 32-bit format for portability, even the 16-bit
XMS-C-compiled version running on OS/2 1.3, so even this one shows the
X32-bit-mode size.
X.PP
XLIKE ANYTHING ELSE THAT'S FREE, ZIP AND ITS ASSOCIATED UTILITIES ARE
XPROVIDED AS IS AND COME WITH NO WARRANTY OF ANY KIND, EITHER EXPRESSED OR
XIMPLIED. IN NO EVENT WILL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY DAMAGES
XRESULTING FROM THE USE OF THIS SOFTWARE.
X.PP
XThat having been said, please send any problems or comments via email to
Xthe Internet address
Xzip\-bugs@cs.ucla.edu.  For bug reports, please include the
Xversion of zip, the make options you used to compile it, the machine and
Xoperating system you are using, and as much additional information as
Xpossible.  Thank you for your support.
END_OF_FILE
  if test 21796 -ne `wc -c <'zip.1'`; then
    echo shar: \"'zip.1'\" unpacked with wrong size!
  fi
  # end of 'zip.1'
fi
if test -f 'zip.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zip.h'\"
else
  echo shar: Extracting \"'zip.h'\" \(10606 characters\)
  sed "s/^X//" >'zip.h' <<'END_OF_FILE'
X/*
X
X Copyright (C) 1990-1992 Mark Adler, Richard B. Wales, Jean-loup Gailly,
X Kai Uwe Rommel and Igor Mandrichenko.
X Permission is granted to any individual or institution to use, copy, or
X redistribute this software so long as all of the original files are included
X unmodified, that it is not sold for profit, and that this copyright notice
X is retained.
X
X*/
X
X/*
X *  zip.h by Mark Adler.
X */
X
X
X/* Set up portability */
X#include "tailor.h"
X
X#define MIN_MATCH  3
X#define MAX_MATCH  258
X/* The minimum and maximum match lengths */
X
X#ifndef WSIZE
X#  define WSIZE  ((unsigned)32768)
X#endif
X/* Maximum window size = 32K. If you are really short of memory, compile
X * with a smaller WSIZE but this reduces the compression ratio for files
X * of size > WSIZE. WSIZE must be a power of two in the current implementation.
X */
X
X#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
X/* Minimum amount of lookahead, except at the end of the input file.
X * See deflate.c for comments about the MIN_MATCH+1.
X */
X
X#define MAX_DIST  (WSIZE-MIN_LOOKAHEAD)
X/* In order to simplify the code, particularly on 16 bit machines, match
X * distances are limited to MAX_DIST instead of WSIZE.
X */
X
X/* Define malloc() and string functions */
X#ifdef MODERN
X#  include <string.h>
X#else /* !MODERN */
X   voidp *malloc();
X   char *getenv();
X   long atol();
X   char *strcpy();
X   char *strcat();
X   char *strchr();
X   char *strrchr();
X#  ifndef ZMEM
X     char *memset();
X     char *memcpy();
X#  endif /* !ZMEM */
X#endif /* ?MODERN */
X
X
X/* Define fseek() commands */
X#ifndef SEEK_SET
X#  define SEEK_SET 0
X#endif /* !SEEK_SET */
X
X#ifndef SEEK_CUR
X#  define SEEK_CUR 1
X#endif /* !SEEK_CUR */
X
X
X/* Forget FILENAME_MAX (incorrectly = 14 on some System V) */
X#ifdef MSDOS
X#  define FNMAX 256
X#else /* !MSDOS */
X#  define FNMAX 1024
X#endif /* ?MSDOS */
X
X
X/* For setting stdout to binary */
X#ifdef MSDOS
X#  include <io.h>
X#  include <fcntl.h>
X#endif /* MSDOS */
X
X
X/* Types centralized here for easy modification */
X#define local static            /* More meaningful outside functions */
Xtypedef unsigned char uch;      /* unsigned 8-bit value */
Xtypedef unsigned short ush;     /* unsigned 16-bit value */
Xtypedef unsigned long ulg;      /* unsigned 32-bit value */
X
X
X/* Lengths of headers after signatures in bytes */
X#define LOCHEAD 26
X#define CENHEAD 42
X#define ENDHEAD 18
X
X
X/* Structures for in-memory file information */
Xstruct zlist {
X  /* See central header in zipfile.c for what vem..off are */
X  ush vem, ver, flg, how;
X  ulg tim, crc, siz, len;
X  extent nam, ext, cext, com;   /* offset of ext must be >= LOCHEAD */
X  ush dsk, att, lflg;           /* offset of lflg must be >= LOCHEAD */
X  ulg atx, off;
X  char *name;                   /* File name in zip file */
X  char *extra;                  /* Extra field (set only if ext != 0) */
X  char *cextra;                 /* Extra in central (set only if cext != 0) */
X  char *comment;                /* Comment (set only if com != 0) */
X  char *zname;                  /* Name for new zip file header */
X  int mark;                     /* Marker for files to operate on */
X  int trash;                    /* Marker for files to delete */
X  int dosflag;                  /* Set to force MSDOS file attributes */
X  struct zlist far *nxt;        /* Pointer to next header in list */
X};
Xstruct flist {
X  char *name;                   /* Pointer to zero-delimited name */
X  char *zname;                  /* Name used for zip file headers */
X  int dosflag;                  /* Set to force MSDOS file attributes */
X  struct flist far * far *lst;  /* Pointer to link pointing here */
X  struct flist far *nxt;        /* Link to next name */
X};
X
X/* internal file attribute */
X#define UNKNOWN (-1)
X#define BINARY  0
X#define ASCII   1
X
X/* Error return codes and PERR macro */
X#include "ziperr.h"
X
X
X/* Public globals */
Xextern uch upper[256];          /* Country dependent case map table */
Xextern uch lower[256];
Xextern char errbuf[];           /* Handy place to build error messages */
Xextern int recurse;             /* Recurse into directories encountered */
Xextern int pathput;             /* Store path with name */
X
X#define BEST -1                 /* Use best method (deflation or store) */
X#define STORE 0                 /* Store method */
X#define DEFLATE 8               /* Deflation method*/
Xextern int method;              /* Restriction on compression method */
X
Xextern int dosify;              /* Make new entries look like MSDOS */
Xextern char *special;           /* Don't compress special suffixes */
Xextern int verbose;             /* Report oddities in zip file structure */
Xextern int level;               /* Compression level */
Xextern int translate_eol;       /* Translate end-of-line LF -> CR LF */
X#ifdef VMS
X   extern int vmsver;           /* Append VMS version number to file names */
X   extern int vms_native;       /* Store in VMS formait */
X#endif /* VMS */
X#ifdef OS2
X   extern int use_longname_ea;   /* use the .LONGNAME EA as the file's name */
X#endif /* OS2 */
Xextern int linkput;             /* Store symbolic links as such */
Xextern int noisy;               /* False for quiet operation */
Xextern char *key;               /* Scramble password or NULL */
Xextern char *tempath;           /* Path for temporary files */
Xextern FILE *mesg;              /* Where informational output goes */
Xextern char *zipfile;           /* New or existing zip archive (zip file) */
Xextern ulg zipbeg;              /* Starting offset of zip structures */
Xextern ulg cenbeg;              /* Starting offset of central directory */
Xextern struct zlist far *zfiles;/* Pointer to list of files in zip file */
Xextern extent zcount;           /* Number of files in zip file */
Xextern extent zcomlen;          /* Length of zip file comment */
Xextern char *zcomment;          /* Zip file comment (not zero-terminated) */
Xextern struct zlist far **zsort;/* List of files sorted by name */
Xextern ulg tempzn;              /* Count of bytes written to output zip file */
Xextern struct flist far *found; /* List of names found */
Xextern struct flist far * far *fnxt;    /* Where to put next in found list */
Xextern extent fcount;           /* Count of names in found list */
X
X
X/* Diagnostic functions */
X#ifdef DEBUG
X# ifdef MSDOS
X#  undef  stderr
X#  define stderr stdout
X# endif
X#  define diag(where) fprintf(stderr, "zip diagnostic: %s\n", where)
X#  define Assert(cond,msg) {if(!(cond)) error(msg);}
X#  define Trace(x) fprintf x
X#  define Tracev(x) {if (verbose) fprintf x ;}
X#  define Tracevv(x) {if (verbose>1) fprintf x ;}
X#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
X#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
X#else
X#  define diag(where)
X#  define Assert(cond,msg)
X#  define Trace(x)
X#  define Tracev(x)
X#  define Tracevv(x)
X#  define Tracec(c,x)
X#  define Tracecv(c,x)
X#endif
X
X
X/* Public function prototypes */
X
X        /* in zip.c, zipcloak.c, or zipsplit.c */
Xvoid warn  OF((char *, char *));
Xvoid err   OF((int c, char *h));
Xvoid error OF((char *h));
X
X        /* in zipup.c */
Xint zipcopy OF((struct zlist far *, FILE *, FILE *));
X#ifndef UTIL
X   int percent OF((long, long));
X   int zipup OF((struct zlist far *, FILE *));
X   int file_read OF((char *buf, unsigned size));
X#endif /* !UTIL */
X
X        /* in zipfile.c */
X#ifndef UTIL
X   struct zlist far *zsearch OF((char *));
X   int trash OF((void));
X#endif /* !UTIL */
Xchar *ziptyp OF((char *));
Xint readzipfile OF((void));
Xint putlocal OF((struct zlist far *, FILE *));
Xint putextended OF((struct zlist far *, FILE *));
Xint putcentral OF((struct zlist far *, FILE *));
Xint putend OF((int, ulg, ulg, extent, char *, FILE *));
X
X        /* in fileio.c */
X#ifndef UTIL
X#  ifdef MSDOS
X     int wild OF((char *));
X#  endif /* MSDOS */
X#  ifdef VMS
X     int wild OF((char *));
X#  endif /* VMS */
X   char *getnam OF((char *));
X   struct flist far *fexpel OF((struct flist far *));
X   char *in2ex OF((char *));
X   int exclude OF((void));
X   int procname OF((char *));
X   void stamp OF((char *, ulg));
X   ulg dostime OF((int, int, int, int, int, int));
X   ulg filetime OF((char *, ulg *, long *));
X   int issymlnk OF((ulg a));
X#  ifdef S_IFLNK
X#    define rdsymlnk(p,b,n) readlink(p,b,n)
X     extern int readlink OF((char *, char *, int));
X#  else /* !S_IFLNK */
X#    define rdsymlnk(p,b,n) (0)
X#  endif /* !S_IFLNK */
X   int deletedir OF((char *));
X#endif /* !UTIL */
Xint destroy OF((char *));
Xint replace OF((char *, char *));
Xint getfileattr OF((char *));
Xint setfileattr OF((char *, int));
Xchar *tempname OF((char *));
Xint fcopy OF((FILE *, FILE *, ulg));
X#ifdef CRYPT
X#  ifndef MSVMS
X     void echoff OF((int));
X     void echon OF((void));
X#  endif /* !MSVMS */
X   char *getp OF((char *, char *, int));
X#endif /* !CRYPT */
X#ifdef ZMEM
X   char *memset OF((char *, int, unsigned int));
X   char *memcpy OF((char *, char *, unsigned int));
X   int memcmp OF((char *, char *, unsigned int));
X#endif /* ZMEM */
X
X        /* in crypt.c */
X#ifndef CRYPT
X#  define zfwrite fwrite
X#  define zputc putc
X#else /* CRYPT */
X   void crypthead OF((char *, ulg, FILE *));
X#  ifdef UTIL
X     int zipcloak OF ((struct zlist far *, FILE *, FILE *, char *));
X     int zipbare OF ((struct zlist far *, FILE *, FILE *, char *));
X#  else /* !UTIL */
X     unsigned zfwrite OF((voidp *, extent, extent, FILE *));
X     int zencode OF((int c));
X     extern char *key;
X#    define zputc(c,f) (putc(key!=NULL? zencode(c) : (c),(f)))
X#  endif /* ?UTIL */
X#endif /* ?CRYPT */
X
X        /* in util.c */
Xchar *isshexp OF((char *));
Xint   shmatch OF((char *, char *));
X#ifdef MSDOS
X   int dosmatch OF((char *, char *));
X#endif /* MSDOS */
Xvoid     init_upper OF((void));
Xint      namecmp    OF((char *string1, char *string2));
Xvoidp far **search  OF((voidp *, voidp far **, extent,
X                       int (*)(voidp *, voidp far *)));
Xulg crc32 OF((ulg, int));
Xulg updcrc OF((char *, extent));
X
X#ifndef UTIL
X        /* in deflate.c */
Xvoid lm_init OF((int pack_level, ush *flags));
Xulg  deflate OF((void));
X
X        /* in trees.c */
Xvoid ct_init     OF((ush *attr, int *method));
Xint  ct_tally    OF((int dist, int lc));
Xulg  flush_block OF((char far *buf, ulg stored_len, int eof));
X
X        /* in bits.c */
Xvoid     bi_init    OF((FILE *zipfile));
Xvoid     send_bits  OF((int value, int length));
Xunsigned bi_reverse OF((unsigned value, int length));
Xvoid     bi_windup  OF((void));
Xvoid     copy_block OF((char far *buf, unsigned len, int header));
Xint      seekable   OF((void));
Xextern   int (*read_buf) OF((char *buf, unsigned size));
Xulg     memcompress OF((char *tgt, ulg tgtsize, char *src, ulg srcsize));
X
X#endif /* !UTIL */
X
X
X/* end of zip.h */
END_OF_FILE
  if test 10606 -ne `wc -c <'zip.h'`; then
    echo shar: \"'zip.h'\" unpacked with wrong size!
  fi
  # end of 'zip.h'
fi
if test -f 'zipfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'zipfile.c'\"
else
  echo shar: Extracting \"'zipfile.c'\" \(24578 characters\)
  sed "s/^X//" >'zipfile.c' <<'END_OF_FILE'
X/*
X
X Copyright (C) 1990-1992 Mark Adler, Richard B. Wales, Jean-loup Gailly,
X Kai Uwe Rommel and Igor Mandrichenko.
X Permission is granted to any individual or institution to use, copy, or
X redistribute this software so long as all of the original files are included
X unmodified, that it is not sold for profit, and that this copyright notice
X is retained.
X
X*/
X
X/*
X *  zipfile.c by Mark Adler.
X */
X
X#include "zip.h"
X
X#ifdef VMS
X#  include "VMSmunch.h"
X#  include <rms.h>
X#endif
X
X
X/* Macros for converting integers in little-endian to machine format */
X#define SH(a) (((ush)(uch)(a)[0]) | (((ush)(uch)(a)[1]) << 8))
X#define LG(a) ((ulg)SH(a) | ((ulg)SH((a)+2) << 16))
X
X/* Macros for writing machine integers to little-endian format */
X#define PUTSH(a,f) {putc((char)(a),(f)); putc((char)((a) >> 8),(f));}
X#define PUTLG(a,f) {PUTSH(a,f) PUTSH((a) >> 16,f)}
X
X
X/* -- Structure of a ZIP file -- */
X
X/* Signatures for zip file information headers */
X#define LOCSIG     0x04034b50L
X#define CENSIG     0x02014b50L
X#define ENDSIG     0x06054b50L
X#define EXTLOCSIG  0x08074b50L
X
X/* Offsets of values in headers */
X#define LOCVER  0               /* version needed to extract */
X#define LOCFLG  2               /* encrypt, deflate flags */
X#define LOCHOW  4               /* compression method */
X#define LOCTIM  6               /* last modified file time, DOS format */
X#define LOCDAT  8               /* last modified file date, DOS format */
X#define LOCCRC  10              /* uncompressed crc-32 for file */
X#define LOCSIZ  14              /* compressed size in zip file */
X#define LOCLEN  18              /* uncompressed size */
X#define LOCNAM  22              /* length of filename */
X#define LOCEXT  24              /* length of extra field */
X
X#define CENVEM  0               /* version made by */
X#define CENVER  2               /* version needed to extract */
X#define CENFLG  4               /* encrypt, deflate flags */
X#define CENHOW  6               /* compression method */
X#define CENTIM  8               /* last modified file time, DOS format */
X#define CENDAT  10              /* last modified file date, DOS format */
X#define CENCRC  12              /* uncompressed crc-32 for file */
X#define CENSIZ  16              /* compressed size in zip file */
X#define CENLEN  20              /* uncompressed size */
X#define CENNAM  24              /* length of filename */
X#define CENEXT  26              /* length of extra field */
X#define CENCOM  28              /* file comment length */
X#define CENDSK  30              /* disk number start */
X#define CENATT  32              /* internal file attributes */
X#define CENATX  34              /* external file attributes */
X#define CENOFF  38              /* relative offset of local header */
X
X#define ENDDSK  0               /* number of this disk */
X#define ENDBEG  2               /* number of the starting disk */
X#define ENDSUB  4               /* entries on this disk */
X#define ENDTOT  6               /* total number of entries */
X#define ENDSIZ  8               /* size of entire central directory */
X#define ENDOFF  12              /* offset of central on starting disk */
X#define ENDCOM  16              /* length of zip file comment */
X
X
X/* Local functions */
X#ifdef PROTO
X   local int zqcmp(voidp *, voidp *);
X#  ifndef UTIL
X     local int zbcmp(voidp *, voidp far *);
X     local char *cutpath(char *);
X#  endif /* !UTIL */
X#endif /* PROTO */
X
X
Xlocal int zqcmp(a, b)
Xvoidp *a, *b;           /* pointers to pointers to zip entries */
X/* Used by qsort() to compare entries in the zfile list.  */
X{
X  return namecmp((*(struct zlist far **)a)->zname,
X                (*(struct zlist far **)b)->zname);
X}
X
X
X#ifndef UTIL
X
Xlocal int zbcmp(n, z)
Xvoidp *n;               /* string to search for */
Xvoidp far *z;           /* pointer to a pointer to a zip entry */
X/* Used by search() to compare a target to an entry in the zfile list. */
X{
X  return namecmp((char *)n, ((struct zlist far *)z)->zname);
X}
X
X
Xstruct zlist far *zsearch(n)
Xchar *n;                /* name to find */
X/* Return a pointer to the entry in zfile with the name n, or NULL if
X   not found. */
X{
X  voidp far **p;        /* result of search() */
X
X  if (zcount && (p = search(n, (voidp far **)zsort, zcount, zbcmp)) != NULL)
X    return *(struct zlist far **)p;
X  else
X    return NULL;
X}
X
X#endif /* !UTIL */
X
X#ifndef VMS
X#  define PATHCUT '/'
X
Xchar *ziptyp(s)
Xchar *s;                /* file name to force to zip */
X/* If the file name *s has a dot (other than the first char), then return
X   the name, otherwise append .zip to the name.  Allocate the space for
X   the name in either case.  Return a pointer to the new name, or NULL
X   if malloc() fails. */
X{
X  char *q;              /* temporary pointer */
X  char *t;              /* pointer to malloc'ed string */
X
X  if ((t = malloc(strlen(s) + 5)) == NULL)
X    return NULL;
X  strcpy(t, s);
X#ifdef MSDOS
X  for (q = t; *q; q++)
X    if (*q == '\\')
X      *q = '/';
X#endif /* MSDOS */
X  if (strrchr((q = strrchr(t, PATHCUT)) == NULL ? t : q + 1, '.') == NULL)
X    strcat(t, ".zip");
X#if defined(FORCE_UPPER) && defined(MSDOS) && !defined(OS2)
X  strupr(t);
X#endif
X  return t;
X}
X
X#else /* VMS */
X
X# define PATHCUT ']'
X
Xchar *ziptyp(s)
Xchar *s;
X{   int status;
X    struct FAB fab;
X    struct NAM nam;
X    static char zero=0;
X    char result[NAM$C_MAXRSS+1],exp[NAM$C_MAXRSS+1];
X    char *p;
X
X    fab = cc$rms_fab;
X    nam = cc$rms_nam;
X
X    fab.fab$l_fna = s;
X    fab.fab$b_fns = strlen(fab.fab$l_fna);
X
X    fab.fab$l_dna = "sys$disk:[].zip";          /* Default fspec */
X    fab.fab$b_dns = strlen(fab.fab$l_dna);
X
X    fab.fab$l_nam = &nam;
X    
X    nam.nam$l_rsa = result;                     /* Put resultant name of */
X    nam.nam$b_rss = sizeof(result)-1;           /* existing zipfile here */
X
X    nam.nam$l_esa = exp;                        /* For full spec of */
X    nam.nam$b_ess = sizeof(exp)-1;              /* file to create */
X
X    status = sys$parse(&fab);
X    if( (status & 1) == 0 )
X        return &zero;
X
X    status = sys$search(&fab);
X    if( status & 1 )
X    {               /* Existing ZIP file */
X        int l;
X        if( (p=malloc( (l=nam.nam$b_rsl) + 1 )) != NULL )
X        {       result[l] = 0;
X                strcpy(p,result);
X        }
X    }
X    else
X    {               /* New ZIP file */
X        int l;
X        if( (p=malloc( (l=nam.nam$b_esl) + 1 )) != NULL )
X        {       exp[l] = 0;
X                strcpy(p,exp);
X        }
X    }
X    return p;
X}
X
X#endif  /* VMS */
X
X
Xint readzipfile()
X/*
X   Make first pass through zip file, reading information from local file
X   headers and then verifying that information with the central file
X   headers.  Any deviation from the expected zip file format returns an
X   error.  At the end, a sorted list of file names in the zip file is made
X   to facilitate searching by name.
X
X   The name of the zip file is pointed to by the global "zipfile".  The
X   globals zfiles, zcount, zcomlen, zcomment, and zsort are filled in.
X   Return an error code in the ZE_ class.
X*/
X{
X  char b[CENHEAD];      /* buffer for central headers */
X  FILE *f;              /* zip file */
X  ush flg;              /* general purpose bit flag */
X  int m;                /* mismatch flag */
X  extent n;             /* length of name */
X  ulg p;                /* current file offset */
X  char r;               /* holds reserved bits during memcmp() */
X  ulg s;                /* size of data, start of central */
X  char *t;              /* temporary variable */
X  char far *u;          /* temporary variable */
X  struct zlist far * far *x;    /* pointer last entry's link */
X  struct zlist far *z;  /* current zip entry structure */
X
X  /* Initialize zip file info */
X  zipbeg = 0;
X  zfiles = NULL;                        /* Points to first header */
X  zcomlen = 0;                          /* zip file comment length */
X
X  /* If zip file exists, read headers and check structure */
X#ifdef VMS
X  if (zipfile == NULL || !(*zipfile) || !strcmp(zipfile, "-"))
X    return ZE_OK;
X  {
X    int rtype;
X    VMSmunch(zipfile, GET_RTYPE, (char *)&rtype);
X    if (rtype == FAT$C_VARIABLE) {
X      fprintf(stderr,
X     "\n     Error:  zipfile is in variable-length record format.  Please\n\
X     run \"bilf b %s\" to convert the zipfile to fixed-length\n\
X     record format.  (Bilf.exe, bilf.c and make_bilf.com are included\n\
X     in the VMS UnZip distribution.)\n\n", zipfile);
X      return ZE_FORM;
X    }
X  }
X  if ((f = fopen(zipfile, FOPR)) != NULL)
X#else /* !VMS */
X  if (zipfile != NULL && *zipfile && strcmp(zipfile, "-") &&
X      (f = fopen(zipfile, FOPR)) != NULL)
X#endif /* ?VMS */
X  {
X    x = &zfiles;                        /* first link */
X    p = 0;                              /* starting file offset */
X    zcount = 0;                         /* number of files */
X
X    /* Find start of zip structures */
X    for (;;) {
X      while ((m = getc(f)) != EOF && m != 'P') p++;
X      b[0] = (char) m;
X      if (fread(b+1, 3, 1, f) != 1 || (s = LG(b)) == LOCSIG || s == ENDSIG)
X        break;
X      if (fseek(f, -3L, SEEK_CUR))
X        return ferror(f) ? ZE_READ : ZE_EOF;
X      p++;
X    }
X    zipbeg = p;
X
X    /* Read local headers */
X    while (LG(b) == LOCSIG)
X    {
X      /* Read local header raw to compare later with central header
X         (this requires that the offest of ext in the zlist structure
X         be greater than or equal to LOCHEAD) */
X      if ((z = (struct zlist far *)farmalloc(sizeof(struct zlist))) == NULL)
X        return ZE_MEM;
X      if (fread(b, LOCHEAD, 1, f) != 1)
X        return ferror(f) ? ZE_READ : ZE_EOF;
X      t = b;  u = (char far *)z;  n = LOCHEAD;
X      do {
X        *u++ = *t++;
X      } while (--n);
X
X      /* Link into list */
X      *x = z;
X      z->nxt = NULL;
X      x = &z->nxt;
X
X      /* Read file name and extra field and skip data */
X      n = SH(LOCNAM + (uch far *)z);
X      z->ext = SH(LOCEXT + (uch far *)z);
X      s = LG(LOCSIZ + (uch far *)z);
X      if (n == 0)
X      {
X        sprintf(errbuf, "%d", zcount + 1);
X        warn("zero-length name for entry #", errbuf);
X        return ZE_FORM;
X      }
X      if ((z->zname = malloc(n+1)) ==  NULL ||
X          (z->ext && (z->extra = malloc(z->ext)) == NULL))
X        return ZE_MEM;
X      if (fread(z->zname, n, 1, f) != 1 ||
X          (z->ext && fread(z->extra, z->ext, 1, f) != 1) ||
X          fseek(f, (long)s, SEEK_CUR))
X        return ferror(f) ? ZE_READ : ZE_EOF;
X      /* If there is an extended local header, s is either 0 or
X       * the correct compressed size.
X       */
X      z->zname[n] = 0;                  /* terminate name */
X#ifdef UTIL
X      z->name = z->zname;
X#else /* !UTIL */
X      z->name = in2ex(z->zname);        /* convert to external name */
X      if (z->name == NULL)
X        return ZE_MEM;
X#endif /* ?UTIL */
X
X      /* Save offset, update for next header */
X      z->off = p;
X      p += 4 + LOCHEAD + n + z->ext + s;
X      zcount++;
X
X      /* Skip extended local header if there is one */
X      flg = SH(b+LOCFLG);
X      if ((flg & 8) != 0) {
X        /* Skip the compressed data if compressed size is unknown.
X         * For safety, we should use the central directory.
X         */
X        if (s == 0) {
X          for (;;) {
X            while ((m = getc(f)) != EOF && m != 'P') ;
X            b[0] = (char) m;
X            if (fread(b+1, 15, 1, f) != 1 || LG(b) == EXTLOCSIG)
X              break;
X            if (fseek(f, -15L, SEEK_CUR))
X              return ferror(f) ? ZE_READ : ZE_EOF;
X          }
X          s = LG(b+8);
X          p += s;
X          if ((ulg) ftell(f) != p+16L) {
X            warn("bad extended local header for ", z->zname);
X            return ZE_FORM;
X          }
X        } else {
X          /* compressed size non zero, assume that it is valid: */
X          if (fseek(f, p, SEEK_SET) || fread(b, 16, 1, f) != 1)
X            return ferror(f) ? ZE_READ : ZE_EOF;
X          if (LG(b) != EXTLOCSIG) {
X            warn("extended local header not found for ", z->zname);
X            return ZE_FORM;
X          }
X        }
X        /* overwrite the unknown values of the local header: */
X        t = b+4;  u = (char far *)z+LOCCRC;  n = 12;
X        do {
X          *u++ = *t++;
X        } while (--n);
X        p += 16L;
X      }
X      /* Read next signature */
X      if (fread(b, 4, 1, f) != 1)
X        return ferror(f) ? ZE_READ : ZE_EOF;
X    }
X
X    /* Point to start of header list and read central headers */
X    z = zfiles;
X    s = p;                              /* save start of central */
X    while (LG(b) == CENSIG)
X    {
X      if (z == NULL)
X      {
X        warn("extraneous central header signature", "");
X        return ZE_FORM;
X      }
X
X      /* Read central header */
X      if (fread(b, CENHEAD, 1, f) != 1)
X        return ferror(f) ? ZE_READ : ZE_EOF;
X
X      /* Compare local header with that part of central header (except
X         for the reserved bits in the general purpose flags and except
X         for length of extra fields--authentication can make these
X         different in central and local headers) */
X      z->lflg = SH(LOCFLG + (uch far *)z);      /* Save reserved bits */
X      r = b[CENFLG+1];
X      ((uch far *)z)[LOCFLG+1] &= 0x1f; /* Zero out reserved bits */
X      b[CENFLG+1] &= 0x1f;
X      for (m = 0, u = (char far *)z, n = 0; n < LOCHEAD - 2; n++)
X        if (u[n] != b[n+2])
X        {
X          if (!m)
X            warn("local and central headers differ for ", z->zname);
X          m = 1;
X          sprintf(errbuf, " offset %d--local = %02x, central = %02x",
X                  n, (uch)u[n], (uch)b[n+2]);
X          warn(errbuf, "");
X        }
X      if (m)
X        return ZE_FORM;
X      b[CENFLG+1] = r;                  /* Restore reserved bits */
X
X      /* Overwrite local header with translated central header */
X      z->vem = SH(CENVEM + b);
X      z->ver = SH(CENVER + b);
X      z->flg = SH(CENFLG + b);          /* may be different from z->lflg */
X      z->how = SH(CENHOW + b);
X      z->tim = LG(CENTIM + b);          /* time and date into one long */
X      z->crc = LG(CENCRC + b);
X      z->siz = LG(CENSIZ + b);
X      z->len = LG(CENLEN + b);
X      z->nam = SH(CENNAM + b);
X      z->cext = SH(CENEXT + b);         /* may be different from z->ext */
X      z->com = SH(CENCOM + b);
X      z->dsk = SH(CENDSK + b);
X      z->att = SH(CENATT + b);
X      z->atx = LG(CENATX + b);
X      if (z->off != LG(CENOFF + b))
X      {
X        warn("local offset in central header incorrect for ", z->zname);
X        return ZE_FORM;
X      }
X
X      /* Compare name and extra fields and read comment field */
X      if ((t = malloc(z->nam)) == NULL)
X        return ZE_MEM;
X      if (fread(t, z->nam, 1, f) != 1)
X      {
X        free((voidp *)t);
X        return ferror(f) ? ZE_READ : ZE_EOF;
X      }
X      if (memcmp(t, z->zname, z->nam))
X      {
X        free((voidp *)t);
X        warn("names in local and central differ for ", z->zname);
X        return ZE_FORM;
X      }
X      free((voidp *)t);
X      if (z->cext)
X      {
X        if ((z->cextra = malloc(z->cext)) == NULL)
X          return ZE_MEM;
X        if (fread(z->cextra, z->cext, 1, f) != 1)
X        {
X          free((voidp *)(z->cextra));
X          return ferror(f) ? ZE_READ : ZE_EOF;
X        }
X        if (z->ext == z->cext && memcmp(z->extra, z->cextra, z->ext) == 0)
X        {
X          free((voidp *)(z->cextra));
X          z->cextra = z->extra;
X        }
X      }
X      if (z->com)
X      {
X        if ((z->comment = malloc(z->com)) == NULL)
X          return ZE_MEM;
X        if (fread(z->comment, z->com, 1, f) != 1)
X        {
X          free((voidp *)(z->comment));
X          return ferror(f) ? ZE_READ : ZE_EOF;
X        }
X      }
X
X      /* Note oddities */
X      if (verbose)
X      {
X        if (z->vem != 10 && z->vem != 11 && z->vem != 20 &&
X            (n = z->vem >> 8) != 3 && n != 2 && n != 6 && n != 0)
X        {
X          sprintf(errbuf, "made by version %d.%d on system type %d: ",
X            (ush)(z->vem & 0xff) / (ush)10,
X            (ush)(z->vem & 0xff) % (ush)10, z->vem >> 8);
X          warn(errbuf, z->zname);
X        }
X        if (z->ver != 10 && z->ver != 11 && z->ver != 20)
X        {
X          sprintf(errbuf, "needs unzip %d.%d on system type %d: ",
X            (ush)(z->ver & 0xff) / (ush)10,
X            (ush)(z->ver & 0xff) % (ush)10, z->ver >> 8);
X          warn(errbuf, z->zname);
X        }
X        if (z->flg != z->lflg)
X        {
X          sprintf(errbuf, "local flags = 0x%04x, central = 0x%04x: ",
X                  z->lflg, z->flg);
X          warn(errbuf, z->zname);
X        }
X        else if (z->flg & ~0xf)
X        {
X          sprintf(errbuf, "undefined bits used in flags = 0x%04x: ", z->flg);
X          warn(errbuf, z->zname);
X        }
X        if (z->how > DEFLATE)
X        {
X          sprintf(errbuf, "unknown compression method %u: ", z->how);
X          warn(errbuf, z->zname);
X        }
X        if (z->dsk)
X        {
X          sprintf(errbuf, "starts on disk %u: ", z->dsk);
X          warn(errbuf, z->zname);
X        }
X        if (z->att & ~1)
X        {
X          sprintf(errbuf, "unknown internal attributes = 0x%04x: ", z->att);
X          warn(errbuf, z->zname);
X        }
X        if (((n = z->vem >> 8) != 3) && n != 2 && z->atx & ~0xffL)
X        {
X          sprintf(errbuf, "unknown external attributes = 0x%08lx: ", z->atx);
X          warn(errbuf, z->zname);
X        }
X        if (z->ext || z->cext)
X          if (z->ext == z->cext && z->extra == z->cextra)
X          {
X            sprintf(errbuf, "has %d bytes of extra data: ", z->ext);
X            warn(errbuf, z->zname);
X          }
X          else
X          {
X            sprintf(errbuf,
X                    "local extra (%d bytes) != central extra (%d bytes): ",
X                    z->ext, z->cext);
X            warn(errbuf, z->zname);
X          }
X      }
X
X      /* Clear actions */
X      z->mark = 0;
X      z->trash = 0;
X
X      /* Update file offset */
X      p += 4 + CENHEAD + z->nam + z->cext + z->com;
X
X      /* Advance to next header structure */
X      z = z->nxt;
X
X      /* Read next signature */
X      if (fread(b, 4, 1, f) != 1)
X        return ferror(f) ? ZE_READ : ZE_EOF;
X    }
X    
X    /* Read end header */
X    if (z != NULL || LG(b) != ENDSIG)
X    {
X      warn("missing end signature--probably not a zip file (did you", "");
X      warn("remember to use binary mode when you transferred it?)", "");
X      return ZE_FORM;
X    }
X    if (fread(b, ENDHEAD, 1, f) != 1)
X      return ferror(f) ? ZE_READ : ZE_EOF;
X    if (SH(ENDDSK + b) || SH(ENDBEG + b) ||
X        SH(ENDSUB + b) != SH(ENDTOT + b))
X      warn("multiple disk information ignored", "");
X    if (zcount != SH(ENDSUB + b))
X    {
X      warn("count in end of central directory incorrect", "");
X      return ZE_FORM;
X    }
X    if (LG(ENDSIZ + b) != p - s)
X    {
X      warn("central directory size is incorrect (made by stzip?)", "");
X      /* stzip 0.9 gets this wrong, so be tolerant */
X      /* return ZE_FORM; */
X    }
X    if (LG(ENDOFF + b) != s)
X    {
X      warn("central directory start is incorrect", "");
X      return ZE_FORM;
X    }
X    cenbeg = s;
X    zcomlen = SH(ENDCOM + b);
X    if (zcomlen)
X    {
X      if ((zcomment = malloc(zcomlen)) == NULL)
X        return ZE_MEM;
X      if (fread(zcomment, zcomlen, 1, f) != 1)
X      {
X        free((voidp *)zcomment);
X        return ferror(f) ? ZE_READ : ZE_EOF;
X      }
X    }
X    if (zipbeg)
X    {
X      sprintf(errbuf, " has a preamble of %ld bytes", zipbeg);
X      warn(zipfile, errbuf);
X    }
X    if (getc(f) != EOF)
X      warn("garbage at end of zip file ignored", "");
X
X    /* Done with zip file for now */
X    fclose(f);
X    
X    /* If one or more files, sort by name */
X    if (zcount)
X    {
X      if ((x = zsort =
X          (struct zlist far **)malloc(zcount * sizeof(struct zlist far *))) ==
X          NULL)
X        return ZE_MEM;
X      for (z = zfiles; z != NULL; z = z->nxt)
X        *x++ = z;
X      qsort((char *)zsort, zcount, sizeof(struct zlist far *), zqcmp);
X    }
X  }
X  return ZE_OK;
X}
X
X
Xint putlocal(z, f)
Xstruct zlist far *z;    /* zip entry to write local header for */
XFILE *f;                /* file to write to */
X/* Write a local header described by *z to file *f.  Return an error code
X   in the ZE_ class. */
X{
X  PUTLG(LOCSIG, f);
X  PUTSH(z->ver, f);
X  PUTSH(z->lflg, f);
X  PUTSH(z->how, f);
X  PUTLG(z->tim, f);
X  PUTLG(z->crc, f);
X  PUTLG(z->siz, f);
X  PUTLG(z->len, f);
X  PUTSH(z->nam, f);
X  PUTSH(z->ext, f);
X  if (fwrite(z->zname, 1, z->nam, f) != z->nam ||
X      (z->ext && fwrite(z->extra, 1, z->ext, f) != z->ext))
X    return ZE_TEMP;
X  return ZE_OK;
X}
X
Xint putextended(z, f)
Xstruct zlist far *z;    /* zip entry to write local header for */
XFILE *f;                /* file to write to */
X/* Write an extended local header described by *z to file *f.
X * Return an error code in the ZE_ class. */
X{
X  PUTLG(EXTLOCSIG, f);
X  PUTLG(z->crc, f);
X  PUTLG(z->siz, f);
X  PUTLG(z->len, f);
X  return ZE_OK;
X}
X
Xint putcentral(z, f)
Xstruct zlist far *z;    /* zip entry to write central header for */
XFILE *f;                /* file to write to */
X/* Write a central header described by *z to file *f.  Return an error code
X   in the ZE_ class. */
X{
X  PUTLG(CENSIG, f);
X  PUTSH(z->vem, f);
X  PUTSH(z->ver, f);
X  PUTSH(z->flg, f);
X  PUTSH(z->how, f);
X  PUTLG(z->tim, f);
X  PUTLG(z->crc, f);
X  PUTLG(z->siz, f);
X  PUTLG(z->len, f);
X  PUTSH(z->nam, f);
X  PUTSH(z->cext, f);
X  PUTSH(z->com, f);
X  PUTSH(z->dsk, f);
X  PUTSH(z->att, f);
X  PUTLG(z->atx, f);
X  PUTLG(z->off, f);
X  if (fwrite(z->zname, 1, z->nam, f) != z->nam ||
X      (z->cext && fwrite(z->cextra, 1, z->cext, f) != z->cext) ||
X      (z->com && fwrite(z->comment, 1, z->com, f) != z->com))
X    return ZE_TEMP;
X  return ZE_OK;
X}
X
X
Xint putend(n, s, c, m, z, f)
Xint n;                  /* number of entries in central directory */
Xulg s, c;               /* size and offset of central directory */
Xextent m;               /* length of zip file comment (0 if none) */
Xchar *z;                /* zip file comment if m != 0 */
XFILE *f;                /* file to write to */
X/* Write the end of central directory data to file *f.  Return an error code
X   in the ZE_ class. */
X{
X  PUTLG(ENDSIG, f);
X  PUTSH(0, f);
X  PUTSH(0, f);
X  PUTSH(n, f);
X  PUTSH(n, f);
X  PUTLG(s, f);
X  PUTLG(c, f);
X  PUTSH(m, f);
X  if (m && fwrite(z, 1, m, f) != m)
X    return ZE_TEMP;
X  return ZE_OK;
X}
X
X
X#ifndef UTIL
X
Xlocal char *cutpath(p)
Xchar *p;                /* path string */
X/* Cut the last path component off the name *p in place.  Return p. */
X{
X  char *r;              /* pointer to last path delimiter */
X
X#ifdef VMS                      /* change [w.x.y]z to [w.x]y.DIR */
X  if ((r = strrchr(p, ']')) != NULL)
X  {
X    *r = 0;
X    if ((r = strrchr(p, '.')) != NULL)
X    {
X      *r = ']';
X      strcat(r, ".DIR");        /* this assumes a little padding--see PAD */
X    }
X    else
X      *p = 0;
X  }
X  else
X    *p = 0;
X#else /* !VMS */                /* change w/x/y/z to w/x/y */
X  if ((r = strrchr(p, '/')) != NULL)
X    *r = 0;
X  else
X    *p = 0;
X#endif /* ?VMS */
X  return p;
X}
X
X
Xint trash()
X/* Delete the compressed files and the directories that contained the deleted
X   files, if empty.  Return an error code in the ZE_ class.  Failure of
X   destroy() or deletedir() is ignored. */
X{
X  extent i;             /* counter on deleted names */
X  extent k;             /* number of deleted directories this pass */
X  extent n;             /* number of deleted names left to handle */
X  struct zlist far **s; /* table of zip entries to handle, sorted */
X  struct zlist far *z;  /* current zip entry */
X
X  /* Count and delete marked names */
X  n = 0;
X  for (z = zfiles; z != NULL; z = z->nxt)
X    if (z->mark || z->trash)
X    {
X      z->mark = 1;
X      n++;
X      if (verbose)
X        printf("zip diagnostic: trashing file %s\n", z->name);
X      destroy(z->name);
X    }
X
X  /* Try to delete all paths that lead up to marked names */
X  if (n)
X  {
X    if ((s = (struct zlist far **)malloc((n+1)*sizeof(struct zlist far *))) ==
X        NULL ||
X        (s[0] = (struct zlist far *)farmalloc(sizeof(struct zlist))) == NULL)
X      return ZE_MEM;
X    s[0]->name = "";
X    s++;
X    do {
X      n = k = 0;
X      for (z = zfiles; z != NULL; z = z->nxt)
X        if (z->mark)
X          s[n++] = z;
X      qsort((char *)s, n, sizeof(struct zlist far *), zqcmp);
X      for (i = 0; i < n; i++)
X        if (*cutpath(s[i]->name) && strcmp(s[i]->name, s[i-1]->name))
X        {
X          if (verbose)
X            printf("zip diagnostic: trashing directory %s\n", s[i]->name);
X          deletedir(s[i]->name);
X          k++;
X        }
X        else
X          s[i]->mark = 0;
X    } while (k);
X    farfree((voidp far *)((--s)[0]));
X    free((voidp *)s);
X  }
X  return ZE_OK;
X}
X
X#endif /* !UTIL */
END_OF_FILE
  if test 24578 -ne `wc -c <'zipfile.c'`; then
    echo shar: \"'zipfile.c'\" unpacked with wrong size!
  fi
  # end of 'zipfile.c'
fi
echo shar: End of archive 6 \(of 11\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
