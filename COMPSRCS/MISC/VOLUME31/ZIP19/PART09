Newsgroups: comp.sources.misc
From: zip-bugs@cs.ucla.edu (Info-ZIP group)
Subject:  v31i101:  zip19 - Info-ZIP portable Zip, version 1.9, Part09/11
Message-ID: <1992Aug23.064947.29627@sparky.imd.sterling.com>
X-Md4-Signature: 21a7f40fe6ce3bc3b1189116643da76f
Date: Sun, 23 Aug 1992 06:49:47 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: zip-bugs@cs.ucla.edu (Info-ZIP group)
Posting-number: Volume 31, Issue 101
Archive-name: zip19/part09
Supersedes: zip: Volume 23, Issue 88-96
Environment: UNIX, VMS, OS/2, MS-DOS, MACINTOSH, WIN-NT, LINUX, MINIX, XOS, !AMIGA, ATARI, symlink, SGI, DEC, Cray, Convex, Amdahl, Sun, PC

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  atari/makefile.st infozip.who mac/macfile.c mac/macstat.c
#   makefile msdos/makefile.msc.UU msdos/match.asm os2/match32.asm.UU
#   vms/VMSmunch.h vms/vaxclib.opt
# Wrapped by kent@sparky on Sun Aug 23 01:00:46 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 9 (of 11)."'
if test -f 'atari/makefile.st' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'atari/makefile.st'\"
else
  echo shar: Extracting \"'atari/makefile.st'\" \(1949 characters\)
  sed "s/^X//" >'atari/makefile.st' <<'END_OF_FILE'
X# Makefile for Zip, ZipNote and ZipSplit for
X# Atari ST with Turbo C 2.0.
X
X# To use, do "make -f makefile.st"
X
X# ------------- Turbo C -------------
XTCHOME=\TC
X
XCFLAGS=-A -G -I$(TCHOME)\INCLUDE -DATARI_ST
XUTILFLAGS=-DUTIL $(CFLAGS)
XCC=tcc
XLD=tlink
XLDFLAGS= -S=8192
X
X# variables
XOBJZ = zip.o zipfile.o zipup.o fileio.o util.o globals.o atari.o
XOBJI = deflate.o trees.o bits.o
X
XOBJU = zipfile_.o zipup_.o fileio_.o util_.o globals.o
XOBJN = zipnote.o  $(OBJU)
XOBJS = zipsplit.o $(OBJU)
X
Xzips:	zip.prg zipnote.prg zipsplit.prg
X	echo done
X
Xatari.o: atari.c
X	$(CC) -c $(CFLAGS) atari.c
X
Xzip.o:	zip.h ziperr.h tailor.h revision.h zip.c
X	$(CC) -c $(CFLAGS) zip.c
X
Xzipfile.o:	zip.h ziperr.h tailor.h zipfile.c
X	$(CC) -c $(CFLAGS) zipfile.c
X
Xzipup.o:	zip.h ziperr.h tailor.h revision.h zipup.c
X	$(CC) -c $(CFLAGS) zipup.c
X
Xfileio.o:	zip.h ziperr.h tailor.h fileio.c
X	$(CC) -c $(CFLAGS) fileio.c
X
Xutil.o:	zip.h ziperr.h tailor.h util.c
X	$(CC) -c $(CFLAGS) util.c
X
Xglobals.o:	zip.h ziperr.h tailor.h globals.c
X	$(CC) -c $(CFLAGS) globals.c
X
Xzipnote.o:	zip.h ziperr.h tailor.h revision.h zipnote.c
X	$(CC) -c $(CFLAGS) zipnote.c
X
Xzipsplit.o:	zipsplit.c zip.h ziperr.h tailor.h revision.h
X	$(CC) -c $(CFLAGS) zipsplit.c
X
Xdeflate.o:	zip.h ziperr.h tailor.h deflate.c
X	$(CC) -c $(CFLAGS) deflate.c
X
Xtrees.o:	zip.h ziperr.h tailor.h trees.c
X	$(CC) -c $(CFLAGS) trees.c
X
Xbits.o:		zip.h ziperr.h tailor.h bits.c
X	$(CC) -c $(CFLAGS) bits.c
X
Xzipfile_.o:	zipfile.c zip.h ziperr.h tailor.h
X	$(CC) -c $(UTILFLAGS) -Ozipfile_.o zipfile.c
X
Xzipup_.o:	zipup.c zip.h ziperr.h tailor.h
X	$(CC) -c $(UTILFLAGS) -Ozipup_.o zipup.c
X
Xfileio_.o:	fileio.c zip.h ziperr.h tailor.h
X	$(CC) -c $(UTILFLAGS) -Ofileio_.o fileio.c
X
Xutil_.o:	util.c zip.h ziperr.h tailor.h
X	$(CC) -c $(UTILFLAGS) -Ofileio_.o fileio.c
X
Xzip.prg: $(OBJZ) $(OBJI)
X	$(LD) $(LDFLAGS) -C=zip.lnk -O=$@
X
Xzipnote.prg: $(OBJN)
X	$(LD) $(LDFLAGS) -C=zipn.lnk -O=$@
X
Xzipsplit.prg: $(OBJS)
X	$(LD) $(LDFLAGS) -C=zips.lnk -O=$@
END_OF_FILE
  if test 1949 -ne `wc -c <'atari/makefile.st'`; then
    echo shar: \"'atari/makefile.st'\" unpacked with wrong size!
  fi
  # end of 'atari/makefile.st'
fi
if test -f 'infozip.who' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'infozip.who'\"
else
  echo shar: Extracting \"'infozip.who'\" \(6165 characters\)
  sed "s/^X//" >'infozip.who' <<'END_OF_FILE'
XThese members of the INFO-ZIP group contributed to the development and
Xtesting of portable Zip.  They are responsible for whatever works in Zip.
XWhatever doesn't work is solely the fault of the authors of Zip (Mark Adler,
XRich Wales, Jean-loup Gailly, Kai Uwe Rommel and Igor Mandrichenko).
XBill Davidsen provided the envargs code. If you have contributed and
Xyour name has been forgotten, please send a reminder to the zip-bugs
Xaddress given in the Readme file.
X
XMark Adler              madler@tybalt.caltech.edu       NeXT 2.x
XGlenn J. Andrews        oper1%drcv06.decnet@drcvax.af.mil       VAX VMS
XTom Betz                marob!upaya!tbetz@phri.nyu.edu  SCO Xenix 2.3.1
XJames Birdsall          jwbirdsa@amc.com                AT&T 3B1
XWim Bonner              27313853@WSUVM1.CSC.WSU.EDU     HP 9000/840a HPUX
XPaul Borman             prb@cray.com                    Cray-X/YMP,2 UNICOS 6-8
XLeslie C. Brown         lbrown@BRL.MIL                  Pyramid MIS-4
XRalf Brown              ralf@b.gp.cs.cmu.edu            Pyramid MIS-4
XPietro Caselli          zaphod@petruz.sublink.org       Minix 1.5.10
XBill Davidsen           davidsen@crdos1.crd.ge.com      Xenix (on what?)
XDaniel Deimert          daniel@hexagon.se               zeus3.21 Zilog S8000
XJames P. Dugal          jpd@usl.edu                     Pyramid 90X OSx4.1
X"Evil Ed"               esaffle@gmuvax2.gmu.edu         Ulrix-32 V3.1 (Rev. 9)
XDavid A. Feinleib       t-davefe@microsoft.com          Windows NT
XGreg Flint              afc@klaatu.cc.purdue.edu        ETA-10P* hybrid Sys V
XJeff Foy                jfoy@glia.biostr.washington.edu IRIX Sys V Rel 3.3.1
XMike Freeman            freeman@watsun.cc.columbia.edu  Vax VMS
XKevin M. Fritz          kmfritz@apgea.army.mil          Turbo C++ 1.0
XJean-loup Gailly        jloup@chorus.fr                 MS-DOS Microsoft C 5.1
XScott D. Galloway       sgallowa@letterkenn-emh1.army.mil   Sperry 5000 SysV.3
XGeorge Grimes           grimes@netcom.com               Apollo Domain SR10.4
XHunter Goatley          goathunter@WKUVX1.BITNET        Vax VMS
XArnt Gulbrandsen        agulbra@pvv.unit.no             Linux
XDavid Gundlach          david@rolf.stat.uga.edu         Sun SS1+ SunOS 4.1
XBob Hardy               hardy@lucid.com                 Power C on MSDOS
XPeter Jones             jones@mips1.info.uqam.ca        MIPS UMIPS 4.0
XKjetil W. J{\o}rgensen  jorgens@lise.unit.no            OSF/1
XBruce Kahn              bkahn@archive.webo.dg.com       MS-DOS Microsoft C 5.1
XJonathan I. Kamens      jik@pit-manager.mit.edu         ultrix on DECstation
XBob Kemp                Robert.V.Kemp@att.com           AT&T 3B2 SysV 3.2v2
XEarl Kiech              KIECH@utkvx.utk.edu             VAX VMS V5.4-1A
XDavid Kirschbaum        kirsch@usasoc.soc.mil           He got us all in this
X                                                        mess in the first place
XBo Kullmar              bk@kullmar.se                   DNIX 5.2, 5.3
XHarry Langenbacher      harry@neuron6.Jpl.Nasa.Gov      Sun SS1+ SunOS 4.1
XMichael D. Lawler       mdlawler@bsu-cs.bsu.edu         Mt.Xinu BSD 4.3 on VAX
XJohnny Lee              johnnyl@microsoft.com           Microsoft C 7.0
XDavid Lemson            lemson@ux1.cso.uiuc.edu         Sequent Dynix 3.0.17
XOnno van der Linden     vdlinden@fwi.uva.nl             SCO Unix 3.2.0
X                                                        BC++ 3.0, djgcc 1.06
XWarner Losh             imp@Solbourne.COM               packing algorithm help
XJohn Lundin             lundin@urvax.urich.edu          VAX VMS
XIgor Mandrichenko       mandrichenko@m10.ihep.su        VAX VMS
XCliff Manis             root@csoftec.csf.com            SCO 2.3.1 (386)
XFulvio Marino           fulvio@iconet.ico.olivetti.it   X/OS 2.3 & 2.4
XBill Marsh              bmarsh@cod.nosc.mil             SGI Iris 4D35
XPeter Mauzey            ptm@mtdcc.att.com               AT&T 6300
XRafal Z. Maszkowski     <rzm%pltumk11.bitnet@mvs.oac.ucla.edu> Bug report
XRobert McBroom (?)      rm3@ornl.gov                    DECsystem 5810
XHumberto Ortiz-Zuazaga  zuazaga@ucunix.san.uc.edu       Linux
XJames E. O'Dell         jim@fpr.com                     MacOS
XWilliam O'Shaughnessy   williamo@hpcupt1.cup.hp.com     HPUX
XEnrico Renato Palmerini palmer@vxscaq.cineca.it         UNISYS 7000 Sys 5 r2.3
XKeith Petersen          w8sdz@simtel20.army.mil         Maintainer of Info-ZIP
X                                                        Pyramid UCB OSx4.4c
XDavid A Rasmussen       dave@convex.csd.uwm.edu         Convex C220 with 9.0 OS
XMichael Regoli          mr@cica.indiana.edu             Ultrix 3.1 VAX 8650
X                                                        BSD 4.3 IBM RT/125
X                                                        BSD 4.3 MicroVAX 3500
X                                                        SunOS 4.0.3 Sun 4/330
XRick Rodgers            rodgers@maxwell.mmwb.ucsf.EDU   Unix man page
XGreg Roelofs            roe2@midway.uchicago.edu        SunOS 4.1.1,4.1.2 Sun 4
X                                                        Unicos 5.1--6.1.5 Cray
X                                                        OS/2 1.3 MS C 6.0
X                                                        Ultrix 4.1,4.2 DEC 5810
X                                                        VMS 5.2, 5.4 VAX 8600
X                                                        Irix 3.3.2, SGI Iris 4D
X                                                        UTS 1.2.4 Amdahl 5880
XKai Uwe Rommel          rommel@informatik.tu-muenchen.de        OS/2
XJon Saxton              jrs@panix.com                   Microsoft C 6.0
XSteve Salisbury         stevesa@microsoft.com           Microsoft C 6.0
XMartin Schulz           martin@indian.cs.unb.ca         Atari ST
XDave Sisson             daves@vtcosy.cns.vt.edu         AIX 1.1.1 PS/2 & 3090
XRon Srodawa             srodawa@vela.acs.oakland.edu    SCO Xenix/386 2.3.3
XBertil Stenstr|m        stenis@heron.qz.se              HP-UX 7.0 HP9000/835
XAntoine Verheijen	antoine@sysmail.ucs.ualberta.ca envargs fix
XArjan de Vet            devet@info.win.tue.nl           SunOS 4.1, MSC 5.1
XRich Wales              wales@cs.ucla.edu               SunOS 4.0.3 Sun-3/50
END_OF_FILE
  if test 6165 -ne `wc -c <'infozip.who'`; then
    echo shar: \"'infozip.who'\" unpacked with wrong size!
  fi
  # end of 'infozip.who'
fi
if test -f 'mac/macfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/macfile.c'\"
else
  echo shar: Extracting \"'mac/macfile.c'\" \(6797 characters\)
  sed "s/^X//" >'mac/macfile.c' <<'END_OF_FILE'
X/*---------------------------------------------------------------------------
X
X  macfile.c
X
X  This source file is used by the mac port to support commands not available
X  directly on the Mac, i.e. mkdir().
X  It also helps determine if we're running on a Mac with HFS and a disk
X  formatted for HFS (HFS - Hierarchical File System; compared to its predecessor,
X  MFS - Macintosh File System).
X  
X  ---------------------------------------------------------------------------*/
X
X#include "unzip.h"
X
X#ifdef MACOS
X#ifndef FSFCBLen
X#define FSFCBLen    (*(short *)0x3F6)
X#endif
X
Xstatic short wAppVRefNum;
Xstatic long lAppDirID;
Xint hfsflag;            /* set if disk has hierarchical file system */
X
Xstatic int IsHFSDisk(short wRefNum)
X{
X    /* get info about the specified volume */
X    if (hfsflag == true) {
X        HParamBlockRec    hpbr;
X        Str255 temp;
X        short wErr;
X        
X        hpbr.volumeParam.ioCompletion = 0;
X        hpbr.volumeParam.ioNamePtr = temp;
X        hpbr.volumeParam.ioVRefNum = wRefNum;
X        hpbr.volumeParam.ioVolIndex = 0;
X        wErr = PBHGetVInfo(&hpbr, 0);
X
X        if (wErr == noErr && hpbr.volumeParam.ioVFSID == 0
X            && hpbr.volumeParam.ioVSigWord == 0x4244) {
X                return true;
X        }
X    }
X
X    return false;
X} /* IsHFSDisk */
X
Xvoid macfstest(int vrefnum)
X{
X    Str255 st;
X
X    /* is this machine running HFS file system? */
X    if (FSFCBLen <= 0) {
X        hfsflag = false;
X    }
X    else
X    {
X        hfsflag = true;
X    }
X
X    /* get the file's volume reference number and directory ID */
X    if (hfsflag == true) {
X        WDPBRec    wdpb;
X        OSErr err = noErr;
X
X        if (vrefnum != 0) {
X            wdpb.ioCompletion = false;
X            wdpb.ioNamePtr = st;
X            wdpb.ioWDIndex = 0;
X            wdpb.ioVRefNum = vrefnum;
X            err = PBHGetVol(&wdpb, false);
X        
X            if (err == noErr) {
X                wAppVRefNum = wdpb.ioWDVRefNum;
X                lAppDirID = wdpb.ioWDDirID;
X            }
X        }
X
X        /* is the disk we're using formatted for HFS? */
X        hfsflag = IsHFSDisk(wAppVRefNum);
X    }
X    
X    return;
X} /* mactest */
X
Xint macmkdir(char *path, short nVRefNum, long lDirID)
X{
X    OSErr    err = -1;
X
X    if (path != 0 && strlen(path)<256 && hfsflag == true) {
X        HParamBlockRec    hpbr;
X        Str255    st;
X
X        CtoPstr(path);
X        if ((nVRefNum == 0) && (lDirID == 0))
X        {
X            hpbr.fileParam.ioNamePtr = st;
X            hpbr.fileParam.ioCompletion = NULL;
X            err = PBHGetVol((WDPBPtr)&hpbr, false);
X            nVRefNum = hpbr.wdParam.ioWDVRefNum;
X            lDirID = hpbr.wdParam.ioWDDirID;
X        }
X        else
X        {
X            err = noErr;
X        }
X        if (err == noErr) {
X            hpbr.fileParam.ioCompletion = NULL;
X            hpbr.fileParam.ioVRefNum = nVRefNum;
X            hpbr.fileParam.ioDirID = lDirID;
X            hpbr.fileParam.ioNamePtr = (StringPtr)path;
X            err = PBDirCreate(&hpbr, false);
X        }    
X        PtoCstr(path);
X    }
X
X    return (int)err;
X} /* mkdir */
X
Xvoid ResolveMacVol(short nVRefNum, short *pnVRefNum, long *plDirID, StringPtr pst)
X{
X    if (hfsflag)
X    {
X        WDPBRec  wdpbr;
X        Str255   st;
X        OSErr    err;
X
X        wdpbr.ioCompletion = (ProcPtr)NULL;
X        wdpbr.ioNamePtr = st;
X        wdpbr.ioVRefNum = nVRefNum;
X        wdpbr.ioWDIndex = 0;
X        wdpbr.ioWDProcID = 0;
X        wdpbr.ioWDVRefNum = 0;
X        err = PBGetWDInfo( &wdpbr, false );
X        if ( err == noErr )
X        {
X            if (pnVRefNum)
X                *pnVRefNum = wdpbr.ioWDVRefNum;
X            if (plDirID)
X                *plDirID = wdpbr.ioWDDirID;
X            if (pst)
X                BlockMove( st, pst, st[0]+1 );
X        }
X    }
X    else
X    {
X        if (pnVRefNum)
X            *pnVRefNum = nVRefNum;
X        if (plDirID)
X            *plDirID = 0;
X        if (pst)
X            *pst = 0;
X    }
X}
X
Xshort macopen(char *sz, short nFlags, short nVRefNum, long lDirID)
X{
X    OSErr   err;
X    Str255  st;
X    char    chPerms = (!nFlags) ? fsRdPerm : fsRdWrPerm;
X    short   nFRefNum;
X
X    CtoPstr( sz );
X    BlockMove( sz, st, sz[0]+1 );
X    PtoCstr( sz );
X    if (hfsflag)
X    {
X        if (nFlags > 1)
X            err = HOpenRF( nVRefNum, lDirID, st, chPerms, &nFRefNum);
X        else
X            err = HOpen( nVRefNum, lDirID, st, chPerms, &nFRefNum);
X    }
X    else
X    {
X        /*
X         * Have to use PBxxx style calls since the high level
X         * versions don't support specifying permissions
X         */
X        ParamBlockRec    pbr;
X
X        pbr.ioParam.ioNamePtr = st;
X        pbr.ioParam.ioVRefNum = gnVRefNum;
X        pbr.ioParam.ioVersNum = 0;
X        pbr.ioParam.ioPermssn = chPerms;
X        pbr.ioParam.ioMisc = 0;
X        if (nFlags >1)
X            err = PBOpenRF( &pbr, false );
X        else
X            err = PBOpen( &pbr, false );
X        nFRefNum = pbr.ioParam.ioRefNum;
X    }
X    if ( err )
X        return -1;
X    else
X        return nFRefNum;
X}
X
Xshort maccreat(char *sz, short nVRefNum, long lDirID, OSType ostCreator, OSType ostType)
X{
X    OSErr   err;
X    Str255  st;
X    FInfo   fi;
X
X    CtoPstr( sz );
X    BlockMove( sz, st, sz[0]+1 );
X    PtoCstr( sz );
X    if (hfsflag)
X    {
X        err = HGetFInfo( nVRefNum, lDirID, st, &fi );
X        if (err == fnfErr)
X            err = HCreate( nVRefNum, lDirID, st, ostCreator, ostType );
X        else if (err == noErr)
X        {
X            fi.fdCreator = ostCreator;
X            fi.fdType = ostType;
X            err = HSetFInfo( nVRefNum, lDirID, st, &fi );
X        }
X    }
X    else
X    {
X        err = GetFInfo( st, nVRefNum, &fi );
X        if (err == fnfErr)
X            err = Create( st, nVRefNum, ostCreator, ostType );
X        else if (err == noErr)
X        {
X            fi.fdCreator = ostCreator;
X            fi.fdType = ostType;
X            err = SetFInfo( st, nVRefNum, &fi );
X        }
X    }
X    if (err == noErr)
X        return noErr;
X    else
X        return -1;
X}
X
Xshort macread(short nFRefNum, char *pb, unsigned cb)
X{
X    long    lcb = cb;
X
X    (void)FSRead( nFRefNum, &lcb, pb );
X
X    return (short)lcb;
X}
X
Xshort macwrite(short nFRefNum, char *pb, unsigned cb)
X{
X    long    lcb = cb;
X
X    (void)FSWrite( nFRefNum, &lcb, pb );
X
X    return (short)lcb;
X}
X
Xshort macclose(short nFRefNum)
X{
X    return FSClose( nFRefNum );
X}
X
Xlong maclseek(short nFRefNum, long lib, short nMode)
X{
X    ParamBlockRec   pbr;
X
X    if (nMode == SEEK_SET)
X        nMode = fsFromStart;
X    else if (nMode == SEEK_CUR)
X        nMode = fsFromMark;
X    else if (nMode == SEEK_END)
X        nMode = fsFromLEOF;
X    pbr.ioParam.ioRefNum = nFRefNum;
X    pbr.ioParam.ioPosMode = nMode;
X    pbr.ioParam.ioPosOffset = lib;
X    (void)PBSetFPos(&pbr, 0);
X    return pbr.ioParam.ioPosOffset;
X}
X
X#endif /* MACOS */
END_OF_FILE
  if test 6797 -ne `wc -c <'mac/macfile.c'`; then
    echo shar: \"'mac/macfile.c'\" unpacked with wrong size!
  fi
  # end of 'mac/macfile.c'
fi
if test -f 'mac/macstat.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mac/macstat.c'\"
else
  echo shar: Extracting \"'mac/macstat.c'\" \(5863 characters\)
  sed "s/^X//" >'mac/macstat.c' <<'END_OF_FILE'
X#ifdef THINK_C
X#define MACOS
X#include    <pascal.h>
X#endif
X#ifdef MPW
X#define MACOS
X#include    <Files.h>
X#include    <Errors.h>
X#define FSFCBLen    (*(short *)0x3F6)
X#define CtoPstr c2pstr
X#define PtoCstr p2cstr
X#endif
X
X#ifdef MACOS
X#include    <string.h>
X#include    "macstat.h"
Xint macstat(char *path, struct stat *buf, short nVRefNum, long lDirID );
X
X#define unixTime(t) ((t) = ((t) < (time_t)0x7c25b080) ? 0 : (t) - (time_t)0x7c25b080)
X
X/* assume that the path will contain a Mac-type pathname, i.e. ':'s, etc. */
Xint macstat(char *path, struct stat *buf, short nVRefNum, long lDirID )
X{
X    char    temp[256];
X    short   nVRefNumT;
X    long    lDirIDT;
X    short   fIsHFS = false;
X    OSErr   err;
X    short   fUseDefault = ((nVRefNum == 0) && (lDirID == 0));
X
X    if (buf == (struct stat *)0L || path == (char *)0L) {
X        SysBeep(1);
X        return -1;
X    }
X
X    if (path[0] == '\0' || strlen(path)>255) {
X        return -1;
X    }
X
X    if ( fUseDefault )
X    {
X        if (GetVol((StringPtr)&temp[0], &nVRefNumT) != noErr) {
X            SysBeep(1);
X            return -1;
X        }
X    }
X
X    /* get info about the specified volume */
X    if (FSFCBLen > 0)   /* HFS Disk? */
X    {
X        HParamBlockRec    hpbr;
X
X        if ( fUseDefault )
X        {
X            WDPBRec wdpb;
X    
X            wdpb.ioCompletion = 0;
X            wdpb.ioNamePtr = (StringPtr)temp;
X            err = PBHGetVol(&wdpb, 0);
X            nVRefNumT = wdpb.ioWDVRefNum;
X            lDirIDT = wdpb.ioWDDirID;
X        }
X        else
X        {
X            nVRefNumT = nVRefNum;
X            lDirIDT = lDirID;
X            err = noErr;
X        }
X        if (err == noErr)
X        {
X            hpbr.volumeParam.ioCompletion = 0;
X            hpbr.volumeParam.ioNamePtr = (StringPtr)temp;
X            hpbr.volumeParam.ioVRefNum = nVRefNumT;
X            hpbr.volumeParam.ioVolIndex = 0;
X            err = PBHGetVInfo(&hpbr, 0);
X
X            if (err == noErr && hpbr.volumeParam.ioVFSID == 0
X                && hpbr.volumeParam.ioVSigWord == 0x4244) {
X                    fIsHFS = true;
X            }
X        }
X    }
X
X
X    /* number of links, at least in System 6.0x, 0 */
X    buf->st_nlink = 0;
X    /* user id */
X    buf->st_uid = 0;
X    /* group id */
X    buf->st_gid = 0;
X
X    if (fIsHFS == true)   /* HFS? */
X    {
X        CInfoPBRec  cPB;
X        HParamBlockRec  hPB;
X
X        /* get information about file */
X        cPB.hFileInfo.ioCompletion = (ProcPtr)0L;
X        CtoPstr(path);
X        strncpy(temp,path, path[0]+1);
X        PtoCstr(path);
X        cPB.hFileInfo.ioNamePtr = (StringPtr)temp;
X        cPB.hFileInfo.ioVRefNum = nVRefNumT;
X        cPB.hFileInfo.ioDirID = lDirIDT;
X        cPB.hFileInfo.ioFDirIndex = 0;
X
X        err = PBGetCatInfo(&cPB, false); 
X
X        if (err != noErr) {
X            if (err != fnfErr) {
X                SysBeep(1);
X            }
X            return -1;
X        }
X        
X        /* Type of file: directory or regular file + access */
X        buf->st_mode = (cPB.hFileInfo.ioFlAttrib & ioDirMask) ? S_IFDIR : S_IFREG |
X                       (cPB.hFileInfo.ioFlAttrib & 0x01) ? S_IREAD : (S_IREAD | S_IWRITE);
X        
X        /* last access time, modification time and creation time(?) */
X        buf->st_atime = buf->st_mtime = cPB.hFileInfo.ioFlMdDat;
X        buf->st_ctime = cPB.hFileInfo.ioFlCrDat;
X        /* dev number */
X        buf->st_dev = (long)cPB.hFileInfo.ioVRefNum;
X        /* inode number */
X        buf->st_ino = cPB.hFileInfo.ioDirID;
X        /* size of file - use only the data fork */
X        buf->st_size = cPB.hFileInfo.ioFlLgLen;
X
X        /* size of disk block */
X        hPB.volumeParam.ioCompletion = (ProcPtr)0L;
X        hPB.volumeParam.ioNamePtr = (StringPtr)temp;
X        hPB.volumeParam.ioVRefNum = nVRefNumT;
X        hPB.volumeParam.ioVolIndex = 0;
X
X        err = PBHGetVInfo(&hPB, false);
X
X        if (err != noErr) {
X            SysBeep(1);
X            return -1;
X        }
X            
X        buf->st_blksize = cPB.hFileInfo.ioFlPyLen / hPB.volumeParam.ioVAlBlkSiz;
X    }
X    else    /* MFS? */
X    {
X        ParamBlockRec   pPB;
X        ParamBlockRec   hPB;
X
X        CtoPstr(path);
X        strncpy(temp, path, path[0]+1);
X        PtoCstr(path);
X        pPB.fileParam.ioCompletion = (ProcPtr)0;
X        pPB.fileParam.ioNamePtr = (StringPtr)temp;
X        pPB.fileParam.ioVRefNum = nVRefNumT;
X        pPB.fileParam.ioFVersNum = 0;
X        pPB.fileParam.ioFDirIndex = 0;
X
X        err = PBGetFInfo(&pPB, false);
X
X        if (err != noErr) {
X            SysBeep(1);
X            return -1;
X        }
X
X        /* Type of file: either directory or regular file + access */
X        buf->st_mode = (pPB.fileParam.ioFlAttrib & ioDirMask) ? S_IFDIR : S_IFREG;
X                       (pPB.fileParam.ioFlAttrib & 0x01) ? S_IREAD : (S_IREAD | S_IWRITE);
X
X        /* last access time, modification time and creation time(?) */
X        buf->st_atime = buf->st_mtime = pPB.fileParam.ioFlMdDat;
X        buf->st_ctime = pPB.fileParam.ioFlCrDat;
X        /* dev number */
X        buf->st_dev = (long)pPB.fileParam.ioVRefNum;
X        /* inode number */
X        buf->st_ino = pPB.fileParam.ioFlNum;
X        /* size of file - use only the data fork */
X        buf->st_size = pPB.fileParam.ioFlLgLen;
X
X        /* size of disk block */
X        hPB.volumeParam.ioCompletion = (ProcPtr)0;
X        hPB.volumeParam.ioNamePtr = (StringPtr)temp;
X        hPB.volumeParam.ioVRefNum = nVRefNumT;
X        hPB.volumeParam.ioVolIndex = 0;
X
X        err = PBGetVInfo(&hPB, false);
X
X        if (err != noErr) {
X            SysBeep(1);
X            return -1;
X        }
X
X        buf->st_blksize = pPB.fileParam.ioFlPyLen / hPB.volumeParam.ioVAlBlkSiz;
X    }
X
X    /* Convert from Macintosh time format to Unix time format. */
X
X    unixTime(buf->st_atime);
X    unixTime(buf->st_mtime);
X    unixTime(buf->st_ctime);
X
X    return 0;
X}
X#else
X#error 1
X#endif
END_OF_FILE
  if test 5863 -ne `wc -c <'mac/macstat.c'`; then
    echo shar: \"'mac/macstat.c'\" unpacked with wrong size!
  fi
  # end of 'mac/macstat.c'
fi
if test -f 'makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile'\"
else
  echo shar: Extracting \"'makefile'\" \(7055 characters\)
  sed "s/^X//" >'makefile' <<'END_OF_FILE'
X# Makefile for Zip, ZipNote, ZipCloak and ZipSplit
X
X# what you can make ...
Xall:
X	@echo ''
X	@echo 'Make what?  You must say what system to make Zip for--e.g.'
X	@echo '"make bsd".  Choices: bsd, bsdold, sysv, sysv_old, sysv_386,'
X	@echo 'dnix, linux, sun, sun_gcc, next10, next, hpux, cray, cray3,'
X	@echo '3b1, att6300, zilog, scodos, aux, c120, convex, aix, minix,'
X	@echo 'isc, ultrix, dec_osf1 and xos.'
X	@echo 'See the files install.doc and zip.doc for more information.'
X	@echo ''
X
XCRYPTO =
XCLOAK =
XCRFLAG =
XMAKE = make
X#  **********************************************************************
X#  *** For encryption version, remove the # at the front of next line ***
X# MAKE = make CRYPTO="crypt.o" CLOAK="zipcloak" CRFLAG="-DCRYPT"
X
X# (to use the Gnu compiler, change cc to gcc in CC and BIND)
XCC = cc
XBIND = cc
XE =
XCPP = /usr/lib/cpp -Dunix
X
X# probably can change this to 'install' if you have it
XINSTALL = cp
X
X# target directories - where to install executables and man pages to
XBINDIR = /usr/local/bin
XMANDIR = /usr/man/manl
X
X# flags
X#   CFLAGS    flags for C compile
X#   LFLAGS1   flags after output file spec, before obj file list
X#   LFLAGS2   flags after obj file list (libraries, etc)
XCFLAGS = -O
XLFLAGS1 =
XLFLAGS2 = -s
X
X# object file lists
XOBJZ = zip.o zipfile.o zipup.o fileio.o util.o globals.o $(CRYPTO)
X
XOBJI = deflate.o trees.o bits.o
XOBJA =
XOBJU = zipfile_.o zipup_.o fileio_.o util_.o globals.o
XOBJN = zipnote.o  $(OBJU)
XOBJC = zipcloak.o $(OBJU) crypt_.o
XOBJS = zipsplit.o $(OBJU)
X
X# suffix rules
X.SUFFIXES:
X.SUFFIXES: _.o .o .c .doc .1
X.c_.o:
X	rm -f $*_.c; ln $< $*_.c
X	$(CC) $(CFLAGS) -DUTIL $(CRFLAG) -c $*_.c
X	rm -f $*_.c
X.c.o:
X	$(CC) $(CFLAGS) $(CRFLAG) -c $<
X
X.1.doc:
X	nroff -man $< | col -b | uniq > $@
X
X# rules for zip, zipnote, zipcloak, zipsplit, and zip.doc.
X$(OBJZ): zip.h ziperr.h tailor.h
X$(OBJI): zip.h ziperr.h tailor.h
X$(OBJN): zip.h ziperr.h tailor.h
X$(OBJS): zip.h ziperr.h tailor.h
X$(OBJC): zip.h ziperr.h tailor.h
X
Xmatch.o: match.s
X	$(CPP) match.s > _match.s
X	$(CC) -c _match.s
X	mv _match.o match.o
X	rm -f _match.s
X
XZIPS = zip$E zipnote$E zipsplit$E $(CLOAK)$E
X
Xzip.o zipup.o zipnote.o zipcloak.o zipsplit.o: revision.h
Xzips: $(ZIPS)
Xzipsman: zip zipnote zipsplit $(CLOAK) zip.doc
X
Xzip$E: $(OBJZ) $(OBJI) $(OBJA)
X	$(BIND) -o zip$E $(LFLAGS1) $(OBJZ) $(OBJI) $(OBJA) $(LFLAGS2)
Xzipnote$E: $(OBJN)
X	$(BIND) -o zipnote$E $(LFLAGS1) $(OBJN) $(LFLAGS2)
Xzipcloak$E: $(OBJC)
X	$(BIND) -o zipcloak$E $(LFLAGS1) $(OBJC) $(LFLAGS2)
Xzipsplit$E: $(OBJS)
X	$(BIND) -o zipsplit$E $(LFLAGS1) $(OBJS) $(LFLAGS2)
X
X# install
Xinstall:	$(ZIPS)
X	$(INSTALL) $(ZIPS) $(BINDIR)
X	$(INSTALL) zip.1 $(MANDIR)
X
X
X# These symbols, when #defined using -D have these effects on compilation:
X# ZMEM		- includes C language versions of memset(), memcpy(), and
X#		  memcmp() (util.c).
X# DIRENT	- use <sys/dirent.h> and getdents() instead of <sys/dir.h>
X#		  and opendir(), etc. (fileio.c).
X# NODIR		- used for 3B1, which has neither getdents() nor opendir().
X# NDIR		- use "ndir.h" instead of <sys/dir.h> (fileio.c).
X# UTIL		- select routines for utilities (note, cloak, and split).
X# PROTO		- enable function prototypes.
X# RMDIR		- remove directories using a system("rmdir ...") call.
X# CONVEX	- for Convex make target.
X# AIX		- for AIX make target.
X# CRYPT 	- include the encryption code.
X# LINUX		- for linux make target.
X
X# BSD 4.3 (also Unisys 7000--AT&T System V with heavy BSD 4.2)
Xbsd:
X	$(MAKE) zips CFLAGS="-O"
X
X# BSD, but missing memset(), memcmp().
Xbsdold:
X	$(MAKE) zips CFLAGS="-O -DZMEM"
X
X# AT&T System V, Rel 3.  Also SCO, Xenix, OpenDeskTop, ETA-10P*, SGI.
Xsysv_old:
X	$(MAKE) zips CFLAGS="-O -DDIRENT"
X
X# AT&T System V, Rel 4. Also any system with readdir() and termio.
Xsysv:
X	$(MAKE) zips CFLAGS="-O -DSYSV -DTERMIO"
X
X# AT&T System V, Rel 4 for 386 (uses asm version):
Xsysv_386:
X	$(MAKE) zips CFLAGS="-O -DSYSV -DTERMIO -DASM" OBJA=match.o
X
X# DNIX 5.x: like System V but optimization is messed up.
Xdnix:
X	$(MAKE) zips CFLAGS="-DDIRENT"
X
X# Linux 0.96a with GCC 2.12, dies with <= 2.11c. The problem with
X# builtin functions still has to be investigated.
Xlinux:
X	$(MAKE) zips CFLAGS="-O -fno-builtin -DSYSV -DTERMIO -DLINUX"
X
X# Sun OS 4.x: BSD, but use getdents(). If you have gcc, use 'make sun_gcc'
X# instead since the code produced is better.
Xsun:
X	$(MAKE) zips CFLAGS="-O4 -DDIRENT"
X
X# Sun OS 4.x with gcc (bug with -s linker flag). Use -O if your version
X# of gcc does not like -O2.
Xsun_gcc:
X	$(MAKE) zips CFLAGS="-O2 -DDIRENT" CC=gcc BIND=gcc LFLAGS2=""
X	strip $(ZIPS)
X
X# NeXT 1.0: BSD, but use shared library.
Xnext10:
X	$(MAKE) zips CFLAGS="-O" LFLAGS2="-s -lsys_s"
X
X# NeXT 2.0: BSD, but use MH_OBJECT format for smaller executables.
Xnext:
X	$(MAKE) zips CFLAGS="-O" LFLAGS2="-s -object"
X
X# HPUX: System V, but use <ndir.h> and opendir(), etc.
Xhpux:
X	$(MAKE) zips CFLAGS="-O -DNDIR"
X
X# Cray Unicos 5.1.10 & 6.0.11, Standard C compiler 2.0
Xcray:
X	$(MAKE) zips CFLAGS="-O -DDIRENT" CC="scc"
X
X# Cray Unicos 6.1, Standard C compiler 3.0 (all routines except trees.c
X# may be compiled with vector3; internal compiler bug in 3.0.2.3 and
X# earlier requires vector2 for trees.c)
Xcray3:
X	$(MAKE) zips CFLAGS="-O -h vector2 -h scalar3 -DDIRENT" CC="scc"
X
X# AT&T 3B1: System V, but missing a few things.
X3b1:
X	$(MAKE) zips CFLAGS="-O -DNODIR -DRMDIR"
X
X# AT&T 6300 PLUS (don't know yet how to allocate 64K bytes):
Xatt6300:
X	$(MAKE) zips LFLAGS1="-Ml" \
X	CFLAGS="-O -Ml -DNODIR -DRMDIR -DDYN_ALLOC -DMEDIUM_MEM -DWSIZE=16384"
X
X# zilog zeus 3.21
Xzilog:
X	$(MAKE) zips CFLAGS="-O -DZMEM -DNDIR -DRMDIR" CC="scc -i" BIND="scc"
X
X# SCO 386 cross compile for MS-DOS
X# Note: zip.exe should be lzexe'd on DOS to reduce its size
Xscodos:
X	$(MAKE) zips CFLAGS="-O -Mc -dos -DNO_ASM" LFLAGS1="-Mc -dos" \
X	 LFLAGS2="-F 1000" E=".exe"
X
X# A/UX:
Xaux:
X	$(MAKE) zips CFLAGS="-O -DTERMIO"
X
X# Convex C120, OS 9.0, cc v. 4.0, no vectorization.
Xc120:
X	$(MAKE) zips CFLAGS="-O1 -rl -DCONVEX"
X
X# Convex C220, OS 9.0
Xconvex:
X	$(MAKE) zips CFLAGS="-O2 -rl -DCONVEX"
X
X# AIX Version 3.1 for RISC System/6000 
Xaix:
X	$(MAKE) zips CC="c89" BIND="c89" \
X	   CFLAGS="-O -D_POSIX_SOURCE -D_ALL_SOURCE -D_BSD -DAIX"
X
X# MINIX 1.5.10 with Bruce Evans 386 patches and gcc/GNU make
Xminix:
X	$(MAKE) zips CFLAGS="-O -DDIRENT -DMINIX" CC=gcc BIND=gcc
X	chmem =262144 zip
X
X# Interactive Systems Corporation System V/386, Rel 3.2--optimizer problems
Xisc:
X	$(MAKE) zips CFLAGS="-DDIRENT"
X
X# DYNIX (R) V3.0.18 (no memset() or memcmp(), rindex() instead of strrchr())
Xdynix:
X	$(MAKE) zips CFLAGS="-O -DZMEM -Dstrrchr=rindex"
X
X# Ultrix
Xultrix:
X	$(MAKE) zips CFLAGS="-O -Olimit 700"
X
X# DEC OSF/1
Xdec_osf1:
X	$(MAKE) zips CFLAGS="-O -Olimit 1000 -DOSF -D_BSD"
X
X# xos: Olivetti LSX-3005..3045 with X/OS 2.3 or 2.4
Xxos:
X	$(MAKE) zips CFLAGS="-O -DTERMIO"
X
X# clean up after making stuff and installing it
Xclean:
X	rm -f *.o
X	rm -f $(ZIPS)
X
X# This one's for Mark:
Xit:
X	$(MAKE) zipsman CFLAGS="-O -Wall -DPROTO"\
X	LFLAGS2="-s -object" VPATH="${HOME}/Unix/bin"
X
X# and this one for Jean-loup:
Xgcc_d:
X	$(MAKE) zip CFLAGS="-g -DDEBUG -DDIRENT" CC=gcc BIND=gcc LFLAGS2="-g"
X	mv zip zipd
X
X# end of Makefile
END_OF_FILE
  if test 7055 -ne `wc -c <'makefile'`; then
    echo shar: \"'makefile'\" unpacked with wrong size!
  fi
  # end of 'makefile'
fi
if test -f 'msdos/makefile.msc.UU' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'msdos/makefile.msc.UU'\"
else
  echo shar: Extracting \"'msdos/makefile.msc.UU'\" \(5501 characters\)
  sed "s/^X//" >'msdos/makefile.msc.UU' <<'END_OF_FILE'
Xbegin 666 msdos/makefile.msc
XM(R!-86ME9FEL92!F;W(@6FEP+"!::7!#;&]A:RP@6FEP3F]T92!A;F0@6FEP
XM4W!L:70@9F]R#0HC($UI8W)O<V]F="!#(#4N,2!O<B V+C N#0H-"B,@5&\@
XM=7-E+"!D;R B;6%K92!M86ME9FEL92YM<V,B#0H-"B,@061D("U$4TU!3$Q?
XM345-(&]R("U$345$255-7TU%32!T;R!#1DQ!1U,@:68@>6]U('=I<V@@=&\@
XM<F5D=6-E('1H92!M96UO<GD-"B,@<F5Q=6ER96UE;G1S+B!!9&0@+41.3U]!
XM4TT@=&\@0T9,04=3(&%N9"!R96UO=F4@;6%T8V@N;V)J(&9R;VT@3T)*22!I
XM9@T*(R!Y;W4@9&\@;F]T(&AA=F4@;6%S;2X-"@T*0U)94%1//0T*0TQ/04L]
XM#0I#4D9,04<]#0H-"B,@("HJ*B!&;W(@96YC<GEP=&EO;B!V97)S:6]N+"!R
XM96UO=F4@=&AE(",@870@=&AE(&9R;VYT(&]F(&YE>'0@,R!L:6YE<R J*BH-
XM"B-#4EE05$\]8W)Y<'0N;V)J#0HC0TQ/04L]>FEP8VQO86LN97AE#0HC0U)&
XM3$%'/2U$0U)94%0-"@T*(R M+2TM+2TM+2TM+2TM($UI8W)O<V]F="!#(#4N
XM,2!O<B V+C @+2TM+2TM+2TM+2TM+0T*34]$14P]+4%##0I&4#T-"D-&3$%'
XM4STM5S,@+4]X("UN;VQO9V\@)"A-3T1%3"D@)"A&4"D@)"A#4D9,04<I#0I3
XM4$5#1DQ!1U,]+5<S("U/86EC=" M1W,@+6YO;&]G;R D*$U/1$5,*2 D*$90
XM*2 D*$-21DQ!1RD-"E5424Q&3$%'4STM1%5424P@)"A#1DQ!1U,I("U&;PT*
XM0T,]8VP-"DQ$/6QI;FL-"DQ$1DQ!1U,]+V4O<W0Z,'@Q,# P#0HC(" @("!)
XM9B!Y;W4@=7-E(&QZ97AE(&%S(')E8V]M;65N9&5D+"!R96UO=F4@+V4@9G)O
XM;2!,1$9,04=3#0I!4SUM87-M#0HC(" @("!&;W(@35-#(#8N,"P@=7-E.B!!
XM4SUM;" -"D%31DQ!1U,]+6UL("UT#0HC($%D9" M1$193E]!3$Q/0R!T;R!!
XM4T9,04=3(&EF('EO=2!H879E(&1E9FEN960@:70@:6X@=&%I;&]R+F@@;W(@
XM0T9,04=3#0H-"B,@+2TM+2TM+2TM+2TM+2!#;VUM;VX@9&5C;&%R871I;VYS
XM.@T*4U1225 ]<F5M#0HC(" @($EF('EO=2!D;VXG="!H879E(&QZ97AE+"!G
XM970@:70N(%1H96X@9&5F:6YE.@T*(U-44DE0/6QZ97AE#0HC(" @($]R(&EF
XM('EO=2=V92!R96=I<W1E<F5D(%!+3$E412P@=&AE;B!D969I;F4Z#0HC4U12
XM25 ]<&ML:71E#0HC(" @(%1H:7,@;6%K97,@82!B:6<@9&EF9F5R96YC92!I
XM;B N97AE('-I>F4@*&%N9"!P;W-S:6)L>2!L;V%D('1I;64I#0H-"B,@+2TM
XM+2TM+2TM+2TM+2!5<V5D(&)Y(&EN<W1A;&P@<G5L90T*(R!S970@0DE.('1O
XM('1H92!D:7)E8W1O<GD@>6]U('=A;G0@=&\@:6YS=&%L;"!T:&4@97AE8W5T
XM86)L97,@=&\-"D))3B ](&,Z7'5T:6P-"@T*(R!V87)I86)L97,-"D]"2EH@
XM/2!Z:7 N;V)J('II<&9I;&4N;V)J('II<'5P+F]B:B!F:6QE:6\N;V)J('5T
XM:6PN;V)J(&=L;V)A;',N;V)J("0H0U)94%1/*0T*#0I/0DI)(#T@9&5F;&%T
XM92YO8FH@=')E97,N;V)J(&)I=',N;V)J(&UA=&-H+F]B:@T*(R!R96UO=F4@
XM;6%T8V@N;V)J(&EF('EO=2!D;R!N;W0@:&%V92!M87-M#0H-"D]"2E4@/2!Z
XM:7!F:6QE7RYO8FH@>FEP=7!?+F]B:B!F:6QE:6]?+F]B:B!U=&EL7RYO8FH@
XM9VQO8F%L<RYO8FH-"D]"2DX@/2!Z:7!N;W1E+F]B:B @)"A/0DI5*0T*3T)*
XM0R ]('II<&-L;V%K+F]B:B D*$]"2E4I(&-R>7!T7RYO8FH-"D]"2E,@/2!Z
XM:7!S<&QI="YO8FH@)"A/0DI5*0T*#0I:25!3(#T@>FEP+F5X92!Z:7!N;W1E
XM+F5X92!Z:7!S<&QI="YE>&4@)"A#3$]!2RD-"@T*>FEP<SH))"A:25!3*0T*
XM#0IZ:7 N;V)J.@EZ:7 N:"!Z:7!E<G(N:"!T86EL;W(N:"!R979I<VEO;BYH
XM('II<"YC#0H))"A#0RD@+6,@)"A#1DQ!1U,I("0J+F,-"@T*(R!-4T,@-2XQ
XM(&=E;F5R871E<R!B860@8V]D92!O;B!Z:7!F:6QE('=I=&@@+4]X#0IZ:7!F
XM:6QE+F]B:CH)>FEP+F@@>FEP97)R+F@@=&%I;&]R+F@@>FEP9FEL92YC#0H)
XM)"A#0RD@+6,@)"A34$5#1DQ!1U,I("0J+F,-"@T*>FEP=7 N;V)J.@EZ:7 N
XM:"!Z:7!E<G(N:"!T86EL;W(N:"!R979I<VEO;BYH('II<'5P+F,-"@DD*$-#
XM*2 M8R D*$-&3$%'4RD@)"HN8PT*#0IF:6QE:6\N;V)J.@EZ:7 N:"!Z:7!E
XM<G(N:"!T86EL;W(N:"!F:6QE:6\N8PT*"20H0T,I("UC("0H0T9,04=3*2 D
XM*BYC#0H-"G5T:6PN;V)J.@EZ:7 N:"!Z:7!E<G(N:"!T86EL;W(N:"!U=&EL
XM+F,-"@DD*$-#*2 M8R D*$-&3$%'4RD@)"HN8PT*#0IG;&]B86QS+F]B:CH)
XM>FEP+F@@>FEP97)R+F@@=&%I;&]R+F@@9VQO8F%L<RYC#0H))"A#0RD@+6,@
XM)"A#1DQ!1U,I("0J+F,-"@T*9&5F;&%T92YO8FHZ"7II<"YH('II<&5R<BYH
XM('1A:6QO<BYH(&1E9FQA=&4N8PT*"20H0T,I("UC("0H0T9,04=3*2 D*BYC
XM#0H-"G1R965S+F]B:CH)>FEP+F@@>FEP97)R+F@@=&%I;&]R+F@@=')E97,N
XM8PT*"20H0T,I("UC("0H0T9,04=3*2 D*BYC#0H-"F)I=',N;V)J.@EZ:7 N
XM:"!Z:7!E<G(N:"!T86EL;W(N:"!B:71S+F,-"@DD*$-#*2 M8R D*$-&3$%'
XM4RD@)"HN8PT*#0IC<GEP="YO8FHZ"7II<"YH('II<&5R<BYH('1A:6QO<BYH
XM(&-R>7!T+F,-"@DD*$-#*2 M8R D*$-&3$%'4RD@)"HN8PT*#0IZ:7!C;&]A
XM:RYO8FHZ"7II<"YH('II<&5R<BYH('1A:6QO<BYH(')E=FES:6]N+F@@>FEP
XM8VQO86LN8PT*"20H0T,I("UC("0H0T9,04=3*2 D*BYC#0H-"GII<&YO=&4N
XM;V)J.@EZ:7 N:"!Z:7!E<G(N:"!T86EL;W(N:"!R979I<VEO;BYH('II<&YO
XM=&4N8PT*"20H0T,I("UC("0H0T9,04=3*2 D*BYC#0H-"B,@35-#(#4N,2!D
XM:65S(&]N('II<'-P;&ET('=I=&@@+4]X#0IZ:7!S<&QI="YO8FHZ"7II<'-P
XM;&ET+F,@>FEP+F@@>FEP97)R+F@@=&%I;&]R+F@@<F5V:7-I;VXN: T*"20H
XM0T,I("UC("0H4U!%0T9,04=3*2 D*BYC#0H-"B,@35-#(#4N,2!G96YE<F%T
XM97,@8F%D(&-O9&4@;VX@>FEP9FEL92!W:71H("U/> T*>FEP9FEL95\N;V)J
XM.@EZ:7!F:6QE+F,@>FEP+F@@>FEP97)R+F@@=&%I;&]R+F@-"@DD*$-#*2 M
XM8R D*%-014-&3$%'4RD@+4155$E,("U&;R1 ('II<&9I;&4N8PT*#0IZ:7!U
XM<%\N;V)J.@EZ:7!U<"YC('II<"YH('II<&5R<BYH('1A:6QO<BYH#0H))"A#
XM0RD@+6,@)"A55$E,1DQ!1U,I)$ @>FEP=7 N8PT*#0IF:6QE:6]?+F]B:CH)
XM9FEL96EO+F,@>FEP+F@@>FEP97)R+F@@=&%I;&]R+F@-"@DD*$-#*2 M8R D
XM*%5424Q&3$%'4RDD0"!F:6QE:6\N8PT*#0IU=&EL7RYO8FHZ"75T:6PN8R!Z
XM:7 N:"!Z:7!E<G(N:"!T86EL;W(N: T*"20H0T,I("UC("0H551)3$9,04=3
XM*21 ('5T:6PN8PT*#0IC<GEP=%\N;V)J.@EC<GEP="YC('II<"YH#0H))"A#
XM0RD@+6,@)"A55$E,1DQ!1U,I)$ @8W)Y<'0N8PT*#0IM871C:"YO8FHZ"6UA
XM=&-H+F%S;0T*"20H05,I("0H05-&3$%'4RD@;6%T8V@[#0H-"B,@=V4@;75S
XM="!C=70@=&AE(&-O;6UA;F0@;&EN92!T;R!F:70@:6X@=&AE($U3+T1/4R Q
XM,C@@8GET92!L:6UI=#H-"GII<"YE>&4Z("0H3T)*6BD@)"A/0DI)*0T*"65C
XM:&\@)"A/0DI:*2L@/B!Z:7 N<G-P#0H)96-H;R D*$]"2DDI.R ^/B!Z:7 N
XM<G-P#0H))"A,1"D@)"A,1$9,04=3*2! >FEP+G)S< T*"61E;"!Z:7 N<G-P
XM#0H))"A35%))4"D@>FEP+F5X90T*#0IZ:7!C;&]A:RYE>&4Z("0H3T)*0RD-
XM"@EE8VAO("0H3T)*0RD[(#X@>FEP8RYR<W -"@DD*$Q$*2 D*$Q$1DQ!1U,I
XM($!Z:7!C+G)S< T*"61E;"!Z:7!C+G)S< T*"20H4U1225 I('II<&-L;V%K
XM+F5X90T*#0IZ:7!N;W1E+F5X93H@)"A/0DI.*0T*"65C:&\@)"A/0DI.*3L@
XM/B!Z:7!N+G)S< T*"20H3$0I("0H3$1&3$%'4RD@0'II<&XN<G-P#0H)9&5L
XM('II<&XN<G-P#0H))"A35%))4"D@>FEP;F]T92YE>&4-"@T*>FEP<W!L:70N
XM97AE.B D*$]"2E,I#0H)96-H;R D*$]"2E,I.R ^('II<',N<G-P#0H))"A,
XM1"D@)"A,1$9,04=3*2! >FEP<RYR<W -"@ED96P@>FEP<RYR<W -"@DD*%-4
XM4DE0*2!Z:7!S<&QI="YE>&4-"@T*:6YS=&%L;#H))"A:25!3*0T*"6-O<'D@
XM+V(@*BYE>&4@)"A"24XI#0H-"F-L96%N.@T*"61E;" J+F]B:@T*"61E;" J
X&+F5X90T*
X 
Xend
END_OF_FILE
  if test 5501 -ne `wc -c <'msdos/makefile.msc.UU'`; then
    echo shar: \"'msdos/makefile.msc.UU'\" unpacked with wrong size!
  else
    echo shar: Uudecoding \"'msdos/makefile.msc'\" \(3966 characters\)
    cat msdos/makefile.msc.UU | uudecode
    if test 3966 -ne `wc -c <'msdos/makefile.msc'`; then
      echo shar: \"'msdos/makefile.msc'\" uudecoded with wrong size!
    else
      rm msdos/makefile.msc.UU
    fi
  fi
  # end of 'msdos/makefile.msc.UU'
fi
if test -f 'msdos/match.asm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'msdos/match.asm'\"
else
  echo shar: Extracting \"'msdos/match.asm'\" \(7753 characters\)
  sed "s/^X//" >'msdos/match.asm' <<'END_OF_FILE'
X;
X; Copyright (C) 1990-1992 Mark Adler, Richard B. Wales, and Jean-loup Gailly.
X; Permission is granted to any individual or institution to use, copy, or
X; redistribute this software so long as all of the original files are included
X; unmodified, that it is not sold for profit, and that this copyright notice
X; is retained.
X;
X; match.asm by Jean-loup Gailly.
X
X; match.asm, optimized version of longest_match() in deflate.c
X; Must be assembled with masm -ml. To be used only with C compact model.
X; (For large model, follow the instructions given below.)
X; This file is only optional. If you don't have masm or tasm, use the
X; C version (add -DNO_ASM to CFLAGS in makefile.msc and remove match.obj
X; from OBJI). If you have reduced WSIZE in zip.h, then change its value
X; below.
X;
X; Turbo C 2.0 does not support static allocation of more than 64K bytes per
X; file, and does not have SS == DS. So TC and BC++ users must use:
X;   tasm -ml -DDYN_ALLOC -DSS_NEQ_DS match;
X;
X; To simplify the code, the option -DDYN_ALLOC is supported for OS/2
X; only if the arrays are guaranteed to have zero offset (allocated by
X; halloc). We also require SS==DS. This is satisfied for MSC but not Turbo C.
X
X        name    match
X
Xifndef DYN_ALLOC
X        extrn   _prev         : word
X        extrn   _window       : byte
X        prev    equ  _prev    ; offset part
X        window  equ  _window
Xendif
X
X_DATA    segment  word public 'DATA'
X        extrn   _match_start  : word
X        extrn   _prev_length  : word
X        extrn   _good_match   : word
X        extrn   _strstart     : word
X        extrn   _max_chain_length : word
Xifdef DYN_ALLOC
X        extrn   _prev         : word
X        extrn   _window       : word
X        prev    equ 0         ; offset forced to zero
X        window  equ 0
X        window_seg equ _window[2]
X	window_off equ 0
Xelse
X	wseg    dw seg _window
X        window_seg equ wseg
X	window_off equ offset _window
Xendif
X_DATA    ends
X
XDGROUP  group _DATA
X
X_TEXT   segment word public 'CODE'
X        assume  cs: _TEXT, ds: DGROUP
X
X	public _match_init
X        public _longest_match
X
X	MIN_MATCH     equ 3
X        MAX_MATCH     equ 258
X	WSIZE         equ 32768		; keep in sync with zip.h !
X	MIN_LOOKAHEAD equ (MAX_MATCH+MIN_MATCH+1)
X	MAX_DIST      equ (WSIZE-MIN_LOOKAHEAD)
X
Xprev_ptr    dw  seg _prev		; pointer to the prev array
Xifdef SS_NEQ_DS
X    match_start dw  0			; copy of _match_start if SS != DS
Xendif
X
X; initialize or check the variables used in match.asm.
X
X_match_init proc near			; 'proc far' for large model
Xifdef SS_NEQ_DS
X        ma_start equ cs:match_start	; does not work on OS/2
Xelse
X	assume ss: DGROUP
X        ma_start equ ss:_match_start
X        mov     ax,ds
X        mov     bx,ss
X        cmp     ax,bx                   ; SS == DS?
X        jne     error
Xendif
Xifdef DYN_ALLOC
X	cmp	_prev[0],0		; verify zero offset
X	jne	error
X	cmp	_window[0],0
X	jne	error
X  ifdef SS_NEQ_DS
X	mov	ax,_prev[2]		; segment value
X	mov     cs:prev_ptr,ax		; ugly write to code, crash on OS/2
X        prev_seg  equ cs:prev_ptr
X  else
X        prev_seg  equ ss:_prev[2]	; works on OS/2 if SS == DS
X  endif
Xelse
X        prev_seg  equ cs:prev_ptr
Xendif
X	ret
X	extrn   _exit : near		; 'far' for large model
Xerror:  call    _exit
X
X_match_init endp
X
X; -----------------------------------------------------------------------
X; Set match_start to the longest match starting at the given string and
X; return its length. Matches shorter or equal to prev_length are discarded,
X; in which case the result is equal to prev_length and match_start is
X; garbage.
X; IN assertions: cur_match is the head of the hash chain for the current
X;   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
X
X; int longest_match(cur_match)
X
X_longest_match  proc near		 ; 'proc far' for large model
X        push    bp
X        mov     bp,sp
X        push    di
X	push	si
X	push	ds
X
X        cur_match    equ word ptr [bp+4] ; [bp+6] for large model
X
X;       window	     equ es:window (es:0 for DYN_ALLOC)
X;       prev	     equ ds:prev
X;       match        equ es:si
X;       scan         equ es:di
X;       chain_length equ bp
X;       best_len     equ bx
X;       limit        equ dx
X
X	mov	si,cur_match            ; use bp before it is destroyed
X        mov     bp,_max_chain_length    ; chain_length = max_chain_length
X	mov	di,_strstart
X	mov	dx,di
X	sub	dx,MAX_DIST             ; limit = strstart-MAX_DIST
X	jae	limit_ok
X	sub	dx,dx			; limit = NIL
Xlimit_ok:
X        add     di,2+window_off         ; di = offset(window + strstart + 2)
X        mov     bx,_prev_length         ; best_len = prev_length
X	mov     es,window_seg
X        mov     ax,es:[bx+di-3]         ; ax = scan[best_len-1..best_len]
X        mov     cx,es:[di-2]            ; cx = scan[0..1]
X	cmp	bx,_good_match		; do we have a good match already?
X        mov     ds,prev_seg    		; (does not destroy the flags)
X        assume  ds: nothing
X        jb      do_scan			; good match?
X	shr	bp,1			; chain_length >>= 2
X	shr	bp,1
X        jmp     short do_scan
X
X        even                            ; align destination of branch
Xlong_loop:
X; at this point, ds:di == scan+2, ds:si == cur_match
X        mov     ax,[bx+di-3]            ; ax = scan[best_len-1..best_len]
X        mov     cx,[di-2]               ; cx = scan[0..1]
X        mov     ds,prev_seg    		; reset ds to address the prev array
Xshort_loop:
X        dec     bp                      ; --chain_length
X        jz      the_end
X; at this point, di == scan+2, si = cur_match,
X; ax = scan[best_len-1..best_len] and cx = scan[0..1]
Xif (WSIZE-32768)
X        and     si,WSIZE-1              ; not needed if WSIZE=32768
Xendif
X        shl     si,1                    ; cur_match as word index
X        mov     si,prev[si]             ; cur_match = prev[cur_match]
X        cmp     si,dx			; cur_match <= limit ?
X        jbe     the_end
Xdo_scan:
X        cmp     ax,word ptr es:window[bx+si-1] ; check match at best_len-1
X        jne     short_loop
X        cmp     cx,word ptr es:window[si]      ; check min_match_length match
X        jne     short_loop
X
X        lea     si,window[si+2]         ; si = match
X        mov     ax,di                   ; ax = scan+2
X        mov     cx,es
X        mov     ds,cx			; ds = es = window
X        mov     cx,(MAX_MATCH-2)/2      ; scan for at most MAX_MATCH bytes
X        repe    cmpsw                   ; loop until mismatch
X        je      maxmatch                ; match of length MAX_MATCH?
Xmismatch:
X        mov     cl,[di-2]               ; mismatch on first or second byte?
X        sub     cl,[si-2]               ; cl = 0 if first bytes equal
X        xchg    ax,di                   ; di = scan+2, ax = end of scan
X        sub     ax,di                   ; ax = len
X	sub	si,ax			; si = cur_match + 2 + offset(window)
X	sub	si,2+window_off         ; si = cur_match
X        sub     cl,1                    ; set carry if cl == 0 (can't use DEC)
X        adc     ax,0                    ; ax = carry ? len+1 : len
X        cmp     ax,bx                   ; len > best_len ?
X        jle     long_loop
X        mov     ma_start,si             ; match_start = cur_match
X        mov     bx,ax                   ; bx = best_len = len
X        cmp     ax,MAX_MATCH            ; len >= MAX_MATCH ?
X        jl      long_loop
Xthe_end:
X	pop	ds
X        assume  ds: DGROUP
Xifdef SS_NEQ_DS
X	mov	ax,ma_start		; garbage if no match found
X	mov	ds:_match_start,ax
Xendif
X        pop     si
X        pop     di
X        pop     bp
X        mov     ax,bx                   ; result = ax = best_len
X        ret
Xmaxmatch:                               ; come here if maximum match
X        cmpsb                           ; increment si and di
X        jmp     mismatch                ; force match_length = MAX_LENGTH
X        
X_longest_match  endp
X
X_TEXT   ends
Xend
END_OF_FILE
  if test 7753 -ne `wc -c <'msdos/match.asm'`; then
    echo shar: \"'msdos/match.asm'\" unpacked with wrong size!
  fi
  # end of 'msdos/match.asm'
fi
if test -f 'os2/match32.asm.UU' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'os2/match32.asm.UU'\"
else
  echo shar: Extracting \"'os2/match32.asm.UU'\" \(8134 characters\)
  sed "s/^X//" >'os2/match32.asm.UU' <<'END_OF_FILE'
Xbegin 666 os2/match32.asm
XM.PT*.R!#;W!Y<FEG:'0@*$,I(#$Y.3 M,3DY,B!-87)K($%D;&5R+"!2:6-H
XM87)D($(N(%=A;&5S+"!*96%N+6QO=7 @1V%I;&QY+ T*.R!+86D@57=E(%)O
XM;6UE;"!A;F0@26=O<B!-86YD<FEC:&5N:V\N#0H[(%!E<FUI<W-I;VX@:7,@
XM9W)A;G1E9"!T;R!A;GD@:6YD:79I9'5A;"!O<B!I;G-T:71U=&EO;B!T;R!U
XM<V4L(&-O<'DL(&]R#0H[(')E9&ES=')I8G5T92!T:&ES('-O9G1W87)E('-O
XM(&QO;F<@87,@86QL(&]F('1H92!O<FEG:6YA;"!F:6QE<R!A<F4@:6YC;'5D
XM960-"CL@=6YM;V1I9FEE9"P@=&AA="!I="!I<R!N;W0@<V]L9"!F;W(@<')O
XM9FET+"!A;F0@=&AA="!T:&ES(&-O<'ER:6=H="!N;W1I8V4-"CL@:7,@<F5T
XM86EN960N#0H[#0H[(&UA=&-H,S(N87-M(&)Y($IE86XM;&]U<"!'86EL;'DN
XM#0H-"CL@;6%T8V@S,BYA<VTL(&]P=&EM:7IE9"!V97)S:6]N(&]F(&QO;F=E
XM<W1?;6%T8V@H*2!I;B!D969L871E+F,-"CL@5&\@8F4@=7-E9"!O;FQY('=I
XM=&@@,S(@8FET(&9L870@;6]D96PN(%1O('-I;7!L:69Y('1H92!C;V1E+"!T
XM:&4@;W!T:6]N#0H[("U$1%E.7T%,3$]#(&ES(&YO="!S=7!P;W)T960N#0H[
XM(%1H:7,@9FEL92!I<R!O;FQY(&]P=&EO;F%L+B!)9B!Y;W4@9&]N)W0@:&%V
XM92!A;B!A<W-E;6)L97(L('5S92!T:&4-"CL@0R!V97)S:6]N("AA9&0@+41.
XM3U]!4TT@=&\@0T9,04=3(&EN(&UA:V5F:6QE(&%N9"!R96UO=F4@;6%T8V@N
XM;PT*.R!F<F]M($]"2DDI+B!)9B!Y;W4@:&%V92!R961U8V5D(%=325I%(&EN
XM('II<"YH+"!T:&5N(&-H86YG92!I=',@=F%L=64-"CL@8F5L;W<N#0H[(" @
XM(" @(" @(" @(" @*BHJ(%=A<FYI;F<Z('1H:7,@9FEL92!I<R!S=&EL;"!U
XM;G1E<W1E9" J*BH-"B @(" @(" @+C,X-@T*#0H@(" @(" @(&YA;64@(" @
XM;6%T8V@-"@T*7T)34R @("!S96=M96YT("!D=V]R9"!54T4S,B!P=6)L:6,@
XM)T)34R<-"B @(" @(" @97AT<FX@("!?;6%T8VA?<W1A<G0@(#H@9'=O<F0-
XM"B @(" @(" @97AT<FX@("!?<')E=E]L96YG=&@@(#H@9'=O<F0-"B @(" @
XM(" @97AT<FX@("!?9V]O9%]M871C:" @(#H@9'=O<F0-"B @(" @(" @97AT
XM<FX@("!?<W1R<W1A<G0@(" @(#H@9'=O<F0-"B @(" @(" @97AT<FX@("!?
XM;6%X7V-H86EN7VQE;F=T:" Z(&1W;W)D#0H@(" @(" @(&5X=')N(" @7W!R
XM978@(" @(" @(" Z('=O<F0-"B @(" @(" @97AT<FX@("!?=VEN9&]W(" @
XM(" @(#H@8GET90T*7T)34R @("!E;F1S#0H-"D1'4D]54" @9W)O=7 @7T)3
XM4PT*#0I?5$585" @('-E9VUE;G0@9'=O<F0@55-%,S(@<'5B;&EC("=#3T1%
XM)PT*(" @(" @("!A<W-U;64@(&-S.B!?5$585"P@9',Z($1'4D]54"P@<W,Z
XM($1'4D]54 T*#0H)<'5B;&EC(&UA=&-H7VEN:71?#0H@(" @(" @('!U8FQI
XM8R!L;VYG97-T7VUA=&-H7PT*#0H)34E.7TU!5$-((" @("!E<74@,PT*(" @
XM(" @("!-05A?34%40T@@(" @(&5Q=2 R-3@-"@E74TE:12 @(" @(" @(&5Q
XM=2 S,C<V. D).R!K965P(&EN('-Y;F,@=VET:"!Z:7 N:" A#0H)34E.7TQ/
XM3TM!2$5!1"!E<74@*$U!6%]-051#2"M-24Y?34%40T@K,2D-"@E-05A?1$E3
XM5" @(" @(&5Q=2 H5U-)6D4M34E.7TQ/3TM!2$5!1"D-"@T*.R!I;FET:6%L
XM:7IE(&]R(&-H96-K('1H92!V87)I86)L97,@=7-E9"!I;B!M871C:"YA<VTN
XM#0H-"FUA=&-H7VEN:71?('!R;V,@;F5A<@T*"7)E= T*;6%T8VA?:6YI=%\@
XM96YD< T*#0H[("TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM
XM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM+2TM#0H[(%-E="!M
XM871C:%]S=&%R="!T;R!T:&4@;&]N9V5S="!M871C:"!S=&%R=&EN9R!A="!T
XM:&4@9VEV96X@<W1R:6YG(&%N9 T*.R!R971U<FX@:71S(&QE;F=T:"X@36%T
XM8VAE<R!S:&]R=&5R(&]R(&5Q=6%L('1O('!R979?;&5N9W1H(&%R92!D:7-C
XM87)D960L#0H[(&EN('=H:6-H(&-A<V4@=&AE(')E<W5L="!I<R!E<75A;"!T
XM;R!P<F5V7VQE;F=T:"!A;F0@;6%T8VA?<W1A<G0@:7,-"CL@9V%R8F%G92X-
XM"CL@24X@87-S97)T:6]N<SH@8W5R7VUA=&-H(&ES('1H92!H96%D(&]F('1H
XM92!H87-H(&-H86EN(&9O<B!T:&4@8W5R<F5N= T*.R @('-T<FEN9R H<W1R
XM<W1A<G0I(&%N9"!I=',@9&ES=&%N8V4@:7,@/#T@34%87T1)4U0L(&%N9"!P
XM<F5V7VQE;F=T:" ^/2 Q#0H-"CL@:6YT(&QO;F=E<W1?;6%T8V@H8W5R7VUA
XM=&-H*0T*#0IL;VYG97-T7VUA=&-H7R!P<F]C(&YE87(-"@T*(" @(" @("!C
XM=7)?;6%T8V@@(" @97%U(&1W;W)D('!T<B!;97-P*S(P70T*(" @(" @(" [
XM(')E='5R;B!A9&1R97-S(" @(" @(" @(" @(" @(#L@97-P*S$V#0H@(" @
XM(" @('!U<V@@(" @96)P(" @(" @(" @(" @(" @(" @(" @.R!E<W K,3(-
XM"B @(" @(" @<'5S:" @("!E9&D@(" @(" @(" @(" @(" @(" @(" [(&5S
XM<"LX#0H)<'5S: EE<VD@(" @(" @(" @(" @(" @(" @(" [(&5S<"LT#0H)
XM<'5S: EE8G@@(" @(" @(" @(" @(" @(" @(" [(&5S< T*#0H[(" @(" @
XM(&UA=&-H(" @(" @("!E<74@97-I#0H[(" @(" @('-C86X@(" @(" @("!E
XM<74@961I#0H[(" @(" @(&-H86EN7VQE;F=T:"!E<74@96)P#0H[(" @(" @
XM(&)E<W1?;&5N(" @("!E<74@96)X#0H[(" @(" @(&QI;6ET(" @(" @("!E
XM<74@961X#0H-"@EM;W8)97-I+&-U<E]M871C: T*(" @(" @("!M;W8@(" @
XM(&5B<"Q?;6%X7V-H86EN7VQE;F=T:" @(#L@8VAA:6Y?;&5N9W1H(#T@;6%X
XM7V-H86EN7VQE;F=T: T*"6UO=@EE9&DL7W-T<G-T87)T#0H);6]V"65D>"QE
XM9&D-"@ES=6()961X+$U!6%]$25-4(" @(" @(" @(" @.R!L:6UI=" ]('-T
XM<G-T87)T+4U!6%]$25-4#0H):F%E"7-H;W)T(&QI;6ET7V]K#0H)<W5B"65D
XM>"QE9'@)"0D[(&QI;6ET(#T@3DE,#0IL:6UI=%]O:SH-"B @(" @(" @861D
XM(" @("!E9&DL,BMO9F9S970@7W=I;F1O=R @(" [(&5D:2 ](&]F9G-E="AW
XM:6YD;W<@*R!S=')S=&%R=" K(#(I#0H@(" @(" @(&UO=B @(" @96)X+%]P
XM<F5V7VQE;F=T:" @(" @(" @.R!B97-T7VQE;B ]('!R979?;&5N9W1H#0H@
XM(" @(" @(&UO=B @(" @87@L6V5B>"ME9&DM,UT@(" @(" @(" @.R!A>" ]
XM('-C86Y;8F5S=%]L96XM,2XN8F5S=%]L96Y=#0H@(" @(" @(&UO=B @(" @
XM8W@L6V5D:2TR72 @(" @(" @(" @(" @.R!C>" ]('-C86Y;,"XN,5T-"@EC
XM;7 )96)X+%]G;V]D7VUA=&-H( D[(&1O('=E(&AA=F4@82!G;V]D(&UA=&-H
XM(&%L<F5A9'D_#0H@(" @(" @(&IB(" @(" @9&]?<V-A;@T*"7-H<@EE8G L
XM,@D)"3L@8VAA:6Y?;&5N9W1H(#X^/2 R#0H@(" @(" @(&IM<" @(" @<VAO
XM<G0@9&]?<V-A;@T*#0H@(" @(" @(&%L:6=N(" @-" @(" @(" @(" @(" @
XM(" @(" @(" @.R!A;&EG;B!D97-T:6YA=&EO;B!O9B!B<F%N8V@-"FQO;F=?
XM;&]O<#H-"CL@870@=&AI<R!P;VEN="P@961I(#T]('-C86XK,BP@97-I(#T]
XM(&-U<E]M871C: T*(" @(" @("!M;W8@(" @(&%X+%ME8G@K961I+3-=(" @
XM(" @(" @(#L@87@@/2!S8V%N6V)E<W1?;&5N+3$N+F)E<W1?;&5N70T*(" @
XM(" @("!M;W8@(" @(&-X+%ME9&DM,ET@(" @(" @(" @(" @(#L@8W@@/2!S
XM8V%N6S N+C%=#0IS:&]R=%]L;V]P.@T*(" @(" @("!D96,@(" @(&5B<" @
XM(" @(" @(" @(" @(" @(" @(#L@+2UC:&%I;E]L96YG=&@-"B @(" @(" @
XM:GH@(" @("!T:&5?96YD#0H[(&%T('1H:7,@<&]I;G0L(&5D:2 ]/2!S8V%N
XM*S(L(&5S:2 ]/2!C=7)?;6%T8V@L#0H[(&%X(#T@<V-A;EMB97-T7VQE;BTQ
XM+BYB97-T7VQE;ET@86YD(&-X(#T@<V-A;ELP+BXQ70T*(" @(" @("!A;F0@
XM(" @(&5S:2Q74TE:12TQ#0H@(" @(" @(&UO=B @(" @<VDL7W!R979;97-I
XM*V5S:5T@(" @(" @.R!C=7)?;6%T8V@@/2!P<F5V6V-U<E]M871C:%T-"B @
XM(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(" [('1O<"!W
XM;W)D(&]F(&5S:2!I<R!S=&EL;" P#0H@(" @(" @(&-M<" @(" @97-I+&5D
XM> D)"3L@8W5R7VUA=&-H(#P](&QI;6ET(#\-"B @(" @(" @:F)E(" @("!S
XM:&]R="!T:&5?96YD#0ID;U]S8V%N.@T*(" @(" @("!C;7 @(" @(&%X+'=O
XM<F0@<'1R(%]W:6YD;W=;96)X*V5S:2TQ72 @(#L@8VAE8VL@;6%T8V@@870@
XM8F5S=%]L96XM,0T*(" @(" @("!J;F4@(" @('-H;W)T7VQO;W -"B @(" @
XM(" @8VUP(" @("!C>"QW;W)D('!T<B!?=VEN9&]W6V5S:5T@(" @(" @(" [
XM(&-H96-K(&UI;E]M871C:%]L96YG=&@@;6%T8V@-"B @(" @(" @:FYE(" @
XM("!S:&]R=%]L;V]P#0H-"B @(" @(" @;&5A(" @("!E<VDL7W=I;F1O=UME
XM<VDK,ET@(" @(" [('-I(#T@;6%T8V@-"B @(" @(" @;6]V(" @("!E87@L
XM961I(" @(" @(" @(" @(" @(" [(&%X(#T@<V-A;BLR#0H@(" @(" @(&UO
XM=B @(" @96-X+"A-05A?34%40T@M,BDO,B @(" @.R!S8V%N(&9O<B!A="!M
XM;W-T($U!6%]-051#2"!B>71E<PT*(" @(" @("!R97!E(" @(&-M<'-W(" @
XM(" @(" @(" @(" @(" @(#L@;&]O<"!U;G1I;"!M:7-M871C: T*(" @(" @
XM("!J92 @(" @(&UA>&UA=&-H(" @(" @(" @(" @(" @(#L@;6%T8V@@;V8@
XM;&5N9W1H($U!6%]-051#2#\-"FUI<VUA=&-H.@T*(" @(" @("!M;W8@(" @
XM(&-L+%ME9&DM,ET@(" @(" @(" @(" @(#L@;6ES;6%T8V@@;VX@9FER<W0@
XM;W(@<V5C;VYD(&)Y=&4_#0H@(" @(" @('-U8B @(" @8VPL6V5S:2TR72 @
XM(" @(" @(" @(" @.R!C;" ](# @:68@9FER<W0@8GET97,@97%U86P-"B @
XM(" @(" @>&-H9R @("!E87@L961I(" @(" @(" @(" @(" @(" [(&5D:2 ]
XM('-C86XK,BP@96%X(#T@96YD(&]F('-C86X-"B @(" @(" @<W5B(" @("!E
XM87@L961I(" @(" @(" @(" @(" @(" [(&5A>" ](&QE;@T*"7-U8@EE<VDL
XM96%X(" @(" @(" )"3L@97-I(#T@8W5R7VUA=&-H("L@,B K(&]F9G-E="AW
XM:6YD;W<I#0H)<W5B"65S:2PR*V]F9G-E="!?=VEN9&]W(" @(#L@97-I(#T@
XM8W5R7VUA=&-H#0H@(" @(" @('-U8B @(" @8VPL,2 @(" @(" @(" @(" @
XM(" @(" @.R!S970@8V%R<GD@:68@8VP@/3T@," H8V%N)W0@=7-E($1%0RD-
XM"B @(" @(" @861C(" @("!E87@L," @(" @(" @(" @(" @(" @(" [(&5A
XM>" ](&-A<G)Y(#\@;&5N*S$@.B!L96X-"B @(" @(" @8VUP(" @("!E87@L
XM96)X(" @(" @(" @(" @(" @(" [(&QE;B ^(&)E<W1?;&5N(#\-"B @(" @
XM(" @:FQE(" @("!L;VYG7VQO;W -"B @(" @(" @;6]V(" @("!?;6%T8VA?
XM<W1A<G0L97-I(" @(" @(" [(&UA=&-H7W-T87)T(#T@8W5R7VUA=&-H#0H@
XM(" @(" @(&UO=B @(" @96)X+&5A>" @(" @(" @(" @(" @(" @.R!E8G@@
XM/2!B97-T7VQE;B ](&QE;@T*(" @(" @("!C;7 @(" @(&5A>"Q-05A?34%4
XM0T@@(" @(" @(" @(#L@;&5N(#X]($U!6%]-051#2" _#0H@(" @(" @(&IL
XM(" @(" @;&]N9U]L;V]P#0IT:&5?96YD.@T*(" @(" @("!M;W8@(" @(&5A
XM>"QE8G@@(" @(" @(" @(" @(" @(#L@<F5S=6QT(#T@96%X(#T@8F5S=%]L
XM96X-"@EP;W )96)X#0H@(" @(" @('!O<" @(" @97-I#0H@(" @(" @('!O
XM<" @(" @961I#0H@(" @(" @('!O<" @(" @96)P#0H@(" @(" @(')E= T*
XM;6%X;6%T8V@Z(" @(" @(" @(" @(" @(" @(" @(" @(" @(" @(#L@8V]M
XM92!H97)E(&EF(&UA>&EM=6T@;6%T8V@-"B @(" @(" @8VUP<V(@(" @(" @
XM(" @(" @(" @(" @(" @(" @(" [(&EN8W)E;65N="!E<VD@86YD(&5D:0T*
XM(" @(" @("!J;7 @(" @(&UI<VUA=&-H(" @(" @(" @(" @(" @(#L@9F]R
XM8V4@;6%T8VA?;&5N9W1H(#T@34%87TQ%3D=42 T*#0IL;VYG97-T7VUA=&-H
X=7R!E;F1P#0H-"E]415A4(" @96YD<PT*96YD#0H*
X 
Xend
END_OF_FILE
 if test 8134 -ne `wc -c <'os2/match32.asm.UU'`; then
    echo shar: \"'os2/match32.asm.UU'\" unpacked with wrong size!
  else
    echo shar: Uudecoding \"'os2/match32.asm'\" \(5879 characters\)
    cat os2/match32.asm.UU | uudecode
    if test 5879 -ne `wc -c <'os2/match32.asm'`; then
      echo shar: \"'os2/match32.asm'\" uudecoded with wrong size!
    else
      rm os2/match32.asm.UU
    fi
  fi
  # end of 'os2/match32.asm.UU'
fi
if test -f 'vms/VMSmunch.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/VMSmunch.h'\"
else
  echo shar: Extracting \"'vms/VMSmunch.h'\" \(5511 characters\)
  sed "s/^X//" >'vms/VMSmunch.h' <<'END_OF_FILE'
X/*---------------------------------------------------------------------------
X
X  VMSmunch.h
X
X  A few handy #defines, plus the contents of three header files from Joe
X  Meadows' FILE program.  Used by VMSmunch and by various routines which
X  call VMSmunch (e.g., in Zip and UnZip).
X
X  ---------------------------------------------------------------------------*/
X
X#define GET_TIMES       4
X#define SET_TIMES       0
X#define GET_RTYPE       1
X#define CHANGE_RTYPE    2
X#define RESTORE_RTYPE   3
X
X/*---------------------------------------------------------------------------
X    fatdef.h
X  ---------------------------------------------------------------------------*/
X
X/* This header file was created by Joe Meadows, and is not copyrighted
X   in any way. No guarantee is made as to the accuracy of the contents
X   of this header file. This header file was last modified on Sep. 22th,
X   1987. (Modified to include this statement) */
X#define FAT$K_LENGTH 32
X#define FAT$C_LENGTH 32
X#define FAT$S_FATDEF 32
X
Xstruct fatdef {
X  union  {
X    unsigned char fat$b_rtype;
X    struct  {
X      unsigned fat$v_rtype : 4;
X      unsigned fat$v_fileorg : 4;
X    } fat$r_rtype_bits;
X  } fat$r_rtype_overlay;
X# define FAT$S_RTYPE 4
X# define FAT$V_RTYPE 0
X#   define FAT$C_UNDEFINED 0
X#   define FAT$C_FIXED 1
X#   define FAT$C_VARIABLE 2
X#   define FAT$C_VFC 3
X#   define FAT$C_STREAM 4
X#   define FAT$C_STREAMLF 5
X#   define FAT$C_STREAMCR 6
X# define FAT$S_FILEORG 4
X# define FAT$V_FILEORG 4
X#   define FAT$C_SEQUENTIAL 0
X#   define FAT$C_RELATIVE 1
X#   define FAT$C_INDEXED 2
X#   define FAT$C_DIRECT 3
X  union  {
X    unsigned char fat$b_rattrib;
X    struct  {
X      unsigned fat$v_fortrancc : 1;
X      unsigned fat$v_impliedcc : 1;
X      unsigned fat$v_printcc : 1;
X      unsigned fat$v_nospan : 1;
X    } fat$r_rattrib_bits;
X  } fat$r_rattrib_overlay;
X#   define FAT$V_FORTRANCC 0
X#   define FAT$M_FORTRANCC 1
X#   define FAT$V_IMPLIEDCC 1
X#   define FAT$M_IMPLIEDCC 2
X#   define FAT$V_PRINTCC 2
X#   define FAT$M_PRINTCC 4
X#   define FAT$V_NOSPAN 3
X#   define FAT$M_NOSPAN 8
X  unsigned short int fat$w_rsize;
X  union
X  {
X    unsigned long int fat$l_hiblk;
X    struct
X    {
X      unsigned short int fat$w_hiblkh;
X      unsigned short int fat$w_hiblkl;
X    } fat$r_hiblk_fields;
X  } fat$r_hiblk_overlay;
X  union
X  {
X    unsigned long int fat$l_efblk;
X    struct
X    {
X      unsigned short int fat$w_efblkh;
X      unsigned short int fat$w_efblkl;
X    } fat$r_efblk_fields;
X  } fat$r_efblk_overlay;
X  unsigned short int fat$w_ffbyte;
X  unsigned char fat$b_bktsize;
X  unsigned char fat$b_vfcsize;
X  unsigned short int fat$w_maxrec;
X  unsigned short int fat$w_defext;
X  unsigned short int fat$w_gbc;
X  char fat$fill[8];
X  unsigned short int fat$w_versions;
X};
X
X/*---------------------------------------------------------------------------
X    fchdef.h
X  ---------------------------------------------------------------------------*/
X
X/* This header file was created by Joe Meadows, and is not copyrighted
X   in any way. No guarantee is made as to the accuracy of the contents
X   of this header file. This header file was last modified on Sep. 22th,
X   1987. (Modified to include this statement) */
X
X#define FCH$V_BADACL 0x00B
X#define FCH$M_BADACL (1 << FCH$V_ACL)
X#define FCH$V_BADBLOCK 0x00E
X#define FCH$M_BADBLOCK (1 << FCH$V_BADBLOCK)
X#define FCH$V_CONTIG 0x007
X#define FCH$M_CONTIG (1 << FCH$V_CONTIG)
X#define FCH$V_CONTIGB 0x005
X#define FCH$M_CONTIGB (1 << FCH$V_CONTIGB)
X#define FCH$V_DIRECTORY 0x00D
X#define FCH$M_DIRECTORY (1 << FCH$V_DIRECTORY)
X#define FCH$V_ERASE 0x011
X#define FCH$M_ERASE (1 << FCH$V_ERASE)
X#define FCH$V_LOCKED 0x006
X#define FCH$M_LOCKED (1 << FCH$V_LOCKED)
X#define FCH$V_MARKDEL 0x00F
X#define FCH$M_MARKDEL (1 << FCH$V_MARKDEL)
X#define FCH$V_NOBACKUP 0x001
X#define FCH$M_NOBACKUP (1 << FCH$V_NOBACKUP)
X#define FCH$V_NOCHARGE 0x010
X#define FCH$M_NOCHARGE (1 << FCH$V_NOCHARGE)
X#define FCH$V_READCHECK 0x003
X#define FCH$M_READCHECK (1 << FCH$V_READCHECK)
X#define FCH$V_SPOOL 0x00C
X#define FCH$M_SPOOL (1 << FCH$V_SPOOL)
X#define FCH$V_WRITCHECK 0x004
X#define FCH$M_WRITCHECK (1 << FCH$V_WRITCHECK)
X#define FCH$V_WRITEBACK 0x002
X#define FCH$M_WRITEBACK (1 << FCH$V_WRITEBACK)
X
Xstruct fchdef  {
X  unsigned : 1;
X  unsigned fch$v_nobackup : 1 ;
X  unsigned fch$v_writeback : 1;
X  unsigned fch$v_readcheck : 1;
X  unsigned fch$v_writcheck : 1;
X  unsigned fch$v_contigb : 1;
X  unsigned fch$v_locked : 1;
X  unsigned fch$v_contig : 1;
X  unsigned : 3;
X  unsigned fch$v_badacl : 1;
X  unsigned fch$v_spool : 1;
X  unsigned fch$v_directory : 1;
X  unsigned fch$v_badblock : 1;
X  unsigned fch$v_markdel : 1;
X  unsigned fch$v_nocharge : 1;
X  unsigned fch$v_erase : 1;
X};
X
X/*---------------------------------------------------------------------------
X    fjndef.h
X  ---------------------------------------------------------------------------*/
X
X/* This header file was created by Joe Meadows, and is not copyrighted
X   in any way. No guarantee is made as to the accuracy of the contents
X   of this header file. This header file was last modified on Sep. 22th,
X   1987. (Modified to include this statement) */
X
X#define FJN$M_ONLY_RU 1
X#define FJN$M_RUJNL 2
X#define FJN$M_BIJNL 4
X#define FJN$M_AIJNL 8
X#define FJN$M_ATJNL 16
X#define FJN$M_NEVER_RU 32
X#define FJN$M_JOURNAL_FILE 64
X#define FJN$S_FJNDEF 1
Xstruct fjndef  {
X  unsigned fjn$v_only_ru : 1;
X  unsigned fjn$v_rujnl : 1;
X  unsigned fjn$v_bijnl : 1;
X  unsigned fjn$v_aijnl : 1;
X  unsigned fjn$v_atjnl : 1;
X  unsigned fjn$v_never_ru : 1;
X  unsigned fjn$v_journal_file:1;
X} ;
END_OF_FILE
  if test 5511 -ne `wc -c <'vms/VMSmunch.h'`; then
    echo shar: \"'vms/VMSmunch.h'\" unpacked with wrong size!
  fi
  # end of 'vms/VMSmunch.h'
fi
if test -f 'vms/vaxclib.opt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/vaxclib.opt'\"
else
  echo shar: Extracting \"'vms/vaxclib.opt'\" \(30 characters\)
  sed "s/^X//" >'vms/vaxclib.opt' <<'END_OF_FILE'
Xsys$library:vaxcrtl.exe/share
END_OF_FILE
  if test 30 -ne `wc -c <'vms/vaxclib.opt'`; then
    echo shar: \"'vms/vaxclib.opt'\" unpacked with wrong size!
  fi
  # end of 'vms/vaxclib.opt'
fi
echo shar: End of archive 9 \(of 11\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
