Newsgroups: comp.sources.misc
From: wht@n4hgf.Mt-Park.GA.US (Warren Tucker)
Subject:  v32i069:  ecu - ECU Asynchronous Communications v3.20, Part34/40
Message-ID: <1992Sep15.153357.20235@sparky.imd.sterling.com>
X-Md4-Signature: a90259bc807d9be058c2e318529edca1
Date: Tue, 15 Sep 1992 15:33:57 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: wht@n4hgf.Mt-Park.GA.US (Warren Tucker)
Posting-number: Volume 32, Issue 69
Archive-name: ecu/part34
Environment: SCO,XENIX,ISC,SUNOS,SYSVR4,HDB,Curses
Supersedes: ecu: Volume 21, Issue 53-89

---- Cut Here and feed the following to sh ----
#!/bin/sh
# this is ecu320.34 (part 34 of ecu320)
# do not concatenate these parts, unpack them in order with /bin/sh
# file fasi/fas.h continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 34; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping fasi/fas.h'
else
echo 'x - continuing file fasi/fas.h'
sed 's/^X//' << 'SHAR_EOF' >> 'fasi/fas.h' &&
X#define DF_DEVICE_OPEN		0x0020	/* physical device is open */
X#define DF_DEVICE_LOCKED	0x0040	/* physical device locked */
X#define DF_MODEM_ENABLED	0x0080	/* modem enabled */
X#define DF_XMIT_BUSY		0x0100	/* transmitter busy */
X#define DF_XMIT_BREAK		0x0200	/* transmitter sends break */
X#define DF_XMIT_LOCKED		0x0400	/* transmitter locked against output */
X#define DF_DO_HANGUP		0x0800	/* delayed hangup request */
X#define DF_DO_BREAK		0x1000	/* delayed break request */
X#define DF_GUARD_TIMEOUT	0x2000	/* protect last char from corruption */
X#define DF_NS16550A_DROP_MODE	0x4000	/* receiver trigger level is dropped */
X
X/* define the flow control status flags */
X
X#define FF_HWO_HANDSHAKE	0x0001	/* output hw handshake enabled */
X#define FF_HWI_HANDSHAKE	0x0002	/* input hw handshake enabled */
X#define FF_HDX_HANDSHAKE	0x0004	/* output hdx hw handshake enabled */
X#define	FF_HWO_STOPPED		0x0008	/* output stopped by hw handshake */
X#define FF_HWI_STOPPED		0x0010	/* input stopped by hw handshake */
X#define FF_HDX_STARTED		0x0020	/* output buffer contains characters */
X#define FF_SWO_STOPPED		0x0040	/* output stopped by sw flow control */
X#define FF_SWI_STOPPED		0x0080	/* input stopped by sw flow control */
X#define FF_SW_FC_REQ		0x0100	/* sw input flow control request */
X#define FF_RXFER_STOPPED	0x0200	/* rxfer function stopped */
X
X/* define the scheduled events flags */
X
X#define EF_DO_RXFER		0x0001	/* rxfer function request */
X#define EF_DO_XXFER		0x0002	/* xxfer function request */
X#define EF_DO_BRKINT		0x0004	/* break int request */
X#define EF_DO_MPROC		0x0008	/* mproc function request */
X#define EF_SIGNAL_VPIX		0x0010	/* send pseudorupt to VP/ix */
X
X/* define an easy way to reference the port structures */
X
X#define RCV_DATA_PORT		(fip->port_0)
X#define XMT_DATA_PORT		(fip->port_0)
X#define INT_ENABLE_PORT		(fip->port_1)
X#define INT_ID_PORT		(fip->port_2)
X#define NS_FIFO_CTL_PORT	(fip->port_2)
X#define I_BANK_PORT		(fip->port_2)
X#define LINE_CTL_PORT		(fip->port_3)
X#define MDM_CTL_PORT		(fip->port_4)
X#define I_IDM_PORT		(fip->port_4)
X#define LINE_STATUS_PORT	(fip->port_5)
X#define I_RCM_PORT		(fip->port_5)
X#define MDM_STATUS_PORT		(fip->port_6)
X#define I_TCM_PORT		(fip->port_6)
X#define DIVISOR_LSB_PORT	(fip->port_0)
X#define DIVISOR_MSB_PORT	(fip->port_1)
X#define CTL_PORT		(fip->ctl_port)
X
X/* modem control port */
X
X#define MC_SET_DTR		0x01
X#define MC_SET_RTS		0x02
X#define MC_SET_OUT1		0x04
X#define MC_SET_OUT2		0x08	/* tristates int line when false */
X#define MC_SET_LOOPBACK		0x10
X
X#define MC_ANY_CONTROL	(MC_SET_DTR | MC_SET_RTS)
X
X/* modem status port */
X
X#define MS_CTS_DELTA		0x01
X#define MS_DSR_DELTA		0x02
X#define MS_RING_TEDGE		0x04
X#define MS_DCD_DELTA		0x08
X#define MS_CTS_PRESENT		0x10
X#define MS_DSR_PRESENT		0x20
X#define MS_RING_PRESENT		0x40
X#define MS_DCD_PRESENT		0x80
X
X#define MS_ANY_DELTA	(MS_CTS_DELTA | MS_DSR_DELTA | MS_RING_TEDGE \
X				| MS_DCD_DELTA)
X#define MS_ANY_PRESENT	(MS_CTS_PRESENT | MS_DSR_PRESENT | MS_RING_PRESENT \
X				| MS_DCD_PRESENT)
X
X/* interrupt enable port */
X
X#define IE_NONE				0x00
X#define	IE_RECV_DATA_AVAILABLE		0x01
X#define	IE_XMIT_HOLDING_BUFFER_EMPTY	0x02
X#define IE_LINE_STATUS			0x04
X#define IE_MODEM_STATUS			0x08
X
X#define IE_INIT_MODE	(IE_RECV_DATA_AVAILABLE | IE_XMIT_HOLDING_BUFFER_EMPTY \
X			| IE_LINE_STATUS | IE_MODEM_STATUS)
X
X/* interrupt id port */
X
X#define II_NO_INTS_PENDING	0x01
X#define II_CODE_MASK		0x07
X#define II_MODEM_STATE		0x00
X#define II_XMTD_CHAR		0x02
X#define II_RCVD_CHAR		0x04
X#define II_RCV_ERROR		0x06
X#define II_NS_FIFO_TIMEOUT	0x08
X#define II_NS_FIFO_ENABLED	0xC0
X
X/* line control port */
X
X#define	LC_WORDLEN_MASK		0x03
X#define	LC_WORDLEN_5		0x00
X#define	LC_WORDLEN_6		0x01
X#define	LC_WORDLEN_7		0x02
X#define	LC_WORDLEN_8		0x03
X#define LC_STOPBITS_LONG	0x04
X#define LC_ENABLE_PARITY	0x08
X#define LC_EVEN_PARITY		0x10
X#define LC_STICK_PARITY		0x20
X#define LC_SET_BREAK_LEVEL	0x40
X#define LC_ENABLE_DIVISOR	0x80
X
X/* line status port */
X
X#define LS_RCV_AVAIL		0x01
X#define LS_OVERRUN		0x02
X#define LS_PARITY_ERROR		0x04
X#define LS_FRAMING_ERROR	0x08
X#define LS_BREAK_DETECTED	0x10
X#define LS_XMIT_AVAIL		0x20
X#define LS_XMIT_COMPLETE	0x40
X#define LS_ERROR_IN_NS_FIFO	0x80	/* NS16550A only */
X 
X#define LS_RCV_INT	(LS_RCV_AVAIL | LS_OVERRUN | LS_PARITY_ERROR \
X			| LS_FRAMING_ERROR | LS_BREAK_DETECTED)
X
X/* fifo control port (NS16550A only) */
X
X#define	NS_FIFO_ENABLE		0x01
X#define	NS_FIFO_CLR_RECV	0x02
X#define	NS_FIFO_CLR_XMIT	0x04
X#define	NS_FIFO_START_DMA	0x08
X#define NS_FIFO_SIZE_1		0x00
X#define NS_FIFO_SIZE_4		0x40
X#define NS_FIFO_SIZE_8		0x80
X#define NS_FIFO_SIZE_14		0xC0
X#define NS_FIFO_SIZE_MASK	0xC0
X
X#define NS_FIFO_CLEAR_CMD	0
X#define NS_FIFO_DROP_CMD	(NS_FIFO_SIZE_1 | NS_FIFO_ENABLE)
X#define NS_FIFO_SETUP_CMD	(NS_FIFO_SIZE_4 | NS_FIFO_ENABLE)
X#define NS_FIFO_INIT_CMD	(NS_FIFO_SETUP_CMD | NS_FIFO_CLR_RECV \
X				| NS_FIFO_CLR_XMIT)
X
X#define INPUT_NS_FIFO_SIZE	16
X#define OUTPUT_NS_FIFO_SIZE	16
X
X/* fifo control ports (i82510 only) */
X
X#define I_BANK_0		0x00
X#define I_BANK_1		0x20
X#define I_BANK_2		0x40
X#define I_BANK_3		0x60
X#define I_FIFO_ENABLE		0x08
X#define I_FIFO_CLR_RECV		0x30
X#define I_FIFO_CLR_XMIT		0x0c
X
X#define I_FIFO_CLEAR_CMD	0
X#define I_FIFO_SETUP_CMD	I_FIFO_ENABLE
X
X#define INPUT_I_FIFO_SIZE	4
X#define OUTPUT_I_FIFO_SIZE	4
X
X/* defines for ioctl calls (VP/ix) */
X
X#define AIOC			('A'<<8)
X#define AIOCINTTYPE		(AIOC|60)	/* set interrupt type */
X#define AIOCDOSMODE		(AIOC|61)	/* set DOS mode */
X#define AIOCNONDOSMODE		(AIOC|62)	/* reset DOS mode */
X#define AIOCSERIALOUT		(AIOC|63)	/* serial device data write */
X#define AIOCSERIALIN		(AIOC|64)	/* serial device data read */
X#define AIOCSETSS		(AIOC|65)	/* set start/stop chars */
X#define AIOCINFO		(AIOC|66)	/* tell us what device we are */
X
X/* ioctl alternate names used by VP/ix */
X
X#define VPC_SERIAL_DOS		AIOCDOSMODE
X#define VPC_SERIAL_NONDOS	AIOCNONDOSMODE
X#define VPC_SERIAL_INFO		AIOCINFO
X#define VPC_SERIAL_OUT		AIOCSERIALOUT
X#define VPC_SERIAL_IN		AIOCSERIALIN
X
X#if defined(FASI)
X#define FASIC			('~' << 8)
X#define FASIC_SIP		(FASIC | 16)	/* get entire fas_info struct */
X#define FASIC_SIP_CHANGE	(FASIC | 17)	/* get entire fas_info struct
X						 * after wait for change */
X#define FASIC_MSR		(FASIC | 18)	/* get various registers */
X#define FASIC_LCR		(FASIC | 19)
X#define FASIC_IER		(FASIC | 20)
X#define FASIC_MCR		(FASIC | 21)
X#define FASIC_DVR_IDENT		(FASIC | 22)	/* get driver revision */
X#define FASIC_SPACE_IDENT	(FASIC | 23)	/* get space.c revision */
X#define FASIC_RESET_STAT	(FASIC | 24)	/* reset statistics */
X#endif /* FASI */
X
X/* serial in/out requests */
X
X#define SO_DIVLLSB		1
X#define SO_DIVLMSB		2
X#define SO_LCR			3
X#define SO_MCR			4
X#define SI_MSR			1
X#define SIO_MASK(x)		(1<<((x)-1))
X
X
X/* This structure contains everything one would like to know about
X   an open device.  There is one of it for each physical unit.
X
X   We use several unions to eliminate most integer type conversions
X   at run-time. The standard UNIX V 3.X/386 C compiler forces all
X   operands in expressions and all function parameters to type int.
X   To save some time, with the means of unions we deliver type int
X   at the proper locations while dealing with the original type
X   wherever int would be slower.
X
X   This is highly compiler implementation specific. But for the sake
X   of speed the end justifies the means.
X
X   Take care that the size of the area that contains the various
X   structure fields (up to, but excluding the ring buffers)
X   is <= 128 bytes. Otherwise a 4-byte offset is used to access
X   some of the structure fields. For the first 128 bytes a 1-byte
X   offset is used, which is faster.
X*/
X
Xstruct	fas_info
X{
X	struct	tty	*tty;	/* the tty structure */
X	struct	fas_info *prev_int_user;/* link to previous fas_info struct */
X	struct	fas_info *next_int_user;/* link to next fas_info struct */
X	int	timeout_idx;	/* timeout index for untimeout () */
X	uint	iflag;		/* current terminal input flags */
X	uint	cflag;		/* current terminal hardware control flags */
X	union {			/* flags about the device state */
X		ushort	s;
X		uint	i;
X	} device_flags;
X	union {			/* flags about the flow control state */
X		ushort	s;
X		uint	i;
X	} flow_flags;
X	union {			/* flags about the scheduled events */
X		ushort	s;
X		uint	i;
X	} event_flags;
X	uint	o_state;	/* current open state */
X	uint	po_state;	/* previous open state */
X	union {			/* modem control masks */
X		struct {
X			unchar	di;	/* mask for modem disable */
X			unchar	eo;	/* mask for modem enable (dialout) */
X			unchar	ei;	/* mask for modem enable (dialin) */
X			unchar	ca;	/* mask for carrier detect */
X		} m;
X		ulong	l;
X	} modem;
X	union {			/* hardware flow control masks */
X		struct {
X			unchar	ic;	/* control mask for inp. flow ctrl */
X			unchar	oc;	/* control mask for outp. flow ctrl */
X			unchar	oe;	/* enable mask for outp. flow ctrl */
X			unchar	hc;	/* control mask for hdx flow ctrl */
X		} m;
X		ulong	l;
X	} flow;
X	unchar	msr;		/* modem status register value */
X	unchar	new_msr;	/* new modem status register value */
X	unchar	mcr;		/* modem control register value */
X	unchar	lcr;		/* line control register value */
X	unchar	ier;		/* interrupt enable register value */
X	unchar	vec;		/* interrupt vector for this struct */
X	unchar	msi_cnt;	/* modem status interrupt counter */
X#if defined (HAVE_VPIX)
X	unchar	v86_intmask;	/* VP/ix pseudorupt mask */
X	v86_t	*v86_proc;	/* VP/ix v86proc pointer for pseudorupts */
X	struct termss	v86_ss;	/* VP/ix start/stop characters */
X#endif
X	uint	ctl_port;	/* muliplexer control port */
X	union {			/* uart port addresses and control values */
X		uint	addr;
X		struct {
X			ushort	addr;
X			unchar	ctl;
X		} p;
X	} port_0, port_1, port_2, port_3, port_4, port_5, port_6;
X	uint	recv_ring_cnt;	/* receiver ring buffer counter */
X	unchar	*recv_ring_put_ptr;	/* recv ring buf put ptr */
X	unchar	*recv_ring_take_ptr;	/* recv ring buf take ptr */
X	ushort	xmit_fifo_size;	/* transmitter FIFO size */
X	ushort	xmit_ring_size;	/* transmitter ring buffer size */
X	uint	xmit_ring_cnt;	/* transmitter ring buffer counter */
X	unchar	*xmit_ring_put_ptr;	/* xmit ring buf put ptr */
X	unchar	*xmit_ring_take_ptr;	/* xmit ring buf take ptr */
X#if defined(FASI)
X	unsigned long characters_received;
X	unsigned long characters_transmitted;
X	unsigned long modem_status_events;
X	unsigned long overrun_errors;
X	unsigned long framing_errors;
X	unsigned long parity_errors;
X	unsigned long rings_detected;
X	unsigned long breaks_detected;
X	unsigned long xmtr_hw_flow_count;
X	unsigned long xmtr_sw_flow_count;
X	unsigned long rcvr_hw_flow_count;
X	unsigned long rcvr_sw_flow_count;
X#endif /* FASI */
X	unchar	recv_buffer [RECV_BUFF_SIZE];	/* recv ring buf */
X	unchar	xmit_buffer [XMIT_BUFF_SIZE];	/* xmit ring buf */
X};
X
X#if defined(FASI)
Xstruct fas_name
X{
X	char name[8];
X};
X#endif
SHAR_EOF
echo 'File fasi/fas.h is complete' &&
chmod 0644 fasi/fas.h ||
echo 'restore of fasi/fas.h failed'
Wc_c="`wc -c < 'fasi/fas.h'`"
test 21979 -eq "$Wc_c" ||
	echo 'fasi/fas.h: original size 21979, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= fasi/idfasi ==============
if test -f 'fasi/idfasi' -a X"$1" != X"-c"; then
	echo 'x - skipping fasi/idfasi (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting fasi/idfasi (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'fasi/idfasi' &&
X:
X#+---------------------------------------------------------------
X# idefas - ECU FASI/FAS Installation
X# Alas, SCO idinstall has no -z (Define) option like ISC does
X#----------------------------------------------------------------
X/etc/conf/bin/idcheck -p fas
Xif [ $? -lt 16 ] ; then
X	/etc/conf/bin/idinstall -a -e -k fas
Xelse
X	/etc/conf/bin/idinstall -u -e -k fas
Xfi
SHAR_EOF
chmod 0744 fasi/idfasi ||
echo 'restore of fasi/idfasi failed'
Wc_c="`wc -c < 'fasi/idfasi'`"
test 370 -eq "$Wc_c" ||
	echo 'fasi/idfasi: original size 370, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ecufriend/ecufriend.c ==============
if test -f 'ecufriend/ecufriend.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ecufriend/ecufriend.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ecufriend/ecufriend.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ecufriend/ecufriend.c' &&
X#define DUMP_SCREEN
X/*+-------------------------------------------------------------------------
X	ecufriend.c -- example of using ecu shared memory access
X	wht@n4hgf.Mt-Park.GA.US
X
XExecute by ecu procedure command:  system -s 'ecufriend '+%itos(%shmid)
XTo manually execute for perusal, do an ipcs command to find the
Xshared memory id or HOME pc echo 'shmid='+%itos(%shmid)
XThen HOME >ecufriend # where # is replaced by the shmid
X--------------------------------------------------------------------------*/
X/*+:EDITS:*/
X/*:09-10-1992-13:58-wht@n4hgf-ECU release 3.20 */
X/*:08-22-1992-15:38-wht@n4hgf-ECU release 3.20 BETA */
X/*:07-25-1991-12:56-wht@n4hgf-ECU release 3.10 */
X/*:08-14-1990-20:40-wht@n4hgf-ecu3.00-flush old edit history */
X
X#include <stdio.h>
X#include <signal.h>
X#include <termio.h>
X#include <sys/errno.h>
X#include "../ecu_types.h"
X#include "../ecu_stat.h"
X#include <time.h>
X#include <sys/ipc.h>
X#include <sys/msg.h>
X#include <sys/shm.h>
X#include "../ecushm.h"
X
XECU_SDS FAR *shm;		/* shared segment pointer */
Xint shmid;				/* sharged segment id */
X
X/*+-------------------------------------------------------------------------
X	main(argc,argv,envp)
X--------------------------------------------------------------------------*/
Xmain(argc,argv,envp)
Xint argc;
Xchar **argv;
Xchar **envp;
X{
Xregister itmp;
X#ifdef DUMP_SCREEN
Xint row,col;
Xunsigned char sch;
X#endif
X
X	if(argc < 2)
X	{
X		printf("usage: ecufriend <ecu-shmid>\n");
X			exit(255);
X	}
X	shmid = atoi(argv[1]);
X
X	if((shm = (ECU_SDS FAR *)shmat(shmid,(char FAR *)0,SHM_RDONLY))
X			== (ECU_SDS FAR *)-1)
X	{
X		perror("shmat");
X		exit(1);
X	}
X
X	printf("ecu shm address = %08lx shmid=%d revision=%08lx\n",
X		shm,shmid,shm->shm_revision);
X
X	if(shm->shm_revision != SHM_REV)
X	{
X		printf("incompatible shared memory revision (compiled with %08lx)\n",
X			SHM_REV);
X		exit(1);
X	}
X
X	printf("xmit chars=%lu rcvd chars=%lu\n",
X		shm->xmit_chars,shm->rcvd_chars);
X	printf("The receive cursor position is at column %d row %d\n",
X		shm->cursor_y,shm->cursor_x);
X
X	printf("If this program was not executed by a shell that closed it,\n");
X	printf("then fd %d is available to us to write and read from the line.\n",
X		shm->Liofd);
X
X	if(isatty(shm->Liofd))
X		printf("It is available.\n");
X	else
X		printf("It is not available. Even so, we could re-open %s here\n",
X			shm->Lline);
X
X	if(shm->Lmodem_off_hook)
X		printf("Hmmm.. we seem to be connected to %s at %s\n",
X			shm->Ldescr,shm->Ltelno);
X
X#ifdef DUMP_SCREEN
X	printf("screen dump\n");
X	printf("-----------\n");
X	for(row = 0; row < 43; row++)
X	{
X		for(col = 0; col < 79; col++)
X		{
X			sch = shm->screen[row][col];
X			if((sch < 0x20) && (sch > 0x7E))
X				putc('.',stdout);
X			else
X				putc(sch,stdout);
X		}
X		putc('\n',stdout);
X	}
X#endif
X
X	exit(0);
X}	/* end of main */
X
X/* vi: set tabstop=4 shiftwidth=4: */
X/* end of ecufriend.c */
SHAR_EOF
chmod 0644 ecufriend/ecufriend.c ||
echo 'restore of ecufriend/ecufriend.c failed'
Wc_c="`wc -c < 'ecufriend/ecufriend.c'`"
test 2829 -eq "$Wc_c" ||
	echo 'ecufriend/ecufriend.c: original size 2829, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= mapkey/README ==============
if test ! -d 'mapkey'; then
    echo 'x - creating directory mapkey'
    mkdir 'mapkey'
fi
if test -f 'mapkey/README' -a X"$1" != X"-c"; then
	echo 'x - skipping mapkey/README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting mapkey/README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mapkey/README' &&
X
X#+:EDITS:*/
X#:09-10-1992-13:59-wht@n4hgf-ECU release 3.20
X#:08-22-1992-15:39-wht@n4hgf-ECU release 3.20 BETA
X#:05-02-1991-01:57-wht@n4hgf-alt-[a-z] range moved from 0x80-0x99 to 0xe0-0xf9
X
XThis file contains information necessary to map ALT-A through ALT-Z
Xin accordance with ecuxkey.h to produce unique codes so that
XALT-[a-z] can cause ECU to execute procedures with a single keystroke.
X
XBeginning with ECU 3.10, the key code range changed:
X      128 through 153 (0x80 through 0x99)     to
X      229 through 249 (0xE0 through 0xF9)
X
XModify your /usr/lib/keyboard/keys value for the ALT values for
Xkey codes matching keys [a-z] as follows.  If you have made no 
Xother changes to your key file, use the supplied keys.usa.ecu
X
XMy apologies to those caught by having already done something
Xsimilar for EMACS or CRISP.
X
XThese are the necessary differences:
X
X                                ALT-unshifted
X                                     |
X                                     V
X    16  'q'    'Q'    dc1    dc1    0xf0   'Q'    dc1    dc1     C
X    17  'w'    'W'    etb    etb    0xf6   'W'    etb    etb     C
X    18  'e'    'E'    enq    enq    0xe4   'E'    enq    enq     C
X    19  'r'    'R'    dc2    dc2    0xf1   'R'    dc2    dc2     C
X    20  't'    'T'    dc4    dc4    0xf3   'T'    dc4    dc4     C
X    21  'y'    'Y'    em     em     0xf8   'Y'    em     em      C
X    22  'u'    'U'    nak    nak    0xf4   'U'    nak    nak     C
X    23  'i'    'I'    ht     ht     0xe8   'I'    ht     ht      C
X    24  'o'    'O'    si     si     0xee   'O'    si     si      C
X    25  'p'    'P'    dle    dle    0xef   'P'    dle    dle     C
X    30  'a'    'A'    soh    soh    0xe0   'A'    soh    soh     C
X    31  's'    'S'    dc3    dc3    0xf2   'S'    dc3    dc3     C
X    32  'd'    'D'    eot    eot    0xe3   'D'    eot    eot     C
X    33  'f'    'F'    ack    ack    0xe5   'F'    ack    ack     C
X    34  'g'    'G'    bel    bel    0xe6   'G'    bel    bel     C
X    35  'h'    'H'    bs     bs     0xe7   'H'    bs     bs      C
X    36  'j'    'J'    nl     nl     0xe9   'J'    nl     nl      C
X    37  'k'    'K'    vt     vt     0xea   'K'    vt     vt      C
X    38  'l'    'L'    np     np     0xeb   'L'    np     np      C
X    44  'z'    'Z'    sub    sub    0xf9   'Z'    sub    sub     C
X    45  'x'    'X'    can    can    0xf7   'X'    can    can     C
X    46  'c'    'C'    etx    etx    0xe2   'C'    etx    etx     C
X    47  'v'    'V'    syn    syn    0xf5   'V'    syn    syn     C
X    48  'b'    'B'    stx    stx    0xe1   'B'    stx    stx     C
X    49  'n'    'N'    so     so     0xed   'N'    so     so      C
X    50  'm'    'M'    cr     cr     0xec   'M'    cr     cr      C
X
SHAR_EOF
chmod 0644 mapkey/README ||
echo 'restore of mapkey/README failed'
Wc_c="`wc -c < 'mapkey/README'`"
test 2723 -eq "$Wc_c" ||
	echo 'mapkey/README: original size 2723, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= mapkey/keys.usa.ecu ==============
if test -f 'mapkey/keys.usa.ecu' -a X"$1" != X"-c"; then
	echo 'x - skipping mapkey/keys.usa.ecu (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting mapkey/keys.usa.ecu (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mapkey/keys.usa.ecu' &&
X#+----------------------------------------------------------------------------
X# keys.usa.ecu
X# SCO keys file for ECU alt-[a-z] support
X#-----------------------------------------------------------------------------
X#+:EDITS:*/
X#:09-10-1992-13:59-wht@n4hgf-ECU release 3.20
X#:08-22-1992-15:39-wht@n4hgf-ECU release 3.20 BETA
X#:05-02-1991-01:57-wht@n4hgf-alt-[a-z] range moved from 0x80-0x99 to 0xe0-0xf9
X
X# scan                      cntrl          alt    alt   cntrl  lock
X# code  base  shift  cntrl  shift   alt   shift  cntrl  shift  state
X     0  nop    nop    nop    nop    nop    nop    nop    nop     O
X     1  esc    esc    esc    esc    esc    esc    esc    esc     O
X     2  '1'    '!'    nop    nop    '1'    '!'    nop    nop     O
X     3  '2'    '@'    nul    nul    '2'    '@'    nul    nul     O
X     4  '3'    '#'    nop    nop    '3'    '#'    nop    nop     O
X     5  '4'    '$'    nop    nop    '4'    '$'    nop    nop     O
X     6  '5'    '%'    nop    nop    '5'    '%'    nop    nop     O
X     7  '6'    '^'    rs     rs     '6'    '^'    rs     rs      O
X     8  '7'    '&'    nop    nop    '7'    '&'    nop    nop     O
X     9  '8'    '*'    nop    nop    '8'    '*'    nop    nop     O
X    10  '9'    '('    nop    nop    '9'    '('    nop    nop     O
X    11  '0'    ')'    nop    nop    '0'    ')'    nop    nop     O
X    12  '-'    '_'    ns     ns     '-'    '_'    ns     ns      O
X    13  '='    '+'    nop    nop    '='    '+'    nop    nop     O
X    14  bs     bs     del    del    bs     bs     del    del     O
X    15  ht     btab   nop    nop    ht     btab   nop    nop     O
X    16  'q'    'Q'    dc1    dc1    0xf1   'Q'    dc1    dc1     C
X    17  'w'    'W'    etb    etb    0xf7   'W'    etb    etb     C
X    18  'e'    'E'    enq    enq    0xe5   'E'    enq    enq     C
X    19  'r'    'R'    dc2    dc2    0xf2   'R'    dc2    dc2     C
X    20  't'    'T'    dc4    dc4    0xf4   'T'    dc4    dc4     C
X    21  'y'    'Y'    em     em     0xf9   'Y'    em     em      C
X    22  'u'    'U'    nak    nak    0xf5   'U'    nak    nak     C
X    23  'i'    'I'    ht     ht     0xe9   'I'    ht     ht      C
X    24  'o'    'O'    si     si     0xef   'O'    si     si      C
X    25  'p'    'P'    dle    dle    0xf0   'P'    dle    dle     C
X    26  '['    '{'    esc    esc    '['    '{'    esc    esc     O
X    27  ']'    '}'    gs     gs     ']'    '}'    gs     gs      O
X    28  cr     cr     nl     nl     cr     cr     nl     nl      O
X    29  lctrl  lctrl  lctrl  lctrl  lctrl  lctrl  lctrl  lctrl   O
X    30  'a'    'A'    soh    soh    0xe1   'A'    soh    soh     C
X    31  's'    'S'    dc3    dc3    0xf3   'S'    dc3    dc3     C
X    32  'd'    'D'    eot    eot    0xe4   'D'    eot    eot     C
X    33  'f'    'F'    ack    ack    0xe6   'F'    ack    ack     C
X    34  'g'    'G'    bel    bel    0xe7   'G'    bel    bel     C
X    35  'h'    'H'    bs     bs     0xe8   'H'    bs     bs      C
X    36  'j'    'J'    nl     nl     0xea   'J'    nl     nl      C
X    37  'k'    'K'    vt     vt     0xeb   'K'    vt     vt      C
X    38  'l'    'L'    np     np     0xec   'L'    np     np      C
X    39  ';'    ':'    nop    nop    ';'    ':'    nop    nop     O
X    40  '\''   '"'    nop    nop    '\''   '"'    nop    nop     O
X    41  '`'    '~'    nop    nop    '`'    '~'    nop    nop     O
X    42  lshift lshift lshift lshift lshift lshift lshift lshift  O
X    43  '\\'   '|'    fs     fs     '\\'   '|'    fs     fs      O
X    44  'z'    'Z'    sub    sub    0xfa   'Z'    sub    sub     C
X    45  'x'    'X'    can    can    0xf8   'X'    can    can     C
X    46  'c'    'C'    etx    etx    0xe3   'C'    etx    etx     C
X    47  'v'    'V'    syn    syn    0xf6   'V'    syn    syn     C
X    48  'b'    'B'    stx    stx    0xe2   'B'    stx    stx     C
X    49  'n'    'N'    so     so     0xee   'N'    so     so      C
X    50  'm'    'M'    cr     cr     0xed   'M'    cr     cr      C
X    51  ','    '<'    nop    nop    ','    '<'    nop    nop     O
X    52  '.'    '>'    nop    nop    '.'    '>'    nop    nop     O
X    53  '/'    '?'    nop    nop    '/'    '?'    nop    nop     O
X    54  rshift rshift rshift rshift rshift rshift rshift rshift  O
X    55  '*'    '*'    nscr   nscr   '*'    '*'    nscr   nscr    O
X    56  lalt   lalt   lalt   lalt   lalt   lalt   lalt   lalt    O
X    57  ' '    ' '    ' '    ' '    ' '    ' '    ' '    ' '     O
X    58  clock  clock  clock  clock  clock  clock  clock  clock   O
X    59  fkey1  fkey13 fkey25 fkey37 scr1   scr11  scr1   scr11   O
X    60  fkey2  fkey14 fkey26 fkey38 scr2   scr12  scr2   scr12   O
X    61  fkey3  fkey15 fkey27 fkey39 scr3   scr13  scr3   scr13   O
X    62  fkey4  fkey16 fkey28 fkey40 scr4   scr14  scr4   scr14   O
X    63  fkey5  fkey17 fkey29 fkey41 scr5   scr15  scr5   scr15   O
X    64  fkey6  fkey18 fkey30 fkey42 scr6   scr16  scr6   scr16   O
X    65  fkey7  fkey19 fkey31 fkey43 scr7   scr7   scr7   scr7    O
X    66  fkey8  fkey20 fkey32 fkey44 scr8   scr8   scr8   scr8    O
X    67  fkey9  fkey21 fkey33 fkey45 scr9   scr9   scr9   scr9    O
X    68  fkey10 fkey22 fkey34 fkey46 scr10  scr10  scr10  scr10   O
X    69  nlock  nlock  dc3    dc3    nlock  nlock  dc3    dc3     O
X    70  slock  slock  del    del    slock  slock  del    del     O
X    71  fkey49 '7'    '7'    '7'    '7'    '7'    '7'    '7'     N
X    72  fkey50 '8'    '8'    '8'    '8'    '8'    '8'    '8'     N
X    73  fkey51 '9'    '9'    '9'    '9'    '9'    '9'    '9'     N
X    74  fkey52 '-'    '-'    '-'    '-'    '-'    '-'    '-'     N
X    75  fkey53 '4'    '4'    '4'    '4'    '4'    '4'    '4'     N
X    76  fkey54 '5'    '5'    '5'    '5'    '5'    '5'    '5'     N
X    77  fkey55 '6'    '6'    '6'    '6'    '6'    '6'    '6'     N
X    78  fkey56 '+'    '+'    '+'    '+'    '+'    '+'    '+'     N
X    79  fkey57 '1'    '1'    '1'    '1'    '1'    '1'    '1'     N
X    80  fkey58 '2'    '2'    '2'    '2'    '2'    '2'    '2'     N
X    81  fkey59 '3'    '3'    '3'    '3'    '3'    '3'    '3'     N
X    82  fkey60 '0'    '0'    '0'    '0'    '0'    '0'    '0'     N
X    83  del    '.'    del    del    del    del    del    del     N
X    84  0x1f   0x1f   0x1f   0x1f   0x1f   0x1f   0x1f   0x1f    O
X    85  nop    nop    nop    nop    nop    nop    nop    nop     O
X    86  nop    nop    nop    nop    nop    nop    nop    nop     O
X    87  fkey11 fkey23 fkey35 fkey47 scr11  scr11  scr11  scr11   O
X    88  fkey12 fkey24 fkey36 fkey48 scr12  scr12  scr12  scr12   O
X    89  nop    nop    nop    nop    nop    nop    nop    nop     O
X    90  nop    nop    nop    nop    nop    nop    nop    nop     O
X    91  nop    nop    nop    nop    nop    nop    nop    nop     O
X    92  nop    nop    nop    nop    nop    nop    nop    nop     O
X    93  nop    nop    nop    nop    nop    nop    nop    nop     O
X    94  nop    nop    nop    nop    nop    nop    nop    nop     O
X    95  nop    nop    nop    nop    nop    nop    nop    nop     O
X    96  fkey50 fkey50 fkey50 fkey50 fkey50 fkey50 fkey50 fkey50  O
X    97  fkey53 fkey53 fkey53 fkey53 fkey53 fkey53 fkey53 fkey53  O
X    98  fkey58 fkey58 fkey58 fkey58 fkey58 fkey58 fkey58 fkey58  O
X    99  fkey55 fkey55 fkey55 fkey55 fkey55 fkey55 fkey55 fkey55  O
X   100  fkey49 fkey49 fkey49 fkey49 fkey49 fkey49 fkey49 fkey49  O
X   102  fkey57 fkey57 fkey57 fkey57 fkey57 fkey57 fkey57 fkey57  O
X   103  fkey59 fkey59 fkey59 fkey59 fkey59 fkey59 fkey59 fkey59  O
X   104  fkey60 fkey60 fkey60 fkey60 fkey60 fkey60 fkey60 fkey60  O
X   105  del    del    del    del    del    del    del    del     N
X   106  fkey54 fkey54 fkey54 fkey54 fkey54 fkey54 fkey54 fkey54  O
X   107  nop    nop    nop    nop    nop    nop    nop    nop     O
X   108  nop    nop    nop    nop    nop    nop    nop    nop     O
X   109  nop    nop    nop    nop    nop    nop    nop    nop     O
X   110  nop    nop    nop    nop    nop    nop    nop    nop     O
X   111  fkey51 fkey51 fkey51 fkey51 fkey51 fkey51 fkey51 fkey51  O
X   111  nop    nop    nop    nop    nop    nop    nop    nop     O
X   112  nop    nop    nop    nop    nop    nop    nop    nop     O
X   113  nop    nop    nop    nop    nop    nop    nop    nop     O
X   114  nop    nop    nop    nop    nop    nop    nop    nop     O
X   116  nop    nop    nop    nop    nop    nop    nop    nop     O
X   117  nop    nop    nop    nop    nop    nop    nop    nop     O
X   118  nop    nop    nop    nop    nop    nop    nop    nop     O
X   119  nop    nop    nop    nop    nop    nop    nop    nop     O
X   120  nop    nop    nop    nop    nop    nop    nop    nop     O
X   121  nop    nop    nop    nop    nop    nop    nop    nop     O
X   122  nop    nop    nop    nop    nop    nop    nop    nop     O
X   123  nop    nop    nop    nop    nop    nop    nop    nop     O
X   124  nop    nop    nop    nop    nop    nop    nop    nop     O
X   125  nop    nop    nop    nop    nop    nop    nop    nop     O
X   126  nop    nop    nop    nop    nop    nop    nop    nop     O
X   127  nop    nop    nop    nop    nop    nop    nop    nop     O
X   128  rctrl  rctrl  rctrl  rctrl  rctrl  rctrl  rctrl  rctrl   O
X   129  ralt   ralt   ralt   ralt   ralt   ralt   ralt   ralt    O
X   130  fkey60 fkey60 fkey60 fkey60 fkey60 fkey60 fkey60 fkey60  O
X   131  del    del    del    del    del    del    del    del     N
X   132  fkey49 fkey49 fkey49 fkey49 fkey49 fkey49 fkey49 fkey49  O
X   133  fkey57 fkey57 fkey57 fkey57 fkey57 fkey57 fkey57 fkey57  O
X   134  fkey51 fkey51 fkey51 fkey51 fkey51 fkey51 fkey51 fkey51  O
X   135  fkey59 fkey59 fkey59 fkey59 fkey59 fkey59 fkey59 fkey59  O
X   136  fkey55 fkey55 fkey55 fkey55 fkey55 fkey55 fkey55 fkey55  O
X   137  fkey53 fkey53 fkey53 fkey53 fkey53 fkey53 fkey53 fkey53  O
X   138  fkey50 fkey50 fkey50 fkey50 fkey50 fkey50 fkey50 fkey50  O
X   139  fkey58 fkey58 fkey58 fkey58 fkey58 fkey58 fkey58 fkey58  O
X   140  '/'    nop    nop    nop    '/'    nop    nop    nop     O
X   141  cr     cr     nl     nl     cr     cr     nl     nl      O
SHAR_EOF
chmod 0644 mapkey/keys.usa.ecu ||
echo 'restore of mapkey/keys.usa.ecu failed'
Wc_c="`wc -c < 'mapkey/keys.usa.ecu'`"
test 9988 -eq "$Wc_c" ||
	echo 'mapkey/keys.usa.ecu: original size 9988, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xsel386/fixttiocom.c ==============
if test ! -d 'xsel386'; then
    echo 'x - creating directory xsel386'
    mkdir 'xsel386'
fi
if test -f 'xsel386/fixttiocom.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xsel386/fixttiocom.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xsel386/fixttiocom.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xsel386/fixttiocom.c' &&
X/*+-------------------------------------------------------------------------
X	fixttiocom.c - change ttiocom to Ttiocom calls in /usr/sys/sys/libsys.a
XThis program patched my Xenix 386 2.3.1 system library (a copy of which
Xhad been named libfix.a, fixed, verified, then moved to libsys.a)
X--------------------------------------------------------------------------*/
X/*+:EDITS:*/
X/*:09-10-1992-14:00-wht@n4hgf-ECU release 3.20 */
X/*:08-22-1992-15:39-wht@n4hgf-ECU release 3.20 BETA */
X/*:07-25-1991-12:59-wht@n4hgf-ECU release 3.10 */
X/*:08-14-1990-20:40-wht@n4hgf-ecu3.00-flush old edit history */
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <fcntl.h>
X
Xchar *lib = "libfix.a";
X
X/* file positions where names needed changing */
X#define PLACE1 0xdcaL
X#define PLACE2 0x1b1cbL
X#define PLACE3 0x1c41bL
X
X/*+-------------------------------------------------------------------------
X	main(argc,argv,envp)
X--------------------------------------------------------------------------*/
Xmain(argc,argv,envp)
Xint argc;
Xchar **argv;
Xchar **envp;
X{
Xint fd = open(lib,O_RDWR,0);
Xunsigned char ch1,ch2,ch3;
Xlong lseek();
X
X	if(fd < 0)
X	{
X		perror(lib);
X		exit(9);
X	}
X
X	if(lseek(fd,PLACE1,0) != PLACE1)
X	{
X		perror("seek1");
X		exit(1);
X	}
X	if(read(fd,&ch1,1) != 1)
X	{
X		perror("read1");
X		exit(1);
X	}
X	printf("char 1 = %02x\n",ch1);
X
X	if(lseek(fd,PLACE2,0) != PLACE2)
X	{
X		perror("seek2");
X		exit(2);
X	}
X	if(read(fd,&ch2,2) != 2)
X	{
X		perror("read2");
X		exit(2);
X	}
X	printf("char 2 = %02x\n",ch2);
X
X
X	if(lseek(fd,PLACE3,0) != PLACE3)
X	{
X		perror("seek3");
X		exit(3);
X	}
X	if(read(fd,&ch3,1) != 1)
X	{
X		perror("read3");
X		exit(3);
X	}
X	printf("char 3 = %02x\n",ch3);
X
X	if((ch1 != 't') || (ch2 != 't') || (ch3 != 't'))
X		exit(8);
X	if(lseek(fd,PLACE1,0) != PLACE1)
X	{
X		perror("seek1");
X		exit(1);
X	}
X	write(fd,"T",1);
X	if(lseek(fd,PLACE2,0) != PLACE2)
X	{
X		perror("seek1");
X		exit(1);
X	}
X	write(fd,"T",1);
X	if(lseek(fd,PLACE3,0) != PLACE3)
X	{
X		perror("seek1");
X		exit(1);
X	}
X	write(fd,"T",1);
X	printf("done\n");
X	close(fd);
X
X	exit(0);
X}	/* end of main */
X
X/* vi: set tabstop=4 shiftwidth=4: */
X/* end of fixttiocom.c */
SHAR_EOF
chmod 0644 xsel386/fixttiocom.c ||
echo 'restore of xsel386/fixttiocom.c failed'
Wc_c="`wc -c < 'xsel386/fixttiocom.c'`"
test 2104 -eq "$Wc_c" ||
	echo 'xsel386/fixttiocom.c: original size 2104, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xsel386/select-update ==============
if test -f 'xsel386/select-update' -a X"$1" != X"-c"; then
	echo 'x - skipping xsel386/select-update (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xsel386/select-update (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xsel386/select-update' &&
XSubject: Re: Select(S) in Xenix 386 2.3.2
XNewsgroups: comp.unix.xenix
XKeywords: select, serial, pipes
XReferences: <117@accsys.acc.uu.no> <172@prmmbx.UUCP>
X
XIn article <172@prmmbx.UUCP>, csch@netcs.UUCP (Clemens Schrimpe) writes:
X> ivar@acc.uu.no (Ivar Hosteng) writes:
X> <> I have experienced some problems using the select call in Xenix 386 V2.3.2.
X> <> It does not seems to detect when a pipe gets ready to been read from.
X> This is, because there is no provision to select on pipes!
X> Why? The stuff is almost totally ported 1:1 from the Berkeley code and
X> in BSD pipes should consist of AF_UNIX sockets, on which you can naturally
X> select.
X> I was very angry, when I found this out after hours of digging with adb in
X> the kernel. But I also tried the same on a SUN under SunOS 4.0 and it doesn't
X> work either ... seems to be a common illness ???
X> (I wonder, because the code for that is very simple ... ??? ...)
X> 
X> <> I also 
X> <> have trouble using select on a serial port.  When I do that the input
X> <> turns into garbage.  This does not occur when I use select on the
X> <> multiscreen ttys (tty01-tty12).
X> Hehe - we had just the same!
X> Here is the solution (thanks to my colleague Stefan Koehler, who took one
X> look at my screen, into which I had starred for hours, to find it ...)
X> 
X> Select is implemented by an undocumented ioctl
X> 	(0xFFFF == IOC_SELECT -> [sys/slect.h])
X> which is handled by ttiocom() for all devices using the standard
X> SYS-V linediscipline!
X> 
X> The ioctl-routine for the serial devices [sioioctl()] just calls 
X> ttiocom() [after some undefinable VPIX stuff ???] and
X> if it returns NON-ZERO it calls sioparam(), which adjusts certain
X> parameters and garbles the output!
X> OK so far. Now: The Bug lies in the ttiocom-code within the check
X> for IOC_SELECT. After detecting the IOC_SELECT, the ttiocom calls
X> the select-code and returns NOTHING, which means that if EAX is
X> non-zero (randomly) sioparam() is called and garbles the output.
X> 
X> The Fix: (quick and dirty)
X> Write a routine called "ttiocom", which might look like this:
X> 
X> ttiocom(ttyp, com, arg, flag)
X> struct tty *ttyp;
X> int com, arg, flag;	/* there should be better types for this :-) */
X> {
X> 	if (com == IOC_SELECT)
X> 	{
X> 		ttselect(ttyp, flag);
X> 		return(0);	/*** THIS IS IMPORTANT ***/
X> 	}
X> 	return(Ttiocom(ttyp, com ,arg, flag));
X> }
X> 
X> Compile something like this, then use whatever you have (GNU-Emacs is
X> great in patching strings in binaries) to patch /usr/sys/sys/libsys.a
X> to change the original ttiocom into Ttiocom !
X> Link in your code and -by some magic reason- experience a full blown
X> select on your System V / Xenix machine!!!
X> 
X> Have fun playing around with it -
X> 
X> 	Clemens Schrimpe, netCS Informationstechnik GmbH Berlin
X> --
X> UUCP:		csch@netcs		BITNET:	csch@db0tui6.BITNET
X> ARPA/NSF:	csch@garp.mit.edu	PSI: PSI%45300033047::CSCH
X> PHONE:		+49-30-24 42 37		FAX: +49-30-24 38 00
X> BTX:		0303325016-0003		TELEX: 186672 net d
X
X
SHAR_EOF
chmod 0644 xsel386/select-update ||
echo 'restore of xsel386/select-update failed'
Wc_c="`wc -c < 'xsel386/select-update'`"
test 2981 -eq "$Wc_c" ||
	echo 'xsel386/select-update: original size 2981, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xsel386/select.asm ==============
if test -f 'xsel386/select.asm' -a X"$1" != X"-c"; then
	echo 'x - skipping xsel386/select.asm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xsel386/select.asm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xsel386/select.asm' &&
X;  CHK=0x1E37
X;+----------------------------------------------------------
X; select(S)
X;
X;#include <stdio.h>
X;#include <sys/select.h>
X;#include <fcntl.h>
X;
X;main(argc,argv,envp)
X;int argc;
X;char **argv;
X;char **envp;
X;{
X;struct timeval t;
X;int readfds;
X;int fd = open("/dev/null",O_RDONLY,0);
X;
X;	readfds = 1<<fd | 1<<0;
X;
X;	t.tv_sec = 5;
X;	t.tv_usec = 0;
X;
X;	printf("%d\n",select(32,&readfds,0,0,&t));
X;	printf("%08x\n",readfds);
X;	exit(0);
X;}	/* end of main */
X;
X;-----------------------------------------------------------
X
X	title	select
X
X	.386
X
XSYSNUM	equ 	2428h
X
Xextrn	_errno:dword
X
Xpublic  _select
X
X_TEXT	segment  dword use32 public 'CODE'
X	assume   cs: _TEXT
X_select	proc near
X	mov	eax, SYSNUM		; Get system call number.
X
X	;
X	; I don't even pretend to understand masm syntax.  I tried
X	; the following line (and variations) without any success.
X	;
X
X;	call    far 7:0			; Switch to kernel and call SYSNUM.
X
X	;
X	; Don't laugh, it works.
X	;
X
X	db 9ah
X	dw 0,0
X	dw 7
X
X	jb	short _cerror		; below == error.
X
X;	xor	eax, eax		; zero return value (no error).
X	ret				; done.
X
X_cerror:
X	mov	_errno, eax		; Save error code in _errno.
X	mov	eax, -1			; Return -1 (as error).
X	ret				; done.
X
X_select	endp
X
X_TEXT	ends
X
X	end
X; vi: set tabstop=8 :
SHAR_EOF
chmod 0644 xsel386/select.asm ||
echo 'restore of xsel386/select.asm failed'
Wc_c="`wc -c < 'xsel386/select.asm'`"
test 1237 -eq "$Wc_c" ||
	echo 'xsel386/select.asm: original size 1237, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xsel386/select.txt ==============
if test -f 'xsel386/select.txt' -a X"$1" != X"-c"; then
	echo 'x - skipping xsel386/select.txt (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xsel386/select.txt (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xsel386/select.txt' &&
XNOTE from ...!gatech!emory!tridom!wht:
Xthe following is the mail message I originally received; with
Xa little tinkering, i got the select call to behave as advertised
Xin the BSD manual (my xenix is 386 2.3).  Added it to /lib/386/Slibx.a
Xand all is well for me.  Good luck.
X
X
XFrom emory!gatech!hubcap!ncrcae!ncr-sd!crash!elgar!ag Thu Feb  2 13:04:07 EST 1989
XArticle 4851 of comp.unix.xenix:
XPath: tridom!emory!gatech!hubcap!ncrcae!ncr-sd!crash!elgar!ag
X>From: ag@elgar.UUCP (Keith Gabryelski)
XNewsgroups: comp.unix.xenix
XSubject: select() on SCO XENIX 2.3.
XMessage-ID: <38@elgar.UUCP>
XDate: 24 Jan 89 04:54:17 GMT
XReply-To: ag@elgar.UUCP (Keith Gabryelski)
XOrganization: Elgar Corporation, San Diego, CA
XLines: 474
X
XA few days ago I was paging through my SCO XENIX 2.3.1 Release Notes
Xand found, on page 44 (section 16), a section describing 4BSD
Xenhancements to the current release of SCO XENIX.
X
Xselect(S) was mentioned specifically.
X
XI checked the rest of the 2.3 manuals to see if there was a clue on
Xhow to access select(); no dice.  I tried my 2.2 dev sys libraries to
Xsee if it had been supported in previous releases and just not
Xmentioned; negative.
X
XI decided to see if I could get select() to work on my system.  And
Xthat is what this article is about.
X
XI checked /xenix and found:
X
X	% nm xenix | grep select
X	nm: xenix: too many symbols to sort		# chuckle
X	0020:00015bec  T _select
X
XBingo!  I also found <sys/select.h> (which has a comment about
Xthe select(2) system call. :-) ).
X
XWhen a system call is made in a C program on a Unix system (eg
Xopen(2)), it actually links in a file from libc.a (/lib/libc.a) (in
Xthis case `open.o') written in assembly that loads a register with a
Xsystem call number and causes an exception to occur.  The `trap'
Xinstruction is used on the 68000, on a vax it's `chmk', and on a 370
Xit's `svc'.  Control is transfered to the kernel which (in the case of
Xthis particular exception) will index the register into a table
X(called the sysent table) to get the address of the actual routine in
Xkernel memory to call (_open).
X
XAt least under SCO XENIX this algorithm is modified somewhat.
X
XWhen a system call is made in a C program on a SCO XENIX system (eg
Xopen(S)), it links in a file from libc.a (/lib/386/Slibc.a) (in this
Xcase `open.o') written in assembly that loads the register `eax' with
Xa system call number and jumps to 7:0 which (a guess) is mapped to an
Xinstruction that switches into supervisory mode and jumps to the
Xroutine ioint (??) in the kernel address space.  The interrupt routine
Xhands the system call number (along with the user given arguments) to
X_trap with figures out what to sysent table to use (there are a few
Xunder SCO XENIX) and does the right thing.
X
XThe _open routine (in libc.a's open.o) would probably look something
Xlike:
X
X;
X; open - open a file for reading or writing
X;
X
X	title	open
X
X	.386
X
XSYSNUM	equ 	5			; open's system call number is `5'.
Xextrn	_errno:dword
X
Xpublic  _open
X
X_TEXT	segment  dword use32 public 'CODE'
X	assume   cs: _TEXT
X_open	proc near
X	mov	eax, SYSNUM		; Get system call number.
X
X	;
X	; I don't even pretend to understand masm syntax.  I tried
X	; the following line (and variations) without any success.
X	;
X
X;	call    far 7:0			; Switch to kernel and call SYSNUM.
X
X	;
X	; Don't laugh, it works.
X	;
X
X	db 9ah
X	dw 0,0
X	dw 7
X
X	jb	short _cerror		; below == error.
X
X	xor	eax, eax		; zero return value (no error).
X	ret				; done.
X
X_cerror:
X	mov	_errno, eax		; Save error code in _errno.
X	mov	eax, -1			; Return -1 (as error).
X	ret				; done.
X
X_open	endp
X
X_TEXT	ends
X
X	end
X
XUnder SCO XENIX the sysent table (struct sysent in <sys/systm.h>) looks
Xsomething like:
X
Xstruct sysent
X{
X    unsigned char  sy_ret;	 /* Type of return value (int, void ...) */
X    unsigned char  sy_arg386;	 /* Number of 386 words args on stack */
X    unsigned char  sy_nlarg286;	 /* # of 286 large model word args on stack */
X    unsigned char  sy_nmarg286;	 /* 286 Small Middle: max # of args */
X    unsigned	   sy_argmask;	 /* Argument types on stack. */
X	     int   (*sy_call)(); /* System call address in kernel */
X}
X
Xsy_ret is the type return of the value this system call returns.  `0'
Xseems to be INT and `6' is probably void.
X
Xsy_arg386 is the number of words the arguments for this system call
Xtake on the stack.
X
Xsy_nlarg286 and sy_nmarg286 are similar to sy_arg386 but used for
Xdoing 286 stuff.  I don't plan on mentioning the 286 stuff in this
Xarticle that much, it just isn't interesting to me.
X
Xsy_argmask is the type of args on the stack using the following table:
X
XNUM | SYMBOL  | 386 | 286L | EXPLANATION
X 0  |         |     |      | Arg not used.
X 1  | DATAP   |	 2  |  1   | Arg is a data pointer; seg + address
X 2  | TEXTP   |	 2  |  1   | Arg is a text pointer; seg + address
X 3  | CONST   |	 1  |  1   | Arg is an int-sized constant 
X 4  | UCONST  |	 1  |  1   | Arg is an unsigned int-sized constant
X 5  | LCONST  |  1  |  1   | Arg is a long-sized constant
X 6  | FDATAP  |	 1  |  1   | Arg is FAR data pointer.
X 7  | SODATAP |  2  |      | 386: 32-bit offset.
X    |         |     |  1   | 286: low word is 16 bit data pointer offset,
X    |         |	    |      |	  high word is 16 bit selector.
X 8  | SOTEXTP |  2  |      | 386: 32-bit offset.
X    |         |     |  1   | 286: low word is 16 bit text pointer offset,
X    |         |	    |      |	  high word is 16 bit selector.
X
XEach nybble in sy_argmask represents one argument passed to the system
Xcall.  Bits 0-3 represent arg one; 4-7 arg two; 8-12 arg three; etc.
XA total of eight arguments (4 bits times 8 args = 32 bits in an int)
Xcan be passed to a function (although MASK, a macro used to make
Xsysent's sy_argmask field is limited to six arguments).
X
XNUM is the number (put in each nybble) represented by the SYMBOL (in
X<sys/systm.h>) that corresponds to the arg type EXPLANATION and takes
X[386|286] (depending on the model you are using) words on the user
Xstack.
X
XSo, for the open() system call: sy_argmask is 0x00000331 and sy_arg386
Xis 0x04.
X
X	open(char *path, int oflag, int mode);
X             ^^^^^^      ^^^        ^^^
X             DATAP       CONST      CONST
X
Xsy_call is the pointer to the function in kernel memory that should
Xhandle this system call request.
X
XThe sysent table on my system looks something like:
X
XSyscal Num | ret| 386| L  | SM |    Arg Types    | System Call 
Xsysent:
X    00     | 00 | 00 | 00 | 03 | 0 0 0 0 0 0 0 0 | _nosys
X    01     | 00 | 02 | 01 | 05 | 0 0 0 0 0 0 0 1 | _rexit
X    02     | 00 | 00 | 00 | 03 | 0 0 0 0 0 0 0 0 | _fork	
X    03     | 00 | 04 | 03 | 03 | 0 0 0 0 0 4 1 3 | _read	
X    04     | 00 | 04 | 03 | 03 | 0 0 0 0 0 4 1 3 | _write
X    05     | 00 | 04 | 03 | 03 | 0 0 0 0 0 3 3 1 | _open	
X    06     | 00 | 01 | 01 | 03 | 0 0 0 0 0 0 0 3 | _close
X    07     | 00 | 00 | 00 | 03 | 0 0 0 0 0 0 0 0 | _wait	
X    08     | 00 | 03 | 02 | 03 | 0 0 0 0 0 0 3 1 | _creat	
X    09     | 00 | 04 | 02 | 03 | 0 0 0 0 0 0 1 1 | _link	
X    0a     | 00 | 02 | 01 | 03 | 0 0 0 0 0 0 0 1 | _unlink	
X    0b     | 00 | 04 | 02 | 03 | 0 0 0 0 0 0 1 1 | _exec
X    0c     | 00 | 02 | 01 | 03 | 0 0 0 0 0 0 0 1 | _chdir	
X    0d     | 00 | 00 | 00 | 05 | 0 0 0 0 0 0 0 0 | _gtime
X    0e     | 00 | 04 | 03 | 03 | 0 0 0 0 0 3 3 1 | _mknod       
X    0f     | 00 | 03 | 02 | 03 | 0 0 0 0 0 0 3 1 | _chmod       
X    10     | 00 | 04 | 03 | 03 | 0 0 0 0 0 3 3 1 | _chown       
X    11     | 00 | 02 | 01 | 03 | 0 0 0 0 0 0 0 7 | _brk
X    12     | 00 | 04 | 02 | 03 | 0 0 0 0 0 0 1 1 | _stat
X    13     | 00 | 04 | 03 | 05 | 0 0 0 0 0 3 5 3 | _seek 
X    14     | 00 | 00 | 00 | 03 | 0 0 0 0 0 0 0 0 | _getpid      
X    15     | 00 | 05 | 03 | 03 | 0 0 0 0 0 3 1 1 | _smount      
X    16     | 00 | 02 | 01 | 03 | 0 0 0 0 0 0 0 1 | _sumount     
X    17     | 00 | 01 | 01 | 03 | 0 0 0 0 0 0 0 4 | _setuid      
X    18     | 00 | 00 | 00 | 03 | 0 0 0 0 0 0 0 0 | _getuid      
X    19     | 00 | 02 | 01 | 03 | 0 0 0 0 0 0 0 5 | _stime       
X    1a     | 00 | 05 | 04 | 03 | 0 0 0 0 3 1 3 3 | _ptrace      
X    1b     | 00 | 01 | 01 | 04 | 0 0 0 0 0 0 0 3 | _alarm       
X    1c     | 00 | 03 | 02 | 03 | 0 0 0 0 0 0 1 3 | _fstat       
X    1d     | 00 | 00 | 00 | 03 | 0 0 0 0 0 0 0 0 | _pause       
X    1e     | 00 | 04 | 02 | 03 | 0 0 0 0 0 0 1 1 | _utime       
X    1f     | 00 | 03 | 02 | 03 | 0 0 0 0 0 0 1 3 | _stty        
X    20     | 00 | 03 | 02 | 03 | 0 0 0 0 0 0 1 3 | _gtty        
X    21     | 00 | 03 | 02 | 03 | 0 0 0 0 0 0 3 1 | _saccess     
X    22     | 00 | 01 | 01 | 03 | 0 0 0 0 0 0 0 3 | _nice        
X    23     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 |
X    24     | 00 | 00 | 00 | 03 | 0 0 0 0 0 0 0 0 | _sync        
X    25     | 00 | 02 | 02 | 03 | 0 0 0 0 0 0 3 3 | _kill        
X    26     | 00 | 00 | 01 | 00 | 0 0 0 0 0 0 0 0 |              
X    27     | 00 | 00 | 02 | 00 | 0 0 0 0 0 0 0 0 |              
X    28     | 00 | 00 | 03 | 00 | 0 0 0 0 0 0 0 0 |              
X    29     | 00 | 02 | 02 | 03 | 0 0 0 0 0 0 3 3 | _dup         
X    2a     | 00 | 00 | 00 | 03 | 0 0 0 0 0 0 0 0 | _pipe        
X    2b     | 00 | 02 | 01 | 05 | 0 0 0 0 0 0 0 1 | _times       
X    2c     | 06 | 08 | 05 | 03 | 0 0 0 1 4 8 4 1 | _profil      
X    2d     | 00 | 01 | 01 | 03 | 0 0 0 0 0 0 0 3 | _lock        
X    2e     | 00 | 01 | 01 | 03 | 0 0 0 0 0 0 0 4 | _setgid      
X    2f     | 00 | 00 | 00 | 03 | 0 0 0 0 0 0 0 0 | _getgid      
X    30     | 00 | 03 | 02 | 02 | 0 0 0 0 0 0 2 3 | _ssig        
X    31     | 00 | 00 | 01 | 03 | 0 0 0 0 0 0 0 3 | _msgsys      
X    32     | 06 | 07 | 04 | 03 | 0 0 0 0 5 5 1 3 | _sysi86      
X    33     | 00 | 02 | 01 | 03 | 0 0 0 0 0 0 0 1 | _sysacct     
X    34     | 00 | 00 | 01 | 06 | 0 0 0 0 0 0 0 3 | _shmsys      
X    35     | 00 | 00 | 01 | 03 | 0 0 0 0 0 0 0 3 | _semsys      
X    36     | 00 | 04 | 03 | 03 | 0 0 0 0 0 7 3 3 | _ioctl       
X    37     | 00 | 00 | 04 | 00 | 0 0 0 0 0 0 0 0 |              
X    38     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    39     | 00 | 00 | 05 | 00 | 0 0 0 0 0 0 0 0 |              
X    3a     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    3b     | 00 | 06 | 03 | 03 | 0 0 0 0 0 1 1 1 | _exece       
X    3c     | 00 | 01 | 01 | 03 | 0 0 0 0 0 0 0 3 | _umask       
X    3d     | 00 | 02 | 01 | 03 | 0 0 0 0 0 0 0 1 | _chroot      
X    3e     | 00 | 00 | 06 | 00 | 0 0 0 0 0 0 0 0 |              
X    3f     | 00 | 00 | 07 | 00 | 0 0 0 0 0 0 0 0 |              
X    40     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    41     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    42     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    43     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    44     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    45     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    46     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    47     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    48     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    49     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    4a     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    4b     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    4c     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    4d     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    4e     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    4f     | 00 | 00 | 08 | 00 | 0 0 0 0 0 0 0 0 |              
X    50     | 00 | 00 | 09 | 00 | 0 0 0 0 0 0 0 0 |              
X    51     | 00 | 04 | 03 | 03 | 0 0 0 0 0 4 1 3 | _getdents    
X    52     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    53     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    54     | 00 | 00 | 0a | 00 | 0 0 0 0 0 0 0 0 |              
X    55     | 00 | 06 | 04 | 03 | 0 0 0 0 3 1 1 3 | _getmsg      
X    56     | 00 | 06 | 04 | 03 | 0 0 0 0 3 1 1 3 | _putmsg      
X    57     | 00 | 05 | 03 | 03 | 0 0 0 0 0 3 5 1 | _poll        
X    58     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    59     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    5a     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    5b     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    5c     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    5d     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    5e     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    5f     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    60     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    61     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    62     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    63     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys       
X    64     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys
X    65     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    66     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    67     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    68     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    69     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    6a     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    6b     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    6c     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    6d     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    6e     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    6f     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    70     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    71     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    72     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    73     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    74     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    75     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    76     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    77     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    78     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    79     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    7a     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    7b     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    7c     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    7d     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    7e     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys      
X    7f     | 00 | 05 | 05 | 0a | 0 0 0 0 0 0 0 0 | _clocal     
X
X_v7sysent:
X
X    00     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 |
X    01     | 00 | 02 | 01 | 03 | 0 0 0 0 0 0 0 1 | _ftime   
X    02     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys   
X    03     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nullsys 
X    04     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys   
X    05     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys   
X    06     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys   
X    07     | 00 | 05 | 05 | 0a | 0 0 0 0 0 0 0 0 | _clocal  
X    08     | 00 | 00 | 00 | 08 | 0 0 0 0 0 0 0 0 | _cxenix  
X    09     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys   
X    0a     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys   
X    0b     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys   
X    
X_s3sysent:
X    01     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 |
X    02     | 00 | 06 | 04 | 03 | 0 0 0 0 3 3 1 1 | _statfs   
X    03     | 00 | 05 | 04 | 03 | 0 0 0 0 3 3 1 3 | _fstatfs  
X    04     | 00 | 01 | 01 | 03 | 0 0 0 0 0 0 0 3 | _setpgrp  
X    05     | 00 | 00 | 00 | 08 | 0 0 0 0 0 0 0 0 | _cxenix   
X    06     | 00 | 04 | 03 | 03 | 0 0 0 0 0 1 3 3 | _uadmin   
X    07     | 00 | 00 | 00 | 09 | 0 0 0 0 0 0 0 0 | _utssys   
X    08     | 00 | 03 | 03 | 03 | 0 0 0 0 0 3 3 3 | _fcntl    
X    09     | 00 | 03 | 02 | 05 | 0 0 0 0 0 0 5 3 | _ulimit   
X    0a     | 00 | 00 | 01 | 03 | 0 0 0 0 0 0 0 1 | _rmdir    
X    0b     | 00 | 00 | 02 | 03 | 0 0 0 0 0 0 3 1 | _mkdir    
X    0c     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys    
X    
X_svidsysent:
X
X    01     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 |
X    02     | 00 | 06 | 04 | 03 | 0 0 0 0 3 3 1 1 | _statfs  
X    03     | 00 | 05 | 04 | 03 | 0 0 0 0 3 3 1 3 | _fstatfs 
X    04     | 00 | 00 | 01 | 03 | 0 0 0 0 0 0 0 3 | _setpgrp 
X    05     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys   
X    06     | 00 | 00 | 03 | 03 | 0 0 0 0 0 1 3 3 | _uadmin  
X    07     | 00 | 00 | 00 | 09 | 0 0 0 0 0 0 0 0 | _utssys  
X    08     | 00 | 00 | 03 | 03 | 0 0 0 0 0 3 3 3 | _fcntl   
X    09     | 00 | 00 | 02 | 05 | 0 0 0 0 0 0 5 3 | _ulimit  
X    0a     | 00 | 00 | 01 | 03 | 0 0 0 0 0 0 0 1 | _rmdir   
X    0b     | 00 | 00 | 02 | 03 | 0 0 0 0 0 0 3 1 | _mkdir   
X    0c     | 00 | 00 | 03 | 03 | 0 0 0 0 0 0 0 0 | _nosys   
X
X_clentry: used for oem CLOCAL routines.  Empty on my system.
X
X_cxentry: used for SCO added stuff.
X
X    00     | 00 | 05 | 03 | 03 | 0 0 0 0 0 4 7 1 | _shutdown
X    01     | 00 | 04 | 03 | 03 | 0 0 0 0 0 7 3 3 | _locking
X    02     | 00 | 03 | 02 | 03 | 0 0 0 0 0 0 3 1 | _creatsem
X    03     | 00 | 02 | 01 | 03 | 0 0 0 0 0 0 0 1 | _opensem
X    04     | 00 | 01 | 01 | 03 | 0 0 0 0 0 0 0 3 | _sigsem
X    05     | 00 | 01 | 01 | 03 | 0 0 0 0 0 0 0 3 | _waitsem
X    06     | 00 | 01 | 01 | 03 | 0 0 0 0 0 0 0 3 | _nbwaitsem
X    07     | 00 | 01 | 01 | 03 | 0 0 0 0 0 0 0 3 | _rdchk
X    08     | 00 | 01 | 01 | 03 | 0 0 0 0 0 0 0 4 | _stkgrow
X    09     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys
X    0a     | 00 | 03 | 02 | 03 | 0 0 0 0 0 0 5 3 | _chsize
X    0b     | 00 | 02 | 01 | 03 | 0 0 0 0 0 0 0 1 | _ftime
X    0c     | 00 | 02 | 01 | 05 | 0 0 0 0 0 0 0 5 | _nap
X    0d     | 00 | 05 | 04 | 01 | 0 0 0 0 3 4 3 1 | _sdget
X    0e     | 00 | 02 | 01 | 03 | 0 0 0 0 0 0 0 7 | _sdfree
X    0f     | 00 | 03 | 02 | 03 | 0 0 0 0 0 0 3 7 | _sdenter
X    10     | 00 | 02 | 01 | 03 | 0 0 0 0 0 0 0 7 | _sdleave
X    11     | 00 | 02 | 01 | 03 | 0 0 0 0 0 0 0 7 | _sdgetv
X    12     | 00 | 03 | 02 | 03 | 0 0 0 0 0 0 3 7 | _sdwaitv
X    13     | 00 | 05 | 03 | 01 | 0 0 0 0 0 7 5 3 | _brkctl
X    14     | 00 | 00 | 00 | 00 | 0 0 0 0 0 0 0 0 | _nosys
X    15     | 00 | 03 | 02 | 03 | 0 0 0 0 0 0 1 3 | _nfs_sys
X    16     | 00 | 04 | 03 | 03 | 0 0 0 0 0 1 3 3 | _msgctl
SHAR_EOF
true || echo 'restore of xsel386/select.txt failed'
fi
echo 'End of ecu320 part 34'
echo 'File xsel386/select.txt is continued in part 35'
echo 35 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
