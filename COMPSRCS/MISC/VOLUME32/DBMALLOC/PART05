Newsgroups: comp.sources.misc
From: cpcahil@vti.com (Conor P. Cahill)
Subject:  v32i010:  dbmalloc - Debug Malloc Library PL14, Part05/10
Message-ID: <1992Sep4.152142.13264@sparky.imd.sterling.com>
X-Md4-Signature: 16ca4722707e9b9544c6ae8d9c6122dc
Date: Fri, 4 Sep 1992 15:21:42 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: cpcahil@vti.com (Conor P. Cahill)
Posting-number: Volume 32, Issue 10
Archive-name: dbmalloc/part05
Environment: C, UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 10)."
# Contents:  malloc.3 mallocin.h
# Wrapped by cpcahil@virtech on Thu Sep  3 18:39:19 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'malloc.3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'malloc.3'\"
else
echo shar: Extracting \"'malloc.3'\" \(42916 characters\)
sed "s/^X//" >'malloc.3' <<'END_OF_FILE'
X.TH DEBUG_MALLOC 3 "VTI" "" "1.11"
X.ds ]T 
X'\"/*
X'\" * (c) Copyright 1990, 1991, 1992 Conor P. Cahill (cpcahil@virtech.vti.com).
X'\" *
X'\" * This software may be distributed freely as long as the following
X'\" * conditions are met:
X'\" *
X'\" * 		* the distribution, or any derivative thereof, may not be
X'\" *		  included as part of a commercial product
X'\" *		* full source code is provided including this copyright
X'\" *		* there is no charge for the software itself (there may be
X'\" *		  a minimal charge for the copying or distribution effort)
X'\" *		* this copyright notice is not modified or removed from any
X'\" *		  source file
X'\" */
X'\" 
X'\" $Id: malloc.3,v 1.28 1992/08/22 16:27:13 cpcahil Exp $
X'\" 
X'\" eX macro -  this macro is used to set up code/picture examples.  It changes
X'\"             the point size & type of font, indents the example 1/2 inch,
X'\"		and turns off fill mode.  To use it just place a .eX before and
X'\"		after your example
X.de eX
X.ie \\n(eX>0 \{\
X.nr eX 0
X.if t .ft
X.fi
X.vs
X.ps
X.in
X.sp \}
X.el \{\
X.nr eX 1
X.br
X.ne 5
X.sp
X.ie \\n(.$>0 .in +\\$1
X.el .in +.5i
X.ie \\n(.$=2 .ps -\\$2
X.el .ps -2
X.ie \\n(.$=2 .vs -\\$2
X.el .vs -2
X.if t .ft CW
X.nf \}
X..
X.nr eX 0
X'\" 
X'\" fake set of VL LI and LE macros for man pages.  This set does handle nested
X'\" calls, but does absolutely NO error checking (so you better do it right).
X'\" 
X.de VL
X.br
X.ie t .nr VL 0\\$1
X.el .nr VL 0\\$1*2
X.ds VS \\$1 \\*(VS
X.in +\\n(VL
X.if t .in +.25i
X..
X.de LI
X.br
X.ti -\\n(VL
X.nr Vw \\n(VLm-\w'\\$1'
X.if \w'\\$1' \&\\$1\h'\\n(Vwu'\&\\c
X..
X.de LE
X.br
X.Le \\*(VS 
X..
X.de Le
X.in -\\n(VL
X.if t .in -.25i
X.ie t .nr VL \\$2
X.el .nr VL \\$2*2
X.ds VS \\$2 \\$3 \\$4 \\$5 \\$6 \\$7
X..
X.ds VS
X.nr VL 0
X.de MP
X.ie t .sp \\n(PDu
X.el .sp
X..
X.de P
X.br
X.ne 4
X.sp
X..
X.SH NAME
Xdbmalloc \- debugging malloc library
X.SH SYNOPSIS
X.nf
X\fB#include <malloc.h>
X.MP
Xint malloc_chain_check(flag);
Xint flag;
X.MP
Xvoid malloc_dump(fd);
Xint fd;
X.MP
Xvoid malloc_list(fd,histid1,histid2);
Xint fd;
Xunsigned long histid1, histid2;
X.MP
Xunsigned long malloc_inuse(histidptr);
Xunsigned long * histidptr;
X.MP
Xvoid malloc_mark(ptr);
Xchar	* ptr;
X.MP
Xint dbmallopt(cmd,val);
Xint cmd; 
Xunion dbmalloptarg val;
X.MP
Xvoid malloc_abort();
X.MP
Xvoid malloc_enter(func);
Xchar * func;
X.MP
Xvoid malloc_leave(func);
Xchar * func;\fP
X.fi
X.SH DESCRIPTION
XThis malloc library is a replacement for the standard library to be used
Xduring software development/debugging.  See the standard malloc(3) pages
Xfor more information on the use of the following functions:
X.MP
X.nf
X.in +.5i
X\fBcalloc\fP(), \fBcfree\fP(), \fBfree\fP(), \fBmalloc\fP(), \fBrealloc\fP()
X.in -.5i
X.fi
X.MP
XThis library differs from the standard malloc library in the
Xfollowing ways:
X.P
X1. Each malloc segment contains a magic number so that free can 
Xverify that the pointer passed points to a valid malloc segment.
X.P
X2. Each malloc segment is filled with a non-zero pattern so that code that
Xdepends upon malloc segments being null will fail.
X.P
X.ne 5
X3. The size of each segment will be at least 1 byte larger than requested
Xand the extra bytes will be filled with a non-zero pattern.  When free is
Xcalled, it will verify that you did not go beyond the number of bytes 
Xyou asked for.
X.P
X4. When a segment is freed, it will be filled with a different non-zero pattern
Xto ensure that the program doesn't depend upon the use of already freed data.
X.P
X.ne 5
X5. Whenever any of the string or memory functions (str*, b*, mem*) are 
Xcalled with a pointer that is within the malloc arena,  the operation is
Xchecked to verify that it does not overrun the malloced segment.  A failure
Xof this check is considered a "warning level error" (described later) and
Xis handled accordingly.
X.P
X6. Run time checking can include verification of the malloc chain at each
Xand every call to one of the malloc functions or manually by calling the
Xmalloc_chain_check function.
X.P
X7. Extensive support for tracking memory leaks is provided.
X.P
X.br
X.ne 15
XWhen a problem is found, the following error message is displayed:
X.eX
XMALLOC Warning from funcname() (called from filename.c line ###):
XWarning message goes here
X.eX
X\fBfuncname\fP is the name of the function that has found the problem
Xand will usually be an entry point into the library.  The information
Xthat identifies where the function is called from will only be 
Xavailable if the source module was compiled with the \fBmalloc.h\fP
Xfile included.
X.P
XIf the error is caused by a problem in the malloc chain and the offending
Xchain element can be identified, the following information is also
Xdisplayed (NOTE: this is just a guess by the software, it may not
Xbe the actual culprit):
X.eX
XThis error is *probably* associated with the following allocation:
X
X   A call to malloc for 33 bytes in program.c on line 834.
X   This was the 172nd call to malloc.
X.eX
X.br
X.ne 15
XThis example assumes that \fBprogram.c\fP included the debugging 
Xlibrary \fBmalloc.h\fP file.  If not, the identification information
Xwill be as follows:
X.eX
XThis error is *probably* associated with the following allocation:
X
X   A call to malloc for 33 bytes in an unknown file.
X   This was the 172nd call to malloc.
X.eX
XThe identification of which call to malloc is associated with the 
Xproblem is helpful in that it gives you the information necessary
Xto set the breakpoint on the allocation function for that particular
Xinvocation (breakpoints usually can have counters associated with
Xthem).  The counters for the three primary allocation entry points (malloc,
Xcalloc, and realloc) are managed separately.
X.P
X.br
X.ne 5
XNOTE 1: if you want to set a breakpoint to capture this invocation
Xof malloc, the actual function that is being called is \fBdebug_malloc\fP
X(or \fBdebug_realloc\fP for \fBrealloc\fP and \fBdebug_calloc\fP for
X\fBcalloc\fP) and that is where the breakpoint should be set.
X.P
X.br
X.ne 19
XNOTE 2: Since the software is guessing at the offending malloc
Xchain segment, it is possible that one of the nearby segments 
Xis actually the culprit.  If the environment variable \s-2MALLOC_SHOW_LINKS\s+2
Xis set, both the segment preceding and the segment following the accused
Xsegment will also be identified.  The following is a sample output:
X.eX
XThis error is *probably* associated with the following allocation:
X
X    A call to malloc for 33 bytes in an unknown file.
X    This was the 172nd call to malloc.
X
X    The malloc chain element prior to the suspect allocation is from:
X
X    A call to calloc for 512 bytes in main.c line 16.
X    This was the 4th call to calloc. 
X    This block was freed on the 2nd call to free()
X    in main.c on line 51.
X 
X    The malloc chain element following the suspect allocation is from: 
X
X    A call to realloc for 4096 bytes in func.c line 376.
X    This was the 1st call to realloc.
X.eX
X.br
X.ne 15
XOnce the error message has been displayed, the software will then 
Xdetermine how to handle the error.  This handling will be based upon
Xthe type of error level (warning or fatal) and the error handling in effect
Xfor that error level (as specified by calls to mallopt or via environment
Xvariables).  The coding for the error handling is as follows:
X.MP
X.VL 3
X.LI "\0\00"
Xcontinue operations
X.LI "\0\01"
Xdrop core and exit
X.LI "\0\02"
Xjust exit
X.LI "\0\03"
Xdrop core, but continue executing.  Core files will
Xbe placed into core.[PID].[counter] i.e: core.00123.001
X.LI "128"
Xdump malloc chain and continue
X.LI "129"
Xdump malloc chain, dump core, and exit
X.LI "130"
Xdump malloc chain, exit
X.LI "131"
Xdump malloc chain, dump core, continue processing
X.LE
X.P
X\fBdbmallopt\fP() is used to set the malloc debugging options. The
Xfollowing options can be set:
X.MP
X.VL 10
X.LI "\s-2MALLOC_WARN\s+2"
Xset the error handling for warning level errors.  \fBval.i\fP is
Xan integer that can contain any one of the following values:
X.MP
X.VL 10
X.LI "\s-2M_HANDLE_IGNORE\s+2"
Xignore error (just display warning message and continue processing)
X.LI "\s-2M_HANDLE_ABORT\s+2"
Xdrop core and exit
X.LI "\s-2M_HANDLE_EXIT\s+2"
Xjust exit (no core drop)
X.LI "\s-2M_HANDLE_CORE\s+2"
Xdrop core, but keep on going
X.LE
X.MP
XIn addition, \s-2M_HANDLE_DUMP\s+2 may be or'd in to cause a dump
Xof the current malloc chain.
X.MP
XThe default action for \s-2MALLOC_WARN\s+2 is \s-2M_HANDLE_IGNORE\s+2.
X.MP
X.LI "\s-2MALLOC_FATAL\s+2"
Xset the error handling for fatal level errors.  \fBval.i\fP is
Xequivalent to \fBval.i\fP for \s-2MALLOC_WARN\s+2.
X.MP
XThe default action for \s-2MALLOC_FATAL\s+2 is \s-2M_HANDLE_ABORT\s+2.
X.MP
X.LI "\s-2MALLOC_ERRFILE\s+2"
Xset the destination for malloc error messages.  \fBval.str\fP
Xis a pointer to a character string containing the name of the file to be used
Xfor error messages.  Note that error messages are \s-1APPENDED\s+1 to this
Xfile, so existing error messages will not be removed.
X.MP
XIf \s-2MALLOC_ERRFILE\s+2 is not set, all error messages will be sent
Xto \fBstderr\fP.
X.MP
X.ne 3
X.LI "\s-2MALLOC_CKCHAIN\s+2"
Xset the malloc chain checking flag.  If \fBval.i\fP is
Xnon-zero, chain checking at every call to malloc is turned on. The 
Xdefault behavior is to not check the chain at each call to malloc because
Xof performance issues (the library is considerably slower when this 
Xfunction is enabled).
X.MP
X.ne 10
X.LI "\s-2MALLOC_FREEMARK\s+2"
Xsets the behavior of freeing of marked areas.  By default, a free of a 
Xmarked segment generates a warning.  If \fBval.i\fP is zero, warnings will
Xnot be generated.
X.MP
X.ne 10
X.LI "\s-2MALLOC_FILLAREA\s+2"
Xset the malloc fill area flag.  \fBval.i\fP specifies the malloc filling
Xmode to be used.   There are four modes: 0, 1, 2 and 3.  Mode 0 disables
Xall filling and checking of filled areas (thereby reducing the effectiveness
Xof the library).  Mode 1 enables the filling of boundary areas before and
Xafter the allocation areas which are used to check for writing before
Xor after the pointer.  Mode 2 includes mode 1 and adds the filling of
Xmalloced regions with a specified fill pattern so that a program does not
Xdepend upon malloced regions to be filled with zeros.  Mode 3 includes
Xall of mode 2 and adds the filling of free'd regions so that an attempt
Xto used a freed data area will result in an error.
X.MP
XAs far as performance is concerned, mode 0 will be the fastest mode, 
Xwhile (somewhat unexpectedly) mode 3 is the next "fastest" mode 
Xwith mode 1 bring up the tail end. 
X.MP
XThe default behavior for \s-2MALLOC_FILLAREA\s+2 is mode 3.
X.MP
X.LI "\s-2MALLOC_LOWFRAG\s+2"
Xset the malloc allocation fragmentation handling level.  By default, malloc
Xuses a first fit algorithm for new allocations.  Under certain allocation
Xscenarios, this can lead to significant memory fragmentation because of
Xthe fact that little allocations can break big blocks up.
X.MP
XIf \fBval.i\fP is non-zero, malloc uses a best fit algorithm which will reduce
Xfragmentation.  This mechanism, while using less memory, is slower because
Xthe entire free list is checked instead of just checking until we find a
Xsegment that is at least big enough.  Normally you will not need to set
Xthis variable.
X.MP
X.LI "\s-2MALLOC_CKDATA\s+2"
Xenable/disable the checking of pointers passed to the memory (mem*,b*) and 
Xstring (str*) functions.  This can be used to startup the code with
Xchecking disabled (when you know the startup code is functioning correctly)
Xand then turn it on later when you get into the area of the code that is 
Xin question.
X.MP
Xif \fBval.i\fP is non-zero, pointer checking is enabled (which is the default
Xmode).
X.MP
X.LI "\s-2MALLOC_REUSE\s+2"
Xenable/disable the reuse of freed segments.  This option can be used to 
Xhelp identify where a freed pointer is being re-used, or where it is being
Xfreed a second time, since the location where it was freed is also kept.
X.MP
XIt should be noted that the memory requirements for a program will typically
Xincrease significantly if this option is used.
X.MP
Xif \fBval.i\fP is zero, freed segments are not reused for subsequent
Xallocations.   If non-zero, freed segments can be reused.  If freed segments
Xare not re-used, you might want to disable filling of freed segments (see
Xthe \s-2MALLOC_FILLAREA\s+2 discussions) so that you can see the data in the
Xsegment - this would be fill mode 2 or below.
X.LE
X.MP
X.ne 10
XFor example, to set up the session to generate a core file for
Xevery malloc warning, to drop core and exit on a malloc fatal, and 
Xto log all messages to the file "malloc_log" do the following:
X.eX
X#include <malloc.h>
Xunion dbmalloptarg  m;
X
Xm.i = M_HANDLE_CORE | M_HANDLE_DUMP;
Xdbmallopt(MALLOC_WARN,m);
X
Xm.i = M_HANDLE_ABORT;
Xdbmallopt(MALLOC_FATAL,m);
X
Xm.str = "malloc_log";
Xdbmallopt(MALLOC_ERRFILE,m);
X.eX
X\fBdbmallopt\fP() can be used to set/alter the debugging options at any
Xtime (i.e. you may want to turn on chain-checking after the program startup if
Xthe program startup does a lot of allocations which are known to be OK).
X.P
X.ne 5
X\fBmalloc_chain_check\fP() will check the status of the malloc arena.
XIf \fBflag\fP is non-zero, an error found in the chain will cause a 
Xfatal error.  \fBmalloc_chain_check\fP() returns zero when there are no
Xproblems found in the malloc chain, non-zero otherwise.
X.P
X.ne 5
X\fBmalloc_dump\fP() will dump a list of all in-use malloc segments 
Xand the first few bytes of each segment.  If the environment variable
X\s-1MALLOC_DETAIL\s+1 is set to a non-zero integer, all segments (including
Xthose that have been freed) are listed and additional internal information
Xis displayed.  \fBfd\fP is the file descriptor to write the data to.
X.P
X.ne 6
X\fBmalloc_list\fP() will dump a list in the same format as \fBmalloc_dump\fP but
Xonly the items that are still in use and which have been allocated within
Xthe malloc history id range specified by \fBhistid1\fP and
X\fBhistid2\fP, inclusive.  The \fBhistid\fPs are obtained from calls
Xto \fBmalloc_inuse\fP(). This is especially useful in tracking down memory
Xleaks.  \fBfd\fP is the file descriptor to write the data to.
X.P
X.ne 6
X\fBmalloc_inuse\fP() returns the amount of malloc data that is currently
Xin use (in bytes).  If \fBhistidptr\fP is not NULL, it is taken to be a pointer
Xto a place to store the current malloc history id which can be used later
Xwhen \fBmalloc_list\fP is called to list items that are still in use.
X.P
X.ne 10
XThe following example shows the typical use of the \fBmalloc_inuse\fP and
X\fBmalloc_list\fP functions in tracking down memory leaks:
X.eX
Xunsigned long	histid1, histid2, orig_size, current_size;
X
Xorig_size = malloc_inuse(&histid1);
X
X/* ..... go do lots of stuff ...... */
X
Xcurrent_size = malloc_inuse(&histid2);
X
Xif( current_size != orig_size )
X{
X	malloc_list(2,histid1,histid2);
X}
X.eX
X\fBmalloc_mark\fP() marks a segment as a non-leak.  Segments that are marked
Xare not counted or listed when dealing with memory leaks.  This is designed
Xto be used on pointers that remain around forever and shouldn't be considered
Xto be a leak (in order to decrease the amount of entries in the leak lists)
X.P
X\fBmalloc_abort\fP() causes the current program to drop core and exit.  This
Xfunction simply calls \fBabort\fP() to do its dirty work and is here solely 
Xfor the purpose of allowing the programmer to substitute thier own abort
Xroutine to handle fatal errors.  If a substitute routine is used, it must not
Xreturn to the caller or else the program will use the \fBabort\fP() system
Xcall to cause the program to stop.
X.P
X\fBmalloc_enter\fP() and \fBmalloc_leave\fP() provide a rudimentary mechanism
Xto track the calling stack that was in place when the allocation was made.
XIn order to use this feature, the enter function should be called upon
Xentry to a function, while the leave function is called when you exit
Xfrom the function.  In order to be accurate, the two functions must be 
Xused in conjunction with each other and a missing call will result in
Xan error generated by the library (if it is detected).
X.P
XNOTE: the argument to either of these functions \fBmust\fP be a constant
Xcharacter string or a static data area.  This is because the stack mechanism
Xdoes not maintain it's own copy of these strings, it just records pointers
Xto the strings and if the strings are on the stack, they will go away.
XTypically the functions would be used with "funcname" as the argument and
Xthis will avoid any problems.
X.P
XThe stack is listed on the dump and/or list reports and on an error 
Xmessage for a segment that has already been freed.
X.P
XIf these functions have been used, error messages will include
Xthe stack information when the identity of the error is 
Xdisplayed.  For example:
X.eX
XThis error is *probably* associated with the following allocation:
X
X    A call to malloc for 1 bytes in teststack.c on line 75.
X    This was the 13th call to malloc.
X    Stack from where allocated:
X     -> sub3() in teststack.c(73)
X     -> sub2() in teststack.c(59)
X     -> main() in teststack.c(23)
X
X.eX
X.br
X.br
X.ne 20
X.SH "USAGE"
XThe library can be used in several modes, each increasingly intrusive (i.e. 
Xrequiring changes to be made to the build process and/or source code).  However,
Xthe extra cost of a little intrusiveness is repaid in much better problem
Xidentification.  Each mode is built upon the previous modes and therefore
Xrequires the changes and/or commands specified in the lower modes.
X.P
X.ne 10
X\fBMODE 1 - library substitution\fP
X.P
XThe simplest use is to just link the object module with the \fBlibdbmalloc.a\fP.
XBe sure to have this library before the C library (\fBlibc.a\fP) on the
Xlink command (this is automatic if you use \fBcc\fP to link and specify the 
Xdebug library without specifying the C library).
X.P
XThis mode links in all of the debug versions of the library modules and
Xwill trap as many errors as it can (yes, there are errors that the malloc
Xlibrary cannot catch).  Environment variables can be used to control the
Xbehavior of the library.
X.P
X.ne 15
X\fBMODE 2 - malloc.h inclusion\fP
X.P
XThis mode involves including the \fBmalloc.h\fP file included with the 
Xdebugging library.  The malloc.h file includes macros that will identify
Xthe source line and file name for each debugging function called.  This
Xis how the library is able to tell you that it was the call to malloc
Xon line 55 in file junk.c.
X.P
X.ne 8
XTypically you should always include malloc.h in your source files and just
Xuse the -I INCLUDEDIR directive for the compiler to point the compiler to
Xthe debugging version of the header file instead of the normal file.  That
Xway you don't have to change the source files when you want to turn off
Xthe debugging library.
X.P
XNOTE: Once you compile code in this mode, you must recompile the code 
Xwithout the debugging malloc.h include file in order to get the software
Xto use the non-debugging functions.
X.P
X.ne 10
X\fBMODE 3 - run-time specification of options\fP
X.P
XEnvironment variables can be used to control the behavior of the debugging
Xlibrary to some extent.  However, this control is very coarse in that
Xyou only have one setting available for the entire running of the program.
X.P
XThis can be a problem if you want to turn on malloc chain checking, but
Xknow that the problem occurs between a relatively narrow portion of the
Xcode and don't want to take the hit of having chain checking on for the
Xentire program execution.  
X.P
X.ne 15
XThe solution to this problem is to include calls to dbmallopt() with the
Xdebugging options which set the appropriate modes when you want them set.
XSince you don't want to have to change the code to remove and add these
Xfunctions every time you decide to include malloc debugging or not, the 
X\fBmalloc.h\fP file defines the preprocessor symbol \s-2_DEBUG_MALLOC_INC\s+2
Xwhich can be used in your code as follows:
X.eX
X#ifdef _DEBUG_MALLOC_INC
X	dbmallopt(.... );
X#endif
X.eX
XIn addition to setting behavior options, you might want to make use of
Xthe memory leak detection routines in this mode.  These calls should
Xalso be surrounded by #ifdefs for the debug malloc symbol so that you
Xcan leave them in the code and automatically get
Xthe increased functionality whenever you compile with the debugging library.
X.P
X.ne 10
X\fBMODE 4 - deeper inclusion of malloc calls\fP
X.P
XThis mode involves inserting calls to the special functions supported
Xby the malloc library (like the leak detection or stack maintenance 
Xroutines).  The effects of the inclusions depends upon the modules
Xincluded and the amount to which they are used. 
X.P
XIt is strongly recommended that you setup your code with the following
Xlines in a header file that is included by all modules, or just add the
Xcode to the beginning of the modules themselves:
X.eX
X#ifndef _DEBUG_MALLOC_INC
X#define malloc_enter(func)
X#define malloc_leave(func)
X#define malloc_chain_check()
X#define malloc_dump(fd)
X#define malloc_list(a,b,c)
X#define malloc_inuse(hist)	(*(hist) = 0, 0)
X#endif
X.eX
XThis will automatically disable the referenced functions when the malloc
Xlibrary is not included (as should be the case when you make a production
Xbuild).
X.br
X.ne 15
X.SH "ENVIRONMENT VARIABLES"
XEnvironment variables can be used to control error handling, error logging
Xand malloc chain checking at run time.  Most of these environment variables
Xcan be set via the \fBdbmallopt\fP() routine and are well described in 
Xthat portion of the document.  Look for further information there.
X.MP
XThe following environment variables are used:
X.P
X.VL 10
X.br
X.ne 4
X.LI "\s-2MALLOC_BOUNDSIZE\s+2"
XThis specifies the minimum number of bytes that the allocation routines
Xwill leave unused at the end of each segment.  This value may be
Xany non-zero positive integer (although you must remember that the
Xamount of memory used is directly related to this buffer area.
X.MP
XIt may be necessary to increase this value if you think you have a module
Xthat is writing far enough beyond its malloc segment that it changes the
Xnext segment (and therefore doesn't make a change that this library
Xwould be able to detect.
X.MP
XThe default for this value is 1 (although because of memory alignment
Xissues, you will usually have more than one byte of filler at the
Xend of most segments).
X.br
X.ne 4
X.LI "\s-2MALLOC_CKCHAIN\s+2"
Xif 1, turns on malloc chain checking at every call to any
Xof the malloc functions.
X.br
X.ne 4
X.LI "\s-2MALLOC_DETAIL\s+2"
Xif set to a non-zero integer, \fBmalloc_dump\fP shows some internal
Xdetail for each 
Xentry in the chain.  This info is probably only of use if you are debugging 
Xthe malloc library itself.
X.br
X.ne 4
X.LI "\s-2MALLOC_ERRFILE\s+2"
Xspecifies the error log file for error messages.  Error messages generated
Xby the library are \fBAPPENDED\fP to this file, so if you want a clean file,
Xyou will have to remove or empty it yourself between runs.  If this option
Xis used, no indication of an error will be sent to stdout or stderr (this 
Xis purposefully done this way so that if you are running a full screen 
Xprogram, it doesn't mess up the screen).
X.br
X.ne 4
X.LI "\s-2MALLOC_FATAL\s+2"
Xspecifies the error handling for fatal errors
X.br
X.ne 4
X.LI "\s-2MALLOC_FILLAREA\s+2"
Xspecifies the fill area flag setting.  If zero, malloc/free area filling 
Xand checking is disabled (thereby increasing performance, while decreasing
Xeffectiveness of the library).  See the discussion of the \fBdbmallopt\fP()
Xarguments for more info on other settings.
X.br
X.ne 5
X.LI "\s-2MALLOC_FILLBYTE\s+2"
XThis specifies the integer value of the character to use when filling
Xallocated areas.  This value defaults to 1 and must be within the range
Xof 0 - 255. This capability is useful if you believe that you are 
Xhaving a problem with code that is trashing its malloc region with
Xa data pattern that matches the default fill pattern.
X.MP
XNOTE: if an attempt is made to use a value outside the specified
Xrange, the new value is \fBsilently\fP ignored and the default is used.
X.br
X.ne 5
X.LI "\s-2MALLOC_FREEBYTE\s+2"
XThis specifies the integer value of the character to use when filling
Xfreed areas.  This value defaults to 1 and must be within the range
Xof 0 - 255. It should also be different from \s-2MALLOC_FILLBYTE\s+2, but
Xthat is not enforced. 
X.MP
XNOTE: if an attempt is made to use a value outside the specified
Xrange, the new value is \fBsilently\fP ignored and the default is used.
X.br
X.ne 4
X.LI "\s-2MALLOC_LOWFRAG\s+2"
Xif 1, turns on best fit allocation algorithm.  Otherwise, first fit algorithm
Xis used for finding allocation segments (which can cause memory fragmentation).
X.br
X.ne 4
X.LI "\s-2MALLOC_CKDATA\s+2"
Xif 0, disables checking of pointers passed to string/memory functions for
Xmalloc region overwrites.
X.br
X.ne 4
X.LI "\s-2MALLOC_REUSE\s+2"
Xif 0, disables reuse of freed memory segments and it does not fill free'd
Xsegments with the fill pattern.  If 1, freed segments are filled and they can
Xbe reused.  If 2, freed segments can be reused, but they are not filled when
Xfreed.
X.br
X.ne 4
X.LI "\s-2MALLOC_SHOW_LINKS\s+2"
Xwhen an error is found, the suspected allocation is
Xdisplayed.  However, since it is possible that the next or previous allocation
Xin the malloc chain was the actual culprit these links may be of interest.
XIf this variable is set to a non-zero integer (i.e. 1) the links will also
Xbe shown.
X.br
X.ne 2
X.LI "\s-2MALLOC_WARN\s+2"
Xspecifies the error handling for warning errors
X.LE
X.P
X.ne 5
XAs an example, to set up the session to generate a core file for
Xevery malloc warning, to drop core and exit on a malloc fatal, and 
Xto log all messages to the file "malloc_log" do the following:
X.eX
XMALLOC_WARN=131
XMALLOC_FATAL=1
XMALLOC_ERRFILE=malloc_log
X
Xexport MALLOC_WARN MALLOC_FATAL MALLOC_ERRFILE
X.eX
X.br
X.ne 15
X.SH "ERROR MESSAGES"
XThe following error messages are reported by the library:
X.VL 15
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_BAD_CONNECT\s+2"
XPointers between this segment and adjoining segments are invalid.
X.MP
XThis error indicates that the malloc chain has been corrupted.
XThis is most often caused by an overwrite of the malloc header
Xby an access via the previous malloc segment.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_BAD_MAGIC\s+2"
XMalloc region does not have a valid magic number in header.
X.MP
XThis error is caused by several mechanisms including \fBfree\fP()ing
Xthe same pointer twice or a pointer that was not returned by \fBmalloc\fP(),
Xor writing beyond the end of a segment.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_BAD_PTR\s+2"
XPointer is not within malloc region.
X.MP
XThe pointer passed to \fBfree\fP or\fPrealloc\fP is not pointer 
Xreturned by \fBmalloc\fP.  Another cause is corruption of the
Xmalloc chain by writing beyond the end of a segment.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_CHAIN_BROKE\s+2"
XMalloc chain is corrupted, pointers out of order.
X.MP
XCorruption has been detected in the malloc chain that is
Xrelated to the relative positions of the malloc chain segments
Xin memory.  This is an indication that someone has overwritten
Xbeyond the amount they allocated.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_FREELIST_BAD\s+2"
XMalloc segment in free list is in-use.
X.MP
XA segment that is in the free-list is flagged as in-use.  This is usually
Xcaused by overwriting from the previous segment in the malloc chain.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_FREEMARK\s+2"
XFree called to free a segment that has been marked.
X.MP
XMarking a segment is done because you believe that the segment will not be
Xfree'd and therefore don't want it to appear in the list of possible leaks.
XIf you then go on to free it, perhaps it shouldn't have been marked.  
X.MP
XThis error message can be disabled with the MALLOC_FREEMARK option on 
Xthe \fBdbmallopt\fP() function.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_NOBOUND\s+2"
XUnable to determine doubleword boundary
X.MP
XThe code was unable to figure out the boundary requirements for a doubleword.
XThis error should never occur.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_NOMORE_MEM\s+2"
XUnable to get additional memory from the system.
X.MP
XThe system call \fBsbrk\fP failed to obtain more memory
Xfor the program.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_NOT_INUSE\s+2"
XData is not in use (can't be freed or reallocated).
X.MP
XA pointer to a malloc segment has been passed to \fBfree\fP() or
X\fBrealloc\fP(), but this segment has already been freed.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_NO_END\s+2"
XMalloc chain is corrupted, end before end pointer.
X.MP
XYet another overwrite problem.   This error means that we got to 
Xwhat we believe is the end of the chain, but it does not match
Xthe recorded end of the chain.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_OUTOF_BOUNDS\s+2"
XPointer within malloc region, but outside of malloc data bounds.
X.MP
XThis is caused by a call to one of the string/memory functions
Xthat attempt to read/write bytes that are not included in
Xthe allocation associated with that memory.  This is the
Xmost typical error that you will see from the malloc library.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_OVERRUN\s+2"
XData has overrun beyond requested number of bytes.
X.MP
XThis error is detected by \fBfree\fP() and indicates that the
Xcurrent segment has written data beyond the number of bytes that
Xit requested.  This only catches overwrites when they are within
Xthe extra space allocated with each segment (this can range from
Xone to eight bytes).  If the overwrite occurs further along it
Xwill usually cause some corruption in the malloc chain.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_REUSE\s+2"
XData in free'd area has been modified.
X.MP
XData in a freed segment has been modified.  This usually indicates
Xthat the program is using a pointer after it called free, but it
Xmay also be caused by an overwrite from a previous segment in 
Xthe chain.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_STK_BADFUNC\s+2"
XCurrent function name doesn't match name on stack.
X.MP
X\fBmalloc_leave\fP() was called with a function name that is not
Xthe current function.  This is usually caused by a missing call
Xto \fBmalloc_enter\fP() in the same function, or a missing call
Xto \fBmalloc_leave\fP() in a sub-function.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_STK_NOCUR\s+2"
XNo current function on stack, probably missing call to malloc_enter().
X.MP
X\fBmalloc_leave\fP() was called with a function name and there is 
Xno current function (the stack is empty). This is usually caused
Xby a missing call to \fBmalloc_enter\fP(), or an extra call to 
X\fBmalloc_leave\fP() in the same function.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_UNDERRUN\s+2"
XData has written before beginning of requested bytes.
X.MP
XThis error is detected by \fBfree\fP() and indicates that the current
Xsegment has written data before the beginning of the requested block.
XThis only catches overwrites when they are within the extra space
Xallocated before each segment (this is usually four bytes).  If the
Xoverwrite occurs further back it will usually cause some corruption in
Xthe malloc chain.
X.br
X.MP
X.ne 6
X.LI "\s-2M_CODE_ZERO_ALLOC\s+2"
XAn allocation routine was called to allocate zero bytes.
X.MP
XWhile ANSI C requires that allocations of zero bytes are permissible and
Xshould be supported, the behavior of such an operation can be undefined on
Xnon-ANSI systems.  This warning will alert you to the locations where these
Xcalls are made.
X.MP
XThis error message can be disabled with the MALLOC_ZERO option on 
Xthe \fBdbmallopt\fP() function.
X.LE
X.P
X.br
X.ne 15
X.SH "DUMP OUTPUT"
XSample dump/list output:
X.eX
X************************** Dump of Malloc Chain ****************************
XPOINTER     FILE  WHERE         LINE      ALLOC        DATA     HEX DUMP   
XTO DATA      ALLOCATED         NUMBER     FUNCT       LENGTH  OF BYTES 1-7 
X-------- -------------------- ------- -------------- ------- --------------
X0x403DB4 teststack.c               75 malloc(1)           40 01010101010101  
X         -> sub3() in teststack.c(73)
X         -> main() in teststack.c(23)
X0x403E0C testerr.c                 16 realloc(1)          20 01010101010101  
X.eX
XThe info in each column is as follows:
X.MP
X.VL 10
X.br
X.ne 4
X.LI "\s-2POINTER\s+2"
Xthe pointer returned by the allocation function (the pointer
Xthe the allocated data area).
X.MP
X.br
X.ne 8
X.LI "\s-2FILE\s+2"
Xthe name of the file where the allocation function was called.  This
Xinformation is only available if the source file includes the \fBmalloc.h\fP
Xfile from this library (as opposed to the system include file).  If
Xthe source file did not include this file, the file will be listed
Xas unknown and the line number will be blank.
XNote that any malloc calls from system libraries will probably not have been
Xcompiled with the \fBmalloc.h\fP file included and will therefore
Xappear as unknown.
X.MP
X.br
X.ne 4
X.LI "\s-2LINE NUM\s+2"
XThe line number of the line that called the allocation function.  This 
Xfield will be left blank if the \fBmalloc.h\fP from this library
Xwas not included in the source file when it was compiled. 
X.MP
X.br
X.ne 5
X.LI "\s-2ALLOC FUNC\s+2"
XThe allocation function called: \fBmalloc\fP, \fBrealloc\fP, or \fBcalloc\fP.
XThe number in parenthesis following the function name is the call number
Xfor that particular function.  For example: malloc(1) means that this
Xallocation was the 1st call to malloc.
X.MP
X.br
X.ne 2
X.LI "\s-2DATA LEN\s+2"
XThe number of bytes allocated.
X.MP
X.br
X.ne 6
X.LI "\s-2HEX DUMP\s+2"
XA hexadecimal dump of the first seven bytes in the allocated data.  This example
Xshows the bytes filled with 0x01s which happen to be the fill pattern used
Xby the malloc library (to make sure that one doesn't depend upon the 
Xfact that some calls to malloc result in NULL bytes).  So the
Xallocations that are shown haven't stored any data in the area yet.
X.LE
X.MP
XThe lines that begin with a "->" are stack dump lines which show the
Xcalling environment that was present when the are was allocated.  The
Xenvironment is managed via the use of the \fBmalloc_enter\fP() and 
X\fBmalloc_leave\fP() routines.
X.MP
X.br
X.ne 15
XIf the environment variable \s-2MALLOC_DETAIL\s+2 is non-zero, the 
Xfollowing additional information will be included:
X.eX
X************************************************************** Du... 
X                             FREE     FREE                  ACTUAL SIZE    ...
X  PTR      NEXT     PREV     NEXT     PREV      FLAGS       INT    HEX     ...
X-------- -------- -------- -------- -------- ---------- -------- --------- ...
X0x403C94 0x403CEC 0x40326C 0x000000 0x000000 0x03156111       48(0x000030) ...
X0x403CEC 0x403D2C 0x403C94 0x000000 0x000000 0x03156121       24(0x000018) ...
X0x403D2C 0x403D6C 0x403CEC 0x000000 0x403D6C 0x03156120       24(0x000018) ...
X0x403D6C 0x000000 0x403D2C 0x403D2C 0x000000 0x03156120       24(0x000018) ...
X
XMalloc start:      0x40326C
XMalloc end:        0x403D2C
XMalloc data start: 0x403C94
XMalloc data end:   0x405C94
XMalloc free list:  0x403D6C
X                -> 0x403D2C
X.eX
XNOTE that I cut off the example at the point where the normal output
Xwould begin (hence the ...).
X.MP
XThe info in each column is as follows:
X.MP
X.VL 8
X.LI "\s-2PTR\s+2"
XThe malloc chain pointer for the segment (the address of the segment).
X.MP
X.LI "\s-2NEXT\s+2"
XThe pointer to the next segment in the chain.
X.MP
X.LI "\s-2PREV\s+2"
XThe pointer to the previous segment in the chain.
X.MP
X.LI "\s-2FREE NEXT\s+2"
XThe pointer to the next segment in the free list.
X.MP
X.LI "\s-2FREE PREV\s+2"
XThe pointer to the previous segment in the free list.
X.MP
X.ne 10
X.LI "\s-2FLAGS\s+2"
XThe flags associated with this segment.  This is a long
Xinteger which contains the following fields
X.MP
X.VL 6
X.LI "0xFFFFFF00"
Xthe magic number.  This should be 0x03156100 (probably 
Xsomeone's birthday).
X.MP
X.LI "0x00000070"
Xthe type of allocation function. Malloc (x010), realloc (0x20), or
Xcalloc (0x30) are the only valid values for this field).
X.MP
X.LI "0x00000001"
Xthe in-use flag.  if this value is non-zero, the indicated segment
Xis currently in use (not freed).
X.LE
X.MP
X.LI "\s-2ACTUAL SIZE\s+2"
XThe actual size reserved for the allocation in both decimal and
Xhex.  This will be at least one byte more than the requested size, and
Xas much as 8, so that we can check to see if the allocation has been
Xoverrun.
X.LE
X.MP
X.ne 4
XMalloc \fBstart\fP and \fBend\fP are pointers to the first and
Xlast malloc chain segment, respectively.
X.MP
X.ne 4
XMalloc \fBdata start\fP and \fBdata end\fP are the lowest and highest
Xdata bytes managed my the malloc sub-system.  These are only used as
Xa quick check to see if a pointer is in the malloc region before we
Xgo hunting down the chain trying to identify the segment it belongs to.
X.MP
X.ne 4
XMalloc \fBfree list\fP is a chain of the elements in the free list (so 
Xit is easier for the programmer to follow the free list if they choose 
Xto).  The address of each element in the list follows below the list head.
X.br
X.ne 15
X.SH "X PROGRAM DEBUGGING"
XThe malloc library includes a set of compatibility routines for the 
XXt toolkit allocation routines: \fBXtMalloc\fP(), \fBXtCalloc\fP(),
X\fBXtRealloc\fP(),and \fBXtFree\fP().   These routines provide the
Xsame level of malloc area integrity checking that is provided by
Xthe basic malloc functions while maintaining complete compatibility
Xwith the X11R5 functions.
X.P
XIf you link an X package with the debug library and you make a call
Xto any of the Xt allocation routines, the debug modules will automatically
Xbe included.  If you don't call them directly, but you still want to
Xinclude them in order to better debug their use, you can add a -u
Xlinker specification for XtRealloc.  For example:
X.eX
Xcc -o xapp -u XtRealloc xapp.o -ldbmalloc -lXt -lX....
X.eX
XNote that you may have to add an underscore before the XtRealloc if your
Xcompiler does this automatically.
X.P
XA second potential problem with X is caused by a difference between
XX11R4 and X11R5.  If you only have one of theses packages, then the
Xmalloc library will be automatically configured to handle that package.
XIf, however, you have both of them installed and you need to be able
Xto link with either system, you may have to add a -u _XtHeapInit to
Xthe link line on the X11R5 links.  This is because X11R5 defines both
Xthe heap management and malloc management routines in the same 
Xmodule, while X11R4 defines them in different modules.
X.P
XThe sign of this problem is a link error due to duplicate references
Xto the Xt allocation routines (XtMalloc, etc).
X.SH LINKING
XThe order in which you link your programs can have a significant effect
Xon the usefulness of the library and even on the ability to link itself.
XThe debug library should be placed as the first system library that you are
Xlinking to (assuming that you are calling at least one of the malloc, string,
Xor memory functions).
X.P
XFor example, if the following is your normal link command:
X.eX
Xcc -o app app.o supp.o else.o applib.a -lmath -lcurses
X.eX
XYou should add the malloc debug library in between applib.a and -lmath, 
Xwhich would result in the following:
X.eX
Xcc -o app app.o supp.o else.o applib.a -ldbmalloc -lmath -lcurses
X.eX
XThis will ensure that the debug malloc library overrides all of the allocation
Xroutines within the other libraries.  
X.P
XIf you have other problems compiling or linking with the library you should
Xlook at the \s-2PROBLEMS\s+2 file in the source directory.  This file 
Xcontains descriptions of common problems and the recommended solutions to
Xthe problems.
X.SH PERFORMANCE
XThis malloc library and its associated string and memory functions are
Xmuch less efficient than the standard functions due in part to the extra
Xerror checking.  You do not want to use this library when generating a
Xproduction (i.e. releasable) version of your software.  It should only
Xbe used during development and testing.
X.P
X.ne 10
XThe following environment variable settings will give you the best
Xperformance (at the expense of some additional error checking):
X.eX
XMALLOC_CKCHAIN=0
XMALLOC_CKDATA=0
XMALLOC_FILLAREA=0
XMALLOC_LOWFRAG=0
X.eX
XWe recommend against setting MALLOC_FILLAREA to zero because, while
Xit will increase the performance, it takes away the capability
Xto uncover small malloc overruns which don't overrite the pointers surrounding
Xthe malloc regions.  The same anti-recommendation applies to MALLOC_CKDATA.
X.P
X.ne 5
XAnyway, with these settings, the malloc library runs at about 1/2 the
Xspeed (things only take twice as long) as the standard library.  If you program
Xspends most of its time in malloc, it will still be slow (but perhaps this is
Xan indication that you need to consider changing the way you are using 
Xmalloc).
X.br
X.ne 15
X.SH WARNINGS
XThe include file for this library "malloc.h" should be included after
Xthe includes for any system related information.  This is because "malloc.h"
Xredefines several system functions including string and memory routines
Xand this will usually cause compilation errors if malloc.h is processed
Xfirst (of course, the compile errors will talk about errors in the other
Xsystem include files like string.h).
X.P
XThis goes hand in hand with the fact that if you have local definitions of
Xthe return types of standard functions like strcmp() or malloc(), 
Xthese lines will cause compile errors due to the #defines in the
Xmalloc.h header file.  Therefore, it is suggested that you remove
Xall such definitions from your code and rely on the system header
Xfiles to define these functions, or you surround the definitions 
Xwith #ifdef \s-2DEBUG_MALLOC_INC\s+2.
X.P
XThere is a possibility that the use of \fBsbrk\fP() by other modules
Xwill cause this library to get confused and possibly report 
Xsome pointers as bad when the really aren't part of the malloc chain
Xitself.  Therefore the direct use of \fBsbrk\fP() is strongly discouraged.
X.P
XThis library attempts to trap errors and exit/handle them gracefully.  
XHowever, the nature of the problems may be such that it causes the 
Xcode in the library itself to crash.  There is no way to avoid this,
Xbut if it does occur,  turn on chain checking to narrow the place where
Xit will occur.
X.P
XThe functions in this library will often conflict with duplicate functions
Xin shared library versions of libc.a.  This is usually due to the 
Xfact that some shared library modules have explicit references to shared
Xlibrary versions of the debug functions.  The only way around this is
Xto not use the shared library when linking.
X.P
XThis malloc library, like most malloc libraries, is not re-entrant 
Xand therefore should not be called from interrupt handlers because of the
Xpotential for receiving an interrupt in the middle of a call to malloc
Xwhich would really mess things up.
X.SH SEE ALSO
Xmalloc(3), string(3), memory(3)
X.br
X.ne 10
X.SH COPYRIGHT
X.nf
X (c) Copyright 1990, 1991, 1992 Conor P. Cahill (cpcahil@virtech.vti.com)
X
X This software may be distributed freely as long as the following conditions
X are met:
X        * the distribution, or any derivative thereof, may not be
X          included as part of a commercial product
X        * full source code is provided including this copyright
X        * there is no charge for the software itself (there may be
X          a minimal charge for the copying or distribution effort)
X        * this copyright notice is not modified or removed from any
X       	  source file
X
X.fi
X.br
X.ne 10
X.SH AUTHOR
X.nf
XConor P. Cahill
XVirtual Technologies Incorporated
X46030 Manekin Plaza, Suite 160
XSterling VA 22170
X703-430-9247
X.MP
Xcpcahil@virtech.vti.com
Xuunet!virtech!cpcahil
END_OF_FILE
if test 42916 -ne `wc -c <'malloc.3'`; then
    echo shar: \"'malloc.3'\" unpacked with wrong size!
fi
# end of 'malloc.3'
fi
if test -f 'mallocin.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mallocin.h'\"
else
echo shar: Extracting \"'mallocin.h'\" \(9557 characters\)
sed "s/^X//" >'mallocin.h' <<'END_OF_FILE'
X/*
X * (c) Copyright 1990, 1991, 1992 Conor P. Cahill (cpcahil@virtech.vti.com)
X *
X * This software may be distributed freely as long as the following conditions
X * are met:
X * 		* the distribution, or any derivative thereof, may not be
X *		  included as part of a commercial product
X *		* full source code is provided including this copyright
X *		* there is no charge for the software itself (there may be
X *		  a minimal charge for the copying or distribution effort)
X *		* this copyright notice is not modified or removed from any
X *		  source file
X */
X/*
X * $Id: mallocin.h,v 1.27 1992/09/03 22:24:33 cpcahil Exp $
X */
X#ifndef _MALLOCIN_H
X#define _MALLOCIN_H 1
X
X/*
X * this file contains macros that are internal to the malloc library
X * and therefore, are not needed in malloc.h.
X */
X
X#if POSIX_HEADERS
X#include <unistd.h>
X#endif
X#if ANSI_HEADERS
X#include <stdlib.h>
X#endif
X
X#ifndef SYS_TYPES_H_INCLUDED
X#include <sys/types.h>
X#endif
X
X#define IN_MALLOC_CODE	1
X#include "sysdefs.h"
X#include "malloc.h"
X
X#define IDTYPE unsigned long
X#define ULONG  unsigned long
X
X/*
X * Data structures used by stack mechanism
X */
Xstruct stack
X{
X	struct stack	* beside;
X	struct stack	* below;
X	struct stack 	* above;
X	CONST char	* func;
X	CONST char	* file;
X	int		  line;
X};
X
X/*
X * minimum round up to get to a doubleword boundry, assuming it is the
X * strictest alignment requirement on the system.  If not, the union s
X * in struct mlist will also have to be changed.  Note that this must be
X * a power of two because of how it is used throughout the code.
X */
X#define M_RND		0x08
X#define M_YOFFSET       (sizeof(SIZETYPE))
X
X#define LONGFILL 2
X
Xstruct mlist
X{
X	struct mlist	* next;			/* next entry in chain	*/
X	struct mlist	* prev;			/* prev entry in chain	*/
X	struct mlist	* freenext;		/* next ent in free chn */
X	struct mlist	* freeprev;		/* prev ent in free chn */
X	struct stack	* stack;		/* current stack level	*/
X	struct stack	* freestack;		/* free stack level	*/
X	long	 	  flag;			/* inuse flag		*/
X	CONST char	* file;			/* file where called fm	*/
X	int		  line;			/* line where called fm	*/
X	CONST char	* ffile;		/* file where freed 	*/
X	int		  fline;		/* line where freed 	*/
X	IDTYPE		  fid;			/* free call number	*/
X	IDTYPE		  hist_id;		/* historical id	*/
X	IDTYPE		  id;			/* malloc call number	*/
X	SIZETYPE	  r_size;		/* requested size	*/
X	union
X	{
X		SIZETYPE	  size;		/* actual size		*/
X		SIZETYPE	  filler[LONGFILL];
X		double		  unused_just_for_alignment;
X	} s;
X	char		  data[M_RND];
X};
X
X/*
X * pre-filler size
X */
X#define FILLSIZE	(sizeof(mlist.s) - sizeof(mlist.s.filler[0]))
X
X/*
X * kludge to get offsetof the data element for the mlist structure
X */
X#define M_SIZE		((SIZETYPE)(char *)((struct mlist *)0)->data)
X#define M_FLAGOFF	((SIZETYPE)(char *)&((struct mlist *)0)->flag)
X
X#define M_INUSE 	0x01
X#define M_FILLED 	0x02
X#define M_MARKED	0x04
X#define M_DFILLED	0x08
X#define M_MAGIC 	0x31561000
X#define M_MAGIC_BITS	0xfffff000
X
X#define M_BLOCKSIZE	(1024*8)
X
X#define EOS			'\0'
X#define M_DFLT_FILL		'\01'
X#define M_DFLT_FREE_FILL	'\02'
X#define M_DFLT_BSIZE		1
X#define M_FILL			((char)malloc_fillbyte)
X#define M_FREE_FILL		((char)malloc_freebyte)
X#define M_BSIZE			(malloc_boundsize)
X
X#define MALLOC_INIT()	if( malloc_data_start == (DATATYPE *)0 ) malloc_init()
X
X/* 
X * malloc internal options
X */
X#define MOPT_MFILL	0x0001		/* fill malloc'd segments	*/
X#define MOPT_FFILL	0x0002		/* fill free'd segments		*/
X#define MOPT_REUSE	0x0004		/* reuse free segments?		*/
X#define MOPT_LOWFRAG	0x0008		/* low fragmentation		*/
X#define MOPT_CKCHAIN	0x0010		/* enable chain checking	*/
X#define MOPT_CKDATA	0x0020		/* enable data checking		*/
X#define MOPT_DFILL	0x0040		/* fill over/underflow areas	*/
X#define MOPT_SLINKS     0x0080		/* turn off/on adjacent link disp */
X#define MOPT_DETAIL     0x0100		/* turn off/on detailed output  */
X#define MOPT_FREEMARK   0x0200		/* warning when freeing marked	*/
X#define MOPT_ZERO       0x0400		/* warning about zero length allocs */
X
X/*
X * malloc_freeseg() operation arguments
X */
X#define M_FREE_REMOVE	1
X#define M_FREE_ADD	2
X/*
X * Malloc types
X */
X#define M_T_MALLOC	0x010
X#define M_T_REALLOC	0x020
X#define M_T_CALLOC	0x030
X#define M_T_SPLIT	0x040
X#define M_T_STACK	0x050
X#define M_T_XTMALLOC	0x060
X#define M_T_XTREALLOC	0x070
X#define M_T_XTCALLOC	0x080
X#define M_T_ALIGNED	0x090
X#define M_T_BITS	0x0F0
X
X#define GETTYPE(_ptr)		(_ptr->flag & M_T_BITS)
X#define SETTYPE(_ptr,_type) 	(_ptr->flag = ((_ptr->flag & ~M_T_BITS)|_type))
X
X#define DATATOMLIST(_ptr) ((struct mlist *) (((char *)_ptr) - M_SIZE))
X
X/*
X * Free types
X */
X#define F_T_FREE	0x100
X#define F_T_CFREE	0x200
X#define F_T_XTFREE	0x300
X#define F_T_REALLOC	0x400
X#define F_T_BITS	0xF00
X
X#define GETFTYPE(_ptr)		(_ptr->flag & F_T_BITS)
X#define SETFTYPE(_ptr,_type) 	(_ptr->flag = ((_ptr->flag & ~F_T_BITS)|_type))
X
X/*
X * Fill types
X */
X#define FILL_MALLOC	1
X#define FILL_REALLOC	2
X#define FILL_CALLOC	3
X#define FILL_FREE	4
X#define FILL_SPLIT	5
X#define FILL_JOIN	6
X
X#define FILLCHECK(a,b,c,d,e) ( malloc_fill ? FillCheck(a,b,c,d,e) : 0 )
X#define FILLDATA(a,b,c,d)     if( malloc_fill ) FillData(a,b,c,d)
X
X/*
X * malloc_chain_check flags
X */
X#define SHOWERRORS	1
X#define DONTSHOWERRS	0
X
X/*
X * DBFmalloc fill flags
X */
X#define DOFILL		1
X#define DONTFILL	0
X
X/*
X * malloc join flags
X */
X#define NOTINUSE	0	/* don't join inuse segments		*/
X#define INUSEOK		1	/* ok to join if current seg is in use	*/
X#define NEXTPTR_INUSEOK	2
X#define ANY_INUSEOK	3
X
X/*
X * number of longwords to search for magic number before we give up and 
X * search the entire malloc list.
X */
X#define MAX_KLUDGE_CHECKS	100
X/*
X * Misc stuff..
X */
X#define M_ROUNDUP(size)	{\
X				if( size & (M_RND-1) ) \
X				{ \
X					size += (M_RND-1); \
X					size &= ~(M_RND-1); \
X				} \
X			}
X
XEXITTYPE	  exit __STDCARGS((int));
Xchar		* getenv __STDCARGS((CONST char *));
XDATATYPE	* sbrk __STDCARGS((int));
X
X/*
X * stuff for X compatibility routines (needed here so that the prototypes 
X * don't fail
X */
Xtypedef struct {
X    char*       start;
X    char*       current;
X    int         bytes_remaining;
X} Heap;
X
X#ifndef _XtIntrinsic_h
Xtypedef unsigned int Cardinal;
Xtypedef char * String;
X#endif
X
X#include "prototypes.h"
X
X/*
X * global variables
X */
Xextern int		  in_malloc_code;
Xextern SIZETYPE		  malloc_align;
Xextern int		  malloc_boundsize;
Xextern DATATYPE		* malloc_data_start;
Xextern DATATYPE		* malloc_data_end;
Xextern struct mlist 	* malloc_end;
Xextern int		  malloc_errfd;
Xextern int		  malloc_errno;
Xextern CONST char	* malloc_err_strings[];
Xextern int		  malloc_fatal_level;
Xextern int		  malloc_fill;
Xextern int		  malloc_fillbyte;
Xextern int		  malloc_freebyte;
Xextern struct mlist	* malloc_freelist;
Xextern long		  malloc_hist_id;
Xextern int		  malloc_opts;
Xextern int		  malloc_round;
Xextern struct mlist	  malloc_start;
Xextern int		  malloc_warn_level;
X
X#endif /* _MALLOCIN_H */
X
X/*
X * $Log: mallocin.h,v $
X * Revision 1.27  1992/09/03  22:24:33  cpcahil
X * final changes for PL14
X *
X * Revision 1.26  1992/08/22  16:27:13  cpcahil
X * final changes for pl14
X *
X * Revision 1.25  1992/07/12  15:30:58  cpcahil
X * Merged in Jonathan I Kamens' changes
X *
X * Revision 1.24  1992/07/03  00:03:25  cpcahil
X * more fixes for pl13, several suggestons from Rich Salz.
X *
X * Revision 1.23  1992/07/02  13:49:54  cpcahil
X * added support for new malloc_size function and additional tests to testerr
X *
X * Revision 1.22  1992/06/30  13:06:39  cpcahil
X * added support for aligned allocations
X *
X * Revision 1.21  1992/06/22  23:40:10  cpcahil
X * many fixes for working on small int systems
X *
X * Revision 1.20  1992/05/09  00:16:16  cpcahil
X * port to hpux and lots of fixes
X *
X * Revision 1.19  1992/05/08  02:30:35  cpcahil
X * minor cleanups from minix/atari port
X *
X * Revision 1.18  1992/05/08  01:44:11  cpcahil
X * more performance enhancements
X *
X * Revision 1.17  1992/05/06  05:37:44  cpcahil
X * added overriding of fill characters and boundary size
X *
X * Revision 1.16  1992/05/06  04:53:29  cpcahil
X * performance enhancments
X *
X * Revision 1.15  1992/04/24  12:09:13  cpcahil
X * (hopefully) final cleanup for patch 10
X *
X * Revision 1.14  1992/04/24  11:18:52  cpcahil
X * Fixes from Denny Page and Better integration of Xt alloc hooks
X *
X * Revision 1.13  1992/04/22  18:17:32  cpcahil
X * added support for Xt Alloc functions, linted code
X *
X * Revision 1.12  1992/04/20  22:29:14  cpcahil
X * changes to fix problems introduced by insertion of size_t
X *
X * Revision 1.11  1992/04/13  18:26:30  cpcahil
X * changed sbrk arg to int which it should be on all systems.
X *
X * Revision 1.10  1992/04/13  14:16:11  cpcahil
X * ansi changes corresponding to changes made in stack.c
X *
X * Revision 1.9  1992/04/13  03:06:33  cpcahil
X * Added Stack support, marking of non-leaks, auto-config, auto-testing
X *
X * Revision 1.8  1992/03/01  12:42:38  cpcahil
X * added support for managing freed areas and fixed doublword bndr problems
X *
X * Revision 1.7  1991/12/31  21:31:26  cpcahil
X * changes for patch 6.  See CHANGES file for more info
X *
X * Revision 1.6  1991/12/06  08:54:18  cpcahil
X * cleanup of __STDC__ usage and addition of CHANGES file
X *
X * Revision 1.5  91/12/04  18:01:22  cpcahil
X * cleand up some aditional warnings from gcc -Wall
X * 
X * Revision 1.4  91/12/04  09:23:42  cpcahil
X * several performance enhancements including addition of free list
X * 
X * Revision 1.3  91/12/02  19:10:12  cpcahil
X * changes for patch release 5
X * 
X * Revision 1.2  91/11/25  14:42:02  cpcahil
X * Final changes in preparation for patch 4 release
X * 
X * Revision 1.1  91/11/24  00:49:30  cpcahil
X * first cut at patch 4
X * 
X */
END_OF_FILE
if test 9557 -ne `wc -c <'mallocin.h'`; then
    echo shar: \"'mallocin.h'\" unpacked with wrong size!
fi
# end of 'mallocin.h'
fi
echo shar: End of archive 5 \(of 10\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 10 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
*** SENTINEL(tm) The ultimate Debugging Environment - email for more info ***

Conor P. Cahill              (703)430-9247            cpcahil@virtech.vti.com
Virtual Technologies, Inc.  46030 Manekin Plaza          Dulles, VA 21066 

exit 0 # Just in case...
