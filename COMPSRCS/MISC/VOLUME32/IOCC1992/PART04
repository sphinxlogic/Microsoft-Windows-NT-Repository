Newsgroups: comp.sources.misc
From: chongo@toad.com (Landon Curt Noll)
Subject:  v32i031:  ioccc.1992 - 1992 International Obfuscated C Code Contest winners, Part04/05
Message-ID: <1992Sep10.154532.27264@sparky.imd.sterling.com>
X-Md4-Signature: 0f6c6ff777027ecc308c543afe753f73
Date: Thu, 10 Sep 1992 15:45:32 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: chongo@toad.com (Landon Curt Noll)
Posting-number: Volume 32, Issue 31
Archive-name: ioccc.1992/part04
Environment: C

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  1992/adrian.c 1992/albert.c 1992/albert.hint 1992/ant.c
#   1992/ant.test.mk 1992/buzzard.1.c 1992/buzzard.2.orig.c
#   1992/help.th 1992/imc.c 1992/imc.orig.c 1992/kivinen.c
#   1992/kivinen.hint 1992/kivinen.orig.c 1992/lush.c 1992/lush.hint
#   1992/lush.orig.c 1992/marangon.c 1992/marangon.hint
#   1992/marangon.orig.c 1992/nathan.c 1992/vern.c
# Wrapped by kent@sparky on Thu Sep 10 10:21:21 1992
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 5)."'
if test -f '1992/adrian.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/adrian.c'\"
else
  echo shar: Extracting \"'1992/adrian.c'\" \(2583 characters\)
  sed "s/^X//" >'1992/adrian.c' <<'END_OF_FILE'
X/* . wc . */
X#include<stdio.h>/* Wht majr flwchrt? */
X#include<string.h>/* That mjr flwchrt! */
X#define P 257
X#define G 17
X#define z 8
X#define v(jr) jr
Xint W ,head;
X#define S(W,b,f) strncpy(W,b,f),W[f]=0\
X
X  
Xchar *wcs=" \t\n";
Xstruct{ char X[z+1]; 
X        char f ;
X        int e ; 
X        struct{ char g[z+1];
X                int b ;
X              } w[ G];
X      } o[ P];
Xint L=0,j= -28;
X
X
Xvoid E(int i, int m,char*c)
X{   
X for(; i<43; i+=3) 
X   putc("}|uutsrq`_^bji`[Zkediml[PO]a_M__]ISOYIRGTNR"[i]+i-9,stderr);
X fprintf(stderr,"(%d): %s\n" ,m,c);
X exit(1);
X}
X
X
X
Xint N(int m, char *t)
X{ 
X  int i ;
X  if (strlen ( 
X              t)>z) t[z ]=0;
X  for(i= 0; i< L ; i++) if(
X                           !strcmp (o[ i] . X
X                                             , t))return i;
X  if( L== P)
X             E(0, m, t);
X  S (o[ L] . X , t
X                  ,z);
X  head; W = .1* head;
X  o[L ].f = !( strchr( t,']' )== 0 );
X  o[L ++ ] . e = 0;
X  return L -1 ; }
X
X#define v(x )
X
Xint A(char *R)
X{
X  int c=0, i;
X  while(* R) {
X    i = -1;
X    while(j){
X      if( ++ i==o[ c].e ) return 0;
X      if(o[ 
X           c] .w[i ] .g[0 ] 
X                            =='.' ||strchr (o[ c].w[i] .g ,* R)){
X      c=
X        o[ c ] .w[i].b; break;/*
Xmain(int sl,char *j[]){
X      sleep (~~~~~~~~atoi(j[1])) ;/* . sl
X      sl s l . sl
X      l l ]
X      sl */ }
X    }
X    R++;
X  }
X  return o[ c].f;
X}
X
X
X main(int wc,char *V[]){char Y[999],*s;FILE*W;int m=0,echo,jr,q,wcl=0,wcw=0,wcc=0;
X v(s = V[1]; if (*V=strrchr(s,'/'))s=*V+1;  if(( !strncmp( s + (jr=strlen(s)) -
X  (q=strlen(V[2]) ),V[2],q))&&jr!=q) s[jr-q] = 0;  puts(s); )
X int e,p,C=0,Q ,basename;
X W= fopen(wc>= 2 ? V[1] : "adgrep.c","rt");
Xecho| m^ e| 5| (int) .8| echo|
Xwc |C ==o[o[C] .e] . 
Xe| e==+p,p; s[o[C] .e ] 
X;
Xwhile( fgets(Y,998,W)) { wcc += strlen(Y); m++;
X     if( s = strtok(Y,wcs)) wcw++;
X     else continue ;
X     C=
X       basename= j +j+*"* . basename" 
X                +j+*"* r ] " + N(m,s) ;
Xwhile( s = strtok(0,wcs)) {
X       if( o[ C ] . e == 
X                         G) E(1 ,m,o[C] .X) ;
X       S(o[C
X             ] .w[o[C ] .e].g,s, z);
X       Q= C ;
X       if(! ( s =strtok ( 0 ,wcs )))wcw --
X       ,E( 2 , m, o[C]
X                   . w[ o[ Q ] .e] . g );
X       e
X         = o[C ] .w[o[C ] .e++ ] .b= N(m,s)
X       ; wcw += 2; }  
X     0&& 
X        W && wcl++
X                  < 10 && printf((W,Y)); }
X   if(j+28) { {
X                ; } printf("%7u%7u%7u\n", wcl , wcw , wcc); }
X   while( gets(Y) ) if(A(Y)) puts(Y);
X   W, jr; }
X
XO(int wc,char**V) {
X--wc && (printf("%s ",*++V), main(wc,V), 1) || printf("\n"); }
X
END_OF_FILE
  if test 2583 -ne `wc -c <'1992/adrian.c'`; then
    echo shar: \"'1992/adrian.c'\" unpacked with wrong size!
  fi
  # end of '1992/adrian.c'
fi
if test -f '1992/albert.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/albert.c'\"
else
  echo shar: Extracting \"'1992/albert.c'\" \(3164 characters\)
  sed "s/^X//" >'1992/albert.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <malloc.h>
X#include <setjmp.h>
X#include <ctype.h>
X#define new(PP) (PP *) malloc(sizeof(PP)) 
Xtypedef struct q {
X    jmp_buf ppp;
X    long qq;
X    struct q *P;
X    struct q *p;
X} 
XPP;
X
XPP *P;
Xint aaaaaa=2;
Xint aaaaaaa=1;
X
Xlong qqq;
X
X
XaaAaaa(aa,aaa)
Xchar *aa;
Xchar *aaa;
X{
X    char aaaa = 0;
X    if ((((( aaa )))))
X    {
X        aaaa = *aa;
X        *aa=0;
X        aa+=strlen(aa+1);
X        P =new(PP);
X        P->P=P;
X        P->p=P;
X    }
X
X    if ((((( !setjmp(P->ppp) ))))) 
X        {
X        if ((((( !isdigit(*aa) )))))
X            longjmp(P->ppp,aaaaaaa);
X        else {
X            P->p->P = new(PP);
X            P->p->P->P = P;
X            P->p->P->p = P->p;
X            P->p = P->p->P;
X
X            P->qq = *aa--;
X            P = P->p;
X            aaAaaa(aa,0);
X        }
X    } else {
X        if ( !aaaa&&!*aa ) 
X           longjmp(P->p->ppp,aaaaaaa);
X
X        if ((((( (P->qq=aaaa)<10     &&!
X                 (isdigit(aaaa))     ||!
X                 (isdigit(*aa)       ||!
X                 *aa                        )))))) 
X        {
X            fprintf(stderr,"Usage %c%s <number>\n",
X            (aaa[0]?7:aaaa),aaa+!aaa[0]);
X            exit(1);
X        }
X    }
X}
X
X
XppPppp(pp,ppp)
XPP **pp, *ppp;
X{
X    int aa;
X    if ((((( !(aa=setjmp(ppp->ppp))||aa==aaaaaa )))))
X    {
X        if ((((( *pp==ppp )))))
X        {
X            ppp = (*pp)->p;
X
X            if ( qqq<47 ) return;
X            if ( ppp->qq!=48 ) return;
X
X            while ( ppp->qq==48 ) 
X            {
X                printf("%ld\n",qqq-45);
X                *pp = ppp;
X                ppp = ppp->p;
X            }
X            qqq -= 1;
X            longjmp(ppp->ppp,aaaaaaa);
X        } else {
X            PP *p;
X
X            ppPppp(pp,ppp->p);
X            for (p=ppp;p!=*pp;p=p->p)
X            {
X                int qq=4;
X                if ((((( qqq<47                            &&
X                         (qq=0,p->qq+=p->p->qq-96)>=48-qqq ||
X                         qqq>46                            &&
X                         (p->qq-=p->p->qq)<0                   ))))) 
X                {
X                    p->qq += qqq+qq;
X                    if ( p->p==P && qqq<=46 )
X                    {
X                        P->p->P = new(PP);
X                        P->p->P->P = P;
X                        P->p->P->p = P->p;
X                        *pp = P = P->p = P->p->P;
X                        P->qq = 48;
X                    }
X
X                    p->p->qq+=qq==0;
X                    p->p->qq-=qq!=0;
X                }
X                else
X                {
X                    p->qq += 48;
X                }
X            }
X            if ( ppp->P==P ) longjmp(ppp->ppp,aaaaaaa);
X        }
X    }
X    else
X    {
X        qqq += 1; 
X
X        while (48==P->qq )
X        {
X            P->P->p = P->p;
X            P = P->p->P = P->P;
X
X        }
X
X        if ( ppp!=ppp->p->p || qqq<47 )
X            longjmp(ppp->ppp,aaaaaa);
X        else
X        {
X            printf("At most one remains\n");
X            exit(0);
X        }
X    }
X}
X
X
Xmain(aaa,aaaa)
Xint aaa;
Xchar **aaaa;
X{
X    aaAaaa(aaa==aaaaaaa?aaaa[0]:aaaa[1],aaaa[0]);
X    qqq = 39;
X    ppPppp(&P,P->p);
X}
X
X
END_OF_FILE
  if test 3164 -ne `wc -c <'1992/albert.c'`; then
    echo shar: \"'1992/albert.c'\" unpacked with wrong size!
  fi
  # end of '1992/albert.c'
fi
if test -f '1992/albert.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/albert.hint'\"
else
  echo shar: Extracting \"'1992/albert.hint'\" \(3193 characters\)
  sed "s/^X//" >'1992/albert.hint' <<'END_OF_FILE'
XMost Useful Program: <albert%bsovax@sun4nl.nluug.nl> Albert van der Horst
X
X	Albert van der Horst
X	S P&A R&C
X	Oranjestraat 8
X	3511 RA   UTRECHT
X	The Netherlands
X
X
XJudges' comments:
X
X    For a canned example:
X	make albert
X	albert 1234567890123456789
X    
X    We were impressed with the speed at which it was able to factor
X    arbitrarily large numbers consisting of factors that fit into
X    a long.
X
X
XSelected notes from the author:
X
X    The Obfuscated version of the Horst algorithm.
X
X    This program will factor unlimited length numbers and print the 
X    factors in ascending order. Numbers of one digit (e.g. 8) 
X    are rejected without notice.
X    It quits as soon as there is at most one
X    factor left, but that factor will not be shown. 
X    It accomplishes this efficiently, without resorting to division
X    or multiplication, until the candidate factor no longer fits in 
X    a signed long. 
X
X    The nicest way is to rename the program into e.g. 4294967297
X    if you want to factor Fermat's 4th number. Then just run it.
X    Or you may type "prog <some-number>"
X    A nice one is also (30 ones)
X    albert 111111111111111111111111111111
X
X    Apart from the foregoing there are no special execution instructions.
X
X    To customize the program into a factorizer of a fixed number, use
X    cc albert.c -o 4294967297
X    or some such.
X
X    There are no data files used, and it is not possible to feed input
X    via stdin.
X
X    I think this program is a nice example of algorithmic obfuscation.
X    Several times two similar algorithms are merged into one. Then you 
X    need quite some tricks to get it running, such as long jumps 
X    through recursive subroutines. I felt like a sword smith, 
X    welding the sword very long, folding it again to the proper 
X    length, keep on hammering till it is tight, then fold again.
X    Always keeping it at the proper red hot temperature, but not too
X    hot lest the hardness fades.
X    The strict naming conventions for subroutines did not make things 
X    much clearer after all, but it was not supposed to.
X
X    I would like to draw attention to the robustness of the program
X    with respect to error handling and the nice stopping criterion.
X    The esthetic appeal of some lines is at the expense of clearness, 
X    I apologize.
X    Running the program through the c-beautifier reveals nothing,
X    it will only destroy some of the lay out.
X    Running the program through lint shows the usual remarks for a
X    K&R program. Defeating this through casts does not make a program 
X    cleaner in my opinion.
X
X    Here are some hints, but they may not be too helpful.
X    1. The Horst algorithm is described in the Hobby Computer Club 
X	Newsletter, year 82, part 4, a real Dutch treat.
X       Assembler, c and Forth version have been around for some years.
X    2. Does fractal programming exist after all?
X    3. You remember the ToomCook algorithm in Knuth?
X       It uses iteration instead of recursion and is quite jumpy.
X       This program shares these disadvantages in a modified form.
X    4. The Conversion is to be found in Knuth, not so the Observation.
X       The Observation: "if it ends in a zero, it is divisible by ten"
END_OF_FILE
  if test 3193 -ne `wc -c <'1992/albert.hint'`; then
    echo shar: \"'1992/albert.hint'\" unpacked with wrong size!
  fi
  # end of '1992/albert.hint'
fi
if test -f '1992/ant.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/ant.c'\"
else
  echo shar: Extracting \"'1992/ant.c'\" \(2547 characters\)
  sed "s/^X//" >'1992/ant.c' <<'END_OF_FILE'
X#define W while
X#define S strspn 
X#define R return 
X#define F fprintf(stderr,
X#define C continue;
X
X#include <stdlib.h>
X#include <stdio.h>
X#include <string.h>
X#include <sys/stat.h>
X
X#ifndef RULES
X#define RULES	500
X#endif
X
X#define N(p, i)	(p += i, p += S(p, w), i = strcspn(p, w))
X
Xchar *b, l[BUFSIZ], *t[RULES], *d[RULES], *c[RULES], w[] = "\n\t ";
X
Xtime_t M();
Xint T();
Xvoid U();
X
X
Xtime_t
XM(f)
Xchar *f;
X{
X	int j, x;
X	size_t i = 0;
X	struct stat s;
X	N(f, i);
X	x = f[i];
X	f[i] = 0; 
X	j = stat(f, &s);
X	f[i] = x;
X	R j < 0 ? 0 : s.st_mtime;
X}
X
Xint
XT(f)
Xchar *f;
X{
X	char *q;
X	size_t i = 0, j, k = 1;
X	N(f, i);
X	W ((q = t[k])) {
X		j = 0;
X		W (N(q, j)) {
X			if (i == j && !strncmp(f, q, i))
X				R k;
X		}
X		++k;
X	}
X	R 0;
X}
X
Xvoid
XU(f)
Xchar *f;
X{
X	time_t t = M(f);
X	size_t i = 0, j = !t, k = T(f);
X	char *p = d[k], *q = c[k];
X	if (!N(p, i) && q && *q != '\t' && j) {
X		F "am: Don't know how to make '%s'.\n", f);
X		exit(1);
X	}
X	W (0 < i) {
X		U(p);
X		if (t < M(p))
X			j = 1;
X		N(p, i);
X	}
X	if (j && q && *q == '\t') {
X		sleep(1);
X		W (*q++ == '\t') {
X			i = j = 1;
X			W (0 < S(q, "-+@")) {
X				if (*q == '@')
X					
X					i = 0;
X				if (*q++ == '-')
X					
X					j = 0;
X			}
X			if (i)
X				puts(q);
X			if (system(q) && j) {
X				F "am: Error making '%s'\n", f);
X				exit(1);
X			}
X			q += strlen(q) + 1;
X		}
X		c[k] = 0;
X	}
X}
X
Xint
Xmain(u, v)
Xint u;
Xchar **v;
X{
X	FILE *f;
X	struct stat s;
X	size_t i, j, k;
X	char *m, *n, *p, *q, *r;
X	if (u < 2) {
X		F "usage: am <makefile> [target]\n");
X		R 2;
X	}
X	if (stat(*++v, &s) || !(f = fopen(*v, "r")))
X		R 3;
X	q = b = malloc(2*s.st_size);
X	if (!b)
X		R 4;
X	i = 1;
X	k = 0;
X	m = 0;
X	*t = *d = *c = "";
X	W ((r = fgets(l, BUFSIZ, f))) {
X		if (RULES <= i) {
X			F "am: Number of target-rules exceeds %d.\n", RULES);
X			R 1;
X		}
X		if (k) {
X			*q++ = ' ';
X			r += S(r, w);
X		} else {
X			if (t[i])
X				c[i++] = q;
X			if (m && putenv(m))
X				F "am: No more environment space.\n");
X			m = 0;
X			if (*l == '#' || *l == '\n')
X				C
X			p = q;
X		}
X		W (!(k = *r == '\\' && r[1] == '\n') && *r) {
X			if (*r == '$') {
X				if (r[1] == '(') {
X					n = r+2;
X					r += strcspn(r, ")");
X					*r++ = 0;
X					n = getenv(n);
X					if (n) 
X						q = strcpy(q, n) + strlen(n);
X					C
X				}
X				if (*r == r[1])
X					++r;
X			} 
X			if (*r == '=' && *l != '\t' && !m) {
X				*q = 0;
X				m = p;
X				j = 0;
X				q = N(m, j) + m;
X				*q++ = *r;
X				j = 1;
X				if (!N(r, j))
X					*q++ = 0;
X				C
X			}
X			if (*r == ':') {
X				t[i] = p;
X				*r = 0;
X				d[i] = q+1;
X			}
X			if (*r == '\n')
X				*r = 0;
X			*q++ = *r++;
X		}
X	}
X	fclose(f);
X	U(2 < u ? *++v : t[1]);
X	R 0;
X}
X
END_OF_FILE
  if test 2547 -ne `wc -c <'1992/ant.c'`; then
    echo shar: \"'1992/ant.c'\" unpacked with wrong size!
  fi
  # end of '1992/ant.c'
fi
if test -f '1992/ant.test.mk' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/ant.test.mk'\"
else
  echo shar: Extracting \"'1992/ant.test.mk'\" \(3164 characters\)
  sed "s/^X//" >'1992/ant.test.mk' <<'END_OF_FILE'
X#
X#	Test makefile for AM
X#
X
X#
X#  Allow for empty macros.
X#
XEMPTY=
X
X#
X#  Allow for white space in macro assignment.
X#
XTEXT_1=no white space
XTEXT_2 =left hand side
XTEXT_3= right hand side
XTEXT_4 = both sides
XTEXT_5	=	tabs boths sides
X
X#
X#  Test psuedo targets.
X#
Xall : print_macros repeat redefine many flags multiple split errors done
X
Xprint_macros : empty t1 t2 t3 t4 t5 t.all
X
X#
X#  Targets with no dependencies.
X#
Xempty :
X	echo EMPTY='$(EMPTY)'
X
Xt1 :
X	echo TEXT_1='$(TEXT_1)'
X
Xt2 :
X	echo TEXT_2='$(TEXT_2)'
X
Xt3 :
X	echo TEXT_3='$(TEXT_3)'
X
Xt4 :
X	echo TEXT_4='$(TEXT_4)'
X
Xt5 :
X	echo TEXT_5='$(TEXT_5)'
X
Xt.all :
X	echo $(TEXT_1) $(TEXT_2) $(TEXT_3) $(TEXT_4) $(TEXT_5)
X
X#
X#  Test redefinition of macros.  AM allows redefinition and 
X#  evaluates macros immediately.
X#
XTEXT_1	=text number 1
XTEXT_2	= test macro split \
X	across lines \
X	three lines
XTEXT_3	= test dollar macro '$$'
XTEXT_4	= test dollar again "$$(TEXT_1)"
XTEXT_5	=	imbeded macro '$(TEXT_1)'
X
Xredefine : r1 r2 r3 r4 r5 
X
Xr1 :
X	echo TEXT_1='$(TEXT_1)'
X
Xr2 :
X	echo TEXT_2='$(TEXT_2)'
X
Xr3 :
X	echo TEXT_3='$(TEXT_3)'
X
Xr4 :
X	echo TEXT_4='$(TEXT_4)'
X
Xr5 :
X	echo TEXT_5='$(TEXT_5)'
X
X#
X#  Try to update a prerequisite more than once.  Subsequent occurences
X#  should be ignored once a prerequisite has been updated.
X#
Xrepeat: t1 repeat.a t3
Xrepeat.a : t2 t1
X
X
X#
X#  Target with multi-line receipe.
X#
Xmany : leaf.1 leaf.2
X	echo Execute receipe with multiple commands.
X	ls -1 leaf.*
X	echo Last line of receipe for target 'many'.
X
Xleaf.1 :
X	touch leaf.1
X
Xleaf.2 : 
X	touch leaf.2
X
X
X#
X#  Test receipe line flags.
X#
Xflags : silence ignore always combination
X
X#  Command not displayed before execution.
Xsilence :
X	echo You should not see the 'ls' command printed. 
X	@ls leaf.*
X
X#  Ignore errors from command.
Xignore :
X	echo The 'ls' command should fail but not terminate AM.
X	-ls unknown
X
X#  This flag is ignored by AM since we don't support a silence option (-n).
Xalways :
X	+echo The '+' flag is accepted and ignored.
X
Xcombination:
X	-@echo The next displayed line should not be 'ls unknown'
X	@-ls unknown
X	@+-echo Combined flags test completed.
X
X
X#
X#  Multiple targets.
X#
Xmultiple : node.2 node.5
X
Xnode.1 node.2 node.3 : leaf.1 leaf.2
X	touch node.1 node.2 node.3
X
Xnode.4 node.5 : node.2 leaf.3 
X	touch node.4 node.5
X
Xleaf.3 :
X	touch leaf.3
X
X
X#
X#  Test split lines.
X#
Xsplit : node.6 leaf.4 split.cmd
X	echo Completed split line tests.
X
X#  Target dependencies split across lines.
Xnode.6 : leaf.1 \
X	leaf.2 \
X	leaf.3
X	echo Test dependency list split across lines.
X	touch node.6
X
X#  Target list split across lines.
Xsplit.tar \
Xleaf.4 \
Xleaf.5 :
X	echo Test target list split across lines
X	touch leaf.4 leaf.5 
X
X#  Command lines split across lines.
Xsplit.cmd:
X	echo Try spliting command \
X		lines across more \
X	than one line.
X
X
X#
X#  Test AM error reports and exit statuses.
X#
Xerrors:
X	-am test.mk error.1
X	-am test.mk error.2
X	-am test.mk error.3
X	
X#  Target that does not exist, has no dependencies, and no commands.
Xerror.1:
X
X#  Target where dependency does not exist.
Xerror.2: unknown
X
X#  Receipe command causes error.
Xerror.3: t1 fail t2
Xfail:
X	ls -l unknown
X
X
X#
X#
X#
Xdone:
X	echo AM Test Complete
X
Xclean:
X	rm leaf.* node.*
END_OF_FILE
  if test 3164 -ne `wc -c <'1992/ant.test.mk'`; then
    echo shar: \"'1992/ant.test.mk'\" unpacked with wrong size!
  fi
  # end of '1992/ant.test.mk'
fi
if test -f '1992/buzzard.1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/buzzard.1.c'\"
else
  echo shar: Extracting \"'1992/buzzard.1.c'\" \(2236 characters\)
  sed "s/^X//" >'1992/buzzard.1.c' <<'END_OF_FILE'
X#define A(c,a,b) t=b;t+=a;_(c)
X#define	B(b,a) P(u,a)t=0;t-=a;R t+=u;t+=1;t/=2;_(b)
X#define b(x) x(g)
X#define C ;main(argc,argv)char**argv;{for(;!w;){q=0;l
X#define c(y) x
X#define D(c,a,b) t=a;t/=b;_(c)
X#define d(x) S(x,x,1)
X#define E(a,d) t=d;t-=p;t*=r;t*=a;p+=t;t=1;t-=a;r*=t;
X#define e(x) y
X#define f(x) x(e)
X#define G(x,y) Q(x,atoi(argv[y]))
X#define g(x) x(b)
X#define H Q(w,1)Q(p,0)r=0;
X#define h(x) x(c)
X#define i(c,a,b) a(b,b,c)
X#define J(x) Q(p,x)r=0;
X#define j(x) Q(f(g),x)
X#define K(x) Q(x,argc)
X#define k(x) S(a,y,x)
X#define L(x) u=p;u-=x;t=u;t*=u;R r+=2;r-=t;r/=2;
X#define l L(q) q+=1;
X#define M(c,a,b) t=a;t*=b;_(c)
X#define m(x) x(a,a)
X#define n(x) x(a,y)
X#define O(c,a,b) t=b;t+=1;t+=a;t/=2;Q(c,t)
X#define o(x,y) M(x,x,y)
X#define P(b,a) t=a;R _(b)
X#define R t+=2047;t/=2048;t+=8191;t/=8192;
X#define Q(a,b) t=b;_(a)
X#define S(c,a,b) t=a;t-=b;_(c)
X#define T }
X#define U(c,a,b) u=b;t=b;t-=1;t*=r;t+=1;b=t;t=a;t/=b;b=u;_(c)
X#define V int t,u,q,p=0,r,w=0,
X#define X(y) printf("%x\n",y);
X#define Z(a,d) t=p;t-=d;t*=a;t+=d;_(p)r*=a;
X#define _(a) t-=a;t*=r;a+=t;
X
XV a,x,y,s C
X
X	    G(f(g),q)G(          g(h),2)n(B)Z(a,4)n(
X	P)E(a,1)j(2989)H l k     (1)m(B)Z(a,6)l k(h(b))
X      B(s,a             )m(P)        Z(s             ,8)E
X    (a,q                   )Q(       s,h               (g)
X   )Q(                               f(c                ),f
X  (g)                                )j(                s)l
X  i(b                                (h)                ,S,
X f(b                                 ))n               (B)
X E(a                                 ,2)             J(8)
Xl j(                                x)Q(x,1)l n(P)Z(a,8
X)o(x                                ,g(f))d(f(e))J(5)l j
X(x)l                                 d(x              )S(a
X ,x,                                 1)m                (B)
X  Z(a                                ,10                 )U(
X  a,y                                ,x)                 o(a
X   ,x)                               k(a                 )m(
X    P)E(                   a,7)      l j                (0)
X      Q(s,1            )l D(a        ,x,              q)o(
X	a,q)S(a,h(g),a)i(s,       M,a)i(a,A,g(f))i(q,D,x
X	    )o(s,16)B(a          ,x)E(a,9)H l j(2766)H
X
XT  X(b(f))  T
END_OF_FILE
  if test 2236 -ne `wc -c <'1992/buzzard.1.c'`; then
    echo shar: \"'1992/buzzard.1.c'\" unpacked with wrong size!
  fi
  # end of '1992/buzzard.1.c'
fi
if test -f '1992/buzzard.2.orig.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/buzzard.2.orig.c'\"
else
  echo shar: Extracting \"'1992/buzzard.2.orig.c'\" \(794 characters\)
  sed "s/^X//" >'1992/buzzard.2.orig.c' <<'END_OF_FILE'
X#define c 0 [m] ++ [m] =
X#define z;break;case
X
Xchar s[5000];
Xint m[20000]={32},L=1,I,T[500],*S=T,t=64,w,f;
X
Xa(x)
X{
X   c L;
X   L= *m-1;
X   c t;
X   c x;
X   scanf("%s",s+t);
X   t+=strlen(s+t)+1;
X}
X
Xr(x)
X{
X   switch(x++[m]){
X	z 5:	for(w=scanf("%s",s)<1?exit(0):L;strcmp(s,&w[&m[1]][s]);w=m[w]);
X		w-1 ? r(w+2) : (c 2,c atoi(s))
X	z 12:	I=1[m]--[m]
X	z 15:	f=S[-f]
X	z 1:	c x 
X	z 9:	f *=* S--
X	z 7:	m[f]= *S--;
X		f= *S--
X	z 0:	*++S=f;
X		f=I++[m]
X	z 8:	f= *S --- f
X	z 2:	m[++1[m]]=I;
X		I=x
X	z 11:	f=0>f
X	z 4:	*m-=2;c 2
X	z 6:	f=f[m]
X	z 10:	f= *S--/f
X	z 3:	a(1);
X		c 2
X	z 13:	putchar(f);
X		f= *S--
X	z 14:	*++S=f;
X		f=getchar();
X   }
X}
X
Xmain()
X{
X   a(3);
X   a(4);
X   a(1);
X   w= *m;
X   c 5;
X   c 2;
X   I= *m;
X   c w;
X   c I-1;
X   for(w=6;w<16;)
X      a(1),c w++;
X   m[1]= *m;
X   for(*m+=512;;r(m[I++]));
X}
END_OF_FILE
  if test 794 -ne `wc -c <'1992/buzzard.2.orig.c'`; then
    echo shar: \"'1992/buzzard.2.orig.c'\" unpacked with wrong size!
  fi
  # end of '1992/buzzard.2.orig.c'
fi
if test -f '1992/help.th' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/help.th'\"
else
  echo shar: Extracting \"'1992/help.th'\" \(1774 characters\)
  sed "s/^X//" >'1992/help.th' <<'END_OF_FILE'
X: help key  ( flush the carriage return form the input buffer )
X
X" The following are the standard known words; words marked with (*) are
Ximmediate words, which cannot be used from command mode, but only in
Xword definitions.  Words marked by (**) declare new words, so are always
Xfollowed by the new word.
X
X	! @		fetch, store
X	+ - * / mod	standard arithmetic operations
X	= < > <= >=	standard comparison operations
X
X	not		boolean not of top of stack
X	logical		turn top of stack into 0 or 1
X
X	dup over	duplicate the top of stack or second of stack
X	swap drop	reverse top two elements or drop topmost
X
X	inc dec		increment/decrement the value at address from stack
X	add		add a value from 2nd of stack into address from top
X
X	echo key	output character from, or input to, top of stack
X	. #		print out number on top of stack without/with cr
X	cr		print a carriage return
X
X[more]" key
X" (**)	var		declare variable with initial value taken from stack
X(**)	constant	declare constant with initial value taken from stack
X(**)	array		declare an array with size taken from stack
X
X(*)	if...else...then	FORTH branching construct
X(*)	do...loop		FORTH looping construct
X	i j			loop values (not variables)
X
X	print		print the string pointed to on screen
X
X(*)(**) :		declare a new THIRD word
X(*)	<build does>	declare a data types compile-time and run-time
X(*)	;		terminate a word definition
X
X[more]" key
X" Advanced words:
X	here		current location in dictionary
X	h		pointer into dictionary
X	r		pointer to return stack
X	fromr tor	pop a value from or to the return stack
X
X	,		write the top of stack to dictionary
X	'		store the address of the following word on the stack
X	allot		leave space on the dictionary
X
X	::		compile a ':' header
X	[		switch into command mode
X	]		continue doing : definitions
X" ;
END_OF_FILE
  if test 1774 -ne `wc -c <'1992/help.th'`; then
    echo shar: \"'1992/help.th'\" unpacked with wrong size!
  fi
  # end of '1992/help.th'
fi
if test -f '1992/imc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/imc.c'\"
else
  echo shar: Extracting \"'1992/imc.c'\" \(1965 characters\)
  sed "s/^X//" >'1992/imc.c' <<'END_OF_FILE'
X#include		     <stdio.h> 
X#include		     <malloc.h> 
X#define			  ext(a) (exit(a),0)
X#define I		  " .:\';+<?F7RQ&%#*"
X#define a			"%s?\n"
X#define n			"0?\n"
X#define C			double	
X#define o			 char
X#define l			 long
X#define L			sscanf
X#define i			stderr
X#define e			stdout
X#define r		       ext   (1)
X#define s(O,B)	   L(++J,O,&B)!=1&&c>++q&&L(v[q],O,&B)!=1&&--q
X#define F(U,S,C,A) t=0,*++J&&(t=L(J,U,&C,&A)),(!t&&c>++q&&!(t=L(v[q],U,\
X		   &C,&A)))?--q:(t<2&&c>++q&&!(t=L(v[q],S,&A))&&--q
X#define T(E)		(s("%d",E),E||(fputs(n,i),r))
X#define d(C,c)		  (F("%lg,%lg","%lg",C,c)))
X#define O	   (F("%d,%d","%d",N,U),(N&&U)||(fputs(n,i),r)))
X#define D		      (s("%lg",f))
X#define E			  putc
X					       C
X						G=0,
X						R
X					     =0,Q,H
X					    ,M,P,z,S
X					     =0,x=0
X				 ,        f=0;l b,j=0,	      k
X				  =128,K=1,V,B=0,Y,m=128,p=0,N
X				 =768,U=768,h[]={0x59A66A95,256
X			     ,192,1,6912,1,0,0},t,A=0,W=0,Z=63,X=23
X			    ;o*J,_;main(c,v)l c;o**v;{l q=1;for(;;q<
X		  c	   ?(((J=v[q])[0]&&J[0]<48&&J++,((_= *J)<99||
X		_/2==	   '2'||(_-1)/3=='\"'||_==107||_/05*2==','||_
X	      >0x074)?(   fprintf(i,a,v[q]),r):_>0152?(_/4>27?(_&1?(
X	     O,Z=N,X=U):  (W++,N=Z,U=X)):_&1?T(K):T(k)):_>103?(d(G,
X	R    ),j=1):_&1? d(S,x):D,q++),q--,main(c-q,v+q)):A==0?(A=
X  1,f||(f=N/4.),b=(((N-1)&017)<8),q=(((N+7)>>3)+b)*U,(J=malloc(q)
X  )||(perror("malloc"),r),S-=(N/2)/f,x+=(U/2)/f):A==1?(B<U?(A=2,V
X	=    0,Q=x-B/f,j ||(R=Q),W&&E('\n',e),E(46,i)):(W&&E('\n',
X	     e),E('\n',i  ),h[1]=N,h[2]=U,h[4]=q,W||(fwrite(h,1,32,
X	      e),fwrite   (J,1,q,e)),free(J),ext(0))):A==2?(V<N?(j?
X		(H=V/f	   +S,M=Q):(G=V/f+S,H=M=0),Y=0,A=03):((m&0x80
X		   )	   ||(m=0x80,p++),b&&(J[p++]=0),A=1,B++)):((Y
X			    <k&&(P=H*H)+(z=M*M)<4.)?(M=2*H*M+R,H=P-z
X			     +G,Y++):(W&&E(I[0x0f*(Y&K)/K],e),Y&K?J
X			         [p]&=~m:(J[p]|=m),(m>>=1)||/*/
X				  (m=128,u--),A==6?ext(1):B<u
X				 .	  e=3,l=2*c*/(       m
X					     =0x80,
X					    p++),V++
X					     ,A=0x2
X						)
X						));
X					       }
END_OF_FILE
  if test 1965 -ne `wc -c <'1992/imc.c'`; then
    echo shar: \"'1992/imc.c'\" unpacked with wrong size!
  fi
  # end of '1992/imc.c'
fi
if test -f '1992/imc.orig.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/imc.orig.c'\"
else
  echo shar: Extracting \"'1992/imc.orig.c'\" \(1937 characters\)
  sed "s/^X//" >'1992/imc.orig.c' <<'END_OF_FILE'
X#include		     <stdio.h> 
X#include		     <malloc.h> 
X#define I		  " .:\';+<?F7RQ&%#*"
X#define a			"%s?\n"
X#define n			"0?\n"
X#define C			double	
X#define o			 char
X#define l			 long
X#define L			sscanf
X#define i			stderr
X#define e			stdout
X#define r		      exit   (1)
X#define s(O,B)	   L(++J,O,&B)!=1&&c>++q&&L(v[q],O,&B)!=1&&--q
X#define F(U,S,C,A) t=0,*++J&&(t=L(J,U,&C,&A)),(!t&&c>++q&&!(t=L(v[q],U,\
X		   &C,&A)))?--q:(t<2&&c>++q&&!(t=L(v[q],S,&A))&&--q
X#define T(E)		(s("%d",E),E||(fputs(n,i),r))
X#define d(C,c)		  (F("%lg,%lg","%lg",C,c)))
X#define O	   (F("%d,%d","%d",N,U),(N&&U)||(fputs(n,i),r)))
X#define D		      (s("%lg",f))
X#define E			  putc
X					       C
X						G=0,
X						R
X					     =0,Q,H
X					    ,M,P,z,S
X					     =0,x=0
X				 ,        f=0;l b,j=0,	      k
X				  =128,K=1,V,B=0,Y,m=128,p=0,N
X				 =768,U=768,h[]={0x59A66A95,256
X			     ,192,1,6912,1,0,0},t,A=0,W=0,Z=63,X=23
X			    ;o*J,_;main(c,v)l c;o**v;{l q=1;for(;;q<
X		  c	   ?(((J=v[q])[0]&&J[0]<48&&J++,((_= *J)<99||
X		_/2==	   '2'||(_-1)/3=='\"'||_==107||_/05*2==','||_
X	      >0x074)?(   fprintf(i,a,v[q]),r):_>0152?(_/4>27?(_&1?(
X	     O,Z=N,X=U):  (W++,N=Z,U=X)):_&1?T(K):T(k)):_>103?(d(G,
X	R    ),j=1):_&1? d(S,x):D,q++),q--,main(c-q,v+q)):A==0?(A=
X  1,f||(f=N/4.),b=(((N-1)&017)<8),q=(((N+7)>>3)+b)*U,(J=malloc(q)
X  )||(perror("malloc"),r),S-=(N/2)/f,x+=(U/2)/f):A==1?(B<U?(A=2,V
X	=    0,Q=x-B/f,j ||(R=Q),W&&E('\n',e),E(46,i)):(W&&E('\n',
X	     e),E('\n',i  ),h[1]=N,h[2]=U,h[4]=q,W||(fwrite(h,1,32,
X	      e),fwrite   (J,1,q,e)),free(J),exit(0))):A==2?(V<N?(j?
X		(H=V/f	   +S,M=Q):(G=V/f+S,H=M=0),Y=0,A=03):((m&0x80
X		   )	   ||(m=0x80,p++),b&&(J[p++]=0),A=1,B++)):((Y
X			    <k&&(P=H*H)+(z=M*M)<4.)?(M=2*H*M+R,H=P-z
X			     +G,Y++):(W&&E(I[0x0f*(Y&K)/K],e),Y&K?J
X			         [p]&=~m:(J[p]|=m),(m>>=1)||/*/
X				  (m=128,u--),A==6?exit(1):B<u
X				 .	  e=3,l=2*c*/(        m
X					     =0x80,
X					    p++),V++
X					     ,A=0x2
X						)
X						));
X					       }
END_OF_FILE
  if test 1937 -ne `wc -c <'1992/imc.orig.c'`; then
    echo shar: \"'1992/imc.orig.c'\" unpacked with wrong size!
  fi
  # end of '1992/imc.orig.c'
fi
if test -f '1992/kivinen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/kivinen.c'\"
else
  echo shar: Extracting \"'1992/kivinen.c'\" \(2119 characters\)
  sed "s/^X//" >'1992/kivinen.c' <<'END_OF_FILE'
X#include						       <X11/Xlib.h>
X#define							 ext(a) (exit(a),0)
X# define		     X(	    x,v,y) XMoveWindow(d,s[x],(v)*z,(y)*z)
X#  define		     _		ButtonPressMask|ButtonReleaseMask
X#   define		     I(		     x,y) XSelectInput(d,s[x],y)
X#    define		     N(		      v) (XMapWindow(d,s[v]),v)
X#     define		     V			  VisibilityChangeMask
X#      define		     A			  XCreateSimpleWindow
X#	define		     D			    DefaultScreen(d)
X#	 define		     E			   r.xbutton.button
X#	  define	     R			    BlackPixel(d,D)
X#	   define	     S			    r.xvisibility
X
X	      int main(a)int a;{Window s[53];int w,u,i,c,y,l=0
X	  ,q,e=32,t,k,j=~0,z=(a+1)/2,x=a&1,v=z&1;XEvent r;Display*
X	d=XOpenDisplay("");s[0]=A(d,DefaultRootWindow(d),200,200,(x&
X       v?330:120)*z,215*z,2,R,R);I(N(c=0),_);for(;c<(x?32:52);c++){s[
X       c+1]=A(d,s[0],x	      ?c*20*z:(c-1)%10	      *12*z,x?-20*z:(
X      c-1)/10*12*z,x		?z*(c^31?10:		2):z*10*(c?1:2
X      ), x& v?z*10:	 (c	 &&!x?10:1+	 x)	 *z,k =q=1, R,
X      WhitePixel(d     ,D));I	  (N(c+1),     V);}X(	  N(1),y=(x&v)
X      *115+50,x*70+	 60	 ); X(N(c--	 )+	 1,x?-10:(i=y)
X      ,u=!x*130-20);		while(c &&e<		160){if(x){if(
X      v){l=!(e &32)*9;	      for(w=30; w--;){	      if(s[w+2]){ k=w%
X      10;l=e&32?k>l?k:l:k<l?k:l;X(w+2,10+k *20+q,(w/10)*20+e);}}l*=20;
X      e&31?e++:e&32?(q++,(q+l>300?e++:0)):(q--,q+l<10?e++:0); } u>140?
X      ext(c):u>-20?X(32,i,u-=(v?5:-1 )) :(!v?(u =5,srandom(time(0)),i=
X      random()%88+6):0); } else{k>0?i+=(i>105?k= -k:k):(i+=(i<1?k= -k:
X      k)); j>0?u	 +=(u>140?ext(++c):j):(u+=(u	    <1?j= -j:j
X      )); X(		    52,i,u);}XSync(d,0);		while(
X      XCheckMaskEvent(d	      ,_|V,&r))if(!(r.	     type==ButtonPress
X      ?(E&1||!x||!v?t=E*4-8			 :u<0?i=y+4,u=122:1):r
X      .type==ButtonRelease&&E?t=0,1:r.type^VisibilityNotify|S.state^1)
X      )for(x&v?(u=	     -15),w++:(w=0);++w		  <52-x*20;)if
X      (s[w]		      ==S.window)x&&v||			 w ^1?
X      XUnmapWindow		   (d,s[w])		  ,s[w]=0,c--:
X      0,l=1; if(!x&&l)j=			    -j,l=0; if(l&x&&!v
X      )u=~19,c--,l=0;t=(!x||!v)		     &&(y<5&&t<0||y>95&&t>0)?0
X	  :t;s[1]?X(1,y+=x&v?t:t/(x+1),130):ext(++c);};return(c);}
END_OF_FILE
  if test 2119 -ne `wc -c <'1992/kivinen.c'`; then
    echo shar: \"'1992/kivinen.c'\" unpacked with wrong size!
  fi
  # end of '1992/kivinen.c'
fi
if test -f '1992/kivinen.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/kivinen.hint'\"
else
  echo shar: Extracting \"'1992/kivinen.hint'\" \(2547 characters\)
  sed "s/^X//" >'1992/kivinen.hint' <<'END_OF_FILE'
XBest X Program: <kivinen@hut.fi> Tero Kivinen
X
X	Tero Kivinen
X	Helsinki University of Technology
X	Klovinrinne 6b
X	02180 Espoo
X	Finland
X
X
XJudges' comments:
X
X    If your machine support the X Window System, Version 11:
X	make kivinen
X
X    The type of entertainment depends on number of arguments
X    you have with the program.  :-)
X
X    NOTE: Some systems do not need (or have) -lsocket -lresolv -lnsl.
X	  Such systems should compile using -lX11.
X
X    NOTE: The original winning source kivinen.orig.c assumed that
X	  exit returned a value which cause problems for some
X	  systems where exit returned a void.  The file kivinen.c
X	  avoids this problem.
X	
X
XSelected notes from the author:
X
X    X Entertainment Kit
X
X    This kit includes three games from the early of video games for
X    The X Window System Version 11 Release 5. It should work with
X    earlier releases, though.
X
X
X    Space Invaders
X
X    The classic game of shooting aliens from outer space, trying to
X    exterminate all life on earth. The game ends when the first line
X    of aliens touches the ground, or destroy you. To win the game you
X    must destroy all the aliens. If you evade out from the screen you
X    lose.
X
X        Controls:
X                Button 1 = Move left
X                Button 2 = Fire missile
X                Button 3 = Move right
X
X
X    Breakout
X
X    Break all the bricks with the ball, using your paddle. If you miss
X    the ball the game ends.
X
X        Controls:
X                Button 1 = Move left
X                Button 3 = Move right
X
X
X    Dropout
X
X    Catch all the falling pieces, before they reach the ground. If you
X    miss it, game ends. To win you must catch all 30 pieces.
X
X        Controls:
X                Button 1 = Move left
X                Button 3 = Move right
X
X
X
X    Starting the game
X
X    The type of the game is determined by the number of arguments
X    given to the program.
X
X        no arguments = Space Invaders
X        1 argument   = Breakout
X        2 arguments  = Dropout
X        3 arguments  = double sized Breakout
X        4 arguments  = triple sized Space Invaders
X        5 arguments  = triple sized Breakout
X        6 arguments  = double sized Dropout
X        7 arguments  = quadruple sized Breakout
X        and so on...
X
X
X    Scores
X
X    The exit value of the game is your score. The smaller the score
X    the better it is. The exit value of zero means you have won.
X
X
X    Features
X
X    The game has a cheat system, which can be found after examining the
X    event loop at the end of program. It is not a bug, it's a feature!
X
END_OF_FILE
  if test 2547 -ne `wc -c <'1992/kivinen.hint'`; then
    echo shar: \"'1992/kivinen.hint'\" unpacked with wrong size!
  fi
  # end of '1992/kivinen.hint'
fi
if test -f '1992/kivinen.orig.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/kivinen.orig.c'\"
else
  echo shar: Extracting \"'1992/kivinen.orig.c'\" \(2084 characters\)
  sed "s/^X//" >'1992/kivinen.orig.c' <<'END_OF_FILE'
X#include						       <X11/Xlib.h>
X# define		     X(	    x,v,y) XMoveWindow(d,s[x],(v)*z,(y)*z)
X#  define		     _		ButtonPressMask|ButtonReleaseMask
X#   define		     I(		     x,y) XSelectInput(d,s[x],y)
X#    define		     N(		      v) (XMapWindow(d,s[v]),v)
X#     define		     V			  VisibilityChangeMask
X#      define		     A			  XCreateSimpleWindow
X#	define		     D			    DefaultScreen(d)
X#	 define		     E			   r.xbutton.button
X#	  define	     R			    BlackPixel(d,D)
X#	   define	     S			    r.xvisibility
X
X	      int main(a)int a;{Window s[53];int w,u,i,c,y,l=0
X	  ,q,e=32,t,k,j=~0,z=(a+1)/2,x=a&1,v=z&1;XEvent r;Display*
X	d=XOpenDisplay("");s[0]=A(d,DefaultRootWindow(d),200,200,(x&
X       v?330:120)*z,215*z,2,R,R);I(N(c=0),_);for(;c<(x?32:52);c++){s[
X       c+1]=A(d,s[0],x	      ?c*20*z:(c-1)%10	      *12*z,x?-20*z:(
X      c-1)/10*12*z,x		?z*(c^31?10:		2):z*10*(c?1:2
X      ), x& v?z*10:	 (c	 &&!x?10:1+	 x)	 *z,k =q=1, R,
X      WhitePixel(d     ,D));I	  (N(c+1),     V);}X(	  N(1),y=(x&v)
X      *115+50,x*70+	 60	 ); X(N(c--	 )+	 1,x?-10:(i=y)
X      ,u=!x*130-20);		while(c &&e<		160){if(x){if(
X      v){l=!(e &32)*9;	      for(w=30; w--;){	      if(s[w+2]){ k=w%
X      10;l=e&32?k>l?k:l:k<l?k:l;X(w+2,10+k *20+q,(w/10)*20+e);}}l*=20;
X      e&31?e++:e&32?(q++,(q+l>300?e++:0)):(q--,q+l<10?e++:0); } u>140?
X      exit(c):u>-20?X(32,i,u-=(v?5:-1)):(!v?(u =5,srandom(time(0)),i=
X      random()%88+6):0); } else{k>0?i+=(i>105?k= -k:k):(i+=(i<1?k= -k:
X      k)); j>0?u	+=(u>140?exit(++c):j):(u+=(u	    <1?j= -j:j
X      )); X(		    52,i,u);}XSync(d,0);		while(
X      XCheckMaskEvent(d	      ,_|V,&r))if(!(r.	     type==ButtonPress
X      ?(E&1||!x||!v?t=E*4-8			 :u<0?i=y+4,u=122:1):r
X      .type==ButtonRelease&&E?t=0,1:r.type^VisibilityNotify|S.state^1)
X      )for(x&v?(u=	     -15),w++:(w=0);++w		  <52-x*20;)if
X      (s[w]		      ==S.window)x&&v||			 w ^1?
X      XUnmapWindow		   (d,s[w])		  ,s[w]=0,c--:
X      0,l=1; if(!x&&l)j=			    -j,l=0; if(l&x&&!v
X      )u=~19,c--,l=0;t=(!x||!v)		     &&(y<5&&t<0||y>95&&t>0)?0
X	 :t;s[1]?X(1,y+=x&v?t:t/(x+1),130):exit(++c);};return(c);}
END_OF_FILE
  if test 2084 -ne `wc -c <'1992/kivinen.orig.c'`; then
    echo shar: \"'1992/kivinen.orig.c'\" unpacked with wrong size!
  fi
  # end of '1992/kivinen.orig.c'
fi
if test -f '1992/lush.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/lush.c'\"
else
  echo shar: Extracting \"'1992/lush.c'\" \(1885 characters\)
  sed "s/^X//" >'1992/lush.c' <<'END_OF_FILE'
X#define f 000:
X          char
X	  *s,*
X	  t,v;
X	  char 
X	  _  [
X	  999]
X	  ,x [
X	  999]
X	  ,*p=
X	  x  ;
X	  char
X	  *av[
X	  ]= {
X	  "W",
X	  "H",
X	  "o",
X	  "l",
X	  "N",
X	  "e",
X	  " ",
X	  "r",
X	  "d",
X	  ".",
X	  "m",
X          "s",
X          "g",
X          "!",
X          "*",
X          "\n"
X	  }  ;
X	   int 
X	  n= 0
X	  ;int 
X	  __ =
X	  0,i=
X	  000;
X	  main
X	  () {
X#define f 001:
X#define F 042:
X#define f 100:
X         _[i--
X#define f 126:
X#define f 132:
X#define f 103:
X#define f 202:
X#define f 666:
X#define f 77::
X#define f 101:
X	   ]=0
X#define f 232:
X#define f 151:
X	  ;if(
X#define f 256:
X          !i){
X          puts
X          ("I"
X          "BM"
X          " S"
X          "UX"
X          );;;
X          ;;;}
X	  ;for
X	  (  ;
X	  gets
X	  (_);
X	  )  {
X	  for(
X#define f 301:
X	  t=_,
X#define f 700:
X#define f 999:
X	  s=t,
X#define f 77 :
X#define f 300:
X	  s=t;
X#define f s=t;
X#define f 123:
X#define f 127:
X	  *t&&
X	  !(!(
X	  *t <
X	  '0'
X	  ||*t
X	  >'9'
X	  )&&!
X          ((t[
X          1] ^
X          ':')
X          &&(t
X          [1]^
X          '.')
X	  )) ; 
X	  t++)
X#define f 137:
X#define f 133:
X	  ;if(
X#define f 111:
X#define f 220:
X          v^*t
X          &&*t
X	  ){v=
X          *t;;
X          n=n*
X	  2+(1
X	  &*t)
X	  ;__=
X	  (__+
X	  1)&3
X	  ; __
X	  ||((
X	  n<15
X	  &&(*
X	  p= *
X	  av[n
X	  ] ),
X#define f 2+2:
X	  p++)
X	  ,n=0
X	  );}}
X#define f ==4:
X	  ;*p=
X	  '\0'
X	  ;;;;
X#define f puts
X	  puts
X	  (x);
X	  s=t;
X#define f s=5;
X	  s=t;
X#define f s=5:
X	  s=t;
X#define f 445:
X#define f 113:
X#define f 900:
X	  s=t;
X#define f n22:
X#define f n40:
X	  s=t;
X#define f nn6:
X	  s=t;
X#define f nn1:
X#define f 0:--
X	  s=t;
X#define f 19:-
X#define f x2:x
X	  s=t;
X#define f x1:x
X	  s=t;
X#define f y2:x
X#define f y7:y
X	  s=t;
X#define f 1:::
X	  s=t;
X#define f @3:@
X#define f 10:0
X#define f x+1:
X	  s=t;
X#define f 2:::
X#define f 3:::
X#define x 7:::
X#define y 3:::
X#define z 990:
X#define Z 47::
X	  ;;;}
X
END_OF_FILE
  if test 1885 -ne `wc -c <'1992/lush.c'`; then
    echo shar: \"'1992/lush.c'\" unpacked with wrong size!
  fi
  # end of '1992/lush.c'
fi
if test -f '1992/lush.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/lush.hint'\"
else
  echo shar: Extracting \"'1992/lush.hint'\" \(695 characters\)
  sed "s/^X//" >'1992/lush.hint' <<'END_OF_FILE'
XWorst Abuse of the C Preprocessor: <lush@erc.msstate.edu> Ed Luke
X
X	Ed Luke
X	Mississippi State University
X	P.O. Box 6176
X	Mississippi State, MS 39762, USA
X
X
XJudges' comments:
X
X    To setup:
X	make lush
X    
X    Try:
X	make lush.again 2>&1 | lush		(sh or ksh users)
X    or:
X	make lush.again |& lush			(csh users)
X
X    The program uses error messages issued by the C Proproessor to
X    generate its message to the world.  One program's error is another 
X    program's data!
X
X
XSelected notes from the author:
X
X    This program is yet another "Hello World." program with a twist.  The
X    string Hello World has been encoded in the error messages the compiler
X    generates when compiling the source.
END_OF_FILE
  if test 695 -ne `wc -c <'1992/lush.hint'`; then
    echo shar: \"'1992/lush.hint'\" unpacked with wrong size!
  fi
  # end of '1992/lush.hint'
fi
if test -f '1992/lush.orig.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/lush.orig.c'\"
else
  echo shar: Extracting \"'1992/lush.orig.c'\" \(1885 characters\)
  sed "s/^X//" >'1992/lush.orig.c' <<'END_OF_FILE'
X#define f 000:
X          char
X	  *s,*
X	  t,v;
X	  char 
X	  _  [
X	  999]
X	  ,x [
X	  999]
X	  ,*p=
X	  x  ;
X	  char
X	  *av[
X	  ]= {
X	  "W",
X	  "H",
X	  "o",
X	  "l",
X	  "N",
X	  "e",
X	  " ",
X	  "r",
X	  "d",
X	  ".",
X	  "m",
X          "s",
X          "g",
X          "!",
X          "*",
X          "\n"
X	  }  ;
X	   int 
X	  n= 0
X	  ;int 
X	  __ =
X	  0,i=
X	  000;
X	  main
X	  () {
X#define f 001:
X#define F 042:
X#define f 100:
X          i--[
X#define f 126:
X#define f 132:
X#define f 103:
X#define f 202:
X#define f 666:
X#define f 77::
X#define f 101:
X	  _]=0
X#define f 232:
X#define f 151:
X	  ;if(
X#define f 256:
X          !i){
X          puts
X          ("I"
X          "BM"
X          " S"
X          "UX"
X          );;;
X          ;;;}
X	  ;for
X	  (  ;
X	  gets
X	  (_);
X	  )  {
X	  for(
X#define f 301:
X	  t=_,
X#define f 700:
X#define f 999:
X	  s=t,
X#define f 77 :
X#define f 300:
X	  s=t;
X#define f s=t;
X#define f 123:
X#define f 127:
X	  *t&&
X	  !(!(
X	  *t <
X	  '0'
X	  ||*t
X	  >'9'
X	  )&&!
X          ((t[
X          1] ^
X          ':')
X          &&(t
X          [1]^
X          '.')
X	  )) ; 
X	  t++)
X#define f 137:
X#define f 133:
X	  ;if(
X#define f 111:
X#define f 220:
X          v^*t
X          &&*t
X	  ){v=
X          *t;;
X          n=n*
X	  2+(1
X	  &*t)
X	  ;__=
X	  (__+
X	  1)&3
X	  ; __
X	  ||((
X	  n<15
X	  &&(*
X	  p= *
X	  av[n
X	  ] ),
X#define f 2+2:
X	  p++)
X	  ,n=0
X	  );}}
X#define f ==4:
X	  ;*p=
X	  '\0'
X	  ;;;;
X#define f puts
X	  puts
X	  (x);
X	  s=t;
X#define f s=5;
X	  s=t;
X#define f s=5:
X	  s=t;
X#define f 445:
X#define f 113:
X#define f 900:
X	  s=t;
X#define f n22:
X#define f n40:
X	  s=t;
X#define f nn6:
X	  s=t;
X#define f nn1:
X#define f 0:--
X	  s=t;
X#define f 19:-
X#define f x2:x
X	  s=t;
X#define f x1:x
X	  s=t;
X#define f y2:x
X#define f y7:y
X	  s=t;
X#define f 1:::
X	  s=t;
X#define f @3:@
X#define f 10:0
X#define f x+1:
X	  s=t;
X#define f 2:::
X#define f 3:::
X#define x 7:::
X#define y 3:::
X#define z 990:
X#define Z 47::
X	  ;;;}
X
END_OF_FILE
  if test 1885 -ne `wc -c <'1992/lush.orig.c'`; then
    echo shar: \"'1992/lush.orig.c'\" unpacked with wrong size!
  fi
  # end of '1992/lush.orig.c'
fi
if test -f '1992/marangon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/marangon.c'\"
else
  echo shar: Extracting \"'1992/marangon.c'\" \(1766 characters\)
  sed "s/^X//" >'1992/marangon.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <curses.h>
X
X#define ST strchr
X#define SRD srand48
X#define RD lrand48
X#define ext(a) (exit(a),0)
X
X#define Q return
X#define W wrefresh(r)
Xtypedef int i;
X
X#define Z(d,a) (RD()%((a)-(d)+1)+(d))
Xi f[3][3] = {15,52,36,20,-39,48,60,0,-25};
X
Xchar z[6][6];
X#define Y(x) (4*(x)+3)
X#define X(x) (2*(x)+1)
X#define I for
XWINDOW *r=NULL;
X#define K endwin()
X
Xchar *g ="\
XUse l-h-k-j for move.\nUse + for increment. Use - for decrement.\nUse Q to quit.";
X
Xi (*d())();
Xnt()
X{
Xlong time();
XSRD(time((i *)0));
Xmemset(z,5,36);
Xinitscr();
Xcbreak();
Xnoecho();
Xnonl();
Xif (COLS<80||LINES<24)
XK,ext(1);
Xif (!(r=newwin(X(6),Y(6),
X(LINES-X(6))/2,(COLS-Y(6))/2)))
XK,ext(1);
Xmvaddstr(LINES-5,0,g);
Xrefresh();
X}
Xi ci()
X{
Xi x,y=0;
XI (;y<6;++y)
XI(x=0;x<6;++x)
Xmvwaddch(r,X(y),Y(x),z[x][y]+'0'); Q(0);
X}
Xvoid main()
X{
Xchar *ST();
Xi a=0,b=0,c,q,t,s,x,sc=0;
Xi(*(*p)())()=(nt(),d);
XI(x=0 ; x++<20; )d(Z(0,5),Z(0,5),Z(1,2));
XI(t=Z(0,2),q=s=0; q<3; s+=f[q][t]*f[q++][t]);
XI(box(r,'|','-'),ci(),wmove(r,X(a),Y(b)),
XW; (ST ("+-Qlkjh",(char)(c=wgetch(r))))&&
X((i)((i)(q^=s%=Y(q),s/=2)!=(i)(s^=q)&&c&64&&(!(c&7|0)&&--b<0&&
X(b=q^s)&0|| c&4&&++b==6&&c&4<(~b&23?q^=s,b^=b
X:b&12?b=3:b|2)||c&2&&~c&1&&++a==++q/2+1&&c&16>(
X!a|12?a=7,a&=~a:a|4?a=2:a&2)||~c&4&&c&
X1&&--a<0&&(a+=6)&0)||~c&64&&(**p(b,a,~c))()||
Xc&16)?K,ext(0):1)||c; sc==36?ci(),W,K,ext(0):wmove(r,X(a),Y(b)),
XW)
XI(t=Z(0,2),q=s=0; q<3; s+=f[q][t]*f[q++][t])
XI(sc=0; sc<36&&*((char *)z+sc++)==5; );
X}
Xi (*d(a,b,c))()i a,b,c;
X{
Xi x,y;
XI(x=a>0?a-1:0; x<=(a<5?a+1:5); ++x)
XI(y=b>0?b-1:0; y<=(b<5?b+1:5); ++y)
Xif(x==a&&y==b&&z[x][y]==(c&2?1:9)||z[x][y]==(c&2?9:1)&&(x!=a||y!=b))Q(ci);
XI(x=a>0?a-1:0; x<=(a<5?a+1:5); x++)
XI(y=b>0?b-1:0; y<=(b<5?b+1:5)&&(x==a&&y==b&&(z[x][y]+=(c&2?-1:1))||(z[x][y]+=(c&2?1:-1))); y++); Q(ci);
X}
END_OF_FILE
  if test 1766 -ne `wc -c <'1992/marangon.c'`; then
    echo shar: \"'1992/marangon.c'\" unpacked with wrong size!
  fi
  # end of '1992/marangon.c'
fi
if test -f '1992/marangon.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/marangon.hint'\"
else
  echo shar: Extracting \"'1992/marangon.hint'\" \(1062 characters\)
  sed "s/^X//" >'1992/marangon.hint' <<'END_OF_FILE'
XBest Game: <marangon@ghost.dsi.unimi.it> Marangoni Andrea
X
X	Marangoni Andrea
X	Department of Computer Science at Milano
X	Via Pausula, 72
X	62014 Corridonia (MC)
X	Italy
X
X
XJudges' comments:
X
X    Make and run.
X
X    The object is to refill the table with 5's, by incrementing
X    or decrementing numbers as needed.  It is the side effects
X    that get you into trouble.  If you are not careful, you may
X    find things "at 6's and 7's".  :-)
X
X    NOTE: Some compilers have had trouble optimizing this entry.
X
X    NOTE: Some systems need to compile with -ltermcap as well as -lcurses.
X
X    NOTE: The original winning source marangon.orig.c assumed that
X	  exit returned a value which cause problems for some
X	  systems where exit returned a void.  The file marangon.c
X	  avoids this problem.
X
X
XSelected notes from the author:
X
X    It starts off by creating a table with number 5 in all places.  The
X    CPU melts the numbers and you must return them in original state.
X    When you increase a number, all the other eight numbers next to it
X    decrease and vice-versa.
END_OF_FILE
  if test 1062 -ne `wc -c <'1992/marangon.hint'`; then
    echo shar: \"'1992/marangon.hint'\" unpacked with wrong size!
  fi
  # end of '1992/marangon.hint'
fi
if test -f '1992/marangon.orig.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/marangon.orig.c'\"
else
  echo shar: Extracting \"'1992/marangon.orig.c'\" \(1743 characters\)
  sed "s/^X//" >'1992/marangon.orig.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <curses.h>
X
X#define ST strchr
X#define SRD srand48
X#define RD lrand48
X
X#define Q return
X#define W wrefresh(r)
Xtypedef int i;
X
X#define Z(d,a) (RD()%((a)-(d)+1)+(d))
Xi f[3][3] = {15,52,36,20,-39,48,60,0,-25};
X
Xchar z[6][6];
X#define Y(x) (4*(x)+3)
X#define X(x) (2*(x)+1)
X#define I for
XWINDOW *r=NULL;
X#define K endwin()
X
Xchar *g ="\
XUse l-h-k-j for move.\nUse + for increment. Use - for decrement.\nUse Q to quit.";
X
Xi (*d())();
Xnt()
X{
Xlong time();
XSRD(time((i *)0));
Xmemset(z,5,36);
Xinitscr();
Xcbreak();
Xnoecho();
Xnonl();
Xif (COLS<80||LINES<24)
XK,exit(1);
Xif (!(r=newwin(X(6),Y(6),
X(LINES-X(6))/2,(COLS-Y(6))/2)))
XK,exit(1);
Xmvaddstr(LINES-5,0,g);
Xrefresh();
X}
Xi ci()
X{
Xi x,y=0;
XI (;y<6;++y)
XI(x=0;x<6;++x)
Xmvwaddch(r,X(y),Y(x),z[x][y]+'0'); Q(0);
X}
Xvoid main()
X{
Xchar *ST();
Xi a=0,b=0,c,q,t,s,x,sc=0;
Xi(*(*p)())()=(nt(),d);
XI(x=0 ; x++<20; )d(Z(0,5),Z(0,5),Z(1,2));
XI(t=Z(0,2),q=s=0; q<3; s+=f[q][t]*f[q++][t]);
XI(box(r,'|','-'),ci(),wmove(r,X(a),Y(b)),
XW; (ST ("+-Qlkjh",(char)(c=wgetch(r))))&&
X((i)((i)(q^=s%=Y(q),s/=2)!=(i)(s^=q)&&c&64&&(!(c&7|0)&&--b<0&&
X(b=q^s)&0|| c&4&&++b==6&&c&4<(~b&23?q^=s,b^=b
X:b&12?b=3:b|2)||c&2&&~c&1&&++a==++q/2+1&&c&16>(
X!a|12?a=7,a&=~a:a|4?a=2:a&2)||~c&4&&c&
X1&&--a<0&&(a+=6)&0)||~c&64&&(**p(b,a,~c))()||
Xc&16)?K,exit(0):1)||c; sc==36?ci(),W,K,exit(0):wmove(r,X(a),Y(b)),
XW)
XI(t=Z(0,2),q=s=0; q<3; s+=f[q][t]*f[q++][t])
XI(sc=0; sc<36&&*((char *)z+sc++)==5; );
X}
Xi (*d(a,b,c))()i a,b,c;
X{
Xi x,y;
XI(x=a>0?a-1:0; x<=(a<5?a+1:5); ++x)
XI(y=b>0?b-1:0; y<=(b<5?b+1:5); ++y)
Xif(x==a&&y==b&&z[x][y]==(c&2?1:9)||z[x][y]==(c&2?9:1)&&(x!=a||y!=b))Q(ci);
XI(x=a>0?a-1:0; x<=(a<5?a+1:5); x++)
XI(y=b>0?b-1:0; y<=(b<5?b+1:5)&&(x==a&&y==b&&(z[x][y]+=(c&2?-1:1))||(z[x][y]+=(c&2?1:-1))); y++); Q(ci);
X}
END_OF_FILE
  if test 1743 -ne `wc -c <'1992/marangon.orig.c'`; then
    echo shar: \"'1992/marangon.orig.c'\" unpacked with wrong size!
  fi
  # end of '1992/marangon.orig.c'
fi
if test -f '1992/nathan.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/nathan.c'\"
else
  echo shar: Extracting \"'1992/nathan.c'\" \(878 characters\)
  sed "s/^X//" >'1992/nathan.c' <<'END_OF_FILE'
X#include <stdio.h>
Xstatic char *text[] =
X{
X  "Export of this program from the USA is governed by the US",
X  "Munitions List from the ITAR (International Traffic in Arms",
X  "Regulations). This list gives the specific categories of",
X  "restricted exports and includes cryptographic exports. Traffic",
X  "entirely external to, entirely internal to, or into the USA is",
X  "not restricted.",
X  "To obtain a copy of the program, email to nathan@inmos.co.uk",
X  "with a subject \"IOCCC request\". If you know that your 'From'",
X  "line is incorrect, add a single line",
X  "\"replyto you@your.correct.address\" to the body of the message.",
X  "A deamon will autoreply.",
X  "WARNING: You must not re-export this out of the USA, or else",
X  "the men in black might get you.",
X  NULL
X};
Xint main()
X{
X  char **ptr;
X
X  for(ptr = text; *ptr; ptr++)
X    printf("%s\n", *ptr);
X  return 0;
X}
END_OF_FILE
  if test 878 -ne `wc -c <'1992/nathan.c'`; then
    echo shar: \"'1992/nathan.c'\" unpacked with wrong size!
  fi
  # end of '1992/nathan.c'
fi
if test -f '1992/vern.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/vern.c'\"
else
  echo shar: Extracting \"'1992/vern.c'\" \(3203 characters\)
  sed "s/^X//" >'1992/vern.c' <<'END_OF_FILE'
X#include <stdio.h>
X;	m(x)(x<0?-1:!!x)
X;	g tj()-J
X;	a(x)(x<0?-x:x)
X;	h(x)((x)<=K?x:N-(x))
X;	f 9999
X;	A return
X;	H printf{ 
X;	R double
X;	U int
X;	V for
X;	b else
X;	u while
X;	B if
XU v,w,Y}	 -1,W,J,p,F,o}	f,M,N,K,X,YY,_,P[f],s{ } ;
Xtypedef U{ *L} { } ;
XL q[f];
Xtj{ } {
XU S}	m{ v} +{ m{ w} <<K} ; 
XB{ !S} A J; 
XV{ v}	W+S; v!}	J&&!q[v]; v+}	S} ;
XA v; 
X}
Xk{ } {
X_}	K; 
XA v?a{ v} >1||w-Y||!q[J]:{ w-Y&&{ w-Y*2||q[W+Y*{ N+1} ]||
X    { J>>K} -K+{ Y-1} / 2} } ||q[J]; 
X}
Xz{ } {
X_}	5; 
XA v*w||g; 
X}
Xe{ } {
X_}	 -2; 
XA{ v*v*v-v||w*w*w-w} &&{ J-W-2||{ W&N} -4||{ W>>K!}	{ Y-1?N:0} } ||
X    q[W+1]||q[W+2]||q[W+K]!}	z||P[W+K]*Y<0} ; 
X}
XR VR{ } {
Xint PZ}	0x7fff; 
XA{ R} { rand{ } &PZ} /{ R} PZ; 
X}
Xl{ } {
X_}	K+1; 
XA{ v*w&&a{ v} -a{ w} } ||g; 
X}
XR UC{ } {
XR {	}	0,d; 
Xu{ { {	+}	d}	VR{ } } <1.0} ; 
XA d; 
X}
Xc{ } {
X_}	 -11; 
XA a{ v} -a{ w} ||g; 
X}
XI{ ur,n,x} {
XW}	ur; 
XJ}	n; 
XB{ P[W]!}	Y||P[J]}	}	Y} A J+1;
Xv}	{ J&N} -{ W&N} ; 
Xw}	{ J>>K} -{ W>>K} ; 
XA q[W]{ } ||{ x&&QL{ W,J,s} } ; 
X}
XTT{ W} {
Xv}	w}	0; 
XA q[W]{ } +K; 
X}
Xs{ } {
XU j}	 -1,{	; 
XY}	 -Y; 
XV{ {	}	0; {	<M; ++{	} {
XB{ j<0&&P[{	]}	}	 -Y&&TT{ {	} &&_}	}	 -2} 
X{
Xj}	{	; 
X{	}	 -1; 
X}
Xb B{ j>}	0&&!I{ {	,j,0} } A Y}	 -Y; 
X}
XA!{ Y}	 -Y} ; 
X}
Xbb{ } {
X_}	1; 
XA a{ v*w} -2; 
X}
Xuv{ } {
XV{ v}	0; v<f; ++v} {
XB{ h{ v>>K} }	}	0} {
XU S}	h{ v&N} ;
Xq[v]}	!S?z:{ S}	}	1?bb:{ S}	}	2?c:{ v&N>K?l:e} } } ; 
X}
Xb B{ h{ v>>K} }	}	1} q[v]}	k; 
Xb q[v]}	0;
XP[v]}	!!q[v]*{ 28-v} ; 
X}
X}
Xy{ } {
XU G}	Y,{	; 
XJ}	0; 
XV{ {	}	0; {	<M; ++{	} {
X{	%8||H"\n%4o ",{	} ;
XB{ { Y}	P[{	]}	m{ P[{	]} } &&
XTT{ {	} } H"%c ",_+93+Y*16} ; 
Xb H"- "} ; 
X}
XH"\n    "} ; 
Xdo 
XH"%2d",{	++&N} ; 
Xu{ {	&N} ; 
XY}	G; 
XH"\n"} ; 
X}
XO{ W,J} {
XB{ { q[J]}	q[W]} }	}	k&&h{ J>>K} }	}	0} q[J]}	l; 
XB{ q[W]}	}	e} B{ J-W}	}	2} O{ J+1,J-1} ;
Xb B{ W-J}	}	2} O{ W-1,W+1} ; 
XP[J]}	P[W]; 
Xq[W]}	0;
XP[W]}	0; 
X}
XQL{ W,J,D} L D; 
X{
XU HQ}	P[J],YX; 
XL AJ}	q[J],XY}	q[W]; 
XO{ W,J} ; 
XYX}	D{ } ;
XO{ J,W} ; 
Xq[J]}	AJ; 
Xq[W]}	XY; 
XP[J]}	HQ; 
XA YX; 
X}
XC{ } {
XU {	,j,BZ}	0; 
XV{ {	}	0; {	<M; ++{	} {
XL Z}	q[{	]; 
XB{ Z} {
XU r}	h{ {	>>K} +h{ {	&N} ,G}	Y,
X    S}	Z}	}	z?88:{ Z}	}	k?11
X+r+{ P[{	]<0?N-{ {	>>K} :{ {	>>K} } :
X{ Z}	}	l?124-{ { YY<8&&{ { {	&N} !}	K||
X    { {	>>K} !}	{ P[{	]>0?0:N} } } ?M:0} :
X{ Z}	}	c?41+r:{ Z}	}	e?f-r-r:36+r+r} } } } ; 
XY}	P[{	];
XV{ j}	0; j<M; ++j} B{ !I{ {	,j,0} } S+}	{ P[j]?5:1} ; 
XBZ+}	G}	}	Y?S:-S;
XY}	G; 
X}
X}
XB{ !{ ++X&M-1} } write{ 1,".",1} ; 
XA BZ; 
X}
XPX{ } {
XU {	,Q}	0,XP}	0,JZ}	M*M,E}	 -f,t,S}	o; 
XB{ !F--} A++F+C{ } ;
XV{ {	}	0; {	<JZ; ++{	} B{ !I{ {	>>K+K,{	&M-1,1} } {
XY}	 -Y; 
Xo}	 -E;
Xt}	 -QL{ {	>>K+K,{	&M-1,PX} ; 
XY}	 -Y; 
XB{ t>E} {
X++XP; 
XQ}	{	; 
XE}	t; 
XB{ E>}	S} 
XA++F,E; 
X}
X}
XB{ !XP} E}	s{ } ?-f+1:0; 
Xp}	Q; 
XA++F,E; 
X}
XRZ{ } {
XU {	,j,T}	0; 
XV{ ; ; } {
Xy{ } ; 
Xo}	f; 
Xdo{
XH"\n%d %d %d %s ",X,T,C{ } ,s{ } ?"!":">"} ;
Xfflush{ stdout} ; 
X}
Xu{ scanf{ "%o%o",&{	,&j} !}	2||I{ {	,j,1} } ;
XO{ {	,j} ; 
Xy{ } ; 
XX}	0; 
X++YY;
XY}	 -Y; 
XT}	PX{ } ; 
X{	}	p>>{ K<<1} ; 
Xj}	p&{ M-1} ; 
XB{ I{ {	,j,1} } {
XH"Rats!\n"} ; 
XA; 
X}
XO{ {	,j} ; 
XY}	 -Y; 
XB{ T>M*M} H"\nHar har.\n"} ; 
X}
X}
Xmain{ ac,av} char**av; 
X{
Xlong time{ } ,j}	time{ &j} ; 
XR {	}	0; 
Xsrand{ { U} j} ;
XV{ M}	0; M<}	f; ++M} {	+}	UC{ } ; 
XM}	{	/100;
XB{ M&3} ++M; 
XB{ M&1} --M; 
XV{ N}	1; N*N<M; ++N} ;
XK}	 --N/2; 
XF}	ac>1?atoi{ av[1]} :2; 
Xuv{ } ;
XRZ{ } ; 
X}
END_OF_FILE
  if test 3203 -ne `wc -c <'1992/vern.c'`; then
    echo shar: \"'1992/vern.c'\" unpacked with wrong size!
  fi
  # end of '1992/vern.c'
fi
echo shar: End of archive 4 \(of 5\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
