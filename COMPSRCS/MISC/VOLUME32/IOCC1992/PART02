Newsgroups: comp.sources.misc
From: chongo@toad.com (Landon Curt Noll)
Subject:  v32i029:  ioccc.1992 - 1992 International Obfuscated C Code Contest winners, Part02/05
Message-ID: <1992Sep10.154310.27096@sparky.imd.sterling.com>
X-Md4-Signature: b08cc8eace3e6682a3ae4932cae42c5d
Date: Thu, 10 Sep 1992 15:43:10 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: chongo@toad.com (Landon Curt Noll)
Posting-number: Volume 32, Issue 29
Archive-name: ioccc.1992/part02
Environment: C

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  1992/Makefile 1992/ant.README 1992/buzzard.1.hint
#   1992/buzzard.2.hint 1992/demo1.1st 1992/gson.hint 1992/rules
# Wrapped by kent@sparky on Thu Sep 10 10:21:20 1992
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 5)."'
if test -f '1992/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/Makefile'\"
else
  echo shar: Extracting \"'1992/Makefile'\" \(5632 characters\)
  sed "s/^X//" >'1992/Makefile' <<'END_OF_FILE'
X# %W% %G% %U%
X#
X# 1992 makefile
X
XSHELL=/bin/sh
XCHMOD=chmod
XCP=cp
XRM=rm
XSED=sed
XLN=ln
XUNIQ=uniq
XCB=cb 
XGREP=grep
X# set this to where your C Processor resides
X#
X# On some systems:
X#	CPP=/lib/cpp
X#
XCPP=/usr/ccs/lib/acpp
X
X# flags for ansi compiles
X#
X# NOTE: Some ANSI compilers make use of -Xa to turn on ANSI mode,
X#	others such as gcc may want -ansi, others may want nothing
X#	at all.  Adjust the CFLAGS line as needed.
X#
X# NOTE: Some compilers cannot optimize, or optimize some entries
X#	entries incorrectly.  You might want need to turn on -O 
X#	to see if your compiler can handle them.
X#
X#CFLAGS=-O -Xa
XCFLAGS=-Xa
XCC=cc
X
X# misc shell babble
X#
XNOINCLUDE=$(SED) -e 's/^.\([	 ]*\)include/%include/'
XSPACECLEAN=$(SED) -e 's/\([^	 ]\)\([	 ]\)[ 	][ 	]*/\1\2/g'
XCPPCLEAN=$(GREP) -v '^. [0-9][0-9]*'
X
X# winners that compile under ANSI C
X#
XWINNERS= adrian albert ant buzzard.1 buzzard.2 gson kivinen imc \
X	lush marangon nathan vern westley
XALT_NAMES= adgrep am babble first ag whereami
X
Xall: $(WINNERS) $(ALT_NAMES)
X
Xadrian: adrian.c
X	$(CC) $(CFLAGS) adrian.c -o adrian
X	$(RM) -f ad.temp adwc.c adbasename.c adecho.c adhead.c adsleep.c
X	$(SED) '1s/\..*\./. wc ./' adrian.c > ad.temp
X	-./adrian ad.temp <ad.temp >adwc.c
X	$(CC) -o adwc adwc.c
X	$(SED) '1s/\..*\./. basename ./' adrian.c > ad.temp
X	-./adrian ad.temp <ad.temp >adbasename.c
X	$(CC) -o adbasename adbasename.c
X	$(SED) '1s/\..*\./. echo| ./' adrian.c > ad.temp
X	-./adrian ad.temp <ad.temp >adecho.c
X	$(CC) -o adecho adecho.c
X	$(SED) '1s/\..*\./. head; ./' adrian.c > ad.temp
X	-./adrian ad.temp <ad.temp >adhead.c
X	$(CC) -o adhead adhead.c
X	$(SED) '1s/\..*\./. sleep ./' adrian.c > ad.temp
X	-./adrian ad.temp <ad.temp >adsleep.c
X	$(CC) -o adsleep adsleep.c
X	$(RM) -f ad.temp
X
X# NOTE: this is the original source that won
X#
Xadrian.orig: adrian.orig.c
X	$(CC) $(CFLAGS) adrian.orig.c -o adrian.orig
X
Xalbert: albert.c
X	$(CC) $(CFLAGS) albert.c -o albert
X
X# NOTE: this is the original source that won
X#
Xalbert.orig: albert.orig.c
X	$(CC) $(CFLAGS) albert.orig.c -o albert.orig
X
Xant: ant.c
X	$(CC) $(CFLAGS) ant.c -o ant
X
Xbuzzard.1: buzzard.1.c
X	$(CC) $(CFLAGS) buzzard.1.c -o buzzard.1
X
Xbabble.cppcb: buzzard.1.c
X	$(NOINCLUDE) buzzard.1.c | \
X	    $(CPP) $(CPPFLAGS) | \
X	    $(CPPCLEAN) | \
X	    $(CB) $(CBFLAGS) | \
X	    $(UNIQ) | \
X	    $(SPACECLEAN) > babble.cppcb 2>&1
X
Xbuzzard.2: buzzard.2.c
X	$(CC) $(CFLAGS) buzzard.2.c -o buzzard.2
X
X# NOTE: this is the original source that won
X#
Xbuzzard.2.orig: buzzard.2.orig.c
X	$(CC) $(CFLAGS) buzzard.2.orig.c -o buzzard.2.orig
X
Xgson: gson.c
X	$(CC) $(CFLAGS) gson.c -o gson
X
X# NOTE: some systems may only need:
X#
X#  $(CC) $(CFLAGS) kivinen.c -o kivinen -lX11
X#
Xkivinen: kivinen.c
X	$(CC) $(CFLAGS) kivinen.c -o kivinen -lX11 -lsocket -lresolv -lnsl
X
X# NOTE: this is the original program that won
X#
X# NOTE: some systems may only need:
X#
X#  $(CC) $(CFLAGS) kivinen.c -o kivinen -lX11
X#
Xkivinen.orig: kivinen.orig.c
X	$(CC) $(CFLAGS) kivinen.orig.c -o kivinen.orig -lX11 \
X	    -lsocket -lresolv -lnsl
X
Ximc: imc.c
X	$(CC) $(CFLAGS) imc.c -o imc
X
X# NOTE: this is the original program that won
X#
Ximc.orig: imc.orig.c
X	$(CC) $(CFLAGS) imc.orig.c -o imc.orig
X
Xlush: lush.c
X	$(CC) $(CFLAGS) lush.c -o lush
X
Xlush.again: lush.c
X	$(CC) $(CFLAGS) lush.c -o lush.again
X	$(RM) -f lush.again
X
X# NOTE: this is the original program that won
X#
Xlush.orig: lush.orig.c
X	$(CC) $(CFLAGS) lush.orig.c -o lush.orig
X
X# NOTE: some systems may need:
X#
X#  $(CC) $(CFLAGS) marangon.c -o marangon -lcurses -ltermcap
X#
Xmarangon: marangon.c
X	$(CC) $(CFLAGS) marangon.c -o marangon -lcurses
X
X# NOTE: this is the original program that won
X#
X# NOTE: some systems may need:
X#
X#  $(CC) $(CFLAGS) marangon.orig.c -o marangon.orig -lcurses -ltermcap
X#
Xmarangon.orig: marangon.orig.c
X	$(CC) $(CFLAGS) marangon.orig.c -o marangon.orig -lcurses
X
Xnathan: nathan.c
X	$(CC) $(CFLAGS) nathan.c -o nathan
X
X# NOTE: this is the original program that won
X#
Xnathan.orig: nathan.orig.c
X	$(CC) $(CFLAGS) nathan.orig.c -o nathan.orig
X
Xvern: vern.tmp.c
X	$(CC) $(CFLAGS) vern.tmp.c -o vern
X
Xvern.tmp.c: vern.c
X	$(RM) -f vern.tmp.c
X	$(SED) <vern.c 's/{ /(/g;s/} /)/g;s/;	/#define /' | \
X	    $(SED) 's/}	/=/g;s/{	/i/g' >vern.tmp.c
X
X# NOTE: this is the original program that won
X#
Xvern.orig: vern.orig.tmp.c
X	$(CC) $(CFLAGS) vern.orig.tmp.c -o vern.orig
X
Xvern.orig.tmp.c: vern.orig.c
X	$(RM) -f vern.orig.tmp.c
X	$(SED) <vern.orig.c 's/{ /(/g;s/} /)/g;s/;	/#define /' | \
X	    $(SED) 's/}	/=/g;s/{	/i/g' >vern.orig.tmp.c
X
Xwestley: westley.c
X	$(CC) $(CFLAGS) westley.c -o westley
X
X# alternate names for selected entries
X#
Xadgrep: adrian
X	$(RM) -f adgrep
X	$(LN) adrian adgrep
Xam: ant
X	$(RM) -f am
X	$(LN) ant am
Xbabble: buzzard.1
X	$(RM) -f babble
X	$(LN) buzzard.1 babble
Xfirst: buzzard.2
X	$(RM) -f first
X	$(LN) buzzard.2 first
Xag: gson
X	$(RM) -f ag
X	$(LN) gson ag
Xwhereami: westley
X	$(RM) -f whereami
X	$(LN) westley whereami
X
Xclean:
X	$(RM) -f *.o a.out core 
X	$(RM) -f vern.tmp.c lush.again babble.cppcb vern.orig.tmp.c
X	$(RM) -f ad.temp adwc.c adbasename.c adecho.c adhead.c adsleep.c
X
Xclobber: clean
X	$(RM) -f $(WINNERS) a.out
X	$(RM) -f $(ALT_NAMES)
X	$(RM) -f adwc adbasename adecho adhead adsleep
X	$(RM) -f adrian.orig lush.orig nathan.orig buzzard.2.orig
X	$(RM) -f kivinen.orig imc.orig albert.orig marangon.orig vern.orig
X
Xam_clobber: clean am
X	$(RM) -f am.safe
X	$(CP) am am.safe
X	$(RM) -f $(WINNERS) a.out
X	$(RM) -f $(ALT_NAMES)
X	$(RM) -f adwc adbasename adecho adhead adsleep
X	$(RM) -f adrian.orig lush.orig nathan.orig buzzard.2.orig
X	$(RM) -f kivinen.orig imc.orig albert.orig marangon.orig vern.orig
X	$(CP) am.safe am
X	$(RM) -f am.safe
X
Xnuke: clobber
X	@true
X
Xinstall: all
X	cat $(WINNERS) > /dev/null
END_OF_FILE
  if test 5632 -ne `wc -c <'1992/Makefile'`; then
    echo shar: \"'1992/Makefile'\" unpacked with wrong size!
  fi
  # end of '1992/Makefile'
fi
if test -f '1992/ant.README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/ant.README'\"
else
  echo shar: Extracting \"'1992/ant.README'\" \(8745 characters\)
  sed "s/^X//" >'1992/ant.README' <<'END_OF_FILE'
XNAME
X
X	am		Anthony's Make 
X
X
XSYNOPSIS
X
X	am <makefile> [target]
X
X
XDESCRIPTION
X
XAM is a programmer's tool to maintain, update, and regenerate groups
Xof files and/or programs.  It is similar to MAKE as described by the
XPOSIX.2 draft standard 11.2, and this document parallels the draft
Xin order to point out the subtle differences between AM and MAKE.
X
XThe AM utility can be used as part of software development to update
Xfiles that are derived from other files.  A typical case is one where
Xobject files are derived from the corresponding source files.  The AM
Xutility examines time relationships and updates those derived files
X(targets) that have modified times earlier than the modified times of
Xthe files (prerequisites) from which they are derived.  A description 
Xfile ("makefile") contains a description of the relationships between 
Xfiles, and the commands that must be executed to update the targets to
Xreflect changes in their prerequisites.  Each specification, or rule, 
Xshall consist of a target, optional prerequisites, and optional 
Xcommands to be executed when a prerequisite is newer than the target.
X
X
XOPTIONS
X
XNone.
X
X
XOPERANDS
X
Xmakefile	This required argument, is a pathname of a description
X		file, which is also referred to as the "makfile".  A
X		pathname of "-", shall *NOT* denote the standard input.
X
Xtarget		This optional argument, is the first target to be 
X		processed.  If no target is specified, when AM is
X		processing the makefile, the first target that AM
X		encounters shall be used.
X
X
XEXTERNAL INFLUENCES
X
XSTANDARD INPUT
X
XNot used.
X
X
XINPUT FILES
X
XThe input file, otherwise known as the makefile, is a text file
Xcontaining rules, macro definitions, and comments.
X
X
XASYNCHRONOUS EVENTS
X
XAll traps are left to their default actions.  If AM receives a SIGHUP,
XSIGTERM, SIGINT, or SIGQUIT then AM will terminate as per request
X*WITHOUT* removing the current target.
X
X
XEXTERNAL EFFECTS
X
XSTANDARD OUTPUT
X
XThe AM utility shall write all commands to be executed to standard
Xoutput unless the command is prefixed with an at-sign (@).  If AM is
Xinvoked without any work needing to be done, it shall *NOT* write a
Xmessage to standard output indicating that no action was taken. 
X
X
XSTANDARD ERROR
X
XStandard error is used for diagnostic messages only.
X
X
XOUTPUT FILES
X
XNone.  However, the utilities invoked by AM may create additional files.
X
X
XEXTENDED DESCRIPTION
X
XThe AM utility attempts to perform the actions required to ensure
Xthat the specified target(s) are up-to-date.  A target is considered
Xout-of-date if it is older than any of its prerequisites or it does
Xnot exist.  The AM utility shall treat all prerequisites as targets
Xthemselves and recursively ensure that they are up-to-date, processing
Xthem in the order which they appear in the rule.  The AM utility shall
Xuse the modification times of files to determine if the corresponding
Xtargets are out-of-date.
X
XAfter AM has ensured that all of the prerequisites of a target are
Xup-to-date, and if the target is out-of-date, the commands associated
Xwith the target entry shall be executed.  If there are no commands
Xlisted for the target, the target shall be treated as up-to-date.
X
X
XMAKEFILE SYNTAX
X
XA makefile can contain rules, macro definitions, and comments.  If a
Xmacro is defined more than once, the value of the macro shall be the
Xlast one specified.  Comments start with a number-sign (#) and
Xcontinue until an unescaped <newline> is reached.
X
XA backslash before a <newline> serves as a line continuation mark, and 
Xis used to create long-lines.   A line will continue to be extended until 
Xan unescaped <newline> is reached.
X
XWhen an escaped <newline> (one preceded by a backslash) is found anywhere
Xin the makefile, it shall be replaced, along with any leading white 
Xspace on the following line, with a single <space>.  
X
X
XMAKEFILE EXECUTION
X
XCommand lines shall be processed one at a time by writing the command
Xline to standard output, unless prefixed with an at-sign (@), and
Xexecuting the command(s) in the line.  Commands shall be executed by
Xpassing the command line to the command interpreter via the system()
Xfunction.
X
XThe environment for the command being executed shall contain all of the
Xvariables in the environment of AM.  All macros are considered to be part 
Xof the environment too.
X
XBy default, when AM receives a non-zero status from the execution of a
Xcommand, it terminates with an error message to standard error.  If
Xthe command is prefixed by a hyphen (-) then any error found while
Xexecuting the command shall be ignored.
X
XCommand lines can have one or more of the following prefixes: a hyphen
X(-) to ignore errors, an at-sign (@) to be silent, or a plus-sign (+)
Xif the command is always executed (this prefix is for compatibility with
XMAKE and is ignored).
X
X
XTARGET RULES
X
XTarget rules are formatted as follows:
X
X	target [target ...] : [prerequisite ...]
X	[<tab>command
X	 <tab>command
X	 ...]
X
X	(line that does not begin with <tab>)
X
XTarget entries are specified by a <blank>-separated, non-null list of
Xtargets, then a colon, then a <blank>-separated, possibly empty list
Xof prerequisite.  All following lines, if any, that begin with a <tab>,
Xare command lines to be executed to update the target(s).  The first
Xline that does not begin with a <tab> shall begin a new entry.
X
XTarget names can be any character supported by the host system,
Xexcluding <blank>s, <tab>s, <newline>s, and colons (:), which are used 
Xfor delimiters.
X
XFor any given target there can be only one target rule.  The first
Xoccurrence of a target in a makefile shall be used.  All subsequent
Xrules for the same target are ignored.  There is *no* support for 
Xadding prerequisites to a target's prerequisite list once a target
Xrule is defined.
X
XThere are no special targets or inference rule support.  
X
X
XMACROS
X
XMacro definitions are in the form:
X
X	string1 = [string2]
X
XThe macro named string1 is defined as having the value of string2,
Xwhere string2 is defined as all characters, if any, after the equal
Xsign up to an unescaped <newline>.  Any <blank>s immediately before or
Xafter the equal sign shall be ignored.
X
XSubsequent appearances of $(string1) shall be replaced by string2.
XThe parentheses are *NOT* optional if string1 is a single character.
XThe macro $$ shall be replaced by the single character $.  
X
XMacro names can be any character that the host system would allow in 
Xthe definition of environment variables, excluding parentheses, ( and ), 
Xwhich are used for delimiters.
X
XMacros can appear anywhere in the makefile, except within other macro 
Xreferences (ie. no nesting).  Macros in target and command lines shall 
Xbe evaluated when the line is read.  Macros in macro definition lines 
Xshall be evaluated *IMMEDIATELY*.  A macro that has not been defined 
Xshall evaluate to a null string without causing any error condition.  
X
XIf a macro is defined more than once, the value of the macro shall be the 
Xlast one specified prior to it being referenced.
X
XMacro assignments shall be accepted from the sources listed below, in 
Xthe order shown.  If a macro name already exists at the time it is being
Xprocessed, the newer definition shall replace the existing definition.
X
X   1)	The contents of the environment, including the variables with
X	null values in the order defined in the environment.
X
X   2)	Macros defined in the makefile, processed in the order specified.
X
XThere are no internal macros supported.  The SHELL macro shall *NOT* be
Xtreated specially.
X
X
XEXIT STATUS
X
X  0	Successful completion.
X  1	General error.
X  2	Usage error.
X  3	Failed to open makefile.
X  4	Failed to allocate memory.
X
X
XINSTALLATION
X
XAM can be built on any system providing at least K&R C.  It has been 
Xtested on 
X
X	o  SunOS with GCC
X	o  ATARI Mega ST with Sozobon C
X	o  PC clone with Turbo C
X	o  Interactive UNIX System V/386 release 3.2
X
XFor all machines, the compile command line should be
X
X	cc -O -o am am.c
X
XThe value RULES represents the number of slots available to record
Xtarget rules, dependencies, and commands.  The default value chosen
Xshould handle most project makefiles.  RULES can be overridden on the
Xcommand line with -DRULES=nn, where 0 < nn < INT_MAX.
X
XOn a DOS machine using Turbo C, it may be necessary to add the include
Xdirective
X
X	#include <time.h>
X
Xwith the rest of the includes if sys/stat.h does not properly define or
Xuse time_t.  Also, on some older K&R C compilers, stdlib.h may not be 
Xdefined and so it might be necessary to remove the include directive for 
Xit. 
X
X
XREFERENCES
X
X[Mil87]	Webb Miller, "A Software Tools Sampler", Prentice Hall, 87
X	ISBN 0-13-822305-X, chaper 2
X
X[POSIX]	POSIX.2 draft 11.2 MAKE
X
X
XFILES
X
Xant.c		Obfuscated source
Xant.README	Manual for AM
Xant.test.mk	Test makefile
X
X
XBUGS
X
XUnknown as of 20 March 92.
END_OF_FILE
  if test 8745 -ne `wc -c <'1992/ant.README'`; then
    echo shar: \"'1992/ant.README'\" unpacked with wrong size!
  fi
  # end of '1992/ant.README'
fi
if test -f '1992/buzzard.1.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/buzzard.1.hint'\"
else
  echo shar: Extracting \"'1992/buzzard.1.hint'\" \(8217 characters\)
  sed "s/^X//" >'1992/buzzard.1.hint' <<'END_OF_FILE'
XMost Obfuscated Algorithm: <sean@stat.tamu.edu> Sean Barrett
X
X	Sean Barrett
X	Software Construction Company
X	430 Southwest Parkway, #1906
X	College Station, TX 77840
X	USA
X
X	Direct bounced email to <jon@stat.tamu.edu>.
X
XJudges' comments:
X
X    To see clearly why this won an award:
X	make babble
X    
X    Try:
X	babble 0 10
X	babble 56 720
X	babble 1 521
X    
X    To see good C Preprocessor babble, try:
X	make babble.cppcb
X	cat babble.cppcb
X    
X    Notice how many statements it takes to do anything useful?
X
X
XSelected notes from the author:
X
X    What you shouldn't think about babble:
X
X      babble doesn't just do a mass of #defines as its obfuscation.
X
X
X    What you should be glad about:
X
X      I didn't just submit the post-C-preprocessed output as an entry.
X
X
X    Cute trick warning:
X
X      babble contains only a numeric printf, yet sometimes it prints out
X      short strings.
X
X
X    What it does:
X
X      babble is a simple mathematical program. It expects two numeric
X      arguments.
X
X      % babble 0 <num>
X      will print out the factorial of <num>.
X
X      % babble <num1> <num2>
X      will print out the largest common factor of num1 and num2.
X
X      % babble 1 <num2>
X      will print out a factor of num2 if it's composite, or else
X      it will print a string informing you that num2 is prime.
X
X      If the first argument is less than 0, it prints out an
X      error message.
X
X
X    What it is:
X
X      babble is a translator from a pseudo-assembly language into a
X      subset of C suitable for execution on Charles Babbage's
X      Analytical Engine.  Or rather, the #defines in babble are that
X      translator.  The rest of babble is a babble program.  If you run the
X      whole mess through CPP and a beautifier, you will see that
X      all you have is a loop that runs until a variable is not 0, and
X      a sequence of assignment statements.  The assignment statements
X      are all of the form 'a op= b' or 'a = b'.  The Engine actually
X      allowed 'a = b op c'.  Only +, -, /, and * are used--no boolean
X      or bitwise operators.  The infinite loop could have been
X      simulated on the AE by connecting the already-processed 
X      card stack to the input card stack.
X
X
X    How to try to understand it:
X
X      *Don't* expand the #defines!  Rather, decipher what they do.
X      Some of them are mere obfuscational fodder, put in to encourage
X      you to run it through CPP.
X
X
X    What it doesn't quite do right as an emulator:
X
X      Because of the definitional constraints, calls to atoi(argv[#])
X      also appear inside the loop.  These could be put outside--
X      the initial values of the "registers" on the AE--but the
X      macro conventions being used didn't lend themselves to it.
X
X
X    Theoretical observations:
X
X      The simulated comparison operations only work with a certain
X      range of numbers; numbers that are too large will cause the
X      output code to fail to simulate the input code.  This means
X      that this implementation of babble would not be turing-complete,
X      even if the AE could process indefinitely-sized numbers.
X      However, this is actually a constraint that no actual computer
X      can meet, either, so we can conclude that if an AE, with
X      card bins connected as suggested above, were hooked up to
X      a memory unit of sufficient size, it would be as turing
X      complete as any existing machine (or, for those who
X      interpret that excessively critically, i.e. "not at all" for
X      both, we can simply say that the AE could simulate any
X      existing machine--although not quickly).  This would be a
X      good place to site some references on the AE, but I don't
X      have any.
X
X
X    Definition of the input language to babble:
X    (OR What Exactly Do All The Macros Do?)
X
X    [Don't read this unless you're stumped!]
X
X
X      MACRO		FUNCTION				MNEMONIC
X        V               begin variable declarations		Variable
X        C               begin program				Code
X
X        Q(b,a)          let b = a				eQuals
X        A(c,a,b)        let c = a + b				Add
X        S(c,a,b)        let c = a - b				Subtract
X        D(c,a,b)        let c = a / b, where b is a *constant*  Divide
X        U(c,a,b)        let c = a / b, where b is anything      Unknown
X        M(c,a,b)        let c = a * b				Multiply
X
X        O(c,a,b)        let c = a boolean-or b (a,b are 0 or 1) Or
X        B(b, a)         let b = boolean value of a		Boolean
X        P(b, a)         let b = 1 if a>0, else 0.		Positive
X
X        l               emit next sequential label		Label
X        J(x)            goto label #x				Jump
X
X        Z(a,d)          if a is 0 goto d    (a is 0 or 1)	Zero
X        E(a,d)          if a is 1 goto d    (a is 0 or 1)	Else
X
X        H               halt					Haly
X
X        K(x)            let x = number of cmd line arguments	Kount
X        G(x,y)          let x = the value if the yth argument   Get argument
X
X        T               end of code; begin output section	Terminate
X        X(y)            print out hexadecimal value of y	heXadecimal
X        T               end of output section and program	Terminate
X
X        You can figure out the other macros yourself.  In the sample
X        program, I've actually implemented subroutines by saving
X        a return address in a variable and then jumping to a routine--
X        specifically, a routine that converts a number into bcd, so
X        it can be output by the hexadecimal output statement.
X
X
X    How it works, i.e., how to get useful programs from a op= b
X
X      The essential statement to be able to do to do interesting
X      programs is the conditional (given that we have loops).
X      Since all you can do in the given operation output set is
X      assignment, we implement "conditional assignment":
X
X        if (x) y = z;
X
X      To implement this, we constrain x to be either 0 or 1, and
X      simply compute:
X
X        y = (z * x) + (y * (1-x));
X
X      This is more obscured by factoring out common terms and restricting
X      ourselves to two operand operations:
X
X        temp = z;                       (temp == z)
X        temp -= y;                      (temp == z-y)
X        temp *= x;                      (temp == (z-y)*x)
X        y += temp;                      (y    == (z-y)*x + y)
X                                        (     == z*x - y*x + y)
X                                        (     == z*x + y*(1-x))
X
X      Next we imagine we have a pc.  "I'm supposed to execute statement
X      pc next", says our emulator.  But suppose we're not currently
X      coming up on statement pc.  To handle this, we simply make every
X      operation conditional on the pc having the correct value:
X
X        if (pc == some_constant) y = z;
X
X      To combine this with other operations, we simply multiply by our
X      (pc == some_constant) flag right after the above 'temp *= x'.
X
X      To evaluate pc == some_constant requires one more trick.  We assume
X      that numbers can only be in some limited range.  Then we use successive
X      additions and divisions to reduce that number down to -1, 0, or 1.
X      You could, for instance, do this by using mod by 2 and div by 2 to
X      count bits, stopping after, say, 32 iterations.  The number you get
X      is between 0..32, so another 6 iterations on it reduces it to 0..6.
X      Three iterations on this produces 0..2 (3 would be '7'), and then
X      two iterations on this produces 0 or 1.  Instead I use a shorter
X      two-divide approach that assumes I'm allowed to use numbers slightly 
X      larger than the numbers I'm operating on.
X
X      A similar approach is used to detect positive numbers.
X
X      Note that the obvious code to compute y/x will not work correctly,
X      because every value is computed, even if the pc is not set correctly;
X      if x is ever 0 when the real C code reaches this computation the
X      program will die.  (This was discovered the hard way.)  The solution
X      is to stick x in a temporary, and if the current code is not about
X      to be executed, set the temporary to 1.
X  
X    Thanks to Bill Pugh for bringing the loopability of the AE to
X    my attention.
X
X    babble was originally named 'cb', for obvious reasons, and is
X    dedicated to the memory of Charles Barrett.
END_OF_FILE
  if test 8217 -ne `wc -c <'1992/buzzard.1.hint'`; then
    echo shar: \"'1992/buzzard.1.hint'\" unpacked with wrong size!
  fi
  # end of '1992/buzzard.1.hint'
fi
if test -f '1992/buzzard.2.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/buzzard.2.hint'\"
else
  echo shar: Extracting \"'1992/buzzard.2.hint'\" \(8915 characters\)
  sed "s/^X//" >'1992/buzzard.2.hint' <<'END_OF_FILE'
XBest Language Tool: <sean@stat.tamu.edu> Sean Barrett
X
X	Sean Barrett
X	Software Construction Company
X	430 Southwest Parkway, #1906
X	College Station, TX 77840
X	USA
X
X        Direct bounced email to <jon@stat.tamu.edu>.
X
XJudges' comments:
X
X    First:
X	make first
X    
X    Second:
X	echo help | cat third help.th - | first
X	cat third demo5.th | first
X    
X    Third:
X	cat third help.th - | first
X
X	Wait until Ok is printed and the type:
X	    2 3 + . cr	    <-- yes you should really type the 2 letters: cr
X
X    Forth:
X	Sorry, this is third!
X
X
XSelected notes from the author:
X
X    What it does:
X
X        first implements a relatively primitive stack machine.  How
X        primitive?  It supplies 13 visible primitives: 3 arithmetic,
X        1 comparison, 2 memory-access, 2 character I/O, 3 primitives
X        for defining new words, 1 tokenizing, and 1 special stack
X        operation.  (There are also three internal operations for
X        the stack machine: 'push this integer', 'call this code',
X        and 'compile a call to this code'.)
X
X        It is very difficult to accomplish anything with this set
X        of primitives, but they do have an interesting property.
X
X        This--what this interesting property is, or in other words
X        what first is good for--is the major obfuscation; there are
X        also minor source obfuscations, as well as some design tricks
X        that are effectively obfuscations.  Details on the obfuscations
X        are below, and the interesting property is discussed much
X        further down.
X
X
X    How to run it:
X
X        first expects you to first enter the names of the 13 primitives,
X        separated by whitespace--it doesn't care what you name them, but
X        if all the names aren't unique, you won't be able to use some of
X        them.  After this you may type any sequence of valid first input.
X        Valid first input is defined as any sequence of whitespace-delimited
X        tokens which consist of primitives, new words you've defined, and
X        integers (as parsed by "%d").  Invalid input behaves unpredictably,
X        but gives no warning messages.  A sample program, demo1.1st, is
X        included, but it only works on ASCII systems.
X
X        Do not expect to be able to do anything interesting with first.
X
X        To do something interesting, you need to feed first the file
X        third first.  In unix, you can do
X
X                % cat third help.th - | first
X
X        to do this.  Hopefully most operating systems will provide a
X        way to do this.  It may take some time for this to complete
X	(I seem to remember it taking several minutes on an 8086 PC);
X        THIRD will prompt you when it is finished.  The file third has
X        not been obfuscated, due to sheer kindness on the author's part.
X
X        For more information on what you can do once you've piped
X        THIRD into first, type 'help' and consult FORTH manuals for
X        further reference.  Six sample THIRD programs are included
X	in the files demo[1-6].th.  buzzard.2.README has more
X	information.
X
X        Keep in mind that you are still running first, and
X        are for the most part limited by first's tokenizer
X        (notably, unknown words will attempt to be parsed as
X        integers.)  It is possible to build a new parser that
X        parses by hand, reading a single character at a time;
X	however, such a parser cannot easily use the existing
X	dictionary, and so would have to implement its own,
X	thus requiring reimplementing all of first and third
X	a second time--I did not care to tackle this project.
X
X
X    Compiling:
X
X        first is reasonably portable.  You may need to adjust the
X        size of the buffers on smaller machines; m[] needs to be
X        at least 2000 long, though.
X
X        I say first is portable mainly because it uses native types.
X        Unlike FORTH, which traditionally allows byte and multi-byte
X        operations, all operations are performed on C 'int's.  That
X        means first code is only as portable as the same code would
X        be in C.  As in C, the result of dividing -1 by 2 is machine
X        (or rather compiler) dependent.
X
X    How is first obfuscated?
X
X        first is obfuscated in several ways.  Some minor obfuscations
X        like &w[&m[1]][s] for s+m[w+1] were in the original source
X	but are no longer because, apparently, ANSI doesn't allow it
X	(gcc -ansi -pedantic doesn't mind it, though.)
X	Other related obfuscations are still present.  The top of the
X	stack is cached in a variable, which increases performance
X	massively if the compiler can figure out to keep it in a register;
X	it also obfuscates the code.  (Unfortunately, the top of stack
X	is a global variable and neither gcc nor most bundled compilers
X	seem to register allocate it.)
X	
X        More significant are the design obfuscations.  m[0] is the
X        "dictionary pointer", used when compiling words, and m[1] is
X        the return stack index.  Both are used as integer offsets into
X        m.  Both are kept in m, instead of as separate pointers,
X        because they are then accessible to first programs, which is a
X        crucial property of first.  Similarly the way words are stored
X        in the dictionary is not obvious, so it can be difficult to
X        follow exactly what the compiler words are doing.
X
X        Assuming you've waded through all that, you still have
X        to penetrate the most significant obfuscation.  Traditionally,
X        the question is whether a reader can answer the question "what
X        will this do when I run it".  A reader who has deciphered first
X        to this point may think they know the answer to this question,
X        but they may not know the answer to the more important question,
X        "what will this program do when given the right input?"  FORTH
X        afficianados, and especially FORTH implementors, may recognize
X        the similarity of the internal compiler format to many FORTH
X        interal representations, and, being aware that FORTH interpreters
X        can often by self-compiling, may be suspicious that this program
X        can compile FORTH, or a significant subset of it, or at least be
X        capable of doing so if fed the right input.  Of course, the name
X        "THIRD" should be a dead giveaway, if the name "first" wasn't.
X        (These numbers were largely chosed because they were five letters
X        long, like "FORTH", and would not require truncation to five
X        letters, which would be a dead giveaway.  Besides, THIRD represents
X        a step backwards, in more ways than one.)
X
X
X    What exactly is first, then?
X
X    first is a tiny interpreter which implements a sufficient
X    pseudo-subset of FORTH to allow it to bootstrap a relatively
X    complete version of FORTH (based loosely on forth79), which
X    I call THIRD.  Complete relative to what, I'm not sure.
X
X    I believe first is close to the smallest amount of code possible
X    to get this effect *using forth-style primitives*, and still have
X    some efficiency (it is possible to get by without multiplication
X    if you have addition, obviously).  In the design file, design,
X    I give a justification for why each primitive in first was included.
X
X    THIRD is sorta slow, because first has so few primitives that
X    many things that are primitives in FORTH (like swap) take a
X    significant amount of time in THIRD.
X
X    When you get the 'Ok.' message from third, try out some sample
X    FORTH code (first has no way of knowing if keyboard input is
X    waiting, so it can't actually prompt you in a normal way.  It
X    only prints 'Ok.' after you define a word).
X
X        2 3 + . cr    ( add 2 and 3, and print it and a newline.)
X
X    and THIRD responds
X
X        5
X
X    Now try:
X
X        : test 11 1 do i . loop cr ;
X        test
X
X    and THIRD responds
X
X        1 2 3 4 5 6 7 8 9 10
X
X
X    When in THIRD, you can see how much space you're currently
X    using by typing
X
X        here .
X
X    The number THIRD replies is the number of machine words (ints)
X    that the dictionary (the first code) takes up, plus the
X    512 ints for the return stack.  If you compile the basic
X    THIRD system without the help word (strings take up one
X    int per character in the string!), you should find that
X    you're using around 1000 ints (plus the return stack).
X
X    Thus THIRD gives you a relatively complete FORTH system in
X    less than 700 chars of C source + about 1000 ints of
X    memory--and it's portable too (you could copy over the
X    THIRD memory dump to another machine, in theory).  If the
X    above numbers seem to you to be mixing apples and oranges
X    (C source and compiled THIRD code), note that you should
X    in theory be able to stick the compiled THIRD code into
X    the C source.
X
X
X    Software Construction Company gets credit for rekindling
X    my interest in FORTH and thus indirectly inspiring me
X    to write this program.
END_OF_FILE
  if test 8915 -ne `wc -c <'1992/buzzard.2.hint'`; then
    echo shar: \"'1992/buzzard.2.hint'\" unpacked with wrong size!
  fi
  # end of '1992/buzzard.2.hint'
fi
if test -f '1992/demo1.1st' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/demo1.1st'\"
else
  echo shar: Extracting \"'1992/demo1.1st'\" \(212 characters\)
  sed "s/^X//" >'1992/demo1.1st' <<'END_OF_FILE'
X: immediate _read @ ! - * / <0 exit echo key _pick
X
X: show echo echo echo echo exit
X: all show show show show echo exit
X
X: doit immediate
X    10 33 100 108 114 111 87
X    32 111 108 108 101 72
X    all
Xexit
X
Xdoit
END_OF_FILE
  if test 212 -ne `wc -c <'1992/demo1.1st'`; then
    echo shar: \"'1992/demo1.1st'\" unpacked with wrong size!
  fi
  # end of '1992/demo1.1st'
fi
if test -f '1992/gson.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/gson.hint'\"
else
  echo shar: Extracting \"'1992/gson.hint'\" \(10891 characters\)
  sed "s/^X//" >'1992/gson.hint' <<'END_OF_FILE'
XMost Humorous Output: <gson@niksula.hut.fi> Andreas Gustafsson
X
X	Andreas Gustafsson
X	Helsinki University of Technology
X	Arentikuja 1 D 305			(home address)
X	00410 Helsinki
X	FINLAND
X
X
XJudges' comments:
X
X    To make:
X	make ag
X    
X    Determine where your system dictionary is located.  You may find
X    it located in one of the following places:
X
X	    /usr/dict/words
X	    /usr/share/lib/spell/words
X	    /usr/ucblib/dict/words
X	    /dev/null			<-- for machines with nothing to say
X    
X    Then using the proper dictionary:
X
X        ag free software foundation	< /usr/dict/words
X        ag obfuscated c contest		< /usr/dict/words
X        ag unix international		< /usr/dict/words
X	ag george bush			< /usr/dict/words
X	ag bill clinton			< /usr/dict/words
X	ag ross perot			< /usr/dict/words
X	ag paul e tsongas		< /usr/dict/words
X
X    Recently some newspapers printed amusing anagrams of one of the
X    names listed above.  Run this program to find the anagrams they
X    weren't allowed to print!
X
X
XSelected notes from the author:
X
X    The name of the game:
X    
X    AG is short for either Anagram Generator or simply AnaGram.
X    It might also be construed to mean Alphabet Game, and by pure
X    coincidence it happens to be the author's initials.
X    
X    
X    What it does:
X    
X    AG takes one or more words as arguments, and tries to find
X    anagrams of those words, i.e. words or sentences containing
X    exactly the same letters.
X    
X    
X    How to use it:
X    
X    To run AG, you need a dictionary file consisting of distinct words
X    in the natural language of your choice, one word on each line.  If
X    your machine doesn't have one already, you can make your own
X    dictionary by concatenating a few hundred of your favourite Usenet
X    articles and piping them through the following obfuscated shell
X    script:
X    
X        #!/bin/sh
X        z=a-z];tr [A-Z\] \[$z|sed s/[\^$z[\^$z*/_/g|tr _ \\012|grep ..|sort -u
X    
X    Using articles from alt.folklore.computers is likely to make
X    a more professional-looking dictionary than rec.arts.erotica.
X    
X    AG must be run with the dictionary file as standard input.
X    
X    Because anagrams consisting of just a few words are generally more
X    meaningful than those consisting of dozens of very short words, the
X    number of words in the anagrams is limited to 3 by default.  This
X    limit can be changed using a numeric command line option, as in
X    "ag -4 international obfuscated c code contest </usr/dict/words".
X    
X    Bugs:
X    
X      - There is no error checking
X      - Standard input must be seekable, so you can't pipe the dictionary
X        into AG.
X      - The input sentence and each line in the dictionary may contain
X        at most 32 distinct letters, and each letter may occur at most 15
X        times.
X      - Words in the dictionary may be at most 255 bytes long
X      - AG cannot handle characters that sign-extend to negative values
X      - Although AG works on both 16-bit and 32-bit machines, 
X        the size of the problems it can solve is severely limited 
X        on machines that limit the stack size to 64k or less.
X    
X    
X    Obfuscatory notes:
X    
X    As you can see, AG takes advantage of the new '92 whitespace rules to
X    achieve a clear, readable, self-documenting layout.  The identifiers
X    have been chosen in a way appropriate for an alphabet game, and common
X    sources of bugs such as goto statements and malloc/free have been
X    eliminated.  As AG also refrains from abusing the preprocessor, it
X    doesn't really have much to offer in terms of "surface obfuscation".
X    Instead, it tries to achieve both its speed and its obscurity through a
X    careful choice of algorithms.  Some of the finer points of those
X    algorithms are outlined in the rot-13 encoded spoiler below.
X    
X    How it works:  (ROT13 to read)
X    
X    Urer sbyybjf n qrfpevcgvba bs fbzr bs gur qngn fgehpgherf naq
X    nytbevguzf hfrq ol NT.  Vg vf ol ab zrnaf pbzcyrgr, ohg vg znl uryc
X    lbh trg na vqrn nobhg gur trareny cevapvcyrf.
X    
X    --
X    
X    Vagreanyyl, NT ercerfragf jbeqf naq fragraprf nf neenlf bs 32
X    4-ovg vagrtre ryrzragf.  Rnpu ryrzrag ercerfragf gur ahzore bs
X    gvzrf n yrggre bpphef va gur jbeq/fragrapr.  Gurer ner 32 ryrzragf
X    orpnhfr 32 vf n pbairavrag cbjre bs gjb ynetre guna gur ahzore bs
X    yrggref va zbfg jrfgrea nycunorgf, naq gur ryrzragf ner 4 ovgf
X    rnpu orpnhfr gur fnzr yrggre vf hayvxryl gb bpphe zber guna 15
X    gvzrf va n cenpgvpny nantenz trarengvba ceboyrz.
X    
X    Gurfr 32*4-ovg neenlf ner npghnyyl fgberq va zrzbel va n
X    "ovg-genafcbfrq" sbezng, nf neenlf bs sbhe "ybat" inyhrf.  Vg vf
X    nffhzrq gung n "ybat" vf ng yrnfg 32 ovgf.  Gur svefg 4-ovg yrggre
X    pbhag vf sbezrq ol gur yrnfg fvtavsvpnag (2^0) ovg va rnpu bs gur
X    sbhe ybatf, gur arkg bar vf sbezrq ol gur 2^1 ovgf, rgp.
X    
X    Guvf fgbentr sbezng znxrf vg cbffvoyr gb nqq be fhogenpg gjb fhpu
X    irpgbef bs 32 4-ovg inyhrf va cnenyyry ol fvzhyngvat n frg bs 32
X    ovanel shyy nqqref va fbsgjner hfvat ovgjvfr ybtvpny bcrengvbaf.
X    R.t., nyy gur YFO:f bs gur erfhyg ner sbezrq va cnenyyry ol gnxvat
X    gur rkpyhfvir BE bs gur YFO:f va rnpu fhzznaq, naq 32 pneel ovgf
X    ner sbezrq va cnenyyry va n fvzvyne jnl hfvat n ybtvpny NAQ.
X    Guhf, 32 vaqrcraqrag 4-ovg nqqvgvbaf pna or cresbezrq ol whfg sbhe
X    vgrengvbaf bs n ybbc pbagnvavat fbzr 32-ovg ovgjvfr ybtvpny
X    bcrengvbaf, ohg ab nevguzrgvp bcrengvbaf bgure guna gubfr vzcyvrq
X    ol neenl vaqrkvat.
X    
X    Fhogenpgvba jbexf fvzvyneyl, naq va snpg NT bayl vzcyrzragf
X    fhogenpgvba qverpgyl, unaqyvat nqqvgvba ol zrnaf bs gur vqragvgl
X    n+o = n-(0-o).
X    
X    Va nqqvgvba gb guvf 32*4-ovg ercerfragngvba, NT nyfb sbezf n fb-pnyyrq
X    "fvtangher" gung vf gur ovgjvfr BE bs gur sbhe ybatf, juvpu vf
X    rdhvinyrag gb fnlvat gung gur fvtangher bs n jbeq pbagnvaf n ybtvpny 1
X    va gur ovg cbfvgvbaf pbeerfcbaqvat gb yrggref bppheevat ng yrnfg bapr
X    va gung jbeq.
X    
X    Gur svefg guvat NT qbrf vf gb pbafgehpg n ybbxhc gnoyr bs 256
X    ybatf, bar sbe rnpu 8-ovg punenpgre inyhr.  Gur ragel sbe n
X    punenpgre jvyy or mreb vs gung punenpgre qbrfa'g nccrne va gur
X    fragrapr tvira ba gur pbzznaq yvar, be vg jvyy unir n fvatyr ovg
X    frg vs gur punenpgre qbrf nccrne va gur fragrapr.  Ol nqqvat
X    gbtrgure gur ovg znfxf sbe nyy gur yrggref va gur vachg fragrapr
X    hfvat gur genafcbfr nqqvgvba zrgubq qrfpevorq nobir, NT sbezf gur
X    32*4 ovg neenl ercerfragngvba bs gur vachg fragrapr.
X    
X    Gur arkg npgvba cresbezrq vf ernqvat gur qvpgvbanel.  Gubfr jbeqf gung
X    pbagnva yrggref abg va gur vachg fragrapr ner vzzrqvngryl qvfpneqrq.
X    Jbeqf pbagnvavat gur evtug yrggref ohg va rkprffvir ahzoref ner
X    ryvzvangrq va n frcnengr purpx vaibyivat gur 32*4 ovg neenl.
X    
X    Gur erznvavat jbeqf, juvpu jvyy or ersreerq gb nf "pnaqvqngr jbeqf",
X    ner fgberq va 32*4-ovg ercerfragngvba, gbtrgure jvgu gurve fvtangherf 
X    naq bssfrgf vagb gur qvpgvbanel svyr fb gung gur cynva-grkg irefvba bs
X    n jbeq pna yngre or sbhaq sbe cevagvat.  Guvf vasbezngvba vf xrcg va n
X    ybpny "fgehpg" va gur qvpgvbanel-ernqvat shapgvba, naq zrzbel vf
X    nyybpngrq sbe rnpu pnaqvqngr jbeq fvzcyl ol znxvat nabgure erphefvir
X    pnyy gb gung shapgvba.
X    
X    Rnpu fgehpg fb nyybpngrq vf yvaxrq vagb n svkrq-fvmr unfu gnoyr bs
X    4096 ragevrf vaqrkrq ol gur 12 ybj ovgf bs gur jbeq'f fvtangher. 
X    Jura gur qvpgvbanel-ernqvat shapgvba rapbhagref raq-bs-svyr, nyy gur
X    pnaqvqngr jbeqf unir orra fgberq va arfgrq npgvingvba erpbeqf ba gur
X    fgnpx, npprffvoyr guebhtu gur unfu gnoyr.
X    
X    Trarengvat gur nantenzf vf gura qbar ol genirefvat gur unfu gnoyr naq
X    fhogenpgvat gur yrggref bs rnpu jbeq va gur unfu gnoyr sebz gur
X    "pheerag fragrapr", juvpu vavgvnyyl vf gur fragrapr tvira ba gur
X    pbzznaq yvar.
X    
X    Gur fhogenpgvba vf cresbezrq va cnenyyry ba gur 4-ovg yrggre pbhagf
X    nf qrfpevorq nobir, naq vs nyy 32 erfhygf ner mreb, na nantenz unf
X    orra sbhaq.  Vs gur erfhyg vf artngvir sbe bar be zber bs gur yrggref
X    (nf vaqvpngrq ol bar be zber "1" va n irpgbe bs 32 obeebj ovgf
X    erghearq ol gur fhogenpgvba ebhgvar), gur jbeq qvq abg zngpu gur
X    pheerag fragrapr naq vf vtaberq.  Svanyyl, vs gur erfhyg pbagnvarq
X    bayl abaartngvir yrggre pbhagf, jr unir sbhaq n cnegvny nantenz: 
X    n jbeq pbagnvavat fbzr, ohg abg nyy, bs gur yrggref va gur pheerag
X    fragrapr.  Va guvf pnfr jr erphefviryl gel gb svaq na nantenz bs gur
X    erznvavat yrggref.  Gur qrcgu bs gur erphefvba vf yvzvgrq gb gur
X    znkvzhz ahzore bs jbeqf va gur nantenz, nf fcrpvsvrq ol gur hfre.
X    
X    Jura gur qrrcrfg erphefvba yriry unf orra ernpurq, na bcgvzvmngvba pna
X    or nccyvrq: orpnhfr ab shegure erphefvba jvyy or qbar, gurer vf ab
X    arrq gb ybbx sbe cnegvny nantenzf, naq gurersber NT bayl arrqf gb
X    purpx sbe jbeqf gung pbagnva rknpgyl gur fnzr yrggref nf gur pheerag
X    fragrapr.  Gubfr jbeqf pna or sbhaq fvzcyl ol vaqrkvat gur unfu gnoyr
X    jvgu gur fvtangher bs gur pheerag fragrapr.
X    
X    Rira jura abg ba gur qrrcrfg erphefvba yriry, NT trarenyyl nibvqf
X    rknzvavat nyy gur ragevrf bs gur unfu gnoyr.  Gur vqrn vf gung jr ner
X    abg vagrerfgrq va unfu ohpxrgf jubfr jbeqf pbagnva nal yrggref abg
X    va gur pheerag fragrapr; gurfr ohpxrgf ner rknpgyl gubfr jubfr vaqrk
X    unf n ybtvpny bar va n ovg cbfvgvba jurer gur fvtangher bs gur pheerag
X    fragrapr unf n mreb.  Chg nabgure jnl, jr jnag gb ybbc guebhtu bayl
X    gubfr unfu ohpxrg vaqvprf "v" gung pbagnva mrebrf va nyy gur ovg
X    cbfvgvbaf jurer gur fvtangher "f" bs gur pheerag fragrapr pbagnvaf
X    n mreb; guvf pna or rkcerffrq va P nf (v & ~f == 0).
X    
X    Vg vf cbffvoyr gb ybbc guebhtu nyy fhpu ahzoref va na rssvpvrag jnl ol
X    gnxvat nqinagntr bs pregnva cebcregvrf bs ovanel nevguzrgvp: ol
X    sbepvat gur ovgf pbeerfcbaqvat gb mrebrf va "f" gb barf, jr pna znxr
X    gur pneevrf trarengrq va vaperzragvat "v" cebcntngr fgenvtug npebff
X    gubfr ovgf gung fubhyq erznva mreb.  Sbe rknzcyr, gur sbyybjvat
X    cebtenz cevagf nyy gubfr 16-ovg vagrtref gung pbagnva mrebrf va nyy
X    rira ovg cbfvgvbaf:
X    
X        znva(){vag v=0,f=0kNNNN;qb{cevags("%04k\g",v);}juvyr(v=((v|~f)+1)&f);}
X    
X    NT hfrf n fvzvyne zrgubq ohg jbexf va gur bccbfvgr qverpgvba, svaqvat
X    gur arkg ybjre inyhr jvgu mrebrf va tvira ovg cbfvgvbaf ol cebcntngvat
X    obeebjf npebff gubfr ovgf.  Fbzr nqqvgvbany nqwhfgzragf ner znqr
X    gb gur unfu gnoyr vaqrk jura vavgvngvat n erphefvir frnepu, hfvat
X    fvzvyne ovg-gjvqqyvat grpuavdhrf.
X    
X    Jurarire na nantenz unf orra sbhaq, vg vf cevagrq ol genirefvat n
X    yvaxrq yvfg sbezrq ol fgehpgf va gur npgvingvba erpbeqf bs gur
X    erphefvir vaibpngvbaf bs gur frnepu shapgvba, frrxvat gb gur ortvaavat
X    bs gur jbeq zngpurq ol gung vaibpngvba, naq pbclvat gur punenpgref bs
X    gur jbeq qverpgyl sebz fgnaqneq vachg gb fgnaqneq bhgchg.
END_OF_FILE
  if test 10891 -ne `wc -c <'1992/gson.hint'`; then
    echo shar: \"'1992/gson.hint'\" unpacked with wrong size!
  fi
  # end of '1992/gson.hint'
fi
if test -f '1992/rules' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/rules'\"
else
  echo shar: Extracting \"'1992/rules'\" \(7451 characters\)
  sed "s/^X//" >'1992/rules' <<'END_OF_FILE'
X9th International Obfuscated C Code Contest Rules
X
X    Obfuscate:  tr.v.  -cated, -cating, -cates.  1. a.  To render obscure.
X		b.  To darken.  2. To confuse:  his emotions obfuscated his
X		judgment.  [LLat. obfuscare, to darken : ob(intensive) +
X		Lat. fuscare, to darken < fuscus, dark.] -obfuscation n.
X		obfuscatory adj.
X
X
XGOALS OF THE CONTEST:
X
X    * To write the most Obscure/Obfuscated C program under the rules below.
X    * To show the importance of programming style, in an ironic way.
X    * To stress C compilers with unusual code.
X    * To illustrate some of the subtleties of the C language.
X    * To provide a safe forum for poor C code.  :-)
X
X
XRULES:
X
X    To help us with the volume of entries, we ask that you follow these rules:
X
X    1) Your entry must be a complete program.
X
X    2) Your entry must be <= 3217 bytes in length.  The number of characters
X       excluding whitespace (tab, space, newline), and excluding any ; { or }
X       followed by either whitespace or end of file, must be <= 1536.
X
X    3) Your entry must be submitted in the following format:
X
X---entry---
Xrule:	1992
Xtitle:	title of entry  (see comments below)
Xentry:	Entry number from 0 to 7 inclusive
Xdate:	Date/time of submission   (use the format of the date command)
Xhost:	Machine(s) and OS(s) under which your entry was tested
X	Use tab indented lines if needed
X---remark---
X    Place remarks about this entry in this section.  It would be helpful if
X    you were to indent your remarks with 4 spaces, though it is not a
X    requirement.  Also, if possible, try to avoid going beyond the 79th
X    column.  Blank lines are ok.
X---author---
Xname:	your name
Xorg:	School/Company/Organization
Xaddr:	postal address
X	use tab indented lines to continue
X	don't forget to include the country
Xemail:  Email address from a well known site or registered domain.
X        If you give several forms, list them on separate tab indented lines.
Xanon:	y or n	   (y => remain anonymous, n => ok to publish this info)
X---info---
XIf your program needs an info file, place a uuencoded copy of it in
Xthis section.  In the case of multiple info files, use multiple info
Xsections.  If your entry does not need a info file, skip this section.
X---build---
XPlace a uuencoded copy of the command(s) used to compile/build your program
Xin this section.  It must uudecode into a file named 'build'.  The resulting
Xfile must be 255 bytes or less.
X---program---
XPlace a uuencoded copy of your program in this section.  It must uudecode
Xinto a file named is 'prog.c'.  The resulting file must follow rule #2.
X---end---
X
X      Regarding the above format:
X
X	* The title must match expression: [a-zA-Z0-9_+=,][a-zA-Z0-9_+=,.-]*
X	  and must be 1 to 10 characters in length.
X
X	  It is suggested, but not required, that the title should
X	  incorporate your username; in the case of multiple authors,
X	  consider using parts of the usernames of the authors.
X
X	* All text outside of the above format will be kept confidential,
X	  unless otherwise stated.  Notes about an author of a winning entry
X	  will be published unless 'y' was given to that author's 'anon' line.
X
X	* To credit multiple authors, include an ---author--- section for
X	  each author.  Each should start with ---author--- line, and
X	  should be found between the ---entry--- and ---build--- sections.
X
X	* The entry's remarks should include:
X	    - what this program does
X	    - how to run the program (sample args or input)
X	    - special compile or execution instructions, if any
X	    - special filename requirements (see rule 4 and 5)
X	    - information about any ---data--- files
X	    - why you think the program is obfuscated
X	    - note if this entry is a re-submission of a previous entry.
X	    - any other remarks (humorous or otherwise)
X
X        * Info files should be used only to supplement your entry.  They 
X	  should not be required to exist.
X
X	  If your entry does not need an info file, skip the ---info---
X	  section.  If your entry needs multiple info files, use multiple 
X	  ---info--- sections, one per info file.  You should describe
X	  each info file in the ---remark--- section.
X
X    4) If your entry is selected as a winner, it will be modified as follows:
X
X	   'build' is incorporated into a makefile, and 'build' is removed
X	   'prog.c' is renamed to your entry's title, followed by an optional
X	       digit, followed by '.c'
X	   your entry is compiled into a file with the name of your entry's
X	       title, possibly followed by a digit
X
X       If your entry requires that a build file exist, state so in your
X       entry's remark section.  The makefile will be arranged to execute a
X       build shell script containing the 'build' information.  The name of
X       this build shell script will be your entry's title, possibly followed
X       by a digit, followed by '.sh'.
X
X       If needed, your entry's remarks should indicate how your entry must
X       be changed in order to deal with the new filenames.
X
X    5) The build file, the source and the resulting executable should be
X       treated as read-only files.  If your entry needs to modify these files,
X       it should make and modify a copy of the appropriate file.  If this
X       occurs, state so in your entry's remarks.
X
X    6) Your entry must be written in C.  Use of ANSI C is preferred.  Use
X       of common C (K&R + extensions) is permitted, as long as it does not
X       cause major problems for ANSI C compilers.
X
X    7) The program must be of original work.  All programs must be in the
X       public domain.  All copyrighted programs will be rejected.
X
X    8) Entries must be received prior to 09-May-92 0:00 UTC.  (UTC is
X       essentially equivalent to Greenwich Mean Time)  Email your entries to:
X
X		...!{apple,pyramid,sun,uunet}!hoptoad!obfuscate
X		obfuscate@toad.com
X
X       We request that your message use the subject 'ioccc entry'.
X
X       If possible, we request that you hold off on Emailing your entries
X       until 1-Mar-92 0:00 UTC.  Early entries will be accepted, however.
X       We will attempt to email a confirmation to the the first author for
X       all entries received after 1-Mar-92 0:00 UTC.
X
X    9) Each person may submit up to 8 entries per contest year.  Each entry
X       must be sent in a separate Email letter.
X
X   10) Entries requiring human interaction to be built are not allowed.  
X       Compiling an entry produce a file (or files) which may be executed.
X
X
XFOR MORE INFORMATION:
X
X    The Judging will be done by Landon Noll and Larry Bassel.  Please send
X    questions or comments (but not entries) about the contest, to:
X
X	...!{apple,pyramid,sun,uunet}!hoptoad!judges
X	judges@toad.com
X
X    The rules and the guidelines may (and often do) change from year to
X    year.  You should be sure you have the current rules and guidelines
X    prior to submitting entries.  The IOCCC rules and guidelines may be
X    obtained from the judges at the address above.  Please use one of
X    the following subjects in your request:
X
X	send rules	  to obtain the current IOCCC rules
X	send guidelines	  to obtain the current IOCCC guidelines
X	send mkentry	  to obtain the current IOCCC mkentry program
X	send all	  to obtain the current IOCCC rules,guidelines,mkentry
X
X    One may also obtain them via anonymous ftp from:
X
X	host: ftp.uu.net	(137.39.1.9)
X	user: anonymous
X	pass: yourname@yourhost
X	dir:  /pub/ioccc
X
X
Xchongo <Landon Curt Noll> /\cc/\  	hoptoad!chongo
XLarry Bassel			  	{uunet,ucbvax,cbosgd}|sun!lab
END_OF_FILE
  if test 7451 -ne `wc -c <'1992/rules'`; then
    echo shar: \"'1992/rules'\" unpacked with wrong size!
  fi
  # end of '1992/rules'
fi
echo shar: End of archive 2 \(of 5\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
