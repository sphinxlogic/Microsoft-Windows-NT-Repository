Newsgroups: comp.sources.misc
From: chongo@toad.com (Landon Curt Noll)
Subject:  v32i030:  ioccc.1992 - 1992 International Obfuscated C Code Contest winners, Part03/05
Message-ID: <1992Sep10.154442.27179@sparky.imd.sterling.com>
X-Md4-Signature: 0a668225acf2082a538a528eaf25d394
Date: Thu, 10 Sep 1992 15:44:42 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: chongo@toad.com (Landon Curt Noll)
Posting-number: Volume 32, Issue 30
Archive-name: ioccc.1992/part03
Environment: C

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  1992/README 1992/adrian.hint 1992/adrian.orig.c
#   1992/albert.orig.c 1992/imc.hint 1992/nathan.hint 1992/third
#   1992/vern.hint 1992/vern.orig.c 1992/westley.hint
# Wrapped by kent@sparky on Thu Sep 10 10:21:21 1992
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 3 (of 5)."'
if test -f '1992/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/README'\"
else
  echo shar: Extracting \"'1992/README'\" \(3693 characters\)
  sed "s/^X//" >'1992/README' <<'END_OF_FILE'
X1992 marked the "The Ninth International Obfuscated C Code Contest"
X
XUse make to compile entries.  It is possible that on BSD or non-unix
Xsystems the makefile needs to be changed.  See the Makefile for details.
X
XLook at the source and try to figure out what the programs do, and run
Xthem with various inputs.  If you want to, look at the hints files for
Xspoilers - this year we included most of the information included
Xby the submitters.
X
XRead over the makefile for compile/build issues.  Your system may
Xrequire certain changes (add or remove a library, add or remove a
X#define).  A number of compilers had problems optimizing certain
Xentries.  Some compilers do optimize, but the resulting program
Xdoes not work.  By default we have left off -O from compile lines.  
XYou might want to add -O back, or add it back for certain entries
Xwhere performance is important.
X
XThis year marked an all time high for number of entries as well as the
Xquality of entries.  Nearly twice the usual number of entries made it
Xto the final judging rounds.  Even when we raised the standards for
Xwinning, we still wound giving out a few more awards than in other
Xyears.  The new size rules size probably contributed to the overall
Xhigh quality.
X
XFYI: By tradition, we do not record the count the number entries,
X     nor do we give our our guess as to the number of entries 
X     received.  For folks who wonder, we can say that we consumed 
X     about 2000 pages of output (printing between 2 and 4 normal 
X     pages per side) during the judging process this year.
X
XThe new instructions for submitting entries worked well - we were
Xable to write scripts to unpack them and eliminate duplicates.
X
XAs promised last year, we accepted programs that made use of the X
Xlibraries for the first time.  We now consider ANSI C compilers to be
Xthe "standard" version that the entries were compiled with.
X
XName and address information are separated from the actual program
Xprior to judging.  This eliminates any chance that we would bias our
Xjudging for/against any person or group.  In the end, we are surprised
Xas you are to see who as won.  Even so, it is worth noting that
XBrian Westley has submitted a winning entry for the past 6 years!
X
X
XA few notes regarding future contests:
X
XWe did not give awards to some traditional contest categories such as
X"Best Layout".  We felt that to do so would deny awards to more
Xdeserving entries.  These categories have not been eliminated.  We will
Xlikely be awarding them in future years.
X
XWe received a few entries whose instructions were rot13'd.  While
Xnothing was said about this in the rules, we found that it made the 
Xjudging process a little harder, so we may request that this not
Xbe done this in the future.
X
XSome thought has been given to a separate obfuscated perl contest.
XWatch comp.lang.perl for details!
X
XBe sure to wait until the 1993 rules are posted before submitting entries.  
XWe may fine tune the rules to reflect the some ideas above.
X
XPlease send us comments and suggestions what we have expressed above.
XAlso include anything else that you would like to see in future contests.
XSend such email to:
X
X	...!{sun,pacbell,uunet,pyramid}!hoptoad!judges
X	judges@toad.com
X
X
XIf you use, distribute or publish these entries in some way, please drop
Xus a line.  We enjoy seeing who, where and how the contest is used.
X
XIf you have problems with any of the entries, AND YOU HAVE A FIX, please
XEmail the fix (patch file or the entire changed file) to the above address.
X
XCredits:
X
XWe would like to thank Barbara Frezza for her role as official chef of
Xthe contest.  Landon Noll and Larry Bassel appreciated the opportunity
Xto serve as official taste testers. Yummo!
END_OF_FILE
  if test 3693 -ne `wc -c <'1992/README'`; then
    echo shar: \"'1992/README'\" unpacked with wrong size!
  fi
  # end of '1992/README'
fi
if test -f '1992/adrian.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/adrian.hint'\"
else
  echo shar: Extracting \"'1992/adrian.hint'\" \(7292 characters\)
  sed "s/^X//" >'1992/adrian.hint' <<'END_OF_FILE'
XMost Educational: <adrian@u.washington.edu> Adrian Mariano
X
X	Adrian Mariano
X	University of Washington
X	2729 72nd Ave SE
X	Mercer Island, WA 98040
X	USA
X
X
XJudges' comments:
X
X    To build:
X	make adrian
X
X    Try:
X	adrian adrian.grep.try < adrian.hint
X    
X    For the slow minded, try:
X	adsleep 32767
X    
X    Once you get past the obfuscation, you have an opportunity to learn
X    about regular expressions and state machines.
X
X    NOTE: Some compilers have had trouble optimizing this entry.
X
X
XSelected notes from the author:
X
X                            ADrian's GREP (adgrep)
X
X    For those confused by the complexity of full-blown egrep style regular
X    expressions, this program offers an alternative.  It implements an
X    equivalent search, using a deterministic finite automaton.
X
X    A deterministic finite automaton consists of a finite set of states,
X    along with transition rules to move from one state to another, an initial
X    state, and a set of accepting states.  The automaton takes a string as
X    input and begins in the start state.  It reads a character of the string
X    and consults the rules for the current state, moving to the new state
X    indicated by the appropriate rule.  This process is repeated until the
X    string is consumed.  If the current state at this point is one of the
X    accepting states, then the string is accepted.
X
X    The deterministic finite automaton is specified as a series of rules for
X    each state:
X
X       <state> chars1 <dest1> chars2 <dest2> ...
X
X    chars1 is a list of characters (only the first 8 are significant) which
X    should trigger a transition to <dest1>.  <dest1> is another state which
X    should have a similar specification somewhere.  A state is accepting if
X    it is specified in square brackets: [final], and state strings are
X    significant to only eight characters.
X
X    Example 1: matches ^abc$
X
X    <q0> a <q1>          The first state to appear is the start state
X    <q1> b <q2>
X    <q2> c [q3]
X    [q3]
X
X    Technically, a deterministic finite automaton should have a rule for each
X    possible input character at each state.  To simplify descriptions of the
X    automata, if no rule is present, the string will not be accepted. Also,
X    the '.' character matches any character if it occurs first in the
X    character list.
X
X
X    Example 2: ^abc
X
X    <q0> a <q1>
X    <q1> b <q2>
X    <q2> c [q3]
X    [q3] . [q3]
X
X
X    Example 3: abc$
X
X    <q0> a <q1> . <q0>
X    <q1> b <q2> a <q1> . <q0>
X    <q2> c [q3] a <q1> . <q0>
X    [q3] . <q1>
X
X
X    Example 4: ^(abc)*$
X
X    [q0] a <q1>
X    <q1> b <q2>
X    <q2> c [q0]
X
X
X    Example 5: ^[ab][cd][ef]$
X
X    <q0> ab <q1>
X    <q1> cd <q2>
X    <q2> ef [q3]
X    [q3]
X
X
X    Example 6: ^(abc|efg)$
X
X    <q0> a <q1> e <q3>
X    <q1> b <q2>
X    <q2> c [q5]
X    <q3> f <q4>
X    <q4> g [q5]
X    [q5]
X
X
X    With the automaton specification in 'filename', invoke the program by
X    typing
X
X                                adgrep 'filename'
X
X    It will read stdin and print out all the lines which the automaton
X    accepts.  If the file cannot be opened, a system error message will
X    be printed.  If the input contains errors, then an error message along
X    with the number of the offending line will be printed to stderr.  The 
X    number of rules for each state is limited to 17.  If more than 17 rules 
X    are present, you get the error to_many_rules, and the state that was 
X    being processed is printed.  Error no_destination occurs if you specify a 
X    set of characters, but no destination state, and error too_many_states 
X    occurs if your automaton has more than 257 states.
X
X    Running
X                             adgrep from < your_mailbox
X
X    will perform a function similar to that of the unix from command.
X
X    If no filename is specified on the command line, then "adgrep.c" is used
X    as the specification for the automaton.  (This file has been renamed 
X    to adrian.c by the judges.)  In this case, the program will search for 
X    matches to the regular expression:
X
X                        ^.[^|C][^w[Q]*(Q|[w[]c).*|^.[C|]$
X
X    I suggest using adgrep.c as input, and storing the output in adwc.c:
X
X                           adgrep < adgrep.c > adwc.c
X
X    Compiling the new file, mywc.c, yields a clone of the unix wc command. It
X    runs on one file (defaulting to "adgrep.c" if no file is given) and
X    displays the number of lines, words, and bytes in the input file.
X
X
X    Another possibly interesting automaton can be created by slightly
X    adjusting the adgrep.c file.  Change the first line to read
X
X                                 /* . echo| . */
X
X    and repeat the process above
X
X                           adgrep <adgrep.c > adecho.c
X
X    The new file now contains all lines which match
X
X                      ^.[^5|m^]*[m^]([e=p,;]|[^e=+p,;].*)$
X
X    Compile and run.  This is an echo clone.  Note the efficient algorithm
X    employed.
X
X
X    Two other adjustments to the first line also yield useful results. By
X    changing it to
X                                 /* . head; . */
X
X    you can search for matches to
X
X                                  ^.[^W]*W..*$
X
X    By some freak happenstance, lines of adgrep.c which match this regular
X    expression form a unix head command.  It prints the first ten lines of
X    the file specified on the command line (or adgrep.c if no file is
X    specified).
X
X    By setting the first line to
X
X                               /* . basename . */
X
X    a clone of the unix basename command can be unearthed. The automaton will
X    search for
X                                  ^.[^j]*jr.*$
X
X    on standard input.  And the program which results by running adgrep.c
X    through this filter requires two parameters.  The first is meant to be a
X    filename, and the second, an extension.  All leading pathname components
X    are removed from the filename, and the extension is removed if present.
X    The resulting base name is printed to stdout.
X
X    Lastly, by setting the first line to
X
X                       	         /* . sleep . */
X
X    you can search for
X
X        		        ^.[^(~][^s]*sl.*$
X
X    Filtering adgrep.c through this search yields a clone of the sleep
X    command.  Invoke with a single integer parameter, and it will pause
X    for that many seconds.
X
X    If either adbasename or adsleep is invoked with too few parameters,
X    the program will print the error message:
X                       Segmentation fault (core dumped)
X
X    (The exact text of the above error messages varies from machine to
X    machine.)  The four programs which read from stdin require lines
X    shorter than 999 characters.
X
X    The other info files are adrian.grep.[1-6] which contain the six
X    examples that appear above, and from, which is used to emulate the
X    unix from command.  For reasons of clarity, the name "from" should
X    probably not be changed if possible.  I wouldn't want to be accused of 
X    confusing people by giving the input files weird names.
X
X    If you want to change the default input filename (line 80) you must be
X    careful to choose a name that doesn't match the wrong search patterns,
X    introducing extra lines into one of the programs.
X
X    The program will produce at least one warning and possible several
X    when compiled depending on the compiler.
END_OF_FILE
  if test 7292 -ne `wc -c <'1992/adrian.hint'`; then
    echo shar: \"'1992/adrian.hint'\" unpacked with wrong size!
  fi
  # end of '1992/adrian.hint'
fi
if test -f '1992/adrian.orig.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/adrian.orig.c'\"
else
  echo shar: Extracting \"'1992/adrian.orig.c'\" \(2581 characters\)
  sed "s/^X//" >'1992/adrian.orig.c' <<'END_OF_FILE'
X/* . wc . */
X#include<stdio.h>/* Wht majr flwchrt? */
X#include<string.h>/* That mjr flwchrt! */
X#define P 257
X#define G 17
X#define z 8
X#define v(jr) jr
Xint W ,head;
X#define S(W,b,f) strncpy(W,b,f),W[f]=0\
X
X  
Xchar *wcs=" \t\n";
Xstruct{ char X[z+1]; 
X        char f ;
X        int e ; 
X        struct{ char g[z+1];
X                int b ;
X              } w[ G];
X      } o[ P];
Xint L=0,j= -28;
X
X
Xvoid E(int i, int m,char*c)
X{   
X for(; i<43; i+=3) 
X   putc(i["}|uutsrq`_^bji`[Zkediml[PO]a_M__]ISOYIRGTNR"]+i-9,stderr);
X fprintf(stderr,"(%d): %s\n" ,m,c);
X exit(1);
X}
X
X
X
Xint N(int m, char *t)
X{ 
X  int i ;
X  if (strlen ( 
X              t)>z) t[z ]=0;
X  for(i= 0; i< L ; i++) if(
X                           !strcmp (o[ i] . X
X                                             , t))return i;
X  if( L== P)
X             E(0, m, t);
X  S (o[ L] . X , t
X                  ,z);
X  head; W = .1* head;
X  o[L ].f = !( strchr( t,']' )== 0 );
X  o[L ++ ] . e = 0;
X  return L -1 ; }
X
X#define v(x )
X
Xint A(char *R)
X{
X  int c=0, i;
X  while(* R) {
X    i = -1;
X    while(j){
X      if( ++ i==o[ c].e ) return 0;
X      if(o[ 
X           c] .w[i ] .g[0 ] 
X                            =='.' ||strchr (o[ c].w[i] .g ,* R)){
X      c=
X        o[ c ] .w[i].b; break;/*
Xmain(int sl,char *j[]){
X      sleep (~~~~~~~~atoi(j[1])) ;/* . sl
X      sl s l . sl
X      l l ]
X      sl */ }
X    }
X    R++;
X  }
X  return o[ c].f;
X}
X
X
X main(int wc,char *V[]){char Y[999],*s;FILE*W;int m=0,echo,jr,q,wcl=0,wcw=0,wcc=0;
X v(s = V[1]; if (*V=strrchr(s,'/'))s=*V+1;  if(( !strncmp( s + (jr=strlen(s)) -
X  (q=strlen(V[2]) ),V[2],q))&&jr!=q) s[jr-q] = 0;  puts(s); )
X int e,p,C,Q ,basename;
X W= fopen(wc>= 2 ? V[1] : "adgrep.c","rt");
Xecho| m^ e| 5| (int) .8| echo|
Xwc |C ==o[o[C] .e] . 
Xe| e==+p,p; s[o[C] .e ] 
X;
Xwhile( fgets(Y,998,W)) { wcc += strlen(Y); m++;
X     if( s = strtok(Y,wcs)) wcw++;
X     else continue ;
X     C=
X       basename= j +j+*"* . basename" 
X                +j+*"* r ] " + N(m,s) ;
Xwhile( s = strtok(0,wcs)) {
X       if( o[ C ] . e == 
X                         G) E(1 ,m,o[C] .X) ;
X       S(o[C
X             ] .w[o[C ] .e].g,s, z);
X       Q= C ;
X       if(! ( s =strtok ( 0 ,wcs )))wcw --
X       ,E( 2 , m, o[C]
X                   . w[ o[ Q ] .e] . g );
X       e
X         = o[C ] .w[o[C ] .e++ ] .b= N(m,s)
X       ; wcw += 2; }  
X     0&& 
X        W && wcl++
X                  < 10 && printf((W,Y)); }
X   if(j+28) { {
X                ; } printf("%7u%7u%7u\n", wcl , wcw , wcc); }
X   while( gets(Y) ) if(A(Y)) puts(Y);
X   W, jr; }
X
XO(int wc,char**V) {
X--wc && (printf("%s ",*++V), main(wc,V), 1) || printf("\n"); }
X
END_OF_FILE
  if test 2581 -ne `wc -c <'1992/adrian.orig.c'`; then
    echo shar: \"'1992/adrian.orig.c'\" unpacked with wrong size!
  fi
  # end of '1992/adrian.orig.c'
fi
if test -f '1992/albert.orig.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/albert.orig.c'\"
else
  echo shar: Extracting \"'1992/albert.orig.c'\" \(3153 characters\)
  sed "s/^X//" >'1992/albert.orig.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <malloc.h>
X#include <setjmp.h>
X#include <ctype.h>
X#define new(PP) (PP *) malloc(sizeof(PP)) 
Xtypedef struct q {
X    jmp_buf ppp;
X    long qq;
X    struct q *P;
X    struct q *p;
X} 
XPP;
X
XPP *P;
Xint aaaaaa=2;
Xint aaaaaaa=1;
X
Xlong qqq;
X
X
XaaAaaa(aa,aaa)
Xchar *aa;
Xchar *aaa;
X{
X    char aaaa = 0;
X    if ((((( aaa )))))
X    {
X        aaaa = *aa;
X        *aa=0;
X        aa+=strlen(aa+1);
X        P =new(PP);
X        P->P=P;
X        P->p=P;
X    }
X
X    if ((((( !setjmp(P->ppp) ))))) 
X        {
X        if ((((( !isdigit(*aa) )))))
X            longjmp(P->ppp,aaaaaaa);
X        else {
X            P->p->P = new(PP);
X            P->p->P->P = P;
X            P->p->P->p = P->p;
X            P->p = P->p->P;
X
X            P->qq = *aa--;
X            P = P->p;
X            aaAaaa(aa,0);
X        }
X    } else {
X        if ( !aaaa&&!*aa ) 
X           longjmp(P->p->ppp,aaaaaaa);
X
X        if ((((( (P->qq=aaaa)<10     &&!
X                 (isdigit(aaaa))     ||!
X                 (isdigit(*aa)       ||!
X                 *aa                        )))))) 
X        {
X            fprintf(stderr,"Usage %c%s <number>\n",
X            (aaa[0]?7:aaaa),aaa+!aaa[0]);
X            exit(1);
X        }
X    }
X}
X
X
XppPppp(pp,ppp)
XPP **pp, *ppp;
X{
X    int aa;
X    if ((((( !(aa=setjmp(ppp->ppp))||aa==aaaaaa )))))
X    {
X        if ((((( *pp==ppp )))))
X        {
X            ppp = (*pp)->p;
X
X            if ( qqq<47 ) return;
X            if ( ppp->qq!=48 ) return;
X
X            while ( ppp->qq==48 ) 
X            {
X                printf("%ld\n",qqq-45);
X                *pp = ppp;
X                ppp = ppp->p;
X            }
X            qqq -= 1;
X            longjmp(ppp->ppp,aaaaaaa);
X        } else {
X            PP *p;
X
X            ppPppp(pp,ppp->p);
X            for (p=ppp;p!=*pp;p=p->p)
X            {
X                int qq=4;
X                if ((((( qqq<47                            &&
X                         (qq=0,p->qq+=p->p->qq-96)>=48-qqq ||
X                         qqq>46                            &&
X                         (p->qq-=p->p->qq)<0                   ))))) 
X                {
X                    p->qq += qqq+qq;
X                    if ( p->p==P && qqq<=46 )
X                    {
X                        P->p->P = new(PP);
X                        P->p->P->P = P;
X                        P->p->P->p = P->p;
X                        *pp = P = P->p = P->p->P;
X                        P->qq = 48;
X                    }
X
X                    p->p->qq+=qq==0;
X                    p->p->qq-=qq!=0;
X                }
X                else
X                {
X                    p->qq += 48;
X                }
X            }
X            if ( ppp->P==P ) longjmp(ppp->ppp,aaaaaaa);
X        }
X    }
X    else
X    {
X        qqq += 1; 
X
X        while (48==P->qq )
X        {
X            P->P->p = P->p;
X            P = P->p->P = P->P;
X
X        }
X
X        if (ppp!=ppp->p->p )
X            longjmp(ppp->ppp,aaaaaa);
X        else
X        {
X            printf("At most one remains\n");
X            exit(0);
X        }
X    }
X}
X
X
Xmain(aaa,aaaa)
Xint aaa;
Xchar **aaaa;
X{
X    aaAaaa(aaa==aaaaaaa?aaaa[0]:aaaa[1],aaaa[0]);
X    qqq = 39;
X    ppPppp(&P,P->p);
X}
X
X
END_OF_FILE
  if test 3153 -ne `wc -c <'1992/albert.orig.c'`; then
    echo shar: \"'1992/albert.orig.c'\" unpacked with wrong size!
  fi
  # end of '1992/albert.orig.c'
fi
if test -f '1992/imc.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/imc.hint'\"
else
  echo shar: Extracting \"'1992/imc.hint'\" \(6479 characters\)
  sed "s/^X//" >'1992/imc.hint' <<'END_OF_FILE'
XBest Output: <imc@ecs.ox.ac.uk> Ian Collier
X
X	Ian Collier
X	Oxford University
X	The Queen's College
X	High Street
X	OXFORD
X	OX1 4AW
X	ENGLAND
X
X
XJudges' comments:
X
X    Make and run.
X
X    The program is more interesting to run on workstations that can
X    make use of a Sun raster file.  Others can make use of the -text
X    flag for character oriented output.
X
X    Of course, the source (layout) is self-documenting!  :-)
X
X    NOTE: The original winning source imc.orig.c assumed that
X	  exit returned a value which cause problems for some
X	  systems where exit returned a void.  The file imc.c
X	  avoids this problem.
X
X
XSelected notes from the author:
X
X    Portability
X
X    This program depends upon the ASCII character set, and makes certain
X    assumptions about the architecture. It naughtily declares the first
X    argument to main as a long, and passes a pointer to long instead of char
X    to fwrite, giving a length value of 32 bytes for an array of 8 longs. I
X    guess that makes this program OK on most flavours of unix, but not on
X    PCs.
X
X    About the program
X
X    This program has several parameters; each of them has a default, so the
X    program runs happily without any parameters. If you supply an incorrect
X    parameter, an obfuscated error message results! :-) Should you want to
X    run the program without knowing what it does, then supplying the single
X    letter t as a parameter is a good move. Otherwise, direct the output
X    into a file. The resulting file is most useful on Sun OS, where the
X    "file" command will tell you what to do with it. For best results with
X    the t option, you may want to change the definition of the I macro :-)
X    Details appear later, though the formatting of the code is a large clue.
X
X    All the code in this program appears between the ";" and ")" in
X    "for(;;)". That isn't because I want to win the best one-liner, but
X    merely because it makes the code so much more impenetrable :-) In fact
X    running a pretty printer on the code hardly improves it at all. This
X    program has the obligatory macros with unmatched parentheses, and the
X    cleverly arranged macro names and parameters to spell out "Ian Colliers
X    Obfuscated C Code". If you expand macros, bear in mind that the more
X    complex ones are best left as macros, because they have well-defined and
X    nontrivial (IMHO) functions. These macros help to give the program's
X    parameter format its flexibility. The parameters are sorted out in a
X    unique way (based on an idea by Pete Bevin) which hides very effectively
X    their identities (and I think that using a variable called _ adds a nice
X    touch to the illegibility of the code). In this section of the code, the
X    data types of the numbers checked against is varied, and just because
X    you see a ',' doesn't mean it has anything to do with commas! So I hope
X    you will agree that this program is more than a little obfuscated...
X
X    This is a Mandelbrot/Julia drawer. Normally it produces a monochrome
X    Sun-format raster file. The version of xloadimage we have is able to
X    view such files, and so is Sun's screenload command. [Note: the header
X    contains eight 4-byte integers, the byte order in which depends upon the
X    machine. On Sun workstations they are stored MSB first].
X
X    The program may be asked to produce text output instead of a raster
X    file. Then the characters defined in the I macro will be used to create
X    up to 16 different shades of grey. Quite a respectable picture can be
X    gained by printing a 130x110 output on a dot matrix 132 column printer
X    with the linefeed set to 7 points. Text output also gives a good picture
X    when used in an X window with small characters having a square aspect
X    ratio.
X
X    The options accepted by the program follow. Each option is a letter; it
X    may be preceded with a minus sign (or any character in [!-/]) and may be
X    followed by other letters, so for example
X          m    -m     mask     *mail
X    all mean the same thing. Most options may be followed by one or two
X    numbers. These numbers may be separated from each other and from the
X    option by a space, or may be joined to each other with a comma, or may
X    be appended to the single-letter option, so
X          -s100,200    size 100,200    -size123 100 200  s100 200
X    all mean the same (note that in "-size123" all characters following the
X    initial s are ignored). Numbers need not be specified, as each has a
X    default value. In all cases except "j" and "t", and "s" whenever it
X    appears before "t", specifying an option without numbers has no effect.
X    (specifying "-s -t" has the effect of producing text with the default
X    raster size; not a good idea!). The options are:
X
X    -centre x y  (float x,y) Centre the picture at x+iy in the complex
X                             plane (default x=0 y=0)
X    -factor f    (float f)   Use f pixels per unit of the plane (default
X                             f=x/4 where x is the width)
X    -julia  x y  (float x,y) Draw a julia set. Use x+iy as the constant
X                             to add after squaring (default x=0 y=0)
X    -limit  l    (int l)     Use l iterations maximum (default l=128)
X    -mask   m    (int m)     Use m as a mask in deciding the colour of each
X                             pixel (see below) (default m=1)
X    -size   x y  (int x,y)   Produce an x-by-y output (default for raster
X                             x=768 y=768; default for text x=63 y=23)
X    -text                    Produce text instead of raster.
X
X    The colour of each point is determined by taking the bit-and of the
X    number of iterations and the mask. For a raster, the point is black
X    (1-bit) if the result is zero, white otherwise. For text, the result of
X    the operation determines the grey-ness of the character produced, with a
X    blank for zero going up to a star for the maximum value. For a
X    four-colour picture, for example, use a mask with two bits set (e.g. 3),
X    and for a 16-colour picture use a mask with four bits set (e.g. 15). For
X    a picture with coarse detail, use a mask which ends with several zero
X    bits (e.g. 8).
X
X    While the program is creating your picture, it displays dots on the
X    standard error to indicate its progess (one dot per pixel line).
X
X    Here are a couple of good pictures to draw:
X
X    imc -s 512,512 -f 600000 -l 512 -m 16 -c.00805,.74274 > screen1.ras
X    imc -s512,512 -j-.523,-.535 > screen2.ras
END_OF_FILE
  if test 6479 -ne `wc -c <'1992/imc.hint'`; then
    echo shar: \"'1992/imc.hint'\" unpacked with wrong size!
  fi
  # end of '1992/imc.hint'
fi
if test -f '1992/nathan.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/nathan.hint'\"
else
  echo shar: Extracting \"'1992/nathan.hint'\" \(4546 characters\)
  sed "s/^X//" >'1992/nathan.hint' <<'END_OF_FILE'
XWorst Abuse of the Rules: <nathan@inmos.co.uk> Nathan Sidwell
X
X	Nathan Sidwell
X	Inmos UK
X	1000 Aztec West
X	Almondsbury
X	Bristol
X	UK BS12 4SQ
X
X
XJudges' comments:
X
X    The US International Traffic in Arms Regulations controls certain
X    exportations going out of the United States.  The U.S.  Munitions
X    List gives the specific categories of restricted exports.  Because
X    this entry appears to fall under this restricted catagory, the
X    judges may not be able to distribute winners outside of the USA.
X
X    Nathan Sidwell has stated that he is willing to distribute the
X    winning source.  To read HIS instructions of how to obtain his
X    winning program:
X
X	make nathan
X	nathan
X
X    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
X    =-=-= The text below assumes that you have the winning source =-=-=
X    =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
X
X    To use:
X	make nathan
X
X    Try:
X	nathan obfuscate < nathan.c > foobarf.c
X	nathan - obfuscate < foobarf.c > barfoof.c
X	diff nathan.c barfoof.c
X
X    WARNING:
X	The judges' make no claim as to the strength or security
X	of this program.  It is likely to be nil, or the next
X	best thing to it.  Still, you might consider installing
X	it in /usr/games/nathan.  :-)
X
X    NOTE: 
X	The 'winning' catagory is also open to question.  One could say
X	that it is a 'file obfuscator'.  One could also say that it
X	unintentionally adbused the intent of rule #7 (that programs
X	should be freely redistributable).  We suspect that the author
X	may not have intended to do this, but that is the way things go
X	sometimes.
X
X	BTW, 'abuse of the rules' entries do not violate the rules.
X	Entries that violate the rules are disqualified.  Abuse of the
X	rules entries are ones that tend to 'streach' the limits and
X	take the contest into unexpected territory.
X
X
XPersonal note from chongo:
X
X    I think this situation shows just how ridiculous US crypto
X    regulations really are.  Certain US federal officials can get away
X    with shipping arms to certain nations in apparent violation of US
X    laws, but I personally can't re-distribute a program contest winner
X    to the network!
X
X
XSelected notes from the author:
X
X    PROGRAM USE
X
X    This program is a hello world text encrypter/decrypter. It uses an
X    enigma (I think) style encryption algorithm, where the encryption
X    key character is modified by a value, determined from the previous
X    character.  Non-printable characters (those with ASCII values < ' '
X    or > 0x7e) are passed unaltered, thus any kind of file may be
X    successfully procesed, but if the original is printable, the
X    processed file will be too. The input is read from stdin, and the
X    output presented to stdout. The key, a text string, is presented as
X    a command argument. This is optional, and if ommitted, the file is
X    self-{de,en}crypted. To specify decryption, a "-" should be given
X    before the key. (Actually encryption and dycryption proper inverse
X    operations, so you can use decrypt to scramble and encrypt to
X    descramble, if you're perverse.)
X
X    PORTABILITY (A little knowledge is a dangerous thing)
X
X    Its written in ANSI C, and doesn't even assume an ASCII character
X    set, (it has an array of the characters to convert), so should be
X    portable across many platforms. It passes gcc -ansi -pedantic -O
X    -Wall with no warnings (You may get assignment in conditional
X    warnings on other platforms though).  Because I've heard that
X    conditional jumps slow down fast processors, I've eliminated all
X    the ifs from the code, indeed, as its only one statement, it should
X    compile to one instruction an a suitably designed CISC machine. To
X    speed compilation, there is only one statement in the loop, so that
X    another scoping level does not need to be opened.
X
X    Being an encrypter/decrypter, you probably want the source code to
X    be obfuscated, to hide the algorithm.
X
X    OBFUSCATION
X
X    Inspite of the fact that it looks like a nice friendly hello world
X    program, it isn't (as documented above). (Short lines have been padded,
X    as you'll find if you look at an encrypted copy of the source.)
X
X    I've also named some of the macros from commonly used functions,
X    just to keep things muddy. Of course, all the variables are
X    misnamed. The program is kept simply (one for statement), by
X    serious overuse of , and ? :. These are really confusing when used
X    together, nested or put in argument lists (is that a comma
X    operator, or argument separator?)
END_OF_FILE
  if test 4546 -ne `wc -c <'1992/nathan.hint'`; then
    echo shar: \"'1992/nathan.hint'\" unpacked with wrong size!
  fi
  # end of '1992/nathan.hint'
fi
if test -f '1992/third' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/third'\"
else
  echo shar: Extracting \"'1992/third'\" \(6605 characters\)
  sed "s/^X//" >'1992/third' <<'END_OF_FILE'
X: immediate _read @ ! - * / <0 exit echo key _pick
X
X: debug immediate 1 5 ! exit
X
X: r 1 exit
X
X: ] r @ 1 - r ! _read ]
X
X: _main immediate r @ 7 ! ]
X_main
X
X
X: _x 3 @ exit
X: _y 4 @ exit
X: _x! 3 ! exit
X: _y! 4 ! exit
X
X
X: swap _x! _y! _x _y exit
X
X: + 0 swap - - exit
X
X: dup _x! _x _x exit
X
X: inc dup @ 1 + swap ! exit
X
X: h 0 exit
X
X: , h @ ! h inc exit
X
X
X: ' r @ @ dup 1 + r @ ! @ exit
X
X: ; immediate ' exit , exit
X
X
X: drop 0 * + ;
X
X: dec dup @ 1 - swap ! ;
X
X: tor r @ @ swap r @ ! r @ 1 + r ! r @ ! ;
X
X: fromr r @ @ r @ 1 - r ! r @ @ swap r @ ! ;
X
X: tail fromr fromr drop tor ;
X
X: minus 0 swap - ;
X
X: bnot 1 swap - ;
X
X: < - <0 ;
X
X: logical dup 0 < swap minus 0 < + ;
X
X: not logical bnot ;
X
X: = - not ;
X
X: branch r @ @ @ r @ @ + r @ ! ;
X
X: computebranch 1 - * 1 + ;
X
X: notbranch
X  not
X  r @ @ @
X  computebranch
X  r @ @ +
X  r @ !
X;
X
X: here h @ ;
X
X: if immediate ' notbranch , here 0 , ;
X
X: then immediate dup here swap - swap ! ;
X
X: ')' 0 ;
X
X: _fix key drop key swap 2 + ! ;
X
X: fix-')' immediate ' ')' _fix ;
X
Xfix-')' )
X
X: find-) key ')' = not if tail find-) then ;
X
X: ( immediate find-) ;
X
X( we should be able to do FORTH-style comments now )
X
X( this works as follows: ( is an immediate word, so it gets
X  control during compilation.  Then it simply reads in characters
X  until it sees a close parenthesis.  once it does, it exits.
X  if not, it pops off the return stack--manual tail recursion. )
X
X( now that we've got comments, we can comment the rest of the code! )
X
X: else immediate
X  ' branch ,		( compile a definite branch )
X  here			( push the backpatching address )
X  0 ,			( compile a dummy offset for branch )
X  swap			( bring old backpatch address to top )
X  dup here swap -	( calculate the offset from old address )
X  swap !		( put the address on top and store it )
X;
X
X: over _x! _y! _y _x _y ;
X
X: add
X  _x!			( save the pointer in a temp variable )
X  _x @			( get the value pointed to )
X  +			( add the incremement from on top of the stack )
X  _x !			( and save it )
X;
X
X: allot	h add ;
X
X: maybebranch
X  logical		( force the TOS to be 0 or 1 )
X  r @ @ @		( load the branch offset )
X  computebranch	( calculate the condition offset [either TOS or 1])
X  r @ @ +		( add it to the return address )
X  r @ !		( store it to our return address and return )
X;
X
X: mod _x! _y!		( get x then y off of stack )
X  _y
X  _y _x / _x *		( y - y / x * x )
X  -
X;
X
X: '\n' 0 ;
X: '"' 0 ;
X: '0' 0 ;
X: 'space' 0 ;
X
X: fix-'\n' immediate ' '\n' _fix ;
X: fix-'"' immediate ' '"' _fix ;
X: fix-'0' immediate ' '0' _fix ;
X: fix-'space' immediate ' 'space' _fix ;
X
Xfix-'0' 0 fix-'space'  fix-'"' "
Xfix-'\n'
X
X
X: cr '\n' echo exit
X
X: printnum
X  dup
X  10 mod '0' +
X  swap 10 / dup
X  if
X    printnum 0
X  then
X  drop echo
X;
X
X: .
X  dup 0 <
X  if
X    45 echo minus
X  then
X  printnum
X  'space' echo
X;
X
X
X: debugprint dup . cr ;
X
X( the following routine takes a pointer to a string, and prints it,
X  except for the trailing quote.  returns a pointer to the next word
X  after the trailing quote )
X
X: _print
X  dup 1 +
X  swap @
X  dup '"' =
X  if
X    drop exit
X  then
X  echo
X  tail _print
X;
X
X: print _print ;
X
X  ( print the next thing from the instruction stream )
X: immprint
X  r @ @
X  print
X  r @ !
X;
X
X: find-"
X  key dup ,
X  '"' =
X  if
X    exit
X  then
X  tail find-"
X;
X
X: " immediate
X  key drop
X  ' immprint ,
X  find-"
X;
X
X: do immediate
X  ' swap ,		( compile 'swap' to swap the limit and start )
X  ' tor ,		( compile to push the limit onto the return stack )
X  ' tor ,		( compile to push the start on the return stack )
X  here			( save this address so we can branch back to it )
X;
X
X: i r @ 1 - @ ;
X: j r @ 3 - @ ;
X
X: > swap < ;
X: <= 1 + < ;
X: >= swap <= ;
X
X: inci 
X  r @ 1 - 	( get the pointer to i )
X  inc		( add one to it )
X  r @ 1 - @ 	( find the value again )
X  r @ 2 - @	( find the limit value )
X  <
X  if
X    r @ @ @ r @ @ + r @ ! exit		( branch )
X  then
X  fromr 1 +
X  fromr drop
X  fromr drop
X  tor
X;
X  	
X: loop immediate ' inci , here - , ;
X
X: loopexit
X
X  fromr drop		( pop off our return address )
X  fromr drop		( pop off i )
X  fromr drop		( pop off the limit of i )
X;			( and return to the caller's caller routine )
X
X: isprime
X  dup 2 = if
X    exit
X  then
X  dup 2 / 2		( loop from 2 to n/2 )
X  do
X    dup			( value we're checking if it's prime )
X    i mod		( mod it by divisor )
X    not if
X      drop 0 loopexit	( exit from routine from inside loop )
X    then
X  loop 
X;
X
X: primes
X  " The primes from "
X  dup .
X  "  to "
X  over .
X  "  are:"
X  cr
X
X  do
X    i isprime 
X    if
X      i . 'space' echo
X    then
X  loop
X  cr
X;
X
X: execute
X  8 !
X  ' exit 9 !
X  8 tor
X;
X
X: :: ;		( :: is going to be a word that does ':' at runtime )
X
X: fix-:: immediate 3 ' :: ! ;
Xfix-::
X
X	( Override old definition of ':' with a new one that invokes ] )
X: : immediate :: ] ;
X
X: command
X  here 5 !		( store dict pointer in temp variable )
X  _read			( compile a word )
X			( if we get control back: )
X  here 5 @
X  = if
X    tail command	( we didn't compile anything )
X  then
X  here 1 - h !		( decrement the dictionary pointer )
X  here 5 @		( get the original value )
X  = if
X    here @		( get the word that was compiled )
X    execute		( and run it )
X  else
X    here @		( else it was an integer constant, so push it )
X    here 1 - h !	( and decrement the dictionary pointer again )
X  then
X  tail command
X;
X
X: make-immediate	( make a word just compiled immediate )
X  here 1 -		( back up a word in the dictionary )
X  dup dup		( save the pointer to here )
X  h !			( store as the current dictionary pointer )
X  @			( get the run-time code pointer )
X  swap			( get the dict pointer again )
X  1 -			( point to the compile-time code pointer )
X  !			( write run-time code pointer on compile-time pointer )
X;
X
X: <build immediate
X  make-immediate	( make the word compiled so far immediate )
X  ' :: ,		( compile '::', so we read next word )
X  2 ,			( compile 'pushint' )
X  here 0 ,		( write out a 0 but save address for does> )
X  ' , ,			( compile a push that address onto dictionary )
X;
X
X: does> immediate
X  ' command ,		( jump back into command mode at runtime )
X  here swap !		( backpatch the build> to point to here )
X  2 ,			( compile run-code primitive so we look like a word )
X  ' fromr ,		( compile fromr, which leaves var address on stack )
X;
X
X
X: _dump			( dump out the definition of a word, sort of )
X  dup " (" . " , "
X  dup @			( save the pointer and get the contents )
X  dup ' exit
X  = if
X	" ;)" cr exit
X  then
X  . " ), "
X  1 +
X  tail _dump
X;
X
X: dump _dump ;
X
X: # . cr ;
X  
X: var <build , does> ;
X: constant <build , does> @ ;
X: array <build allot does> + ;
X
X: [ immediate command ;
X: _welcome " Welcome to THIRD.
XOk.
X" ;
X
X: ; immediate ' exit , command exit
X
X[
X
X_welcome
END_OF_FILE
  if test 6605 -ne `wc -c <'1992/third'`; then
    echo shar: \"'1992/third'\" unpacked with wrong size!
  fi
  # end of '1992/third'
fi
if test -f '1992/vern.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/vern.hint'\"
else
  echo shar: Extracting \"'1992/vern.hint'\" \(6513 characters\)
  sed "s/^X//" >'1992/vern.hint' <<'END_OF_FILE'
XBest of Show: <vern@ee.lbl.gov> Vern Paxson
X
X	Vern Paxson
X	Lawrence Berkeley Laboratory
X	Computer Systems Engineering
X	Bldg. 46A, Room 1123
X	Lawrence Berkeley Laboratory
X	1 Cyclotron Rd.
X	Berkeley, CA 94720  USA
X
X
XJudges' comments:
X
X     Try: 
X	make vern
X	vern 3		<-- default is 2
X
X     You might start off by giving the following input:
X	63 43
X	76 55
X	71 52
X	67 57		(this may take a while)
X    
X    The judges assume no responsibility for the obfuscated opening
X    suggested above.  :-)
X
X    For a real quick game try:
X	vern
X
X	65 55
X	66 46
X
X    NOTE: Move values must be restricted to the range 00 to 77.
X
X    NOTE: Because some mailers have problems with the original winning source,
X	  a slightly modified version with shorter lines has been provided.
X
X
XSelected notes from the author:
X
X    This program plays chess.  You play the white pieces and the program
X    the black pieces.  Moves are entered as a two-digit number specifying
X    the coordinates of the piece to be moved followed by another two-digit
X    number specifying the coordinates of where to move it.  Rows and
X    columns are numbered starting with (0,0) for the upper-lefthand corner
X    (black's queen's rook) and going to (7,7) for the lower-righthand
X    corner (white's king's rook).  For example, the PK4 opening for white
X    is indicated as "64 44".  Moves are read using scanf() so care should
X    be taken to not enter the wrong number of fields.
X
X    If the move you enter is illegal then you are just prompted again to
X    move.  If the move is legal then the new position is displayed and the
X    program starts computing its response.  For every 64 board positions it
X    examines a "." is printed.  Once it has chosen its move it simply
X    displays the board updated to reflect the move.
X
X    Your move is prompted for using a string like "1351 9 2 >".  The first
X    number is how many board positions the program examined when computing
X    its previous response.  The second number is its anticipated value for
X    the move it just made (with larger numbers meaning an ultimately better
X    board position for it), and the third number is the evaluation it
X    assigns to the your current position (larger numbers meaning better
X    positions for you).  A ">" indicates that you are not in check; for
X    check it is changed to "!".
X
X    There are a few limitations on play:
X
X    o	    castling can only be done on the king's side;
X    o	    prohibitions against castling out of or through check are
X     		not enforced;
X    o	    prohibitions against castling if the king or rook have moved
X     		are not enforced;
X    o	    pawns are always promoted to queens;
X    o	    en passant is not allowed;
X    o	    the board-position-repeated-three-times and fifty-moves
X     		stalemates are not recognized;
X
X    If you checkmate the computer it prints "Rats!" and exits.  If your own
X    checkmate is imminent it prints "Har har." but doesn't exit so it can
X    rub your nose in defeat (which may be a move or two away if you're
X    playing at a high "ply" - see the next paragraph).  Stalemates are not
X    recognized per se, but when selecting its move the program assigns a
X    stalemate position a value of 0 so it will try for a stalemate if its
X    other options are worse.
X
X    The program takes one optional argument indicating the ply (lookahead)
X    it should use.  The default is 2, which is enough to keep it from
X    making flaming blunders.  The higher the ply, the better the play, and
X    the longer you have to wait.  For example, at a ply of 2, a response to
X    the PK4 opening takes about 1.8 CPU seconds on a SPARC ELC when
X    compiled -O with Sun cc.  A ply of 3 takes 13 CPU seconds (and results
X    in a different response to PK4) and a ply of 4 takes a little under 4
X    CPU minutes (and for PK4 comes up with the same response as a ply of
X    3).  A ply of 3 is in general good enough to avoid not only flaming
X    blunders but also immediately stupid moves altogether.  A ply of 4
X    will find all mate-in-two's.
X
X
X
X    This program is obfuscated in a number of ways.  First, it abuses the
X    contest rule regarding ';', '{', and '}' in the source not counting
X    against the non-whitespace character limit if followed by whitespace.
X    As can be seen from the build file, certain combinations of these
X    characters followed by a particular whitespace character are expanded
X    at build time into much-needed text.  Without this hack the program
X    wouldn't pass the character limit.  A nice side effect is that the
X    initial source is gloriously difficult to peruse.
X
X    Second, the rather ho-hum step has been taking of naming each variable
X    with a one or two letter identifier to render it meaningless (and save
X    space).  This tactic is rather effective in a complex program.
X
X    Third, the board is represented not as an array of pieces but rather as
X    an array of function pointers (with a separate array representing
X    whether a piece is white or black).  This obfuscates the program's
X    central data structure.  There is one function per type of piece; when
X    called they return 1 if the current move is illegal for that piece and
X    0 if it is legal.  The functions also as a side effect set a global
X    indicating the type of the piece (though the type can also be determined
X    by comparing the function pointer with the function itself).
X
X    Fourth, there are no independent routines for generating potential
X    moves.  Instead, the program generates its moves by brute force: for
X    every piece it controls on the board, it attempts to move it to every
X    square on the board.  Those moves that are legal it then explores to
X    see their effects (using alpha-beta search).  This tactic somewhat
X    obfuscates the algorithm used by the program.
X
X    Finally, there are three key constants that occur throughout the
X    program:  64, 8, and 3 (lg 8).  Rather than making these available at
X    compile-time, which provides a hint as to what the program is up to,
X    they are computed probabilistically at run-time.  An instance of the
X    "Inspection Paradox" is used which happens to produce a value that on
X    average is close to .64.  10000 instances of this value are computed,
X    added up, and then divided by 100.  Sometimes the value produced will
X    be 63 or 65 instead of 64 (but I've never observed any other values),
X    so the result is then rounded to the nearest multiple of 4, and then
X    the other constants are derived from it.
END_OF_FILE
  if test 6513 -ne `wc -c <'1992/vern.hint'`; then
    echo shar: \"'1992/vern.hint'\" unpacked with wrong size!
  fi
  # end of '1992/vern.hint'
fi
if test -f '1992/vern.orig.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/vern.orig.c'\"
else
  echo shar: Extracting \"'1992/vern.orig.c'\" \(3201 characters\)
  sed "s/^X//" >'1992/vern.orig.c' <<'END_OF_FILE'
X#include <stdio.h>
X;	m(x)(x<0?-1:!!x)
X;	g tj()-J
X;	a(x)(x<0?-x:x)
X;	h(x)((x)<=K?x:N-(x))
X;	f 9999
X;	A return
X;	H printf{ 
X;	R double
X;	U int
X;	V for
X;	b else
X;	u while
X;	B if
XU v,w,Y}	 -1,W,J,p,F,o}	f,M,N,K,X,YY,_,P[f],s{ } ;
Xtypedef U{ *L} { } ;
XL q[f];
Xtj{ } {
XU S}	m{ v} +{ m{ w} <<K} ; 
XB{ !S} A J; 
XV{ v}	W+S; v!}	J&&!q[v]; v+}	S} ;
XA v; 
X}
Xk{ } {
X_}	K; 
XA v?a{ v} >1||w-Y||!q[J]:{ w-Y&&{ w-Y*2||q[W+Y*{ N+1} ]||
X    { J>>K} -K+{ Y-1} / 2} } ||q[J]; 
X}
Xz{ } {
X_}	5; 
XA v*w||g; 
X}
Xe{ } {
X_}	 -2; 
XA{ v*v*v-v||w*w*w-w} &&{ J-W-2||{ W&N} -4||{ W>>K!}	{ Y-1?N:0} } ||
X    q[W+1]||q[W+2]||q[W+K]!}	z||P[W+K]*Y<0} ; 
X}
XR VR{ } {
Xint PZ}	0x7fff; 
XA{ R} { rand{ } &PZ} /{ R} PZ; 
X}
Xl{ } {
X_}	K+1; 
XA{ v*w&&a{ v} -a{ w} } ||g; 
X}
XR UC{ } {
XR {	}	0,d; 
Xu{ { {	+}	d}	VR{ } } <1.0} ; 
XA d; 
X}
Xc{ } {
X_}	 -11; 
XA a{ v} -a{ w} ||g; 
X}
XI{ ur,n,x} {
XW}	ur; 
XJ}	n; 
XB{ P[W]!}	Y||P[J]}	}	Y} A J+1;
Xv}	{ J&N} -{ W&N} ; 
Xw}	{ J>>K} -{ W>>K} ; 
XA q[W]{ } ||{ x&&QL{ W,J,s} } ; 
X}
XTT{ W} {
Xv}	w}	0; 
XA q[W]{ } +K; 
X}
Xs{ } {
XU j}	 -1,{	; 
XY}	 -Y; 
XV{ {	}	0; {	<M; ++{	} {
XB{ j<0&&P[{	]}	}	 -Y&&TT{ {	} &&_}	}	 -2} 
X{
Xj}	{	; 
X{	}	 -1; 
X}
Xb B{ j>}	0&&!I{ {	,j,0} } A Y}	 -Y; 
X}
XA!{ Y}	 -Y} ; 
X}
Xbb{ } {
X_}	1; 
XA a{ v*w} -2; 
X}
Xuv{ } {
XV{ v}	0; v<f; ++v} {
XB{ h{ v>>K} }	}	0} {
XU S}	h{ v&N} ;
Xq[v]}	!S?z:{ S}	}	1?bb:{ S}	}	2?c:{ v&N>K?l:e} } } ; 
X}
Xb B{ h{ v>>K} }	}	1} q[v]}	k; 
Xb q[v]}	0;
XP[v]}	!!q[v]*{ 28-v} ; 
X}
X}
Xy{ } {
XU G}	Y,{	; 
XJ}	0; 
XV{ {	}	0; {	<M; ++{	} {
X{	%8||H"\n%4o ",{	} ;
XB{ { Y}	P[{	]}	m{ P[{	]} } &&TT{ {	} } H"%c ",_+93+Y*16} ; 
Xb H"- "} ; 
X}
XH"\n    "} ; 
Xdo 
XH"%2d",{	++&N} ; 
Xu{ {	&N} ; 
XY}	G; 
XH"\n"} ; 
X}
XO{ W,J} {
XB{ { q[J]}	q[W]} }	}	k&&h{ J>>K} }	}	0} q[J]}	l; 
XB{ q[W]}	}	e} B{ J-W}	}	2} O{ J+1,J-1} ;
Xb B{ W-J}	}	2} O{ W-1,W+1} ; 
XP[J]}	P[W]; 
Xq[W]}	0;
XP[W]}	0; 
X}
XQL{ W,J,D} L D; 
X{
XU HQ}	P[J],YX; 
XL AJ}	q[J],XY}	q[W]; 
XO{ W,J} ; 
XYX}	D{ } ;
XO{ J,W} ; 
Xq[J]}	AJ; 
Xq[W]}	XY; 
XP[J]}	HQ; 
XA YX; 
X}
XC{ } {
XU {	,j,BZ}	0; 
XV{ {	}	0; {	<M; ++{	} {
XL Z}	q[{	]; 
XB{ Z} {
XU r}	h{ {	>>K} +h{ {	&N} ,G}	Y,
X    S}	Z}	}	z?88:{ Z}	}	k?11+r+{ P[{	]<0?N-{ {	>>K} :{ {	>>K} } :
X{ Z}	}	l?124-{ { YY<8&&{ { {	&N} !}	K||
X    { {	>>K} !}	{ P[{	]>0?0:N} } } ?M:0} :
X{ Z}	}	c?41+r:{ Z}	}	e?f-r-r:36+r+r} } } } ; 
XY}	P[{	];
XV{ j}	0; j<M; ++j} B{ !I{ {	,j,0} } S+}	{ P[j]?5:1} ; 
XBZ+}	G}	}	Y?S:-S;
XY}	G; 
X}
X}
XB{ !{ ++X&M-1} } write{ 1,".",1} ; 
XA BZ; 
X}
XPX{ } {
XU {	,Q}	0,XP}	0,JZ}	M*M,E}	 -f,t,S}	o; 
XB{ !F--} A++F+C{ } ;
XV{ {	}	0; {	<JZ; ++{	} B{ !I{ {	>>K+K,{	&M-1,1} } {
XY}	 -Y; 
Xo}	 -E;
Xt}	 -QL{ {	>>K+K,{	&M-1,PX} ; 
XY}	 -Y; 
XB{ t>E} {
X++XP; 
XQ}	{	; 
XE}	t; 
XB{ E>}	S} 
XA++F,E; 
X}
X}
XB{ !XP} E}	s{ } ?-f+1:0; 
Xp}	Q; 
XA++F,E; 
X}
XRZ{ } {
XU {	,j,T}	0; 
XV{ ; ; } {
Xy{ } ; 
Xo}	f; 
Xdo{
XH"\n%d %d %d %s ",X,T,C{ } ,s{ } ?"!":">"} ;
Xfflush{ stdout} ; 
X}
Xu{ scanf{ "%o%o",&{	,&j} !}	2||I{ {	,j,1} } ;
XO{ {	,j} ; 
Xy{ } ; 
XX}	0; 
X++YY;
XY}	 -Y; 
XT}	PX{ } ; 
X{	}	p>>{ K<<1} ; 
Xj}	p&{ M-1} ; 
XB{ I{ {	,j,1} } {
XH"Rats!\n"} ; 
XA; 
X}
XO{ {	,j} ; 
XY}	 -Y; 
XB{ T>M*M} H"\nHar har.\n"} ; 
X}
X}
Xmain{ ac,av} char**av; 
X{
Xlong time{ } ,j}	time{ &j} ; 
XR {	}	0; 
Xsrand{ { U} j} ;
XV{ M}	0; M<}	f; ++M} {	+}	UC{ } ; 
XM}	{	/100;
XB{ M&3} ++M; 
XB{ M&1} --M; 
XV{ N}	1; N*N<M; ++N} ;
XK}	 --N/2; 
XF}	ac>1?atoi{ av[1]} :2; 
Xuv{ } ;
XRZ{ } ; 
X}
END_OF_FILE
  if test 3201 -ne `wc -c <'1992/vern.orig.c'`; then
    echo shar: \"'1992/vern.orig.c'\" unpacked with wrong size!
  fi
  # end of '1992/vern.orig.c'
fi
if test -f '1992/westley.hint' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'1992/westley.hint'\"
else
  echo shar: Extracting \"'1992/westley.hint'\" \(4374 characters\)
  sed "s/^X//" >'1992/westley.hint' <<'END_OF_FILE'
XBest Small Program: <merlyn@digibd.com> Brian Westley (aka Merlyn LeRoy)
X
X	Brian Westley (aka Merlyn LeRoy)
X	Digi International
X	1026 Blair Ave.
X	St. Paul, MN  55104
X	USA
X
X
XJudges' comments:
X
X    If lost:
X	make whereami
X    
X    Then run:
X	whereami lat long
X    
X    Where lat and long correspond to your latitude and longitude.
X
X    To find the approximate place where this entry was judged, type:
X
X	whereami 37 -122	(- means west of meridian)
X    
X
XSelected notes from the author:
X
X    Run the program with your latitude & longitude as integer
X    arguments; it will produce a map made up of '!' with the given
X    position marked with either a '"' (if the position is over a '!')
X    or a '#' (if the position is over a space).  Southern latitudes
X    and western longitudes are entered as negative numbers.  For
X    example, to find San Francisco, run with "prog 38 -122".  The
X    resolution of the map is five degrees horizontally, ten degrees
X    vertically.  The map is a Mercator projection with equal spacing
X    of the latitudes, so the areas near the poles are very distorted.
X    Latitudes near the poles and Antarctica are not shown.
X
X    The program requires the ASCII character set, putchar(), atoi(),
X    and a display that auto-wraps at 80 characters(!).  If your display
X    does not work this way, you will have to massage the output;
X    for example, you can pipe it to a file and edit it with vi,
X    which will do autowrap for you.
X
X    Lint complains that main() returns a random value and I'm not
X    checking the value that putchar() returns.  Scandalous!
X
X    If you run it with fewer than 2 arguments, it will likely
X    give you an exception, as it will access arguments that
X    don't exist and characters before a string constant.
X
X    How it works:
X
X    The map is printed as one long string of ' ' and '!' characters,
X    with the autowrap used to stack up slices of 80.  The map data is
X    a string; the first character is how many '!'s are printed
X    ('A'=1, 'B'=2, etc), the second character is how many ' 's, the
X    third is how many '!'s, etc.  ASCII characters less than 'A'
X    print no characters but still change the polarity, so any map
X    of ' 's and '!'s is possible.  This is done in the putchar()
X    argument as "33^l&1", where l is the character position+4; if
X    l is odd, ' ' is printed, if l is even, '!' is printed.
X
X    The position of latitude & longitude is changed into a single
X    character position within the one long string via the first
X    expression "d = latitude/10*80 - longitude/5 - offset"  The
X    latitude is divided by ten because the vertical resolution is
X    ten degrees, then multiplied by 80 because of the 80 character
X    wrap (i.e. each ten degrees moves the position up or down one
X    entire row).  The longitude is divided by five and added, because
X    five degrees of change moves the location one character.  The signs
X    are opposite because latitude is decreasing and longitude is
X    increasing as you go from upper left to lower right.  The offset
X    is where the origin (latitude=0, longitude=0) is found.
X
X    The position counting down to zero changes the putchar() from
X    printing ('!' or ' ') to printing ('"' or '#').
X
X    The "H E L L O,   W O R L D!" string inside the data string
X    prints the line of blanks past Tierra del Fuego and the last
X    blank line.  It's just for show, really.
X
X    Since the resolution is coarse, a few costal cities are shown to
X    be just off the map; this is an unavoidable artifact.  The map
X    is reasonably accurate.
X
X    Here are some cities you might like to try:
X
X         New York  41  -74       Los Angeles  34 -118
X           London  52    0             Paris  45    2
X           Moscow  56   38           Beijing  40  116
X        New Delhi  29   77    Rio de Janeiro -23  -43
X           Sydney -34  151             Tokyo  36  140
X
XFor a domestic (USA) version with higher resolution, try:
X---cut---
Xmain(l,a,n,d)char**a;{for(d=atoi(a[1])/2*80-atoi(a[2])-2043;
Xn="bnaBCOCXdBBHGYdAP[A M E R I C A].AqandkmavX|ELC}BOCd"
X[l++-3];)for(;n-->64;)putchar(!d+++33^l&1);}
X---cut---
XThe code will test the 80-column wrap and document itself if it is
Xjoined together as one 160-character line and listed.  You should see:
X
Xmain(l,a,n,d)...
X[A M E R I C A]...
X
X...going down the left edge if your terminal autowraps at 80 characters.
END_OF_FILE
  if test 4374 -ne `wc -c <'1992/westley.hint'`; then
    echo shar: \"'1992/westley.hint'\" unpacked with wrong size!
  fi
  # end of '1992/westley.hint'
fi
echo shar: End of archive 3 \(of 5\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
