Newsgroups: comp.sources.misc
From: jsp@Princeton.EDU (James Plank)
Subject:  v32i090:  jgraph - A filter for plotting postscript graphs v8.0, Patch02
Message-ID: <1992Sep21.205654.6957@sparky.imd.sterling.com>
X-Md4-Signature: 6280599e74cabb2d80a2f1a5f5a1612b
Date: Mon, 21 Sep 1992 20:56:54 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jsp@Princeton.EDU (James Plank)
Posting-number: Volume 32, Issue 90
Archive-name: jgraph/patch02
Environment: UNIX, VMS, postscript
Patch-To: jgraph: Volume 31, Issue 31-37

Jgraph patch 8.2: Mon Sep 21 10:56:27 EDT 1992

Another patch to jgraph:

- The bounding box was changed from floats to ints so that it
  could be compatible with more packages.

- Added the tokens 'pattern', 'ppattern' and 'apattern', so 
  that whenever you're able to fill something (e.g. a 
  mark) you can specify a pattern -- currently the only
  patterns are 'solid' and 'stripe', but the addition of
  stripes should greatly benefit those who use jgraph for
  bar graphs.  See the man page under 'pattern'.

- I finally gave in and put filenames on the command line.
  If you omit the filename, it will read in from standard 
  input as before.

- Added a marktype 'eps' so you can include encapsulated postscript
  files as marks.  I've been using it to include jgraph files in other
  jgraph files.  In theory it should work with all encapsulated 
  postsctript files, but I haven't tested that.

As always, version 8.2 is available via anonymous ftp to princeton.edu
  in the file pub/jgraph.Z.  It's a compressed shar file.  Remember
  to set ftp to binary before getting the file.

Or, you can get jgraph from netlib:  

  echo "send jgraph.shar from jgraph" | mail netlib@ornl.gov

Let me know if there are any problems.

Take it easy,

Jim
jsp@princeton.edu


Patch from v8.1:

*** ../work/NeXT.help	Mon Sep 21 10:52:12 1992
--- NeXT.help	Mon Sep 21 10:42:47 1992
***************
*** 1,6 ****
  To compile jgraph on the NeXT machines, compile with -DLCC.  This will
! define LCC in jgraph.h so that <stdlib.h> will be included.  Otherwise,
! the compilation will go fine, but there will be type conversion errors
! in token.c which will give bogus output.
  
  Jim
--- 1,6 ----
  To compile jgraph on the NeXT machines, compile with -DLCC.  This will
! define LCC in jgraph.h and token.c so that <stdlib.h> will be included.  
! Otherwise, the compilation will go fine, but there will be type conversion 
! errors in token.c which will give bogus output.
  
  Jim
*** ../work/README	Mon Sep 21 10:52:12 1992
--- README	Mon Sep 21 10:42:47 1992
***************
*** 1,4 ****
! $Revision: 8.1 $
  
  Jgraph takes the description of a graph or graphs in the standard
  input, and produces a postscript file on the standard output.  Jgraph
--- 1,4 ----
! $Revision: 8.2 $
  
  Jgraph takes the description of a graph or graphs in the standard
  input, and produces a postscript file on the standard output.  Jgraph
*** ../work/acc.jgr	Mon Sep 21 10:52:13 1992
--- acc.jgr	Mon Sep 21 10:42:55 1992
***************
*** 25,37 ****
  
  newcurve
    label : GE
!   marktype xbar fill .3 marksize .4
    pts
!     3   7.9602  (* 518.2473 Kb/sec *)
  
  newcurve
    label : RNG
!   marktype xbar fill 0 marksize .4
    pts
      4   8.2876  (* 539.5619 Kb/sec *)
  
--- 25,37 ----
  
  newcurve
    label : GE
!   marktype xbar fill .3 pattern stripe 40 marksize .4
    pts
!     3   27.9602  (* 518.2473 Kb/sec *)
  
  newcurve
    label : RNG
!   marktype xbar fill 0 pattern stripe marksize .4
    pts
      4   8.2876  (* 539.5619 Kb/sec *)
  
*** ../work/acc.tex	Mon Sep 21 10:52:13 1992
--- acc.tex	Mon Sep 21 10:42:59 1992
***************
*** 8,14 ****
  A sample bar graph
  
  \begin{figure}[h]
! \centerline{\psfig{figure=acc.jps}}
  \end{figure}
  
  \end{document}
--- 8,14 ----
  A sample bar graph
  
  \begin{figure}[h]
! \centerline{\psfig{figure=acc.eps}}
  \end{figure}
  
  \end{document}
*** /dev/null	Mon Sep 21 10:25:34 1992
--- ad.jgr	Mon Sep 21 10:42:56 1992
***************
*** 0 ****
--- 1,16 ----
+ newgraph 
+ xaxis min 0 max 5.5 size 5.5 nodraw
+ yaxis min 0 max 2.8 size 2.8 nodraw
+ 
+ newcurve eps cube.eps marksize 1.25 2.8 pts .6 1.4
+ newcurve eps disk.eps marksize .8 .8 pts 
+    4.7 1.6
+    4.5 1.3
+    4.3 1
+    4.1 0.7
+ 
+ newline asize .2 .1 linethickness 3 rarrow 
+           pts 1.4 1.5 4.0 1.6
+ copycurve pts 1.4 1.4 3.8 1.3
+ copycurve pts 1.4 1.3 3.6 1.0
+ copycurve pts 1.4 1.2 3.4 0.7
*** /dev/null	Mon Sep 21 10:25:34 1992
--- cube.jgr	Mon Sep 21 10:42:56 1992
***************
*** 0 ****
--- 1,35 ----
+ (* Drawing of the hypercube:  
+    Dimensions = 1.25 * 2.55 *)
+ 
+ newgraph 
+ xaxis min 0 max 1.25 size 1.25 nodraw
+ yaxis min -0.30 max 2.25 size 2.55 nodraw
+ 
+ (* Legs *)
+ newline poly pfill 0 pts
+   0.50  0.00   0.75  0.00   0.75 -0.20   0.50 -0.20
+ copycurve pts
+   0.75 -0.20   1.20 -0.30   1.23 -0.28   0.75 -0.10
+ copycurve pts
+   0.50 -0.20   0.05 -0.30   0.02 -0.28   0.50 -0.10
+ copycurve pts
+   0.75 -0.05   1.20  0.03   1.23  0.02   0.75 -0.13
+ copycurve pts
+   0.50 -0.05   0.05  0.03   0.02  0.02   0.50 -0.13
+ 
+ (* Box *)
+ newline poly pfill 1 pts
+   0.00 0.00   1.00 0.00   1.00 2.00   0.00 2.00   
+ copycurve pfill .80 pts
+   0.00 2.00   0.25 2.20   1.25 2.20   1.00 2.00
+ copycurve pfill .9 pts
+   1.00 2.00   1.25 2.20   1.25 0.25   1.00 0.00
+ 
+ 
+ newline poly pfill 0 pts
+   0.60 0.70   0.60 1.80   0.90 1.80   0.90 0.70
+ 
+ newcurve marktype box marksize .03 .08 fill 1 pts
+   shell : awk ' BEGIN { for (i = 0.65; i < 0.90; i += 0.05) {\
+                           for (j = 0.80; j < 1.70; j += 0.15) {\
+                             printf("%f %f\n", i, j); } } }'
*** /dev/null	Mon Sep 21 10:25:34 1992
--- disk.jgr	Mon Sep 21 10:42:56 1992
***************
*** 0 ****
--- 1,13 ----
+ newgraph
+ xaxis min 0 max 0.4 nodraw
+ yaxis min 0 max 0.4 nodraw
+ 
+ (* Picture of a disk:
+    0 0 to 0.4 0.4 *)
+ 
+ newcurve marktype ellipse fill .5 marksize 0.4 0.2 pts 0.2 0.1
+ newcurve marktype box fill .5 gray .5 marksize 0.4 0.2 pts 0.2 0.2
+ newline pts 0.0 0.1   0.0 0.3
+ newline pts 0.4 0.1   0.4 0.3
+ newcurve marktype ellipse fill 1 marksize 0.4 0.2 pts 0.2 0.3
+ 
*** ../work/draw.c	Mon Sep 21 10:52:16 1992
--- draw.c	Mon Sep 21 10:42:48 1992
***************
*** 1,7 ****
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/draw.c,v $
!  * $Revision: 8.1 $
!  * $Date: 92/07/20 16:44:32 $
   * $Author: jsp $
   */
  
--- 1,7 ----
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/draw.c,v $
!  * $Revision: 8.2 $
!  * $Date: 92/09/21 10:40:52 $
   * $Author: jsp $
   */
  
***************
*** 211,217 ****
        if (j != 0) {
          if (c->poly) {
            printf("closepath ");
!           setfill(c->pfilltype, c->pfill);
          }
          end_line();
        }
--- 211,217 ----
        if (j != 0) {
          if (c->poly) {
            printf("closepath ");
!           setfill(0.0, 0.0, c->pfilltype, c->pfill, c->ppattern, c->pparg);
          }
          end_line();
        }
***************
*** 235,241 ****
        if (i != 0) {
          if (c->poly) {
            printf("closepath ");
!           setfill(c->pfilltype, c->pfill);
          }
          end_line();
        }
--- 235,241 ----
        if (i != 0) {
          if (c->poly) {
            printf("closepath ");
!           setfill(0.0, 0.0, c->pfilltype, c->pfill, c->ppattern, c->pparg);
          }
          end_line();
        }
***************
*** 273,282 ****
  Graph g;
  {
    Point p;
!   float ms0, ms1;
    int i, j;
    FILE *f;
    char ch;
  
    if (c->marktype == 'n') return;
    ms0 = c->marksize[0] / 2.0;
--- 273,285 ----
  Graph g;
  {
    Point p;
!   float ms0, ms1, scx, scy, trx, try;
    int i, j;
    FILE *f;
    char ch;
+   int done, newline;
+   char inp[100];
+   int bb[4];
  
    if (c->marktype == 'n') return;
    ms0 = c->marksize[0] / 2.0;
***************
*** 287,292 ****
--- 290,349 ----
  
    switch (c->marktype) {
      case 'n': break;
+     case 'E': if (c->eps == CNULL) break;
+               f = fopen(c->eps, "r");
+               if (f == NULL) {
+                 fprintf(stderr, "Error: eps file %s couldn't be opened\n",
+                       c->eps);
+                 exit(1);
+               }
+               /* Get bbox */
+               newline = 1;
+               done = 0;
+               while(!done) {
+                 while(!newline) {
+                   ch = getc(f);
+                   if (ch == real_eof) {
+                     fprintf(stderr, "Error: Eps file '%s' has %s\n",
+                             c->eps, "no bounding box");
+                     exit(1);
+                   }
+                   newline = (ch == '\n');
+                 }
+                 fscanf(f, "%s", inp); 
+                 if (strcmp(inp, "%%BoundingBox:") == 0) done = 1;
+               }
+               for (i = 0; i < 4; i++) {
+                 if (fscanf(f, "%d", &(bb[i])) == NULL) {
+                   fprintf(stderr, "Error: Eps file '%s': eof in %s\n",
+                           c->eps, "bounding box");
+                   exit(1);
+                 }
+               }
+               if (bb[2] - bb[0] == 0) {
+                 scx = ms0;
+                 trx = 0.0;
+               } else {
+                 scx = ms0 * 2.0/(float)(bb[2] - bb[0]);
+                 trx = -(float)(bb[2] - bb[0])/2.0 - bb[0];
+               }
+               if (bb[3] - bb[1] == 0) {
+                 scy = ms1;
+                 try = 0.0;
+               } else {
+                 scy = ms1 * 2.0/(float)(bb[3] - bb[1]);
+                 try = -(float)(bb[3] - bb[1])/2.0 - bb[1];
+               }
+ 
+               sprintf(inp, "Including eps file %s", c->eps);
+               comment(inp);
+               /* Use bbox to scale and translate */
+               printf("%f %f scale %f %f translate\n", scx, scy, trx, try);
+               /* Include the rest of the file */
+               for (ch = getc(f); ch != real_eof; ch = getc(f)) putchar(ch);
+               putchar('\n');
+               fclose(f);
+               break;
      case 'p': if (c->postscript == CNULL) break;
                printf("%f %f scale\n", ms0, ms1);
                if (!c->postfile) {
***************
*** 294,302 ****
                } else {
                  f = fopen(c->postscript, "r");
                  if (f == NULL) {
!                 fprintf(stderr, 
!                         "Error: postscript file %s couldn't be opened\n",
!                         c->postscript);
                    exit(1);
                  }
                  for (ch = getc(f); ch != real_eof; ch = getc(f)) putchar(ch);
--- 351,359 ----
                } else {
                  f = fopen(c->postscript, "r");
                  if (f == NULL) {
!                   fprintf(stderr, 
!                           "Error: postscript file %s couldn't be opened\n",
!                           c->postscript);
                    exit(1);
                  }
                  for (ch = getc(f); ch != real_eof; ch = getc(f)) putchar(ch);
***************
*** 311,323 ****
                cont_poly(ms0, -ms1);
                cont_poly(ms0, ms1);
                cont_poly(-ms0, ms1);
!               end_poly(c->filltype, c->fill);
                break;
      case 'd': start_poly(-ms0, 0.0);
                cont_poly(0.0, -ms1);
                cont_poly(ms0, 0.0);
                cont_poly(0.0, ms1);
!               end_poly(c->filltype, c->fill);
                break;
      case 'g': p = first(c->general_marks);
                if (p == nil(c->general_marks)) break;
--- 368,380 ----
                cont_poly(ms0, -ms1);
                cont_poly(ms0, ms1);
                cont_poly(-ms0, ms1);
!               end_poly(x, y, c->filltype, c->fill, c->pattern, c->parg);
                break;
      case 'd': start_poly(-ms0, 0.0);
                cont_poly(0.0, -ms1);
                cont_poly(ms0, 0.0);
                cont_poly(0.0, ms1);
!               end_poly(x, y, c->filltype, c->fill, c->pattern, c->parg);
                break;
      case 'g': p = first(c->general_marks);
                if (p == nil(c->general_marks)) break;
***************
*** 325,331 ****
                start_poly(p->x*ms0, p->y*ms1);
                for(p = next(p); p != nil(c->general_marks); p = next(p))
                  cont_poly(p->x*ms0, p->y*ms1);
!               end_poly(c->filltype, c->fill);
                break;
      case 'G': i = 0;
                for (p = first(c->general_marks);
--- 382,388 ----
                start_poly(p->x*ms0, p->y*ms1);
                for(p = next(p); p != nil(c->general_marks); p = next(p))
                  cont_poly(p->x*ms0, p->y*ms1);
!               end_poly(x, y, c->filltype, c->fill, c->pattern, c->parg);
                break;
      case 'G': i = 0;
                for (p = first(c->general_marks);
***************
*** 389,395 ****
                  i = (i + 1) % 3;
                }
                printf("closepath ");
!               setfill(c->filltype, c->fill);
                printf("stroke\n");
  
                if (i != 1) {
--- 446,452 ----
                  i = (i + 1) % 3;
                }
                printf("closepath ");
!               setfill(x, y, c->filltype, c->fill, c->pattern, c->parg);
                printf("stroke\n");
  
                if (i != 1) {
***************
*** 402,427 ****
      case 'x': printline(-ms0, -ms1, ms0, ms1, 'x');
                printline(-ms0, ms1, ms0, -ms1, 'x');
                break;
!     case 'o': printellipse(0.0, 0.0, ms0, ms0, c->filltype, c->fill);
                break;
!     case 'e': printellipse(0.0, 0.0, ms0, ms1, c->filltype, c->fill);
                break;
      case 't': start_poly(ms0, -ms1);
                cont_poly(0.0, ms1);
                cont_poly(-ms0, -ms1);
!               end_poly(c->filltype, c->fill);
                break;
      case 'X': start_poly(ms0, 0.0);
                cont_poly(-ms0, 0.0);
                cont_poly(-ms0, g->x_axis->draw_at - y);
                cont_poly(ms0, g->x_axis->draw_at - y);
!               end_poly(c->filltype, c->fill);
                break;
      case 'Y': start_poly(0.0, ms1);
                cont_poly(0.0, -ms1);
                cont_poly(g->y_axis->draw_at - x, -ms1);
                cont_poly(g->y_axis->draw_at - x, ms1);
!               end_poly(c->filltype, c->fill);
                break;
      case 'l': draw_label(c->lmark);
                break;
--- 459,486 ----
      case 'x': printline(-ms0, -ms1, ms0, ms1, 'x');
                printline(-ms0, ms1, ms0, -ms1, 'x');
                break;
!     case 'o': printellipse(x, y, ms0, ms0, 
!                            c->filltype, c->fill, c->pattern, c->parg);
                break;
!     case 'e': printellipse(x, y, ms0, ms1,
!                            c->filltype, c->fill, c->pattern, c->parg);
                break;
      case 't': start_poly(ms0, -ms1);
                cont_poly(0.0, ms1);
                cont_poly(-ms0, -ms1);
!               end_poly(x, y, c->filltype, c->fill, c->pattern, c->parg);
                break;
      case 'X': start_poly(ms0, 0.0);
                cont_poly(-ms0, 0.0);
                cont_poly(-ms0, g->x_axis->draw_at - y);
                cont_poly(ms0, g->x_axis->draw_at - y);
!               end_poly(x, y, c->filltype, c->fill, c->pattern, c->parg);
                break;
      case 'Y': start_poly(0.0, ms1);
                cont_poly(0.0, -ms1);
                cont_poly(g->y_axis->draw_at - x, -ms1);
                cont_poly(g->y_axis->draw_at - x, ms1);
!               end_poly(x, y, c->filltype, c->fill, c->pattern, c->parg);
                break;
      case 'l': draw_label(c->lmark);
                break;
***************
*** 467,473 ****
    start_poly(0.0, 0.0);
    cont_poly(-(c->asize[0]), (c->asize[1]));
    cont_poly(-(c->asize[0]), -(c->asize[1]));
!   end_poly(c->afilltype, c->afill);
    grestore();
    printf("\n");
  }
--- 526,532 ----
    start_poly(0.0, 0.0);
    cont_poly(-(c->asize[0]), (c->asize[1]));
    cont_poly(-(c->asize[0]), -(c->asize[1]));
!   end_poly(0.0, 0.0, c->afilltype, c->afill, c->apattern, c->aparg);
    grestore();
    printf("\n");
  }
***************
*** 595,618 ****
    printf("%%!PS-Adobe-2.0 EPSF-1.2\n");
    printf("%%%%Pages: 0\n");
    if (landscape) {
!     printf("%%%%BoundingBox: %f %f %f %f\n", gs->bb[1], gs->bb[0], 
              gs->bb[3], gs->bb[2]);
    } else {
!     printf("%%%%BoundingBox: %f %f %f %f\n", gs->bb[0], gs->bb[1], 
              gs->bb[2], gs->bb[3]);
    }
  
    printf("%%%%EndComments\n");
-   printf("/$F2psDict 32 dict def $F2psDict begin\t$F2psDict /mtrx matrix put\n");
-   printf("/DrawEllipse {\t/endangle exch def\t/startangle exch def");
-   printf("\t/yrad exch def\t/xrad exch def\t/y exch def\t/x exch def");
-   printf("\t/savematrix mtrx currentmatrix def");
-   printf("\tx y translate xrad yrad scale 0 0 1 startangle endangle arc");
-   printf("\tsavematrix setmatrix\t} def\n");
-   printf("\tend\t/$F2psBegin {$F2psDict begin /$F2psEnteredState save def} def");
-   printf("\t/$F2psEnd\n");
-   printf("{$F2psEnteredState restore end} def\t%%%%EndProlog\n");
-   printf("$F2psBegin\n");
    if (landscape) {
      printf("-90 rotate\n");
    }
--- 654,667 ----
    printf("%%!PS-Adobe-2.0 EPSF-1.2\n");
    printf("%%%%Pages: 0\n");
    if (landscape) {
!     printf("%%%%BoundingBox: %d %d %d %d\n", gs->bb[1], gs->bb[0], 
              gs->bb[3], gs->bb[2]);
    } else {
!     printf("%%%%BoundingBox: %d %d %d %d\n", gs->bb[0], gs->bb[1], 
              gs->bb[2], gs->bb[3]);
    }
  
    printf("%%%%EndComments\n");
    if (landscape) {
      printf("-90 rotate\n");
    }
***************
*** 620,631 ****
      if (landscape) {
        printf("%f 0 translate\n", -(11.0 * FCPI));
        printf("%f %f translate\n",
!         (((11.0 * FCPI) - gs->width) / 2.0) - gs->bb[0],     
!         (((8.5 * FCPI) - gs->height) / 2.0) - gs->bb[1]);     
      } else {
        printf("%f %f translate\n",
!         (((8.5 * FCPI) - gs->width) / 2.0) - gs->bb[0],     
!         (((11.0 * FCPI) - gs->height) / 2.0) - gs->bb[1]);     
      }
    } else if (landscape) {
      printf("%f 0 translate\n", -gs->bb[2] - gs->bb[0]);
--- 669,680 ----
      if (landscape) {
        printf("%f 0 translate\n", -(11.0 * FCPI));
        printf("%f %f translate\n",
!         (((11.0 * FCPI) - (gs->bb[2] - gs->bb[0])) / 2.0) - gs->bb[0],     
!         (((8.5 * FCPI) - (gs->bb[3] - gs->bb[1])) / 2.0) - gs->bb[1]);     
      } else {
        printf("%f %f translate\n",
!         (((8.5 * FCPI) - (gs->bb[2] - gs->bb[0])) / 2.0) - gs->bb[0],     
!         (((11.0 * FCPI) - (gs->bb[3] - gs->bb[1])) / 2.0) - gs->bb[1]);     
      }
    } else if (landscape) {
      printf("%f 0 translate\n", -gs->bb[2] - gs->bb[0]);
***************
*** 633,638 ****
--- 682,724 ----
    printf("1 setlinecap 1 setlinejoin\n");
    printf("0.700 setlinewidth\n");
    printf("0.00 setgray\n");
+ 
+   printf("\n");
+   printf("/Jrnd { exch cvi exch cvi dup 3 1 roll idiv mul } def\n");
+ 
+   printf("/JDEdict 8 dict def\n");
+   printf("JDEdict /mtrx matrix put\n");
+   printf("/JDE {\n");
+   printf("  JDEdict begin\n");
+   printf("  /yrad exch def\n");
+   printf("  /xrad exch def\n");
+   printf("  /savematrix mtrx currentmatrix def\n");
+   printf("  xrad yrad scale\n");
+   printf("  0 0 1 0 360 arc\n");
+   printf("  savematrix setmatrix\n");
+   printf("  end\n");
+   printf("} def\n");
+ 
+   printf("/JSTR {\n");
+   printf("  gsave 1 eq { gsave 1 setgray fill grestore } if\n");
+   printf("    exch neg exch neg translate \n");
+   printf("    clip                        \n");
+   printf("    rotate                      \n");
+   printf("    4 dict begin\n");
+   printf("      pathbbox  /&top exch def\n");
+   printf("                /&right exch def\n");
+   printf("                /&bottom exch def\n");
+   printf("                &right sub /&width exch def\n");
+   printf("      newpath\n");
+   printf("      currentlinewidth mul round dup               \n");
+   printf("      &bottom exch Jrnd exch &top             \n");
+   printf("      4 -1 roll currentlinewidth mul setlinewidth  \n");
+   printf("      { &right exch moveto &width 0 rlineto stroke } for    \n");
+   printf("    end\n");
+   printf("  grestore\n");
+   printf("  newpath\n");
+   printf("} bind def\n");
+ 
    gsave();
    setfont("Times-Roman", 9.00);
    if (gs->preamble != CNULL) {
***************
*** 674,680 ****
        printf("%s\n", gs->epilogue);
      }
    }
-   printf("$F2psEnd\n");
    grestore();
    if (pp) printf("showpage\n"); else printf("\n");
  }
--- 760,765 ----
*** ../work/edit.c	Mon Sep 21 10:52:17 1992
--- edit.c	Mon Sep 21 10:42:48 1992
***************
*** 1,7 ****
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/edit.c,v $
!  * $Revision: 8.1 $
!  * $Date: 92/07/20 16:44:34 $
   * $Author: jsp $
   */
  
--- 1,7 ----
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/edit.c,v $
!  * $Revision: 8.2 $
!  * $Date: 92/09/21 10:40:53 $
   * $Author: jsp $
   */
  
***************
*** 89,94 ****
--- 89,100 ----
      newf->f = f->f;
      insert(newf, c1->gen_linetype);
    }
+   c1->pattern = c2->pattern;
+   c1->apattern = c2->apattern;
+   c1->ppattern = c2->ppattern;
+   c1->parg = c2->parg;
+   c1->aparg = c2->aparg;
+   c1->pparg = c2->pparg;
    c1->marktype = c2->marktype;
    c1->linetype = c2->linetype;
    c1->linethick = c2->linethick;
***************
*** 122,127 ****
--- 128,134 ----
    c1->afill[2] = c2->afill[2];
    c1->postscript = c2->postscript;
    c1->postfile = c2->postfile;
+   c1->eps = c2->eps;
    c1->rarrow = c2->rarrow;
    c1->larrow = c2->larrow;
    c1->rarrows = c2->rarrows;
***************
*** 348,353 ****
--- 355,389 ----
    g->title->label = s;
  }
  
+ getpattern(inp_str, key, p, a)
+ char *inp_str, *key, *p;
+ float *a;
+ {
+   int i;
+   float f;
+ 
+   if (!getstring(inp_str)) return;
+   for (i = 0; i < NPATTERNS; i++) {
+     if (strcmp(inp_str, PATTERNS[i]) == 0) {
+       *p = PTYPES[i];
+       if (getfloat(&f)) {
+         *a = f;
+       } else {
+         rejecttoken();
+       }
+       i = NPATTERNS + 1;
+     } 
+   }
+   if (i == NPATTERNS) {
+     error_header(); fprintf(stderr, "Bad %s: %s\n", key, inp_str);
+     error_header(); fprintf(stderr, "             Valid %ss are:", key);
+     for (i = 0; i < NPATTERNS; i++) fprintf(stderr, " %s", PATTERNS[i]);
+     fprintf(stderr, "\n");
+     exit(1);
+   }
+   return;
+ }
+ 
  edit_curve(c, g)
  Curve c;
  Graph g;
***************
*** 357,362 ****
--- 393,399 ----
    float xh, yh, xl, yl;
    Point p, p1, p2;
    Flist fl;
+   FILE *fi;
    int i;
    char e;
  
***************
*** 517,522 ****
--- 554,566 ----
          insert(fl, c->gen_linetype);
        } 
        rejecttoken();
+     } else if (strcmp(inp_str, "pattern") == 0) {
+       getpattern(inp_str, "pattern", &(c->pattern), &(c->parg));
+     } else if (strcmp(inp_str, "apattern") == 0) {
+       getpattern(inp_str, "apattern", &(c->apattern), &(c->aparg));
+     } else if (strcmp(inp_str, "ppattern") == 0) {
+       getpattern(inp_str, "ppattern", &(c->ppattern), &(c->pparg));
+ 
      } else if (strcmp(inp_str, "linetype") == 0) {
        if (!getstring(inp_str)) return;
        if (strcmp(inp_str, "none") == 0) c->linetype = '0';
***************
*** 556,564 ****
        if (!getfloat(&f)) rejecttoken(); else {
          c->mrotate = f;
        }
      } else if (strcmp(inp_str, "postscript") == 0) {
-       c->marktype = 'p';
        if (!getstring(inp_str)) return;
        if (strcmp(inp_str, ":") == 0) {
          c->postfile = 0;
          if ((txt = getmultiline()) == CNULL) return;
--- 600,625 ----
        if (!getfloat(&f)) rejecttoken(); else {
          c->mrotate = f;
        }
+     } else if (strcmp(inp_str, "eps") == 0) {
+       if (!getstring(inp_str)) {
+         error_header();
+         fprintf(stderr, "eps token must be followed by an %s\n",
+                 "encapsulated postscript file\n");
+         exit(1);
+       }
+       c->marktype = 'E';
+       c->eps = (char *) malloc ((strlen(inp_str)+1)*sizeof(char));
+       strcpy(c->eps, inp_str);
+       fi = fopen(c->eps, "r");
+       if (fi == NULL) {
+         error_header();
+         fprintf(stderr, "couldn't open eps file '%s'\n", c->eps);
+         exit(1);
+       }
+       fclose(fi);
      } else if (strcmp(inp_str, "postscript") == 0) {
        if (!getstring(inp_str)) return;
+       c->marktype = 'p';
        if (strcmp(inp_str, ":") == 0) {
          c->postfile = 0;
          if ((txt = getmultiline()) == CNULL) return;
***************
*** 567,572 ****
--- 628,641 ----
          c->postfile = 1;
          c->postscript = (char *) malloc ((strlen(inp_str)+1)*sizeof(char));
          strcpy(c->postscript, inp_str);
+         fi = fopen(c->postscript, "r");
+         if (fi == NULL) {
+           error_header();
+           fprintf(stderr, "couldn't open postscript file '%s'\n", 
+                   c->postscript);
+           exit(1);
+         }
+         fclose(fi);
        }
      } else if (strcmp(inp_str, "poly") == 0) {
        c->poly = 1;
***************
*** 968,974 ****
    Graph g, tmp_g;
    char inp_str[80];
    float f;
!   int num, i, ok;
  
    the_g = first(gs);
    while ( getstring(inp_str) ) {
--- 1037,1043 ----
    Graph g, tmp_g;
    char inp_str[80];
    float f;
!   int num, i, ok, j;
  
    the_g = first(gs);
    while ( getstring(inp_str) ) {
***************
*** 1013,1024 ****
        the_g = last(gs);
      } else if (strcmp(inp_str, "bbox") == 0) {
        for (i = 0; i < 4; i++) {
!         if (!getfloat(&f)) {
            error_header();
!           fprintf(stderr, "Bbox definition must have four numbers\n");
            exit(1);
          } else {
!           the_g->bb[i] = f;
          }
        }
      } else if (strcmp(inp_str, "preamble") == 0) {
--- 1082,1093 ----
        the_g = last(gs);
      } else if (strcmp(inp_str, "bbox") == 0) {
        for (i = 0; i < 4; i++) {
!         if (!getint(&j)) {
            error_header();
!           fprintf(stderr, "Bbox definition must have four integers\n");
            exit(1);
          } else {
!           the_g->bb[i] = j;
          }
        }
      } else if (strcmp(inp_str, "preamble") == 0) {
*** ../work/jgraph.1	Mon Sep 21 10:52:21 1992
--- jgraph.1	Mon Sep 21 10:42:54 1992
***************
*** 9,23 ****
  [\-\fIP\fR\|]
  [\-\fIL\fR\|]
  [\-\fIcomments\fR\|]
  .SH DESCRIPTION
  \fBJgraph\fR
! takes the description of a graph or graphs in the standard
! input, and produces a postscript file on the standard output.  
  \fBJgraph\fR
  is ideal for plotting any mixture of scatter point graphs, line
  graphs, and/or bar graphs, and embedding the output into LaTeX, or
  any other text processing system which can read postscript.
  .sp
  The graph description language is simple enough to get nice looking
  graphs with a minimum of effort, yet powerful enough to give the user
  the flexibility to tailor the appearance of the graph to his or her
--- 9,27 ----
  [\-\fIP\fR\|]
  [\-\fIL\fR\|]
  [\-\fIcomments\fR\|]
+ [\fIfilename\fR ...\|]
  .SH DESCRIPTION
  \fBJgraph\fR
! takes the description of a graph or graphs
! and produces a postscript file on the standard output.  
  \fBJgraph\fR
  is ideal for plotting any mixture of scatter point graphs, line
  graphs, and/or bar graphs, and embedding the output into LaTeX, or
  any other text processing system which can read postscript.
  .sp
+ \fBJgraph\fR reads its input from the specified files.  If no
+ files are specified, then it reads from standard input.
+ .sp
  The graph description language is simple enough to get nice looking
  graphs with a minimum of effort, yet powerful enough to give the user
  the flexibility to tailor the appearance of the graph to his or her
***************
*** 712,718 ****
  This sets the kind of mark that is plotted for this curve.  Valid
  marks are: \fIcircle\fR, \fIbox\fR, \fIdiamond\fR, \fItriangle\fR,
  \fIx\fR, \fIcross\fR, \fIellipse\fR, \fIxbar\fR, \fIybar\fR,
! \fItext\fR, \fIpostscript\fR, \fInone\fR, and variants of
  \fIgeneral\fR.  Most of these are self-explanatory, except for the
  last few: 
    \fIXbar\fR makes the curve into a bar graph with the bars going
--- 716,722 ----
  This sets the kind of mark that is plotted for this curve.  Valid
  marks are: \fIcircle\fR, \fIbox\fR, \fIdiamond\fR, \fItriangle\fR,
  \fIx\fR, \fIcross\fR, \fIellipse\fR, \fIxbar\fR, \fIybar\fR,
! \fItext\fR, \fIpostscript\fR, \fIeps\fR, \fInone\fR, and variants of
  \fIgeneral\fR.  Most of these are self-explanatory, except for the
  last few: 
    \fIXbar\fR makes the curve into a bar graph with the bars going
***************
*** 727,732 ****
--- 731,737 ----
  curve points (units are units of the x and y axes).
  Default label values are 0 for x and y, and center justification.
    \fIPostscript:\fR See the \fIpostscript\fB token below.
+   \fIEps:\fR See the \fIeps\fB token below.
    \fINone\fR means that no mark will be
  plotted (this is useful for drawing lines).  
    There are four types of \fIgeneral\fR marks, which work using the 
***************
*** 787,792 ****
--- 792,811 ----
  \fIfill 0\fB
  (black).
  .TP
+ \fBpattern \fItoken\fB \|[\fIfloat\fB\|]\fR   
+ This defines the how the mark is to be filled.  \fIToken\fR
+ may be \fIsolid\fR (the default), \fIstripe\fR, or \fIestripe\fR.  If 
+ \fIsolid\fR, then the \fIfloat\fR is ignored, and the mark is
+ completely filled in with either the gray value defined by
+ \fIfill\fR or the color value defined by \fIcfill\fR.
+ If \fIstripe\fR, then the mark will be filled with stripes of
+ either the gray value defined by \fIfill\fR or the color defined
+ by \fIcfill\fR.  The stripes will be rotated by \fIfloat\fR 
+ degrees.  \fIEstripe\fR differs from \fIstripe\fR only in that 
+ \fIstripe\fR draws 
+ stripes on a white background, while \fIestripe\fR simply draws the 
+ stripes on an empty background.
+ .TP
  \fBpoly\fR
  .br
  .ns
***************
*** 800,810 ****
  .ns
  .TP
  \fBpcfill \|[\fIfloat\fB\| \|\fIfloat\fB\| \|\fIfloat\fB\|]\fR   
  \fIPoly\fB allows the user to make jgraph treat the curve as a 
  closed polygon (or in the case of a bezier, a closed bezier curve).
! \fIpfill\fB and \fIpcfill\fB specify the filling of the polygon,
! and work like \fIfill\fB and \fIcfill\fB above.  The default is
! \fInopoly\fB.
  .TP
  \fBgmarks \|[\|{\fIfloat\fB\|} \|{\fIfloat\fB\|}\|]*\fR   
  \fIGmarks\fB
--- 819,834 ----
  .ns
  .TP
  \fBpcfill \|[\fIfloat\fB\| \|\fIfloat\fB\| \|\fIfloat\fB\|]\fR   
+ .br
+ .ns
+ .TP
+ \fBppattern \fItoken\fB \|[\fIfloat\fB\|]\fR   
  \fIPoly\fB allows the user to make jgraph treat the curve as a 
  closed polygon (or in the case of a bezier, a closed bezier curve).
! \fIpfill\fB, \fIpcfill\fB and \fIppattern\fB  specify the 
! filling of the polygon,
! and work like \fIfill\fB, \fIcfill\fB and \fIpattern\fB above.  
! The default is \fInopoly\fB.
  .TP
  \fBgmarks \|[\|{\fIfloat\fB\|} \|{\fIfloat\fB\|}\|]*\fR   
  \fIGmarks\fB
***************
*** 850,855 ****
--- 874,887 ----
  .fi
  .PP
  .TP
+ \fBeps {\fItoken\fB\|}\fR   
+ This allows the user to include an encapsulated postscript file
+ and treat it as a mark.  It automatically sets the marktype to
+ \fIeps\fB.  The file will be scaled so that the bounding
+ box is \fImarksize\fR units.  Among other things, this allows the
+ user to include whole jgraph files as marks.  Please see ad.jgr,
+ explained in HINTS AND EXAMPLE GRAPHS below for an example of this feature.
+ .TP
  \fBlarrows\fR
  .br
  .ns
***************
*** 909,923 ****
  .br
  .ns
  .TP
! \fBacfill \|[\fIfloat\fB\| \|\fIfloat\fB\| \|\fIfloat\fB\|]\fR
  These control the grayness or color of arrowheads.  
! \fIAfill\fB
! and
  \fIacfill\fB
  work in the same way as 
! \fIfill\fB
! and
  \fIcfill\fB
  described above.  The default is
  \fIafill 0\fB
  (black).
--- 941,961 ----
  .br
  .ns
  .TP
! \fBafill \|[\fIfloat\fB\|]\fR
! .br
! .ns
! .TP
! \fBapattern \fItoken\fB \|[\fIfloat\fB\|]\fR   
  These control the grayness or color of arrowheads.  
! \fIAfill\fB,
  \fIacfill\fB
+ and 
+ \fIapattern\fB
  work in the same way as 
! \fIfill\fB,
  \fIcfill\fB
+ and
+ \fIpattern\fB
  described above.  The default is
  \fIafill 0\fB
  (black).
***************
*** 1510,1516 ****
  contains a description of how the legend was created.
  .sp
  - ex1.jgr and ex2.jgr are two examples which were figures 1 and
!   two in an extended abstract for a paper about jgraph.
  .sp
  - mab2.jgr is a graph created by Matt Blaze which shows how a 
  complicated output graph can be quite concisely and simply stated.
--- 1548,1554 ----
  contains a description of how the legend was created.
  .sp
  - ex1.jgr and ex2.jgr are two examples which were figures 1 and
! two in an extended abstract for a paper about jgraph.
  .sp
  - mab2.jgr is a graph created by Matt Blaze which shows how a 
  complicated output graph can be quite concisely and simply stated.
***************
*** 1521,1529 ****
--- 1559,1575 ----
  commands, as well as displaying how jgraph lets you extract data from
  output files with awk.
  .sp
+ - nr.jgr is an example of a rather complicated bar graph with 
+ stripe-filled bars.  It was created by Norman Ramsey.
+ .sp
  - hypercube.jgr shows an interesting use of jgraph
  for picture-drawing.
  .sp
+ - ad.jgr is an example which shows how one can include jgraph 
+ output as jgraph input.  The file uses the \fIeps\fR token to 
+ include cube.jgr, a jgraph drawing of an Intel hypercube, and disk.jgr,
+ a jgraph drawing of a disk, in a picture.
+ .sp
  - alb.jgr is another use of jgraph for picture drawing.  This file
  was created by an awk script which Adam Buchsbaum wrote to draw 
  trees and graphs.
***************
*** 1597,1600 ****
  There may well be loads of other bugs.  Send to jsp@princeton.edu.
  .sp
  
! This is $Revision: 8.1 $.
--- 1643,1646 ----
  There may well be loads of other bugs.  Send to jsp@princeton.edu.
  .sp
  
! This is $Revision: 8.2 $.
*** ../work/jgraph.c	Mon Sep 21 10:52:22 1992
--- jgraph.c	Mon Sep 21 10:42:49 1992
***************
*** 1,7 ****
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/jgraph.c,v $
!  * $Revision: 8.1 $
!  * $Date: 92/07/20 16:44:39 $
   * $Author: jsp $
   */
  
--- 1,7 ----
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/jgraph.c,v $
!  * $Revision: 8.2 $
!  * $Date: 92/09/21 10:40:58 $
   * $Author: jsp $
   */
  
***************
*** 9,31 ****
  
  #ifdef VMS 
  #include <redexp.VMS>
- extern FILE *IOSTREAM;	/* for token.c, q.v. -hdd */
  #endif
  
  #include "jgraph.h"
  
! int NMARKTYPES = 16;
  int NORMALMARKTYPES = 6;
  
  char *MARKTYPESTRS[] = { "circle", "box", "diamond", "triangle", "x", "cross", 
                           "ellipse", "general", "general_nf", "general_bez",
!                          "general_bez_nf", "postscript", 
                           "xbar", "ybar", "none", "text"};
  char MARKTYPES[] = {     'o',      'b',   'd',       't',        'x', 'c', 
  			 'e',       'g',       'G',          'Z',
!                          'B',              'p',          
                           'X',    'Y',    'n',    'l' };
  
  Label new_label()
  {
    Label l;
--- 9,34 ----
  
  #ifdef VMS 
  #include <redexp.VMS>
  #endif
  
  #include "jgraph.h"
  
! int NMARKTYPES = 17;
  int NORMALMARKTYPES = 6;
  
  char *MARKTYPESTRS[] = { "circle", "box", "diamond", "triangle", "x", "cross", 
                           "ellipse", "general", "general_nf", "general_bez",
!                          "general_bez_nf", "postscript", "eps", 
                           "xbar", "ybar", "none", "text"};
  char MARKTYPES[] = {     'o',      'b',   'd',       't',        'x', 'c', 
  			 'e',       'g',       'G',          'Z',
!                          'B',              'p',          'E',
                           'X',    'Y',    'n',    'l' };
  
+ int NPATTERNS = 3;
+ char *PATTERNS[] = { "solid", "stripe", "estripe" };
+ char PTYPES[] = { 's', '/', 'e' };
+ 
  Label new_label()
  {
    Label l;
***************
*** 61,66 ****
--- 64,75 ----
    new_c->lmark->hj = 'c';
    new_c->lmark->vj = 'c';
    new_c->clip = 0;
+   new_c->pattern = 's';
+   new_c->parg = FSIG;
+   new_c->apattern = 's';
+   new_c->aparg = FSIG;
+   new_c->ppattern = 's';
+   new_c->pparg = FSIG;
    new_c->graytype = 'n';
    for (i = 0; i < 3; i++) new_c->gray[i] = 0.0;
    new_c->afilltype = 'g';
***************
*** 91,96 ****
--- 100,106 ----
    new_c->bezier = 0;
    new_c->postscript = CNULL;
    new_c->postfile = 0;
+   new_c->eps = CNULL;
    prio_insert(new_c, c, 0);
    return new_c;
  }
***************
*** 294,301 ****
    newg->g = (Graph) make_list(sizeof(struct graph));
    newg->height = 0.0;
    newg->width = 0.0;
!   newg->bb[0] = FSIG; newg->bb[1] = FSIG;
!   newg->bb[2] = FSIG; newg->bb[3] = FSIG;
    newg->preamble = CNULL;
    newg->epilogue = CNULL;
    newg->prefile = 0;
--- 304,311 ----
    newg->g = (Graph) make_list(sizeof(struct graph));
    newg->height = 0.0;
    newg->width = 0.0;
!   newg->bb[0] = ISIG; newg->bb[1] = ISIG;
!   newg->bb[2] = ISIG; newg->bb[3] = ISIG;
    newg->preamble = CNULL;
    newg->epilogue = CNULL;
    newg->prefile = 0;
***************
*** 312,317 ****
--- 322,328 ----
    int show, pp;
    int landscape;
    int comments;
+   int nfiles;
  
  #ifdef VMS 
    IOSTREAM = stdin;	/* for token.c -hdd */
***************
*** 320,325 ****
--- 331,337 ----
    pp = 0;
    comments = 0;
    landscape = 0;
+   nfiles = 0;
  
    for (i = 1; i < argc; i++) {
      if (strcmp(argv[i], "-p") == 0) show = 1;
***************
*** 326,332 ****
--- 338,349 ----
      else if (strcmp(argv[i], "-comments") == 0) comments = 1;
      else if (strcmp(argv[i], "-P") == 0) pp = 1;
      else if (strcmp(argv[i], "-L") == 0) landscape = 1;
+     else {
+       nfiles++;
+       set_input_file(argv[i]);
+     }
    }
+   if (nfiles == 0) set_input_file(CNULL);
    gs = (Graphs) make_list(sizeof(struct graphs));
    set_comment(comments);
    new_graphs(gs);
*** ../work/jgraph.h	Mon Sep 21 10:52:23 1992
--- jgraph.h	Mon Sep 21 10:42:50 1992
***************
*** 1,7 ****
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/jgraph.h,v $
!  * $Revision: 8.1 $
!  * $Date: 92/07/20 16:44:42 $
   * $Author: jsp $
   */
  
--- 1,7 ----
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/jgraph.h,v $
!  * $Revision: 8.2 $
!  * $Date: 92/09/21 10:40:59 $
   * $Author: jsp $
   */
  
***************
*** 18,23 ****
--- 18,24 ----
  #define CNULL ((char *)0)
  #define GMNULL ((Point)0)
  #define FSIG -10010.0
+ #define ISIG -11111111
  #define HASH_SIZE 5.0
  #define MHASH_SIZE 2.0
  
***************
*** 77,85 ****
--- 78,93 ----
    char filltype ;
    char afilltype;
    char pfilltype;
+   char pattern;
+   float parg;
+   char apattern;
+   float aparg;
+   char ppattern;
+   float pparg;
    char marktype;
    char linetype;
    char *postscript;
+   char *eps;
    int postfile;
    int rarrow;
    int larrow;
***************
*** 197,203 ****
    Graph g;
    float height;
    float width;
!   float bb[4]; /* Bounding box */
    char *preamble; 
    char *epilogue; 
    int prefile;
--- 205,211 ----
    Graph g;
    float height;
    float width;
!   int bb[4]; /* Bounding box */
    char *preamble; 
    char *epilogue; 
    int prefile;
***************
*** 227,229 ****
--- 235,240 ----
  extern char MARKTYPES[];
  extern int NMARKTYPES;
  extern int NORMALMARKTYPES;
+ extern char *PATTERNS[];
+ extern char PTYPES[];
+ extern int NPATTERNS;
*** ../work/list.c	Mon Sep 21 10:52:24 1992
--- list.c	Mon Sep 21 10:42:50 1992
***************
*** 1,7 ****
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/list.c,v $
!  * $Revision: 8.1 $
!  * $Date: 92/07/20 16:44:43 $
   * $Author: jsp $
   */
  
--- 1,7 ----
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/list.c,v $
!  * $Revision: 8.2 $
!  * $Date: 92/09/21 10:41:00 $
   * $Author: jsp $
   */
  
*** ../work/list.h	Mon Sep 21 10:52:24 1992
--- list.h	Mon Sep 21 10:42:51 1992
***************
*** 1,7 ****
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/list.h,v $
!  * $Revision: 8.1 $
!  * $Date: 92/07/20 16:44:44 $
   * $Author: jsp $
   */
  
--- 1,7 ----
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/list.h,v $
!  * $Revision: 8.2 $
!  * $Date: 92/09/21 10:41:01 $
   * $Author: jsp $
   */
  
*** ../work/makefile	Mon Sep 21 10:52:25 1992
--- makefile	Mon Sep 21 10:42:54 1992
***************
*** 20,26 ****
--- 20,28 ----
  
  EXAMPLES = \
  	acc.jps		\
+ 	acc.eps		\
  	alb.jps		\
+ 	ad.jps		\
  	bailey.jps	\
  	ebars.jps	\
  	ex1.jps		\
***************
*** 31,36 ****
--- 33,39 ----
  	gpaper.jps	\
  	hypercube.jps	\
  	mab2.jps	\
+ 	nr.jps	\
  	sin.jps		\
  	sin1.jps	\
  	sin2.jps	\
***************
*** 44,54 ****
  
  examples: $(EXAMPLES)
  
! .SUFFIXES: .c .o .h .jgr .jps .tex .dvi
  
  .jgr.jps:
  	jgraph -P < $*.jgr > $*.jps
  
  .tex.dvi:
  	latex $*.tex
  .c.o: 
--- 47,60 ----
  
  examples: $(EXAMPLES)
  
! .SUFFIXES: .c .o .h .jgr .jps .eps .tex .dvi
  
  .jgr.jps:
  	jgraph -P < $*.jgr > $*.jps
  
+ .jgr.eps:
+ 	jgraph < $*.jgr > $*.eps
+ 
  .tex.dvi:
  	latex $*.tex
  .c.o: 
***************
*** 61,66 ****
--- 67,73 ----
  sin:	sin.o
  	cc -o sin sin.o -lm
  
+ ad.jps: cube.eps disk.eps
  bailey.jps: bailey.pts
  ex2.jps: data.txt
  mab2.jps: mab2.times
*** /dev/null	Mon Sep 21 10:25:34 1992
--- nr.jgr	Mon Sep 21 10:42:58 1992
***************
*** 0 ****
--- 1,93 ----
+ (* Bar graph from Norman Ramsey's PhD dissertation *)
+ 
+ newgraph
+   xaxis size 6.0 min 0 hash 100 label : Number of lines
+   yaxis min -4.625 max -0.375 size 2.5
+   yaxis no_auto_hash_labels no_draw_hash_marks no_draw_axis_label
+ 
+ 	(* MIPS *)
+   yaxis hash_label at -1 : MIPS
+     newcurve pts 545 -1 marktype ybar fill 0.3
+       marksize 75 0.75 pattern stripe -45
+     newcurve pts 458 -1 marktype ybar fill 0.75
+       marksize 75 0.75 pattern stripe -45
+     newcurve pts 411 -1 marktype ybar fill 0.1
+       marksize 75 0.75 pattern stripe -45
+     newcurve pts 338 -1 marktype ybar fill 1.0
+       marksize 75 0.75 pattern solid
+     newcurve pts 303 -1 marktype ybar fill 0.2
+       marksize 75 0.75 pattern solid
+     newcurve pts 246 -1 marktype ybar fill 0.85
+       marksize 75 0.75 pattern stripe 45
+     newcurve pts 171 -1 marktype ybar fill 0.5
+       marksize 75 0.75 pattern stripe 45
+     newcurve pts 66 -1 marktype ybar fill 0
+       marksize 75 0.75 pattern stripe 45
+ 
+ 	(* SPARC *)
+   yaxis hash_label at -2 : SPARC
+     newcurve pts 535 -2 marktype ybar fill 0.3
+       marksize 75 0.75 pattern stripe -45
+     newcurve pts 386 -2 marktype ybar fill 0.75
+       marksize 75 0.75 pattern stripe -45
+     newcurve pts 330 -2 marktype ybar fill 0.1
+       marksize 75 0.75 pattern stripe -45
+     newcurve pts 208 -2 marktype ybar fill 1.0
+       marksize 75 0.75 pattern solid
+     newcurve pts 190 -2 marktype ybar fill 0.2
+       marksize 75 0.75 pattern solid
+     newcurve pts 174 -2 marktype ybar fill 0.5
+       marksize 75 0.75 pattern stripe 45
+     newcurve pts 74 -2 marktype ybar fill 0
+       marksize 75 0.75 pattern stripe 45
+ 
+ 	(* VAX *)
+   yaxis hash_label at -3 : VAX
+     newcurve pts 213 -3 marktype ybar fill 1.0
+       marksize 75 0.75 pattern solid
+     newcurve pts 200 -3 marktype ybar fill 0.2
+       marksize 75 0.75 pattern solid
+     newcurve pts 135 -3 marktype ybar fill 0.5
+       marksize 75 0.75 pattern stripe 45
+     newcurve pts 52 -3 marktype ybar fill 0
+       marksize 75 0.75 pattern stripe 45
+ 
+ 	(* 68020 *)
+   yaxis hash_label at -4 : 68020
+     newcurve pts 185 -4 marktype ybar fill 1.0
+       marksize 75 0.75 pattern solid
+     newcurve pts 169 -4 marktype ybar fill 0.2
+       marksize 75 0.75 pattern solid
+     newcurve pts 98 -4 marktype ybar fill 0.5
+       marksize 75 0.75 pattern stripe 45
+     newcurve pts 53 -4 marktype ybar fill 0
+       marksize 75 0.75 pattern stripe 45
+   xaxis max 600
+ 
+   (* first column of legend *)
+   newcurve marktype ybar fill 0 marksize 50 0.75 pattern stripe 45
+     label : configuration
+   newcurve marktype ybar fill 0.5 marksize 50 0.75 pattern stripe 45
+     label : stack walking
+   newcurve marktype ybar fill 0.85 marksize 50 0.75 pattern stripe 45
+     label : runtime procedure table
+   newcurve marktype ybar fill 0.2 marksize 50 0.75 pattern solid
+     label : nub code
+   legend bottom defaults hjl linelength 75 x 50 y -6.0
+ 
+ copygraph xaxis nodraw yaxis nodraw (* for second legend *)
+   (* second column of legend *)
+   legend bottom defaults hjl x 250.0 y -6.0
+   newcurve marktype ybar fill 1.0 marksize 50 0.75 pattern solid
+     label : PostScript
+   newcurve marktype ybar fill 0.1 marksize 50 0.75 pattern stripe -45
+     label : instruction-set specification
+   newcurve marktype ybar fill 0.75 marksize 50 0.75 pattern stripe -45
+     label : follow sets
+   newcurve marktype ybar fill 0.3 marksize 50 0.75 pattern stripe -45
+     label : disassembler
+ 
+ (* top X axis *)
+ copygraph xaxis draw hash -1 hash_scale +1.0 min 0 max 4.457652303
+  label : percentage of total size
+ 
*** ../work/printline.c	Mon Sep 21 10:52:26 1992
--- printline.c	Mon Sep 21 10:42:51 1992
***************
*** 1,7 ****
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/printline.c,v $
!  * $Revision: 8.1 $
!  * $Date: 92/07/20 16:44:47 $
   * $Author: jsp $
   */
  
--- 1,7 ----
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/printline.c,v $
!  * $Revision: 8.2 $
!  * $Date: 92/09/21 10:41:03 $
   * $Author: jsp $
   */
  
***************
*** 75,91 ****
    }
  }
    
! setfill( t, f)
! char t ;
! float f[] ;
  {
!     if ( t == 'g' )  {
!        if( f[0] >= 0.0 ) printf("gsave %f setgray fill grestore ", f[0] );
!     } else if ( t == 'c' )  {
!        printf("gsave %f %f %f setrgbcolor fill grestore ", f[0], f[1], f[2] );
!     } else {
!        printf("fill ");
!     }
  }
  
  setgray( t, f)
--- 75,103 ----
    }
  }
    
! setfill( x, y, t, f, p, a)
! char t, p ;
! float x, y;
! float f[], a ;
  {
! /*   fprintf(stderr, "Hello?  %c %f %c %f\n", t, f[0], p, a); */
!   if (t == 'g' && f[0] < 0.0) return;
!   printf("gsave ");
! 
!   if ( t == 'g' )  {
!     if( f[0] >= 0.0 ) printf("%f setgray ", f[0] );
!   } else if ( t == 'c' )  {
!     printf("%f %f %f setrgbcolor ", f[0], f[1], f[2] );
!   }
! 
!   if (p == 's') {
!     printf(" fill");
!   } else if (p == '/') {
!     printf(" 6.1 10 %f %f %f 1 JSTR", a, x, y);
!   } else if (p == 'e') {
!     printf(" 6.1 10 %f %f %f 0 JSTR", a, x, y);
!   }
!   printf(" grestore\n");
  }
  
  setgray( t, f)
***************
*** 104,114 ****
  char orientation;
  {
    if (orientation == 'x') 
!     printf("newpath %f %f moveto %f %f lineto stroke\n",
!           x1, y1, x2, y2);
    else
!     printf("newpath %f %f moveto %f %f lineto stroke\n",
!           y1, x1, y2, x2);
  } 
  
  print_ebar(x1, y1, x2, ms, orientation)
--- 116,125 ----
  char orientation;
  {
    if (orientation == 'x') 
!     printf("newpath %f %f moveto %f %f lineto stroke\n", x1, y1, x2, y2);
    else
!     printf("newpath %f %f moveto %f %f lineto stroke\n", y1, x1, y2, x2);
!   fflush(stdout);
  } 
  
  print_ebar(x1, y1, x2, ms, orientation)
***************
*** 139,144 ****
--- 150,156 ----
    printf("stroke\n");
    setlinewidth(1.0);
    setlinestyle('s', (Flist) 0);
+   fflush(stdout);
  
  }
  
***************
*** 158,164 ****
  start_poly(x1, y1)
  float x1, y1;
  {
!   printf("newpath %f %f moveto ", x1, y1);
  }
  
  cont_poly(x1, y1)
--- 170,176 ----
  start_poly(x1, y1)
  float x1, y1;
  {
!   printf(" newpath %f %f moveto", x1, y1);
  }
  
  cont_poly(x1, y1)
***************
*** 167,188 ****
    printf("  %f %f lineto\n", x1, y1);
  }
  
! end_poly(ftype, fill)
! char  ftype ;
! float fill[];
  {
    printf("closepath ");
!   setfill( ftype, fill );
    printf("stroke\n");
  }
  
! printellipse(x, y, radius1, radius2, ftype, fill)
! char ftype ;
! float x, y, radius1, radius2, fill[];
  {
!   printf("newpath %f %f %f %f 0 360 DrawEllipse ", x, y, radius1, radius2);
!   setfill( ftype, fill );
    printf("stroke\n");
  }
  
  set_comment(c)
--- 179,205 ----
    printf("  %f %f lineto\n", x1, y1);
  }
  
! end_poly(x, y, ftype, fill, pattern, parg)
! float x, y;
! char  ftype, pattern ;
! float fill[], parg;
  {
    printf("closepath ");
!   setfill( x, y, ftype, fill, pattern, parg );
    printf("stroke\n");
+   fflush(stdout);
  }
  
! /* Ellipse at 0, 0 -- assumes that you've already translated to x, y */
! 
! printellipse(x, y, radius1, radius2, ftype, fill, pattern, parg)
! char ftype, pattern;
! float x, y, radius1, radius2, fill[], parg;
  {
!   printf("newpath %f %f JDE\n", radius1, radius2);
!   setfill( x, y, ftype, fill, pattern, parg );
    printf("stroke\n");
+   fflush(stdout);
  }
  
  set_comment(c)
***************
*** 276,282 ****
  setlinewidth(size)
  float size;
  {
!   printf("%f setlinewidth\n", size * LINEWIDTHFACTOR);
  }
  
  setlinestyle(style, glist)
--- 293,299 ----
  setlinewidth(size)
  float size;
  {
!   printf("%f setlinewidth ", size * LINEWIDTHFACTOR);
  }
  
  setlinestyle(style, glist)
***************
*** 286,301 ****
    Flist fl;
  
    switch(style) {
!     case '0': printf("\t[0 2] setdash\n"); break;
!     case 's': printf("\t[] 0 setdash\n"); break;
!     case '.': printf("\t [1 3.200000] 0 setdash\n"); break;
!     case '-': printf("\t [4.00000] 0 setdash\n"); break;
!     case 'l': printf("\t [7 2] 0 setdash\n"); break;
!     case 'd': printf("\t [5 3 1 3] 0 setdash\n"); break;
!     case 'D': printf("\t [5 3 1 2 1 3] 0 setdash\n"); break;
!     case '2': printf("\t [5 3 5 3 1 2 1 3] 0 setdash\n"); break;
      case 'g': 
!       printf("\t [");
        for (fl = first(glist); fl != nil(glist); fl = next(fl))
          printf("%f ", fl->f);
        printf("] 0 setdash\n");
--- 303,318 ----
    Flist fl;
  
    switch(style) {
!     case '0': printf(" [0 2] setdash\n"); break;
!     case 's': printf(" [] 0 setdash\n"); break;
!     case '.': printf(" [1 3.200000] 0 setdash\n"); break;
!     case '-': printf(" [4.00000] 0 setdash\n"); break;
!     case 'l': printf(" [7 2] 0 setdash\n"); break;
!     case 'd': printf(" [5 3 1 3] 0 setdash\n"); break;
!     case 'D': printf(" [5 3 1 2 1 3] 0 setdash\n"); break;
!     case '2': printf(" [5 3 5 3 1 2 1 3] 0 setdash\n"); break;
      case 'g': 
!       printf(" [");
        for (fl = first(glist); fl != nil(glist); fl = next(fl))
          printf("%f ", fl->f);
        printf("] 0 setdash\n");
*** ../work/prio_list.c	Mon Sep 21 10:52:26 1992
--- prio_list.c	Mon Sep 21 10:42:51 1992
***************
*** 1,7 ****
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/prio_list.c,v $
!  * $Revision: 8.1 $
!  * $Date: 92/07/20 16:44:48 $
   * $Author: jsp $
   */
  
--- 1,7 ----
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/prio_list.c,v $
!  * $Revision: 8.2 $
!  * $Date: 92/09/21 10:41:04 $
   * $Author: jsp $
   */
  
*** ../work/prio_list.h	Mon Sep 21 10:52:26 1992
--- prio_list.h	Mon Sep 21 10:42:51 1992
***************
*** 1,7 ****
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/prio_list.h,v $
!  * $Revision: 8.1 $
!  * $Date: 92/07/20 16:44:49 $
   * $Author: jsp $
   */
  
--- 1,7 ----
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/prio_list.h,v $
!  * $Revision: 8.2 $
!  * $Date: 92/09/21 10:41:04 $
   * $Author: jsp $
   */
  
*** ../work/process.c	Mon Sep 21 10:52:27 1992
--- process.c	Mon Sep 21 10:42:52 1992
***************
*** 1,7 ****
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/process.c,v $
!  * $Revision: 8.1 $
!  * $Date: 92/07/20 16:44:51 $
   * $Author: jsp $
   */
  
--- 1,7 ----
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/process.c,v $
!  * $Revision: 8.2 $
!  * $Date: 92/09/21 10:41:05 $
   * $Author: jsp $
   */
  
***************
*** 688,693 ****
--- 688,696 ----
    c->lmark->x = disttop(c->lmark->x, g->x_axis);
    c->lmark->y = disttop(c->lmark->y, g->y_axis);
    process_label(c->lmark, g, 0);
+   if (c->parg == FSIG) c->parg = 0.0;
+   if (c->aparg == FSIG) c->aparg = 0.0;
+   if (c->pparg == FSIG) c->pparg = 0.0;
  }
  
  process_curves(g)
***************
*** 797,802 ****
--- 800,806 ----
        max_x = MAX(max_x, g->x_translate + g->xmaxval);
        min_x = MIN(min_x, g->x_translate + g->xminval);
      }
+ 
      if (the_g->height >= 0.00) {
        the_g->height *= FCPI;
        if (the_g->height > max_y - min_y) {
***************
*** 823,834 ****
      }
  
      do_bb = 1;
!     for (i = 0; i < 4; i++) do_bb = (do_bb && the_g->bb[i] == FSIG);
      if (do_bb) {
!       the_g->bb[0] = min_x;
!       the_g->bb[1] = min_y;
!       the_g->bb[2] = max_x;
!       the_g->bb[3] = max_y;
      } 
    }
  }
--- 827,838 ----
      }
  
      do_bb = 1;
!     for (i = 0; i < 4; i++) do_bb = (do_bb && the_g->bb[i] == ISIG);
      if (do_bb) {
!       the_g->bb[0] = (int) (min_x - 1.0);
!       the_g->bb[1] = (int) (min_y - 1.0);
!       the_g->bb[2] = (int) (max_x + 1.0);
!       the_g->bb[3] = (int) (max_y + 1.0);
      } 
    }
  }
*** ../work/show.c	Mon Sep 21 10:52:29 1992
--- show.c	Mon Sep 21 10:42:53 1992
***************
*** 1,7 ****
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/show.c,v $
!  * $Revision: 8.1 $
!  * $Date: 92/07/20 16:44:53 $
   * $Author: jsp $
   */ 
  
--- 1,7 ----
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/show.c,v $
!  * $Revision: 8.2 $
!  * $Date: 92/09/21 10:41:07 $
   * $Author: jsp $
   */ 
  
***************
*** 149,154 ****
--- 149,158 ----
        exit(1);
      }
    }
+   if (c->eps != CNULL) {
+     spaces(nsp);
+     printf("eps %s\n", c->eps);
+   }
    if (c->postscript != CNULL) {
      spaces(nsp);
      printf("postscript ");
***************
*** 224,229 ****
--- 228,240 ----
      printf("color %f %f %f ", c->gray[0], c->gray[1], c->gray[2]);
    }
    if(!c->clip) printf("no"); printf("clip\n");
+   spaces(nsp);
+   for (i = 0; i < NPATTERNS && PTYPES[i] != c->pattern; i++) ;
+   printf("pattern %s %f ", PATTERNS[i], c->parg);
+   for (i = 0; i < NPATTERNS && PTYPES[i] != c->ppattern; i++) ;
+   printf("ppattern %s %f ", PATTERNS[i], c->pparg);
+   for (i = 0; i < NPATTERNS && PTYPES[i] != c->apattern; i++) ;
+   printf("apattern %s %f\n", PATTERNS[i], c->aparg);
    spaces(nsp); 
    if(!c->rarrow) printf("no"); printf("rarrow ");
    if(!c->larrow) printf("no"); printf("larrow ");
***************
*** 406,412 ****
        show_mltiline(the_g->epilogue);
      }
      printf("bbox"); 
!     for (i = 0; i < 4; i++) printf(" %f", the_g->bb[i]);
      printf("\n");
      for (g = first(the_g->g); g != nil(the_g->g); g = next(g)) {
        printf("graph %d\n", g->num);
--- 417,423 ----
        show_mltiline(the_g->epilogue);
      }
      printf("bbox"); 
!     for (i = 0; i < 4; i++) printf(" %d", the_g->bb[i]);
      printf("\n");
      for (g = first(the_g->g); g != nil(the_g->g); g = next(g)) {
        printf("graph %d\n", g->num);
*** ../work/token.c	Mon Sep 21 10:52:35 1992
--- token.c	Mon Sep 21 10:42:54 1992
***************
*** 1,16 ****
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/token.c,v $
!  * $Revision: 8.1 $
!  * $Date: 92/07/20 16:44:55 $
   * $Author: jsp $
   */
  
  #include <math.h>
! /* On VMS, math.h does not have a definition for atof. Grrr. */
  #ifdef VMS 
  #include <stdlib.h>
  #endif
- #include <stdio.h>
  
  #include "list.h"
  
--- 1,21 ----
  /* 
   * $Source: /n/fs/grad1/jsp/src/jgraph/RCS/token.c,v $
!  * $Revision: 8.2 $
!  * $Date: 92/09/21 10:41:08 $
   * $Author: jsp $
   */
  
  #include <math.h>
! #include <stdio.h>
! 
! #ifdef LCC 
! #include <stdlib.h>
! #endif
! 
  #ifdef VMS 
  #include <stdlib.h>
+ #include <redexp.VMS>
  #endif
  
  #include "list.h"
  
***************
*** 37,56 ****
  static Iostack stack;
  static char real_eof = EOF;
  
! #ifndef VMS 
! static FILE *IOSTREAM = stdin;
! #else
! FILE *IOSTREAM; /* VMS cannot initialize streams, init in jgraph.c -hdd */
! #endif
  static char FILENAME[300];
  static int line = 1;
  
- #define iostackinit() {\
-                         if (init == 0) {\
-                           strcpy(FILENAME, "<stdin>"); \
-                           stack = (Iostack) make_list(sizeof(struct iostack)); \
-                           init = 1; }}
- 
  #ifdef VMS
  /* On VMS, there are no popen() and pclose(), so we provide dummies here. */
  FILE *popen(command, type)
--- 42,51 ----
  static Iostack stack;
  static char real_eof = EOF;
  
! static FILE *IOSTREAM;
  static char FILENAME[300];
  static int line = 1;
  
  #ifdef VMS
  /* On VMS, there are no popen() and pclose(), so we provide dummies here. */
  FILE *popen(command, type)
***************
*** 65,73 ****
  }
  #endif /*VMS*/
  
  error_header()
  {
-   iostackinit();
    fprintf(stderr, "%s,%d: ", FILENAME, line);
  }
    
--- 60,100 ----
  }
  #endif /*VMS*/
  
+ set_input_file(s)
+ char *s;
+ {
+   FILE *f;
+   Iostack n;
+ 
+   if (init == 0) {
+     stack = (Iostack) make_list(sizeof(struct iostack));
+     if (s == CNULL) {
+       IOSTREAM = stdin;
+       strcpy(FILENAME, "<stdin>");
+     } else {
+       IOSTREAM = fopen(s, "r");
+       if (IOSTREAM == NULL) {
+         fprintf(stderr, "Error: cannot open file \"%s\"\n", s);
+         exit(1);
+       }
+       strcpy(FILENAME, s);
+     }
+     init = 1;
+   } else {
+     n = (Iostack) get_node(stack);
+     n->stream = NULL;
+     n->filename = (char *) malloc (sizeof(char)*(strlen(s)+2));
+     strcpy(n->filename, s);
+     n->oldchar = oldchar;
+     n->oldcharvalid = oldcharvalid;
+     n->pipe = pipe;
+     n->line = line;
+     insert(n, stack->flink);
+   }
+ }
+ 
  error_header()
  {
    fprintf(stderr, "%s,%d: ", FILENAME, line);
  }
    
***************
*** 118,124 ****
  
  static int iostackempty()
  {
-   iostackinit();
    return (first(stack) == nil(stack));
  }
  
--- 145,150 ----
***************
*** 127,133 ****
  {
    Iostack n;
  
-   iostackinit();
    n = (Iostack) get_node(stack);
    n->stream = IOSTREAM;
    n->filename = (char *) malloc (sizeof(char)*(strlen(FILENAME)+2));
--- 153,158 ----
***************
*** 156,165 ****
  {
    Iostack n;
  
- /*  error_header();
-   fprintf(stderr, "\nCalled pop_io_stack.  Pipe = %d\n", pipe); */
    fflush(IOSTREAM);
-   iostackinit();
    if (pipe) {
      if (pclose(IOSTREAM)) {
        /*error_header();
--- 181,187 ----
***************
*** 170,178 ****
      fclose(IOSTREAM);
    }
    n = last(stack);
    IOSTREAM = n->stream;
    strcpy(FILENAME, n->filename);
! /*  free(n->filename); */
    pipe = n->pipe;
    line = n->line;
    oldchar = n->oldchar;
--- 192,207 ----
      fclose(IOSTREAM);
    }
    n = last(stack);
+   if (n->stream == NULL) {
+     n->stream = fopen(n->filename, "r");
+     if (n->stream == NULL) {
+       fprintf(stderr, "Error: cannot open file \"%s\"\n", n->stream);
+       exit(1);
+     }
+   }
    IOSTREAM = n->stream;
    strcpy(FILENAME, n->filename);
!   free(n->filename);
    pipe = n->pipe;
    line = n->line;
    oldchar = n->oldchar;
***************
*** 187,193 ****
    if (getnew) {
      while (1) {
        if (gettoken(INPUT) == 0) {
-         iostackinit();
          if (iostackempty()) {
            eof = 1;
            getnew = 0;
--- 216,221 ----

exit 0 # Just in case...
