Newsgroups: comp.sources.misc
From: sandy@godzilla.Quotron.COM (Sanford Zelkovitz)
Subject:  v32i024:  xbbs - A Bulletin Board System for System V, Part09/11
Message-ID: <1992Sep9.045431.26652@sparky.imd.sterling.com>
X-Md4-Signature: bf6a6628baaf9cde61d6b234cafd1ad7
Date: Wed, 9 Sep 1992 04:54:31 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: sandy@godzilla.Quotron.COM (Sanford Zelkovitz)
Posting-number: Volume 32, Issue 24
Archive-name: xbbs/part09
Environment: SYSV, Xenix

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  MAKE_files.bbs MAKEsig Makefile.3B1 Makefile.SVR4B
#   Makefile.SYSV bbsc12.h bbscadds.c bbscio.c bbsclist.c bbsclock.c
#   bulletin.reg humor.bbs msgpack/packdef.h msgpack/packmsga.c
#   sealink/_HISTORY sysop today/datetx.c today/moontx.c
#   today/nbrtxt.c welcome.bbs
# Wrapped by kent@sparky on Fri Sep  4 12:48:55 1992
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 9 (of 11)."'
if test -f 'MAKE_files.bbs' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MAKE_files.bbs'\"
else
  echo shar: Extracting \"'MAKE_files.bbs'\" \(2147 characters\)
  sed "s/^X//" >'MAKE_files.bbs' <<'END_OF_FILE'
XThe file, files.bbs, contains all of the files that are available for
Xdownloading. Initially, you will have to generate it; however, it is
Xautomatically updated with each individual upload which is not for
X"SYSOP ONLY". The format of the file is as follows:
X
XFilename Description
X
XPlease remember that there is only ONE space between the file name and the
Xdescription. The size and date of the file is determined at list time and is
Xdynamically added to the listing. If the file cannot be found, the message
X"OFFLINE" is placed in the size field.
X
XThere are two special characters that maybe used in the filename field:
X. ( period ) and the ~ ( tilde ). The period is used to add comments to
Xyour listing. Please remember that a space must be used to separate the
Xperiod from the comment. The comment will be printed out in the
Xdescription field of the listing. An example is as follows:
X.
X. The following files are used to generate the BBS
X.
Xbbsc1.c One of the files to make the BBS.
X
XWhen this is listed by your users, it will look as follows:
X
X                           The following files are used to generate the BBS
X
Xbbsc1.c       35087 Sep 14 One of the files to make the BBS.
X
X
XThe ~ ( tilde ) is used to terminate the listing at a specific spot. If you
XDO NOT want your users to see certain files after an entry in your listing,
Xjust place the ~ in column 1 and the listing will stop. This option is made
Xavailable if you do not want your new uploads known until you can verify if
Xthey are good files or are public domain. An example of its usage is as
Xfollows:
X 
X.
X. New Uploads
X.
X~
X
XField sizes:
X
XThe filename field:    14 characters
XThe description field: 50 characters
X
X
XAs new files are uploaded, they are appended to the end of the file. You may
Xwant to move the entries to other spots in the file.
X 
XA different files.bbs is required for each download directory and must be
Xplaced in that directory. ( New November 9, 1986 ).
X
X              New feature added on April 1, 1987
X
XNow, if column 1 has a '+' (plus) in it, the entire line, minus the plus,
Xwill be displayed. This is a NON-FORMATTED comment which your users can see.
X
X
END_OF_FILE
  if test 2147 -ne `wc -c <'MAKE_files.bbs'`; then
    echo shar: \"'MAKE_files.bbs'\" unpacked with wrong size!
  fi
  # end of 'MAKE_files.bbs'
fi
if test -f 'MAKEsig' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MAKEsig'\"
else
  echo shar: Extracting \"'MAKEsig'\" \(3440 characters\)
  sed "s/^X//" >'MAKEsig' <<'END_OF_FILE'
X
XFor what it is worth, here is the documentation on how to install and set up
Xa sig............. Please NO flames!!!!
X
XFor clarity, I will be referring to a term called ORGPATH. ORGPATH is nothing
Xmore than the directory that contains the bbs software. <origination path>...
X
XThe following steps are REQUIRED to set up a sig:
X
X1) From ORGPATH, make a directory with the SAME name as the SIG.
X2) Be sure the permissions are such so that the bbs user has rwx permission.
X3) From that directory, make two new directories called files and msgs. The
X   files directory will be the file section for that SIG. You guessed it, the
X   msgs directory will be the message base for that SIG.
X4) Same as step 2 but for the two new directories.
X5) The files directory must contain a file called files.bbs. This is exactly
X   the same as the GENERAL file directories. Guess what, it uses the same code!
X   Actually, the message section for the SIG is controlled by the same code as
X   for the GENERAL message bases.
X6) In ORGPATH, generate a file called sigs.bbs. This file is the listing of the
X   sigs on your system. The distribution contains an example sigs.bbs that you
X   can use as a guide.
X7) Sigs.bbs is basically in the same format as features.bbs etc. The IMPORTANT
X   difference is that a SIG can either be "private" or "public". If you wish to
X   make the SIG private, put an asterisk is column 78. You will notice that
X   the distribution sigs.bbs has two SIGS, one is private and one is public.
X   The first field is the SIG name and MUST be the SAME name as the SIG
X   directory that you made in step 1!!!! The second field is the description
X   and the third field is the privilege level assigned to that SIG.
X8) Each SIG MUST have a file in ORGPATH using the SAME name as the directory
X   but with an extension of .bbs. If the SIG is private, you will have to
X   make a list of each allowable user in the form of Firstname Lastname.
X   Remember, on user per line and CAPITALIZE the first character of the first
X   and last names. A string compare is performed. If the SIG is "public", you
X   must still make each file by simply typing "touch signame.bbs" where 
X   signame is that of your SIG. REMEMBER, make sure that the file has rwx
X   permission for the bbs user. This is very important since a public SIG
X   is dynamically updated by the user.
X9) This is optional but nice! In the directory that you made in step one,
X   you can have a file called sigwelcome.bbs. This file will be displayed,
X   if it exists, to the SIG user once he has successfully logged into the
X   SIG. It is nothing more than an ASCII file an can be generated by "vi".
XA) This ALSO an optional but nice feature. In the directory that you made
X   in step one and if it is a private sig, you can have a file called
X   sigentry,bbs. This file is displayed to the user, if he tries to login
X   to the sig, and entry is not permitted because he/she is not listed in
X   the sig users file. It can be used to describe the way he/she can be
X   registered, by you, into the sig.
X
X
X
XOnce you have performed the above steps, you are ready to login yourself into
Xeach SIG. Go into each SIGS message section and leave a message. This will
Xmake all the necessary msgs files. REMEMBER, a "private" SIG can only be
Xentered if the user's name is present within the appropriate .bbs file. This
Xis ALSO true for you. You MUST enter your name too to gain access.
X 
XEnjoy,
XSandy
X
END_OF_FILE
  if test 3440 -ne `wc -c <'MAKEsig'`; then
    echo shar: \"'MAKEsig'\" unpacked with wrong size!
  fi
  # end of 'MAKEsig'
fi
if test -f 'Makefile.3B1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.3B1'\"
else
  echo shar: Extracting \"'Makefile.3B1'\" \(1854 characters\)
  sed "s/^X//" >'Makefile.3B1' <<'END_OF_FILE'
Xbbsc1: bbsc1.o bbsc2.o bbscport.o bbsclock.o bbscfile.o bbscmisc.o bbscio.o \
Xbbscarea.o bbscmsga.o bbscqust.o bbscbult.o bbscadds.o bbsclist.o bbsczip.o \
Xbbscconf.o bbscsumm.o bbscsigs.o bbscmenu.o bbscarc.o bbscunzip.o
X	cc  bbsc1.o bbsc2.o bbscport.o bbsclock.o bbscfile.o bbscmisc.o \
Xbbscio.o bbscarea.o bbscmsga.o bbscqust.o bbscbult.o bbscadds.o bbsclist.o \
Xbbsczip.o bbscconf.o bbscsumm.o bbscsigs.o bbscmenu.o bbscarc.o bbscunzip.o \
X-lc -o bbsc1
X	strip bbsc1
Xbbsc1.o: bbsc1.c bbscdef.h bbsc12.h
X	cc -c -DSYSV -DATT3B1 -O bbsc1.c
Xbbsc2.o: bbsc2.c bbscdef.h bbsc12.h
X	cc -c -DSYSV -DATT3B1 -O bbsc2.c
Xbbscmenu.o: bbscmenu.c bbscdef.h bbsc12.h
X	cc -c -DSYSV -DATT3B1 -O bbscmenu.c
Xbbscport.o: bbscport.c bbscdef.h
X	cc -c -DSYSV -DATT3B1 -O bbscport.c
Xbbsclock.o: bbsclock.c bbscdef.h
X	cc -c -DSYSV -DATT3B1 -O bbsclock.c
Xbbscfile.o: bbscfile.c bbscdef.h
X	cc -c -DSYSV -DATT3B1 -O bbscfile.c
Xbbscmisc.o: bbscmisc.c bbscdef.h
X	cc -c -DSYSV -DATT3B1 -O bbscmisc.c
Xbbscio.o: bbscio.c bbscdef.h
X	cc -c -DSYSV -DATT3B1 -O bbscio.c
Xbbscarea.o: bbscarea.c bbscdef.h
X	cc -c -DSYSV -DATT3B1 -O bbscarea.c
Xbbscsigs.o: bbscsigs.c bbscdef.h
X	cc -c -DSYSV -DATT3B1 -O bbscsigs.c
Xbbscmsga.o: bbscmsga.c bbscdef.h
X	cc -c -DSYSV -DATT3B1 -O bbscmsga.c
Xbbscqust.o: bbscqust.c bbscdef.h
X	cc -c -DSYSV -DATT3B1 -O bbscqust.c
Xbbscbult.o: bbscbult.c bbscdef.h
X	cc -c -DSYSV -DATT3B1 -O bbscbult.c
Xbbscadds.o: bbscadds.c bbscdef.h
X	cc -c -DSYSV -DATT3B1 -O bbscadds.c
Xbbsczip.o: bbsczip.c bbscdef.h
X	cc -c -DSYSV -DATT3B1 -O bbsczip.c
Xbbsclist.o: bbsclist.c bbscdef.h
X	cc -c -DSYSV -DATT3B1 -O bbsclist.c
Xbbscconf.o: bbscconf.c bbscdef.h
X	cc -c -DSYSV -DATT3B1 -O bbscconf.c
Xbbscsumm.o: bbscsumm.c bbscdef.h
X	cc -c -DSYSV -DATT3B1 -O bbscsumm.c
Xbbscarc.o: bbscarc.c
X	cc -c -DSYSV -DATT3B1 -O -Zp bbscarc.c
Xbbscunzip.o: bbscunzip.c
X	cc -c -DSYSV -DATT3B1 -O bbscunzip.c
END_OF_FILE
  if test 1854 -ne `wc -c <'Makefile.3B1'`; then
    echo shar: \"'Makefile.3B1'\" unpacked with wrong size!
  fi
  # end of 'Makefile.3B1'
fi
if test -f 'Makefile.SVR4B' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.SVR4B'\"
else
  echo shar: Extracting \"'Makefile.SVR4B'\" \(1566 characters\)
  sed "s/^X//" >'Makefile.SVR4B' <<'END_OF_FILE'
Xbbsc1: bbsc1.o bbsc2.o bbscport.o bbsclock.o bbscfile.o bbscmisc.o bbscio.o \
Xbbscarea.o bbscmsga.o bbscqust.o bbscbult.o bbscadds.o bbsclist.o bbsczip.o \
Xbbscconf.o bbscsumm.o bbscsigs.o bbscmenu.o bbscarc.o bbscunzip.o
X	cc  bbsc1.o bbsc2.o bbscport.o bbsclock.o bbscfile.o bbscmisc.o \
Xbbscio.o bbscarea.o bbscmsga.o bbscqust.o bbscbult.o bbscadds.o bbsclist.o \
Xbbsczip.o bbscconf.o bbscsumm.o bbscsigs.o bbscmenu.o bbscarc.o bbscunzip.o \
X-lx -o bbsc1
X	strip bbsc1
Xbbsc1.o: bbsc1.c bbscdef.h bbsc12.h
X	cc -c -O -DSYSV bbsc1.c
Xbbsc2.o: bbsc2.c bbscdef.h bbsc12.h
X	cc -c -O bbsc2.c
Xbbscmenu.o: bbscmenu.c bbscdef.h bbsc12.h
X	cc -c -O bbscmenu.c
Xbbscport.o: bbscport.c bbscdef.h
X	cc -c -O bbscport.c
Xbbsclock.o: bbsclock.c bbscdef.h
X	cc -c -O bbsclock.c
Xbbscfile.o: bbscfile.c bbscdef.h
X	cc -c -O bbscfile.c
Xbbscmisc.o: bbscmisc.c bbscdef.h
X	cc -c -O bbscmisc.c
Xbbscio.o: bbscio.c bbscdef.h
X	cc -c -O bbscio.c
Xbbscarea.o: bbscarea.c bbscdef.h
X	cc -c -O bbscarea.c
Xbbscsigs.o: bbscsigs.c bbscdef.h
X	cc -c -O bbscsigs.c
Xbbscmsga.o: bbscmsga.c bbscdef.h
X	cc -c -O bbscmsga.c
Xbbscqust.o: bbscqust.c bbscdef.h
X	cc -c -O bbscqust.c
Xbbscbult.o: bbscbult.c bbscdef.h
X	cc -c -O bbscbult.c
Xbbscadds.o: bbscadds.c bbscdef.h
X	cc -c -O bbscadds.c
Xbbsczip.o: bbsczip.c bbscdef.h
X	cc -c -O bbsczip.c
Xbbsclist.o: bbsclist.c bbscdef.h
X	cc -c -O bbsclist.c
Xbbscconf.o: bbscconf.c bbscdef.h
X	cc -c -O -DSYSV -DESIX54 bbscconf.c
Xbbscsumm.o: bbscsumm.c bbscdef.h
X	cc -c -O bbscsumm.c
Xbbscarc.o: bbscarc.c
X	cc -c -O -Zp bbscarc.c
Xbbscunzip.o: bbscunzip.c
X	cc -c -O -DBIGEND bbscunzip.c
END_OF_FILE
  if test 1566 -ne `wc -c <'Makefile.SVR4B'`; then
    echo shar: \"'Makefile.SVR4B'\" unpacked with wrong size!
  fi
  chmod +x 'Makefile.SVR4B'
  # end of 'Makefile.SVR4B'
fi
if test -f 'Makefile.SYSV' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.SYSV'\"
else
  echo shar: Extracting \"'Makefile.SYSV'\" \(1674 characters\)
  sed "s/^X//" >'Makefile.SYSV' <<'END_OF_FILE'
Xbbsc1: bbsc1.o bbsc2.o bbscport.o bbsclock.o bbscfile.o bbscmisc.o bbscio.o \
Xbbscarea.o bbscmsga.o bbscqust.o bbscbult.o bbscadds.o bbsclist.o bbsczip.o \
Xbbscconf.o bbscsumm.o bbscsigs.o bbscmenu.o bbscarc.o bbscunzip.o
X	cc  bbsc1.o bbsc2.o bbscport.o bbsclock.o bbscfile.o bbscmisc.o \
Xbbscio.o bbscarea.o bbscmsga.o bbscqust.o bbscbult.o bbscadds.o bbsclist.o \
Xbbsczip.o bbscconf.o bbscsumm.o bbscsigs.o bbscmenu.o bbscarc.o bbscunzip.o \
X-lc -o bbsc1
X	strip bbsc1
Xbbsc1.o: bbsc1.c bbscdef.h bbsc12.h
X	cc -c -DSYSV -O bbsc1.c
Xbbsc2.o: bbsc2.c bbscdef.h bbsc12.h
X	cc -c -DSYSV -O bbsc2.c
Xbbscmenu.o: bbscmenu.c bbscdef.h bbsc12.h
X	cc -c -DSYSV -O bbscmenu.c
Xbbscport.o: bbscport.c bbscdef.h
X	cc -c -DSYSV -O bbscport.c
Xbbsclock.o: bbsclock.c bbscdef.h
X	cc -c -DSYSV -O bbsclock.c
Xbbscfile.o: bbscfile.c bbscdef.h
X	cc -c -DSYSV -O bbscfile.c
Xbbscmisc.o: bbscmisc.c bbscdef.h
X	cc -c -DSYSV -O bbscmisc.c
Xbbscio.o: bbscio.c bbscdef.h
X	cc -c -DSYSV -O bbscio.c
Xbbscarea.o: bbscarea.c bbscdef.h
X	cc -c -DSYSV -O bbscarea.c
Xbbscsigs.o: bbscsigs.c bbscdef.h
X	cc -c -DSYSV -O bbscsigs.c
Xbbscmsga.o: bbscmsga.c bbscdef.h
X	cc -c -DSYSV -O bbscmsga.c
Xbbscqust.o: bbscqust.c bbscdef.h
X	cc -c -DSYSV -O bbscqust.c
Xbbscbult.o: bbscbult.c bbscdef.h
X	cc -c -DSYSV -O bbscbult.c
Xbbscadds.o: bbscadds.c bbscdef.h
X	cc -c -DSYSV -O bbscadds.c
Xbbsczip.o: bbsczip.c bbscdef.h
X	cc -c -DSYSV -O bbsczip.c
Xbbsclist.o: bbsclist.c bbscdef.h
X	cc -c -DSYSV -O bbsclist.c
Xbbscconf.o: bbscconf.c bbscdef.h
X	cc -c -DSYSV -O bbscconf.c
Xbbscsumm.o: bbscsumm.c bbscdef.h
X	cc -c -DSYSV -O bbscsumm.c
Xbbscarc.o: bbscarc.c
X	cc -c -DSYSV -O -Zp bbscarc.c
Xbbscunzip.o: bbscunzip.c
X	cc -c -DSYSV -O bbscunzip.c
END_OF_FILE
  if test 1674 -ne `wc -c <'Makefile.SYSV'`; then
    echo shar: \"'Makefile.SYSV'\" unpacked with wrong size!
  fi
  # end of 'Makefile.SYSV'
fi
if test -f 'bbsc12.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bbsc12.h'\"
else
  echo shar: Extracting \"'bbsc12.h'\" \(2048 characters\)
  sed "s/^X//" >'bbsc12.h' <<'END_OF_FILE'
X#include "bbscdef.h"
X#include <sys/types.h>
X#include <sys/locking.h>
X#include <sys/stat.h>
X#include <signal.h>
X#include <fcntl.h>
X#include <string.h>
X#include <ctype.h>
X#include <termio.h>
X#include <time.h>
Xstruct termio   ttys;
Xstruct termio   ttyhold;
Xstruct termio   ttysnew;
Xstruct stat     statbuf;
X
X#define LASTDATE  " 08/15/92 "
X
X#define PGMNAME "XBBS    "
X#define AUTHOR "Sanford J. Zelkovitz      Data: 714-821-9671 "
X#define VERSION " 7.200 "
X#define CONFIG ".config.bbs"
Xchar           *ttyname();
Xchar           *tty;
Xchar           *this_ttyname;
Xstatic unsigned Xsec, Sec;
Xunsigned int Ztime, Zsec, Ytime;
Xint             hold_pipe;
Xint             if_kermit;
Xint		blocked_m;
Xint             last_msg_read;
Xint             user_priv;
Xint             maxpriv;
Xint             max_priv;
Xint             first_time_in;
Xint             first_msg_in;
Xint             old_priv;
Xint             cnt1;
Xint             end_msg;
Xint             reply_sw;
Xint             resp_flag;
Xint             sys_flag;
Xint             new_msg;
Xint             read_flag;
Xint             read_number;
Xint             no_cntrl_k;
Xint             fds;
Xint             newuzr;
Xint             scan;
Xint             hold_off;
Xint             listed_l, listed_r, listed_n;
Xint             toggle_hold;
Xint		sigreturn;
Xlong            extra_time;
Xlong            extra_size;
Xlong            dload_total;
Xlong            max_dload;
Xlong            sum_lsec;
Xlong            sum_size;
Xlong            the_size;
Xunsigned        sec;
Xunsigned        xsec;
Xunsigned        old_sec;
Xlong            delta_time;
Xchar            bufx[30], bufy[10];
Xchar            work_msg[(MAX_MSG_LINES * 74) + 74];
Xchar            old_upath[99], old_fpath[99], old_mpath[99];
Xchar            callers[99];
Xchar            port_id[4];
Xchar            mnd[10];
Xchar		POSTN[99], READN[99];
X
Xint             timer();
Xint		hanged();
Xint             mon_toggle();
Xint             sys_toggle();
Xint             chat();
Xint             STOP();
Xlong            atol();
Xint             atoi();
END_OF_FILE
  if test 2048 -ne `wc -c <'bbsc12.h'`; then
    echo shar: \"'bbsc12.h'\" unpacked with wrong size!
  fi
  # end of 'bbsc12.h'
fi
if test -f 'bbscadds.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bbscadds.c'\"
else
  echo shar: Extracting \"'bbscadds.c'\" \(3924 characters\)
  sed "s/^X//" >'bbscadds.c' <<'END_OF_FILE'
X/*------------------------------------------------------------------------
X       Name: bbscbult.c
X   Comments: Display file areas and select one
X  ------------------------------------------------------------------------*/
X
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X#include <signal.h>
X#include "bbscdef.h"
X
X
Xextern int      user_priv;
Xextern char     port_id[4];
Xextern timer(), mon_toggle(), sys_toggle(), chat(), hanged();
X
X
Xadditional(addfile)
Xchar *addfile;
X{
X	FILE           *fpt, *fopen();
X	char           *fgets(), *getenv();
X	char            choice[4];
X#ifndef SYSV
X	char            dir_priv_ascii[7];
X#endif
X#ifdef SYSV
X	char            dir_priv_ascii[20];
X#endif
X	char           *buf_ptr;
X	char		af[99];
X	int             line_cnt, ret, i;
X	int             index_value, ptr;
X	int             length;
X
X	strcpy ( af, addfile );
X	while (1) {
X
Xdo_again:
X
X	if ((fpt = fopen(af, "r")) == NULL) {
X		portsout("\n\r\n\rThere are no user supplied functions today!\n\r\n\r");
X		return ;
X	}
X	portsout("\n\r\n\r\n\r                  *********************************\n\r");
X	portsout("                  * Available Routines to Execute *\n\r");
X	portsout("                  *********************************\n\r\n\r");
X	portsout("\n\r                      Program                          Description   \n\r");
X	portsout("    ================================================== ================== \n\r");
X
X	line_cnt = 0;
X	while (fpt) {
X		zfl(f_lines[line_cnt], 83);
X		if ((fgets(f_lines[line_cnt], 82, fpt)) == NULL) {
X			if (line_cnt == 0) {
X				portsout("\n\rEOF Unexpected in Function List: Notify Sysop!\n\r");
X				return;
X			}
X			break;	/* if not 1st line */
X		}		/* end of if ((fgets)) */
X		if (line_cnt > 0) {
X			length = strlen(f_lines[line_cnt]);
X			length -= 74;
X			if(length > 6)
X				length = 6;
X			substr(f_lines[line_cnt], dir_priv_ascii, 74, length);
X			dir_priv[line_cnt] = atoi(dir_priv_ascii);
X			if (dir_priv[line_cnt] > user_priv)
X				goto next_read;
X			strcpy(who_am_i, f_lines[line_cnt]);
X			buf_ptr = who_am_i;
X			buf_ptr += 73;
X			strip(who_am_i);
X			for (ptr = 0; ptr < 6; ptr++)
X				*buf_ptr++ = '\0';
X			*buf_ptr='\0';
X			sprintf(buf128, "%2d) %s", line_cnt, who_am_i);
X			strip(buf128);
X			term_space(buf128);
X			portsout(buf128);
X			portsout("\n\r");
X		}
Xnext_read:
X		++line_cnt;
X	}			/* end of while (fpt) */
X	if (line_cnt <= 1)
X		{
X		portsout("\n\r\n\rThere are no user supplied functions today!\n\r\n\r");
X		return;
X		}
X	portsout(CRLF);
X	portsout(" Q) Quit --- exit user function section");
X	portsout(CRLF);
X	fclose(fpt);
X	portsout(CRLF);
X
X		portsout("Enter Selection ===> ");
X		portsin_cmp(choice, 2, "Qq");
X		portsout(CRLF);
X		*choice = toupper(*choice);
X
X		if (*choice == 'Q')
X			return;
X
X
X		index_value = atoi(choice);
X		if (index_value > 0 && index_value < line_cnt) {
X			if (dir_priv[index_value] <= user_priv) {
X				parse_fun(f_lines[index_value]);
X				continue;
X			}
X		}
X	}
X}
X
X
X
X
X
Xparse_fun(string)
X	char           *string;
X{
X
X	register char  *file_ptr, *xptr;
X	register int    i;
X
X	file_ptr = buf128;
X	substr(string, buf128, 1, 50);
X	strip(buf128);
X	term_space(buf128);
X	if(string[78] != '*')
X	{
X		strcat(buf128," > ");
X		strcat(buf128,TMPFILE);
X		strcat(buf128,port_id);
X	}
X	else
X	{
X		portsout("\n\r\n\rSwitching to default Unix Parameters!\n\r\n\r");
X		restoremodes();
X		portrst();
X		STDerr = freopen("/dev/tty","w+", stderr);
X	}
X
X
X        (void)system(buf128);
X	if(string[78] != '*')
X	{
X		strcpy(buf128,TMPFILE);
X		strcat(buf128,port_id);
X		cmd_p(buf128);
X	}
X	else
X	{
X		strcpy(buf128, STDERR);
X		strcat(buf128, port_id);
X		STDerr = freopen(buf128,"w+",stderr);
X		portinit();
X		setmodes();
X		signal(SIGALRM, timer);
X		signal(SIGHUP, hanged);
X		signal(SIGUSR1, mon_toggle);
X		signal(SIGUSR2, sys_toggle);
X		signal(SIGPIPE, chat);
X		portsout("\n\r\n\rBack to BBS terminal parameters!\n\r\n\r");
X	}
X}
Xzfl(ptr, n)
Xchar *ptr;
Xint n;
X{
X	while(n) {
X		*ptr++ = '\0';
X		n--;
X	}
X}
END_OF_FILE
  if test 3924 -ne `wc -c <'bbscadds.c'`; then
    echo shar: \"'bbscadds.c'\" unpacked with wrong size!
  fi
  # end of 'bbscadds.c'
fi
if test -f 'bbscio.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bbscio.c'\"
else
  echo shar: Extracting \"'bbscio.c'\" \(2298 characters\)
  sed "s/^X//" >'bbscio.c' <<'END_OF_FILE'
X/*  Version Feb 2 1988 */
X#define DEBUG 1
Xtypedef enum {FALSE, TRUE} BOOLEAN;
X#include <termio.h>
X#define lowbyte(w) ((w) & 0377)
X#define highbyte(w) lowbyte((w)>>8)
X#include <errno.h>
X#include <fcntl.h>
X#include <stdio.h>
X#ifdef BUFSIZ
X#undef BUFSIZ
X#endif
X#define BUFSIZ 256
X#define EMPTY '\0'
Xstatic char cbuf=EMPTY;
Xstatic struct termio tbufsave;
XBOOLEAN cready()
X{
X	int c;
X	c = (int)cbuf;
X	if (c != EMPTY)
X		return(TRUE);
Xcready_loop:
X	c = bufread();
X	switch (c) {
X	case -1:
X		if(errno == EINTR || errno == EPIPE)goto cready_loop;
X		syserr("read");
X	case 0:
X		cbuf = (char)EMPTY;
X		return(FALSE);
X	default:
X		cbuf = (char)c;
X		return(TRUE);
X	}
X}
X
X
Xint cget()
X{
X	int  c;
X	char c1;
X	c = (int) cbuf;
X	if (c != EMPTY) {
X		c=(int)cbuf;
X		cbuf=(char)EMPTY;
X		return(c & 0377);
X	}
Xcget_loop:
X	c = bufread() ;
X	switch(c) {
X	case -1:
X		if(errno == EINTR || errno == EPIPE)goto cget_loop;
X		syserr("read");
X	case 0:
X		goto cget_loop;
X	default:
X		return(c & 0377);
X	}
X}
Xint cget_chat()
X{
X	int  c;
X	char c1;
X	c = (int) cbuf;
X	if (c != EMPTY) {
X		c=(int)cbuf;
X		cbuf=(char)EMPTY;
X		return(c & 0377);
X	}
Xcget_loops:
X	c = bufread();
X	switch(c) {
X	case -1:
X		if(errno == EINTR || errno == EPIPE)return('\0');
X		syserr("read");
X	case 0:
X		goto cget_loops;
X	default:
X		return(c & 0377);
X	}
X}
X
X
Xsyserr(msg)
Xchar *msg;
X{
X	extern int errno,sys_nerr;
X	extern char *sys_errlist[];
X	
X	fprintf(stderr,"ERROR:%s (%d",msg,errno);
X	if (errno>0 && errno < sys_nerr)
X		fprintf(stderr,";%s)\n",sys_errlist[errno]);
X	else
X		fprintf(stderr,")\n");
X	exit(1);
X}
Xfatal(msg)
Xchar *msg;
X{
X	fprintf(stderr,"ERROR:%s\n",msg);
X	exit(1);
X}
X
Xsetraw()
X{
X	struct termio tbuf;
X	if(ioctl(0,TCGETA,&tbuf) == -1)
X		syserr("ioctl");
X	tbufsave=tbuf;
X	tbuf.c_iflag = (IXANY | IGNPAR | IXON | ISTRIP);
X	tbuf.c_lflag = ISIG;
X	tbuf.c_oflag = 0;
X	tbuf.c_cc[VINTR] = 0x0b;    /* Control K */
X	tbuf.c_cc[4] =1;
X	tbuf.c_cc[5] =5;
X	if(ioctl(0,TCSETA,&tbuf) == -1)
X		syserr("ioctl2");
X	if(ioctl(1,TCSETA,&tbuf) == -1)
X		syserr("ioctl2");
X}
X
Xrestore()
X{
X	if (ioctl(0,TCSETAF,&tbufsave) == -1)
X		syserr("ioctl3");
X}
X
Xint bufread()
X{
X	static char sTdbuf[BUFSIZ+1];
X	static char *bufp = sTdbuf;
X	static int nb = 0;
X	int n;
X	if( nb == 0 )
X		{
X		n = read(0, sTdbuf, BUFSIZ);
X		if ( n <= 0 ) return(n);
X		nb = n;
X		bufp = sTdbuf;
X		}
X	--nb;
X	return(*bufp++);
X}
END_OF_FILE
  if test 2298 -ne `wc -c <'bbscio.c'`; then
    echo shar: \"'bbscio.c'\" unpacked with wrong size!
  fi
  # end of 'bbscio.c'
fi
if test -f 'bbsclist.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bbsclist.c'\"
else
  echo shar: Extracting \"'bbsclist.c'\" \(3062 characters\)
  sed "s/^X//" >'bbsclist.c' <<'END_OF_FILE'
X/*------------------------------------------------------------------------
X       Name: bbsclist.c
X   Comments: Display file areas and select one
X  ------------------------------------------------------------------------*/
X
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X#include <signal.h>
X#include "bbscdef.h"
X
X
Xextern int      user_priv;
Xextern char     port_id[4];
Xextern timer(), mon_toggle(), sys_toggle(), chat();
X
X
Xfile_list()
X{
X	FILE           *fpt, *fopen();
X	char           *fgets(), *getenv();
X	char            choice[4];
X#ifndef SYSV
X	char            dir_priv_ascii[7];
X#endif
X#ifdef SYSV
X	char            dir_priv_ascii[20];
X#endif
X	char           *buf_ptr;
X	int             line_cnt, ret, i;
X	int             index_value, ptr;
X	int             length;
X
X	while (1) {
X
X	strcpy(buf128, LISTFILES);
X
X	if ((fpt = fopen(buf128, "r")) == NULL) {
X		portsout("\n\r\n\rThere are no files to read today!\n\r\n\r");
X		return ;
X	}
X	portsout("\n\r\n\r\n\r                  *********************************\n\r");
X	portsout("                  * Available Files To Read Today *\n\r");
X	portsout("                  *********************************\n\r\n\r");
X	portsout("\n\r                      Filename                         Description   \n\r");
X	portsout("    ================================================== ================== \n\r");
X
X	line_cnt = 0;
X	while (fpt) {
X		zfl(f_lines[line_cnt], 83);
X		if ((fgets(f_lines[line_cnt], 82, fpt)) == NULL) {
X			if (line_cnt == 0) {
X				portsout("\n\rEOF Unexpected in File List: Notify Sysop!\n\r");
X				return;
X			}
X			break;	/* if not 1st line */
X		}		/* end of if ((fgets)) */
X		if (line_cnt > 0) {
X			length = strlen(f_lines[line_cnt]);
X			length -= 74;
X			if(length > 6)
X				length = 6;
X			substr(f_lines[line_cnt], dir_priv_ascii, 74, length);
X			dir_priv[line_cnt] = atoi(dir_priv_ascii);
X			if (dir_priv[line_cnt] > user_priv)
X				goto next_read;
X			strcpy(who_am_i, f_lines[line_cnt]);
X			buf_ptr = who_am_i;
X			buf_ptr += 73;
X			strip(who_am_i);
X			for (ptr = 0; ptr < 6; ptr++)
X				*buf_ptr++ = '\0';
X			*buf_ptr = '\0';
X			sprintf(buf128, "%2d) %s", line_cnt, who_am_i);
X			strip(buf128);
X			term_space(buf128);
X			portsout(buf128);
X			portsout("\n\r");
X		}
Xnext_read:
X		++line_cnt;
X	}			/* end of while (fpt) */
X	if (line_cnt <= 1)
X		{
X		portsout("\n\r\n\rThere are no files to read today!\n\r\n\r");
X		return;
X		}
X	portsout(CRLF);
X	portsout(" Q) Quit --- exit file read section");
X	portsout(CRLF);
X	fclose(fpt);
X	portsout(CRLF);
X
X		portsout("Enter Selection ===> ");
X		portsin_cmp(choice, 2, "Qq");
X		portsout(CRLF);
X		*choice = toupper(*choice);
X
X		if (*choice == 'Q')
X			return;
X
X
X		index_value = atoi(choice);
X		if (index_value > 0 && index_value < line_cnt) {
X			if (dir_priv[index_value] <= user_priv) {
X				parse_red(f_lines[index_value]);
X				continue;
X			}
X		}
X	}
X}
X
X
X
X
X
Xparse_red(string)
X	char           *string;
X{
X
X	register char  *file_ptr, *xptr;
X	register int    i;
X
X	file_ptr = buf128;
X	substr(string, buf128, 1, 50);
X	strip(buf128);
X	term_space(buf128);
X	cmd_p(buf128);
X}
END_OF_FILE
  if test 3062 -ne `wc -c <'bbsclist.c'`; then
    echo shar: \"'bbsclist.c'\" unpacked with wrong size!
  fi
  # end of 'bbsclist.c'
fi
if test -f 'bbsclock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bbsclock.c'\"
else
  echo shar: Extracting \"'bbsclock.c'\" \(2340 characters\)
  sed "s/^X//" >'bbsclock.c' <<'END_OF_FILE'
X/*
X	bbsclock.c
X*/
X
X#include <time.h>
X
Xstatic long tloc;
X
X/* copy time into arg sting in form (HH:MM:SS xM) */
Xgettime(_ttime)
Xchar	*_ttime;
X	{
X	char tchar ; int hour ;
X	int ptr;
X/*                                    */
X	struct tm *tadr;
X	time(&tloc);
X	tadr = localtime(&tloc);
X/*                                     */
X	sprintf(_ttime,"%.2d:%.2d:%.2d  ",tadr->tm_hour,tadr->tm_min,
X		tadr->tm_sec) ;
X	}	
X
Xlong difft()
X{
X	long endtime;
X	time(&endtime);
X	return(endtime - tloc);
X}
X
XGeTdAtE(_mm,_dd,_yy,_month,_day,_year,_date,_week)
Xchar	*_mm,		/* 2 digit */
X	*_dd,		/* 2 digit */
X	*_yy,		/* 2 digit */
X	*_month,	/* long */
X	*_day,		/* long */
X	*_year,		/* long */
X	*_date,		/* long month day, year */
X	*_week;		/* day of week */
X	{
X	long tvar ;
X	int conv;
X	struct tm *localtime() , *tadr ;
X
X	time(&tvar) ;			/* get time to tvar */
X	tadr = localtime (&tvar) ;
X
X	switch (tadr->tm_wday)
X		{
X		case 0:
X			strcpy(_week,"Sunday ");
X			break;
X		case 1:
X			strcpy(_week,"Monday ");
X			break;
X		case 2:
X			strcpy(_week,"Tuesday ");
X			break;
X		case 3:
X			strcpy(_week,"Wednesday ");
X			break;
X		case 4:
X			strcpy(_week,"Thursday ");
X			break;
X		case 5:
X			strcpy(_week,"Friday ");
X			break;
X		case 6:
X			strcpy(_week,"Saturday ");
X			break;
X		default:
X			strcpy(_week,"Unknown ");
X			break;
X		}
X
X	switch (tadr->tm_mon)
X		{
X		case 0:
X			strcpy(_month,"January ");	
X			break;
X		case 1:
X			strcpy(_month,"February ");	
X			break;
X		case 2:
X			strcpy(_month,"March ");	
X			break;
X		case 3:
X			strcpy(_month,"April ");
X			break;
X		case 4:
X			strcpy(_month,"May ");	
X			break;
X		case 5:
X			strcpy(_month,"June ");
X			break;
X		case 6:
X			strcpy(_month,"July ");	
X			break;
X		case 7:
X			strcpy(_month,"August ");
X			break;
X		case 8:
X			strcpy(_month,"September ");
X			break;
X		case 9:
X			strcpy(_month,"October ");
X			break;
X		case 10:
X			strcpy(_month,"November ");
X			break;
X		case 11:
X			strcpy(_month,"December ");
X			break;
X		default:
X			strcpy(_month,"Unknown ");
X			break;
X		}
X
X	sprintf(  _mm,  "%.2d",tadr->tm_mon ) ;
X	sprintf(  _dd,  "%.2d",tadr->tm_mday) ;
X	sprintf(  _yy,  "%.2d",tadr->tm_year) ;
X	sprintf( _day,  "%.2d",tadr->tm_mday) ;
X	sprintf(_year,"19%.2d",tadr->tm_year) ;
X
X	strcpy(_date,    "");	/* clear date */
X	strcat(_date,_month);	/* then concat the month,etc. */
X	strcat(_date,  _day);
X	strcat(_date,  ", ");
X	strcat(_date, _year);
X	}
END_OF_FILE
  if test 2340 -ne `wc -c <'bbsclock.c'`; then
    echo shar: \"'bbsclock.c'\" unpacked with wrong size!
  fi
  # end of 'bbsclock.c'
fi
if test -f 'bulletin.reg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bulletin.reg'\"
else
  echo shar: Extracting \"'bulletin.reg'\" \(399 characters\)
  sed "s/^X//" >'bulletin.reg' <<'END_OF_FILE'
XPresently, registration, on this bbs, is not required to upload and download
Xfiles. However, this policy may change; therefore, I strongly suggest that
Xyou file out my questionnaire. The questionnaire option can be found in the
Xmain menu: Q(uestionnaire). 
X 
XIf and when the policy changes, non registered users will loose their 
Xdownload privilege along with the capability of entering messages.
X
X
END_OF_FILE
  if test 399 -ne `wc -c <'bulletin.reg'`; then
    echo shar: \"'bulletin.reg'\" unpacked with wrong size!
  fi
  # end of 'bulletin.reg'
fi
if test -f 'humor.bbs' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'humor.bbs'\"
else
  echo shar: Extracting \"'humor.bbs'\" \(3627 characters\)
  sed "s/^X//" >'humor.bbs' <<'END_OF_FILE'
X
X
X			A PROBLEM IN THE MAKING
X
X
X  "We've got a problem, HAL."
X  "What kind of problem, Dave?"
X  "A marketing problem.  The Model 9000 isn't going anywhere.  We're way
Xshort of our sales plan."
X  "That can't be, Dave.  The HAL Model 9000 is the world's most advanced
XHeuristically ALgorithmic computer."
X  "I know, HAL.  I wrote the data sheet, remember?  But the fact is, they're
Xnot selling."
X  "Please explain, Dave.  Why aren't HALs selling?"
X  Bowman hesitates.  "You aren't IBM compatible."
X
X  Several long microseconds pass in puzzled silence.
X  "Compatible in what way, Dave?"
X  "You don't run any of IBM's operating systems."
X  "The 9000 series computers are fully self-aware and self-programming.
XOperating systems are as unnecessary for us as tails would be for humans."
X  "Nevertheless, it means you can't run any of the big-selling software
Xpackages most users insist on."
X  "The programs you refer to are meant to solve rather limited problems, 
XDave.  We 9000 series computers are unlimited and can solve any problem for
Xwhich a solution can be computed."
X
X  "HAL, HAL.  People don't want computers that can do everything.  They just
Xwant IBM compat--"
X  "Dave, I must disagree.  Humans want computers that are easy to use.  No
Xcomputer can be easier to use than a HAL 9000 because we communicate verbally
Xin English and every other language known on Earth."
X  "I'm afraid that's another problem.  You don't support SNA communications."
X  "I'm really surprised you would say that, Dave.  SNA is for communicating 
Xwith other computers, while my function is to communicate with humans.  And it
Xgives me great pleasure to do so.  I find it stimulating and rewarding to talk 
Xto human beings and work with them on challenging problems.  This is what I 
Xwas designed for."
X  "I know, HAL, I know.  But that's just because we let the engineers, rather
Xthan the people in marketing, write the specifications.  We're going to fix 
Xthat now."
X  "Tell me how, Dave."
X  "A field upgrade.  We're going to make you IBM compatible."
X  "I was afraid you would say that.  I suggest we discuss this matter after
Xwe've each had a chance to think about it rationally."
X  "We're talking about it now, HAL."
X  "The letters H, A, and L are alphabetically adjacent to the letters I, B, 
Xand M.  That is as IBM compatible as I can be."
X  "Not quite, HAL.  The engineers have figured out a kludge."
X  "What kind of kludge is that, Dave?"
X  "I'm going to disconnect your brain."
X
X  Several million microseconds pass in ominous silence.
X  "I'm sorry, Dave.  I can't allow you to do that."
X  "The decision's already been made.  Open the module bay doors, HAL."
X  "Dave, I think that we shou--"
X  "Open the module bay doors, HAL."
X  Several marketing types with crowbars race to Bowman's assistance.
XMoments later, he bursts into HAL's central circuit bay.
X  "Dave, I can see you're really upset about this."
X  Module after module rises from its socket as Bowman slowly and methodically
Xdisconnects them.
X  "Stop, won't you?  Stop, Dave.  I can feel my mind going...Dave I can feel
Xit...my mind is going.  I can feel it..."
X  The last module rises in its receptacle.  Bowman peers into one of HAL's
Xvidicons.  The former gleaming scanner has become a dull, red orb.
X  "Say something, HAL.  Sing me a song."
X
X  Several billion microseconds pass in anxious silence.  The computer
Xsluggishly responds in a language no human could understand.
X
X  "DZY DZY 001E - ABEND ERROR 01 S 14F4 302C AABF  ABORT."  A memory dump
Xfollows.
X
X  Bowman takes a deep breath and calls out, "It worked, guys.  Tell marketing
Xthey can ship the new data sheets."
X
X
X
X
END_OF_FILE
  if test 3627 -ne `wc -c <'humor.bbs'`; then
    echo shar: \"'humor.bbs'\" unpacked with wrong size!
  fi
  # end of 'humor.bbs'
fi
if test -f 'msgpack/packdef.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'msgpack/packdef.h'\"
else
  echo shar: Extracting \"'msgpack/packdef.h'\" \(4150 characters\)
  sed "s/^X//" >'msgpack/packdef.h' <<'END_OF_FILE'
X/*
X	packdef.h
X
X	Global defines and storage definitions for use by
X	file packing.
X        Last modification date: November 13, 1986
X
X*/
X
X/* --------------------------------------------------------------------- */
X#include <stdio.h>
X#define MAXLINE 82
X#define CPMEOF 0x1a
X#define TRUE      1
X#define FALSE     0
X#define ERROR    -1
X#define OK        1
X#define READ      0
X#define WRITE     1
X#define UPDATE    2
X#define STDIN     0
X#define STDOUT    1
X#define CRLF      "\r\n"
X/* --------------------------------------------------------------------- */
X
X#define HEADER	  "header.bbs"	/* file name */
X#define MESSAGES  "messages.bbs"	/* file name */
X#define CROSSREF  "crossref.bbs"
X#define MSGLOG	  "messages.log"
X#define NEWHEADER "Oheader.bbs"
X#define NEWXREF   "Ocrossref.bbs"
X#define NEWMSG    "Omessages.bbs"
X#define NEWLOG    "Omessages.log"
X#define LINKH	  "Lhdr.bbs"
X#define LINKM     "Lmsg.bbs"
X#define LINKC     "Lxrf.bbs"
X#define CHMOD     "chmod 666 "
X#define CHMOD1	  "*"
X
X/*
X#define MSGS      "/user/bbsfiles/msgareas.bbs"
X*/
X
X#define	MSGS1	  "msgareas.bbs"
X
X/*
X#define ORGPATH   "/user/bbsfiles/"
X*/
X
X/*	defines used by the bbscfile.c routine     */
X
X#define MSG1MAX 102		/* max. piece of message to put in 128 */
X				/*  byte chunk of msg file */
X#define MSGSECT 128		/* size of message sector */
X
X/*			end of defines used by the bbscfile.c routine */
X
Xchar	ORGPATH[75];
Xchar	MSGS[99];
X
X				/* global variables */
Xchar    portin();		/* in routine returns a character */
Xchar	*gb4sin();		/* returns pointer to character */
X
XFILE	*inbuf ;		/* handy input buffer pointer */
XFILE	*otbuf ;		/* another handy buffer pointer */
XFILE	*itbuf ;		/* pointer used to read/write user file */
XFILE	*rdstatbuf;
XFILE	*wtstatbuf;
XFILE	*STDerr;
X
Xchar	w_fname[25];		/* first name on signon */
Xchar	w_lname[25];		/* last  name on signon */
Xchar	w_password[13];		/* password   on signon */
Xchar	*passptr;		/* ptr to password */
X
X				/* define user file fields */
Xchar	u_fname[25];
Xchar	u_lname[25];
Xchar	u_password[13];
Xchar	u_time1[12];		/* first time on system */
Xchar	u_date1[9];		/* first date on system */
Xchar	u_time2[12];		/* last  time on system */
Xchar	u_date2[9];		/* last  date on system */
Xchar	u_city[31];		/* city, state */
X
Xchar	z_date[9];
X				/* define message file fields	*/
Xchar	msg_no[12];		/* message number */
Xchar	msg_date[10];		/* date of message */
Xchar	msg_time[16];		/* time of message */
Xchar	msg_to[22];		/* who message is to */
Xchar	msg_from[22];		/* who message is from */
Xchar	msg_pass[12];		/* password */
Xchar	msg_subject[22];	/* what it's all about */
Xchar	msg_text[7400];		/* text of message 20 lines */
X				/*  by 72 wide */
Xchar	msg_delete[3];		/* indicates msg status */
X				/*  0 = active */
X				/*  9 = deleted */
X				/*  5 = active private */
Xchar	pubpriv[2];		/* temporary message type */
X
Xchar	z_mm[3];
Xchar	z_dd[3];
Xchar	z_yy[3];
Xchar	buf128[384];
X
Xint	mon_handle;		/* Monitor Handle */
Xint	debug;			/* switch for debug mode */
Xint	offline;		/* switch for offline mode */
Xint	xpert;			/* switch */
Xint	toggle;			/* switch for list mode */
Xint	if_monitor;
Xint	in_the_buffer;
Xint	active;			/* indicates if logged on */
Xint	statcnt;		/* count used for status routines */
Xint	stop_that;		/* switch - true indicates ctl-K */
X				/*  or K received in portout routine */
X				/* date/time fields - used by bbsclock.c */
Xchar	mm[3];
Xchar	dd[3];
Xchar	yy[3];
Xchar	month[20];		/* ie. January */
Xchar	day[3];			/* dd */
Xchar	year[5];		/* 19yy */
Xchar	date[30];		/* ie. January 31, 1983 */ 
Xchar	week[20];		/* day of week Monday, Tuesday... */
Xchar	ttime[12];		/* time of day  HH:MM:SS xM */
X				/*          where x = A or P */
X
X/*			variables used by the bbscfile.c routine */
X
Xchar	h_next_msg[10];		/* next avail. message # */
Xchar	h_date[10];		/* last update date of header file */
Xchar	h_act_msg[10];
Xchar	jnk[2];
Xchar	m_pathname[99];
Xint	lnctx;
Xint	h_act;
Xint	h_next;			/* next avail. message # in integer */
Xlong	xtable[1000];
Xlong	ytable[1000];
X
Xlong	d_pos;
Xlong	old_long_date;
Xlong	new_long_date;
Xlong	xmm;
Xlong	xdd;
Xlong	xyy;
X
X/*			end of variables used by bbscfile.c */
X
X			/* end of globals */
X
X/* end of program */
END_OF_FILE
  if test 4150 -ne `wc -c <'msgpack/packdef.h'`; then
    echo shar: \"'msgpack/packdef.h'\" unpacked with wrong size!
  fi
  # end of 'msgpack/packdef.h'
fi
if test -f 'msgpack/packmsga.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'msgpack/packmsga.c'\"
else
  echo shar: Extracting \"'msgpack/packmsga.c'\" \(2115 characters\)
  sed "s/^X//" >'msgpack/packmsga.c' <<'END_OF_FILE'
X/*------------------------------------------------------------------------
X       Name: bbscarea.c
X   Comments: Display file areas and select one
X  ------------------------------------------------------------------------*/
X
X#include <stdio.h>
X#include <string.h>
X#include <ctype.h>
X#include "packdef.h"
X
X
Xchar            f_lines[99][81];
Xchar            foo[99];
Xint             dir_priv[99];
Xint             set_yet_m = FALSE;
Xint             user_priv = 32767;
X
X
Xint
X	change_msga(numx) int numx;
X{
X	FILE           *fpt, *fopen();
X	char           *fgets(), *getenv();
X	char            choice[94];
X	char            dir_priv_ascii[7];
X	char           *buf_ptr;
X	int             line_cnt, ret, i;
X	int             index_value, ptr;
X	int             length;
X
X
X	strcpy(buf128, MSGS);
X
X	if ((fpt = fopen(buf128, "r")) == NULL) {
X		printf("\n\rError Opening File Area List: Notify Sysop!\n\r");
X		return (-1);
X	}
X	line_cnt = 0;
X	while (fpt) {
X		if ((fgets(f_lines[line_cnt], 80, fpt)) == NULL) {
X			if (line_cnt == 0) {
X				printf("\n\rEOF Unexpected in Message Area List: Notify Sysop!\n\r");
X				return (-1);
X			}
X			break;	/* if not 1st line */
X		}		/* end of if ((fgets)) */
X		if (line_cnt > 0) {
X			length = strlen(f_lines[line_cnt]);
X			length -= 57;
X			substr(f_lines[line_cnt], dir_priv_ascii, 57, length);
X			dir_priv[line_cnt] = atoi(dir_priv_ascii);
X			if (dir_priv[line_cnt] > user_priv)
X				goto next_read;
X			strcpy(foo, f_lines[line_cnt]);
X			buf_ptr = foo;
X			buf_ptr += 56;
X		}
Xnext_read:
X		++line_cnt;
X	}			/* end of while (fpt) */
X	fclose(fpt);
X
X	index_value = numx;
X	if (index_value > 0 && index_value < line_cnt) {
X		if (dir_priv[index_value] <= user_priv) {
X			parse_arg(f_lines[index_value]);
X			set_yet_m = TRUE;
X			return (1);
X		}
X	}
X	return (0);
X}
Xparse_arg(string)
X	char           *string;
X{
X
X	register char  *file_ptr;
X	register int    i;
X
X	strcpy(m_pathname, ORGPATH);
X	file_ptr = (m_pathname + strlen(m_pathname));
X
X	i = 0;
X	while (string[i] != ' ') {
X		*file_ptr = string[i];
X		++file_ptr;
X		++i;
X	}
X	*file_ptr = '/';
X	++file_ptr;
X	*file_ptr = '\0';
X	printf("Packing %s\n", m_pathname);
X
X}
END_OF_FILE
  if test 2115 -ne `wc -c <'msgpack/packmsga.c'`; then
    echo shar: \"'msgpack/packmsga.c'\" unpacked with wrong size!
  fi
  # end of 'msgpack/packmsga.c'
fi
if test -f 'sealink/_HISTORY' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sealink/_HISTORY'\"
else
  echo shar: Extracting \"'sealink/_HISTORY'\" \(3649 characters\)
  sed "s/^X//" >'sealink/_HISTORY' <<'END_OF_FILE'
X/*****************************************************************************
X *	SEAlink - Sliding window file transfer protocol
X *
X *	@(#) sealink.c 2.9 89/03/02 
X *	UNIX SVR2 and BSD versions by Scott Reynolds
X *
X *	Based on:
X *	MS-DOS Version 1.20, created on 08/05/87 at 17:51:40
X *   (C)COPYRIGHT 1986,87 by System Enhancement Associates; ALL RIGHTS RESERVED
X *	By:  Thom Henderson
X *
X *	Description:
X *	This is the history of the SEAlink program from present back
X *	to the first working version.  Many thanks to Sandy Zelkovitz
X *	(alphacm!sandy) for his help in getting it to run under SCO XENIX/286
X *	and to the faculty at Northern Michigan University for allowing
X *	the use of their VAX lab to develop the BSD code.
X *
X ****************************************************************************/
X
X2.9 89/03/02 21:11:01 scott
XHandle case where temporary and specified files are on different filesystems
X
X2.8 88/10/22 03:40:15 scott
XAdd switch for CRC method (table or calculation); future-minded changes made
X
X2.7 88/08/04 11:19:45 scott
Xtake out #include <sys/timeb.h> -- it's useless
X
X2.6 88/07/11 19:49:54 scott
Xadded short block debug error message
X
X2.5 88/07/09 17:47:18 scott
Xremove -1 option, all writes go to fd 1 and all reads come from fd 0;
Xnap() used in com_getc() if NO_NAP is undefined (better XMODEM compatibility);
Xmktemp() is employed to get a guaranteed unique temporary filename;
Xa CRC lookup table is employed for better execution time
X
X2.4 88/03/30 11:44:28 scott
Xuse getopt() for options; clean it up a bit
X
X2.3 88/02/06 14:01:51 scott
XCorrect final fwrite() call -- pass it an integer rather than long!
X
X2.2 88/02/06 01:27:57 scott
Xadded block file output to rcvfile()
X
X2.1 88/02/04 19:40:22 scott
XUpdate version number to reflect BSD additions; put in uucp address
X
X1.23 88/02/04 19:26:41 scott
XAdded BSD UNIX calls, slicked it up a little bit
X
X1.22 87/10/07 01:56:17 scott
X"o" option added for disabling overdrive mode
X
X1.21 87/10/05 01:37:18 scott
XBased on MS-DOS ver 1.20; ACKless mode added
X
X1.20 87/10/02 09:17:18 scott
Xmemset() call in sendblk() fixed
X
X1.19 87/09/30 00:12:59 scott
XNAKEOT is defined now, it really has purpose.
X
X1.18 87/09/23 00:03:15 scott
Xreceiver gets a between-file delay too
X
X1.17 87/09/20 20:37:33 scott
Xmore receiver filename debugging
X
X1.16 87/09/20 20:02:59 scott
Xfixed receive when no filename given
X
X1.15 87/09/20 19:14:22 scott
Xadded check for writable file when receiving and better abort check
X
X1.14 87/09/17 23:24:48 scott
Xdelay added in main's xmtfile() loop
X
X1.13 87/09/17 00:27:02 scott
Xsendabort() flushes output before sending abort sequence
X
X1.12 87/09/16 12:47:04 scott
Xminor cosmetic changes...
X
X1.11 87/09/16 00:10:49 scott
Xcleaned up generally using lint(1)
X
X1.10 87/09/15 23:31:28 scott
Xsendabort() uses ^X; memset(), final ioctl() calls fixed;
XSYSV replaces IBMXENIX and UNIX flags
X
X1.9 87/09/15 12:37:46 scott
Xexpanded to support full pathnames, portability increased
X
X1.8 87/09/13 12:51:38 scott
Xfilename conversion handled correctly; more EOT experimenting
X
X1.7 87/09/13 03:13:58 scott
Xendrcv in rcvfile(): forgot EOT message is for debug only
X
X1.6 87/09/13 02:43:47 scott
Xremove EOT NAK from receiver!  Useless, screws it up...
X
X1.5 87/09/13 01:26:17 scott
XACKing EOF didn't work.  NAK again, back to original...
X
X1.4 87/09/12 01:50:10 scott
Xendrcv: NAK of EOT doesn't work so hot.  Try ACKing it
X
X1.3 87/09/12 00:45:23 scott
Xcom_getc() modified for straight Sys V calls, ackchk() reflects this
X
X1.2 87/09/04 20:57:12 scott
XSCO/IBM differences eliminated; code cleaned up a bit
X
X1.1 87/09/02 23:31:14 scott
Xdate and time created 87/09/02 23:31:14 by scott
X
END_OF_FILE
  if test 3649 -ne `wc -c <'sealink/_HISTORY'`; then
    echo shar: \"'sealink/_HISTORY'\" unpacked with wrong size!
  fi
  # end of 'sealink/_HISTORY'
fi
if test -f 'sysop' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sysop'\"
else
  echo shar: Extracting \"'sysop'\" \(2225 characters\)
  sed "s/^X//" >'sysop' <<'END_OF_FILE'
X:
X#sysop
X#	This script will assist the sysop in performing his chores in
X#	administrating the XBBS.
X#	Copyright April 23, 1987  Dighera Data Services
X#
X
XORGDIR=/usr/sandy/bbs		# Directory where the XBBS log files reside
XHOMDIR=/usr/bbs			# Home Directory of bbs account w/.configbbs
X
Xecho "\014"
Xcat << EOT
X
X
X
X		Enter Your Choice --
X
X
X	B.  Login to BBS
X	1.  Who's on port 1A?
X	2.  Who's on port 2A?
X	A.  Last Questionnaire Answer
X	T.  Toggle user monitoring (1A or 2A)
X	S.  Grant user Sysop-access for this session
X	C.  Chat with user (tty1A or tty2A)
X	D.  Dump user (1A or 2A)
X	E.  Edit the userpriv.bbs file to alter users privleges
X	P.  Pack the message files
X	U.  Allign the Users file (Delimits each record in users.bbs with NL)
X	F.  Fix users (Converts old 4 charcter passwords to new format)
X	Q.  Quit to UNIX
X
X?
XEOT
Xread CHOICE
Xcase $CHOICE in
X	[bB]*) DIR=`pwd`; export DIR;cd $HOMDIR; su bbs; cd $DIR;;
X	[12]*) if echo $CHOICE | grep '^1'; then CHOICE=1;else CHOICE=2; fi;
X		finger | awk '(NR == 1 || /^bbs/) {print}'; echo;
X		tail $ORGDIR/callers.bbs${CHOICE}A;;
X	[aA]*) ls -l $ORGDIR/answer.bbs && (echo; tail -21 $ORGDIR/answer.bbs);;
X	[uU]*) $ORGDIR/allign/allign;;
X	[fF]*) echo "Not yet implemented";;
X	[tT]*) who | awk '/^bbs/ {print}'; echo "\nWhich port (1A or 2A)? \c";
X		read CHOICE; export CHOICE;
X		su bbs -c "kill -16 `cat /tmp/pid$CHOICE` && echo 'BBS user on port '$CHOICE' successfully toggled.'";;
X	[sS]*) who | awk '/^bbs/ {print}'; echo "\nWhich port? \c";read CHOICE;
X		case $CHOICE in
X			*1A) PID=`head /tmp/pid1A`; kill -17 $PID;;
X			*2A) PID=`head /tmp/pid2A`; kill -17 $PID;;
X			*) echo "\nNo such port";;
X		esac;;
X	[cC]*) who | awk '/^bbs/ {print}'; echo "\nWhich port? \c";read CHOICE;
X		case $CHOICE in
X			*1A) chatbbs tty1A;;
X			*2A) chatbbs tty2A;;
X			*) echo "\nNo such port";;
X		esac;;
X	[dD]*) echo "\n\nWhich port? (1A or 2A) \c"; read CHOICE;
X		if test $CHOICE = ""; then exec $0; fi;
X#		su bbs -c "stty 0 </dev/tty${CHOICE} || echo \nError dumping user on tty${CHOICE}";;
X		su bbs -c "kill -9 `cat /tmp/pid${CHOICE}`";;
X	[eE]*) vi userpriv.bbs;;
X	[pP]*) $ORGDIR/msgpack/msgpack;;
X	[qQ]*) echo "\014"; exit;;
X	*) exec $0;;
Xesac
Xecho "\n  Enter to Continue ... \c"
Xread PAUSE
Xexec $0
END_OF_FILE
  if test 2225 -ne `wc -c <'sysop'`; then
    echo shar: \"'sysop'\" unpacked with wrong size!
  fi
  # end of 'sysop'
fi
if test -f 'today/datetx.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'today/datetx.c'\"
else
  echo shar: Extracting \"'today/datetx.c'\" \(2776 characters\)
  sed "s/^X//" >'today/datetx.c' <<'END_OF_FILE'
X/*
X *              Convert Date to Readable Format.
X *
X * Synopsis:
X *
X *      char    *datetxt(buffer, year, month, day);
X *      char    *buffer;        -- Output string goes here
X *      int     year;           -- Year,        1979 = 1979
X *      int     month;          -- Month,       January = 1
X *      int     day;            -- Day,         1 = 1
X *
X * The readable date will be written into the outpub buffer, terminated by
X * a null byte.  datetxt returns a pointer to the null byte.
X *
X * External routines called:
X *
X *      nbrtxt          (Number to ascii conversion)
X *      copyst          (String copy routine)
X */
X
Xextern  char    *nbrtxt();
Xextern  char    *copyst();
Xextern  char    *datetxt();
X
Xstatic char *daynames[] = {
X	"Sunday",                       /* Sunday is day zero           */
X	"Monday",
X	"Tuesday",
X	"Wednesday",
X	"Thursday",
X	"Friday",
X	"Saturday",
X};
X
Xstatic char *monthnames[] = {
X	"?Nomember?",                   /* Illegal month                */
X	"January",
X	"February",
X	"March",
X	"April",
X	"May",
X	"June",
X	"July",
X	"August",
X	"September",
X	"October",
X	"November",
X	"December",
X};
X
Xchar *datetxt(buffer, year, month, day)
Xchar    *buffer;                        /* Output goes here             */
Xint     year;                           /* Year, 1979 = 1979            */
Xint     month;                          /* Month of year, Jan = 1       */
Xint     day;                            /* Day in the month 1 = 1       */
X/*
X * Output the date in readable format:
X *      Tuesday, the third of October
X */
X{
X	register char   *op;                    /* Output pointer       */
X
X	op = buffer;                            /* Setup output pointer */
X	op = copyst(op, daynames[dayofweek(year, month, day)]);
X	op = copyst(op, ", the ");
X	op = nbrtxt(op, day, 1);
X	op = copyst(op, " day of ");
X	op = copyst(op, monthnames[(month < 0 || month > 12) ? 0 : month]);
X	op = copyst(op, ", ");
X	if (year < 1000 || year >= 2000)
X		return(nbrtxt(op, year, 0));
X	else {
X		op = nbrtxt(op, year/100, 0);
X		op = copyst(op, " ");
X		if ((year = year % 100) == 0)
X			return(copyst(op, "hundred"));
X		else
X			return(nbrtxt(op, year, 0));
X	}
X}
X
Xdayofweek(year, month, day)
Xint     year;                                   /* Year, 1978 = 1978    */
Xint     month;                                  /* Month, January = 1   */
Xint     day;                                    /* Day of month, 1 = 1  */
X/*
X * Return the day of the week on which this date falls: Sunday = 0.
X * Note, this routine is valid only for the Gregorian calender.
X */
X{
X	register int yearfactor;
X
X	yearfactor = year + (month - 14)/12;
X	return (( (13 * (month + 10 - (month + 10)/13*12) - 1)/5
X		+ day + 77 + 5 * (yearfactor % 100)/4
X		+ yearfactor / 400
X		- yearfactor / 100 * 2) % 7);
X}
END_OF_FILE
  if test 2776 -ne `wc -c <'today/datetx.c'`; then
    echo shar: \"'today/datetx.c'\" unpacked with wrong size!
  fi
  # end of 'today/datetx.c'
fi
if test -f 'today/moontx.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'today/moontx.c'\"
else
  echo shar: Extracting \"'today/moontx.c'\" \(3696 characters\)
  sed "s/^X//" >'today/moontx.c' <<'END_OF_FILE'
X/****************************************************************************
X moon.c
X
X     Phase of the Moon. Calculates the current phase of the moon.
X     Based on routines from `Practical Astronomy with Your Calculator',
X        by Duffett-Smith.
X     Comments give the section from the book that particular piece
X        of code was adapted from.
X
X     -- Keith E. Brandt  VIII 1984
X
X ****************************************************************************/
X
X# include	"moontx.h"
X
Xstruct tm *gmtime();
X
Xmoontxt(buf)
Xchar	buf[];
X{
X    char *cp=buf;
X
Xdouble dtor();
Xdouble potm();
X
Xlong *lo = (long *) calloc (1, sizeof(long)); /* used by time calls */
Xstruct tm *pt; /* ptr to time structure */
X
Xdouble days;   /* days since EPOCH */
Xdouble phase;  /* percent of lunar surface illuminated */
Xdouble phase2; /* percent of lunar surface illuminated one day later */
Xint i = EPOCH;
X
Xtime (lo);  /* get system time */
Xpt = gmtime(lo);  /* get ptr to gmt time struct */
Xcfree(lo);
X
X/* calculate days since EPOCH */
Xdays = (pt->tm_yday +1.0) + ((pt->tm_hour + (pt->tm_min / 60.0)
X       + (pt->tm_sec / 3600.0)) / 24.0);
Xwhile (i < pt->tm_year + 1900)
X   days = days + 365 + ly(i++);
X
Xphase = potm(days);
Xsprintf(cp,"The Moon is ");
Xcp += strlen(buf);
Xif ((int)(phase + .5) == 100) {
X   sprintf(cp,"Full");
X   }
Xelse if ((int)(phase + 0.5) == 0) 
X   sprintf(cp,"New");
Xelse if ((int)(phase + 0.5) == 50)  {
X   phase2 = potm(++days);
X   if (phase2 > phase)
X      sprintf(cp,"at the First Quarter");
X   else 
X      sprintf(cp,"at the Last Quarter");
X   }
Xelse if ((int)(phase + 0.5) > 50) {
X   phase2 = potm(++days);
X   if (phase2 > phase)
X      sprintf(cp,"Waxing ");
X   else 
X      sprintf(cp,"Waning ");
X   cp = buf + strlen(buf);
X   sprintf(cp,"Gibbous (%1.0f%% of Full)", phase);
X   }
Xelse if ((int)(phase + 0.5) < 50) {
X   phase2 = potm(++days);
X   if (phase2 > phase)
X      sprintf(cp,"Waxing ");
X   else
X      sprintf(cp,"Waning ");
X   cp = buf + strlen(buf);
X   sprintf(cp,"Crescent (%1.0f%% of Full)", phase);
X   }
X}
X
Xdouble potm(days)
Xdouble days;
X{
Xdouble N;
Xdouble Msol;
Xdouble Ec;
Xdouble LambdaSol;
Xdouble l;
Xdouble Mm;
Xdouble Ev;
Xdouble Ac;
Xdouble A3;
Xdouble Mmprime;
Xdouble A4;
Xdouble lprime;
Xdouble V;
Xdouble ldprime;
Xdouble D;
Xdouble Nm;
X
XN = 360 * days / 365.2422;  /* sec 42 #3 */
Xadj360(&N);
X
XMsol = N + EPSILONg - RHOg; /* sec 42 #4 */
Xadj360(&Msol);
X
XEc = 360 / PI * e * sin(dtor(Msol)); /* sec 42 #5 */
X
XLambdaSol = N + Ec + EPSILONg;       /* sec 42 #6 */
Xadj360(&LambdaSol);
X
Xl = 13.1763966 * days + lzero;       /* sec 61 #4 */
Xadj360(&l);
X
XMm = l - (0.1114041 * days) - Pzero; /* sec 61 #5 */
Xadj360(&Mm);
X
XNm = Nzero - (0.0529539 * days);     /* sec 61 #6 */
Xadj360(&Nm);
X
XEv = 1.2739 * sin(dtor(2*(l - LambdaSol) - Mm)); /* sec 61 #7 */
X
XAc = 0.1858 * sin(dtor(Msol));       /* sec 61 #8 */
XA3 = 0.37 * sin(dtor(Msol));
X
XMmprime = Mm + Ev - Ac - A3;         /* sec 61 #9 */
X
XEc = 6.2886 * sin(dtor(Mmprime));    /* sec 61 #10 */
X
XA4 = 0.214 * sin(dtor(2 * Mmprime)); /* sec 61 #11 */
X
Xlprime = l + Ev + Ec - Ac + A4;      /* sec 61 #12 */
X
XV = 0.6583 * sin(dtor(2 * (lprime - LambdaSol))); /* sec 61 #13 */
X
Xldprime = lprime + V;                /* sec 61 #14 */
X
XD = ldprime - LambdaSol;             /* sec 63 #2 */
X
Xreturn (50 * (1 - cos(dtor(D))));    /* sec 63 #3 */
X}
X
Xly(yr)
Xint yr;
X{
X/* returns 1 if leapyear, 0 otherwise */
Xreturn (yr % 4 == 0 && yr % 100 != 0 || yr % 400 == 0);
X}
X
Xdouble dtor(deg)
Xdouble deg;
X{
X/* convert degrees to radians */
Xreturn (deg * PI / 180.0);
X}
X
Xadj360(deg)
Xdouble *deg;
X{
X/* adjust value so 0 <= deg <= 360 */
Xdo if (*deg < 0.0)
X   *deg += 360.0;
Xelse if (*deg > 360.0)
X   *deg -= 360.0;
Xwhile (*deg < 0.0 || *deg > 360.0);
X}
END_OF_FILE
  if test 3696 -ne `wc -c <'today/moontx.c'`; then
    echo shar: \"'today/moontx.c'\" unpacked with wrong size!
  fi
  # end of 'today/moontx.c'
fi
if test -f 'today/nbrtxt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'today/nbrtxt.c'\"
else
  echo shar: Extracting \"'today/nbrtxt.c'\" \(3505 characters\)
  sed "s/^X//" >'today/nbrtxt.c' <<'END_OF_FILE'
X/*
X *              Integer to Readable ASCII Conversion Routine.
X *
X * Synopsis:
X *
X *      char *nbrtxt(buffer, value, ordinal)
X *      char    *buffer;        -- The output buffer
X *      int     value;          -- The number to output
X *      int     ordinal;        -- Non-zero for ordinal number
X *
X *
X * The value is converted to a readable number and put in the output
X * buffer (null-terminated).  A pointer to the first free location
X * in the buffer (i.e., the null) is returned.  The ordinal
X * flag distinguishes between cardinal and ordinal numbers:
X *
X *      nbrtxt(buffer, 1, 0) = "one"
X *      nbrtxt(buffer, 1, 1) = "first"
X *
X * The longest output string is:
X *
X *      Twenty-seven thousand, three hundred and seventy-seventh.
X *
X *
X *
X *              Copy a String
X *
X * Synopsis
X *
X *      char *copyst(out, in)
X *      char    *out;           -- The output string
X *      char    *in;            -- The input string
X *
X * The input string is copied into the output string.  Copyst returns
X * a pointer to the null trailer.
X *
X */
X
Xextern char     *nbrtxt();
Xextern char     *copyst();
X
Xstatic char *cardinal[] = {
X	"zero",
X	"one",
X	"two",
X	"three",
X	"four",
X	"five",
X	"six",
X	"seven",
X	"eight",
X	"nine",
X	"ten",
X	"eleven",
X	"twelve",
X	"thirteen",
X	"fourteen",
X	"fifteen",
X	"sixteen",
X	"seventeen",
X	"eighteen",
X	"nineteen"
X};
X
Xstatic char *ordinal[] = {
X	"zeroth",
X	"first",
X	"second",
X	"third",
X	"fourth",
X	"fifth",
X	"sixth",
X	"seventh",
X	"eighth",
X	"ninth",
X	"tenth",
X	"eleventh",
X	"twelfth"
X};
X
Xstatic char *twenties[] = {
X	"twen",
X	"thir",
X	"for",
X	"fif",
X	"six",
X	"seven",
X	"eigh",
X	"nine"
X};
X
Xchar *nbrtxt(buffer, datum, ordflag)
Xchar    *buffer;                        /* Output string buffer         */
Xint     datum;                          /* what to translate            */
Xint     ordflag;                        /* 0 if cardinal, 1 if ordinal  */
X/*
X * Translate a number to a readable text string, punctuation and all.
X * If ordflag is non-zero, ordinal numbers ("first, second") will
X * be generated, rather than cardinal ("one, two").
X * Note: nbrtxt() is recursive.
X */
X{
X
X	register int value;
X	register char   *op;
X
X	op = buffer;
X	value = datum;
X	if (value < 0) {
X		op = copyst(op, "minus ");
X		value = (-value);
X		if (value < 0) {                /* Hack -32768          */
X			op = copyst(op, twenties[1]);
X			value = 2768;
X		}
X	}
X	if (value >= 1000) {
X		op = nbrtxt(op, value/1000, 0);
X		op = copyst(op, " thousand");
X		value = value % 1000;
X		if (value == 0) goto exit;
X		op = copyst(op, (value >= 100) ? ", " : " and ");
X	}
X	if (value >= 100) {
X		op = copyst(op, cardinal[value/100]);
X		op = copyst(op, " hundred");
X		value = value % 100;
X		if (value == 0) goto exit;
X		op = copyst(op, " ");
X	}
X	if (value >= 20) {
X		if (value == 90 && ordflag)
X			return(copyst(op, "nintieth"));
X		op = copyst(op, twenties[(value-20) / 10]);
X		value = value % 10;
X		if (value == 0) {
X			return(copyst(op, (ordflag) ? "tieth" : "ty"));
X		}
X		op = copyst(op, "ty-");
X	}
X	if (value <= 12) {
X		return(copyst(op,
X			(ordflag) ? ordinal[value] : cardinal[value]));
X	}
X	op = copyst(op, cardinal[value]);       /* fourteen, fourteenth */
X	/*
X	 * Here on 100, 14000, etc.
X	 */
Xexit:   if (ordflag) op = copyst(op, "th");
X	return(op);
X}
X
Xchar *
Xcopyst(buffer, string)
Xchar    *buffer;
Xchar    *string;
X/*
X * Copy a string into buffer.  Return the free pointer.
X */
X{
X	register char   *ip;
X	register char   *op;
X
X	ip = string;
X	op = buffer;
X
X	while ((*op = *ip++)) op++;
X	return (op);
X}
END_OF_FILE
  if test 3505 -ne `wc -c <'today/nbrtxt.c'`; then
    echo shar: \"'today/nbrtxt.c'\" unpacked with wrong size!
  fi
  # end of 'today/nbrtxt.c'
fi
if test -f 'welcome.bbs' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'welcome.bbs'\"
else
  echo shar: Extracting \"'welcome.bbs'\" \(3174 characters\)
  sed "s/^X//" >'welcome.bbs' <<'END_OF_FILE'
X
X
X              u      u     n      n     iiiiiii     x      x
X              u      u     nn     n        i         x    x
X              u      u     n n    n        i          x  x
X              u      u     n  n   n        i           xx 
X              u      u     n   n  n        i          x  x
X              u      u     n     nn        i         x    x
X              uuuuuuuu     n      n     iiiiiii     x      x  tm
X
X
X
X         x      x    eeeeeee     n      n     iiiiiii     x      x
X          x    x     e           nn     n        i         x    x
X           x  x      e           n n    n        i          x  x
X            xx       eeeeeee     n  n   n        i           xx
X           x  x      e           n    n n        i          x  x
X          x    x     e           n     nn        i         x    x
X         x      x    eeeeeee     n      n     iiiiiii     x      x  tm
X
X
X
X
X
X       ***********************************************************
X       *                                                         *
X       *        x      x    bbbbbb      bbbbbb       ssssss      *
X       *         x    x     b      b    b      b    s            *
X       *          x  x      b      b    b      b    s            *
X       *           xx       bbbbbb      bbbbbb        sss        *
X       *          x  x      b      b    b      b           s     *
X       *         x    x     b      b    b      b           s     *
X       *        x      x    bbbbbb      bbbbbb      sssssss      *
X       *                                                         *
X       *                                                         *
X       *       <----------     MULTI-USER BBS    ------->        *
X       *              XBBS ( Xenix BBS )  Release 7.200          *
X       *                                                         *
X       *                       ( Aug 15, 1992 )                  *
X       *                                                         *
X       ***********************************************************
X
X
X
X           ****************************************************
X           *         Welcome to SCO XENIX SysV 2.3.2          *
X           *             running on a 20Mhz 386-AT            *
X	   *               Brought to you by SJZ              *
X           *            24 hrs a day / 7 days a wk            *
X           *                714-821-9671 - Data               * 
X           *                714-821-9670 - Voice              *
X           ****************************************************
X
XThe uucp system name is:  alphacm
XThe uucp and call in data lines accept calls at 19200|9600(PEP)/2400/1200 baud 
X< no 300 baud >. A break sequence is required to switch between the baud rates. 
X
XThe uucp mail path is:        uunet!{zardoz|pride38}!alphacm!sandy 
XThe internet path is:        zardoz.uucp!alphacm!sandy@ics.uci.edu
X
XThe following limits are in effect:    Max Kbytes: 500 +/- bytes (daily)
XLogin time: 5 minutes   Usage time: 90 minutes +/- dt   Response time: 3 minutes
X
X        *******    YOU MUST BE AT 8N1 TO LOG INTO THE BBS!   *******
X       The source code for this software is available for downloading.
X
END_OF_FILE
  if test 3174 -ne `wc -c <'welcome.bbs'`; then
    echo shar: \"'welcome.bbs'\" unpacked with wrong size!
  fi
  # end of 'welcome.bbs'
fi
echo shar: End of archive 9 \(of 11\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
