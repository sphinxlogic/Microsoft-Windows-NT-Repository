Newsgroups: comp.sources.misc
From: <dfs@doe.carleton.ca> (David F. Skoll)
Subject: v36i001:  remind - A replacement for calendar, Patch04a/3
Message-ID: <csm-v36i001=remind.220158@sparky.IMD.Sterling.COM>
X-Md4-Signature: b333423c3f42efa2e85ddd6c57384b9d
Date: Mon, 8 Mar 1993 04:02:59 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: <dfs@doe.carleton.ca> (David F. Skoll)
Posting-number: Volume 36, Issue 1
Archive-name: remind/patch04a
Environment: UNIX, MS-DOS
Patch-To: remind: Volume 33, Issue 58-69

This is patch 4 for version 3.0 of Remind.

Remind is a sophisticated calendar/alarm program, which runs under
MS-DOS, UNIX and OS/2.

Patch 4 contains the following major upgrades:

- Reminders can be sorted by date and time in the normal mode of operation

- Remind now supports English, German, Dutch and Finnish messages

- The SCANFROM clause was added to make "safe moveable OMITs" possible.
  Read the man page.

Availability:

You can get Remind via ftp from ftp.doe.carleton.ca (134.117.9.35)
in the directory "pub/remind-3.0".

The files are:

man-ps.tar.Z		Man pages in PostScript
man-txt.tar.Z		Man pages in formatted ASCII
msdos-exe.tar.Z		MS-DOS executables (remind.exe and rem2ps.exe)
patch01.tar.Z		Patch: 03.00.00 to 03.00.01
patch02.tar.Z		Patch: 03.00.01 to 03.00.02
patch03.tar.Z		Patch: 03.00.02 to 03.00.03
patch04.tar.Z		Patch: 03.00.03 to 03.00.04
remind-3.0.4.tar.Z	Entire 03.00.04 source distribution.

David F. Skoll
--------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  dutch.h patch.04.A
# Wrapped by kent@sparky on Sun Mar  7 21:51:01 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 3)."'
if test -f 'dutch.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dutch.h'\"
else
  echo shar: Extracting \"'dutch.h'\" \(3242 characters\)
  sed "s/^X//" >'dutch.h' <<'END_OF_FILE'
X/***************************************************************/
X/*                                                             */
X/*  DUTCH.H                                                    */
X/*                                                             */
X/*  Support for the DUTCH language.                            */
X/*                                                             */
X/*  Author: Willem Kasdorp                                     */
X/*                                                             */
X/*  Modified slightly by David Skoll                           */
X/*                                                             */
X/*  This file is part of REMIND.                               */
X/*  Copyright (C) 1992, 1993 by David F. Skoll.                */
X/*                                                             */
X/***************************************************************/
X
X/* The very first define in a language support file must be L_LANGNAME: */
X#define L_LANGNAME "Dutch"
X
X/* Day names */
X#define L_SUNDAY "Zondag"
X#define L_MONDAY "Maandag"
X#define L_TUESDAY "Dinsdag"
X#define L_WEDNESDAY "Woensdag"
X#define L_THURSDAY "Donderdag"
X#define L_FRIDAY "Vrijdag"
X#define L_SATURDAY "Zaterdag"
X
X/* Day initials - first letter only */
X#define L_DAYINIT "ZMDWDVZ"
X
X/* Month names */
X#define L_JAN "Januari"
X#define L_FEB "Februari"
X#define L_MAR "Maart"
X#define L_APR "April"
X#define L_MAY "Mei"
X#define L_JUN "Juni"
X#define L_JUL "Juli"
X#define L_AUG "Augustus"
X#define L_SEP "September"
X#define L_OCT "October"
X#define L_NOV "November"
X#define L_DEC "December"
X
X/* Today and tomorrow */
X#define L_TODAY "vandaag"
X#define L_TOMORROW "morgen"
X
X/* The default banner */
X#define L_BANNER "Herinneringen voor %w, %d%s %m, %y%o:"
X
X/* "am" and "pm" */
X#define L_AM "am"
X#define L_PM "pm"
X
X/*** The following are only used in dosubst.c ***/
X#ifdef L_IN_DOSUBST
X
X/* Ago and from now */
X#define L_AGO "geleden"
X#define L_FROMNOW "vanaf nu"
X
X/* "in %d days' time" */
X#define L_INXDAYS "over %d dagen"
X
X/* "on" as in "on date..." */
X#define L_ON "op"
X
X/* Pluralizing - this is a problem for many languages and may require
X   a more drastic fix. (Indeed..., wkasdo) */
X#define L_PLURAL "s"
X
X/* Minutes, hours, at, etc */
X#define L_NOW "nu"
X#define L_AT "op"
X#define L_MINUTE "minuut"
X#define L_HOUR "uur"
X#define L_IS "is"
X#define L_WAS "was"
X#define L_AND "en"
X/* What to add to make "hour" plural (should result in uren, not uuren (wkasdo) */
X#define L_HPLU "en"  
X/* What to add to make "minute" plural (should be minuten, not minuuten) */
X#define L_MPLU "en"
X
X/* Define any overrides here, such as L_ORDINAL_OVERRIDE, L_A_OVER, etc.
X   See the file dosubst.c for more info. */
X
X/* Willem - I fixed the uren/uuren problem here */
X#define L_1_OVER \
Xif (tdiff == 0) \
X   sprintf(s, L_NOW); \
Xelse if (hdiff == 0) \
X   sprintf(s, "%d %s %s", mdiff, \
X      (mdiff == 1 ? "minuut" : "minuten"), when); \
Xelse if (mdiff == 0) \
X   sprintf(s, "%d %s %s", hdiff, \
X      (mdiff == 1 ? "uur" : "uren"), when); \
X   else sprintf(s, "%d %s %s %d %s %s", hdiff, \
X      (hdiff == 1 ? "uur" : "uren"), \
X      L_AND, mdiff, \
X      (mdiff == 1 ? "minuut" : "minuten"), \
X       when);
X
X#endif /* L_IN_DOSUBST */
X
END_OF_FILE
  if test 3242 -ne `wc -c <'dutch.h'`; then
    echo shar: \"'dutch.h'\" unpacked with wrong size!
  fi
  # end of 'dutch.h'
fi
if test -f 'patch.04.A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patch.04.A'\"
else
  echo shar: Extracting \"'patch.04.A'\" \(53218 characters\)
  sed "s/^X//" >'patch.04.A' <<'END_OF_FILE'
XPrereq: "03.00.03"
X*** ../patch3/version.h	Tue Feb  2 14:36:05 1993
X--- ./version.h	Mon Feb 15 13:24:00 1993
X***************
X*** 9,12 ****
X  /*                                                             */
X  /***************************************************************/
X  
X! #define VERSION "03.00.03"
X--- 9,12 ----
X  /*                                                             */
X  /***************************************************************/
X  
X! #define VERSION "03.00.04"
X*** ../patch3/COPYRIGHT	Fri Jan  8 13:26:53 1993
X--- ./COPYRIGHT	Wed Mar  3 17:13:09 1993
X***************
X*** 1,29 ****
X  THE REMIND COPYRIGHT
X  
X! REMIND refers to the entire set of files and documentation in the
X  REMIND package.
X  
X! REMIND is Copyright 1990, 1991, 1992, 1993 by David Skoll, except for
X  the file remind-all.sh, which is Copyright 1990 by Bill Aten.
X  
X! You may use REMIND for free, and may freely distribute it, providing
X  you do not charge the recipients to whom you distribute REMIND.
X  
X! You may modify REMIND.  However, you must clearly indicate such
X  modifications when you distribute REMIND, and must tell the recipients
X  of the modified version that it is modified.  Place that notice in the
X  WHATSNEW.xx file.
X  
X! You may incorporate parts of REMIND into your own programs, providing
X  you do not sell these programs.  You must clearly indicate that the
X  parts of REMIND you have incorporated are Copyright 1990, 1991, 1992,
X! 1993 by David Skoll.
X  
X! I will attempt to support REMIND as much as possible.  However, you
X  use it at your own risk.  I am not responsible for any damages caused
X  by the use or misuse of REMIND.
X  
X! If you wish to contribute ideas or money to help the production of
X  software like REMIND, you can reply to the address shown at the end of
X  this file.  Note that you are under no obligation to send me money.
X  If you don't donate, you have full rights to use REMIND just as if you
X--- 1,40 ----
X  THE REMIND COPYRIGHT
X  
X! 1. REMIND refers to the entire set of files and documentation in the
X  REMIND package.
X  
X! 2. REMIND is Copyright 1990, 1991, 1992, 1993 by David Skoll, except for
X  the file remind-all.sh, which is Copyright 1990 by Bill Aten.
X  
X! 3. You may use REMIND for free, and may freely distribute it, providing
X  you do not charge the recipients to whom you distribute REMIND.
X  
X! 4. This means that if you distribute REMIND:
X! 
X! - You may not charge more than cost for distribution media.
X! - If you run a BBS or network service, you cannot charge more than
X!   the regular access fee for REMIND.  That is, REMIND must be accessible
X!   at the basic BBS access rate, with no surcharge.
X! - You may not charge users support fees for REMIND.
X! - No other fees may be levied for REMIND.
X! - You cannot use REMIND to solicit donations.
X! 
X! 5. You may modify REMIND.  However, you must clearly indicate such
X  modifications when you distribute REMIND, and must tell the recipients
X  of the modified version that it is modified.  Place that notice in the
X  WHATSNEW.xx file.
X  
X! 6. You may incorporate parts of REMIND into your own programs, providing
X  you do not sell these programs.  You must clearly indicate that the
X  parts of REMIND you have incorporated are Copyright 1990, 1991, 1992,
X! 1993 by David Skoll.  These programs can be distributed according to
X! the terms of paragraphs 3 and 4.
X  
X! 7. I will attempt to support REMIND as much as possible.  However, you
X  use it at your own risk.  I am not responsible for any damages caused
X  by the use or misuse of REMIND.
X  
X! 8. If you wish to contribute ideas or money to help the production of
X  software like REMIND, you can reply to the address shown at the end of
X  this file.  Note that you are under no obligation to send me money.
X  If you don't donate, you have full rights to use REMIND just as if you
X***************
X*** 32,37 ****
X--- 43,52 ----
X  of software like REMIND.  Should you wish to donate, the suggested
X  amount is $18.00 (Canadian)
X  
X+ If you wish to incorporate Remind into a commercial product, or to
X+ charge support fees for products incorporating Remind, contact
X+ me for licensing arrangements.
X+ 
X  ACKNOWLEDGEMENTS:
X  
X  I would like to thank the following people:
X***************
X*** 52,57 ****
X--- 67,83 ----
X  Dave Wolfe <dwolfe@pffft.sps.mot.com> and Raphael Manfredi
X  <ram@eiffel.com> for noticing bugs and sending me fixes.
X  
X+ Dave Rickel and George M. Sipe for sample reminders and holidays.
X+ 
X+ Michael Salmon for ISO encoding of PostScript output.
X+ 
X+ Darrel Hankerson for helping me provide some OS/2 support.  Sorry
X+ it's not complete, Darrel!
X+ 
X+ Phillipp Slusallek for suggesting the -k option.
X+ 
X+ All of the language translators whose names are listed in lang.h
X+ 
X  Timo Salmi, Keith Petersen, Bill Davidsen and Kent Landfield for
X  maintaining the uwasa and SIMTEL archives, and comp.binaries.ibm.pc
X  and comp.sources.misc in the face of a flurry of updates to REMIND.
X***************
X*** 64,72 ****
X  
X  --
X  David F. Skoll <dfs@doe.carleton.ca>
X! 4-317 LeBreton Street South
X! Ottawa, Ontario K1S 4L4
X  CANADA
X  
X! Tel. (613) 567-3662
X  
X--- 90,98 ----
X  
X  --
X  David F. Skoll <dfs@doe.carleton.ca>
X! 986 Eiffel Avenue
X! Ottawa, Ontario K2C 0J2
X  CANADA
X  
X! Tel. (613) 225-8687
X  
X*** ../patch3/MANIFEST.DOS	Mon Jan 25 15:40:01 1993
X--- ./MANIFEST.DOS	Mon Mar  1 16:52:01 1993
X***************
X*** 4,14 ****
X--- 4,16 ----
X  defs.rem
X  dorem.c
X  dosubst.c
X+ dutch.h
X  english.h
X  err.h
X  expr.c
X  expr.h
X  files.c
X+ finnish.h
X  funcs.c
X  german.h
X  globals.c
X***************
X*** 41,46 ****
X--- 43,49 ----
X  remind-a.sh
X  remind.1
X  remind.def
X+ sort.c
X  test-rem
X  test.cmp
X  test.rem
X*** ../patch3/MANIFEST.UNX	Mon Feb  8 14:26:43 1993
X--- ./MANIFEST.UNX	Mon Mar  1 16:51:53 1993
X***************
X*** 11,21 ****
X--- 11,23 ----
X  defs.rem
X  dorem.c
X  dosubst.c
X+ dutch.h
X  english.h
X  err.h
X  expr.c
X  expr.h
X  files.c
X+ finnish.h
X  funcs.c
X  german.h
X  globals.c
X***************
X*** 42,47 ****
X--- 44,50 ----
X  remind-all.sh
X  remind.1
X  remind.def
X+ sort.c
X  test-rem
X  test.cmp
X  test.rem
X*** ../patch3/Makefile	Tue Feb  2 14:36:58 1993
X--- ./Makefile	Tue Mar  2 11:03:25 1993
X***************
X*** 13,21 ****
X  # Uncomment the next line if you want to use gcc instead of default compiler
X  CC= gcc
X  
X! # Put any additional flags for the C compiler here
X  CFLAGS= -O -ansi
X  CDEFS=
X  
X  #### INSTALLATION LOCATIONS ####
X  # Note that I use 'cp' rather than 'install' for improved portability.
X--- 13,22 ----
X  # Uncomment the next line if you want to use gcc instead of default compiler
X  CC= gcc
X  
X! # Put any additional flags for the C compiler or linker here
X  CFLAGS= -O -ansi
X  CDEFS=
X+ LDFLAGS=
X  
X  #### INSTALLATION LOCATIONS ####
X  # Note that I use 'cp' rather than 'install' for improved portability.
X***************
X*** 45,62 ****
X  # YOU SHOULDN'T EDIT ANYTHING BELOW HERE.  You may want to change some things
X  # in config.h; then, you should be able to type 'make'.
X  #-----------------------------------------------------------------------------
X! VERSION= 03.00.03
X  
X! HDRS= config.h err.h expr.h globals.h protos.h types.h version.h lang.h
X  STDHDRS= config.h types.h protos.h globals.h err.h lang.h
X  SRCS= calendar.c dorem.c dosubst.c expr.c files.c funcs.c globals.c init.c \
X! main.c omit.c queue.c token.c trigger.c userfns.c utils.c var.c
X  
X  MANIFEST= README.UNIX README.DOS COPYRIGHT $(HDRS) $(SRCS) Makefile rem rem.1 \
X  remind.1 remind-all.csh remind-all.sh test.rem test-rem test.cmp makefile.tc \
X  makefile.msc lnk.msc lnk.tc MANIFEST.UNX MANIFEST.DOS WHATSNEW.30 kall kall.1 \
X  defs.rem README.OS2 makefile.os2 rem2ps.c rem2ps.h remind.def rem2ps.1 \
X! lang.h english.h german.h tstlang.rem
X  
X  OBJS= $(SRCS:.c=.o)
X  
X--- 46,66 ----
X  # YOU SHOULDN'T EDIT ANYTHING BELOW HERE.  You may want to change some things
X  # in config.h; then, you should be able to type 'make'.
X  #-----------------------------------------------------------------------------
X! VERSION= 03.00.04
X  
X! HDRS= config.h err.h expr.h globals.h protos.h types.h version.h \
X! lang.h english.h german.h dutch.h finnish.h
X! 
X  STDHDRS= config.h types.h protos.h globals.h err.h lang.h
X+ 
X  SRCS= calendar.c dorem.c dosubst.c expr.c files.c funcs.c globals.c init.c \
X! main.c omit.c sort.c queue.c token.c trigger.c userfns.c utils.c var.c
X  
X  MANIFEST= README.UNIX README.DOS COPYRIGHT $(HDRS) $(SRCS) Makefile rem rem.1 \
X  remind.1 remind-all.csh remind-all.sh test.rem test-rem test.cmp makefile.tc \
X  makefile.msc lnk.msc lnk.tc MANIFEST.UNX MANIFEST.DOS WHATSNEW.30 kall kall.1 \
X  defs.rem README.OS2 makefile.os2 rem2ps.c rem2ps.h remind.def rem2ps.1 \
X! tstlang.rem
X  
X  OBJS= $(SRCS:.c=.o)
X  
X***************
X*** 66,75 ****
X  	$(CC) $(UNIX) $(SYSV) -c -o $*.o $(CFLAGS) $(CDEFS) $*.c
X  
X  rem2ps: rem2ps.o
X! 	$(CC) -o rem2ps rem2ps.o
X  
X  remind: $(OBJS)
X! 	$(CC) -o remind $(OBJS)
X  
X  clean:
X  	rm -f *.o *~
X--- 70,79 ----
X  	$(CC) $(UNIX) $(SYSV) -c -o $*.o $(CFLAGS) $(CDEFS) $*.c
X  
X  rem2ps: rem2ps.o
X! 	$(CC) $(LDFLAGS) -o rem2ps rem2ps.o
X  
X  remind: $(OBJS)
X! 	$(CC) $(LDFLAGS) -o remind $(OBJS)
X  
X  clean:
X  	rm -f *.o *~
X***************
X*** 91,96 ****
X--- 95,101 ----
X  init.o: init.c $(STDHDRS) expr.h version.h
X  main.o: main.c $(STDHDRS) expr.h
X  omit.o: omit.c $(STDHDRS)
X+ sort.o: sort.c $(STDHDRS)
X  queue.o: queue.c $(STDHDRS)
X  token.o: token.c $(STDHDRS)
X  trigger.o: trigger.c $(STDHDRS) expr.h
X***************
X*** 99,106 ****
X  var.o: var.c $(STDHDRS) expr.h
X  
X  tarZ:
X! 	tar cvf remind-3.0.3.tar $(MANIFEST)
X! 	compress -v remind-3.0.3.tar
X  
X  shar:
X  	shar -x -n"Remind $(VERSION)" -l45 -o./Shar $(MANIFEST)
X--- 104,111 ----
X  var.o: var.c $(STDHDRS) expr.h
X  
X  tarZ:
X! 	tar cvf remind-3.0.4.tar $(MANIFEST)
X! 	compress -v remind-3.0.4.tar
X  
X  shar:
X  	shar -x -n"Remind $(VERSION)" -l45 -o./Shar $(MANIFEST)
X*** ../patch3/README.DOS	Fri Jan 22 11:08:58 1993
X--- ./README.DOS	Wed Mar  3 17:15:06 1993
X***************
X*** 40,48 ****
X  
X  --
X  David F. Skoll <dfs@doe.carleton.ca>
X! 4-317 LeBreton Street South
X! Ottawa, Ontario K1S 4L4
X  CANADA
X  
X! Tel. (613) 567-3662
X  
X--- 40,48 ----
X  
X  --
X  David F. Skoll <dfs@doe.carleton.ca>
X! 986 Eiffel Avenue
X! Ottawa, Ontario K2C 0J2
X  CANADA
X  
X! Tel. (613) 225-8687
X  
X*** ../patch3/README.OS2	Fri Jan 22 11:08:54 1993
X--- ./README.OS2	Wed Mar  3 17:14:49 1993
X***************
X*** 48,56 ****
X  
X  --
X  David F. Skoll <dfs@doe.carleton.ca>
X! 4-317 LeBreton Street South
X! Ottawa, Ontario K1S 4L4
X  CANADA
X  
X! Tel. (613) 567-3662
X  
X--- 48,56 ----
X  
X  --
X  David F. Skoll <dfs@doe.carleton.ca>
X! 986 Eiffel Avenue
X! Ottawa, Ontario K2C 0J2
X  CANADA
X  
X! Tel. (613) 225-8687
X  
X*** ../patch3/README.UNIX	Fri Jan 29 13:43:01 1993
X--- ./README.UNIX	Wed Mar  3 17:14:29 1993
X***************
X*** 79,86 ****
X  
X  --
X  David F. Skoll <dfs@doe.carleton.ca>
X! 4-317 LeBreton Street South
X! Ottawa, Ontario K1S 4L4
X  CANADA
X  
X! Tel. (613) 567-3662
X--- 79,86 ----
X  
X  --
X  David F. Skoll <dfs@doe.carleton.ca>
X! 986 Eiffel Avenue
X! Ottawa, Ontario K2C 0J2
X  CANADA
X  
X! Tel. (613) 225-8687
X*** ../patch3/WHATSNEW.30	Mon Feb  8 14:43:57 1993
X--- ./WHATSNEW.30	Wed Mar  3 17:16:40 1993
X***************
X*** 1,9 ****
X  CHANGES TO REMIND
X  
X! *** PLEASE NOTE:  AFTER 24 FEBRUARY, 1993, MY NEW ADDRESS WILL BE:
X! 986 Eiffel Avenue,
X! Ottawa, Ontario K2C 0J2
X! Canada
X  
X  * Version 3.0 Patch 3
X  
X--- 1,63 ----
X  CHANGES TO REMIND
X  
X! * Version 3.0 Patch 4
X! 
X! - Added the -g option - this sorts reminders by date/time before
X!   issuing them.  (You can see I'm running out of letters to
X!   name options!)  This feature was suggested by George M. Sipe,
X!   Paul D. Smith, and Francois Pinard.
X! 
X! - Added the "args()" and "dosubst()" built-in functions - see the
X!   man page for details.
X! 
X! - Added more support for the ISO 8859-1 character set, and
X!   modified the german.h file to take advantage of this, thanks
X!   to Robert Joop.
X! 
X! - Allowed any character to be used as date and time separator
X!   characters (not just "/-:.")
X! 
X! - Added support for the Dutch and Finnish languages, thanks to
X!   Willem Kasdorp and Mikko Silvonen.  (Anyone care to contribute
X!   French?  Italian?  Spanish?)
X! 
X! - Made Remind issue a warning if you try to redefine a built-in
X!   function.  This warning is disabled in 'Hush' mode.
X! 
X! - Added the SCANFROM clause to the REM command.  This allows reasonably
X!   safe moveable OMITs such as the Labour Day example in the manual.
X! 
X! - Added more examples to the defs.rem file, and cleaned up some old
X!   examples.  Note that there are now safe moveable holidays for most
X!   U.S. holidays provided in the defs.rem file.
X! 
X! - Added the '-k' option, which allows MSG-type reminders to be passed
X!   to any system command.  (Idea and patch courtesy of Philipp Slusallek.)
X! 
X! - Allowed selection of ':' or '.' as time separator characters at
X!   compile-time.
X! 
X! - Edited the COPYRIGHT file to clarify the rules.  Please read them.
X! 
X! - Removed hard-coding of "am" and "pm" and placed them in language-specific
X!   header files as #defines L_AM and L_PM
X! 
X! - Fixed a bug in the FindToken() routine which had, through sheer luck,
X!   never been activated until the SCANFROM clause was added!
X! 
X! - Fixed the UNTIL clause to check for a valid expiry date.
X! 
X! - Removed identifiers in the C source beginning with "_" to conform
X!   to ANSI practice.
X!   
X! - Fixed a bug in the -u option which resulted in environment variables
X!   SHELL and USER not being set correctly.  Also made -u set the LOGNAME
X!   environment variable.
X! 
X! - Fixed a couple of typos in the man page; added LDFLAGS to the
X!   Makefile.  (Thanks to Dave Wolfe.)
X! 
X! - Put my new mailing address in the README files.
X  
X  * Version 3.0 Patch 3
X  
X*** ../patch3/calendar.c	Fri Feb  5 14:47:40 1993
X--- ./calendar.c	Mon Mar  1 13:00:46 1993
X***************
X*** 24,31 ****
X  #include "err.h"
X  
X  /* Data structures used by the calendar */
X! typedef struct _cal_entry {
X!    struct _cal_entry *next;
X     char *text;
X     char *pos;
X     int time;
X--- 24,31 ----
X  #include "err.h"
X  
X  /* Data structures used by the calendar */
X! typedef struct cal_entry {
X!    struct cal_entry *next;
X     char *text;
X     char *pos;
X     int time;
X***************
X*** 328,334 ****
X     int i;
X  
X     for (i=0; i<d; i++) putchar(pad);
X!    printf("%s", s);
X     for (i=d+len; i<width; i++) putchar(pad);
X  }
X  
X--- 328,336 ----
X     int i;
X  
X     for (i=0; i<d; i++) putchar(pad);
X!    for (i=0; i<width; i++) {
X!       if (*s) putchar(*s++); else break;
X!    }
X     for (i=d+len; i<width; i++) putchar(pad);
X  }
X  
X***************
X*** 625,631 ****
X     if (trig.typ == NO_TYPE) return E_EOLN;
X     if (trig.typ == SAT_TYPE) return DoSatRemind(&trig, &tim, p);
X     /* Calculate the trigger date */
X!    jul = ComputeTrigger(JulianToday, &trig, &r);
X     if (r) return r;
X  
X     /* If trigger date == today, add it to the current entry */   
X--- 627,633 ----
X     if (trig.typ == NO_TYPE) return E_EOLN;
X     if (trig.typ == SAT_TYPE) return DoSatRemind(&trig, &tim, p);
X     /* Calculate the trigger date */
X!    jul = ComputeTrigger(trig.scanfrom, &trig, &r);
X     if (r) return r;
X  
X     /* If trigger date == today, add it to the current entry */   
X***************
X*** 765,771 ****
X  	    if (h == 0) hh=12;
X  	    else if (h > 12) hh=h-12;
X  	    else hh=h;
X! 	    sprintf(out, "%2d:%02d%s ", hh, min, (h>=12) ? "pm" : "am");
X           }
X  	 break;
X  
X--- 767,773 ----
X  	    if (h == 0) hh=12;
X  	    else if (h > 12) hh=h-12;
X  	    else hh=h;
X! 	    sprintf(out, "%2d%c%02d%s ", hh, TIMESEP, min, (h>=12) ? L_PM : L_AM);
X           }
X  	 break;
X  
X***************
X*** 774,780 ****
X  	 else {
X  	    h = tim / 60;
X  	    min = tim % 60;
X! 	    sprintf(out, "%02d:%02d ", h, min);
X           }
X  	 break;
X     }
X--- 776,782 ----
X  	 else {
X  	    h = tim / 60;
X  	    min = tim % 60;
X! 	    sprintf(out, "%02d%c%02d ", h, TIMESEP, min);
X           }
X  	 break;
X     }
X*** ../patch3/config.h	Mon Feb  1 12:21:15 1993
X--- ./config.h	Tue Mar  2 12:12:49 1993
X***************
X*** 19,24 ****
X--- 19,37 ----
X  /* #define DATESEP '-' */
X  
X  /*---------------------------------------------------------------------*/
X+ /* TIMESEP:  The default time separator.  North American usage is ':'; */
X+ /* others may prefer '.'.                                              */
X+ /*---------------------------------------------------------------------*/
X+ #define TIMESEP ':'
X+ /* #define TIMESEP '.' */
X+ 
X+ /*---------------------------------------------------------------------*/
X+ /* ISOLATIN1: uncomment the following line if your system uses the     */
X+ /* ISO 8859-1 character set instead of ASCII.                          */
X+ /*---------------------------------------------------------------------*/
X+ /* #define ISOLATIN1 1 */
X+ 
X+ /*---------------------------------------------------------------------*/
X  /* WANT_U_OPTION: Comment out the next define to permanently disable   */
X  /* the -u option.  If you do this, however, remind-all.[c]sh will not  */
X  /* work.                                                               */
X*** ../patch3/defs.rem	Fri Jan  8 13:26:17 1993
X--- ./defs.rem	Fri Mar  5 11:46:11 1993
X***************
X*** 3,15 ****
X  # DEFS.REM
X  #
X  # This file is a reminder script, which contains a few handy definitions.
X! # Cut and paste as desired!
X  #
X  # This file is part of REMIND.
X  # Copyright (C) 1992, 1993 by David F. Skoll
X  #
X  # ---------------------------------------------------------------------------
X  
X  # It's handy to have symbolic constants for weekdays and month names
X  SET Sunday    0
X  SET Monday    1
X--- 3,28 ----
X  # DEFS.REM
X  #
X  # This file is a reminder script, which contains a few handy definitions.
X! # Cut and paste as desired!  Also, near the end, there are a bunch of holiday
X! # definitions for the U.S.
X  #
X+ # Some examples provided by George M. Sipe <gsipe@pyratl.ga.pyramid.com>
X+ #
X+ # U.S. holidays provided by Dave Rickel <drickel@sjc.mentorg.com>
X+ #
X  # This file is part of REMIND.
X  # Copyright (C) 1992, 1993 by David F. Skoll
X  #
X  # ---------------------------------------------------------------------------
X  
X+ # Bombproofing
X+ RUN OFF
X+ IF version() < "03.00.04"
X+    ERRMSG This file requires at least version 03.00.04 of Remind.%
X+    ERRMSG This version is [version()].
X+    EXIT
X+ ENDIF
X+ 
X  # It's handy to have symbolic constants for weekdays and month names
X  SET Sunday    0
X  SET Monday    1
X***************
X*** 19,24 ****
X--- 32,45 ----
X  SET Friday    5
X  SET Saturday  6
X  
X+ SET Sun 0
X+ SET Mon 1
X+ SET Tue 2
X+ SET Wed 3
X+ SET Thu 4
X+ SET Fri 5
X+ SET Sat 6
X+ 
X  # ---------------------------------------------------------------------------
X  
X  SET Jan 1
X***************
X*** 53,67 ****
X  
X  # A function which, given a time, returns a string in "AM/PM" format.
X  # Unfortunately, has a leading zero.  Example call:
X! #	set a ampm(now())
X  
X! FSET ampm(x) iif(x<1:00, x+12*60+"am", \
X! 	         iif(x<12:00, x+"am", \
X! 	             iif(x<13:00, x+"pm", x-12*60+"pm")))
X  
X  # A function which knocks off a single leading zero from a string
X  
X! FSET no_lz(s) iif(substr(s, 1, 1)=="0", substr(s, 2), s)
X  
X  # ---------------------------------------------------------------------------
X  
X--- 74,88 ----
X  
X  # A function which, given a time, returns a string in "AM/PM" format.
X  # Unfortunately, has a leading zero.  Example call:
X! #	set a _am_pm(now())
X  
X! FSET _am_pm(tm)	IIF (tm<1:00, tm+12*60+"am", \
X! 			IIF (tm<12:00, tm+"am", \
X! 				IIF (tm<13:00, tm+"pm", tm-12*60+"pm")))
X  
X  # A function which knocks off a single leading zero from a string
X  
X! FSET _no_lz(s) IIF(SUBSTR(s, 1, 1)=="0", SUBSTR(s, 2), s)
X  
X  # ---------------------------------------------------------------------------
X  
X***************
X*** 76,110 ****
X  # dependent upon the current date, it's tricky and results may not be
X  # what you expect.  You should try to make sure that the OMIT context
X  # "near" any current reminders will not change during a calendar run.
X  
X! set thisyear year(today())
X  
X! OMIT 4 July MSG The real thing!
X  
X! # Check for Saturday case
X! if wkdaynum(date(thisyear, 7, 4)) == Saturday
X!    OMIT 3 July [thisyear] MSG 4 July (observed)
X! endif
X  
X! # Check for Sunday case
X! if wkdaynum(date(thisyear, 7, 4)) == Sunday
X!    OMIT 5 July [thisyear] MSG 4 July (observed)
X! endif
X  
X! # ---------------------------------------------------------------------------
X  
X! # Here's the since() function - quite useful for remembering how
X! # old kids are:
X  
X! fset since(x) ord(year(trigdate())-x)
X  
X! # Here's an example of how to use it:
X! REM 1 Nov ++12 MSG %"Dean's [since(1984)] birthday%" is %b.
X  
X  # ---------------------------------------------------------------------------
X  
X  # How do we get a double-quote into a string????  Only works on ASCII
X  # machines
X  
X  set example "The last word of this sentence is in " \
X! 	+ char(34) + "quotes." + char(34)
X--- 97,299 ----
X  # dependent upon the current date, it's tricky and results may not be
X  # what you expect.  You should try to make sure that the OMIT context
X  # "near" any current reminders will not change during a calendar run.
X+ # The SCANFROM clause should help make these OMITs very safe.
X  
X! # Convenient function and variable for safe moveable OMITs
X! FSET _safe(x) trigger(today()-x)
X! # Usually, a safety margin of 7 is sufficient.  We can stick it in a
X! # variable.  Note that you must NOT preserve this variable, because
X! # it must be updated as today() is incremented.
X! SET safe7 _safe(7)
X  
X! # The usual holiday
X! OMIT 4 July MSG Independence day
X  
X! # Calculate a "potential" advanced holiday
X! REM 3 July SCANFROM [safe7] SATISFY 1
X  
X! # But only trigger it if it falls on a Friday
X! IF WKDAYNUM(TRIGDATE()) == 5
X!    OMIT [TRIGGER(TRIGDATE())] MSG Independence day (observed)
X! ENDIF
X  
X! # Calculate a "potential" delayed holiday
X! REM 5 July SCANFROM [safe7] SATISFY 1
X  
X! # But only trigger it if it falls on a Monday
X! IF WKDAYNUM(TRIGDATE()) == 1
X!    OMIT [TRIGGER(TRIGDATE())] MSG Independence day (observed)
X! ENDIF
X  
X! # ---------------------------------------------------------------------------
X! # Function to calculate number of years since a given year or
X! # number of months since a given month and year...  useful for kids'
X! # birthdays.
X  
X! FSET _yr_num(yr)	ORD(YEAR(TRIGDATE()) - yr)
X! FSET _mo_num(mo, yr)	ORD(12 * (YEAR(TRIGDATE()) - yr) + \
X! 				MONNUM(TRIGDATE()) - mo)
X  
X+ # Here's an example of how to use them:
X+ REM 1 Nov ++12 MSG %"Dean's [_yr_num(1984)] birthday%" is %b.
X+ REM 1 MSG Dean's [_mo_num(11, 1984)] 'monthly' anniversary
X  # ---------------------------------------------------------------------------
X  
X  # How do we get a double-quote into a string????  Only works on ASCII
X  # machines
X  
X+ set Quote char(34)
X  set example "The last word of this sentence is in " \
X! 	+ Quote + "quotes." + Quote
X! 
X! # ---------------------------------------------------------------------------
X! 
X! # Function to send mail via elm's "fastmail" (by George M. Sipe)...
X! 
X! #FSET _mail(from, subj)	"mailx -s " + \
X! #				Quote + from + " : " + subj + Quote \
X! #				getenv("LOGNAME") + " < /dev/null 1>&0"
X! 
X! FSET _mail(from, subj)	"fastmail -f " + \
X! 				Quote + from + Quote + \
X! 				" -s " + Quote + subj + Quote + \
X! 				" /dev/null " + getenv("LOGNAME")
X! 
X! # Example of use of _mail
X! REM Feb 14 ONCE RUN [_mail("Someone you know", "Valentine's day is today")]
X! 
X! # ---------------------------------------------------------------------------
X! 
X! # A meeting on the first Monday of every month which is moved to the
X! # second Monday in the event of a holiday.
X! 
X! # First, the normal meeting.  However, the SKIP keyword means this
X! # one won't be triggered if the first Monday is a holiday
X! REM Mon 1 SKIP MSG Meeting
X! 
X! # Now, calculate the "potential" delayed meeting
X! REM Mon 8 SATISFY 1
X! 
X! # But only actually trigger the delayed meeting if the previous
X! # Monday was a holiday
X! IF ISOMITTED(TRIGDATE()-7)
X!    REM [TRIGGER(TRIGDATE())] MSG Delayed meeting
X! ENDIF
X! 
X! # ---------------------------------------------------------------------------
X! #
X! # A very complicated reminder sent in by a Remind user.
X! # This person gets paid every two weeks, starting from 8 January 1993.
X! # If a pay date occurs before the twelfth of a month, then that
X! # he pays his mortgage on that pay date.  Otherwise, he pays the mortgage
X! # on the previous pay date.  Furthermore, he has to schedule his
X! # mortgage payment six days before it is due.  He wants to be reminded
X! # a further four days before the scheduling deadline.  He also
X! # wants to be mailed a notice two weeks before the scheduling deadline.
X! 
X! # Here's the solution - if you can follow this, consider yourself a
X! # Remind programmer extraordinaire!
X! 
X! # A function to determine whether or not a pay-date is a mortgage-date.
X! 
X! FSET _IsMortDate(x) DAY(x) < 12 || (DAY(x+14) >= 12 && DAY(x+14) <= 14)
X! 
X! # Paydays - for reference
X! 
X! REM 8 Jan 1993 *14 MSG Payday
X! 
X! # Calculate the mortgage payment six days ahead of time.  Note that this
X! # is done "implicitly" by subtracting 6 from the starting date - we start
X! # on 2 Jan rather than 8 Jan.  We add 6 to TRIGDATE() in _IsMortDate to
X! # compensate.
X! 
X! REM 2 Jan 1993 *14 SATISFY _IsMortDate(TRIGDATE()+6)
X! REM [TRIGGER(TRIGDATE())] ++4 MSG %"Schedule mortgage payment%" for %a.
X! 
X! # Now the mail reminder two weeks before the payment date - because two
X! # weeks before a payment date is also a payment date, no pre-compensation
X! # in the starting date of 8 Jan is necessary - convince yourself of this!
X! # This uses the _mail() function defined earlier.
X! 
X! REM 8 Jan 1993 *14 SATISFY _IsMortDate(TRIGDATE()+14)
X! REM [TRIGGER(TRIGDATE())] ONCE RUN [_mail("Decatur Federal", \
X! 	"Pay mortgage by the " + ORD(DAY(TRIGDATE()+14)))]
X! 
X! # Make an entry on the calendar when the mortgage should be paid
X! 
X! REM 8 Jan 1993 *14 SATISFY _IsMortDate(TRIGDATE())
X! REM [TRIGGER(TRIGDATE())] CAL Mortgage payment
X! 
X! 
X! # ---------------------------------------------------------------------------
X! #
X! # The following holidays were provided by Dave Rickel
X! # Modified by D. Skoll to give safe OMITs for moveable holidays
X! 
X! set thisyear year(today())
X! if ! defined("eyear")
X! 	set eyear 0
X! endif
X! 
X! # Note:  A shorter way to set a default value for eyear is the following:
X! # set eyear value("eyear", 0) -- David S.
X! 
X! if eyear != thisyear
X! 	set a thisyear % 19
X! 	set b thisyear / 100
X! 	set c thisyear % 100
X! 	set d b / 4
X! 	set e b % 4
X! 	set f (b + 8) % 25
X! 	set g (b - f + 1) / 3
X! 	set h (19 * a + b - d - g + 15) % 30
X! 	set i c / 4
X! 	set k c % 4
X! 	set l (32 + e + e + i + i - h - k) % 7
X! 	set m (a + 11 * h + 22 * l) / 451
X! 	set a h + l - 7 * m + 114
X! 	set n a / 31
X! 	set p a % 31 + 1
X! 
X! 	set eyear thisyear
X! 	set emon mon(n)
X! 	set eday p
X! 	preserve eyear emon eday
X! endif
X! REM [emon] [eday] MSG Easter Sunday.
X! 
X! # Some holidays are omitted, some are not.  You may want to change
X! # which ones are omitted - use the general forms shown below.
X! # You'll need the safe7 variable from way up above.
X! 
X! REM Monday Feb 15 SCANFROM [safe7] SATISFY 1
X! OMIT [trigger(trigdate())] MSG President's Day.
X! 
X! REM Saturday Mar 31 MSG Daylight Savings Time begins tonight.
X! REM Mon Tue Wed Thu Fri Sat 15 April MSG Income Tax Day.
X! REM Saturday May 1 MSG Kentucky Derby Day.
X! REM Sunday May 8 MSG Mother's Day.
X! 
X! REM Monday May 25 SCANFROM [safe7] SATISFY 1
X! OMIT [trigger(trigdate())] MSG Memorial Day.
X! 
X! REM Sunday June 15 MSG Father's Day.
X! 
X! REM Monday Sep 1 SCANFROM [safe7] SATISFY 1
X! OMIT [trigger(trigdate())] MSG Labor Day.
X! 
X! REM Monday Oct 8 SCANFROM [safe7] SATISFY 1
X! OMIT [trigger(trigdate())] MSG Columbus Day.
X! 
X! REM Monday Oct 22 SCANFROM [safe7] SATISFY 1
X! OMIT [trigger(trigdate())] MSG Veteran's Day.
X! 
X! REM Saturday Oct 24 MSG Daylight Savings Time ends tonight.
X! 
X! REM Tuesday Nov 2 SCANFROM [safe7] SATISFY (year(trigdate()) % 4) == 0
X! OMIT [trigger(trigdate())] MSG U.S. Election Day.
X! 
X! REM Saturday Nov 12 MSG Sadie Hawkin's Day.
X! 
X! REM Thursday Nov 22 SCANFROM [safe7] SATISFY 1
X! OMIT [trigger(trigdate())] MSG Thanksgiving.
X*** ../patch3/dorem.c	Fri Feb  5 14:48:35 1993
X--- ./dorem.c	Tue Mar  2 16:20:33 1993
X***************
X*** 26,31 ****
X--- 26,32 ----
X  
X  PRIVATE int ParseTimeTrig ARGS ((ParsePtr s, TimeTrig *tim));
X  PRIVATE int ParseLocalOmit ARGS ((ParsePtr s, Trigger *t));
X+ PRIVATE int ParseScanFrom ARGS ((ParsePtr s, Trigger *t));
X  PRIVATE int ParseUntil ARGS ((ParsePtr s, Trigger *t));
X  
X  /***************************************************************/
X***************
X*** 54,60 ****
X     if (trig.typ == NO_TYPE) return E_EOLN;
X     if (trig.typ == SAT_TYPE) return DoSatRemind(&trig, &tim, p);
X     /* Calculate the trigger date */
X!    jul = ComputeTrigger(JulianToday, &trig, &r);
X     if (r) return r;
X     
X  /* Queue the reminder, if necessary */
X--- 55,61 ----
X     if (trig.typ == NO_TYPE) return E_EOLN;
X     if (trig.typ == SAT_TYPE) return DoSatRemind(&trig, &tim, p);
X     /* Calculate the trigger date */
X!    jul = ComputeTrigger(trig.scanfrom, &trig, &r);
X     if (r) return r;
X     
X  /* Queue the reminder, if necessary */
X***************
X*** 108,113 ****
X--- 109,115 ----
X     trig->skip = NO_SKIP;
X     trig->once = NO_ONCE;
X     trig->typ = NO_TYPE;
X+    trig->scanfrom = NO_DATE;
X     tim->ttime = NO_TIME;
X     tim->delta = NO_DELTA;
X     tim->rep   = NO_REP;
X***************
X*** 149,154 ****
X--- 151,161 ----
X  	    if (r) return r;
X  	    break;
X  
X+ 	 case T_Scanfrom:
X+ 	    r=ParseScanFrom(s, trig);
X+ 	    if (r) return r;
X+ 	    break;
X+ 
X  	 case T_RemType:
X  	    trig->typ = tok.val;
X  	    if (s->isnested) {
X***************
X*** 155,160 ****
X--- 162,168 ----
X  	       Eprint("Can't nest '%s' in expression", TokBuffer);
X  	       return E_PARSE_ERR;
X              }
X+ 	    if (trig->scanfrom == NO_DATE) trig->scanfrom = JulianToday;
X  	    return OK;
X  
X  	 case T_Until:
X***************
X*** 216,221 ****
X--- 224,230 ----
X  	    break;
X  
X  	 case T_Empty:
X+ 	    if (trig->scanfrom == NO_DATE) trig->scanfrom = JulianToday;
X  	    return OK;
X  
X  	 default:
X***************
X*** 363,368 ****
X--- 372,378 ----
X  	       Eprint("Incompletely specified UNTIL");
X  	       return E_PARSE_ERR;
X  	    }
X+ 	    if (!DateOK(y, m, d)) return E_BAD_DATE;
X  	    t->until = Julian(y, m, d);
X  	    PushToken(TokBuffer);
X  	    return OK;
X***************
X*** 372,377 ****
X--- 382,453 ----
X  
X  /***************************************************************/
X  /*                                                             */
X+ /*  ParseScanFrom - parse the SCANFROM portion of a reminder   */
X+ /*                                                             */
X+ /***************************************************************/
X+ #ifdef HAVE_PROTOS
X+ PRIVATE int ParseScanFrom(ParsePtr s, Trigger *t)
X+ #else
X+ static int ParseScanFrom(s, t)
X+ ParsePtr s;
X+ Trigger *t;
X+ #endif
X+ {
X+    int y = NO_YR,
X+        m = NO_MON,
X+        d = NO_DAY;
X+ 
X+    Token tok;
X+    int r;
X+ 
X+    if (t->scanfrom != NO_DATE) {
X+       Eprint("Cannot specify SCANFROM twice");
X+       return E_PARSE_ERR;
X+    }
X+ 
X+    while(1) {
X+       r = ParseToken(s, TokBuffer);
X+       if (r) return r;
X+       FindToken(TokBuffer, &tok);
X+       switch(tok.type) {
X+ 	 case T_Year:
X+ 	    if (y != NO_YR) {
X+ 	       Eprint("Year specified twice in SCANFROM");
X+ 	       return E_PARSE_ERR;
X+ 	    }
X+ 	    y = tok.val;
X+ 	    break;
X+ 
X+ 	 case T_Month:
X+ 	    if (m != NO_MON) {
X+ 	       Eprint("Month specified twice in SCANFROM");
X+ 	       return E_PARSE_ERR;
X+ 	    }
X+ 	    m = tok.val;
X+ 	    break;
X+ 
X+ 	 case T_Day:
X+ 	    if (d != NO_DAY) {
X+ 	       Eprint("Day specified twice in SCANFROM");
X+ 	       return E_PARSE_ERR;
X+ 	    }
X+ 	    d = tok.val;
X+ 	    break;
X+ 
X+ 	 default:
X+ 	    if (y == NO_YR || m == NO_MON || d == NO_DAY) {
X+ 	       Eprint("Incompletely specified SCANFROM");
X+ 	       return E_PARSE_ERR;
X+ 	    }
X+ 	    if (!DateOK(y, m, d)) return E_BAD_DATE;
X+ 	    t->scanfrom = Julian(y, m, d);
X+ 	    PushToken(TokBuffer);
X+ 	    return OK;
X+       }
X+    }
X+ }
X+ /***************************************************************/
X+ /*                                                             */
X  /*  TriggerReminder                                            */
X  /*                                                             */
X  /*  Trigger the reminder if it's a RUN or MSG type.            */
X***************
X*** 388,412 ****
X  #endif
X  {
X     int r, y, m, d;
X-    Trigger tempTrig;
X-    TimeTrig tempTime;
X-    Parser tempP;
X  
X     if (t->typ == RUN_TYPE && RunDisabled) return E_RUN_DISABLED;
X     if (t->typ == CAL_TYPE) return OK;
X  
X! /* If we're in Daemon mode, do nothing over here... */
X! 
X! /* If it's a MSG-type reminder, issue the banner. */
X!    if (t->typ == MSG_TYPE && !NumTriggered && !NextMode) {
X!       CreateParser(Banner, &tempP);
X!       tempP.allownested = 0;
X!       tempTrig.typ = MSG_TYPE;
X!       tempTime.ttime = SystemTime()/60;
X!       if (!(r=DoSubst(&tempP, SubstBuffer, &tempTrig,
X!            &tempTime, JulianToday, NORMAL_MODE)))
X           if (*SubstBuffer) printf("%s\n", SubstBuffer);
X-       DestroyParser(&tempP);
X     }
X  
X  /* If it's NextMode, process as a CAL-type entry, and issue simple-calendar
X--- 464,477 ----
X  #endif
X  {
X     int r, y, m, d;
X  
X     if (t->typ == RUN_TYPE && RunDisabled) return E_RUN_DISABLED;
X     if (t->typ == CAL_TYPE) return OK;
X  
X! /* If it's a MSG-type reminder, and no -k option was used, issue the banner. */
X!    if (t->typ == MSG_TYPE && !NumTriggered && !NextMode && !MsgCommand) {
X!       if (!DoSubstFromString(Banner, SubstBuffer, JulianToday, NO_TIME))
X           if (*SubstBuffer) printf("%s\n", SubstBuffer);
X     }
X  
X  /* If it's NextMode, process as a CAL-type entry, and issue simple-calendar
X***************
X*** 424,433 ****
X  /* Put the substituted string into the SubstBuffer */
X     if ( (r=DoSubst(p, SubstBuffer, t, tim, jul, NORMAL_MODE)) ) return r;
X  
X! /* Go for it... */
X!    if (t->typ == MSG_TYPE) printf("%s\n", SubstBuffer);
X!    else system(SubstBuffer);
X  
X     NumTriggered++;
X     return OK;
X  }
X--- 489,517 ----
X  /* Put the substituted string into the SubstBuffer */
X     if ( (r=DoSubst(p, SubstBuffer, t, tim, jul, NORMAL_MODE)) ) return r;
X  
X! /* If we are sorting, just queue it up in the sort buffer */
X!    if (SortByDate) {
X!       if (InsertIntoSortBuffer(jul, tim->ttime, SubstBuffer, t->typ) == OK) {
X!          NumTriggered++;
X!          return OK;
X!       }
X! /* If we failed to insert the reminder into the sort buffer, issue the
X!    reminder now. */
X!    }
X  
X+ /* Otherwise, issue the reminder now */
X+    if (t->typ == MSG_TYPE) {
X+       if (!MsgCommand)
X+          printf("%s\n", SubstBuffer);
X+       else {
X+          char buf[LINELEN+TOKSIZE];
X+          sprintf(buf, MsgCommand, SubstBuffer);
X+ 	 system(buf);
X+       }
X+    } else { /* Must be RUN_TYPE */
X+       system(SubstBuffer);
X+    }
X+ 
X     NumTriggered++;
X     return OK;
X  }
X***************
X*** 519,525 ****
X     char *s;
X  
X     iter = 0;
X!    jul = JulianToday;
X     while (iter++ < MaxSatIter) {
X        jul = ComputeTrigger(jul, trig, &r);
X        if (r) {
X--- 603,609 ----
X     char *s;
X  
X     iter = 0;
X!    jul = trig->scanfrom;
X     while (iter++ < MaxSatIter) {
X        jul = ComputeTrigger(jul, trig, &r);
X        if (r) {
X*** ../patch3/dosubst.c	Mon Jan 25 16:09:28 1993
X--- ./dosubst.c	Fri Mar  5 11:57:34 1993
X***************
X*** 42,48 ****
X  /*  mode==CAL_MODE, process the %" sequence.                   */
X  /*                                                             */
X  /***************************************************************/
X- 
X  #ifdef HAVE_PROTOS
X  PUBLIC int DoSubst(ParsePtr p, char *out, Trigger *t, TimeTrig *tt, int jul, int mode)
X  #else
X--- 42,47 ----
X***************
X*** 82,94 ****
X     h = tim / 60;
X     min = tim % 60;
X  
X!    pm = (h < 12) ? "am" : "pm";
X     hh = (h == 12) ? 12 : h % 12;
X     
X     ch = curtime / 60;
X     cmin = curtime % 60;
X  
X!    cpm = (ch < 12) ? "am" : "pm";
X     chh = (ch == 12) ? 12 : ch % 12;
X  
X  #ifdef L_ORDINAL_OVERRIDE
X--- 81,101 ----
X     h = tim / 60;
X     min = tim % 60;
X  
X! #ifdef L_AMPM_OVERRIDE
X!    L_AMPM_OVERRIDE (pm, h)
X! #else
X!    pm = (h < 12) ? L_AM : L_PM;
X! #endif
X     hh = (h == 12) ? 12 : h % 12;
X     
X     ch = curtime / 60;
X     cmin = curtime % 60;
X  
X! #ifdef L_AMPM_OVERRIDE
X!    L_AMPM_OVERRIDE (cpm, ch)
X! #else
X!    cpm = (ch < 12) ? L_AM : L_PM;
X! #endif
X     chh = (ch == 12) ? 12 : ch % 12;
X  
X  #ifdef L_ORDINAL_OVERRIDE
X***************
X*** 114,120 ****
X        if (err) return err;
X        if (c == '\n') continue;
X        if (!c) {
X!          if (mode != CAL_MODE && t->typ != RUN_TYPE) *s++ = '\n';
X  	 *s++ = 0;
X  	 break;
X        }
X--- 121,128 ----
X        if (err) return err;
X        if (c == '\n') continue;
X        if (!c) {
X!          if (mode != CAL_MODE && t->typ != RUN_TYPE && !MsgCommand)
X! 	    *s++ = '\n';
X  	 *s++ = 0;
X  	 break;
X        }
X***************
X*** 452,458 ****
X  L_3_OVER
X  #else
X  
X! 	    sprintf(s, "%s %02d:%02d", L_AT, h, min);
X  #endif
X  	    s += strlen(s);
X  	    break;
X--- 460,466 ----
X  L_3_OVER
X  #else
X  
X! 	    sprintf(s, "%s %02d%c%02d", L_AT, h, TIMESEP, min);
X  #endif
X  	    s += strlen(s);
X  	    break;
X***************
X*** 542,554 ****
X  #ifdef L_HASH_OVER
X  L_HASH_OVER
X  #else
X! 	    sprintf(s, "%02d:%02d", ch, cmin);
X  #endif
X  	    s += strlen(s);
X  	    break;
X  
X           case '_': 
X!             if (mode != CAL_MODE)
X                 sprintf(s, "%s", NL);
X              else
X                 sprintf(s, " ");
X--- 550,562 ----
X  #ifdef L_HASH_OVER
X  L_HASH_OVER
X  #else
X! 	    sprintf(s, "%02d%c%02d", ch, TIMESEP, cmin);
X  #endif
X  	    s += strlen(s);
X  	    break;
X  
X           case '_': 
X!             if (mode != CAL_MODE && !MsgCommand)
X                 sprintf(s, "%s", NL);
X              else
X                 sprintf(s, " ");
X***************
X*** 611,613 ****
X--- 619,656 ----
X  }
X     
X  
X+ /***************************************************************/
X+ /*                                                             */
X+ /*  DoSubstFromString                                          */
X+ /*                                                             */
X+ /*  DoSubst consumes input from a parser.  This function       */
X+ /*  consumes characters from a string.  It also provides       */
X+ /*  default triggers and a mode of NORMAL_MODE.                */
X+ /*                                                             */
X+ /***************************************************************/
X+ #ifdef HAVE_PROTOS
X+ PUBLIC int DoSubstFromString(char *source, char *dest, int jul, int tim)
X+ #else
X+ int DoSubstFromString(source, dest, jul, tim)
X+ char *source;
X+ char *dest;
X+ int jul;
X+ int tim;
X+ #endif
X+ {
X+    Trigger tempTrig;
X+    TimeTrig tempTime;
X+    Parser tempP;
X+    int r;
X+ 
X+    if (jul == NO_DATE) jul=JulianToday;
X+    if (tim == NO_TIME) tim=SystemTime()/60;
X+    CreateParser(source, &tempP);
X+    tempP.allownested = 0;
X+    tempTrig.typ = MSG_TYPE;
X+    tempTime.ttime = tim;
X+    
X+    r = DoSubst(&tempP, dest, &tempTrig, &tempTime, jul, NORMAL_MODE);
X+    DestroyParser(&tempP);
X+    return r;
X+ }
X*** ../patch3/english.h	Fri Jan 22 14:41:34 1993
X--- ./english.h	Tue Feb 16 17:19:32 1993
X***************
X*** 45,50 ****
X--- 45,54 ----
X  /* The default banner */
X  #define L_BANNER "Reminders for %w, %d%s %m, %y%o:"
X  
X+ /* "am" and "pm" */
X+ #define L_AM "am"
X+ #define L_PM "pm"
X+ 
X  /*** The following are only used in dosubst.c ***/
X  #ifdef L_IN_DOSUBST
X  
X*** ../patch3/err.h	Fri Jan  8 13:25:56 1993
X--- ./err.h	Mon Feb 15 20:41:25 1993
X***************
X*** 70,76 ****
X  = {
X     "Ok",
X     "Missing ']'",
X!    "Missing double-quote",
X     "Expression too complex - too many operators",
X     "Expression too complex - too many operands",
X     "Missing ')'",
X--- 70,76 ----
X  = {
X     "Ok",
X     "Missing ']'",
X!    "Missing quote",
X     "Expression too complex - too many operators",
X     "Expression too complex - too many operands",
X     "Missing ')'",
X*** ../patch3/expr.c	Fri Feb  5 14:51:35 1993
X--- ./expr.c	Wed Mar  3 17:35:34 1993
X***************
X*** 44,50 ****
X  	   GreaterOrEqual(void), LogAND(void), LogOR(void),
X  	   UnMinus(void), LogNot(void),
X  	   Compare(int);
X- PRIVATE Operator *FindFunc(char *name, Operator where[], int num);
X  #else
X  PRIVATE int Multiply(), Divide(), Mod(), Add(),
X  	   Subtract(), GreaterThan(), LessThan(),
X--- 44,49 ----
X***************
X*** 51,57 ****
X  	   EqualTo(), NotEqual(), LessOrEqual(),
X  	   GreaterOrEqual(), LogAND(), LogOR(),
X             UnMinus(), LogNot(), Compare();
X- PRIVATE Operator *FindFunc();
X  #endif
X  
X  PRIVATE int MakeValue ARGS ((char *s, Value *v, Var *locals));
X--- 50,55 ----
X***************
X*** 227,232 ****
X--- 225,231 ----
X  
X     /* Handle the parsing of quoted strings */
X     if (c == '\"') {
X+       if (!*(*in+1)) return E_MISS_QUOTE;
X        while (**in) if ((c = *out++ = *(*in)++) == '\"') break;
X        *out = 0;
X        if (c == '\"') return OK ; else return E_MISS_QUOTE;
X***************
X*** 234,239 ****
X--- 233,239 ----
X  
X     /* Dates can be specified with single-quotes */
X     if (c == '\'') {
X+       if (!*(*in+1)) return E_MISS_QUOTE;
X        while (**in) if ((c = *out++ = *(*in)++) == '\'') break;
X        *out = 0;
X        if (c == '\'') return OK ; else return E_MISS_QUOTE;
X***************
X*** 245,251 ****
X     }
X  
X     /* Parse a constant, variable name or function */
X!    while (ISID(**in) || **in == ':') *out++ = *(*in)++;
X  
X     /* Chew up any remaining white space */
X     while (**in && isspace(**in)) (*in)++;
X--- 245,252 ----
X     }
X  
X     /* Parse a constant, variable name or function */
X!    while (ISID(**in) || **in == ':' || **in == '.' || **in == TIMESEP)
X!       *out++ = *(*in)++;
X  
X     /* Chew up any remaining white space */
X     while (**in && isspace(**in)) (*in)++;
X***************
X*** 341,349 ****
X  	    while(1) {
X  	       args++;
X  	       r = Evaluate(s, locals);
X! 	       if (r) return r;
X  	       if (*ExprBuf == ')') break;
X  	       else if (*ExprBuf != ',') {
X   		  Eprint("Expecting comma, found '%c'", *ExprBuf);
X  	          return E_ILLEGAL_CHAR;
X                 }
X--- 342,354 ----
X  	    while(1) {
X  	       args++;
X  	       r = Evaluate(s, locals);
X! 	       if (r) {
X! 	          if (!f) free(ufname);
X! 	          return r;
X! 	       }
X  	       if (*ExprBuf == ')') break;
X  	       else if (*ExprBuf != ',') {
X+ 	          if (!f) free(ufname);
X   		  Eprint("Expecting comma, found '%c'", *ExprBuf);
X  	          return E_ILLEGAL_CHAR;
X                 }
X***************
X*** 458,464 ****
X           len *= 10;
X           len += (*s++ - '0');
X        }
X!       if (*s == ':') { /* Must be a literal time */
X  	 s++;
X  	 if (!isdigit(*s)) return E_BAD_TIME;
X  	 h = len;
X--- 463,469 ----
X           len *= 10;
X           len += (*s++ - '0');
X        }
X!       if (*s == ':' || *s == '.' || *s == TIMESEP) { /* Must be a literal time */
X  	 s++;
X  	 if (!isdigit(*s)) return E_BAD_TIME;
X  	 h = len;
X***************
X*** 601,607 ****
X        case STR_TYPE:
X           switch(v->type) {
X              case INT_TYPE: sprintf(CoerceBuf, "%d", v->v.val); break;
X!             case TIM_TYPE: sprintf(CoerceBuf, "%02d:%02d", v->v.val / 60, v->v.val % 60);
X  			   break;
X  	    case DATE_TYPE: FromJulian(v->v.val, &y, &m, &d);
X  			    sprintf(CoerceBuf, "%04d%c%02d%c%02d",
X--- 606,613 ----
X        case STR_TYPE:
X           switch(v->type) {
X              case INT_TYPE: sprintf(CoerceBuf, "%d", v->v.val); break;
X!             case TIM_TYPE: sprintf(CoerceBuf, "%02d%c%02d", v->v.val / 60, 
X! 				   TIMESEP, v->v.val % 60);
X  			   break;
X  	    case DATE_TYPE: FromJulian(v->v.val, &y, &m, &d);
X  			    sprintf(CoerceBuf, "%04d%c%02d%c%02d",
X***************
X*** 686,692 ****
X  		  h *= 10;
X  		  h += *s++ - '0';
X  	       }
X! 	       if (*s++ != ':') return E_CANT_COERCE;
X  	       if (!isdigit(*s)) return E_CANT_COERCE;
X  	       while (isdigit(*s)) {
X  		  m *= 10;
X--- 692,700 ----
X  		  h *= 10;
X  		  h += *s++ - '0';
X  	       }
X! 	       if (*s != ':' && *s != '.' && *s != TIMESEP)
X! 	          return E_CANT_COERCE;
X! 	       s++;
X  	       if (!isdigit(*s)) return E_CANT_COERCE;
X  	       while (isdigit(*s)) {
X  		  m *= 10;
X***************
X*** 754,759 ****
X--- 762,768 ----
X     if ((v1.type == DATE_TYPE && v2.type == INT_TYPE) ||
X         (v1.type == INT_TYPE && v2.type == DATE_TYPE)) {
X        v1.v.val += v2.v.val;
X+       if (v1.v.val < 0) return E_DATE_OVER;
X        v1.type = DATE_TYPE;
X        return PushValStack(&v1);
X     }
X***************
X*** 1128,1136 ****
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X! PRIVATE Operator *FindFunc(char *name, Operator where[], int num)
X  #else
X! static Operator *FindFunc(name, where, num)
X  char *name;
X  Operator where[];
X  int num;
X--- 1137,1145 ----
X  /*                                                             */
X  /***************************************************************/
X  #ifdef HAVE_PROTOS
X! Operator *FindFunc(char *name, Operator where[], int num)
X  #else
X! Operator *FindFunc(name, where, num)
X  char *name;
X  Operator where[];
X  int num;
X***************
X*** 1174,1180 ****
X        if (*s) fprintf(fp, "...");
X     }      
X     else if (v->type == INT_TYPE) fprintf(fp, "%d", v->v.val);
X!    else if (v->type == TIM_TYPE) fprintf(fp, "%02d:%02d", v->v.val / 60, v->v.val % 60);
X     else if (v->type == DATE_TYPE) {
X        FromJulian(v->v.val, &y, &m, &d);
X        fprintf(fp, "%04d%c%02d%c%02d", y, DATESEP, m+1, DATESEP, d);
X--- 1183,1190 ----
X        if (*s) fprintf(fp, "...");
X     }      
X     else if (v->type == INT_TYPE) fprintf(fp, "%d", v->v.val);
X!    else if (v->type == TIM_TYPE) fprintf(fp, "%02d%c%02d", v->v.val / 60, 
X! 					 TIMESEP, v->v.val % 60);
X     else if (v->type == DATE_TYPE) {
X        FromJulian(v->v.val, &y, &m, &d);
X        fprintf(fp, "%04d%c%02d%c%02d", y, DATESEP, m+1, DATESEP, d);
X***************
X*** 1234,1240 ****
X        y *= 10;
X        y += *(*s)++ - '0';
X     }
X!    if (**s != '/' && **s != '-') return E_BAD_DATE;
X     (*s)++;
X     if (!isdigit(**s)) return E_BAD_DATE;
X     while (isdigit(**s)) {
X--- 1244,1250 ----
X        y *= 10;
X        y += *(*s)++ - '0';
X     }
X!    if (**s != '/' && **s != '-' && **s != DATESEP) return E_BAD_DATE;
X     (*s)++;
X     if (!isdigit(**s)) return E_BAD_DATE;
X     while (isdigit(**s)) {
X***************
X*** 1242,1248 ****
X        m += *(*s)++ - '0';
X     }
X     m--;
X!    if (**s != '/' && **s != '-') return E_BAD_DATE;
X     (*s)++;
X     if (!isdigit(**s)) return E_BAD_DATE;
X     while (isdigit(**s)) {
X--- 1252,1258 ----
X        m += *(*s)++ - '0';
X     }
X     m--;
X!    if (**s != '/' && **s != '-' && **s != DATESEP) return E_BAD_DATE;
X     (*s)++;
X     if (!isdigit(**s)) return E_BAD_DATE;
X     while (isdigit(**s)) {
X***************
X*** 1249,1257 ****
X        d *= 10;
X        d += *(*s)++ - '0';
X     }
X!    if (y < BASE || y > BASE+YR_RANGE || m<0 ||
X!         m>11 || d<1 || d>DaysInMonth(m, y)) return E_BAD_DATE;
X! 
X     *jul = Julian(y, m, d);
X  
X     return OK;
X--- 1259,1266 ----
X        d *= 10;
X        d += *(*s)++ - '0';
X     }
X!    if (!DateOK(y, m, d)) return E_BAD_DATE;
X!    
X     *jul = Julian(y, m, d);
X  
X     return OK;
X*** ../patch3/files.c	Fri Feb  5 14:52:12 1993
X--- ./files.c	Mon Mar  1 13:00:30 1993
X***************
X*** 39,52 ****
X  #include "err.h"
X  
X  /* Define the structures needed by the file caching system */
X! typedef struct _cache_ {
X!    struct _cache_ *next;
X     char *text;
X     int LineNo;
X  } CachedLine;
X  
X! typedef struct _cheader_ {
X!    struct _cheader_ *next;
X     char *filename;
X     CachedLine *cache;
X  } CachedFile;
X--- 39,52 ----
X  #include "err.h"
X  
X  /* Define the structures needed by the file caching system */
X! typedef struct cache {
X!    struct cache *next;
X     char *text;
X     int LineNo;
X  } CachedLine;
X  
X! typedef struct cheader {
X!    struct cheader *next;
X     char *filename;
X     CachedLine *cache;
X  } CachedFile;
X*** ../patch3/funcs.c	Fri Feb  5 14:43:14 1993
X--- ./funcs.c	Tue Mar  2 16:27:55 1993
X***************
X*** 47,52 ****
X--- 47,53 ----
X  /* Function prototypes */
X  PRIVATE	int	FAbs		ARGS ((void));
X  PRIVATE	int	FAccess		ARGS ((void));
X+ PRIVATE int     FArgs		ARGS ((void));
X  PRIVATE	int	FAsc		ARGS ((void));
X  PRIVATE	int	FBaseyr		ARGS ((void));
X  PRIVATE	int	FChar		ARGS ((void));
X***************
X*** 56,61 ****
X--- 57,63 ----
X  PRIVATE	int	FDay		ARGS ((void));
X  PRIVATE	int	FDaysinmon	ARGS ((void));
X  PRIVATE	int	FDefined	ARGS ((void));
X+ PRIVATE	int	FDosubst	ARGS ((void));
X  PRIVATE	int	FFilename	ARGS ((void));
X  PRIVATE	int	FGetenv		ARGS ((void));
X  PRIVATE	int	FHour		ARGS ((void));
X***************
X*** 136,141 ****
X--- 138,144 ----
X  
X      {   "abs",		1,	1,	FAbs	},
X      {   "access",       2,      2,      FAccess },
X+     {   "args",         1,      1,      FArgs   },
X      {   "asc",		1,	1,	FAsc	},
X      {   "baseyr",	0,	0,	FBaseyr	},
X      {   "char",		1,	NO_MAX,	FChar	},
X***************
X*** 145,150 ****
X--- 148,154 ----
X      {   "day",		1,	1,	FDay	},
X      {   "daysinmon",	2,	2,	FDaysinmon },
X      {   "defined",	1,	1,	FDefined },
X+     {   "dosubst",	1,	3,	FDosubst },
X      {   "filename",	0,	0,	FFilename },
X      {   "getenv",	1,	1,	FGetenv },
X      {   "hour",		1,	1,	FHour	},
X***************
X*** 370,377 ****
X     m = ARG(1).v.val - 1;
X     d = ARG(2).v.val;
X  
X!    if (y < BASE || y > BASE+YR_RANGE || m < 0 || m > 11 || d < 1 ||
X!        d > DaysInMonth(m, y)) return E_BAD_DATE;
X  
X     RetVal.type = DATE_TYPE;
X     RetVal.v.val = Julian(y, m, d);
X--- 374,380 ----
X     m = ARG(1).v.val - 1;
X     d = ARG(2).v.val;
X  
X!    if (!DateOK(y, m, d)) return E_BAD_DATE;
X  
X     RetVal.type = DATE_TYPE;
X     RetVal.v.val = Julian(y, m, d);
X***************
X*** 1435,1437 ****
X--- 1438,1492 ----
X  {
X     return RetStrVal(L_LANGNAME);
X  }
X+ 
X+ /***************************************************************/
X+ /*                                                             */
X+ /*  FArgs                                                      */
X+ /*                                                             */
X+ /*  Implement the args() function.                             */
X+ /*                                                             */
X+ /***************************************************************/
X+ #ifdef HAVE_PROTOS
X+ PRIVATE int FArgs(void)
X+ #else
X+ static int FArgs()
X+ #endif
X+ {
X+    if (ARG(0).type != STR_TYPE) return E_BAD_TYPE;
X+    RetVal.type = INT_TYPE;
X+    RetVal.v.val = UserFuncExists(ARG(0).v.str);
X+    return OK;
X+ }
X+ 
X+ /***************************************************************/
X+ /*                                                             */
X+ /*  FDosubst                                                   */
X+ /*                                                             */
X+ /*  Implement the dosubst() function.                          */
X+ /*                                                             */
X+ /***************************************************************/
X+ #ifdef HAVE_PROTOS
X+ PRIVATE int FDosubst(void)
X+ #else
X+ static int FDosubst()
X+ #endif
X+ {
X+    int jul, tim, r;
X+    char TmpBuf[LINELEN];
X+ 
X+    jul = NO_DATE;
X+    tim = NO_TIME;
X+    if (ARG(0).type != STR_TYPE) return E_BAD_TYPE;
X+    if (Nargs >= 2) {
X+       if (ARG(1).type != DATE_TYPE) return E_BAD_TYPE;
X+       jul = ARG(1).v.val;
X+       if (Nargs >= 3) {
X+          if (ARG(2).type != TIM_TYPE) return E_BAD_TYPE;
X+ 	 tim = ARG(2).v.val;
X+       }
X+    }
X+ 
X+    if ((r=DoSubstFromString(ARG(0).v.str, TmpBuf, jul, tim))) return r;
X+    return RetStrVal(TmpBuf);
X+ }
X+ 
X*** ../patch3/german.h	Fri Jan 22 14:41:16 1993
X--- ./german.h	Tue Mar  2 12:15:26 1993
X***************
X*** 31,37 ****
X  /* Month names */
X  #define L_JAN "Januar"
X  #define L_FEB "Februar"
X! #define L_MAR "Maerz"
X  #define L_APR "April"
X  #define L_MAY "Mai"
X  #define L_JUN "Juni"
X--- 31,41 ----
X  /* Month names */
X  #define L_JAN "Januar"
X  #define L_FEB "Februar"
X! #ifdef ISOLATIN1
X! #  define L_MAR "M\344rz"
X! #else
X! #  define L_MAR "Maerz"
X! #endif
X  #define L_APR "April"
X  #define L_MAY "Mai"
X  #define L_JUN "Juni"
X***************
X*** 47,54 ****
X  #define L_TOMORROW "morgen"
X  
X  /* The default banner */
X! #define L_BANNER "Termine fuer %w, den %d %m %y%o:"
X  
X  /*** The following are only used in dosubst.c ***/
X  #ifdef L_IN_DOSUBST
X  
X--- 51,66 ----
X  #define L_TOMORROW "morgen"
X  
X  /* The default banner */
X! #ifdef ISOLATIN1
X! #  define L_BANNER "Termine f\374r %w, den %d. %m %y%o:"
X! #else
X! #  define L_BANNER "Termine fuer %w, den %d. %m %y%o:"
X! #endif
X  
X+ /* "am" and "pm" */
X+ #define L_AM "am"
X+ #define L_PM "pm"
X+ 
X  /*** The following are only used in dosubst.c ***/
X  #ifdef L_IN_DOSUBST
X  
END_OF_FILE
  if test 53218 -ne `wc -c <'patch.04.A'`; then
    echo shar: \"'patch.04.A'\" unpacked with wrong size!
  elif test -f 'patch.04.B'; then
    echo shar: Combining  \"'patch.04'\" \(111518 characters\)
    cat 'patch.04.A' 'patch.04.B' > 'patch.04'
    if test 111518 -ne `wc -c <'patch.04'`; then
      echo shar: \"'patch.04'\" combined with wrong size!
    else
      rm patch.04.A patch.04.B
    fi
  fi
  # end of 'patch.04.A'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
