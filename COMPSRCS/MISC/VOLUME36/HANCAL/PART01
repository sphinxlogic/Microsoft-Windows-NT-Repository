Newsgroups: comp.sources.misc
From: ken@syd.dit.csiro.au (Ken Yap)
Subject: v36i007:  hancal - Chinese calendar generator, Part01/01
Message-ID: <1993Mar8.042433.23822@sparky.imd.sterling.com>
X-Md4-Signature: ed582c2d39ef4453ca4317f4963e8276
Date: Mon, 8 Mar 1993 04:24:33 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: ken@syd.dit.csiro.au (Ken Yap)
Posting-number: Volume 36, Issue 7
Archive-name: hancal/part01
Environment: UNIX

This program prints a Chinese calendar in a solar calendar.  By this I
mean that the output format is as follows:  The solar month name is
preceeded by the Chinese month for the first day of the month, with a +
suffix if a leap month. The days are the Chinese dates. In this example
below

    1/Feb 1993             2/Mar 1993             3/Apr 1993
Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa
   10 11 12 13 14 15       9 10 11 12 13 14               10 11 12
16 17 18 19 20 21 22   15 16 17 18 19 20 21   13 14 15 16 17 18 19
23 24 25 26 27 28 29   22 23 24 25 26 27 28   20 21 22 23 24 25 26
 1  2  3  4  5  6  7   29 30  1  2  3  4  5   27 28 29 30  1  2  3
 8                      6  7  8  9             4  5  6  7  8  9

Monday 1 March 1993 is the 9th day of the 2nd month in the Chinese
calendar.  Usage instructions are in the file cal.man.  Pay attention
to the range limitations of the lunar program.

See the README file for further information.
-------------
#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create:
#	Makefile
#	Makefile.lunar
#	README
#	cal.c
#	cal.man
#	hancal.c
#	lunar.1
#	lunar.bitmap
#	lunar.c
#	readme.txt
#	tables.h
# This archive created: Mon Mar  8 10:46:04 1993
export PATH; PATH=/bin:/usr/bin:$PATH
echo shar: "extracting 'Makefile'" '(194 characters)'
if test -f 'Makefile'
then
	echo shar: "will not over-write existing file 'Makefile'"
else
cat << \SHAR_EOF > 'Makefile'
# Makefile of HANCAL

CFLAGS= -O

hancal:	hancal.o lunar.o
	$(CC) -o $@ hancal.o lunar.o

hancal.o:	hancal.c

lunar.o:	lunar.c
	$(CC) -Dmain=lmain -Dusage=lusage -c lunar.c

clean:
	rm *.o core
SHAR_EOF
if test 194 -ne "`wc -c < 'Makefile'`"
then
	echo shar: "error transmitting 'Makefile'" '(should have been 194 characters)'
fi
fi
echo shar: "extracting 'Makefile.lunar'" '(91 characters)'
if test -f 'Makefile.lunar'
then
	echo shar: "will not over-write existing file 'Makefile.lunar'"
else
cat << \SHAR_EOF > 'Makefile.lunar'
# Makefile of LUNAR

CFLAGS= -O

lunar:	lunar.o
	cc -o lunar lunar.o

clean:
	rm *.o core

SHAR_EOF
if test 91 -ne "`wc -c < 'Makefile.lunar'`"
then
	echo shar: "error transmitting 'Makefile.lunar'" '(should have been 91 characters)'
fi
fi
echo shar: "extracting 'README'" '(1711 characters)'
if test -f 'README'
then
	echo shar: "will not over-write existing file 'README'"
else
cat << \SHAR_EOF > 'README'
HANCAL
======

This was a quick one hour hack. Hardly any original programming.

What I did was take a public domain reimplementation of Unix cal by
Martin Minow and modify it slightly to call routines from Lunar 2.1, a
Lunar Calendar Conversion Program by Fung F. Lee and Ricky Yeung.
(Their copyright does not allow me to change the file, so I got around
this by redefining the clashing names.  Perhaps they will separate out
the useful conversion routines in a later release, hint hint.)

The hybrid program prints a Chinese calendar in a solar calendar.  By
this I mean that the output format is as follows:  The solar month name
is preceeded by the Chinese month for the first day of the month, with
a + suffix if a leap month. The days are the Chinese dates. In this
example below

    1/Feb 1993             2/Mar 1993             3/Apr 1993
Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa
   10 11 12 13 14 15       9 10 11 12 13 14               10 11 12
16 17 18 19 20 21 22   15 16 17 18 19 20 21   13 14 15 16 17 18 19
23 24 25 26 27 28 29   22 23 24 25 26 27 28   20 21 22 23 24 25 26
 1  2  3  4  5  6  7   29 30  1  2  3  4  5   27 28 29 30  1  2  3
 8                      6  7  8  9             4  5  6  7  8  9

Monday 1 March 1993 is the 9th day of the 2nd month in the Chinese
calendar.  Usage instructions are in the file cal.man.  Pay attention
to the range limitations of the lunar program.

Bugs in the lunar conversion routines should be brought to the
attention of the corresponding authors. For cal,c, If you find a bug,
you've got the source so you fix it yourself.

This software has nothing to do with my employers.

	Ken Yap
	ken@syd.dit.csiro.au
	6 March 1993
SHAR_EOF
if test 1711 -ne "`wc -c < 'README'`"
then
	echo shar: "error transmitting 'README'" '(should have been 1711 characters)'
fi
fi
echo shar: "extracting 'cal.c'" '(9180 characters)'
if test -f 'cal.c'
then
	echo shar: "will not over-write existing file 'cal.c'"
else
cat << \SHAR_EOF > 'cal.c'
/*
 * 			C A L E N D A R
 *
 * Usage:
 *	cal	MM		If small, it's a month, if large, a year.
 * or
 *	cal	YYYY MM		year/month
 * or
 *	cal	MM YYYY	
 */

#include <stdio.h>
#include <time.h>
#ifdef	decus
int	$$narg = 1;			/* Don't prompt			*/
#endif
#ifdef vms
#include		ssdef
#define	IO_ERROR	SS$_ABORT
#define	IO_SUCCESS	SS$_NORMAL
#endif
#ifndef	IO_ERROR
#define	IO_SUCCESS	0		/* Unix definitions		*/
#define	IO_ERROR	1
#endif
#define	EOS	0

#define	ENTRY_SIZE	3		/* 3 bytes per value		*/
#define DAYS_PER_WEEK	7		/* Sunday, etc.			*/
#define	WEEKS_PER_MONTH	6		/* Max. weeks in a month	*/
#define	MONTHS_PER_LINE	3		/* Three months across		*/
#define	MONTH_SPACE	3		/* Between each month		*/

/*
 * calendar() stuffs data into layout[],
 * output() copies from layout[] to outline[], (then trims blanks).
 */
char	layout[MONTHS_PER_LINE][WEEKS_PER_MONTH][DAYS_PER_WEEK][ENTRY_SIZE];
char	outline[(MONTHS_PER_LINE * DAYS_PER_WEEK * ENTRY_SIZE)
	    + (MONTHS_PER_LINE * MONTH_SPACE)
	    + 1];

char	*weekday = "Su Mo Tu We Th Fr Sa";
char	*monthname[] = {
	"???",						/* No month 0	*/
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

main(argc, argv)
int		argc;
char		*argv[];
{
	register int	month;
	register int	year;

	register int	arg1val;
	int		arg1len;
	int		arg2val;
	int		tvec[2];
	struct tm	*tm;

	time(&tvec[0]);
	tm = localtime(&tvec[0]);
	year = tm->tm_year + 1900;
	month = tm->tm_mon + 1;
	if (argc <= 1) {
	    /*
	     * No arguments mean do last, this, and next month
	     */
	    do3months(year, month);
	}
	else {
	    arg1val = atoi(argv[1]);
	    arg1len = strlen(argv[1]);
	    if (argc == 2) {
		/*
		 * Only one argument, if small, it's a month.  If
		 * large, it's a year.  Note:
		 *	calend	0082	Year '82
		 *	calend	82	Year 1982
		 */
		if (arg1len <= 2 && arg1val <= 12)
		    do3months(year, arg1val);
		else {
		    if (arg1len <= 2 && arg1val > 0 && arg1val <= 99)
			arg1val += 1900;
		    doyear(arg1val);
		}
	    }
	    else {
		/*
		 * Two arguments, allow YYYY MM or MM YYYY (but not
		 * MM YY or YY MM).
		 */
		arg2val = atoi(argv[2]);
		if (arg1len > 2)
		    do3months(arg1val, arg2val);
		else
		    do3months(arg2val, arg1val);
	    }
	}
	exit(IO_SUCCESS);
}

doyear(year)
int		year;
/*
 * Print the calendar for an entire year.
 */
{
	register int	month;

	if (year < 1 || year > 9999)
	    usage("year", year);
	printf("\n\n\n%35d\n\n", year);
	for (month = 1; month <= 12; month += MONTHS_PER_LINE) {
	    printf("\n\n%12s%23s%23s\n",
		    monthname[month],
		    monthname[month+1],
		    monthname[month+2]);
	    printf("%s   %s   %s\n", weekday, weekday, weekday);
	    calendar(year, month+0, 0);
	    calendar(year, month+1, 1);
	    calendar(year, month+2, 2);
	    output(3);
#if MONTHS_PER_LINE != 3
	    << error, the above won't work >>
#endif
	}
	printf("\n\n\n");
}

do3months(thisyear, thismonth)
int		thisyear;
register int	thismonth;
/*
 * Do last month, this month, and next month.
 */
{
	int		lastmonth;
	int		lastyear;
	int		nextmonth;
	int		nextyear;

/*
 * Range check year and month.  Avoid wraps that would
 * cause embarrassment.
 */
	if (thisyear < 2 || thisyear > 9998)
	    usage("year", thisyear);
	if (thismonth <= 0 || thismonth > 12)
	    usage("month", thismonth);

	lastyear = nextyear = thisyear;
	if ((lastmonth = thismonth - 1) == 0) {
	    lastmonth = 12;
	    lastyear--;
	}
	if ((nextmonth = thismonth + 1) == 13) {
	    nextmonth = 1;
	    nextyear++;
	}
	printf("%9s%5d%18s%5d%18s%5d\n",
		monthname[lastmonth], lastyear,
		monthname[thismonth], thisyear,
		monthname[nextmonth], nextyear);
	printf("%s   %s   %s\n", weekday, weekday, weekday);
	calendar(lastyear, lastmonth, 0);
	calendar(thisyear, thismonth, 1);
	calendar(nextyear, nextmonth, 2);
	output(3);
#if MONTHS_PER_LINE != 3
	<< error, the above won't work >>
#endif
	printf("\n\n\n");
}
	
output(nmonths)
int		nmonths;		/* Number of months to do	*/
/*
 * Clean up and output the text.
 */
{
	register int	week;
	register int	month;
	register char	*outp;

	for (week = 0; week < WEEKS_PER_MONTH; week++) {
	    outp = outline;
	    for (month = 0; month < nmonths; month++) {
		/*
		 * The -1 in the following removes
		 * the unwanted leading blank from
		 * the entry for Sunday.
		 */
		sprintf(outp, "%.*s%*s",
		    DAYS_PER_WEEK * ENTRY_SIZE - 1,
		    &layout[month][week][0][1],
		    MONTH_SPACE, "");
		outp += (DAYS_PER_WEEK * ENTRY_SIZE) + MONTH_SPACE - 1;
	    }
	    while (outp > outline && outp[-1] == ' ')
		outp--;
	    *outp = EOS;
	    puts(outline);
	}
}

calendar(year, month, index)
int		year;
int		month;
int		index;		/* Which of the three months		*/
/*
 * Actually build the calendar for this month.
 */
{
	register char	*tp;
	int		week;
	register int	wday;
	register int	today;

	setmonth(year, month);
	for (week = 0; week < WEEKS_PER_MONTH; week++) {
	    for (wday = 0; wday < DAYS_PER_WEEK; wday++) {
		tp = &layout[index][week][wday][0];
		*tp++ = ' ';
		today = getdate(week, wday);
		if (today <= 0) {
		    *tp++ = ' ';
		    *tp++ = ' ';
		}
		else if (today < 10) {
		    *tp++ = ' ';
		    *tp   = (today + '0');
		}
		else {
		    *tp++ = (today / 10) + '0';
		    *tp   = (today % 10) + '0';
		}
	    }
	}
}

usage(what, value)
char		*what;
int		value;
/*
 * Fatal parameter error
 */
{
	fprintf(stderr, "Calendar parameter error: bad %s: %d\n",
	    what, value);
	fprintf(stderr, "Usage: \"calend month\" or \"calend year month\"\n");
	fprintf(stderr, "Year and month are integers.\n");
	exit(IO_ERROR);
}

/*
 * Calendar routines, intended for eventual porting to TeX
 *
 * date(year, month, week, wday)
 *	Returns the date on this week (0 is first, 5 last possible)
 *	and day of the week (Sunday == 0)
 *	Note: January is month 1.
 *
 * setmonth(year, month)
 *	Parameters are as above, sets getdate() for this month.
 *
 * int
 * getdate(week, wday)
 *	Parameters are as above, uses the data set by setmonth()
 */

/*
 * This structure is used to pass data between setmonth() and getdate().
 * It needs considerable expansion if the Julian->Gregorian change is
 * to be extended to other countries.
 */

static struct {
    int		feb;		/* Days in February for this month	*/
    int		sept;		/* Days in September for this month	*/
    int		days_in_month;	/* Number of days in this month		*/
    int		dow_first;	/* Day of week of the 1st day in month	*/
} info;

static int day_month[] = {	/* 30 days hath September...		*/
	0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

int
date(year, month, week, wday)
int		year;		/* Calendar date being computed		*/
int		month;		/* January == 1				*/
int		week;		/* Week in the month 0..5 inclusive	*/
int		wday;		/* Weekday, Sunday == 0			*/
/*
 * Return the date of the month that fell on this week and weekday.
 * Return zero if it's out of range.
 */
{
	setmonth(year, month);
	return (getdate(week, wday));
}

setmonth(year, month)
int		year;			/* Year to compute		*/
int		month;			/* Month, January is month 1	*/
/*
 * Setup the parameters needed to compute this month
 * (stored in the info structure).
 */
{
	register int		i;

	if (month < 1 || month > 12) {	/* Verify caller's parameters	*/
	    info.days_in_month = 0;	/* Garbage flag			*/
	    return;
	}
	info.dow_first = Jan1(year);	/* Day of January 1st for now	*/
	info.feb = 29;			/* Assume leap year		*/
	info.sept = 30;			/* Assume normal year		*/
	/*
	 * Determine whether it's an ordinary year, a leap year
	 * or the magical calendar switch year of 1752.
	 */
	switch ((Jan1(year + 1) + 7 - info.dow_first) % 7) {
	case 1:				/* Not a leap year		*/
	    info.feb = 28;
	case 2:				/* Ordinary leap year		*/
	    break;

	default:			/* The magical moment arrives	*/
	    info.sept = 19;		/* 19 days hath September	*/
	    break;
	}
	info.days_in_month =
	      (month == 2) ? info.feb
	    : (month == 9) ? info.sept
	    : day_month[month];
	for (i = 1; i < month; i++) {
	    switch (i) {		/* Special months?		*/
	    case 2:			/* February			*/
		info.dow_first += info.feb;
		break;

	    case 9:
		info.dow_first += info.sept;
		break;

	    default:
		info.dow_first += day_month[i];
		break;
	    }
	}
	info.dow_first %= 7;		/* Now it's Sunday to Saturday	*/
}

int
getdate(week, wday)
int		week;
int		wday;
{
	register int	today;

	/*
	 * Get a first guess at today's date and make sure it's in range.
	 */
	today = (week * 7) + wday - info.dow_first + 1;
	if (today <= 0 || today > info.days_in_month)
	    return (0);
	else if (info.sept == info.days_in_month && info.sept == 19 
		 && today >= 3)		/* The magical month?	*/
	    return (today + 11);	/* If so, some dates changed	*/
	else				/* Otherwise,			*/
	    return (today);		/* Return the date		*/
}

static int
Jan1(year)
int		year;
/*
 * Return day of the week for Jan 1 of the specified year.
 */
{
	register int	day;

	day = year + 4 + ((year + 3) / 4);	/* Julian Calendar	*/
	if (year > 1800) {			/* If it's recent, do	*/
	    day -= ((year - 1701) / 100);	/* Clavian correction	*/
	    day += ((year - 1601) / 400);	/* Gregorian correction	*/
	}
	if (year > 1752)			/* Adjust for Gregorian	*/
	    day += 3;				/* calendar		*/
	return (day % 7);
}

SHAR_EOF
if test 9180 -ne "`wc -c < 'cal.c'`"
then
	echo shar: "error transmitting 'cal.c'" '(should have been 9180 characters)'
fi
fi
echo shar: "extracting 'cal.man'" '(1573 characters)'
if test -f 'cal.man'
then
	echo shar: "will not over-write existing file 'cal.man'"
else
cat << \SHAR_EOF > 'cal.man'




       CAL(1)		local				CAL(1)



       USAGE

        	cal [year] [month]
		cal [month] [year]

       DESCRIPTION

        	When invoked without arguments, calend prints a
        	calendar for the preceeding, current, and next
        	months of the current year.

        	If a month is given (a value from 1 through 12),
        	it prints the three months centered on the requested
        	month.  For example,

        	    calend 12

        	Prints November and December for this year, and
        	January for next year.

        	If a year is given, it prints a calendar for the
        	entire year:

        	    calend 1985

        	If both values are given, it prints the three months
        	centered on the indicated date:

        	    calend 1752 9
        	    calend 9 1752

        	Note that a three or four digit number will always be taken as
        	a year.  A one or two digit number will be either a month
        	or a year in the 20th century:

        	    calend 78		(equals calend 1978)
        	    calend 0078		(early common era)

       BUGS

        	The change from the Julian to Gregorian calendars follows
        	usage in England and her colonies.  Options should be provided
        	to process the change for other countries (and localities).
        	This is, however, a fairly complex task with little payback.

        	The year didn't always start in January.

       REFERENCES

        	Enclycopaedia Brittanica, 13th edition, Vol. 4, p. 987 et. seq.

       AUTHOR

        	Martin Minow


        			        -1-
SHAR_EOF
if test 1573 -ne "`wc -c < 'cal.man'`"
then
	echo shar: "error transmitting 'cal.man'" '(should have been 1573 characters)'
fi
fi
echo shar: "extracting 'hancal.c'" '(10062 characters)'
if test -f 'hancal.c'
then
	echo shar: "will not over-write existing file 'hancal.c'"
else
cat << \SHAR_EOF > 'hancal.c'
/*
 * 			C A L E N D A R
 *
 * Usage:
 *	cal	MM		If small, it's a month, if large, a year.
 * or
 *	cal	YYYY MM		year/month
 * or
 *	cal	MM YYYY	
 */

#include <stdio.h>
#include <sys/types.h>
#include <time.h>
#ifdef	decus
int	$$narg = 1;			/* Don't prompt			*/
#endif
#ifdef vms
#include		ssdef
#define	IO_ERROR	SS$_ABORT
#define	IO_SUCCESS	SS$_NORMAL
#endif
#ifndef	IO_ERROR
#define	IO_SUCCESS	0		/* Unix definitions		*/
#define	IO_ERROR	1
#endif
#define	EOS	0

#define	ENTRY_SIZE	3		/* 3 bytes per value		*/
#define DAYS_PER_WEEK	7		/* Sunday, etc.			*/
#define	WEEKS_PER_MONTH	6		/* Max. weeks in a month	*/
#define	MONTHS_PER_LINE	3		/* Three months across		*/
#define	MONTH_SPACE	3		/* Between each month		*/

/*
 * calendar() stuffs data into layout[],
 * output() copies from layout[] to outline[], (then trims blanks).
 */
char	layout[MONTHS_PER_LINE][WEEKS_PER_MONTH][DAYS_PER_WEEK][ENTRY_SIZE];
char	outline[(MONTHS_PER_LINE * DAYS_PER_WEEK * ENTRY_SIZE)
	    + (MONTHS_PER_LINE * MONTH_SPACE)
	    + 1];

char	*weekday = "Su Mo Tu We Th Fr Sa";
char	*monthname[] = {
	"???",						/* No month 0	*/
	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

/*
 * Imports from lunar.c
 */
typedef struct {
int year, month, day, hour, weekday;
int leap;	/* the lunar month is a leap month */
} Date;

extern Date solar, lunar;
extern void Solar2Lunar();

/* End of imports */

/*
 * Interposed to return Chinese month and Solar monthname
 */
char *xmonthname(month, year)
int		month;
int		year;
{
	static char	buffer[13][10];

	solar.year = year;
	solar.month = month;
	solar.day = 1;
	solar.hour = 0;
	Solar2Lunar();
	sprintf(buffer[month], "%d%s/%s", lunar.month, lunar.leap ? "+" : "",
		monthname[month]);
	return (buffer[month]);
}

main(argc, argv)
int		argc;
char		*argv[];
{
	register int	month;
	register int	year;

	register int	arg1val;
	int		arg1len;
	int		arg2val;
	time_t		tval;
	struct tm	*tm;

	tval = time(0);
	tm = localtime(&tval);
	year = tm->tm_year + 1900;
	month = tm->tm_mon + 1;
	if (argc <= 1) {
	    /*
	     * No arguments mean do last, this, and next month
	     */
	    do3months(year, month);
	}
	else {
	    arg1val = atoi(argv[1]);
	    arg1len = strlen(argv[1]);
	    if (argc == 2) {
		/*
		 * Only one argument, if small, it's a month.  If
		 * large, it's a year.  Note:
		 *	calend	0082	Year '82
		 *	calend	82	Year 1982
		 */
		if (arg1len <= 2 && arg1val <= 12)
		    do3months(year, arg1val);
		else {
		    if (arg1len <= 2 && arg1val > 0 && arg1val <= 99)
			arg1val += 1900;
		    doyear(arg1val);
		}
	    }
	    else {
		/*
		 * Two arguments, allow YYYY MM or MM YYYY (but not
		 * MM YY or YY MM).
		 */
		arg2val = atoi(argv[2]);
		if (arg1len > 2)
		    do3months(arg1val, arg2val);
		else
		    do3months(arg2val, arg1val);
	    }
	}
	exit(IO_SUCCESS);
}

doyear(year)
int		year;
/*
 * Print the calendar for an entire year.
 */
{
	register int	month;

	if (year < 1 || year > 9999)
	    usage("year", year);
	printf("\n\n\n%35d\n\n", year);
	for (month = 1; month <= 12; month += MONTHS_PER_LINE) {
	    printf("\n\n%12s%23s%23s\n",
		    xmonthname(month, year),
		    xmonthname(month+1, year),
		    xmonthname(month+2, year));
	    printf("%s   %s   %s\n", weekday, weekday, weekday);
	    calendar(year, month+0, 0);
	    calendar(year, month+1, 1);
	    calendar(year, month+2, 2);
	    output(3);
#if MONTHS_PER_LINE != 3
	    << error, the above wont work >>
#endif
	}
	printf("\n\n\n");
}

do3months(thisyear, thismonth)
int		thisyear;
register int	thismonth;
/*
 * Do last month, this month, and next month.
 */
{
	int		lastmonth;
	int		lastyear;
	int		nextmonth;
	int		nextyear;

/*
 * Range check year and month.  Avoid wraps that would
 * cause embarrassment.
 */
	if (thisyear < 2 || thisyear > 9998)
	    usage("year", thisyear);
	if (thismonth <= 0 || thismonth > 12)
	    usage("month", thismonth);

	lastyear = nextyear = thisyear;
	if ((lastmonth = thismonth - 1) == 0) {
	    lastmonth = 12;
	    lastyear--;
	}
	if ((nextmonth = thismonth + 1) == 13) {
	    nextmonth = 1;
	    nextyear++;
	}
	printf("%9s%5d%18s%5d%18s%5d\n",
		xmonthname(lastmonth, lastyear), lastyear,
		xmonthname(thismonth, thisyear), thisyear,
		xmonthname(nextmonth, nextyear), nextyear);
	printf("%s   %s   %s\n", weekday, weekday, weekday);
	calendar(lastyear, lastmonth, 0);
	calendar(thisyear, thismonth, 1);
	calendar(nextyear, nextmonth, 2);
	output(3);
#if MONTHS_PER_LINE != 3
	<< error, the above wont work >>
#endif
	printf("\n\n\n");
}
	
output(nmonths)
int		nmonths;		/* Number of months to do	*/
/*
 * Clean up and output the text.
 */
{
	register int	week;
	register int	month;
	register char	*outp;

	for (week = 0; week < WEEKS_PER_MONTH; week++) {
	    outp = outline;
	    for (month = 0; month < nmonths; month++) {
		/*
		 * The -1 in the following removes
		 * the unwanted leading blank from
		 * the entry for Sunday.
		 */
		sprintf(outp, "%.*s%*s",
		    DAYS_PER_WEEK * ENTRY_SIZE - 1,
		    &layout[month][week][0][1],
		    MONTH_SPACE, "");
		outp += (DAYS_PER_WEEK * ENTRY_SIZE) + MONTH_SPACE - 1;
	    }
	    while (outp > outline && outp[-1] == ' ')
		outp--;
	    *outp = EOS;
	    puts(outline);
	}
}

calendar(year, month, index)
int		year;
int		month;
int		index;		/* Which of the three months		*/
/*
 * Actually build the calendar for this month.
 */
{
	register char	*tp;
	int		week;
	register int	wday;
	register int	today;

	setmonth(year, month);
	for (week = 0; week < WEEKS_PER_MONTH; week++) {
	    for (wday = 0; wday < DAYS_PER_WEEK; wday++) {
		tp = &layout[index][week][wday][0];
		*tp++ = ' ';
		today = getdate(week, wday);
		if (today <= 0) {
		    *tp++ = ' ';
		    *tp++ = ' ';
		}
		else if (today < 10) {
		    *tp++ = ' ';
		    *tp   = (today + '0');
		}
		else {
		    *tp++ = (today / 10) + '0';
		    *tp   = (today % 10) + '0';
		}
	    }
	}
}

usage(what, value)
char		*what;
int		value;
/*
 * Fatal parameter error
 */
{
	fprintf(stderr, "Calendar parameter error: bad %s: %d\n",
	    what, value);
	fprintf(stderr, "Usage: \"calend month\" or \"calend year month\"\n");
	fprintf(stderr, "Year and month are integers.\n");
	exit(IO_ERROR);
}

/*
 * Calendar routines, intended for eventual porting to TeX
 *
 * date(year, month, week, wday)
 *	Returns the date on this week (0 is first, 5 last possible)
 *	and day of the week (Sunday == 0)
 *	Note: January is month 1.
 *
 * setmonth(year, month)
 *	Parameters are as above, sets getdate() for this month.
 *
 * int
 * getdate(week, wday)
 *	Parameters are as above, uses the data set by setmonth()
 */

/*
 * This structure is used to pass data between setmonth() and getdate().
 * It needs considerable expansion if the Julian->Gregorian change is
 * to be extended to other countries.
 */

static struct {
    int		feb;		/* Days in February for this month	*/
    int		sept;		/* Days in September for this month	*/
    int		days_in_month;	/* Number of days in this month		*/
    int		dow_first;	/* Day of week of the 1st day in month	*/
} info;

static int day_month[] = {	/* 30 days hath September...		*/
	0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

int
date(year, month, week, wday)
int		year;		/* Calendar date being computed		*/
int		month;		/* January == 1				*/
int		week;		/* Week in the month 0..5 inclusive	*/
int		wday;		/* Weekday, Sunday == 0			*/
/*
 * Return the date of the month that fell on this week and weekday.
 * Return zero if it's out of range.
 */
{
	setmonth(year, month);
	return (getdate(week, wday));
}

setmonth(year, month)
int		year;			/* Year to compute		*/
int		month;			/* Month, January is month 1	*/
/*
 * Setup the parameters needed to compute this month
 * (stored in the info structure).
 */
{
	register int		i;

	if (month < 1 || month > 12) {	/* Verify caller's parameters	*/
	    info.days_in_month = 0;	/* Garbage flag			*/
	    return;
	}
/* mod for lunar.c */
	solar.year = year;
	solar.month = month;
	solar.hour = 0;
/* only solar.day left to set in getdate */
	info.dow_first = Jan1(year);	/* Day of January 1st for now	*/
	info.feb = 29;			/* Assume leap year		*/
	info.sept = 30;			/* Assume normal year		*/
	/*
	 * Determine whether it's an ordinary year, a leap year
	 * or the magical calendar switch year of 1752.
	 */
	switch ((Jan1(year + 1) + 7 - info.dow_first) % 7) {
	case 1:				/* Not a leap year		*/
	    info.feb = 28;
	case 2:				/* Ordinary leap year		*/
	    break;

	default:			/* The magical moment arrives	*/
	    info.sept = 19;		/* 19 days hath September	*/
	    break;
	}
	info.days_in_month =
	      (month == 2) ? info.feb
	    : (month == 9) ? info.sept
	    : day_month[month];
	for (i = 1; i < month; i++) {
	    switch (i) {		/* Special months?		*/
	    case 2:			/* February			*/
		info.dow_first += info.feb;
		break;

	    case 9:
		info.dow_first += info.sept;
		break;

	    default:
		info.dow_first += day_month[i];
		break;
	    }
	}
	info.dow_first %= 7;		/* Now it's Sunday to Saturday	*/
}

int
getdate(week, wday)
int		week;
int		wday;
{
	register int	today;

	/*
	 * Get a first guess at today's date and make sure it's in range.
	 */
	today = (week * 7) + wday - info.dow_first + 1;
	if (today <= 0 || today > info.days_in_month)
	    return (0);
	else if (info.sept == info.days_in_month && info.sept == 19 
		 && today >= 3)		/* The magical month?	*/
/* mod for lunar.c */
	    return (solar.day = today + 11,
		Solar2Lunar(),
		lunar.day);	/* If so, some dates changed	*/
	else				/* Otherwise,			*/
	    return (solar.day = today,
		Solar2Lunar(),
		lunar.day);		/* Return the date		*/
}

static int
Jan1(year)
int		year;
/*
 * Return day of the week for Jan 1 of the specified year.
 */
{
	register int	day;

	day = year + 4 + ((year + 3) / 4);	/* Julian Calendar	*/
	if (year > 1800) {			/* If it's recent, do	*/
	    day -= ((year - 1701) / 100);	/* Clavian correction	*/
	    day += ((year - 1601) / 400);	/* Gregorian correction	*/
	}
	if (year > 1752)			/* Adjust for Gregorian	*/
	    day += 3;				/* calendar		*/
	return (day % 7);
}

SHAR_EOF
if test 10062 -ne "`wc -c < 'hancal.c'`"
then
	echo shar: "error transmitting 'hancal.c'" '(should have been 10062 characters)'
fi
fi
echo shar: "extracting 'lunar.1'" '(2938 characters)'
if test -f 'lunar.1'
then
	echo shar: "will not over-write existing file 'lunar.1'"
else
cat << \SHAR_EOF > 'lunar.1'
.TH lunar 1 "23 July 1992"
.SH NAME
lunar (version 2.1) \- a calendar conversion utility
.SH SYNTAX
.B lunar
[
.B\-h
] [
.B\-b
] [
.B\-i
] [
.B\-l
]
.I year month day
[
.I hour
]
.SH DESCRIPTION
The
.PN lunar
program performs date conversion between the Gregorian Solar Calendar (SC)
and the Chinese Lunar Calendar (LC).
Given a date in either calendar, the program also
outputs the corresponding "shengxiao" (animal of the year)
and "ganzhi" characters.
The date range currently covered is from about 1900 A.D. to 2049 A.D.
.PP
For the sake of convenience, we choose the convention such that the solar 
and lunar year numbers of the first day of a lunar year are the same.
For example, SC 1991.2.15 is LC 1991.1.1,
while SC 1991.2.14 is LC 1990.12.30.
Moreover, we choose the convention such that the solar and lunar hour numbers
(in 24-hour clock) of a date are the same, although a lunar day starts
at 23:00 of a solar day. This means that SC 1991.2.15.23 is LC 1991.1.2.23,
while SC 1991.2.16.0 is LC 1991.1.2.0,
and SC 1991.2.16.1 is LC 1991.1.2.1.
.PP
The standard time of the Lunar Calendar is
Beijing (Hong Kong) Standard Time, not GMT.
Be sure to adjust appropriately for other time zones
and "Day-light Saving Time".
.PP
In the Lunar Calendar,
a normal year has 12 months, and a leap year (run-nian) has 13 months,
where the extra month is called a "leap month" (run-yue).
For example, the leap month that follows immediately the 6-th lunar month
is called the 6-th leap month.
A (leap) month is either a short or long one, which has 29 or 30 days
respectively.
.PP
There are 10 gan's and 12 zhi's.
The ganzhi labeling of the year, month, day and hour of a date
is a member of the Cartesian product GxGxGxG, where G = {1,2,...,60}.
For example, "jia-zi" is 1, "yi-chou" is 2, and so on.
The ganzhi of the j-th leap month is the same as that of the j-th month.

The possible options are
.IP b
output ganzhi in special "bitmap" characters.
.IP h
output hanzi or Chinese characters encoded in (highest-bit-set) GB code.
.IP i
convert a lunar date to solar date.
The default is to convert a solar date to a lunar date.
.IP l
indicate the month is a lunar leap month.
This option is meaningful only when the "-i" option is used.
.SH COPYRIGHT
Copyright (C) 1988, 1989, 1991, 1992	Fung F. Lee and Ricky Yeung 
.sp
All rights reserved.
Permission to copy and distribute verbatim copies of the source code
and accompanied documents for non-commercial purposes is granted,
but changing them is not allowed.
There is absolutely no warranty for this program.
.SH AUTHORS
Fung F. Lee and Ricky Yeung
.SH ACKNOWLEDGEMENT
The special "bitmap" file "lunar.bitmap" was contributed by Weimin Liu.

Special thanks to Hwei Chen Ti who extended the tables from 2001 to 2049.
.SH BUGS
Bug reports and comments should be sent to Ricky.Yeung@Eng.Sun.Com or
lee@umunhum.stanford.edu.
.SH DISCLAIMER
This software has no connection with our employers.

SHAR_EOF
if test 2938 -ne "`wc -c < 'lunar.1'`"
then
	echo shar: "error transmitting 'lunar.1'" '(should have been 2938 characters)'
fi
fi
echo shar: "extracting 'lunar.bitmap'" '(1731 characters)'
if test -f 'lunar.bitmap'
then
	echo shar: "will not over-write existing file 'lunar.bitmap'"
else
cat << \SHAR_EOF > 'lunar.bitmap'
 /_______
/    |
 .___|___
 |   |  
_|___|____
     |
     |
  |-----|
  |     |
  |-----|
  |_____|
  |     |
  |     |
 /    \_|
  ._____.
  |     |
  |     |
  |_____|
  |     |
  |     |
  |_____|
       |
|-|  --|--
|_| ---`---     
| | ____|__
|-|  \  |
        |
      \_|
 |---:---|
 |   |   |
 |---|---|
 |   |   |
 |---|---|
     |
     |
 ______.
      /
     /
    /
   /
  /      |
 |______/
 _________
     |
 |---|---|
 |   ^   |
 |  / \  |
 |       |
 |     \_|
 _________
     |
     |
     |
     |
     |
   \_|
     |   \
 |---+----
 |   |   .
 |    \ /
 |     X
 |    / \
/        \_
________.
        |
        |
--------|
|
|
|________|
 .____\____
 | ___|__.
 |  __|__|_
 | ___|__|
 |    ^  
 |   / \
/   /   \_
 ____\____
   \   /
  -------
     |
 ----+----
     |
     |
  ____.-'
     |
     |    
 ----+---'
     |
     |
  -------
  ___ ___
    / \  
 \_/___\/
  /__|__\
_/   ^   \_
    / \
  _/   \_
  ._____.
       /
      /
 ____|___.
     |
     |
   \_|
  ______.
    |   |
    |   |
  __|___|
    |   |
    |   |
 __/___/__
.____\____.
| _______ '
  .__|__.
  |__|__|
  |__|__|
   .   .
 _/     \_
._-' ____.
|  |  |  |
|  |  |  |
| .|  |  |
|/ |  |\_|
  /   |
 /    |
 ._______.
 |_______
 |________ 
 | | \  .
 | |  \/
 | |   \
/  |/   \_
_______.
|      |
|      |
|------'
|
|
|_______|.
  /______
 /   |
     |
 ----+----
     |
     |
     |
  ___|___
     |
-----+----'
   / |\
  /  | \
 /   |  \_
   \_|
 .___|___.
 |   |   |
 |___|___|
 |   |   |
 |___|___|
     |
     |
----------
 ._|__|_.
 | |  | |
 | |  | |
 |/    \|
 | ____ |
 |______|
     |   \
 |---+----
 |   |   .
 |__  \ /
 |     X
 |    / \
/        \_
_____\_____
   /  /
  /__/  /
    /  /
   /  /
  '  / \
  __/   \__
SHAR_EOF
if test 1731 -ne "`wc -c < 'lunar.bitmap'`"
then
	echo shar: "error transmitting 'lunar.bitmap'" '(should have been 1731 characters)'
fi
fi
echo shar: "extracting 'lunar.c'" '(18447 characters)'
if test -f 'lunar.c'
then
	echo shar: "will not over-write existing file 'lunar.c'"
else
cat << \SHAR_EOF > 'lunar.c'
char version[] = "Lunar Version 2.1 (July 23, 1992)";

/*----------------------------------------------------------------------------


  		Lunar 2.1: A Calendar Conversion Program
				for
	Gregorian Solar Calendar and Chinese Lunar Calendar
	---------------------------------------------------

	By Fung F. Lee and Ricky Yeung

	Copyright (C) 1988,1989,1991,1992  Fung F. Lee and Ricky Yeung

	All rights reserved.
	Permission to copy and distribute verbatim copies of this
	document for non-commercial purposes is granted, but changing
	it is not allowed.
	There is absolutely no warranty for this program.

	Please send your comments and suggestions to the authors:
	Fung F. Lee	lee@umunhum.stanford.edu
	Ricky Yeung	Ricky.Yeung@Eng.Sun.Com
	
	The special "bitmap" file "lunar.bitmap" was contributed
	by Weimin Liu (weimin@alpha.ece.jhu.edu).

	Special thanks to Hwei Chen Ti (chetihc@nuscc.nus.sg or
	CHETIHC@NUSVM.Bitnet) who extended the tables from 2001 to 2049. 

----------------------------------------------------------------------------*/

/*
This document contains Highest-bit-set GuoBiao (HGB) code, as adopted by
CCDOS on IBM PC compatibles, ChineseTalk 6.0 (GB version) on Macintosh,
and cxterm on UNIX and X window.  Hence, one may need to transfer this 
document as a **binary** file.

References:
1. "Zhong1guo2 yin1yang2 ri4yue4 dui4zhao4 wan4nian2li4" by Lin2 Qi3yuan2.
   !6VP9zRuQtHUTB6TUUMrDj@z!7#.AV
2. "Ming4li3 ge2xin1 zi3ping2 cui4yan2" by Xu2 Le4wu2.
   !6C|@m8oPBWSF=4bQT!7#.Pl
3. Da1zhong4 wan4nian2li4.
   !64sVZMrDj@z!7
*/ 


#include <stdio.h>
#include <string.h>

/* "Bitmap" constants */
#define	BMRow	7	/* number of rows for each bitmap */
#define	BMCol	11	/* number of columns for each bitmap */
#define	NBM	26	/* number of bitmaps */
#define NianBM  0
#define YueBM   1
#define RiBM    2
#define ShiBM   3
#define	GanBM	4
#define	ZhiBM	14

typedef struct {
int year, month, day, hour, weekday;
int leap;	/* the lunar month is a leap month */
} Date;

typedef char byte;

#include "tables.h"

static int daysInSolarMonth[13] = {
    0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

static int moon[2] = {29,30}; /* a short (long) lunar month has 29 (30) days */

static	char	*Gan[] = {
	"Jia3",	"Yi3",	 "Bing3", "Ding1", "Wu4",
	"Ji3",	"Geng1", "Xin1",  "Ren2",  "Gui3"
};

static	char	*Zhi[] = {
	"Zi3",	"Chou3", "Yin2",  "Mao3",  "Chen2", "Si4",
	"Wu3",	"Wei4",	 "Shen1", "You3",  "Xu1",   "Hai4"
};

static	char   *ShengXiao[] = {
    "Mouse", "Ox", "Tiger", "Rabbit", "Dragon", "Snake",
    "Horse", "Goat", "Monkey", "Rooster", "Dog", "Pig"
};

static char *weekday[] = {
    "Sunday", "Monday", "Tuesday", "Wednesday",
    "Thursday", "Friday", "Saturday"
};

static	char	*GanGB[] = {
    "<W", "RR", "1{", "6!", "Nl",
    "<:", "8}", "PA", "HI", "9o"
};

static	char	*ZhiGB[] = {
    "WS", "3s", "Rz", "C.", "3=", "KH",
    "Ng", "N4", "Ij", "SO", "Pg", ":%"
};

static	char   *ShengXiaoGB[] = {
    "Js", "E#", ";"", "MC", "Az", "I_",
    "Bm", "Qr", ":o", "<&", "97", "Vm"
};

static char *weekdayGB[] = {
    "HU", "R;", "6~", "H}",
    "KD", "Ne", "Ay"
};


Date solar, lunar, gan, zhi, gan2, zhi2, lunar2;

int ymonth[Nyear];	/* number of lunar months in the years */
int yday[Nyear];	/* number of lunar days in the years */
int mday[Nmonth+1];	/* number of days in the months of the lunar year */
int jieAlert;		/* if there is uncertainty in JieQi calculation */

int	showHZ = 0;			/* output in hanzi */
int	showBM = 0;			/* output in bitmap */
char	BMfile[] = "lunar.bitmap";	/* bit map file */
char	GZBM[NBM][BMRow][BMCol];	/* the bitmap array */
char	*progname;

void	Solar2Lunar(), Lunar2Solar();
long    Solar2Day(), Solar2Day1(), Lunar2Day();
void	Day2Lunar(), Day2Solar();
int     make_yday(), make_mday(), GZcycle();
void	CalGZ();
int	JieDate(), JieDate();
void    readBM(), display3();
void	Report(), ReportE(), ReportBM(), ReportGB();
void	usage(), Error();


void main(argc, argv)
int argc;
char *argv[];
{
    int year, month, day, hour, i, k, option, inverse=0, leap=0;
    int dateInfo[4];
    
    progname = "lunar";
    printf("%s\n\n", version);

    for (k=1; k<argc && argv[k][0]=='-'; k++)
    {
	option = argv[k][1];
	switch(option)
	{
	    case 'i': inverse = 1; break;
	    case 'l': if (inverse) leap=1; else usage(); break;
	    case 'h': showHZ = 1; break;
	    case 'b': showBM = 1; break;
	    default:  usage(); break;
	}
    }
    if (showBM) readBM();
    if (!((argc - k >= 3) && (argc - k <= 4))) usage();
    dateInfo[3] = 0;
    for (i=0; k<argc && i<4; k++, i++)
    {
	if (sscanf(argv[k], "%d", &dateInfo[i]) != 1)
	    usage();
    }
    year = dateInfo[0];
    month = dateInfo[1];
    day = dateInfo[2];
    hour = dateInfo[3];
    if (!(year>=Cyear && year<Cyear+Nyear))
	Error("Year out of range.");
    if (!(month>=1 && month<=12))
	Error("Month out of range.");
    if (!(day>=1 && day<=31) || (inverse && day>30))
	Error("Day out of range.");
    if (!(hour>=0 && hour<=23))
	Error("Hour out of range.");

    if (!inverse && year==SolarFirstDate.year &&
	CmpDate(month, day, SolarFirstDate.month, SolarFirstDate.day)<0)
	Error("Date out of range.");

    if (inverse)
    {
	lunar.year = year;
	lunar.month = month;
	lunar.day = day;
	lunar.hour = hour;
	lunar.leap = leap;
	Lunar2Solar();
    }
    else
    {
	solar.year = year;
	solar.month = month;
	solar.day = day;
	solar.hour = hour;
	Solar2Lunar();
    }
    Report();
}
 
void usage()
{
    printf("Usage:\n\n");
    printf("Solar->Lunar:\t%s [-h] [-b] year month day [hour]\n", progname);
    printf("\t\t(in Solar Calendar, 24 hour clock)\n\n");
    printf("Lunar->Solar:\t%s [-h] [-b] -i [-l] year month day [hour]\n",
	   progname);
    printf("\t\t(in Lunar Calendar, 24 hour clock)\n");
    printf("\t\t-l means the month is a leap month (\"run4 yue4\")\n\n");
    printf("\t\t-h means output in hanzi (GB)\n");
    printf("\t\t-b means output in \"bitmap\"\n\n");
    printf("Date range: about %d years from the Solar Date %d.%d.%d\n", Nyear,
	   SolarFirstDate.year, SolarFirstDate.month, SolarFirstDate.day);
    exit(1);
}


void Solar2Lunar()
{

    long offset;
    Date *d;

    offset = Solar2Day(&solar);
    solar.weekday = (offset + SolarFirstDate.weekday) % 7;
    
    /* A lunar day begins at 11 p.m. */
    if (solar.hour == 23)
	offset++;

    Day2Lunar(offset, &lunar);
    lunar.hour = solar.hour;
    CalGZ(offset, &lunar, &gan, &zhi);

    jieAlert = JieDate(&solar, &lunar2);
    lunar2.day = lunar.day;
    lunar2.hour = lunar.hour;
    CalGZ(offset, &lunar2, &gan2, &zhi2);
}


void Lunar2Solar()
{
    long offset;
    int adj;
    Date *d;

    /* A solar day begins at 12 a.m. */
    adj = (lunar.hour == 23)? -1 : 0;
    offset = Lunar2Day(&lunar);
    solar.weekday = (offset+ adj + SolarFirstDate.weekday) % 7;
    Day2Solar(offset + adj, &solar);
    solar.hour = lunar.hour;
    CalGZ(offset, &lunar, &gan, &zhi);

    jieAlert = JieDate(&solar, &lunar2);
    lunar2.day = lunar.day;
    lunar2.hour = lunar.hour;
    CalGZ(offset, &lunar2, &gan2, &zhi2);
}


#define	LeapYear(y)	(((y)%4==0) && ((y)%100!=0) || ((y)%400==0))
#define BYEAR		1201
/* BYEAR % 4 == 1  and BYEAR % 400 == 1 for easy calculation of leap years */
/* assert(BYEAR <= SolarFirstDate.year) */

long Solar2Day(d)
Date *d;
{
    return (Solar2Day1(d) - Solar2Day1(&SolarFirstDate));
}


/* Compute the number of days from the Solar date BYEAR.1.1 */
long Solar2Day1(d)
Date *d;
{
    long offset, delta;
    int i;

    delta = d->year - BYEAR;
    if (delta<0) Error("Internal error: pick a larger constant for BYEAR.");
    offset = delta * 365 + delta / 4 - delta / 100 + delta / 400;
    for (i=1; i< d->month; i++)
    	offset += daysInSolarMonth[i];
    if ((d->month > 2) && LeapYear(d->year))
	offset++;
    offset += d->day - 1;

    if ((d->month == 2) && LeapYear(d->year))
    {
	if (d->day > 29) Error("Day out of range.");
    }
    else if (d->day > daysInSolarMonth[d->month]) Error("Day out of range.");
    return offset;
}


/* Compute offset days of a lunar date from the beginning of the table */
long Lunar2Day(d)
Date *d;
{
    long offset = 0;
    int year, i, m, nYear, leapMonth;

    nYear = make_yday();
    year = d->year - LunarFirstDate.year;
    for (i=0; i<year; i++)
	offset += yday[i];

    leapMonth = make_mday(year);
    if ((d->leap) && (leapMonth!=d->month))
    {
	printf("%d is not a leap month in year %d.\n", d->month, d->year);
	exit(1);
    }
    for (m=1; m<d->month; m++)
	offset += mday[m];
    if (leapMonth && 
	((d->month>leapMonth) || (d->leap && (d->month==leapMonth))))
	offset += mday[m++];
    offset += d->day - 1;

    if (d->day > mday[m]) Error("Day out of range.");

    return offset;
}


void Day2Lunar(offset, d)
long offset;
Date *d;

{
    int i, m, nYear, leapMonth;
    
    nYear = make_yday();
    for (i=0; i<nYear && offset > 0; i++)
	offset -= yday[i];
    if (offset<0)
	offset += yday[--i];
    if (i==Nyear) Error("Year out of range.");
    d->year = i + LunarFirstDate.year;

    leapMonth = make_mday(i);
    for (m=1; m<=Nmonth && offset>0; m++)
	offset -= mday[m];
    if (offset<0)
	offset += mday[--m];

    d->leap = 0;	/* don't know leap or not yet */

    if (leapMonth>0)	/* has leap month */
    {
	/* if preceeding month number is the leap month,
	   this month is the actual extra leap month */
	d->leap = (leapMonth == (m - 1));

	/* month > leapMonth is off by 1, so adjust it */
	if (m > leapMonth) --m;
    }

    d->month = m;
    d->day = offset + 1;
}


void Day2Solar(offset, d)
long offset;
Date *d;
{
    int	i, m, days;

    /* offset is the number of days from SolarFirstDate */
    offset -= Solar2Day(&LunarFirstDate);  /* the argument is negative */
    /* offset is now the number of days from SolarFirstDate.year.1.1 */

    for (i=SolarFirstDate.year;
         (i<SolarFirstDate.year+Nyear) && (offset > 0);	 i++) 
	offset -= 365 + LeapYear(i);
    if (offset<0)
    {
	--i; 	/* LeapYear is a macro */
	offset += 365 + LeapYear(i);
    }
    if (i==(SolarFirstDate.year + Nyear)) Error("Year out of range.");
    d->year = i;
    
    /* assert(offset<(365+LeapYear(i))); */
    for (m=1; m<=12; m++)
    {
	days = daysInSolarMonth[m];
	if ((m==2) && LeapYear(i))	/* leap February */
	    days++;
	if (offset<days)
	{
	    d->month = m;
	    d->day = offset + 1;
	    return;
	}
	offset -= days;
    }
}


int GZcycle(g, z)
int g, z;
{
    int gz;

    for (gz = z; gz % 10 != g && gz < 60; gz += 12) ;
    if (gz >= 60) printf("internal error\n");
    return gz+1;
}
	     

void CalGZ(offset, d, g, z)
long offset;
Date *d, *g, *z;
{
    int	year, month;
        
    year = d->year - LunarFirstDate.year;
    month = year * 12 + d->month - 1;   /* leap months do not count */

    g->year = (GanFirstDate.year + year) % 10;
    z->year = (ZhiFirstDate.year + year) % 12;
    g->month = (GanFirstDate.month + month) % 10;
    z->month = (ZhiFirstDate.month + month) % 12;
    g->day = (GanFirstDate.day + offset) % 10;
    z->day = (ZhiFirstDate.day + offset) % 12;
    z->hour = ((d->hour + 1) / 2) % 12;
    g->hour = (g->day * 12 + z->hour) % 10;
}


void Error(s)
char	*s;
{
    printf("%s\n",s);
    exit(1);
}


/* Compare two dates and return <,=,> 0 if the 1st is <,=,> the 2nd */
int CmpDate(month1, day1, month2, day2)
int month1, day1, month2, day2;
{
    if (month1!=month2) return(month1-month2);
    if (day1!=day2) return(day1-day2);
    return(0);
}


/*
   Given a solar date, find the "lunar" date for the purpose of
   calculating the "4-columns" by taking jie into consideration.
*/
int JieDate(ds, dl)
Date *ds, *dl;
{
    int m, flag;

    if (ds->month==1)
    {
	flag = CmpDate(ds->month, ds->day,
		       1, fest[ds->year - SolarFirstDate.year - 1][11]);
	if (flag<0) dl->month = 11;
	else if (flag>0) dl->month = 12;
	dl->year = ds->year - 1;
	return(flag==0);
    }
    for (m=2; m<=12; m++)
    {
	flag = CmpDate(ds->month, ds->day,
		       m, fest[ds->year - SolarFirstDate.year][m-2]);
	if (flag==0) m++;
	if (flag<=0) break;
    }
    dl->month = (m-2) % 12;
    dl->year = ds->year;
    if ((dl->month)==0)
    {
	dl->year = ds->year - 1;
	dl->month = 12;
    }
    return(flag==0);
}


/* Compute the number of days in each lunar year in the table */
int make_yday()
{
    int year, i, leap;
    long code;
    
    for (year = 0; year < Nyear; year++)
    {
	code = yearInfo[year];
	leap = code & 0xf;
	yday[year] = 0;
	if (leap != 0)
	{
	    i = (code >> 16) & 0x1;
	    yday[year] += moon[i];
	}
	code >>= 4;
	for (i = 0; i < Nmonth-1; i++)
	{
	    yday[year] += moon[code&0x1];
	    code >>= 1;
	}
	ymonth[year] = 12;
	if (leap != 0) ymonth[year]++;
    }
    return Nyear;
}


/* Compute the days of each month in the given lunar year */
int make_mday(year)
int year;
{
    int i, leapMonth;
    long code;
    
    code = yearInfo[year];
    leapMonth = code & 0xf;
    /* leapMonth == 0 means no leap month */
    code >>= 4;
    if (leapMonth == 0)
    {
	mday[Nmonth] = 0;
	for (i = Nmonth-1; i >= 1; i--)
	{
	    mday[i] = moon[code&0x1];
	    code >>= 1;
	}
    }
    else
    {
	/* 
	  There is a leap month (run4 yue4) L in this year.
	  mday[1] contains the number of days in the 1-st month;
	  mday[L] contains the number of days in the L-th month;
	  mday[L+1] contains the number of days in the L-th leap month;
	  mday[L+2] contains the number of days in the L+1 month, etc.

	  cf. yearInfo[]: info about the leap month is encoded differently.
	*/
	i = (yearInfo[year] >> 16) & 0x1;
	mday[leapMonth+1] = moon[i];
	for (i = Nmonth; i >= 1; i--)
	{
	    if (i == leapMonth+1) i--;
	    mday[i] = moon[code&0x1];
	    code >>= 1;
	}
    }
    return leapMonth;
}


void Report()
{
    if (showHZ)
	ReportGB();
    else if (showBM)
	ReportBM();
    else
	ReportE();
}


void ReportGB()
{
    printf("%s%d%s%2d%s%2d%s%2d%s%s%s\n", "Qt@z#:!!",
	   solar.year, "Dj", solar.month, "TB", solar.day,
	   "HU", solar.hour, "J1!!",
	   "PGFZ", weekdayGB[solar.weekday]); 
    printf("%s%d%s%s%2d%s%2d%s%s%s%s%s\n", "Ru@z#:!!",
	   lunar.year, "Dj", (lunar.leap? "Hr":""),
	   lunar.month, "TB", lunar.day, "HU", 
	   ZhiGB[zhi.hour], "J1!!",
	   "IzP$Jt", ShengXiaoGB[zhi.year]);
    printf("%s%s%s%s%s%s%s%s%s%s%s%s%s\n", "8IV'#:!!",
	   GanGB[gan.year], ZhiGB[zhi.year], "Dj!!",
	   GanGB[gan.month], ZhiGB[zhi.month], "TB!!",
	   GanGB[gan.day], ZhiGB[zhi.day], "HU!!",
	   GanGB[gan.hour], ZhiGB[zhi.hour], "J1!!");
    printf("%s%s%s%s%s%s%s%s%s%s%s%s%s\n",
	   "SCKDVyIqKcMFKcV.J13=0KWV#:!!",
	   GanGB[gan2.year], ZhiGB[zhi2.year], "Dj!!",
	   GanGB[gan2.month], ZhiGB[zhi2.month], "TB!!",
	   GanGB[gan2.day], ZhiGB[zhi2.day], "HU!!",
	   GanGB[gan2.hour], ZhiGB[zhi2.hour], "J1!!");
    if (jieAlert)
    {
	printf("* %s, %s\n", "JGHUN*=Z",
	       "TBVy?ID\R*P^8D");
	if (lunar2.month==1)
	    printf("* %s\n", "DjVyR`?ID\R*P^8D");
	printf("* %s\n", "Gk2iSP=ZFxJ1<dV.MrDj@z");
    }
}


void ReportE()
{
    printf("Solar : %d.%d.%d.%d\t%s\n", solar.year, solar.month, solar.day,
	   solar.hour, weekday[solar.weekday]);
    printf("Lunar : %d.%d%s.%d.%d\tShengXiao: %s\n",
	   lunar.year, lunar.month, (lunar.leap?"Leap":""), lunar.day,
	   lunar.hour, ShengXiao[zhi.year] );
    printf("GanZhi: %s-%s.%s-%s.%s-%s.%s-%s\n",
	   Gan[gan.year], Zhi[zhi.year], Gan[gan.month], Zhi[zhi.month],
	   Gan[gan.day], Zhi[zhi.day], Gan[gan.hour], Zhi[zhi.hour]);
    printf("        (GanZhi Order)\t%d-%d.%d-%d.%d-%d.%d-%d\n",
	   gan.year+1, zhi.year+1, gan.month+1, zhi.month+1,
	   gan.day+1, zhi.day+1, gan.hour+1, zhi.hour+1);
    printf("        (JiaZi Cycle)\t%d.%d.%d.%d\n\n",
	   GZcycle(gan.year, zhi.year), GZcycle(gan.month, zhi.month),
	   GZcycle(gan.day, zhi.day), GZcycle(gan.hour, zhi.hour));
    printf("BaZi (8-characters) according to 'Four Column Calculation':\n");
    printf("        %s-%s.%s-%s.%s-%s.%s-%s\n",
	   Gan[gan2.year], Zhi[zhi2.year], Gan[gan2.month], Zhi[zhi2.month],
	   Gan[gan2.day], Zhi[zhi2.day], Gan[gan2.hour], Zhi[zhi2.hour]);
    printf("        (GanZhi Order)\t%d-%d.%d-%d.%d-%d.%d-%d\n",
	   gan2.year+1, zhi2.year+1, gan2.month+1, zhi2.month+1,
	   gan2.day+1, zhi2.day+1, gan2.hour+1, zhi2.hour+1);
    printf("        (JiaZi Cycle)\t%d.%d.%d.%d\n\n",
	   GZcycle(gan2.year, zhi2.year), GZcycle(gan2.month, zhi2.month),
	   GZcycle(gan2.day, zhi2.day), GZcycle(gan2.hour, zhi2.hour));
    if (jieAlert)
    {
	printf("* The month column may need adjustment because the date falls on a jie.\n");
	if (lunar2.month==1)
	    printf("* The day column may need adjustment, too.\n");
	printf("* Please consult a detailed conversion table.\n");
    }
}


void ReportBM()
{
    printf("Solar : %d.%d.%d.%d\t%s\n", solar.year, solar.month, solar.day,
	   solar.hour, weekday[solar.weekday]);
    printf("Lunar : %d.%d%s.%d.%d\tShengXiao: %s\n",
	   lunar.year, lunar.month, (lunar.leap?"Leap":""), lunar.day,
	   lunar.hour, ShengXiao[zhi.year] );
    printf("GanZhi: \n\n");
    display3(gan.year+GanBM, zhi.year+ZhiBM, NianBM);
    display3(gan.month+GanBM, zhi.month+ZhiBM, YueBM);
    display3(gan.day+GanBM, zhi.day+ZhiBM, RiBM);
    display3(gan.hour+GanBM, zhi.hour+ZhiBM, ShiBM);
    printf("\nBaZi  : \n\n");
    display3(gan2.year+GanBM, zhi2.year+ZhiBM, NianBM);
    display3(gan2.month+GanBM, zhi2.month+ZhiBM, YueBM);
    display3(gan2.day+GanBM, zhi2.day+ZhiBM, RiBM);
    display3(gan2.hour+GanBM, zhi2.hour+ZhiBM, ShiBM);
    if (jieAlert)
    {
	printf("* The month column may need adjustment because the date falls on a jie.\n");
	if (lunar2.month==1)
	    printf("* The day column may need adjustment, too.\n");
	printf("* Please consult a detailed conversion table.\n");
    }
}


void readBM()
{
    int	i, j, k, m, c;
    FILE *fp;

    if ((fp=fopen(BMfile,"r"))==NULL)
    {
	printf("Bitmap file '%s' not found.\n",BMfile);
	exit(1);
    }
    for (i=0; i<NBM; i++)
      for (j=0; j<BMRow; j++)
      {
	  k = 0;
	  for (;;)
	  {
	      c = getc(fp);
	      if ((c==EOF) || (c=='\n')) break;
	      GZBM[i][j][k++] = c;
	  }
	  for (m=k; m<BMCol; m++) GZBM[i][j][m] = ' ';
      }
    fclose(fp);
}


/* Display three ganzhi characters in a row */
void display3(i, j, k)
int i,j,k;
{
    int	r,c;

    for (r=0; r<BMRow; r++)
    {
	for (c=0; c<BMCol; c++) putchar(GZBM[i][r][c]);
	printf("  ");
	for (c=0; c<BMCol; c++) putchar(GZBM[j][r][c]);
	printf("    ");
	for (c=0; c<BMCol; c++) putchar(GZBM[k][r][c]);
	putchar('\n');
    }
    putchar('\n');
}


SHAR_EOF
if test 18447 -ne "`wc -c < 'lunar.c'`"
then
	echo shar: "error transmitting 'lunar.c'" '(should have been 18447 characters)'
fi
fi
echo shar: "extracting 'readme.txt'" '(357 characters)'
if test -f 'readme.txt'
then
	echo shar: "will not over-write existing file 'readme.txt'"
else
cat << \SHAR_EOF > 'readme.txt'
This is a public-domain reimplementation of the Unix "cal" calendar program.
The inner-loop -- that puts a date into the calendar -- was designed
for eventual rewriting in LaTeX (but I haven't gotten that working yet).

If you aren't interested in Julian/Gregorian hacks, the code can
be considerably simplified.

Happy New Year.

Martin Minow
decvax!minow
SHAR_EOF
if test 357 -ne "`wc -c < 'readme.txt'`"
then
	echo shar: "error transmitting 'readme.txt'" '(should have been 357 characters)'
fi
fi
echo shar: "extracting 'tables.h'" '(11140 characters)'
if test -f 'tables.h'
then
	echo shar: "will not over-write existing file 'tables.h'"
else
cat << \SHAR_EOF > 'tables.h'
/* 
 * tables.h: contains tables and parameters for lunar.c
 */
#define Cyear	1900	/* Note that LC1900.1.1 is SC1900.1.31 */
#define Nyear	150	/* number of years covered by the table */
#define Nmonth  13	/* maximum number of months in a lunar year */

static Date SolarFirstDate = {
    /* Wednesday, 12 a.m., 31 January, 1900 */
    1900, 1, 31, 0, 3, 0
    };

static Date LunarFirstDate = {
    /* Wednesday, 12 a.m., First day, First month, 1900 */
    1900, 1, 1, 0, 3, 0
    };

static Date GanFirstDate = {
    /* geng1-nian2 wu4-yue4 jia3-ri4 jia3-shi2 */
       6,          4,       0,       0,           3, 0
    };

static Date ZhiFirstDate = {
    /* zi3-nian2 yin2-yue4 chen2-ri4 zi3-shi2 */
       0,        2,        4,        0,           3, 0
    };

static long yearInfo[Nyear] = {
    /* encoding:
		b bbbbbbbbbbbb bbbb
       bit#    	1 111111000000 0000
	        6 543210987654 3210
    		. ............ ....
       month#	  000000000111
	        M 123456789012   L
				
    b_j = 1 for long month, b_j = 0 for short month
    L is the leap month of the year if 1<=L<=12; NO leap month if L = 0.
    The leap month (if exists) is long one iff M = 1.
    */
    					0x04bd8,	/* 1900 */
    0x04ae0, 0x0a570, 0x054d5, 0x0d260, 0x0d950,	/* 1905 */
    0x16554, 0x056a0, 0x09ad0, 0x055d2, 0x04ae0,	/* 1910 */
    0x0a5b6, 0x0a4d0, 0x0d250, 0x1d255, 0x0b540,	/* 1915 */
    0x0d6a0, 0x0ada2, 0x095b0, 0x14977, 0x04970,	/* 1920 */
    0x0a4b0, 0x0b4b5, 0x06a50, 0x06d40, 0x1ab54,	/* 1925 */
    0x02b60, 0x09570, 0x052f2, 0x04970, 0x06566,	/* 1930 */
    0x0d4a0, 0x0ea50, 0x06e95, 0x05ad0, 0x02b60,	/* 1935 */
    0x186e3, 0x092e0, 0x1c8d7, 0x0c950, 0x0d4a0,	/* 1940 */
    0x1d8a6, 0x0b550, 0x056a0, 0x1a5b4, 0x025d0,	/* 1945 */
    0x092d0, 0x0d2b2, 0x0a950, 0x0b557, 0x06ca0,	/* 1950 */
    0x0b550, 0x15355, 0x04da0, 0x0a5d0, 0x14573,	/* 1955 */
    0x052d0, 0x0a9a8, 0x0e950, 0x06aa0, 0x0aea6,	/* 1960 */
    0x0ab50, 0x04b60, 0x0aae4, 0x0a570, 0x05260,	/* 1965 */
    0x0f263, 0x0d950, 0x05b57, 0x056a0, 0x096d0,	/* 1970 */
    0x04dd5, 0x04ad0, 0x0a4d0, 0x0d4d4, 0x0d250,	/* 1975 */
    0x0d558, 0x0b540, 0x0b5a0, 0x195a6, 0x095b0,	/* 1980 */
    0x049b0, 0x0a974, 0x0a4b0, 0x0b27a, 0x06a50,	/* 1985 */
    0x06d40, 0x0af46, 0x0ab60, 0x09570, 0x04af5,	/* 1990 */
    0x04970, 0x064b0, 0x074a3, 0x0ea50, 0x06b58,	/* 1995 */
    0x055c0, 0x0ab60, 0x096d5, 0x092e0, 0x0c960,	/* 2000 */
    0x0d954, 0x0d4a0, 0x0da50, 0x07552, 0x056a0,	/* 2005 */
    0x0abb7, 0x025d0, 0x092d0, 0x0cab5, 0x0a950,	/* 2010 */
    0x0b4a0, 0x0baa4, 0x0ad50, 0x055d9, 0x04ba0,	/* 2015 */
    0x0a5b0, 0x15176, 0x052b0, 0x0a930, 0x07954,	/* 2020 */
    0x06aa0, 0x0ad50, 0x05b52, 0x04b60, 0x0a6e6,	/* 2025 */
    0x0a4e0, 0x0d260, 0x0ea65, 0x0d530, 0x05aa0,	/* 2030 */
    0x076a3, 0x096d0, 0x04bd7, 0x04ad0, 0x0a4d0,	/* 2035 */
    0x1d0b6, 0x0d250, 0x0d520, 0x0dd45, 0x0b5a0,	/* 2040 */
    0x056d0, 0x055b2, 0x049b0, 0x0a577, 0x0a4b0,	/* 2045 */
    0x0aa50, 0x1b255, 0x06d20, 0x0ada0			/* 2049 */
};

/*
  In "4-column" calculation, a "mingli" (fortune-telling) calculation,
  the beginning of a month is not the first day of the month as in
  the Lunar Calendar; it is instead governed by "jie2" (festival).
  Interestingly, in the Solar calendar, a jie always comes around certain
  day. For example, the jie "li4chun1" (beginning of spring) always comes
  near Feburary 4 of the Solar Calendar. 

  Meaning of array fest:
  Each element, fest[i][j] stores the jie day (in term of the following Solar
  month) of the lunar i-th year, j-th month.
  For example, in 1992, fest[92][0] is 4, that means the jie "li4chun1"
  (beginning of spring) is on Feb. 4, 1992; fest[92][11] is 5, that means
  the jie of the 12th lunar month is on Jan. 5, 1993.
*/

static byte fest[Nyear][12] = {
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1900 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1901 */
{5, 6, 6, 6, 7, 8, 8, 8, 9, 8, 8, 6},	/* 1902 */
{5, 7, 6, 7, 7, 8, 9, 9, 9, 8, 8, 7},	/* 1903 */
{5, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1904 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1905 */
{5, 6, 6, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1906 */
{5, 7, 6, 7, 7, 8, 9, 9, 9, 8, 8, 7},	/* 1907 */
{5, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1908 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1909 */
{5, 6, 6, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1910 */
{5, 7, 6, 7, 7, 8, 9, 9, 9, 8, 8, 7},	/* 1911 */
{5, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1912 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1913 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1914 */
{5, 6, 6, 6, 7, 8, 8, 9, 9, 8, 8, 6},	/* 1915 */
{5, 6, 5, 6, 6, 7, 8, 8, 8, 8, 7, 6},	/* 1916 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 7, 6},	/* 1917 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1918 */
{5, 6, 6, 6, 7, 8, 8, 9, 9, 8, 8, 6},	/* 1919 */
{5, 6, 5, 6, 6, 7, 8, 8, 8, 8, 7, 6},	/* 1920 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 9, 7, 6},	/* 1921 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1922 */
{5, 6, 6, 6, 7, 8, 8, 9, 9, 8, 8, 6},	/* 1923 */
{5, 6, 5, 6, 6, 7, 8, 8, 8, 8, 7, 6},	/* 1924 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 7, 6},	/* 1925 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1926 */
{5, 6, 6, 6, 7, 8, 8, 8, 9, 8, 8, 6},	/* 1927 */
{5, 6, 5, 6, 6, 7, 8, 8, 8, 7, 7, 6},	/* 1928 */
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1929 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1930 */
{5, 6, 6, 6, 7, 8, 8, 8, 9, 8, 8, 6},	/* 1931 */
{5, 6, 5, 6, 6, 7, 8, 8, 8, 7, 7, 6},	/* 1932 */
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1933 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1934 */
{5, 6, 6, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1935 */
{5, 6, 5, 6, 6, 7, 8, 8, 8, 7, 7, 6},	/* 1936 */
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1937 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1938 */
{5, 6, 6, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1939 */
{5, 6, 5, 6, 6, 7, 8, 8, 8, 7, 7, 6},	/* 1940 */
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1941 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1942 */
{5, 6, 6, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1943 */
{5, 6, 5, 5, 6, 7, 8, 8, 8, 7, 7, 6},	/* 1944 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 8, 7, 6},	/* 1945 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1946 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1947 */
{5, 5, 5, 5, 6, 7, 7, 8, 8, 7, 7, 5},	/* 1948 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 8, 7, 6},	/* 1949 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1950 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1951 */
{5, 5, 5, 5, 6, 7, 7, 8, 8, 7, 7, 5},	/* 1952 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 8, 7, 6},	/* 1953 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 7, 6},	/* 1954 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1955 */
{5, 5, 5, 5, 6, 7, 7, 8, 8, 7, 7, 5},	/* 1956 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 8, 7, 6},	/* 1957 */
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1958 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1959 */
{5, 5, 5, 5, 6, 7, 7, 7, 8, 7, 7, 5},	/* 1960 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 7, 7, 6},	/* 1961 */
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1962 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1963 */
{5, 5, 5, 5, 6, 7, 7, 7, 8, 7, 7, 5},	/* 1964 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 7, 7, 6},	/* 1965 */
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1966 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1967 */
{5, 5, 5, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 1968 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 7, 7, 6},	/* 1969 */
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1970 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1971 */
{5, 5, 5, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 1972 */
{4, 6, 5, 5, 6, 7, 8, 8, 8, 7, 7, 6},	/* 1973 */
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1974 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1975 */
{5, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 1976 */
{4, 6, 5, 5, 6, 7, 7, 8, 8, 7, 7, 6},	/* 1977 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 8, 7, 6},	/* 1978 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1979 */
{5, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 1980 */
{4, 6, 5, 5, 6, 7, 7, 8, 8, 7, 7, 6},	/* 1981 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 8, 7, 6},	/* 1982 */
{4, 6, 5, 6, 6, 8, 8, 8, 9, 8, 8, 6},	/* 1983 */
{4, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 1984 */
{5, 5, 5, 5, 5, 8, 7, 7, 8, 7, 7, 5},	/* 1985 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 8, 7, 6},	/* 1986 */
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1987 */
{4, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 1988 */
{5, 5, 5, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 1989 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 8, 7, 6},	/* 1990 */
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1991 */
{4, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 1992 */
{5, 5, 5, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 1993 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 7, 7, 6},	/* 1994 */
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1995 */
{4, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 1996 */
{5, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 1997 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 7, 7, 6},	/* 1998 */
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 1999 */
{4, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2000 */
{4, 5, 5, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2001 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 7, 7, 6},	/* 2002 */
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 2003 */
{4, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2004 */
{4, 5, 5, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2005 */
{4, 6, 5, 5, 6, 7, 7, 8, 8, 7, 7, 6},	/* 2006 */
{4, 6, 5, 6, 6, 7, 8, 8, 9, 8, 7, 6},	/* 2007 */
{4, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2008 */
{4, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2009 */
{4, 6, 5, 5, 6, 7, 7, 8, 8, 7, 7, 6},	/* 2010 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 8, 7, 6},	/* 2011 */
{4, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2012 */
{4, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2013 */
{4, 6, 5, 5, 6, 7, 7, 8, 8, 7, 7, 6},	/* 2014 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 8, 7, 6},	/* 2015 */
{4, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2016 */
{3, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2017 */
{4, 5, 5, 5, 6, 7, 7, 8, 8, 7, 7, 5},	/* 2018 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 8, 7, 6},	/* 2019 */
{4, 5, 4, 5, 5, 6, 7, 7, 8, 7, 7, 5},	/* 2020 */
{3, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2021 */
{4, 5, 5, 5, 6, 7, 7, 7, 8, 7, 7, 5},	/* 2022 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 8, 7, 6},	/* 2023 */
{4, 5, 4, 5, 5, 6, 7, 7, 8, 7, 6, 5},	/* 2024 */
{3, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2025 */
{4, 5, 5, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2026 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 7, 7, 6},	/* 2027 */
{4, 5, 4, 5, 5, 6, 7, 7, 8, 7, 6, 5},	/* 2028 */
{3, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2029 */
{4, 5, 5, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2030 */
{4, 6, 5, 6, 6, 7, 8, 8, 8, 7, 7, 6},	/* 2031 */
{4, 5, 4, 5, 5, 6, 7, 7, 8, 7, 6, 5},	/* 2032 */
{3, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2033 */
{4, 5, 5, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2034 */
{4, 6, 5, 5, 6, 7, 7, 8, 8, 7, 7, 6},	/* 2035 */
{4, 5, 4, 5, 5, 6, 7, 7, 8, 7, 6, 5},	/* 2036 */
{3, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2037 */
{4, 5, 5, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2038 */
{4, 6, 5, 5, 6, 7, 7, 8, 8, 7, 7, 6},	/* 2039 */
{4, 5, 4, 5, 5, 6, 7, 7, 8, 7, 6, 5},	/* 2040 */
{3, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2041 */
{4, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2042 */
{4, 6, 5, 5, 6, 7, 7, 8, 8, 7, 7, 6},	/* 2043 */
{4, 5, 4, 5, 5, 6, 7, 7, 7, 7, 6, 5},	/* 2044 */
{3, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2045 */
{4, 5, 4, 5, 5, 7, 7, 7, 8, 7, 7, 5},	/* 2046 */
{4, 6, 5, 5, 6, 7, 7, 8, 8, 7, 7, 6},	/* 2047 */
{4, 5, 4, 5, 5, 6, 7, 7, 7, 7, 6, 5},	/* 2048 */
{3, 5, 4, 5, 5, 6, 7, 7, 8, 7, 7, 5}	/* 2049 */
};

SHAR_EOF
if test 11140 -ne "`wc -c < 'tables.h'`"
then
	echo shar: "error transmitting 'tables.h'" '(should have been 11140 characters)'
fi
fi
exit 0
#	End of shell archive

exit 0 # Just in case...
