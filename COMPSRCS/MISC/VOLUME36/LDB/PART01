Newsgroups: comp.sources.misc
From: ross@teserv.den.mmc.com (Perry R. Ross)
Subject: v36i098:  ldb - Play backgammon by e-mail, v1.3, Part01/12
Message-ID: <csm-v36i098=ldb.182548@sparky.IMD.Sterling.COM>
X-Md4-Signature: 976b9d8d0e4003c411b0310f66b22256
Date: Sun, 11 Apr 1993 23:26:24 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: ross@teserv.den.mmc.com (Perry R. Ross)
Posting-number: Volume 36, Issue 98
Archive-name: ldb/part01
Environment: UNIX, C, VMS, VAXC, CURSES, 32BIT
Supersedes: ldb: Volume 28, Issue 93-97

		Long Distance Backgammon

	This is a program that lets two people easily play backgammon
by e-mail.  It currently runs only on character-oriented terminals
(or emulators thereof) under the curses package.  It runs on most
flavors of UNIX, as well as VMS version 5.0 and above.

	Ldb takes care of rolling dice, checking moves, and
communicating with your opponent's ldb via e-mail.  Duplicated mail
messages are rejected, and lost messages may be regenerated easily.
Gammons and backgammons are detected, and the game value is automatically
calculated at the end of the game.  Doubling is fully supported, and
automatic doubles (when there is a tied opening roll) may be enabled
at the user's option.  Ldb also allows you to enclose a two-line comment
with each move which will be displayed on your opponent's screen.

	This is version 1.3 of ldb, containing many new features over
the previously posted version, which was version 1.0.  For those wondering
what happened to 1.1 and 1.2, see the README file.  This file also contains
installation instructions.

	These are a few of the new features in ldb 1.3.  The README
file contains a more complete list.  Earle Ake contributed much of the new
stuff in ldb 1.3.  Thanks, Earle.

	- Context-sensitive help
	- Match play
	- Crawford and Jacoby rules
	- Pip count display
	- Cumulative score-keeping by opponent
	- Permanent games (for people you play continuously)

	Ldb 1.3 is designed to maintain full compatibility with older
versions of ldb.  You should be able to upgrade to 1.3 without damaging
any games in progress.  Prudence would suggest, however, that you save
a copy of ldb 1.0 and your old .ldbdata until after you are sure 1.3
is working.  Ignore problems with garbled comments; this will only
happen for one move, then comments should start working normally again.
You might want to warn your opponents that you are about to upgrade,
and your next comment might be garbled.

	An astounding 5 of the 12 parts of this distribution are devoted
to documentation.  One part is the nroff source to the manual, one is
this same manual converted to tex source, and 3 are the that manual
converted to postscript.  To reassemble the postscript version, you'll
have to concatenate ldb-man.ps1 through ldb-man.ps3.  Thanks to Earle Ake
for converting the manuals.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 12)."
# Contents:  MANIFEST Makefile README TODO board.c dohelp.c
#   flist_none.c flist_vms.c ldb.opt lock.c makefile.vms makeldb.com
#   patchlevel.h rename.c t_email.c
# Wrapped by ross@teserv.den.mmc.com on Tue Apr  6 14:52:16 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(2460 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X MANIFEST                   1	List of files
X Makefile                   1	Compilation instructions
X README                     1	Info file
X TODO                       1	Future enhancement ideas
X board.c                    1	Routines pertaining to setting up boards
X check.c                    3	Routines that check for legal moves
X control.c                  2	Function to handle the -control option
X dohelp.c                   1	Function to display on-line help
X dostats.c                  2	Routines to display roll statistics
X fe_curses.c               10	Front end routines, based on curses package
X flist_none.c               1	Last resort if flist_unix/flist_vms don't work
X flist_unix.c               3	Filename globbing in UNIX
X flist_vms.c                1	Filename globbing in VMS
X game.c                     4	Functions to create/delete/find games
X ldb-man.ps1                9	Ldb manual in postscript format, part 1
X ldb-man.ps2                8	"cat ldb-man.ps? > ldb-man.ps" to reassemble
X ldb-man.ps3                7	Ldb manual in postscript format, part 3
X ldb-man.tex               12	Ldb manual in tex format
X ldb.h                      4	Master include file
X ldb.man                   11	The user's manual source ("make ldb.doc")
X ldb.opt                    1	Option file for makefile.vms and makeldb.com
X ldbstarter                 2	A game starter script, if you want to try it
X lock.c                     1	Code to lock ldb data files while in use
X main.c                     6	The main program
X makefile.vms               1	Makefile for vms (see also makeldb.com)
X makeldb.com                1	Command file to build ldb under vax c
X misc.c                     5	Miscellaneous handy routines
X move.c                     2	Performing/checking moves
X patchlevel.h               1	Patch level (for patch program)
X process.c                  4	Routines to perform local game processing
X r_xrand.c                  2	Roll routine, based on xrand
X rcvop.c                    3	Routines to handle received operations
X readmail.c                 3	Routines that read & process incoming mail
X rename.c                   1	Rename routine for systems that don't have one
X save.c                     5	Routines that save and load things
X t_email.c                  1	Transport routine, based on mail
X vars.c                     2	All global variables.
END_OF_FILE
if test 2460 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(4861 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile for ldb	8/3/91
X#
X# Copyright 1991  Perry R. Ross
X#
X# Permission to use, copy, modify, and distribute this software and its
X# documentation without fee is hereby granted, subject to the restrictions
X# detailed in the README file, which is included here by reference.
X# Any other use requires written permission from the author.  This software
X# is distributed "as is" without any warranty, including any implied
X# warranties of merchantability or fitness for a particular purpose.
X# The author shall not be liable for any damages resulting from the
X# use of this software.  By using this software, the user agrees
X# to these terms.
X
X### INSTALLATION OPTIONS ###
X# If your host uses an ancient version of curses (e.g. VAX-C, Sequent),
X# uncomment the following line.  To tell if you need this option,
X# first try compiling without it and see if your linker complains
X# about cbreak() and nocbreak() not being defined.  If it does,
X# you need this option.
XOLDCURSES=
X#OLDCURSES=-DOLD_CURSES
X
X# If your system uses index and rindex rather than strchr and strrchr,
X# uncomment the following line.  If you don't know, just try compiling
X# and see if you get an error.  These days most systems will take strchr
X# and strrchr.
XUSE_INDEX=
X#USE_INDEX=-DUSE_INDEX
X
X# If your libc doesn't have a rename function, uncomment the
X# following to use the one that's included.  DO NOT use this
X# rename if your system already has one.
XRENAME=
X#RENAME=rename.o
X
X# Uncomment the following lines only if you are using Eunice.
X# If you don't know what it is, believe me, you're not using it.
XUNIXTOVMS=true
XVMSTOUNIX=true
X#UNIXTOVMS=unixtovms
X#VMSTOUNIX=vmstounix
X
X# Uncomment this line if your UNIX does not have the Berkeley
X# variable-length directory routines.  These are opendir,
X# readdir, closedir, etc.
XNEED_READDIR=
X# NEED_READDIR=-DNEED_READDIR
X
X# Put the name of the filename of the appropriate pattern matcher here.
X# For UNIX systems, this should be flist_unix.  For VMS, this should
X# be flist_vms.  If for some reason the flist file does not work on
X# your system, 1) please send me mail telling me, and 2) you can
X# plug in flist_none, which disables pattern matching but allows
X# ldb to compile.
XFLIST=flist_unix
X
X# Put the name of the front-end you want to compile in here.
X# NOTE: there is currently only one available front-end (curses).
XFE_FILE=fe_curses
X
X# Put the name of the transport you want to compile in here.
X# NOTE: there is currently only one available transport (email).
XT_FILE=t_email
X
X# Put the name of the dice roller you want to compile in here.
X# If you want to write your own dice roller, you can.  I would
X# prefer people all used the same one, since that is more fair,
X# but as long as it is really a random number generator, you're ok.
X# If you put in a fake dice roller (e.g. one that asks you what
X# roll you want), you are in violation of the copyright.  Read
X# the README file for more information.
XR_FILE=r_xrand
X
X# Put compiler flags here.
XCFLAGS=-O $(OLDCURSES) $(NEED_READDIR)
XLIBS=-lcurses -ltermcap
X
X# use these 2 lines for SCO XENIX (also SCO UNIX?)
X#CFLAGS= -O -Mle -LARGE -Zi -DM_TERMCAP $(OLDCURSES)
X#LIBS=-lx -ltcap -ltermlib
XLINTFLAGS=
X
X# Name of ldb executable.
XLDB=ldb
X# LDB=ldb.exe
X
X# Page length to format manual with.  62 for VMS or Eunice, 66 for most others.
XPAGELEN=66
X
X# If you want to use gcc, plug it in here.  Ldb has been tested with
X# gcc 2.3.3, should work with other versions.  (?)  Ignore warnings.
XCC=cc
X
X### END OF INSTALLATION OPTIONS ###
X
XCFILES=	board.c game.c main.c misc.c move.c process.c rcvop.c control.c \
X	check.c readmail.c save.c vars.c fe_curses.c t_email.c r_xrand.c \
X	dohelp.c dostats.c rename.c flist_unix.c flist_vms.c flist_none.c \
X	lock.c
XHFILES=ldb.h patchlevel.h
XOFILES=	board.o game.o main.o misc.o move.o process.o rcvop.o control.o \
X	check.o readmail.o save.o vars.o $(FE_FILE).o $(T_FILE).o $(R_FILE).o \
X	dohelp.o dostats.o $(RENAME) $(FLIST).o lock.o
XSHARFILES=MANIFEST README TODO Makefile $(CFILES) $(HFILES) makefile.vms \
X	ldb-man.ps1 ldb-man.ps2 ldb-man.ps3 ldb-man.tex makeldb.com \
X	ldb.man ldbstarter ldb.opt
X
X$(LDB): $(OFILES)
X	$(CC) $(CFLAGS) -s -o $(LDB) $(OFILES) $(LIBS)
X
Xall: $(LDB) ldb.doc
X
Xldb.doc: ldb.man
X	nroff -rT$(PAGELEN) -man ldb.man >ldb.doc
X	$(UNIXTOVMS) ldb.doc
X
Xldb.doc60: ldb.man
X	nroff -rT60 -man ldb.man >ldb.doc60
X	$(UNIXTOVMS) ldb.doc60
X
Xldb.doc62: ldb.man
X	nroff -rT62 -man ldb.man >ldb.doc62
X	$(UNIXTOVMS) ldb.doc62
X
Xldb.doc66: ldb.man
X	nroff -rT66 -man ldb.man >ldb.doc66
X	$(UNIXTOVMS) ldb.doc66
X
Xlint: .XXX
X	lint $(LINTFLAGS) $(CFILES) > lint.out
X
Xclean: .XXX
X	rm -f $(OFILES) ldb *.obj ldb.exe make.out .mk lint.out MANIFEST.BAK
X
Xshar: $(SHARFILES)
X	$(VMSTOUNIX) $(SHARFILES)
X	makekit -m
X
Xtar: $(SHARFILES)
X	tar cvf ldb.tar $(SHARFILES)
X
Xtags: .XXX
X	ctags $(CFILES)
X	sed 's/Mmain/main/' <tags | sort >.tags
X	mv .tags tags
X
X.XXX:
END_OF_FILE
if test 4861 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(9736 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X		Long Distance Backgammon
X		------------------------
X
X	This is a program that lets two people easily play backgammon
Xby e-mail.  It currently runs only on character-oriented terminals
X(or emulators thereof) under the curses package.  It runs on most
Xflavors of UNIX, as well as VMS version 5.0 and above.
X
X	To build ldb, create a directory, copy all the parts into
Xthat directory, strip the usenet or mail headers with a text editor,
Xand execute them with a shell (e.g. sh Part1; sh Part2; ...).
XThe installation options are documented in the Makefile.
X
X	Suggestions and problems are cheerfully accepted, all the more
Xso when accompanied by appropriate patches, in any format the patch
Xprogram understands (e.g. context diff).  E-mail to ross@emf780.den.mmc.com.
X
X	This file is for version 1.3 of ldb.  For those upgrading from
X1.0 who are wondering what happened to 1.1, it was only released on
Xthe DECUS tape.  Because of time constraints, it had to be released
Xwithout some of the planned features, so it was assigned a unique rev number.
X1.2 was to be the next version, but it was released so widely for beta
Xtest that there were countless different "versions" of version 1.2.
X
X		New Features
X		------------
X
X	A complete listing of the changes for rev 1.1, 1.2, and 1.3 is in
Xthe comments at the top of main.c.  Briefly, they are:
X	- Ldb has a context-sensitive help function that is activated
X	  whenever you press ? or h.
X	- Match play is now supported.
X	- The Crawford and Jacoby rules are supported, as is the european
X	  scoring of backgammons as double rather than triple games.
X	- You can now declare a game to be "permanent", meaning that it
X	  will be automatically restarted when it ends.  This is for
X	  people you play continuously.
X	- The current pip count for you and your opponent is displayed
X	  above the board.
X	- You can obtain detailed statistics about the rolls you and
X	  your opponent have received, including a histogram of
X	  relative frequency, by pressing the % or # keys.
X	- You can use the -score option to print a summary of games
X	  won/lost by opponent.
X	- You can press ESC while entering a message to get back to
X	  your game and abort the operation.
X	- Ldb will not ask for the second digit of a 1-digit point number
X	  unless it needs to (e.g. to tell the difference between 1 and 12)
X	- Comments are rot13'd before they are sent.  That way you won't
X	  accidentally read the comment while extracting your mail and
X	  ruin the surprise.  If ldb sees that your opponent is running
X	  an old version of ldb, comments work like they used to.
X	- Concede now scores gammons/backgammons, so a player cannot
X	  concede to avoid a gammon or backgammon.
X	- A lock file is used to prevent more than one ldb from running
X	  at the same time in any account.
X	- The name, mail address, and an alias for all your opponents are
X	  stored in a new file.  This file also keeps track of games
X	  won and lost to that opponent.
X	- If you clobber your data file, ldb can reconstruct it from your
X	  opponents' data files.
X	- Reverse video now works on VMS, as does the screen redraw and
X	  the supervisor key.
X	- Any printing characters may be used to draw the game pieces.
X	- You can dump the screen to a file from the -control menu.
X	- You can have ldb automatically notify your opponents when
X	  your e-mail address changes, provided they are using version
X	  1.3 or better.
X
X
X		Automatic Game Starters
X		-----------------------
X
X	An automatic game starter has been set up by Mark Rubin on
Xcs.umb.edu.  This matches people by ability and automatically starts a
Xgame between them.  The ability categories are novice, intermediate, and
Xexpert.  For example, if you consider yourself an expert, you would
Xmail to:
X
X		ldb-expert@cs.umb.edu
X
Xwhereupon you will be matched at random with someone else who mailed to the
Xsame address, and your game will be started using the remotestart
Xfunction of ldb.
X
X	For more information, mail to:
X
X		ldb-help@cs.umb.edu
X
XYou will receive an automated reply by return mail.
X
XFor those wishing to set up their own game starter, the shellscript used
Xto do it is included in this distribution as ldbstarter.
XGetting it to work on your system may take a little work.
X
X
X		Running Ldb
X		-----------
X
X	The first time ldb is run, it will create a file in your home
Xdirectory called ".ldbrc".  If this name is inconvenient, define the
Xenvironment variable LDBRC to be the name you want before running it
Xthe first time (and all times after that).  Ldb will ask for your
Xpersonal, human-type name and your e-mail address.  All other options
Xwill be set to their defaults, as explained in the manual.  The "sendcmd"
Xoption in .ldbrc may need to be modified to work with the mail program
Xon your system.  This option tells ldb how to send mail to your opponent,
Xand must be correctly set for ldb to work.  This string after "sendcmd="
Xis executed by ldb after making the following substitutions:
X	$a	is replaced by the address to mail to.
X	$f	is replaced by the file containing the message.
X	$s	is replaced by the subject line of the message.
X	$$	is replaced by a single $.
XThe default, which should work with most UNIX systems, is:
X	mail -s '$s' $a < $f
XNote that ldb performs the substitutions, not the shell, so the substitutions
Xare not subject to any quoting.  All other characters, including shell
Xmetacharacters, are passed to the system unchanged.
X
XVMS users will have the following default sendcmd set:
X
X	sendcmd=MAIL/SUBJECT="$s" $f IN%"""$a"""
X
XThis is correct if you are using the IN% SMTP mailer.  If not,
Xyou may need to change the sendcmd= line as follows:
X
XIf you are using VMS mail only, use the line:
X
X	sendcmd=MAIL/SUBJECT="$s" $f $a
X
XDepending on which SMTP mailer you have, the IN% may need to be
Xchanged to WINS% (for Wollongong), etc.
X
X
X		Starting A Game
X		---------------
X
X	To start a game, type:
X		ldb -start opponent's-email-address
Xand everything is automatic from there.  You may have to exchange
Xseveral mail messages before you are ready to play, since your ldb has to
Xdo the initial roll with the remote ldb, and if there is a tie, the
Xinitial roll is repeated.  Eventually, you will see a board drawn on
Xthe screen.  The commands are in the bottom right corner.  The moves by
Xyou and your opponent are above that, on the right side of the screen, and
Xthe bottom of the screen contains a place for you to enclose a 2-line
Xmessage with each move.  This is useful for taunting, pleading, etc.
XYou will need to press 'r' to roll the dice, then press the number of the roll
Xyou want to use followed by the point you want to move from.  For example,
Xif you roll 5 2, and you want to move the piece on the 11 point 5, press
X5 1 1.  You don't need to hit return.  After you have used one of your rolls,
Xthere are 3 shortcuts you can use for the remainder of your roll:
X	<space bar>	Continues the last move.  The piece you last moved
X			is moved by the amount of the other/next roll.
X	<return>	Repeat the last move.  The other/next roll is applied
X			to the same point you moved from last time.
X	p		Make point.  This gets a little tricky.  Ldb attempts
X			to use the other/next roll to move one of your pieces
X			so that it ends up on the same point as your last move
X			ended on.  That is, if you roll 5 2 and use the 5
X			to move from the 6 point to the 11 point, and hit "p",
X			ldb will move one of your pieces from the 9 point to
X			the 11 point to make the 11 point.  This assumes,
X			of course, that you have a piece on the 9 point.
X
X	Ldb checks your moves for all conceivable errors.  These
Xare listed in the manual.
X
X	To move off the bar, merely select a roll.  That roll will
Xautomatically bring you off the bar, since you have no other legal
Xmove anyway.  To bear pieces off, you can either enter the point
Xnumber like normal, or press "o" to have it bear off for you automatically.
X
X	When a move arrives in your mail, go into mail and save the message
Xinto a file.  Delete the message from your mail, exit mail, and run
Xldb with the name of the file as an argument.  There are easier ways
Xto feed incoming mail to ldb; these are discussed in the manual.
X
X	For more options, read the manual and the comments at the top
Xof main.c.
X
X	Good luck!
X
X						Perry R. Ross
X						ross@emf780.den.mmc.com
X
X-----------------------------------------------------------------------------
X
X	Really Scary and Hopefully Bulletproof Legal Statement:
X
XThis software is copyright 1991 by Perry R. Ross.  Permission to use,
Xcopy, modify, and redistribute it is granted provided:
X	(1) It is not sold.
X	(2) This notice accompanies all copies, and is kept intact.
X	(3) Users do not cheat by any method, including but not limited to:
X		A. modifying the roll generated by the random number generator,
X		B. modifying the code to provide any roll other than that
X		   generated by a bona-fide random number generator,
X		C. taking advantage of any non-randomness in a random
X		   number generator to predict upcoming rolls,
X		D. changing the contents of an incoming message or of the
X		   .ldbdata file to modify the normal progression of a
X		   game in any way, or
X		E. generating a roll before offering to double.
X	   Persons guilty of cheating in any way while using this software
X	   are denied permission to use or distribute this software
X	   in perpetuity.  Excluded from the definition of cheating is
X	   any action whose intention is to test or debug this software,
X	   as long as the opponent is aware that these actions are being
X	   performed, and the game is considered "unofficial".
XThe above restrictions are made in all seriousness, and with every
Xintention of enforcement by any and all legal means where practical.
X
X(Sounds almost as good as the real thing, doesn't it?)
END_OF_FILE
if test 9736 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'TODO' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'TODO'\"
else
echo shar: Extracting \"'TODO'\" \(2429 characters\)
sed "s/^X//" >'TODO' <<'END_OF_FILE'
Xdelete redundant fields from game structure (opaddr, myaddr, etc)
X
Xdelmail option should work on system mail file.
X
XMake superkey work instantly, instead of only when waiting for a character.
X
XWay of changing local colors for a game, or for setting local colors
Xindependent of colors specified in START.
X
XIndication of last access time for a game in -control.
X
XInstead of keeping 3 board images Bef, Aft, Cur, keep log file of
Xall prior moves, with board image, player, & move made.  Use ^ and v
Xcommands (or ku & kd from termcap?) to scroll backward and forward through
Xlog file, displaying board & pieces moved at each step.  Delete log file
Xwhen game is deleted?  Use name like .ldblogXXXXX for log file,
Xput log file name into game structure.  Scan directory for unused
Xlog files when games are read, so they can be deleted?  Maybe, each
Xscroll back is in two steps, before move was made & after.  That is,
XCur, -1 After, -1 Before, -2 After, -2 Before, ...
X
XWay of specifying that board should invert if necessary automatically
Xso that play is always in the desired direction.
X
Xallow unlimited length comments, scroll window.
X
XWay to print board to file, load board from file.  Allow board
Xto be set up in any desired configuration.
X
XSecurity from (1) advance knowledge of rolls, (2) generating false rolls.
X
XMultiple language support.
X
Xregister vars
X
XFlip board left/right.
X
XFlush input before reading.
X
XSocket transport.
X
XMotif front-end.  Open Look?  Xlib?
X
XVMS command line interface.  Maybe, separate out all host-specific
Xstuff into a separate file, & only compile in the one you need.
X
XOption to display "scratch" screen, move any piece.  Don't save.
XInitial setup?
X
XProtect critical sections from SIGINT.  Catch more signals?
XCatch SIGSTOP/SIGTSTP/SIGCONT & reset tty modes.
X
XAllow multiple rolls without sending packet when opponent is closed out.
XAllow opponent's roll to be generated locally when piece is on the bar,
X& skip if he cannot move.  Conflicts with secure dice roller?  How
Xto send multiple moves in one packet?
X
XProcess id in lock file, look to see if process still exists.
XPortability?  How in VMS?
X
XPlug memory leaks.
X
XFaster start protocol, have starting host perform entire opening roll
Xand reroll ties immediately.  Conflicts with: 1) backward compatibility,
X2) autodoubling, 3) secure roller.
X
XCatch failure in sending mail, return to move state.
X
Xhandle failed write better.  "" in writegames.
END_OF_FILE
if test 2429 -ne `wc -c <'TODO'`; then
    echo shar: \"'TODO'\" unpacked with wrong size!
fi
# end of 'TODO'
fi
if test -f 'board.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'board.c'\"
else
echo shar: Extracting \"'board.c'\" \(2195 characters\)
sed "s/^X//" >'board.c' <<'END_OF_FILE'
X/* board.c		8/3/91
X *
X * Copyright 1991  Perry R. Ross
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation without fee is hereby granted, subject to the restrictions
X * detailed in the README file, which is included here by reference.
X * Any other use requires written permission from the author.  This software
X * is distributed "as is" without any warranty, including any implied
X * warranties of merchantability or fitness for a particular purpose.
X * The author shall not be liable for any damages resulting from the
X * use of this software.  By using this software, the user agrees
X * to these terms.
X */
X
X#include "ldb.h"
X
X/*----------------------------------------------------------------------
X *	newboard -- set up a board array for a new game
X *
X * This function initializes a board array so that it is set up
X * properly for a new game.  It is passed two characters that are
X * used to draw the pieces for the board.  C1 is the color for the
X * upbound player, and c2 is the color for the downbound player.
X *----------------------------------------------------------------------
X */
X
Xnewboard(b,c1,c2)
Xboard b;
Xchar c1, c2;
X{
Xint i;
X
Xfor (i = 0; i < BOARDSIZE; i++) {
X	b[i].qty = 0;			/* init to empty */
X	b[i].color = '-';		/* init to invalid color */
X	}
Xb[1].qty = 2;				/* 2 c1's on 1 point */
Xb[1].color = c1;
Xb[6].qty = 5;				/* 5 c2's on 6 point */
Xb[6].color = c2;
Xb[8].qty = 3;				/* 3 c2's on 8 point */
Xb[8].color = c2;
Xb[12].qty = 5;				/* 5 c1's on 12 point */
Xb[12].color = c1;
Xb[13].qty = 5;				/* 5 c2's on 13 point */
Xb[13].color = c2;
Xb[17].qty = 3;				/* 3 c1's on 17 point */
Xb[17].color = c1;
Xb[19].qty = 5;				/* 5 c1's on 19 point */
Xb[19].color = c1;
Xb[24].qty = 2;				/* 2 c2's on 24 point */
Xb[24].color = c2;
X}
X
X
X/*----------------------------------------------------------------------
X *	copyboard -- make a copy a board array
X *
X * This is a convenience function that copies an entire board. The
X * source is given as "f", and the destination as "t".
X *----------------------------------------------------------------------
X */
X
Xcopyboard(f,t)
Xboard f, t;
X{
Xint i;
X
Xfor (i = 0; i < BOARDSIZE; i++)
X	t[i] = f[i];
X}
END_OF_FILE
if test 2195 -ne `wc -c <'board.c'`; then
    echo shar: \"'board.c'\" unpacked with wrong size!
fi
# end of 'board.c'
fi
if test -f 'dohelp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dohelp.c'\"
else
echo shar: Extracting \"'dohelp.c'\" \(4994 characters\)
sed "s/^X//" >'dohelp.c' <<'END_OF_FILE'
X/* dohelp.c		3/27/92
X *
X * Copyright 1992  Earle F. Ake
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation without fee is hereby granted, subject to the restrictions
X * detailed in the README file, which is included here by reference.
X * Any other use requires written permission from the author.  This software
X * is distributed "as is" without any warranty, including any implied
X * warranties of merchantability or fitness for a particular purpose.
X * The author shall not be liable for any damages resulting from the
X * use of this software.  By using this software, the user agrees
X * to these terms.
X *
X * Original coding by Earle F. Ake <ake@dayton.saic.com> - 27 March 1992.
X *
X */
X
X#include "ldb.h"
X
X/*----------------------------------------------------------------------
X *	dohelp -- display online help for the user
X *
X * This function creates a new curses window and displays command help
X * to the user.  The user then presses any key to return to the game.
X *----------------------------------------------------------------------
X */
X
Xdohelp()
X{
XWINDOW *helpwin;
Xint row;
X
Xhelpwin = newwin(0,0,0,0);	/* get a new window to post help to */
X
Xmvwaddstr(helpwin,0,30,"ldb Command Summary");		/* print title */
Xmvwaddstr(helpwin,1,30,"-------------------");		/* underline title */
Xrow = 3;
X
Xif(GameState == STATE_MYACPT) {
X	mvwaddstr(helpwin,row,0,"Accept -");
X	mvwaddstr(helpwin,row++,15,"Accept the double and the game continues.");
X	row++;
X	mvwaddstr(helpwin,row,0,"Decline -");
X	mvwaddstr(helpwin,row++,15,"You decline the double and lose the game for the current");
X	mvwaddstr(helpwin,row++,15,"game value.");
X	row++;
X	}
X
Xif(GameState == STATE_CONTROL) {
X	mvwaddstr(helpwin,row,0,"Invert -");
X	mvwaddstr(helpwin,row++,15,"Invert the board for this game.  Pressing Invert again will");
X	mvwaddstr(helpwin,row++,15,"put it back to normal.  Inverting the board does not affect");
X	mvwaddstr(helpwin,row++,15,"point numbering.");
X	row++;
X	mvwaddstr(helpwin,row,0,"Resend -");
X	mvwaddstr(helpwin,row++,15,"Resend your last move command to your opponent.");
X	row++;
X	mvwaddstr(helpwin,row,0,"Get Resend -");
X	mvwaddstr(helpwin,row++,15,"Request a resend from your opponent.");
X	row++;
X	mvwaddstr(helpwin,row,0,"Screen Dump -");
X	mvwaddstr(helpwin,row++,15,"Dump the screen to ldb_screen.dmp");
X	row++;
X	mvwaddstr(helpwin,row,0,"Delete Game -");
X	mvwaddstr(helpwin,row++,15,"This marks a game for deletion.  The game is not deleted");
X	mvwaddstr(helpwin,row++,15,"until you quit and you can undelete it by pressing D again.");
X	row++;
X	}
X
Xif(GameState == STATE_MYTURN) {
X	mvwaddstr(helpwin,row,0,"Roll -");
X	mvwaddstr(helpwin,row++,15,"Roll the dice.  Your roll will appear in your move block.");
X	mvwaddstr(helpwin,row++,15,"You will see two numbers appear or four if you have");
X	mvwaddstr(helpwin,row++,15,"rolled doubles.");
X	row++;
X	mvwaddstr(helpwin,row,0,"Double -");
X	mvwaddstr(helpwin,row++,15,"Choose to double the current game value.  A message will");
X	mvwaddstr(helpwin,row++,15,"be sent to your opponent and ldb then will automatically");
X	mvwaddstr(helpwin,row++,15,"select roll.");
X	row++;
X	}
X
Xif(GameState == STATE_MYMOVE) {
X	mvwaddstr(helpwin,row,0,"Point -");
X	mvwaddstr(helpwin,row++,15,"Attempt to make the point your last move ended on.");
X	row++;
X	mvwaddstr(helpwin,row,0,"Off -");
X	mvwaddstr(helpwin,row++,15,"Bear off a piece by using the next UNUSED roll.");
X	row++;
X	mvwaddstr(helpwin,row,0,"Reset -");
X	mvwaddstr(helpwin,row++,15,"Reset your rolls to UNUSED and put the board back how it was");
X	mvwaddstr(helpwin,row++,15,"before you moved.  You can then enter some different moves.");
X	row++;
X	mvwaddstr(helpwin,row,0,"Send -");
X	mvwaddstr(helpwin,row++,15,"Send your move to your opponent.  You will be able to");
X	mvwaddstr(helpwin,row++,15,"enter 2 lines of 56 characters to send with your move.");
X	row++;
X	}
X
Xif(GameState != STATE_CONTROL) {
X	mvwaddstr(helpwin,row,0,"Board -");
X	mvwaddstr(helpwin,row++,15,"Cycle between the current board, the board before your");
X	mvwaddstr(helpwin,row++,15,"opponent's last move, and the board after your opponent's");
X	mvwaddstr(helpwin,row++,15,"last move.");
X	row++;
X	}
X
Xif((GameState == STATE_MYTURN) || (GameState == STATE_MYMOVE)) {
X	mvwaddstr(helpwin,row,0,"Concede -");
X	mvwaddstr(helpwin,row++,15,"Concede the current game.");
X	row++;
X	}
X
Xmvwaddstr(helpwin,row,0,"Next Game -");
Xmvwaddstr(helpwin,row++,15,"The next game is displayed.  If there is no next game, quit.");
Xrow++;
Xmvwaddstr(helpwin,row,0,"Quit -");
Xmvwaddstr(helpwin,row++,15,"Quit the current ldb session.");
X
Xmvwaddstr(helpwin,23,25,"Press <return> to continue: ");
X
Xtouchwin(helpwin);		/* Make sure the screen is updated */
Xwrefresh(helpwin);		/* update the help window clearing screen */
Xwgetch(helpwin);		/* Wait for user response */
Xwclear(helpwin);		/* clear the help window */
Xwrefresh(helpwin);		/* update the help window clearing screen */
Xdelwin(helpwin);		/* delete the help window */
X}
END_OF_FILE
if test 4994 -ne `wc -c <'dohelp.c'`; then
    echo shar: \"'dohelp.c'\" unpacked with wrong size!
fi
# end of 'dohelp.c'
fi
if test -f 'flist_none.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flist_none.c'\"
else
echo shar: Extracting \"'flist_none.c'\" \(1317 characters\)
sed "s/^X//" >'flist_none.c' <<'END_OF_FILE'
X/*	flist_none.c		4/24/91
X *
X * Copyright 1991  Perry R. Ross
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation without fee is hereby granted, subject to the restrictions
X * detailed in the README file, which is included here by reference.
X * Any other use requires written permission from the author.  This software
X * is distributed "as is" without any warranty, including any implied
X * warranties of merchantability or fitness for a particular purpose.
X * The author shall not be liable for any damages resulting from the
X * use of this software.  By using this software, the user agrees
X * to these terms.
X */
X
X#include "ldb.h"
X
X
X/*----------------------------------------------------------------------
X *	filelist -- generate a list of all matching files.
X *
X * This is a dummy function that can be used to disable filename
X * matching.  It just copies the pattern into a 1-element list
X * and returns it.  This can be used if flist_unix does not work,
X * or if filename matching is not desired.
X *----------------------------------------------------------------------
X */
X
Xstruct flist *filelist(ptn)
Xchar *ptn;
X{
Xstruct flist *cur;
X
Xif ( (cur = (struct flist *) calloc(sizeof(struct flist),1)) == NULL)
X	fatal("Out of memory!");
Xcur->name = save(ptn);
Xreturn(cur);
X}
END_OF_FILE
if test 1317 -ne `wc -c <'flist_none.c'`; then
    echo shar: \"'flist_none.c'\" unpacked with wrong size!
fi
# end of 'flist_none.c'
fi
if test -f 'flist_vms.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flist_vms.c'\"
else
echo shar: Extracting \"'flist_vms.c'\" \(3176 characters\)
sed "s/^X//" >'flist_vms.c' <<'END_OF_FILE'
X/*	flist_vms.c		4/24/92
X *
X * Copyright 1992  Earle Ake and Perry Ross
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation without fee is hereby granted, subject to the restrictions
X * detailed in the README file, which is included here by reference.
X * Any other use requires written permission from the author.  This software
X * is distributed "as is" without any warranty, including any implied
X * warranties of merchantability or fitness for a particular purpose.
X * The author shall not be liable for any damages resulting from the
X * use of this software.  By using this software, the user agrees
X * to these terms.
X */
X
X#include "ldb.h"
X
X
X/*----------------------------------------------------------------------
X *	filelist -- generate a list of all matching files.
X *
X * This function generates a list of all files that match a pattern.
X * Each file is stored in an instance of struct flist, which just
X * links the names in a linked list.  A pointer to the beginning of
X * the list is returned.  It is the callers responsibility to free
X * the list when it is no longer needed.
X *----------------------------------------------------------------------
X */
X
Xstruct flist *filelist(ptn)
Xchar *ptn;
X{
Xchar nextfile[257];
Xint context = 0;
Xstruct flist *head, *tail, *cur;
X
Xhead = NULL;
Xwhile (1) {
X	if (scan_files(ptn,&nextfile,&context) == 0)
X		return(head);
X	if ( (cur = (struct flist *) calloc(sizeof(struct flist),1)) == NULL)
X		fatal("Out of memory!");
X	if (head == NULL) {
X		head = cur;
X		tail = cur;
X		}
X	else {
X		tail->next = cur;
X		tail = cur;
X		}
X	cur->name = save(nextfile);
X	}
X}
X
X
X/*----------------------------------------------------------------------
X *	scan_files -- find the next file matching a pattern
X *
X * This function finds the next (or first) file matching a given
X * pattern.  The pattern is interpreted in the same way as DCL.
X * If the pattern does not specify a version number, ';*' is
X * the default.  scan_files returns 1 if a file was found,
X * 0 if there are no more matching files.
X *----------------------------------------------------------------------
X */
X
Xint scan_files(itm_files,nextfile,context)
X	char *itm_files, *nextfile;
X	int *context;
X{
X	char *def_spec = ";*";
X	int status;
X	unsigned key[2];
X	char fnam[257], *s;
X	static struct RAB itmrab;
X	static struct dsc$descriptor itm_dsc, defspec_dsc;
X	$DESCRIPTOR(fnam_dsc,fnam);
X
X	if (*context == 0) {
X		itm_dsc.dsc$w_length = strlen(itm_files);
X		itm_dsc.dsc$b_dtype = DSC$K_DTYPE_T;
X		itm_dsc.dsc$b_class = DSC$K_CLASS_S;
X		itm_dsc.dsc$a_pointer = itm_files;
X
X		defspec_dsc.dsc$w_length = strlen(def_spec);
X		defspec_dsc.dsc$b_dtype = DSC$K_DTYPE_T;
X		defspec_dsc.dsc$b_class = DSC$K_CLASS_S;
X		defspec_dsc.dsc$a_pointer = def_spec;
X
X		itmrab.rab$l_kbf = (char *) key;
X		itmrab.rab$b_krf = 0;
X		itmrab.rab$b_ksz = 8;
X		itmrab.rab$l_rop = RAB$M_RRL | RAB$M_NLK ;
X		itmrab.rab$b_rac = RAB$C_KEY;
X	}
X
X	if ((status = lib$find_file(&itm_dsc,&fnam_dsc,context,
X		&defspec_dsc,0,0,0)) & 1) {
X
X		fnam[256] = '\0';
X
X		if (s = strchr(fnam,' ')) *s = '\0';
X		strcpy(nextfile,&fnam);
X		return 1;
X		}
X	else {
X		lib$find_file_end(context);
X	}
X	return 0;
X}
END_OF_FILE
if test 3176 -ne `wc -c <'flist_vms.c'`; then
    echo shar: \"'flist_vms.c'\" unpacked with wrong size!
fi
# end of 'flist_vms.c'
fi
if test -f 'ldb.opt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ldb.opt'\"
else
echo shar: Extracting \"'ldb.opt'\" \(24 characters\)
sed "s/^X//" >'ldb.opt' <<'END_OF_FILE'
Xsys$share:vaxcrtl/share
END_OF_FILE
if test 24 -ne `wc -c <'ldb.opt'`; then
    echo shar: \"'ldb.opt'\" unpacked with wrong size!
fi
# end of 'ldb.opt'
fi
if test -f 'lock.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lock.c'\"
else
echo shar: Extracting \"'lock.c'\" \(2218 characters\)
sed "s/^X//" >'lock.c' <<'END_OF_FILE'
X/*	lock.c		4/28/92
X *
X * Copyright 1992  Perry R. Ross
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation without fee is hereby granted, subject to the restrictions
X * detailed in the README file, which is included here by reference.
X * Any other use requires written permission from the author.  This software
X * is distributed "as is" without any warranty, including any implied
X * warranties of merchantability or fitness for a particular purpose.
X * The author shall not be liable for any damages resulting from the
X * use of this software.  By using this software, the user agrees
X * to these terms.
X */
X
X#include "ldb.h"
X
X
X/*----------------------------------------------------------------------
X *	get_lock -- attempt to open a lock file, exit if it exists
X *
X * This function attempts to create a file in such a way that,
X * if the file exists, the create will fail.  If the create succeeds,
X * we "own" the ldb lock, and have the exclusive right to access
X * the ldb data files in this directory.  If the create fails,
X * some other ldb already has the lock and we exit.
X *
X * This uses the O_EXCL flag to open, which as far as I know is
X * supported on all UNIX flavors.  If it isn't on yours:
X *	a. Please mail me at ross@emf780.den.mmc.com and tell me
X *	   what your system is.
X *	b. try replacing open(fn,O_...,0644) with creat(fn,0444).
X *----------------------------------------------------------------------
X */
X
Xget_lock(fn)
Xchar *fn;
X{
Xint fd;
Xstruct stat s;
X
Xif ( (fd = open(fn,O_WRONLY|O_CREAT|O_EXCL,0644)) < 0) {
X	printf("ERROR: Ldb is already running in this account -- exiting.\n\n");
X	printf("If you are sure no other ldb is active, you can remove\n");
X	printf("the lock with the following command:\n\n");
X#ifdef VMS
X	printf("\t$ delete sys$login:%s;*\n",fn);
X#else
X	if (*fn == '/')
X		printf("\t$ rm %s\n",fn);
X	else
X		printf("\t$ rm $HOME/%s\n",fn);
X#endif
X	printf(
X	"\nPlease be certain no other ldb is running before doing this.\n\n");
X	if (stat(fn,&s) >= 0)
X		printf("The lock file was created %s\n",ctime(&s.st_ctime));
X	exit(STAT_ABORT);	/* DON'T call ldbexit, it calls release_lock */
X	}
Xclose(fd);		/* success, close the file and return */
X}
END_OF_FILE
if test 2218 -ne `wc -c <'lock.c'`; then
    echo shar: \"'lock.c'\" unpacked with wrong size!
fi
# end of 'lock.c'
fi
if test -f 'makefile.vms' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.vms'\"
else
echo shar: Extracting \"'makefile.vms'\" \(3736 characters\)
sed "s/^X//" >'makefile.vms' <<'END_OF_FILE'
X# Makefile for ldb under vms	5/1/92
X#
X# Copyright 1992  Earle F. Ake
X#
X# Permission to use, copy, modify, and distribute this software and its
X# documentation without fee is hereby granted, subject to the restrictions
X# detailed in the README file, which is included here by reference.
X# Any other use requires written permission from the author.  This software
X# is distributed "as is" without any warranty, including any implied
X# warranties of merchantability or fitness for a particular purpose.
X# The author shall not be liable for any damages resulting from the
X# use of this software.  By using this software, the user agrees
X# to these terms.
X
X# This makefile is for the vms make program written by Todd Aven and
X# used by DECUS UUCP.  This file should be renamed to makefile.
X# before it is used.  If you do not have make on your system, you
X# can compile ldb with @makeldb.com.  If you use this file, you
X# shouldn't need to modify any of the installation options below.
X
X### INSTALLATION OPTIONS ###
X# If your host uses an ancient version of curses (e.g. VAX-C, Sequent),
X# uncomment the following line.  To tell if you need this option,
X# first try compiling without it and see if your linker complains
X# about cbreak() and nocbreak() not being defined.  If it does,
X# you need this option.
X#OLDCURSES=
X#OLDCURSES=-DOLD_CURSES
X
X# If your libc doesn't have a rename function, uncomment the
X# following to use the one that's included.  DO NOT use this
X# rename if your system already has one.
X#RENAME=
X#RENAME=rename.o
X
X# Uncomment the following lines only if you are using Eunice.
X# If you don't know what it is, believe me, you're not using it.
X#UNIXTOVMS=true
X#VMSTOUNIX=true
X# UNIXTOVMS=unixtovms
X# VMSTOUNIX=vmstounix
X
X# Put the name of the front-end you want to compile in here.
X# NOTE: there is currently only one available front-end (curses).
XFE_FILE=fe_curses
X
X# Put the name of the transport you want to compile in here.
X# NOTE: there is currently only one available transport (email).
XT_FILE=t_email
X
X# Put the name of the dice roller you want to compile in here.
X# If you want to write your own dice roller, you can.  I would
X# prefer people all used the same one, since that is more fair,
X# but as long as it is really a random number generator, you're ok.
X# If you put in a fake dice roller (e.g. one that asks you what
X# roll you want), you are in violation of the copyright.  Read
X# the README file for more information.
XR_FILE=r_xrand
X
X# Put compiler flags here.
XCFLAGS=/nolist
X#LIBS=-lcurses -ltermcap
X
X# use these 2 lines for SCO XENIX (also SCO UNIX?)
X#CFLAGS= -O -Mle -LARGE -Zi -DM_TERMCAP $(OLDCURSES)
X#LIBS=-lx -ltcap -ltermlib
X#LINTFLAGS=
X
X# Name of ldb executable.
X#LDB=ldb
XLDB=ldb.exe
X
X# Page length to format manual with.  62 for VMS or Eunice, 66 for most others.
X#PAGELEN=66
X
X#CC=cc
X
X### END OF INSTALLATION OPTIONS ###
X
X*.obj :	*.c
X	write sys$output "Compiling $*"
X	cc $(CFLAGS) $*
X	purge/nolog $*.obj
X	rename $*.obj *.*;1
X
Xldb :	$(LDB)
X	write sys$output "ldb Build finished."
X
Xldb_objs = board.obj,game.obj,main.obj,misc.obj,move.obj,process.obj,\
X	rcvop.obj,control.obj,\
X	check.obj,readmail.obj,save.obj,vars.obj,$(FE_FILE).obj,\
X	$(T_FILE).obj,$(R_FILE).obj,\
X	dohelp.obj,dostats.obj,flist_vms.obj,lock.obj
X
X#
X#	Include all the sources necessary to build under VMS or unix
X#
X
XSHARFILES=readme.,todo.,ldb.doc,ldb.man,ldb.ps,makefile.*,ldb.opt,makeldb.com,*.c,*.h,ldbstarter.csh,ldb-man.tex,ldb-man.ps1,ldb-man.ps2,ldb-man.ps3
X
X$(LDB) : $(ldb_objs)
X	write sys$output "Linking $(LDB)"
X 	link/exe=$(LDB)/notrace/nodebug/nomap $(ldb_objs),\
X	sys$share:vaxccurse.olb/library,\
X	sys$disk:[]ldb.opt/options
X
X$(ldb_objs) : ldb.h patchlevel.h
X
Xvms_share : $(SHARFILES)
X	vms_share $(SHARFILES) ldb_src
END_OF_FILE
if test 3736 -ne `wc -c <'makefile.vms'`; then
    echo shar: \"'makefile.vms'\" unpacked with wrong size!
fi
# end of 'makefile.vms'
fi
if test -f 'makeldb.com' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makeldb.com'\"
else
echo shar: Extracting \"'makeldb.com'\" \(634 characters\)
sed "s/^X//" >'makeldb.com' <<'END_OF_FILE'
X$ set verify
X$ assign "sys$library" vaxc$include
X$ cc/nolist board
X$ cc/nolist check
X$ cc/nolist control
X$ cc/nolist dohelp
X$ cc/nolist dostats
X$ cc/nolist fe_curses
X$ cc/nolist flist_vms
X$ cc/nolist game
X$ cc/nolist lock
X$ cc/nolist main
X$ cc/nolist misc
X$ cc/nolist move
X$ cc/nolist process
X$ cc/nolist r_xrand
X$ cc/nolist rcvop
X$ cc/nolist readmail
X$ cc/nolist save
X$ cc/nolist t_email
X$ cc/nolist vars
X$ link/exe=ldb sys$input/opt
Xboard,check,control,dohelp,dostats,fe_curses,flist_vms,game,lock,main
Xmisc,move,process,r_xrand,rcvop,readmail,save,t_email,vars
Xsys$share:vaxccurse.olb/library
Xldb.opt/options
X$ set noverify
X$ exit
END_OF_FILE
if test 634 -ne `wc -c <'makeldb.com'`; then
    echo shar: \"'makeldb.com'\" unpacked with wrong size!
fi
# end of 'makeldb.com'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
echo shar: Extracting \"'patchlevel.h'\" \(1761 characters\)
sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X/*	patchlevel.h	9/9/91
X *
X * adapted from the file "patchlevel", which is part of the
X * "xloadimage" package by Jim Frost, and used within the terms
X * of the original copyright notice, which appears below.
X * Please note that the copyright notice below applies only to
X * this file.
X */
X
X/*
X * Copyright 1989, 1990, 1991 Jim Frost
X *
X * Permission to use, copy, modify, distribute, and sell this software
X * and its documentation for any purpose is hereby granted without fee,
X * provided that the above copyright notice appear in all copies and
X * that both that copyright notice and this permission notice appear
X * in supporting documentation.  The author makes no representations
X * about the suitability of this software for any purpose.  It is
X * provided "as is" without express or implied warranty.
X *
X * THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
X * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
X * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
X * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
X * USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X	/* REVISION and PATCHLEVEL can't be more than 9			*/
X	/* due to the way the version field is coded in outgoing	*/
X	/* messages (i.e. only 1 digit each).  I would suggest		*/
X	/* rolling REVISION if PATCHLEVEL gets to 9, and similarly	*/
X	/* rolling VERSION if REVISION gets to 9.  VERSION is		*/
X	/* essentially unlimited.					*/
X
X#define VERSION		1
X#define REVISION	3		/* no more than 9 */
X#define PATCHLEVEL	0		/* no more than 9 */
X#define AUTHOR_EMAIL	"ross@emf780.den.mmc.com"
END_OF_FILE
if test 1761 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
fi
# end of 'patchlevel.h'
fi
if test -f 'rename.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rename.c'\"
else
echo shar: Extracting \"'rename.c'\" \(1665 characters\)
sed "s/^X//" >'rename.c' <<'END_OF_FILE'
X/*	rename.c		4/10/92
X *
X * Copyright 1991  Perry R. Ross
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation without fee is hereby granted, subject to the restrictions
X * detailed in the README file, which is included here by reference.
X * Any other use requires written permission from the author.  This software
X * is distributed "as is" without any warranty, including any implied
X * warranties of merchantability or fitness for a particular purpose.
X * The author shall not be liable for any damages resulting from the
X * use of this software.  By using this software, the user agrees
X * to these terms.
X */
X
X#include "ldb.h"
X
X
X/*----------------------------------------------------------------------
X *	rename -- rename a file
X *
X * This function may be used to rename a file if the local C library
X * does not have such a function.  It uses the link and unlink calls,
X * which should be on all systems, but is not atomic like real rename's.
X * This rename is not meant for general use, as it does no error checking.
X * Since it is only used to save the old copy of a file as a backup,
X * it is better to fail silently than complain about something the user
X * can't do anything about anyway.  The old file is always unlinked,
X * even if the link to the new name succeeded, since the next thing
X * we are going to do is write over the old file anyway.
X *----------------------------------------------------------------------
X */
X
Xrename(old,new)
Xchar *old;
Xchar *new;
X{
X
Xunlink(new);		/* get rid of existing file named NEW */
Xlink(old,new);		/* make link from OLD to NEW */
Xunlink(old);		/* get rid of link to OLD */
X}
END_OF_FILE
if test 1665 -ne `wc -c <'rename.c'`; then
    echo shar: \"'rename.c'\" unpacked with wrong size!
fi
# end of 'rename.c'
fi
if test -f 't_email.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'t_email.c'\"
else
echo shar: Extracting \"'t_email.c'\" \(4960 characters\)
sed "s/^X//" >'t_email.c' <<'END_OF_FILE'
X/*	t_email.c		9/5/91
X *
X * Copyright 1991  Perry R. Ross
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation without fee is hereby granted, subject to the restrictions
X * detailed in the README file, which is included here by reference.
X * Any other use requires written permission from the author.  This software
X * is distributed "as is" without any warranty, including any implied
X * warranties of merchantability or fitness for a particular purpose.
X * The author shall not be liable for any damages resulting from the
X * use of this software.  By using this software, the user agrees
X * to these terms.
X */
X
X#include "ldb.h"
X
X/*======================================================================
X * This file is the e-mail transport for the ldb program.  It is
X * modularized to allow other transports to be substituted, most
X * notably a socket transport to allow interactive network backgammon.
X * For now, though, this is the only transport available.
X *
X * Packets are sent via TSendPacket, which takes an instance of
X * struct packet and an address, and sends the packet to that address.
X * TInitialize must be called before any calls to TSendPacket, and
X * TFinishSession must be called before exiting.
X *
X * Individual files may be sent by calling TSendFile.  These files
X * need not be related to a game.
X *======================================================================
X */
X
XPRIVATE PStringSub();
X
X
X/*----------------------------------------------------------------------
X *	TInitialize -- initialize the transport
X *
X * This function is called before the transport is used.  As you can
X * see, email doesn't require a great deal of initialization.
X *----------------------------------------------------------------------
X */
X
XTInitialize()
X{
X}
X
X
X/*----------------------------------------------------------------------
X *	FeDrawMenu -- draw menu choices in menu box
X *
X * This function closes down the transport.
X *----------------------------------------------------------------------
X */
X
XTFinishSession()
X{
X}
X
X
X
X/*----------------------------------------------------------------------
X *	TSendPacket -- send a packet to an email address
X *
X * This function sends a packet to an email address.  It returns 1 if
X * the packet was sent, 0 if an error occurred.
X *----------------------------------------------------------------------
X */
X
XTSendPacket(p,addr)
Xstruct packet *p;
Xchar *addr;
X{
Xchar subject[80];
XFILE *fp;
Xint status;
X
X
Xif ((fp = fopen(rc.tempfile,"w")) == NULL) {	/* open temp file */
X	message("ERROR: can't create %s!\n",rc.tempfile);
X	return;
X	}
Xfprintf(fp,"<<<===LDB===>>>\n");	/* send magic header text */
Xnvwrite(fp,nv_packet,p);	/* write the contents of the packet */
Xfclose(fp);				/* close temp file */
Xsprintf(subject,"<=LDB=> from %s (Long Distance Backgammon)", rc.myname);
Xstatus = TSendFile(addr,rc.tempfile,subject);	/* send the file */
Xunlink(rc.tempfile);		/* delete the temp file */
Xreturn(status);
X}
X
X
X/*----------------------------------------------------------------------
X *	TSendFile -- send a file to an address
X *
X * This function takes an e-mail address, a file, and a subject line,
X * and sends the contents of the file to the specified address.  The
X * subject is set to the contents of the subject argument, which should
X * be one line.  TSendFile returns a 1 if the message was sent,
X * and a 0 if an error occurred.
X *----------------------------------------------------------------------
X */
X
XTSendFile(addr,file,subj)
Xchar *addr, *file, *subj;
X{
Xchar cmd[256];
Xchar *subs[3];
Xint s;
X
Xsubs[0] = addr;			/* substitute $a with opponent address */
Xsubs[1] = file;			/* substitue $f with file */
Xsubs[2] = subj;			/* substitute $s with subject */
XPStringSub(rc.sendcmd,"afs",subs,cmd);
Xs = system(cmd);			/* execute email command */
Xreturn(s == SYS_GOOD);
X}
X
X
X
X/*----------------------------------------------------------------------
X *	PStringSub -- substitute variables in a string
X *
X * This function copies str to obuf, replacing occurrences of $x to
X * a corresponding string.  The characters which can appear after
X * the $ are passed in a single string in the "chars" argument, and
X * the strings to replace them with are passed, in the same order as
X * the characters appear in "chars", in the "strings" argument.
X *----------------------------------------------------------------------
X */
X
XPRIVATE PStringSub(str,chars,strings,obuf)
Xchar *str, *chars, *strings[], obuf[];
X{
Xchar *s, *o, *t;
X
Xfor (s = str, o = obuf; *s; s++) {
X	if (*s != '$') {	/* as long as we don't see a $ */
X		*o++ = *s;	/* just keep copying */
X		continue;
X		}
X	s++;
X	if (*s == '$') {	/* $$ is a single $ */
X		*o++ = '$';
X		continue;
X		}
X	if ( (t = strchr(chars,*s)) == NULL)	/* skip invalid $ subs */
X		continue;
X	t = strings[t - chars];		/* get ptr to replacement string */
X	while (*t)			/* copy it to obuf */
X		*o++ = *t++;
X	}
X*o = '\0';				/* null terminate obuf */
X}
END_OF_FILE
if test 4960 -ne `wc -c <'t_email.c'`; then
    echo shar: \"'t_email.c'\" unpacked with wrong size!
fi
# end of 't_email.c'
fi
echo shar: End of archive 1 \(of 12\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 12 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
