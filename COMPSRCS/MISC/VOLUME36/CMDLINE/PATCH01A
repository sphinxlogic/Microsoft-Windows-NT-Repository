Newsgroups: comp.sources.misc
From: brad@hcx1.ssd.csd.harris.com (Brad Appleton)
Subject: v36i093:  cmdline - C++ Library for parsing command-line arguments, Patch01a/2
Message-ID: <csm-v36i093=cmdline.125351@sparky.IMD.Sterling.COM>
X-Md4-Signature: d5a29f9fc42655e644590ff4f9a878bf
Date: Sun, 4 Apr 1993 17:54:42 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: brad@hcx1.ssd.csd.harris.com (Brad Appleton)
Posting-number: Volume 36, Issue 93
Archive-name: cmdline/patch01a
Environment: C++
Patch-To: cmdline: Volume 31, Issue 47-54

This is patch01 for the CmdLine C++ library and cmdparse command.

To apply this patch:

1) cd to your "CmdLine" source directory
2) unshar this file by typing "sh name-of-this-file"
   (this will create the file PATCH01)
3) type "patch -p0 <PATCH01"

The changes made in this patch are as follows:

- Made some more fixes to get the package to compile with g++.

- A description string may now be attached to a CmdLine object and it will
  be printed (with the heading "Description:") as the last part of verbose
  usage messages if the description-string is non-NULL and non-empty.

- Added a "sequence" to a CmdArg that indicates the relative order in
  which the arguments appeared on the command line. Also added a member
  to CmdLine that returns the number of valid arguments found (the sequence
  of an argument will be zero if it was not given, otherwise it will be in
  the range 1 .. #valid-args-parsed).

- Added a facility for programmers to setup their own parse-termination
  handler so they can do something besides exit if they so desire.

- Added the ability to allow (at run-time) the use of "+" as the long-option
  prefix (this could be done only at compile-time until now).

If you don't already have either Options or CmdLine sources, you can get 
them from your nearest comp.sources.misc archive or you can e-mail me at
brad@travis.csd.harris.com and I will send them to you.

For those of you that are unfamiliar with CmdLine and/or cmdparse,
the description from the Overview file follows:

 

                    An overview of CmdLine and cmdparse
                    ===================================

                 by Brad Appleton <brad@ssd.csd.harris.com>


 Introduction
 ------------
 CmdLine is a C++ Library for parsing command-line arguments. It is 
 approximately 2000 lines of C++ code (excluding comments).

 Cmdparse is a command-line interface to CmdLine for Unix shell-scripts.
 It is approximately 1200 lines of C++ code (excluding comments).


 CmdLine(3C++)
 -------------
 CmdLine is a set of classes to parse command-line arguments.  Unlike
 getopt() and its variants, CmdLine does more than just split up the
 command-line into some canonical form.  CmdLine will actually parse
 the command-line, assigning the appropriate command-line values to
 the corresponding variables, and will verify the command-line syntax
 (and print a usage message if necessary) all in one member function
 call.  Furthermore, many features of CmdLine's parsing behavior are
 configurable at run-time.  These features include the following:

     o  Prompting the user for missing arguments.
     o  Allowing keywords (-count=4) and/or options (-c4).
     o  Ignoring bad syntax instead of terminating.
     o  Ignoring upper/lower case on the command-line.
     o  Suppressing the printing of syntax error messages.
     o  Controlling the verboseness of usage messages.
     o  Controlling whether or not options may be processed
          after positional parameters have been seen.

 CmdLine also allows for options that take an optional argument, options
 that take a (possibly optional) list of one or more arguments, sticky
 options (options whose argument must reside in the same token as the
 option itself), and options whose argument must reside in a separate
 token from the option itself.

 CmdLine consists of a set of C++ classes to parse arguments from an
 input source called a CmdLineArgIter (which is a base class for iterating
 over arguments from an arbitrary input source).  Argument iterators are
 defined for an argv[] array (with or without a corresponding argc), for
 a string of tokens that are separated by a given set of delimiters, and
 for an input-stream.  Users can easily extend CmdLine to parse arguments
 from other input sources simply by creating their own argument iterator
 classes derived from the CmdLineArgIter class defined in <cmdline.h>.

 Command-line arguments are themselves objects that contain a specific
 command-line interface, and a function that performs the desired actions
 when its corresponding argument is seen on the command line.  Predefined
 command-line argument types (derived from the abstract class CmdArg in
 <cmdline.h>) exist for boolean, integer, floating-point, character, and
 string arguments, and for lists of integers, floats, and strings.  These
 predefined subclasses of CmdArg may be found in <cmdargs.h>.  Users can
 also create their own command-argument types on the fly by defining and
 implementing an appropriate subclass of the CmdArg class.

 Using CmdLine is relatively easy - you need to construct your arguments,
 your command-line, and your argument iterator.  Then all that is left to
 do is call the "parse" member function of your CmdLine object.  The
 following is a simple example:

    #include <stdlib.h>
    #include <iostream.h>
    #include <cmdargs.h>

    int  main(int argc, char * argv[])
    {
          // Declare arguments
       CmdArgInt  count('c', "count", "number", "number of copies to print.");
       CmdArgBool xflag('x', "xmode", "turn on 'x'-mode.");
       CmdArgChar fdsep('s', "separator", "char", "field-separator to use.");
       CmdArgStr  input("input-file",  "input file to read.");
       CmdArgStrList  output("[output-file ...]",  "where to print output.");

          // Declare command object and its argument-iterator
       CmdLine  cmd(*argv, &count, &xflag, &fdsep, &input, &output, NULL);
       CmdArgvIter  arg_iter(--argc, ++argv);

          // Initialize arguments to appropriate default values.
       count = 1;
       xflag = 0;
       fdsep = ',';

          // Parse arguments
       cmd.parse(arg_iter);

          // Print arguments
       cout << "count=" << count << endl ;
       cout << "xflag=" << (xflag ? "ON" : "OFF") << endl ;
       cout << "fdsep='" << (char) fdsep << "'" << endl ;
       cout << "input=\"" << input << "\"" << endl ;
       
       for (int i = 0 ; i < output.count() ; i++) {
          cout << "output[" << i << "]=" << output[i] << endl ;
       }

       return  0;
    }


 The Unix command-line syntax for the above program would be as follows:

    Usage: progname [-c number] [-x] [-s char] input-file [output-file ...]

    Options/Arguments:
            -c number        number of copies to print.
            -x               turn on 'x'-mode.
            -s char          field-separator to use.
            input-file       input file to read.
            output-file ...  where to print output.


 The Unix command-line syntax using long-options (keywords) for the above
 program would be as follows:

    Usage: progname [--count number] [--xmode] [--separator char]
                    input-file [output-file ...]

    Options/Arguments:
            --count number    number of copies to print.
            --xmode           turn on 'x'-mode.
            --separator char  field-separator to use.
            input-file        input file to read.
            output-file ...   where to print output.

 If desired, one can set a configuration flag at run-time to allow "+"
 to also be recognized (in addition to "--") as a long-option prefix.

 By default, CmdLine allows both options and long-options to appear on the
 command-line. You can instruct CmdLine to disallow one or the other however.
 As an "extra", when options are disallowed, the "-" prefix is assumed to
 denote a long-option instead of an option (hence either "-" or "--" denotes
 a keyword in this case).  Using this feature, CmdLine can be used to supply
 the type of long-option syntax that is now becoming quite popular in the
 Unix world. Using this "new" syntax, the command-line syntax for the above
 command would be the following:

    Usage: progname [-count number] [-xmode] [-separator char]
                    input-file [output-file ...]

    Options/Arguments:
            -count number    number of copies to print.
            -xmode           turn on 'x'-mode.
            -separator char  field-separator to use.
            input-file       input file to read.
            output-file ...  where to print output.


 It should be mentioned that, when long-options are used, only a unique
 prefix of the keyword needs to be given (and character-case is ignored).
 Hence, in the above example, "-x", "-X", and "-xm" will match "-xmode".


 cmdparse(1)
 -----------
 Using "cmdparse" is even easier than using CmdLine. You declare your
 arguments in a string and then you invoke cmdparse with the command
 line of your shell-script and cmdparse will output a script of variable
 settings for you to evaluate.  The following is an example (using the
 same arguments as in our sample program):

    #!/bin/sh
    NAME="`/bin/basename $0`"

    ARGS='
       ArgInt   count  "[c|count number]"    "number of copies to print."
       ArgBool  xflag  "[x|xmode]"           "turn on x-mode."
       ArgChar  fdsep  "[s|separator char]"  "field-separator to use."
       ArgStr   input  "input-file"          "input file to read."
       ArgStr   output "[output-file ...]"   "where to print output."
    '

    if  cmdparse -shell=sh -decls="$ARGS" -- $NAME "$@" > tmp$$
    then
       . tmp$$
       /bin/rm -f tmp$$
    else
       EXITVAL=$?
       /bin/rm -f tmp$$
       exit $EXITVAL
    fi

    echo "xflag=" $xflag
    echo "count=" $count
    echo "fdsep=" $fdsep
    echo "input=" $input
    if [ "$output" ] ; then
       echo "output=" $output
    fi


 Note that you declare the syntax of an argument differently for cmdparse
 than for CmdLine. The syntax for a single argument for cmdparse looks like
 the following:

    <arg-type>  <arg-name>  <syntax>  <description>

 Where <arg-type> is one of the following:

    ArgInt     --  an integer value (or list of values)
    ArgFloat   --  a floating-point value (or list of values)
    ArgChar    --  a character value (or list of values)
    ArgStr     --  a string value (or list of values)
    ArgBool    --  a boolean flag that is turned ON
    ArgClear   --  a boolean flag that is turned OFF
    ArgToggle  --  a boolean flag that is toggled
    ArgUsage   --  print usage and exit
    ArgDummy   --  a dummy argument

 If desired, the leading "Arg" portion may be omitted from the type-name.

 <arg-name> is simply the name of the variable in your script that you wish
 to contain the resultant value from the command-line.  Any default value
 must be assigned to the variable before invoking cmdparse.

 <syntax> and <description> *MUST* be enclosed in either single or double
 quotes! <description> is simply that, the description of the argument.
 
 <syntax> is a little trickier, there are three basic forms of syntax:

   1)  "c|keyword"        -- an option the takes no value
   2)  "c|keyword value"  -- an option that takes a value
   3)  "value"            -- a positional parameter

 Note that the option-character MUST precede the keyword-name and that
 there must be NO spaces surrounding the '|' in "c|keyword"!

 Any "optional" parts of the argument should appear inside square-brackets
 ('[' and ']') and a list of values is denoted by an ellipsis (" ...").
 Most options will be inside of square brackets to reflect the fact that
 they are "optional".

 Some example <syntax> strings follow:

    "c|keyword"                -- a required option
    "[c|keyword]"              -- an option with no value
    "[c|keyword value]"        -- an option that takes a value
    "[c|keyword [value]]"      -- an option that takes an optional value
    "[c|keyword value ...]"    -- an option that takes 1 or more values
    "[c|keyword [value ...]]"  -- an option that takes 0 or more values
    "value"                    -- a required positional parameter
    "[value]"                  -- an optional positional-parameter
    "[c|keyword] value"        -- a required argument that may be matched
                                  either positionally or by keyword!


 Further Information
 -------------------
 This is just a brief overview of what the CmdLine package can do. Please
 read the documentation for a more thorough explanation of this products'
 capabilities and limitations!


______________________ "And miles to go before I sleep." ______________________
 Brad Appleton                         Harris Corp., Computer Systems Division
   Senior Software Engineer            2101 West Cypress Creek Road,  M/S 161 
     brad@ssd.csd.harris.com           Fort Lauderdale, FL  33309-1892  USA
       ...!uunet!travis!brad                 Phone: (305) 973-5190
~~~~~~~~~~~~~~~~~~~ Disclaimer: I said it, not my employer! ~~~~~~~~~~~~~~~~~~~

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  PATCH01.A
# Wrapped by kent@sparky on Sun Apr  4 12:46:49 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 2)."'
if test -f 'PATCH01.A' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'PATCH01.A'\"
else
  echo shar: Extracting \"'PATCH01.A'\" \(36495 characters\)
  sed "s/^X//" >'PATCH01.A' <<'END_OF_FILE'
X*** Config.mk.OLD	Fri Mar 26 10:48:58 1993
X--- Config.mk	Mon Mar  1 10:54:09 1993
X***************
X*** 73,79 ****
X  CAT=cat
X  
X     ## maintain archives
X! AR=ar -r
X  
X     ## maintain library archives
X  RANLIB=ranlib
X--- 73,79 ----
X  CAT=cat
X  
X     ## maintain archives
X! AR=ar r
X  
X     ## maintain library archives
X  RANLIB=ranlib
X***************
X*** 164,170 ****
X  DBG=-g
X  
X     ## option to indicate the name of the executable file
X! EXE=-o
X  
X     ## option to suppress the loading phase
X  NOLD=-c
X--- 164,170 ----
X  DBG=-g
X  
X     ## option to indicate the name of the executable file
X! EXE=-o 
X  
X     ## option to suppress the loading phase
X  NOLD=-c
X***************
X*** 183,198 ****
X  FLAG=$(OPT)
X  # FLAG=$(DBG)
X  TESTDEFS=
X! # USRDEFS=$(DEF)DEBUG_CMDLINE
X  OPTIONS=
X  
X  #------------------------------------------------------------------------------
X  # Define the macro to pass to recursive makes
X  #
X! RECUR= FLAG=$(FLAG) \
X!    TESTDEFS=$(TESTDEFS) \
X!    USRDEFS=$(USRDEFS) \
X!    OPTIONS=$(OPTIONS)
X  
X  #------------------------------------------------------------------------------
X  # Define the command for recursive makes
X--- 183,198 ----
X  FLAG=$(OPT)
X  # FLAG=$(DBG)
X  TESTDEFS=
X! USRDEFS=$(DEF)DEBUG_CMDLINE
X  OPTIONS=
X  
X  #------------------------------------------------------------------------------
X  # Define the macro to pass to recursive makes
X  #
X! RECUR= "FLAG=$(FLAG)" \
X!    "TESTDEFS=$(TESTDEFS)" \
X!    "USRDEFS=$(USRDEFS)" \
X!    "OPTIONS=$(OPTIONS)"
X  
X  #------------------------------------------------------------------------------
X  # Define the command for recursive makes
X*** MANIFEST.OLD	Fri Mar 26 10:49:02 1993
X--- MANIFEST	Tue Mar 23 17:08:01 1993
X***************
X*** 3,9 ****
X   Config.mk                  2	Make flags for the product
X   MANIFEST                   1	This shipping list
X   Makefile                   1	Makefile for the product
X!  Overview                   3	A brief overview of the product
X   README                     1	Read this file first
X   doc                        1	Documentation directory
X   doc/Makefile               1	Makefile for the documentation
X--- 3,9 ----
X   Config.mk                  2	Make flags for the product
X   MANIFEST                   1	This shipping list
X   Makefile                   1	Makefile for the product
X!  Overview                   4	A brief overview of the product
X   README                     1	Read this file first
X   doc                        1	Documentation directory
X   doc/Makefile               1	Makefile for the documentation
X***************
X*** 12,18 ****
X   doc/classes.man            4	documents the basics of the most common classes
X   doc/cmdargs.man3           2	documents <cmdargs.h>
X   doc/cmdline.man3           2	documents <cmdline.h>
X!  doc/cmdparse.man1          5	documents cmdparse(1)
X   doc/environ.man            1	documents the use of environment variables
X   doc/example.man            1	documents example use of CmdLine(3C++)
X   doc/files.man              1	documents files used by CmdLine(3C++)
X--- 12,18 ----
X   doc/classes.man            4	documents the basics of the most common classes
X   doc/cmdargs.man3           2	documents <cmdargs.h>
X   doc/cmdline.man3           2	documents <cmdline.h>
X!  doc/cmdparse.man1          6	documents cmdparse(1)
X   doc/environ.man            1	documents the use of environment variables
X   doc/example.man            1	documents example use of CmdLine(3C++)
X   doc/files.man              1	documents files used by CmdLine(3C++)
X***************
X*** 27,33 ****
X   src/cmd/cmdparse.c         6	the guts of the cmdparse program
X   src/cmd/cmdparse.h         1	the specification of the cmdparse program
X   src/cmd/cmdparse.pl        2	cmdparse for Perl programmers
X!  src/cmd/cmdparse.tcl       1	cmdparse for Tcl programmers
X   src/cmd/fsm.c              2	finite-state-machine for parsing arg-syntax
X   src/cmd/fsm.h              1	finite-state-machine specification
X   src/cmd/main.c             1	main program for cmdparse(1)
X--- 27,33 ----
X   src/cmd/cmdparse.c         6	the guts of the cmdparse program
X   src/cmd/cmdparse.h         1	the specification of the cmdparse program
X   src/cmd/cmdparse.pl        2	cmdparse for Perl programmers
X!  src/cmd/cmdparse.tcl       2	cmdparse for Tcl programmers
X   src/cmd/fsm.c              2	finite-state-machine for parsing arg-syntax
X   src/cmd/fsm.h              1	finite-state-machine specification
X   src/cmd/main.c             1	main program for cmdparse(1)
X***************
X*** 35,41 ****
X   src/cmd/quoted.h           1	definition of a quoted-string class
X   src/cmd/shell_arg.c        1	implementation of an abstract shell-script arg
X   src/cmd/shell_arg.h        1	definition of an abstract shell-script argument
X!  src/cmd/shells.c           4	implementation of command-interpreters
X   src/cmd/shells.h           4	definitions of various command-interpreters
X   src/cmd/syntax.c           4	implementation of an argument-syntax object
X   src/cmd/syntax.h           1	definition of an argument-syntax object
X--- 35,41 ----
X   src/cmd/quoted.h           1	definition of a quoted-string class
X   src/cmd/shell_arg.c        1	implementation of an abstract shell-script arg
X   src/cmd/shell_arg.h        1	definition of an abstract shell-script argument
X!  src/cmd/shells.c           5	implementation of command-interpreters
X   src/cmd/shells.h           4	definitions of various command-interpreters
X   src/cmd/syntax.c           4	implementation of an argument-syntax object
X   src/cmd/syntax.h           1	definition of an argument-syntax object
X***************
X*** 45,51 ****
X   src/lib/arglist.h          1	command argument list type definitions
X   src/lib/cmdarg.c           3	implementation of base class CmdArg
X   src/lib/cmdargs.c          5	implementation of the various argument types
X!  src/lib/cmdargs.h          7	include file for the various argument types
X   src/lib/cmdline.c          3	constructors/destructors for CmdLine objects
X   src/lib/cmdline.h          7	include file for the library
X   src/lib/cmdtest.c          3	test program for the library
X--- 45,51 ----
X   src/lib/arglist.h          1	command argument list type definitions
X   src/lib/cmdarg.c           3	implementation of base class CmdArg
X   src/lib/cmdargs.c          5	implementation of the various argument types
X!  src/lib/cmdargs.h          8	include file for the various argument types
X   src/lib/cmdline.c          3	constructors/destructors for CmdLine objects
X   src/lib/cmdline.h          7	include file for the library
X   src/lib/cmdtest.c          3	test program for the library
X***************
X*** 52,62 ****
X   src/lib/dump.c             3	dumping/debugging member functions
X   src/lib/exits.h            1	definition of exit codes used for exit(3C)
X   src/lib/fifolist.c         1	implementation of a generic FIFO linked list
X!  src/lib/fifolist.h         2	definition of a generic FIFO linked list
X   src/lib/parse.c            2	public parsing functions for CmdLine
X   src/lib/patchlevel.c       1	functions to return version information
X   src/lib/private.c          5	private/protected functions for a CmdLine
X   src/lib/states.h           1	state enumeration definitions
X   src/lib/strindent.c        3	function to print a hanging indented paragraph
X!  src/lib/unix.c             6	Unix specific parts of a CmdLine
X   src/lib/usage.c            3	usage-message specific parts of a CmdLine
X--- 52,62 ----
X   src/lib/dump.c             3	dumping/debugging member functions
X   src/lib/exits.h            1	definition of exit codes used for exit(3C)
X   src/lib/fifolist.c         1	implementation of a generic FIFO linked list
X!  src/lib/fifolist.h         3	definition of a generic FIFO linked list
X   src/lib/parse.c            2	public parsing functions for CmdLine
X   src/lib/patchlevel.c       1	functions to return version information
X   src/lib/private.c          5	private/protected functions for a CmdLine
X   src/lib/states.h           1	state enumeration definitions
X   src/lib/strindent.c        3	function to print a hanging indented paragraph
X!  src/lib/unix.c             7	Unix specific parts of a CmdLine
X   src/lib/usage.c            3	usage-message specific parts of a CmdLine
X*** Overview.OLD	Fri Mar 26 10:49:11 1993
X--- Overview	Wed Mar  3 14:57:55 1993
X***************
X*** 37,46 ****
X            after positional parameters have been seen.
X  
X   CmdLine also allows for options that take an optional argument, options
X!  that take a (possibly optional) list of one or more arguments, options
X!  whose argument must reside in the same token as the option itself, and
X!  options whose argument must reside in a separate token from the option
X!  itself.
X  
X   CmdLine consists of a set of C++ classes to parse arguments from an
X   input source called a CmdLineArgIter (which is a base class for iterating
X--- 37,46 ----
X            after positional parameters have been seen.
X  
X   CmdLine also allows for options that take an optional argument, options
X!  that take a (possibly optional) list of one or more arguments, sticky
X!  options (options whose argument must reside in the same token as the
X!  option itself), and options whose argument must reside in a separate
X!  token from the option itself.
X  
X   CmdLine consists of a set of C++ classes to parse arguments from an
X   input source called a CmdLineArgIter (which is a base class for iterating
X***************
X*** 130,135 ****
X--- 130,137 ----
X              input-file        input file to read.
X              output-file ...   where to print output.
X  
X+  If desired, one can set a configuration flag at run-time to allow "+"
X+  to also be recognized (in addition to "--") as a long-option prefix.
X  
X   By default, CmdLine allows both options and long-options to appear on the
X   command-line. You can instruct CmdLine to disallow one or the other however.
X***************
X*** 210,216 ****
X      ArgClear   --  a boolean flag that is turned OFF
X      ArgToggle  --  a boolean flag that is toggled
X      ArgUsage   --  print usage and exit
X!     ArgDummy   -- a dummy argument
X  
X   If desired, the leading "Arg" portion may be omitted from the type-name.
X  
X--- 212,218 ----
X      ArgClear   --  a boolean flag that is turned OFF
X      ArgToggle  --  a boolean flag that is toggled
X      ArgUsage   --  print usage and exit
X!     ArgDummy   --  a dummy argument
X  
X   If desired, the leading "Arg" portion may be omitted from the type-name.
X  
X*** README.OLD	Fri Mar 26 10:49:15 1993
X--- README	Wed Mar  3 14:47:09 1993
X***************
X*** 62,67 ****
X--- 62,69 ----
X   msdos           Needed for MS-DOS systems.
X   os2             Needed for OS/2 Systems.
X  
X+  __gplusplus     Needed if you are using g++ as your C++ compiler.
X+ 
X   unix_style      (This is the default) Use this to have CmdLine parse
X                   command-lines using traditional Unix command-line syntax.
X  
X***************
X*** 68,75 ****
X   vms_style       (Not yet supported) Use this to have CmdLine parse
X                   command-lines using traditional VAX/VMS DCL syntax.
X  
X!  USE_PLUS        Makes CmdLine use "+" instead of "--" as the keyword prefix
X!                  when -Dunix_style is used.
X  
X   DEBUG_CMDLINE   Enables use of the "dump" member functions in the CmdLine
X                   library.
X--- 70,77 ----
X   vms_style       (Not yet supported) Use this to have CmdLine parse
X                   command-lines using traditional VAX/VMS DCL syntax.
X  
X!  ibm_style       (Not yet supported) Use this to have CmdLine parse
X!                  command-lines using traditional IBM-PC (MS-DOS) syntax.
X  
X   DEBUG_CMDLINE   Enables use of the "dump" member functions in the CmdLine
X                   library.
X***************
X*** 154,156 ****
X--- 156,189 ----
X   -----------------------------------------------------------------------------
X   First release.
X  
X+ 
X+  11/13/92		Brad Appleton		<brad@ssd.csd.harris.com>
X+  -----------------------------------------------------------------------------
X+  Made some fixes to get the package to compile with g++ and Borland C++.
X+ 
X+ 
X+  02/24/93		Brad Appleton		<brad@ssd.csd.harris.com>
X+  -----------------------------------------------------------------------------
X+  Made some more fixes to get the package to compile with g++.
X+ 
X+ 
X+  03/03/93		Brad Appleton		<brad@ssd.csd.harris.com>
X+  -----------------------------------------------------------------------------
X+  Added a few new features:
X+ 
X+  - A description string may now be attached to a CmdLine object and it will
X+    be printed (with the heading "Description:") as the last part of verbose
X+    usage messages if the description-string is non-NULL and non-empty.
X+ 
X+  - Added a "sequence" to a CmdArg that indicates the relative order in
X+    which the arguments appeared on the command line. Also added a member
X+    to CmdLine that returns the number of valid arguments found (the sequence
X+    of an argument will be zero if it was not given, otherwise it will be in
X+    the range 1 .. #valid-args-parsed).
X+ 
X+  - Added a facility for programmers to setup their own parse-termination
X+    handler so they can do something besides exit if they so desire.
X+ 
X+  - Added the ability to allow (at run-time) the use of "+" as the long-option
X+    prefix (this could be done only at compile-time until now).
X+    
X*** doc/cmdparse.man1.OLD	Fri Mar 26 10:49:22 1993
X--- doc/cmdparse.man1	Wed Mar  3 14:34:45 1993
X***************
X*** 20,25 ****
X--- 20,26 ----
X  [\fB\-noabort\fP]
X  [\fB\-noguessing\fP]
X  [\fB\-prompt\fP]
X+ [\fB\-plus\fP]
X  .if t .br
X  [\fB\-options-only\fP]
X  [\fB\-keywords-only\fP]
X***************
X*** 167,172 ****
X--- 168,177 ----
X  \fB\-prompt\fP
X  Prompt the user interactively for any missing required arguments.
X  .TP
X+ \fB\-plus\fP
X+ Allow the prefix ``+'' to be used to indicate a long-option.
X+ (this may also be specified by saying \fB\-+\fP).
X+ .TP
X  \fB\-options-only\fP
X  Don't match keywords (long-options).  Look only for single-character options.
X  .TP
X***************
X*** 391,397 ****
X  At present, \*(NM knows about the following shells:
X  .RS
X  .IP \fIsh\fP  6
X! The Bourne Shell. This shell is the standard unix shell
X  (designed and written by Stephen R. Bourne).
X  .IP \fIcsh\fP  6
X  The C Shell. Bill Joy's answer to \fIsh\fP using C-like syntax.
X--- 396,402 ----
X  At present, \*(NM knows about the following shells:
X  .RS
X  .IP \fIsh\fP  6
X! The Bourne Shell. This shell is the standard Unix shell
X  (designed and written by Stephen R. Bourne).
X  .IP \fIcsh\fP  6
X  The C Shell. Bill Joy's answer to \fIsh\fP using C-like syntax.
X*** doc/parsing.man.OLD	Fri Mar 26 10:49:28 1993
X--- doc/parsing.man	Wed Mar  3 14:34:32 1993
X***************
X*** 9,15 ****
X  By default, \*(NM will allow both single-character options \fIand\fP
X  keywords (long-options) to be matched on the command-line.
X  Under Unix, a single character option is prefixed by the string ``\-''.
X! and a long-option is prefixed by the string ``\*(--''.  If a token
X  on the command-line exactly matches the string ``\*(--'', then all
X  further matching of options (both long and short) are disabled and
X  any remaining arguments are considered to be positional parameters
X--- 9,17 ----
X  By default, \*(NM will allow both single-character options \fIand\fP
X  keywords (long-options) to be matched on the command-line.
X  Under Unix, a single character option is prefixed by the string ``\-''.
X! and a long-option is prefixed by the string ``\*(--''.
X! (If desired, the string ``+'' may also be used as a long-option prefix
X! by explicitly specifying the corresponding flag).  If a token
X  on the command-line exactly matches the string ``\*(--'', then all
X  further matching of options (both long and short) are disabled and
X  any remaining arguments are considered to be positional parameters
X***************
X*** 17,26 ****
X  
X  If short-option processing is disabled, then the prefix ``\-'' may be used
X  to indicate a long-option (the ``\*(--'' prefix will still be accepted).
X- 
X- If desired, the string ``+'' may be used as the long-option prefix
X- instead of ``\*(--'' by defining the constant \s-1USE_PLUS\s+1 when
X- building \f4CmdLine\fP.
X  .RE
X  
X  .SS "OPTION MATCHING"
X--- 19,24 ----
X*** src/cmd/cmdparse.c.OLD	Fri Mar 26 10:49:36 1993
X--- src/cmd/cmdparse.c	Wed Mar  3 14:09:57 1993
X***************
X*** 7,12 ****
X--- 7,15 ----
X  //
X  // ^HISTORY:
X  //    04/26/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X+ //
X+ //    03/01/93	Brad Appleton	<brad@ssd.csd.harris.com>
X+ //    - Added ALLOW_PLUS to list of CmdLine configuration flags
X  //-^^---------------------------------------------------------------------
X  
X  #include <stdlib.h>
X***************
X*** 84,90 ****
X  {
X     cerr << cmd.name() << "\trelease " << cmd.release()
X          << " at patchlevel " << cmd.patchlevel() << endl ;
X!    ::exit(e_VERSION);
X     return  0;  // shutup the compiler about not returning a value
X  }
X  
X--- 87,93 ----
X  {
X     cerr << cmd.name() << "\trelease " << cmd.release()
X          << " at patchlevel " << cmd.patchlevel() << endl ;
X!    cmd.quit(e_VERSION);
X     return  0;  // shutup the compiler about not returning a value
X  }
X  
X***************
X*** 566,571 ****
X--- 569,577 ----
X       prompt('p', "prompt",
X          "Prompt the user interactively for any missing required arguments."
X       ),
X+      plus('+', "plus",
X+         "Allow the string \"+\" to be used as a long-option prefix."
X+      ),
X       opts_only('o', "options-only",
X          "Dont match keywords (long-options)."
X       ),
X***************
X*** 617,627 ****
X          (CmdArg::isPOS | CmdArg::isREQ | CmdArg::isVALREQ)
X       ),
X       usr_args("[arguments ...]",
X!         "The program-arguments to be parsed",
X       )
X  {
X        // Append options.
X!    (*this) << anywhere << anycase << no_abort << no_guessing << prompt
X             << opts_only << kwds_only << quiet << array_variant << usage
X             << version << true_str << false_str << suffix_str << usr_shell
X             << input_file << input_var << input_str << dummy_arg ;
X--- 623,633 ----
X          (CmdArg::isPOS | CmdArg::isREQ | CmdArg::isVALREQ)
X       ),
X       usr_args("[arguments ...]",
X!         "The program-arguments to be parsed"
X       )
X  {
X        // Append options.
X!    (*this) << anywhere << anycase << no_abort << no_guessing << prompt << plus
X             << opts_only << kwds_only << quiet << array_variant << usage
X             << version << true_str << false_str << suffix_str << usr_shell
X             << input_file << input_var << input_str << dummy_arg ;
X***************
X*** 713,718 ****
X--- 719,725 ----
X     if (no_abort)     usr_cmd.set(CmdLine::NO_ABORT);
X     if (no_guessing)  usr_cmd.set(CmdLine::NO_GUESSING);
X     if (prompt)       usr_cmd.set(CmdLine::PROMPT_USER);
X+    if (plus)         usr_cmd.set(CmdLine::ALLOW_PLUS);
X     if (opts_only)    usr_cmd.set(CmdLine::OPTS_ONLY);
X     if (kwds_only)    usr_cmd.set(CmdLine::KWDS_ONLY);
X     if (quiet)        usr_cmd.set(CmdLine::QUIET);
X*** src/cmd/cmdparse.h.OLD	Fri Mar 26 10:49:41 1993
X--- src/cmd/cmdparse.h	Wed Mar  3 14:08:06 1993
X***************
X*** 7,12 ****
X--- 7,15 ----
X  //
X  // ^HISTORY:
X  //    05/01/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X+ //
X+ //    03/01/93	Brad Appleton	<brad@ssd.csd.harris.com>
X+ //    - Added ALLOW_PLUS to list of CmdLine configuration flags
X  //-^^---------------------------------------------------------------------
X  
X  #ifndef _cmdparse_h
X***************
X*** 87,92 ****
X--- 90,96 ----
X     CmdArgBool     no_abort;         // set NO_ABORT
X     CmdArgBool     no_guessing;      // set NO_GUESSING
X     CmdArgBool     prompt;           // set PROMPT_USER
X+    CmdArgBool     plus;             // set ALLOW_PLUS
X     CmdArgBool     opts_only;        // set OPTS_ONLY
X     CmdArgBool     kwds_only;        // set KWDS_ONLY
X     CmdArgBool     quiet;            // set QUIET
X*** src/lib/argiter.c.OLD	Fri Mar 26 10:49:57 1993
X--- src/lib/argiter.c	Tue Mar 23 17:00:10 1993
X***************
X*** 94,107 ****
X  
X  //-------------------------------------------------------- class CmdIstreamIter
X  
X! static const unsigned  MAX_LINE_LEN = 1024 ;
X  
X- #ifdef vms
X-    enum { c_COMMENT = '!' } ;
X- #else
X-    enum { c_COMMENT = '#' } ;
X- #endif
X- 
X     // Constructor
X  CmdIstreamIter::CmdIstreamIter(istream & input) : is(input), tok_iter(NULL)
X  {
X--- 94,101 ----
X  
X  //-------------------------------------------------------- class CmdIstreamIter
X  
X! const unsigned  CmdIstreamIter::MAX_LINE_LEN = 1024 ;
X  
X     // Constructor
X  CmdIstreamIter::CmdIstreamIter(istream & input) : is(input), tok_iter(NULL)
X  {
X***************
X*** 129,141 ****
X     if (result)  return  result;
X     if (! is)  return  NULL;
X  
X!    char buf[MAX_LINE_LEN];
X     do {
X        *buf = '\0';
X        is.getline(buf, sizeof(buf));
X        char * ptr = buf;
X        while (isspace(*ptr)) ++ptr;
X!       if (*ptr && (*ptr != c_COMMENT)) {
X           if (tok_iter) {
X              tok_iter->reset(ptr);
X           } else {
X--- 123,135 ----
X     if (result)  return  result;
X     if (! is)  return  NULL;
X  
X!    char buf[CmdIstreamIter::MAX_LINE_LEN];
X     do {
X        *buf = '\0';
X        is.getline(buf, sizeof(buf));
X        char * ptr = buf;
X        while (isspace(*ptr)) ++ptr;
X!       if (*ptr && (*ptr != CmdIstreamIter::c_COMMENT)) {
X           if (tok_iter) {
X              tok_iter->reset(ptr);
X           } else {
X*** src/lib/cmdarg.c.OLD	Fri Mar 26 10:50:03 1993
X--- src/lib/cmdarg.c	Mon Mar  1 10:31:54 1993
X***************
X*** 7,12 ****
X--- 7,15 ----
X  //
X  // ^HISTORY:
X  //    03/25/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X+ //
X+ //    03/01/93	Brad Appleton	<brad@ssd.csd.harris.com>
X+ //    - Added arg_sequence field to CmdArg
X  //-^^---------------------------------------------------------------------
X  
X  #include <stdlib.h>
X***************
X*** 22,34 ****
X  
X     // Copy-Constructor
X  CmdArg::CmdArg(const CmdArg & cp)
X!    : arg_char_name(cp.arg_char_name),
X       arg_keyword_name(cp.arg_keyword_name),
X       arg_value_name(cp.arg_value_name),
X!      alloc_value_name(cp.alloc_value_name),
X!      arg_syntax(cp.arg_syntax),
X!      arg_description(cp.arg_description),
X!      arg_flags(cp.arg_flags)
X  {
X     if (alloc_value_name) {
X        char * val_name = new char[::strlen(cp.arg_value_name) + 1] ;
X--- 25,38 ----
X  
X     // Copy-Constructor
X  CmdArg::CmdArg(const CmdArg & cp)
X!    : alloc_value_name(cp.alloc_value_name),
X!      arg_flags(cp.arg_flags),
X!      arg_syntax(cp.arg_syntax),
X!      arg_sequence(cp.arg_sequence),
X!      arg_char_name(cp.arg_char_name),
X       arg_keyword_name(cp.arg_keyword_name),
X       arg_value_name(cp.arg_value_name),
X!      arg_description(cp.arg_description)
X  {
X     if (alloc_value_name) {
X        char * val_name = new char[::strlen(cp.arg_value_name) + 1] ;
X***************
X*** 44,55 ****
X                 const char * value,
X                 const char * description,
X                 unsigned     syntax_flags)
X!    : arg_char_name(optchar),
X!      arg_keyword_name(keyword),
X!      arg_value_name(value), alloc_value_name(0),
X       arg_syntax(syntax_flags),
X!      arg_description(description),
X!      arg_flags(0)
X  {
X     parse_description();
X     parse_value();
X--- 48,61 ----
X                 const char * value,
X                 const char * description,
X                 unsigned     syntax_flags)
X!    : alloc_value_name(0),
X!      arg_flags(0),
X       arg_syntax(syntax_flags),
X!      arg_sequence(0),
X!      arg_char_name(optchar),
X!      arg_keyword_name(keyword),
X!      arg_value_name(value),
X!      arg_description(description)
X  {
X     parse_description();
X     parse_value();
X***************
X*** 61,72 ****
X                 const char * keyword,
X                 const char * description,
X                 unsigned     syntax_flags)
X!    : arg_char_name(optchar),
X!      arg_keyword_name(keyword),
X!      arg_value_name(NULL), alloc_value_name(0),
X       arg_syntax(syntax_flags),
X!      arg_description(description),
X!      arg_flags(0)
X  {
X     parse_description();
X     adjust_syntax();
X--- 67,80 ----
X                 const char * keyword,
X                 const char * description,
X                 unsigned     syntax_flags)
X!    : alloc_value_name(0),
X!      arg_flags(0),
X       arg_syntax(syntax_flags),
X!      arg_sequence(0),
X!      arg_char_name(optchar),
X!      arg_keyword_name(keyword),
X!      arg_value_name(NULL),
X!      arg_description(description)
X  {
X     parse_description();
X     adjust_syntax();
X***************
X*** 76,87 ****
X  CmdArg::CmdArg(const char * value,
X                 const char * description,
X                 unsigned     syntax_flags)
X!    : arg_char_name(0),
X!      arg_keyword_name(NULL),
X!      arg_value_name(value), alloc_value_name(0),
X       arg_syntax(syntax_flags),
X!      arg_description(description),
X!      arg_flags(0)
X  {
X     parse_description();
X     parse_value();
X--- 84,97 ----
X  CmdArg::CmdArg(const char * value,
X                 const char * description,
X                 unsigned     syntax_flags)
X!    : alloc_value_name(0),
X!      arg_flags(0),
X       arg_syntax(syntax_flags),
X!      arg_sequence(0),
X!      arg_char_name(0),
X!      arg_keyword_name(NULL),
X!      arg_value_name(value),
X!      arg_description(description)
X  {
X     parse_description();
X     parse_value();
X*** src/lib/cmdargs.c.OLD	Fri Mar 26 10:50:09 1993
X--- src/lib/cmdargs.c	Wed Mar  3 10:01:29 1993
X***************
X*** 7,12 ****
X--- 7,15 ----
X  //
X  // ^HISTORY:
X  //    03/25/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X+ //
X+ //    03/03/93	Brad Appleton	<brad@ssd.csd.harris.com>
X+ //    - Added exit_handler() and quit() member-functions to CmdLine
X  //-^^---------------------------------------------------------------------
X  
X  #include <stdlib.h>
X***************
X*** 110,117 ****
X  CmdArgUsage::operator()(const char * & , CmdLine & cmd)
X  {
X     cmd.usage(cmd.error(CmdLine::NOPRINT), CmdLine::VERBOSE_USAGE);
X!    ::exit(e_USAGE);
X!    return  SUCCESS;  // get the compiler to shut up about NO return value!
X  }
X  
X  //----------------------------------------------------------- Integer Arguments
X--- 113,120 ----
X  CmdArgUsage::operator()(const char * & , CmdLine & cmd)
X  {
X     cmd.usage(cmd.error(CmdLine::NOPRINT), CmdLine::VERBOSE_USAGE);
X!    cmd.quit(e_USAGE);
X!    return  SUCCESS;
X  }
X  
X  //----------------------------------------------------------- Integer Arguments
X***************
X*** 266,283 ****
X  
X  //------------------------------------------------------------ String Arguments
X  
X! typedef  CmdArgStrCompiler::string  CmdArgString ;
X  
X! CmdArgString::~string(void)
X  {
X     if (is_alloc)  delete [] (char *)str;
X  }
X  
X     // Copy a string (allocating storage if necessary)
X  void
X  CmdArgString::copy(unsigned  is_temporary, const char * s)
X  {
X!    if (is_alloc)  delete  (char *)str;
X     is_alloc = (is_temporary) ? 1 : 0;
X     str = s;
X     if (is_alloc && s) {
X--- 269,288 ----
X  
X  //------------------------------------------------------------ String Arguments
X  
X! typedef  CmdArgStrCompiler::casc_string  CmdArgString ;
X  
X! #ifndef __gplusplus
X! CmdArgString::~casc_string(void)
X  {
X     if (is_alloc)  delete [] (char *)str;
X  }
X+ #endif 
X  
X     // Copy a string (allocating storage if necessary)
X  void
X  CmdArgString::copy(unsigned  is_temporary, const char * s)
X  {
X!    if (is_alloc)  delete [] (char *)str;
X     is_alloc = (is_temporary) ? 1 : 0;
X     str = s;
X     if (is_alloc && s) {
X***************
X*** 315,321 ****
X  }
X  
X  ostream &
X! operator<<(ostream & os, const CmdArgStrCompiler::string & str)
X  {
X     return  (os << str.str) ;
X  }
X--- 320,326 ----
X  }
X  
X  ostream &
X! operator<<(ostream & os, const CmdArgStrCompiler::casc_string & str)
X  {
X     return  (os << str.str) ;
X  }
X*** src/lib/cmdargs.h.OLD	Fri Mar 26 10:50:15 1993
X--- src/lib/cmdargs.h	Thu Feb 25 14:19:53 1993
X***************
X*** 435,467 ****
X     // type that make it unnecessary to know the difference between
X     // it and a "char *" (in most cases).
X     //
X!    struct  string {
X        unsigned     is_alloc : 1 ;
X        const char * str ;
X  
X!       string(void) : is_alloc(0), str(0) {}
X  
X!       string(const char * s) : is_alloc(0), str(s) {}
X  
X        void
X        copy(unsigned  is_temporary, const char * s);
X  
X!       string(unsigned  is_temporary, const char * s)
X           : is_alloc(0), str(0) { copy(is_temporary, s); }
X  
X!       string(const string & cp)
X           : is_alloc(0), str(0) { copy(cp.is_alloc, cp.str); }
X  
X!       string &
X!       operator=(const string & cp)
X           { copy(cp.is_alloc, cp.str); return *this; }
X  
X!       string &
X        operator=(const char * cp) { copy(0, cp); return *this; }
X  
X        operator const char*(void)  const { return  str; }
X  
X!       virtual ~string(void);
X     } ;
X  
X     CmdArgStrCompiler(char         optchar,
X--- 435,471 ----
X     // type that make it unnecessary to know the difference between
X     // it and a "char *" (in most cases).
X     //
X!    struct  casc_string {
X        unsigned     is_alloc : 1 ;
X        const char * str ;
X  
X!       casc_string(void) : is_alloc(0), str(0) {}
X  
X!       casc_string(const char * s) : is_alloc(0), str(s) {}
X  
X        void
X        copy(unsigned  is_temporary, const char * s);
X  
X!       casc_string(unsigned  is_temporary, const char * s)
X           : is_alloc(0), str(0) { copy(is_temporary, s); }
X  
X!       casc_string(const casc_string & cp)
X           : is_alloc(0), str(0) { copy(cp.is_alloc, cp.str); }
X  
X!       casc_string &
X!       operator=(const casc_string & cp)
X           { copy(cp.is_alloc, cp.str); return *this; }
X  
X!       casc_string &
X        operator=(const char * cp) { copy(0, cp); return *this; }
X  
X        operator const char*(void)  const { return  str; }
X  
X!       virtual ~casc_string(void)
X! #ifdef __gplusplus
X!          { if (is_alloc)   delete [] (char *) str; }
X! #endif
X!       ;
X     } ;
X  
X     CmdArgStrCompiler(char         optchar,
X***************
X*** 486,492 ****
X     operator()(const char * & arg, CmdLine & cmd) = 0;
X  
X     int
X!    compile(const char * & arg, CmdLine & cmd, string & value) ;
X  } ;
X  
X  
X--- 490,496 ----
X     operator()(const char * & arg, CmdLine & cmd) = 0;
X  
X     int
X!    compile(const char * & arg, CmdLine & cmd, casc_string & value) ;
X  } ;
X  
X  
X***************
X*** 540,561 ****
X     operator=(const CmdArgStr & cp)  { val = cp.val; return  *this; }
X  
X     CmdArgStr &
X!    operator=(const CmdArgStrCompiler::string & cp)
X        { val = cp; return  *this; }
X  
X     CmdArgStr &
X     operator=(const char * cp)  { val = cp; return  *this; }
X  
X!    operator CmdArgStrCompiler::string(void)  { return  val; }
X  
X     operator const char*(void)  const { return  val.str; }
X  
X  private:
X!    CmdArgStrCompiler::string  val;
X  } ;
X  
X  ostream &
X! operator<<(ostream & os, const CmdArgStrCompiler::string & str);
X  
X  ostream &
X  operator<<(ostream & os, const CmdArgStr & str_arg);
X--- 544,568 ----
X     operator=(const CmdArgStr & cp)  { val = cp.val; return  *this; }
X  
X     CmdArgStr &
X!    operator=(const CmdArgStrCompiler::casc_string & cp)
X        { val = cp; return  *this; }
X  
X     CmdArgStr &
X     operator=(const char * cp)  { val = cp; return  *this; }
X  
X!    operator CmdArgStrCompiler::casc_string(void)  { return  val; }
X  
X     operator const char*(void)  const { return  val.str; }
X  
X+    // use this for comparing to NULL
X+    int isNULL(void) const { return (val.str) ? 0 : 1; }
X+ 
X  private:
X!    CmdArgStrCompiler::casc_string  val;
X  } ;
X  
X  ostream &
X! operator<<(ostream & os, const CmdArgStrCompiler::casc_string & str);
X  
X  ostream &
X  operator<<(ostream & os, const CmdArgStr & str_arg);
X***************
X*** 699,705 ****
X     unsigned
X     count(void) const;
X  
X!    CmdArgStrCompiler::string &
X     operator[](unsigned  index);
X  
X  private:
X--- 706,712 ----
X     unsigned
X     count(void) const;
X  
X!    CmdArgStrCompiler::casc_string &
X     operator[](unsigned  index);
X  
X  private:
X*** src/lib/cmdline.c.OLD	Fri Mar 26 10:50:21 1993
X--- src/lib/cmdline.c	Wed Mar  3 14:40:15 1993
X***************
X*** 13,18 ****
X--- 13,23 ----
X  //
X  // ^HISTORY:
X  //    03/21/92	Brad Appleton	<brad@ssd.csd.harris.com>	Created
X+ //
X+ //    03/01/93	Brad Appleton	<brad@ssd.csd.harris.com>
X+ //    - Added cmd_nargs_parsed field to CmdLine
X+ //    - Added cmd_description field to CmdLine
X+ //    - Added exit_handler() and quit() member-functions to CmdLine
X  //-^^---------------------------------------------------------------------
X  
X  #include <stdlib.h>
X***************
X*** 127,136 ****
X  
X  #if (defined(vms) || defined(msdos) || defined(os2))
X     const char * start, * p1, * p2 ;
X!    const char * str, * ext;
X  
X  # ifdef vms
X!    const char * ver;
X     // remove leading directory and/or device name
X     p1 = ::strrchr(filename, ':');
X     p2 = ::strrchr(filename, ']');
X--- 132,141 ----
X  
X  #if (defined(vms) || defined(msdos) || defined(os2))
X     const char * start, * p1, * p2 ;
X!    char * str, * ext;
X  
X  # ifdef vms
X!    char * ver;
X     // remove leading directory and/or device name
X     p1 = ::strrchr(filename, ':');
X     p2 = ::strrchr(filename, ']');
X***************
X*** 154,165 ****
X  
X     // remove the extension
X     ext = ::strrchr(str, '.');
X!    if (ext)  *ext = '0' ;
X  
X  # ifdef vms
X     // remove the version
X     ver = ::strrchr(str, ';');
X!    if (ver)  *ver = '0' ;
X  # endif
X  
X     return  str ;
X--- 159,170 ----
X  
X     // remove the extension
X     ext = ::strrchr(str, '.');
X!    if (ext)  *ext = '\0' ;
X  
X  # ifdef vms
X     // remove the version
X     ver = ::strrchr(str, ';');
X!    if (ver)  *ver = '\0' ;
X  # endif
X  
X     return  str ;
X***************
X*** 181,190 ****
X       cmd_state(cmd_START_STATE),
X       cmd_flags(DEFAULT_CMDFLAGS),
X       cmd_status(CmdLine::NO_ERROR),
X       cmd_name(NULL),
X       cmd_matched_arg(NULL),
X       cmd_args(NULL),
X!      cmd_err(NULL)
X  {
X     name(cmdname);
X     ::init_args(cmd_args);
X--- 186,198 ----
X       cmd_state(cmd_START_STATE),
X       cmd_flags(DEFAULT_CMDFLAGS),
X       cmd_status(CmdLine::NO_ERROR),
X+      cmd_nargs_parsed(0),
X       cmd_name(NULL),
X+      cmd_description(NULL),
X       cmd_matched_arg(NULL),
X       cmd_args(NULL),
X!      cmd_err(NULL),
X!      cmd_quit_handler(NULL)
X  {
X     name(cmdname);
X     ::init_args(cmd_args);
X***************
X*** 196,205 ****
X       cmd_state(cmd_START_STATE),
X       cmd_flags(DEFAULT_CMDFLAGS),
X       cmd_status(CmdLine::NO_ERROR),
X       cmd_name(NULL),
X       cmd_matched_arg(NULL),
X       cmd_args(NULL),
X!      cmd_err(NULL)
X  {
X     name(cmdname);
X     ::init_args(cmd_args);
X--- 204,216 ----
X       cmd_state(cmd_START_STATE),
X       cmd_flags(DEFAULT_CMDFLAGS),
X       cmd_status(CmdLine::NO_ERROR),
X+      cmd_nargs_parsed(0),
X       cmd_name(NULL),
X+      cmd_description(NULL),
X       cmd_matched_arg(NULL),
X       cmd_args(NULL),
X!      cmd_err(NULL),
X!      cmd_quit_handler(NULL)
X  {
X     name(cmdname);
X     ::init_args(cmd_args);
X***************
X*** 222,231 ****
X       cmd_state(cmd_START_STATE),
X       cmd_flags(DEFAULT_CMDFLAGS),
X       cmd_status(CmdLine::NO_ERROR),
X       cmd_name(NULL),
X       cmd_matched_arg(NULL),
X       cmd_args(NULL),
X!      cmd_err(NULL)
X  {
X     if (cmdarg == NULL)  return;
X     ::init_args(cmd_args);
X--- 233,245 ----
X       cmd_state(cmd_START_STATE),
X       cmd_flags(DEFAULT_CMDFLAGS),
X       cmd_status(CmdLine::NO_ERROR),
X+      cmd_nargs_parsed(0),
X       cmd_name(NULL),
X+      cmd_description(NULL),
X       cmd_matched_arg(NULL),
X       cmd_args(NULL),
X!      cmd_err(NULL),
X!      cmd_quit_handler(NULL)
X  {
X     if (cmdarg == NULL)  return;
X     ::init_args(cmd_args);
X***************
X*** 271,277 ****
X  ostream &
X  CmdLine::error(int  print) const
X  {
X!    ostream * os = (cmd_err) ? (ostream *)cmd_err : &cerr ;
X     if (print && cmd_name && *cmd_name)  *os << cmd_name << ": " ;
X     return  *os;
X  }
X--- 285,291 ----
X  ostream &
X  CmdLine::error(int  print) const
X  {
X!    ostream * os = (cmd_err) ? cmd_err : &cerr ;
X     if (print && cmd_name && *cmd_name)  *os << cmd_name << ": " ;
X     return  *os;
X  }
X***************
X*** 288,293 ****
X--- 302,316 ----
X     return  *this ;
X  }
X  
X+    // terminate parsing altogether
X+ void
X+ CmdLine::quit(int status) {
X+    if (cmd_quit_handler != NULL) {
X+       (*cmd_quit_handler)(status);
X+    } else {
X+       ::exit(status);
X+    }
X+ }
X  
X  //---------------------------------------------------------- CmdLineCmdArgIter
X  
END_OF_FILE
  if test 36495 -ne `wc -c <'PATCH01.A'`; then
    echo shar: \"'PATCH01.A'\" unpacked with wrong size!
  elif test -f 'PATCH01.B' ; then
    echo shar: Combining  \"'PATCH01'\" \(68045 characters\)
    cat 'PATCH01.A' 'PATCH01.B' > 'PATCH01'
    if test 68045 -ne `wc -c <'PATCH01'`; then
      echo shar: \"'PATCH01'\" combined with wrong size!
    else
      rm PATCH01.A PATCH01.B
    fi
  fi
  # end of 'PATCH01.A'
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
