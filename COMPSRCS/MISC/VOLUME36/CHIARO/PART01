Newsgroups: comp.sources.misc
From: jwbirdsa@picarefy.picarefy.com (James W. Birdsall)
Subject: v36i071:  chiaro - Image Utilities, Part01/18
Message-ID: <csm-v36i071=chiaro.120734@sparky.IMD.Sterling.COM>
X-Md4-Signature: 44932c7988c6e4dfa938da66229ec2ea
Date: Thu, 25 Mar 1993 18:09:04 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jwbirdsa@picarefy.picarefy.com (James W. Birdsall)
Posting-number: Volume 36, Issue 71
Archive-name: chiaro/part01
Environment: UNIX, Sun, DECstation, 3B1

This is the Chiaro Suite, a group of image analysis programs covering
several popular formats (GIF, IMG, JFIF, PCX, PBM/PGM/PPM, SunRaster,
Targa, XBM, and BMP). At present, only the GIF format is extensively
supported; additional formats will be added in future releases. The Chiaro
Suite is currently comprised of three programs: chils, gifstrip, and
gifcheck. A manual page for each is provided.

This version of the Chiaro Suite is intended for computers running UNIX
and UNIX-like operating systems. It requires that the "char" type be
exactly eight bits. It works on machines where type "int" is 16 or 32 bits,
and type "long int" is 32 bits. It should work on machines with more bits,
but has not been tested on such.

------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  README src src/chidisp.c templates
# Wrapped by kent@sparky on Thu Mar 25 11:20:00 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 18)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(4250 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
XTHE CHIARO SUITE
XJames W. Birdsall
Xrelease: 03/19/93
X
XINTRO:
X   This is the Chiaro Suite, a group of image analysis programs covering
Xseveral popular formats. At present, only the GIF format is extensively
Xsupported; additional formats will be added in future releases. The Chiaro
XSuite is currently comprised of three programs: chils, gifstrip, and
Xgifcheck. A manual page for each is provided.
X
XREQUIREMENTS:
X   This version of the Chiaro Suite is intended for computers running UNIX
Xand UNIX-like operating systems. It requires that the "char" type be
Xexactly eight bits. It works on machines where type "int" is 16 or 32 bits,
Xand type "long int" is 32 bits. It should work on machines with more bits,
Xbut has not been tested on such.
X
X   If your compiler does not support long identifiers, you will have to run
Xthe "Shorten" utility. If you do not know whether your compiler supports
Xlong identifiers, attempt to compile without running the Shorten utility.
XIf you see many error messages stating that symbols have been redeclared,
Xyour compiler does not support long identifiers. You can use the 'clean'
Xtarget in the makefile ("make clean") to clean up any object files or other
Xtemporary files already created.
X
XINSTALLATION:
X   This version of the Chiaro Suite is intended for computers running UNIX
Xand UNIX-like operating systems. Installation is relatively simple:
X
X	1)  Go into the templates directory and follow the directions
X	    in the README there.
X	1a) If your compiler does not support long identifiers, go into the
X	    src directory and run the Shorten utility by "make -f Shorten".
X	    This usually takes a while to run. If it fails, see "NOTES ON
X	    MAKE" below.
X	2)  In the src directory, type "make". The programs will automatically
X	    be compiled and linked. 
X	3)  Move the executables, the manual pages, and the file chils.cfg
X	    wherever you want them to live permanently. The executables and
X	    manual pages do not have to be in the same directory. See the
X	    manual page for chils for restrictions on placement of the
X	    file chils.cfg.
X	4)  You may customize the file chils.cfg for your preferences and
X	    environment. See the manual page for chils for the format and
X	    contents of chils.cfg.
X
XCHANGES:
X   If you have to create new template files because your system is not
Xalready supported, the author would appreciate it very much if you would
Xmail him your template files, along with as detailed a description of your
Xsystem (hardware, OS, versions, etc.) as possible. Template files sent in
Xwill probably be included in the next release, with appropriate credits.
XInformation on contacting the author is included toward the end of each
Xmanual page.
X
X   If you have to make changes to the source code itself, the author would
Xlike to hear about it as soon as possible, preferably in the form of
Xcontext diffs (and a detailed description of your system). Such changes
Xwill probably be included in the next release, with appropriate credits.
X
XNOTES ON MAKE:
X   Most "make" utilities use the Bourne shell (sh) to execute commands.
XHowever, some use whatever shell is specified by the SHELL environment
Xvariable. If the Shorten utility fails, try adjusting the SHELL environment
Xvariable (the Bourne shell is typically found in /bin/sh). The easiest way
Xto do this, which works in most environments, is: start a Bourne shell as a
Xsubshell of your current one by "sh", change the SHELL environment variable
Xby "SHELL=/bin/sh; export SHELL", then do "make -f Shorten" again. When it
Xis complete, exit the subshell (hitting control-D works on most systems).
X
XMISC:
X   The Chiaro Suite is also available for IBM PCs and compatibles running
XDOS.
X
XCOPYRIGHT AND WARRANTY:
X   Copyright (c) 1993 by James W. Birdsall, all rights reserved.
XPermission is granted to any individual or institution to use, copy, or
Xredistribute this software so long as all of the original files are included
Xunmodified, that it is not sold for profit, and that this copyright notice
Xis retained.
X
XLIKE ANYTHING ELSE THAT'S FREE, THE CHIARO SUITE IS PROVIDED AS IS AND COMES
XWITH NO WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED. IN NO EVENT WILL
XTHE AUTHOR BE LIABLE FOR ANY DAMAGES RESULTING FROM THE USE OF THIS SOFTWARE.
END_OF_FILE
  if test 4250 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test ! -d 'src' ; then
    echo shar: Creating directory \"'src'\"
    mkdir 'src'
fi
if test -f 'src/chidisp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/chidisp.c'\"
else
  echo shar: Extracting \"'src/chidisp.c'\" \(46063 characters\)
  sed "s/^X//" >'src/chidisp.c' <<'END_OF_FILE'
X/***************************************************************************
X*   CHIDISP.C                                                              *
X*   MODULE:  -                                                             *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   The Graphics Interchange Format(c) is the Copyright property of        *
X*   CompuServe Incorporated. GIF(sm) is a Service Mark property of         *
X*   CompuServe Incorporated.                                               *
X*                                                                          *
X*   $Id: chidisp.c,v 1.6 1993/03/12 21:01:31 jwbirdsa Exp $
X*                                                                          *
X*   Display functions for Chiaro suite LS program.                         *
X*                                                                          *
X***************************************************************************/
X
X#include "config.h"
X
X/*
X** system includes <>
X*/
X
X#include <stdio.h>
X#include <ctype.h>
X#ifndef NO_STDLIB
X#include <stdlib.h>
X#endif
X#ifndef NO_STR_INC
X#ifdef STRING_PLURAL
X#include <strings.h>
X#else
X#include <string.h>
X#endif
X#endif
X
X
X/*
X** custom includes ""
X*/
X
X#include "depend.h"
X
X#include "fb.h"
X#include "formats.h"
X#include "gif.h"
X#include "img.h"
X#include "jfif.h"
X#include "sr.h"
X#include "tga.h"
X#include "pnm.h"
X#include "xbm.h"
X#include "bmp.h"
X#include "pcx.h"
X
X#include "chils.h"
X#include "chidisp.h"
X
X
X/*
X** local #defines
X*/
X
X#define PRINT_FMT(f,d)         printf("%-8s ", ((fm_name(f) != NULL) ? \
X                                                fm_name(f) : (d)))
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST rcsid[] = "$Id: chidisp.c,v 1.6 1993/03/12 21:01:31 jwbirdsa Exp $";
X
X
X/*
X** typedefs
X*/
X
X/*
X** global variables
X*/
X
Xint screencols = 0;
X
X/*
X** function prototypes
X*/
X
X#ifdef  __STDC__
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
Xstatic VOID printname P_((char *origname, int printed));
X
X#undef P_
X
X#ifdef NO_STDLIB
Xextern char *getenv();
X#endif
X
X#ifdef NO_STR_INC
Xextern int strlen();
Xextern char *strrchr();
X#endif
X
X
X/*
X** functions
X*/
X
X/***************************************************************************
X*   FUNCTION:  setcols                                                     *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Sets the value of the screencols variable (unless less than 80,    *
X*       which is adjusted to 80).                                          *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XVOID
X#ifdef __STDC__
Xsetcols(int cols)
X#else
Xsetcols(cols)
Xint cols;
X#endif
X{
X    screencols = ((cols < 80) ? 80 : cols);
X
X    return;
X} /* end of setcols() */
X
X
X/***************************************************************************
X*   FUNCTION:  getcols                                                     *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Retrieves the number of columns on the screen and stores it in     *
X*       the screencols variable.                                           *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XVOID
Xgetcols()
X{
X#ifdef HAS_TERMINFO
X    FILE *pipe;
X#endif
X#ifndef HAS_TERMCAP
X    char scratch[80];
X#else
X    char scratch[1024];
X#endif
X
X    if (screencols != 0)
X    {
X        /* Has already been set, do nothing. */
X
X        return;
X    }
X
X#ifdef HAS_TERMINFO
X    /* Run the terminfo tput program and read its output. */
X
X    sprintf(scratch, "%s cols", TERMINFO_PATH);
X    if ((pipe = popen(scratch, "r")) != ((FILE *) NULL))
X    {
X        int c;
X
X        while (isdigit(c = fgetc(pipe)))
X        {
X            screencols *= 10;
X            screencols += (c - '0');
X        }
X    }
X#endif
X
X#ifdef HAS_TERMCAP
X    /* Only do termcap if not already set by terminfo. */
X
X    if (0 == screencols)
X    {
X        char *termname = getenv("TERM");
X
X        if ((termname) && (tgetent(scratch, termname) == 1))
X        {
X            /* Returns -1 on error, which will be adjusted to 80 below. */
X
X            screencols = tgetnum("co");
X        }
X    }
X#endif
X
X    /* If not set by now, or less than 80, arbitrarily set to 80. */
X
X    if (screencols < 80)
X    {
X        screencols = 80;
X    }
X
X    return;
X} /* end of getcols() */
X
X
X/***************************************************************************
X*   FUNCTION:  gif_display                                                 *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Display function for GIF files.                                    *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       gifinfo  - contains header info from GIF file                      *
X*       infile   - file pointer for GIF file, to do fast terminator check  *
X*       filename - name of GIF file                                        *
X*       filesize - size of GIF file                                        *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XVOID
X#ifdef __STDC__
Xgif_display(GIF_LSD *gifinfo, FILE *infile, char *filename, long filesize)
X#else
Xgif_display(gifinfo, infile, filename, filesize)
XGIF_LSD *gifinfo;
XFILE *infile;
Xchar *filename;
Xlong filesize;
X#endif
X{
X    char c;
X    long uncsize;
X    int printed = 0;
X
X    /* Print out format identifier. */
X
X    PRINT_FMT(gifinfo->version, GIF_MAIN);
X
X    /* 
X    ** Perform a fast check for junk on the end.
X    ** GIF files should end with a semicolon (GIF_TERMINATOR).
X    */
X
X    if (fseek(infile, -1L, SEEK_END))
X    {
X        printf("\nERROR: Error seeking in file %s\n", filename);
X        return;
X    }
X    if (fread(&c, 1, 1, infile) != 1)
X    {
X        printf("\nERROR: Error reading file %s\n", filename);
X        return;
X    }
X    printf(((GIF_TERMINATOR == c) ? "-" : "E"));
X
X    /* Print global color table flag. */
X
X    printf(((gifinfo->gct_flag) ? "G" : "-"));
X
X    /* Print global color table sort flag if 89a. */
X
X    if (GIF_89A == gifinfo->version)
X    {
X        printf(((gifinfo->sort_flag) ? "S" : "-"));
X    }
X    else
X    {
X        printf(" ");
X    }
X
X    /* Print some spaces and filesize. */
X
X    printf("  %6ld", filesize);
X
X    /* Print logical screen height, width, and size of color table. */
X
X    printf(" %4u x %4u @ ", gifinfo->scr_wid, gifinfo->scr_hi);
X    if (gifinfo->gct_flag)
X    {
X        printf("%-3d", (0x1 << gifinfo->gct_size));
X    }
X    else
X    {
X        printf("---");
X    }
X    printf("   ");
X    printed++;
X
X    /*
X    ** Calculate and print approximate compression ratio,
X    ** but only if there is a global color table!
X    */
X
X    printf("C~");
X    if (gifinfo->gct_flag)
X    {
X        uncsize = ((long) gifinfo->scr_wid) * ((long) gifinfo->scr_hi);
X        uncsize *= (long) gifinfo->gct_size;
X        uncsize /= 8L;
X        printf("%-3ld", ((filesize * 100L) / uncsize));
X    }
X    else
X    {
X        printf("-- ");
X    }
X    printed += 5;
X
X    /* Print aspect ratio if 89a. */
X
X    if (GIF_89A == gifinfo->version)
X    {
X        printf(" AS");
X
X        /* If gifinfo->aspect is 0, then no aspect ratio data present. */
X
X        if (0 == gifinfo->aspect)
X        {
X            printf("none ");
X        }
X        else
X        {
X            printf("%02d/64", gifinfo->aspect);
X        }
X        printed += 8;
X    }
X
X    /* Finally, print filename. */
X
X    printname(filename, printed);
X
X    return;
X} /* end of gif_display() */
X
X
X/***************************************************************************
X*   FUNCTION:  img_display                                                 *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Display function for IMG files.                                    *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       imginfo  - contains header info from IMG file                      *
X*       filename - name of IMG file                                        *
X*       filesize - size of IMG file                                        *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XVOID
X#ifdef __STDC__
Ximg_display(IMG_HDR *imginfo, char *filename, long filesize)
X#else
Ximg_display(imginfo, filename, filesize)
XIMG_HDR *imginfo;
Xchar *filename;
Xlong filesize;
X#endif
X{
X    long uncsize;
X    int printed = 0;
X
X    /* Print out format identifier. */
X
X    PRINT_FMT(imginfo->version, IMG_MAIN);
X
X    /* Print 'L' if long header, '-' if normal length. */
X
X    printf("%c", (((imginfo->headerlen * 2) > IMG_HDR_LEN) ? 'L' : '-'));
X
X    /* Print some spaces and filesize. */
X
X    printf("    %6ld", filesize);
X
X    /* Print image height, width, and maximum number of colors. */
X
X    printf(" %4u x %4u @ ", imginfo->imwid, imginfo->imhi);
X    printf("%-3u   ", (0x1 << imginfo->planes));
X    printed++;
X
X    /* Calculate and print approximate compression ratio. */
X
X    printf("C~");
X    uncsize = ((long) imginfo->imwid) * ((long) imginfo->imhi);
X    uncsize *= (long) imginfo->planes;
X    uncsize /= 8L;
X    printf("%-3ld", (((filesize - (imginfo->headerlen * 2)) * 100L) /
X                     uncsize));
X    printed += 5;
X
X    /* Print aspect ratio. */
X
X    printf(" AS%3u/%-3u", imginfo->pixwid, imginfo->pixhi);
X    printed += 10;
X
X    /* Print pattern length. */
X
X    printf(" P%1u", imginfo->patternlen);
X    printed += 3;
X
X    /* Finally, print filename. */
X
X    printname(filename, printed);
X
X    return;
X} /* end of img_display() */
X
X
X/***************************************************************************
X*   FUNCTION:  jfif_display                                                *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Display function for JFIF files.                                   *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       jfifinfo  - contains header info from JFIF file                    *
X*       filename - name of IMG file                                        *
X*       filesize - size of IMG file                                        *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XVOID
X#ifdef __STDC__
Xjfif_display(JFIF_HDR *jfifinfo, char *filename, long filesize)
X#else
Xjfif_display(jfifinfo, filename, filesize)
XJFIF_HDR *jfifinfo;
Xchar *filename;
Xlong filesize;
X#endif
X{
X    long uncsize;
X    int printed = 0;
X
X    /* Print out format identifier. */
X
X    PRINT_FMT(jfifinfo->version, JFIF_MAIN);
X
X    /* Print 'T' if thumbnail present, '-' if not. */
X
X    if ((jfifinfo->xthumb != 0) && (jfifinfo->ythumb != 0))
X    {
X        printf("T");
X    }
X    else
X    {
X        printf("-");
X    }
X
X    /* Print some spaces and filesize. */
X
X    printf("    %6ld", filesize);
X
X    /* Print image height, width, components, and bits per sample. */
X
X    printf(" %4u x %4u", jfifinfo->width, jfifinfo->height);
X    printf(", %1d @%2d  ", jfifinfo->components, jfifinfo->bits);
X    printed++;
X
X    /* Calculate and print approximate compression ratio. */
X
X    printf("C~");
X    uncsize = ((long) jfifinfo->height) * ((long) jfifinfo->height);
X    uncsize *= (((long) jfifinfo->components) * ((long) jfifinfo->bits));
X    uncsize /= 8L;
X    printf("%-3ld", ((filesize * 100L) / uncsize));
X    printed += 5;
X
X    /* Print aspect ratio or density. */
X
X    if (jfifinfo->densunit != JFIF_DENS_ASPECT)
X    {
X        printf(" %3u x%3u ", jfifinfo->xdens, jfifinfo->ydens);
X        if (JFIF_DENS_DPI == jfifinfo->densunit)
X        {
X            printf("dpi ");
X        }
X        else if (JFIF_DENS_DPCM == jfifinfo->densunit)
X        {
X            printf("dpcm");
X        }
X        else
X        {
X            printf("????");
X        }
X        printed += 14;
X    }
X    else
X    {
X        printf(" AS%3u/%3u", jfifinfo->xdens, jfifinfo->ydens);
X        printed += 10;
X    }
X
X    /* Finally, print filename. */
X
X    printname(filename, printed);
X
X    return;
X} /* end of jfif_display() */
X
X
X/***************************************************************************
X*   FUNCTION:  sr_display                                                  *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Display function for SR files.                                     *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       srinfo   - contains header info from SR file                       *
X*       filename - name of SR file                                         *
X*       filesize - size of SR file                                         *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XVOID
X#ifdef __STDC__
Xsr_display(SR_HDR *srinfo, char *filename, long filesize)
X#else
Xsr_display(srinfo, filename, filesize)
XSR_HDR *srinfo;
Xchar *filename;
Xlong filesize;
X#endif
X{
X    char type;
X    int printed = 0;
X    ULONG uncsize;
X
X    /* Print format ID. */
X
X    PRINT_FMT(SR_1, SR_MAIN);
X
X    /* Print type flag. */
X
X    switch (srinfo->rastype)
X    {
X        /* Old format. */
X        case 0:
X            type = 'O';
X            break;
X
X        /* Standard format. */
X        case 1:
X            type = 'S';
X            break;
X
X        /* Byte-encoded (compressed) format. */
X        case 2:
X            type = 'C';
X            break;
X
X        /* 24-bit format in (X)RGB order (instead of (X)BGR). */
X        case 3:
X            type = 'R';
X            break;
X
X        /* "tiff <-> standard rasterfile" */
X        case 4:
X            type = 'T';
X            break;
X
X        /* "iff (TAAC format) <-> standard rasterfile" */
X        case 5:
X            type = 'I';
X            break;
X
X        /* Experimental. */
X        case 0xFFFF:
X            type = 'E';
X            break;
X
X        /* Unknown. */
X        default:
X            type = '?';
X            break;
X    }
X    printf("%c", type);
X
X    /* Print colormap type. */
X
X    switch (srinfo->maptype)
X    {
X        /* No colormap. */
X        case 0:
X            type = '-';
X            break;
X
X        /* R,G,B vector map (all R's together, etc.) */
X        case 1:
X            type = 'V';
X            break;
X
X        /* Raw colormap (usually RGB triples) */
X        case 2:
X            type = 'R';
X            break;
X
X        /* Unknown. */
X        default:
X            type = '?';
X            break;
X    }
X    printf("%c   ", type);
X
X    /* Print filesize. */
X
X    printf("%6ld ", filesize);
X
X    /* Print height and width of image. */
X
X    printf("%4ld x %4ld", srinfo->imwid, srinfo->imhi);
X
X    /* Print number of colors in image, depending. */
X
X    if (srinfo->pixelbits < 20)
X    {
X        printf(" @ %-5u ", (0x1L << srinfo->pixelbits));
X    }
X    else
X    {
X        printf(", %2d bit ", srinfo->pixelbits);
X    }
X    printed++;
X
X    /* If is compressed format, print compression ratio. */
X
X    if (2 == srinfo->rastype)
X    {
X        uncsize = srinfo->imwid * srinfo->imhi * srinfo->pixelbits;
X        uncsize /= 8;
X        printf("C~%-3ld  ", ((100L * srinfo->rasterlen) / uncsize));
X        printed += 7;
X    }
X
X    /* If has colormap, print colormap length. */
X
X    if (srinfo->maptype != 0)
X    {
X        printf("ML=%-5ld  ", srinfo->maplen);
X        printed += 10;
X    }
X
X    /* Finally, print filename. */
X
X    printname(filename, printed);
X
X    return;
X} /* end of sr_display() */
X
X
X/***************************************************************************
X*   FUNCTION:  tga_display                                                 *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Display function for TGA files.                                    *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       tgainfo   - contains header info from TGA file                     *
X*       filename - name of TGA file                                        *
X*       filesize - size of TGA file                                        *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XVOID
X#ifdef __STDC__
Xtga_display(TGA_HDR *tgainfo, char *filename, long filesize)
X#else
Xtga_display(tgainfo, filename, filesize)
XTGA_HDR *tgainfo;
Xchar *filename;
Xlong filesize;
X#endif
X{
X    char flag;
X    int printed = 0;
X    ULONG uncsize;
X
X    /* Print format ID. */
X
X    PRINT_FMT(TGA_1, TGA_MAIN);
X
X    /* Print image-present flag. */
X
X    printf("%c", ((0 == tgainfo->type) ? 'N' : '-'));
X
X    /* Print compression flag. */
X
X    switch (tgainfo->type)
X    {
X        /* No image. */
X        case 0:
X            flag = '-';
X            break;
X
X        /* Uncompressed image. */
X        case 1:
X        case 2:
X        case 3:
X            flag = 'U';
X            break;
X
X        /* Runlength-encoded image. */
X        case 9:
X        case 10:
X            flag = 'R';
X            break;
X
X        /* Compressed image. */
X        case 11:
X        case 32:
X        case 33:
X            flag = 'C';
X            break;
X
X        /* Unknown format. */
X        default:
X            flag = '?';
X            break;
X    }
X    printf("%c", flag);
X
X    /* Print color type flag. */
X
X    switch (tgainfo->type)
X    {
X        /* No image. */
X        case 0:
X            flag = '-';
X            break;
X
X        /* Colormapped image. */
X        case 1:
X        case 9:
X        case 32:
X        case 33:
X            flag = 'M';
X            break;
X
X        /* Black and white image. */
X        case 3:
X        case 11:
X            flag = 'B';
X            break;
X
X        /* RGB image. */
X        case 2:
X        case 10:
X            flag = 'C';
X            break;
X
X        /* Unknown format. */
X        default:
X            flag = '?';
X            break;
X    }
X    printf("%c", flag);
X
X    /* Print interleave type flag. */
X
X    switch (tgainfo->interleave)
X    {
X        case 1:
X            flag = '2';
X            break;
X
X        case 2:
X            flag = '4';
X            break;
X
X        case 3:
X            flag = 'R';
X            break;
X
X        default:
X        case 0:
X            flag = '-';
X            break;
X    }
X    printf("%c ", flag);
X
X    /* Print filesize. */
X
X    printf("%6ld ", filesize);
X
X    /* Print height and width of image. */
X
X    printf("%4u x %4u", tgainfo->imwid, tgainfo->imhi);
X
X    /* Print number of colors in image, depending. */
X
X    switch (tgainfo->type)
X    {
X        case 1:
X        case 9:
X        case 32:
X        case 33:
X            /* Color-mapped image. */
X            printf(" @ %-5u ", tgainfo->maplen);
X            break;
X
X        case 2:
X        case 3:
X        case 10:
X        case 11:
X            /* True-color image. */
X            if (tgainfo->pixelbits < 20)
X            {
X                printf(" @ %-5ld ", (0x1L << tgainfo->pixelbits));
X            }
X            else
X            {
X                printf(", %2u bit ", tgainfo->pixelbits);
X            }
X            break;
X
X        default:
X        case 0:
X            printf(" @ ---   ");
X            break;
X    }
X    printed++;
X
X    /* If is compressed format, print compression ratio. */
X
X    switch (tgainfo->type)
X    {
X        case 9:
X        case 10:
X        case 11:
X        case 32:
X        case 33:
X            uncsize = tgainfo->imwid * tgainfo->imhi * tgainfo->pixelbits;
X            uncsize /= 8;
X            printf(" C~%-3ld  ", ((100L * (filesize - TGA_HDR_LEN -
X                                           tgainfo->idfieldlen - 
X                                           ((tgainfo->maplen * 
X                                             tgainfo->mapentsize) / 8))) / 
X                                  uncsize));
X            printed += 8;
X            break;
X
X        default:
X            break;
X    }
X
X    /* Print format type. */
X
X    printf("T%-2d ", tgainfo->type);
X    printed += 4;
X
X    /* Print attribute bits. */
X
X    printf("A%1d ", tgainfo->attrbits);
X    printed += 3;
X
X    /* If unnecessary colormap included, print M */
X
X    switch (tgainfo->type)
X    {
X        case 2:
X        case 3:
X        case 10:
X        case 11:
X            if (tgainfo->maptype != 0)
X            {
X                printf("M ");
X                printed += 2;
X            }
X            break;
X
X        default:
X            break;
X    }
X
X    /* If file has an ID field (nonzero length), print I */
X
X    if (tgainfo->idfieldlen != 0)
X    {
X        printf("I ");
X        printed += 2;
X    }
X
X    /* Finally, print filename. */
X
X    printname(filename, printed);
X
X    return;
X} /* end of tga_display() */
X
X
X/***************************************************************************
X*   FUNCTION:  pnm_display                                                 *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Display function for PBM, PGM, and PPM files.                      *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       pnminfo   - contains header info from P?M file                     *
X*       filename - name of file                                            *
X*       filesize - size of file                                            *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XVOID
X#ifdef __STDC__
Xpnm_display(PNM_HDR *pnminfo, char *filename, long filesize)
X#else
Xpnm_display(pnminfo, filename, filesize)
XPNM_HDR *pnminfo;
Xchar *filename;
Xlong filesize;
X#endif
X{
X    char flag;
X    int printed = 0;
X    ULONG colors;
X    int loop;
X
X    /* Print format ID. */
X
X    switch FORMAT_TYPE(pnminfo->version)
X    {
X        case FORMAT_TYPE(FORMAT_PBM):
X            PRINT_FMT(pnminfo->version, PBM_MAIN);
X            break;
X
X        case FORMAT_TYPE(FORMAT_PGM):
X            PRINT_FMT(pnminfo->version, PGM_MAIN);
X            break;
X
X        case FORMAT_TYPE(FORMAT_PPM):
X            PRINT_FMT(pnminfo->version, PPM_MAIN);
X            break;
X
X        default:
X            printf("PNM      ");
X            break;
X    }
X
X    /* Print raw/normal flag. */
X
X    switch FORMAT_TYPE(pnminfo->version)
X    {
X        case FORMAT_TYPE(FORMAT_PBM):
X            flag = ((PBM_NORM == pnminfo->version) ? 'N' : 'R');
X            break;
X
X        case FORMAT_TYPE(FORMAT_PGM):
X            flag = ((PGM_NORM == pnminfo->version) ? 'N' : 'R');
X            break;
X
X        case FORMAT_TYPE(FORMAT_PPM):
X            flag = ((PPM_NORM == pnminfo->version) ? 'N' : 'R');
X            break;
X
X        default:
X            flag = '-';
X            break;
X    }
X    printf ("%c    ", flag);
X
X    /* Print filesize. */
X
X    printf("%6ld ", filesize);
X
X    /* Print height and width of image. */
X
X    printf("%4ld x %4ld", pnminfo->imwid, pnminfo->imhi);
X
X    /* Print number of colors in image, depending. */
X
X    switch FORMAT_TYPE(pnminfo->version)
X    {
X        case FORMAT_TYPE(FORMAT_PBM):
X            printf(" @ 2     ");
X            break;
X
X        case FORMAT_TYPE(FORMAT_PGM):
X            printf(" @ %-3d   ", pnminfo->maxpix + 1);
X            break;
X
X        case FORMAT_TYPE(FORMAT_PPM):
X            colors = (pnminfo->maxpix + 1);
X            colors = colors * colors * colors;
X            if (colors <= 99999)
X            {
X                printf(" @ %-5ld ", colors);
X            }
X            else
X            {
X                for (loop = 0; (colors & 0x1L) == 0; loop++, colors >>= 1) ;
X                if ((colors >> 1) == 0)
X                {
X                    printf(", %2d bit ", loop);
X                }
X                else
X                {
X                    printf(" @ %ld ", (colors << loop));
X                    printed += 3;          /* a guess */
X                }
X            }
X            break;
X
X        default:
X            printf(" @ ---   ");
X            break;
X    }
X    printed++;
X
X    /* If PGM or PBM, print bits. */
X
X    if ((FORMAT_TYPE(pnminfo->version) == FORMAT_TYPE(FORMAT_PGM)) ||
X        (FORMAT_TYPE(pnminfo->version) == FORMAT_TYPE(FORMAT_PPM)))
X    {
X        printf("MaxVal = %3d ", pnminfo->maxpix);
X        printed += 13;
X    }
X
X    /* Finally, print filename. */
X
X    printname(filename, printed);
X
X    return;
X} /* end of pnm_display() */
X
X
X/***************************************************************************
X*   FUNCTION:  xbm_display                                                 *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Display function for XBM files.                                    *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       xbminfo   - contains header info from XBM file                     *
X*       filename - name of file                                            *
X*       filesize - size of file                                            *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XVOID
X#ifdef __STDC__
Xxbm_display(XBM_HDR *xbminfo, char *filename, long filesize)
X#else
Xxbm_display(xbminfo, filename, filesize)
XXBM_HDR *xbminfo;
Xchar *filename;
Xlong filesize;
X#endif
X{
X    int printed = 0;
X
X    /* Print format ID. */
X
X    PRINT_FMT(XBM_1, XBM_MAIN);
X
X    /* No flags. */
X
X    printf("     ");
X
X    /* Print filesize. */
X
X    printf("%6ld ", filesize);
X
X    /* Print height and width and number of colors of image. */
X
X    printf("%4ld x %4ld @ 2     ", xbminfo->imwid, xbminfo->imhi);
X    printed++;
X
X    /* Print embedded name. */
X
X    printf("'%s' ", xbminfo->imname);
X    printed += (strlen(xbminfo->imname) + 3);
X    free(xbminfo->imname);
X
X    /* Finally, print filename. */
X
X    printname(filename, printed);
X
X    return;
X} /* end of xbm_display() */
X
X
X/***************************************************************************
X*   FUNCTION:  bmp_display                                                 *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Display function for BMP files.                                    *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       bmpinfo   - contains header info from BMP file                     *
X*       filename - name of file                                            *
X*       filesize - size of file                                            *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XVOID
X#ifdef __STDC__
Xbmp_display(BMP_HDR *bmpinfo, char *filename, long filesize)
X#else
Xbmp_display(bmpinfo, filename, filesize)
XBMP_HDR *bmpinfo;
Xchar *filename;
Xlong filesize;
X#endif
X{
X    char flag;
X    int printed = 0;
X    ULONG colors;
X    int loop;
X    BMP_H2 *hdr2 = (BMP_H2 *) bmpinfo->more;
X    BMP_H11 *hdr11 = (BMP_H11 *) bmpinfo->more;
X    BMP_H3 *hdr3 = (BMP_H3 *) bmpinfo->more;
X    BMP_H20 *hdr20 = (BMP_H20 *) bmpinfo->more;
X
X    /* Print format ID. */
X
X    PRINT_FMT(bmpinfo->version, BMP_MAIN);
X
X    /* Print flags by type. */
X
X    switch (FORMAT_VERS(bmpinfo->version))
X    {
X        case FORMAT_VERS(BMP_WIN2):
X            printf("%c    ", ((hdr2 != NULL) ? 
X                              ((hdr2->discardable != 0) ? 'D' : '-') : '-'));
X            break;
X
X        case FORMAT_VERS(BMP_OS2_11):
X            printf("%c    ", 
X                   ((hdr11 != NULL) ? 
X                    ((hdr11->filesize != filesize) ? 'E' : '-') : '-'));
X            break;
X
X        case FORMAT_VERS(BMP_WIN3):
X            if (hdr3 != NULL)
X            {
X                printf("%c", ((hdr3->more.filesize != filesize) ? 'E' : '-'));
X                switch (hdr3->compression)
X                {
X                    case 1:
X                        flag = '8';
X                        break;
X
X                    case 2:
X                        flag = '4';
X                        break;
X                       
X                    default:
X                    case 0:
X                        flag = '-';
X                        break;
X                }
X                printf("%c", flag);
X            }
X            else
X            {
X                printf("--");
X            }
X            printf("   ");
X            break;
X
X        case FORMAT_VERS(BMP_OS2_20):
X            if (hdr20 != NULL)
X            {
X                printf("%c",
X                       ((hdr20->more.more.filesize != filesize) ? 'E' : '-'));
X                printf("%c", ((hdr20->more.compression != 0) ? 'C' : '-'));
X                printf("%c", ((hdr20->clrencode != 0) ? '?' : 'R'));
X                printf("%c ", ((hdr20->halfalg != 0) ? 'H' : '-'));
X            }
X            else
X            {
X                printf("---- ");
X            }
X            break;
X
X        default:
X            break;
X    }
X
X    /* Print filesize. */
X
X    printf("%6ld ", filesize);
X
X    /* Print height and width of image. */
X
X    printf("%4ld x %4ld", bmpinfo->imwid, bmpinfo->imhi);
X
X    /* Print colors. */
X
X    colors = 0x1L << (bmpinfo->planes * bmpinfo->pixbits);
X    if (((BMP_WIN3 == bmpinfo->version) || (BMP_OS2_20 == bmpinfo->version)) &&
X        ((bmpinfo->planes * bmpinfo->pixbits) != 24) &&
X        (bmpinfo->more != NULL))
X    {
X        ULONG temp;
X
X        temp = ((BMP_WIN3 == bmpinfo->version) ? hdr3->clrused :
X                                                 hdr20->more.clrused);
X        if (temp != 0)
X        {
X            colors = temp;
X        }
X    }
X    if (colors <= 99999)
X    {
X        printf(" @ %-5ld ", colors);
X    }
X    else
X    {
X        ULONG temp = colors;
X
X        for (loop = 0; (temp & 0x1L) == 0; loop++, temp >>= 1) ;
X        if ((temp >> 1) == 0)
X        {
X            printf(", %2d bit ", loop);
X        }
X        else
X        {
X            printf(" @ %ld ", temp);
X            printed += 3;          /* a guess */
X        }
X    }
X    printed++;
X
X    /* Print assorted stuff by type. */
X
X    if ((BMP_WIN3 == bmpinfo->version) && (hdr3 != NULL))
X    {
X        if ((hdr3->compression != 0) && (hdr3->compsize != 0))
X        {
X            /* Print compression ratio. */
X
X            printf("C~%-3ld ", ((100L * hdr3->compsize) /
X                                ((bmpinfo->imwid * bmpinfo->imhi *
X                                  bmpinfo->planes * bmpinfo->pixbits) / 8L)));
X            printed += 6;
X        }
X        if ((hdr3->xres != 0) || (hdr3->yres != 0))
X        {
X            printf("X%3ld,Y%3ld ", hdr3->xres, hdr3->yres);
X            printed += 10;
X        }
X        if ((hdr3->clrimp != 0) && (hdr3->clrimp != colors))
X        {
X            printf("I-%3ld ", hdr3->clrimp);
X            printed += 5;
X        }
X    }
X    else if ((BMP_OS2_20 == bmpinfo->version) && (hdr20 != NULL))
X    {
X        if ((hdr20->more.compression != 0) &&
X            (hdr20->more.compsize != 0))
X        {
X            /* Print compression ratio. */
X
X            printf("C~%-3ld ", ((100L * hdr20->more.compsize) /
X                                ((bmpinfo->imwid * bmpinfo->imhi *
X                                  bmpinfo->planes * bmpinfo->pixbits) / 8L)));
X            printed += 6;
X            printed += 6;
X        }
X        if ((hdr20->more.xres != 0) || (hdr20->more.yres != 0))
X        {
X            printf("X%3ld,Y%3ld dp%c ", hdr20->more.xres, hdr20->more.yres,
X                   ((0 == hdr20->resunits) ? 'm' : '?'));
X            printed += 14;
X        }
X        if ((hdr20->more.clrimp != 0) && (hdr20->more.clrimp != colors))
X        {
X            printf("I%-3ld ", hdr20->more.clrimp);
X            printed += 5;
X        }
X    }
X
X    /* Finally, print filename. */
X
X    printname(filename, printed);
X
X    if (bmpinfo->more != NULL)
X    {
X        free(bmpinfo->more);
X    }
X
X    return;
X} /* end of bmp_display() */
X
X
X/***************************************************************************
X*   FUNCTION:  pcx_display                                                  *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Display function for PCX files.                                     *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       pcxinfo   - contains header info from PCX file                       *
X*       filename - name of PCX file                                         *
X*       filesize - size of PCX file                                         *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XVOID
X#ifdef __STDC__
Xpcx_display(PCX_HDR *pcxinfo, char *filename, long filesize)
X#else
Xpcx_display(pcxinfo, filename, filesize)
XPCX_HDR *pcxinfo;
Xchar *filename;
Xlong filesize;
X#endif
X{
X    int printed = 0;
X    ULONG uncsize;
X    char flag;
X
X    /* Print format ID. */
X
X    PRINT_FMT(pcxinfo->version, PCX_MAIN);
X
X    /* Print encoding and palette-format flags. */
X
X    printf("%c", ((1 == pcxinfo->encoding) ? 'R' : '?'));
X    switch (pcxinfo->palfmt)
X    {
X        case 2:
X            flag = 'G';
X            break;
X
X        case 1:
X            flag = 'C';
X            break;
X
X        default:
X            flag = '?';
X            break;
X    }
X    printf("%c   ", flag);
X
X    /* Print filesize. */
X
X    printf("%6ld ", filesize);
X
X    /* Print height and width of image. */
X
X    printf("%4u x %4u", pcxinfo->imwid, pcxinfo->imhi);
X
X    /* Print number of colors in image, depending. */
X
X    if ((pcxinfo->pixbits * pcxinfo->planes) < 20)
X    {
X        printf(" @ %-5u ", (0x1L << (pcxinfo->pixbits * pcxinfo->planes)));
X    }
X    else
X    {
X        printf(", %2d bit ", (pcxinfo->pixbits * pcxinfo->planes));
X    }
X    printed++;
X
X    /* If is compressed format, print compression ratio. */
X
X    if (1 == pcxinfo->encoding)
X    {
X        uncsize = pcxinfo->imwid * pcxinfo->imhi * pcxinfo->pixbits *
X                  pcxinfo->planes;
X        uncsize /= 8;
X        printf("C~%-3ld  ", ((100L * (filesize - PCX_HDR_MAXLEN)) / uncsize));
X        printed += 7;
X    }
X
X    /* Print horizontal and vertical resolution of creator. */
X
X    printf("CX%3u,CY%3u ", pcxinfo->hres, pcxinfo->vres);
X    printed += 12;
X
X    /* Finally, print filename. */
X
X    printname(filename, printed);
X
X    return;
X} /* end of pcx_display() */
X
X
X/***************************************************************************
X*   FUNCTION:  printname  STATIC                                           *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Prints the name of the file on the end of the information line     *
X*       or on the next line, depending on how many characters have been    *
X*       printed already, the length of the filename, and the setting of    *
X*       the fullname flag.                                                 *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       origname - Full name of the file, including path if any.           *
X*       printed  - Number of characters beyond 40 already printed.         *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xstatic VOID
X#ifdef __STDC__
Xprintname(char *origname, int printed)
X#else
Xprintname(origname, printed)
Xchar *origname;
Xint printed;
X#endif
X{
X    char *finalname = origname;
X    char *temp;
X
X    if ((flags & NAMETRUNC) && ((temp = strrchr(origname, '/')) != NULL))
X    {
X        finalname = temp + 1;
X    }
X
X    if (strlen(finalname) < (screencols - 41 - printed))
X    {
X        printf("%*s\n", (screencols - 41 - printed), finalname);
X    }
X    else
X    {
X        printf("\n     %*s\n", (screencols - 6), finalname);
X    }
X            
X    return;
X} /* end of static printname() */
X
END_OF_FILE
  if test 46063 -ne `wc -c <'src/chidisp.c'`; then
    echo shar: \"'src/chidisp.c'\" unpacked with wrong size!
  fi
  # end of 'src/chidisp.c'
fi
if test ! -d 'templates' ; then
    echo shar: Creating directory \"'templates'\"
    mkdir 'templates'
fi
echo shar: End of archive 1 \(of 18\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
