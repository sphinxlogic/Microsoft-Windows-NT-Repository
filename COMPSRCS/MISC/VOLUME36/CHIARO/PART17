Newsgroups: comp.sources.misc
From: jwbirdsa@picarefy.picarefy.com (James W. Birdsall)
Subject: v36i087:  chiaro - Image Utilities, Part17/18
Message-ID: <1993Mar26.203007.15255@sparky.imd.sterling.com>
X-Md4-Signature: 9037349b18c8b6f2a1a40b347314b8e3
Date: Fri, 26 Mar 1993 20:30:07 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jwbirdsa@picarefy.picarefy.com (James W. Birdsall)
Posting-number: Volume 36, Issue 87
Archive-name: chiaro/part17
Environment: UNIX, Sun, DECstation, 3B1

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  src/bmp.h src/depend.h src/fb.h src/formats.h src/gif.h
#   src/gld.h src/pcx.h src/re.h src/status.h src/stdinarg.c src/tga.h
# Wrapped by kent@sparky on Thu Mar 25 11:20:08 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 17 (of 18)."'
if test -f 'src/bmp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/bmp.h'\"
else
  echo shar: Extracting \"'src/bmp.h'\" \(6408 characters\)
  sed "s/^X//" >'src/bmp.h' <<'END_OF_FILE'
X/***************************************************************************
X*   BMP.H                                                                  *
X*   HEADER FOR BMP                                                         *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   $Id: bmp.h,v 1.1 1993/02/15 01:54:57 jwbirdsa Exp $
X*                                                                          *
X*   This file specifies the external interface to the BMP module.          *
X*                                                                          *
X***************************************************************************/
X
X#ifndef DEPEND_H
X    **** ERROR ****    MUST INCLUDE DEPEND.H BEFORE BMP.H
X#endif
X
X#ifndef BMP_H
X
X#define BMP_H
X
X/*
X** system includes <>
X*/
X
X/*
X** custom includes ""
X*/
X
X#include "status.h"
X
X
X/*
X** local #defines
X*/
X
X/* Version defines. */
X
X#define BMP_NOT                    FORMAT_NOT
X#define BMP_WIN2                   (FORMAT_BMP | MKLONG(1))
X#define BMP_OS2_11                 (FORMAT_BMP | MKLONG(2))
X#define BMP_WIN3                   (FORMAT_BMP | MKLONG(3))
X#define BMP_OS2_20                 (FORMAT_BMP | MKLONG(4))
X
X/* Offsets in BMP_WIN2 header. */
X
X#define BMP_HDR2_MAGIC_OFF         0
X#define BMP_HDR2_DISC_OFF          1
X#define BMP_HDR2_ZERO1_OFF         2
X#define BMP_HDR2_IMWID_OFF         4
X#define BMP_HDR2_IMHI_OFF          6
X#define BMP_HDR2_BYTWID_OFF        8
X#define BMP_HDR2_PLANES_OFF        10
X#define BMP_HDR2_BITS_OFF          11
X#define BMP_HDR2_ZERO2_OFF         12
X#define BMP_HDR2_ZERO3_OFF         14
X
X#define BMP_HDR2_LEN               16
X
X/* Offsets in header for all non-Win2 types. */
X
X#define BMP_HDR_MAGIC_OFF          0
X#define BMP_HDR_FSIZE_OFF          2
X#define BMP_HDR_ZERO1_OFF          6
X#define BMP_HDR_ZERO2_OFF          8
X#define BMP_HDR_HLEN_OFF           10
X#define BMP_HDR_INFOLEN_OFF        14
X
X#define BMP_HDR_LEN                18
X
X/* Offsets in header for BMP_OS2_11. */
X
X#define BMP_HDR11_IMWID_OFF        BMP_HDR_LEN
X#define BMP_HDR11_IMHI_OFF         (BMP_HDR_LEN + 2)
X#define BMP_HDR11_PLANES_OFF       (BMP_HDR_LEN + 4)
X#define BMP_HDR11_BITS_OFF         (BMP_HDR_LEN + 8)
X
X#define BMP_HDR11_LEN              (BMP_HDR_LEN + 8)
X#define BMP_HDR11_INFOLEN_VAL      12
X
X/* Offsets in header for BMP_WIN3. */
X
X#define BMP_HDR3_IMWID_OFF         BMP_HDR_LEN
X#define BMP_HDR3_IMHI_OFF          (BMP_HDR_LEN + 4)
X#define BMP_HDR3_PLANES_OFF        (BMP_HDR_LEN + 8)
X#define BMP_HDR3_BITS_OFF          (BMP_HDR_LEN + 10)
X#define BMP_HDR3_COMPR_OFF         (BMP_HDR_LEN + 12)
X#define BMP_HDR3_CSIZE_OFF         (BMP_HDR_LEN + 16)
X#define BMP_HDR3_XRES_OFF          (BMP_HDR_LEN + 20)
X#define BMP_HDR3_YRES_OFF          (BMP_HDR_LEN + 24)
X#define BMP_HDR3_CLRUSED_OFF       (BMP_HDR_LEN + 28)
X#define BMP_HDR3_CLRIMP_OFF        (BMP_HDR_LEN + 32)
X
X#define BMP_HDR3_LEN               (BMP_HDR_LEN + 36)
X#define BMP_HDR3_INFOLEN_VAL       40
X
X/* Offsets in header for BMP_OS2_20. Same as BMP_WIN3 otherwise. */
X
X#define BMP_HDR20_RESUNITS_OFF     BMP_HDR3_LEN
X#define BMP_HDR20_ZERO3_OFF        (BMP_HDR3_LEN + 2)
X#define BMP_HDR20_ORIENT_OFF       (BMP_HDR3_LEN + 4)
X#define BMP_HDR20_HALFALG_OFF      (BMP_HDR3_LEN + 6)
X#define BMP_HDR20_HALF1_OFF        (BMP_HDR3_LEN + 8)
X#define BMP_HDR20_HALF2_OFF        (BMP_HDR3_LEN + 12)
X#define BMP_HDR20_CLRENC_OFF       (BMP_HDR3_LEN + 16)
X#define BMP_HDR20_APPDATA_OFF      (BMP_HDR3_LEN + 20)
X
X#define BMP_HDR20_LEN              (BMP_HDR3_LEN + 24)
X#define BMP_HDR20_INFOLEN_VAL      64
X
X/* Error/status defines. */
X
X#define BMP_NOTBMP_E       MKERR(1, BMP_MODULE, ST_ERROR)
X#define BMP_FILEERR_E      MKERR(2, BMP_MODULE, ST_ERROR)
X#define BMP_UNEOF_E        MKERR(3, BMP_MODULE, ST_ERROR)
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST RCSbmp[] = "$Id: bmp.h,v 1.1 1993/02/15 01:54:57 jwbirdsa Exp $";
X
X
X/*
X** typedefs
X*/
X
Xtypedef struct {
X    ULONG version;                  /* the BMP format version */
X    ULONG imwid;                    /* image width, pixels */
X    ULONG imhi;                     /* image height, pixels */
X    unsigned int planes;            /* color planes */
X    unsigned int pixbits;           /* bits per pixel */
X    ULONG dataoffset;               /* offset of image data in file */
X    VOID *more;                     /* pointer to additional data */
X} BMP_HDR;
X
Xtypedef struct {
X    int discardable;                /* nonzero if discardable bitmap */
X} BMP_H2;                     /* additional data for BMP_WIN2 */
X
Xtypedef struct {
X    ULONG filesize;                 /* size of BMP file */
X} BMP_H11;                    /* additional data for BMP_OS2_11 */
X
Xtypedef struct {
X    BMP_H11 more;                 /* data common with BMP_OS2_11 */
X    ULONG compression;              /* data compression type */
X    ULONG compsize;                 /* size of compressed data */
X    ULONG xres;                     /* horizontal resolution */
X    ULONG yres;                     /* vertical resolution */
X    ULONG clrused;                  /* number of colors actually used */
X    ULONG clrimp;                   /* number of colors that are important */
X} BMP_H3;                     /* additional data for BMP_WIN3 */
X
Xtypedef struct {
X    BMP_H3 more;                  /* data common with BMP_WIN3 */
X    unsigned int resunits;          /* units of resolution */
X    unsigned int origin;            /* origin of pixels */
X    unsigned int halfalg;           /* halftoning algorithm */
X    ULONG half1;                    /* data used with halfalg */
X    ULONG half2;                    /* data used with halfalg */
X    ULONG clrencode;                /* format of color table */
X    ULONG appdata;                  /* application-specific data */
X} BMP_H20;                    /* additional data for BMP_OS2_20 */
X
X
X/*
X** global variables
X*/
X
X/*
X** function prototypes
X*/
X
X#ifdef  __STDC__
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
XULONG bmp_verify P_((char *filename, ULONG *version, char **exts));
X
XULONG bmp_getheader P_((FILE *infile, BMP_HDR *results));
X
Xchar *bmp_errstring P_((ULONG errcode));
X
X#undef P_
X
X#endif /* BMP_H */
X
END_OF_FILE
  if test 6408 -ne `wc -c <'src/bmp.h'`; then
    echo shar: \"'src/bmp.h'\" unpacked with wrong size!
  fi
  # end of 'src/bmp.h'
fi
if test -f 'src/depend.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/depend.h'\"
else
  echo shar: Extracting \"'src/depend.h'\" \(4198 characters\)
  sed "s/^X//" >'src/depend.h' <<'END_OF_FILE'
X/***************************************************************************
X*   depend.h                                                               *
X*   HEADER FOR hardware/OS dependent stuff.                                *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   Header for hardware and OS dependent functions.                        *
X*                                                                          *
X*   $Id: depend.h,v 1.8 1993/02/15 02:00:16 jwbirdsa Exp $
X*                                                                          *
X***************************************************************************/
X
X#ifndef CONFIG_H
X    **** ERROR **** MUST INCLUDE CONFIG.H BEFORE DEPEND.H
X#endif
X
X#ifndef DEPEND_H
X
X#define DEPEND_H
X
X/*
X** system includes <>
X*/
X
X/*
X** custom includes ""
X*/
X
X/*
X** local #defines
X*/
X
X#ifndef NO_CONST
X#define CONST           const
X#else
X#define CONST
X#endif
X
X#ifndef INT16
X#define MKLONG(x)       x
X#else
X#ifdef __STDC__
X#define MKLONG(x)       x##L
X#else
X/*
X** This gross kluge added because I don't know anything else that will work
X** for non-ANSI compilers.
X*/
X#define MKLONG(x)       x/**/L
X#endif
X#endif
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST RCSdepend[] = "$Id: depend.h,v 1.8 1993/02/15 02:00:16 jwbirdsa Exp $";
X
X
X/* A rough guess at a reasonable maximum path length. */
X
X#ifndef MAXPATH
X#define MAXPATH         255
X#endif
X
X/* If stdio.h doesn't define SEEK_SET (or override by user), default to 0. */
X
X#ifndef SEEK_SET
X#define SEEK_SET        0
X#endif
X
X/* If stdio.h doesn't define SEEK_CUR (or override by user), default to 1. */
X
X#ifndef SEEK_CUR
X#define SEEK_CUR        1
X#endif
X
X/* If stdio.h doesn't define SEEK_END (or override by user), default to 2. */
X
X#ifndef SEEK_END
X#define SEEK_END        2
X#endif
X
X/* Refault SYS_BLOCKSIZE to 512. */
X
X#ifndef SYS_BLOCKSIZE
X#define SYS_BLOCKSIZE                 512
X#endif
X
X/* Default FOPEN_READ_BINARY to "r". */
X
X#ifndef FOPEN_READ_BINARY
X#define FOPEN_READ_BINARY            "r"
X#endif
X
X/* Default FOPEN_WRITE_BINARY to "w". */
X
X#ifndef FOPEN_WRITE_BINARY
X#define FOPEN_WRITE_BINARY           "w"
X#endif
X
X/* Default MINRAM to 10K. */
X
X#ifndef MINRAM
X#define MINRAM                       10240
X#endif
X
X/* Default NULL_DEVICE to "/dev/null". */
X
X#ifndef NULL_DEVICE
X#define NULL_DEVICE                  "/dev/null"
X#endif
X
X/* Some systems have macro max(), others don't. */
X
X#ifndef max
X#define max(a,b)                     (((a) > (b)) ? (a) : (b))
X#endif
X
X
X/*
X** typedefs
X*/
X
X/* Use unsigned char if possible, otherwise plain char and hope. */
X
X#ifndef NO_UCHAR
Xtypedef unsigned char UCHAR;
X#else
Xtypedef char UCHAR;
X#endif
X
X/* Use void if possible, otherwise same as UCHAR. */
X
X#ifndef NO_VOID
Xtypedef void VOID;
X#else
Xtypedef UCHAR VOID;
X#endif
X
X/*
X** If ints are 32 bits, use unsigned int. This helps avoid warning
X** messages from ANSI compilers about unsigned long != unsigned int.
X** On 16-bit machines, have to use a long of some type to get 32 bits.
X** Use unsigned long if possible, otherwise use plain long and hope.
X*/
X
X#ifndef INT16
Xtypedef unsigned int ULONG;
X#else
X#ifndef NO_ULONG
Xtypedef unsigned long ULONG;
X#else
Xtypedef long ULONG;
X#endif
X#endif
X
X
X/*
X** global variables
X*/
X
X/*
X** function prototypes
X*/
X
X/* function prototypes courtesy of the 'mkptypes' program */
X#ifdef  __STDC__
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X 
Xchar **scand P_((char *mask));
Xlong dfree P_((char *temppath));
Xchar *tempname P_((char *dir, char *prefix));
X
Xint coreleft P_((long needed));
X
Xint stricmp P_((char *s1, char *s2));
Xint strnicmp P_((char *s1, char *s2, int len));
X 
X#ifdef NO_MEMOP
XVOID *memcpy P_((VOID *dest, VOID *src, unsigned int n));
Xint memcmp P_((VOID *s1, VOID *s2, unsigned int n));
X#endif
X
X#ifdef NO_STRDUP
Xchar *strdup P_((char *s1));
X#endif
X
X#ifdef NO_RENAME
Xint rename P_((char *path1, char *path2));
X#endif
X
X#undef P_
X
X#endif /* DEPEND_H */
X
END_OF_FILE
  if test 4198 -ne `wc -c <'src/depend.h'`; then
    echo shar: \"'src/depend.h'\" unpacked with wrong size!
  fi
  # end of 'src/depend.h'
fi
if test -f 'src/fb.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/fb.h'\"
else
  echo shar: Extracting \"'src/fb.h'\" \(3342 characters\)
  sed "s/^X//" >'src/fb.h' <<'END_OF_FILE'
X/***************************************************************************
X*   FB.H                                                                   *
X*   HEADER FOR FB (File Buffer) MODULE                                     *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 by James W. Birdsall, all rights reserved.          *
X*                                                                          *
X*   $Id: fb.h,v 1.6 1993/02/10 01:33:16 jwbirdsa Exp $
X*                                                                          *
X*   This file specifies the external interface to the FB (file buffer)     *
X*   module.                                                                *
X*                                                                          *
X****************************************************************************/
X
X#ifndef DEPEND_H
X    **** ERROR **** MUST INCLUDE DEPEND.H BEFORE FB.H
X#endif
X
X#ifndef FB_H
X
X#define FB_H
X
X/*
X** system includes <>
X*/
X
X/*
X** custom includes ""
X*/
X
X#include "status.h"
X
X
X/*
X** #defines
X*/
X
X/* miscellaneous defines */
X
X#define FB_MINBUFFER   512
X#define FB_MAXBUFFER   32767
X
X/* error/status defines */
X
X#define FB_EOF_W       MKERR(1, FB_MODULE, ST_WARNING)
X
X#define FB_NOMEM_E     MKERR(1, FB_MODULE, ST_ERROR)
X#define FB_BADPARAM_E  MKERR(2, FB_MODULE, ST_ERROR)
X#define FB_NOHANDLE_E  MKERR(3, FB_MODULE, ST_ERROR)
X#define FB_NOFILE_E    MKERR(4, FB_MODULE, ST_ERROR)
X#define FB_NOTINIT_E   MKERR(5, FB_MODULE, ST_ERROR)
X#define FB_REINIT_E    MKERR(6, FB_MODULE, ST_ERROR)
X#define FB_NOMEMBUF_E  MKERR(7, FB_MODULE, ST_ERROR)
X
X#define FB_FILEERR_F   MKERR(1, FB_MODULE, ST_FATAL)
X#define FB_BUG_F       MKERR(2, FB_MODULE, ST_FATAL)
X#define FB_BADFUNC_F   MKERR(3, FB_MODULE, ST_FATAL)
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST RCSfb[] = "$Id: fb.h,v 1.6 1993/02/10 01:33:16 jwbirdsa Exp $";
X
X
X/*
X** typedefs
X*/
X
X/* FB data structure */
Xtypedef struct {
X    FILE *rawfile;                    /* normal file handle */
X    UCHAR *buffer;                    /* pointer to buffer */
X    int bufvalid;                     /* bytes of valid data in buffer */
X    int bufloc;                       /* current index in buffer */
X    long bufoffset;                   /* offset in file */
X    char filemode;                    /* file mode 'r' or 'w' */
X} FB;
X
X
X/*
X** global variables
X*/
X
Xextern ULONG fb_error;                /* error/status code storage */
X
X
X/*
X** function prototypes
X*/
X
X/* function prototypes courtesy of the 'mkptypes' program */
X#ifdef  __STDC__
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
XULONG fb_init P_((int tablesize, int buffersize));
XFB *fb_open P_((char *filename, char filemode, long *length));
XFB *fb_retrofit P_((FILE *rawfile, char filemode));
XULONG fb_close P_((FB *filehandle));
XULONG fb_seek P_((FB *filehandle, long offset));
Xlong fb_tell P_((FB *filehandle));
XULONG fb_flush P_((FB *filehandle));
Xint fb_read P_((FB *filehandle, UCHAR *buffer, int count));
Xint fb_getc P_((FB *filehandle));
XULONG fb_write P_((FB *filehandle, UCHAR *buffer, int count));
XULONG fb_putc P_((FB *filehandle, UCHAR c));
Xchar *fb_errstring P_((ULONG errcode));
X
X#undef P_
X
X#endif /* FB_H */
X
END_OF_FILE
  if test 3342 -ne `wc -c <'src/fb.h'`; then
    echo shar: \"'src/fb.h'\" unpacked with wrong size!
  fi
  # end of 'src/fb.h'
fi
if test -f 'src/formats.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/formats.h'\"
else
  echo shar: Extracting \"'src/formats.h'\" \(4706 characters\)
  sed "s/^X//" >'src/formats.h' <<'END_OF_FILE'
X/***************************************************************************
X*   FORMATS.H                                                              *
X*   HEADER FOR FM (Formats) MODULE                                         *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 by James W. Birdsall, all rights reserved.          *
X*                                                                          *
X*   $Id: formats.h,v 1.3 1993/02/10 01:51:36 jwbirdsa Exp $
X*                                                                          *
X*   This file specifies various generic returns from the individual        *
X*   format modules and provides macros for comparing and determining       *
X*   types and versions of files.                                           *
X*                                                                          *
X***************************************************************************/
X
X#ifndef DEPEND_H
X    **** ERROR **** MUST INCLUDE DEPEND.H BEFORE FORMATS.H
X#endif
X
X#ifndef FORMATS_H
X
X#define FORMATS_H
X
Xstatic char CONST RCSformats[] = "$Id: formats.h,v 1.3 1993/02/10 01:51:36 jwbirdsa Exp $";
X
X/*
X** #defines
X*/
X
X/* format type and version masks */
X
X#define FORMAT_TYPE_MASK            MKLONG(0xFFFF0000)
X#define FORMAT_VERS_MASK            MKLONG(0x0000FFFF)
X
X#define FORMAT_TYPE_SHIFT           16
X#define FORMAT_VERS_SHIFT           0
X
X/* format types -- version defined in individual format headers */
X
X#define FORMAT_NOT                  MKLONG(0x00000000)
X#define FORMAT_GIF                  MKLONG(0x00010000)
X#define FORMAT_IMG                  MKLONG(0x00020000)
X#define FORMAT_JFIF                 MKLONG(0x00030000)
X#define FORMAT_SR                   MKLONG(0x00040000)
X#define FORMAT_TGA                  MKLONG(0x00050000)
X#define FORMAT_PBM                  MKLONG(0x00060000)
X#define FORMAT_PGM                  MKLONG(0x00070000)
X#define FORMAT_PPM                  MKLONG(0x00080000)
X#define FORMAT_XBM                  MKLONG(0x00090000)
X#define FORMAT_BMP                  MKLONG(0x000A0000)
X#define FORMAT_PCX                  MKLONG(0x000B0000)
X
X/* macros to extract and compare types and versions */
X
X#define FORMAT_TYPE(x)              ((int)(((x) & FORMAT_TYPE_MASK) >> \
X                                           FORMAT_TYPE_SHIFT))
X#define FORMAT_VERS(x)              ((int)(((x) & FORMAT_VERS_MASK) >> \
X                                           FORMAT_VERS_SHIFT))
X
X/* macros to extract data from headers */
X
X#define CONSTRUCT_M_UINT(b)           ((((unsigned int)(*(b)))<<8)| \
X                                       ((unsigned int)(*((b)+1))))
X
X#define CONSTRUCT_M_ULONG(b)          ((((ULONG)(*(b)))<<24)| \
X                                       (((ULONG)(*((b)+1)))<<16)| \
X                                       (((ULONG)(*((b)+2)))<<8)| \
X                                       ((ULONG)(*((b)+3))))
X
X#define CONSTRUCT_I_UINT(b)           ((((unsigned int)(*((b)+1)))<<8)| \
X                                       ((unsigned int)(*(b))))
X
X#define CONSTRUCT_I_ULONG(b)          ((((ULONG)(*((b)+3)))<<24)| \
X                                       (((ULONG)(*((b)+2)))<<16)| \
X                                       (((ULONG)(*((b)+1)))<<8)| \
X                                       ((ULONG)(*(b))))
X/* miscellaneous defines */
X
X#define GIF_MAIN    "GIF"         /* main GIF format designation */
X#define IMG_MAIN    "IMG"         /* main IMG format designation */
X#define JFIF_MAIN   "JFIF"        /* main JFIF format designation */
X#define SR_MAIN     "SUNRAS"      /* main Sun Raster format designation */
X#define TGA_MAIN    "TARGA"       /* main Targa format designation */
X#define PBM_MAIN    "PBM"         /* main PBM format designation */
X#define PGM_MAIN    "PGM"         /* main PGM format designation */
X#define PPM_MAIN    "PPM"         /* main PPM format designation */
X#define XBM_MAIN    "XBM"         /* main XBM format designation */
X#define BMP_MAIN    "BMP"         /* main BMP format designation */
X#define PCX_MAIN    "PCX"         /* main PCX format designation */
X
X
X/*
X** typedefs
X*/
X
Xtypedef struct aa {
X   ULONG mask;
X   ULONG value;
X   struct aa *next;
X} flist;
X
Xtypedef struct {
X   char name[9];
X   flist value;
X} fsearch;
X
Xtypedef struct rgb_triplet {
X    UCHAR red;
X    UCHAR green;
X    UCHAR blue;
X} RGB_TRIPLET;
X
X/*
X** global variables
X*/
X
Xextern fsearch formatsearch[];
X
X
X/*
X** function prototypes
X*/
X
X#ifdef  __STDC__
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
Xchar *fm_name P_((ULONG format));
X
X#undef P_
X
X
X#include "re.h"
X
X#endif /* FORMATS_H */
X
END_OF_FILE
  if test 4706 -ne `wc -c <'src/formats.h'`; then
    echo shar: \"'src/formats.h'\" unpacked with wrong size!
  fi
  # end of 'src/formats.h'
fi
if test -f 'src/gif.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/gif.h'\"
else
  echo shar: Extracting \"'src/gif.h'\" \(8525 characters\)
  sed "s/^X//" >'src/gif.h' <<'END_OF_FILE'
X/***************************************************************************
X*   GIF.H                                                                  *
X*   HEADER FOR GIF (GIF FORMAT PROCESSOR)                                  *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   $Id: gif.h,v 1.3 1993/02/10 01:35:18 jwbirdsa Exp $
X*                                                                          *
X*   This file specifies the external interface to the GIF module.          *
X*                                                                          *
X***************************************************************************/
X
X#ifndef FB_H
X    **** ERROR ****    MUST INCLUDE FB.H BEFORE GIF.H
X#endif
X#ifndef DEPEND_H
X    **** ERROR ****    MUST INCLUDE DEPEND.H BEFORE GIF.H
X#endif
X
X
X#ifndef GIF_H
X
X#define GIF_H
X
X/*
X** system includes <>
X*/
X
X/*
X** custom includes ""
X*/
X
X#include "status.h"
X
X
X/*
X** local #defines
X*/
X
X/* GIF format signature and length. */
X
X#define GIF_SIGNATURE           "GIF"
X#define GIF_SIGNATURE_LEN       3
X
X/* GIF format version signatures and length. */
X
X#define GIF_VERS87A_SIG         "87a"
X#define GIF_VERS89A_SIG         "89a"
X#define GIF_VERS_SIG_LEN        3
X
X/* Length and structure of GIF logical screen descriptor. */
X
X#define GIF_LSD_LEN             7
X
X#define GIF_LSD_SCRWID_OFF      0
X#define GIF_LSD_SCRHI_OFF       2
X#define GIF_LSD_PACKED_OFF      4
X#define    GIF_LSD_GCTFLAG_MASK        0x80
X#define    GIF_LSD_CLRRES_MASK         0x70
X#define    GIF_LSD_CLRRES_SHIFT        4
X#define    GIF_LSD_SORTFLAG_MASK       0x08
X#define    GIF_LSD_GCTSIZE_MASK        0x07
X#define GIF_LSD_BACKGROUND_OFF  5
X#define GIF_LSD_ASPECT_OFF      6
X
X/* Length and structure of GIF image descriptor. */
X
X#define GIF_IMD_LEN             9
X
X#define GIF_IMD_IMLEFT_OFF      0
X#define GIF_IMD_IMTOP_OFF       2
X#define GIF_IMD_IMWID_OFF       4
X#define GIF_IMD_IMHI_OFF        6
X#define GIF_IMD_PACKED_OFF      8
X#define    GIF_IMD_LCTFLAG_MASK        0x80
X#define    GIF_IMD_INTRLACEFLAG_MASK   0x40
X#define    GIF_IMD_SORTFLAG_MASK       0x20
X#define    GIF_IMD_LCTSIZE_MASK        0x07
X
X/* Length and structure of GIF graphic control extension. */
X
X#define GIF_GCE_LEN             4
X
X#define GIF_GCE_PACKED_OFF      0
X#define    GIF_GCE_DISPOSAL_MASK       0x1C
X#define    GIF_GCE_DISPOSAL_SHIFT      2
X#define    GIF_GCE_USERINFLAG_MASK     0x02
X#define    GIF_GCE_TRANSFLAG_MASK      0x01
X#define GIF_GCE_DELAY_OFF       1
X#define GIF_GCE_TRANSPARENT_OFF 3
X
X/* Length and structure of GIF plain text extension header. */
X
X#define GIF_PTEHEAD_LEN         12
X
X#define GIF_PTEHEAD_LEFT_OFF    0
X#define GIF_PTEHEAD_TOP_OFF     2
X#define GIF_PTEHEAD_WID_OFF     4
X#define GIF_PTEHEAD_HI_OFF      6
X#define GIF_PTEHEAD_CELLWID_OFF 8
X#define GIF_PTEHEAD_CELLHI_OFF  9
X#define GIF_PTEHEAD_FORECLR_OFF 10
X#define GIF_PTEHEAD_BACKCLR_OFF 11
X
X/* Length and structure of GIF application extension header. */
X
X#define GIF_APPL_LEN            (GIF_APPL_APPLID_LEN + GIF_APPL_AUTH_LEN)
X
X#define GIF_APPL_APPLID_OFF     0
X#define GIF_APPL_AUTH_OFF       GIF_APPL_APPLID_LEN
X
X/* GIF special characters. */
X
X#define GIF_EXTBLOCK            '!'    /* 0x21 */
X#define GIF_IMAGE               ','    /* 0x2C */
X#define GIF_TERMINATOR          ';'    /* 0x3B */
X
X/* GIF89a special extension block numbers. */
X
X#define GIF_EXT_PLAIN_TEXT      0x01
X#define GIF_EXT_GRAPHIC_CONTROL 0xF9
X#define GIF_EXT_COMMENT         0xFE
X#define GIF_EXT_APPLICATION     0xFF
X#define    GIF_APPL_APPLID_LEN        8
X#define    GIF_APPL_AUTH_LEN          3
X
X/* Format version returns. */
X
X#define GIF_NOT                 FORMAT_NOT
X#define GIF_87A                 (FORMAT_GIF | MKLONG(1))
X#define GIF_89A                 (FORMAT_GIF | MKLONG(2))
X
X/* Error/status defines. */
X
X#define GIF_NOFILE_E            MKERR(1, GIF_MODULE, ST_ERROR)
X#define GIF_FILEERR_E           MKERR(2, GIF_MODULE, ST_ERROR)
X#define GIF_NOTGIF_E            MKERR(3, GIF_MODULE, ST_ERROR)
X#define GIF_UNEOF_E             MKERR(4, GIF_MODULE, ST_ERROR)
X#define GIF_NOMEM_E             MKERR(5, GIF_MODULE, ST_ERROR)
X#define GIF_BADSECTION_E        MKERR(6, GIF_MODULE, ST_ERROR)
X
X#define GIF_UNSUPRT_F           MKERR(1, GIF_MODULE, ST_FATAL)
X#define GIF_BUG_F               MKERR(2, GIF_MODULE, ST_FATAL)
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST RCSgif[] = "$Id: gif.h,v 1.3 1993/02/10 01:35:18 jwbirdsa Exp $";
X
X
X/*
X** typedefs
X*/
X
Xtypedef struct gif_lsd {
X    ULONG version;               /* the GIF format version */
X    unsigned int scr_wid;        /* logical screen width */
X    unsigned int scr_hi;         /* logical screen height */
X    UCHAR raw_packed;            /* raw contents of packed fields */
X    char gct_flag;               /* global color table flag */
X    int clr_res;                 /* bits per color on source */
X    char sort_flag;              /* global color table sorted flag */
X    int gct_size;                /* bits per pixel in image */
X    int background;              /* background color index */
X    int aspect;                  /* numerator of aspect ratio */
X} GIF_LSD;
X
Xtypedef struct gif_imd {
X    unsigned int im_left;        /* column of left side of image */
X    unsigned int im_top;         /* row of top of image */
X    unsigned int im_wid;         /* width of image */
X    unsigned int im_hi;          /* height of image */
X    unsigned int raw_packed;     /* raw contents of packed fields */
X    char lct_flag;               /* 1: local color table, 0: no lct */
X    char interlace_flag;         /* 1: interlaced, 0: sequential */
X    char sort_flag;              /* 1: lct sorted, 0: lct not sorted */
X    int lct_size;                /* bits per pixel in image, if lct */
X} GIF_IMD;
X
Xtypedef struct gif_gce {
X    unsigned int delay;          /* delay time */
X    int transparent;             /* index of transparent color */
X    UCHAR raw_packed;            /* raw contents of packed fields */
X    int disposal;                /* disposal method */
X    char userinflag;             /* 1: user input expected, 0: not expected */
X    char transflag;              /* 1: transparency enabled, 0: not */
X} GIF_GCE;
X
Xtypedef struct gif_pte {
X    unsigned int left;           /* column of left side of text grid */
X    unsigned int top;            /* row of top of text grid */
X    unsigned int wid;            /* width of grid, pixels */
X    unsigned int hi;             /* height of grid, pixels */
X    unsigned int cellwid;        /* character cell width, pixels */
X    unsigned int cellhi;         /* character cell height, pixels */
X    int forecolor;               /* text foreground color index */
X    int backcolor;               /* text background color index */
X    char *text;                  /* text buffer -- must be free()'ed */
X    unsigned int textln;         /* text length */
X} GIF_PTE;
X
Xtypedef struct gif_appl {
X    char appl_id[GIF_APPL_APPLID_LEN];     /* application identifier */
X    UCHAR appl_auth[GIF_APPL_AUTH_LEN];    /* application authentication */
X    UCHAR *appldata;                       /* application data buffer -- */
X                                           /* must be free()'ed */
X    unsigned int appldatlen;               /* length of application data */
X} GIF_APPL;
X
X
X/*
X** global variables
X*/
X
X/*
X** function prototypes
X*/
X
X#ifdef  __STDC__
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
XULONG gif_verify P_((char *filename, ULONG *version, char **exts));
X
XULONG gif_lsdget P_((FILE *infile, GIF_LSD *results));
XULONG gif_searchlsd P_((FB *infile, GIF_LSD *results, ULONG *skipped));
XULONG gif_gctget P_((FB *infile, RGB_TRIPLET **gct, int colors));
X
XULONG gif_findnext P_((FB *infile, int *datatype, ULONG *skip, int *extype));
X
XULONG gif_imdget P_((FB *infile, GIF_IMD *imd));
XULONG gif_lctget P_((FB *infile, RGB_TRIPLET **lct, int colors));
X
XULONG gif_skipsection P_((FB *infile));
X
XULONG gif_grafctrlext P_((FB *infile, GIF_GCE *gce));
XULONG gif_commentext P_((FB *infile, char **text, unsigned *textln));
XULONG gif_plaintextext P_((FB *infile, GIF_PTE *pte));
XULONG gif_applext P_((FB *infile, GIF_APPL *appl));
X
XULONG gif_readblock P_((FB *infile, UCHAR **data, int *length));
X
Xchar *gif_errstring P_((ULONG errcode));
X
X#undef P_
X
X#endif /* GIF_H */
X
END_OF_FILE
  if test 8525 -ne `wc -c <'src/gif.h'`; then
    echo shar: \"'src/gif.h'\" unpacked with wrong size!
  fi
  # end of 'src/gif.h'
fi
if test -f 'src/gld.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/gld.h'\"
else
  echo shar: Extracting \"'src/gld.h'\" \(3472 characters\)
  sed "s/^X//" >'src/gld.h' <<'END_OF_FILE'
X/***************************************************************************
X*   GLD.H                                                                  *
X*   HEADER FOR GIF/LZW decode                                              *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   $Id: gld.h,v 1.3 1993/02/10 01:36:25 jwbirdsa Exp $
X*                                                                          *
X*   Lempel-Ziv-Welch decoding for GIF files.                               *
X*                                                                          *
X***************************************************************************/
X
X#ifndef GLD_H
X
X#define GLD_H
X
X/*
X** system includes <>
X*/
X
X/*
X** custom includes ""
X*/
X
X#include "status.h"
X
X
X/*
X** local #defines
X*/
X
X#define MAXCODEBITS         12
X#define CODES               (0x1 << MAXCODEBITS)
X#define MAXCODE             (CODES - 1)
X
X/* error/status defines */
X
X#define GLD_EOI_S               MKERR(1, GLD_MODULE, ST_SUCCESS)
X#define GLD_CLEARED_S           MKERR(2, GLD_MODULE, ST_SUCCESS)
X
X#define GLD_NOMEM_E             MKERR(1, GLD_MODULE, ST_ERROR)
X#define GLD_BADHOLDSIZE_E       MKERR(2, GLD_MODULE, ST_ERROR)
X
X#define GLD_BADCODE_F           MKERR(1, GLD_MODULE, ST_FATAL)
X#define GLD_BUG_F               MKERR(2, GLD_MODULE, ST_FATAL)
X#define GLD_LENOVERFLOW_F       MKERR(3, GLD_MODULE, ST_FATAL)
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST RCSgld[] = "$Id: gld.h,v 1.3 1993/02/10 01:36:25 jwbirdsa Exp $";
X
X
X/*
X** typedefs
X*/
X
X/*
X** NOTES ABOUT CODEINFO STRUCTURE:
X**   If stringlen == 1, then firstchar == lastchar, root entry!
X**                   2, whole string is firstchar, lastchar
X**                   3, whole string is firstchar, buf[0], lastchar
X**                   4, whole string is firstchar, buf[0], buf[1], lastchar
X**                >= 5, trace back through prevind entries until hit
X**                      one that has length 4 or one with prevind > 4096,
X**                      which means entire string is stored in holding buffer
X**                <  0, special meanings
X*/
Xtypedef struct {
X    int stringlen;                /* length of decoded string */
X    UCHAR firstchar;              /* first char of decoded string */
X    union {
X        unsigned int prevind;     /* index of prefix string code */
X        char buf[2];              /* parts of string */
X    } pb;
X    UCHAR lastchar;               /* last character of decoded string */
X} codeinfo;
X
X
X/*
X** global variables
X*/
X
X/* Variables which control decoding. */
X
Xextern unsigned int gld_hopsmax;
X
X/* Statistics from decoding. */
X
Xextern unsigned int gld_holdmax;
Xextern ULONG gld_codes;
Xextern UCHAR gld_indused[];
Xextern unsigned int gld_colors;
Xextern unsigned int gld_clears;
Xextern ULONG gld_pixout;
X
X
X/*
X** function prototypes
X*/
X
X#ifdef __STDC__
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
XULONG gld_init P_((int min_codesize, int truebits, codeinfo *table, UCHAR *savebuf, unsigned int savebuflen));
XULONG gld_process P_((int length, UCHAR *codes, UCHAR *buffer, long buflen, VOID (*callback)(long, UCHAR **, long *, long *)));
X
Xchar *gld_errstring P_((ULONG errcode));
X
X#undef P_
X
X#endif /* GLD_H */
X
END_OF_FILE
  if test 3472 -ne `wc -c <'src/gld.h'`; then
    echo shar: \"'src/gld.h'\" unpacked with wrong size!
  fi
  # end of 'src/gld.h'
fi
if test -f 'src/pcx.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/pcx.h'\"
else
  echo shar: Extracting \"'src/pcx.h'\" \(3558 characters\)
  sed "s/^X//" >'src/pcx.h' <<'END_OF_FILE'
X/***************************************************************************
X*   PCX.H                                                                  *
X*   HEADER FOR PCX                                                         *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   $Id: pcx.h,v 1.0 1993/02/10 01:42:44 jwbirdsa Exp $
X*                                                                          *
X*   This file specifies the external interface to the PCX module.          *
X*                                                                          *
X***************************************************************************/
X
X#ifndef DEPEND_H
X    **** ERROR ****    MUST INCLUDE DEPEND.H BEFORE PCX.H
X#endif
X
X#ifndef PCX_H
X
X#define PCX_H
X
X/*
X** system includes <>
X*/
X
X/*
X** custom includes ""
X*/
X
X#include "status.h"
X
X
X/*
X** local #defines
X*/
X
X/* Version defines. */
X
X#define PCX_NOT            FORMAT_NOT
X#define PCX_VER25          (FORMAT_PCX | MKLONG(1))
X#define PCX_VER28          (FORMAT_PCX | MKLONG(2))
X#define PCX_VER28P         (FORMAT_PCX | MKLONG(3))
X#define PCX_VER30          (FORMAT_PCX | MKLONG(4))
X
X/* Offsets in header. */
X
X#define PCX_HDR_MAGIC_OFF  0
X#define PCX_HDR_VERS_OFF   1
X#define PCX_HDR_ENC_OFF    2
X#define PCX_HDR_BITS_OFF   3
X#define PCX_HDR_XMIN_OFF   4
X#define PCX_HDR_YMIN_OFF   6
X#define PCX_HDR_XMAX_OFF   8
X#define PCX_HDR_YMAX_OFF   10
X#define PCX_HDR_HRES_OFF   12
X#define PCX_HDR_VRES_OFF   14
X#define PCX_HDR_CMAP_OFF   16
X#define PCX_HDR_ZERO_OFF   64
X#define PCX_HDR_PLANES_OFF 65
X#define PCX_HDR_BYTLIN_OFF 66
X#define PCX_HDR_PFMT_OFF   68
X#define PCX_HDR_FILLER_OFF 70
X
X#define PCX_HDR_LEN        70
X#define PCX_HDR_MAXLEN     128
X
X/* PCX magic and version numbers. */
X
X#define PCX_MAGIC          10
X
X#define PCX_VER25_MAGIC    0
X#define PCX_VER28_MAGIC    3
X#define PCX_VER28P_MAGIC   2
X#define PCX_VER30_MAGIC    5
X
X/* Error/status defines. */
X
X#define PCX_NOTPCX_E       MKERR(1, PCX_MODULE, ST_ERROR)
X#define PCX_FILEERR_E      MKERR(2, PCX_MODULE, ST_ERROR)
X#define PCX_UNEOF_E        MKERR(3, PCX_MODULE, ST_ERROR)
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST RCSpcx[] = "$Id: pcx.h,v 1.0 1993/02/10 01:42:44 jwbirdsa Exp $";
X
X
X/*
X** typedefs
X*/
X
Xtypedef struct {
X    ULONG version;                  /* the PCX format version */
X    unsigned int planes;            /* color planes, aka bits/pixel */
X    unsigned int pixbits;           /* bits per pixel */
X    unsigned int imwid;             /* image width, pixels */
X    unsigned int imhi;              /* image height, pixels */
X    unsigned int imleft;            /* left corner of image */
X    unsigned int imtop;             /* top of image */
X    unsigned int encoding;          /* data encoding */
X    unsigned int hres;              /* horizontal resolution of creator */
X    unsigned int vres;              /* vertical resolution of creator */
X    unsigned int palfmt;            /* palette format */
X} PCX_HDR;
X
X
X/*
X** global variables
X*/
X
X/*
X** function prototypes
X*/
X
X#ifdef  __STDC__
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
XULONG pcx_verify P_((char *filename, ULONG *version, char **exts));
X
XULONG pcx_getheader P_((FILE *infile, PCX_HDR *results));
X
Xchar *pcx_errstring P_((ULONG errcode));
X
X#undef P_
X
X#endif /* PCX_H */
X
END_OF_FILE
  if test 3558 -ne `wc -c <'src/pcx.h'`; then
    echo shar: \"'src/pcx.h'\" unpacked with wrong size!
  fi
  # end of 'src/pcx.h'
fi
if test -f 'src/re.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/re.h'\"
else
  echo shar: Extracting \"'src/re.h'\" \(2225 characters\)
  sed "s/^X//" >'src/re.h' <<'END_OF_FILE'
X/***************************************************************************
X*   RE.H                                                                   *
X*   part of FORMATS module header                                          *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   $Id: re.h,v 1.1 1993/03/18 21:14:48 jwbirdsa Exp $                                                                  *
X*                                                                          *
X*   This file specifies the external interface to the format recognizer    *
X*   functions.                                                             *
X*                                                                          *
X***************************************************************************/
X
X#ifndef DEPEND_H
X    **** ERROR **** MUST INCLUDE DEPEND.H BEFORE RE.H
X#endif
X#ifndef FORMATS_H
X    **** ERROR **** MUST INCLUDE FORMATS.H BEFORE RE.H
X#endif
X
X#ifndef RE_H
X
X#define RE_H
X
X/*
X** custom includes ""
X*/
X
X#include "status.h"
X
X
X/*
X** local #defines
X*/
X
X/* error/status defines */
X
X#define FM_UNRECOGNIZED_W   MKERR(1, FM_MODULE, ST_WARNING)
X#define FM_EOF_W            MKERR(2, FM_MODULE, ST_WARNING)
X#define FM_NOCFGFILE_W      MKERR(3, FM_MODULE, ST_WARNING)
X
X#define FM_READERR_E        MKERR(1, FM_MODULE, ST_ERROR)
X#define FM_FILEERR_E        MKERR(2, FM_MODULE, ST_ERROR)
X
X#define FM_NOMEM_F          MKERR(1, FM_MODULE, ST_FATAL)
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST RCSre[] = "$Id: re.h,v 1.1 1993/03/18 21:14:48 jwbirdsa Exp $";
X
X
X/*
X** typedefs
X*/
X
X/*
X** global variables
X*/
X
X/*
X** function prototypes
X*/
X
X#ifdef  __STDC__
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
XULONG re_ident P_((char *filename, ULONG *format));
XULONG re_init P_((char *progname, char *cfg_name, char *envvar));
XVOID re_deinit();
Xchar **re_extlist P_((char *fortype));
X
Xchar *re_errstring P_((ULONG errcode));
X
X#undef P_
X
X#endif /* RE_H */
X
END_OF_FILE
  if test 2225 -ne `wc -c <'src/re.h'`; then
    echo shar: \"'src/re.h'\" unpacked with wrong size!
  fi
  # end of 'src/re.h'
fi
if test -f 'src/status.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/status.h'\"
else
  echo shar: Extracting \"'src/status.h'\" \(4521 characters\)
  sed "s/^X//" >'src/status.h' <<'END_OF_FILE'
X/***************************************************************************
X*   STATUS.H                                                               *
X*   Status code header.                                                    *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright 1993 by James W. Birdsall, all rights reserved.              *
X*                                                                          *
X*   $Id: status.h,v 1.5 1993/02/10 01:52:44 jwbirdsa Exp $
X*                                                                          *
X*   This file contains definitions for module and severity codes which     *
X*   are used in error/status return codes.                                 *
X*                                                                          *
X*   Each module has a specific code, which occupies bits 16-25,            *
X*   allowing for 1023 modules (code 0 is reserved).                        *
X*                                                                          *
X*   Bits 0-1 are the severity code.                                        *
X*                                                                          *
X*   Bits 2-15 are the error/status code itself.                            *
X*                                                                          *
X*   Code 0L is reserved for success.                                       *
X*                                                                          *
X***************************************************************************/
X
X#ifndef DEPEND_H
X    **** ERROR **** MUST INCLUDE DEPEND.H BEFORE STATUS.H
X#endif
X
X#ifndef __STATUS__
X
X#define __STATUS__
X
X/*
X** #defines
X*/
X
X/* Field masks and shift constants. */
X
X#define ST_SEVER_MASK   MKLONG(0x00000003)  /* severity code mask */
X#define ST_MOD_MASK     MKLONG(0x03FF0000)  /* module code mask */
X#define ST_CODE_MASK    MKLONG(0x0000FFFC)  /* error code mask */
X
X#define ST_SEVER_SHIFT  0                   /* shift of severity to bit 0 */
X#define ST_MOD_SHIFT    16                  /* shift of module to bit 0 */
X#define ST_CODE_SHIFT   2                   /* shift of code to bit 0 */
X
X/* Severity codes. */
X
X#define ST_SUCCESS      MKLONG(0x00000000)  /* success */
X#define ST_WARNING      MKLONG(0x00000001)  /* warning */
X#define ST_ERROR        MKLONG(0x00000002)  /* error */
X#define ST_FATAL        MKLONG(0x00000003)  /* fatal error, module munged */
X
X/* Module codes. */
X
X#define FB_MODULE       MKLONG(0x00010000)  /* FB (file buffer) module */
X#define GIF_MODULE      MKLONG(0x00020000)  /* GIF (GIF format processor) */
X#define MF_MODULE       MKLONG(0x00030000)  /* MF (memfile) module */
X#define GLD_MODULE      MKLONG(0x00040000)  /* GLD (GIF/LZW decode) module */
X#define IMG_MODULE      MKLONG(0x00050000)  /* IMG (IMG format processor) */
X#define JFIF_MODULE     MKLONG(0x00060000)  /* JFIF (JFIF format processor) */
X#define FM_MODULE       MKLONG(0x00070000)  /* FM (formats) module */
X#define SR_MODULE       MKLONG(0x00080000)  /* SR (Sun Raster format proc) */
X#define TGA_MODULE      MKLONG(0x00090000)  /* TGA (Targa format processor) */
X#define PBM_MODULE      MKLONG(0x000A0000)  /* PBM format processor */
X#define PGM_MODULE      MKLONG(0x000B0000)  /* PGM format processor */
X#define PPM_MODULE      MKLONG(0x000C0000)  /* PPM format processor */
X#define XBM_MODULE      MKLONG(0x000D0000)  /* XBM format processor */
X#define BMP_MODULE      MKLONG(0x000E0000)  /* BMP format processor */
X#define PCX_MODULE      MKLONG(0x000F0000)  /* PCX format processor */
X
X/* SUCCESS() returns 0L if code was a success code, nonzero otherwise. */
X
X#define SUCCESS(x)      ((x) & ST_SEVER_MASK)
X
X/* Crack an error code into its component parts. */
X
X#define SEVERITY(x)     ((int)(((x) & ST_SEVER_MASK) >> ST_SEVER_SHIFT))
X#define MODULE(x)       ((int)(((x) & ST_MOD_MASK) >> ST_MOD_SHIFT))
X#define ERRCODE(x)      ((int)(((x) & ST_CODE_MASK) >> ST_CODE_SHIFT))
X#define ERRSEV(x)       (SEVERITY(x) | (ERRCODE(x) << ST_CODE_SHIFT))
X
X/* Create an error code from its component parts. */
X
X#define MKERR(c,m,s)    ((MKLONG(c) << ST_CODE_SHIFT) | (m) | (s))
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST RCSstatus[] = "$Id: status.h,v 1.5 1993/02/10 01:52:44 jwbirdsa Exp $";
X
X
X/*
X** typedefs
X*/
X
X/*
X** global variables
X*/
X
X/*
X** function prototypes
X*/
X
X
X#endif /* STATUS_H */
X
END_OF_FILE
  if test 4521 -ne `wc -c <'src/status.h'`; then
    echo shar: \"'src/status.h'\" unpacked with wrong size!
  fi
  # end of 'src/status.h'
fi
if test -f 'src/stdinarg.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/stdinarg.c'\"
else
  echo shar: Extracting \"'src/stdinarg.c'\" \(5426 characters\)
  sed "s/^X//" >'src/stdinarg.c' <<'END_OF_FILE'
X/***************************************************************************
X*   STDINARG.C                                                             *
X*   MODULE:  -                                                             *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   The Graphics Interchange Format(c) is the Copyright property of        *
X*   CompuServe Incorporated. GIF(sm) is a Service Mark property of         *
X*   CompuServe Incorporated.                                               *
X*                                                                          *
X*   $Id: stdinarg.c,v 1.0 1993/02/10 01:55:19 jwbirdsa Exp $
X*                                                                          *
X*   Load arguments from stdin.                                             *
X*                                                                          *
X***************************************************************************/
X
X#include "config.h"
X
X/*
X** system includes <>
X*/
X
X#include <stdio.h>
X#ifndef NO_MALLOCHDR
X#include <malloc.h>
X#endif
X#ifndef NO_STR_INC
X#ifdef STRING_PLURAL
X#include <strings.h>
X#else
X#include <string.h>
X#endif
X#endif
X
X
X/*
X** custom includes ""
X*/
X
X#include "depend.h"
X
X#include "stdinarg.h"
X
X
X/*
X** local #defines
X*/
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST rcsid[] = "$Id: stdinarg.c,v 1.0 1993/02/10 01:55:19 jwbirdsa Exp $";
X
X
X/*
X** typedefs
X*/
X
X/*
X** global variables
X*/
X
X/*
X** static globals
X*/
X
X/*
X** function prototypes
X*/
X
X#ifdef NO_STR_INC
X#ifndef NO_STRDUP
Xextern char *strdup();
X#endif
X#endif
X
X
X/*
X** functions
X*/
X
X/***************************************************************************
X*   FUNCTION:  stdinload                                                   *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*      This function loads targets from stdin when using CHILS as a front  *
X*      end, or a response file.                                            *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*      argcc - pointer to int in which to return number of targets         *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*      Returns an argv[]-style array of target strings, or NULL on error.  *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xchar **
X#ifdef __STDC__
Xstdinload(int *argcc)
X#else
Xstdinload(argcc)
Xint *argcc;
X#endif
X{
X    struct inlist {
X        char *target;
X        struct inlist *next;
X    } *top, *temp;
X    int intarget, loop;
X    char **argvv;
X    char buffer[128];
X
X    /* Setup. */
X
X    top = NULL;
X    intarget = 0;
X
X    /* Read from stdin until EOF. */
X
X    while (gets(buffer) != NULL)
X    {
X        /* If blank line read, ignore. */
X
X        if ('\0' == buffer[0])
X        {
X            continue;
X        }
X
X        /* Allocate a new element for linked list. */
X
X        if ((temp = (struct inlist *) malloc(sizeof(struct inlist))) == 
X             (struct inlist *) NULL)
X        {
X            while (top)
X            {
X                temp = top;
X                free(top->target);
X                free(top);
X                top = temp;
X            }
X            return NULL;
X        }
X
X        /* Duplicate buffer into list. */
X
X        temp->target = strdup(buffer);
X        if (NULL == temp->target)
X        {
X            while (top)
X            {
X                temp = top;
X                free(top->target);
X                free(top);
X                top = temp;
X            }
X            return NULL;
X        }
X
X        /* Place new element on top of list. */
X
X        temp->next = top;
X        top = temp;
X        intarget++;
X    }
X
X    /* Compensate for fact that first argument is always program name. */
X
X    intarget++;
X
X    /* Allocate space for array of pointers. */
X
X    if ((argvv = (char **) calloc(intarget, sizeof(char *))) == NULL)
X    {
X        while (top)
X        {
X            temp = top;
X            free(top->target);
X            free(top);
X            top = temp;
X        }
X        return NULL;
X    }
X
X    /* Copy pointers to filenames into array. */
X
X    for(loop = 1; top; loop++)
X    {
X        argvv[loop] = top->target;
X
X        /* And free linked list elements. */
X
X        temp = top;
X        top = top->next;
X        free(temp);
X    }
X
X    /* Return pointer to array and number of arguments. */
X
X    *argcc = intarget;
X
X    return argvv;
X} /* end of stdinload() */
X
END_OF_FILE
  if test 5426 -ne `wc -c <'src/stdinarg.c'`; then
    echo shar: \"'src/stdinarg.c'\" unpacked with wrong size!
  fi
  # end of 'src/stdinarg.c'
fi
if test -f 'src/tga.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/tga.h'\"
else
  echo shar: Extracting \"'src/tga.h'\" \(3490 characters\)
  sed "s/^X//" >'src/tga.h' <<'END_OF_FILE'
X/***************************************************************************
X*   TGA.H                                                                  *
X*   HEADER FOR TGA (Targa file processor)                                  *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   $Id: tga.h,v 1.0 1993/02/10 01:44:41 jwbirdsa Exp $
X*                                                                          *
X*   This file specifies the external interface to the TGA module.          *
X*                                                                          *
X***************************************************************************/
X
X#ifndef DEPEND_H
X    **** ERROR ****    MUST INCLUDE DEPEND.H BEFORE TGA.H
X#endif
X
X#ifndef TGA_H
X
X#define TGA_H
X
X/*
X** system includes <>
X*/
X
X/*
X** custom includes ""
X*/
X
X#include "status.h"
X
X
X/*
X** local #defines
X*/
X
X/* Version defines. */
X
X#define TGA_NOT               FORMAT_NOT
X#define TGA_1                 (FORMAT_TGA | MKLONG(1))
X
X/* Offsets in header. */
X
X#define TGA_HDR_IDLEN_OFF     0
X#define TGA_HDR_MTYPE_OFF     1
X#define TGA_HDR_TYPE_OFF      2
X#define TGA_HDR_MORG_OFF      3
X#define TGA_HDR_MLEN_OFF      5
X#define TGA_HDR_MESIZ_OFF     7
X#define TGA_HDR_IMXORG_OFF    8
X#define TGA_HDR_IMYORG_OFF    10
X#define TGA_HDR_IMWID_OFF     12
X#define TGA_HDR_IMHI_OFF      14
X#define TGA_HDR_BITS_OFF      16
X#define TGA_HDR_RAW_OFF       17
X
X#define TGA_HDR_LEN           18
X
X/* Masks and shifts for raw bitfield. */
X
X#define TGA_MASK_ATTRBITS     0x0F
X#define TGA_SHIFT_ATTRBITS    0
X#define TGA_MASK_INTERLEAVE   0xC0
X#define TGA_SHIFT_INTERLEAVE  6
X
X/* Error/status defines. */
X
X#define TGA_NOTTGA_E          MKERR(1, TGA_MODULE, ST_ERROR)
X#define TGA_FILEERR_E         MKERR(2, TGA_MODULE, ST_ERROR)
X#define TGA_UNEOF_E           MKERR(3, TGA_MODULE, ST_ERROR)
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST RCStga[] = "$Id: tga.h,v 1.0 1993/02/10 01:44:41 jwbirdsa Exp $";
X
X
X/*
X** typedefs
X*/
X
Xtypedef struct {
X    int idfieldlen;                 /* ID field length, usually 0 */
X    int maptype;                    /* type of colormap */
X    int type;                       /* image type */
X    unsigned int maporg;            /* origin of colormap */
X    unsigned int maplen;            /* length of the colormap, entries */
X    int mapentsize;                 /* size of colormap entry, bits */
X    unsigned int imxorg;            /* X origin of image */
X    unsigned int imyorg;            /* Y origin of image */
X    unsigned int imwid;             /* image width, pixels */
X    unsigned int imhi;              /* image height, pixels */
X    int pixelbits;                  /* bits per pixel */
X    UCHAR raw;                      /* raw contents of bitfield */
X    int attrbits;                   /* raw: attribute bits per pixel */
X    int interleave;                 /* raw: interleave type */
X} TGA_HDR;
X
X
X/*
X** global variables
X*/
X
X/*
X** function prototypes
X*/
X
X#ifdef  __STDC__
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
XULONG tga_verify P_((char *filename, ULONG *version, char **exts));
X
XULONG tga_getheader P_((FILE *infile, TGA_HDR *results));
X
Xchar *tga_errstring P_((ULONG errcode));
X
X#undef P_
X
X#endif /* TGA_H */
X
END_OF_FILE
  if test 3490 -ne `wc -c <'src/tga.h'`; then
    echo shar: \"'src/tga.h'\" unpacked with wrong size!
  fi
  # end of 'src/tga.h'
fi
echo shar: End of archive 17 \(of 18\).
cp /dev/null ark17isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
