Newsgroups: comp.sources.misc
From: jwbirdsa@picarefy.picarefy.com (James W. Birdsall)
Subject: v36i084:  chiaro - Image Utilities, Part14/18
Message-ID: <1993Mar26.202909.14935@sparky.imd.sterling.com>
X-Md4-Signature: 60bd4c2ae8b0dad3837fd4cf3cdd5bc0
Date: Fri, 26 Mar 1993 20:29:09 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jwbirdsa@picarefy.picarefy.com (James W. Birdsall)
Posting-number: Volume 36, Issue 84
Archive-name: chiaro/part14
Environment: UNIX, Sun, DECstation, 3B1

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  src/img.c src/re.c src/xbm.c templates/pcix.h
# Wrapped by kent@sparky on Thu Mar 25 11:20:06 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 14 (of 18)."'
if test -f 'src/img.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/img.c'\"
else
  echo shar: Extracting \"'src/img.c'\" \(11120 characters\)
  sed "s/^X//" >'src/img.c' <<'END_OF_FILE'
X/***************************************************************************
X*   IMG.C                                                                  *
X*   MODULE:  IMG                                                           *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   $Id: img.c,v 1.5 1993/03/02 00:55:29 jwbirdsa Exp $
X*                                                                          *
X*   REMEMBER THAT HEADER OF IMG FILE CONTAINS WORDS IN MOTOROLA FORMAT!    *
X*                                                                          *
X*   This file contains functions to process IMG format files.              *
X*   Functions:                                                             *
X*      img_verify    - checks filename to see if it is an IMG file         *
X*      img_getheader - extracts header data from IMG file                  *
X*                                                                          *
X*      img_errstring - converts error code into message                    *
X*                                                                          *
X***************************************************************************/
X
X#include "config.h"
X
X/*
X** system includes <>
X*/
X
X#include <stdio.h>
X#ifndef NO_STR_INC
X#ifdef STRING_PLURAL
X#include <strings.h>
X#else
X#include <string.h>
X#endif
X#endif
X
X
X/*
X** custom includes ""
X*/
X
X#include "depend.h"
X#include "formats.h"
X#include "img.h"
X
X
X/*
X** local #defines
X*/
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
X/*
X** typedefs
X*/
X
X/*
X** global variables
X*/
X
X/*
X** static globals
X*/
X
Xstatic char CONST rcsid[] = "$Id: img.c,v 1.5 1993/03/02 00:55:29 jwbirdsa Exp $";
X
X
X/*
X** function prototypes
X*/
X
X#ifdef NO_STR_INC
Xextern char *strrchr();
Xextern int strcmp();
X#endif
X
X
X/*
X** functions
X*/
X
X
X/***************************************************************************
X*   FUNCTION:    img_verify                                                *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Verifies that a file is an IMG file by checking filename against   *
X*       list of extensions. Reads IMG version number from start of file.   *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       filename - name of file to be verified                             *
X*       version  - pointer to unsigned long in which format/version value  *
X*                  is returned                                             *
X*       exts     - array of string pointers, list of extensions for IMG    *
X*                  files                                                   *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns an error/status code.                                      *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XULONG
X#ifdef __STDC__
Ximg_verify(char *filename, ULONG *version, char **exts)
X#else
Ximg_verify(filename, version, exts)
Xchar *filename;
XULONG *version;
Xchar **exts;
X#endif
X{
X    char *extptr;
X    int loop;
X    FILE *imgfile;
X    int verno;
X    ULONG retval;
X
X    /* Search for '.' marking extension. */
X
X    extptr = strrchr(filename, '.');
X    if (NULL == extptr)
X    {
X        /* No extension, cannot classify. */
X
X        *version = IMG_NOT;
X        return 0;
X    }
X    extptr++;
X
X    /* Now we have the extension, check against list. */
X
X    for (loop = 0; exts[loop] != NULL; loop++)
X    {
X        /* Case-sensitive string compare. */
X
X        if (strcmp(extptr, exts[loop]) == 0)
X        {
X            /* Match, so break out of loop. */
X
X            break;
X        }
X    }
X
X    /* Check exit from loop. */
X
X    if (NULL == exts[loop])
X    {
X        /* No match, return. */
X
X        *version = IMG_NOT;
X        return 0;
X    }
X
X    /* Extension is valid for type IMG, so process accordingly. */
X
X    if ((imgfile = fopen(filename, FOPEN_READ_BINARY)) == (FILE *) NULL)
X    {
X        return IMG_FILEERR_E;
X    }
X
X    /* Read version number, MSB. */
X
X    if ((loop = fgetc(imgfile)) == EOF)
X    {
X        *version = IMG_NOT;
X        retval = (feof(imgfile) ? ST_SUCCESS : IMG_FILEERR_E);
X        fclose(imgfile);
X        return retval;
X    }
X    verno = (loop & 0x00FF);
X    verno <<= 8;
X
X    /* Read version number, LSB. */
X
X    if ((loop = fgetc(imgfile)) == EOF)
X    {
X        *version = IMG_NOT;
X        retval = (feof(imgfile) ? ST_SUCCESS : IMG_FILEERR_E);
X        fclose(imgfile);
X        return retval;
X    }
X    verno |= (loop & 0x00FF);
X
X    /* Set version according to verno */
X
X    *version = ((1 == verno) ? IMG_VER1 : IMG_NOT);
X
X    /* Close file. */
X
X    if (fclose(imgfile))
X    {
X        return IMG_FILEERR_E;
X    }
X
X    /* Return OK. */
X
X    return 0;
X} /* end of img_verify() */
X
X
X/***************************************************************************
X*   FUNCTION:    img_getheader                                             *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Assumes that file is an IMG file. Reads header from file, extracts *
X*       data into IMG_HDR structure.                                       *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       infile  - file to be processed                                     *
X*       results - pointer to IMG_HDR structure in which data from header   *
X*                 is returned                                              *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns an error/status code.                                      *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X*       Leaves file pointing to beginning of image data.                   *
X*                                                                          *
X***************************************************************************/
XULONG
X#ifdef __STDC__
Ximg_getheader(FILE *infile, IMG_HDR *results)
X#else
Ximg_getheader(infile, results)
XFILE *infile;
XIMG_HDR *results;
X#endif
X{
X    UCHAR rawhdr[IMG_HDR_LEN];
X
X    /* Make sure we're at beginning of file. */
X
X    if (fseek(infile, 0L, SEEK_SET))
X    {
X        return IMG_FILEERR_E;
X    }
X
X    /* Read raw bytes into buffer. */
X
X    if (fread(rawhdr, 1, IMG_HDR_LEN, infile) != IMG_HDR_LEN)
X    {
X        return (feof(infile) ? IMG_UNEOF_E : IMG_FILEERR_E);
X    }
X
X    /* Extract info from raw header. */
X
X#if 0
X    /* Someday this code may be meaningful. */
X
X    results->version = (ULONG) CONSTRUCT_M_UINT(rawhdr + IMG_HDR_VERS_OFF);
X#else
X    results->version = IMG_VER1;
X#endif
X
X    results->headerlen = CONSTRUCT_M_UINT(rawhdr + IMG_HDR_HLEN_OFF);
X    results->planes = CONSTRUCT_M_UINT(rawhdr + IMG_HDR_PLANES_OFF);
X    results->patternlen = CONSTRUCT_M_UINT(rawhdr + IMG_HDR_PLEN_OFF);
X    results->pixwid = CONSTRUCT_M_UINT(rawhdr + IMG_HDR_PWID_OFF);
X    results->pixhi = CONSTRUCT_M_UINT(rawhdr + IMG_HDR_PHI_OFF);
X    results->imwid = CONSTRUCT_M_UINT(rawhdr + IMG_HDR_IMWID_OFF);
X    results->imhi = CONSTRUCT_M_UINT(rawhdr + IMG_HDR_IMHI_OFF);
X
X    /* Set file to point to start of data. */
X
X    if (fseek(infile, (long) (results->headerlen * 2), SEEK_SET))
X    {
X        return IMG_FILEERR_E;
X    }
X
X    /* Return OK. */
X
X    return 0;
X} /* end of img_getheader() */
X
X
X/***************************************************************************
X*   FUNCTION: img_errstring                                                *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*      Returns a string corresponding to an error code.                    *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*      errcode - error code to be translated                               *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*      Returns a pointer to the appropriate string, or NULL if there is    *
X*      no appropriate string.                                              *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xchar *
X#ifdef __STDC__
Ximg_errstring(ULONG errcode)
X#else
Ximg_errstring(errcode)
XULONG errcode;
X#endif
X{
X    char *temp;
X
X    /* If error code not from this module, return NULL. */
X
X    if ((errcode & ST_MOD_MASK) != IMG_MODULE)
X    {
X        return NULL;
X    }
X
X    /* Process by code. */
X
X    switch (ERRSEV(errcode))
X    {
X        case ERRSEV(IMG_NOTIMG_E):
X            temp = "File is not a IMG format file.";
X            break;
X        case ERRSEV(IMG_FILEERR_E):
X            temp = "Error accessing file.";
X            break;
X        case ERRSEV(IMG_UNEOF_E):
X            temp = "Unexpected End of File";
X            break;
X
X        default:
X            temp = NULL;
X            break;
X    }
X
X    return temp;
X} /* end of img_errstring() */
X
END_OF_FILE
  if test 11120 -ne `wc -c <'src/img.c'`; then
    echo shar: \"'src/img.c'\" unpacked with wrong size!
  fi
  # end of 'src/img.c'
fi
if test -f 'src/re.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/re.c'\"
else
  echo shar: Extracting \"'src/re.c'\" \(28428 characters\)
  sed "s/^X//" >'src/re.c' <<'END_OF_FILE'
X/***************************************************************************
X*   RE.C                                                                   *
X*   MODULE:  FORMATS                                                       *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   The Graphics Interchange Format(c) is the Copyright property of        *
X*   CompuServe Incorporated. GIF(sm) is a Service Mark property of         *
X*   CompuServe Incorporated.                                               *
X*                                                                          *
X*   $Id: re.c,v 1.2 1993/03/18 21:15:35 jwbirdsa Exp $
X*                                                                          *
X*   Functions to recognize file formats.                                   *
X*                                                                          *
X*   Functions in this file are:                                            *
X*                                                                          *
X*     re_ident   - identify a file                                         *
X*     re_init    - initialize the recognizer module                        *
X*     re_deinit  - deinitialize the recognizer module                      *
X*     re_extlist - get the extension list for a type                       *
X*                                                                          *
X***************************************************************************/
X
X#include "config.h"
X
X/*
X** system includes <>
X*/
X
X#include <stdio.h>
X#include <ctype.h>
X#ifndef NO_STDLIB
X#include <stdlib.h>
X#endif
X#ifndef NO_MEMOP
X#include <memory.h>
X#endif
X#ifndef NO_MALLOCHDR
X#include <malloc.h>
X#endif
X#ifndef NO_STR_INC
X#ifdef STRING_PLURAL
X#include <strings.h>
X#else
X#include <string.h>
X#endif
X#endif
X
X
X/*
X** custom includes ""
X*/
X
X#include "depend.h"
X
X#include "formats.h"
X#include "re.h"
X
X#include "fb.h"
X#include "gif.h"
X#include "img.h"
X#include "jfif.h"
X#include "sr.h"
X#include "tga.h"
X#include "pnm.h"
X#include "xbm.h"
X#include "bmp.h"
X#include "pcx.h"
X
X
X/*
X** local #defines
X*/
X
X#define EXTS_GUESS  5             /* initial guess at extensions/type */
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST rcsid[] = "$Id: re.c,v 1.2 1993/03/18 21:15:35 jwbirdsa Exp $";
X
X
X/*
X** typedefs
X*/
X
Xtypedef struct bb {
X    char name[15];
X    char **exts;
X    struct bb *next;
X} EXTLIST;
X
X
X/*
X** global variables
X*/
X
Xstatic EXTLIST *extlist = NULL;          /* list of format extensions */
X
Xstatic char scratch[80];                 /* local scratchpad */
X
X
X/*
X** function prototypes
X*/
X
X#ifdef  __STDC__
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
Xstatic int searchpath P_((char *progname, char *retbuf));
X
X#undef P_
X
X
X#ifdef NO_STDLIB
Xextern char *getenv();
X#endif
X
X#ifdef NO_STR_INC
Xextern char *strcpy();
Xextern char *strchr();
Xextern char *strrchr();
Xextern int strlen();
Xextern int strcmp();
X#ifndef NO_STRDUP
Xextern char *strdup();
X#endif
X#endif
X
Xextern int access();
X
X/*
X** functions
X*/
X
X
X/***************************************************************************
X*   FUNCTION: re_ident                                                     *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Examines a given file to determine if it is of a known bitmap      *
X*       format.                                                            *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       filename - name of file to be examined                             *
X*       format   - place to return format code                             *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns error/status code.                                         *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XULONG
X#ifdef __STDC__
Xre_ident(char *filename, ULONG *format)
X#else
Xre_ident(filename, format)
Xchar *filename;
XULONG *format;
X#endif
X{
X    ULONG status;
X    char **exts;
X
X    /*
X    ** Check each format in turn.
X    */
X
X    /* GIF */
X
X    if ((status = gif_verify(filename, format, re_extlist(GIF_MAIN))) != 0)
X    {
X        return status;
X    }
X    if (*format != FORMAT_NOT)
X    {
X        return 0;
X    }
X
X    /* IMG */
X
X    if ((exts = re_extlist(IMG_MAIN)) != (char **) NULL)
X    {
X        /* Got a match, so use supplied list. */
X 
X        if ((status = img_verify(filename, format, exts)) != 0)
X        {
X            return status;
X        }
X        if (*format != FORMAT_NOT)
X        {
X            return 0;
X        }
X    }
X
X    /* JFIF */
X
X    if ((exts = re_extlist(JFIF_MAIN)) != (char **) NULL)
X    {
X        /* Got a match, so use supplied list. */
X 
X        if ((status = jfif_verify(filename, format, exts)) != 0)
X        {
X            return status;
X        }
X        if (*format != FORMAT_NOT)
X        {
X            return 0;
X        }
X    }
X
X    /* SR (Sun Raster) */
X
X    if ((status = sr_verify(filename, format, re_extlist(SR_MAIN))) != 0)
X    {
X        return status;
X    }
X    if (*format != FORMAT_NOT)
X    {
X        return 0;
X    }
X
X    /* TGA */
X
X    if ((exts = re_extlist(TGA_MAIN)) != (char **) NULL)
X    {
X        /* Got a match, so use supplied list. */
X 
X        if ((status = tga_verify(filename, format, exts)) != 0)
X        {
X            return status;
X        }
X        if (*format != FORMAT_NOT)
X        {
X            return 0;
X        }
X    }
X
X    /* PBM */
X
X    if ((exts = re_extlist(PBM_MAIN)) != (char **) NULL)
X    {
X        /* Got a match, so use supplied list. */
X 
X        if ((status = pbm_verify(filename, format, exts)) != 0)
X        {
X            return status;
X        }
X        if (*format != FORMAT_NOT)
X        {
X            return 0;
X        }
X    }
X
X    /* PGM */
X
X    if ((exts = re_extlist(PGM_MAIN)) != (char **) NULL)
X    {
X        /* Got a match, so use supplied list. */
X 
X        if ((status = pgm_verify(filename, format, exts)) != 0)
X        {
X            return status;
X        }
X        if (*format != FORMAT_NOT)
X        {
X            return 0;
X        }
X    }
X
X    /* PPM */
X
X    if ((exts = re_extlist(PPM_MAIN)) != (char **) NULL)
X    {
X        /* Got a match, so use supplied list. */
X 
X        if ((status = ppm_verify(filename, format, exts)) != 0)
X        {
X            return status;
X        }
X        if (*format != FORMAT_NOT)
X        {
X            return 0;
X        }
X    }
X
X    /* XBM */
X
X    if ((exts = re_extlist(XBM_MAIN)) != (char **) NULL)
X    {
X        /* Got a match, so use supplied list. */
X 
X        if ((status = xbm_verify(filename, format, exts)) != 0)
X        {
X            return status;
X        }
X        if (*format != FORMAT_NOT)
X        {
X            return 0;
X        }
X    }
X
X    /* BMP */
X
X    if ((exts = re_extlist(BMP_MAIN)) != (char **) NULL)
X    {
X        /* Got a match, so use supplied list. */
X 
X        if ((status = bmp_verify(filename, format, exts)) != 0)
X        {
X            return status;
X        }
X        if (*format != FORMAT_NOT)
X        {
X            return 0;
X        }
X    }
X
X    /* PCX */
X
X    if ((exts = re_extlist(PCX_MAIN)) != (char **) NULL)
X    {
X        /* Got a match, so use supplied list. */
X 
X        if ((status = pcx_verify(filename, format, exts)) != 0)
X        {
X            return status;
X        }
X        if (*format != FORMAT_NOT)
X        {
X            return 0;
X        }
X    }
X
X    /* File type not recognized at all. Return unrecognized. */
X
X    return FM_UNRECOGNIZED_W;
X} /* end of re_ident() */
X
X
X/***************************************************************************
X*   FUNCTION:    re_init                                                   *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Reads extension lists from configuration file.                     *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       progname - path to CHILS executable                                *
X*       cfg_name - name of configuration file                              *
X*       envvar   - name of environment variable                            *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns an error/status code.                                      *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X*       Builds the list of extension lists.                                *
X*                                                                          *
X***************************************************************************/
XULONG
X#ifdef __STDC__
Xre_init(char *progname, char *cfg_name, char *envvar)
X#else
Xre_init(progname, cfg_name, envvar)
Xchar *progname;
Xchar *cfg_name;
Xchar *envvar;
X#endif
X{
X    FILE *configfile;
X    int loop, go;
X    EXTLIST *tempext;
X    int c;
X    int extcount, extarraysize;
X    char **tempre;
X    char *chihome;
X    char *term;
X
X    /*
X    ** First, find configuration file -- check for configuration file in
X    ** current directory.
X    */
X
X    if ((configfile = fopen(cfg_name, "r")) == (FILE *) NULL)
X    {
X        /*
X        ** If not, check for environment variable.
X        */
X
X        if ((chihome = getenv(envvar)) != (char *) NULL)
X        {
X            strcpy(scratch, chihome);
X        }
X        else
X        {
X            /* 
X            ** Last chance -- check directory where program resides.
X            */
X
X            /* First, create filespec. */
X
X            strcpy(scratch, progname);
X            if ((term = strrchr(scratch, '/')) == NULL)
X            {
X                /* Program is either in current directory or in path. */
X
X                if (access(progname, 1) == 0)
X                {
X                    /* 
X                    ** Oops -- program is in current directory, and we already 
X                    ** looked there, so abort.
X                    */
X    
X                    return FM_NOCFGFILE_W;
X                }
X
X                /* Program is in path, so search path for it. */
X
X                if (searchpath(progname, scratch) == -1)
X                {
X                    /*
X                    ** Didn't find the program in the path, so who knows
X                    ** where it came from? (and hence where to look for the
X                    ** config file)
X                    */
X    
X                    return FM_NOCFGFILE_W;
X                }
X            }
X            else
X            {
X                /* Program name includes path, use it. */
X
X                *term = '\0';
X            }
X        }
X
X        /*
X        ** Got a base name, now make a full name out of it and try to open
X        ** that file.
X        */
X
X        loop = strlen(scratch);
X        scratch[loop] = '/';
X        strcpy((scratch + loop + 1), cfg_name);
X        if ((configfile = fopen(scratch, "r")) == (FILE *) NULL)
X        {
X            return FM_NOCFGFILE_W;
X        }
X    }
X
X    /*
X    ** Read entries from file.
X    */
X
X    while (feof(configfile) == 0)
X    {
X        /*
X        ** Read forward to non-whitespace.
X        */
X
X        while ((c = fgetc(configfile)) != EOF)
X        {
X            if (isspace(c) == 0)
X            {
X               break;
X            }
X        }
X        if (EOF == c)
X        {
X            continue;
X        }
X
X        /*
X        ** If it's a '#', read forward to next newline and start over.
X        */
X
X        if ('#' == c)
X        {
X            while ((c = fgetc(configfile)) != EOF)
X            {
X                if ('\n' == c)
X                {
X                    break;
X                }
X            }
X            continue;
X        }
X
X        /*
X        ** Found something that's not whitespace or a comment,
X        ** must be an entry. So get name of type.
X        */
X
X        scratch[0] = c;
X        for (loop = 1; isspace((c = fgetc(configfile))) == 0; loop++)
X        {
X            if (EOF == c)
X            {
X                scratch[loop] = '\0';
X                fprintf(stderr,
X                        "WARNING: Type name %s has no extension list in %s\n",
X                        scratch, cfg_name);
X                break;
X            }
X            scratch[loop] = (char) c;
X        }
X        if (EOF == c)
X        {
X            continue;
X        }
X        scratch[loop] = '\0';
X
X        /*
X        ** Search through format name list for match, case sensitive.
X        */
X
X        for (loop = 0; formatsearch[loop].name[0] != '\0'; loop++)
X        {
X            if (strcmp(formatsearch[loop].name, scratch) == 0)
X            {
X                /* Got a match, break out. */
X
X                break;
X            }
X        }
X        if ('\0' == formatsearch[loop].name[0])
X        {
X            /* Didn't get a match. */
X
X            fprintf(stderr,
X                 "WARNING: Unrecognized format id %s in configuration file.\n",
X                 scratch);
X
X            /* So read forward to next newline and continue. */
X
X            while ((c = fgetc(configfile)) != EOF)
X            {
X                if ('\n' == c)
X                {
X                    break;
X                }
X            }
X            continue;
X        }
X
X        /*
X        ** Allocate an EXTLIST structure, initialize.
X        */
X
X        if ((tempext = (EXTLIST *) malloc(sizeof(EXTLIST))) == 
X            (EXTLIST *) NULL)
X        {
X            fclose(configfile);
X            return FM_NOMEM_F;
X        }
X
X        /* Copy name into EXTLIST structure. */
X
X        strcpy(tempext->name, formatsearch[loop].name);
X
X        /*
X        ** Read extensions.
X        */
X
X        go = 1;
X        extcount = 0;
X        extarraysize = EXTS_GUESS;
X        tempext->exts = (char **) malloc((extarraysize + 1) * sizeof(char *));
X        if (((char **) NULL) == tempext->exts)
X        {
X            fclose(configfile);
X            return FM_NOMEM_F;
X        }
X        while (1 == go)
X        {
X            /* Skip forward to next non-whitespace, non-comma. */
X
X            while ((c = fgetc(configfile)) != EOF)
X            {
X                if (',' == c)
X                {
X                    continue;
X                }
X                if (isspace(c) == 0)
X                {
X                    break;
X                }
X            }
X            if (EOF == c)
X            {
X                go = 0;
X                continue;
X            }
X            scratch[0] = c;
X
X            /* Read characters until hit comma, whitespace, or EOF. */
X
X            for (loop = 1; (c = fgetc(configfile)) != EOF; loop++)
X            {
X                if ('\n' == c)
X                {
X                    go = 0;
X                    break;
X                }
X                if ((isspace(c)) || (',' == c))
X                {
X                    break;
X                }
X                scratch[loop] = (char) c;
X            }
X            scratch[loop] = '\0';
X
X            /* Check extension length. */
X
X            if ('\0' == scratch[0])
X            {
X                fprintf(stderr,
X                        "WARNING: Skipping null extension for type %s\n",
X                        tempext->name);
X            }
X
X            /* Is array large enough? */
X
X            if (extcount >= extarraysize)
X            {
X                extarraysize += EXTS_GUESS;
X                tempre = (char **) realloc(tempext->exts,
X                                           ((extarraysize + 1) * 
X                                            sizeof(char *)));
X                if (((char **) NULL) == tempre)
X                {
X                    fclose(configfile);
X                    return FM_NOMEM_F;
X                }
X                tempext->exts = tempre;
X            }
X
X            /* Put extension into array. */
X
X            tempext->exts[extcount++] = strdup(scratch);
X        }
X
X        /*
X        ** If error while reading extensions, break out of loop,
X        ** else clean up a bit.
X        */
X
X        if (-1 == go)
X        {
X            break;
X        }
X
X        /* Check that there were extensions. */
X
X        if (0 == extcount)
X        {
X            /* If none, free structures and get another entry. */
X
X            fprintf(stderr, "WARNING: No extensions found for type %s\n",
X                    tempext->name);
X            free(tempext->exts);
X            free(tempext);
X            continue;
X        }
X
X        /* Shrink exts to minimum size necessary. */
X
X        tempre = (char **) realloc(tempext->exts,
X                                   ((extcount + 1) * sizeof(char *)));
X        if (((char **) NULL) == tempre)
X        {
X            fclose(configfile);
X            return FM_NOMEM_F;
X        }
X        else
X        {
X            tempext->exts = tempre;
X        }
X        tempext->exts[extcount] = (char *) NULL;
X
X        /* Put extension list on list of extension lists. */
X
X        tempext->next = extlist;
X        extlist = tempext;
X
X        /* Go get another entry. */
X
X        if (fseek(configfile, -1L, SEEK_CUR) != 0)
X        {
X            fclose(configfile);
X            return FM_READERR_E;
X        }
X    }
X
X    /*
X    ** Clean up.
X    */
X
X    fclose(configfile);
X
X    return ST_SUCCESS;
X} /* end of re_init() */
X
X
X/***************************************************************************
X*   FUNCTION:  re_deinit                                                   *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Frees extension lists.                                             *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns nothing.                                                   *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XVOID
Xre_deinit()
X{
X    EXTLIST *temp;
X    int loop;
X
X    /* Free extension list, if present. */
X
X    while (extlist != (EXTLIST *) NULL)
X    {
X        temp = extlist;
X        extlist = extlist->next;
X        for (loop = 0; temp->exts[loop] != NULL; loop++)
X        {
X            free(temp->exts[loop]);
X        }
X        free(temp->exts);
X        free(temp);
X    }
X
X    return;
X} /* end of re_deinit() */
X
X
X/***************************************************************************
X*   FUNCTION:  re_extlist                                                  *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Searches list of extension lists for list belonging to given       *
X*       image format.                                                      *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       fortype - format id                                                *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Pointer to extension list (array of strings), or NULL if no        *
X*       extension list exists for the given format.                        *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xchar **
X#ifdef __STDC__
Xre_extlist(char *fortype)
X#else
Xre_extlist(fortype)
Xchar *fortype;
X#endif
X{
X    EXTLIST *tempext;
X
X    /* Search list of extension lists for keyword. */
X
X    for (tempext = extlist; tempext != (EXTLIST *) NULL;
X         tempext = tempext->next)
X    {
X        if (strcmp(tempext->name, fortype) == 0)
X        {
X            /* Got a match, break out. */
X
X            break;
X        }
X    }
X
X    /* Check exit from loop. */
X
X    if (((EXTLIST *) NULL) == tempext)
X    {
X        /* No match, so return NULL. */
X
X        return (char **) NULL;
X    }
X
X    /* Got a match, return it. */
X
X    return tempext->exts;
X} /* end of re_extlist() */
X
X
X/***************************************************************************
X*   FUNCTION: re_errstring                                                 *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Returns a string corresponding to the given error.                 *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       errcode - error code to be translated                              *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns a pointer to the appropriate string, or NULL if there is   *
X*       no appropriate string.                                             *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xchar *
X#ifdef __STDC__
Xre_errstring(ULONG errcode)
X#else
Xre_errstring(errcode)
XULONG errcode;
X#endif
X{
X    char *temp;
X
X    /* If not an FM module error code, return NULL. */
X
X    if (MODULE(errcode) != MODULE(FM_MODULE))
X    {
X        return NULL;
X    }
X
X    /* Process by code. */
X
X    switch (ERRSEV(errcode))
X    {
X        case ERRSEV(FM_UNRECOGNIZED_W):
X            temp = "File type not recognized.";
X            break;
X        case ERRSEV(FM_EOF_W):
X            temp = "EOF encountered when tokenizing file.";
X            break;
X        case ERRSEV(FM_NOCFGFILE_W):
X            temp = "Cannot find configuration file.";
X            break;
X
X        case ERRSEV(FM_READERR_E):
X            temp = "Critical error reading configuration file.";
X            break;
X        case ERRSEV(FM_FILEERR_E):
X            temp = "Read error when tokenizing file.";
X            break;
X
X        case ERRSEV(FM_NOMEM_F):
X            temp = "Out of memory processing configuration file.";
X            break;
X
X        default:
X            temp = NULL;
X            break;
X    }
X
X    return temp;
X} /* end of re_errstring() */
X
X
X/***************************************************************************
X*   FUNCTION:  searchpath  STATIC                                          *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       This function searches for an executable file progname in all      *
X*       the directories in the path.                                       *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       progname - name of program to be found                             *
X*       retbuf   - buffer in which to return directory in which program    *
X*                  was found                                               *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns 0 and directory on success, -1 on failure (and contents    *
X*       of retbuf are undefined).                                          *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xstatic int
X#ifdef __STDC__
Xsearchpath(char *progname, char *retbuf)
X#else
Xsearchpath(progname, retbuf)
Xchar *progname;
Xchar *retbuf;
X#endif
X{
X    char *path;
X    char *working;
X    char *candidate;
X    char *term;
X    char *term2;
X
X    /* Retrieve path from environment. */
X
X    if ((path = getenv("PATH")) == NULL)
X    {
X        return -1;
X    }
X
X    /* Make a working copy that we can munge. */
X
X    if ((working = strdup(path)) == NULL)
X    {
X        return -1;
X    }
X
X    /* Loop through the working copy. */
X
X    for (candidate = working, term = NULL; candidate != NULL; )
X    {
X        /* Find the next colon, terminate the candidate string there. */
X
X        term = strchr(candidate, ':');
X        if (term != NULL)
X        {
X            *term = '\0';
X        }   
X
X        /* Copy candidate into retbuf, add '/' and progname. */
X
X        strcpy(retbuf, candidate);
X        term2 = retbuf + strlen(retbuf);
X        if (term2 != retbuf)
X        {
X            *term2 = '/';
X            *(term2 + 1) = '\0';
X        }
X        strcat(retbuf, progname);
X
X        /* Does it exist? */
X
X        if (access(retbuf, 1) == 0)
X        {
X           /* Yes, so trim retbuf to be just the directory and return. */
X
X           *term2 = '\0';
X           free(working);
X           return 0;
X        }
X
X        /* Doesn't exist, so go on to next one if there is one. */
X
X        candidate = ((term != NULL) ? (term + 1) : NULL);
X    }
X
X    /* Not found. */
X
X    free(working);
X
X    return -1;
X} /* end of static searchpath() */
X
END_OF_FILE
  if test 28428 -ne `wc -c <'src/re.c'`; then
    echo shar: \"'src/re.c'\" unpacked with wrong size!
  fi
  # end of 'src/re.c'
fi
if test -f 'src/xbm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/xbm.c'\"
else
  echo shar: Extracting \"'src/xbm.c'\" \(11149 characters\)
  sed "s/^X//" >'src/xbm.c' <<'END_OF_FILE'
X/***************************************************************************
X*   XBM.C                                                                  *
X*   MODULE:  XBM                                                           *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   $Id: xbm.c,v 1.1 1993/03/02 01:01:00 jwbirdsa Exp $
X*                                                                          *
X*   This file contains functions to process XBM format files.              *
X*   Functions:                                                             *
X*      xbm_verify    - checks filename to see if it is an XBM file         *
X*      xbm_getheader - extracts header data from XBM file                  *
X*                                                                          *
X*      xbm_errstring - converts error code into message                    *
X*                                                                          *
X***************************************************************************/
X
X#include "config.h"
X
X/*
X** system includes <>
X*/
X
X#include <stdio.h>
X#ifndef NO_STDLIB
X#include <stdlib.h>
X#endif
X#ifndef NO_STR_INC
X#ifdef STRING_PLURAL
X#include <strings.h>
X#else
X#include <string.h>
X#endif
X#endif
X
X
X/*
X** custom includes ""
X*/
X
X#include "depend.h"
X#include "formats.h"
X#include "xbm.h"
X#include "token.h"
X
X
X/*
X** local #defines
X*/
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
X/*
X** typedefs
X*/
X
X/*
X** global variables
X*/
X
X/*
X** static globals
X*/
X
Xstatic char CONST rcsid[] = "$Id: xbm.c,v 1.1 1993/03/02 01:01:00 jwbirdsa Exp $";
X
X
X/*
X** function prototypes
X*/
X
X#ifdef NO_STDLIB
Xextern long atol();
X#endif
X
X#ifdef NO_STR_INC
Xextern char *strchr();
Xextern char *strrchr();
Xextern int strcmp();
X#ifndef NO_STRDUP
Xextern char *strdup();
X#endif
X#endif
X
X
X/*
X** functions
X*/
X
X
X/***************************************************************************
X*   FUNCTION:    xbm_verify                                                *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Verifies that a file is an XBM file by checking filename against   *
X*       list of extensions. Reads XBM version number from start of file.   *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       filename - name of file to be verified                             *
X*       version  - pointer to unsigned long in which format/version value  *
X*                  is returned                                             *
X*       exts     - array of string pointers, list of extensions for XBM    *
X*                  files                                                   *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns an error/status code.                                      *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XULONG
X#ifdef __STDC__
Xxbm_verify(char *filename, ULONG *version, char **exts)
X#else
Xxbm_verify(filename, version, exts)
Xchar *filename;
XULONG *version;
Xchar **exts;
X#endif
X{
X    char *extptr;
X    int loop;
X
X    /* Search for '.' marking extension. */
X
X    extptr = strrchr(filename, '.');
X    if (NULL == extptr)
X    {
X        /* No extension, cannot classify. */
X
X        *version = XBM_NOT;
X        return 0;
X    }
X    extptr++;
X
X    /* Now we have the extension, check against list. */
X
X    for (loop = 0; exts[loop] != NULL; loop++)
X    {
X        /* Case-sensitive string compare. */
X
X        if (strcmp(extptr, exts[loop]) == 0)
X        {
X            /* Match, so break out of loop. */
X
X            break;
X        }
X    }
X
X    /* Check exit from loop. */
X
X    if (NULL == exts[loop])
X    {
X        /* No match, return. */
X
X        *version = XBM_NOT;
X        return 0;
X    }
X
X    /* Set version. */
X
X    *version = XBM_1;
X
X    /* Return OK. */
X
X    return 0;
X} /* end of xbm_verify() */
X
X
X/***************************************************************************
X*   FUNCTION:    xbm_getheader                                             *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Assumes that file is an XBM file. Reads header from file, extracts *
X*       data into XBM_HDR structure.                                       *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       infile  - file to be processed                                     *
X*       results - pointer to XBM_HDR structure in which data from header   *
X*                 is returned                                              *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns an error/status code.                                      *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X*       Leaves file pointing to beginning of image data.                   *
X*                                                                          *
X***************************************************************************/
XULONG
X#ifdef __STDC__
Xxbm_getheader(FILE *infile, XBM_HDR *results)
X#else
Xxbm_getheader(infile, results)
XFILE *infile;
XXBM_HDR *results;
X#endif
X{
X    char *token;
X    char *search;
X
X    /* Make sure we're at beginning of file. */
X
X    if (fseek(infile, 0L, SEEK_SET))
X    {
X        return XBM_FILEERR_E;
X    }
X
X    /* Get first token, should be '#define'. */
X
X    if ((token = fm_token(infile)) == NULL)
X    {
X        return XBM_FILEERR_E;
X    }
X    if (strcmp(token, "#define") != 0)
X    {
X        /* Not an XBM. */
X
X        free(token);
X        return XBM_NOTXBM_E;
X    }
X    free(token);
X
X    /* Get next token. */
X
X    if ((token = fm_token(infile)) == NULL)
X    {
X        return XBM_FILEERR_E;
X    }
X    if ((search = strchr(token, '_')) == NULL)
X    {
X        free(token);
X        return XBM_NOTXBM_E;
X    }
X    if (strcmp(search, "_width") != 0)
X    {
X        free(token);
X        return XBM_NOTXBM_E;
X    }
X    *search = '\0';
X    results->imname = token;
X
X    /* Get width value. */
X
X    if ((token = fm_token(infile)) == NULL)
X    {
X        return XBM_FILEERR_E;
X    }
X    if ((results->imwid = atol(token)) == 0L)
X    {
X        free(results->imname);
X        free(token);
X        return XBM_NOTXBM_E;
X    }
X
X    /* Get next token, should be '#define'. */
X
X    if ((token = fm_token(infile)) == NULL)
X    {
X        return XBM_FILEERR_E;
X    }
X    if (strcmp(token, "#define") != 0)
X    {
X        /* Not an XBM. */
X
X        free(token);
X        free(results->imname);
X        return XBM_NOTXBM_E;
X    }
X    free(token);
X
X    /* Get next token. */
X
X    if ((token = fm_token(infile)) == NULL)
X    {
X        return XBM_FILEERR_E;
X    }
X    if ((search = strchr(token, '_')) == NULL)
X    {
X        free(token);
X        free(results->imname);
X        return XBM_NOTXBM_E;
X    }
X    if (strcmp(search, "_height") != 0)
X    {
X        free(token);
X        free(results->imname);
X        return XBM_NOTXBM_E;
X    }
X    free(token);
X
X    /* Get height value. */
X
X    if ((token = fm_token(infile)) == NULL)
X    {
X        return XBM_FILEERR_E;
X    }
X    if ((results->imhi = atol(token)) == 0L)
X    {
X        free(token);
X        free(results->imname);
X        return XBM_NOTXBM_E;
X    }
X
X    /* File already set to point to start of data. */
X
X    /* Return OK. */
X
X    return 0;
X} /* end of xbm_getheader() */
X
X
X/***************************************************************************
X*   FUNCTION: xbm_errstring                                                *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*      Returns a string corresponding to an error code.                    *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*      errcode - error code to be translated                               *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*      Returns a pointer to the appropriate string, or NULL if there is    *
X*      no appropriate string.                                              *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xchar *
X#ifdef __STDC__
Xxbm_errstring(ULONG errcode)
X#else
Xxbm_errstring(errcode)
XULONG errcode;
X#endif
X{
X    char *temp;
X
X    /* If error code not from this module, return NULL. */
X
X    if ((errcode & ST_MOD_MASK) != XBM_MODULE)
X    {
X        return NULL;
X    }
X
X    /* Process by code. */
X
X    switch (ERRSEV(errcode))
X    {
X        case ERRSEV(XBM_NOTXBM_E):
X            temp = "File is not a XBM format file.";
X            break;
X        case ERRSEV(XBM_FILEERR_E):
X            temp = "Error accessing file.";
X            break;
X        case ERRSEV(XBM_UNEOF_E):
X            temp = "Unexpected End of File";
X            break;
X
X        default:
X            temp = NULL;
X            break;
X    }
X
X    return temp;
X} /* end of xbm_errstring() */
X
END_OF_FILE
  if test 11149 -ne `wc -c <'src/xbm.c'`; then
    echo shar: \"'src/xbm.c'\" unpacked with wrong size!
  fi
  # end of 'src/xbm.c'
fi
if test -f 'templates/pcix.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'templates/pcix.h'\"
else
  echo shar: Extracting \"'templates/pcix.h'\" \(819 characters\)
  sed "s/^X//" >'templates/pcix.h' <<'END_OF_FILE'
X/*
X** Configuration file for PC/IX 1.0 and 1.1 with the stock compiler.
X*/
X
X#define CONFIG_H
X
X/* no memory functions */
X#define NO_MEMOP
X
X/* no stdlib.h */
X#define NO_STDLIB
X
X/* no malloc.h */
X#define NO_MALLOCHDR
X
X/* void not really supported */
X#define NO_VOID
X
X/* 16-bit ints */
X#define INT16
X
X/* cc doesn't support "const" type */
X#define NO_CONST
X
X/* ustat() function present */
X#define USTAT
X#define SYS_BLOCKSIZE       512
X
X/* no strdup() function */
X#define NO_STRDUP
X
X/* small memory size */
X#define SMALL_MEM
X
X/* no directory-access functions */
X#define DIR_NODIR
X
X/* no rename() function */
X#define NO_RENAME
X
X/* enable progress indicator */
X#define PROGRESS_IND
X
X/* errno.h does not declare errno */
X#define NO_ERRNO
X
X/* no string include files */
X#define NO_STR_INC
X
X/* have TERMCAP */
X#define HAS_TERMCAP
END_OF_FILE
  if test 819 -ne `wc -c <'templates/pcix.h'`; then
    echo shar: \"'templates/pcix.h'\" unpacked with wrong size!
  fi
  # end of 'templates/pcix.h'
fi
echo shar: End of archive 14 \(of 18\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
