Newsgroups: comp.sources.misc
From: jwbirdsa@picarefy.picarefy.com (James W. Birdsall)
Subject: v36i080:  chiaro - Image Utilities, Part10/18
Message-ID: <1993Mar26.202754.14616@sparky.imd.sterling.com>
X-Md4-Signature: 98a1ac53653d2528c08459055cf0edc5
Date: Fri, 26 Mar 1993 20:27:54 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jwbirdsa@picarefy.picarefy.com (James W. Birdsall)
Posting-number: Volume 36, Issue 80
Archive-name: chiaro/part10
Environment: UNIX, Sun, DECstation, 3B1

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  src/chils.1 src/jfif.h src/pgmppm.c
# Wrapped by kent@sparky on Thu Mar 25 11:20:05 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 10 (of 18)."'
if test -f 'src/chils.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/chils.1'\"
else
  echo shar: Extracting \"'src/chils.1'\" \(34361 characters\)
  sed "s/^X//" >'src/chils.1' <<'END_OF_FILE'
X.\"
X.\" $Id: chils.1,v 1.4 1993/03/18 21:18:21 jwbirdsa Exp $
X.\"
X.TH CHILS 1 "$Date: 1993/03/18 21:18:21 $"
X.PD 1
X.SH NAME
Xchils \- specialized ls for image files
X.SH SYNOPSIS
X.B chils
X[
X.B \-v
X][
X.B \-f
X][
X.B \-h
X][
X.B \-n
X][
X.B \-w[n]
X][
X.B \-tformat
X][
X.B \-spattern
X] [ target ] [ target... ]
X.br
X.SH DESCRIPTION
X.I Chils
Xis a specialized ls(1)-equivalent for image files. It recognizes a variety
Xof image file formats and prints out the file name, file format, file size,
Xand some details of image size, colors, etc., depending on what information
Xthe format contains and how accessible it is.
X.SH TARGETS
XA target is a filename or directory. Multiple targets may be specified on
Xthe command line. If a target is a directory, all files in that directory
Xwill be processed. If no targets are specified on the command line, all
Xfiles in the current directory will be processed.
X.PP
XIf the format of a file is recognized, various information about the file
Xwill be printed to the standard output. Otherwise, no output is generated
Xfor that file unless the
X.B \-v
Xoption has been specified.
X.SH OPTIONS
XOptions may not be combined. In the case of the
X.B \-t
Xand
X.B \-s
Xoptions, there cannot be a space between the option and the argument to the
Xoption.
X.TP
X.B \-v
XPrint a line for every file checked, whether the format was recognized or
Xnot. If the file format was not recognized, a message "ERROR: file 
X.I filename
Xis of unknown format" is printed.
X.TP
X.B \-f
XPrints a list of the names of files of recognized formats (subject to
Xselection criteria specified by other options) on the standard output,
Xseparated by newlines. The
X.B \-v
Xoption is ignored and all other output is suppressed. This output is
Xintended for use as a front end for 
X.I gifstrip
Xand other Chiaro suite programs.
X.TP
X.B \-h
XPrints a usage message.
X.TP
X.B \-n
X.I Chils
Xnormally removes the path, if present, from filenames when displaying, the
Xbetter to fit everything on one line. This option causes
X.I chils
Xto not remove the path, if present.
X.TP
X.B \-w[n]
X.I Chils
Xnormally determines the width of the screen automatically, or defaults the
Xwidth to 80 columns if it cannot get a better answer. This option overrides
Xthe automatic determination. If a number is not supplied, the width is set
Xto 80 columns. If a number is supplied, the width is set to that value or
X80, whichever is greater.
X.TP
X.B \-tformat
XOnly files of the specified format will be processed. Multiple
X.B \-t
Xoptions may be specified; files of all the specified types will be
Xprocessed. The
X.B \-v
Xoption is ignored. There must not be a space between the "-t" and the
Xformat identifier. The complete list of recognized format identifiers is
Xprinted out in the usage message. Format identifiers are case insensitive.
XAt present, the following format identifiers are recognized:
X.PP
X.RS 10
X.nf
XGIF87a         GIF87a files
XGIF89a         GIF89a files
XGIF            Any GIF file, either GIF87a or GIF89a
XIMG_1          GEM IMG version 1 files
XIMG            Any GEM IMG file
XJFIF101        JPEG File Interchange Format versions
X                  1.00 and 1.01
XJFIF           Any JFIF file
XSUNRAS         Sun raster files
XTARGA          TARGA files
XPBM_NORM       Portable BitMap files, ASCII format
XPBM_RAW        Portable BitMap files, raw format
XPBM            Any Portable BitMap file
XPGM_NORM       Portable GrayMap files, ASCII format
XPGM_RAW        Portable GrayMap files, raw format
XPGM            Any Portable GrayMap file
XPPM_NORM       Portable PixMap files, ASCII format
XPPM_RAW        Portable PixMap files, raw format
XPPM            Any Portable PixMap file
XXBM            X11 BitMap files
XWIN2BMP        MS-Windows 2.x bitmap files
XOS2BMP11       OS/2 1.1-1.3 bitmap files
XWIN3BMP        MS-Windows 3.x bitmap files
XOS2BMP20       OS/2 2.0 bitmap files
XBMP            Any BMP file.
XPCX_25         PCX version 2.5 files.
XPCX_28         PCX version 2.8 files without palettes.
XPCX_28P        PCX version 2.8 files with palettes.
XPCX_30         PCX version 3.0 files.
XPCX            Any PCX file.
X.fi
X.RE
X.TP
X.B \-spattern
XSelects files according to a complicated Boolean search pattern, including
Xsearch on file format, image height, image width, number of colors in the
Ximage, and file size. Only files which meet the specified search criteria
Xare processed. Any
X.B \-t
Xand
X.B \-v
Xoptions are ignored. There must not be a space between the "-s" and the
Xsearch pattern, or within the search pattern. If more than one
X.B \-s
Xoption is specified, only the last one on the command line will have
Xeffect. The search pattern may include the following operator characters:
X.PP
X.RS 10
X.nf
X( )    ( )     parentheses for grouping
X=      =       equal
X>      }       greater than
X<      {       less than
X>=     }=      greater or equal
X<=     {=      less or equal
X&      +       logical AND
X|      ,       logical OR
X.fi
X.RE
X.RS 5
X.PP
XNormally, the operators in the first column should be used.
XIf
X.I chils
Xwas compiled with the DOS_COMSRCH option, then use the operators in the
Xsecond column. Since most of the operators are also shell metacharacters,
Xthe search pattern should be quoted:
X.PP
X.ti+5n
Xchils -s'(W>320)&(H>200)'
X.PP
XThe operator characters work on the following elements:
X.RE
X.PP
X.RS 10
X.nf
XH              image height
XW              image width
XC              image colors
XF              file size
Xdecimal numbers
X.fi
Xformat identifiers as for
X.B \-t
X.RE
X.SH CONFIGURATION
XMany image formats do not include signatures which identify them uniquely.
XThe only way to identify these formats is by filename. Most formats have one
Xor more extensions which are commonly used to identify that format. To
Xaccomodate as wide a variety of naming systems as possible,
X.I chils
Xuses a configuration file which contains lists of formats and extensions
Xwhich identify those formats. Extensions may also be included for those
Xformats which have identification signatures (GIF and SUNRAS), to avoid false
Xrecognition. If extensions for these formats are included, only files with
Xthose extensions will be checked for the signature; otherwise all files
Xwill be checked.
X.PP
XThe configuration file must be named
X.I chils.cfg.
X.I Chils
Xsearches for it first in the current directory. If there is no such file in
Xthe current directory,
X.I chils
Xchecks for the existence of an environment variable
X.I CHIHOME.
XIf it exists, it is assumed to contain the directory in which the
Xconfiguration file resides. Finally,
X.I chils
Xsearches in the directory containing the
X.I chils
Xexecutable. This three-layer system allows local configuration files which
Xoverride the main configuration file, and allows the main configuration
Xfile to be anywhere, not necessarily in the directory with the executable.
XIf the configuration file does not exist, a warning message is issued.
XFormats for which
X.I chils
Xneeds an extension list, but which do not have an entry in the
Xconfiguration file, will not be processed. The default configuration file
Xsupplied with the source code contains entries for all formats which
X.I chils
Xcan process.
X.PP
XBlank lines in
X.I chils.cfg
Xare ignored. Comments begin with '#'. The '#' must be the first
Xnon-whitespace character on the line, but it does not have to be in the
Xfirst column. Both spaces and tabs are recognized as whitespace. Comments
Xare terminated by the end of the line.
X.PP
XEach format entry consists of one line. The syntax of the entry is:
X.PP
X.ti+10n
Xformat_name extension [[,] extension...]
X.PP
XThe format name and extensions are case sensitive. The line may contain
Xleading whitespace before the format name. The format name must be
Xseparated from the first extension by at least one space or tab. There must
Xbe at least one extension on the line. Additional extensions may be
Xseparated by commas and/or whitespace. The entry is terminated by the end
Xof the line. Warnings are generated when
X.I chils
Xencounters an unrecognized format name, an entry with only a format name
X(no extension list), or a zero-length extension (caused by two commas in a
Xrow, for example).
X.PP
XFormat identifiers recognized by CHILS are: GIF, IMG, JFIF, SUNRAS, TARGA,
XPBM, PGM, PPM, XBM, BMP, and PCX.
X.SH OUTPUT
XThe output generated by
X.I chils
Xvaries according to the format of the image, but the meaning of some
Xcolumns is constant.
X.PP
X.nf
X.ti-2n
XGIF87A   -G   110871  381 x  480 @ 64    C~80                    ssb28c.gif
X.ti-2n
XGIF89A   -G-    2657  640 x  480 @ 16    C~1   ASnone          89aillus.gif
X.ti-2n
XGIF89A   -G-   62318  640 x  480 @ 16    C~40  AS49/64           grney5.gif
X.ti-2n
XIMG_1    -     62630  960 x  960 @ 2     C~54  AS 85/85  P1    example1.img
X.ti-2n
XJFIF101  -     18314  264 x  341, 3 @ 8  C~5   AS  1/  1           lat1.jpg
X.ti-2n
XJFIF101  -     44046  976 x  768, 1 @ 8  C~7   AS  1/  1          slf1n.jpg
X.ti-2n
XJFIF101  -     62139  597 x  480, 3 @ 8  C~8    72 x 72 dpi        jol1.jpg
X.ti-2n
XSUNRAS   CV     4435   80 x   50 @ 256   C~90   ML=768          encoded.im8
X.ti-2n
XSUNRAS   C-    32150  871 x  871 @ 2     C~33                  jupiterc.im1
X.ti-2n
XSUNRAS   SV     4800   80 x   50 @ 256   ML=768                standard.sun
X.ti-2n
XSUNRAS   S-     1568   16 x   32, 24 bit                      stndrd24.im24
X.ti-2n
XTARGA    -UM-   4756   80 x   50 @ 246   T1  A0                   type1.tga
X.ti-2n
XTARGA    -UC-   1554   16 x   32, 24 bit T2  A0                   type2.tga
X.ti-2n
XTARGA    -UB-    186   24 x    7 @ 256   T3  A0                   type3.tga
X.ti-2n
XPBM_RAW  R        29   24 x    7 @ 2                           feep-raw.pbm
X.ti-2n
XPGM_RAW  R       180   24 x    7 @ 256   MaxVal = 255          feep-raw.pgm
X.ti-2n
XPPM_RAW  R        59    4 x    4, 24 bit MaxVal = 255          feep-raw.ppm
X.ti-2n
XPBM_NORM N       355   24 x    7 @ 2                               feep.pbm
X.ti-2n
XPGM_NORM N       519   24 x    7 @ 16    MaxVal =  15              feep.pgm
X.ti-2n
XPPM_NORM N       189    4 x    4 @ 4096  MaxVal =  15              feep.ppm
X.ti-2n
XXBM              182   24 x    7 @ 2     'feep'                    feep.xbm
X.ti-2n
XWIN3BMP  --     5078   80 x   50 @ 256                         256color.bmp
X.ti-2n
XWIN3BMP  --      630   32 x   32 @ 16                            argyle.bmp
X.ti-2n
XPCX_30   RC     4715   80 x   50 @ 256   C~114  CX 80,CY 50       color.pcx
X.ti-2n
XPCX_30   RC      191   24 x    7 @ 8     C~100  CX 24,CY  7    feepgray.pcx
X.ti-2n
XPCX_30   RC      152   24 x    7 @ 2     C~114  CX 24,CY  7    feepmono.pcx
X.fi
X.PP
XThe first column is always the format (see the list under the
X.B \-t
Xoption above). The second column, if present, is a group of flags whose
Xmeaning varies according to the image (see below). The third column is the
Xfilesize. Next is the width and the height of the image (or a reasonable
Xapproximation) in pixels, then the number of colors
Xin the image in a format which depends on the image. After that is 
Xmiscellaneous format-dependent information; frequently a compression ratio
Xis given, indicated by "C~". The last column is always the filename. If the
Xfilename is too long to fit on the line, it is put on the line immediately
Xfollowing, right justified.
X.RS 3
X.SS GIF87a
X.PP
X.nf
X 
X.ti-2n
XGIF87A   EG    53882  398 x  548 @ 16    C~49                      bar4.gif
X.ti-2n
XGIF87A   -G   110871  381 x  480 @ 64    C~80                    ssb28c.gif
X.ti-2n
XGIF87A   --    59392  320 x  240 @ ---   C~--                        tt.gif
X.fi
X.PP
XThe GIF87A format has two flags. The first is "E" if extra characters are
Xdetected on the end of the file, or "-" if not. The second is "G" if the
Xfile contains a global color table, or "-" if not. Note that
Xthe "E" flag is only a quick and dirty check for extra characters on the end
Xof the file. If the last character of the file is the GIF Terminator, "-"
Xis displayed; if it is not, "E" is displayed. This check will be
Xfooled if the file contains extra characters which happen to end with the
XGIF Terminator character.
X.I Gifstrip
Xand
X.I gifcheck
Xoffer reliable detection of extra characters (and, in the case of
X.I gifstrip,
Xremoval thereof).
X.PP
XThe width and height displayed are for the logical screen, not the actual
Ximage. Typically the image or images in the file will be the same size as
Xthe logical screen, but this is not required. Unfortunately, it is not
Xpossible to extract the size of the actual image or images without parsing
Xmuch of the file, which is beyond the scope of
X.I chils.
X.PP
XThe number of colors shown is the size of the global color table, or "---"
Xif there is no global color table. Images typically do not use all the colors
Xin the global color table; the number should be regarded as an upper limit on
Xthe colors in the actual image rather than the actual figure.
X.I Gifcheck
Xcan determine the number of unique colors actually used.
X.PP
XThe only format-dependent display is the compression ratio. "--" is
Xdisplayed if no global color table is present, since the calculation relies
Xon the size of that table. The compression ratio 
Xis calculated by multiplying the height by the width, then multiplying that
Xresult by the number of bits required to represent the colors in the image
X(based on the size of the global color table), and dividing by 8 to
Xobtain the number of bytes which the image data would occupy when
Xuncompressed. Finally, the present file size is divided by the
Xcomputed uncompressed size, which yields the size of the compressed image
Xas a percentage of the uncompressed size. Note that the value displayed may
Xbe radically incorrect if the file contains multiple images, if the file
Xcontains extension blocks, if the image uses a local color table, if the
Ximage is smaller than the logical screen size, or if there are very many
Xextra characters on the end of the file.
X.SS GIF89a
X.PP
X.nf
X 
X.ti-2n
XGIF89A   -G-    2657  640 x  480 @ 16    C~1   ASnone          89aillus.gif
X.ti-2n
XGIF89A   -G-   62318  640 x  480 @ 16    C~40  AS49/64           grney5.gif
X.fi
X.PP
XThe GIF89A format has three flags. The first is "E" if extra characters are
Xdetected on the end of the file, or "-" if not. The second is "G" if the
Xfile contains a global color table, or "-" if not. The third is "S" if the
Xglobal color table is sorted in order of decreasing importance, or "-" if
Xnot. Note that the "E" flag is only a quick and dirty check for extra characters
Xon the end of the file. If the last character of the file is the GIF
XTerminator, "-" is displayed; if it is not, "E" is displayed. This check will
Xbe fooled if the file contains extra characters which happen to end with the
XGIF Terminator character.
X.I Gifstrip
Xand
X.I gifcheck
Xoffer reliable detection of extra characters (and, in the case of
X.I gifstrip,
Xremoval thereof).
X.PP
XThe width and height displayed are for the logical screen, not the actual
Ximage. Typically the image or images in the file will be the same size as
Xthe logical screen, but this is not required. Unfortunately, it is not
Xpossible to extract the size of the actual image or images without parsing
Xmuch of the file, which is beyond the scope of
X.I chils.
X.PP
XThe number of colors shown is the size of the global color table, or "---"
Xif there is no global color table. Images typically do not use all the colors
Xin the global color table; the number should be regarded as an upper limit on
Xthe number of colors in the actual image rather than the actual figure.
X.I Gifcheck
Xcan determine the number of unique colors actually used.
X.PP
XFormat-dependent displays for GIF89a are the compression ratio and aspect
Xratio, in that order.
X.PP
XIf no global color table is present, "--" is displayed for the compression
Xratio, since the calculation relies on the size of that table. The compression
Xratio is calculated by multiplying the height by the width, then multiplying
Xthat result by the number of bits required to represent the colors in the image
X(based on the size of the global color table), and dividing by 8 to
Xobtain the number of bytes which the image data would occupy when
Xuncompressed. Finally, the present file size is divided by the
Xcomputed uncompressed size, which yields the size of the compressed image
Xas a percentage of the uncompressed size. Note that the value displayed may
Xbe radically incorrect if the file contains multiple images, if the file
Xcontains extension blocks, if the image uses a local color table, if the
Ximage is smaller than the logical screen size, or if there are very many
Xextra characters on the end of the file.
X.PP
XThe aspect ratio is given in 64ths. If there is no aspect ratio, "none" is
Xdisplayed.
X.SS IMG_1
X.PP
X.nf
X 
X.ti-2n
XIMG_1    -     62630  960 x  960 @ 2     C~54  AS 85/85  P1    example1.img
X.fi
X.PP
XNote that there are many file formats named "IMG", a situation which is
Xconfusing at best.
X.I Chils
Xrecognizes only the GEM IMG format.
X.PP
XThe IMG_1 format has one flag. It is "L" if the IMG header is extended
X(to contain a palette, for example), or "-" if the header is of normal
Xlength.
X.PP
XThe maximum number of colors in the file is calculated from the number of
Xbit planes; the actual number of colors used may be less than the number
Xshown.
X.PP
XFormat-dependent displays for IMG_1 are the compression ratio, aspect ratio,
Xand pattern length, in that order.
X.PP
XThe compression ratio is computed by multiplying the height by the width,
Xthen multiplying that result by the number of bit planes, and dividing by 8
Xto obtain the number of bytes which the image data would occupy when
Xuncompressed. Finally, the present file size minus the header length is
Xdivided by the computed uncompressed size, which yields the size of the
Xcompressed image as a percentage of the uncompressed size. The compression
Xratio is reasonably accurate. Since the header length is known accurately,
Xthat number is subtracted from the filesize to get a more accurate
Xcompressed size. The compression ratio will only be incorrect if there are
Xjunk characters on the end of the file.
X.PP
XThe aspect ratio is always present. The numbers also represent the width and
Xheight, respectively, of a pixel, in microns. 85 microns is approximately
Xequivalent to 300 pixels per inch.
X.PP
XThe pattern length in pixels is used when decompressing the image.
X.SS JFIF1.01
X.PP
X.nf
X 
X.ti-2n
XJFIF101  -     18314  264 x  341, 3 @ 8  C~5   AS  1/  1           lat1.jpg
X.ti-2n
XJFIF101  -     44046  976 x  768, 1 @ 8  C~7   AS  1/  1          slf1n.jpg
X.ti-2n
XJFIF101  -     62139  597 x  480, 3 @ 8  C~8    72 x 72 dpi        jol1.jpg
X.fi
X.PP
XThe JFIF 1.0 and 1.01 formats differ minimally;
X.I chils
Xtreats them as identical.
X.PP
XThe JFIF101 format has one flag. It is "T" if a thumbnail image is present
Xin the file, or "-" if not.
X.PP
XThe number of colors is expressed as the number of "components" (usually 3
Xor 1) by the number of bits per component (usually 8). Images with three
Xcomponents are full-color, while images with one are, by convention,
Xgrayscale.
X.PP
XFormat-dependent displays for JFIF101 are the compression ratio and aspect
Xratio or pixel density, in that order.
X.PP
XThe compression ratio is computed by multiplying the height by the width,
Xthen multiplying that result by the number of components times the bits per
Xcomponent, and dividing by 8 to obtain the number of bytes which the image
Xdata would occupy when uncompressed. Finally, the present file size is
Xdivided by the computed uncompressed size, which yields the size of the
Xcompressed image as a percentage of the uncompressed size. Note that the image
Xitself is actually compressed even more than shown, since the present file
Xsize includes all the headers and other, non-image information present in the
Xfile.
X.PP
XJFIF101 files contain either an aspect ratio or a pixel density. If an
Xaspect ratio is present, it is expressed as a fraction. If pixel density is
Xpresent instead, it is displayed as the horizontal density by the vertical
Xdensity followed by the units, which are either "dpi" (pixels/dots per
Xinch) or "dpcm" (pixels/dots per centimeter).
X.SS SUNRAS
X.PP
X.nf
X 
X.ti-2n
XSUNRAS   CV     4435   80 x   50 @ 256   C~90   ML=768          encoded.im8
X.ti-2n
XSUNRAS   C-    32150  871 x  871 @ 2     C~33                  jupiterc.im1
X.ti-2n
XSUNRAS   SV     4800   80 x   50 @ 256   ML=768                standard.sun
X.ti-2n
XSUNRAS   S-     1568   16 x   32, 24 bit                      stndrd24.im24
X.fi
X.PP
XSun Raster files are a format developed by Sun Microsystems for use on
Xtheir workstations.
X.PP
XThe SUNRAS format has two flags. The first is "O" for 'old' format files
X(left over from ancient versions of SunOS), "S" for standard files, "C"
Xfor compressed files, "R" for 24-bit files with reversed color-component
Xorder, "T" for "tiff <-> standard rasterfile" (don't ask me), "I" for "iff
X(TAAC format) <-> standard rasterfile" (again, don't ask me), and "E" 
Xfor 'experimental' formats. The second flag is "-" if the file does not have a
Xcolormap, "V" if the colormap is in 'vector' format (all red components
Xgrouped together, all green components grouped together in the same order,
Xetc.), or "R" if the colormap is in 'raw' format (usually RGB triples).
X.PP
XThe number of colors is expressed either as a number or as the number of
Xbits per pixel, depending on which fits in the available space. In the case
Xof a plain number, not all colors may be used; the number should be regarded
Xas an upper limit on the number of colors in the actual image rather than
Xthe actual figure.
X.PP
XFormat-dependent displays for SUNRAS are the compression ratio (if a
Xcompressed format) and the length of the colormap in bytes (if a colormap
Xis present), in that order.
X.PP
XThe compression ratio is computed by multiplying the height by the width,
Xthen multiplying that result by the number of bits per pixel, and dividing by
X8 to obtain the number of bytes which the image data would occupy when
Xuncompressed. Finally, the size of the compressed data (maintained in the
Xfile header) is divided by the computed uncompressed size, which yields the
Xsize of the compressed image as a percentage of the uncompressed size. The
Xcompression ratio is accurate unless the file is corrupted.
X.PP
XIf a colormap is present, the length in bytes is displayed as "ML=nnn".
X.SS TARGA
X.PP
X.nf
X 
X.ti-2n
XTARGA    -UM-   4756   80 x   50 @ 246   T1  A0                   type1.tga
X.ti-2n
XTARGA    -UC-   1554   16 x   32, 24 bit T2  A0                   type2.tga
X.ti-2n
XTARGA    -UB-    186   24 x    7 @ 256   T3  A0                   type3.tga
X.fi
X.PP
XThe Targa format was developed by AT&T in conjunction with their TrueVision
Xgraphics hardware.
X.PP
XThe TARGA format has four flags. The first is "-" if the file contains an
Ximage or "N" if not. The second is "-" for no image, "U" for an
Xuncompressed image, "R" for a runlength-encoded image, or "C" for an
XLZW-compressed image. The third is "-" for no image, "M" for a colormapped
Ximage, "B" for a grayscale image, or "C" for a full-color image. The fourth
Xflag indicates the scan-line interleave of the image: "-" for
Xnoninterleaved, "2" or "4" for two- or four-way interleaving, or "R" for a
Xreserved value.
X.PP
XThe number of colors is expressed either as a number or as the number of
Xbits per pixel. If the image is colormapped, the length of the colormap is
Xdisplayed. If the image is not colormapped (either grayscale or
Xfull-color), either a number or the number of bits is displayed depending
Xon which fits in the available space. In the case of a plain number, not
Xall colors may be used; the number should be regarded as an upper limit on
Xthe number of colors in the actual image rather than the actual figure.
X.PP
XFormat-dependent displays for TARGA are the compression ratio (if a
Xrunlength-encoded or LZW-compressed format), the format type "Tn", the number
Xof attribute bits per pixel "An", "M" if an unnecessary colormap is
Xincluded in the file, and "I" if the file has an ID field.
X.PP
XThe compression ratio is computed by multiplying the height by the width,
Xthen multiplying that result by the number of bits per pixel, and dividing
Xby 8 to obtain the number of bytes which the image data would occupy when
Xuncompressed. Finally, the present file size minus the header, ID field,
Xand colormap lengths is divided by the computed uncompressed size, which
Xyields the size of the compressed image as a percentage of the
Xuncompressed size. The compression ratio should be accurate unless the file
Xis corrupted or there are junk characters on the end of the file.
X.SS PBM, PGM, PPM, PBM_RAW, PGM_RAW, PPM_RAW
X.PP
X.nf
X 
X.ti-2n
XPBM_RAW  R        29   24 x    7 @ 2                           feep-raw.pbm
X.ti-2n
XPGM_RAW  R       180   24 x    7 @ 256   MaxVal = 255          feep-raw.pgm
X.ti-2n
XPPM_RAW  R        59    4 x    4, 24 bit MaxVal = 255          feep-raw.ppm
X.ti-2n
XPBM_NORM N       355   24 x    7 @ 2                               feep.pbm
X.ti-2n
XPGM_NORM N       519   24 x    7 @ 16    MaxVal =  15              feep.pgm
X.ti-2n
XPPM_NORM N       189    4 x    4 @ 4096  MaxVal =  15              feep.ppm
X.fi
X.PP
XThese formats were developed by Jef Poskanzer for his Portable Bitmap
X(later Portable Bitmap Plus) package. The formats were designed to be
Xeasily transferable between machines and easily usable on widely differing
Xmachines. There are three basic types, PBM (Portable BitMap, black and
Xwhite only), PGM (Portable GrayMap, grayscale), and PPM (Portable PixMap,
Xfull-color), each of which comes in two varieties, normal (all data is
Xrepresented as ASCII text) and raw (the image data is stored as
Xpacked bytes.)
X.I Chils
Xhandles all six permutations.
X.PP
XThese formats have only one flag, which is "R" for a raw file and "N" for a
Xnormal file, and is redundant.
X.PP
XThe number of colors is expressed either as a number or as the number of
Xbits per pixel. For PBM and PGM images, it is always a number (always 2 for
XPBM). For PPM images, it is either a number or the number of bits depending
Xon which fits in the available space. In the case of a plain number, not
Xall colors may be used; the number should be regarded as an upper limit on
Xthe number of colors in the actual image rather than the actual figure.
X.PP
XThere are no format-dependent displays for PBM; PGM and PPM display the
Xmaximum value that a pixel may take (usually a power of 2 minus 1).
X.SS XBM
X.PP
X.nf
X 
X.ti-2n
XXBM              182   24 x    7 @ 2     'feep'                    feep.xbm
X.fi
X.PP
XThe XBM (X BitMap) format is used by the X Window system developed at MIT.
XThe format is designed for easy incorporation into C-language programs and
Xall data is represented as ASCII text.
X.PP
XThe XBM format has no flags.
X.PP
XThe number of colors is always 2, black and white.
X.PP
XFormat-dependent displays for XBM are the name of the image, which is
Xencoded into the file.
X.SS WIN2BMP
X.PP
X.nf
X 
X.ti-2n
XWIN2BMP  -       630   32 x   32 @ 16                              argh.bmp
X.fi
X.PP
XThe WIN2BMP format is an obsolete format used by MS-Windows 2.x.
X.PP
XThe WIN2BMP format has one flag, which is "D" if the bitmap resource is
Xdiscardable or "-" if it is not.
X.PP
XThe number of colors is expressed either as a number or as the number of
Xbits per pixel, depending on which fits in the available space. In the case
Xof a plain number, not all colors may be used; the number should be regarded
Xas an upper limit on the number of colors in the actual image rather than the
Xactual figure.
X.PP
XThere are no format-dependent displays for WIN2BMP.
X.SS OS2BMP11
X.PP
X.nf
X 
X.ti-2n
XOS2BMP11 -      5078   80 x   50 @ 256                         256color.bmp
X.fi
X.PP
XThe OS2BMP11 format is used by OS/2 1.1-1.3. The WIN3BMP and OS2BMP20
Xformats are loosely based on it.
X.PP
XThe OS2BMP11 format has one flag, which is "E" if the file size in the
Xheader does not match the present file size or "-" if it does.
X.PP
XThe number of colors is expressed either as a number or as the number of
Xbits per pixel, depending on which fits in the available space. In the case
Xof a plain number, not all colors may be used; the number should be regarded
Xas an upper limit on the number of colors in the actual image rather than the
Xactual figure.
X.PP
XThere are no format-dependent displays for OS2BMP11.
X.SS WIN3BMP
X.PP
X.nf
X 
X.ti-2n
XWIN3BMP  --     5078   80 x   50 @ 256                         256color.bmp
X.ti-2n
XWIN3BMP  --      630   32 x   32 @ 16                            argyle.bmp
X.fi
X.PP
XThe WIN3BMP format is used by MS-Windows 3.x. It is loosely based on the
XOS2BMP11 format and the OS2BMP20 format is based on it.
X.PP
XThe WIN3BMP format has two flags. The first one is "E" if the file size in
Xthe header does not match the present file size or "-" if it does. The
Xsecond one is "-" for an uncompressed file, "4" if 4-bit run-length
Xcompression is used, or "8" if 8-bit run-length compression is used.
X.PP
XThe number of colors is expressed either as a number or as the number of
Xbits per pixel, depending on which fits in the available space. In the case
Xof a plain number, not all colors may be used; the number should be regarded
Xas an upper limit on the number of colors in the actual image rather than the
Xactual figure.
X.PP
XFormat-dependent displays for WIN3BMP are the compression ratio (for
Xcompressed files), the horizontal and vertical resolution (if present) and
Xthe number of important colors (if present and different from the number of
Xcolors in the colormap) "Innn".
X.PP
XThe compression ratio is computed by multiplying the height by the width,
Xthen multiplying that result by the number of bits per pixel, and dividing
Xby 8 to obtain the number of bytes which the image data would occupy when
Xuncompressed. Finally, the size of the compressed data (maintained in the
Xfile header) is divided by the computed uncompressed size, which
Xyields the size of the compressed image as a percentage of the
Xuncompressed size. The compression ratio is accurate unless the file is
Xcorrupted.
X.PP
XThe horizontal and vertical resolution are in pixels per meter, displayed
Xas "Xnnn,Ynnn".
X.SS OS2BMP20
X.PP
X.nf
X 
X.ti-2n
XOS2BMP20 --R-   5078   80 x   50 @ 256                         256color.bmp
X.fi
X.PP
XThe OS2BMP20 format is used by OS/2 2.0. It is an extension of the WIN3BMP
Xformat.
X.PP
XThe OS2BMP20 format has four flags. The first one is "E" if the file size
Xin the header does not match the present file size or "-" if it does. The
Xsecond one is "-" for an uncompressed file or "C" for a compressed file.
XThe third one relates to the colormap format and should always be "R". The
Xfourth one is "H" if a halftoning algorithm is specified, "-" otherwise.
X.PP
XThe number of colors is expressed either as a number or as the number of
Xbits per pixel, depending on which fits in the available space. In the case
Xof a plain number, not all colors may be used; the number should be regarded
Xas an upper limit on the number of colors in the actual image rather than the
Xactual figure.
X.PP
XFormat-dependent displays for OS2BMP20 are the compression ratio (for
Xcompressed files), the horizontal and vertical resolution (if present) and
Xthe number of important colors (if present and different from the number of
Xcolors in the colormap) "Innn".
X.PP
XThe compression ratio is computed by multiplying the height by the width,
Xthen multiplying that result by the number of bits per pixel, and dividing
Xby 8 to obtain the number of bytes which the image data would occupy when
Xuncompressed. Finally, the size of the compressed data (maintained in the
Xfile header) is divided by the computed uncompressed size, which
Xyields the size of the compressed image as a percentage of the
Xuncompressed size. The compression ratio is accurate unless the file is
Xcorrupted.
X.PP
XThe horizontal and vertical resolution are displayed as "Xnnn,Ynnn dp?",
Xwhere '?' should always be 'm' (for dots per meter).
X.SS PCX
X.PP
X.nf
X 
X.ti-2n
XPCX_30   RC     4715   80 x   50 @ 256   C~114  CX 80,CY 50       color.pcx
X.ti-2n
XPCX_30   RC      191   24 x    7 @ 8     C~100  CX 24,CY  7    feepgray.pcx
X.ti-2n
XPCX_30   RC      152   24 x    7 @ 2     C~114  CX 24,CY  7    feepmono.pcx
X.fi
X.PP
XThe PCX format was created by the ZSoft Corporation.
X.I Chils
Xrecognizes PCX_25 (version 2.5), PCX_28 (version 2.8 without palette),
XPCX_28P (version 2.8 with palette), and PCX_30 (version 3.0).
X.PP
XThe PCX format has two flags. The first one should always be "R",
Xindicating that the file is run-length encoded. The second one is "G" if
Xthe palette should be interpreted as grayscale or "C" if it should be
Xinterpreted as color.
X.PP
XThe number of colors is expressed either as a number or as the number of
Xbits per pixel, depending on which fits in the available space. In the case
Xof a plain number, not all colors may be used; the number should be regarded
Xas an upper limit on the number of colors in the actual image rather than the
Xactual figure.
X.PP
XFormat-dependent displays for PCX are the compression ratio and the
Xhorizontal and vertical resolution of the file creator, in that order.
X.PP
XThe compression ratio is computed by multiplying the height by the width,
Xthen multiplying that result by the number of bits per pixel, and dividing
Xby 8 to obtain the number of bytes which the image data would occupy when
Xuncompressed. Finally, the present file size minus the length of the PCX
Xheader is divided by the computed uncompressed size, which 
Xyields the size of the compressed image as a percentage of the
Xuncompressed size. The compression ratio should be accurate unless the file 
Xhas extra characters (such as a 256-color palette) on the end.
X.PP
XThe horizontal and vertical resolution are displayed as "CXnnn,CYnnn".
XUnfortunately, it is not clear what these values mean.
X.RE
X.SH COPYRIGHT
X.I Chils
Xis copyright 1993 by James W. Birdsall, all rights reserved.
X.PP
XThe Graphics Interchange Format(c) is the Copyright property of CompuServe
XIncorporated. GIF(sm) is a Service Mark property of CompuServe
XIncorporated.
X.PP
XSunOS is a trademark of Sun Microsystems Inc.
X.PP
XTarga and TrueVision are probably trademarks of AT&T.
X.PP
XMS-Windows is probably a trademark of Microsoft.
X.PP
XOS/2 is a registered trademark of IBM.
X.PP
XOther terms in this document may be trademarks or service marks of or
Xcopyright by various corporations and organizations.
X.SH AUTHOR
XJames W. Birdsall
X.RS 3
X.nf
Xsupport@picarefy.com
Xuunet!uw-coco!amc-gw!picarefy!support
XCompuServe: 71261,1731
XGEnie: J.BIRDSALL2
X.fi
X.RE
X.SH FILES
Xchils.cfg         Configuration file
X.SH "SEE ALSO"
Xgifstrip(1),
Xgifcheck(1)
END_OF_FILE
  if test 34361 -ne `wc -c <'src/chils.1'`; then
    echo shar: \"'src/chils.1'\" unpacked with wrong size!
  fi
  # end of 'src/chils.1'
fi
if test -f 'src/jfif.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/jfif.h'\"
else
  echo shar: Extracting \"'src/jfif.h'\" \(3868 characters\)
  sed "s/^X//" >'src/jfif.h' <<'END_OF_FILE'
X/***************************************************************************
X*   JFIF.H                                                                 *
X*   HEADER FOR JFIF                                                        *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   $Id: jfif.h,v 1.4 1993/02/10 01:38:45 jwbirdsa Exp $
X*                                                                          *
X*   This file specifies the external interface to the JFIF module.         *
X*                                                                          *
X***************************************************************************/
X
X#ifndef DEPEND_H
X    **** ERROR **** DEPEND.H MUST BE INCLUDED BEFORE JFIF.H
X#endif
X#ifndef FB_H
X    **** ERROR **** FB.H MUST BE INCLUDED BEFORE JFIF.H
X#endif
X
X#ifndef JFIF_H
X
X#define JFIF_H
X
X/*
X** system includes <>
X*/
X
X/*
X** custom includes ""
X*/
X
X#include "status.h"
X
X
X/*
X** local #defines
X*/
X
X/* Version defines. */
X
X#define JFIF_NOT                FORMAT_NOT
X#define JFIF_VER101             (FORMAT_JFIF | MKLONG(1))
X
X/* Block types. */
X
X#define JFIF_SOI                0xD8
X#define JFIF_APP0               0xE0
X#define JFIF_SOF0               0xC0
X#define JFIF_EOI                0xD9
X
X#define JFIF_SEPARATOR          0xFF
X
X/* Offsets in APP0. */
X
X#define JFIF_APP0_LENGTH_OFF    0
X#define JFIF_APP0_SIGNATURE_OFF 2
X#define JFIF_APP0_VERS_OFF      7
X#define JFIF_APP0_DENSUNIT_OFF  9
X#define JFIF_APP0_XDENS_OFF     10
X#define JFIF_APP0_YDENS_OFF     12
X#define JFIF_APP0_XTHUMB_OFF    14
X#define JFIF_APP0_YTHUMB_OFF    15
X#define JFIF_APP0_THUMB_OFF     16
X
X#define JFIF_APP0_LEN           16
X
X/* Offsets in SOF0. */
X
X#define JFIF_SOF0_LENGTH_OFF    0
X#define JFIF_SOF0_PREC_OFF      2
X#define JFIF_SOF0_HI_OFF        3
X#define JFIF_SOF0_WID_OFF       5
X#define JFIF_SOF0_COMP_OFF      7
X#define JFIF_SOF0_STUFF_OFF     8
X
X#define JFIF_SOF0_LEN           8
X
X/* Offsets in misc block. */
X
X#define JFIF_GENERIC_LENGTH_OFF 0
X
X#define JFIF_GENERIC_LEN        2
X
X/* JFIF signature info. */
X
X#define JFIF_SIGNATURE          "JFIF"
X#define JFIF_SIGNATURE_LEN      5
X
X/* JFIF pixel density units types. */
X
X#define JFIF_DENS_ASPECT        0
X#define JFIF_DENS_DPI           1
X#define JFIF_DENS_DPCM          2
X
X/* Error/status defines. */
X
X#define JFIF_NOTJFIF_E          MKERR(1, JFIF_MODULE, ST_ERROR)
X#define JFIF_FILEERR_E          MKERR(2, JFIF_MODULE, ST_ERROR)
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST RCSjfif[] = "$Id: jfif.h,v 1.4 1993/02/10 01:38:45 jwbirdsa Exp $";
X
X
X/*
X** typedefs
X*/
X
Xtypedef struct {
X    ULONG version;              /* the JFIF format version */
X    int components;             /* color components (1=grayscale, 3=color) */
X    int bits;                   /* bits per sample */
X    unsigned int height;        /* image height, pixels */
X    unsigned int width;         /* image width, pixels */
X    int densunit;               /* density unit (see above for meanings) */
X    unsigned int xdens;         /* horizontal pixel density */
X    unsigned int ydens;         /* vertical pixel density */
X    int xthumb;                 /* thumbnail image width, pixels (0 if none) */
X    int ythumb;                 /* thumbnail image height, pixels (0 if none) */
X} JFIF_HDR;
X
X
X/*
X** global variables
X*/
X
X/*
X** function prototypes
X*/
X
X#ifdef  __STDC__
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
XULONG jfif_verify P_((char *filename, ULONG *version, char **exts));
X
XULONG jfif_headerget P_((FB *infile, JFIF_HDR *results));
X
Xchar *jfif_errstring P_((ULONG errcode));
X
X#undef P_
X
X#endif /* JFIF_H */
X
END_OF_FILE
  if test 3868 -ne `wc -c <'src/jfif.h'`; then
    echo shar: \"'src/jfif.h'\" unpacked with wrong size!
  fi
  # end of 'src/jfif.h'
fi
if test -f 'src/pgmppm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/pgmppm.c'\"
else
  echo shar: Extracting \"'src/pgmppm.c'\" \(14335 characters\)
  sed "s/^X//" >'src/pgmppm.c' <<'END_OF_FILE'
X/***************************************************************************
X*   PGMPPM.C                                                               *
X*   PNM_MODULE:  PNM                                                           *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   $Id: pgmppm.c,v 1.1 1993/03/02 00:58:33 jwbirdsa Exp $
X*                                                                          *
X*   This file contains functions to process PGM or PPM format files.       *
X*   Functions:                                                             *
X*      p?m_verify    - checks filename to see if it is an PGM file         *
X*      p?m_getheader - extracts header data from PGM file                  *
X*                                                                          *
X*      p?m_errstring - converts error code into message                    *
X*                                                                          *
X***************************************************************************/
X
X#include "config.h"
X
X/*
X** system includes <>
X*/
X
X#include <stdio.h>
X#ifndef NO_STDLIB
X#include <stdlib.h>
X#endif
X#ifndef NO_STR_INC
X#ifdef STRING_PLURAL
X#include <strings.h>
X#else
X#include <string.h>
X#endif
X#endif
X
X
X/*
X** custom includes ""
X*/
X
X#include "depend.h"
X#include "formats.h"
X#include "token.h"
X#include "pnm.h"
X
X
X/*
X** local #defines
X*/
X
X#ifdef PGM
X#define VERIFY              pgm_verify
X#define GETHEADER           pgm_getheader
X#define ERRSTRING           pgm_errstring
X
X#define FILEERR_E           PGM_FILEERR_E
X#define UNEOF_E             PGM_UNEOF_E
X#define NOT_E               PGM_NOTPGM_E
X
X#define MAGIC_NORM          PGM_MAGIC_NORM
X#define MAGIC_RAW           PGM_MAGIC_RAW
X
X#define NORM                PGM_NORM
X#define RAW                 PGM_RAW
X
X#define PNM_MODULE          PGM_MODULE
X#else
X#define VERIFY              ppm_verify
X#define GETHEADER           ppm_getheader
X#define ERRSTRING           ppm_errstring
X
X#define FILEERR_E           PPM_FILEERR_E
X#define UNEOF_E             PGM_UNEOF_E
X#define NOT_E               PGM_NOTPGM_E
X
X#define MAGIC_NORM          PPM_MAGIC_NORM
X#define MAGIC_RAW           PPM_MAGIC_RAW
X
X#define NORM                PPM_NORM
X#define RAW                 PPM_RAW
X
X#define PNM_MODULE          PPM_MODULE
X#endif /* PGM */
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
X/*
X** typedefs
X*/
X
X/*
X** global variables
X*/
X
X/*
X** static globals
X*/
X
Xstatic char CONST rcsid[] = "$Id: pgmppm.c,v 1.1 1993/03/02 00:58:33 jwbirdsa Exp $";
X
X
X/*
X** function prototypes
X*/
X
X#ifdef NO_STDLIB
Xextern int atoi();
Xextern long atol();
X#endif
X
X#ifdef NO_STR_INC
Xextern char *strrchr();
Xextern int strcmp();
X#endif
X
X
X/*
X** functions
X*/
X
X
X/***************************************************************************
X*   FUNCTION:    p?m_verify                                                *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Verifies that a file is an PGM/PPM file by checking filename       *
X*       against list of extensions. Reads magic number from start of       *
X*       file.                                                              *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       filename - name of file to be verified                             *
X*       version  - pointer to unsigned long in which format/version value  *
X*                  is returned                                             *
X*       exts     - array of string pointers, list of extensions for files  *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns an error/status code.                                      *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XULONG
X#ifdef __STDC__
XVERIFY(char *filename, ULONG *version, char **exts)
X#else
XVERIFY(filename, version, exts)
Xchar *filename;
XULONG *version;
Xchar **exts;
X#endif
X{
X    char *extptr;
X    int loop;
X    FILE *pnmfile;
X    int magic;
X    ULONG retval;
X
X    /* Search for '.' marking extension. */
X
X    extptr = strrchr(filename, '.');
X    if (NULL == extptr)
X    {
X        /* No extension, cannot classify. */
X
X        *version = FORMAT_NOT;
X        return 0;
X    }
X    extptr++;
X
X    /* Now we have the extension, check against list. */
X
X    for (loop = 0; exts[loop] != NULL; loop++)
X    {
X        /* Case-sensitive string compare. */
X
X        if (strcmp(extptr, exts[loop]) == 0)
X        {
X            /* Match, so break out of loop. */
X
X            break;
X        }
X    }
X
X    /* Check exit from loop. */
X
X    if (NULL == exts[loop])
X    {
X        /* No match, return. */
X
X        *version = FORMAT_NOT;
X        return 0;
X    }
X
X    /* Extension is valid for type, so process accordingly. */
X
X    if ((pnmfile = fopen(filename, FOPEN_READ_BINARY)) == (FILE *) NULL)
X    {
X        return FILEERR_E;
X    }
X
X    /* Read magic number, first character. */
X
X    if ((magic = fgetc(pnmfile)) == EOF)
X    {
X        *version = FORMAT_NOT;
X        retval = (feof(pnmfile) ? ST_SUCCESS : FILEERR_E);
X        fclose(pnmfile);
X        return retval;
X    }
X    if (magic != PNM_MAGIC)
X    {
X        *version = FORMAT_NOT;
X        fclose(pnmfile);
X        return ST_SUCCESS;
X    }
X
X    /* Read magic number, second character. */
X
X    if ((magic = fgetc(pnmfile)) == EOF)
X    {
X        *version = FORMAT_NOT;
X        retval = (feof(pnmfile) ? ST_SUCCESS : FILEERR_E);
X        fclose(pnmfile);
X        return retval;
X    }
X    if ((magic != MAGIC_NORM) && (magic != MAGIC_RAW))
X    {
X        *version = FORMAT_NOT;
X        fclose(pnmfile);
X        return ST_SUCCESS;
X    }
X
X    /* Set version according to second character of magic number. */
X
X    *version = ((MAGIC_NORM == magic) ? NORM : RAW);
X
X    /* Close file. */
X
X    if (fclose(pnmfile))
X    {
X        return FILEERR_E;
X    }
X
X    /* Return OK. */
X
X    return 0;
X} /* end of p?m_verify() */
X
X
X/***************************************************************************
X*   FUNCTION:    p?m_getheader                                             *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Assumes that file is an PGM/PPM file. Reads header from file,      *
X*       extracts data into PNM_HDR structure.                              *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       infile  - file to be processed                                     *
X*       results - pointer to PNM_HDR structure in which data from header   *
X*                 is returned                                              *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns an error/status code.                                      *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X*       Leaves file pointing to beginning of image data.                   *
X*                                                                          *
X***************************************************************************/
XULONG
X#ifdef __STDC__
XGETHEADER(FILE *infile, PNM_HDR *results)
X#else
XGETHEADER(infile, results)
XFILE *infile;
XPNM_HDR *results;
X#endif
X{
X    char *token;
X    ULONG status;
X
X    /* Make sure we're at beginning of file. */
X
X    if (fseek(infile, 0L, SEEK_SET))
X    {
X        return FILEERR_E;
X    }
X
X    /* Get first token, should be magic number. */
X
X    if ((token = fm_token(infile)) == NULL)
X    {
X        return FILEERR_E;
X    }
X    if ((token[0] != PNM_MAGIC) ||
X        ((token[1] != MAGIC_NORM) && (token[1] != MAGIC_RAW)))
X    {
X        return NOT_E;
X    }
X    results->version = ((MAGIC_NORM == token[1]) ? NORM : RAW);
X    free(token);
X
X    /* Search for next token that is not a comment. */
X
X    if ((token = fm_token(infile)) == NULL)
X    {
X        return FILEERR_E;
X    }
X    while ('#' == token[0])
X    {
X        free(token);
X        if ((status = fm_eol(infile)) != ST_SUCCESS)
X        {
X            return ((FM_EOF_W == status) ? UNEOF_E : FILEERR_E);
X        }
X        if ((token = fm_token(infile)) == NULL)
X        {
X            return FILEERR_E;
X        }
X    }
X
X    /* Got a token that is not a comment. Should be width of image. */
X
X    if ((results->imwid = (ULONG) atol(token)) == 0L)
X    {
X        /* Something is wrong. Shouldn't be zero width. */
X
X        free(token);
X        results->version = FORMAT_NOT;
X        return NOT_E;
X    }
X    free(token);
X
X    /* Search for next token that is not a comment. */
X
X    if ((token = fm_token(infile)) == NULL)
X    {
X        return FILEERR_E;
X    }
X    while ('#' == token[0])
X    {
X        free(token);
X        if ((status = fm_eol(infile)) != ST_SUCCESS)
X        {
X            return ((FM_EOF_W == status) ? UNEOF_E : FILEERR_E);
X        }
X        if ((token = fm_token(infile)) == NULL)
X        {
X            return FILEERR_E;
X        }
X    }
X
X    /* Got a token that is not a comment. Should be height of image. */
X
X    if ((results->imhi = (ULONG) atol(token)) == 0L)
X    {
X        /* Something is wrong. Shouldn't be zero height. */
X
X        free(token);
X        results->version = FORMAT_NOT;
X        return NOT_E;
X    }
X    free(token);
X
X    /* Search for next token that is not a comment. */
X
X    if ((token = fm_token(infile)) == NULL)
X    {
X        return FILEERR_E;
X    }
X    while ('#' == token[0])
X    {
X        free(token);
X        if ((status = fm_eol(infile)) != ST_SUCCESS)
X        {
X            return ((FM_EOF_W == status) ? UNEOF_E : FILEERR_E);
X        }
X        if ((token = fm_token(infile)) == NULL)
X        {
X            return FILEERR_E;
X        }
X    }
X
X    /* Got a token that is not a comment. Should be max pixval. */
X
X    if ((results->maxpix = atoi(token)) == 0)
X    {
X        /* Something is wrong. Shouldn't be zero max. */
X
X        free(token);
X        results->version = FORMAT_NOT;
X        return NOT_E;
X    }
X    free(token);
X
X    /*
X    ** Set file to point to start of data. Search for next token that 
X    ** is not a comment. 
X    */
X
X    if ((token = fm_token(infile)) == NULL)
X    {
X        return FILEERR_E;
X    }
X    while ('#' == token[0])
X    {
X        free(token);
X        if ((status = fm_eol(infile)) != ST_SUCCESS)
X        {
X            return ((FM_EOF_W == status) ? UNEOF_E : FILEERR_E);
X        }
X        if ((token = fm_token(infile)) == NULL)
X        {
X            return FILEERR_E;
X        }
X    }
X    free(token);
X
X    /* Return OK. */
X
X    return 0;
X} /* end of p?m_getheader() */
X
X
X/***************************************************************************
X*   FUNCTION: p?m_errstring                                                *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*      Returns a string corresponding to an error code.                    *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*      errcode - error code to be translated                               *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*      Returns a pointer to the appropriate string, or NULL if there is    *
X*      no appropriate string.                                              *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xchar *
X#ifdef __STDC__
XERRSTRING(ULONG errcode)
X#else
XERRSTRING(errcode)
XULONG errcode;
X#endif
X{
X    char *temp;
X
X    /* If error code not from this module, return NULL. */
X
X    if ((errcode & ST_MOD_MASK) != PNM_MODULE)
X    {
X        return NULL;
X    }
X
X    /* Process by code. */
X
X    switch (ERRSEV(errcode))
X    {
X        case ERRSEV(NOT_E):
X#ifdef PGM
X            temp = "File is not a PGM format file.";
X#else
X            temp = "File is not a PPM format file.";
X#endif
X            break;
X        case ERRSEV(FILEERR_E):
X            temp = "Error accessing file.";
X            break;
X        case ERRSEV(UNEOF_E):
X            temp = "Unexpected End of File";
X            break;
X
X        default:
X            temp = NULL;
X            break;
X    }
X
X    return temp;
X} /* end of p?m_errstring() */
X
END_OF_FILE
  if test 14335 -ne `wc -c <'src/pgmppm.c'`; then
    echo shar: \"'src/pgmppm.c'\" unpacked with wrong size!
  fi
  # end of 'src/pgmppm.c'
fi
echo shar: End of archive 10 \(of 18\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
