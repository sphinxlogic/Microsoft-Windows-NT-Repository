Newsgroups: comp.sources.misc
From: jwbirdsa@picarefy.picarefy.com (James W. Birdsall)
Subject: v36i075:  chiaro - Image Utilities, Part05/18
Message-ID: <1993Mar25.181037.20162@sparky.imd.sterling.com>
X-Md4-Signature: 96fc77e15ddb98dc61a691b8ad54cb79
Date: Thu, 25 Mar 1993 18:10:37 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jwbirdsa@picarefy.picarefy.com (James W. Birdsall)
Posting-number: Volume 36, Issue 75
Archive-name: chiaro/part05
Environment: UNIX, Sun, DECstation, 3B1

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  src/chils.c src/sr.c
# Wrapped by kent@sparky on Thu Mar 25 11:20:03 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 5 (of 18)."'
if test -f 'src/chils.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/chils.c'\"
else
  echo shar: Extracting \"'src/chils.c'\" \(41782 characters\)
  sed "s/^X//" >'src/chils.c' <<'END_OF_FILE'
X/***************************************************************************
X*   CHILS.C                                                                *
X*   MODULE:  -                                                             *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   The Graphics Interchange Format(c) is the Copyright property of        *
X*   CompuServe Incorporated. GIF(sm) is a Service Mark property of         *
X*   CompuServe Incorporated.                                               *
X*                                                                          *
X*   $Id: chils.c,v 1.18 1993/03/18 23:01:27 jwbirdsa Exp $
X*                                                                          *
X*   Chiaro suite LS program.                                               *
X*                                                                          *
X***************************************************************************/
X
X#include "config.h"
X
X/*
X** system includes <>
X*/
X
X#include <stdio.h>
X#include <ctype.h>
X#ifndef NO_STDLIB
X#include <stdlib.h>
X#endif
X#ifndef NO_MEMOP
X#include <memory.h>
X#endif
X#ifndef NO_MALLOCHDR
X#include <malloc.h>
X#endif
X#ifndef NO_STR_INC
X#ifdef STRING_PLURAL
X#include <strings.h>
X#else
X#include <string.h>
X#endif
X#endif
X
X
X/*
X** custom includes ""
X*/
X
X#include "depend.h"
X
X#include "chils.h"
X
X#include "fb.h"
X
X#include "formats.h"
X#include "gif.h"
X#include "img.h"
X#include "jfif.h"
X#include "sr.h"
X#include "tga.h"
X#include "pnm.h"
X#include "xbm.h"
X#include "bmp.h"
X#include "pcx.h"
X
X#include "comsrch.h"
X
X#include "patchlevel.h"
X
X
X/*
X** local #defines
X*/
X
X#define CFG_NAME    "chils.cfg"   /* CHILS configuration file name. */
X#define ENVVAR_NAME "CHIHOME"     /* CHILS environment variable name. */
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST copyright[] = "Copyright (c) 1993 James W. Birdsall. All Rights Reserved";
Xstatic char CONST rcsid[] = "$Id: chils.c,v 1.18 1993/03/18 23:01:27 jwbirdsa Exp $";
X
X#define VERS        "1.0"
X
X
X/*
X** typedefs
X*/
X
X/*
X** global variables
X*/
X
Xint flags = NAMETRUNC;            /* Global function flags. */
Xflist *formatlist = NULL;         /* Check for specific formats. */
Xchar *searchstr = NULL;           /* Complex search string. */
Xchar scratch[80];                 /* Global scratchpad. */
X
X
X/*
X** function prototypes
X*/
X
X#ifdef  __STDC__
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
Xstatic VOID examine P_((char *filename));
Xstatic VOID short_examine P_((char *filename));
Xstatic VOID long_examine P_((char *filename));
X
Xstatic VOID usage();
Xstatic VOID cleanup P_((int exitcode));
Xstatic char *errxlate P_((ULONG errcode));
X
X#undef P_
X
X
X/*
X** functions
X*/
X
X
X/***************************************************************************
X *   FUNCTION: main                                                        *
X ***************************************************************************/
X#ifdef __STDC__
Xmain(int argc, char *argv[])
X#else
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X#endif
X{
X    int loop, loop2;
X    char **namelist;
X    int onlyflags = 1;
X    flist *ftemp;
X    ULONG status;
X
X    /*
X    ** Searches the entire command line looking for options and sets
X    ** global flag variables appropriately.
X    */
X
X    for (loop = 1; loop < argc; loop++)
X    {
X        if ('-' == argv[loop][0])
X        {
X            switch (argv[loop][1])
X            {
X                /* Verbose option. */
X                case 'v':
X                    flags |= VERBOSE;
X                    break;
X
X                /* Front-end option. */
X                case 'f':
X                    flags |= FRONTEND;
X                    break;
X
X                /* Full name option. */
X                case 'n':
X                    flags ^= NAMETRUNC;
X                    break;
X
X                /* Width option. */
X                case 'w':
X                    if (isdigit(argv[loop][2]) == 0)
X                    {
X                        /* Auto-set to 80. */
X
X                        setcols(80);
X                    }
X                    else
X                    {
X                        /* Set to number. */
X
X                        int cols = 0;
X
X                        for (loop2 = 2; isdigit(argv[loop][loop2]); loop2++)
X                        {
X                            cols *= 10;
X                            cols += (argv[loop][loop2] - '0');
X                        }
X                        setcols(cols);
X                    }
X                    break;
X
X                /* Format search option. */
X                case 't':
X                    /* If complex search specified, ignore this option. */
X
X                    if (searchstr)
X                    {
X                        break;
X                    }
X
X                    /* Search through table of formats for specified type. */
X
X                    for (loop2=0; formatsearch[loop2].name[0] != '\0'; loop2++)
X                    {
X                        /* Check against table of strings. */
X
X                        if (stricmp(formatsearch[loop2].name, (argv[loop] + 2)))
X                        {
X                            continue;
X                        }
X
X                        /* String matched in order to get here, so break. */
X
X                        break;
X                    }
X
X                    /* Was a match found? */
X
X                    if ('\0' == formatsearch[loop2].name[0])
X                    {
X                        fprintf(stderr, "\nERROR: Bad format type string %s\n",
X                                (argv[loop] + 2));
X                        cleanup(3);
X                    }
X
X                    /* Allocate a format list structure. */
X
X                    if ((ftemp = (flist *) malloc(sizeof(flist))) ==
X                        (flist *) NULL)
X                    {
X                        fprintf(stderr, "\nERROR: Out of memory.\n");
X                        cleanup(3);
X                    }
X
X                    /* Initialize. */
X
X                    memcpy(ftemp, &(formatsearch[loop2].value), sizeof(flist));
X
X                    /* Put in format list. */
X
X                    ftemp->next = formatlist;
X                    formatlist = ftemp;
X                    break;
X
X                /* Complex search option. */
X                case 's':
X                    /* Save search string. */
X
X                    searchstr = &(argv[loop][2]);
X
X                    /* Check syntax. */
X
X                    if (0 == comcheck(searchstr))
X                    {
X                        usage();
X                    }
X
X                    /* Free any format searches present. */
X
X                    while (formatlist != (flist *) NULL)
X                    {
X                        ftemp = formatlist->next;
X                        free(formatlist);
X                        formatlist = ftemp;
X                    }
X                    break;
X
X                /* Help option. */
X                case 'h':
X                /* Unrecognized option -- print out help message. */
X                default:
X                    usage();
X                    break;
X            }
X        }
X        else
X        {
X            /*
X            ** onlyflags == 1 when the command line contains only options,
X            ** and therefore the current directory should be scanned. If
X            ** this clause is executed, means there is at least one arg
X            ** which is not an option and therefore is a target.
X            */
X
X            onlyflags = 0;
X        }
X    }
X
X    /* If using as front end, ignore VERBOSE flag. */
X
X    if (flags & FRONTEND)
X    {
X        flags ^= VERBOSE;
X    }
X
X    /* Initialize format recognizer. */
X
X    if ((status = re_init(argv[0], CFG_NAME, ENVVAR_NAME)) != 0)
X    {
X        fprintf(stderr, "%s\n", errxlate(status));
X        if ((SEVERITY(status) == SEVERITY(ST_ERROR)) ||
X            (SEVERITY(status) == SEVERITY(ST_FATAL)))
X        {
X            cleanup(3);
X        }
X    }
X
X    /* Initialize FB module. */
X
X    if (fb_init(2, FB_MINBUFFER) != 0)
X    {
X        fprintf(stderr, "%s\n", errxlate(fb_error));
X        cleanup(3);
X    }
X
X    /* Retrieve number of screen columns. */
X
X    getcols();
X
X    /* If the command line contains only options, process the current dir. */
X
X    if (onlyflags)
X    {
X        /* Get filenames. */
X
X        if ((namelist = scand(".")) == NULL)
X        {
X            fprintf(stderr, "\nERROR: Error reading current directory.\n");
X            cleanup(3);
X        }
X
X        /* Are there any files? */
X
X        if (NULL == namelist[0])
X        {
X            fprintf(stderr, "\nNo files found in current directory.\n");
X        }
X        else
X        {
X            /* Process each file. */
X
X            for (loop = 0; namelist[loop]; loop++)
X            {
X                examine(namelist[loop]);
X                free(namelist[loop]);
X            }
X        }
X
X        /* Cleanup. */
X
X        free(namelist);
X    }
X    else
X    {
X        /* Process the command line arguments that aren't options. */
X
X        for (loop = 1; loop < argc; loop++)
X        {
X            /* Only process if not an option. */
X
X            if (argv[loop][0] != '-')
X            {
X                /* Get filenames. */
X
X                if ((namelist = scand(argv[loop])) == NULL)
X                {
X                    fprintf(stderr, "\nERROR: Bad target %s\n", argv[loop]);
X                    continue;
X                }
X                if (NULL == namelist[0])
X                {
X                    fprintf(stderr, "\nNo files matching %s found.\n",
X                            argv[loop]);
X                }
X                else
X                {
X                    /* Process each one. */
X
X                    for (loop2 = 0; namelist[loop2]; loop2++)
X                    {
X                        examine(namelist[loop2]);
X                        free(namelist[loop2]);
X                    }
X                }
X
X                /* Cleanup. */
X
X                free(namelist);
X            }
X        }
X    }
X
X    /* Done. */
X
X    cleanup(0);
X} /* end of main() */
X
X
X/***************************************************************************
X*   FUNCTION: examine  STATIC                                              *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Examines a given file to determine if it is of a known bitmap      *
X*       format.                                                            *
X*                                                                          *
X*       If it is not, it is ignored unless the VERBOSE flag is             *
X*       set, in which case a message is printed.                           *
X*                                                                          *
X*       If it is of a known bitmap format and the FRONTEND flag is set,    *
X*       only the filename is printed.                                      *
X*                                                                          *
X*       If it is of a known bitmap format and the FRONTEND flag is not     *
X*       set, various basic information on the file is printed.             *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       filename - name of file to be examined                             *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xstatic VOID 
X#ifdef __STDC__
Xexamine(char *filename)
X#else
Xexamine(filename)
Xchar *filename;
X#endif
X{
X    /*
X    ** If FRONTEND flag set and no complex search, all we need is the
X    ** short form. Otherwise do the whole thing.
X    */
X
X    if ((flags & FRONTEND) && (NULL == searchstr))
X    {
X        short_examine(filename);
X    }
X    else
X    {
X        long_examine(filename);
X    }
X
X    return;
X} /* end of static examine() */
X
X
X/***************************************************************************
X*   FUNCTION: short_examine  STATIC                                        *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Called when the FRONTEND flag set and there is no complex search.  *
X*       Examines a given file to determine if it is of a known bitmap      *
X*       format. If it is not, it is ignored. If it is of a known format    *
X*       the filename is printed.                                           *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       filename - name of file to be examined                             *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xstatic VOID 
X#ifdef __STDC__
Xshort_examine(char *filename)
X#else
Xshort_examine(filename)
Xchar *filename;
X#endif
X{
X    ULONG format;
X    ULONG status;
X    flist *ftemp;
X
X    /* Attempt to identify the file. */
X
X    if ((status = re_ident(filename, &format)) != 0)
X    {
X        if (status != FM_UNRECOGNIZED_W)
X        {
X            fprintf(stderr, "\n%s File %s\n", errxlate(status), filename);
X            return;
X        }
X        return;
X    }
X
X    /* If there is a format list, make sure file's format is on list. */
X
X    for (ftemp = formatlist; ftemp; ftemp = ftemp->next)
X    {
X        /* check for match */
X        if ((format & ftemp->mask) == ftemp->value)
X        {
X             /* If match, break out. */
X
X            break;
X        }
X    }
X
X    /* If match, or no format list, print filename. */
X
X    if ((ftemp != (flist *) NULL) || (((flist *) NULL) == formatlist))
X    {
X        printf("%s\n", filename);
X    }
X
X    return;
X} /* end of static short_examine() */
X
X
X/***************************************************************************
X*   FUNCTION: long_examine  STATIC                                         *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Examines a given file to determine if it is of a known bitmap      *
X*       format. Called when FRONTEND flag is not set or it is set but      *
X*       there is a complex search.                                         *
X*                                                                          *
X*       If it is not, it is ignored unless the VERBOSE flag is             *
X*       set, in which case a message is printed.                           *
X*                                                                          *
X*       If it is of a known bitmap format and the FRONTEND flag is not     *
X*       set, various basic information on the file is printed. If the      *
X*       FRONTEND flag is set, only the filename is printed.                *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       filename - name of file to be examined                             *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xstatic VOID 
X#ifdef __STDC__
Xlong_examine(char *filename)
X#else
Xlong_examine(filename)
Xchar *filename;
X#endif
X{
X    FILE *infile;
X    FB *infile2;
X    ULONG format;
X    ULONG status;
X    flist *ftemp;
X    ULONG height, width;
X    ULONG colors;
X    long filesize;
X    int searchval;
X
X    GIF_LSD gifinfo;
X    IMG_HDR imginfo;
X    JFIF_HDR jfifinfo;
X    SR_HDR srinfo;
X    TGA_HDR tgainfo;
X    PNM_HDR pnminfo;
X    XBM_HDR xbminfo;
X    BMP_HDR bmpinfo;
X    PCX_HDR pcxinfo;
X
X    /* Is the file of a known format? */
X
X    if ((status = re_ident(filename, &format)) != 0)
X    {
X        if (status != FM_UNRECOGNIZED_W)
X        {
X            fprintf(stderr, "\n%s File %s\n", errxlate(status), filename);
X            return;
X        }
X    }
X    if (FORMAT_NOT == format)
X    {
X        /*
X        ** Do nothing for files which are not recognized, unless the verbose
X        ** flag is set.
X        */
X
X        if (flags & VERBOSE)
X        {
X            fprintf(stderr,"\nERROR: file %s is of unknown format\n", filename);
X        }
X        return;
X    }
X
X    /* Format recognized, so start doing things. Open file. */
X
X    if ((infile = fopen(filename, FOPEN_READ_BINARY)) == (FILE *) NULL)
X    {
X        sprintf(scratch, "\nERROR: Error opening file %s", filename);
X        perror(scratch);
X        return;
X    }
X
X    /* Extract information from the file. */
X
X    switch (FORMAT_TYPE(format))
X    {
X        case FORMAT_TYPE(FORMAT_GIF):
X            if ((status = gif_lsdget(infile, &gifinfo)) != 0)
X            {
X                fprintf(stderr, "\n%s File %s\n", errxlate(status), filename);
X                fclose(infile);
X                return;
X            }
X            break;
X
X        case FORMAT_TYPE(FORMAT_IMG):
X            if ((status = img_getheader(infile, &imginfo)) != 0)
X            {
X                fprintf(stderr, "\n%s File %s\n", errxlate(status), filename);
X                fclose(infile);
X                return;
X            }
X            break;
X
X        case FORMAT_TYPE(FORMAT_SR):
X            if ((status = sr_getheader(infile, &srinfo)) != 0)
X            {
X                fprintf(stderr, "\n%s File %s\n", errxlate(status), filename);
X                fclose(infile);
X                return;
X            }
X            break;
X
X        case FORMAT_TYPE(FORMAT_TGA):
X            if ((status = tga_getheader(infile, &tgainfo)) != 0)
X            {
X                fprintf(stderr, "\n%s File %s\n", errxlate(status), filename);
X                fclose(infile);
X                return;
X            }
X            break;
X
X        case FORMAT_TYPE(FORMAT_PBM):
X            if ((status = pbm_getheader(infile, (PBM_HDR *) &pnminfo)) != 0)
X            {
X                fprintf(stderr, "\n%s File %s\n", errxlate(status), filename);
X                fclose(infile);
X                return;
X            }
X            break;
X
X        case FORMAT_TYPE(FORMAT_PGM):
X            if ((status = pgm_getheader(infile, (PBM_HDR *) &pnminfo)) != 0)
X            {
X                fprintf(stderr, "\n%s File %s\n", errxlate(status), filename);
X                fclose(infile);
X                return;
X            }
X            break;
X
X        case FORMAT_TYPE(FORMAT_PPM):
X            if ((status = ppm_getheader(infile, (PBM_HDR *) &pnminfo)) != 0)
X            {
X                fprintf(stderr, "\n%s File %s\n", errxlate(status), filename);
X                fclose(infile);
X                return;
X            }
X            break;
X
X        case FORMAT_TYPE(FORMAT_XBM):
X            if ((status = xbm_getheader(infile, &xbminfo)) != 0)
X            {
X                fprintf(stderr, "\n%s File %s\n", errxlate(status), filename);
X                fclose(infile);
X                return;
X            }
X            break;
X
X        case FORMAT_TYPE(FORMAT_BMP):
X            if ((status = bmp_getheader(infile, &bmpinfo)) != 0)
X            {
X                fprintf(stderr, "\n%s File %s\n", errxlate(status), filename);
X                fclose(infile);
X                return;
X            }
X            break;
X
X        case FORMAT_TYPE(FORMAT_PCX):
X            if ((status = pcx_getheader(infile, &pcxinfo)) != 0)
X            {
X                fprintf(stderr, "\n%s File %s\n", errxlate(status), filename);
X                fclose(infile);
X                return;
X            }
X            break;
X
X        case FORMAT_TYPE(FORMAT_JFIF):
X            infile2 = fb_retrofit(infile, 'r');
X            if (fb_error != 0)
X            {
X                fprintf(stderr, "\n%s File %s\n", errxlate(status), filename);
X                fclose(infile);
X                return;
X            }
X            if ((status = jfif_headerget(infile2, &jfifinfo)) != 0)
X            {
X                fprintf(stderr, "\n%s File %s\n", errxlate(status), filename);
X                fb_close(infile2);
X                return;
X            }
X    
X            /*
X            ** Close file and reopen so stuff lower down is OK. Note that
X            ** closing of infile is handled by the fb_close() of infile2.
X            */
X    
X            fb_close(infile2);
X            if ((infile = fopen(filename, FOPEN_READ_BINARY)) == (FILE *) NULL)
X            {
X                sprintf(scratch, "\nERROR: Error opening file %s", filename);
X                perror(scratch);
X                return;
X            }
X            break;
X
X        default:
X            /* Should never get here. */
X
X            fprintf(stderr, "\nInternal error, bad format ID.\n");
X            fclose(infile);
X            return;
X            break;
X    }
X
X    /* If there is a format list, make sure file's format is on list.  */
X
X    for (ftemp = formatlist; ftemp; ftemp = ftemp->next)
X    {
X        /* check for match */
X        if ((format & ftemp->mask) == ftemp->value)
X        {
X            /* if match, break out */
X            break;
X        }
X    }
X
X    /* If no match, return. */
X
X    if ((((flist *) NULL) == ftemp) && (formatlist != (flist *) NULL))
X    {
X        fclose(infile);
X        return;
X    }
X
X    /* Obtain size of file. */
X
X    if (fseek(infile, 0L, SEEK_END))
X    {
X        sprintf(scratch, "\nERROR: Error seeking in file %s", filename);
X        perror(scratch);
X        fclose(infile);
X        return;
X    }
X    if ((filesize = ftell(infile)) == -1L)
X    {
X        sprintf(scratch, "\nERROR: Error determining size of %s", filename);
X        perror(scratch);
X        fclose(infile);
X        return;
X    }
X
X    /* If there is a complex search string, process it now.  */
X
X    if (searchstr != (char *) NULL)
X    {
X        /* extract necessary data */
X
X        switch FORMAT_TYPE(format)
X        {
X            case FORMAT_TYPE(FORMAT_GIF):
X                height = gifinfo.scr_hi;
X                width = gifinfo.scr_wid;
X                colors = (0x1L << gifinfo.gct_size);
X                break;
X
X            case FORMAT_TYPE(FORMAT_IMG):
X                height = imginfo.imhi;
X                width = imginfo.imwid;
X                colors = (0x1L << imginfo.planes);
X                break;
X
X            case FORMAT_TYPE(FORMAT_SR):
X                height = srinfo.imhi;
X                width = srinfo.imwid;
X                colors = (0x1L << srinfo.pixelbits);
X                break;
X
X            case FORMAT_TYPE(FORMAT_TGA):
X                height = tgainfo.imhi;
X                width = tgainfo.imwid;
X                switch (tgainfo.type)
X                {
X                    /* No image data, rummage around looking for clues. */
X                    case 0:
X                        if (tgainfo.maptype != 0)
X                        {
X                            colors = tgainfo.maplen;
X                        }
X                        else if (tgainfo.pixelbits != 0)
X                        {
X                            colors = (0x1L << tgainfo.pixelbits);
X                            /* Overflow on 32-bit color. */
X                            colors = ((0 == colors) ? 0xFFFFFFFFL : colors);
X                        }
X                        else
X                        {
X                            colors = 0;
X                        }
X                        break;
X                        
X                    /* Color-mapped image. */
X                    case 1:
X                    case 9:
X                    case 32:
X                    case 33:
X                        colors = tgainfo.maplen;
X                        break;
X
X                    /* True-color image. */
X                    case 2:
X                    case 3:
X                    case 10:
X                    case 11:
X                        colors = (0x1L << tgainfo.pixelbits);
X                        /* Overflow on 32-bit color. */
X                        colors = ((0 == colors) ? 0xFFFFFFFFL : colors);
X                        break;
X
X                    default:
X                        fprintf(stderr,
X                                "\nERROR: internal error, bad Targa ID.\n");
X                        fclose(infile);
X                        return;
X                }
X                break;
X
X            case FORMAT_TYPE(FORMAT_JFIF):
X                height = jfifinfo.height;
X                width = jfifinfo.width;
X                if ((jfifinfo.components * jfifinfo.bits) > 31)
X                {
X                    colors = 0xFFFFFFFFL;
X                }
X                else
X                {
X                    colors = (0x1L << (jfifinfo.components * jfifinfo.bits));
X                }
X                break;
X
X            case FORMAT_TYPE(FORMAT_PBM):
X                height = pnminfo.imhi;
X                width = pnminfo.imwid;
X                colors = 2;
X                break;
X
X            case FORMAT_TYPE(FORMAT_PGM):
X                height = pnminfo.imhi;
X                width = pnminfo.imwid;
X                colors = pnminfo.maxpix + 1;
X                break;
X
X            case FORMAT_TYPE(FORMAT_PPM):
X                height = pnminfo.imhi;
X                width = pnminfo.imwid;
X                colors = pnminfo.maxpix + 1;
X                colors = colors * colors * colors;
X                break;
X
X            case FORMAT_TYPE(FORMAT_XBM):
X                height = xbminfo.imhi;
X                width = xbminfo.imwid;
X                colors = 2;
X                break;
X
X            case FORMAT_TYPE(FORMAT_BMP):
X                height = bmpinfo.imhi;
X                width = bmpinfo.imwid;
X                colors = (0x1L << (bmpinfo.planes * bmpinfo.pixbits));
X                if (((BMP_WIN3 == bmpinfo.version) || 
X                     (BMP_OS2_20 == bmpinfo.version)) &&
X                    (bmpinfo.more != NULL) &&
X                    ((bmpinfo.planes * bmpinfo.pixbits) != 24))
X                {
X                    if ((BMP_WIN3 == bmpinfo.version) &&
X                        (((BMP_H3 *) bmpinfo.more)->clrused != 0))
X                    {
X                        colors = ((BMP_H3 *) bmpinfo.more)->clrused;
X                    }
X                    else if ((BMP_OS2_20 == bmpinfo.version) &&
X                             (((BMP_H20 *) bmpinfo.more)->more.clrused != 0))
X                    {
X                        colors = ((BMP_H20 *) bmpinfo.more)->more.clrused;
X                    }
X                }
X                break;
X
X            case FORMAT_TYPE(FORMAT_PCX):
X                height = pcxinfo.imhi;
X                width = pcxinfo.imwid;
X                colors = (0x1L << (pcxinfo.planes * pcxinfo.pixbits));
X                break;
X
X            default:
X                fprintf(stderr, "\nERROR: internal error, bad format ID.\n");
X                fclose(infile);
X                return;
X        }
X        searchval = comsearch(height, width, colors, format, (ULONG) filesize,
X                              searchstr);
X
X        /* Check for error. */
X
X        if (com_errorflag != 0)
X        {
X            fprintf(stderr, "\nERROR: internal error during search parse.\n");
X            fclose(infile);
X            return;
X        }
X
X        /* Check for match. */
X
X        if (0 == searchval)
X        {
X            /* Does not match. */
X
X            fclose(infile);
X            return;
X        }
X    }
X
X    /*
X    ** If FRONTEND, just print filename and return.
X    ** Will arrive here when FRONTEND and complex search.
X    */
X
X    if (flags & FRONTEND)
X    {
X        printf("%s\n", filename);
X        fclose(infile);
X        return;
X    }
X
X    /*
X    ** Now we know what format the file is, so process further by format
X    ** including output to screen.
X    */
X
X    switch FORMAT_TYPE(format)
X    {
X        case FORMAT_TYPE(FORMAT_GIF):
X            gif_display(&gifinfo, infile, filename, filesize);
X            break;
X
X        case FORMAT_TYPE(FORMAT_IMG):
X            img_display(&imginfo, filename, filesize);
X            break;
X
X        case FORMAT_TYPE(FORMAT_JFIF):
X            jfif_display(&jfifinfo, filename, filesize);
X            break;
X
X        case FORMAT_TYPE(FORMAT_SR):
X            sr_display(&srinfo, filename, filesize);
X            break;
X
X        case FORMAT_TYPE(FORMAT_TGA):
X            tga_display(&tgainfo, filename, filesize);
X            break;
X
X        case FORMAT_TYPE(FORMAT_PBM):
X        case FORMAT_TYPE(FORMAT_PGM):
X        case FORMAT_TYPE(FORMAT_PPM):
X            pnm_display(&pnminfo, filename, filesize);
X            break;
X
X        case FORMAT_TYPE(FORMAT_XBM):
X            xbm_display(&xbminfo, filename, filesize);
X            break;
X
X        case FORMAT_TYPE(FORMAT_BMP):
X            bmp_display(&bmpinfo, filename, filesize);
X            break;
X
X        case FORMAT_TYPE(FORMAT_PCX):
X            pcx_display(&pcxinfo, filename, filesize);
X            break;
X
X        default:
X            fprintf(stderr, "\nERROR: Internal error!\n");
X            fclose(infile);
X            return;
X    }
X
X    /* Clean up and return. */
X
X    fclose(infile);
X
X    return;
X} /* end of static long_examine() */
X
X
X/***************************************************************************
X*   FUNCTION: usage  STATIC                                                *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Prints a usage message.                                            *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       Nothing.                                                           *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Does not return.                                                   *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xstatic VOID
Xusage()
X{
X    int loop;
X
X    printf("\n");
X    printf("CHILS version %s, patchlevel %d by James W. Birdsall\n", VERS,
X           PATCHLEVEL);
X    printf("   Prints out various data on files of various bitmap formats\n");
X    printf("   usage: chils [options] [target] [target target...]\n");
X    printf("     target       filename or directory. If a directory, all files in that\n");
X    printf("                   directory will be processed. If no targets are given,\n");
X    printf("                   all files in the current directory will be processed.\n");
X    printf("     -spattern    COMPLEX SEARCH: Allows complicated Boolean searches based on\n");
X    printf("                   height, width, colors, and format. Format keywords are as\n");
X    printf("                   for the -t option, below. Decimal numbers are allowed.\n");
X    printf("                   Other operators are:\n");
X    printf("        ( )   parentheses          =     equal           H     height\n");
X#ifdef DOS_COMSRCH
X    printf("        }     greater than         {     less than       W     width\n");
X    printf("        }=    greater or equal     {=    less or equal   C     colors\n");
X    printf("        +     logical and          ,     logical or      F     file length\n");
X#else
X    printf("        >     greater than         <     less than       W     width\n");
X    printf("        >=    greater or equal     <=    less or equal   C     colors\n");
X    printf("        &     logical and          |     logical or      F     file length\n");
X#endif
X    printf("                   Since many operators are also shell metacharacters, search\n");
X    printf("                   strings should be quoted.\n");
X#ifdef DOS_COMSRCH
X    printf("                   Example: -s'(W}=640+H}=480),(GIF+C=256)' searches for\n");
X#else
X    printf("                   Example: -s'(W>=640&H>=480)|(GIF&C=256)' searches for\n");
X#endif
X    printf("                   images at least 640 by 480, or any GIF with 256 colors.\n");
X    printf("     -tformat     TYPE: Only files of type format will be processed. Ignores\n");
X    printf("                   -v option. Multiple -t options may be specified. Formats\n");
X    printf("                   recognized (case insensitive) are:");
X
X    for (loop = 0; formatsearch[loop].name[0] != '\0'; loop++)
X    {
X        if ((loop % 6) == 0)
X        {
X            printf("\n                   ");
X        }
X        printf(formatsearch[loop].name);
X        if (formatsearch[loop + 1].name[0] != '\0')
X        {
X            printf(", ");
X        }
X    }
X
X    printf("\n");
X    printf("     -v           VERBOSE: Prints a line for every file checked, whether the\n");
X    printf("                   format was recognized or not.\n");
X    printf("     -f           FRONT END: For use as front end for other CHIARO programs.\n");
X    printf("                   Prints list of matching files on stdout. Ignores -v option.\n");
X    printf("     -n           NO TRUNCATE: Does not strip directories from filenames\n");
X    printf("                   in output.\n");
X    printf("     -w[n]        WIDTH: Overrides automatic determination of output width in\n");
X    printf("                   columns. If no number is specified, sets width to 80,\n");
X    printf("                   otherwise sets it to number specified (must be at least 80).\n");
X    printf("     -h           HELP: Prints this message.\n");
X    printf("\n");
X    printf("   Options may not be combined.\n");
X
X    cleanup(3);
X} /* end of static usage() */
X
X
X/***************************************************************************
X*   FUNCTION: errxlate  STATIC                                             *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Translates an error code into a string.                            *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       errcode - code to be translated                                    *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns a pointer to the appropriate string.                       *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xstatic char *
X#ifdef __STDC__
Xerrxlate(ULONG errcode)
X#else
Xerrxlate(errcode)
XULONG errcode;
X#endif
X{
X    char *errstring;
X    char *sever;
X
X    /* Determine severity of error. */
X
X    switch (SEVERITY(errcode))
X    {
X        case SEVERITY(ST_SUCCESS):
X            sever = "SUCCESS";
X            break;
X
X        case SEVERITY(ST_WARNING):
X            sever = "WARNING";
X            break;
X
X        case SEVERITY(ST_ERROR):
X            sever = "ERROR";
X            break;
X
X        case SEVERITY(ST_FATAL):
X        default:
X            sever = "FATAL";
X            break;
X    }
X
X    /* Get error string from module. */
X
X    switch (MODULE(errcode))
X    {
X        case MODULE(GIF_MODULE):
X            errstring = gif_errstring(errcode);
X            break;
X
X        case MODULE(IMG_MODULE):
X            errstring = img_errstring(errcode);
X            break;
X
X        case MODULE(JFIF_MODULE):
X            errstring = jfif_errstring(errcode);
X            break;
X
X        case MODULE(SR_MODULE):
X            errstring = sr_errstring(errcode);
X            break;
X
X        case MODULE(TGA_MODULE):
X            errstring = tga_errstring(errcode);
X            break;
X
X        case MODULE(PBM_MODULE):
X            errstring = pbm_errstring(errcode);
X            break;
X
X        case MODULE(PGM_MODULE):
X            errstring = pgm_errstring(errcode);
X            break;
X
X        case MODULE(PPM_MODULE):
X            errstring = ppm_errstring(errcode);
X            break;
X
X        case MODULE(XBM_MODULE):
X            errstring = xbm_errstring(errcode);
X            break;
X
X        case MODULE(BMP_MODULE):
X            errstring = bmp_errstring(errcode);
X            break;
X
X        case MODULE(PCX_MODULE):
X            errstring = pcx_errstring(errcode);
X            break;
X
X        case MODULE(FB_MODULE):
X            errstring = fb_errstring(errcode);
X            break;
X
X        case MODULE(FM_MODULE):
X            errstring = re_errstring(errcode);
X            break;
X
X        default:
X            errstring = NULL;
X            break;
X    }
X
X    /* Composite strings. */
X
X    if (errstring != NULL)
X    {
X        sprintf(scratch, "%s: %s", sever, errstring);
X    }
X    else
X    {
X        /* Error not recognized by any module. */
X
X        sprintf(scratch, "%s: %08lX.", sever, errcode);
X    }
X
X    return scratch;
X} /* end of static errxlate() */
X
X
X/***************************************************************************
X*   FUNCTION: cleanup  STATIC                                              *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Frees format list, if present, and exits with specified code.      *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       exitcode - code to exit with                                       *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Does not return.                                                   *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xstatic VOID
X#ifdef __STDC__
Xcleanup(int exitcode)
X#else
Xcleanup(exitcode)
Xint exitcode;
X#endif
X{
X    flist *temp;
X
X    /* Free format list, if present. */
X
X    while (formatlist != (flist *) NULL)
X    {
X        temp = formatlist;
X        formatlist = formatlist->next;
X        free(temp);
X    }
X
X    /* Free extension list, if present. */
X
X    re_deinit();
X
X    /* Exit. */
X
X    exit(exitcode);
X} /* end of static cleanup() */
X
END_OF_FILE
  if test 41782 -ne `wc -c <'src/chils.c'`; then
    echo shar: \"'src/chils.c'\" unpacked with wrong size!
  fi
  # end of 'src/chils.c'
fi
if test -f 'src/sr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/sr.c'\"
else
  echo shar: Extracting \"'src/sr.c'\" \(10626 characters\)
  sed "s/^X//" >'src/sr.c' <<'END_OF_FILE'
X/***************************************************************************
X*   SR.C                                                                   *
X*   MODULE:  SR (Sun Raster)                                               *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   $Id: sr.c,v 1.1 1993/03/02 00:59:36 jwbirdsa Exp $
X*                                                                          *
X*   This file contains functions to process Sun Raster format files.       *
X*   Functions:                                                             *
X*      sr_verify    - checks filename to see if it is an Sun Raster file   *
X*      sr_getheader - extracts header data from SR file                   *
X*                                                                          *
X*      sr_errstring - converts error code into message                     *
X*                                                                          *
X***************************************************************************/
X
X#include "config.h"
X
X/*
X** system includes <>
X*/
X
X#include <stdio.h>
X
X
X/*
X** custom includes ""
X*/
X
X#include "depend.h"
X#include "formats.h"
X#include "sr.h"
X
X
X/*
X** local #defines
X*/
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
X/*
X** typedefs
X*/
X
X/*
X** global variables
X*/
X
X/*
X** static globals
X*/
X
Xstatic char CONST rcsid[] = "$Id: sr.c,v 1.1 1993/03/02 00:59:36 jwbirdsa Exp $";
X
X
X/*
X** function prototypes
X*/
X
X/*
X** functions
X*/
X
X
X/***************************************************************************
X*   FUNCTION:    sr_verify                                                 *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Verifies that a file is a Sun Raster file by checking for the      *
X*       magic number at the beginning of the file.                         *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       filename - name of file to be verified                             *
X*       version  - pointer to unsigned long in which format/version value  *
X*                  is returned                                             *
X*       exts     - optional list of file extensions                        *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns an error/status code.                                      *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XULONG
X#ifdef __STDC__
Xsr_verify(char *filename, ULONG *version, char **exts)
X#else
Xsr_verify(filename, version, exts)
Xchar *filename;
XULONG *version;
Xchar **exts;
X#endif
X{
X    FILE *srfile;
X    UCHAR verbuf[4];
X    ULONG retval;
X
X    /* If a list of extensions was supplied, check against it. */
X
X    if (((char **) NULL) != exts)
X    {
X        /* Search for '.' marking extension. */
X    
X        int loop;
X        char *extptr = (char *) strrchr(filename, '.');
X
X        if (NULL == extptr)
X        {
X            /* No extension, cannot classify. */
X    
X            *version = SR_NOT;
X            return 0;
X        }
X        extptr++;
X    
X        /* Now we have the extension, check against list. */
X    
X        for (loop = 0; exts[loop] != NULL; loop++)
X        {
X            /* Case-sensitive string compare. */
X    
X            if (strcmp(extptr, exts[loop]) == 0)
X            {
X                /* Match, so break out of loop. */
X    
X                break;
X            }
X        }
X    
X        /* Check exit from loop. */
X    
X        if (NULL == exts[loop])
X        {
X            /* No match, return. */
X    
X            *version = SR_NOT;
X            return 0;
X        }
X    
X        /* Extension is valid for type SR, so process accordingly. */
X    }
X
X    /* Open the file so we can check the magic number. */
X
X    if ((srfile = fopen(filename, FOPEN_READ_BINARY)) == (FILE *) NULL)
X    {
X        return SR_FILEERR_E;
X    }
X
X    /* Read all four bytes of the magic number. */
X
X    if (fread(verbuf, sizeof(UCHAR), 4, srfile) != 4)
X    {
X        *version = SR_NOT;
X        retval = (feof(srfile) ? ST_SUCCESS : SR_FILEERR_E);
X        fclose(srfile);
X        return retval;
X    }
X
X    /* Set version return according to magic number. */
X
X    *version = ((SR_MAGIC == CONSTRUCT_M_ULONG(verbuf)) ? SR_1 : SR_NOT);
X
X    /* Close file. */
X
X    if (fclose(srfile))
X    {
X        return SR_FILEERR_E;
X    }
X
X    /* Return OK. */
X
X    return 0;
X} /* end of sr_verify() */
X
X
X/***************************************************************************
X*   FUNCTION:    sr_getheader                                             *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Assumes that file is an SR file. Reads header from file, extracts *
X*       data into SR_HDR structure.                                       *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       infile  - file to be processed                                     *
X*       results - pointer to SR_HDR structure in which data from header   *
X*                 is returned                                              *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns an error/status code.                                      *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X*       Leaves file pointing to beginning of image data.                   *
X*                                                                          *
X***************************************************************************/
XULONG
X#ifdef __STDC__
Xsr_getheader(FILE *infile, SR_HDR *results)
X#else
Xsr_getheader(infile, results)
XFILE *infile;
XSR_HDR *results;
X#endif
X{
X    UCHAR rawhdr[SR_HDR_LEN];
X
X    /* Make sure we're at beginning of file. */
X
X    if (fseek(infile, 0L, SEEK_SET))
X    {
X        return SR_FILEERR_E;
X    }
X
X    /* Read raw bytes into buffer. */
X
X    if (fread(rawhdr, 1, SR_HDR_LEN, infile) != SR_HDR_LEN)
X    {
X        return (feof(infile) ? SR_UNEOF_E : SR_FILEERR_E);
X    }
X
X    /* Extract info from raw header. */
X
X    results->imwid = CONSTRUCT_M_ULONG(rawhdr + SR_HDR_IMWID_OFF);
X    results->imhi = CONSTRUCT_M_ULONG(rawhdr + SR_HDR_IMHI_OFF);
X    results->pixelbits = (int) CONSTRUCT_M_ULONG(rawhdr + SR_HDR_BITS_OFF);
X    results->rasterlen = CONSTRUCT_M_ULONG(rawhdr + SR_HDR_RLEN_OFF);
X    results->rastype = (unsigned int)
X                       CONSTRUCT_M_ULONG(rawhdr + SR_HDR_TYPE_OFF);
X    results->maptype = (int) CONSTRUCT_M_ULONG(rawhdr + SR_HDR_MTYPE_OFF);
X    results->maplen = CONSTRUCT_M_ULONG(rawhdr + SR_HDR_MLEN_OFF);
X
X    /* Set file to point to start of colormap. */
X
X    if (fseek(infile, (long)(SR_HDR_LEN), SEEK_SET))
X    {
X        return SR_FILEERR_E;
X    }
X
X    /* Return OK. */
X
X    return 0;
X} /* end of sr_getheader() */
X
X
X/***************************************************************************
X*   FUNCTION: sr_errstring                                                *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*      Returns a string corresponding to an error code.                    *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*      errcode - error code to be translated                               *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*      Returns a pointer to the appropriate string, or NULL if there is    *
X*      no appropriate string.                                              *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xchar *
X#ifdef __STDC__
Xsr_errstring(ULONG errcode)
X#else
Xsr_errstring(errcode)
XULONG errcode;
X#endif
X{
X    char *temp;
X
X    /* If error code not from this module, return NULL. */
X
X    if ((errcode & ST_MOD_MASK) != SR_MODULE)
X    {
X        return NULL;
X    }
X
X    /* Process by code. */
X
X    switch (ERRSEV(errcode))
X    {
X        case ERRSEV(SR_NOTSR_E):
X            temp = "File is not a SR format file.";
X            break;
X        case ERRSEV(SR_FILEERR_E):
X            temp = "Error accessing file.";
X            break;
X        case ERRSEV(SR_UNEOF_E):
X            temp = "Unexpected End of File";
X            break;
X
X        default:
X            temp = NULL;
X            break;
X    }
X
X    return temp;
X} /* end of sr_errstring() */
X
END_OF_FILE
  if test 10626 -ne `wc -c <'src/sr.c'`; then
    echo shar: \"'src/sr.c'\" unpacked with wrong size!
  fi
  # end of 'src/sr.c'
fi
echo shar: End of archive 5 \(of 18\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
