Newsgroups: comp.sources.misc
From: jwbirdsa@picarefy.picarefy.com (James W. Birdsall)
Subject: v36i074:  chiaro - Image Utilities, Part04/18
Message-ID: <1993Mar25.181018.20080@sparky.imd.sterling.com>
X-Md4-Signature: 52e8144a10e01088d59cb559750cccb7
Date: Thu, 25 Mar 1993 18:10:18 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jwbirdsa@picarefy.picarefy.com (James W. Birdsall)
Posting-number: Volume 36, Issue 74
Archive-name: chiaro/part04
Environment: UNIX, Sun, DECstation, 3B1

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  src/depend.c templates/linux-gcc.h templates/template.h
# Wrapped by kent@sparky on Thu Mar 25 11:20:02 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 18)."'
if test -f 'src/depend.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/depend.c'\"
else
  echo shar: Extracting \"'src/depend.c'\" \(42953 characters\)
  sed "s/^X//" >'src/depend.c' <<'END_OF_FILE'
X/***************************************************************************
X*   depend.c                                                               *
X*   MODULE:  -                                                             *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   $Id: depend.c,v 1.11 1993/02/15 01:57:13 jwbirdsa Exp $
X*                                                                          *
X*   Hardware and OS dependent functions; basic services that depend on     *
X*   the OS and/or hardware.                                                *
X*                                                                          *
X***************************************************************************/
X
X#include "config.h"
X
X/*
X** system includes <>
X*/
X
X#include <stdio.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#ifndef NO_MALLOCHDR
X#include <malloc.h>
X#endif
X#ifndef NO_STR_INC
X#ifdef STRING_PLURAL
X#include <strings.h>
X#else
X#include <string.h>
X#endif
X#endif
X#ifdef DIR_READDIR
X#include <dirent.h>
X#else /* ! DIR_READDIR */
X#include <fcntl.h>
X#endif
X#ifdef DIR_GETDENTS
X#include <sys/dirent.h>
X#endif
X#ifdef DIR_NODIR
X#include <sys/dir.h>
X#include <errno.h>
X#endif
X#ifdef USTAT
X#include <ustat.h>
X#endif
X#ifdef STATFS
X#include <sys/vfs.h>
X#endif
X#ifdef STATFS_FSDATA
X#include <sys/param.h>
X#include <sys/mount.h>
X#endif
X
X
X/*
X** custom includes ""
X*/
X
X#include "depend.h"
X
X
X/*
X** local #defines
X*/
X
X#define MASK_PATTERN       1
X#define MASK_DIREC         2
X#define MASK_FILE          3
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST rcsid[] = "$Id: depend.c,v 1.11 1993/02/15 01:57:13 jwbirdsa Exp $";
X
X
X/*
X** typedefs
X*/
X
X#ifdef DIR_GETDIRENT
Xstruct dirent
X{
X    unsigned long d_fileno;
X    unsigned short d_reclen;
X    unsigned short d_namlen;
X    char d_name[256];
X};
X
Xtypedef struct tagDIR
X{
X    int fd;
X    long totsize;
X    long blocksize;
X    struct dirent *buffer;
X    struct dirent *nextentry;
X    struct dirent *lastentry;
X} DIR;
X#endif /* DIR_GETDIRENT */
X
X#ifdef DIR_GETDENTS
Xtypedef struct tagDIR
X{
X    int fd;
X} DIR;
X#endif /* DIR_GETDENTS */
X
X#ifdef DIR_NODIR
X#define dirent direct
X
Xtypedef struct tagDIR
X{
X    int fd;
X    char d_name[256];
X} DIR;
X#endif /* DIR_NODIR */
X
X
X/*
X** global variables
X*/
X
X#ifdef DIR_NODIR
X#ifdef NO_ERRNO
Xextern int errno;
X#endif
X#endif
X
X
X/*
X** static globals
X*/
X
X/*
X** function prototypes
X*/
X
X#ifdef  __STDC__
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
Xstatic char *strdp P_((char *dupee1, char *dupee2));
X
X#ifndef DIR_READDIR
Xstatic DIR *opendir P_((char *dirname));
Xstatic struct dirent *readdir P_((DIR *dirp));
Xstatic int closedir P_((DIR *dirp));
X#endif
X#ifdef DIR_NODIR
Xstatic int getdents P_((int fd, char *buf, int nbytes));
X#endif
X
X#undef P_
X
X#ifdef NO_STR_INC
Xextern int strlen();
Xextern char *strncpy();
Xextern char *strcpy();
Xextern char *strcat();
X#ifndef NO_STRDUP
Xextern char *strdup();
X#endif
X#endif
X
X
X/*
X** functions
X*/
X
X/***************************************************************************
X*   FUNCTION: scand                                                        *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       This function returns a pointer to an array of strings (i.e. an    *
X*       array of character pointers) which contain the filenames to be     *
X*       processed, including path as necessary. The last pointer           *
X*       in the array is NULL.                                              *
X*                                                                          *
X*       The argument MASK may be a directory name or a filename. Wildcards *
X*       will never get here, as they are expanded by the shell. A filename *
X*       can include a path. If MASK is a directory, it will be expanded to *
X*       a list of the filenames in that directory. If MASK is a file, the  *
X*       filename will be returned.                                         *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       mask - see above                                                   *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns a pointer to an array of character pointers, or NULL on    *
X*       error.                                                             *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xchar **
X#ifdef __STDC__
Xscand(char *mask)
X#else
Xscand(mask)
Xchar *mask;
X#endif
X{
X    int masktype;
X    struct stat statbuf;
X    char *temp;
X    char *candidate;
X    DIR *dirhandle;
X    struct dirent *data;
X    int loop;
X    int dirsize;
X    char **buffer;
X    char **tmpbuf;
X#ifdef DIR_NODIR
X    char holdname[DIRSIZ + 1];
X#endif
X
X    /* FIRST: We need to find out if the mask is a directory or a filename. */
X
X    if (stat(mask, &statbuf) == -1)
X    {
X        /* Error in mask. */
X
X        return NULL;
X    }
X    masktype = (statbuf.st_mode & S_IFDIR) ? MASK_DIREC : MASK_FILE;
X
X    /* SECOND: if filename, return the easy way. */
X
X    if (masktype == MASK_FILE)
X    {
X        /* Allocate memory. */
X
X        if ((buffer = (char **) calloc(2, sizeof(char *))) == NULL)
X        {
X            return NULL;
X        }
X        if ((buffer[0] = strdup(mask)) == NULL)
X        {
X            free(buffer);
X            return NULL;
X        }
X        buffer[1] = NULL;
X        return buffer;
X    }
X
X    /* THIRD: search for regular files in the directory and put in buffer. */
X
X    dirsize = 0;
X
X    /* Open the directory. */
X
X    if ((dirhandle = opendir(mask)) == NULL)
X    {
X        return NULL;
X    }
X
X    /* Prepare a modified mask for append. */
X
X    if (mask[strlen(mask) - 1] == '/')
X    {
X        /* If trailing slash already, just copy. */
X
X        if ((temp = strdup(mask)) == NULL)
X        {
X            closedir(dirhandle);
X            return NULL;
X        }
X    }
X    else
X    {
X        /* Otherwise add one. */
X
X        if ((temp = strdp(mask, "/")) == NULL)
X        {
X            closedir(dirhandle);
X            return NULL;
X        }
X    }
X
X    /* Allocate buffer first time. */
X
X    if ((buffer = (char **) malloc(sizeof(char *))) == (char **) NULL)
X    {
X        closedir(dirhandle);
X        free(temp);
X        return NULL;
X    }
X
X    /* Start reading. */
X
X    while ((data = readdir(dirhandle)) != (struct dirent *) NULL)
X    {
X        /* Check for file type. */
X
X#ifdef DIR_NODIR
X        strncpy(holdname, data->d_name, DIRSIZ);
X        holdname[DIRSIZ] = '\0';
X        if ((candidate = strdp(temp, holdname)) == NULL)
X#else
X        if ((candidate = strdp(temp, data->d_name)) == NULL)
X#endif
X        {
X            closedir(dirhandle);
X            free(temp);
X            for (loop = 0; loop < dirsize; loop++)
X            {
X                free(buffer[loop]);
X            }
X            free(buffer);
X            return NULL;
X        }
X        if (stat(candidate, &statbuf) == -1)
X        {
X            /* Error in filename. */
X
X            closedir(dirhandle);
X            free(temp);
X            for (loop = 0; loop < dirsize; loop++)
X            {
X                free(buffer[loop]);
X            }
X            free(buffer);
X            free(candidate);
X            return NULL;
X        }
X        if (statbuf.st_mode & S_IFREG)
X        {
X            /* Only include if regular file. */
X
X            buffer[dirsize++] = candidate;
X            tmpbuf = (char **) realloc(buffer, ((dirsize + 1)*sizeof(char *)));
X            if (tmpbuf == (char **) NULL)
X            {
X                closedir(dirhandle);
X                free(temp);
X                for (loop = 0; loop < (dirsize - 1); loop++)
X                {
X                    free(buffer[loop]);
X                }
X                free(buffer);
X                free(candidate);
X                return NULL;
X            }
X            buffer = tmpbuf;
X        }
X        else
X        {
X            free(candidate);
X        }
X    }
X    buffer[dirsize] = NULL;
X
X    /* FOURTH: clean up, return. */
X
X    closedir(dirhandle);
X    free(temp);
X
X    return buffer;
X} /* end of function scand() */
X
X
X/***************************************************************************
X*   FUNCTION: dfree                                                        *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Returns free space on drive specified in TEMPPATH, or default      *
X*       drive if none specified.                                           *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       temppath - possible drive specifier                                *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns free space on drive, or -1 on error.                       *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xlong
X#ifdef __STDC__
Xdfree(char *temppath)
X#else
Xdfree(temppath)
Xchar *temppath;
X#endif
X{
X    long free;
X    char *usepath;
X    char *dummypath = ".";
X#ifdef USTAT
X    struct stat buf;
X    struct ustat ubuf;
X#endif
X#ifdef STATFS
X    struct statfs fbuf;
X#endif
X#ifdef STATFS_FSDATA
X    struct fs_data fbuf;
X#endif
X
X    /* Use supplied path by default. */
X
X    usepath = temppath;
X
X    /* If temppath is NULL or null string, use dummypath instead. */
X
X    if ((temppath == (char *) NULL) || (temppath[0] == '\0'))
X    {
X        usepath = dummypath;
X    }
X
X#ifdef USTAT
X    if (stat(usepath, &buf) == -1)
X    {
X        return -1;
X    }
X    if (ustat(buf.st_dev, &ubuf) == -1)
X    {
X        return -1;
X    }
X    free = ubuf.f_tfree * SYS_BLOCKSIZE;
X#endif /* USTAT */
X
X#ifdef STATFS
X    if (statfs(usepath, &fbuf) == -1)
X    {
X        return -1;
X    }
X    free = fbuf.f_bavail * fbuf.f_bsize;
X#endif /* STATFS */
X
X#ifdef STATFS_FSDATA
X    if (statfs(usepath, &fbuf) != 1)
X    {
X        return -1;
X    }
X    free = fbuf.fd_req.bfreen * 1024;
X#endif /* STATFS_FSDATA */
X
X    return free;
X} /* end of dfree() */
X
X
X/***************************************************************************
X*   FUNCTION: tempname                                                     *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Verifies that the supplied directory is one we can use, and        *
X*       fakes the operation of tempnam() on systems that don't have it.    *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       dir    - Directory in which to place temporary file.               *
X*       prefix - Characters to start temp name with.                       *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns a pointer to a malloc()'ed buffer containing name.         *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xchar *
X#ifdef __STDC__
Xtempname(char *dir, char *prefix)
X#else
Xtempname(dir, prefix)
Xchar *dir;
Xchar *prefix;
X#endif
X{
X    struct stat statbuf;
X    char name[128];
X    char *pref;
X    char sep;
X
X    static long namecount = 0;
X
X    if (dir != NULL)
X    {
X        /* Is dir a directory? */
X
X        if (stat(dir, &statbuf) == -1)
X        {
X            return NULL;
X        }
X        if ((statbuf.st_mode & S_IFDIR) == 0)
X        {
X            return NULL;
X        }
X    
X        /* Can we create a file in that directory? */
X
X        if (access(dir, 02) == -1)
X        {
X            return NULL;
X        }
X    }
X
X#ifdef TEMPNAM
X    return tempnam(dir, prefix);
X#else
X    if (dir == NULL)
X    {
X        /* If no directory specified, use tmpnam(). */
X
X        tmpnam(name);
X    }
X    else
X    {
X        while (1)
X        {
X            /* Create a name. */
X
X            pref = ((prefix != NULL) ? prefix : "CHI");
X            sep = ((dir[strlen(dir)-1] == '/') ? '_' : '/');
X            sprintf(name, "%s%c%s%05lX", dir, sep, pref, namecount++);
X            if (access(name, 00) == -1)
X            {
X                /* No such file, OK to use. */
X
X                break;
X            }
X            namecount &= 0xFFFFF;
X        }
X    }
X    
X    return (strdup(name));
X#endif /* TEMPNAM */
X} /* end of tempname() */
X
X
X/***************************************************************************
X*   FUNCTION: strdp  STATIC                                                *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       This function returns a pointer to a new string which is the       *
X*       concatenation of the two arguments.                                *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       dupee1 - first string                                              *
X*       dupee2 - second string                                             *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns pointer to new string, or NULL on error.                   *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xstatic char *
X#ifdef __STDC__
Xstrdp(char *dupee1, char *dupee2)
X#else
Xstrdp(dupee1, dupee2)
Xchar *dupee1;
Xchar *dupee2;
X#endif
X{
X    int len;
X    char *wholename, *temp;
X
X    /* Determine necessary length. Add one to allow for null terminator. */
X
X    len = strlen(dupee1) + strlen(dupee2) + 1;
X
X    /* Allocate memory. */
X
X    if ((wholename = (char *) calloc(len, sizeof(char))) == (char *) NULL)
X    {
X        return NULL;
X    }
X
X    /* Copy first argument into result memory. */
X
X    for (temp = wholename; (*temp = *dupee1) != '\0'; temp++, dupee1++) ;
X
X    /* Copy second argument into result memory. */
X
X    for (; (*temp = *dupee2) != '\0'; temp++, dupee2++) ;
X
X    /* Return pointer to string. */
X
X    return wholename;
X} /* end of static function strdp */
X
X
X/***************************************************************************
X*   FUNCTION: coreleft                                                     *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Determines whether the requested amount of memory is available.    *
X*       Must be MINRAM bytes still available after request is filled.      *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       needed - Number of bytes of memory needed.                         *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns 1 if memory is available, 0 if not.                        *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xint
X#ifdef __STDC__
Xcoreleft(long needed)
X#else
Xcoreleft(needed)
Xlong needed;
X#endif
X{
X    char *big;
X    char *leftover;
X
X    /* If SMALL_MEM and asking for more than 64K, forget it. */
X
X#ifdef SMALL_MEM
X    if (needed > MKLONG(65535))
X    {
X        return 0;
X    }
X#endif
X
X    /* Otherwise, attempt to allocate needed amount. */
X
X    if ((big = (char *) malloc(needed)) == NULL)
X    {
X        /* Not available. */
X
X        return 0;
X    }
X
X    /* OK, managed to allocate amount needed, is enough left? */
X
X    if ((leftover = (char *) malloc(MINRAM)) == NULL)
X    {
X        /* Not enough. */
X
X        free(big);
X        return 0;
X    }
X
X    /* Clean up and return. */
X
X    free(big);
X    free(leftover);
X
X    return 1;
X} /* end of coreleft() */
X
X
X/***************************************************************************
X*   FUNCTION: stricmp                                                      *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Provides case-insensitive string compare, which doesn't seem to    *
X*       exist on any system.                                               *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       s1 - First string to compare.                                      *
X*       s2 - Second string to compare.                                     *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       As strcmp().                                                       *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xint
X#ifdef __STDC__
Xstricmp(char *s1, char *s2)
X#else
Xstricmp(s1, s2)
Xchar *s1;
Xchar *s2;
X#endif
X{
X    int i;
X
X    /* Search forward for terminator or first mismatch. */
X
X    for (i = 0; (s1[i] != '\0') && (toupper(s1[i]) == toupper(s2[i])); i++) ;
X    
X    return (((int)(s1[i])) - ((int)(s2[i])));
X} /* end of stricmp() */
X
X
X/***************************************************************************
X*   FUNCTION: strnicmp                                                     *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Provides case-insensitive string compare with limit, which doesn't *
X*       seem to exist on any system.                                       *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       s1  - First string to compare.                                     *
X*       s2  - Second string to compare.                                    *
X*       len - Maximum length to compare.                                   *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       As strncmp().                                                      *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xint
X#ifdef __STDC__
Xstrnicmp(char *s1, char *s2, int len)
X#else
Xstrnicmp(s1, s2, len)
Xchar *s1;
Xchar *s2;
Xint len;
X#endif
X{
X    int i;
X
X    /* Search forward for terminator, limit, or first mismatch. */
X
X    for (i = 0; (s1[i] != '\0') && (toupper(s1[i]) == toupper(s2[i])) &&
X                (i < len); i++) ;
X    
X    return ((i == len) ? 0 : (((int)(s1[i])) - ((int)(s2[i]))));
X} /* end of strnicmp() */
X
X
X#ifdef NO_MEMOP
X
X/***************************************************************************
X*   FUNCTION: memcpy                                                       *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Copies bytes from src to dest, provided for systems which don't    *
X*       have it.                                                           *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       dest - pointer to destination of copy                              *
X*       src  - pointer to source of copy                                   *
X*       n    - number of bytes to copy                                     *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns dest.                                                      *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
XVOID *
X#ifdef __STDC__
Xmemcpy(VOID *dest, VOID *src, unsigned int n)
X#else
Xmemcpy(dest, src, n)
XVOID *dest;
XVOID *src;
Xunsigned int n;
X#endif
X{
X    UCHAR *t1, *t2;
X
X    for (t2 = (UCHAR *) dest, t1 = (UCHAR *) src; n != 0; n--)
X    {
X        t2[n - 1] = t1[n - 1];
X    }
X    return dest;
X} /* end of memcpy() */
X
X
X/***************************************************************************
X*   FUNCTION: memcmp                                                       *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Compares two regions in memory. Provided for systems which don't   *
X*       have it.                                                           *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       s1 - pointer to first region to compare                            *
X*       s2 - pointer to second region to compare                           *
X*       n  - number of bytes to compare                                    *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns 0 if same, -1 or 1 otherwise.                              *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xint
X#ifdef __STDC__
Xmemcmp(VOID *s1, VOID *s2, unsigned int n)
X#else
Xmemcmp(s1, s2, n)
XVOID *s1;
XVOID *s2;
Xunsigned int n;
X#endif
X{
X    unsigned int i;
X    UCHAR *t1, *t2;
X
X    t1 = (UCHAR *) s1;
X    t2 = (UCHAR *) s2;
X    for (i = 0; i < n; i++)
X    {
X        if (t1[i] != t2[i])
X        {
X            break;
X        }
X    }
X    if (i != n)
X    {
X        return ((t1[i] < t2[i]) ? -1 : 1);
X    }
X    return 0;
X} /* end of memcmp() */
X
X#endif /* NO_MEMOP */
X
X
X#ifdef NO_STRDUP
X
X/***************************************************************************
X*   FUNCTION: strdup                                                       *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Duplicates a string. Provided for systems which don't have it.     *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       s1 - string to be duplicated                                       *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns a pointer to a malloc()'ed duplicate.                      *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xchar *
X#ifdef __STDC__
Xstrdup(char *s1)
X#else
Xstrdup(s1)
Xchar *s1;
X#endif
X{
X    char *temp;
X
X    if ((temp = (char *) malloc((strlen(s1) + 1))) == NULL)
X    {
X        return NULL;
X    }
X    strcpy(temp, s1);
X    return temp;
X} /* end of strdup() */
X
X#endif /* NO_STRDUP */
X
X#ifndef DIR_READDIR
X
X/***************************************************************************
X*   FUNCTION: opendir                                                      *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Opens a directory for reading. Provided for systems which don't    *
X*       have it.                                                           *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       dirname - Name of directory to open.                               *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns a pointer to a directory handle, NULL on error.            *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xstatic DIR *
X#ifdef __STDC__
Xopendir(char *dirname)
X#else
Xopendir(dirname)
Xchar *dirname;
X#endif
X{
X    DIR *sendback;
X    int handle;
X    struct stat statbuf;
X
X    /* Check to make sure dirname is a directory. */
X
X    if (stat(dirname, &statbuf) == -1)
X    {
X        return (DIR *) NULL;
X    }
X    if ((statbuf.st_mode & S_IFDIR) == 0)
X    {
X        return (DIR *) NULL;
X    }
X
X    /* Try to open it. */
X
X    handle = open(dirname, O_RDONLY);
X    if (handle == -1)
X    {
X        return (DIR *) NULL;
X    }
X
X    /* Found and opened, so return. */
X
X    if ((sendback = (DIR *) malloc(sizeof(DIR))) == (DIR *) NULL)
X    {
X        close(handle);
X        return (DIR *) NULL;
X    }
X    sendback->fd = handle;
X#ifdef DIR_GETDIRENT
X    sendback->totsize = statbuf.st_size;
X    sendback->blocksize = statbuf.st_blksize;
X    sendback->buffer = (struct dirent *) NULL;
X#endif
X#ifdef DIR_NODIR
X    strcpy(sendback->d_name, dirname);
X    if (dirname[strlen(dirname) - 1] != '/')
X    {
X        strcat(sendback->d_name, "/");
X    }
X#endif
X    
X    return sendback;
X} /* end of opendir() */
X
X
X/***************************************************************************
X*   FUNCTION: readdir                                                      *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Read an entry from an open directory. Provided for systems which   *
X*       don't have it.                                                     *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       dirp - pointer to directory handle of directory to read from       *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Pointer to directory entry, NULL on error or end of directory.     *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xstatic struct dirent *
X#ifdef __STDC__
Xreaddir(DIR *dirp)
X#else
Xreaddir(dirp)
XDIR *dirp;
X#endif
X{
X    int nbytes;
X
X#ifdef DIR_GETDENTS
X    static struct dirent holding;
X
X    /* Attempt to read from directory. */
X
X    if ((nbytes = getdents(dirp->fd, &holding, sizeof(struct dirent))) == -1)
X    {
X        return (struct dirent *) NULL;
X    }
X
X    /* Is end of directory? */
X
X    if (nbytes == 0)
X    {
X        return (struct dirent *) NULL;
X    }
X
X    /* Read OK, so set pointer for next time (in case we read more than one). */
X
X    if (lseek(dirp->fd, holding.d_off, SEEK_SET) == -1)
X    {
X        return (struct dirent *) NULL;
X    }
X
X    /* Return pointer to holding. */
X
X    return &holding;
X#endif /* DIR_GETDENTS */
X
X#ifdef DIR_GETDIRENT
X    int allocsize;
X    long basep;
X    struct dirent *current;
X
X    /* If buffer hasn't been filled, allocate it and fill. */
X
X    if (dirp->buffer == (struct dirent *) NULL)
X    {
X        /* Allocate memory to hold the entire directory (we hope). */
X
X        allocsize = ((dirp->totsize > dirp->blocksize) ? dirp->totsize :
X                                                         dirp->blocksize);
X        dirp->buffer = (struct dirent *) malloc(allocsize);
X        if (dirp->buffer == (struct dirent *) NULL)
X        {
X            return (struct dirent *) NULL;
X        }
X
X        /* Try to read the directory in. */
X
X        if ((nbytes = getdirentries(dirp->fd, (char *) dirp->buffer,
X                                    allocsize, &basep)) == -1)
X        {
X            free(dirp->buffer);
X            dirp->buffer = (struct dirent *) NULL;
X            return (struct dirent *) NULL;
X        }
X
X        /* Read again -- should return 0 (end of directory). */
X
X        if (getdirentries(dirp->fd, (char *) dirp->buffer, allocsize, &basep)
X            != 0)
X        {
X            free(dirp->buffer);
X            dirp->buffer = (struct dirent *) NULL;
X            return (struct dirent *) NULL;
X        }
X
X        /* Initialize position pointers. */
X
X        for (current = dirp->buffer;
X             (((char *)current) - ((char *)dirp->buffer)) < nbytes;
X             current = (struct dirent *)(((char *)current)+current->d_reclen)) ;
X        dirp->lastentry = current;
X        dirp->nextentry = dirp->buffer;
X    }
X
X    /* Have we run off end? */
X
X    if (dirp->nextentry == (struct dirent *) NULL)
X    {
X        return dirp->nextentry;
X    }
X
X    current = dirp->nextentry;
X    if (dirp->nextentry == dirp->lastentry)
X    {
X        /* This was the last one, so set nextentry to NULL. */
X
X        dirp->nextentry = (struct dirent *) NULL;
X    }
X    else
X    {
X        /* Otherwise increment. */
X
X        dirp->nextentry = (struct dirent *)(((char *)dirp->nextentry) +
X                                            dirp->nextentry->d_reclen);
X    }
X
X    return current;
X#endif /* DIR_GETDIRENT */
X
X#ifdef DIR_NODIR
X    static struct dirent holding;
X    char namebuf[DIRSIZ + 1];
X    char *testname;
X    struct stat statbuf;
X
X    while (1)
X    {
X        /* Attempt to read from directory. */
X
X        if ((nbytes = getdents(dirp->fd, &holding, sizeof(struct dirent))) ==
X            -1)
X        {
X            return (struct dirent *) NULL;
X        }
X
X        /* Is end of directory? */
X
X        if (nbytes == 0)
X        {
X            return (struct dirent *) NULL;
X        }
X
X        /* Does this file actually still exist? */
X
X        strncpy(namebuf, holding.d_name, DIRSIZ);
X        namebuf[DIRSIZ] = '\0';
X        if ((testname = strdp(dirp->d_name, namebuf)) == NULL)
X        {
X            return (struct dirent *) NULL;
X        }
X        if (stat(testname, &statbuf) != -1)
X        {
X            /*
X            ** File still exists, but is this a phantom with the same
X            ** same as another file? Check inode numbers to be sure.
X            */
X
X            if (statbuf.st_ino == holding.d_ino)
X            {
X                /* Is a real file, break out and return OK. */
X
X                free(testname);
X                break;
X            }
X
X            /* Is a phantom -- keep going. */
X
X        }
X        else if (errno != ENOENT)
X        {
X            /* Serious error. */
X
X            free(testname);
X            return (struct dirent *) NULL;
X        }
X
X        /* File does not exist, but may be more so keep going. */
X        free(testname);
X    }
X
X    /* Return pointer to holding. */
X
X    return &holding;
X#endif /* DIR_NODIR */
X} /* end of readdir() */
X
X
X/***************************************************************************
X*   FUNCTION: closedir                                                     *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Closes a directory previously opened with opendir. Provided for    *
X*       systems which don't have it.                                       *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       dirp - pointer to handle of directory to be closed                 *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns 0 on success, -1 on error.                                 *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xstatic int
X#ifdef __STDC__
Xclosedir(DIR *dirp)
X#else
Xclosedir(dirp)
XDIR *dirp;
X#endif
X{
X    int handle = dirp->fd;
X
X#ifdef DIR_GETDIRENT
X    if (dirp->buffer != (struct dirent *) NULL)
X    {
X        free(dirp->buffer);
X    }
X#endif
X
X    /* Attempt to close directory. */
X
X    return (close(handle));
X} /* end of closedir() */
X
X
X#ifdef DIR_NODIR
X
X/***************************************************************************
X*   FUNCTION: getdents  STATIC                                             *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Reads a directory entry on a system which has no directory         *
X*       functions at all. Makes the life of readdir() on such systems      *
X*       easier.                                                            *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       fd     - file descriptor from which to read                        *
X*       buf    - buffer into which to read                                 *
X*       nbytes - maximum number of bytes to be read                        *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns number of bytes actually read, -1 on error.                *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xstatic int
X#ifdef __STDC__
Xgetdents(int fd, char *buf, int nbytes)
X#else
Xgetdents(fd, buf, nbytes)
Xint fd;
Xchar *buf;
Xint nbytes;
X#endif
X{
X    int readbytes;
X
X    /* enough room? */
X    if (nbytes < sizeof(struct dirent))
X    {
X        return -1;
X    }
X
X    /* read */
X    if ((readbytes = read(fd, buf, nbytes)) == -1)
X    {
X        return -1;
X    }
X
X    if ((readbytes != nbytes) && (readbytes != 0))
X    {
X        /* oops */
X        return -1;
X    }
X
X    return readbytes;
X} /* end of static getdents() */
X
X#endif /* DIR_NODIR */
X
X#endif /* ! DIR_READDIR */
X
X
X#ifdef NO_RENAME
X
X/***************************************************************************
X*   FUNCTION: rename                                                       *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Renames a file. Provided for systems which don't have it.          *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       path1 - current name of file                                       *
X*       path2 - new name for file                                          *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns 0 on success, -1 on error.                                 *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xint
X#ifdef __STDC__
Xrename(char *path1, char *path2)
X#else
Xrename(path1, path2)
Xchar *path1;
Xchar *path2;
X#endif
X{
X    /* create new link to file first */
X    if (link(path1, path2) == -1)
X    {
X        return -1;
X    }
X    /* now try to unlink old name */
X    if (unlink(path1) == -1)
X    {
X        return -1;
X    }
X    return 0;
X} /* end of rename() */
X
X#endif /* NO_RENAME */
X
END_OF_FILE
  if test 42953 -ne `wc -c <'src/depend.c'`; then
    echo shar: \"'src/depend.c'\" unpacked with wrong size!
  fi
  # end of 'src/depend.c'
fi
if test -f 'templates/linux-gcc.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'templates/linux-gcc.h'\"
else
  echo shar: Extracting \"'templates/linux-gcc.h'\" \(393 characters\)
  sed "s/^X//" >'templates/linux-gcc.h' <<'END_OF_FILE'
X/*
X** Configuration for Linux 0.99p5 (and possibly other versions) with GCC.
X** Provided by Peter Couvares (pfcouvar@unix.amherst.edu).
X*/
X
X#define CONFIG_H
X
X/* statfs() function present */
X#define STATFS
X
X/* readdir() et al. functions present */
X#define DIR_READDIR
X
X/* tempnam() function present */
X#define TEMPNAM
X
X/* Only superuser can give away a file with chown() */
X#define ROOT_CHOWN
X
END_OF_FILE
  if test 393 -ne `wc -c <'templates/linux-gcc.h'`; then
    echo shar: \"'templates/linux-gcc.h'\" unpacked with wrong size!
  fi
  # end of 'templates/linux-gcc.h'
fi
if test -f 'templates/template.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'templates/template.h'\"
else
  echo shar: Extracting \"'templates/template.h'\" \(8705 characters\)
  sed "s/^X//" >'templates/template.h' <<'END_OF_FILE'
X/*
X** This is the template configuration header. It contains all possible
X** options and their explanations. To configure this file for a particular
X** system, edit it, setting the various options as necessary for your
X** system.
X*/
X
X/* to let other files know this one has been included -- DO NOT CHANGE! */
X#define CONFIG_H
X
X
X
X/*********************************************
X** HEADER FILES
X** Configuration options having to do with the presence or absence
X** of various header files.
X*/
X
X/*
X** STDLIB: Define this symbol if there is no stdlib.h include file for
X** your compiler.
X*/
X/* #define NO_STDLIB */
X
X/*
X** MALLOCHDR: Define this symbol if there is no malloc.h include file
X** for your compiler.
X*/
X/* #define NO_MALLOCHDR */
X
X/*
X** UTIME: define this symbol if there is a utime.h include file for
X** your compiler.
X*/
X/* #define UTIME_HDR */
X
X/*
X** ERRNO: Define this symbol if your errno.h include file does not
X** declare the external variable "int errno".
X*/
X/* #define NO_ERRNO */
X
X/*
X** STRING: Some systems have an include file string.h; others have
X** strings.h; and some don't have either. Define NO_STR_INC if your
X** system does not have either file; define STRING_PLURAL if your
X** system has strings.h instead of string.h.
X*/
X/* #define NO_STR_INC */
X/* #define STRING_PLURAL */
X
X
X
X/*********************************************
X** TYPES
X** Configuration options having to do with the ability of the compiler
X** to handle various data types.
X*/
X
X/*
X** UNSIGNED CHAR: Define this symbol if your compiler does not support
X** the type "unsigned char".
X*/
X/* #define NO_UCHAR */
X
X/*
X** VOID: Define this symbol if your compiler does not support the type
X** "void". Some compilers may only partially support this type -- if you
X** get errors about bad types even though the compiler claims to support
X** the void type, try defining this symbol.
X*/
X/* #define NO_VOID */
X
X/*
X** UNSIGNED LONG: Define this symbol if your compiler does not support
X** the type "unsigned long".
X*/
X/* #define NO_ULONG */
X
X/*
X** INT16: Define this symbol if type "int" is 16 bits on your system
X** instead of 32.
X*/
X/* #define INT16 */
X
X/*
X** CONST: Define this symbol if your compiler does not recognize the
X** type modifier "const".
X*/
X/* #define NO_CONST */
X
X
X
X/*********************************************
X** FUNCTIONS
X** Configuration options having to do with the presence or absence of
X** various functions in the libraries supplied with the compiler.
X*/
X
X/*
X** MEMORY OPERATIONS: Define this symbol if your compiler's standard
X** library does not have the functions memcpy() or memcmp(). In the
X** manual pages, these functions are typically listed under "memory" in
X** section 3, if they are present.
X*/
X/* #define NO_MEMOP */
X
X/*
X** DISKFREE: If your system has the function statfs() and it returns data
X** in a "struct statfs", define the symbol STATFS. If your system has the
X** function statfs() and it returns data in a "struct fs_data" (Ultrix
X** systems), define the symbol STATFS_FSDATA. If your system has the function
X** ustat(), define the symbols USTAT and SYS_BLOCKSIZE. SYS_BLOCKSIZE is the
X** size, in bytes, of a disk block on your system. If you don't know this,
X** just leave it at 512, which is its default value. One of STATFS,
X** STATFS_FSDATA, or USTAT _must_ be defined.
X*/
X/* #define STATFS */
X/* #define STATFS_FSDATA */
X/*
X** #define USTAT
X** #define SYS_BLOCKSIZE       512
X*/
X
X/*
X** STRDUP: define this symbol if your compiler's standard library
X** does not have the function strdup(). In the manual pages, this function
X** is typically listed under "string" in section 3, if it is present.
X*/
X/* #define NO_STRDUP */
X
X/*
X** DIRECTORY ACCESS: Define one of these symbols according to which
X** functions your system has. If your system has the opendir()/readdir()
X** set of functions, define DIR_READDIR. Modern systems have these
X** functions. Older systems may have getdents(); if so, define
X** DIR_GETDENTS. Old Sun systems may have getdirentries(); if so,
X** define DIR_GETDIRENT. If your system has none of these functions,
X** define DIR_NODIR. One of these symbols _must_ be defined.
X** NOTE: if your system supports long filenames (>14 characters), it will
X** almost certainly have one of the functions listed above.
X*/
X/* #define DIR_READDIR */
X/* #define DIR_GETDENTS */
X/* #define DIR_GETDIRENT */
X/* #define DIR_NODIR */
X
X/*
X** TEMPORARY FILENAMES: Define this symbol if your compiler's standard
X** library has the function tempnam().
X*/
X/* #define TEMPNAM */
X
X/*
X** RENAME: Define this symbol if your compiler's standard library does
X** not have the function rename().
X*/
X/* #define NO_RENAME */
X
X
X
X/*********************************************
X** SYSTEM and MISC
X** Configuration options about the system in general, capabilities of
X** standard library functions, etc.
X*/
X
X/*
X** TERMINFO or TERMCAP: Most systems have information about terminals which
X** may be accessed via terminfo (newer), termcap (older), or both. Chils
X** uses this information to determine the width of the terminal in columns.
X** If your system has terminfo, define HAS_TERMINFO and define TERMINFO_PATH
X** as the fully-qualified name of the tput program used with terminfo
X** (see the example below). If your system has termcap, define HAS_TERMCAP. 
X** If your system has neither, the width is assumed to be 80 columns. In any
X** case, the width may be overridden with the -w option. If your system
X** has both, you can use both with no ill effects. Note that some systems
X** with both may have information on more terminals in one or the other.
X** Also note that if you use termcap, you will probably need to modify the
X** makefile template to include the termcap library in the link.
X*/
X/*
X** #define HAS_TERMINFO
X** #define TERMINFO_PATH       "/usr/5bin/tput"
X*/
X/* #define HAS_TERMCAP */
X
X/*
X** FOPEN: Most systems do not distinguish between binary and text files, so
X** the defaults of "r" for reading a file and "w" for writing a file are
X** OK. If your system requires a different string to open a file in raw
X** (binary) mode, define the appropriate symbol to be the appropriate
X** string (for example, "rb" and "wb").
X*/
X/* #define FOPEN_READ_BINARY   "rb" */
X/* #define FOPEN_WRITE_BINARY  "wb" */
X
X/*
X** FSEEK: These three symbols are usually already defined in standard
X** include files. If they are not defined in the standard include files,
X** they will default to the values shown. If your system requires different
X** values for the function fseek(), define them here.
X*/
X/*
X** #define SEEK_SET            0
X** #define SEEK_CUR            1
X** #define SEEK_END            2
X*/
X
X/*
X** MEMORY SIZE: Define this symbol if your system limits the maximum size
X** of a process to 128K or less. In general, only very old systems have
X** this sort of restriction.
X*/
X/* #define SMALL_MEM */
X
X/*
X** MINIMUM MEMORY: This symbol determines the minimum amount of memory
X** that should be left free after allocating large buffers. It defaults
X** to 10K bytes. If you experience "out of memory" problems, try increasing
X** this value. Insufficient memory can also manifest as failures when
X** opening files and other seemingly-unrelated problems. If you get
X** inexplicable errors, try increasing this value.
X*/
X/* #define MINRAM              10240 */
X
X/*
X** CHOWN USE: Define this symbol if only root (the superuser) can give
X** away a file with the function chown(). This is true for most BSD-based
X** systems, and false for most SysIII/SysV-based systems. If you don't
X** know, leave it undefined -- it won't hurt anything.
X*/
X/* #define ROOT_CHOWN */
X
X/*
X** NULL DEVICE: This symbol is the full path to the null device. It
X** defaults to "/dev/null", which is correct for most systems. If the
X** null device on your system has a different name, define this symbol
X** to be the full path to it.
X*/
X/* #define NULL_DEVICE          "/dev/null" */
X
X
X
X/*********************************************
X** PREFERENCES
X** Configuration options which are a matter of user preference, affecting
X** the user interface.
X*/
X
X/*
X** PROGRESS INDICATOR: If this symbol is defined, it enables a small
X** progress indicator in the program gifcheck, which is displayed when
X** a GIF image is being decompressed. On fast systems, the decompression
X** does take very long, and the progress indicator may become invisible
X** or appear not to be moving at all. In general, it is only worth
X** enabling the progress indicator on very slow systems.
X*/
X/* #define PROGRESS_IND */
X
X/*
X** COMPLEX SEARCH: If you prefer the DOS symbol usage when specifying
X** complex patterns to chils, define this symbol. See the manual page
X** for chils for information on the symbols used.
X*/
X/* #define DOS_COMSRCH */
X
END_OF_FILE
  if test 8705 -ne `wc -c <'templates/template.h'`; then
    echo shar: \"'templates/template.h'\" unpacked with wrong size!
  fi
  # end of 'templates/template.h'
fi
echo shar: End of archive 4 \(of 18\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
