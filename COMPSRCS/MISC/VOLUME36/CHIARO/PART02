Newsgroups: comp.sources.misc
From: jwbirdsa@picarefy.picarefy.com (James W. Birdsall)
Subject: v36i072:  chiaro - Image Utilities, Part02/18
Message-ID: <1993Mar25.180932.19878@sparky.imd.sterling.com>
X-Md4-Signature: e3dad866687630cb75736edd0e8a4bd1
Date: Thu, 25 Mar 1993 18:09:32 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jwbirdsa@picarefy.picarefy.com (James W. Birdsall)
Posting-number: Volume 36, Issue 72
Archive-name: chiaro/part02
Environment: UNIX, Sun, DECstation, 3B1

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  src/Makefile src/gifstrip.c
# Wrapped by kent@sparky on Thu Mar 25 11:20:00 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 18)."'
if test -f 'src/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/Makefile'\"
else
  echo shar: Extracting \"'src/Makefile'\" \(4530 characters\)
  sed "s/^X//" >'src/Makefile' <<'END_OF_FILE'
X#
X# Makefile for the Chiaro suite.
X#
X# Copyright (c) 1993 by James W. Birdsall, all rights reserved.
X#
X
Xinclude template.mk
X
XCCC	= $(CC) $(CFLAGS) $(CINC)
XLLL	= $(LINK) $(LFLAGS)
X
X
Xall:	chils$(EXE) gifstrip$(EXE) gifcheck$(EXE)
X
X
Xclean:
X	$(RM) core *.$O chils$(EXE) gifstrip$(EXE) gifcheck$(EXE)
X	$(RM) fbro.c gifnofb.c gldc.c gldm.c pgm.c ppm.c
X
X
Xchils$(EXE):	chils.$O depend.$O comsrch.$O fbro.$O chidisp.$O \
X		formats.$O re.$O token.$O \
X		gifnofb.$O img.$O jfif.$O sr.$O tga.$O pbm.$O pgm.$O \
X		ppm.$O xbm.$O bmp.$O pcx.$O
X	$(LLL) -o $@ $(LOBJS) chils.$O depend.$O comsrch.$O fbro.$O chidisp.$O \
X		formats.$O re.$O token.$O gifnofb.$O img.$O jfif.$O sr.$O \
X		tga.$O pbm.$O pgm.$O ppm.$O xbm.$O bmp.$O pcx.$O $(LLIBS)
X	$(POST_CHILS)
X
Xgifstrip$(EXE):	gifstrip.$O depend.$O stdinarg.$O gif.$O fb.$O mf.$O
X	$(LLL) -o $@ $(LOBJS) gifstrip.$O depend.$O stdinarg.$O gif.$O fb.$O \
X		 mf.$O $(LLIBS)
X	$(POST_GIFSTRIP)
X
Xgifcheck$(EXE):	gifcheck.$O depend.$O stdinarg.$O fb.$O colors.$O blocproc.$O \
X		gif.$O gldm.$O 
X	$(LLL) -o $@ $(LOBJS) gifcheck.$O depend.$O stdinarg.$O fb.$O \
X		colors.$O blocproc.$O gif.$O gldm.$O $(LLIBS)
X	$(POST_GIFCHECK)
X
X
Xblocproc.$O:	blocproc.c config.h depend.h fb.h formats.h gif.h gld.h \
X		colors.h gifcheck.h blocproc.h
X	$(CCC) blocproc.c
X
Xbmp.$O:		bmp.c config.h depend.h formats.h bmp.h
X	$(CCC) bmp.c
X
Xchidisp.$O:	chidisp.c config.h depend.h fb.h formats.h gif.h img.h \
X		jfif.h sr.h tga.h pnm.h xbm.h bmp.h pcx.h chils.h chidisp.h
X	$(CCC) chidisp.c
X
Xchils.$O:	chils.c config.h depend.h chils.h fb.h formats.h gif.h \
X		img.h jfif.h sr.h tga.h pnm.h xbm.h bmp.h pcx.h comsrch.h \
X		patchlevel.h
X	$(CCC) chils.c
X
Xcolors.$O:	colors.c config.h depend.h formats.h colors.h
X	$(CCC) colors.c
X
Xcomsrch.$O:	comsrch.c config.h depend.h formats.h comsrch.h
X	$(CCC) comsrch.c
X
Xdepend.$O:	depend.c config.h depend.h
X	$(CCC) depend.c
X
Xfb.$O:		fb.c config.h fb.h depend.h
X	$(CCC) fb.c
X
Xfbro.$O:	fb.c config.h fb.h depend.h
X	$(RM) fbro.c
X	$(LN) fb.c fbro.c
X	$(CCC) -DREADONLY fbro.c
X	$(RM) fbro.c
X
Xformats.$O:	formats.c config.h depend.h fb.h formats.h gif.h img.h \
X		jfif.h sr.h tga.h pnm.h xbm.h bmp.h pcx.h
X	$(CCC) formats.c
X
Xgif.$O:		gif.c config.h depend.h fb.h formats.h gif.h
X	$(CCC) gif.c
X
Xgifnofb.$O:	gif.c config.h depend.h fb.h formats.h gif.h
X	$(RM) gifnofb.c
X	$(LN) gif.c gifnofb.c
X	$(CCC) -DNO_FB gifnofb.c
X	$(RM) gifnofb.c
X
Xgifcheck.$O:	gifcheck.c config.h depend.h fb.h formats.h gif.h gld.h \
X		colors.h gifcheck.h blocproc.h stdinarg.h patchlevel.h
X	$(CCC) gifcheck.c
X
Xgifstrip.$O:	gifstrip.c config.h depend.h fb.h mf.h formats.h gif.h \
X		stdinarg.h patchlevel.h
X	$(CCC) gifstrip.c
X
Xgldc.$O:	gld.c config.h depend.h gld.h
X	$(RM) gldc.c
X	$(LN) gld.c gldc.c
X	$(CCC) -DCODE_CHECK gldc.c
X	$(RM) gldc.c
X
Xgldm.$O:	gld.c config.h depend.h gld.h
X	$(RM) gldm.c
X	$(LN) gld.c gldm.c
X	$(CCC) -DMINIMAL gldm.c
X	$(RM) gldm.c
X
Ximg.$O:		img.c config.h depend.h formats.h img.h
X	$(CCC) img.c
X
Xjfif.$O:	jfif.c config.h depend.h fb.h formats.h jfif.h
X	$(CCC) jfif.c
X
Xmf.$O:		mf.c config.h depend.h mf.h fb.h
X	$(CCC) mf.c
X
Xpbm.$O:		pbm.c config.h depend.h formats.h token.h pnm.h
X	$(CCC) pbm.c
X
Xpcx.$O:		pcx.c config.h depend.h formats.h pcx.h
X	$(CCC) pcx.c
X
Xpgm.$O:		pgmppm.c depend.h formats.h token.h pnm.h
X	$(RM) pgm.c
X	$(LN) pgmppm.c pgm.c
X	$(CCC) -DPGM pgm.c
X	$(RM) pgm.c
X
Xppm.$O:		pgmppm.c depend.h formats.h token.h pnm.h
X	$(RM) ppm.c
X	$(LN) pgmppm.c ppm.c
X	$(CCC) ppm.c
X	$(RM) ppm.c
X
Xre.$O:		re.c config.h depend.h formats.h re.h fb.h gif.h img.h \
X		jfif.h sr.h tga.h pnm.h xbm.h bmp.h pcx.h
X	$(CCC) re.c
X
Xsr.$O:		sr.c config.h depend.h formats.h sr.h
X	$(CCC) sr.c
X
Xstdinarg.$O:	stdinarg.c config.h depend.h stdinarg.h
X	$(CCC) stdinarg.c
X
Xtga.$O:		tga.c config.h depend.h formats.h tga.h
X	$(CCC) tga.c
X
Xtoken.$O:	token.c config.h depend.h formats.h token.h
X	$(CCC) token.c
X
Xxbm.$O:		xbm.c config.h depend.h formats.h xbm.h token.h
X	$(CCC) xbm.c
X
X
Xbmp.h:	status.h
X
Xfb.h:	status.h
X
Xformats.h:	re.h
X
Xgif.h:	status.h
X
Xgld.h:	status.h
X
Ximg.h:	status.h
X
Xjfif.h:	status.h
X
Xmf.h:	status.h
X
Xpbm.h:	status.h
X
Xpcx.h:	status.h
X
Xpgm.h:	status.h
X
Xpnm.h:	status.h pbm.h pgm.h ppm.h
X
Xppm.h:	status.h
X
Xre.h:	status.h
X
Xsr.h:	status.h
X
Xtga.h:	status.h
X
Xxbm.h:	status.h
X
X
X#
X# WARNING: THESE TARGETS ARE FOR TEST USE ONLY.
X#
Xgldtest3$(EXE):	gldtest3.$O gif.$O gldc.$O fb.$O depend.$O
X	$(LLL) -o $@ $(LOBJS) gldtest3.$O gif.$O gldc.$O fb.$O depend.$O \
X		$(LLIBS)
X
Xgldtest3.$O:	gldtest3.c config.h depend.h fb.h formats.h gif.h gld.h
X	$(CCC) gldtest3.c
X
Xgldtest3.c:	../masters/gldtest3.c
X	$(CP) ../masters/gldtest3.c .
END_OF_FILE
  if test 4530 -ne `wc -c <'src/Makefile'`; then
    echo shar: \"'src/Makefile'\" unpacked with wrong size!
  fi
  # end of 'src/Makefile'
fi
if test -f 'src/gifstrip.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/gifstrip.c'\"
else
  echo shar: Extracting \"'src/gifstrip.c'\" \(47919 characters\)
  sed "s/^X//" >'src/gifstrip.c' <<'END_OF_FILE'
X/***************************************************************************
X*   GIFSTRIP.C                                                             *
X*   MODULE:  -                                                             *
X*   OS:      UNIX                                                          *
X*                                                                          *
X*   Copyright (c) 1993 James W. Birdsall. All Rights Reserved.             *
X*                                                                          *
X*   The Graphics Interchange Format(c) is the Copyright property of        *
X*   CompuServe Incorporated. GIF(sm) is a Service Mark property of         *
X*   CompuServe Incorporated.                                               *
X*                                                                          *
X*   $Id: gifstrip.c,v 1.10 1993/03/02 00:49:36 jwbirdsa Exp $
X*                                                                          *
X*   Chiaro suite GIF rebuild program.                                      *
X*                                                                          *
X***************************************************************************/
X
X#include "config.h"
X
X/*
X** system includes <>
X*/
X
X#include <stdio.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#ifndef NO_STDLIB
X#include <stdlib.h>
X#endif
X#ifndef NO_MALLOCHDR
X#include <malloc.h>
X#endif
X#ifndef NO_STR_INC
X#ifdef STRING_PLURAL
X#include <strings.h>
X#else
X#include <string.h>
X#endif
X#endif
X#ifdef UTIME_HDR
X#include <utime.h>
X#endif
X
X
X/*
X** custom includes ""
X*/
X
X#include "depend.h"
X
X#include "fb.h"
X#include "mf.h"
X
X#include "formats.h"
X#include "gif.h"
X
X#include "stdinarg.h"
X
X#include "patchlevel.h"
X
X
X/*
X** local #defines
X*/
X
X#define FB_TABLESIZE         5
X#ifdef SMALL_MEM
X#define FB_BUFSIZE           4096
X#else
X#define FB_BUFSIZE           30000
X#endif
X
X#define TBUFSIZ              15
X
X#define EARLY                0
X#define LATE                 1
X
X/* Returns from strip(). */
X
X#define EXIT_OK              0
X#define EXIT_NOTGIF          1
X#define EXIT_UNEOF           2
X#define EXIT_ERROR           3
X
X
X/*
X** misc: copyright strings, version macros, etc.
X*/
X
Xstatic char CONST copyright[] = "Copyright (c) 1992 James W. Birdsall. All Rights Reserved";
Xstatic char CONST rcsid[] = "$Id: gifstrip.c,v 1.10 1993/03/02 00:49:36 jwbirdsa Exp $";
X
X#define VERS                 "2.0"
X
X
X/*
X** typedefs
X*/
X
X#ifndef UTIME_HDR
Xstruct utimbuf
X{
X    time_t actime;
X    time_t modtime;
X};
X#endif
X
X/*
X** global variables
X*/
X
X/*
X** static globals
X*/
X
X/* Default: use memory and disk. */
X
Xstatic int mf_flags = (USE_CONMEM | USE_DISKMEM);
X
X/* Default: no recopy if no extra bytes or no format violations. */
X
Xstatic int forced_copy = 0;
X
X/* Default: strict format -- report and recopy on format violations. */
X
Xstatic int strict = 1;
X
X/* Default: assume no leading junk. */
X
Xstatic int nolead = 1;
X
X/* Default: late unlink. */
X
Xstatic int unlinktime = LATE;
X
X/* File handles for standard and error output. */
X
Xstatic FILE *outstr = stdout;
Xstatic FILE *outerr = stdout;
X
X/* Temporary file path. */
X
Xstatic char *tpath = (char *) NULL;
X
X/* Global scratch space. */
X
Xstatic char scratch[80];
X
X
X/*
X** function prototypes
X*/
X
X#ifdef  __STDC__
X# define P_(s) s
X#else
X# define P_(s) ()
X#endif
X
Xstatic int strip P_((char *filename));
X
Xstatic VOID usage();
Xstatic char *errxlate P_((ULONG errcode));
X
X#undef P_
X
X#ifdef NO_STR_INC
X#ifndef NO_STRDUP
Xextern char *strdup();
X#endif
X#endif
X
X
X/*
X** functions
X*/
X
X
X/***************************************************************************
X *   FUNCTION MAIN                                                         *
X ***************************************************************************/
X#ifdef __STDC__
Xmain(int argc, char *argv[])
X#else
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X#endif
X{
X    int loop, loop2;
X    int onlyflags = 1;
X    int argcc;
X    char **argvv;
X    char **namelist;
X    char separator;
X    char *temp;
X    int stdinkey = 1;    /* Nonzero = stdin is keyboard, zero = redirected. */
X    int errorlevel;
X
X    /* Search for option and parse if found. */
X
X    for(loop = 1; loop < argc; loop++)
X    {
X        if ('-' == argv[loop][0])
X        {
X            switch (argv[loop][1])
X            {
X                /* Don't use memory. */
X                case 'c':
X                    mf_flags &= (~(USE_CONMEM));
X                    if ((mf_flags & USE_MASK) == 0)
X                    {
X                        fprintf(outerr, "ERROR: Cannot process files unless some form of temporary storage is\n");
X                        fprintf(outerr, "available and allowed. Type GIFSTRIP -h for usage.\n");
X                        exit(EXIT_ERROR);
X                    }
X                    break;
X
X                /* Don't use disk. */
X                case 'd':
X                    mf_flags &= (~(USE_DISKMEM));
X                    if ((mf_flags & USE_MASK) == 0)
X                    {
X                        fprintf(outerr, "ERROR: Cannot process files unless some form of temporary storage is\n");
X                        fprintf(outerr, "available and allowed. Type GIFSTRIP -h for usage.\n");
X                        exit(EXIT_ERROR);
X                    }
X                    break;
X
X                /* Safety mode, use only disk. */
X                case 's':
X                    mf_flags &= (~(USE_CONMEM));
X                    if ((mf_flags & USE_MASK) == 0)
X                    {
X                        fprintf(outerr, "ERROR: Cannot process files unless some form of temporary storage is\n");
X                        fprintf(outerr, "available and allowed. Type GIFSTRIP -h for usage.\n");
X                        exit(EXIT_ERROR);
X                    }
X                    break;
X
X                /* Batch mode option. */
X                case 'b': 
X                    if ((outstr = fopen(NULL_DEVICE, "w")) == (FILE *) NULL)
X                    {
X                        fprintf(stderr, "ERROR: Cannot open %s\n", NULL_DEVICE);
X                        exit(EXIT_ERROR);
X                    }
X                    outerr = outstr;
X                    break;
X
X                /* Force rebuild of file. */
X                case 'f':
X                    forced_copy = 1;
X                    break;
X
X                /* Disable strict format enforcement. */
X                case 'n':
X                    strict = 0;
X                    break;
X
X                /* Allow handling of leading junk. */
X                case 'm':
X                    nolead = 0;
X                    break;
X 
X                /* Redirect errors to stderr. */
X                case 'r':
X                    outerr = stderr;
X                    break;
X
X                /* Overwrite original file early. */
X                case 'o':
X                    unlinktime = EARLY;
X                    break;
X
X                /* Specify temporary path. */
X                case 't':
X                    if ((tpath = strdup(&(argv[loop][2]))) == (char *) NULL)
X                    {
X                        fprintf(stderr, "ERROR: Out of memory.\n");
X                        exit(EXIT_ERROR);
X                    }
X                    break;
X
X                /* Take filenames from stdin. */
X                case '-':
X                    stdinkey = 0;
X                    break;
X
X                /* Help option. */
X                case 'h':
X                /* Unknown option. */
X                default:
X                    usage();
X                    break;
X            }
X        }
X        else
X        {
X            /*
X            ** onlyflags == 1 when the command line contains only options.
X            ** If this clause is executed, means there is at least one arg
X            ** which is not an option and therefore is a target.
X            */
X
X            onlyflags = 0;
X        }
X    }
X
X    /* If no target(s) specified and stdin not redirected, error. */
X
X    if ((onlyflags != 0) && (stdinkey != 0))
X    {
X        usage();
X    }
X
X    /* Initialize file buffering package. */
X
X    if (fb_init(FB_TABLESIZE, FB_BUFSIZE) != 0)
X    {
X        fprintf(outerr, "%s\n", fb_errstring(fb_error));
X        exit(EXIT_ERROR);
X    }
X
X    /* Check for stdin redirection -- load targets from stdin if redirected. */
X
X    if (stdinkey != 0)
X    {
X        argcc = argc;
X        argvv = argv;
X    }
X    else
X    {
X        argvv = stdinload(&argcc);
X        argvv[0] = argv[0];
X    }
X
X    /* Loop through targets, processing. */
X
X    for(loop = 1; loop < argcc; loop++)
X    {
X        if (argvv[loop][0] != '-')
X        {
X            /* Extract an argument from the command line and expand it. */
X
X            if ((namelist = scand(argvv[loop])) == NULL)
X            {
X                fprintf(outerr, "ERROR: bad target %s\n", argvv[loop]);
X                continue;
X            }
X            else if (NULL == namelist[0])
X            {
X                fprintf(outerr, "WARNING: No files matching %s found.\n",
X                        argvv[loop]);
X                continue;
X            }
X
X            /* Strip each file. */
X
X            for(loop2 = 0; namelist[loop2]; loop2++)
X            {
X                fprintf(outstr, "\nProcessing %s...\n", namelist[loop2]);
X                errorlevel = strip(namelist[loop2]);
X            }
X
X            /* Cleanup. */
X
X            for(loop2 = 0; namelist[loop2]; loop2++)
X            {
X                free(namelist[loop2]);
X            }
X            free(namelist);
X            if (0 == stdinkey)
X            {
X                free(argvv[loop]);
X            }
X        }
X    }
X
X    /* Cleanup. */
X
X    if (0 == stdinkey)
X    {
X        free(argvv);
X    }
X
X    exit(errorlevel);
X} /* end of main */
X
X
X/***************************************************************************
X*   FUNCTION:    strip  STATIC                                             *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       This function rebuilds the named file, if necessary.               *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       filename - name of file to be rebuilt. May include drive and/or    *
X*                  path.                                                   *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns EXIT_OK, EXIT_NOTGIF, or EXIT_ERROR, depending.            *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xstatic int
X#ifdef __STDC__
Xstrip(char *filename)
X#else
Xstrip(filename)
Xchar *filename;
X#endif
X{
X    FILE *origfile, *stampset;
X    FB *infile, *outfile;
X    ULONG status;
X    long size;
X    int colors;
X    int viol_copy = 0;
X    ULONG skip;
X    ULONG newbytes = 0L;
X    ULONG blockbytes;
X    unsigned int blocks;
X    UCHAR *rebuf;
X    struct stat statbuf;
X    struct utimbuf times;
X    char *tname;
X    int myuid;
X    int fileuid;
X
X    UCHAR tempbuf[TBUFSIZ];
X    int loop;
X
X    GIF_LSD lsd;
X    RGB_TRIPLET *ctable;
X    int blocktype;
X    int extype;
X    GIF_IMD imd;
X    UCHAR codesize;
X    UCHAR *data;
X    int datalen;
X
X    /* Open original GIF and perform other startup functions. */
X
X    if ((origfile = fopen(filename, FOPEN_READ_BINARY)) == (FILE *) NULL)
X    {
X        fprintf(outerr, "ERROR: Cannot open file %s\n", filename);
X        return EXIT_ERROR;
X    }
X    mf_locked = 0;
X
X    /* Get the size and other data (owner, group, timestamps, mode). */
X
X    if (fstat(fileno(origfile), &statbuf) == -1)
X    {
X        fprintf(outerr, "ERROR: Error in fstat() on %s\n", filename);
X        fclose(origfile);
X        return EXIT_ERROR;
X    }
X    size = statbuf.st_size;
X
X    /* Open memory file and make sure there is enough space. */
X
X    if ((status = mf_open(mf_flags, (ULONG) size, tpath)) != 0)
X    {
X        fprintf(outerr, "%s\n", errxlate(status));
X        fclose(origfile);
X        return EXIT_ERROR;
X    }
X
X    /* Get GIF logical screen descriptor. */
X
X    if (nolead != 0)
X    {
X        if ((status = gif_lsdget(origfile, &lsd)) != ST_SUCCESS)
X        {
X            fprintf(outerr, "%s\n", errxlate(status));
X            fclose(origfile);
X            mf_close();
X            switch (ERRSEV(status))
X            {
X                case ERRSEV(GIF_NOTGIF_E):
X                    return EXIT_NOTGIF;
X
X                case ERRSEV(GIF_UNEOF_E):
X                    return EXIT_UNEOF;
X
X                default:
X                    return EXIT_ERROR;
X            }
X        }
X
X        /* Attach buffering to original GIF file. */
X
X        infile = fb_retrofit(origfile, 'r');
X        if (fb_error != 0)
X        {
X            fprintf(outerr, "%s\n", errxlate(fb_error));
X            fclose(origfile);
X            mf_close();
X            return EXIT_ERROR;
X        }
X
X    }
X    else
X    {
X        /* Attach buffering to original GIF file. */
X        infile = fb_retrofit(origfile, 'r');
X        if (fb_error != 0)
X        {
X            fprintf(outerr, "%s\n", errxlate(fb_error));
X            fclose(origfile);
X            mf_close();
X            return EXIT_ERROR;
X        }
X
X        /* Search for potentially buried LSD. */
X
X        if ((status = gif_searchlsd(infile, &lsd, &skip)) != ST_SUCCESS)
X        {
X            fprintf(outerr, "%s\n", errxlate(status));
X            fb_close(infile);
X            mf_close();
X            switch (ERRSEV(status))
X            {
X                case ERRSEV(GIF_NOTGIF_E):
X                case ERRSEV(GIF_UNEOF_E):
X                    return EXIT_NOTGIF;
X
X                default:
X                    return EXIT_ERROR;
X            }
X        }
X        if (skip != 0)
X        {
X            fprintf(outstr, "FYI: Skipped %lu leading junk bytes.\n", skip);
X        }
X    }
X
X    /* Print some info. */
X
X    fprintf(outstr, ((GIF_89A == lsd.version) ? "GIF89A  " : "GIF87A  "));
X    fprintf(outstr, ((lsd.gct_flag) ? "G" : "-"));
X    if (GIF_89A == lsd.version)
X    {
X        fprintf(outstr, ((lsd.sort_flag) ? "S" : "-"));
X        fprintf(outstr, ((lsd.aspect) ? "A" : "-"));
X    }
X    else
X    {
X        fprintf(outstr, "--");
X    }
X    fprintf(outstr, "%8ld  %5u x %5u @ ", size, lsd.scr_wid, lsd.scr_hi);
X    if (lsd.gct_flag)
X    {
X        colors = (0x1 << lsd.gct_size);
X        fprintf(outstr, "%3d", colors);
X    }
X    else
X    {
X        fprintf(outstr, "---");
X    }
X    fprintf(outstr, "   %s\n", filename);
X
X    /* Reconstruct GIF header and logical screen descriptor. */
X
X    /* Output signatures. */
X
X    if ((status = mf_write(GIF_SIGNATURE, GIF_SIGNATURE_LEN)) != 0)
X    {
X        fprintf(outerr, "%s\n", errxlate(status));
X        fb_close(infile);
X        mf_close();
X        return EXIT_ERROR;
X    }
X    newbytes += GIF_SIGNATURE_LEN;
X
X    /* Output version signature. */
X
X    if ((status = mf_write(((GIF_89A == lsd.version) ? GIF_VERS89A_SIG :
X                                                       GIF_VERS87A_SIG),
X                           GIF_VERS_SIG_LEN)) != 0)
X    {
X        fprintf(outerr, "%s\n", errxlate(status));
X        fb_close(infile);
X        mf_close();
X        return EXIT_ERROR;
X    }
X    newbytes += GIF_VERS_SIG_LEN;
X
X    /* Create new logical screen descriptor. */
X
X    tempbuf[GIF_LSD_SCRWID_OFF] = (UCHAR) (lsd.scr_wid & 0x00FF);
X    tempbuf[GIF_LSD_SCRWID_OFF + 1] = (UCHAR) (lsd.scr_wid >> 8);
X    tempbuf[GIF_LSD_SCRHI_OFF] = (UCHAR) (lsd.scr_hi & 0x00FF);
X    tempbuf[GIF_LSD_SCRHI_OFF + 1] = (UCHAR) (lsd.scr_hi >> 8);
X    if (0 == strict)
X    {
X        tempbuf[GIF_LSD_PACKED_OFF] = lsd.raw_packed;
X    }
X    else
X    {
X        tempbuf[GIF_LSD_PACKED_OFF] = 0;
X        if (lsd.gct_flag)
X        {
X            tempbuf[GIF_LSD_PACKED_OFF] |= GIF_LSD_GCTFLAG_MASK;
X        }
X        tempbuf[GIF_LSD_PACKED_OFF] |= (UCHAR)
X           (((lsd.clr_res - 1) << GIF_LSD_CLRRES_SHIFT) & GIF_LSD_CLRRES_MASK);
X        if (lsd.sort_flag != 0)
X        {
X            if (GIF_89A == lsd.version)
X            {
X                tempbuf[GIF_LSD_PACKED_OFF] |= GIF_LSD_SORTFLAG_MASK;
X            }
X            else
X            {
X                /*
X                ** Can only get here if version is 87A, strict is on,
X                ** and sort flag is set. This is illegal combination.
X                */
X
X                fprintf(outstr,
X                 "FYI: Ignoring illegal global color table sorted flag.\n   ");
X
X                /*
X                ** Turn on viol_copy so that file is rebuilt
X                ** even if size is same.
X                */
X
X                viol_copy = 1;
X            }
X        }
X        tempbuf[GIF_LSD_PACKED_OFF] |=
X                           (UCHAR) ((lsd.gct_size - 1) & GIF_LSD_GCTSIZE_MASK);
X    }
X    tempbuf[GIF_LSD_BACKGROUND_OFF] = (UCHAR) (lsd.background);
X    if ((GIF_89A == lsd.version) || (0 == strict))
X    {
X        tempbuf[GIF_LSD_ASPECT_OFF] = (UCHAR) (lsd.aspect);
X    }
X    else
X    {
X        tempbuf[GIF_LSD_ASPECT_OFF] = 0;
X        if (lsd.aspect != 0)
X        {
X            fprintf(outstr, "FYI: Ignoring illegal aspect ratio value.   \n");
X
X            /* Turn on viol_copy so that file is rebuilt even if size same. */
X            viol_copy = 1;
X        }
X    }
X
X    /* Write new logical screen descriptor. */
X
X    if ((status = mf_write(tempbuf, GIF_LSD_LEN)) != 0)
X    {
X        fprintf(outerr, "%s\n", errxlate(status));
X        fb_close(infile);
X        mf_close();
X        return EXIT_ERROR;
X    }
X    newbytes += GIF_LSD_LEN;
X
X    /* Get and write global color table, if any. */
X
X    if (lsd.gct_flag)
X    {
X        if ((status = gif_gctget(infile, &ctable, colors)) != 0)
X        {
X            fprintf(outerr, "%s\n", errxlate(status));
X            fb_close(infile);
X            mf_close();
X            return ((GIF_UNEOF_E == status) ? EXIT_UNEOF : EXIT_ERROR);
X        }
X
X        for (loop = 0; loop < colors; loop++)
X        {
X            tempbuf[0] = ctable[loop].red;
X            tempbuf[1] = ctable[loop].green;
X            tempbuf[2] = ctable[loop].blue;
X            if ((status = mf_write(tempbuf, 3)) != 0)
X            {
X                fprintf(outerr, "%s\n", errxlate(status));
X                fb_close(infile);
X                mf_close();
X                return EXIT_ERROR;
X            }
X            newbytes += 3;
X        }
X
X        free(ctable);
X    }
X
X    /* Loop through data blocks. */
X
X    blocktype = 0;
X    while (blocktype != GIF_TERMINATOR)
X    {
X        fprintf(outstr, "   ");
X
X        /* Find next block. */
X
X        if ((status = gif_findnext(infile, &blocktype, &skip, &extype)) != 0)
X        {
X            fprintf(outerr, "%s\n", errxlate(status));
X            fb_close(infile);
X            mf_close();
X            return ((GIF_UNEOF_E == status) ? EXIT_UNEOF : EXIT_ERROR);
X        }
X
X        /* If skipped characters, FYI. */
X
X        if (skip != 0)
X        {
X            fprintf(outstr, "FYI: %lu garbage characters skipped\n   ", skip);
X        }
X
X        /* Process by type of block. */
X
X        switch (blocktype)
X        {
X            case GIF_IMAGE:
X                /* Write image header. */
X
X                tempbuf[0] = GIF_IMAGE;
X                if ((status = mf_write(tempbuf, 1)) != 0)
X                {
X                    fprintf(outerr, "%s\n", errxlate(status));
X                    fb_close(infile);
X                    mf_close();
X                    return EXIT_ERROR;
X                }
X                newbytes++;
X
X                /* Get image descriptor. */
X
X                if ((status = gif_imdget(infile, &imd)) != 0)
X                {
X                    fprintf(outerr, "%s\n", errxlate(status));
X                    fb_close(infile);
X                    mf_close();
X                    return ((GIF_UNEOF_E == status) ? EXIT_UNEOF : EXIT_ERROR);
X                }
X
X                /* Create new image descriptor. */
X
X                tempbuf[GIF_IMD_IMLEFT_OFF] = (UCHAR) (imd.im_left & 0x00FF);
X                tempbuf[GIF_IMD_IMLEFT_OFF + 1] = (UCHAR) (imd.im_left >> 8);
X                tempbuf[GIF_IMD_IMTOP_OFF] = (UCHAR) (imd.im_top & 0x00FF);
X                tempbuf[GIF_IMD_IMTOP_OFF + 1] = (UCHAR) (imd.im_top >> 8);
X                tempbuf[GIF_IMD_IMWID_OFF] = (UCHAR) (imd.im_wid & 0x00FF);
X                tempbuf[GIF_IMD_IMWID_OFF + 1] = (UCHAR) (imd.im_wid >> 8);
X                tempbuf[GIF_IMD_IMHI_OFF] = (UCHAR) (imd.im_hi & 0x00FF);
X                tempbuf[GIF_IMD_IMHI_OFF + 1] = (UCHAR) (imd.im_hi >> 8);
X                if (0 == strict)
X                {
X                    tempbuf[GIF_IMD_PACKED_OFF] = imd.raw_packed;
X                }
X                else
X                {
X                    tempbuf[GIF_IMD_PACKED_OFF] = 0;
X                    if (imd.lct_flag)
X                    {
X                        tempbuf[GIF_IMD_PACKED_OFF] |= GIF_IMD_LCTFLAG_MASK;
X                        tempbuf[GIF_IMD_PACKED_OFF] |= (UCHAR)
X                                   ((imd.lct_size - 1) & GIF_IMD_LCTSIZE_MASK);
X                    }
X                    else if ((imd.lct_size - 1) != 0)
X                    {
X                        fprintf(outstr, "FYI: Ignoring illegal local color table size (no local color table).\n   ");
X
X                        /*
X                        ** Turn on viol_copy so that file is rebuilt
X                        ** even if size is same.
X                        */
X
X                        viol_copy = 1;
X                    }
X                    if (imd.interlace_flag)
X                    {
X                        tempbuf[GIF_IMD_PACKED_OFF] |=
X                                                     GIF_IMD_INTRLACEFLAG_MASK;
X                    }
X                    if (imd.sort_flag)
X                    {
X                        if ((GIF_89A == lsd.version) && (imd.lct_flag))
X                        {
X                            tempbuf[GIF_IMD_PACKED_OFF] |=
X                                                         GIF_IMD_SORTFLAG_MASK;
X                        }
X                        else
X                        {
X                            fprintf(outstr,
X                                "FYI: Ignoring illegal local color table sorted flag");
X                            if (0 == imd.lct_flag)
X                            {
X                                fprintf(outstr, " (no local color table)");
X                            }
X                            fprintf(outstr, ".\n   ");
X
X                            /*
X                            ** Turn on viol_copy so that file is rebuilt
X                            ** even if size is same.
X                            */
X
X                            viol_copy = 1;
X                        }
X                    }
X                }
X
X                /* Write new image descriptor. */
X
X                if ((status = mf_write(tempbuf, GIF_IMD_LEN)) != 0)
X                {
X                    fprintf(outerr, "%s\n", errxlate(status));
X                    fb_close(infile);
X                    mf_close();
X                    return EXIT_ERROR;
X                }
X                newbytes += GIF_IMD_LEN;
X
X                /* Print some info. */
X
X                fprintf(outstr, ((imd.lct_flag) ? "L" : "G"));
X                if (GIF_89A == lsd.version)
X                {
X                    fprintf(outstr, ((imd.sort_flag) ? "S" : "-"));
X                }
X                else
X                {
X                    fprintf(outstr, "-");
X                }
X                fprintf(outstr, ((imd.interlace_flag) ? "I" : "S"));
X                fprintf(outstr, "  (%3u,%3u)", imd.im_left, imd.im_top);
X                fprintf(outstr, "  %5u x %5u", imd.im_wid, imd.im_hi);
X                fprintf(outstr, " @ %3d  ", (0x1 << ((imd.lct_flag) ?
X                                            imd.lct_size : lsd.gct_size)));
X
X                /* Read and write local color table, if any. */
X
X                if (imd.lct_flag)
X                {
X                    if ((status = gif_lctget(infile, &ctable,
X                                             (0x1 << imd.lct_size))) != 0)
X                    {
X                        fprintf(outerr, "%s\n", errxlate(status));
X                        fb_close(infile);
X                        mf_close();
X                        return ((GIF_UNEOF_E == status) ? EXIT_UNEOF :
X                                                          EXIT_ERROR);
X                    }
X
X                    for (loop = 0; loop < (0x1 << imd.lct_size); loop++)
X                    {
X                        tempbuf[0] = ctable[loop].red;
X                        tempbuf[1] = ctable[loop].green;
X                        tempbuf[2] = ctable[loop].blue;
X                        if ((status = mf_write(tempbuf, 3)) != 0)
X                        {
X                            fprintf(outerr, "%s\n", errxlate(status));
X                            fb_close(infile);
X                            mf_close();
X                            return EXIT_ERROR;
X                        }
X                        newbytes += 3;
X                    }
X
X                    free(ctable);
X                }
X
X                /* Read and write codesize. */
X
X                codesize = (UCHAR) fb_getc(infile);
X                if (fb_error != 0)
X                {
X                    fprintf(outerr, "%s\n", errxlate(fb_error));
X                    fb_close(infile);
X                    mf_close();
X                    return ((FB_EOF_W == status) ? EXIT_UNEOF : EXIT_ERROR);
X                }
X                if ((status = mf_write(&codesize, 1)) != 0)
X                {
X                    fprintf(outerr, "%s\n", errxlate(status));
X                    fb_close(infile);
X                    mf_close();
X                    return EXIT_ERROR;
X                }
X                newbytes++;
X
X                /* Read and write data blocks until done. */
X
X                blockbytes = 0;
X                blocks = 0;
X                while (1)
X                {
X                    /* Read block. */
X
X                    if ((status = gif_readblock(infile, &data, &datalen)) != 0)
X                    {
X                        fprintf(outerr, "%s\n", errxlate(status));
X                        fb_close(infile);
X                        mf_close();
X                        return ((GIF_UNEOF_E == status) ? EXIT_UNEOF :
X                                                          EXIT_ERROR);
X                    }
X
X                    /* Check length. */
X
X                    if (0 == datalen)
X                    {
X                        /* If zero length, at end. */
X
X                        break;
X                    }
X                    blockbytes += (ULONG) datalen;
X                    blocks++;
X
X                    /* Write block length. */
X
X                    tempbuf[0] = (UCHAR) datalen;
X                    if ((status = mf_write(tempbuf, 1)) != 0)
X                    {
X                        fprintf(outerr, "%s\n", errxlate(status));
X                        fb_close(infile);
X                        mf_close();
X                        return EXIT_ERROR;
X                    }
X                    newbytes++;
X
X                    /* Write block. */
X
X                    if ((status = mf_write(data, (unsigned int) datalen)) != 0)
X                    {
X                        fprintf(outerr, "%s\n", errxlate(status));
X                        fb_close(infile);
X                        mf_close();
X                        return EXIT_ERROR;
X                    }
X                    newbytes += (ULONG) datalen;
X
X                    /* Free block. */
X
X                    free(data);
X                }
X
X                /* Write terminating block. */
X
X                tempbuf[0] = '\0';
X                if ((status = mf_write(tempbuf, 1)) != 0)
X                {
X                    fprintf(outerr, "%s\n", errxlate(status));
X                    fb_close(infile);
X                    mf_close();
X                    return EXIT_ERROR;
X                }
X                newbytes++;
X
X                /* Print more info. */
X
X                fprintf(outstr, "%6luBY  %4uBL\n", blockbytes, blocks);
X
X                break;
X
X            case GIF_EXTBLOCK:
X                /* Write out extension block header and type. */
X
X                tempbuf[0] = GIF_EXTBLOCK;
X                tempbuf[1] = (UCHAR) extype;
X                if ((status = mf_write(tempbuf, 2)) != 0)
X                {
X                    fprintf(outerr, "%s\n", errxlate(status));
X                    fb_close(infile);
X                    mf_close();
X                    return EXIT_ERROR;
X                }
X                newbytes += 2;
X
X                /* Print some info. */
X
X                if (GIF_89A == lsd.version)
X                {
X                    switch (extype)
X                    {
X                        case GIF_EXT_PLAIN_TEXT:
X                            fprintf(outstr, "Plain Text Extension Block");
X                            break;
X
X                        case GIF_EXT_GRAPHIC_CONTROL:
X                            fprintf(outstr, "Graphic Control Extension Block");
X                            break;
X
X                        case GIF_EXT_COMMENT:
X                            fprintf(outstr, "Comment Extension Block");
X                            break;
X
X                        case GIF_EXT_APPLICATION:
X                            fprintf(outstr, "Application Extension Block");
X                            break;
X
X                        default:
X                            fprintf(outstr, "Type %3d Extension Block", extype);
X                            break;
X                    }
X                }
X                else
X                {
X                    fprintf(outstr, "Type %3d Extension Block", extype);
X                }
X
X                /* Read and write data blocks until done. */
X
X                blockbytes = 0;
X                blocks = 0;
X                while (1)
X                {
X                    /* Read block. */
X
X                    if ((status = gif_readblock(infile, &data, &datalen)) != 0)
X                    {
X                        fprintf(outerr, "%s\n", errxlate(status));
X                        fb_close(infile);
X                        mf_close();
X                        return ((GIF_UNEOF_E == status) ? EXIT_UNEOF :
X                                                          EXIT_ERROR);
X                    }
X
X                    /* Check length. */
X
X                    if (0 == datalen)
X                    {
X                        /* If zero length, at end. */
X
X                        break;
X                    }
X                    blockbytes += (ULONG) datalen;
X                    blocks++;
X
X                    /* Write block length. */
X
X                    tempbuf[0] = (UCHAR) datalen;
X                    if ((status = mf_write(tempbuf, 1)) != 0)
X                    {
X                        fprintf(outerr, "%s\n", errxlate(status));
X                        fb_close(infile);
X                        mf_close();
X                        return EXIT_ERROR;
X                    }
X                    newbytes++;
X                    /* Write block. */
X
X                    if ((status = mf_write(data, (unsigned int) datalen)) != 0)
X                    {
X                        fprintf(outerr, "%s\n", errxlate(status));
X                        fb_close(infile);
X                        mf_close();
X                        return EXIT_ERROR;
X                    }
X                    newbytes += (ULONG) datalen;
X
X                    /* Free block. */
X
X                    free(data);
X                }
X
X                /* Write terminating block. */
X
X                tempbuf[0] = '\0';
X                if ((status = mf_write(tempbuf, 1)) != 0L)
X                {
X                    fprintf(outerr, "%s\n", errxlate(status));
X                    fb_close(infile);
X                    mf_close();
X                    return EXIT_ERROR;
X                }
X                newbytes++;
X
X                /* Print more info. */
X
X                fprintf(outstr, "%6luBY  %4uBL\n", blockbytes, blocks);
X
X                break;
X
X            case GIF_TERMINATOR:
X                /* Print info. */
X
X                fprintf(outstr, "GIF Terminator\n");
X
X                /* Write terminator. */
X
X                tempbuf[0] = GIF_TERMINATOR;
X                if ((status = mf_write(tempbuf, 1)) != 0)
X                {
X                    fprintf(outerr, "%s\n", errxlate(status));
X                    fb_close(infile);
X                    mf_close();
X                    return EXIT_ERROR;
X                }
X                newbytes++;
X
X                break;
X
X            default:
X                fprintf(outerr, "FATAL ERROR: Internal error.\n");
X                break;
X
X        } /* end of switch (blocktype) */
X    } /* end of while (blocktype != GIF_TERMINATOR) */
X
X    /* Read all good data from file, clean up. */
X
X    if ((status = fb_close(infile)) != 0)
X    {
X        fprintf(outerr, "%s\n", errxlate(status));
X        mf_close();
X        return EXIT_ERROR;
X    }
X    if ((status = mf_reset()) != 0)
X    {
X        fprintf(outerr, "%s\n", errxlate(status));
X        mf_close();
X        return EXIT_ERROR;
X    }
X
X    /* Check for change in file size. */
X
X    if ((newbytes == size) && (0 == forced_copy) && (0 == viol_copy))
X    {
X        fprintf(outstr, "   No work to be done. File unchanged.\n");
X        if ((status = mf_close()) != 0)
X        {
X            fprintf(outerr, "%s\n", errxlate(status));
X            return EXIT_ERROR;
X        }
X        return EXIT_OK;
X    }
X
X    /* Prepare to recopy. */
X
X    fprintf(outstr, "   New size: %6lu   Bytes removed: %6lu\n", newbytes,
X             (size - newbytes));
X
X    /* Lock temporary file, if there is one. */
X
X    mf_locked = 1;
X
X    if (EARLY == unlinktime)
X    {
X        /* Delete original file. */
X
X        if (unlink(filename) != 0)
X        {
X            fprintf(outerr, "   FATAL ERROR: Cannot remove original file.\n");
X            mf_locked = 0;
X            mf_close();
X            return EXIT_ERROR;
X        }
X
X        /* Open output file. */
X
X        outfile = fb_open(filename, 'w', &size);
X        if (fb_error != 0)
X        {
X            fprintf(outerr, "%s\n", errxlate(fb_error));
X            mf_close();
X            return EXIT_ERROR;
X        }
X    }
X    else
X    {
X        /* Check free space. */
X
X        if (dfree(filename) < newbytes)
X        {
X            fprintf(outerr, "   ERROR: Insufficient space on disk for recopy. Try using -o\n");
X            mf_locked = 0;
X            mf_close();
X            return EXIT_ERROR;
X        }
X
X        /* Get a name for a temporary file in the current directory. */
X
X        tname = tempname(".", "GIF.");
X        if (NULL == tname)
X        {
X            fprintf(outerr, "Cannot get name for temporary file.\n");
X            mf_close();
X            return EXIT_ERROR;
X        }
X
X        /* Open temporary file. */
X
X        outfile = fb_open(tname, 'w', &size);
X        if (fb_error != 0L)
X        {
X            fprintf(outerr, "%s\n", errxlate(fb_error));
X            mf_close();
X            free(tname);
X            return EXIT_ERROR;
X        }
X    }
X
X    /* Allocate recopy buffer. */
X
X    blockbytes = FB_BUFSIZE;
X    while ((rebuf = (UCHAR *) malloc((unsigned int) blockbytes)) ==
X           (UCHAR *) NULL)
X    {
X        blockbytes /= 2;
X        if (blockbytes < TBUFSIZ)
X        {
X            rebuf = tempbuf;
X            blockbytes = TBUFSIZ;
X            break;
X        }
X    }
X
X    /* Recopy.  */
X
X    fprintf(outstr, "Recopying... ");
X    for (; newbytes != 0; newbytes -= blockbytes)
X    {
X        if (newbytes < blockbytes)
X        {
X            blockbytes = newbytes;
X        }
X        if ((status = mf_read(rebuf, (unsigned int) blockbytes, &blocks)) != 0)
X        {
X            fprintf(outerr, "%s\n", errxlate(status));
X            fb_close(outfile);
X            mf_close();
X            if (rebuf != tempbuf)
X            {
X                free(rebuf);
X            }
X            unlink(tname);
X            if (LATE == unlinktime)
X            {
X                free(tname);
X            }
X            return EXIT_ERROR;
X        }
X        if ((status = fb_write(outfile, rebuf, (int) blockbytes)) != 0)
X        {
X            fprintf(outerr, "%s\n", errxlate(status));
X            fb_close(outfile);
X            mf_close();
X            if (rebuf != tempbuf)
X            {
X                free(rebuf);
X            }
X            unlink(tname);
X            if (LATE == unlinktime)
X            {
X                free(tname);
X            }
X            return EXIT_ERROR;
X        }
X    }
X    fprintf(outstr, "done.\n");
X
X    /* Close all, clean up. */
X
X    /* Close rebuilt file. */
X
X    if ((status = fb_close(outfile)) != 0)
X    {
X        fprintf(outerr, "%s\n", errxlate(status));
X        mf_close();
X        if (rebuf != tempbuf)
X        {
X            free(rebuf);
X        }
X        unlink(tname);
X        if (LATE == unlinktime)
X        {
X            free(tname);
X        }
X        return EXIT_ERROR;
X    }
X
X    /* Close memory file. */
X
X    mf_locked = 0;
X    if ((status = mf_close()) != 0)
X    {
X        fprintf(outerr, "%s\n", errxlate(status));
X        if (rebuf != tempbuf)
X        {
X            free(rebuf);
X        }
X        unlink(tname);
X        if (LATE == unlinktime)
X        {
X            free(tname);
X        }
X        return EXIT_ERROR;
X    }
X
X    /* Release recopy buffer. */
X
X    if (rebuf != tempbuf)
X    {
X        free(rebuf);
X    }
X
X    if (LATE == unlinktime)
X    {
X        /* Now remove original file. */
X
X        if (unlink(filename) != 0)
X        {
X            fprintf(outerr, "   FATAL ERROR: Cannot remove original file.\n");
X            unlink(tname);
X            free(tname);
X            return EXIT_ERROR;
X        }
X
X        /* And rename temporary file. */
X
X        if (rename(tname, filename) != 0)
X        {
X            fprintf(outerr, "   FATAL ERROR: Cannot move %s to %s.\n", tname, filename);
X            unlink(tname);
X            free(tname);
X            return EXIT_ERROR;
X        }
X        free(tname);
X    }
X
X    /* Reset the time stamp, owner, mode, etc. of the recopied file. */
X
X    /* First, update mode. */
X
X    if (chmod(filename, (statbuf.st_mode & 07777)) == -1)
X    {
X        fprintf(outerr, "ERROR: Error setting mode of recopied file!\n");
X        return EXIT_ERROR;
X    }
X
X    /* Next, try to change owner, but only if necessary. */
X
X    fileuid = myuid = getuid();
X    if (myuid != statbuf.st_uid)
X    {
X#ifdef ROOT_CHOWN
X        if (myuid != 0)
X        {
X            /* If ROOT_CHOWN, only root can give away files with chown(). */
X
X            fprintf(outerr, "WARNING: Cannot reset owner of recopied file!\n");
X        }
X        else
X        {
X#endif
X            if (chown(filename, statbuf.st_uid, statbuf.st_gid) == -1)
X            {
X                fprintf(outerr,
X                        "ERROR: Error setting owner of recopied file!\n");
X                return EXIT_ERROR;
X            }
X            else
X            {
X                fileuid = statbuf.st_uid;
X            }
X#ifdef ROOT_CHOWN
X        }
X#endif
X    }
X    else if (getgid() != statbuf.st_gid)
X    {
X        /*
X        ** Owner is same, group is not. since owner is same, can
X        ** change group no problem.
X        */
X
X        if (chown(filename, statbuf.st_uid, statbuf.st_gid) == -1)
X        {
X            fprintf(outerr, "ERROR: Error setting group of recopied file!\n");
X            return EXIT_ERROR;
X        }
X    }
X
X    /* Finally, reset timestamps. */
X
X    if (myuid != fileuid)
X    {
X        /* We're not owner of file anymore, but are we root? */
X
X        if (0 == myuid)
X        {
X            /* We're root, so we can still update file timestamp. */
X
X            times.actime = statbuf.st_atime;
X            times.modtime = statbuf.st_mtime;
X            if (utime(filename, &times) == -1)
X            {
X                fprintf(outerr,
X                        "ERROR: Error setting timestamp on recopied file!\n");
X                return EXIT_ERROR;
X            }
X        }
X        else
X        {
X            fprintf(outerr, 
X                    "WARNING: Cannot set timestamp on recopied file!\n");
X        }
X    } 
X    else
X    {
X        /* We are owner, so can update timestamps no problem. */
X
X        times.actime = statbuf.st_atime;
X        times.modtime = statbuf.st_mtime;
X        if (utime(filename, &times) == -1)
X        {
X            fprintf(outerr, 
X                    "ERROR: Error setting timestamp on recopied file!\n");
X            return EXIT_ERROR;
X        }
X    }
X
X    /* All done, return OK. */
X
X    return EXIT_OK;
X} /* end of static strip() */
X
X
X/***************************************************************************
X*   FUNCTION:    usage  STATIC                                             *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*      Prints out usage message.                                           *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*      None.                                                               *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*      Never returns.                                                      *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X*      Exit()s with errorlevel EXIT_ERROR.                                 *
X*                                                                          *
X***************************************************************************/
Xstatic VOID 
Xusage()
X{
X    fprintf(outstr, "\n");
X    fprintf(outstr, 
X            "GIFSTRIP version %s, patchlevel %d by James W. Birdsall.\n", 
X            VERS, PATCHLEVEL);
X    fprintf(outstr, "   Strips extraneous characters from GIF files.\n");
X    fprintf(outstr, "   usage: gifstrip [options] target [target ...]\n");
X    fprintf(outstr, "     target       filename or directory. If a directory, all files in that\n");
X    fprintf(outstr, "                   directory will be processed. If no targets are given,\n");
X    fprintf(outstr, "                   this usage message is displayed.\n");
X
X    fprintf(outstr, "     -b           BATCH: suppresses all console output. Should be first on the\n");
X    fprintf(outstr, "                   line. Returns 0 if OK or stripped OK, 1 if a non-GIF file\n");
X    fprintf(outstr, "                   was found, 2 if unexpected EOF in a GIF file, or 3 on error.\n");
X    fprintf(outstr, "     -r           Sends error messages to stderr instead of stdout.\n");
X    fprintf(outstr, "     --           Take targets from stdin. For use with -f option of CHILS.\n");
X    fprintf(outstr, "                   Targets must be separated by newlines. Directories are\n");
X    fprintf(outstr, "                   expanded but wildcards are not. Command-line targets are\n");
X    fprintf(outstr, "                   ignored if this option is given.\n");
X
X    fprintf(outstr, "     -f           Forces rebuild. Normally file is not rebuilt if no extra\n");
X    fprintf(outstr, "                   characters are found and file meets format requirements.\n");
X    fprintf(outstr, "     -n           Disables strict format requirements.\n");
X    fprintf(outstr, "     -m           Enables checking for leading junk characters (from a Mac,\n");
X    fprintf(outstr, "                   for example).\n");
X    fprintf(outstr, "     -o           OVERWRITE: erases original before recopying.\n");
X
X    fprintf(outstr, "     -c           Do not use memory for temporary storage.\n");
X    fprintf(outstr, "     -d           Do not use DISK for temporary storage.\n");
X    fprintf(outstr, "     -s           Use ONLY DISK for temporary storage. Equivalent to -c\n");
X    fprintf(outstr, "     -tpath       Specify path for DISK temporary storage.\n");
X    fprintf(outstr, "     -h           HELP: Prints this message.\n");
X
X    fprintf(outstr, "   Note that at least one of memory or disk must be allowed.\n");
X    fprintf(outstr, "\n");
X    fprintf(outstr, "   Options may not be combined.\n");
X    fprintf(outstr, "\n");
X
X    exit(EXIT_ERROR);
X} /* end of static usage() */
X
X
X/***************************************************************************
X*   FUNCTION: errxlate STATIC                                              *
X*                                                                          *
X*   DESCRIPTION:                                                           *
X*                                                                          *
X*       Translates an error code into a string.                            *
X*                                                                          *
X*   ENTRY:                                                                 *
X*                                                                          *
X*       errcode - code to be translated                                    *
X*                                                                          *
X*   EXIT:                                                                  *
X*                                                                          *
X*       Returns a pointer to the appropriate string.                       *
X*                                                                          *
X*   CONSTRAINTS/SIDE EFFECTS:                                              *
X*                                                                          *
X***************************************************************************/
Xstatic char *
X#ifdef __STDC__
Xerrxlate(ULONG errcode)
X#else
Xerrxlate(errcode)
XULONG errcode;
X#endif
X{
X    char *errstring;
X    char *sever;
X
X    /* Determine severity of error. */
X
X    switch (SEVERITY(errcode))
X    {
X        case SEVERITY(ST_SUCCESS):
X            sever = "SUCCESS";
X            break;
X
X        case SEVERITY(ST_WARNING):
X            sever = "WARNING";
X            break;
X
X        case SEVERITY(ST_ERROR):
X            sever = "ERROR";
X            break;
X
X        case SEVERITY(ST_FATAL):
X        default:
X            sever = "FATAL";
X            break;
X    }
X
X    /* Get error string from module. */
X
X    switch (MODULE(errcode))
X    {
X        case MODULE(GIF_MODULE):
X            errstring = gif_errstring(errcode);
X            break;
X
X        case MODULE(FB_MODULE):
X            errstring = fb_errstring(errcode);
X            break;
X
X        case MODULE(MF_MODULE):
X            errstring = mf_errstring(errcode);
X            break;
X
X        default:
X            errstring = NULL;
X            break;
X    }
X
X    /* Composite strings. */
X
X    if (errstring != NULL)
X    {
X        sprintf(scratch, "%s: %s", sever, errstring);
X    }
X    else
X    {
X        /* Error not recognized by any module. */
X
X        sprintf(scratch, "%s: %08lX.", sever, errcode);
X    }
X
X    return scratch;
X} /* end of static errxlate() */
X
END_OF_FILE
  if test 47919 -ne `wc -c <'src/gifstrip.c'`; then
    echo shar: \"'src/gifstrip.c'\" unpacked with wrong size!
  fi
  # end of 'src/gifstrip.c'
fi
echo shar: End of archive 2 \(of 18\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
