Newsgroups: comp.sources.misc,alt.binaries.pictures.utilities
From: jstevens@teal.csn.org (John W.M. Stevens)
Subject: v36i120:  unpost - Smart multi-part uudecoder v2.1.2, Part07/07
Message-ID: <1993Apr19.052646.29581@sparky.imd.sterling.com>
X-Md4-Signature: 1dff28035b9ed522c9945a870c36b285
Date: Mon, 19 Apr 1993 05:26:46 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jstevens@teal.csn.org (John W.M. Stevens)
Posting-number: Volume 36, Issue 120
Archive-name: unpost/part07
Environment: UNIX, MS-DOS, OS/2, Windows, MacIntosh, Amiga, Vax/VMS

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  cfg/email.cfg cfg/mufud.cfg config.h decode.h ident.c
#   ident.h lex.h makefils/makefile.aix makefils/makefile.dos
#   makefils/makefile.gcc makefils/makefile.hp makefils/makefile.os2
#   modflnm.h parse.h read_me.doc regexp.h sets.c sets.h unpost.h
#   utils.h utils/tokens uudec.h
# Wrapped by kent@sparky on Sun Apr 18 23:10:31 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 7 (of 7)."'
if test -f 'cfg/email.cfg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cfg/email.cfg'\"
else
  echo shar: Extracting \"'cfg/email.cfg'\" \(3704 characters\)
  sed "s/^X//" >'cfg/email.cfg' <<'END_OF_FILE'
X#   This configuration file tells UNPOST how to handle email (and,
X#   if I remember correctly, nn) segments.
X
Xsegment "^From "
X{
X    header
X    {
X        "^Subject:"
X        {
X            "^Subject:(.*)[[({]Part[_   ]*([0-9]+)[^0-9]+([0-9]+)[)\]}](.*)"
X            {
X                id 1
X                segment number 2
X                segments 3
X                alternate id 4
X                case ignore
X            }
X            "^Subject:(.*)Part[_    ]*[[({]([0-9]+)[^0-9]+([0-9]+)[)\]}](.*)"
X            {
X                id 1
X                segment number 2
X                segments 3
X                alternate id 4
X                case ignore
X            }
X            "^Subject:(.*)Part[_    ]+([0-9]+)[^0-9]+([0-9]+)(.*)"
X            {
X                id 1
X                segment number 2
X                segments 3
X                alternate id 4
X                case ignore
X            }
X            "^Subject:(.*)[([{]([0-9]+)[^0-9]+([0-9]+)[)\]}](.*)"
X            {
X                id 1
X                segment number 2
X                segments 3
X                alternate id 4
X                case ignore
X            }
X            "^Subject:(.*)([0-9]+)([/|]|[ \t]+of[ \t]+)([0-9]+)(.*)"
X            {
X                id 1
X                segment number 2
X                segments 4
X                alternate id 5
X                case ignore
X            }
X            "^Subject:(.*)"
X            {
X                id 1
X                segment number 0
X                segments 0
X                alternate id 0
X                case ignore
X            }
X        }
X        "^X-File-Name:"
X        {
X            "^X-File-Name:[     ]+(.*)"
X            {
X                id 1
X                segment number 0
X                segments 0
X                 alternate id 0
X                case sensitive
X            }
X        }
X        "^X-Part:"
X        {
X            "^X-Part:[  ]+([0-9]+)"
X            {
X                id 0
X                segment number 1
X                segments 0
X                alternate id 0
X                case sensitive
X            }
X        }
X        "^X-Part-Total:"
X        {
X            "^X-Part-Total:[    ]+([0-9]+)"
X            {
X                id 0
X                segment number 0
X                segments 1
X                alternate id 0
X                case sensitive
X            }
X        }
X        "^Uusplit-part:"
X        {
X            "^Uusplit-part:[    ]+([0-9]+)"
X            {
X                id 0
X                segment number 1
X                segments 0
X                alternate id 0
X                case sensitive
X            }
X        }
X        "^Uusplit-parts:"
X        {
X            "^Uusplit-parts:[   ]+([0-9]+)"
X            {
X                id 0
X                segment number 0
X                segments 1
X                alternate id 0
X                case sensitive
X            }
X        }
X    }
X    body
X    {
X        "^section [0-9]+ of uuencode [0-9]+\.[0-9]+ of file "
X        "[^     ]+    by R.E.M."
X        {
X            "^section ([0-9]+) of uuencode [0-9]+\.[0-9]+ of file "
X            "([^    ]+)[    ]+by R.E.M."
X            {
X                id 2
X                segment number 1
X                segments 0
X                alternate id 0
X                case sensitive
X            }
X        }
X        "^[^    ]+[     ]+section[  ]+[0-9]+/[0-9]+[    ]+UUXFER "
X        "ver [^     ]+ by David M. Read"
X         {
X            "^([^ \t]+)[ \t]+section[ \t]+([0-9]+)/([0-9]+)[ \t]+UUXFER "
X            "ver [^ \t]+ by David M. Read"
X            {
X                id 1
X                segment number 2
X                segments 3
X                alternate id 0
X                case sensitive
X            }
X        }
X    }
X}
END_OF_FILE
  if test 3704 -ne `wc -c <'cfg/email.cfg'`; then
    echo shar: \"'cfg/email.cfg'\" unpacked with wrong size!
  fi
  # end of 'cfg/email.cfg'
fi
if test -f 'cfg/mufud.cfg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cfg/mufud.cfg'\"
else
  echo shar: Extracting \"'cfg/mufud.cfg'\" \(579 characters\)
  sed "s/^X//" >'cfg/mufud.cfg' <<'END_OF_FILE'
Xsegment "^Article[:]?"
X{
X    header
X    {
X        "^Subject:"
X        {
X            "^Subject:(.*)part[ ]+([0-9]+)[ ]*(of|/)[ ]*([0-9]+)(.*)"
X            {
X                id 1
X                segment number 2
X                segments 4
X                alternate id 5
X                case ignore
X            }
X            "^Subject:(.*)([0-9]+)[ ]*(of|/)[ ]*([0-9]+)(.*)"
X            {
X                id 1
X                segment number 2
X                segments 4
X                alternate id 5
X                case ignore
X            }
X        }
X    }
X    body
X    {
X    }
X}
END_OF_FILE
  if test 579 -ne `wc -c <'cfg/mufud.cfg'`; then
    echo shar: \"'cfg/mufud.cfg'\" unpacked with wrong size!
  fi
  # end of 'cfg/mufud.cfg'
fi
if test -f 'config.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'config.h'\"
else
  echo shar: Extracting \"'config.h'\" \(452 characters\)
  sed "s/^X//" >'config.h' <<'END_OF_FILE'
X/******************************************************************************
X* Module    :   Configuration File Parser --- Parse the configuration file.
X*
X* Author    :   John W. M. Stevens
X******************************************************************************/
X
X#if ! defined(CONFIG_FILE_PARSER)
X#define CONFIG_FILE_PARSER
X
X#include    "parse.h"
X
X/*  External function prototypes.   */
Xextern
XSEGMENT *ReadConfig(char    *CfgFlNm);
X
X#endif
END_OF_FILE
  if test 452 -ne `wc -c <'config.h'`; then
    echo shar: \"'config.h'\" unpacked with wrong size!
  fi
  # end of 'config.h'
fi
if test -f 'decode.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'decode.h'\"
else
  echo shar: Extracting \"'decode.h'\" \(686 characters\)
  sed "s/^X//" >'decode.h' <<'END_OF_FILE'
X/******************************************************************************
X* Module    :   Decode segments.
X*
X* Author    :   John W. Stevens
X******************************************************************************/
X
X#if ! defined(DECODE_HELPER_HEADER)
X#define DECODE_HELPER_HEADER
X
X#include    "parse.h"
X
X/*  Function prototypes.    */
Xextern
Xint     DecSeg(FILE         *InFlPtr,
X               FILE         *OutFlPtr,
X               CHK_UU_ENC   *UULnType);
Xextern
Xint         DeCode(FILE     *InFlPtr,
X                   FL_LIST  *FlDesc);
Xextern
Xvoid        DecTruncUULn(char   *Line,
X                         int    *Len,
X                         BYTE   *Bfr);
X
X#endif
END_OF_FILE
  if test 686 -ne `wc -c <'decode.h'`; then
    echo shar: \"'decode.h'\" unpacked with wrong size!
  fi
  # end of 'decode.h'
fi
if test -f 'ident.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ident.c'\"
else
  echo shar: Extracting \"'ident.c'\" \(2385 characters\)
  sed "s/^X//" >'ident.c' <<'END_OF_FILE'
X/******************************************************************************
X* Module    :   Identify a binary file.
X*
X* Author    :   John Stevens
X******************************************************************************/
X
X#include    "compiler.h"
X
X#include    "ident.h"
X
X/*  Define file type information for static storage.    */
Xtypedef struct
X{
X    int             Offset;
X    int             length;
X    char            *string;
X    char            ext[5];
X    BIN_TYPES       FileType;
X} FILE_TYPES;
X
Xstatic  FILE_TYPES  FileTypes[] =
X{
X    {   0,  6,  "GIF87a",   ".gif",     GIF87A          },
X    {   0,  6,  "GIF89a",   ".gif",     GIF89A          },
X    {   6,  4,  "JFIF",     ".jpg",     JFIF_JPEG       },
X    {   0,  4,  "hsi1",     ".hsi",     HSI1_JPEG       },
X    {   0,  0,  "",         "",         UNKNOWN_TYPE    }
X};
X
X/*-----------------------------------------------------------------------------
X| Routine   :   IdUUFile() --- Identify a uuencoded binary file from it's
X|               first line.  Currently this only works for graphics that
X|               I have access to.
X|
X| Inputs    :   Bfr - Buffer containing first line.
X|               Len - Number of bytes in buffer.
X|               Ext - Pointer to extension buffer.
X|
X| Returns   :   Returns the file type.
X-----------------------------------------------------------------------------*/
X
XBIN_TYPES   IdUUFile(BYTE   *Bfr,
X                     int    Len,
X                     char   *Ext)
X{
X    register    int     i;
X    register    int     j;
X    auto        BYTE    *tp;
X
X    /*  Run file types, looking for all listed types.   */
X    *Ext = '\0';
X    for (i = 0; FileTypes[i].length; i++)
X    {
X        /*  Make sure that there are enough bytes in the buffer
X        *   to identify this file.
X        */
X        if (FileTypes[i].length + (int) FileTypes[i].Offset > Len)
X            continue;
X
X        /*  Compare the buffers.    */
X        for (j = 0, tp = Bfr + FileTypes[i].Offset;
X             j < FileTypes[i].length;
X             j++)
X            if (FileTypes[i].string[j] != (char) tp[j])
X                break;
X
X        /*  Check for file type found.  */
X        if (j == FileTypes[i].length)
X        {
X            strcpy(Ext, FileTypes[i].ext);
X            return( FileTypes[i].FileType );
X        }
X    }
X
X    /*  Return type unknown.    */
X    return( UNKNOWN_TYPE );
X}
END_OF_FILE
  if test 2385 -ne `wc -c <'ident.c'`; then
    echo shar: \"'ident.c'\" unpacked with wrong size!
  fi
  # end of 'ident.c'
fi
if test -f 'ident.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ident.h'\"
else
  echo shar: Extracting \"'ident.h'\" \(560 characters\)
  sed "s/^X//" >'ident.h' <<'END_OF_FILE'
X/******************************************************************************
X* Module    :   Identify a binary file.
X*
X* Author    :   John W. M. Stevens
X******************************************************************************/
X
X#if ! defined(IDENT_HEADER_FILE)
X
X#include    "unpost.h"
X
X/*  Define binary file type enumerations.   */
Xtypedef enum
X{
X    UNKNOWN_TYPE,
X    GIF87A,
X    GIF89A,
X    JFIF_JPEG,
X    HSI1_JPEG
X} BIN_TYPES;
X
Xextern
XBIN_TYPES   IdUUFile(BYTE   *Bfr,
X                     int    Len,
X                     char   *Ext);
X
X#endif
END_OF_FILE
  if test 560 -ne `wc -c <'ident.h'`; then
    echo shar: \"'ident.h'\" unpacked with wrong size!
  fi
  # end of 'ident.h'
fi
if test -f 'lex.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lex.h'\"
else
  echo shar: Extracting \"'lex.h'\" \(923 characters\)
  sed "s/^X//" >'lex.h' <<'END_OF_FILE'
X/******************************************************************************
X* Module    :   Lexical Analyzer --- Extract tokens from the source file.
X*
X* Author    :   John W. M. Stevens
X******************************************************************************/
X
X#if ! defined(LEXICAL_ANALYZER)
X#define     LEXICAL_ANALYZER
X
Xtypedef enum    {
X    T_NOT_FND,
X    T_ALTERNATE,
X    T_BODY,
X    T_CASE,
X    T_HEADER,
X    T_ID,
X    T_IGNORE,
X    T_NUMBER,
X    T_PART,
X    T_SEGMENT,
X    T_SEGMENTS,
X    T_SENSITIVE,
X    T_STRING,
X    T_TOTAL,
X    T_L_BRACE,
X    T_R_BRACE,
X    T_DBL_QUOTE,
X    T_INT_NO
X} TKNS;
X
X/*  Token structure for returning values.   */
Xtypedef struct  {
X    char        str[256];
X    int         no;
X} TOKEN;
X
X/*  Function prototypes.    */
Xextern
Xvoid    ParseErr(char   *ErrStr);
Xextern
Xvoid    OpenCfg(char    *FileNm);
Xextern
Xvoid    CloseCfg(void);
Xextern
Xint     Lex(TOKEN   *sym);
X
X#endif
END_OF_FILE
  if test 923 -ne `wc -c <'lex.h'`; then
    echo shar: \"'lex.h'\" unpacked with wrong size!
  fi
  # end of 'lex.h'
fi
if test -f 'makefils/makefile.aix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefils/makefile.aix'\"
else
  echo shar: Extracting \"'makefils/makefile.aix'\" \(1080 characters\)
  sed "s/^X//" >'makefils/makefile.aix' <<'END_OF_FILE'
X#******************************************************************************
X# Module    :   Makefile for UnPost utility. (IBM AIX)
X#
X# Author    :   John W. M. Stevens
X#******************************************************************************
X
XCC_FLAGS    =
X
X.c.o:
X        c89 -c $(CC_FLAGS) $<
X
Xall: retest unpost
X
Xretest: recomp.o rematch.o retest.o sets.o utils.o
X        c89 $(CC_FLAGS) -o retest retest.o recomp.o rematch.o sets.o utils.o
X
Xunpost: config.o   decode.o   ident.o    lex.o      list.o \
X        modflnm.o  parse.o    recomp.o   rematch.o  segment.o \
X        sets.o     unpost.o   utils.o    uudec.o
X        c89 -o unpost config.o   decode.o   ident.o    lex.o      list.o \
X        modflnm.o  parse.o    recomp.o   rematch.o  segment.o \
X        sets.o     unpost.o   utils.o    uudec.o
X
Xconfig.o: config.c
X
Xdecode.o: decode.c
X
Xident.o: ident.c
X
Xlex.o: lex.c
X
Xlist.o: list.c
X
Xmodflnm.o: modflnm.c
X
Xparse.o: parse.c
X
Xrecomp.o: recomp.c
X
Xrematch.o: rematch.c
X
Xsegment.o: segment.c
X
Xsets.o: sets.c
X
Xunpost.o: unpost.c
X
Xutils.o: utils.c
X
Xuudec.o: uudec.c
END_OF_FILE
  if test 1080 -ne `wc -c <'makefils/makefile.aix'`; then
    echo shar: \"'makefils/makefile.aix'\" unpacked with wrong size!
  fi
  # end of 'makefils/makefile.aix'
fi
if test -f 'makefils/makefile.dos' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefils/makefile.dos'\"
else
  echo shar: Extracting \"'makefils/makefile.dos'\" \(1337 characters\)
  sed "s/^X//" >'makefils/makefile.dos' <<'END_OF_FILE'
X#******************************************************************************
X# Module    :   Makefile for UnPost utility. (MS-DOS, Borland C++ 3.0)
X#
X# Author    :   John W. M. Stevens
X#******************************************************************************
X
XCC_FLAGS    =   -w -ml -DSYSTEM_MS_DOS -DBCC_COMPILER
X
X.c.obj:
X        bcc -c $(CC_FLAGS) $<
X
Xall: retest.exe unpost.exe
X
Xretest.exe: recomp.obj rematch.obj retest.obj sets.obj utils.obj
X        bcc $(CC_FLAGS) retest.obj recomp.obj rematch.obj sets.obj utils.obj
X
Xunpost.exe: config.obj   decode.obj   ident.obj    lex.obj      list.obj\
X            modflnm.obj  parse.obj    recomp.obj   rematch.obj  segment.obj\
X            sets.obj     unpost.obj   utils.obj    uudec.obj
X        tlink @&&!
X        /x c0l.obj +
X        config.obj   decode.obj   ident.obj    lex.obj      list.obj +
X        modflnm.obj  parse.obj    recomp.obj   rematch.obj  segment.obj +
X        sets.obj     unpost.obj   utils.obj    uudec.obj
X        $*
X        $*
X        mathl.lib cl.lib emu.lib
X!
X
Xconfig.obj: config.c
X
Xdecode.obj: decode.c
X
Xident.obj: ident.c
X
Xlex.obj: lex.c
X
Xlist.obj: list.c
X
Xmodflnm.obj: modflnm.c
X
Xparse.obj: parse.c
X
Xrecomp.obj: recomp.c
X
Xrematch.obj: rematch.c
X
Xsegment.obj: segment.c
X
Xsets.obj: sets.c
X
Xunpost.obj: unpost.c
X
Xutils.obj: utils.c
X
Xuudec.obj: uudec.c
END_OF_FILE
  if test 1337 -ne `wc -c <'makefils/makefile.dos'`; then
    echo shar: \"'makefils/makefile.dos'\" unpacked with wrong size!
  fi
  # end of 'makefils/makefile.dos'
fi
if test -f 'makefils/makefile.gcc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefils/makefile.gcc'\"
else
  echo shar: Extracting \"'makefils/makefile.gcc'\" \(1108 characters\)
  sed "s/^X//" >'makefils/makefile.gcc' <<'END_OF_FILE'
X#******************************************************************************
X# Module    :   Makefile for UnPost utility. (GCC on Sun 4)
X#
X# Author    :   John W. M. Stevens
X#******************************************************************************
X
XCC_FLAGS    =   -ansi -DGCC_COMPILER
X
X.c.o:
X        gcc -c $(CC_FLAGS) $<
X
Xall: retest unpost
X
Xretest: recomp.o rematch.o retest.o sets.o utils.o
X        gcc $(CC_FLAGS) -o retest retest.o recomp.o rematch.o sets.o utils.o
X
Xunpost: config.o   decode.o   ident.o    lex.o      list.o \
X        modflnm.o  parse.o    recomp.o   rematch.o  segment.o \
X        sets.o     unpost.o   utils.o    uudec.o
X        gcc -o unpost config.o   decode.o   ident.o    lex.o      list.o \
X        modflnm.o  parse.o    recomp.o   rematch.o  segment.o \
X        sets.o     unpost.o   utils.o    uudec.o
X
Xconfig.o: config.c
X
Xdecode.o: decode.c
X
Xident.o: ident.c
X
Xlex.o: lex.c
X
Xlist.o: list.c
X
Xmodflnm.o: modflnm.c
X
Xparse.o: parse.c
X
Xrecomp.o: recomp.c
X
Xrematch.o: rematch.c
X
Xsegment.o: segment.c
X
Xsets.o: sets.c
X
Xunpost.o: unpost.c
X
Xutils.o: utils.c
X
Xuudec.o: uudec.c
END_OF_FILE
  if test 1108 -ne `wc -c <'makefils/makefile.gcc'`; then
    echo shar: \"'makefils/makefile.gcc'\" unpacked with wrong size!
  fi
  # end of 'makefils/makefile.gcc'
fi
if test -f 'makefils/makefile.hp' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefils/makefile.hp'\"
else
  echo shar: Extracting \"'makefils/makefile.hp'\" \(1089 characters\)
  sed "s/^X//" >'makefils/makefile.hp' <<'END_OF_FILE'
X#******************************************************************************
X# Module    :   Makefile for UnPost utility. (HP Apollo 700)
X#
X# Author    :   John W. M. Stevens
X#******************************************************************************
X
XCC_FLAGS    =   -Aa
X
X.c.o:
X        cc -c $(CC_FLAGS) $<
X
Xall: retest unpost
X
Xretest: recomp.o rematch.o retest.o sets.o utils.o
X        cc $(CC_FLAGS) -o retest retest.o recomp.o rematch.o sets.o utils.o
X
Xunpost: config.o   decode.o   ident.o    lex.o      list.o \
X        modflnm.o  parse.o    recomp.o   rematch.o  segment.o \
X        sets.o     unpost.o   utils.o    uudec.o
X        cc -o unpost config.o   decode.o   ident.o    lex.o      list.o \
X        modflnm.o  parse.o    recomp.o   rematch.o  segment.o \
X        sets.o     unpost.o   utils.o    uudec.o
X
Xconfig.o: config.c
X
Xdecode.o: decode.c
X
Xident.o: ident.c
X
Xlex.o: lex.c
X
Xlist.o: list.c
X
Xmodflnm.o: modflnm.c
X
Xparse.o: parse.c
X
Xrecomp.o: recomp.c
X
Xrematch.o: rematch.c
X
Xsegment.o: segment.c
X
Xsets.o: sets.c
X
Xunpost.o: unpost.c
X
Xutils.o: utils.c
X
Xuudec.o: uudec.c
END_OF_FILE
  if test 1089 -ne `wc -c <'makefils/makefile.hp'`; then
    echo shar: \"'makefils/makefile.hp'\" unpacked with wrong size!
  fi
  # end of 'makefils/makefile.hp'
fi
if test -f 'makefils/makefile.os2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefils/makefile.os2'\"
else
  echo shar: Extracting \"'makefils/makefile.os2'\" \(1145 characters\)
  sed "s/^X//" >'makefils/makefile.os2' <<'END_OF_FILE'
X#******************************************************************************
X# Module    :   Makefile for UnPost utility. (EMX-GCC)
X#
X# Author    :   John W. M. Stevens
X#******************************************************************************
X
XCC_FLAGS    =   -ansi -DEMX_GCC_COMPILER -DSYSTEM_OS_2
X
X.c.o:
X        gcc -c $(CC_FLAGS) $<
X
Xall: retest unpost
X
Xretest.exe: recomp.o rematch.o retest.o sets.o utils.o
X        gcc $(CC_FLAGS) -o retest.exe retest.o recomp.o rematch.o\
X        sets.o utils.o
X
Xunpost.exe: config.o   decode.o   ident.o    lex.o      list.o \
X        modflnm.o  parse.o    recomp.o   rematch.o  segment.o \
X        sets.o     unpost.o   utils.o    uudec.o
X        gcc -o unpost.exe config.o   decode.o   ident.o    lex.o\
X        list.o      modflnm.o  parse.o    recomp.o   rematch.o\
X        segment.o   sets.o     unpost.o   utils.o    uudec.o
X
Xconfig.o: config.c
X
Xdecode.o: decode.c
X
Xident.o: ident.c
X
Xlex.o: lex.c
X
Xlist.o: list.c
X
Xmodflnm.o: modflnm.c
X
Xparse.o: parse.c
X
Xrecomp.o: recomp.c
X
Xrematch.o: rematch.c
X
Xsegment.o: segment.c
X
Xsets.o: sets.c
X
Xunpost.o: unpost.c
X
Xutils.o: utils.c
X
Xuudec.o: uudec.c
END_OF_FILE
  if test 1145 -ne `wc -c <'makefils/makefile.os2'`; then
    echo shar: \"'makefils/makefile.os2'\" unpacked with wrong size!
  fi
  # end of 'makefils/makefile.os2'
fi
if test -f 'modflnm.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'modflnm.h'\"
else
  echo shar: Extracting \"'modflnm.h'\" \(887 characters\)
  sed "s/^X//" >'modflnm.h' <<'END_OF_FILE'
X/******************************************************************************
X* Module    :   File name utilities.
X*
X* Author    :   John W. M. Stevens
X******************************************************************************/
X
X#if ! defined(MOD_FL_NM_HEADER)
X#define MOD_FL_NM_HEADER
X
X/*  Define maximum base and extension file name string lengths.
X*   Currently, as MS-DOS is the most restrictive, names will tested
X*   for fit into MS-DOS length restrictions.
X*/
X#define MAX_FILE            8
X#define MAX_EXT             3
X#define EXT_SEP_CHAR        '.'
X
X/*  Function prototypes.    */
Xextern
Xvoid    FlNmFilter(char     *FlName);
X
Xextern
Xint     ModifyFlNm(char         *FlName,
X                   char         *Ext,
X                   char         *OutName);
Xextern
Xvoid    ModExten(char   *FlName,
X                 char   *Exten,
X                 char   *OutFlNm);
X
X#endif
END_OF_FILE
  if test 887 -ne `wc -c <'modflnm.h'`; then
    echo shar: \"'modflnm.h'\" unpacked with wrong size!
  fi
  # end of 'modflnm.h'
fi
if test -f 'parse.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'parse.h'\"
else
  echo shar: Extracting \"'parse.h'\" \(3645 characters\)
  sed "s/^X//" >'parse.h' <<'END_OF_FILE'
X/******************************************************************************
X* Module    :   Parser header file.
X*
X* Author    :   John W. M. Stevens
X******************************************************************************/
X
X#if ! defined(PARSER_HEADER_FILE)
X#define     PARSER_HEADER_FILE
X
X#include    "regexp.h"
X#include    "uudec.h"
X
X#define PRS_NO_SEGMENT  -1L     /*  Found end of file before SEGMENT begin. */
X#define PRS_NO_ID_STR   -2L     /*  Did not find an ID string.              */
X#define PRS_NO_UU_LN    -3L     /*  Did not find a UU line in SEGMENT.      */
X#define PRS_NO_BEGIN    -4L     /*  Did not find expected uuencode begin.   */
X#define PRS_NO_SEG_NUM  -5L     /*  Did not find a SEGMENT number.          */
X#define PRS_NO_NUM_SEGS -6L     /*  Did not find total number of SEGMENTs.  */
X#define PRS_UNX_END_SEG -7L     /*  Found unexpected end of segment.        */
X
X/*  Part numbering parsing RE's.    */
Xtypedef struct  {
X    char            *ReExpStr;  /*  RE source string.                   */
X    int             IDStr;      /*  Sub-Expr. number for ID string.     */
X    int             SegNo;      /*  Sub-Expr. for segment number.       */
X    int             NoSegs;     /*  Sub-Expr. for number of segments.   */
X    int             AltIDStr;   /*  Sub-Expr. for alternate ID string.  */
X    CASE_CMP        Case;       /*  Case sensitivity switch.            */
X    REG_EXP_NODE    *ReExpr;    /*  Pointer to compiled RE.             */
X} PART_RE;
X
X/*  Subject line structure. */
Xtypedef struct  {
X    char            *ReExprStr; /*  Pointer to RE source string.        */
X    PART_RE         *IdParts;   /*  List of part number parsing RE's.   */
X    REG_EXP_NODE    *ReExpr;    /*  Pointer to compiled RE.             */
X} IDENT;
X
X/*  Segment RE structure.   */
Xtypedef struct  {
X    char            *ReExprStr; /*  Pointer to RE source string.        */
X    IDENT           *Header;    /*  Header ID regular expressions.      */
X    IDENT           *Body;      /*  Body ID regular expressions.        */
X    REG_EXP_NODE    *ReExpr;    /*  Pointer to compiled RE.             */
X} SEGMENT;
X
X/*  Define a structure to store the results of the first pass.  */
Xtypedef struct  {
X    long        SegOfs;
X    long        UUOfs;
X    int         Exists;
X    int         SegNo;
X    int         SegLstOrd;
X} SEGS;
X
X/*  File list structure.    */
Xtypedef struct  {
X    char    *IDString;      /*  Pointer to SEGMENT ID string.           */
X    char    *FlName;        /*  File name.                              */
X    int     Success;        /*  Successful unpost flag.                 */
X    int     NoSegs;         /*  Number of segments in binary.           */
X    SEGS    *Segs;          /*  Pointer to list of segment desc.        */
X} FL_LIST;
X
X/*  Segment information.    */
Xtypedef struct  {
X    int     NoSegs;
X    int     SegNo;
X    long    SegOfs;
X    long    UUOfs;
X    char    *IDString;
X    char    *FlName;
X} SEG_INFO;
X
X/*  Function prototypes.    */
Xextern
Xvoid    GetBinFlNm(FILE     *InFlPtr,
X                   char     **RetStrs,
X                   char     *FlName);
Xextern
Xint     MatchEnd(char   *Line);
Xextern
Xint     MatchBegin(char     *Line,
X                   char     ***RetStrs);
Xextern
Xint     MatchSegment(char       *Line,
X                     IDENT      **Hdr,
X                     IDENT      **Body);
Xextern
Xlong    Parse(FILE      *InFlPtr,
X              char      *SegLine,
X              char      *IDLine,
X              SEG_INFO  *SegInfo);
Xextern
Xvoid    SetSegBegin(char    *SegType);
Xextern
Xvoid    LoadCfg(char   *CfgFlNm);
Xextern
Xvoid    ParseInit(void);
X
X#endif
END_OF_FILE
  if test 3645 -ne `wc -c <'parse.h'`; then
    echo shar: \"'parse.h'\" unpacked with wrong size!
  fi
  # end of 'parse.h'
fi
if test -f 'read_me.doc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'read_me.doc'\"
else
  echo shar: Extracting \"'read_me.doc'\" \(3023 characters\)
  sed "s/^X//" >'read_me.doc' <<'END_OF_FILE'
XTo compile:
X
XAt this point, you have the archive unpacked, or you will never see this
Xmessage.
X
XSo, since this message is in the unpost directory, all you have to do
Xis make a copy of one of the makefiles in the makefils directory,
Xrenaming it to makefile and moving it to this directory, and type make.
X
XBe aware that you may need to convert the source files (CR<->CR/LF) to
Xmake them acceptable to your compiler.
X
XExample:
X    cp makefils/makefile.dos makefile
X    make
X
XThere are five makefiles:
X
Xmakefile.aix - Contains the makefile that someone ELSE told me worked
X               on his RS6000 running AIX.
X
Xmakefile.dos - Contains the makefile that I used to compile UNPOST
X               on an MS-DOS machine.  I used Borland's C++ compiler,
X               version 3.1.
X
Xmakefile.hp  - This is a makefile that should compile UNPOST on
X               the HP Apollo 700 machines, and maybe some of the
X               other HP Apollo machines.
X
Xmakefile.gcc - Makefile for compiling UNPOST using the gcc (GNU C
X               compiler) compiler. This has the correct switch settings
X               for the gcc compiler that I used (Vers. 2.1).  This
X               makefile was what I used to compile UNPOST on a Sun.
X
X               If your system has sys_errlist already defined,
X               Add -DNO_SYS_ERR_LIST to the compiler flags in the
X               makefile.
X
Xmakefile.os2 - Makefile for compiling UNPOST using the EMX/gcc (GNU C
X               compiler) compiler on OS/2. This has the define for
X               removing the sys_errlist declarations.
X
XBe aware that UNPOST requires an ANSI C compatible compiler, as it uses
Xthe ANSI C function headers for full type checking and maximum portability.
X(If it ain't ANSI C, it ain't portable in the long run).
X
XIf you have any problems, edit the compiler.h file and uncomment the
Xvariable UNPOST_DEBUG.  Then run unpost on your input file, capture
Xthe output sent to standard out and email it to me.  Save the input
Xfile, as I will probably email back asking you to send me one or
Xmore article headers out of it.
X
XIf you have compilation problems, send me as much information as
Xpossible and I will do my best to help you.
X
XSimplest way to use UNPOST:
X
XCapture all articles in a file called source.uue (How is system and
Xnews access method dependent, see unpost.doc for an rn example), then
Xrun unpost by doing:
X
Xunpost -e errors -t text -i incomp source.uue
X
XThat's it.  All complete and correct binary postings that were in
Xfile source.uue will be in the directory that you ran the above
Xcommand in.  The file 'errors' will have a summary of warnings,
Xerrors, the binary postings, parts and byte offsets into the source
Xfile.  The 'text' file will contain text only articles, and the
X'incomp' file will contain any incomplete or incorrect postings.
X
XPlease read the unpost.doc and changes.doc files.  They are the result
Xof a lot of work on my part, and I will feel slighted if you don't at
Xleast take a few seconds to scan them. . . :-)
X
Xjstevens@csn.org
END_OF_FILE
  if test 3023 -ne `wc -c <'read_me.doc'`; then
    echo shar: \"'read_me.doc'\" unpacked with wrong size!
  fi
  # end of 'read_me.doc'
fi
if test -f 'regexp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'regexp.h'\"
else
  echo shar: Extracting \"'regexp.h'\" \(2634 characters\)
  sed "s/^X//" >'regexp.h' <<'END_OF_FILE'
X/******************************************************************************
X* Module    :   Regular Expression String Matching --- Defines, typedefs and
X*               function prototypes.
X*
X* Author    :   John Stevens
X******************************************************************************/
X
X#if ! defined(REGULAR_EXPRESSION_HEADER_FILE)
X#define     REGULAR_EXPRESSION_HEADER_FILE
X
X#include    "sets.h"
X
X/*  Define the maximum number of sub-expressions supported. */
X#define MAX_SUB_EXPRS   20
X
X/*  Flags for case sensitivity in string compares.  */
Xtypedef enum    {
X    CASE_SENSITIVE,
X    IGN_CASE
X} CASE_CMP;
X
X/*  Type of regular expression node in expression tree. */
Xtypedef enum    {
X    NODE_TYPE_NOT_SET,
X    OP_ENUM,                /*  Enumeration operator.       */
X    OP_OR,                  /*  Alternation operator.       */
X    OP_AND,                 /*  Catenation operator.        */
X    OP_L_PAREN,             /*  Parentheses.                */
X    OP_R_PAREN,             /*  Right parentheses.          */
X    END_OR,                 /*  End alternation.            */
X    END_ENUM,               /*  End enumeration.            */
X    DATA_LEFT_ANCHOR,       /*  Anchor left side.           */
X    DATA_RIGHT_ANCHOR,      /*  Anchor right side.          */
X    DATA_ANY,               /*  Any single character.       */
X    DATA_SPAN,              /*  Match any character.        */
X    DATA_STRING,            /*  String data node.           */
X    DATA_SET                /*  Set data node.              */
X} NODE_TYPE;
X
X/*  Type definition for regular expression node in expression tree. */
Xtypedef struct  reg_exp_st
X{
X    NODE_TYPE           NodeType;   /*  Node type, operator or data.    */
X    struct  reg_exp_st  *Left;      /*  Expression tree pointers.       */
X    struct  reg_exp_st  *Right;
X    unsigned int        MinSpan;    /*  Minimum span.                   */
X    unsigned int        MaxSpan;    /*  Maximum span.                   */
X    unsigned int        SubExprNo;  /*  Sub-expression number.          */
X    union
X    {
X        char        *MatchStr;      /*  String to match against.        */
X        SET_TYPE    *CSet;          /*  Character set to match against. */
X    } data;
X} REG_EXP_NODE;
X
X/*  Function prototypes.    */
Xextern  REG_EXP_NODE    *ReCompile(char *);
Xextern  int             ReMatch(char            *Str,
X                                CASE_CMP        Case,
X                                REG_EXP_NODE    *ReExpr,
X                                char            ***SubStrs);
Xextern  REG_EXP_NODE    *FreeReExpr(REG_EXP_NODE    *ReExpr);
X
X#endif
END_OF_FILE
  if test 2634 -ne `wc -c <'regexp.h'`; then
    echo shar: \"'regexp.h'\" unpacked with wrong size!
  fi
  # end of 'regexp.h'
fi
if test -f 'sets.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sets.c'\"
else
  echo shar: Extracting \"'sets.c'\" \(2941 characters\)
  sed "s/^X//" >'sets.c' <<'END_OF_FILE'
X/******************************************************************************
X* Module    :   Bit Mapped Set Functions.
X*
X* Author    :   John W. M. Stevens.
X******************************************************************************/
X
X#include    "sets.h"
X
X#define     NUL     '\0'
X#define     EOL     '\n'
X
X/*-----------------------------------------------------------------------------
X| Routine   :   InSet() --- Test to see if a character is a member of a set.
X|
X| Inputs    :   CSet    - Character set to test against.
X|               c       - Character to test.
X|
X| Returns   :   Zero for not in the set, non-zero for in set.
X-----------------------------------------------------------------------------*/
X
Xint InSet(SET   CSet,
X          char  c)
X{
X    return( (int) (CSet[c / INT_SIZE] & (1 << (c % INT_SIZE))) );
X}
X
X/*-----------------------------------------------------------------------------
X| Routine   :   CrtSet() --- Create a character set.
X|
X| Inputs    :   Str     - String containing set elements.
X| Outputs   :   CSet    - Initialized character set.
X-----------------------------------------------------------------------------*/
X
Xvoid    CrtSet(char **Str,
X               SET  CSet)
X{
X    register    int     i;
X    register    int     c;
X    auto        int     NegateFlag;
X    auto        char    LastCh;
X
X    /*  If the first character of the set is a '^', this is a negated
X    *   set.
X    */
X    if (**Str == '^')
X    {
X        NegateFlag = 1;
X        (*Str)++;
X    }
X    else
X        NegateFlag = 0;
X
X    /*  Clear the set first.    */
X    for (i = 0; i < SET_SIZE; i++)
X        CSet[i] = 0;
X
X    /*  Get characters of set.  */
X    for (LastCh = '\0'; **Str && **Str != ']'; (*Str)++)
X    {
X        /*  Check for escape character. */
X        if (**Str == '\\')
X            (*Str)++;
X        else if (**Str == '-')
X        {
X            /*  Check to make sure that this is a range separator
X            *   character.
X            */
X            if ( LastCh )
X            {
X                /*  Get termination character.  */
X                if ((*Str)[1] && (*Str)[1] != ']')
X                {
X                    /*  Skip escape character.  */
X                    if ((c = *++(*Str)) == '\\')
X                        c = *++(*Str);
X
X                    /*  Fill in range.  */
X                    for (i = LastCh + 1; i < c; i++)
X                        CSet[i / INT_SIZE] |= 1 << (i % INT_SIZE);
X                    LastCh = '\0';
X                }
X            }
X        }
X
X        /*  Add character to set.   */
X        CSet[**Str / INT_SIZE] |= 1 << (**Str % INT_SIZE);
X        LastCh = **Str;
X    }
X    if (**Str == ']')
X        (*Str)++;
X
X    /*  Negate set if necesary. */
X    if ( NegateFlag )
X    {
X        for (i = 0; i < SET_SIZE; i++)
X            CSet[i] = ~CSet[i];
X    }
X
X    /*  Do not EVER match a '\0' or '\n'.   */
X    CSet[0] &= ~1;
X    CSet[EOL / INT_SIZE] &= ~(1 << (EOL % INT_SIZE));
X}
END_OF_FILE
  if test 2941 -ne `wc -c <'sets.c'`; then
    echo shar: \"'sets.c'\" unpacked with wrong size!
  fi
  # end of 'sets.c'
fi
if test -f 'sets.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sets.h'\"
else
  echo shar: Extracting \"'sets.h'\" \(745 characters\)
  sed "s/^X//" >'sets.h' <<'END_OF_FILE'
X/******************************************************************************
X* Module    :   Bit Map Sets Header File
X*
X* Author    :   John Stevens
X******************************************************************************/
X
X#if ! defined(BIT_MAPPED_SETS_HEADER_FILE)
X#define     BIT_MAPPED_SETS_HEADER_FILE
X
X/*  Type defines and macro defines for character set utilities. */
X#if     ! defined(_OS2EMX_H)
Xtypedef unsigned    int     UINT;
X#endif
Xtypedef UINT                SET_TYPE;
X#define INT_SIZE            (sizeof( SET_TYPE ) * 8)
X#define SET_SIZE            (256 / INT_SIZE)
Xtypedef SET_TYPE            SET[SET_SIZE];
X
X/*  Function prototypes.    */
Xextern  int     InSet(SET, char);
Xextern  void    CrtSet(char **, SET);
X
X#endif
END_OF_FILE
  if test 745 -ne `wc -c <'sets.h'`; then
    echo shar: \"'sets.h'\" unpacked with wrong size!
  fi
  # end of 'sets.h'
fi
if test -f 'unpost.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'unpost.h'\"
else
  echo shar: Extracting \"'unpost.h'\" \(764 characters\)
  sed "s/^X//" >'unpost.h' <<'END_OF_FILE'
X/******************************************************************************
X* Module    :   Unpost header file.
X*
X* Author    :   John W. M. Stevens
X******************************************************************************/
X
X#if ! defined(UNPOST_HEADER_FILE)
X#define     UNPOST_HEADER_FILE
X
X/*  Global constants.   */
X#define TRUE    1
X#define ERROR   1
X#define MATCH   1
X#define FALSE   0
X#define OK      0
X
X#define FL_NM_SZ    256
X#define BFR_SIZE    512
X
X#if     ! defined(_OS2EMX_H)
Xtypedef unsigned    char    BYTE;
X#endif
X
X/*  Function prototypes.    */
Xextern
Xint     ReadLine(FILE   *FlPtr,
X                 char   *InBfr,
X                 int    BfrMax);
Xextern
Xchar    *StrDup(char    *Str);
Xextern
Xint     FileExists(char     *FlName);
X
X#endif
END_OF_FILE
  if test 764 -ne `wc -c <'unpost.h'`; then
    echo shar: \"'unpost.h'\" unpacked with wrong size!
  fi
  # end of 'unpost.h'
fi
if test -f 'utils.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils.h'\"
else
  echo shar: Extracting \"'utils.h'\" \(657 characters\)
  sed "s/^X//" >'utils.h' <<'END_OF_FILE'
X/******************************************************************************
X* Module    :   Utility Functions --- Function prototypes.
X*
X* Author    :   John W. M. Stevens
X******************************************************************************/
X
X#if ! defined(UTILITY_HEADER_FILE)
X#define     UTILITY_HEADER_FILE
X
X/*  Function prototypes.    */
Xextern
Xchar    *StrDup(char    *Str);
Xextern
Xint     FileExists(char     *FlName);
Xextern
Xvoid    MemCopy(void    *Dest,
X                void    *Source,
X                int     NoBytes);
Xextern
Xvoid    MemMove(void    *Dest,
X                void    *Source,
X                int     NoBytes);
X
X#endif
END_OF_FILE
  if test 657 -ne `wc -c <'utils.h'`; then
    echo shar: \"'utils.h'\" unpacked with wrong size!
  fi
  # end of 'utils.h'
fi
if test -f 'utils/tokens' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'utils/tokens'\"
else
  echo shar: Extracting \"'utils/tokens'\" \(315 characters\)
  sed "s/^X//" >'utils/tokens' <<'END_OF_FILE'
Xalternate   T_ALTERNATE
Xbody        T_BODY
Xcase        T_CASE
Xheader      T_HEADER
Xid          T_ID
Xignore      T_IGNORE
Xnumber      T_NUMBER
Xpart        T_PART
Xsegment     T_SEGMENT
Xsegments    T_SEGMENTS
Xsensitive   T_SENSITIVE
Xstring      T_STRING
Xtotal       T_TOTAL
X{           T_L_BRACE
X}           T_R_BRACE
END_OF_FILE
  if test 315 -ne `wc -c <'utils/tokens'`; then
    echo shar: \"'utils/tokens'\" unpacked with wrong size!
  fi
  # end of 'utils/tokens'
fi
if test -f 'uudec.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'uudec.h'\"
else
  echo shar: Extracting \"'uudec.h'\" \(879 characters\)
  sed "s/^X//" >'uudec.h' <<'END_OF_FILE'
X/******************************************************************************
X* Module    :   UU Decode header file.
X*
X* Author    :   John W. Stevens
X******************************************************************************/
X
X#if ! defined(UU_DECODE_HEADER)
X#define UU_DECODE_HEADER
X
X#include    "segment.h"
X
X/*  Return value for UU line checking.  */
Xtypedef enum    {
X    UU_TYPE_NOT_SET,
X    NOT_UU_LINE,
X    IS_UU_LINE,
X    UU_SPACE,
X    UU_BEGIN,
X    UU_END
X} CHK_UU_ENC;
X
X/*  Function prototypes.    */
Xextern
XCHK_UU_ENC  ChkUULine(char  *Line,
X                      char  ***RetStrs,
X                      int   *EncLen);
Xextern
XCHK_UU_ENC  DecUULine(char  *Line,
X                      int   *Len,
X                      BYTE  *Bfr);
Xextern
Xvoid        DecTruncUULn(char   *Line,
X                         int    *Len,
X                         BYTE   *Bfr);
X
X#endif
END_OF_FILE
  if test 879 -ne `wc -c <'uudec.h'`; then
    echo shar: \"'uudec.h'\" unpacked with wrong size!
  fi
  # end of 'uudec.h'
fi
echo shar: End of archive 7 \(of 7\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
