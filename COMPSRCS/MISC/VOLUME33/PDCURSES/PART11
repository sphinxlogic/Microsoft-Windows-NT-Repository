Newsgroups: comp.sources.misc
From: M.Hessling@gu.edu.au (Mark Hessling)
Subject:  v33i091:  pdcurses - Public Domain curses library for DOS and OS/2 v2.0, Part11/11
Message-ID: <1992Nov19.040926.8458@sparky.imd.sterling.com>
X-Md4-Signature: 0cd8f1106308cdd4c73dddc306e603e6
Date: Thu, 19 Nov 1992 04:09:26 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: M.Hessling@gu.edu.au (Mark Hessling)
Posting-number: Volume 33, Issue 91
Archive-name: pdcurses/part11
Environment: DOS,OS/2,ANSI-C

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  demos/firework.def demos/newdemo.def demos/testcurs.def
#   demos/xmas.def doc/todo.man flexos/_gname.c nonport/border.c
#   nonport/breakcha.c nonport/cursoff.c nonport/mvwinser.c
#   nonport/rawout.c nonport/tabsize.c nonport/waddraws.c
#   nonport/wordchar.c nonport/wtabsize.c portable/canchang.c
#   portable/clearok.c portable/echo.c portable/erasecha.c
#   portable/fixterm.c portable/gettmode.c portable/has_il.c
#   portable/killchar.c portable/nodelay.c portable/noecho.c
#   portable/resetter.c portable/saveoldt.c portable/saveterm.c
#   portable/ungetch.c private/_clrscr.c private/_findwin.c
#   private/_getscrn.c private/_newline.c private/_rmwin.c
#   private/_usleep.c
# Wrapped by kent@sparky on Wed Nov 18 21:44:11 1992
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 11 (of 11)."'
if test -f 'demos/firework.def' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demos/firework.def'\"
else
  echo shar: Extracting \"'demos/firework.def'\" \(719 characters\)
  sed "s/^X//" >'demos/firework.def' <<'END_OF_FILE'
XNAME firework windowcompat
X
XDESCRIPTION 'test'
X
XPROTMODE
X
XSTACKSIZE 32767
X
XIMPORTS
XVioGetCurType=vio32.Vio32GetCurType
XVioSetCurType=vio32.Vio32SetCurType
XVioGetCurPos=vio32.Vio32GetCurPos
XVioSetCurPos=vio32.Vio32SetCurPos
XVioGetMode=vio32.Vio32GetMode
XVioSetMode=vio32.Vio32SetMode
XVioReadCellStr=vio32.Vio32ReadCellStr
XVioWrtTTY=vio32.Vio32WrtTTY
XVioWrtNAttr=vio32.Vio32WrtNAttr
XVioGetConfig=vio32.Vio32GetConfig
XVioScrollUp=vio32.Vio32ScrollUp
XVioWrtCellStr=vio32.Vio32WrtCellStr
XVioWrtNCell=vio32.Vio32WrtNCell
XVioWrtCharStr=vio32.Vio32WrtCharStr
XKbd32CharIn=kbd32.Kbd32CharIn
XKbd32Peek=kbd32.Kbd32Peek
XKbd32FlushBuffer=kbd32.Kbd32FlushBuffer
XKbd32GetStatus=kbd32.Kbd32GetStatus
XKbd32SetStatus=kbd32.Kbd32SetStatus
END_OF_FILE
  if test 719 -ne `wc -c <'demos/firework.def'`; then
    echo shar: \"'demos/firework.def'\" unpacked with wrong size!
  fi
  # end of 'demos/firework.def'
fi
if test -f 'demos/newdemo.def' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demos/newdemo.def'\"
else
  echo shar: Extracting \"'demos/newdemo.def'\" \(718 characters\)
  sed "s/^X//" >'demos/newdemo.def' <<'END_OF_FILE'
XNAME newdemo windowcompat
X
XDESCRIPTION 'test'
X
XPROTMODE
X
XSTACKSIZE 32767
X
XIMPORTS
XVioGetCurType=vio32.Vio32GetCurType
XVioSetCurType=vio32.Vio32SetCurType
XVioGetCurPos=vio32.Vio32GetCurPos
XVioSetCurPos=vio32.Vio32SetCurPos
XVioGetMode=vio32.Vio32GetMode
XVioSetMode=vio32.Vio32SetMode
XVioReadCellStr=vio32.Vio32ReadCellStr
XVioWrtTTY=vio32.Vio32WrtTTY
XVioWrtNAttr=vio32.Vio32WrtNAttr
XVioGetConfig=vio32.Vio32GetConfig
XVioScrollUp=vio32.Vio32ScrollUp
XVioWrtCellStr=vio32.Vio32WrtCellStr
XVioWrtNCell=vio32.Vio32WrtNCell
XVioWrtCharStr=vio32.Vio32WrtCharStr
XKbd32CharIn=kbd32.Kbd32CharIn
XKbd32Peek=kbd32.Kbd32Peek
XKbd32FlushBuffer=kbd32.Kbd32FlushBuffer
XKbd32GetStatus=kbd32.Kbd32GetStatus
XKbd32SetStatus=kbd32.Kbd32SetStatus
END_OF_FILE
  if test 718 -ne `wc -c <'demos/newdemo.def'`; then
    echo shar: \"'demos/newdemo.def'\" unpacked with wrong size!
  fi
  # end of 'demos/newdemo.def'
fi
if test -f 'demos/testcurs.def' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demos/testcurs.def'\"
else
  echo shar: Extracting \"'demos/testcurs.def'\" \(719 characters\)
  sed "s/^X//" >'demos/testcurs.def' <<'END_OF_FILE'
XNAME testcurs windowcompat
X
XDESCRIPTION 'test'
X
XPROTMODE
X
XSTACKSIZE 32767
X
XIMPORTS
XVioGetCurType=vio32.Vio32GetCurType
XVioSetCurType=vio32.Vio32SetCurType
XVioGetCurPos=vio32.Vio32GetCurPos
XVioSetCurPos=vio32.Vio32SetCurPos
XVioGetMode=vio32.Vio32GetMode
XVioSetMode=vio32.Vio32SetMode
XVioReadCellStr=vio32.Vio32ReadCellStr
XVioWrtTTY=vio32.Vio32WrtTTY
XVioWrtNAttr=vio32.Vio32WrtNAttr
XVioGetConfig=vio32.Vio32GetConfig
XVioScrollUp=vio32.Vio32ScrollUp
XVioWrtCellStr=vio32.Vio32WrtCellStr
XVioWrtNCell=vio32.Vio32WrtNCell
XVioWrtCharStr=vio32.Vio32WrtCharStr
XKbd32CharIn=kbd32.Kbd32CharIn
XKbd32Peek=kbd32.Kbd32Peek
XKbd32FlushBuffer=kbd32.Kbd32FlushBuffer
XKbd32GetStatus=kbd32.Kbd32GetStatus
XKbd32SetStatus=kbd32.Kbd32SetStatus
END_OF_FILE
  if test 719 -ne `wc -c <'demos/testcurs.def'`; then
    echo shar: \"'demos/testcurs.def'\" unpacked with wrong size!
  fi
  # end of 'demos/testcurs.def'
fi
if test -f 'demos/xmas.def' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demos/xmas.def'\"
else
  echo shar: Extracting \"'demos/xmas.def'\" \(715 characters\)
  sed "s/^X//" >'demos/xmas.def' <<'END_OF_FILE'
XNAME xmas windowcompat
X
XDESCRIPTION 'test'
X
XPROTMODE
X
XSTACKSIZE 32767
X
XIMPORTS
XVioGetCurType=vio32.Vio32GetCurType
XVioSetCurType=vio32.Vio32SetCurType
XVioGetCurPos=vio32.Vio32GetCurPos
XVioSetCurPos=vio32.Vio32SetCurPos
XVioGetMode=vio32.Vio32GetMode
XVioSetMode=vio32.Vio32SetMode
XVioReadCellStr=vio32.Vio32ReadCellStr
XVioWrtTTY=vio32.Vio32WrtTTY
XVioWrtNAttr=vio32.Vio32WrtNAttr
XVioGetConfig=vio32.Vio32GetConfig
XVioScrollUp=vio32.Vio32ScrollUp
XVioWrtCellStr=vio32.Vio32WrtCellStr
XVioWrtNCell=vio32.Vio32WrtNCell
XVioWrtCharStr=vio32.Vio32WrtCharStr
XKbd32CharIn=kbd32.Kbd32CharIn
XKbd32Peek=kbd32.Kbd32Peek
XKbd32FlushBuffer=kbd32.Kbd32FlushBuffer
XKbd32GetStatus=kbd32.Kbd32GetStatus
XKbd32SetStatus=kbd32.Kbd32SetStatus
END_OF_FILE
  if test 715 -ne `wc -c <'demos/xmas.def'`; then
    echo shar: \"'demos/xmas.def'\" unpacked with wrong size!
  fi
  # end of 'demos/xmas.def'
fi
if test -f 'doc/todo.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/todo.man'\"
else
  echo shar: Extracting \"'doc/todo.man'\" \(562 characters\)
  sed "s/^X//" >'doc/todo.man' <<'END_OF_FILE'
X/*man-start*********************************************************************
X
XThe following curses functions are not supported in the current release
Xof PDCurses:
X
X   copywin              halfdelay           scr_restore
X                        notimeout           setsyx
X   filter               resetterm           slk*
X   flushok              ripoffline          subpad
X   garbagedlines        scr_dump            vwprintf
X   getsyx               scr_init            vwscanf
X
X**man-end**********************************************************************/
END_OF_FILE
  if test 562 -ne `wc -c <'doc/todo.man'`; then
    echo shar: \"'doc/todo.man'\" unpacked with wrong size!
  fi
  # end of 'doc/todo.man'
fi
if test -f 'flexos/_gname.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flexos/_gname.c'\"
else
  echo shar: Extracting \"'flexos/_gname.c'\" \(927 characters\)
  sed "s/^X//" >'flexos/_gname.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef NDEBUG
Xchar *rcsid__gname = "$Header: c:/curses/flexos/RCS/_gname.c%v 2.0 1992/11/15 02:42:08 mh Rel $";
X#endif
X
X
X
X
X#ifdef	FLEXOS
XVIRCON	vir;			/* Allocate a Virtual Console Structure */
X
X/*man-start*********************************************************************
X
X  _flexos_gname()	- FLEXOS: Return virtual console name
X
X  PDCurses Description:
X 	This is a Flexos platform PDCurses function.
X
X 	This routine returns the name of the Flexos virtual console.
X 	The VIRCON vir structure is initialized within the initscr()
X 	calltree.
X
X  PDCurses Return Value:
X 	This routine returns a character pointer.
X
X  PDCurses Errors:
X 	No errors are defined for this routine.
X
X  Portability:
X 	PDCurses	char*	_flexos_gname( void );
X
X**man-end**********************************************************************/
X
Xchar*	_flexos_gname(void)
X{
X	return (&vir.vc_wname[0]);
X}
X#endif
END_OF_FILE
  if test 927 -ne `wc -c <'flexos/_gname.c'`; then
    echo shar: \"'flexos/_gname.c'\" unpacked with wrong size!
  fi
  # end of 'flexos/_gname.c'
fi
if test -f 'nonport/border.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nonport/border.c'\"
else
  echo shar: Extracting \"'nonport/border.c'\" \(1096 characters\)
  sed "s/^X//" >'nonport/border.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	border
X
X#ifndef	NDEBUG
Xchar *rcsid_border = "$Header: c:/curses/nonport/RCS/border.c%v 2.0 1992/11/15 03:18:25 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  border()	- sets the border characters in the stdscr window.
X
X  PDCurses Description:
X 	This routine sets the border characters for stdscr.
X
X 	WARNING:
X 		Don't make this a call to wborder() - it would
X 		require too much stack for parameters.
X 	
X  PDCurses Return Value:
X 	This function returns OK upon success otherwise ERR is returned.
X
X  PDCurses Errors:
X 	It is an error for stdscr to be a NULL pointer.
X
X  Portability:
X 	PDCurses	int border( chtype l,  chtype r,  chtype t,  chtype b,
X 				    chtype tl, chtype tr  chtype bl, chtype br );
X
X**man-end**********************************************************************/
X
Xint	border(chtype l,chtype r,chtype t,chtype b,chtype tl,chtype tr,chtype bl,chtype br)
X{
X	if (stdscr == (WINDOW *)NULL)
X		return( ERR );
X
X	return( wborder( stdscr, l, r, t, b, tl, tr, bl, br ) );
X}
END_OF_FILE
  if test 1096 -ne `wc -c <'nonport/border.c'`; then
    echo shar: \"'nonport/border.c'\" unpacked with wrong size!
  fi
  # end of 'nonport/border.c'
fi
if test -f 'nonport/breakcha.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nonport/breakcha.c'\"
else
  echo shar: Extracting \"'nonport/breakcha.c'\" \(1142 characters\)
  sed "s/^X//" >'nonport/breakcha.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	breakchar
X
X#ifndef	NDEBUG
Xchar *rcsid_breakcha = "$Header: c:/curses/nonport/RCS/breakcha.c%v 2.0 1992/11/15 03:18:25 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  breakchar()	- Return's user's current break character.
X
X  PDCurses Description:
X
X 	This routine will return the current BREAK char.  This is a
X 	routine and not a macro in anticipation of providing
X 	user-specified BREAK chars.
X
X  PDCurses Return Value:
X 	The (chtype) character value that is the user's current break
X 	character.  This is currently hardcoded, but provided in
X 	anticipation of providing support for a user defined break char.
X
X  PDCurses Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	chtype	breakchar(void);
X 	BSD Curses
X 	SYS V Curses
X**man-end**********************************************************************/
X
Xchtype	breakchar(void)
X{
X#ifdef FLEXOS
X	return( (chtype) 0x03 );
X#endif
X#ifdef DOS
X	return( (chtype) 0x03 );			/* Control-C */
X#endif
X#ifdef OS2
X	return( (chtype) 0x03 );			/* Control-C */
X#endif
X}
END_OF_FILE
  if test 1142 -ne `wc -c <'nonport/breakcha.c'`; then
    echo shar: \"'nonport/breakcha.c'\" unpacked with wrong size!
  fi
  # end of 'nonport/breakcha.c'
fi
if test -f 'nonport/cursoff.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nonport/cursoff.c'\"
else
  echo shar: Extracting \"'nonport/cursoff.c'\" \(1096 characters\)
  sed "s/^X//" >'nonport/cursoff.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	cursoff
X
X#ifndef	NDEBUG
Xchar *rcsid_cursoff = "$Header: c:/curses/nonport/RCS/cursoff.c%v 2.0 1992/11/15 03:18:26 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  cursoff()	- Turns off the hardware cursor.
X
X  PDCurses Description:
X 	Turns off the hardware curses, it does nothing if it is already off.
X
X  PDCurses Return Value:
X 	Returns OK upon success, ERR upon failure.
X
X  PDCurses Errors:
X 	ERR will be returned (in the case of FLEXOS) if the hardware cursor
X 	can not be disabled.
X
X  Portability:
X 	PDCurses	int cursoff( void );
X
X**man-end**********************************************************************/
X
Xint	cursoff(void)
X{
X	if	(_cursvar.visible_cursor)
X	{
X		_cursvar.visible_cursor = FALSE;
X#ifdef     OS2
X		PDC_set_cursor_mode(32, 33);	/* turn it off */
X#else
X		switch (_cursvar.adapter)
X		{
X		case _FLEXOS:
X			PDC_set_cursor_mode(_cursvar.visible_cursor, 0);
X			break;
X		default:
X			PDC_set_cursor_mode(32, 33);	/* turn it off */
X			break;
X		}
X#endif
X	}
X	return( OK );
X}
END_OF_FILE
  if test 1096 -ne `wc -c <'nonport/cursoff.c'`; then
    echo shar: \"'nonport/cursoff.c'\" unpacked with wrong size!
  fi
  # end of 'nonport/cursoff.c'
fi
if test -f 'nonport/mvwinser.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nonport/mvwinser.c'\"
else
  echo shar: Extracting \"'nonport/mvwinser.c'\" \(910 characters\)
  sed "s/^X//" >'nonport/mvwinser.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	mvwinsert
X
X#ifndef	NDEBUG
Xchar *rcsid_mvwinser = "$Header: c:/curses/nonport/RCS/mvwinser.c%v 2.0 1992/11/15 03:18:27 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  mvwinsert()	- Insert line
X
X  PDCurses Description:
X 	A blank line is inserted above the current line and the bottom
X 	line is lost.
X
X 	This routine is provided as an extension to the X/Open interface.
X
X  PDCurses Return Value:
X 	These functions return OK on success and ERR on error.
X
X  PDCurses Errors:
X 	It is an error to call this function with a NULL window pointer.
X
X  Portability:
X 	PDCurses	int mvwinsertln( WINDOW win, int y, int x );
X
X**man-end**********************************************************************/
X
Xint	mvwinsertln(WINDOW *win, int y, int x)
X{
X	return( (wmove(win, y, x) == ERR) ? ERR : winsertln(win) );
X}
END_OF_FILE
  if test 910 -ne `wc -c <'nonport/mvwinser.c'`; then
    echo shar: \"'nonport/mvwinser.c'\" unpacked with wrong size!
  fi
  # end of 'nonport/mvwinser.c'
fi
if test -f 'nonport/rawout.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nonport/rawout.c'\"
else
  echo shar: Extracting \"'nonport/rawout.c'\" \(973 characters\)
  sed "s/^X//" >'nonport/rawout.c' <<'END_OF_FILE'
X#define CURSES_LIBRARY	1
X#include <curses.h>
X#undef  raw_output
X
X#ifndef NDEBUG
Xchar *rcsid_rawout = "$Header: c:/curses/nonport/RCS/rawout.c%v 2.0 1992/11/15 03:18:27 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  raw_output()	- enable raw output mode
X
X  PDCurses Description:
X 	This routine enables the output of raw characters using the
X 	'standard' *add* and *ins* curses functions.
X 	To force 8 bit output and no translation of control characters,
X 	invoke raw_output() with bf as TRUE.  To force 7 bit output and
X 	translation of control characters, invoke raw_output() with bf
X 	as FALSE.
X
X  PDCurses Return Value:
X 	This function returns OK.
X
X  PDCurses Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int raw_output( bool );
X
X**man-end**********************************************************************/
X
Xint	raw_output(bool bf)
X{
X	_cursvar.raw_out = bf;
X	return( OK );
X}
END_OF_FILE
  if test 973 -ne `wc -c <'nonport/rawout.c'`; then
    echo shar: \"'nonport/rawout.c'\" unpacked with wrong size!
  fi
  # end of 'nonport/rawout.c'
fi
if test -f 'nonport/tabsize.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nonport/tabsize.c'\"
else
  echo shar: Extracting \"'nonport/tabsize.c'\" \(959 characters\)
  sed "s/^X//" >'nonport/tabsize.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	tabsize
X
X#ifndef	NDEBUG
Xchar *rcsid_tabsize = "$Header: c:/curses/nonport/RCS/tabsize.c%v 2.0 1992/11/15 03:18:29 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  tabsize()	- Set tab size in window
X
X  PDCurses Description:
X 	This routine sets the tabsize for stdscr and returns the previous
X 	tab size settings.
X
X  PDCurses Return Value:
X 	This routine returns the previous tab size setting upon success
X 	otherwise, it returns ERR.
X
X  PDCurses Errors:
X 	It is an error to call this routine before initscr().
X
X  Portability:
X 	PDCurses	int tabsize( int ts );
X 	X/Open Dec '88	
X 	SysV Curses	
X 	BSD Curses	
X
X**man-end**********************************************************************/
X
Xint	tabsize(int ts)
X{
X	int	origval;
X
X	if (stdscr == (WINDOW *)NULL)
X		return( ERR );
X
X	origval = stdscr->_tabsize;
X	stdscr->_tabsize = ts;
X	return( origval );
X}
END_OF_FILE
  if test 959 -ne `wc -c <'nonport/tabsize.c'`; then
    echo shar: \"'nonport/tabsize.c'\" unpacked with wrong size!
  fi
  # end of 'nonport/tabsize.c'
fi
if test -f 'nonport/waddraws.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nonport/waddraws.c'\"
else
  echo shar: Extracting \"'nonport/waddraws.c'\" \(1104 characters\)
  sed "s/^X//" >'nonport/waddraws.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	waddeawstr
X
X#ifndef	NDEBUG
Xchar *rcsid_waddraws = "$Header: c:/curses/nonport/RCS/waddraws.c%v 2.0 1992/11/15 03:18:29 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  waddrawstr()	- add raw string to window
X
X  PDCurses Description:
X 	The *raw*() routines output 8 bit values.  These contrast to their
X 	normal counterparts which output 7 bit values and convert control
X 	character to the ^X notation.
X
X 	str is a standard 8 bit character string WITHOUT embedded attributes.
X
X  PDCurses Return Value:
X 	The waddrawstr() function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	It is an error to call this function with a NULL window pointer.
X
X  Portability:
X 	PDCurses	int waddrawstr( WINDOW* win, char* str );
X
X**man-end**********************************************************************/
X
Xint	waddrawstr(WINDOW *win, char *str)
X{
X	if (win == (WINDOW *)NULL)
X		return( ERR );
X
X	while (*str)
X	{
X		if (waddrawch(win, *str++) == ERR)
X		{
X			return( ERR );
X		}
X	}
X	return( OK );
X}
END_OF_FILE
  if test 1104 -ne `wc -c <'nonport/waddraws.c'`; then
    echo shar: \"'nonport/waddraws.c'\" unpacked with wrong size!
  fi
  # end of 'nonport/waddraws.c'
fi
if test -f 'nonport/wordchar.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nonport/wordchar.c'\"
else
  echo shar: Extracting \"'nonport/wordchar.c'\" \(892 characters\)
  sed "s/^X//" >'nonport/wordchar.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	wordchar
X
X#ifndef	NDEBUG
Xchar *rcsid_wordchar = "$Header: c:/curses/nonport/RCS/wordchar.c%v 2.0 1992/11/15 03:18:31 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  wordchar()	- returns the users word delete char
X
X  PDCurses Description:
X 	This routine returns the user's current word delete char.
X
X 	At the present time, this is still a constant, but positions
X 	the library to more fully support this in the future.
X
X  PDCurses Errors:
X 	The wordchar returns the user's current delete word character.
X 	If none is specified, then Ctrl-U is returned.
X
X  Portability:
X 	PDCurses	char wordchar( void );
X 	SysV Curses	
X 	BSD Curses	
X
X**man-end**********************************************************************/
X
Xchar	wordchar(void)
X{
X	return (_DWCHAR);			/* word delete char */
X}
END_OF_FILE
  if test 892 -ne `wc -c <'nonport/wordchar.c'`; then
    echo shar: \"'nonport/wordchar.c'\" unpacked with wrong size!
  fi
  # end of 'nonport/wordchar.c'
fi
if test -f 'nonport/wtabsize.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nonport/wtabsize.c'\"
else
  echo shar: Extracting \"'nonport/wtabsize.c'\" \(1003 characters\)
  sed "s/^X//" >'nonport/wtabsize.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	wtabsize
X
X#ifndef	NDEBUG
Xchar *rcsid_wtabsize = "$Header: c:/curses/nonport/RCS/wtabsize.c%v 2.0 1992/11/15 03:18:32 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  wtabsize()	- Set tab size in window
X
X  X/Open Description:
X 	Not available.
X
X  PDCurses Description:
X 	This routine sets the tabsize for stdscr and returns the previous
X 	tab size settings.
X
X  X/Open Return Value:
X 	This routine returns the previous tab size setting upon success
X 	otherwise, it returns ERR.
X
X  PDCurses Errors:
X 	
X
X  Portability:
X 	PDCurses	int wtabsize( WINDOW* win, int ts );
X 	X/Open Dec '88	int wtabsize( WINDOW* win, int ts );
X 	SysV Curses	
X 	BSD Curses	
X
X**man-end**********************************************************************/
X
Xint	wtabsize(WINDOW *win, int ts)
X{
X	int	origval;
X
X	if (win == (WINDOW *)NULL)
X		return( ERR );
X
X	origval = win->_tabsize;
X	win->_tabsize = ts;
X	return( origval );
X}
END_OF_FILE
  if test 1003 -ne `wc -c <'nonport/wtabsize.c'`; then
    echo shar: \"'nonport/wtabsize.c'\" unpacked with wrong size!
  fi
  # end of 'nonport/wtabsize.c'
fi
if test -f 'portable/canchang.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/canchang.c'\"
else
  echo shar: Extracting \"'portable/canchang.c'\" \(876 characters\)
  sed "s/^X//" >'portable/canchang.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef can_change_color
X
X#ifndef	NDEBUG
Xchar *rcsid_canchang = "$Header: c:/curses/portable/RCS/canchang.c%v 2.0 1992/11/15 03:28:47 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  can_change_color()	- Indicate if terminal can change color definitions
X
X  PDCurses Description:
X 	This is defined as a macro.
X
X 	This routine indicates if the terminal has the capability to change
X 	the definition of its colors. Although this is possible at least
X 	with VGA monitors, this function always returns FALSE.
X
X
X  PDCurses Return Value:
X 	This function returns FALSE.
X
X  PDCurses Errors:
X 	N/A
X
X  Portability:
X 	PDCurses	int can_change_color( void );
X
X**man-end**********************************************************************/
X
Xint can_change_color(void)
X{
X return(FALSE);
X}
END_OF_FILE
  if test 876 -ne `wc -c <'portable/canchang.c'`; then
    echo shar: \"'portable/canchang.c'\" unpacked with wrong size!
  fi
  # end of 'portable/canchang.c'
fi
if test -f 'portable/clearok.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/clearok.c'\"
else
  echo shar: Extracting \"'portable/clearok.c'\" \(1138 characters\)
  sed "s/^X//" >'portable/clearok.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	clearok
X
X#ifndef	NDEBUG
Xchar *rcsid_clearok = "$Header: c:/curses/portable/RCS/clearok.c%v 2.0 1992/11/15 03:28:47 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  clearok()	- enable screen clearing
X
X  X/Open Description:
X 	If bf is TRUE, the next call to wrefresh() with this window will
X 	clear the screen completely and redraw the entire screen.
X
X  X/Open Return Value:
X 	The clearok() function returns OK on success and ERR on error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  PDCurses Errors:
X 	It is an error to call this function with a NULL window pointer.
X
X  Portability:
X 	PDCurses	int clearok( WINDOW* win, bool flag );
X 	X/Open Dec '88	int clearok( WINDOW* win, bool bf );
X 	BSD Curses
X 	SYS V Curses	int clearok( WINDOW* win, bool bf );
X
X**man-end**********************************************************************/
X
Xint	clearok(WINDOW *win, bool flag)
X{
X	if (win == (WINDOW *)NULL)
X		return( ERR );
X
X	if (win == curscr)
X		tmpwin->_clear = flag;
X	else
X		win->_clear = flag;
X
X	return( OK );
X}
END_OF_FILE
  if test 1138 -ne `wc -c <'portable/clearok.c'`; then
    echo shar: \"'portable/clearok.c'\" unpacked with wrong size!
  fi
  # end of 'portable/clearok.c'
fi
if test -f 'portable/echo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/echo.c'\"
else
  echo shar: Extracting \"'portable/echo.c'\" \(1030 characters\)
  sed "s/^X//" >'portable/echo.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	echo
X
X#ifndef	NDEBUG
Xchar *rcsid_echo = "$Header: c:/curses/portable/RCS/echo.c%v 2.0 1992/11/15 03:28:50 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  echo()	- enable/disable terminal echo
X
X  X/Open Description:
X 	These functions control whether characters typed by the user
X 	are echoed by the input routine.  Initially, input characters
X 	are echoed.  Subsequent calls to echo() and noecho() do not
X 	flush type-ahead.
X
X  PDCurses Description:
X 	No additional PDCurses functionality.
X
X  X/Open Return Value:
X 	The echo() function returns OK on success and ERR on error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int echo( void );
X 	X/Open Dec '88	int echo( void );
X 	BSD Curses	int echo( void );
X 	SYS V Curses	int echo( void );
X
X**man-end**********************************************************************/
X
Xint	echo(void)
X{
X	_cursvar.echo = TRUE;
X	return( OK );
X}
END_OF_FILE
  if test 1030 -ne `wc -c <'portable/echo.c'`; then
    echo shar: \"'portable/echo.c'\" unpacked with wrong size!
  fi
  # end of 'portable/echo.c'
fi
if test -f 'portable/erasecha.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/erasecha.c'\"
else
  echo shar: Extracting \"'portable/erasecha.c'\" \(1040 characters\)
  sed "s/^X//" >'portable/erasecha.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	erasechar
X
X#ifndef	NDEBUG
Xchar *rcsid_erasecha = "$Header: c:/curses/portable/RCS/erasecha.c%v 2.0 1992/11/15 03:28:51 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  erasechar()	- Return current ERASE character.
X
X  X/Open Description:
X 	The user's current ERASE character is returned.
X
X  PDCurses Description:
X 	This is hardcoded at this time.  There may be future development
X 	to allow applications an easy way to specify this value.
X
X  X/Open Return Value:
X 	The erasechar() function returns the user's current line ERASE
X 	character.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	char erasechar( void );
X 	X/Open Dec '88	char erasechar( void );
X 	BSD Curses	char erasechar( void );
X 	SYS V Curses	char erasechar( void );
X 	
X**man-end**********************************************************************/
X
Xchar	erasechar(void)
X{
X	return(	_ECHAR );	/* character delete char (^H) */
X}
END_OF_FILE
  if test 1040 -ne `wc -c <'portable/erasecha.c'`; then
    echo shar: \"'portable/erasecha.c'\" unpacked with wrong size!
  fi
  # end of 'portable/erasecha.c'
fi
if test -f 'portable/fixterm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/fixterm.c'\"
else
  echo shar: Extracting \"'portable/fixterm.c'\" \(567 characters\)
  sed "s/^X//" >'portable/fixterm.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	fixterm
X
X#ifndef	NDEBUG
Xchar *rcsid_fixterm = "$Header: c:/curses/portable/RCS/fixterm.c%v 2.0 1992/11/15 03:28:52 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  fixterm()	- restore terminal mode
X
X  PDCurses Description:
X 	Now obsolete. Retained for compatibility with older versions
X 	of curses.
X
X 	see reset_prog_mode()
X**man-end**********************************************************************/
X
Xint	fixterm(void)
X{
X	return( reset_prog_mode() );
X}
END_OF_FILE
  if test 567 -ne `wc -c <'portable/fixterm.c'`; then
    echo shar: \"'portable/fixterm.c'\" unpacked with wrong size!
  fi
  # end of 'portable/fixterm.c'
fi
if test -f 'portable/gettmode.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/gettmode.c'\"
else
  echo shar: Extracting \"'portable/gettmode.c'\" \(542 characters\)
  sed "s/^X//" >'portable/gettmode.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	gettmode
X
X#ifndef	NDEBUG
Xchar *rcsid_gettmode = "$Header: c:/curses/portable/RCS/gettmode.c%v 2.0 1992/11/15 03:28:53 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  gettmode()	- Unknown description.
X
X  PDCurses Description:
X 	Now obsolete. Retained for compatibility with older versions
X 	of curses.
X
X 	A no-op.
X**man-end**********************************************************************/
X
Xint	gettmode(void)
X{
X	return (OK);
X}
END_OF_FILE
  if test 542 -ne `wc -c <'portable/gettmode.c'`; then
    echo shar: \"'portable/gettmode.c'\" unpacked with wrong size!
  fi
  # end of 'portable/gettmode.c'
fi
if test -f 'portable/has_il.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/has_il.c'\"
else
  echo shar: Extracting \"'portable/has_il.c'\" \(1184 characters\)
  sed "s/^X//" >'portable/has_il.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	has_il
X
X#ifndef	NDEBUG
Xchar *rcsid_has_il = "$Header: c:/curses/portable/RCS/has_il.c%v 2.0 1992/11/15 03:28:54 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  has_il()	- determine whether insert/delete line available
X
X  X/Open Description:
X 	This function will return TRUE if the terminal has insert line
X 	and delete line capabilities.
X
X  PDCurses Description:
X 	For DOS, this is irrelevant (and ALWAYS TRUE), as the speed of
X 	the DIRECT VIDEO or even BIOS writes is quicker than on a
X 	serial terminal.
X
X 	For FLEXOS, this value has meaning and depends on the terminal,
X 	though at this time, it is a constant TRUE.
X
X  X/Open Return Value:
X 	The has_il() function returns TRUE if the terminal has insert
X 	line and delete line capabilities, otherwise it returns
X 	FALSE.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	bool has_il( void );
X 	X/Open Dec '88	bool has_il( void );
X 	BSD Curses	
X 	SYS V Curses	
X
X**man-end**********************************************************************/
X
Xbool	has_il(void)
X{
X	return( TRUE );
X}
END_OF_FILE
  if test 1184 -ne `wc -c <'portable/has_il.c'`; then
    echo shar: \"'portable/has_il.c'\" unpacked with wrong size!
  fi
  # end of 'portable/has_il.c'
fi
if test -f 'portable/killchar.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/killchar.c'\"
else
  echo shar: Extracting \"'portable/killchar.c'\" \(1015 characters\)
  sed "s/^X//" >'portable/killchar.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	killchar
X
X#ifndef	NDEBUG
Xchar *rcsid_killchar = "$Header: c:/curses/portable/RCS/killchar.c%v 2.0 1992/11/15 03:28:58 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  killchar()	- return current KILL character
X
X  X/Open Description:
X 	The user's current line KILL character.
X
X  PDCurses Description:
X 	This is hardcoded at this time.  There may be future development
X 	to allow applications an easy way to specify this value.
X
X  X/Open Return Value:
X 	The killchar() function returns the user's current line KILL
X 	character.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	char killchar( void );
X 	X/Open Dec '88	char killchar( void );
X 	BSD Curses	char killchar( void );
X 	SYS V Curses	char killchar( void );
X
X**man-end**********************************************************************/
X
Xchar	killchar(void)
X{
X	return( _DLCHAR );	/* line delete char (^U) */
X}
END_OF_FILE
  if test 1015 -ne `wc -c <'portable/killchar.c'`; then
    echo shar: \"'portable/killchar.c'\" unpacked with wrong size!
  fi
  # end of 'portable/killchar.c'
fi
if test -f 'portable/nodelay.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/nodelay.c'\"
else
  echo shar: Extracting \"'portable/nodelay.c'\" \(1151 characters\)
  sed "s/^X//" >'portable/nodelay.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	nodelay
X
X#ifndef	NDEBUG
Xchar *rcsid_nodelay = "$Header: c:/curses/portable/RCS/nodelay.c%v 2.0 1992/11/15 03:29:05 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  nodelay()	- disable block during read
X
X  X/Open Description:
X 	This function controls whether wgetch() is a non-blocking
X 	call. If the option is enabled, and no input is ready, wgetch()
X 	will return ERR. If disabled, wgetch() will hang until input
X 	is ready.
X
X  PDCurses Description:
X 	There is no additional PDCurses functionality for this function.
X
X  X/Open Return Value:
X 	This function returns OK on success and ERR on error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int nodelay( WINDOW* win, bool bf );
X 	X/Open Dec '88	int nodelay( WINDOW* win, bool bf );
X 	BSD Curses	int nodelay( WINDOW* win, bool bf );
X 	SYS V Curses	int nodelay( WINDOW* win, bool bf );
X
X**man-end**********************************************************************/
X
Xint	nodelay( WINDOW *win, bool flag )
X{
X	win->_nodelay = flag;
X	return( OK );
X}
END_OF_FILE
  if test 1151 -ne `wc -c <'portable/nodelay.c'`; then
    echo shar: \"'portable/nodelay.c'\" unpacked with wrong size!
  fi
  # end of 'portable/nodelay.c'
fi
if test -f 'portable/noecho.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/noecho.c'\"
else
  echo shar: Extracting \"'portable/noecho.c'\" \(1050 characters\)
  sed "s/^X//" >'portable/noecho.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	noecho
X
X#ifndef	NDEBUG
Xchar *rcsid_noecho = "$Header: c:/curses/portable/RCS/noecho.c%v 2.0 1992/11/15 03:29:05 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  noecho()	- enable/disable terminal echo
X
X  X/Open Description:
X 	These functions control whether characters typed by the user
X 	are echoed by the input routine.  Initially, input characters
X 	are echoed.  Subsequent calls to echo() and noecho() do not
X 	flush type-ahead.
X
X  PDCurses Description:
X 	No additional PDCurses functionality.
X
X  X/Open Return Value:
X 	The noraw() function returns OK on success and ERR on error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int noecho( void );
X 	X/Open Dec '88	int noecho( void );
X 	BSD Curses	int noecho( void );
X 	SYS V Curses	int noecho( void );
X
X**man-end**********************************************************************/
X
Xint	noecho(void)
X{
X	_cursvar.echo = FALSE;
X	return( OK );
X}
END_OF_FILE
  if test 1050 -ne `wc -c <'portable/noecho.c'`; then
    echo shar: \"'portable/noecho.c'\" unpacked with wrong size!
  fi
  # end of 'portable/noecho.c'
fi
if test -f 'portable/resetter.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/resetter.c'\"
else
  echo shar: Extracting \"'portable/resetter.c'\" \(599 characters\)
  sed "s/^X//" >'portable/resetter.c' <<'END_OF_FILE'
X#include <string.h>
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef NDEBUG
Xchar *rcsid_resetter = "$Header: c:/curses/portable/RCS/resetter.c%v 2.0 1992/11/15 03:29:10 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  resetterm()	- Reset's terminal to "out of curses" mode
X
X  PDCurses Description:
X 	Now obsolete. Retained for compatibility with older versions
X 	of curses.
X
X 	see reset_shell_mode()
X**man-end**********************************************************************/
X
Xint	resetterm(void)
X{
X	return( reset_shell_mode() );
X}
END_OF_FILE
  if test 599 -ne `wc -c <'portable/resetter.c'`; then
    echo shar: \"'portable/resetter.c'\" unpacked with wrong size!
  fi
  # end of 'portable/resetter.c'
fi
if test -f 'portable/saveoldt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/saveoldt.c'\"
else
  echo shar: Extracting \"'portable/saveoldt.c'\" \(527 characters\)
  sed "s/^X//" >'portable/saveoldt.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#if	!defined( NDEBUG )
Xchar *rcsid_saveoldt = "$Header: c:/curses/portable/RCS/saveoldt.c%v 2.0 1992/11/15 03:29:12 MH Rel $";
X#endif
X
X
X/*man-start*********************************************************************
X
X  saveoldterm()	- Unknown description.
X
X  PDCurses Description:
X 	Now obsolete. Retained for compatibility with older versions
X 	of curses.
X**man-end**********************************************************************/
X
Xint	saveoldterm(void)
X{
X	return( OK );
X}
END_OF_FILE
  if test 527 -ne `wc -c <'portable/saveoldt.c'`; then
    echo shar: \"'portable/saveoldt.c'\" unpacked with wrong size!
  fi
  # end of 'portable/saveoldt.c'
fi
if test -f 'portable/saveterm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/saveterm.c'\"
else
  echo shar: Extracting \"'portable/saveterm.c'\" \(574 characters\)
  sed "s/^X//" >'portable/saveterm.c' <<'END_OF_FILE'
X#include <string.h>
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef NDEBUG
Xchar *rcsid_saveterm = "$Header: c:/curses/portable/RCS/saveterm.c%v 2.0 1992/11/15 03:29:13 MH Rel $";
X#endif
X
X/*man-start*********************************************************************
X
X  saveterm()	- Save the terminal settings
X
X  PDCurses Description:
X 	Now obsolete. Retained for compatibility with older versions
X 	of curses.
X
X 	see def_prog_mode()
X**man-end**********************************************************************/
X
Xint	saveterm(void)
X{
X	return( def_prog_mode() );
X}
END_OF_FILE
  if test 574 -ne `wc -c <'portable/saveterm.c'`; then
    echo shar: \"'portable/saveterm.c'\" unpacked with wrong size!
  fi
  # end of 'portable/saveterm.c'
fi
if test -f 'portable/ungetch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/ungetch.c'\"
else
  echo shar: Extracting \"'portable/ungetch.c'\" \(1121 characters\)
  sed "s/^X//" >'portable/ungetch.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	ungetch
X
X#ifndef NDEBUG
Xchar *rcsid_ungetch = "$Header: c:/curses/portable/RCS/ungetch.c%v 2.0 1992/11/15 03:29:20 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  ungetch()	- pushes a character back onto the input stream
X
X  PDCurses Description:
X 	There is only one input stream to ungetch characters onto.  It
X 	is of size NUNGETCH.
X
X  PDCurses Return Value:
X 	The ungetch() routine returns OK upon success otherwise ERR is
X 	returned.
X
X  PDCurses Errors:
X 	ERR will be returned when the push back stack is full.
X
X  Portability:
X 	PDCurses	ungetch( chtype ch );
X 	SysV Curses	
X 	BSD Curses	
X
X**man-end**********************************************************************/
X
Xint	ungetch(chtype ch)
X{
Xextern	int	c_pindex;		/* putter index */
Xextern	int	c_gindex;		/* getter index */
Xextern	int	c_ungind;		/* wungetch() push index */
Xextern	chtype	c_ungch[NUNGETCH];	/* array of ungotten chars */
X
X	if (c_ungind >= NUNGETCH)	/* pushback stack full */
X		return( ERR );
X
X	c_ungch[c_ungind++] = ch;
X	return( OK );
X}
END_OF_FILE
  if test 1121 -ne `wc -c <'portable/ungetch.c'`; then
    echo shar: \"'portable/ungetch.c'\" unpacked with wrong size!
  fi
  # end of 'portable/ungetch.c'
fi
if test -f 'private/_clrscr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_clrscr.c'\"
else
  echo shar: Extracting \"'private/_clrscr.c'\" \(763 characters\)
  sed "s/^X//" >'private/_clrscr.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__clrscr = "$Header: c:/curses/private/RCS/_clrscr.c%v 2.0 1992/11/15 03:24:42 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_clr_scrn()	- Clears the physical screen and homes the cursor.
X
X  PDCurses Description:
X 	This is an internal routine called by the doupdate() routines.
X
X  PDCurses Return Value:
X 	This routine always returns OK.
X
X  Portability:
X 	PDCurses	int PDC_clr_scrn( WINDOW* win );
X
X**man-end**********************************************************************/
X
Xint	PDC_clr_scrn(WINDOW *win)
X{
X	chtype	attrs = win->_attrs;
X	PDC_scroll(0, 0, LINES - 1, COLS - 1, 0, attrs);
X	PDC_gotoxy(0, 0);
X	return( OK );
X}
END_OF_FILE
  if test 763 -ne `wc -c <'private/_clrscr.c'`; then
    echo shar: \"'private/_clrscr.c'\" unpacked with wrong size!
  fi
  # end of 'private/_clrscr.c'
fi
if test -f 'private/_findwin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_findwin.c'\"
else
  echo shar: Extracting \"'private/_findwin.c'\" \(1042 characters\)
  sed "s/^X//" >'private/_findwin.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifdef	REGISTERWINDOWS
X#ifndef	NDEBUG
Xchar *rcsid__findwin = "$Header: c:/curses/private/RCS/_findwin.c%v 2.0 1992/11/15 03:24:42 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_findwin()	- Find a window in the visible windows list.
X
X  PDCurses Description:
X 	This is a private PDCurses routine.
X
X 	This routine is a part of the developing window registration
X 	system that will reach maturity soon.
X
X 	This routine returns the passed WINDOW*'s WINDS pointer.
X
X  PDCurses Return Value:
X 	This function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	WINDS* PDC_findwin( WINDOW* win );
X
X**man-end**********************************************************************/
X
XWINDS*	PDC_findwin(WINDOW *win)
X{
X	WINDS*	next = _cursvar.visible;
X
X	while (next != (WINDS *)NULL)
X	{
X		if (next->w == win)
X			break;
X		next = next->next;
X	}
X	return( next );
X}
X#endif
END_OF_FILE
  if test 1042 -ne `wc -c <'private/_findwin.c'`; then
    echo shar: \"'private/_findwin.c'\" unpacked with wrong size!
  fi
  # end of 'private/_findwin.c'
fi
if test -f 'private/_getscrn.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_getscrn.c'\"
else
  echo shar: Extracting \"'private/_getscrn.c'\" \(1068 characters\)
  sed "s/^X//" >'private/_getscrn.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__getscrn = "$Header: c:/curses/private/RCS/_getscrn.c%v 2.0 1992/11/15 03:24:26 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_get_scrn_mode()	- Return the current BIOS video mode
X
X  PDCurses Description:
X 	This is a private PDCurses routine.
X
X 	Returns the current BIOS Video Mode Number.
X
X  PDCurses Return Value:
X 	This function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	The FLEXOS version of this routine returns an ERR.
X
X  Portability:
X 	PDCurses	int PDC_get_scrn_mode( void );
X
X**man-end**********************************************************************/
X
X#ifdef     OS2
XVIOMODEINFO	PDC_get_scrn_mode(void)
X#else
Xint	PDC_get_scrn_mode(void)
X#endif
X{
X#ifdef	FLEXOS
X	return( ERR );
X#endif
X#ifdef	DOS
X	regs.h.ah = 0x0f;
X	int86(0x10, &regs, &regs);
X	return ((int) regs.h.al);
X#endif
X#ifdef     OS2
X        VIOMODEINFO vioModeInfo;
X        VioGetMode (&vioModeInfo, 0);
X        return vioModeInfo;
X#endif
X}
END_OF_FILE
  if test 1068 -ne `wc -c <'private/_getscrn.c'`; then
    echo shar: \"'private/_getscrn.c'\" unpacked with wrong size!
  fi
  # end of 'private/_getscrn.c'
fi
if test -f 'private/_newline.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_newline.c'\"
else
  echo shar: Extracting \"'private/_newline.c'\" \(962 characters\)
  sed "s/^X//" >'private/_newline.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__newline = "$Header: c:/curses/private/RCS/_newline.c%v 2.0 1992/11/15 03:24:17 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_newline()	- Advances 1 newline from supplied line number.
X
X  PDCurses Description:
X 	This is a private PDCurses routine.
X
X 	Does line advance and returns the new cursor line.  If error,
X 	return -1.
X
X  PDCurses Return Value:
X 	This function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int PDC_newline( WINDOW* win, int lin );
X
X**man-end**********************************************************************/
X
Xint	PDC_newline(WINDOW *win, int lin)
X{
X	if (win == (WINDOW *)NULL)
X		return( -1 );
X
X	if (++lin > win->_bmarg)
X	{
X		lin--;
X		if (win->_scroll)
X			scroll(win);
X		else
X			return( -1 );
X	}
X	return( lin );
X}
END_OF_FILE
  if test 962 -ne `wc -c <'private/_newline.c'`; then
    echo shar: \"'private/_newline.c'\" unpacked with wrong size!
  fi
  # end of 'private/_newline.c'
fi
if test -f 'private/_rmwin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_rmwin.c'\"
else
  echo shar: Extracting \"'private/_rmwin.c'\" \(1200 characters\)
  sed "s/^X//" >'private/_rmwin.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifdef	REGISTERWINDOWS
X#ifndef	NDEBUG
Xchar *rcsid__rmwin = "$Header: c:/curses/private/RCS/_rmwin.c%v 2.0 1992/11/15 03:24:32 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  _rmwin()	- Unregister window
X
X  PDCurses Description:
X 	This routine removes a window from the current visible list
X 	of windows.
X
X  PDCurses Return Value:
X 	This function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	It is an error to call this function with a NULL window pointer.
X
X  Portability:
X 	PDCurses	int _rmwin( WINDOW* win );
X
X**man-end**********************************************************************/
X
Xint	_rmwin(WINDOW *win)
X{
Xextern	void	(*fre)();
X
X	WINDS  *w = _findwin(win);
X	WINDS  *next;
X	WINDS  *prev;
X
X	if (w != (WINDS *)NULL)
X	{
X		if (_cursvar.visible == w)
X		{
X			_cursvar.visible = w->next;
X			(*fre)(w);
X		}
X		else
X		if (w->next == NULL)
X		{
X			if (w->prev != NULL)
X			{
X				w->prev->next = NULL;
X				(*fre)(w);
X			}
X		}
X		else
X		{
X			next = w->next;
X			prev = w->prev;
X			next->prev = prev;
X			prev->next = next;
X			(*fre)(w);
X		}
X		return( OK );
X	}
X	return( ERR );
X}
X#endif
END_OF_FILE
  if test 1200 -ne `wc -c <'private/_rmwin.c'`; then
    echo shar: \"'private/_rmwin.c'\" unpacked with wrong size!
  fi
  # end of 'private/_rmwin.c'
fi
if test -f 'private/_usleep.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_usleep.c'\"
else
  echo shar: Extracting \"'private/_usleep.c'\" \(1149 characters\)
  sed "s/^X//" >'private/_usleep.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef PDC_usleep
X
X#if defined(DOS) && defined(MSC)
X#include <time.h>
X#endif
X
X#ifndef	NDEBUG
Xchar *rcsid__usleep = "$Header: c:/curses/private/RCS/_usleep.c%v 2.0 1992/11/15 03:24:40 MH Rel $";
X#endif
X
X
X
X/*man-start*********************************************************************
X
X  PDC_usleep()	- waits for specified number of microseconds
X
X  PDCurses Description:
X 	This routine is intended to provide a mechanism to wait the
X 	specified number of microseconds. This routine is provided for
X 	users of the Microsoft compilers under DOS as the default
X 	library does not provide a suitable function.
X 	Under any other Operating System/Compiler option, this function
X 	does nothing.
X
X  Portability:
X 	PDCurses	void PDC_usleep( clock_t );
X
X  Acknowledgement
X 	PDC_usleep() was written by John Steele  (jsteele@netcom.com)
X
X**man-end**********************************************************************/
X
X#if defined(DOS) && defined(MSC)
Xvoid	PDC_usleep(clock_t wait)
X{
X	clock_t goal;
X	goal = wait + clock();
X	while (goal > clock())
X	;
X	return;
X}
X#else
Xvoid	PDC_usleep(long wait)
X{
X	return;
X}
X#endif
END_OF_FILE
  if test 1149 -ne `wc -c <'private/_usleep.c'`; then
    echo shar: \"'private/_usleep.c'\" unpacked with wrong size!
  fi
  # end of 'private/_usleep.c'
fi
echo shar: End of archive 11 \(of 11\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
