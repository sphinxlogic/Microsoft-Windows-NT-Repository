Newsgroups: comp.sources.misc
From: M.Hessling@gu.edu.au (Mark Hessling)
Subject:  v33i081:  pdcurses - Public Domain curses library for DOS and OS/2 v2.0, Part01/11
Message-ID: <csm-v33i081=pdcurses.215551@sparky.IMD.Sterling.COM>
X-Md4-Signature: d837022ffc855a0ee7792cdf9c2d611f
Date: Thu, 19 Nov 1992 03:59:11 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: M.Hessling@gu.edu.au (Mark Hessling)
Posting-number: Volume 33, Issue 81
Archive-name: pdcurses/part01
Environment: DOS,OS/2,ANSI-C

                              PDCurses 2.0
                   (Public Domain Curses for DOS and OS/2)

PDCurses is a public domain C library that is compatible with Unix 
System V 3.2 curses written for most of the popular DOS and OS/2 
C compilers.

PDCurses v2.0 is an almost total rewrite of PCCurses 1.4 done by John
'Frotz' Fa'atuai, the previous maintainer.

This version has been tested with Microsoft C v6.0, QuickC v2.0 and
Borland C++ 2.0 under DOS and Microsoft C v6.0 and TopSpeed c v3.02
under OS/2 2.0. Also the library has been compiled successfully with
emx 0.8e, C Set/2 and Watcom 9.

If you wish to be kept up-to-date with changes to PDCurses, contact
Robert Wolf at rwolf@dretor.dciem.dnd.ca and ask to be placed on the
PDCurses mailing list.
----------------------------------------------------------------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  README curses.h demos doc flexos nonport portable
#   portable/newterm.c private tools
# Wrapped by kent@sparky on Wed Nov 18 21:44:05 1992
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 11)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(5305 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
X
X                             PDCurses 2.0
X                  (Public Domain Curses for DOS and OS/2)
X
X
XINTRODUCTION:
X
X	Well, here it finally is; PDCurses v2.0.
X	
X	PDCurses v2.0 is an almost total rewrite of PCCurses 1.4 done by John
X	'Frotz' Fa'atuai, the previous maintainer.
X	
X	This version has been tested with Microsoft C v6.0, QuickC v2.0 and
X	Borland C++ 2.0 under DOS and Microsoft C v6.0 and TopSpeed c v3.02
X	under OS/2 2.0. Also the library has been compiled successfully with
X	emx 0.8e, C Set/2 and Watcom 9.
X	Most testing was done with the large memory model where applicable.
X	The large memory model is probably the best model to use.
X	
X	The amount of testing has not been as extensive as I would have
X	liked, but demands on releasing a product have outweighed the
X	product's quality. Nothing new with that !!
X	Hopefully with wider circulation, more bugs will be fixed more quickly.
X	
X	I have included just 1 makefile which is suitable for dmake 3.8 for
X	both DOS and OS/2. The makefile does not rely on customisation of the
X	dmake.ini file.
X	
X	If you discover bugs, and especially if you have fixes, please let me
X	know ASAP.
X	
X	The source to the library is distributed as a zip file made with zip
X	1.9. You will need Info-ZIP unzip 5.0 to unzip.
X	Follow the directions below to compile the library.
X
XDIRECTIONS:
X
X	1.Create a new directory in which to unzip pdcurs20.zip. This will
X	  create a curses directory and a number of subdirectories containing
X	  source code for the library and utilities and the documentation.
X
X	2.Make changes to the makefile where necessary:
X	  Change the MODEL or model macro to the appropriate value (if it
X	  applies to your compiler). Use model for Borland compilers.
X
X	  Change any paths in the defined macros to be suitable for your
X	  compiler.
X
X	3.Invoke DMAKE [-e environment_options] [target]
X	
X	  where environment_options are:
X
X		OS (host operating system)
X		COMP (compiler)
X		OPT (optimised version or debug version) - optional. default Y
X		TOS (target operating system) - optional. default OS
X
X		see the makefile for valid combinations
X
X		targets: all, demos, lcursesd.lib, manual...
X		
X		NB. dmake is case sensitive with targets, so those environments
X		that use an upper case model value (eg MSC) MUST specify the
X		library target as for eg. Lcursesd.lib
X
X		The makefile is by default set up for Borland C++. The use of
X		-e environment_options override these defaults. Of you prefer
X		you can just change the defaults in the makefile and invoke it
X		without the -e switch.
X
XOTHER NOTES:
X
X	The documentation for the library is built into each source file,
X	a couple of specific doc files and the header files. A program is
X	supplied (manext) to build the manual. This program gets compiled
X	when you build the documentation.
X	
X	To generate the library response file correctly, I had to write a
X	quick and dirty program (buildlrf) to achive this. Originally the
X	makefiles just had statements like: "echo -+$(OBJ)\$* & >> $(LRF)"
X	which appended a suitable line to the response file. Unfortunately
X	under some combinations of makefiles and command processors (eg.
X	nmake and 4DOS) the & would get treated as stderr and the echo
X	command would fail.
X	
X	The original source for PDCurses that I received from the previous
X	maintainer contained support for the FLEXOS operating system. Not
X	having access to it, I could not test the changes I made so its
X	support has fallen by the wayside. If you really need to have PDCurses
X	running under FLEXOS, contact me and I will see what can be arranged.
X
XCOMPILER-SPECIFIC NOTES:
X
X	Microsoft C
X	-----------
X	It is possible with MSC 6.0 to build the OS/2 libraries and demo
X	programs from within DOS. This is the only case where it is possible
X	to specifiy the value of TOS on the command line to be OS2 and the
X	value of OS be DOS.
X
X	C Set/2
X	-------
X	I have only tested the library using the migration libraries. I doubt
X	that the demo programs will work without them.
X
X	emx
X	---
X	Testing has been done with 0.8e of emx together with the 16_to_32
X	libraries.
X	The emx\lib directory should include the vio32.lib and kbd32.lib
X	libraries from the 16_to_32 package.
X
XBUGS and UNFINISHED BUSINESS:
X
X	PDC_set_ctrl_break() function does not work under OS/2.
X	wprint() and PDC_Print() do not work under OS/2.
X	The file todo.man in the doc directory also lists those functions of
X	System V 3.2 curses not yet implemented. Any volunteers ?
X
XACKNOWLEGEMENTS:
X
X	John 'Frotz' Fa'atuai, the previous maintainer for providing an
X	excellent base for further development.
X	John Burnell (johnb@kea.am.dsir.govt.nz), for the OS/2 port.
X	John Steele, Jason (finally NOT a John) Schumate....
X	for various fixes and suggestions.
X	Eberhardt Mattes (author of emx) for allowing code based on his
X	C library to be included with PDCurses.
X	Several others for their support, moral and actual.
X
X
XGood luck, Mark
X
X------------------------------------------------------------------------
XMark Hessling                          email: M.Hessling@itc.gu.edu.au
XDBA, ITS                               phone: + 61 7 875 7691
XGriffith University                    fax:   + 61 7 875 7787
XNathan 4111
XQld Australia                          *** PDCurses maintainer ***
X------------------------------------------------------------------------
END_OF_FILE
  if test 5305 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'curses.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'curses.h'\"
else
  echo shar: Extracting \"'curses.h'\" \(41892 characters\)
  sed "s/^X//" >'curses.h' <<'END_OF_FILE'
X/* $Header: c:/curses/RCS/curses.h%v 2.0 1992/11/16 22:40:30 MH Rel $
X*----------------------------------------------------------------------
X*				PDCurses
X*----------------------------------------------------------------------
X* MH
X*	921120	2.0	Changed #if to #ifdef/#if defined to make it
X*			easier to add new platforms/compilers.
X*
X*			Added System V colour support.
X*
X*			Added OS/2 port.
X*-------
X* Frotz
X*	911221	2.0 pre-beta	Changed back from short to int. (int is the
X*			correct size for the default platform.  Short
X*			might be too short on some platforms.  This
X*			is more portable.  I, also, made this mistake.)
X*
X*			Many functions are now macros.  If you want
X*			the real thing, #undef the macro. (X/Open
X*			requirement.)
X*
X*			Merged many sources into current release.
X*
X*			Added many X/Open routines (not quite all yet).
X*
X*			Added internal documentation to all routines.
X*
X*			Added a HISTORY file to the environment.
X*
X*			Added a CONTRIB file to the environment.
X*-------
X* bl	900114	1.4	Window origin mod in overlay() and overwrite(), on
X*			public (and very reasonable) request. Swapped
X*			#define'd values of OK and ERR; OK now 1, and
X*			ERR is 0/NULL. Conforms better to UNIX
X*			versions.  borderchars[] removed from WINDOW
X*			struct since the border() functions were
X*			redefined. Use of short wherever possible.
X*			Portability improvements, mispelled name of
X*			[w]setscrreg().
X*
X*	881005	1.3	All modules lint-checked with MSC '-W3' and
X*			turbo'C' '-w -w-pro' switches. Support for
X*			border(), wborder() functions.
X*
X*	881002	1.2	Rcsid[] string in all modules, for maintenance.
X*
X*	880306	1.1	'Raw' output routines, revision info in curses.h.
X*
X*	870515	1.0	Initial Release.
X*
X*----------------------------------------------------------------------
X*/
X
X#ifndef  __PDCURSES__
X#define	__PDCURSES__ 1
X
X/*man-start*********************************************************************
X
XAll defines are "defined" here.  All compiler and environment
Xspecific definitions are defined into generic class defines.
XThese defines are to be given values so that the code can
Xrely on #if, rather than a complicated set of #if defined() or
X#ifdefs...
X
XPDCurses definitions list:  (Only define those needed)
X
X	REGISTERWINDOWS True for auto window update registery.
X	FAST_VIDEO      True if display is memory mapped, or
X	                we can utilize the fast video update routines.
X	DOS             True if compiling for DOS.
X	OS2             True if compiling for OS/2.
X	FLEXOS          True if compiling for Flexos.
X	HC              True if using a Metaware compiler.
X	TC              True if using a Borland compiler.
X	MSC             True if using a Microsoft compiler.
X	ANSI            True if the compiler supports ANSI C and
X	                (full or mixed) prototypes.
X	CPLUSPLUS       True if the compiler supports C++.
X
XPDCurses portable platform definitions list:
X
X	PDCurses        Enables access to PDCurses-only routines.
X	XOPEN           Always true.
X	SYSV            True if you are compiling for SYSV portability.
X	BSD             True if you are compiling for BSD portability.
X	INTERNAL        Enables access to internal PDCurses routines.
X**man-end**********************************************************************/
X
X#define	PDCURSES	1	/* PDCurses-only routines	*/
X#define	XOPEN		1	/* X/Open Curses routines	*/
X#define	SYSV		1	/* System V Curses routines	*/
X#define	BSD		1	/* BSD Curses routines		*/
X#define	INTERNAL	1	/* PDCurses Internal routines	*/
X
X
X/*----------------------------------------
X*       BORLAND COMPILERS       Turbo C[++], Borland C[++]
X*
X*       Borland definitions:
X*               TC
X*               DOS
X*               FLEXOS
X*               CPLUSPLUS
X*
X*               __TURBOC__ & __MSDOS__ are predefined by compiler.
X*/
X#ifdef __TURBOC__              /* Borland gives defines this as a value*/
X#  define TC    __TURBOC__     /* Define a value for TC                */
X#  define ANSI  1              /* Borland supports ANSI C prototypes   */
X#  ifdef __MSDOS__
X#    define DOS 6              /* Major release of DOS supported       */
X#    include <bios.h>
X#    include <dos.h>
X#  endif
X#  ifdef __FLEXOS__            /* define this on the command line      */
X#    define FLEXOS 2           /* or latest major release value.       */
X#  endif
X#  if __TURBOC__ >= 0x290
X#    ifdef  __BCPLUSPLUS__
X#      define CPLUSPLUS   1    /* Define that we are compiling C++.    */
X#    endif
X#    ifdef  __TCPLUSPLUS__
X#      define CPLUSPLUS   1    /* Define that we are compiling C++.    */
X#    endif
X#    ifdef  __CPLUSPLUS__
X#      define CPLUSPLUS   1    /* Define that we are compiling C++.    */
X#    endif
X#  endif
X#endif
X
X
X/*----------------------------------------
X*       METAWARE COMPILERS      High C
X*
X*       Metaware definitions:
X*               HC
X*               DOS
X*               FLEXOS
X*/
X#ifdef __HIGHC__
X#  define HC    1
X#  pragma off(prototype_override_warnings)
X#  define ANSI  1              /* Metaware supports ANSI C prototypes  */
X#  ifdef __MSDOS__
X#    define DOS 6              /* Major release of DOS supported       */
X#    include <bios.h>
X#    include <dos.h>
X#  endif
X#  ifdef __FLEXOS__            /* define this on the command line      */
X#    define FLEXOS 2           /* or latest major release value.       */
X#  endif
X#endif
X
X/*----------------------------------------
X*       MICROSOFT COMPILERS      MSC
X*
X*       Microsoft definitions:
X*               MSC
X*               DOS || OS2
X*/
X#ifdef _MSC_VER                                 /* defined by compiler */
X#  define MSC   1
X#  define ANSI  1              /* Microsoft supports ANSI C prototypes */
X#  ifdef __OS2__                /* You will have to define in makefile */
X#    define USE_OS2_H 1             /* Use the os2.h for the compiler  */
X#    define OS2 2                   /* Major release of OS/2 supported */
X#    define INCL_VIO
X#    define INCL_KBD
X#    include <os2.h>
X#    define NO_VSSCANF 1 /* define if no vsscanf() function in library */
X#    define FARKeyword far
X#    define APIRET USHORT
X#    undef MSDOS                        /* have to undef this for OS/2 */
X#  endif
X#  ifdef MSDOS          /* defined by compiler (for both DOS and OS/2) */
X#    define DOS 6                    /* Major release of DOS supported */
X#    include <bios.h>
X#    include <dos.h>
X#    define NO_VSSCANF 1 /* define if no vsscanf() function in library */
X#  endif
X#endif
X
X/*----------------------------------------
X*       TOPSPEED compilers     TSC
X*
X*       TOPSPEED definitions:
X*               TSC
X*               DOS || OS2
X*/
X#ifdef __TSC__                   /* You may have to define in makefile */
X#  define TSC   1
X#  define ANSI  1              /* TopSpeed supports ANSI C prototypes  */
X#  ifdef __OS2__
X#    define OS2 2                   /* Major release of OS/2 supported */
X#    include <cursos2.h>
X#  endif
X#endif
X
X/*----------------------------------------
X*       IBM C Set/2 Compiler   CSET2
X*
X*       IBM definitions:
X*               CSET2
X*               OS2
X*/
X#ifdef __IBMC__
X#  define CSET2 1
X#  define ANSI  1               /* C Set/2 supports ANSI C prototypes  */
X#  ifdef __OS2__
X#    define OS2 2                   /* Major release of OS/2 supported */
X#    define NO_VSSCANF 1 /* define if no vsscanf() function in library */
X#    define INCL_VIO
X#    define INCL_KBD
X#    include <os2.h>
X#  endif
X#endif
X
X/*----------------------------------------
X*       GNU compilers     emx
X*
X*       emx definitions:
X*               EMX
X*               OS2
X*/
X#ifdef __EMX__                   /* You may have to define in makefile */
X#  define EMX   1
X#  define ANSI  1                   /* GNU supports ANSI C prototypes  */
X#  ifdef __OS2__
X#    define OS2 2                   /* Major release of OS/2 supported */
X#    define CURSES__32BIT__
X#    include <cursos2.h>
X#  endif
X#endif
X
X/*----------------------------------------
X*       Watcom C/386 9.0X compiler
X*
X*       WATCOM definitions:
X*               WATCOMC
X*               OS2
X*/
X#ifdef __WATCOMC__
X#  define WATCOMC  1
X#  define ANSI  1          /* Watcom C/386 supports ANSI C prototypes  */
X#  ifdef __OS2__
X#    define OS2 2                   /* Major release of OS/2 supported */
X#    define CURSES__32BIT__
X#    define NO_MEMORY_H      /* this compiler does not have a memory.h */
X#    define INCL_VIO
X#    define INCL_KBD
X#    include <os2.h>
X#  endif
X#endif
X
X/*---------------------------------------------------------------------*/
X
X#include <stdio.h>		/* Required by X/Open usage below	*/
X
X
X
X/*----------------------------------------------------------------------
X *
X *	PDCurses Manifest Constants
X *
X */
X#ifndef FALSE			/* booleans		 */
X#  define	FALSE	0
X#endif
X#ifndef	TRUE			/* booleans		 */
X#  define	TRUE	!FALSE
X#endif
X#ifndef	NULL
X#  define NULL	((void*)0)	/* Null pointer		 */
X#endif
X#define	 ERR	0		/* general error flag	 */
X#define	 OK	1		/* general OK flag	 */
X
X
X
X
X/*----------------------------------------------------------------------
X *
X *	PDCurses Type Declarations
X *
X */
Xtypedef unsigned char bool;	/* PDCurses Boolean type	*/
Xtypedef unsigned short chtype;	/* 8-bit attr + 8-bit char	*/
X
X
X
X
X/*----------------------------------------------------------------------
X *
X *	PDCurses Structure Definitions:
X *
X */
Xtypedef struct _win		/* definition of a window.	   */
X{
X	int	_cury;		/* current pseudo-cursor	   */
X	int	_curx;
X	int	_maxy;		/* max window coordinates	   */
X	int	_maxx;
X	int	_pmaxy;		/* max physical size		   */
X	int	_pmaxx;
X	int	_begy;		/* origin on screen		   */
X	int	_begx;
X	int	_flags;		/* window properties		   */
X	chtype	_attrs;		/* standard A_STANDOUT attributes and colors  */
X	int	_tabsize;	/* tab character size		   */
X	bool	_clear;		/* causes clear at next refresh	   */
X	bool	_leave;		/* leaves cursor as it happens	   */
X	bool	_scroll;	/* allows window scrolling	   */
X	bool	_nodelay;	/* input character wait flag	   */
X	bool	_use_keypad;	/* flags keypad key mode active	   */
X	bool	_use_idl;	/* True if Ins/Del line can be used*/
X	chtype**_y;		/* pointer to line pointer array   */
X	int*	_firstch;	/* first changed character in line */
X	int*	_lastch;	/* last changed character in line  */
X	int	_tmarg;	/* top of scrolling region	   */
X	int	_bmarg;	/* bottom of scrolling region	   */
X	chtype	_borderchars[8];/* non-std border chars		   */
X	char*	_title;		/* window title			   */
X	char	_title_ofs;	/* window title offset from left   */
X	chtype	_title_attr;	/* window title attributes	   */
X	chtype	_blank;		/* window's blank character	   */
Xstruct	_win*	_parent;	/* subwin's pointer to parent win  */
X}	WINDOW;
X
X
X
X/*----------------------------------------------------------------------
X*
X*	Private structures that are necessary for correct
X*	macro construction.
X*
X*/
X
X#ifdef	REGISTERWINDOWS
Xtypedef struct _ref		/* Refresh Window Structure	 */
X{
X	WINDOW*	win;
Xstruct	_ref*	next;
Xstruct	_ref*	tail;
X}	ACTIVE;
X
Xtypedef struct _wins
X{
X	WINDOW*		w;	/* pointer to a visible window	    */
X	struct _wins*	next;	/* Next visible window pointer	    */
X	struct _wins*	prev;	/* Next visible window pointer	    */
X	struct _wins*	tail;	/* Last visible window pointer	    */
X				/* Only head window (stdscr) has    */
X				/* a valid tail pointer.	    */
X}	WINDS;
X#endif
X
X
X
X
Xtypedef struct
X{
X	bool	alive;		/* TRUE if already opened.	    */
X	bool	autocr;		/* if lf -> crlf		    */
X	bool	cbreak;		/* if terminal unbuffered	    */
X	bool	echo;		/* if terminal echo		    */
X	bool	raw_inp;	/* raw input mode (v. cooked input) */
X	bool	raw_out;	/* raw output mode (7 v. 8 bits)    */
X	bool	refrbrk;	/* if premature refresh brk allowed */
X	bool	orgcbr;		/* original MSDOS ^-BREAK setting   */
X	bool	visible_cursor; /* TRUE if cursor is visible	    */
X	bool	audible;	/* FALSE if the bell is visual	    */
X	bool	full_redraw;	/* TRUE for bad performance	    */
X	bool	direct_video;	/* Allow Direct Screen Memory writes*/
X	bool	mono;		/* TRUE if current screen is mono.  */
X	bool	sizeable;	/* TRUE if adapter is resizeable.   */
X	bool	bogus_adapter;	/* TRUE if adapter has insane values*/
X	bool	shell;		/* TRUE if reset_prog_mode() needs  */
X				/*	to be called.		    */
X	chtype	blank;		/* Background character		    */
X	chtype	orig_attr;	/* Original screen attributes	    */
X	int	cursrow;	/* position of physical cursor	    */
X	int	curscol;	/* position of physical cursor	    */
X	int	cursor;		/* Current Cursor definition	    */
X	int	video_page;	/* Current PC video page	    */
X	int	orig_emulation; /* Original cursor emulation value  */
X	int	orig_cursor;	/* Original cursor size		    */
X	int	font;		/* default font size		    */
X	int	orig_font;	/* Original font size		    */
X	int	lines;		/* New value for LINES		    */
X	int	cols;		/* New value for COLS		    */
X	int	emalloc;	/* 0x0C0C if initscr() is to reset  */
X				/*     this value to TRUE;	    */
X				/* TRUE only if emalloc()/ecalloc() */
X				/*     are is to be used;	    */
X				/* FALSE if malloc()/calloc() are   */
X				/*     to be used.		    */
X#ifdef OS2
X	VIOMODEINFO scrnmode;	/* default screen mode		    */
X	VIOCONFIGINFO adapter;	/* Screen type			    */
X#else
X	int	scrnmode;	/* default screen mode		    */
X	int	adapter;	/* Screen type			    */
X	unsigned video_seg;	/* video base segment		    */
X	unsigned video_ofs;	/* video base offset		    */
X#endif
X#ifdef	REGISTERWINDOWS
X	WINDS*	visible;	/* List of visible windows	    */
X	bool	refreshall;	/* Refresh all registered windows?  */
X#endif
X
X}	SCREEN;
X
X
X
X
X
X/* external variables */
Xextern	int	LINES;		/* terminal height		*/
Xextern	int	COLS;		/* terminal width		*/
Xextern	WINDOW*	stdscr;		/* the default screen window	*/
Xextern	SCREEN	_cursvar;	/* curses variables		*/
X
X#if	defined (INTERNAL) | defined (CURSES_LIBRARY)
Xextern	WINDOW*	curscr;		/* the current screen image	*/
Xextern	WINDOW*	tmpwin;		/* the temporary screen image	*/
Xextern	int	_default_lines;	/* For presetting maximum lines	*/
X#endif
X
X#ifdef	REGISTERWINDOWS
Xextern	ACTIVE*	CurWins;	/* Currently Visible Windows	*/
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
XPDCurses Text Attributes:
X
XTo include colour in PDCurses, a number of things had to be sacrificed
Xfrom the strict Unix and System V support.
XThe main problem is fitting all character attributes and colour into
Xan unsigned char (all 8 bits!). On System V, chtype is a long on
XPDCurses it is a short int.
X
XThe following is the structure of a win->_attrs chtype:
X
X-------------------------------------------------
X|15|14|13|12|11|10| 9| 8| 7| 6| 5| 4| 3| 2| 1| 0|
X-------------------------------------------------
X colour number |  attrs |   character eg 'a'
X
Xthe high order char is an index into an array of physical colours
X(defined in INITPAIR.c). 32 (5 bits) foreground/background colour
Xcombinations combined with 8 (3 bits) attribute modifiers are
Xavailable.
X
XThe available attribute enhancers are bold, reverse and blink.
XAll other Unix attributes have no effect as attributes. This
Xlimitation may be overcome in future releases by expanding chtype
Xto a long.
X
X**man-end**********************************************************************/
X
X/* Video attribute definitions. */
X#define A_NORMAL	(chtype)0x0000		/* SysV */
X#define A_ALTCHARSET	(chtype)0x0000		/* X/Open	*/
X#define A_BLINK		(chtype)0x0400		/* X/Open	*/
X#define A_BLANK		(chtype)0x0000		/* X/Open	*/
X#define A_BOLD		(chtype)0x0100		/* X/Open	*/
X#define A_DIM		(chtype)0x0000		/* X/Open	*/
X#define A_PROTECT	(chtype)0x0000		/* X/Open	*/
X#define A_REVERSE	(chtype)0x0200		/* X/Open	*/
X#define A_STANDOUT	((chtype)(A_REVERSE | A_BOLD))		/* X/Open	*/
X#define A_UNDERLINE	(chtype)0x0000		/* X/Open	*/
X#define A_COLOR	(chtype)0xF800		/*System V	*/
X
X#define CHR_MSK		(chtype)(0xFF)		/* Obsolete	*/
X#define ATR_MSK		(chtype)(~CHR_MSK)	/* Obsolete	*/
X#define ATR_NRM		A_NORMAL			/* Obsolete	*/
X#define A_CHARTEXT	CHR_MSK			/* X/Open	*/
X#define A_ATTRIBUTES	ATR_MSK			/* X/Open	*/
X
X/* ALTCHARSET definitions from jshumate@logds1.wr.aflc.af.mil */
X#define ACS_ULCORNER	(chtype)0xda			/* SysV		*/
X#define ACS_LLCORNER	(chtype)0xc0			/* SysV		*/
X#define ACS_URCORNER	(chtype)0xbf			/* SysV		*/
X#define ACS_LRCORNER	(chtype)0xd9			/* SysV		*/
X#define ACS_RTEE	(chtype)0xb4			/* SysV		*/
X#define ACS_LTEE	(chtype)0xc3			/* SysV		*/
X#define ACS_BTEE	(chtype)0xc1			/* SysV		*/
X#define ACS_TTEE	(chtype)0xc2			/* SysV		*/
X#define ACS_HLINE	(chtype)0xc4			/* SysV		*/
X#define ACS_VLINE	(chtype)0xb3			/* SysV		*/
X#define ACS_PLUS	(chtype)0xc5			/* SysV		*/
X#define ACS_S1	(chtype)0x2d			/* SysV		*/
X#define ACS_S9	(chtype)0x5f			/* SysV		*/
X#define ACS_DIAMOND	(chtype)0xc5			/* SysV		*/
X#define ACS_CKBOARD	(chtype)0xb2			/* SysV		*/
X#define ACS_DEGREE	(chtype)0xf8			/* SysV		*/
X#define ACS_PLMINUS	(chtype)0xf1			/* SysV		*/
X#define ACS_BULLET	(chtype)0xf9			/* SysV		*/
X#define ACS_LARROW	(chtype)0x3c			/* SysV		*/
X#define ACS_RARROW	(chtype)0x3e			/* SysV		*/
X#define ACS_DARROW	(chtype)0x76			/* SysV		*/
X#define ACS_UARROW	(chtype)0x5e			/* SysV		*/
X#define ACS_BOARD	(chtype)0x23			/* SysV		*/
X#define ACS_LANTERN	(chtype)0x23			/* SysV		*/
X#define ACS_BLOCK	(chtype)0x23			/* SysV		*/
X
X/* the following definitions can be used if you have set raw_output()
X   or are using the PDCurses *raw*() functions                        */
X#if 0
X#define ACS_DIAMOND	(chtype)0x04			/* SysV		*/
X#define ACS_LARROW	(chtype)0x1b			/* SysV		*/
X#define ACS_RARROW	(chtype)0x1a			/* SysV		*/
X#define ACS_DARROW	(chtype)0x19			/* SysV		*/
X#define ACS_UARROW	(chtype)0x18			/* SysV		*/
X#define ACS_BOARD	(chtype)0xb0			/* SysV		*/
X#define ACS_LANTERN	(chtype)0x0f			/* SysV		*/
X#define ACS_BLOCK	(chtype)0xdb			/* SysV		*/
X#endif
X
X/* colour attributes */
X#define COLOR_BLACK		0
X#define COLOR_BLUE		1
X#define COLOR_GREEN		2
X#define COLOR_CYAN		3
X#define COLOR_RED		4
X#define COLOR_MAGENTA		5
X#define COLOR_YELLOW		6
X#define COLOR_WHITE		7
X
X#define COLOR_PAIR(n)  (((n) << 11) & A_ATTRIBUTES)
X#define PAIR_NUMBER(n) (((n) & A_COLOR) >> 11)
X
Xextern int COLORS,COLOR_PAIRS;
X/*----------------------------------------------------------------------
X *
X *	Function and Keypad Key Definitions.
X *	Many are just for compatibility.
X *
X */
X#define KEY_MIN         0x101   /* Minimum curses key value      */
X#define KEY_BREAK       0x101   /* Not on PC KBD                 */
X#define KEY_DOWN        0x102   /* Down arrow key                */
X#define KEY_UP          0x103   /* Up arrow key                  */
X#define KEY_LEFT        0x104   /* Left arrow key                */
X#define KEY_RIGHT       0x105   /* Right arrow key               */
X#define KEY_HOME        0x106   /* home key                      */
X#define KEY_BACKSPACE   0x107   /* not on pc                     */
X#define KEY_F0          0x108   /* function keys. space for      */
X#define KEY_F(n)    (KEY_F0+(n))/* 64 keys are reserved.         */
X#define KEY_DL          0x148   /* not on pc                     */
X#define KEY_IL          0x149   /* insert line                   */
X#define KEY_DC          0x14a   /* delete character              */
X#define KEY_IC          0x14b   /* insert char or enter ins mode */
X#define KEY_EIC         0x14c   /* exit insert char mode         */
X#define KEY_CLEAR       0x14d   /* clear screen                  */
X#define KEY_EOS         0x14e   /* clear to end of screen        */
X#define KEY_EOL         0x14f   /* clear to end of line          */
X#define KEY_SF          0x150   /* scroll 1 line forward         */
X#define KEY_SR          0x151   /* scroll 1 line back (reverse)  */
X#define KEY_NPAGE       0x152   /* next page                     */
X#define KEY_PPAGE       0x153   /* previous page                 */
X#define KEY_STAB        0x154   /* set tab                       */
X#define KEY_CTAB        0x155   /* clear tab                     */
X#define KEY_CATAB       0x156   /* clear all tabs                */
X#define KEY_ENTER       0x157   /* enter or send (unreliable)    */
X#define KEY_SRESET      0x158   /* soft/reset (partial/unreliable)*/
X#define KEY_RESET       0x159   /* reset/hard reset (unreliable) */
X#define KEY_PRINT       0x15a   /* print/copy                    */
X#define KEY_LL          0x15b   /* home down/bottom (lower left) */
X#define KEY_ABORT       0x15c   /* abort/terminate key (any)     */
X#define KEY_SHELP       0x15d   /* short help                    */
X#define KEY_LHELP       0x15e   /* long help                     */
X#define KEY_BTAB        0x15f   /* Back tab key                  */
X#define KEY_BEG         0x160   /* beg(inning) key               */
X#define KEY_CANCEL      0x161   /* cancel key                    */
X#define KEY_CLOSE       0x162   /* close key                     */
X#define KEY_COMMAND     0x163   /* cmd (command) key             */
X#define KEY_COPY        0x164   /* copy key                      */
X#define KEY_CREATE      0x165   /* create key                    */
X#define KEY_END         0x166   /* end key                       */
X#define KEY_EXIT        0x167   /* exit key                      */
X#define KEY_FIND        0x168   /* find key                      */
X#define KEY_HELP        0x169   /* help key                      */
X#define KEY_MARK        0x16a   /* mark key                      */
X#define KEY_MESSAGE     0x16b   /* message key                   */
X#define KEY_MOVE        0x16c   /* move key                      */
X#define KEY_NEXT        0x16d   /* next object key               */
X#define KEY_OPEN        0x16e   /* open key                      */
X#define KEY_OPTIONS     0x16f   /* options key                   */
X#define KEY_PREVIOUS    0x170   /* previous object key           */
X#define KEY_REDO        0x171   /* redo key                      */
X#define KEY_REFERENCE   0x172   /* ref(erence) key               */
X#define KEY_REFRESH     0x173   /* refresh key                   */
X#define KEY_REPLACE     0x174   /* replace key                   */
X#define KEY_RESTART     0x175   /* restart key                   */
X#define KEY_RESUME      0x176   /* resume key                    */
X#define KEY_SAVE        0x177   /* save key                      */
X#define KEY_SBEG        0x178   /* shifted beginning key         */
X#define KEY_SCANCEL     0x179   /* shifted cancel key            */
X#define KEY_SCOMMAND    0x17a   /* shifted command key           */
X#define KEY_SCOPY       0x17b   /* shifted copy key              */
X#define KEY_SCREATE     0x17c   /* shifted create key            */
X#define KEY_SDC         0x17d   /* shifted delete char key       */
X#define KEY_SDL         0x17e   /* shifted delete line key       */
X#define KEY_SELECT      0x17f   /* select key                    */
X#define KEY_SEND        0x180   /* shifted end key               */
X#define KEY_SEOL        0x181   /* shifted clear line key        */
X#define KEY_SEXIT       0x182   /* shifted exit key              */
X#define KEY_SFIND       0x183   /* shifted find key              */
X#define KEY_SHOME       0x184   /* shifted home key              */
X#define KEY_SIC         0x185   /* shifted input key             */
X#define KEY_SLEFT       0x187   /* shifted left arrow key        */
X#define KEY_SMESSAGE    0x188   /* shifted message key           */
X#define KEY_SMOVE       0x189   /* shifted move key              */
X#define KEY_SNEXT       0x18a   /* shifted next key              */
X#define KEY_SOPTIONS    0x18b   /* shifted options key           */
X#define KEY_SPREVIOUS   0x18c   /* shifted prev key              */
X#define KEY_SPRINT      0x18d   /* shifted print key             */
X#define KEY_SREDO       0x18e   /* shifted redo key              */
X#define KEY_SREPLACE    0x18f   /* shifted replace key           */
X#define KEY_SRIGHT      0x190   /* shifted right arrow           */
X#define KEY_SRSUME      0x191   /* shifted resume key            */
X#define KEY_SSAVE       0x192   /* shifted save key              */
X#define KEY_SSUSPEND    0x193   /* shifted suspend key           */
X#define KEY_SUNDO       0x194   /* shifted undo key              */
X#define KEY_SUSPEND     0x195   /* suspend key                   */
X#define KEY_UNDO        0x196   /* undo key                      */
X
X/* PDCurses specific key definitions */
X
X#define ALT_0           0x197   /* Alt-0                PC only  */
X#define ALT_1           0x198   /* Alt-1                PC only  */
X#define ALT_2           0x199   /* Alt-2                PC only  */
X#define ALT_3           0x19a   /* Alt-3                PC only  */
X#define ALT_4           0x19b   /* Alt-4                PC only  */
X#define ALT_5           0x19c   /* Alt-5                PC only  */
X#define ALT_6           0x19d   /* Alt-6                PC only  */
X#define ALT_7           0x19e   /* Alt-7                PC only  */
X#define ALT_8           0x19f   /* Alt-8                PC only  */
X#define ALT_9           0x1a0   /* Alt-9                PC only  */
X#define ALT_A           0x1a1   /* Alt-A                PC only  */
X#define ALT_B           0x1a2   /* Alt-B                PC only  */
X#define ALT_C           0x1a3   /* Alt-C                PC only  */
X#define ALT_D           0x1a4   /* Alt-D                PC only  */
X#define ALT_E           0x1a5   /* Alt-E                PC only  */
X#define ALT_F           0x1a6   /* Alt-F                PC only  */
X#define ALT_G           0x1a7   /* Alt-G                PC only  */
X#define ALT_H           0x1a8   /* Alt-H                PC only  */
X#define ALT_I           0x1a9   /* Alt-I                PC only  */
X#define ALT_J           0x1aa   /* Alt-J                PC only  */
X#define ALT_K           0x1ab   /* Alt-K                PC only  */
X#define ALT_L           0x1ac   /* Alt-L                PC only  */
X#define ALT_M           0x1ad   /* Alt-M                PC only  */
X#define ALT_N           0x1ae   /* Alt-N                PC only  */
X#define ALT_O           0x1af   /* Alt-O                PC only  */
X#define ALT_P           0x1b0   /* Alt-P                PC only  */
X#define ALT_Q           0x1b1   /* Alt-Q                PC only  */
X#define ALT_R           0x1b2   /* Alt-R                PC only  */
X#define ALT_S           0x1b3   /* Alt-S                PC only  */
X#define ALT_T           0x1b4   /* Alt-T                PC only  */
X#define ALT_U           0x1b5   /* Alt-U                PC only  */
X#define ALT_V           0x1b6   /* Alt-V                PC only  */
X#define ALT_W           0x1b7   /* Alt-W                PC only  */
X#define ALT_X           0x1b8   /* Alt-X                PC only  */
X#define ALT_Y           0x1b9   /* Alt-Y                PC only  */
X#define ALT_Z           0x1ba   /* Alt-Z                PC only  */
X#define CTL_LEFT        0x1bb   /* Control-Left-Arrow   PC only  */
X#define CTL_RIGHT       0x1bc   /* Control-Right-Arrow  PC only  */
X#define CTL_PGUP        0x1bd   /* Control-PgUp         PC only  */
X#define CTL_PGDN        0x1be   /* Control-PgDn         PC only  */
X#define CTL_HOME        0x1bf   /* Control-Home         PC only  */
X#define CTL_END         0x1c0   /* Control-End          PC only  */
X#define KEY_BACKTAB     0x1c1   /* Back-tab             PC only  */
X
X#ifdef FLEXOS
X#define KEY_A1          KEY_HOME/* upper left on Virtual keypad  */
X#define KEY_A2          KEY_UP  /* upper middle on Virt. keypad  */
X#define KEY_A3          KEY_PPAGE/* upper right on Vir. keypad   */
X#define KEY_B1          KEY_LEFT/* middle left on Virt. keypad   */
X#define KEY_B2          0x00    /* center on Virt. keypad        */
X#define KEY_B3          KEY_RIGHT/* middle right on Vir. keypad  */
X#define KEY_C1          KEY_LL  /* lower left on Virt. keypad    */
X#define KEY_C2          KEY_DOWN /* lower middle on Virt. keypad */
X#define KEY_C3          KEY_NPAGE /* lower right on Vir. keypad  */
X#define KEY_MAX         KEY_BACKTAB /* Maximum curses key        */
X#endif
X
X
X#if defined(DOS)  || defined (OS2)
X#define KEY_A1          0x1c2   /* upper left on Virtual keypad  */
X#define KEY_A2          0x1c3   /* upper middle on Virt. keypad  */
X#define KEY_A3          0x1c4   /* upper right on Vir. keypad    */
X#define KEY_B1          0x1c5   /* middle left on Virt. keypad   */
X#define KEY_B2          0x1c6   /* center on Virt. keypad        */
X#define KEY_B3          0x1c7   /* middle right on Vir. keypad   */
X#define KEY_C1          0x1c8   /* lower left on Virt. keypad    */
X#define KEY_C2          0x1c9   /* lower middle on Virt. keypad  */
X#define KEY_C3          0x1ca   /* lower right on Vir. keypad    */
X#define PADSLASH        0x1cb   /* slash on keypad               */
X#define PADENTER        0x1cc   /* enter on keypad               */
X#define CTL_PADENTER    0x1cd   /* ctl-enter on keypad           */
X#define ALT_PADENTER    0x1ce   /* alt-enter on keypad           */
X#define SHF_PADSTOP     0x1cf   /* shift-stop on keypad          */
X#define PADSTAR         0x1d0   /* star on keypad                */
X#define PADMINUS        0x1d1   /* minus on keypad               */
X#define PADPLUS         0x1d2   /* plus on keypad                */
X#define CTL_PADSTOP     0x1d3   /* ctl-stop on keypad            */
X#define CTL_PADCENTER   0x1d4   /* ctl-enter on keypad           */
X#define CTL_PADPLUS     0x1d5   /* ctl-plus on keypad            */
X#define CTL_PADMINUS    0x1d6   /* ctl-minus on keypad           */
X#define CTL_PADSLASH    0x1d7   /* ctl-slash on keypad           */
X#define CTL_PADSTAR     0x1d8   /* ctl-star on keypad            */
X#define ALT_PADPLUS     0x1d9   /* alt-plus on keypad            */
X#define ALT_PADMINUS    0x1da   /* alt-minus on keypad           */
X#define ALT_PADSLASH    0x1db   /* alt-slash on keypad           */
X#define ALT_PADSTAR     0x1dc   /* alt-star on keypad            */
X#define CTL_INS         0x1dd   /* ctl-insert                    */
X#define ALT_DEL         0x1de   /* alt-delete                    */
X#define ALT_INS         0x1df   /* alt-insert                    */
X#define CTL_UP          0x1e0   /* ctl-up arrow                  */
X#define CTL_DOWN        0x1e1   /* ctl-down arrow                */
X#define CTL_TAB         0x1e2   /* ctl-tab                       */
X#define ALT_TAB         0x1e3   /* alt-tab                       */
X#define ALT_MINUS       0x1e4   /* alt-minus                     */
X#define ALT_EQUAL       0x1e5   /* alt-equal                     */
X#define ALT_HOME        0x1e6   /* alt-home                      */
X#define ALT_PGUP        0x1e7   /* alt-pgup                      */
X#define ALT_PGDN        0x1e8   /* alt-pgdn                      */
X#define ALT_END         0x1e9   /* alt-end                       */
X#define ALT_UP          0x1ea   /* alt-up arrow                  */
X#define ALT_DOWN        0x1eb   /* alt-down arrow                */
X#define ALT_RIGHT       0x1ec   /* alt-right arrow               */
X#define ALT_LEFT        0x1ed   /* alt-left arrow                */
X#define ALT_ENTER       0x1ee   /* alt-enter                     */
X#define ALT_ESC         0x1ef   /* alt-escape                    */
X#define ALT_BQUOTE      0x1f0   /* alt-back quote                */
X#define ALT_LBRACKET    0x1f1   /* alt-left bracket              */
X#define ALT_RBRACKET    0x1f2   /* alt-right bracket             */
X#define ALT_SEMICOLON   0x1f3   /* alt-semi-colon                */
X#define ALT_FQUOTE      0x1f4   /* alt-forward quote             */
X#define ALT_COMMA       0x1f5   /* alt-comma                     */
X#define ALT_STOP        0x1f6   /* alt-stop                      */
X#define ALT_FSLASH      0x1f7   /* alt-forward slash             */
X#define ALT_BKSP        0x1f8   /* alt-backspace                 */
X#define CTL_BKSP        0x1f9   /* ctl-backspace                 */
X#define CTL_PAD0        0x1fa   /* ctl-keypad 0                  */
X#define CTL_PAD1        0x1fb   /* ctl-keypad 1                  */
X#define CTL_PAD2        0x1fc   /* ctl-keypad 2                  */
X#define CTL_PAD3        0x1fd   /* ctl-keypad 3                  */
X#define CTL_PAD4        0x1fe   /* ctl-keypad 4                  */
X#define CTL_PAD5        0x1ff   /* ctl-keypad 5                  */
X#define CTL_PAD6        0x200   /* ctl-keypad 6                  */
X#define CTL_PAD7        0x201   /* ctl-keypad 7                  */
X#define CTL_PAD8        0x202   /* ctl-keypad 8                  */
X#define CTL_PAD9        0x203   /* ctl-keypad 9                  */
X#define CTL_DEL         0x204   /* clt-delete                    */
X#define ALT_BSLASH      0x205   /* alt-back slash                */
X#define CTL_ENTER       0x206   /* ctl-enter                     */
X#define KEY_MAX         CTL_ENTER  /* Maximum curses key         */
X#endif
X
X
X
X/*----------------------------------------------------------------------
X*       PDCurses function declarations
X*/
X#ifdef ANSI
X#  ifdef   CPLUSPLUS
X     extern "C" {
X#  endif
Xbool    typeahead( FILE* );
Xchar    erasechar( void );
Xchar    killchar( void );
Xchar    wordchar( void );
Xchar*   longname( void );
Xchar*   unctrl( chtype );
Xint     baudrate( void );
Xint     beep( void );
Xint     border( chtype, chtype, chtype, chtype, chtype, chtype, chtype, chtype );
Xint     can_change_color ( void );
Xint     clearok( WINDOW*, bool );
Xint     color_content( int, short*, short*, short* );
Xint     def_prog_mode( void );
Xint     def_shell_mode( void );
Xint     delwin( WINDOW* );
Xint     delay_output(  int  );
Xint     doupdate( void );
Xint     endwin( void );
Xint     flash( void );
Xint     flushinp( void );
Xint     has_colors( void );
Xint     init_color( int, short, short, short );
Xint     init_pair( int, short, short );
Xint     intrflush(  WINDOW*, bool  );
Xchar *  keyname(  int  );
Xint     mvaddrawch( int, int, chtype );
Xint     mvaddrawstr( int, int, char* );
Xint     mvcur( int, int, int, int );
Xint     mvinsrawch( int, int, chtype );
Xint     mvprintw( int, int, char*,... );
Xint     mvwin( WINDOW*, int, int );
Xint     mvwinsrawch( WINDOW*, int, int, chtype );
Xint     mvwprintw( WINDOW*, int, int, char*,... );
Xint     newline( WINDOW*, int );
Xint     noraw( void );
Xint     overlay( WINDOW*, WINDOW* );
Xint     overwrite( WINDOW*, WINDOW* );
Xint     pair_content( int, short*, short* );
Xint     pnoutrefresh( WINDOW*, int, int, int, int, int, int );
Xint     prefresh( WINDOW*, int, int, int, int, int, int );
Xint     printw( char*,... );
Xint     raw( void );
Xint     refresh( void );
Xint     resetterm( void );
Xint     resetty( void );
Xint     reset_prog_mode( void );
Xint     reset_shell_mode( void );
Xint     saveoldterm( void );
Xint     saveterm( void );
Xint     savetty( void );
Xint     scroll( WINDOW* );
Xint     start_color( void );
Xint     tabsize( int );
Xint     touchline( WINDOW*, int ,int );
Xint     touchwin( WINDOW* );
Xint     waddrawstr( WINDOW*, char* );
Xint     waddstr( WINDOW*, char* );
Xint     wattroff( WINDOW*, int );
Xint     wattron( WINDOW*, int );
Xint     wattrset( WINDOW*, int );
Xint     wborder( WINDOW*, chtype, chtype, chtype, chtype, chtype, chtype, chtype, chtype );
Xint     wbox( WINDOW*, int, int, int, int, chtype, chtype );
Xint     wclrtobot( WINDOW* );
Xint     wclrtoeol( WINDOW* );
Xint     wdelch( WINDOW* );
Xint     wdeleteln( WINDOW* );
Xint     werase( WINDOW* );
Xint     wgetch( WINDOW* );
Xint     wgetstr( WINDOW*, char* );
Xint     winsch( WINDOW*, chtype );
Xint     winsertln( WINDOW* );
Xint     wmove( WINDOW*, int, int );
Xint     wnoutrefresh( WINDOW* );
Xint     wprintw( WINDOW*, char*,... );
Xint     wrefresh( WINDOW* );
Xint     wsetscrreg( WINDOW*, int, int );
Xint     wtabsize( WINDOW*, int );
Xint     wungetch( chtype );
XSCREEN* newterm( char*, FILE*, FILE* );
XSCREEN* set_term( SCREEN* );
XWINDOW* initscr( void );
XWINDOW* newpad( int, int );
XWINDOW* newwin( int, int, int, int );
XWINDOW* subwin( WINDOW*, int, int, int, int );
Xint     meta( WINDOW*, bool );
Xint     gettmode( void );
Xint     fixterm( void );
Xint     cursoff( void );
Xint     curson( void );
Xint     curs_set( int );
X
X#ifdef     PDCURSES
Xint     resize( int );
Xint     win_print( WINDOW*, int );
XWINDOW* resize_win( WINDOW*, int, int );
Xint     raw_output( bool );
X#endif
X
Xint     scanw( char*,... );
Xint     mvscanw( int, int, char*,... );
Xint     mvwscanw( WINDOW*, int, int, char*,... );
Xint     wscanw( WINDOW*, char*,... );
X
X/*
X*       Keep the compiler happy with our macros below...
X*/
Xint     PDC_chadd( WINDOW*, chtype, bool, bool );
Xint     PDC_chins( WINDOW*, chtype, bool );
X
X#  ifdef   CPLUSPLUS
X     }
X#  endif
X#endif
X
X
X
X/*
X*       Functions defined as macros
X*/
X#ifndef max
X#define max(a,b) (((a) > (b)) ? (a) : (b))
X#endif
X#ifndef min
X#define min(a,b) (((a) < (b)) ? (a) : (b))
X#endif
X
X
X#define addch( c )              waddch( stdscr, c )
X#define addstr(str)             waddstr( stdscr, str )
X#define attroff(attr)           wattroff( stdscr, (chtype)attr )
X#define attron(attr)            wattron( stdscr, (chtype)attr )
X#define attrset(attr)           wattrset( stdscr, (chtype)attr )
X#define box( w, v, h )          wbox( w, 0, 0, 0, 0, v, h )
X#define can_change_color()      FALSE
X#define cbreak()                (_cursvar.cbreak = TRUE)
X#define clear()                 (clearok( stdscr, TRUE )==ERR?ERR:wclear( stdscr ))
X#define clrtobot()              wclrtobot( stdscr )
X#define clrtoeol()              wclrtoeol( stdscr )
X#define crmode()                (_cursvar.cbreak = TRUE)
X#define delch()                 wdelch( stdscr )
X#define deleteln()              wdeleteln( stdscr )
X#define erase()                 werase( stdscr )
X#define getch()                 wgetch(stdscr)
X#define getstr(str)             wgetstr( stdscr, str )
X#define getyx(w,y,x)            ( y = (w)->_cury, x = (w)->_curx )
X#define getbegyx(w,y,x)         ( y = (w)->_begy, x = (w)->_begx )
X#define getmaxyx(w,y,x)         ( y = (w)->_maxy, x = (w)->_maxx )
X#define has_colors()            ((_cursvar.mono) ? FALSE : TRUE)
X#define has_ic()                TRUE
X#define has_il()                TRUE
X#define idlok()                 OK
X#define inch()                  (stdscr->_y[stdscr->_cury][stdscr->_curx])
X#define insch( c )              winsch( stdscr, c )
X#define insertln()              winsertln( stdscr )
X#define isendwin()              ((_cursvar.alive) ? FALSE : TRUE)
X#define keypad(w,flag)          (w->_use_keypad  = flag)
X#define leaveok(w,flag)         (w->_leave   = flag)
X#define move(y,x)               wmove( stdscr, y, x )
X#define mvaddch(y,x,c)          (move( y, x )==ERR?ERR:addch( c ))
X#define mvaddstr(y,x,str)       (move( y, x )==ERR?ERR:addstr( str ))
X#define mvdelch(y,x)            (move( y, x )==ERR?ERR:wdelch( stdscr ))
X#define mvgetch(y,x)            (move( y, x )==ERR?ERR:wgetch(stdscr))
X#define mvgetstr(y,x,str)       {move( y, x )==ERR?ERR:wgetstr( stdscr, str ))
X#define mvinch(y,x)             (wmove(stdscr,y,x)==ERR?ERR:(w->_y[y][x]))
X#define mvinsch(y,x,c)          (move( y, x )==ERR?ERR:winsch( stdscr, c ))
X#define mvwaddch(w,y,x,c)       (wmove( w, y, x )==ERR?ERR:waddch( w, c ))
X#define mvwaddstr(w,y,x,str)    (wmove( w, y, x )==ERR?ERR:waddstr( w, str ))
X#define mvwaddrawch(w,y,x,c)    (wmove( w, y, x )==ERR?ERR:waddrawch( w, c ))
X#define mvwaddrawstr(w,y,x,str) (wmove( w, y, x )==ERR?ERR:waddrawstr( w, str ))
X#define mvwdelch(w,y,x)         (wmove( w, y, x )==ERR?ERR:wdelch( w ))
X#define mvwgetch(w,y,x)         (wmove( w, y, x )==ERR?ERR:wgetch( w ))
X#define mvwgetstr(w,y,x,str)    (wmove( w, y, x )==ERR?ERR:wgetstr( w, str ))
X#define mvwinch(w,y,x)          (wmove(w,y,x)==ERR?ERR:(w->_y[y][x]))
X#define mvwinsch(w,y,x,c)       (wmove( w, y, x )==ERR?ERR:winsch( w, c ))
X#define napms(ms)               delay_output(ms)
X#define nl()                    (_cursvar.autocr = TRUE)
X#define nocbreak()              (_cursvar.cbreak = FALSE)
X#define nocrmode()              (_cursvar.cbreak = FALSE)
X#define nodelay(w,flag)         (w->_nodelay = flag)
X#define noecho()                (_cursvar.echo = FALSE)
X#define echo()                  (_cursvar.echo = TRUE)
X#define nonl()                  (_cursvar.autocr = FALSE)
X#define refrbrk(flag)           (_cursvar.refrbrk = flag)
X#define refresh()               wrefresh( stdscr )
X#define scrollok(w,flag)        (w->_scroll  = flag)
X#define setscrreg(top, bot)     wsetscrreg( stdscr, top, bot )
X#define standend()              wstandend( stdscr )
X#define standout()              wstandout( stdscr )
X#define ungetch(c)              wungetch(c)
X#define waddch(w, c)            PDC_chadd( w, (chtype)c, (bool)!(_cursvar.raw_out), TRUE )
X#define wclear(w)               ( werase( w )==ERR?ERR:(w->_clear = TRUE))
X#define winch(w)                (w->_y[w->_cury][w->_curx])
X#define wstandend(w)            (wattroff(w, A_STANDOUT)==ERR?ERR:(w->_attrs = 0))
X#define wstandout(w)            wattrset(w, A_STANDOUT);
X#define echochar(c)             (addch((chtype)c)==ERR?ERR:refresh())
X#define wechochar(w,c)          (waddch(w,(chtype)c)==ERR?ERR:wrefresh(w))
X#define pechochar(w,c)          (waddch(w,(chtype)c)==ERR?ERR:prefresh(w))
X
X#ifdef     PDCURSES
X#define addrawch( c )           waddrawch( stdscr, c )
X#define addrawstr(str)          waddrawstr( stdscr, str )
X#define insrawch( c )           winsrawch( stdscr, c )
X#define waddrawch(w, c)         PDC_chadd( w, (chtype)c, FALSE, TRUE )
X#define winsrawch(w, c)         PDC_chins( w, (chtype)c, FALSE )
X
X/*
X *      FYI: Need to document these functions...
X */
X#define title(s,a)              wtitle( stdscr, s, (chtype)a )
X#define titleofs(ofs)           wtitleofs( stdscr, ofs )
X#define wtitle(w,s,a)           (w->_title = s, w->_title_attr = (chtype)a)
X#define wtitleofs(w,ofs)        (w->_title_ofs = ofs)
X#endif
X
X/*
X *      Load up curspriv.h.     This should be in the same place as
X *      curses.h.  We allow anyone who defines CURSES_LIBRARY to have
X *      access to our internal routines.  This provides quick
X *      PC applications at the expense of portability.
X */
X#if defined     (CURSES_LIBRARY) | defined( INTERNAL)
X#  include <curspriv.h>
X#  include <stdlib.h>
X#endif
X
X#endif  /* __PDCURSES__ */
END_OF_FILE
  if test 41892 -ne `wc -c <'curses.h'`; then
    echo shar: \"'curses.h'\" unpacked with wrong size!
  fi
  # end of 'curses.h'
fi
if test ! -d 'demos' ; then
    echo shar: Creating directory \"'demos'\"
    mkdir 'demos'
fi
if test ! -d 'doc' ; then
    echo shar: Creating directory \"'doc'\"
    mkdir 'doc'
fi
if test ! -d 'flexos' ; then
    echo shar: Creating directory \"'flexos'\"
    mkdir 'flexos'
fi
if test ! -d 'nonport' ; then
    echo shar: Creating directory \"'nonport'\"
    mkdir 'nonport'
fi
if test ! -d 'portable' ; then
    echo shar: Creating directory \"'portable'\"
    mkdir 'portable'
fi
if test -f 'portable/newterm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/newterm.c'\"
else
  echo shar: Extracting \"'portable/newterm.c'\" \(3226 characters\)
  sed "s/^X//" >'portable/newterm.c' <<'END_OF_FILE'
X#include <stdlib.h>
X#ifndef NO_MEMORY_H
X#include <memory.h>
X#endif
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	newterm
X
X#ifndef	NDEBUG
Xchar *rcsid_newterm = "$Header: c:/curses/portable/RCS/newterm.c%v 2.0 1992/11/15 03:29:03 MH Rel $";
X#endif
X
X#if	EMALLOC
Xvoid*	emalloc( size_t );
Xvoid*	ecalloc( size_t, size_t );
Xvoid	efree( void* );
X#endif
X
X
X
X
X#if 0
X/*man-start*********************************************************************
X
X  newterm()	- open new terminal
X
X  X/Open Description:
X 	A program which outputs to more than one terminal should use
X 	for each terminal instead of initscr().  The newterm() function
X 	should be called once for each terminal.  It returns a value of
X 	type SCREEN* which should be saved as a reference to that terminal.
X 	The arguments are the type of of terminal to be used in place of
X 	TERM (environment variable), a file pointer for output to the
X 	terminal and another file pointer for input from the terminal.  The
X 	program must also call endwin() for each terminal no longer being
X 	used.
X
X  PDCurses Description:
X 	This routine is a quick hack.  It is basically a copy of initscr()
X 	with the appropriate arguments being passed.  There is no formal
X 	support yet for dual monitor systems.  This is almost, but not
X 	quiet, a NOP.
X
X 	outfd and infd are ignored, but required for portability.
X
X  X/Open Return Value:
X 	The newterm() function returns stdscr on success otherwise ERR is
X 	returned.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  PDCurses Errors:
X 	It is an error to open the same SCREEN more than once.
X
X  Portability:
X 	PDCurses	SCREEN* newtern( char* type, FILE outfd, FILE infd );
X 	X/Open Dec '88	SCREEN* newtern( char* type, FILE outfd, FILE infd );
X 	BSD Curses	
X 	SYS V Curses	SCREEN* newtern( char* type, FILE outfd, FILE infd );
X
X**man-end**********************************************************************/
X
XSCREEN*	newterm( char *type, FILE *outfd, FILE *infd )
X{
X#ifdef	TC
X#  pragma argsused
X#endif
Xextern	void*	mallc();	/* malloc(size)		*/
Xextern	void*	callc();	/* calloc(num,size)	*/
Xextern	void	fre();		/* free(ptr)		*/
X
Xextern	void*	malloc();
Xextern	void*	calloc();
Xextern	void	free();
X
X	if  (_cursvar.alive)
X		return( ERR );
X
X	if  (_cursvar.emalloc == EMALLOC_MAGIC)
X	{
X#if	EMALLOC
X		memset(&_cursvar, 0, sizeof(SCREEN));
X		_cursvar.emalloc = TRUE;
X		mallc = emalloc;
X		callc = ecalloc;
X		fre   = efree;
X#endif
X	}
X	else
X	{
X		memset(&_cursvar, 0, sizeof(SCREEN));
X		mallc = malloc;
X		callc = calloc;
X		fre   = free;
X	}
X	PDC_scr_open(&_cursvar, 0);
X	_cursvar.orig_cursor = _cursvar.cursor;
X	_cursvar.orig_font = PDC_get_font();
X	_cursvar.orgcbr = PDC_get_ctrl_break();
X	_cursvar.blank = ' ';
X#ifdef	FLEXOS
X	_flexos_16bitmode();
X#endif
X	savetty();
X	LINES = PDC_get_rows();
X	COLS = PDC_get_columns();
X
X	if ((tmpwin = newwin(LINES, COLS, 0, 0)) == (WINDOW *) ERR)
X	{
X		return( ERR );
X	}
X	if ((curscr = newwin(LINES, COLS, 0, 0)) == (WINDOW *) ERR)
X	{
X		return( ERR );
X	}
X	if ((stdscr = newwin(LINES, COLS, 0, 0)) == (WINDOW *) ERR)
X	{
X		return( ERR );
X	}
X	curscr->_clear = FALSE;
X#ifdef	REGISTERWINDOWS
X	_cursvar.refreshall = FALSE;
X	_inswin(stdscr, (WINDOW *)NULL);
X#endif
X	_cursvar.alive = TRUE;
X	return( &_cursvar );
X}
X#endif
END_OF_FILE
  if test 3226 -ne `wc -c <'portable/newterm.c'`; then
    echo shar: \"'portable/newterm.c'\" unpacked with wrong size!
  fi
  # end of 'portable/newterm.c'
fi
if test ! -d 'private' ; then
    echo shar: Creating directory \"'private'\"
    mkdir 'private'
fi
if test ! -d 'tools' ; then
    echo shar: Creating directory \"'tools'\"
    mkdir 'tools'
fi
echo shar: End of archive 1 \(of 11\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
