Newsgroups: comp.sources.misc
From: M.Hessling@gu.edu.au (Mark Hessling)
Subject:  v33i090:  pdcurses - Public Domain curses library for DOS and OS/2 v2.0, Part10/11
Message-ID: <1992Nov19.040854.8383@sparky.imd.sterling.com>
X-Md4-Signature: 45b2bda9ce028a0c276ed5a9fdb64bdc
Date: Thu, 19 Nov 1992 04:08:54 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: M.Hessling@gu.edu.au (Mark Hessling)
Posting-number: Volume 33, Issue 90
Archive-name: pdcurses/part10
Environment: DOS,OS/2,ANSI-C

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  flexos/_16bitmo.c flexos/_8bitmod.c nonport/wborder.c
#   pdcurses.cfg portable/baudrate.c portable/beep.c portable/box.c
#   portable/cbreak.c portable/delay_ou.c portable/getyx.c
#   portable/has_ic.c portable/initcolo.c portable/meta.c
#   portable/mvcur.c portable/mvwin.c portable/nl.c
#   portable/nocbreak.c portable/refresh.c portable/scrollok.c
#   portable/startcol.c portable/touchlin.c portable/wclear.c
#   portable/werase.c portable/winsch.c private/_addtail.c
#   private/_ckbiosk.c private/_gcrspos.c private/_gcurcol.c
#   private/_gcurrow.c private/_getattr.c private/_scrnmod.c
# Wrapped by kent@sparky on Wed Nov 18 21:44:10 1992
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 10 (of 11)."'
if test -f 'flexos/_16bitmo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flexos/_16bitmo.c'\"
else
  echo shar: Extracting \"'flexos/_16bitmo.c'\" \(1370 characters\)
  sed "s/^X//" >'flexos/_16bitmo.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__16bitmo = "$Header: c:/curses/flexos/RCS/_16bitmod.c%v 2.0 1992/11/15 02:42:04 mh Rel $";
X#endif
X
X
X
X
X#ifdef	FLEXOS
X/*man-start*********************************************************************
X
X  _flexos_16bitmode()	- Puts console 16 bit mode.
X
X  PDCurses Description:
X 	This routine sets 16 bit mode (8 bit character +
X 	8 bit attribute) for Flexos.
X
X  PDCurses Return Value:
X 	This function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	Under FLEXOS, an ERR will be returned if the s_get() call
X 	fails, or if the s_set() call fails.  You are referred to
X 	the Flexos Programmer's Reference Guide for details on the
X 	actual error.
X
X  Portability:
X 	PDCurses	int _flexos_16bitmode( void );
X
X**man-end**********************************************************************/
X
Xint	_flexos_16bitmode(void)
X{
Xextern	VIRCON	vir;		/* Allocate a Virtual Console Structure */
X
X	retcode = s_get(T_VIRCON, 0L, (char *) &vir, (long) sizeof(vir));
X	if (retcode < 0L)
X		return( ERR );
X
X	vir.vc_kbmode = vir.vc_kbmode | (VCKM_NABORT | VCKM_NSTOP |
X					 VCKM_NXLAT  | VCKM_NESC  |
X					 VCKM_16BIT  | VCKM_NECHO |
X					 VCKM_NEOF);
X
X	vir.vc_smode = vir.vc_smode | VCSM_16BIT;
X
X	retcode = s_set(T_VIRCON, 0L, (char *) &vir, (long) sizeof(vir));
X	return( (retcode < 0L) ? ERR : OK );
X}
X#endif
END_OF_FILE
  if test 1370 -ne `wc -c <'flexos/_16bitmo.c'`; then
    echo shar: \"'flexos/_16bitmo.c'\" unpacked with wrong size!
  fi
  # end of 'flexos/_16bitmo.c'
fi
if test -f 'flexos/_8bitmod.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'flexos/_8bitmod.c'\"
else
  echo shar: Extracting \"'flexos/_8bitmod.c'\" \(1254 characters\)
  sed "s/^X//" >'flexos/_8bitmod.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__8bitmod = "$Header: c:/curses/flexos/RCS/_8bitmod.c%v 2.0 1992/11/15 02:42:10 mh Rel $";
X#endif
X
X
X
X
X#ifdef	FLEXOS
X/*man-start*********************************************************************
X
X  _flexos_8bitmode()	- Puts console into 8 bit mode.
X
X  PDCurses Description:
X 	This routine sets 8 bit mode (no 8 bit attribute) for Flexos.
X
X  PDCurses Return Value:
X 	This function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	Under FLEXOS, an ERR will be returned if the s_get() call
X 	fails, or if the s_set() call fails.  You are referred to
X 	the Flexos Programmer's Reference Guide for details on the
X 	actual error.
X
X  Portability:
X 	PDCurses	int _flexos_16bitmode( void );
X
X**man-end**********************************************************************/
X
Xint	_flexos_8bitmode(void)
X{
Xextern	VIRCON	vir;		/* Allocate a Virtual Console Structure */
X
X	retcode = s_get(T_VIRCON, 0L, (char *) &vir, (long) sizeof(vir));
X	if (retcode < 0L)
X		return( ERR );
X
X	vir.vc_kbmode = vir.vc_kbmode & ~VCKM_16BIT;
X	vir.vc_smode = vir.vc_smode & ~VCKM_16BIT;
X
X	retcode = s_set(T_VIRCON, 0L, (char *) &vir, (long) sizeof(vir));
X	return( (retcode < 0L) ? ERR : OK );
X}
X#endif
END_OF_FILE
  if test 1254 -ne `wc -c <'flexos/_8bitmod.c'`; then
    echo shar: \"'flexos/_8bitmod.c'\" unpacked with wrong size!
  fi
  # end of 'flexos/_8bitmod.c'
fi
if test -f 'nonport/wborder.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'nonport/wborder.c'\"
else
  echo shar: Extracting \"'nonport/wborder.c'\" \(1193 characters\)
  sed "s/^X//" >'nonport/wborder.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	wborder
X
X#ifndef	NDEBUG
Xchar *rcsid_wborder = "$Header: c:/curses/nonport/RCS/wborder.c%v 2.0 1992/11/15 03:18:29 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  wborder()	- sets the border characters in the passed window.
X
X  PDCurses Description:
X 	This routine sets the border characters for the passed window.
X
X  PDCurses Return Value:
X 	This function returns OK upon success otherwise ERR is returned.
X
X  PDCurses Errors:
X 	It is an error for stdscr to be a NULL pointer.
X
X  Portability:
X 	PDCurses	int wborder( chtype l,  chtype r,  chtype t,  chtype b,
X 				    chtype tl, chtype tr  chtype bl, chtype br );
X
X**man-end**********************************************************************/
X
Xint	wborder(WINDOW *win,chtype l,chtype r,chtype t,chtype b,chtype tl,chtype tr,chtype bl,chtype br)
X{
X	if (win == (WINDOW *)NULL)
X		return( ERR );
X
X	win->_borderchars[0] = l;
X	win->_borderchars[1] = r;
X	win->_borderchars[2] = t;
X	win->_borderchars[3] = b;
X	win->_borderchars[4] = tl;
X	win->_borderchars[5] = tr;
X	win->_borderchars[6] = bl;
X	win->_borderchars[7] = br;
X	return( OK );
X}
END_OF_FILE
  if test 1193 -ne `wc -c <'nonport/wborder.c'`; then
    echo shar: \"'nonport/wborder.c'\" unpacked with wrong size!
  fi
  # end of 'nonport/wborder.c'
fi
if test -f 'pdcurses.cfg' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pdcurses.cfg'\"
else
  echo shar: Extracting \"'pdcurses.cfg'\" \(43 characters\)
  sed "s/^X//" >'pdcurses.cfg' <<'END_OF_FILE'
X-1-
X-2-
X-K
X-G
X-rd
X-d
X-V
X-w-eff
X-j0
X-c 
X-P-
END_OF_FILE
  if test 43 -ne `wc -c <'pdcurses.cfg'`; then
    echo shar: \"'pdcurses.cfg'\" unpacked with wrong size!
  fi
  # end of 'pdcurses.cfg'
fi
if test -f 'portable/baudrate.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/baudrate.c'\"
else
  echo shar: Extracting \"'portable/baudrate.c'\" \(1358 characters\)
  sed "s/^X//" >'portable/baudrate.c' <<'END_OF_FILE'
X#include <limits.h>
X#define CURSES_LIBRARY	1
X#include <curses.h>
X#undef baudrate
X
X#ifndef	NDEBUG
Xchar *rcsid_baudrate = "$Header: c:/curses/portable/RCS/baudrate.c%v 2.0 1992/11/15 03:28:45 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  baudrate()	- Return terminal baud rate
X
X  X/Open Description:
X 	Returns the output speed of the terminal.  The number returned
X 	is bits per second, for example 9600, and is an integer.
X
X  PDCurses Description:
X 	If FAST_VIDEO is true, then this is the largest possible
X 	(portable) int value (INT_MAX from limits.h) IF direct
X 	video is possible, OR the approximate guess at BIOS speeds,
X 	19200.
X
X 	If FAST_VIDEO is false, this is an approximate guess at BIOS
X 	speeds, 19200.
X
X  X/Open Return Value:
X 	The baudrate() function returns a pointer to a verbose description
X 	of the current terminal on success and the null pointer on error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses		int baudrate( void );
X 	X/Open Dec '88		int baudrate( void );
X 	BSD Curses
X 	SYS V Curses
X
X**man-end**********************************************************************/
X
Xint	baudrate(void)
X{
X#ifdef FAST_VIDEO
X	return (_cursvar.direct_video ? INT_MAX : 19200 );
X#else
X	return (19200);			/* Approx. guess at BIOS speeds.*/
X#endif
X}
END_OF_FILE
  if test 1358 -ne `wc -c <'portable/baudrate.c'`; then
    echo shar: \"'portable/baudrate.c'\" unpacked with wrong size!
  fi
  # end of 'portable/baudrate.c'
fi
if test -f 'portable/beep.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/beep.c'\"
else
  echo shar: Extracting \"'portable/beep.c'\" \(1324 characters\)
  sed "s/^X//" >'portable/beep.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef beep
X
X#ifndef	NDEBUG
Xchar *rcsid_beep = "$Header: c:/curses/portable/RCS/beep.c%v 2.0 1992/11/15 03:29:34 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  beep()	- generate audio-visual alarm.
X
X  X/Open Description:
X 	This routine is used to signal the terminal user.  The beep()
X 	function will sound the audible bell on the terminal, if possible
X 	and if not, will flash the screen (visible bell), if possible.
X 	The flash() function will flash the screen, and if that is not
X 	possible, will sound the audible signal.  If neither signal is
X 	possible, nothing will happen.  Nearly all terminals have an
X 	audible signal (bell or beep), but only some can flash the screen.
X
X  X/Open Return Value:
X 	The beep() and flash() functions return OK on success and ERR on
X 	error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int beep( void );
X 	X/Open Dec '88	int beep( void );
X 	BSD Curses	int beep( void );
X 	SYS V Curses	int beep( void );
X
X**man-end**********************************************************************/
X
Xint	beep(void)
X{
X	if (!_cursvar.audible)
X	{
X		flash();
X		return( ERR );		/* We try to flash instead...*/
X	}
X	PDC_putctty( '\007', 0 );
X	return( OK );
X}
END_OF_FILE
  if test 1324 -ne `wc -c <'portable/beep.c'`; then
    echo shar: \"'portable/beep.c'\" unpacked with wrong size!
  fi
  # end of 'portable/beep.c'
fi
if test -f 'portable/box.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/box.c'\"
else
  echo shar: Extracting \"'portable/box.c'\" \(1359 characters\)
  sed "s/^X//" >'portable/box.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	box
X
X#ifndef	NDEBUG
Xchar *rcsid_box = "$Header: c:/curses/portable/RCS/box.c%v 2.0 1992/11/15 03:28:51 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  box()	- draw box
X
X  X/Open Description:	
X 	A box is drawn around the edge of the window.  The characters
X 	vert and hor are the characters used to draw the box.  If vert or
X 	hor are zero, then appropriate default characters will be used.
X
X  PDCurses Description:
X 	See border() for additional control over the sides and corners
X 	of the box drawn.
X
X  X/Open Return Value:
X 	The box() function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	No errors are defined for these functions.
X
X  Portability:
X 	PDCurses	int box( WINDOW* win, chtype vert, chtype hor );
X 	X/Open Dec '88	int box( WINDOW* win, chtype vert, chtype hor );
X 	BSD Curses	int box( WINDOW* win, chtype vert, chtype hor );
X 	SYS V Curses	int box( WINDOW* win, chtype vert, chtype hor );
X
X**man-end**********************************************************************/
X
Xint	box( WINDOW *win, chtype vert, chtype hor )
X{
X	if  (!vert || !hor)	/*
X	{			* SYSV Fix Courtesy of Augustine Cano
X		vert= ACS_VLINE;* afc@shibaya.lonestar.org
X		hor = ACS_HLINE;* 19920520
X	}			*/
X	return( wbox( win, 0, 0, 0, 0, vert, hor ) );
X}
END_OF_FILE
  if test 1359 -ne `wc -c <'portable/box.c'`; then
    echo shar: \"'portable/box.c'\" unpacked with wrong size!
  fi
  # end of 'portable/box.c'
fi
if test -f 'portable/cbreak.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/cbreak.c'\"
else
  echo shar: Extracting \"'portable/cbreak.c'\" \(1345 characters\)
  sed "s/^X//" >'portable/cbreak.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	cbreak
X
X#ifndef	NDEBUG
Xchar *rcsid_cbreak = "$Header: c:/curses/portable/RCS/cbreak.c%v 2.0 1992/11/15 03:28:47 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  cbreak()	- set/clear cbreak mode
X
X  X/Open Description:	cbreak() and nocbreak()
X 	These two routines put the terminal into and out of cbreak mode.
X 	In cbreak mode, characters typed by the user are immediately
X 	available to the program and erase/kill character processing is
X 	not performed.  When out of cbreak mode, the terminal driver
X 	will buffer characters typed until a newline or carriage return
X 	is typed.  Interrupt and flow control characters are unaffected
X 	by this mode.  Initially the terminal may or may not need be
X 	in cbreak mode.
X
X  PDCurses Description:
X 	There is no additional PDCurses functionality.
X
X  X/Open Return Value:
X 	The cbreak() function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	No errors are defined for these functions.
X
X  Portability:
X 	PDCurses	int cbreak( void );
X 	X/Open Dec '88	int cbreak( void );
X 	BSD Curses	int cbreak( void );
X 	SYS V Curses	int cbreak( void );
X
X**man-end**********************************************************************/
X
Xint	cbreak(void)
X{
X	_cursvar.cbreak = TRUE;
X	return( OK );
X}
END_OF_FILE
  if test 1345 -ne `wc -c <'portable/cbreak.c'`; then
    echo shar: \"'portable/cbreak.c'\" unpacked with wrong size!
  fi
  # end of 'portable/cbreak.c'
fi
if test -f 'portable/delay_ou.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/delay_ou.c'\"
else
  echo shar: Extracting \"'portable/delay_ou.c'\" \(1328 characters\)
  sed "s/^X//" >'portable/delay_ou.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X/*#define NEEDS_OS2       1*/
X#include <curses.h>
X#undef	delay_output
X
X#if defined(DOS) && defined(MSC)
X#include <time.h>
X#endif
X
X#ifndef	NDEBUG
Xchar *rcsid_delay_ou = "$Header: c:/curses/portable/RCS/delay_ou.c%v 2.0 1992/11/15 03:28:46 MH Rel $";
X#endif
X
X#ifdef OS2
X	APIRET APIENTRY DosSleep(ULONG ulTime);
X#endif
X
X
X/*man-start*********************************************************************
X
X  delay_output()	- cause short delay
X
X  X/Open Description:
X 	Insert ms millisecond pause in output.  On some systems, this
X 	has no effect.
X
X  PDCurses Description:
X 	This routine relies on the compiler's delay() routine and
X 	provides this x millisecond granularity to the application.
X
X  X/Open Return Value:
X 	The delay_output() function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	If this function is a nop, then an ERR is returned.
X
X  Portability:
X 	PDCurses	int delay_output( int ms );
X 	X/Open Dec '88	int delay_output( int ms );
X 	BSD Curses	
X 	SYS V Curses	
X
X**man-end**********************************************************************/
X
Xint	delay_output( int ms )
X{
X#if defined(TC) && defined(DOS)
X	delay( ms );
X	return( OK );
X#endif
X#if	defined(OS2)
X	DosSleep(ms);
X	return( OK );
X#endif
X#if	defined(DOS) && defined(MSC)
X	PDC_usleep((clock_t)ms);
X	return( OK );
X#endif
X}
END_OF_FILE
  if test 1328 -ne `wc -c <'portable/delay_ou.c'`; then
    echo shar: \"'portable/delay_ou.c'\" unpacked with wrong size!
  fi
  # end of 'portable/delay_ou.c'
fi
if test -f 'portable/getyx.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/getyx.c'\"
else
  echo shar: Extracting \"'portable/getyx.c'\" \(1326 characters\)
  sed "s/^X//" >'portable/getyx.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	getyx
X
X#ifndef	NDEBUG
Xchar *rcsid_getyx = "$Header: c:/curses/portable/RCS/getyx.c%v 2.0 1992/11/15 03:28:53 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  getyx()	- get cursor position
X
X  X/Open Description:
X 	The cursor position of the window is placed in the two integer
X 	variables y and x.  This is implemented as a macro, so no & is
X 	necessary before the variables.
X
X 	NOTE: getyx() is a macro.
X
X  PDCurses Description:
X 	This routine is here to as a documentation place holder.  The
X 	code in this module will never be executed unless you #undef
X 	getyx(), in which case, you will need the & operator.
X
X  X/Open Return Value:
X 	This function returns OK on success and ERR on error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int getyx( WINDOW* win, int* y, int* x );
X 	    or 		int getyx( WINDOW* win, int y, int x );
X 	X/Open Dec '88	int getyx( WINDOW* win, int y, int x );
X 	BSD Curses	int getyx( WINDOW* win, int y, int x );
X 	SYS V Curses	int getyx( WINDOW* win, int y, int x );
X
X**man-end**********************************************************************/
X
Xint	getyx( WINDOW *win, int *y, int *x )
X{
X	*y = win->_cury;
X	*x = win->_curx;
X	return( OK );
X}
END_OF_FILE
  if test 1326 -ne `wc -c <'portable/getyx.c'`; then
    echo shar: \"'portable/getyx.c'\" unpacked with wrong size!
  fi
  # end of 'portable/getyx.c'
fi
if test -f 'portable/has_ic.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/has_ic.c'\"
else
  echo shar: Extracting \"'portable/has_ic.c'\" \(1205 characters\)
  sed "s/^X//" >'portable/has_ic.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	has_ic
X
X#ifndef	NDEBUG
Xchar *rcsid_has_ic = "$Header: c:/curses/portable/RCS/has_ic.c%v 2.0 1992/11/15 03:28:54 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  has_ic()	- determine whether insert/delete character available
X
X  X/Open Description:
X 	This function will return TRUE if the terminal has insert character
X 	and delete character capabilities.
X
X  PDCurses Description:
X 	For DOS, this is irrelevant (and ALWAYS TRUE), as the speed of
X 	the DIRECT VIDEO or even BIOS writes is quicker than on a
X 	serial terminal.
X
X 	For FLEXOS, this value has meaning and depends on the terminal,
X 	though at this time, it is a constant TRUE.
X
X  X/Open Return Value:
X 	The has_ic() function returns TRUE if the terminal has insert
X 	character and delete character capabilities, otherwise it returns
X 	FALSE.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	bool has_ic(void);
X 	X/Open Dec '88	bool has_ic(void);
X 	BSD Curses	
X 	SYS V Curses	
X
X**man-end**********************************************************************/
X
Xbool	has_ic(void)
X{
X	return( TRUE );
X}
END_OF_FILE
  if test 1205 -ne `wc -c <'portable/has_ic.c'`; then
    echo shar: \"'portable/has_ic.c'\" unpacked with wrong size!
  fi
  # end of 'portable/has_ic.c'
fi
if test -f 'portable/initcolo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/initcolo.c'\"
else
  echo shar: Extracting \"'portable/initcolo.c'\" \(1319 characters\)
  sed "s/^X//" >'portable/initcolo.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid_initcolo = "$Header: c:/curses/portable/RCS/initcolo.c%v 2.0 1992/11/15 03:28:55 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  init_color()	- Change the definition of a color.
X
X  PDCurses Description:
X
X 	This routine is used to change the definition of a color.
X 	The routine takes four arguments: the number of the color to be
X 	redefined, and the new values of the red, green and blue
X 	components of the color.
X
X 	The value of color must be between 0 and COLORS-1.
X 	The values of red, green and blue must each fall between 0 and
X 	1000;
X
X 	***** This function doesn't do anything yet *****
X
X  PDCurses Return Value:
X 	This function returns OK if the color change was possible or
X 	ERR on error.
X
X  PDCurses Errors:
X 	N/A
X
X  Portability:
X 	PDCurses	int init_color( int color, short red, short green, short blue);
X 	SYS V curses	int init_color( int color, short red, short green, short blue);
X
X**man-end**********************************************************************/
X
X
Xint init_color(int color, short red, short green, short blue)
X{
X extern int COLORS;
X
X if (color >= COLORS -1 || color < 1)
X    return(ERR);
X/*
X * This function doesn't do anything yet...
X */
X return(ERR);
X}
END_OF_FILE
  if test 1319 -ne `wc -c <'portable/initcolo.c'`; then
    echo shar: \"'portable/initcolo.c'\" unpacked with wrong size!
  fi
  # end of 'portable/initcolo.c'
fi
if test -f 'portable/meta.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/meta.c'\"
else
  echo shar: Extracting \"'portable/meta.c'\" \(1302 characters\)
  sed "s/^X//" >'portable/meta.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	meta
X
X#ifndef	NDEBUG
Xchar *rcsid_meta = "$Header: c:/curses/portable/RCS/meta.c%v 2.0 1992/11/15 03:29:00 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  meta()	- Force the number of significant bits on input.
X
X  Ultrix 4.1 Description:
X 	This function forces the user's terminal to return 7 or 8
X 	significant bits on input.  To force 8 bits to be returned,
X 	invoke meta() with bf as TRUE.  To force 7 bits to be returned,
X 	invoke meta() with bf as FALSE.
X
X 	The window argument is always ignored, but it must still be a
X 	valid window to avoid compiler errors.
X
X  PDCurses Description:
X 	This function is provided for portability.  By default, 8 bits
X 	are returned.
X
X 	FYI:  The Ultrix DOC needs confirmation...
X
X  PDCurses Return Value:
X 	The meta() function returns OK.
X
X  PDCurses Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int meta( WINDOW* win, bool bf );
X 	BSD Curses	int meta( WINDOW* win, bool bf );
X 	SYS V Curses	int meta( WINDOW* win, bool bf );
X
X**man-end**********************************************************************/
X
Xint	meta( WINDOW *win, bool bf )
X{
X#ifdef	TC
X# pragma argsused;
X#endif
X	_cursvar.raw_inp = bf;
X	return( OK );
X}
END_OF_FILE
  if test 1302 -ne `wc -c <'portable/meta.c'`; then
    echo shar: \"'portable/meta.c'\" unpacked with wrong size!
  fi
  # end of 'portable/meta.c'
fi
if test -f 'portable/mvcur.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/mvcur.c'\"
else
  echo shar: Extracting \"'portable/mvcur.c'\" \(1382 characters\)
  sed "s/^X//" >'portable/mvcur.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	mvcur
X
X#ifndef	NDEBUG
Xchar *rcsid_mvcur = "$Header: c:/curses/portable/RCS/mvcur.c%v 2.0 1992/11/15 03:29:00 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  mvcur()	- low-level cursor movement
X
X  Ultrix 4.1 Description:
X 	This function controls low-level cursor motion with optimization.
X
X  PDCurses Description:
X 	There is no optimization here since the PC has memory mapped
X 	video and we support, under certain compilation options, direct
X 	video writes.
X
X  PDCurses Return Value:
X 	The mvcur() function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	If the new cursor position is outside the physical screen size,
X 	an error occurs.
X
X  Portability:
X 	PDCurses	int mvcur(int oldrow,int oldcol,int newrow,int newcol);
X 	BSD Curses	int mvcur(int oldrow,int oldcol,int newrow,int newcol);
X 	SYS V Curses	int mvcur(int oldrow,int oldcol,int newrow,int newcol);
X
X**man-end**********************************************************************/
X
Xint	mvcur(int oldrow, int oldcol, int newrow, int newcol)
X{
X#ifdef	TC
X#  pragma argsused
X#endif
X	if ((newrow >= LINES)	||
X	    (newcol >= COLS)	||
X	    (newrow < 0)	||
X	    (newcol < 0))
X	{
X		return( ERR );
X	}
X	PDC_gotoxy( newrow, newcol );
X	_cursvar.cursrow = newrow;
X	_cursvar.curscol = newcol;
X	return( OK );
X}
END_OF_FILE
  if test 1382 -ne `wc -c <'portable/mvcur.c'`; then
    echo shar: \"'portable/mvcur.c'\" unpacked with wrong size!
  fi
  # end of 'portable/mvcur.c'
fi
if test -f 'portable/mvwin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/mvwin.c'\"
else
  echo shar: Extracting \"'portable/mvwin.c'\" \(1253 characters\)
  sed "s/^X//" >'portable/mvwin.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	mvwin
X
X#ifndef	NDEBUG
Xchar *rcsid_mvwin = "$Header: c:/curses/portable/RCS/mvwin.c%v 2.0 1992/11/15 03:29:01 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  mvwin()	- move window
X
X  X/Open Description:
X 	
X
X  PDCurses Description:
X 	There is no additional PDCurses functionality.
X
X  X/Open Return Value:
X 	The mvwin() routine returns OK on success and otherwise ERR
X 	is returned.
X
X  PDCurses Errors:
X 	It is an error to call this function with a NULL window pointer.
X 	It is also an error to address a position that is outside the
X 	bounds of the specified window.
X
X  Portability:
X 	PDCurses	int mvwin( WINDOW* win, int y, int x );
X 	X/Open Dec '88	int mvwin( WINDOW* win, int y, int x );
X 	BSD Curses	int mvwin( WINDOW* win, int y, int x );
X 	SYS V Curses	int mvwin( WINDOW* win, int y, int x );
X
X**man-end**********************************************************************/
X
Xint	mvwin(WINDOW *win, int y, int x)
X{
X	if (win == (WINDOW *)NULL)
X		return( ERR );
X
X	if (win->_begy + win->_maxy > LINES)
X		return( ERR );
X
X	if (win->_begx + win->_maxx > COLS)
X		return( ERR );
X
X	win->_begy = y;
X	win->_begx = x;
X	touchwin(win);
X	return( OK );
X}
END_OF_FILE
  if test 1253 -ne `wc -c <'portable/mvwin.c'`; then
    echo shar: \"'portable/mvwin.c'\" unpacked with wrong size!
  fi
  # end of 'portable/mvwin.c'
fi
if test -f 'portable/nl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/nl.c'\"
else
  echo shar: Extracting \"'portable/nl.c'\" \(1437 characters\)
  sed "s/^X//" >'portable/nl.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	nl
X
X#ifndef	NDEBUG
Xchar *rcsid_nl = "$Header: c:/curses/portable/RCS/nl.c%v 2.0 1992/11/15 03:29:04 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  nl()	- enable/disable newline control
X
X  X/Open Description:	nl(), nonl()
X 	These functions control whether a newline is translated into a
X 	carriage return and a line-feed on output, and wether a return
X 	is translated into a newline on input.  Initially, the translations
X 	do occur.  By disabling these translations, curses is able to
X 	make better use of the line-feed capability, resulting in faster
X 	cursor motion.
X
X 	NOTE: nl() and nonl() are macros.
X
X  PDCurses Description:
X 	This module is not an executable, it is merely a documentation
X 	place holder.  This module will only execute code if the user
X 	#undefs nl.
X
X  X/Open Return Value:
X 	The nl() and nonl() functions return OK on success and ERR on error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int mvprintw( int y, int x, char* fmt, ... );
X 	X/Open Dec '88	int mvprintw( int y, int x, char* fmt, ... );
X 	BSD Curses	int mvprintw( int y, int x, char* fmt, ... );
X 	SYS V Curses	int mvprintw( int y, int x, char* fmt, ... );
X
X**man-end**********************************************************************/
X
Xint	nl(void)
X{
X	_cursvar.autocr = TRUE;
X	return( OK );
X}
END_OF_FILE
  if test 1437 -ne `wc -c <'portable/nl.c'`; then
    echo shar: \"'portable/nl.c'\" unpacked with wrong size!
  fi
  # end of 'portable/nl.c'
fi
if test -f 'portable/nocbreak.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/nocbreak.c'\"
else
  echo shar: Extracting \"'portable/nocbreak.c'\" \(1366 characters\)
  sed "s/^X//" >'portable/nocbreak.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	nocbreak
X
X#ifndef	NDEBUG
Xchar *rcsid_nocbreak = "$Header: c:/curses/portable/RCS/nocbreak.c%v 2.0 1992/11/15 03:29:04 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  nocbreak()	- set/clear cbreak mode
X
X  X/Open Description:	cbreak() and nocbreak()
X 	These two routines put the terminal into and out of cbreak mode.
X 	In cbreak mode, characters typed by the user are immediately
X 	available to the program and erase/kill character processing is
X 	not performed.  When out of cbreak mode, the terminal driver
X 	will buffer characters typed until a newline or carriage return
X 	is typed.  Interrupt and flow control characters are unaffected
X 	by this mode.  Initially the terminal may or may not need be
X 	in cbreak mode.
X
X  PDCurses Description:
X 	There is no additional PDCurses functionality.
X
X  X/Open Return Value:
X 	The nocbreak() function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	No errors are defined for these functions.
X
X  Portability:
X 	PDCurses	int nocbreak( void );
X 	X/Open Dec '88	int nocbreak( void );
X 	BSD Curses	int nocbreak( void );
X 	SYS V Curses	int nocbreak( void );
X
X**man-end**********************************************************************/
X
Xint	nocbreak(void)
X{
X	_cursvar.cbreak = FALSE;
X	return( OK );
X}
END_OF_FILE
  if test 1366 -ne `wc -c <'portable/nocbreak.c'`; then
    echo shar: \"'portable/nocbreak.c'\" unpacked with wrong size!
  fi
  # end of 'portable/nocbreak.c'
fi
if test -f 'portable/refresh.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/refresh.c'\"
else
  echo shar: Extracting \"'portable/refresh.c'\" \(1246 characters\)
  sed "s/^X//" >'portable/refresh.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	refresh
X
X#ifndef	NDEBUG
Xchar *rcsid_refresh = "$Header: c:/curses/portable/RCS/refresh.c%v 2.0 1992/11/15 03:29:10 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  refresh()	- refresh window
X
X  X/Open Description:
X 	The routine wrefresh copies the named window to the physical
X 	terminal screen, taking into account what is already there in
X 	order to optimize cursor movement.
X
X 	The routine refresh does the same, using stdscr as a default
X 	screen.
X
X 	These routines must be called to get any output on the
X 	terminal, as other routines only manipulate data structures.
X
X 	Unless leaveok has been enabled, the physical cursor of the
X 	terminal is left at the location of the window's cursor.
X
X  X/Open Return Value:
X 	The refresh() function returns OK on success and ERR on error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int refresh( void );
X 	X/Open Dec '88	int refresh( void );
X 	BSD Curses	int refresh( void );
X 	SYS V Curses	int refresh( void );
X
X**man-end**********************************************************************/
X
Xint	refresh( void )
X{
X	return( wrefresh(stdscr) );
X}
END_OF_FILE
  if test 1246 -ne `wc -c <'portable/refresh.c'`; then
    echo shar: \"'portable/refresh.c'\" unpacked with wrong size!
  fi
  # end of 'portable/refresh.c'
fi
if test -f 'portable/scrollok.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/scrollok.c'\"
else
  echo shar: Extracting \"'portable/scrollok.c'\" \(1341 characters\)
  sed "s/^X//" >'portable/scrollok.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	scrollok
X
X#ifndef	NDEBUG
Xchar *rcsid_scrollok = "$Header: c:/curses/portable/RCS/scrollok.c%v 2.0 1992/11/15 03:29:31 MH Rel $";
X#endif
X
X
X
X
X
X/*man-start*********************************************************************
X
X  scrollok()	- scrollok window
X
X  X/Open Description:
X 	This function controls what happens when the cursor of a window
X 	is moved off the edge of the window or scrolling region, either
X 	from a newline on the bottom line or by typing the last character
X 	of the last line.  If the option is disabled, the cursor is left
X 	on the bottom line.  If enabled, the window is scrolled up one
X 	line and then refreshed.
X
X  PDCurses Description:
X 	This is also implemented as a macro.
X
X  X/Open Return Value:
X 	The scrollok() function returns OK on success otherwise ERR
X 	is returned.
X
X  PDCurses Errors:
X 	It is an error to pass a NULL* window.
X
X  Portability:
X 	PDCurses	int scrollok( WINDOW* win, bool bf );
X 	X/Open Dec '88	int scrollok( WINDOW* win, bool bf );
X 	SysV Curses	int scrollok( WINDOW* win, bool bf );
X 	BSD Curses	int scrollok( WINDOW* win, bool bf );
X
X**man-end**********************************************************************/
X
Xint	scrollok(WINDOW *win, bool bf)
X{
X	if  (win == (WINDOW *)NULL)
X		return( ERR );
X
X	win->_scroll	= bf;
X	return( OK );
X}
END_OF_FILE
  if test 1341 -ne `wc -c <'portable/scrollok.c'`; then
    echo shar: \"'portable/scrollok.c'\" unpacked with wrong size!
  fi
  # end of 'portable/scrollok.c'
fi
if test -f 'portable/startcol.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/startcol.c'\"
else
  echo shar: Extracting \"'portable/startcol.c'\" \(1377 characters\)
  sed "s/^X//" >'portable/startcol.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef start_color
X
X#ifndef	NDEBUG
Xchar *rcsid_startcol = "$Header: c:/curses/portable/RCS/startcol.c%v 2.0 1992/11/15 03:29:17 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  start_color()	- Initialize and set up curses for color mode.
X
X  PDCurses Description:
X 	This routine sets up curses to enable color support.
X
X 	Eight basic color are initialized: black, blue, green, cyan, red,
X 	magenta, yellow and white. Two global variables - COLORS and
X 	COLOR_PAIRS, as defined in <curses.h> header file - are also
X 	initialized. The se variables define the maximum number of colors
X 	and the maximum number of color-pairs supported.
X
X 	This routine must be called before any other curses routine which
X 	manipulates or uses colors. A good place to call it is immediately
X 	after initscr().
X
X  PDCurses Return Value:
X 	This function returns ERR if the monitor does not support color.
X 	Otherwise OK is returned.
X
X  PDCurses Errors:
X 	N/A
X
X  Portability:
X 	PDCurses	int start_color(void);
X 	SYS V curses	int start_color(void);
X
X**man-end**********************************************************************/
X
Xint COLORS=0,COLOR_PAIRS=0;
X
Xint start_color(void)
X{
X if (_cursvar.mono)
X    return(ERR);
X COLORS = 8;
X COLOR_PAIRS = 33;  /* actually only allows 32 */
X return(OK);
X}
END_OF_FILE
  if test 1377 -ne `wc -c <'portable/startcol.c'`; then
    echo shar: \"'portable/startcol.c'\" unpacked with wrong size!
  fi
  # end of 'portable/startcol.c'
fi
if test -f 'portable/touchlin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/touchlin.c'\"
else
  echo shar: Extracting \"'portable/touchlin.c'\" \(1277 characters\)
  sed "s/^X//" >'portable/touchlin.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	touchline
X
X#ifndef	NDEBUG
Xchar *rcsid_touchlin = "$Header: c:/curses/portable/RCS/touchlin.c%v 2.0 1992/11/15 03:29:18 MH Rel $";
X#endif
X
X
X
X
X
X/*man-start*********************************************************************
X
X  touchline()	- touch line in window
X
X  PDCurses Description:
X 	Similar to touchwin(), but less drastic.
X
X 	Throw away all optimisation information about which parts of the
X 	window (well, lines) have been touched, by pretending that the
X 	entire line(s) has been drawn on.
X
X  PDCurses Errors:
X 	The touchline() function returns OK on success and ERR on error.
X
X 	It is an error to pass a NULL window.
X
X 	It is also an error to specify a line outside the boundaries of
X 	the passed window or if the start line plus the number of lines
X 	exceeds the boundary of the window.
X
X  Portability:
X 	PDCurses	
X 	SysV Curses	
X 	BSD Curses	
X
X**man-end**********************************************************************/
X
Xint	touchline(WINDOW *w, int start,int num)
X{
X	register int i;
X
X	if (w == (WINDOW *)NULL)
X		return( ERR );
X
X	if  (start > w->_maxy || start + num > w->_maxy)
X		return( ERR );
X	for(i=start;i<start+num;i++)
X	   {
X		w->_firstch[i] = 0;
X		w->_lastch[i] = w->_maxx - 1;
X	   }
X	return( OK );
X}
END_OF_FILE
  if test 1277 -ne `wc -c <'portable/touchlin.c'`; then
    echo shar: \"'portable/touchlin.c'\" unpacked with wrong size!
  fi
  # end of 'portable/touchlin.c'
fi
if test -f 'portable/wclear.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/wclear.c'\"
else
  echo shar: Extracting \"'portable/wclear.c'\" \(1309 characters\)
  sed "s/^X//" >'portable/wclear.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	wclear
X
X#ifndef	NDEBUG
Xchar *rcsid_wclear = "$Header: c:/curses/portable/RCS/wclear.c%v 2.0 1992/11/15 03:29:23 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  wclear()	- Clear window
X
X  X/Open Description:	clear() and wclear()
X 	These functions are like erase(), but they also call clearok(),
X 	arranging that the screen will be cleared completely on the
X 	next call to wrefresh() for that window and repainted.
X
X 	NOTE: clear() is a macro.
X
X  PDCurses Description:
X 	There is no additional PDCurses functionality.  This module is
X 	a documentation place holder.  No code will execute in this module
X 	unless the user #undefs wclear.
X
X  X/Open Return Value:
X 	The wclear() function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	It is an error to call this function with a NULL window pointer.
X
X  Portability:
X 	PDCurses	int wclear( WINDOW* win );
X 	X/Open Dec '88	int wclear( WINDOW* win );
X 	BSD Curses	int wclear( WINDOW* win );
X 	SYS V Curses	int wclear( WINDOW* win );
X
X**man-end**********************************************************************/
X
Xint	wclear( WINDOW *win )
X{
X	if  (win == (WINDOW *)NULL)
X		return( ERR );
X
X	clearok( win, TRUE );
X	return( werase( win ) );
X}
END_OF_FILE
  if test 1309 -ne `wc -c <'portable/wclear.c'`; then
    echo shar: \"'portable/wclear.c'\" unpacked with wrong size!
  fi
  # end of 'portable/wclear.c'
fi
if test -f 'portable/werase.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/werase.c'\"
else
  echo shar: Extracting \"'portable/werase.c'\" \(1405 characters\)
  sed "s/^X//" >'portable/werase.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	werase
X
X#ifndef	NDEBUG
Xchar *rcsid_werase = "$Header: c:/curses/portable/RCS/werase.c%v 2.0 1992/11/15 03:29:07 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  werase()	- copy blanks into window
X
X  X/Open Description:
X 	These functions copy blanks to every position in the window.
X
X 	NOTE: erase() is a macro.
X
X  PDCurses Description:
X 	There is no additional PDCurses functionality.
X
X  X/Open Return Value:
X 	These functions return OK on success and ERR on error.
X
X  PDCurses Errors:
X 	It is an error to call this function with a NULL window pointer.
X
X  Portability:
X 	PDCurses	int werase( WINDOW* win );
X 	X/Open Dec '88	int werase( WINDOW* win );
X 	BSD Curses	int werase( WINDOW* win );
X 	SYS V Curses	int werase( WINDOW* win );
X
X**man-end**********************************************************************/
X
Xint	werase(WINDOW *win)
X{
X	chtype*	end;
X	chtype*	start;
X	int	y;
Xstatic	chtype	blank;
X
X	if (win == (WINDOW *)NULL)
X		return( ERR );
X
X	blank = win->_blank | win->_attrs;
X
X	for (y = win->_tmarg; y <= win->_bmarg; y++)
X	{
X		start = win->_y[y];
X		end = &start[win->_maxx - 1];
X/* changed JGB 6/92 < to <= */
X		while (start <= end)
X		{
X			*start++ = blank;
X		}
X		win->_firstch[y] = 0;
X		win->_lastch[y] = win->_maxx - 1;
X	}
X	win->_cury = win->_tmarg;
X	win->_curx = 0;
X	return( OK );
X}
X
END_OF_FILE
  if test 1405 -ne `wc -c <'portable/werase.c'`; then
    echo shar: \"'portable/werase.c'\" unpacked with wrong size!
  fi
  # end of 'portable/werase.c'
fi
if test -f 'portable/winsch.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/winsch.c'\"
else
  echo shar: Extracting \"'portable/winsch.c'\" \(1339 characters\)
  sed "s/^X//" >'portable/winsch.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	winsch
X
X#ifndef	NDEBUG
Xchar *rcsid_winsch = "$Header: c:/curses/portable/RCS/winsch.c%v 2.0 1992/11/15 03:29:26 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  winsch()	- Insert character
X
X  X/Open Description:
X 	The character ch is inserted before the character under the
X 	cursor.  All characters to the right are moved one space to the
X 	right, possibly losing the rightmost character on the line.
X 	The cursor position does not change (after moving to y,x if
X 	specified).
X
X 	NOTE: insch(), mvinsch(), mvwinsch() are macros.
X
X  PDCurses Description:
X 	See the call ctrl( bool bf ); for information regarding the
X 	replacement of all former 1.4 and prior "raw" PDCurses
X 	routines.
X
X  X/Open Return Value:
X 	These functions return OK on success and ERR on error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int winsch( WINDOW* win, chtype ch );
X 	X/Open Dec '88	int winsch( WINDOW* win, chtype ch );
X 	BSD Curses	int winsch( WINDOW* win, chtype ch );
X 	SYS V Curses	int winsch( WINDOW* win, chtype ch );
X
X**man-end**********************************************************************/
X
Xint	winsch( WINDOW *win, chtype ch )
X{
X	return( PDC_chins( win, ch, !(_cursvar.raw_out) ) );
X}
END_OF_FILE
  if test 1339 -ne `wc -c <'portable/winsch.c'`; then
    echo shar: \"'portable/winsch.c'\" unpacked with wrong size!
  fi
  # end of 'portable/winsch.c'
fi
if test -f 'private/_addtail.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_addtail.c'\"
else
  echo shar: Extracting \"'private/_addtail.c'\" \(1281 characters\)
  sed "s/^X//" >'private/_addtail.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifdef	REGISTERWINDOWS
X#ifndef	NDEBUG
Xchar *rcsid__addtail = "$Header: c:/curses/private/RCS/_addtail.c%v 2.0 1992/11/15 03:24:17 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_addtail()	- add window to the visible window list
X
X  PDCurses Description:
X 	This is a private PDCurses function.
X
X 	This routine adds the passed window pointer to the end fo the
X 	visible window list.  All windows on this list will automatically
X 	be refreshed if _cursvar.refreshall is true.
X
X  PDCurses Return Value:
X 	This function returns OK upon success otherwise ERR is returned.
X
X  PDCurses Errors:
X 	It is an error to pass a NULL window pointer.
X
X  Portability:
X 	PDCurses	int	PDC_addtail( WINDOW* tail );
X
X**man-end**********************************************************************/
X
Xint	PDC_addtail(WINDOW *tail)
X{
X	WINDS  *next = _cursvar.visible;
X
X	if  (tail == (WINDOW *)NULL)
X		return( ERR );
X
X	while (next != (WINDS *)NULL)
X	{
X		if (next->next == NULL)
X			break;
X		next = next->next;
X	}
X	if (next == NULL)
X		PDC_inswin(tail, (WINDOW *)NULL);
X	else
X	{
X		if (next->w == NULL)
X			PDC_inswin(tail, (WINDOW *)NULL);
X		else
X			PDC_addwin(tail, next->w);
X	}
X	return( OK );
X}
X#endif
END_OF_FILE
  if test 1281 -ne `wc -c <'private/_addtail.c'`; then
    echo shar: \"'private/_addtail.c'\" unpacked with wrong size!
  fi
  # end of 'private/_addtail.c'
fi
if test -f 'private/_ckbiosk.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_ckbiosk.c'\"
else
  echo shar: Extracting \"'private/_ckbiosk.c'\" \(1229 characters\)
  sed "s/^X//" >'private/_ckbiosk.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#define NEEDS_OS2       1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__ckbiosk = "$Header: c:/curses/private/RCS/_ckbiosk.c%v 2.0 1992/11/15 03:24:29 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_check_bios_key()	- Check BIOS key data area for input
X
X  PDCurses Description:
X 	This is a private PDCurses routine.
X
X 	This routine will check the BIOS for any indication that
X 	keystrokes are pending.
X
X  PDCurses Return Value:
X 	Returns 1 if a keyboard character is available, 0 otherwise.
X
X  PDCurses Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	bool	PDC_check_bios_key( void );
X
X**man-end**********************************************************************/
X
Xbool PDC_check_bios_key(void)
X{
X#ifdef	FLEXOS
X	retcode = s_get(T_VIRCON, 0L, (char *) &vir, (long) sizeof(vir));
X	return( (retcode < 0L) ? ERR : vir.vc_tahead );
X#endif
X#if	defined (DOS)
X return(kbhit());
X#endif
X#if	OS2
X#if !defined(MSC)
X	KBDKEYINFO keyInfo;
X	
X/*	KbdCharIn(&keyInfo, IO_NOWAIT, 0);*/	/* get a character	*/
X	KbdPeek(&keyInfo, 0);	/* peek at keyboard	*/
X	return (keyInfo.fbStatus != 0);
X#else
X return(kbhit());
X#endif
X#endif
X}
END_OF_FILE
  if test 1229 -ne `wc -c <'private/_ckbiosk.c'`; then
    echo shar: \"'private/_ckbiosk.c'\" unpacked with wrong size!
  fi
  # end of 'private/_ckbiosk.c'
fi
if test -f 'private/_gcrspos.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_gcrspos.c'\"
else
  echo shar: Extracting \"'private/_gcrspos.c'\" \(1348 characters\)
  sed "s/^X//" >'private/_gcrspos.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__gcrspos = "$Header: c:/curses/private/RCS/_gcrspos.c%v 2.0 1992/11/15 03:24:22 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_get_cursor_pos()	- return current cursor position
X
X  PDCurses Description:
X 	This is a private PDCurses function
X
X 	Gets the cursor position in video page 0.  'row' and 'column'
X 	are the cursor address.  At this time, there is no support for
X 	use of multiple screen pages.
X
X  PDCurses Return Value:
X 	This routine will return OK upon success and otherwise ERR will be
X 	returned.
X
X  PDCurses Errors:
X 	There are no defined errors for this routine.
X
X  Portability:
X 	PDCurses	int	PDC_get_cursor_pos( int* row, int* col );
X
X**man-end**********************************************************************/
X
Xint	PDC_get_cursor_pos(int *row, int *col)
X{
X#ifdef	FLEXOS
X	retcode = s_get(T_VIRCON, 0L, (char *) &vir, (long) sizeof(vir));
X	if (retcode < 0L)
X		return( ERR );
X	*row = vir.vc_cursor.pos_row;
X	*col = vir.vc_cursor.pos_col;
X	return( OK );
X#endif
X#ifdef	DOS
X	regs.h.ah = 0x03;
X	regs.h.bh = _cursvar.video_page;
X	int86(0x10, &regs, &regs);
X	*row = regs.h.dh;
X	*col = regs.h.dl;
X	return( OK );
X#endif
X#ifdef	OS2
X	VioGetCurPos((PUSHORT)&row,(PUSHORT)&col,0);
X	return( OK );
X#endif
X}
END_OF_FILE
  if test 1348 -ne `wc -c <'private/_gcrspos.c'`; then
    echo shar: \"'private/_gcrspos.c'\" unpacked with wrong size!
  fi
  # end of 'private/_gcrspos.c'
fi
if test -f 'private/_gcurcol.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_gcurcol.c'\"
else
  echo shar: Extracting \"'private/_gcurcol.c'\" \(1243 characters\)
  sed "s/^X//" >'private/_gcurcol.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__gcurcol = "$Header: c:/curses/private/RCS/_gcurcol.c%v 2.0 1992/11/15 03:24:22 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_get_cur_col()	- get current column position of cursor
X
X  PDCurses Description:
X 	This is a private PDCurses function
X
X 	This routine returns the current column position of the cursor on
X 	screen.
X
X  PDCurses Return Value:
X 	This routine returns the current column position of the cursor. No
X 	error is returned.
X
X  PDCurses Errors:
X 	There are no defined errors for this routine.
X
X  Portability:
X 	PDCurses	int	PDC_get_cur_col( void );
X
X**man-end**********************************************************************/
X
Xint	PDC_get_cur_col(void)
X{
X#ifdef	FLEXOS
X	retcode = s_get(T_VIRCON, 1L, (char *) &vir, (long) sizeof(vir));
X	return( (retcode < 0L) ? ERR : vir.vc_cursor.pos_col );
X#endif
X#ifdef	DOS
X	regs.x.ax = 0x0003;
X	regs.h.bh = _cursvar.video_page;
X	int86(0x10, &regs, &regs);
X	return((int) regs.h.dl);
X#endif
X#ifdef	OS2
X	USHORT curCol, curRow;
X	
X	/* find the current cursor position */
X	VioGetCurPos ((PUSHORT) &curRow, (PUSHORT) &curCol, 0);
X	return (curCol);
X#endif
X}
END_OF_FILE
  if test 1243 -ne `wc -c <'private/_gcurcol.c'`; then
    echo shar: \"'private/_gcurcol.c'\" unpacked with wrong size!
  fi
  # end of 'private/_gcurcol.c'
fi
if test -f 'private/_gcurrow.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_gcurrow.c'\"
else
  echo shar: Extracting \"'private/_gcurrow.c'\" \(1235 characters\)
  sed "s/^X//" >'private/_gcurrow.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__gcurrow = "$Header: c:/curses/private/RCS/_gcurrow.c%v 2.0 1992/11/15 03:24:23 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_get_cur_row()	- get current row position of cursor
X
X  PDCurses Description:
X 	This is a private PDCurses function
X
X 	This routine returns the current row position of the cursor on
X 	screen.
X
X  PDCurses Return Value:
X 	This routine returns the current row position of the cursor. No
X 	error is returned.
X
X  PDCurses Errors:
X 	There are no defined errors for this routine.
X
X  Portability:
X 	PDCurses	int	PDC_get_cur_row( void );
X
X**man-end**********************************************************************/
X
Xint	PDC_get_cur_row(void)
X{
X#ifdef	FLEXOS
X	retcode = s_get(T_VIRCON, 1L, (char *) &vir, (long) sizeof(vir));
X	return( (retcode < 0L) ? ERR : vir.vc_cursor.pos_col );
X#endif
X#ifdef	DOS
X	regs.x.ax = 0x0003;
X	regs.h.bh = _cursvar.video_page;
X	int86(0x10, &regs, &regs);
X	return ((int) regs.h.dh);
X#endif
X#ifdef	OS2
X	USHORT curCol, curRow;
X	
X	/* find the current cursor position */
X	VioGetCurPos ((PUSHORT) &curRow, (PUSHORT) &curCol, 0);
X	return (curRow);
X#endif
X}
END_OF_FILE
  if test 1235 -ne `wc -c <'private/_gcurrow.c'`; then
    echo shar: \"'private/_gcurrow.c'\" unpacked with wrong size!
  fi
  # end of 'private/_gcurrow.c'
fi
if test -f 'private/_getattr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_getattr.c'\"
else
  echo shar: Extracting \"'private/_getattr.c'\" \(1298 characters\)
  sed "s/^X//" >'private/_getattr.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__getattr = "$Header: c:/curses/private/RCS/_getattr.c%v 2.0 1992/11/15 03:24:23 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_get_attribute()	- Get attribute at current cursor
X
X  PDCurses Description:
X 	This is a private PDCurses function
X
X 	Return the current attr at current cursor position on the screen.
X
X  PDCurses Return Value:
X 	This routine will return OK upon success and otherwise ERR will be
X 	returned.
X
X  PDCurses Errors:
X 	There are no defined errors for this routine.
X
X  Portability:
X 	PDCurses	int	PDC_get_attribute( void );
X
X**man-end**********************************************************************/
X
Xint	PDC_get_attribute(void)
X{
X#ifdef	FLEXOS
X	/* Get and return current attribute.  Force error until fixed. */
X	return ((COLOR_CYAN) >> ((sizeof(ch type) / 2) * 8));
X#endif
X#ifdef	DOS
X	regs.x.ax = 0x0800;
X	regs.h.bh = _cursvar.video_page;
X	int86(0x10, &regs, &regs);
X	return ((int) regs.h.ah);
X#endif
X#ifdef	OS2
X	char Cell[4];
X	USHORT cellLen = 2;
X	USHORT curRow = PDC_get_cur_row();
X	USHORT curCol = PDC_get_cur_col();
X	VioReadCellStr((PCH)&Cell, (PUSHORT)&cellLen, (USHORT)curRow, (USHORT)curCol, 0);
X	return ((int) Cell[1]);
X#endif
X}
END_OF_FILE
  if test 1298 -ne `wc -c <'private/_getattr.c'`; then
    echo shar: \"'private/_getattr.c'\" unpacked with wrong size!
  fi
  # end of 'private/_getattr.c'
fi
if test -f 'private/_scrnmod.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_scrnmod.c'\"
else
  echo shar: Extracting \"'private/_scrnmod.c'\" \(1210 characters\)
  sed "s/^X//" >'private/_scrnmod.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_scrn_modes_equal()	- Decide if two screen modes are equal
X
X  PDCurses Description:
X 	Mainly required for OS/2. It decides if two screen modes
X        (VIOMODEINFO structure) are equal. Under DOS it just compares
X        two integers
X
X  PDCurses Return Value:
X 	This function returns TRUE if equal else FALSe.
X
X  PDCurses Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int PDC_scrn_modes_equal( int mode1, int mode2 );
X 	OS2 PDCurses	int PDC_scrn_modes_equal( VIOMODEINFO mode1, VIOMODEINFO mode2 );
X
X**man-end**********************************************************************/
X
X#ifdef     OS2
Xbool	PDC_scrn_modes_equal(VIOMODEINFO mode1, VIOMODEINFO mode2)
X#else
Xbool	PDC_scrn_modes_equal(int mode1, int mode2)
X#endif
X{
X#ifdef     OS2
X    return (   (mode1.cb == mode2.cb) && (mode1.fbType == mode2.fbType)
X            && (mode1.color == mode2.color) && (mode1.col == mode2.col)
X            && (mode1.row == mode2.row) && (mode1.hres == mode2.vres)
X            && (mode1.vres == mode2.vres) );
X#else
X    return (mode1 == mode2);
X#endif
X}
END_OF_FILE
  if test 1210 -ne `wc -c <'private/_scrnmod.c'`; then
    echo shar: \"'private/_scrnmod.c'\" unpacked with wrong size!
  fi
  # end of 'private/_scrnmod.c'
fi
echo shar: End of archive 10 \(of 11\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
