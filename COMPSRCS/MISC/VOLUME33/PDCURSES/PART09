Newsgroups: comp.sources.misc
From: M.Hessling@gu.edu.au (Mark Hessling)
Subject:  v33i089:  pdcurses - Public Domain curses library for DOS and OS/2 v2.0, Part09/11
Message-ID: <1992Nov19.040811.8306@sparky.imd.sterling.com>
X-Md4-Signature: ce62036a8f93f3c574f3886f91091d6c
Date: Thu, 19 Nov 1992 04:08:11 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: M.Hessling@gu.edu.au (Mark Hessling)
Posting-number: Volume 33, Issue 89
Archive-name: pdcurses/part09
Environment: DOS,OS/2,ANSI-C

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  portable/colorcon.c portable/def_shel.c portable/flash.c
#   portable/idlok.c portable/intrflus.c portable/keypad.c
#   portable/leaveok.c portable/paircont.c portable/savetty.c
#   portable/set_term.c portable/touchwin.c portable/waddstr.c
#   portable/wdeletel.c portable/winsertl.c portable/wmove.c
#   portable/wrefresh.c private/_getcols.c private/_getcrsr.c
#   private/_getfont.c private/_gotoxy.c private/_print.c
#   private/_putc.c private/_putctty.c private/_scrclos.c
#   private/_set8025.c private/_setscrn.c private/_splitpl.c
# Wrapped by kent@sparky on Wed Nov 18 21:44:09 1992
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 9 (of 11)."'
if test -f 'portable/colorcon.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/colorcon.c'\"
else
  echo shar: Extracting \"'portable/colorcon.c'\" \(1404 characters\)
  sed "s/^X//" >'portable/colorcon.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef color_content
X
X#ifndef	NDEBUG
Xchar *rcsid_colorcon = "$Header: c:/curses/portable/RCS/colorcon.c%v 2.0 1992/11/15 03:28:48 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  color_content()	- Obtain color content information.
X
X  PDCurses Description:
X
X 	This routine obtains the current color-content information of a given
X 	color.
X 	The routine uses four arguments: the color number, which must
X 	be a value between 0 and COLORS-1, and the addresses of three
X 	short integers for storing the obtained information of the color
X 	components red, green and blue. The function stores the current
X 	values at these adresses passed.
X
X 	***** This function doesn't do anything yet *****
X
X  PDCurses Return Value:
X 	This function returns ERR if the color is out of range otherwise
X 	it returns OK.
X
X  PDCurses Errors:
X 	N/A
X
X  Portability:
X 	PDCurses	int color_content( int color, short *red, short *green, short *blue);
X 	SYS V curses	int color_content( int color, short *red, short *green, short *blue);
X
X**man-end**********************************************************************/
X
X
Xint color_content(int color, short *red, short *green, short *blue)
X{
X extern int COLORS;
X
X if (color >= COLORS -1 || color < 1)
X    return(ERR);
X/*
X * This function doesn't do anything yet...
X */
X return(ERR);
X}
END_OF_FILE
  if test 1404 -ne `wc -c <'portable/colorcon.c'`; then
    echo shar: \"'portable/colorcon.c'\" unpacked with wrong size!
  fi
  # end of 'portable/colorcon.c'
fi
if test -f 'portable/def_shel.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/def_shel.c'\"
else
  echo shar: Extracting \"'portable/def_shel.c'\" \(1612 characters\)
  sed "s/^X//" >'portable/def_shel.c' <<'END_OF_FILE'
X#ifndef NO_MEMORY_H
X#include <memory.h>
X#endif
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	def_shell_mode
X
X#ifndef	NDEBUG
Xchar *rcsid_def_shel = "$Header: c:/curses/portable/RCS/def_shel.c%v 2.0 1992/11/15 03:28:49 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  def_shell_mode()	- Save terminal mode
X
X  X/Open Description:
X 	Save the current terminal modes as the "program" (in CURSES) or
X 	"shell" (not in CURSES) state for use by the reset_prog_mode()
X 	and reset_shell_mode() functions.  This is done automatically by
X 	initscr().
X
X  PDCurses Description:
X 	PDCurses maintains a WINDOW* that contains the original user's
X 	screen upon startup.  This might be useful for returning the
X 	user's environment to its (near) original state.
X
X 	This is unimplemented at this time.
X
X  X/Open Return Value:
X 	The def_shell_mode() function returns OK on success and ERR on error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int def_shell_mode( void );
X 	X/Open Dec '88	int def_shell_mode( void );
X 	BSD Curses
X 	SYS V Curses	int def_shell_mode( void );
X
X**man-end**********************************************************************/
X
Xint	def_shell_mode(void)
X{
X#ifdef	FLEXOS
X	_flexos_8bitmode();
X#endif
X	c_sh_tty.been_set = TRUE;
X#if 	defined(DOS) || defined(OS2)
X#  if	SMALL || MEDIUM
X	movedata( FP_SEG(&_cursvar),		FP_OFF(&_cursvar),
X		  FP_SEG(&c_sh_tty.saved),	FP_OFF(&c_sh_tty.saved),
X		  sizeof(SCREEN) );
X#  else
X	memcpy(&c_sh_tty.saved, &_cursvar, sizeof(SCREEN));
X#  endif
X#endif
X	return( OK );
X}
END_OF_FILE
  if test 1612 -ne `wc -c <'portable/def_shel.c'`; then
    echo shar: \"'portable/def_shel.c'\" unpacked with wrong size!
  fi
  # end of 'portable/def_shel.c'
fi
if test -f 'portable/flash.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/flash.c'\"
else
  echo shar: Extracting \"'portable/flash.c'\" \(1447 characters\)
  sed "s/^X//" >'portable/flash.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	flash
X
X#ifndef	NDEBUG
Xchar *rcsid_flash = "$Header: c:/curses/portable/RCS/flash.c%v 2.0 1992/11/15 03:28:52 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  flash()	- generate audio-visual alarm
X
X  X/Open Description:
X 	This routine is used to signal the terminal user.  The beep()
X 	function will sound the audible bell on the terminal, if possible
X 	and if not, will flash the screen (visible bell), if possible.
X 	The flash() function will flash the screen, and if that is not
X 	possible, will sound the audible signal.  If neither signal is
X 	possible, nothing will happen.  Nearly all terminals have an
X 	audible signal (bell or beep), but only some can flash the screen.
X
X  X/Open Return Value:
X 	The beep() and flash() functions return OK on success and ERR on
X 	error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int flash( void );
X 	X/Open Dec '88	int flash( void );
X 	BSD Curses	int flash( void );
X 	SYS V Curses	int flash( void );
X
X**man-end**********************************************************************/
X
Xint	flash(void)
X{
X	extern unsigned char atrtab[MAX_ATRTAB];
X	int	i;
X
X	PDC_scroll(0, 0, LINES - 1, COLS - 1, 0, (chtype)(atrtab[264] << 8));
X	delay_output( 50 );
X	PDC_scroll(0, 0, LINES - 1, COLS - 1, 0, (chtype)(atrtab[265] << 8));
X	wrefresh(curscr);
X	return( OK );
X}
END_OF_FILE
  if test 1447 -ne `wc -c <'portable/flash.c'`; then
    echo shar: \"'portable/flash.c'\" unpacked with wrong size!
  fi
  # end of 'portable/flash.c'
fi
if test -f 'portable/idlok.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/idlok.c'\"
else
  echo shar: Extracting \"'portable/idlok.c'\" \(1550 characters\)
  sed "s/^X//" >'portable/idlok.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	idlok
X
X#ifndef	NDEBUG
Xchar *rcsid_idlok = "$Header: c:/curses/portable/RCS/idlok.c%v 2.0 1992/11/15 03:28:55 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  idlok()	- Enable use of Insert/Delete Line
X
X  X/Open Description:
X 	If enabeld (bf is TRUE), curses will use the insert/delete line
X 	feature of terminals so equipped.  If disabled, curses will not
X 	use this feature.  (The insert/delete character feature is always
X 	used.)  This option should be enabled only if the application
X 	needs insert/delete line; for example, for a screen editor.  It
X 	is disabled by default because insert/delete line tends to be
X 	visually annoying when used in applications where it isn't really
X 	needed.  If insert/delete line cannot be used, curses will redraw
X 	the changed portions of all lines.
X
X  PDCurses Description:
X 	This is provided for portability.  This may have some value for
X 	the FLEXOS platform, but there is no code in PDCurses at this
X 	time (910725) that takes advantage of this.
X
X  X/Open Return Value:
X 	The idlok() function returns OK on success and ERR on error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int idlok( WINDOW* win, bool bf );
X 	X/Open Dec '88	int idlok( WINDOW* win, bool bf );
X 	BSD Curses	
X 	SYS V Curses	
X
X**man-end**********************************************************************/
X
Xint	idlok( WINDOW *win, bool bf )
X{
X	win->_use_idl = bf;
X	return( OK );
X}
END_OF_FILE
  if test 1550 -ne `wc -c <'portable/idlok.c'`; then
    echo shar: \"'portable/idlok.c'\" unpacked with wrong size!
  fi
  # end of 'portable/idlok.c'
fi
if test -f 'portable/intrflus.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/intrflus.c'\"
else
  echo shar: Extracting \"'portable/intrflus.c'\" \(1488 characters\)
  sed "s/^X//" >'portable/intrflus.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	intrflush
X
X#ifndef	NDEBUG
Xchar *rcsid_intrflus = "$Header: c:/curses/portable/RCS/intrflus.c%v 2.0 1992/11/15 03:28:57 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  intrflush()	- enable flush on interrupt
X
X  X/Open Description:
X 	If this option is enabled (bf is TRUE), and an interrupt is
X 	pressed on the keyboard (INTR, BREAK, or QUIT) all output in
X 	the terminal driver queue will be flushed, giving the effect
X 	of faster response to the interrupt but causing curses to have
X 	the wrong idea of what is on the screen.  Disabling the option
X 	prevents the flush.  The default for the option is inherited
X 	from the terminal driver settings.  The window argument is
X 	ignored.
X
X  PDCurses Description:
X 	No additional functionality.
X
X  X/Open Return Value:
X 	The intrflush() function returns OK on success and ERR on error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int intrflush( WINDOW* win, bool bf );
X 	X/Open Dec '88	int intrflush( WINDOW* win, bool bf );
X 	BSD Curses	
X 	SYS V Curses	
X
X**man-end**********************************************************************/
X
Xint	intrflush( WINDOW *win, bool bf )
X{
X#ifdef	TC
X#  pragma argsused
X#endif
X	int	y;
X	int	maxy;
X
X	if (win == (WINDOW *)NULL)
X		return( ERR );
X
X	maxy = win->_maxy - 1;
X
X	for (y = 0; y <= maxy; y++)
X	{
X		win->_firstch[y] = _NO_CHANGE;
X	}
X	return( OK );
X}
END_OF_FILE
  if test 1488 -ne `wc -c <'portable/intrflus.c'`; then
    echo shar: \"'portable/intrflus.c'\" unpacked with wrong size!
  fi
  # end of 'portable/intrflus.c'
fi
if test -f 'portable/keypad.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/keypad.c'\"
else
  echo shar: Extracting \"'portable/keypad.c'\" \(1551 characters\)
  sed "s/^X//" >'portable/keypad.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	keypad
X
X#ifndef	NDEBUG
Xchar *rcsid_keypad = "$Header: c:/curses/portable/RCS/keypad.c%v 2.0 1992/11/15 03:28:58 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  keypad()	- enable keypad
X
X  X/Open Description:
X 	This function changes the keypad option of the user's terminal.
X 	If enabled (bf is TRUE), the user can press a function key (such
X 	as the left arrow key) and getch() will return a single value
X 	that represents the KEY_LEFT function key.  (See Section 11.3.3,
X 	Input Values.)  If disabled, curses will not treat function keys
X 	as special keys and the program has to interpret the escape
X 	sequences itself.  If the keypad is enabled, the terminal keypad
X 	is turned on before input begins.
X
X  PDCurses Description:
X 	In the above text, substitute the following string:
X 		"escape sequences"	->	"scan codes"
X 		"Section 11.3.3"	->	"curses.h" or "intro.man"
X
X 	This routine is also provided as a macro.
X
X  X/Open Return Value:
X 	The keypad() function returns OK on success and ERR on error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int keypad( WINDOW* win, bool bf );
X 	X/Open Dec '88	int keypad( WINDOW* win, bool bf );
X 	BSD Curses	int keypad( WINDOW* win, bool bf );
X 	SYS V Curses	int keypad( WINDOW* win, bool bf );
X
X**man-end**********************************************************************/
X
Xint	keypad( WINDOW *win, bool bf )
X{
X	win->_use_keypad = bf;
X	return( OK );
X}
END_OF_FILE
  if test 1551 -ne `wc -c <'portable/keypad.c'`; then
    echo shar: \"'portable/keypad.c'\" unpacked with wrong size!
  fi
  # end of 'portable/keypad.c'
fi
if test -f 'portable/leaveok.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/leaveok.c'\"
else
  echo shar: Extracting \"'portable/leaveok.c'\" \(1429 characters\)
  sed "s/^X//" >'portable/leaveok.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	leaveok
X
X#ifndef	NDEBUG
Xchar *rcsid_leaveok = "$Header: c:/curses/portable/RCS/leaveok.c%v 2.0 1992/11/15 03:28:59 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  leaveok()	- enable non-tracking cursor
X
X  X/Open Description:
X 	Normally, the hardware cursor is left at the location of the
X 	window being refreshed.  This option allows the cursor to be
X 	left whereever the update happens to leave it.  It is useful
X 	for applications where the cursor is not used, since it reduces
X 	the need for cursor motions.  If possible, the cursor is made
X 	invisible when this option is enabled.
X
X  PDCurses Description:
X 	Though not explicitly stated, the cursor will be made visible
X 	again, if leaveok() is passed a FALSE value.
X 			(Frotz:911226 Comments?)
X
X  X/Open Return Value:
X 	The leaveok() function returns OK on success and ERR on error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int leaveok( WINDOW* win, bool bf );
X 	X/Open Dec '88	int leaveok( WINDOW* win, bool bf );
X 	BSD Curses	int leaveok( WINDOW* win, bool bf );
X 	SYS V Curses	int leaveok( WINDOW* win, bool bf );
X
X**man-end**********************************************************************/
X
Xint	leaveok( WINDOW *win, bool bf )
X{
X	if  ((win->_leave = bf) != 0)	cursoff();
X	else				curson();
X	return( OK );
X}
END_OF_FILE
  if test 1429 -ne `wc -c <'portable/leaveok.c'`; then
    echo shar: \"'portable/leaveok.c'\" unpacked with wrong size!
  fi
  # end of 'portable/leaveok.c'
fi
if test -f 'portable/paircont.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/paircont.c'\"
else
  echo shar: Extracting \"'portable/paircont.c'\" \(1566 characters\)
  sed "s/^X//" >'portable/paircont.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef pair_content
X
X#ifndef	NDEBUG
Xchar *rcsid_paircont = "$Header: c:/curses/portable/RCS/paircont.c%v 2.0 1992/11/15 03:29:07 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  pair_content()	- Obtain color-pair information.
X
X  PDCurses Description:
X
X 	This routine is used to determine what the colors of a given color-pair
X 	consist of.
X
X 	The routine uses three arguments: the colorpair number which
X 	must be a value between 1 and COLOR_PAIRS-1 and the adresses of
X 	two shorts for storing the obtained color components of foreground
X 	and background. The function will store the current values at these
X 	addresses passed. The values will be between 0 and COLORS-1.
X
X  PDCurses Return Value:
X 	This function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	It is an error to call this function with a colorpair outside of the
X 	range specified above.
X
X  Portability:
X 	PDCurses	int pair_content( int colorpair, short *foreground, short *background);
X 	SYS V Curses	int pair_content( int colorpair, short *foreground, short *background);
X
X**man-end**********************************************************************/
X
X
Xint pair_content(int colorpair,short *foreground,short *background)
X{
X extern int COLOR_PAIRS;
X extern unsigned char atrtab[MAX_ATRTAB];
X
X if (colorpair >= COLOR_PAIRS || colorpair < 1)
X    return(ERR);
X
X *foreground = (short)(atrtab[colorpair] & 0x0F);
X *background = (short)((atrtab[colorpair] & 0xF0)>>4);
X return(OK);
X}
END_OF_FILE
  if test 1566 -ne `wc -c <'portable/paircont.c'`; then
    echo shar: \"'portable/paircont.c'\" unpacked with wrong size!
  fi
  # end of 'portable/paircont.c'
fi
if test -f 'portable/savetty.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/savetty.c'\"
else
  echo shar: Extracting \"'portable/savetty.c'\" \(1540 characters\)
  sed "s/^X//" >'portable/savetty.c' <<'END_OF_FILE'
X#ifndef NO_MEMORY_H
X#include <memory.h>
X#endif
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	savetty
X
X#ifndef NDEBUG
Xchar *rcsid_savetty = "$Header: c:/curses/portable/RCS/savetty.c%v 2.0 1992/11/15 03:29:13 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  savetty()	- save/restore terminal modes
X
X  X/Open Description:
X 	These routines save and restore the state of the terminal modes.
X 	The savetty() function saves the current state in a buffer and
X 	resetty() restores the state to what it was at the last call to
X 	savetty().
X
X  PDCurses Description:
X 	FYI: It is very unclear whether this is a duplication of the
X 	reset_prog_mode() and reset_shell_mode() functions or whether
X 	this is a backing store type of operation.  At this time, they
X 	are implemented similar to the reset_*_mode() routines.
X
X  X/Open Return Value:
X 	The savetty() function returns OK upon success otherwise ERR is
X 	returned.
X
X  Portability:
X 	PDCurses	int savetty( void );
X 	X/Open Dec '88	int savetty( void );
X 	SysV Curses	int savetty( void );
X 	BSD Curses	int savetty( void );
X
X**man-end**********************************************************************/
X
Xint	savetty(void)
X{
X	c_save_tty.been_set = TRUE;
X#if 	defined(DOS) || defined(OS2)
X#  if	SMALL || MEDIUM
X	movedata( FP_SEG(&_cursvar),		FP_OFF(&_cursvar),
X		  FP_SEG(&c_save_tty.saved),	FP_OFF(&c_save_tty.saved),
X		  sizeof(SCREEN) );
X#  else
X	memcpy(&c_save_tty.saved, &_cursvar, sizeof(SCREEN));
X#  endif
X#endif
X	return( OK );
X}
END_OF_FILE
  if test 1540 -ne `wc -c <'portable/savetty.c'`; then
    echo shar: \"'portable/savetty.c'\" unpacked with wrong size!
  fi
  # end of 'portable/savetty.c'
fi
if test -f 'portable/set_term.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/set_term.c'\"
else
  echo shar: Extracting \"'portable/set_term.c'\" \(1600 characters\)
  sed "s/^X//" >'portable/set_term.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	set_term
X
X#ifndef	NDEBUG
Xchar *rcsid_set_term = "$Header: c:/curses/portable/RCS/set_term.c%v 2.0 1992/11/15 03:29:15 MH Rel $";
X#endif
X
X#if	EMALLOC
Xvoid*	emalloc( size_t );
Xvoid*	ecalloc( size_t, size_t );
Xvoid	efree( void* );
X#endif
X
X
X
X
X
X/*man-start*********************************************************************
X
X  set_term()	- switch between terminals
X
X  X/Open Description:
X 	This function is used to switch between different terminals.
X 	The screen reference 'new' becomes the new current terminal.
X 	The previous terminal is returned by the routine.  This is the
X 	only routine which manipulates SCREEN pointers; all other routines
X 	affect only the current terminal.
X
X  PDCurses Description:
X 	FYI: Dual monitor support is not quite complete.  Nothing will
X 	happen if you try to call this routine.
X
X  X/Open Return Value:
X 	The set_term() function returns a pointer to the previous
X 	SCREEN structure on success otherwise a NULL pointer is
X 	returned.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  PDCurses Errors:
X 	It is an error to call this routine at this time.
X 	It is an error to pass a NULL SCREEN pointer.
X
X  Portability:
X 	PDCurses	SCREEN* set_term( SCREEN* new );
X 	X/Open Dec '88	SCREEN* set_term( SCREEN* new );
X 	BSD Curses	
X 	SYS V Curses	SCREEN* set_term( SCREEN* new );
X
X**man-end**********************************************************************/
X
XSCREEN*	set_term( SCREEN *new )
X{
X#ifdef	TC
X#  pragma argsused
X#endif
X	return( &_cursvar );  /* We only have one screen supported right now */
X}
END_OF_FILE
  if test 1600 -ne `wc -c <'portable/set_term.c'`; then
    echo shar: \"'portable/set_term.c'\" unpacked with wrong size!
  fi
  # end of 'portable/set_term.c'
fi
if test -f 'portable/touchwin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/touchwin.c'\"
else
  echo shar: Extracting \"'portable/touchwin.c'\" \(1458 characters\)
  sed "s/^X//" >'portable/touchwin.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	touchwin
X
X#ifndef	NDEBUG
Xchar *rcsid_touchwin = "$Header: c:/curses/portable/RCS/touchwin.c%v 2.0 1992/11/15 03:29:18 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  touchwin()	- touch window
X
X  X/Open Description:
X 	Throw away all optimisation information about which parts of the
X 	window have been touched, by pretending that the entire window has
X 	been drawn on.  This is sometimes necessary when using overlapping
X 	windows, since a change to one window will affect the other window,
X 	but the records of which lines have been changed in the other
X 	window will not reflect the change.
X
X  PDCurses Description:
X 	No additional functionality in the PDCurses library.
X
X  X/Open Return Value:
X 	The touchwin() function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	It is an error to pass a NULL window.
X
X  Portability:
X 	PDCurses	int touchwin( WINDOW* win );
X 	SysV Curses	int touchwin( WINDOW* win );
X 	BSD Curses	int touchwin( WINDOW* win );
X 	X/Open Dec '88	int touchwin( WINDOW* win );
X
X**man-end**********************************************************************/
X
Xint	touchwin(WINDOW *win)
X{
X	int	y;
X	int	maxy;
X	int	maxx;
X
X	if (win == (WINDOW *)NULL)
X		return( ERR );
X
X	maxy = win->_maxy - 1;
X	maxx = win->_maxx - 1;
X
X	for (y = 0; y <= maxy; y++)
X	{
X		win->_firstch[y] = 0;
X		win->_lastch[y] = maxx;
X	}
X	return( OK );
X}
END_OF_FILE
  if test 1458 -ne `wc -c <'portable/touchwin.c'`; then
    echo shar: \"'portable/touchwin.c'\" unpacked with wrong size!
  fi
  # end of 'portable/touchwin.c'
fi
if test -f 'portable/waddstr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/waddstr.c'\"
else
  echo shar: Extracting \"'portable/waddstr.c'\" \(1517 characters\)
  sed "s/^X//" >'portable/waddstr.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	waddstr
X
X#ifndef	NDEBUG
Xchar *rcsid_waddstr = "$Header: c:/curses/portable/RCS/waddstr.c%v 2.0 1992/11/15 03:29:21 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  waddstr()	- add string to window
X
X  X/Open Description:
X 	These routines write all the characters of the null-terminated
X 	string str on the given window.  The functionality is equivalent
X 	to calling waddch() once for each character in the string.
X
X 	NOTE:  addstr(), mvaddstr(), and mvwaddstr() are macros.
X
X  PDCurses Description:
X 	The *raw*() routines output 8 bit values.  These contrast to their
X 	normal counterparts which output 7 bit values and convert control
X 	character to the ^X notation.
X
X 	str is a standard 8 bit character string WITHOUT embedded attributes.
X
X  X/Open Return Value:
X 	The waddstr() function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	It is an error to call this function with a NULL window pointer.
X
X  Portability:
X 	PDCurses	int waddstr( WINDOW* win, char* str );
X 	X/Open Dec '88	int waddstr( WINDOW* win, char* str );
X 	BSD Curses	int waddstr( WINDOW* win, char* str );
X 	SYS V Curses	int waddstr( WINDOW* win, char* str );
X
X**man-end**********************************************************************/
X
Xint	waddstr(WINDOW *win, char *str)
X{
X	if (win == (WINDOW *)NULL)
X		return( ERR );
X
X	while (*str)
X	{
X		if (waddch(win, *str++) == ERR)
X		{
X			return( ERR );
X		}
X	}
X	return( OK );
X}
END_OF_FILE
  if test 1517 -ne `wc -c <'portable/waddstr.c'`; then
    echo shar: \"'portable/waddstr.c'\" unpacked with wrong size!
  fi
  # end of 'portable/waddstr.c'
fi
if test -f 'portable/wdeletel.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/wdeletel.c'\"
else
  echo shar: Extracting \"'portable/wdeletel.c'\" \(1601 characters\)
  sed "s/^X//" >'portable/wdeletel.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	wdeleteln
X
X#ifndef	NDEBUG
Xchar *rcsid_wdeletel = "$Header: c:/curses/portable/RCS/wdeletel.c%v 2.0 1992/11/15 03:29:06 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  wdeleteln()	- remove line from window
X
X  X/Open Description:
X 	The line under the cursor in the window is deleted.  All
X 	lines below the current line are moved up one line.  The
X 	bottom line of the window is cleared.  The cursor position
X 	does not change.
X
X 	NOTE: deleteln() is a macro.
X
X  PDCurses Description:
X 	No additional functionality.
X
X  X/Open Return Value:
X 	The wdeleteln() function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	It is an error to pass a NULL window pointer to this routine.
X
X  Portability:
X 	PDCurses	int wdeleteln( WINDOW* win );
X 	X/Open Dec '88	int wdeleteln( WINDOW* win );
X 	BSD Curses	int wdeleteln( WINDOW* win );
X 	SYS V Curses	int wdeleteln( WINDOW* win );
X
X**man-end**********************************************************************/
X
Xint	wdeleteln(WINDOW *win)
X{
Xstatic	chtype	blank;
X	chtype*	end;
X	chtype*	temp;
X	int	y;
X
X	if (win == (WINDOW *)NULL)
X		return( ERR );
X
X	blank	= win->_blank | win->_attrs;
X	temp	= win->_y[win->_cury];
X
X	for (y = win->_cury; y < win->_bmarg; y++)
X	{
X		win->_y[y]	 = win->_y[y + 1];
X		win->_firstch[y] = 0;
X		win->_lastch[y] = win->_maxx - 1;
X	}
X
X	win->_firstch[y]		= 0;
X	win->_lastch[y]		= win->_maxx - 1;
X	win->_y[win->_bmarg]	= temp;
X
X	for (end = &(temp[win->_maxx - 1]); temp <= end;)
X	{
X		*temp++ = blank;
X	}
X	return( OK );
X}
END_OF_FILE
  if test 1601 -ne `wc -c <'portable/wdeletel.c'`; then
    echo shar: \"'portable/wdeletel.c'\" unpacked with wrong size!
  fi
  # end of 'portable/wdeletel.c'
fi
if test -f 'portable/winsertl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/winsertl.c'\"
else
  echo shar: Extracting \"'portable/winsertl.c'\" \(1554 characters\)
  sed "s/^X//" >'portable/winsertl.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	winsert
X
X#ifndef	NDEBUG
Xchar *rcsid_winsertl = "$Header: c:/curses/portable/RCS/winsertl.c%v 2.0 1992/11/15 03:29:09 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  winsert()	- Insert line
X
X  X/Open Description:
X 	A blank line is inserted above the current line and the bottom
X 	line is lost.
X
X 	NOTE: insertln() is a macro.
X
X  PDCurses Description:
X 	The mv[w]insertln() routines have been added to the X/Open
X 	interface specification as a convienience.
X
X  X/Open Return Value:
X 	These functions return OK on success and ERR on error.
X
X  PDCurses Errors:
X 	It is an error to call this function with a NULL window pointer.
X
X  Portability:
X 	PDCurses	int winsertln( WINDOW* win );
X 	X/Open Dec '88	int winsertln( WINDOW* win );
X 	BSD Curses	int winsertln( WINDOW* win );
X 	SYS V Curses	int winsertln( WINDOW* win );
X
X
X**man-end**********************************************************************/
X
Xint	winsertln(WINDOW *win)
X{
X	chtype	blank;
X	chtype*	temp;
X	chtype*	end;
X	short	y;
X
X	if (win == (WINDOW *)NULL)
X		return( ERR );
X
X	blank	= win->_blank | win->_attrs;
X	temp	= win->_y[win->_bmarg];
X
X	for (y = win->_bmarg; y > win->_cury; y--)
X	{
X		win->_y[y]	 = win->_y[y - 1];
X		win->_firstch[y] = 0;
X		win->_lastch[y] = win->_maxx - 1;
X	}
X
X	win->_y[win->_cury] = temp;
X
X	for (end = &temp[win->_maxx - 1]; temp <= end; temp++)
X	{
X		*temp = blank;
X	}
X
X	win->_firstch[win->_cury] = 0;
X	win->_lastch[win->_cury] = win->_maxx - 1;
X
X	return( OK );
X}
END_OF_FILE
  if test 1554 -ne `wc -c <'portable/winsertl.c'`; then
    echo shar: \"'portable/winsertl.c'\" unpacked with wrong size!
  fi
  # end of 'portable/winsertl.c'
fi
if test -f 'portable/wmove.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/wmove.c'\"
else
  echo shar: Extracting \"'portable/wmove.c'\" \(1553 characters\)
  sed "s/^X//" >'portable/wmove.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef	wmove
X
X#ifndef	NDEBUG
Xchar *rcsid_wmove = "$Header: c:/curses/portable/RCS/wmove.c%v 2.0 1992/11/15 03:29:27 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  wmove()	- Move cursor in window
X
X  X/Open Description:
X 	The cursor associated with the window is moved to the given
X 	location.  This does not move the physical cursor of the
X 	terminal until refresh() is called.  The position specified is
X 	relative to the upper left corner of the window, which is (0,0).
X
X 	NOTE: move() is a macro.
X
X  PDCurses Description:
X 	There may be additional [window oriented] move routines associated
X 	with other sections of the curses library.  See those sections for
X 	details.
X
X  X/Open Return Value:
X 	These functions return OK on success and ERR on error.
X
X  PDCurses Errors:
X 	It is an error to call this function with a NULL window pointer.
X
X  Portability:
X 	PDCurses	int wmove( WINDOW* win, int y, int x );
X 	X/Open Dec '88	int wmove( WINDOW* win, int y, int x );
X 	BSD Curses	int wmove( WINDOW* win, int y, int x );
X 	SYS V Curses	int wmove( WINDOW* win, int y, int x );
X
X**man-end**********************************************************************/
X
Xint	wmove(WINDOW *win, int y, int x)
X{
X	if (win == (WINDOW *)NULL)
X		return( ERR );
X
X	if ((x < 0) ||
X	    (y < 0) ||
X	    (x >= win->_maxx) ||
X	    (y >= win->_maxy) ||
X	    (y < win->_tmarg) ||
X	    (y > win->_bmarg))
X	{
X		return( ERR );
X	}
X	win->_curx = x;
X	win->_cury = y;
X	return( OK );
X}
END_OF_FILE
  if test 1553 -ne `wc -c <'portable/wmove.c'`; then
    echo shar: \"'portable/wmove.c'\" unpacked with wrong size!
  fi
  # end of 'portable/wmove.c'
fi
if test -f 'portable/wrefresh.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'portable/wrefresh.c'\"
else
  echo shar: Extracting \"'portable/wrefresh.c'\" \(1445 characters\)
  sed "s/^X//" >'portable/wrefresh.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X#undef wrefresh
X
X#ifndef	NDEBUG
Xchar *rcsid_wrefresh = "$Header: c:/curses/portable/RCS/wrefresh.c%v 2.0 1992/11/15 03:29:28 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  wrefresh()	- refresh window
X
X  X/Open Description:
X 	The routine wrefresh copies the named window to the physical
X 	terminal screen, taking into account what is already there in
X 	order to optimize cursor movement.
X
X 	The routine refresh does the same, using stdscr as a default
X 	screen.
X
X 	These routines must be called to get any output on the
X 	terminal, as other routines only manipulate data structures.
X
X 	Unless leaveok has been enabled, the physical cursor of the
X 	terminal is left at the location of the window's cursor.
X
X  X/Open Return Value:
X 	The wrefresh() function returns OK on success and ERR on error.
X
X  X/Open Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int wrefresh( WINDOW* win );
X 	X/Open Dec '88	int wrefresh( WINDOW* win );
X 	BSD Curses	int wrefresh( WINDOW* win );
X 	SYS V Curses	int wrefresh( WINDOW* win );
X
X**man-end**********************************************************************/
X
Xint	wrefresh(WINDOW *win)
X{
X	if (win == (WINDOW *)NULL)	return( ERR );
X	if (win->_flags & _PAD)	return( ERR );
X
X	if (win == curscr)
X		curscr->_clear = TRUE;
X	else	
X		wnoutrefresh(win);
X	doupdate();
X	return( OK );
X}
END_OF_FILE
  if test 1445 -ne `wc -c <'portable/wrefresh.c'`; then
    echo shar: \"'portable/wrefresh.c'\" unpacked with wrong size!
  fi
  # end of 'portable/wrefresh.c'
fi
if test -f 'private/_getcols.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_getcols.c'\"
else
  echo shar: Extracting \"'private/_getcols.c'\" \(1587 characters\)
  sed "s/^X//" >'private/_getcols.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__getcols = "$Header: c:/curses/private/RCS/_getcols.c%v 2.0 1992/11/15 03:24:24 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_get_columns()	- return width of screen/viewport.
X
X  PDCurses Description:
X 	This is a private PDCurses function
X
X 	This function will return the width of the current screen.
X
X  PDCurses Return Value:
X 	This routine will return OK upon success and otherwise ERR will be
X 	returned.
X
X  PDCurses Errors:
X 	There are no defined errors for this routine.
X
X  Portability:
X 	PDCurses	int	PDC_get_columns( void );
X
X**man-end**********************************************************************/
X
Xint	PDC_get_columns(void)
X{
X#ifdef	FLEXOS
X	return( vir.vc_size.rs_ncols );
X#endif
X#ifdef	DOS
X/*	short far*	CRT_COLS;*/
X	int		cols;
X	char *env_cols;
X
X/*	CRT_COLS = (short far *) 0x044aL;*/
X/*	cols = *CRT_COLS;*/
X
X/* use the value from COLS environment variable, if set. MH 10-Jun-92 */
X/* and use the minimum of COLS and return from int10h    MH 18-Jun-92 */
X	regs.h.ah = 0x0f;
X	int86(0x10, &regs, &regs);
X	cols = (int)regs.h.ah;
X	env_cols = (char *)getenv("COLS");
X	if (env_cols != (char *)NULL)
X	{
X		cols = min(atoi(env_cols),cols);
X	}
X	return(cols);
X#endif
X#ifdef	OS2
X	VIOMODEINFO modeInfo;
X	int cols;
X	char *env_cols;
X
X	modeInfo.cb = sizeof(modeInfo);
X	VioGetMode(&modeInfo, 0);
X	cols = modeInfo.col;
X	env_cols = (char *)getenv("COLS");
X	if (env_cols != (char *)NULL)
X	{
X		cols = min(atoi(env_cols),cols);
X	}
X	return(cols);
X#endif
X}
END_OF_FILE
  if test 1587 -ne `wc -c <'private/_getcols.c'`; then
    echo shar: \"'private/_getcols.c'\" unpacked with wrong size!
  fi
  # end of 'private/_getcols.c'
fi
if test -f 'private/_getcrsr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_getcrsr.c'\"
else
  echo shar: Extracting \"'private/_getcrsr.c'\" \(1407 characters\)
  sed "s/^X//" >'private/_getcrsr.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__getcrsr = "$Header: c:/curses/private/RCS/_getcrsr.c%v 2.0 1992/11/15 03:24:25 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_get_cursor_mode()	- Get the cursor start and stop scan lines.
X
X  PDCurses Description:
X 	Gets the cursor type to begin in scan line startrow and end in
X 	scan line endrow.  Both values should be 0-31.
X
X  PDCurses Return Value:
X 	This function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int PDC_get_cursor_mode( void );
X
X**man-end**********************************************************************/
X
Xint	PDC_get_cursor_mode(void)
X{
X#ifdef	FLEXOS
X	/*
X	 * Under FLEXOS, this routine returns 1 if the cursor is on and 0 if
X	 * the cursor is off...
X	 */
X	s_getfield(T_VIRCON, VC_MODE, STDOUT, (far BYTE *) & vir,
X		sizeof(vir.vc_mode));
X
X	if (vir.vc_mode & VCWM_CURSOR)
X		return (TRUE);
X	else
X		return (FALSE);
X#endif
X#ifdef	DOS
X	short far*	CURSOR_MODE;
X	short		cmode;
X
X	CURSOR_MODE = (short far *) 0x0460L;
X	cmode = *CURSOR_MODE;
X	return (cmode);
X#endif
X#ifdef	OS2
X	VIOCURSORINFO cursorInfo;
X	short		cmode;
X
X	VioGetCurType (&cursorInfo, 0);
X/* I am not sure about this JGB */
X	cmode = ((cursorInfo.yStart << 8) | (cursorInfo.cEnd));
X	return(cmode);
X#endif
X}
END_OF_FILE
  if test 1407 -ne `wc -c <'private/_getcrsr.c'`; then
    echo shar: \"'private/_getcrsr.c'\" unpacked with wrong size!
  fi
  # end of 'private/_getcrsr.c'
fi
if test -f 'private/_getfont.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_getfont.c'\"
else
  echo shar: Extracting \"'private/_getfont.c'\" \(1621 characters\)
  sed "s/^X//" >'private/_getfont.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__getfont = "$Header: c:/curses/private/RCS/_getfont.c%v 2.0 1992/11/15 03:24:25 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_get_font()	- Get the current font size
X
X  PDCurses Description:
X 	This is a private PDCurses routine.
X
X 	This function returns the current font size.  This function only
X 	works if the #define FAST_VIDEO is true.
X
X  PDCurses Return Value:
X 	This function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	An ERR will be returned if FAST_VIDEO is not true.
X
X  Portability:
X 	PDCurses	int PDC_get_font( void );
X
X**man-end**********************************************************************/
X
Xint	PDC_get_font(void)
X{
X#if	defined (DOS) && defined (FAST_VIDEO)
X	int	retval;
X	short far *POINTS;
X
X	POINTS = (short far *) 0x0485L;
X	retval = *POINTS;
X	if ((retval == 0) && (_cursvar.adapter == _MDS_GENIUS))
X	{
X		retval = _FONT15; /* Assume the MDS Genius is in 66 line mode. */
X	}
X	switch (_cursvar.adapter)
X	{
X	case _EGACOLOR:
X	case _EGAMONO:
X		switch (retval)
X		{
X		case _FONT8:
X		case _FONT14:
X			break;
X		default:
X			retval = _FONT14;
X		}
X		break;
X
X	case _VGACOLOR:
X	case _VGAMONO:
X		switch (retval)
X		{
X		case _FONT8:
X		case _FONT14:
X		case _FONT16:
X			break;
X		default:
X			break;
X		}
X		break;
X	default:
X		break;
X	}
X	return( retval );
X#endif
X#ifdef OS2
X	VIOMODEINFO modeInfo;
X        modeInfo.cb = sizeof(modeInfo);
X        /* set most parameters of modeInfo */
X	VioGetMode(&modeInfo, 0);
X        return ( modeInfo.vres / modeInfo.row);
X#endif
X}
END_OF_FILE
  if test 1621 -ne `wc -c <'private/_getfont.c'`; then
    echo shar: \"'private/_getfont.c'\" unpacked with wrong size!
  fi
  # end of 'private/_getfont.c'
fi
if test -f 'private/_gotoxy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_gotoxy.c'\"
else
  echo shar: Extracting \"'private/_gotoxy.c'\" \(1459 characters\)
  sed "s/^X//" >'private/_gotoxy.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__gotoxy = "$Header: c:/curses/private/RCS/_gotoxy.c%v 2.0 1992/11/15 03:24:27 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_gotoxy()	- position hardware cursor at (x, y)
X
X  PDCurses Description:
X 	This is a private PDCurses routine.
X
X 	Moves the physical cursor to the desired address on the
X 	screen. We don't optimize here -- on a PC, it takes more time
X 	to optimize than to do things directly.
X
X  PDCurses Return Value:
X 	This function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int PDC_gotoxy( int row, int col );
X
X**man-end**********************************************************************/
X
Xint	PDC_gotoxy(int row, int col)
X{
X	if ((_cursvar.cursrow == row) && (_cursvar.curscol == col))
X		return( OK );
X
X#ifdef	FLEXOS
X	retcode = s_get(T_VIRCON, 0L, (char *) &vir, (long) sizeof(vir));
X	if (retcode < 0L)
X		return( ERR );
X	vir.vc_cursor.pos_row = row;
X	vir.vc_cursor.pos_col = col;
X	retcode = s_set(T_VIRCON, 0L, (char *) &vir, (long) sizeof(vir));
X	return( (retcode < 0L) ? ERR : OK );
X#endif
X#ifdef	DOS
X	regs.h.ah = 0x02;
X	regs.h.bh = _cursvar.video_page;
X	regs.h.dh = (unsigned char) row;
X	regs.h.dl = (unsigned char) col;
X	int86(0x10, &regs, &regs);
X	return( OK );
X#endif
X#ifdef	OS2
X	VioSetCurPos (row, col, 0);
X#endif
X}
END_OF_FILE
  if test 1459 -ne `wc -c <'private/_gotoxy.c'`; then
    echo shar: \"'private/_gotoxy.c'\" unpacked with wrong size!
  fi
  # end of 'private/_gotoxy.c'
fi
if test -f 'private/_print.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_print.c'\"
else
  echo shar: Extracting \"'private/_print.c'\" \(1628 characters\)
  sed "s/^X//" >'private/_print.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#define NEEDS_OS2       1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__print = "$Header: c:/curses/private/RCS/_print.c%v 2.0 1992/11/15 03:24:33 MH Rel $";
X#endif
X
X#ifdef OS2
X#  if !defined (CURSES__32BIT__) && !defined(CSET2) && !defined(MSC)
X#define INCL_DOS
X#include <bsedos.h>
X#endif
Xchar Printer[]="LPT1:";
X#endif
X
X
X/*man-start*********************************************************************
X
X  PDC_print()	- Provides primitive access to the BIOS printer functions
X
X  PDCurses Description:
X 	This is a private PDCurses routine.
X
X 	Implements write/init/read printer services at the BIOS level.
X
X 	This provides the basic support that PDCurses needs to dump the
X 	contents of windows or pads to the printer attached to the BIOS
X 	printer port.
X
X  PDCurses Return Value:
X 	See the BIOS INT 0x17 specifications.
X
X  PDCurses Errors:
X 	See the BIOS INT 0x17 specifications.
X
X  Portability:
X 	PDCurses	int PDC_print( int cmd, int byte, int port );
X
X**man-end**********************************************************************/
X
Xint	PDC_print(int cmd, int byte, int port)
X{
X#ifdef	FLEXOS
X	return( OK );
X#endif
X#ifdef	DOS
X	int	status = 0;
X
X	regs.h.ah = (unsigned char)cmd;
X	regs.h.al = (unsigned char)byte;
X	regs.x.dx = (unsigned int)port;
X	int86(0x17, &regs, &regs);
X	status = regs.h.ah;
X	return (status);
X#endif
X#ifdef	OS2
X#  if !defined (CURSES__32BIT__) && !defined(CSET2)
X	HFILE Lpt;
X	USHORT Action;
X	USHORT NoWritten;
X	if (DosOpen((PSZ)Printer, &Lpt, &Action, 0,0,0,0,0) != 0)
X		return(ERR);
X	DosWrite(Lpt,&byte,1,&NoWritten);
X	DosClose(Lpt);
X	return(NoWritten == 1);
X#  endif	
X#endif
X}
END_OF_FILE
  if test 1628 -ne `wc -c <'private/_print.c'`; then
    echo shar: \"'private/_print.c'\" unpacked with wrong size!
  fi
  # end of 'private/_print.c'
fi
if test -f 'private/_putc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_putc.c'\"
else
  echo shar: Extracting \"'private/_putc.c'\" \(1528 characters\)
  sed "s/^X//" >'private/_putc.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__putc = "$Header: c:/curses/private/RCS/_putc.c%v 2.0 1992/11/15 03:24:30 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_putc()	- Output a character in the current attribute.
X
X  PDCurses Description:
X 	This is a private PDCurses routine.
X
X 	Outputs character 'chr' to screen in tty fashion. If a colour
X 	mode is active, the character is written with colour 'colour'.
X
X  PDCurses Return Value:
X 	This function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int PDC_putc( chtype character, chtype color );
X
X**man-end**********************************************************************/
X
Xint	PDC_putc( chtype character, chtype color )
X{
X#ifdef	FLEXOS
X	int	x = color;
X	retcode = s_write(0x00, 0x01L, (_far char *) &character, 1L, 0);
X	return( (retcode < 0L) ? ERR : OK );
X#endif
X#ifdef	DOS
X	regs.h.ah = 0x0a;	/* Avoid screen wrap.  Don't advance cursor. */
X	regs.h.al = (unsigned char) (character & A_CHARTEXT);
X	regs.h.bh = _cursvar.video_page;
X	regs.h.bl = (unsigned char) ((color & A_ATTRIBUTES) >> 8);
X	regs.x.cx = 0;
X	int86(0x10, &regs, &regs);
X	return( OK );
X#endif
X#ifdef	OS2
X	int curRow = PDC_get_cur_row ();
X	int curCol = PDC_get_cur_col ();
X
X	VioWrtTTY ((PCH)&character, 1, 0);
X	VioWrtNAttr ((PBYTE)&color, 1, (USHORT)curRow, (USHORT)curCol, 0);
X	PDC_gotoxy (curRow, curCol);
X	return( OK );
X#endif
X}
END_OF_FILE
  if test 1528 -ne `wc -c <'private/_putc.c'`; then
    echo shar: \"'private/_putc.c'\" unpacked with wrong size!
  fi
  # end of 'private/_putc.c'
fi
if test -f 'private/_putctty.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_putctty.c'\"
else
  echo shar: Extracting \"'private/_putctty.c'\" \(1596 characters\)
  sed "s/^X//" >'private/_putctty.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__putctty = "$Header: c:/curses/private/RCS/_putctty.c%v 2.0 1992/11/15 03:24:30 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_putctty()	- Output a character and attribute in TTY fashion.
X
X  PDCurses Description:
X 	This is a private PDCurses routine.
X
X 	Outputs character 'chr' to screen in tty fashion. If a colour
X 	mode is active, the character is written with colour 'colour'.
X
X 	This function moves the physical cursor after writing so the
X 	screen will scroll if necessary.
X
X  PDCurses Return Value:
X 	This function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int PDC_putctty( chtype character, chtype color );
X
X**man-end**********************************************************************/
X
Xint	PDC_putctty( chtype character, chtype color )
X{
X#ifdef	FLEXOS
X	int	x = color;
X	retcode = s_write(0x00, 0x01L, (_far char *) &character, 1L, 0);
X	return( (retcode < 0L) ? ERR : OK );
X#endif
X#ifdef	DOS
X	regs.h.ah = 0x0e;	/* Write in TTY fashion, advance cursor. */
X	regs.h.al = (unsigned char) (character & A_CHARTEXT);
X	regs.h.bh = _cursvar.video_page;
X	regs.h.bl = (unsigned char) ((color & A_ATTRIBUTES) >> 8);
X	int86(0x10, &regs, &regs);
X	return( OK );
X#endif
X#ifdef	OS2
X	int curRow = PDC_get_cur_row ();
X	int curCol = PDC_get_cur_col ();
X
X	VioWrtTTY ((PCH)&character, 1, 0);
X	VioWrtNAttr ((PBYTE)&color, 1, (USHORT)curRow, (USHORT)curCol, 0);
X	return( OK );
X#endif
X}
END_OF_FILE
  if test 1596 -ne `wc -c <'private/_putctty.c'`; then
    echo shar: \"'private/_putctty.c'\" unpacked with wrong size!
  fi
  # end of 'private/_putctty.c'
fi
if test -f 'private/_scrclos.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_scrclos.c'\"
else
  echo shar: Extracting \"'private/_scrclos.c'\" \(1414 characters\)
  sed "s/^X//" >'private/_scrclos.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__scrclos = "$Header: c:/curses/private/RCS/_scrclos.c%v 2.0 1992/11/15 03:24:33 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_scr_close()	- Internal low-level binding to close the physical screen
X
X  PDCurses Description:
X 	This function provides a low-level binding for the Flexos
X 	platform which must close the screen before writing to it.
X 	This is a nop for the DOS platform.
X
X 	This function is provided in order to reset the FlexOS 16 bit
X 	character set for input rather than the limited input
X 	character set associated with the VT52.
X
X  PDCurses Return Value:
X 	This function returns OK on success, otherwise an ERR is returned.
X
X  PDCurses Errors:
X 	The DOS platform will never fail.  The Flexos platform may fail
X 	depending on the ability to close the current virtual console in
X 	8 (as opposed to 16) bit mode.
X
X  Portability:
X 	PDCurses	int	PDC_scr_close( void );
X
X**man-end**********************************************************************/
X
Xint	PDC_scr_close(void)
X{
X#ifdef	FLEXOS
X	_flexos_8bitmode();
X	vir.vc_kbmode = kbmode;
X	vir.vc_smode = smode;
X	vir.vc_mode = cmode;
X	retcode = s_set(T_VIRCON, 1L, (char *) &vir, (long) sizeof(vir));
X	if  (retcode < 0L)
X		return( ERR );
X	return( OK );
X#endif
X#if	defined (DOS) || defined (OS2)
X	return( OK );
X#endif
X}
END_OF_FILE
  if test 1414 -ne `wc -c <'private/_scrclos.c'`; then
    echo shar: \"'private/_scrclos.c'\" unpacked with wrong size!
  fi
  # end of 'private/_scrclos.c'
fi
if test -f 'private/_set8025.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_set8025.c'\"
else
  echo shar: Extracting \"'private/_set8025.c'\" \(1469 characters\)
  sed "s/^X//" >'private/_set8025.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef NDEBUG
Xchar *rcsid__set8025 = "$Header: c:/curses/private/RCS/_set8025.c%v 2.0 1992/11/15 03:24:35 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_set_80x25()	- force a known screen state: 80x25 text mode.
X
X  PDCurses Description:
X 	This is a private PDCurses function.
X
X 	Forces the appropriate 80x25 alpha mode given the display adapter.
X
X 	Since we currently do not support changing the virtual console size,
X 	this routine is a NOP under Flexos.
X
X  PDCurses Return Value:
X 	This function returns OK upon success otherwise ERR is returned.
X
X  PDCurses Errors:
X 	No errors are defined for this routine.
X
X  Portability:
X 	PDCurses	int	PDC_set_80x25( void );
X
X**man-end**********************************************************************/
X
Xint	PDC_set_80x25(void)
X{
X#ifdef	FLEXOS
X	return( OK );
X#endif
X#ifdef	DOS
X	switch (_cursvar.adapter)
X	{
X	case _CGA:
X	case _EGACOLOR:
X	case _EGAMONO:
X	case _VGACOLOR:
X	case _VGAMONO:
X	case _MCGACOLOR:
X	case _MCGAMONO:
X		regs.h.ah = 0x00;
X		regs.h.al = 0x03;
X		int86(0x10, &regs, &regs);
X		break;
X	case _MDA:
X		regs.h.ah = 0x00;
X		regs.h.al = 0x07;
X		int86(0x10, &regs, &regs);
X	default:
X		break;
X	}
X	return( OK );
X#endif
X#ifdef	OS2
X	VIOMODEINFO modeInfo;
X
X	modeInfo.cb = sizeof(modeInfo);
X	/* set most parameters of modeInfo */
X	VioGetMode(&modeInfo, 0);
X	modeInfo.fbType = 1;
X	VioSetMode(&modeInfo, 0);
X#endif
X}
END_OF_FILE
  if test 1469 -ne `wc -c <'private/_set8025.c'`; then
    echo shar: \"'private/_set8025.c'\" unpacked with wrong size!
  fi
  # end of 'private/_set8025.c'
fi
if test -f 'private/_setscrn.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_setscrn.c'\"
else
  echo shar: Extracting \"'private/_setscrn.c'\" \(1444 characters\)
  sed "s/^X//" >'private/_setscrn.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__setscrn = "$Header: c:/curses/private/RCS/_setscrn.c%v 2.0 1992/11/15 03:24:37 MH Rel $";
X#endif
X
X
X
X
X/*man-start*********************************************************************
X
X  PDC_set_scrn_mode()	- Set BIOS Video Mode
X
X  PDCurses Description:
X 	Sets the BIOS Video Mode Number ONLY if it is different from
X 	the current video mode.  This routine is for DOS systems only.
X
X  PDCurses Return Value:
X 	This function returns OK on success and ERR on error.
X
X  PDCurses Errors:
X 	No errors are defined for this function.
X
X  Portability:
X 	PDCurses	int PDC_set_scrn_mode( int new_mode );
X
X**man-end**********************************************************************/
X
X#ifdef     OS2
Xint	PDC_set_scrn_mode(VIOMODEINFO new_mode)
X#else
Xint	PDC_set_scrn_mode(int new_mode)
X#endif
X{
X#ifdef	FLEXOS
X	return( OK );
X#endif
X#ifdef	DOS
X	int	cur;
X
X	cur = (int) PDC_get_scrn_mode();
X	if (cur != new_mode)
X	{
X		regs.h.ah = 0x00;
X		regs.h.al = (char) new_mode;
X		int86(0x10, &regs, &regs);
X	}
X	_cursvar.font = PDC_get_font();
X	_cursvar.scrnmode = new_mode;
X	LINES = PDC_get_rows();
X	COLS = PDC_get_columns();
X	return( OK );
X#endif
X#ifdef	OS2
X        if (VioSetMode (&new_mode, 0) != 0)
X        {
X	  _cursvar.font = PDC_get_font();
X	  _cursvar.scrnmode = new_mode;
X	  LINES = PDC_get_rows();
X	  COLS = PDC_get_columns();
X	  return( OK );
X        }
X	else
X	  return (ERR);
X#endif
X}
END_OF_FILE
  if test 1444 -ne `wc -c <'private/_setscrn.c'`; then
    echo shar: \"'private/_setscrn.c'\" unpacked with wrong size!
  fi
  # end of 'private/_setscrn.c'
fi
if test -f 'private/_splitpl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'private/_splitpl.c'\"
else
  echo shar: Extracting \"'private/_splitpl.c'\" \(1546 characters\)
  sed "s/^X//" >'private/_splitpl.c' <<'END_OF_FILE'
X#define	CURSES_LIBRARY	1
X#include <curses.h>
X
X#ifndef	NDEBUG
Xchar *rcsid__splitpl = "$Header: c:/curses/private/RCS/_splitpl.c%v 2.0 1992/11/15 03:24:41 MH Rel $";
X#endif
X
X
X
X#ifdef	FLEXOS
X/*man-start*********************************************************************
X
X  _flexos_split_plane()	- splits a char/attr plane into separate planes
X
X  PDCurses Description:
X 	This is a private PDCurses function.
X
X 	This routine is used only be the Flexos platform.
X
X 	This routine will separate the character/attributes plane into
X 	a separate character and attribute plane.
X
X  PDCurses Return Value:
X 	This function returns OK upon success otherwise ERR is returned.
X
X  PDCurses Errors:
X 	It is an error to pass a NULL WINDOW pointer.
X 	It is also an error if the starting x or y coordinate exceeds the
X 	passed window boundaries.
X
X  Portability:
X 	PDCurses	int	_flexos_split_plane( WINDOW* w,
X 					char* chr, char* attr,
X 					int sy, int sx,
X 					int ey, int ex );
X
X**man-end**********************************************************************/
X
Xint	_flexos_split_plane(WINDOW* w,char* chr,char* attr,int sy,int sx,int ey,int ex)
X{
X	int	l;
X	int	c;
X
X	if (w == (WINDOW *)NULL)		return( ERR );
X	if (sy > w->_maxy)	return( ERR );
X	if (sx > w->_maxx)	return( ERR );
X	if (ey > w->_maxy)	ey = w->_maxy - 1;
X	if (ex > w->_maxx)	ex = w->_maxx - 1;
X
X	for (l = sy; l <= ey; l++)
X	{
X		for (c = sx; c <= ex; c++)
X		{
X			*chr  = (char)(w->_y[l][c] & CHR_MSK);
X			*attr = (char)(w->_y[l][c] & ATR_MSK) >> 8;
X			chr++;
X			attr++;
X		}
X	}
X	return( OK );
X}
X#endif
END_OF_FILE
  if test 1546 -ne `wc -c <'private/_splitpl.c'`; then
    echo shar: \"'private/_splitpl.c'\" unpacked with wrong size!
  fi
  # end of 'private/_splitpl.c'
fi
echo shar: End of archive 9 \(of 11\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 11 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
