Newsgroups: comp.sources.misc
From: jmd@cyclone.bt.co.uk (John Downey)
Subject:  v33i019:  xvi - portable multi-window vi-like editor, Part10/18
Message-ID: <1992Oct24.172239.2004@sparky.imd.sterling.com>
X-Md4-Signature: 504814a0f682503af7299b1e63aad003
Date: Sat, 24 Oct 1992 17:22:39 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jmd@cyclone.bt.co.uk (John Downey)
Posting-number: Volume 33, Issue 19
Archive-name: xvi/part10
Environment: Unix, MS-DOS, OS/2, QNX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  xvi/doc/xvi.lst.UU xvi/src/makefile.aix xvi/src/search.c
# Wrapped by kent@sparky on Thu Oct 22 09:03:43 1992
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 10 (of 18)."'
if test -f 'xvi/doc/xvi.lst.UU' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xvi/doc/xvi.lst.UU'\"
else
  echo shar: Extracting \"'xvi/doc/xvi.lst.UU'\" \(23200 characters\)
  sed "s/^X//" >'xvi/doc/xvi.lst.UU' <<'END_OF_FILE'
Xbegin 664 xvi/doc/xvi.lst
XM"@H*6%9)*#$I(" @(" @(" @(" @(" @(" @(%5315(@0T]-34%.1%,@(" @
XM(" @(" @(" @(" @(" @("!85DDH,2D*"@H*3D%-10H@(" @('AV:2 M(&UU
XM;'1I+69I;&4@=&5X="!E9&ET;W(*"E-93D]04TE3"B @(" @>'9I('L@+7,@
XM(%\(<%\(85\(<E\(85\(;5\(95\(=%\(95\(<BU?"&%?"'-?"'-?"&E?"&=?
XM"&Y?"&U?"&5?"&Y?"'0@('T@(%L@("UT("!?"'1?"&%?"&<@('P@("M?"&Y?
XM"'5?"&U?"&)?"&5?"'(@('P*(" @(" K+U\(<%\(85\(=%\(=%\(95\(<E\(
XM;B!=('L@7PAF7PAI7PAL7PAE7PAN7PAA7PAM7PAE("XN+B @?0H*1$530U))
XM4%1)3TX*(" @("!8=FD@*'!R;VYO=6YC960@7PAE7PAC7PAK7PAS+5\(=E\(
XM95\(92U?"&5?"'E?"&4I(&ES(&$@(&9R964L("!P;W)T86)L92P@(&UU;'1I
XM+0H@(" @('=I;F1O=R @:6UP;&5M96YT871I;VX@(&]F('1H92!P;W!U;&%R
XM('9I*#$I(&5D:71O<BX@($ET(&AA<PH@(" @('-O;64@=7-E9G5L(&5N:&%N
XM8V5M96YT<RP@86QT:&]U9V@L(&%S(&1E<V-R:6)E9"!B96QO=RP@(&YO= H@
XM(" @(&%L;" @;V8@('9I)W,@(&9E871U<F5S("!H879E(&)E96X@:6UP;&5M
XM96YT960@>65T+"!A;F0@<V]M90H@(" @('1H:6YG<R!W;W)K(&1I9F9E<F5N
XM=&QY(&9R;VT@=FDN"@I/4%1)3TY3"B @(" @5&AE(&9O;&QO=VEN9R!C;VUM
XM86YD+6QI;F4@;W!T:6]N<R!A<F4@879A:6QA8FQE.@H*(" @(" M<R!?"'!?
XM"&%?"')?"&%?"&U?"&5?"'1?"&5?"'(M7PAA7PAS7PAS7PAI7PAG7PAN7PAM
XM7PAE7PAN7PAT"@D@(%-E="!T:&4@=F%L=64@;V8@=&AE('-P96-I9FEE9" @
XM<&%R86UE=&5R("!A=" @<W1A<G1U<"X*"2 @5&AE("!A<W-I9VYM96YT("!H
XM87,@('1H92!S86UE(&9O<FT@87,@=VAE;B!G:79E;B!A<R!A;@H)("!E9&ET
XM;W(@8V]M;6%N9"P@:2YE.@H*"2 @7PAN7PAA7PAM7PAE/5\(<U\(=%\(<E\(
XM:5\(;E\(9PH)(" @(" @(&9O<B!S=')I;F<@<&%R86UE=&5R<PH*"2 @7PAN
XM7PAA7PAM7PAE/5\(;E\(=5\(;5\(8E\(95\(<@H)(" @(" @(&9O<B!N=6UE
XM<FEC('!A<F%M971E<G,*"@D@(%\(;E\(85\(;5\(92!T;R!T=7)N(&$@0F]O
XM;&5A;B!P87)A;65T97(@;VX*"@D@(&YO7PAN7PAA7PAM7PAE"@D@(" @(" @
XM=&\@='5R;B!A($)O;VQE86X@<&%R86UE=&5R(&]F9@H*(" @(" M="!?"'1?
XM"&%?"&<*"2 @161I="!T:&4@9FEL92!C;VYT86EN:6YG('1H92 @9&5F:6YI
XM=&EO;B @<W!E8VEF:65D("!A<PH)("!?"'1?"&%?"&<L(&%T('1H92!S=&%R
XM="!O9B!T:&4@9&5F:6YI=&EO;B H87,@<&5R('9I*2X*"B @(" @*U\(;E\(
XM=5\(;5\(8E\(95\(<@H)("!';R!T;R!T:&4@<W!E8VEF:65D("!L:6YE("!N
XM=6UB97(@(&]F("!T:&4@(&9I;&4@(&)E:6YG"@D@(&5D:71E9"X*"B @(" @
XM*R]?"'!?"&%?"'1?"'1?"&5?"')?"&X*"2 @1V\@=&\@=&AE(&9I<G-T(&]C
XM8W5R<F5N8V4@(&]F("!T:&4@('-P96-I9FEE9" @7PAP7PAA7PAT7PAT7PAE
XM7PAR7PAN"@D@('=I=&AI;B!T:&4@9FEL92!B96EN9R!E9&ET960N"@H@(" @
XM(%1H92 M<B!C;VUM86YD(&QI;F4@;W!T:6]N(&ES(&YO="!S=7!P;W)T960N
XM"@I%3DA!3D-%345.5%,*("!-=6QT:7!L92!B=69F97)S(&%N9"!W:6YD;W=S
XM"B @(" @02!?"&)?"'5?"&9?"&9?"&5?"'(@:7,@=&AE("!I;G1E<FYA;" @
XM;V)J96-T("!W:&EC:" @:&]L9',@(&$@(&9I;&4@(&EN"B @(" @;65M;W)Y
XM+" @=VAI;&4@82!?"'=?"&E?"&Y?"&1?"&]?"'<@:7,@86X@87)E82!O9B!T
XM:&4@<V-R965N('=H:6-H('-H;W=S"B @(" @<&%R="!O9B!A(&)U9F9E<BX@
XM($5V97)Y('=I;F1O=R!R969E<F5N8V5S(&$@8G5F9F5R+"!E=F5N(&EF"@H*
XM"E5N:7@@(" @(" @(" @(" @(" @($QA<W0@8VAA;F=E.B Q.2\V+S$Y.3(@
XM(" @(" @(" @(" @(" @(" @(" Q"@H*"@H*"EA622@Q*2 @(" @(" @(" @
XM(" @(" @("!54T52($-/34U!3D13(" @(" @(" @(" @(" @(" @(" @6%9)
XM*#$I"@H*"B @(" @;F\@(&9I;&4@(&ES("!B96EN9R @961I=&5D+B @(%1H
XM92 @9F]L;&]W:6YG("!C;VUM86YD<R @87)E"B @(" @879A:6QA8FQE(&9O
XM<B!O<&5R871I;F<@;VX@8G5F9F5R<R!A;F0@=VEN9&]W<SH*"B @(" @.F)U
XM9F9E<@H)("!C<F5A=&4@82!N97<@8G5F9F5R(&EN(&$@;F5W('=I;F1O=SL@
XM8V%N(&)E(&9O;&QO=V5D(&)Y"@D@(&$@9FEL96YA;64L('=H:6-H('=I;&P@
XM8F4@961I=&5D(&EN('1H92!N97<@8G5F9F5R+@H*(" @(" Z<W!L:70*"2 @
XM8W)E871E(&$@(&YE=R @=VEN9&]W("!O;B @=&\@('1H92 @8W5R<F5N=" @
XM8G5F9F5R("!B>0H)("!S<&QI='1I;F<@("!T:&4@("!C=7)R96YT("!W:6YD
XM;W<@(&EN("!H86QF+B @(%1H92 @='=O"@D@(')E<W5L=&EN9R!W:6YD;W=S
XM(&%R92!S:6UI;&%R("!T;R @7PAV7PAI7PAE7PAW7PAP7PAO7PAR7PAT7PAS
XM("!O;B @=&\@(&$*"2 @<VEN9VQE("!E9&ET:6YG("!B=69F97(L("!I;B @
XM=&AA=" @8VAA;F=E<R!M861E(&EN(&]N90H)("!W:6YD;W<@87)E(')E9FQE
XM8W1E9"!I;B!T:&4@;W1H97(@;VYE+@H*(" @(" Z8VQO<V4*"2 @8VQO<V4@
XM=&AE(&-U<G)E;G0@=VEN9&]W.R!W:6QL(&%L<V\@8VQO<V4@=&AE(&)U9F9E
XM<B!I9@H)("!T:&ES(&ES('1H92!L87-T('=I;F1O=R!O;B!T;R!I="X*"B @
XM(" @.G@@+R!:6@H)("!C;&]S92!O;FQY('1H92!C=7)R96YT('=I;F1O=RX@
XM($EF('1H92 @=VEN9&]W("!I<R @=&AE"@D@(&]N;'D@;VYE(&]N('1O('1H
XM92!B=69F97(L('1H92!B=69F97(@=VEL;"!B92!C;&]S960@87,*"2 @=V5L
XM;"P@=W)I=&EN9R!I="!F:7)S="!I9B!I="!I<R!M;V1I9FEE9"X*"B @(" @
XM9R @("!M;W9E('1O('1H92!N97AT('=I;F1O=RX*"B @(" @7E<@("!I;F-R
XM96%S92!T:&4@<VEZ92!O9B!T:&4@8W5R<F5N="!W:6YD;W<@*&UA>2!B92!G
XM:79E;B!A"@D@(&YU;65R:6,@<')E9FEX+"!D969A=6QT(&ES(&]N92!L:6YE
XM*2X*"B @(" @7E0@("!D96-R96%S92!T:&4@<VEZ92!O9B!T:&4@8W5R<F5N
XM="!W:6YD;W<@*&UA>2!B92!G:79E;B!A"@D@(&YU;65R:6,@<')E9FEX+"!D
XM969A=6QT(&ES(&]N92!L:6YE*2X*"B @(" @7D\@("!M86ME('1H92!C=7)R
XM96YT('=I;F1O=R!A<R!L87)G92!A<R!P;W-S:6)L92X*"B @(" @7ET@("!A
XM<R @9F]R("!V:2P@(&)U=" @8W)E871E("!A("!N97<@(&)U9F9E<B @('=I
XM;F1O=R @(&EF"@D@(&%P<')O<')I871E("AA;F0@:68@875T;W-P;&ET(&%L
XM;&]W<RDN"@H@(" @($YO=&4@=&AA="!T:&4@.G%U:70@8V]M;6%N9"!Q=6ET
XM<R!O=70@;V8@=&AE(&5D:71O<BP@;F]T(&]U= H@(" @(&]F("!A("!W:6YD
XM;W<N("!4:&4@.F-L;W-E(&-O;6UA;F0@:7,@=&AU<R!T:&4@97%U:79A;&5N
XM="!O9@H@(" @(#IQ=6ET(&9O<B!W:6YD;W=S+B @5&AE<F4@:7,@;F\@97%U
XM:79A;&5N="!O9B Z>"!O<B @6EH@(&9O<@H@(" @('1H92!W:&]L92!E9&ET
XM;W([('1H97-E(&AA=F4@8F5E;B!H:6IA8VME9"!F;W(@;W!E<F%T:6]N<R!O
XM;@H@(" @('=I;F1O=W,N"@H@(" @(%1H92!N=6UE<FEC(&%U=&]S<&QI="!P
XM87)A;65T97(@<W!E8VEF:65S('1H92!M87AI;75M(&YU;6)E<@H@(" @(&]F
XM(" @8G5F9F5R("!W:6YD;W=S("!T:&%T("!W:6QL("!B92 @8W)E871E9" @
XM875T;VUA=&EC86QL>0H@(" @('=H96YE=F5R('EO=2!E:71H97(@961I="!M
XM;W)E('1H86X@;VYE(&9I;&4L(&]R('5S92!T86=S("!T;PH@(" @(&5D:70@
XM82!D:69F97)E;G0@9FEL92X*"B @(" @56YD;R!W;W)K<R!P97(@8G5F9F5R
XM+"!A<R!D;R!M87)K<SL@>6%N:R]P=70@86YD(')E9&\@*'1H92 N"B @(" @
XM8V]M;6%N9"D@=V]R:R!O=F5R(&%L;"!B=69F97)S+"!I+F4N('EO=2!C86X@
XM9&5L971E(&9R;VT@;VYE"B @(" @8G5F9F5R(&%N9"!P=70@=&AE('1E>'0@
XM:6YT;R!A(&1I9F9E<F5N="!B=69F97(N"@H*"@H*56YI>" @(" @(" @(" @
XM(" @(" @3&%S="!C:&%N9V4Z(#$Y+S8O,3DY,B @(" @(" @(" @(" @(" @
XM(" @(#(*"@H*"@H*6%9)*#$I(" @(" @(" @(" @(" @(" @(%5315(@0T]-
XM34%.1%,@(" @(" @(" @(" @(" @(" @("!85DDH,2D*"@H*("!&:6QE('!R
XM97-E<G9A=&EO;@H@(" @(%)A=&AE<B!T:&%N('5S92!V:2=S(%5N:7@M<W!E
XM8VEF:6,@;65T:&]D(&9O<B @<')E<V5R=F%T:6]N+ H@(" @('AV:2 @9&]E
XM<R!P97)I;V1I8R!P<F5S97)V871I;VX@;V8@86QL(&9I;&5S(&-U<G)E;G1L
XM>2!B96EN9PH@(" @(&5D:71E9"!I;G1O('1E;7!O<F%R>2!F:6QE<R!I;B!T
XM:&4@<V%M92!D:7)E8W1O<GDN("!)="!T<FEE<PH@(" @('1O("!D;R!T:&ES
XM('=H96X@>6]U(&%R96XG="!T>7!I;F<L('-O('1H870@>6]U('=O;B=T(&YO
XM=&EC90H@(" @('1H92!S:&]R="!D96QA>2!W:&5N('1H92 @=&5M<&]R87)Y
XM("!F:6QE("!I<R @=W)I='1E;B @;W5T+@H@(" @($]B=FEO=7-L>2P@;VYL
XM>2!C:&%N9V5D(&9I;&5S(&%R92!P<F5S97)V960@:6X@=&AI<R!W87DL(&%N
XM9 H@(" @('1H92!T96UP;W)A<GD@9FEL92!I<R!R96UO=F5D(&]N8V4@=&AE
XM(')E86P@(&9I;&4@(&AA<R @8F5E;@H@(" @('-U8V-E<W-F=6QL>2!W<FET
XM=&5N+@H*(" X+6)I="!C:&%R86-T97(@<W5P<&]R= H@(" @($-H87)A8W1E
XM<G,@=VET:"!T:&4@=&]P(&)I="!S970@87)E(&%C8V5P=&5D(&)Y('AV:2P@
XM8G5T("!I= H@(" @(&ES("!N;W0@('EE=" @<&]S<VEB;&4@('1O("!H879E
XM(&YU;&P@*"=<,"<I(&)Y=&5S(&EN(&$@9FEL90H@(" @(&)U9F9E<BX@($AO
XM=R!C:&%R86-T97)S(&%R92!D:7-P;&%Y960@8V%N(&)E("!C;VYT<F]L;&5D
XM("!B>0H@(" @('1H92 @8V-H87)S("!A;F0@(&UC:&%R<R @<&%R86UE=&5R
XM<RP@('=H:6-H+" @:68@<V5T+"!C875S90H@(" @(&-O;G1R;VP@(&%N9" @
XM;65T82UC:&%R86-T97)S("!R97-P96-T:79E;'D@('1O("!B92 @(&]U='!U
XM= H@(" @('5N8VAA;F=E9#L@("!O=&AE<G=I<V4@("!T:&5Y("!A<F4@('-H
XM;W=N("!A<R @<V5Q=65N8V5S("!O9@H@(" @('!R:6YT86)L92!C:&%R86-T
XM97)S+@H*(" @("!486)S(&%R92!N;W)M86QL>2!D:7-P;&%Y960@87,@82!S
XM97)I97,@(&]F("!S<&%C97,@(&]F("!T:&4*(" @("!A<'!R;W!R:6%T92 @
XM;&5N9W1H(" H86-C;W)D:6YG("!T;R!T:&4@=&%B<W1O<',@<&%R86UE=&5R
XM*3L*(" @("!S971T:6YG(&QI<W0@;6]D92!W:6QL(&-A=7-E('1H96T@=&\@
XM8F4@9&ES<&QA>65D(&%S(&-O;G1R;VP*(" @("!C:&%R86-T97)S+" @87,@
XM('=I;&P@=6YS971T:6YG('1H92!T86)S('!A<F%M971E<BX@($AO=R!T:&4*
XM(" @("!T86(@8VAA<F%C=&5R(&ES(&1I<W!L87EE9"!I<R!T:&5N('5N9&5R
XM('1H92!C;VYT<F]L(&]F("!T:&4*(" @("!C8VAA<G,@<&%R86UE=&5R+@H*
XM(" @("!9;W4@8V%N('5S92!T:&4@7E\@*&-O;G1R;VPM=6YD97)S8V]R92D@
XM8V]M;6%N9"!T;R!F;&EP("!T:&4*(" @("!T;W @(&)I=" @;V8@('1H92 @
XM8VAA<F%C=&5R("!T:&4@8W5R<V]R(&ES(&]N+B @5&AI<R!M87D@8F4*(" @
XM("!U<V5F=6P@;VX@<WES=&5M<R!W:&5R92!I="!I<R!O=&AE<G=I<V4@:6UP
XM;W-S:6)L92!T;R @96YT97(*(" @(" X+6)I="!C:&%R86-T97)S+@H*("!&
XM:6QE(&9O<FUA=',*(" @("!8=FD@8V%N(')E860@86YD('=R:71E('1E>'0@
XM9FEL97,@:6X@;F]N+55N:7@@9F]R;6%T<RX@("!4:&4*(" @("!C=7)R96YT
XM(" @9F]R;6%T("!I<R @9VEV96X@(&)Y("!T:&4@('9A;'5E("!O9B @=&AE
XM("!F;W)M870*(" @("!P87)A;65T97(L('=H:6-H(&UA>2!B92!S970@=&\@
XM(G5N:7@B+" B;7-D;W,B+"!E=&,N("!4;R!S964*(" @("!A(&QI<W0@;V8@
XM879A:6QA8FQE(&9O<FUA=',L('1Y<&4*"@D@(#IS92!F;70]/PH*("!%>'1E
XM;F1E9"!R96=U;&%R(&5X<')E<W-I;VYS"B @(" @=FDG<R @;6%G:6,@('!A
XM<F%M971E<B @:7,@('-U<&5R<V5D960@(&)Y(" @=&AE(" @<F5G97AT>7!E
XM"B @(" @<&%R86UE=&5R+"!W:&EC:"!C86X@=&%K92!T:&4@9F]L;&]W:6YG
XM('9A;'5E<SH*"B @(" @=&%G<R!O;FQY(%X@86YD("0@87)E('-I9VYI9FEC
XM86YT("AU<V5D(&9O<B!T86=S*0H*(" @("!G<F5P(&QI:V4@9W)E<"@Q*2P@
XM8G5T('=I=&@@7#P@86YD(%P^(&%D9&5D"@H@(" @(&5G<F5P"@D@(&QI:V4@
XM96=R97 H,2DL(&)U="!W:71H(%P\(&%N9"!</B!A9&1E9 H*(" @("!4:&4@
XM9&5F875L="!I<R!G<F5P+@H*"@H*56YI>" @(" @(" @(" @(" @(" @3&%S
XM="!C:&%N9V4Z(#$Y+S8O,3DY,B @(" @(" @(" @(" @(" @(" @(#,*"@H*
XM"@H*6%9)*#$I(" @(" @(" @(" @(" @(" @(%5315(@0T]-34%.1%,@(" @
XM(" @(" @(" @(" @(" @("!85DDH,2D*"@H*(" @("!.;W1E('1H870@:70@
XM:7,@<W1I;&P@<&]S<VEB;&4@=&\@<V5T(&]R('5N<V5T(&UA9VEC("!A<R @
XM:6X*(" @("!V:3L@('1H:7,@('=I;&P@('-I;7!L>2 @<F5S=6QT("!I;B @
XM<F5G97AT>7!E("!B96EN9R!S970@87,*(" @("!A<'!R;W!R:6%T92X*"B @
XM(" @5&AE('-E8W1I;VYS(&%N9"!P87)A9W)A<&AS("!P87)A;65T97)S("!D
XM969I;F4@(&5G<F5P+7-T>6QE"B @(" @<&%T=&5R;G,@('1O("!S96%R8V@@
XM(&9O<BP@(')A=&AE<B!T:&%N('9I)W,@<VEM<&QI<W1I8R H86YD"B @(" @
XM=')O9F8M9&5P96YD96YT*2!C:&%R86-T97(@<&%I<G,N"@H@($EM<')O=F5D
XM(')E<&QA8V4@;6]D90H@(" @(%1H92!2(&-O;6UA;F0@86-T<R!M;W)E(&EN
XM=&5L;&EG96YT;'D@=VAE;B!Y;W4@<')E<W,@(')E='5R;@H@(" @("T@(&ET
XM("!L96%V97,@('1H92 @<F5S="!O9B!T:&4@8W5R<F5N="!L:6YE(&%L;VYE
XM+"!A;F0@:G5S= H@(" @('-T87)T<R!R97!L86-I;F<@=&5X="!O;B!T:&4@
XM(&YE>'0@(&QI;F4L("!S=&%R=&EN9R @870@('1H90H@(" @('-C<F5E;B!C
XM;VQU;6X@=VAE<F4@>6]U(&9I<G-T('1Y<&5D(%(N"@H@($-O;6UA;F0@<F4M
XM97AE8W5T:6]N"B @(" @07,@=V5L;"!A<R!T:&4@;F]R;6%L(&YA;65D(" H
XM8V]N:G5G871E*2 @8G5F9F5R<RP@(&%N9" @=&AE"B @(" @9&5F875L=" @
XM;VYE("AN86UE9"! *2P@=&AE<F4@97AI<W0@<V5V97)A;"!E>'1R82!O;F5S
XM(&YA;65D"B @(" @.BP@+RP@/R!A;F0@(2P@=VAI8V@@8V]N=&%I;B!T:&4@
XM;&%S="!C;VUM86YD(&QI;F5S('1Y<&5D('1O"B @(" @96%C:" @;V8@('1H
XM92 @9VEV96X@8V]M;6%N9',N("!3;R!F;W(@:6YS=&%N8V4L($ Z('=I;&P@
XM<F4M"B @(" @97AE8W5T92!T:&4@;&%S="!E>"!C;VUM86YD+"!O<B!Y;W4@
XM8V%N(&EN<V5R="!I="!I;G1O("!Y;W5R"B @(" @8G5F9F5R+"!E9&ET(&ET
XM(&%N9"!T:&5N(')E+65X96-U=&4@:70@*&4N9RX@=VET:"!D9$! *2X*"B @
XM2G5M<'-C<F]L; H@(" @(%=H96X@;75L=&EP;&4@=VEN9&]W<R!A<F4@=7-E
XM9"P@>'9I(&YO<FUA;&QY(&AA<R!T;R!B92 @86)L90H@(" @('1O("!S8W)O
XM;&P@(&EN9&EV:61U86P@('=I;F1O=W,@('=I=&AO=70@<V-R;VQL:6YG('1H
XM92!W:&]L90H@(" @('-C<F5E;BX@(%1H:7,@8V%N(&)E('9E<GD@:6YE9F9I
XM8VEE;G0@;VX@('1E<FUI;F%L<R @=VET:&]U= H@(" @('-C<F]L;&EN9R @
XM<F5G:6]N<RP@('-O('1H92!J=6UP<V-R;VQL('!A<F%M971E<B!I<R!P<F]V
XM:61E9 H@(" @('1O(&-O;G1R;VP@=&AE(&5D:71O<B=S('-C<F]L;&EN9R!B
XM96AA=FEO=7(N("!)="!C86X@8F4@('-E= H@(" @('1O(&]N92!O9CH*"B @
XM(" @;V9F("!7:&5N('1H92!C=7)S;W(@;6]V97,@;W5T<VED92 @82 @=VEN
XM9&]W)W,@(&)O=6YD87)I97,L"@D@(&%N9" @=&AE("!N97<@('!O<VET:6]N
XM(&ES(&YE87(@96YO=6=H+"!T:&4@=VEN9&]W('=I;&P*"2 @<V-R;VQL('1O
XM('1H92!N97<@<&]S:71I;VXN"@H@(" @(&]N(" @5VAE;B!T:&4@8W5R<V]R
XM(&UO=F5S(&]U='-I9&4@(&$@('=I;F1O=R=S("!B;W5N9&%R:65S+ H)("!T
XM:&4@=VEN9&]W('=I;&P@86QW87ES(&IU;7 @=&\@=&AE(&YE=R!P;W-I=&EO
XM;BX*"B @(" @875T;R!!('=I;F1O=R!W:6QL('-C<F]L;"!O;FQY(&EF(&ET
XM(&-A;B!D;R!S;R @969F:6-I96YT;'D["@D@(&]T:&5R=VES92!I="!W:6QL
XM(&IU;7 N"@H@(" @(%1H92!D969A=6QT('9A;'5E(&ES(&%U=&\N"@H@(" @
XM($]N("!)4T$M='EP92 @<WES=&5M<R @=VAI8V@@(&AA=F4@(&UE;6]R>2UM
XM87!P960@(&1I<W!L87ES+ H@(" @(&AA<F1W87)E(" @(&-H87)A8W1E<B @
XM(&=E;F5R871O<G,@("!A;F0@("!R96%S;VYA8FQY(" @9F%S= H@(" @('!R
XM;V-E<W-O<G,L(&IU;7!S8W)O;&P@('-H;W5L9" @9V5N97)A;&QY("!B92 @
XM<V5T("!T;R @;V9F.PH@(" @(&AO=V5V97(L("!O;B!,0T0@<V-R965N<R!O
XM<B!O=&AE<B!D:7-P;&%Y<R!W:71H(&$@;&]N9R!I;6%G90H@(" @('!E<G-I
XM<W1E;F-E+"!T:&ES(&UA>2!A8W1U86QL>2!M86ME('1H92!T97AT(&UO<F4@
XM(&1I9F9I8W5L= H@(" @('1O("!R96%D+" @86YD("!M86YY("!U<V5R<R @
XM;6%Y(&)E(&UO<F4@8V]M9F]R=&%B;&4@=VET:"!I= H@(" @('1U<FYE9"!O
XM;BX*"B @(" @17AP;&EC:70@<V-R;VQL(&-O;6UA;F1S("AE+F<N("!>1"!A
XM;F0@7D4I(&%R92!N;W0@(&%F9F5C=&5D"B @(" @8GD@=&AE(&IU;7!S8W)O
XM;&P@<&%R86UE=&5R+@H*"@I5;FEX(" @(" @(" @(" @(" @("!,87-T(&-H
XM86YG93H@,3DO-B\Q.3DR(" @(" @(" @(" @(" @(" @(" @- H*"@H*"@I8
XM5DDH,2D@(" @(" @(" @(" @(" @(" @55-%4B!#3TU-04Y$4R @(" @(" @
XM(" @(" @(" @(" @(%A622@Q*0H*"@H@($-O;&]U<@H@(" @(%1H97)E(&%R
XM92!F;W5R(&YE=R!P87)A;65T97)S('1O(&-O;G1R;VP@<V-R965N(&-O;&]U
XM<G,Z"@H@(" @(&-O;&]U<B @(" @(&-O;&]U<B!U<V5D(&9O<B!T97AT"@H@
XM(" @('-T871U<V-O;&]U<F-O;&]U<B!U<V5D(&9O<B!S=&%T=7,@;&EN97,*
XM"B @(" @<F]S8V]L;W5R(" @87,@<W1A='5S8V]L;W5R+"!B=70@9F]R(')E
XM861O;FQY(&9I;&5S"@H@(" @('-Y<W1E;6-O;&]U<F-O;&]U<B!U<V5D(&9O
XM<B!S>7-T96T@;6]D92 H:2YE+B!S=6)S:&5L;',@(&%N9 H@(" @(&%F=&5R
XM('1E<FUI;F%T:6]N*0H*(" @("!4:&5S92!P87)A;65T97)S(&%R92!N=6UE
XM<FEC+"!A;F0@=&AE('9A;'5E(&UE86YS("!D:69F97)E;G0*(" @("!T:&EN
XM9W,@(&]N("!D:69F97)E;G0@(&]P97)A=&EN9R!S>7-T96US+B @3VX@56YI
XM>"P@:70@:7,@86X*(" @("!I;F1E>"!I;G1O('1H92!T97)M8V%P*#4I(&5N
XM=')I97,@(F,P(B!T;R @(F,Y(BP@('=H:6-H("!A<F4*(" @("!A<W-U;65D
XM("!T;R @8F4@(&-O;&]U<BUS971T:6YG(&5S8V%P92!S97%U96YC97,@:68@
XM=&AE>2!A<F4*(" @("!P<F5S96YT+B @268@=&AE>2!A<F4@(&YO=" @<')E
XM<V5N="P@(")S;R(@("AB96=I;B @<W1A;F1O=70*(" @("!M;V1E*2!A;F0@
XM(G-E(B H96YD('-T86YD;W5T(&UO9&4I(&%R92!U<V5D(&EN<W1E860N("!6
XM86QU97,*(" @("!O9B P(&%N9" Q(&=I=F4@(&YO<FUA;" @=&5X="P@('=H
XM97)E87,@(#(@(&%N9" @86)O=F4@(&=I=F4*(" @("!S=&%N9&]U="!M;V1E
XM+@H*(" @("!4:&4@(&1E9F%U;'0@(&-O;&]U<B @9F]R("!T:&4@(')O<V-O
XM;&]U<B @('!A<F%M971E<B @('=I;&P*(" @("!G96YE<F%L;'D@(&EN=F]L
XM=F4@(')E9" @:68@(&-O;&]U<G,@(&%R92!A=F%I;&%B;&4[('1H:7,@:7,*
XM(" @("!I;G1E;F1E9"!T;R!P<F]V:61E(&$@=V%R;FEN9R!T;R!T:&4@=7-E
XM<B!T:&%T("!W<FET:6YG("!T:&4*(" @("!F:6QE(&UA>2!N;W0@8F4@<&]S
XM<VEB;&4N"@H@($]N+6QI;F4@:&5L< H@(" @($$@<')I;6ET:79E(&AE;' @
XM9F%C:6QI='D@:7,@879A:6QA8FQE.R @=&AE(" Z:&5L<" @8V]M;6%N9 H@
XM(" @('-I;7!L>2 @8W)E871E<R @82 @;F5W("!B=69F97(@=VEN9&]W(&]N
XM('1O(&$@<W1A;F1A<F0@:&5L< H@(" @(&9I;&4N("!4:&4@;F%M92!O9B!T
XM:&4@9FEL92!W:&EC:"!I<R!E9&ET960@:7,@9VEV96X@8GD@('1H90H@(" @
XM(&AE;'!F:6QE("!S=')I;F<@('!A<F%M971E<CL@=&AE(&1E9F%U;'0@;VX@
XM56YI>"!V97)S:6]N<R!I<PH@(" @("(O=7-R+VQI8B]X=FDN:&5L<"(N("!.
XM;W1E('1H870@=&AE(&AE;' @9FEL92!B=69F97(@=VEL;"!B90H@(" @(&UA
XM<FME9" @(FYO=" @961I=&%B;&4B("!W:&5N("!I="!I<R!C<F5A=&5D+"!W
XM:&EC:"!P<F5V96YT<PH@(" @(&%C8VED96YT86P@;W9E<G=R:71I;F<@;V8@
XM=&AE(&AE;' @9FEL92!E=F5N('=H96X@('1H92 @9FEL90H@(" @('!E<FUI
XM<W-I;VYS('=O=6QD(&%L;&]W(&ET+@H*("!-:7-C96QL86YE;W5S"B @(" @
XM5&AE(&-O;6UA;F0@.G=N("AW<FET92!F:6QE(&%N9"!E9&ET(&YE>'0I(&ES
XM("!P<F]V:61E9"P@(&%S"B @(" @:6X@4$,M=FDN"@H@(" @(%1H92!N97<@
XM961I="!P87)A;65T97(@8V]N=')O;',@('=H971H97(@(&$@(&)U9F9E<B @
XM8V%N("!B90H@(" @(&UO9&EF:65D+B @(%1H:7,@;6%Y(&)E('5S960@=&\@
XM:6UP;&5M96YT(&$@;FEC97(@=F5R<VEO;B!O9@H@(" @('9I97<H,2D@=&AA
XM;B!T:&4@<W1A;F1A<F0@=FD@=F5R<VEO;BP@<VEN8V4@(&ET("!W;VXG=" @
XM9F]O; H@(" @('EO=2 @:6YT;R @=&AI;FMI;F<@('1H870@(&5D:71I;F<@
XM('1H92!B=69F97(@:7,@:6X@86YY('=A>0H@(" @('-A9F4N("!"92!W87)N
XM960Z(&]N8V4@:&%V:6YG('-E="!N;V5D:70L(&ET(&ES(&YO="!P;W-S:6)L
XM90H@(" @('1O(&1O(&$@.G-E="!E9&ET(&%N>2!M;W)E+B @270G<R!A(&]N
XM92UW87D@<W1R965T+@H*(" @("!);B!I;G-E<G0@86YD(')E<&QA8V4@;6]D
XM97,L(%Y!(&AA<R!T:&4@<V%M92!M96%N:6YG("!A<R @7D *(" @("!I;B @
XM=FDL("!E>&-E<'0@('1H870@:70@=V]R:W,@870@86YY('1I;64L(&YO="!J
XM=7-T(&9O<B!T:&4*(" @("!F:7)S="!C:&%R86-T97(N("!!;'-O+"!T>7!I
XM;F<@7D)?"'@@=VAE<F4@7PAX(&ES('1H92!N86UE(&]F("!A"B @(" @8V]N
XM:G5G871E("!B=69F97(L("!I;G-E<G1S('1H92!C;VYT96YT<R!O9B!T:&%T
XM(&)U9F9E<B!I;G1O"B @(" @=&AE(&EN<'5T('-T<F5A;2!A="!T:&%T('!O
XM:6YT+B @5&AE(&)U9F9E<B!N86UE9" @/" @86QW87ES"@H*"E5N:7@@(" @
XM(" @(" @(" @(" @($QA<W0@8VAA;F=E.B Q.2\V+S$Y.3(@(" @(" @(" @
XM(" @(" @(" @(" U"@H*"@H*"EA622@Q*2 @(" @(" @(" @(" @(" @("!5
XM4T52($-/34U!3D13(" @(" @(" @(" @(" @(" @(" @6%9)*#$I"@H*"B @
XM(" @8V]N=&%I;G,@=&AE(&QA<W0@=&AI;F<@:6YS97)T960L('-O('1H870@
XM7D(\(&ES('1H92!S86UE(&%S"B @(" @7D$N"@I,24U)5$%424].4PH@($5X
XM(&UO9&4*(" @("!4:&4@;6%I;B!A<F5A(&EN('=H:6-H('AV:2!I<R!L86-K
XM:6YG(&ES('9I)W,@97@@;6]D92P@=VAI8V@*(" @("!I<R @;F]T(&EM<&QE
XM;65N=&5D(&%T(&%L;" H86YD(&YE:71H97(@87)E(&5D:70L(&4L(&]R(&]P
XM96X*(" @("!M;V1E<RDN("!(;W=E=F5R+"!M86YY(&]F('1H92!E>"!C;VUM
XM86YD<R!A<F4@(&%V86EL86)L92 @:6X*(" @("!V:2 @;6]D92!A<R!C;VQO
XM;B!C;VUM86YD<SL@=&AE(&-O;&]N(&-O;6UA;F1S('1H870@:&%V92!N;W0*
XM(" @("!B965N(&EM<&QE;65N=&5D(&%R92 @;6]S=&QY("!T:&]S92 @=VAI
XM8V@@(&]F9F5R("!T:&4@('-A;64*(" @("!F=6YC=&EO;F%L:71Y(&%S(&]T
XM:&5R(&-O;6UA;F1S(&EN('9I(&UO9&4N"@H@(" @($EN('!A<G1I8W5L87(L
XM(&%B8G)E=FEA=&4L(&%P<&5N9"P@8VAA;F=E+"!E>"P@:6YS97)T+"!J;VEN
XM+ H@(" @(&]P96XL(')E8V]V97(L('5N86)B<F5V:6%T92P@=6YD;RP@=W)I
XM=&4^/BP@>B!A;F0@?"!H879E(&YO= H@(" @(&)E96X@:6UP;&5M96YT960@
XM87,@8V]L;VX@8V]M;6%N9',@>65T+@H*("!6:2!M;V1E"B @(" @26X@=FD@
XM;6]D92P@=&AE("!5("!A;F0@(#T@(&-O;6UA;F1S("!A<F4@(&YO=" @:6UP
XM;&5M96YT960L"B @(" @86QT:&]U9V@@('1H97)E("!I<R @;F\@(')E86P@
XM(')E87-O;B!W:'D@=&AE>2!S:&]U;&1N)W0@8F4L"B @(" @=VAI;'-T(%$@
XM:7,@:6YA<'!R;W!R:6%T92!I;B!T:&4@8V]N=&5X="!O9B!X=FDL('-I;F-E
XM('1H97)E"B @(" @:7,@;F\@97@@;6]D92X*"B @4&%R86UE=&5R<PH@(" @
XM($UA;GD@;V8@=FDG<R @<&%R86UE=&5R<R @:&%V92 @;F]T("!B965N("!I
XM;7!L96UE;G1E9#L@('1H90H@(" @(&-O;6UA;F0@(#IS92!A;&P@9VEV97,@
XM82!C;VUP;&5T92!L:7-T+"!W:71H(&-U<G)E;G0@=F%L=65S+ H@(" @(&]F
XM('1H;W-E('1H870@:&%V92!B965N+@H*("!-:7-C96QL86YE;W5S"B @(" @
XM4F5P96%T(&-O=6YT<R!B969O<F4@:6YS97)T:6]N<R!D;VXG="!W;W)K+@H*
XM(" @("!!<'!E;F1I;F<@=&\@;F%M960@8G5F9F5R<R!I<R!N;W0@>65T(&EM
XM<&QE;65N=&5D+@H*(" @("!4>7!I;F<@7E$@:6X@:6YP=70@;6]D92!D;V5S
XM(&YO="!M96%N('1H92 @<V%M92 @87,@(%Y6.R @:70*(" @("!J=7-T("!I
XM;G-E<G1S("!A(&!>42<L(&%S<W5M:6YG(&ET(&=E=',@87,@9F%R(&%S('1H
XM92!E9&ET;W(*(" @("!A="!A;&PN"@H@(" @(%1Y<&EN9R!>5R!I;B!I;G-E
XM<G0@;6]D92!D;V5S(&YO="!B86-K('5P(&]N92!W;W)D(&%S(&EN('9I+@H*
XM(" @("!)="!I<R!N;W0@<&]S<VEB;&4@=&\@(&EN=&5R<G5P=" @=&AE("!E
XM9&ET;W(@('=H:6QE("!I=" @:7,*(" @("!P97)F;W)M:6YG("!C97)T86EN
XM("!O<&5R871I;VYS+B @($EF("!Y;W4@('-T87)T("!O9F8@82!B:6<*(" @
XM("!G;&]B86P@8V]M;6%N9"P@>6]U(&AA=F4@=&\@=V%I="!F;W(@:70@=&\@
XM9FEN:7-H+@H*(" @("!&;&%G<R!A;F0@8V]U;G1S(&%F=&5R(&5X(&UO9&4@
XM8V]M;6%N9',@87)E(&YO="!S=7!P;W)T960N"@H@(" @($ET(&ES(&YO="!P
XM;W-S:6)L92!T;R!R96%D('1H92!O=71P=70@;V8@(&$@('-Y<W1E;2 @8V]M
XM;6%N9 H@(" @('5S:6YG"@H)(" Z<B A7PAC7PAO7PAM7PAM7PAA7PAN7PAD
XM"@H@(" @(&]R('1O('=R:71E(&EN=&\@82!C;VUM86YD('5S:6YG"@H)(" Z
XM=R A7PAC7PAO7PAM7PAM7PAA7PAN7PAD+@H*"@I5;FEX(" @(" @(" @(" @
XM(" @("!,87-T(&-H86YG93H@,3DO-B\Q.3DR(" @(" @(" @(" @(" @(" @
XM(" @-@H*"@H*"@I85DDH,2D@(" @(" @(" @(" @(" @(" @55-%4B!#3TU-
XM04Y$4R @(" @(" @(" @(" @(" @(" @(%A622@Q*0H*"@H@(" @(%)E9W5L
XM87(@97AP<F5S<VEO;G,L(&%L=&AO=6=H(&EM<&QE;65N=&5D(" H<V5E("!A
XM8F]V92DL("!D;PH@(" @(&YO=" @<W5P<&]R="!T:&4@?B!M971A8VAA<F%C
XM=&5R.R!A;'-O+"!T:&4@7'4@86YD(%QL(&5S8V%P90H@(" @('-E<75E;F-E
XM<R @87)E("!N;W0@('-U<'!O<G1E9" @:6X@('-U8G-T:71U=&4@("!R97!L
XM86-E;65N= H@(" @('!A='1E<FYS+B @($YE=VQI;F5S("!I;F-L=61E9" @
XM;VX@('1H92!R:6=H="!H86YD('-I9&4@;V8@80H@(" @('-U8G-T:71U=&EO
XM;B!D;R!N;W0@8W5R<F5N=&QY(&-A=7-E('1H92!L:6YE("!T;R @8F4@('-P
XM;&ET.PH@(" @('1H92!N97=L:6YE(&-H87)A8W1E<B!I<R!L:71E<F%L;'D@
XM:6YS97)T960@:6YT;R!T:&4@;&EN92X*"B @(" @5&AE(#IG;&]B86P@8V]M
XM;6%N9"!O;FQY('-U<'!O<G1S('1H92!C;VUM86YD<R!;;'!S)GYD72X*"D]4
XM2$52($1)1D9%4D5.0T53($923TT@5DD*(" @("!4:&4@6%9)3DE4(&5N=FER
XM;VYM96YT('9A<FEA8FQE(&ES(')E860@:6YS=&5A9" @;V8@($5824Y)5"X*
XM(" @("!7:&EL<W0@;F\@9FEL97,@87)E('-O=7)C960@875T;VUA=&EC86QL
XM>2P@=7-E<G,@=VAO('=I<V@@=&\*(" @("!H879E(&$@<W1A<G1U<"!F:6QE
XM(&-A;B!A<G)A;F=E(&ET('9E<GD@(&5A<VEL>2X@("!S:"@Q*2 @;W(*(" @
XM("!K<V@H,2D@=7-E<G,@<VAO=6QD(&%D9"!T:&ES(&QI;F4@=&\@=&AE:7(@
XM)$A/344O+G!R;V9I;&4Z"@H)("!85DE.250])W-O=7)C92!?"'A?"'9?"&DM
XM7PAS7PAT7PAA7PAR7PAT7PAU7PAP+5\(9E\(:5\(;%\(92<[(&5X<&]R="!8
XM5DE.250*"B @(" @8W-H*#$I('5S97)S('-H;W5L9"!A9&0@=&AI<R!T;R!T
XM:&5I<B D2$]-12\N;&]G:6XZ"@H)("!S971E;G8@6%9)3DE4("=S;W5R8V4@
XM7PAX7PAV7PAI+5\(<U\(=%\(85\(<E\(=%\(=5\(<"U?"&9?"&E?"&Q?"&4G
XM"@H@(" @(%1H92!T86=S('!A<F%M971E<B!C86X@8F4@('5S960@('1O("!S
XM<&5C:69Y("!M=6QT:7!L92 @=&%G<PH@(" @(&9I;&5S.R @=&AE<V4@(&-A
XM;B @8F4@<V5P87)A=&5D(&)Y(&5I=&AE<B!@8%P@)R<@*&)A8VMS;&%S: H@
XM(" @('-P86-E*2!O<B!@8"PG)R H8V]M;6$I+@H*(" @("!!;'1E<FYA=&4@
XM9FEL97,@87)E(&AA;F1L960@<VQI9VAT;'D@9&EF9F5R96YT;'DL("!O=VEN
XM9R @=&\*(" @("!T:&4@('!R97-E;F-E("!O9B @8G5F9F5R(&%N9"!W:6YD
XM;W<@:&%N9&QI;F<N("!%<W-E;G1I86QL>2P*(" @("!W:&5N('EO=2!C;&]S
XM92!A(&)U9F9E<BP@:71S(&9I;&5N86UE(&ES(')E;65M8F5R960@(&%S("!T
XM:&4*(" @("!A;'1E<FYA=&4@(&9I;&4[("!W:&5N("!Y;W4@(&EN=F]K92!T
XM:&4@7EX@;W(@.F4@(R!C;VUM86YD<RP*(" @("!T:&ES(&9I;&4@:7,@<F4M
XM961I=&5D+B @3F]T92!T:&%T(%Y>("!E9&ET<R @=&AE("!A;'1E<FYA=&4*
XM(" @("!F:6QE(&EN(&$@;F5W(&)U9F9E<B!W:6YD;W<L(&EF(&%U=&]S<&QI
XM="!A;&QO=W,N"@H@(" @($AI='1I;F<@=&AE(&5S8V%P92!K97D@=VAI;&4@
XM:6X@=&AE(&-O;6UA;F0@(&QI;F4@(&1O97,@(&YO= H@(" @('1E<FUI;F%T
XM92 @:6YP=70[("!I;G-T96%D+" @:70@8V%N8V5L<R!I;G!U="P@<F5T=7)N
XM:6YG('1H90H@(" @('!R;VUP="!T;R!T:&4@8F5G:6YN:6YG(&]F('1H92!L
XM:6YE+B @5&AI<R!A<'!L:65S('1O("!I;G!U= H@(" @(&9O<B Z+" O+" _
XM(&%N9" A+@H*1DE,15,*(" @(" O=7-R+VQI8B]X=FDN:&5L<$1E9F%U;'0@
XM:&5L<"!F:6QE+@H*4T5%($%,4T\*(" @("!E>"@Q*2P@=FDH,2DL('1E<FUC
XM87 H-2DN"B @(" @7PA37PAU7PAM7PAM7PAA7PAR7PAY(%\(;U\(9B!?"$1?
XM"&E?"&9?"&9?"&5?"')?"&5?"&Y?"&-?"&5?"',@7PAB7PAE7PAT7PAW7PAE
XM7PAE7PAN(%\(5E\(:2!?"&%?"&Y?"&0@7PA87PAV7PAI+@H*0E5'4PH@(" @
XM(&\(*R @("!7:&5N('1H92!C=7)S;W(@:7,@;VX@=&AE(&QA<W0@=V]R9"!O
XM9B @82 @8G5F9F5R+" @=&AE"@D@(&-O;6UA;F0@(&1W("!L96%V97,@('1H
XM92 @;&%S=" @8VAA<F%C=&5R("!O9B @=&AE('=O<F0*"2 @=6YD96QE=&5D
XM+@H*(" @("!O""L@(" @4V]M92!S8W)E96X@=7!D871E<R!D;R @;F]T("!G
XM970@('-H;W=N("!P<F]P97)L>2 @=VAE;@H)("!B=69F97)S("!A<F4@('-P
XM;&ET+"!A;F0@8V5R=&%I;B!C;VUM86YD<R H92YG+B @>"D@87)E"@D@(&5X
XM96-U=&5D+@H*"@I5;FEX(" @(" @(" @(" @(" @("!,87-T(&-H86YG93H@
XM,3DO-B\Q.3DR(" @(" @(" @(" @(" @(" @(" @-PH*"@H*"@I85DDH,2D@
XM(" @(" @(" @(" @(" @(" @55-%4B!#3TU-04Y$4R @(" @(" @(" @(" @
XM(" @(" @(%A622@Q*0H*"@H@(" @(&\(*R @("!)9B!Y;W4@9&\@<V]M971H
XM:6YG(&QI:V4@8V8N5T]21#Q?"&5?"'-?"&,^(&%N9"!T:&5N(')E9&\@:70L
XM"@D@(&%N9" @=&AE("!F+B @9F%I;',L("!T:&5N("!T:&4@5T]21#Q?"&5?
XM"'-?"&,^(&=E=',@=&%K96X@87,*"2 @;F]R;6%L(&EN<'5T+B @5&AE(')E
XM<W0@;V8@=&AE(&EN<'5T('-H;W5L9" @<F5A;&QY("!B90H)("!C86YC96QL
XM960@=VAE;B!P87)T(&]F(&$@<F5D;R!F86EL<RX*"B @(" @;P@K(" @($$@
XM8V]M;6%N9"!O9B!T:&4@9F]R;2 Z+W!A="\[*S%M+B!W:6QL(&YO="!W;W)K
XM(&)E8V%U<V4*"2 @=&AE("!E9&ET;W(@(&EN8V]R<F5C=&QY("!D971E8W1S
XM("!A("!C;VYF;&EC=" @8F5T=V5E;@H)("!S;W5R8V4@86YD(&1E<W1I;F%T
XM:6]N+@H*(" @("!O""L@(" @5&AE(&5D:71O<B!I;B!I=',@<')E<V5N="!F
XM;W)M(&ES('9E<GD@(&EN969F:6-I96YT("!I;@H)("!T97)M<R!O9B!#4%4@
XM8WEC;&5S+@H*(" @("!O""L@(" @36]S="!T97)M8V%P*#4I('1E<FUI;F%L
XM(&1E<V-R:7!T:6]N<R!A<F4@(&]N;'D@('1E<W1E9 H)("!W:71H("!V:2@Q
XM*2 @*&%N9"!P;W-S:6)L>2!R;V=U92@V*2DN("!3:6YC92!X=FD@:7,L(&EN
XM"@D@('-O;64@=V%Y<RP@;6]R92!D96UA;F1I;F<@=&AA;B!V:2!I;B!I=',@
XM=7-E(&]F('1E<FUC87 *"2 @8V%P86)I;&ET:65S+"!I="!S;VUE=&EM97,@
XM97AP;W-E<R!B=6=S(&]R(&EN861E<75A8VEE<PH)("!I;B @=&5R;6-A<" @
XM96YT<FEE<RX@("!4:&ES("!A<'!L:65S(" @97-P96-I86QL>2 @('1O"@D@
XM('-C<F]L;&EN9R!R96=I;VYS+@H*059!24Q!0DE,2519"B @(" @6'9I(&AA
XM<R!B965N('!O<G1E9"!T;R!-4RU$3U,L($]3+S(L(%%.6"!A;F0@;6%N>2 @
XM9&EF9F5R96YT"B @(" @=F5R<VEO;G,@(&]F("!5;FEX+B @(%-O=7)C92 @
XM8V]D92 @:7,@(&%V86EL86)L92 @9G)O;2 @=&AE"B @(" @875T:&]R<RX*
XM"D%55$A/4E,*(" @("!#:')I<R!A;F0@2F]H;B!$;W=N97DN"@H@(" @($1E
XM<FEV960@9G)O;2 @4U1%5DE%+" @=W)I='1E;B @8GD@(%1I;2 @5&AO;7!S
XM;VX@(&%N9" @5&]N>0H@(" @($%N9')E=W,N"@H*"@H*"@H*"@H*"@H*"@H*
XM"@H*"@H*"@H*56YI>" @(" @(" @(" @(" @(" @3&%S="!C:&%N9V4Z(#$Y
XA+S8O,3DY,B @(" @(" @(" @(" @(" @(" @(#@*"@H*
X 
Xend
END_OF_FILE
  if test 23204 -ne `wc -c <'xvi/doc/xvi.lst.UU'`; then
    echo shar: \"'xvi/doc/xvi.lst.UU'\" unpacked with wrong size!
  else
    echo shar: Uudecoding \"'xvi/doc/xvi.lst'\" \(16818 characters\)
    cat 'xvi/doc/xvi.lst.UU' | uudecode
    if test -f 'xvi/doc/xvi.lst' ; then
      if test 16818 -ne `wc -c <'xvi/doc/xvi.lst'`; then
        echo shar: \"'xvi/doc/xvi.lst'\" uudecoded with wrong size!
      else
        rm 'xvi/doc/xvi.lst.UU'
      fi 
    else
      echo shar: \"'xvi/doc/xvi.lst'\" uudecode failed!
    fi
  fi
  # end of 'xvi/doc/xvi.lst.UU'
fi
if test -f 'xvi/src/makefile.aix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xvi/src/makefile.aix'\"
else
  echo shar: Extracting \"'xvi/src/makefile.aix'\" \(1993 characters\)
  sed "s/^X//" >'xvi/src/makefile.aix' <<'END_OF_FILE'
X# Copyright (c) 1990,1991,1992 Chris and John Downey
X#***
X#
X# @(#)makefile.aix	2.2 (Chris & John Downey) 7/31/92
X#
X# program name:
X#	xvi
X# function:
X#	PD version of UNIX "vi" editor, with extensions.
X# module name:
X#	makefile.aix
X# module function:
X#	Makefile for AIX (IBM's SysV-compatible UNIX).
X# history:
X#	STEVIE - ST Editor for VI Enthusiasts, Version 3.10
X#	Originally by Tim Thompson (twitch!tjt)
X#	Extensive modifications by Tony Andrews (onecom!wldrdg!tony)
X#	Heavily modified by Chris & John Downey
X#***
X
XSYSDEFS=	-DUNIX -DAIX -DTERMIO
XINCDIRS=
X
XLIBS=		-lcurses
XLDFLAGS=
X
X# Don't use -O flag here because on the RT/PC (on which
X# this version was developed) compilation takes 4 times as
X# long if you use it (8 lines per second rather than 33).
XCFLAGS=		$(SYSDEFS) $(INCDIRS)
XLINTFLAGS=	$(SYSDEFS) $(INCDIRS) -ah
X
XMACHSRC=	unix.c termcap.c defscr.c
XMACHOBJ=	unix.o termcap.o defscr.o
XMACHINC=	unix.h termcap.h
X
XGENINC=		ascii.h param.h ptrfunc.h regexp.h regmagic.h xvi.h virtscr.h
X
XGENSRC=		alloc.c ascii.c buffers.c cmdline.c cursor.c \
X		edit.c ex_cmds1.c ex_cmds2.c events.c fileio.c \
X		find.c flexbuf.c map.c mark.c misccmds.c movement.c \
X		normal.c param.c pipe.c preserve.c ptrfunc.c \
X		regexp.c screen.c search.c signal.c startup.c status.c \
X		tags.c undo.c version.c windows.c yankput.c
X
XGENOBJ=		alloc.o ascii.o buffers.o cmdline.o cursor.o \
X		edit.o ex_cmds1.o ex_cmds2.o events.o fileio.o \
X		find.o flexbuf.o map.o mark.o misccmds.o movement.o \
X		normal.o param.o pipe.o preserve.o ptrfunc.o \
X		regexp.o screen.o search.o signal.o startup.o status.o \
X		tags.o undo.o version.o windows.o yankput.o
X
Xall:		xvi
X
Xxvi:		$(GENOBJ) $(MACHOBJ)
X		$(CC) $(CFLAGS) -o xvi $(GENOBJ) $(MACHOBJ) $(LIBS)
X
X.c.o:		$< $(GENINC) $(MACHINC) param.c
X		$(CC) $(CFLAGS) -c -o $@ $<
X
Xlint:
X		lint $(LINTFLAGS) $(GENSRC) $(MACHSRC)
X
Xtags:		$(GENSRC) $(MACHSRC)
X		ctags -t $(GENSRC) $(MACHSRC) $(GENINC) $(MACHINC)
X
Xclean:
X		rm $(GENOBJ) $(MACHOBJ) xvi
X
X$(GENOBJ):	$(GENINC) $(MACHINC)
END_OF_FILE
  if test 1993 -ne `wc -c <'xvi/src/makefile.aix'`; then
    echo shar: \"'xvi/src/makefile.aix'\" unpacked with wrong size!
  fi
  # end of 'xvi/src/makefile.aix'
fi
if test -f 'xvi/src/search.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xvi/src/search.c'\"
else
  echo shar: Extracting \"'xvi/src/search.c'\" \(27204 characters\)
  sed "s/^X//" >'xvi/src/search.c' <<'END_OF_FILE'
X/* Copyright (c) 1990,1991,1992 Chris and John Downey */
X#ifndef lint
Xstatic char *sccsid = "@(#)search.c	2.1 (Chris & John Downey) 7/29/92";
X#endif
X
X/***
X
X* program name:
X    xvi
X* function:
X    PD version of UNIX "vi" editor, with extensions.
X* module name:
X    search.c
X* module function:
X    Regular expression searching, including global command.
X* history:
X    STEVIE - ST Editor for VI Enthusiasts, Version 3.10
X    Originally by Tim Thompson (twitch!tjt)
X    Extensive modifications by Tony Andrews (onecom!wldrdg!tony)
X    Heavily modified by Chris & John Downey
X
X***/
X
X#include "xvi.h"
X#include "regexp.h"	/* Henry Spencer's regular expression routines */
X#include "regmagic.h"	/* Henry Spencer's regular expression routines */
X
X#ifdef	MEGAMAX
Xoverlay "search"
X#endif
X
X/*
X * String searches
X *
X * The actual searches are done using Henry Spencer's regular expression
X * library.
X */
X
X/*
X * Names of values for the P_regextype enumerated parameter.
X */
Xchar	*rt_strings[] =
X{
X    "tags",
X    "grep",
X    "egrep",
X    NULL
X};
X
X/*
X * Used by g/re/p to remember where we are and what we are doing.
X */
Xstatic	Line	*curline;
Xstatic	Line	*lastline;
Xstatic	long	curnum;
Xstatic	bool_t	greptype;
X
Xstatic	Posn	*bcksearch P((Xviwin *, Line *, int, bool_t));
Xstatic	Posn	*fwdsearch P((Xviwin *, Line *, int, bool_t));
Xstatic	char	*mapstring P((char **, int));
Xstatic	char	*compile P((char *, int, bool_t));
Xstatic	char	*grep_line P((void));
Xstatic	long	substitute P((Xviwin *, Line *, Line *, char *, char *));
X
X/*
X * Convert a regular expression to egrep syntax: the source string can
X * be either tags compatible (only ^ and $ are significant), vi
X * compatible or egrep compatible (but also using \< and \>)
X *
X * Our first parameter here is the address of a pointer, which we
X * point to the closing delimiter character if we found one, otherwise
X * the closing '\0'.
X */
Xstatic char *
Xmapstring(sp, delim)
Xchar	**sp;		/* pointer to pointer to pattern string */
Xint	delim;		/* delimiter character */
X{
X    static Flexbuf	ns;
X    int			rxtype;	/* can be rt_TAGS, rt_GREP or rt_EGREP */
X    register enum {
X	m_normal,	/* nothing special */
X	m_startccl,	/* just after [ */
X	m_negccl,	/* just after [^ */
X	m_ccl,		/* between [... or [^... and ] */
X	m_escape	/* just after \ */
X    }	state = m_normal;
X    register char	*s;
X
X    rxtype = Pn(P_regextype);
X
X    flexclear(&ns);
X    for (s = *sp; *s != '\0' && (*s != delim || state != m_normal); s++) {
X	switch (state) {
X	case m_normal:
X	    switch (*s) {
X	    case '\\':
X		state = m_escape;
X		break;
X
X	    case '(': case ')': case '+': case '?': case '|':
X		/* egrep metacharacters */
X		if (rxtype != rt_EGREP)
X		    (void) flexaddch(&ns, '\\');
X		(void) flexaddch(&ns, *s);
X		break;
X
X	    case '*': case '.': case '[':
X		/* grep metacharacters */
X		if (rxtype == rt_TAGS) {
X		    (void) flexaddch(&ns, '\\');
X		} else if (*s == '[') {
X		    /* start of character class */
X		    state = m_startccl;
X		}
X		 /* fall through ... */
X
X	    default:
X		(void) flexaddch(&ns, *s);
X	    }
X	    break;
X
X	case m_startccl:
X	case m_negccl:
X	    (void) flexaddch(&ns, *s);
X	    state = (*s == '^' && state == m_startccl) ? m_negccl : m_ccl;
X	    break;
X
X	case m_ccl:
X	    (void) flexaddch(&ns, *s);
X	    if (*s == ']')
X		state = m_normal;
X	    break;
X
X	case m_escape:
X	    switch (*s) {
X	    case '(':		/* bracket conversion */
X	    case ')':
X		if (rxtype != rt_GREP)
X		    (void) flexaddch(&ns, '\\');
X		(void) flexaddch(&ns, *s);
X		break;
X
X	    case '.':		/* egrep metacharacters */
X	    case '\\':
X	    case '[':
X	    case '*':
X	    case '?':
X	    case '+':
X	    case '^':
X	    case '$':
X	    case '|':
X		(void) lformat(&ns, "\\%c", *s);
X		break;
X
X	    default:		/* a normal character */
X		if (*s != delim)
X		    (void) flexaddch(&ns, '\\');
X		(void) flexaddch(&ns, *s);
X	    }
X	    state = m_normal;
X	}
X    }
X
X    *sp = s;
X
X    /*
X     * This is horrible, but the real vi does it, so ...
X     */
X    if (state == m_escape) {
X	(void) lformat(&ns, "\\\\");
X    }
X    return flexgetstr(&ns);
X}
X
X/**********************************************************
X *							  *
X * Abstract type definition.				  *
X *							  *
X * Regular expression node, with pointer reference count. *
X *							  *
X * We need this for global substitute commands.		  *
X *							  *
X **********************************************************/
X
Xtypedef struct {
X    regexp	*rn_ptr;
X    int		rn_count;
X} Rnode;
X
X/*
X * Node for last successfully compiled regular expression.
X */
Xstatic Rnode	*lastprogp = NULL;
X
X/*
X * Last regular expression used in a substitution.
X */
Xstatic	Rnode	*last_lhs = NULL;
X
X/*
X * Last rhs for a substitution.
X */
Xstatic	char	*last_rhs = NULL;
X
X/*
X * rn_new(), rn_delete() & rn_duplicate() perform operations on Rnodes
X * which are respectively analogous to open(), close() & dup() for
X * Unix file descriptors.
X */
X
X/*
X * Make a new Rnode, given a pattern string.
X */
Xstatic Rnode *
Xrn_new(str)
X    char	*str;
X{
X    Rnode	*retp;
X
X    if ((retp = (Rnode *) alloc(sizeof (Rnode))) == NULL)
X	return NULL;
X    if ((retp->rn_ptr = regcomp(str)) == NULL) {
X	free ((char *) retp);
X	return NULL;
X    }
X    retp->rn_count = 1;
X    return retp;
X}
X
X/*
X * Make a copy of an Rnode pointer & increment the Rnode's reference
X * count.
X */
X#define rn_duplicate(s)	((s) ? ((s)->rn_count++, (s)) : NULL)
X
X/*
X * Decrement an Rnode's reference count, freeing it if there are no
X * more pointers pointing to it.
X *
X * In C++, this would be a destructor for an Rnode.
X */
Xstatic void
Xrn_delete(rp)
XRnode	*rp;
X{
X    if (rp != NULL && --rp->rn_count <= 0) {
X	free((char *) rp->rn_ptr);
X	free((char *) rp);
X    }
X}
X
X#if 0
X/*
X * Increment the reference count for the current prog,
X * and return it to the caller.
X */
Xstatic Rnode *
Xinccount()
X{
X    if (lastprogp != NULL) {
X	lastprogp->rn_count++;
X    }
X    return(lastprogp);
X}
X
X#endif
X
X#define	cur_prog()	(lastprogp->rn_ptr)
X
X/*
X * Compile given regular expression from string.
X *
X * The opening delimiter for the regular expression is supplied; the
X * end of it is marked by an unescaped matching delimiter or, if
X * delim_only is FALSE, by a '\0' character. We return a pointer to
X * the terminating '\0' or to the character following the closing
X * delimiter, or NULL if we failed.
X *
X * If, after we've found a delimiter, we have an empty pattern string,
X * we use the last compiled expression if there is one.
X *
X * The regular expression is converted to egrep syntax by mapstring(),
X * which also finds the closing delimiter. The actual compilation is
X * done by regcomp(), from Henry Spencer's regexp routines.
X *
X * If we're successful, the compiled regular expression will be
X * pointed to by lastprogp->rn_ptr, & lastprogp->rn_count will be > 0.
X */
Xstatic char *
Xcompile(pat, delimiter, delim_only)
Xchar	*pat;
Xint	delimiter;
Xbool_t	delim_only;
X{
X    Rnode	*progp;
X
X    if (pat == NULL) {
X	return(NULL);
X    }
X
X    /*
X     * If we get an empty regular expression, we just use the last
X     * one we compiled (if there was one).
X     */
X    if (*pat == '\0') {
X	return((delim_only || lastprogp == NULL) ? NULL : pat);
X    }
X    if (*pat == delimiter) {
X	return((lastprogp == NULL) ? NULL : &pat[1]);
X    }
X
X    progp = rn_new(mapstring(&pat, delimiter));
X    if (progp == NULL) {
X	return(NULL);
X    }
X
X    if (*pat == '\0') {
X	if (delim_only) {
X	    rn_delete(progp);
X	    return(NULL);
X	}
X    } else {
X	pat++;
X    }
X    rn_delete(lastprogp);
X    lastprogp = progp;
X    return(pat);
X}
X
XPosn *
Xsearch(window, startline, startindex, dir, strp)
XXviwin		*window;
XLine		*startline;
Xint		startindex;
Xint		dir;		/* FORWARD or BACKWARD */
Xchar		**strp;
X{
X    Posn	*pos;
X    Posn	*(*sfunc) P((Xviwin *, Line *, int, bool_t));
X    char	*str;
X
X    str = compile(*strp, (dir == FORWARD) ? '/' : '?', FALSE);
X    if (str == NULL) {
X	return(NULL);
X    }
X    *strp = str;
X
X    if (dir == BACKWARD) {
X	sfunc = bcksearch;
X    } else {
X	sfunc = fwdsearch;
X    }
X    pos = (*sfunc)(window, startline, startindex, Pb(P_wrapscan));
X
X    return(pos);
X}
X
X/*
X * Search for the given expression, ignoring regextype, without
X * wrapscan & and without using the compiled regular expression for
X * anything else (so 'n', 'N', etc., aren't affected). We do, however,
X * cache the compiled form for the last string we were given.
X */
XPosn *
Xnsearch(window, startline, startindex, dir, str)
XXviwin		*window;
XLine		*startline;
Xint		startindex;
Xint		dir;
Xchar		*str;
X{
X    static Rnode	*progp = NULL;
X    static char		*last_str = NULL;
X    Rnode		*old_progp;
X    Posn		*pos;
X    Posn		*(*sfunc) P((Xviwin *, Line *, int, bool_t));
X
X    if (str == NULL) {
X	return(NULL);
X    }
X    if (str != last_str &&
X	(last_str == NULL || strcmp(str, last_str) != 0)) {
X	if (progp) {
X	    rn_delete(progp);
X	}
X	progp = rn_new(str);
X	last_str = str;
X    }
X    if (progp == NULL) {
X	last_str = NULL;
X	return(NULL);
X    }
X
X    if (dir == BACKWARD) {
X	sfunc = bcksearch;
X    } else {
X	sfunc = fwdsearch;
X    }
X
X    old_progp = lastprogp;
X
X    lastprogp = progp;
X    pos = (*sfunc)(window, startline, startindex, FALSE);
X
X    lastprogp = old_progp;
X
X    return(pos);
X}
X
X/*
X * Perform line-based search, returning a pointer to the first line
X * (forwards or backwards) on which a match is found, or NULL if there
X * is none in the buffer specified.
X */
XLine *
Xlinesearch(window, dir, strp)
XXviwin	*window;
Xint	dir;
Xchar	**strp;
X{
X    Posn	pos;
X    Posn	*newpos;
X
X    pos = *(window->w_cursor);
X    if (dir == FORWARD) {
X	/*
X	 * We don't want a match to occur on the current line,
X	 * but setting the starting position to the next line
X	 * is wrong because we will not match a pattern at the
X	 * start of the line. So go to the end of this line.
X	 */
X	if (gchar(&pos) != '\0') {
X	    while (inc(&pos) == mv_SAMELINE) {
X		;
X	    }
X	}
X    } else {
X	pos.p_index = 0;
X    }
X
X    newpos = search(window, pos.p_line, pos.p_index, dir, strp);
X    return((newpos != NULL) ? newpos->p_line : NULL);
X}
X
X/*
X * regerror - called by regexp routines when errors are detected.
X */
Xvoid
Xregerror(s)
Xchar	*s;
X{
X    if (echo & e_REGERR) {
X	show_error(curwin, "%s", s);
X    }
X    echo &= ~(e_REGERR | e_NOMATCH);
X}
X
X/*
X * Find a match at or after "ind" on the given "line"; return
X * pointer to Posn of match, or NULL if no match was found.
X */
Xstatic Posn *
Xmatch(line, ind)
XLine	*line;
Xint	ind;
X{
X    static Posn	matchposn;
X    char	*s;
X    regexp	*prog;
X
X    s = line->l_text + ind;
X    prog = cur_prog();
X
X    if (regexec(prog, s, (ind == 0))) {
X	matchposn.p_line = line;
X	matchposn.p_index = (int) (prog->startp[0] - line->l_text);
X
X	/*
X	 * If the match is after the end of the line,
X	 * move it to the last character of the line,
X	 * unless the line has no characters at all.
X	 */
X	if (line->l_text[matchposn.p_index] == '\0' &&
X					matchposn.p_index > 0) {
X	    matchposn.p_index -= 1;
X	}
X
X	return(&matchposn);
X    } else {
X	return(NULL);
X    }
X}
X
X/*
X * Like match(), but returns the last available match on the given
X * line which is before the index given in maxindex.
X */
Xstatic Posn *
Xrmatch(line, ind, maxindex)
XLine		*line;
Xregister int	ind;
Xint		maxindex;
X{
X    register int	lastindex = -1;
X    Posn		*pos;
X    register char	*ltp;
X
X    ltp = line->l_text;
X    for (; (pos = match(line, ind)) != NULL; ind++) {
X	ind = pos->p_index;
X	if (ind >= maxindex)
X	    break;
X	/*
X	 * If we've found a match on the last
X	 * character of the line, return it here or
X	 * we could get into an infinite loop.
X	 */
X	if (ltp[lastindex = ind] == '\0' || ltp[ind + 1] == '\0')
X	    break;
X    }
X
X    if (lastindex >= 0) {
X	static Posn	lastmatch;
X
X	lastmatch.p_index = lastindex;
X	lastmatch.p_line = line;
X	return &lastmatch;
X    } else {
X	return NULL;
X    }
X}
X
X/*
X * Search forwards through the buffer for a match of the last
X * pattern compiled.
X */
Xstatic Posn *
Xfwdsearch(window, startline, startindex, wrapscan)
XXviwin		*window;
XLine		*startline;
Xint		startindex;
Xbool_t		wrapscan;
X{
X    static Posn	*pos;		/* location of found string */
X    Line	*lp;		/* current line */
X    Line	*last;
X
X    last = window->w_buffer->b_lastline;
X
X    /*
X     * First, search for a match on the current line
X     * after the cursor position.
X     */
X    pos = match(startline, startindex + 1);
X    if (pos != NULL) {
X	return(pos);
X    }
X
X    /*
X     * Now search all the lines from here to the end of the file,
X     * and from the start of the file back to here if (wrapscan).
X     */
X    for (lp = startline->l_next; lp != startline; lp = lp->l_next) {
X	/*
X	 * Wrap around to the start of the file.
X	 */
X	if (lp == last) {
X	    if (wrapscan) {
X		lp = window->w_buffer->b_line0;
X		continue;
X	    }
X	     /* else */
X		return(NULL);
X	}
X
X	pos = match(lp, 0);
X	if (pos != NULL) {
X	    return(pos);
X	}
X    }
X
X    /*
X     * Finally, search from the start of the cursor line
X     * up to the cursor position. (Wrapscan was set if
X     * we got here.)
X     */
X    pos = match(startline, 0);
X    if (pos != NULL) {
X	if (pos->p_index <= startindex) {
X	    return(pos);
X	}
X    }
X
X    return(NULL);
X}
X
X/*
X * Search backwards through the buffer for a match of the last
X * pattern compiled.
X *
X * Because we're searching backwards, we have to return the
X * last match on a line if there is more than one, so we call
X * rmatch() instead of match().
X */
Xstatic Posn *
Xbcksearch(window, startline, startindex, wrapscan)
XXviwin		*window;
XLine		*startline;
Xint		startindex;
Xbool_t		wrapscan;
X{
X    Posn	*pos;		/* location of found string */
X    Line	*lp;		/* current line */
X    Line	*line0;
X
X    /*
X     * First, search for a match on the current line before the
X     * current cursor position; if "begword" is set, it must be
X     * before the current cursor position minus one.
X     */
X    pos = rmatch(startline, 0, startindex);
X    if (pos != NULL) {
X	return(pos);
X    }
X
X    /*
X     * Search all lines back to the start of the buffer,
X     * and then from the end of the buffer back to the
X     * line after the cursor line if wrapscan is set.
X     */
X    line0 = window->w_buffer->b_line0;
X    for (lp = startline->l_prev; lp != startline; lp = lp->l_prev) {
X
X	if (lp == line0) {
X	    if (wrapscan) {
X		/*
X		 * Note we do a continue here so that
X		 * the loop control works properly.
X		 */
X		lp = window->w_buffer->b_lastline;
X		continue;
X	    } else {
X		return(NULL);
X	    }
X	}
X	pos = rmatch(lp, 0, INT_MAX);
X	if (pos != NULL)
X	    return pos;
X    }
X
X    /*
X     * Finally, try for a match on the cursor line
X     * after (or at) the cursor position.
X     */
X    pos = rmatch(startline, startindex, INT_MAX);
X    if (pos != NULL) {
X	return(pos);
X    }
X
X    return(NULL);
X}
X
X/*
X * Execute a global command of the form:
X *
X * g/pattern/X
X *
X * where 'x' is a command character, currently one of the following:
X *
X * d	Delete all matching lines
X * l	List all matching lines
X * p	Print all matching lines
X * s	Perform substitution
X * &	Repeat last substitution
X * ~	Apply last right-hand side used in a substitution to last
X *	regular expression used
X *
X * The command character (as well as the trailing slash) is optional, and
X * is assumed to be 'p' if missing.
X *
X * The "lp" and "up" parameters are the first line to be considered, and
X * the last line to be considered. If these are NULL, the whole buffer is
X * considered; if only up is NULL, we consider the single line "lp".
X *
X * The "matchtype" parameter says whether we are doing 'g' or 'v'.
X */
Xvoid
Xdo_global(window, lp, up, cmd, matchtype)
XXviwin		*window;
XLine		*lp, *up;
Xchar		*cmd;
Xbool_t		matchtype;
X{
X    Rnode		*globprogp;
X    regexp		*prog;		/* compiled pattern */
X    long		ndone;		/* number of matches */
X    register char	cmdchar = '\0';	/* what to do with matching lines */
X
X    /*
X     * compile() compiles the pattern up to the first unescaped
X     * delimiter: we place the character after the delimiter in
X     * cmdchar. If there is no such character, we default to 'p'.
X     */
X    if (*cmd == '\0' || (cmd = compile(&cmd[1], *cmd, FALSE)) == NULL) {
X	regerror(matchtype ?
X		"Usage: :g/search pattern/command" :
X		"Usage: :v/search pattern/command");
X	return;
X    }
X    /*
X     * Check we can do the command before starting.
X     */
X    switch (cmdchar = *cmd) {
X    case '\0':
X	cmdchar = 'p';
X	 /* fall through ... */
X    case 'l':
X    case 'p':
X	break;
X    case 's':
X    case '&':
X    case '~':
X	cmd++;	/* cmd points at char after modifier */
X	 /* fall through ... */
X    case 'd':
X	if (!start_command(window)) {
X	    return;
X	}
X	break;
X    default:
X	regerror("Invalid command character");
X	return;
X    }
X
X    ndone = 0;
X
X    /*
X     * If no range was given, do every line.
X     * If only one line was given, just do that one.
X     * Ensure that "up" points at the line after the
X     * last one in the range, to make the loop easier.
X     */
X    if (lp == NULL) {
X	lp = window->w_buffer->b_file;
X	up = window->w_buffer->b_lastline;
X    } else if (up == NULL) {
X	up = lp->l_next;
X    } else {
X	up = up->l_next;
X    }
X
X    /*
X     * If we are going to print lines, it is sensible
X     * to find out the line number of the first line in
X     * the range before we start, and increment it as
X     * we go rather than finding out the line number
X     * for each line as it is printed.
X     */
X    switch (cmdchar) {
X    case 'p':
X    case 'l':
X	curnum = lineno(window->w_buffer, lp);
X	curline = lp;
X	lastline = up;
X	greptype = matchtype;
X	disp_init(window, grep_line, (int) Columns,
X	      (cmdchar == 'l'));
X	return;
X    }
X
X    /*
X     * This is tricky. do_substitute() might default to
X     * using cur_prog(), if the command is of the form
X     *
X     *	:g/pattern/s//.../
X     *
X     * so cur_prog() must still reference the expression we
X     * compiled. On the other hand, it may compile a
X     * different regular expression, so we have to be able
X     * to maintain a separate one (which is what globprogp
X     * is for). Moreover, if it does compile a different
X     * expression, one of them has to be freed afterwards.
X     *
X     * This is why we use Rnodes, which contain
X     * reference counts. An Rnode, & the compiled
X     * expression it points to, are only freed when its
X     * reference count is decremented to 0.
X     */
X    globprogp = rn_duplicate(lastprogp);
X    prog = cur_prog();
X
X    /*
X     * Place the cursor at bottom left of the window,
X     * so the user knows what we are doing.
X     * It is safe not to put the cursor back, because
X     * we are going to produce some more output anyway.
X     */
X    gotocmd(window, FALSE);
X    flush_output();
X
X    /*
X     * Try every line from lp up to (but not including) up.
X     */
X    ndone = 0;
X    while (lp != up) {
X	if (matchtype == regexec(prog, lp->l_text, TRUE)) {
X	    Line	*thisline;
X
X	    /*
X	     * Move the cursor to the line before
X	     * doing anything. Also move the line
X	     * pointer on one before calling any
X	     * functions which might alter or delete
X	     * the line.
X	     */
X	    move_cursor(window, lp, 0);
X
X	    thisline = lp;
X	    lp = lp->l_next;
X
X	    switch (cmdchar) {
X	    case 'd':	/* delete the line */
X		repllines(window, thisline, 1L,
X			(Line *) NULL);
X		ndone++;
X		break;
X	    case 's':	/* perform substitution */
X	    case '&':
X	    case '~':
X	    {
X		register long	(*func) P((Xviwin *, Line *, Line *, char *));
X		unsigned	savecho;
X
X		switch (cmdchar) {
X		case 's':
X		    func = do_substitute;
X		    break;
X		case '&':
X		    func = do_ampersand;
X		    break;
X		case '~':
X		    func = do_tilde;
X		}
X
X		savecho = echo;
X
X		echo &= ~e_NOMATCH;
X		ndone += (*func)
X		(window, thisline, thisline, cmd);
X
X		echo = savecho;
X		break;
X	    }
X	    }
X	} else {
X	    lp = lp->l_next;
X	}
X    }
X
X    /*
X     * If globprogp is still the current prog, this should just
X     * decrement its reference count to 1: otherwise, if
X     * do_substitute() has compiled a different pattern, then that
X     * counts as the last compiled pattern, globprogp's reference
X     * count should be decremented to 0, & it should be freed.
X     */
X    rn_delete(globprogp);
X
X    switch (cmdchar) {
X    case 'd':
X    case 's':
X    case '&':
X    case '~':
X	end_command(window);
X	if (ndone) {
X	    update_buffer(window->w_buffer);
X	    cursupdate(window);
X	    begin_line(window, TRUE);
X	    if (ndone >= Pn(P_report)) {
X		show_message(window,
X			 (cmdchar == 'd') ?
X			 "%ld fewer line%c" :
X			 "%ld substitution%c",
X			 ndone,
X			 (ndone > 1) ?
X			 's' : ' ');
X	    }
X	}
X    }
X
X    if (ndone == 0 && (echo & e_NOMATCH)) {
X	regerror("No match");
X    }
X}
X
Xstatic char *
Xgrep_line()
X{
X    static Flexbuf	b;
X    regexp		*prog;
X
X    prog = cur_prog();
X    for ( ; curline != lastline; curline = curline->l_next, curnum++) {
X
X	if (greptype == regexec(prog, curline->l_text, TRUE)) {
X
X	    flexclear(&b);
X	    if (Pb(P_number)) {
X		(void) lformat(&b, NUM_FMT, curnum);
X	    }
X	    (void) lformat(&b, "%s", curline->l_text);
X	    break;
X	}
X    }
X
X    if (curline == lastline) {
X	return(NULL);
X    } else {
X	curline = curline->l_next;
X	curnum++;
X	return(flexgetstr(&b));
X    }
X}
X
X/*
X * regsubst - perform substitutions after a regexp match
X *
X * Adapted from a routine from Henry Spencer's regexp package. The
X * original copyright notice for all these routines is in regexp.c,
X * which is distributed herewith.
X */
X
X#ifndef CHARBITS
X#	define	UCHARAT(p)	((int)*(unsigned char *)(p))
X#else
X#	define	UCHARAT(p)	((int)*(p)&CHARBITS)
X#endif
X
Xstatic void
Xregsubst(prog, src, dest)
Xregister regexp	*prog;
Xregister char	*src;
XFlexbuf		*dest;
X{
X    register int	c;
X
X    if (prog == NULL || src == NULL || dest == NULL) {
X	regerror("NULL parameter to regsubst");
X	return;
X    }
X
X    if (UCHARAT(prog->program) != MAGIC) {
X	regerror("Damaged regexp fed to regsubst");
X	return;
X    }
X
X    while ((c = *src++) != '\0') {
X	register int no;
X
X	/*
X	 * First check for metacharacters.
X	 */
X	if (c == '&') {
X	    no = 0;
X	} else if (c == '\\' && '0' <= *src && *src <= '9') {
X	    no = *src++ - '0';
X	} else {
X	    no = -1;
X	}
X
X	if (no < 0) {
X	    /*
X	     * It's an ordinary character.
X	     */
X	    if (c == '\\' && *src != '\0')
X		c = *src++;
X
X	    (void) flexaddch(dest, c);
X
X	} else if (prog->startp[no] != NULL && prog->endp[no] != NULL) {
X	    register char *bracketp;
X
X	    /*
X	     * It isn't an ordinary character, but a reference
X	     * to a string matched on the lhs. Notice that we
X	     * just do nothing if we find a reference to a null
X	     * match, or one that doesn't exist; we can't tell
X	     * the difference at this stage.
X	     */
X
X	    for (bracketp = prog->startp[no]; bracketp < prog->endp[no];
X							     bracketp++) {
X		if (*bracketp == '\0') {
X		    regerror("Damaged match string");
X		    return;
X		} else {
X		    (void) flexaddch(dest, *bracketp);
X		}
X	    }
X	}
X    }
X}
X
X/*
X * do_substitute(window, lp, up, cmd)
X *
X * Perform a substitution from line 'lp' up to (but not including)
X * line 'up' using the command pointed to by 'cmd' which should be
X * of the form:
X *
X * /pattern/substitution/g
X *
X * The trailing 'g' is optional and, if present, indicates that multiple
X * substitutions should be performed on each line, if applicable.
X * The usual escapes are supported as described in the regexp docs.
X */
Xlong
Xdo_substitute(window, lp, up, command)
XXviwin	*window;
XLine	*lp, *up;
Xchar	*command;
X{
X    char	*copy;		/* for copy of command */
X    regexp	*prog;
X    char	*sub;
X    char	*cp;
X    char	delimiter;
X    long	nsubs;
X
X    copy = alloc((unsigned) strlen(command) + 1);
X    if (copy == NULL) {
X	return(0);
X    }
X    (void) strcpy(copy, command);
X
X    delimiter = *copy;
X    if (delimiter == '\0' ||
X    			(cp = compile(&copy[1], delimiter, TRUE)) == NULL) {
X	regerror("Usage: :s/search pattern/replacement/");
X	free(copy);
X	return(0);
X    }
X    sub = cp;
X    prog = cur_prog();
X
X    /*
X     * Scan past the rhs to the flags, if any.
X     */
X    for (; *cp != '\0'; cp++) {
X	if (*cp == '\\') {
X	    if (*++cp == '\0') {
X		break;
X	    }
X	} else if (*cp == delimiter) {
X	    *cp++ = '\0';
X	    break;
X	}
X    }
X
X    /*
X     * Save the regular expression for do_ampersand().
X     */
X    if (last_lhs) {
X	rn_delete(last_lhs);
X    }
X    last_lhs = rn_duplicate(lastprogp);
X
X    /*
X     * Save the rhs.
X     */
X    if (last_rhs != NULL) {
X	free(last_rhs);
X    }
X    last_rhs = strsave(sub);
X
X    nsubs = substitute(window, lp, up, sub, cp);
X
X    free(copy);
X
X    return(nsubs);
X}
X
X/*
X * Repeat last substitution.
X *
X * For vi compatibility, this also changes the value of the last
X * regular expression used.
X */
Xlong
Xdo_ampersand(window, lp, up, flags)
XXviwin	*window;
XLine	*lp, *up;
Xchar	*flags;
X{
X    long	nsubs;
X
X    if (last_lhs == NULL || last_rhs == NULL) {
X	show_error(window, "No substitute to repeat!");
X	return(0);
X    }
X    rn_delete(lastprogp);
X    lastprogp = rn_duplicate(last_lhs);
X    nsubs = substitute(window, lp, up, last_rhs, flags);
X    return(nsubs);
X}
X
X/*
X * Apply last right-hand side used in a substitution to last regular
X * expression used.
X *
X * For vi compatibility, this also changes the value of the last
X * substitution.
X */
Xlong
Xdo_tilde(window, lp, up, flags)
XXviwin	*window;
XLine	*lp, *up;
Xchar	*flags;
X{
X    long	nsubs;
X
X    if (lastprogp == NULL || last_rhs == NULL) {
X	show_error(window, "No substitute to repeat!");
X	return(0);
X    }
X    if (last_lhs) {
X	rn_delete(last_lhs);
X    }
X    last_lhs = rn_duplicate(lastprogp);
X    nsubs = substitute(window, lp, up, last_rhs, flags);
X    return(nsubs);
X}
X
Xstatic long
Xsubstitute(window, lp, up, sub, flags)
XXviwin	*window;
XLine	*lp, *up;
Xchar	*sub;
Xchar	*flags;
X{
X    long	nsubs;
X    Flexbuf	ns;
X    regexp	*prog;
X    bool_t	do_all;		/* true if 'g' was specified */
X
X    if (!start_command(window)) {
X	return(0);
X    }
X
X    prog = cur_prog();
X
X    do_all = (*flags == 'g');
X
X    nsubs = 0;
X
X    /*
X     * If no range was given, do the current line.
X     * If only one line was given, just do that one.
X     * Ensure that "up" points at the line after the
X     * last one in the range, to make the loop easier.
X     */
X    if (lp == NULL) {
X	lp = window->w_cursor->p_line;
X    }
X    if (up == NULL) {
X	up = lp->l_next;
X    } else {
X	up = up->l_next;
X    }
X    flexnew(&ns);
X    for (; lp != up; lp = lp->l_next) {
X	if (regexec(prog, lp->l_text, TRUE)) {
X	    char	*p, *matchp;
X
X	    /*
X	     * Save the line that was last changed for the final
X	     * cursor position (just like the real vi).
X	     */
X	    move_cursor(window, lp, 0);
X
X	    flexclear(&ns);
X	    p = lp->l_text;
X
X	    do {
X		/*
X		 * Copy up to the part that matched.
X		 */
X		while (p < prog->startp[0]) {
X		    (void) flexaddch(&ns, *p);
X		    p++;
X		}
X
X		regsubst(prog, sub, &ns);
X
X		/*
X		 * Continue searching after the match.
X		 *
X		 * Watch out for null matches - we
X		 * don't want to go into an endless
X		 * loop here.
X		 */
X		matchp = p = prog->endp[0];
X		if (prog->startp[0] >= p) {
X		    if (*p == '\0') {
X			/*
X			 * End of the line.
X			 */
X			break;
X		    } else {
X			matchp++;
X		    }
X		}
X
X	    } while (do_all && regexec(prog, matchp, FALSE));
X
X	    /*
X	     * Copy the rest of the line, that didn't match.
X	     */
X	    (void) lformat(&ns, "%s", p);
X	    replchars(window, lp, 0, strlen(lp->l_text),
X		  flexgetstr(&ns));
X	    nsubs++;
X	}
X    }
X    flexdelete(&ns);			/* free the temp buffer */
X    end_command(window);
X
X    if (!nsubs && (echo & e_NOMATCH)) {
X	regerror("No match");
X    }
X    return(nsubs);
X}
END_OF_FILE
  if test 27204 -ne `wc -c <'xvi/src/search.c'`; then
    echo shar: \"'xvi/src/search.c'\" unpacked with wrong size!
  fi
  # end of 'xvi/src/search.c'
fi
echo shar: End of archive 10 \(of 18\).
cp /dev/null ark10isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
