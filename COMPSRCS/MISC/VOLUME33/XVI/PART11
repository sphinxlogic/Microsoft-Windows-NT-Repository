Newsgroups: comp.sources.misc
From: jmd@cyclone.bt.co.uk (John Downey)
Subject:  v33i020:  xvi - portable multi-window vi-like editor, Part11/18
Message-ID: <1992Oct24.172358.2081@sparky.imd.sterling.com>
X-Md4-Signature: 8e472a1333d4f9d1615c622bd2a6be33
Date: Sat, 24 Oct 1992 17:23:58 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: jmd@cyclone.bt.co.uk (John Downey)
Posting-number: Volume 33, Issue 20
Archive-name: xvi/part11
Environment: Unix, MS-DOS, OS/2, QNX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  xvi/doc/summary.ms xvi/src/qnx.h xvi/src/termcap.c
# Wrapped by kent@sparky on Thu Oct 22 09:03:43 1992
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 11 (of 18)."'
if test -f 'xvi/doc/summary.ms' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xvi/doc/summary.ms'\"
else
  echo shar: Extracting \"'xvi/doc/summary.ms'\" \(21826 characters\)
  sed "s/^X//" >'xvi/doc/summary.ms' <<'END_OF_FILE'
X.\"========== Macro definitions
X.\"========== Three-column output
X.de c3
X.ta 1.5i 3i 4.5i
X\\$1	\\$2	\\$3
X.br
X..
X.\"========== Put string in boldface & surround with quotes
X.de qB
X\%\*Q\fB\\$1\fP\*U\\$2
X..
X.\"========== Redefine NH to avoid widowing
X.rn NH Nh
X.de NH
X.if \\$1=1 .ne 1.5i
X.ne 1i
X.Nh \\$1 \\$2
X..
X.\"========== End of macros
X.\"========== 11 on 13 looks so much better than 10 on 12
X.nr PS 11
X.nr VS 13
X.ps 11
X.vs 13p
X.nr HM 0.9i
X.nr FM 0.9i
X.if n .nr PO 0.5i
X.if n .nr LL 6.5i
X.\"========== Turn hyphenation off, and make sure it stays off
X.nh
X.rm hy
X.\"========== Headers in italics helps them to stand out from the text
X.OH '\fISummary of Differences between Vi and Xvi\fP''\fI%\fP'
X.EH '\fI%\fP''\fISummary of Differences between Vi and Xvi\fP'
X.OF '\fI25th September 1992\fP''\fIPage %\fP'
X.EF '\fIPage %\fP''\fI25th September 1992\fP'
X.\"===================== End of header; start of document ====================
X.TL
XSummary of Differences between Vi and Xvi
X.AU
XChris Downey
XJohn Downey
X.AB no
X\fBXvi\fP (pronounced \fIecks-vee-eye\fP)
Xis a free, portable, multi-window implementation of the popular
X.UX
Xeditor \fBvi\fP.
X.LP
XThis document summarises the differences between the ``real'' \fBvi\fP
Xand \fBxvi\fP.
XThese differences are divided into three groups:
X\fIunimplemented features\fP,
X\fIdifferences\fP
Xand \fIenhancements\fP,
Xand each of these is described in the following sections.
X.AE
X.\"===========================================================================
X.NH 1
XUnimplemented Features
X.\"---------------------------------------------------------------------------
X.KS
X.NH 2
XEx Mode
X.LP
XThe main area in which \fBxvi\fP is lacking is \fBvi\fP's
X.B ex
Xmode,
Xwhich is not implemented at all (and neither are \fBedit\fP, \fBe\fP,
Xand \fBopen\fP modes).
XHowever, many of the \fBex\fP commands are available in \fBxvi\fP as
Xcolon commands;
Xthe colon commands that have not been implemented are mostly those which offer
Xthe same functionality as other commands in \fBvi\fP mode.
X.KE
X.KS
X.LP
XSpecifically, the following \fBex\fP commands are not implemented,
Xand probably never will be within \fBxvi\fP:
X.DS
X.B
X.c3 insert undo ex
X.c3 change open |
X.c3 append z
X.R
X.DE
X.KE
X.KS
X.nh
X.rm hy
Xwhile these \fBex\fP commands, although not currently implemented,
Xmay be added as colon commands at some time in the future:
X.DS
X.B
X.c3 abbreviate recover write>>
X.c3 unabbreviate join
X.R
X.DE
X.KE
X.\"---------------------------------------------------------------------------
X.NH 2
XVi commands
X.LP
XThe following \fBvi\fP mode commands are not implemented,
Xalthough there is no real reason why they shouldn't be:
X.DS
X.B
X.c3 U =
X.R
X.DE
X.KS
Xwhile this one is inappropriate in the context of \fBxvi\fP,
Xsince there is no
X.B ex
Xmode:
X.DS
X.B Q
X.DE
X.KE
X.\"---------------------------------------------------------------------------
X.KS
X.NH 2
XParameters
X.LP
XThe following parameters have not been implemented,
Xand probably won't be:
X.DS
X.B
X.c3 ada lisp redraw
X.c3 adapath mesg slowopen
X.c3 autoprint modeline term
X.c3 beautify open terse
X.c3 directory optimize ttytype
X.c3 edcompatible prompt window
X.c3 hardtabs
X.R
X.DE
X.KE
X.KS
Xwhile these parameters may well be implemented at some point:
X.DS
X.B
X.c3 autowrite scroll warn
X.c3 errorbells sourceany writeany
X.R
X.DE
X.KE
X.\"---------------------------------------------------------------------------
X.NH 2
XMiscellaneous
X.LP
XSome features of certain commands do not work as they should.
XSpecifically:
X.IP \(bu 5
XRepeat counts before insertions don't work.
X.IP \(bu 5
XAppending to named buffers is not yet implemented.
X.IP \(bu 5
XTyping \fB^Q\fP in input mode does not mean the same as \fB^V\fP;
Xit just inserts a `^Q', assuming it gets as far as the editor at all.
X.IP \(bu 5
XTyping \fB^W\fP in insert mode does not back up one word as in \fBvi\fP.
X.IP \(bu 5
XIt is not possible to interrupt the editor while it is
Xperforming certain operations.
XIf you start off a big global command, you have to wait for it to finish.
X.IP \(bu 5
XFlags and counts after colon commands are not supported.
X.KS
X.IP \(bu 5
XIt is not possible to read the output of a system command using
X.DS
X\fB:r\ !\fP\fIcommand\fP
X.DE
Xor to write into a command using
X.DS
X\fB:w\ !\fP\fIcommand\fP
X.DE
X.KE
X.IP \(bu 5
XThe \fB:substitute\fP command does not support splitting of lines.
X.IP \(bu 5
XRegular expressions, although implemented (see later for more details),
Xdo not support the \fB~\fP character;
Xalso, the \fB\e\^u\fP and \fB\e\^l\fP escape sequences are not supported on
Xthe right-hand side of a substitute replacement pattern.
X.IP \(bu 5
XThe \fB:global\fP command only supports the commands [\fBlps&~d\fP].
X.IP \(bu 5
X\fBUndo\fP does not work properly when applied to macros (either
X.B @
Xor
X\fB:map\fP); it should undo all the changes made by the macro, but in
Xfact only the last command within the macro is undone.
X.\"===========================================================================
X.NH 1
XEnhancements
X.LP
XThe following extensions are available in \fBxvi\fP.
X.\"---------------------------------------------------------------------------
X.KS
X.NH 2
XParameter Handling
X.LP
X\fBXvi\fP supports 5 types of parameter:
Xas well as \fBvi\fP's
X\fInumeric\fP,
X\fIstring\fP and
X\fIboolean\fP,
Xit also has
X\fIenumerated\fP and
X\fIlist\fP types.
XThe former is used for e.g. \fBformat\fP and \fBregextype\fP,
Xwhile the latter is currently only used for \fBtags\fP.
XThe advantage of the \fIenumerated\fP type is that if you try
Xto set an illegal value, the set of correct values will be displayed,
Xwhich is very useful if you have forgotten what the values may be.
X(Try \fB:set preserve\fP to see an example of this.)
X.KE
X.\"---------------------------------------------------------------------------
X.NH 2
XWindows
X.LP
X\fBXvi\fP supports multiple \fIbuffers\fP and \fIwindows\fP.
XA \fIbuffer\fP is the object which holds a file in memory,
Xwhile a \fIwindow\fP is an area of the screen which shows part of a buffer.
XNote that every window references a buffer, even if no file is being edited.
X.LP
XThe following commands are available for operating on buffers and windows:
X.IP \fB:buffer\fP 10
Xcreate a new buffer in a new window; can be followed
Xby a filename, which will be edited in the new buffer.
X.IP \fB:split\fP 10
Xcreate a new window onto the current buffer by
Xsplitting the current window in half.
XThe two resulting windows are similar to
X.I viewports
Xon to a single editing buffer,
Xin that changes made in one window are reflected in the other one.
X.IP \fB:close\fP 10
Xclose the current window; will also close the buffer
Xif this is the last window onto it.
X.IP "\fB:x / ZZ\fP" 10
Xclose only the current window.
XIf the window is the only one onto the buffer,
Xthe buffer will be closed as well,
Xwriting it first if it is modified.
XHence, for a single window, this command does the
Xsame as in \fBvi\fP.
X.IP \fBg\fP 10
Xmove to the next window.
XThis is normally the window directly below the current one
Xon the screen, or the top window on the screen if the current
Xwindow is the bottom one.
X.IP \fB^W\fP 10
Xincrease the size of the current window (may be
Xgiven a numeric prefix, default is one line).
X.IP \fB^T\fP 10
Xdecrease the size of the current window (may be
Xgiven a numeric prefix, default is one line).
X.IP \fB^O\fP 10
Xmake the current window as large as possible.
X.IP \fB^]\fP 10
Xas for \fBvi\fP, but creates a new buffer window
Xif appropriate (and if \fBautosplit\fP allows).
X.LP
XNote that the \fB:quit\fP command quits out of the editor,
Xnot out of a window.
XThe \fB:close\fP command is thus the equivalent of \fB:quit\fP for windows.
XThere is no equivalent of \fB:x\fP or \fBZZ\fP for the whole editor;
Xthese have been hijacked for operations on windows.
X.LP
XAlso the numeric \fBautosplit\fP parameter specifies the maximum number
Xof buffer windows that will be created automatically whenever you
Xeither edit more than one file, or use tags to edit a different file.
X.LP
XUndo works per buffer, as do marks; yank/put and redo (the \fB.\fP command)
Xwork over all buffers, i.e. you can delete from one buffer and put
Xthe text into a different buffer.
X.LP
XThe \fBminrows\fP parameter specifies the minimum number of rows
Xto which a window may be shrunk, including the status line.
XThe default value is 2; 0 and 1 may also be useful.
X.\"---------------------------------------------------------------------------
X.KS
X.NH 2
XNamed Buffers
X.LP
XAs well as the normal named (conjugate) buffers, and the default one
Xnamed \fB@\fP,
Xseveral extra buffers named
X.B : ,
X.B / ,
X.B ?
Xand
X.B !
Xcontain the last command lines entered for each of the command types.
XSo for instance,
X.B @:
Xwill re-execute the last colon command, or you can insert
Xit into your buffer, edit it and then re-execute it (e.g. with
X.B dd@@ ).
X.KE
X.\"---------------------------------------------------------------------------
X.KS
X.NH 2
XFile Formats
X.LP
X\fBXvi\fP will handle different file formats, via the \fBformat\fP parameter,
Xwhich may be set to e.g.
X.qB unix ,
X.qB msdos ,
Xetc.
XThis means you can edit \%MS-DOS files under UNIX, etc.
X.KE
X.\"---------------------------------------------------------------------------
X.KS
X.NH 2
XRegular Expressions
X.LP
X\fBVi\fP's \fBmagic\fP parameter is replaced by the \fBregextype\fP parameter,
Xwhich can take the following values:
X.KE
X.IP \fBtags\fP 10
Xonly
X.B ^
Xand
X.B $
Xare significant (used for tags).
X.IP \fBgrep\fP 10
Xlike
X.B grep (1),
Xbut with
X.B \e<
Xand
X.B \e\^>
Xadded.
X.IP \fBegrep\fP 10
Xlike
X.B egrep (1),
Xbut with
X.B \e<
Xand
X.B \e\^>
Xadded.
X.LP
XThe default is
X.B grep .
X.LP
XThe \fBsections\fP and \fBparagraphs\fP parameters define
X.B egrep -style
Xpatterns to search for, rather than
X.B vi 's
Xsimplistic (and
X.B troff -dependent)
Xcharacter pairs.
X.LP
XThe \fBsentences\fP parameter is also implemented in this fashion,
Xbut this is not completely satisfactory at the moment.
X.LP
XNote that it is possible to set or unset the \fBmagic\fP parameter
Xas in \fBvi\fP; this will simply result in the \fBregextype\fP parameter
Xbeing set as appropriate.
X.\"---------------------------------------------------------------------------
X.KS
X.NH 2
XColour
X.LP
X\fBXvi\fP has a minimal amount of support for colours.
XBasically, there are considered to be four settable colours,
Xeach with a numeric parameter to say what its value is:
X.IP \fBcolour\fP 14
Xcolour used for text
X.IP \fBstatuscolour\fP 14
Xcolour used for status lines
X.IP \fBroscolour\fP 14
Xas statuscolour, but for readonly files
X.IP \fBsystemcolour\fP 14
Xcolour used for system mode
X(i.e. subshells and after termination).
X.KE
X.LP
XThe actual values of these parameters are system-dependent;
Xon PC versions, they are hardware-dependent video attributes,
Xwhile on UNIX they are indexes into the
Xentries ``\fBc0\fP'' to ``\fBc9\fP''
Xin the
X.B termcap (5)
Xdatabase,
Xwhich are assumed to be colour-setting
Xescape sequences if they are present.
XIf they are not present,
X.qB so
X(begin standout mode)
Xand
X.qB se
X(end standout mode)
Xare used instead.
XValues of 0 and 1 give normal text, 2 to 9 give standout mode.
X.LP
XThe default colour for the \fBroscolour\fP parameter will usually involve red
Xif colours are available;
Xthis is intended to provide a warning to the user that writing the file may
Xnot be possible.
X.KS
X.LP
XThe colour values may be entered in decimal, octal or hexadecimal form.
XThis
Xmay be convenient for PC versions where the numbers actually
Xrepresent colour bitmaps; for example, on \%MS-DOS,
X.DS
X.B
X:set co=0x1f
X.R
X.DE
Xgives bright white text on a blue background.
X.KE
X.\"---------------------------------------------------------------------------
X.KS
X.NH 2
XReplace Mode
X.LP
X\fBXvi\fP's \fIreplace\fP mode (entered by the \fBR\fP command)
Xacts more intelligently when you press the return key \(em
Xit leaves the rest of the current line alone, and just starts
Xreplacing text on the next line, starting at the screen column
Xwhere you first typed \fBR\fP.
X.KE
X.\"---------------------------------------------------------------------------
X.KS
X.NH 2
XPreserve
X.LP
XRather than use \fBvi\fP's UNIX-specific method for preservation,
X\fBxvi\fP does periodic preservation of all files
Xcurrently being edited into a temporary file in the same directory.
X\fBXvi\fP tries to do this when you are not typing, so that you won't
Xnotice the short delay when the temporary file is written out.
XObviously, only changed files are preserved in this way, and the
Xtemporary file is normally removed
Xonce the real file has been successfully written.
XAs an additional safety measure,
Xwhen a file is explicitly saved
Xand it appears not to have been preserved recently,
Xit is normally preserved first.
XThis ensures that,
Xeven if the operating system crashes while the
Xreal file is being created,
Xthere should always be at least one recent copy of it in the filesystem.
XThe \fB:preserve\fP command is available as in \fBvi\fP to preserve
Xa specific buffer manually.
X.KE
X.LP
XThe level of safety provided by the preservation facility may be configured
Xby changing the values of the
X.B preserve
Xand
X.B preservetime
Xparameters.
XThe following values are available for
X.B preserve :
X.IP \fBunsafe\fP 10
XNever preserve any buffer before an explicit save.
XThis can be useful on old, slow, floppy-only systems,
Xbut is not generally recommended.
X.IP \fBstandard\fP 10
XThe default value.
XOnly preserve a buffer before an explicit save if it appears not to have
Xbeen preserved recently.
X.IP \fBsafe\fP 10
XAlways preserve buffers before they are written.
X.IP \fBparanoid\fP 10
XAs for \fBsafe\fP, but the preserve file is never removed,
Xeven after the file has been successfully written.
X.LP
X.nh
XIn all cases,
Xall modified buffers are preserved automatically after no user events
Xhave been received for
X.B preservetime
Xseconds,
Xif a minimum number of events (currently 60) have been received since the
Xlast automatic preservation.
XThis behaviour can be more or less disabled by setting
X.B preservetime
Xto a very high value.
X(For example,
Xone of the authors sets it to 600 on the machine he uses at home,
Xwhich is an 8088-based PC with no hard disk;
Xby way of contrast,
Xon the SparcStation IPX which he uses at work,
Xhe sets it to 2.)
X.LP
XThe names given to preserve files are system-dependent,
Xbut are generally of the form \*Q\fIfilename\fP.tmp\*U,
Xor \*Q\fIfilename\fP.001\*U to \*Q\fIfilename\fP.999\*U.
XIf a preserve file already exists, it will not be overwritten;
Xinstead, a new filename will be generated.
X.LP
XThe \fB\-r\fP command line option is not supported.
X.\"---------------------------------------------------------------------------
X.KS
X.NH 2
XHelp
X.LP
XA primitive help facility is available; the command \fB:help\fP, also
Xmapped to the HELP or F1 keys on many systems, simply creates a new
Xbuffer window onto a standard help file.
XThe name of the file which is edited is given by the \fBhelpfile\fP
Xstring parameter;
Xthe default on Unix versions is
X\fB"/usr/lib/xvi.help"\fP.
X.KE
X.\"---------------------------------------------------------------------------
X.KS
X.NH 2
XScrolling
X.LP
XThe
X.B jumpscroll
Xenumerated parameter
Xcontrols
Xthe editor's
Xbehaviour when the cursor moves beyond the limits of
Xthe current window.
XIf its value is
X.B off ,
Xand the new position is still reasonably close to the current window,
Xthe window will be scrolled so that the new cursor position is at the
Xtop or bottom of it.
XTypically, the window will be scrolled one
Xline at a time as the cursor is moved up or down.
XThis behaviour may not always be desirable; for example,
Xterminals without real scrolling regions
Xmay force the editor to do a lot of screen updating,
Xpossibly over a slow telephone line or overloaded network.
XAlso, on LCD screens or other displays with a long image persistence,
Xit may
Xmake the text more difficult to read.
XIf
X.B jumpscroll
Xis set to
X.B on ,
Xscrolling behaviour is modified so that,
Xwhenever
Xthe cursor moves beyond the limits of the current window,
Xthe window is redrawn so as to place the cursor as centrally as possible
Xin it; thus, the window appears to
X.I jump
Xto the new position.
XThe default value for
X.B jumpscroll
Xis \fBauto\fP,
Xwhich causes
Xthe editor to jump
Xinstead of scrolling only if it can't scroll the affected window
Xefficiently.
X.LP
XIn all cases,
Xif the distance from the top or bottom of the window
Xto the new position is more than half the window size,
Xthe editor will jump instead of scrolling.
X.KE
X.LP
XExplicit scroll commands (e.g. \fB^D\fP) are not affected by
Xthe \fBjumpscroll\fP parameter.
X.\"---------------------------------------------------------------------------
X.KS
X.NH 2
X8-bit Characters
X.LP
XCharacters with the top bit set may be displayed, although
Xit is not yet possible to have null
X(\(fm\^\e\^0\^\(fm)
Xbytes in a file buffer.
XHow the characters are displayed varies between systems;
Xon UNIX, they will be shown as an octal escape sequence,
Xwhile on \%MS-DOS, OS/2 and QNX they will be shown as the actual
Xcharacter in the PC character set.
XThis can be controlled by setting the \fBcchars\fP and \fBmchars\fP
Xvariables; if these parameters are set,
Xcontrol- and meta-characters (respectively) are shown directly,
Xotherwise they are shown as some sequence of printable characters.
X.LP
XYou can use the \fB^_\fP (control-underscore) command to flip the
Xtop bit of the character the cursor is on.
XThis may be useful on systems where it is otherwise impossible
Xto enter 8-bit characters.
X.LP
XTabs are normally displayed as a series of spaces of the appropriate
Xlength (according to the \fBtabstops\fP parameter);
Xsetting \fBlist\fP mode will cause them to be displayed as a control
Xcharacter, as will unsetting the \fBtabs\fP parameter.
XHow the tab character is displayed is then under the control of
Xthe \fBcchars\fP parameter.
X.KE
X.\"---------------------------------------------------------------------------
X.KS
X.NH 2
XMouse Support
X.LP
XSome mouse support is available for micro-based systems and workstations.
XClicking the mouse button on:
X.IP "any line outside current window"
Xchanges current window to the one indicated by the mouse
X(can be used instead of \fBg\fP).
X.IP "top line of any window"
Xscrolls window downwards (same as \fB^Y\fP).
X.IP "bottom line of any window"
Xscrolls window upwards (same as \fB^E\fP).
X.IP "status line of any window"
Xshows current file and lines (same as \fB^G\fP).
X.IP "any text line of any window"
Xmoves text cursor as near as possible to mouse cursor.
X.LP
XAlso,
Xwindows can be resized by \*Qdragging\*U the appropriate status line
Xup or down with the mouse.
X.KE
X.\"---------------------------------------------------------------------------
X.KS
X.NH 2
XMiscellaneous
X.IP \(bu 5
XThe \fB:wn\fP (write file and edit next) command is provided, as per PC-vi.
X.KE
X.IP \(bu 5
XThere is no limit to the number or size of \fBmap\fPs which may be defined,
Xnor is there any fixed limit to the number of lines in a buffer.
X.IP \(bu 5
XThe \fBedit\fP parameter controls whether a buffer can be modified.
XThis may be used, together with the
X.B readonly
Xparameter,
Xto implement a nicer version of
X.B view (1)
Xthan
X\fBvi\fP's version, since it won't fool you into thinking that editing
Xthe buffer is in any way safe.
XBe warned: once having set \fBnoedit\fP, it is not possible to do a
X\fB:set edit\fP.
XIt's a one-way street.
X.IP \(bu 5
XThe \fBtimeout\fP parameter is implemented as a numeric value,
Xspecifying the number of milliseconds after which to assume that
Xno further input is available to continue with the parsing of a
X\fBmap\fP sequence.
XThis replaces \fBvi\fP's boolean parameter of the same name.
X.IP \(bu 5
XThe \fBvbell\fP parameter may be used to specify use of a visual,
Xrather than audible, bell, if this is available.
X.IP \(bu  5
XThe \fB:echo\fP command is available; it simply echoes its arguments,
Xafter expansion of % and # characters.
X.IP \(bu 5
XIn insert and replace modes,
X.B ^A
Xhas the same meaning as
X.B ^@
Xin vi, except that it
Xworks at any time,
Xnot just for the first character.
XAlso, typing
X\fB^B\fP\fIx\fP,
Xwhere
X.I x
Xis the name of a conjugate buffer, inserts the contents of that
Xbuffer into the input stream at that point.
XThe buffer named
X.B <
Xalways contains the last thing inserted,
Xso that
X.B ^B<
Xis the same as
X.B ^A .
X.\"===========================================================================
X.KS
X.NH 1
XDifferences
X.IP \(bu 5
XArgument handling is somewhat different; for instance,
X.B \-R
Xis not supported, but
X.qB "\-s\ parameter=value"
Xis, which is much more useful anyway.
X.KE
X.IP \(bu 5
XThe
X.B XVINIT
Xenvironment variable is read instead of
X.B EXINIT .
XWhilst no files are sourced
Xautomatically,
Xusers who wish to have a startup file can arrange it very easily.
X.B sh (1)
Xor
X.B ksh (1)
Xusers should add this line to their
X.B "$HOME/.profile" :
X.DS
X.B
XXVINIT=\(fmsource \fIxvi-startup-file\fP\|\(fm; export XVINIT
X.R
X.DE
X.B csh (1)
Xusers should add this to their
X.B "$HOME/.login" :
X.DS
X.B
Xsetenv XVINIT \(fmsource \fIxvi-startup-file\fP\|\(fm
X.R
X.DE
Xand \%MS-DOS users should add this to their
X.B autoexec.bat :
X.DS
X.B
Xset XVINIT=source \fIxvi-startup-file\fP
X.R
X.DE
X.IP \(bu 5
XThe \fBtags\fP parameter can be used to specify multiple tags files;
Xthese can be separated by either
X.qB "\^\e\ \|"
X(backslash space) or
X.qB ","
X(comma).
X.IP \(bu 5
XAlternate files are handled slightly differently,
Xowing to the presence of buffer and window handling.
XEssentially, when you close a buffer, its filename
Xis remembered as the alternate file;
Xwhen you invoke the \fB^^\fP or \fB:e #\fP commands,
Xthis filename is re-edited.
XNote that \fB^^\fP edits the alternate file in a new buffer window.
X.IP \(bu 5
XHitting the escape key while in the command line does not terminate input;
Xinstead, it cancels input, returning the prompt to the beginning
Xof the line.
XThis applies to input for
X.B : ,
X.B / ,
X.B ?
Xand
X.B ! .
X.IP \(bu 5
XCharacter-based yanks (or deletes) which span line boundaries are handled
Xcorrectly (\fBvi\fP gets this wrong).
END_OF_FILE
  if test 21826 -ne `wc -c <'xvi/doc/summary.ms'`; then
    echo shar: \"'xvi/doc/summary.ms'\" unpacked with wrong size!
  fi
  # end of 'xvi/doc/summary.ms'
fi
if test -f 'xvi/src/qnx.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xvi/src/qnx.h'\"
else
  echo shar: Extracting \"'xvi/src/qnx.h'\" \(4321 characters\)
  sed "s/^X//" >'xvi/src/qnx.h' <<'END_OF_FILE'
X/* Copyright (c) 1990,1991,1992 Chris and John Downey */
X/***
X
X* @(#)qnx.h	2.1 (Chris & John Downey) 7/29/92
X
X* program name:
X    xvi
X* function:
X    PD version of UNIX "vi" editor, with extensions.
X* module name:
X    qnx.h
X* module function:
X    Definitions for QNX system interface module.
X* history:
X    STEVIE - ST Editor for VI Enthusiasts, Version 3.10
X    Originally by Tim Thompson (twitch!tjt)
X    Extensive modifications by Tony Andrews (onecom!wldrdg!tony)
X    Heavily modified by Chris & John Downey
X
X***/
X
X#include <tcap.h>
X#include <stdlib.h>
X#include <time.h>
X#include <malloc.h>
X#include <lfsys.h>
X#include <process.h>
X
X#ifndef	HELPFILE
X#   define	HELPFILE	"/user/local/bin/xvi.help"
X#endif
X
X/*
X * These are the buffer sizes we use for reading & writing files.
X */
X#define SETVBUF_AVAIL
X#define	READBUFSIZ	4096
X#define	WRTBUFSIZ	4096
X
X/*
X * Execute a command in a subshell.
X */
X#define	call_system(s)	system(s)
X
X/*
X * System-dependent constants.
X */
X#define	MAXPATHLEN	79	/* maximum length of full path name */
X#define	MAXNAMLEN	16	/* maximum length of file name */
X#define	DIRSEPS		"/^"	/*
X				 * directory separators within
X				 * pathnames
X				 */
X
X/*
X * Under QNX, characters with the top bit set are perfectly valid
X * (although not necessarily always what you want to see).
X */
X#define	DEF_CCHARS	TRUE
X#define	DEF_MCHARS	TRUE
X
X/*
X * Default file format.
X */
X#define DEF_TFF		fmt_QNX
X
X#define	Rows		tcap_entry.term_num_rows
X#define	Columns		tcap_entry.term_num_cols
X
X/*
X * Size of buffer for file i/o routines.
X * The SETVBUF_AVAIL forces the file i/o routines to
X * use a large buffer for reading and writing, and
X * this results in a large performance improvement.
X */
X#define SETVBUF_AVAIL
X#define BIGBUF		16384
X
X/*
X * Macros to open files in binary mode,
X * and to expand filenames.
X */
X#define fopenrb(f)	fopen((f),"r")
X#define fopenwb(f)	fopen((f),"w")
X
X/*
X * Terminal driving functions.
X *
X * Assume TCAP driver.
X */
X#define	erase_line()	term_clear(_CLS_EOL)
X#define	insert_line()	term_esc(tcap_entry.disp_insert_line)
X#define	delete_line()	term_esc(tcap_entry.disp_delete_line)
X#define	erase_display()	term_clear(_CLS_SCRH)
X#define	invis_cursor()
X#define	vis_cursor()
X
X#define	cost_goto	8
X
X#define	can_ins_line	FALSE
X#define	can_del_line	FALSE
X
Xextern	bool_t		can_scroll_area;
Xextern	void		(*up_func)(int, int, int);
Xextern	void		(*down_func)(int, int, int);
X#define	scroll_up	(*up_func)
X#define	scroll_down	(*down_func)
X
X#define tty_linefeed()	putchar('\n')
Xextern	bool_t		can_scroll_area;
X#define	can_inschar	FALSE
X#define	inschar(c)
X
X/*
X * Colour handling: QNX attributes.
X * These are defined so as to work on both colour and monochrome screens.
X *
X * The colour word contains the following fields:
X *
X *	eBBB_FFF__uihb
X *
X * where:
X *	e	means enable colour
X *	BBB	is the background colour
X *	FFF	is the foreground colour
X *	u	means underline
X *	i	means inverse
X *	h	means high brightness
X *	b	means blinking
X *
X * The colours that may be represented using the three bits of FFF or
X * BBB are:
X *	0	black		4	red
X *	1	blue		5	magenta
X *	2	green		6	yellow
X *	3	cyan		7	white
X *
X * We always set 'e', sometimes 'h' and never 'u', or 'b'.
X * 'i' is set for colours which want to be inverse in monochrome.
X */
X#define	DEF_COLOUR	(0x8000 | 0x00 | 0x0700)   /* white on black      */
X#define	DEF_SYSCOLOUR	(0x8000 | 0x00 | 0x0700)   /* white on black      */
X#define	DEF_STCOLOUR	(0x8000 | 0x06 | 0x6100)   /* bright cyan on blue */
X#define	DEF_ROSCOLOUR	(0x8000 | 0x06 | 0x7400)   /* bright white on red */
X
X/*
X * Declarations for OS-specific routines in qnx.c.
X */
Xextern	int		inchar(long);
Xextern	void		sys_init(void);
Xextern	void		sys_exit(int);
Xextern	bool_t		can_write(char *);
Xextern	bool_t		exists(char *);
Xextern	int		call_shell(char *);
Xextern	void		alert(void);
Xextern	void		delay(void);
Xextern	void		outchar(int);
Xextern	void		outstr(char *);
Xextern	void		flush_output(void);
Xextern	void		set_colour(int);
Xextern	void		tty_goto(int, int);
Xextern	void		co_up(int, int, int);
Xextern	void		co_down(int, int, int);
Xextern	void		vt_up(int, int, int);
Xextern	void		vt_down(int, int, int);
Xextern	void		sys_startv(void);
Xextern	void		sys_endv(void);
Xextern	char		*tempfname(char *);
Xextern	bool_t		sys_pipe P((char *, int (*)(FILE *), long (*)(FILE *)));
Xextern	char		*fexpand P((char *));
END_OF_FILE
  if test 4321 -ne `wc -c <'xvi/src/qnx.h'`; then
    echo shar: \"'xvi/src/qnx.h'\" unpacked with wrong size!
  fi
  # end of 'xvi/src/qnx.h'
fi
if test -f 'xvi/src/termcap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xvi/src/termcap.c'\"
else
  echo shar: Extracting \"'xvi/src/termcap.c'\" \(26020 characters\)
  sed "s/^X//" >'xvi/src/termcap.c' <<'END_OF_FILE'
X/* Copyright (c) 1990,1991,1992 Chris and John Downey */
X#ifndef lint
Xstatic char *sccsid = "@(#)termcap.c	2.1 (Chris & John Downey) 7/29/92";
X#endif
X
X/***
X
X* program name:
X    xvi
X* function:
X    PD version of UNIX "vi" editor, with extensions.
X* module name:
X    termcap.c
X* module function:
X    Termcap terminal interface module.
X
X    The following capabilities are not yet used, but may be added in future
X    to improve efficiency (at the expense of code compactness):
X
X	cr	str	Carriage return, (default ^M)
X	dC	num	Number of milliseconds of cr delay needed
X	nc	bool	No correctly working carriage return (DM2500,H2000)
X	xr	bool	Return acts like ce \r \n (Delta Data)
X
X	ch	str	Like cm but horizontal motion only, line stays same
X	DO	str	down N lines
X	up	str	Upline (cursor up)
X	UP	str	up N lines
X	LE	str	left N chars
X	RI	str	right N spaces
X	ll	str	Last line, first column
X	sc	str	save cursor
X	rc	str	restore cursor from last "sc"
X	dB	num	Number of milliseconds of bs delay needed
X
X	AL	str	add N new blank lines
X	DL	str	delete N lines
X
X	dc	str	Delete character
X	dm	str	Delete mode (enter)
X	ed	str	End delete mode
X	ip	str	Insert pad after character inserted
X	in	bool	Insert mode distinguishes nulls on display
X	mi	bool	Safe to move while in insert mode
X
X	dF	num	Number of milliseconds of ff delay needed
X	cd	str	Clear to end of display
X
X	xs	bool	Standout not erased by writing over it (HP 264?)
X	ms	bool	Safe to move while in standout and underline mode
X
X* history:
X    STEVIE - ST Editor for VI Enthusiasts, Version 3.10
X    Originally by Tim Thompson (twitch!tjt)
X    Extensive modifications by Tony Andrews (onecom!wldrdg!tony)
X    Heavily modified by Chris & John Downey
X
X***/
X
X#include "xvi.h"
X
X/* #define	SG_TEST	1 */
X
Xstatic	void	xyupdate P((void));
Xstatic	void	fail P((char *));
Xstatic	void	set_scroll_region P((int, int));
X
X/*
X * These are used to optimise output - they hold the current
X * "real" and "virtual" coordinates of the cursor, i.e. where
X * it is and where it is supposed to be.
X *
X * The "optimise" variable says whether we should cache cursor
X * positions or should just go to the place asked; it is
X * unset at the start so that the first goto sets things up.
X *
X * Note that the functions "outchar" and "outstr" should be
X * used for strings of ordinary characters; stdio primitives
X * are used internally to put out escape sequences.
X */
Xstatic	int	real_row = 0, real_col = 0;
Xstatic	int	virt_row = 0, virt_col = 0;
Xstatic	bool_t	optimise = FALSE;
X
X/*
X * Termcap-related declarations.
X */
Xextern	char	*tgetstr();
Xextern	char	*tgoto();
X
X/*
X * Exported.
X */
Xint		cost_goto = 0;		/* cost of doing a goto */
Xbool_t		can_scroll_area = FALSE; /* true if we can set scroll region */
Xbool_t		can_del_line;		/* true if we can delete lines */
Xbool_t		can_ins_line;		/* true if we can insert lines */
Xbool_t		can_inschar;		/* true if we can insert characters */
Xunsigned int	CO = 0;			/* screen dimensions; 0 at start */
Xunsigned int	LI = 0;
X
X/*
X * Needed by termcap library.
X */
Xchar	PC;				/* pad character */
X
X/*
X * Internal string, num and boolean defs.
X */
Xstatic	char	*KS, *KE;		/* keypad transmit start/end */
Xstatic	char	*VS, *VE;		/* visual start/end */
Xstatic	char	*TI, *TE;		/* cursor motion start/end */
Xstatic	char	*CE, *CL;		/* erase line/display */
Xstatic	char	*AL, *DL;		/* insert/delete line */
Xstatic	char	*IC, *IM, *EI;		/* insert character / insert mode */
Xstatic	char	*CM;			/* cursor motion string */
Xstatic	char	*HO;			/* cursor to home position */
Xstatic	char	*CS;			/* change scroll region */
Xstatic	char	*sf, *sr;		/* scroll forward/reverse 1 line */
Xstatic	char	*SF, *SR;		/* scroll forward/reverse n lines */
Xstatic	char	*SO, *SE;		/* standout mode start/end */
X
Xstatic	char	*VB;			/* visual bell */
X
Xstatic	char	*colours[10];		/* colour caps c0 .. c9 */
Xstatic	int	ncolours;		/* number of colour caps we have */
X
Xstatic	char	BC;			/* backspace char */
Xstatic	char	ND;			/* backspace char */
Xstatic	char	DO;			/* down one line */
X
Xstatic	bool_t	can_backspace;		/* true if can backspace (bs/bc) */
Xstatic	bool_t	can_fwdspace = FALSE;	/* true if can forward space (nd) */
Xstatic	bool_t	can_movedown = FALSE;	/* true if can move down (do) */
Xstatic	bool_t	auto_margins;		/* true if AM is set */
X
X/*
X * We use this table to perform mappings from cursor keys
X * into appropriate xvi input keys (in command mode).
X */
Xstatic char arrow_keys[] = {
X    K_UARROW,	'\0',
X    K_DARROW,	'\0',
X    K_RARROW,	'\0',
X    K_LARROW,	'\0',
X    CTRL('B'),	'\0',
X    CTRL('F'),	'\0',
X    K_HELP,	'\0',
X};
Xstatic struct {
X    char	*key_tcname;
X    char	*key_rhs;
X} keys[] = {
X    "ku",	arrow_keys + 0,	/* up */
X    "kd",	arrow_keys + 2,	/* down */
X    "kr",	arrow_keys + 4,	/* right */
X    "kl",	arrow_keys + 6,	/* left */
X    "kP",	arrow_keys + 8,	/* page up */
X    "kN",	arrow_keys + 10,/* page down */
X    "kh",	"H",		/* home */
X    "k0",	"#0",		/* function key 0 */
X    "k1",	arrow_keys + 12,/* help */
X    "k2",	"#2",		/* function key 2 */
X    "k3",	"#3",		/* function key 3 */
X    "k4",	"#4",		/* function key 4 */
X    "k5",	"#5",		/* function key 5 */
X    "k6",	"#6",		/* function key 6 */
X    "k7",	"#7",		/* function key 7 */
X    "k8",	"#8",		/* function key 8 */
X    "k9",	"#9",		/* function key 9 */
X    NULL
X};
X
X/*
X * Standout glitch: number of spaces left when entering or leaving
X * standout mode.
X *
X * This abomination is still needed for some terminals (e.g.
X * Televideo).
X */
Xint		SG;
X
X/*
X * Used by scroll region optimisation.
X */
Xstatic int	s_top = 0, s_bottom = 0;
X
X/*
X * Used for colour-setting optimisation.
X */
X#define	NO_COLOUR	-1
Xstatic	int		old_colour = NO_COLOUR;
X
X/*
X * Flush any pending output, including cursor position.
X */
Xvoid
Xflush_output()
X{
X    xyupdate();
X    oflush();
X}
X
X/*
X * Put out a "normal" character, updating the cursor position.
X */
Xvoid
Xoutchar(c)
Xregister int	c;
X{
X    xyupdate();
X    real_col++;
X    virt_col++;
X    if (real_col >= CO) {
X	if (auto_margins) {
X	    virt_col = (real_col = 0);
X	    virt_row = (real_row += 1);
X	} else {
X	    optimise = FALSE;
X	}
X    }
X    moutch(c);
X}
X
X/*
X * Put out a "normal" string, updating the cursor position.
X */
Xvoid
Xoutstr(s)
Xregister char	*s;
X{
X    xyupdate();
X    while (*s != '\0') {
X	real_col++;
X	virt_col++;
X	moutch(*s++);
X    }
X
X    /*
X     * We only worry about whether we have hit the right-hand margin
X     * at the end of the string; this is okay so long as we can trust
X     * the calling code not to use outstr if the string is going to
X     * wrap around.
X     */
X    if (real_col >= CO) {
X	if (auto_margins) {
X	    virt_col = (real_col %= CO);
X	    virt_row = (real_row += 1);
X	} else {
X	    optimise = FALSE;
X	}
X    }
X}
X
X/*
X * This routine is called by tty_open() if for some reason the terminal
X * is unsuitable.
X */
Xstatic void
Xfail(str)
Xchar	*str;
X{
X    /*
X     * Assume we are in raw mode already, so set back into cooked.
X     */
X    sys_endv();
X
X    (void) fputs(str, stderr);
X    putc('\n', stderr);
X
X    exit(2);
X}
X
X/*
X * Look up term entry in termcap database, and set up all the strings.
X */
Xvoid
Xtty_open(prows, pcolumns)
Xunsigned int	*prows;
Xunsigned int	*pcolumns;
X{
X    char	tcbuf[1024];		/* buffer for termcap entry */
X    char	*termtype;		/* terminal type */
X    static	char strings[512];	/* space for storing strings */
X    char	*strp = strings;	/* ptr to space left in strings */
X    char	*cp;			/* temp for single char strings */
X    int	i;
X
X    termtype = getenv("TERM");
X    if (termtype == NULL) {
X	fail("Can't find your terminal type.");
X    }
X    switch (tgetent(tcbuf, termtype)) {
X    case -1:
X	fail("Can't open termcap.");
X	/*NOTREACHED*/
X    case 0:
X	fail("Can't find entry for your terminal in termcap.");
X	/*NOTREACHED*/
X    }
X
X    /*
X     * Booleans.
X     */
X    auto_margins = (bool_t) (tgetflag("am") && !tgetflag("xn"));
X    can_backspace = (bool_t) tgetflag("bs");
X
X    /*
X     * Integers.
X     */
X
X    /*
X     * Screen dimensions. Ask termcap for its values if we haven't
X     * already got any.
X     */
X    if (*pcolumns == 0) {
X	int iv;
X
X	iv = tgetnum("co");
X	if (iv <= 0) {
X	    fail("`co' entry in termcap is invalid or missing.");
X	}
X	*pcolumns = CO = (unsigned) iv;
X    } else {
X	CO = *pcolumns;
X    }
X    if (*prows == 0) {
X	int iv;
X
X	iv = tgetnum("li");
X	if (iv <= 0) {
X	    fail("`li' entry in termcap is invalid or missing.");
X	}
X	*prows = LI = (unsigned) iv;
X    } else {
X	LI = *prows;
X    }
X
X    SG = tgetnum("sg");
X    if (SG < 0) {
X	SG = 0;
X    }
X#ifdef SG_TEST
X    SG++;
X#endif
X
X    /*
X     * Single-char strings - some of these may be strings,
X     * but we only want them if they are single characters.
X     * This is because the optimisation calculations get
X     * extremely complicated if we have to work out the
X     * number of characters used to do a cursor move in
X     * every possible way; we basically assume that we
X     * don't have infinite amounts of time or space.
X     */
X    cp = tgetstr("pc", &strp);	/* pad character */
X    if (cp != NULL)
X	PC = *cp;
X
X    cp = tgetstr("bc", &strp);	/* backspace char if not ^H */
X    if (cp != NULL && cp[1] == '\0')
X	BC = *cp;
X    else
X	BC = '\b';
X
X    cp = tgetstr("nd", &strp);	/* non-destructive forward space */
X    if (cp != NULL && cp[1] == '\0') {
X	ND = *cp;
X	can_fwdspace = TRUE;
X    }
X
X#ifndef	AIX
X    /*
X     * The termcap emulation (over terminfo) on an RT/PC
X     * (the only AIX machine I have experience of) gets
X     * the "do" capability wrong; it moves the cursor
X     * down a line, but also sends a carriage return.
X     * We must therefore avoid use of "do" under AIX.
X     */
X
X    cp = tgetstr("do", &strp);	/* down a line */
X    if (cp != NULL && cp[1] == '\0') {
X	DO = *cp;
X	can_movedown = TRUE;
X    }
X#endif
X
X    /*
X     * Strings.
X     */
X    KS = tgetstr("ks", &strp);
X    KE = tgetstr("ke", &strp);
X    VS = tgetstr("vs", &strp);
X    VE = tgetstr("ve", &strp);
X    TI = tgetstr("ti", &strp);
X    TE = tgetstr("te", &strp);
X    CE = tgetstr("ce", &strp);
X    CL = tgetstr("cl", &strp);
X    AL = tgetstr("al", &strp);
X    DL = tgetstr("dl", &strp);
X    IC = tgetstr("ic", &strp);
X    IM = tgetstr("im", &strp);
X    EI = tgetstr("ei", &strp);
X    CM = tgetstr("cm", &strp);
X    HO = tgetstr("ho", &strp);
X    CS = tgetstr("cs", &strp);
X    sf = tgetstr("sf", &strp);
X    sr = tgetstr("sr", &strp);
X    SF = tgetstr("SF", &strp);
X    SR = tgetstr("SR", &strp);
X    SO = tgetstr("so", &strp);
X    SE = tgetstr("se", &strp);
X    VB = tgetstr("vb", &strp);
X
X    /*
X     * Find up to 10 colour capabilities.
X     */
X    for (ncolours = 0; ncolours < 10; ncolours++) {
X	char	capname[3];
X	char	*cap;
X
X	capname[0] = 'c';
X	capname[1] = ncolours + '0';	/* assumes ASCII - nasty */
X	capname[2] = '\0';
X	cap = tgetstr(capname, &strp);
X	if (cap == NULL)
X	    break;
X	colours[ncolours] = cap;
X    }
X
X    if (CM == NULL) {
X	fail("Xvi can't work without cursor motion.");
X    }
X
X    /*
X     * This may not be quite right, but it will be close.
X     */
X    cost_goto = strlen(CM) - 1;
X
X    /*
X     * Set these variables as appropriate.
X     */
X    can_del_line = (DL != NULL);
X    can_ins_line = (AL != NULL);
X    can_inschar = (IC != NULL) || (IM != NULL);
X    can_scroll_area = (
X	(CS != NULL)
X	&&
X	(SF != NULL || sf != NULL || DL != NULL || can_movedown)
X	&&
X	(SR != NULL || sr != NULL || AL != NULL)
X    );
X
X    /*
X     * Enter cursor arrow keys etc into xvi map table.
X     */
X    for (i = 0; keys[i].key_tcname != NULL; i++) {
X	char	*lhs;
X
X	lhs = tgetstr(keys[i].key_tcname, &strp);
X	if (lhs != NULL) {
X	    xvi_keymap(lhs, keys[i].key_rhs);
X	}
X    }
X}
X
X/*
X * Functions called to perform screen manipulations..
X */
Xstatic enum {
X	m_SYS = 0,
X	m_VI
X}	termmode;
X
X/*
X * Called by sys_startv(), just after switching to raw/cbreak mode.
X * Assumes tty_open() has been called.
X */
Xvoid
Xtty_startv()
X{
X    if (termmode == m_SYS) {
X	if (TI != NULL)
X	    tputs(TI, (int) LI, foutch);
X	if (VS != NULL)
X	    tputs(VS, (int) LI, foutch);
X	if (KS != NULL)
X	    tputs(KS, (int) LI, foutch);
X    }
X    old_colour = NO_COLOUR;
X    optimise = FALSE;
X    termmode = m_VI;
X}
X
X/*
X * Called by sys_endv(), just before returning to cooked mode.
X *
X * tty_endv() can be called when we're already in system mode, so we
X * have to check.
X */
Xvoid
Xtty_endv()
X{
X    if (termmode == m_VI) {
X	if (can_scroll_area) {
X	    set_scroll_region(0, (int) LI - 1);
X	}
X	if (KE != NULL)
X	    tputs(KE, (int) LI, foutch);
X	if (VE != NULL)
X	    tputs(VE, (int) LI, foutch);
X	if (TE != NULL)
X	    tputs(TE, (int) LI, foutch);
X	termmode = m_SYS;
X    }
X    oflush();
X}
X
X/*
X * Erase the entire current line.
X */
Xvoid
Xerase_line()
X{
X    xyupdate();
X    if (CE != NULL)
X	tputs(CE, (int) LI, foutch);
X}
X
X/*
X * Insert one line.
X */
Xvoid
Xinsert_line()
X{
X    xyupdate();
X    if (AL != NULL)
X	tputs(AL, (int) LI, foutch);
X}
X
X/*
X * Delete one line.
X */
Xvoid
Xdelete_line()
X{
X    xyupdate();
X    if (DL != NULL)
X	tputs(DL, (int) LI, foutch);
X}
X
X/*
X * Erase display (may optionally home cursor).
X */
Xvoid
Xerase_display()
X{
X    /*
X     * Don't know where the cursor goes, so turn optim
X     * back off until we can re-sync the position.
X     */
X    optimise = FALSE;
X    old_colour = NO_COLOUR;
X    if (CL != NULL)
X	tputs(CL, (int) LI, foutch);
X    oflush();
X}
X
X/*
X * Internal routine: used to set the scroll region to an area
X * of the screen. We only change it if necessary.
X *
X * Assumes CS is available, i.e. can_scroll_area is TRUE.
X */
Xstatic void
Xset_scroll_region(top, bottom)
Xint	top, bottom;
X{
X    if (top != s_top || bottom != s_bottom) {
X	tputs(tgoto(CS, bottom, top), bottom - top, foutch);
X	s_top = top;
X	s_bottom = bottom;
X	/*
X	 * Some terminals move the cursor when we set scroll region.
X	 */
X	optimise = FALSE;
X    }
X}
X
X/*
X * Scroll up an area of the screen.
X */
Xvoid
Xscroll_up(start_row, end_row, nlines)
Xint	start_row, end_row, nlines;
X{
X    if (!can_scroll_area)
X	return;
X
X    /*
X     * Set the scrolling region, if it is different
X     * from the one there already. Note that we used
X     * to set the scroll region after moving the cursor,
X     * because we don't know how the terminal will
X     * respond to movements when a scroll region is
X     * set; some terminals move relative to the top
X     * of the current scroll region. However, some
X     * terminals (e.g.vt100) actually move the cursor
X     * when the scroll region is set, so you can't win.
X     */
X    set_scroll_region(start_row, end_row);
X
X    /*
X     * Make sure we are in the "right" place before calling
X     * xyupdate(), or we will get infinite recursion.
X     * The "right" place is:
X     *	if we have sf or SF:
X     *		assume they will work with the cursor placed
X     *		anywhere inside the scroll region; so if we
X     *		are already there, we don't need to move.
X     *		This is a big win for normal editing usage.
X     *	if no sf or SF capability:
X     *		if we have a dl capability:
X     *			the first row of the area
X     *			Only move the cursor to that row if it is
X     *			not already there; this saves a lot of nasty
X     *			"flicker" of the cursor.
X     *		else:
X     *			we have to use the "do" capability,
X     *			on the bottom row of the scroll area.
X     *			Assume it is safe to do this, because
X     *			optimise will be turned off afterwards,
X     *			and the caller save the cursor anyway.
X     */
X    if (SF != NULL || sf != NULL) {
X	if (virt_row < start_row || virt_row > end_row) {
X	    virt_row = start_row;
X	    virt_col = 0;
X	}
X    } else {	/* don't have sf or SF */
X	if (DL != NULL) {
X	    if (virt_row != start_row) {
X		virt_row = start_row;
X		virt_col = 0;
X	    }
X	} else {	/* no DL; use DO */
X	    if (virt_row != end_row) {
X		virt_row = end_row;
X		virt_col = 0;
X	    }
X	}
X    }
X
X    xyupdate();
X
X    /*
X     * And scroll the area, either by an explicit sequence
X     * or by the appropriate number of line insertions.
X     */
X    if (SF != NULL && (nlines > 1 || sf == NULL)) {
X	static Flexbuf	SFbuf;
X
X	flexclear(&SFbuf);
X	(void) lformat(&SFbuf, SF, nlines);
X	(void) tputs(flexgetstr(&SFbuf), end_row - start_row, foutch);
X    } else if (sf != NULL) {
X	int	i;
X
X	for (i = 0; i < nlines; i++) {
X	    tputs(sf, end_row - start_row, foutch);
X	}
X    } else if (DL != NULL) {
X	int	i;
X
X	for (i = 0; i < nlines; i++) {
X	    tputs(DL, end_row - start_row, foutch);
X	}
X    } else {
X	int	i;
X
X	for (i = 0; i < nlines; i++) {
X	    moutch(DO);
X	}
X    }
X
X    /*
X     * Set the scrolling region back to how it should be.
X     */
X    set_scroll_region(0, (int) LI - 1);
X
X    /*
X     * We don't know what this does to the cursor position;
X     * so the safest thing to do here is to assume nothing.
X     */
X    optimise = FALSE;
X}
X
X/*
X * Scroll down an area of the screen.
X */
Xvoid
Xscroll_down(start_row, end_row, nlines)
Xint	start_row, end_row, nlines;
X{
X    if (CS == NULL || (SR == NULL && sr == NULL && AL == NULL))
X	return;
X
X    /*
X     * Set the scrolling region, if it is different
X     * from the one there already. Note that we used
X     * to set the scroll region after moving the cursor,
X     * because we don't know how the terminal will
X     * respond to movements when a scroll region is
X     * set; some terminals move relative to the top
X     * of the current scroll region. However, some
X     * terminals (e.g.vt100) actually move the cursor
X     * when the scroll region is set, so you can't win.
X     */
X    set_scroll_region(start_row, end_row);
X
X    /*
X     * Make sure we are in the "right" place before calling
X     * xyupdate(), or we will get infinite recursion.
X     * The "right" place is:
X     *	if no sr or SR capability:
X     *		the first row of the area, so AL will work.
X     *		Only move the cursor to that row if it is
X     *		not already there; this saves a lot of nasty
X     *		"flicker" of the cursor.
X     *	if we have sr or SR:
X     *		It would be nice to assume that "sr" / "SR"
X     *		would work anywhere within the scroll region;
X     *		unfortunately, this just isn't true. Sigh.
X     *		So we use the first row here too.
X     */
X    if (virt_row != start_row) {
X	virt_row = start_row;
X	virt_col = 0;
X    }
X
X    xyupdate();
X
X    /*
X     * And scroll the area, either by an explicit sequence
X     * or by the appropriate number of line insertions.
X     */
X    if (SR != NULL && (nlines > 1 || sr == NULL)) {
X	static Flexbuf	SRbuf;
X
X	flexclear(&SRbuf);
X	(void) lformat(&SRbuf, SR, nlines);
X	(void) tputs(flexgetstr(&SRbuf), end_row - start_row, foutch);
X    } else if (sr != NULL) {
X	int	i;
X
X	for (i = 0; i < nlines; i++) {
X	    tputs(sr, end_row - start_row, foutch);
X	}
X    } else {
X	int	i;
X
X	for (i = 0; i < nlines; i++) {
X	    tputs(AL, end_row - start_row, foutch);
X	}
X    }
X
X    /*
X     * Set the scrolling region back to how it should be.
X     */
X    set_scroll_region(0, (int) LI - 1);
X
X    /*
X     * We don't know what this does to the cursor position;
X     * so the safest thing to do here is to assume nothing.
X     */
X    optimise = FALSE;
X}
X
X/*
X * Set the specified colour. Just does standout/standend mode for now.
X * Optimisation here to avoid setting standend when we aren't in
X * standout; assumes calling routines are well-behaved (i.e. only do
X * screen movement in P_colour) or some terminals will write garbage
X * all over the screen.
X */
Xvoid
Xset_colour(c)
Xint	c;
X{
X    if (c == old_colour)
X	return;
X
X    xyupdate();
X
X    if (c < ncolours) {
X	/*
X	 * Within the range of possible colours.
X	 */
X	tputs(colours[c], 1, foutch);
X    } else {
X	/*
X	 * No colour caps, so use standout/standend.
X	 * Map colour 2..9 => standout, 0 & 1 => normal.
X	 * This is because the default values are:
X	 *
X	 *	systemcolour	0
X	 *	colour		1
X	 *	statcolour	2
X	 *	roscolour	3
X	 */
X
X	if (c == 1)
X	    c = 0;
X
X	if (c == old_colour)
X	    return;
X
X	if (c != 0) {
X	    if (SO != NULL) {
X		tputs(SO, 1, foutch);
X#ifdef SG_TEST
X		outchar('+');
X#endif
X	    }
X	} else {
X	    if (SE != NULL) {
X#ifdef SG_TEST
X		outchar('-');
X#endif
X		tputs(SE, 1, foutch);
X	    }
X	}
X    }
X
X    old_colour = c;
X}
X
X/*
X * Insert the given character at the cursor position.
X */
Xvoid
Xinschar(c)
Xchar	c;
X{
X    xyupdate();
X    if (IM != NULL)
X	tputs(IM, (int) LI, foutch);
X    if (IC != NULL)
X	tputs(IC, (int) LI, foutch);
X    outchar(c);
X    if (EI != NULL)
X	tputs(EI, (int) LI, foutch);
X}
X
X/*
X * Goto the specified location.
X */
Xvoid
Xtty_goto(row, col)
Xint	row, col;
X{
X    virt_row = row;
X    virt_col = col;
X}
X
X/*
X * Output a linefeed.
X *
X * This can only be called safely when the virtual cursor is at the
X * bottom left corner of the display area.
X */
Xvoid
Xtty_linefeed()
X{
X    xyupdate();
X    moutch('\n');
X}
X
X/*
X * Beep at the user.
X *
X * Use visual bell if it's there and the vbell parameter says to use it.
X */
Xvoid
Xalert()
X{
X    if (Pb(P_vbell) && VB != NULL) {
X	xyupdate();
X	tputs(VB, (int) LI, foutch);
X	optimise = FALSE;
X    } else {
X	moutch('\007');
X    }
X    oflush();
X}
X
X/*
X * This is an internal routine which is called whenever we want
X * to be sure that the cursor position is correct; it looks at
X * the cached values of the desired row and column, compares them
X * with the recorded "real" row and column, and outputs whatever
X * escape codes are necessary to put the cursor in the right place.
X *
X * Some optimisation is done here, because quite often this can be
X * a big win; many cursor movements asked for by the editor are
X * quite simple to do, only costing a few output bytes and little
X * work.  If "optimise" is FALSE, this optimisation is not done.
X * Other routines in this file can use this to turn optimisation
X * off temporarily if they "lose" the cursor.
X */
Xstatic void
Xxyupdate()
X{
X    register int	hdisp, vdisp;
X    register int	totaldisp;
X
X    /*
X     * Horizontal and vertical displacements needed
X     * to get the cursor to the right position.
X     * These are positive for downward and rightward movements.
X     *
X     * Totaldisp is the total absolute displacement.
X     */
X    hdisp = virt_col - real_col;
X    vdisp = virt_row - real_row;
X
X    totaldisp = ((vdisp < 0) ? -vdisp : vdisp) +
X	    ((hdisp < 0) ? -hdisp : hdisp);
X
X    /*
X     * First, ensure that the current scroll region
X     * contains the intended cursor position.
X     */
X    if (virt_row < s_top || virt_row > s_bottom) {
X	if (can_scroll_area)
X	    set_scroll_region(0, (int) LI - 1);
X    }
X
X    /*
X     * If we want to go near the top of the screen, it may be
X     * worth using HO.  We musn't do this if we would thereby
X     * step outside the current scroll region.  Also, we can
X     * only move to a position near home if we can use "down"
X     * and "right" movements after having gone to "home".
X     */
X    if (
X	(
X	    HO != NULL		/* "home" capability exists */
X	)
X	&&				/* AND */
X	(
X	    !can_scroll_area	/* no scroll regions */
X	    ||
X	    s_top == 0		/* or doesn't affect us */
X	)
X	&&				/* AND */
X	(
X	    virt_col == 0		/* we're not moving right */
X	    ||
X	    can_fwdspace		/* or we can if we want */
X	)
X	&&				/* AND */
X	(
X	    virt_row == 0		/* we're not moving down */
X	    ||
X	    can_movedown		/* or we can if we want */
X	)
X    ) {
X	/*
X	 * Cost of using the "ho" capability.
X	 */
X	static unsigned		cost_home;
X
X	/*
X	 * Possible total cost of getting to the desired
X	 * position if we use "ho".
X	 */
X	register unsigned	netcost;
X
X	if (cost_home == 0)
X	    cost_home = strlen(HO);
X	netcost = cost_home + virt_row + virt_col;
X
X	/*
X	 * Only use home if it is worth it, and if
X	 * either we are already below where we want
X	 * to be on the screen, or optimise is off
X	 * (and hence relative movements inappropriate).
X	 */
X	if (netcost < cost_goto
X	    &&
X	    (!optimise || real_row > virt_row)) {
X	    tputs(HO, (int) LI, foutch);
X	    real_row = real_col = 0;
X	    totaldisp = (hdisp = virt_col) + (vdisp = virt_row);
X	    optimise = TRUE;
X	}
X    }
X
X    if (!optimise) {
X	/*
X	 * If optim is off, we should just go to the
X	 * specified place; we can then turn it on,
X	 * because we know where the cursor is.
X	 */
X	tputs(tgoto(CM, virt_col, virt_row), (int) LI, foutch);
X	optimise = TRUE;
X    } else {
X	if (vdisp != 0 || hdisp != 0) {
X	    /*
X	     * Update the cursor position in the best way.
X	     */
X
X	    if (
X		(totaldisp < cost_goto)
X		&&
X		(
X		    hdisp == 0
X		    ||
X		    (hdisp > 0 && can_fwdspace)
X		    ||
X		    (hdisp < 0 && can_backspace)
X		)
X		&&
X		(
X		    vdisp >= 0
X		    &&
X		    can_movedown
X		)
X	    ) {
X		/*
X		 * A small motion; worth looking at
X		 * doing it with BS, ND and DO.
X		 * No UP handling yet, and we don't
X		 * really care about whether ND is
X		 * more than one char - this can make
X		 * the output really inefficient.
X		 */
X
X		int	n;
X
X		/*
X		 * Move down to the right line.
X		 */
X		for (n = vdisp; n > 0; n--) {
X		    moutch(DO);
X		}
X
X		if (hdisp < 0) {
X		    if (virt_col == 0) {
X			moutch('\r');
X		    } else {
X			for (n = hdisp; n < 0; n++) {
X			    moutch(BC);
X			}
X		    }
X		} else if (hdisp > 0) {
X		    for (n = hdisp; n > 0; n--) {
X			moutch(ND);
X		    }
X		}
X
X	    } else if (vdisp == 0) {
X
X		/*
X		 * Same row.
X		 */
X		if (virt_col == 0) {
X		    /*
X		     * Start of line - easy.
X		     */
X		    moutch('\r');
X
X		} else if (can_fwdspace && hdisp > 0 &&
X			    hdisp < cost_goto) {
X		    int	n;
X
X		    /*
X		     * Forward a bit.
X		     */
X		    for (n = hdisp; n > 0; n--) {
X			moutch(ND);
X		    }
X
X		} else if (can_backspace && hdisp < 0 &&
X			    (-hdisp) < cost_goto) {
X		    int	n;
X
X		    /*
X		     * Back a bit.
X		     */
X		    for (n = hdisp; n < 0; n++) {
X			moutch(BC);
X		    }
X
X		} else {
X		    /*
X		     * Move a long way.
X		     */
X		    tputs(tgoto(CM, virt_col, virt_row),
X				1, foutch);
X		}
X	    } else if (virt_col == 0) {
X
X		/*
X		 * Different row, column 0.
X		 */
X		if (vdisp > 0 && vdisp + 1 < cost_goto) {
X		    /*
X		     * Want to move downwards.
X		     * This happens a lot.
X		     */
X		    int	n;
X
X		    if (real_col != 0)
X			moutch('\r');
X		    for (n = vdisp; n > 0; n--) {
X			moutch('\n');
X		    }
X		} else {
X		    /*
X		     * Want to move upwards.
X		     */
X		    tputs(tgoto(CM, virt_col, virt_row),
X			    (int) LI, foutch);
X		}
X	    } else {
X		/*
X		 * Give up - do a goto.
X		 */
X		tputs(tgoto(CM, virt_col, virt_row),
X			(int) LI, foutch);
X	    }
X	}
X    }
X    real_row = virt_row;
X    real_col = virt_col;
X}
END_OF_FILE
  if test 26020 -ne `wc -c <'xvi/src/termcap.c'`; then
    echo shar: \"'xvi/src/termcap.c'\" unpacked with wrong size!
  fi
  # end of 'xvi/src/termcap.c'
fi
echo shar: End of archive 11 \(of 18\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 18 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
