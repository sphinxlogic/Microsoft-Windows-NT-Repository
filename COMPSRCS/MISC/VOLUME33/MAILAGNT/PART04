Newsgroups: comp.sources.misc
From: ram@eiffel.com (Raphael Manfredi)
Subject:  v33i096:  mailagent - Rule Based Mail Filtering, Part04/17
Message-ID: <1992Nov20.050314.13479@sparky.imd.sterling.com>
X-Md4-Signature: d7db0d0f7b07860dba8e47519b4f4e56
Date: Fri, 20 Nov 1992 05:03:14 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: ram@eiffel.com (Raphael Manfredi)
Posting-number: Volume 33, Issue 96
Archive-name: mailagent/part04
Environment: Perl, Sendmail, UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  Configure.a agent/pl/matching.pl agent/test/basic/filter.t
# Wrapped by kent@sparky on Wed Nov 18 22:42:21 1992
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 4 (of 17)."'
if test -f 'Configure.a' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Configure.a'\"
else
  echo shar: Extracting \"'Configure.a'\" \(36159 characters\)
  sed "s/^X//" >'Configure.a' <<'END_OF_FILE'
X#! /bin/sh
X#
X# If these # comments don't work, trim them. Don't worry about any
X# other shell scripts, Configure will trim # comments from them for you.
X#
X# (If you are trying to port this package to a machine without sh,
X# I would suggest you have a look at the prototypical config.h.SH file
X# and edit it to reflect your system. Some packages may include samples
X# of config.h for certain machines, so you might look for one of those.)
X#
X# Yes, you may rip this off to use in other distribution packages. This
X# script belongs to the public domain and cannot be copyrighted.
X#
X# (Note: this Configure script was generated automatically. Rather than
X# working with this copy of Configure, you may wish to get metaconfig.
X# Write to ram@eiffel.com (Raphael Manfredi) and I will send you the
X# latest revision of the dist package, which includes metaconfig.)
X
X# $Id: Configure,v 2.9 92/07/14 16:46:52 ram Exp $
X#
X# Generated on Tue Jul 14 14:23:38 PDT 1992 [metaconfig 2.8 PL13]
X
Xcat >/tmp/c1$$ <<EOF
X
XARGGGHHHH!!!!!
X
XSCO csh still thinks true is false.  Write to SCO today and tell them that next
Xyear Configure ought to "rm /bin/csh" unless they fix their blasted shell. :-)
X
X(Actually, Configure ought to just patch csh in place.  Hmm.  Hmmmmm.  All
Xwe'd have to do is go in and swap the && and || tokens, wherever they are.)
X
X[End of diatribe.  We now return you to your regularly scheduled programming...]
XEOF
Xcat >/tmp/c2$$ <<EOF
X
XOOPS!  You naughty creature!  You didn't run Configure with sh!
XI will attempt to remedy the situation by running sh for you...
XEOF
X
Xtrue || cat /tmp/c1$$ /tmp/c2$$
Xtrue || exec sh $0
X
Xexport PATH || cat /tmp/c2$$
Xexport PATH || exec sh $0
Xrm -f /tmp/c1$$ /tmp/c2$$
X
X: sanity checks
XPATH=".:$PATH:/bin:/usr/bin:/usr/local/bin:/usr/ucb:/usr/local:/usr/lbin"
XPATH=$PATH:'/usr/5bin:/etc:/usr/gnu/bin:/usr/new:/usr/new/bin:/usr/nbin'
XPATH=$PATH:'/sys5.3/bin:/sys5.3/usr/bin /bsd4.3/bin /bsd4.3/usr/ucb'
XPATH=$PATH:'/bsd4.3/usr/bin:/usr/bsd:/bsd43/bin:/usr/ccs/bin'
Xexport PATH
X
Xif test ! -t 0; then
X    echo "Say 'sh Configure', not 'sh <Configure'"
X    exit 1
Xfi
X
X(alias) >/dev/null 2>&1 && \
X    echo "(I see you are using the Korn shell.  Some ksh's blow up on Configure," && \
X    echo "especially on exotic machines.  If yours does, try the Bourne shell instead.)"
X
Xtest -d UU || mkdir UU
Xcd UU && rm -f *
X
Xcase "$1" in
X-d) shift; fastread='yes';;
Xesac
X
Xd_bsd=''
Xd_eunice=''
Xd_xenix=''
Xeunicefix=''
XMcc=''
Xawk=''
Xbison=''
Xcat=''
Xchgrp=''
Xchmod=''
Xchown=''
Xcompress=''
Xcp=''
Xcpio=''
Xcpp=''
Xcsh=''
Xdate=''
Xecho=''
Xegrep=''
Xemacs=''
Xexpr=''
Xgrep=''
Xinews=''
Xless=''
Xline=''
Xlint=''
Xln=''
Xlp=''
Xlpr=''
Xls=''
Xmail=''
Xmailx=''
Xmake=''
Xmkdir=''
Xmore=''
Xmv=''
Xnroff=''
Xperl=''
Xpg=''
Xpmake=''
Xpr=''
Xrm=''
Xrmail=''
Xsed=''
Xsendmail=''
Xsleep=''
Xsmail=''
Xsort=''
Xsubmit=''
Xtail=''
Xtar=''
Xtbl=''
Xtest=''
Xtouch=''
Xtr=''
Xtroff=''
Xuname=''
Xuniq=''
Xuuname=''
Xvi=''
Xzcat=''
Xmyuname=''
XAuthor=''
XDate=''
XHeader=''
XId=''
XLocker=''
XLog=''
XRCSfile=''
XRevision=''
XSource=''
XState=''
Xbin=''
Xcc=''
Xccflags=''
Xcppflags=''
Xldflags=''
Xlkflags=''
Xoptimize=''
Xcontains=''
Xcppminus=''
Xcppstdin=''
Xd_bcopy=''
Xaphostname=''
Xd_gethname=''
Xd_phostname=''
Xd_uname=''
Xd_hidnet=''
Xhiddennet=''
Xd_index=''
Xd_portable=''
Xd_rename=''
Xd_strerrm=''
Xd_strerror=''
Xd_sysernlst=''
Xd_syserrlst=''
Xd_time=''
Xtimetype=''
Xd_uwait=''
Xd_vfork=''
Xd_voidsig=''
Xsignal_t=''
Xhostname=''
Xmydomain=''
Xphostname=''
Xi_fcntl=''
Xi_string=''
Xstrings=''
Xi_sysfile=''
Xi_syswait=''
Xi_systime=''
Xi_systimek=''
Xi_time=''
Xtimeincl=''
Xtimezone=''
Xintsize=''
Xlibc=''
Xnm_opt=''
Xlibpth=''
Xplibpth=''
Xlibs=''
Xmaildir=''
Xmailfile=''
Xmanext=''
Xmansrc=''
Xmkdep=''
Xhuge=''
Xlarge=''
Xmedium=''
Xmodels=''
Xsmall=''
Xsplit=''
Xc=''
Xn=''
Xorgname=''
Xpackage=''
Xperlpath=''
Xpidtype=''
Xprivlib=''
Xreg10=''
Xreg11=''
Xreg12=''
Xreg13=''
Xreg14=''
Xreg15=''
Xreg16=''
Xreg1=''
Xreg2=''
Xreg3=''
Xreg4=''
Xreg5=''
Xreg6=''
Xreg7=''
Xreg8=''
Xreg9=''
Xregisters=''
Xscriptdir=''
Xsharpbang=''
Xshsharp=''
Xspitshell=''
Xstartsh=''
Xsysman=''
Xuidtype=''
Xincpath=''
Xmips=''
Xmips_type=''
Xusrinc=''
Xd_whoami=''
Xi_sysselct=''
XCONFIG=''
X: set package name
Xpackage=mailagent
X
X: Eunice requires " " instead of "", can you believe it
Xecho " "
X: Here we go...
Xecho "Beginning of configuration questions for $package kit."
X
Xdefine='define'
Xundef='undef'
Xsmallmach='pdp11 i8086 z8000 i80286 iAPX286'
Xrmlist='ark[1-9]isdone ark[1-9][0-9]isdone'
Xtrap 'echo " "; rm -f $rmlist; exit 1' 1 2 3 15
X
X: We must find out about Eunice early
Xeunicefix=':'
Xif test -f /etc/unixtovms; then
X    eunicefix=/etc/unixtovms
Xfi
Xif test -f /etc/unixtovms.exe; then
X    eunicefix=/etc/unixtovms.exe
Xfi
X
X: Find out which program gives a meaningful exit status
Xif ls blurfl >/dev/null 2>&1; then
X	if awk '' blurfl >/dev/null 2>&1; then
X		check='cat'
X	else
X		check='awk ""'
X	fi
Xelse
X	check='ls'
Xfi
X
X: Now test for existence of everything in MANIFEST
Xecho " "
Xif test -f ../MANIFEST; then
X	echo "First let's make sure your kit is complete.  Checking..."
X	: some grep do not return a proper exit status
X	grep '^---' ../MANIFEST > .grepmani 2>/dev/null
X	if test -s .grepmani; then
X(cd ..; eval $check `awk '!/^.*\/$/{if (b) print $1}
X/^---/{b=1}' MANIFEST` || kill $$) >/dev/null
X	else
X(cd ..; eval $check `awk '!/^.*\/$/{print $1}' MANIFEST` || kill $$) >/dev/null
X	fi
X	echo "Looks good..."
Xelse
X	echo "No MANIFEST found. Hope your kit is complete !"
Xfi
Xrm -f .grepmani
X
X: list of known cpp symbols
Xattrlist="DGUX M_I186 M_I286 M_I386 M_I8086 M_XENIX UTS __DGUX__"
Xattrlist="$attrlist _AIX __STDC__ __m88k__ ansi bsd4_2 gcos gimpel"
Xattrlist="$attrlist hp9000s300 hp9000s500 hp9000s800 hpux"
Xattrlist="$attrlist i186 i386 i486 i8086 iAPX286 ibm interdata"
Xattrlist="$attrlist m88k mc300 mc500 mc68000 mc68k mc700 mert"
Xattrlist="$attrlist mips ns16000 ns32000 nsc32000 os pdp11 posix pyr"
Xattrlist="$attrlist sinix sony sparc sun tower tower32 tower32_600"
Xattrlist="$attrlist tower32_800 tss u3b2 u3b20 u3b200 u3b5 ultrix unix"
Xattrlist="$attrlist vax venix xenix z8000"
X
X: no include file wanted by default
Xinclwanted=''
X
X: change the next line if compiling for Xenix/286 on Xenix/386
Xxlibpath='/usr/lib/386 /lib/386'
Xlibpth='/usr/lib/large /lib '$xlibpth' /lib/large'
Xlibpth=$libpth' /usr/lib/small /lib/small'
X
X
X: some greps do not return status, grrr.
Xecho "grimblepritz" >grimble
Xif grep blurfldyick grimble >/dev/null 2>&1 ; then
X    contains=contains
Xelif grep grimblepritz grimble >/dev/null 2>&1 ; then
X    contains=grep
Xelse
X    contains=contains
Xfi
Xrm -f grimble
X: the following should work in any shell
Xcase "$contains" in
Xcontains*)
X    echo " "
X    echo "AGH!  Grep doesn't return a status.  Attempting remedial action."
X    cat >contains <<'EOSS'
Xgrep "$1" "$2" >.greptmp && cat .greptmp && test -s .greptmp
XEOSS
Xchmod +x contains
Xesac
X
X: first determine how to suppress newline on echo command
Xecho " "
Xecho "Checking echo to see how to suppress newlines..."
X(echo "hi there\c" ; echo " ") >.echotmp
Xif $contains c .echotmp >/dev/null 2>&1 ; then
X    echo "...using -n."
X    n='-n'
X    c=''
Xelse
X    cat <<'EOM'
X...using \c
XEOM
X    n=''
X    c='\c'
Xfi
Xecho $n "The star should be here-->$c"
Xecho '*'
Xrm -f .echotmp
X
X: set up the echo used in my read
Xmyecho="case \"\$xxxm\" in
X'') echo $n \"\$rp $c\";;
X*) case \"\$rp\" in
X	'') echo $n \"[\$xxxm] $c\";;
X	*) echo $n \"\$rp [\$xxxm] $c\";;
X	esac;;
Xesac"
X
X: now set up to do reads with possible shell escape and default assignment
Xcat <<EOSC >myread
Xxxxm=\$dflt
X$myecho
Xcase "\$fastread" in
Xyes) case "\$dflt" in
X	'') ans='!';;
X	*) ans=''; echo " " ;;
X	esac;;
X*) ans='!';;
Xesac
Xwhile expr "X\$ans" : "X!" >/dev/null; do
X	read answ
X	set x \$xxxm
X	shift
X	aok=''; eval "ans=\"\$answ\"" && aok=y
X	case  "\$answ" in
X	"\$ans")
X		case "\$ans" in
X		!)
X			sh
X			echo " "
X			$myecho
X			;;
X		!*)
X			set x \`expr "X\$ans" : "X!\(.*\)\$"\`
X			shift
X			sh -c "\$*"
X			echo " "
X			$myecho
X			;;
X		esac;;
X	*)
X		case "\$aok" in
X		y)
X			echo "*** Substitution done -- please confirm."
X			xxxm="\$ans"
X			ans=\`echo $n "\$ans$c" | tr '\012' ' '\`
X			xxxm="\$ans"
X			ans=!
X			;;
X		*)
X			echo "*** Error -- try again."
X			ans=!
X			;;
X		esac
X		$myecho
X		;;
X	esac
Xdone
Xcase "\$ans" in
X'') ans="\$xxxm";;
Xesac
XEOSC
X
X: general instructions
Xcat <<EOH
X 
XThis installation shell script will examine your system and ask you questions
Xto determine how the mailagent package should be installed.  If you get stuck
Xon a question, you may use a ! shell escape to start a subshell or execute a
Xcommand.  Many of the questions will have default answers in square brackets;
Xtyping carriage return will give you the default.
X
XOn some of the questions which ask for file or directory names you are allowed
Xto use the ~name construct to specify the login directory belonging to "name",
Xeven if you don't have a shell which knows about that.  Questions where this is
Xallowed will be marked "(~name ok)".
X
XEOH
Xrp=''
Xdflt="Type carriage return to continue"
X. myread
Xcat <<'EOH'
X
XThe prompter used in this script allows you to use shell variables and
Xbackticks in your answers.  You may use $1, $2, etc...  to refer to the words
Xin the default answer, as if the default line was a set of arguments given to a
Xscript shell.  This means you may also use $* to repeat the whole default line,
Xso you do not have to re-type everything to add something to the default.
X
XEverytime there is a substitution, you will have to confirm.  If there is an
Xerror (e.g. an unmatched backtick), the default answer will remain unchanged
Xand you will be prompted again.
X
XIf you are in a hurry, you may run 'Configure -d'.  This will bypass nearly all
Xthe questions and use the computed defaults (or the previous answers if there
Xwas already a config.sh file).
X
XEOH
X. myread
Xcat <<EOH
X
XMuch effort has been expended to ensure that this shell script will run on any
XUnix system.  If despite that it blows up on yours, your best bet is to edit
XConfigure and run it again.  Also, let me (ram@eiffel.com)
Xknow how I blew it.  If you can't run Configure for some reason, you'll have to
Xgenerate a config.sh file by hand.
X
XThis installation script affects things in two ways:
X
X1) it may do direct variable substitutions on some of the files included
X   in this kit.
X2) it builds a config.h file for inclusion in C programs.  You may edit
X   any of these files as the need arises after running this script.
X
XIf you make a mistake on a question, there is no easy way to back up to it
Xcurrently.  The easiest thing to do is to edit config.sh and rerun all the SH
Xfiles.  Configure will offer to let you do this before it runs the SH files.
X
XEOH
Xdflt="Type carriage return to continue"
X. myread
X
X: see if sh knows # comments
Xecho " "
Xecho "Checking your sh to see if it knows about # comments..."
Xif sh -c '#' >/dev/null 2>&1 ; then
X	echo "Your sh handles # comments correctly."
X	shsharp=true
X	spitshell=cat
X	echo " "
X	echo "Okay, let's see if #! works on this system..."
X	echo "#!/bin/cat" >try
X	$eunicefix try
X	chmod +x try
X	try > today
X	if test -s today; then
X		echo "It does."
X		sharpbang='#!'
X	else
X		echo "#! /bin/cat" > try
X		$eunicefix try
X		chmod +x try
X		try > today
X		if test -s today; then
X			echo "It does."
X			sharpbang='#! '
X		else
X			echo "It doesn't."
X			sharpbang=': use '
X		fi
X	fi
Xelse
X	echo "Your sh doesn't grok # comments--I will strip them later on."
X	shsharp=false
X	echo "exec grep -v '^[ 	]*#'" >spitshell
X	chmod +x spitshell
X	$eunicefix spitshell
X	spitshell=`pwd`/spitshell
X	echo "I presume that if # doesn't work, #! won't work either!"
X	sharpbang=': use '
Xfi
Xrm -f try today
X
X: figure out how to guarantee sh startup
Xecho " "
Xecho "Checking out how to guarantee sh startup..."
Xstartsh=$sharpbang'/bin/sh'
Xecho "Let's see if '$startsh' works..."
Xcat >try <<EOSS
X$startsh
Xset abc
Xtest "$?abc" != 1
XEOSS
X
Xchmod +x try
X$eunicefix try
Xif try; then
X    echo "Yup, it does."
Xelse
X    echo "Nope.  You may have to fix up the shell scripts to make sure sh runs them."
Xfi
Xrm -f try
X
X: find out where common programs are
Xecho " "
Xecho "Locating common programs..."
Xcat <<EOSC >loc
X$startsh
Xcase \$# in
X0) exit 1;;
Xesac
Xthing=\$1
Xshift
Xdflt=\$1
Xshift
Xfor dir in \$*; do
X    case "\$thing" in
X    .)
X	if test -d \$dir/\$thing; then
X	    echo \$dir
X	    exit 0
X	fi
X	;;
X    *)
X	if test -f \$dir/\$thing; then
X	    echo \$dir/\$thing
X	    exit 0
X	elif test -f \$dir/\$thing.exe; then
X	    : on Eunice apparently
X	    echo \$dir/\$thing
X	    exit 0
X	fi
X	;;
X    esac
Xdone
Xecho \$dflt
Xexit 1
XEOSC
Xchmod +x loc
X$eunicefix loc
Xloclist="
Xawk
Xcat
Xchgrp
Xchmod
Xchown
Xecho
Xexpr
Xgrep
Xmv
Xrm
Xsed
Xsleep
Xsort
Xtr
Xuniq
X"
Xtrylist="
XMcc
Xcpp
Xdate
Xinews
Xnroff
Xperl
Xtest
Xuname
Xzcat
X"
Xpth=`echo $PATH | sed -e 's/:/ /g'`
Xpth="$pth /lib /usr/lib"
Xfor file in $loclist; do
X    xxx=`loc $file $file $pth`
X    eval $file=$xxx
X    eval _$file=$xxx
X    case "$xxx" in
X    /*)
X	echo $file is in $xxx.
X	;;
X    *)
X	echo "I don't know where $file is.  I hope it's in everyone's PATH."
X	;;
X    esac
Xdone
Xecho " "
Xecho "Don't worry if any of the following aren't found..."
Xans=offhand
Xfor file in $trylist; do
X    xxx=`loc $file $file $pth`
X    eval $file=$xxx
X    eval _$file=$xxx
X    case "$xxx" in
X    /*)
X	echo $file is in $xxx.
X	;;
X    *)
X	echo "I don't see $file out there, $ans."
X	ans=either
X	;;
X    esac
Xdone
Xcase "$egrep" in
Xegrep)
X    echo "Substituting grep for egrep."
X    egrep=$grep
X    ;;
Xesac
Xcase "$test" in
Xtest)
X    echo "Hopefully test is built into your sh."
X    ;;
X/bin/test)
X    if sh -c "PATH= test true" >/dev/null 2>&1; then
X	echo "Using the test built into your sh."
X	test=test
X    fi
X    ;;
X*)
X    test=test
X    ;;
Xesac
Xcase "$echo" in
Xecho)
X    echo "Hopefully echo is built into your sh."
X    ;;
X/bin/echo)
X    echo " "
X    echo "Checking compatibility between /bin/echo and builtin echo (if any)..."
X    $echo $n "hi there$c" >foo1
X    echo $n "hi there$c" >foo2
X    if cmp foo1 foo2 >/dev/null 2>&1; then
X	echo "They are compatible.  In fact, they may be identical."
X    else
X	case "$n" in
X	'-n') n='' c='\c';;
X	*) n='-n' c='';;
X	esac
X	cat <<FOO
XThey are not compatible!  You are probably running ksh on a non-USG system.
XI'll have to use /bin/echo instead of the builtin, since Bourne shell doesn't
Xhave echo built in and we may have to run some Bourne shell scripts.  That
Xmeans I'll have to use $ans to suppress newlines now.  Life is ridiculous.
X
XFOO
X	$echo $n "The star should be here-->$c"
X	$echo "*"
X    fi
X    $rm -f foo1 foo2
X    ;;
X*)
X    : cross your fingers
X    echo=echo
X    ;;
Xesac
Xrmlist="$rmlist loc"
X
X: try to determine whether config.sh was made on this system
Xmyuname=`( ($uname -a) 2>/dev/null || hostname) 2>&1`
Xdflt=n
Xif test -f ../config.sh; then
X	xxx=$myuname
X	eval "`grep myuname= ../config.sh`"
X	if test "X$xxx" = "X$myuname"; then
X		dflt=y
X	fi
Xfi
X
X: get old answers, if there is a config file out there
Xhint=default
Xif test -f ../config.sh; then
X    echo " "
X    rp="I see a config.sh file.  Did Configure make it on THIS system?"
X    . myread
X    case "$ans" in
X    n*|N*) echo "OK, I'll ignore it.";;
X    *)  echo "Fetching default answers from your old config.sh file..."
X		tmp="$n"
X		ans="$c"
X		. ../config.sh
X		cp ../config.sh .
X		n="$tmp"
X		c="$ans"
X		hint=previous
X		;;
X	esac
Xfi
X
X: restore computed paths
Xfor file in $loclist $trylist; do
X	eval $file="\$_$file"
Xdone
X
X: preserve RCS keywords in files with variable substitution, grrr
XHeader='$Header'
XId='$Id'
XLog='$Log'
X
X: make some quick guesses about what we are up against
Xecho " "
X$echo $n "Hmm...  $c"
X$cat /usr/include/signal.h /usr/include/sys/signal.h >foo 2>/dev/null
Xif test `echo abc | tr a-z A-Z` = Abc ; then
X	xxx=`./loc addbib blurfl $pth`
X	if $test -f $xxx; then
X		echo "Looks kind of like a USG system with BSD features, but we'll see..."
X		echo exit 0 >bsd
X		echo exit 0 >usg
X		echo exit 1 >v7
X	else
X		if $contains SIGTSTP foo >/dev/null 2>&1 ; then
X			echo "Looks kind of like an extended USG system, but we'll see..."
X		else
X			echo "Looks kind of like a USG system, but we'll see..."
X		fi
X		echo exit 1 >bsd
X		echo exit 0 >usg
X		echo exit 1 >v7
X	fi
X	d_bsd="$undef"
Xelif $contains SIGTSTP foo >/dev/null 2>&1 ; then
X    echo "Looks kind of like a BSD system, but we'll see..."
X	d_bsd="$define"
X    echo exit 0 >bsd
X    echo exit 1 >usg
X    echo exit 1 >v7
Xelse
X    echo "Looks kind of like a Version 7 system, but we'll see..."
X	d_bsd="$undef"
X    echo exit 1 >bsd
X    echo exit 1 >usg
X    echo exit 0 >v7
Xfi
Xcase "$eunicefix" in
X*unixtovms*)
X    cat <<'EOI'
XThere is, however, a strange, musty smell in the air that reminds me of
Xsomething...hmm...yes...I've got it...there's a VMS nearby, or I'm a Blit.
XEOI
X    echo "exit 0" >eunice
X    eunicefix=unixtovms
X    d_eunice="$define"
X: it so happens the Eunice I know will not run shell scripts in Unix format
X	;;
X*)
X    echo " "
X    echo "Congratulations.  You aren't running Eunice."
X    eunicefix=':'
X    d_eunice="$undef"
X    echo "exit 1" >eunice
X	;;
Xesac
Xif test -f /xenix; then
X    echo "Actually, this looks more like a XENIX system..."
X    echo "exit 0" >xenix
X	d_xenix="$define"
Xelse
X    echo " "
X    echo "It's not Xenix..."
X    echo "exit 1" >xenix
X	d_xenix="$undef"
Xfi
Xchmod +x xenix
X$eunicefix xenix
Xif test -f /venix; then
X    echo "Actually, this looks more like a VENIX system..."
X    echo "exit 0" >venix
Xelse
X    echo " "
X    if xenix; then
X	: null
X    else
X	echo "Nor is it Venix..."
X    fi
X    echo "exit 1" >venix
Xfi
Xchmod +x bsd usg v7 eunice venix
X$eunicefix bsd usg v7 eunice venix
X$rm -f foo
Xrmlist="$rmlist bsd usg v7 eunice venix xenix"
X
X: set up shell script to do ~ expansion
Xcat >filexp <<EOSS
X$startsh
X: expand filename
Xcase "\$1" in
X ~/*|~)
X    echo \$1 | $sed "s|~|\${HOME-\$LOGDIR}|"
X    ;;
X ~*)
X    if $test -f /bin/csh; then
X	/bin/csh -f -c "glob \$1"
X	echo ""
X    else
X	name=\`$expr x\$1 : '..\([^/]*\)'\`
X	dir=\`$sed -n -e "/^\${name}:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\).*"'\$'"/\1/" -e p -e q -e '}' </etc/passwd\`
X	if $test ! -d "\$dir"; then
X	    me=\`basename \$0\`
X	    echo "\$me: can't locate home directory for: \$name" >&2
X	    exit 1
X	fi
X	case "\$1" in
X	*/*)
X	    echo \$dir/\`$expr x\$1 : '..[^/]*/\(.*\)'\`
X	    ;;
X	*)
X	    echo \$dir
X	    ;;
X	esac
X    fi
X    ;;
X*)
X    echo \$1
X    ;;
Xesac
XEOSS
Xchmod +x filexp
X$eunicefix filexp
X
X: determine where manual pages are on this system
Xecho " "
Xcase "$sysman" in
X'') sysman=`loc . /usr/man/man1 /usr/man/man1 /usr/man/mann /usr/man/manl /usr/man/local/man1 /usr/man/u_man/man1 /usr/share/man/man1 /usr/catman/u_man/man1 /usr/man/l_man/man1 /usr/local/man/u_man/man1 /usr/local/man/l_man/man1 /usr/man/man.L`
X    ;;
Xesac
Xif test -d "$sysman"; then
X	echo "System manual is in $sysman."
Xelse
X	echo "Could not find manual pages in source form."
Xfi
X
X: see what memory models we can support
Xcase "$models" in
X'')
X    $cat >pdp11.c <<'EOP'
Xmain() {
X#ifdef pdp11
X    exit(0);
X#else
X    exit(1);
X#endif
X}
XEOP
X	cc -o pdp11 pdp11.c >/dev/null 2>&1
X	if pdp11 2>/dev/null; then
X		dflt='unsplit split'
X	else
X		ans=`loc . X /lib/small /lib/large /usr/lib/small /usr/lib/large /lib/medium /usr/lib/medium /lib/huge`
X		case "$ans" in
X		X) dflt='none';;
X		*) if $test -d /lib/small || $test -d /usr/lib/small; then
X				dflt='small'
X			else
X				dflt=''
X			fi
X			if $test -d /lib/medium || $test -d /usr/lib/medium; then
X				dflt="$dflt medium"
X			fi
X			if $test -d /lib/large || $test -d /usr/lib/large; then
X				dflt="$dflt large"
X			fi
X			if $test -d /lib/huge || $test -d /usr/lib/huge; then
X				dflt="$dflt huge"
X			fi
X		esac
X	fi;;
X*) dflt="$models";;
Xesac
X$cat <<EOM
X 
XSome systems have different model sizes.  On most systems they are called
Xsmall, medium, large, and huge.  On the PDP11 they are called unsplit and
Xsplit.  If your system doesn't support different memory models, say "none".
XIf you wish to force everything to one memory model, say "none" here and
Xput the appropriate flags later when it asks you for other cc and ld flags.
XVenix systems may wish to put "none" and let the compiler figure things out.
X(In the following question multiple model names should be space separated.)
X
XEOM
Xrp="Which models are supported?"
X. myread
Xmodels="$ans"
X
Xcase "$models" in
Xnone)
X	small=''
X	medium=''
X	large=''
X	huge=''
X	unsplit=''
X	split=''
X	;;
X*split)
X	case "$split" in
X	'') if $contains '\-i' $sysman/ld.1 >/dev/null 2>&1 || \
X			 $contains '\-i' $sysman/cc.1 >/dev/null 2>&1; then
X			dflt='-i'
X		else
X			dflt='none'
X		fi;;
X	*) dflt="$split";;
X	esac
X	rp="What flag indicates separate I and D space?"
X	. myread
X	case "$ans" in
X	none) ans='';;
X	esac
X	split="$ans"
X	unsplit='';;
X*large*|*small*|*medium*|*huge*)
X	case "$model" in
X	*large*)
X		case "$large" in
X		'') dflt='-Ml';;
X		*) dflt="$large";;
X		esac
X	rp="What flag indicates large model?"
X	. myread
X	case "$ans" in
X	none) ans='';
X	esac
X	large="$ans";;
X	*) large='';;
X	esac
X	case "$model" in
X	*huge*) case "$huge" in
X		'') dflt='-Mh';;
X		*) dflt="$huge";;
X		esac
X		rp="What flag indicates huge model?"
X		. myread
X		case "$ans" in
X		none) ans='';
X		esac
X		huge="$ans";;
X    *) huge="$large";;
X	esac
X	case "$model" in
X	*medium*) case "$medium" in
X		'') dflt='-Mm';;
X		*) dflt="$medium";;
X		esac
X		rp="What flag indicates medium model?"
X		. myread
X		case "$ans" in
X		none) ans='';
X		esac
X		medium="$ans";;
X    *) medium="$large";;
X	esac
X	case "$model" in
X	*small*) case "$small" in
X		'') dflt='none';;
X		*) dflt="$small";;
X		esac
X		rp="What flag indicates small model?"
X		. myread
X		case "$ans" in
X		none) ans='';
X		esac
X		small="$ans";;
X	*) small='';;
X	esac
X	;;
X*)
X	echo "Unrecognized memory models--you may have to edit Makefile.SH"
X	;;
Xesac
X
X: see if we need a special compiler
Xecho " "
Xif usg; then
X	case "$cc" in
X	'') case "$Mcc" in
X		/*) dflt='Mcc';;
X		*) case "$large" in
X			-M*) dflt='cc';;
X			*)	if $contains '\-M' $sysman/cc.1 >/dev/null 2>&1 ; then
X					if $contains '\-M' $sysman/cpp.1 >/dev/null 2>&1; then
X						dflt='cc'
X					else
X						dflt='cc -M'
X					fi
X				else
X					dflt='cc'
X				fi;;
X			esac;;
X		esac;;
X    *)  dflt="$cc";;
X    esac
X    $cat <<'EOM'
XOn some systems the default C compiler will not resolve multiple global
Xreferences that happen to have the same name.  On some such systems the "Mcc"
Xcommand may be used to force these to be resolved.  On other systems a "cc -M"
Xcommand is required.  (Note that the -M flag on other systems indicates a
Xmemory model to use!) If you have the Gnu C compiler, you might wish to use
Xthat instead.
X
XEOM
X	rp="What command will force resolution on this system?"
X	. myread
X	cc="$ans"
Xelse
X	case "$cc" in
X	'') dflt=cc;;
X	*) dflt="$cc";;
X	esac
X	rp="Use which C compiler?"
X	. myread
X	cc="$ans"
Xfi
Xcase "$cc" in
Xgcc*) cpp=`loc gcc-cpp $cpp $pth`;;
Xesac
X
X: What should the include directory be ?
Xecho " "
X$echo $n "Hmm...  $c"
Xcase "$usrinc" in
X'') dflt='/usr/include';;
X*) dflt=$usrinc;;
Xesac
Xincpath=''
Xmips_type=''
Xif $test -f /bin/mips && /bin/mips; then
X	echo "Looks like a MIPS system..."
X	$cat >usr.c <<'EOCP'
X#ifdef SYSTYPE_BSD43
X/bsd43
X#endif
XEOCP
X	if $cc -E usr.c > usr.out && $contains / usr.out >/dev/null 2>&1; then
X		dflt='/bsd43/usr/include'
X		incpath='/bsd43'
X		mips_type='BSD 4.3'
X	else
X		mips_type='System V'
X	fi
X	echo "and you're compiling with the $mips_type compiler and libraries."
Xelse
X	echo "Doesn't look like a MIPS system."
X	echo "exit 1" >mips
X	chmod +x mips
X	$eunicefix mips
Xfi
Xcont=true
Xwhile $test "$cont"; do
X	echo " "
X	rp="Where are the include files you want to use?"
X	. myread
X	usrinc="$ans"
X	if $test -d "$ans"; then
X		cont=''
X	else
X		if $test "$fastread" = yes; then
X			dflt=y
X		else
X			dflt=n
X		fi
X		rp="Directory $ans doesn't exist.  Use that name anyway?"
X		. myread
X		dflt=''
X		case "$ans" in
X		y*) cont='';;
X		esac
X	fi
Xdone
X$rm -f usr.c usr.out
X
X: now get the host name
Xecho " "
Xecho "Figuring out host name..."
Xcont=true
Xecho 'Maybe "hostname" will work...'
Xif ans=`sh -c hostname 2>&1` ; then
X	hostname=$ans
X	phostname=hostname
X	cont=''
Xfi
Xif $test "$cont"; then
X	if xenix; then
X		echo 'Oh, dear.  Maybe "/etc/systemid" is the key...'
X		if ans=`cat /etc/systemid 2>&1` ; then
X			hostname=$ans
X			phostname='cat /etc/systemid'
X			echo "Whadyaknow.  Xenix always was a bit strange..."
X			cont=''
X		fi
X	elif $test -r /etc/systemid; then
X		echo "(What is a non-Xenix system doing with /etc/systemid?)"
X	fi
Xfi
Xif $test "$cont"; then
X	echo 'No, maybe "uuname -l" will work...'
X	if ans=`sh -c 'uuname -l' 2>&1` ; then
X		hostname=$ans
X		phostname='uuname -l'
X	else
X		echo 'Strange.  Maybe "uname -n" will work...'
X		if ans=`sh -c 'uname -n' 2>&1` ; then
X			hostname=$ans
X			phostname='uname -n'
X		else
X			echo 'Oh well, maybe I can mine it out of whoami.h...'
X			if ans=`sh -c $contains' sysname $usrinc/whoami.h' 2>&1` ; then
X				hostname=`echo "$ans" | $sed 's/^.*"\(.*\)"/\1/'`
X				phostname="sed -n -e '"'/sysname/s/^.*\"\\(.*\\)\"/\1/{'"' -e p -e q -e '}' <$usrinc/whoami.h"
X			else
X				case "$hostname" in
X				'') echo "Does this machine have an identity crisis or something?"
X					phostname='';;
X				*) echo "Well, you said $hostname before...";;
X				esac
X			fi
X		fi
X	fi
Xfi
X: you do not want to know about this
Xset $hostname
Xhostname=$1
X
X: translate upper to lower if necessary
Xcase "$hostname" in
X*[A-Z]*)
X	hostname=`echo $hostname | tr '[A-Z]' '[a-z]'`
X	echo "(Normalizing case in your host name)"
X	;;
Xesac
X
X: verify guess
Xif $test "$hostname" ; then
X	dflt=y
X	rp='Your host name appears to be "'$hostname'".'" Right?"
X	. myread
X	case "$ans" in
X	y*) ;;
X	*) hostname='';;
X	esac
Xfi
X
X: bad guess or no guess
Xwhile $test "X$hostname" = X ; do
X	dflt=''
X	rp="Please type the (one word) name of your host:"
X	. myread
X	hostname="$ans"
Xdone
X
Xcase "$hostname" in
X*.*)
X	dflt=`expr "X$hostname" : "X[^.]*\(\..*\)"`
X	hostname=`expr "X$hostname" : "X\([^.]*\)\."`
X	echo "(Trimming domain name from host name--host name is now $hostname)"
X	;;
X*) case "$mydomain" in
X	'') dflt=.`$awk "/[0-9].*$hostname/ {for(i=2; i<=NF;i++) print \\\$i}" /etc/hosts|
X		$sort|$uniq|$sed -n -e "s/$hostname\.\([a-zA-Z_.]\)/\1/p"`
X		case "$dflt" in
X		.) echo "(You do not have fully-qualified names in /etc/hosts)"
X			dflt='.uucp';;
X		esac;;
X	*) dflt="$mydomain";;
X	esac;;
Xesac
Xecho " "
Xrp="What is your domain name?"
X. myread
Xcase "$ans" in
X'') ;;
X.*) ;;
X*) ans=".$ans";;
Xesac
Xmydomain="$ans"
X
X: a little sanity check here
Xcase "$phostname" in
X'') ;;
X*)
X	case `$phostname` in
X	$hostname$mydomain|$hostname) ;;
X	*)
X		case "$phostname" in
X		sed*)
X			echo "(That doesn't agree with your whoami.h file, by the way.)"
X			;;
X		*)
X			echo "(That doesn't agree with your $phostname command, by the way.)"
X			;;
X		esac
X	phostname=''
X	;;
X	esac
X	;;
Xesac
X
X: decide how portable to be
Xcase "$d_portable" in
X"$define") dflt=y;;
X*)	dflt=n;;
Xesac
X$cat <<'EOH'
X 
XI can set things up so that your shell scripts and binaries are more portable,
Xat what may be a noticable cost in performance.  In particular, if you
Xask to be portable, the following happens:
X
X     1) Shell scripts will rely on the PATH variable rather than using
X	the paths derived above.
X     2) ~username interpretations will be done at run time rather than
X	by Configure.
X     3) The system name will be determined at run time, if at all possible.
X
XEOH
Xrp="Do you expect to run these scripts and binaries on multiple machines?"
X. myread
Xcase "$ans" in
X    y*) d_portable="$define"
X	for file in $loclist; do
X	    eval $file=$file
X	done
X	;;
X    *)  d_portable="$undef" ;;
Xesac
X
X: Set private lib path
Xcase "$plibpth" in
X'') if mips; then
X		plibpth="$incpath/usr/lib /usr/local/lib /usr/ccs/lib"
X	else
X		plibpth="/usr/ccs/lib /usr/lib /usr/ucblib /usr/local/lib"
X	fi;;
Xesac
Xlibpth="$plibpth $libpth"
X
X: Looking for optional libraries
Xecho " "
Xecho "Checking for optional libraries..."
Xcase "$libs" in
X'') dflt='';;
X*) dflt="$libs";;
Xesac
Xcase "$libswanted" in
X'') libswanted='c_s';;
Xesac
Xfor thislib in $libswanted; do
X	case "$thislib" in
X	dbm) thatlib=ndbm;;
X	*_s) thatlib=NONE;;
X	*) thatlib="${thislib}_s";;
X	*) thatlib=NONE;;
X	esac
X	yyy="$incpath/usr/ccs/lib $incpath/usr/lib $incpath/usr/ucblib"
X	yyy="$yyy $incpath/usr/local/lib $incpath/lib"
X	xxx=`loc lib$thislib.a X $yyy`
X	if $test -f $xxx; then
X		echo "Found -l$thislib."
X		case "$dflt" in
X		*-l$thislib*|*-l$thatlib*);;
X		*) dflt="$dflt -l$thislib";;
X		esac
X	else
X		xxx=`loc lib$thislib.a X $libpth`
X		if $test -f $xxx; then
X			echo "Found $xxx."
X			case "$dflt" in
X			*$xxx*);;
X			*) dflt="$dflt $xxx";;
X			esac
X		else
X			xxx=`loc Slib$thislib.a X $xlibpth`
X			if $test -f $xxx; then
X				echo "Found -l$thislib."
X				case "$dflt" in
X				*-l$thislib*|*-l$thatlib*);;
X				*) dflt="$dflt -l$thislib";;
X				esac
X			else
X				echo "No -l$thislib."
X			fi
X		fi
X	fi
Xdone
Xset X $dflt
Xshift
Xdflt="$*"
Xcase "$libs" in
X'') dflt="$dflt";;
X*) dflt="$libs";;
Xesac
Xcase "$dflt" in
X'') dflt='none';;
Xesac
X
X$cat <<EOM
X 
XSome versions of Unix support shared libraries, which make executables smaller
Xbut make load time slightly longer.
X
XOn some systems, mostly newer Unix System V's, the shared library is included
Xby putting the option "-lc_s" as the last thing on the cc command line when
Xlinking.  Other systems use shared libraries by default.  There may be other
Xlibraries needed to compile $package on your machine as well.  If your system
Xneeds the "-lc_s" option, include it here.  Include any other special libraries
Xhere as well.  Say "none" for none.
XEOM
X
Xecho " "
Xrp="Any additional libraries?"
X. myread
Xcase "$ans" in
Xnone) ans='';
Xesac
Xlibs="$ans"
X
X: get list of predefined functions in a handy place
Xecho " "
Xcase "$libc" in
X'') libc=unknown;;
Xesac
Xcase "$nm_opt" in
X'') if $test -f /mach_boot; then
X		nm_opt=''
X	elif $test -d /usr/ccs/lib; then
X		nm_opt='-p'
X	elif $test -f /dgux; then
X		nm_opt='-p'
X	else
X		nm_opt=''
X	fi;;
Xesac
Xlibpth="$plibpth $libpth"
Xcase "$libs" in
X*-lc_s*) libc=`loc libc_s.a $libc $libpth`
Xesac
Xlibnames='';
Xcase "$libs" in
X'') ;;
X*)  for thislib in $libs; do
X	case "$thislib" in
X	-l*) thislib=`expr X$thislib : 'X-l\(.*\)'`
X	    try=`loc lib$thislib.a blurfl/dyick $libpth`
X	    if test ! -f $try; then
X		try=`loc lib$thislib blurfl/dyick $libpth`
X		if test ! -f $try; then
X		    try=`loc $thislib blurfl/dyick $libpth`
X		    if test ! -f $try; then
X			try=`loc Slib$thislib.a blurfl/dyick $xlibpth`
X			if test ! -f $try; then
X			    try=''
X			fi
X		    fi
X		fi
X	    fi
X	    libnames="$libnames $try"
X	    ;;
X	*) libnames="$libnames $thislib" ;;
X	esac
X    done
X    ;;
Xesac
Xset /usr/ccs/lib/libc.so
X$test -f $1 || set /usr/lib/libc.so
X$test -f $1 || set /usr/lib/libc.so.[0-9]*
X$test -f $1 || set /lib/libsys_s.a
Xeval set \$$#
Xif test -f "$1"; then
X    echo "Your (shared) C library seems to be in $1."
X    libc="$1"
Xelif test -f /lib/libc && test -f /lib/clib; then
X    echo "Your C library seems to be in both /lib/clib and /lib/libc."
X    libc='/lib/clib /lib/libc'
X	if test -f /lib/syslib; then
X		echo "(Your math library is in /lib/syslib.)"
X		libc="$libc /lib/syslib"
X	fi
Xelif test -f "$libc"; then
X    echo "Your C library seems to be in $libc, as you said before."
Xelif test -f $incpath/usr/lib/libc.a; then
X	libc=$incpath/usr/lib/libc.a;
X    echo "Your C library seems to be in $libc.  That's fine."
Xelif test -f /lib/libc.a; then
X	libc=/lib/libc.a;
X    echo "Your C library seems to be in $libc.  You're normal."
Xelse
X    if ans=`./loc libc.a blurfl/dyick $libpth`; test -f "$ans"; then
X		:
X	elif ans=`./loc libc blurfl/dyick $libpth`; test -f "$ans"; then
X		libnames="$libnames "`./loc clib blurfl/dyick $libpth`
X	elif ans=`./loc clib blurfl/dyick $libpth`; test -f "$ans"; then
X		:
X	elif ans=`./loc Slibc.a blurfl/dyick $xlibpth`; test -f "$ans"; then
X		:
X	elif ans=`./loc Mlibc.a blurfl/dyick $xlibpth`; test -f "$ans"; then
X		:
X	else
X		ans=`./loc Llibc.a blurfl/dyick $xlibpth`
X    fi
X    if test -f "$ans"; then
X		echo "Your C library seems to be in $ans, of all places."
X		libc=$ans
X	else
X		libc='blurfl'
X	fi
Xfi
Xif $test -f "$libc"; then
X	dflt="$libc"
X	cat <<EOM
X
XIf the guess above is wrong (which it might be if you're using a strange
Xcompiler, or your machine supports multiple models), you can override it here.
X
XEOM
Xelse
X	dflt=''
X	echo $libpth | tr ' ' '\012' | sort | uniq > libpath
X	cat <<EOM
XI can't seem to find your C library.  I've looked in the following places:
X
XEOM
X	$sed 's/^/	/' libpath
X	cat <<EOM
X
XNone of these seems to contain your C library. I need to get its name...
X
XEOM
Xfi
Xcont=true
Xwhile $test "$cont"; do
X	rp="Where is your C library?"
X	. myread
X	libc="$ans"
X	if $test -f "$libc"; then
X		cont=''
X	else
X		case "$fastread" in
X		yes) dflt=y;;
X		*) dflt=n;;
X		esac
X		rp="File $libc does not exist. Use that name anyway?"
X		. myread
X		case "$ans" in
X		y*) cont='';;
X		esac
X		dflt=''
X	fi
Xdone
Xecho " "
Xecho $libc $libnames | tr ' ' '\012' | sort | uniq > libnames
Xset X `cat libnames`
Xshift
Xxxx=files
Xcase $# in 1) xxx=file; esac
Xecho "Extracting names from the following $xxx for later perusal:"
Xecho " "
X$sed 's/^/	/' libnames
Xecho " "
X$echo $n "This may take a while...$c"
Xnm $nm_opt $* 2>/dev/null >libc.tmp
X$echo $n ".$c"
X$grep fprintf libc.tmp > libc.ptf
Xxscan='eval "<libc.ptf $com >libc.list"; $echo $n ".$c"'
Xxrun='eval "<libc.tmp $com >libc.list"; echo "done"'
Xif com="$sed -n -e 's/^.* [ADTS]  *_[_.]*//p' -e 's/^.* [ADTS] //p'";\
X	eval $xscan;\
X	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
X		eval $xrun
Xelif com="$sed -n -e 's/^__*//' -e 's/^\([a-zA-Z_0-9$]*\).*xtern.*/\1/p'";\
X	eval $xscan;\
X	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
X		eval $xrun
Xelif com="$sed -n -e '/|UNDEF/d' -e '/FUNC..GL/s/^.*|__*//p'";\
X	eval $xscan;\
X	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
X		eval $xrun
Xelif com="$sed -n -e 's/^.* D __*//p' -e 's/^.* D //p'";\
X	eval $xscan;\
X	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
X		eval $xrun
Xelif com="$sed -n -e 's/^_//' -e 's/^\([a-zA-Z_0-9]*\).*xtern.*text.*/\1/p'";\
X	eval $xscan;\
X	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
X		eval $xrun
Xelif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p'";\
X	eval $xscan;\
X	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
X		eval $xrun
Xelif com="$grep '|' | $sed -n -e '/|COMMON/d' -e '/|DATA/d' \
X				-e '/ file/d' -e 's/^\([^ 	]*\).*/\1/p'";\
X	eval $xscan;\
X	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
X		eval $xrun
Xelif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p' -e 's/^.*|FUNC |WEAK .*|//p'";\
X	eval $xscan;\
X	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
X		eval $xrun
Xelif com="$sed -n -e 's/^__//' -e '/|Undef/d' -e '/|Proc/s/ .*//p'";\
X	eval $xscan;\
X	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
X		eval $xrun
Xelse
X	nm -p $* 2>/dev/null >libc.tmp
X	com="$sed -n -e 's/^.* [ADTS]  *_[_.]*//p' -e 's/^.* [ADTS] //p'";\
X	eval "<libc.tmp $com >libc.list"
X	if $contains '^fprintf$' libc.list >/dev/null 2>&1; then
X		nm_opt='-p'
X		echo "done"
X	else
X		echo " "
X		echo "nm didn't seem to work right. Trying ar instead..."
X		com=''
X		if ar t $libc > libc.tmp; then
X			for thisname in $libnames; do
X				ar t $thisname >>libc.tmp
X			done
X			$sed -e 's/\.o$//' < libc.tmp > libc.list
X			echo "Ok."
X		else
X			echo "ar didn't seem to work right."
X			echo "Maybe this is a Cray...trying bld instead..."
X			if bld t $libc | $sed -e 's/.*\///' -e 's/\.o:.*$//' > libc.list; then
X				for thisname in $libnames; do
X					bld t $libnames | \
X					$sed -e 's/.*\///' -e 's/\.o:.*$//' >>libc.list
X					ar t $thisname >>libc.tmp
X				done
X				echo "Ok."
X			else
X				echo "That didn't work either.  Giving up."
X				exit 1
X			fi
X		fi
X	fi
Xfi
Xnm_extract="$com"
Xif test -f /lib/syscalls.exp; then
X	echo " "
X	echo "Also extracting names from /lib/syscalls.exp for good ole AIX..."
X	$sed -n 's/^\([^ 	]*\)[ 	]*syscall$/\1/p' /lib/syscalls.exp >>libc.list
Xfi
X$rm -f libnames libpath
X
X: see how we will look up host name
Xecho " "
Xd_uname="$undef"
Xd_gethname="$undef"
Xd_phostname="$undef"
Xif xenix; then
X	echo "(Assuming Xenix uname() is broken.)"
Xelif $contains '^gethostname$' libc.list >/dev/null 2>&1 ; then
X	echo "gethostname() found."
X	d_gethname="$define"
X	ans=gethostname
Xelif $contains '^uname$' libc.list >/dev/null 2>&1 ; then
X	echo "uname() found."
X	d_uname="$define"
X	ans=uname
Xfi
Xcase "$d_uname$d_gethname" in
X*define*)
X	dflt=n
X	cat <<EOM
X 
XEvery now and then someone has a $ans() that lies about the hostname
Xbut can't be fixed for political or economic reasons.  If you wish, I can
Xpretend $ans() isn't there and maybe compile in the hostname or
Xcompute it from the '$phostname' command at run-time.
X
XEOM
END_OF_FILE
 if test 36159 -ne `wc -c <'Configure.a'`; then
    echo shar: \"'Configure.a'\" unpacked with wrong size!
 elif test -f 'Configure.b'; then
    echo shar: Combining  \"'Configure'\" \(70471 characters\)
    cat 'Configure.a' 'Configure.b' > 'Configure'
    if test 70471 -ne `wc -c <'Configure'`; then
      echo shar: \"'Configure'\" combined with wrong size!
    else
      chmod u+x Configure
      rm Configure.a Configure.b
    fi
  fi
  # end of 'Configure.a'
fi
if test -f 'agent/pl/matching.pl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'agent/pl/matching.pl'\"
else
  echo shar: Extracting \"'agent/pl/matching.pl'\" \(13814 characters\)
  sed "s/^X//" >'agent/pl/matching.pl' <<'END_OF_FILE'
X;# $Id: matching.pl,v 2.9.1.1 92/08/02 16:11:54 ram Exp $
X;#
X;#  Copyright (c) 1992, Raphael Manfredi
X;#
X;#  You may redistribute only under the terms of the GNU General Public
X;#  Licence as specified in the README file that comes with dist.
X;#
X;# $Log:	matching.pl,v $
X;# Revision 2.9.1.1  92/08/02  16:11:54  ram
X;# patch2: added support for negated selectors
X;# 
X;# Revision 2.9  92/07/14  16:50:20  ram
X;# 3.0 beta baseline.
X;# 
X;# 
X#
X# Matching functions
X#
X
X# List of special header selector, for which a pattern without / is to be
X# taken as an equality with the login name of the address. If there are some
X# metacharacters, then a match will be attempted on that name. For each of
X# those special headers, we record the name of the subroutine to be called.
X# If a matching function is not specified, the default is 'match_var'.
X# The %Amatcher gives the name of the fields which contains an address.
Xsub init_matcher {
X	%Matcher = (
X		'From', 'match_single',
X		'To', 'match_list',
X		'Cc', 'match_list',
X		'Apparently-To', 'match_list',
X		'Newsgroups', 'match_list'
X	);
X	%Amatcher = (
X		'From', 1,
X		'To', 1,
X		'Cc', 1,
X		'Apparently-To', 1
X	);
X}
X
X# Take a pattern as written in the rule file and make it suitable for
X# pattern matching as understood by perl. If the pattern starts with a
X# leading /, nothing is done. Otherwise, a set of / are added.
X# match (1st case).
Xsub make_pattern {
X	local($_) = shift(@_);
X	unless (m|^/|) {				# Pattern does not start with a /
X		# With simple words, patterns have the same form as shell ones
X		s/\./\\./g;			# Escape .
X		s/\*/.*/g;			# Transform * into .*
X		s/\?/./g;			# Transform ? into .
X		$_ = "/^$_\$/";		# Anchor pattern
X	}
X	# The whole pattern is inserted within () to make at least one
X	# backreference. Otherwise, the following could happen:
X	#    $_ = '1 for you';
X	#    @matched = /^\d/;
X	#    @matched = /^(\d)/;
X	# In both cases, the @matched array is set to ('1'), with no way to
X	# determine whether it is due to a backreference (2nd case) or a sucessful
X	# match. Knowing we have at least one bracketed reference is enough to
X	# disambiguate.
X	s|^/(.*)/|/($1)/|;		# Enclose whole pattern within ()
X	$_;						# Pattern suitable for eval'ed matching
X}
X
X# Attempt a match of a set of pattern, for each possible selector
Xsub match {
X	local($selector) = shift(@_);	# The selector on which pattern applies
X	local($pattern) = shift(@_);	# The pattern or script to apply
X	local($matched) = 0;			# Matching status returned
X	# If the pattern is held within double quotes, it is assumed to be the name
X	# of a file from which patterns may be found (one per line, shell comments
X	# being ignored).
X	if ($pattern !~ /^"/) {
X		$matched = do apply_match($selector, $pattern);
X	} else {
X		local(@filepat) = ();			# File pattern
X		local($filename);				# Where pattern should be read from
X		($filename) =
X			$pattern =~ /^"(.*)"$/;		# The filename is held within ""
X		$filename =
X			&locate_file($filename);	# Path may not be absolute
X		if ($filename) {
X			if (open(PATTERN, "$filename")) {
X				while (<PATTERN>) {
X					next if /^\s*#/;	# Skip shell comments
X					chop;
X					s/^\s*//;			# Remove leading spaces
X					push(@filepat, $_);
X					do add_log ("loading pattern $_") if $loglvl > 19;
X				}
X				close PATTERN;
X			} else {
X				do add_log("WARNING couldn't open $filename for patterns")
X					if $loglvl > 4;
X				push(@filepat, "*");	# Ensure anything matches
X			}
X		} else {
X			do add_log("WARNING incorrect file name $pattern") if $loglvl > 4;
X			push(@filepat, "*");	# Ensure anything matches
X		}
X		# Now do the match for all the patterns. Stop as soon as one matches.
X		foreach (@filepat) {
X			$matched = do apply_match($selector, $_);
X			last if $matched;
X		}
X	}
X	$matched ? 1 : 0;		# Return matching status (guaranteed numeric)
X}
X
X# Attempt a pattern match on a set of selectors, and set the special macro %&
X# to the name of the regexp-specified fields which matched.
Xsub apply_match {
X	local($selector) = shift(@_);	# The selector on which pattern applies
X	local($pattern) = shift(@_);	# The pattern or script to apply
X	local($matched) = 0;			# True when a matching occurred
X	local($inverted) = 0;			# True whenever all '!' match succeeded
X	local($invert) = 1;				# Set to false whenever a '!' match fails
X	local($match);					# Matching status reported
X	local($not) = '';				# Shall we negate matching status?
X	if ($selector eq 'script') {	# Pseudo header selector
X		$matched = do evaluate(*pattern);
X	} else {						# True header selector
X
X		# There can be multiple slectors separated by a white space. As soon as
X		# one of them matches, we stop and return true. A selector may contain
X		# metacharacters, in which case a regular pattern matching is attempted
X		# on the true *header* fields (i.e. we skip the pseudo keys like Body,
X		# Head, etc..). For instance, Return* would attempt a match on the
X		# field Return-Receipt-To:, if present. The special macro %& is set
X		# to the list of all the fields on which the match succeeded
X		# (alphabetically sorted).
X
X		foreach $select (split(/ /, $selector)) {
X			$not = '';
X			$select =~ s/^!// && ($not = '!');
X			# Allowed metacharacters are listed here (no braces wanted)
X			if ($select =~ /\.|\*|\[|\]|\||\\|\^|\?|\+|\(|\)/) {
X				$match = &expr_selector_match($select, $pattern);
X			} else {
X				$match = &selector_match($select, $pattern);
X			}
X			if ($not) {								# Negated test
X				$invert = !$match if $invert;
X				$inverted = $invert if !$match;		# '!' tests AND'ed
X			} else {
X				$matched = $match;					# Normal tests OR'ed
X			}
X			last if $matched;		# Stop when matching status known
X		}
X	}
X	$matched || $inverted;			# Return matching status
X}
X
X# Attempt a pattern match on a set of selectors, and set the special macro %&
X# to the name of the field which matched. If there is more than one such
X# selector, values are separated using comas. If selector is preceded by a '!',
X# then the matching status is negated and *all* the tested fields are recorded
X# within %& when the returned status is 'true'.
Xsub expr_selector_match {
X	local($selector) = shift(@_);	# The selector on which pattern applies
X	local($pattern) = shift(@_);	# The pattern or script to apply
X	local($matched) = 0;			# True when a matching occurred
X	local(@keys) = sort keys %Header;
X	local($match);					# Local matching status
X	local($not) = '';				# Shall boolean value be negated?
X	local($orig_ampersand) = $macro_ampersand;	# Save %&
X	$selector =~ s/^!// && ($not = '!');
X	&add_log("field '$selector' has metacharacters") if $loglvl > 18;
X	field: foreach $key (@keys) {
X		next if $Pseudokey{$key};		# Skip Body, All...
X		&add_log("'$select' tried on '$key'") if $loglvl > 19;
X		next unless eval '$key =~ /' . $select . '/';
X		$match = &selector_match($key, $pattern);
X		$matched = 1 if $match;			# Only one match needed
X		# Record matching field for futher reference if a match occurred and
X		# the selector does not start with a '!'. Record all the tested fields
X		# if's starting with a '!' (because that's what is interesting in that
X		# case). In that last case, the original macro will be restored if any
X		# match occurs.
X		if ($not || $match) {
X			$macro_ampersand .= ',' if $macro_ampersand;
X			$macro_ampersand =~ s/;,$/;/;
X			$macro_ampersand .= $key;
X		}
X		if ($match) {
X			&add_log("obtained match with '$key' field")
X				if $loglvl > 18;
X			next field;				# Try all the matching selectors
X		}
X		&add_log("no match with '$key' field") if $loglvl > 18;
X	}
X	$macro_ampersand .= ';';		# Set terminated with a ';'
X	# No need to negate status if selector was preceded by a '!': this will
X	# be done by apply match.
X	$macro_ampersand = $orig_ampersand if $not && $matched;	# Restore %&
X	&add_log("matching status for '$selector' is '$matched'")
X		if $loglvl > 18;
X	$matched;						# Return matching status
X}
X
X# Attempt a match of a pattern against a selector, return boolean status.
X# If pattern is preceded by a '!', the boolean status is negated.
Xsub selector_match {
X	local($selector) = shift(@_);	# The selector on which pattern applies
X	local($pattern) = shift(@_);	# The pattern to apply
X	local($matcher);				# Subroutine used to do the match
X	local($matched);				# Record matching status
X	local($not) = '';				# Shall we apply NOT on matching result?
X	$selector = &header'normalize($selector);	# Normalize case
X	$matcher = $Matcher{$selector};
X	$matcher = 'match_var' unless $matcher;
X	$pattern =~ s/^!// && ($not = '!');
X	$matched = &$matcher($selector, $pattern);
X	$matched = !$matched if $not;	# Revert matching status if ! pattern
X	if ($loglvl > 19) {
X		local($logmsg) = "matching '$not$pattern' on '$selector' was ";
X		$logmsg .= $matched ? "true" : "false";
X		do add_log($logmsg);
X	}
X	$matched;				# Return matching status
X}
X
X# Pattern matching functions:
X#	They are invoked as function($selector, $pattern) and return true if
X#	the pattern is found in the variable, according to some internal rules
X#	which are different among the functions. For instance, match_single will
X#	attempt a match with a login name or a regular pattern matching on the
X#	whole variable if the pattern was not a single word.
X
X# Matching is done in a header which only contains an internet address
X# If the selector starts with a >, then it is not a selector but a buffer on
X# which pattern matching is to be done.
Xsub match_single {
X	local($selector) = shift(@_);	# The variable which must be tested
X	local($pattern) = shift(@_);	# The pattern which must be used
X	local($buffer);					# Buffer on which pattern matching is done
X	local($login) = 0;				# Set to true when attempting login match
X	local(@matched);
X	if ($selector =~ s/^>([\w\-]+)<//) {	# Already a buffer for matching
X		$buffer = $selector;				# Remaining is the buffer
X		$selector = $1;						# Between > and < was selector
X	} else {
X		$buffer = $Header{$selector};
X	}
X	# If we attempt a match on a field holding e-mail addresses and the pattern
X	# is anchored at the beginning with a /^, then we only keep the address
X	# part and remove the comment if any. Otherwise, the field is left alone.
X	# Of course, if the pattern is only a single name, we extract the login
X	# name for matching purposes...
X	if ($Amatcher{$selector}) {					# Field holds an e-mail address
X		$buffer = (&parse_address($buffer))[0] if $pattern =~ m|^/\^|;
X		if ($pattern =~ m|^[-\w.*?]+\s*$|) {	# Single name may have - or .
X			$buffer = (&parse_address($buffer))[0];
X			$buffer = do login_name($buffer);	# Match done only on login name
X			$pattern =~ tr/A-Z/a-z/;	# Cannonicalize name to lower case
X		}
X		$login = 1 unless $pattern =~ m|^/|;	# Ask for case-insensitive match
X	}
X	$buffer =~ s/^\s+//;				# Remove leading spaces
X	$buffer =~ s/\s+$//;				# And trailing ones
X	$pattern = do make_pattern($pattern);
X	$pattern .= "i" if $login;			# Login matches are case-insensitive
X	@matched = eval '($buffer =~ ' . $pattern . ');';
X	# If buffer is empty, we have to recheck the pattern in a non array context
X	# to see if there is a match. Otherwise, /(.*)/ does not seem to match an
X	# empty string as it returns an empty string in $matched[0]...
X	$matched[0] = eval '$buffer =~ ' . $pattern if $buffer eq '';
X	&eval_error;						# Make sure eval worked
X	&update_backref(*matched);			# Record non-null backreferences
X	$matched[0];						# Return matching status
X}
X
X# Matching is done on a header field which may contains multiple addresses
X# This will not work if there is a ',' in the comment part of the addresses,
X# but I never saw that and I don't want to write complex code for that--RAM.
Xsub match_list {
X	local($selector) = shift(@_);	# The variable which must be tested
X	local($pattern) = shift(@_);	# The pattern which must be used
X	local($buffer);					# Buffer on which pattern matching is done
X	local($_) = $Header{$selector};	# Work on a copy of the line
X	$_ = join(' ', split(/\n/, $_));
X	local($matched) = 0;			# Set to true when matching has occurred
X	local(@list) = split(/,/);		# List of addresses
X	foreach $buffer (@list) {
X		$matched = do match_single(">$selector<$buffer", $pattern);
X		last if $matched;
X	}
X	$matched;
X}
X
X# Look for a pattern in a multi-line context
Xsub match_var {
X	local($selector) = shift(@_);		# The variable which must be tested
X	local($pattern) = shift(@_);		# The pattern we're looking for
X	local(@matched);
X	$pattern = do make_pattern($pattern);
X	$* = 1;								# Multi-line matching is attempted
X	local(@dol);						# To store backward references
X	@matched = eval '($Header{\'' . $selector . '\'} =~ ' . $pattern . ');';
X	# If buffer is empty, we have to recheck the pattern in a non array context
X	# to see if there is a match. Otherwise, /(.*)/ does not seem to match an
X	# empty string as it returns an empty string in $matched[0]...
X	$matched[0] = eval '$Header{\'' . $selector . '\'} =~ ' . $pattern
X		if $Header{$selector} eq '';
X	&eval_error;						# Make sure eval worked
X	&update_backref(*matched);			# Record non-null backreferences
X	$* = 0;
X	$matched[0];						# Return matching status
X}
X
X# Reseet the backreferences at the beginning of each rule match attempt
X# The backreferences include %& and %1 .. %99.
Xsub reset_backref {
X	$macro_ampersand = '';			# List of matched generic selector
X	@Backref = ();					# Stores backreferences provided by perl
X}
X
X# Update the backward reference array. There is a maximum of 99 backreferences
X# per filter rule. The argument list is an array of all the backreferences
X# found in the pattern matching, but the first item has to be skipped: it is
X# the whole matching string -- see comment on make_pattern().
Xsub update_backref {
X	local(*array) = @_;				# Array holding $1 .. $9, $10 ..
X	local($i, $val);
X	for ($i = 1; $i < @array; $i++) {
X		$val = $array[$i];
X		push(@Backref, $val);		# Stack backreference for later perusal
X		&add_log("stacked '$val' as backreference") if $loglvl > 18;
X	}
X}
X
END_OF_FILE
  if test 13814 -ne `wc -c <'agent/pl/matching.pl'`; then
    echo shar: \"'agent/pl/matching.pl'\" unpacked with wrong size!
  fi
  # end of 'agent/pl/matching.pl'
fi
if test -f 'agent/test/basic/filter.t' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'agent/test/basic/filter.t'\"
else
  echo shar: Extracting \"'agent/test/basic/filter.t'\" \(1706 characters\)
  sed "s/^X//" >'agent/test/basic/filter.t' <<'END_OF_FILE'
X# Make sure filter queues messages correctly
Xdo '../pl/init.pl';
Xdo '../pl/logfile.pl';
Xchdir '../out' || exit 0;
Xopen(WAIT, ">queue/agent.wait") || print "1\n";
Xclose WAIT;
X`chmod u-w queue`;
X$? == 0 || print "2\n";
X# Use the special undocumented -t option from filter to get HOME directory
X# via environment instead of /etc/passwd.
Xopen(FILTER, "|$filter -t >/dev/null 2>&1") || print "3\n";
Xprint FILTER <<EOF;
XDummy mail
XEOF
Xclose FILTER;
X$? == 0 || print "4\n";		# Must terminate correctly (stored in agent.wait)
X&get_log(5);
X&check_log('memorized', 6);	# Make sure mail has been memorized
X-s 'queue/agent.wait' || print "7\n";
X$file = <emerg/*>;
Xif (-f "$file") {
X	chop($what = `cat queue/agent.wait`);
X	chop($pwd = `pwd`);
X	$what eq "$pwd/$file" || print "8\n";
X	unlink "$file";
X} else {
X	print "8\n";
X}
X`chmod u+w queue`;
Xunlink 'queue/agent.wait', 'agentlog';
Xopen(FILTER, "|$filter -t >/dev/null 2>&1") || print "9\n";
Xprint FILTER <<EOF;
XDummy mail
XEOF
Xclose FILTER;
X$? == 0 || print "10\n";	# Must terminate correctly (queued)
X&get_log(11);
X&check_log('QUEUED', 12);	# Mail was queued
X$file = <queue/qm*>;
X-f "$file" || print "13\n";	# Must have been left in queue
Xunlink "$file", 'agentlog';
X# Make sure file is correctly queued when another filter is running
X`cp /dev/null filter.lock`;
X$? == 0 || print "14\n";
Xopen(FILTER, "|$filter -t >/dev/null 2>&1") || print "15\n";
Xprint FILTER <<EOF;
XDummy mail
XEOF
Xclose FILTER;
X$? == 0 || print "16\n";	# Must terminate correctly (queued)
X&get_log(17);
X&check_log('QUEUED', 18);	# Mail was queued
X$file = <queue/fm*>;
X-f "$file" || print "19\n";	# Must have been left in queue as a 'fm' file
Xunlink "$file", 'agentlog', 'filter.lock';
Xprint "0\n";
END_OF_FILE
  if test 1706 -ne `wc -c <'agent/test/basic/filter.t'`; then
    echo shar: \"'agent/test/basic/filter.t'\" unpacked with wrong size!
  fi
  # end of 'agent/test/basic/filter.t'
fi
echo shar: End of archive 4 \(of 17\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 17 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
