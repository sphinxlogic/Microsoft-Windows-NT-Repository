Newsgroups: comp.sources.misc
From: ram@eiffel.com (Raphael Manfredi)
Subject:  v33i097:  mailagent - Rule Based Mail Filtering, Part05/17
Message-ID: <1992Nov20.050349.13560@sparky.imd.sterling.com>
X-Md4-Signature: ff4a793c6a28c9a9b13de77c988d283c
Date: Fri, 20 Nov 1992 05:03:49 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: ram@eiffel.com (Raphael Manfredi)
Posting-number: Volume 33, Issue 97
Archive-name: mailagent/part05
Environment: Perl, Sendmail, UNIX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  Configure.b agent/filter/io.c agent/test/cmd/give.t
# Wrapped by kent@sparky on Wed Nov 18 22:42:21 1992
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 5 (of 17)."'
if test -f 'Configure.b' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Configure.b'\"
else
  echo shar: Extracting \"'Configure.b'\" \(34312 characters\)
  sed "s/^X//" >'Configure.b' <<'END_OF_FILE'
X	rp="Shall I ignore $ans() from now on?"
X	. myread
X	case "$ans" in
X	y*) d_uname="$undef" d_gethname="$undef"; $echo $n "Okay...$c";;
X	esac;;
Xesac
Xcase "$phostname" in
X'') aphostname='';;
X*) case "$aphostname" in
X	/*) ;;
X	*) set X $phostname
X		shift
X		file=$1
X		shift
X		file=`loc $file $file $pth`
X		aphostname=`echo $file $*`
X		;;
X	esac
X	;;
Xesac
Xcase "$d_uname$d_gethname" in
X*define*) ;;
X*)
X	case "$phostname" in
X	'') ;;
X	*)
X		$cat <<EOT
X
XThere is no gethostname() or uname() on this system.  You have two
Xpossibilities at this point:
X
X1)  You can have your host name ($hostname) compiled into $package, which
X    lets $package start up faster, but makes your binaries non-portable, or
X2)  you can have $package use a
X	
X	popen("$aphostname","r")
X
X    which will start slower but be more portable.
X
XIf you want option 2 but with a different command, you can edit config.sh at
Xthe end of this shell script.
X
XEOT
X		case "$d_phostname" in
X		"$define") dflt=n;;
X		"$undef")  dflt=y;;
X		'')
X			case "$d_portable" in
X			"$define") dflt=n ;;
X			*) dflt=y ;;
X			esac;;
X		esac
X		rp="Do you want your host name compiled in?"
X		. myread
X		case "$ans" in
X		n*)d_phostname="$define" ;;
X		*) phostname=''; d_phostname="$undef";;
X		esac;;
X    esac
X	case "$phostname" in
X	'')
X		echo 'No hostname function--hardwiring "'$hostname'".';;
X    esac;;
Xesac
X
X: determine where public executables go
Xcase "$bin" in
X'')
X    dflt=`loc . /bin /usr/local/bin /usr/lbin /usr/local /usr/bin`
X    ;;
X*)  dflt="$bin"
X    ;;
Xesac
Xcont=true
Xwhile $test "$cont" ; do
X    echo " "
X    rp="Where do you want to put the public executables? (~name ok)"
X    . myread
X    bin="$ans"
X    bin=`filexp $bin`
X    if test -d $bin; then
X	cont=''
X    else
X	dflt=n
X	rp="Directory $bin doesn't exist.  Use that name anyway?"
X	. myread
X	dflt=''
X	case "$ans" in
X	y*) cont='';;
X	esac
X    fi
Xdone
X
X: determine optimize, if desired, or use for debug flag also
Xcase "$optimize" in
X' ') dflt="none";;
X'') dflt="-O";;
X*) dflt="$optimize";;
Xesac
X$cat <<EOH
X
XSome C compilers have problems with their optimizers, by default, $package
Xcompiles with the -O flag to use the optimizer.  Alternately, you might want to
Xuse the symbolic debugger, which uses the -g flag (on traditional Unix systems).
XEither flag can be specified here. To use neither flag, specify the word "none".
X
XEOH
Xrp="What optimizer/debugger flag should be used?"
X. myread
Xoptimize="$ans"
Xcase "$optimize" in
X'none') optimize=" ";;
Xesac
X
Xcase "$ccflags" in
X'') case "$cc" in
X	*gcc*) dflt='-fpcc-struct-return';;
X	*) dflt='';;
X	esac
X	;;
X*) dflt="$ccflags"
X	case "$cc" in
X	*gcc*) case "$dflt" in
X		*-fpcc-struct-return*) ;;
X		*) dflt="$dflt -fpcc-struct-return";;
X		esac;;
X	esac;;
Xesac
X
Xcase "$mips_type" in
X*BSD*) ;;
X'') ;;
X*) inclwanted="$inclwanted $usrinc/bsd";;
Xesac
Xfor thisincl in $inclwanted; do
X	if $test -d $thisincl; then
X		if $test x$thisincl != x$usrinc; then
X			case "$dflt" in
X			*$thisincl*);;
X			*) dflt="$dflt -I$thisincl";;
X			esac
X		fi
X	fi
Xdone
X
Xcase "$optimize" in
X-g*)
X	case "$dflt" in
X	*DEBUG*);;
X	*) dflt="$dflt -DDEBUG";;
X	esac
X	;;
Xesac
Xif $contains 'LANGUAGE_C' $usrinc/signal.h >/dev/null 2>&1; then
X	case "$dflt" in
X	*LANGUAGE_C*);;
X	*) dflt="$dflt -DLANGUAGE_C";;
X	esac
Xelif $contains 'LANGUAGE_C' $usrinc/sys/signal.h >/dev/null 2>&1; then
X	case "$dflt" in
X	*LANGUAGE_C*);;
X	*) dflt="$dflt -DLANGUAGE_C";;
X	esac
Xfi
Xif $contains 'NO_PROTOTYPE' $usrinc/signal.h >/dev/null 2>&1; then
X	case "$dflt" in
X	*NO_PROTOTYPE*);;
X	*) dflt="$dflt -DNO_PROTOTYPE";;
X	esac
Xelif $contains 'NO_PROTOTYPE' $usrinc/sys/signal.h >/dev/null 2>&1; then
X	case "$dflt" in
X	*NO_PROTOTYPE*);;
X	*) dflt="$dflt -DNO_PROTOTYPE";;
X	esac
Xfi
Xif $contains '_NO_PROTO' $usrinc/signal.h >/dev/null 2>&1; then
X	case "$dflt" in
X	*_NO_PROTO*);;
X	*) dflt="$dflt -D_NO_PROTO";;
X	esac
Xelif $contains '_NO_PROTO' $usrinc/sys/signal.h >/dev/null 2>&1; then
X	case "$dflt" in
X	*_NO_PROTO*);;
X	*) dflt="$dflt -D_NO_PROTO";;
X	esac
Xfi
Xcase "$dflt" in
X'') dflt=none;;
Xesac
X$cat <<EOH
X
XYour C compiler may want other flags.  For this question you should include
X-I/whatever and -DWHATEVER flags and any other flags used by the C compiler,
Xbut you should NOT include libraries or ld flags like -lwhatever.  To use no
Xflags, specify the word "none".
X
XEOH
Xset X $dflt
Xshift
Xdflt=${1+"$@"}
Xrp="Any additional cc flags?"
X. myread
Xcase "$ans" in
Xnone) ans='';
Xesac
Xccflags="$ans"
X
X: the following weeds options from ccflags that are of no interest to cpp
Xcppflags="$ccflags"
Xcase "$cc" in
X*gcc*) cppflags="$cppflags -D__GNUC__";;
Xesac
Xcase "$mips_type" in
X'');;
X*BSD*) cppflags="$cppflags -DSYSTYPE_BSD43";;
Xesac
Xcase "$cppflags" in
X'');;
X*)  set X $cppflags
X	cppflags=''
X	for flag
X	do
X		case $flag in
X		-D*|-I*|-traditional|-ansi|-nostdinc) cppflags="$cppflags $flag";;
X		esac
X	done
X	case "$cppflags" in
X	*-*)  echo "(C preprocessor flags: $cppflags)";;
X	esac
X	;;
Xesac
X
X: flags used in final linking phase
Xcase "$ldflags" in
X'') if venix; then
X		dflt='-i -z'
X	else
X		dflt='none'
X	fi
X	;;
X*) dflt="$ldflags";;
Xesac
Xecho " "
Xrp="Any additional ld flags (NOT including libraries)?"
X. myread
Xcase "$ans" in
Xnone) ans='';
Xesac
Xldflags="$ans"
Xrmlist="$rmlist pdp11"
X
X: set up the script used to warn in case of inconsistency
Xcat <<'EOSC' >whoa
Xdflt=y
Xecho ' '
Xecho "*** WHOA THERE!!! ***"
Xecho "    The $hint value for \$$var on this machine was \"$was\"!"
Xrp="    Keep the $hint value?"
X. myread
Xcase "$ans" in
Xy) td=$was; tu=$was;;
Xesac
XEOSC
X
X: define an is-in-libc? function
Xinlibc='echo " "; td=$define; tu=$undef;
Xvar=$2; eval "was=\$$2";
Xif $contains "^$1\$" libc.list >/dev/null 2>&1;
Xthen echo "$1() found.";
X	eval "case \"\$$var\" in $undef) . whoa; esac"; eval "$var=\$td";
Xelse echo "$1() not found.";
X	eval "case \"\$$var\" in $define) . whoa; esac"; eval "$var=\$tu"; fi'
X
X: see if bcopy exists
Xcase "$d_bcopy" in
X$define) d_bcopy="$undef";;
X$undef) d_bcopy="$define";;
Xesac
Xset bcopy d_bcopy
Xeval $inlibc
Xcase "$d_bcopy" in
X$define) d_bcopy="$undef";;
X*) d_bcopy="$define";;
Xesac
X
X: function used to set $1 to $val
Xsetvar='var=$1; eval "was=\$$1"; td=$define; tu=$undef;
Xcase "$val$was" in
X$define$undef) . whoa; eval "$var=\$td";;
X$undef$define) . whoa; eval "$var=\$tu";;
X*) eval "$var=$val";;
Xesac'
X
X: see which of string.h or strings.h is needed
Xecho " "
Xstrings=`loc string.h "" $usrinc $inclwanted`
Xval="$undef"
Xif $test -r "$strings"; then
X	echo "Using <string.h> instead of <strings.h>."
X	if bsd; then
X		echo "(Actually, this looks more like it were an USG system)"
X	fi
X	val="$define"
Xelse
X	strings=`loc strings.h "" $usrinc $inclwanted`
X	if $test -r "$strings"; then
X		echo "Using <strings.h> instead of <string.h>."
X		if usg; then
X			echo "(Actually, this looks more like it were a BSD system)"
X		fi
X	else
X		echo "No string header found--You'll surely have problems."
X	fi
Xfi
Xset i_string
Xeval $setvar
X
X: index or strchr
Xecho " "
Xcase "$d_index" in
Xn) dflt=n;;
X*) dflt=y;;
Xesac
Xif $contains '^index$' libc.list >/dev/null 2>&1 ; then
X	if $contains '^strchr$' libc.list >/dev/null 2>&1 ; then
X		if $contains strchr "$strings" >/dev/null 2>&1 ; then
X			if $contains index "$strings" >/dev/null 2>&1 ; then
X				echo "Your system has both index() and strchr()."
X				rp="Shall I use index() rather than strchr()?"
X				. myread
X				case "$ans" in
X					n*) val="$define" ;;
X					*)  val="$undef" ;;
X				esac
X			else
X				val="$define"
X				echo "strchr() found."
X			fi
X		else
X			val="$undef"
X			echo "index() found."
X		fi
X	else
X		val="$undef"
X		echo "index() found."
X	fi
Xelse
X	if $contains '^strchr$' libc.list >/dev/null 2>&1 ; then
X		val="$define"
X		echo "strchr() found."
X	else
X		echo "No index() or strchr() found!"
X		val="$undef"
X	fi
Xfi
Xset d_index
Xeval $setvar
X
X: see if rename exists
Xset rename d_rename
Xeval $inlibc
X
X: see if strerror and/or sys_errlist[] exist
Xecho " "
Xif $contains '^strerror$' libc.list >/dev/null 2>&1; then
X    echo 'strerror() found.'
X    d_strerror="$define"
X    d_strerrm="$undef"
X	if $contains 'sys_errlist' libc.tmp >/dev/null 2>&1; then	
X		echo "You also have sys_errlist[]."
X		d_syserrlst="$define"
X	else
X		echo "But you don't have sys_errlist[]."
X		d_syserrlst="$undef"
X	fi
Xelif $contains '#[ 	]*define.*strerror' $usrinc/string*.h >/dev/null 2>&1; then
X    echo 'strerror() found in string header.'
X    d_strerror="$define"
X    d_strerrm="$undef"
X	if $contains 'sys_errlist' libc.tmp >/dev/null 2>&1; then	
X		echo "You also have sys_errlist[]."
X		d_syserrlst="$define"
X	else
X		echo "But you don't have sys_errlist[]."
X		d_syserrlst="$undef"
X	fi
Xelif $contains 'sys_errlist' libc.tmp >/dev/null 2>&1; then
X	echo "strerror() not found, but you have sys_errlist[] so we'll use that."
X    d_strerror="$undef"
X    d_syserrlst="$define"
X    d_strerrm="$define"
Xelse
X    echo 'strerror() and sys_errlist[] not found.'
X    d_strerror="$undef"
X    d_syserrlst="$undef"
X    d_strerrm="$undef"
Xfi
Xif $contains 'sys_errnolist' libc.tmp >/dev/null 2>&1; then
X	echo " "
X	echo "Symbolic error codes for errno are kept in sys_errnolist[]."
X	d_sysernlst="$define"
Xelse
X	d_sysernlst="$undef"
Xfi
X
X: see if union wait is available
Xecho " "
Xif $contains 'int.*w_status;' $usrinc/sys/wait.h >/dev/null 2>&1 ; then
X	echo "Looks like we have to use 'union wait' pointer for wait()."
X	val="$define"
Xelse
X	echo "Your wait() should be happy with a plain 'int' pointer."
X	val="$undef"
Xfi
Xset d_uwait
Xeval $setvar
X
X: see if there is a vfork
Xecho " "
Xif $contains '^vfork$' libc.list >/dev/null 2>&1 ; then
X    echo "vfork() found."
X    val="$undef"
Xelse
X    echo "No vfork() found--will use fork() instead."
X    val="$define"
Xfi
Xset d_vfork
Xeval $setvar
X
X: now get the host name to advertise as our mailing address
Xcase "$hiddennet" in
X'') dflt=n;;
X*) dflt=y;;
Xesac
X$cat <<EOM
X 
XSome sites are on "hidden" networks, in the sense that the network appears
Xto the outside world as a single machine.  The advertised name of any host
Xon this hidden network is the name of one machine on the local network which
Xknows how to forward mail to any other host on the hidden network.
X
XDo you wish to advertise a different hostname to the world than the one your
Xown host ($hostname$mydomain) has?
X
XEOM
Xrp='Use "hidden" network?'
X. myread
Xcase "$ans" in
Xn*) d_hidnet="$undef" hiddennet='';;
X*)
X    d_hidnet="$define"
X    echo " "
X    case "$hiddennet" in
X    '') dflt=`echo $mydomain | $sed -e 's/^\.//'`;;
X    *) dflt="$hiddennet";;
X    esac
X    rp="What hostname do you wish to advertise?"
X    . myread
X    hiddennet="$ans"
X    ;;
Xesac
X
X: see if this is an fcntl system
Xecho " "
Xif $test -r $usrinc/fcntl.h ; then
X    val="$define"
X    echo "<fcntl.h> found."
Xelse
X    val="$undef"
X    echo "No <fcntl.h> found, but that's ok."
Xfi
Xset i_fcntl
Xeval $setvar
X
X: define an alternate in-header-list? function
Xinhdr='echo " "; td=$define; tu=$undef; yyy=$@;
Xcont=true; xxf="echo \"<\$1> found.\"";
Xcase $# in 2) xxnf="echo \"No <\$1> found.\"";;
X*) xxnf="echo \"No <\$1> found, ...\"";;
Xesac;
Xcase $# in 4) instead=instead;; *) instead="at last";; esac;
Xwhile $test "$cont";
Xdo xxx=`loc $1 x $usrinc /usr/local/include $inclwanted`;
X	var=$2; eval "was=\$$2";
X	if $test -f $xxx;
X	then eval $xxf;
X		eval "case \"\$$var\" in $undef) . whoa; esac"; eval "$var=\$td";
X		cont="";
X	else eval $xxnf;
X		eval "case \"\$$var\" in $define) . whoa; esac"; eval "$var=\$tu"; fi;
X	set $yyy; shift; shift; yyy=$@;
X	case $# in 0) cont="";;
X	2) xxf="echo \"but I found <\$1> $instead.\"";
X		xxnf="echo \"and I did not find <\$1> either.\"";;
X	*) xxf="echo \"but I found <\$1\> instead.\"";
X		xxnf="echo \"there is no <\$1>, ...\"";;
X	esac;
Xdone;
Xwhile $test "$yyy";
Xdo set $yyy; var=$2; eval "was=\$$2";
X	eval "case \"\$$var\" in $define) . whoa; esac"; eval "$var=\$tu";
X	set $yyy; shift; shift; yyy=$@;
Xdone'
X
X: see if this is a sys/file.h system
Xset sys/file.h i_sysfile
Xeval $inhdr
X
X: see if we should include time.h, sys/time.h, or both
Xecho " "
Xecho "Testing to see if we should include <time.h>, <sys/time.h> or both."
X$echo $n "I'm now running the test program...$c"
X$cat >try.c <<'EOCP'
X#include <sys/types.h>
X#ifdef I_TIME
X#include <time.h>
X#endif
X#ifdef I_SYSTIME
X#ifdef SYSTIMEKERNEL
X#define KERNEL
X#endif
X#include <sys/time.h>
X#endif
X#ifdef I_SYSSELECT
X#include <sys/select.h>
X#endif
Xmain()
X{
X    struct tm foo;
X#ifdef S_TIMEVAL
X    struct timeval bar;
X#endif
X#ifdef S_TIMEZONE
X	struct timezone tzp;
X#endif
X    if (foo.tm_sec == foo.tm_sec)
X	exit(0);
X#ifdef S_TIMEVAL
X    if (bar.tv_sec == bar.tv_sec)
X	exit(0);
X#endif
X    exit(1);
X}
XEOCP
Xflags=''
Xfor s_timezone in '-DS_TIMEZONE' ''; do
Xsysselect=''
Xfor s_timeval in '-DS_TIMEVAL' ''; do
Xfor i_systimek in '' '-DSYSTIMEKERNEL'; do
Xfor i_time in '' '-DI_TIME'; do
Xfor i_systime in '-DI_SYSTIME' ''; do
X	case "$flags" in
X	'') $echo $n ".$c"
X		if $cc $ccflags \
X		$i_time $i_systime $i_systimek $sysselect $s_timeval $s_timezone \
X		try.c -o try >/dev/null 2>&1 ; then
X			set X $i_time $i_systime $i_systimek $sysselect $s_timeval
X			shift
X			flags="$*"
X			echo " "
X			$echo $n "Succeeded with $flags$c"
X		fi
X		;;
X	esac
Xdone
Xdone
Xdone
Xdone
Xdone
Xtimeincl=''
Xecho " "
Xcase "$flags" in
X*SYSTIMEKERNEL*) i_systimek="$define"
X	timeincl="$usrinc/sys/time.h"
X	echo "We'll include <sys/time.h> with KERNEL defined.";;
X*) i_systimek="$undef";;
Xesac
Xcase "$flags" in
X*I_TIME*) i_time="$define"
X	timeincl="$usrinc/time.h $timeincl"
X	echo "We'll include <time.h>.";;
X*) i_time="$undef";;
Xesac
Xcase "$flags" in
X*I_SYSTIME*) i_systime="$define"
X	timeincl="$usrinc/sys/time.h $timeincl"
X	echo "We'll include <sys/time.h>.";;
X*) i_systime="$undef";;
Xesac
X$rm -f try.c try
X
X: see if this is a syswait system
Xset sys/wait.h i_syswait
Xeval $inhdr
X
X: check for length of integer
Xecho " "
Xcase "$intsize" in
X'')
X	echo "Checking to see how big your integers are..."
X	$cat >try.c <<'EOCP'
X#include <stdio.h>
Xmain()
X{
X	printf("%d\n", sizeof(int));
X}
XEOCP
X	if $cc $ccflags try.c -o try >/dev/null 2>&1 ; then
X		dflt=`./try`
X	else
X		dflt='4'
X		echo "(I can't seem to compile the test program.  Guessing...)"
X	fi
X	;;
X*)
X	dflt="$intsize"
X	;;
Xesac
Xrp="What is the size of an integer (in bytes)?"
X. myread
Xintsize="$ans"
X$rm -f try.c try
X
X: determine where mail is spooled
Xcase "$maildir" in
X'') dflt=`loc . /usr/spool/mail /usr/spool/mail /usr/mail`;;
X*) dflt="$maildir";;
Xesac
Xcont=true
Xwhile $test "$cont" ; do
X	echo " "
X	rp="Where is yet-to-be-read mail spooled?"
X	. myread
X	maildir=`filexp "$ans"`
X	if $test -d "$maildir"; then
X		cont=''
X	else
X		dflt=n
X		rp="Directory $maildir doesn't exist.  Use that name anyway?"
X		. myread
X		dflt=''
X		case "$ans" in
X		y*) cont='';;
X		esac
X	fi
Xdone
X
X: determine where mail is spooled
Xcase "$mailfile" in
X'')
X    dflt="$maildir"
X    case "$dflt" in
X    '') dflt='%~/mailbox';;
X    *) dflt="$dflt/%L";;
X    esac
X    ;;
X*)  dflt="$mailfile"
X    ;;
Xesac
Xcat <<'EOM'
X
XIn the following question, you may use %~ to represent the user's home
Xdirectory, and %L to represent a users name.
X
XEOM
Xrp="In which file is yet-to-be-read mail spooled?"
X. myread
Xmailfile=`filexp "$ans"`
X
X: determine where manual pages go
X$cat <<EOM
X
X$package has manual pages available in source form.
XEOM
Xcase "$nroff" in
Xnroff)
X	echo "However, you don't have nroff, so they're probably useless to you."
X	case "$mansrc" in
X	'') mansrc="none";;
X	esac;;
Xesac
Xecho "If you don't want the manual sources installed, answer 'none'."
Xcase "$mansrc" in
X'')
X    dflt="$sysman"
X    ;;
X*)  dflt="$mansrc"
X    ;;
Xesac
Xcont=true
Xwhile $test "$cont" ; do
X    echo " "
X    rp="Where do the manual pages (source) go? (~name ok)"
X    . myread
X	case "$ans" in
X	'none') mansrc=''
X		cont='';;
X	*)
X		mansrc=`filexp "$ans"`
X		if test -d "$mansrc"; then
X			cont=''
X		else
X			dflt=n
X			rp="Directory $mansrc doesn't exist.  Use that name anyway?"
X			. myread
X			dflt=''
X			case "$ans" in
X			y*) cont='';;
X			esac
X		fi;;
X	esac
Xdone
Xcase "$mansrc" in
X'') manext='0';;
X*l) manext=l;;
X*n) manext=n;;
X*o) manext=l;;
X*p) manext=n;;
X*C) manext=C;;
X*L) manext=L;;
X*) manext=1;;
Xesac
X
X: find out how to generate dependencies
Xecho " "
Xecho "Checking how to generate makefile dependencies on your machine..."
Xtoplev=`cd ..;pwd`
X$cat >dep.c <<'EOCP'
X#include "dep.h"
XEOCP
X$cat >dep.h <<'EOCP'
X
XEOCP
Xtakeflags='flags=""
Xcase "$@" in
X*--*)
X	for arg
X	do
X		shift
X		case "$arg" in
X		--) break;;
X		*) flags="$flags $arg";;
X		esac
X	done;;
Xesac'
Xcase "$mkdep" in
X'')
X	;;
X*)
X	if test -x "$mkdep" &&
X		$mkdep dep.c >dep.out 2>/dev/null &&
X		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
X	then
X		echo "$mkdep works."
X	else
X		mkdep=
X	fi
Xesac
X
Xcase "$mkdep" in
X'')
X	$spitshell > ../mkdep <<EOM
X$startsh
X$takeflags
Xfor srcfile
Xdo
X	$cpp -M -I. $cppflags \$flags \$srcfile 2>/dev/null
Xdone
XEOM
X	mkdep=$toplev/mkdep
X	chmod +x $mkdep
X	$eunicefix $mkdep
X	if $mkdep dep.c >dep.out 2>/dev/null &&
X		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
X	then
X		echo "Looks like we can use $cpp -M."
X	else
X		mkdep=
X	fi
X	;;
Xesac
X
Xcase "$mkdep" in
X'')
X	$spitshell >../mkdep <<EOS
X$startsh
X$takeflags
Xfor srcfile
Xdo
X	case "\$srcfile" in
X	*.c) c='.c';;
X	*.y) c='.y';;
X	*.l) c='.l';;
X	esac
X	filebase=\`basename \$srcfile \$c\`
X	<\$srcfile $cpp $cppminus $cppflags -I. \$flags 2>/dev/null | \\
X	$sed -e '/^# *[0-9]/!d' \\
X		-e 's/^.*"\(.*\)".*\$/'\$filebase'.o: \1/' \\
X		-e 's|: \./|: |' \\
X		-e 's|: *$|: '\$srcfile'|' | \\
X	$grep -v '^#' | $sort | $uniq
Xdone
XEOS
X	mkdep=$toplev/mkdep
X	chmod +x $mkdep
X	$eunicefix $mkdep
X	if $mkdep dep.c >dep.out 2>/dev/null &&
X		$contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
X	then
X		echo "A shell script using $cpp does the trick."
X	else
X		echo "$cpp doesn't seem to be any use at all."
X		$spitshell >../mkdep <<EOS
X$startsh
X$takeflags
Xfor srcfile
Xdo
X	case "\$srcfile" in
X	*.c) c='.c';;
X	*.y) c='.y';;
X	*.l) c='.l';;
X	esac
X	filebase=\`basename \$srcfile \$c\`
X	echo \$filebase.o: \$srcfile
X	$grep '^#[  ]*include' \$srcfile /dev/null |
X	$sed -e 's/#[   ]*include[  ]*//' \\
X		-e 's,<\(.*\)>,"$usrinc/\1",' \\
X		-e 's/:[^"]*"\([^"]*\)".*/: \1/' \\
X		-e 's/\.c:/\.o:/'
Xdone
XEOS
X		mkdep=$toplev/mkdep
X		chmod +x $mkdep
X		$eunicefix $mkdep
X		if $mkdep dep.c >dep.out 2>/dev/null &&
X		    $contains 'dep\.o:.*dep\.h' dep.out >/dev/null 2>&1
X		then
X			cat << EOM
X
XI can use a script with grep instead, but it will make some incorrect
Xdependencies, since it doesn't understand about conditional compilation.
XMoreover, some dependencies may be missing, because scanning won't be
Xa recursive process.
XIf you have a program which generates makefile dependencies, you may want
Xto use it.  If not, you can use the script and edit the Makefile by hand
Xif you need to.
XEOM
X		else
X			mkdep=
X			cat << EOM
X
XI can't seem to generate makefile dependencies at all!  Perhaps you have a
Xprogram that does?  If you don't, you might look at the mkdep script to
Xsee if you can create one which works.
XEOM
X		fi
X	fi
Xesac
Xcont=true
Xdflt="$mkdep"
Xwhile $test "$cont" ; do
X	echo " "
Xrp="Name of program to make makefile dependencies?"
X. myread
Xmkdep="$ans"
Xmkdep=`filexp $mkdep`
Xif test -f "$mkdep"; then
X	cont=''
Xelse
X	dflt=n
X	rp="$mkdep doesn't exist.  Use that name anyway?"
X	. myread
X	dflt=''
X	case "$ans" in
X	y*) cont='';;
X	esac
Xfi
Xdone
X$rm -f dep.c dep.h dep.o dep.out
X
X: get organization name
Xlongshots='/usr/src/new /usr/src/local /usr/local/src'
Xcase "$orgname" in
X'') if xxx=`loc news/src/defs.h x $longshots`; then
X		dflt=`$sed -n 's/^.*MYORG[ 	]*"\(.*\)".*$/\1/p' $xxx`
X	else
X		dflt=''
X	fi
X	;;
X*)  dflt="$orgname";;
Xesac
X$cat << 'EOH'
X 
XPlease type the name of your organization as you want it to appear on the
XOrganization line of outgoing articles.  (It's nice if this also specifies
Xyour location.  Your city name is probably sufficient if well known.)
XFor example:
X
X    University of Southern North Dakota, Hoople
X
XYou may also put the name of a file, as long as it begins with a slash.
XFor example:
X
X    /etc/organization
X
XEOH
Xorgname=""
Xwhile test "X$orgname" = "X"; do
X    rp="Organization:"
X    . myread
X    orgname="$ans"
Xdone
X
X: determine perl absolute location
Xcase "$perlpath" in
X'')
X	if test -f /usr/bin/perl; then
X		dflt=/usr/bin/perl
X	else
X		case "$_perl" in
X		*/*) dflt="$_perl";;
X		*) dflt=/usr/bin/perl;;
X		esac
X	fi
X	;;
X*)  dflt="$perlpath"
X	;;
Xesac
Xcont=true
Xwhile $test "$cont" ; do
X	echo " "
X	rp="Where is perl located on your system?"
X	. myread
X	perlpath="$ans"
X	case "$ans" in
X	/*) if test -f $ans; then
X		cont=''
X	else
X		dflt=n
X		rp="File $ans doesn't exist.  Use that name anyway?"
X		. myread
X		dflt=''
X		case "$ans" in
X		y*) cont='';;
X		esac
X	fi
X	;;
X	*) echo "Please use an absolute path name.";;
X	esac
Xdone
X
X: see what type pids are declared as in the kernel
Xcase "$pidtype" in
X'')
X	if $contains 'pid_t;' $usrinc/sys/types.h >/dev/null 2>&1 ; then
X		dflt='pid_t';
X	else
X		dflt="int"
X	fi
X	;;
X*)  dflt="$pidtype";;
Xesac
Xecho " "
Xrp="What type are process ids on this system declared as?"
X. myread
Xpidtype="$ans"
X
X: determine where private executables go
Xcase "$privlib" in
X'')
X    dflt=/usr/lib/$package
X    test -d /usr/local/lib && dflt=/usr/local/lib/$package
X    ;;
X*)  dflt="$privlib"
X    ;;
Xesac
X$cat <<EOM
X
XThe $package package has some auxiliary files that should be put in a library
Xthat is accessible by everyone.  Where do you want to put these "private" but
Xaccessible files?
X
XEOM
Xrp="Private library path? (~name ok)"
X. myread
Xprivlib="$ans"
Xcase "$d_portable" in
X"$undef")
X    privlib=`filexp $privlib`
X    ;;
Xesac
X
X: see how we invoke the C preprocessor
Xecho " "
Xecho "Now, how can we feed standard input to your C preprocessor..."
Xcat <<'EOT' >testcpp.c
X#define ABC abc
X#define XYZ xyz
XABC.XYZ
XEOT
Xcd ..
Xecho 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
Xchmod 755 cppstdin
Xwrapper=`pwd`/cppstdin
Xcd UU
Xif test "X$cppstdin" != "X" && \
X	$cppstdin $cppminus <testcpp.c >testcpp.out 2>&1 && \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	echo "You used to use $cppstdin $cppminus so we'll use that again."
Xelif test "$cc" = gcc && \
X	(echo "Using gcc, eh?  We'll try to force gcc -E using a wrapper..."; \
X	$wrapper <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1) ; then
X	echo "Yup, we can."
X	cppstdin="$wrapper"
X	cppminus='';
Xelif echo 'Maybe "'"$cc"' -E" will work...'; \
X	$cc -E <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	echo "Yup, it does."
X	cppstdin="$cc -E"
X	cppminus='';
Xelif echo 'Nope...maybe "'"$cc"' -E -" will work...'; \
X	$cc -E - <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	echo "Yup, it does."
X	cppstdin="$cc -E"
X	cppminus='-';
Xelif echo 'Uh-uh.  Time to get fancy.  Trying a wrapper...'; \
X	$wrapper <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	cppstdin="$wrapper"
X	cppminus=''
X	echo "Eureka!"
Xelif echo 'No such luck, maybe "'$cpp'" will work...'; \
X	$cpp <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	echo "It works!"
X	cppstdin="$cpp"
X	cppminus='';
Xelif echo 'Nixed again...maybe "'$cpp' -" will work...'; \
X	$cpp - <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	echo "Hooray, it works!  I was beginning to wonder."
X	cppstdin="$cpp"
X	cppminus='-';
Xelif echo 'Nope...maybe "'"$cc"' -P" will work...'; \
X	$cc -P <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	echo "Yipee, that works!"
X	cppstdin="$cc -P"
X	cppminus='';
Xelif echo 'Nope...maybe "'"$cc"' -P -" will work...'; \
X	$cc -P - <testcpp.c >testcpp.out 2>&1; \
X	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X	echo "At long last!"
X	cppstdin="$cc -P"
X	cppminus='-';
Xelse
X	dflt=''
X	rp="No dice.  I can't find a C preprocessor.  Name one:"
X	. myread
X	cppstdin="$ans"
X	$cppstdin <testcpp.c >testcpp.out 2>&1
X	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
X		echo "OK, that will do."
X	else
X		echo "Sorry, I can't get that to work.  Go find one and rerun Configure."
X		exit 1
X	fi
Xfi
X$rm -f testcpp.c testcpp.out
X
X: get C preprocessor symbols handy
Xecho " "
Xecho $attrlist | $tr '[ - ]' '[\012-\012]' >Cppsym.know
X$cat <<EOSS >Cppsym
X$startsh
Xcase "\$1" in
X-l) list=true
X    shift
X    ;;
Xesac
Xunknown=''
Xcase "\$list\$#" in
X1|2)
X    for sym do
X	if $contains "^\$1$" Cppsym.true >/dev/null 2>&1; then
X	    exit 0
X	elif $contains "^\$1$" Cppsym.know >/dev/null 2>&1; then
X		:
X	else
X	    unknown="\$unknown \$sym"
X	fi
X    done
X    set X \$unknown
X    shift
X    ;;
Xesac
Xcase \$# in
X0) exit 1;;
Xesac
Xecho \$* | $tr '[ - ]' '[\012-\012]' | $sed -e 's/\(.*\)/\\
X#ifdef \1\\
Xexit 0; _ _ _ _\1\\	 \1\\
X#endif\\
X/' >Cppsym\$\$
Xecho exit 1 >>Cppsym\$\$
X$cppstdin $cppminus <Cppsym\$\$ >Cppsym2\$\$
Xcase "\$list" in
Xtrue) $awk 'NF > 5 {print substr(\$6,2,100)}' <Cppsym2\$\$ ;;
X*)
X    sh Cppsym2\$\$
X    status=\$?
X    ;;
Xesac
X$rm -f Cppsym\$\$ Cppsym2\$\$
Xexit \$status
XEOSS
Xchmod +x Cppsym
X$eunicefix Cppsym
Xecho "Your C preprocessor defines the following symbols:"
XCppsym -l $attrlist >Cppsym.true
X$cat Cppsym.true
Xrmlist="$rmlist Cppsym Cppsym.know Cppsym.true"
X
X: see how many register declarations we want to use
Xcase "$registers" in
X'')
X	if Cppsym vax; then
X		dflt=6
X	elif Cppsym sun mc68000 mips; then
X		dflt=10
X	elif Cppsym pyr; then
X		dflt=14
X	elif Cppsym ns32000 ns16000; then
X		dflt=5
X	elif Cppsym $smallmach; then
X		dflt=3
X	else
X		: if you have any other numbers for me, please send them in
X		dflt=6
X	fi;;
X*) dflt=$registers ;;
Xesac
Xcat <<EOM
X 
XDifferent C compilers on different machines pay attention to different numbers
Xof register declarations.  About how many register declarations in each routine
Xdoes your C compiler pay attention to?  (OK to guess)
X
XEOM
Xrp="Maximum register declarations?"
X. myread
Xregisters=$ans
Xreg1=''
X$awk "BEGIN { for (i=1; i<=16; i++) printf \"reg%d=''\n\", i}" </dev/null >.foo
X. .foo
X$awk "BEGIN { for (i=1; i<=$registers; i++) printf \"reg%d=register\n\", i}" \
X	</dev/null >.foo
X. .foo
X$rm -f .foo
X
X: determine where public executables go
Xcase "$scriptdir" in
X'')
X    dflt="$bin"
X    : guess some guesses
X    $test -d /usr/share/scripts && dflt=/usr/share/scripts
X    $test -d /usr/share/bin && dflt=/usr/share/bin
X    ;;
X*)  dflt="$scriptdir"
X    ;;
Xesac
Xcont=true
X$cat <<EOM
X 
XSome installations have a separate directory just for executable scripts so
Xthat they can mount it across multiple architectures but keep the scripts in
Xone spot.  You might, for example, have a subdirectory of /usr/share for this.
XOr you might just lump your scripts in with all your other executables.
X 
XEOM
Xwhile $test "$cont" ; do
X    rp="Where do you keep publicly executable scripts? (~name ok)"
X    . myread
X    scriptdir="$ans"
X    scriptdir=`./filexp "$scriptdir"`
X    if $test -d $scriptdir; then
X	cont=''
X    else
X	case "$fastread" in
X	yes) dflt=y;;
X	*) dflt=n;;
X	esac
X	rp="Directory $scriptdir doesn't exist.  Use that name anyway?"
X	. myread
X	dflt=''
X	case "$ans" in
X	y*) cont='';;
X	esac
X    fi
Xdone
X
X: see if signal is declared as pointer to function returning int or void
Xecho " "
X$cppstdin $cppminus $cppflags < $usrinc/signal.h >$$.tmp
Xif $contains 'int.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
X    echo "You have int (*signal())() instead of void."
X	val="$undef"
X	signal_t="int"
Xelif $contains 'void.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
X    echo "You have void (*signal())() instead of int."
X    val="$define"
X	signal_t="void"
Xelif $contains 'extern[ 	]*[(\*]*signal' $$.tmp >/dev/null 2>&1 ; then
X    echo "You have int (*signal())() instead of void."
X	val="$undef"
X	signal_t="int"
Xelse
X	case "$d_voidsig" in
X	'') echo "I can't determine whether signal handler returns void or int..."
X		dflt=void
X		rp="What type does your signal handler returns?"
X		. myread
X		case "$ans" in
X		void) val="$define"; signal_t="void";;
X		*) val="$undef"; signal_t="int";;
X		esac;;
X	*) echo "As you already told me, signal handler returns $signal_t.";;
X	esac
Xfi
Xset d_voidsig
Xeval $setvar
X$rm -f $$.tmp
X
X: see if time exists
Xecho " "
Xif $contains '^time$' libc.list >/dev/null 2>&1; then
X    echo 'time() found.'
X    val="$define"
X	case "$timetype" in
X	'')
X		if $contains 'time_t;' $usrinc/sys/types.h >/dev/null 2>&1 ; then
X			dflt='time_t';
X		else
X			dflt='long';
X		fi
X		;;
X	*)  dflt="$timetype"
X		;;
X	esac
X	cont=true
X	echo " "
X	rp="What type is returned by time() on this sytem?"
X	. myread
X	timetype="$ans"
Xelse
X    echo 'time() not found, hope that will do.'
X    val="$undef"
X	timetype='int';
Xfi
Xset d_time
Xeval $setvar
X
X: see what type uids are declared as in the kernel
Xcase "$uidtype" in
X'')
X	if $contains 'uid_t;' $usrinc/sys/types.h >/dev/null 2>&1 ; then
X		dflt='uid_t';
X	else
X		set `grep '_ruid;' $usrinc/sys/user.h 2>/dev/null` unsigned short
X		case $1 in
X		unsigned) dflt="$1 $2" ;;
X		*) dflt="$1" ;;
X		esac
X	fi
X	;;
X*)  dflt="$uidtype";;
Xesac
Xecho " "
Xrp="What type are user ids on this system declared as?"
X. myread
Xuidtype="$ans"
X
Xecho " "
Xecho "End of configuration questions."
Xecho " "
X
X: create config.sh file
Xecho " "
Xif test -d ../UU; then
X    cd ..
Xfi
Xecho "Creating config.sh..."
Xxxx=`$date 2>&1`
Xyyy=`( (logname) 2>/dev/null || whoami) 2>&1`
X$spitshell <<EOT >config.sh
X$startsh
X#
X# This file was produced by running the Configure script. It holds all the
X# definitions figured out by Configure. Should you modify one of these values,
X# do not forget to propagate your changes by running "Configure -d". You may
X# instead choose to run each of the .SH files by yourself.
X#
X
X# Configuration time: $xxx 
X# Configured by: $yyy
X# Target system: $myuname
X
Xd_bsd='$d_bsd'
Xd_eunice='$d_eunice'
Xd_xenix='$d_xenix'
Xeunicefix='$eunicefix'
XMcc='$Mcc'
Xawk='$awk'
Xbison='$bison'
Xcat='$cat'
Xchgrp='$chgrp'
Xchmod='$chmod'
Xchown='$chown'
Xcompress='$compress'
Xcp='$cp'
Xcpio='$cpio'
Xcpp='$cpp'
Xcsh='$csh'
Xdate='$date'
Xecho='$echo'
Xegrep='$egrep'
Xemacs='$emacs'
Xexpr='$expr'
Xgrep='$grep'
Xinews='$inews'
Xless='$less'
Xline='$line'
Xlint='$lint'
Xln='$ln'
Xlp='$lp'
Xlpr='$lpr'
Xls='$ls'
Xmail='$mail'
Xmailx='$mailx'
Xmake='$make'
Xmkdir='$mkdir'
Xmore='$more'
Xmv='$mv'
Xnroff='$nroff'
Xperl='$perl'
Xpg='$pg'
Xpmake='$pmake'
Xpr='$pr'
Xrm='$rm'
Xrmail='$rmail'
Xsed='$sed'
Xsendmail='$sendmail'
Xsleep='$sleep'
Xsmail='$smail'
Xsort='$sort'
Xsubmit='$submit'
Xtail='$tail'
Xtar='$tar'
Xtbl='$tbl'
Xtest='$test'
Xtouch='$touch'
Xtr='$tr'
Xtroff='$troff'
Xuname='$uname'
Xuniq='$uniq'
Xuuname='$uuname'
Xvi='$vi'
Xzcat='$zcat'
Xmyuname='$myuname'
XAuthor='$Author'
XDate='$Date'
XHeader='$Header'
XId='$Id'
XLocker='$Locker'
XLog='$Log'
XRCSfile='$RCSfile'
XRevision='$Revision'
XSource='$Source'
XState='$State'
Xbin='$bin'
Xcc='$cc'
Xccflags='$ccflags'
Xcppflags='$cppflags'
Xldflags='$ldflags'
Xlkflags='$lkflags'
Xoptimize='$optimize'
Xcontains='$contains'
Xcppminus='$cppminus'
Xcppstdin='$cppstdin'
Xd_bcopy='$d_bcopy'
Xaphostname='$aphostname'
Xd_gethname='$d_gethname'
Xd_phostname='$d_phostname'
Xd_uname='$d_uname'
Xd_hidnet='$d_hidnet'
Xhiddennet='$hiddennet'
Xd_index='$d_index'
Xd_portable='$d_portable'
Xd_rename='$d_rename'
Xd_strerrm='$d_strerrm'
Xd_strerror='$d_strerror'
Xd_sysernlst='$d_sysernlst'
Xd_syserrlst='$d_syserrlst'
Xd_time='$d_time'
Xtimetype='$timetype'
Xd_uwait='$d_uwait'
Xd_vfork='$d_vfork'
Xd_voidsig='$d_voidsig'
Xsignal_t='$signal_t'
Xhostname='$hostname'
Xmydomain='$mydomain'
Xphostname='$phostname'
Xi_fcntl='$i_fcntl'
Xi_string='$i_string'
Xstrings='$strings'
Xi_sysfile='$i_sysfile'
Xi_syswait='$i_syswait'
Xi_systime='$i_systime'
Xi_systimek='$i_systimek'
Xi_time='$i_time'
Xtimeincl='$timeincl'
Xtimezone='$timezone'
Xintsize='$intsize'
Xlibc='$libc'
Xnm_opt='$nm_opt'
Xlibpth='$libpth'
Xplibpth='$plibpth'
Xlibs='$libs'
Xmaildir='$maildir'
Xmailfile='$mailfile'
Xmanext='$manext'
Xmansrc='$mansrc'
Xmkdep='$mkdep'
Xhuge='$huge'
Xlarge='$large'
Xmedium='$medium'
Xmodels='$models'
Xsmall='$small'
Xsplit='$split'
Xc='$c'
Xn='$n'
Xorgname='$orgname'
Xpackage='$package'
Xperlpath='$perlpath'
Xpidtype='$pidtype'
Xprivlib='$privlib'
Xreg10='$reg10'
Xreg11='$reg11'
Xreg12='$reg12'
Xreg13='$reg13'
Xreg14='$reg14'
Xreg15='$reg15'
Xreg16='$reg16'
Xreg1='$reg1'
Xreg2='$reg2'
Xreg3='$reg3'
Xreg4='$reg4'
Xreg5='$reg5'
Xreg6='$reg6'
Xreg7='$reg7'
Xreg8='$reg8'
Xreg9='$reg9'
Xregisters='$registers'
Xscriptdir='$scriptdir'
Xsharpbang='$sharpbang'
Xshsharp='$shsharp'
Xspitshell='$spitshell'
Xstartsh='$startsh'
Xsysman='$sysman'
Xuidtype='$uidtype'
Xincpath='$incpath'
Xmips='$mips'
Xmips_type='$mips_type'
Xusrinc='$usrinc'
XEOT
X
X: add special variables
Xtest -f patchlevel.h && \
Xawk '/^#define/ {printf "%s=%s\n",$2,$3}' patchlevel.h >>config.sh
Xecho "CONFIG=true" >>config.sh
X
X: propagate old symbols
Xif test -f UU/config.sh; then
X	<UU/config.sh sort | uniq >UU/oldconfig.sh
X	sed -n 's/^\([a-zA-Z_0-9]*\)=.*/\1/p' config.sh config.sh UU/oldconfig.sh |\
X	sort | uniq -u >UU/oldsyms
X	set X `cat UU/oldsyms`
X	shift
X	case $# in
X	0) ;;
X	*)	echo "Hmm...You had some extra variables I don't know about...I'll try to keep 'em..."
X	for sym in `cat UU/oldsyms`; do
X		echo "    Propagating $hint variable "'$'"$sym..."
X		eval 'tmp="$'"${sym}"'"'
X		echo "$tmp" | \
X		sed -e "s/'/'\"'\"'/g" -e "s/^/$sym='/" -e "s/$/'/" >>config.sh
X	done
X	;;
X	esac
Xfi
X
X: Finish up
XCONFIG=true
X
Xecho " "
Xdflt=''
Xecho "If you didn't make any mistakes, then just type a carriage return here."
Xrp="If you need to edit config.sh, do it as a shell escape here:"
X. UU/myread
Xcase "$ans" in
X'') ;;
X*) : in case they cannot read
X    eval $ans;;
Xesac
X. ./config.sh
X
Xecho " "
Xecho "Doing variable substitutions on .SH files..."
Xif test -f MANIFEST; then
X	set x `awk '{print $1}' <MANIFEST | $grep '\.SH'`
Xelse
X	set x `find . -name "*.SH" -print`
Xfi
Xshift
Xcase $# in
X0) set x *.SH; shift;;
Xesac
Xif test ! -f $1; then
X    shift
Xfi
Xfor file in $*; do
X    case "$file" in
X    */*)
X	dir=`$expr X$file : 'X\(.*\)/'`
X	file=`$expr X$file : 'X.*/\(.*\)'`
X	(cd $dir && . $file)
X	;;
X    *)
X	. $file
X	;;
X    esac
Xdone
Xif test -f config.h.SH; then
X    if test ! -f config.h; then
X	: oops, they left it out of MANIFEST, probably, so do it anyway.
X	. config.h.SH
X    fi
Xfi
X
Xif $contains '^depend:' Makefile >/dev/null 2>&1; then
X    dflt=n
X    $cat <<EOM
X
XNow you need to generate make dependencies by running "make depend".
XYou might prefer to run it in background: "make depend > makedepend.out &"
XIt can take a while, so you might not want to run it right now.
X
XEOM
X    rp="Run make depend now?"
X    . UU/myread
X    case "$ans" in
X    y*) make depend
X	echo "Now you must run a make."
X	;;
X    *)  echo "You must run 'make depend' then 'make'."
X	;;
X    esac
Xelif test -f [Mm]akefile; then
X    echo " "
X    echo "Now you must run a make."
Xelse
X    echo "Done."
Xfi
X
X$rm -f kit*isdone
X$rm -rf UU
X: end of Configure
END_OF_FILE
 if test 34312 -ne `wc -c <'Configure.b'`; then
    echo shar: \"'Configure.b'\" unpacked with wrong size!
 elif test -f 'Configure.a'; then
    echo shar: Combining  \"'Configure'\" \(70471 characters\)
    cat 'Configure.a' 'Configure.b' > 'Configure'
    if test 70471 -ne `wc -c <'Configure'`; then
      echo shar: \"'Configure'\" combined with wrong size!
    else
      chmod u+x Configure
      rm Configure.a Configure.b
    fi
  fi
  # end of 'Configure.b'
fi
if test -f 'agent/filter/io.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'agent/filter/io.c'\"
else
  echo shar: Extracting \"'agent/filter/io.c'\" \(16581 characters\)
  sed "s/^X//" >'agent/filter/io.c' <<'END_OF_FILE'
X/*
X
X    #     ####            ####
X    #    #    #          #    #
X    #    #    #          #
X    #    #    #   ###    #
X    #    #    #   ###    #    #
X    #     ####    ###     ####
X
X	I/O routines.
X*/
X
X/*
X * $Id: io.c,v 2.9 92/07/14 16:48:13 ram Exp $
X *
X *  Copyright (c) 1992, Raphael Manfredi
X *
X *  You may redistribute only under the terms of the GNU General Public
X *  Licence as specified in the README file that comes with dist.
X *
X * $Log:	io.c,v $
X * Revision 2.9  92/07/14  16:48:13  ram
X * 3.0 beta baseline.
X * 
X */
X
X#include "config.h"
X#include "portable.h"
X#include <sys/types.h>
X#include "hash.h"
X#include "parser.h"
X#include "lock.h"
X#include "logfile.h"
X#include "environ.h"
X#include <stdio.h>
X#include <errno.h>
X#include <sys/stat.h>
X
X#ifdef I_SYSWAIT
X#include <sys/wait.h>
X#endif
X
X#ifdef I_FCNTL
X#include <fcntl.h>
X#else
X#include <sys/fcntl.h>
X#endif
X#ifdef I_SYSFILE
X#include <sys/file.h>
X#endif
X
X#ifdef I_STRING
X#include <string.h>
X#else
X#include <strings.h>
X#endif
X
X#define BUFSIZE		1024			/* Amount of bytes read in a single call */
X#define CHUNK		(10 * BUFSIZE)	/* Granularity of pool */
X#define MAX_STRING	2048			/* Maximum string's length */
X#define AGENT_WAIT	"agent.wait"	/* File listing out-of-the-queue mails */
X#define AGENT_LOCK	"perl.lock"		/* Lock file used by mailagent */
X
Xprivate void pool_realloc();	/* Extend pool zone */
Xprivate int get_lock();			/* Attempt to get a lockfile */
Xprivate void release_agent();	/* Remove mailagent's lock if needed */
Xprivate int process_mail();		/* Process mail by feeding the mailagent */
Xprivate void queue_mail();		/* Queue mail for delayed processing */
Xprivate char *write_file();		/* Write mail on disk */
Xprivate char *save_file();		/* Emergency saving into a file */
X
Xprivate char *mail = (char *) 0;	/* Where mail is stored */
Xprivate int len;					/* Mail length in bytes */
Xprivate int queued = 0;				/* True when mail queued safely */
X
Xextern int errno;				/* System call error status */
Xextern char *malloc();			/* Memory allocation */
Xextern char *realloc();			/* Re-allocation of memory pool */
Xextern char *logname();			/* User's login name */
Xextern int loglvl;				/* Logging level */
X
Xprivate void read_stdin()
X{
X	/* Read the whole stdandard input into memory and return a pointer to its
X	 * location in memory. Any I/O error is fatal. Set the length of the
X	 * data read into 'len'.
X	 */
X
X	int size;					/* Current size of memory pool */
X	int amount = 0;				/* Total amount of data read */
X	int n;						/* Bytes read by last system call */
X	char *pool;					/* Where input is stored */
X	char buf[BUFSIZE];
X
X	size = CHUNK;
X	pool = malloc(size);
X	if (pool == (char *) 0)
X		fatal("out of memory");
X
X	add_log(19, "reading mail");
X
X	while (n = read(0, buf, BUFSIZE)) {
X		if (n == -1) {
X			add_log(1, "SYSERR read: %m (%e)");
X			fatal("I/O error");
X		}
X		if (size - amount < n)				/* Pool not big enough */
X			pool_realloc(&pool, &size);		/* Resize it or fail */
X		bcopy(buf, pool + amount, n);		/* Copy read bytes */
X		amount += n;						/* Update amount of bytes read */
X	}
X
X	len = amount;				/* Indicate how many bytes where read */
X
X	add_log(16, "got mail (%d bytes)", amount);
X
X	mail = pool;				/* Where mail is stored */
X}
X
Xpublic void process()
X{
X	char *queue;						/* Location of mailagent's queue */
X
X	(void) umask(077);					/* Files we create are private ones */
X
X	queue = ht_value(&symtab, "queue");	/* Fetch queue location */
X	if (queue == (char *) 0)
X		fatal("queue directory not defined");
X
X	read_stdin();						/* Read mail */
X	(void) get_lock();					/* Get a lock file */
X	queue_mail(queue);					/* Process also it locked */
X	release_lock();						/* Release lock file if necessary */
X}
X
Xpublic int was_queued()
X{
X	return queued;			/* Was mail queued? */
X}
X
Xprivate void pool_realloc(pool, size)
Xchar **pool;
Xint *size;
X{
X	/* Make more room in pool and update parameters accordingly */
X
X	char *cpool = *pool;	/* Current location */
X	int csize = *size;		/* Current size */
X
X	csize += CHUNK;
X	cpool = realloc(cpool, csize);
X	if (cpool == (char *) 0)
X		fatal("out of memory");
X	*pool = cpool;
X	*size = csize;
X}
X
Xprivate int get_lock()
X{
X	/* Try to get a filter lock in the spool directory. Propagate the return
X	 * status of filter_lock(): 0 for ok, -1 for failure.
X	 */
X
X	char *spool;						/* Location of spool directory */
X
X	spool = ht_value(&symtab, "spool");	/* Fetch spool location */
X	if (spool == (char *) 0)
X		fatal("spool directory not defined");
X
X	return filter_lock(spool);			/* Get a lock in spool directory */
X}
X
Xprivate void release_agent()
X{
X	/* In case of abnormal failure, the mailagent may leave its lock file
X	 * in the spool directory. Remove it if necessary.
X	 */
X
X	char *spool;					/* Location of spool directory */
X	char agentlock[MAX_STRING];		/* Where lock file is held */
X	struct stat buf;				/* Stat buffer */
X
X	spool = ht_value(&symtab, "spool");	/* Fetch spool location */
X	if (spool == (char *) 0)			/* Should not happen */
X		return;
X
X	sprintf(agentlock, "%s/%s", spool, AGENT_LOCK);
X	if (-1 == stat(agentlock, &buf))
X		return;						/* Assume no lock file left behind */
X
X	if (-1 == unlink(agentlock)) {
X		add_log(1, "SYSERR unlink: %m (%e)");
X		add_log(2, "ERROR could not remove mailagent's lock");
X	} else
X		add_log(5, "NOTICE removed mailagent's lock");
X}
X
Xprivate void queue_mail(queue)
Xchar *queue;				/* Location of the queue directory */
X{
X	char *where;			/* Where mail is stored */
X	char real[MAX_STRING];	/* Real queue mail */
X	char *base;				/* Pointer to base name */
X	struct stat buf;		/* To make sure queued file remains */
X
X	where = write_file(queue, "Tm");
X	if (where == (char *) 0) {
X		add_log(1, "ERROR unable to queue mail");
X		fatal("try again later");
X	}
X
X	/* If we have a lock, create a qm* file suitable for mailagent processing.
X	 * Otherwise, create a fm* file and the mailagent will process it
X	 * immediately.
X	 */
X	if (is_locked())
X		sprintf(real, "%s/%s%d", queue, "qm", progpid);
X	else
X		sprintf(real, "%s/%s%d", queue, "fm", progpid);
X
X	if (-1 == rename(where, real)) {
X		add_log(1, "SYSERR rename: %m (%e)");
X		add_log(2, "ERROR could not rename %s into %s", where, real);
X		fatal("try again later");
X	}
X
X	/* Compute base name of queued mail */
X	base = rindex(real, '/');
X	if (base++ == (char *) 0)
X		base = real;
X
X	add_log(4, "QUEUED [%s] %d bytes", base, len);
X	queued = 1;
X
X	/* If we got a lock, then no mailagent is running and we may process the
X	 * mail. Otherwise, do nothing. The mail will be processed by the currently
X	 * active mailagent.
X	 */
X
X	if (!is_locked())			/* Another mailagent is running */
X		return;					/* Leave mail in queue */
X
X	if (0 == process_mail(real)) {
X		/* Mailagent may have simply queued the mail for itself by renaming
X		 * it, so of course we would not be able to remove it. Hence the
X		 * test for ENOENT to avoid error messages when the file does not
X		 * exit any more.
X		 */
X		if (-1 == unlink(real) && errno != ENOENT) {
X			add_log(1, "SYSERR unlink: %m (%e)");
X			add_log(2, "ERROR could not remove queued mail");
X		}
X		return;
X	}
X	/* Paranoia: make sure the queued mail is still there */
X	if (-1 == stat(real, &buf)) {
X		queued = 0;			/* Or emergency_save() would not do anything */
X		add_log(1, "SYSERR stat: %m (%e)");
X		add_log(1, "ERROR queue file [%s] vanished", base);
X		if (-1 == emergency_save())
X			add_log(1, "ERROR mail probably lost");
X	} else {
X		add_log(4, "WARNING mailagent failed, [%s] left in queue", base);
X		release_agent();	/* Remove mailagent's lock file if needed */
X	}
X}
X
Xprivate int process_mail(location)
Xchar *location;
X{
X	/* Process mail held in 'location' by invoking the mailagent on it. If the
X	 * command fails, return -1. Otherwise, return 0;
X	 * Note that we will exit if the first fork is not possible, but that is
X	 * harmless, because we know the mail was safely queued, otherwise we would
X	 * not be here trying to make the mailagent process it.
X	 */
X	
X	FILE *fp;				/* The file pointer on pipe */
X	char cmd[MAX_STRING];	/* The built command */
X	char buf[MAX_STRING];	/* To store output from mailagent */
X	char **envp;			/* Environment pointer */
X#ifdef UNION_WAIT
X	union wait status;		/* Waiting status */
X#else
X	int status;				/* Status from command */
X#endif
X	int xstat;				/* The exit status value */
X	int pid;				/* Pid of our children */
X	int res;				/* Result from wait */
X
X	if (loglvl <= 20) {		/* Loggging level higher than 20 is for tests */
X		pid = fork();
X		if (pid == -1) {	/* Resources busy, most probably */
X			release_lock();
X			add_log(1, "SYSERR fork: %m (%e)");
X			add_log(6, "NOTICE exiting to save resources");
X			exit(0);		/* Exiting will also release sendmail process */
X		} else if (pid != 0)
X			exit(0);		/* Release waiting sendmail */
X	}
X
X	/* Now hopefully we detached ourselves from sendmail, which thinks the mail
X	 * has been delivered. Not yet, but close. Simply wait a little in case
X	 * more mail is comming. This process is going to remain alive while the
X	 * mailagent is running so as to trap any weird exit status. But the size
X	 * of the perl process (with script compiled) is about 1650K on my MIPS,
X	 * so the more we delay the invocation, the better.
X	 */
X
X	if (loglvl < 12)		/* Loggging level 12 and higher is for debugging */
X		sleep(60);			/* Delay invocation of mailagent */
X	progpid = getpid();		/* This may be the child (if fork succeded) */
X	envp = make_env();		/* Build new environment */
X
X	pid = vfork();			/* Virtual fork this time... */
X	if (pid == -1) {
X		add_log(1, "SYSERR vfork: %m (%e)");
X		add_log(1, "ERROR cannot run mailagent");
X		return -1;
X	}
X
X	if (pid == 0) {			/* This is the child */
X		execle(PERLPATH, "perl", "-S", "mailagent", location, (char *) 0, envp);
X		exit(1);
X	} else {				/* Parent process */
X		while (pid != (res = wait(&status)))
X			if (res == -1) {
X				add_log(1, "SYSERR wait: %m (%e)");
X				return -1;
X			}
X
X#ifdef WEXITSTATUS
X		if (WIFEXITED(status)) {			/* Exited normally */
X			xstat = WEXITSTATUS(status);
X			if (xstat != 0) {
X				add_log(3, "ERROR mailagent returned status %d", xstat);
X				return -1;
X			}
X		} else if (WIFSIGNALED(status)) {	/* Signal received */
X			xstat = WTERMSIG(status);
X			add_log(3, "ERROR mailagent terminated by signal %d", xstat);
X			return -1;
X		} else if (WIFSTOPPED(status)) {	/* Process stopped */
X			xstat = WSTOPSIG(status);
X			add_log(3, "WARNING mailagent stopped by signal %d", xstat);
X			add_log(6, "NOTICE terminating mailagent, pid %d", pid);
X			if (-1 == kill(pid, 15))
X				add_log(1, "SYSERR kill: %m (%e)");
X			return -1;
X		} else
X			add_log(1, "BUG please report bug 'posix-wait' to author");
X#else
X#ifdef UNION_WAIT
X		xstat = status.w_status;
X#else
X		xstat = status;
X#endif
X		if ((xstat & 0xff) == 0177) {		/* Process stopped */
X			xstat >>= 8;
X			add_log(3, "WARNING mailagent stopped by signal %d", xstat);
X			add_log(6, "NOTICE terminating mailagent, pid %d", pid);
X			if (-1 == kill(pid, 15))
X				add_log(1, "SYSERR kill: %m (%e)");
X			return -1;
X		} else if ((xstat & 0xff) != 0) {	/* Signal received */
X			xstat &= 0xff;
X			if (xstat & 0200) {				/* Dumped a core ? */
X				xstat &= 0177;
X				add_log(3, "ERROR mailagent dumped core on signal %d", xstat);
X			} else
X				add_log(3, "ERROR mailagent terminated by signal %d", xstat);
X			return -1;
X		} else {
X			xstat >>= 8;
X			if (xstat != 0) {
X				add_log(3, "ERROR mailagent returned status %d", xstat);
X				return -1;
X			}
X		}
X#endif
X	}
X	
X	add_log(19, "mailagent ok");
X
X	return 0;
X}
X
Xpublic int emergency_save()
X{
X	/* Save mail in emeregency files and add the path to the agent.wait file,
X	 * so that the mailagent knows where to look when processing its queue.
X	 * Return -1 if the mail was not sucessfully saved, 0 otherwise.
X	 */
X
X	char *where;			/* Where file was stored (static data) */
X	char *home = homedir();	/* Location of the home directory */
X	char path[MAX_STRING];	/* Location of the AGENT_WAIT file */
X	char *queue;			/* Location of the queue directory */
X	char *emergdir;			/* Emergency directory */
X	int fd;					/* File descriptor to write in AGENT_WAIT */
X	int size;				/* Length of 'where' string */
X
X	if (mail == (char *) 0)
X		return -1;			/* Mail not read yet */
X
X	if (queued) {
X		add_log(6, "NOTICE mail was safely queued");
X		return 0;
X	}
X
X	emergdir = ht_value(&symtab, "emergdir");
X	if ((emergdir != (char *) 0) && (char *) 0 != (where = save_file(emergdir)))
X		goto ok;
X	if ((home != (char *) 0) && (char *) 0 != (where = save_file(home)))
X		goto ok;
X	if (where = save_file("/usr/spool/uucppublic"))
X		goto ok;
X	if (where = save_file("/var/spool/uucppublic"))
X		goto ok;
X	if (where = save_file("/usr/tmp"))
X		goto ok;
X	if (where = save_file("/var/tmp"))
X		goto ok;
X	if (where = save_file("/tmp"))
X		goto ok;
X
X	return -1;		/* Could not save mail anywhere */
X
Xok:
X	add_log(6, "DUMPED in %s", where);
X	fprintf(stderr, "%s: DUMPED in %s\n", progname, where);
X
X	/* Attempt to write path of saved mail in the AGENT_WAIT file */
X
X	queue = ht_value(&symtab, "queue");
X	if (queue == (char *) 0)
X		return 0;
X	sprintf(path, "%s/%s", queue, AGENT_WAIT);
X	if (-1 == (fd = open(path, O_WRONLY | O_APPEND | O_CREAT, 0600))) {
X		add_log(1, "SYSERR open: %m (%e)");
X		add_log(6, "WARNING mailagent ignores where mail was left");
X		return 0;
X	}
X	size = strlen(where);
X	where[size + 1] = '\0';			/* Make room for trailing new-line */
X	where[size] = '\n';
X	if (-1 == write(fd, where, size + 1)) {
X		add_log(1, "SYSERR write: %m (%e)");
X		add_log(4, "ERROR could not append to %s", path);
X		add_log(6, "WARNING mailagent ignores where mail was left");
X	} else {
X		where[size] = '\0';
X		add_log(7, "NOTICE memorized %s", where);
X		queued = 1;
X	}
X	close(fd);
X
X	return 0;
X}
X
Xprivate char *save_file(dir)
Xchar *dir;				/* Where saving should be done (directory) */
X{
X	/* Attempt to write mail in directory 'dir' and return a pointer to static
X	 * data holding the path name of the saved file if writing was ok.
X	 * Otherwise, return a null pointer and unlink any already created file.
X	 */
X
X	struct stat buf;				/* Stat buffer */
X
X	/* Make sure 'dir' entry exists, although we do not make sure it is really
X	 * a directory. If 'dir' is in fact a file, then open() will loudly
X	 * complain. We only want to avoid spurious log messages.
X	 */
X
X	if (-1 == stat(dir, &buf))		/* No entry in file system, probably */
X		return (char *) 0;			/* Saving failed */
X
X	return write_file(dir, logname());
X}
X
Xprivate char *write_file(dir, template)
Xchar *dir;				/* Where saving should be done (directory) */
Xchar *template;			/* First part of the file name */
X{
X	/* Attempt to write mail in directory 'dir' and return a pointer to static
X	 * data holding the path name of the saved file if writing was ok.
X	 * Otherwise, return a null pointer and unlink any already created file.
X	 * The file 'dir/template.$$' is created (where '$$' refers to the pid of
X	 * the current process). As login name <= 8 and pid is <= 5, we are below
X	 * the fatidic 14 chars limit for filenames.
X	 */
X
X	static char path[MAX_STRING];	/* Path name of created file */
X	int fd;							/* File descriptor */
X	register4 int n;				/* Result from the write system call */
X	register1 char *mailptr;		/* Pointer into mail buffer */
X	register2 int length;			/* Number of bytes already written */
X	register3 int amount;			/* Amount of bytes written by last call */
X
X	sprintf(path, "%s/%s.%d", dir, template, progpid);
X
X	if (-1 == (fd = open(path, O_WRONLY | O_CREAT | O_EXCL, 0600))) {
X		add_log(1, "SYSERR open: %m (%e)");
X		add_log(2, "ERROR cannot create file %s", path);
X		return (char *) 0;
X	}
X
X	/* Write the mail on disc. We do not call a single write on the mail buffer
X	 * as in "write(fd, mail, len)" in case the mail length exceeds the maximum
X	 * amount of bytes the system can atomically write.
X	 */
X	
X	for (
X		mailptr = mail, length = 0;
X		length < len;
X		mailptr += amount, length += amount
X	) {
X		amount = len - length;
X		if (amount > BUFSIZ)		/* Do not write more than BUFSIZ */
X			amount = BUFSIZ;
X		n = write(fd, mailptr, amount);
X		if (n == -1 || n != amount) {
X			if (n == -1)
X				add_log(1, "SYSERR write: %m (%e)");
X			add_log(2, "ERROR cannot write to file %s", path);
X			if (-1 == unlink(path)) {
X				add_log(1, "SYSERR unlink: %m (%e)");
X				add_log(4, "WARNING leaving %s around", path);
X			}
X			close(fd);
X			return (char *) 0;
X		}
X	}
X
X	close(fd);
X	add_log(19, "mail in %s", path);
X
X	return path;			/* Where mail was writen (static data) */
X}
X
X#ifndef RENAME
Xpublic int rename(from, to)
Xchar *from;				/* Original name */
Xchar *to;				/* Target name */
X{
X	(void) unlink(to);
X	if (-1 == link(from, to))
X		return -1;
X	if (-1 == unlink(from))
X		return -1;
X
X	return 0;
X}
X#endif
X
END_OF_FILE
  if test 16581 -ne `wc -c <'agent/filter/io.c'`; then
    echo shar: \"'agent/filter/io.c'\" unpacked with wrong size!
  fi
  # end of 'agent/filter/io.c'
fi
if test -f 'agent/test/cmd/give.t' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'agent/test/cmd/give.t'\"
else
  echo shar: Extracting \"'agent/test/cmd/give.t'\" \(494 characters\)
  sed "s/^X//" >'agent/test/cmd/give.t' <<'END_OF_FILE'
X# Test GIVE command
Xdo '../pl/cmd.pl';
Xunlink 'output';
X
X&add_header('X-Tag: give');
X`$cmd`;
X$? == 0 || print "1\n";
X-f 'output' || print "2\n";		# Where output is created
Xchop($output = `cat output 2>/dev/null`);
X@output = split(' ', $output);
X@valid = (17, 132, 804);		# Output of wc on body
X$ok = 1;
Xfor ($i = 0; $i < 3; $i++) {
X	$ok = 0 if $valid[$i] != $output[$i];
X}
X$ok || print "3\n";
X-f "$user" || print "4\n";		# Default action applies
X
Xunlink 'output', 'mail', "$user";
Xprint "0\n";
END_OF_FILE
  if test 494 -ne `wc -c <'agent/test/cmd/give.t'`; then
    echo shar: \"'agent/test/cmd/give.t'\" unpacked with wrong size!
  fi
  # end of 'agent/test/cmd/give.t'
fi
echo shar: End of archive 5 \(of 17\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 17 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
