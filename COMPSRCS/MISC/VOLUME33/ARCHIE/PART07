Newsgroups: comp.sources.misc
From: brendan@cygnus.com (Brendan Kehoe)
Subject:  v33i056:  archie - A client to query the Archie FTP databases, v1.4.1, Part07/07
Message-ID: <1992Nov5.210914.26656@sparky.imd.sterling.com>
X-Md4-Signature: 5d1a10e65d90e74b9e51e622a4dabbf4
Date: Thu, 5 Nov 1992 21:09:14 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: brendan@cygnus.com (Brendan Kehoe)
Posting-number: Volume 33, Issue 56
Archive-name: archie/part07
Environment: UNIX, VMS, DOS
Supersedes: archie: Volume 27, Issue 79-84

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  INSTALL Prospero archie.h atalloc.c get_pauth.c
#   makefile.cut makefile.dos makefile.nfs makefile.os2 patchlevel.h
#   pc-archie.nfs pcompat.h pprot.h ptalloc.c rdgram.h regex.h
#   stcopy.c vl_comp.c vlalloc.c vms.h vms/fd.h vms/multi.opt
#   vms/pseudos.h vms/socket.h vms/time.h vms/types.h vms/ucx.opt
#   vms/woll.opt
# Wrapped by kent@sparky on Thu Nov  5 12:53:10 1992
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 7 (of 7)."'
if test -f 'INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INSTALL'\"
else
  echo shar: Extracting \"'INSTALL'\" \(1590 characters\)
  sed "s/^X//" >'INSTALL' <<'END_OF_FILE'
X[Version 1.4.1]
X
X This is the minimal set of things you need to build an Archie client
Xthat takes advantage of the Prospero system.  It is derived from the
X4.2beta version of Prospero, currently available as the file prospero.tar.Z
Xon the host cs.washington.edu.  See the README in here for the full scoop.
X
X * To make the client under Unix:
X   * edit the Makefile, changing CC, OPTIONS, LDFLAGS, and RM if
X     necessary (odds are you won't have to do this..see below)
X   * edit the DEFINEs as necessary
X   * if archie.sura.net isn't "close" to you netwise, please edit
X     ARCHIE in the Makefile appropriately.  This is particularly important
X     if you're not in the US.  You don't need to touch archie.h anymore.
X   * type `make'
X
X I've tried to make this as portable as possible.  I'd encourage you
Xto try doing a "make" without any changes to the Makefile, and see how
Xit goes.  If it pukes, and you have to define something, please drop
Xme a line---my goal is for anybody to just type "make" and not have to
Xworry about things like what functions their system supports.
X
X * To make the client under VMS, just type @MAKE and it'll ask you
X   which of the available Archie servers is closest.  That's it!
X   The file `archie.hlp' is a VMS help file which can be added to your
X   system (or private) help library.
X
X * To make the client under MSDOS or OS/2:
X   * with FTP Software's PC/TCP for MSDOS (version 2.1 or higher) and
X     OS/2 (version 1.1 and higher), use makefile.os2 or makefile.dos
X   * with CUTCP (NCSA telnet), use makefile.cut
X
X-- Brendan Kehoe (brendan@cygnus.com)
END_OF_FILE
  if test 1590 -ne `wc -c <'INSTALL'`; then
    echo shar: \"'INSTALL'\" unpacked with wrong size!
  fi
  # end of 'INSTALL'
fi
if test -f 'Prospero' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Prospero'\"
else
  echo shar: Extracting \"'Prospero'\" \(1409 characters\)
  sed "s/^X//" >'Prospero' <<'END_OF_FILE'
XProspero also allows users to access Archie as if it were part of a
Xfile system.  Here is an example of how Prospero can be used to access
XArchie in this manner.
X
X  Script started on Mon Jul  1 22:36:42 1991
X  % source /home/ftp/archie/pfs/bin/vfsetup.source
X  % vfsetup guest
X  % venable
X  % cd /archive-sites/archie/regex
X  % cd prospero (This command specifies the query)
X  % ls -l
X  total 0
X  -r--r--r--   0 -               0 -            info-prospero.arc
X  dr-xr-xr-x   0 -               0 -            prospero
X  dr-xr-xr-x   0 -               0 -            prospero-papers
X  -r--r--r--   0 -               0 -            prospero.arc
X  -r--r--r--   0 -               0 -            prospero.tar.Z
X  (Note that the "vls" command could have been used)
X  (to show where the files were actually stored    )
X  % ls prospero (list a result if it is a directory)
X  prog.tar.Z      prospero.tar.Z
X  % cat info-prospero.arc  (The file is automatically retrieved and displayed)
X  >From bcn@n1dmm  Tue Dec  4 02:33:36 1990
X  Received: from n1dmm.cs.washington.edu by june.cs.washington.edu (5.64/7.0jh)
X          id AA24763; Tue, 4 Dec 90 02:33:36 -0800
X  Received: by n1dmm.cs.washington.edu (5.64/7.0h)
X          id AA08497; Tue, 4 Dec 90 02:33:31 -0800
X  Date: Tue, 4 Dec 90 02:33:31 -0800
X  From: bcn@cs.washington.edu (Clifford Neuman)
X  ...
X  % vdisable
X  % exit
X  script done on Mon Jul  1 22:39:33 1991
END_OF_FILE
  if test 1409 -ne `wc -c <'Prospero'`; then
    echo shar: \"'Prospero'\" unpacked with wrong size!
  fi
  # end of 'Prospero'
fi
if test -f 'archie.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'archie.h'\"
else
  echo shar: Extracting \"'archie.h'\" \(2294 characters\)
  sed "s/^X//" >'archie.h' <<'END_OF_FILE'
X/*
X * archie.h : Definitions for the programmatic Prospero interface to Archie
X *
X *     Written by Brendan Kehoe (brendan@cygnus.com),
X *                George Ferguson (ferguson@cs.rochester.edu), and
X *                Clifford Neuman (bcn@isi.edu).
X */
X
X/* You can't touch this.  */
X#ifndef XARCHIE
X# define ARCHIES	"archie.ans.net (USA [NY])","archie.rutgers.edu (USA [NJ])","archie.sura.net (USA [MD])","archie.unl.edu (USA [NE])","archie.mcgill.ca (Canada)","archie.funet.fi (Finland/Mainland Europe)","archie.au (Australia)","archie.doc.ic.ac.uk (Great Britain/Ireland)","archie.wide.ad.jp (Japan)","archie.ncu.edu.tw (Taiwan)"
X# define NARCHIES	10
X#endif
X
X/*
X * Default value for max hits.  Note that this is normally different
X * for different client implementations.  Doing so makes it easier to
X * collect statistics on the use of the various clients.
X */
X#ifdef VMS
X# define	MAX_HITS	98	/* VMS Client */
X#else
X# ifdef XARCHIE
X#  define	MAX_HITS	99	/* X Client */
X# else
X#  define	MAX_HITS	95	/* Normal client */
X# endif
X#endif
X
X/*
X * CLIENT_VERSION may be used to identify the version of the client if 
X * distributed separately from the Prospero distribution.  The version
X * command should then identify both the client version and the Prospero
X * version identifiers.   
X */
X#ifdef XARCHIE
X# define CLIENT_VERSION	"1.3-X"
X#else
X# define CLIENT_VERSION "1.4.1"
X#endif
X
X/* The different kinds of queries we can make.  */
Xtypedef enum query_type
X{
X  NONE = '\0', EXACT = '=', REGEXP = 'R',
X  SUBSTRING = 'S', SUBSTRING_CASE = 'C'
X} Query;
X
X/* Procedures from user/aquery.c */
Xextern VLINK archie_query (); 
X
X/* defcmplink(p,q) and invdatecmplink(p,q)                             */
Xextern int defcmplink();	/* Compare by host then by filename    */
Xextern int invdatecmplink();	/* Compare links inverted by date      */
X
X/* Definitions for the comparison procedures                           */
X#define AQ_DEFCMP	defcmplink
X#define AQ_INVDATECMP	invdatecmplink
X
X/* Flags                                                               */
X#define AQ_NOSORT	0x01	/* Don't sort                          */
X#define AQ_NOTRANS	0x02	/* Don't translate Archie responses    */
X
X/* To keep the code clean (hah!). */
X#ifdef VMS
X# define ERROR_EXIT	SS$_NORMAL
X#else
X# define ERROR_EXIT	1
X#endif
END_OF_FILE
  if test 2294 -ne `wc -c <'archie.h'`; then
    echo shar: \"'archie.h'\" unpacked with wrong size!
  fi
  # end of 'archie.h'
fi
if test -f 'atalloc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'atalloc.c'\"
else
  echo shar: Extracting \"'atalloc.c'\" \(1796 characters\)
  sed "s/^X//" >'atalloc.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989, 1990 by the University of Washington
X *
X * For copying and distribution information, please see the file
X * <copyright.h>.
X */
X
X#include <stdio.h>
X
X#include <pfs.h>
X#include <pmachine.h> /* for correct definition of ZERO */
X
Xstatic PATTRIB	lfree = NULL;
Xint		pattrib_count = 0;
Xint		pattrib_max = 0;
X
X/*
X * atalloc - allocate and initialize vlink structure
X *
X *    ATALLOC returns a pointer to an initialized structure of type
X *    PATTRIB.  If it is unable to allocate such a structure, it
X *    returns NULL.
X */
XPATTRIB
Xatalloc()
X    {
X	PATTRIB	at;
X	if(lfree) {
X	    at = lfree;
X	    lfree = lfree->next;
X	}
X	else {
X	    at = (PATTRIB) malloc(sizeof(PATTRIB_ST));
X	    if (!at) return(NULL);
X	    pattrib_max++;
X	}
X
X	pattrib_count++;
X
X	ZERO(at);
X	/* Initialize and fill in default values; all items are
X	   0 [or NULL] save precedence */
X	at->precedence = ATR_PREC_OBJECT;
X
X	return(at);
X    }
X
X/*
X * atfree - free a PATTRIB structure
X *
X *    ATFREE takes a pointer to a PATTRRIB structure and adds it to
X *    the free list for later reuse.
X */
Xvoid
Xatfree(at)
X    PATTRIB	at;
X    {
X	if(at->aname) stfree(at->aname);
X
X	if((strcmp(at->avtype,"ASCII") == 0) && at->value.ascii) 
X	    stfree(at->value.ascii);
X	if((strcmp(at->avtype,"LINK") == 0) && at->value.link) 
X	    vlfree(at->value.link);
X	
X	if(at->avtype) stfree(at->avtype);
X
X	at->next = lfree;
X	at->previous = NULL;
X	lfree = at;
X	pattrib_count--;
X    }
X
X/*
X * atlfree - free a PATTRIB structure
X *
X *    ATLFREE takes a pointer to a PATTRIB structure frees it and any linked
X *    PATTRIB structures.  It is used to free an entrie list of PATTRIB
X *    structures.
X */
Xvoid
Xatlfree(at)
X    PATTRIB	at;
X    {
X	PATTRIB	nxt;
X
X	while(at != NULL) {
X	    nxt = at->next;
X	    atfree(at);
X	    at = nxt;
X	}
X    }
X
END_OF_FILE
  if test 1796 -ne `wc -c <'atalloc.c'`; then
    echo shar: \"'atalloc.c'\" unpacked with wrong size!
  fi
  # end of 'atalloc.c'
fi
if test -f 'get_pauth.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'get_pauth.c'\"
else
  echo shar: Extracting \"'get_pauth.c'\" \(2063 characters\)
  sed "s/^X//" >'get_pauth.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989, 1990 by the University of Washington
X *
X * For copying and distribution information, please see the file
X * <copyright.h>.
X */
X
X#include <stdio.h>
X#ifndef VMS
X# include <sys/types.h> /* this may/will define FD_SET etc */
X# include <pmachine.h>
X#endif
X
X#ifdef NEED_STRING_H
X# include <string.h>
X#else
X# include <strings.h>
X#endif
X
X#ifndef VMS
X# if defined(MSDOS) && !defined(OS2) && !defined(PCNFS)
X#  ifndef CUTCP
X#   include <rwconf.h>
X#  endif
X# else
X#  include <pwd.h>
X# endif
X#else
X# include <jpidef.h>
X# include <vms.h>
X#endif
X
X#include <pcompat.h>
X#include <pauthent.h>
X
XPAUTH
Xget_pauth(type)
X    int		type;
X    {
X	static PAUTH_ST   no_auth_st;
X	static PAUTH		  no_auth = NULL;
X#if !defined(VMS) && !defined(MSDOS) || defined(OS2) || defined(PCNFS)
X	struct passwd *whoiampw;
X#else
X	char username[13];
X	unsigned short usernamelen;
X	struct {
X	    unsigned short buflen;
X	    unsigned short itmcod;
X	    char *bufadr;
X	    unsigned short *retlenadr;
X	    unsigned long null;
X	} jpi_itemlist;
X#endif
X
X	if(no_auth == NULL) {
X	    no_auth = &no_auth_st;
X	    strcpy(no_auth->auth_type,"UNAUTHENTICATED");
X
X	    /* find out who we are */
X#ifndef VMS
X#if defined(MSDOS) && !defined(OS2) && !defined(PCNFS)
X#ifndef CUTCP
X	    if (!getconf("general", "user", no_auth->authenticator, 250)
X		|| (strlen (no_auth->authenticator) == 0))
X#endif
X	      strcpy(no_auth->authenticator,"nobody");
X#else /* not MSDOS */
X	    DISABLE_PFS(whoiampw = getpwuid(getuid()));
X	    if (whoiampw == 0) strcpy(no_auth->authenticator,"nobody");
X	    else strcpy(no_auth->authenticator, whoiampw->pw_name);
X#endif /* not MSDOS */
X#else
X	    jpi_itemlist.buflen = sizeof(username);
X	    jpi_itemlist.itmcod = JPI$_USERNAME;
X	    jpi_itemlist.bufadr = &username;
X	    jpi_itemlist.retlenadr = &usernamelen;
X	    jpi_itemlist.null = 0;
X	    if (SYS$GETJPI(0, 0, 0, &jpi_itemlist, 0, 0, 0) & 0x1)
X	    {
X		username[usernamelen] = 0;
X		strcpy(no_auth->authenticator, username);
X	    } else
X		strcpy(no_auth->authenticator, "nobody");
X#endif
X	}
X	return(no_auth);
X    }
END_OF_FILE
  if test 2063 -ne `wc -c <'get_pauth.c'`; then
    echo shar: \"'get_pauth.c'\" unpacked with wrong size!
  fi
  # end of 'get_pauth.c'
fi
if test -f 'makefile.cut' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.cut'\"
else
  echo shar: Extracting \"'makefile.cut'\" \(768 characters\)
  sed "s/^X//" >'makefile.cut' <<'END_OF_FILE'
X#
X# CUTCP/CUTE BC++ version 11/22/91 bkc@omnigate.clarkson.edu
X# Last changed: 12/03/91 1.2.1
X#
X# Makefile for the minimal build for an archie Prospero client.
X#.INCLUDE ../../../builtins
X
XOBJS	= aquery.obj	archie.obj	atalloc.obj \ 
X	  get_pauth.obj	get_vdir.obj	perrmesg.obj	procquery.obj	\
X	  ptalloc.obj	regex.obj	stcopy.obj	support.obj\
X	  vlalloc.obj	vl_comp.obj 	dirsend.obj	misc.obj
X
X# dirsend.obj
X
XHDRS	= archie.h	pmachine.h	pcompat.h
X
XDEFINES	= -DDEBUG -DCUTCP
X
XCFLAGS= -k -N -ml -r -v $(DEFINES) -I.
XLFLAGS= /P/m/s
XCC = bccx
X
XEXE	= archie.exe
X
Xall: $(EXE)
X
X$(OBJS): $(HDRS)
X
X.c.obj:
X	$(CC)  $(CFLAGS) -c $<
X
X$(EXE): $(OBJS) Makefile 
X	tlink $(LFLAGS) @&&!
Xc0l $(OBJS)
X!,archie,archie,@&&!
Xlib\tcp lib\sess lib\enet lib\vjc lib\over cl
X!
X
Xclean:
X	+-del *.obj
END_OF_FILE
  if test 768 -ne `wc -c <'makefile.cut'`; then
    echo shar: \"'makefile.cut'\" unpacked with wrong size!
  fi
  # end of 'makefile.cut'
fi
if test -f 'makefile.dos' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.dos'\"
else
  echo shar: Extracting \"'makefile.dos'\" \(592 characters\)
  sed "s/^X//" >'makefile.dos' <<'END_OF_FILE'
X#
X# Last changed: 11/20/91, v1.2
X#
X# Makefile for the minimal build for an archie Prospero client.
X#.INCLUDE ../../../builtins
X
XOBJS	= aquery.lo	archie.lo	atalloc.lo	dirsend.lo	\
X	  get_pauth.lo	get_vdir.lo	perrmesg.lo	procquery.lo	\
X	  ptalloc.lo	regex.lo	stcopy.lo	support.lo	\
X	  vlalloc.lo	vl_comp.lo
XHDRS	= archie.h	pmachine.h	pcompat.h
X
XDEFINES	= -DDEBUG -DNOREGEX -DUSG
X
XCFLAGS	= -Oeclgsz -Gs -Zi -W4 -I. $(DEFINES)
X
XEXE	= archie.exe
X
Xall: $(EXE)
X
X$(OBJS): $(HDRS)
X
X$(EXE): $(OBJS) Makefile archie.lnk
X	link @archie.lnk
X	exepack archie.unp archie.exe
X
Xclean:
X	+-del *.lo
X	+-del *.exe
X
END_OF_FILE
  if test 592 -ne `wc -c <'makefile.dos'`; then
    echo shar: \"'makefile.dos'\" unpacked with wrong size!
  fi
  # end of 'makefile.dos'
fi
if test -f 'makefile.nfs' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.nfs'\"
else
  echo shar: Extracting \"'makefile.nfs'\" \(664 characters\)
  sed "s/^X//" >'makefile.nfs' <<'END_OF_FILE'
X#
X# Last changed: 11/20/91, v1.2
X#
X# Makefile for the minimal build for an archie Prospero client.
X#.INCLUDE ../../../builtins
X
XOBJS    = aquery.obj     archie.obj       atalloc.obj      dirsend.obj  \
X	  get_paut.obj  get_vdir.obj     perrmesg.obj     procquer.obj \
X	  ptalloc.obj    regex.obj        stcopy.obj       support.obj \
X	  vlalloc.obj    vl_comp.obj
XHDRS    = archie.h      pmachine.h      pcompat.h
X
XDEFINES = -DDEBUG -DPCNFS
X
XCFLAGS  =  -AL -Gs -Zi -W3 -I. $(DEFINES)
X
XEXE     = archie.exe
X
Xall: $(EXE)
X
X$(OBJS): $(HDRS)
X
X$(EXE): $(OBJS) Makefile.nfs pc-archie.nfs
X	link @pc-archie.nfs
X	exepack archie.unp archie.exe
X
Xclean:
X	del *.obj
X	del *.exe
X
END_OF_FILE
  if test 664 -ne `wc -c <'makefile.nfs'`; then
    echo shar: \"'makefile.nfs'\" unpacked with wrong size!
  fi
  # end of 'makefile.nfs'
fi
if test -f 'makefile.os2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'makefile.os2'\"
else
  echo shar: Extracting \"'makefile.os2'\" \(800 characters\)
  sed "s/^X//" >'makefile.os2' <<'END_OF_FILE'
X#
X# Last changed: 11/20/91, v1.2
X#
X# Makefile for the minimal build for an archie Prospero client.
X.INCLUDE ../../../builtins
X
XOBJS	= aquery.obj	archie.obj	atalloc.obj	dirsend.obj	\
X	  get_pauth.obj	get_vdir.obj	perrmesg.obj	procquery.obj	\
X	  ptalloc.obj	regex.obj	stcopy.obj	support.obj	\
X	  vlalloc.obj	vl_comp.obj
XHDRS	= archie.h	pmachine.h	pcompat.h
X
XDEFINES	= -DDEBUG -DNOREGEX
X
XIFLAGS	= -I. -I../../../include $(DEFINES)
X
XLFLAGS 	= /stack:30000/nod/noe/noi/map/CO
XLIBS	= pctcp bsd ftpcrt socket os2
XEXE	= archie.exe
X
Xall: $(EXE)
X
Xinstall: $(EXE)
X	cp $[m,*.exe,$**] ..\..\..\bin
X	@touch install
X
X$(OBJS): $(HDRS)
X
X$(EXE): $(OBJS) Makefile
X	$(LD) $(LFLAGS) $(L_DEBUG) <@<
X$[s,"+ \n",$[m,*.obj,$**]]
X$*
X$*
X$(LIBS)
X
X<
X	+markexe lfns $@
X	+markexe windowcompat $@
X
Xclean:
X	+-del *.obj
X	+-del *.exe
X
END_OF_FILE
  if test 800 -ne `wc -c <'makefile.os2'`; then
    echo shar: \"'makefile.os2'\" unpacked with wrong size!
  fi
  # end of 'makefile.os2'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
  echo shar: Extracting \"'patchlevel.h'\" \(980 characters\)
  sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X/*
X * Archie Client version 1.4.1.
X *
X * History:
X *
X * 10/26/92 v1.4.1	Further fixes, avoid alloca.
X * 10/20/92 v1.4	Added PCNFS support, ported to Solaris 2, print domains
X *			using reverse-sort, added archie.el to distribution,
X *			added Alex mode, -V option, use getopt.
X * 04/14/92 v1.3.2	Further porting, add ARCHIE_HOST env var, new version
X *			of make.com (VMS), support for SVR4, merged 4.2E
X *			Prospero changes, CUTCP stack fix.
X * 01/10/92 v1.3.1	Bug.
X * 01/09/92 v1.3	CUTCP (DOS) support, more VMS support (UCX), added
X *			option -L to list hosts & default server.
X * 11/20/91 v1.2	VMS support (Wallongong and Multinet),
X *			DOS and OS/2 support, new regex.c from oz, added
X *			udp.c and the testing info for UDP blockage, cope
X *			with GCC 1.x's bad sparc structure handling, and
X *			total rewrite of dirsend.c to be more modular (more
X *			usable by xarchie).
X * 08/20/91 v1.1	Major revisions and hacks of the Prospero code.
X * 07/31/91 v1.0	Original.
X */
END_OF_FILE
  if test 980 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
  fi
  # end of 'patchlevel.h'
fi
if test -f 'pc-archie.nfs' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pc-archie.nfs'\"
else
  echo shar: Extracting \"'pc-archie.nfs'\" \(236 characters\)
  sed "s/^X//" >'pc-archie.nfs' <<'END_OF_FILE'
Xaquery.obj archie.obj atalloc.obj dirsend.obj+
Xget_paut.obj get_vdir.obj perrmesg.obj procquer.obj+
Xptalloc.obj regex.obj stcopy.obj support.obj+
Xvlalloc.obj vl_comp.obj
Xarchie.unp
Xarchie/map/noi/co/li/stack:45000/seg:256
Xltklib llibce
END_OF_FILE
  if test 236 -ne `wc -c <'pc-archie.nfs'`; then
    echo shar: \"'pc-archie.nfs'\" unpacked with wrong size!
  fi
  # end of 'pc-archie.nfs'
fi
if test -f 'pcompat.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pcompat.h'\"
else
  echo shar: Extracting \"'pcompat.h'\" \(1512 characters\)
  sed "s/^X//" >'pcompat.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989, 1990 by the University of Washington
X *
X * For copying and distribution information, please see the file
X * <copyright.h>.
X */
X
X#include <copyright.h>
X
X/* 
X * pcompat.h - Definitions for compatability library
X *
X * This file contains the defintions used by the compatability
X * library.  Among the definitions are the possible values for
X * pfs_disable_flag.  This file also contains the external 
X * declaration of that variable.  Note, however that the 
X * the module pfs_disable_flag.o is included in libpfs.a
X * because some of the routines in that library set it.
X * The only place it is checked, however, is in pfs_access, 
X * found in libpcompat.a
X *
X */
X
Xextern	int		pfs_default;
Xextern	int		pfs_enable;
X
X/* Definitions for values of pfs_enable */
X#define PMAP_DISABLE      0
X#define PMAP_ENABLE       1
X#define PMAP_COLON	  2
X#define PMAP_ATSIGN_NF	  3
X#define PMAP_ATSIGN	  4
X
X#define DISABLE_PFS(stmt) do {int DpfStmp; DpfStmp = pfs_enable;\
X			   pfs_enable = PMAP_DISABLE; \
X			   stmt; \
X			   pfs_enable = DpfStmp;} while (0)
X
X/* Definitions for PFS_ACCESS */
X#define PFA_MAP           0  /* Map the file name only                       */
X#define PFA_CREATE        1  /* Create file if not found                     */
X#define PFA_CRMAP         2  /* Map file name.  Map to new name if not found */
X#define PFA_RO            4  /* Access to file is read only                  */
X
X#define check_pfs_default() \
X	do { if (pfs_default == -1) get_pfs_default(); } while (0)
END_OF_FILE
  if test 1512 -ne `wc -c <'pcompat.h'`; then
    echo shar: \"'pcompat.h'\" unpacked with wrong size!
  fi
  # end of 'pcompat.h'
fi
if test -f 'pprot.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pprot.h'\"
else
  echo shar: Extracting \"'pprot.h'\" \(2159 characters\)
  sed "s/^X//" >'pprot.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989, 1990, 1991 by the University of Washington
X *
X * For copying and distribution information, please see the file
X * <copyright.h>.
X */
X
X#include <copyright.h>
X
X#ifndef MAXPATHLEN
X# ifdef VMS
X#  define MAXPATHLEN 32
X# else /* not VMS */
X#  if defined(MSDOS) && !defined(OS2)
X#   define MAXPATHLEN 255
X#  else /* not MSDOS */
X#   ifdef ISC
X#    define MAXPATHLEN 512
X#   else /* not Interactive..normal! (gasp) */
X#    include <sys/param.h>
X#   endif /* ISC */
X#  endif /* MSDOS && !OS2 */
X# endif /* VMS */
X#endif
X
X/* Protocol Definitions */
X
X#define	       VFPROT_VNO	1      /* Protocol Version Number           */
X
X#define	       DIRSRV_PORT      1525   /* Server port used if not in srvtab */
X#define        PROSPERO_PORT	191    /* Officially assigned prived port   */
X#define	       PROS_FIRST_PRIVP 901    /* First privileged port to try      */
X#define        PROS_NUM_PRIVP   20     /* Number of privileged ports to try */
X
X#define	       MAXPKT	        1024   /* Max size of response from server  */
X#define	       SEQ_SIZE		32     /* Max size of sequence text in resp */ 
X#define	       MAX_DIR_LINESIZE 160+MAXPATHLEN /* Max linesize in directory */
X
X#define	       MAX_FWD_DEPTH    20     /* Max fwd pointers to follow        */
X
X#define S_AD_SZ		sizeof(struct sockaddr_in)
X
X/* Replacement for strtok that doesn't keep state.  Both the variable  */
X/* S and the variable S_next must be defined.  To initialize, assign   */
X/* the string to be stepped through to S_next, then call get_token on  */
X/* S.  The first token will be in S, and S_next will point to the next */
X/* token.  Like strtok, this macro does modify the string passed to it */
X#ifdef __GNUC__
X#define get_token(S,C) \
X  do { \
X    S = S##_next; \
X    if(S) { \
X     while(*S == C) S++; \
X     S##_next = index(S,C); \
X     if(S##_next) *(S##_next++) = '\0'; \
X     if(!*S) S = NULL; \
X    } \
X  } while (0)
X#else
X#define get_token(S,C) \
X    S = S/**/_next; \
X  do { \
X    if(S) { \
X     while(*S == C) S++; \
X     S/**/_next = index(S,C); \
X     if(S/**/_next) *(S/**/_next++) = '\0'; \
X     if(!*S) S = NULL; \
X    } \
X  } while (0)
X#endif /* __GNUC__ */
END_OF_FILE
  if test 2159 -ne `wc -c <'pprot.h'`; then
    echo shar: \"'pprot.h'\" unpacked with wrong size!
  fi
  # end of 'pprot.h'
fi
if test -f 'ptalloc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ptalloc.c'\"
else
  echo shar: Extracting \"'ptalloc.c'\" \(1601 characters\)
  sed "s/^X//" >'ptalloc.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989, 1990, 1991 by the University of Washington
X *
X * For copying and distribution information, please see the file
X * <copyright.h>.
X */
X
X#include <stdio.h>
X
X#include <pfs.h>
X#include <pmachine.h> /* for correct definition of ZERO */
X#ifdef MSDOS
X# define free _pfree   /* otherwise we get conflicts with free() */
X#endif
X
Xstatic PTEXT	free = NULL;
Xint 		ptext_count = 0;
Xint		ptext_max = 0;
X
X/*
X * ptalloc - allocate and initialize ptext structure
X *
X *    PTALLOC returns a pointer to an initialized structure of type
X *    PTEXT.  If it is unable to allocate such a structure, it
X *    returns NULL.
X */
XPTEXT
Xptalloc()
X    {
X	PTEXT	vt;
X	if(free) {
X	    vt = free;
X	    free = free->next;
X	}
X	else {
X	    vt = (PTEXT) malloc(sizeof(PTEXT_ST));
X	    if (!vt) return(NULL);
X	    ptext_max++;
X	}
X	ptext_count++;
X
X	/* nearly all parts are 0 [or NULL] */
X	ZERO(vt);
X	/* The offset is to leave room for additional headers */
X	vt->start = vt->dat + MAX_PTXT_HDR;
X
X	return(vt);
X    }
X
X/*
X * ptfree - free a VTEXT structure
X *
X *    VTFREE takes a pointer to a VTEXT structure and adds it to
X *    the free list for later reuse.
X */
Xvoid
Xptfree(vt)
X    PTEXT	vt;
X    {
X	vt->next = free;
X	vt->previous = NULL;
X	free = vt;
X	ptext_count--;
X    }
X
X/*
X * ptlfree - free a VTEXT structure
X *
X *    VTLFREE takes a pointer to a VTEXT structure frees it and any linked
X *    VTEXT structures.  It is used to free an entrie list of VTEXT
X *    structures.
X */
Xvoid
Xptlfree(vt)
X    PTEXT	vt;
X    {
X	PTEXT	nxt;
X
X	while(vt != NULL) {
X	    nxt = vt->next;
X	    ptfree(vt);
X	    vt = nxt;
X	}
X    }
X
END_OF_FILE
  if test 1601 -ne `wc -c <'ptalloc.c'`; then
    echo shar: \"'ptalloc.c'\" unpacked with wrong size!
  fi
  # end of 'ptalloc.c'
fi
if test -f 'rdgram.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rdgram.h'\"
else
  echo shar: Extracting \"'rdgram.h'\" \(545 characters\)
  sed "s/^X//" >'rdgram.h' <<'END_OF_FILE'
X/*
X * Copyright (c) 1991 by the University of Washington
X *
X * For copying and distribution information, please see the file
X * <copyright.h>.
X */
X
X#include <copyright.h>
X
X/* Queuing priorities for datagrams */
X#define	       RDGRAM_MAX_PRI   32765  /* Maximum user proiority          */
X#define	       RDGRAM_MAX_SPRI  32767  /* Maximum priority for system use */
X#define	       RDGRAM_MIN_PRI  -32765  /* Maximum user proiority          */
X#define	       RDGRAM_MIN_SPRI -32768  /* Maximum priority for system use */
X
Xint	rdgram_priority = 0;
END_OF_FILE
  if test 545 -ne `wc -c <'rdgram.h'`; then
    echo shar: \"'rdgram.h'\" unpacked with wrong size!
  fi
  # end of 'rdgram.h'
fi
if test -f 'regex.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'regex.h'\"
else
  echo shar: Extracting \"'regex.h'\" \(624 characters\)
  sed "s/^X//" >'regex.h' <<'END_OF_FILE'
X/*
X * regex.h : External defs for Ozan Yigit's regex functions, for systems
X *	that don't have them builtin. See regex.c for copyright and other
X *	details.
X *
X * Note that this file can be included even if we're linking against the
X * system routines, since the interface is (deliberately) identical.
X *
X * George Ferguson, ferguson@cs.rochester.edu, 11 Sep 1991.
X */
X
X#if defined(_AUX_SOURCE) || defined(USG)
X/* Let them use ours if they wish.  */
X# ifndef NOREGEX
Xextern char *regcmp();
Xextern char *regex();
X#define re_comp regcmp
X#define re_exec regex
X# endif
X#else
Xextern char *re_comp();
Xextern int re_exec();
X#endif
END_OF_FILE
  if test 624 -ne `wc -c <'regex.h'`; then
    echo shar: \"'regex.h'\" unpacked with wrong size!
  fi
  # end of 'regex.h'
fi
if test -f 'stcopy.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stcopy.c'\"
else
  echo shar: Extracting \"'stcopy.c'\" \(2054 characters\)
  sed "s/^X//" >'stcopy.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989, 1990, 1991 by the University of Washington
X *
X * For copying and distribution information, please see the file
X * <copyright.h>.
X */
X
X#include <stdio.h>
X#include <pmachine.h>
X
X#ifdef NEED_STRING_H
X# include <string.h>
X#else
X# include <strings.h>
X#endif
X
X#if defined(MSDOS)
X# include <stdlib.h>
X#endif
X
Xchar	*stcopyr();
X
Xint	string_count = 0;
Xint	string_max = 0;
X
X/*
X * stcopy - allocate space for and copy a string
X *
X *     STCOPY takes a string as an argument, allocates space for
X *     a copy of the string, copies the string to the allocated space,
X *     and returns a pointer to the copy.
X */
X
Xchar *
Xstcopy(st)
X    char	*st;
X    {
X      if (!st) return(NULL);
X      if (string_max < ++string_count) string_max = string_count;
X
X      return strcpy((char *)malloc(strlen(st) + 1), st);
X    }
X
X/*
X * stcopyr - copy a string allocating space if necessary
X *
X *     STCOPYR takes a string, S, as an argument, and a pointer to a second
X *     string, R, which is to be replaced by S.  If R is long enough to
X *     hold S, S is copied.  Otherwise, new space is allocated, and R is
X *     freed.  S is then copied to the newly allocated space.  If S is
X *     NULL, then R is freed and NULL is returned.
X *
X *     In any event, STCOPYR returns a pointer to the new copy of S,
X *     or a NULL pointer.
X */
Xchar *
Xstcopyr(s,r)
X    char	*s;
X    char	*r;
X    {
X	int	sl;
X
X	if(!s && r) {
X	    free(r);
X	    string_count--;
X	    return(NULL);
X	}
X	else if (!s) return(NULL);
X
X	sl = strlen(s) + 1;
X
X	if(r) {
X	    if ((strlen(r) + 1) < sl) {
X		free(r);
X		r = (char *) malloc(sl);
X	    }
X	}
X	else {
X	    r = (char *) malloc(sl);
X	    string_count++;
X	    if(string_max < string_count) string_max = string_count;
X	}
X	    
X	return strcpy(r,s);
X    }
X
X/*
X * stfree - free space allocated by stcopy or stalloc
X *
X *     STFREE takes a string that was returned by stcopy or stalloc 
X *     and frees the space that was allocated for the string.
X */
Xvoid
Xstfree(st)
X    char *st;
X    {
X	if(st) {
X	    free(st);
X	    string_count--;
X	}
X    }
X
X
END_OF_FILE
  if test 2054 -ne `wc -c <'stcopy.c'`; then
    echo shar: \"'stcopy.c'\" unpacked with wrong size!
  fi
  # end of 'stcopy.c'
fi
if test -f 'vl_comp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vl_comp.c'\"
else
  echo shar: Extracting \"'vl_comp.c'\" \(2114 characters\)
  sed "s/^X//" >'vl_comp.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989, 1990, 1991 by the University of Washington
X *
X * For copying and distribution information, please see the file
X * <copyright.h>.
X */
X
X#include <pfs.h>
X
X/*
X * vl_comp - compare the names of two virtual links
X *
X *           VL_COMP compares the names of two links.  It returns
X *           0 if they are equal, negative if vl1 < vl2, and positive if
X *           vl1 > vl2.
X *
X *    ARGS:  vl1,vl2 - Virtual links to be compared
X * 
X * RETURNS:  0 if equal, + is vl1 > vl2, - if vl1 < vl2
X *
X *   NOTES:  Order of significance is as follows.  Existence,
X *           name.  If names do not exist, then hosttype, host,
X *           native filenametype, native filename.  The only time
X *           the name will not exist if if the link is a union link.
X */
Xint
Xvl_comp(vl1,vl2)
X    VLINK	vl1;
X    VLINK	vl2;
X    {
X	int	retval;
X
X	if(vl1->name && !vl2->name) return(1);
X	if(!vl1->name && vl2->name) return(-1);
X	if(vl1->name && vl2->name && (*(vl1->name) || *(vl2->name)))
X	    return(strcmp(vl1->name,vl2->name));
X
X	retval = strcmp(vl1->hosttype,vl2->hosttype);
X	if(!retval) retval = strcmp(vl1->host,vl2->host);
X	if(!retval) retval = strcmp(vl1->nametype,vl2->nametype);
X	if(!retval) retval = strcmp(vl1->filename,vl2->filename);
X	return(retval);
X    }
X
X/*
X * vl_equal - compare the values of two virtual links
X *
X *           VL_EQUAL compares the values of two links.  It returns
X *           1 if all important fields are the same, and 0 otherwise.
X *
X *    ARGS:  vl1,vl2 - Virtual links to be compared
X * 
X * RETURNS:  1 if equal, 0 if not equal
X *
X */
Xint
Xvl_equal(vl1,vl2)
X    VLINK	vl1;
X    VLINK	vl2;
X    {
X      return strcmp(vl1->name, vl2->name) == 0         &&
X	     vl1->linktype == vl2->linktype            &&
X	     strcmp(vl1->type, vl2->type) == 0         &&
X	     strcmp(vl1->hosttype, vl2->hosttype) == 0 &&
X	     strcmp(vl1->host, vl2->host) == 0         &&
X	     strcmp(vl1->nametype, vl2->nametype) == 0 &&
X	     strcmp(vl1->filename, vl2->filename) == 0 &&
X	     vl1->version == vl2->version              &&
X	     vl1->f_magic_no == vl2->f_magic_no        ;
X
X    }
X
END_OF_FILE
  if test 2114 -ne `wc -c <'vl_comp.c'`; then
    echo shar: \"'vl_comp.c'\" unpacked with wrong size!
  fi
  # end of 'vl_comp.c'
fi
if test -f 'vlalloc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vlalloc.c'\"
else
  echo shar: Extracting \"'vlalloc.c'\" \(2298 characters\)
  sed "s/^X//" >'vlalloc.c' <<'END_OF_FILE'
X/*
X * Copyright (c) 1989, 1990, 1991 by the University of Washington
X *
X * For copying and distribution information, please see the file
X * <copyright.h>.
X */
X
X#include <stdio.h>
X
X#include <pfs.h>
X#include <pmachine.h>
X
Xstatic VLINK	lfree = NULL;
Xint		vlink_count = 0;
Xint		vlink_max = 0;
X
X/*
X * vlalloc - allocate and initialize vlink structure
X *
X *    VLALLOC returns a pointer to an initialized structure of type
X *    VLINK.  If it is unable to allocate such a structure, it
X *    returns NULL.
X */
XVLINK
Xvlalloc()
X    {
X	VLINK	vl;
X	if(lfree) {
X	    vl = lfree;
X	    lfree = lfree->next;
X	}
X	else {
X	    vl = (VLINK) malloc(sizeof(VLINK_ST));
X	    if (!vl) return(NULL);
X	    vlink_max++;
X	}
X
X	vlink_count++;
X
X	/* Initialize and fill in default values */
X	/* Since all but four are set to a zero-value,
X	   why not just wipe it clean?  */
X	ZERO(vl);
X
X	vl->linktype = 'L';
X	vl->type = stcopy("FILE");
X	vl->hosttype = stcopy("INTERNET-D");
X	vl->nametype = stcopy("ASCII");
X
X	return(vl);
X    }
X
X/*
X * vlfree - free a VLINK structure
X *
X *    VLFREE takes a pointer to a VLINK structure and adds it to
X *    the free list for later reuse.
X */
Xvoid
Xvlfree(vl)
X    VLINK	vl;
X    {
X        extern int string_count;
X
X	if(vl->dontfree) return;
X	/* many of these don't need to call stfree(); since a check
X	   for pointer validity's already done before even calling
X	   it, we can just call free() here then do one big decrement
X	   of string_count at the end.  */
X	if(vl->name) free(vl->name);
X	stfree(vl->type);
X	if(vl->replicas) vllfree(vl->replicas);
X	stfree(vl->hosttype);
X	if(vl->host) free(vl->host);
X	stfree(vl->nametype);
X	if(vl->filename) free(vl->filename);
X	if(vl->args) free(vl->args);
X	if(vl->lattrib) atlfree(vl->lattrib);
X	/* No allocation routines for f_info yet */
X	vl->f_info = NULL;
X	vl->next = lfree;
X	vl->previous = NULL;
X	lfree = vl;
X	vlink_count--;
X	string_count -= 4; /* freed name, host, filename, and args */
X    }
X
X/*
X * vllfree - free a VLINK structure
X *
X *    VLLFREE takes a pointer to a VLINK structure frees it and any linked
X *    VLINK structures.  It is used to free an entrie list of VLINK
X *    structures.
X */
Xvoid
Xvllfree(vl)
X    VLINK	vl;
X    {
X	VLINK	nxt;
X
X	while((vl != NULL) && !vl->dontfree) {
X	    nxt = vl->next;
X	    vlfree(vl);
X	    vl = nxt;
X	}
X    }
X
END_OF_FILE
  if test 2298 -ne `wc -c <'vlalloc.c'`; then
    echo shar: \"'vlalloc.c'\" unpacked with wrong size!
  fi
  # end of 'vlalloc.c'
fi
if test -f 'vms.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms.h'\"
else
  echo shar: Extracting \"'vms.h'\" \(1159 characters\)
  sed "s/^X//" >'vms.h' <<'END_OF_FILE'
X#ifndef _ARCHIE_VMS
X#define _ARCHIE_VMS
X#include <pmachine.h>
X
X#if !defined(MULTINET_30) && !defined(WOLLONGONG) && !defined(UCX)
X#include "[.vms]pseudos.h"
X#include "[.vms]types.h"
X#include "[.vms]in.h"
X#include "[.vms]signal.h"
X#include "[.vms]socket.h"
X#include "[.vms]time.h"
X
X#else
X
X/* time_t gets multiply defined <ekup> */
X#ifndef __TYPES
X#define __TYPES
X#endif
X#ifdef MULTINET_30
X# include "multinet_root:[multinet.include.sys]types.h"
X# include "multinet_root:[multinet.include.netinet]in.h"
X# include "multinet_root:[multinet.include.sys]socket.h"
X# include "multinet_root:[multinet.include.sys]time.h"
X#endif /* MULTINET_30 */
X
X#ifdef WOLLONGONG
X/* We don't want size_t defined.  */
X# ifndef __STDDEF
X#  define __STDDEF
X# endif
X# include "twg$tcp:[netdist.include.sys]types.h"
X# include "twg$tcp:[netdist.include.netinet]in.h"
X# include "twg$tcp:[netdist.include.sys]socket.h"
X# include "twg$tcp:[netdist.include.sys]time.h"
X#endif /* WOLLONGONG */
X
X#ifdef UCX
X# include <types.h>
X# include <in.h>
X# include <socket.h>
X# include <time.h>
X# include "[.vms]fd.h"
X#endif /* UCX */
X
X#endif /* Multinet or Wallongong or UCX */
X
X#endif /* _ARCHIE_VMS */
END_OF_FILE
  if test 1159 -ne `wc -c <'vms.h'`; then
    echo shar: \"'vms.h'\" unpacked with wrong size!
  fi
  # end of 'vms.h'
fi
if test -f 'vms/fd.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/fd.h'\"
else
  echo shar: Extracting \"'vms/fd.h'\" \(393 characters\)
  sed "s/^X//" >'vms/fd.h' <<'END_OF_FILE'
X#ifndef _VMS_FD
X#define _VMS_FD
X
Xtypedef struct fd_set
X{
X  int fds_bits[1];
X} fd_set;
X
X#define FD_SETSIZE          (sizeof (fd_set) * 8)
X#define FD_SET(f,s)         ((s)->fds_bits[0] |= (1 << (f)))
X#define FD_CLR(f,s)         ((s)->fds_bits[0] &= ~(1 << (f)))
X#define FD_ISSET(f,s)       ((s)->fds_bits[0] & (1 << (f)))
X#define FD_ZERO(s)          ((s)->fds_bits[0] = 0)
X
X#endif /* _VMS_FD */
END_OF_FILE
  if test 393 -ne `wc -c <'vms/fd.h'`; then
    echo shar: \"'vms/fd.h'\" unpacked with wrong size!
  fi
  # end of 'vms/fd.h'
fi
if test -f 'vms/multi.opt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/multi.opt'\"
else
  echo shar: Extracting \"'vms/multi.opt'\" \(73 characters\)
  sed "s/^X//" >'vms/multi.opt' <<'END_OF_FILE'
Xsys$library:vaxcrtl.exe/share
Xmultinet:multinet_socket_library.exe/share
END_OF_FILE
  if test 73 -ne `wc -c <'vms/multi.opt'`; then
    echo shar: \"'vms/multi.opt'\" unpacked with wrong size!
  fi
  # end of 'vms/multi.opt'
fi
if test -f 'vms/pseudos.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/pseudos.h'\"
else
  echo shar: Extracting \"'vms/pseudos.h'\" \(439 characters\)
  sed "s/^X//" >'vms/pseudos.h' <<'END_OF_FILE'
X/* These are so we don't end up using the MultiNet versions.  */
X#define socket	VMSsocket
X#define bind	VMSbind
X#define connect	VMSconnect
X#define listen	VMSlisten
X#define accept	VMSaccept
X#define select	VMSselect
X#define recv	VMSrecv
X#define recvfrom	VMSrecvfrom
X#define send	VMSsend
X#define sendto	VMSsendto
X#define getsockname	VMSgetsockname
X#define shutdown	VMSshutdown
X#define getsockopt	VMSgetsockopt
X#define setsockopt	VMSsetsockopt
END_OF_FILE
  if test 439 -ne `wc -c <'vms/pseudos.h'`; then
    echo shar: \"'vms/pseudos.h'\" unpacked with wrong size!
  fi
  # end of 'vms/pseudos.h'
fi
if test -f 'vms/socket.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/socket.h'\"
else
  echo shar: Extracting \"'vms/socket.h'\" \(527 characters\)
  sed "s/^X//" >'vms/socket.h' <<'END_OF_FILE'
X/* sys/socket.h */
X#define SOCK_STREAM     1
X#define SOCK_DGRAM      2
X
X#define SO_DEBUG        0x01
X#define SO_ACCEPTCONN   0x02
X#define SO_REUSEADDR    0x04
X#define SO_KEEPALIVE    0x08
X#define SO_LINGER       0x80
X#define SO_DONTLINGER   (~SO_LINGER)
X
X#define AF_UNSPEC       0
X#define AF_ERROR        0
X#define AF_INET         2
X#define AF_CCITT        10
X#define AF_X25          10
X
Xstruct sockaddr
X{
X  unsigned short sa_family;
X  char sa_data[14];
X};
X
X#define SOL_SOCKET      0xffff
X
X#define MSG_OOB 1
X#define MSG_PEEK 2
END_OF_FILE
  if test 527 -ne `wc -c <'vms/socket.h'`; then
    echo shar: \"'vms/socket.h'\" unpacked with wrong size!
  fi
  # end of 'vms/socket.h'
fi
if test -f 'vms/time.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/time.h'\"
else
  echo shar: Extracting \"'vms/time.h'\" \(459 characters\)
  sed "s/^X//" >'vms/time.h' <<'END_OF_FILE'
X#ifndef __PKTIME
X#define __PKTIME
X
Xstruct timeval
X{
X  long tv_sec;
X  long tv_usec;
X};
X
Xstruct timezone
X{
X  int tz_minuteswest;
X  int tz_dsttime;
X};
X
Xstruct itimerval
X{
X  struct timeval it_interval;
X  struct timeval it_value;
X};
X
X#define ITIMER_REAL 0
X#define timerclear(x) (x)->tv_sec = (x)->tv_usec = 0
X
X#ifndef __GNUC__
X# include <sys$library:time.h>
X#else /* not Gnu C */
X# include <gnu_cc_include:[000000]time.h>
X#endif /* Gnu C */
X
X#endif /* __PKTIME */
END_OF_FILE
  if test 459 -ne `wc -c <'vms/time.h'`; then
    echo shar: \"'vms/time.h'\" unpacked with wrong size!
  fi
  # end of 'vms/time.h'
fi
if test -f 'vms/types.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/types.h'\"
else
  echo shar: Extracting \"'vms/types.h'\" \(467 characters\)
  sed "s/^X//" >'vms/types.h' <<'END_OF_FILE'
X/* sys/types.h */
X#ifndef _types_
X#define _types_
X
X#ifndef __GNUC__
X# include <sys$library:stddef.h>
X#endif /* not Gnu C */
X
Xtypedef unsigned char u_char;
Xtypedef unsigned short u_short;
Xtypedef unsigned int u_int;
Xtypedef unsigned long u_long;
X
Xtypedef long daddr_t;
Xtypedef char *caddr_t;
X
X#include <sys$library:types.h>
X
Xtypedef unsigned short ino_t;
Xtypedef char *dev_t;
Xtypedef unsigned int off_t;
Xtypedef long key_t;
X
X#include "[.vms]fd.h"
X
X#endif /* _types */
END_OF_FILE
  if test 467 -ne `wc -c <'vms/types.h'`; then
    echo shar: \"'vms/types.h'\" unpacked with wrong size!
  fi
  # end of 'vms/types.h'
fi
if test -f 'vms/ucx.opt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/ucx.opt'\"
else
  echo shar: Extracting \"'vms/ucx.opt'\" \(54 characters\)
  sed "s/^X//" >'vms/ucx.opt' <<'END_OF_FILE'
Xsys$library:vaxcrtl.exe/share
Xsys$library:ucx$ipc/lib
END_OF_FILE
  if test 54 -ne `wc -c <'vms/ucx.opt'`; then
    echo shar: \"'vms/ucx.opt'\" unpacked with wrong size!
  fi
  # end of 'vms/ucx.opt'
fi
if test -f 'vms/woll.opt' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vms/woll.opt'\"
else
  echo shar: Extracting \"'vms/woll.opt'\" \(66 characters\)
  sed "s/^X//" >'vms/woll.opt' <<'END_OF_FILE'
Xsys$library:vaxcrtl.exe/share
Xtwg$tcp:[netdist.lib]twglib.olb/lib
END_OF_FILE
  if test 66 -ne `wc -c <'vms/woll.opt'`; then
    echo shar: \"'vms/woll.opt'\" unpacked with wrong size!
  fi
  # end of 'vms/woll.opt'
fi
echo shar: End of archive 7 \(of 7\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 7 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
