Newsgroups: comp.sources.misc
From: Warren Tucker <wht@n4hgf.Mt-Park.GA.US>
Subject:  v33i116:  u386mon - SVR3 performance/status monitor v2.60, Part07/09
Message-ID: <1992Nov22.020251.24400@sparky.imd.sterling.com>
X-Md4-Signature: 4252b4b64226e9cc61a5f6a0236f8333
Date: Sun, 22 Nov 1992 02:02:51 GMT
Approved: kent@sparky.imd.sterling.com

Submitted-by: Warren Tucker <wht@n4hgf.Mt-Park.GA.US>
Posting-number: Volume 33, Issue 116
Archive-name: u386mon/part07
Environment: SYSVR3
Supersedes: u386mon: Volume 22, Issue 3-9

#!/bin/sh
# This is part 07 of u386mon.2.60
# ============= libnlsym.h ==============
if test -f 'libnlsym.h' -a X"$1" != X"-c"; then
	echo 'x - skipping libnlsym.h (File already exists)'
else
echo 'x - extracting libnlsym.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'libnlsym.h' &&
X/* CHK=0x7095 */
X/*+-----------------------------------------------------------------------
X	libnlsym.h
X	...!{gatech,emory}!n4hgf!wht
X------------------------------------------------------------------------*/
X/*+:EDITS:*/
X/*:07-15-1992-14:31-wht@n4hgf-2.60 release - u386mon+siotools merge */
X/*:08-01-1991-23:34-wht@n4hgf-release 2.40 source control point */
X/*:08-10-1990-14:12-jmd@p1so/wht@n4hgf-2.20-add Tandem Integrity S2 */
X/*:08-07-1990-14:24-wht@n4hgf-nba@sysware.dk SVR31 updates */
X/*:08-02-1990-15:36-wht@n4hgf-2.12-old curses hacks+minor 3.2 formalizations */
X/*:07-28-1990-18:06-wht@n4hgf-2.10 release */
X/*:06-27-1990-01:57-wht@n4hgf-1.10-incorporate suggestions from alpha testers */
X/*:06-25-1990-04:14-wht@n4hgf-1.02-better error handling */
X/*:06-24-1990-20:53-wht@n4hgf-v1.01-add ISC support thanks to peter@radig.de */
X/*:06-21-1990-14:26-r@n4hgf-version x0.12 seems bug free */
X/*:10-28-1988-14:47-afterlint-creation */
X
X
X#ifndef _libnlsym_h
X#define _libnlsym_h
X
X#ifndef BUILDING_LINT_ARGS
X#ifdef LINT_ARGS
X
X/* libnlsym.c */
Xvoid nlsym_error(char * );
Xvoid nlsym_read(void);
X
X#else		/* compiler doesn't know about prototyping */
X
X/* libnlsym.c */
Xvoid nlsym_error();
Xvoid nlsym_read();
X
X#endif /* LINT_ARGS */
X#endif /* BUILDING_LINT_ARGS */
X#endif /* _libnlsym_h */
X
X/* vi: set tabstop=4 shiftwidth=4: */
X/* end of libnlsym.h */
SHAR_EOF
chmod 0644 libnlsym.h ||
echo 'restore of libnlsym.h failed'
Wc_c="`wc -c < 'libnlsym.h'`"
test 1352 -eq "$Wc_c" ||
	echo 'libnlsym.h: original size 1352, current size' "$Wc_c"
fi
# ============= lint_args.h ==============
if test -f 'lint_args.h' -a X"$1" != X"-c"; then
	echo 'x - skipping lint_args.h (File already exists)'
else
echo 'x - extracting lint_args.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'lint_args.h' &&
X/* CHK=0x3AC6 */
X/*+-----------------------------------------------------------------------
X	lint_args.h
X------------------------------------------------------------------------*/
X/*+:EDITS:*/
X/*:07-15-1992-14:32-wht@n4hgf-2.60 release - u386mon+siotools merge */
X/*:08-01-1991-23:34-wht@n4hgf-release 2.40 source control point */
X/*:08-10-1990-14:12-jmd@p1so/wht@n4hgf-2.20-add Tandem Integrity S2 */
X/*:08-07-1990-14:24-wht@n4hgf-nba@sysware.dk SVR31 updates */
X/*:08-02-1990-15:36-wht@n4hgf-2.12-old curses hacks+minor 3.2 formalizations */
X/*:07-28-1990-18:06-wht@n4hgf-2.10 release */
X/*:07-21-1990-16:01-afterlint-creation */
X
X#ifndef _lint_args_h
X#define _lint_args_h
X
X#ifndef BUILDING_LINT_ARGS
X#ifdef LINT_ARGS
X
X/* bootinfo.c */
Xextern  char *bmemf_text(unsigned long flags);
Xextern  void display_bootinfo(struct _win_st *win,int y,int x);
X/* det_proc.c */
Xextern  char *get_cpu_time_str(long ticks);
Xextern  char *pgrp_to_ttyname(int pgrp);
Xextern  char *uid_to_name(unsigned short uid);
Xextern  int det_proc_init(void );
Xextern  int get_user(struct proc *tproc,struct user *tuser);
Xextern  int getpwent_and_enter(unsigned short uid);
Xextern  int ppproc_pid_compare(struct proc * *ppp1,struct proc * *ppp2);
Xextern  int uid_name_enter(unsigned short uid,char *name);
Xextern  struct utmp *find_utmp_for_pgrp(int pgrp);
Xextern  void display_proc_stat(struct _win_st *win,int iproc,int initial);
Xextern  void display_proc_stats(struct _win_st *win,int initial);
Xextern  void init_uid_name_hash(void );
Xextern  void read_and_sort_procs(int initial);
Xextern  void read_utmp(void );
X/* det_sio.c */
Xextern  char *B_to_baud_rate(int code);
Xextern  char *cflag_to_baud_d_p_s(int cflag);
Xextern  void display_sio_summary(struct _win_st *win,int initial);
Xextern  int tty_slot_compare(struct tty *sio1,struct tty *sio2);
Xextern  void display_siofull_init(struct _win_st *win,int tly,int tlx,int show_flag);
Xextern  void display_siofull_update(struct _win_st *win,int tly,int tlx,struct tty *tsio);
Xextern  void display_siosum_update(struct _win_st *win,int y,struct tty *tsio);
Xextern  void grok_sio_tty(void );
X/* detail.c */
Xextern  void detail_init(void );
Xextern  void detail_panel_cmd(unsigned long cmd);
Xextern  void detail_panel_update(void );
Xextern  void detpanel_destroy(void );
Xextern  void detpanel_extra_init(void );
Xextern  void detpanel_extra_update(void );
Xextern  void detpanel_ps_init(int full43);
Xextern  void detpanel_ps_update(void );
Xextern  void detpanel_sio_init(void );
Xextern  void detpanel_sio_update(void );
X/* disputil.c */
Xextern  PANEL *mkpanel(int rows,int cols,int tly,int tlx,char *userp);
Xextern  void clear_area(struct _win_st *win,int y,int x,int len);
Xextern  void clear_area_char(struct _win_st *win,int y,int x,int len,unsigned char fillchar);
Xextern  void disp_info_int(struct _win_st *win,char *label,char *fmt,int value);
Xextern  void disp_info_long(struct _win_st *win,char *label,char *fmt,long value);
Xextern  void disp_msg(unsigned long cp,char *msg);
Xextern  void disp_static_int(struct _win_st *win,char *label,char *fmt,int value);
Xextern  void disp_static_long(struct _win_st *win,char *label,char *fmt,long value);
Xextern  void pflush(void );
Xextern  void wperror(struct _win_st *win,char *desc);
X/* libkmem.c */
Xextern  void kinit(int write_needed);
Xextern  void kread(char *caddr,long kaddr,int len);
X/* libmem.c */
Xextern  void minit(int write_needed);
Xextern  void mread(char *caddr,long maddr,int len);
X/* libnlsym.c */
Xextern  void nlsym_error(char *text);
Xextern  void nlsym_read(void );
X/* libswap.c */
Xextern  void sinit(void );
Xextern  void sread(char *caddr,long maddr,int len);
X/* nlsym.c */
Xextern  int main(int argc,char * *argv,char * *envp);
Xextern  void nlsym_write_error(int code);
X/* proc.c */
Xextern  char *pstat_text(char pstat);
Xextern  void display_proc(struct _win_st *win,int y,int x);
Xextern  void grok_proc(void );
X/* tune.c */
Xextern  void display_tune(struct _win_st *win,int y,int x);
X/* u386mon.c */
Xextern  char *get_elapsed_time(long elapsed_seconds);
Xextern  int get_cpu_avg(long *cpu_ticks,int period);
Xextern  int get_wait_avg(long *wait_ticks,int period);
Xextern  int main(int argc,char * *argv,char * *envp);
Xextern  long update_cpuscale(struct _win_st *win,int y,int x,int width,long *per_state);
Xextern  long update_waitscale(struct _win_st *win,int y,int x,int width,long *per_state,long total_ticks);
Xextern  void calc_cpu_avg(long *per_state);
Xextern  void calc_wait_avg(long *per_state);
Xextern  void caught_signal(int sig);
Xextern  void draw_cpuscale_literals(struct _win_st *win,int y,int x);
Xextern  void draw_per_sec_literals(struct _win_st *win,int y,int x);
Xextern  void draw_waitscale_literals(struct _win_st *win,int y,int x);
Xextern  void extra_info_stuff(void );
Xextern  void extra_static_stuff(void );
Xextern  void leave(int exit_code);
Xextern  void leave_text(char *text,int exit_code);
Xextern  void leaving(void );
Xextern  void read_sysinfo_and_minfo(void );
X/* var.c */
Xextern  void display_var(struct _win_st *win,int y,int x);
X
X#else		/* compiler doesn't know about prototyping */
X
X/* bootinfo.c */
Xextern  char *bmemf_text();
Xextern  void display_bootinfo();
X/* det_proc.c */
Xextern  char *get_cpu_time_str();
Xextern  char *pgrp_to_ttyname();
Xextern  char *uid_to_name();
Xextern  int det_proc_init();
Xextern  int get_user();
Xextern  int getpwent_and_enter();
Xextern  int ppproc_pid_compare();
Xextern  int uid_name_enter();
Xextern  struct utmp *find_utmp_for_pgrp();
Xextern  void display_proc_stat();
Xextern  void display_proc_stats();
Xextern  void init_uid_name_hash();
Xextern  void read_and_sort_procs();
Xextern  void read_utmp();
X/* det_sio.c */
Xextern  char *B_to_baud_rate();
Xextern  char *cflag_to_baud_d_p_s();
Xextern  void display_sio_summary();
Xextern  int tty_slot_compare();
Xextern  void display_siofull_init();
Xextern  void display_siofull_update();
Xextern  void display_siosum_update();
Xextern  void grok_sio_tty();
X/* detail.c */
Xextern  void detail_init();
Xextern  void detail_panel_cmd();
Xextern  void detail_panel_update();
Xextern  void detpanel_destroy();
Xextern  void detpanel_extra_init();
Xextern  void detpanel_extra_update();
Xextern  void detpanel_ps_init();
Xextern  void detpanel_ps_update();
Xextern  void detpanel_sio_init();
Xextern  void detpanel_sio_update();
X/* disputil.c */
Xextern  PANEL *mkpanel();
Xextern  void clear_area();
Xextern  void clear_area_char();
Xextern  void disp_info_int();
Xextern  void disp_info_long();
Xextern  void disp_msg();
Xextern  void disp_static_int();
Xextern  void disp_static_long();
Xextern  void pflush();
Xextern  void wperror();
X/* libkmem.c */
Xextern  void kinit();
Xextern  void kread();
X/* libmem.c */
Xextern  void minit();
Xextern  void mread();
X/* libnlsym.c */
Xextern  void nlsym_error();
Xextern  void nlsym_read();
X/* libswap.c */
Xextern  void sinit();
Xextern  void sread();
X/* nlsym.c */
Xextern  int main();
Xextern  void nlsym_write_error();
X/* proc.c */
Xextern  char *pstat_text();
Xextern  void display_proc();
Xextern  void grok_proc();
X/* tune.c */
Xextern  void display_tune();
X/* u386mon.c */
Xextern  char *get_elapsed_time();
Xextern  int get_cpu_avg();
Xextern  int get_wait_avg();
Xextern  int main();
Xextern  long update_cpuscale();
Xextern  long update_waitscale();
Xextern  void calc_cpu_avg();
Xextern  void calc_wait_avg();
Xextern  void caught_signal();
Xextern  void draw_cpuscale_literals();
Xextern  void draw_per_sec_literals();
Xextern  void draw_waitscale_literals();
Xextern  void extra_info_stuff();
Xextern  void extra_static_stuff();
Xextern  void leave();
Xextern  void leave_text();
Xextern  void leaving();
Xextern  void read_sysinfo_and_minfo();
X/* var.c */
Xextern  void display_var();
X
X#endif /* LINT_ARGS */
X#endif /* BUILDING_LINT_ARGS */
X#endif /* _lint_args_h */
X
X/* vi: set tabstop=4 shiftwidth=4: */
X/* end of lint_args.h */
SHAR_EOF
chmod 0644 lint_args.h ||
echo 'restore of lint_args.h failed'
Wc_c="`wc -c < 'lint_args.h'`"
test 7817 -eq "$Wc_c" ||
	echo 'lint_args.h: original size 7817, current size' "$Wc_c"
fi
# ============= nlsym.h ==============
if test -f 'nlsym.h' -a X"$1" != X"-c"; then
	echo 'x - skipping nlsym.h (File already exists)'
else
echo 'x - extracting nlsym.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'nlsym.h' &&
X/* CHK=0x88A7 */
X/*+-------------------------------------------------------------------------
X	nlsym.h -- utility nlist - fast access to kernel /dev/kmem offsets
X	...!{gatech,emory}!n4hgf!wht
X
XThe nlsym file contains three records:
X1.  struct stat unixstat - stat buffer from /unix at file creation time
X2.  struct nlist nlsym - the structure of nlist'd information
X3.  long unique - a unique identifier to help ensure correct nlsym length
X
X--------------------------------------------------------------------------*/
X/*+:EDITS:*/
X/*:07-15-1992-14:32-wht@n4hgf-2.60 release - u386mon+siotools merge */
X/*:08-20-1991-12:44-root@n4hgf-nba@sysware.dk S5R31 and config reorg */
X/*:08-14-1991-13:04-wht@n4hgf-STREAMS and table works for ISC 2.2 */
X/*:08-01-1991-23:34-wht@n4hgf-release 2.40 source control point */
X/*:05-15-1991-17:22-wht@n4hgf-2.3 patches for SVR31 from nba@sysware.dk */
X/*:04-16-1991-02:25-martin@hppcmart additions for SCO 3.2.2 */
X/*:08-10-1990-14:12-jmd@p1so/wht@n4hgf-2.20-add Tandem Integrity S2 */
X/*:08-07-1990-14:24-wht@n4hgf-nba@sysware.dk SVR31 updates */
X/*:08-02-1990-15:36-wht@n4hgf-2.12-old curses hacks+minor 3.2 formalizations */
X/*:07-28-1990-18:06-wht@n4hgf-2.10 release */
X/*:06-27-1990-01:57-wht@n4hgf-1.10-incorporate suggestions from alpha testers */
X/*:06-27-1990-01:55-wht@n4hgf-use 64 bits of unique check */
X/*:06-25-1990-04:14-wht@n4hgf-1.02-better error handling */
X/*:06-24-1990-20:53-wht@n4hgf-v1.01-add ISC support thanks to peter@radig.de */
X/*:06-21-1990-14:26-r@n4hgf-version x0.12 seems bug free */
X/*:10-27-1988-11:07-wht-creation */
X
X#ifndef _nlsym_h
X#define _nlsym_h
X
X#define UNIX_KERNEL		"/unix"
X#define UNIX_NLSYM		"/unix.nlsym"
X#define NLSYM_UNIQUE1	0x1BADD00DL
X#define NLSYM_UNIQUE2	0xDEADB1FFL
X
X#define Nindex_AVAILRMEM            0
X#define Nindex_AVAILSMEM            1
X#define Nindex_BDEVCNT              2
X#define Nindex_BDEVSW               3
X#if defined(HAS_BOOTINFO)
X#define Nindex_BOOTINFO             4
X#endif
X#define Nindex_CDEVCNT              5
X#define Nindex_CDEVSW               6
X#define Nindex_CFREE                7
X#define Nindex_CFREECNT             8
X#define Nindex_CFREELIST            9
X#if defined(M_UNIX)
X#define Nindex_CONSSW              10
X#endif
X#define Nindex_CURPROC             11
X#define Nindex_DINFO               12
X#if defined(M_UNIX)
X#define Nindex_DSTFLAG             13
X#endif
X#define Nindex_DUMPDEV             14
X#if defined(M_UNIX)
X#define Nindex_EMAP                15
X#endif
X#define Nindex_FFREELIST           16
X#define Nindex_FILE                17
X#define Nindex_FMODCNT             18
X#define Nindex_FMODSW              19
X#define Nindex_FREEMEM             20
X#define Nindex_FSINFO              21
X#define Nindex_FSTYPSW             22
X#if defined(M_UNIX)
X#define Nindex_HZ                  23
X#endif
X#define Nindex_IDLESERVER          24
X#define Nindex_IFREELIST           25
X#define Nindex_INODE               26
X#define Nindex_KPTBL               27
X#define Nindex_LBOLT               28
X#define Nindex_LINECNT             29
X#define Nindex_LINESW              30
X#define Nindex_MAXCLICK            31
X#define Nindex_MAXMEM              32
X#define Nindex_MINFO               33
X#define Nindex_MOUNT               34
X#define Nindex_MSGLISTCNT          35
X#define Nindex_NFSTYP              36
X#define Nindex_NPTALLOCED          37
X#define Nindex_NPTFREE             38
X#define Nindex_NSERVERS            39
X#define Nindex_NSWAP               40
X#if defined(M_UNIX)
X#define Nindex_NSYSENT             41
X#define Nindex_OLDPROC             42
X#define Nindex_OLD_CURPROC         43
X#endif
X#define Nindex_PANICSTR            44
X#define Nindex_PHYSMEM             45
X#define Nindex_PIPEDEV             46
X#define Nindex_PROC                47
X#define Nindex_RCINFO              48
X#define Nindex_ROOTDEV             49
X#define Nindex_RUNQ                50
X#define Nindex_SHLBINFO            51
X#define Nindex_SWAPDEV             52
X#define Nindex_SWPLO               53
X#define Nindex_SYSERR              54
X#define Nindex_SYSINFO             55
X#define Nindex_SYSSEGS             56
X#define Nindex_SYSWAIT             57
X#define Nindex_TIME                58
X#if defined(M_UNIX)
X#define Nindex_TIMEZONE            59
X#endif
X#define Nindex_TTHIWAT             60
X#define Nindex_TTLOWAT             61
X#define Nindex_TUNE                62
X#define Nindex_U                   63
X#if defined(M_UNIX)
X#define Nindex_USERTABLE           64
X#endif
X#define Nindex_V                   65
X#if defined(M_UNIX)
X#define Nindex_WIN_UBLK            66
X#endif
X#define Nindex_REGION              67
X#if defined(DPT_SIO)
X#define Nindex_SIO_TTY             68
X#endif
X#if defined(DPT_STREAMS)
X#define Nindex_STRST               69
X#define Nindex_RBSIZE              70
X#define Nindex_NMBLOCK             71
X#define Nindex_FLCKINFO            72
X#define Nindex_RACTIVE             73
X#endif
X#if defined(DPT_TABLE)
X#define Nindex_CALLOUT             74
X#endif
X#if defined(DPT_WD)
X#define Nindex_FLSTATS             75
X#define Nindex_WD1010STATS         76
X#endif
X
X#if defined(HAS_BOOTINFO)
X#define bootinfoaddr (nlsym[Nindex_BOOTINFO].n_value)
X#endif
X#define freememaddr (nlsym[Nindex_FREEMEM].n_value)
X#define lboltaddr (nlsym[Nindex_LBOLT].n_value)
X#define maxmemaddr (nlsym[Nindex_MAXMEM].n_value)
X#define minfoaddr (nlsym[Nindex_MINFO].n_value)
X#define nswapaddr (nlsym[Nindex_NSWAP].n_value)
X#define physmemaddr (nlsym[Nindex_PHYSMEM].n_value)
X#define procaddr (nlsym[Nindex_PROC].n_value)
X#define regionaddr (nlsym[Nindex_REGION].n_value)
X#define sysinfoaddr (nlsym[Nindex_SYSINFO].n_value)
X#define tuneaddr (nlsym[Nindex_TUNE].n_value)
X#define vaddr (nlsym[Nindex_V].n_value)
X#if defined(DPT_SIO)
X#define sio_ttyaddr (nlsym[Nindex_SIO_TTY].n_value)
X#endif /* DPT_SIO */
X#if defined(DPT_STREAMS)
X#define strstaddr (nlsym[Nindex_STRST].n_value)
X#define rbsizeaddr (nlsym[Nindex_RBSIZE].n_value)
X#define nmblockaddr (nlsym[Nindex_NMBLOCK].n_value)
X#endif /* DPT_STREAMS */
X#if defined(DPT_TABLE)
X#define flckinfoaddr (nlsym[Nindex_FLCKINFO].n_value)
X#define fileaddr (nlsym[Nindex_FILE].n_value)
X#define ifreelistaddr (nlsym[Nindex_IFREELIST].n_value)
X#define inodeaddr (nlsym[Nindex_INODE].n_value)
X#define ffreelistaddr (nlsym[Nindex_FFREELIST].n_value)
X#define ractiveaddr (nlsym[Nindex_RACTIVE].n_value)
X#define cfreecntaddr (nlsym[Nindex_CFREECNT].n_value)
X#define calloutaddr (nlsym[Nindex_CALLOUT].n_value)
X#define syserraddr (nlsym[Nindex_SYSERR].n_value)
X#endif /* DPT_TABLE */
X#if defined(DPT_WD)
X#define flstatsaddr (nlsym[Nindex_FLSTATS].n_value)
X#define wd1010statsaddr (nlsym[Nindex_WD1010STATS].n_value)
X#endif /* DPT_WD */
X
X#ifdef DEFINE_NLSYM
Xstruct nlist nlsym[] =
X{
X	{ "availrmem" },
X	{ "availsmem" },
X	{ "bdevcnt" },
X	{ "bdevsw" },
X#if defined(HAS_BOOTINFO)
X	{ "bootinfo" },
X#else
X	{ "dummy" },
X#endif
X	{ "cdevcnt" },
X	{ "cdevsw" },
X	{ "cfree" },
X	{ "cfreecnt" },
X	{ "cfreelist" },
X#if defined(M_UNIX)
X	{ "conssw" },
X#else
X	{ "dummy" },
X#endif
X	{ "curproc" },
X	{ "dinfo" },
X#if defined(M_UNIX)
X	{ "Dstflag" },
X#else
X	{ "dummy" },
X#endif
X	{ "dumpdev" },
X#if defined(M_UNIX)
X	{ "emap" },
X#else
X	{ "dummy" },
X#endif
X	{ "ffreelist" },
X	{ "file" },
X	{ "fmodcnt" },
X	{ "fmodsw" },
X	{ "freemem" },
X	{ "fsinfo" },
X	{ "fstypsw" },
X#if defined(M_UNIX)
X	{ "Hz" },
X#else
X	{ "dummy" },
X#endif
X	{ "idleserver" },
X	{ "ifreelist" },
X	{ "inode" },
X	{ "kptbl" },
X	{ "lbolt" },
X	{ "linecnt" },
X	{ "linesw" },
X	{ "maxclick" },
X	{ "maxmem" },
X	{ "minfo" },
X	{ "mount" },
X	{ "msglistcnt" },
X	{ "nfstyp" },
X	{ "nptalloced" },
X	{ "nptfree" },
X	{ "nservers" },
X	{ "nswap" },
X#if defined(M_UNIX)
X	{ "nsysent" },
X	{ "oldproc" },
X	{ "old_curproc" },
X#else
X	{ "dummy" },
X	{ "dummy" },
X	{ "dummy" },
X#endif
X	{ "panicstr" },
X	{ "physmem" },
X	{ "dummy" },
X	{ "proc" },
X	{ "rcinfo" },
X	{ "rootdev" },
X	{ "runq" },
X	{ "shlbinfo" },
X	{ "swapdev" },
X	{ "swplo" },
X	{ "syserr" },
X	{ "sysinfo" },
X	{ "syssegs" },
X	{ "syswait" },
X	{ "time" },
X#if defined(M_UNIX)
X	{ "Timezone" },
X#else
X	{ "dummy" },
X#endif
X	{ "tthiwat" },
X	{ "ttlowat" },
X	{ "tune" },
X	{ "u" },
X#if defined(M_UNIX)
X	{ "usertable" },
X#else
X	{ "dummy" },
X#endif
X	{ "v" },
X#if defined(M_UNIX)
X	{ "win_ublk" },
X#else
X	{ "dummy" },
X#endif
X	{ "region" },
X#if defined(DPT_SIO)
X#if defined(SIO_IS_FAS)
X	{ "fas_tty" },
X#else
X	{ "sio_tty" },
X#endif
X#else
X	{ "dummy" },
X#endif
X#if defined(DPT_STREAMS)
X	{ "strst" },
X	{ "rbsize" },
X	{ "nmblock" },
X#else
X	{ "dummy" },
X	{ "dummy" },
X	{ "dummy" },
X#endif
X#if defined(DPT_TABLE)
X	{ "flckinfo" },
X	{ "ractive" },
X	{ "callout" },
X#else
X	{ "dummy" },
X	{ "dummy" },
X	{ "dummy" },
X#endif
X#if defined(DPT_WD)
X	{ "flstats" },
X	{ "wd1010stats" },
X#else
X	{ "dummy" },
X	{ "dummy" },
X#endif
X	{ (char *)0 }
X};
X#else
Xextern struct nlist nlsym[];
X#endif
X
X#endif /* _nlsym_h */
X
X/* vi: set tabstop=4 shiftwidth=4: */
X/* end of nlsym.h */
SHAR_EOF
chmod 0644 nlsym.h ||
echo 'restore of nlsym.h failed'
Wc_c="`wc -c < 'nlsym.h'`"
test 8792 -eq "$Wc_c" ||
	echo 'nlsym.h: original size 8792, current size' "$Wc_c"
fi
# ============= patchlevel.h ==============
if test -f 'patchlevel.h' -a X"$1" != X"-c"; then
	echo 'x - skipping patchlevel.h (File already exists)'
else
echo 'x - extracting patchlevel.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'patchlevel.h' &&
X/* CHK=0x1C3F */
X#define PATCHLEVEL 0 /* scheme good for 9 patches */
SHAR_EOF
chmod 0644 patchlevel.h ||
echo 'restore of patchlevel.h failed'
Wc_c="`wc -c < 'patchlevel.h'`"
test 70 -eq "$Wc_c" ||
	echo 'patchlevel.h: original size 70, current size' "$Wc_c"
fi
# ============= ttynm.h ==============
if test -f 'ttynm.h' -a X"$1" != X"-c"; then
	echo 'x - skipping ttynm.h (File already exists)'
else
echo 'x - extracting ttynm.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ttynm.h' &&
X/* CHK=0xEBC2 */
X/*+-------------------------------------------------------------------------
X	ttynm.h - u386mon tty name file
X
XYou may have to edit this file if you do not use an SCO sio driver
X--------------------------------------------------------------------------*/
X/*+:EDITS:*/
X/*:07-15-1992-14:33-wht@n4hgf-2.60 release - u386mon+siotools merge */
X/*:04-07-1992-14:26-wht@n4hgf-creation */
X
X#ifndef _ttynm_h
X#define _ttynm_h
X
Xextern char *ttynm[];
X
X#if !defined(SIO_IS_FAS)
X
X#define SIO_NTTY 16	
X
X#ifdef DEFINE_TTYNM
Xchar *ttynm[SIO_NTTY] = {
X	"1a",
X	"1b",
X	"1c",
X	"1d",
X	"1e",
X	"1f",
X	"1g",
X	"1h",
X	"2a",
X	"2b",
X	"2c",
X	"2d",
X	"2e",
X	"2f",
X	"2g",
X	"2h",
X};
X#endif /* DEFINE_TTYNM */
X
X#else
X
X/*
X * This is the ordering of my FAS driver tty structures
X * Yours will probably be different
X */
X#define SIO_NTTY 18
X
X#ifdef DEFINE_TTYNM
Xchar *ttynm[SIO_NTTY] = {
X	"1a",
X	"2a",
X	"2b",
X	"2c",
X	"2d",
X	"2e",
X	"2f",
X	"2g",
X	"2h",
X	"1A",
X	"2A",
X	"2B",
X	"2C",
X	"2D",
X	"2E",
X	"2F",
X	"2G",
X	"2H",
X};
X#endif /* DEFINE_TTYNM */
X
X#endif /* SIO_IS_FAS */
X
X#endif /* _ttynm_h */
X
X/* vi: set tabstop=4 shiftwidth=4: */
X/* end of ttynm.h */
SHAR_EOF
chmod 0644 ttynm.h ||
echo 'restore of ttynm.h failed'
Wc_c="`wc -c < 'ttynm.h'`"
test 1129 -eq "$Wc_c" ||
	echo 'ttynm.h: original size 1129, current size' "$Wc_c"
fi
# ============= u386mon.h ==============
if test -f 'u386mon.h' -a X"$1" != X"-c"; then
	echo 'x - skipping u386mon.h (File already exists)'
else
echo 'x - extracting u386mon.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'u386mon.h' &&
X/* CHK=0x4829 */
X/*+-------------------------------------------------------------------------
X	u386mon.h - UNIX 386 system monitor definitions
X	wht@n4hgf.Mt-Park.GA.US
X--------------------------------------------------------------------------*/
X/*+:EDITS:*/
X/*:07-15-1992-14:34-wht@n4hgf-2.60 release - u386mon+siotools merge */
X/*:08-01-1991-23:35-wht@n4hgf-release 2.40 source control point */
X/*:08-10-1990-14:12-jmd@p1so/wht@n4hgf-2.20-add Tandem Integrity S2 */
X/*:08-07-1990-14:24-wht@n4hgf-nba@sysware.dk SVR31 updates */
X/*:08-02-1990-15:36-wht@n4hgf-2.12-old curses hacks+minor 3.2 formalizations */
X/*:07-28-1990-18:06-wht@n4hgf-2.10 release */
X/*:07-10-1990-19:06-root@n4hgf-redesign attributes/color pairs */
X/*:07-10-1990-18:33-root@n4hgf-move pio wait to medium alert */
X/*:07-03-1990-03:21-root@n4hgf-add cpBANWARN and renumber */
X/*:06-27-1990-01:57-wht@n4hgf-1.10-incorporate suggestions from alpha testers */
X/*:06-25-1990-04:14-wht@n4hgf-1.02-better error handling */
X/*:06-24-1990-20:53-wht@n4hgf-v1.01-add ISC support thanks to peter@radig.de */
X/*:06-21-1990-14:27-r@n4hgf-version x0.12 seems bug free */
X/*:06-20-1990-03:03-root@n4hgf-trick use_cp into making bright fgnd colors */
X/*:06-19-1990-21:35-wht-get ready for release */
X
X
X#ifndef _u386mon_h
X#define _u386mon_h
X
X#ifndef M_SYSV	/* for ISC */
X#define u_char unsigned char
X#define u_long unsigned long
X#endif
X
Xchar *getenv();
Xchar *strchr();
Xchar *strrchr();
X#ifdef __STDC__
Xvoid *malloc();
X#else
Xchar *malloc();
X#endif
X
X#define pW(pan) panel_window(pan)
X#define W WINDOW
X#define P PANEL
X
X/* color numbers for EGA/VGA */
X#ifdef COLOR_16_TERMINFO	/* wht 16-color fgnd/bgnd terminfo */
X#define cHIBIT	8
X#define cBLK	0
X#define cBLU	1
X#define cGRN	2
X#define cCYN	3
X#define cRED	4
X#define cMAG	5
X#define cBRN	6
X#define cWHT	7
X#define cGRY	(cBLK | cHIBIT)
X#define cLTB	(cBLU | cHIBIT)
X#define cLTG	(cGRN | cHIBIT)
X#define cLTC	(cCYN | cHIBIT)
X#define cLTR	(cRED | cHIBIT)
X#define cLTM	(cMAG | cHIBIT)
X#define cYEL	(cBRN | cHIBIT)
X#define cHIW	(cWHT | cHIBIT)
X#else
X#ifdef	COLOR_BLACK
X#define cBLK	COLOR_BLACK
X#define cBLU	COLOR_BLUE
X#define cGRN	COLOR_GREEN
X#define cCYN	COLOR_CYAN
X#define cRED	COLOR_RED
X#define cMAG	COLOR_MAGENTA
X#define cBRN	COLOR_YELLOW
X#define cWHT	COLOR_WHITE
X#define cGRY	COLOR_BLACK
X#define cLTB	COLOR_BLUE
X#define cLTG	COLOR_GREEN
X#define cLTC	COLOR_CYAN
X#define cLTR	COLOR_RED
X#define cLTM	COLOR_MAGENTA
X#define cYEL	COLOR_YELLOW
X#define cHIW	COLOR_WHITE
X#endif
X#endif
X
X#define sTL		0xDA
X#define sTR		0xBF
X#define sBL		0xC0
X#define sBR		0xD9
X#define sLT		0xC3	/* left hand T */
X#define sRT		0xB4	/* right hand T */
X#define sVR		0xB3	/* vertical rule */
X#define sHR		0xC4	/* horizontal rule */
X
X/* color pairs */
X#ifdef COLOR_16_TERMINFO	/* wht 16-color fgnd/bgnd terminfo */
X#define use_cp(win,cp) wattrset(win,COLOR_PAIR(cp))
X#else
X#ifdef COLOR_PAIR
X#define use_cp(win,cp) wattrset(win,\
X	(color_avail) ? color_attr[cp] : mono_attr[cp])
X#else
X#define use_cp(win,cp) wattrset(win,mono_attr[cp])
X#endif
X#endif
X
X/*
X * for SVR31
X */
X#ifndef getcury
X#define getcury(win)        ((win)->_cury)
X#endif
X#ifndef getcurx
X#define getcurx(win)        ((win)->_curx)
X#endif
X#ifndef getbegy
X#define getbegy(win)        ((win)->_begy)
X#endif
X#ifndef getbegx
X#define getbegx(win)        ((win)->_begx)
X#endif
X#ifndef getbegyx
X#define getbegyx(win,y,x)   ((y)=getbegy(win),(x)=getbegx(win))
X#endif
X#ifndef getmaxy
X#define getmaxy(win)        ((win)->_maxy)
X#endif
X#ifndef getmaxx
X#define getmaxx(win)        ((win)->_maxx)
X#endif
X#ifndef getmaxyx
X#define getmaxyx(win,y,x)   ((y)=getmaxy(win),(x)=getmaxx(win))
X#endif
X
X/* 
X * if color par numbers are changed, disputil.c
X * color_attr and mono_attr tables
X * must also be changed
X */
X
X#define cpINFO		1	/* information field */
X#define cpREVERSE	2	/* "reverse video" */
X#define cpBANWARN	3	/* banner warning */
X#define cpLOW		4	/* low/user/io */
X#define cpMED		5	/* medium/kernel/pio */
X#define cpHIGH		6	/* high/brk/swp */
X#define cpBANNER	7	/* banner */
X#define cpLIT		8	/* field literals */
Xextern int color_avail;
X#ifdef COLOR_PAIR
Xextern long color_attr[];
X#endif
Xextern long mono_attr[];
X
X#define MSG_TLY		(LINES - 2)
X#define CMD_TLY		(LINES - 1)
X#define LVMSG_Y		MSG_TLY
X#define LVMSG_X		0
X
X#define CPUSCALE_TLY		1
X#define CPUSCALE_SX			13
X#define CPUSCALE_WIDTH		50
X
X#define WAITSCALE_TLY		5
X#define WAITSCALE_SX		13
X#define WAITSCALE_WIDTH		50
X
X/* Sysinfo/Minfo per second area */
X#define PER_SEC_TLY			9
X#define PER_SEC1_TLX		0
X#define PER_SEC2_TLX		18
X#define PER_SEC3_TLX		35
X#define PER_SEC4_TLX		51
X#define PER_SEC5_TLX		66
X
X/* extra info area */
X#define EXTRA_TLY			26
X#define EXTRA1_TLX			0
X#define EXTRA2_TLX			18
X#define EXTRA3_TLX			43
X#define EXTRA4_TLX			62
X
X#include "lint_args.h"
X
X#endif /* _u386mon_h */
X
X/* vi: set tabstop=4 shiftwidth=4: */
X/* end of u386mon.h */
SHAR_EOF
chmod 0644 u386mon.h ||
echo 'restore of u386mon.h failed'
Wc_c="`wc -c < 'u386mon.h'`"
test 4824 -eq "$Wc_c" ||
	echo 'u386mon.h: original size 4824, current size' "$Wc_c"
fi
# ============= renice/Makefile ==============
if test ! -d 'renice'; then
    echo 'x - creating directory renice'
    mkdir 'renice'
fi
if test -f 'renice/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping renice/Makefile (File already exists)'
else
echo 'x - extracting renice/Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'renice/Makefile' &&
X#  CHK=0x72AC
X#+-------------------------------------------------------------------
X#  Makefile for renice for SCO UNIX V/386
X#  ...!emory!n4hgf!wht
X#--------------------------------------------------------------------
X#+:EDITS:*/
X#:07-15-1992-14:32-wht@n4hgf-2.60 release - u386mon+siotools merge
X#:06-25-1990-04:14-wht@n4hgf-1.03-better error handling
X#:06-21-1990-14:27-r@n4hgf-version x0.12 seems bug free
X#:06-19-1990-21:37-wht@n4hgf-get ready for 0.08 release
X
X#------------> CFLAGS 
XCFLAGS = -c -Octl -DLINT_ARGS
X#CFLAGS = -c -O
X
X#------------> BINDIR
XBINDIR = /usr/local/bin
X
X#LDFLAGS = -s
X
X
X#handle Sys V make "feature" of using SHELL
XSHELL = /bin/sh
X
X#FCRC = fcrc -u $*.c ;
X.c.o:;	$(FCRC) $(CC) $(CFLAGS) $*.c 
X
XSRC = \
X	renice.c
X
XRENICE_OBJ =\
X	renice.o\
X	../libnlsym.o\
X	libkmem-w.o
X
Xall: renice
X
X#must run as root
Xinstall: all
X	mv renice $(BINDIR)
X	chmod 4711 $(BINDIR)/renice
X	chown root $(BINDIR)/renice
X	@echo ' ';echo 'csh users rehash before executing'
X
Xrenice: $(RENICE_OBJ)
X	$(CC) $(LDFLAGS) -o $@ $(RENICE_OBJ) $(LIB)
X
Xlibkmem-w.o: ../libkmem.c
X	cc $(CFLAGS) -I .. -DKWRITE_NEEDED ../libkmem.c; mv libkmem.o libkmem-w.o
X
X../libnlsym.o: ../libnlsym.c
X	cd ..;make libnlsym.o
X
Xclean:
X	rm -f renice.o libkmem-w.o core 
X
Xclobber: clean
X	rm -f renice
X
SHAR_EOF
chmod 0644 renice/Makefile ||
echo 'restore of renice/Makefile failed'
Wc_c="`wc -c < 'renice/Makefile'`"
test 1267 -eq "$Wc_c" ||
	echo 'renice/Makefile: original size 1267, current size' "$Wc_c"
fi
# ============= renice/renice.c ==============
if test -f 'renice/renice.c' -a X"$1" != X"-c"; then
	echo 'x - skipping renice/renice.c (File already exists)'
else
echo 'x - extracting renice/renice.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'renice/renice.c' &&
X/* CHK=0x71B7 */
X/*+-------------------------------------------------------------------------
X	renice.c - UNIX 386 renice
X
X * This program was written by me, Mike "Ford" Ditto, and
X * I hereby release it into the public domain in the interest
X * of promoting the development of free, quality software
X * for the hackers and users of the world.
X *
X * Feel free to use, copy, modify, improve, and redistribute
X * this program, but keep in mind the spirit of this
X * contribution; always provide source, and always allow
X * free redistribution (shareware is fine with me).  If
X * you use a significant part of this code in a program of
X * yours, I would appreciate being given the appropriate
X * amount of credit.
X *				-=] Ford [=-
X *
X--------------------------------------------------------------------------*/
X/*+:EDITS:*/
X/*:07-15-1992-14:32-wht@n4hgf-2.60 release - u386mon+siotools merge */
X/*:06-26-1990-15:09-wht@n4hgf-adapt Ford's work to UNIX 386 */
X
X#include <stdio.h>
X#include <errno.h>
X#include <sys/types.h>
X#undef NGROUPS_MAX
X#undef NULL
X#include <sys/param.h>
X#include <sys/immu.h>
X#include <sys/region.h>
X#include <sys/proc.h>
X#include <sys/var.h>
X#include <nlist.h>
X#include "../nlsym.h"
X#include "../libkmem.h"
X#include "../libnlsym.h"
X
Xstruct var v;
Xstruct proc tproc;
Xint myuid;
Xchar *progname;
Xchar s128[128];
Xint myreadcnt = 0;			/* see libkmem.c, libmem.c, libswap.c */
Xdaddr_t myreadlen = 0;
X
X/*+-------------------------------------------------------------------------
X	leave_text(text,exit_code)
XIf exit_code == 255, do perror
X--------------------------------------------------------------------------*/
Xvoid
Xleave_text(text,exit_code)
Xchar *text;
Xint exit_code;
X{
X	if(exit_code == 255)
X		perror(text);
X	else
X	{
X		fputs(text,stderr);
X		fputs("\n",stderr);
X	}
X	exit(exit_code);
X}	/* end of leave_text */
X
X/*+-------------------------------------------------------------------------
X	renice(pid,value,relative) - change nice of process `pid'
Xbased on 'value' and 'relative'
X--------------------------------------------------------------------------*/
Xrenice(pid,value,relative)
Xint pid;
Xint value;
Xint relative;
X{
X	register i;
X	int tmpnice;
X
X	for(i = 0; i < v.v_proc; i++)
X	{
X		kread((caddr_t)&tproc,(daddr_t)((struct proc *)procaddr + i),
X		    sizeof(struct proc));
X		if(tproc.p_pid == pid)
X		{
X#ifdef DEBUG
X			fprintf(stderr,"Found it!  proc[%d], p_uid is %d\n",
X			    i,tproc.p_uid);
X
X			fprintf(stderr,"Old p_nice was %d\n",tproc.p_nice);
X#endif /* DEBUG */
X
X			tmpnice = tproc.p_nice;
X
X			if(relative)
X				tmpnice += value;
X			else
X				tmpnice = value;
X
X			if(tmpnice >= 40)
X				tmpnice = 40;
X			if(tmpnice < 0)
X				tmpnice = 0;
X
X#ifdef DEBUG
X			fprintf(stderr,"New p_nice is %d\n",tmpnice);
X#endif /* DEBUG */
X
X			if( 
X#ifdef WHT
X				(myuid && (myuid != 201))
X#else
X				myuid
X#endif
X			 	&& ((myuid != tproc.p_uid) || (tmpnice < tproc.p_nice)))
X			{
X				errno = EACCES;
X				sprintf(s128,"%s: can't renice process %d",progname,pid);
X				perror(s128);
X				return 1;
X			}
X
X			tproc.p_nice = tmpnice;
X
X			kwrite((daddr_t)&((struct proc *)procaddr)[i]
X			    + ( ((caddr_t)&tproc.p_nice) - (caddr_t)&tproc ),
X			    (caddr_t)&tproc.p_nice,sizeof(tproc.p_nice));
X			return(0);
X		}
X	}
X	fprintf(stderr,"%s: process %d not found.\n",progname,pid);
X
X	return(1);
X}	/* end of renice */
X
X/*+-------------------------------------------------------------------------
X	usage()
X--------------------------------------------------------------------------*/
Xvoid
Xusage()
X{
X    fprintf(stderr,"usage: %s [{+-}inc] [=prio] pid ...\n",progname);
X    exit(-1);
X}	/* end of usage */
X
X/*+-------------------------------------------------------------------------
X	main(argc,argv)
X--------------------------------------------------------------------------*/
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X{
X	int status=0;
X	int pid;
X	int relative = 1;
X	int value = 0;
X
X	progname = *argv;
X	if(argc < 2)
X		usage();
X
X	myuid = getuid();
X	nlsym_read();
X	kinit(1);
X	kread((caddr_t)&v,vaddr,sizeof(v));
X
X	while(++argv,--argc)
X	{
X		switch(**argv)
X		{
X		case '-':
X			if(sscanf(*argv+1,"%d",&value) != 1)
X				usage();
X			relative = 1;
X			break;
X		case '+':
X			if(sscanf(*argv+1,"%d",&value) != 1)
X				usage();
X			value = -value;
X			relative = 1;
X			break;
X		case '=':
X			if(sscanf(*argv+1,"%d",&value) != 1)
X				usage();
X			relative = 0;
X			break;
X		default:
X			if(sscanf(*argv,"%d",&pid) != 1)
X				usage();
X			status += renice(pid,value,relative);
X		}
X	}
X
X	exit(status);
X}	/* end of main */
X
X/* vi: set tabstop=4 shiftwidth=4: */
X/* end of renice.c */
SHAR_EOF
chmod 0644 renice/renice.c ||
echo 'restore of renice/renice.c failed'
Wc_c="`wc -c < 'renice/renice.c'`"
test 4536 -eq "$Wc_c" ||
	echo 'renice/renice.c: original size 4536, current size' "$Wc_c"
fi
# ============= panel/README ==============
if test ! -d 'panel'; then
    echo 'x - creating directory panel'
    mkdir 'panel'
fi
if test -f 'panel/README' -a X"$1" != X"-c"; then
	echo 'x - skipping panel/README (File already exists)'
else
echo 'x - extracting panel/README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'panel/README' &&
XLIBPANEL 1.2 README - last revised Wed Jul 25 01:07:33 EDT 1990
X
XThis is a public domain implementation of the S5R3 terminfo
Xcurses panels layer.  It was written primarily to assist in
Xporting u386mon 2.0 to systems lacking panels support.  It meets
Xthose needs and may be useful in other applications.  u386mon
X2.10 and beyond use the package.
X
XFUNCTIONALITY
X-------------
X
XPanels are terminfo curses(3) windows with the added feature of depth.
XPanel functions allow the use of stacked windows and ensure the proper
Xportions of each window and the curses stdscr window are hidden or
Xdisplayed when panels are added, moved, modified or removed.  The set
Xof currently visible panels is the stack of panels.  Stdscr beneath
Xall panels, and is not considered part of the stack.
X
XA window is associated with every panel.  The panel routines enable
Xyou to create, move, hides, and show panels, as well as position a
Xpanel at an appropriate position in the stack.
X
XPanel routines are a functional layer added to terminfo curses(3),
Xmake only high-level curses calls, and work anywhere terminfo curses
Xdoes.
X
XCOMPATIBILITY
X-------------
X
XReasonable care has been taken to ensure compatibility with the native
Xpanel facility introducted with S5R3.2.  The PANEL data structures are
Xmerely similar.  The programmer is cautioned not to directly use
X'PANEL' fields.
X
XThe functions show_panel() and top_panel() are identical in thes
Ximplementation, and work equally well with displayed or hidden panels.
XIn the native implementation, show_panel() is intended for making a
Xhidden panel visible (at the top of the stack) and top_panel() is
Xintended for making an already-visible panel move to the top of the
Xstack.  You are cautioned to use the correct function to ensure
Xcompatibility with native panel libraries.
X
XUSE
X---
X
XTo make this panels implementation work for you, install
Xpanel.h in /usr/include or modify each of your panel-using
Xsources in a fashion similar to:
X
Xold:
X#include <curses.h>
X#include <panel.h>
X
Xnew:
X#include <curses.h>
X#ifdef NATIVE_PANELS
X#include <panel.h>
X#else
X#include "panel.h"
X#endif
X
XInclude libpanel.o in your link line and panel away.
X
XCOMPILE TIME SWITCHES
X---------------------
X__STDC__ is used to detect nouveau compilers.  Depending on who/where
Xyou are, on what day of the week, The Great Programmer help you.
XI only use it to satisfy lint that malloc is a good function to use.
X
XLINT_ARGS causes a Microsoft 5.1 flavor of function prototypes to
Xbe used.
X
XNATIVE_PANELS is detected by panel.h.  If NATIVE_PANELS *is* defined,
Xthen an error is emited to keep you from using the wrong panel.h.
X
XTESTING
X-------
X
XA rudimentary test program, PTEST, is supplied.  It requires
Xthe nap() system call.  If You do not have nap, add -DNONAP
Xto your CFLAGS line.
X
XCopy libpanel.[ch] into this directory to make the test executable.
X
XThe manual page speaks highly of libpanel, but I really have no
Xidea about its usability other than with u386mon.
X
XComments are appreciated, especially bug fixes and information
Xhelping to port the module to another system.
X
XWarren Tucker N4HGF
X{gatech,emory}!n4hgf!wht -or- wht@n4hgf.Mt-Park.GA.US
SHAR_EOF
chmod 0644 panel/README ||
echo 'restore of panel/README failed'
Wc_c="`wc -c < 'panel/README'`"
test 3147 -eq "$Wc_c" ||
	echo 'panel/README: original size 3147, current size' "$Wc_c"
fi
# ============= panel/panel.3 ==============
if test -f 'panel/panel.3' -a X"$1" != X"-c"; then
	echo 'x - skipping panel/panel.3 (File already exists)'
else
echo 'x - extracting panel/panel.3 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'panel/panel.3' &&
X.\" @(#)panel.3	1.1 7/23/90
X.TH PANEL 3 "23 July 1990" "wht@n4hgf"
X.SH NAME
Xpanel - surrogate PANEL library routines
X.SH SYNTAX
X.B "include "panel.h"
X
X.B "cc [flags] sourcefiles libpanel.[co] -lcurses -[otherlibs]
X
X.B "PANEL *new_panel(win);"
X.br
XWINDOW *win;
X
X.B "int bottom_panel(pan);"
X.br
XPANEL *pan;
X
X.B "int top_panel(pan);"
X.br
XPANEL *pan;
X
X.B "int show_panel(pan);"
X.br
XPANEL *pan;
X
X.B "void update_panels();"
X
X.B "int hide_panel(pan);"
X.br
XPANEL *pan;
X
X.B "WINDOW *panel_window(pan);"
X.br
XPANEL *pan;
X
X.B "int replace_panel(pan,window);"
X.br
XPANEL *pan;
X.br
XWINDOW *window;
X
X.B "int move_panel(pan,starty,startx);"
X.br
XPANEL *pan;
X.br
Xint starty;
X.br
Xint startx;
X
X.B "int panel_hidden(pan);"
X.br
XPANEL *pan;
X
X.B "PANEL *panel_above(pan);"
X.br
XPANEL *pan;
X
X.B "PANEL *panel_below(pan);"
X.br
XPANEL *pan;
X
X.B "int set_panel_userptr(pan,ptr);"
X.br
XPANEL *pan;
X.br
Xchar *ptr;
X
X.B "char *panel_userptr(pan);"
X.br
XPANEL *pan;
X
X.B "int del_panel(pan);"
X.br
XPANEL *pan;
X
X.SH DESCRIPTION
XPanels are terminfo curses(3) windows with the added feature of
Xdepth.  Panel functions allow the use of stacked windows and
Xensure the proper portions of each window and the curses stdscr
Xwindow are hidden or displayed when panels are added, moved,
Xmodified or removed.  The set of currently visible panels is the
Xstack of panels.  Stdscr beneath all panels, and is not
Xconsidered part of the stack.
X
XA window is associated with every panel.  The panel routines
Xenable you to create, move, hides, and show panels, as well as
Xposition a panel at an appropriate position in the stack.
X
XPanel routines are a functional layer added to terminfo curses(3), make
Xonly high-level curses calls, and work anywhere terminfo curses does.
X
X.SH FUNCTIONS
X.B "new_panel(win)"
Xallocates a 'PANEL',
Xassovciates it with win,
Xplaces the panel on the top of the stack (causes it to be dispalyed
Xabove any other panel) and
Xreturns a pointer to the new panel.
X
X.B "void update_panels()"
Xrefreshes the virtual screen to reflect the relations between the
Xpanels in the stack, but does not call doupdate() to refresh the
Xphysical screen.  Use this function and not wrefresh or wnoutrefresh.
Xupdate_panels() may be called more than once before a call to
Xdoupdate(), but doupdate() is the function responsible for
Xupdating the physical screen.
X.br
Xe.g.,
X.br
Xupdate_panels();   /* panel(3) call */
X.br
Xdoupdate();        /* curses(3) call */
X
X.B "del_panel(pan)"
Xremoves pan from the stack,
Xdeletes the 'PANEL', but not its associated window.
X
X.B "hide_panel(pan)"
Xremoves the panel from the panel stack and thus hides it
Xfrom view.  The 'PANEL' is not lost, merely removed
Xfrom the stack.
X
X.B "show_panel(pan)"
Xmakes a hidden panel visible by placing it on top of
Xthe panels in the panel stack.
XSee COMPATIBILITY below.
X
X.B "top_panel(pan)"
Xputs the given visible panel on top of all panels in the stack.
XSee COMPATIBILITY below.
X
X.B "bottom_panel(pan)"
Xputs panel at the bottom of all panels.
X
X.B "move_panel(pan,starty,startx)"
Xmoves the given panel window so that
Xits upper-left corner is at starty, startx.  
XIt does not change the position of the panel in the stack.
XBe sure to use this function, not mvwin(), to move a panel window.
X
X.B "replace_panel(pan,window)"
Xreplaces the current window of panel with window.
XIt does not change the position of the panel in the stack.
X
X.B "panel_above(pan)"
Xreturns a pointer to the panel above pan.  If
Xthe panel argument is (PANEL *)0, it returns a pointer to the
Xbottom panel in the stack.
X
X.B "panel_below(pan)"
Xreturns a pointer to the panel just below pan.
XIf the panel argument is (PANEL *)0,
Xit returns a pointer to the top panel in the stack.
X
X.B "set_panel_userptr(pan,ptr)"
Xsets the panel's user pointer.
X
X.B "panel_userptr(pan)"
Xreturns the user pointer for a given panel.
X
X.B "panel_window(pan)"
Xreturns a pointer to the window of panel.
X
X.SH DIAGNOSTICS
XEach routine that returns a pointer returns NULL if an error
Xoccurs.  Each routine that returns an int value returns OK if it
Xexecutes successfully and ERR if not.
X
X.SH COMPATIBILITY
XReasonable care has been taken to ensure compatibility with
Xthe native panel facility introducted with S5R3.2.  The PANEL
Xdata structures are merely  similar.  The programmer
Xis cautioned not to directly use 'PANEL' fields.
X
XThe functions show_panel() and top_panel() are identical
Xin thes implementation, and work equally well with
Xdisplayed or hidden panels.
XIn the native implementation,
Xshow_panel() is intended for making a hidden panel visible
X(at the top of the stack) and top_panel() is intended for
Xmaking an already-visible panel move to the top of the stack.
XYou are cautioned to use the correct function to ensure
Xcompatibility with native panel libraries.
X
X.SH FILES
Xpanel.h
X.br
Xlibpanel.c
X
X.SH "SEE ALSO"
Xcurses(3)
X
X.SH "AUTHOR"
Xwht@n4hgf.Mt-Park.GA.US ({emory,gatech}!n4hgf!wht), primarily
Xto assist in porting u386mon to systems without a native
Xpanels library.
SHAR_EOF
chmod 0644 panel/panel.3 ||
echo 'restore of panel/panel.3 failed'
Wc_c="`wc -c < 'panel/panel.3'`"
test 4935 -eq "$Wc_c" ||
	echo 'panel/panel.3: original size 4935, current size' "$Wc_c"
fi
# ============= panel/ptest.c ==============
if test -f 'panel/ptest.c' -a X"$1" != X"-c"; then
	echo 'x - skipping panel/ptest.c (File already exists)'
else
echo 'x - extracting panel/ptest.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'panel/ptest.c' &&
X/* CHK=0x9F7C */
X/*+-------------------------------------------------------------------------
X	ptest.c
X--------------------------------------------------------------------------*/
X/*+:EDITS:*/
X/*:07-15-1992-14:32-wht@n4hgf-2.60 release - u386mon+siotools merge */
X/*:07-24-1990-23:20-wht@n4hgf-move debug code to libpanel.c */
X/*:07-20-1990-18:28-wht-creation */
X
X#define M_TERMINFO
X#include <curses.h>
X#include "libpanel.h"
X
XPANEL *p1;
XPANEL *p2;
XPANEL *p3;
XPANEL *p4;
XPANEL *p5;
XWINDOW *w1;
XWINDOW *w2;
XWINDOW *w3;
XWINDOW *w4;
XWINDOW *w5;
X
Xlong nap_msec = 500L;
X
Xchar *mod[] = 
X{
X	"test ",
X	"TEST ",
X	"(**) ",
X	"*()* ",
X	"<--> ",
X	"LAST "
X};
X
X/*+-------------------------------------------------------------------------
X	wait_a_while(msec)
X--------------------------------------------------------------------------*/
Xvoid
Xwait_a_while(msec)
Xlong msec;
X{
X#ifdef NONAP
X	if(nap_msec == 1)
X		getchar();
X	else if(msec > 1000L)
X		sleep((int)msec/1000L);
X	else
X		sleep(1);
X#else
X	if(nap_msec == 1)
X		getchar();
X	else
X		nap(nap_msec);
X#endif
X}	/* end of wait_a_while */
X
X/*+-------------------------------------------------------------------------
X	saywhat(text)
X--------------------------------------------------------------------------*/
Xvoid
Xsaywhat(text)
Xchar *text;
X{
Xint y,x;
X
X#ifdef PANEL_DEBUG
X	if(!dfp)
X	{
X		dfp = fopen("p.log","w");
X		fputs("-------\n",dfp);
X	}
X	fprintf(dfp,"\n--> %s\n",text);
X#endif
X
X	wmove(stdscr,LINES - 1,0);
X	wprintw(stdscr,"%-20.20s",text);
X
X}	/* end of saywhat */
X
X/*+-------------------------------------------------------------------------
X	mkpanel(rows,cols,tly,tlx) - alloc a win and panel and associate them
X--------------------------------------------------------------------------*/
XPANEL *
Xmkpanel(rows,cols,tly,tlx)
Xint rows;
Xint cols;
Xint tly;
Xint tlx;
X{
XWINDOW *win = newwin(rows,cols,tly,tlx);
XPANEL *pan;
X
X	if(!win)
X		return((PANEL *)0);
X	if(pan = new_panel(win))
X		return(pan);
X	delwin(win);
X	return((PANEL *)0);
X}	/* end of mkpanel */
X
X/*+-------------------------------------------------------------------------
X	rmpanel(pan)
X--------------------------------------------------------------------------*/
Xvoid
Xrmpanel(pan)
XPANEL *pan;
X{
XWINDOW *win = pan->win;
X	del_panel(pan);
X	delwin(win);
X}	/* end of rmpanel */
X
X/*+-------------------------------------------------------------------------
X	pflush()
X--------------------------------------------------------------------------*/
Xvoid
Xpflush()
X{
X	update_panels();
X	doupdate();
X}	/* end of pflush */
X
X/*+-------------------------------------------------------------------------
X	fill_panel(win)
X--------------------------------------------------------------------------*/
Xfill_panel(pan)
XPANEL *pan;
X{
XWINDOW *win = pan->win;
Xchar num = *(pan->user + 1);
Xint y,x;
X
X	box(win,'|','-');
X	wmove(win,1,1);
X	wprintw(win,"-pan%c-",num);
X	for(y = 2; y < getmaxy(win) - 1; y++)
X	{
X		for(x = 1; x < getmaxx(win) - 1; x++)
X		{
X			wmove(win,y,x);
X			waddch(win,num);
X		}
X	}
X}	/* end of fill_panel */
X
X/*+-------------------------------------------------------------------------
X	main(argc,argv)
X--------------------------------------------------------------------------*/
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X{
Xint itmp;
Xregister y,x;
Xlong atol();
X
X	if((argc > 1) && atol(argv[1]))
X		nap_msec = atol(argv[1]);
X
X	initscr();
X
X	for(y = 0; y < LINES - 1; y++)
X	{
X		for(x = 0; x < COLS; x++)
X			wprintw(stdscr,"%d",(y + x) % 10);
X	}
X	for(y = 0; y < 5; y++)
X	{
X		p1 = mkpanel(10,10,0,0);
X		w1 = panel_window(p1);
X		set_panel_userptr(p1,"p1");
X
X		p2 = mkpanel(14,14,5,5);
X		w2 = panel_window(p2);
X		set_panel_userptr(p2,"p2");
X
X		p3 = mkpanel(6,8,12,12);
X		w3 = panel_window(p3);
X		set_panel_userptr(p3,"p3");
X
X		p4 = mkpanel(10,10,10,30);
X		w4 = panel_window(p4);
X		set_panel_userptr(p4,"p4");
X
X		p5 = mkpanel(10,10,13,37);
X		w5 = panel_window(p5);
X		set_panel_userptr(p5,"p5");
X
X		fill_panel(p1);
X		fill_panel(p2);
X		fill_panel(p3);
X		fill_panel(p4);
X		fill_panel(p5);
X		hide_panel(p4);
X		hide_panel(p5);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("h3 s1 s2 s4 s5;");
X		move_panel(p1,0,0);
X		hide_panel(p3);
X		show_panel(p1);
X		show_panel(p2);
X		show_panel(p4);
X		show_panel(p5);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("s1;");
X		show_panel(p1);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("s2;");
X		show_panel(p2);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("m2;");
X		move_panel(p2,10,10);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("s3;");
X		show_panel(p3);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("m3;");
X		move_panel(p3,5,5);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("b3;");
X		bottom_panel(p3);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("s4;");
X		show_panel(p4);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("s5;");
X		show_panel(p5);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("t3;");
X		top_panel(p3);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("t1;");
X		top_panel(p1);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("t2;");
X		top_panel(p2);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("t3;");
X		top_panel(p3);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("t4;");
X		top_panel(p4);
X		pflush();
X		wait_a_while(nap_msec);
X
X		for(itmp = 0; itmp < 6; itmp++)
X		{
X			saywhat("m4;");
X			wmove(w4,3,1);
X			waddstr(w4,mod[itmp]);
X			move_panel(p4,4,itmp*10);
X			wmove(w5,4,1);
X			waddstr(w5,mod[itmp]);
X			pflush();
X			wait_a_while(nap_msec);
X			saywhat("m5;");
X			wmove(w4,4,1);
X			waddstr(w4,mod[itmp]);
X			move_panel(p5,7,(itmp*10) + 6);
X			wmove(w5,3,1);
X			waddstr(w5,mod[itmp]);
X			pflush();
X			wait_a_while(nap_msec);
X		}
X
X		saywhat("m4;");
X		move_panel(p4,4,itmp*10);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("t5;");
X		top_panel(p5);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("t2;");
X		top_panel(p2);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("t1;");
X		top_panel(p1);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("d2;");
X		rmpanel(p2);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("h3;");
X		hide_panel(p3);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("d1;");
X		rmpanel(p1);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("d4; ");
X		rmpanel(p4);
X		pflush();
X		wait_a_while(nap_msec);
X
X		saywhat("d5; ");
X		rmpanel(p5);
X		pflush();
X		wait_a_while(nap_msec);
X		if(nap_msec == 1)
X			break;
X		nap_msec = 100L;
X	}
X	endwin();
X	exit(0);
X}	/* end of main */
X
X/* vi: set tabstop=4 shiftwidth=4: */
X/* end of ptest.c */
SHAR_EOF
chmod 0644 panel/ptest.c ||
echo 'restore of panel/ptest.c failed'
Wc_c="`wc -c < 'panel/ptest.c'`"
test 6409 -eq "$Wc_c" ||
	echo 'panel/ptest.c: original size 6409, current size' "$Wc_c"
fi
# ============= panel/Makefile ==============
if test -f 'panel/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping panel/Makefile (File already exists)'
else
echo 'x - extracting panel/Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'panel/Makefile' &&
X#  CHK=0xFD12
XCFLAGS = -O
X#CFLAGS = -O -DLINT_ARGS
X
XSHARFLS = \
X	README\
X	Makefile\
X	panel.3\
X	config.h\
X	libpanel.h\
X	libpanel.c
X
XOBJ = ptest.o libpanel.o
X
Xptest: $(OBJ)
X	cc -o $@ $(OBJ) -lcurses -lx
X
X$(OBJ): Makefile libpanel.h
X
Xshar:
X	shar -n libpanel -a $(SHARFLS) > libpanel.sh
X
Xclean:
X	rm -rf $(OBJ) core a.out cscope.out tags
X
Xclobber: clean
X	rm -rf ptest
SHAR_EOF
chmod 0644 panel/Makefile ||
echo 'restore of panel/Makefile failed'
Wc_c="`wc -c < 'panel/Makefile'`"
test 363 -eq "$Wc_c" ||
	echo 'panel/Makefile: original size 363, current size' "$Wc_c"
fi
# ============= siotools/Makefile ==============
if test ! -d 'siotools'; then
    echo 'x - creating directory siotools'
    mkdir 'siotools'
fi
if test -f 'siotools/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping siotools/Makefile (File already exists)'
else
echo 'x - extracting siotools/Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'siotools/Makefile' &&
X#  CHK=0x041A
X#-----------------------------------
X# Makefile for uusnap & siomon
X# wht@n4hgf.Mt-Park.GA.US
X#-----------------------------------
X#+:EDITS:*/
X#:07-15-1992-14:33-wht@n4hgf-2.60 release - u386mon+siotools merge
X#:06-22-1992-13:25-wht@n4hgf-revisit for 3.2v4
X#:12-04-1989-18:28-wht-release to comp.sources.misc
X#:11-23-1989-20:46-wht-creation
X
XSHELL = /bin/sh
X
X# CFLAGS2 options:
X# -DSTANDALONE_NLIST: to compile to not use u386mon's nlsym
X#               this makes for long druding nlists
X# -DSIO_IS_FAS: is how I get the stuff to work with my FAS configuration
X#               study the code, especially ../ttynm.h
XCFLAGS2 = -DSIO_IS_FAS
X
X# SCO CC
XCC=cc
XCFLAGS = \
X	-O \
X	$(CFLAGS2)
X
X# SCO UNIX 3.2->3.2v4 gcc
X#CC = gcc
X#CFLAGS = \
X#	$(CFLAGS2) \
X#	-traditional -O \
X#	-g \
X#	-fstrength-reduce -fpcc-struct-return -fwritable-strings \
X#	-finline-functions -fforce-mem -fforce-addr \
X#	-W -Wunused -Wpointer-arith -Wcast-qual -Wshadow -Wcomment -Wswitch\
X#	-D_NO_PROTOTYPE -D_SVID -D_KR \
X#	-DM_BITFIELDS -DM_COFF -DM_I386 -DM_I86 -DM_I86SM \
X#	-DM_INTERNAT -DM_SDATA -DM_STEXT -DM_SYS3 -DM_SYS5 \
X#	-DM_SYSIII -DM_SYSV -DM_UNIX -DM_WORDSWAP -DM_XENIX -Dunix -Di386\
X#	-DM_TERMINFO
X
X# get shared library stuff first, then opendir/etc from libc.a not libx.a
X# then get nap/rdchk from libx.a
XLIB=-ltinfo -lc_s -lc -lx
X
X# local bin directory (for make install)
XLBIN=/usr/local/bin
X
XSIOMON_OBJ = \
X	siomon.o\
X	kmemsio.o \
X	../libnlsym.o \
X	utoa.o \
X	wingets.o \
X	wintty.o
X
XUUSNAP_OBJ = \
X	uusnap.o\
X	kmemsio.o \
X	../libnlsym.o \
X	utoa.o \
X	wingets.o \
X	wintty.o
X
Xall: uusnap siomon
X
Xuusnap: $(UUSNAP_OBJ)
X	$(CC) $(CFLAGS) $(UUSNAP_OBJ) -o $@ $(LIB)
X
Xsiomon: $(SIOMON_OBJ)
X	$(CC) $(CFLAGS) $(SIOMON_OBJ) -o $@ $(LIB)
X
X../libnlsym.o:
X	cd ..;make libnlsym.o
X
Xinstall: all
X	cp siomon $(LBIN)
X	-if [ -x /usr/bin/mcs ]; then /usr/bin/mcs -d $(LBIN)/siomon; fi
X	strip $(LBIN)/siomon
X	chown root $(LBIN)/siomon
X	chgrp uucp $(LBIN)/siomon
X	chmod 4111 $(LBIN)/siomon
X	cp uusnap $(LBIN)
X	-if [ -x /usr/bin/mcs ]; then /usr/bin/mcs -d $(LBIN)/uusnap; fi
X	strip $(LBIN)/uusnap
X	chown root $(LBIN)/uusnap
X	chgrp uucp $(LBIN)/uusnap
X	chmod 4111 $(LBIN)/uusnap
X
XSHARFLAGS = -F -n siotools -a -s wht@n4hgf.Mt-Park.GA.US -l 50 -o siotools
Xshar:
X	shar $(SHARFLAGS) \
X	README \
X	Makefile \
X	kmemsio.c \
X	kmemsio.h \
X	siomon.c \
X	utoa.c \
X	utoa.h \
X	uusnap.c \
X	wingets.c \
X	wintio.c \
X	wintio.h \
X	wintty.c \
X	wintty.h 
X
Xneat:
X	rm -f *\# *~ *.orig *.rej *.out *.log core ,* cscope.out tags
X
Xclean: neat
X	rm -f *.o *.a 
X
Xclobber: clean
X	rm -f uusnap siomon
SHAR_EOF
chmod 0644 siotools/Makefile ||
echo 'restore of siotools/Makefile failed'
Wc_c="`wc -c < 'siotools/Makefile'`"
test 2546 -eq "$Wc_c" ||
	echo 'siotools/Makefile: original size 2546, current size' "$Wc_c"
fi
true || echo 'restore of siotools/README failed'
echo End of part 7, continue with part 8
exit 0

exit 0 # Just in case...
