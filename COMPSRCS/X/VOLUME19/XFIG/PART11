Newsgroups: comp.sources.x
From: envbvs@epb9.lbl.gov (Brian V. Smith)
Subject: v19i123:  xfig - Draw amd manipulate objects in an X-Window, Part11/27
Message-ID: <1993May21.021437.5894@sparky.imd.sterling.com>
X-Md4-Signature: e8ed189b92d14041ee6317fc1621bdce
Sender: chris@sparky.imd.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Fri, 21 May 1993 02:14:37 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: envbvs@epb9.lbl.gov (Brian V. Smith)
Posting-number: Volume 19, Issue 123
Archive-name: xfig/part11
Environment: X11
Supersedes: xfig: Volume 16, Issue 6-30,39

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 11 (of 27)."
# Contents:  Examples/watch.fig.uu Makefile u_markers.c w_export.c
#   w_modepanel.c
# Wrapped by envbvs@epb9.lbl.gov.lbl.gov on Mon May  3 12:05:54 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Examples/watch.fig.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Examples/watch.fig.uu'\"
else
echo shar: Extracting \"'Examples/watch.fig.uu'\" \(13742 characters\)
sed "s/^X//" >'Examples/watch.fig.uu' <<'END_OF_FILE'
Xbegin 444 watch.fig
XM(T9)1R`R+C$*.#`@,@HU(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P(#$Y
XM-"XP,#`@-#,V+C`P,"`R,#8@-#,Q(#(P-R`T,S8@,C`V(#0T,0HU(#$@,"`Q
XM("TQ(#`@,"`P(#`N,#`P(#`@,"`P(#$Y,"XU,#`@-#,V+C`P,"`R,#@@-#,P
XM(#(P.2`T,S8@,C`X(#0T,@HU(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P
XM(#$X-RXP,#`@-#,V+C`P,"`R,3(@-#(Y(#(Q,R`T,S8@,C$R(#0T,PHU(#$@
XM,"`Q("TQ(#`@,"`P(#`N,#`P(#$@,"`P(#(P-2XP,#`@-#,V+C`P,"`Q.3,@
XM-#,Q(#$Y,B`T,S8@,3DS(#0T,0HU(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#$@
XM,"`P(#(P-RXU,#`@-#,V+C`P,"`Q.3`@-#,P(#$X.2`T,S8@,3DP(#0T,@HU
XM(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#$@,"`P(#(Q,2XP,#`@-#,V+C`P,"`Q
XM.#<@-#(Y(#$X-B`T,S8@,3@W(#0T,PHQ(#0@,"`Q("TQ(#`@,"`P(#`N,#`P
XM(#$@,"XP,#`@,C0P(#,S.2`X(#@@,C,S(#,S.2`R-#@@,S,Y"C$@-"`P(#,@
XM+3$@,"`P(#(Q(#`N,#`P(#$@,"XP,#`@,C0P(#,S.2`S(#,@,C,X(#,S.2`R
XM-#,@,S,Y"C$@,R`P(#$@+3$@,"`P(#(Q(#`N,#`P(#$@,"XP,#`@,3DX(#0T
XM,"`R(#(@,3DX(#0T,"`R,#`@-#0P"C$@,R`P(#$@+3$@,"`P(#(Q(#`N,#`P
XM(#$@,"XP,#`@,C4R(#0T,B`R(#(@,C4R(#0T,B`R-30@-#0R"C(@,R`P(#$@
XM+3$@,"`P(#(Q(#`N,#`P(#`@,"`P"@D@,C,U(#,R."`R,C(@,S`U(#(R,R`S
XM,#,@,C(U(#,P,R`R,S4@,S(X(#DY.3D@.3DY.0HR(#0@,"`Q("TQ(#`@,"`P
XM(#`N,#`P(#4@,"`P"@D@-#<Y(#(U.2`T-SD@,C<Y(#0Y,2`R-SD@-#DQ(#(U
XM.2`T-SD@,C4Y(#DY.3D@.3DY.0HR(#0@,"`Q("TQ(#`@,"`P(#`N,#`P(#4@
XM,"`P"@D@-#<Y(#0Q.2`T-SD@-#,Y(#0Y,2`T,SD@-#DQ(#0Q.2`T-SD@-#$Y
XM(#DY.3D@.3DY.0HR(#0@,"`Q("TQ(#`@,"`P(#`N,#`P(#4@,"`P"@D@,30W
XM(#0Q.2`Q-#<@-#,Y(#$U.2`T,SD@,34Y(#0Q.2`Q-#<@-#$Y(#DY.3D@.3DY
XM.0HR(#$@,"`S("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@,S4T(#,X-"`S-30@
XM,S@Y(#DY.3D@.3DY.0HR(#$@,"`S("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@
XM,S4T(#,U-"`S-30@,S4Y(#DY.3D@.3DY.0HR(#,@,"`Q("TQ(#`@,"`R,2`P
XM+C`P,"`P(#`@,`H)(#0T-B`S-S<@-#0T(#,X,"`T-#0@-#`R(#0T-B`T,#4@
XM-#0X(#0P,B`T-#@@,S@P(#0T-B`S-S<@.3DY.2`Y.3DY"C(@,R`P(#$@+3$@
XM,"`P(#(Q(#`N,#`P(#`@,"`P"@D@-#0V(#,T-2`T-#0@,S0X(#0T-"`S-S`@
XM-#0V(#,W,R`T-#@@,S<P(#0T."`S-#@@-#0V(#,T-2`Y.3DY(#DY.3D*,B`S
XM(#`@,2`M,2`P(#`@,C$@,"XP,#`@,"`P(#`*"2`T-#8@,S<U(#0T,R`S-S,@
XM-#(Q(#,W,R`T,3@@,S<U(#0R,2`S-S<@-#0S(#,W-R`T-#8@,S<U(#DY.3D@
XM.3DY.0HR(#,@,"`Q("TQ(#`@,"`R,2`P+C`P,"`P(#`@,`H)(#,Y."`T,#4@
XM,SDU(#0P,R`S-S,@-#`S(#,W,"`T,#4@,S<S(#0P-R`S.34@-#`W(#,Y."`T
XM,#4@.3DY.2`Y.3DY"C(@,R`P(#$@+3$@,"`P(#(Q(#`N,#`P(#`@,"`P"@D@
XM,S8Y(#,W-B`S-C<@,S<Y(#,V-R`T,#$@,S8Y(#0P-"`S-S$@-#`Q(#,W,2`S
XM-SD@,S8Y(#,W-B`Y.3DY(#DY.3D*,B`S(#`@,2`M,2`P(#`@,C$@,"XP,#`@
XM,"`P(#`*"2`S.3D@,S0U(#,Y-R`S-#@@,SDW(#,W,"`S.3D@,S<S(#0P,2`S
XM-S`@-#`Q(#,T."`S.3D@,S0U(#DY.3D@.3DY.0HR(#,@,"`Q("TQ(#`@,"`R
XM,2`P+C`P,"`P(#`@,`H)(#,Y-R`S-#0@,SDT(#,T,B`S-S(@,S0R(#,V.2`S
XM-#0@,S<R(#,T-B`S.30@,S0V(#,Y-R`S-#0@.3DY.2`Y.3DY"C(@,R`P(#$@
XM+3$@,"`P(#(Q(#`N,#`P(#`@,"`P"@D@,S0T(#,W-B`S-#(@,S<Y(#,T,B`T
XM,#$@,S0T(#0P-"`S-#8@-#`Q(#,T-B`S-SD@,S0T(#,W-B`Y.3DY(#DY.3D*
XM,B`S(#`@,2`M,2`P(#`@,C$@,"XP,#`@,"`P(#`*"2`S-#0@,S0T(#,T,B`S
XM-#<@,S0R(#,V.2`S-#0@,S<R(#,T-B`S-CD@,S0V(#,T-R`S-#0@,S0T(#DY
XM.3D@.3DY.0HR(#,@,"`Q("TQ(#`@,"`R,2`P+C`P,"`P(#`@,`H)(#,Y-R`S
XM-S0@,SDT(#,W,B`S-S(@,S<R(#,V.2`S-S0@,S<R(#,W-B`S.30@,S<V(#,Y
XM-R`S-S0@.3DY.2`Y.3DY"C(@,R`P(#$@+3$@,"`P(#(Q(#`N,#`P(#`@,"`P
XM"@D@,S$T(#,W-B`S,3(@,S<Y(#,Q,B`T,#$@,S$T(#0P-"`S,38@-#`Q(#,Q
XM-B`S-SD@,S$T(#,W-B`Y.3DY(#DY.3D*,B`S(#`@,2`M,2`P(#`@,C$@,"XP
XM,#`@,"`P(#`*"2`S,30@,S0T(#,Q,B`S-#<@,S$R(#,V.2`S,30@,S<R(#,Q
XM-B`S-CD@,S$V(#,T-R`S,30@,S0T(#DY.3D@.3DY.0HR(#,@,"`Q("TQ(#`@
XM,"`R,2`P+C`P,"`P(#`@,`H)(#0Q."`S-#4@-#$V(#,T."`T,38@,S<P(#0Q
XM."`S-S,@-#(P(#,W,"`T,C`@,S0X(#0Q."`S-#4@.3DY.2`Y.3DY"C(@,B`P
XM(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`Q-3$@,C4X(#$U,2`R-SD@,34Y
XM(#(W.2`Q-3D@,C4X(#$U,2`R-3@@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P
XM(#(Q(#`N,#`P(#`@,"`P"@D@,3DT(#,S.2`R,#D@,S,Y(#DY.3D@.3DY.0HR
XM(#$@,"`Q("TQ(#`@,"`R,2`P+C`P,"`P(#`@,`H)(#(X.2`S,SD@,C<T(#,S
XM.2`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#(S
XM.2`S.#D@,C,Y(#0P-"`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P
XM,"`P(#`@,`H)(#(S.2`R-C0@,C,Y(#(W.2`Y.3DY(#DY.3D*,B`S(#`@,2`M
XM,2`P(#`@,C$@,"XP,#`@,"`P(#`*"2`R-#@@,S0Y(#(W,R`S-S<@,C<R(#,X
XM,"`R-CD@,S<Y(#(T."`S-#D@.3DY.2`Y.3DY"C(@,2`P(#(@+3$@,"`P(#`@
XM,"XP,#`@,"`P(#`*"2`T,C`@,S`X(#0S,R`S,#@@.3DY.2`Y.3DY"C(@,2`P
XM(#(@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`T,C$@,C@V(#0S-2`R.#8@.3DY
XM.2`Y.3DY"C(@,2`P(#(@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`T,C,@,C8S
XM(#0S-B`R-C,@.3DY.2`Y.3DY"C(@,2`P(#(@+3$@,"`P(#`@,"XP,#`@,"`P
XM(#`*"2`T,S<@,C@W(#0S-2`S,#<@.3DY.2`Y.3DY"C(@,2`P(#(@+3$@,"`P
XM(#`@,"XP,#`@,"`P(#`*"2`T,SD@,C8T(#0S-R`R.#0@.3DY.2`Y.3DY"C(@
XM,2`P(#(@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`T,3D@,C@W(#0Q-R`S,#<@
XM.3DY.2`Y.3DY"C(@,2`P(#(@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`T,C$@
XM,C8T(#0Q.2`R.#0@.3DY.2`Y.3DY"C(@,2`P(#(@+3$@,"`P(#`@,"XP,#`@
XM,"`P(#`*"2`T,#0@,C@W(#0P,B`S,#<@.3DY.2`Y.3DY"C(@,2`P(#(@+3$@
XM,"`P(#`@,"XP,#`@,"`P(#`*"2`T,#8@,C8T(#0P-"`R.#0@.3DY.2`Y.3DY
XM"C(@-"`P(#$@+3$@,"`P(#`@,"XP,#`@-R`P(#`*"2`R.3D@,C4T(#(Y.2`T
XM,30@-#4T(#0Q-"`T-30@,C4T(#(Y.2`R-30@.3DY.2`Y.3DY"C(@-"`P(#$@
XM+3$@,"`P(#`@,"XP,#`@-R`P(#`*"2`Q.#0@,C4T(#$X-"`T,30@,CDY(#0Q
XM-"`R.3D@,C4T(#$X-"`R-30@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@
XM,"XP,#`@,"`P(#`*"2`R-SD@-#$Y(#$W.2`T,3D@.3DY.2`Y.3DY"C(@,B`P
XM(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`S,C0@-#$Y(#(W.2`T,3D@,C<Y
XM(#0U-"`S,C0@-#4T(#,R-"`T,3D@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P
XM(#`@,"XP,#`@,"`P(#`*"2`S,C0@-#$Y(#,V.2`T,3D@,S8Y(#0U-"`S,C0@
XM-#4T(#,R-"`T,3D@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@
XM,"`P(#`*"2`T,30@-#$Y(#,V.2`T,3D@,S8Y(#0U-"`T,30@-#4T(#0Q-"`T
XM,3D@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`T
XM-3D@-#$Y(#0Q-"`T,3D@.3DY.2`Y.3DY"C(@-"`P(#(@+3$@,"`P(#`@,"XP
XM,#`@."`P(#`*"2`Q-SD@,C0Y(#$W.2`T-30@-#4Y(#0U-"`T-3D@,C0Y(#$W
XM.2`R-#D@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*
XM"2`R-30@,C,Y(#0S.2`R,SD@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@
XM,"XP,#`@,"`P(#`*"2`R-30@,C,T(#0S.2`R,S0@.3DY.2`Y.3DY"C(@,2`P
XM(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`R-30@,C(Y(#0S.2`R,CD@.3DY
XM.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`R-30@,C(T
XM(#0S.2`R,C0@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P
XM(#`*"2`R-30@,C$Y(#0S.2`R,3D@.3DY.2`Y.3DY"C(@,R`P(#(@+3$@,"`P
XM(#`@,"XP,#`@,"`P(#`*"2`Q.#D@,C$T(#$W.2`R,S0@,3@T(#(T-"`T-30@
XM,C0T(#0U.2`R,S0@-#0Y(#(Q-"`Q.#D@,C$T(#DY.3D@.3DY.0HR(#,@,"`R
XM("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@,3@T(#(P.2`Q-CD@,C,Y(#$V.2`T
XM-3D@,3@T(#0X.2`T-30@-#@Y(#0V.2`T-3D@-#8Y(#(S.2`T-30@,C`Y"@D@
XM,3@T(#(P.2`Y.3DY(#DY.3D*,B`S(#`@,R`M,2`P(#`@,"`P+C`P,"`P(#`@
XM,`H)(#$W.2`Q.3D@,34Y(#(S.2`Q-3D@-#4Y(#$W.2`T.3D@-#4Y(#0Y.2`T
XM-SD@-#4Y(#0W.2`R,SD@-#4Y(#$Y.0H)(#$W.2`Q.3D@.3DY.2`Y.3DY"C(@
XM,R`P(#$@+3$@,"`P(#0@,"XP,#`@,"`P(#`*"2`Q.#D@,3DY(#$X.2`Q.#0@
XM,C8Y(#$X-"`R-CD@,38T(#(X.2`Q-C0@,C@Y(#$X-"`S,#D@,3@T(#,P.2`Q
XM-C0*"2`S,CD@,38T(#,R.2`Q.#0@,S0Y(#$X-"`S-#D@,38T(#,V.2`Q-C0@
XM,S8Y(#$X-"`T-#D@,3@T(#0T.2`Q.3D*"2`Q.#D@,3DY(#DY.3D@.3DY.0HR
XM(#,@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,3DT(#$W.2`R-CD@,3<Y
XM(#(V.2`Q-#0@,C`T(#$T-"`Q.30@,3<Y(#DY.3D@.3DY.0HR(#,@,"`Q("TQ
XM(#`@,"`T(#`N,#`P(#`@,"`P"@D@,C8Y(#$S.2`R-CD@,3`T(#(Q-B`Q,#0@
XM,C`V(#$S.2`R-CD@,3,Y(#DY.3D@.3DY.0HR(#,@,"`Q("TQ(#`@,"`T(#`N
XM,#`P(#`@,"`P"@D@,C8Y(#DY(#(V.2`V-"`R,C,@-C0@,C$W(#DY(#(V.2`Y
XM.2`Y.3DY(#DY.3D*,B`S(#`@,2`M,2`P(#`@-"`P+C`P,"`P(#`@,`H)(#(R
XM-"`U.2`R-CD@-3D@,C8Y(#(T(#(R-R`R-"`R,C0@-3D@.3DY.2`Y.3DY"C(@
XM,B`P(#$@+3$@,"`P(#0@,"XP,#`@,"`P(#`*"2`R-CD@,3(T(#(V.2`Q-C0@
XM,C@Y(#$V-"`R.#D@,3(T(#(V.2`Q,C0@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@
XM,"`P(#0@,"XP,#`@,"`P(#`*"2`R.#D@,30T(#(X.2`Q.#0@,S`Y(#$X-"`S
XM,#D@,30T(#(X.2`Q-#0@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#0@,"XP
XM,#`@,"`P(#`*"2`S-#D@-"`S-#D@-#0@,S8Y(#0T(#,V.2`T(#,T.2`T(#DY
XM.3D@.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,S`Y(#$R
XM-"`S,#D@,38T(#,R.2`Q-C0@,S(Y(#$R-"`S,#D@,3(T(#DY.3D@.3DY.0HR
XM(#(@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,C@Y(#$P-"`R.#D@,30T
XM(#,P.2`Q-#0@,S`Y(#$P-"`R.#D@,3`T(#DY.3D@.3DY.0HR(#(@,"`Q("TQ
XM(#`@,"`T(#`N,#`P(#`@,"`P"@D@,C8Y(#@T(#(V.2`Q,C0@,C@Y(#$R-"`R
XM.#D@.#0@,C8Y(#@T(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P
XM(#`@,"`P"@D@,C@Y(#8T(#(X.2`Q,#0@,S`Y(#$P-"`S,#D@-C0@,C@Y(#8T
XM(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,S`Y
XM(#@T(#,P.2`Q,C0@,S(Y(#$R-"`S,CD@.#0@,S`Y(#@T(#DY.3D@.3DY.0HR
XM(#(@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,S(Y(#$T-"`S,CD@,3@T
XM(#,T.2`Q.#0@,S0Y(#$T-"`S,CD@,30T(#DY.3D@.3DY.0HR(#(@,"`Q("TQ
XM(#`@,"`T(#`N,#`P(#`@,"`P"@D@,S(Y(#$P-"`S,CD@,30T(#,T.2`Q-#0@
XM,S0Y(#$P-"`S,CD@,3`T(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N
XM,#`P(#`@,"`P"@D@,S0Y(#$R-"`S-#D@,38T(#,V.2`Q-C0@,S8Y(#$R-"`S
XM-#D@,3(T(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P
XM"@D@,S0Y(#@T(#,T.2`Q,C0@,S8Y(#$R-"`S-CD@.#0@,S0Y(#@T(#DY.3D@
XM.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,S(Y(#8T(#,R
XM.2`Q,#0@,S0Y(#$P-"`S-#D@-C0@,S(Y(#8T(#DY.3D@.3DY.0HR(#(@,"`Q
XM("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,S`Y(#0T(#,P.2`X-"`S,CD@.#0@
XM,S(Y(#0T(#,P.2`T-"`Y.3DY(#DY.3D*,B`R(#`@,2`M,2`P(#`@-"`P+C`P
XM,"`P(#`@,`H)(#(V.2`T-"`R-CD@.#0@,C@Y(#@T(#(X.2`T-"`R-CD@-#0@
XM.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#0@,"XP,#`@,"`P(#`*"2`R.#D@
XM,C0@,C@Y(#8T(#,P.2`V-"`S,#D@,C0@,C@Y(#(T(#DY.3D@.3DY.0HR(#(@
XM,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,C8Y(#0@,C8Y(#0T(#(X.2`T
XM-"`R.#D@-"`R-CD@-"`Y.3DY(#DY.3D*,B`R(#`@,2`M,2`P(#`@-"`P+C`P
XM,"`P(#`@,`H)(#,R.2`R-"`S,CD@-C0@,S0Y(#8T(#,T.2`R-"`S,CD@,C0@
XM.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#0@,"XP,#`@,"`P(#`*"2`S,#D@
XM-"`S,#D@-#0@,S(Y(#0T(#,R.2`T(#,P.2`T(#DY.3D@.3DY.0HR(#(@,"`Q
XM("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,S0Y(#0T(#,T.2`X-"`S-CD@.#0@
XM,S8Y(#0T(#,T.2`T-"`Y.3DY(#DY.3D*,B`S(#`@,2`M,2`P(#`@-"`P+C`P
XM,"`P(#`@,`H)(#0T-"`Q-SD@,S8Y(#$W.2`S-CD@,30T(#0S-"`Q-#0@-#0T
XM(#$W.2`Y.3DY(#DY.3D*,B`S(#`@,2`M,2`P(#`@-"`P+C`P,"`P(#`@,`H)
XM(#,V.2`Q,SD@,S8Y(#$P-"`T,C(@,3`T(#0S,B`Q,SD@,S8Y(#$S.2`Y.3DY
XM(#DY.3D*,B`S(#`@,2`M,2`P(#`@-"`P+C`P,"`P(#`@,`H)(#,V.2`Y.2`S
XM-CD@-C0@-#$U(#8T(#0R,2`Y.2`S-CD@.3D@.3DY.2`Y.3DY"C(@,R`P(#$@
XM+3$@,"`P(#0@,"XP,#`@,"`P(#`*"2`T,30@-3D@,S8Y(#4Y(#,V.2`R-"`T
XM,3$@,C0@-#$T(#4Y(#DY.3D@.3DY.0HR(#,@,"`Q("TQ(#`@,"`T(#`N,#`P
XM(#`@,"`P"@D@-#$T(#8S.2`S-CD@-C,Y(#,V.2`V-S0@-#$Q(#8W-"`T,30@
XM-C,Y(#DY.3D@.3DY.0HR(#,@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@
XM,S8Y(#4Y.2`S-CD@-C,T(#0Q-2`V,S0@-#(Q(#4Y.2`S-CD@-3DY(#DY.3D@
XM.3DY.0HR(#,@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,S8Y(#4U.2`S
XM-CD@-3DT(#0R,B`U.30@-#,R(#4U.2`S-CD@-34Y(#DY.3D@.3DY.0HR(#,@
XM,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@-#0T(#4Q.2`S-CD@-3$Y(#,V
XM.2`U-30@-#,T(#4U-"`T-#0@-3$Y(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@
XM,"`T(#`N,#`P(#`@,"`P"@D@,S0Y(#8U-"`S-#D@-C$T(#,V.2`V,30@,S8Y
XM(#8U-"`S-#D@-C4T(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P
XM(#`@,"`P"@D@,S`Y(#8Y-"`S,#D@-C4T(#,R.2`V-30@,S(Y(#8Y-"`S,#D@
XM-CDT(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@
XM,S(Y(#8W-"`S,CD@-C,T(#,T.2`V,S0@,S0Y(#8W-"`S,CD@-C<T(#DY.3D@
XM.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,C8Y(#8Y-"`R
XM-CD@-C4T(#(X.2`V-30@,C@Y(#8Y-"`R-CD@-CDT(#DY.3D@.3DY.0HR(#(@
XM,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,C@Y(#8W-"`R.#D@-C,T(#,P
XM.2`V,S0@,S`Y(#8W-"`R.#D@-C<T(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@
XM,"`T(#`N,#`P(#`@,"`P"@D@,C8Y(#8U-"`R-CD@-C$T(#(X.2`V,30@,C@Y
XM(#8U-"`R-CD@-C4T(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P
XM(#`@,"`P"@D@,S`Y(#8U-"`S,#D@-C$T(#,R.2`V,30@,S(Y(#8U-"`S,#D@
XM-C4T(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@
XM,S(Y(#8S-"`S,CD@-3DT(#,T.2`U.30@,S0Y(#8S-"`S,CD@-C,T(#DY.3D@
XM.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,S0Y(#8Q-"`S
XM-#D@-3<T(#,V.2`U-S0@,S8Y(#8Q-"`S-#D@-C$T(#DY.3D@.3DY.0HR(#(@
XM,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,S0Y(#4W-"`S-#D@-3,T(#,V
XM.2`U,S0@,S8Y(#4W-"`S-#D@-3<T(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@
XM,"`T(#`N,#`P(#`@,"`P"@D@,S(Y(#4Y-"`S,CD@-34T(#,T.2`U-30@,S0Y
XM(#4Y-"`S,CD@-3DT(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P
XM(#`@,"`P"@D@,S(Y(#4U-"`S,CD@-3$T(#,T.2`U,30@,S0Y(#4U-"`S,CD@
XM-34T(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@
XM,S`Y(#8Q-"`S,#D@-3<T(#,R.2`U-S0@,S(Y(#8Q-"`S,#D@-C$T(#DY.3D@
XM.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,C@Y(#8S-"`R
XM.#D@-3DT(#,P.2`U.30@,S`Y(#8S-"`R.#D@-C,T(#DY.3D@.3DY.0HR(#(@
XM,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,C8Y(#8Q-"`R-CD@-3<T(#(X
XM.2`U-S0@,C@Y(#8Q-"`R-CD@-C$T(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@
XM,"`T(#`N,#`P(#`@,"`P"@D@,C@Y(#4Y-"`R.#D@-34T(#,P.2`U-30@,S`Y
XM(#4Y-"`R.#D@-3DT(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P
XM(#`@,"`P"@D@,S`Y(#4W-"`S,#D@-3,T(#,R.2`U,S0@,S(Y(#4W-"`S,#D@
XM-3<T(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@
XM,S0Y(#8Y-"`S-#D@-C4T(#,V.2`V-30@,S8Y(#8Y-"`S-#D@-CDT(#DY.3D@
XM.3DY.0HR(#(@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,C@Y(#4U-"`R
XM.#D@-3$T(#,P.2`U,30@,S`Y(#4U-"`R.#D@-34T(#DY.3D@.3DY.0HR(#(@
XM,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,C8Y(#4W-"`R-CD@-3,T(#(X
XM.2`U,S0@,C@Y(#4W-"`R-CD@-3<T(#DY.3D@.3DY.0HR(#,@,"`Q("TQ(#`@
XM,"`T(#`N,#`P(#`@,"`P"@D@,C(T(#8S.2`R-CD@-C,Y(#(V.2`V-S0@,C(W
XM(#8W-"`R,C0@-C,Y(#DY.3D@.3DY.0HR(#,@,"`Q("TQ(#`@,"`T(#`N,#`P
XM(#`@,"`P"@D@,C8Y(#4Y.2`R-CD@-C,T(#(R,R`V,S0@,C$W(#4Y.2`R-CD@
XM-3DY(#DY.3D@.3DY.0HR(#,@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@
XM,C8Y(#4U.2`R-CD@-3DT(#(Q-B`U.30@,C`V(#4U.2`R-CD@-34Y(#DY.3D@
XM.3DY.0HR(#,@,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,3DT(#4Q.2`R
XM-CD@-3$Y(#(V.2`U-30@,C`T(#4U-"`Q.30@-3$Y(#DY.3D@.3DY.0HR(#,@
XM,"`Q("TQ(#`@,"`T(#`N,#`P(#`@,"`P"@D@,3@Y(#0Y.2`Q.#D@-3$T(#(V
XM.2`U,30@,C8Y(#4S-"`R.#D@-3,T(#(X.2`U,30@,S`Y(#4Q-"`S,#D@-3,T
XM"@D@,S(Y(#4S-"`S,CD@-3$T(#,T.2`U,30@,S0Y(#4S-"`S-CD@-3,T(#,V
XM.2`U,30@-#0Y(#4Q-"`T-#D@-#DY"@D@,3@Y(#0Y.2`Y.3DY(#DY.3D*,B`Q
XM(#`@,R`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#(P,"`T,S(@,C`T(#0S,B`Y
XM.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,C$@,"XP,#`@,"`P(#`*"2`R,#`@
XM-#,Y(#(P,"`T,S(@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@
XM,"`P(#`*"2`R-#0@-#,Y(#(T-B`T,S<@,C0X(#0S,"`R-3$@-#(Y(#DY.3D@
XM.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@,C4Y(#0S.2`R
XM-3<@-#,W(#(U-2`T,S`@,C4R(#0R.2`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P
XM(#`@,"`P+C`P,"`P(#`@,`H)(#(T-"`T,SD@,C4X(#0S.2`Y.3DY(#DY.3D*
XM,B`Q(#`@,B`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#(U,B`T,CD@,C4R(#0R
XM-R`Y.3DY(#DY.3D*-"`P(#$X(#$T(#`@+3$@,"`P+C`P,"`T(#$Q(#(S(#,Q
XM.2`R.#D@04T!"C0@,2`Q."`Q."`P("TQ(#`@,"XP,#`@-"`Q-"`V,"`R,3@@
XM,C,V($-!4TE/`0HT(#$@,3@@,30@,"`M,2`P(#`N,#`P(#0@,3$@,S(@-#,V
XM(#0T,B!#2%(!"C0@,2`Q."`Q-"`P("TQ(#`@,"XP,#`@-"`Q,2`S,B`S.3,@
XM-#0R(%1-4@$*-"`Q(#$X(#$T(#`@+3$@,"`P+C`P,"`T(#$Q(#0P(#,T-R`T
XM-#(@1%5!3`$*-"`Q(#$X(#$T(#`@+3$@,"`P+C`P,"`T(#$Q(#,Q(#,P,2`T
X(-#(@04Q-`0H*
X`
Xend
END_OF_FILE
if test 13742 -ne `wc -c <'Examples/watch.fig.uu'`; then
    echo shar: \"'Examples/watch.fig.uu'\" unpacked with wrong size!
fi
# end of 'Examples/watch.fig.uu'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(13610 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and </tmp/IIf.a12617>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.72.1.1 92/03/18 13:13:37 rws Exp $
X
X# operating system:  SunOS 4.1.2
X
X# $XConsortium: sunLib.rules,v 1.7 91/12/20 11:19:47 rws Exp $
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -g kmem -m 2755
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS =
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/lib
X           BINDIR = /usr/bin/X11
X          INCROOT = /usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = l
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X# $XConsortium: sunLib.tmpl,v 1.14.1.1 92/03/17 14:58:46 rws Exp $
X
XSHLIBLDFLAGS = -assert pure-text
XPICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X       XMULIBONLY = -lXmu
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
X# Uncomment the following if needed for DECstations running older X11R4
X#INCROOT=/usr/include/mit
X
XSYS_LIBRARIES= 		-lm
XDEPLIBS = 		$(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X# use the following if NOT using DPS
XLOCAL_LIBRARIES = 	$(XAWLIB) $(XMULIB) $(XTOOLLIB) $(XLIB)
X# use the following if using DPS, *** and add -DDPS to the DEFINES line ***
X#LOCAL_LIBRARIES = 	-ldps $(XAWLIB) $(XMULIB) $(XTOOLLIB) $(XLIB)
X# use (and change) the following if you want the multi-key data base file
X# somewhere other than the standard X11 library directory
X#XFIGLIBDIR =		/usr/local/lib/X11/xfig
X# use this if you want the multi-key data base file in the standard X11 tree
XXFIGLIBDIR =		$(LIBDIR)/xfig
XDIR_DEFS=		-DXFIGLIBDIR=\"$(XFIGLIBDIR)\"
X
X# remove -DGSBIT from the DEFINES if you DON'T want to have gs (ghostscript)
X# generate a preview bitmap.  If you do use ghostscript you will need
X# version 2.4 or later.
XDEFINES =             $(STRSTRDEFINES) -DGSBIT
X
XXFIGSRC =	d_arc.c d_arcbox.c d_box.c d_ellipse.c d_epsobj.c \
X		d_intspline.c d_line.c d_regpoly.c d_spline.c d_text.c \
X		e_addpt.c e_align.c e_arrow.c e_break.c \
X		e_convert.c e_copy.c e_delete.c e_deletept.c \
X		e_edit.c e_flip.c e_glue.c e_move.c \
X		e_movept.c e_rotate.c e_scale.c e_update.c \
X		f_load.c f_read.c f_epsobj.c \
X		f_readold.c f_save.c f_util.c f_xbitmap.c \
X		main.c mode.c object.c resources.c \
X		u_bound.c u_create.c u_drag.c u_draw.c \
X		u_elastic.c u_error.c u_fonts.c u_free.c u_geom.c \
X		u_list.c u_markers.c u_pan.c u_print.c \
X		u_redraw.c u_search.c u_translate.c u_undo.c \
X		w_canvas.c w_cmdpanel.c w_cursor.c w_dir.c w_drawprim.c \
X		w_export.c w_file.c w_fontbits.c w_fontpanel.c w_grid.c \
X		w_icons.c w_indpanel.c w_modepanel.c w_mousefun.c w_msgpanel.c \
X		w_print.c w_rottext.c w_rulers.c w_setup.c w_util.c w_zoom.c
X
XXFIGOBJ =	d_arc.o d_arcbox.o d_box.o d_ellipse.o d_epsobj.o \
X		d_intspline.o d_line.o d_regpoly.o d_spline.o d_text.o \
X		e_addpt.o e_align.o e_arrow.o e_break.o \
X		e_convert.o e_copy.o e_delete.o e_deletept.o \
X		e_edit.o e_flip.o e_glue.o e_move.o \
X		e_movept.o e_rotate.o e_scale.o e_update.o \
X		f_load.o f_read.o f_epsobj.o \
X		f_readold.o f_save.o f_util.o f_xbitmap.o \
X		main.o mode.o object.o resources.o \
X		u_bound.o u_create.o u_drag.o u_draw.o \
X		u_elastic.o u_error.o u_fonts.o u_free.o u_geom.o \
X		u_list.o u_markers.o u_pan.o u_print.o \
X		u_redraw.o u_search.o u_translate.o u_undo.o \
X		w_canvas.o w_cmdpanel.o w_cursor.o w_dir.o w_drawprim.o \
X		w_export.o w_file.o w_fontbits.o w_fontpanel.o w_grid.o \
X		w_icons.o w_indpanel.o w_modepanel.o w_mousefun.o w_msgpanel.o \
X		w_print.o w_rottext.o w_rulers.o w_setup.o w_util.o w_zoom.o
X
XSRCS = $(XFIGSRC)
XOBJS = $(XFIGOBJ)
X
X PROGRAM = xfig
X
Xall:: xfig
X
Xxfig: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xsaber_xfig:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xosaber_xfig:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xinstall:: xfig
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  xfig $(DESTDIR)$(BINDIR)
X
Xinstall.man:: Doc/xfig.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) Doc/xfig.man $(DESTDIR)$(MANDIR)/xfig.$(MANSUFFIX)
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
Xinstall::
X	@case '${MFLAGS}' in *[i]*) set +e;; esac;
X	@for i in $(XFIGLIBDIR); do if [ -d $(DESTDIR)$$i ]; then \
X	set +x; else (set -x; $(MKDIRHIER) $(DESTDIR)$$i); fi \
X	done
X
Xinstall:: CompKeyDB
X	$(INSTALL) -c $(INSTDATFLAGS) CompKeyDB $(DESTDIR)$(XFIGLIBDIR)
X
Xinstall:: Fig.ad
X	@if [ -d $(DESTDIR)$(XAPPLOADDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XAPPLOADDIR)); fi
X	$(INSTALL) -c $(INSTAPPFLAGS) Fig.ad $(DESTDIR)$(XAPPLOADDIR)/Fig
X
Xinstall:: Fig-color.ad
X	@if [ -d $(DESTDIR)$(XAPPLOADDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XAPPLOADDIR)); fi
X	$(INSTALL) -c $(INSTAPPFLAGS) Fig-color.ad $(DESTDIR)$(XAPPLOADDIR)/Fig-color
X
Xw_canvas.o:  $(ICONFIGFILES)
X	$(RM) $@
X	$(CC) -c $(CFLAGS)  $(DIR_DEFS) $*.c
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	# load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	# load $(ALLDEFINES) $(OBJS)
X
X# -------------------------------------------------------------------------
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
END_OF_FILE
if test 13610 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'u_markers.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'u_markers.c'\"
else
echo shar: Extracting \"'u_markers.c'\" \(13865 characters\)
sed "s/^X//" >'u_markers.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both the copyright
X * notice and this permission notice appear in supporting documentation. 
X * No representations are made about the suitability of this software for 
X * any purpose.  It is provided "as is" without express or implied warranty."
X */
X
X#include "fig.h"
X#include "resources.h"
X#include "object.h"
X#include "mode.h"
X#include "paintop.h"
X#include "w_zoom.h"
X
X#define set_marker(win,x,y,w,h,z1,z2) \
X	zXDrawRectangle(tool_d,(win),gccache[INV_PAINT],(x),(y),(w),(h))
X
X#ifdef notdef
X/* not used in present implementation */
Xstatic u_int	marker_pattern[3] = {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
X
Xmpr_static(pmarker, 5, 5, 1, marker_pattern);
X#endif
X
Xcenter_marker(x, y)
X    int		    x, y;
X{
X    pw_vector(canvas_win, x, y - 2, x, y + 2, INV_PAINT, 1,
X	      RUBBER_LINE, 0.0, DEFAULT_COLOR);
X    pw_vector(canvas_win, x - 2, y, x + 2, y, INV_PAINT, 1,
X	      RUBBER_LINE, 0.0, DEFAULT_COLOR);
X}
X
Xtoggle_csrhighlight(x, y)
X    int		    x, y;
X{
X    set_line_stuff(1, RUBBER_LINE, 0.0, (INV_PAINT), DEFAULT_COLOR);
X    set_marker(canvas_win, x - 2, y - 2, 5, 5, 0, 0);
X    set_marker(canvas_win, x - 1, y - 1, 3, 3, 0, 0);
X}
X
Xellipse_in_mask()
X{
X    return (cur_objmask & M_ELLIPSE);
X}
X
Xarc_in_mask()
X{
X    return (cur_objmask & M_ARC);
X}
X
Xcompound_in_mask()
X{
X    return (cur_objmask & M_COMPOUND);
X}
X
Xanytext_in_mask()
X{
X    return ((cur_objmask & M_TEXT_NORMAL) || (cur_objmask & M_TEXT_HIDDEN));
X}
X
Xvalidtext_in_mask(t)
X    F_text	   *t;
X{
X    return ((hidden_text(t) && (cur_objmask & M_TEXT_HIDDEN)) ||
X	    ((!hidden_text(t)) && (cur_objmask & M_TEXT_NORMAL)));
X}
X
Xanyline_in_mask()
X{
X    return ((cur_objmask & M_POLYLINE_LINE) ||
X	    (cur_objmask & M_POLYLINE_POLYGON) ||
X	    (cur_objmask & M_POLYLINE_BOX));
X}
X
Xvalidline_in_mask(l)
X    F_line	   *l;
X{
X    return ((((l->type == T_BOX) ||
X	      (l->type == T_ARC_BOX)) && (cur_objmask & M_POLYLINE_BOX)) ||
X	    ((l->type == T_EPS_BOX) && (cur_objmask & M_POLYLINE_BOX)) ||
X	    ((l->type == T_POLYLINE) && (cur_objmask & M_POLYLINE_LINE)) ||
X	    ((l->type == T_POLYGON) && (cur_objmask & M_POLYLINE_POLYGON)));
X}
X
Xanyspline_in_mask()
X{
X    return ((cur_objmask & M_SPLINE_O_NORMAL) ||
X	    (cur_objmask & M_SPLINE_O_INTERP) ||
X	    (cur_objmask & M_SPLINE_C_NORMAL) ||
X	    (cur_objmask & M_SPLINE_C_INTERP));
X}
X
Xvalidspline_in_mask(s)
X    F_spline	   *s;
X{
X    return (((s->type == T_OPEN_INTERP) && (cur_objmask & M_SPLINE_O_INTERP)) ||
X	((s->type == T_OPEN_NORMAL) && (cur_objmask & M_SPLINE_O_NORMAL)) ||
X      ((s->type == T_CLOSED_INTERP) && (cur_objmask & M_SPLINE_C_INTERP)) ||
X       ((s->type == T_CLOSED_NORMAL) && (cur_objmask & M_SPLINE_C_NORMAL)));
X}
X
Xmask_toggle_ellipsemarker(e)
X    F_ellipse	   *e;
X{
X    if (ellipse_in_mask())
X	toggle_ellipsemarker(e);
X}
X
Xmask_toggle_arcmarker(a)
X    F_arc	   *a;
X{
X    if (arc_in_mask())
X	toggle_arcmarker(a);
X}
X
Xmask_toggle_compoundmarker(c)
X    F_compound	   *c;
X{
X    if (compound_in_mask())
X	toggle_compoundmarker(c);
X}
X
Xmask_toggle_textmarker(t)
X    F_text	   *t;
X{
X    if (validtext_in_mask(t))
X	toggle_textmarker(t);
X}
X
Xmask_toggle_linemarker(l)
X    F_line	   *l;
X{
X    if (validline_in_mask(l))
X	toggle_linemarker(l);
X}
X
Xmask_toggle_splinemarker(s)
X    F_spline	   *s;
X{
X    if (validspline_in_mask(s))
X	toggle_splinemarker(s);
X}
X
Xtoggle_markers()
X{
X    toggle_markers_in_compound(&objects);
X}
X
Xtoggle_markers_in_compound(cmpnd)
X    F_compound	   *cmpnd;
X{
X    F_ellipse	   *e;
X    F_arc	   *a;
X    F_line	   *l;
X    F_spline	   *s;
X    F_text	   *t;
X    F_compound	   *c;
X    register int    mask;
X
X    mask = cur_objmask;
X    if (mask & M_ELLIPSE)
X	for (e = cmpnd->ellipses; e != NULL; e = e->next)
X	    toggle_ellipsemarker(e);
X    if ((mask & M_TEXT_NORMAL) || (mask & M_TEXT_HIDDEN))
X	for (t = cmpnd->texts; t != NULL; t = t->next) {
X	    if ((hidden_text(t) && (mask & M_TEXT_HIDDEN)) ||
X		((!hidden_text(t)) && (mask & M_TEXT_NORMAL)))
X		toggle_textmarker(t);
X	}
X    if (mask & M_ARC)
X	for (a = cmpnd->arcs; a != NULL; a = a->next)
X	    toggle_arcmarker(a);
X    if ((mask & M_POLYLINE_LINE) ||
X	(mask & M_POLYLINE_POLYGON) ||
X	(mask & M_POLYLINE_BOX))
X	for (l = cmpnd->lines; l != NULL; l = l->next) {
X	    if ((((l->type == T_BOX) ||
X		  (l->type == T_ARC_BOX)) && (mask & M_POLYLINE_BOX)) ||
X		((l->type == T_EPS_BOX) && (mask & M_POLYLINE_BOX)) ||
X		((l->type == T_POLYLINE) && (mask & M_POLYLINE_LINE)) ||
X		((l->type == T_POLYGON) && (mask & M_POLYLINE_POLYGON)))
X		toggle_linemarker(l);
X	}
X    if ((mask & M_SPLINE_O_NORMAL) || (mask & M_SPLINE_O_INTERP) ||
X	(mask & M_SPLINE_C_NORMAL) || (mask & M_SPLINE_C_INTERP))
X	for (s = cmpnd->splines; s != NULL; s = s->next) {
X	    if (((s->type == T_OPEN_INTERP) && (mask & M_SPLINE_O_INTERP)) ||
X		((s->type == T_OPEN_NORMAL) && (mask & M_SPLINE_O_NORMAL)) ||
X	     ((s->type == T_CLOSED_INTERP) && (mask & M_SPLINE_C_INTERP)) ||
X		((s->type == T_CLOSED_NORMAL) && (mask & M_SPLINE_C_NORMAL)))
X		toggle_splinemarker(s);
X	}
X    if (mask & M_COMPOUND)
X	for (c = cmpnd->compounds; c != NULL; c = c->next)
X	    toggle_compoundmarker(c);
X}
X
Xupdate_markers(mask)
X    int		    mask;
X{
X    F_ellipse	   *e;
X    F_arc	   *a;
X    F_line	   *l;
X    F_spline	   *s;
X    F_text	   *t;
X    F_compound	   *c;
X    register int    oldmask, newmask;
X
X    oldmask = cur_objmask;
X    newmask = mask;
X    if ((oldmask & M_ELLIPSE) != (newmask & M_ELLIPSE))
X	for (e = objects.ellipses; e != NULL; e = e->next)
X	    toggle_ellipsemarker(e);
X    if (((oldmask & M_TEXT_NORMAL) != (newmask & M_TEXT_NORMAL)) ||
X	((oldmask & M_TEXT_HIDDEN) != (newmask & M_TEXT_HIDDEN)))
X	for (t = objects.texts; t != NULL; t = t->next) {
X	    if ((hidden_text(t) &&
X		 ((oldmask & M_TEXT_HIDDEN) != (newmask & M_TEXT_HIDDEN))) ||
X		((!hidden_text(t)) &&
X		 ((oldmask & M_TEXT_NORMAL) != (newmask & M_TEXT_NORMAL))))
X		toggle_textmarker(t);
X	}
X    if ((oldmask & M_ARC) != (newmask & M_ARC))
X	for (a = objects.arcs; a != NULL; a = a->next)
X	    toggle_arcmarker(a);
X    if (((oldmask & M_POLYLINE_LINE) != (newmask & M_POLYLINE_LINE)) ||
X	((oldmask & M_POLYLINE_POLYGON) != (newmask & M_POLYLINE_POLYGON)) ||
X	((oldmask & M_POLYLINE_BOX) != (newmask & M_POLYLINE_BOX)))
X	for (l = objects.lines; l != NULL; l = l->next) {
X	    if ((((l->type == T_BOX) ||
X		  (l->type == T_ARC_BOX || l->type == T_EPS_BOX)) &&
X	      ((oldmask & M_POLYLINE_BOX) != (newmask & M_POLYLINE_BOX))) ||
X		((l->type == T_POLYLINE) &&
X	    ((oldmask & M_POLYLINE_LINE) != (newmask & M_POLYLINE_LINE))) ||
X		((l->type == T_POLYGON) &&
X		 ((oldmask & M_POLYLINE_POLYGON) != (newmask & M_POLYLINE_POLYGON))))
X		toggle_linemarker(l);
X	}
X    if (((oldmask & M_SPLINE_O_NORMAL) != (newmask & M_SPLINE_O_NORMAL)) ||
X	((oldmask & M_SPLINE_O_INTERP) != (newmask & M_SPLINE_O_INTERP)) ||
X	((oldmask & M_SPLINE_C_NORMAL) != (newmask & M_SPLINE_C_NORMAL)) ||
X	((oldmask & M_SPLINE_C_INTERP) != (newmask & M_SPLINE_C_INTERP)))
X	for (s = objects.splines; s != NULL; s = s->next) {
X	    if (((s->type == T_OPEN_INTERP) &&
X		 ((oldmask & M_SPLINE_O_INTERP) !=
X		  (newmask & M_SPLINE_O_INTERP))) ||
X		((s->type == T_OPEN_NORMAL) &&
X		 ((oldmask & M_SPLINE_O_NORMAL) !=
X		  (newmask & M_SPLINE_O_NORMAL))) ||
X		((s->type == T_CLOSED_INTERP) &&
X		 ((oldmask & M_SPLINE_C_INTERP) !=
X		  (newmask & M_SPLINE_C_INTERP))) ||
X		((s->type == T_CLOSED_NORMAL) &&
X		 ((oldmask & M_SPLINE_C_NORMAL) !=
X		  (newmask & M_SPLINE_C_NORMAL))))
X		toggle_splinemarker(s);
X	}
X    if ((oldmask & M_COMPOUND) != (newmask & M_COMPOUND))
X	for (c = objects.compounds; c != NULL; c = c->next)
X	    toggle_compoundmarker(c);
X    cur_objmask = newmask;
X}
X
Xtoggle_ellipsemarker(e)
X    F_ellipse	   *e;
X{
X    set_line_stuff(1, RUBBER_LINE, 0.0, (INV_PAINT), DEFAULT_COLOR);
X    set_marker(canvas_win, e->start.x - 2, e->start.y - 2, 5, 5, 0, 0);
X    set_marker(canvas_win, e->end.x - 2, e->end.y - 2, 5, 5, 0, 0);
X    if (e->tagged)
X	toggle_ellipsehighlight(e);
X}
X
Xtoggle_ellipsehighlight(e)
X    F_ellipse	   *e;
X{
X    set_line_stuff(1, RUBBER_LINE, 0.0, (INV_PAINT), DEFAULT_COLOR);
X    set_marker(canvas_win, e->start.x, e->start.y, 1, 1, 0, 0);
X    set_marker(canvas_win, e->start.x - 1, e->start.y - 1, 3, 3, 0, 0);
X    set_marker(canvas_win, e->end.x, e->end.y, 1, 1, 0, 0);
X    set_marker(canvas_win, e->end.x - 1, e->end.y - 1, 3, 3, 0, 0);
X}
X
Xtoggle_arcmarker(a)
X    F_arc	   *a;
X{
X    set_line_stuff(1, RUBBER_LINE, 0.0, (INV_PAINT), DEFAULT_COLOR);
X    set_marker(canvas_win, a->point[0].x - 2, a->point[0].y - 2, 5, 5, 0, 0);
X    set_marker(canvas_win, a->point[1].x - 2, a->point[1].y - 2, 5, 5, 0, 0);
X    set_marker(canvas_win, a->point[2].x - 2, a->point[2].y - 2, 5, 5, 0, 0);
X    if (a->tagged)
X	toggle_archighlight(a);
X}
X
Xtoggle_archighlight(a)
X    F_arc	   *a;
X{
X    set_line_stuff(1, RUBBER_LINE, 0.0, (INV_PAINT), DEFAULT_COLOR);
X    set_marker(canvas_win, a->point[0].x, a->point[0].y, 1, 1, 0, 0);
X    set_marker(canvas_win, a->point[0].x - 1, a->point[0].y - 1, 3, 3, 0, 0);
X    set_marker(canvas_win, a->point[1].x, a->point[1].y, 1, 1, 0, 0);
X    set_marker(canvas_win, a->point[1].x - 1, a->point[1].y - 1, 3, 3, 0, 0);
X    set_marker(canvas_win, a->point[2].x, a->point[2].y, 1, 1, 0, 0);
X    set_marker(canvas_win, a->point[2].x - 1, a->point[2].y - 1, 3, 3, 0, 0);
X}
X
Xtoggle_textmarker(t)
X    F_text	   *t;
X{
X    int		    dx, dy;
X
X    set_line_stuff(1, RUBBER_LINE, 0.0, (INV_PAINT), DEFAULT_COLOR);
X    /* adjust for text angle */
X    dy = (int) ((double) t->height * cos(t->angle));
X    dx = (int) ((double) t->height * sin(t->angle));
X    set_marker(canvas_win, t->base_x - dx - 2, t->base_y - dy - 2, 5, 5, 0, 0);
X    set_marker(canvas_win, t->base_x - 2, t->base_y - 2, 5, 5, 0, 0);
X    if (t->tagged)
X	toggle_texthighlight(t);
X}
X
Xtoggle_texthighlight(t)
X    F_text	   *t;
X{
X    int		    dx, dy;
X
X    set_line_stuff(1, RUBBER_LINE, 0.0, (INV_PAINT), DEFAULT_COLOR);
X    /* adjust for text angle */
X    dy = (int) ((double) t->height * cos(t->angle));
X    dx = (int) ((double) t->height * sin(t->angle));
X    set_marker(canvas_win, t->base_x - dx, t->base_y - dy, 1, 1, 0, 0);
X    set_marker(canvas_win, t->base_x - dx - 1, t->base_y - dy - 1, 3, 3, 0, 0);
X    set_marker(canvas_win, t->base_x, t->base_y, 1, 1, 0, 0);
X    set_marker(canvas_win, t->base_x - 1, t->base_y - 1, 3, 3, 0, 0);
X}
X
Xtoggle_all_compoundmarkers()
X{
X    F_compound	   *c;
X    for (c=objects.compounds; c!=NULL ; c=c->next)
X	toggle_compoundmarker(c);
X}
X
Xtoggle_compoundmarker(c)
X    F_compound	   *c;
X{
X    set_line_stuff(1, RUBBER_LINE, 0.0, (INV_PAINT), DEFAULT_COLOR);
X    set_marker(canvas_win, c->nwcorner.x - 2, c->nwcorner.y - 2, 5, 5, 0, 0);
X    set_marker(canvas_win, c->secorner.x - 2, c->secorner.y - 2, 5, 5, 0, 0);
X    set_marker(canvas_win, c->nwcorner.x - 2, c->secorner.y - 2, 5, 5, 0, 0);
X    set_marker(canvas_win, c->secorner.x - 2, c->nwcorner.y - 2, 5, 5, 0, 0);
X    if (c->tagged)
X	toggle_compoundhighlight(c);
X}
X
Xtoggle_compoundhighlight(c)
X    F_compound	   *c;
X{
X    set_line_stuff(1, RUBBER_LINE, 0.0, (INV_PAINT), DEFAULT_COLOR);
X    set_marker(canvas_win, c->nwcorner.x, c->nwcorner.y, 1, 1, 0, 0);
X    set_marker(canvas_win, c->nwcorner.x - 1, c->nwcorner.y - 1, 3, 3, 0, 0);
X    set_marker(canvas_win, c->secorner.x, c->secorner.y, 1, 1, 0, 0);
X    set_marker(canvas_win, c->secorner.x - 1, c->secorner.y - 1, 3, 3, 0, 0);
X    set_marker(canvas_win, c->nwcorner.x, c->secorner.y, 1, 1, 0, 0);
X    set_marker(canvas_win, c->nwcorner.x - 1, c->secorner.y - 1, 3, 3, 0, 0);
X    set_marker(canvas_win, c->secorner.x, c->nwcorner.y, 1, 1, 0, 0);
X    set_marker(canvas_win, c->secorner.x - 1, c->nwcorner.y - 1, 3, 3, 0, 0);
X}
X
Xtoggle_linemarker(l)
X    F_line	   *l;
X{
X    F_point	   *p;
X    int		    fx, fy, x, y;
X
X    set_line_stuff(1, RUBBER_LINE, 0.0, (INV_PAINT), DEFAULT_COLOR);
X    p = l->points;
X    fx = p->x;
X    fy = p->y;
X    for (p = p->next; p != NULL; p = p->next) {
X	x = p->x;
X	y = p->y;
X	set_marker(canvas_win, x - 2, y - 2, 5, 5, 0, 0);
X    }
X    if (x != fx || y != fy || l->points->next == NULL) {
X	set_marker(canvas_win, fx - 2, fy - 2, 5, 5, 0, 0);
X    }
X    if (l->tagged)
X	toggle_linehighlight(l);
X}
X
Xtoggle_linehighlight(l)
X    F_line	   *l;
X{
X    F_point	   *p;
X    int		    fx, fy, x, y;
X
X    set_line_stuff(1, RUBBER_LINE, 0.0, (INV_PAINT), DEFAULT_COLOR);
X    p = l->points;
X    fx = p->x;
X    fy = p->y;
X    for (p = p->next; p != NULL; p = p->next) {
X	x = p->x;
X	y = p->y;
X	set_marker(canvas_win, x, y, 1, 1, 0, 0);
X	set_marker(canvas_win, x - 1, y - 1, 3, 3, 0, 0);
X    }
X    if (x != fx || y != fy) {
X	set_marker(canvas_win, fx, fy, 1, 1, 0, 0);
X	set_marker(canvas_win, fx - 1, fy - 1, 3, 3, 0, 0);
X    }
X}
X
Xtoggle_splinemarker(s)
X    F_spline	   *s;
X{
X    F_point	   *p;
X    int		    fx, fy, x, y;
X
X    set_line_stuff(1, RUBBER_LINE, 0.0, (INV_PAINT), DEFAULT_COLOR);
X    p = s->points;
X    fx = p->x;
X    fy = p->y;
X    for (p = p->next; p != NULL; p = p->next) {
X	x = p->x;
X	y = p->y;
X	set_marker(canvas_win, x - 2, y - 2, 5, 5, 0, 0);
X    }
X    if (x != fx || y != fy) {
X	set_marker(canvas_win, fx - 2, fy - 2, 5, 5, 0, 0);
X    }
X    if (s->tagged)
X	toggle_splinehighlight(s);
X}
X
Xtoggle_splinehighlight(s)
X    F_spline	   *s;
X{
X    F_point	   *p;
X    int		    fx, fy, x, y;
X
X    set_line_stuff(1, RUBBER_LINE, 0.0, (INV_PAINT), DEFAULT_COLOR);
X    p = s->points;
X    fx = p->x;
X    fy = p->y;
X    for (p = p->next; p != NULL; p = p->next) {
X	x = p->x;
X	y = p->y;
X	set_marker(canvas_win, x, y, 1, 1, 0, 0);
X	set_marker(canvas_win, x - 1, y - 1, 3, 3, 0, 0);
X    }
X    if (x != fx || y != fy) {
X	set_marker(canvas_win, fx, fy, 1, 1, 0, 0);
X	set_marker(canvas_win, fx - 1, fy - 1, 3, 3, 0, 0);
X    }
X}
END_OF_FILE
if test 13865 -ne `wc -c <'u_markers.c'`; then
    echo shar: \"'u_markers.c'\" unpacked with wrong size!
fi
# end of 'u_markers.c'
fi
if test -f 'w_export.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'w_export.c'\"
else
echo shar: Extracting \"'w_export.c'\" \(13679 characters\)
sed "s/^X//" >'w_export.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both the copyright
X * notice and this permission notice appear in supporting documentation. 
X * No representations are made about the suitability of this software for 
X * any purpose.  It is provided "as is" without express or implied warranty."
X */
X
X#include "fig.h"
X#include "figx.h"
X#include "mode.h"
X#include "resources.h"
X#include "w_dir.h"
X#include "w_drawprim.h"		/* for char_height */
X#include "w_setup.h"
X#include "w_util.h"
X
Xextern String	text_translations;
Xextern Widget	make_popup_menu();
Xextern char    *panel_get_value();
Xextern Widget	file_popup;
Xextern Widget	file_dir;
X
X/* global so w_file.c can access it */
Xchar		default_export_file[PATH_MAX];
Xchar		export_dir[PATH_MAX];
X
X/* LOCAL */
X
Xstatic String	file_name_translations =
X	"<Key>Return: ExportFile()\n";
Xvoid		do_export();
Xstatic XtActionsRec	file_name_actions[] =
X{
X    {"ExportFile", (XtActionProc) do_export},
X};
Xstatic String   export_translations =
X        "<Message>WM_PROTOCOLS: DismissExport()\n";
Xstatic void     export_panel_cancel();
Xstatic XtActionsRec     export_actions[] =
X{
X    {"DismissExport", (XtActionProc) export_panel_cancel},
X    {"cancel", (XtActionProc) export_panel_cancel},
X    {"export", (XtActionProc) do_export},
X};
X
Xstatic char	named_file[60];
X
Xstatic char    *orient_items[] = {
X    "Portrait ",
X    "Landscape"};
X
Xstatic char    *just_items[] = {
X    "Centered",
X    "Flush left"};
X
Xstatic void	orient_select();
Xstatic Widget	orient_panel, orient_menu, orient_lab;
X
Xstatic void	lang_select();
Xstatic Widget	lang_panel, lang_menu, lang_lab;
X
Xstatic void	just_select();
Xstatic Widget	just_panel, just_menu, just_lab;
X
Xstatic Widget	cancel_but, export_but;
Xstatic Widget	dfile_lab, dfile_text, nfile_lab;
Xstatic Widget	export_popup, mag_lab, mag_text, export_w;
Xstatic Position xposn, yposn;
X
X/* Global so w_dir.c can access us */
X
XWidget		export_panel,	/* so w_dir can access the scrollbars */
X		exp_selfile,	/* output (selected) file widget */
X		exp_mask,	/* mask widget */
X		exp_dir,	/* current directory widget */
X		exp_flist,	/* file list wiget */
X		exp_dlist;	/* dir list wiget */
X
XBoolean		export_up = False;
X
Xstatic void
Xexport_panel_dismiss()
X{
X    DeclareArgs(1);
X
X    FirstArg(XtNstring, "\0");
X    SetValues(exp_selfile);		/* clear ascii widget string */
X    XtPopdown(export_popup);
X    XtSetSensitive(export_w, True);
X    export_up = False;
X}
X
Xstatic void
Xexport_panel_cancel(w, ev)
X    Widget	    w;
X    XButtonEvent   *ev;
X{
X    export_panel_dismiss();
X}
X
Xstatic char	export_msg[] = "EXPORT";
X
Xvoid
Xdo_export(w)
X    Widget	    w;
X{
X	DeclareArgs(1);
X	float	    mag;
X	char	   *fval;
X
X	if (emptyfigure_msg(export_msg))
X		return;
X
X	if (!export_popup) 
X		create_export_panel(w);
X	FirstArg(XtNstring, &fval);
X	GetValues(exp_selfile);
X	if (emptyname(fval)) {		/* output filename is empty, use default */
X	    fval = default_export_file;
X	    warnexist = False;		/* don't warn if this file exists */
X	} else {
X	    warnexist = True;		/* otherwise warn if the file exists */
X	}
X
X	/* if not absolute path, change directory */
X	if (*fval != '/') {
X	    if (change_directory(export_dir) != 0)
X		return;
X	}
X
X	/* check for XBitmap first */
X	if (cur_exp_lang == LANG_XBITMAP) {
X	    XtSetSensitive(export_but, False);
X	    if (write_bitmap(fval) == 0)
X		{
X		FirstArg(XtNlabel, fval);
X		SetValues(dfile_text);		/* set the default filename */
X		if (strcmp(fval,default_export_file) != 0)
X		    strcpy(default_export_file,fval); /* and copy to default */
X		export_panel_dismiss();
X		}
X	    XtSetSensitive(export_but, True);
X	} else {
X	    mag = (float) atof(panel_get_value(mag_text)) / 100.0;
X	    if (mag <= 0.0)
X		mag = 1.0;
X	    XtSetSensitive(export_but, False);
X	    if (print_to_file(fval, lang_items[cur_exp_lang],
X			      mag, export_flushleft) == 0)
X		{
X		FirstArg(XtNlabel, fval);
X		SetValues(dfile_text);		/* set the default filename */
X		if (strcmp(fval,default_export_file) != 0)
X		    strcpy(default_export_file,fval); /* and copy to default */
X		export_panel_dismiss();
X		}
X	    XtSetSensitive(export_but, True);
X	}
X}
X
Xstatic void
Xorient_select(w, new_orient, garbage)
X    Widget	    w;
X    XtPointer	    new_orient, garbage;
X{
X    DeclareArgs(1);
X
X    FirstArg(XtNlabel, XtName(w));
X    SetValues(orient_panel);
X    print_landscape = (int) new_orient;
X}
X
Xstatic void
Xjust_select(w, new_just, garbage)
X    Widget	    w;
X    XtPointer	    new_just, garbage;
X{
X    DeclareArgs(1);
X
X    FirstArg(XtNlabel, XtName(w));
X    SetValues(just_panel);
X    export_flushleft = (new_just? True: False);
X}
X
Xstatic void
Xlang_select(w, new_lang, garbage)
X    Widget	    w;
X    XtPointer	    new_lang, garbage;
X{
X    DeclareArgs(1);
X
X    FirstArg(XtNlabel, XtName(w));
X    SetValues(lang_panel);
X    cur_exp_lang = (int) new_lang;
X    if (cur_exp_lang == LANG_XBITMAP) {
X	XtSetSensitive(mag_lab, False);
X	XtSetSensitive(mag_text, False);
X	XtSetSensitive(orient_lab, False);
X	XtSetSensitive(orient_panel, False);
X    } else {
X	XtSetSensitive(mag_lab, True);
X	XtSetSensitive(mag_text, True);
X	XtSetSensitive(orient_lab, True);
X	XtSetSensitive(orient_panel, True);
X    }
X
X    if (cur_exp_lang == LANG_PS) {
X	XtSetSensitive(just_lab, True);
X	XtSetSensitive(just_panel, True);
X    } else {
X	XtSetSensitive(just_lab, False);
X	XtSetSensitive(just_panel, False);
X    }
X
X    update_def_filename();
X    FirstArg(XtNlabel, default_export_file);
X    SetValues(dfile_text);
X}
X
Xpopup_export_panel(w)
X    Widget	    w;
X{
X	extern Atom wm_delete_window;
X
X	DeclareArgs(10);
X
X	set_temp_cursor(wait_cursor);
X	XtSetSensitive(w, False);
X	export_up = True;
X
X	if (!export_popup)
X		create_export_panel(w);
X
X	/* set the directory widget to the current export directory */
X	FirstArg(XtNstring, export_dir);
X	SetValues(exp_dir);
X
X	Rescan(0, 0, 0, 0);
X
X	FirstArg(XtNlabel, default_export_file);
X	NextArg(XtNwidth, 250);
X	SetValues(dfile_text);
X	XtPopup(export_popup, XtGrabNonexclusive);
X    	(void) XSetWMProtocols(XtDisplay(export_popup), XtWindow(export_popup),
X			       &wm_delete_window, 1);
X	reset_cursor();
X}
X
Xcreate_export_panel(w)
X    Widget	    w;
X{
X	Widget	    	beside, below;
X	PIX_FONT	temp_font;
X	DeclareArgs(10);
X
X	export_w = w;
X	XtTranslateCoords(w, (Position) 0, (Position) 0, &xposn, &yposn);
X
X	FirstArg(XtNx, xposn);
X	NextArg(XtNy, yposn + 50);
X	NextArg(XtNtitle, "Xfig: Export menu");
X	export_popup = XtCreatePopupShell("xfig_export_menu",
X					  transientShellWidgetClass,
X					  tool, Args, ArgCount);
X	XtOverrideTranslations(export_popup,
X			   XtParseTranslationTable(export_translations));
X	XtAppAddActions(tool_app, export_actions, XtNumber(export_actions));
X
X	export_panel = XtCreateManagedWidget("export_panel", formWidgetClass,
X					     export_popup, NULL, ZERO);
X
X	FirstArg(XtNlabel, "   Magnification%:");
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	mag_lab = XtCreateManagedWidget("mag_label", labelWidgetClass,
X					export_panel, Args, ArgCount);
X
X	FirstArg(XtNwidth, 40);
X	NextArg(XtNfromHoriz, mag_lab);
X	NextArg(XtNeditType, "edit");
X	NextArg(XtNstring, "100");
X	NextArg(XtNinsertPosition, 3);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	mag_text = XtCreateManagedWidget("magnification", asciiTextWidgetClass,
X					 export_panel, Args, ArgCount);
X	XtOverrideTranslations(mag_text,
X			   XtParseTranslationTable(text_translations));
X
X	FirstArg(XtNlabel, "      Orientation:");
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	NextArg(XtNfromVert, mag_text);
X	orient_lab = XtCreateManagedWidget("orient_label", labelWidgetClass,
X					   export_panel, Args, ArgCount);
X
X	FirstArg(XtNlabel, orient_items[print_landscape]);
X	NextArg(XtNfromHoriz, orient_lab);
X	NextArg(XtNfromVert, mag_text);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	orient_panel = XtCreateManagedWidget("orientation",
X					     menuButtonWidgetClass,
X					     export_panel, Args, ArgCount);
X	orient_menu = make_popup_menu(orient_items, XtNumber(orient_items),
X				      orient_panel, orient_select);
X
X	FirstArg(XtNlabel, "    Justification:");
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	NextArg(XtNfromVert, orient_panel);
X	just_lab = XtCreateManagedWidget("just_label", labelWidgetClass,
X					 export_panel, Args, ArgCount);
X
X	FirstArg(XtNlabel, just_items[export_flushleft? 1 : 0]);
X	NextArg(XtNfromHoriz, just_lab);
X	NextArg(XtNfromVert, orient_panel);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	NextArg(XtNresizable, True);
X	just_panel = XtCreateManagedWidget("justify",
X					   menuButtonWidgetClass,
X					   export_panel, Args, ArgCount);
X	just_menu = make_popup_menu(just_items, XtNumber(just_items),
X				    just_panel, just_select);
X
X	FirstArg(XtNlabel, "         Language:");
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	NextArg(XtNfromVert, just_panel);
X	lang_lab = XtCreateManagedWidget("lang_label", labelWidgetClass,
X					 export_panel, Args, ArgCount);
X
X	FirstArg(XtNlabel, lang_texts[cur_exp_lang]);
X	NextArg(XtNfromHoriz, lang_lab);
X	NextArg(XtNfromVert, just_panel);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	lang_panel = XtCreateManagedWidget("language",
X					   menuButtonWidgetClass,
X					   export_panel, Args, ArgCount);
X	lang_menu = make_popup_menu(lang_texts, XtNumber(lang_texts),
X				    lang_panel, lang_select);
X
X	FirstArg(XtNlabel, " Default Filename:");
X	NextArg(XtNfromVert, lang_panel);
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	dfile_lab = XtCreateManagedWidget("def_file_label", labelWidgetClass,
X					  export_panel, Args, ArgCount);
X
X	FirstArg(XtNlabel, default_export_file);
X	NextArg(XtNfromVert, lang_panel);
X	NextArg(XtNfromHoriz, dfile_lab);
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	NextArg(XtNwidth, 250);
X	dfile_text = XtCreateManagedWidget("def_file_name", labelWidgetClass,
X					   export_panel, Args, ArgCount);
X
X	FirstArg(XtNlabel, "  Output Filename:");
X	NextArg(XtNfromVert, dfile_text);
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	nfile_lab = XtCreateManagedWidget("out_file_name", labelWidgetClass,
X					  export_panel, Args, ArgCount);
X
X	FirstArg(XtNfont, &temp_font);
X	GetValues(nfile_lab);
X
X	FirstArg(XtNwidth, 350);
X	NextArg(XtNheight, char_height(temp_font) * 2 + 4);
X	NextArg(XtNfromHoriz, nfile_lab);
X	NextArg(XtNfromVert, dfile_text);
X	NextArg(XtNeditType, "edit");
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	NextArg(XtNstring, named_file);
X	NextArg(XtNinsertPosition, strlen(named_file));
X	NextArg(XtNscrollHorizontal, XawtextScrollWhenNeeded);
X	exp_selfile = XtCreateManagedWidget("file", asciiTextWidgetClass,
X					    export_panel, Args, ArgCount);
X	XtOverrideTranslations(exp_selfile,
X			   XtParseTranslationTable(text_translations));
X
X	/* add action to export file for following translation */
X	XtAppAddActions(tool_app, file_name_actions, XtNumber(file_name_actions));
X
X	/* make <return> in the filename window export the file */
X	XtOverrideTranslations(exp_selfile,
X			   XtParseTranslationTable(file_name_translations));
X
X	create_dirinfo(export_panel, exp_selfile, &beside, &below,
X		       &exp_mask, &exp_dir, &exp_flist, &exp_dlist);
X	/* make <return> in the file list window export the file */
X	XtOverrideTranslations(exp_flist,
X			   XtParseTranslationTable(file_name_translations));
X
X	FirstArg(XtNlabel, "Cancel");
X	NextArg(XtNfromHoriz, beside);
X	NextArg(XtNfromVert, below);
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNhorizDistance, 25);
X	NextArg(XtNheight, 25);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	cancel_but = XtCreateManagedWidget("cancel", commandWidgetClass,
X					   export_panel, Args, ArgCount);
X	XtAddEventHandler(cancel_but, ButtonReleaseMask, (Boolean) 0,
X			  (XtEventHandler)export_panel_cancel, (XtPointer) NULL);
X
X	FirstArg(XtNlabel, "Export");
X	NextArg(XtNfromVert, below);
X	NextArg(XtNfromHoriz, cancel_but);
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNhorizDistance, 25);
X	NextArg(XtNheight, 25);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	export_but = XtCreateManagedWidget("export", commandWidgetClass,
X					   export_panel, Args, ArgCount);
X	XtAddEventHandler(export_but, ButtonReleaseMask, (Boolean) 0,
X			  (XtEventHandler)do_export, (XtPointer) NULL);
X
X	XtInstallAccelerators(export_panel, cancel_but);
X	XtInstallAccelerators(export_panel, export_but);
X
X	if (cur_exp_lang == LANG_XBITMAP) {
X	    XtSetSensitive(mag_lab, False);
X	    XtSetSensitive(mag_text, False);
X	    XtSetSensitive(orient_lab, False);
X	    XtSetSensitive(orient_panel, False);
X	}
X	if (cur_exp_lang != LANG_PS) {
X	    XtSetSensitive(just_lab, False);
X	    XtSetSensitive(just_panel, False);
X	}
X	update_def_filename();
X}
X
Xupdate_def_filename()
X{
X    int		    i;
X    DeclareArgs(1);
X    char	   *dval;
X
X    (void) strcpy(default_export_file, cur_filename);
X    if (default_export_file[0] != '\0') {
X	i = strlen(default_export_file);
X	if (i >= 4 && strcmp(&default_export_file[i - 4], ".fig") == 0)
X	    default_export_file[i - 4] = '\0';
X	(void) strcat(default_export_file, ".");
X	(void) strcat(default_export_file, lang_items[cur_exp_lang]);
X    }
X    /* remove trailing blanks */
X    for (i = strlen(default_export_file) - 1; i >= 0; i--)
X	if (default_export_file[i] == ' ')
X	    default_export_file[i] = '\0';
X	else
X	    i = 0;
X    /* set the current directory from the file popup directory */
X    if (file_popup) {
X	FirstArg(XtNstring, &dval);
X	GetValues(file_dir);
X	strcpy(export_dir,dval);
X    }
X}
END_OF_FILE
if test 13679 -ne `wc -c <'w_export.c'`; then
    echo shar: \"'w_export.c'\" unpacked with wrong size!
fi
# end of 'w_export.c'
fi
if test -f 'w_modepanel.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'w_modepanel.c'\"
else
echo shar: Extracting \"'w_modepanel.c'\" \(13698 characters\)
sed "s/^X//" >'w_modepanel.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1991 by Paul King
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both the copyright
X * notice and this permission notice appear in supporting documentation. 
X * No representations are made about the suitability of this software for 
X * any purpose.  It is provided "as is" without express or implied warranty."
X */
X
X#include "fig.h"
X#include "figx.h"
X#include "resources.h"
X#include "mode.h"
X#include "object.h"
X#include "paintop.h"
X#include "w_drawprim.h"
X#include "w_icons.h"
X#include "w_indpanel.h"
X#include "w_util.h"
X#include "w_mousefun.h"
X#include "w_setup.h"
X
Xextern          finish_text_input();
Xextern          erase_objecthighlight();
X
Xextern          circlebyradius_drawing_selected();
Xextern          circlebydiameter_drawing_selected();
Xextern          ellipsebyradius_drawing_selected();
Xextern          ellipsebydiameter_drawing_selected();
Xextern          box_drawing_selected();
Xextern          arcbox_drawing_selected();
Xextern          line_drawing_selected();
Xextern          regpoly_drawing_selected();
Xextern          epsobj_drawing_selected();
Xextern          text_drawing_selected();
Xextern          arc_drawing_selected();
Xextern          spline_drawing_selected();
Xextern          intspline_drawing_selected();
Xextern          align_selected();
Xextern          compound_selected();
Xextern          break_selected();
Xextern          scale_selected();
Xextern          point_adding_selected();
Xextern          delete_point_selected();
Xextern          move_selected();
Xextern          move_point_selected();
Xextern          delete_selected();
Xextern          copy_selected();
Xextern          rotate_cw_selected();
Xextern          rotate_ccw_selected();
Xextern          flip_ud_selected();
Xextern          flip_lr_selected();
Xextern          convert_selected();
Xextern          arrow_head_selected();
Xextern          edit_item_selected();
Xextern          update_selected();
X
X/**************	    local variables and routines   **************/
X
X#define MAX_MODEMSG_LEN 80
Xtypedef struct mode_switch_struct {
X    PIXRECT         icon;
X    int             mode;
X    int             (*setmode_func) ();
X    int             objmask;
X    int             indmask;
X    char            modemsg[MAX_MODEMSG_LEN];
X    TOOL            widget;
X    Pixmap          normalPM, reversePM;
X}               mode_sw_info;
X
X#define		setmode_action(z)    (z->setmode_func)(z)
X
XDeclareStaticArgs(13);
X/* pointer to current mode switch */
Xstatic mode_sw_info *current = NULL;
X
X/* button selection event handler */
Xstatic void     sel_mode_but();
Xstatic void     turn_on();
X
Xstatic mode_sw_info mode_switches[] = {
X    {&cirrad_ic, F_CIRCLE_BY_RAD, circlebyradius_drawing_selected, M_NONE,
X    I_BOX, "CIRCLE drawing: specify RADIUS",},
X    {&cirdia_ic, F_CIRCLE_BY_DIA, circlebydiameter_drawing_selected, M_NONE,
X    I_BOX, "CIRCLE drawing: specify DIAMETER",},
X    {&ellrad_ic, F_ELLIPSE_BY_RAD, ellipsebyradius_drawing_selected, M_NONE,
X    I_ELLIPSE, "ELLIPSE drawing: specify RADII",},
X    {&elldia_ic, F_ELLIPSE_BY_DIA, ellipsebydiameter_drawing_selected, M_NONE,
X    I_ELLIPSE, "ELLIPSE drawing: specify DIAMETERS",},
X    {&c_spl_ic, F_CLOSED_SPLINE, spline_drawing_selected, M_NONE,
X    I_CLOSED, "CLOSED SPLINE drawing: specify control points",},
X    {&spl_ic, F_SPLINE, spline_drawing_selected, M_NONE,
X    I_OPEN, "SPLINE drawing: specify control points",},
X    {&c_intspl_ic, F_CLOSED_INTSPLINE, intspline_drawing_selected, M_NONE,
X    I_CLOSED, "CLOSED INTERPOLATED SPLINE drawing",},
X    {&intspl_ic, F_INTSPLINE, intspline_drawing_selected, M_NONE,
X    I_OPEN, "INTERPOLATED SPLINE drawing",},
X    {&polygon_ic, F_POLYGON, line_drawing_selected, M_NONE,
X    I_CLOSED, "POLYGON drawing",},
X    {&line_ic, F_POLYLINE, line_drawing_selected, M_NONE,
X    I_OPEN, "POLYLINE drawing",},
X    {&box_ic, F_BOX, box_drawing_selected, M_NONE,
X    I_BOX, "Rectangular BOX drawing",},
X    {&arc_box_ic, F_ARC_BOX, arcbox_drawing_selected, M_NONE,
X    I_ARCBOX, "Rectangular BOX drawing with ROUNDED CORNERS",},
X    {&regpoly_ic, F_REGPOLY, regpoly_drawing_selected, M_NONE,
X    I_REGPOLY, "Regular Polygon",},
X    {&arc_ic, F_CIRCULAR_ARC, arc_drawing_selected, M_NONE,
X    I_ARC, "ARC drawing: specify three points on the arc",},
X    {&epsobj_ic, F_EPSOBJ, epsobj_drawing_selected, M_NONE,
X    I_EPSOBJ, "Encapsulated Postscript Object",},
X    {&text_ic, F_TEXT, text_drawing_selected, M_TEXT_NORMAL,
X    I_TEXT, "TEXT input (from keyboard)",},
X    {&glue_ic, F_GLUE, compound_selected, M_ALL,
X    I_MIN2, "GLUE objects into COMPOUND object",},
X    {&break_ic, F_BREAK, break_selected, M_COMPOUND,
X    I_MIN1, "BREAK COMPOUND object",},
X    {&scale_ic, F_SCALE, scale_selected, M_NO_TEXT,
X    I_MIN2, "SCALE objects",},
X    {&align_ic, F_ALIGN, align_selected, M_COMPOUND,
X    I_ALIGN, "ALIGN objects within a COMPOUND or to CANVAS",},
X    {&movept_ic, F_MOVE_POINT, move_point_selected, M_NO_TEXT,
X    I_ADDMOVPT, "MOVE POINTs",},
X    {&move_ic, F_MOVE, move_selected, M_ALL,
X    I_MIN3, "MOVE objects",},
X    {&addpt_ic, F_ADD_POINT, point_adding_selected, M_VARPTS_OBJECT,
X    I_ADDMOVPT, "ADD POINTs (to lines, polygons and splines)",},
X    {&copy_ic, F_COPY, copy_selected, M_ALL,
X    I_MIN3, "COPY objects",},
X    {&deletept_ic, F_DELETE_POINT, delete_point_selected, M_VARPTS_OBJECT,
X    I_MIN1, "DELETE POINTs (from lines, polygons and splines)",},
X    {&delete_ic, F_DELETE, delete_selected, M_ALL,
X    I_MIN1, "DELETE objects",},
X    {&update_ic, F_UPDATE, update_selected, M_ALL,
X    I_OBJECT, "UPDATE object <-> current settings",},
X    {&change_ic, F_EDIT, edit_item_selected, M_ALL,
X    I_MIN1, "CHANGE OBJECT via EDIT pane",},
X    {&flip_x_ic, F_FLIP, flip_ud_selected, M_NO_TEXT,
X    I_MIN1, "FLIP objects up or down",},
X    {&flip_y_ic, F_FLIP, flip_lr_selected, M_NO_TEXT,
X    I_MIN1, "FLIP objects left or right",},
X    {&rotCW_ic, F_ROTATE, rotate_cw_selected, M_ALL,
X    I_ROTATE, "ROTATE objects clockwise",},
X    {&rotCCW_ic, F_ROTATE, rotate_ccw_selected, M_ALL,
X    I_ROTATE, "ROTATE objects counter-clockwise",},
X    {&convert_ic, F_CONVERT, convert_selected,
X	(M_POLYLINE_LINE | M_POLYLINE_POLYGON | M_SPLINE_INTERP), I_MIN1,
X    "CONVERT lines (polygons) into splines (closed-splines) or vice versa",},
X    {&autoarrow_ic, F_AUTOARROW, arrow_head_selected, M_OPEN_OBJECT,
X    I_MIN1 | I_LINEWIDTH, "ADD/DELETE ARROWs",},
X};
X
X#define		NUM_MODE_SW	(sizeof(mode_switches) / sizeof(mode_sw_info))
X
Xstatic Arg      button_args[] =
X{
X     /* 0 */ {XtNlabel, (XtArgVal) "    "},
X     /* 1 */ {XtNwidth, (XtArgVal) 0},
X     /* 2 */ {XtNheight, (XtArgVal) 0},
X     /* 3 */ {XtNresizable, (XtArgVal) False},
X     /* 4 */ {XtNborderWidth, (XtArgVal) 0},
X     /* 5 */ {XtNresize, (XtArgVal) False},	/* keeps buttons from being
X						 * resized when there are not
X						 * a multiple of three of
X						 * them */
X     /* 6 */ {XtNbackgroundPixmap, (XtArgVal) NULL},
X};
X
Xstatic XtActionsRec mode_actions[] =
X{
X    {"EnterModeSw", (XtActionProc) draw_mousefun_mode},
X    {"LeaveModeSw", (XtActionProc) clear_mousefun},
X    {"PressMiddle", (XtActionProc) notused_middle},
X    {"ReleaseMiddle", (XtActionProc) clear_middle},
X    {"PressRight", (XtActionProc) notused_right},
X    {"ReleaseRight", (XtActionProc) clear_right},
X};
X
Xstatic String   mode_translations =
X"<EnterWindow>:EnterModeSw()highlight()\n\
X    <Btn1Down>:\n\
X    <Btn1Up>:\n\
X    <Btn2Down>:PressMiddle()\n\
X    <Btn2Up>:ReleaseMiddle()\n\
X    <Btn3Down>:PressRight()\n\
X    <Btn3Up>:ReleaseRight()\n\
X    <LeaveWindow>:LeaveModeSw()unhighlight()\n";
X
Xint
Xinit_mode_panel(tool)
X    TOOL            tool;
X{
X    register int    i;
X    register mode_sw_info *sw;
X
X    FirstArg(XtNwidth, MODEPANEL_WD);
X    NextArg(XtNhSpace, INTERNAL_BW);
X    NextArg(XtNvSpace, INTERNAL_BW);
X    NextArg(XtNtop, XtChainTop);
X    NextArg(XtNbottom, XtChainTop);
X    NextArg(XtNfromVert, msg_form);
X    NextArg(XtNvertDistance, -INTERNAL_BW);
X    NextArg(XtNleft, XtChainLeft);
X    NextArg(XtNright, XtChainLeft);
X    NextArg(XtNresizable, False);
X    NextArg(XtNborderWidth, 0);
X    NextArg(XtNmappedWhenManaged, False);
X
X    mode_panel = XtCreateWidget("mode_panel", boxWidgetClass, tool,
X				Args, ArgCount);
X
X    XtAppAddActions(tool_app, mode_actions, XtNumber(mode_actions));
X
X    for (i = 0; i < NUM_MODE_SW; ++i) {
X	sw = &mode_switches[i];
X	if (sw->mode == FIRST_DRAW_MODE) {
X	    FirstArg(XtNwidth, MODE_SW_WD * SW_PER_ROW +
X		     INTERNAL_BW * (SW_PER_ROW - 1));
X	    NextArg(XtNborderWidth, 0);
X	    NextArg(XtNresize, False);
X	    NextArg(XtNheight, (MODEPANEL_SPACE + 1) / 2);
X	    NextArg(XtNlabel, "Drawing\n modes");
X	    d_label = XtCreateManagedWidget("label", labelWidgetClass,
X					    mode_panel, Args, ArgCount);
X	} else if (sw->mode == FIRST_EDIT_MODE) {
X	    /* assume Args still set up from d_label */
X	    ArgCount -= 2;
X	    NextArg(XtNheight, (MODEPANEL_SPACE) / 2);
X	    NextArg(XtNlabel, "Editing\n modes");
X	    e_label = XtCreateManagedWidget("label", labelWidgetClass,
X					    mode_panel, Args, ArgCount);
X	}
X	button_args[1].value = sw->icon->width;
X	button_args[2].value = sw->icon->height;
X	sw->widget = XtCreateManagedWidget("button", commandWidgetClass,
X			    mode_panel, button_args, XtNumber(button_args));
X
X	/* left button changes mode */
X	XtAddEventHandler(sw->widget, ButtonPressMask, (Boolean) 0,
X			  sel_mode_but, (XtPointer) sw);
X	XtOverrideTranslations(sw->widget,
X			       XtParseTranslationTable(mode_translations));
X    }
X    return;
X}
X
X/*
X * after panel widget is realized (in main) put some bitmaps etc. in it
X */
X
Xsetup_mode_panel()
X{
X    register int    i;
X    register mode_sw_info *msw;
X    register Display *d = tool_d;
X    register Screen *s = tool_s;
X
X    blank_gc = XCreateGC(tool_d, XtWindow(mode_panel), (unsigned long) 0, NULL);
X    button_gc = XCreateGC(tool_d, XtWindow(mode_panel), (unsigned long) 0, NULL);
X    FirstArg(XtNforeground, &but_fg);
X    NextArg(XtNbackground, &but_bg);
X    GetValues(mode_switches[0].widget);
X
X    XSetBackground(tool_d, blank_gc, but_bg);
X    XSetForeground(tool_d, blank_gc, but_bg);
X
X    FirstArg(XtNfont, button_font);
X    SetValues(d_label);
X    SetValues(e_label);
X
X    if (appres.INVERSE) {
X	FirstArg(XtNbackground, WhitePixelOfScreen(tool_s));
X    } else {
X	FirstArg(XtNbackground, BlackPixelOfScreen(tool_s));
X    }
X    SetValues(mode_panel);
X
X    for (i = 0; i < NUM_MODE_SW; ++i) {
X	msw = &mode_switches[i];
X	/* create normal bitmaps */
X	msw->normalPM = XCreatePixmapFromBitmapData(d, XtWindow(msw->widget),
X		       (char *) msw->icon->data, msw->icon->width, msw->icon->height,
X				   but_fg, but_bg, DefaultDepthOfScreen(s));
X
X	FirstArg(XtNbackgroundPixmap, msw->normalPM);
X	SetValues(msw->widget);
X
X	/* create reverse bitmaps */
X	msw->reversePM = XCreatePixmapFromBitmapData(d, XtWindow(msw->widget),
X		       (char *) msw->icon->data, msw->icon->width, msw->icon->height,
X				   but_bg, but_fg, DefaultDepthOfScreen(s));
X	/* install the accelerators in the buttons */
X	XtInstallAllAccelerators(msw->widget, tool);
X    }
X    /* install the accelerators for the surrounding parts */
X    XtInstallAllAccelerators(mode_panel, tool);
X    XtInstallAllAccelerators(d_label, tool);
X    XtInstallAllAccelerators(e_label, tool);
X
X    XDefineCursor(d, XtWindow(mode_panel), arrow_cursor);
X    FirstArg(XtNmappedWhenManaged, True);
X    SetValues(mode_panel);
X}
X
X/* come here when a button is pressed in the mode panel */
X
Xstatic void
Xsel_mode_but(widget, closure, event, continue_to_dispatch)
X    Widget          widget;
X    XtPointer	    closure;
X    XEvent*	    event;
X    Boolean*	    continue_to_dispatch;
X{
X    XButtonEvent    xbutton;
X    mode_sw_info    *msw = (mode_sw_info *) closure;
X    int             new_objmask;
X
X    xbutton = event->xbutton;
X    if (action_on) {
X	if (cur_mode == F_TEXT)
X	    finish_text_input();/* finish up any text input */
X	else {
X	    put_msg("Please finish (or cancel) the current operation before changing modes");
X	    return;
X	}
X    } else if (highlighting)
X	erase_objecthighlight();
X    if (xbutton.button == Button1) {	/* left button */
X	turn_off_current();
X	turn_on(msw);
X	/* turn off the update boxes if not in update mode */
X	if (msw->mode != F_UPDATE)
X		unmanage_update_buts();
X	update_indpanel(msw->indmask);
X	put_msg(msw->modemsg);
X	if ((cur_mode == F_GLUE || cur_mode == F_BREAK) &&
X	    msw->mode != F_GLUE &&
X	    msw->mode != F_BREAK)
X	    /*
X	     * reset tagged items when changing modes, perhaps this is not
X	     * really necessary
X	     */
X	    set_tags(&objects, 0);
X	cur_mode = msw->mode;
X	anypointposn = !(msw->indmask & I_POINTPOSN);
X	new_objmask = msw->objmask;
X	if (cur_mode == F_ROTATE && cur_rotnangle != 90)
X	    new_objmask = M_ROTATE_ANGLE;
X	update_markers(new_objmask);
X	current = msw;
X	setmode_action(msw);
X    }
X}
X
Xvoid
Xforce_positioning()
X{
X    update_indpanel(current->indmask | I_POINTPOSN);
X    anypointposn = 0;
X}
X
Xvoid
Xforce_nopositioning()
X{
X    update_indpanel(current->indmask & ~I_POINTPOSN);
X    anypointposn = 1;
X}
X
Xvoid
Xforce_anglegeom()
X{
X    update_indpanel(current->indmask | I_ANGLEGEOM);
X}
X
Xvoid
Xforce_noanglegeom()
X{
X    update_indpanel(current->indmask & ~I_ANGLEGEOM);
X}
X
Xstatic void
Xturn_on(msw)
X    mode_sw_info   *msw;
X{
X    FirstArg(XtNbackgroundPixmap, msw->reversePM);
X    SetValues(msw->widget);
X}
X
Xturn_on_current()
X{
X    if (current)
X	turn_on(current);
X}
X
Xturn_off_current()
X{
X    if (current) {
X	FirstArg(XtNbackgroundPixmap, current->normalPM);
X	SetValues(current->widget);
X    }
X}
END_OF_FILE
if test 13698 -ne `wc -c <'w_modepanel.c'`; then
    echo shar: \"'w_modepanel.c'\" unpacked with wrong size!
fi
# end of 'w_modepanel.c'
fi
echo shar: End of archive 11 \(of 27\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 27 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM       | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@imd.sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
