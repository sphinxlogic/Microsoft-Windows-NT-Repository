Newsgroups: comp.sources.x
From: envbvs@epb9.lbl.gov (Brian V. Smith)
Subject: v19i119:  xfig - Draw amd manipulate objects in an X-Window, Part07/27
Message-ID: <1993May21.021333.5385@sparky.imd.sterling.com>
X-Md4-Signature: 2cee93581fd2d0d2f5ceef732e45f391
Sender: chris@sparky.imd.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Fri, 21 May 1993 02:13:33 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: envbvs@epb9.lbl.gov (Brian V. Smith)
Posting-number: Volume 19, Issue 119
Archive-name: xfig/part07
Environment: X11
Supersedes: xfig: Volume 16, Issue 6-30,39

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 7 (of 27)."
# Contents:  Doc/FORMAT2.1 Examples/houseD.fig.uu Examples/lists.fig.uu
#   Examples/roundboxes2.fig.uu d_ellipse.c object.h u_geom.c
# Wrapped by envbvs@epb9.lbl.gov.lbl.gov on Mon May  3 12:05:50 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Doc/FORMAT2.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Doc/FORMAT2.1'\"
else
echo shar: Extracting \"'Doc/FORMAT2.1'\" \(8354 characters\)
sed "s/^X//" >'Doc/FORMAT2.1' <<'END_OF_FILE'
XThe following is the format of fig output (fig 2.1).
X
X(1) The very first line is a comment line containing the name and version:
X	#FIG 2.1
X
X    The character # at the first column of a line indicates that the line
X    is a comment line which will be ignored.
X
X(2) The first non-comment line consists of two numbers :
X
X	int	fig_resolution		(pixels/inch)
X	int	coordinate_system	(1 : origin is at the lower left corner
X					 2 : Upper left)
X
X    Fig_resolution is the resolution fig is using for the current file.
X    It must always be 80 for compatibility with this version of Fig.
X    Pixels are assumed to be square.
X
X(3) The rest of the file contains various objects.  An object can be one
X    of six classes (or types).
X
X	  i)	Arc.
X	 ii)	Ellipse which is a generalization of circle.
X	iii)	Polyline which includes polygon and box.
X	 iv)	Spline which includes closed/open control/interpolated spline.
X	  v)	Text.
X	 vi)	Compound object which is composed of one or more objects.
X
X    In the following elaboration on object formats, every value of fig
X    output are separated by blank characters or new line ('\n').  The
X    value of the not-used parameters will be -1.
X
X    Some fields are described as "enumeration type" or "bit vector"; the 
X    values which these fields can take are defined in the header file object.h.
X    The pen, arrow_type, and arrow_style fields are described as unused.
X    These values may be defined in some future version of Fig.
X
X    The color field is defined as follows:
X
X	-1 = Default
X	 0 = Black
X	 1 = Blue
X	 2 = Green
X	 3 = Cyan
X	 4 = Red
X	 5 = Magenta
X	 6 = Yellow
X	 7 = White
X	 values from 8 to 2^30-1 = reserved for future use
X
X    The depth field is defined as follows:
X
X	 0 ... 999 where larger value means object is deeper than (under)
X		   objects with smaller depth
X
X    The area fill field is defined as follows:
X	
X	 0 = not filled
X	 1 = white
X	...  values from 2 to 20 are shades of grey, from lighter to darker
X	21 = black
X
X    The line_style field is defined as follows:
X
X	-1 = Default
X	 0 = Solid
X	 1 = Dashed
X	 2 = Dotted
X
X    The style_val field is defined as the length, in pixels, of the on/off dashes
X    for dashed lines, and the distance between the dots, in pixels, for dotted lines
X 
X    (3.1) ARC
X
X    First line :
X	type	name			(brief description)
X	----	----			-------------------
X	int	object_code		(always 5)
X	int	sub_type		(always	1)
X	int	line_style		(enumeration type)
X	int	line_thickness		(pixels)
X	int	color			(enumeration type)
X	int	depth			(no units)
X	int	pen			(not used)
X	int	area_fill		(enumeration type)
X	float	style_val		(pixels)
X	int	direction		(0 : clockwise, 1 : counterclockwise)
X	int	forward_arrow		(0: no forward arrow, 1: on)
X	int	backward_arrow		(0: no forward arrow, 1: on)
X	float	center_x, center_y	(center of the arc)
X	int	x1, y1			(pixels, the 1st point the user entered)
X	int	x2, y2			(pixels, the 2nd point)
X	int	x3, y3			(pixels, the last point)
X
X    Forward arrow line (Optional; absent if forward_arrow is 0) :
X	type	name			(brief description)
X	----	----			-------------------
X	int	arrow_type		(not used)
X	int	arrow_style		(not used)
X	float	arrow_thickness		(pixels)
X	float 	arrow_width		(pixels)
X	float	arrow_height		(pixels)
X
X    Backward arrow line (Optional; absent if backward_arrow is 0) :
X	type	name			(brief description)
X	----	----			-------------------
X	int	arrow_type		(not used)
X	int	arrow_style		(not used)
X	float	arrow_thickness		(pixels)
X	float	arrow_width		(pixels)
X	float	arrow_height		(pixels)
X
X    (3.2) COMPOUND
X
X    A line with object code 6 signifies the start of a compound.
X    There are four more numbers on this line which indicate the
X    upper right corner and the lower left corner of the bounding
X    box of this compound.  A line with object code -6 signifies
X    the end of the compound.  Compound may be nested.
X
X    First line :
X	type	name			(brief description)
X	----	----			-------------------
X	int	object_code		(always 6)
X	int	upperright_corner_x	(pixels)
X	int	upperright_corner_y	(pixels)
X	int	lowerleft_corner_x	(pixels)
X	int	lowerleft_corner_y	(pixels)
X
X    Subsequent lines :
X	objects
X	.
X	.
X
X    Last line :
X	-6
X
X    (3.3) ELLIPSE
X
X    First line :
X	type	name			(brief description)
X	----	----			-------------------
X	int	object_code		(always 1)
X	int	sub_type		(1 : ellipse defined by radiuses
X					 2 : ellipse defined by diameters
X					 3 : circle defined by radius
X					 4 : circle defined by diameter)
X	int	line_style		(enumeration type)
X	int	thickness		(pixels)
X	int	color			(enumeration type)
X	int	depth			(no units)
X	int	pen			(not used)
X	int	area_fill		(enumeration type)
X	float	style_val		(pixels)
X	int	direction		(always 1)
X	float	angle			(radians, the angle of the x-axis)
X	int	center_x, center_y	(pixels)
X	int	radius_x, radius_y	(pixels)
X	int	start_x, start_y	(pixels; the 1st point entered)
X	int	end_x, end_y		(pixels; the last point entered)
X
X    (3.4) POLYLINE
X
X    First line :
X	type	name			(brief description)
X	----	----			-------------------
X	int	object_code		(always 2)
X	int	sub_type		(1 : polyline
X					 2 : box
X					 3 : polygon
X					 4 : arc-box)
X					 5 : imported-eps bounding-box)
X	int	line_style		(enumeration type)
X	int	thickness		(pixels)
X	int	color			(enumeration type)
X	int	depth			(no units)
X	int	pen			(not used)
X	int	area_fill		(enumeration type)
X	float	style_val		(pixels)
X	int	radius			(pixels)
X	int	forward_arrow		(0: off, 1: on)
X	int	backward_arrow		(0: off, 1: on)
X
X    Forward arrow line : same as ARC object
X
X    Backward arrow line : same as ARC object
X
X    Points line :
X	type	name			(brief description)
X	----	----			-------------------
X	int	x1, y1			(pixels)
X	int	x2, y2			(pixels)
X	  .
X	  .
X	int	xn, yn			(this will be the same as the 1st
X					point for polygon and box)
X	int	x, y			(always 9999, 9999; marks the end of
X					point for polygon and box)
X
X    EPS line :
X	type	name			(brief description)
X	----	----			-------------------
X	boolean	flipped			orientation = normal (0) or flipped (1)
X	char	file[]			name of eps file to import
X
X    (3.5) SPLINE
X
X    First line :
X	type	name			(brief description)
X	----	----			-------------------
X	int	object_code		(always 3)
X	int	sub_type		(0 : open spline
X					 1 : closed spline
X					 2 : open interpolated spline
X					 3 : closed interpolated spline)
X	int	line_style		(See the end of this section)
X	int	thickness		(pixels)
X	int	color			(enumeration type)
X	int	depth			(no units)
X	int	pen			(not used)
X	int	area_fill		(enumeration type)
X	float	style_val		(pixels)
X	int	forward_arrow		(0: off, 1: on)
X	int	backward_arrow		(0: off, 1: on)
X
X    Forward arrow line : same as ARC object
X
X    Backward arrow line : same as ARC object
X
X    Points line : same as POLYLINE object
X
X    Control points line (absent if sub_type is 1 or 2) :
X	Control points of interpolated spline.  There are two control
X	points for each knots.  A section i, of the spline is drawn
X	using Bezier cubic with the following four points:
X		(x ,y ), (rx ,ry ), (lx	  , ly   ), (x   , y   ).
X		  i  i	    i	i      i+1    i+1     i+1   i+1
X	For closed interpolated spline the last pair of control points,
X	(lxn,lyn) and (rxn,ryn) (which can be ignored), are the same as
X	(lx1,ly1) and (rx1,ry1) respectively.
X
X	type	name			(brief description)
X	----	----			-------------------
X	float	lx1, ly1		(pixels)
X	float	rx1, ry1		(pixels)
X	float	lx2, ly2		(pixels)
X	float	rx2, ry2		(pixels)
X	  .
X	  .
X	float	lxn, lyn		(pixels)
X	float	rxn, ryn		(pixels)
X
X    (3.6) TEXT
X	type	name			(brief description)
X	----	----			-------------------
X	int	object 			(always 4)
X	int	sub_type		(0 : Left justified
X					 1 : Center justified
X					 2 : Right justified)
X	int	font 			(enumeration type)
X	int	font_size 		(points)
X	int	pen			(not used)
X	int	color			(enumeration type)
X	int	depth			(no units)
X	float	angle			(radians, the angle of the text)
X	int	font_flags		(bit vector)
X	int	height			(pixels)
X	int	length			(pixels)
X	int	x, y			(pixels, coordinate of the origin
X					 of the string.  If sub_type = 0, it is
X					 the lower left corner of the string.
X					 If sub_type = 1, it is the lower
X					 center.  Otherwise it is the lower
X					 right corner of the string.)
X	char	string[]		(ascii characters; starts after a blank
X					character following the last number and
X					ends before the character '\1'.  This
X					character is not part of the string.
X					Note that the string may contain '\n'.)
END_OF_FILE
if test 8354 -ne `wc -c <'Doc/FORMAT2.1'`; then
    echo shar: \"'Doc/FORMAT2.1'\" unpacked with wrong size!
fi
# end of 'Doc/FORMAT2.1'
fi
if test -f 'Examples/houseD.fig.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Examples/houseD.fig.uu'\"
else
echo shar: Extracting \"'Examples/houseD.fig.uu'\" \(8465 characters\)
sed "s/^X//" >'Examples/houseD.fig.uu' <<'END_OF_FILE'
Xbegin 444 houseD.fig
XM(T9)1R`R+C$*.#`@,@HU(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#$@,"`P(#(V
XM.2XV-3@@,C(Y+C8U."`R-CD@,C<T(#,P,B`R-C`@,S$T(#(R.0HU(#$@,"`Q
XM("TQ(#`@,"`P(#`N,#`P(#`@,"`P(#$Y-BXW,#`@,C`Q+C<P,"`R,30@,C`T
XM(#(Q,"`R,3,@,3DY(#(Q.0HQ(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#$@,"XP
XM,#`@,S,Y(#$W-2`Q,2`Q-B`S,SD@,3<U(#,T.2`Q.3`*,2`Q(#`@,2`M,2`P
XM(#`@,"`P+C`P,"`Q(#`N,#`P(#,S."`Q,S`@,3$@,38@,S,X(#$S,"`S-#@@
XM,30U"C$@,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P+C`P,"`R,C8@,3(Q(#$Q
XM(#$U(#(Q-R`Q,S@@,C,W(#$P-@HR(#(@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@
XM,"`P"@D@-C4Y(#,X-R`V-3D@-#,T(#8R.2`T,S0@-C(Y(#,X-R`V-3D@,S@W
XM(#DY.3D@.3DY.0HR(#(@,2`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@-C(Y
XM(#,X-R`V,CD@,S0Q(#8U.2`S-#$@-C4Y(#,X-R`V,CD@,S@W(#DY.3D@.3DY
XM.0HR(#(@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@,S(S(#(S,2`S.#,@
XM,C,Q(#,X,R`R-C$@,S(S(#(V,2`S,C,@,C,Q(#DY.3D@.3DY.0HR(#$@,"`Q
XM("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@,SDT(#(Q.2`S.30@,3$Y(#0T-"`Q
XM,3D@-#0T(#(Q.2`Y.3DY(#DY.3D*,B`S(#`@,2`M,2`P(#`@,"`P+C`P,"`P
XM(#`@,`H)(#,V-"`R,3D@,SDT(#(Q.2`S.30@,C(Y(#,V-"`R,CD@,S8T(#(Q
XM.2`Y.3DY(#DY.3D*,B`S(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#0X
XM-"`R,CD@-#0T(#(R.2`T-#0@,C$Y(#0W-"`R,3D@-#<T(#@Y(#0X-"`X.2`T
XM.#0@,C(Y(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P
XM"@D@,SDT(#(Q.2`S.30@,3$Y(#0T-"`Q,3D@-#0T(#(Q.2`Y.3DY(#DY.3D*
XM,B`S(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#,U-"`X.2`S-C0@.#D@
XM,S8T(#(R.2`S,30@,C(Y(#,Q-"`R,3D@,S4T(#(Q.2`S-30@.#D@.3DY.2`Y
XM.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`S,3D@.#D@,S$Y
XM(#(Q.2`Y.3DY(#DY.3D*,B`R(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)
XM(#,R-"`X-"`S,C0@.30@,S0T(#DT(#,T-"`X-"`S,C0@.#0@.3DY.2`Y.3DY
XM"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`Q-SD@,3DY(#$W.2`R
XM,3D@.3DY.2`Y.3DY"C(@,R`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`Q
XM,SD@,3@Y(#$Y.2`Q.#D@,3DY(#(P-"`Q.#D@,C`T(#$X.2`Q.3D@,3,Y(#$Y
XM.2`Q,SD@,3@Y(#DY.3D@.3DY.0HR(#0@,"`Q("TQ(#`@,"`P(#`N,#`P(#,@
XM,"`P"@D@,C$Q(#(S,2`R,3$@,C8T(#(V-2`R-C0@,C8U(#(S,2`R,3$@,C,Q
XM(#DY.3D@.3DY.0HR(#0@,"`Q("TQ(#`@,"`P(#`N,#`P(#,@,"`P"@D@,30R
XM(#(S,2`Q-#(@,C8T(#(P.2`R-C0@,C`Y(#(S,2`Q-#(@,C,Q(#DY.3D@.3DY
XM.0HR(#$@,"`R("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@,C8Y(#(W-"`R-CD@
XM,C(Y(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@
XM,3DT(#@Y(#$Y-"`Q.#D@.3DY.2`Y.3DY"C(@-"`P(#$@+3$@,"`P(#`@,"XP
XM,#`@-R`P(#`*"2`Q-#0@.30@,30T(#$X-"`Q.#D@,3@T(#$X.2`Y-"`Q-#0@
XM.30@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`R
XM,S0@.#0@,C<Y(#@T(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P
XM(#`@,"`P"@D@,C<Y(#<Y(#(W.2`X.2`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P
XM(#`@,"`P+C`P,"`P(#`@,`H)(#(S-"`W.2`R,S0@.#D@.3DY.2`Y.3DY"C(@
XM-"`P(#$@+3$@,"`P(#`@,"XP,#`@,R`P(#`*"2`R,3,@,3`S(#(Q,R`Y,2`R
XM,SD@.3$@,C,Y(#$P,R`R,3,@,3`S(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@
XM,"`P(#`N,#`P(#`@,"`P"@D@,C,U(#$Q,B`R,S4@,3`S(#DY.3D@.3DY.0HR
XM(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@,C$W(#$Q-"`R,3<@,3`S
XM(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@-C8T
XM(#$P.2`V-S0@,3`Y(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P
XM(#`@,"`P"@D@-C8T(#$T.2`V-S0@,30Y(#DY.3D@.3DY.0HR(#$@,"`Q("TQ
XM(#`@,"`P(#`N,#`P(#`@,"`P"@D@-C8Y(#$P.2`V-CD@,30Y(#DY.3D@.3DY
XM.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@-C`T(#@T(#8T-"`X
XM-"`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#8T
XM-"`X.2`V-#0@-SD@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@
XM,"`P(#`*"2`V,#0@.#D@-C`T(#<Y(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@
XM,"`P(#`N,#`P(#`@,"`P"@D@,30T(#,Q,R`Q-#0@,S,Y(#$V.2`S,SD@,38Y
XM(#,Q,R`Q-#0@,S$S(#DY.3D@.3DY.0HR(#0@,"`Q("TQ(#`@,"`P(#`N,#`P
XM(#0@,"`P"@D@,38T(#0U.2`R.#D@-#4Y(#(X.2`S-#D@,38T(#,T.2`Q-C0@
XM-#4Y(#DY.3D@.3DY.0HR(#0@,"`Q("TQ(#`@,"`P(#`N,#`P(#,@,"`P"@D@
XM,38T(#,T-"`Q-#D@,S0T(#$T.2`T-C0@,38T(#0V-"`Q-C0@,S0T(#DY.3D@
XM.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@-38T(#0Y.2`U
XM-C0@-3`Y(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P
XM"@D@-3`T(#0Y.2`U,#0@-3`Y(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P
XM(#`N,#`P(#`@,"`P"@D@-3`T(#4P-"`U-C0@-3`T(#DY.3D@.3DY.0HR(#$@
XM,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@,3DY(#0Y.2`Q.3D@-3`Y(#DY
XM.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@,C4Y(#0Y
XM.2`R-3D@-3`Y(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@
XM,"`P"@D@,3DY(#4P-"`R-3D@-3`T(#DY.3D@.3DY.0HR(#,@,"`Q("TQ(#`@
XM,"`P(#`N,#`P(#`@,"`P"@D@-#(T(#,V.2`T,30@,S8Y(#0Q-"`S-#D@-#<Y
XM(#,T.2`T-SD@-#DY(#8V-"`T.3D@-C8T(#@Y(#,T-"`X.0H)(#,T-"`Y-"`S
XM,C0@.30@,S(T(#@Y(#$S.2`X.2`Q,SD@,S<T(#$R.2`S-S0@,3(Y(#<Y(#8W
XM-"`W.0H)(#8W-"`U,#D@,3(Y(#4P.2`Q,CD@,S<T(#$S.2`S-S0@,3,Y(#0Y
XM.2`T,30@-#DY(#0Q-"`T.#D@-#(T(#0X.0H)(#0R-"`T.3D@-#8Y(#0Y.2`T
XM-CD@,S4Y(#0R-"`S-3D@-#(T(#,V.2`Y.3DY(#DY.3D*,B`Q(#`@,B`M,2`P
XM(#`@,"`P+C`P,"`P(#`@,`H)(#0R,"`T,C0@-#(P(#0X-B`Y.3DY(#DY.3D*
XM,B`Q(#`@,B`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#0Q-R`S-S(@-#$W(#0R
XM.2`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#$R
XM.2`T-#0@,3,Y(#0T-"`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P
XM,"`P(#`@,`H)(#$S.2`S-S0@,3(Y(#,W-"`Y.3DY(#DY.3D*,B`Q(#`@,2`M
XM,2`P(#`@,"`P+C`P,"`P(#`@,0H),"`P(#$N,#`P(#0N,#`P(#@N,#`P"@D@
XM-C<Q(#8T(#0S.2`V-"`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P
XM,"`P(#`@,0H),"`P(#$N,#`P(#0N,#`P(#@N,#`P"@D@,3,Q(#8T(#,Y-"`V
XM-"`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#$R
XM.2`U-"`Q,CD@-S0@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@
XM,"`P(#`*"2`Q,S0@,S<T(#$S-"`T-#0@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@
XM,"`P(#`@,"XP,#`@,"`P(#`*"2`S,SD@-#DT(#,X-R`T.30@,S@W(#0W,"`S
XM,SD@-#<P(#,S.2`T.30@.3DY.2`Y.3DY"C(@-"`P(#$@+3$@,"`P(#`@,"XP
XM,#`@,R`P(#`*"2`U.#0@-#0T(#4X-"`T.30@-#@T(#0Y-"`T.#0@-#0T(#4X
XM-"`T-#0@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*
XM"2`V-S0@-30@-C<T(#<T(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N
XM,#`P(#`@,"`P"@D@-C8Y(#,W.2`V-CD@-#,Y(#DY.3D@.3DY.0HR(#$@,"`Q
XM("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@-C8T(#,W.2`V-S0@,S<Y(#DY.3D@
XM.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@-C8T(#0S.2`V
XM-S0@-#,Y(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P
XM"@D@-CDY(#4P.2`V-SD@-3`Y(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P
XM(#`N,#`P(#`@,"`P"@D@-CDY(#<Y(#8W.2`W.2`Y.3DY(#DY.3D*,B`Q(#`@
XM,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#8X.2`X,2`V.#D@,C@T(#DY.3D@
XM.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`Q"@DP(#`@,2XP,#`@
XM-"XP,#`@."XP,#`*"2`V.#D@-3`V(#8X.2`S,30@.3DY.2`Y.3DY"C(@,R`P
XM(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`U.#0@,38Y(#4U.2`Q-CD@-34Y
XM(#$W.2`U-S0@,3<Y(#4W-"`S,C0@-C8T(#,R-"`V-C0@,S$T(#4X-"`S,30*
XM"2`U.#0@,38Y(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@
XM,"`P"@D@-3<Y(#@Y(#4W.2`Q-CD@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P
XM(#`@,"XP,#`@,"`P(#`*"2`U.#0@,38Y(#8V-"`Q-CD@.3DY.2`Y.3DY"C(@
XM,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`U.#0@,3@T(#8V-"`Q.#0@
XM.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`U.#0@
XM,3DY(#8V-"`Q.3D@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@
XM,"`P(#`*"2`U.#0@,C$T(#8V-"`R,30@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@
XM,"`P(#`@,"XP,#`@,"`P(#`*"2`U.#0@,C(Y(#8V-"`R,CD@.3DY.2`Y.3DY
XM"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`U.#0@,C0T(#8V-"`R
XM-#0@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`U
XM.#0@,C4Y(#8V-"`R-3D@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP
XM,#`@,"`P(#`*"2`U.#0@,C<T(#8V-"`R-S0@.3DY.2`Y.3DY"C(@,2`P(#$@
XM+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`U.#0@,C@Y(#8V-"`R.#D@.3DY.2`Y
XM.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`U-C0@.#D@-38T
XM(#$V.2`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#$@,`H)
XM,"`P(#$N,#`P(#0N,#`P(#@N,#`P"@D@-34T(#$R.2`V,#D@,3(Y(#8R.2`Q
XM-#0@-C(Y(#(Y-"`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P
XM(#`@,`H)(#4X-"`S,#0@-C8T(#,P-"`Y.3DY(#DY.3D*,B`S(#`@,2`M,2`P
XM(#`@,"`P+C`P,"`P(#`@,`H)(#$S.2`R,3D@,C8Y(#(Q.2`R-CD@,C(Y(#$S
XM.2`R,CD@,3,Y(#(Q.2`Y.3DY(#DY.3D*,B`Q(#`@,B`M,2`P(#`@,"`P+C`P
XM,"`P(#`@,`H)(#$Y.2`R,#0@,C$T(#(P-"`Y.3DY(#DY.3D*-"`P(#`@,3(@
XM,"`M,2`P(#`N,#`P(#0@.2`R-R`V,S0@-#`Y(%-%5P$*-"`P(#`@,3(@,"`M
XM,2`P(#`N,#`P(#0@.2`Q-R`S-#8@,C4P($12`0HT(#`@,"`Q,B`P("TQ(#`@
XM,"XP,#`@-"`Y(#$X(#0P.2`Q-30@0TPN`0HT(#`@,"`Q,B`P("TQ(#`@,"XP
XM,#`@-"`Y(#$U(#$U.2`R,30@0TP!"C0@,"`P(#$R(#`@+3$@,"`P+C`P,"`T
XM(#D@,3<@,C(Y(#(T.2!$4@$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`Q
XM-R`Q-3D@,C0Y($12`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#,S(#(S
XM-"`Q-#D@0D%42`$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`W(#$U,2`S
XM,S$@5`$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`R-2`R,#D@-#`Y($)%
XM1`$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`S,"`S.3D@-CD@,C<G(#(B
XM`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#0P(#4R.2`S-SD@4U151%D!
XM"C0@,"`P(#$R(#`@+3$@,"`P+C`P,"`T(#D@,3$U(#(R."`S,#4@34%35$52
XM($)%1%)/3TT!"C0@,"`P(#$R(#`@+3$@,"`P+C`P,"`T(#$R(#4T(#$Y(#,Y
XM.2!H;W5S940N9FEG`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#$X(#0S
XM-"`T,CD@0TPN`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#$W(#,U-"`T
XM.#0@1%(!"C0@,"`P(#$R(#`@+3$@,"`P+C`P,"`T(#D@,S(@-3$Y(#0V.2!$
XM15-+`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#,P(#8X-"`S,#0@,C$G
XM(#8B`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#,Y(#4R-"`Q,C0@1$]7
X#3@$*
X`
Xend
END_OF_FILE
if test 8465 -ne `wc -c <'Examples/houseD.fig.uu'`; then
    echo shar: \"'Examples/houseD.fig.uu'\" unpacked with wrong size!
fi
# end of 'Examples/houseD.fig.uu'
fi
if test -f 'Examples/lists.fig.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Examples/lists.fig.uu'\"
else
echo shar: Extracting \"'Examples/lists.fig.uu'\" \(8458 characters\)
sed "s/^X//" >'Examples/lists.fig.uu' <<'END_OF_FILE'
Xbegin 444 lists.fig
XM(T9)1R`R+C$*.#`@,@HU(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,2`P(#4T
XM,BXQ-3<@-#,Q+C4X,2`U,C$@,SDT(#4T.2`S.#D@-38U(#,Y-0H),"`P(#$N
XM,#`P(#0N,#`P(#@N,#`P"C4@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,2`Q(#`@
XM-3`P+C$W."`T,C0N,#$V(#0W-2`S.30@-#8Q(#0R-"`T-S`@-#0Y"@DS-#`W
XM.#<R(#$S,3`W,B`Q+C`P,"`T+C`P,"`X+C`P,`HU(#$@,"`Q("TQ(#`@,"`P
XM(#`N,#`P(#$@,2`P(#4P,"XQ-S@@-#<Y+C`Q-B`T-S4@-#0Y(#0V,2`T-SD@
XM-#<P(#4P-`H),S0P-S@W,B`Q,S$P-S(@,2XP,#`@-"XP,#`@."XP,#`*-2`Q
XM(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#$@,"`S,#`N-CDX(#0R.2XP,#8@,C@P
XM(#,Y-"`S,#@@,S@Y(#,R,R`S.34*"3`@,"`Q+C`P,"`T+C`P,"`X+C`P,`HU
XM(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#$@,2`P(#(U-BXX,#@@-#(S+C,W-R`R
XM,S,@,SDT(#(Q.2`T,C0@,C(Y(#0T.0H),S0P-S@W,B`Q,S$P-S(@,2XP,#`@
XM-"XP,#`@."XP,#`*-2`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`Q(#$@,"`R-38N
XM.#`X(#0W."XS-S<@,C,S(#0T.2`R,3D@-#<Y(#(R.2`U,#0*"3,T,#<X-S(@
XM,3,Q,#<R(#$N,#`P(#0N,#`P(#@N,#`P"C4@,2`P(#$@+3$@,"`P(#`@,"XP
XM,#`@,2`Q(#`@,C4V+C@P."`U,S,N,S<W(#(S,R`U,#0@,C$Y(#4S-"`R,CD@
XM-34Y"@DS-#`W.#<R(#$S,3`W,B`Q+C`P,"`T+C`P,"`X+C`P,`HU(#$@,"`Q
XM("TQ(#`@,"`P(#`N,#`P(#$@,2`P(#(U-BXX,#@@-3@X+C,W-R`R,S,@-34Y
XM(#(Q.2`U.#D@,C(Y(#8Q-`H),S0P-S@W,B`Q,S$P-S(@,2XP,#`@-"XP,#`@
XM."XP,#`*-2`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`Q(#$@,"`S-SDN,3<W(#4S
XM-"XP,38@,S4T(#4P-"`S-#`@-3,T(#,T.2`U-3D*"3,T,#<X-S(@,3,Q,#<R
XM(#$N,#`P(#0N,#`P(#@N,#`P"C4@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,2`Q
XM(#`@,S<Y+C$W."`T-SDN,#$V(#,U-"`T-#D@,S0P(#0W.2`S-#D@-3`T"@DS
XM-#`W.#<R(#$S,3`W,B`Q+C`P,"`T+C`P,"`X+C`P,`HU(#$@,"`Q("TQ(#`@
XM,"`P(#`N,#`P(#$@,2`P(#,W.2XQ-S@@-#(T+C`Q-B`S-30@,SDT(#,T,"`T
XM,C0@,S0Y(#0T.0H),S0P-S@W,B`Q,S$P-S(@,2XP,#`@-"XP,#`@."XP,#`*
XM-2`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#$@,"`T,C$N,34W(#0S,2XU.#$@
XM-#`P(#,Y-"`T,C@@,S@Y(#0T-"`S.34*"3`@,"`Q+C`P,"`T+C`P,"`X+C`P
XM,`HU(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#$@,2`P(#$S-2XX,#@@-3,S+C,W
XM-R`Q,3(@-3`T(#DX(#4S-"`Q,#@@-34Y"@DS-#`W.#<R(#$S,3`W,B`Q+C`P
XM,"`T+C`P,"`X+C`P,`HU(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#$@,2`P(#$S
XM-2XX,#@@-#<X+C,W-R`Q,3(@-#0Y(#DX(#0W.2`Q,#@@-3`T"@DS-#`W.#<R
XM(#$S,3`W,B`Q+C`P,"`T+C`P,"`X+C`P,`HU(#$@,"`Q("TQ(#`@,"`P(#`N
XM,#`P(#$@,2`P(#$S-2XX,#@@-#(S+C,W-R`Q,3(@,SDT(#DX(#0R-"`Q,#@@
XM-#0Y"@DS-#`W.#<R(#$S,3`W,B`Q+C`P,"`T+C`P,"`X+C`P,`HU(#$@,"`Q
XM("TQ(#`@,"`P(#`N,#`P(#$@,2`P(#@W+C@W."`S-34N,C@V(#0W(#,V.2`V
XM,2`S.#D@.#(@,SDX"@DP(#`@,2XP,#`@-"XP,#`@."XP,#`*-2`Q(#`@,2`M
XM,2`P(#`@,"`P+C`P,"`P(#$@,"`Q-SDN-CDX(#0R.2XP,#8@,34Y(#,Y-"`Q
XM.#<@,S@Y(#(P,B`S.34*"3`@,"`Q+C`P,"`T+C`P,"`X+C`P,`HR(#(@,"`Q
XM("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@,30T(#4Y(#$T-"`Y-"`S,C0@.30@
XM,S(T(#4Y(#$T-"`U.2`Y.3DY(#DY.3D*,B`R(#`@,2`M,2`P(#`@,"`P+C`P
XM,"`P(#`@,`H)(#$U-"`Q,C0@,34T(#(Q.2`Q-S0@,C$Y(#$W-"`Q,C0@,34T
XM(#$R-"`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)
XM(#$V-"`Y-"`Q-C0@,3(T(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N
XM,#`P(#`@,"`P"@D@,3DY(#DT(#$Y.2`Q,C0@.3DY.2`Y.3DY"C(@,B`P(#$@
XM+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`Q.#D@,3(T(#$X.2`R,3D@,C`Y(#(Q
XM.2`R,#D@,3(T(#$X.2`Q,C0@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#`@
XM,"XP,#`@,"`P(#`*"2`R,C0@,3(T(#(R-"`R,3D@,C0T(#(Q.2`R-#0@,3(T
XM(#(R-"`Q,C0@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P
XM(#`*"2`R,S0@.30@,C,T(#$R-"`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@
XM,"`P+C`P,"`P(#`@,`H)(#(V.2`Y-"`R-CD@,3(T(#DY.3D@.3DY.0HR(#(@
XM,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@,C4Y(#$R-"`R-3D@,C$Y(#(W
XM.2`R,3D@,C<Y(#$R-"`R-3D@,3(T(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@
XM,"`P(#`N,#`P(#`@,"`P"@D@,CDT(#$R-"`R.30@,C$Y(#,Q-"`R,3D@,S$T
XM(#$R-"`R.30@,3(T(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P
XM(#`@,"`P"@D@,S`T(#DT(#,P-"`Q,C0@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@
XM,"`P(#`@,"XP,#`@,"`P(#`*"2`T.#0@-#DT(#0X-"`U,3D@.3DY.2`Y.3DY
XM"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`T-#<@-#DT(#0T-R`U
XM,3D@-3,Q(#4Q.2`U,S$@-#DT(#0T-R`T.30@.3DY.2`Y.3DY"C(@,B`P(#$@
XM+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`U-C@@,S@T(#4V."`T,#D@-C4Q(#0P
XM.2`V-3$@,S@T(#4V."`S.#0@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@
XM,"XP,#`@,"`P(#`*"2`V,#4@,S@T(#8P-2`T,#D@.3DY.2`Y.3DY"C(@,2`P
XM(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`T.#0@,S@T(#0X-"`T,#D@.3DY
XM.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`T-#<@,S@T
XM(#0T-R`T,#D@-3,Q(#0P.2`U,S$@,S@T(#0T-R`S.#0@.3DY.2`Y.3DY"C(@
XM,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`T.#0@-#,Y(#0X-"`T-C0@
XM.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`T-#<@
XM-#,Y(#0T-R`T-C0@-3,Q(#0V-"`U,S$@-#,Y(#0T-R`T,SD@.3DY.2`Y.3DY
XM"C(@,B`Q(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`Q.3$@-3,T(#,P."`U
XM,S0@,S`X(#4X-"`Q.3$@-3@T(#$Y,2`U,S0@.3DY.2`Y.3DY"C(@,2`P(#$@
XM+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`R-#(@,S@T(#(T,B`T,#D@.3DY.2`Y
XM.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`R,#4@,S@T(#(P
XM-2`T,#D@,C@Y(#0P.2`R.#D@,S@T(#(P-2`S.#0@.3DY.2`Y.3DY"C(@,2`P
XM(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`R-#(@-#,Y(#(T,B`T-C0@.3DY
XM.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`R,#4@-#,Y
XM(#(P-2`T-C0@,C@Y(#0V-"`R.#D@-#,Y(#(P-2`T,SD@.3DY.2`Y.3DY"C(@
XM,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`R,#4@-#DT(#(P-2`U,3D@
XM,C@Y(#4Q.2`R.#D@-#DT(#(P-2`T.30@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@
XM,"`P(#`@,"XP,#`@,"`P(#`*"2`R-#(@-#DT(#(T,B`U,3D@.3DY.2`Y.3DY
XM"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`R-#(@-30Y(#(T,B`U
XM-S0@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`R
XM,#4@-30Y(#(P-2`U-S0@,C@Y(#4W-"`R.#D@-30Y(#(P-2`U-#D@.3DY.2`Y
XM.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`R,#4@-C`T(#(P
XM-2`V,CD@,C@Y(#8R.2`R.#D@-C`T(#(P-2`V,#0@.3DY.2`Y.3DY"C(@,2`P
XM(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`R-#(@-C`T(#(T,B`V,CD@.3DY
XM.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`S,C8@-30Y
XM(#,R-B`U-S0@-#$P(#4W-"`T,3`@-30Y(#,R-B`U-#D@.3DY.2`Y.3DY"C(@
XM,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`S-C,@-30Y(#,V,R`U-S0@
XM.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`S-C,@
XM-#DT(#,V,R`U,3D@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@
XM,"`P(#`*"2`S,C8@-#DT(#,R-B`U,3D@-#$P(#4Q.2`T,3`@-#DT(#,R-B`T
XM.30@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`S
XM,C8@-#,Y(#,R-B`T-C0@-#$P(#0V-"`T,3`@-#,Y(#,R-B`T,SD@.3DY.2`Y
XM.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`S-C,@-#,Y(#,V
XM,R`T-C0@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*
XM"2`S,C8@,S@T(#,R-B`T,#D@-#$P(#0P.2`T,3`@,S@T(#,R-B`S.#0@.3DY
XM.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`S-C,@,S@T
XM(#,V,R`T,#D@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P
XM(#`*"2`Q,C(@-30Y(#$R,B`U-S0@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P
XM(#`@,"XP,#`@,"`P(#`*"2`X-"`U-#D@.#0@-3<T(#$V."`U-S0@,38X(#4T
XM.2`X-"`U-#D@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P
XM(#`*"2`X-"`T.30@.#0@-3$Y(#$V."`U,3D@,38X(#0Y-"`X-"`T.30@.3DY
XM.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`Q,C(@-#DT
XM(#$R,B`U,3D@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P
XM(#`*"2`Q,C(@-#,Y(#$R,B`T-C0@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P
XM(#`@,"XP,#`@,"`P(#`*"2`X-"`T,SD@.#0@-#8T(#$V."`T-C0@,38X(#0S
XM.2`X-"`T,SD@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P
XM(#`*"2`X-"`S.#0@.#0@-#`Y(#$V."`T,#D@,38X(#,X-"`X-"`S.#0@.3DY
XM.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`Q,C(@,S@T
XM(#$R,B`T,#D@.3DY.2`Y.3DY"C0@,"`P(#$R(#`@+3$@,"`P+C`P,"`T(#D@
XM.#D@,S,T(#$V.2!3=6)O<F1I;F%T92!,:7-T<P$*-"`P(#`@,3(@,"`M,2`P
XM(#`N,#`P(#0@.2`V(#(Y.2`R,SD@-0$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P
XM(#0@.2`V(#(V-"`R,SD@-`$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`V
XM(#(R.2`R,SD@,P$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`V(#$Y-"`R
XM,SD@,@$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`V(#$U.2`R,SD@,0$*
XM-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`X,2`Q.#D@.#0@34%35$52("!,
XM25-4`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#(P(#0U,B`U,30@3DE,
XM`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#,T(#0X.2`U,#D@1$%400$*
XM-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`S-"`V,3`@,SDY($1!5$$!"C0@
XM,"`P(#$R(#`@+3$@,"`P+C`P,"`T(#D@,C`@-3<R(#0P-"!.24P!"C0@,"`P
XM(#$R(#`@+3$@,"`P+C`P,"`T(#D@,S0@-#@Y(#0U-"!$051!`0HT(#`@,"`Q
XM,B`P("TQ(#`@,"XP,#`@-"`U(#8@,S$R(#4X-"`J`0HT(#`@,"`Q,B`P("TQ
XM(#`@,"XP,#`@-"`Y(#(P(#(Q,"`V,C0@3DE,`0HT(#`@,"`Q,B`P("TQ(#`@
XM,"XP,#`@-"`Y(#,T(#(T-R`T-30@1$%400$*-"`P(#`@,3(@,"`M,2`P(#`N
XM,#`P(#0@.2`S-"`R-#<@-3`Y($1!5$$!"C0@,"`P(#$R(#`@+3$@,"`P+C`P
XM,"`T(#D@,S0@,C0W(#4V-"!$051!`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@
XM-"`Y(#,T(#(T-R`V,3D@1$%400$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@
XM.2`S-"`S-C@@-38T($1!5$$!"C0@,"`P(#$R(#`@+3$@,"`P+C`P,"`T(#D@
XM,S0@,S8X(#4P.2!$051!`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#,T
XM(#,V."`T-30@1$%400$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`S-"`Q
XM,C8@-38T($1!5$$!"C0@,"`P(#$R(#`@+3$@,"`P+C`P,"`T(#D@,S0@,3(V
XM(#4P.2!$051!`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#,T(#$R-B`T
XM-30@1$%400$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`R,B`Q,C8@,SDY
XM(%!44@$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`R,B`X.2`S.3D@4%12
XM`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#(P(#@Y(#4V.2!.24P!"C0@
XM,"`P(#$R(#`@+3$@,"`P+C`P,"`T(#D@.#$@-#,@,S4Y($U!4U1%4B`@3$E3
XM5`$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`R,"`S,S$@-38Y($Y)3`$*
X`
Xend
END_OF_FILE
if test 8458 -ne `wc -c <'Examples/lists.fig.uu'`; then
    echo shar: \"'Examples/lists.fig.uu'\" unpacked with wrong size!
fi
# end of 'Examples/lists.fig.uu'
fi
if test -f 'Examples/roundboxes2.fig.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Examples/roundboxes2.fig.uu'\"
else
echo shar: Extracting \"'Examples/roundboxes2.fig.uu'\" \(8142 characters\)
sed "s/^X//" >'Examples/roundboxes2.fig.uu' <<'END_OF_FILE'
Xbegin 444 roundboxes2.fig
XM(T9)1R`R+C`*.#`@,@HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,C$@,"`P"@D@
XM-#8Y(#8T(#0V.2`S,#0@-C0T(#,P-"`V-#0@-C0@-#8Y(#8T(#DY.3D@.3DY
XM.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,C$@,"`P"@D@-S`Y(#0X-"`W,#D@
XM,S`Y(#0V.2`S,#D@-#8Y(#0X-"`W,#D@-#@T(#DY.3D@.3DY.0HR(#0@,"`Q
XM(#`@,"`P(#`@,"XP,#`@,C$@,"`P"@D@,C@Y(#,P.2`R.#D@-30Y(#0V-"`U
XM-#D@-#8T(#,P.2`R.#D@,S`Y(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@
XM,"XP,#`@,C$@,"`P"@D@-#8T(#,P.2`T-C0@,3,T(#(R-"`Q,S0@,C(T(#,P
XM.2`T-C0@,S`Y(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,C`@
XM,"`P"@D@,C(Y(#$S.2`R,CD@,S`T(#0U.2`S,#0@-#4Y(#$S.2`R,CD@,3,Y
XM(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,C`@,"`P"@D@,CDT
XM(#,Q-"`R.30@-30T(#0U.2`U-#0@-#4Y(#,Q-"`R.30@,S$T(#DY.3D@.3DY
XM.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@."`P(#`*"2`S-30@-#@T(#,Y.2`T
XM.#0@,SDY(#,W-"`S-30@,S<T(#,U-"`T.#0@.3DY.2`Y.3DY"C(@-"`P(#$@
XM,"`P(#`@,"`P+C`P,"`X(#`@,`H)(#(X.2`Q.3D@,C@Y(#(T-"`S.3D@,C0T
XM(#,Y.2`Q.3D@,C@Y(#$Y.2`Y.3DY(#DY.3D*,B`T(#`@,2`P(#`@,"`P(#`N
XM,#`P(#D@,"`P"@D@-#`T(#(T.2`T,#0@,3DT(#(X-"`Q.30@,C@T(#(T.2`T
XM,#0@,C0Y(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,3`@,"`P
XM"@D@,C<Y(#$X.2`R-SD@,C4T(#0P.2`R-30@-#`Y(#$X.2`R-SD@,3@Y(#DY
XM.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,3$@,"`P"@D@,C<T(#$X
XM-"`R-S0@,C4Y(#0Q-"`R-3D@-#$T(#$X-"`R-S0@,3@T(#DY.3D@.3DY.0HR
XM(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,3(@,"`P"@D@-#$Y(#(V-"`T,3D@,3<Y
XM(#(V.2`Q-SD@,C8Y(#(V-"`T,3D@,C8T(#DY.3D@.3DY.0HR(#0@,"`Q(#`@
XM,"`P(#`@,"XP,#`@,3,@,"`P"@D@-#(T(#(V.2`T,C0@,3<T(#(V-"`Q-S0@
XM,C8T(#(V.2`T,C0@,C8Y(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP
XM,#`@,30@,"`P"@D@-#(Y(#(W-"`T,CD@,38Y(#(U.2`Q-CD@,C4Y(#(W-"`T
XM,CD@,C<T(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,34@,"`P
XM"@D@-#,T(#(W.2`T,S0@,38T(#(U-"`Q-C0@,C4T(#(W.2`T,S0@,C<Y(#DY
XM.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,38@,"`P"@D@-#,Y(#(X
XM-"`T,SD@,34Y(#(T.2`Q-3D@,C0Y(#(X-"`T,SD@,C@T(#DY.3D@.3DY.0HR
XM(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,3<@,"`P"@D@-#0T(#(X.2`T-#0@,34T
XM(#(T-"`Q-30@,C0T(#(X.2`T-#0@,C@Y(#DY.3D@.3DY.0HR(#0@,"`Q(#`@
XM,"`P(#`@,"XP,#`@,3@@,"`P"@D@,C,Y(#$T.2`R,SD@,CDT(#0T.2`R.30@
XM-#0Y(#$T.2`R,SD@,30Y(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP
XM,#`@,3D@,"`P"@D@-#4T(#(Y.2`T-30@,30T(#(S-"`Q-#0@,C,T(#(Y.2`T
XM-30@,CDY(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,3D@,"`P
XM"@D@,CDY(#,Q.2`R.3D@-3,Y(#0U-"`U,SD@-#4T(#,Q.2`R.3D@,S$Y(#DY
XM.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,3@@,"`P"@D@,S`T(#4S
XM-"`T-#D@-3,T(#0T.2`S,C0@,S`T(#,R-"`S,#0@-3,T(#DY.3D@.3DY.0HR
XM(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,3<@,"`P"@D@-#0T(#,R.2`S,#D@,S(Y
XM(#,P.2`U,CD@-#0T(#4R.2`T-#0@,S(Y(#DY.3D@.3DY.0HR(#0@,"`Q(#`@
XM,"`P(#`@,"XP,#`@,38@,"`P"@D@-#,Y(#,S-"`S,30@,S,T(#,Q-"`U,C0@
XM-#,Y(#4R-"`T,SD@,S,T(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP
XM,#`@,34@,"`P"@D@-#,T(#,S.2`S,3D@,S,Y(#,Q.2`U,3D@-#,T(#4Q.2`T
XM,S0@,S,Y(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,30@,"`P
XM"@D@-#(Y(#,T-"`S,C0@,S0T(#,R-"`U,30@-#(Y(#4Q-"`T,CD@,S0T(#DY
XM.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,3,@,"`P"@D@-#(T(#,T
XM.2`S,CD@,S0Y(#,R.2`U,#D@-#(T(#4P.2`T,C0@,S0Y(#DY.3D@.3DY.0HR
XM(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,3(@,"`P"@D@-#$Y(#,U-"`S,S0@,S4T
XM(#,S-"`U,#0@-#$Y(#4P-"`T,3D@,S4T(#DY.3D@.3DY.0HR(#0@,"`Q(#`@
XM,"`P(#`@,"XP,#`@,3$@,"`P"@D@,S,Y(#0Y.2`T,30@-#DY(#0Q-"`S-3D@
XM,S,Y(#,U.2`S,SD@-#DY(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP
XM,#`@,3`@,"`P"@D@,S0T(#0Y-"`T,#D@-#DT(#0P.2`S-C0@,S0T(#,V-"`S
XM-#0@-#DT(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@.2`P(#`*
XM"2`T,#0@,S8Y(#,T.2`S-CD@,S0Y(#0X.2`T,#0@-#@Y(#0P-"`S-CD@.3DY
XM.2`Y.3DY"C(@-"`P(#$@,"`P(#`@,"`P+C`P,"`W(#`@,`H)(#(Y-"`R,#0@
XM,CDT(#(S.2`S.30@,C,Y(#,Y-"`R,#0@,CDT(#(P-"`Y.3DY(#DY.3D*,B`T
XM(#`@,2`P(#`@,"`P(#`N,#`P(#8@,"`P"@D@,CDY(#(P.2`R.3D@,C,T(#,X
XM.2`R,S0@,S@Y(#(P.2`R.3D@,C`Y(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P
XM(#`@,"XP,#`@-2`P(#`*"2`S.#0@,C(Y(#,X-"`R,30@,S`T(#(Q-"`S,#0@
XM,C(Y(#,X-"`R,CD@.3DY.2`Y.3DY"C(@-"`P(#$@,"`P(#`@,"`P+C`P,"`S
XM(#`@,`H)(#,W.2`R,C0@,S<Y(#(Q.2`S,#D@,C$Y(#,P.2`R,C0@,S<Y(#(R
XM-"`Y.3DY(#DY.3D*,B`T(#`@,2`P(#`@,"`P(#`N,#`P(#<@,"`P"@D@,SDT
XM(#,W.2`S-3D@,S<Y(#,U.2`T-SD@,SDT(#0W.2`S.30@,S<Y(#DY.3D@.3DY
XM.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@-B`P(#`*"2`S.#D@,S@T(#,V-"`S
XM.#0@,S8T(#0W-"`S.#D@-#<T(#,X.2`S.#0@.3DY.2`Y.3DY"C(@-"`P(#$@
XM,"`P(#`@,"`P+C`P,"`U(#`@,`H)(#,V.2`T-CD@,S@T(#0V.2`S.#0@,S@Y
XM(#,V.2`S.#D@,S8Y(#0V.2`Y.3DY(#DY.3D*,B`T(#`@,2`P(#`@,"`P(#`N
XM,#`P(#,@,"`P"@D@,S<T(#0V-"`S-SD@-#8T(#,W.2`S.30@,S<T(#,Y-"`S
XM-S0@-#8T(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@-R`P(#`*
XM"2`U,SD@,S<Y(#4S.2`T,30@-C,Y(#0Q-"`V,SD@,S<Y(#4S.2`S-SD@.3DY
XM.2`Y.3DY"C(@-"`P(#$@,"`P(#`@,"`P+C`P,"`V(#`@,`H)(#4T-"`S.#0@
XM-30T(#0P.2`V,S0@-#`Y(#8S-"`S.#0@-30T(#,X-"`Y.3DY(#DY.3D*,B`T
XM(#`@,2`P(#`@,"`P(#`N,#`P(#4@,"`P"@D@-C(Y(#0P-"`V,CD@,S@Y(#4T
XM.2`S.#D@-30Y(#0P-"`V,CD@-#`T(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P
XM(#`@,"XP,#`@,R`P(#`*"2`V,C0@,SDY(#8R-"`S.30@-34T(#,Y-"`U-30@
XM,SDY(#8R-"`S.3D@.3DY.2`Y.3DY"C(@-"`P(#$@,"`P(#`@,"`P+C`P,"`Q
XM.2`P(#`*"2`T-SD@,S$Y(#0W.2`T-S0@-CDY(#0W-"`V.3D@,S$Y(#0W.2`S
XM,3D@.3DY.2`Y.3DY"C(@-"`P(#$@,"`P(#`@,"`P+C`P,"`Q."`P(#`*"2`V
XM.30@-#8Y(#8Y-"`S,C0@-#@T(#,R-"`T.#0@-#8Y(#8Y-"`T-CD@.3DY.2`Y
XM.3DY"C(@-"`P(#$@,"`P(#`@,"`P+C`P,"`Q-R`P(#`*"2`T.#D@,S(Y(#0X
XM.2`T-C0@-C@Y(#0V-"`V.#D@,S(Y(#0X.2`S,CD@.3DY.2`Y.3DY"C(@-"`P
XM(#$@,"`P(#`@,"`P+C`P,"`Q-B`P(#`*"2`T.30@,S,T(#0Y-"`T-3D@-C@T
XM(#0U.2`V.#0@,S,T(#0Y-"`S,S0@.3DY.2`Y.3DY"C(@-"`P(#$@,"`P(#`@
XM,"`P+C`P,"`Q-2`P(#`*"2`T.3D@,S,Y(#0Y.2`T-30@-C<Y(#0U-"`V-SD@
XM,S,Y(#0Y.2`S,SD@.3DY.2`Y.3DY"C(@-"`P(#$@,"`P(#`@,"`P+C`P,"`Q
XM-"`P(#`*"2`U,#0@,S0T(#4P-"`T-#D@-C<T(#0T.2`V-S0@,S0T(#4P-"`S
XM-#0@.3DY.2`Y.3DY"C(@-"`P(#$@,"`P(#`@,"`P+C`P,"`Q,R`P(#`*"2`U
XM,#D@,S0Y(#4P.2`T-#0@-C8Y(#0T-"`V-CD@,S0Y(#4P.2`S-#D@.3DY.2`Y
XM.3DY"C(@-"`P(#$@,"`P(#`@,"`P+C`P,"`Q,B`P(#`*"2`U,30@,S4T(#4Q
XM-"`T,SD@-C8T(#0S.2`V-C0@,S4T(#4Q-"`S-30@.3DY.2`Y.3DY"C(@-"`P
XM(#$@,"`P(#`@,"`P+C`P,"`Q,2`P(#`*"2`V-3D@-#,T(#8U.2`S-3D@-3$Y
XM(#,U.2`U,3D@-#,T(#8U.2`T,S0@.3DY.2`Y.3DY"C(@-"`P(#$@,"`P(#`@
XM,"`P+C`P,"`Q,"`P(#`*"2`V-30@-#(Y(#8U-"`S-C0@-3(T(#,V-"`U,C0@
XM-#(Y(#8U-"`T,CD@.3DY.2`Y.3DY"C(@-"`P(#$@,"`P(#`@,"`P+C`P,"`Y
XM(#`@,`H)(#4R.2`S-CD@-3(Y(#0R-"`V-#D@-#(T(#8T.2`S-CD@-3(Y(#,V
XM.2`Y.3DY(#DY.3D*,B`T(#`@,2`P(#`@,"`P(#`N,#`P(#@@,"`P"@D@-C0T
XM(#0Q.2`V-#0@,S<T(#4S-"`S-S0@-3,T(#0Q.2`V-#0@-#$Y(#DY.3D@.3DY
XM.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@-R`P(#`*"2`V,SD@-#$T(#8S.2`S
XM-SD@-3,Y(#,W.2`U,SD@-#$T(#8S.2`T,30@.3DY.2`Y.3DY"C(@-"`P(#$@
XM,"`P(#`@,"`P+C`P,"`R,"`P(#`*"2`T-S0@,S$T(#0W-"`T-SD@-S`T(#0W
XM.2`W,#0@,S$T(#0W-"`S,30@.3DY.2`Y.3DY"C(@-"`P(#$@,"`P(#`@,"`P
XM+C`P,"`W(#`@,`H)(#4W-"`Q,S0@-3,Y(#$S-"`U,SD@,C,T(#4W-"`R,S0@
XM-3<T(#$S-"`Y.3DY(#DY.3D*,B`T(#`@,2`P(#`@,"`P(#`N,#`P(#8@,"`P
XM"@D@-38Y(#$S.2`U-#0@,3,Y(#4T-"`R,CD@-38Y(#(R.2`U-CD@,3,Y(#DY
XM.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@-2`P(#`*"2`U-#D@,C(T
XM(#4V-"`R,C0@-38T(#$T-"`U-#D@,30T(#4T.2`R,C0@.3DY.2`Y.3DY"C(@
XM-"`P(#$@,"`P(#`@,"`P+C`P,"`S(#`@,`H)(#4U-"`R,3D@-34Y(#(Q.2`U
XM-3D@,30Y(#4U-"`Q-#D@-34T(#(Q.2`Y.3DY(#DY.3D*,B`T(#`@,2`P(#`@
XM,"`P(#`N,#`P(#@@,"`P"@D@-3<Y(#$R."`U,S0@,3(X(#4S-"`R,S@@-3<Y
XM(#(S."`U-SD@,3(X(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@
XM.2`P(#`*"2`U,CD@,C0T(#4X-"`R-#0@-3@T(#$R-"`U,CD@,3(T(#4R.2`R
XM-#0@.3DY.2`Y.3DY"C(@-"`P(#$@,"`P(#`@,"`P+C`P,"`Q,"`P(#`*"2`U
XM.#D@,3$Y(#4R-"`Q,3D@-3(T(#(T.2`U.#D@,C0Y(#4X.2`Q,3D@.3DY.2`Y
XM.3DY"C(@-"`P(#$@,"`P(#`@,"`P+C`P,"`Q,2`P(#`*"2`U.30@,3$T(#4Q
XM.2`Q,30@-3$Y(#(U-"`U.30@,C4T(#4Y-"`Q,30@.3DY.2`Y.3DY"C(@-"`P
XM(#$@,"`P(#`@,"`P+C`P,"`Q,B`P(#`*"2`U,30@,C4Y(#4Y.2`R-3D@-3DY
XM(#$P.2`U,30@,3`Y(#4Q-"`R-3D@.3DY.2`Y.3DY"C(@-"`P(#$@,"`P(#`@
XM,"`P+C`P,"`Q,R`P(#`*"2`U,#D@,C8T(#8P-"`R-C0@-C`T(#$P-"`U,#D@
XM,3`T(#4P.2`R-C0@.3DY.2`Y.3DY"C(@-"`P(#$@,"`P(#`@,"`P+C`P,"`Q
XM-"`P(#`*"2`U,#0@,C8Y(#8P.2`R-CD@-C`Y(#DY(#4P-"`Y.2`U,#0@,C8Y
XM(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,34@,"`P"@D@-#DY
XM(#(W-"`V,30@,C<T(#8Q-"`Y-"`T.3D@.30@-#DY(#(W-"`Y.3DY(#DY.3D*
XM,B`T(#`@,2`P(#`@,"`P(#`N,#`P(#$V(#`@,`H)(#0Y-"`R-SD@-C$Y(#(W
XM.2`V,3D@.#D@-#DT(#@Y(#0Y-"`R-SD@.3DY.2`Y.3DY"C(@-"`P(#$@,"`P
XM(#`@,"`P+C`P,"`Q-R`P(#`*"2`T.#D@,C@T(#8R-"`R.#0@-C(T(#@T(#0X
XM.2`X-"`T.#D@,C@T(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@
XM,3@@,"`P"@D@-C(Y(#<Y(#0X-"`W.2`T.#0@,C@Y(#8R.2`R.#D@-C(Y(#<Y
XM(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@,3D@,"`P"@D@-#<Y
XM(#(Y-"`V,S0@,CDT(#8S-"`W-"`T-SD@-S0@-#<Y(#(Y-"`Y.3DY(#DY.3D*
XM,B`T(#`@,2`P(#`@,"`P(#`N,#`P(#(P(#`@,`H)(#8S.2`R.3D@-C,Y(#8Y
XB(#0W-"`V.2`T-S0@,CDY(#8S.2`R.3D@.3DY.2`Y.3DY"B`R
X`
Xend
END_OF_FILE
if test 8142 -ne `wc -c <'Examples/roundboxes2.fig.uu'`; then
    echo shar: \"'Examples/roundboxes2.fig.uu'\" unpacked with wrong size!
fi
# end of 'Examples/roundboxes2.fig.uu'
fi
if test -f 'd_ellipse.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'d_ellipse.c'\"
else
echo shar: Extracting \"'d_ellipse.c'\" \(9045 characters\)
sed "s/^X//" >'d_ellipse.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both the copyright
X * notice and this permission notice appear in supporting documentation. 
X * No representations are made about the suitability of this software for 
X * any purpose.  It is provided "as is" without express or implied warranty."
X */
X
X#include "fig.h"
X#include "resources.h"
X#include "mode.h"
X#include "object.h"
X#include "paintop.h"
X#include "u_create.h"
X#include "u_elastic.h"
X#include "u_list.h"
X#include "w_canvas.h"
X#include "w_mousefun.h"
X
X/*************************  local procedures  ********************/
X
Xstatic int	init_ellipsebyradius_drawing();
Xstatic int	init_ellipsebydiameter_drawing();
Xstatic int	init_circlebyradius_drawing();
Xstatic int	init_circlebydiameter_drawing();
Xstatic int	create_ellipsebydia();
Xstatic int	create_ellipsebyrad();
Xstatic int	create_circlebyrad();
Xstatic int	create_circlebydia();
Xstatic int	cancel_ellipsebydia();
Xstatic int	cancel_ellipsebyrad();
Xstatic int	cancel_circlebyrad();
Xstatic int	cancel_circlebydia();
X
Xellipsebyradius_drawing_selected()
X{
X    canvas_kbd_proc = null_proc;
X    canvas_locmove_proc = null_proc;
X    canvas_leftbut_proc = init_ellipsebyradius_drawing;
X    canvas_middlebut_proc = null_proc;
X    canvas_rightbut_proc = null_proc;
X    set_cursor(arrow_cursor);
X    set_mousefun("center point", "", "");
X    reset_action_on();
X}
X
Xstatic
Xinit_ellipsebyradius_drawing(x, y)
X    int		    x, y;
X{
X    cur_x = fix_x = x;
X    cur_y = fix_y = y;
X    cur_angle = cur_elltextangle/180.0*M_PI;
X    center_marker(fix_x, fix_y);
X    set_mousefun("corner point", "", "cancel");
X    draw_mousefun_canvas();
X    canvas_locmove_proc = resizing_ebr;
X    canvas_rightbut_proc = cancel_ellipsebyrad;
X    canvas_leftbut_proc = create_ellipsebyrad;
X    set_temp_cursor(null_cursor);
X    elastic_ebr();
X    set_action_on();
X}
X
Xstatic
Xcancel_ellipsebyrad()
X{
X    elastic_ebr();
X    center_marker(fix_x, fix_y);
X    ellipsebyradius_drawing_selected();
X    draw_mousefun_canvas();
X}
X
Xstatic
Xcreate_ellipsebyrad(x, y)
X    int		    x, y;
X{
X    F_ellipse	   *ellipse;
X
X    elastic_ebr();
X    center_marker(fix_x, fix_y);
X    if ((ellipse = create_ellipse()) == NULL)
X	return;
X
X    ellipse->type = T_ELLIPSE_BY_RAD;
X    ellipse->style = cur_linestyle;
X    ellipse->thickness = cur_linewidth;
X    ellipse->style_val = cur_styleval * (cur_linewidth + 1) / 2;
X    ellipse->angle = cur_elltextangle/180.0*M_PI;	/* convert to radians */
X    ellipse->color = cur_color;
X    ellipse->depth = cur_depth;
X    ellipse->pen = 0;
X    ellipse->fill_style = cur_fillstyle;
X    ellipse->direction = 1;
X    ellipse->center.x = fix_x;
X    ellipse->center.y = fix_y;
X    ellipse->radiuses.x = abs(x - fix_x);
X    ellipse->radiuses.y = abs(y - fix_y);
X    ellipse->start.x = fix_x;
X    ellipse->start.y = fix_y;
X    ellipse->end.x = x;
X    ellipse->end.y = y;
X    ellipse->next = NULL;
X    draw_ellipse(ellipse, PAINT);
X    add_ellipse(ellipse);
X    ellipsebyradius_drawing_selected();
X    draw_mousefun_canvas();
X}
X
Xellipsebydiameter_drawing_selected()
X{
X    set_mousefun("first corner", "", "");
X    canvas_kbd_proc = null_proc;
X    canvas_locmove_proc = null_proc;
X    canvas_leftbut_proc = init_ellipsebydiameter_drawing;
X    canvas_middlebut_proc = null_proc;
X    canvas_rightbut_proc = null_proc;
X    set_cursor(arrow_cursor);
X    reset_action_on();
X}
X
Xstatic
Xinit_ellipsebydiameter_drawing(x, y)
X    int		    x, y;
X{
X    cur_x = fix_x = x;
X    cur_y = fix_y = y;
X    cur_angle = cur_elltextangle/180.0*M_PI;
X    center_marker(fix_x, fix_y);
X    set_mousefun("final corner", "", "cancel");
X    draw_mousefun_canvas();
X    canvas_locmove_proc = resizing_ebd;
X    canvas_rightbut_proc = cancel_ellipsebydia;
X    canvas_leftbut_proc = create_ellipsebydia;
X    set_temp_cursor(null_cursor);
X    elastic_ebd();
X    set_action_on();
X}
X
Xstatic
Xcancel_ellipsebydia()
X{
X    elastic_ebd();
X    center_marker(fix_x, fix_y);
X    ellipsebydiameter_drawing_selected();
X    draw_mousefun_canvas();
X}
X
Xstatic
Xcreate_ellipsebydia(x, y)
X    int		    x, y;
X{
X    F_ellipse	   *ellipse;
X
X    elastic_ebd();
X    center_marker(fix_x, fix_y);
X    if ((ellipse = create_ellipse()) == NULL)
X	return;
X
X    ellipse->type = T_ELLIPSE_BY_DIA;
X    ellipse->style = cur_linestyle;
X    ellipse->thickness = cur_linewidth;
X    ellipse->style_val = cur_styleval * (cur_linewidth + 1) / 2;
X    ellipse->angle = cur_elltextangle/180.0*M_PI;	/* convert to radians */
X    ellipse->color = cur_color;
X    ellipse->depth = cur_depth;
X    ellipse->pen = 0;
X    ellipse->fill_style = cur_fillstyle;
X    ellipse->direction = 1;
X    ellipse->center.x = (fix_x + x) / 2;
X    ellipse->center.y = (fix_y + y) / 2;
X    ellipse->radiuses.x = abs(ellipse->center.x - fix_x);
X    ellipse->radiuses.y = abs(ellipse->center.y - fix_y);
X    ellipse->start.x = fix_x;
X    ellipse->start.y = fix_y;
X    ellipse->end.x = x;
X    ellipse->end.y = y;
X    ellipse->next = NULL;
X    draw_ellipse(ellipse, PAINT);
X    add_ellipse(ellipse);
X    ellipsebydiameter_drawing_selected();
X    draw_mousefun_canvas();
X}
X
X/***************************  circle  section  ************************/
X
Xcirclebyradius_drawing_selected()
X{
X    set_mousefun("center point", "", "");
X    canvas_kbd_proc = null_proc;
X    canvas_locmove_proc = null_proc;
X    canvas_leftbut_proc = init_circlebyradius_drawing;
X    canvas_middlebut_proc = null_proc;
X    canvas_rightbut_proc = null_proc;
X    set_cursor(arrow_cursor);
X    reset_action_on();
X}
X
Xstatic
Xinit_circlebyradius_drawing(x, y)
X    int		    x, y;
X{
X    cur_x = fix_x = x;
X    cur_y = fix_y = y;
X    center_marker(fix_x, fix_y);
X    set_mousefun("set radius", "", "cancel");
X    draw_mousefun_canvas();
X    canvas_locmove_proc = resizing_cbr;
X    canvas_rightbut_proc = cancel_circlebyrad;
X    canvas_leftbut_proc = create_circlebyrad;
X    set_temp_cursor(null_cursor);
X    elastic_cbr();
X    set_action_on();
X}
X
Xstatic
Xcancel_circlebyrad()
X{
X    elastic_cbr();
X    center_marker(fix_x, fix_y);
X    circlebyradius_drawing_selected();
X    draw_mousefun_canvas();
X}
X
Xstatic
Xcreate_circlebyrad(x, y)
X    int		    x, y;
X{
X    F_ellipse	   *c;
X    int		    rx, ry;
X
X    elastic_cbr();
X    center_marker(fix_x, fix_y);
X    if ((c = create_ellipse()) == NULL)
X	return;
X
X    c->type = T_CIRCLE_BY_RAD;
X    c->style = cur_linestyle;
X    c->thickness = cur_linewidth;
X    c->style_val = cur_styleval * (cur_linewidth + 1) / 2;
X    c->angle = 0.0;
X    c->color = cur_color;
X    c->depth = cur_depth;
X    c->pen = 0;
X    c->fill_style = cur_fillstyle;
X    c->direction = 1;
X    c->center.x = fix_x;
X    c->center.y = fix_y;
X    rx = fix_x - x;
X    ry = fix_y - y;
X    c->radiuses.x = c->radiuses.y = round(sqrt((double) (rx * rx + ry * ry)));
X    c->start.x = fix_x;
X    c->start.y = fix_y;
X    c->end.x = x;
X    c->end.y = y;
X    c->next = NULL;
X    draw_ellipse(c, PAINT);
X    add_ellipse(c);
X    circlebyradius_drawing_selected();
X    draw_mousefun_canvas();
X}
X
Xcirclebydiameter_drawing_selected()
X{
X    set_mousefun("diameter point", "", "");
X    canvas_kbd_proc = null_proc;
X    canvas_locmove_proc = null_proc;
X    canvas_leftbut_proc = init_circlebydiameter_drawing;
X    canvas_middlebut_proc = null_proc;
X    canvas_rightbut_proc = null_proc;
X    set_cursor(arrow_cursor);
X    reset_action_on();
X}
X
Xstatic
Xinit_circlebydiameter_drawing(x, y)
X    int		    x, y;
X{
X    cur_x = fix_x = x;
X    cur_y = fix_y = y;
X    center_marker(fix_x, fix_y);
X    set_mousefun("final point", "", "cancel");
X    draw_mousefun_canvas();
X    canvas_locmove_proc = resizing_cbd;
X    canvas_leftbut_proc = create_circlebydia;
X    canvas_rightbut_proc = cancel_circlebydia;
X    set_temp_cursor(null_cursor);
X    elastic_cbd();
X    set_action_on();
X}
X
Xstatic
Xcancel_circlebydia()
X{
X    elastic_cbd();
X    center_marker(fix_x, fix_y);
X    circlebydiameter_drawing_selected();
X    draw_mousefun_canvas();
X}
X
Xstatic
Xcreate_circlebydia(x, y)
X    int		    x, y;
X{
X    F_ellipse	   *c;
X    int		    rx, ry;
X
X    elastic_cbd();
X    center_marker(fix_x, fix_y);
X    if ((c = create_ellipse()) == NULL)
X	return;
X
X    c->type = T_CIRCLE_BY_DIA;
X    c->style = cur_linestyle;
X    c->thickness = cur_linewidth;
X    c->style_val = cur_styleval * (cur_linewidth + 1) / 2;
X    c->angle = 0.0;
X    c->color = cur_color;
X    c->depth = cur_depth;
X    c->pen = 0;
X    c->fill_style = cur_fillstyle;
X    c->direction = 1;
X    c->center.x = (fix_x + x) / 2 + .5;
X    c->center.y = (fix_y + y) / 2 + .5;
X    rx = x - c->center.x;
X    ry = y - c->center.y;
X    c->radiuses.x = c->radiuses.y = round(sqrt((double) (rx * rx + ry * ry)));
X    c->start.x = fix_x;
X    c->start.y = fix_y;
X    c->end.x = x;
X    c->end.y = y;
X    c->next = NULL;
X    draw_ellipse(c, PAINT);
X    add_ellipse(c);
X    circlebydiameter_drawing_selected();
X    draw_mousefun_canvas();
X}
END_OF_FILE
if test 9045 -ne `wc -c <'d_ellipse.c'`; then
    echo shar: \"'d_ellipse.c'\" unpacked with wrong size!
fi
# end of 'd_ellipse.c'
fi
if test -f 'object.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'object.h'\"
else
echo shar: Extracting \"'object.h'\" \(8953 characters\)
sed "s/^X//" >'object.h' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both the copyright
X * notice and this permission notice appear in supporting documentation. 
X * No representations are made about the suitability of this software for 
X * any purpose.  It is provided "as is" without express or implied warranty."
X */
X
X#define		DEFAULT		      (-1)
X#define		SOLID_LINE		0
X#define		DASH_LINE		1
X#define		DOTTED_LINE		2
X#define		RUBBER_LINE		3
X#define		PANEL_LINE		4
X
X#define		Color			int
X
X#define		BLACK			0
X#define		WHITE			7
X
Xtypedef struct f_pattern {
X    int		    w, h;
X    int		   *p;
X}
X		F_pattern;
X
Xtypedef struct f_point {
X    int		    x, y;
X    struct f_point *next;
X}
X		F_point;
X
Xtypedef struct f_pos {
X    int		    x, y;
X}
X		F_pos;
X
Xtypedef struct f_arrow {
X    int		    type;
X    int		    style;
X    float	    thickness;
X    float	    wid;
X    float	    ht;
X}
X		F_arrow;
X
Xtypedef struct f_ellipse {
X    int		    tagged;
X    int		    type;
X#define					T_ELLIPSE_BY_RAD	1
X#define					T_ELLIPSE_BY_DIA	2
X#define					T_CIRCLE_BY_RAD		3
X#define					T_CIRCLE_BY_DIA		4
X    int		    style;
X    int		    thickness;
X    Color	    color;
X    int		    depth;
X    int		    direction;
X    float	    style_val;
X    float	    angle;
X    int		    pen;
X    int		    fill_style;
X#define					UNFILLED	0
X#define					WHITE_FILL	1
X#define					BLACK_FILL	21
X    struct f_pos    center;
X    struct f_pos    radiuses;
X    struct f_pos    start;
X    struct f_pos    end;
X    struct f_ellipse *next;
X}
X		F_ellipse;
X
Xtypedef struct f_arc {
X    int		    tagged;
X    int		    type;
X#define					T_3_POINTS_ARC		1
X    int		    style;
X    int		    thickness;
X    Color	    color;
X    int		    depth;
X    int		    pen;
X    int		    fill_style;
X    float	    style_val;
X    int		    direction;
X    struct f_arrow *for_arrow;
X    struct f_arrow *back_arrow;
X    struct {
X	float		x, y;
X    }		    center;
X    struct f_pos    point[3];
X    struct f_arc   *next;
X}
X		F_arc;
X
X#define		CLOSED_PATH		0
X#define		OPEN_PATH		1
X#define		DEF_BOXRADIUS		7
X#define		DEF_DASHLENGTH		4
X#define		DEF_DOTGAP		3
X
Xtypedef struct f_eps {
X    char	    file[PATH_MAX];
X    int		    flipped;
X    unsigned char  *bitmap;
X    float	    hw_ratio;
X    int		    size_x, size_y;
X    struct f_pos    bit_size;
X    Pixmap	    pixmap;
X    int		    pix_rotation, pix_width, pix_height, pix_flipped;
X}
X		F_eps;
X
Xextern char	EMPTY_EPS[];
X
Xtypedef struct f_line {
X    int		    tagged;
X    int		    type;
X#define					T_POLYLINE	1
X#define					T_BOX		2
X#define					T_POLYGON	3
X#define					T_ARC_BOX	4
X#define					T_EPS_BOX	5
X    int		    style;
X    int		    thickness;
X    Color	    color;
X    int		    depth;
X    float	    style_val;
X    int		    pen;
X    int		    fill_style;
X    int		    radius;	/* corner radius for T_ARC_BOX */
X    struct f_arrow *for_arrow;
X    struct f_arrow *back_arrow;
X    struct f_point *points;
X    struct f_eps   *eps;
X    struct f_line  *next;
X}
X		F_line;
X
Xtypedef struct f_text {
X    int		    tagged;
X    int		    type;
X#define					T_LEFT_JUSTIFIED	0
X#define					T_CENTER_JUSTIFIED	1
X#define					T_RIGHT_JUSTIFIED	2
X    int		    font;
X    PIX_ROT_FONT    fontstruct;
X    int		    size;	/* point size */
X    Color	    color;
X    int		    depth;
X    float	    angle;	/* in radian */
X
X    int		    flags;
X#define					RIGID_TEXT		1
X#define					SPECIAL_TEXT		2
X#define					PSFONT_TEXT		4
X#define					HIDDEN_TEXT		8
X
X    int		    height;	/* pixels */
X    int		    length;	/* pixels */
X    int		    base_x;
X    int		    base_y;
X    int		    pen;
X    char	   *cstring;
X    struct f_text  *next;
X}
X		F_text;
X
X#define MAXFONT(T) (psfont_text(T) ? NUM_PS_FONTS : NUM_LATEX_FONTS)
X
X#define		rigid_text(t) \
X			(t->flags == DEFAULT \
X				|| (t->flags & RIGID_TEXT))
X
X#define		special_text(t) \
X			((t->flags != DEFAULT \
X				&& (t->flags & SPECIAL_TEXT)))
X
X#define		psfont_text(t) \
X			(t->flags != DEFAULT \
X				&& (t->flags & PSFONT_TEXT))
X
X#define		hidden_text(t) \
X			(t->flags != DEFAULT \
X				&& (t->flags & HIDDEN_TEXT))
X
X#define		text_length(t) \
X			(hidden_text(t) ? hidden_text_length : t->length)
X
X#define		using_ps	(cur_textflags & PSFONT_TEXT)
X
Xtypedef struct f_control {
X    float	    lx, ly, rx, ry;
X    struct f_control *next;
X}
X		F_control;
X
X#define		int_spline(s)		(s->type & 0x2)
X#define		normal_spline(s)	(!(s->type & 0x2))
X#define		closed_spline(s)	(s->type & 0x1)
X#define		open_spline(s)		(!(s->type & 0x1))
X
Xtypedef struct f_spline {
X    int		    tagged;
X    int		    type;
X#define					T_OPEN_NORMAL	0
X#define					T_CLOSED_NORMAL 1
X#define					T_OPEN_INTERP	2
X#define					T_CLOSED_INTERP 3
X    int		    style;
X    int		    thickness;
X    Color	    color;
X    int		    depth;
X    float	    style_val;
X    int		    pen;
X    int		    fill_style;
X    struct f_arrow *for_arrow;
X    struct f_arrow *back_arrow;
X    /*
X     * For T_OPEN_NORMAL and T_CLOSED_NORMAL points are control points while
X     * they are knots for T_OPEN_INTERP and T_CLOSED_INTERP whose control
X     * points are stored in controls.
X     */
X    struct f_point *points;
X    struct f_control *controls;
X    struct f_spline *next;
X}
X		F_spline;
X
Xtypedef struct f_compound {
X    int		    tagged;
X    struct f_pos    nwcorner;
X    struct f_pos    secorner;
X    struct f_line  *lines;
X    struct f_ellipse *ellipses;
X    struct f_spline *splines;
X    struct f_text  *texts;
X    struct f_arc   *arcs;
X    struct f_compound *compounds;
X    struct f_compound *next;
X}
X		F_compound;
X
Xtypedef struct f_linkinfo {
X    struct f_line  *line;
X    struct f_point *endpt;
X    struct f_point *prevpt;
X    int		    two_pts;
X    struct f_linkinfo *next;
X}
X		F_linkinfo;
X
X#define		ARROW_SIZE		sizeof(struct f_arrow)
X#define		POINT_SIZE		sizeof(struct f_point)
X#define		CONTROL_SIZE		sizeof(struct f_control)
X#define		ELLOBJ_SIZE		sizeof(struct f_ellipse)
X#define		ARCOBJ_SIZE		sizeof(struct f_arc)
X#define		LINOBJ_SIZE		sizeof(struct f_line)
X#define		TEXOBJ_SIZE		sizeof(struct f_text)
X#define		SPLOBJ_SIZE		sizeof(struct f_spline)
X#define		COMOBJ_SIZE		sizeof(struct f_compound)
X#define		EPS_SIZE		sizeof(struct f_eps)
X#define		LINKINFO_SIZE		sizeof(struct f_linkinfo)
X
X/**********************  object codes  **********************/
X
X#define		O_ELLIPSE		1
X#define		O_POLYLINE		2
X#define		O_SPLINE		3
X#define		O_TEXT			4
X#define		O_ARC			5
X#define		O_COMPOUND		6
X#define		O_END_COMPOUND		-O_COMPOUND
X#define		O_ALL_OBJECT		99
X
X/********************* object masks for update  ************************/
X
X#define M_NONE			0x000
X#define M_POLYLINE_POLYGON	0x001
X#define M_POLYLINE_LINE		0x002
X#define M_POLYLINE_BOX		0x004	/* includes ARCBOX */
X#define M_SPLINE_O_NORMAL	0x008
X#define M_SPLINE_C_NORMAL	0x010
X#define M_SPLINE_O_INTERP	0x020
X#define M_SPLINE_C_INTERP	0x040
X#define M_TEXT_NORMAL		0x080
X#define M_TEXT_HIDDEN		0x100
X#define M_ARC			0x200
X#define M_ELLIPSE		0x400
X#define M_COMPOUND		0x800
X
X#define M_TEXT		(M_TEXT_HIDDEN | M_TEXT_NORMAL)
X#define M_SPLINE_O	(M_SPLINE_O_NORMAL | M_SPLINE_O_INTERP)
X#define M_SPLINE_C	(M_SPLINE_C_NORMAL | M_SPLINE_C_INTERP)
X#define M_SPLINE_NORMAL (M_SPLINE_O_NORMAL | M_SPLINE_C_NORMAL)
X#define M_SPLINE_INTERP (M_SPLINE_O_INTERP | M_SPLINE_C_INTERP)
X#define M_SPLINE	(M_SPLINE_NORMAL | M_SPLINE_INTERP)
X#define M_POLYLINE	(M_POLYLINE_LINE | M_POLYLINE_POLYGON | M_POLYLINE_BOX)
X#define M_VARPTS_OBJECT (M_POLYLINE_LINE | M_POLYLINE_POLYGON | M_SPLINE)
X#define M_OPEN_OBJECT	(M_POLYLINE_LINE | M_SPLINE_O | M_ARC)
X#define M_ROTATE_ANGLE	(M_VARPTS_OBJECT | M_ARC | M_TEXT | M_COMPOUND | M_ELLIPSE)
X#define M_ELLTEXTANGLE	(M_ELLIPSE | M_TEXT)
X#define M_OBJECT	(M_ELLIPSE | M_POLYLINE | M_SPLINE | M_TEXT | M_ARC)
X#define M_NO_TEXT	(M_ELLIPSE | M_POLYLINE | M_SPLINE | M_COMPOUND | M_ARC)
X#define M_ALL		(M_OBJECT | M_COMPOUND)
X
X/************************  Objects  **********************/
X
Xextern F_compound objects;
X
X/************  global working pointers ************/
X
Xextern F_line  *cur_l, *new_l, *old_l;
Xextern F_arc   *cur_a, *new_a, *old_a;
Xextern F_ellipse *cur_e, *new_e, *old_e;
Xextern F_text  *cur_t, *new_t, *old_t;
Xextern F_spline *cur_s, *new_s, *old_s;
Xextern F_compound *cur_c, *new_c, *old_c;
Xextern F_point *first_point, *cur_point;
Xextern F_linkinfo *cur_links;
X
X/*************** object attribute settings ***********/
X
X/*  Lines  */
Xextern int	cur_linewidth;
Xextern int	cur_linestyle;
Xextern float	cur_dashlength;
Xextern float	cur_dotgap;
Xextern float	cur_styleval;
Xextern int	pen_size;
Xextern int	pen_type;
Xextern Color	cur_color;
Xextern int	cur_boxradius;
Xextern int	cur_fillstyle;
Xextern int	cur_arrowmode;
X
X/* Text */
Xextern int	cur_fontsize;	/* font size */
Xextern int	cur_latex_font;
Xextern int	cur_ps_font;
Xextern int	cur_textjust;
Xextern int	cur_textflags;
X
X/* Misc */
Xextern float	cur_elltextangle;
END_OF_FILE
if test 8953 -ne `wc -c <'object.h'`; then
    echo shar: \"'object.h'\" unpacked with wrong size!
fi
# end of 'object.h'
fi
if test -f 'u_geom.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'u_geom.c'\"
else
echo shar: Extracting \"'u_geom.c'\" \(9088 characters\)
sed "s/^X//" >'u_geom.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both the copyright
X * notice and this permission notice appear in supporting documentation. 
X * No representations are made about the suitability of this software for 
X * any purpose.  It is provided "as is" without express or implied warranty."
X */
X
X/*
X * Routines dealing with geometry under the following headings:
X *	COMPUTE NORMAL, CLOSE TO VECTOR, COMPUTE ARC CENTER,
X *	COMPUTE ANGLE, COMPUTE DIRECTION, LATEX LINE ROUTINES.
X */
X
X#include "fig.h"
X#include "resources.h"
X#include "object.h"
X
X/*************************** COMPUTE NORMAL **********************
X
XInput arguments :
X	(x1,y1)(x2,y2) : the vector
X	direction : direction of the normal vector to (x1,y1)(x2,y2)
XOutput arguments :
X	(*x,*y)(x2,y2) : a normal vector.
XReturn value : none
X
X******************************************************************/
X
Xcompute_normal(x1, y1, x2, y2, direction, x, y)
X    float	    x1, y1;
X    int		    x2, y2, direction, *x, *y;
X{
X    if (direction) {		/* counter clockwise  */
X	*x = round(x2 - (y2 - y1));
X	*y = round(y2 - (x1 - x2));
X    } else {
X	*x = round(x2 + (y2 - y1));
X	*y = round(y2 + (x1 - x2));
X    }
X}
X
X/******************** CLOSE TO VECTOR **************************
X
XInput arguments:
X	(x1,y1)(x2,y2) : the vector
X	(xp,yp) : the point
X	d : tolerance (max. allowable distance from the point to the vector)
X	dd : d * d
XOutput arguments:
X	(*px,*py) : a point on the vector which is not far from (xp,yp)
X		by more than d. Normally the vector (*px,*py)(xp,yp)
X		is normal to vector (x1,y1)(x2,y2) except when (xp,yp)
X		is within d from (x1,y1) or (x2,y2), in which cases,
X		(*px,*py) = (x1,y1) or (x2,y2) respectively.
XReturn value :
X	0 : No point on the vector is within d from (xp, yp)
X	1 : (*px, *py) is such a point.
X
X******************************************************************/
X
Xclose_to_vector(x1, y1, x2, y2, xp, yp, d, dd, px, py)
X    int		    x1, y1, x2, y2, xp, yp, d;
X    float	    dd;
X    int		   *px, *py;
X{
X    int		    xmin, ymin, xmax, ymax;
X    float	    x, y, slope, D2, dx, dy;
X
X    if (abs(xp - x1) <= d && abs(yp - y1) <= d) {
X	*px = x1;
X	*py = y1;
X	return (1);
X    }
X    if (abs(xp - x2) <= d && abs(yp - y2) <= d) {
X	*px = x2;
X	*py = y2;
X	return (1);
X    }
X    if (x1 < x2) {
X	xmin = x1 - d;
X	xmax = x2 + d;
X    } else {
X	xmin = x2 - d;
X	xmax = x1 + d;
X    }
X    if (xp < xmin || xmax < xp)
X	return (0);
X
X    if (y1 < y2) {
X	ymin = y1 - d;
X	ymax = y2 + d;
X    } else {
X	ymin = y2 - d;
X	ymax = y1 + d;
X    }
X    if (yp < ymin || ymax < yp)
X	return (0);
X
X    if (x2 == x1) {
X	x = x1;
X	y = yp;
X    } else if (y1 == y2) {
X	x = xp;
X	y = y1;
X    } else {
X	slope = ((float) (x2 - x1)) / ((float) (y2 - y1));
X	y = (slope * (xp - x1 + slope * y1) + yp) / (1 + slope * slope);
X	x = ((float) x1) + slope * (y - y1);
X    }
X    dx = ((float) xp) - x;
X    dy = ((float) yp) - y;
X    D2 = dx * dx + dy * dy;
X    if (D2 < dd) {
X	*px = (int) (x + .5);
X	*py = (int) (y + .5);
X	return (1);
X    }
X    return (0);
X}
X
X/********************* COMPUTE ARC CENTER ******************
X
XInput arguments :
X	p1, p2, p3 : 3 points on the arc
XOutput arguments :
X	(*x,*y) : Center of the arc
XReturn value :
X	0 : if p1, p2, p3 are co-linear.
X	1 : if they are not.
X
X*************************************************************/
X
Xint
Xcompute_arccenter(p1, p2, p3, x, y)
X    F_pos	    p1, p2, p3;
X    float	   *x, *y;
X{
X    float	    s12, s13, len1, len2, len3, dx12, dy12, dx13, dy13;
X
X    if (p1.x == p3.x && p1.y == p3.y)
X	return 0;
X
X    dx12 = p1.x - p2.x;
X    dy12 = p1.y - p2.y;
X    dx13 = p1.x - p3.x;
X    dy13 = p1.y - p3.y;
X
X    s12 = asin((double) (dy12 / sqrt((double) (dx12 * dx12 + dy12 * dy12))));
X    s13 = asin((double) (dy13 / sqrt((double) (dx13 * dx13 + dy13 * dy13))));
X    if (fabs(s12 - s13) < .01)
X	return 0;
X
X    len1 = p1.x * p1.x + p1.y * p1.y;
X    len2 = p2.x * p2.x + p2.y * p2.y;
X    len3 = p3.x * p3.x + p3.y * p3.y;
X    *y = (dx12 * (len3 - len1) - dx13 * (len2 - len1)) /
X	(2 * (dx13 * dy12 - dx12 * dy13));
X    if (p1.x != p3.x)
X	*x = (len3 + 2 * (*y) * dy13 - len1) / (2 * (-dx13));
X    else
X	*x = (len2 + 2 * (*y) * dy12 - len1) / (2 * (-dx12));
X    return 1;
X}
X
X/********************* COMPUTE ANGLE ************************
X
XInput arguments :
X	(dx,dy) : the vector (0,0)(dx,dy)
XOutput arguments : none
XReturn value : the angle of the vector in the range [0, 2PI)
X
X*************************************************************/
X
Xfloat
Xcompute_angle(dx, dy)		/* compute the angle between 0 to 2PI  */
X    float	    dx, dy;
X{
X    float	    alpha;
X
X    if (dx == 0) {
X	if (dy > 0)
X	    alpha = M_PI_2;
X	else
X	    alpha = 3 * M_PI_2;
X    } else if (dy == 0) {
X	if (dx > 0)
X	    alpha = 0;
X	else
X	    alpha = M_PI;
X    } else {
X	alpha = atan((double) (dy / dx));	/* range = -PI/2 to PI/2 */
X	if (dx < 0)
X	    alpha += M_PI;
X	else if (dy < 0)
X	    alpha += M_2PI;
X    }
X    return (alpha);
X}
X
X
X/********************* COMPUTE DIRECTION ********************
X
XInput arguments :
X	p1, p2, p3 : 3 points of an arc with p1 the first and p3 the last.
XOutput arguments : none
XReturn value :
X	0 : if the arc passes p1, p2 and p3 (in that order) in
X		clockwise direction
X	1 : if direction is counterclockwise
X
X*************************************************************/
X
Xint
Xcompute_direction(p1, p2, p3)
X    F_pos	    p1, p2, p3;
X{
X    float	    diff, dx, dy, alpha, theta;
X
X    dx = p2.x - p1.x;
X    dy = p1.y - p2.y;		/* because origin of the screen is on the
X				 * upper left corner */
X
X    alpha = compute_angle(dx, dy);
X
X    dx = p3.x - p2.x;
X    dy = p2.y - p3.y;
X    theta = compute_angle(dx, dy);
X
X    diff = theta - alpha;
X    if ((0 < diff && diff < M_PI) || diff < -M_PI) {
X	return (1);		/* counterclockwise */
X    }
X    return (0);			/* clockwise */
X}
X
X/*********************** LATEX LINE ROUTINES ***************************/
X
Xint
Xpgcd(a, b)
X    int		    a, b;
X
X/*
X * compute greatest common divisor, assuming 0 < a <= b
X */
X{
X    b = b % a;
X    return (b) ? gcd(b, a) : a;
X}
X
Xint
Xgcd(a, b)
X    int		    a, b;
X
X/*
X * compute greatest common divisor
X */
X{
X    if (a < 0)
X	a = -a;
X    if (b < 0)
X	b = -b;
X    return (a <= b) ? pgcd(a, b) : pgcd(b, a);
X}
X
X
Xint
Xlcm(a, b)
X    int		    a, b;
X
X/*
X * compute least common multiple
X */
X{
X    return abs(a * b) / gcd(a, b);
X}
X
X
Xdouble		rad2deg = 57.295779513082320877;
X
Xstruct angle_table {
X    int		    x, y;
X    double	    angle;
X};
X
Xstruct angle_table line_angles[25] =
X{{0, 1, 90.0},
X{1, 0, 0.0},
X{1, 1, 45.0},
X{1, 2, 63.434948822922010648},
X{1, 3, 71.565051177077989351},
X{1, 4, 75.963756532073521417},
X{1, 5, 78.690067525979786913},
X{1, 6, 80.537677791974382609},
X{2, 1, 26.565051177077989351},
X{2, 3, 56.309932474020213086},
X{2, 5, 68.198590513648188229},
X{3, 1, 18.434948822922010648},
X{3, 2, 33.690067525979786913},
X{3, 4, 53.130102354155978703},
X{3, 5, 59.036243467926478582},
X{4, 1, 14.036243467926478588},
X{4, 3, 36.869897645844021297},
X{4, 5, 51.340191745909909396},
X{5, 1, 11.309932474020213086},
X{5, 2, 21.801409486351811770},
X{5, 3, 30.963756532073521417},
X{5, 4, 38.659808254090090604},
X{5, 6, 50.194428907734805993},
X{6, 1, 9.4623222080256173906},
X{6, 5, 39.805571092265194006}
X};
X
Xstruct angle_table arrow_angles[13] =
X{{0, 1, 90.0},
X{1, 0, 0.0},
X{1, 1, 45.0},
X{1, 2, 63.434948822922010648},
X{1, 3, 71.565051177077989351},
X{1, 4, 75.963756532073521417},
X{2, 1, 26.565051177077989351},
X{2, 3, 56.309932474020213086},
X{3, 1, 18.434948822922010648},
X{3, 2, 33.690067525979786913},
X{3, 4, 53.130102354155978703},
X{4, 1, 14.036243467926478588},
X{4, 3, 36.869897645844021297},
X};
X
Xget_slope(dx, dy, sxp, syp, arrow)
X    int		    dx, dy, *sxp, *syp, arrow;
X{
X    double	    angle;
X    int		    i, s, max;
X    double	    d, d1;
X    struct angle_table *st;
X
X    if (dx == 0) {
X	*sxp = 0;
X	*syp = signof(dy);
X	return;
X    }
X    angle = atan((double) abs(dy) / (double) abs(dx)) * rad2deg;
X    if (arrow) {
X	st = arrow_angles;
X	max = 13;
X    } else {
X	st = line_angles;
X	max = 25;
X    }
X    s = 0;
X    d = 9.9e9;
X    for (i = 0; i < max; i++) {
X	d1 = fabs(angle - st[i].angle);
X	if (d1 < d) {
X	    s = i;
X	    d = d1;
X	}
X    }
X    *sxp = st[s].x;
X    if (dx < 0)
X	*sxp = -*sxp;
X    *syp = st[s].y;
X    if (dy < 0)
X	*syp = -*syp;
X}
X
Xlatex_endpoint(x1, y1, x2, y2, xout, yout, arrow, magnet)
X    int		    x1, y1, x2, y2;
X    int		   *xout, *yout;
X    int		    arrow, magnet;
X{
X    int		    dx, dy, sx, sy, ds, dsx, dsy;
X
X    dx = x2 - x1;
X    dy = y2 - y1;
X    get_slope(dx, dy, &sx, &sy, arrow);
X    if (abs(sx) >= abs(sy)) {
X	ds = lcm(sx, magnet * gcd(sx, magnet));
X	dsx = (2 * abs(dx) / ds + 1) / 2;
X	dsx = (dx >= 0) ? dsx * ds : -dsx * ds;
X	*xout = x1 + dsx;
X	*yout = y1 + dsx * sy / sx;
X    } else {
X	ds = lcm(sy, magnet * gcd(sy, magnet));
X	dsy = (2 * abs(dy) / ds + 1) / 2;
X	dsy = (dy >= 0) ? dsy * ds : -dsy * ds;
X	*yout = y1 + dsy;
X	*xout = x1 + dsy * sx / sy;
X    }
X}
END_OF_FILE
if test 9088 -ne `wc -c <'u_geom.c'`; then
    echo shar: \"'u_geom.c'\" unpacked with wrong size!
fi
# end of 'u_geom.c'
fi
echo shar: End of archive 7 \(of 27\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 27 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM       | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@imd.sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
