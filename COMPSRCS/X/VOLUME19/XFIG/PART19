Newsgroups: comp.sources.x
From: envbvs@epb9.lbl.gov (Brian V. Smith)
Subject: v19i131:  xfig - Draw amd manipulate objects in an X-Window, Part19/27
Message-ID: <1993May21.021646.7033@sparky.imd.sterling.com>
X-Md4-Signature: 25398c7a76dcb530b0ef54e88b3344da
Sender: chris@sparky.imd.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Fri, 21 May 1993 02:16:46 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: envbvs@epb9.lbl.gov (Brian V. Smith)
Posting-number: Volume 19, Issue 131
Archive-name: xfig/part19
Environment: X11
Supersedes: xfig: Volume 16, Issue 6-30,39

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 19 (of 27)."
# Contents:  w_drawprim.c
# Wrapped by envbvs@epb9.lbl.gov.lbl.gov on Mon May  3 12:06:03 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'w_drawprim.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'w_drawprim.c'\"
else
echo shar: Extracting \"'w_drawprim.c'\" \(37827 characters\)
sed "s/^X//" >'w_drawprim.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X * Copyright (c) 1992 by Brian V. Smith
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both the copyright
X * notice and this permission notice appear in supporting documentation. 
X * No representations are made about the suitability of this software for 
X * any purpose.  It is provided "as is" without express or implied warranty."
X */
X
X/*
X * This file provides some drawing primitives which make use of the
X * underlying low-level windowing system operations.
X *
X * The file is divided into routines for:
X *
X * GRAPHICS CONTEXTS (which are used by all the following)
X * FONTS
X * LINES
X * SHADING
X */
X
X/* IMPORTS */
X
X#include "fig.h"
X#include "figx.h"
X#include "resources.h"
X#include "paintop.h"
X#include "mode.h"
X#include "object.h"
X#include "u_fonts.h"
X#include "w_canvas.h"
X#include "w_drawprim.h"
X#include "w_icons.h"		/* for none_ic in init_fill_pm */
X#include "w_indpanel.h"
X#include "w_setup.h"
X#include "w_util.h"
X#include "w_zoom.h"
X
Xextern struct _xfstruct x_fontinfo[NUM_X_FONTS];
Xextern struct _fstruct ps_fontinfo[];	/* font names */
Xextern choice_info fillstyle_choices[];
X
X/* EXPORTS */
X
XPIX_FONT	bold_font;
XPIX_FONT	roman_font;
XPIX_FONT	button_font;
XPIX_ROT_FONT	canvas_font;
X
X/* LOCAL */
X
Xstatic Pixel	gc_color[NUMOPS];
Xstatic XRectangle clip[1];
Xstatic pr_size	pfx_textwidth();
Xstatic int	parsesize();
X
X#define MAXNAMES 35
X
Xstatic struct {
X    char	   *fn;
X    int		    s;
X}		flist[MAXNAMES];
X
Xinit_font()
X{
X    struct xfont   *newfont, *nf;
X    int		    f, count, i, p, ss;
X    char	    template[200];
X    char	  **fontlist, **fname;
X
X    if (appres.boldFont == NULL || *appres.boldFont == '\0')
X	appres.boldFont = BOLD_FONT;
X    if (appres.normalFont == NULL || *appres.normalFont == '\0')
X	appres.normalFont = NORMAL_FONT;
X    if (appres.buttonFont == NULL || *appres.buttonFont == '\0')
X	appres.buttonFont = BUTTON_FONT;
X
X    roman_font = XLoadQueryFont(tool_d, appres.normalFont);
X    hidden_text_length = 4 * roman_font->max_bounds.width;
X    if ((bold_font = XLoadQueryFont(tool_d, appres.boldFont)) == 0) {
X	fprintf(stderr, "Can't load font: %s, using %s\n",
X		appres.boldFont, appres.normalFont);
X	bold_font = XLoadQueryFont(tool_d, appres.normalFont);
X    }
X    if ((button_font = XLoadQueryFont(tool_d, appres.buttonFont)) == 0) {
X	fprintf(stderr, "Can't load font: %s, using %s\n",
X		appres.buttonFont, appres.normalFont);
X	button_font = XLoadQueryFont(tool_d, appres.normalFont);
X    }
X    /*
X     * Now initialize the font structure for the X fonts corresponding to the
X     * Postscript fonts for the canvas.	 OpenWindows can use any LaserWriter
X     * fonts at any size, so we don't need to load anything if we are using
X     * it.
X     */
X
X#ifndef OPENWIN
X    /* if the user asked for scalable fonts, check that the server 
X       really has them by checking for font of 0-0 size */
X    if (appres.SCALABLEFONTS) {
X	strcpy(template,x_fontinfo[0].template);  /* just check the first font */
X	strcat(template,"0-0-*-*-*-*-*-*");
X	if ((fontlist = XListFonts(tool_d, template, 1, &count))==0)
X	    appres.SCALABLEFONTS = False;	/* none, turn off request for them */
X    }
X
X    /* X11R5 has scalable fonts - skip next section in that case */
X    if (!appres.SCALABLEFONTS) {
X	for (f = 0; f < NUM_X_FONTS; f++) {
X	    nf = NULL;
X	    strcpy(template,x_fontinfo[f].template);
X	    strcat(template,"*-*-*-*-*-*-");
X	    /* add ISO8859 (if not Symbol font or ZapfDingbats) to font name */
X	    if (strstr(template,"symbol") == NULL && 
X		strstr(template,"zapfdingbats") == NULL)
X		    strcat(template,"ISO8859-*");
X	    else
X		strcat(template,"*-*");
X	    /* don't free the Fontlist because we keep pointers into it */
X	    p = 0;
X	    if ((fontlist = XListFonts(tool_d, template, MAXNAMES, &count))==0) {
X		/* no fonts by that name found, substitute the -normal font name */
X		flist[p].fn = appres.normalFont;
X		flist[p++].s = 12;	/* just set the size to 12 */
X	    } else {
X		fname = fontlist; /* go through the list finding point
X				   * sizes */
X		while (count--) {
X		ss = parsesize(*fname);	/* get the point size from
X					 * the name */
X		flist[p].fn = *fname++;	/* save name of this size
X					 * font */
X		flist[p++].s = ss;	/* and save size */
X		}
X	    }
X	    for (ss = 4; ss <= 50; ss++) {
X		for (i = 0; i < p; i++)
X			if (flist[i].s == ss)
X			    break;
X		if (i < p && flist[i].s == ss) {
X			newfont = (struct xfont *) malloc(sizeof(struct xfont));
X			if (nf == NULL)
X			    x_fontinfo[f].xfontlist = newfont;
X			else
X			    nf->next = newfont;
X			nf = newfont;	/* keep current ptr */
X			nf->size = ss;	/* store the size here */
X			nf->fname = flist[i].fn;	/* keep actual name */
X			nf->list = NULL;
X			nf->next = NULL;
X		    }
X	    } /* next size */
X	} /* next font, f */
X    } /* !appres.SCALABLEFONTS */
X#endif /* OPENWIN */
X}
X
X/* parse the point size of font 'name' */
X/* e.g. -adobe-courier-bold-o-normal--10-100-75-75-m-60-ISO8859-1 */
X
Xstatic int
Xparsesize(name)
X    char	   *name;
X{
X    int		    s;
X    char	   *np;
X
X    for (np = name; *(np + 1); np++)
X	if (*np == '-' && *(np + 1) == '-')	/* look for the -- */
X	    break;
X    s = 0;
X    if (*(np + 1)) {
X	np += 2;		/* point past the -- */
X	s = atoi(np);		/* get the point size */
X    } else
X	fprintf(stderr, "Can't parse '%s'\n", name);
X    return s;
X}
X
X/*
X * Lookup an X font corresponding to a Postscript font style that is close in
X * size and with angle "angle"
X */
X
XPIX_ROT_FONT
Xlookfont(f, s, angle)
X    int		    f, s;
X    float	    angle;
X{
X    struct xfont   *xf;
X    PIX_ROT_FONT   fontst;
X    int		   dir;
X
X    /*** Must fix the following to actually return the "-normal font" ROTATED font */
X    if (f == DEFAULT)
X	f = 0;		/* pass back the -normal font font */
X    if (s < 0)
X	s = DEF_FONTSIZE;	/* default font size */
X
X#ifdef OPENWIN
X  {
X    /* to search for OpenWindows font - see below */
X    char	    fn[128];
X    int		    i;
X
X    for (i = 1; i < NUM_PS_FONTS + 1; i++)
X	if (ps_fontinfo[i].xfontnum == f)
X	    {
X	    sprintf(fn, "%s-%d", ps_fontinfo[i].name, s);
X	    break;
X	    }
X
X    for (i = strlen(fn) - 1; i >= 0; i--)
X	if (isupper(fn[i]))
X	    fn[i] = tolower(fn[i]);
X    if (appres.DEBUG)
X	fprintf(stderr, "Loading font %s\n", fn);
X    set_temp_cursor(wait_cursor);
X    app_flush();
X    fontst = XRotLoadFont(tool_d, fn, angle);
X    if (fontst == NULL) {
X	fprintf(stderr, "xfig: Can't load font %s ?!, using %s\n",
X		fn, appres.normalFont);
X	fontst = XRotLoadFont(tool_d, appres.normalFont, angle);
X    }
X    reset_cursor();
X    return (fontst);
X  }
X
X#else
X  {
X	char		fn[128];
X	char		template[200];
X	Boolean		found;
X	struct xfont   *newfont, *nf, *oldnf;
X	struct flist   *lp, *nlp, *oldlp;
X
X	/* see if we've already loaded that font size 's' at angle 'angle' 
X	   from the font family 'f' */
X	/* actually, we've reduced the number of angles to four - 0, 90, 180 and 270 */
X	if (angle < 0.0)
X		angle += 2.0*M_PI;
X	dir = (int)(angle/M_PI_2+0.0001);
X	if (dir > 3)
X		dir -= 4;
X	found = False;
X	/* start with the basic font name (e.g. adobe-times-medium-r-normal-...) */
X	nf = x_fontinfo[f].xfontlist;
X	oldnf = nf;
X	if (nf != NULL) {
X	    if (nf->size > s && !appres.SCALABLEFONTS)
X		found = True;
X	    else while (nf != NULL){
X	    if (nf->size == s || (!appres.SCALABLEFONTS &&
X		     (nf->size >= s && oldnf->size <= s ))) {
X		found = True;
X		break;
X	    }
X	    oldnf = nf;
X	    nf = nf->next;
X	    }
X	}
X	if (found) {		/* found exact size (or only larger available) */
X	    strcpy(fn,nf->fname);  /* put the name in fn */
X	    if (s < nf->size)
X		put_msg("Font size %d not found, using larger %d point",s,nf->size);
X	} else if (!appres.SCALABLEFONTS) {	/* not found, use largest available */
X	    nf = oldnf;
X	    strcpy(fn,nf->fname);  /* put the name in fn */
X	    if (s > nf->size)
X		put_msg("Font size %d not found, using smaller %d point",s,nf->size);
X	} else { /* SCALABLE; none yet of that size, alloc one and put it in the list */
X	    newfont = (struct xfont *) malloc(sizeof(struct xfont));
X	    /* add it on to the end of the list */
X	    if (x_fontinfo[f].xfontlist == NULL)
X	        x_fontinfo[f].xfontlist = newfont;
X	    else
X	        oldnf->next = newfont;
X	    nf = newfont;		/* keep current ptr */
X	    nf->size = s;		/* store the size here */
X	    nf->list = NULL;
X	    nf->next = NULL;
X
X	    /* create a full XLFD font name */
X	    strcpy(template,x_fontinfo[f].template);
X	    /* attach pointsize to font name */
X	    strcat(template,"%d-*-*-*-*-*-");
X	    /* add ISO8859 (if not Symbol font or ZapfDingbats) to font name */
X	    if (strstr(template,"symbol") == NULL && 
X		strstr(template,"zapfdingbats") == NULL)
X		    strcat(template,"ISO8859-*");
X	    else
X		strcat(template,"*-*");
X	    /* use the pixel field instead of points in the fontname so that the
X		font scales with screen size */
X	    sprintf(fn, template, s);
X	    /* allocate space for the name and put it in the structure */
X	    nf->fname = (char *) malloc(strlen(fn));
X	    strcpy(nf->fname, fn);
X	} /* if (!found) */
X	if (appres.DEBUG)
X	    fprintf(stderr, "Loading font %s at angle %f (%f)\n", 
X			fn, (float) dir*90.0, angle);
X	lp = nf->list;
X	oldlp = lp;
X	found = False;
X	while (lp) {
X		if (lp->dir == dir) {
X		    found = True;
X		    break;
X		}
X		oldlp = lp;
X		lp = lp->next;
X	} /* while (lp) */
X	if (!found) {
X		nlp = (struct flist *) malloc(sizeof(struct flist));
X		nlp->next = NULL;
X		if (oldlp)
X			oldlp->next = nlp;	/* add this to the list */
X		else
X			nf->list = nlp;		/* first on the list */
X		nlp->dir = dir;
X		set_temp_cursor(wait_cursor);
X		app_flush();
X		fontst = XRotLoadFont(tool_d, fn, (float) dir*90.0);
X		reset_cursor();
X		if (fontst == NULL) {
X		    fprintf(stderr, "xfig: Can't load font %s ?!, using %s\n",
X			fn, appres.normalFont);
X		    fontst = XRotLoadFont(tool_d, appres.normalFont, (float) dir*90.0);
X		    nf->fname = fn;	/* keep actual name */
X		}
X		/* put the structure in the list */
X		nlp->fstruct = fontst;
X		lp = nlp;
X	} /* if (!found) */
X	fontst = lp->fstruct;
X	return (fontst);
X  }
X
X#endif				/* !OPENWIN */
X
X}
X
X/* print "string" in window "w" using font specified in fstruct at (x,y) */
X
Xpw_text(w, x, y, op, fstruct, string, color)
X    Window	    w;
X    int		    x, y, op;
X    PIX_ROT_FONT    fstruct;
X    char	   *string;
X    Color	    color;
X{
X    if (fstruct == NULL)
X	fprintf(stderr,"Error, in pw_text, fstruct==NULL\n");
X    pwx_text(w, x, y, op, fstruct, string, color);
X}
X
Xpwx_text(w, x, y, op, fstruct, string, color)
X    Window	    w;
X    int		    x, y, op;
X    PIX_ROT_FONT    fstruct;
X    char	   *string;
X    Color	    color;
X{
X    /* if we're drawing to the bitmap instead of the canvas
X       map colors white => white, all others => black */
X    if (writing_bitmap)
X	{
X	if (color == WHITE)
X		color = 0;
X	else
X		color = 1;
X	}
X    if (writing_bitmap? color != gc_color[op] : x_color(color) != gc_color[op]) {
X	    if (op == PAINT) {
X		if (writing_bitmap)
X		    XSetForeground(tool_d,gccache[op],color);
X		else
X		    set_x_color(gccache[op], color);
X		gc_color[op] = writing_bitmap? color : x_color(color);
X	    }
X    }
X    zXRotDrawString(tool_d, w, fstruct, gccache[op], x, y, 
X		    string, strlen(string));
X}
X
Xpr_size
Xpf_textwidth(fstruct, n, s)
X    PIX_ROT_FONT    fstruct;
X    int		    n;
X    char	   *s;
X{
X    pr_size	    ret;
X
X    ret.x = XRotTextWidth(fstruct, s, n);
X    ret.y = XRotTextHeight(fstruct, s, n);
X    return (ret);
X}
X
X/* LINES */
X
Xstatic int	gc_thickness[NUMOPS], gc_line_style[NUMOPS];
X
Xstatic		GC
Xmakegc(op, fg, bg)
X    int		    op;
X    Pixel	    fg;
X    Pixel	    bg;
X{
X    register GC	    ngc;
X    XGCValues	    gcv;
X    unsigned long   gcmask;
X
X    gcv.font = roman_font->fid;
X    gcv.join_style = JoinMiter;
X    gcmask = GCJoinStyle | GCFunction | GCForeground | GCBackground | GCFont;
X    switch (op) {
X    case PAINT:
X	gcv.foreground = fg;
X	gcv.background = bg;
X	gcv.function = GXcopy;
X	break;
X    case ERASE:
X	gcv.foreground = bg;
X	gcv.background = bg;
X	gcv.function = GXcopy;
X	break;
X    case INV_PAINT:
X	gcv.foreground = fg ^ bg;
X	gcv.background = bg;
X	gcv.function = GXxor;
X	break;
X    case MERGE:
X	gcv.foreground = fg;
X	gcv.background = bg;
X	gcv.function = GXor;
X	break;
X    }
X
X    ngc = XCreateGC(tool_d, XtWindow(canvas_sw), gcmask, &gcv);
X    XCopyGC(tool_d, gc, ~(gcmask), ngc);	/* add main gc's values to
X						 * the new one */
X    return (ngc);
X}
X
Xinit_gc()
X{
X    int		    i;
X
X    gccache[PAINT] = makegc(PAINT, x_fg_color.pixel, x_bg_color.pixel);
X    gccache[ERASE] = makegc(ERASE, x_fg_color.pixel, x_bg_color.pixel);
X    gccache[INV_PAINT] = makegc(INV_PAINT, x_fg_color.pixel, x_bg_color.pixel);
X    gccache[MERGE] = makegc(MERGE, x_fg_color.pixel, x_bg_color.pixel);
X
X    for (i = 0; i < NUMOPS; i++) {
X	gc_color[i] = -1;
X	gc_thickness[i] = -1;
X	gc_line_style[i] = -1;
X    }
X}
X
X/* create the gc's for fill style (PAINT and ERASE) */
X/* the fill_pm[] and unfill_pm[] must already be created */
X
Xinit_fill_gc()
X{
X    XGCValues	    gcv;
X    int		    i;
X
X    gcv.fill_style = FillOpaqueStippled;
X    gcv.arc_mode = ArcPieSlice; /* fill mode for arcs */
X    gcv.fill_rule = EvenOddRule /* WindingRule */ ;
X    for (i = 0; i < NUMFILLPATS; i++) {
X	/* make color fill pattern with black bg (fg is set later in set_x_color() */
X	fill_gc[i] = makegc(PAINT, x_fg_color.pixel, x_color(BLACK));
X	un_fill_gc[i] = makegc(ERASE, x_fg_color.pixel, x_color(BLACK));
X	/* make black fill pattern with default background */
X	black_fill_gc[i] = makegc(PAINT, x_fg_color.pixel, x_bg_color.pixel);
X	black_un_fill_gc[i] = makegc(ERASE, x_fg_color.pixel, x_bg_color.pixel);
X	gcv.stipple = fill_pm[i];
X	XChangeGC(tool_d, fill_gc[i],
X		  GCStipple | GCFillStyle | GCFillRule | GCArcMode, &gcv);
X	XChangeGC(tool_d, black_fill_gc[i],
X		  GCStipple | GCFillStyle | GCFillRule | GCArcMode, &gcv);
X	XChangeGC(tool_d, un_fill_gc[i],
X		  GCStipple | GCFillStyle | GCArcMode, &gcv);
X	XChangeGC(tool_d, black_un_fill_gc[i],
X		  GCStipple | GCFillStyle | GCArcMode, &gcv);
X    }
X}
X
X/* SHADING */
X
X/* grey images for fill patterns (32x32) */
X
Xstatic unsigned char fill_images[NUMFILLPATS][128] = {
X {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
X {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x88,0x88,0x88,
X 0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08,
X 0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x88,
X 0x88,0x88,0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X 0x08,0x08,0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X 0x00,0x88,0x88,0x88,0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X 0x00,0x00,0x08,0x08,0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X 0x00,0x00,0x00,0x88,0x88,0x88,0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X 0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08},
X {0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x44,0x44,0x44,0x44,0x00,0x00,0x00,
X 0x00,0x01,0x11,0x01,0x11,0x00,0x00,0x00,0x00,0x44,0x44,0x44,0x44,0x00,0x00,
X 0x00,0x00,0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x44,0x44,0x44,0x44,0x00,
X 0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x44,0x44,0x44,0x44,
X 0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x44,0x44,0x44,
X 0x44,0x00,0x00,0x00,0x00,0x01,0x11,0x01,0x11,0x00,0x00,0x00,0x00,0x44,0x44,
X 0x44,0x44,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x44,
X 0x44,0x44,0x44,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,
X 0x44,0x44,0x44,0x44,0x00,0x00,0x00,0x00},
X {0x00,0x00,0x00,0x00,0x11,0x51,0x11,0x51,0x00,0x00,0x00,0x00,0x44,0x44,0x44,
X 0x44,0x00,0x00,0x00,0x00,0x15,0x15,0x15,0x15,0x00,0x00,0x00,0x00,0x44,0x44,
X 0x44,0x44,0x00,0x00,0x00,0x00,0x51,0x11,0x51,0x11,0x00,0x00,0x00,0x00,0x44,
X 0x44,0x44,0x44,0x00,0x00,0x00,0x00,0x15,0x15,0x15,0x15,0x00,0x00,0x00,0x00,
X 0x44,0x44,0x44,0x44,0x00,0x00,0x00,0x00,0x11,0x51,0x11,0x51,0x00,0x00,0x00,
X 0x00,0x44,0x44,0x44,0x44,0x00,0x00,0x00,0x00,0x15,0x15,0x15,0x15,0x00,0x00,
X 0x00,0x00,0x44,0x44,0x44,0x44,0x00,0x00,0x00,0x00,0x51,0x11,0x51,0x11,0x00,
X 0x00,0x00,0x00,0x44,0x44,0x44,0x44,0x00,0x00,0x00,0x00,0x15,0x15,0x15,0x15,
X 0x00,0x00,0x00,0x00,0x44,0x44,0x44,0x44},
X {0x00,0x00,0x00,0x00,0xaa,0xaa,0xaa,0xaa,0x00,0x00,0x00,0x00,0x8a,0x88,0x8a,
X 0x88,0x00,0x00,0x00,0x00,0xaa,0xaa,0xaa,0xaa,0x00,0x00,0x00,0x00,0x88,0x88,
X 0x88,0x88,0x00,0x00,0x00,0x00,0xaa,0xaa,0xaa,0xaa,0x00,0x00,0x00,0x00,0x8a,
X 0x8a,0x8a,0x8a,0x00,0x00,0x00,0x00,0xaa,0xaa,0xaa,0xaa,0x00,0x00,0x00,0x00,
X 0x88,0x88,0x88,0x88,0x00,0x00,0x00,0x00,0xaa,0xaa,0xaa,0xaa,0x00,0x00,0x00,
X 0x00,0x8a,0x88,0x8a,0x88,0x00,0x00,0x00,0x00,0xaa,0xaa,0xaa,0xaa,0x00,0x00,
X 0x00,0x00,0x88,0x88,0x88,0x88,0x00,0x00,0x00,0x00,0xaa,0xaa,0xaa,0xaa,0x00,
X 0x00,0x00,0x00,0x8a,0x8a,0x8a,0x8a,0x00,0x00,0x00,0x00,0xaa,0xaa,0xaa,0xaa,
X 0x00,0x00,0x00,0x00,0x88,0x88,0x88,0x88},
X {0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x55,0x55,0x55,0x55,0x00,0x00,0x00,
X 0x00,0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x55,0x55,0x55,0x55,0x00,0x00,
X 0x00,0x00,0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x55,0x55,0x55,0x55,0x00,
X 0x00,0x00,0x00,0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x55,0x55,0x55,0x55,
X 0x00,0x00,0x00,0x00,0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x55,0x55,0x55,
X 0x55,0x00,0x00,0x00,0x00,0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x55,0x55,
X 0x55,0x55,0x00,0x00,0x00,0x00,0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x55,
X 0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,
X 0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00},
X {0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x55,0x55,0x55,0x55,0x88,0x88,0x88,
X 0x88,0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x55,0x55,0x55,0x55,0x80,0x80,
X 0x80,0x80,0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x55,0x55,0x55,0x55,0x88,
X 0x88,0x88,0x88,0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x55,0x55,0x55,0x55,
X 0x88,0x80,0x88,0x80,0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x55,0x55,0x55,
X 0x55,0x88,0x88,0x88,0x88,0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x55,0x55,
X 0x55,0x55,0x80,0x80,0x80,0x80,0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,0x55,
X 0x55,0x55,0x55,0x88,0x88,0x88,0x88,0x55,0x55,0x55,0x55,0x00,0x00,0x00,0x00,
X 0x55,0x55,0x55,0x55,0x88,0x80,0x88,0x80},
X {0x22,0x22,0x22,0x22,0x55,0x55,0x55,0x55,0x80,0x80,0x80,0x80,0x55,0x55,0x55,
X 0x55,0x22,0x22,0x22,0x22,0x55,0x55,0x55,0x55,0x88,0x08,0x88,0x08,0x55,0x55,
X 0x55,0x55,0x22,0x22,0x22,0x22,0x55,0x55,0x55,0x55,0x80,0x80,0x80,0x80,0x55,
X 0x55,0x55,0x55,0x22,0x22,0x22,0x22,0x55,0x55,0x55,0x55,0x08,0x08,0x08,0x08,
X 0x55,0x55,0x55,0x55,0x22,0x22,0x22,0x22,0x55,0x55,0x55,0x55,0x80,0x80,0x80,
X 0x80,0x55,0x55,0x55,0x55,0x22,0x22,0x22,0x22,0x55,0x55,0x55,0x55,0x88,0x08,
X 0x88,0x08,0x55,0x55,0x55,0x55,0x22,0x22,0x22,0x22,0x55,0x55,0x55,0x55,0x80,
X 0x80,0x80,0x80,0x55,0x55,0x55,0x55,0x22,0x22,0x22,0x22,0x55,0x55,0x55,0x55,
X 0x08,0x08,0x08,0x08,0x55,0x55,0x55,0x55},
X {0x88,0x88,0x88,0x88,0x55,0x55,0x55,0x55,0x22,0xa2,0x22,0xa2,0x55,0x55,0x55,
X 0x55,0x88,0x88,0x88,0x88,0x55,0x55,0x55,0x55,0x2a,0x2a,0x2a,0x2a,0x55,0x55,
X 0x55,0x55,0x88,0x88,0x88,0x88,0x55,0x55,0x55,0x55,0xa2,0x22,0xa2,0x22,0x55,
X 0x55,0x55,0x55,0x88,0x88,0x88,0x88,0x55,0x55,0x55,0x55,0x2a,0x2a,0x2a,0x2a,
X 0x55,0x55,0x55,0x55,0x88,0x88,0x88,0x88,0x55,0x55,0x55,0x55,0x22,0xa2,0x22,
X 0xa2,0x55,0x55,0x55,0x55,0x88,0x88,0x88,0x88,0x55,0x55,0x55,0x55,0x2a,0x2a,
X 0x2a,0x2a,0x55,0x55,0x55,0x55,0x88,0x88,0x88,0x88,0x55,0x55,0x55,0x55,0xa2,
X 0x22,0xa2,0x22,0x55,0x55,0x55,0x55,0x88,0x88,0x88,0x88,0x55,0x55,0x55,0x55,
X 0x2a,0x2a,0x2a,0x2a,0x55,0x55,0x55,0x55},
X {0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa,0x54,0x54,0x54,
X 0x54,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa,0x44,0x44,
X 0x44,0x44,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa,0x44,
X 0x54,0x44,0x54,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa,
X 0x44,0x44,0x44,0x44,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,
X 0xaa,0x54,0x54,0x54,0x54,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,
X 0xaa,0xaa,0x44,0x44,0x44,0x44,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,
X 0xaa,0xaa,0xaa,0x44,0x54,0x44,0x54,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,
X 0xaa,0xaa,0xaa,0xaa,0x44,0x44,0x44,0x44},
X {0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,
X 0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,
X 0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,
X 0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,
X 0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,
X 0x55,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa,0x55,0x55,
X 0x55,0x55,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa,0x55,
X 0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa,
X 0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa},
X {0xdd,0xdd,0xdd,0xdd,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,
X 0xaa,0xd5,0xd5,0xd5,0xd5,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,0xaa,
X 0xaa,0xaa,0xdd,0xdd,0xdd,0xdd,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,0xaa,
X 0xaa,0xaa,0xaa,0xdd,0xd5,0xdd,0xd5,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,0x55,
X 0xaa,0xaa,0xaa,0xaa,0xdd,0xdd,0xdd,0xdd,0xaa,0xaa,0xaa,0xaa,0x55,0x55,0x55,
X 0x55,0xaa,0xaa,0xaa,0xaa,0xd5,0xd5,0xd5,0xd5,0xaa,0xaa,0xaa,0xaa,0x55,0x55,
X 0x55,0x55,0xaa,0xaa,0xaa,0xaa,0xdd,0xdd,0xdd,0xdd,0xaa,0xaa,0xaa,0xaa,0x55,
X 0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa,0xdd,0xd5,0xdd,0xd5,0xaa,0xaa,0xaa,0xaa,
X 0x55,0x55,0x55,0x55,0xaa,0xaa,0xaa,0xaa},
X {0x77,0x77,0x77,0x77,0xaa,0xaa,0xaa,0xaa,0xd5,0xd5,0xd5,0xd5,0xaa,0xaa,0xaa,
X 0xaa,0x77,0x77,0x77,0x77,0xaa,0xaa,0xaa,0xaa,0xdd,0x5d,0xdd,0x5d,0xaa,0xaa,
X 0xaa,0xaa,0x77,0x77,0x77,0x77,0xaa,0xaa,0xaa,0xaa,0xd5,0xd5,0xd5,0xd5,0xaa,
X 0xaa,0xaa,0xaa,0x77,0x77,0x77,0x77,0xaa,0xaa,0xaa,0xaa,0x5d,0xdd,0x5d,0xdd,
X 0xaa,0xaa,0xaa,0xaa,0x77,0x77,0x77,0x77,0xaa,0xaa,0xaa,0xaa,0xd5,0xd5,0xd5,
X 0xd5,0xaa,0xaa,0xaa,0xaa,0x77,0x77,0x77,0x77,0xaa,0xaa,0xaa,0xaa,0xdd,0x5d,
X 0xdd,0x5d,0xaa,0xaa,0xaa,0xaa,0x77,0x77,0x77,0x77,0xaa,0xaa,0xaa,0xaa,0xd5,
X 0xd5,0xd5,0xd5,0xaa,0xaa,0xaa,0xaa,0x77,0x77,0x77,0x77,0xaa,0xaa,0xaa,0xaa,
X 0x5d,0xdd,0x5d,0xdd,0xaa,0xaa,0xaa,0xaa},
X {0x55,0x55,0x55,0x55,0xbb,0xbb,0xbb,0xbb,0x55,0x55,0x55,0x55,0xfe,0xfe,0xfe,
X 0xfe,0x55,0x55,0x55,0x55,0xbb,0xbb,0xbb,0xbb,0x55,0x55,0x55,0x55,0xee,0xef,
X 0xee,0xef,0x55,0x55,0x55,0x55,0xbb,0xbb,0xbb,0xbb,0x55,0x55,0x55,0x55,0xfe,
X 0xfe,0xfe,0xfe,0x55,0x55,0x55,0x55,0xbb,0xbb,0xbb,0xbb,0x55,0x55,0x55,0x55,
X 0xef,0xef,0xef,0xef,0x55,0x55,0x55,0x55,0xbb,0xbb,0xbb,0xbb,0x55,0x55,0x55,
X 0x55,0xfe,0xfe,0xfe,0xfe,0x55,0x55,0x55,0x55,0xbb,0xbb,0xbb,0xbb,0x55,0x55,
X 0x55,0x55,0xee,0xef,0xee,0xef,0x55,0x55,0x55,0x55,0xbb,0xbb,0xbb,0xbb,0x55,
X 0x55,0x55,0x55,0xfe,0xfe,0xfe,0xfe,0x55,0x55,0x55,0x55,0xbb,0xbb,0xbb,0xbb,
X 0x55,0x55,0x55,0x55,0xef,0xef,0xef,0xef},
X {0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0x77,0x77,0x77,0x77,0xaa,0xaa,0xaa,
X 0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0x77,0x7f,0x77,0x7f,0xaa,0xaa,
X 0xaa,0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0x77,0x77,0x77,0x77,0xaa,
X 0xaa,0xaa,0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0x7f,0x7f,0x7f,0x7f,
X 0xaa,0xaa,0xaa,0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0x77,0x77,0x77,
X 0x77,0xaa,0xaa,0xaa,0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0x77,0x7f,
X 0x77,0x7f,0xaa,0xaa,0xaa,0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0x77,
X 0x77,0x77,0x77,0xaa,0xaa,0xaa,0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,
X 0x7f,0x7f,0x7f,0x7f,0xaa,0xaa,0xaa,0xaa},
X {0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,
X 0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,
X 0xaa,0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0xff,0xff,0xff,0xff,0xaa,
X 0xaa,0xaa,0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0xff,0xff,0xff,0xff,
X 0xaa,0xaa,0xaa,0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0xff,0xff,0xff,
X 0xff,0xaa,0xaa,0xaa,0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0xff,0xff,
X 0xff,0xff,0xaa,0xaa,0xaa,0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0xff,
X 0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa,
X 0xff,0xff,0xff,0xff,0xaa,0xaa,0xaa,0xaa},
X {0x55,0x55,0x55,0x55,0xff,0xff,0xff,0xff,0xdd,0xdd,0xdd,0xdd,0xff,0xff,0xff,
X 0xff,0x55,0x55,0x55,0x55,0xff,0xff,0xff,0xff,0x5d,0xdd,0x5d,0xdd,0xff,0xff,
X 0xff,0xff,0x55,0x55,0x55,0x55,0xff,0xff,0xff,0xff,0xdd,0xdd,0xdd,0xdd,0xff,
X 0xff,0xff,0xff,0x55,0x55,0x55,0x55,0xff,0xff,0xff,0xff,0x5d,0x5d,0x5d,0x5d,
X 0xff,0xff,0xff,0xff,0x55,0x55,0x55,0x55,0xff,0xff,0xff,0xff,0xdd,0xdd,0xdd,
X 0xdd,0xff,0xff,0xff,0xff,0x55,0x55,0x55,0x55,0xff,0xff,0xff,0xff,0x5d,0xdd,
X 0x5d,0xdd,0xff,0xff,0xff,0xff,0x55,0x55,0x55,0x55,0xff,0xff,0xff,0xff,0xdd,
X 0xdd,0xdd,0xdd,0xff,0xff,0xff,0xff,0x55,0x55,0x55,0x55,0xff,0xff,0xff,0xff,
X 0x5d,0x5d,0x5d,0x5d,0xff,0xff,0xff,0xff},
X {0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff,0xbb,0xba,0xba,0xba,0xff,0xff,0xff,
X 0xff,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff,0xab,0xbb,0xab,0xbb,0xff,0xff,
X 0xff,0xff,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff,0xbb,0xba,0xba,0xba,0xff,
X 0xff,0xff,0xff,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff,0xbb,0xab,0xbb,0xab,
X 0xff,0xff,0xff,0xff,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff,0xbb,0xba,0xba,
X 0xba,0xff,0xff,0xff,0xff,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff,0xab,0xbb,
X 0xab,0xbb,0xff,0xff,0xff,0xff,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff,0xbb,
X 0xba,0xba,0xba,0xff,0xff,0xff,0xff,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff,
X 0xbb,0xab,0xbb,0xab,0xff,0xff,0xff,0xff},
X {0xff,0xff,0xff,0xff,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff,0xfb,0xfb,0xfb,
X 0xfb,0xff,0xff,0xff,0xff,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff,0xbf,0xbb,
X 0xbf,0xbb,0xff,0xff,0xff,0xff,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff,0xfb,
X 0xfb,0xfb,0xfb,0xff,0xff,0xff,0xff,0xee,0xee,0xee,0xee,0xff,0xff,0xff,0xff,
X 0xbf,0xbf,0xbf,0xbf,0xff,0xff,0xff,0xff,0xee,0xee,0xee,0xee,0xff,0xff,0xff,
X 0xff,0xfb,0xfb,0xfb,0xfb,0xff,0xff,0xff,0xff,0xee,0xee,0xee,0xee,0xff,0xff,
X 0xff,0xff,0xbf,0xbb,0xbf,0xbb,0xff,0xff,0xff,0xff,0xee,0xee,0xee,0xee,0xff,
X 0xff,0xff,0xff,0xfb,0xfb,0xfb,0xfb,0xff,0xff,0xff,0xff,0xee,0xee,0xee,0xee,
X 0xff,0xff,0xff,0xff,0xbf,0xbf,0xbf,0xbf},
X {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xbb,0xbb,0xbb,
X 0xbb,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfb,0xfb,
X 0xfb,0xfb,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xbb,
X 0xbb,0xbb,0xbb,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
X 0xfb,0xfb,0xfb,0xfb,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
X 0xff,0xbb,0xbb,0xbb,0xbb,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
X 0xff,0xff,0xfb,0xfb,0xfb,0xfb,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
X 0xff,0xff,0xff,0xbb,0xbb,0xbb,0xbb,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
X 0xff,0xff,0xff,0xff,0xfb,0xfb,0xfb,0xfb},
X {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
X 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
X 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
X 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
X 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
X 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
X 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
X 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
X 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff},
X};
X
X/* generate the fill pixmaps */
X
Xinit_fill_pm()
X{
X    int		    i;
X
X    for (i = 0; i < NUMFILLPATS + 1; i++) {
X	fillstyle_choices[i].value = i;
X	fillstyle_choices[i].icon = &none_ic;
X    }
X    /* use same colors for "NONE" indicator for black and color */
X    fillstyle_choices[0].normalPM = 
X	fillstyle_choices[0].blackPM = XCreatePixmapFromBitmapData(tool_d,
X			XtWindow(ind_panel), (char *) none_ic.data, none_ic.width,
X			none_ic.height, x_fg_color.pixel, x_bg_color.pixel,
X			DefaultDepthOfScreen(tool_s));
X
X    for (i = 0; i < NUMFILLPATS; i++) {
X	fill_pm[i] = XCreateBitmapFromData(tool_d, XtWindow(canvas_sw),
X					   (char *) fill_images[i], 32, 32);
X	/* create fill style pixmaps for indicator button */
X	fillstyle_choices[i + 1].normalPM = XCreatePixmapFromBitmapData(tool_d,
X		 XtWindow(canvas_sw), (char *) fill_images[i], 32, 32, 
X		 x_bg_color.pixel,x_fg_color.pixel,DefaultDepthOfScreen(tool_s));
X	fillstyle_choices[i + 1].blackPM = XCreatePixmapFromBitmapData(tool_d,
X		 XtWindow(canvas_sw), (char *) fill_images[i], 32, 32, 
X		 x_fg_color.pixel,x_bg_color.pixel,DefaultDepthOfScreen(tool_s));
X    }
X}
X
Xpw_vector(w, x1, y1, x2, y2, op, line_width, line_style, style_val, color)
X    Window	    w;
X    int		    x1, y1, x2, y2, op, line_width, line_style;
X    float	    style_val;
X    Color	    color;
X{
X    if (line_width == 0)
X	return;
X    set_line_stuff(line_width, line_style, style_val, op, color);
X    if (line_style == PANEL_LINE)
X	XDrawLine(tool_d, w, gccache[op], x1, y1, x2, y2);
X    else
X	zXDrawLine(tool_d, w, gccache[op], x1, y1, x2, y2);
X}
X
Xpw_curve(w, xstart, ystart, xend, yend,
X	 op, linewidth, style, style_val, fill_style, color)
X    Window	    w;
X    int		    xstart, ystart, xend, yend;
X    int		    op, linewidth, style, fill_style;
X    float	    style_val;
X    Color	    color;
X{
X    short	    xmin, ymin;
X    unsigned short  wd, ht;
X
X    xmin = (short) min2(xstart, xend);
X    ymin = (short) min2(ystart, yend);
X    wd = (unsigned short) abs(xstart - xend);
X    ht = (unsigned short) abs(ystart - yend);
X
X    /* if it's a fill pat we know about */
X    if (fill_style >= 1 && fill_style <= NUMFILLPATS) {
X	set_fillgc(fill_style, op, color);
X	zXFillArc(tool_d, w, fillgc, xmin, ymin, wd, ht, 0, 360 * 64);
X    }
X    if (linewidth == 0)
X	return;
X    if (op == ERASE) {
X	/* kludge - to speed things up we erase with thick solid lines */
X	set_line_stuff(linewidth + 3, SOLID_LINE, 0.0, op, color);	/* +2 or +3 ok */
X	zXDrawArc(tool_d, w, gccache[op], xmin, ymin, wd, ht, 0, 360 * 64);
X    } else {
X	set_line_stuff(linewidth, style, style_val, op, color);
X	zXDrawArc(tool_d, w, gccache[op], xmin, ymin, wd, ht, 0, 360 * 64);
X    }
X}
X
Xpw_point(w, x, y, line_width, op, color)
X    Window	    w;
X    int		    x, y;
X    int		    op, line_width;
X    Color	    color;
X{
X    /* pw_point doesn't use line_style or fill_style - maybe not needed */
X    /* (needs color though - hns) */
X    set_line_stuff(line_width, SOLID_LINE, 0.0, op, color);
X    zXDrawPoint(tool_d, w, gccache[op], x, y);
X}
X
Xpw_arcbox(w, xmin, ymin, xmax, ymax, radius, op,
X	  line_width, line_style, style_val, fill_style, color)
X    Window	    w;
X    int		    xmin, ymin, xmax, ymax, radius;
X    int		    op, line_width, line_style, fill_style;
X    float	    style_val;
X    Color	    color;
X{
X    GC		    gc;
X    int		    diam = 2 * radius;
X
X    /* if it's a fill pat we know about */
X    if (fill_style >= 1 && fill_style <= NUMFILLPATS) {
X	set_fillgc(fill_style, op, color);
X	/* upper left */
X	zXFillArc(tool_d, w, fillgc, xmin, ymin, diam, diam, 90 * 64, 90 * 64);
X	/* lower left */
X	zXFillArc(tool_d, w, fillgc, xmin, ymax - diam, diam, diam,
X		  180 * 64, 90 * 64);
X	/* lower right */
X	zXFillArc(tool_d, w, fillgc, xmax - diam, ymax - diam, diam, diam,
X		  270 * 64, 90 * 64);
X	/* upper right */
X	zXFillArc(tool_d, w, fillgc, xmax - diam, ymin, diam, diam,
X		  0 * 64, 90 * 64);
X	/* fill strip on left side between upper and lower arcs */
X	if (ymax - ymin - diam > 0)
X	    zXFillRectangle(tool_d, w, fillgc, xmin, ymin + radius, radius,
X			    ymax - ymin - diam);
X	/* fill middle section */
X	if (xmax - xmin - diam > 0)
X	    zXFillRectangle(tool_d, w, fillgc, xmin + radius, ymin,
X			    xmax - xmin - diam, ymax - ymin);
X	/* fill strip on right side between upper and lower arcs */
X	if (ymax - ymin - diam > 0)
X	    zXFillRectangle(tool_d, w, fillgc, xmax - radius, ymin + radius,
X			    radius, ymax - ymin - diam);
X    }
X    if (line_width == 0)
X	return;
X
X    set_line_stuff(line_width, line_style, style_val, op, color);
X    gc = gccache[op];
X    zXDrawArc(tool_d, w, gc, xmin, ymin, diam, diam, 90 * 64, 90 * 64);
X    zXDrawLine(tool_d, w, gc, xmin, ymin + radius, xmin, ymax - radius + 1);
X    zXDrawArc(tool_d, w, gc, xmin, ymax - diam, diam, diam, 180 * 64, 90 * 64);
X    zXDrawLine(tool_d, w, gc, xmin + radius, ymax, xmax - radius + 1, ymax);
X    zXDrawArc(tool_d, w, gc, xmax - diam, ymax - diam,
X	      diam, diam, 270 * 64, 90 * 64);
X    zXDrawLine(tool_d, w, gc, xmax, ymax - radius, xmax, ymin + radius - 1);
X    zXDrawArc(tool_d, w, gc, xmax - diam, ymin, diam, diam, 0 * 64, 90 * 64);
X    zXDrawLine(tool_d, w, gc, xmax - radius, ymin, xmin + radius - 1, ymin);
X}
X
Xpw_lines(w, points, npoints, op, line_width, line_style, style_val, fill_style, color)
X    Window	    w;
X    int		    npoints;
X    XPoint	   *points;
X    int		    op, line_width, line_style, fill_style;
X    float	    style_val;
X    Color	    color;
X{
X    /* if it's a fill pat we know about */
X    if (fill_style >= 1 && fill_style <= NUMFILLPATS) {
X	set_fillgc(fill_style, op, color);
X	if (line_style == PANEL_LINE)
X	    XFillPolygon(tool_d, w, fillgc, points, npoints,
X			 Complex, CoordModeOrigin);
X	else
X	    zXFillPolygon(tool_d, w, fillgc, points, npoints,
X			  Complex, CoordModeOrigin);
X    }
X    if (line_width == 0)
X	return;
X    set_line_stuff(line_width, line_style, style_val, op, color);
X    if (line_style == PANEL_LINE)
X	XDrawLines(tool_d, w, gccache[op], points, npoints, CoordModeOrigin);
X    else
X	zXDrawLines(tool_d, w, gccache[op], points, npoints, CoordModeOrigin);
X}
X
Xset_clip_window(xmin, ymin, xmax, ymax)
X    int		    xmin, ymin, xmax, ymax;
X{
X    clip_xmin = clip[0].x = xmin;
X    clip_ymin = clip[0].y = ymin;
X    clip_xmax = xmax;
X    clip_ymax = ymax;
X    clip_width = clip[0].width = xmax - xmin;
X    clip_height = clip[0].height = ymax - ymin;
X    XSetClipRectangles(tool_d, gccache[PAINT], 0, 0, clip, 1, YXBanded);
X    XSetClipRectangles(tool_d, gccache[INV_PAINT], 0, 0, clip, 1, YXBanded);
X}
X
Xset_zoomed_clip_window(xmin, ymin, xmax, ymax)
X    int		    xmin, ymin, xmax, ymax;
X{
X    set_clip_window(ZOOMX(xmin), ZOOMY(ymin), ZOOMX(xmax), ZOOMY(ymax));
X}
X
Xreset_clip_window()
X{
X    set_clip_window(0, 0, CANVAS_WD, CANVAS_HT);
X}
X
Xset_fillgc(fill_style, op, color)
X    int		    fill_style;
X    int		    op;
X    Color	    color;
X{
X    if (op == PAINT) {
X	fillgc = ((color==BLACK || 
X	     (color==DEFAULT_COLOR && x_fg_color.pixel==appres.color[BLACK]) ||
X	     (!all_colors_available && color!=WHITE))? 
X		black_fill_gc[fill_style - 1]: fill_gc[fill_style - 1]);
X	if (writing_bitmap)
X	    {
X	    if (color == WHITE)
X		color = 0;
X	    else
X		color = 1;
X	    XSetForeground(tool_d,fillgc,color);
X	    }
X	else
X	    set_x_color(fillgc, color);
X    } else
X	fillgc = ((color==BLACK || 
X	     (color==DEFAULT_COLOR && x_fg_color.pixel==appres.color[BLACK]) ||
X	     (!all_colors_available && color!=WHITE))? 
X		black_un_fill_gc[fill_style - 1]: un_fill_gc[fill_style - 1]);
X    XSetClipRectangles(tool_d, fillgc, 0, 0, clip, 1, YXBanded);
X}
X
Xset_line_stuff(width, style, style_val, op, color)
X    int		    width, style, op;
X    float	    style_val;
X    Color	    color;
X{
X    XGCValues	    gcv;
X    unsigned long   mask;
X    static unsigned char dash_list[2] = {-1, -1};
X
X    switch (style) {
X    case RUBBER_LINE:
X	width = 0;
X	break;
X    case PANEL_LINE:
X	break;
X    default:
X	width = round(zoomscale * width);
X	break;
X    }
X
X    /* user zero-width lines for speed with SOLID lines */
X    /* can't do this for dashed lines because server isn't */
X    /* required to draw dashes for zero-width lines */
X    if (width == 1 && style == SOLID_LINE)
X	width = 0;
X
X    /* if we're drawing to the bitmap instead of the canvas
X       map colors white => white, all others => black */
X    if (writing_bitmap)
X	{
X	if (color == WHITE)
X		color = 0;
X	else
X		color = 1;
X	}
X    /* see if all gc stuff is already correct */
X
X    if (width == gc_thickness[op] && style == gc_line_style[op] &&
X	(writing_bitmap? color == gc_color[op] : x_color(color) == gc_color[op]) &&
X	(style != DASH_LINE && style != DOTTED_LINE ||
X	 dash_list[1] == (char) round(style_val * zoomscale)))
X	return;			/* no need to change anything */
X
X    gcv.line_width = width;
X    mask = GCLineWidth | GCLineStyle | GCCapStyle;
X    if (op == PAINT)
X	mask |= GCForeground;
X    gcv.line_style = (style == DASH_LINE || style == DOTTED_LINE) ?
X	LineOnOffDash : LineSolid;
X    gcv.cap_style = (style == DOTTED_LINE) ? CapRound : CapButt;
X    gcv.foreground = (writing_bitmap? color : x_color(color));
X
X    XChangeGC(tool_d, gccache[op], mask, &gcv);
X    if (style == DASH_LINE || style == DOTTED_LINE) {
X	if (style_val > 0.0) {	/* style_val of 0.0 causes problems */
X	    /* length of ON/OFF pixels */
X	    dash_list[0] = dash_list[1] = (char) round(style_val *zoomscale);
X	    if (dash_list[0]==0)		/* take care for rounding to zero ! */
X		dash_list[0]=dash_list[1]=1;
X
X	    if (style == DOTTED_LINE)
X		dash_list[0] = 1;	/* length of ON pixels for dotted */
X	    XSetDashes(tool_d, gccache[op], 0, (char *) dash_list, 2);
X	}
X    }
X    gc_thickness[op] = width;
X    gc_line_style[op] = style;
X    gc_color[op] = writing_bitmap? color : x_color(color);
X}
END_OF_FILE
if test 37827 -ne `wc -c <'w_drawprim.c'`; then
    echo shar: \"'w_drawprim.c'\" unpacked with wrong size!
fi
# end of 'w_drawprim.c'
fi
echo shar: End of archive 19 \(of 27\).
cp /dev/null ark19isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 27 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM       | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@imd.sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
