Newsgroups: comp.sources.x
From: envbvs@epb9.lbl.gov (Brian V. Smith)
Subject: v19i125:  xfig - Draw amd manipulate objects in an X-Window, Part13/27
Message-ID: <1993May21.021510.6255@sparky.imd.sterling.com>
X-Md4-Signature: 95ef26403d95a1dc6ac32a38c3594e95
Sender: chris@sparky.imd.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Fri, 21 May 1993 02:15:10 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: envbvs@epb9.lbl.gov (Brian V. Smith)
Posting-number: Volume 19, Issue 125
Archive-name: xfig/part13
Environment: X11
Supersedes: xfig: Volume 16, Issue 6-30,39

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 13 (of 27)."
# Contents:  e_movept.c u_list.c u_search.c
# Wrapped by envbvs@epb9.lbl.gov.lbl.gov on Mon May  3 12:05:56 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'e_movept.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'e_movept.c'\"
else
echo shar: Extracting \"'e_movept.c'\" \(19377 characters\)
sed "s/^X//" >'e_movept.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both the copyright
X * notice and this permission notice appear in supporting documentation. 
X * No representations are made about the suitability of this software for 
X * any purpose.  It is provided "as is" without express or implied warranty."
X */
X
X#include "fig.h"
X#include "resources.h"
X#include "mode.h"
X#include "object.h"
X#include "paintop.h"
X#include "u_draw.h"
X#include "u_search.h"
X#include "u_create.h"
X#include "u_elastic.h"
X#include "u_list.h"
X#include "u_undo.h"
X#include "w_canvas.h"
X#include "w_mousefun.h"
X
Xextern void     force_anglegeom(), force_noanglegeom();
X
X/* local routine declarations */
X
Xstatic F_point *moved_point;
X
Xstatic Boolean	init_ellipsepointmoving();
Xstatic int	init_arcpointmoving();
Xstatic int	init_linepointmoving();
Xstatic int	init_splinepointmoving();
Xstatic int	init_compoundpointmoving();
X
Xstatic int	relocate_arcpoint();
Xstatic int	relocate_ellipsepoint();
Xstatic int	relocate_linepoint();
Xstatic int	relocate_splinepoint();
Xstatic int	assign_newboxpoint();
X
Xstatic int	init_move_point();
Xstatic int	init_arb_move_point();
Xstatic int	init_stretch_move_point();
X
Xstatic int	fix_movedarcpoint();
Xstatic int	fix_movedellipsepoint();
Xstatic int	fix_movedsplinepoint();
Xstatic int	fix_box();
Xstatic int	fix_movedlinepoint();
Xstatic int	fix_movedlatexlinepoint();
X
Xstatic int	cancel_movedarcpoint();
Xstatic int	cancel_movedellipsepoint();
Xstatic int	cancel_movedsplinepoint();
Xstatic int	cancel_box();
Xstatic int	cancel_movedlinepoint();
X
Xmove_point_selected()
X{
X    set_mousefun("move point", "horiz/vert move", "");
X    canvas_kbd_proc = null_proc;
X    canvas_locmove_proc = null_proc;
X    init_searchproc_left(init_arb_move_point);
X    init_searchproc_middle(init_stretch_move_point);
X    canvas_leftbut_proc = point_search_left;
X    canvas_middlebut_proc = point_search_middle;
X    canvas_rightbut_proc = null_proc;
X    set_cursor(pick9_cursor);
X    force_anglegeom();
X}
X
Xstatic
Xinit_arb_move_point(obj, type, x, y, p, q)
X    char	   *obj;
X    int		    type, x, y;
X    F_point	   *p, *q;
X{
X    constrained = MOVE_ARB;
X    init_move_point(obj, type, x, y, p, q);
X    set_mousefun("new posn", "", "cancel");
X    draw_mousefun_canvas();
X    canvas_middlebut_proc = null_proc;
X}
X
Xstatic
Xinit_stretch_move_point(obj, type, x, y, p, q)
X    char	   *obj;
X    int		    type, x, y;
X    F_point	   *p, *q;
X{
X    constrained = MOVE_HORIZ_VERT;
X    init_move_point(obj, type, x, y, p, q);
X    set_mousefun("", "new posn", "cancel");
X    draw_mousefun_canvas();
X    canvas_middlebut_proc = canvas_leftbut_proc;
X    canvas_leftbut_proc = null_proc;
X}
X
Xstatic
Xinit_move_point(obj, type, x, y, p, q)
X    char	   *obj;
X    int		    type, x, y;
X    F_point	   *p, *q;
X{
X    left_point = p;
X    moved_point = q;
X    switch (type) {
X    case O_POLYLINE:
X	cur_l = (F_line *) obj;
X	right_point = q->next;
X	init_linepointmoving();
X	break;
X    case O_SPLINE:
X	cur_s = (F_spline *) obj;
X	right_point = q->next;
X	init_splinepointmoving();
X	break;
X    case O_ELLIPSE:
X	force_noanglegeom();
X	/* dirty trick - arcpoint_num is stored in p */
X	movedpoint_num = (int) p;
X	cur_e = (F_ellipse *) obj;
X	if (!init_ellipsepointmoving()) /* selected center, ignore */
X	    return;
X	break;
X    case O_ARC:
X	force_noanglegeom();
X	/* dirty trick - arcpoint_num is stored in p */
X	movedpoint_num = (int) p;
X	cur_a = (F_arc *) obj;
X	init_arcpointmoving();
X	break;
X    case O_COMPOUND:
X	force_noanglegeom();
X	/* dirty trick - posn of corner is stored in p and q */
X	cur_x = (int) p;
X	cur_y = (int) q;
X	cur_c = (F_compound *) obj;
X	init_compoundpointmoving();
X	break;
X    default:
X	return;
X    }
X}
X
Xstatic
Xwrapup_movepoint()
X{
X    reset_action_on();
X    move_point_selected();
X    draw_mousefun_canvas();
X}
X
X/*************************  ellipse  *******************************/
X
Xstatic		Boolean
Xinit_ellipsepointmoving()
X{
X    double	    dx, dy, l;
X
X    if (constrained &&
X	(cur_e->type == T_CIRCLE_BY_DIA || cur_e->type == T_CIRCLE_BY_RAD)) {
X	put_msg("Constrained move not supported for CIRCLES");
X	return False;		/* abort - constrained move for circle not
X				 * needed */
X    }
X    if (movedpoint_num == 0) {
X	if (cur_e->type == T_ELLIPSE_BY_RAD ||
X	    cur_e->type == T_CIRCLE_BY_RAD) {
X	    put_msg("Cannot move CENTER point");
X	    return False;	/* abort - center point is selected */
X	}
X	cur_x = cur_e->start.x;
X	cur_y = cur_e->start.y;
X	fix_x = cur_e->end.x;
X	fix_y = cur_e->end.y;
X    } else {
X	cur_x = cur_e->end.x;
X	cur_y = cur_e->end.y;
X	fix_x = cur_e->start.x;
X	fix_y = cur_e->start.y;
X    }
X    if (constrained) {
X	dx = cur_x - fix_x;
X	dy = cur_y - fix_y;
X	l = sqrt(dx * dx + dy * dy);
X	cosa = fabs(dx / l);
X	sina = fabs(dy / l);
X    }
X    cur_angle = cur_e->angle;
X    set_action_on();
X    toggle_ellipsemarker(cur_e);
X    draw_ellipse(cur_e, ERASE);
X    switch (cur_e->type) {
X    case T_ELLIPSE_BY_RAD:
X	canvas_locmove_proc = constrained_resizing_ebr;
X	elastic_ebr();
X	break;
X    case T_CIRCLE_BY_RAD:
X	canvas_locmove_proc = resizing_cbr;
X	elastic_cbr();
X	break;
X    case T_ELLIPSE_BY_DIA:
X	canvas_locmove_proc = constrained_resizing_ebd;
X	elastic_ebd();
X	break;
X    case T_CIRCLE_BY_DIA:
X	canvas_locmove_proc = resizing_cbd;
X	elastic_cbd();
X	break;
X    }
X    from_x = cur_x;
X    from_y = cur_y;
X    set_temp_cursor(crosshair_cursor);
X    canvas_leftbut_proc = fix_movedellipsepoint;
X    canvas_rightbut_proc = cancel_movedellipsepoint;
X    return True;		/* all is Ok */
X}
X
Xstatic
Xcancel_movedellipsepoint()
X{
X    switch (cur_e->type) {
X	case T_ELLIPSE_BY_RAD:
X	elastic_ebr();
X	break;
X    case T_CIRCLE_BY_RAD:
X	elastic_cbr();
X	break;
X    case T_ELLIPSE_BY_DIA:
X	elastic_ebd();
X	break;
X    case T_CIRCLE_BY_DIA:
X	elastic_cbd();
X	break;
X    }
X    draw_ellipse(cur_e, PAINT);
X    toggle_ellipsemarker(cur_e);
X    wrapup_movepoint();
X}
X
Xstatic
Xfix_movedellipsepoint(x, y)
X    int		    x, y;
X{
X    switch (cur_e->type) {
X    case T_ELLIPSE_BY_RAD:
X	elastic_ebr();
X	break;
X    case T_CIRCLE_BY_RAD:
X	elastic_cbr();
X	break;
X    case T_ELLIPSE_BY_DIA:
X	elastic_ebd();
X	break;
X    case T_CIRCLE_BY_DIA:
X	elastic_cbd();
X	break;
X    }
X    adjust_box_pos(x, y, from_x, from_y, &cur_x, &cur_y);
X    new_e = copy_ellipse(cur_e);
X    relocate_ellipsepoint(new_e, cur_x, cur_y, movedpoint_num);
X    change_ellipse(cur_e, new_e);
X    toggle_ellipsemarker(new_e);
X    wrapup_movepoint();
X}
X
Xstatic
Xrelocate_ellipsepoint(ellipse, x, y, point_num)
X    F_ellipse	   *ellipse;
X    int		    x, y, point_num;
X{
X    int		    dx, dy;
X
X    set_temp_cursor(wait_cursor);
X    draw_ellipse(ellipse, ERASE);
X    if (point_num == 0) {	/* starting point is selected  */
X	fix_x = ellipse->end.x;
X	fix_y = ellipse->end.y;
X	ellipse->start.x = x;
X	ellipse->start.y = y;
X    } else {
X	fix_x = ellipse->start.x;
X	fix_y = ellipse->start.y;
X	ellipse->end.x = x;
X	ellipse->end.y = y;
X    }
X    cur_angle = ellipse->angle;
X    switch (ellipse->type) {
X    case T_ELLIPSE_BY_RAD:
X	ellipse->radiuses.x = abs(x - fix_x);
X	ellipse->radiuses.y = abs(y - fix_y);
X	break;
X    case T_CIRCLE_BY_RAD:
X	dx = fix_x - x;
X	dy = fix_y - y;
X	ellipse->radiuses.x = sqrt((double) (dx * dx + dy * dy)) + .5;
X	ellipse->radiuses.y = ellipse->radiuses.x;
X	break;
X    case T_ELLIPSE_BY_DIA:
X	ellipse->center.x = (fix_x + x) / 2;
X	ellipse->center.y = (fix_y + y) / 2;
X	ellipse->radiuses.x = abs(ellipse->center.x - fix_x);
X	ellipse->radiuses.y = abs(ellipse->center.y - fix_y);
X	break;
X    case T_CIRCLE_BY_DIA:
X	dx = ellipse->center.x = (fix_x + x) / 2 + .5;
X	dy = ellipse->center.y = (fix_y + y) / 2 + .5;
X	dx -= x;
X	dy -= y;
X	ellipse->radiuses.x = sqrt((double) (dx * dx + dy * dy)) + .5;
X	ellipse->radiuses.y = ellipse->radiuses.x;
X	break;
X    }
X    /* if this WAS an ellipse and is NOW a circle (radii are equal), change type */
X    if (ellipse->type == T_ELLIPSE_BY_RAD || ellipse->type == T_ELLIPSE_BY_DIA) {
X	if (ellipse->radiuses.x == ellipse->radiuses.y)
X	    ellipse->type += 2;
X    }
X    draw_ellipse(ellipse, PAINT);
X    reset_cursor();
X}
X
X/***************************  arc  *********************************/
X
Xstatic
Xinit_arcpointmoving()
X{
X    set_action_on();
X    toggle_arcmarker(cur_a);
X    cur_x = cur_a->point[movedpoint_num].x;
X    cur_y = cur_a->point[movedpoint_num].y;
X    set_temp_cursor(crosshair_cursor);
X    win_setmouseposition(canvas_win, cur_x, cur_y);
X    elastic_arclink();
X    canvas_locmove_proc = reshaping_arc;
X    canvas_leftbut_proc = fix_movedarcpoint;
X    canvas_rightbut_proc = cancel_movedarcpoint;
X}
X
Xstatic
Xcancel_movedarcpoint()
X{
X    elastic_arclink();
X    toggle_arcmarker(cur_a);
X    wrapup_movepoint();
X}
X
Xstatic
Xfix_movedarcpoint(x, y)
X    int		    x, y;
X{
X    elastic_arclink();
X    adjust_pos(x, y, cur_a->point[movedpoint_num].x,
X	       cur_a->point[movedpoint_num].y, &x, &y);
X    new_a = copy_arc(cur_a);
X    relocate_arcpoint(new_a, x, y, movedpoint_num);
X    change_arc(cur_a, new_a);
X    toggle_arcmarker(new_a);
X    wrapup_movepoint();
X}
X
Xstatic
Xrelocate_arcpoint(arc, x, y, movedpoint_num)
X    F_arc	   *arc;
X    int		    x, y, movedpoint_num;
X{
X    float	    xx, yy;
X    F_pos	    p[3];
X
X    p[0] = arc->point[0];
X    p[1] = arc->point[1];
X    p[2] = arc->point[2];
X    p[movedpoint_num].x = x;
X    p[movedpoint_num].y = y;
X    if (compute_arccenter(p[0], p[1], p[2], &xx, &yy)) {
X	set_temp_cursor(wait_cursor);
X	draw_arc(arc, ERASE);	/* erase old arc */
X	arc->point[movedpoint_num].x = x;
X	arc->point[movedpoint_num].y = y;
X	arc->center.x = xx;
X	arc->center.y = yy;
X	arc->direction = compute_direction(p[0], p[1], p[2]);
X	draw_arc(arc, PAINT);	/* draw new arc */
X	reset_cursor();
X    }
X}
X
X/**************************  spline  *******************************/
X
Xstatic
Xinit_splinepointmoving()
X{
X    F_point	   *p;
X
X    set_action_on();
X    toggle_splinemarker(cur_s);
X    from_x = cur_x = moved_point->x;
X    from_y = cur_y = moved_point->y;
X    set_temp_cursor(crosshair_cursor);
X    if (open_spline(cur_s)) {
X	if (left_point == NULL || right_point == NULL) {
X            if (left_point != NULL) {
X                fix_x = left_point->x;
X                fix_y = left_point->y;
X            } else if (right_point != NULL) {
X                fix_x = right_point->x;
X                fix_y = right_point->y;
X            }
X	    if (latexline_mode || latexarrow_mode) {
X                canvas_locmove_proc = latex_line;
X                cur_latexcursor = crosshair_cursor;
X            } else if (mountain_mode || manhattan_mode) {
X                canvas_locmove_proc = constrainedangle_line;
X            } else {
X                /* freehand line */
X                canvas_locmove_proc = reshaping_line;
X            }
X	} else {
X            /* linelink, always freehand */
X	    force_noanglegeom();
X	    canvas_locmove_proc = reshaping_line;
X	}
X    } else {
X	/* must be closed spline */
X	force_noanglegeom();
X	canvas_locmove_proc = reshaping_line;
X	if (left_point == NULL) {
X	    for (left_point = right_point, p = left_point->next;
X		 p->next != NULL;
X		 left_point = p, p = p->next);
X	}
X    }
X    elastic_linelink();
X    canvas_leftbut_proc = fix_movedsplinepoint;
X    canvas_rightbut_proc = cancel_movedsplinepoint;
X}
X
Xstatic
Xcancel_movedsplinepoint()
X{
X    elastic_linelink();
X    toggle_splinemarker(cur_s);
X    wrapup_movepoint();
X}
X
Xstatic
Xfix_movedsplinepoint(x, y)
X    int		    x, y;
X{
X    (*canvas_locmove_proc) (x, y);
X    elastic_linelink();
X    old_s = copy_spline(cur_s);
X    clean_up();
X    set_latestspline(old_s);
X    set_action_object(F_CHANGE, O_SPLINE);
X    old_s->next = cur_s;
X    relocate_splinepoint(cur_s, cur_x, cur_y, moved_point);
X    toggle_splinemarker(cur_s);
X    wrapup_movepoint();
X}
X
Xstatic
Xrelocate_splinepoint(s, x, y, moved_point)
X    F_spline	   *s;
X    int		    x, y;
X    F_point	   *moved_point;
X{
X    set_temp_cursor(wait_cursor);
X    draw_spline(s, ERASE);	/* erase old spline */
X    moved_point->x = x;
X    moved_point->y = y;
X    if (closed_spline(s)) {
X	left_point->next->x = x;
X	left_point->next->y = y;
X    }
X    if (int_spline(s))
X	remake_control_points(s);
X    draw_spline(s, PAINT);	/* draw spline with moved point */
X    set_modifiedflag();
X    reset_cursor();
X}
X
X/***************************  compound	********************************/
X
Xstatic		prescale_compound(), cancel_compound();
X
Xstatic
Xinit_compoundpointmoving()
X{
X    double	    dx, dy, l;
X
X    set_action_on();
X    if (cur_x == cur_c->nwcorner.x)
X	fix_x = cur_c->secorner.x;
X    else
X	fix_x = cur_c->nwcorner.x;
X    if (cur_y == cur_c->nwcorner.y)
X	fix_y = cur_c->secorner.y;
X    else
X	fix_y = cur_c->nwcorner.y;
X    from_x = cur_x;
X    from_y = cur_y;
X    toggle_compoundmarker(cur_c);
X    draw_compoundelements(cur_c, ERASE);
X    set_temp_cursor(crosshair_cursor);
X    elastic_box(fix_x, fix_y, cur_x, cur_y);
X    if (constrained) {
X	dx = cur_x - fix_x;
X	dy = cur_y - fix_y;
X	l = sqrt(dx * dx + dy * dy);
X	cosa = fabs(dx / l);
X	sina = fabs(dy / l);
X    }
X    canvas_locmove_proc = constrained_resizing_box;
X    canvas_leftbut_proc = prescale_compound;
X    canvas_rightbut_proc = cancel_compound;
X}
X
Xstatic
Xcancel_compound()
X{
X    elastic_box(fix_x, fix_y, cur_x, cur_y);
X    draw_compoundelements(cur_c, PAINT);
X    toggle_compoundmarker(cur_c);
X    wrapup_movepoint();
X}
X
Xextern		scale_compound();
X
Xstatic
Xprescale_compound(x, y)
X    int		    x, y;
X{
X    float	    scalex, scaley;
X
X    elastic_box(fix_x, fix_y, cur_x, cur_y);
X    adjust_box_pos(x, y, from_x, from_y, &cur_x, &cur_y);
X
X    scalex = ((float) (cur_x - fix_x)) / (from_x - fix_x);
X    scaley = ((float) (cur_y - fix_y)) / (from_y - fix_y);
X    scale_compound(cur_c, scalex, scaley, fix_x, fix_y);
X
X    draw_compoundelements(cur_c, PAINT);
X    set_lastposition(from_x, from_y);
X    set_newposition(cur_x, cur_y);
X    clean_up();
X    set_action_object(F_SCALE, O_COMPOUND);
X    set_latestcompound(cur_c);
X    toggle_compoundmarker(cur_c);
X    set_modifiedflag();
X    reset_cursor();
X    wrapup_movepoint();
X}
X
X/***************************  line  ********************************/
X
Xstatic
Xinit_linepointmoving()
X{
X    F_point	   *p;
X
X    set_action_on();
X    toggle_linemarker(cur_l);
X    from_x = cur_x = moved_point->x;
X    from_y = cur_y = moved_point->y;
X    set_temp_cursor(crosshair_cursor);
X    switch (cur_l->type) {
X    case T_POLYGON:
X	if (left_point == NULL)
X	    for (left_point = right_point, p = left_point->next;
X		 p->next != NULL;
X		 left_point = p, p = p->next);
X        force_noanglegeom();
X	canvas_locmove_proc = reshaping_line;
X	break;
X
X    case T_BOX:
X    case T_ARC_BOX:
X    case T_EPS_BOX:
X	if (right_point->next == NULL) {	/* point 4 */
X	    fix_x = cur_l->points->next->x;
X	    fix_y = cur_l->points->next->y;
X	} else {
X	    fix_x = right_point->next->x;
X	    fix_y = right_point->next->y;
X	}
X	draw_line(cur_l, ERASE);
X
X	if (constrained) {
X	    double		dx, dy, l;
X
X	    dx = cur_x - fix_x;
X	    dy = cur_y - fix_y;
X	    l = sqrt(dx * dx + dy * dy);
X	    cosa = fabs(dx / l);
X	    sina = fabs(dy / l);
X	}
X
X        force_noanglegeom();
X	elastic_box(fix_x, fix_y, cur_x, cur_y);
X	canvas_locmove_proc = constrained_resizing_box;
X	canvas_leftbut_proc = fix_box;
X	canvas_rightbut_proc = cancel_box;
X	return;
X
X    case T_POLYLINE:
X	if (left_point != NULL) {
X	    if (left_point == cur_l->points) {
X		if (cur_l->back_arrow)	/* backward arrow  */
X		    draw_arrow(cur_x, cur_y,
X			       left_point->x, left_point->y,
X			       cur_l->back_arrow, ERASE,
X			       cur_l->color);
X	    }
X	} else if (cur_l->back_arrow)	/* backward arrow  */
X	    draw_arrow(right_point->x, right_point->y,
X		       cur_x, cur_y, cur_l->back_arrow, ERASE,
X		       cur_l->color);
X	if (right_point != NULL) {
X	    if (cur_l->for_arrow && right_point->next == NULL)
X		draw_arrow(cur_x, cur_y, right_point->x, right_point->y,
X			   cur_l->for_arrow, ERASE,
X			   cur_l->color);
X	} else if (cur_l->for_arrow)	/* f arrow */
X	    draw_arrow(left_point->x, left_point->y,
X		       cur_x, cur_y, cur_l->for_arrow, ERASE,
X		       cur_l->color);
X	if (left_point == NULL || right_point == NULL) {
X	    if (left_point != NULL) {
X		fix_x = left_point->x;
X		fix_y = left_point->y;
X	    } else if (right_point != NULL) {
X		fix_x = right_point->x;
X		fix_y = right_point->y;
X	    }
X            if (latexline_mode || latexarrow_mode) {
X                canvas_locmove_proc = latex_line;
X		cur_latexcursor = crosshair_cursor;
X            } else if (mountain_mode || manhattan_mode) {
X                canvas_locmove_proc = constrainedangle_line;
X            } else {
X		/* freehand line */
X		canvas_locmove_proc = reshaping_line;
X	    }
X	} else {
X	    /* linelink, always freehand */
X            force_noanglegeom();
X	    canvas_locmove_proc = reshaping_line;
X	}
X	break;
X    }
X    elastic_linelink();
X    canvas_leftbut_proc = fix_movedlinepoint;
X    canvas_rightbut_proc = cancel_movedlinepoint;
X}
X
Xstatic
Xcancel_box()
X{
X    elastic_box(fix_x, fix_y, cur_x, cur_y);
X    draw_line(cur_l, PAINT);
X    toggle_linemarker(cur_l);
X    wrapup_movepoint();
X}
X
Xstatic
Xfix_box(x, y)
X    int		    x, y;
X{
X    elastic_box(fix_x, fix_y, cur_x, cur_y);
X    adjust_box_pos(x, y, from_x, from_y, &x, &y);
X    new_l = copy_line(cur_l);
X    draw_line(cur_l, ERASE);
X    if (new_l->type == T_EPS_BOX) {
X	if (signof(fix_x - from_x) != signof(fix_x - x))
X	    new_l->eps->flipped = 1 - new_l->eps->flipped;
X	if (signof(fix_y - from_y) != signof(fix_y - y))
X	    new_l->eps->flipped = 1 - new_l->eps->flipped;
X    }
X    assign_newboxpoint(new_l, fix_x, fix_y, x, y);
X    change_line(cur_l, new_l);
X    draw_line(new_l, PAINT);
X    toggle_linemarker(new_l);
X    wrapup_movepoint();
X}
X
Xstatic
Xassign_newboxpoint(b, x1, y1, x2, y2)
X    F_line	   *b;
X    int		    x1, y1, x2, y2;
X{
X    F_point	   *p;
X
X    p = b->points;
X    if (p->x != x1)
X	p->x = x2;
X    if (p->y != y1)
X	p->y = y2;
X    p = p->next;
X    if (p->x != x1)
X	p->x = x2;
X    if (p->y != y1)
X	p->y = y2;
X    p = p->next;
X    if (p->x != x1)
X	p->x = x2;
X    if (p->y != y1)
X	p->y = y2;
X    p = p->next;
X    if (p->x != x1)
X	p->x = x2;
X    if (p->y != y1)
X	p->y = y2;
X    p = p->next;
X    if (p->x != x1)
X	p->x = x2;
X    if (p->y != y1)
X	p->y = y2;
X}
X
Xstatic
Xcancel_movedlinepoint()
X{
X    elastic_linelink();
X    toggle_linemarker(cur_l);
X    wrapup_movepoint();
X}
X
Xstatic
Xfix_movedlinepoint(x, y)
X    int		    x, y;
X{
X    (*canvas_locmove_proc) (x, y);
X    elastic_linelink();
X    if (cur_latexcursor != crosshair_cursor)
X	set_temp_cursor(crosshair_cursor);
X    /* make a copy of the original and save as unchanged object */
X    old_l = copy_line(cur_l);
X    clean_up();
X    set_latestline(old_l);
X    set_action_object(F_CHANGE, O_POLYLINE);
X    old_l->next = cur_l;
X    /* now change the original to become the new object */
X    relocate_linepoint(cur_l, cur_x, cur_y, moved_point, left_point);
X    toggle_linemarker(cur_l);
X    wrapup_movepoint();
X}
X
Xstatic
Xrelocate_linepoint(line, x, y, moved_point, left_point)
X    F_line	   *line;
X    int		    x, y;
X    F_point	   *moved_point, *left_point;
X{
X    draw_line(line, ERASE);
X    if (line->type == T_POLYGON)
X	if (line->points == moved_point) {
X	    left_point->next->x = x;
X	    left_point->next->y = y;
X	}
X    moved_point->x = x;
X    moved_point->y = y;
X    set_modifiedflag();
X    draw_line(line, PAINT);
X}
END_OF_FILE
if test 19377 -ne `wc -c <'e_movept.c'`; then
    echo shar: \"'e_movept.c'\" unpacked with wrong size!
fi
# end of 'e_movept.c'
fi
if test -f 'u_list.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'u_list.c'\"
else
echo shar: Extracting \"'u_list.c'\" \(17965 characters\)
sed "s/^X//" >'u_list.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both the copyright
X * notice and this permission notice appear in supporting documentation. 
X * No representations are made about the suitability of this software for 
X * any purpose.  It is provided "as is" without express or implied warranty."
X */
X
X#include "fig.h"
X#include "mode.h"
X#include "resources.h"
X#include "object.h"
X#include "paintop.h"
X#include "u_create.h"
X#include "u_list.h"
X#include "u_elastic.h"
X#include "u_undo.h"
X
Xvoid
Xlist_delete_arc(arc_list, arc)
X    F_arc	  **arc_list, *arc;
X{
X    F_arc	   *a, *aa;
X
X    if (*arc_list == NULL)
X	return;
X    if (arc == NULL)
X	return;
X
X    for (a = aa = *arc_list; aa != NULL; a = aa, aa = aa->next) {
X	if (aa == arc) {
X	    if (aa == *arc_list)
X		*arc_list = (*arc_list)->next;
X	    else
X		a->next = aa->next;
X	    break;
X	}
X    }
X    arc->next = NULL;
X}
X
Xvoid
Xlist_delete_ellipse(ellipse_list, ellipse)
X    F_ellipse	  **ellipse_list, *ellipse;
X{
X    F_ellipse	   *q, *r;
X
X    if (*ellipse_list == NULL)
X	return;
X    if (ellipse == NULL)
X	return;
X
X    for (q = r = *ellipse_list; r != NULL; q = r, r = r->next) {
X	if (r == ellipse) {
X	    if (r == *ellipse_list)
X		*ellipse_list = (*ellipse_list)->next;
X	    else
X		q->next = r->next;
X	    break;
X	}
X    }
X    ellipse->next = NULL;
X}
X
Xvoid
Xlist_delete_line(line_list, line)
X    F_line	   *line, **line_list;
X{
X    F_line	   *q, *r;
X
X    if (*line_list == NULL)
X	return;
X    if (line == NULL)
X	return;
X
X    for (q = r = *line_list; r != NULL; q = r, r = r->next) {
X	if (r == line) {
X	    if (r == *line_list)
X		*line_list = (*line_list)->next;
X	    else
X		q->next = r->next;
X	    break;
X	}
X    }
X    line->next = NULL;
X}
X
Xvoid
Xlist_delete_spline(spline_list, spline)
X    F_spline	  **spline_list, *spline;
X{
X    F_spline	   *q, *r;
X
X    if (*spline_list == NULL)
X	return;
X    if (spline == NULL)
X	return;
X
X    for (q = r = *spline_list; r != NULL; q = r, r = r->next) {
X	if (r == spline) {
X	    if (r == *spline_list)
X		*spline_list = (*spline_list)->next;
X	    else
X		q->next = r->next;
X	    break;
X	}
X    }
X    spline->next = NULL;
X}
X
Xvoid
Xlist_delete_text(text_list, text)
X    F_text	  **text_list, *text;
X{
X    F_text	   *q, *r;
X
X    if (*text_list == NULL)
X	return;
X    if (text == NULL)
X	return;
X
X    for (q = r = *text_list; r != NULL; q = r, r = r->next)
X	if (r == text) {
X	    if (r == *text_list)
X		*text_list = text->next;
X	    else
X		q->next = text->next;
X	    break;
X	}
X    text->next = NULL;
X}
X
Xvoid
Xlist_delete_compound(list, compound)
X    F_compound	  **list, *compound;
X{
X    F_compound	   *c, *cc;
X
X    if (*list == NULL)
X	return;
X    if (compound == NULL)
X	return;
X
X    for (cc = c = *list; c != NULL; cc = c, c = c->next) {
X	if (c == compound) {
X	    if (c == *list)
X		*list = (*list)->next;
X	    else
X		cc->next = c->next;
X	    break;
X	}
X    }
X    compound->next = NULL;
X}
X
Xvoid
Xlist_add_arc(arc_list, a)
X    F_arc	  **arc_list, *a;
X{
X    F_arc	   *aa;
X
X    a->next = NULL;
X    if ((aa = last_arc(*arc_list)) == NULL)
X	*arc_list = a;
X    else
X	aa->next = a;
X}
X
Xvoid
Xlist_add_ellipse(ellipse_list, e)
X    F_ellipse	  **ellipse_list, *e;
X{
X    F_ellipse	   *ee;
X
X    e->next = NULL;
X    if ((ee = last_ellipse(*ellipse_list)) == NULL)
X	*ellipse_list = e;
X    else
X	ee->next = e;
X}
X
Xvoid
Xlist_add_line(line_list, l)
X    F_line	  **line_list, *l;
X{
X    F_line	   *ll;
X
X    l->next = NULL;
X    if ((ll = last_line(*line_list)) == NULL)
X	*line_list = l;
X    else
X	ll->next = l;
X}
X
Xvoid
Xlist_add_spline(spline_list, s)
X    F_spline	  **spline_list, *s;
X{
X    F_spline	   *ss;
X
X    s->next = NULL;
X    if ((ss = last_spline(*spline_list)) == NULL)
X	*spline_list = s;
X    else
X	ss->next = s;
X}
X
Xvoid
Xlist_add_text(text_list, t)
X    F_text	  **text_list, *t;
X{
X    F_text	   *tt;
X
X    t->next = NULL;
X    if ((tt = last_text(*text_list)) == NULL)
X	*text_list = t;
X    else
X	tt->next = t;
X}
X
Xvoid
Xlist_add_compound(list, c)
X    F_compound	  **list, *c;
X{
X    F_compound	   *cc;
X
X    c->next = NULL;
X    if ((cc = last_compound(*list)) == NULL)
X	*list = c;
X    else
X	cc->next = c;
X}
X
Xvoid
Xdelete_line(old_l)
X    F_line	   *old_l;
X{
X    list_delete_line(&objects.lines, old_l);
X    clean_up();
X    set_latestline(old_l);
X    set_action_object(F_DELETE, O_POLYLINE);
X    set_modifiedflag();
X}
X
Xvoid
Xdelete_arc(old_a)
X    F_arc	   *old_a;
X{
X    list_delete_arc(&objects.arcs, old_a);
X    clean_up();
X    set_latestarc(old_a);
X    set_action_object(F_DELETE, O_ARC);
X    set_modifiedflag();
X}
X
Xvoid
Xdelete_ellipse(old_e)
X    F_ellipse	   *old_e;
X{
X    list_delete_ellipse(&objects.ellipses, old_e);
X    clean_up();
X    set_latestellipse(old_e);
X    set_action_object(F_DELETE, O_ELLIPSE);
X    set_modifiedflag();
X}
X
Xvoid
Xdelete_text(old_t)
X    F_text	   *old_t;
X{
X    list_delete_text(&objects.texts, old_t);
X    clean_up();
X    set_latesttext(old_t);
X    set_action_object(F_DELETE, O_TEXT);
X    set_modifiedflag();
X}
X
Xvoid
Xdelete_spline(old_s)
X    F_spline	   *old_s;
X{
X    list_delete_spline(&objects.splines, old_s);
X    clean_up();
X    set_latestspline(old_s);
X    set_action_object(F_DELETE, O_SPLINE);
X    set_modifiedflag();
X}
X
Xvoid
Xdelete_compound(old_c)
X    F_compound	   *old_c;
X{
X    list_delete_compound(&objects.compounds, old_c);
X    clean_up();
X    set_latestcompound(old_c);
X    set_action_object(F_DELETE, O_COMPOUND);
X    set_modifiedflag();
X}
X
Xvoid
Xadd_line(new_l)
X    F_line	   *new_l;
X{
X    list_add_line(&objects.lines, new_l);
X    clean_up();
X    set_latestline(new_l);
X    set_action_object(F_ADD, O_POLYLINE);
X    set_modifiedflag();
X}
X
Xvoid
Xadd_arc(new_a)
X    F_arc	   *new_a;
X{
X    list_add_arc(&objects.arcs, new_a);
X    clean_up();
X    set_latestarc(new_a);
X    set_action_object(F_ADD, O_ARC);
X    set_modifiedflag();
X}
X
Xvoid
Xadd_ellipse(new_e)
X    F_ellipse	   *new_e;
X{
X    list_add_ellipse(&objects.ellipses, new_e);
X    clean_up();
X    set_latestellipse(new_e);
X    set_action_object(F_ADD, O_ELLIPSE);
X    set_modifiedflag();
X}
X
Xvoid
Xadd_text(new_t)
X    F_text	   *new_t;
X{
X    list_add_text(&objects.texts, new_t);
X    clean_up();
X    set_latesttext(new_t);
X    set_action_object(F_ADD, O_TEXT);
X    set_modifiedflag();
X}
X
Xvoid
Xadd_spline(new_s)
X    F_spline	   *new_s;
X{
X    list_add_spline(&objects.splines, new_s);
X    clean_up();
X    set_latestspline(new_s);
X    set_action_object(F_ADD, O_SPLINE);
X    set_modifiedflag();
X}
X
Xvoid
Xadd_compound(new_c)
X    F_compound	   *new_c;
X{
X    list_add_compound(&objects.compounds, new_c);
X    clean_up();
X    set_latestcompound(new_c);
X    set_action_object(F_ADD, O_COMPOUND);
X    set_modifiedflag();
X}
X
X
Xvoid
Xchange_line(old_l, new_l)
X    F_line	   *old_l, *new_l;
X{
X    list_delete_line(&objects.lines, old_l);
X    list_add_line(&objects.lines, new_l);
X    clean_up();
X    old_l->next = new_l;
X    set_latestline(old_l);
X    set_action_object(F_CHANGE, O_POLYLINE);
X    set_modifiedflag();
X}
X
Xvoid
Xchange_arc(old_a, new_a)
X    F_arc	   *old_a, *new_a;
X{
X    list_delete_arc(&objects.arcs, old_a);
X    list_add_arc(&objects.arcs, new_a);
X    clean_up();
X    old_a->next = new_a;
X    set_latestarc(old_a);
X    set_action_object(F_CHANGE, O_ARC);
X    set_modifiedflag();
X}
X
Xvoid
Xchange_ellipse(old_e, new_e)
X    F_ellipse	   *old_e, *new_e;
X{
X    list_delete_ellipse(&objects.ellipses, old_e);
X    list_add_ellipse(&objects.ellipses, new_e);
X    clean_up();
X    old_e->next = new_e;
X    set_latestellipse(old_e);
X    set_action_object(F_CHANGE, O_ELLIPSE);
X    set_modifiedflag();
X}
X
Xvoid
Xchange_text(old_t, new_t)
X    F_text	   *old_t, *new_t;
X{
X    list_delete_text(&objects.texts, old_t);
X    list_add_text(&objects.texts, new_t);
X    clean_up();
X    old_t->next = new_t;
X    set_latesttext(old_t);
X    set_action_object(F_CHANGE, O_TEXT);
X    set_modifiedflag();
X}
X
Xvoid
Xchange_spline(old_s, new_s)
X    F_spline	   *old_s, *new_s;
X{
X    list_delete_spline(&objects.splines, old_s);
X    list_add_spline(&objects.splines, new_s);
X    clean_up();
X    old_s->next = new_s;
X    set_latestspline(old_s);
X    set_action_object(F_CHANGE, O_SPLINE);
X    set_modifiedflag();
X}
X
Xvoid
Xchange_compound(old_c, new_c)
X    F_compound	   *old_c, *new_c;
X{
X    list_delete_compound(&objects.compounds, old_c);
X    list_add_compound(&objects.compounds, new_c);
X    clean_up();
X    old_c->next = new_c;
X    set_latestcompound(old_c);
X    set_action_object(F_CHANGE, O_COMPOUND);
X    set_modifiedflag();
X}
X
Xtail(ob, tails)
X    F_compound	   *ob, *tails;
X{
X    F_arc	   *a;
X    F_compound	   *c;
X    F_ellipse	   *e;
X    F_line	   *l;
X    F_spline	   *s;
X    F_text	   *t;
X
X    if (NULL != (a = ob->arcs))
X	for (; a->next != NULL; a = a->next);
X    if (NULL != (c = ob->compounds))
X	for (; c->next != NULL; c = c->next);
X    if (NULL != (e = ob->ellipses))
X	for (; e->next != NULL; e = e->next);
X    if (NULL != (l = ob->lines))
X	for (; l->next != NULL; l = l->next);
X    if (NULL != (s = ob->splines))
X	for (; s->next != NULL; s = s->next);
X    if (NULL != (t = ob->texts))
X	for (; t->next != NULL; t = t->next);
X
X    tails->arcs = a;
X    tails->compounds = c;
X    tails->ellipses = e;
X    tails->lines = l;
X    tails->splines = s;
X    tails->texts = t;
X}
X
X/*
X * Make pointers in tails point to the last element of each list of l1 and
X * Append the lists in l2 after those in l1. The tails pointers must be
X * defined prior to calling append.
X */
Xappend_objects(l1, l2, tails)
X    F_compound	   *l1, *l2, *tails;
X{
X    if (tails->arcs)
X	tails->arcs->next = l2->arcs;
X    else
X	l1->arcs = l2->arcs;
X    if (tails->compounds)
X	tails->compounds->next = l2->compounds;
X    else
X	l1->compounds = l2->compounds;
X    if (tails->ellipses)
X	tails->ellipses->next = l2->ellipses;
X    else
X	l1->ellipses = l2->ellipses;
X    if (tails->lines)
X	tails->lines->next = l2->lines;
X    else
X	l1->lines = l2->lines;
X    if (tails->splines)
X	tails->splines->next = l2->splines;
X    else
X	l1->splines = l2->splines;
X    if (tails->texts)
X	tails->texts->next = l2->texts;
X    else
X	l1->texts = l2->texts;
X}
X
X/* Cut is the dual of append. */
X
Xcut_objects(objects, tails)
X    F_compound	   *objects, *tails;
X{
X    if (tails->arcs)
X	tails->arcs->next = NULL;
X    else
X	objects->arcs = NULL;
X    if (tails->compounds)
X	tails->compounds->next = NULL;
X    else
X	objects->compounds = NULL;
X    if (tails->ellipses)
X	tails->ellipses->next = NULL;
X    else
X	objects->ellipses = NULL;
X    if (tails->lines)
X	tails->lines->next = NULL;
X    else
X	objects->lines = NULL;
X    if (tails->splines)
X	tails->splines->next = NULL;
X    else
X	objects->splines = NULL;
X    if (tails->texts)
X	tails->texts->next = NULL;
X    else
X	objects->texts = NULL;
X}
X
Xappend_point(x, y, point)
X    int		    x, y;
X    F_point	  **point;
X{
X    F_point	   *p;
X
X    if ((p = create_point()) == NULL)
X	return;
X
X    p->x = x;
X    p->y = y;
X    p->next = NULL;
X    (*point)->next = p;
X    *point = p;
X}
X
Xnum_points(points)
X    F_point	   *points;
X{
X    int		    n;
X    F_point	   *p;
X
X    for (p = points, n = 0; p != NULL; p = p->next, n++);
X    return (n);
X}
X
XF_text	       *
Xlast_text(list)
X    F_text	   *list;
X{
X    F_text	   *tt;
X
X    if (list == NULL)
X	return NULL;
X
X    for (tt = list; tt->next != NULL; tt = tt->next);
X    return tt;
X}
X
XF_line	       *
Xlast_line(list)
X    F_line	   *list;
X{
X    F_line	   *ll;
X
X    if (list == NULL)
X	return NULL;
X
X    for (ll = list; ll->next != NULL; ll = ll->next);
X    return ll;
X}
X
XF_spline       *
Xlast_spline(list)
X    F_spline	   *list;
X{
X    F_spline	   *ss;
X
X    if (list == NULL)
X	return NULL;
X
X    for (ss = list; ss->next != NULL; ss = ss->next);
X    return ss;
X}
X
XF_arc	       *
Xlast_arc(list)
X    F_arc	   *list;
X{
X    F_arc	   *tt;
X
X    if (list == NULL)
X	return NULL;
X
X    for (tt = list; tt->next != NULL; tt = tt->next);
X    return tt;
X}
X
XF_ellipse      *
Xlast_ellipse(list)
X    F_ellipse	   *list;
X{
X    F_ellipse	   *tt;
X
X    if (list == NULL)
X	return NULL;
X
X    for (tt = list; tt->next != NULL; tt = tt->next);
X    return tt;
X}
X
XF_compound     *
Xlast_compound(list)
X    F_compound	   *list;
X{
X    F_compound	   *tt;
X
X    if (list == NULL)
X	return NULL;
X
X    for (tt = list; tt->next != NULL; tt = tt->next);
X    return tt;
X}
X
XF_point	       *
Xlast_point(list)
X    F_point	   *list;
X{
X    F_point	   *tt;
X
X    if (list == NULL)
X	return NULL;
X
X    for (tt = list; tt->next != NULL; tt = tt->next);
X    return tt;
X}
X
XF_arc	       *
Xprev_arc(list, arc)
X    F_arc	   *list, *arc;
X{
X    F_arc	   *csr;
X
X    if (list == arc)
X	return NULL;
X
X    for (csr = list; csr->next != arc; csr = csr->next);
X    return csr;
X}
X
XF_compound     *
Xprev_compound(list, compound)
X    F_compound	   *list, *compound;
X{
X    F_compound	   *csr;
X
X    if (list == compound)
X	return NULL;
X
X    for (csr = list; csr->next != compound; csr = csr->next);
X    return csr;
X}
X
XF_ellipse      *
Xprev_ellipse(list, ellipse)
X    F_ellipse	   *list, *ellipse;
X{
X    F_ellipse	   *csr;
X
X    if (list == ellipse)
X	return NULL;
X
X    for (csr = list; csr->next != ellipse; csr = csr->next);
X    return csr;
X}
X
XF_line	       *
Xprev_line(list, line)
X    F_line	   *list, *line;
X{
X    F_line	   *csr;
X
X    if (list == line)
X	return NULL;
X
X    for (csr = list; csr->next != line; csr = csr->next);
X    return csr;
X}
X
XF_spline       *
Xprev_spline(list, spline)
X    F_spline	   *list, *spline;
X{
X    F_spline	   *csr;
X
X    if (list == spline)
X	return NULL;
X
X    for (csr = list; csr->next != spline; csr = csr->next);
X    return csr;
X}
X
XF_text	       *
Xprev_text(list, text)
X    F_text	   *list, *text;
X{
X    F_text	   *csr;
X
X    if (list == text)
X	return NULL;
X
X    for (csr = list; csr->next != text; csr = csr->next);
X    return csr;
X}
X
XF_point	       *
Xprev_point(list, point)
X    F_point	   *list, *point;
X{
X    F_point	   *csr;
X
X    if (list == point)
X	return NULL;
X
X    for (csr = list; csr->next != point; csr = csr->next);
X    return csr;
X}
X
Xint
Xobject_count(list)
X    F_compound	   *list;
X{
X    register int    cnt;
X    F_arc	   *a;
X    F_text	   *t;
X    F_compound	   *c;
X    F_ellipse	   *e;
X    F_line	   *l;
X    F_spline	   *s;
X
X    cnt = 0;
X    for (a = list->arcs; a != NULL; a = a->next, cnt++);
X    for (t = list->texts; t != NULL; t = t->next, cnt++);
X    for (c = list->compounds; c != NULL; c = c->next, cnt++);
X    for (e = list->ellipses; e != NULL; e = e->next, cnt++);
X    for (l = list->lines; l != NULL; l = l->next, cnt++);
X    for (s = list->splines; s != NULL; s = s->next, cnt++);
X    return (cnt);
X}
X
Xset_tags(list, tag)
X    F_compound	   *list;
X    int		    tag;
X{
X    F_arc	   *a;
X    F_text	   *t;
X    F_compound	   *c;
X    F_ellipse	   *e;
X    F_line	   *l;
X    F_spline	   *s;
X
X    for (a = list->arcs; a != NULL; a = a->next) {
X	mask_toggle_arcmarker(a);
X	a->tagged = tag;
X	mask_toggle_arcmarker(a);
X    }
X    for (t = list->texts; t != NULL; t = t->next) {
X	mask_toggle_textmarker(t);
X	t->tagged = tag;
X	mask_toggle_textmarker(t);
X    }
X    for (c = list->compounds; c != NULL; c = c->next) {
X	mask_toggle_compoundmarker(c);
X	c->tagged = tag;
X	mask_toggle_compoundmarker(c);
X    }
X    for (e = list->ellipses; e != NULL; e = e->next) {
X	mask_toggle_ellipsemarker(e);
X	e->tagged = tag;
X	mask_toggle_ellipsemarker(e);
X    }
X    for (l = list->lines; l != NULL; l = l->next) {
X	mask_toggle_linemarker(l);
X	l->tagged = tag;
X	mask_toggle_linemarker(l);
X    }
X    for (s = list->splines; s != NULL; s = s->next) {
X	mask_toggle_splinemarker(s);
X	s->tagged = tag;
X	mask_toggle_splinemarker(s);
X    }
X}
X
Xvoid
Xget_links(llx, lly, urx, ury)
X    int		    llx, lly, urx, ury;
X{
X    F_line	   *l;
X    F_point	   *a;
X    F_linkinfo	   *j, *k;
X
X    j = NULL;
X    for (l = objects.lines; l != NULL; l = l->next)
X	if (l->type == T_POLYLINE) {
X	    a = l->points;
X	    if (point_on_perim(a, llx, lly, urx, ury)) {
X		if ((k = new_link(l, a, a->next)) == NULL)
X		    return;
X		if (j == NULL)
X		    cur_links = k;
X		else
X		    j->next = k;
X		j = k;
X		if (k->prevpt != NULL)
X		    k->two_pts = (k->prevpt->next == NULL);
X		continue;
X	    }
X	    if (a->next == NULL)/* single point, no need to check further */
X		continue;
X	    a = last_point(l->points);
X	    if (point_on_perim(a, llx, lly, urx, ury)) {
X		if ((k = new_link(l, a, prev_point(l->points, a))) == NULL)
X		    return;
X		if (j == NULL)
X		    cur_links = k;
X		else
X		    j->next = k;
X		j = k;
X		if (k->prevpt != NULL)
X		    k->two_pts = (prev_point(l->points, k->prevpt) == NULL);
X		continue;
X	    }
X	}
X}
X
X#define LINK_TOL 3
X
Xint
Xpoint_on_perim(p, llx, lly, urx, ury)
X    F_point	   *p;
X    int		    llx, lly, urx, ury;
X{
X    return ((abs(p->x - llx) <= LINK_TOL && p->y >= lly - LINK_TOL
X	     && p->y <= ury + LINK_TOL) ||
X	    (abs(p->x - urx) <= LINK_TOL && p->y >= lly - LINK_TOL
X	     && p->y <= ury + LINK_TOL) ||
X	    (abs(p->y - lly) <= LINK_TOL && p->x >= llx - LINK_TOL
X	     && p->x <= urx + LINK_TOL) ||
X	    (abs(p->y - ury) <= LINK_TOL && p->x >= llx - LINK_TOL
X	     && p->x <= urx + LINK_TOL));
X}
X
Xvoid
Xadjust_links(mode, links, dx, dy, cx, cy, sx, sy, copying)
X    int		    mode;
X    F_linkinfo	   *links;
X    int		dx, dy;		/* delta */
X    int		cx, cy;		/* center of scale - NOT USED YET */
X    float	sx, sy;		/* scale factor - NOT USED YET */
X    int		    copying;
X{
X    F_linkinfo	   *k;
X    F_line	   *l;
X
X    if (mode != SMART_OFF)
X	for (k = links; k != NULL; k = k->next) {
X	    if (copying) {
X		l = copy_line(k->line);
X		list_delete_line(&objects.lines, k->line);
X		list_add_line(&saved_objects.lines, k->line);
X		list_add_line(&objects.lines, l);
X	    } else {
X		mask_toggle_linemarker(k->line);
X		draw_line(k->line, ERASE);
X	    }
X	    if (mode == SMART_SLIDE && k->prevpt != NULL) {
X		if (k->endpt->x == k->prevpt->x)
X		    k->prevpt->x += dx;
X		else
X		    k->prevpt->y += dy;
X	    }
X	    k->endpt->x += dx;
X	    k->endpt->y += dy;
X	    draw_line(k->line, PAINT);
X	    mask_toggle_linemarker(k->line);
X	}
X}
END_OF_FILE
if test 17965 -ne `wc -c <'u_list.c'`; then
    echo shar: \"'u_list.c'\" unpacked with wrong size!
fi
# end of 'u_list.c'
fi
if test -f 'u_search.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'u_search.c'\"
else
echo shar: Extracting \"'u_search.c'\" \(19267 characters\)
sed "s/^X//" >'u_search.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both the copyright
X * notice and this permission notice appear in supporting documentation. 
X * No representations are made about the suitability of this software for 
X * any purpose.  It is provided "as is" without express or implied warranty."
X */
X
X#include "fig.h"
X#include "resources.h"
X#include "object.h"
X#include "mode.h"
X#include "u_list.h"
X#include "w_zoom.h"
X
X#define TOLERANCE 3
X
Xstatic		(*manipulate) ();
Xstatic		(*handlerproc_left) ();
Xstatic		(*handlerproc_middle) ();
Xstatic		(*handlerproc_right) ();
Xstatic int	type;
Xstatic long	objectcount;
Xstatic long	n;
Xstatic int	csr_x, csr_y;
X
Xstatic F_point	point1, point2;
X
Xstatic F_arc   *a;
Xstatic F_ellipse *e;
Xstatic F_line  *l;
Xstatic F_spline *s;
Xstatic F_text  *t;
Xstatic F_compound *c;
X
Xchar
Xnext_arc_found(x, y, tolerance, px, py, shift)
X    int		    x, y, tolerance, *px, *py;
X    int		    shift;
X{				/* (px, py) is the control point on the
X				 * circumference of an arc which is the
X				 * closest to (x, y)				 */
X
X    int		    i;
X
X    if (!arc_in_mask())
X	return (0);
X    if (a == NULL)
X	a = last_arc(objects.arcs);
X    else if (shift)
X	a = prev_arc(objects.arcs, a);
X
X    for (; a != NULL; a = prev_arc(objects.arcs, a), n++) {
X	for (i = 0; i < 3; i++)
X	    if ((abs(a->point[i].x - x) <= tolerance) &&
X		(abs(a->point[i].y - y) <= tolerance)) {
X		*px = a->point[i].x;
X		*py = a->point[i].y;
X		return (1);
X	    }
X    }
X    return (0);
X}
X
X
Xchar
Xnext_ellipse_found(x, y, tolerance, px, py, shift)
X    int		    x, y, tolerance, *px, *py;
X    int		    shift;
X{				/* (px, py) is the point on the circumference
X				 * of an ellipse which is the closest to (x,
X				 * y)				 */
X
X    int		    a, b, dx, dy;
X    float	    dis, r, tol;
X
X    if (!ellipse_in_mask())
X	return (0);
X    if (e == NULL)
X	e = last_ellipse(objects.ellipses);
X    else if (shift)
X	e = prev_ellipse(objects.ellipses, e);
X
X    tol = (float) tolerance;
X    for (; e != NULL; e = prev_ellipse(objects.ellipses, e), n++) {
X	dx = x - e->center.x;
X	dy = y - e->center.y;
X	a = e->radiuses.x;
X	b = e->radiuses.y;
X	/* prevent sqrt(0) core dumps */
X	if (dx == 0 && dy == 0)
X	    dis = 0;		/* so we return below */
X	else
X	    dis = sqrt((double) (dx * dx + dy * dy));
X	if (dis < tol) {
X	    *px = e->center.x;
X	    *py = e->center.y;
X	    return (1);
X	}
X	if (abs(x - e->start.x) <= tolerance && abs(y - e->start.y) <= tolerance) {
X	    *px = e->start.x;
X	    *py = e->start.y;
X	    return (1);
X	}
X	if (abs(x - e->end.x) <= tolerance && abs(y - e->end.y) <= tolerance) {
X	    *px = e->end.x;
X	    *py = e->end.y;
X	    return (1);
X	}
X	if (a * dy == 0 && b * dx == 0)
X	    r = 0;		/* prevent core dumps */
X	else
X	    r = a * b * dis / sqrt((double) (1.0 * b * b * dx * dx + 1.0 * a * a * dy * dy));
X	if (fabs(dis - r) <= tol) {
X	    *px = (int) (r * dx / dis + ((dx < 0) ? -.5 : .5)) + e->center.x;
X	    *py = (int) (r * dy / dis + ((dy < 0) ? -.5 : .5)) + e->center.y;
X	    return (1);
X	}
X    }
X    return (0);
X}
X
Xchar
Xnext_line_found(x, y, tolerance, px, py, shift)
X    int		    x, y, tolerance, *px, *py, shift;
X{				/* return the pointer to lines object if the
X				 * search is successful otherwise return
X				 * NULL.  The value returned via (px, py) is
X				 * the closest point on the vector to point
X				 * (x, y)					 */
X
X    F_point	   *point;
X    int		    x1, y1, x2, y2;
X    float	    tol2;
X
X    tol2 = (float) tolerance *tolerance;
X
X    if (!anyline_in_mask())
X	return (0);
X    if (l == NULL)
X	l = last_line(objects.lines);
X    else if (shift)
X	l = prev_line(objects.lines, l);
X
X    for (; l != NULL; l = prev_line(objects.lines, l))
X	if (validline_in_mask(l)) {
X	    n++;
X	    point = l->points;
X	    x1 = point->x;
X	    y1 = point->y;
X	    if (abs(x - x1) <= tolerance && abs(y - y1) <= tolerance) {
X		*px = x1;
X		*py = y1;
X		return (1);
X	    }
X	    for (point = point->next; point != NULL; point = point->next) {
X		x2 = point->x;
X		y2 = point->y;
X		if (close_to_vector(x1, y1, x2, y2, x, y, tolerance, tol2,
X				    px, py))
X		    return (1);
X		x1 = x2;
X		y1 = y2;
X	    }
X	}
X    return (0);
X}
X
Xchar
Xnext_spline_found(x, y, tolerance, px, py, shift)
X    int		    x, y, tolerance, *px, *py;
X    int		    shift;
X{				/* return the pointer to lines object if the
X				 * search is successful otherwise return
X				 * NULL.  */
X
X    F_point	   *point;
X    int		    x1, y1, x2, y2;
X    float	    tol2;
X
X    if (!anyspline_in_mask())
X	return (0);
X    if (s == NULL)
X	s = last_spline(objects.splines);
X    else if (shift)
X	s = prev_spline(objects.splines, s);
X
X    tol2 = (float) tolerance *tolerance;
X
X    for (; s != NULL; s = prev_spline(objects.splines, s))
X	if (validspline_in_mask(s)) {
X	    n++;
X	    point = s->points;
X	    x1 = point->x;
X	    y1 = point->y;
X	    for (point = point->next; point != NULL; point = point->next) {
X		x2 = point->x;
X		y2 = point->y;
X		if (close_to_vector(x1, y1, x2, y2, x, y, tolerance, tol2,
X				    px, py))
X		    return (1);
X		x1 = x2;
X		y1 = y2;
X	    }
X	}
X    return (0);
X}
X
Xchar
Xnext_text_found(x, y, tolerance, px, py, shift)
X    int		    x, y, tolerance, *px, *py;
X    int		    shift;
X{
X    int		    halflen, dx, dy;
X    int		    txmin, txmax, tymin, tymax;
X
X    if (!anytext_in_mask())
X	return (0);
X    if (t == NULL)
X	t = last_text(objects.texts);
X    else if (shift)
X	t = prev_text(objects.texts, t);
X
X    for (; t != NULL; t = prev_text(objects.texts, t))
X	if (validtext_in_mask(t)) {
X	    n++;
X	    text_bound(t, &txmin, &tymin, &txmax, &tymax);
X	    if (x >= txmin-tolerance && x <= txmax+tolerance &&
X	        y >= tymin-tolerance && y <= tymax+tolerance) {
X			*px = x;
X			*py = y;
X			return (1);
X	    }
X	}
X    return (0);
X}
X
Xint
Xnext_compound_found(x, y, tolerance, px, py, shift)
X    int		    x, y, tolerance, *px, *py;
X    int		    shift;
X{
X    float	    tol2;
X
X    if (!compound_in_mask())
X	return (0);
X    if (c == NULL)
X	c = last_compound(objects.compounds);
X    else if (shift)
X	c = prev_compound(objects.compounds, c);
X
X    tol2 = tolerance * tolerance;
X
X    for (; c != NULL; c = prev_compound(objects.compounds, c), n++) {
X	if (close_to_vector(c->nwcorner.x, c->nwcorner.y, c->nwcorner.x,
X			    c->secorner.y, x, y, tolerance, tol2, px, py))
X	    return (1);
X	if (close_to_vector(c->secorner.x, c->secorner.y, c->nwcorner.x,
X			    c->secorner.y, x, y, tolerance, tol2, px, py))
X	    return (1);
X	if (close_to_vector(c->secorner.x, c->secorner.y, c->secorner.x,
X			    c->nwcorner.y, x, y, tolerance, tol2, px, py))
X	    return (1);
X	if (close_to_vector(c->nwcorner.x, c->nwcorner.y, c->secorner.x,
X			    c->nwcorner.y, x, y, tolerance, tol2, px, py))
X	    return (1);
X    }
X    return (0);
X}
X
Xshow_objecthighlight()
X{
X    if (highlighting)
X	return;
X    highlighting = 1;
X    toggle_objecthighlight();
X}
X
Xerase_objecthighlight()
X{
X    if (!highlighting)
X	return;
X    highlighting = 0;
X    toggle_objecthighlight();
X    if (type == -1) {
X	e = NULL;
X	type = O_ELLIPSE;
X    }
X}
X
Xtoggle_objecthighlight()
X{
X    switch (type) {
X    case O_ELLIPSE:
X	toggle_ellipsehighlight(e);
X	break;
X    case O_POLYLINE:
X	toggle_linehighlight(l);
X	break;
X    case O_SPLINE:
X	toggle_splinehighlight(s);
X	break;
X    case O_TEXT:
X	toggle_texthighlight(t);
X	break;
X    case O_ARC:
X	toggle_archighlight(a);
X	break;
X    case O_COMPOUND:
X	toggle_compoundhighlight(c);
X	break;
X    default:
X	toggle_csrhighlight(csr_x, csr_y);
X    }
X}
X
Xstatic void
Xinit_search()
X{
X    if (highlighting)
X	erase_objecthighlight();
X    else {
X	objectcount = 0;
X	if (ellipse_in_mask())
X	    for (e = objects.ellipses; e != NULL; e = e->next)
X		objectcount++;
X	if (anyline_in_mask())
X	    for (l = objects.lines; l != NULL; l = l->next)
X		if (validline_in_mask(l))
X		    objectcount++;
X	if (anyspline_in_mask())
X	    for (s = objects.splines; s != NULL; s = s->next)
X		if (validspline_in_mask(s))
X		    objectcount++;
X	if (anytext_in_mask())
X	    for (t = objects.texts; t != NULL; t = t->next)
X		if (validtext_in_mask(t))
X		    objectcount++;
X	if (arc_in_mask())
X	    for (a = objects.arcs; a != NULL; a = a->next)
X		objectcount++;
X	if (compound_in_mask())
X	    for (c = objects.compounds; c != NULL; c = c->next)
X		objectcount++;
X	e = NULL;
X	type = O_ELLIPSE;
X    }
X}
X
Xvoid
Xdo_object_search(x, y, shift)
X    int		    x, y;
X    unsigned int    shift;	/* Shift Key Status from XEvent */
X{
X    int		    px, py;
X    char	    found = 0;
X
X    init_search();
X    for (n = 0; n < objectcount;) {
X	switch (type) {
X	case O_ELLIPSE:
X	    found = next_ellipse_found(x, y, TOLERANCE, &px, &py, shift);
X	    break;
X	case O_POLYLINE:
X	    found = next_line_found(x, y, TOLERANCE, &px, &py, shift);
X	    break;
X	case O_SPLINE:
X	    found = next_spline_found(x, y, TOLERANCE, &px, &py, shift);
X	    break;
X	case O_TEXT:
X	    found = next_text_found(x, y, TOLERANCE, &px, &py, shift);
X	    break;
X	case O_ARC:
X	    found = next_arc_found(x, y, TOLERANCE, &px, &py, shift);
X	    break;
X	case O_COMPOUND:
X	    found = next_compound_found(x, y, TOLERANCE, &px, &py, shift);
X	    break;
X	}
X
X	if (found)
X	    break;
X
X	switch (type) {
X	case O_ELLIPSE:
X	    type = O_POLYLINE;
X	    l = NULL;
X	    break;
X	case O_POLYLINE:
X	    type = O_SPLINE;
X	    s = NULL;
X	    break;
X	case O_SPLINE:
X	    type = O_TEXT;
X	    t = NULL;
X	    break;
X	case O_TEXT:
X	    type = O_ARC;
X	    a = NULL;
X	    break;
X	case O_ARC:
X	    type = O_COMPOUND;
X	    c = NULL;
X	    break;
X	case O_COMPOUND:
X	    type = O_ELLIPSE;
X	    e = NULL;
X	    break;
X	}
X    }
X    if (!found) {		/* nothing found */
X	csr_x = x;
X	csr_y = y;
X	type = -1;
X	show_objecthighlight();
X    } else if (shift) {		/* show selected object */
X	show_objecthighlight();
X    } else {			/* user selected an object */
X	erase_objecthighlight();
X	switch (type) {
X	case O_ELLIPSE:
X	    manipulate(e, type, x, y, px, py);
X	    break;
X	case O_POLYLINE:
X	    manipulate(l, type, x, y, px, py);
X	    break;
X	case O_SPLINE:
X	    manipulate(s, type, x, y, px, py);
X	    break;
X	case O_TEXT:
X	    manipulate(t, type, x, y, px, py);
X	    break;
X	case O_ARC:
X	    manipulate(a, type, x, y, px, py);
X	    break;
X	case O_COMPOUND:
X	    manipulate(c, type, x, y, px, py);
X	    break;
X	}
X    }
X}
X
Xobject_search_left(x, y, shift)
X    int		    x, y;
X    unsigned int    shift;	/* Shift Key Status from XEvent */
X{
X    manipulate = handlerproc_left;
X    do_object_search(x, y, shift);
X}
X
Xobject_search_middle(x, y, shift)
X    int		    x, y;
X    unsigned int    shift;	/* Shift Key Status from XEvent */
X{
X    manipulate = handlerproc_middle;
X    do_object_search(x, y, shift);
X}
X
Xobject_search_right(x, y, shift)
X    int		    x, y;
X    unsigned int    shift;	/* Shift Key Status from XEvent */
X{
X    manipulate = handlerproc_right;
X    do_object_search(x, y, shift);
X}
X
Xchar
Xnext_ellipse_point_found(x, y, tol, point_num, shift)
X    int		    x, y, tol, shift, *point_num;
X
X/* dirty trick - point_num is called as a `F_point *point_num' */
X{
X
X    if (!ellipse_in_mask())
X	return (0);
X    if (e == NULL)
X	e = last_ellipse(objects.ellipses);
X    else if (shift)
X	e = prev_ellipse(objects.ellipses, e);
X
X    for (; e != NULL; e = prev_ellipse(objects.ellipses, e), n++) {
X	if (abs(e->start.x - x) <= tol && abs(e->start.y - y) <= tol) {
X	    *point_num = 0;
X	    return (1);
X	}
X	if (abs(e->end.x - x) <= tol && abs(e->end.y - y) <= tol) {
X	    *point_num = 1;
X	    return (1);
X	}
X    }
X    return (0);
X}
X
Xchar
Xnext_arc_point_found(x, y, tol, point_num, shift)
X    int		    x, y, tol, shift, *point_num;
X
X/* dirty trick - point_num is called as a `F_point *point_num' */
X{
X    int		    i;
X
X    if (!arc_in_mask())
X	return (0);
X    if (a == NULL)
X	a = last_arc(objects.arcs);
X    else if (shift)
X	a = prev_arc(objects.arcs, a);
X
X    for (; a != NULL; a = prev_arc(objects.arcs, a), n++) {
X	for (i = 0; i < 3; i++) {
X	    if (abs(a->point[i].x - x) <= tol &&
X		abs(a->point[i].y - y) <= tol) {
X		*point_num = i;
X		return (1);
X	    }
X	}
X    }
X    return (0);
X}
X
Xchar
Xnext_spline_point_found(x, y, tol, p, q, shift)
X    int		    x, y, tol, shift;
X    F_point	  **p, **q;
X{
X    if (!anyspline_in_mask())
X	return (0);
X    if (s == NULL)
X	s = last_spline(objects.splines);
X    else if (shift)
X	s = prev_spline(objects.splines, s);
X
X    for (; s != NULL; s = prev_spline(objects.splines, s))
X	if (validspline_in_mask(s)) {
X	    n++;
X	    *p = NULL;
X	    for (*q = s->points; *q != NULL; *p = *q, *q = (*q)->next) {
X		if (abs((*q)->x - x) <= tol && abs((*q)->y - y) <= tol)
X		    return (1);
X	    }
X	}
X    return (0);
X}
X
Xchar
Xnext_line_point_found(x, y, tol, p, q, shift)
X    int		    x, y, tol, shift;
X    F_point	  **p, **q;
X{
X    F_point	   *a, *b;
X
X    if (!anyline_in_mask())
X	return (0);
X    if (l == NULL)
X	l = last_line(objects.lines);
X    else if (shift)
X	l = prev_line(objects.lines, l);
X
X    for (; l != NULL; l = prev_line(objects.lines, l))
X	if (validline_in_mask(l)) {
X	    n++;
X	    for (a = NULL, b = l->points; b != NULL; a = b, b = b->next) {
X		if (abs(b->x - x) <= tol && abs(b->y - y) <= tol) {
X		    *p = a;
X		    *q = b;
X		    return (1);
X		}
X	    }
X	}
X    return (0);
X}
X
Xchar
Xnext_compound_point_found(x, y, tol, p, q, shift)
X    int		    x, y, tol, shift, *p, *q;
X
X/* dirty trick - p and q are called with type `F_point' */
X{
X    if (!compound_in_mask())
X	return (0);
X    if (c == NULL)
X	c = last_compound(objects.compounds);
X    else if (shift)
X	c = prev_compound(objects.compounds, c);
X
X    for (; c != NULL; c = prev_compound(objects.compounds, c), n++) {
X	if (abs(c->nwcorner.x - x) <= tol &&
X	    abs(c->nwcorner.y - y) <= tol) {
X	    *p = c->nwcorner.x;
X	    *q = c->nwcorner.y;
X	    return (1);
X	}
X	if (abs(c->nwcorner.x - x) <= tol &&
X	    abs(c->secorner.y - y) <= tol) {
X	    *p = c->nwcorner.x;
X	    *q = c->secorner.y;
X	    return (1);
X	}
X	if (abs(c->secorner.x - x) <= tol &&
X	    abs(c->nwcorner.y - y) <= tol) {
X	    *p = c->secorner.x;
X	    *q = c->nwcorner.y;
X	    return (1);
X	}
X	if (abs(c->secorner.x - x) <= tol &&
X	    abs(c->secorner.y - y) <= tol) {
X	    *p = c->secorner.x;
X	    *q = c->secorner.y;
X	    return (1);
X	}
X    }
X    return (0);
X}
X
Xvoid
Xinit_searchproc_left(handlerproc)
X    int		    (*handlerproc) ();
X
X{
X    handlerproc_left = handlerproc;
X}
X
Xvoid
Xinit_searchproc_middle(handlerproc)
X    int		    (*handlerproc) ();
X
X{
X    handlerproc_middle = handlerproc;
X}
X
Xvoid
Xinit_searchproc_right(handlerproc)
X    int		    (*handlerproc) ();
X
X{
X    handlerproc_right = handlerproc;
X}
X
Xvoid
Xdo_point_search(x, y, shift)
X    int		    x, y;
X    unsigned int    shift;	/* Shift Key Status from XEvent */
X{
X    F_point	   *px, *py;
X    char	    found = 0;
X
X    px = &point1;
X    py = &point2;
X    init_search();
X    for (n = 0; n < objectcount;) {
X	switch (type) {
X	case O_ELLIPSE:
X	    /* dirty trick - px returns point_num */
X	    found = next_ellipse_point_found(x, y, TOLERANCE, &px, shift);
X	    break;
X	case O_POLYLINE:
X	    found = next_line_point_found(x, y, TOLERANCE, &px, &py, shift);
X	    break;
X	case O_SPLINE:
X	    found = next_spline_point_found(x, y, TOLERANCE, &px, &py, shift);
X	    break;
X	case O_ARC:
X	    /* dirty trick - px returns point_num */
X	    found = next_arc_point_found(x, y, TOLERANCE, &px, shift);
X	    break;
X	case O_COMPOUND:
X	    found = next_compound_point_found(x, y, TOLERANCE, &px, &py, shift);
X	    break;
X	}
X	if (found) {
X	    if (shift)
X		show_objecthighlight();
X	    break;
X	}
X	switch (type) {
X	case O_ELLIPSE:
X	    type = O_POLYLINE;
X	    l = NULL;
X	    break;
X	case O_POLYLINE:
X	    type = O_SPLINE;
X	    s = NULL;
X	    break;
X	case O_SPLINE:
X	    type = O_ARC;
X	    a = NULL;
X	    break;
X	case O_ARC:
X	    type = O_COMPOUND;
X	    c = NULL;
X	    break;
X	case O_COMPOUND:
X	    type = O_ELLIPSE;
X	    e = NULL;
X	    break;
X	}
X    }
X    if (!found) {
X	csr_x = x;
X	csr_y = y;
X	type = -1;
X	show_objecthighlight();
X    } else if (shift) {
X	show_objecthighlight();
X    } else {
X	erase_objecthighlight();
X	switch (type) {
X	case O_ELLIPSE:
X	    manipulate(e, type, x, y, px, py);
X	    break;
X	case O_POLYLINE:
X	    manipulate(l, type, x, y, px, py);
X	    break;
X	case O_SPLINE:
X	    manipulate(s, type, x, y, px, py);
X	    break;
X	case O_ARC:
X	    manipulate(a, type, x, y, px, py);
X	    break;
X	case O_COMPOUND:
X	    manipulate(c, type, x, y, px, py);
X	    break;
X	}
X    }
X}
X
Xpoint_search_left(x, y, shift)
X    int		    x, y;
X    unsigned int    shift;	/* Shift Key Status from XEvent */
X{
X    manipulate = handlerproc_left;
X    do_point_search(x, y, shift);
X}
X
Xpoint_search_middle(x, y, shift)
X    int		    x, y;
X    unsigned int    shift;	/* Shift Key Status from XEvent */
X{
X    manipulate = handlerproc_middle;
X    do_point_search(x, y, shift);
X}
X
Xpoint_search_right(x, y, shift)
X    int		    x, y;
X    unsigned int    shift;	/* Shift Key Status from XEvent */
X{
X    manipulate = handlerproc_right;
X    do_point_search(x, y, shift);
X}
X
X/* =============================================================== */
X
X/* These are some of the original search subroutines which are still in use */
X
XF_text	       *
Xtext_search(x, y)
X    int		    x, y;
X{
X    F_text	   *t;
X    int		    xmin, xmax, ymin, ymax;
X
X    for (t = objects.texts; t != NULL; t = t->next) {
X	text_bound(t, &xmin, &ymin, &xmax, &ymax);
X	if (x >= xmin && x <= xmax &&
X	    y >= ymin && y <= ymax)
X		return(t);
X    }
X    return (NULL);
X}
X
XF_compound     *
Xcompound_search(x, y, tolerance, px, py)
X    int		    x, y, tolerance, *px, *py;
X{
X    F_compound	   *c;
X    float	    tol2;
X
X    tol2 = tolerance * tolerance;
X
X    for (c = objects.compounds; c != NULL; c = c->next) {
X	if (close_to_vector(c->nwcorner.x, c->nwcorner.y, c->nwcorner.x,
X			    c->secorner.y, x, y, tolerance, tol2, px, py))
X	    return (c);
X	if (close_to_vector(c->secorner.x, c->secorner.y, c->nwcorner.x,
X			    c->secorner.y, x, y, tolerance, tol2, px, py))
X	    return (c);
X	if (close_to_vector(c->secorner.x, c->secorner.y, c->secorner.x,
X			    c->nwcorner.y, x, y, tolerance, tol2, px, py))
X	    return (c);
X	if (close_to_vector(c->nwcorner.x, c->nwcorner.y, c->secorner.x,
X			    c->nwcorner.y, x, y, tolerance, tol2, px, py))
X	    return (c);
X    }
X    return (NULL);
X}
X
XF_compound     *
Xcompound_point_search(x, y, tol, cx, cy, fx, fy)
X    int		    x, y, tol, *cx, *cy, *fx, *fy;
X{
X    F_compound	   *c;
X
X    for (c = objects.compounds; c != NULL; c = c->next) {
X	if (abs(c->nwcorner.x - x) <= tol &&
X	    abs(c->nwcorner.y - y) <= tol) {
X	    *cx = c->nwcorner.x;
X	    *cy = c->nwcorner.y;
X	    *fx = c->secorner.x;
X	    *fy = c->secorner.y;
X	    return (c);
X	}
X	if (abs(c->nwcorner.x - x) <= tol &&
X	    abs(c->secorner.y - y) <= tol) {
X	    *cx = c->nwcorner.x;
X	    *cy = c->secorner.y;
X	    *fx = c->secorner.x;
X	    *fy = c->nwcorner.y;
X	    return (c);
X	}
X	if (abs(c->secorner.x - x) <= tol &&
X	    abs(c->nwcorner.y - y) <= tol) {
X	    *cx = c->secorner.x;
X	    *cy = c->nwcorner.y;
X	    *fx = c->nwcorner.x;
X	    *fy = c->secorner.y;
X	    return (c);
X	}
X	if (abs(c->secorner.x - x) <= tol &&
X	    abs(c->secorner.y - y) <= tol) {
X	    *cx = c->secorner.x;
X	    *cy = c->secorner.y;
X	    *fx = c->nwcorner.x;
X	    *fy = c->nwcorner.y;
X	    return (c);
X	}
X    }
X    return (NULL);
X}
END_OF_FILE
if test 19267 -ne `wc -c <'u_search.c'`; then
    echo shar: \"'u_search.c'\" unpacked with wrong size!
fi
# end of 'u_search.c'
fi
echo shar: End of archive 13 \(of 27\).
cp /dev/null ark13isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 27 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM       | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@imd.sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
