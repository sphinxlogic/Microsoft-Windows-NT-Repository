Newsgroups: comp.sources.x
From: envbvs@epb9.lbl.gov (Brian V. Smith)
Subject: v19i121:  xfig - Draw amd manipulate objects in an X-Window, Part09/27
Message-ID: <1993May21.021359.5646@sparky.imd.sterling.com>
X-Md4-Signature: 5814eb403936751af46cbac30a798e10
Sender: chris@sparky.imd.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Fri, 21 May 1993 02:13:59 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: envbvs@epb9.lbl.gov (Brian V. Smith)
Posting-number: Volume 19, Issue 121
Archive-name: xfig/part09
Environment: X11
Supersedes: xfig: Volume 16, Issue 6-30,39

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 9 (of 27)."
# Contents:  Examples/arithmetic.fig.uu f_epsobj.c f_readold.c
#   u_create.c u_drag.c w_file.c
# Wrapped by envbvs@epb9.lbl.gov.lbl.gov on Mon May  3 12:05:51 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Examples/arithmetic.fig.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Examples/arithmetic.fig.uu'\"
else
echo shar: Extracting \"'Examples/arithmetic.fig.uu'\" \(10539 characters\)
sed "s/^X//" >'Examples/arithmetic.fig.uu' <<'END_OF_FILE'
Xbegin 444 arithmetic.fig
XM(T9)1R`R+C$*.#`@,@HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,2`P"@DP
XM(#`@,2XP,#`@-"XP,#`@."XP,#`*"2`S,S4@,3`P(#,S-2`Q,C<@.3DY.2`Y
XM.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`Q(#`*"3`@,"`Q+C`P,"`T
XM+C`P,"`X+C`P,`H)(#(W-B`Q,#`@,C<V(#$R-R`Y.3DY(#DY.3D*,B`R(#`@
XM,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#(U-"`Q,S`@,CDV(#$S,"`R.38@
XM,30W(#(U-"`Q-#<@,C4T(#$S,"`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@
XM,"`P+C`P,"`P(#$@,`H),"`P(#$N,#`P(#0N,#`P(#@N,#`P"@D@,S8U(#4T
XM-R`S-C4@-3<X(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@
XM,2`P"@DP(#`@,2XP,#`@-"XP,#`@."XP,#`*"2`S-38@-34P(#,U-B`U-S@@
XM.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`Q(#`*"3`@,"`Q
XM+C`P,"`T+C`P,"`X+C`P,`H)(#,T."`U-30@,S0X(#4W."`Y.3DY(#DY.3D*
XM,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,0H),"`P(#$N,#`P(#0N,#`P
XM(#@N,#`P"@D@-3,V(#,W,"`U,S8@,SDU(#DY.3D@.3DY.0HR(#$@,"`Q("TQ
XM(#`@,"`P(#`N,#`P(#`@,"`Q"@DP(#`@,2XP,#`@-"XP,#`@."XP,#`*"2`U
XM,S8@-#(R(#4S-B`V,CD@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP
XM,#`@,"`P(#`*"2`T.3(@,SDU(#0Y,B`T,C`@-3@R(#0R,"`U.#(@,SDU(#0Y
XM,B`S.34@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`Q(#`*
XM"3`@,"`Q+C`P,"`T+C`P,"`X+C`P,`H)(#0S-R`T.3(@-#4Y(#0Y,B`T-3D@
XM-C(V(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,2`P"@DP
XM(#`@,2XP,#`@-"XP,#`@."XP,#`*"2`S.3`@-#DP(#0P.2`T.3`@.3DY.2`Y
XM.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`T,3(@-#8S(#0Q
XM,B`U,3D@-#,W(#4Q.2`T,S<@-#8S(#0Q,B`T-C,@.3DY.2`Y.3DY"C(@,2`P
XM(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#$*"3`@,"`Q+C`P,"`T+C`P,"`X+C`P
XM,`H)(#,R,"`U-#D@,CDV(#4T.2`R.38@-C(Y(#DY.3D@.3DY.0HR(#$@,"`Q
XM("TQ(#`@,"`P(#`N,#`P(#`@,2`P"@DP(#`@,2XP,#`@-"XP,#`@."XP,#`*
XM"2`S-C4@,SDP(#,V-2`T,S`@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@
XM,"XP,#`@,"`Q(#`*"3`@,"`Q+C`P,"`T+C`P,"`X+C`P,`H)(#,U-B`S.3`@
XM,S4V(#0R-R`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#$@
XM,`H),"`P(#$N,#`P(#0N,#`P(#@N,#`P"@D@,S0X(#,Y,"`S-#@@-#(S(#DY
XM.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`Q"@DP(#`@,2XP
XM,#`@-"XP,#`@."XP,#`*"2`S,SD@-#$X(#,S.2`S.3`@.3DY.2`Y.3DY"C(@
XM,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#$*"3`@,"`Q+C`P,"`T+C`P,"`X
XM+C`P,`H)(#(V."`T,S,@,C4T(#0S,R`R-30@-C(Y(#DY.3D@.3DY.0HR(#$@
XM,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,2`P"@DP(#`@,2XP,#`@-"XP,#`@."XP
XM,#`*"2`R.38@-#,S(#,R,"`T,S,@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P
XM(#`@,"XP,#`@,"`P(#`*"2`R-S$@-#`W(#(Y-B`T,#<@,CDV(#0U.2`R-S$@
XM-#4Y(#(W,2`T,#<@.3DY.2`Y.3DY"C(@,R`P(#$@+3$@,"`P(#`@,"XP,#`@
XM,"`P(#`*"2`S,C,@-#$R(#,Y,"`T-#(@,SDP(#4S-2`S,C,@-38U(#,R,R`U
XM,C<@,S0X(#4Q-"`S-#@@-#8S(#,R,R`T-3`*"2`S,C,@-#$R(#DY.3D@.3DY
XM.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@-3,V(#$T-R`U,C<@
XM,34Q(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`Q"@DP
XM(#`@,2XP,#`@-"XP,#`@."XP,#`*"2`U,S$@,C`X(#4S,2`R,C@@-3DU(#(R
XM."`U.34@,S(V(#4V.2`S,C8@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@
XM,"XP,#`@,"`P(#$*"3`@,"`Q+C`P,"`T+C`P,"`X+C`P,`H)(#4S,2`Q,#(@
XM-3,Q(#$X.2`Y.3DY(#DY.3D*,B`R(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@
XM,`H)(#4P,2`Q.#D@-3`Q(#(P-B`U-C$@,C`V(#4V,2`Q.#D@-3`Q(#$X.2`Y
XM.3DY(#DY.3D*,B`R(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#4P,2`R
XM-3@@-3`Q(#,V."`U-CD@,S8X(#4V.2`R-3@@-3`Q(#(U."`Y.3DY(#DY.3D*
XM,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#0X-R`S,3$@-3`P(#,R
XM-"`T.#<@,S,W(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@
XM,"`P"@D@-#0U(#,S,"`T.3(@,S,P(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@
XM,"`P(#`N,#`P(#`@,"`P"@D@-#0U(#,Q."`T.3(@,S$X(#DY.3D@.3DY.0HR
XM(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@,SDY(#(V,B`S.3`@,C8V
XM(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@,SDY
XM(#$T-R`S.3`@,34Q(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P
XM(#`@,2`P"@DP(#`@,2XP,#`@-"XP,#`@."XP,#`*"2`S.34@,S$X(#,Y-2`R
XM,#@@.3DY.2`Y.3DY"C(@,B`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`S
XM-C4@,3@Y(#,V-2`R,#8@-#(U(#(P-B`T,C4@,3@Y(#,V-2`Q.#D@.3DY.2`Y
XM.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#$*"3`@,"`Q+C`P,"`T
XM+C`P,"`X+C`P,`H)(#,Y-2`Q,#(@,SDU(#$X.2`Y.3DY(#DY.3D*,B`R(#`@
XM,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#0R.2`R.3(@-#(Y(#,U-B`T-#4@
XM,S4V(#0T-2`R.3(@-#(Y(#(Y,B`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@
XM,"`P+C`P,"`P(#`@,`H)(#$Q,R`S,S`@-#(Y(#,S,"`Y.3DY(#DY.3D*,B`Q
XM(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#$Q,R`S,3@@-#(Y(#,Q."`Y
XM.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#$P-2`Q
XM,#`@-3<T(#$P,"`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P
XM(#`@,`H)(#$P-2`X-R`U-S0@.#<@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P
XM(#`@,"XP,#`@,"`Q(#`*"3`@,"`Q+C`P,"`T+C`P,"`X+C`P,`H)(#$S,"`Q
XM,#`@,3,P(#$R-R`Y.3DY(#DY.3D*,B`R(#`@,2`M,2`P(#`@,"`P+C`P,"`P
XM(#`@,`H)(#$P.2`Q,S`@,34R(#$S,"`Q-3(@,30W(#$P.2`Q-#<@,3`Y(#$S
XM,"`Y.3DY(#DY.3D*,B`R(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#$V
XM.2`Q,S`@,C$Q(#$S,"`R,3$@,30W(#$V.2`Q-#<@,38Y(#$S,"`Y.3DY(#DY
XM.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#$@,`H),"`P(#$N,#`P(#0N
XM,#`P(#@N,#`P"@D@,3DP(#$P,"`Q.3`@,3(W(#DY.3D@.3DY.0HR(#(@,"`Q
XM("TQ(#`@,"`P(#`N,#`P(#`@,"`P"@D@,3,P(#$W,B`Q,S`@,C,R(#$Y,"`R
XM,S(@,3DP(#$W,B`Q,S`@,3<R(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P
XM(#`N,#`P(#`@,2`P"@DP(#`@,2XP,#`@-"XP,#`@."XP,#`*"2`Q,S`@,30W
XM(#$T-B`Q-CD@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`Q
XM(#`*"3`@,"`Q+C`P,"`T+C`P,"`X+C`P,`H)(#$Y,"`Q-#<@,3<R(#$V.2`Y
XM.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#$S-2`Q
XM,#@@,3(V(#$Q,B`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P
XM(#`@,`H)(#$Y-"`Q,#@@,3@V(#$Q,B`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P
XM(#`@,"`P+C`P,"`P(#$@,`H),"`P(#$N,#`P(#0N,#`P(#@N,#`P"@D@,38P
XM(#(S,B`Q-C`@,C4U(#DY.3D@.3DY.0HR(#(@,"`Q("TQ(#`@,"`P(#`N,#`P
XM(#`@,"`P"@D@,3,P(#(U."`Q,S`@,C<U(#$Y,"`R-S4@,3DP(#(U."`Q,S`@
XM,C4X(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,2`P"@DP
XM(#`@,2XP,#`@-"XP,#`@."XP,#`*"2`Q-C`@,C<U(#$V,"`S,34@.3DY.2`Y
XM.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`Q-C0@,C0Q(#$U
XM-B`R-#4@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*
XM"2`Q-C0@,CDR(#$U-B`R.38@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@
XM,"XP,#`@,"`P(#`*"2`S,#D@,CDR(#,P,2`R.38@.3DY.2`Y.3DY"C(@,2`P
XM(#$@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`S,#D@,C0Q(#,P,2`R-#4@.3DY
XM.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`Q(#`*"3`@,"`Q+C`P
XM,"`T+C`P,"`X+C`P,`H)(#,P-2`R-S4@,S`U(#,Q-2`Y.3DY(#DY.3D*,B`R
XM(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#(W-B`R-3@@,C<V(#(W-2`S
XM,S4@,C<U(#,S-2`R-3@@,C<V(#(U."`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P
XM(#`@,"`P+C`P,"`P(#$@,`H),"`P(#$N,#`P(#0N,#`P(#@N,#`P"@D@,S`U
XM(#(S,B`S,#4@,C4X(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P
XM(#`@,"`P"@D@,S,Y(#$P."`S,S$@,3$R(#DY.3D@.3DY.0HR(#$@,"`Q("TQ
XM(#`@,"`P(#`N,#`P(#`@,"`P"@D@,C<Y(#$P."`R-S$@,3$R(#DY.3D@.3DY
XM.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,2`P"@DP(#`@,2XP,#`@-"XP
XM,#`@."XP,#`*"2`S,S4@,30W(#,Q-R`Q-CD@.3DY.2`Y.3DY"C(@,2`P(#$@
XM+3$@,"`P(#`@,"XP,#`@,"`Q(#`*"3`@,"`Q+C`P,"`T+C`P,"`X+C`P,`H)
XM(#(W-B`Q-#<@,CDR(#$V.2`Y.3DY(#DY.3D*,B`R(#`@,2`M,2`P(#`@,"`P
XM+C`P,"`P(#`@,`H)(#(W-B`Q-S(@,C<V(#(S,B`S,S4@,C,R(#,S-2`Q-S(@
XM,C<V(#$W,B`Y.3DY(#DY.3D*,B`R(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@
XM,`H)(#,Q,R`Q,S`@,S4V(#$S,"`S-38@,30W(#,Q,R`Q-#<@,S$S(#$S,"`Y
XM.3DY(#DY.3D*,B`R(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#$U,B`T
XM.3(@,C$Y(#0Y,B`R,3D@-3$P(#$U,B`U,3`@,34R(#0Y,B`Y.3DY(#DY.3D*
XM,B`R(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#$U,B`U,3`@,C$Y(#4Q
XM,"`R,3D@-3(W(#$U,B`U,C<@,34R(#4Q,"`Y.3DY(#DY.3D*,B`R(#`@,2`M
XM,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#$U,B`U,C<@,C$Y(#4R-R`R,3D@-30T
XM(#$U,B`U-#0@,34R(#4R-R`Y.3DY(#DY.3D*,B`R(#`@,2`M,2`P(#`@,"`P
XM+C`P,"`P(#`@,`H)(#$U,B`U-#0@,C$Y(#4T-"`R,3D@-38Q(#$U,B`U-C$@
XM,34R(#4T-"`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@
XM,`H)(#$S-2`V,CD@-38Q(#8R.2`Y.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@
XM,"`P+C`P,"`P(#`@,`H)(#$S-2`V-#(@-38Q(#8T,B`Y.3DY(#DY.3D*,B`Q
XM(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,`H)(#4U-2`V,C,@-38W(#8S-2`U
XM-34@-C0X(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`P
XM"@D@,30Q(#8R-"`Q,C<@-C,V(#$T,2`V-#D@.3DY.2`Y.3DY"C(@,2`P(#$@
XM+3$@,"`P(#`@,"XP,#`@,"`Q(#$*"3`@,"`Q+C`P,"`T+C`P,"`X+C`P,`H)
XM,"`P(#$N,#`P(#0N,#`P(#@N,#`P"@D@,3@V(#4V,R`Q.#8@-C(V(#DY.3D@
XM.3DY.0HR(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`Q"@DP(#`@,2XP,#`@
XM-"XP,#`@."XP,#`*"2`Q,#<@,3,Y(#DR(#$S.2`Y.3DY(#DY.3D*,B`Q(#`@
XM,2`M,2`P(#`@,"`P+C`P,"`P(#`@,0H),"`P(#$N,#`P(#0N,#`P(#@N,#`P
XM"@D@,C$S(#$S.2`R,CD@,3,Y(#DY.3D@.3DY.0HR(#$@,"`Q("TQ(#`@,"`P
XM(#`N,#`P(#`@,"`Q"@DP(#`@,2XP,#`@-"XP,#`@."XP,#`*"2`R-3$@,3,Y
XM(#(S-R`Q,SD@.3DY.2`Y.3DY"C(@,2`P(#$@+3$@,"`P(#`@,"XP,#`@,"`P
XM(#$*"3`@,"`Q+C`P,"`T+C`P,"`X+C`P,`H)(#$Y,2`R-C8@,C`W(#(V-B`Y
XM.3DY(#DY.3D*,B`Q(#`@,2`M,2`P(#`@,"`P+C`P,"`P(#`@,0H),"`P(#$N
XM,#`P(#0N,#`P(#@N,#`P"@D@,S,W(#(V-B`S-3(@,C8V(#DY.3D@.3DY.0HR
XM(#$@,"`Q("TQ(#`@,"`P(#`N,#`P(#`@,"`Q"@DP(#`@,2XP,#`@-"XP,#`@
XM."XP,#`*"2`S-3@@,3,Y(#,W,R`Q,SD@.3DY.2`Y.3DY"C(@,2`P(#(@+3$@
XM,"`P(#`@,"XP,#`@,"`P(#`*"2`Q-S$@,C$S(#$U,2`Q.3,@.3DY.2`Y.3DY
XM"C(@,2`P(#(@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`Q-S$@,3DS(#$U,2`R
XM,3,@.3DY.2`Y.3DY"C(@,2`P(#(@+3$@,"`P(#`@,"XP,#`@,"`P(#`*"2`S
XM,#4@,3DS(#,P-2`R,3,@.3DY.2`Y.3DY"C(@,2`P(#(@+3$@,"`P(#`@,"XP
XM,#`@,"`P(#`*"2`S,34@,C`S(#(Y-2`R,#,@.3DY.2`Y.3DY"C0@,"`P(#$R
XM(#`@+3$@,"`P+C`P,"`T(#D@,3`V(#(V,R`W,"!!4DE42$U%5$E#(%5.250!
XM"C0@,"`P(#$R(#`@+3$@,"`P+C`P,"`T(#D@.#@@,3$V(#0T,R!!1$1215-3
XM(%5.250!"C0@,"`P(#$R(#`@+3$@,"`P+C`P,"`T(#D@-S`@,S(V(#,X,B!/
XM4$52051)3TX!"C0@,"`P(#$R(#`@+3$@,"`P+C`P,"`T(#$R(#,X(#0Y-R`T
XM,S,@*$U!4BD!"C0@,"`P(#$R(#`@+3$@,"`P+C`P,"`T(#D@.#8@,C4X(#8V
XM,R!!1$1215-3("!"55,!"C0@,"`P(#$R(#`@+3$@,"`P+C`P,"`T(#D@.#(@
XM,S,U(#4Y-B!#3TY$("!#3T1%4P$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@
XM.2`R-"`T,3(@-#4Y($]55`$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`X
XM-R`T.38@-#$R($U%32!!1%(@4D5'`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@
XM-"`Y(#(T(#,U-B`T.3(@04Q5`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y
XM(#$T(#$W-R`U-3<@4C`!"C0@,"`P(#$R(#`@+3$@,"`P+C`P,"`T(#D@,30@
XM,3<W(#4S.2!2,0$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`Q-"`Q-S<@
XM-3(R(%(R`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#$T(#$W-R`U,#4@
XM4C,!"C0@,"`P(#$R(#`@+3$@,"`P+C`P,"`T(#D@,S,@,C8V(#,Y."!414U0
XM`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#4W(#4P.2`S-C4@041$4D53
XM4P$*-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`V,2`U,S8@,3@U($1!5$$@
XM3U54`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#4V(#4S-B`Q-S(@345-
XM3U)9`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#(Y(#4Q.2`R,#(@341/
XM`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@-"`Y(#,T(#,W."`R,#(@651/00$*
XM-"`P(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`R-"`U,SD@,S(V($]55`$*-"`P
XM(#`@,3(@,"`M,2`P(#`N,#`P(#0@.2`Q,R`U,#8@,S(V($E.`0HT(#`@,"`Q
XM,B`P("TQ(#`@,"XP,#`@-"`Y(#(X(#4Q.2`S,#$@4D%-`0HT(#`@,"`Q,B`P
XM("TQ(#`@,"XP,#`@-"`Y(#,T(#4Q-"`R.#,@1$%400$*-"`P(#`@,3(@,"`M
XM,2`P(#`N,#`P(#0@.2`U-2`T,C`@,C@S(%E43TU%30$*-"`P(#`@,3(@,"`M
XM,2`P(#`N,#`P(#0@.2`S-2`R,#<@,S$S(%D@0E53`0HT(#`@,"`Q,B`P("TQ
XM(#`@,"XP,#`@-"`Y(#,R(#$S-2`X,R!!0E53`0HT(#`@,"`Q,B`P("TQ(#`@
XM,"XP,#`@-"`Y(#,R(#$Q,R`Q-#(@355,,`$*-"`P(#`@,3(@,"`M,2`P(#`N
XM,#`P(#0@.2`S,B`Q-S(@,30R($U53#$!"C0@,"`P(#$R(#`@+3$@,"`P+C`P
XM,"`T(#D@-3`@,3,U(#(W,2!-54Q/550!"C0@,"`P(#$R(#`@+3$@,"`P+C`P
XM,"`T(#D@-3$@,C<Y(#(W,2!!1$1/550!"C0@,"`P(#$R(#`@+3$@,"`P+C`P
XM,"`T(#D@,S,@,S$X(#$T,B!!1$0Q`0HT(#`@,"`Q,B`P("TQ(#`@,"XP,#`@
X5-"`Y(#,S(#(U."`Q-#(@041$,`$*
X`
Xend
END_OF_FILE
if test 10539 -ne `wc -c <'Examples/arithmetic.fig.uu'`; then
    echo shar: \"'Examples/arithmetic.fig.uu'\" unpacked with wrong size!
fi
# end of 'Examples/arithmetic.fig.uu'
fi
if test -f 'f_epsobj.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'f_epsobj.c'\"
else
echo shar: Extracting \"'f_epsobj.c'\" \(10986 characters\)
sed "s/^X//" >'f_epsobj.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1992 by Brian Boyter
X * DPS option Copyright 1992 by Dave Hale
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both the copyright
X * notice and this permission notice appear in supporting documentation. 
X * No representations are made about the suitability of this software for 
X * any purpose.  It is provided "as is" without express or implied warranty."
X */
X
X/* GS bitmap generation added: 13 Nov 1992, by Michael C. Grant
X*  (mcgrant@rascals.stanford.edu) adapted from Marc Goldburg's
X*  (marcg@rascals.stanford.edu) original idea and code. */
X
X#include "fig.h"
X#include "resources.h"
X#include "object.h"
X#include "paintop.h"
X#include "u_create.h"
X#include "u_elastic.h"
X#include "w_canvas.h"
X#include "w_setup.h"
X#include "mode.h"
X
Xread_epsf(eps)
X    F_eps	   *eps;
X{
X    int		    nbitmap;
X    int		    bitmapz;
X    char	   *cp;
X    unsigned char  *mp;
X    unsigned int    hexnib;
X    int		    flag,preview;
X    char	    buf[300];
X    int		    llx, lly, urx, ury, bad_bbox;
X    FILE	   *epsf;
X    register unsigned char *last;
X#ifdef DPS
X    int dummy, useDPS;
X#endif
X#ifdef GSBIT
X    FILE           *ppmfile, *gsfile;
X    char           *ppmnam;
X    int            useGS;
X#endif
X    int            usePV;
X#ifdef DPS
X    useDPS = 0;
X#endif
X#ifdef GSBIT
X    useGS = 0;
X#endif
X    usePV = 0;
X
X    /* don't touch the flipped flag - caller has already set it */
X    eps->bitmap = (unsigned char *) NULL;
X    eps->hw_ratio = 0.0;
X    eps->size_x = 0;
X    eps->size_y = 0;
X    eps->bit_size.x = 0;
X    eps->bit_size.y = 0;
X    eps->pixmap = (Pixmap) NULL;
X    eps->pix_rotation = 0;
X    eps->pix_width = 0;
X    eps->pix_height = 0;
X    eps->pix_flipped = 0;
X
X    epsf = fopen(eps->file, "r");
X    if (epsf == NULL) {
X	file_msg("Cannot open file: %s", eps->file);
X	return 0;
X    }
X    while (fgets(buf, 300, epsf) != NULL) {
X	lower(buf);
X	if (!strncmp(buf, "%%boundingbox", 13)) {
X	    /* the Encapsulated PostScript Specifications (2.0) doesn't say
X	       that the values for the bounding box must be integers */
X	    float rllx, rlly, rurx, rury;
X	    if (sscanf(buf, "%%%%boundingbox: %f %f %f %f",
X		       &rllx, &rlly, &rurx, &rury) < 4) {
X		file_msg("Bad EPS file: %s", eps->file);
X		fclose(epsf);
X		return 0;
X	    }
X	    llx = round(rllx);
X	    lly = round(rlly);
X	    urx = round(rurx);
X	    ury = round(rury);
X	    break;
X	}
X    }
X
X    eps->hw_ratio = (float) (ury - lly) / (float) (urx - llx);
X    eps->size_x = (urx - llx) * PIX_PER_INCH / 72.0;
X    eps->size_y = (ury - lly) * PIX_PER_INCH / 72.0;
X
X    if ( bad_bbox = ( urx <= llx || ury <= lly ) ) {
X	file_msg("Bad values in EPS bounding box");
X    }
X    bitmapz = 0;
X
X#ifdef DPS
X    /* if Display PostScript on server */
X    if (XQueryExtension(tool_d,"DPSExtension",&dummy,&dummy,&dummy)) {
X	eps->bit_size.x = eps->size_x;
X	eps->bit_size.y = eps->size_y;
X	bitmapz = 1;
X	useDPS = 1;
X    /* else if no Display PostScript */
X    } else {
X#endif
X	/* look for a preview bitmap */
X	while (fgets(buf, 300, epsf) != NULL) {
X	    lower(buf);
X	    if (!strncmp(buf, "%%beginpreview", 14)) {
X		sscanf(buf, "%%%%beginpreview: %d %d %d",
X		   &eps->bit_size.x, &eps->bit_size.y, &bitmapz);
X		bitmapz = 1;
X		usePV = 1;
X		break;
X	    }
X	}
X#ifdef GSBIT
X	/* if GhostScript exists */
X	if (!bitmapz && !bad_bbox && (gsfile = popen("gs -sDEVICE=bit -q -","w" ))) {
X	    ppmnam = tempnam(NULL,"xfig");
X	    eps->bit_size.x = urx - llx + 1;
X	    eps->bit_size.y = ury - lly + 1;
X	    bitmapz = 1;
X	    useGS = 1;
X	}
X#endif
X#ifdef DPS
X    }
X#endif
X    if (!bitmapz) {
X        file_msg("EPS object read OK, but no preview bitmap found/generated");
X        fclose(epsf);
X        return 0;
X    } else if ( eps->bit_size.x <= 0 || eps->bit_size.y <= 0 ) {
X        file_msg("Strange bounding-box/bitmap-size error, no bitmap found/generated");
X        fclose(epsf);
X#ifdef GSBIT
X        if ( useGS )
X            pclose( gsfile );
X#endif
X        return 0;
X    } else {
X	nbitmap = (eps->bit_size.x + 7) / 8 * eps->bit_size.y;
X	eps->bitmap = (unsigned char *) malloc(nbitmap);
X	if (eps->bitmap == NULL) {
X	    file_msg("Could not allocate %d bytes of memory for EPS bitmap\n",
X                     nbitmap);
X	    fclose(epsf);
X#ifdef GSBIT
X            if ( useGS )
X                pclose( gsfile );
X#endif
X	    return 0;
X	}
X    }
X#ifdef DPS
X    /* if Display PostScript */
X    if ( useDPS ) {
X	static int bitmapDPS (FILE*,int,int,int,int,int,int,int,unsigned char *);
X        if (!bitmapDPS(epsf,llx,lly,urx,ury,
X                       eps->size_x,eps->size_y,nbitmap,eps->bitmap)) {
X            file_msg("DPS extension failed to generate EPS bitmap\n");
X            fclose(epsf);
X            return 0;
X        }
X    }
X#endif
X#ifdef GSBIT
X    /* if GhostScript */
X    if ( useGS ) {
X        ppmnam = tempnam("/usr/tmp","xfig");
X 	fprintf(gsfile, "[1 0 0 1 0 0] %d %d <ff 00>\n", eps->bit_size.x, 
X 		eps->bit_size.y);
X 	fprintf(gsfile, "makeimagedevice setdevice\n");
X 	fprintf(gsfile, "0 %d translate 1 -1 scale\n", eps->bit_size.y);
X 	fprintf(gsfile, "%d neg %d neg translate\n", llx, lly);
X 	fprintf(gsfile, "/showpage {null exec} def (%s) run\n", eps->file);
X 	fprintf(gsfile, "(%s) (w) file currentdevice writeppmfile quit\n",
X 		ppmnam);        
X        if ( pclose(gsfile) != 0 || ( ppmfile = fopen(ppmnam,"r") ) == NULL ) {
X            put_msg( "Could not parse EPS file with GS: %s", eps->file);
X            free(eps->bitmap); eps->bitmap = NULL;
X            unlink(ppmnam);
X            return 0;
X        }
X        fgets(buf, 300, ppmfile);
X        fgets(buf, 300, ppmfile);
X        fgets(buf, 300, ppmfile);
X        if ( fread(eps->bitmap,nbitmap,1,ppmfile) != 1 ) {
X            put_msg("Error reading ppm file (EPS problems?): %s", ppmnam);
X            fclose(ppmfile); unlink(ppmnam);
X            free(eps->bitmap); eps->bitmap = NULL;
X            return 0;
X        }
X        fclose(ppmfile); unlink(ppmnam);
X    }
X#endif
X    if ( usePV ) {
X        mp = eps->bitmap;
X        bzero(mp, nbitmap);	/* init bitmap to zero */
X        last = eps->bitmap + nbitmap;
X        flag = True;
X        while (fgets(buf, 300, epsf) != NULL && mp < last) {
X            lower(buf);
X            if (!strncmp(buf, "%%endpreview", 12) ||
X                !strncmp(buf, "%%endimage", 10))
X                break;
X            cp = buf;
X            if (*cp != '%')
X                break;
X            cp++;
X            while (*cp != '\0') {
X                if (isxdigit(*cp)) {
X                    hexnib = hex(*cp);
X                    if (flag) {
X                        flag = False;
X                        *mp = hexnib << 4;
X                    } else {
X                        flag = True;
X                        *mp = *mp + hexnib;
X                        mp++;
X                        if (mp >= last)
X                            break;
X                    }
X                }
X                cp++;
X            }
X        }
X    }
X    put_msg("EPS object read OK");
X    fclose(epsf);
X    return 1;
X}
X
Xint
Xhex(c)
X    char	    c;
X{
X    if (isdigit(c))
X	return (c - 48);
X    else
X	return (c - 87);
X}
X
Xlower(buf)
X    char	   *buf;
X{
X    while (*buf) {
X	if (isupper(*buf))
X	    *buf = (char) tolower(*buf);
X	buf++;
X    }
X}
X
X/* Display PostScript */
X#ifdef DPS
X
X#ifdef sgi
X#include <X11/extensions/XDPS.h>
X#include <X11/extensions/XDPSlib.h>
X#include <X11/extensions/dpsXclient.h>
X#else
X#include <DPS/XDPS.h>
X#include <DPS/XDPSlib.h>
X#include <DPS/dpsXclient.h>
X#endif
X
X#define LBUF 1000
X
Xstatic 
Xint bitmapDPS (FILE *fp, int llx, int lly, int urx, int ury,
X	int width, int height, int nbitmap, unsigned char *bitmap)
X{
X	Display *dpy=tool_d;
X	int scr=tool_sn;
X	unsigned long black=BlackPixel(dpy,scr),white=WhitePixel(dpy,scr);
X	char buf[LBUF];
X	unsigned char *bp,*dp;
X	int line,byte,nbyte;
X	int scrwidth,scrheight,scrwidthmm,scrheightmm;
X	float dppi;
X	GC gcbit;
X	Colormap cm;
X	Pixmap bit;
X	XColor color;
X	XStandardColormap *scm;
X	XImage *image;
X	DPSContext dps;
X	
X	/* create bit pixmap and its GC */
X	bit = XCreatePixmap(dpy,DefaultRootWindow(dpy),width,height,
X			    DefaultDepthOfScreen(tool_s));
X        gcbit = XCreateGC(dpy,bit,0,NULL);
X
X        /* create standard colormap for black-and-white only */
X        cm = XCreateColormap(dpy,RootWindow(dpy,scr),
X                DefaultVisual(dpy,scr),AllocAll);
X        color.pixel = 0;
X        color.red = color.green = color.blue = 0;
X        color.flags = DoRed | DoGreen | DoBlue;
X        XStoreColor(dpy,cm,&color);
X        color.pixel = 1;
X        color.red = color.green = color.blue = 65535;
X        color.flags = DoRed | DoGreen | DoBlue;
X        XStoreColor(dpy,cm,&color);
X        scm = XAllocStandardColormap();
X        scm->colormap = cm;
X        scm->red_max = 1;
X        scm->red_mult = 1;
X        scm->base_pixel = 0;
X        scm->visualid = XVisualIDFromVisual(DefaultVisual(dpy,scr));
X
X        /* create and set Display PostScript context for bit pixmap */
X        dps = XDPSCreateContext(dpy,bit,gcbit,0,height,0,scm,NULL,0,
X                DPSDefaultTextBackstop,DPSDefaultErrorProc,NULL);
X        if (dps==NULL) {
X		file_msg("Cannot create Display PostScript context!");
X		return 0;
X        }
X        DPSPrintf(dps,"\n resyncstart\n");
X        DPSSetContext(dps);
X        DPSFlushContext(dps);
X        DPSWaitContext(dps);
X
X	/* display pixels per inch */
X	scrwidth = WidthOfScreen(DefaultScreenOfDisplay(dpy));
X	scrheight = HeightOfScreen(DefaultScreenOfDisplay(dpy));
X	scrwidthmm = WidthMMOfScreen(DefaultScreenOfDisplay(dpy));
X	scrheightmm = HeightMMOfScreen(DefaultScreenOfDisplay(dpy));
X	dppi = 0.5*((int)(25.4*scrwidth/scrwidthmm)+
X		(int)(25.4*scrheight/scrheightmm));
X
X        /* scale */
X        DPSPrintf(dps,"%f %f scale\n",PIX_PER_INCH/dppi,PIX_PER_INCH/dppi);
X
X        /* paint white background */
X        DPSPrintf(dps,
X                  "gsave\n 1 setgray\n 0 0 %d %d rectfill\n grestore\n",
X                  urx-llx+2,ury-lly+2);
X
X        /* translate */
X        DPSPrintf(dps,"%d %d translate\n",-llx,-lly);
X
X        /* read PostScript from standard input and render in bit pixmap */
X        DPSPrintf(dps,"/showpage {} def\n");
X        while (fgets(buf,LBUF,fp)!=NULL)
X                DPSWritePostScript(dps,buf,strlen(buf));
X        DPSFlushContext(dps);
X        DPSWaitContext(dps);
X
X	/* get image from bit pixmap */
X	image = XGetImage(dpy,bit,0,0,width,height,1,XYPixmap);
X
X	/* copy bits from image to bitmap */
X	bzero(bitmap,nbitmap);
X	nbyte = (width+7)/8;
X	for (line=0; line<height; ++line) {
X		bp = bitmap+line*nbyte;
X		dp = (unsigned char*)(image->data+line*image->bytes_per_line);
X		for (byte=0; byte<nbyte; ++byte)
X			*bp++ = ~(*dp++);
X	}
X
X	/* clean up */
X        DPSDestroySpace(DPSSpaceFromContext(dps));
X	XFreePixmap(dpy,bit);
X	XFreeColormap(dpy,cm);
X	XFreeGC(dpy,gcbit);
X	XDestroyImage(image);
X}
X#endif /* DPS */
END_OF_FILE
if test 10986 -ne `wc -c <'f_epsobj.c'`; then
    echo shar: \"'f_epsobj.c'\" unpacked with wrong size!
fi
# end of 'f_epsobj.c'
fi
if test -f 'f_readold.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'f_readold.c'\"
else
echo shar: Extracting \"'f_readold.c'\" \(10730 characters\)
sed "s/^X//" >'f_readold.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both the copyright
X * notice and this permission notice appear in supporting documentation. 
X * No representations are made about the suitability of this software for 
X * any purpose.  It is provided "as is" without express or implied warranty."
X */
X
X#include "fig.h"
X#include "resources.h"
X#include "object.h"
X#include "u_create.h"
X
X/*******    Fig 1.3 subtype of objects	  *******/
X#define			DRAW_ELLIPSE_BY_RAD	1
X#define			DRAW_ELLIPSE_BY_DIA	2
X#define			DRAW_CIRCLE_BY_RAD	3
X#define			DRAW_CIRCLE_BY_DIA	4
X#define			DRAW_CIRCULAR_ARC	5
X#define			DRAW_POLYLINE		6
X#define			DRAW_BOX		7
X#define			DRAW_POLYGON		8
X#define			DRAW_TEXT		9
X#define			DRAW_SPLINE		10
X#define			DRAW_CLOSEDSPLINE	11
X#define			DRAW_COMPOUND		13
X
Xstatic F_ellipse *read_1_3_ellipseobject();
Xstatic F_line  *read_1_3_lineobject();
Xstatic F_text  *read_1_3_textobject();
Xstatic F_spline *read_1_3_splineobject();
Xstatic F_arc   *read_1_3_arcobject();
Xstatic F_compound *read_1_3_compoundobject();
X
Xextern int	line_no;
Xextern int	num_object;
X
Xint
Xread_1_3_objects(fp, obj)
X    FILE	   *fp;
X    F_compound	   *obj;
X{
X    F_ellipse	   *e, *le = NULL;
X    F_line	   *l, *ll = NULL;
X    F_text	   *t, *lt = NULL;
X    F_spline	   *s, *ls = NULL;
X    F_arc	   *a, *la = NULL;
X    F_compound	   *c, *lc = NULL;
X    int		    n;
X    int		    object, pixperinch, canvaswid, canvasht, coord_sys;
X
X    n = fscanf(fp, "%d%d%d%d\n", &pixperinch, &coord_sys, &canvaswid, &canvasht);
X    if (n != 4) {
X	file_msg("Incorrect format in the first line in input file");
X	return (-1);
X    }
X    obj->nwcorner.x = pixperinch;
X    obj->nwcorner.y = coord_sys;
X    while (fscanf(fp, "%d", &object) == 1) {
X	switch (object) {
X	case O_POLYLINE:
X	    if ((l = read_1_3_lineobject(fp)) == NULL)
X		return (-1);
X	    if (ll)
X		ll = (ll->next = l);
X	    else
X		ll = obj->lines = l;
X	    num_object++;
X	    break;
X	case O_SPLINE:
X	    if ((s = read_1_3_splineobject(fp)) == NULL)
X		return (-1);
X	    if (ls)
X		ls = (ls->next = s);
X	    else
X		ls = obj->splines = s;
X	    num_object++;
X	    break;
X	case O_ELLIPSE:
X	    if ((e = read_1_3_ellipseobject(fp)) == NULL)
X		return (-1);
X	    if (le)
X		le = (le->next = e);
X	    else
X		le = obj->ellipses = e;
X	    num_object++;
X	    break;
X	case O_ARC:
X	    if ((a = read_1_3_arcobject(fp)) == NULL)
X		return (-1);
X	    if (la)
X		la = (la->next = a);
X	    else
X		la = obj->arcs = a;
X	    num_object++;
X	    break;
X	case O_TEXT:
X	    if ((t = read_1_3_textobject(fp)) == NULL)
X		return (-1);
X	    if (lt)
X		lt = (lt->next = t);
X	    else
X		lt = obj->texts = t;
X	    num_object++;
X	    break;
X	case O_COMPOUND:
X	    if ((c = read_1_3_compoundobject(fp)) == NULL)
X		return (-1);
X	    if (lc)
X		lc = (lc->next = c);
X	    else
X		lc = obj->compounds = c;
X	    num_object++;
X	    break;
X	default:
X	    file_msg("Incorrect object code %d", object);
X	    return (-1);
X	}			/* switch */
X    }				/* while */
X    if (feof(fp))
X	return (0);
X    else
X	return (errno);
X}
X
Xstatic F_arc   *
Xread_1_3_arcobject(fp)
X    FILE	   *fp;
X{
X    F_arc	   *a;
X    int		    f, b, h, w, n;
X
X    if ((a = create_arc()) == NULL)
X	return (NULL);
X
X    a->type = T_3_POINTS_ARC;
X    a->color = BLACK;
X    a->depth = 0;
X    a->pen = 0;
X    a->for_arrow = NULL;
X    a->back_arrow = NULL;
X    a->next = NULL;
X    n = fscanf(fp, " %d %d %d %f %d %d %d %d %d %f %f %d %d %d %d %d %d\n",
X	       &a->type, &a->style, &a->thickness,
X	       &a->style_val, &a->direction, &f, &b,
X	       &h, &w, &a->center.x, &a->center.y,
X	       &a->point[0].x, &a->point[0].y,
X	       &a->point[1].x, &a->point[1].y,
X	       &a->point[2].x, &a->point[2].y);
X    if (n != 17) {
X	file_msg("Incomplete arc data");
X	free((char *) a);
X	return (NULL);
X    }
X    if (f) {
X	a->for_arrow = forward_arrow();
X	a->for_arrow->wid = w;
X	a->for_arrow->ht = h;
X    }
X    if (b) {
X	a->back_arrow = backward_arrow();
X	a->back_arrow->wid = w;
X	a->back_arrow->ht = h;
X    }
X    return (a);
X}
X
Xstatic F_compound *
Xread_1_3_compoundobject(fp)
X    FILE	   *fp;
X{
X    F_arc	   *a, *la = NULL;
X    F_ellipse	   *e, *le = NULL;
X    F_line	   *l, *ll = NULL;
X    F_spline	   *s, *ls = NULL;
X    F_text	   *t, *lt = NULL;
X    F_compound	   *com, *c, *lc = NULL;
X    int		    n, object;
X
X    if ((com = create_compound()) == NULL)
X	return (NULL);
X
X    com->arcs = NULL;
X    com->ellipses = NULL;
X    com->lines = NULL;
X    com->splines = NULL;
X    com->texts = NULL;
X    com->compounds = NULL;
X    com->next = NULL;
X    n = fscanf(fp, " %d %d %d %d\n", &com->nwcorner.x, &com->nwcorner.y,
X	       &com->secorner.x, &com->secorner.y);
X    if (n != 4) {
X	file_msg("Incorrect compound object format");
X	return (NULL);
X    }
X    while (fscanf(fp, "%d", &object) == 1) {
X	switch (object) {
X	case O_POLYLINE:
X	    if ((l = read_1_3_lineobject(fp)) == NULL) {
X		free_line(&l);
X		return (NULL);
X	    }
X	    if (ll)
X		ll = (ll->next = l);
X	    else
X		ll = com->lines = l;
X	    break;
X	case O_SPLINE:
X	    if ((s = read_1_3_splineobject(fp)) == NULL) {
X		free_spline(&s);
X		return (NULL);
X	    }
X	    if (ls)
X		ls = (ls->next = s);
X	    else
X		ls = com->splines = s;
X	    break;
X	case O_ELLIPSE:
X	    if ((e = read_1_3_ellipseobject(fp)) == NULL) {
X		free_ellipse(&e);
X		return (NULL);
X	    }
X	    if (le)
X		le = (le->next = e);
X	    else
X		le = com->ellipses = e;
X	    break;
X	case O_ARC:
X	    if ((a = read_1_3_arcobject(fp)) == NULL) {
X		free_arc(&a);
X		return (NULL);
X	    }
X	    if (la)
X		la = (la->next = a);
X	    else
X		la = com->arcs = a;
X	    break;
X	case O_TEXT:
X	    if ((t = read_1_3_textobject(fp)) == NULL) {
X		free_text(&t);
X		return (NULL);
X	    }
X	    if (lt)
X		lt = (lt->next = t);
X	    else
X		lt = com->texts = t;
X	    break;
X	case O_COMPOUND:
X	    if ((c = read_1_3_compoundobject(fp)) == NULL) {
X		free_compound(&c);
X		return (NULL);
X	    }
X	    if (lc)
X		lc = (lc->next = c);
X	    else
X		lc = com->compounds = c;
X	    break;
X	case O_END_COMPOUND:
X	    return (com);
X	}			/* switch */
X    }
X    if (feof(fp))
X	return (com);
X    else {
X	file_msg("Format error: %s", sys_errlist[errno]);
X	return (NULL);
X    }
X}
X
Xstatic F_ellipse *
Xread_1_3_ellipseobject(fp)
X    FILE	   *fp;
X{
X    F_ellipse	   *e;
X    int		    n, t;
X
X    if ((e = create_ellipse()) == NULL)
X	return (NULL);
X
X    e->color = BLACK;
X    e->angle = 0.0;
X    e->depth = 0;
X    e->pen = 0;
X    e->fill_style = 0;
X    e->next = NULL;
X    n = fscanf(fp, " %d %d %d %f %d %d %d %d %d %d %d %d %d\n",
X	       &t, &e->style,
X	       &e->thickness, &e->style_val, &e->direction,
X	       &e->center.x, &e->center.y,
X	       &e->radiuses.x, &e->radiuses.y,
X	       &e->start.x, &e->start.y,
X	       &e->end.x, &e->end.y);
X    if (n != 13) {
X	file_msg("Incomplete ellipse data");
X	free((char *) e);
X	return (NULL);
X    }
X    if (t == DRAW_ELLIPSE_BY_RAD)
X	e->type = T_ELLIPSE_BY_RAD;
X    else if (t == DRAW_ELLIPSE_BY_DIA)
X	e->type = T_ELLIPSE_BY_DIA;
X    else if (t == DRAW_CIRCLE_BY_RAD)
X	e->type = T_CIRCLE_BY_RAD;
X    else
X	e->type = T_CIRCLE_BY_DIA;
X    return (e);
X}
X
Xstatic F_line  *
Xread_1_3_lineobject(fp)
X    FILE	   *fp;
X{
X    F_line	   *l;
X    F_point	   *p, *q;
X    int		    f, b, h, w, n, t, x, y;
X
X    if ((l = create_line()) == NULL)
X	return (NULL);
X
X    l->color = BLACK;
X    l->depth = 0;
X    l->pen = 0;
X    l->fill_style = 0;
X    l->for_arrow = NULL;
X    l->back_arrow = NULL;
X    l->next = NULL;
X    if ((p = create_point()) == NULL) {
X	free((char *) l);
X	return (NULL);
X    }
X    l->points = p;
X    n = fscanf(fp, " %d %d %d %f %d %d %d %d %d %d", &t,
X	       &l->style, &l->thickness, &l->style_val,
X	       &f, &b, &h, &w, &p->x, &p->y);
X    if (n != 10) {
X	file_msg("Incomplete line data");
X	free((char *) l);
X	return (NULL);
X    }
X    if (t == DRAW_POLYLINE)
X	l->type = T_POLYLINE;
X    else if (t == DRAW_POLYGON)
X	l->type = T_POLYGON;
X    else
X	l->type = T_BOX;
X    if (f) {
X	l->for_arrow = forward_arrow();
X	l->for_arrow->wid = w;
X	l->for_arrow->ht = h;
X    }
X    if (b) {
X	l->back_arrow = backward_arrow();
X	l->back_arrow->wid = w;
X	l->back_arrow->ht = h;
X    }
X    for (;;) {
X	if (fscanf(fp, " %d %d", &x, &y) != 2) {
X	    file_msg("Incomplete line object");
X	    free_linestorage(l);
X	    return (NULL);
X	}
X	if (x == 9999)
X	    break;
X	if ((q = create_point()) == NULL)
X	    return (NULL);
X	q->x = x;
X	q->y = y;
X	q->next = NULL;
X	p->next = q;
X	p = q;
X    }
X    return (l);
X}
X
Xstatic F_spline *
Xread_1_3_splineobject(fp)
X    FILE	   *fp;
X{
X    F_spline	   *s;
X    F_point	   *p, *q;
X    int		    f, b, h, w, n, t, x, y;
X
X    if ((s = create_spline()) == NULL)
X	return (NULL);
X
X    s->color = BLACK;
X    s->depth = 0;
X    s->pen = 0;
X    s->fill_style = 0;
X    s->for_arrow = NULL;
X    s->back_arrow = NULL;
X    s->controls = NULL;
X    s->next = NULL;
X    if ((p = create_point()) == NULL) {
X	free((char *) s);
X	return (NULL);
X    }
X    s->points = p;
X    n = fscanf(fp, " %d %d %d %f %d %d %d %d %d %d",
X	       &t, &s->style, &s->thickness, &s->style_val,
X	       &f, &b,
X	       &h, &w, &p->x, &p->y);
X    if (n != 10) {
X	file_msg("Incomplete spline data");
X	free((char *) s);
X	return (NULL);
X    }
X    if (t == DRAW_CLOSEDSPLINE)
X	s->type = T_CLOSED_NORMAL;
X    else
X	s->type = T_OPEN_NORMAL;
X    if (f) {
X	s->for_arrow = forward_arrow();
X	s->for_arrow->wid = w;
X	s->for_arrow->ht = h;
X    }
X    if (b) {
X	s->back_arrow = backward_arrow();
X	s->back_arrow->wid = w;
X	s->back_arrow->ht = h;
X    }
X    for (;;) {
X	if (fscanf(fp, " %d %d", &x, &y) != 2) {
X	    file_msg("Incomplete spline object");
X	    free_splinestorage(s);
X	    return (NULL);
X	};
X	if (x == 9999)
X	    break;
X	if ((q = create_point()) == NULL) {
X	    free_splinestorage(s);
X	    return (NULL);
X	}
X	q->x = x;
X	q->y = y;
X	q->next = NULL;
X	p->next = q;
X	p = q;
X    }
X    return (s);
X}
X
Xstatic F_text  *
Xread_1_3_textobject(fp)
X    FILE	   *fp;
X{
X    F_text	   *t;
X    int		    n;
X    char	    buf[128];
X
X    if ((t = create_text()) == NULL)
X	return (NULL);
X
X    t->type = T_LEFT_JUSTIFIED;
X    t->flags = RIGID_TEXT;
X    t->color = BLACK;
X    t->depth = 0;
X    t->pen = 0;
X    t->angle = 0.0;
X    t->next = NULL;
X    n = fscanf(fp, " %d %d %d %d %d %d %d %[^\n]", &t->font,
X	       &t->size, &t->flags, &t->height, &t->length,
X	       &t->base_x, &t->base_y, buf);
X    if (n != 8) {
X	file_msg("Incomplete text data");
X	free((char *) t);
X	return (NULL);
X    }
X    if ((t->cstring = new_string(strlen(buf) + 1)) == NULL) {
X	free((char *) t);
X	return (NULL);
X    }
X    strcpy(t->cstring, buf);
X    if (t->size == 0)
X	t->size = 18;
X    return (t);
X}
END_OF_FILE
if test 10730 -ne `wc -c <'f_readold.c'`; then
    echo shar: \"'f_readold.c'\" unpacked with wrong size!
fi
# end of 'f_readold.c'
fi
if test -f 'u_create.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'u_create.c'\"
else
echo shar: Extracting \"'u_create.c'\" \(10951 characters\)
sed "s/^X//" >'u_create.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both the copyright
X * notice and this permission notice appear in supporting documentation. 
X * No representations are made about the suitability of this software for 
X * any purpose.  It is provided "as is" without express or implied warranty."
X */
X
X#include "fig.h"
X#include "resources.h"
X#include "object.h"
X#include "u_create.h"
X
Xextern int	cur_linewidth;
X
X/* LOCAL */
X
Xstatic float	forward_arrow_wid = 4;
Xstatic float	forward_arrow_ht = 8;
Xstatic int	forward_arrow_type = 0;
Xstatic int	forward_arrow_style = 0;
Xstatic float	forward_arrow_thickness = 1;
X
Xstatic float	backward_arrow_wid = 4;
Xstatic float	backward_arrow_ht = 8;
Xstatic int	backward_arrow_type = 0;
Xstatic int	backward_arrow_style = 0;
Xstatic float	backward_arrow_thickness = 1;
X
Xstatic F_arrow *create_arrow();
Xstatic char	Err_mem[] = "Running out of memory.";
X
X/****************** ARROWS ****************/
X
Xstatic F_arrow *
Xcreate_arrow()
X{
X    F_arrow	   *a;
X
X    if ((a = (F_arrow *) malloc(ARROW_SIZE)) == NULL)
X	put_msg(Err_mem);
X    return (a);
X}
X
XF_arrow	       *
Xforward_arrow()
X{
X    F_arrow	   *a;
X
X    if ((a = create_arrow()) == NULL)
X	return (NULL);
X
X    a->type = forward_arrow_type;
X    a->style = forward_arrow_style;
X    a->thickness = forward_arrow_thickness = (float) cur_linewidth;
X    a->wid = forward_arrow_thickness * forward_arrow_wid;
X    a->ht = forward_arrow_thickness * forward_arrow_ht;
X    return (a);
X}
X
XF_arrow	       *
Xbackward_arrow()
X{
X    F_arrow	   *a;
X
X    if ((a = create_arrow()) == NULL)
X	return (NULL);
X
X    a->type = backward_arrow_type;
X    a->style = backward_arrow_style;
X    a->thickness = backward_arrow_thickness = (float) cur_linewidth;
X    a->wid = backward_arrow_thickness * backward_arrow_wid;
X    a->ht = backward_arrow_thickness * backward_arrow_ht;
X    return (a);
X}
X
XF_arrow	       *
Xnew_arrow(type, style, thickness, wid, ht)
X    int		    type, style;
X    float	    thickness, wid, ht;
X{
X    F_arrow	   *a;
X
X    if ((a = create_arrow()) == NULL)
X	return (NULL);
X
X    a->type = type;
X    a->style = style;
X    a->thickness = thickness;
X    a->wid = wid;
X    a->ht = ht;
X    return (a);
X}
X
X/************************ SMART LINKS *************************/
X
XF_linkinfo     *
Xnew_link(l, ep, pp)
X    F_line	   *l;
X    F_point	   *ep, *pp;
X{
X    F_linkinfo	   *k;
X
X    if ((k = (F_linkinfo *) malloc(LINKINFO_SIZE)) == NULL) {
X	put_msg(Err_mem);
X	return (NULL);
X    }
X    k->line = l;
X    k->endpt = ep;
X    k->prevpt = pp;
X    k->next = NULL;
X    return (k);
X}
X
X/************************ POINTS *************************/
X
XF_point	       *
Xcreate_point()
X{
X    F_point	   *p;
X
X    if ((p = (F_point *) malloc(POINT_SIZE)) == NULL)
X	put_msg(Err_mem);
X    return (p);
X}
X
XF_control      *
Xcreate_cpoint()
X{
X    F_control	   *cp;
X
X    if ((cp = (F_control *) malloc(CONTROL_SIZE)) == NULL)
X	put_msg(Err_mem);
X    return (cp);
X}
X
XF_point	       *
Xcopy_points(orig_pt)
X    F_point	   *orig_pt;
X{
X    F_point	   *new_pt, *prev_pt, *first_pt;
X
X    if ((new_pt = create_point()) == NULL)
X	return (NULL);
X
X    first_pt = new_pt;
X    *new_pt = *orig_pt;
X    new_pt->next = NULL;
X    prev_pt = new_pt;
X    for (orig_pt = orig_pt->next; orig_pt != NULL; orig_pt = orig_pt->next) {
X	if ((new_pt = create_point()) == NULL) {
X	    free_points(first_pt);
X	    return (NULL);
X	}
X	prev_pt->next = new_pt;
X	*new_pt = *orig_pt;
X	new_pt->next = NULL;
X	prev_pt = new_pt;
X    }
X    return (first_pt);
X}
X
X/************************ ARCS *************************/
X
XF_arc	       *
Xcreate_arc()
X{
X    F_arc	   *a;
X
X    if ((a = (F_arc *) malloc(ARCOBJ_SIZE)) == NULL)
X	put_msg(Err_mem);
X    a->tagged = 0;
X    return (a);
X}
X
XF_arc	       *
Xcopy_arc(a)
X    F_arc	   *a;
X{
X    F_arc	   *arc;
X    F_arrow	   *arrow;
X
X    if ((arc = create_arc()) == NULL)
X	return (NULL);
X
X    *arc = *a;
X    arc->next = NULL;
X    if (a->for_arrow) {
X	if ((arrow = create_arrow()) == NULL) {
X	    free((char *) arc);
X	    return (NULL);
X	}
X	arc->for_arrow = arrow;
X	*arrow = *a->for_arrow;
X    }
X    if (a->back_arrow) {
X	if ((arrow = create_arrow()) == NULL) {
X	    free((char *) arc);
X	    return (NULL);
X	}
X	arc->back_arrow = arrow;
X	*arrow = *a->back_arrow;
X    }
X    return (arc);
X}
X
X/************************ ELLIPSES *************************/
X
XF_ellipse      *
Xcreate_ellipse()
X{
X    F_ellipse	   *e;
X
X    if ((e = (F_ellipse *) malloc(ELLOBJ_SIZE)) == NULL)
X	put_msg(Err_mem);
X    e->tagged = 0;
X    return (e);
X}
X
XF_ellipse      *
Xcopy_ellipse(e)
X    F_ellipse	   *e;
X{
X    F_ellipse	   *ellipse;
X
X    if ((ellipse = create_ellipse()) == NULL)
X	return (NULL);
X
X    *ellipse = *e;
X    ellipse->next = NULL;
X    return (ellipse);
X}
X
X/************************ LINES *************************/
X
XF_line	       *
Xcreate_line()
X{
X    F_line	   *l;
X
X    if ((l = (F_line *) malloc(LINOBJ_SIZE)) == NULL)
X	put_msg(Err_mem);
X    l->tagged = 0;
X    l->eps = NULL;
X    l->next = NULL;
X    l->for_arrow = NULL;
X    l->back_arrow = NULL;
X    l->points = NULL;
X    l->radius = DEFAULT;
X    return (l);
X}
X
XF_eps	       *
Xcreate_eps()
X{
X    F_eps	   *e;
X
X    if ((e = (F_eps *) malloc(EPS_SIZE)) == NULL)
X	put_msg(Err_mem);
X    return (e);
X}
X
XF_line	       *
Xcopy_line(l)
X    F_line	   *l;
X{
X    F_line	   *line;
X    F_arrow	   *arrow;
X    int		    nbytes;
X
X    if ((line = create_line()) == NULL)
X	return (NULL);
X
X    *line = *l;
X    line->next = NULL;
X    if (l->for_arrow) {
X	if ((arrow = create_arrow()) == NULL) {
X	    free((char *) line);
X	    return (NULL);
X	}
X	line->for_arrow = arrow;
X	*arrow = *l->for_arrow;
X    }
X    if (l->back_arrow) {
X	if ((arrow = create_arrow()) == NULL) {
X	    free((char *) line);
X	    return (NULL);
X	}
X	line->back_arrow = arrow;
X	*arrow = *l->back_arrow;
X    }
X    line->points = copy_points(l->points);
X    if (NULL == line->points) {
X	put_msg(Err_mem);
X	free_linestorage(line);
X	return (NULL);
X    }
X    if (l->eps != NULL) {
X	if ((line->eps = create_eps()) == NULL) {
X	    free((char *) line);
X	    return (NULL);
X	}
X	bcopy(l->eps, line->eps, EPS_SIZE);
X	if (l->eps->bitmap != NULL) {
X	    nbytes = (line->eps->bit_size.x + 7) / 8 * line->eps->bit_size.y;
X	    line->eps->bitmap = (unsigned char *) malloc(nbytes);
X	    if (line->eps->bitmap == NULL)
X		fprintf(stderr, "xfig: out of memory in function copy_line");
X	    bcopy(l->eps->bitmap, line->eps->bitmap, nbytes);
X	    line->eps->pix_width = 0;
X	    line->eps->pix_height = 0;
X	    line->eps->pixmap = 0;
X	}
X    }
X    return (line);
X}
X
X/************************ SPLINES *************************/
X
XF_spline       *
Xcreate_spline()
X{
X    F_spline	   *s;
X
X    if ((s = (F_spline *) malloc(SPLOBJ_SIZE)) == NULL)
X	put_msg(Err_mem);
X    s->tagged = 0;
X    return (s);
X}
X
XF_spline       *
Xcopy_spline(s)
X    F_spline	   *s;
X{
X    F_spline	   *spline;
X    F_control	   *new_cp, *orig_cp, *last_cp;
X    F_arrow	   *arrow;
X
X    if ((spline = create_spline()) == NULL)
X	return (NULL);
X
X    *spline = *s;
X    spline->next = NULL;
X    if (s->for_arrow) {
X	if ((arrow = create_arrow()) == NULL) {
X	    free((char *) spline);
X	    return (NULL);
X	}
X	spline->for_arrow = arrow;
X	*arrow = *s->for_arrow;
X    }
X    if (s->back_arrow) {
X	if ((arrow = create_arrow()) == NULL) {
X	    free((char *) spline);
X	    return (NULL);
X	}
X	spline->back_arrow = arrow;
X	*arrow = *s->back_arrow;
X    }
X    spline->points = copy_points(s->points);
X    if (NULL == spline->points) {
X	put_msg(Err_mem);
X	free_splinestorage(spline);
X	return (NULL);
X    }
X    spline->controls = NULL;
X    if (s->controls == NULL)
X	return (spline);
X
X    if ((new_cp = create_cpoint()) == NULL) {
X	free_splinestorage(spline);
X	return (NULL);
X    }
X    new_cp->next = NULL;
X    last_cp = spline->controls = new_cp;
X    orig_cp = s->controls;
X    *new_cp = *orig_cp;
X    for (orig_cp = orig_cp->next; orig_cp != NULL; orig_cp = orig_cp->next) {
X	if ((new_cp = create_cpoint()) == NULL) {
X	    free_splinestorage(spline);
X	    return (NULL);
X	}
X	last_cp->next = new_cp;
X	new_cp->next = NULL;
X	*new_cp = *orig_cp;
X	last_cp = new_cp;
X    }
X    return (spline);
X}
X
X/************************ TEXTS *************************/
X
XF_text	       *
Xcreate_text()
X{
X    F_text	   *t;
X
X    if ((t = (F_text *) malloc(TEXOBJ_SIZE)) == NULL)
X	put_msg(Err_mem);
X    t->tagged = 0;
X    return (t);
X}
X
Xchar	       *
Xnew_string(len)
X    int		    len;
X{
X    char	   *c;
X
X    if ((c = (char *) calloc((unsigned) len, sizeof(char))) == NULL)
X	put_msg(Err_mem);
X    return (c);
X}
X
XF_text	       *
Xcopy_text(t)
X    F_text	   *t;
X{
X    F_text	   *text;
X
X    if ((text = create_text()) == NULL)
X	return (NULL);
X
X    *text = *t;
X    if ((text->cstring = new_string(strlen(t->cstring) + 1)) == NULL) {
X	free((char *) text);
X	return (NULL);
X    }
X    strcpy(text->cstring, t->cstring);
X    text->next = NULL;
X    return (text);
X}
X
X/************************ COMPOUNDS *************************/
X
XF_compound     *
Xcreate_compound()
X{
X    F_compound	   *c;
X
X    if ((c = (F_compound *) malloc(COMOBJ_SIZE)) == NULL)
X	put_msg(Err_mem);
X    c->tagged = 0;
X    return (c);
X}
X
XF_compound     *
Xcopy_compound(c)
X    F_compound	   *c;
X{
X    F_ellipse	   *e, *ee;
X    F_arc	   *a, *aa;
X    F_line	   *l, *ll;
X    F_spline	   *s, *ss;
X    F_text	   *t, *tt;
X    F_compound	   *cc, *ccc, *compound;
X
X    if ((compound = create_compound()) == NULL)
X	return (NULL);
X
X    compound->nwcorner = c->nwcorner;
X    compound->secorner = c->secorner;
X    compound->arcs = NULL;
X    compound->ellipses = NULL;
X    compound->lines = NULL;
X    compound->splines = NULL;
X    compound->texts = NULL;
X    compound->compounds = NULL;
X    compound->next = NULL;
X    for (e = c->ellipses; e != NULL; e = e->next) {
X	if (NULL == (ee = copy_ellipse(e))) {
X	    put_msg(Err_mem);
X	    return (NULL);
X	}
X	list_add_ellipse(&compound->ellipses, ee);
X    }
X    for (a = c->arcs; a != NULL; a = a->next) {
X	if (NULL == (aa = copy_arc(a))) {
X	    put_msg(Err_mem);
X	    return (NULL);
X	}
X	list_add_arc(&compound->arcs, aa);
X    }
X    for (l = c->lines; l != NULL; l = l->next) {
X	if (NULL == (ll = copy_line(l))) {
X	    put_msg(Err_mem);
X	    return (NULL);
X	}
X	list_add_line(&compound->lines, ll);
X    }
X    for (s = c->splines; s != NULL; s = s->next) {
X	if (NULL == (ss = copy_spline(s))) {
X	    put_msg(Err_mem);
X	    return (NULL);
X	}
X	list_add_spline(&compound->splines, ss);
X    }
X    for (t = c->texts; t != NULL; t = t->next) {
X	if (NULL == (tt = copy_text(t))) {
X	    put_msg(Err_mem);
X	    return (NULL);
X	}
X	list_add_text(&compound->texts, tt);
X    }
X    for (cc = c->compounds; cc != NULL; cc = cc->next) {
X	if (NULL == (ccc = copy_compound(cc))) {
X	    put_msg(Err_mem);
X	    return (NULL);
X	}
X	list_add_compound(&compound->compounds, ccc);
X    }
X    return (compound);
X}
END_OF_FILE
if test 10951 -ne `wc -c <'u_create.c'`; then
    echo shar: \"'u_create.c'\" unpacked with wrong size!
fi
# end of 'u_create.c'
fi
if test -f 'u_drag.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'u_drag.c'\"
else
echo shar: Extracting \"'u_drag.c'\" \(10463 characters\)
sed "s/^X//" >'u_drag.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both the copyright
X * notice and this permission notice appear in supporting documentation. 
X * No representations are made about the suitability of this software for 
X * any purpose.  It is provided "as is" without express or implied warranty."
X */
X
X#include "fig.h"
X#include "resources.h"
X#include "object.h"
X#include "paintop.h"
X#include "u_draw.h"
X#include "u_elastic.h"
X#include "u_list.h"
X#include "u_undo.h"
X#include "mode.h"
X#include "w_canvas.h"
X#include "w_drawprim.h"
X#include "w_zoom.h"
X
Xstatic int	place_line(), cancel_line();
Xstatic int	place_arc(), cancel_arc();
Xstatic int	place_spline(), cancel_spline();
Xstatic int	place_ellipse(), cancel_ellipse();
Xstatic int	place_text(), cancel_text();
Xstatic int	place_compound(), cancel_compound();
X
Xextern int	copy_selected();
X
X/***************************** ellipse section ************************/
X
Xinit_ellipsedragging(e, x, y)
X    F_ellipse	   *e;
X    int		    x, y;
X{
X    new_e = e;
X    fix_x = cur_x = x;
X    fix_y = cur_y = y;
X    cur_angle = e->angle;
X    x1off = (e->center.x - e->radiuses.x) - cur_x;
X    x2off = (e->center.x + e->radiuses.x) - cur_x;
X    y1off = (e->center.y - e->radiuses.y) - cur_y;
X    y2off = (e->center.y + e->radiuses.y) - cur_y;
X    canvas_locmove_proc = moving_ellipse;
X    canvas_leftbut_proc = place_ellipse;
X    canvas_rightbut_proc = cancel_ellipse;
X    set_action_on();
X    elastic_moveellipse();
X}
X
Xstatic
Xcancel_ellipse()
X{
X    elastic_moveellipse();
X    if (return_proc == copy_selected) {
X	free_ellipse(&new_e);
X    } else {
X	list_add_ellipse(&objects.ellipses, new_e);
X	redisplay_ellipse(new_e);
X    }
X    (*return_proc) ();
X    draw_mousefun_canvas();
X}
X
Xstatic
Xplace_ellipse(x, y)
X    int		    x, y;
X{
X    elastic_moveellipse();
X    adjust_pos(x, y, fix_x, fix_y, &x, &y);
X    translate_ellipse(new_e, x - fix_x, y - fix_y);
X    if (return_proc == copy_selected) {
X	add_ellipse(new_e);
X    } else {
X	list_add_ellipse(&objects.ellipses, new_e);
X	clean_up();
X	set_lastposition(fix_x, fix_y);
X	set_newposition(x, y);
X	set_action_object(F_MOVE, O_ELLIPSE);
X	set_latestellipse(new_e);
X	set_modifiedflag();
X    }
X    redisplay_ellipse(new_e);
X    (*return_proc) ();
X    draw_mousefun_canvas();
X}
X
X/*****************************	arc  section  *******************/
X
Xinit_arcdragging(a, x, y)
X    F_arc	   *a;
X    int		    x, y;
X{
X    new_a = a;
X    fix_x = cur_x = x;
X    fix_y = cur_y = y;
X    canvas_locmove_proc = moving_arc;
X    canvas_leftbut_proc = place_arc;
X    canvas_rightbut_proc = cancel_arc;
X    set_action_on();
X    elastic_movearc(new_a);
X}
X
Xstatic
Xcancel_arc()
X{
X    elastic_movearc(new_a);
X    if (return_proc == copy_selected) {
X	free_arc(&new_a);
X    } else {
X	list_add_arc(&objects.arcs, new_a);
X	redisplay_arc(new_a);
X    }
X    (*return_proc) ();
X    draw_mousefun_canvas();
X}
X
Xstatic
Xplace_arc(x, y)
X    int		    x, y;
X{
X    elastic_movearc(new_a);
X    adjust_pos(x, y, fix_x, fix_y, &x, &y);
X    translate_arc(new_a, x - fix_x, y - fix_y);
X    if (return_proc == copy_selected) {
X	add_arc(new_a);
X    } else {
X	list_add_arc(&objects.arcs, new_a);
X	clean_up();
X	set_lastposition(fix_x, fix_y);
X	set_newposition(x, y);
X	set_action_object(F_MOVE, O_ARC);
X	set_latestarc(new_a);
X	set_modifiedflag();
X    }
X    redisplay_arc(new_a);
X    (*return_proc) ();
X    draw_mousefun_canvas();
X}
X
X/*************************  line  section  **********************/
X
Xinit_linedragging(l, x, y)
X    F_line	   *l;
X    int		    x, y;
X{
X    int		    xmin, ymin, xmax, ymax;
X
X    new_l = l;
X    cur_x = fix_x = x;
X    cur_y = fix_y = y;
X    canvas_locmove_proc = moving_line;
X    canvas_leftbut_proc = place_line;
X    canvas_rightbut_proc = cancel_line;
X    set_action_on();
X    if (l->type == T_BOX || l->type == T_ARC_BOX || l->type == T_EPS_BOX) {
X	line_bound(l, &xmin, &ymin, &xmax, &ymax);
X	get_links(xmin, ymin, xmax, ymax);
X    }
X    elastic_moveline(new_l->points);
X}
X
Xstatic
Xcancel_line()
X{
X    elastic_moveline(new_l->points);
X    free_linkinfo(&cur_links);
X    if (return_proc == copy_selected) {
X	free_line(&new_l);
X    } else {
X	list_add_line(&objects.lines, new_l);
X	redisplay_line(new_l);
X    }
X    (*return_proc) ();
X    draw_mousefun_canvas();
X}
X
Xstatic
Xplace_line(x, y)
X    int		    x, y;
X{
X    int		    dx, dy;
X
X    elastic_moveline(new_l->points);
X    adjust_pos(x, y, fix_x, fix_y, &x, &y);
X    dx = x - fix_x;
X    dy = y - fix_y;
X    translate_line(new_l, dx, dy);
X    clean_up();
X    set_latestline(new_l);
X    if (return_proc == copy_selected) {
X	adjust_links(cur_linkmode, cur_links, dx, dy, 0, 0, 1.0, 1.0, 1);
X	tail(&objects, &object_tails);
X	append_objects(&objects, &saved_objects, &object_tails);
X	set_action_object(F_ADD, O_ALL_OBJECT);
X	free_linkinfo(&cur_links);
X    } else {
X	list_add_line(&objects.lines, new_l);
X	adjust_links(cur_linkmode, cur_links, dx, dy, 0, 0, 1.0, 1.0, 0);
X	set_lastposition(fix_x, fix_y);
X	set_newposition(x, y);
X	set_lastlinkinfo(cur_linkmode, cur_links);
X	cur_links = NULL;
X	set_action_object(F_MOVE, O_POLYLINE);
X    }
X    set_modifiedflag();
X    redisplay_line(new_l);
X    (*return_proc) ();
X    draw_mousefun_canvas();
X}
X
X/************************  text section	 **************************/
X
Xstatic PR_SIZE	txsize;
X
Xinit_textdragging(t, x, y)
X    F_text	   *t;
X    int		    x, y;
X{
X    int		   cw,cw2;
X    float	   angle;
X
X    new_t = t;
X    /* adjust in case text was off positioning grid and positioning is now on */
X    round_coords(new_t->base_x,new_t->base_y);
X    fix_x = cur_x = x;
X    fix_y = cur_y = y;
X    x1off = new_t->base_x - x;
X    y1off = new_t->base_y - y;
X    if (t->type == T_CENTER_JUSTIFIED || t->type == T_RIGHT_JUSTIFIED) {
X	txsize = pf_textwidth(t->fontstruct, strlen(t->cstring), t->cstring);
X	angle = t->angle*180.0/M_PI;
X	if (t->type == T_CENTER_JUSTIFIED) {
X	    cw2 = round(txsize.x/2/zoomscale);
X	    if (angle < 90.0 - 0.001)
X		x1off -= cw2;
X	    else if (angle < 180.0 - 0.001) 
X		y1off += cw2;
X	    else if (angle < 270.0 - 0.001) 
X		x1off += cw2;
X	    else 
X		y1off -= cw2;
X	} else { /* T_RIGHT_JUSTIFIED */
X	    cw = round(txsize.x/zoomscale);
X	    if (angle < 90.0 - 0.001)
X		x1off -= cw;
X	    else if (angle < 180.0 - 0.001) 
X		y1off += cw;
X	    else if (angle < 270.0 - 0.001) 
X		x1off += cw;
X	    else 
X		y1off -= cw;
X	}
X    }
X    canvas_locmove_proc = moving_text;
X    canvas_leftbut_proc = place_text;
X    canvas_rightbut_proc = cancel_text;
X    elastic_movetext();
X    set_action_on();
X}
X
Xstatic
Xcancel_text()
X{
X    elastic_movetext();
X    if (return_proc == copy_selected) {
X	free_text(&new_t);
X    } else {
X	list_add_text(&objects.texts, new_t);
X	redisplay_text(new_t);
X    }
X    (*return_proc) ();
X    draw_mousefun_canvas();
X}
X
Xstatic
Xplace_text(x, y)
X    int		    x, y;
X{
X    elastic_movetext();
X    adjust_pos(x, y, fix_x, fix_y, &x, &y);
X    translate_text(new_t, x - fix_x, y - fix_y);
X    if (return_proc == copy_selected) {
X	add_text(new_t);
X    } else {
X	list_add_text(&objects.texts, new_t);
X	clean_up();
X	set_lastposition(fix_x, fix_y);
X	set_newposition(x, y);
X	set_action_object(F_MOVE, O_TEXT);
X	set_latesttext(new_t);
X	set_modifiedflag();
X    }
X    redisplay_text(new_t);
X    (*return_proc) ();
X    draw_mousefun_canvas();
X}
X
X/*************************  spline  section  **********************/
X
Xinit_splinedragging(s, x, y)
X    F_spline	   *s;
X    int		    x, y;
X{
X    new_s = s;
X    cur_x = fix_x = x;
X    cur_y = fix_y = y;
X    canvas_locmove_proc = moving_spline;
X    canvas_leftbut_proc = place_spline;
X    canvas_rightbut_proc = cancel_spline;
X    set_action_on();
X    elastic_moveline(new_s->points);
X}
X
Xstatic
Xcancel_spline()
X{
X    elastic_moveline(new_s->points);
X    if (return_proc == copy_selected) {
X	free_spline(&new_s);
X    } else {
X	list_add_spline(&objects.splines, new_s);
X	redisplay_spline(new_s);
X    }
X    (*return_proc) ();
X    draw_mousefun_canvas();
X}
X
Xstatic
Xplace_spline(x, y)
X    int		    x, y;
X{
X    elastic_moveline(new_s->points);
X    adjust_pos(x, y, fix_x, fix_y, &x, &y);
X    translate_spline(new_s, x - fix_x, y - fix_y);
X    if (return_proc == copy_selected) {
X	add_spline(new_s);
X    } else {
X	list_add_spline(&objects.splines, new_s);
X	clean_up();
X	set_lastposition(fix_x, fix_y);
X	set_newposition(x, y);
X	set_action_object(F_MOVE, O_SPLINE);
X	set_latestspline(new_s);
X	set_modifiedflag();
X    }
X    redisplay_spline(new_s);
X    (*return_proc) ();
X    draw_mousefun_canvas();
X}
X
X/*****************************	Compound section  *******************/
X
Xinit_compounddragging(c, x, y)
X    F_compound	   *c;
X    int		    x, y;
X{
X    new_c = c;
X    fix_x = cur_x = x;
X    fix_y = cur_y = y;
X    x1off = c->nwcorner.x - x;
X    x2off = c->secorner.x - x;
X    y1off = c->nwcorner.y - y;
X    y2off = c->secorner.y - y;
X    canvas_locmove_proc = moving_box;
X    canvas_leftbut_proc = place_compound;
X    canvas_rightbut_proc = cancel_compound;
X    set_action_on();
X    get_links(c->nwcorner.x, c->nwcorner.y, c->secorner.x, c->secorner.y);
X    elastic_movebox();
X}
X
Xstatic
Xcancel_compound()
X{
X    elastic_movebox();
X    free_linkinfo(&cur_links);
X    if (return_proc == copy_selected) {
X	free_compound(&new_c);
X    } else {
X	list_add_compound(&objects.compounds, new_c);
X	redisplay_compound(new_c);
X    }
X    (*return_proc) ();
X    draw_mousefun_canvas();
X}
X
Xstatic
Xplace_compound(x, y)
X    int		    x, y;
X{
X    int		    dx, dy;
X
X    elastic_movebox();
X    adjust_pos(x, y, fix_x, fix_y, &x, &y);
X    dx = x - fix_x;
X    dy = y - fix_y;
X    translate_compound(new_c, dx, dy);
X    clean_up();
X    set_latestcompound(new_c);
X    if (return_proc == copy_selected) {
X	adjust_links(cur_linkmode, cur_links, dx, dy, 0, 0, 1.0, 1.0, 1);
X	tail(&objects, &object_tails);
X	append_objects(&objects, &saved_objects, &object_tails);
X	set_action_object(F_ADD, O_ALL_OBJECT);
X	free_linkinfo(&cur_links);
X    } else {
X	list_add_compound(&objects.compounds, new_c);
X	adjust_links(cur_linkmode, cur_links, dx, dy, 0, 0, 1.0, 1.0, 0);
X	set_lastposition(fix_x, fix_y);
X	set_newposition(x, y);
X	set_lastlinkinfo(cur_linkmode, cur_links);
X	cur_links = NULL;
X	set_action_object(F_MOVE, O_COMPOUND);
X    }
X    set_modifiedflag();
X    redisplay_compound(new_c);
X    (*return_proc) ();
X    draw_mousefun_canvas();
X}
END_OF_FILE
if test 10463 -ne `wc -c <'u_drag.c'`; then
    echo shar: \"'u_drag.c'\" unpacked with wrong size!
fi
# end of 'u_drag.c'
fi
if test -f 'w_file.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'w_file.c'\"
else
echo shar: Extracting \"'w_file.c'\" \(11258 characters\)
sed "s/^X//" >'w_file.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1991 by Brian V. Smith
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both the copyright
X * notice and this permission notice appear in supporting documentation. 
X * No representations are made about the suitability of this software for 
X * any purpose.  It is provided "as is" without express or implied warranty."
X */
X
X#include "fig.h"
X#include "figx.h"
X#include "resources.h"
X#include "object.h"
X#include "mode.h"
X#include "w_drawprim.h"		/* for char_height */
X#include "w_dir.h"
X#include "w_util.h"
X#include "w_setup.h"
X
Xextern Boolean	file_msg_is_popped;
Xextern Widget	file_msg_popup;
X
Xextern String	text_translations;
Xstatic char	load_msg[] = "The current figure is modified.\nDo you want to discard it and load the new file?";
Xstatic char	buf[40];
X
XDeclareStaticArgs(12);
Xstatic Widget	file_status, num_objects;
Xstatic Widget	cfile_lab, cfile_text;
Xstatic Widget	cancel, save, merge, load;
Xstatic Widget	file_w;
Xstatic Position xposn, yposn;
Xstatic String	file_name_translations =
X	"<Key>Return: load()\n";
Xstatic void	file_panel_cancel(), do_merge();
Xvoid		do_load(), do_save();
Xstatic XtActionsRec	file_name_actions[] =
X{
X    {"load", (XtActionProc) do_load},
X};
Xstatic String	file_translations =
X	"<Message>WM_PROTOCOLS: DismissFile()\n";
Xstatic XtActionsRec	file_actions[] =
X{
X    {"DismissFile", (XtActionProc) file_panel_cancel},
X    {"cancel", (XtActionProc) file_panel_cancel},
X    {"load", (XtActionProc) do_load},
X    {"save", (XtActionProc) do_save},
X    {"merge", (XtActionProc) do_merge},
X};
X
X/* Global so w_dir.c can access us */
X
XWidget		file_panel,	/* so w_dir can access the scrollbars */
X		file_popup,	/* the popup itself */
X		file_selfile,	/* selected file widget */
X		file_mask,	/* mask widget */
X		file_dir,	/* current directory widget */
X		file_flist,	/* file list wiget */
X		file_dlist;	/* dir list wiget */
X
XBoolean		file_up = False;
X
Xstatic void
Xfile_panel_dismiss()
X{
X    FirstArg(XtNstring, "\0");
X    SetValues(file_selfile);	/* clear Filename string */
X    XtPopdown(file_popup);
X    XtSetSensitive(file_w, True);
X    file_up = False;
X}
X
Xstatic void
Xdo_merge(w, ev)
X    Widget	    w;
X    XButtonEvent   *ev;
X{
X    char	    filename[100];
X    char	   *fval, *dval;
X
X    FirstArg(XtNstring, &fval);
X    GetValues(file_selfile);	/* check the ascii widget for a filename */
X    if (emptyname(fval))
X	fval = cur_filename;	/* "Filename" widget empty, use current filename */
X
X    if (emptyname_msg(fval, "MERGE"))
X	return;
X
X    FirstArg(XtNstring, &dval);
X    GetValues(file_dir);
X
X    strcpy(filename, dval);
X    strcat(filename, "/");
X    strcat(filename, fval);
X    if (merge_file(filename) == 0)
X	file_panel_dismiss();
X}
X
Xvoid
Xdo_load(w, ev)
X    Widget	    w;
X    XButtonEvent   *ev;
X{
X    char	   *fval, *dval;
X
X    if (file_popup) {
X	FirstArg(XtNstring, &dval);
X	GetValues(file_dir);
X	FirstArg(XtNstring, &fval);
X	GetValues(file_selfile);	/* check the ascii widget for a filename */
X	if (emptyname(fval))
X	    fval = cur_filename;	/* "Filename" widget empty, use current filename */
X
X	if (emptyname_msg(fval, "LOAD"))
X	    return;
X
X	if (!emptyfigure() && figure_modified) {
X	    XtSetSensitive(load, False);
X	    if (!popup_query(QUERY_YES, load_msg)) {
X		XtSetSensitive(load, True);
X		return;
X	    }
X	    XtSetSensitive(load, True);
X	}
X	if (change_directory(dval) == 0) {
X	    if (load_file(fval) == 0) {
X		FirstArg(XtNlabel, fval);
X		SetValues(cfile_text);		/* set the current filename */
X		if (fval != cur_filename)
X			update_cur_filename(fval);	/* and update cur_filename */
X		update_def_filename();		/* and the default export filename */
X		file_panel_dismiss();
X	    }
X	}
X    } else {
X	(void) load_file(cur_filename);
X    }
X}
X
Xvoid
Xdo_save(w)
X    Widget	    w;
X{
X    char	   *fval, *dval;
X
X    if (emptyfigure_msg("Save"))
X	return;
X
X    if (file_popup) {
X	FirstArg(XtNstring, &fval);
X	GetValues(file_selfile);	/* check the ascii widget for a filename */
X	if (emptyname(fval)) {
X	    fval = cur_filename;	/* "Filename" widget empty, use current filename */
X	    warnexist = False;		/* don't warn if this file exists */
X	/* copy the name from the file_name widget to the current filename */
X	} else
X	    {
X	    warnexist = True;			/* warn if this file exists */
X	    }
X
X	if (emptyname_msg(fval, "Save"))
X	    return;
X
X	/* get the directory from the ascii widget */
X	FirstArg(XtNstring, &dval);
X	GetValues(file_dir);
X
X	if (change_directory(dval) == 0) {
X	    XtSetSensitive(save, False);
X	    if (write_file(fval) == 0) {
X		FirstArg(XtNlabel, fval);
X		SetValues(cfile_text);
X		if (strcmp(fval,cur_filename) != 0) {
X		    update_cur_filename(fval);	/* update cur_filename */
X		    update_def_filename();	/* update the default export filename */
X		}
X		reset_modifiedflag();
X		file_panel_dismiss();
X	    }
X	    XtSetSensitive(save, True);
X	}
X    } else {
X	/* not using popup => filename not changed so ok to write existing file */
X	warnexist = False;			
X	if (write_file(cur_filename) == 0)
X	    reset_modifiedflag();
X    }
X}
X
Xstatic void
Xfile_panel_cancel(w, ev)
X    Widget	    w;
X    XButtonEvent   *ev;
X{
X    file_panel_dismiss();
X}
X
Xpopup_file_panel(w)
X    Widget	    w;
X{
X    extern Atom     wm_delete_window;
X
X    set_temp_cursor(wait_cursor);
X    XtSetSensitive(w, False);
X    file_up = True;
X
X    if (!file_popup)
X	create_file_panel(w);
X    else
X	Rescan(0, 0, 0, 0);
X
X    FirstArg(XtNlabel, (figure_modified ? "      File Status: Modified    " :
X					  "      File Status: Not modified"));
X    SetValues(file_status);
X    sprintf(buf, "Number of Objects: %d", object_count(&objects));
X    FirstArg(XtNlabel, buf);
X    SetValues(num_objects);
X    XtPopup(file_popup, XtGrabNonexclusive);
X    (void) XSetWMProtocols(XtDisplay(file_popup), XtWindow(file_popup),
X			   &wm_delete_window, 1);
X    if (file_msg_is_popped)
X	XtAddGrab(file_msg_popup, False, False);
X    reset_cursor();
X}
X
Xcreate_file_panel(w)
X	Widget		   w;
X{
X	Widget		   file, dir, beside, below;
X	PIX_FONT	   temp_font;
X	static int	   actions_added=0;
X	file_w = w;
X	XtTranslateCoords(w, (Position) 0, (Position) 0, &xposn, &yposn);
X
X	FirstArg(XtNx, xposn);
X	NextArg(XtNy, yposn + 50);
X	NextArg(XtNtitle, "Xfig: File menu");
X	file_popup = XtCreatePopupShell("xfig_file_menu",
X					transientShellWidgetClass,
X					tool, Args, ArgCount);
X	XtOverrideTranslations(file_popup,
X			   XtParseTranslationTable(file_translations));
X
X	file_panel = XtCreateManagedWidget("file_panel", formWidgetClass,
X					   file_popup, NULL, ZERO);
X
X	FirstArg(XtNlabel, "");
X	NextArg(XtNwidth, 400);
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	NextArg(XtNresize, False);
X	file_status = XtCreateManagedWidget("file_status", labelWidgetClass,
X					    file_panel, Args, ArgCount);
X
X	FirstArg(XtNlabel, "");
X	NextArg(XtNwidth, 400);
X	NextArg(XtNfromVert, file_status);
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	NextArg(XtNresize, False);
X	num_objects = XtCreateManagedWidget("num_objects", labelWidgetClass,
X					    file_panel, Args, ArgCount);
X
X	FirstArg(XtNlabel, " Current Filename:");
X	NextArg(XtNfromVert, num_objects);
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	cfile_lab = XtCreateManagedWidget("cur_file_label", labelWidgetClass,
X					  file_panel, Args, ArgCount);
X
X	FirstArg(XtNlabel, cur_filename);
X	NextArg(XtNfromVert, num_objects);
X	NextArg(XtNfromHoriz, cfile_lab);
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	NextArg(XtNwidth, 250);
X	cfile_text = XtCreateManagedWidget("cur_file_name", labelWidgetClass,
X					   file_panel, Args, ArgCount);
X
X	FirstArg(XtNlabel, "         Filename:");
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNfromVert, cfile_lab);
X	NextArg(XtNborderWidth, 0);
X	file = XtCreateManagedWidget("file_label", labelWidgetClass,
X				     file_panel, Args, ArgCount);
X	FirstArg(XtNfont, &temp_font);
X	GetValues(file);
X
X	FirstArg(XtNwidth, 350);
X	NextArg(XtNheight, char_height(temp_font) * 2 + 4);
X	NextArg(XtNeditType, "edit");
X	NextArg(XtNstring, cur_filename);
X	NextArg(XtNinsertPosition, strlen(cur_filename));
X	NextArg(XtNfromHoriz, file);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNfromVert, cfile_lab);
X	NextArg(XtNscrollHorizontal, XawtextScrollWhenNeeded);
X	file_selfile = XtCreateManagedWidget("file_name", asciiTextWidgetClass,
X					     file_panel, Args, ArgCount);
X	XtOverrideTranslations(file_selfile,
X			   XtParseTranslationTable(text_translations));
X
X	if (!actions_added) {
X	    XtAppAddActions(tool_app, file_actions, XtNumber(file_actions));
X	    actions_added = 1;
X	    /* add action to load file */
X	    XtAppAddActions(tool_app, file_name_actions, XtNumber(file_name_actions));
X	}
X
X	/* make <return> in the filename window load the file */
X	XtOverrideTranslations(file_selfile,
X			   XtParseTranslationTable(file_name_translations));
X
X	create_dirinfo(file_panel, file_selfile, &beside, &below,
X		       &file_mask, &file_dir, &file_flist, &file_dlist);
X	/* make <return> in the file list window load the file */
X	XtOverrideTranslations(file_flist,
X			   XtParseTranslationTable(file_name_translations));
X	FirstArg(XtNlabel, "Cancel");
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNhorizDistance, 25);
X	NextArg(XtNheight, 25);
X	NextArg(XtNfromHoriz, beside);
X	NextArg(XtNfromVert, below);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	cancel = XtCreateManagedWidget("cancel", commandWidgetClass,
X				       file_panel, Args, ArgCount);
X	XtAddEventHandler(cancel, ButtonReleaseMask, (Boolean) 0,
X			  (XtEventHandler)file_panel_cancel, (XtPointer) NULL);
X
X	FirstArg(XtNlabel, "Save");
X	NextArg(XtNfromHoriz, cancel);
X	NextArg(XtNfromVert, below);
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNhorizDistance, 25);
X	NextArg(XtNheight, 25);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	save = XtCreateManagedWidget("save", commandWidgetClass,
X				     file_panel, Args, ArgCount);
X	XtAddEventHandler(save, ButtonReleaseMask, (Boolean) 0,
X			  (XtEventHandler)do_save, (XtPointer) NULL);
X
X	FirstArg(XtNlabel, "Load");
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	NextArg(XtNfromHoriz, save);
X	NextArg(XtNfromVert, below);
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNhorizDistance, 25);
X	NextArg(XtNheight, 25);
X	load = XtCreateManagedWidget("load", commandWidgetClass,
X				     file_panel, Args, ArgCount);
X	XtAddEventHandler(load, ButtonReleaseMask, (Boolean) 0,
X			  (XtEventHandler)do_load, (XtPointer) NULL);
X
X	FirstArg(XtNlabel, "Merge Read");
X	NextArg(XtNfromHoriz, load);
X	NextArg(XtNfromVert, below);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNhorizDistance, 25);
X	NextArg(XtNheight, 25);
X	merge = XtCreateManagedWidget("merge", commandWidgetClass,
X				      file_panel, Args, ArgCount);
X	XtAddEventHandler(merge, ButtonReleaseMask, (Boolean) 0,
X			  (XtEventHandler)do_merge, (XtPointer) NULL);
X
X	XtInstallAccelerators(file_panel, cancel);
X	XtInstallAccelerators(file_panel, save);
X	XtInstallAccelerators(file_panel, load);
X	XtInstallAccelerators(file_panel, merge);
X}
END_OF_FILE
if test 11258 -ne `wc -c <'w_file.c'`; then
    echo shar: \"'w_file.c'\" unpacked with wrong size!
fi
# end of 'w_file.c'
fi
echo shar: End of archive 9 \(of 27\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 27 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM       | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@imd.sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
