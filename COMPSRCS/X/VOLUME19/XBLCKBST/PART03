Newsgroups: comp.sources.x
From: master@cats.UCSC.EDU (Mark Wedel)
Subject: v19i046:  xblockbuster - a variation of the break-out type games, Part03/05
Message-ID: <1993Mar17.160310.568@sparky.imd.sterling.com>
X-Md4-Signature: b7c1587b7d96ac44934bcfacd4a1cbfb
Date: Wed, 17 Mar 1993 16:03:10 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: master@cats.UCSC.EDU (Mark Wedel)
Posting-number: Volume 19, Issue 46
Archive-name: xblockbuster/part03
Environment: X11R5


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 5)."
# Contents:  CHANGES FILES Imakefile RATIONAL.SV XBlockbuster.ad
#   deflection.c icons/blockbuster.icon icons/brick_j_alt.pr save.c
#   score.c stage.c stagemm.c stagemm.man xblockbuster.h
# Wrapped by master@sleipner on Sat Mar 13 02:21:01 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CHANGES'\"
else
echo shar: Extracting \"'CHANGES'\" \(1247 characters\)
sed "s/^X//" >'CHANGES' <<'END_OF_FILE'
XXBlockBuster v1.00:
X
X Converted to run under X11 instead of SunView.
X
X Clippers no longer leave the remains on the screen.
X
X When raising the pallet with button 1, it will now register a deflection
Xif the pallet moved through where the ball is.  Therefor, if a ball is
Xcoming down, you can raise the pallet without the ball slipping through it.
X
X The hit bonus is now displayed at the top of the screen.
X
X Escape is now used to save instead of 'R1'.
X
X Each ball is now launched by clicking the right mouse button.  Previously,
Xonly the first ball for each stage was started with a click, and subsequent
Xlaunches on that stage were automatic.
X
X The ball(s) stop moving when the pointer exits the window.
X
X The game can be saved as long as no bricks in the stage have been destroyed.
XPreviously, the game could only be saved before play started on the stage.
X
X Color support (via X Resources) for the bricks has been added.  Also,
Xalternate brick images for color have been added.
X
X Removed the *.SKEL files from the distribution.  I do not think that these
Xfiles were really of any use, and you could easily use the programs these
Xran without the shell script interface they provided (I believe some were
Xoutdated by the changes Bill Randle made.)
END_OF_FILE
if test 1247 -ne `wc -c <'CHANGES'`; then
    echo shar: \"'CHANGES'\" unpacked with wrong size!
fi
# end of 'CHANGES'
fi
if test -f 'FILES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'FILES'\"
else
echo shar: Extracting \"'FILES'\" \(1727 characters\)
sed "s/^X//" >'FILES' <<'END_OF_FILE'
XSKELS
XSTAGES
XSTAGES/save
XSTAGES.try
XSTAGES.try/save
XSTAGES.wacko
XSTAGES.wacko/save
Xicons
XCHANGES
XFILES
XImakefile
XMANIFEST
XMakefile.noIm
XRATIONAL.SV
XREADME
XREADME.SV
XSKELS/stage.skel
XSTAGES/stage0
XSTAGES/stage1
XSTAGES/stage10
XSTAGES/stage11
XSTAGES/stage12
XSTAGES/stage13
XSTAGES/stage14
XSTAGES/stage15
XSTAGES/stage16
XSTAGES/stage17
XSTAGES/stage18
XSTAGES/stage19
XSTAGES/stage2
XSTAGES/stage20
XSTAGES/stage21
XSTAGES/stage22
XSTAGES/stage23
XSTAGES/stage3
XSTAGES/stage4
XSTAGES/stage5
XSTAGES/stage6
XSTAGES/stage7
XSTAGES/stage8
XSTAGES/stage9
XSTAGES/nb_stages
XSTAGES/scores
XSTAGES.try/nb_stages
XSTAGES.try/scores
XSTAGES.wacko/stage0
XSTAGES.wacko/stage1
XSTAGES.wacko/nb_stages
XSTAGES.wacko/scores
XXBlockbuster.ad
Xballs_pallet.c
Xbricks.c
Xdeflection.c
Xicons/ball.pr
Xicons/brick_0.pr
Xicons/brick_1.pr
Xicons/brick_2.pr
Xicons/brick_3.pr
Xicons/brick_4.pr
Xicons/brick_5.pr
Xicons/brick_6.pr
Xicons/brick_7.pr
Xicons/brick_8.pr
Xicons/brick_9.pr
Xicons/brick_A.pr
Xicons/brick_C.pr
Xicons/brick_D.pr
Xicons/brick_E.pr
Xicons/brick_G.pr
Xicons/brick_H.pr
Xicons/brick_L.pr
Xicons/brick_M.pr
Xicons/brick_P.pr
Xicons/brick_R.pr
Xicons/brick_S.pr
Xicons/brick_T.pr
Xicons/brick_U.pr
Xicons/brick_W.pr
Xicons/brick_X.pr
Xicons/brick_a.pr
Xicons/brick_b.pr
Xicons/brick_c.pr
Xicons/brick_d.pr
Xicons/brick_e.pr
Xicons/brick_j.pr
Xicons/clear.pr
Xicons/clear0.pr
Xicons/launchNE.pr
Xicons/launchNE0.pr
Xicons/launchNW.pr
Xicons/launchNW0.pr
Xicons/solid.pr
Xicons/solid0.pr
Xicons/blockbuster.icon
Xicons/brick_a_alt.pr
Xicons/brick_b_alt.pr
Xicons/brick_S_alt.pr
Xicons/brick_c_alt.pr
Xicons/brick_0_alt.pr
Xicons/brick_d_alt.pr
Xicons/brick_e_alt.pr
Xicons/brick_j_alt.pr
Xicons/cursor.pr
Xpatchlevel.h
Xsave.c
Xscore.c
Xstage.c
Xstagemm.c
Xstagemm.man
Xxblockbuster.c
Xxblockbuster.h
Xxblockbuster.man
END_OF_FILE
if test 1727 -ne `wc -c <'FILES'`; then
    echo shar: \"'FILES'\" unpacked with wrong size!
fi
# end of 'FILES'
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(1193 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
XXCOMM $XConsortium: Imakefile,v 1.9 91/07/16 23:06:01 gildea Exp $
X/*	 BINDIR = /usr/games/
X*/
X	   FONT	= -DFONT=\"10x20\"
X/*	 MANDIR = /usr/local/man/man6
X*/
X      MANSUFFIX = 6
X/*
X       STAGEDIR = /usr/games/lib/xblockbuster
X*/
X#ifndef STAGEDIR
X#define STAGEDIR = LIBDIR
X#endif
X
X	DEFINES = $(FONT) -DSTAGEDIR=\"$(STAGEDIR)\"
X        DEPLIBS = $(DEPXLIB)
XLOCAL_LIBRARIES = $(XLIB)
X          SRCS1 = balls_pallet.c bricks.c deflection.c save.c score.c stage.c \
X			xblockbuster.c
X          OBJS1 = balls_pallet.o bricks.o deflection.o save.o score.o stage.o \
X			xblockbuster.o
X	  SRCS2 = stagemm.c
X	  OBJS2 = stagemm.o
X       PROGRAMS = xblockbuster stagemm
X
XComplexProgramTarget_1(xblockbuster,$(LOCAL_LIBRARIES),-lm)
XSingleProgramTarget(stagemm,$(OBJS2), NullParameter, NullParameter)
XInstallAppDefaults(XBlockbuster)
XInstallManPage(xblockbuster, $(MANDIR))
XInstallManPage(stagemm, $(MANDIR))
XInstallProgram(stagemm, $(BINDIR))
X/*
X  There must be a better way of doing this install, other than listing
X  the 40 or so files and doing a InstallMultiple.
X*/
Xinstall::
X	MakeDir($(STAGEDIR))
X	cp -r STAGES* $(STAGEDIR)
X	chmod 666 $(STAGEDIR)/STAGES*/scores
X	chmod 777 $(STAGEDIR)/STAGES*/save
X
END_OF_FILE
if test 1193 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'RATIONAL.SV' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'RATIONAL.SV'\"
else
echo shar: Extracting \"'RATIONAL.SV'\" \(1343 characters\)
sed "s/^X//" >'RATIONAL.SV' <<'END_OF_FILE'
XThis game was written as an endeavour in learning Sunview.
XA similar effort may someday be made in porting it to X11.
X(unless someone beats me to it!)
X
XThe game as distributed has been played here on Sun 3.50 and 4c.
XThe set of stages is, we believe, balanced both for novice players and experts.
XThey can be modified easily, but as this makes it harder to compare scores,
Xyou should provide a separate play ground.
X
XMakeable things:
X- blockbuster
X	Executable for whatever host your on.
X	(must be executed from within a play ground directory)
X- sun3.50 & sun4
X	Assures tuning parameters are uptodate w.r.t. whatever was last made.
X	(no crosscompilation though, you must be on a sun3.50 or sun4
X		respectively)
X- stagemm
X	Small bookkeeping program, useful if you want to design your own stages.
X
XSkeleton shellscripts:
X(You may wish to adjust, rename and put these in your path.)
X- blockbuster.SKEL
X	Main program (architecture, and directory independent)
X- smm.SKEL
X	Allows you to call stagemm by name ('grep (1)') or number.
X	(must be called from within a play ground directory)
X- tes.SKEL
X	Allows you to edit a stage (starting from a default skeleton);
X	likewise called by name or number (idem).
X- try.SKEL
X	Allows you to try out any stage (no score);
X	likewise called by name or number (idem).
X
X-- Eric Van Gestel (ericvg@cs.kuleuven.ac.be)
END_OF_FILE
if test 1343 -ne `wc -c <'RATIONAL.SV'`; then
    echo shar: \"'RATIONAL.SV'\" unpacked with wrong size!
fi
# end of 'RATIONAL.SV'
fi
if test -f 'XBlockbuster.ad' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'XBlockbuster.ad'\"
else
echo shar: Extracting \"'XBlockbuster.ad'\" \(1166 characters\)
sed "s/^X//" >'XBlockbuster.ad' <<'END_OF_FILE'
XXBlockbuster.alternate_bricks:	True
X*brick0_fg:	darkseagreen
X*brick0_bg:	blue2
X*brick1_fg:	blue2
X*brick1_bg:	green2
X*brick2_fg:	blue2
X*brick2_bg:	green2
X*brick3_fg:	blue2
X*brick3_bg:	green2
X*brick4_fg:	blue2
X*brick4_bg:	green2
X*brick5_fg:	blue2
X*brick5_bg:	green2
X*brick6_fg:	blue2
X*brick6_bg:	green2
X*brick7_fg:	blue2
X*brick7_bg:	green2
X*brick8_fg:	blue2
X*brick8_bg:	green2
X*brick9_fg:	blue2
X*brick9_bg:	green2
X*bricka_fg:	blue1
X*bricka_bg:	gold
X*brickb_fg:	blue1
X*brickb_bg:	gold
X*brickc_fg:	blue1
X*brickc_bg:	gold
X*brickd_fg:	blue1
X*brickd_bg:	gold
X*bricke_fg:	blue1
X*bricke_bg:	gold
X*brickj_fg:	blue1
X*brickj_bg:	gold
X*brickA_fg:	pink
X*brickA_bg:	coral
X*brickC_fg:	plum
X*brickC_bg:	red
X*brickD_fg:	orange1
X*brickD_bg:	blue1
X*brickE_fg:	cyan2
X*brickE_bg:	coral
X*brickG_fg:	red
X*brickG_bg:	azure
X*brickH_fg:	blue1
X*brickH_bg:	aquamarine
X*brickL_fg:	cyan2
X*brickL_bg:	coral
X*brickM_fg:	red
X*brickM_bg:	wheat
X*brickP_fg:	cyan2
X*brickP_bg:	blue1
X*brickR_fg:	wheat
X*brickR_bg:	indianred
X*brickS_fg:	red
X*brickT_fg:	orange1
X*brickT_bg:	blue1
X*brickU_fg:	coral
X*brickU_bg:	blue1
X*brickW_fg:	dodgerblue2
X*brick%_fg:	dodgerblue2
X*brickX_bg:	chartreuse2
X*brick^_fg:	purple
END_OF_FILE
if test 1166 -ne `wc -c <'XBlockbuster.ad'`; then
    echo shar: \"'XBlockbuster.ad'\" unpacked with wrong size!
fi
# end of 'XBlockbuster.ad'
fi
if test -f 'deflection.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'deflection.c'\"
else
echo shar: Extracting \"'deflection.c'\" \(2964 characters\)
sed "s/^X//" >'deflection.c' <<'END_OF_FILE'
X/*
X * File:       deflection.c
X * Author:     Eric Van Gestel
X *
X * For:                xblockbuster
X *
X * No changes required for X11 support - MSW
X *
X * Implementation:
X *     Simple horizontal and vertical deflection only changes the quadrant,
X *     reversing motion along the y and x axes respectively.
X *     Deflection from the convex pallet is a function of excentricity,
X *     as well as of incoming angle (given a sliding of the edge effect).
X */
X
X#include "xblockbuster.h"
X
Xvoid
Xbrick_deflection( hit, ball )
X	register int    hit;	/* enumeration { HORIZONTAL, VERTICAL } */
X	register struct Ball *ball;
X{
X	if ( hit == HORIZONTAL ) {
X		switch ( ball->quadrant ) {
X		case NE:
X			ball->quadrant = SE;
X			break;
X		case NW:
X			ball->quadrant = SW;
X			break;
X		case SW:
X			ball->quadrant = NW;
X			break;
X		case SE:
X			ball->quadrant = NE;
X		}
X		ball->y_speed = -( ball->y_speed );
X	} else {		/* VERTICAL */
X		switch ( ball->quadrant ) {
X		case NE:
X			ball->quadrant = NW;
X			break;
X		case NW:
X			ball->quadrant = NE;
X			break;
X		case SW:
X			ball->quadrant = SE;
X			break;
X		case SE:
X			ball->quadrant = SW;
X		};
X		ball->x_speed = -( ball->x_speed );
X	}
X}
X
Xvoid
Xpallet_deflection( ball )
X	register struct Ball *ball;
X{
X	double          excentricity, true_angle;
X
X	switch ( ball->quadrant ) {
X	case SW:
X		excentricity = ball->x - pallet_x;
X		break;
X	case SE:
X		excentricity = pallet_x - ball->x;
X		break;
X	default:
X		return;		/* bouncing up from below */
X	};
X	ball->angle -= 2 * atan2( excentricity, pallet_height );
X
X	if ( ball->angle > -M_PI_4 )
X		ball->quadrant = ( ball->quadrant == SW ) ? NW
X			 /* SE */ : NE;
X	else {			/* rebound */
X		ball->angle = -M_PI_2 - ball->angle;
X		ball->quadrant = ( ball->quadrant == SW ) ? NE
X			 /* SE */ : NW;
X	};
X
X	/*
X	 * avoid downward slide offs as well as infinite horizontal bounce
X	 * loops
X	 */
X	if ( ball->angle > NEAR_HORIZONTAL )
X		ball->angle = NEAR_HORIZONTAL;
X
X	true_angle = ( ball->quadrant == NE ) ? M_PI_4 - ball->angle
X		 /* NW */ : M_PI_3_4 + ball->angle;
X	ball->x_speed = ball->speed * cos( true_angle );
X	ball->y_speed = ball->speed * -sin( true_angle );
X}
X
X#ifdef DEBUG_PDEFL
Xmain(  )
X{
X	pallet_xI = 0;
X	pallet_x = 0;
X	printf( "\npallet_length & pallet_height:  " );
X	scanf( "%d%d", &pallet_lengthI, &pallet_heightI );
X	pallet_length = ( double ) pallet_lengthI;
X	pallet_height = ( double ) pallet_heightI;
X	if ( pallet_lengthI > 0 && pallet_heightI > pallet_lengthI )
X		for ( ;; ) {
X			printf( "\nquadrant, in angle & excentricity:  " );
X			scanf( "%d%lf%lf", &ball1.quadrant, &ball1.angle, &ball1.x );
X			if ( ball1.quadrant < 1 || ball1.quadrant > 4 ||
X			     ball1.angle < -45 || ball1.angle > 45 ||
X			ball1.x < -pallet_length || ball1.x > pallet_length )
X				break;
X			ball1.angle = ( ball1.angle / 45 ) * M_PI_4;
X			pallet_deflection( &ball1 );
X			ball1.angle = ( ball1.angle * 45 ) / M_PI_4;
X			printf( "==> quadrant: %d  angle: %f\n", ball1.quadrant, ball1.angle );
X		};
X}
X#endif DEBUG_PDEFL
END_OF_FILE
if test 2964 -ne `wc -c <'deflection.c'`; then
    echo shar: \"'deflection.c'\" unpacked with wrong size!
fi
# end of 'deflection.c'
fi
if test -f 'icons/blockbuster.icon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icons/blockbuster.icon'\"
else
echo shar: Extracting \"'icons/blockbuster.icon'\" \(2689 characters\)
sed "s/^X//" >'icons/blockbuster.icon' <<'END_OF_FILE'
X#define blockbuster_width	64
X#define blockbuster_height	64
Xstatic char blockbuster_bits[] = {
X0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,
X0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X0xFF,0x61,0x78,0xAF,0xE1,0x1E,0x86,0xFF,0xFF,0x61,0xB8,0xD7,0xE1,0x1D,0x86,0xFF,
X0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x87,0x7F,0x78,0x87,0xEB,0x1E,0xFE,0xE1,
X0x87,0x7F,0xB8,0x87,0xF5,0x1D,0xFE,0xE1,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,
X0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x87,0x69,0x1A,0xAE,0x61,0x58,0x96,0xE1,
X0x87,0x65,0x19,0xD6,0x61,0x98,0xA6,0xE1,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X0xD7,0x7F,0x1A,0x86,0x6B,0x58,0xFE,0xEB,0xAF,0x7F,0x19,0x86,0x75,0x98,0xFE,0xF5,
X0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x87,0xE1,0x1F,0xAE,0x61,0xF8,0x87,0xE1,
X0x87,0xE1,0x1F,0xD6,0x61,0xF8,0x87,0xE1,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X0xD7,0x61,0xFA,0x87,0xEB,0x5F,0x86,0xEB,0xAF,0x61,0xF9,0x87,0xF5,0x9F,0x86,0xF5,
X0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x87,0x61,0x1A,0xAE,0x61,0x58,0x86,0xE1,
X0x87,0x61,0x19,0xD6,0x61,0x98,0x86,0xE1,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
X0x03,0x04,0x00,0x00,0x00,0x00,0x40,0xC0,0x03,0x0A,0x00,0x00,0x00,0x00,0xA0,0xC0,
X0x03,0x11,0x00,0x00,0x00,0x00,0x10,0xC1,0x83,0x00,0x00,0x00,0x00,0x00,0x08,0xC2,
X0x43,0x40,0x00,0x00,0x00,0x00,0x04,0xC4,0x23,0x00,0x00,0x00,0x00,0x00,0x02,0xC8,
X0x13,0x00,0x01,0x00,0x00,0x00,0x01,0xD0,0x0B,0x00,0x00,0x00,0x00,0x80,0x00,0xE0,
X0x07,0x00,0x04,0x00,0x00,0x40,0x00,0xD0,0x0B,0x00,0x00,0x00,0x00,0x20,0x00,0xC8,
X0x13,0x00,0x00,0x00,0x00,0x10,0x00,0xC4,0x23,0x00,0x00,0x00,0x00,0x08,0x00,0xC2,
X0x43,0x00,0x00,0x00,0x00,0x04,0x00,0xC1,0x83,0x00,0x00,0x00,0x00,0x02,0x80,0xC0,
X0x03,0x01,0x00,0x00,0x00,0x01,0x40,0xC0,0x03,0x02,0x00,0x00,0x80,0x00,0x20,0xC0,
X0x03,0x04,0x00,0x00,0x40,0x00,0x08,0xC0,0x03,0x08,0x00,0x00,0x20,0x00,0x1C,0xC0,
X0x03,0x10,0x00,0x00,0x10,0x00,0x08,0xC0,0x03,0x20,0x00,0x00,0x08,0x00,0x00,0xC0,
X0x03,0x40,0x00,0x00,0x04,0x00,0x00,0xC0,0x03,0x80,0x00,0x00,0x02,0x00,0x00,0xC0,
X0x03,0x00,0x01,0x00,0x01,0x00,0x00,0xC0,0x03,0x00,0x02,0x80,0x00,0x00,0x00,0xC0,
X0x03,0x00,0x04,0x40,0x00,0x00,0x00,0xC0,0x03,0x00,0x08,0x20,0x00,0x00,0x00,0xC0,
X0x03,0x00,0x10,0x10,0x00,0x00,0x00,0xC0,0x03,0x00,0x20,0x08,0x00,0x00,0x00,0xC0,
X0x03,0x00,0x40,0x04,0x00,0x00,0x00,0xC0,0x03,0x00,0x80,0x02,0x00,0x00,0x00,0xC0,
X0x03,0x00,0x00,0x01,0x00,0x00,0x00,0xC0,0x03,0x00,0xE0,0xFF,0x01,0x00,0x00,0xC0,
X0xFF,0x03,0x20,0x00,0x01,0x00,0xC0,0xFF,0xFF,0x03,0xE0,0xFF,0x01,0x00,0xC0,0xFF,
X};
END_OF_FILE
if test 2689 -ne `wc -c <'icons/blockbuster.icon'`; then
    echo shar: \"'icons/blockbuster.icon'\" unpacked with wrong size!
fi
# end of 'icons/blockbuster.icon'
fi
if test -f 'icons/brick_j_alt.pr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'icons/brick_j_alt.pr'\"
else
echo shar: Extracting \"'icons/brick_j_alt.pr'\" \(896 characters\)
sed "s/^X//" >'icons/brick_j_alt.pr' <<'END_OF_FILE'
X#define brick_j_alt_width 64
X#define brick_j_alt_height 16
Xstatic char brick_j_alt_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
X   0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x79, 0x38, 0xfc, 0xff, 0x7f,
X   0xfe, 0xff, 0x7f, 0x38, 0x93, 0xf9, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x39,
X   0x93, 0xf9, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x39, 0x93, 0xf9, 0xff, 0x7f,
X   0xfe, 0xff, 0xff, 0x39, 0x93, 0xf9, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x39,
X   0x93, 0xf9, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x79, 0x38, 0xfc, 0xff, 0x7f,
X   0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 896 -ne `wc -c <'icons/brick_j_alt.pr'`; then
    echo shar: \"'icons/brick_j_alt.pr'\" unpacked with wrong size!
fi
# end of 'icons/brick_j_alt.pr'
fi
if test -f 'save.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'save.c'\"
else
echo shar: Extracting \"'save.c'\" \(1617 characters\)
sed "s/^X//" >'save.c' <<'END_OF_FILE'
X/*
X * File:       save.c
X * Author:     Eric Van Gestel
X *
X * For:                xblockbuster
X * Updated for X11 by Mark S. Wedel
X *
X */
X
X#include "xblockbuster.h"
X
Xvoid
Xstart_up(  )
X{
X	FILE           *fd;
X	char            sve[SAVEFILE_LENGTH];
X	register int    stage_nb_tmp;
X
X	if ((fd = fopen( sprintf( sve, SAVEFILE, playground, login ),"r+" ))) {
X		/* restoring save file */
X		XDrawImageString(display, win, gc, OFFSET_BALLS,
X			font_height, "Restoring...",12);
X
X		fscanf( fd, "%d:%d::%d:%d::%d:%lf\n",
X			&score, &balls_left,
X			&nb_stages, &stage_nb,
X			&pallet_modif, &launch_speed );
X		for ( stage_nb_tmp = 0; stage_nb_tmp < MAX_NB_STAGES; )
X			fscanf( fd, "%1d", &stages[stage_nb_tmp++] );
X		fclose( fd );
X		/* remove save file */
X		unlink( sve );
X		/* restart stage chosen when saved */
X		get_stage(  );
X	} else {
X		/* no save file */
X		score = 0;
X		balls_left = INIT_BALLS;
X		pallet_modif = 0;
X		launch_speed = INIT_SPEED;
X		nb_stages = 0;
X		for ( stage_nb_tmp = 0; stage_nb_tmp < MAX_NB_STAGES; )
X			stages[stage_nb_tmp++] = FALSE;
X		/* start some stage */
X		new_stage(  );
X	}
X}
X
Xvoid
Xsave(  )
X{
X	FILE           *fd;
X	char            sve[SAVEFILE_LENGTH];
X	register int    stage_nb_tmp = 0;
X
X	if ( !( fd = fopen( sprintf( sve, SAVEFILE, playground, login ),
X			    "w" ) ) ) {
X		perror( "Can't open save file" );
X		exit( 1 );
X	}
X	fprintf( fd, "%d:%d::%d:%d::%d:%f\n",
X		 score, balls_left,
X		 nb_stages, stage_nb,
X		 pallet_modif, launch_speed );
X	for ( stage_nb_tmp = 0; stage_nb_tmp < MAX_NB_STAGES; )
X		fprintf( fd, "%1d", stages[stage_nb_tmp++] );
X	close( fd );
X
X	show_score_board(  );	/* BYE !! */
X}
END_OF_FILE
if test 1617 -ne `wc -c <'save.c'`; then
    echo shar: \"'save.c'\" unpacked with wrong size!
fi
# end of 'save.c'
fi
if test -f 'score.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'score.c'\"
else
echo shar: Extracting \"'score.c'\" \(5698 characters\)
sed "s/^X//" >'score.c' <<'END_OF_FILE'
X/*
X * File:       score.c
X * Author:     Eric Van Gestel
X * Updated for X11 by Mark S. Wedel
X *
X * For:                xblockbuster
X *
X * Implementation:
X *     Upto USER_SCORES scores are logged per user.
X *     The insertion low point (i.e., the entry that will disappear) is defined
X *     to be either the user's previous save entry, or his USER_SCORES'th entry
X *     or the last entry if neither exists.
X *     Sometimes saved scores may not be completed
X *     (e.g, if the game crashed or if the player Quit explicitly).
X *     Such entries are given a negative number of balls when detected
X *     (criterium: score not bettered).
X */
X
X#include "xblockbuster.h"
X
Xstruct Score {
X	int             score, balls_left;
X	char            login[9];
X}               score_board[NB_SCORES];
X
Xvoid center_text(offset, message )
Xint offset;
Xchar *message;
X{
X        XDrawImageString(display, win, gc, 
X            ( STAGE_WIDTH_IN_PIXELS - strlen( message ) * font_width ) / 2,
X                BORDER + ( 4 + offset ) * font_height, 
X                message, strlen(message));
X}
X
X
Xvoid
Xshow_score_board(  )
X{
X	register int    lows, s, ns,scorenum=0;
X	register int    update = FALSE;
X	register int    made_it = FALSE;
X	FILE           *fd;
X	char            buf[PATH_LENGTH];
X
X	XClearWindow(display,win);
X
X	/* initalize score board (in case it would be empty) */
X	for ( s = 0; s < NB_SCORES; s++ ) {
X		score_board[s].score = 100;
X		score_board[s].balls_left = 0;
X		( void ) strcpy( score_board[s].login, "computer" );
X	}
X
X	/* read the score file into the array */
X	if ( !( fd = fopen( sprintf( buf, SCOREFILE, playground ), "r+" ) ) ) {
X		perror( "No score file" );
X		exit( 1 );
X	}
X	for ( s = 0; s < NB_SCORES; s++ ) {
X		fscanf( fd, "%d:%d:%s\n", &score_board[s].score,
X			&score_board[s].balls_left,
X			score_board[s].login );
X	}
X
X	/* find insertion low point */
X	for ( lows = ns = 0; lows < NB_SCORES - 1; lows++ ) {
X		if ( !strcmp( score_board[lows].login, login ) ) {
X			if ( score_board[lows].balls_left > 0 ) {
X				if ( score_board[lows].score > score ) {
X					/*
X					 * an older incomplete game: complete
X					 * it
X					 */
X					score_board[lows].balls_left *= -1;
X					ns++;
X					update = TRUE;
X				} else
X					/* (presumably) the previous save */
X					break;
X			} else
X				/* an older completed game */
X				ns++;
X			if ( ns >= USER_SCORES )
X				break;
X		}
X	}
X
X	/* find insertion high point */
X	for ( s = 0; s <= lows && score_board[s].score > score; s++ );
X
X	/* check to see if current score made it */
X	if ( s <= lows ) {
X		/* yes it did , so shift smaller scores */
X		for (  /* lows = lows */ ; lows > s; lows-- )
X			score_board[lows] = score_board[lows - 1];
X		score_board[s].score = score;
X		score_board[s].balls_left = balls_left;
X		( void ) strcpy( score_board[s].login, login );
X		update = TRUE;
X		made_it = TRUE;
X		scorenum=s;
X	}
X	/* write updated score board */
X	if ( update ) {
X		rewind( fd );
X		for ( s = 0; s < NB_SCORES; s++ ) {
X			fprintf( fd, "%d:%d:%s\n", score_board[s].score,
X				 score_board[s].balls_left,
X				 score_board[s].login );
X		}
X	}
X	fclose( fd );
X
X	/* show score board */
X	center_text( 0, "Top Scores" );
X	for ( s = 0; s < NB_SCORES; s++ ) {
X		if ( score_board[s].balls_left > 99 ) {
X			center_text( s + 2, sprintf( buf, "%7d (%3d)   %8s ",
X					     score_board[s].score,
X					     score_board[s].balls_left,
X					     score_board[s].login ) );
X		} else if ( score_board[s].balls_left > 9 ) {
X			center_text( s + 2, sprintf( buf, "%7d  (%2d)   %8s ",
X					     score_board[s].score,
X					     score_board[s].balls_left,
X					     score_board[s].login ) );
X		} else if ( score_board[s].balls_left > 0 ) {
X			center_text( s + 2, sprintf( buf, "%7d   (%1d)   %8s ",
X					     score_board[s].score,
X					     score_board[s].balls_left,
X					     score_board[s].login ) );
X		} else if ( score_board[s].balls_left < -99 ) {
X			center_text( s + 2, sprintf( buf, "%7d (%3d) + %8s ",
X					     score_board[s].score,
X					     -score_board[s].balls_left,
X					     score_board[s].login ) );
X		} else if ( score_board[s].balls_left < -9 ) {
X			center_text( s + 2, sprintf( buf, "%7d  (%2d) + %8s ",
X					     score_board[s].score,
X					     -score_board[s].balls_left,
X					     score_board[s].login ) );
X		} else if ( score_board[s].balls_left < 0 ) {
X			center_text( s + 2, sprintf( buf, "%7d   (%1d) + %8s ",
X					     score_board[s].score,
X					     -score_board[s].balls_left,
X					     score_board[s].login ) );
X		} else {	/* no balls left */
X			center_text( s + 2, sprintf( buf, "%7d         %8s ",
X					     score_board[s].score,
X					     score_board[s].login ) );
X		}
X		if ((s==scorenum) && made_it)
X		    XDrawImageString(display,win,gc,
X			(STAGE_WIDTH_IN_PIXELS - strlen(buf)*font_width)/2 
X			-4*font_width,
X			BORDER+ (6+s)*font_height, ">>> ",4);
X	}
X			
X
X
X
X	/* make sure the current score is on the board */
X	if ( !made_it ) {
X		if ( balls_left > 99 ) {
X			center_text( NB_SCORES + 3, sprintf( buf, "%7d (%3d)   %8s ",
X					       score, balls_left, login ) );
X		} else if ( balls_left > 9 ) {
X			center_text( NB_SCORES + 3, sprintf( buf, "%7d  (%2d)   %8s ",
X					       score, balls_left, login ) );
X		} else if ( balls_left ) {
X			center_text( NB_SCORES + 3, sprintf( buf, "%7d   (%1d)   %8s ",
X					       score, balls_left, login ) );
X		} else {	/* no balls left */
X			center_text( NB_SCORES + 3, sprintf( buf, "%7d    <>   %8s ",
X						     score, login ) );
X		}
X	}
X	/* show the current pallet shrinkage */
X	center_text( NB_SCORES + 5, sprintf( buf, "pallet >>> %2d %% <<<",
X			    ( pallet_modif * 100 ) / PALLET_DENOMINATOR ) );
X
X
X	XFlush(display);
X
X	/* provide some time to read */
X	sleep( 9 );
X	XCloseDisplay(display);
X	exit( 0 );		/* BYE !! */
X}
END_OF_FILE
if test 5698 -ne `wc -c <'score.c'`; then
    echo shar: \"'score.c'\" unpacked with wrong size!
fi
# end of 'score.c'
fi
if test -f 'stage.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stage.c'\"
else
echo shar: Extracting \"'stage.c'\" \(4272 characters\)
sed "s/^X//" >'stage.c' <<'END_OF_FILE'
X/*
X * File:       stage.c
X * Author:     Eric Van Gestel
X * Updated for X11 by Mark S. Wedel
X *
X * For:                xblockbuster
X */
X
X#include "xblockbuster.h"
X
Xvoid
Xget_stage(  )
X{
X	FILE           *fd;
X	char            buf[MAX_COL + 3], stg[STAGEFILE_LENGTH];
X	register int    row, col, tmp;
X	register char   code;
X
X	nbricks = 0;
X	score_incr = 1;
X	loop_nhits = 0;
X	last_busted_brick = NULL;
X
X	/* open next stage file */
X	if ( !( fd = fopen( sprintf( stg, STAGEFILE, playground, stage_nb ),
X			    "r" ) ) ) {
X		perror( "Can't open stage" );
X		exit( 1 );
X	}
X	/* clear msg, but leave the top line so the bonus remains on screen */
X	XFillRectangle( display,win, gc_erase,
X		font_height+5, STAGE_WIDTH_IN_PIXELS - 1, 
X		MSG_HEIGHT, STAGE_WIDTH_IN_PIXELS -1);
X
X	/* read stage name */
X	fscanf( fd, "%s\n", stage_name );
X	for ( tmp = 0; stage_name[tmp]; tmp++ )
X		if ( stage_name[tmp] == '_' )
X			stage_name[tmp] = ' ';
X	for (  /* tmp = tmp */ ; tmp < NAME_LENGTH - 1; tmp++ )
X		stage_name[tmp] = ' ';
X	stage_name[NAME_LENGTH - 1] = '\0';
X	XDrawImageString(display, win, gc, OFFSET_SPEED, font_height*2,
X		stage_name, strlen(stage_name));
X
X	/* read pallet dimensions */
X	fscanf( fd, "%d%d\n", &pallet_lengthI, &pallet_heightI );
X	if ( pallet_lengthI < SHORT_PALLET_LENGTH ||
X	     pallet_lengthI > LONG_PALLET_LENGTH ||
X	     pallet_heightI < pallet_lengthI ||
X	     pallet_heightI > MAX_PALLET_HEIGHT ) {
X		perror( "Inconsistent pallet dimensions" );
X		exit( 1 );
X	}
X	/* modify for difficulty level */
X	pallet_lengthI -= ( pallet_modif * pallet_lengthI ) / PALLET_DENOMINATOR;
X	if ( pallet_lengthI < MIN_PALLET_LENGTH )
X		pallet_lengthI = MIN_PALLET_LENGTH;
X	if ( pallet_lengthI > MAX_PALLET_LENGTH )
X		pallet_lengthI = MAX_PALLET_LENGTH;
X	if ( pallet_heightI < pallet_lengthI )
X		pallet_heightI = pallet_lengthI;
X	pallet_length = ( double ) pallet_lengthI;
X	pallet_height = ( double ) pallet_heightI;
X
X	/* read stage map */
X	for ( row = 0; row <= MAX_ROW; row++ ) {
X		if ( !fgets( buf, MAX_COL + 3, fd ) ) {
X			perror( "Can't read stage" );
X			exit( 1 );
X		}
X		for ( col = 0; col <= MAX_COL; col++ ) {
X			code = buf[col];
X			if ( IS_HIT_BRICK( code ) )
X				nbricks++;
X			switch ( code ) {
X			case '/':
X				launch_quadrant = NE;
X				launch_row = row;
X				launch_col = col;
X				launch_x = ( double ) ( COL_X( col + 1 ) );
X				launch_y = ( double ) ( ROW_Y( row ) );
X				break;
X			case '\\':
X				launch_quadrant = NW;
X				launch_row = row;
X				launch_col = col;
X				launch_x = ( double ) ( COL_X( col ) );
X				launch_y = ( double ) ( ROW_Y( row ) );
X				break;
X			case '^':
X				emit_row = row;
X				emit_col = col;
X			}
X			stage[row][col].code = code;
X			stage[row][col].nhits = 0;
X		}
X	}
X	fclose( fd );
X	XClearWindow(display, win);
X
X	/* draw new stage */
X	for ( row = 0; row <= MAX_ROW; row++ ) {
X		draw_brick0( row, 0 );
X		for ( col = 1; col < MAX_COL; col++ )
X			draw_brick( row, col );
X		draw_brick0( row, MAX_COL );
X	}
X
X	/* reset pallet location */
X	pallet_y = ( double ) ( pallet_yI = PALLET_MAX_Y + 4 );
X	pallet_row = MAX_ROW - 1;
X	draw_pallet(  );
X
X	/* ready ? */
X	XDrawImageString(display, win, gc, OFFSET_BALLS, font_height*2,
X	      "Press right mouse button when ready; Escape to save.      ",60);
X
X}
X
Xvoid
Xnew_stage(  )
X{
X	FILE           *fd;
X	register int    stage_index, stage_nb_tmp;
X	char		buf[STAGEFILE_LENGTH], buf2[2*STAGEFILE_LENGTH];
X
X	/* go faster or make the pallet smaller */
X	if ( launch_speed < MAX_SPEED )
X		launch_speed += SPEED_INCR;
X	else
X		pallet_modif += PALLET_INCR;
X
X	/* determine stage number */
X	if ( !nb_stages ) {
X		/* read number of available stages */
X		if ( !( fd = fopen( sprintf( buf, NB_STAGESFILE, playground ),
X				    "r" ) ) ) {
X			perror( sprintf( buf2, "Can't open number of stages file <%s>",
X					 buf ) );
X			exit( 1 );
X		}
X		fscanf( fd, "%d", &nb_stages );
X		fclose( fd );
X		/* clear stages memory */
X		for ( stage_nb_tmp = 0; stage_nb_tmp < MAX_NB_STAGES; )
X			stages[stage_nb_tmp++] = FALSE;
X	}
X	/* search for stage index'th available stage number */
X	stage_index = ( int ) ( random(  ) ) % nb_stages--;
X	if ( stage_index < 0 )
X		stage_index = -stage_index;
X	for ( stage_nb = 0; stages[stage_nb]; )
X		stage_nb++;
X	while ( stage_index-- ) {
X		while ( stages[++stage_nb] );
X	}
X	stages[stage_nb] = TRUE;
X
X	get_stage(  );
X}
END_OF_FILE
if test 4272 -ne `wc -c <'stage.c'`; then
    echo shar: \"'stage.c'\" unpacked with wrong size!
fi
# end of 'stage.c'
fi
if test -f 'stagemm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stagemm.c'\"
else
echo shar: Extracting \"'stagemm.c'\" \(3120 characters\)
sed "s/^X//" >'stagemm.c' <<'END_OF_FILE'
X/*
X * File:       smm.c
X * Author:     Eric Van Gestel
X *
X * Aux. For:   blockbuster
X *
X * Implementation:
X *     Calculates a minimum and approximate maximum score for the stage.
X *     If there are both 'D's or 'T's and 'U's, this tends to grow rapidly.
X */
X
X#include "xblockbuster.h"
X
Xvoid
Xmain( argc, argv )
X	int             argc;
X	char           *argv[];
X
X{
X	FILE           *fd;
X	char            buf[MAX_COL + 3];
X	register int    row, col, tmp;
X	int    codes[256];	/* indexed by char */
X
X	for ( tmp = 0; tmp < 256; )
X		codes[tmp++] = 0;
X
X	/* open stage file */
X	if ( !( fd = fopen( argv[1], "r" ) ) ) {
X		perror( "Can't open stage" );
X		exit( 1 );
X	}
X	/* read stage name */
X	fscanf( fd, "%s\n", stage_name );
X	printf( "%>>> %s:", stage_name );
X
X	/* read pallet dimensions */
X	fscanf( fd, "%d%d\n", &pallet_lengthI, &pallet_heightI );
X	if ( pallet_lengthI < MIN_PALLET_LENGTH ||
X	     pallet_lengthI > MAX_PALLET_LENGTH ||
X	     pallet_heightI < pallet_lengthI ||
X	     pallet_heightI > MAX_PALLET_HEIGHT ) {
X		perror( "Inconsistent pallet dimensions" );
X		exit( 1 );
X	}
X	/* read stage map */
X	for ( row = 0; row <= MAX_ROW; row++ ) {
X		if ( !fgets( buf, MAX_COL + 3, fd ) ) {
X			perror( "Can't read stage" );
X			exit( 1 );
X		}
X		for ( col = 0; col <= MAX_COL; col++ )
X			codes[buf[col]]++;
X	}
X	fclose( fd );
X
X	/* minimax approximation */
X	score = codes['1']
X		+ codes['2'] * 3
X		+ codes['3'] * 6
X		+ codes['4'] * 10
X		+ codes['5'] * 15
X		+ codes['6'] * 21
X		+ codes['7'] * 28
X		+ codes['8'] * 36
X		+ codes['9'] * 45;
X	printf( " from %d", score );
X	score += codes['I'] * 2
X		+ codes['a'] * 10
X		+ codes['b'] * 20
X		+ codes['c'] * 30
X		+ codes['d'] * 40
X		+ codes['e'] * 50
X		+ codes['j'] * 100;
X	for ( tmp = codes['D']; tmp; tmp-- )
X		score *= 2;
X	for ( tmp = codes['T']; tmp; tmp-- )
X		score *= 3;
X	if ( codes['U'] ) {
X		if ( codes['T'] )
X			for ( tmp = codes['U']; tmp; tmp-- )
X				score *= 3;
X		else if ( codes['D'] )
X			for ( tmp = codes['U']; tmp; tmp-- )
X				score *= 2;
X		else if ( codes['j'] )
X			score += codes['U'] * 100;
X		else if ( codes['e'] )
X			score += codes['U'] * 50;
X		else if ( codes['9'] )
X			score += codes['U'] * 45;
X		else if ( codes['d'] )
X			score += codes['U'] * 40;
X		else if ( codes['8'] )
X			score += codes['U'] * 36;
X		else if ( codes['c'] )
X			score += codes['U'] * 30;
X		else if ( codes['7'] )
X			score += codes['U'] * 28;
X		else if ( codes['6'] )
X			score += codes['U'] * 21;
X		else if ( codes['b'] )
X			score += codes['U'] * 20;
X		else if ( codes['5'] )
X			score += codes['U'] * 15;
X		else if ( codes['4'] )
X			score += codes['U'] * 11;
X		else if ( codes['a'] )
X			score += codes['U'] * 10;
X		else if ( codes['3'] )
X			score += codes['U'] * 6;
X		else if ( codes['2'] )
X			score += codes['U'] * 3;
X		else if ( codes['I'] )
X			score += codes['U'];
X		else if ( codes['1'] )
X			score += codes['U'];
X	}
X	printf( " to %d", score );
X	if ( codes['0'] )
X		printf( " and more" );
X	printf( "\n" );
X
X	/* verify stage map */
X	if ( codes['/'] + codes['\\'] != 1 )
X		printf( "*** no or several launchpads\n" );
X	if ( codes['A'] && codes['^'] != 1 )
X		printf( "*** no or several emitters\n" );
X}
END_OF_FILE
if test 3120 -ne `wc -c <'stagemm.c'`; then
    echo shar: \"'stagemm.c'\" unpacked with wrong size!
fi
# end of 'stagemm.c'
fi
if test -f 'stagemm.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'stagemm.man'\"
else
echo shar: Extracting \"'stagemm.man'\" \(986 characters\)
sed "s/^X//" >'stagemm.man' <<'END_OF_FILE'
X.TH STAGEMM 6 "16 November 1992"
X.br
X.SH NAME
Xstagemm \- utility program for xblockbuster game
X.SH SYNOPSIS
X.B stagemm
X.I stage
X.SH DESCRIPTION
Xstagemm determines the mininum and maximum score that can be produced
Xby playing a stage.  It also does some checking to make sure the
Xstage data includes everything necessary, and that all values are
X"sane".   This can be useful for developing new stages
Xfor xblockbuster.
X.SH OUTPUT
Xstagemm will produce output like the following:
X
X>>> Zebra: from 574 to 634
X
X The low score reflects only hitting the bricks necessary to complete
Xthe stage.  The high score includes doubler, triplers, and the
X10, 20, 30, 40, 50 and 100 point bricks.  It also factors in the 
Xeffects of undo's on bricks.
X
X In addition, results from some stages will be like:
X
X>>> Snail: from 168 to 208 and more
X
X The 'and more' means that there are invisible bricks on the stage
X.SH AUTHOR
XStagemm was written by Eric Van Gestel.  This man page was written
Xby Mark Wedel.
END_OF_FILE
if test 986 -ne `wc -c <'stagemm.man'`; then
    echo shar: \"'stagemm.man'\" unpacked with wrong size!
fi
# end of 'stagemm.man'
fi
if test -f 'xblockbuster.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xblockbuster.h'\"
else
echo shar: Extracting \"'xblockbuster.h'\" \(5321 characters\)
sed "s/^X//" >'xblockbuster.h' <<'END_OF_FILE'
X/*
X * File:       xblockbuster.h
X * Author:     Eric Van Gestel
X * X11 Support by: Mark Wedel
X * For:                xblockbuster
X *
X */
X
X/* file paths are defined at the end of this file */
X
X#include <stdio.h>
X#include <pwd.h>
X/*#include <sys/file.h>
X#include <ctype.h>*/
X#include <math.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#include <X11/Xatom.h>
X
X
X/*
X * #define M_PI                3.14159265358979323846
X * #define M_PI_2      1.57079632679489661923
X * #define M_PI_4      0.78539816339744830962
X */
X#define M_PI_3_4       2.35619449019234492885
X#define M_SQRT2_2      0.70710678118654752440
X#define NEAR_HORIZONTAL        0.7	/* < M_PI_4 */
X
XDisplay		*display;
XWindow		win;
XGC		gc, gc_erase, gc_xor,gc_color;
XXFontStruct	*font_info;
Xint		screen_num, font_width, font_height;
X
X/*** windowing objects ***/
X
X#define BORDER         50
X#define MSG_HEIGHT     font_height*2 + 4
X
X#define MAX_ROW                42
X#define MAX_COL                11
X
X/* upper left corner of brick in pixels */
X#define COL_X( col )   (col) ? (col) * 64 - 48 + BORDER : BORDER
X#define ROW_Y( row )   (row) * 16 + BORDER
X
X/* brick coordinates */
X#define X_COL( x )     ( (int)(x) - BORDER + 48 ) / 64
X#define Y_ROW( y )     ( (int)(y) - BORDER ) / 16
X
X#define STAGE_HEIGHT_IN_PIXELS ( ( MAX_ROW + 1 ) * 16 + 2 * BORDER )
X#define STAGE_WIDTH_IN_PIXELS  ( ( MAX_COL - 1 ) * 64 + 2 * ( BORDER + 16 ) )
X
X
X/*** messages ***/
X
X
X#define OFFSET_BALLS   20
X#define OFFSET_SCORE   250
X#define OFFSET_SPEED   550
X
X
X/*** active objects ***/
X
X#define NO_BALL        0
X#define NE     1
X#define NW     2
X#define SW     3
X#define SE     4
X
X#ifndef FALSE
X#define FALSE  0
X#endif
X#ifndef TRUE
X#define TRUE   1
X#endif
X
X#define HORIZONTAL     1
X#define VERTICAL       2
X
X#define INIT_BALLS     3
X#define LOOP_MAX       100
X
X#define INIT_SPEED     3.0
X#define MAX_SPEED      8.0
X#define SPEED_LIMIT    12.0
X#define SPEED_INCR     0.2
X#define SPEED_INCR_2   0.1	/* SPEED_INCR / 2 */
X#define SPEED_RESOLUTION       60	/* SPEED_LIMIT / SPEED_INCR */
X#define SPEED_RESOLUTION_FACTOR        5.0	/* SPEED_RESOLUTION /
X						 * SPEED_LIMI
X						 */
X
X#define NUM_BRICK_TYPES	37
X
X/* foreground/background colors for each of the bricks - MSW */
Xstruct	COLOR {
X	unsigned long	fg, bg;
X} brick_color[NUM_BRICK_TYPES+1];
X
X/* the stage is a two
X * dimensional array of
X * bricks */
X
Xstruct Brick {
X	char            code;	/* Q.V. map_codes */
X	short           nhits;
X}               stage[MAX_ROW + 1][MAX_COL + 1];
X
X#define IS_HIT_BRICK( code )   code > '0' && code <= '9'
X
Xstruct Ball {
X	int             quadrant;	/* enumeration { NO_BALL, NE, NW, SW,
X					 * SE } */
X	double          angle;	/* range -M_PI_4..NEAR_HORIZONTAL */
X	/*
X	 * NW -P4|-P4 NE +NH | +NH >>>>>>+<<<<<<  (gap to avoid infinite
X	 * horizontal bounce loops) +NH | +NH SW -P4|-P4 SE
X	 */
X	int             row, col;	/* coordinates on the stage */
X	double          x, y;	/* coordinates in pixels */
X	double          speed, x_speed, y_speed;	/* motion per update in
X							 * pixels */
X	/*
X	 * INVARIANT: x_speed == speed * cos( true_angle ) y_speed == speed *
X	 * sin( true_angle )
X	 */
X}               ball1, ball2, ball3;
X
Xint             launch_quadrant;/* enumeration { NE, NW } */
Xint             launch_row, launch_col;
Xdouble          launch_x, launch_y;
Xint             emit_row, emit_col;
X
X#define MIN_PALLET_LENGTH      12
X#define SHORT_PALLET_LENGTH    16
X#define LONG_PALLET_LENGTH     99
X#define MAX_PALLET_LENGTH      99
X#define MAX_PALLET_HEIGHT      999
X#define PALLET_INCR    100
X#define PALLET_DENOMINATOR     20000
X#define PALLET_MIN_Y   ROW_Y( MAX_ROW - 9 )
X#define PALLET_MAX_Y   ROW_Y( MAX_ROW - 1 )
X
Xint             pallet_lengthI;	/* range MIN_PALLET_LENGTH..MAX_PALLET_LENGTH */
Xint             pallet_heightI;	/* range pallet_lengthI..MAX_PALLET_HEIGHT */
Xint             pallet_xI;	/* range 0..STAGE_WIDTH_IN_PIXELS */
Xint             pallet_yI;	/* range PALLET_MAX_Y+4..PALLET_MIN_Y-12 */
Xint             pallet_row;	/* range MAX_ROW-1..MAX_ROW-9 */
Xdouble          pallet_length, pallet_height, pallet_x, pallet_y;
X
X/*
X * INVARIANT:
X *     pallet_* == (double) pallet_*I;
X *     pallet_width == 2 * pallet_length
X *     pallet_height >= pallet_length >= ABS( excentricity )
X *       =>  atan2( excentricity, pallet_height ) range -M_PI_4..M_PI_4
X */
Xint             mouse_yI;	/* range 0..STAGE_HEIGHT_IN_PIXELS *//* <HC> */
X
Xint             nb_stages, stage_nb, balls_left, score, score_incr, nbricks, loop_nhits, pallet_modif;
Xdouble          launch_speed;
X
X#define NAME_LENGTH    20
Xchar            stage_name[NAME_LENGTH];
X
X#define MAX_NB_STAGES  100
Xint             stages[MAX_NB_STAGES];
X
Xstruct Brick   *last_busted_brick;	/* NULL == none so far */
Xchar            last_busted_code;
Xint             last_busted_row, last_busted_col;
X
X
X
X/*** score and stages files ***/
X
X#define PATH_LENGTH	64
X
Xchar	*login;
Xchar	playground[PATH_LENGTH];
X
X#ifndef STAGEDIR
X#define STAGEDIR	"/usr/games/lib/blockbuster"
X#endif
X
X#define SCOREFILE      "%s/scores"
X#define NB_SCORES      12
X#define USER_SCORES    3
X
X#define NB_STAGESFILE  "%s/nb_stages"
X#define STAGEFILE      "%s/stage%d"
X#define STAGEFILE_LENGTH       PATH_LENGTH
X
X#define SAVEFILE       "%s/save/%s"
X#define SAVEFILE_LENGTH        PATH_LENGTH
X
X/* Timer information */
X
X#define ITIMER_DELAY	5000
X
END_OF_FILE
if test 5321 -ne `wc -c <'xblockbuster.h'`; then
    echo shar: \"'xblockbuster.h'\" unpacked with wrong size!
fi
# end of 'xblockbuster.h'
fi
echo shar: End of archive 3 \(of 5\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0


exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM            | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly!      |
 "It's intuitively obvious to the most |    sources-x@imd.sterling.com
  casual observer..."                  |
