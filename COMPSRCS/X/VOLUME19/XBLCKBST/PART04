Newsgroups: comp.sources.x
From: master@cats.UCSC.EDU (Mark Wedel)
Subject: v19i047:  xblockbuster - a variation of the break-out type games, Part04/05
Message-ID: <1993Mar17.160324.643@sparky.imd.sterling.com>
X-Md4-Signature: cae37fbf85e9bfb669f0ed951a4abc83
Date: Wed, 17 Mar 1993 16:03:24 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: master@cats.UCSC.EDU (Mark Wedel)
Posting-number: Volume 19, Issue 47
Archive-name: xblockbuster/part04
Environment: X11R5


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 5)."
# Contents:  Makefile.noIm bricks.c xblockbuster.c xblockbuster.man
# Wrapped by master@sleipner on Sat Mar 13 02:21:02 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile.noIm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.noIm'\"
else
echo shar: Extracting \"'Makefile.noIm'\" \(7028 characters\)
sed "s/^X//" >'Makefile.noIm' <<'END_OF_FILE'
X#
X# Makefile for XBlockbuster
X#
XHDRS= xblockbuster.h patchlevel.h
XSRCS = balls_pallet.c bricks.c deflection.c save.c score.c stage.c \
X	xblockbuster.c 
XOBJS = balls_pallet.o bricks.o deflection.o save.o score.o stage.o \
X	xblockbuster.o 
X
X# Where you want the executable installed
XBINDIR = /usr/games
X# where you want the stages and scores stored
XLIBDIR = /usr/games/lib/xblockbuster
X# where to put the man page, and its extension
XMANDIR = /usr/local/man/man6/
XMANEXT = 6
X
X# Font to use for writing text.
XFONT = 10x20
X
XCC = cc
X# IF you want to change the FONT or LIBDIR, do it above
XCFLAGS= -O -DFONT=\"${FONT}\"  -DSTAGEDIR=\"${LIBDIR}\"
XLDFLAGS=
XLIBS= -lm -lX11
X
Xall:	xblockbuster stagemm
X
Xxblockbuster: ${HDRS} ${OBJS} ${SRCS}
X	$(CC) ${LDFLAGS} ${OBJS} ${LIBS} -o xblockbuster
X
Xstagemm: stagemm.c
X	$(CC) stagemm.c -o stagemm
X
Xinstall:
X	mkdir ${LIBDIR}
X	cp -r STAGES* ${LIBDIR}
X	chmod 666 ${LIBDIR}/STAGES*/scores
X	chmod 777 ${LIBDIR}/STAGES*/save
X	cp XBlockbuster.ad ${LIBDIR}
X	cp xblockbuster ${BINDIR}/xblockbuster
X	cp xblockbuster.man ${MANDIR}/xblockbuster.${MANEXT}
X	cp stagemm ${BINDIR}/stagemm
X	cp stagemm.man ${MANDIR}/stagemm.${MANEXT}
X
Xrealclean:
X	rm -f $(OBJS) xblockbuster stagemm
X
Xdepend:
X	makedepend -- $(SRCS) -- $(HDRS)
X
Xclean:
X	rm -f $(OBJS)
X
X# DO NOT DELETE THIS LINE -- make depend depends on it.
X
Xballs_pallet.o: xblockbuster.h /usr/include/X11/Xlib.h
Xballs_pallet.o: /usr/include/sys/types.h /usr/include/sys/stdtypes.h
Xballs_pallet.o: /usr/include/sys/sysmacros.h /usr/include/X11/X.h
Xballs_pallet.o: /usr/include/X11/Xfuncproto.h /usr/include/X11/Xosdefs.h
Xballs_pallet.o: /usr/include/stddef.h /usr/include/X11/Xutil.h
Xballs_pallet.o: /usr/include/X11/Xos.h /usr/include/string.h
Xballs_pallet.o: /usr/include/fcntl.h /usr/include/sys/fcntlcom.h
Xballs_pallet.o: /usr/include/sys/stat.h /usr/include/unistd.h
Xballs_pallet.o: /usr/include/sys/time.h /usr/include/sys/time.h
Xballs_pallet.o: /usr/include/X11/Xatom.h icons/ball.pr
Xbricks.o: xblockbuster.h /usr/include/X11/Xlib.h /usr/include/sys/types.h
Xbricks.o: /usr/include/sys/stdtypes.h /usr/include/sys/sysmacros.h
Xbricks.o: /usr/include/X11/X.h /usr/include/X11/Xfuncproto.h
Xbricks.o: /usr/include/X11/Xosdefs.h /usr/include/stddef.h
Xbricks.o: /usr/include/X11/Xutil.h /usr/include/X11/Xos.h
Xbricks.o: /usr/include/string.h /usr/include/fcntl.h
Xbricks.o: /usr/include/sys/fcntlcom.h /usr/include/sys/stat.h
Xbricks.o: /usr/include/unistd.h /usr/include/sys/time.h
Xbricks.o: /usr/include/sys/time.h /usr/include/X11/Xatom.h icons/clear.pr
Xbricks.o: icons/solid.pr icons/launchNE.pr icons/launchNW.pr icons/clear0.pr
Xbricks.o: icons/solid0.pr icons/launchNE0.pr icons/launchNW0.pr
Xbricks.o: icons/brick_0.pr icons/brick_1.pr icons/brick_2.pr icons/brick_3.pr
Xbricks.o: icons/brick_4.pr icons/brick_5.pr icons/brick_6.pr icons/brick_7.pr
Xbricks.o: icons/brick_8.pr icons/brick_9.pr icons/brick_a.pr icons/brick_b.pr
Xbricks.o: icons/brick_c.pr icons/brick_d.pr icons/brick_e.pr icons/brick_j.pr
Xbricks.o: icons/brick_A.pr icons/brick_C.pr icons/brick_D.pr icons/brick_E.pr
Xbricks.o: icons/brick_G.pr icons/brick_H.pr icons/brick_L.pr icons/brick_M.pr
Xbricks.o: icons/brick_P.pr icons/brick_R.pr icons/brick_S.pr icons/brick_T.pr
Xbricks.o: icons/brick_U.pr icons/brick_W.pr icons/brick_X.pr
Xbricks.o: icons/brick_a_alt.pr icons/brick_b_alt.pr icons/brick_c_alt.pr
Xbricks.o: icons/brick_d_alt.pr icons/brick_e_alt.pr icons/brick_j_alt.pr
Xbricks.o: icons/brick_S_alt.pr icons/brick_0_alt.pr icons/cursor.pr
Xdeflection.o: xblockbuster.h /usr/include/X11/Xlib.h /usr/include/sys/types.h
Xdeflection.o: /usr/include/sys/stdtypes.h /usr/include/sys/sysmacros.h
Xdeflection.o: /usr/include/X11/X.h /usr/include/X11/Xfuncproto.h
Xdeflection.o: /usr/include/X11/Xosdefs.h /usr/include/stddef.h
Xdeflection.o: /usr/include/X11/Xutil.h /usr/include/X11/Xos.h
Xdeflection.o: /usr/include/string.h /usr/include/fcntl.h
Xdeflection.o: /usr/include/sys/fcntlcom.h /usr/include/sys/stat.h
Xdeflection.o: /usr/include/unistd.h /usr/include/sys/time.h
Xdeflection.o: /usr/include/sys/time.h /usr/include/X11/Xatom.h
Xsave.o: xblockbuster.h /usr/include/X11/Xlib.h /usr/include/sys/types.h
Xsave.o: /usr/include/sys/stdtypes.h /usr/include/sys/sysmacros.h
Xsave.o: /usr/include/X11/X.h /usr/include/X11/Xfuncproto.h
Xsave.o: /usr/include/X11/Xosdefs.h /usr/include/stddef.h
Xsave.o: /usr/include/X11/Xutil.h /usr/include/X11/Xos.h /usr/include/string.h
Xsave.o: /usr/include/fcntl.h /usr/include/sys/fcntlcom.h
Xsave.o: /usr/include/sys/stat.h /usr/include/unistd.h /usr/include/sys/time.h
Xsave.o: /usr/include/sys/time.h /usr/include/X11/Xatom.h
Xscore.o: xblockbuster.h /usr/include/X11/Xlib.h /usr/include/sys/types.h
Xscore.o: /usr/include/sys/stdtypes.h /usr/include/sys/sysmacros.h
Xscore.o: /usr/include/X11/X.h /usr/include/X11/Xfuncproto.h
Xscore.o: /usr/include/X11/Xosdefs.h /usr/include/stddef.h
Xscore.o: /usr/include/X11/Xutil.h /usr/include/X11/Xos.h
Xscore.o: /usr/include/string.h /usr/include/fcntl.h
Xscore.o: /usr/include/sys/fcntlcom.h /usr/include/sys/stat.h
Xscore.o: /usr/include/unistd.h /usr/include/sys/time.h
Xscore.o: /usr/include/sys/time.h /usr/include/X11/Xatom.h
Xstage.o: xblockbuster.h /usr/include/X11/Xlib.h /usr/include/sys/types.h
Xstage.o: /usr/include/sys/stdtypes.h /usr/include/sys/sysmacros.h
Xstage.o: /usr/include/X11/X.h /usr/include/X11/Xfuncproto.h
Xstage.o: /usr/include/X11/Xosdefs.h /usr/include/stddef.h
Xstage.o: /usr/include/X11/Xutil.h /usr/include/X11/Xos.h
Xstage.o: /usr/include/string.h /usr/include/fcntl.h
Xstage.o: /usr/include/sys/fcntlcom.h /usr/include/sys/stat.h
Xstage.o: /usr/include/unistd.h /usr/include/sys/time.h
Xstage.o: /usr/include/sys/time.h /usr/include/X11/Xatom.h
Xxblockbuster.o: xblockbuster.h /usr/include/X11/Xlib.h
Xxblockbuster.o: /usr/include/sys/types.h /usr/include/sys/stdtypes.h
Xxblockbuster.o: /usr/include/sys/sysmacros.h /usr/include/X11/X.h
Xxblockbuster.o: /usr/include/X11/Xfuncproto.h /usr/include/X11/Xosdefs.h
Xxblockbuster.o: /usr/include/stddef.h /usr/include/X11/Xutil.h
Xxblockbuster.o: /usr/include/X11/Xos.h /usr/include/string.h
Xxblockbuster.o: /usr/include/fcntl.h /usr/include/sys/fcntlcom.h
Xxblockbuster.o: /usr/include/sys/stat.h /usr/include/unistd.h
Xxblockbuster.o: /usr/include/sys/time.h /usr/include/sys/time.h
Xxblockbuster.o: /usr/include/X11/Xatom.h /usr/include/sys/dir.h
Xxblockbuster.o: /usr/include/signal.h /usr/include/sys/signal.h
Xxblockbuster.o: /usr/include/vm/faultcode.h icons/blockbuster.icon
Xxblockbuster.o: /usr/include/X11/Xlib.h /usr/include/sys/types.h
Xxblockbuster.o: /usr/include/sys/stdtypes.h /usr/include/sys/sysmacros.h
Xxblockbuster.o: /usr/include/X11/X.h /usr/include/X11/Xfuncproto.h
Xxblockbuster.o: /usr/include/X11/Xosdefs.h /usr/include/stddef.h
Xxblockbuster.o: /usr/include/X11/Xutil.h /usr/include/X11/Xos.h
Xxblockbuster.o: /usr/include/string.h /usr/include/fcntl.h
Xxblockbuster.o: /usr/include/sys/fcntlcom.h /usr/include/sys/stat.h
Xxblockbuster.o: /usr/include/unistd.h /usr/include/sys/time.h
Xxblockbuster.o: /usr/include/sys/time.h /usr/include/X11/Xatom.h
END_OF_FILE
if test 7028 -ne `wc -c <'Makefile.noIm'`; then
    echo shar: \"'Makefile.noIm'\" unpacked with wrong size!
fi
# end of 'Makefile.noIm'
fi
if test -f 'bricks.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bricks.c'\"
else
echo shar: Extracting \"'bricks.c'\" \(12416 characters\)
sed "s/^X//" >'bricks.c' <<'END_OF_FILE'
X/*
X * File:       bricks.c
X * Author:     Eric Van Gestel
X * Updated to X11, alternate brick support and color added by Mark S. Wedel
X *
X * For:                xblockbuster
X */
X#include "xblockbuster.h"
Xstatic int	has_color=FALSE;
X
X
XPixmap 	launchNW_pr,launchNW0_pr,launchNE_pr,launchNE0_pr,
X	solid_pr,solid0_pr,clear_pr,clear0_pr,
X	brick_0_pr,brick_1_pr,brick_2_pr,brick_3_pr,brick_4_pr,
X	brick_5_pr,brick_6_pr,brick_7_pr,brick_8_pr,brick_9_pr,
X	brick_a_pr,brick_b_pr,brick_c_pr,brick_d_pr,brick_e_pr,
X	brick_j_pr,brick_A_pr,brick_C_pr,brick_D_pr,brick_E_pr,
X	brick_G_pr,brick_H_pr,brick_L_pr,brick_M_pr,brick_P_pr,
X	brick_R_pr,brick_S_pr,brick_T_pr,brick_U_pr,brick_W_pr,
X	brick_X_pr;
X
X
X/* Include all the brick images */
X#include "icons/clear.pr"
X#include "icons/solid.pr"
X#include "icons/launchNE.pr"
X#include "icons/launchNW.pr"
X#include "icons/clear0.pr"
X#include "icons/solid0.pr"
X#include "icons/launchNE0.pr"
X#include "icons/launchNW0.pr"
X#include "icons/brick_0.pr"
X#include "icons/brick_1.pr"
X#include "icons/brick_2.pr"
X#include "icons/brick_3.pr"
X#include "icons/brick_4.pr"
X#include "icons/brick_5.pr"
X#include "icons/brick_6.pr"
X#include "icons/brick_7.pr"
X#include "icons/brick_8.pr"
X#include "icons/brick_9.pr"
X#include "icons/brick_a.pr"
X#include "icons/brick_b.pr"
X#include "icons/brick_c.pr"
X#include "icons/brick_d.pr"
X#include "icons/brick_e.pr"
X#include "icons/brick_j.pr"
X#include "icons/brick_A.pr"
X#include "icons/brick_C.pr"
X#include "icons/brick_D.pr"
X#include "icons/brick_E.pr"
X#include "icons/brick_G.pr"
X#include "icons/brick_H.pr"
X#include "icons/brick_L.pr"
X#include "icons/brick_M.pr"
X#include "icons/brick_P.pr"
X#include "icons/brick_R.pr"
X#include "icons/brick_S.pr"
X#include "icons/brick_T.pr"
X#include "icons/brick_U.pr"
X#include "icons/brick_W.pr"
X#include "icons/brick_X.pr"
X
X/* Alternate bricks for some of the above - meant for color displays  - MSW */
X#include "icons/brick_a_alt.pr"
X#include "icons/brick_b_alt.pr"
X#include "icons/brick_c_alt.pr"
X#include "icons/brick_d_alt.pr"
X#include "icons/brick_e_alt.pr"
X#include "icons/brick_j_alt.pr"
X#include "icons/brick_S_alt.pr"
X#include "icons/brick_0_alt.pr"
X
X/* Our Cursor */
X#include "icons/cursor.pr"
X
X
Xvoid	do_brick_colors()
X{
X	Colormap	def_cmap;
X	XColor		exact_def;
X	Cursor          cursor;
X	Pixmap		cursor_pr;
X	int	count;
X	char		*bricks="0123456789 #/\\abcdejA^CDEGHILMPRSTUW%X";
X	char		option[30],*value;
X
X	for (count=0; count<=NUM_BRICK_TYPES; count++) {
X		brick_color[count].bg = WhitePixel(display, screen_num);
X		brick_color[count].fg = BlackPixel(display, screen_num);
X	}
X
X
X	def_cmap = DefaultColormap(display, screen_num);
X
X
X	/* This cursor code should really be in xblockbuster.c, but
X	since we are dealing with colormaps here, it is easier to place
X	the cursor code here.  I re-color the cursor so that it does
X	not show up on the screen. */
X
X	cursor_pr = XCreateBitmapFromData(display,win,cursor_bits, 
X		cursor_width, cursor_height);
X	exact_def.pixel = WhitePixel(display, screen_num);
X	XQueryColor(display, def_cmap, &exact_def);
X	cursor = XCreatePixmapCursor(display, cursor_pr, cursor_pr,
X		&exact_def, &exact_def, 0, 0);
X	XDefineCursor(display, win,cursor);
X
X	/* Figure we need at least a 5 bit display (32 colors) in order
X	to support color bricks.  Probably not many 5, 6, or 7 bit displays
X	out there, but you never know -MSW */
X
X	if (DefaultDepth(display,screen_num)<5) return;
X	else has_color=TRUE;
X
X
X	count=0;
X	while (bricks[count]!='\0') {
X		sprintf(option,"brick%c_fg",bricks[count]);
X		value = XGetDefault(display, "XBlockbuster", option);
X		if (value) {
X		    if (!XParseColor(display, def_cmap, value, &exact_def)) {
X 		       printf("Couldn't find color %s for option %s\n",value,option);
X		    }
X		    else 
X			if (!XAllocColor(display, def_cmap, &exact_def))
X				printf("couldn't allocate color %s in option %s\n",value,option);
X			else
X				brick_color[count].fg=exact_def.pixel;
X		}
X
X		sprintf(option,"brick%c_bg",bricks[count]);
X		value = XGetDefault(display, "XBlockbuster", option);
X		if (value) {
X		    if (!XParseColor(display, def_cmap, value, &exact_def)) {
X		    printf("Couldn't find color %s for option %s\n",value,option);
X		    }
X		    else 
X			if (!XAllocColor(display, def_cmap, &exact_def))
X				printf("couldn't allocate color %s in option %s\n",value,option);
X			else
X				brick_color[count].bg=exact_def.pixel;
X		}
X		count++;
X	}
X}
X
X
Xvoid bricks_init()
X{
X
X	char	*value;
X	int	use_alt_bricks=FALSE;
X
X	do_brick_colors();
X
X
X/* The width and height of these should really be keyed in from the defintions
Xin the files themselves.  However, that would take a considerable amount of
Xtyping effort that I don't feel like doing.  The width and height values are
Xhardcoded into other areas of the program anyways.  I must admit that it
Xwould be interesting to have different brick sizes, but in order to do that,
Xit would also entail changing how the stages are stored  - MSW */
X
X	launchNW_pr = XCreateBitmapFromData(display,win,launchNW_bits, 64,16);
X	launchNW0_pr = XCreateBitmapFromData(display,win,launchNW0_bits, 16,16);
X	launchNE_pr = XCreateBitmapFromData(display,win,launchNE_bits, 64,16);
X	launchNE0_pr = XCreateBitmapFromData(display,win,launchNE0_bits, 16,16);
X	solid_pr =   XCreateBitmapFromData(display,win,solid_bits, 64,16);
X	solid0_pr =  XCreateBitmapFromData(display,win,	solid0_bits, 16,16);
X	clear_pr =   XCreateBitmapFromData(display,win,	clear_bits, 64,16);
X	clear0_pr =  XCreateBitmapFromData(display,win,	clear0_bits, 16,16);
X	brick_1_pr = XCreateBitmapFromData(display,win,	brick_1_bits, 64,16);
X	brick_2_pr = XCreateBitmapFromData(display,win,	brick_2_bits, 64,16);
X	brick_3_pr = XCreateBitmapFromData(display,win,	brick_3_bits, 64,16);
X	brick_4_pr = XCreateBitmapFromData(display,win,	brick_4_bits, 64,16);
X	brick_5_pr = XCreateBitmapFromData(display,win,	brick_5_bits, 64,16);
X	brick_6_pr = XCreateBitmapFromData(display,win,	brick_6_bits, 64,16);
X	brick_7_pr = XCreateBitmapFromData(display,win,	brick_7_bits, 64,16);
X	brick_8_pr = XCreateBitmapFromData(display,win,	brick_8_bits, 64,16);
X	brick_9_pr = XCreateBitmapFromData(display,win,	brick_9_bits, 64,16);
X	brick_A_pr = XCreateBitmapFromData(display,win,	brick_A_bits, 64,16);
X	brick_C_pr = XCreateBitmapFromData(display,win,	brick_C_bits, 64,16);
X	brick_D_pr = XCreateBitmapFromData(display,win,	brick_D_bits, 64,16);
X	brick_E_pr = XCreateBitmapFromData(display,win,	brick_E_bits, 64,16);
X	brick_G_pr = XCreateBitmapFromData(display,win,	brick_G_bits, 64,16);
X	brick_H_pr = XCreateBitmapFromData(display,win,	brick_H_bits, 64,16);
X	brick_L_pr = XCreateBitmapFromData(display,win,	brick_L_bits, 64,16);
X	brick_M_pr = XCreateBitmapFromData(display,win,	brick_M_bits, 64,16);
X	brick_P_pr = XCreateBitmapFromData(display,win,	brick_P_bits, 64,16);
X	brick_R_pr = XCreateBitmapFromData(display,win,	brick_R_bits, 64,16);
X	brick_T_pr = XCreateBitmapFromData(display,win,	brick_T_bits, 64,16);
X	brick_U_pr = XCreateBitmapFromData(display,win,	brick_U_bits, 64,16);
X	brick_W_pr = XCreateBitmapFromData(display,win,	brick_W_bits, 64,16);
X	brick_X_pr = XCreateBitmapFromData(display,win,	brick_X_bits, 64,16);
X
X
X	/* Since everywhere else in the program uses the bitmap structures,
X	the use_alt_bricks only needs to be local to determine which
X	way to initialize the bitmap structures */
X
X	/* See if we should use the alternate bricks */
X	value = XGetDefault(display, "XBlockbuster", "alternate_bricks");
X	if (value) {
X		if (strcasecmp(value,"true")==0) {
X			use_alt_bricks=TRUE;
X		}
X	}
X	/* only use the alternate bricks on a color system */
X	if (use_alt_bricks && has_color) {
X		brick_0_pr = XCreateBitmapFromData(display,win,	brick_0_alt_bits, 64,16);
X		brick_a_pr = XCreateBitmapFromData(display,win,	brick_a_alt_bits, 64,16);
X		brick_b_pr = XCreateBitmapFromData(display,win,	brick_b_alt_bits, 64,16);
X		brick_c_pr = XCreateBitmapFromData(display,win,	brick_c_alt_bits, 64,16);
X		brick_d_pr = XCreateBitmapFromData(display,win,	brick_d_alt_bits, 64,16);
X		brick_e_pr = XCreateBitmapFromData(display,win,	brick_e_alt_bits, 64,16);
X		brick_j_pr = XCreateBitmapFromData(display,win,	brick_j_alt_bits, 64,16);
X		brick_S_pr = XCreateBitmapFromData(display,win,	brick_S_alt_bits, 64,16);
X	}
X	else {
X		brick_0_pr = XCreateBitmapFromData(display,win,	brick_0_bits, 64,16);
X		brick_a_pr = XCreateBitmapFromData(display,win,	brick_a_bits, 64,16);
X		brick_b_pr = XCreateBitmapFromData(display,win,	brick_b_bits, 64,16);
X		brick_c_pr = XCreateBitmapFromData(display,win,	brick_c_bits, 64,16);
X		brick_d_pr = XCreateBitmapFromData(display,win,	brick_d_bits, 64,16);
X		brick_e_pr = XCreateBitmapFromData(display,win,	brick_e_bits, 64,16);
X		brick_j_pr = XCreateBitmapFromData(display,win,	brick_j_bits, 64,16);
X		brick_S_pr = XCreateBitmapFromData(display,win,	brick_S_bits, 64,16);
X	}
X}
X
X
X
X
X/*** address functions ***/
X
XPixmap        brick_addr( row, col )
X	int             row, col;	/* col > 0 && col < MAX_COL */
X{
X	int             tmp = stage[row][col].nhits;
X
X	switch ( stage[row][col].code ) {
X	case ' ':return ( clear_pr );
X	case '#':return ( solid_pr );
X	case '/':return ( launchNE_pr );
X	case '\\':return ( launchNW_pr );
X
X	case '9':if ( !tmp-- )	return ( brick_9_pr );
X	case '8':if ( !tmp-- )	return ( brick_8_pr );
X	case '7':if ( !tmp-- )	return ( brick_7_pr );
X	case '6':if ( !tmp-- )	return ( brick_6_pr );
X	case '5':if ( !tmp-- )	return ( brick_5_pr );
X	case '4':if ( !tmp-- )	return ( brick_4_pr );
X	case '3':if ( !tmp-- )	return ( brick_3_pr );
X	case '2':if ( !tmp-- )	return ( brick_2_pr );
X	case '1':return ( brick_1_pr );
X	case '0':return ( brick_0_pr );
X	case 'a':return ( brick_a_pr );
X	case 'b':return ( brick_b_pr );
X	case 'c':return ( brick_c_pr );
X	case 'd':return ( brick_d_pr );
X	case 'e':return ( brick_e_pr );
X	case 'j':return ( brick_j_pr );
X	case 'A':return ( brick_A_pr );
X	case '^':return ( solid_pr );
X	case 'C':return ( brick_C_pr );
X	case 'D':return ( brick_D_pr );
X	case 'E':return ( brick_E_pr );
X	case 'G':return ( brick_G_pr );
X	case 'H':return ( brick_H_pr );
X	case 'I':return ( clear_pr );
X	case 'L':return ( brick_L_pr );
X	case 'M':return ( brick_M_pr );
X	case 'P':return ( brick_P_pr );
X	case 'R':return ( brick_R_pr );
X	case 'S':return ( brick_S_pr );
X	case 'T':return ( brick_T_pr );
X	case 'U':return ( brick_U_pr );
X	case 'W':return ( brick_W_pr );
X	case '%':return ( solid_pr );
X	case 'X':return ( brick_X_pr );
X
X	default:
X		perror( "Illegal map code" );
X		exit( 1 );
X	}
X}
X
XPixmap        brick_addr0( row, col )
X	int             row, col;	/* col == 0 || col == MAX_COL */
X{
X	switch ( stage[row][col].code ) {
X	case ' ':return ( clear0_pr );
X	case '#':return ( solid0_pr );
X	case '/':return ( launchNE0_pr );
X	case '\\':return ( launchNW0_pr );
X
X	default:
X		perror( "Illegal map code" );
X		exit( 1 );
X	};
X}
X
X
X
Xint        brick_value( row,col )
Xint             row, col;	/* col > 0 && col < MAX_COL */
X{
X
X	switch ( stage[row][col].code ) {
X
X	case '0':return(0);
X	case '1':return(1);
X	case '2':return(2-stage[row][col].nhits);
X	case '3':return(3-stage[row][col].nhits);
X	case '4':return(4-stage[row][col].nhits);
X	case '5':return(5-stage[row][col].nhits);
X	case '6':return(6-stage[row][col].nhits);
X	case '7':return(7-stage[row][col].nhits);
X	case '8':return(8-stage[row][col].nhits);
X	case '9':return(9-stage[row][col].nhits);
X	case ' ':return(10);
X	case '#':return(11);
X	case '/':return(12);
X	case '\\':return(13);
X	case 'a':return(14); 
X	case 'b':return(15);
X	case 'c':return(16);
X	case 'd':return(17);
X	case 'e':return(18);
X	case 'j':return(19);
X	case 'A':return(20);
X	case '^':return(21);
X	case 'C':return(22);
X	case 'D':return(23);
X	case 'E':return(24);
X	case 'G':return(25);
X	case 'H':return(26);
X	case 'I':return(27);
X	case 'L':return(28);
X	case 'M':return(29);
X	case 'P':return(30);
X	case 'R':return(31);
X	case 'S':return(32);
X	case 'T':return(33);
X	case 'U':return(34);
X	case 'W':return(35);
X	case '%':return(36);
X	case 'X':return(37);
X
X	default:
X		perror( "Illegal map code" );
X		exit( 1 );
X	}
X}
X
X
X
X
Xvoid draw_brick( row, col ) 
Xint row, col;
X{
X	if (has_color) {
X		XSetForeground(display, gc_color, brick_color[brick_value(row,col)].fg); 
X		XSetBackground(display, gc_color, brick_color[brick_value(row,col)].bg);
X	}
X	XCopyPlane(display, brick_addr(row,col), win, gc_color, 0, 0, 
X		64, 16, COL_X(col), ROW_Y(row), 1);
X
X}
X
Xvoid draw_brick0( row, col )
Xint row, col;
X{
X	XCopyPlane(display, brick_addr0(row,col), win, gc, 0, 0,
X		16, 16, COL_X(col), ROW_Y(row), 1);
X}
END_OF_FILE
if test 12416 -ne `wc -c <'bricks.c'`; then
    echo shar: \"'bricks.c'\" unpacked with wrong size!
fi
# end of 'bricks.c'
fi
if test -f 'xblockbuster.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xblockbuster.c'\"
else
echo shar: Extracting \"'xblockbuster.c'\" \(9125 characters\)
sed "s/^X//" >'xblockbuster.c' <<'END_OF_FILE'
X/*
X * Xblockbuster should run on any X11 system (bw or color) - MSW
X *
X *****************************************************************************
X * Appearance ONLY shamelessly stolen from the real video game,
X * wonderfully written by someone somewhere (I haven't got the foggiest).
X *
X * Move mouse to move pallet and keep the ball on the stage.
X *
X * Stages are built from various building blocks, some of which are based on
X * recollection from analogous blocks in the video game, others, in particular
X * the interesting ones, are new.
X *
X * The stages can be defined from the ascii map codes using any text editor.
X * They must be numbered consecutively from 0 with the total number
X * (i.e., one more than the highest number) available in the file nb_stages.
X *
X * -- Eric Van Gestel (ericvg@cs.kuleuven.ac.be)
X */
X
X#include "xblockbuster.h"
X#include <sys/dir.h>
X#include <sys/stat.h>
X#include <signal.h>
X
X#include "icons/blockbuster.icon"
X#include "patchlevel.h"
X
Xint timer_active=FALSE,	/* has the user started the ball? */
Xwindow_active=FALSE;	/* is the pointer in the window? */
X
X
X
Xvoid event_handler()
X{
X	XEvent	e;
X	int	row,col,sleeptime;
X	double	old_pallet_y;
X	char	keystr[2],str[10];
X	struct	timeval	tp,oldtp;
X	struct 	timezone tzp;
X
X    gettimeofday(&oldtp,&tzp);
X    draw_pallet();
X    while(1) {
X	/* timer function to keep things moving at a constant speed.
X	We read time before servicing events so that the amount of time
X	it takes to perform the event should not slow down/speed up
X	the game.  Note that other factors may control speed of the
X	game (such as available cpu).  Even on my unloaded sun 3/60, I
X	notice that many times that sleeptime was negative, even though
X	the program uses less than 20% of the cpu time- MSW*/
X
X	gettimeofday(&tp, &tzp);
X	sleeptime = ITIMER_DELAY - ((tp.tv_sec - oldtp.tv_sec)*1000000 +
X			(tp.tv_usec - oldtp.tv_usec));
X	if (sleeptime>0)
X		usleep(sleeptime);
X
X	gettimeofday(&oldtp,&tzp);
X
X	if (timer_active && window_active) move_balls();
X
X	/* Event handling (if any events need to be handled) - MSW */
X	if (XPending(display)) {
X	    XNextEvent(display, &e);
X	    switch (e.type) {
X		case ButtonPress:
X		    switch (e.xbutton.button) {
X			case Button3: /* right mouse button */
X				/* Clear message area */
X			    XFillRectangle(display, win, gc_erase,
X				0,0,STAGE_WIDTH_IN_PIXELS, MSG_HEIGHT);
X				/* redo messages */
X			    XDrawImageString(display, win, gc,
X				OFFSET_SPEED, font_height*2, stage_name,
X				strlen(stage_name));
X			    if (score_incr>1) {
X			 	sprintf(str,"Bonus x%d",score_incr);
X				XDrawImageString(display, win, gc,
X				    OFFSET_SCORE, font_height*2, str, 
X				    strlen(str));
X			    }
X			    print_balls();
X			    print_score();
X			    show_speeds();
X			    timer_active=TRUE;
X			    move_balls();
X			    break;
X
X			case Button2:
X				draw_pallet(); /* erase old */
X				pallet_y = (double) (pallet_yI = PALLET_MAX_Y+4);
X				pallet_row = MAX_ROW - 1;
X				draw_pallet(); /* draw new */
X				break;
X
X			case Button1:
X				draw_pallet(); /* erase old */
X				if (pallet_yI > PALLET_MIN_Y) {
X					old_pallet_y = pallet_y;
X					pallet_y = (double) (pallet_yI -=16);
X					pallet_row--;
X
X					/* See if the ball could have been
X					deflected as the pallete moved
X					upwards */
X					check_deflections(old_pallet_y);
X				}
X				draw_pallet(); /* draw new */
X				break;
X		    }
X		break;
X
X		case KeyPress:
X			XLookupString((XKeyEvent*) &e,keystr,2, NULL, NULL);
X			if (keystr[0]==27) {	/* Escape to save */
X				if (!ball1.quadrant && !ball2.quadrant &&
X				    !ball3.quadrant && last_busted_brick==NULL) {
X					XDrawImageString(display, win, gc,
X					OFFSET_BALLS, font_height,
X					"Saving...             ",
X					23);
X					save();
X				    }
X				else
X					XDrawImageString(display, win, gc,
X					OFFSET_BALLS, font_height,
X					"Not Saved...          ",
X					23);
X			}
X		break;
X
X		case MotionNotify:
X			draw_pallet();	/* erase old pallet */
X			pallet_x = (double) (pallet_xI =e.xmotion.x);
X			mouse_yI = e.xmotion.y;
X			draw_pallet();	/* draw new one */
X			break;
X
X		case EnterNotify:
X			window_active = TRUE;
X			break;
X
X		case LeaveNotify:
X			window_active = FALSE;
X			break;
X
X		case Expose:
X			/* redraw the stage */
X
X			for ( row = 0; row <= MAX_ROW; row++ ) {
X                		draw_brick0( row, 0 );
X                		for ( col = 1; col < MAX_COL; col++ )
X                        		draw_brick( row, col );
X		                draw_brick0( row, MAX_COL );
X			}
X			draw_pallet();
X			break;
X
X		default:
X			printf("unknown event: %d\n",e.type);
X			break;
X	    }
X	}
X    }
X}
X
X
Xvoid get_playground( argc, argv )
Xint argc;
Xchar *argv[];
X{
X	DIR		*dirp;
X	struct direct	*dp;
X	struct stat	st;
X	int		len, found;
X
X	/* set default playground directory */
X	strcpy( playground, STAGEDIR );
X	strcat( playground, "/" );
X	/* check for additional arguments (specific playground) */
X	if ( argc > 1 ) {
X		if ( argv[1][0] == '-' ) {
X			/* list available playgrounds */
X			printf( "available playgrounds are:\n" );
X			printf( "\tdefault\n" );
X			dirp = opendir(STAGEDIR);
X			for( dp=readdir( dirp ); dp!=NULL; dp=readdir( dirp ) ) {
X				if ( !strncmp( dp->d_name, "STAGES.", 7 ) )
X					printf( "\t%s\n", (dp->d_name)+7 );
X			}
X			closedir( dirp );
X			exit( 0 );
X		}
X		/* it's a playground name or private directory */
X		if( !strcmp( argv[1], "default" ) ) {
X			/* just in case someone used default */
X			strcat( playground, "STAGES" );
X			return;
X		}
X		found = 0;
X		len = strlen( argv[1] );
X		dirp = opendir( STAGEDIR );
X		for( dp=readdir( dirp ); dp!=NULL; dp=readdir( dirp ) ) {
X			if ( dp->d_namlen == len+7 &&
X			     !strcmp( (dp->d_name)+7, argv[1] ) ) {
X				found++;
X				break;
X			}
X		}
X		closedir( dirp );
X		if ( found )
X			strcat( playground, dp->d_name );
X		else {
X			/* private dir */
X			strcpy( playground, argv[1] );
X			stat( playground, &st );
X			if( !(st.st_mode & S_IFDIR) ) {
X				printf( "private playground <%s> not a directory.\n",
X					playground );
X				exit( 1 );
X			}
X		}
X	} else {
X		strcat( playground, "STAGES" );
X	}
X}
X			    
X
X/*** xblockbuster ***/
Xvoid main( argc, argv )
X	int             argc;
X	char           *argv[];
X
X{
X	XGCValues	xgcvalues;
X	Pixmap		icon_image;
X	XSizeHints	size_hints;
X	XWMHints	wm_hints;
X	XClassHint	class_hints;
X
X	/* who am i ? ['cuserid(3S)' is fooled by 'su(1)'] */
X	login = getpwuid( getuid(  ) )->pw_name;
X
X	if ((display=XOpenDisplay(NULL))==NULL) {
X		fprintf(stderr, "Unable to open display: %s\n",
X			XDisplayName(NULL));
X		exit(1);
X	}
X
X	screen_num = DefaultScreen(display);
X	win = XCreateSimpleWindow(display, RootWindow(display, screen_num),
X		0, 0, STAGE_WIDTH_IN_PIXELS, STAGE_HEIGHT_IN_PIXELS,
X		0, 2, WhitePixel(display, screen_num));
X
X
X	XSelectInput(display, win, ExposureMask | ButtonPressMask |
X		LeaveWindowMask | EnterWindowMask | KeyPressMask |
X		PointerMotionMask);
X
X
X	if ((font_info = XLoadQueryFont(display, FONT))==NULL) {
X		fprintf(stderr,"Unable to load font %s\n",FONT);
X		exit(1);
X	}
X	font_width= font_info->max_bounds.rbearing - font_info->min_bounds.lbearing;
X	font_height=font_info->max_bounds.ascent + font_info->max_bounds.descent +1;
X
X
X	xgcvalues.foreground = BlackPixel(display, screen_num);
X	xgcvalues.background = WhitePixel(display, screen_num);
X	xgcvalues.graphics_exposures = False;
X	xgcvalues.font = font_info->fid;
X
X	/* create the various graphic contexts we need. gc and gc_color
X	differ only in the we only change the colors on the gc_color context,
X	and thus, it is only used for brick drawing.  gc_color really has no
X	use on a black & white system */
X
X	gc = XCreateGC(display, win, GCFont | 
X		GCForeground | GCBackground | GCGraphicsExposures, &xgcvalues);
X	gc_color = XCreateGC(display, win, GCFont | 
X		GCForeground | GCBackground | GCGraphicsExposures, &xgcvalues);
X
X	xgcvalues.function = GXclear;
X	gc_erase = XCreateGC(display, win, GCForeground | GCBackground |
X		GCFont | GCGraphicsExposures | GCFunction, &xgcvalues);
X
X	xgcvalues.function = GXxor;	/* Exclusive or */
X
X	gc_xor = XCreateGC(display, win, GCForeground | GCBackground |
X		GCFont | GCGraphicsExposures | GCFunction, &xgcvalues);
X
X
X	/* Create our icon for when the window is closed */
X
X	if  (!(icon_image = XCreateBitmapFromData(display, win,
X	    blockbuster_bits,blockbuster_width, blockbuster_height)))
X	{
X		fprintf(stderr, "Can't create icon pixmap\n");
X		exit (1);
X	}
X
X	size_hints.flags = PMinSize;
X	size_hints.x = 0;
X	size_hints.y = 0;
X	size_hints.height = STAGE_HEIGHT_IN_PIXELS;
X	size_hints.min_height = STAGE_HEIGHT_IN_PIXELS;
X	size_hints.width = STAGE_WIDTH_IN_PIXELS;
X	size_hints.min_width = STAGE_WIDTH_IN_PIXELS;
X
X	wm_hints.flags = InputHint | IconPixmapHint;
X	wm_hints.input = True;
X	wm_hints.icon_pixmap = icon_image;
X
X	class_hints.res_name = "XBlockbuster";
X	class_hints.res_class =  "XBlockbuster";
X
X	XmbSetWMProperties(display, win, VERSION , VERSION,
X		argv,argc, &size_hints, &wm_hints, &class_hints);
X
X
X	XMapWindow(display, win);
X	/* initialize random (used to determine next stage_nb) */
X	srandom( time( 0 ) );
X
X	get_playground( argc, argv );
X
X	/* and off we go */
X	bricks_init();
X	ball_init();
X	start_up(  );
X	ball1.quadrant = ball2.quadrant = ball3.quadrant = 0;
X
X	event_handler();
X
X
X}
END_OF_FILE
if test 9125 -ne `wc -c <'xblockbuster.c'`; then
    echo shar: \"'xblockbuster.c'\" unpacked with wrong size!
fi
# end of 'xblockbuster.c'
fi
if test -f 'xblockbuster.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xblockbuster.man'\"
else
echo shar: Extracting \"'xblockbuster.man'\" \(8915 characters\)
sed "s/^X//" >'xblockbuster.man' <<'END_OF_FILE'
X.TH XBLOCKBUSTER 6 "16 November 1992"
X.br
X.SH NAME
Xxblockbuster \- game
X.SH SYNOPSIS
X.B xblockbuster
X.I [play_ground]
X.SH DESCRIPTION
XThe play ground is either the anonymous public play ground (no argument),
Xa named public playground or a privately owned directory.
XThe list of available named public play grounds is obtained by giving "-"
Xas the play ground argument.
X.LP
XThe object of the game is to collect as many points as possible by
X.I busting
Xthrough
X.I blocks
Xof various types with a ball that reflects from the blocks and from a pallet
Xcontrolled by mouse movement.
X.LP
XThe ball must be seen as a high-energy particle that penetrates the block
Xbefore being repelled.
XIf it gets repelled into another block it will find its own way out again.
XThis process, which often leads to surprises, is known as
X.I tunnelling.
X.br
X(By design, tunnelling only occurs along a horizontal connection between blocks
Xor along the vertical sides, so never vertically between blocks.)
X.LP
XAs the game progresses, balls are launched faster and faster.
XWhen the speed has reached it maximum, the pallet is gradually,
Xthough cumulatively, shrunk.
XBe aware that the maximum launch speed (see below),
Xand hence the point from which the pallet is shrunk,
Xis only 2/3 of the speed limit, and the effect is much larger than that of
Xhitting a speeder (but of course you may hit them often).
X.LP
XThe pallet is convex.
XHence reflection is a function of both the incoming angle and the excentricity
Xof the point of impact.
XIf the pallet is sufficiently convex (differs from stage to stage), the ball
Xmay even rebound.
X.LP
XThe mouse buttons control the pallet:
XLEFT moves it up one row, MIDDLE moves it all the way down again.
XEach ball is launched with the RIGHT mouse button.
X.LP
XA stage can be halted by closing the window, or moving the pointer out
Xof the window.
XBe advised however, that the game will resume immediately upon opening the
Xwindow.
X.LP
XDuring a game, the score, number of balls left and speeds are shown.
XThe speeds are represented by up to 3 thin lines (one for each ball),
Xabove a thick line representing the speed limit.
XThe short vertical bar indicates the launch speed
X(black upon reaching the maximum launch speed, white below that).
XIf, during a stage, you have busted a 'double' or 'triple' brick, your
Xbonus multiplier will also be displayed at the top.
X.LP
XA game can be saved in between stages with the Escape key.
XAt this point, as well as at the end of the game, your score is logged.
XThe score board shows scores, number of balls left between parentheses if any
Xand user name.
XFinally, an indication of your current pallet shrinkage is given.
X.SH NOTES
X.LP
XIn order to avoid infinite loops
X(i.e., the ball(s) never reflecting from the pallet),
Xa ball will, upon hitting too many solid bricks,
Xundergo a horizontal shift,
Xproportional to, but opposite to the current horizontal speed.
X.LP
XThe score board imposes a maximum on the number of entries for any given user
Xname.
XIf your current score didn't make it onto the score board,
Xit will be displayed at the bottom.
X.LP
XIf a score entry is detected which obviously must have originated from a saved
Xgame which for some reason "died", a `+' is appended and the entry will hence
Xforward be treated as any completed game.
X.LP
XA common problem players encounter is that of losing track of their mouse.
XBe advised that mouse movement only alters the horizontal pallet position,
Xbut the mouse of course may move vertically as well.
XIf your mouse is not neatly perpendicular to the reflection plate, you may
Xfind yourself outside the window, halting play.
XFor this reason the horizontal crosshair is shown at the window border,
Xhelping you to keep track of the mouse.
X.SH "CREATION OF PLAY GROUNDS"
XA private play ground can be created in any directory.
XThe stages can be defined from the ascii map codes using any text editor
XThey must be numbered consecutively from 0 with the total number
X(i.e., one more than the highest number) available in the file nb_stages.
XFurthermore a directory 'save' and an empty file 'scores' must be created.
X.LP
XIndividual stages can be tried in the public play ground "try" (q.v. 'try'),
Xprovided you have write access.
X.SH "TYPES OF BLOCKS"
X.sp
X.nf
X.na
XCODE\h'|7m'NAME\h'|24m'REPRESENTATION
X.sp
X\&' ' \h'|7m'clear space\h'|24m'white
X#\h'|7m'solid wall\h'|24m'black
X/,\\\h'|7m'launchpad\h'|24m'black with arrow (like solid wall)
X  The balls enters the stage diagonally at the tip of the arrow.
X.SS BRICKS
X.sp
X0\h'|7m'solid brick\h'|24m'75% gray
X  Scores 1 on each hit.
X.sp
X1-9\h'|7m'hit bricks\h'|24m'white with border (and slanted bars)
X  Requires as many hits as their are bars (plus 1),
X  each scoring equal to how often you have hit it.
X  The stage is over when no such bricks remain.
X.sp
Xa-e,j\h'|7m'bonus bricks\h'|24m'50% gray with value inscribed
X  Requires value/10+1 hits before scoring.
X.SS MAGIC
X.sp
XA\h'|7m'absorber\h'|24m'25% gray (no border)
X^\h'|7m'emitter\h'|24m'black (like solid wall)
X  The ball is absorbed and emitted (whilst being reflected).
X.sp
XC\h'|7m'clipper\h'|24m'pair of scissors between "> <"
X  (On 2nd hit) Clips 10% off the pallet.
X  By design, the remnants litter the screen!
X  [Until the end of the current stage only.]
X.sp
XD\h'|7m'double\h'|24m'"double"
X  (On 2nd hit) Doubles all subsequent hit values.
X  [Until the end of the current stage only.]
X.sp
XE\h'|7m'extra ball\h'|24m'"+O+"
X  (On 2nd hit) Adds an extra ball to the stock.
X.sp
XG\h'|7m'gap\h'|24m'the danger sign (! in a triangle)
X  (On 2nd hit) The ball is lost.
X  [As if it would have left the stage.]
X.sp
XH\h'|7m'halt\h'|24m'maze of small squares
X  Successively takes 10, 20 and 30% of the speed.
X.sp
XI\h'|7m'invisible brick\h'|24m'white (like open space)
X  Turns into a single hit brick when first hit, scoring 1.
X.sp
XL\h'|7m'launch ball\h'|24m'"=O="
X  (On 2nd hit) Launches an extra ball.
X  [Behaves like an 'extra ball' from 3 balls in game.]
X.sp
XM\h'|7m'mine\h'|24m'"kaboom" in dashed border
X  (On 3rd hit) Blows up all adjacent bricks (no score);
X  leaving debris 'refractor's.
X.sp
XP\h'|7m'pause\h'|24m'maze of small squares with launchpad images.
X  (On 8th hit) Takes 30% of the excessive launch speed.
X.sp
XR\h'|7m'refractor\h'|24m'dashed border with crosses
X  Interchanges motion along the axes.
X.sp
XS\h'|7m'speeder\h'|24m'concentric borders
X  Adds speed (up to the speed limit; then pallet shrinkage).
X.sp
XT\h'|7m'triple\h'|24m'"triple"
X  (On 3rd hit) Triples all subsequent hit values.
X  [Until the end of the current stage only.]
X.sp
XU\h'|7m'undo\h'|24m'"undo"
X  Restores the last block busted (with 0 hit count).
X.sp
XW\h'|7m'open window\h'|24m'bracketed set of vertical lines
X%\h'|7m'closed window\h'|24m'black (like solid wall)
X  Alternates between the two states upon each hit.
X.sp
XX\h'|7m'expander\h'|24m'a pallet image between "< >"
X  (On 4th hit) Expands the pallet.
X  [Equivalent to twice the full launch speed shrinkage.]
X  [Effective in the next stage only.]
X
X.fi
X.ad
X.SH X Defaults
X.LP
XThe resource name
X.I XBlockbuster
Xcan be used to control the color the bricks to be displayed.  Each brick
Xhas both a foreground and background color that can be displayed.  The
Xformat is brick\fIcode\fP_fg or brick\fIcode\fP_bg.
X.I code
Xrepresents the brick code, as detailed above.  Therefore a line such
Xas:
X.LP
XXBlockbuster.brick0_fg:		green
X
XMakes the foreground color of the solid brick green.
X.LP
XIn addition, the resource \fIalternate_bricks\fP
Xexists.  If selected,  alternate brick patterns will be used on color displays.
XThe alternate bricks tend to take coloring better than the standard bricks.
XIf you want to use alternate bricks, add the line:
X
XXBlockbuster.alternate_bricks:  True
X
Xto your .Xdefaults file.
X.LP
XThe coloring information and alternate brick request is ignored on
Xblack and white systems.
X
X
X.SH FILES
X.nf
X.na
Xstagemm\h'|30m'[optional] bookkeeping program
X
XThe location of the following is installation depedent.
Xstage.skel\h'|30m'skeleton stage
XSTAGES.\h'|30m'anonymous public play ground
XSTAGES.*\h'|30m'named public play grounds
X\h'|30m'(including a try out environment)
XXBlockbuster.ad\h'|30m'Sample Xdefaults for xblockbuster.
X.fi
X.ad
X
X.SH BUGS
XWhen two balls hit the same brick simultaneously,
Xone may leave a shadow on the stage.
X.LP
XSometimes a ball image is left when the window is re-opened.
X.LP
XIf the ball hits the bottom corners of the playing area, they will at times
Xreflect back in a reverse direction, instead of reflecting downward and
Xout of bounds.
X.LP
XXBlockbuster uses a public colormap for systems which use color.  If it is
Xunable to get all the colors it wants, it will use black and white for
Xthe bricks it was unable to color.  If using alternate bricks, it can be
Xdifficult to differentiate bricks without the coloring.
X.LP
XNone of the standard command line X arguements are interperted.  Likewise,
Xnone of the standard X defaults (in the .Xdefaults file) are used.
END_OF_FILE
if test 8915 -ne `wc -c <'xblockbuster.man'`; then
    echo shar: \"'xblockbuster.man'\" unpacked with wrong size!
fi
# end of 'xblockbuster.man'
fi
echo shar: End of archive 4 \(of 5\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0


exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM            | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly!      |
 "It's intuitively obvious to the most |    sources-x@imd.sterling.com
  casual observer..."                  |
