Newsgroups: comp.sources.x
From: duane@blacks.jpl.nasa.gov (Duane Clark)
Subject: v19i081:  Jetedit - A Motif text editor, Part02/04
Message-ID: <1993Apr8.144446.20169@sparky.imd.sterling.com>
X-Md4-Signature: 74dc3efc8b15a9f29e37b177081fe62e
Date: Thu, 8 Apr 1993 14:44:46 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: duane@blacks.jpl.nasa.gov (Duane Clark)
Posting-number: Volume 19, Issue 81
Archive-name: Jetedit/part02
Environment: X11, OSF/Motif

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 4)."
# Contents:  jetedit.man.uu xmemenu.c xmespec.c
# Wrapped by duane@blacks.jpl.nasa.gov on Sat Apr  3 20:04:06 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'jetedit.man.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'jetedit.man.uu'\"
else
echo shar: Extracting \"'jetedit.man.uu'\" \(14226 characters\)
sed "s/^X//" >'jetedit.man.uu' <<'END_OF_FILE'
Xbegin 755 jetedit.man
XM+E1(($I%5$5$250@,5@*+E-(($Y!344*:F5T961I="!<*&5M(&$@8&!#)R<@
XM<')O9W)A;6UE<B=S('!O:6YT(&%N9"!C;&EC:R!E9&ET;W(N(`HN4T@@4UE.
XM5$%8"BY"(&IE=&5D:70*+E))(%L@9FEL96YA;64@70HN4T@@1$530U))4%1)
XM3TX*+DD@2F5T961I=`II<R!I;G1E;F1E9"!T;R!B92!A('!R;V=R86UM97(G
XM<R!E9&ET;W(L(&)U="!I<R!U<V%B;&4@9F]R(&=E;F5R86P@<'5R<&]S92!E
XM9&ET:6YG+B!)="!H87,@82!-86,@;&EK92!I;G1E<F9A8V4@=VET:"!T:&4*
XM+D(@(CQ%>'1E;F0@8VAA<CXB"FME>2!R97!L86-I;F<@=&AE($UA8PHN0B`\
XM8V]M;6%N9#X*:V5Y+"!A;F0@9'5P;&EC871E<R!T:&4@8V]M;6]N($UA8R!E
XM9&ET:6YG(&-O;6UA;F1S+B!/=&AE<B!F96%T=7)E<R!I="!H87,Z"BY)4"!<
XM*&)U"D9I;F0@86YD(%)E<&QA8V4*+DE0(%PH8G4*1V]T;R!L:6YE(&YU;6)E
XM<@HN25`@7"AB=0I486)B:6YG(&EN(&%N9"!O=70@82!B;&]C:R!O9B!T97AT
XM"BY)4"!<*&)U"E5N9&\@961I=',*+DE0(%PH8G4*075T;VUA=&EC($,@<WEN
XM=&%X('-E;G-I=&EV92!I;F1E;G1I;F<L"G=H:6-H(&-A;B!B92!E87-I;'D@
XM8V]N9FEG=7)E9"!T;R!S=6ET('1H92!S='EL92!Y;W4@87)E('5S960@=&\N
XM(`HN4T@@3U!424].4PHN22!*971E9&ET"G)E8V]G;FEZ97,@86QL('1H92!N
XM;W)M86P@6"!7:6YD;W=S(&]P=&EO;G,@<W5C:"!A<R!F;VYT(&%N9"!G96]M
XM971R>2X@5&AE(&]N;'D@861D:71I;VYA;"!O<'1I;VX@:70@<F5C;V=N:7IE
XM<R!I<R!A(`HN25(@9FEL96YA;64@+@HN4T@@(DA/5R!)5"!73U)+4R(*+E!0
XM"E1H92!M;W-T(&EM<&]R=&%N="!F96%T=7)E(&ES('1H870@961I=',@8V%N
XM(&)E('5N9&]N92X@5&AI<R!I<R!H87)D(&-O9&5D('1O(')E;65M8F5R('1H
XM92!P<F5V:6]U<R`R,"!E9&ET<RP@=7-I;F<@82!C:7)C=6QA<B!B=69F97(N
XM"E-E;&5C=`HN22!5;F1O"F9R;VT@=&AE"BY)($5D:70*;65N=2!O<B!T>7!E
XM"BY"4B`\17AT/EH@+@I.;W1E('1H870@<V]M92!E9&ET:6YG(&9U;F-T:6]N
XM<RP@<W5C:"!A<R!T86)B:6YG(&$@8FQO8VL@;V8@=&5X="P@87)E(')E;65M
XM8F5R960@87,@;75L=&EP;&4@961I=',L"G-O('EO=2!M87D@;F5E9"!T;R!U
XM;F1O(&UU;'1I<&QE('1I;65S('1O(&-O;7!L971E;'D@=6YD;RX@"BY04`I7
XM:71H('1H92!E>&-E<'1I;VX@;V8@=6YD;RP*86QL('1H92!E9&ET:6YG(&9U
XM;F-T:6]N<R!W;W)K(&IU<W0@;&EK92!A($UA8RX@5&AI<R!I;F-L=61E<R!T
XM:&4@97AI<W1E;F-E(&]F(&$@8VQI<&)O87)D+B!497AT(&-U="!O<B!C;W!I
XM960@=&\@=&AE(&-L:7!B;V%R9`IC86X@;F]T(&]N;'D@8F4@<&%S=&5D(&)E
XM='=E96X@961I=&]R<R!R=6YN:6YG(&]N('1H92!S86UE(&AO<W0L(&)U="!B
XM96-A=7-E(&]F(%@@5VEN9&]W<R!C86X@86QS;R!B92!P87-T960@=&\@86X@
XM961I=&]R(')U;FYI;F<@;VX@82!D:69F97)E;G0@:&]S="`H=&AE"BY"(%AM
XM0VQI<&)O87)D"FES('5S960I+@HN4%`*1F]R(&YO;B!-86,@=7-E<G,L(&$@
XM8G)I968@97AP;&%N871I;VXZ"BY)4"!<*&)U"DAO;&1I;F<@9&]W;B!T:&4*
XM+DD@;&5F=`IM;W5S92!B=71T;VX@86YD(&1R86=G:6YG('1H92!M;W5S90IW
XM:6QL('-E;&5C="!A(&)L;V-K(&]F('1E>'0N"D9O<B!L87)G92!B;&]C:W,@
XM;V8@=&5X="P*8VQI8VL@=&AE(&UO=7-E(&%T('1H92!B96=I;FYI;F<@*&]R
XM(&5N9"D@;V8@=&AE(&1E<VER960@8FQO8VL@;V8@=&5X="P@;6]V92!T;R!T
XM:&4@;W1H97(@96YD(&]F('1H92!T97AT+`IA;F0@:&]L9"!D;W=N"BY"(#Q3
XM:&EF=#X*=VAI;&4@8VQI8VMI;F<@=&AE(&UO=7-E+@I4:&4@96YD<R!O9B!T
XM:&4@<V5L96-T960@8FQO8VL@8V%N(&)E(&%L=&5R960@8GD@"BY"(#Q3:&EF
XM=#X*8VQI8VMI;F<@86=A:6X@;W(@9')A9V=I;F<@=&AE(&UO=7-E('=H:6QE
XM(&AO;&1I;F<@9&]W;B!T:&4@8G5T=&]N+B`*+DE0(%PH8G4*+DD@0V]P>0HH
XM9G)O;2!T:&4*+DD@161I=`IM96YU*2!W:6QL(&-O<'D@=&AE('-E;&5C=&5D
XM(&)L;V-K(&]F('1E>'0@=&\@82!@8&-L:7!B;V%R9"<G(&EN(&UE;6]R>2X*
XM3F]T92!T:&%T('1H90HN4D(@8&`@17AT*T,@)R<*;F5X="!T;PHN4D(@8&`@
XM0V]P>2`G)PII;B!T:&4@;65N=2!M96%N<R!T:&%T(&-O<'EI;F<@8V%N(&%L
XM<V\@8F4@9&]N92!B>2!H;VQD:6YG(&1O=VX@=&AE(`HN0B`\17AT/@IK97D@
XM86YD('1Y<&EN9PHN0E(@/$,^("X*3VX@<V]M92!K97EB;V%R9',L"BY"(#Q%
XM>'0^"FUA>2!B92!H879E('-O;64@;W1H97(@;&%B96P@<W5C:"!A<PHN0E(@
XM/$%L=#X@+@HN25`@7"AB=0HN22!#=70*=VEL;"!C;W!Y('1H92!T97AT('1O
XM('1H92!C;&EP8F]A<F0L"F%N9"!T:&5N(&1E;&5T92!I="!F<F]M('EO=7(@
XM9&]C=6UE;G0N"BY)4"!<*&)U"BY)($-L96%R"BAO<B!T:&4*+D(@/$1E;#X*
XM;W(*+D(@/$)A8VMS<&%C93X*:V5Y*2!W:6QL(&1E;&5T92!T:&4@=&5X="!F
XM<F]M('1H92!D;V-U;65N="!W:71H;W5T(&%L=&5R:6YG('1H92!C;&EP8F]A
XM<F0N"BY)4"!<*&)U"BY)(%!A<W1E"G=I;&P@:6YS97)T(&$@8V]P>2!O9B!T
XM:&4@=&5X="!F<F]M('1H92!C;&EP8F]A<F0@=&\@=&AE(&-U<G)E;G0@:6YS
XM97)T:6]N('!O:6YT+@HN25`@7"AB=0I)9B!A(&)L;V-K(&]F('1E>'0@:7,@
XM<V5L96-T960L"F%N9"!T:&5N('EO=2!T>7!E(&$@8VAA<F%C=&5R(&]R('!A
XM<W1E(&9R;VT@=&AE(&-L:7!B;V%R9"P@=&AE('-E;&5C=&5D(&)L;V-K(&ES
XM(&]V97)W<FET=&5N+@I4:&4@8V]N=&5N=',@;V8@=&AE(&-L:7!B;V%R9"!A
XM<F4@;F]T(&%L=&5R960N(`HN4%`*06YO=&AE<B!M971H;V0@879A:6QA8FQE
XM(&9O<B!C;W!Y:6YG('1E>'0@:7,@=&\@8VQI8VL@=&AE(&UO=7-E(&%T('1H
XM92!P;VEN="!W:&5R92!Y;W4@=V%N="!T:&4@=&5X="!T;R!B92!I;G-E<G1E
XM9"P@=&\@<'5T('1H92!I;G-E<G1I;VX@<&]I;G0@=&AE<F4N"E1H96X@9V\@
XM=&\@=&AE('1H92!T97AT('1O(&)E(&-O<&EE9"!A;F0@<')E<W,@=&AE(`HN
XM22!C96YT97(*;6]U<V4@8G5T=&]N('=H:6QE(&1R86=G:6YG('1H92!M;W5S
XM92X*07,@>6]U(&1R86<@=&AE(&UO=7-E+`IT:&4@<V5L96-T960@=&5X="!W
XM:6QL(&)E('5N9&5R;&EN960N"E=H96X@=&AE(&UO=7-E(&)U='1O;B!I<R!R
XM96QE87-E9"P*=&AE('-E;&5C=&5D('1E>'0@=VEL;"!B92!C;W!I960@=&\@
XM=&AE('!R979I;W5S;'D@<V5T(&EN<V5R=&EO;B!P;VEN="X@2&]L9&EN9R!D
XM;W=N"BY"(#Q#5%),/@IW:&EL92!D<F%G9VEN9R!W:6QL(')E<W5L="!I;B!T
XM:&4@<V5L96-T960@=&5X="!B96EN9R!D96QE=&5D(&%F=&5R(&ET(&ES(&-O
XM<&EE9"X*+E!0"D%N(&5N=&ER92!B;&]C:R!O9B!T97AT(&-A;B!B92!T86)B
XM960@:6X@;W(@;W5T(&)Y('-E;&5C=&EN9R!T:&4@8FQO8VL@=VET:"!T:&4@
XM;6]U<V4L"G1H96X@='EP:6YG"BY"(#Q486(^"F]R"BY"4B!S:&EF=#Q486(^
XM("X*+E!0"BY"($5X=#Q(;VUE/@IW:6QL('1A:V4@>6]U('1O('1H92!B96=I
XM;FYI;F<@;V8@=&AE(&9I;&4N(`HN0B!3:&EF=#Q(;VUE/@IW:6QL('1A:V4@
XM>6]U('1O('1H92!E;F0@;V8@=&AE(&9I;&4N"BY04`I396QE8W1I;F<*+DD@
XM3W!E;@IF<F]M('1H90HN22!&:6QE"FUE;G4@=VEL;"!P;W`@=7`@80HN22`B
XM1FEL92!396QE8W1I;VXB"F1I86QO9R!B;W@N"E1H92!D:6%L;V<@86QL;W=S
XM('1R879E<G-A;"!U<"!A;F0@9&]W;@IT:')O=6=H('1H92!D:7)E8W1O<GD@
XM<W1R=6-T=7)E('5S:6YG('1H92!M;W5S92X@1&]U8FQE(&-L:6-K:6YG("AC
XM;&EC:VEN9R!T:&4*+DD@;&5F=`IM;W5S92!B=71T;VX@='=I8V4@<F%P:61L
XM>2D@;VX@82!D:7)E8W1O<GD@;F%M92!I;B!T:&4@"BY)($9I;&5S"F%R96$@
XM=VEL;"!M;W9E('EO=2!D;W=N(&EN=&\@=&AA="!D:7)E8W1O<GDN($1O=6)L
XM92!C;&EC:VEN9R!O;B!@8"XN)R<@=VEL;"!M;W9E('EO=2!U<"!O;F4@9&ER
XM96-T;W)Y+B!$;W5B;&4@8VQI8VMI;F<@;VX@82!F:6QE;F%M92!W:6QL(&]P
XM96X@=&AA="!F:6QE+B!!9&1I;F<@<V]M971H:6YG(&QI:V4@8&`J+F,G)R!I
XM;B!T:&4*+DD@(D9I;&4@1FEL=&5R(@IW:6YD;W<@=VEL;"!C875S92!T:&4@
XM9&EA;&]G('1O(&]N;'D@9&ES<&QA>2`J+F,@9FEL97,L(&9O<B!E>&%M<&QE
XM+@HN4%`*02!N=6UB97(@;V8@9F5A='5R97,@:6YT96YD960@9F]R('!R;V=R
XM86UM97)S(&%R92!I;F-L=61E9"P@86YD(&-A;B!B92!E87-I;'D@=F%R:65D
XM('1O('-U:70@=&AE(&9O<FUA="!S='EL92!Y;W4@87)E('5S960@=&\N(%1H
XM97D@87)E(&-O;G1R;VQL960@8GD@<F5S;W5R8V5S('1H870@8V%N(&)E('-E
XM="!I;B!Y;W5R(`HN0B`N6&1E9F%U;'1S"F9I;&4@;W(@=VET:"!A(&1I86QO
XM9RX*4V5L96-T:6YG"BY)(%!R969E<F5N8V5S"F9R;VT@=&AE"BY)($5D:70*
XM;65N=2!W:6QL('!O<"!U<"!A(&1I86QO9R!T;R!A;&QO=R!Y;W4@=&\@<V5T
XM('1H92!P<F5F97)E;F-E<RX@5&AE;B!C;&EC:VEN9R!T:&4*+DD@2&5L<`IB
XM=71T;VX@=VEL;"!P;W`@=7`@86YO=&AE<B!D:6%L;V<*=VAI8V@@=VEL;"!T
XM96QL('EO=2!E>&%C=&QY('=H870@<F5S;W5R8V5S('1O('5S92!F;W(@=&AE
XM('-E;&5C=&5D('!R969E<F5N8V5S+@HN4%`*5&AR964@:6YD96YT:6YG(&UO
XM9&5S(&%R92!A=F%I;&%B;&4N"E-M87)T(&EN9&5N=&EN9R!W:6QL(&EN9&5N
XM="!A(&YE=R!L:6YE('1O('1H92!L979E;"!O9B!T:&4@<')E=FEO=7,@;&EN
XM92X*4WEN=&%X('-E;G-I=&EV92!I;F1E;G1I;F<@871T96UP=',@=&\@;6%K
XM92!I;G1E;&QI9V5N="!D96-I<VEO;G,@86)O=70@:6YD96YT:6YG(&%N9"!O
XM=71D96YT:6YG(&%C8V]R9&EN9R!T;R!T:&4@<G5L97,@;V8@0R!S>6YT87@L
XM(&%N9"!A8V-O<F1I;F<@=&\@82!N=6UB97(@;V8@<V5L96-T86)L92!P<F5F
XM97)E;F-E<R!F;W(@:6YD96YT:6YG('-T>6QE+B!9;W4@8V%N(&%L<V\@8VAO
XM;W-E(&YO(&%U=&]M871I8R!I;F1E;G1I;F<@:68@9&5S:7)E9"X@"BY32"`B
XM6"!$149!54Q44R(*5&AE(&9O;&QO=VEN9R!R97-O=7)C97,@8V%N(&)E('!U
XM="!I;B!Y;W5R(`HN0B!^+RY89&5F875L=',*;W(*+D(@=7-R+VQI8B]8,3$O
XM87!P+61E9F%U;'1S+TIE=&5D:70*9FEL92X*4F5A<V]N86)L92!D969A=6QT
XM<R!A<F4@<W5P<&QI960@:68@;F\@<F5S;W5R8V5S(&%R92!S<&5C:69I960N
XM"BY44`HN0B!B86-K9W)O=6YD"DD@9FEN9"!T:&%T(&%N(&]V97)A;&P@8F%C
XM:V=R;W5N9"!O9B!@8$=R87DY,"<G(&ES(&UU8V@@96%S:65R(&]N('1H92!E
XM>65S('1H86X@8&!7:&ET92<G+B`*+E10"BY"(&)L:6YK4F%T90I-;W1I9B`Q
XM+C`@=&5X="!W:61G971S(&AA=F4@<')O8FQE;7,@=VET:"!T:&4@8FQI;FMI
XM;F<@8W5R<V]R+B!3971T:6YG('1H:7,@<F5S;W5R8V4@=&\@8&`P)R<@=VEL
XM;"!S=&]P('1H92!B;&EN:VEN9R!A;F0@=&AE('!R;V)L96TN(`HN5%`*+D(@
XM9FEN9%]C87-E+G-E=`I3971T:6YG('1H:7,@=&\*+DD@5')U90IW:6QL('-E
XM="!T:&4@9&5F875L="!F;W(@=&5X="!S96%R8VAE<R!T;R!I9VYO<F4@=&5X
XM="!C87-E+@HN5%`*+D(@9F]N=$QI<W0*270@:7,@8F5S="!T;R!S96QE8W0@
XM82!F:7AE9"!W:61T:"!F;VYT+B!!;'-O+"!T:&4@36]T:68@,2XP('1E>'0@
XM=VED9V5T(&AA<R!P<F]B;&5M<R!W:71H('-O;64@9F]N=',@=VAE;B!D<F%G
XM9VEN9R!T:&4@;6]U<V4@=&\@<V5L96-T('1E>'0N"E1H92!D969A=6QT(&ES
XM(&!@1FEX960G)RX*06YO=&AE<B!G;V]D(&]N92!I9B!Y;W4@:&%V92!I="!I
XM<R!@8&QU=%)3,3(G)RX@"BY44`HN0B!I;F9O1FEL90I3<&5C:69Y:6YG(&$@
XM9FEL96YA;64@=VET:"!A(&-O;7!L971E('!A=&@@=VEL;"!C875S92!T:&%T
XM(&9I;&4@=&\@8F4@<F5A9"!I;G1O"BY)(&IE=&5D:70*:68@;F\*+DD@9FEL
XM96YA;64*:7,@<W!E8VEF:65D(&]N('1H92!C;VUM86YD(&QI;F4N"E1H:7,@
XM;6EG:'0@8F4@=7-E9G5L(&9O<B!I;F9O<FUI;F<@=7-E<G,@9VQO8F%L;'D@
XM;V8@=7!D871E<RX@"BY44`HN0B!R96=U;&%R7V5X<"YS970*4V5T=&EN9R!T
XM:&ES('1O"BY)(%1R=64*=VEL;"!S970@=&AE(&1E9F%U;'0@9F]R('1E>'0@
XM<V5A<F-H97,@=&\@=7-E(')E9W5L87(@97AP<F5S<VEO;G,N"BY44`HN0B!S
XM=&%R=%]A=%]T;W`N<V5T"E-E='1I;F<@=&AI<R!T;PHN22!4<G5E"G=I;&P@
XM<V5T('1H92!D969A=6QT(&9O<B!T97AT('-E87)C:&5S('1O(&)E9VEN(&%T
XM('1H92!T;W`@;V8@=&AE(&9I;&4N"BY44`HN0B!U;G-E;&5C=$-O;&]R"E1H
XM:7,@9&5T97)M:6YE<R!T:&4@8V]L;W(@=7-E9"!T;R!I;F1I8V%T92!T:&4@
XM=6YS96QE8W1E9"!S=&%T92!O9B!T:&4@8G)A8VME=',@:6X@=&AE('!R969E
XM<F5N8V5S(&1I86QO9W,N($$@9V]O9"!C;VQO<B!I<R!@8$=R87DW,"<G+@I)
XM="!D969A=6QT<R!T;R!@8%=H:71E)R<N"BY04`I4:&4@9F]L;&]W:6YG(')E
XM<V]U<F-E<R!A<F4@96%S:65S="!T;R!D971E<FUI;F4@8GD@<V5L96-T:6YG
XM"BY)(%!R969E<F5N8V5S"F9R;VT@=&AE"BY)($5D:70*;65N=2!A;F0@=7-I
XM;F<@=&AE"BY)($AE;'`*9&EA;&]G('1O(&1E=&5R;6EN92!T:&4@8V]R<F5C
XM="!V86QU97,@=&\@=7-E+B`*+E10"BY"(&EN9&5N=`I296=U;&%R+"!S;6%R
XM="P@;W(@0R!S>6YT87@@<V5N<VET:79E(&EN9&5N=&EN9RX@"BY44`HN0B!L
XM96%D:6YG5&%B<PI!(&)O;VQE86X@9&5T97)M:6YI;F<@=VAE=&AE<B!T;R!U
XM<V4@<W!A8V5S(&]R('1A8G,@9F]R(&QE861I;F<@=&%B<RX@3&5A9&EN9R!T
XM86)S(&%R92!T86)S('=H:6-H(&%R92!T>7!E9`IB969O<F4@86YY(&YO;BUW
XM:&ET97-P86-E(&]N(&$@;&EN92X*+E10"BY"('1R86EL:6YG5&%B<PI!;&P@
XM;W1H97(@=&%B<R!A<F4@=')A:6QI;F<@=&%B<RX*+E10"BY"('-P86-E<PI$
XM971E<FUI;F5S(&AO=R!M86YY('-P86-E<R!T;R!I;G-E<G0@=VAE;B!A('1A
XM8B!I<R!T>7!E9"!I9B!E:71H97(*+D(@;&5A9&EN9U1A8G,*;W(*+D(@=')A
XM:6QI;F=486)S"FES($9A;'-E+@HN5%`*+D(@;W!E;D)R86-E"D1E=&5R;6EN
XM97,@:&]W('1O(&EN9&5N="!O<&5N:6YG(&)R86-E<RX@"BY44`HN0B!C;&]S
XM94)R86-E"D1E=&5R;6EN97,@:&]W('1O(&EN9&5N="!C;&]S:6YG(&)R86-E
XM<RX@"BY44`HN0B!I;F1E;G1#87-E"D$@8F]O;&5A;B!W:&EC:"!D971E<FUI
XM;F5S('=H971H97(@=&\@:6YD96YT(&-A<V4@<W1A=&5M96YT<R!F<F]M('1H
XM92!L979E;"!O9B!T:&4@<W=I=&-H('-T871E;65N="X*+E-((%1204Y33$%4
XM24].4PHN22!*971E9&ET"F1E9FEN97,@=&AE(&9O;&QO=VEN9R!T<F%N<VQA
XM=&EO;G,@9F]R('1H92!M86EN(&5D:71I;F<@=VEN9&]W+B`*+EPB+2TM+2TM
XM+2T*+EPB(%-T87)T(&]F(%1A8FQE"BY<(B!4:&4@7"8@87)E('1H97)E('-I
XM;7!L>2!T;R!F:6QL('-P86-E(&EN('1H92!S;W5R8V4@9FEL92`*+EPB('-O
XM('1H870@=&AE('1A8G,@;&]O:R!G;V]D(&AE<F4@87,@=V5L;"!A<R!I;B!T
XM:&4@;W5T<'5T+B`*+EPB+2TM+2TM+2T*+E!0"BY24PHN=&$@7'<G.CQ+97D^
XM8G)A8V5R:6=H=#I<,%PP7#!<,"=U"BYN9@HN9G0@0@H\2V5Y/E)E='5R;CI<
XM)EPF"4YE=TQI;F4H7'PI"E-H:69T/$ME>3Y(;VUE.EPF"51O0F]T=&]M*%Q\
XM*0I-971A/$ME>3Y(;VUE.EPF"51O5&]P*%Q\*0I3:&EF=#Q+97D^5&%B.EPF
XM"4]U=&1E;G1497AT*%Q\*0H\2V5Y/E1A8CI<)EPF7"9<)@E);F1E;G1497AT
XM*%Q\*0HZ/$ME>3YB<F%C97)I9VAT.@E2:6=H=$)R86-E*%Q\*0HZ/$ME>3YB
XM<F%C96QE9G0Z"4QE9G1"<F%C92A<?"D*+F9T(%`*+D14"BYF:0HN4D4*+EPB
XM+2TM+2TM+2T*+EPB($5N9"!O9B!486)L90HN7"(M+2TM+2TM+0HN4T@@04-4
XM24].(%)/551)3D53"BY)($IE=&5D:70*9&5F:6YE<R!T:&4@9F]L;&]W:6YG
XM(&%C=&EO;B!R;W5T:6YE<RX*+E10"BY"($YE=TQI;F4H7'PI"E=H96X@:6X@
XM<VUA<G0@;W(@<WEN=&%X(&EN9&5N=&EN9R!M;V1E+`ID971E<FUI;F5S('1H
XM92!N=6UB97(@;V8@=&%B<R!O<B!S<&%C97,@=&\@:6YS97)T(&%N9"!I;G-E
XM<G1S('1H96TN(`HN5%`*+D(@5&]";W1T;VTH7'PI"DUO=F5S('1H92!C=7)S
XM;W(@=&\@=&AE(&)O='1O;2!O9B!T:&4@9FEL92X@"BY44`HN0B!4;U1O<"A<
XM?"D*36]V97,@=&AE(&-U<G-O<B!T;R!T:&4@=&]P(&]F('1H92!F:6QE+B`*
XM+E10"BY"($EN9&5N=%1E>'0H7'PI"DEF(&$@8FQO8VL@;V8@=&5X="!I<R!S
XM96QE8W1E9"P*:6YD96YT<R!E86-H(&QI;F4@:6X@=&AE(&)L;V-K(&]N92!T
XM86(@<W1O<"X@16QS92!I;G-E<G1S(&]N92!T86(@<W1O<"!A="!C=7)R96YT
XM(&-U<G-O<B!P;W-I=&EO;BX@"BY44`HN0B!/=71D96YT5&5X="A<?"D*268@
XM82!B;&]C:R!O9B!T97AT(&ES('-E;&5C=&5D+`IO=71D96YT<R!E86-H(&QI
XM;F4@:6X@=&AE(&)L;V-K(&]N92!T86(@<W1O<"X@16QS92!D96QE=&5S(&]N
XM92!T86(@<W1O<"!A="!C=7)R96YT(&-U<G-O<B!P;W-I=&EO;BX@"BY44`HN
XM0B!2:6=H=$)R86-E*%Q\*0I);G-E<G1S(&$@<FEG:'0@8G)A8V4L"F]U=&1E
XM;G1I;F<@:68@87!P<F]P<FEA=&4@9F]R('1H92!S96QE8W1E9"!E9&ET:6YG
XM('-T>6QE+B`*+E10"BY"($QE9G1"<F%C92A<?"D*26YS97)T<R!A(&QE9G0@
XM8G)A8V4L"F]U=&1E;G1I;F<@:68@87!P<F]P<FEA=&4@9F]R('1H92!S96QE
XM8W1E9"!E9&ET:6YG('-T>6QE+B`*+E10"BY"($-U=$ET96TH7'PI"D-O<&EE
XM<R!T:&4@<V5L96-T960@8FQO8VL@;V8@=&5X="!T;R!T:&4@8VQI<&)O87)D
XM+"!T:&5N(&1E;&5T97,@:70@9G)O;2!T:&4@=&5X="!W:6YD;W<N"BY44`HN
XM0B!#;W!Y271E;2A<?"D*0V]P:65S('1H92!S96QE8W1E9"!B;&]C:R!O9B!T
XM97AT('1O('1H92!C;&EP8F]A<F0N(`HN5%`*+D(@4&%S=&5)=&5M*%Q\*0I/
XM=F5R=W)I=&5S('1H92!S96QE8W1E9"!B;&]C:R!O9B!T97AT"G=I=&@@=&AE
XM(&-O;G1E;G1S(&]F('1H92!C;&EP8F]A<F0N"BY32"!"54=3"BY04`I4:&4@
XM36]T:68@,2XP('1E>'0@=VED9V5T(&AA<R!A(&YU;6)E<B!O9B!M:6YO<B!B
XM=6=S+"!M;W-T(&]F('=H:6-H(&AA=F4@8F5E;B!C;W)R96-T960@:6X@36]T
XM:68@,2XQ+B`*+E!0"D)U9W,@=VAI8V@@:&%V92!B965N(&-O<G)E8W1E9"!I
XM;B!-;W1I9B`Q+C$Z(`HN25`@7"AB=0I4:&4@8FQI;FMI;F<@8W5R<V]R('-O
XM;65T:6UE<R!B96-O;65S(&5R<F%T:6,@;W(@9&ES87!P96%R<RX@5&AI<R!I
XM<R!B97-T(&-O<G)E8W1E9"!B>2!D:7-A8FQI;F<@8FQI;FMI;F<N(%-E92!T
XM:&4*+D(@(E@@1$5&055,5%,B"G-E8W1I;VX@86)O=F4N"BY)4"!<*&)U"DD@
XM9&ED(&YO="!I;7!L96UE;G0@<&%G92!U<"!A;F0@9&]W;@IB>2!C;&EC:VEN
XM9R!I;B!T:&4@<V-R;VQL(&)A<B!P86=I;F<@87)E82X@36]T:68@,2XQ(&AA
XM<R!T:&ES('-U<'!O<G0@8G5I;'0@:6XN"BY)4"!<*&)U"D]N('-O;64@<V5R
XM=F5R<RP@=VAE;B!D<F%G9VEN9R!T:&4@;6]U<V4@=&\@<V5L96-T(&$@8FQO
XM8VL@;V8@=&5X="P@=&AE(&9I<G-T(&-A<F%C=&5R('EO=2!T:&]U9VAT('EO
XM=2!W97)E('-E;&5C=&EN9R!G971S(&UI<W-E9"X@3F\L('EO=2!A<F5N)W0@
XM;&]S:6YG(&5Y92!H86YD(&-O;W)D:6YA=&EO;BX@"BY)4"!<*&)U"E1Y<&EN
XM9R!A(&UE;G4@86-C96QE<F%T;W(@=VAI;&4@:6X@;VYE(&]F('1H92!M96YU
XM(&1I86QO9W,@8V%N(&-A=7-E(&9A=&%L(&-R87-H97,N"DEN(&]V97(@='=O
XM('EE87)S('5S92!W:71H($UO=&EF(#$N,"P*=&AI<R!I<R!T:&4@;VYL>2!K
XM;F]W;B!F871A;"!E<G)O<BP@86YD(&ES(&9I>&5D(&EN($UO=&EF,2XQ+@HN
XM4%`*0G5G<R!W:&EC:"!E>&ES="!I;B!-;W1I9B`Q+C$Z"BY)4"!<*&)U"E=H
XM96X@:6X@=V]R9'=R87`@;6]D92P@961I=&EN9R!B96-O;65S(')A=&AE<B!S
XM;'5G9VES:"!W:71H(&9I;&5S(&]F(&5V96X@82!F97<@=&AO=7-A;F0@8GET
XM97,N(`HN4%`*+E-(($-/4%E224=(5%,**&,I($-O<'ER:6=H="`Q.3DS(&)Y
XM($1U86YE($-L87)K+@HN4%`*4V5E('1H90HN22!J971E9&ET"G-O=7)C92!F
XM:6QE"BY"(&-O<'ER:6=H="YH"F9O<B!A(&9U;&P@8V]P>7)I9VAT(&YO=&EC
XM92X*+E-(($%55$A/4E,*1'5A;F4@0VQA<FL@7"AE;2!D=6%N94!B;&%C:W,N
XM:G!L+FYA<V$N9V]V(`HN4%`*2FEM($-A;7!B96QL(%PH96T@:F5C0&UI;&YE
XM+F)O96EN9RYC;VT@7"AE;2!C;VYT<FEB=71E9"!R96=U;&%R(&5X<')E<W-I
XM;VX@=&5X="!S96%R8VAE<RX@"BY04`I$879I9"!7+B!386YD97)S;VX@7"AE
XM;2!D=W-`<W-E8RYW:7-C+F5D=2!<*&5M(&1I9"!S:6=N:69I8V%N="!W;W)K
XM('1O(&EM<')O=F4@=&AE(&9O<FUA='1I;F<@;V8@=&AE(&UA;B!P86=E+B`*
X`
Xend
END_OF_FILE
if test 14226 -ne `wc -c <'jetedit.man.uu'`; then
    echo shar: \"'jetedit.man.uu'\" unpacked with wrong size!
fi
# end of 'jetedit.man.uu'
fi
if test -f 'xmemenu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xmemenu.c'\"
else
echo shar: Extracting \"'xmemenu.c'\" \(16225 characters\)
sed "s/^X//" >'xmemenu.c' <<'END_OF_FILE'
X/**---------------------------------------------------------------------
X***     
X***	file:		xmemenu.c
X***	main:		xme.c
X***
X***	project:	Motif Widgets text editor
X***
X*** 			(c) Copyright 1989 by Open Software Foundation, Inc.
X*** 				All Rights Reserved.
X***
X*** 			(c) Copyright 1989 by Hewlett-Packard Company.
X***
X***
X***-------------------------------------------------------------------*/
X
X#define MENU_EXIT		201
X#define MENU_OPEN		202
X#define MENU_NEW		203
X#define MENU_CLOSE		204
X#define MENU_SAVE		205
X#define MENU_SAVE_AS		206
X#define MENU_PRINT		207
X#define MENU_CUT		208
X#define MENU_COPY		209
X#define MENU_PASTE		210
X#define MENU_CLEAR		211
X#define MENU_GOTO		212
X#define MENU_FINDA		213
X#define MENU_FIND		214
X#define MENU_UNDO		215
X#define MENU_REPLACE		216
X#define MENU_WRAP		217
X#define MENU_PREF		218
X
X#define DISABLE_INDENT		300
X#define SMART_INDENT		301
X#define SYNTAX_INDENT		302
X
X#define REAL_TAB		303
X#define FOUR_TAB		304
X
X#include "xme.h"
X
X
Xvoid CutItem(w,event)
XWidget	  w;
XXKeyEvent *event;
X{
X#ifdef Motif1.0
X    CopyItemToClipboard(event->time);
X    DeletePrimarySelection();
X#else
X    XmTextCut(w, event->time+1);
X#endif
X}
X
Xvoid CopyItem(w,event)
XWidget	  w;
XXKeyEvent *event;
X{
X#ifdef Motif1.0
X    CopyItemToClipboard(event->time);
X#else
X    XmTextCopy(w, event->time+1);
X#endif
X}
X
Xvoid PasteItem(w,event)
XWidget	  w;
XXKeyEvent *event;
X{
X#ifdef Motif1.0
X    PasteItemFromClipboard();
X#else
X    XmTextPaste (w);
X#endif
X}
X
X/* ClearItem will only be called if Clear is selected from the menu.
XOtherwise, the text widgets already handle the delete key correctly. */
Xvoid ClearItem(w,event)
XWidget	  w;
XXKeyEvent *event;
X{
X#ifdef Motif1.0
X    DeletePrimarySelection();
X#else
X    XmTextRemove(w);
X#endif
X}
X
X/*-------------------------------------------------------------
X**	MenuCB
X**		Process callback from PushButtons in PulldownMenus.
X*/
Xvoid MenuCB (w, client_data, call_data) 
XWidget		w;		/*  widget id			*/
Xcaddr_t		client_data;	/*  data from application	*/
Xcaddr_t		call_data;	/*  data from widget class	*/
X{
X    Cardinal	ac;		/* arg count                */
X    Arg		al[10];		/* arg list                 */
X    char	*command;	/* command used in printing */
X    Boolean	Wrap;
X
X    XmAnyCallbackStruct *cb = (XmAnyCallbackStruct *) call_data;
X    
X    switch ((int)client_data)
X    {
X    case MENU_OPEN:
X        /* display the file selection dialog */
X        XtManageChild (open_dialog);
X        if (!file_saved) /* display the 'save' message dialog */
X            XtManageChild (open_warning);
X        break;
X
X    case MENU_NEW:
X        /* display the prompt dialog */
X        if (thefile) {
X            XtSetArg(al[0], XmNtextString, XmStringCreateLtoR
X                 (thefile, charset));
X            XtSetValues (new_dialog, al, 1);
X        }
X        XtManageChild (new_dialog);
X        if (!file_saved) /* display the 'save' message dialog */
X            XtManageChild (new_warning);
X        break;
X
X    case MENU_CLOSE:
X        if (!file_saved) /* display the 'save' message dialog */
X            XtManageChild (close_warning);
X        else {
X            CloseFile();
X            sprintf (message_string, " Editing:");
X            XtSetArg(al[0], XmNlabelString, 
X                XmStringCreateLtoR(message_string, charset));
X            XtSetValues(message, al, 1);
X        }
X        break;
X
X    case MENU_SAVE:
X        SaveFile();
X        break;
X
X    case MENU_SAVE_AS:
X        /* Display the 'save as' dialog with the
X		present thefile displayed in it. */
X        ac = 0;
X        XtSetArg(al[ac], XmNtextString,
X             XmStringCreateLtoR (thefile, charset));  ac++;
X        XtSetValues(save_as_dialog, al, ac);
X        XtManageChild (save_as_dialog);
X        break;
X
X    case MENU_PRINT:
X/*        if (!file_saved)
X            XtManageChild(print_warning);
X        else if (thefile != NULL) {
X            /* malloc space for the command name. 
X                Note: command = size of the thefile +
X                "lp " + null terminator */
X/*            command = XtMalloc(sizeof(thefile) + 4);
X            sprintf(command, "lp %s", thefile);
X            if (system(command) != NULL)
X                fprintf(stderr, "\7print failed");
X        }
X        break;
X*/
X    
X    case MENU_EXIT:
X        /* exit if there is no files open */
X        if (!file_saved) /* display the 'save' message dialog */
X            XtManageChild (exit_warning);
X        else {
X            /* close up file pointers and descriptors */
X            CloseFile();
X            CloseUndoBuffer();
X
X            /* exit this program */
X            exit (0);
X        }
X        break;
X
X    case MENU_UNDO:
X        {
X        Undo(cb->event);
X        }
X        break;
X
X    case MENU_CUT:
X        CutItem(text, cb->event);
X        break;
X
X    case MENU_COPY:
X        CopyItem(text, cb->event);
X        break;
X
X    case MENU_PASTE:
X        PasteItem(text, cb->event);
X        break;
X
X    case MENU_CLEAR:
X        ClearItem(text, cb->event);
X        break;
X
X    case MENU_FIND:
X        XtSetSensitive(findA_button, False);
X        XtSetSensitive(replace_button, False);
X        XtSetSensitive(replace_pb, False);
X        XtSetSensitive(replaceAll_pb, False);
X        XtManageChild(find_dialog);
X        break;
X
X    case MENU_REPLACE:
X        ReplaceString();        
X    case MENU_FINDA:
X        if (the_string)
X            FindString(cb->event->xbutton.time+1);
X        break;
X
X    case MENU_GOTO:
X        XtManageChild(goto_dialog);
X        break;
X
X    case MENU_PREF:
X        XtManageChild (prefer_dialog);
X        break;
X
X    default:
X        /* unknown client_data was recieved and
X            there is no setup to handle this */
X        fprintf(stderr, "\7Warning: in menu callback\n");
X        break;
X    }
X
X}
X
X
X
X/*-------------------------------------------------------------
X**      CreateMenuBar
X**              Create MenuBar in MainWindow
X*/
XWidget CreateMenuBar (parent)
XWidget          parent;
X{
X    Widget    menu_bar;		/*  RowColumn                   */
X    Widget    cascade;		/*  CascadeButton               */
X    Widget    menu_pane;	/*  RowColumn                   */
X    Widget    button;		/*  PushButton                  */
X    Widget    sub_menu;
X    
X    Arg		al[10];		/*  arg list                    */
X    Cardinal	ac;		/*  arg count                   */
X    
X    /****   Create MenuArea.        ****/
X    ac = 0;
X    menu_bar = XmCreateMenuBar (parent, "menu_bar", al, ac);
X    
X    /****   Create "File" PulldownMenu.     ****/
X    ac = 0;
X    menu_pane = XmCreatePulldownMenu (menu_bar, "filemenu", al, ac);
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Open", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg(al[ac], XmNacceleratorText,
X    	XmStringCreateLtoR("Ext+O", charset)); ac++;
X    XtSetArg(al[ac], XmNaccelerator, "Meta<Key>O:"); ac++;
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    button = XmCreatePushButtonGadget (menu_pane, "Open", al, ac);
X    XtAddCallback (button, XmNactivateCallback, MenuCB, MENU_OPEN);
X    XtManageChild (button);
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("New", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg(al[ac], XmNacceleratorText,
X    	XmStringCreateLtoR("Ext+N", charset)); ac++;
X    XtSetArg(al[ac], XmNaccelerator, "Meta<Key>N:"); ac++;
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    button = XmCreatePushButtonGadget (menu_pane, "New", al, ac);
X    XtAddCallback (button, XmNactivateCallback, MenuCB, MENU_NEW);
X    XtManageChild (button);
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Close", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    button = XmCreatePushButtonGadget (menu_pane, "Close", al, ac);
X    XtAddCallback (button, XmNactivateCallback, MenuCB, MENU_CLOSE);
X    XtManageChild (button);
X    
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Save", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg(al[ac], XmNacceleratorText,
X    	XmStringCreateLtoR("Ext+S", charset)); ac++;
X    XtSetArg(al[ac], XmNaccelerator, "Meta<Key>S:"); ac++;
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    save_button = XmCreatePushButtonGadget (menu_pane, "Save", al, ac);
X    XtAddCallback (save_button, XmNactivateCallback, MenuCB, MENU_SAVE);
X    XtManageChild (save_button);
X    XtSetSensitive(save_button, False);
X    
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Save As...", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    button = XmCreatePushButtonGadget (menu_pane, "Save As...", al, ac);
X    XtAddCallback (button, XmNactivateCallback, MenuCB, MENU_SAVE_AS);
X    XtManageChild (button);
X    
X    
X    ac = 0;
X    separator = XmCreateSeparator (menu_pane, "Sep", al, ac);
X    XtManageChild (separator);
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Quit", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg(al[ac], XmNacceleratorText,
X    	XmStringCreateLtoR("Ext+Q", charset)); ac++;
X    XtSetArg(al[ac], XmNaccelerator, "Meta<Key>Q:"); ac++;
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    button = XmCreatePushButtonGadget (menu_pane, "Exit", al, ac);
X    XtAddCallback (button, XmNactivateCallback, MenuCB, MENU_EXIT);
X    XtManageChild (button);
X    
X    ac = 0;
X    XtSetArg (al[ac], XmNsubMenuId, menu_pane);  ac++;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("File", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    cascade = XmCreateCascadeButton (menu_bar, "File", al, ac);
X    XtManageChild (cascade);
X    
X    /****   Create "Edit" PulldownMenu.     ****/
X    ac = 0;
X    menu_pane = XmCreatePulldownMenu (menu_bar, "editmenu", al, ac);
X
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Undo", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg(al[ac], XmNacceleratorText,
X    	XmStringCreateLtoR("Ext+Z", charset)); ac++;
X    XtSetArg(al[ac], XmNaccelerator, "Meta<Key>Z:"); ac++;
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    undo_button = XmCreatePushButtonGadget (menu_pane, "Undo", al, ac);
X    XtAddCallback (undo_button, XmNactivateCallback, MenuCB, MENU_UNDO);
X    XtManageChild (undo_button);
X    XtSetSensitive(undo_button, False);
X    
X    ac = 0;
X    separator = XmCreateSeparator (menu_pane, "Sep", al, ac);
X    XtManageChild (separator);
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Cut", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg(al[ac], XmNacceleratorText,
X    	XmStringCreateLtoR("Ext+X", charset)); ac++;
X    XtSetArg(al[ac], XmNaccelerator, "Meta<Key>X:"); ac++;
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    cut_button = XmCreatePushButtonGadget (menu_pane, "Cut", al, ac);
X    XtAddCallback (cut_button, XmNactivateCallback, MenuCB, MENU_CUT);
X    XtManageChild (cut_button);
X    XtSetSensitive(cut_button, False);
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Copy", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg(al[ac], XmNacceleratorText,
X    	XmStringCreateLtoR("Ext+C", charset)); ac++;
X    XtSetArg(al[ac], XmNaccelerator, "Meta<Key>C:"); ac++;
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    copy_button = XmCreatePushButtonGadget (menu_pane, "Copy", al, ac);
X    XtAddCallback (copy_button, XmNactivateCallback, MenuCB, MENU_COPY);
X    XtManageChild (copy_button);
X    XtSetSensitive(copy_button, False);
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Paste", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg(al[ac], XmNacceleratorText,
X    	XmStringCreateLtoR("Ext+V", charset)); ac++;
X    XtSetArg(al[ac], XmNaccelerator, "Meta<Key>V:"); ac++;
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    paste_button = XmCreatePushButtonGadget (menu_pane, "Paste", al, ac); ac++;
X    XtAddCallback (paste_button, XmNactivateCallback, MenuCB, MENU_PASTE);
X    XtManageChild (paste_button);
X    XtSetSensitive(paste_button, False);
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Clear", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg(al[ac], XmNacceleratorText,
X    	XmStringCreateLtoR("Del", charset)); ac++;
X    /* don't need an accelerator - Text already handles
X    this action appropriately */
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    clear_button = XmCreatePushButtonGadget (menu_pane, "Clear", al, ac);
X    XtAddCallback (clear_button, XmNactivateCallback, MenuCB, MENU_CLEAR);
X    XtManageChild (clear_button);
X    XtSetSensitive(clear_button, False);
X    
X    ac = 0;
X    separator = XmCreateSeparator (menu_pane, "Sep", al, ac);
X    XtManageChild (separator);
X    
X    ac = 0;
X    XtSetArg (al[ac], XmNvisibleWhenOff, True);  ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    button = XmCreatePushButtonGadget (menu_pane, "Preferences", al, ac); ac++;
X    XtAddCallback (button, XmNactivateCallback, MenuCB, MENU_PREF);
X    XtManageChild (button);
X    
X    ac = 0;
X    XtSetArg (al[ac], XmNsubMenuId, menu_pane);  ac++;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Edit", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    cascade= XmCreateCascadeButton (menu_bar, "Edit", al, ac);
X    XtManageChild (cascade);
X    
X    
X    /****   Create "Search" PulldownMenu.   ****/
X    ac = 0;
X    menu_pane = XmCreatePulldownMenu (menu_bar, "searchmenu", al, ac);
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Find", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg(al[ac], XmNacceleratorText,
X    	XmStringCreateLtoR("Ext+F", charset)); ac++;
X    XtSetArg(al[ac], XmNaccelerator, "Meta<Key>F:"); ac++;
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    find_button = XmCreatePushButtonGadget (menu_pane, "Find", al, ac);
X    XtAddCallback (find_button, XmNactivateCallback, MenuCB, MENU_FIND);
X    XtManageChild (find_button);
X    XtSetSensitive(find_button, False);
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Find again", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg(al[ac], XmNacceleratorText,
X    	XmStringCreateLtoR("Ext+A", charset)); ac++;
X    XtSetArg(al[ac], XmNaccelerator, "Meta<Key>A:"); ac++;
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    findA_button = XmCreatePushButtonGadget (menu_pane, "FindA", al, ac);
X    XtAddCallback (findA_button, XmNactivateCallback, MenuCB, MENU_FINDA);
X    XtManageChild (findA_button);
X    XtSetSensitive(findA_button, False);
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Replace", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg(al[ac], XmNacceleratorText,
X    	XmStringCreateLtoR("Ext+R", charset)); ac++;
X    XtSetArg(al[ac], XmNaccelerator, "Meta<Key>R:"); ac++;
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    replace_button = XmCreatePushButtonGadget (menu_pane, "Replace", al, ac);
X    XtAddCallback (replace_button, XmNactivateCallback, MenuCB, MENU_REPLACE);
X    XtManageChild (replace_button);
X    XtSetSensitive(replace_button, False);
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Go to", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg(al[ac], XmNacceleratorText,
X    	XmStringCreateLtoR("Ext+G", charset)); ac++;
X    XtSetArg(al[ac], XmNaccelerator, "Meta<Key>G:"); ac++;
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    goto_button = XmCreatePushButtonGadget (menu_pane, "GoTo", al, ac);
X    XtAddCallback (goto_button, XmNactivateCallback, MenuCB, MENU_GOTO);
X    XtManageChild (goto_button);
X    XtSetSensitive(goto_button, False);
X    
X    ac = 0;
X    XtSetArg (al[ac], XmNsubMenuId, menu_pane);  ac++;
X    XtSetArg(al[ac], XmNlabelString,
X    	XmStringCreateLtoR("Search", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    cascade= XmCreateCascadeButton (menu_bar, "Search", al, ac);
X    XtManageChild (cascade);
X    
X    return (menu_bar);
X}
X
END_OF_FILE
if test 16225 -ne `wc -c <'xmemenu.c'`; then
    echo shar: \"'xmemenu.c'\" unpacked with wrong size!
fi
chmod +x 'xmemenu.c'
# end of 'xmemenu.c'
fi
if test -f 'xmespec.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xmespec.c'\"
else
echo shar: Extracting \"'xmespec.c'\" \(22644 characters\)
sed "s/^X//" >'xmespec.c' <<'END_OF_FILE'
X/**---------------------------------------------------------------------
X***     
X***	file:		xmespec.c
X***			Special dialogs and supporting routines.
X***
X***	project:	jetedit - Motif Widgets text editor
X***
X***-------------------------------------------------------------------*/
X
X#include "xme.h"
X#define FIND 1
X#define REPLACE 2
X
Xstatic Widget	Find_dialog;
Xstatic Widget	find_entry;
Xstatic Widget	replace_entry;
Xstatic Widget	start_at_top;
Xstatic Widget	find_case;
Xstatic Widget	regular_exp;
X
Xchar	*seg_string;
Xchar	*find_string;
X#define EXPSIZE 4096
X#define INIT register char *sp = find_string; 
X#define GETC() (*sp++)
X#define PEEKC() (*sp)
X#define UNGETC(c) (--sp)
X#define RETURN(c) return;
X#define ERROR(c) fprintf (stderr, "\7")
X#include <regexp.h>
X
X/* bits for exclamation point in dialog */
Xchar warningBits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00,
X   0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00,
X   0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00,
X   0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00,
X   0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00,
X   0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00,
X   0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x00,
X   0x00, 0xe0, 0x07, 0x00, 0x00, 0xf0, 0x0f, 0x00, 0x00, 0xf0, 0x0f, 0x00,
X   0x00, 0xf0, 0x0f, 0x00, 0x00, 0xf0, 0x0f, 0x00, 0x00, 0xe0, 0x07, 0x00,
X   0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00};
X
X/************************************************************************
X *
X *  CreateDefaultImage - create a default image for warning symbol.
X *
X **********************************<->***********************************/
XXImage *CreateDefaultImage (bits, width, height)
Xchar *bits;
Xint   width, height;
X{
X    XImage *image;
X
X    image = (XImage *) XtMalloc (sizeof (XImage));
X    image->width = width;
X    image->height = height;
X    image->data = bits;
X    image->depth = 1;
X    image->xoffset = 0;
X    image->format = XYBitmap;
X    image->byte_order = LSBFirst;
X    image->bitmap_unit = 8;
X    image->bitmap_bit_order = LSBFirst;
X    image->bitmap_pad = 8;
X    image->bytes_per_line = (width+7)/8;
X    return (image);
X}
X
X
X
X/*-------------------------------------------------------------
X**	CreateSpecialWarningDialog
X**		Create special 3 button message box out of a
X** 	Selection box.
X*/
XWidget CreateSpecialWarningDialog (parent, name, image_string, message,
X					arglist, argcount)
XWidget		parent;
XString		name;
XString		image_string;
XString		message;
XArg		arglist[];
XCardinal	argcount;
X{
X    Widget	warning_dialog;	/*  special warning selection box */
X    Widget	work_area;	/*  rowcolumn for pixmap and text */
X    Widget	pixmap_label;
X    Widget	text_label;
X    Widget	apply_button;
X    Widget	ok_button;
X    Widget	kid[5];		/*  buttons		*/
X    XmFontList	font_list;
X    Pixel	foreground;	/*  dialog foreground	*/
X    Pixel	background;	/*  dialog background	*/
X    Pixmap	pixmap;		/*  dialog pixmap	*/
X    register int	i;	/*  kid index		*/
X    Arg		al[10];
X    Cardinal	ac;
X
X    warning_dialog = XmCreatePromptDialog(parent, name, arglist, argcount);
X
X    /* Create work area for insertion of prompt. */
X    ac = 0;
X    XtSetArg(al[ac], XmNorientation, XmHORIZONTAL); ac++;
X    work_area = XmCreateRowColumn(warning_dialog, "workarea", al, ac);
X    XtManageChild(work_area);
X
X    ac = 0;
X    XtSetArg(al[ac], XmNforeground, &foreground); ac++;
X    XtSetArg(al[ac], XmNbackground, &background); ac++;
X    XtGetValues(warning_dialog, al, ac);
X
X    /* Create and insert prompt. */
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelType, XmPIXMAP); ac++;
X    pixmap = XmGetPixmap(XtScreen(warning_dialog), image_string,
X                     foreground, background);
X    XtSetArg(al[ac], XmNlabelPixmap, pixmap); ac++;
X    pixmap_label = XmCreateLabel(work_area, "pixmap_label", al, ac);
X    XtManageChild(pixmap_label);
X
X    /* Label for the prompt. */
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X         XmStringCreateLtoR(message, charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    text_label = XmCreateLabel(work_area, "text_label", al, ac);
X    XtManageChild(text_label);
X
X    /* Create discard button. */
X    ac = 0;
X    apply_button = XmSelectionBoxGetChild (warning_dialog,
X         XmDIALOG_APPLY_BUTTON);
X    XtSetArg(al[ac], XmNlabelString,
X         XmStringCreateLtoR("Discard", charset)); ac++;
X    XtSetValues(apply_button, al, ac);
X    XtManageChild(apply_button);
X
X    /* Change label on OK button. */
X    ac = 0;
X    ok_button = XmSelectionBoxGetChild (warning_dialog,
X         XmDIALOG_OK_BUTTON);
X    XtSetArg(al[ac], XmNlabelString,
X         XmStringCreateLtoR("Save", charset)); ac++;
X    XtSetValues(ok_button, al, ac);
X
X        
X    /*		Unmanage unneeded children.
X    */
X    i = 0;
X    kid[i++] = XmSelectionBoxGetChild (warning_dialog, XmDIALOG_TEXT);
X    kid[i++] = XmSelectionBoxGetChild (warning_dialog,
X         XmDIALOG_SELECTION_LABEL);
X    kid[i++] = XmSelectionBoxGetChild (warning_dialog, XmDIALOG_HELP_BUTTON);
X    XtUnmanageChildren (kid, i);
X
X    return(warning_dialog);
X}
X
X
X/*-------------------------------------------------------------
X**	strlwr
X**		Convert any upper case letters in string
X**		to lower case.
X*/
Xvoid strlwr (theString)
Xchar	*theString;
X{
X    int  i, j;
X    
X    j = strlen (theString);
X    for (i=0; i<j; i++)
X        if (theString[i] >= 'A' && theString[i] <= 'Z')
X            theString[i] += 'a' - 'A';
X}
X
X
X
X/*-------------------------------------------------------------
X**      ReplaceString
X**		The callback for the menu replace function.
X*/
Xvoid ReplaceString()
X{
X    Arg		al[1];
X    char	replaceString[MAXLENGTH];
X    char	*aString;
X    char	*selString;
X    char	*file_string;		/* Contents of file.    */
X    XmTextPosition cursorPos;
X
X    /* Get the Replace string */
X    aString = &replaceString[0];
X    XtSetArg (al[0], XmNvalue, &aString);
X    XtGetValues (replace_entry, al, 1);
X    
X    if (selString = XmTextGetSelection(text)) {
X        file_string = XmTextGetString(text);
X        XtSetArg (al[0], XmNcursorPosition, &cursorPos);
X        XtGetValues (text, al, 1);
X        if (!strncmp (selString, file_string+cursorPos, strlen(selString))) {
X            XmTextReplace (text, cursorPos, cursorPos + strlen(selString), "");
X            XmTextReplace (text, cursorPos, cursorPos, aString);
X        }
X        else {
X            XmTextReplace (text, cursorPos, cursorPos, aString);
X            XmTextReplace (text, cursorPos - strlen(selString), cursorPos, "");
X        }
X        XtFree (selString);
X        XtFree (file_string);
X    }
X}
X
X
X/*-------------------------------------------------------------
X**      FindString
X**		The use of regular expressions was contributed by:
X**		jec@milne.boeing.com (Jim Campbell)
X*/
XBoolean FindString(thetime)
XTime thetime;
X{
X    char	*file_string;		/* Contents of file.    */
X    char	*found;
X    char	buffer[30];
X    XmTextPosition cursorPos;
X    XmTextPosition end_cursorPos;
X    Arg		al[1];
X    Boolean	ignore_case;
X    Boolean	reg_exp;
X    char expbuf [EXPSIZE];
X
X    if (!the_string) {
X        fprintf (stderr, "\7");	/* Beep */
X        XmTextClearSelection(text, thetime);
X        return (False);
X    }
X        
X    /* get the text string */
X    file_string = XmTextGetString(text);
X    XtSetArg (al[0], XmNcursorPosition, &cursorPos);
X    XtGetValues (text, al, 1);
X    seg_string = (char *)((long)file_string + (long)cursorPos);
X    find_string = XtMalloc (strlen(the_string) + 1);
X    strcpy (find_string, the_string);
X    
X    XtSetArg (al[0], XmNset, &ignore_case);
X    XtGetValues (find_case, al, 1);
X    if (ignore_case) {
X        strlwr (seg_string);
X        strlwr (find_string);
X    }
X        
X    XtSetArg (al[0], XmNset, &reg_exp);
X    XtGetValues (regular_exp, al, 1);
X    if (reg_exp) {
X        compile (find_string, expbuf, &expbuf[EXPSIZE], '\0'); 	
X        if (step (seg_string, expbuf)) {
X            cursorPos = (XmTextPosition)((long)loc1 + (long)cursorPos - (long)seg_string); 
X            end_cursorPos = (XmTextPosition)((long)cursorPos + (long)loc2 - (long)loc1); 
X            XmTextSetSelection(text, cursorPos, end_cursorPos, thetime); 
X            MoveTo(end_cursorPos);
X            XtFree (file_string);
X            XtFree (find_string);
X            return (True);
X        }
X        else {
X            fprintf (stderr, "\7");	/* Beep */
X            XmTextClearSelection(text, thetime);
X            XtFree (file_string);
X            XtFree (find_string);
X            return (False);
X        }
X    }
X    else {
X        if ((found = strstr (seg_string, find_string)) != NULL) {
X            cursorPos = (XmTextPosition)((long)found + (long)cursorPos - (long)seg_string);
X            end_cursorPos = (XmTextPosition)((long)cursorPos + strlen(the_string));
X            XmTextSetSelection(text, cursorPos, end_cursorPos, thetime);
X            MoveTo(end_cursorPos);
X            XtFree (file_string);
X            XtFree (find_string);
X            return (True);
X        }
X        else {
X            fprintf (stderr, "\7");	/* Beep */
X            XmTextClearSelection(text, thetime);
X            XtFree (file_string);
X            XtFree (find_string);
X            return (False);
X        }
X    }
X}
X
X
X/*-------------------------------------------------------------
X**	FindCB
X*/
Xvoid FindCB (w, client_data, call_data) 
XWidget 		w;		/*  widget id           */
Xcaddr_t		client_data;	/*  data from application   */
Xcaddr_t		call_data;	/*  data from widget class  */
X{
X    Arg		al[1];
X    Boolean	startAtTop;
X
X    XmAnyCallbackStruct *cb = (XmAnyCallbackStruct *) call_data;
X    
X    XtSetArg (al[0], XmNvalue, &the_string);
X    XtGetValues (find_entry, al, 1);
X    
X    /* Get Start at beginning of file indicator */
X    XtSetArg (al[0], XmNset, &startAtTop);
X    XtGetValues (start_at_top, al, 1);
X    if (startAtTop) {
X        MoveTo((XmTextPosition)0);
X        XtSetArg (al[0], XmNset, False);
X        XtSetValues (start_at_top, al, 1);
X    }
X    
X    FindString (cb->event->xbutton.time);
X    XtSetSensitive (findA_button, True);
X    XtSetSensitive (replace_button, True);
X    XtSetSensitive (replace_pb, True);
X    XtSetSensitive (replaceAll_pb, True);
X}
X
X
X/*-------------------------------------------------------------
X**	ReplaceCB
X*/
Xvoid ReplaceCB (w, client_data, call_data) 
XWidget 		w;		/*  widget id           */
Xcaddr_t		client_data;	/*  data from application   */
Xcaddr_t		call_data;	/*  data from widget class  */
X{
X    Arg		al[1];
X    char	replaceString[MAXLENGTH];
X    char	*aString;
X    XmTextPosition cursorPos;		/* text cursor position */
X    XmTextPosition cursorBack;
X    Boolean	startAtTop;
X    Time	thetime;
X    
X    XmAnyCallbackStruct *cb = (XmAnyCallbackStruct *) call_data;
X    thetime = cb->event->xbutton.time;
X    
X    ReplaceString();
X    FindString(thetime+2);
X}
X
X/*-------------------------------------------------------------
X**	ReplaceAllCB
X*/
Xvoid ReplaceAllCB (w, client_data, call_data) 
XWidget 		w;		/*  widget id           */
Xcaddr_t		client_data;	/*  data from application   */
Xcaddr_t		call_data;	/*  data from widget class  */
X{
X    Arg		al[1];
X    char	replaceString[MAXLENGTH];
X    char	*aString;
X    XmTextPosition cursorPos;		/* text cursor position */
X    XmTextPosition cursorBack;
X    Boolean	startAtTop;
X    Time	thetime;
X    
X    XmAnyCallbackStruct *cb = (XmAnyCallbackStruct *) call_data;
X    thetime = cb->event->xbutton.time;
X    
X    /* Get the Find string */
X    XtSetArg (al[0], XmNvalue, &the_string);
X    XtGetValues (find_entry, al, 1);
X    cursorBack = strlen (the_string);
X    /* Get the Replace string */
X    aString = &replaceString[0];
X    XtSetArg (al[0], XmNvalue, &aString);
X    XtGetValues (replace_entry, al, 1);
X    /* Get Start at beginning of file indicator */
X    XtSetArg (al[0], XmNset, &startAtTop);
X    XtGetValues (start_at_top, al, 1);
X    
X    XtSetSensitive (findA_button, True);
X    if (startAtTop) {
X        MoveTo((XmTextPosition)0);
X        XtSetArg (al[0], XmNset, False);
X        XtSetValues (start_at_top, al, 1);
X    }
X    
X    while (FindString(thetime++)) {
X        XtSetArg (al[0], XmNcursorPosition, &cursorPos);
X        XtGetValues (text, al, 1);
X        XmTextReplace (text, cursorPos-cursorBack, cursorPos, aString);
X    }
X}
X
X/*-------------------------------------------------------------
X**	ExitCB
X*/
Xvoid ExitCB (w, client_data, call_data) 
XWidget 		w;		/*  widget id           */
Xcaddr_t		client_data;	/*  data from application   */
Xcaddr_t		call_data;	/*  data from widget class  */
X{
X    XtUnmanageChild (Find_dialog);
X}
X
X
X/*-------------------------------------------------------------
X**	FindHelpCB
X*/
Xvoid FindHelpCB (w, client_data, call_data) 
XWidget 		w;		/*  widget id           */
Xcaddr_t		client_data;	/*  data from application   */
Xcaddr_t		call_data;	/*  data from widget class  */
X{
X    XtManageChild (find_help_dialog);
X}
X
X
X/*--------------------------------------------------------------
X**	Translation table for the find dialog's text widgets.
X*/
Xstatic char defaultTranslations[] =
X    "Meta<Key>X:	CutItem()	\n\
X    Meta<Key>C:		CopyItem()	\n\
X    Meta<Key>V:		PasteItem()";
X
X/*-------------------------------------------------------------
X**	CreateSpecialFindDialog
X**		Create find & replace message box out of a
X** 	Dialog Shell.
X*/
XWidget CreateSpecialFindDialog (parent, dialog_name, arglist, argcount)
XWidget		parent;
XString		dialog_name;
XArg		arglist[];
XCardinal	argcount;
X{
X    Widget	work_area;
X    Widget	help_area;
X    Widget	button;
X    Widget	separator;
X    Widget	label;
X    Widget	kid[5];
X    int		i;
X    Arg		al[15];
X    Cardinal	ac;
X    XmFontList	font_list;
X    Dimension	button_width;
X    XtTranslations trans_table;
X    
X    trans_table = XtParseTranslationTable(defaultTranslations);
X    
X    Find_dialog = XmCreatePromptDialog(parent, dialog_name, arglist, argcount);
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNtextFontList, &font_list); ac++;
X    XtGetValues(Find_dialog, al, ac);
X    
X    /* Create work area. */
X    ac=0;
X    work_area = XmCreateRowColumn(Find_dialog, "workarea", al, ac);
X    XtManageChild(work_area);
X    
X    /* Label for the "Find Text". */
X    ac = 0;
X    XtSetArg(al[ac], XmNmarginWidth, 0); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    label = XmCreateLabel(work_area, "Find Text:", al, ac);
X    XtManageChild(label);
X
X    /* Create "Find Text" box. */
X    ac = 0;
X    XtSetArg(al[ac], XmNmaxLength, MAXLENGTH); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    find_entry = XmCreateText(work_area, "find_entry", al, ac);
X    XtManageChild(find_entry);
X    XtOverrideTranslations (find_entry, trans_table);
X
X    /* Label for the "Replace With". */
X    ac = 0;
X    XtSetArg(al[ac], XmNmarginWidth, 0); ac++;
X    XtSetArg(al[ac], XmNalignment, XmALIGNMENT_BEGINNING); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    label = XmCreateLabel(work_area, "Replace With:", al, ac);
X    XtManageChild(label);
X
X    /* Create "Replace With" box. */
X    ac = 0;
X    XtSetArg(al[ac], XmNmaxLength, MAXLENGTH); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    replace_entry = XmCreateText(work_area, "replace_entry", al, ac);
X    XtManageChild(replace_entry);
X    XtOverrideTranslations (replace_entry, trans_table);
X
X    /* Create "Ignore Case" button. */
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X         XmStringCreateLtoR("Ignore text case", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    find_case = XmCreateToggleButtonGadget(work_area, "find_case", al, ac);
X    XtManageChild(find_case);
X
X    /* Create "Start at top of file" button. */
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X         XmStringCreateLtoR("Start at top of file", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    start_at_top = XmCreateToggleButtonGadget(work_area, "start_at_top", al, ac);
X    XtManageChild(start_at_top);
X
X    /* Create "Use Regular Expressions" button. */
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X         XmStringCreateLtoR("Use regular expressions", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    regular_exp = XmCreateToggleButtonGadget(work_area, "regular_exp", al, ac);
X    XtManageChild(regular_exp);
X
X    /*** Put a separator and help message below the work area ***/
X    ac = 0;
X    separator = XmCreateSeparator(work_area, "separator", al, ac);
X    XtManageChild(separator);
X    
X    ac = 0;
X    XtSetArg (al[ac], XmNorientation, XmHORIZONTAL);  ac++;
X    help_area = XmCreateRowColumn(work_area, "help_area", al, ac);
X    XtManageChild(help_area);
X    
X    ac = 0;
X    XtSetArg(al[ac], XmNlabelString,
X         XmStringCreateLtoR("Help", charset)); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    button = XmCreatePushButtonGadget(help_area, "Help", al, ac);
X    XtManageChild(button);
X    
X    ac = 0;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    label = XmCreateLabelGadget (help_area, 
X        "Press HELP for a quick reference to regular expressions.", al, ac);
X    XtManageChild (label);
X    
X    /* Relabel OK button */
X    ac = 0;
X    XtSetArg(al[ac], XmNokLabelString,
X         XmStringCreateLtoR("Find", charset)); ac++;
X    XtSetValues(Find_dialog, al, ac);
X
X    /* Create Replace button. */
X    ac = 0;
X    XtSetArg(al[ac], XmNapplyLabelString,
X         XmStringCreateLtoR("Replace", charset)); ac++;
X    XtSetValues(Find_dialog, al, ac);
X    replace_pb = XmSelectionBoxGetChild (Find_dialog, XmDIALOG_APPLY_BUTTON);
X    XtManageChild(replace_pb);
X    XtSetSensitive(replace_pb, False);
X
X    /* Relabel Cancel button */
X    ac = 0;
X    XtSetArg(al[ac], XmNcancelLabelString,
X         XmStringCreateLtoR("Replace All", charset)); ac++;
X    XtSetValues(Find_dialog, al, ac);
X    replaceAll_pb = XmSelectionBoxGetChild (Find_dialog, XmDIALOG_CANCEL_BUTTON);
X    XtSetSensitive(replaceAll_pb, False);
X
X    /* Relabel Help button */
X    ac = 0;
X    XtSetArg(al[ac], XmNhelpLabelString,
X         XmStringCreateLtoR("Done", charset)); ac++;
X    XtSetValues(Find_dialog, al, ac);
X
X    XtAddCallback (button, XmNactivateCallback, FindHelpCB, NULL);
X    XtAddCallback (Find_dialog, XmNokCallback, FindCB, NULL);
X    XtAddCallback (Find_dialog, XmNapplyCallback, ReplaceCB, NULL);
X    XtAddCallback (Find_dialog, XmNcancelCallback, ReplaceAllCB, NULL);
X    XtAddCallback (Find_dialog, XmNhelpCallback, ExitCB, NULL); 
X    
X    /*	Unmanage unneeded children. */
X    i = 0;
X    kid[i++] = XmSelectionBoxGetChild (Find_dialog, XmDIALOG_TEXT);
X    kid[i++] = XmSelectionBoxGetChild (Find_dialog, XmDIALOG_SELECTION_LABEL);
X    XtUnmanageChildren (kid, i);
X
X    XmAddTabGroup(find_entry);
X    XmAddTabGroup(replace_entry);
X    XmAddTabGroup(find_case);
X    XmAddTabGroup(start_at_top);
X    XmAddTabGroup(regular_exp);
X    XmAddTabGroup(button);
X    XmAddTabGroup(Find_dialog);
X    return(Find_dialog);
X}
X
X        
X
X/*-------------------------------------------------------------
X**	CreateSpecialHelpDialog
X*/
XWidget CreateSpecialHelpDialog (parent, help_txt, dialog_name, arglist, argcount)
XWidget		parent;
XWidget		*help_txt;
XString		dialog_name;
XArg		arglist[];
XCardinal	argcount;
X{
X    Widget	the_dialog;
X    Widget	text_window;
X    Widget	butt_sep;
X    Widget	button_area;
X    Widget	helpok_button;
X    Arg		al[15];
X    Cardinal	ac;
X    int		file_length;	/* Length of file.        */
X    char	*file_string;	/* Contents of file.      */
X    int		tfd;		/* Temporary file descriptor */
X    struct stat statbuf;	/* Information on a file. */
X    XmFontList	font_list;
X    
X    the_dialog = XmCreateFormDialog(parent, dialog_name, arglist, argcount);
X
X    ac = 0;
X    XtSetArg(al[ac], XmNtextFontList, &font_list); ac++;
X    XtGetValues(the_dialog, al, ac);
X
X    ac = 0;
X    XtSetArg(al[ac], XmNmarginWidth, 0); ac++;
X    XtSetArg(al[ac], XmNmarginHeight, 0); ac++;
X    XtSetArg(al[ac], XmNheight, 400); ac++;
X    XtSetArg(al[ac], XmNwidth, 400); ac++;
X    XtSetArg(al[ac], XmNresizePolicy, XmRESIZE_GROW); ac++;
X    XtSetArg(al[ac], XmNdialogTitle,
X         XmStringCreateLtoR(dialog_name, charset)); ac++;
X    XtSetValues (the_dialog, al, ac);
X
X    /* Create Help Ok button. */
X    ac = 0;
X    XtSetArg(al[ac], XmNbottomOffset, 10); ac++;
X    XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
X    XtSetArg(al[ac], XmNleftOffset, 15); ac++;
X    XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_FORM); ac++;
X    XtSetArg(al[ac], XmNshowAsDefault, 1); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    helpok_button = XmCreatePushButtonGadget (the_dialog, "OK",al, ac);
X    XtManageChild(helpok_button);
X
X    /* Create seperator above button. */
X    ac = 0;
X    XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
X    XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
X    XtSetArg(al[ac], XmNbottomWidget, (XtArgVal)helpok_button); ac++;
X    XtSetArg(al[ac], XmNbottomOffset, 10); ac++;
X    XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_WIDGET); ac++;
X    butt_sep = XmCreateSeparator(the_dialog, "butt_sep", al, ac);
X    XtManageChild(butt_sep);
X
X    /* Create "Help Text" box. */
X    ac = 0;
X    XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
X    XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
X    XtSetArg(al[ac], XmNtopAttachment, XmATTACH_FORM); ac++;
X    XtSetArg(al[ac], XmNbottomWidget, (XtArgVal)butt_sep); ac++;
X    XtSetArg(al[ac], XmNbottomOffset, 10); ac++;
X    XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_WIDGET); ac++;
X    XtSetArg(al[ac], XmNeditMode, XmMULTI_LINE_EDIT); ac++;
X    XtSetArg(al[ac], XmNeditable, False); ac++;
X    XtSetArg(al[ac], XmNscrollHorizontal, False); ac++;
X    XtSetArg(al[ac], XmNwordWrap, True); ac++;
X#ifdef HARDCODE
X    XtSetArg (al[ac], XmNfontList, fontlist);  ac++;
X#endif
X    *help_txt = XmCreateScrolledText(the_dialog, "help_text", al, ac);
X    XtManageChild(*help_txt);
X    
X    text_window = XtParent (*help_txt);
X    ac = 0;
X    XtSetArg(al[ac], XmNleftAttachment, XmATTACH_FORM); ac++;
X    XtSetArg(al[ac], XmNrightAttachment, XmATTACH_FORM); ac++;
X    XtSetArg(al[ac], XmNbottomWidget, (XtArgVal)butt_sep); ac++;
X    XtSetArg(al[ac], XmNbottomAttachment, XmATTACH_WIDGET); ac++;
X    XtSetValues (text_window, al, ac);
X    
X    return (the_dialog);
X}
X
X
END_OF_FILE
if test 22644 -ne `wc -c <'xmespec.c'`; then
    echo shar: \"'xmespec.c'\" unpacked with wrong size!
fi
chmod +x 'xmespec.c'
# end of 'xmespec.c'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM            | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly!      |
 "It's intuitively obvious to the most |    sources-x@imd.sterling.com
  casual observer..."                  |
