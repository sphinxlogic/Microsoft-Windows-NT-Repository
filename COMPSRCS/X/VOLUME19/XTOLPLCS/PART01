Newsgroups: comp.sources.x
From: adam@iset.scan.mc.xerox.com (Adam Stein)
Subject: v19i075:  Xtoolplaces - save current X desktop window information, Part01/03
Message-ID: <csx-v19i075=Xtoolplaces.093059@sparky.IMD.Sterling.COM>
X-Md4-Signature: ee6cdb13b3ce79f2936f441d464109f3
Date: Tue, 6 Apr 1993 14:34:34 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: adam@iset.scan.mc.xerox.com (Adam Stein)
Posting-number: Volume 19, Issue 75
Archive-name: Xtoolplaces/part01
Environment: X11, !mwm, !tvtwm
Supersedes: Xtoolplaces: Volume 14, Issue 2-3

This is from the README file for xtoolplaces:

  This program will collect state information from any windows
  currently running on an X desktop.  This information can then
  be used to start X to return to the current desktop state.  This
  is the X equivalent of Sunview's toolplaces program.

-------------
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  README Imakefile getargs.c getinfo.c is.c missing.c
# Wrapped by chris@sparky on Tue Apr  6 09:15:54 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 3)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(4615 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
XThis is the README file for xtoolplaces.
X
XAuthor:
X
X  Adam Stein (adam@iset.scan.mc.xerox.com)
X
XCopyright:
X
X  Copyright (c) 1993 Xerox Corporation.  All Rights Reserved.
X
X  Permission to use,  copy,  modify  and  distribute  without
X  charge this software, documentation, images, etc. is grant-
X  ed, provided that this copyright and the author's  name  is
X  retained.
X
X  A fee may be charged for this program ONLY to recover costs
X  for distribution (i.e. media costs).  No profit can be made
X  on this program.
X
X  The author assumes no responsibility for disasters (natural
X  or otherwise) as a consequence of use of this software.
X
XDescription:
X
X  This program will collect state information from any windows
X  currently running on an X desktop.  This information can then
X  be used to start X to return to the current desktop state.  This
X  is the X equivalent of Sunview's toolplaces program.
X
X  Xtoolplaces is currently at v1.3 patchlevel 3.  Don't worry if
X  you never saw patchlevel 1, it never made it out.
X
X  This will most likely be the last release unless something major
X  is wrong.
X
XInstallation:
X
X  This program has only been compiled and tested on BSD or BSD/SYS5
X  mixed systems.  I have no idea what would have to be changed for
X  a SYS5 only system (probably only index to strchr and that sort of
X  stuff).
X  
X  This program can be compiled with gcc.  Commented out gcc lines have
X  been added to Imakefile and Makefile.simple.  To use gcc instead of
X  cc, comment/uncomment the appropriate lines in whichever dependency
X  file you plan using for compiling.
X
X  To compile using imake use:
X
X		imake
X
X  and to install the program and man page use
X
X		imake install install.man
X
X  To compile using make instead, use:
X
X		make -f Makefile.simple
X
X  and to install the program and man page use
X
X		make -f Makefile.simple install
X
X
XMethodology:
X
X  This program works by following these steps:
X
X  I.   Change cursor to a watch, grab the pointer so that the
X       user can't change anything during execution, and ring
X       the bell once to let the user know the program has started.
X
X  II.  Loop through each screen to save from:
X
X       a. Loop through each window in the tree to:
X
X          1. See if it's a window worth saving.  It has to meet
X	     four conditions:
X
X	     a. it has WM_NAME set (so we know it's not a pop-up, etc)
X
X	     b. it's a group leader or assume it's ok if group leader
X	        isn't set
X
X	     c. it's parent is the root window
X
X	     d. it has a WM_COMMAND property to save, is a console
X		window or is on a list specified with the '-m' option
X
X          2. Tell window to update it's current state if it knows
X	     about the WM_SAVE_YOURSELF message.
X  
X          3. See if it either:  has a state to save (WM_COMMAND);
X	     is a console window or is on the missing applications
X	     list (-m option)
X
X	  4. If window doesn't know how to save itself (doesn't
X	     understand WM_SAVE_YOURSELF), extract geometry
X	     information manually.
X
X          5. If console checking is enabled (-c), check to see if
X	     window is a console and write 'if ... fi' clause to
X	     only have it start up if X is starting on /dev/console.
X
X          6. Check to see if window is a remote application and
X	     put the appropriate remote command (default 'rsh -n') to
X	     start application.
X
X          7. Save current window state.
X
X          8. If add arguments is enabled (-a), check to see if this
X	     window applications has any arguments to add to it's
X	     command line.
X
X  III. Release pointer (which changes the cursor back to normal) and ring
X       the bell twice to let the user know that the program is finished.
X
XBugs/Additions:
X
X  I would appreciate knowing about any bugs either found or
X  fixed and any enhancements made.  I would like to keep a
X  centralized version with the upgrades so that there aren't
X  50 million versions posted to the net.  I can't make any
X  guarantees to when bug fixes would be made (if any are
X  found :-{), but I'll do my best.
X
X  I hope this program is of use to you, either in it's capacity or as simple
X  example in X programming.
X
X  It is known that xtoolplaces won't work with the Motif window manager (mwm)
X  or the virtual version of TWM (tvtwm).  Neither of these window managers
X  seem to return the queried information correctly.
X
XAcknowledgements:
X
X  For v1.0
X  --------
X  I would like to thank my original beta testers, Donn Morrill and
X  Bill Fuss for helping to make sure the first version of this  program
X  worked and keeping me honest.
X
X  For v1.1 Beta -> present
X  --------------------------
X  See CHANGES file.
END_OF_FILE
  if test 4615 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
  echo shar: Extracting \"'Imakefile'\" \(1397 characters\)
  sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
X# Copyright (c) 1993 Xerox Corporation.  All Rights Reserved.
X#
X# Permission to use,  copy,  modify  and  distribute  without
X# charge this software, documentation, images, etc. is grant-
X# ed, provided that this copyright and the author's  name  is
X# retained.
X#
X# A fee may be charged for this program ONLY to recover costs
X# for distribution (i.e. media costs).  No profit can be made
X# on this program.
X#
X# The author assumes no responsibility for disasters (natural
X# or otherwise) as a consequence of use of this software.
X#
X# Adam Stein (adam@iset.scan.mc.xerox.com)
X
X# Name of program to build
XTARGET=xtoolplaces
X
X# Name of resource file
XRESOURCE=Xtoolplaces
X
X#Uncomment the next 2 lines if using gcc
X#EXTRA_DEFINES=-traditional -fpcc-struct-return -c -O
X#CC=gcc
X
XINCS=addon.h patchlevel.h xtoolplaces.h
XSRCS=copyright.c adddisplay.c addon.c combine.c fix_command.c\
X     getargs.c getgeom.c getinfo.c is.c make_list.c missing.c\
X     strdup.c strstr.c xtoolplaces.c
XOBJS=copyright.o adddisplay.o addon.o combine.o fix_command.o\
X     getargs.o getgeom.o getinfo.o is.o make_list.o missing.o\
X     strdup.o strstr.o xtoolplaces.o
X
XLOCAL_LIBRARIES = ${XLIB}
X
XComplexProgramTarget(${TARGET})
X
XInstallAppDefaults(${RESOURCE})
X
Xshar:
X	shar -c -o ${TARGET} -l50 README CHANGES MANIFEST Imakefile \
X	Makefile.simple ${RESOURCE}.ad xtoolplaces.man ${SRCS} ${INCS} \
X	addon.sample missing.sample
X
END_OF_FILE
  if test 1397 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
  fi
  # end of 'Imakefile'
fi
if test -f 'getargs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getargs.c'\"
else
  echo shar: Extracting \"'getargs.c'\" \(13930 characters\)
  sed "s/^X//" >'getargs.c' <<'END_OF_FILE'
X/*Copyright (c) 1993 Xerox Corporation.  All Rights Reserved.
X
X  Permission to use,  copy,  modify  and  distribute  without
X  charge this software, documentation, images, etc. is grant-
X  ed, provided that this copyright and the author's  name  is
X  retained.
X
X  A fee may be charged for this program ONLY to recover costs
X  for distribution (i.e. media costs).  No profit can be made
X  on this program.
X
X  The author assumes no responsibility for disasters (natural
X  or otherwise) as a consequence of use of this software.
X
X  Adam Stein (adam@iset.scan.mc.xerox.com)
X*/
X
X#include <stdio.h>
X#include <pwd.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xresource.h>
X#include "xtoolplaces.h"
X#include "patchlevel.h"
X
Xint num_op_entries = 8;			/*Number of entries in OP table*/
Xchar use_display[256];			/*Display to use*/
XXrmDatabase cmmd_line_db;		/*Command line arguments*/
XXrmDatabase database;			/*Database containing ALL resources*/
XXrmOptionDescRec op_table[] = {		/*Argument operation resource table*/
X		{"-a", ".addon",     XrmoptionSepArg, (caddr_t) NULL},
X		{"-c", ".console",   XrmoptionIsArg,  (caddr_t) NULL},
X		{"-d", ".display",   XrmoptionSepArg, (caddr_t) NULL},
X		{"-f", ".saveto",    XrmoptionSepArg, (caddr_t) NULL},
X		{"-m", ".missing",   XrmoptionSepArg, (caddr_t) NULL},
X		{"-r", ".remote",    XrmoptionSepArg, (caddr_t) NULL},
X		{"-s", ".screens",   XrmoptionSepArg, (caddr_t) NULL},
X		{"-v", ".version",   XrmoptionIsArg,  (caddr_t) NULL}
X};
Xextern char *program;
Xextern Display *display;
Xchar *malloc(),*strdup(),*getenv();
X
X/*This function will gather all the arguments for this program, either through
X  the command line or from resource databases.  The order for overriding options
X  is as follows:
X
X	1) Hardcoded defaults
X	2) Values in /usr/lib/X11/app-defaults/Xtoolplaces
X	3) Values in $XUSERFILESEARCHPATH/Xtoolplaces or
X	   $XAPPLRESDIR/Xtoolplaces
X	4) Values set using xrdb, either through the
X	   XResourceMangerString macro or, if that's empty, the
X	   .Xdefaults file in the user's home directory
X	5) Values in the file specified by the XENVIRONMENT
X	   environment variable or, if that's not set, the
X	   .Xdefaults-hostname file in the user's home directory
X	   (where hostname is the name of the machine)
X	6) Command line arguments
X
X  Each order overrides anything before it (i.e. command line arguments override
X  everything, while /usr/lib/X11/app-defaults/Xtoolplaces only override
X  hardcoded defaults).
X
X  Inputs:  argc - number of command line arguments
X	   argv - command line arguments
X  Outputs: none
X  Locals:  none
X  Globals: none
X*/
Xgetargs(argc,argv)
Xint argc;
Xregister char *argv[];
X{
X	/*Initialize resource manager*/
X	XrmInitialize();
X
X	/*Parse command line first so we can open the display*/
X	parse_cmmd_args(&argc,argv);
X
X	/*Get server defaults, program defaults, .Xdefaults,
X	  command line, etc. and merge them*/
X	merge_databases();
X
X	/*Extract values from database for use*/
X	extract_options();
X}
X
X/*This function will parse the command line options to get a display (-d)
X  option if one is given.  It will also check for the '-v' option and act
X  on it if it's given.
X
X  Inputs:  argc           - number of command line arguments
X	   argv           - command line arguments
X  Outputs: none
X  Locals:  resource       - name of resource to find
X	   str_type       - representation type (ignored)
X	   value          - value in the database
X  Globals: display        - interface info to X display
X	   cmmd_line_db   - command line arguments in database form
X	   num_op_entries - number of entries in the OP table
X	   op_table       - argument operation resource table
X	   program        - name of currently executing program
X	   stderr         - standard error
X	   use_display    - display to use
X	   PATCHLEVEL     - current program patchlevel
X	   NULL		  - 0
X	   USAGE	  - usage line
X	   VERSION	  - current program version
X*/
Xparse_cmmd_args(argc,argv)
Xregister int *argc;
Xregister char *argv[];
X{
X	register char *str_type[20],*resource;
X	XrmValue value;
X
X	/*Allocate space for the names of the 2 resources we'll be looking
X	  for (the display and version resources)*/
X	if((resource = malloc(strlen(program)+9)) == NULL) {
X	  perror(program);
X	  exit(1);
X	}
X
X	use_display[0] = '\0';
X
X	/*Put command line arguments into database form*/
X	XrmParseCommand(&cmmd_line_db,op_table,num_op_entries,argv[0],
X			argc,argv);
X
X	/*Usage error if any arguments left*/
X	if(*argc != 1) {
X	  fprintf(stderr,"usage: %s %s\n",program,USAGE);
X	  exit(1);
X	}
X
X	/*If the -v option is given, just print the version and quit*/
X	sprintf(resource,"%s.version",program);
X	if(XrmGetResource(cmmd_line_db,resource,"xtoolplaces.display",
X	   str_type,&value) == True) {
X	  fprintf(stderr,"%s: version %s, patchlevel %s\n",program,VERSION,
X		  PATCHLEVEL);
X	  exit(0);
X	}
X
X	/*Get display now because we need it to get other databases*/
X	sprintf(resource,"%s.display",program);
X	if(XrmGetResource(cmmd_line_db,resource,"xtoolplaces.display",
X	   str_type,&value) == True)
X	  strcpy(use_display,value.addr);
X
X	/*Open a connection to the X server*/
X	if(!(display = XOpenDisplay(use_display))) {
X	  fprintf(stderr,"%s: can't open display (%s)\n",program,
X		  XDisplayName(use_display));
X	  exit(1);
X	}
X
X	free(resource);
X}
X
X/*This function will get resources from all the standard X resource
X  places in the standard X order of looking and merge them into one
X  database.  Resources are read in and merged into the global database
X  according to the following order:
X
X	1) Values in /usr/lib/X11/app-defaults/Xtoolplaces
X	2) Values in $XUSERFILESEARCHPATH/Xtoolplaces or
X	   $XAPPLRESDIR/Xtoolplaces
X	3) Values set using xrdb, either through the
X	   XResourceMangerString macro or, if that's empty, the
X	   .Xdefaults file in the user's home directory
X	4) Values in the file specified by the XENVIRONMENT
X	   environment variable or, if that's not set, the
X	   .Xdefaults-hostname file in the user's home directory
X	   (where hostname is the name of the machine)
X	5) Command line arguments
X
X  Inputs:  none
X  Outputs: none
X  Locals:  db		- database of read in resource file
X	   db_file	- name of resource file to read in
X	   env_var	- environment variable value
X	   home		- user's home directory
X  Globals: cmmd_line_db - command line arguments in database form
X	   database	- database containing ALL resources for this application
X	   display	- interface info to X display
X	   program	- name of currently executing program
X	   stderr	- standard error
X	   APPSDIR      - default resource directory
X	   APPSFILENAME - class name of this application
X	   NULL		- 0
X*/
Xmerge_databases()
X{
X	register char db_file[1024],*env_var,*home;
X	register XrmDatabase db;
X	char *gethomedir();
X
X	/*Get application defaults file, if any*/
X	sprintf(db_file,"%s/%s",APPSDIR,APPSFILENAME);
X	db = XrmGetFileDatabase(db_file);
X	XrmMergeDatabases(db,&database);
X
X	/*Merge $XUSERFILESEARCHPATH/Xtoolplaces, if XUSERFILESEARCHPATH
X	  is defined; otherwise merge $XAPPLRESDIR/Xtoolplaces if it's
X	  defined*/
X	if((env_var = getenv("XUSERFILESEARCHPATH")) == NULL)
X	  env_var = getenv("XAPPLRESDIR");
X	if(env_var) {
X	  sprintf(db_file,"%s/%s",env_var,APPSFILENAME);
X	  db = XrmGetFileDatabase(db_file);
X	  XrmMergeDatabases(db,&database);
X	}
X
X	/*Merge server defaults (these are created by xrdb).  If not
X	  defined, use ~/.Xdefaults*/
X	if(XResourceManagerString(display) != NULL)
X	  db = XrmGetStringDatabase(XResourceManagerString(display));
X	else {
X	       /*Open .Xdefaults file and merge into existing database*/
X	       if((home = gethomedir()) == NULL) {
X		 fprintf(stderr,"%s: can't find home directory\n",program);
X		 exit(1);
X	       }
X	       sprintf(db_file,"%s/.Xdefaults",home);
X
X	       db = XrmGetFileDatabase(db_file);
X	     }
X	XrmMergeDatabases(db,&database);
X
X	/*Open XENVIRONMENT file if defined or the ~/.Xdefaults-hostname file
X	  if not*/
X	if((env_var = getenv("XENVIRONMENT")) == NULL) {
X	  if((home = gethomedir()) == NULL) {
X	    fprintf(stderr,"%s: can't find home directory\n",program);
X	    exit(1);
X	  }
X	  sprintf(db_file,"%s/.Xdefaults-",home);
X	  gethostname(&db_file[strlen(db_file)],1024-strlen(db_file));
X	} else strcpy(db_file,env_var);
X	db = XrmGetFileDatabase(db_file);
X	XrmMergeDatabases(db,&database);
X
X	/*Command line overrides everything, merge that in last*/
X	XrmMergeDatabases(cmmd_line_db,&database);
X}
X
X/*This function will extract the options out of the database.
X
X  Inputs:  none
X  Outputs: none
X  Locals:  filename	    - name of file to write window info to
X	   resource	    - name of resource to find
X	   str_type	    - representation type (ignored)
X	   value	    - value in the database
X  Globals: addon	    - name of file containing commands to add on
X	   console_checking - indicates if the check console flag was given
X	   database	    - database containing ALL resources
X	   list		    - option list of screens to save from
X	   missing	    - name of file containing X applications
X	   program	    - name of currently executing program
X	   remote	    - command to use for remote applications
X	   stderr	    - standard error
X	   NULL		    - 0
X	   True		    - 'true' value
X*/
Xextract_options()
X{
X	register char *resource,*str_type[20],*filename;
X	XrmValue value;
X	char *malloc();
X	extern int console_checking;
X	extern char *addon,*missing,*remote,*list;
X
X	/*Allocate space for the names of the resources we'll be looking
X	  for*/
X	if((resource = malloc(strlen(program)+11)) == NULL) {
X	  perror(program);
X	  exit(1);
X	}
X
X	/*Get addon information (-a)*/
X	addon = NULL;
X	sprintf(resource,"%s.addon",program);
X	if(XrmGetResource(database,resource,"xtoolplaces.addon",
X			  str_type,&value) == True)
X	  if(value.addr && ((addon = strdup(value.addr)) == NULL)) {
X	    perror(program);
X	    exit(1);
X	  }
X
X	/*Get console checking information (-c)*/
X	console_checking = 0;
X	sprintf(resource,"%s.console",program);
X	if(XrmGetResource(database,resource,"xtoolplaces.console",
X			  str_type,&value) == True)
X	  console_checking = 1;
X
X	/*Get filename to save information to (-f)*/
X	filename = NULL;
X	sprintf(resource,"%s.saveto",program);
X	if(XrmGetResource(database,resource,"xtoolplaces.saveto",
X			  str_type,&value) == True)
X	  if(value.addr && ((filename = strdup(value.addr)) == NULL)) {
X	    perror(program);
X	    exit(1);
X	  }
X	open_file(filename);
X
X	/*Get missing applications list (-m)*/
X	missing = NULL;
X	sprintf(resource,"%s.missing",program);
X	if(XrmGetResource(database,resource,"xtoolplaces.missing",
X			  str_type,&value) == True)
X	  if(value.addr && ((missing = strdup(value.addr)) == NULL)) {
X	    perror(program);
X	    exit(1);
X	  }
X
X	/*Get remote command to use (-r)*/
X	remote = NULL;
X	sprintf(resource,"%s.remote",program);
X	if(XrmGetResource(database,resource,"xtoolplaces.remote",
X			  str_type,&value) == True)
X	  if(value.addr && ((remote = strdup(value.addr)) == NULL)) {
X	    perror(program);
X	    exit(1);
X	  }
X
X	/*Get list of screens to save window information from (-s)*/
X	list = NULL;
X	sprintf(resource,"%s.screens",program);
X	if(XrmGetResource(database,resource,"xtoolplaces.screens",
X			  str_type,&value) == True)
X	  if(value.addr && ((list = strdup(value.addr)) == NULL)) {
X	    perror(program);
X	    exit(1);
X	  }
X}
X
X/*This function will get the user's home directory, either from the HOME
X  environment variable, or if that's not set, based on the USER environment
X  variable (going through the password file).  If neither HOME or USER are
X  set, the home directory is gotten by getting the user's uid and then going
X  through the password file.  If this also fails, a NULL is returned,
X  otherwise a valid home directory is returned.
X
X  Inputs:  none
X  Outputs: ptr  - user's home directory if found, NULL if not
X  Locals:  ptr  - user's home directory
X	   pw   - password entry of user
X	   uid  - uid of user
X  Globals: HOME - environment variable containing the user's home directory
X	   NULL - 0
X	   USER - user's user name
X*/
Xchar *gethomedir()
X{
X	register int uid;
X	register char *ptr;
X	register struct passwd *pw;
X
X	if((ptr = getenv(HOME)) == NULL) {
X	  if((ptr = getenv(USER)) == NULL) {
X	     uid = getuid();
X	     pw = getpwuid(uid);
X	  } else pw = getpwnam(ptr);
X
X	  if(pw) ptr = pw->pw_dir;
X	  else ptr = NULL;
X	}
X
X	return(ptr);
X}
X
X/*This will open the file to save information to.  If the filename isn't
X  given on the command line (or resource files) (-f option), then use
X  the default name of ~/.defaults.  If '-' is given as a filename, write
X  to stdout.
X
X  Inputs:  filename         - name of file to write window info to
X  Outputs: none
X  Locals:  home             - user's home directory
X  Globals: fp		    - file pointer to write window information to
X	   program	    - name of currently executing program
X	   stderr	    - standard error
X	   stdout	    - standard output
X	   DEFAULT_FILENAME - default filename to save to
X	   NULL		    - 0
X*/
Xopen_file(filename)
Xregister char *filename;
X{
X	register char *home;
X	char *gethomedir();
X	extern FILE *fp;
X
X	/*If filename isn't given, use default ~/.xtoolplaces
X	  else if filename matches -, write to stdout, else
X	  open the filename given for writing*/
X        if(!filename) {
X          /*Get home directory for default filename*/
X	  if((home = gethomedir()) == NULL) {
X	    fprintf(stderr,"%s: can't find home directory\n",program);
X	    exit(1);
X	  }
X
X	  /*Allocate space for home directory, directory slash, and
X	    default filename*/
X          if((filename = malloc(strlen(home)+strlen(DEFAULT_FILENAME)+2))
X             == NULL) {
X            perror(program);
X            exit(1);
X          }
X            
X          strcpy(filename,home);
X          strcat(filename,"/");
X          strcat(filename,DEFAULT_FILENAME);
X        }
X          
X        if(strcmp(filename,"-")) {
X          if((fp = fopen(filename,"w")) == NULL) {
X           fprintf(stderr,"%s: can't open {%s} for writing\n",program,filename);           exit(1);
X          }
X        } else fp = stdout;
X}
X
END_OF_FILE
  if test 13930 -ne `wc -c <'getargs.c'`; then
    echo shar: \"'getargs.c'\" unpacked with wrong size!
  fi
  # end of 'getargs.c'
fi
if test -f 'getinfo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'getinfo.c'\"
else
  echo shar: Extracting \"'getinfo.c'\" \(12330 characters\)
  sed "s/^X//" >'getinfo.c' <<'END_OF_FILE'
X/*Copyright (c) 1993 Xerox Corporation.  All Rights Reserved.
X
X  Permission to use,  copy,  modify  and  distribute  without
X  charge this software, documentation, images, etc. is grant-
X  ed, provided that this copyright and the author's  name  is
X  retained.
X
X  A fee may be charged for this program ONLY to recover costs
X  for distribution (i.e. media costs).  No profit can be made
X  on this program.
X
X  The author assumes no responsibility for disasters (natural
X  or otherwise) as a consequence of use of this software.
X
X  Adam Stein (adam@iset.scan.mc.xerox.com)
X*/
X
X#include <stdio.h>
X#include <signal.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/cursorfont.h>
X#include <X11/Xatom.h>
X
Xint mult_screens,screen_number,display_number;
Xchar hostname[50];
XAtom wm_save_yourself,wm_protocols,wm_client_machine;
XDisplay *display;
XWindow root_window;
Xextern int console_checking;
Xextern char *program,*addon;
Xextern FILE *fp;
X
X/*This function will initialize the interface to X, lock the pointer and
X  change it to a watch, start the recursive procedure of going through
X  the window tree list, and then release the pointer and change the cursor
X  back to normal when done.
X
X  Inputs:  none
X  Outputs: none
X  Locals:  child             - list of child window IDs
X	   cursor            - X cursor bitmap
X	   hostname	     - name of host
X	   loop		     - loop through screen number array
X	   num_child         - number of children under a parent
X	   parent            - parent window ID of child in the window tree
X	   root              - top window ID to start in window tree from
X	   screens	     - array of screens to save from
X  Globals: display           - interface info to X display
X	   display_number    - number of the display this will be working under
X	   mult_screens      - flag indicating if saving more than 1 screen
X	   program           - name of currently executing program
X	   root_window       - root window ID
X	   screen_number     - number of the screen this will be working under
X	   stderr	     - standard error
X	   use_display       - display to use
X	   wm_client_machine - WM_CLIENT_MACHINE atom
X	   wm_protocols      - WM_PROTOCOLS atom
X	   wm_save_yourself  - WM_SAVE_YOURSELF atom
X  	   CurrentTime	     - indicates to execute action immediately
X	   False             - indicates not to do something
X	   GrabModeAsync     - indicates to grab device asynchronously
X	   GrabModeSync      - indicates to grab device synchronously
X	   None		     - indicates no choice for an item
X	   NULL		     - 0
X	   XC_watch          - indicates the watch bitmap
X*/
Xgetinfo()
X{
X	register int *screens,loop;
X	unsigned int num_child;
X	register Cursor cursor;
X	Window root,parent,*child;
X	extern char *use_display[256];
X	int *make_list();
X
X	/*Get hostname*/
X	if(gethostname(hostname,50)) {
X	  perror(program);
X	  exit(1);
X	}
X
X	/*Find out what screens to save application states from*/
X	display_number = display->ext_number;
X	screens = make_list(DefaultScreen(display),ScreenCount(display));
X	if(screens[1] != -1) mult_screens = 1;
X	else mult_screens = 0;
X
X	/*Set up ATOMS to use*/
X	wm_save_yourself = XInternAtom(display,"WM_SAVE_YOURSELF",False);
X	wm_protocols = XInternAtom(display,"WM_PROTOCOLS",False);
X	wm_client_machine = XInternAtom(display,"WM_CLIENT_MACHINE",False);
X
X	/*Change cursor to a watch and ring bell once to let user know
X	  that the server is tied up and the process has begun*/
X	root_window = RootWindow(display,DefaultScreen(display));
X	cursor = XCreateFontCursor(display,XC_watch);
X	XGrabPointer(display,root_window,False,0,GrabModeSync,GrabModeAsync,
X		     None,cursor,CurrentTime);
X	XBell(display,50);
X
X	/*Write Bourne shell header*/
X	write_header();
X
X	/*Loop through the screens to save from*/
X	for(loop = 0;screens[loop] != -1;++loop) {
X	  /*Get information about root window*/
X	  screen_number = screens[loop];
X	  root_window = RootWindow(display,screen_number);
X
X	  /*Get list of root window's child*/
X	  if(!XQueryTree(display,root_window,&root,&parent,&child,&num_child)) {
X	    fprintf(stderr,"%s: couldn't get root window's child (window 0x%lx)\n",program,root_window);
X	    exit(1);
X	  }
X
X	  /*Loop through children windows*/
X	  for(;num_child;--num_child)
X	    search(display,child[num_child-1],root_window);
X  
X	  /*Free resources*/
X	  XFree(child);
X	}
X
X	/*Change cursor back to normal and ring bell twice to signal that
X	  the process of saving the desktop is over*/
X	XUngrabPointer(display,CurrentTime);
X	XBell(display,50);
X	XBell(display,50);
X	XFlush(display);
X
X	/*Close the connection to the X server*/
X	XCloseDisplay(display);
X}
X
X/*This function will recursively search through the window tree.  It will check
X  each window to see if it's state should be saved with a WM_SAVE_YOURSELF
X  message and if it has a WM_COMMAND property to save.  A window is saved
X  if:
X	1.  it has WM_NAME set (so we know it's not a pop-up, etc)
X	2.  it's a group leader or assume it's ok if group leader isn't set
X	3.  it's parent is the root window
X	4.  it has a WM_COMMAND property to save or is on a list specified
X	    with the '-m' option
X
X  Inputs:  display            - interface info to X display
X	   parent_window      - parent window ID of window we are examining
X	   window             - window we are examining
X  Outputs: none
X  Locals:  argc		      - number of WM_COMMAND arguments
X	   argv	              - WM_COMMAND arguments
X	   child              - list of child window IDs
X	   command_line       - command line arguments in a single string
X	   console            - indicates if a window is a console
X	   count              - number of protocols that a window can receive
X	   event	      - event information
X	   group_leader       - window ID of group leader
X	   hints              - window hints
X	   name		      - X window name
X	   num_child          - number of children under a parent
X	   parent             - parent window ID of child in the window tree
X	   protocols          - list of protocols that a window can receive
X	   root               - top window ID to start in window tree from
X	   save_yourself      - flag indicating if window saved itself or not
X	   status             - status of get calls
X  Globals: addon	      - name of file containing commands to add on
X	   console_checking   - indicates if the check console flag was given
X	   fp		      - file pointer to write window information to
X	   mult_screens       - flag indicating if saving more than 1 screen
X	   on_missing_list    - flag indicating if window is a missing app
X	   program            - name of currently executing program
X	   root_window        - root window ID
X	   screen_number      - number of the screen this will be working under
X	   stderr	      - standard error
X	   wm_protocols	      - WM_PROTOCOLS atom
X	   wm_save_yourself   - WM_SAVE_YOURSELF atom
X	   ClientMessage      - event that indicates a message from 1 client
X				to another
X	   False	      - indicates not to do something
X	   PropertyChangeMask - indicates a window property has changed
X	   PropertyNotify     - event that indicates a property has changed
X	   WindowGroupHint    - mask for group hint bit in hint flags
X*/
Xsearch(display,window,parent_window)
Xregister Display *display;
Xregister Window window,parent_window;
X{
X	register int save_yourself,on_missing_list,console = 0;
X	unsigned int num_child;
X	int count,argc,group_leader = 0;
X	register char *command_line,*name;
X	char **argv;
X	Atom *protocols;
X	register Status status;
X	void getsignal();
X	Window root,parent,*child;
X	XEvent event;
X	register XWMHints *hints;
X	char *combine(),*getgeom(),*getname(),*lower();
X
X
X	/*If a child had children of it's own, loop thru it's children
X	  recursively*/
X	if(XQueryTree(display,window,&root,&parent,&child,&num_child)) {
X	  for(;num_child;--num_child)
X	    search(display,child[num_child-1],parent_window);
X
X	  /*Free resources*/
X	  XFree(child);
X	}
X
X	/*Don't report window if it doesn't have a name (in which case it's
X	  probably a pop-up or unmapped child*/
X	if(name = getname(window)) XFree(name);
X	else return;
X
X	/*Don't report window if it's not a group leader or isn't a top
X	  window*/
X	hints = XGetWMHints(display,window);
X
X	/*Also check if program didn't set #!$% group leader, in this case
X	  assume it's ok (I'm sure that's asking for trouble!)*/
X	if(hints) {
X	  if((hints->window_group == window) ||
X	     !(hints->flags & WindowGroupHint))
X	    group_leader = 1;
X	  XFree(hints);
X	}
X	if(!group_leader || (parent_window != root_window)) return;
X
X	/*Determine if window has WM_SAVE_YOURSELF ATOM and send it if
X	  it does to save it's state*/
X	status = XGetWMProtocols(display,window,&protocols,&count);
X	if(status && is_save_yourself(protocols,count)) {
X	  save_yourself = 1;
X
X	  /*If window does have WM_SAVE_YOURSELF, send it a message to
X	    save it's state and wait for the PropertyNotify response*/
X	  event.type = ClientMessage;
X	  event.xclient.window = window;
X	  event.xclient.message_type = wm_protocols;
X	  event.xclient.format = 32;
X	  event.xclient.data.l[0] = (long) wm_save_yourself;
X	  XSelectInput(display,window,PropertyChangeMask);
X	  XSendEvent(display,window,False,0L,&event);
X	  XNextEvent(display,&event);
X	  if(event.type == PropertyNotify) {
X	    if(event.xproperty.window != window) {
X	      fprintf(stderr,"%s: unexpected PropertyNotify event\n",program);
X	      exit(1);
X	    }
X	  } else {
X		   fprintf(stderr,"%s: unexpected event\n",program);
X		   exit(1);
X		 }
X	} else save_yourself = 0;
X
X	/*Free resources*/
X	if(status) XFree(protocols);
X
X	/*Determine if window is on missing apps list*/
X	on_missing_list = on_list(window);
X
X	/*Get WM_COMMAND.  If window doesn't have it set or isn't a console
X	  tool, skip it, otherwise write it out*/
X	status = XGetCommand(display,window,&argv,&argc);
X	if((status && !isnull(window)) || on_missing_list ||
X	   is_console(window,NULL)) {
X	  /*Put arguments into a single string and free up argv.  Makes it
X	    easier to check for things*/
X	  if(status) {
X	    command_line = combine(argc,argv);
X	    XFreeStringList(argv);
X	  } else {
X		   /*It is ASSUMED that if we have to save a window that
X		    doesn't have WM_COMMAND set, it's name is the basename
X		    of WM_NAME in all lower case (i.e. xman sets WM_NAME to
X		    Xman)*/
X		   command_line = lower(getname(window));
X		   save_yourself = 0;
X		 }
X
X	  if(!save_yourself) command_line = getgeom(window,command_line);
X
X	  /*If console checking flag was given, check each window to see
X	    if it's a console window*/
X	  if(console_checking)
X	    console = is_console(window,command_line);
X
X	  /*If this window is a console window, write out the special
X	    'if ... fi' clause*/
X	  if(console)
X	    fputs("if [ \"`tty`\" = \"/dev/console\" ]\nthen\n  ",fp);
X
X	  /*Check to see if window is a remote application*/
X	  is_remote(window);
X
X	  /*Fix Xview's long label problem*/
X	  fix_command(command_line);
X
X	  /*If saving from more than 1 screen, make sure each application
X	    has the correct -display option to put it back onto the correct
X	    screen*/
X
X	  /*Write out all the arguments in WM_COMMAND*/
X	  fprintf(fp,"%s ",command_line);
X
X	  if(mult_screens) adddisplay(command_line,screen_number);
X
X	  /*If -a option given, search for any addon commands for this window*/
X	  if(addon) addto(command_line);
X
X	  /*Write out ampersand to put command into the background*/
X	  fputs("&\n",fp);
X
X	  if(console)
X	    fputs("fi\n",fp);
X
X	  /*Free resources*/
X	  free(command_line);
X	}
X}
X
X/*This function will convert all letters in a string to lower case (if not
X  already lower case).  It will also take the basename of the string.
X
X  Inputs:  string    - string to turn all characters to lower case
X  Outputs: string    - string of all lower case characters
X  Locals:  loop      - loop through string
X	   newstring - lower case basename of original string
X	   pointer   - pointer to directory slash to get basename
X  Globals: none
X*/
Xchar *lower(string)
Xregister char *string;
X{
X	register int loop;
X	register char *pointer,*newstring;
X	char *rindex(),*strdup();
X
X	if((pointer = rindex(string,'/')) == NULL) pointer = string;
X	else ++pointer;
X
X	if((newstring = strdup(pointer)) == NULL) {
X	  perror(program);
X	  exit(1);
X	}
X
X	for(loop = 0;loop < strlen(newstring);++loop)
X	  if(isupper(newstring[loop]))
X	    newstring[loop] = tolower(newstring[loop]);
X
X	return(newstring);
X}
X
END_OF_FILE
  if test 12330 -ne `wc -c <'getinfo.c'`; then
    echo shar: \"'getinfo.c'\" unpacked with wrong size!
  fi
  # end of 'getinfo.c'
fi
if test -f 'is.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'is.c'\"
else
  echo shar: Extracting \"'is.c'\" \(12708 characters\)
  sed "s/^X//" >'is.c' <<'END_OF_FILE'
X/*Copyright (c) 1993 Xerox Corporation.  All Rights Reserved.
X
X  Permission to use,  copy,  modify  and  distribute  without
X  charge this software, documentation, images, etc. is grant-
X  ed, provided that this copyright and the author's  name  is
X  retained.
X
X  A fee may be charged for this program ONLY to recover costs
X  for distribution (i.e. media costs).  No profit can be made
X  on this program.
X
X  The author assumes no responsibility for disasters (natural
X  or otherwise) as a consequence of use of this software.
X
X  Adam Stein (adam@iset.scan.mc.xerox.com)
X*/
X
X#include <stdio.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xatom.h>
X#include "xtoolplaces.h"
X
Xextern char *remote,hostname[];
Xextern Atom wm_save_yourself,wm_client_machine;
Xextern Display *display;
Xextern FILE *fp;
X
X/*This function will check a list of protocols to see if the WM_SAVE_YOURSELF
X  protocol is in the list
X
X  Inputs:  count            - number of protocols in list
X	   protocols        - protocol list
X  Outputs: 1 if WM_SAVE_YOURSELF is found, 0 otherwise
X  Locals:  none
X  Globals: wm_save_yourself - WM_SAVE_YOURSELF atom
X*/
Xis_save_yourself(protocols,count)
Xregister int count;
Xregister Atom *protocols;
X{
X	for(;count;--count)
X	  if(protocols[count-1] == wm_save_yourself)
X	    return(1);
X
X	return(0);
X}
X
X/*This function will read in WM_COMMAND from a window and determine if
X  WM_COMMAND is set, but null.  This is a problem which XGetCommand()
X  doesn't handle.  If WM_COMMAND is null, XGetCommand() still returns
X  an argv pointer with the number of arguments equal to 1.  This code
X  is lifted (and modified) from xprop (i.e. I didn't think of it myself).
X
X  This routine is needed because some windows are EXACTLY like a top-level
X  window to save EXCEPT their WM_COMMAND property is null (i.e. Filemgr's
X  wastebasket and Mailtool's Compose window -- both from the OpenWindow
X  deskset).
X
X  Inputs:  window        - window we are examining
X  Outputs: 1 if null (or no WM_COMMAND), 0 otherwise
X  Locals:  actual_format - actual data type of the returned data
X	   actual_type   - actual type of WM_COMMAND
X	   bytes_after   - number of bytes remaining to be read in if a
X			   partial read was performed
X	   nitems        - actual number of items returned in 'prop'.
X	   prop		 - pointer to the data in WM_COMMAND
X	   status	 - status of get call
X*/
Xisnull(window)
Xregister Window window;
X{
X	register int status;
X	int actual_format;
X	unsigned long nitems,bytes_after;
X	unsigned char *prop;
X	Atom actual_type;
X
X	status = XGetWindowProperty(display,window,XA_WM_COMMAND,0,2500,False,
X				    AnyPropertyType,&actual_type,
X				    &actual_format,&nitems,&bytes_after,&prop);
X
X	if((status == Success) && nitems) return(0);
X	else return(1);
X}
X
X
X/*This function will determine if a window is acting as a console window.  It
X  does this by first checking the class of the window.  Since there is no
X  standard class for consoles, maybe this program will start one.  The window
X  is considered a console if it's class is XConsole.  If the class isn't
X  XConsole (which is most likely the case), functions are called to check
X  for each console type that I could think of.  This includes contool,
X  Sun's shelltool & cmdtool, and xterm.  Each (of course) has a different
X  way of identifying when it's on console mode.  To add other consoles, just
X  add another function call here and the function to make the check.  A 1
X  is returned if the window is a console, 0 otherwise.
X
X  Inputs:  command_line  - WM_COMMAND arguments in a single string
X	   window        - ID of the window that we are going to check
X  Outputs: console       - indicates if a window is a console
X  Locals:  class_hints   - window class
X	   console       - indicates if a window is a console
X	   status        - status of get call
X  Globals: display       - interface info to X display
X	   CONSOLE_CLASS - class name for console windows
X*/
Xis_console(window,command_line)
Xregister char *command_line;
Xregister Window window;
X{
X	register int console = 0;
X	register Status status;
X	XClassHint class_hints;
X
X	/*Get window class and check it against what a class for a console
X	  window should be*/
X	status = XGetClassHint(display,window,&class_hints);
X	if(status && !strcmp(class_hints.res_class,CONSOLE_CLASS))
X	  console = 1;
X	XFree(class_hints.res_name);
X	XFree(class_hints.res_class);
X
X	/*If the class doesn't match, check for each type of console
X	  window possible*/
X	if(!console)
X	  if(!(console = check_contool(window)))
X	    if(command_line && !(console = check_sun_tools(window)))
X	      console = check_xterm(window,command_line);
X
X	return(console);
X}
X
X/*This function will check to see if a window is the contool window.  Since
X  contool is always a console, we only have to check the window name to see
X  if the word 'Contool' is in the name.  A 1 is returned if it is a contool
X  window, 0 otherwise.
X
X  Inputs:  window       - ID of the window that we are going to check
X  Outputs: contool      - flag indicating if window is contool window or not
X  Locals:  contool      - flag indicating if window is contool window or not
X	   name		- X window name
X  Globals: display      - interface info to X display
X	   CONTOOL_NAME - name of contool window
X*/
Xcheck_contool(window)
Xregister Window window;
X{
X	register int contool = 0;
X	register char *name;
X	char *getname();
X
X	/*Get the name of the window to compare it against the name contool
X	  gives it's window*/
X	name = getname(window);
X	if(name && strstr(name,CONTOOL_NAME)) {
X	  contool = 1;
X	  XFree(name);
X	}
X
X	return(contool);
X}
X
X/*This function will check to see if a window is either a shelltool or
X  cmdtool in the console mode.  Since the icon name is CONSOLE only when
X  either is started up in console mode, we can check that.  A 1 is returned
X  if it is in console mode, 0 otherwise.
X
X  Inputs:  window              - ID of the window that we are going to check
X  Outputs: sun_tools           - flag indicating if window is in console mode
X  Locals:  status              - status of get call
X	   sun_tools 	       - flag indicating if window is in console mode
X	   tp        	       - window's text property
X  Globals: display	       - interface info to X display
X	   SUN_TOOLS_ICON_NAME - icon name for {shell,cmd}tool in console mode
X*/
Xcheck_sun_tools(window)
Xregister Window window;
X{
X	register int sun_tools = 0;
X	register Status status;
X	XTextProperty tp;
X
X	/*Get window's icon name and check it against what Sun labels the icon
X	  of either shelltool or cmdtool in console mode*/
X	status = XGetWMIconName(display,window,&tp);
X	if(status && !strcmp(tp.value,SUN_TOOLS_ICON_NAME))
X	  sun_tools = 1;
X
X	XFree(tp.value);
X
X	return(sun_tools);
X}
X
X/*This function will check to see if a window is xterm in the console mode.
X  The only way to determine if xterm is in console mode is to check the
X  options to see if it was started with the -C option.  A 1 is returned
X  if it is in console mode, 0 otherwise.
X
X  Inputs:  command_line - WM_COMMAND arguments in a single string
X	   window       - ID of the window that we are going to check
X  Outputs: xterm        - flag indicating if window is xterm in console mode
X  Locals:  xterm        - flag indicating if window is xterm in console mode
X  Globals: XTERM_OPTION - xterm option to put it into console mode
X*/
Xcheck_xterm(window,command_line)
Xregister char *command_line;
Xregister Window window;
X{
X	register int xterm = 0;
X
X	/*See if it's xterm*/
X	if(is_xterm(window) == 1)
X	  /*If window is xterm, then check argument list for xterm console
X	    mode option*/
X	  if(strstr(command_line,XTERM_OPTION)) xterm = 1;
X
X	return(xterm);
X}
X
X/*This function determines if a particular window is an xterm window.  To
X  see if a window is an xterm window, we check it's class.  Xterm always sets
X  it's class to "XTerm".  1 is returned if it is an xterm window, 0 if it
X  isn't, -1 if there is an error in getting the class of the window.
X
X  Inputs:  window   - ID of the window that we are going to check
X  Outputs: 1 if xterm, 0 if not xterm, -1 if error in getting class
X  Locals:  match    - flag indicating if window is xterm window or not
X	   status   - status of get call
X	   tp	    - window's text property
X  Globals: display  - interface info to X display
X*/
Xis_xterm(window)
Xregister Window window;
X{
X	register int match;
X	register Status status;
X	XClassHint class_hints;
X
X	/*Get window class to see if it's xterm*/
X	status = XGetClassHint(display,window,&class_hints);
X
X	if(status) {
X	  match = strcmp(class_hints.res_class,"XTerm");
X	  XFree(class_hints.res_name);
X	  XFree(class_hints.res_class);
X
X	  return((!match)?1:0);
X	} else return(-1);
X}
X
X/*This function determines if a particular window is an emacs window.  To
X  see if a window is an emacs window, we check it's class.  Emacs always sets
X  it's class to "Emacs".  1 is returned if it is an emacs window, 0 if it
X  isn't, -1 if there is an error in getting the name of the window.
X
X  Inputs:  window   - ID of the window that we are going to check
X  Outputs: 1 if emacs, 0 if not emacs, -1 if error in getting class
X  Locals:  match    - flag indicating if window is emacs window or not
X	   status   - status of get call
X	   tp	    - window's text property
X  Globals: display  - interface info to X display
X*/
Xis_emacs(window)
Xregister Window window;
X{
X	register int match,propstatus;
X	int actual_format;
X	unsigned long nitems,bytes_after;
X	unsigned char *prop;
X	register Atom epoch_current;
X	Atom actual_type;
X	register Status status;
X	XClassHint class_hints;
X
X	/*Get window class to see if it's emacs*/
X	status = XGetClassHint(display,window,&class_hints);
X
X	if(status) {
X	  match = strcmp(class_hints.res_class,"Emacs");
X
X	  epoch_current = XInternAtom(display,"EPOCH_CURRENT",True);
X	  if(epoch_current != None) {
X	    propstatus = XGetWindowProperty(display,window,epoch_current,0,1,
X					    False,AnyPropertyType,&actual_type,
X					    &actual_format,&nitems,&bytes_after,
X					    &prop);
X
X	  /*It's weird that XGetWindowProperty() would return Success without
X	    sending back any properties (prop = NULL)*/
X	  if((propstatus == Success) && prop && strcmp(prop,"minibuf"))
X	    match = 0;
X	  else match = 1;
X
X	  XFree(class_hints.res_name);
X	  XFree(class_hints.res_class);
X	  if(prop) XFree(prop);
X	  }
X
X	  return((!match)?1:0);
X	} else return(-1);
X}
X
X/*This function determines if a particular window is a calctool window.  To
X  see if a window is a calctool window, we check it's name.  Calctool always
X  sets it's name to "calctool".  1 is returned if it is a calctool window, 0
X  if it isn't, -1 if there is an error in getting the name of the window.
X
X  Inputs:  window    - ID of the window that we are going to check
X  Outputs: 1 if calctool, 0 if not calctool, -1 if error in getting name
X  Locals:  status    - status of get call
X	   text_prop - window's text property
X  Globals: display   - interface info to X display
X*/
Xis_calctool(window)
Xregister Window window;
X{
X	register Status status;
X	XTextProperty text_prop;
X
X	/*Get window name to see if it's calctool*/
X	status = XGetWMName(display,window,&text_prop);
X
X	if(status) return((!strcmp(text_prop.value,"calctool"))?1:0);
X	else return(-1);
X}
X
X/*This function checks to see if an application is being executed remotely.
X  If it is, it prints out the remote execution command (typically 'rsh -n') and
X  the name of the remote machine to execute on.
X
X  Inputs:  window 	     - ID of the window that we are going to check
X  Outputs: none
X  Locals:  status 	     - status of get call
X	   tp     	     - window's text property
X  Globals: display	     - interface info to X display
X	   fp		     - file pointer to write window information to
X	   hostname	     - name of host
X	   remote	     - command to use for remote applications
X	   wm_client_machine - WM_CLIENT_MACHINE atom
X*/
Xis_remote(window)
Xregister Window window;
X{
X	register Status status;
X	XTextProperty tp;
X
X	status = XGetTextProperty(display,window,&tp,wm_client_machine);
X
X	/*Check if WM_CLIENT_MACHINE exists and isn't the name of the
X	  machine we are currently executing on*/
X	if(status && strcmp(tp.value,hostname))
X	  fprintf(fp,"%s %s ",remote,tp.value);
X}
X
X/*This function gets the name of an X window and returns it.
X
X  Inputs:  window   - ID of the window that we are going to check
X  Outputs: tp.value - name of X window
X  Locals:  status   - status of get call
X	   tp       - window's text property
X  Globals: display  - interface info to X display
X	   NULL     - 0
X*/
Xchar *getname(window)
Xregister Window window;
X{
X	register Status status;
X	XTextProperty tp;
X
X	/*Get the name of the window*/
X	status = XGetWMName(display,window,&tp);
X
X	if(status) return((char *) tp.value);
X	else return(NULL);
X}
X
END_OF_FILE
  if test 12708 -ne `wc -c <'is.c'`; then
    echo shar: \"'is.c'\" unpacked with wrong size!
  fi
  # end of 'is.c'
fi
if test -f 'missing.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'missing.c'\"
else
  echo shar: Extracting \"'missing.c'\" \(2855 characters\)
  sed "s/^X//" >'missing.c' <<'END_OF_FILE'
X/*Copyright (c) 1993 Xerox Corporation.  All Rights Reserved.
X
X  Permission to use,  copy,  modify  and  distribute  without
X  charge this software, documentation, images, etc. is grant-
X  ed, provided that this copyright and the author's  name  is
X  retained.
X
X  A fee may be charged for this program ONLY to recover costs
X  for distribution (i.e. media costs).  No profit can be made
X  on this program.
X
X  The author assumes no responsibility for disasters (natural
X  or otherwise) as a consequence of use of this software.
X
X  Adam Stein (adam@iset.scan.mc.xerox.com)
X*/
X
X#include <stdio.h>
X#include <X11/Xos.h>
X#include <X11/Xlib.h>
X
Xint aindex;
Xchar *missing_list[50];
Xextern char *missing,*program;
X
X/*This function will read in the list of X applications that don't set
X  WM_COMMAND and need to be saved.
X
X  Inputs:  none
X  Outputs: none
X  Locals:  fp           - file pointer to read from
X	   line         - line of text read in
X  Globals: aindex	- index into name list
X	   missing	- name of file containing X applications
X	   missing_list - list of X applications that don't set WM_COMMAND
X	   program      - name of currently executing program
X	   stderr	- standard error
X	   NULL		- 0
X*/
Xread_missing()
X{
X	register char line[200];
X	register FILE *fp;
X	char *strdup();
X
X	/*Open the file for reading*/
X	if((fp = fopen(missing,"r")) == NULL) {
X	  fprintf(stderr,"%s: can't open {%s}\n",program,missing);
X	  exit(1);
X	}
X
X	aindex = 0;
X
X	/*Read lines from file until there is no more*/
X	while(fgets(line,200,fp) != NULL)
X	  switch(line[0]) {
X            case '#':                   /*Comment character - ignore line*/
X            case '\n':                  /*Blank line - ignore line*/
X                        break;
X            default:
X			line[strlen(line)-1] = '\0';  /*Take out NL char*/
X			if((missing_list[aindex++] = strdup(line)) == NULL) {
X			  perror(program);
X			  exit(1);
X			}
X
X			break;
X	  }
X}
X
X/*This function will determine if an application's window is on the missing
X  applications list.  A 1 is returned if on the list, 0 if not.
X
X  Inputs:  window 	- ID of the window that we are going to check
X  Outputs: result 	- 1 if application is on the list, 0 if not
X  Locals:  loop   	- loop through name list
X	   name   	- name of window
X	   result 	- flag indicating if window is on list or not
X  Globals: aindex	- number of entries in the name list
X	   missing	- name of file containing X applications
X	   missing_list - list of X applications that don't set WM_COMMAND
X*/
Xon_list(window)
Xregister Window window;
X{
X	register int loop,result;
X	register char *name;
X	char *getname();
X
X	result = 0;
X
X	/*Check name list if '-m' was given*/
X	if(missing)
X	  if(name = getname(window)) {
X	    for(loop = 0;!result && (loop < aindex);++loop)
X	      if(!strcmp(name,missing_list[loop])) result = 1;
X
X	    XFree(name);
X	  }
X
X	return(result);
X}
X
END_OF_FILE
  if test 2855 -ne `wc -c <'missing.c'`; then
    echo shar: \"'missing.c'\" unpacked with wrong size!
  fi
  # end of 'missing.c'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM            | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly!      |
 "It's intuitively obvious to the most |    sources-x@imd.sterling.com
  casual observer..."                  |
