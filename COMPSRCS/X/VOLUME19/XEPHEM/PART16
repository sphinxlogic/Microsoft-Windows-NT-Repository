Newsgroups: comp.sources.x
From: ecdowney@pobox.cca.cr.rockwell.com (Elwood Downey)
Subject: v19i104:  xephem - astronomical ephemeris program, Part16/21
Message-ID: <1993May10.221222.9390@sparky.imd.sterling.com>
X-Md4-Signature: 5f93851abcc7f29fa8b420ad5b4ace3b
Date: Mon, 10 May 1993 22:12:22 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: ecdowney@pobox.cca.cr.rockwell.com (Elwood Downey)
Posting-number: Volume 19, Issue 104
Archive-name: xephem/part16
Environment: X11r4, OSF/Motif
Supersedes: xephem: Volume 16, Issue 112-134

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# Contents:  earthmap.c earthmenu.c srchmenu.c
# Wrapped by chris@nova on Mon May 10 16:41:51 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 16 (of 21)."'
if test -f 'earthmap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'earthmap.c'\"
else
  echo shar: Extracting \"'earthmap.c'\" \(28806 characters\)
  sed "s/^X//" >'earthmap.c' <<'END_OF_FILE'
X#include "map.h"
X
Xstatic MCoord ec0[] = {
X    {-140,  60},
X    {-132,  57},
X    {-131,  56},
X    {-134,  57},
X    {-136,  59},
X    {-137,  58},
X    {-140,  60},
X    {-147,  60},
X    {-150,  60},
X    {-149,  61},
X    {-154,  59},
X    {-157,  57},
X    {-162,  55},
X    {-158,  58},
X    {-162,  58},
X    {-165,  60},
X    {-165,  63},
X    {-161,  64},
X    {-168,  65},
X    {-163,  66},
X    {-162,  67},
X    {-167,  68},
X    {-160,  70},
X    {-154,  71},
X    {-148,  70},
X    {-142,  70},
X    {-141,  70},
X};
Xstatic MCoord ec1[] = {
X    {-153,  58},
X    {-153,  58},
X};
Xstatic MCoord ec2[] = {
X    {-153,  58},
X    {-152,  57},
X    {-153,  58},
X};
Xstatic MCoord ec3[] = {
X    {-167,  54},
X    {-167,  54},
X};
Xstatic MCoord ec4[] = {
X    {-168,  54},
X    {-168,  53},
X};
Xstatic MCoord ec5[] = {
X    {-171,  53},
X    {-171,  53},
X};
Xstatic MCoord ec6[] = {
X    {-174,  52},
X    {-174,  52},
X};
Xstatic MCoord ec7[] = {
X    {-177,  52},
X    {-177,  52},
X};
Xstatic MCoord ec8[] = {
X    {-178,  52},
X    {-177,  52},
X};
Xstatic MCoord ec9[] = {
X    {-178,  52},
X};
Xstatic MCoord ec10[] = {
X    { 177,  52},
X    { 177,  52},
X};
Xstatic MCoord ec11[] = {
X    { 172,  53},
X    { 173,  53},
X};
Xstatic MCoord ec12[] = {
X    {-141,  60},
X    {-133,  59},
X    {-131,  55},
X    {-129,  54},
X    {-127,  52},
X    {-127,  51},
X    {-124,  50},
X    {-123,  49},
X};
Xstatic MCoord ec13[] = {
X    { -92,  48},
X    { -88,  49},
X    { -83,  46},
X    { -82,  45},
X    { -82,  42},
X    { -77,  44},
X    { -70,  47},
X    { -66,  45},
X    { -66,  44},
X    { -61,  45},
X    { -65,  47},
X    { -64,  49},
X    { -71,  47},
X    { -67,  49},
X    { -60,  50},
X    { -56,  52},
X    { -59,  54},
X    { -58,  54},
X    { -61,  55},
X    { -62,  57},
X    { -64,  59},
X    { -67,  58},
X    { -70,  60},
X    { -71,  61},
X    { -78,  62},
X    { -77,  60},
X    { -77,  56},
X    { -79,  52},
X    { -82,  53},
X    { -87,  56},
X    { -92,  57},
X    { -96,  59},
X    { -93,  62},
X    { -91,  63},
X    { -96,  64},
X    { -90,  64},
X    { -89,  65},
X    { -87,  66},
X    { -85,  67},
X    { -82,  68},
X    { -83,  70},
X    { -86,  68},
X    { -88,  68},
X    { -91,  69},
X    { -92,  70},
X    { -93,  71},
X    { -97,  71},
X    { -93,  70},
X    { -94,  68},
X    { -96,  67},
X    { -99,  68},
X    {-102,  68},
X    {-108,  68},
X    {-106,  68},
X    {-108,  67},
X    {-111,  68},
X    {-114,  68},
X    {-121,  69},
X    {-124,  69},
X    {-129,  71},
X    {-132,  69},
X    {-131,  70},
X    {-136,  69},
X    {-140,  69},
X    {-141,  70},
X};
Xstatic MCoord ec14[] = {
X    {-123,  48},
X    {-128,  51},
X    {-123,  48},
X};
Xstatic MCoord ec15[] = {
X    {-132,  53},
X    {-132,  53},
X};
Xstatic MCoord ec16[] = {
X    {-133,  53},
X    {-132,  54},
X    {-133,  53},
X};
Xstatic MCoord ec17[] = {
X    { -55,  52},
X    { -55,  50},
X    { -54,  47},
X    { -53,  46},
X    { -56,  47},
X    { -58,  48},
X    { -58,  50},
X    { -55,  52},
X};
Xstatic MCoord ec18[] = {
X    { -61,  49},
X    { -62,  49},
X    { -61,  49},
X};
Xstatic MCoord ec19[] = {
X    { -63,  47},
X    { -64,  47},
X    { -63,  47},
X};
Xstatic MCoord ec20[] = {
X    { -60,  46},
X    { -60,  47},
X};
Xstatic MCoord ec21[] = {
X    {-122,  49},
X    {-124,  47},
X    {-125,  42},
X    {-123,  38},
X    {-122,  37},
X    {-118,  33},
X    {-117,  33},
X};
Xstatic MCoord ec22[] = {
X    { -98,  26},
X    { -96,  29},
X    { -91,  29},
X    { -87,  30},
X    { -83,  28},
X    { -80,  27},
X    { -81,  32},
X    { -77,  35},
X    { -76,  38},
X    { -76,  38},
X    { -71,  42},
X    { -69,  44},
X    { -68,  47},
X    { -73,  45},
X    { -79,  43},
X    { -83,  43},
X    { -83,  45},
X    { -86,  44},
X    { -88,  43},
X    { -86,  46},
X    { -87,  47},
X    { -91,  47},
X    { -90,  48},
X};
Xstatic MCoord ec23[] = {
X    { -72,  41},
X    { -72,  41},
X};
Xstatic MCoord ec24[] = {
X    { -81,  27},
X    { -81,  27},
X};
Xstatic MCoord ec25[] = {
X    {-113,  42},
X    {-113,  42},
X};
Xstatic MCoord ec26[] = {
X    {-156,  20},
X    {-156,  20},
X};
Xstatic MCoord ec27[] = {
X    {-157,  21},
X    {-157,  21},
X};
Xstatic MCoord ec28[] = {
X    {-157,  21},
X    {-157,  21},
X};
Xstatic MCoord ec29[] = {
X    {-158,  21},
X};
Xstatic MCoord ec30[] = {
X    {-160,  22},
X};
Xstatic MCoord ec31[] = {
X    {-117,  66},
X    {-120,  65},
X    {-124,  65},
X    {-124,  66},
X    {-119,  66},
X    {-117,  66},
X};
Xstatic MCoord ec32[] = {
X    {-121,  64},
X    {-115,  62},
X    {-109,  63},
X    {-113,  61},
X    {-119,  61},
X    {-117,  61},
X    {-116,  63},
X    {-119,  64},
X    {-121,  64},
X};
Xstatic MCoord ec33[] = {
X    {-112,  58},
X    {-109,  59},
X    {-104,  59},
X    {-103,  57},
X    {-102,  59},
X    {-105,  59},
X    {-111,  59},
X    {-112,  59},
X};
Xstatic MCoord ec34[] = {
X    { -99,  50},
X    {-100,  52},
X    {-100,  51},
X    { -99,  50},
X};
Xstatic MCoord ec35[] = {
X    { -97,  50},
X    { -97,  54},
X    { -99,  53},
X    { -97,  51},
X    { -97,  50},
X};
Xstatic MCoord ec36[] = {
X    { -95,  49},
X    { -92,  50},
X    { -94,  49},
X    { -95,  49},
X};
Xstatic MCoord ec37[] = {
X    { -80,  56},
X    { -79,  56},
X    { -80,  56},
X};
Xstatic MCoord ec38[] = {
X    {-104,  59},
X    {-104,  59},
X};
Xstatic MCoord ec39[] = {
X    {-102,  58},
X    {-102,  58},
X    {-102,  58},
X};
Xstatic MCoord ec40[] = {
X    {-102,  56},
X    { -98,  57},
X    {-101,  56},
X    {-102,  56},
X};
Xstatic MCoord ec41[] = {
X    {-117,  32},
X    {-115,  28},
X    {-113,  25},
X    {-111,  24},
X    {-114,  30},
X    {-113,  30},
X    {-110,  26},
X    {-106,  22},
X    {-102,  18},
X    { -96,  16},
X    { -92,  15},
X};
Xstatic MCoord ec42[] = {
X    { -88,  17},
X    { -87,  21},
X    { -92,  19},
X    { -97,  20},
X    { -98,  26},
X};
Xstatic MCoord ec43[] = {
X    { -92,  15},
X    { -87,  12},
X    { -83,   9},
X    { -80,   9},
X    { -77,   8},
X    { -82,   9},
X    { -84,  13},
X    { -86,  16},
X    { -88,  16},
X};
Xstatic MCoord ec44[] = {
X    { -78,   7},
X    { -79,   1},
X    { -81,  -4},
X    { -76, -15},
X    { -70, -19},
X    { -71, -26},
X    { -71, -32},
X    { -73, -37},
X    { -73, -42},
X    { -73, -46},
X    { -74, -48},
X    { -74, -52},
X    { -71, -54},
X    { -69, -51},
X    { -68, -47},
X    { -63, -43},
X    { -62, -40},
X    { -57, -37},
X    { -53, -34},
X    { -51, -32},
X    { -48, -25},
X    { -41, -22},
X    { -39, -15},
X    { -35,  -8},
X    { -42,  -3},
X    { -48,  -2},
X    { -48,  -2},
X    { -51,   0},
X    { -54,   5},
X    { -61,   8},
X    { -64,  10},
X    { -71,  11},
X    { -71,  12},
X    { -76,   9},
X    { -78,   7},
X};
Xstatic MCoord ec45[] = {
X    { -69, -53},
X    { -66, -55},
X    { -70, -55},
X    { -71, -54},
X    { -69, -53},
X};
Xstatic MCoord ec46[] = {
X    { -59, -52},
X    { -59, -52},
X};
Xstatic MCoord ec47[] = {
X    { -59, -52},
X    { -59, -52},
X};
Xstatic MCoord ec48[] = {
X    { -84,  21},
X    { -74,  20},
X    { -79,  21},
X    { -84,  22},
X    { -84,  21},
X};
Xstatic MCoord ec49[] = {
X    { -67,  18},
X    { -67,  18},
X};
Xstatic MCoord ec50[] = {
X    { -78,  17},
X    { -78,  17},
X};
Xstatic MCoord ec51[] = {
X    { -74,  18},
X    { -70,  19},
X    { -71,  18},
X    { -74,  18},
X};
Xstatic MCoord ec52[] = {
X    { -85,  74},
X    { -86,  71},
X    { -85,  72},
X    { -85,  73},
X    { -81,  73},
X    { -78,  72},
X    { -75,  73},
X    { -74,  72},
X    { -73,  71},
X    { -71,  71},
X    { -70,  70},
X    { -68,  70},
X    { -66,  69},
X    { -67,  68},
X    { -64,  68},
X    { -62,  67},
X    { -63,  65},
X    { -66,  66},
X    { -67,  65},
X    { -64,  63},
X    { -67,  63},
X    { -69,  62},
X    { -72,  64},
X    { -77,  64},
X    { -73,  66},
X    { -70,  67},
X    { -72,  67},
X    { -76,  68},
X    { -78,  70},
X    { -82,  70},
X    { -88,  70},
X    { -90,  71},
X    { -85,  74},
X};
Xstatic MCoord ec53[] = {
X    { -81,  76},
X    { -84,  76},
X    { -89,  76},
X    { -85,  77},
X    { -85,  78},
X    { -87,  79},
X    { -83,  79},
X    { -85,  80},
X    { -81,  80},
X    { -76,  81},
X    { -83,  81},
X    { -83,  81},
X    { -87,  81},
X    { -89,  81},
X    { -90,  81},
X    { -89,  82},
X    { -87,  82},
X    { -81,  82},
X    { -80,  83},
X    { -78,  83},
X    { -76,  83},
X    { -71,  83},
X    { -65,  83},
X    { -63,  82},
X    { -68,  81},
X    { -69,  80},
X    { -71,  80},
X    { -74,  79},
X    { -75,  79},
X    { -75,  79},
X    { -76,  78},
X    { -81,  77},
X    { -78,  77},
X    { -81,  76},
X};
Xstatic MCoord ec54[] = {
X    { -93,  74},
X    { -92,  73},
X    { -95,  73},
X    { -93,  74},
X};
Xstatic MCoord ec55[] = {
X    { -95,  77},
X    { -90,  76},
X    { -89,  75},
X    { -82,  76},
X    { -79,  75},
X    { -86,  74},
X    { -92,  75},
X    { -96,  77},
X    { -95,  77},
X};
Xstatic MCoord ec56[] = {
X    {-100,  74},
X    { -98,  73},
X    { -98,  71},
X    {-102,  73},
X    {-101,  73},
X    {-100,  74},
X};
Xstatic MCoord ec57[] = {
X    {-108,  73},
X    {-105,  71},
X    {-102,  70},
X    {-104,  69},
X    {-107,  69},
X    {-114,  69},
X    {-114,  70},
X    {-116,  70},
X    {-116,  71},
X    {-117,  72},
X    {-114,  72},
X    {-110,  72},
X    {-107,  72},
X    {-107,  73},
X};
Xstatic MCoord ec58[] = {
X    {-121,  74},
X    {-118,  73},
X    {-123,  71},
X    {-123,  74},
X    {-121,  74},
X};
Xstatic MCoord ec59[] = {
X    {-109,  77},
X    {-106,  76},
X    {-107,  75},
X    {-113,  74},
X    {-112,  75},
X    {-116,  75},
X    {-115,  76},
X    {-111,  76},
X    {-110,  76},
X    {-109,  77},
X};
Xstatic MCoord ec60[] = {
X    {-116,  77},
X    {-118,  76},
X    {-121,  76},
X    {-116,  77},
X};
Xstatic MCoord ec61[] = {
X    {-110,  78},
X    {-112,  78},
X    {-110,  78},
X};
Xstatic MCoord ec62[] = {
X    {-110,  78},
X    {-112,  78},
X    {-110,  78},
X};
Xstatic MCoord ec63[] = {
X    { -98,  77},
X    { -99,  75},
X    {-101,  76},
X    { -99,  76},
X    { -98,  77},
X};
Xstatic MCoord ec64[] = {
X    { -95,  76},
X    { -95,  76},
X};
Xstatic MCoord ec65[] = {
X    {-104,  79},
X    { -99,  78},
X    {-103,  78},
X    {-104,  79},
X};
Xstatic MCoord ec66[] = {
X    { -94,  78},
X    { -94,  78},
X};
Xstatic MCoord ec67[] = {
X    { -97,  79},
X    { -97,  78},
X    { -97,  78},
X};
Xstatic MCoord ec68[] = {
X    { -85,  66},
X    { -82,  64},
X    { -85,  63},
X    { -85,  66},
X};
Xstatic MCoord ec69[] = {
X    { -82,  63},
X    { -82,  63},
X};
Xstatic MCoord ec70[] = {
X    { -80,  62},
X    { -80,  62},
X};
Xstatic MCoord ec71[] = {
X    { -44,  60},
X    { -45,  61},
X    { -48,  61},
X    { -50,  62},
X    { -51,  64},
X    { -51,  65},
X    { -53,  66},
X    { -54,  67},
X    { -54,  68},
X    { -52,  69},
X    { -52,  70},
X    { -52,  71},
X    { -55,  71},
X    { -55,  73},
X    { -57,  75},
X    { -62,  76},
X    { -66,  76},
X    { -71,  77},
X    { -67,  78},
X    { -71,  78},
X    { -65,  80},
X    { -63,  81},
X    { -57,  82},
X    { -48,  82},
X    { -42,  83},
X    { -38,  84},
X    { -24,  83},
X    { -26,  82},
X    { -26,  81},
X    { -14,  81},
X    { -17,  80},
X    { -20,  79},
X    { -19,  78},
X    { -22,  76},
X    { -21,  75},
X    { -22,  74},
X    { -24,  74},
X    { -27,  73},
X    { -25,  73},
X    { -22,  72},
X    { -25,  71},
X    { -27,  71},
X    { -27,  70},
X    { -24,  69},
X    { -28,  68},
X    { -32,  69},
X    { -35,  66},
X    { -38,  66},
X    { -40,  65},
X    { -40,  64},
X    { -42,  63},
X    { -43,  61},
X    { -43,  60},
X    { -44,  60},
X};
Xstatic MCoord ec72[] = {
X    { -16,  66},
X    { -15,  64},
X    { -20,  63},
X    { -22,  64},
X    { -21,  65},
X    { -23,  66},
X    { -22,  66},
X    { -19,  66},
X    { -16,  66},
X};
Xstatic MCoord ec73[] = {
X    {   1,  51},
X    {  -2,  55},
X    {  -3,  58},
X    {  -5,  58},
X    {  -6,  56},
X    {  -3,  55},
X    {  -5,  53},
X    {  -3,  52},
X    {  -4,  50},
X    {   1,  51},
X    {   1,  51},
X};
Xstatic MCoord ec74[] = {
X    {  -7,  55},
X    { -10,  53},
X    {  -9,  52},
X    {  -6,  55},
X    {  -7,  55},
X};
Xstatic MCoord ec75[] = {
X    {  -1,  61},
X    {  -1,  60},
X};
Xstatic MCoord ec76[] = {
X    {  -6,  58},
X    {  -6,  58},
X};
Xstatic MCoord ec77[] = {
X    {  -6,  58},
X    {  -6,  58},
X};
Xstatic MCoord ec78[] = {
X    {  -7,  58},
X};
Xstatic MCoord ec79[] = {
X    {  -7,  57},
X};
Xstatic MCoord ec80[] = {
X    {  -7,  57},
X};
Xstatic MCoord ec81[] = {
X    {  -6,  56},
X};
Xstatic MCoord ec82[] = {
X    {  -5,  56},
X};
Xstatic MCoord ec83[] = {
X    {  -4,  54},
X    {  -4,  54},
X};
Xstatic MCoord ec84[] = {
X    {  -8,  71},
X    {  -8,  71},
X};
Xstatic MCoord ec85[] = {
X    {  17,  80},
X    {  22,  78},
X    {  17,  76},
X    {  16,  77},
X    {  16,  78},
X    {  17,  80},
X};
Xstatic MCoord ec86[] = {
X    {  15,  79},
X    {  16,  79},
X    {  14,  78},
X    {  14,  78},
X    {  13,  79},
X    {  15,  79},
X};
Xstatic MCoord ec87[] = {
X    {  22,  78},
X    {  22,  78},
X};
Xstatic MCoord ec88[] = {
X    {  22,  78},
X    {  24,  77},
X    {  22,  78},
X    {  23,  78},
X};
Xstatic MCoord ec89[] = {
X    {  24,  80},
X    {  28,  80},
X    {  21,  79},
X    {  19,  79},
X    {  21,  80},
X    {  23,  80},
X};
Xstatic MCoord ec90[] = {
X    {  47,  80},
X    {  43,  80},
X    {  47,  80},
X};
Xstatic MCoord ec91[] = {
X    {  50,  80},
X    {  51,  80},
X    {  48,  80},
X    {  50,  80},
X};
Xstatic MCoord ec92[] = {
X    {  62,  80},
X    {  62,  80},
X};
Xstatic MCoord ec93[] = {
X    {  65,  81},
X    {  64,  81},
X    {  65,  81},
X};
Xstatic MCoord ec94[] = {
X    {  -5,  36},
X    {   4,  37},
X    {  10,  37},
X    {  11,  34},
X    {  20,  30},
X    {  23,  32},
X    {  32,  31},
X    {  36,  24},
X    {  40,  15},
X    {  43,  11},
X    {  52,  11},
X    {  50,   7},
X    {  43,  -1},
X    {  39,  -8},
X    {  40, -13},
X    {  38, -18},
X    {  35, -23},
X    {  33, -28},
X    {  27, -34},
X    {  20, -36},
X    {  18, -31},
X    {  12, -19},
X    {  14, -13},
X    {  12,  -6},
X    {  10,   0},
X    {   7,   4},
X    {   2,   5},
X    {  -5,   5},
X    { -12,   7},
X    { -16,  11},
X    { -16,  16},
X    { -16,  22},
X    { -13,  27},
X    { -10,  31},
X    {  -5,  36},
X};
Xstatic MCoord ec95[] = {
X    {  34,   0},
X    {  33,  -3},
X    {  33,   0},
X    {  34,   0},
X};
Xstatic MCoord ec96[] = {
X    {  49, -12},
X    {  49, -19},
X    {  44, -25},
X    {  44, -20},
X    {  46, -16},
X    {  48, -14},
X    {  49, -12},
X};
Xstatic MCoord ec97[] = {
X    {  32,  31},
X    {  36,  35},
X    {  33,  36},
X    {  28,  37},
X    {  27,  39},
X    {  32,  41},
X    {  39,  40},
X    {  40,  43},
X    {  40,  46},
X    {  35,  45},
X    {  34,  45},
X    {  30,  45},
X    {  29,  41},
X    {  27,  40},
X    {  24,  40},
X    {  24,  37},
X    {  22,  37},
X    {  19,  42},
X    {  15,  44},
X    {  15,  42},
X    {  18,  40},
X    {  16,  39},
X    {  12,  42},
X    {   7,  43},
X    {   3,  41},
X    {  -1,  37},
X    {  -6,  37},
X    {  -9,  40},
X    {  -7,  43},
X    {  -1,  46},
X    {  -4,  48},
X    {   0,  49},
X    {   4,  51},
X    {   6,  53},
X    {   8,  56},
X    {  12,  55},
X    {  12,  54},
X    {  17,  54},
X    {  21,  56},
X    {  25,  57},
X    {  29,  59},
X    {  24,  60},
X    {  22,  63},
X    {  24,  65},
X    {  19,  63},
X    {  19,  60},
X    {  18,  59},
X    {  15,  56},
X    {  12,  58},
X    {   8,  58},
X    {   6,  59},
X    {   7,  61},
X    {   8,  62},
X    {  10,  63},
X    {  13,  65},
X    {  15,  67},
X    {  19,  69},
X    {  22,  70},
X    {  25,  70},
X    {  26,  70},
X    {  29,  70},
X    {  30,  70},
X    {  34,  69},
X    {  42,  67},
X    {  35,  66},
X    {  33,  66},
X    {  35,  64},
X    {  38,  64},
X    {  42,  64},
X    {  45,  66},
X    {  45,  68},
X    {  46,  67},
X    {  52,  68},
X    {  54,  68},
X    {  60,  68},
X    {  65,  69},
X    {  69,  69},
X    {  68,  71},
X    {  73,  72},
X    {  74,  68},
X    {  69,  66},
X    {  73,  66},
X    {  78,  68},
X    {  81,  67},
X    {  75,  69},
X    {  75,  72},
X    {  79,  71},
X    {  78,  72},
X    {  83,  71},
X    {  84,  70},
X    {  81,  73},
X    {  87,  74},
X    {  88,  75},
X    {  90,  75},
X};
Xstatic MCoord ec98[] = {
X    {  68,  77},
X    {  66,  76},
X    {  59,  74},
X    {  55,  73},
X    {  57,  74},
X    {  59,  75},
X    {  64,  76},
X    {  68,  77},
X};
Xstatic MCoord ec99[] = {
X    {  53,  73},
X    {  58,  70},
X    {  55,  71},
X    {  53,  72},
X    {  54,  73},
X};
Xstatic MCoord ec100[] = {
X    {  90,  21},
X    {  82,  16},
X    {  80,  12},
X    {  76,   9},
X    {  73,  17},
X    {  72,  20},
X    {  69,  22},
X    {  65,  24},
X    {  58,  25},
X    {  53,  26},
X    {  50,  29},
X    {  51,  25},
X    {  54,  23},
X    {  59,  23},
X    {  58,  19},
X    {  53,  16},
X    {  47,  13},
X    {  43,  15},
X    {  40,  20},
X    {  37,  26},
X    {  33,  28},
X    {  33,  31},
X};
Xstatic MCoord ec101[] = {
X    {  52,  47},
X    {  52,  45},
X    {  53,  42},
X    {  53,  40},
X    {  54,  38},
X    {  49,  38},
X    {  48,  43},
X    {  49,  46},
X    {  52,  47},
X};
Xstatic MCoord ec102[] = {
X    {  62,  46},
X    {  60,  43},
X    {  60,  46},
X    {  62,  46},
X};
Xstatic MCoord ec103[] = {
X    {  80,  46},
X    {  74,  44},
X    {  79,  46},
X    {  80,  46},
X};
Xstatic MCoord ec104[] = {
X    {  77,  42},
X    {  77,  42},
X};
Xstatic MCoord ec105[] = {
X    {  35,  35},
X    {  35,  35},
X    {  35,  35},
X};
Xstatic MCoord ec106[] = {
X    {  24,  35},
X    {  24,  35},
X    {  24,  35},
X};
Xstatic MCoord ec107[] = {
X    {  16,  38},
X    {  13,  38},
X    {  16,  38},
X};
Xstatic MCoord ec108[] = {
X    {  10,  41},
X    {   8,  40},
X    {   9,  41},
X};
Xstatic MCoord ec109[] = {
X    {  10,  43},
X    {  10,  42},
X};
Xstatic MCoord ec110[] = {
X    {  81,   9},
X    {  80,   6},
X    {  80,   8},
X};
Xstatic MCoord ec111[] = {
X    {  11,  57},
X    {  11,  57},
X};
Xstatic MCoord ec112[] = {
X    { -78,  25},
X    { -78,  24},
X};
Xstatic MCoord ec113[] = {
X    { -78,  24},
X    { -77,  24},
X};
Xstatic MCoord ec114[] = {
X    { -76,  24},
X    { -75,  24},
X};
Xstatic MCoord ec115[] = {
X    { -91,   0},
X    { -92,   0},
X};
Xstatic MCoord ec116[] = {
X    { -60,  47},
X    { -61,  46},
X};
Xstatic MCoord ec117[] = {
X    { -64,  49},
X    { -63,  49},
X};
Xstatic MCoord ec118[] = {
X    { 143, -11},
X    { 146, -16},
X    { 150, -22},
X    { 153, -27},
X    { 151, -35},
X    { 146, -39},
X    { 140, -38},
X    { 137, -35},
X    { 136, -35},
X    { 132, -31},
X    { 122, -34},
X    { 116, -33},
X    { 114, -26},
X    { 115, -21},
X    { 122, -18},
X    { 125, -15},
X    { 128, -15},
X    { 132, -11},
X    { 136, -12},
X    { 138, -16},
X    { 142, -11},
X};
Xstatic MCoord ec119[] = {
X    { 145, -41},
X    { 148, -42},
X    { 146, -43},
X    { 146, -41},
X};
Xstatic MCoord ec120[] = {
X    { 173, -34},
X    { 176, -38},
X    { 177, -39},
X    { 175, -38},
X    { 173, -34},
X};
Xstatic MCoord ec121[] = {
X    { 172, -41},
X    { 173, -44},
X    { 168, -46},
X    { 170, -43},
X    { 174, -41},
X};
Xstatic MCoord ec122[] = {
X    { 151, -10},
X    { 143,  -8},
X    { 138,  -7},
X    { 132,  -3},
X    { 131,  -1},
X    { 134,  -3},
X    { 141,  -3},
X    { 148,  -8},
X    { 151, -10},
X};
Xstatic MCoord ec123[] = {
X    { 117,   7},
X    { 118,   1},
X    { 114,  -3},
X    { 109,  -1},
X    { 113,   3},
X    { 117,   7},
X};
Xstatic MCoord ec124[] = {
X    {  95,   6},
X    { 102,   1},
X    { 106,  -3},
X    { 101,  -3},
X    {  95,   6},
X};
Xstatic MCoord ec125[] = {
X    { 141,  42},
X    { 141,  36},
X    { 137,  35},
X    { 134,  35},
X    { 132,  35},
X    { 137,  37},
X    { 140,  40},
X    { 141,  41},
X};
Xstatic MCoord ec126[] = {
X    { 134,  34},
X    { 131,  32},
X    { 129,  33},
X    { 134,  34},
X};
Xstatic MCoord ec127[] = {
X    { 142,  46},
X    { 144,  43},
X    { 140,  42},
X    { 142,  45},
X    { 142,  46},
X};
Xstatic MCoord ec128[] = {
X    { 143,  54},
X    { 144,  49},
X    { 142,  46},
X    { 142,  51},
X    { 143,  54},
X};
Xstatic MCoord ec129[] = {
X    { 122,  25},
X    { 121,  25},
X    { 122,  26},
X};
Xstatic MCoord ec130[] = {
X    { 111,  20},
X    { 109,  20},
X    { 111,  20},
X};
Xstatic MCoord ec131[] = {
X    { 107,  -6},
X    { 114,  -8},
X    { 109,  -8},
X    { 107,  -6},
X};
Xstatic MCoord ec132[] = {
X    { 164, -20},
X    { 164, -20},
X};
Xstatic MCoord ec133[] = {
X    { 179, -17},
X    { 179, -17},
X};
Xstatic MCoord ec134[] = {
X    { 179, -16},
X    { 179, -16},
X};
Xstatic MCoord ec135[] = {
X    {-173, -13},
X    {-173, -14},
X};
Xstatic MCoord ec136[] = {
X    { 122,  19},
X    { 123,  14},
X    { 121,  14},
X    { 120,  16},
X    { 122,  18},
X};
Xstatic MCoord ec137[] = {
X    { 125,  10},
X    { 126,   6},
X    { 122,   7},
X    { 125,   9},
X};
Xstatic MCoord ec138[] = {
X    { 120,  11},
X    { 119,  10},
X    { 120,  11},
X};
Xstatic MCoord ec139[] = {
X    {  90,  22},
X    {  94,  18},
X    {  98,  15},
X    {  98,   9},
X    { 103,   2},
X    { 100,   8},
X    { 100,  14},
X    { 104,  10},
X    { 107,  10},
X    { 108,  16},
X    { 109,  22},
X    { 113,  22},
X    { 119,  25},
X    { 121,  30},
X    { 121,  33},
X    { 122,  37},
X    { 118,  38},
X    { 122,  40},
X    { 125,  39},
X    { 126,  35},
X    { 128,  38},
X    { 130,  42},
X    { 139,  47},
X    { 141,  52},
X    { 137,  54},
X    { 141,  58},
X    { 149,  59},
X    { 154,  59},
X    { 157,  62},
X    { 160,  61},
X    { 164,  62},
X    { 156,  58},
X    { 156,  51},
X    { 162,  55},
X    { 163,  57},
X    { 164,  60},
X    { 170,  60},
X    { 177,  63},
X    { 178,  64},
X    { 179,  65},
X};
Xstatic MCoord ec140[] = {
X    {-180,  65},
X    {-177,  66},
X    {-173,  65},
X    {-171,  66},
X    {-176,  68},
X    {-179,  68},
X};
Xstatic MCoord ec141[] = {
X    { 179,  69},
X    { 170,  70},
X    { 168,  70},
X    { 160,  70},
X    { 151,  71},
X    { 147,  72},
X    { 146,  72},
X    { 140,  72},
X    { 135,  72},
X    { 131,  71},
X    { 126,  72},
X    { 129,  73},
X    { 123,  73},
X    { 113,  73},
X    { 110,  74},
X    { 108,  74},
X    { 113,  76},
X    { 106,  76},
X    { 104,  78},
X    { 100,  76},
X    {  95,  76},
X    {  90,  76},
X};
Xstatic MCoord ec142[] = {
X    { 102,  79},
X    { 101,  78},
X    { 101,  79},
X};
Xstatic MCoord ec143[] = {
X    {  94,  79},
X    { 100,  79},
X    {  95,  79},
X    {  95,  80},
X    {  97,  80},
X};
Xstatic MCoord ec144[] = {
X    {  95,  81},
X    {  92,  80},
X    {  95,  81},
X};
Xstatic MCoord ec145[] = {
X    {  91,  80},
X    {  91,  80},
X};
Xstatic MCoord ec146[] = {
X    { 139,  76},
X    { 145,  75},
X    { 140,  75},
X    { 137,  75},
X    { 138,  76},
X};
Xstatic MCoord ec147[] = {
X    { 146,  75},
X    { 148,  75},
X    { 146,  75},
X};
Xstatic MCoord ec148[] = {
X    { 141,  74},
X    { 141,  74},
X};
Xstatic MCoord ec149[] = {
X    {   0, -72},
X    {   7, -71},
X    {  15, -70},
X    {  25, -71},
X    {  33, -69},
X    {  38, -70},
X    {  43, -68},
X    {  47, -67},
X    {  49, -67},
X    {  53, -66},
X    {  58, -67},
X    {  64, -68},
X    {  71, -68},
X    {  69, -70},
X    {  76, -69},
X    {  88, -67},
X    {  95, -67},
X    { 102, -66},
X    { 111, -66},
X    { 119, -67},
X    { 126, -66},
X    { 133, -66},
X    { 140, -67},
X    { 147, -68},
X    { 154, -69},
X    { 160, -70},
X    { 164, -71},
X    { 170, -72},
X    { 166, -75},
X    { 164, -78},
X    { 162, -79},
X    { 167, -83},
X    { 176, -84},
X};
Xstatic MCoord ec150[] = {
X    {-179, -84},
X    {-148, -85},
X    {-153, -81},
X    {-154, -79},
X    {-151, -77},
X    {-147, -76},
X    {-138, -75},
X    {-132, -75},
X    {-123, -74},
X    {-115, -74},
X    {-112, -75},
X    {-105, -75},
X    {-101, -74},
X    {-101, -73},
X    {-100, -73},
X    { -93, -73},
X    { -85, -73},
X    { -80, -73},
X    { -78, -73},
X    { -72, -73},
X    { -68, -71},
X    { -68, -69},
X    { -67, -67},
X    { -64, -65},
X    { -59, -64},
X    { -60, -64},
X    { -62, -66},
X    { -62, -67},
X    { -66, -68},
X    { -64, -69},
X    { -62, -71},
X    { -61, -73},
X    { -61, -74},
X    { -63, -76},
X    { -76, -77},
X    { -83, -77},
X    { -74, -81},
X    { -56, -82},
X    { -42, -82},
X    { -32, -80},
X    { -34, -79},
X    { -32, -77},
X    { -26, -76},
X    { -17, -73},
X    { -11, -72},
X    {  -9, -72},
X    {  -5, -71},
X    {  -1, -72},
X    {   0, -72},
X};
Xstatic MCoord ec151[] = {
X    { 165, -78},
X    { 171, -77},
X    { 180, -78},
X};
Xstatic MCoord ec152[] = {
X    {-179, -78},
X    {-166, -78},
X    {-158, -78},
X};
Xstatic MCoord ec153[] = {
X    { -59, -65},
X    { -61, -69},
X    { -61, -72},
X};
Xstatic MCoord ec154[] = {
X    { -62, -75},
X    { -52, -77},
X    { -42, -78},
X    { -36, -78},
X};
Xstatic MCoord ec155[] = {
X    { -35, -78},
X    { -26, -76},
X    { -19, -73},
X    { -12, -72},
X    {  -6, -71},
X    {  -1, -69},
X    {   5, -70},
X    {  11, -70},
X    {  17, -70},
X    {  25, -70},
X    {  32, -69},
X    {  34, -70},
X};
Xstatic MCoord ec156[] = {
X    {  71, -69},
X    {  74, -70},
X};
Xstatic MCoord ec157[] = {
X    {  81, -68},
X    {  85, -66},
X    {  89, -67},
X};
Xstatic MCoord ec158[] = {
X    {-136, -75},
X    {-124, -73},
X    {-117, -74},
X    {-110, -75},
X    {-105, -75},
X    {-106, -75},
X};
Xstatic MCoord ec159[] = {
X    { -69, -70},
X    { -71, -73},
X    { -71, -72},
X    { -75, -71},
X    { -72, -71},
X    { -70, -69},
X    { -69, -70},
X};
Xstatic MCoord ec160[] = {
X    { -49, -78},
X    { -45, -79},
X    { -44, -80},
X    { -59, -80},
X    { -49, -78},
X    { -48, -78},
X};
Xstatic MCoord ec161[] = {
X    { -58, -80},
X    { -63, -80},
X    { -58, -80},
X};
Xstatic MCoord ec162[] = {
X    {-164, -79},
X    {-161, -80},
X    {-164, -79},
X};
Xstatic MCoord ec163[] = {
X    {  67,  67},
X    {  67,  67},
X};
XMRegion ereg[] = {
X    {(char *)0, ec0, 27},
X    {(char *)0, ec1, 2},
X    {(char *)0, ec2, 3},
X    {(char *)0, ec3, 2},
X    {(char *)0, ec4, 2},
X    {(char *)0, ec5, 2},
X    {(char *)0, ec6, 2},
X    {(char *)0, ec7, 2},
X    {(char *)0, ec8, 2},
X    {(char *)0, ec9, 1},
X    {(char *)0, ec10, 2},
X    {(char *)0, ec11, 2},
X    {(char *)0, ec12, 8},
X    {(char *)0, ec13, 65},
X    {(char *)0, ec14, 3},
X    {(char *)0, ec15, 2},
X    {(char *)0, ec16, 3},
X    {(char *)0, ec17, 8},
X    {(char *)0, ec18, 3},
X    {(char *)0, ec19, 3},
X    {(char *)0, ec20, 2},
X    {(char *)0, ec21, 7},
X    {(char *)0, ec22, 23},
X    {(char *)0, ec23, 2},
X    {(char *)0, ec24, 2},
X    {(char *)0, ec25, 2},
X    {(char *)0, ec26, 2},
X    {(char *)0, ec27, 2},
X    {(char *)0, ec28, 2},
X    {(char *)0, ec29, 1},
X    {(char *)0, ec30, 1},
X    {(char *)0, ec31, 6},
X    {(char *)0, ec32, 9},
X    {(char *)0, ec33, 8},
X    {(char *)0, ec34, 4},
X    {(char *)0, ec35, 5},
X    {(char *)0, ec36, 4},
X    {(char *)0, ec37, 3},
X    {(char *)0, ec38, 2},
X    {(char *)0, ec39, 3},
X    {(char *)0, ec40, 4},
X    {(char *)0, ec41, 11},
X    {(char *)0, ec42, 5},
X    {(char *)0, ec43, 9},
X    {(char *)0, ec44, 35},
X    {(char *)0, ec45, 5},
X    {(char *)0, ec46, 2},
X    {(char *)0, ec47, 2},
X    {(char *)0, ec48, 5},
X    {(char *)0, ec49, 2},
X    {(char *)0, ec50, 2},
X    {(char *)0, ec51, 4},
X    {(char *)0, ec52, 33},
X    {(char *)0, ec53, 34},
X    {(char *)0, ec54, 4},
X    {(char *)0, ec55, 9},
X    {(char *)0, ec56, 6},
X    {(char *)0, ec57, 14},
X    {(char *)0, ec58, 5},
X    {(char *)0, ec59, 10},
X    {(char *)0, ec60, 4},
X    {(char *)0, ec61, 3},
X    {(char *)0, ec62, 3},
X    {(char *)0, ec63, 5},
X    {(char *)0, ec64, 2},
X    {(char *)0, ec65, 4},
X    {(char *)0, ec66, 2},
X    {(char *)0, ec67, 3},
X    {(char *)0, ec68, 4},
X    {(char *)0, ec69, 2},
X    {(char *)0, ec70, 2},
X    {(char *)0, ec71, 54},
X    {(char *)0, ec72, 9},
X    {(char *)0, ec73, 11},
X    {(char *)0, ec74, 5},
X    {(char *)0, ec75, 2},
X    {(char *)0, ec76, 2},
X    {(char *)0, ec77, 2},
X    {(char *)0, ec78, 1},
X    {(char *)0, ec79, 1},
X    {(char *)0, ec80, 1},
X    {(char *)0, ec81, 1},
X    {(char *)0, ec82, 1},
X    {(char *)0, ec83, 2},
X    {(char *)0, ec84, 2},
X    {(char *)0, ec85, 6},
X    {(char *)0, ec86, 6},
X    {(char *)0, ec87, 2},
X    {(char *)0, ec88, 4},
X    {(char *)0, ec89, 6},
X    {(char *)0, ec90, 3},
X    {(char *)0, ec91, 4},
X    {(char *)0, ec92, 2},
X    {(char *)0, ec93, 3},
X    {(char *)0, ec94, 35},
X    {(char *)0, ec95, 4},
X    {(char *)0, ec96, 7},
X    {(char *)0, ec97, 94},
X    {(char *)0, ec98, 8},
X    {(char *)0, ec99, 5},
X    {(char *)0, ec100, 22},
X    {(char *)0, ec101, 9},
X    {(char *)0, ec102, 4},
X    {(char *)0, ec103, 4},
X    {(char *)0, ec104, 2},
X    {(char *)0, ec105, 3},
X    {(char *)0, ec106, 3},
X    {(char *)0, ec107, 3},
X    {(char *)0, ec108, 3},
X    {(char *)0, ec109, 2},
X    {(char *)0, ec110, 3},
X    {(char *)0, ec111, 2},
X    {(char *)0, ec112, 2},
X    {(char *)0, ec113, 2},
X    {(char *)0, ec114, 2},
X    {(char *)0, ec115, 2},
X    {(char *)0, ec116, 2},
X    {(char *)0, ec117, 2},
X    {(char *)0, ec118, 21},
X    {(char *)0, ec119, 4},
X    {(char *)0, ec120, 5},
X    {(char *)0, ec121, 5},
X    {(char *)0, ec122, 9},
X    {(char *)0, ec123, 6},
X    {(char *)0, ec124, 5},
X    {(char *)0, ec125, 8},
X    {(char *)0, ec126, 4},
X    {(char *)0, ec127, 5},
X    {(char *)0, ec128, 5},
X    {(char *)0, ec129, 3},
X    {(char *)0, ec130, 3},
X    {(char *)0, ec131, 4},
X    {(char *)0, ec132, 2},
X    {(char *)0, ec133, 2},
X    {(char *)0, ec134, 2},
X    {(char *)0, ec135, 2},
X    {(char *)0, ec136, 5},
X    {(char *)0, ec137, 4},
X    {(char *)0, ec138, 3},
X    {(char *)0, ec139, 40},
X    {(char *)0, ec140, 6},
X    {(char *)0, ec141, 22},
X    {(char *)0, ec142, 3},
X    {(char *)0, ec143, 5},
X    {(char *)0, ec144, 3},
X    {(char *)0, ec145, 2},
X    {(char *)0, ec146, 5},
X    {(char *)0, ec147, 3},
X    {(char *)0, ec148, 2},
X    {(char *)0, ec149, 33},
X    {(char *)0, ec150, 49},
X    {(char *)0, ec151, 3},
X    {(char *)0, ec152, 3},
X    {(char *)0, ec153, 3},
X    {(char *)0, ec154, 4},
X    {(char *)0, ec155, 12},
X    {(char *)0, ec156, 2},
X    {(char *)0, ec157, 3},
X    {(char *)0, ec158, 6},
X    {(char *)0, ec159, 7},
X    {(char *)0, ec160, 6},
X    {(char *)0, ec161, 3},
X    {(char *)0, ec162, 3},
X    {(char *)0, ec163, 2},
X};
X
Xint nereg = (sizeof(ereg)/sizeof(ereg[0]));
END_OF_FILE
  if test 28806 -ne `wc -c <'earthmap.c'`; then
    echo shar: \"'earthmap.c'\" unpacked with wrong size!
  fi
  # end of 'earthmap.c'
fi
if test -f 'earthmenu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'earthmenu.c'\"
else
  echo shar: Extracting \"'earthmenu.c'\" \(16271 characters\)
  sed "s/^X//" >'earthmenu.c' <<'END_OF_FILE'
X/* code to manage the stuff on the "earthmap" menu.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include <math.h>
X#if defined(__STDC__)
X#include <stdlib.h>
X#endif
X#include <X11/Xlib.h>
X#include <Xm/Xm.h>
X#include <Xm/Form.h>
X#include <Xm/Frame.h>
X#include <Xm/Label.h>
X#include <Xm/PushB.h>
X#include <Xm/RowColumn.h>
X#include <Xm/DrawingA.h>
X#include <Xm/Separator.h>
X#include <Xm/ToggleB.h>
X#include "astro.h"
X#include "circum.h"
X#include "map.h"
X
X#if defined(__STDC__) || defined(__cplusplus)
X#define P_(s) s
X#else
X#define P_(s) ()
X#endif
X
Xextern double mjd_day P_((double jd));
Xextern double mjd_hr P_((double jd));
Xextern int any_ison P_((void));
Xextern int obj_cir P_((Now *np, Obj *op));
Xextern void f_gangle P_((Widget w, double a));
Xextern void get_something P_((Widget w, char *resource, char *value));
Xextern void hlp_dialog P_((char *tag, char *deflt[], int ndeflt));
Xextern void precess P_((double mjd1, double mjd2, double *ra, double *dec));
Xextern void range P_((double *v, double r));
Xextern void register_selection P_((char *name));
Xextern void timestamp P_((Now *np, Widget w));
Xextern void utc_gst P_((double Mjd, double utc, double *gst));
X
Xvoid e_manage P_((void));
Xvoid e_update P_((Now *np, int force));
Xint e_ison P_((void));
Xvoid e_selection_mode P_((int whether));
Xvoid e_cursor P_((Cursor c));
Xstatic void e_create_form P_((void));
Xstatic void e_ll_cb P_((Widget w, XtPointer client, XtPointer call));
Xstatic void e_close_cb P_((Widget w, XtPointer client, XtPointer call));
Xstatic void e_help_cb P_((Widget w, XtPointer client, XtPointer call));
Xstatic void e_exp_cb P_((Widget w, XtPointer client, XtPointer call));
Xstatic void e_set_buttons P_((int whether));
Xstatic void e_subsolar P_((Now *np, double *latp, double *longp));
Xstatic void e_map P_((Now *np, double slat, double slong));
X
X#undef P_
X
X/* these are from earthmap.c */
Xextern MRegion ereg[];
Xextern int nereg;
X
Xextern Widget toplevel_w;
Xextern Now *mm_get_now();
X#define	XtD	XtDisplay(toplevel_w)
X
Xstatic int e_selecting;	/* set while our fields are being selected */
X
Xstatic Widget eform_w;	/* main form dialog */
Xstatic Widget e_long_w;	/* solar longitude numberic display widget */
Xstatic Widget e_lat_w;	/* solar latitude numberic display widget */
Xstatic Widget e_da_w;	/* map DrawingArea widget */
Xstatic Widget e_dt_w;	/* data/time stamp label widget */
X
X#define	DSIN(x)		sin(degrad(x))
X#define	DCOS(x)		cos(degrad(x))
X
Xvoid
Xe_manage()
X{
X	if (!eform_w)
X	    e_create_form();
X
X	if (XtIsManaged(eform_w))
X	    XtUnmanageChild(eform_w);
X	else {
X	    XtManageChild(eform_w);
X	    e_set_buttons(e_selecting);
X	}
X}
X
X/* display the map and lat/long info for circumstances described by *np..
X * don't bother with the computation of lat/long unless we are managed or
X *   someone cares.
X * don't bother with the map unless we are managed.
X */
Xvoid
Xe_update(np, force)
XNow *np;
Xint force;
X{
X	double slat, slong;
X
X	if (!eform_w)
X	    return;
X	if (!XtIsManaged(eform_w) && !any_ison() && !force)
X	    return;
X
X	e_subsolar (np, &slat, &slong);
X
X	if (XtIsManaged(eform_w))
X	    e_map (np, slat, slong);
X
X	f_gangle (e_lat_w, slat);
X
X	/* we want to display +W in range of -PI..+PI */
X	slong = -slong;
X	range (&slong, 2*PI);
X	if (slong >= PI)
X	    slong -= 2*PI;
X	f_gangle (e_long_w, slong);
X}
X
Xe_ison()
X{
X	return (eform_w && XtIsManaged(eform_w));
X}
X
X/* called by other menus as they want to hear from our buttons or not.
X * the ons and offs stack.
X */
Xvoid
Xe_selection_mode (whether)
Xint whether;
X{
X	e_selecting += whether ? 1 : -1;
X
X	if (e_ison())
X	    if (whether && e_selecting == 1	   /* first one to want on */
X		|| !whether && e_selecting == 0 /* first one to want off */)
X		e_set_buttons (whether);
X}
X
Xvoid
Xe_cursor(c)
XCursor c;
X{
X	Window win;
X
X	if (eform_w && (win = XtWindow(eform_w))) {
X	    Display *dsp = XtDisplay(eform_w);
X	    if (c)
X		XDefineCursor(dsp, win, c);
X	    else
X		XUndefineCursor(dsp, win);
X	}
X}
X
Xstatic void
Xe_create_form()
X{
X	static struct {
X	    char *name;
X	    void (*cb)();
X	} ctls[] = {
X	    {"Close", e_close_cb},
X	    {"Help", e_help_cb}
X	};
X	Widget w;
X	Widget fr_w;
X	Widget f_w;
X	Widget sep_w;
X	XmString str;
X	Arg args[20];
X	int n;
X	int i;
X
X	/* create form */
X	n = 0;
X	XtSetArg (args[n], XmNautoUnmanage, False); n++;
X	XtSetArg (args[n], XmNdefaultPosition, False); n++;
X	XtSetArg (args[n], XmNresizePolicy, XmRESIZE_NONE); n++;
X	XtSetArg (args[n], XmNhorizontalSpacing, 4); n++;
X	XtSetArg (args[n], XmNverticalSpacing, 4); n++;
X	eform_w = XmCreateFormDialog (toplevel_w, "Earth", args,n);
X
X	/* set some stuff in the parent DialogShell.
X	 * setting XmNdialogTitle in the Form didn't work..
X	 */
X	n = 0;
X	XtSetArg (args[n], XmNtitle, "xephem Earth subsolar view"); n++;
X	XtSetValues (XtParent(eform_w), args, n);
X
X	/* make the bottom control panel form */
X
X	n = 0;
X	XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNleftAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNrightAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNfractionBase, 9); n++;
X	XtSetArg (args[n], XmNverticalSpacing, 5); n++;
X	f_w = XmCreateForm (eform_w, "CtlF", args, n);
X	XtManageChild (f_w);
X
X	    for (i = 0; i < XtNumber(ctls); i++) {
X		n = 0;
X		XtSetArg (args[n], XmNtopAttachment, XmATTACH_FORM); n++;
X		XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X		XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X		XtSetArg (args[n], XmNleftPosition, 1+i*4); n++;
X		XtSetArg (args[n], XmNrightAttachment, XmATTACH_POSITION); n++;
X		XtSetArg (args[n], XmNrightPosition, 4+i*4); n++;
X		w = XmCreatePushButton (f_w, ctls[i].name, args, n);
X		XtManageChild (w);
X		XtAddCallback (w, XmNactivateCallback, ctls[i].cb, NULL);
X	    }
X
X	/* make a separator */
X
X	n = 0;
X	XtSetArg (args[n], XmNbottomAttachment, XmATTACH_WIDGET); n++;
X	XtSetArg (args[n], XmNbottomWidget, f_w); n++;
X	XtSetArg (args[n], XmNleftAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNrightAttachment, XmATTACH_FORM); n++;
X	sep_w = XmCreateSeparator (eform_w, "Sep", args, n);
X	XtManageChild(sep_w);
X
X	/* make the "latitude" label and push button pair */
X
X	str = XmStringCreateLtoR("Latitude (degs, +N): ",
X						    XmSTRING_DEFAULT_CHARSET);
X	n = 0;
X	XtSetArg (args[n], XmNbottomAttachment, XmATTACH_WIDGET); n++;
X	XtSetArg (args[n], XmNbottomWidget, sep_w); n++;
X	XtSetArg (args[n], XmNleftAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNalignment, XmALIGNMENT_BEGINNING); n++;
X	XtSetArg (args[n], XmNlabelString, str); n++;
X	w = XmCreateLabel (eform_w, "LatLbl", args, n);
X	XtManageChild (w);
X	XmStringFree(str);
X
X	str = XmStringCreateLtoR("-88:88:88",XmSTRING_DEFAULT_CHARSET); /*size*/
X	n = 0;
X	XtSetArg (args[n], XmNbottomAttachment, XmATTACH_WIDGET); n++;
X	XtSetArg (args[n], XmNbottomWidget, sep_w); n++;
X	XtSetArg (args[n], XmNrightAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNleftAttachment, XmATTACH_WIDGET); n++;
X	XtSetArg (args[n], XmNleftWidget, w); n++;
X	XtSetArg (args[n], XmNalignment, XmALIGNMENT_END); n++;
X	XtSetArg (args[n], XmNlabelString, str); n++;
X	XtSetArg (args[n], XmNuserData, "Earth.Lat"); n++;
X	e_lat_w = XmCreatePushButton (eform_w, "LatVal", args, n);
X	XtAddCallback (e_lat_w, XmNactivateCallback, e_ll_cb, 0);
X	XtManageChild (e_lat_w);
X	XmStringFree(str);
X
X	/* make the "Longitude" label and push button pair */
X
X	str = XmStringCreateLtoR("Longitude (degs, +W): ",
X						    XmSTRING_DEFAULT_CHARSET);
X	n = 0;
X	XtSetArg (args[n], XmNbottomAttachment, XmATTACH_WIDGET); n++;
X	XtSetArg (args[n], XmNbottomWidget, e_lat_w); n++;
X	XtSetArg (args[n], XmNleftAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNalignment, XmALIGNMENT_BEGINNING); n++;
X	XtSetArg (args[n], XmNlabelString, str); n++;
X	w = XmCreateLabel (eform_w, "LongLbl", args, n);
X	XtManageChild (w);
X	XmStringFree(str);
X
X	str = XmStringCreateLtoR("-188:88:88",XmSTRING_DEFAULT_CHARSET);/*size*/
X	n = 0;
X	XtSetArg (args[n], XmNbottomAttachment, XmATTACH_WIDGET); n++;
X	XtSetArg (args[n], XmNbottomWidget, e_lat_w); n++;
X	XtSetArg (args[n], XmNrightAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNleftAttachment, XmATTACH_WIDGET); n++;
X	XtSetArg (args[n], XmNleftWidget, w); n++;
X	XtSetArg (args[n], XmNalignment, XmALIGNMENT_END); n++;
X	XtSetArg (args[n], XmNlabelString, str); n++;
X	XtSetArg (args[n], XmNuserData, "Earth.Long"); n++;
X	e_long_w = XmCreatePushButton (eform_w, "LongVal", args, n);
X	XtAddCallback (e_long_w, XmNactivateCallback, e_ll_cb, 0);
X	XtManageChild (e_long_w);
X	XmStringFree(str);
X
X	/* make the date/time indicator label */
X
X	n = 0;
X	XtSetArg (args[n], XmNbottomAttachment, XmATTACH_WIDGET); n++;
X	XtSetArg (args[n], XmNbottomWidget, e_long_w); n++;
X	XtSetArg (args[n], XmNleftAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNrightAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNalignment, XmALIGNMENT_CENTER); n++;
X	e_dt_w = XmCreateLabel (eform_w, "DTstamp", args, n);
X	XtManageChild (e_dt_w);
X
X	/* make a drawing area in a frame on top */
X
X	n = 0;
X	XtSetArg (args[n], XmNtopAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNbottomAttachment, XmATTACH_WIDGET); n++;
X	XtSetArg (args[n], XmNbottomWidget, e_dt_w); n++;
X	XtSetArg (args[n], XmNleftAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNrightAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNshadowType, XmSHADOW_ETCHED_OUT); n++;
X	fr_w = XmCreateFrame (eform_w, "EarthFrame", args, n);
X	XtManageChild (fr_w);
X
X	    n = 0;
X	    e_da_w = XmCreateDrawingArea (fr_w, "Map", args, n);
X	    XtAddCallback (e_da_w, XmNexposeCallback, e_exp_cb, NULL);
X	    XtManageChild (e_da_w);
X}
X
X/* callback for when the lat/long buttons are activated. */
X/* ARGSUSED */
Xstatic void
Xe_ll_cb (w, client, call)
XWidget w;
XXtPointer client;
XXtPointer call;
X{
X	if (e_selecting) {
X	    char *userD;
X	    get_something (w, XmNuserData, (char *)&userD);
X	    register_selection (userD);
X	}
X}
X
X/* callback for when the Close button is activated. */
X/* ARGSUSED */
Xstatic void
Xe_close_cb (w, client, call)
XWidget w;
XXtPointer client;
XXtPointer call;
X{
X	XtUnmanageChild (eform_w);
X}
X
X/* callback from the Help button
X */
X/* ARGSUSED */
Xstatic void
Xe_help_cb (w, client, call)
XWidget w;
XXtPointer client;
XXtPointer call;
X{
X	static char *msg[] = {
X"This is a simple schematic depiction of the Earth surface at the given time.",
X"The view is from directly over the spot where the Sun is currently over head.",
X};
X
X	hlp_dialog ("Earth", msg, XtNumber(msg));
X}
X
X/* called whenever the earth drawing area gets an expose.
X */
X/* ARGSUSED */
Xstatic void
Xe_exp_cb (w, client, call)
XWidget w;
XXtPointer client;
XXtPointer call;
X{
X	XmDrawingAreaCallbackStruct *c = (XmDrawingAreaCallbackStruct *)call;
X
X	/* filter out a few oddball cases */
X	switch (c->reason) {
X	case XmCR_EXPOSE: {
X	    /* turn off gravity so we get expose events for either shrink or
X	     * expand.
X	     */
X	    static before;
X	    XExposeEvent *e = &c->event->xexpose;
X
X	    if (!before) {
X		XSetWindowAttributes swa;
X		swa.bit_gravity = ForgetGravity;
X		XChangeWindowAttributes (e->display, e->window, 
X							    CWBitGravity, &swa);
X		before = 1;
X	    }
X	    /* wait for the last in the series */
X	    if (e->count != 0)
X		return;
X	    break;
X	    }
X	default:
X	    printf ("Unexpected eform_w event. type=%d\n", c->reason);
X	    exit(1);
X	}
X
X	e_update (mm_get_now(), 1);
X}
X
X/* go through all the buttons and set whether they
X * should appear to look like buttons or just flat labels.
X */
Xstatic void
Xe_set_buttons (whether)
Xint whether;	/* whether setting up for plotting or for not plotting */
X{
X	static Arg look_like_button[] = {
X	    {XmNtopShadowColor, (XtArgVal) 0},
X	    {XmNbottomShadowColor, (XtArgVal) 0},
X	    {XmNfillOnArm, (XtArgVal) True},
X	};
X	static Arg look_like_label[] = {
X	    {XmNtopShadowColor, (XtArgVal) 0},
X	    {XmNbottomShadowColor, (XtArgVal) 0},
X	    {XmNfillOnArm, (XtArgVal) False},
X	};
X	static int called;
X	Arg *ap;
X	int na;
X
X	if (!called) {
X	    /* get baseline label and shadow appearances.
X	     */
X	    Pixel topshad, botshad, bgcol;
X	    Arg args[20];
X	    int n;
X
X	    n = 0;
X	    XtSetArg (args[n], XmNtopShadowColor, &topshad); n++;
X	    XtSetArg (args[n], XmNbottomShadowColor, &botshad); n++;
X	    XtSetArg (args[n], XmNbackground, &bgcol); n++;
X	    XtGetValues (e_lat_w, args, n);
X
X	    look_like_button[0].value = topshad;
X	    look_like_button[1].value = botshad;
X	    look_like_label[0].value = bgcol;
X	    look_like_label[1].value = bgcol;
X
X	    called = 1;
X	}
X
X	if (whether) {
X	    ap = look_like_button;
X	    na = XtNumber(look_like_button);
X	} else {
X	    ap = look_like_label;
X	    na = XtNumber(look_like_label);
X	}
X
X	XtSetValues (e_lat_w, ap, na);
X	XtSetValues (e_long_w, ap, na);
X}
X
X/* return the long and lat of the subsolar point (where the sun is directly
X * overhead) at np.
X * both are in rads, lat is +N, long is +E.
X */
Xstatic void
Xe_subsolar(np, latp, longp)
XNow *np;
Xdouble *latp, *longp;
X{
X	Obj o;
X	double gst;
X
X	o.type = PLANET;
X	o.pl.code = SUN;
X
X	if (obj_cir (np, &o) < 0) {
X	    printf ("e_subsolar(): can't get sun loc\n");
X	    exit (1);
X	}
X	if (epoch != EOD) {
X	    double tra = o.s_ra, tdec = o.s_dec;
X	    precess (epoch, mjd, &tra, &tdec);
X	    o.s_ra = tra;
X	    o.s_dec = tdec;
X	}
X
X	*latp = o.s_dec;
X
X	utc_gst (mjd_day(mjd), mjd_hr(mjd), &gst);
X	*longp =  o.s_ra - hrrad(gst);	/* remember: we want +E */
X}
X
X/* draw map centered at slat/slong.
X * each in rads, slat is +N, slong is +E.
X */
Xstatic void
Xe_map (np, slat, slong)
XNow *np;
Xdouble slat, slong;
X{
X#define	CRAD		20		/* cross radius, pixels */
X#define	COAST_LW	2		/* line_width for drawing coast lines */
X#define	CROSS_LW	0		/* line_width for drawing the cross */
X#define	LINE_ST		LineSolid
X#define	CAP_ST		CapRound
X#define	JOIN_ST		JoinRound
X	static unsigned long last_w, last_h;
X	static Pixmap e_pm;
X	static GC e_gc;
X	static Pixel e_fg, e_bg;
X	Display *dsp = XtDisplay(e_da_w);
X	Window win = XtWindow(e_da_w);
X	int x, y;
X	unsigned w, h, b, d;
X	Window root;
X	int wb, hb, r;
X	MRegion *rp;
X	MCoord *cp;
X
X	/* make the GC if this is our first time */
X	if (!e_gc) {
X	    XGCValues gcv;
X	    unsigned long gcm;
X
X	    gcm = 0;
X	    e_gc = XCreateGC (dsp, win, gcm, &gcv);
X
X	    get_something (e_da_w, XmNforeground, (char *)&e_fg);
X	    get_something (e_da_w, XmNbackground, (char *)&e_bg);
X	}
X
X	/* set up width and height borders and the radius so the
X	 * planetary sphere is a circle centered within the window.
X	 */
X	XGetGeometry (dsp, win, &root, &x, &y, &w, &h, &b, &d);
X	if (w > h) {
X	    wb = (w - h)/2;
X	    hb = 0;
X	    r = h/2;
X	} else {
X	    wb = 0;
X	    hb = (h - w)/2;
X	    r = w/2;
X	}
X
X	/* make the pixmap if this is our first time or the size has changed */
X	if (!e_pm || w != last_w || h != last_h) {
X	    last_w = w;
X	    last_h = h;
X	    if (e_pm)
X		XFreePixmap (dsp, e_pm);
X	    e_pm = XCreatePixmap (dsp, win, w, h, d);
X	}
X
X	/* clear the scene, draw filled circle in foreground then fill in
X	 * each region in background.
X	 */
X	XSetLineAttributes (dsp, e_gc, COAST_LW, LINE_ST, CAP_ST, JOIN_ST);
X	XSetForeground (dsp, e_gc, e_bg);
X	XFillRectangle (dsp, e_pm, e_gc, 0, 0, w, h);
X	XSetForeground (dsp, e_gc, e_fg);
X	XFillArc (dsp, e_pm, e_gc, wb, hb, 2*r, 2*r, 0, 360*64);
X	XSetForeground (dsp, e_gc, e_bg);
X	for (rp = ereg; rp < ereg + nereg; rp++) {
X	    XPoint xp[1024];
X	    int nxp = 0;
X	    MCoord *lastcp = rp->mcp + rp->nmcp - 1;
X	    for (cp = rp->mcp; cp <= lastcp; cp++) {
X		/* rotate to (lat,long)=(0,0) then project onto x/y plane */
X		double longp = degrad(cp->lg) - slong;
X		double z = r*cos(longp);
X		if (z > 0 && nxp < XtNumber(xp)) {
X		    double latp = degrad(cp->lt) - slat;
X		    double lx = r*sin(longp)*cos(latp);
X		    double ly = -r*sin(latp);
X		    xp[nxp].x = (int)floor(lx+0.5) + wb + r;
X		    xp[nxp].y = (int)floor(ly+0.5) + hb + r;
X		    nxp++;
X		}
X		if (z < 0 || cp == lastcp) {
X		    if (nxp > 1)
X			XDrawLines (dsp, e_pm, e_gc, xp, nxp, CoordModeOrigin);
X		    nxp = 0;
X		}
X	    }
X	}
X
X	/* draw a cross-hair in the center to mark the subsolar point */
X	XSetLineAttributes (dsp, e_gc, CROSS_LW, LINE_ST, CAP_ST, JOIN_ST);
X	XDrawLine (dsp, e_pm, e_gc, wb+r-CRAD, hb+r-CRAD, wb+r+CRAD, hb+r+CRAD);
X	XDrawLine (dsp, e_pm, e_gc, wb+r-CRAD, hb+r+CRAD, wb+r+CRAD, hb+r-CRAD);
X
X	XSetFunction (dsp, e_gc, GXcopy);
X	XCopyArea (dsp, e_pm, win, e_gc, 0, 0, w, h, 0, 0);
X
X	timestamp (np, e_dt_w);
X}
END_OF_FILE
  if test 16271 -ne `wc -c <'earthmenu.c'`; then
    echo shar: \"'earthmenu.c'\" unpacked with wrong size!
  fi
  # end of 'earthmenu.c'
fi
if test -f 'srchmenu.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'srchmenu.c'\"
else
  echo shar: Extracting \"'srchmenu.c'\" \(27491 characters\)
  sed "s/^X//" >'srchmenu.c' <<'END_OF_FILE'
X/* this file contains functions to support iterative xephem searches.
X * we support several kinds of searching and solving algorithms.
X * the expressions being evaluated are compiled and executed from compiler.c.
X */
X
X#include <stdio.h>
X#include <ctype.h>
X#include <math.h>
X#if defined(__STDC__)
X#include <stdlib.h>
X#endif
X#include <X11/Xlib.h>
X#include <Xm/Xm.h>
X#include <Xm/Form.h>
X#include <Xm/Frame.h>
X#include <Xm/Label.h>
X#include <Xm/PushB.h>
X#include <Xm/RowColumn.h>
X#include <Xm/Separator.h>
X#include <Xm/SelectioB.h>
X#include <Xm/ToggleB.h>
X#include <Xm/Text.h>
X#include "astro.h"
X#include "circum.h"
X
X#if defined(__STDC__) || defined(__cplusplus)
X#define P_(s) s
X#else
X#define P_(s) ()
X#endif
X
Xextern Now *mm_get_now P_((void));
Xextern int any_ison P_((void));
Xextern int compile_expr P_((char *ex, char *errbuf));
Xextern int execute_expr P_((double *vp, char *errbuf));
Xextern int prog_isgood P_((void));
Xextern void all_selection_mode P_((int whether));
Xextern void compiler_log P_((char *name, double value));
Xextern void f_dec_sexsign P_((double x, int *h, int *m, int *s));
Xextern void f_double P_((Widget w, char *fmt, double f));
Xextern void f_sscansex P_((char *bp, int *d, int *m, int *s));
Xextern void f_time P_((Widget w, double t));
Xextern void get_xmstring P_((Widget w, char *resource, char **txtp));
Xextern void hlp_dialog P_((char *tag, char *deflt[], int ndeflt));
Xextern void lst_selection P_((char *name));
Xextern void plt_selection P_((char *name));
Xextern void prompt_map_cb P_((Widget w, XtPointer client, XtPointer call));
Xextern void redraw_screen P_((int how_much));
Xextern void set_something P_((Widget w, char *resource, char *value));
Xextern void set_xmstring P_((Widget w, char *resource, char *txt));
Xextern void sex_dec P_((int hd, int m, int s, double *d));
Xextern void xe_msg P_((char *msg, int app_modal));
X
Xvoid srch_manage P_((void));
Xvoid srch_selection_mode P_((int whether));
Xvoid srch_selection P_((char *name));
Xint srch_eval P_((double Mjd, double *tmincp));
Xint srch_ison P_((void));
Xvoid srch_log P_((char *name, double value));
Xvoid srch_cursor P_((Cursor c));
Xstatic void srch_create_form P_((void));
Xstatic srch_isup P_((void));
Xstatic srching_now P_((void));
Xstatic void srch_set_buttons P_((int whether));
Xstatic void srch_use_cb P_((Widget w, XtPointer client, XtPointer call));
Xstatic void srch_funcactivate_cb P_((Widget w, XtPointer client, XtPointer call));
Xstatic void srch_compile_cb P_((Widget w, XtPointer client, XtPointer call));
Xstatic void srch_help_cb P_((Widget w, XtPointer client, XtPointer call));
Xstatic void srch_fields_cb P_((Widget w, XtPointer client, XtPointer call));
Xstatic void srch_close_cb P_((Widget w, XtPointer client, XtPointer call));
Xstatic void srch_acc_ok_cb P_((Widget w, XtPointer client, XtPointer call));
Xstatic void srch_acc_cb P_((Widget wid, XtPointer client, XtPointer call));
Xstatic void srch_goal_cb P_((Widget w, XtPointer client, XtPointer call));
Xstatic void srch_on_off_cb P_((Widget w, XtPointer client, XtPointer call));
Xstatic srch_minmax P_((double Mjd, double v, double *tmincp));
Xstatic srch_solve0 P_((double Mjd, double v, double *tmincp));
Xstatic srch_binary P_((double Mjd, double v, double *tmincp));
X
X#undef P_
X
Xextern Widget toplevel_w;
X#define	XtD	XtDisplay(toplevel_w)
X
X/* the widgets we need direct access to */
Xstatic Widget srchform_w;
Xstatic Widget help_w;
Xstatic Widget acc_w;
Xstatic Widget field_w;
Xstatic Widget func_w;	/* contains the search function [to be] compiled */
Xstatic Widget err_w;
Xstatic Widget compile_w;
Xstatic Widget valu_w;	/* used to display most recent calulated value */
Xstatic Widget use_w;	/* use to select srch value for use in plotting */
Xstatic Widget on_w;	/* whether searching is active comes directly from this
X			 * widget's XmToggleButtonGetState()
X			 */
X
X/* name is it appears when valu_w is selected for plotting or lising */
Xstatic char srchvname[] = "SrchValue";
X
Xstatic int (*srch_f)();		/* 0 or pointer to one of the search functions*/
Xstatic int srch_tmscalled;	/* number of iterations so far */
Xstatic double tmlimit = 1./60.;	/* search accuracy, in hrs; def is one minute */
X
Xstatic int srch_selecting;	/* whether our value is currently selectable */
Xstatic int srch_self_selection_mode;	/* flag to prevent self-selection */
X
X/* called when the search menu is activated via the main menu pulldown.
X * if never called before, create and manage all the widgets as a child of a
X * form. otherwise, just toggle whether the form is managed.
X */
Xvoid
Xsrch_manage ()
X{
X	if (!srchform_w)
X	    srch_create_form();
X	
X	if (XtIsManaged(srchform_w))
X	    XtUnmanageChild (srchform_w);
X	else {
X	    XtManageChild (srchform_w);
X	    srch_set_buttons(srch_selecting);
X	}
X}
X
X/* called by other menus as they want to hear from our buttons or not.
X * the "on"s and "off"s stack - only really redo the buttons if it's the
X * first on or the last off.
X * N.B. we cooperate with a flag from the Enable pushbutton to prevent
X *   being able use the search function result as a term in the search funtion.
X */
Xvoid
Xsrch_selection_mode (whether)
Xint whether;	/* whether setting up for plotting or for not plotting */
X{
X	if (srch_self_selection_mode)
X	    return;
X
X	srch_selecting += whether ? 1 : -1;
X
X	if (srchform_w && XtIsManaged(srchform_w))
X	    if (whether && srch_selecting == 1     /* first one to want on */
X		|| !whether && srch_selecting == 0 /* last one to want off */)
X		srch_set_buttons (whether);
X}
X
X/* called when other modules, such as data menu, have a button pushed
X * and we have asked (by enabling field buttons) that they inform us that
X * that button is to be included in the search function.
X * other modules that use buttons, such as plotting and listing, might ask
X * too so it might not really be us that wants to use it.
X */
Xvoid
Xsrch_selection (name)
Xchar *name;
X{
X	int ins;
X	char *qname;
X
X	if (!srchform_w
X		|| !XtIsManaged(srchform_w)
X		|| !XmToggleButtonGetState(field_w))
X	    return;
X
X	ins = XmTextGetInsertionPosition (func_w);
X	qname = XtMalloc (strlen(name) + 3);	/* two '"' and \0 */
X	(void) sprintf (qname, "\"%s\"", name);
X	XmTextReplace (func_w, /* from */ ins, /* to */ ins, qname);
X	XtFree (qname);
X
X	/* move the focus right back to the search menu so the insertion point
X	 * remains visible.
X	 */
X	XSetInputFocus (XtDisplay(srchform_w), XtWindow(srchform_w),
X						RevertToParent, CurrentTime);
X}
X
X/* if searching is in effect call the search type function.
X * it might modify *tmincp according to where it next wants to eval.
X * (remember tminc is in hours, not days).
X * if searching ends for any reason it is also turned off.
X * if we are not searching but are plotting or listing we still execute the
X *   search function (if it is ok) and flog and display it.
X * return 0 if caller can continue or -1 if it is time to stop.
X */
Xsrch_eval(Mjd, tmincp)
Xdouble Mjd;
Xdouble *tmincp;
X{
X	int s;
X
X	if (prog_isgood() && any_ison()) {
X	    char errbuf[128];
X	    double v;
X	    s = execute_expr (&v, errbuf);
X	    if (s == 0) {
X		f_double (valu_w, "%g", v);
X		if (srching_now()) {
X		    s = (*srch_f)(Mjd, v, tmincp);
X		    srch_tmscalled++;
X		}
X	    } else {
X		char srchmsg[256];
X		(void) sprintf (srchmsg, "Search evaluation error: %.200s",
X								    errbuf);
X		xe_msg (srchmsg, 0);
X	    }
X	} else
X	    s = 0;
X
X	if (s < 0)
X	    XmToggleButtonSetState(on_w, False, /*invoke cb*/True);
X
X	return (s);
X}
X
X/* called by other systems to decide whether it is worth computing and
X *   logging values to the search system.
X * we say True whenever there is a validly compiled function and either we are
X *   searching (obviously) or the srch control menu is up.
X */
Xsrch_ison()
X{
X	return (prog_isgood() && (srching_now() || srch_isup()));
X}
X
X/* called as each different field is written -- just tell the compiler
X * if we are interested in it.
X * we have to check if *anything* is on because we might be plotting/listing
X *   the srch function itself.
X */
Xvoid
Xsrch_log (name, value)
Xchar *name;
Xdouble value;
X{
X	if (any_ison())
X	    compiler_log (name, value);
X}
X
X/* called to put up or remove the watch cursor.  */
Xvoid
Xsrch_cursor (c)
XCursor c;
X{
X	Window win;
X
X	if (srchform_w && (win = XtWindow(srchform_w))) {
X	    Display *dsp = XtDisplay(srchform_w);
X	    if (c)
X		XDefineCursor (dsp, win, c);
X	    else
X		XUndefineCursor (dsp, win);
X	}
X}
X
Xstatic void
Xsrch_create_form()
X{
X	static struct {
X	    char *title;
X	    XtPointer cb_data;
X	} rbtb[] = {
X	    {"Find Extreme", (XtPointer)srch_minmax},
X	    {"Find 0", (XtPointer)srch_solve0},
X	    {"Binary", (XtPointer)srch_binary},
X	};
X	XmString str;
X	Widget w, rc_w, f_w, rb_w;
X	Arg args[20];
X	int i, n;
X
X	/* create form dialog */
X	n = 0;
X	XtSetArg (args[n], XmNautoUnmanage, False); n++;
X	XtSetArg (args[n], XmNdefaultPosition, False); n++;
X	srchform_w = XmCreateFormDialog (toplevel_w, "Srch", args, n);
X
X	/* set some stuff in the parent DialogShell.
X	 * setting XmNdialogTitle in the Form didn't work..
X	 */
X	n = 0;
X	XtSetArg (args[n], XmNtitle, "xephem Search Control"); n++;
X	XtSetValues (XtParent(srchform_w), args, n);
X
X	/* create a RowColumn to hold stuff */
X	n = 0;
X	XtSetArg (args[n], XmNtopAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNleftAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNrightAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNisAligned, False); n++;
X	XtSetArg (args[n], XmNadjustMargin, False); n++;
X	rc_w = XmCreateRowColumn (srchform_w, "SrchRC", args, n);
X	XtManageChild (rc_w);
X
X	/* searching on/off toggle button */
X
X	n = 0;
X	on_w = XmCreateToggleButton (rc_w, "Searching is Active", args, n);
X	XtAddCallback (on_w, XmNvalueChangedCallback, srch_on_off_cb, 0);
X	XtManageChild (on_w);
X
X	/* create a separator */
X
X	n = 0;
X	w = XmCreateSeparator (rc_w, "Sep1", args, n);
X	XtManageChild (w);
X
X	/* compiler area title */
X
X	str = XmStringCreate ("Search Function:",
X						    XmSTRING_DEFAULT_CHARSET);
X	n = 0;
X	XtSetArg (args[n], XmNalignment, XmALIGNMENT_BEGINNING); n++;
X	XtSetArg (args[n], XmNlabelString, str); n++;
X	w = XmCreateLabel (rc_w, "FuncL", args, n);
X	XtManageChild (w);
X
X	/* function text.
X	 * arrange for Return to activate the Compile button.
X	 */
X
X	n = 0;
X	func_w = XmCreateText (rc_w, "SrchFunction", args, n);
X	XtAddCallback (func_w, XmNactivateCallback, srch_funcactivate_cb, NULL);
X	XtManageChild (func_w);
X
X	/* compiler message label */
X
X	n = 0;
X	XtSetArg (args[n], XmNalignment, XmALIGNMENT_BEGINNING); n++;
X	err_w = XmCreateLabel (rc_w, "SrchErrsL", args, n);
X	XtManageChild (err_w);
X	set_xmstring (err_w, XmNlabelString, " ");
X
X	/* use-fields button */
X
X	str = XmStringCreate("Enable field buttons", XmSTRING_DEFAULT_CHARSET);
X	n = 0;
X	XtSetArg (args[n], XmNlabelString, str); n++;
X	field_w = XmCreateToggleButton (rc_w, "SrchFEnable", args, n);
X	XtAddCallback (field_w, XmNvalueChangedCallback, srch_fields_cb, 0);
X	XtManageChild (field_w);
X	XmStringFree(str);
X
X	/* COMPILE push button */
X
X	n = 0;
X	XtSetArg (args[n], XmNshowAsDefault, True); n++;
X	compile_w = XmCreatePushButton (rc_w, "Compile", args, n);
X	XtAddCallback (compile_w, XmNactivateCallback, srch_compile_cb, 0);
X	XtManageChild (compile_w);
X	set_something (srchform_w, XmNdefaultButton, (char *)w);
X
X	/* create a separator */
X
X	n = 0;
X	w = XmCreateSeparator (rc_w, "Sep2", args, n);
X	XtManageChild (w);
X
X	/* create goal radio box and its toggle buttons */
X
X	str = XmStringCreate ("Search goal:", XmSTRING_DEFAULT_CHARSET);
X	n = 0;
X	XtSetArg (args[n], XmNalignment, XmALIGNMENT_BEGINNING); n++;
X	XtSetArg (args[n], XmNlabelString, str); n++;
X	w = XmCreateLabel (rc_w, "SrchRBL", args, n);
X	XtManageChild(w);
X	XmStringFree(str);
X
X	n = 0;
X	XtSetArg (args[n], XmNorientation, XmVERTICAL); n++;
X	rb_w = XmCreateRadioBox (rc_w, "SrchGoalRadioBox", args, n);
X	XtManageChild (rb_w);
X
X	    for (i = 0; i < XtNumber(rbtb); i++) {
X		n = 0;
X		str = XmStringCreate(rbtb[i].title, XmSTRING_DEFAULT_CHARSET);
X		XtSetArg (args[n], XmNlabelString, str); n++;
X		w = XmCreateToggleButton (rb_w, "SrchRBTB", args, n);
X		XtAddCallback (w, XmNvalueChangedCallback, srch_goal_cb,
X						    (XtPointer)rbtb[i].cb_data);
X		XtManageChild (w);
X		XmStringFree(str);
X	    }
X
X	/* create a separator */
X
X	n = 0;
X	w = XmCreateSeparator (rc_w, "Sep3", args, n);
X	XtManageChild (w);
X
X	/* Accuracy label and its push button in a form */
X
X	n = 0;
X	f_w = XmCreateForm (rc_w, "SrchAF", args, n);
X	XtManageChild (f_w);
X
X	    n = 0;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_FORM); n++;
X	    XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X	    XtSetArg (args[n], XmNrightAttachment, XmATTACH_FORM); n++;
X	    acc_w = XmCreatePushButton (f_w, "SrchAcc", args, n);
X	    XtAddCallback (acc_w, XmNactivateCallback, srch_acc_cb, 0);
X	    f_time (acc_w, tmlimit);
X	    XtManageChild (acc_w);
X
X	    str = XmStringCreate("Desired accuracy:", XmSTRING_DEFAULT_CHARSET);
X	    n = 0;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_FORM); n++;
X	    XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_FORM); n++;
X	    XtSetArg (args[n], XmNrightAttachment, XmATTACH_WIDGET); n++;
X	    XtSetArg (args[n], XmNrightWidget, acc_w); n++;
X	    XtSetArg (args[n], XmNalignment, XmALIGNMENT_BEGINNING); n++;
X	    XtSetArg (args[n], XmNlabelString, str); n++;
X	    w = XmCreateLabel (f_w, "SrchAccL", args, n);
X	    XmStringFree (str);
X	    XtManageChild (w);
X
X	/* create a separator */
X
X	n = 0;
X	w = XmCreateSeparator (rc_w, "Sep4", args, n);
X	XtManageChild (w);
X
X	/* current search value in a form */
X
X	n = 0;
X	f_w = XmCreateForm (rc_w, "SrchVF", args, n);
X	XtManageChild (f_w);
X
X	    n = 0;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_FORM); n++;
X	    XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X	    XtSetArg (args[n], XmNrightAttachment, XmATTACH_FORM); n++;
X	    valu_w = XmCreateLabel (f_w, "SrchValu", args, n);
X	    XtManageChild (valu_w);
X	    set_xmstring (valu_w, XmNlabelString, "");
X
X	    str = XmStringCreate ("Current value: ", XmSTRING_DEFAULT_CHARSET);
X	    n = 0;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_FORM); n++;
X	    XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_FORM); n++;
X	    XtSetArg (args[n], XmNrightAttachment, XmATTACH_WIDGET); n++;
X	    XtSetArg (args[n], XmNrightWidget, valu_w); n++;
X	    XtSetArg (args[n], XmNalignment, XmALIGNMENT_BEGINNING); n++;
X	    XtSetArg (args[n], XmNlabelString, str); n++;
X	    w = XmCreateLabel (f_w, "SrchValuL", args, n);
X	    XtManageChild (w);
X	    XmStringFree (str);
X
X	    /* add the name in the userData field in case it's plotted or
X	     * listed
X	     */
X	    set_something (valu_w, XmNuserData, srchvname);
X
X	/* button to select using for plotting. 
X	 * ONLY MANAGED WHEN WE ARE TOLD TO SELECT FOR PLOTTING.
X	 */
X
X	n = 0;
X	use_w = XmCreatePushButton (rc_w, "SrchUse", args, n);
X	XtAddCallback (use_w, XmNactivateCallback, srch_use_cb, 0);
X	set_xmstring (use_w, XmNlabelString, "Use for plotting");
X
X	/* create a separator */
X
X	n = 0;
X	w = XmCreateSeparator (rc_w, "Sep4", args, n);
X	XtManageChild (w);
X
X	/* form to hold bottom control buttons */
X
X	n = 0;
X	XtSetArg (args[n], XmNfractionBase, 7); n++;
X	f_w = XmCreateForm (rc_w, "SrchCF", args, n);
X	XtManageChild (f_w);
X
X	    n = 0;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_FORM); n++;
X	    XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, 1); n++;
X	    XtSetArg (args[n], XmNrightAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNrightPosition, 3); n++;
X	    w = XmCreatePushButton(f_w, "Close", args,n);
X	    XtManageChild (w);
X	    XtAddCallback(w, XmNactivateCallback, srch_close_cb, 0);
X
X	    n = 0;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_FORM); n++;
X	    XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, 4); n++;
X	    XtSetArg (args[n], XmNrightAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNrightPosition, 6); n++;
X	    help_w = XmCreatePushButton(f_w, "Help", args, n);
X	    XtManageChild (help_w);
X	    XtAddCallback(help_w, XmNactivateCallback, srch_help_cb, 0);
X}
X
X/* return True whenever the srch control menu is up */
Xstatic
Xsrch_isup()
X{
X	return (srchform_w && XtIsManaged(srchform_w));
X}
X
X/* return True whenever we are actually in the midst of controlling a search.
X */
Xstatic
Xsrching_now()
X{
X	return (on_w && XmToggleButtonGetState(on_w));
X}
X
X/* go through all the buttons pickable for plotting and set whether they
X * should appear to look like buttons.
X */
Xstatic void
Xsrch_set_buttons (whether)
Xint whether;	/* whether setting up for plotting or for not plotting */
X{
X	if (whether)
X	    XtManageChild (use_w);
X	else
X	    XtUnmanageChild (use_w);
X}
X
X/* callback from the "use" button.
X * if plotting or listing has put us in selecting mode, we look like a button
X * and we should inform them we have been picked.
X * otherwise, we do nothing (we didn't look like a button anyway).
X */
X/* ARGSUSED */
Xstatic void
Xsrch_use_cb (w, client, call)
XWidget w;
XXtPointer client;
XXtPointer call;
X{
X	static char msg[] =
X	    "You must first successfully compile a search\nfunction before value may be selected.";
X
X	if (srch_selecting) {
X	    if (prog_isgood()) {
X		plt_selection (srchvname);
X		lst_selection (srchvname);
X	    } else
X		xe_msg (msg, 0);
X	}
X}
X
X/* callback when Return is typed in the function text widget.
X * we just stimulate the Compile button as per Heller, pg 219.
X */
X/* ARGSUSED */
Xstatic void
Xsrch_funcactivate_cb (w, client, call)
XWidget w;
XXtPointer client;
XXtPointer call;
X{
X	XmAnyCallbackStruct *cbs = (XmAnyCallbackStruct *) call;
X
X	XtCallActionProc (compile_w, "ArmAndActivate", cbs->event, NULL, 0);
X}
X
X/* callback from the compile button.
X */
X/* ARGSUSED */
Xstatic void
Xsrch_compile_cb (w, client, call)
XWidget w;
XXtPointer client;
XXtPointer call;
X{
X	char *newexp;
X	char errbuf[256];
X
X	newexp = XmTextGetString (func_w);
X	if (compile_expr (newexp, errbuf) <  0)
X	    set_xmstring (err_w, XmNlabelString, errbuf);
X	else
X	    set_xmstring (err_w, XmNlabelString, "<no compile errors>");
X
X	XtFree (newexp);
X
X	/* as a courtesy, turn off searching if it's currently active */
X	if (XmToggleButtonGetState(on_w))
X	    XmToggleButtonSetState(on_w, False, True/*invoke cb*/);
X
X	/* compute the new function.
X	 * must update everything else first because our function uses that
X	 *   stuff in all likelihood.
X	 */
X	if (prog_isgood()) {
X	    Now *np = mm_get_now();
X	    redraw_screen(1);
X	    (void) srch_eval (mjd, (double *)NULL);
X	}
X}
X
X/* callback from the help button.
X */
X/* ARGSUSED */
Xstatic void
Xsrch_help_cb (w, client, call)
XWidget w;
XXtPointer client;
XXtPointer call;
X{
Xstatic char *help_msg[] = {
X"This menu controls the automatic searching facility. You define an arithmetic",
X"or boolean function, using most of the fields xephem displays, then xephem",
X"will automatically evaluate the function and adjust the time on each",
X"iteration to search for the goal.",
X"",
X"To perform a search:",
X"   enter a function,",
X"   compile it,",
X"   select a goal,",
X"   set the desired accuracy,",
X"   enable searching,",
X"   perform the search by stepping xephem."
X};
X
X	hlp_dialog ("Search", help_msg, sizeof(help_msg)/sizeof(help_msg[0]));
X}
X
X/* callback from the "field enable" push button.
X * inform the other menues whether we are setting up for them to tell us
X * what fields to plot.
X */
X/* ARGSUSED */
Xstatic void
Xsrch_fields_cb (w, client, call)
XWidget w;
XXtPointer client;
XXtPointer call;
X{
X	int whether = XmToggleButtonGetState(w);;
X
X	/* don't use our own result to srch with */
X	srch_self_selection_mode = 1;
X	all_selection_mode(whether);
X	srch_self_selection_mode = 0;
X}
X
X/* callback from the Close button.
X */
X/* ARGSUSED */
Xstatic void
Xsrch_close_cb (w, client, call)
XWidget w;
XXtPointer client;
XXtPointer call;
X{
X	XtUnmanageChild (srchform_w);
X}
X
X/* user typed OK to the accuracy prompt. get his new value and use it */
X/* ARGSUSED */
Xstatic void
Xsrch_acc_ok_cb (w, client, call)
XWidget w;
XXtPointer client;
XXtPointer call;
X{
X	int hrs, mins, secs;
X	char *text;
X	
X	f_dec_sexsign (tmlimit, &hrs, &mins, &secs);
X	get_xmstring(w, XmNtextString, &text);
X	f_sscansex (text, &hrs, &mins, &secs);
X	XtFree (text);
X	sex_dec (hrs, mins, secs, &tmlimit);
X	f_time (acc_w, tmlimit);
X	XtDestroyWidget (w);
X}
X
X/* callback from the accuracy-change-request pushbutton.
X * put up a prompt dialog to ask for a new value.
X */
X/* ARGSUSED */
Xstatic void
Xsrch_acc_cb (wid, client, call)
XWidget wid;
XXtPointer client;
XXtPointer call;
X{
X	Widget w, dw;
X	XmString str, title;
X	Arg args[20];
X	int n;
X	
X	str = XmStringCreate ("search accuracy (h:m:s):",
X						    XmSTRING_DEFAULT_CHARSET);
X	title = XmStringCreate ("xephem Search Accuracy",
X						    XmSTRING_DEFAULT_CHARSET);
X	n = 0;
X	XtSetArg(args[n], XmNdefaultPosition, False);  n++;
X	XtSetArg(args[n], XmNselectionLabelString, str);  n++;
X	XtSetArg(args[n], XmNdialogTitle, title);  n++;
X	dw = XmCreatePromptDialog(toplevel_w, "xephem Accuracy", args, n);
X	XtAddCallback (dw, XmNokCallback, srch_acc_ok_cb, NULL);
X	XtAddCallback (dw, XmNmapCallback, prompt_map_cb, NULL);
X	XmStringFree (str);
X	XmStringFree (title);
X
X	w = XmSelectionBoxGetChild (dw, XmDIALOG_HELP_BUTTON);
X	XtUnmanageChild (w);
X
X	XtManageChild (dw);
X
X#if XmVersion >= 1001
X	w = XmSelectionBoxGetChild (dw, XmDIALOG_TEXT);
X	XmProcessTraversal (w, XmTRAVERSE_CURRENT);
X	XmProcessTraversal (w, XmTRAVERSE_CURRENT); /* yes, twice!! */
X#endif
X}
X
X/* callback from the search goal selection radio buttons.
X * same callback used for all of them.
X * client is pointer to desired search function.
X */
X/* ARGSUSED */
Xstatic void
Xsrch_goal_cb(w, client, call)
XWidget w;
XXtPointer client;
XXtPointer call;
X{
X	int (*sfp)()= (int (*)())client;
X
X	if (XmToggleButtonGetState(w)) {
X	    /* better turn off searching if changing the search function! */
X	    if (srch_f != sfp && srching_now())
X		XmToggleButtonSetState(on_w, False, True /* invoke cb */);
X	    srch_f = sfp;
X	}
X}
X
X/* callback from the on/off toggle button activate.
X */
X/* ARGSUSED */
Xstatic void
Xsrch_on_off_cb(w, client, call)
XWidget w;
XXtPointer client;
XXtPointer call;
X{
X	static char *msg =
X	    "You must first successfully compile a search function and\n select a goal algorithm before searching may be enabled.";
X
X	if (XmToggleButtonGetState(w)) {
X	    /* insure there is a valid function and goal algorithm selected
X	     * if turning searching on.
X	     */
X	    if (!prog_isgood()) {
X		XmToggleButtonSetState(on_w, False, True/* invoke cb */);
X		xe_msg (msg, 0);
X		 
X	    } else if (srch_f == 0) {
X		XmToggleButtonSetState(on_w, False, True/* invoke cb */);
X		xe_msg (msg, 0);
X	    } else {
X		srch_tmscalled = 0;
X		/* turning on searhing so as a courtesy turn off the
X		 * field selection mechanism if it's on now.
X		 */
X		if (XmToggleButtonGetState(field_w))
X		    XmToggleButtonSetState(field_w, False, True);
X	    }
X	}
X}
X
X/* use successive paraboloidal fits to find when expression is at a
X * local minimum or maximum.
X */
Xstatic
Xsrch_minmax(Mjd, v, tmincp)
Xdouble Mjd;
Xdouble v;
Xdouble *tmincp;
X{
X	static double base;		/* for better stability */
X	static double x_1, x_2, x_3;	/* keep in increasing order */
X	static double y_1, y_2, y_3;
X	double xm, a, b;
X
X	if (srch_tmscalled == 0) {
X	    base = Mjd;
X	    x_1 = 0.0;
X	    y_1 = v;
X	    return (0);
X	}
X	Mjd -= base;
X	if (srch_tmscalled == 1) {
X	    /* put in one of first two slots */
X	    if (Mjd < x_1) {
X	        x_2 = x_1;  y_2 = y_1;
X		x_1 = Mjd; y_1 = v;
X	    } else {
X		x_2 = Mjd; y_2 = v;
X	    }
X	    return (0);
X	}
X	if (srch_tmscalled == 2 || fabs(Mjd - x_1) < fabs(Mjd - x_3)) {
X	    /* closer to x_1 so discard x_3.
X	     * or if it's our third value we know to "discard" x_3.
X	     */
X	    if (Mjd > x_2) {
X		x_3 = Mjd; y_3 = v;
X	    } else {
X		x_3 = x_2;  y_3 = y_2;
X		if (Mjd > x_1) {
X		    x_2 = Mjd; y_2 = v;
X		} else {
X		    x_2 = x_1;  y_2 = y_1;
X		    x_1 = Mjd; y_1 = v;
X		}
X	    }
X	    if (srch_tmscalled == 2)
X		return (0);
X	} else {
X	    /* closer to x_3 so discard x_1 */
X	    if (Mjd < x_2) {
X		x_1 = Mjd;  y_1 = v;
X	    } else {
X		x_1 =  x_2;  y_1 = y_2;
X		if (Mjd < x_3) {
X		    x_2 = Mjd; y_2 = v;
X		} else {
X		    x_2 =  x_3; y_2 = y_3;
X		    x_3 = Mjd; y_3 = v;
X		}
X	    }
X	}
X
X#ifdef TRACEMM
X	{ char buf[NC];
X	  (void) sprintf (buf, "x_1=%g y_1=%g x_2=%g y_2=%g x_3=%g y_3=%g",
X						x_1, y_1, x_2, y_2, x_3, y_3);
X	  xe_msg (buf,0);
X	}
X#endif
X	a = y_1*(x_2-x_3) - y_2*(x_1-x_3) + y_3*(x_1-x_2);
X	if (fabs(a) < 1e-10) {
X	    /* near-0 zero denominator, ie, curve is pretty flat here,
X	     * so assume we are done enough.
X	     * signal this by forcing a 0 tminc.
X	     */
X	    *tmincp = 0.0;
X	    return (-1);
X	}
X	b = (x_1*x_1)*(y_2-y_3) - (x_2*x_2)*(y_1-y_3) + (x_3*x_3)*(y_1-y_2);
X	xm = -b/(2.0*a);
X	*tmincp = (xm - Mjd)*24.0;
X	return (fabs (*tmincp) < tmlimit ? -1 : 0);
X}
X
X/* use secant method to solve for time when expression passes through 0.
X */
Xstatic
Xsrch_solve0(Mjd, v, tmincp)
Xdouble Mjd;
Xdouble v;
Xdouble *tmincp;
X{
X	static double x0, x_1;	/* x(n-1) and x(n) */
X	static double y_0, y_1;	/* y(n-1) and y(n) */
X	double x_2;		/* x(n+1) */
X	double df;		/* y(n) - y(n-1) */
X
X	switch (srch_tmscalled) {
X	case 0: x0 = Mjd; y_0 = v; return(0);
X	case 1: x_1 = Mjd; y_1 = v; break;
X	default: x0 = x_1; y_0 = y_1; x_1 = Mjd; y_1 = v; break;
X	}
X
X	df = y_1 - y_0;
X	if (fabs(df) < 1e-10) {
X	    /* near-0 zero denominator, ie, curve is pretty flat here,
X	     * so assume we are done enough.
X	     * signal this by forcing a 0 tminc.
X	     */
X	    *tmincp = 0.0;
X	    return (-1);
X	}
X	x_2 = x_1 - y_1*(x_1-x0)/df;
X	*tmincp = (x_2 - Mjd)*24.0;
X	return (fabs (*tmincp) < tmlimit ? -1 : 0);
X}
X
X/* binary search for time when expression changes from its initial state.
X * if the change is outside the initial tminc range, then keep searching in that
X *    direction by tminc first before starting to divide down.
X */
Xstatic
Xsrch_binary(Mjd, v, tmincp)
Xdouble Mjd;
Xdouble v;
Xdouble *tmincp;
X{
X	static double lb, ub;		/* lower and upper bound */
X	static int initial_state;
X	int this_state = v >= 0.5;
X
X#define	FLUNDEF	-9e10
X
X	if (srch_tmscalled == 0) {
X	    if (*tmincp >= 0.0) {
X		/* going forwards in time so first Mjd is lb and no ub yet */
X		lb = Mjd;
X		ub = FLUNDEF;
X	    } else {
X		/* going backwards in time so first Mjd is ub and no lb yet */
X		ub = Mjd;
X		lb = FLUNDEF;
X	    }
X	    initial_state = this_state;
X	    return (0);
X	}
X
X	if (ub != FLUNDEF && lb != FLUNDEF) {
X	    if (this_state == initial_state)
X		lb = Mjd;
X	    else
X		ub = Mjd;
X	    *tmincp = ((lb + ub)/2.0 - Mjd)*24.0;
X#ifdef TRACEBIN
X	    { char buf[NC];
X	      (void) sprintf (buf, "lb=%g ub=%g tminc=%g Mjd=%g is=%d ts=%d",
X			    lb, ub, *tmincp, Mjd, initial_state, this_state);
X	      xe_msg(buf, 0);
X	    }
X#endif
X	    /* signal to stop if asking for time change less than TMLIMIT */
X	    return (fabs (*tmincp) < tmlimit ? -1 : 0);
X	} else if (this_state != initial_state) {
X	    /* gone past; turn around half way */
X	    if (*tmincp >= 0.0)
X		ub = Mjd;
X	    else
X		lb = Mjd;
X	    *tmincp /= -2.0;
X	    return (0);
X	} else {
X	    /* just keep going, looking for first state change but we keep
X	     * learning the lower (or upper, if going backwards) bound.
X	     */
X	    if (*tmincp >= 0.0)
X		lb = Mjd;
X	    else
X		ub = Mjd;
X	    return (0);
X	}
X}
END_OF_FILE
  if test 27491 -ne `wc -c <'srchmenu.c'`; then
    echo shar: \"'srchmenu.c'\" unpacked with wrong size!
  fi
  # end of 'srchmenu.c'
fi
echo shar: End of archive 16 \(of 21\).
cp /dev/null ark16isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 21 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo Building ephem.db
    cat > ephem.db.Z.uu ephem.db.Z.uu.?
    uudecode ephem.db.Z.uu
    rm ephem.db.Z.uu ephem.db.Z.uu.?
    uncompress ephem.db.Z
    echo Building skyviewmenu.c
    cat > skyviewmenu.c skyviewmenu.c.?
    rm skyviewmenu.c.?
    echo Building smallfm.xbm
    cat > smallfm.xbm smallfm.xbm.?
    rm smallfm.xbm.?
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM            | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly!      |
 "It's intuitively obvious to the most |    sources-x@imd.sterling.com
  casual observer..."                  |
