Newsgroups: comp.sources.x
From: koreth@hyperion.com (Steven Grimm)
Subject: v19i010:  workman - CD player for HP, Sun, DEC, Linux, Part02/09
Message-ID: <1993Mar9.163823.415@sparky.imd.sterling.com>
X-Md4-Signature: 4cfe15b012925505784e0fca3a4d2be6
Date: Tue, 9 Mar 1993 16:38:23 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: koreth@hyperion.com (Steven Grimm)
Posting-number: Volume 19, Issue 10
Archive-name: workman/part02
Environment: X11R5 Xview3 HP Sun Dec Linux

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 9)."
# Contents:  ANSWERS Makefile Makefile.linux bitmaps/iconmask
#   bitmaps/sink1 bitmaps/sink5 struct.h to-do workmandb.man
# Wrapped by koreth@gerbilmeister on Thu Mar  4 10:04:49 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'ANSWERS' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ANSWERS'\"
else
echo shar: Extracting \"'ANSWERS'\" \(6478 characters\)
sed "s/^X//" >'ANSWERS' <<'END_OF_FILE'
X- @(#)ANSWERS	1.5 12/17/92 -
X
XCOMMON "WORKMAN" QUESTIONS (with answers!)
X
X1. Why doesn't it play through the workstation's speaker?
X2. How do I label several tracks in a row as part of the same song?
X3. Can different tracks be by different artists?
X4. Why does it eat more and more memory as it runs?
X5. Why do I have to type all that information in?  Isn't it on the CD?
X6. Why doesn't WorkMan recognize a CD I know is in the database?
X7. How do I get the controls to stop moving up and down?
X
X---
X1. Why doesn't it play through the workstation's speaker?
X
XThe short answer: Because it can't.  The CD-ROM drive provides no way to read
Xthe audio data from the CD to the computer.  This is a limitation in the
Xhardware.  The workaround is to run an audio patch cable (available at any
Xdecent stereo store) from the drive's headphone jack to the workstation's
Xaudio input; then run "cat /dev/audio > /dev/audio" (on Suns; you'll need
Xto do something else on other machines).
X
X---
X2. How do I label several tracks in a row as part of the same song?
X
XThere are several special symbols you can put into a track title to alter
Xaspects of the main window's display.  The most important is "//" (two
Xforward slashes in a row.)  This splits the title up into segments.  Usually,
Xeach segment is displayed on its own line in the main window; a common use
Xis to enter titles that are too big to fit on one line.  For instance,
Xyou might enter a title like:
X
XThe really really really really really//really really really long song
X
XThat would add a second line of track title information to the main window,
Xwith the text after the "//"; the text before "//" would go on the first
Xline of the window.  The "//" itself is never displayed.  If you leave out
Xthe "//" and just enter the long song title, the program will do its best
Xto break the title into separate segments automatically.
X
XIf a segment starts with "+", the rest of the text in the segment is displayed
Xin place of the disc name on the main window.  This is most often used when
Xseveral tracks are related in some way (such as movements of a symphony.)
XFor example, you might enter:
X
X+Symphony No. 2, op. 40//Allegro assai
X
XThat title line has two segments.  The second segment is displayed as the
Xtrack title.  Since the first segment begins with "+", the CD's title is
Xreplaced with "Symphony No. 2, op. 40" while the track in question is
Xplaying.
X
XAs a shortcut, if a segment contains only a "+" character and nothing
Xelse, the "+" segment from the previous track is used.  So you might
Xhave a group of tracks labeled:
X
X+Piano concerto in G//Allegro
X+//Andante
XPresto//+
X+//Allegro assai - Andante -//Moderato marcato
X
XThe third line is to demonstrate that the order of segments isn't important;
X"+" can come anywhere.  The fourth track has the "Piano concerto in G"
Xtitle, as well as a two-line track title.
X
XIf you're not sure what the result will look like when you enter a
Xtitle with several segments, just click on the track's selector button
Xon the main window and the title will be displayed, even if the CD isn't
Xplaying.
X
X---
X3. Can different tracks be by different artists?
X
XYes, using the same facilities described in answer #2.  There is a second
Xspecial character that can come at the front of a segment, "@".  It causes
Xthe artist name on the main window display to be replaced with the rest of
Xthe text in the segment while the track in question is playing.
X
X"@" behaves in much the same way as "+" (e.g. if it's alone in a segment,
Xthe previous track's "@" segment is used.)
X
XA compilation CD's track titles might look like this:
X
X@Charles Gounod//+Ballet music from "Faust"//Allegretto
X@//+//Adagio
X@//+//Allegretto
X@//+//Moderato maestoso
X@//+//Moderato con moto
X@//+//Allegretto
X@//+//Allegro vivo
X@Friedrich Smetana//Symphonic poem "The Moldau"
X@Anton Dvorak//Slavonic Dance No. 2 in E minor
X@Adolphe Adam//Overture from "If I were King"
X
X---
X4. Why does it eat more and more memory as it runs?
X
XThere is a bug in XView 3.0 (fixed in 3.0.1 and higher) that causes the
Xlibrary to lose a little bit of memory whenever an image is destroyed.
XUnfortunately, this happens twice a second while the About popup is
Xdisplayed.  If the About popup is left up overnight, the program can get
Xbigger than you might expect.  WorkMan doesn't update the About popup
Xunless it's actually displayed onscreen, so unpin (dismiss) it when
Xyou're not using it and the program will stop growing.
X
X---
X5. Why do I have to type all that information in?  Isn't it on the CD?
X
XI've heard rumors to that effect, but haven't seen definite proof one way
Xor the other.  In any case, even if the information _is_ on the CD, the
Xsoftware interface to the CD-ROM provides no mechanism for getting at it.
XSo you're stuck typing names in for now.
X
X---
X6. Why doesn't WorkMan recognize a CD I know is in the database?
X
XSometimes you'll put in a CD, and the program won't recognize it even
Xthough you know you saw it in the database.  What's likely happening is
Xthat you have a different pressing (publication run) of the CD than the
Xperson who entered it into the database.  As I understand it, when they
Xwant to make more copies of a CD, they produce a new pressing master from
Xthe audio tape.  Unfortunately, the track timings are different by a
Xfraction of a second when they do that -- and since WorkMan uses track
Xtimings (down to 1/75 of a second accuracy) to identify a CD, the new
Xpressing looks like a different disc.
X
XA future version of the program will let you set a control to recognize
Xclose matches; a popup saying "This CD could be XXX by XXX; is it?" will
Xappear.
X
X---
X7. How do I get the controls to stop moving up and down?
X
XThe window size changes as the program displays different track titles
Xand other things.  If you start the program with the "-geometry" option
Xand give a negative number for the Y coordinate, the bottom of the window
Xwill be fixed in place and the controls won't move around.  Note that
Xyou should specify only the window position, and not the size.  For
Xexample,
X
Xworkman -geometry -0-500
X
Xwould pop the window up on the right side of the screen, about halfway
Xup (on screens of typical resolution.)  "-0-0" will put the window
Xslightly off the bottom of the screen because there's no way to tell how
Xtall the window manager's decorations are.  Play with the numbers until
Xthe WorkMan window pops up where you want it; under olwm version 3,
X"-0-38" will put the window in the lower right corner.
END_OF_FILE
if test 6478 -ne `wc -c <'ANSWERS'`; then
    echo shar: \"'ANSWERS'\" unpacked with wrong size!
fi
# end of 'ANSWERS'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(4696 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# @(#)Makefile	1.44 3/4/93
X
X# Uncomment the following if you're compiling on Solaris 2.  It adds an option
X# (-o) and changes the default device name of the CD-ROM.
X#SOL2 = -DSYSV
X
X# Set these to the locations of your XView include files and libraries.
XINCDIR = $(OPENWINHOME)/include
XLIBDIR = $(OPENWINHOME)/lib
X
X# If your linker supports the -R flag to set a default location for
X# shared libraries, uncomment this line.
X#LIBLOC = -R$(LIBDIR)
X
X# Set these to the directory names in which to install the software and
X# help files.
XBINDIR = $(OPENWINHOME)/bin
XHLPDIR = $(OPENWINHOME)/lib/help
X
X# Set this to the directory containing manual pages.  Manual pages will only
X# be installed if you "make install.man".
XMANDIR = $(OPENWINHOME)/man
X
X# Set these to the manual sections (e.g. 1, 4, 5, l) for the program and
X# database file manual pages, respectively.
XPEXT = 1
XDEXT = 5
X
X# And don't worry about anything from this line on.
X
X############################################################################
X# Parameters.
X
XPROGRAM = workman
XSOURCES.c = workman_stubs.c database.c hardware.c cdinfo.c display.c setup.c \
X	ui_cdinfo.c
XSOURCES.h = struct.h workman_ui.h
X
XOBJECTS = \
X	$(SOURCES.c:%.c=%.o)
X
X# Compiler flags.
X
XCFLAGS = -O
XCPPFLAGS = -I$(INCDIR) $(SOL2)
XLDFLAGS = -L$(LIBDIR) $(LIBLOC)
XLDLIBS = -lxview -lolgx -lX11 -ldl
XCC = cc
X
X# Standard targets.
X
Xall:	 $(PROGRAM) $(PROGRAM).doc workmandb.doc
X
X$(PROGRAM): $(SOURCES.c) $(OBJECTS)
X	$(CC) $(LDFLAGS) -o $@ $(OBJECTS) $(LDLIBS)
X
Xclean:
X	$(RM) $(OBJECTS) *.BAK *.delta core
X
Xinstall: $(PROGRAM)
X	cp $(PROGRAM) $(BINDIR)
X	chmod 755 $(BINDIR)/$(PROGRAM)
X	cp $(PROGRAM).info $(HLPDIR)
X	chmod 644 $(HLPDIR)/$(PROGRAM).info
X
Xinstall.man: workman.man workmandb.man $(MANDIR)/man$(PEXT) $(MANDIR)/man$(DEXT)
X	cp workman.man $(MANDIR)/man$(PEXT)/workman.$(PEXT)
X	chmod 644 $(MANDIR)/man$(PEXT)/workman.$(PEXT)
X	cp workmandb.man $(MANDIR)/man$(DEXT)/workmandb.$(DEXT)
X	chmod 644 $(MANDIR)/man$(DEXT)/workmandb.$(DEXT)
X
Xdisplay.o: display.c workman_ui.h
Xsetup.o: setup.c workman_ui.h
Xworkman_stubs.o: workman_stubs.c workman_ui.h
Xui_cdinfo.o: ui_cdinfo.c workman_ui.h
X# This next one isn't completely true, but close enough
X$(OBJECTS): struct.h
X
X$(PROGRAM).doc: $(PROGRAM).man
X	nroff -man $(PROGRAM).man > $(PROGRAM).doc
Xworkmandb.doc: workmandb.man
X	nroff -man workmandb.man > workmandb.doc
X
X#
X# These targets are for building the shar distribution.
X#
Xshar: part01
Xtar: WorkMan.tar
X
XALLSOURCES= README README.ultrix README.hpux README.linux ANSWERS INSTALLATION \
X	to-do $(PROGRAM)_ui.h \
X	$(PROGRAM).man $(PROGRAM).doc $(SOURCES.c) workmandb.man workmandb.doc \
X	CHANGELOG struct.h bitmaps \
X	$(PROGRAM).info Makefile Makefile.hpux Makefile.linux Imakefile \
X	WorkMan.tmpl
XALLFILES= $(ALLSOURCES) \
X	bitmaps/loud.icon bitmaps/loud0.icon \
X	bitmaps/loud1.icon bitmaps/loud2.icon bitmaps/loud3.icon \
X	bitmaps/loud4.icon bitmaps/loud5.icon bitmaps/loud6.icon \
X	bitmaps/phones bitmaps/phones0 bitmaps/phonesl1 bitmaps/phonesl2 \
X	bitmaps/phonesl3 bitmaps/phonesr1 bitmaps/phonesr2 bitmaps/phonesr3 \
X	bitmaps/sink0 bitmaps/sink1 bitmaps/sink2 bitmaps/sink3 \
X	bitmaps/sink4 bitmaps/sink5 bitmaps/sink6 bitmaps/sink7 \
X	bitmaps/eject.button bitmaps/ff.button \
X	bitmaps/icon bitmaps/iconmask bitmaps/pause.button \
X	bitmaps/play.button bitmaps/rew.button bitmaps/stop.button
X
Xpart01: $(ALLFILES)
X	makekit -s 50k -n part $(ALLFILES)
XWorkMan.tar: $(ALLSOURCES)
X	(cd ..; tar cvFf workman/WorkMan.tar `(for i in $(ALLSOURCES); do \
X		echo $$i; done) | sed 's@^@workman/@'`)
X
X#
X# The following builds a compressed tarfile for binary distribution.
X# It will require a little hacking to use on machines other than mine.
X#
XAUXDIR = /tmp
X
XAUXSTUFF = $(AUXDIR)/$(PROGRAM) $(AUXDIR)/ANSWERS \
X	$(AUXDIR)/$(PROGRAM).info $(AUXDIR)/CHANGELOG $(AUXDIR)/$(PROGRAM).doc \
X	$(AUXDIR)/$(PROGRAM).man $(AUXDIR)/workmandb.man $(AUXDIR)/workmandb.doc
X
Xtarfile: $(AUXDIR)/$(PROGRAM).tar.Z
X
X$(AUXDIR)/$(PROGRAM).tar.Z: $(AUXSTUFF)
X	cd $(AUXDIR); tar cf - $(PROGRAM) \
X		$(PROGRAM).info CHANGELOG $(PROGRAM).man $(PROGRAM).doc \
X		workmandb.man workmandb.doc ANSWERS | \
X		compress > $@
X	chmod 644 $@
X
X$(AUXDIR)/$(PROGRAM): $(PROGRAM)
X	cp $(PROGRAM) $@
X	chmod 755 $@
X$(AUXDIR)/$(PROGRAM).info: $(PROGRAM).info
X	cp $(PROGRAM).info $(AUXDIR)
X	chmod 644 $@
X$(AUXDIR)/ANSWERS: ANSWERS
X	cp ANSWERS $@
X	chmod 644 $@
X$(AUXDIR)/CHANGELOG: CHANGELOG
X	cp CHANGELOG $@
X	chmod 644 $@
X$(AUXDIR)/workmandb.man: workmandb.man
X	cp workmandb.man $@
X	chmod 644 $@
X$(AUXDIR)/workmandb.doc: workmandb.doc
X	cp workmandb.4 $@
X	chmod 644 $@
X$(AUXDIR)/$(PROGRAM).man: $(PROGRAM).man
X	cp $(PROGRAM).man $@
X	chmod 644 $@
X$(AUXDIR)/$(PROGRAM).doc: $(PROGRAM).doc
X	cp $(PROGRAM).1 $@
X	chmod 644 $@
END_OF_FILE
if test 4696 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'Makefile.linux' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.linux'\"
else
echo shar: Extracting \"'Makefile.linux'\" \(4565 characters\)
sed "s/^X//" >'Makefile.linux' <<'END_OF_FILE'
X# @(#)Makefile.linux	1.2 3/4/93
X
X# Uncomment the following if you're compiling on Solaris 2.  It adds an option
X# (-o) and changes the default device name of the CD-ROM.
X#SOL2 = -DSYSV
X
X# Set these to the locations of your XView include files and libraries.
XINCDIR = $(OPENWINHOME)/include
XLIBDIR = $(OPENWINHOME)/lib
X
X# Location of the X libraries
XXLIBDIR = /usr/X386/lib
X
X# If your linker supports the -R flag to set a default location for
X# shared libraries, uncomment this line.
X#LIBLOC = -R$(LIBDIR)
X
X# Set these to the directory names in which to install the software and
X# help files.
XBINDIR = $(OPENWINHOME)/bin
XHLPDIR = $(OPENWINHOME)/lib/help
X
X# Set this to the directory containing manual pages.  Manual pages will only
X# be installed if you "make install.man".
XMANDIR = $(OPENWINHOME)/man
X
X# Set these to the manual sections (e.g. 1, 4, 5, l) for the program and
X# database file manual pages, respectively.
XPEXT = 1
XDEXT = 5
X
X# And don't worry about anything from this line on.
X
X############################################################################
X# Parameters.
X
XPROGRAM = workman
XSOURCES.c = workman_stubs.c database.c hardware.c cdinfo.c display.c setup.c \
X	ui_cdinfo.c
XSOURCES.h = struct.h workman_ui.h
X
XOBJECTS = \
X	$(SOURCES.c:%.c=%.o)
X
X# Compiler flags.
X
XCFLAGS = -O2 -m486 -Dlinux
XCPPFLAGS = -I$(INCDIR) $(SOL2)
XLDFLAGS = -L$(LIBDIR) -L$(XLIBDIR) $(LIBLOC)
XLDLIBS = -lxview -lolgx -lX11
XCC = gcc
X
X# Standard targets.
X
Xall:	 $(PROGRAM) $(PROGRAM).doc workmandb.doc
X
X$(PROGRAM): $(SOURCES.c) $(OBJECTS)
X	$(CC) $(LDFLAGS) -o $@ $(OBJECTS) $(LDLIBS)
X
Xclean:
X	$(RM) $(OBJECTS) *.BAK *.delta core
X
Xinstall: $(PROGRAM)
X	cp $(PROGRAM) $(BINDIR)
X	chmod 755 $(BINDIR)/$(PROGRAM)
X	cp $(PROGRAM).info $(HLPDIR)
X	chmod 644 $(HLPDIR)/$(PROGRAM).info
X
Xinstall.man: workman.man workmandb.man $(MANDIR)/man$(PEXT) $(MANDIR)/man$(DEXT)
X	cp workman.man $(MANDIR)/man$(PEXT)/workman.$(PEXT)
X	chmod 644 $(MANDIR)/man$(PEXT)/workman.$(PEXT)
X	cp workmandb.man $(MANDIR)/man$(DEXT)/workmandb.$(DEXT)
X	chmod 644 $(MANDIR)/man$(DEXT)/workmandb.$(DEXT)
X
Xdisplay.o: display.c workman_ui.h
Xsetup.o: setup.c workman_ui.h
Xworkman_stubs.o: workman_stubs.c workman_ui.h
Xui_cdinfo.o: ui_cdinfo.c workman_ui.h
X# This next one isn't completely true, but close enough
X$(OBJECTS): struct.h
X
X$(PROGRAM).doc: $(PROGRAM).man
X	nroff -man $(PROGRAM).man > $(PROGRAM).doc
Xworkmandb.doc: workmandb.man
X	nroff -man workmandb.man > workmandb.doc
X
X#
X# These targets are for building the shar distribution.
X#
Xshar: part01
X
XALLFILES= README README.ultrix README.hpux ANSWERS INSTALLATION to-do \
X	$(PROGRAM)_ui.h \
X	$(PROGRAM).man $(PROGRAM).doc $(SOURCES.c) workmandb.man workmandb.doc \
X	CHANGELOG struct.h bitmaps bitmaps/loud.icon bitmaps/loud0.icon \
X	bitmaps/loud1.icon bitmaps/loud2.icon bitmaps/loud3.icon \
X	bitmaps/loud4.icon bitmaps/loud5.icon bitmaps/loud6.icon \
X	bitmaps/phones bitmaps/phones0 bitmaps/phonesl1 bitmaps/phonesl2 \
X	bitmaps/phonesl3 bitmaps/phonesr1 bitmaps/phonesr2 bitmaps/phonesr3 \
X	bitmaps/sink0 bitmaps/sink1 bitmaps/sink2 bitmaps/sink3 \
X	bitmaps/sink4 bitmaps/sink5 bitmaps/sink6 bitmaps/sink7 \
X	bitmaps/eject.button bitmaps/ff.button \
X	bitmaps/icon bitmaps/iconmask bitmaps/pause.button \
X	bitmaps/play.button bitmaps/rew.button bitmaps/stop.button \
X	$(PROGRAM).info Makefile Makefile.hpux Imakefile WorkMan.tmpl
X
Xpart01: $(ALLFILES)
X	makekit -s 60k -n part $(ALLFILES)
X
X#
X# The following builds a compressed tarfile for binary distribution.
X# It will require a little hacking to use on machines other than mine.
X#
XAUXDIR = /tmp
X
XAUXSTUFF = $(AUXDIR)/$(PROGRAM) $(AUXDIR)/ANSWERS \
X	$(AUXDIR)/$(PROGRAM).info $(AUXDIR)/CHANGELOG $(AUXDIR)/$(PROGRAM).doc \
X	$(AUXDIR)/$(PROGRAM).man $(AUXDIR)/workmandb.man $(AUXDIR)/workmandb.doc
X
Xtarfile: $(AUXDIR)/$(PROGRAM).tar.Z
X
X$(AUXDIR)/$(PROGRAM).tar.Z: $(AUXSTUFF)
X	cd $(AUXDIR); tar cf - $(PROGRAM) \
X		$(PROGRAM).info CHANGELOG $(PROGRAM).man $(PROGRAM).doc \
X		workmandb.man workmandb.doc ANSWERS | \
X		compress > $@
X	chmod 644 $@
X
X$(AUXDIR)/$(PROGRAM): $(PROGRAM)
X	cp $(PROGRAM) $@
X	chmod 755 $@
X$(AUXDIR)/$(PROGRAM).info: $(PROGRAM).info
X	cp $(PROGRAM).info $(AUXDIR)
X	chmod 644 $@
X$(AUXDIR)/ANSWERS: ANSWERS
X	cp ANSWERS $@
X	chmod 644 $@
X$(AUXDIR)/CHANGELOG: CHANGELOG
X	cp CHANGELOG $@
X	chmod 644 $@
X$(AUXDIR)/workmandb.man: workmandb.man
X	cp workmandb.man $@
X	chmod 644 $@
X$(AUXDIR)/workmandb.doc: workmandb.doc
X	cp workmandb.4 $@
X	chmod 644 $@
X$(AUXDIR)/$(PROGRAM).man: $(PROGRAM).man
X	cp $(PROGRAM).man $@
X	chmod 644 $@
X$(AUXDIR)/$(PROGRAM).doc: $(PROGRAM).doc
X	cp $(PROGRAM).1 $@
X	chmod 644 $@
END_OF_FILE
if test 4565 -ne `wc -c <'Makefile.linux'`; then
    echo shar: \"'Makefile.linux'\" unpacked with wrong size!
fi
# end of 'Makefile.linux'
fi
if test -f 'bitmaps/iconmask' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/iconmask'\"
else
echo shar: Extracting \"'bitmaps/iconmask'\" \(2190 characters\)
sed "s/^X//" >'bitmaps/iconmask' <<'END_OF_FILE'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0400,	0x0000,	0x0C00,
X	0x0000,	0x0700,	0x0000,	0x0F00,
X	0x0700,	0x0780,	0x0000,	0x0FC0,
X	0x07E0,	0x0480,	0x0000,	0x09C0,
X	0x07E0,	0x0400,	0x0000,	0x0C40,
X	0x0460,	0x0400,	0x0000,	0x0F40,
X	0x0420,	0x0400,	0x0000,	0x0BC0,
X	0x0420,	0x1C00,	0x0000,	0x38C0,
X	0x0420,	0x3C00,	0x0000,	0x7840,
X	0x1C20,	0x3C00,	0x0000,	0x79C0,
X	0x3CE0,	0x1800,	0x0000,	0x33C0,
X	0x3DE0,	0x0000,	0x0000,	0x03C0,
X	0x19E0,	0x01FF,	0xFE00,	0x0180,
X	0x00C1,	0xFFFF,	0xFFFE,	0x0000,
X	0x001F,	0xFFFF,	0xFFFF,	0xE000,
X	0x00FF,	0xFFFF,	0xFFFF,	0xFC00,
X	0x03FF,	0xFFFF,	0xFFFF,	0xFF00,
X	0x0FFF,	0xFFFF,	0xFFFF,	0xFFC0,
X	0x1FFF,	0xFFFF,	0xFFFF,	0xFFE0,
X	0x3FFF,	0xFFE0,	0x1FFF,	0xFFF0,
X	0x3FFF,	0xFFC0,	0x0FFF,	0xFFF0,
X	0x3FFF,	0xFFE0,	0x1FFF,	0xFFF0,
X	0x3FFF,	0xFFFF,	0xFFFF,	0xFFF0,
X	0x1FFF,	0xFFFF,	0xFFFF,	0xFFE0,
X	0x0FFF,	0xFFFF,	0xFFFF,	0xFFC0,
X	0x03FF,	0xFFFF,	0xFFFF,	0xFF00,
X	0x00FF,	0xFFFF,	0xFFFF,	0xFC00,
X	0x001F,	0xFFFF,	0xFFFF,	0xE000,
X	0x0003,	0xFFFF,	0xFFFF,	0x0000,
X	0x0000,	0x03FF,	0xFF00,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x000E,	0x0000,	0x0000,
X	0x0000,	0x0004,	0x0000,	0x0000,
X	0x0000,	0x0004,	0x0000,	0x0000,
X	0x0393,	0x3969,	0xF663,	0xFB80,
X	0x0291,	0x478A,	0x2BA4,	0x9480,
X	0x0111,	0x850C,	0x3324,	0x9880,
X	0x0132,	0x890C,	0x2249,	0x1100,
X	0x0122,	0x890A,	0x2649,	0x1100,
X	0x0174,	0x9112,	0x244B,	0x7280,
X	0x0198,	0xE211,	0xC44D,	0xA300,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
END_OF_FILE
if test 2190 -ne `wc -c <'bitmaps/iconmask'`; then
    echo shar: \"'bitmaps/iconmask'\" unpacked with wrong size!
fi
# end of 'bitmaps/iconmask'
fi
if test -f 'bitmaps/sink1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/sink1'\"
else
echo shar: Extracting \"'bitmaps/sink1'\" \(2190 characters\)
sed "s/^X//" >'bitmaps/sink1' <<'END_OF_FILE'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x01C1,	0x8380,	0x0000,
X	0x0000,	0x0222,	0x4440,	0x0000,
X	0x0000,	0x0364,	0x26C0,	0x0000,
X	0x0000,	0x0144,	0x2280,	0x0000,
X	0x0000,	0x0148,	0x1280,	0x0000,
X	0x0000,	0x014E,	0x7280,	0x0000,
X	0x0000,	0x0002,	0x4000,	0x0000,
X	0x0000,	0xFFFE,	0x7FFF,	0x0000,
X	0x0000,	0x8004,	0x2001,	0x0038,
X	0x0001,	0x8004,	0x2001,	0x8044,
X	0x0001,	0x8004,	0x2001,	0x807C,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0008,	0x800F,	0xF001,	0x1038,
X	0x0008,	0x8003,	0xC001,	0x1000,
X	0x0010,	0x8001,	0x8001,	0x0800,
X	0x0010,	0xFFFE,	0x7FFF,	0x0800,
X	0x0020,	0x8001,	0x8001,	0x0400,
X	0x0020,	0x8000,	0x0000,	0x8400,
X	0x0021,	0x0000,	0x0000,	0x8400,
X	0x0041,	0x0000,	0x0000,	0x8200,
X	0x0042,	0x0000,	0x0000,	0x4200,
X	0x0082,	0x0000,	0x0000,	0x4100,
X	0x0082,	0x0007,	0xE000,	0x2100,
X	0x0104,	0x0008,	0x1000,	0x2080,
X	0x0104,	0x0008,	0x1000,	0x2080,
X	0x0204,	0x0007,	0xE000,	0x1040,
X	0x0208,	0x0000,	0x0000,	0x1040,
X	0x0408,	0x0000,	0x0000,	0x1020,
X	0x0410,	0x0000,	0x0000,	0x0820,
X	0x0810,	0x0000,	0x0000,	0x0810,
X	0x0FFF,	0xFFFF,	0xFFFF,	0xFFF0,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
END_OF_FILE
if test 2190 -ne `wc -c <'bitmaps/sink1'`; then
    echo shar: \"'bitmaps/sink1'\" unpacked with wrong size!
fi
# end of 'bitmaps/sink1'
fi
if test -f 'bitmaps/sink5' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/sink5'\"
else
echo shar: Extracting \"'bitmaps/sink5'\" \(2190 characters\)
sed "s/^X//" >'bitmaps/sink5' <<'END_OF_FILE'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x01C1,	0x8380,	0x0000,
X	0x0000,	0x0222,	0x4440,	0x0000,
X	0x0000,	0x0364,	0x26C0,	0x0000,
X	0x0000,	0x0144,	0x2280,	0x0000,
X	0x0000,	0x0148,	0x1280,	0x0000,
X	0x0000,	0x014E,	0x7280,	0x0000,
X	0x0000,	0x0002,	0x4000,	0x0000,
X	0x0000,	0xFFFE,	0x7FFF,	0x0000,
X	0x0000,	0x8004,	0x2001,	0x0038,
X	0x0001,	0x8004,	0x2001,	0x8044,
X	0x0001,	0x8004,	0x2001,	0x807C,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0008,	0x800F,	0xF001,	0x1038,
X	0x0008,	0x8003,	0xC001,	0x1000,
X	0x0010,	0x8000,	0x0001,	0x0800,
X	0x0010,	0xFFFF,	0xFFFF,	0x0800,
X	0x0020,	0x8000,	0x0001,	0x0400,
X	0x0020,	0x8000,	0x0000,	0x8400,
X	0x0021,	0x0001,	0x8000,	0x8400,
X	0x0041,	0x0001,	0x8000,	0x8200,
X	0x0042,	0x0001,	0x8000,	0x4200,
X	0x0082,	0x0002,	0x4000,	0x4100,
X	0x0082,	0x0006,	0x6000,	0x2100,
X	0x0104,	0x0009,	0x9000,	0x2080,
X	0x0104,	0x0008,	0x1000,	0x2080,
X	0x0204,	0x0007,	0xE000,	0x1040,
X	0x0208,	0x0000,	0x0000,	0x1040,
X	0x0408,	0x0000,	0x0000,	0x1020,
X	0x0410,	0x0000,	0x0000,	0x0820,
X	0x0810,	0x0000,	0x0000,	0x0810,
X	0x0FFF,	0xFFFF,	0xFFFF,	0xFFF0,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
END_OF_FILE
if test 2190 -ne `wc -c <'bitmaps/sink5'`; then
    echo shar: \"'bitmaps/sink5'\" unpacked with wrong size!
fi
# end of 'bitmaps/sink5'
fi
if test -f 'struct.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'struct.h'\"
else
echo shar: Extracting \"'struct.h'\" \(2710 characters\)
sed "s/^X//" >'struct.h' <<'END_OF_FILE'
X/* @(#)struct.h	1.13 11/12/92 */
X
X/*
X * Structure for a single track.  This is pretty much self-explanatory --
X * one of these exists for each track on the current CD.
X */
Xstruct trackinfo {
X	char	*songname;	/* Name of song, dynamically allocated */
X	char	*otherdb;	/* Unrecognized info for this track */
X	char	*otherrc;
X	int	length;		/* Length of track in seconds or Kbytes */
X	int	start;		/* Starting position (f+s*75+m*60*75) */
X	int	volume;		/* Per-track volume (1-32, 0 to disable) */
X	int	track;		/* Physical track number */
X	int	section;	/* Section number (0 if track not split) */
X	char	contd;		/* Flag: continuation of previous track */
X	char	avoid;		/* Flag: don't play this track. */
X	char	data;		/* Flag: data track */
X};
X
X/*
X * Structure for internal playlist management.  The internal playlist is
X * simply the list of track ranges that are being played currently.  This
X * is built whenever the CD starts playing; it's used in normal and shuffle
X * modes as well as playlist mode.
X *
X * The "starttime" element represents how much time has elapsed by the time
X * we get to this entry.  For instance, if the list begins with a 5-minute
X * track and a 3-minute track, the third entry would have a starttime of 8
X * minutes.  This is used so that the elapsed play time can be displayed
X * even in shuffle or playlist modes.
X *
X * The last member of the list has a start track of 0, and its starttime is
X * the total playing time of the playlist (which will usually be overestimated,
X * since we don't play leadouts in some cases.)
X */
Xstruct play {
X	int	start;		/* Start track, or 0 if end of list */
X	int	end;		/* last track plus 1 */
X	int	starttime;	/* Number of seconds elapsed previously */
X};
X
X/*
X * Structure for playlists (as seen by the user.)  This is simply a name
X * followed by a zero-terminated list of track numbers to play.  The list
X * is terminated by a NULL name.
X */
Xstruct playlist {
X	char	*name;		/* Name of this playlist */
X	int	*list;		/* List of tracks */
X};
X
Xstruct cdinfo {
X	char	artist[84];	/* Artist's name */
X	char	cdname[84];	/* Disc's name */
X	int	ntracks;	/* Number of tracks on the disc */
X	int	length;		/* Total running time in seconds */
X	int	autoplay;	/* Start playing CD immediately */
X	int	playmode;	/* How to play the CD */
X	int	volume;		/* Default volume (1-32, 0 for none) */
X	struct trackinfo *trk;	/* struct trackinfo[ntracks] */
X	struct playlist *lists;	/* User-specified playlists */
X	char	*whichdb;	/* Which database is this entry from? */
X	char	*otherdb;	/* Unrecognized lines from this entry */
X	char	*otherrc;
X};
X
X/* The global variable "cd" points to the struct for the CD that's playing. */
Xextern struct cdinfo *cd;
X
Xstruct playlist *new_list();
END_OF_FILE
if test 2710 -ne `wc -c <'struct.h'`; then
    echo shar: \"'struct.h'\" unpacked with wrong size!
fi
# end of 'struct.h'
fi
if test -f 'to-do' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'to-do'\"
else
echo shar: Extracting \"'to-do'\" \(4211 characters\)
sed "s/^X//" >'to-do' <<'END_OF_FILE'
XIn no particular order, here're the major things people have suggested or
XI have thought of:
X
X
XSplit doesn't continue to the next track in shuffle mode.
X
XYou should be able to default to shuffle mode for unknown CDs.
X
XThe user should be able to attach arbitrary data to a CD or track.  The
Xsimple stuff, like text fields (publisher, recording date, etc.) and
Xlarger pieces of text (liner notes) can be input and displayed internally
Xby WorkMan.  For more complex data (GIF pictures, music videos) the user
Xwill tell WorkMan the data type; WorkMan will have a separate database of
Xdisplay methods, so it will know "run 'xv' with the filename as an argument
Xto display images of types X, Y, and Z".  The user, naturally, will be
Xable to add data types and display methods.
X
XCheck for changes in the play mode or the current playlist (if a playlist is
Xbeing used) as each track finishes.  The user should be able to play half
Xthe disc in Normal mode, then switch to Shuffle and get the remaining tracks
Xin random order.
X
XThe HPUX version should use notify_set_input_func() to wait for a response
Xfrom the drive; that way the program won't freeze up when there's no CD.
X
XHidden/private sections.  A user should be able to split a track but ask that
Xthe split not be saved to the main database.
X
XThe program should be able to collapse to a tiny base frame with just the
Xmode selector.  Or better still, with whatever controls the user wants.
X
XShuffle mode should be independent of playlist mode -- you should be able
Xto play the tracks in a playlist in random order.
X
XWhen CD remains paused for more than X minutes, stop it, then resume from
Xthat position when it's unpaused.
X
XCheck the user's tty; if the idle time is more than X minutes, pause the
XCD (and stop it eventually as above.)
X
XAllow the main window to be resized.
X
XShow the total running time of a playlist as it's being built.
X
XTutorial mode for first-time users.
X
XUse gettext() for all labels and messages so the program can easily be
Xlocalized.
X
XOptionally display the current CD or artist name in window title bar, to save
Xscreen space.
X
XIf the user changes the volume and there's a default volume, the program
Xshould interpret the change as a percentage volume change -- e.g. if the
Xvolume is cut in half, other tracks should play at half their default
Xvolumes.  Perhaps this should be selectable from Goodies, as it might
Xsurprise people.
X
XA "mute" tool or hot-key.  This can already be built with the signal
Xinterface, so it's pretty low-priority.
X
XOptionally lose the track selection buttons in favor of a scrolling list.
XThis will allow the window to remain a constant size no matter how many
Xtracks there are.
X
XOptionally spawn off a background process when the user quits the tool; this
Xprocess will continue playing the CD according to the playlist, stopping
Xor ejecting the CD when it's done.
X
XWorkMan should handle errors in a more elegant way.  Most of the time, if a
Xsystem call fails unexpectedly, the program will print an error and exit.
XIt should pop up a notice and let the user figure out what to do.  (For
Xexample, the return value of save() is never examined.)
X
XAs described in the ANSWERS file, WorkMan needs a setting to recognize
Xdifferent pressings of a CD by allowing approximate matches.
X
XYou should be able to double-click on track title to select that track
Xfor playing.
X
XWorkMan should grab info from the CD Info popup when it's unpinned.
X
XThere needs to be a better indication of tracks played already and tracks
Xremaining to play.  A Possibility might be crossing out already-played
Xtracks' buttons with Xs (which would mean replacing the button labels with
Xdynamically-generated images.)
X
XWe need a database broswing tool.  This should probably be separate from
XWorkMan, though WorkMan might be able to invoke it.
X
XWorkMan shouldn't make assumptions about the sizes of characters in its
Xfont.  Right now, digits are assumed to all be the same width, twice as
Xwide as spaces and periods.  That's true for the Sun-supplied XView fonts,
Xbut isn't very flexible.
X
XAn interface to Radio Free Ethernet would be neat.
X
XWorkMan should accept keyboard focus, and you should be able to hit keys
Xto pause/play/stop/eject the CD.
END_OF_FILE
if test 4211 -ne `wc -c <'to-do'`; then
    echo shar: \"'to-do'\" unpacked with wrong size!
fi
# end of 'to-do'
fi
if test -f 'workmandb.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'workmandb.man'\"
else
echo shar: Extracting \"'workmandb.man'\" \(8919 characters\)
sed "s/^X//" >'workmandb.man' <<'END_OF_FILE'
X.\" @(#)workmandb.man	1.9 12/5/92
X.TH workmandb 5 "12/5/92"
X.SH NAME
Xworkmanrc, workmandb \- database and preferences files for workman
X.SH SYNOPSIS
X.B $\s-2HOME\s+2/.workmanrc
Xor value of \s-2WORKMANRC\s+2 variable
X.LP
X.B $\s-2HOME\s+2/.workmandb
Xor value(s) of \s-2WORKMANDB\s+2 variable
X.SH DESCRIPTION
X.LP
XThe \fB.workmandb\fP file stores information about compact discs.  It is
Xgenerated by
X.IR workman (1)
Xbased on user input.  Its companion file, \fB.workmanrc\fP, stores user
Xpreferences for each disc.  The distinction between the two is
Xthat \fB.workmandb\fP contains only the hard information about a CD (the disc
Xname, artist, track titles, etc.) and is often shared among several
Xusers.  \fB.workmanrc\fP, on the other hand, contains settings like the default
Xvolumes of particular tracks, the numbers of tracks to be avoided, and
Xso forth.  Each user generally maintains a private \fB.workmanrc\fP,
Xeven if a shared \fB.workmandb\fP is being used.
X.LP
XThough
X.IR workman (1)
Xstores different information in each file,
Xboth files have an identical format; most of this manual page will
Xnot distinguish between the two.  Each line of the file is of the form
X.LP
X[s-]keyword	[\fIoptional whitespace-separated arguments\fP]
X.LP
XEmpty lines are ignored.  Lines starting with unrecognized keywords are
Xretained and written back out verbatim when the database is saved.  The
Xprogram preserves the ordering of unrecognized lines, and their positions
Xrelative to the track information.  This
Xallows the database to be extended to hold any sort of information desired
Xby the user.
X.LP
XKeywords that begin with "s-" apply to sections rather than tracks.  See
Xthe \fBsections\fP keyword below.  A CD entry with "s-" keywords must
Xhave a \fBsections\fP keyword as well.  This is done for backward
Xcompatibility and will disappear eventually, and in any case only applies
Xto keywords found in \fB.workmandb\fP (the assumption is that users
Xwon't downgrade the versions they run, so \fB.workmanrc\fP doesn't need
Xto be backward-compatible.)
X.LP
XSome keywords are delimiters that modify the meanings of keywords that
Xfollow; others are position-independent and may occur anywhere in the
Xfile.  (In general, the position-independent keywords are concerned with
Xsettings for the tool as a whole, rather than for a particular disc.)
X.LP
XThe keywords, and their arguments, follow.  All numeric arguments are in
Xdecimal unless otherwise specified.
X.SS Initial Keywords
XThese keywords must appear before the first CD's entry, and represent
Xglobal settings for the tool.  They are usually found in \fB.workmanrc\fP.
X.TP
X\fBwhendone eject\fP | \fBstop\fP | \fBrepeat\fP
XSelect the default action taken by
X.IR workman (1)
Xwhen a CD is finished playing.  The default is \fBstop\fP.
X.TP
X\fBplaynew\fP
XIf specified,
X.IR workman (1)
Xwill play unknown CDs (those not listed in \fB.workmanrc\fP) when they're
Xinserted.
X.SS CD Information
XThe rest of the keywords describe specific CDs.
X.TP
X\fBtracks\fI \fIntracks start1 start2 ... startn length\fP
XThis keyword delimits the start of a particular CD's entry (and thus
Xthe end of the previous entry.)  Its
Xarguments contain the information used to distinguish one disc from
Xanother.  The first argument, \fIntracks\fP, is the number of tracks
Xon the CD.  For each of those tracks, there is a \fIstart\fP value,
Xwhich is the starting frame of the track (a frame is approximately
X1/75th of a second.)  The final argument is the length of the CD in
Xseconds.
X.TP
X\fBsections\fP \fInsects start1 start2 ... startn\fP
X.IR Workman (1)
Xallows the user to split a CD's physical tracks into smaller virtual tracks
Xcalled sections.
XThe \fBsections\fP keyword, which must immediately follow \fBtracks\fP,
Xdefines the starting positions of the sections.  Sections are inserted into
Xthe track list, and track numbers are adjusted accordingly, e.g. section 1.2
Xas presented to the user is represented as track 2 in the database file.
XIf the sections listed in \fB.workmandb\fP and \fB.workmanrc\fP
Xdiffer, \fB.workmandb\fP takes precedence, and sections listed only
Xin \fB.workmanrc\fP are discarded.
X.TP
X\fBcdname\fP \fIname\fP
XThe name of the current disc, as supplied by the user.
X.TP
X\fBartist\fP \fIname\fP
XThe artist's name for the current disc, as supplied by the user.
X.TP
X\fBplaymode\fP \fImode\fP
XThe default play mode for the CD is \fImode\fP, a numeric value.  0 is
Xthe "normal" play mode (play all tracks sequentially) and 1 is "shuffle"
Xmode.  If \fImode\fP is 2 or greater, the default play sequence is a
Xplaylist (\fImode\fP 2 meaning the first playlist, 3 meaning the second,
Xetc.)
X.TP
X\fBautoplay\fP
XIf \fBautoplay\fP is present, this CD will begin playing immediately
Xwhen it is inserted.
X.TP
X\fBcdvolume\fP \fIvolume\fP
XThe default play volume of the CD, a value from 0 to 32.  If \fIvolume\fP is 0,
Xthe CD has no default volume (since 0 is the default, \fBcdvolume\fP will
Xusually not be present in that case.)
X.TP
X\fBplaylist\fP \fIname number track1 track2 ...\fP
XDefine a playlist for the current CD.  The \fIname\fP does not contain any
Xwhitespace; whitespace is converted to "_" on output and "_" is converted
Xto whitespace on input.  (See the \s-2BUGS\s+2 section.)  The \fInumber\fP
Xargument is the number of tracks contained in the playlist; the rest of
Xthe line is a list of track numbers.  Playlists are ordered; see the
X\fBplaymode\fP keyword above.
X.TP
X\fBtrack\fP [\fIname\fP]
XThe name of a track.  This delimits the start of a
Xtrack's information.
XThe \fIname\fP argument is optional; it will not be present unless the
Xuser has supplied a track name.  This line may be divided into display
Xlines with the "//" token.  Additionally, a display line beginning with
X"+" indicates that the rest of the display line contains a replacement
Xdisc title (usually the name of a group of tracks,
Xsuch as "Symphony No. 2" on a disc
Xwith more than one piece of music.)  A display line beginning with "@"
Xreplaces the artist's name for the track.  If "+" or "@" is the only
Xcharacter on a display line,
X.IR workman (1)
Xwill use the title or artist from the previous track, searching backwards
Xas necessary.  If a display line is empty, the corresponding display line
Xfrom the previous track is used.
X.TP
X\fBcontinue\fP
XThe current track is a continuation of the previous one (e.g. the
Xsecond movement of a symphony.)
X.TP
X\fBdontplay\fP \fItrack\fP
XDon't play a track (specified by number) unless it's specifically requested
Xby the user.
X.TP
X\fBvolume\fP \fItrack\fP \fIvolume\fP
XThe default play volume for \fItrack\fP, specified by number.  \fIvolume\fP
Xis a number from 0 to 32.  See \fBcdvolume\fP above.
X.TP
X\fBmark\fP \fIframe\fP \fImark-id\fP
XDefine a mark.  Marks with IDs other than \fBSTART\fP and \fBEND\fP are
Xcurrently
Xignored.  Those two marks represent the start and end of the part of
Xthe CD to be repeated (as set from the Goodies popup) respectively.  The
X\fIframe\fP value is an absolute frame number.
X.SH EXAMPLE
XThe first example is a \fB.workmandb\fP entry for a hypothetical disc.  At
Xleast, I hope it's hypothetical.
X.IP
X.ll +4i
Xtracks 6 150 10341 20449 45117 100104 150100 1609
X.br
Xcdname Amazing Accordion Tunes - The Early Years
X.br
Xartist The Hemophiliacs
X.br
Xtrack Polka 'Till the Sun Goes Down
X.br
Xtrack I've Got Rocks In My Heart, Baby...
X.br
Xtrack ...But I Still Get Stoned On You
X.br
Xcontinue
X.br
Xtrack You Never Know How Late It Is Until the Clock Strikes Blue
X.br
Xtrack +The Big Exhibition//@Mussorgsky//IX. La Cabane//Allegro
X.br
Xtrack +//@////Andante mosso
X.br
Xcontinue
X.ll -4i
X.LP
XThe third track is a continuation of the second.
XThe fifth
Xtrack is an excerpt from a larger work, originally written by someone
Xelse; it has a two-line track title.  The sixth track is a continuation of
Xthe fifth; it uses the same title and artist, and the first line of the
Xtrack title is the same, but the second is different.
X.LP
XThe \fB.workmanrc\fP entry for the same CD might look like:
X.IP
Xtracks 6 150 10341 20449 45117 100104 150100 1609
X.br
Xcdvolume 32
X.br
Xplaymode 1
X.br
Xplaylist Originals 3 2 3 1
X.br
Xautoplay
X.br
Xdontplay 4
X.br
Xvolume 3 20
X.LP
XThe \fBtracks\fP line, naturally, is the same in both files, since it
Xidentifies which CD the entry is for.  This CD plays at maximum volume
Xin shuffle mode by default.  It has one playlist with tracks 2, 3, and
X1.  When inserted, it will start up automatically.  Track 4 is particularly
Xunpleasant, so the user never wants to hear it.  And track 3 should be
Xplayed more quietly than the others.
X.SH SEE ALSO
X.BR workman (1)
X.SH BUGS
XThe \fBplaylist\fP keyword is not well thought-out.  The \fIname\fP should
Xgo at the end of the line, so it can contain whitespace or whatever else
Xthe user likes.
X.LP
XThe file updating algorithm used by
X.IR workman (1)
Xleaves big holes (consisting of empty lines) in the database files.  It
Xmakes an attempt to fill the holes when possible rather than growing
Xthe files.
END_OF_FILE
if test 8919 -ne `wc -c <'workmandb.man'`; then
    echo shar: \"'workmandb.man'\" unpacked with wrong size!
fi
# end of 'workmandb.man'
fi
echo shar: End of archive 2 \(of 9\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 9 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM            | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly!      |
 "It's intuitively obvious to the most |    sources-x@imd.sterling.com
  casual observer..."                  |
