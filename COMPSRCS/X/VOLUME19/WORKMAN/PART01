Newsgroups: comp.sources.x
From: koreth@hyperion.com (Steven Grimm)
Subject: v19i009:  workman - CD player for HP, Sun, DEC, Linux, Part01/09
Message-ID: <csx-v19i009=workman.103551@sparky.IMD.Sterling.COM>
X-Md4-Signature: 4608e1f18f81d4c7b322d973a6f53a3e
Date: Tue, 9 Mar 1993 16:37:49 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: koreth@hyperion.com (Steven Grimm)
Posting-number: Volume 19, Issue 9
Archive-name: workman/part01
Environment: X11R5 Xview3 HP Sun Dec Linux

WorkMan is a graphical tool for playing audio compact discs on a CD-ROM
drive.  It has most of the features available on standalone CD players,
such as a shuffle mode, programmable playlists, and elapsed/remaining
timers.  But it also has extra features, foremost of which is the ability
to store information about CDs in a database, then automatically extract
that information when the CD is inserted later.  WorkMan stores the
artist's name, the disc title, the names of individual tracks, and even
remembers which tracks you don't want to hear!  All in an easy-to-use,
attractive OPEN LOOK graphical interface.

Disc databases may be shared among any number of users on the network.
WorkMan keeps separate databases for your private information about
CDs (e.g. which order you like the tracks to play) and the discs' public
information.  During WorkMan's alpha test, several users shared my
database, which now contains over 750 CDs.  That database is available
via anonymous ftp from ftp.hyperion.com in the "WorkMan" directory.

WorkMan requires XView 3.0 or higher (which comes with the OpenWindows
distribution, and is also available as part of X11R5.)

WorkMan runs under SunOS 4.x, Solaris 2, ULTRIX, HP-UX, and Linux.
Binaries for ULTRIX and HP-UX are on ftp.hyperion.com.  Linux binaries
are on sunsite.unc.edu.

If you like the program, send me a picture postcard!  See the README file.

-Steve

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 9)."
# Contents:  CHANGELOG INSTALLATION Imakefile Makefile.hpux README
#   README.hpux README.linux README.ultrix WorkMan.tmpl bitmaps
#   bitmaps/eject.button bitmaps/ff.button bitmaps/icon
#   bitmaps/loud.icon bitmaps/loud0.icon bitmaps/loud1.icon
#   bitmaps/loud2.icon bitmaps/loud3.icon bitmaps/loud4.icon
#   bitmaps/loud5.icon bitmaps/loud6.icon bitmaps/pause.button
#   bitmaps/phones bitmaps/phones0 bitmaps/phonesl1 bitmaps/phonesl2
#   bitmaps/phonesl3 bitmaps/phonesr1 bitmaps/phonesr2
#   bitmaps/phonesr3 bitmaps/play.button bitmaps/rew.button
#   bitmaps/sink0 bitmaps/sink2 bitmaps/sink3 bitmaps/sink4
#   bitmaps/sink6 bitmaps/sink7 bitmaps/stop.button workman_ui.h
# Wrapped by koreth@gerbilmeister on Thu Mar  4 10:04:48 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'CHANGELOG' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CHANGELOG'\"
else
echo shar: Extracting \"'CHANGELOG'\" \(196 characters\)
sed "s/^X//" >'CHANGELOG' <<'END_OF_FILE'
XRelease 1.0.1 (93/03/04)
X
XSupport for Linux systems added.
X
X
XRelease 1.0 (92/12/24)
X
XRearranged the manual page to make it more useful.
X
X<pre-1.0 history deleted -- mail me if you want to see it>
END_OF_FILE
if test 196 -ne `wc -c <'CHANGELOG'`; then
    echo shar: \"'CHANGELOG'\" unpacked with wrong size!
fi
# end of 'CHANGELOG'
fi
if test -f 'INSTALLATION' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INSTALLATION'\"
else
echo shar: Extracting \"'INSTALLATION'\" \(1695 characters\)
sed "s/^X//" >'INSTALLATION' <<'END_OF_FILE'
XWorkMan requires XView version 3 or higher.  This is supplied by default
Xon Sun systems.  See the README file for your machine if you're using
Xsomething other than a Sun.
X
XTo build workman, many people (OpenWindows users running SunOS 4.x)
Xcan just type "make".  ULTRIX users will want to either generate a
XMakefile with "imake" or edit the provided Makefile to point to the
Xright directories.  HPUX users should edit Makefile.hpux and build
Xusing it.
X
XThe Makefile assumes that OPENWINHOME is set to the OpenWindows 3.x home
Xdirectory.  Some tweaking will probably be required if you're not using
XOpenWindows; OPENWINHOME is used to locate the XView include files and
Xlibraries.
X
XIf you're compiling on Solaris 2, you'll want to uncomment the -DSYSV
Xline at the top of the Makefile.  The biggest thing this does is enable
Xa background process that is necessary if you don't want the CD to stop
Xplaying when you start workman.  (Use the "-o" option to prevent the
Xbackground process from being spawned, even if you've compiled with
X-DSYSV.)
X
XOnce the executable is built, install it in your favorite directory
Xfor such things.  The file "workman.info" should be placed in the XView
Xhelp directory, usually $OPENWINHOME/lib/help.  If you put it somewhere
Xelse, be sure to set your HELPPATH environment variable to point to that
Xdirectory.  This is necessary if you want to use the Help key to see
Xthe controls' descriptions.  Run "make install" to install everything
Xunder $OPENWINHOME.  You will probably need to be root to do this.
X
XOnce all that's done, you're ready to rock and roll (or jazz, or...)
X
XSunOS 4.x and HPUX users may want to use the "-e" option; see the manual
Xpage for details.
END_OF_FILE
if test 1695 -ne `wc -c <'INSTALLATION'`; then
    echo shar: \"'INSTALLATION'\" unpacked with wrong size!
fi
# end of 'INSTALLATION'
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(917 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
X/**/# @(#)Imakefile	1.3 11/28/92
X
X/**/# Note: Sun users should use the supplied Makefile.  But if you need
X/**/# to use imake, uncomment this line if you are compiling for Solaris 2.
X/**/# SOLARIS2 = -DSYSV
X
X/**/# Set this to the manual section where you want to install workmandb.man
XDBMANSECTION = 5
X
X/**/# And you shouldn't need to touch anything below this.
X
X
X#include <XView.tmpl>
X#include "WorkMan.tmpl"
X
X#define HasInfoFiles YES
X
XDEFINES = $(SOLARIS2)
XDEPLIBS = XViewClientDepLibs
XLOCAL_LIBRARIES = XViewClientLibs
X
XINFOFILES = workman.info
X
XSRCS = cdinfo.c database.c display.c hardware.c setup.c ui_cdinfo.c \
X	workman_stubs.c
X
XOBJS = cdinfo.o database.o display.o hardware.o setup.o ui_cdinfo.o \
X	workman_stubs.o
X
XComplexProgramTarget(workman)
X
XInstallSpecialManPage(workmandb,$(DBMANSECTION))
X
X#ifdef UltrixArchitecture
XSpecialObjectRule(database.o,database.c,-Olimit 600);
X#endif
X
X#include <XView.prog>
X
END_OF_FILE
if test 917 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'Makefile.hpux' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.hpux'\"
else
echo shar: Extracting \"'Makefile.hpux'\" \(2152 characters\)
sed "s/^X//" >'Makefile.hpux' <<'END_OF_FILE'
X# @(#)Makefile.hpux	1.1 12/6/92
X
X# Set these to the locations of your XView include files and libraries.
XINCDIR = /usr/include/X11
XLIBDIR = /usr/lib/X11
X
X# Set these to the directory names in which to install the software and
X# help files.  HLPDIR should point to wherever the other XView ".info"
X# files live.
XBINDIR = /usr/local/bin
XHLPDIR = /usr/lib/X11/help
X
X# Set this to the directory containing manual pages.  Manual pages will only
X# be installed if you "make install.man".
XMANDIR = /usr/local/man
X
X# Set these to the manual sections (e.g. 1, 4, 5, l) for the program and
X# database file manual pages, respectively.
XPEXT = 1
XDEXT = 5
X
X# And you shouldn't need to change anything from this line on.
X
X############################################################################
X# Parameters.
X
XPROGRAM = workman
XOBJECTS = workman_stubs.o database.o hardware.o cdinfo.o display.o setup.o \
X	ui_cdinfo.o
XSOURCES.c = workman_stubs.c database.c hardware.c cdinfo.c display.c setup.c \
X	ui_cdinfo.c
XSOURCES.h = struct.h workman_ui.h
X
X# Compiler flags.
X
XCFLAGS = -O -Wp,-H,256000 -I$(INCDIR)
XLDFLAGS = -L$(LIBDIR)
XLDLIBS = -lxview -lolgx -lX11 -lBSD
X
X# Standard targets.
X
Xall:	 $(PROGRAM) $(PROGRAM).doc workmandb.doc
X
X$(PROGRAM): $(SOURCES.c) $(OBJECTS)
X	$(CC) $(LDFLAGS) -o $@ $(OBJECTS) $(LDLIBS)
X
Xclean:
X	$(RM) $(OBJECTS) *.BAK *.delta core
X
Xinstall: $(PROGRAM)
X	cp $(PROGRAM) $(BINDIR)
X	chmod 755 $(BINDIR)/$(PROGRAM)
X	cp $(PROGRAM).info $(HLPDIR)
X	chmod 644 $(HLPDIR)/$(PROGRAM).info
X
Xinstall.man: workman.man workmandb.man $(MANDIR)/man$(PEXT) $(MANDIR)/man$(DEXT)
X	cp workman.man $(MANDIR)/man$(PEXT)/workman.$(PEXT)
X	chmod 644 $(MANDIR)/man$(PEXT)/workman.$(PEXT)
X	cp workmandb.man $(MANDIR)/man$(DEXT)/workmandb.$(DEXT)
X	chmod 644 $(MANDIR)/man$(DEXT)/workmandb.$(DEXT)
X
Xdisplay.o: display.c workman_ui.h
Xsetup.o: setup.c workman_ui.h
Xworkman_stubs.o: workman_stubs.c workman_ui.h
Xui_cdinfo.o: ui_cdinfo.c workman_ui.h
X# This next one isn't completely true, but close enough
X$(OBJECTS): struct.h
X
X$(PROGRAM).doc: $(PROGRAM).man
X	nroff -man $(PROGRAM).man > $(PROGRAM).doc
Xworkmandb.doc: workmandb.man
X	nroff -man workmandb.man > workmandb.doc
END_OF_FILE
if test 2152 -ne `wc -c <'Makefile.hpux'`; then
    echo shar: \"'Makefile.hpux'\" unpacked with wrong size!
fi
# end of 'Makefile.hpux'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(2228 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XWorkMan is a graphical tool for playing audio compact discs on a CD-ROM
Xdrive.  It has most of the features available on standalone CD players,
Xsuch as a shuffle mode, programmable playlists, and elapsed/remaining
Xtimers.  But it also has extra features, foremost of which is the ability
Xto store information about CDs in a database, then automatically extract
Xthat information when the CD is inserted later.  WorkMan stores the
Xartist's name, the disc title, the names of individual tracks, and even
Xremembers which tracks you don't want to hear!  All in an easy-to-use,
Xattractive OPEN LOOK graphical interface.
X
XDisc databases may be shared among any number of users on the network.
XWorkMan keeps separate databases for your private information about
XCDs (e.g. which order you like the tracks to play) and the discs' public
Xinformation.  During WorkMan's alpha test, several users shared my
Xdatabase, which now contains over 750 CDs.  That database is available
Xvia anonymous ftp from ftp.hyperion.com in the "WorkMan" directory.
X
XTo build WorkMan, Sun users should be able to type "make" and sit
Xback.  See the file INSTALLATION for more details.  WorkMan requires
XXView 3.0 or higher (which comes with the OpenWindows distribution,
Xand is also available as part of X11R5.)
X
XThe manual page (workman.man) contains a brief description of the user
Xinterface, though for the most part you should be able to start using
Xthe tool right away without reading the docs.  If you're curious about
Xthe program's innards, the workmandb.man manual page describes the
Xdatabase file format.
X
XI'd like to thank the 100+ people from all over the world who participated
Xin WorkMan's beta test phase, providing encouragement and hitting me over
Xthe head with bug reports at all hours of the night.  And special thanks
Xto Chris Ross and John Brezak, without who WorkMan would still be a
XSun-only program.
X
XIf you enjoy WorkMan, drop me a picture postcard!  My address is
X
XSteven Grimm
X173 Sherland Ave.
XMountain View, CA 94043
XUSA
X
XComments, questions, and suggestions should be mailed to me at
Xkoreth@hyperion.com.  Check the BUGS section of the manual page and the
Xto-do list, as well as the ANSWERS file, before you mail me.
X
XEnjoy!
X
X-Steve
END_OF_FILE
if test 2228 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'README.hpux' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.hpux'\"
else
echo shar: Extracting \"'README.hpux'\" \(3565 characters\)
sed "s/^X//" >'README.hpux' <<'END_OF_FILE'
XNote: Hewlett Packard supplies this without warranty or support of any kind.
X
XWorkMan was ported to HPUX by John Brezak (brezak@apollo.hp.com).  Bug
Xreports should still be sent to me at koreth@hyperion.com, though; I have
Xaccess to HPs and can probably fix most problems.
X
XThis program should compile and run on series 700 machines under HPUX 8.07.
XIt should work under 9.0 as well.  You will need the XView toolkit, version
X3.0 or higher.  An HPUX port of XView is available from many sites via
Xanonymous ftp.  Use archie to find one near you.  Neither John nor I can
Xsupply people with XView sources, so please don't ask.  ftp.csc.liv.ac.uk
Xis one place you'll find XView for the HP, though I'm sure they'd appreciate
Xit if you tried to find a closer site before using theirs.
X
XThere is a WorkMan binary at ftp.hyperion.com:/WorkMan/hp700.tar.Z if you
Xcan't find XView or don't want to bother installing it.
X
XYou may also need to install the OPEN LOOK fonts to use this program.
XThey are available from ftp.hyperion.com as well as with the generic XView
Xsource distribution, available widely in the contrib section of X11R5.
XYou do not need to build XView from source to get the fonts from the
Xsource distribution.  They're included in the XView tarfiles on
Xftp.csc.liv.ac.uk.
X
XThe supplied Makefile (Makefile.hpux) will need to be tweaked to point to
Xyour XView include files and libraries.  You might also be able to generate
Xa valid Makefile with "imake".  I haven't tested that.
X
XYou'll want to put the following in your X resources:
X
X	openWindows.windowColor:        #CCCCCC
X
XMake "/dev/rscsi" a link to the CD-ROM's raw disk device.  For instance,
Xif your CD-ROM drive is at SCSI target number 5, you'd do (as root):
X
X	ln -s /dev/rdsk/5s0 /dev/rscsi
X
XOr, if you prefer, use the "-c" option when running the program to tell
Xit to use a device name other than /dev/rscsi.
X
XTo use the program's spot help, you'll need to define a Help key, since
Xthere isn't one on the HP keyboard.  Use the "xmodmap" program to do it.
XFor instance, the following will define the numeric keypad's "0" key as
Xthe help key:
X
X	xmodmap -e "keysym KP_0 = Help"
X
XOnce you have a Help key defined, position the mouse pointer over a control
Xand hit the key.  For this to work, you will either need to install the
X"workman.info" file in /usr/lib/help or set your HELPPATH environment
Xvariable to point to the directory where the .info file lives.
X
XFor those who'd like to read through the source, note that the HPUX-specific
Xcode is contained in hardware.c, with the exception of slight changes to
Xworkman_stubs.c and display.c.
X
XThe authoritative guide to controlling the HP CD-ROM drive (which is actually
Xa Toshiba XM3301) is the Toshiba XM3301 User's Manual.  If you want to look
Xat it, contact Toshiba.
X
X
XHP-SPECIFIC PROBLEMS:
X
XWhen there's no CD in the drive, WorkMan is very slow.  As far as I can tell,
Xthis is a hardware limitation -- the drive takes a long time to respond when
Xthere's no CD present, and WorkMan is stuck waiting for the response in the
Xmeantime.  If anyone knows a workaround, please get in touch with me.  You
Xcan run with "-ee" if you find this behavior annoying (see the man page).
X
XThe Toshiba drive doesn't allow the volume to be adjusted from software, so
XWorkMan's volume controls are greyed out and can't be manipulated.
X
XThe mwm window manager (a derivative of which is used as the VUE window
Xmanager) chops off part of the WorkMan icon.  This is an mwm problem; I'm
Xnot aware that there's anything I can do to tell mwm to give the icon more
Xroom.
END_OF_FILE
if test 3565 -ne `wc -c <'README.hpux'`; then
    echo shar: \"'README.hpux'\" unpacked with wrong size!
fi
# end of 'README.hpux'
fi
if test -f 'README.linux' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.linux'\"
else
echo shar: Extracting \"'README.linux'\" \(2390 characters\)
sed "s/^X//" >'README.linux' <<'END_OF_FILE'
X[This is a slightly modified version of the README file accompanying the
XWorkMan Linux binary distribution on sunsite.unc.edu.  Most of it applies
Xto the source as well.  -Steve]
X
XThis is version 1.0.1 of WorkMan OpenWindows CD-ROM audio tool for Linux --
XWorkMan is now out of beta. Please see the other read-me like files in this
Xdirectory for information about WorkMan in general; this README covers Linux-
Xspecific issues.
X
XThe WorkMan binary included here was compiled with gcc 2.3.3 and linked
Xagainst: libc-4.3, X libs 3.0 and XView libraries 1.1. The devicename for
Xthe CD-ROM drive defaults to /dev/sr0; if needed, this can be overridden
Xby a command-line switch. See the WorkMan docs.
X
XFor WorkMan to function you will need a kernel-supported CD-ROM drive
Xwhich uses the Sun-style ioctls for audio control. Currently, there are
Xthree options: I have implemented these functions for SCSI-2 CD-ROM drives;
Xthe patches for this can be found in a misc. SCSI patches release by
XEric Youngdale: look on tsx-11.mit.edu:pub/linux/. These patches are known
Xto work with a Sony CDU-541 drive.
X
XThe other two options are the Sony CDU-31A and CDU-535/531 drives with their
Xspecial interfaces. Drivers for these drives, written by Corey Minyard and
XRONJ.AN@site007.saic.com (Jeppesen, Ronald), respectively, can be found at
Xsunsite.unc.edu and tsx-11.mit.edu.
X
XIf you want to compile WorkMan for yourself, you will need the X libraries
Xand the XView3L3 package (look on sunsite). *IMPORTANT:* the included
XMakefile.linux should work. *DO NOT* run xmkmf unless you know that you have
Xthe OpenWindows .tmpl files. As far as I know, they are *NOT* in the XView3L3
Xpackage... At least I don't have them.
X
XThe file workman.diff contains the changes to the source for Linux. These
Xare trivial. Note that the diffs *have already* been applied to the source
Xin this package; they are included for reference.
X
XI have also included a rather large WorkMan database file, normally
Xdistributed seperately from the program. This file is provided by the
Xauthor of WorkMan. It contains lots of popular CDs, with all the track
Xnames. See the WorkMan documentation for tips on how to install a shared,
Xpublic CD database.
X
XI have sorta-kinda assumed responsibility for WorkMan on Linux, so if you
Xfind any problems specific to Linux, send me mail.
X
X-Chris Newbold (ctne_ltd@uhura.cc.rochester.edu)
X3 March 1993
END_OF_FILE
if test 2390 -ne `wc -c <'README.linux'`; then
    echo shar: \"'README.linux'\" unpacked with wrong size!
fi
# end of 'README.linux'
fi
if test -f 'README.ultrix' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README.ultrix'\"
else
echo shar: Extracting \"'README.ultrix'\" \(1811 characters\)
sed "s/^X//" >'README.ultrix' <<'END_OF_FILE'
XWorkMan was ported to ULTRIX by Chris Ross (cross@eng.umd.edu).  Bug
Xreports should still be sent to me at koreth@hyperion.com, though; I will
Xforward ULTRIX-specific reports to Chris.
X
XThis program should compile and run under ULTRIX 4.2.  You will need the
XXView toolkit, version 3.0 or higher.  An ULTRIX port of XView is available
Xfrom many sites via anonymous ftp.  Use archie to find one near you.  Neither
XChris nor I can supply people with XView sources, so please don't ask.
X
XYou will need to use "imake" to build a Makefile suitable for ULTRIX; the
Xsupplied Makefile is tuned for Suns (though it isn't hard to adjust if you
Xprefer not to use imake).  The usual way of running imake is to type "xmkmf"
Xand let it figure out all the parameters.
X
XThere is a WorkMan binary at ftp.hyperion.com:/WorkMan/ultrix.tar.Z if you
Xcan't find XView or don't want to bother installing it.  You may need to
Xinstall the OPEN LOOK fonts, though; they are available from ftp.hyperion.com
Xas well as with the generic XView source distribution, available widely in
Xthe contrib section of X11R5.  You do not need to build XView from source to
Xget the fonts from the source distribution.
X
XIf you get an error like "Cannot open connection to window server", try
Xsetting your DISPLAY environment variable to ":0.0".  There seems to be a
Xbug in the ULTRIX port of XView that causes the UNIX-domain server interface
Xto work better than the Internet-domain one.  If that doesn't help, try
Xsetting DISPLAY to "hostname:0" (substituting your display host for "hostname",
Xof course).  And if _that_ doesn't help, I'm afraid I don't know what's
Xwrong (but I'd like to hear about it if you figure out the problem!)
X
XFor those who'd like to read through the source, note that the ULTRIX-
Xspecific code is all contained in hardware.c.
END_OF_FILE
if test 1811 -ne `wc -c <'README.ultrix'`; then
    echo shar: \"'README.ultrix'\" unpacked with wrong size!
fi
# end of 'README.ultrix'
fi
if test -f 'WorkMan.tmpl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'WorkMan.tmpl'\"
else
echo shar: Extracting \"'WorkMan.tmpl'\" \(425 characters\)
sed "s/^X//" >'WorkMan.tmpl' <<'END_OF_FILE'
X/*
X * InstallSpecialManPage - generate rules to install the indicated manual page,
X * in a location other than $MANDIR/foo.$MANSUFFIX
X */
X#ifndef InstallSpecialManPage
X#define InstallSpecialManPage(file,section)				@@\
Xinstall.man:: file.man							@@\
X	MakeDir($(DESTDIR)$(MANSOURCEPATH)section)			@@\
X	$(INSTALL) -c $(INSTMANFLAGS) file.man $(DESTDIR)$(MANSOURCEPATH)section/file.section
X#endif /* InstallSpecialManPage */
X
END_OF_FILE
if test 425 -ne `wc -c <'WorkMan.tmpl'`; then
    echo shar: \"'WorkMan.tmpl'\" unpacked with wrong size!
fi
# end of 'WorkMan.tmpl'
fi
if test ! -d 'bitmaps' ; then
    echo shar: Creating directory \"'bitmaps'\"
    mkdir 'bitmaps'
fi
if test -f 'bitmaps/eject.button' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/eject.button'\"
else
echo shar: Extracting \"'bitmaps/eject.button'\" \(333 characters\)
sed "s/^X//" >'bitmaps/eject.button' <<'END_OF_FILE'
X/* Format_version=1, Width=32, Height=16, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,0x0000,
X	0x0001,0x8000,
X	0x0003,0xC000,
X	0x0007,0xE000,
X	0x000F,0xF000,
X	0x001F,0xF800,
X	0x003F,0xFC00,
X	0x007F,0xFE00,
X	0x00FF,0xFF00,
X	0x00FF,0xFF00,
X	0x0000,0x0000,
X	0x0000,0x0000,
X	0x00FF,0xFF00,
X	0x00FF,0xFF00,
X	0x00FF,0xFF00,
X	0x0000,0x0000
END_OF_FILE
if test 333 -ne `wc -c <'bitmaps/eject.button'`; then
    echo shar: \"'bitmaps/eject.button'\" unpacked with wrong size!
fi
# end of 'bitmaps/eject.button'
fi
if test -f 'bitmaps/ff.button' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/ff.button'\"
else
echo shar: Extracting \"'bitmaps/ff.button'\" \(350 characters\)
sed "s/^X//" >'bitmaps/ff.button' <<'END_OF_FILE'
X/* Format_version=1, Width=32, Height=16, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x00C0,	0xC0C0,
X	0x00F0,	0xF0C0,
X	0x00FC,	0xFCC0,
X	0x00FF,	0xFFC0,
X	0x00FF,	0xFFC0,
X	0x00FC,	0xFCC0,
X	0x00F0,	0xF0C0,
X	0x00C0,	0xC0C0,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
END_OF_FILE
if test 350 -ne `wc -c <'bitmaps/ff.button'`; then
    echo shar: \"'bitmaps/ff.button'\" unpacked with wrong size!
fi
# end of 'bitmaps/ff.button'
fi
if test -f 'bitmaps/icon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/icon'\"
else
echo shar: Extracting \"'bitmaps/icon'\" \(2190 characters\)
sed "s/^X//" >'bitmaps/icon' <<'END_OF_FILE'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0400,	0x0000,	0x0C00,
X	0x0000,	0x0700,	0x0000,	0x0F00,
X	0x0700,	0x0780,	0x0000,	0x0FC0,
X	0x07E0,	0x0480,	0x0000,	0x09C0,
X	0x07E0,	0x0400,	0x0000,	0x0C40,
X	0x0460,	0x0400,	0x0000,	0x0F40,
X	0x0420,	0x0400,	0x0000,	0x0BC0,
X	0x0420,	0x1C00,	0x0000,	0x38C0,
X	0x0420,	0x3C00,	0x0000,	0x7840,
X	0x1C20,	0x3C00,	0x0000,	0x79C0,
X	0x3CE0,	0x1800,	0x0000,	0x33C0,
X	0x3DE0,	0x0000,	0x0000,	0x03C0,
X	0x19E0,	0x01FF,	0xFE00,	0x0180,
X	0x00C1,	0xFFFF,	0xFFFE,	0x0000,
X	0x001F,	0xFFFF,	0xFFFF,	0xE000,
X	0x00FF,	0xFFFF,	0xFFFF,	0xFC00,
X	0x03FF,	0xFFFF,	0xFFFF,	0xFF00,
X	0x0FFF,	0xFFFF,	0xFFFF,	0xFFC0,
X	0x1FFF,	0xFFFF,	0xFFFF,	0xFFE0,
X	0x3FFF,	0xFFE0,	0x1FFF,	0xFFF0,
X	0x3FFF,	0xFFC0,	0x0FFF,	0xFFF0,
X	0x3FFF,	0xFFE0,	0x1FFF,	0xFFF0,
X	0x3FFF,	0xFFFF,	0xFFFF,	0xFFF0,
X	0x1FFF,	0xFFFF,	0xFFFF,	0xFFE0,
X	0x0FFF,	0xFFFF,	0xFFFF,	0xFFC0,
X	0x03FF,	0xFFFF,	0xFFFF,	0xFF00,
X	0x00FF,	0xFFFF,	0xFFFF,	0xFC00,
X	0x001F,	0xFFFF,	0xFFFF,	0xE000,
X	0x0003,	0xFFFF,	0xFFFF,	0x0000,
X	0x0000,	0x03FF,	0xFF00,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x000E,	0x0000,	0x0000,
X	0x0000,	0x0004,	0x0000,	0x0000,
X	0x0000,	0x0004,	0x0000,	0x0000,
X	0x0393,	0x3969,	0xF663,	0xFB80,
X	0x0291,	0x478A,	0x2BA4,	0x9480,
X	0x0111,	0x850C,	0x3324,	0x9880,
X	0x0132,	0x890C,	0x2249,	0x1100,
X	0x0122,	0x890A,	0x2649,	0x1100,
X	0x0174,	0x9112,	0x244B,	0x7280,
X	0x0198,	0xE211,	0xC44D,	0xA300,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
END_OF_FILE
if test 2190 -ne `wc -c <'bitmaps/icon'`; then
    echo shar: \"'bitmaps/icon'\" unpacked with wrong size!
fi
# end of 'bitmaps/icon'
fi
if test -f 'bitmaps/loud.icon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/loud.icon'\"
else
echo shar: Extracting \"'bitmaps/loud.icon'\" \(213 characters\)
sed "s/^X//" >'bitmaps/loud.icon' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=15, Depth=1, Valid_bits_per_item=16
X */
X	0x0080,
X	0x0040,
X	0x0320,
X	0x08A0,
X	0x1A90,
X	0x3A50,
X	0xF950,
X	0xFD48,
X	0xF950,
X	0x3A50,
X	0x1A90,
X	0x08A0,
X	0x0320,
X	0x0040,
X	0x0080,
END_OF_FILE
if test 213 -ne `wc -c <'bitmaps/loud.icon'`; then
    echo shar: \"'bitmaps/loud.icon'\" unpacked with wrong size!
fi
# end of 'bitmaps/loud.icon'
fi
if test -f 'bitmaps/loud0.icon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/loud0.icon'\"
else
echo shar: Extracting \"'bitmaps/loud0.icon'\" \(213 characters\)
sed "s/^X//" >'bitmaps/loud0.icon' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=15, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0800,
X	0x1800,
X	0x3800,
X	0xF800,
X	0xF800,
X	0xF800,
X	0x3800,
X	0x1800,
X	0x0800,
X	0x0000,
X	0x0000,
X	0x0000,
END_OF_FILE
if test 213 -ne `wc -c <'bitmaps/loud0.icon'`; then
    echo shar: \"'bitmaps/loud0.icon'\" unpacked with wrong size!
fi
# end of 'bitmaps/loud0.icon'
fi
if test -f 'bitmaps/loud1.icon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/loud1.icon'\"
else
echo shar: Extracting \"'bitmaps/loud1.icon'\" \(213 characters\)
sed "s/^X//" >'bitmaps/loud1.icon' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=15, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0800,
X	0x1800,
X	0x3800,
X	0xFC00,
X	0xFA00,
X	0xFC00,
X	0x3800,
X	0x1800,
X	0x0800,
X	0x0000,
X	0x0000,
X	0x0000,
END_OF_FILE
if test 213 -ne `wc -c <'bitmaps/loud1.icon'`; then
    echo shar: \"'bitmaps/loud1.icon'\" unpacked with wrong size!
fi
# end of 'bitmaps/loud1.icon'
fi
if test -f 'bitmaps/loud2.icon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/loud2.icon'\"
else
echo shar: Extracting \"'bitmaps/loud2.icon'\" \(213 characters\)
sed "s/^X//" >'bitmaps/loud2.icon' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=15, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0800,
X	0x1800,
X	0x3C00,
X	0xFA00,
X	0xFA00,
X	0xFA00,
X	0x3C00,
X	0x1800,
X	0x0800,
X	0x0000,
X	0x0000,
X	0x0000,
END_OF_FILE
if test 213 -ne `wc -c <'bitmaps/loud2.icon'`; then
    echo shar: \"'bitmaps/loud2.icon'\" unpacked with wrong size!
fi
# end of 'bitmaps/loud2.icon'
fi
if test -f 'bitmaps/loud3.icon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/loud3.icon'\"
else
echo shar: Extracting \"'bitmaps/loud3.icon'\" \(213 characters\)
sed "s/^X//" >'bitmaps/loud3.icon' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=15, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0800,
X	0x1A00,
X	0x3A00,
X	0xF900,
X	0xFD00,
X	0xF900,
X	0x3A00,
X	0x1A00,
X	0x0800,
X	0x0000,
X	0x0000,
X	0x0000,
END_OF_FILE
if test 213 -ne `wc -c <'bitmaps/loud3.icon'`; then
    echo shar: \"'bitmaps/loud3.icon'\" unpacked with wrong size!
fi
# end of 'bitmaps/loud3.icon'
fi
if test -f 'bitmaps/loud4.icon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/loud4.icon'\"
else
echo shar: Extracting \"'bitmaps/loud4.icon'\" \(213 characters\)
sed "s/^X//" >'bitmaps/loud4.icon' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=15, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0A00,
X	0x1900,
X	0x3C80,
X	0xFA80,
X	0xFA40,
X	0xFA80,
X	0x3C80,
X	0x1900,
X	0x0A00,
X	0x0000,
X	0x0000,
X	0x0000,
END_OF_FILE
if test 213 -ne `wc -c <'bitmaps/loud4.icon'`; then
    echo shar: \"'bitmaps/loud4.icon'\" unpacked with wrong size!
fi
# end of 'bitmaps/loud4.icon'
fi
if test -f 'bitmaps/loud5.icon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/loud5.icon'\"
else
echo shar: Extracting \"'bitmaps/loud5.icon'\" \(213 characters\)
sed "s/^X//" >'bitmaps/loud5.icon' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=15, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,
X	0x0000,
X	0x0300,
X	0x0880,
X	0x1A80,
X	0x3A40,
X	0xF940,
X	0xFD40,
X	0xF940,
X	0x3A40,
X	0x1A80,
X	0x0880,
X	0x0300,
X	0x0000,
X	0x0000,
END_OF_FILE
if test 213 -ne `wc -c <'bitmaps/loud5.icon'`; then
    echo shar: \"'bitmaps/loud5.icon'\" unpacked with wrong size!
fi
# end of 'bitmaps/loud5.icon'
fi
if test -f 'bitmaps/loud6.icon' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/loud6.icon'\"
else
echo shar: Extracting \"'bitmaps/loud6.icon'\" \(213 characters\)
sed "s/^X//" >'bitmaps/loud6.icon' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=15, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,
X	0x0100,
X	0x0080,
X	0x0A40,
X	0x1940,
X	0x3D20,
X	0xFAA0,
X	0xFAA0,
X	0xFAA0,
X	0x3D20,
X	0x1940,
X	0x0A40,
X	0x0080,
X	0x0100,
X	0x0000,
END_OF_FILE
if test 213 -ne `wc -c <'bitmaps/loud6.icon'`; then
    echo shar: \"'bitmaps/loud6.icon'\" unpacked with wrong size!
fi
# end of 'bitmaps/loud6.icon'
fi
if test -f 'bitmaps/pause.button' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/pause.button'\"
else
echo shar: Extracting \"'bitmaps/pause.button'\" \(333 characters\)
sed "s/^X//" >'bitmaps/pause.button' <<'END_OF_FILE'
X/* Format_version=1, Width=32, Height=16, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,0x0000,
X	0x003C,0x3C00,
X	0x003C,0x3C00,
X	0x003C,0x3C00,
X	0x003C,0x3C00,
X	0x003C,0x3C00,
X	0x003C,0x3C00,
X	0x003C,0x3C00,
X	0x003C,0x3C00,
X	0x003C,0x3C00,
X	0x003C,0x3C00,
X	0x003C,0x3C00,
X	0x003C,0x3C00,
X	0x003C,0x3C00,
X	0x003C,0x3C00,
X	0x0000,0x0000
END_OF_FILE
if test 333 -ne `wc -c <'bitmaps/pause.button'`; then
    echo shar: \"'bitmaps/pause.button'\" unpacked with wrong size!
fi
# end of 'bitmaps/pause.button'
fi
if test -f 'bitmaps/phones' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/phones'\"
else
echo shar: Extracting \"'bitmaps/phones'\" \(622 characters\)
sed "s/^X//" >'bitmaps/phones' <<'END_OF_FILE'
X/* Format_version=1, Width=32, Height=32, Depth=1, Valid_bits_per_item=16
X */
X	0x0001,	0x8000,
X	0x0006,	0x6000,
X	0x0008,	0x1000,
X	0x0010,	0x0800,
X	0x0010,	0x0800,
X	0x0020,	0x0400,
X	0x0020,	0x0400,
X	0x0020,	0x0400,
X	0x0040,	0x0200,
X	0x0040,	0x0200,
X	0x0040,	0x0200,
X	0x00E0,	0x0700,
X	0x00E0,	0x0700,
X	0x00E0,	0x0700,
X	0x00E0,	0x0700,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
END_OF_FILE
if test 622 -ne `wc -c <'bitmaps/phones'`; then
    echo shar: \"'bitmaps/phones'\" unpacked with wrong size!
fi
# end of 'bitmaps/phones'
fi
if test -f 'bitmaps/phones0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/phones0'\"
else
echo shar: Extracting \"'bitmaps/phones0'\" \(276 characters\)
sed "s/^X//" >'bitmaps/phones0' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=22, Depth=1, Valid_bits_per_item=16
X */
X	0x0180,
X	0x0660,
X	0x0810,
X	0x1008,
X	0x1008,
X	0x2004,
X	0x2004,
X	0x2004,
X	0x4002,
X	0x4002,
X	0x4002,
X	0xE007,
X	0xFFFF,
X	0xE007,
X	0xE007,
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0000,
END_OF_FILE
if test 276 -ne `wc -c <'bitmaps/phones0'`; then
    echo shar: \"'bitmaps/phones0'\" unpacked with wrong size!
fi
# end of 'bitmaps/phones0'
fi
if test -f 'bitmaps/phonesl1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/phonesl1'\"
else
echo shar: Extracting \"'bitmaps/phonesl1'\" \(292 characters\)
sed "s/^X//" >'bitmaps/phonesl1' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=22, Depth=1, Valid_bits_per_item=16
X */
X	0x0180,	
X	0x0660,	
X	0x0810,	
X	0x1008,	
X	0x1008,	
X	0x2004,	
X	0x2004,	
X	0x2004,	
X	0x4002,	
X	0x4002,	
X	0x5002,	
X	0xE807,	
X	0xE407,	
X	0xE407,	
X	0xE807,	
X	0x1000,	
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0000,
END_OF_FILE
if test 292 -ne `wc -c <'bitmaps/phonesl1'`; then
    echo shar: \"'bitmaps/phonesl1'\" unpacked with wrong size!
fi
# end of 'bitmaps/phonesl1'
fi
if test -f 'bitmaps/phonesl2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/phonesl2'\"
else
echo shar: Extracting \"'bitmaps/phonesl2'\" \(294 characters\)
sed "s/^X//" >'bitmaps/phonesl2' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=22, Depth=1, Valid_bits_per_item=16
X */
X	0x0180,	
X	0x0660,	
X	0x0810,	
X	0x1008,	
X	0x1008,	
X	0x2004,	
X	0x2004,	
X	0x2004,	
X	0x4802,	
X	0x4402,	
X	0x5202,	
X	0xEA07,	
X	0xE507,	
X	0xE507,	
X	0xEA07,	
X	0x1200,	
X	0x0400,	
X	0x0800,	
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0000,
END_OF_FILE
if test 294 -ne `wc -c <'bitmaps/phonesl2'`; then
    echo shar: \"'bitmaps/phonesl2'\" unpacked with wrong size!
fi
# end of 'bitmaps/phonesl2'
fi
if test -f 'bitmaps/phonesl3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/phonesl3'\"
else
echo shar: Extracting \"'bitmaps/phonesl3'\" \(278 characters\)
sed "s/^X//" >'bitmaps/phonesl3' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=20, Depth=1, Valid_bits_per_item=16
X */
X	0x0180,	
X	0x0660,	
X	0x0810,	
X	0x1008,	
X	0x1008,	
X	0x2004,	
X	0x2404,	
X	0x2204,	
X	0x4902,	
X	0x4482,	
X	0x5282,	
X	0xEA47,	
X	0xE547,	
X	0xE547,	
X	0xEA47,	
X	0x1280,	
X	0x0480,	
X	0x0900,	
X	0x0200,	
X	0x0400,	
END_OF_FILE
if test 278 -ne `wc -c <'bitmaps/phonesl3'`; then
    echo shar: \"'bitmaps/phonesl3'\" unpacked with wrong size!
fi
# end of 'bitmaps/phonesl3'
fi
if test -f 'bitmaps/phonesr1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/phonesr1'\"
else
echo shar: Extracting \"'bitmaps/phonesr1'\" \(292 characters\)
sed "s/^X//" >'bitmaps/phonesr1' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=22, Depth=1, Valid_bits_per_item=16
X */
X	0x0180,	
X	0x0660,	
X	0x0810,	
X	0x1008,	
X	0x1008,	
X	0x2004,	
X	0x2004,	
X	0x2004,	
X	0x4002,	
X	0x4002,	
X	0x400A,	
X	0xE017,	
X	0xE027,	
X	0xE027,	
X	0xE017,	
X	0x0008,	
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0000,
END_OF_FILE
if test 292 -ne `wc -c <'bitmaps/phonesr1'`; then
    echo shar: \"'bitmaps/phonesr1'\" unpacked with wrong size!
fi
# end of 'bitmaps/phonesr1'
fi
if test -f 'bitmaps/phonesr2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/phonesr2'\"
else
echo shar: Extracting \"'bitmaps/phonesr2'\" \(294 characters\)
sed "s/^X//" >'bitmaps/phonesr2' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=22, Depth=1, Valid_bits_per_item=16
X */
X	0x0180,	
X	0x0660,	
X	0x0810,	
X	0x1008,	
X	0x1008,	
X	0x2004,	
X	0x2004,	
X	0x2004,	
X	0x4012,	
X	0x4022,	
X	0x404A,	
X	0xE057,	
X	0xE0A7,	
X	0xE0A7,	
X	0xE057,	
X	0x0048,	
X	0x0020,	
X	0x0010,	
X	0x0000,
X	0x0000,
X	0x0000,
X	0x0000,
END_OF_FILE
if test 294 -ne `wc -c <'bitmaps/phonesr2'`; then
    echo shar: \"'bitmaps/phonesr2'\" unpacked with wrong size!
fi
# end of 'bitmaps/phonesr2'
fi
if test -f 'bitmaps/phonesr3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/phonesr3'\"
else
echo shar: Extracting \"'bitmaps/phonesr3'\" \(278 characters\)
sed "s/^X//" >'bitmaps/phonesr3' <<'END_OF_FILE'
X/* Format_version=1, Width=16, Height=20, Depth=1, Valid_bits_per_item=16
X */
X	0x0180,	
X	0x0660,	
X	0x0810,	
X	0x1008,	
X	0x1008,	
X	0x2004,	
X	0x2024,	
X	0x2044,	
X	0x4092,	
X	0x4122,	
X	0x414A,	
X	0xE257,	
X	0xE2A7,	
X	0xE2A7,	
X	0xE257,	
X	0x0148,	
X	0x0120,	
X	0x0090,	
X	0x0040,	
X	0x0020,	
END_OF_FILE
if test 278 -ne `wc -c <'bitmaps/phonesr3'`; then
    echo shar: \"'bitmaps/phonesr3'\" unpacked with wrong size!
fi
# end of 'bitmaps/phonesr3'
fi
if test -f 'bitmaps/play.button' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/play.button'\"
else
echo shar: Extracting \"'bitmaps/play.button'\" \(333 characters\)
sed "s/^X//" >'bitmaps/play.button' <<'END_OF_FILE'
X/* Format_version=1, Width=32, Height=16, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,0x0000,
X	0x001E,0x0000,
X	0x001F,0x0000,
X	0x001F,0x8000,
X	0x001F,0xC000,
X	0x001F,0xE000,
X	0x001F,0xF000,
X	0x001F,0xF800,
X	0x001F,0xF800,
X	0x001F,0xF000,
X	0x001F,0xE000,
X	0x001F,0xC000,
X	0x001F,0x8000,
X	0x001F,0x0000,
X	0x001E,0x0000,
X	0x0000,0x0000
END_OF_FILE
if test 333 -ne `wc -c <'bitmaps/play.button'`; then
    echo shar: \"'bitmaps/play.button'\" unpacked with wrong size!
fi
# end of 'bitmaps/play.button'
fi
if test -f 'bitmaps/rew.button' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/rew.button'\"
else
echo shar: Extracting \"'bitmaps/rew.button'\" \(350 characters\)
sed "s/^X//" >'bitmaps/rew.button' <<'END_OF_FILE'
X/* Format_version=1, Width=32, Height=16, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0303,	0x0300,
X	0x030F,	0x0F00,
X	0x033F,	0x3F00,
X	0x03FF,	0xFF00,
X	0x03FF,	0xFF00,
X	0x033F,	0x3F00,
X	0x030F,	0x0F00,
X	0x0303,	0x0300,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
X	0x0000,	0x0000,
END_OF_FILE
if test 350 -ne `wc -c <'bitmaps/rew.button'`; then
    echo shar: \"'bitmaps/rew.button'\" unpacked with wrong size!
fi
# end of 'bitmaps/rew.button'
fi
if test -f 'bitmaps/sink0' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/sink0'\"
else
echo shar: Extracting \"'bitmaps/sink0'\" \(2190 characters\)
sed "s/^X//" >'bitmaps/sink0' <<'END_OF_FILE'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x01C1,	0x8380,	0x0000,
X	0x0000,	0x0222,	0x4440,	0x0000,
X	0x0000,	0x0364,	0x26C0,	0x0000,
X	0x0000,	0x0144,	0x2280,	0x0000,
X	0x0000,	0x0148,	0x1280,	0x0000,
X	0x0000,	0x014E,	0x7280,	0x0000,
X	0x0000,	0x0002,	0x4000,	0x0000,
X	0x0000,	0xFFFE,	0x7FFF,	0x0000,
X	0x0000,	0x8004,	0x2001,	0x0038,
X	0x0001,	0x8004,	0x2001,	0x8044,
X	0x0001,	0x8004,	0x2001,	0x807C,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0008,	0x800F,	0xF001,	0x1038,
X	0x0008,	0x8003,	0xC001,	0x1000,
X	0x0010,	0x8000,	0x0001,	0x0800,
X	0x0010,	0xFFFF,	0xFFFF,	0x0800,
X	0x0020,	0x8000,	0x0001,	0x0400,
X	0x0020,	0x8000,	0x0000,	0x8400,
X	0x0021,	0x0000,	0x0000,	0x8400,
X	0x0041,	0x0000,	0x0000,	0x8200,
X	0x0042,	0x0000,	0x0000,	0x4200,
X	0x0082,	0x0000,	0x0000,	0x4100,
X	0x0082,	0x0007,	0xE000,	0x2100,
X	0x0104,	0x0008,	0x1000,	0x2080,
X	0x0104,	0x0008,	0x1000,	0x2080,
X	0x0204,	0x0007,	0xE000,	0x1040,
X	0x0208,	0x0000,	0x0000,	0x1040,
X	0x0408,	0x0000,	0x0000,	0x1020,
X	0x0410,	0x0000,	0x0000,	0x0820,
X	0x0810,	0x0000,	0x0000,	0x0810,
X	0x0FFF,	0xFFFF,	0xFFFF,	0xFFF0,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
END_OF_FILE
if test 2190 -ne `wc -c <'bitmaps/sink0'`; then
    echo shar: \"'bitmaps/sink0'\" unpacked with wrong size!
fi
# end of 'bitmaps/sink0'
fi
if test -f 'bitmaps/sink2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/sink2'\"
else
echo shar: Extracting \"'bitmaps/sink2'\" \(2190 characters\)
sed "s/^X//" >'bitmaps/sink2' <<'END_OF_FILE'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x01C1,	0x8380,	0x0000,
X	0x0000,	0x0222,	0x4440,	0x0000,
X	0x0000,	0x0364,	0x26C0,	0x0000,
X	0x0000,	0x0144,	0x2280,	0x0000,
X	0x0000,	0x0148,	0x1280,	0x0000,
X	0x0000,	0x014E,	0x7280,	0x0000,
X	0x0000,	0x0002,	0x4000,	0x0000,
X	0x0000,	0xFFFE,	0x7FFF,	0x0000,
X	0x0000,	0x8004,	0x2001,	0x0038,
X	0x0001,	0x8004,	0x2001,	0x8044,
X	0x0001,	0x8004,	0x2001,	0x807C,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0008,	0x800F,	0xF001,	0x1038,
X	0x0008,	0x8003,	0xC001,	0x1000,
X	0x0010,	0x8001,	0x8001,	0x0800,
X	0x0010,	0xFFFE,	0x7FFF,	0x0800,
X	0x0020,	0x8002,	0x4001,	0x0400,
X	0x0020,	0x8001,	0x8000,	0x8400,
X	0x0021,	0x0000,	0x0000,	0x8400,
X	0x0041,	0x0000,	0x0000,	0x8200,
X	0x0042,	0x0000,	0x0000,	0x4200,
X	0x0082,	0x0000,	0x0000,	0x4100,
X	0x0082,	0x0007,	0xE000,	0x2100,
X	0x0104,	0x0008,	0x1000,	0x2080,
X	0x0104,	0x0008,	0x1000,	0x2080,
X	0x0204,	0x0007,	0xE000,	0x1040,
X	0x0208,	0x0000,	0x0000,	0x1040,
X	0x0408,	0x0000,	0x0000,	0x1020,
X	0x0410,	0x0000,	0x0000,	0x0820,
X	0x0810,	0x0000,	0x0000,	0x0810,
X	0x0FFF,	0xFFFF,	0xFFFF,	0xFFF0,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
END_OF_FILE
if test 2190 -ne `wc -c <'bitmaps/sink2'`; then
    echo shar: \"'bitmaps/sink2'\" unpacked with wrong size!
fi
# end of 'bitmaps/sink2'
fi
if test -f 'bitmaps/sink3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/sink3'\"
else
echo shar: Extracting \"'bitmaps/sink3'\" \(2190 characters\)
sed "s/^X//" >'bitmaps/sink3' <<'END_OF_FILE'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x01C1,	0x8380,	0x0000,
X	0x0000,	0x0222,	0x4440,	0x0000,
X	0x0000,	0x0364,	0x26C0,	0x0000,
X	0x0000,	0x0144,	0x2280,	0x0000,
X	0x0000,	0x0148,	0x1280,	0x0000,
X	0x0000,	0x014E,	0x7280,	0x0000,
X	0x0000,	0x0002,	0x4000,	0x0000,
X	0x0000,	0xFFFE,	0x7FFF,	0x0000,
X	0x0000,	0x8004,	0x2001,	0x0038,
X	0x0001,	0x8004,	0x2001,	0x8044,
X	0x0001,	0x8004,	0x2001,	0x807C,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0008,	0x800F,	0xF001,	0x1038,
X	0x0008,	0x8003,	0xC001,	0x1000,
X	0x0010,	0x8001,	0x8001,	0x0800,
X	0x0010,	0xFFFF,	0xFFFF,	0x0800,
X	0x0020,	0x8001,	0x8001,	0x0400,
X	0x0020,	0x8002,	0x4000,	0x8400,
X	0x0021,	0x0002,	0x4000,	0x8400,
X	0x0041,	0x0001,	0x8000,	0x8200,
X	0x0042,	0x0000,	0x0000,	0x4200,
X	0x0082,	0x0000,	0x0000,	0x4100,
X	0x0082,	0x0007,	0xE000,	0x2100,
X	0x0104,	0x0008,	0x1000,	0x2080,
X	0x0104,	0x0008,	0x1000,	0x2080,
X	0x0204,	0x0007,	0xE000,	0x1040,
X	0x0208,	0x0000,	0x0000,	0x1040,
X	0x0408,	0x0000,	0x0000,	0x1020,
X	0x0410,	0x0000,	0x0000,	0x0820,
X	0x0810,	0x0000,	0x0000,	0x0810,
X	0x0FFF,	0xFFFF,	0xFFFF,	0xFFF0,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
END_OF_FILE
if test 2190 -ne `wc -c <'bitmaps/sink3'`; then
    echo shar: \"'bitmaps/sink3'\" unpacked with wrong size!
fi
# end of 'bitmaps/sink3'
fi
if test -f 'bitmaps/sink4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/sink4'\"
else
echo shar: Extracting \"'bitmaps/sink4'\" \(2190 characters\)
sed "s/^X//" >'bitmaps/sink4' <<'END_OF_FILE'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x01C1,	0x8380,	0x0000,
X	0x0000,	0x0222,	0x4440,	0x0000,
X	0x0000,	0x0364,	0x26C0,	0x0000,
X	0x0000,	0x0144,	0x2280,	0x0000,
X	0x0000,	0x0148,	0x1280,	0x0000,
X	0x0000,	0x014E,	0x7280,	0x0000,
X	0x0000,	0x0002,	0x4000,	0x0000,
X	0x0000,	0xFFFE,	0x7FFF,	0x0000,
X	0x0000,	0x8004,	0x2001,	0x0038,
X	0x0001,	0x8004,	0x2001,	0x8044,
X	0x0001,	0x8004,	0x2001,	0x807C,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0008,	0x800F,	0xF001,	0x1038,
X	0x0008,	0x8003,	0xC001,	0x1000,
X	0x0010,	0x8000,	0x0001,	0x0800,
X	0x0010,	0xFFFF,	0xFFFF,	0x0800,
X	0x0020,	0x8001,	0x8001,	0x0400,
X	0x0020,	0x8001,	0x8000,	0x8400,
X	0x0021,	0x0001,	0x8000,	0x8400,
X	0x0041,	0x0002,	0x4000,	0x8200,
X	0x0042,	0x0002,	0x4000,	0x4200,
X	0x0082,	0x0001,	0x8000,	0x4100,
X	0x0082,	0x0007,	0xE000,	0x2100,
X	0x0104,	0x0008,	0x1000,	0x2080,
X	0x0104,	0x0008,	0x1000,	0x2080,
X	0x0204,	0x0007,	0xE000,	0x1040,
X	0x0208,	0x0000,	0x0000,	0x1040,
X	0x0408,	0x0000,	0x0000,	0x1020,
X	0x0410,	0x0000,	0x0000,	0x0820,
X	0x0810,	0x0000,	0x0000,	0x0810,
X	0x0FFF,	0xFFFF,	0xFFFF,	0xFFF0,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
END_OF_FILE
if test 2190 -ne `wc -c <'bitmaps/sink4'`; then
    echo shar: \"'bitmaps/sink4'\" unpacked with wrong size!
fi
# end of 'bitmaps/sink4'
fi
if test -f 'bitmaps/sink6' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/sink6'\"
else
echo shar: Extracting \"'bitmaps/sink6'\" \(2190 characters\)
sed "s/^X//" >'bitmaps/sink6' <<'END_OF_FILE'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x01C1,	0x8380,	0x0000,
X	0x0000,	0x0222,	0x4440,	0x0000,
X	0x0000,	0x0364,	0x26C0,	0x0000,
X	0x0000,	0x0144,	0x2280,	0x0000,
X	0x0000,	0x0148,	0x1280,	0x0000,
X	0x0000,	0x014E,	0x7280,	0x0000,
X	0x0000,	0x0002,	0x4000,	0x0000,
X	0x0000,	0xFFFE,	0x7FFF,	0x0000,
X	0x0000,	0x8004,	0x2001,	0x0038,
X	0x0001,	0x8004,	0x2001,	0x8044,
X	0x0001,	0x8004,	0x2001,	0x807C,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0008,	0x800F,	0xF001,	0x1038,
X	0x0008,	0x8003,	0xC001,	0x1000,
X	0x0010,	0x8000,	0x0001,	0x0800,
X	0x0010,	0xFFFF,	0xFFFF,	0x0800,
X	0x0020,	0x8000,	0x0001,	0x0400,
X	0x0020,	0x8000,	0x0000,	0x8400,
X	0x0021,	0x0000,	0x0000,	0x8400,
X	0x0041,	0x0000,	0x0000,	0x8200,
X	0x0042,	0x0001,	0x8000,	0x4200,
X	0x0082,	0x0001,	0x8000,	0x4100,
X	0x0082,	0x0007,	0xE000,	0x2100,
X	0x0104,	0x000A,	0x5000,	0x2080,
X	0x0104,	0x000A,	0x5000,	0x2080,
X	0x0204,	0x0007,	0xE000,	0x1040,
X	0x0208,	0x0000,	0x0000,	0x1040,
X	0x0408,	0x0000,	0x0000,	0x1020,
X	0x0410,	0x0000,	0x0000,	0x0820,
X	0x0810,	0x0000,	0x0000,	0x0810,
X	0x0FFF,	0xFFFF,	0xFFFF,	0xFFF0,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
END_OF_FILE
if test 2190 -ne `wc -c <'bitmaps/sink6'`; then
    echo shar: \"'bitmaps/sink6'\" unpacked with wrong size!
fi
# end of 'bitmaps/sink6'
fi
if test -f 'bitmaps/sink7' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/sink7'\"
else
echo shar: Extracting \"'bitmaps/sink7'\" \(2190 characters\)
sed "s/^X//" >'bitmaps/sink7' <<'END_OF_FILE'
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x01C1,	0x8380,	0x0000,
X	0x0000,	0x0222,	0x4440,	0x0000,
X	0x0000,	0x0364,	0x26C0,	0x0000,
X	0x0000,	0x0144,	0x2280,	0x0000,
X	0x0000,	0x0148,	0x1280,	0x0000,
X	0x0000,	0x014E,	0x7280,	0x0000,
X	0x0000,	0x0002,	0x4000,	0x0000,
X	0x0000,	0xFFFE,	0x7FFF,	0x0000,
X	0x0000,	0x8004,	0x2001,	0x0038,
X	0x0001,	0x8004,	0x2001,	0x8044,
X	0x0001,	0x8004,	0x2001,	0x807C,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0002,	0x8004,	0x2001,	0x4044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0004,	0x8008,	0x1001,	0x2044,
X	0x0008,	0x800F,	0xF001,	0x1038,
X	0x0008,	0x8003,	0xC001,	0x1000,
X	0x0010,	0x8000,	0x0001,	0x0800,
X	0x0010,	0xFFFF,	0xFFFF,	0x0800,
X	0x0020,	0x8000,	0x0001,	0x0400,
X	0x0020,	0x8000,	0x0000,	0x8400,
X	0x0021,	0x0000,	0x0000,	0x8400,
X	0x0041,	0x0000,	0x0000,	0x8200,
X	0x0042,	0x0000,	0x0000,	0x4200,
X	0x0082,	0x0000,	0x0000,	0x4100,
X	0x0082,	0x0007,	0xE000,	0x2100,
X	0x0104,	0x0009,	0x9000,	0x2080,
X	0x0104,	0x0009,	0x9000,	0x2080,
X	0x0204,	0x0007,	0xE000,	0x1040,
X	0x0208,	0x0000,	0x0000,	0x1040,
X	0x0408,	0x0000,	0x0000,	0x1020,
X	0x0410,	0x0000,	0x0000,	0x0820,
X	0x0810,	0x0000,	0x0000,	0x0810,
X	0x0FFF,	0xFFFF,	0xFFFF,	0xFFF0,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xFFFF,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
END_OF_FILE
if test 2190 -ne `wc -c <'bitmaps/sink7'`; then
    echo shar: \"'bitmaps/sink7'\" unpacked with wrong size!
fi
# end of 'bitmaps/sink7'
fi
if test -f 'bitmaps/stop.button' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/stop.button'\"
else
echo shar: Extracting \"'bitmaps/stop.button'\" \(333 characters\)
sed "s/^X//" >'bitmaps/stop.button' <<'END_OF_FILE'
X/* Format_version=1, Width=32, Height=16, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,0x0000,
X	0x007F,0xFE00,
X	0x007F,0xFE00,
X	0x007F,0xFE00,
X	0x007F,0xFE00,
X	0x007F,0xFE00,
X	0x007F,0xFE00,
X	0x007F,0xFE00,
X	0x007F,0xFE00,
X	0x007F,0xFE00,
X	0x007F,0xFE00,
X	0x007F,0xFE00,
X	0x007F,0xFE00,
X	0x007F,0xFE00,
X	0x007F,0xFE00,
X	0x0000,0x0000
END_OF_FILE
if test 333 -ne `wc -c <'bitmaps/stop.button'`; then
    echo shar: \"'bitmaps/stop.button'\" unpacked with wrong size!
fi
# end of 'bitmaps/stop.button'
fi
if test -f 'workman_ui.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'workman_ui.h'\"
else
echo shar: Extracting \"'workman_ui.h'\" \(1972 characters\)
sed "s/^X//" >'workman_ui.h' <<'END_OF_FILE'
X#ifndef	HEADER
X#define	HEADER
X
X/*
X * @(#)workman_ui.h	1.9 12/5/92
X *
X * User interface structure declarations.
X */
X
Xextern Attr_attribute	INSTANCE;
X
Xextern Xv_opaque	track_menu_create();
X
Xtypedef struct {
X	Xv_opaque	window1;
X	Xv_opaque	controls1;
X	Xv_opaque	tracks;
X	Xv_opaque	tracktimer;
X	Xv_opaque	songpos;
X	Xv_opaque	tracklen;
X	Xv_opaque	speaker;
X	Xv_opaque	repeat;
X	Xv_opaque	mode;
X	Xv_opaque	volume;
X	Xv_opaque	shuffle;
X	Xv_opaque	cdtimer;
X	Xv_opaque	cdlen;
X	Xv_opaque	cdgauge;
X	Xv_opaque	button3;
X	Xv_opaque	button2;
X	Xv_opaque	button4;
X} window1_objects;
X
Xextern window1_objects	*window1_objects_init();
X
Xtypedef struct {
X	Xv_opaque	popup1;
X	Xv_opaque	controls2;
X	Xv_opaque	artist;
X	Xv_opaque	cdname;
X	Xv_opaque	tracklist;
X	Xv_opaque	trackname;
X	Xv_opaque	trackoptions;
X	Xv_opaque	whichvolume;
X	Xv_opaque	defaultvolume;
X	Xv_opaque	defaultspeaker;
X	Xv_opaque	playmode;
X	Xv_opaque	autoplay;
X	Xv_opaque	button1;
X	Xv_opaque	button8;
X	Xv_opaque	buttonpl;
X} popup1_objects;
X
Xextern popup1_objects	*popup1_objects_init();
X
Xtypedef struct {
X	Xv_opaque	about;
X	Xv_opaque	controls3;
X	Xv_opaque	message1;
X	Xv_opaque	message2;
X	Xv_opaque	message7;
X	Xv_opaque	sink;
X	Xv_opaque	message3;
X	Xv_opaque	message4;
X	Xv_opaque	message5;
X	Xv_opaque	message6;
X} about_objects;
X
Xextern about_objects	*about_objects_init();
X
Xtypedef struct {
X	Xv_opaque	goodies;
X	Xv_opaque	controls4;
X	Xv_opaque	balance;
X	Xv_opaque	phones;
X	Xv_opaque	timemode_track;
X	Xv_opaque	playnewcds;
X	Xv_opaque	abrepeat;
X	Xv_opaque	a;
X	Xv_opaque	alabel;
X	Xv_opaque	b;
X	Xv_opaque	blabel;
X	Xv_opaque	indexscan;
X	Xv_opaque	split;
X	Xv_opaque	delete;
X	Xv_opaque	timemode_cd;
X} goodies_objects;
X
Xextern goodies_objects	*goodies_objects_init();
X
Xtypedef struct {
X	Xv_opaque	plpopup;
X	Xv_opaque	controls5;
X	Xv_opaque	playlists;
X	Xv_opaque	listname;
X	Xv_opaque	button7;
X	Xv_opaque	button6;
X	Xv_opaque	button5;
X	Xv_opaque	playlist;
X	Xv_opaque	delete;
X} plpopup_objects;
X
Xextern plpopup_objects	*plpopup_objects_init();
X
X#endif
END_OF_FILE
if test 1972 -ne `wc -c <'workman_ui.h'`; then
    echo shar: \"'workman_ui.h'\" unpacked with wrong size!
fi
# end of 'workman_ui.h'
fi
echo shar: End of archive 1 \(of 9\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 9 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM            | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly!      |
 "It's intuitively obvious to the most |    sources-x@imd.sterling.com
  casual observer..."                  |
