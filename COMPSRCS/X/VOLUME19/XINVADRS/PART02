Newsgroups: comp.sources.x
From: jonathan@Think.COM (Jonny Goldman)
Subject: v19i007:  xinvaders - space invaders for X, Part02/03
Message-ID: <1993Mar8.220509.11707@sparky.imd.sterling.com>
X-Md4-Signature: f46a8cd43c466b4fbfe7c30ba1d18bd4
Date: Mon, 8 Mar 1993 22:05:09 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: jonathan@Think.COM (Jonny Goldman)
Posting-number: Volume 19, Issue 7
Archive-name: xinvaders/part02
Environment: X11
Supersedes: xinvaders: Volume 8, Issue 62-66

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  Makefile base.c main.c spacers.c vaders.c widget.c
# Wrapped by chris@sparky on Mon Mar  8 15:41:52 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 3)."'
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(9091 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.51 89/12/12 12:37:30 jim Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X###########################################################################
X# Makefile generated from "Imake.tmpl" and <Imakefile>
X# $XConsortium: Imake.tmpl,v 1.77 89/12/18 17:01:37 jim Exp $
X#
X# Platform-specific parameters may be set in the appropriate .cf
X# configuration files.  Site-wide parameters may be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor doesn't define any unique symbols, you'll need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make Makefile", "make Makefiles", or "make World").
X#
X# If you absolutely can't get imake to work, you'll need to set the
X# variables at the top of each Makefile as well as the dependencies at the
X# bottom (makedepend will do this automatically).
X#
X
X###########################################################################
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.38 89/12/23 16:10:10 jim Exp $
X# operating system:  SunOS 4.1.1
X
X###########################################################################
X# site-specific configuration parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.21 89/12/06 11:46:50 jim Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar cq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X               RM = rm -f
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0664
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X          DESTDIR =
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X      COMPATFLAGS =
X
X      ALLINCLUDES = $(STD_INCLUDES) $(TOP_INCLUDES) $(INCLUDES) $(EXTRA_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(PROTO_DEFINES) $(DEFINES) $(COMPATFLAGS)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS)
X   LDCOMBINEFLAGS = -X -r
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X###########################################################################
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
X###########################################################################
X# X Window System make variables; this need to be coordinated with rules
X# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
X          PATHSEP = /
X        USRLIBDIR = $(DESTDIR)/usr/lib
X           BINDIR = $(DESTDIR)/usr/bin/X11
X          INCROOT = $(DESTDIR)/usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = $(DESTDIR)/usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           AWMDIR = $(LIBDIR)/awm
X           TWMDIR = $(LIBDIR)/twm
X           GWMDIR = $(LIBDIR)/gwm
X          MANPATH = $(DESTDIR)/usr/man
X    MANSOURCEPATH = $(MANPATH)/man
X           MANDIR = $(MANSOURCEPATH)1
X        LIBMANDIR = $(MANSOURCEPATH)3
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X
X        SOXLIBREV = 4.2
X          SOXTREV = 4.0
X         SOXAWREV = 4.0
X        SOOLDXREV = 4.0
X         SOXMUREV = 4.0
X        SOXEXTREV = 4.0
X
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X            FONTC = bdftosnf
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier.sh
X
X        CONFIGSRC = $(TOP)/config
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X     MKFONTDIRSRC = $(FONTSRC)/mkfontdir
X     EXTENSIONSRC = $(TOP)/extensions
X
X  DEPEXTENSIONLIB = $(USRLIBDIR)/libXext.a
X     EXTENSIONLIB =  -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X
X        DEPXMULIB =
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB =
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB =
X           XAWLIB = -lXaw
X
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X LINTEXTENSIONLIB = $(USRLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(USRLIBDIR)/llib-lX11.ln
X          LINTXMU = $(USRLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(USRLIBDIR)/llib-lXt.ln
X          LINTXAW = $(USRLIBDIR)/llib-lXaw.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X###########################################################################
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.67 89/12/18 17:14:15 jim Exp $
X
X###########################################################################
X# start of Imakefile
X
XLOCAL_LIBRARIES = $(XAWLIB) $(XMULIB) $(XTOOLLIB) $(XLIB)
X
XOBJS = spacers.o base.o widget.o main.o vaders.o shot.o score.o
X
XSRCS = spacers.c base.c widget.c main.c vaders.c shot.c score.c
X
XINCLUDES = -I$(TOP) -I$(TOP)/X11
X
X PROGRAM = xinvaders
X
Xall:: xinvaders
X
Xxinvaders: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xsaber_xinvaders:
X	#load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xosaber_xinvaders:
X	#load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xinstall:: xinvaders
X	$(INSTALL) -c $(INSTPGMFLAGS)   xinvaders $(BINDIR)
X
Xinstall.man:: xinvaders.man
X	$(INSTALL) -c $(INSTMANFLAGS) xinvaders.man $(MANDIR)/xinvaders.1
X
Xdepend::
X	$(DEPEND) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
X###########################################################################
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) \#*
X
XMakefile::
X	-@if [ -f Makefile ]; then \
X	echo "	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak"; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	#load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	#load $(ALLDEFINES) $(OBJS)
X
X###########################################################################
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X###########################################################################
X# dependencies generated by makedepend
X
END_OF_FILE
  if test 9091 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'base.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'base.c'\"
else
  echo shar: Extracting \"'base.c'\" \(7113 characters\)
  sed "s/^X//" >'base.c' <<'END_OF_FILE'
X/* 
XCopyright notice:
X
XThis is mine.  I'm only letting you use it.  Period.  Feel free to rip off
Xany of the code you see fit, but have the courtesy to give me credit.
XOtherwise great hairy beasties will rip your eyes out and eat your flesh
Xwhen you least expect it.
X
XJonny Goldman <jonathan@think.com>
X
XWed May  8 1991
X*/
X
X/* base.c - handle movement, etc. of the base. */
X
X#include "vaders.h"
X
Xextern int paused;
XBoolean basedestroyed;
X
Xstatic Boolean showingexplosion = FALSE;
X
Xvoid DrawBuildings();
X
X#define BASEY (gameheight-base->height)
X
Xtypedef struct _BaseRec {
X  int x;			/* Location. */
X  int v;			/* velocity */
X  int width, height;		/* box of this base. */
X  XImage *shape_image;		/* an XImage for the spaceship */
X} BaseRec, *Base;
X
XBaseRec baserec;
X
XBase base = &baserec;
X
XXImage *explosion;
X
X#define BaseNearPoint(base, x, y)	\
X  ((base)->x <= (x) && (x) < (base)->x + (base)->width  && \
X   y <= BASEY + (base)->height && y > BASEY)
X
X#include "base1.bit"
X#include "base2.bit"
X#include "explode1.bit"
X#include "explode2.bit"
X
Xint ReadBaseImage()
X{
X  unsigned int width, height;
X  int x_hot, y_hot;
X  char *data, filename[255];
X  int status;
X
X  base->width = (scale == 1) ? base1_width : base2_width;
X  base->height = (scale == 1) ? base1_height : base2_height;
X
X  base->shape_image = XCreateImage(dpy,
X				   DefaultVisual(dpy, DefaultScreen(dpy)),
X				   1,
X				   XYBitmap,
X				   0,
X				   (scale == 1) ? base1_bits : base2_bits,
X				   base->width, base->height,
X				   8, 0);
X
X  base->shape_image->bitmap_bit_order = LSBFirst;
X  base->shape_image->byte_order = LSBFirst;
X
X  explosion = XCreateImage(dpy,
X			   DefaultVisual(dpy, DefaultScreen(dpy)),
X			   1,
X			   XYBitmap,
X			   0,
X			   (scale == 1) ? explode1_bits : explode2_bits,
X			   (scale == 1) ? explode1_width : explode2_width,
X			   (scale == 1) ? explode1_height : explode2_height,
X			   8, 0);
X  explosion->bitmap_bit_order = LSBFirst;
X  explosion->byte_order = LSBFirst;
X  
X  return BitmapSuccess;
X}
X
Xvoid InitBase()
X{
X    if( ReadBaseImage() != BitmapSuccess) {
X      fprintf(stderr, "Error reading base image.\n");
X      exit(20);
X    }
X    basedestroyed = TRUE;
X    showingexplosion = FALSE;
X    basetimerid = NULL;
X    base->v = 0;
X}
X
X
X
Xvoid PaintBase(gc)
XGC gc;
X{
X  XPutImage(dpy, gamewindow, gc, base->shape_image,
X	    0, 0, base->x, gameheight-base->height, base->width, base->height);
X}
X
X
XShowBase(i, gc)
Xint i;
XGC gc;
X{
X  XPutImage(dpy, labelwindow, gc, base->shape_image,
X	    0, 0, i*(base->width+2), gameheight/2-(3*base->height),
X	    base->width, base->height);
X}
X
XPaintBasesLeft()
X{
X  int i;
X  XDrawString(dpy, labelwindow, scoregc,
X	      0, gameheight-(4*base->height),
X	      "Bases", 5);
X  for(i = 0; i < basesleft; i++) {
X    ShowBase(i, basegc);
X  }
X}
X
X
Xvoid ShowExplosion(gc)
XGC gc;
X{
X  XPutImage(dpy, gamewindow, gc, explosion,
X	      0, 0, base->x, gameheight-base->height, explosion->width, explosion->height);
X}
X
Xvoid DestroyBase()
X{
X  if(!paused) {
X    PaintBase(backgc);
X    basedestroyed = TRUE;
X    showingexplosion = TRUE;
X    ShowExplosion(basegc);
X    if (basetimerid) XtRemoveTimeOut(basetimerid);
X    basetimerid = XtAddTimeOut(1000, MoveBase, (Opaque) MoveBase);
X  }
X}
X
X
XBoolean ShotHitsBase(x,y)
Xint x,y;
X{
X  if(!basedestroyed && BaseNearPoint(base, x, y)) {
X    DestroyBase();
X    return TRUE;
X  }
X  return FALSE;
X}
X
XResetGame()
X{
X  static Arg args[1];
X
X  spacer_shown = 0;
X  SuspendTimers();
X  XClearWindow(dpy, gamewindow);
X  paused = 1;
X  InitScore();
X  basesleft--;
X  level = 1;
X  CreateVaders(level);
X  spacer_counter = 1000;
X  numshots = 0;
X  numvshots = 0;
X  PaintAllVaders();
X  PaintBasesLeft();
X  InitBuildings();
X  DrawBuildings();
X  lastscore = 0;
X  PaintScore();
X  XSync(dpy, 0);
X  basedestroyed = FALSE;
X  base->x = base->v = 0;
X  showingexplosion = FALSE;
X  PaintBase(basegc);
X  XtSetArg(args[0], XtNlabel, "Start");
X  XtSetValues(pausebutton, args, 1);
X}
X
X/*ARGSUSED*/
Xvoid MoveBase(closure, id)
XOpaque closure;
XXtIntervalId id;
X{
X  if (closure != (Opaque) MoveBase) return;
X  if(!paused) {
X    if (basedestroyed) {
X      if (showingexplosion) {
X	ShowExplosion(backgc);
X	showingexplosion = FALSE;
X	basetimerid = XtAddTimeOut(2000, MoveBase, (Opaque) MoveBase);
X	return;
X      }
X      if (basesleft <= 0) {
X	ResetGame();
X	return;
X      }
X      base->x = 0;
X      basesleft--;
X      ShowBase(basesleft, backgc);
X      PaintBase(basegc);
X      PaintScore();
X      basedestroyed = FALSE;
X      base->v = 0;
X    }
X
X    if (!paused)
X      basetimerid = XtAddTimeOut(basewait, MoveBase, (Opaque) MoveBase);
X    if(base->v) {
X      PaintBase(backgc);
X      base->x += base->v;
X      base->x = (base->x < 0) ? 0 :
X      ((base->x > gamewidth-base->width) ? gamewidth-base->width : base->x);
X      PaintBase(basegc);
X    }
X  }
X}
X
Xvoid MoveLeft()
X{
X  if(!paused) base->v= -scale;
X}
X
X
Xvoid MoveRight()
X{
X  if(!paused) base->v = scale;
X}
X
X
Xvoid Stop()
X{
X  if(!paused)
X    base->v = 0;
X}
X
X
Xvoid Fire()
X{
X    if (!basedestroyed&&!paused) AddShot(base->x+base->width/2, gameheight-base->height);
X}
X
X/* this part is for the buildings */
X
X#define NUMBUILDINGS 4
X#define HUNKROWS 4
X#define NUMHUNKS 10
X#define HUNKWIDTH (2*scale)
X#define HUNKHEIGHT (4*scale)
X#define buildingwidth HUNKWIDTH*NUMHUNKS
X#define buildingheight HUNKHEIGHT*HUNKROWS
X
Xtypedef struct {
X  int x,y;
X  Boolean hunks[HUNKROWS][NUMHUNKS];
X} BuildingRec, *Building;
X
XBuildingRec buildings[NUMBUILDINGS];
X
X
Xvoid DrawBuildingHunk(building, r, c, gc)
XBuilding building;
Xint r,c;
XGC gc;
X{
X  int x, y;
X
X  x = building->x+c*HUNKWIDTH;
X  y = gameheight-scale*45+r*HUNKHEIGHT;
X
X  XFillRectangle(dpy, gamewindow, gc, x, y, HUNKWIDTH, HUNKHEIGHT);
X}
X
Xvoid ToastHunk(building,r,c)
XBuilding building;
Xint r,c;
X{
X  building->hunks[r][c] = FALSE;
X  DrawBuildingHunk(building, r, c, backgc);
X}
X
XBoolean ShotHitsBuilding(x, y)
Xint x,y;
X{
X  int i, r, c;
X  Building building;
X
X  for(i=0; i< NUMBUILDINGS; i++) {
X    building = &buildings[i];
X    if(x>=building->x && x<building->x+buildingwidth &&
X       y>=gameheight-scale*45 && y<gameheight-scale*45+buildingheight) {
X      r = (y-(gameheight-scale*45))/HUNKHEIGHT;
X      c = (x-building->x)/HUNKWIDTH;
X      if (r<0 || r>=HUNKROWS)
X	printf("Error in row");
X      if (c<0 || c>=NUMHUNKS)
X	printf("Error in column");
X      if(building->hunks[r][c]) {
X	ToastHunk(building, r,c);
X	return TRUE;
X      }
X      return FALSE;
X    }
X  }
X  return FALSE;
X}
X
XInitBuildings()
X{
X  int i, j, k;
X
X  for(i=0; i< NUMBUILDINGS; i++) {
X    buildings[i].x = i*((gamewidth ?
X			 (scale*(VWIDTH-70)) :
X			 (gamewidth-scale*70)))/4+scale*35+(HUNKWIDTH*NUMHUNKS)/2;
X    for (j=0; j<HUNKROWS; j++)
X      for (k = 0; k < NUMHUNKS; k++) 
X	buildings[i].hunks[j][k] = TRUE;
X  }
X  j--;
X
X  for(i=0; i< NUMBUILDINGS; i++) {
X    buildings[i].hunks[0][0] = FALSE;
X    buildings[i].hunks[0][NUMHUNKS-1] = FALSE;
X    for (k = 3; k < NUMHUNKS-3; k++) 
X	buildings[i].hunks[j][k] = FALSE;
X  }
X}
X
Xvoid DrawBuildings()
X{
X  int i, j, k;
X
X  for(i=0; i< NUMBUILDINGS; i++) {
X    for (j=0; j<HUNKROWS; j++)
X      for (k = 0; k < NUMHUNKS; k++) 
X	if(buildings[i].hunks[j][k]) DrawBuildingHunk(&buildings[i], j, k, buildinggc);
X  }
X}
END_OF_FILE
  if test 7113 -ne `wc -c <'base.c'`; then
    echo shar: \"'base.c'\" unpacked with wrong size!
  fi
  # end of 'base.c'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
  echo shar: Extracting \"'main.c'\" \(8498 characters\)
  sed "s/^X//" >'main.c' <<'END_OF_FILE'
X/* 
XCopyright notice:
X
XThis is mine.  I'm only letting you use it.  Period.  Feel free to rip off
Xany of the code you see fit, but have the courtesy to give me credit.
XOtherwise great hairy beasties will rip your eyes out and eat your flesh
Xwhen you least expect it.
X
XJonny Goldman <jonathan@think.com>
X
XWed May  8 1991
X*/
X
X/* main.c -- create our windows and initialize things. */
X
X#define MAIN
X#include "vaders.h"
X#include <X11/Xaw/Form.h>
X#ifndef X11R3
X#include <X11/Xaw/Label.h>
X#else
X#include <X11/IntrinsicP.h>
X#include <X11/Label.h>
X#endif
Xstatic int width, height;		/* Size of window. */
X
X#ifdef XFILESEARCHPATH
Xstatic void AddPathToSearchPath();
X#endif
X
Xstatic XrmOptionDescRec table[] = {
X    {"-debug",	"*debug",	XrmoptionNoArg,	NULL},
X};
X
Xstatic XtResource resources[] = {
X    {XtNwidth, XtCWidth, XtRInt, sizeof(int),
X	 (Cardinal)&width, XtRImmediate, (caddr_t) VWIDTH},
X    {XtNheight, XtCHeight, XtRInt, sizeof(int),
X	 (Cardinal)&height, XtRImmediate, (caddr_t) VHEIGHT},
X    {"debug", "Debug", XtRBoolean, sizeof(Boolean),
X	 (Cardinal)&debug, XtRString, "off"},
X    {"font", "Font", XtRString, sizeof(String),
X	 (Cardinal)&vaderfont, XtRString, (String)"9x15"},
X    {"scale", "Scale", XtRInt, sizeof(int),
X	 (Cardinal)&scale, XtRImmediate, (caddr_t) 2},
X    {"basewait", "BaseWait", XtRInt, sizeof(int),
X	 (Cardinal)&basewait, XtRImmediate, (caddr_t) 10},
X    {"vaderwait", "VaderWait", XtRInt, sizeof(int),
X	 (Cardinal)&vaderwait, XtRImmediate, (caddr_t) 300},
X    {"spacerwait", "SpacerWait", XtRInt, sizeof(int),
X	 (Cardinal)&spacerwait, XtRImmediate, (caddr_t) 50},
X    {"shotwait", "ShotWait", XtRInt, sizeof(int),
X	 (Cardinal)&shotwait, XtRImmediate, (caddr_t) 10},
X    {"vshotwait", "VshotWait", XtRInt, sizeof(int),
X	 (Cardinal)&vshotwait, XtRImmediate, (caddr_t) 30},
X    {"basecolor", "BaseColor", XtRPixel, sizeof(Pixel),
X	 (Cardinal)&basepixel, XtRString, "cyan"},
X    {"spacercolor", "SpacerColor", XtRPixel, sizeof(Pixel),
X	 (Cardinal)&spacerpixel, XtRString, "gray"},
X    {"buildingcolor", "BuildingColor", XtRPixel, sizeof(Pixel),
X	 (Cardinal)&buildingpixel, XtRString, "yellow"},
X    {"vader1color", "Vader1Color", XtRPixel, sizeof(Pixel),
X	 (Cardinal)&vader1pixel, XtRString, "blue"},
X    {"vader2color", "Vader2Color", XtRPixel, sizeof(Pixel),
X	 (Cardinal)&vader2pixel, XtRString, "green"},
X    {"vader3color", "Vader3Color", XtRPixel, sizeof(Pixel),
X	 (Cardinal)&vader3pixel, XtRString, "red"},
X    {"shotcolor", "ShotColor", XtRPixel, sizeof(Pixel),
X	 (Cardinal)&shotpixel, XtRString, "lavender"},
X    {"vshotcolor", "VshotColor", XtRPixel, sizeof(Pixel),
X	 (Cardinal)&vshotpixel, XtRString, "orange"},
X    {"scorecolor", "ScoreColor", XtRPixel, sizeof(Pixel),
X	 (Cardinal)&scorepixel, XtRString, "white"},
X    {"maxshots", "MaxShots", XtRInt, sizeof(int),
X	 (Cardinal) &maxshots, XtRImmediate, (caddr_t) 1},
X    {"maxvshots", "MaxVshots", XtRInt, sizeof(int),
X	 (Cardinal) &maxvshots, XtRImmediate, (caddr_t) 6},
X    {"defaultfore", "DefaultFore", XtRPixel, sizeof(Pixel),
X	 (Cardinal) &defaultfore, XtRString, "white"},
X    {"defaultback", "DefaultBack", XtRPixel, sizeof(Pixel),
X	 (Cardinal) &defaultback, XtRString, "black"},
X};
X
X
X/*ARGSUSED*/
Xstatic void CvtStringToFloat(args, num_args, fromVal, toVal)
XArgList args;
XCardinal num_args;
XXrmValue    *fromVal;
XXrmValue    *toVal;
X{
X    static float  i;
X
X    if (sscanf((char *)fromVal->addr, "%f", &i) == 1) {
X	toVal->size = sizeof(float);
X	toVal->addr = (caddr_t) &i;
X    } else {
X	toVal->size = 0;
X	toVal->addr = NULL;
X    }
X}
X
Xstatic void AddResource(r, p)
Xchar *r;
XPixel *p;
X{
X    XrmValue value;
X    XrmDatabase db = XtDatabase(dpy);
X    value.size = sizeof(Pixel);
X    value.addr = (caddr_t) p;
X    XrmPutResource(&db, r, XtRPixel, &value);
X}
X
XWidget
XMakeCommandButton(box, name, function, vlink, hlink, data)
XWidget box, vlink, hlink;
Xchar *name;
XXtCallbackProc function;
Xcaddr_t data;
X{
X  Widget w;
X  Arg args[10];
X  Cardinal numargs;
X
X  numargs = 0;
X  if(vlink != NULL) {
X    XtSetArg(args[numargs], XtNfromVert, vlink); numargs++;
X  }
X  if(hlink != NULL) {
X    XtSetArg(args[numargs], XtNfromHoriz, hlink); numargs++;
X  }
X  w = XtCreateManagedWidget(name, commandWidgetClass, box, args, numargs);
X  if (function != NULL)
X    XtAddCallback(w, XtNcallback, function, data);
X  return w;
X}
X
Xmain(argc, argv)
XCardinal argc;
Xchar **argv;
X{
X  static Arg args[10];
X  int n;
X  Widget form, button;
X  extern WidgetClass labelwidgetclass;
X
X  me_image = NULL;
X
X  srandom(time(0));
X#ifdef XFILESEARCHPATH
X  AddPathToSearchPath(XFILESEARCHPATH);
X#endif
X  toplevel = XtInitialize(argv[0], "Vaders", table, XtNumber(table),
X			  &argc, argv);
X  dpy = XtDisplay(toplevel);
X  XtAddConverter(XtRString, XtRFloat, CvtStringToFloat, NULL, 0);
X  XtGetApplicationResources(toplevel, (caddr_t) NULL, 
X			    resources, XtNumber(resources),
X			    NULL, (Cardinal) 0);
X  AddResource("*background", &defaultback);
X  if (DisplayCells(dpy, DefaultScreen(dpy)) <= 2)
X    {
X      basepixel = defaultfore;
X      buildingpixel = defaultfore;
X      vader1pixel = defaultfore;
X      vader2pixel = defaultfore;
X      vader3pixel = defaultfore;
X      shotpixel = defaultfore;
X      vshotpixel = defaultfore;
X      scorepixel = defaultfore;
X    }
X  if (scale<1) scale = 1;
X  if (scale>2) scale = 2;
X  width = scale*VWIDTH;
X  height = scale*VHEIGHT;
X
X  form = XtCreateManagedWidget ("form", formWidgetClass,
X				toplevel, NULL, 0);
X
X  n = 0;
X  XtSetArg (args[n], XtNleft, XtChainLeft); n++;
X  XtSetArg (args[n], XtNright, XtChainLeft); n++;
X  XtSetArg (args[n], XtNtop, XtChainTop); n++;
X  XtSetArg (args[n], XtNbottom, XtChainTop); n++;
X  XtSetArg (args[n], XtNwidth, width); n++;
X  XtSetArg (args[n], XtNheight, height); n++;
X  
X  gamewidget = (VadersWidget)
X    XtCreateManagedWidget("field", vadersWidgetClass, form, args, n);
X
X  n = 0;
X  XtSetArg (args[n], XtNleft, XtChainLeft); n++;
X  XtSetArg (args[n], XtNright, XtChainLeft); n++;
X  XtSetArg (args[n], XtNtop, XtChainTop); n++;
X  XtSetArg (args[n], XtNbottom, XtChainTop); n++;
X  XtSetArg (args[n], XtNfromHoriz, gamewidget); n++;
X  XtSetArg (args[n], XtNhorizDistance, 5); n++;
X  XtSetArg (args[n], XtNwidth, scale*IWIDTH); n++;
X  XtSetArg (args[n], XtNheight, height/2); n++;
X  
X  labelwidget = (VadersWidget)
X    XtCreateManagedWidget("label", vadersWidgetClass, form, args, n);
X
X  pausebutton = MakeCommandButton(form, "pause", Pause, labelwidget, gamewidget, NULL);
X  XtSetArg(args[0], XtNlabel, " Start");
X  XtSetArg(args[1], XtNforeground, defaultfore);
X  XtSetArg(args[2], XtNbackground, defaultback);
X  XtSetArg(args[3], XtNborderColor, defaultfore);
X  XtSetValues(pausebutton, args, 4);
X  button = MakeCommandButton(form, "quit", Quit, pausebutton, gamewidget, NULL);
X  XtSetArg(args[0], XtNlabel, " Quit ");
X  XtSetArg(args[1], XtNforeground, defaultfore);
X  XtSetArg(args[2], XtNbackground, defaultback);
X  XtSetArg(args[3], XtNborderColor, defaultfore);
X  XtSetValues(button, args, 4);
X  infobutton = MakeCommandButton(form, "info", ShowInfo, button, gamewidget, NULL);
X  XtSetArg(args[0], XtNlabel, " Info ");
X  XtSetArg(args[1], XtNforeground, defaultfore);
X  XtSetArg(args[2], XtNbackground, defaultback);
X  XtSetArg(args[3], XtNborderColor, defaultfore);
X  XtSetValues(infobutton, args, 4);
X
X  XtRealizeWidget(toplevel);
X  ResetGame();
X  XtMainLoop();
X}
X
X#ifdef XFILESEARCHPATH
Xstatic void
XAddPathToSearchPath(path)
Xchar *path;
X{
X     char *old, *new;
X     extern char *getenv();
X     
X     old = getenv("XFILESEARCHPATH");
X     if (old) {
X#if defined(mips) || defined(hpux) || defined(sun)
X	  /* +1 for =, +2 for :, +3 for null */
X	  new = XtMalloc((Cardinal) (strlen("XFILESEARCHPATH") +
X				     strlen(old) +
X				     strlen(path) + 3));
X	  (void) strcpy(new, "XFILESEARCHPATH");
X	  (void) strcat(new, "=");
X	  (void) strcat(new, old);
X	  (void) strcat(new, ":");
X	  (void) strcat(new, path);
X	  putenv(new);
X#else
X	  /* +1 for colon, +2 for null */
X	  new = XtMalloc((Cardinal) (strlen(old) + strlen(path) + 2));
X	  (void) strcpy(new, old);
X	  (void) strcat(new, ":");
X	  (void) strcat(new, path);
X	  setenv("XFILESEARCHPATH", new, 1);
X#endif
X     }
X     else {
X#if defined(mips) || defined(hpux) || defined(sun)
X	  new = XtMalloc((Cardinal) (strlen("XFILESEARCHPATH") +
X				     strlen(path) + 2));
X	  (void) strcpy(new, "XFILESEARCHPATH");
X	  (void) strcat(new, "=");
X	  (void) strcat(new, path);
X	  putenv(new);
X#else
X	  setenv("XFILESEARCHPATH", path, 1);
X#endif
X     }
X}
X#endif
X
X#ifdef sparc
XXShapeCombineMask()
X{}
X
XXShapeQueryExtension()
X{}
X#endif
END_OF_FILE
  if test 8498 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
  fi
  # end of 'main.c'
fi
if test -f 'spacers.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'spacers.c'\"
else
  echo shar: Extracting \"'spacers.c'\" \(3471 characters\)
  sed "s/^X//" >'spacers.c' <<'END_OF_FILE'
X/* 
XCopyright notice:
X
XThis is mine.  I'm only letting you use it.  Period.  Feel free to rip off
Xany of the code you see fit, but have the courtesy to give me credit.
XOtherwise great hairy beasties will rip your eyes out and eat your flesh
Xwhen you least expect it.
X
XJonny Goldman <jonathan@think.com>
X
XWed May  8 1991
X*/
X
X/* spacers.c - handle movement, etc. of the little space ships. */
X
X#include "vaders.h"
X
XBoolean spacer_shown;
X
X#define SPACERY 0
X#define SPACERV 2*scale
X
Xtypedef struct _SpacerRec {
X  int x;			/* Location. */
X  int width, height;		/* box of this rock. */
X  int score;			/* value of this guy */
X  XImage *shape_image;		/* an XImage for the spaceship */
X} SpacerRec, *Spacer;
X
XSpacerRec spacerrec;
X
XSpacer spacer = &spacerrec;
X
X#define SpacerNearPoint(spacer, x, y)	\
X  ((spacer)->x <= (x) && (x) < (spacer)->x + (spacer)->width  && \
X   y <= SPACERY + (spacer)->height && y > SPACERY)
X
Xint spacer_counter;		/* number of steps to wait for new spacer */
X
Xint showing_sexplosion = FALSE;
X
X/* now the code */
X
Xvoid PaintSpacer(gc)
X     GC gc;
X{
X    XPutImage(dpy, gamewindow, gc, spacer->shape_image,
X	      0, 0, spacer->x, SPACERY, spacer->width, spacer->height);
X}
X
X
Xvoid ShowSexplosion(gc)
XGC gc;
X{
X  char score[5];
X
X  sprintf(score,"%3d", spacer->score);
X  XDrawString(dpy, gamewindow, gc, spacer->x, SPACERY+spacer->height, score, 3);
X
X}
X
X/*
X * Destroy the Spacer, much like the ship.
X */
X
Xstatic void DestroySpacer()
X{
X  score += spacer->score;
X  PaintScore();
X
X  if(!paused) {
X    PaintSpacer(backgc);
X    ShowSexplosion(spacergc);
X    if (spacertimerid)
X      XtRemoveTimeOut(spacertimerid);
X    XtAddTimeOut(1000, MoveSpacer, (Opaque) MoveSpacer);
X    showing_sexplosion = TRUE;
X    spacer_shown = FALSE;
X  }
X}
X
XBoolean ShotHitsSpacer(x, y)
X     int x, y;
X{
X  if(spacer_shown) {
X    if (SpacerNearPoint(spacer, x, y)) {
X      DestroySpacer();
X      return TRUE;
X    }
X  }
X  return FALSE;
X}
X
X
X
Xvoid MakeSpacer()
X{
X  spacer_shown = TRUE;
X
X  spacer->x=0;
X  spacer->score = 50*(random()%6+1);
X  PaintSpacer(spacergc);
X}
X  
X/*ARGSUSED*/
Xvoid MoveSpacer(closure, id)
X     Opaque closure;
X     XtIntervalId id;
X{
X  if (closure != (Opaque) MoveSpacer) return;
X  spacertimerid = XtAddTimeOut(spacerwait, MoveSpacer, (Opaque) MoveSpacer);
X  if (!paused) {
X    if (showing_sexplosion) {
X      showing_sexplosion = FALSE;
X      ShowSexplosion(backgc);
X      spacer_shown = FALSE;
X      spacer_counter = 1000;
X      return;
X    }
X    if (spacer_shown) {
X      PaintSpacer(backgc);
X      spacer->x += SPACERV;
X      if (spacer->x < gamewidth-spacer->width) {
X	PaintSpacer(spacergc);
X      } else {
X	spacer_shown = FALSE;
X	spacer_counter = 1000;
X      }
X    } else
X      if (spacer_counter-- == 0) MakeSpacer();
X  }
X}
X
X
X#include "spacer1.bit"
X#include "spacer2.bit"
X
Xint ReadSpacerImages()
X{
X  spacer->width = (scale == 1) ? spacer1_width : spacer2_width;
X  spacer->height = (scale == 1) ? spacer1_height : spacer2_height;
X
X  spacer->shape_image = XCreateImage(dpy,
X				     DefaultVisual(dpy, DefaultScreen(dpy)),
X				     1,
X				     XYBitmap,
X				     0,
X				     (scale == 1) ? spacer1_bits : spacer2_bits,
X				     spacer->width, spacer->height,
X				     8, 0);
X
X  spacer->shape_image->bitmap_bit_order = LSBFirst;
X  spacer->shape_image->byte_order = LSBFirst;
X
X  return BitmapSuccess;
X}
X
Xvoid InitSpacers()
X{
X  if(ReadSpacerImages()!= BitmapSuccess) {
X    fprintf(stderr, "Error reading Spacer image\n");
X    exit(10);
X  }
X
X  spacertimerid = NULL;
X}
END_OF_FILE
  if test 3471 -ne `wc -c <'spacers.c'`; then
    echo shar: \"'spacers.c'\" unpacked with wrong size!
  fi
  # end of 'spacers.c'
fi
if test -f 'vaders.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'vaders.c'\"
else
  echo shar: Extracting \"'vaders.c'\" \(11501 characters\)
  sed "s/^X//" >'vaders.c' <<'END_OF_FILE'
X/* 
XCopyright notice:
X
XThis is mine.  I'm only letting you use it.  Period.  Feel free to rip off
Xany of the code you see fit, but have the courtesy to give me credit.
XOtherwise great hairy beasties will rip your eyes out and eat your flesh
Xwhen you least expect it.
X
XJonny Goldman <jonathan@think.com>
X
XWed May  8 1991
X*/
X
X/* vaders.c - handle movement, etc. of the vaders. */
X
X#include "vaders.h"
X
X#define NUMTYPES	3	/* How many types of vaders there are. */
X#define NUMROWS		5	/* number of rows of vaders */
X#define NUMVADERS	11	/* Maximum of vaders of each type. */
X#define BASEY 10
X#define VADERWIDTH	(14*scale)
X#define VADERHEIGHT	(12*scale)
X#define VADERYINC	(8*scale)
X
Xstatic XImage *Vader_Image[NUMTYPES][2];	/* XImages for the vaders. */
X
Xextern int basex;		/* Base location */
X
Xstatic int tick = 0;
Xstatic int vaderwaitinit;
X
Xtypedef struct _VaderRec {
X  int x, y;			/* Location. */
X  int vx, vy;			/* Velocity. */
X  int width, height;		/* size of this Vader. */
X  GC gc;			/* graphics context */
X  XImage *shape_image[2];
X  int value;
X  Boolean alive;
X  Boolean exploded;
X} VaderRec, *Vader;
X
XVaderRec vaders[NUMROWS][NUMVADERS];
X
Xint numvaders = 0;		/* Number of vaders existing. */
X
X
Xtypedef struct _BaseRec {
X  int x;			/* Location. */
X  int v;			/* velocity */
X  int width, height;		/* box of this base. */
X  XImage *shape_image;		/* an XImage for the spaceship */
X} BaseRec, *Base;
X
Xextern Base base;
X
XXImage *Explode_image;
X
X/* indicates pad around vader bitmap for better collision detection */
X#define VADERPAD 	scale
X
X#define PointInVader(vader, x, y)	\
X  (x >= (vader)->x+VADERPAD && y >= (vader)->y &&		\
X   x <= (vader)->x + (vader)->width-VADERPAD  && y <= (vader)->y + (vader)->height)
X
Xstatic void PaintVader(vader, gc)
X     Vader vader;
X     GC gc;
X{
X  int rx, ry, w, h;
X  
X  w = vader->width;
X  h = vader->height;
X
X  rx = vader->x;
X  ry = vader->y;
X  
X  XPutImage(dpy, gamewindow, gc, vader->shape_image[tick],
X	    0, 0, rx, ry, w, h);
X}
X
Xstatic void PaintExplodedVader(vader, gc)
X     Vader vader;
X     GC gc;
X{
X  int rx, ry, w, h;
X  
X  w = Explode_image->width;
X  h = Explode_image->height;
X
X  rx = vader->x;
X  ry = vader->y;
X  
X  XPutImage(dpy, gamewindow, gc, Explode_image,
X	    0, 0, rx, ry, w, h);
X}
X
Xstatic void DestroyVader(vader)
XVader vader;
X{
X  PaintVader(vader, backgc);
X  score += vader->value;
X  PaintScore();
X  numvaders--;
X  switch (numvaders) {
X  case 32:
X  case 16:
X  case 8:
X  case 4:
X  case 2:
X  case 1:
X    vaderwait /= 2; break;
X  }
X  vader->alive = FALSE;
X  vader->exploded = TRUE;
X  PaintExplodedVader(vader, vader->gc);
X}
X
X
X
XBoolean ShotHitsVader(x, y)
X     int x, y;
X{
X  register Vader vader;
X  int i, j;
X
X  for(j = 0; j < NUMROWS; j++)
X    for (i=0 ; i<NUMVADERS ; i++) {
X      vader = &vaders[j][i];
X      if(vader->alive && PointInVader(vader, x, y)) {
X	DestroyVader(vader);
X	return TRUE;
X    }
X  }
X  return FALSE;
X}
X
X
X
Xvoid PaintAllVaders()
X{
X  int i, j;
X  Vader vader;
X
X  for(j = 0; j < NUMROWS; j++)
X    for (i=0 ; i< NUMVADERS ; i++) {
X      vader = &vaders[j][i];
X      if(vader->alive) PaintVader(vader, vader->gc);
X    }
X}
X
X/* add some random shot */
X
Xvoid SFire()
X{
X  register Vader vader;
X  int i, j, c;
X
X  for(j = 0, c = random()%NUMVADERS; j < NUMVADERS; j++) {
X    for (i= NUMROWS-1; i>=0; i--) {
X      vader = &vaders[i][(c+j)%NUMVADERS];
X      if(vader->alive) {
X	AddVshot(vader->x+vader->width/2, vader->y+vader->height);
X	return;
X      }
X    }
X  }
X}
X
Xvoid VaderBoop(tick)
Xint tick;
X{
X  XKeyboardControl vals;
X
X  vals.bell_duration = vaderwait/2;
X  vals.bell_pitch = tick ? 60 : 40;
X
X  XChangeKeyboardControl(dpy, KBBellPitch | KBBellDuration, &vals);
X  XBell(dpy, 100);
X}
X
Xstatic int createvaderp = FALSE;
X
X/*ARGSUSED*/
Xvoid MoveVaders(closure, id)
X     Opaque closure;
X     XtIntervalId id;
X{
X  register Vader vader;
X  register int i, j;
X  Boolean reversep;
X
X  reversep = FALSE;
X
X  if (closure != (Opaque) MoveVaders) return;
X  if (createvaderp) {
X    createvaderp = FALSE;
X    CreateVaders(level);
X  }
X  if (numvaders == 0 && numvshots == 0) {
X    vadertimerid = XtAddTimeOut(2000, MoveVaders, (Opaque) MoveVaders);
X    level++;
X    createvaderp = TRUE;
X    InitBuildings();
X    DrawBuildings();
X  } else {
X    vadertimerid = XtAddTimeOut(vaderwait, MoveVaders, (Opaque) MoveVaders);
X    /* this is the way to do it, but on the Sun it SUCKS!
X    VaderBoop(tick);
X    */
X    if((random()%1000)>900) SFire();
X    for(j = 0; j < NUMROWS; j++)
X      for (i=0 ; i< NUMVADERS ; i++) {
X	vader = &vaders[j][i];
X	if (vader->exploded) {
X	  PaintExplodedVader(vader, backgc);
X	  vader->exploded = FALSE;
X	}
X	else if (vader->alive) {
X	  if (vader->vx > 0)
X	    (void)ShotHitsBuilding(vader->x+vader->width, vader->y+vader->height);
X	  else
X	    (void)ShotHitsBuilding(vader->x, vader->y+vader->height);
X	  vader->x += vader->vx;
X	  if ((vader->x < (VADERWIDTH-vader->width)/2 && vader->vx < 0) || 
X	      (vader->x > gamewidth-VADERWIDTH && vader->vx > 0))
X	    reversep = TRUE;
X	  tick = tick ? 0 : 1;
X	  PaintVader(vader, vader->gc);
X	  tick = tick ? 0 : 1;
X	}
X      }
X    tick = tick ? 0 : 1;
X    if (reversep) {
X      for(j = 0; j < NUMROWS; j++)
X	for (i=0 ; i< NUMVADERS ; i++) {
X	  vader = &vaders[j][i];
X	  if (vader->alive) {
X	    PaintVader(vader, backgc);
X	    vader->vx = -vader->vx;
X	    vader->y = vader->y + VADERYINC;
X	    PaintVader(vader, vader->gc);
X	    if(vader->y >= gameheight-base->height+vader->height) {
X	      ResetGame();
X	      return;
X	    }
X	  }
X	}
X    }
X  }
X}
X
X#include "vader1a1.bit"
X#include "vader1b1.bit"
X#include "vader1a2.bit"
X#include "vader1b2.bit"
X#include "vader2a1.bit"
X#include "vader2b1.bit"
X#include "vader2a2.bit"
X#include "vader2b2.bit"
X#include "vader3a1.bit"
X#include "vader3b1.bit"
X#include "vader3a2.bit"
X#include "vader3b2.bit"
X#include "vexplod1.bit"
X#include "vexplod2.bit"
X
Xint ReadVaderImages()
X{
X  if (scale == 1) {
X    Vader_Image[0][0] = XCreateImage(dpy,
X				     DefaultVisual(dpy, DefaultScreen(dpy)),
X				     1,
X				     XYBitmap,
X				     0,
X				     vader1a1_bits,
X				     vader1a1_width, vader1a1_height,
X				     8, 0);
X    Vader_Image[0][0]->bitmap_bit_order = LSBFirst;
X    Vader_Image[0][0]->byte_order = LSBFirst;
X
X    Vader_Image[0][1] = XCreateImage(dpy,
X				     DefaultVisual(dpy, DefaultScreen(dpy)),
X				     1,
X				     XYBitmap,
X				     0,
X				     vader1b1_bits,
X				     vader1b1_width, vader1b1_height,
X				     8, 0);
X    Vader_Image[0][1]->bitmap_bit_order = LSBFirst;
X    Vader_Image[0][1]->byte_order = LSBFirst;
X
X    Vader_Image[1][0] = XCreateImage(dpy,
X				     DefaultVisual(dpy, DefaultScreen(dpy)),
X				     1,
X				     XYBitmap,
X				     0,
X				     vader2a1_bits,
X				     vader2a1_width, vader2a1_height,
X				     8, 0);
X    Vader_Image[1][0]->bitmap_bit_order = LSBFirst;
X    Vader_Image[1][0]->byte_order = LSBFirst;
X
X    Vader_Image[1][1] = XCreateImage(dpy,
X				     DefaultVisual(dpy, DefaultScreen(dpy)),
X				     1,
X				     XYBitmap,
X				     0,
X				     vader2b1_bits,
X				     vader2b1_width, vader2b1_height,
X				     8, 0);
X    Vader_Image[1][1]->bitmap_bit_order = LSBFirst;
X    Vader_Image[1][1]->byte_order = LSBFirst;
X
X    Vader_Image[2][0] = XCreateImage(dpy,
X				     DefaultVisual(dpy, DefaultScreen(dpy)),
X				     1,
X				     XYBitmap,
X				     0,
X				     vader3a1_bits,
X				     vader3a1_width, vader3a1_height,
X				     8, 0);
X    Vader_Image[2][0]->bitmap_bit_order = LSBFirst;
X    Vader_Image[2][0]->byte_order = LSBFirst;
X
X    Vader_Image[2][1] = XCreateImage(dpy,
X				     DefaultVisual(dpy, DefaultScreen(dpy)),
X				     1,
X				     XYBitmap,
X				     0,
X				     vader3b1_bits,
X				     vader3b1_width, vader3b1_height,
X				     8, 0);
X    Vader_Image[2][1]->bitmap_bit_order = LSBFirst;
X    Vader_Image[2][1]->byte_order = LSBFirst;
X
X    Explode_image = XCreateImage(dpy,
X				 DefaultVisual(dpy, DefaultScreen(dpy)),
X				 1,
X				 XYBitmap,
X				 0,
X				 vexplode1_bits,
X				 vexplode1_width, vexplode1_height,
X				 8, 0);
X
X    Explode_image->bitmap_bit_order = LSBFirst;
X    Explode_image->byte_order = LSBFirst;
X  }
X  else {
X    Vader_Image[0][0] = XCreateImage(dpy,
X				     DefaultVisual(dpy, DefaultScreen(dpy)),
X				     1,
X				     XYBitmap,
X				     0,
X				     vader1a2_bits,
X				     vader1a2_width, vader1a2_height,
X				     8, 0);
X    Vader_Image[0][0]->bitmap_bit_order = LSBFirst;
X    Vader_Image[0][0]->byte_order = LSBFirst;
X
X    Vader_Image[0][1] = XCreateImage(dpy,
X				     DefaultVisual(dpy, DefaultScreen(dpy)),
X				     1,
X				     XYBitmap,
X				     0,
X				     vader1b2_bits,
X				     vader1b2_width, vader1b2_height,
X				     8, 0);
X    Vader_Image[0][1]->bitmap_bit_order = LSBFirst;
X    Vader_Image[0][1]->byte_order = LSBFirst;
X
X    Vader_Image[1][0] = XCreateImage(dpy,
X				     DefaultVisual(dpy, DefaultScreen(dpy)),
X				     1,
X				     XYBitmap,
X				     0,
X				     vader2a2_bits,
X				     vader2a2_width, vader2a2_height,
X				     8, 0);
X    Vader_Image[1][0]->bitmap_bit_order = LSBFirst;
X    Vader_Image[1][0]->byte_order = LSBFirst;
X
X    Vader_Image[1][1] = XCreateImage(dpy,
X				     DefaultVisual(dpy, DefaultScreen(dpy)),
X				     1,
X				     XYBitmap,
X				     0,
X				     vader2b2_bits,
X				     vader2b2_width, vader2b2_height,
X				     8, 0);
X    Vader_Image[1][1]->bitmap_bit_order = LSBFirst;
X    Vader_Image[1][1]->byte_order = LSBFirst;
X
X    Vader_Image[2][0] = XCreateImage(dpy,
X				     DefaultVisual(dpy, DefaultScreen(dpy)),
X				     1,
X				     XYBitmap,
X				     0,
X				     vader3a2_bits,
X				     vader3a2_width, vader3a2_height,
X				     8, 0);
X    Vader_Image[2][0]->bitmap_bit_order = LSBFirst;
X    Vader_Image[2][0]->byte_order = LSBFirst;
X
X    Vader_Image[2][1] = XCreateImage(dpy,
X				     DefaultVisual(dpy, DefaultScreen(dpy)),
X				     1,
X				     XYBitmap,
X				     0,
X				     vader3b2_bits,
X				     vader3b2_width, vader3b2_height,
X				     8, 0);
X    Vader_Image[2][1]->bitmap_bit_order = LSBFirst;
X    Vader_Image[2][1]->byte_order = LSBFirst;
X
X    Explode_image = XCreateImage(dpy,
X				 DefaultVisual(dpy, DefaultScreen(dpy)),
X				 1,
X				 XYBitmap,
X				 0,
X				 vexplode2_bits,
X				 vexplode2_width, vexplode2_height,
X				 8, 0);
X
X    Explode_image->bitmap_bit_order = LSBFirst;
X    Explode_image->byte_order = LSBFirst;
X  }
X
X  return BitmapSuccess;
X}
X
X
Xvoid CreateVaders(level)
Xint level;
X{
X  int offset, i, j;
X  Vader vader;
X
X  offset = MIN(level, 8);
X  vaderwait = vaderwaitinit;
X  numvaders = NUMROWS*NUMVADERS;
X  for (j = 0; j < NUMROWS; j++)
X    for (i = 0; i < NUMVADERS; i++) {
X      vader = &vaders[j][i];
X      vader->x = 3 + VADERWIDTH*i+(VADERWIDTH-vader->width)/2;
X      vader->y = VADERHEIGHT*(offset+j);
X      vader->vx = scale;
X      vader->alive = TRUE;
X      vader->exploded = FALSE;
X    }
X}
X
Xvoid InitVaders()
X{
X  int i, j, k, width, height;
X  Vader vader;
X
X  level = 1;
X  if (ReadVaderImages() != BitmapSuccess) {
X    fprintf(stderr, "Error reading Invader images\n");
X    exit(10);
X  }
X
X  for (j = 0; j < NUMROWS; j++) {
X    switch (j) {
X    case 0:
X      k = 0; break;
X    case 1:
X    case 2:
X      k = 1; break;
X    case 3:
X    case 4:
X      k = 2; break;
X    }
X    width = Vader_Image[k][0]->width;
X    height = Vader_Image[k][0]->height;
X    for (i = 0; i < NUMVADERS; i++) {
X      vader = &vaders[j][i];
X      vader->shape_image[0] = Vader_Image[k][0];
X      vader->shape_image[1] = Vader_Image[k][1];
X      vader->gc = vadergc[k];
X      vader->width = width;
X      vader->height = height;
X      vader->value = 10*(3-k);
X    }
X  }
X  vaderwaitinit = vaderwait;
X  CreateVaders(level);
X  vadertimerid = NULL;
X}
END_OF_FILE
  if test 11501 -ne `wc -c <'vaders.c'`; then
    echo shar: \"'vaders.c'\" unpacked with wrong size!
  fi
  # end of 'vaders.c'
fi
if test -f 'widget.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'widget.c'\"
else
  echo shar: Extracting \"'widget.c'\" \(10215 characters\)
  sed "s/^X//" >'widget.c' <<'END_OF_FILE'
X/* 
XCopyright notice:
X
XThis is mine.  I'm only letting you use it.  Period.  Feel free to rip off
Xany of the code you see fit, but have the courtesy to give me credit.
XOtherwise great hairy beasties will rip your eyes out and eat your flesh
Xwhen you least expect it.
X
XJonny Goldman <jonathan@think.com>
X
XWed May  8 1991
X*/
X
X/* widget.c -- handle things that make the playing field behave as a widget. */
X
X#include "vaders.h"
X#include <X11/Xaw/Form.h>
X
Xtypedef struct _BaseRec {
X  int x;			/* Location. */
X  int v;			/* velocity */
X  int width, height;		/* box of this base. */
X  XImage *shape_image;		/* an XImage for the spaceship */
X} BaseRec, *Base;
X
Xextern Base base;
X
Xvoid HandleFocus();
Xvoid HandleStruct();
Xvoid Pause();
X
Xstatic XtActionsRec actions[] = {
X    {"grab-focus",	(XtActionProc) TakeFocus},
X    {"left",		MoveLeft},
X    {"right",		MoveRight},
X    {"stop",		Stop},
X    {"fire",		Fire},
X    {"pause",		Pause},
X    {"quit",		Quit},
X};
X
Xstatic char defaultTranslation[] =
X     "<Btn1Down>:	left()\n\
X     <Btn1Up>:		stop()\n\
X     <Btn2Down>:	fire()\n\
X     <Btn3Down>:	right()\n\
X     <Btn3Up>:		stop()\n\
X     <KeyDown>z:	fire()\n\
X     <KeyDown>\\,:	left()\n\
X     <KeyUp>\\,:	stop()\n\
X     <KeyDown>.:	right()\n\
X     <KeyUp>.:		stop()\n\
X     <KeyDown>\\ :	fire()\n\
X     <KeyDown>p:	pause()\n\
X     <KeyDown>q:	quit()";
X
X
Xstatic void ClassInitialize() {}
X
X/*ARGSUSED*/
Xstatic void Initialize(request, w)
XWidget request, w;
X{
X    XtAddEventHandler(toplevel, (EventMask) FocusChangeMask, FALSE,
X		      HandleFocus, (Opaque) NULL);
X    XtAddEventHandler(toplevel, (EventMask) StructureNotifyMask, FALSE,
X		      HandleStruct, (Opaque) NULL);
X}
X
X
Xstatic void Realize(w, valueMask, attributes)
XWidget w;
XMask *valueMask;
XXSetWindowAttributes *attributes;
X{
X  XGCValues forevalues;
X  XGCValues backvalues;
X  XGCValues basevalues;
X  XGCValues buildingvalues;
X  XGCValues vader1values;
X  XGCValues vader2values;
X  XGCValues vader3values;
X  XGCValues shotvalues;
X  XGCValues scorevalues;
X  XGCValues spacervalues;
X
X  /*
X   * Safety check.
X   */
X
X  if (w->core.width == 0) w->core.width = 1;
X  if (w->core.height == 0) w->core.height = 1;
X
X  XtCreateWindow(w, (unsigned int) InputOutput, (Visual *) CopyFromParent,
X		 *valueMask, attributes);
X
X  gamewidth = scale*VWIDTH;
X  gameheight = scale*VHEIGHT;
X  gamewindow = XtWindow(gamewidget);
X  labelwindow = XtWindow(labelwidget);
X
X  forevalues.background = WhitePixel(dpy, DefaultScreen(dpy));
X  forevalues.foreground = BlackPixel(dpy, DefaultScreen(dpy));
X  foregc = XCreateGC(dpy, XtWindow(w),
X		     (XtGCMask) GCForeground | GCBackground, &forevalues);
X  XSetFunction(dpy, foregc, GXcopy);
X  backvalues.background = defaultback;
X  backvalues.foreground = defaultback;
X  backgc = XCreateGC(dpy, XtWindow(w),
X		     (XtGCMask) GCForeground | GCBackground, &backvalues);
X  XSetFunction(dpy, backgc, GXcopy);
X  basevalues.background = defaultback;
X  basevalues.foreground = basepixel;
X  basegc = XCreateGC(dpy, XtWindow(w),
X		     (XtGCMask) GCForeground | GCBackground, &basevalues);
X  XSetFunction(dpy, basegc, GXcopy);
X  buildingvalues.background = defaultback;
X  buildingvalues.foreground = buildingpixel;
X  buildinggc = XCreateGC(dpy, XtWindow(w),
X		     (XtGCMask) GCForeground | GCBackground, &buildingvalues);
X  XSetFunction(dpy, buildinggc, GXcopy);
X  vader1values.background = defaultback;
X  vader1values.foreground = vader1pixel;
X  vadergc[0] = XCreateGC(dpy, XtWindow(w),
X			 (XtGCMask) GCForeground | GCBackground, &vader1values);
X  XSetFunction(dpy, vadergc[0], GXcopy);
X  vader2values.background = defaultback;
X  vader2values.foreground = vader2pixel;
X  vadergc[1] = XCreateGC(dpy, XtWindow(w),
X			 (XtGCMask) GCForeground | GCBackground, &vader2values);
X  XSetFunction(dpy, vadergc[1], GXcopy);
X  vader3values.background = defaultback;
X  vader3values.foreground = vader3pixel;
X  vadergc[2] = XCreateGC(dpy, XtWindow(w),
X			 (XtGCMask) GCForeground | GCBackground, &vader3values);
X  XSetFunction(dpy, vadergc[2], GXcopy);
X  shotvalues.background = defaultback;
X  shotvalues.foreground = shotpixel;
X  shotgc = XCreateGC(dpy, XtWindow(w),
X		     (XtGCMask) GCForeground | GCBackground, &shotvalues);
X  XSetFunction(dpy, shotgc, GXcopy);
X  scorevalues.background = defaultback;
X  scorevalues.foreground = scorepixel;
X  scorevalues.font = XLoadFont(dpy, vaderfont);
X  scoregc = XCreateGC(dpy, XtWindow(w),
X		     (XtGCMask) GCForeground | GCBackground | GCFont, &scorevalues);
X  XSetFunction(dpy, scoregc, GXcopy);
X  shotvalues.background = defaultback;
X  shotvalues.foreground = vshotpixel;
X  vshotgc = XCreateGC(dpy, XtWindow(w),
X		      (XtGCMask) GCForeground | GCBackground, &shotvalues);
X  XSetFunction(dpy, vshotgc, GXcopy);
X  spacervalues.background = defaultback;
X  spacervalues.foreground = spacerpixel;
X  spacergc = XCreateGC(dpy, XtWindow(w),
X		       (XtGCMask) GCForeground | GCBackground, &spacervalues);
X  XSetFunction(dpy, spacergc, GXcopy);
X
X  InitBase();
X  InitBuildings();
X  InitVaders();
X  InitSpacers();
X  InitShot();
X  InitScore();
X}
X
Xvoid SuspendTimers()
X{
X  if (basetimerid) 
X    XtRemoveTimeOut(basetimerid);
X  basetimerid = NULL;
X  if (vadertimerid)
X    XtRemoveTimeOut(vadertimerid);
X  vadertimerid = NULL;
X  if (shottimerid)
X    XtRemoveTimeOut(shottimerid);
X  shottimerid = NULL;
X  if (vshottimerid)
X    XtRemoveTimeOut(vshottimerid);
X  vshottimerid = NULL;
X  if (spacertimerid)
X    XtRemoveTimeOut(spacertimerid);
X  spacertimerid = NULL;
X}
X
Xvoid EnableTimers()
X{
X  if (basetimerid == NULL)
X    basetimerid = XtAddTimeOut(basewait, MoveBase, (Opaque) MoveBase);
X  if (vadertimerid == NULL)
X    vadertimerid = XtAddTimeOut(vaderwait, MoveVaders,
X			       (Opaque) MoveVaders);
X  if(spacertimerid == NULL)
X    spacertimerid = XtAddTimeOut(spacerwait, MoveSpacer,
X				 (Opaque) MoveSpacer);
X  if (shottimerid == NULL)
X    shottimerid = XtAddTimeOut(shotwait, MoveShots,
X			       (Opaque) MoveShots);
X  if (vshottimerid == NULL)
X    vshottimerid = XtAddTimeOut(vshotwait, MoveVshots,
X				(Opaque) MoveVshots);
X}
X
X/*ARGSUSED*/
Xstatic void HandleExpose(w, event)
XWidget w;
XXEvent *event;
X{
X /*  if (event->xexpose.count) return; */
X  XSync(dpy, 0);
X  /* suspend events */
X  SuspendTimers();
X  /* rebuild the display */
X  XSync(dpy, 0);
X  XClearWindow(dpy, gamewindow);
X  if (!basedestroyed)
X    PaintBase(basegc);
X  if(spacer_shown)
X    PaintSpacer(spacergc);
X  PaintAllVaders();
X  PaintAllShots();
X  PaintBasesLeft();
X  DrawBuildings();
X  PaintScore();
X  XSync(dpy, 0);
X  /* enable events */
X  if(!paused) 
X    EnableTimers();
X}
X
X/*ARGSUSED*/
Xvoid Quit(w, closure, event)
XWidget w;
XOpaque closure;
XXEvent *event;
X{
X    XCloseDisplay(dpy);
X    exit(0);
X}
X
Xint paused = 1;
X
X/*ARGSUSED*/
Xstatic void HandleFocus(w, closure, event)
XWidget w;
XOpaque closure;
XXEvent *event;
X{
X}
X
X/*ARGSUSED*/
Xvoid Pause(w, closure, event)
XWidget w;
XOpaque closure;
XXEvent *event;
X{
X  static Arg args[1];
X  if (paused) {
X    paused = 0;
X    EnableTimers();
X    XtSetArg(args[0], XtNlabel, "Pause");
X    XtSetValues(pausebutton, args, 1);
X    HandleExpose(NULL, NULL, NULL);
X  } else {
X    paused = 1;
X    SuspendTimers();
X    XtSetArg(args[0], XtNlabel, "Resume");
X    XtSetValues(pausebutton, args, 1);
X  }
X}
X
X/*ARGSUSED*/
Xstatic void HandleStruct(w, closure, event)
XWidget w;
XOpaque closure;
XXEvent *event;
X{
X}
X
Xstatic void Destroy() {}
X
Xstatic void Resize() {}
X
Xstatic Boolean SetValues() 
X{
X  return FALSE;
X}
X
Xstatic Boolean TakeFocus()
X{
X    XSetInputFocus(dpy, gamewindow, RevertToPointerRoot, CurrentTime);
X    return TRUE;
X}
X
X#include "me.h"
X
Xvoid ShowInfo(w, closure, event)
XWidget w;
XOpaque closure;
XXEvent *event;
X{
X  int xloc, yloc;
X
X  paused = 0;
X  Pause(NULL, NULL, NULL);
X  /* rebuild the display */
X  XSync(dpy, 0);
X  XClearWindow(dpy, gamewindow);
X  if (me_image == NULL) {
X    me_image = XCreateImage(dpy,
X			    DefaultVisual(dpy, DefaultScreen(dpy)),
X			    1,
X			    XYBitmap,
X			    0,
X			    (scale == 1) ? me1_bits:me2_bits,
X			    (scale == 1) ? me1_width : me2_width,
X			    (scale == 1) ? me1_height: me2_height,
X			    8, 0);
X    me_image->bitmap_bit_order = LSBFirst;
X    me_image->byte_order = LSBFirst;
X  }
X  
X  xloc = (gamewidth-((scale == 1) ? me1_width : me2_width))/2;
X  yloc = ((scale == 1) ? me1_width : me2_width) + 10;
X
X  XPutImage(dpy, gamewindow, foregc, me_image,
X	    0, 0, 
X	    xloc, 0,
X	    (scale == 1) ? me1_width : me2_width,
X	    (scale == 1) ? me1_height: me2_height);
X
X  if (scale == 2)
X    XDrawImageString(dpy, gamewindow, scoregc, xloc, yloc, "Xinvaders, by Jonny Goldman", 27);
X  else {
X    XDrawImageString(dpy, gamewindow, scoregc, xloc+30, yloc, "Xinvaders", 9);
X    XDrawImageString(dpy, gamewindow, scoregc, xloc, yloc+15, "by Jonny Goldman", 16);
X  }
X
X  XSync(dpy, 0);
X}
X
X
XVadersClassRec vadersClassRec = {
X  {
X/* core_class fields      */
X    /* superclass         */    (WidgetClass) &widgetClassRec,
X    /* class_name         */    "Xinvaders",
X    /* widget_size        */    sizeof(VadersRec),
X    /* class_initialize   */    ClassInitialize,
X    /* class_part_initiali*/	NULL,
X    /* class_inited       */    FALSE,
X    /* initialize         */    Initialize,
X    /* initialize_hook	  */	NULL,
X    /* realize            */    Realize,
X    /* actions            */    actions,
X    /* num_actions        */    XtNumber(actions),
X    /* resources          */    NULL,
X    /* num_resources      */    (Cardinal) 0,
X    /* xrm_class          */    NULLQUARK,
X    /* compress_motion    */    TRUE,
X    /* compress_exposure  */    TRUE,
X    /* compress_enterleave*/	TRUE,
X    /* visible_interest   */    FALSE,
X    /* destroy            */    Destroy,
X    /* resize             */    Resize,
X    /* expose             */    HandleExpose,
X    /* set_values         */    SetValues,
X    /* set_values_hook	  */	NULL,
X    /* set_values_almost  */	NULL,
X    /* get_values_hook	  */	NULL,
X    /* accept_focus       */    TakeFocus,
X    /* version		  */	XtVersion,
X    /* callback_private	  */	NULL,
X    /* tm_table		  */	defaultTranslation,
X    /* query_geometry	  */	NULL,
X    /* display_accelerator*/	NULL,
X    /* extension`	  */	NULL,
X  },{
X    /* mumble             */    0       /* Make C compiler happy   */
X  }
X};
X
XWidgetClass vadersWidgetClass = (WidgetClass)&vadersClassRec;
END_OF_FILE
  if test 10215 -ne `wc -c <'widget.c'`; then
    echo shar: \"'widget.c'\" unpacked with wrong size!
  fi
  # end of 'widget.c'
fi
echo shar: End of archive 2 \(of 3\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM            | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly!      |
 "It's intuitively obvious to the most |    sources-x@imd.sterling.com
  casual observer..."                  |
