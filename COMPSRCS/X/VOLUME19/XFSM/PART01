Newsgroups: comp.sources.x
From: rgasch@nl.oracle.com (Robert Gasch)
Subject: v19i088:  xfsm - X Files System Monitor, Part01/01
Message-ID: <1993Apr24.174454.407@sparky.imd.sterling.com>
X-Md4-Signature: 5515415a45a67e4297ebf46b7d7efaca
Date: Sat, 24 Apr 1993 17:44:54 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: rgasch@nl.oracle.com (Robert Gasch)
Posting-number: Volume 19, Issue 88
Archive-name: xfsm/part01
Environment: X11, UNIX


xfsm displays a list of bar graphs for the file systems of the host you are
on. Clicking on a file system gives you detailed information - clicking on
it again closes the detail window. Type "xfsm -?" for help.

The following systems are supported:
	SVR4
        SunOS
        AIX
        LINUX
        TOS


This is a shell archive. Remove everything below the header and the 
extract the files by typing "sh <filename>".
----------------------- cut here ---------------------
echo x - Imakefile
sed '/^X/s///' > Imakefile << '/'
X/* ************************************************************************* *
X   xfsm - (C) Copyright 1993 Robert Gasch (rgasch@nl.oracle.com)
X
X   Permission to use, copy, modify and distribute this software for any 
X   purpose and without fee is hereby granted, provided that this copyright
X   notice appear in all copies as well as supporting documentation. All
X   work developed as a consequence of the use of this program should duly
X   acknowledge such use.
X
X   No representations are made about the suitability of this software for
X   any purpose. This software is provided "as is" without express or implied 
X   warranty.
X
X   All commercial uses of xfsm must be done by agreement with the autor.
X * ************************************************************************* */
X
X
X
X# basic definitions for the Imake. Call xmkmf to generate the makefile.
X
XLOCAL_LIBRARIES = $(XLIB)
X
X
X# flags for the compiler and linker
X# uncomment the DEFINES definition appropriate fro your machine
X# DEFINES		= -g -DSUNOS -DDEBUG 
XDEFINES		= -O -DSUNOS 
X# DEFINES		= -O -DLINUX
X# DEFINES		= -O -DSVR4 
X# DEFINES		= -O -DAIX 
X# DEFINES		= -O -DTOS 
X
X
XOBJS = main.o util.o
XSRCS = main.c util.c
X
X
XINCLUDES = -I$(TOP) -I$(TOP)/X11
X
X
XComplexProgramTarget(xfsm)
X
/
echo x - Makefile.std
sed '/^X/s///' > Makefile.std << '/'
X# path to X header files
XXINCLUDE        = /usr/X11R5/include
X
X# path to X library files
XXLIBS           = /usr/X11R5/lib
X
X# the C compiler, used as linker ;o)
XCC		= cc 
X
X# flags for the compiler and linker
X# uncomment the CFLAGS definition appropriate fro your machine 
X# CFLAGS		= -g -DSUNOS -DDEBUG -I$(XINCLUDE)
XCFLAGS		= -O -DSUNOS -I$(XINCLUDE)
X# CFLAGS		= -O -LINUX -I$(XINCLUDE)
X# CFLAGS		= -O -DSVR4 -I$(XINCLUDE)
X# CFLAGS		= -O -DAIX -I$(XINCLUDE)
X# CFLAGS		= -O -DTOS -I$(XINCLUDE)
XLDFLAGS         = -L$(XLIBS)
XLDLIBS          = -lX11 -lm 
XOBJS		= main.o util.o
X
X
X### Dependencies/Actions
X
Xxfsm:	$(OBJS)
X	@echo -n "Linking xfsm ... "
X	@$(CC) $(LDFLAGS) $(OBJS) $(LDLIBS) -o xfsm
X	@echo "Done."
X
Xclean:
X	rm -rf *.o 
X
X
X### dependencies for each object
Xmain.o: main.c main.h
Xutil.o: util.c main.h
X
/
echo x - README
sed '/^X/s///' > README << '/'
X			This is the README file for 
X
X
X                        X   X  FFFFF  SSSSS  M     M                            
X                         X X   F      S      M M M M                          
X                          X    FFFFF  SSSSS  M  M  M                           
X                         X X   F          S  M     M                           
X                        X   X  F      SSSSS  M     M                            
X
X                        X      File   System Monitor   (c) 1993 Robert Gasch
X
X
X1) Author & Copyright
X
X	xfsm was written by Robert Gasch (rgasch@nl.oracle.com) and is 
X	copyright by the author.
X
X2) Distribution Policy
X
X 	Permission to use, copy, modify and distribute this software for
X	any purpose and without fee is hereby granted, provided that this
X	copyright notice appear in all copies as well as supporting 
X	documentation. All work developed as a consequence of the use of 
X	this program should duly acknowledge such use.
X
X	All commercial uses of xfsm must be done by agreement with the
X	author.
X
X3) Guarantees
X
X	xfsm should work all right *but*
X
X	No representations are made about the suitability of this software 
X	for any purpose. This software is provided "as is" without express 
X	or implied warranty.
X
X4) What is xfsm?
X
X	xfsm stands for X File System Monitor and runs under MIT's X11
X	window system on several flavors of UNIX. It is a tool designed 
X	to make monitoring your file systems' status easy by displaying 
X	a simple bar graph for each file system greater than size 0. It
X	updates the file systems' statistics at regular intervals and 
X	has a scalable sleep time to allow fine tuning to save CPU
X	power.
X
X5) What if you change the program?
X
X	If you extend xfsm's functionality, add support for new UNIX
X	flavors, or simply solve bugs, *please*mail* me the changes(!)
X	as I'd like to act as the central source for xfsm. This will 
X	also enable me to include your changes in a future release. 
X	Unless it is generic please enclose it in a meaningful
X	#ifdef. If your change affects *many* lines, please provide
X	some method of me finding it back (preferrably a #ifdef, 
X	alternativeley some comment I can grep for). If I decide
X	to incorporate your fix in a future release (seems likely)
X	you'll be given credit.
X
X6) Systems currently supported
X
X	SVR4
X	SunOS
X	AIX
X	LINUX
X	TOS
X
X7) How do I get started?
X
X	This section assumes that you have all the necessary files! (The 
X	file "Manifest" contains a list of distributed files.)
X
X	a) Customize the Imakefile to suit your system setup. 
X	If it turns out that your system is not one of the currently
X	supported ones, you'll have to add the appropriate definitions.
X
X	b) Make the Makefile by typing 
X		xmkmf
X	If your system does not support generating makefiles from 
X	Imakefiles use "Makefile.std" as a template to build your
X	own.
X
X	c) Once you have a valid Makefile build xfsm by tying
X		make
X
X	Once you have created the executable, you're ready to go. The
X	executable will be created in the directory in which the source
X	for xfsm resides.
X
X8) Brief users guide
X
X	You can get a list of supported options by typing
X		xfsm -?
X
X	Once you have started xfsm you will get a window containing 
X	at least 1 bar graph (xfsm removes all file systems of size 0) 
X	and 2 menus. The Menus are:
X
X		Update Now - updates all files systems' statistics now
X		Quit       - exits xfsm
X
X	If you click on the graph of a file system with the left or middle
X	mouse button you get a window displaying the detailed statistics
X	for the file system. Clicking on the file system again, closes 
X	the detail window while clicking on another file system while the
X	detail window is open, displays this file system's statistics in 
X	the detail window.
X
X	The right mouse button is used to toggle the display mode. The
X	default startup mode graphs all file system equally big. By 
X	clicking with the right mouse button, the graphs are drawn in 
X	proportion to the file system's size. Clicking with the right
X	mouse button again reverts back to the original mode. 
X
X	The following keys can be used to control xfsm:
X		q - close the detail window
X		u - update now
X		t - toggle display mode
X
X	The Detail Window can display the following statistics. Depending
X	on the system you are on, you may not get all these statistics:
X		Total Size		The file system size in MB
X		Space Free		Free space in MB
X		Sapce Available		Space Available to non-root in MB
X		Block Size		The size of a block in Bytes
X		Blocks			The number of blocks
X		Blocks Free		The number of free blocks
X		Blocks Available	Blocks available to non-root
X		File Inodes		The number of Inodes
X		Free Inodes		The number of free Inodes
X		Inodes Availible	Inodes available to non-root user
X
X	You can not resize the detail window. You can resize the main
X	window but xfsm will now let you make the main window smaller 
X	beyond a certain point. This is to ensure that the output 
X	remains neat and legible.
X
X8) Command line parameters
X
X	xfsm accepts the following command line options:
X
X 	-r              displays space available to root rather than user
X                                not available on TOS
X	-b              draw bars black
X	-m              minimize window size
X	-p              don't display percent
X	-a              toggle display mode to absolute bar size
X	-f              displays percent free rather than percent in use
X	-s <arg>        scale sleep interval by <arg>
X	-i <arg>        interval at which display is updated (default = 300s)
X	-d <arg1 ... argn> do not include these file systems
X	-?              get help
X
X9) Troubleshooting
X
X	If you find a problem which is not listed below there are 2 things
X	you can do:
X		1) Fix it yourself. If this case please send me a short 
X		note explaining the problem and the fix. Note that the
X		code for xfsm is actually pretty simple and for the 
X		most part well commented so it should not be hard to
X		figure out what's going on. If you can, please do it 
X		this way as I am busy enough as is is.
X		2) Send me a description of the problem. I'll try to
X		attend to it as fast as I can, but work comes first so
X		this may take a while.
X
X	Problem: Some windows are not updated correctly.
X	Solution: This sounds like a known bug. Type "xfsm -?" to see
X		the known bugs. Don't send me mail about these. They'll
X		be fixed with the next release.
X
X	Problem: Compile fails with "GET_FS" undefined.
X	Solution: You didn't provide the compiler with any -D options 
X		for a particular machine type. Change your Imakefile 
X		accordingly and go back to section 7 (How do I get 
X		started?).
X
X	Problem: Compile fails with some member of the stats structure 
X		undefined.
X	Solution: You have selected inappropriate -D options for your 
X		machine.  Change the option (if available) or add the 
X		appropriate code. If you really don't know how to do 
X		the latter mail me. Depending on my schedule I may 
X		decide to help you out.
X
X	Problem: xfsm's reponse time is unacceptably slow.
X	Solutions: Check if you're not scaling the sleep time using the
X		-s command line option.
X
X	Problem: xfsm starts OK but I don't get the window.
X	Solution: Check if your DISPLAY variable is set correctly.
X
X10) I've found a bug. What now?
X
X	Read section 9 (Troubeshooting) to see if it falls under one of
X	the problems listed there. If not, reread the first part of
X	section 9 (9.1 and 9.2). Then decide on the best way to approch
X	your problem.
X
X11) I've come up with a feature which I think would be useful.
X
X	Here again you can do 2 things:
X		1) Implement it yourself. If you do this then
X		reread section 5 (What if you change the program?)
X		to get an idea what I would like you to do with the
X		result.
X		2) Mail me. I'll consider it and if I agree with you
X		will implement it whenever I find time.
X
X12) I'm extatic about this wonderful program. How can I make the author happy?
X
X	If you really feel this way, how about a short mail message
X	telling me that you are happy about using xfsm.
X
X13) I hate this worthless program. It ruins my day.
X
X	Don't use it. Don't mail me!
X
X14) Credits
X
X	msleep was taken from Tom Boutell's "Broken Throne".
X
X	Many thanks to Joost Helberg for identifying numerous bugs,
X	suggesting the relative display mode and providing the LINUX
X	#defines.
/
echo x - main.c
sed '/^X/s///' > main.c << '/'
X/* ************************************************************************* *
X   xfsm - (C) Copyright 1993 Robert Gasch (rgasch@nl.oracle.com)
X
X   Permission to use, copy, modify and distribute this software for any 
X   purpose and without fee is hereby granted, provided that this copyright
X   notice appear in all copies as well as supporting documentation. All
X   work developed as a consequence of the use of this program should duly
X   acknowledge such use.
X
X   No representations are made about the suitability of this software for
X   any purpose. This software is provided "as is" without express or implied 
X   warranty.
X
X   All commercial uses of xfsm must be done by agreement with the autor.
X * ************************************************************************* */
X
X
X
X/* *************************************************************************
X   This program displays a list of bar graphs for the file systems of the 
X   machine you are on. The following switches are supported:
X	-r		displays space available to root rather than user
X				not available on TOS
X	-b		draw bars black
X	-m		minimize window size
X	-p		don't display percent
X	-a		toggle display mode to absolute bar size
X	-f		displays percent free rather than percent in use
X	-s <arg>	scale sleep interval by <arg>
X	-i <arg>	interval at which display is updated (default = 300s)
X	-d <arg1 ... argn> do not include these file systems
X	-?		get this description
X
X
X   Version History:
X	24-3-93: 1.00 
X	29-3-93: 1.01 
X			Added support for gray filling of graphs
X	10-4-93: 1.10 
X			Added resize support, detail window title,
X			fixed interval handling in msleep delay loop,
X			added -m, -p and -s option
X	12-4-93: 1.11
X			Fixed resize bug which resulted in graph
X			heights being too small
X	14-4-93: 1.20
X			Fixed percent display placement, added -t flag 
X			and toggle handling
X	16-4-93: 1.21
X			Added MB line for detail window
X	18-4-93: 1.22
X			Fixed overflow problem for MB line (detail window)
X			for very large file systems, adapted sleep 
X			handling to allow larger scaling of sleep time
X	19-4-93: 1.23
X			Added LINUX ifdefs
X   ************************************************************************* */
X
X
X#include "main.h"
X
XDisplay			*mydisplay;
XWinType			main_win,
X			menu[MENU_ITEMS],
X			fs_win[MAXFS],
X			detail_win;
XXGCValues		gray_gc_val;
XXEvent			myevent;
Xunsigned long		fg, bg;
XKeySym  		mykey;
XXWindowAttributes  	attribs;
XXSizeHints		myhint;
Xint 			done,
X			show_use=TRUE,
X			upd_interval=300,
X			NFS=0,
X			detail_open=NOGOOD,
X			minimize=FALSE,
X			percent=TRUE,
X			absolute=FALSE;
X			gray=TRUE;
Xlong			usec=SLEEPT,
X			sec=0,
X			b_blocks=0;
Xfloat			fs_perc[MAXFS];
Xstring  		fs_name[MAXFS],
X			hname;
X
X#ifdef TOS
X			root=TRUE;
X#else
X			root=FALSE;
X#endif
X
X#if defined (SUNOS) || defined (TOS) || defined (AIX) || defined (LINUX)
Xstruct statfs 		stats[MAXFS];
X# else
X# ifdef SVR4
Xstruct statvfs		stats[MAXFS];
X# endif
X#endif
X
X
X
Xmain (argc, argv)
Xint argc;
Xchar **argv;
X{
X	int			i=0, t, myscreen, scrdepth;
X	unsigned long int 	gray_mask;
X	FILE 			*fp;
X
X	/* *** see if we catch a help flag *** */
X	for (i=1; i<argc; i++)
X		if (HELPARG)
X			do_help(argv[0]); 
X
X	/* *** Open Pipe to appropriate command *** */
X	if ((fp=popen (GET_HOSTNAME, "r")) == NULL)
X		{
X		fprintf (stderr, "Error opening pipe: %s ... Exiting\n",
X			GET_HOSTNAME);
X		exit (1);
X		}
X	if (fgets(hname,MAXCPL,fp)!=NULL)
X		{
X		/* *** convert trailing \n to \0 *** */
X		char *c;
X		if ((c=strchr (hname, '\n'))!=NULL)
X			*c='\0';
X		printf ("Hostname = %s\n", hname);
X		}
X	else
X		fprintf (stderr, "Can't read hostname ...\n");
X	pclose (fp);
X
X	/* *** open pipe to get file system names *** */
X	if ((fp=popen (GET_FS, "r")) == NULL)
X		{
X		fprintf (stderr, "Error opening pipe: %s ... Exiting\n",
X			GET_FS);
X		exit (1);
X		}
X#ifdef AIX
X	fgets(fs_name[0],MAXCPL,fp);	/* skip header line */
X#endif
X
X	/* *** read all file systems *** */
X	while (NFS<MAXFS && (fgets(fs_name[NFS++],MAXCPL,fp)!=NULL))
X		{
X		/* *** convert trailing \n to \0 *** */
X		char *c;
X		if ((c=strchr (fs_name[NFS-1], '\n'))!=NULL)
X			*c='\0';
X		printf ("%s\n", fs_name[NFS-1]);
X		}
X	if (NFS==MAXFS)
X	   	{
X	   	printf ("Maximum number of file systems (%d) exceeded...",
X			MAXFS);
X	   	printf ("Ignoring Rest\n");
X	   	}
X	else
X		NFS--;	/* *** fix blank line at end *** */
X	pclose (fp);
X	if (NFS < 1)
X		{
X		fprintf (stderr, "Mount returned no valid file syetems ... \
Xexiting\n");
X		exit (1);
X		}
X	printf ("%d file systems found ...\n", NFS);
X
X	/* *** process arguments *** */
X	process_args (argc, argv);
X
X	/* *** get the file system statistics *** */
X	get_fs_stat();
X
X	/* *** connect to X Server and assign screen *** */
X	if ((mydisplay = XOpenDisplay("")) == NULL)
X		{
X		fprintf (stderr, "Error Opening Display ... Exiting\n");
X		exit (1);
X		}
X	myscreen = DefaultScreen (mydisplay);
X	scrdepth = DefaultDepth (mydisplay, myscreen);
X	init_all_windows();
X
X	/* *** assign foreground and backgound colors *** */
X	bg = WhitePixel (mydisplay, myscreen);
X	fg = BlackPixel (mydisplay, myscreen);
X
X	/* *** create Main Program Windows *** */
X	create_window (DefaultRootWindow(mydisplay), &main_win, argc, argv);
X	myhint.min_width=MIN_WIN_X;
X	myhint.min_height=((MIN_INTERVAL*NFS)+BEGIN_NFS);
X	myhint.flags=PMinSize;
X	XSetStandardProperties (mydisplay, main_win.win, 0, 0, None, argv, 
X		argc, &myhint);
X	
X	/* *** create all the buttons using child windows *** */
X 	for (i=0; i < MENU_ITEMS ; ++i) 
X		create_window (main_win.win, &menu[i], argc, argv); 
X	for (i=0; i < NFS; i++)
X		{
X		create_window (main_win.win, &fs_win[i], argc, argv); 
X		if (gray)
X			{
X			gray_gc_val.tile=XCreatePixmapFromBitmapData (mydisplay,
X				fs_win[i].win, gray1_bits, gray1_width, 
X				gray1_height, fg, bg, scrdepth);
X			if (!gray_gc_val.tile)
X				{
X				fprintf (stderr, "Couldn't create gray tile \
X... escaping to black fill\n");
X				gray=FALSE;
X				}
X			else
X				{
X				gray_gc_val.fill_style=FillTiled;
X				gray_mask= GCFillStyle | GCTile;
X				XChangeGC (mydisplay, fs_win[i].gc, gray_mask, 
X					&gray_gc_val);
X				}
X			}
X		}
X
X	/* *** Map window definitions onto screen *** */
X	XMapRaised (mydisplay, main_win.win);
X	XMapSubwindows (mydisplay, main_win.win);
X
X#if DEBUG
X	fprintf (stdout, "Setup is Done!\n");
X#endif
X
X/* ************************************************************ */
X/* ************** setup is done - main event loop ************* */
X/* ************************************************************ */
X
X	do_event_loop (argc, argv);
X
X	/* *** we are done - destroy all the windows *** */
X	if (detail_open != NOGOOD)
X		{
X		XFreeGC (mydisplay, detail_win.gc);
X		XDestroyWindow (mydisplay, detail_win.win);
X		}
X	destroy_menu (menu, MENU_ITEMS);
X	destroy_menu (fs_win, NFS);
X	XFreeGC (mydisplay, main_win.gc);
X	XDestroyWindow (mydisplay, main_win.win);
X	XCloseDisplay (mydisplay);
X	exit (0);
X}
X
X
X
Xvoid do_event_loop (argc, argv)
Xint argc;
Xchar **argv;
X{
X	XEvent 	tevent;
X	int	count, cont, this_item, i, t, ppnfs; 
X	long	target=time(NULL)+upd_interval;
X	char	text[10];
X
X	done=FALSE;
X	while (!done)
X		{
X		/* *** here we wait while there are no events *** */
X		/* *** and count out down our interval. We    *** */
X		/* *** wait .25 seconds each turn to save CPU *** */
X		while (XPending (mydisplay) == 0)
X		{
X		msleep ();
X		if ((time(NULL)) >= target)
X			{
X#ifdef DEBUG
X			printf ("Update interval finished ... updating\n");
X#endif
X			redraw_main_win ();
X			if (detail_open != NOGOOD)
X				write_detail (detail_open);
X			target=target+upd_interval;
X			}
X		}
X  		/* read the next event */
X  		XNextEvent (mydisplay, &myevent);
X  		switch (myevent.type)
X  		    {
X		    /* *** expose event -> redraw the window *** */
X		    case Expose:
X			/* ********************************************* *
X			 *  since a window can generate multiple expose  *
X			 *  events we can collapse these into one redraw *
X			 * ********************************************* */
X			count=0;
X			do
X				{
X				XPeekEvent (mydisplay, &tevent);
X				if (tevent.xexpose.window == 
X				    myevent.xexpose.window)
X					{
X					XNextEvent (mydisplay, &myevent);
X					count++;
X					}
X				}
X			while(tevent.xexpose.window==myevent.xexpose.window);
X	
X#if DEBUG
X			if (!count)
X				fprintf(stdout, 
X					"got expose event in window: %d\n",
X                			myevent.xexpose.window);
X			else
X				
X				fprintf(stdout, 
X					"Compressed %d expose events into 1 \
Xin window: %d\n", count, myevent.xexpose.window);
X#endif
X
X			/* ******************************************* *
X			 * ** now deal with the actual expose event ** *
X			 * ******************************************* */
X  			if (myevent.xexpose.window == main_win.win)
X			   	{
X				for (i=0; i<NFS; i++)
X					{
X					XDrawImageString (mydisplay, 
X					   main_win.win, main_win.gc, OFF_X+2,
X					   fs_win[i].y-2, fs_name[i], 
X					   strlen(fs_name[i]));
X					if (percent)
X						write_percent (i);
X					}
X				break;
X				}
X			else
X			if (myevent.xexpose.window == detail_win.win)
X				write_detail (detail_open);
X			cont=TRUE;
X			cont = expose_win (menu, MENU_ITEMS);
X			if (!cont) break;
X			for (i=0; i<NFS; i++)
X				if (myevent.xexpose.window == fs_win[i].win)
X					{
X					redraw_fs_win (i);
X					i=NFS;
X					}
X			break;
X
X		    /* *** change work window if main window changes *** */
X		    case ConfigureNotify:
X#if DEBUG
X			fprintf(stdout, 
X				"got configure notify event in window: %d\n",
X                		myevent.xconfigure.window);
X#endif
X			if (myevent.xconfigure.window != main_win.win)
X				break;
X			if (myevent.xconfigure.width==main_win.width &&
X			    myevent.xconfigure.height==main_win.height)
X				break;
X
X			/* *** figure out how many points per nfs we have *** */
X
X			ppnfs=((myevent.xconfigure.height-BEGIN_NFS)/NFS);
X#if DEBUG
X			fprintf (stdout, "got resize event - new interval = \
X%d\nwidth = %d height = %d\n", ppnfs, myevent.xconfigure.width,
Xmyevent.xconfigure.height);
X#endif
X			XClearWindow (mydisplay, main_win.win);
X			main_win.width=myevent.xconfigure.width;
X			main_win.height=myevent.xconfigure.height;
X			XResizeWindow (mydisplay, main_win.win, main_win.width,
X				main_win.height);
X			for (i=0; i<MENU_ITEMS; i++)
X				{
X				menu[i].x=((myevent.xconfigure.width-
X				    SM_MENU_WIDTH)/2); 
X				XMoveWindow (mydisplay, menu[i].win,
X				    menu[i].x, menu[i].y);
X				}
X			for (i=0; i<NFS; i++)
X				{
X				fs_win[i].y=(BEGIN_NFS+(ppnfs*i));
X				fs_win[i].width=
X					myevent.xconfigure.width-OFF_X*2;
X				if (!absolute)
X					{
X					fs_win[i].width=(int)(fs_win[i].width*
X						(((float)stats[i].f_blocks)/
X						((float)b_blocks)));
X					if (!fs_win[i].width)
X						fs_win[i].width=1;
X                        		}
X				fs_win[i].height=ppnfs-LETTER_SPACE-
X					FREE_LETTER_SP;
X				XClearWindow (mydisplay, fs_win[i].win);
X				XMoveResizeWindow (mydisplay, fs_win[i].win,
X					OFF_X, fs_win[i].y, fs_win[i].width,
X					fs_win[i].height);
X				XFillRectangle (mydisplay, fs_win[i].win, 
X					fs_win[i].gc, 0, 0, (int)
X					(float)(fs_perc[i]*fs_win[i].width), 
X					fs_win[i].height); 
X				XDrawImageString (mydisplay, main_win.win, 
X					main_win.gc, OFF_X+2, fs_win[i].y-2, 
X					fs_name[i], strlen(fs_name[i]));
X				redraw_fs_win(i);
X				} 
X
X  			break;
X
X		    /* *** process keyboard mapping changes *** */
X		    case MappingNotify:
X#if DEBUG
X			fprintf(stdout, 
X				"got mapping notify event in window: %d\n",
X                	   	myevent.xexpose.window);
X#endif
X  			XRefreshKeyboardMapping ((XMappingEvent *) &myevent );
X  			break;
X
X		    /* *** drag in work window *** */
X		    case MotionNotify:
X#if DEBUG
X			fprintf(stdout, 
X				"got motion notify event in window: %d\n",
X			   	myevent.xbutton.window);
X#endif
X  			break;
X
X
X		   /* *** mouse enters a window *** */
X		   case EnterNotify:
X			this_item = highlight_menu (menu, MENU_ITEMS, 
X				TRUE);
X			break;
X
X		   /* *** Mouse Leaves a window *** */
X		   case LeaveNotify:
X			this_item = highlight_menu (menu, MENU_ITEMS, 
X				FALSE);
X			break;
X
X		   /* *** process mouse-button presses *** */
X		   case ButtonPress:
X#if DEBUG
X			fprintf(stdout, "button press (%d) in window: %d\n",
X				myevent.xbutton.button, myevent.xbutton.window);
X#endif
X			if (myevent.xbutton.button==1 ||
X			    myevent.xbutton.button==2)
X			   {
X			   this_item=
X			   	which_button_pressed (menu, MENU_ITEMS);
X  			   if (this_item == UPDATE)
X				{
X				redraw_main_win ();
X				if (detail_open != NOGOOD)
X					write_detail (detail_open);
X				target=time(NULL)+upd_interval;
X				break;
X				}
X			   else
X			   if (this_item == QUIT)
X				{
X				done=TRUE;
X				break;
X				}
X
X			   /* *** see if btnpress was in a graph window *** */
X			   this_item=
X				which_button_pressed (fs_win, NFS);
X			   if (this_item == NOGOOD)
X				break;
X
X			   /* *** open a detail window *** */
X			   if (detail_open == NOGOOD)
X				{
X				create_window (DefaultRootWindow(mydisplay),
X					&detail_win, argc, argv);
X				myhint.min_width=DETAIL_X;
X				myhint.min_height=DETAIL_Y;
X				myhint.max_width=DETAIL_X;
X				myhint.max_height=DETAIL_Y;
X				myhint.flags=PMinSize|PMaxSize;
X				XSetStandardProperties (mydisplay, 
X					detail_win.win, 0, 0, None, argv, 
X					argc, &myhint);
X				write_detail (this_item);
X				XMapRaised (mydisplay, detail_win.win);
X				detail_open = this_item;
X				}
X			   /* *** det_win for this graph open - close it *** */
X			   else
X			   if (detail_open == this_item)
X				{
X				XFreeGC (mydisplay, detail_win.gc);
X				XDestroyWindow (mydisplay, detail_win.win);
X				detail_open=NOGOOD;
X				}
X			   else
X				{
X				XClearWindow (mydisplay, detail_win.win);
X				detail_open=this_item;
X				write_detail (this_item);
X				}
X			   }
X			   else
X				toggle_mode();
X
X			   break;
X
X		/* *** process mouse-button release *** */
X		case ButtonRelease:
X#if DEBUG
X			fprintf(stdout, "button release in window: %d\n",
X				myevent.xbutton.window);
X#endif
X  			break;
X
X
X		/* *** process Resize *** */
X		case ResizeRequest:
X#if DEBUG
X			fprintf (stdout, "got resize event \n");
X#endif
X			break;
X
X		/* *** process keyboard input *** */
X		case KeyPress:
X#if DEBUG
X			fprintf (stdout, "got keypress event in window: %d\n",
X                		myevent.xkey.window);
X#endif
X  			i=XLookupString ((XKeyEvent *)&myevent, text, 
X				10, &mykey, 0 );
X			if (text[0]==UPDATE_KEY)
X				{
X				redraw_main_win ();
X				if (detail_open != NOGOOD)
X					write_detail (detail_open);
X				target=time(NULL)+upd_interval;
X				}
X			else
X			if (text[0]==QUIT_KEY)
X			   if (detail_open != NOGOOD)
X				if (myevent.xkey.window == detail_win.win)
X				   {
X				   XFreeGC (mydisplay, detail_win.gc);
X				   XDestroyWindow (mydisplay, detail_win.win);
X				   detail_open=NOGOOD;
X				   }
X			if (text[0]==TOGGLE_KEY)
X				toggle_mode ();
X
X			break;
X 		} /* switch (myevent.type) */
X	} /* while (done == 0) */
X}
/
echo x - main.h
sed '/^X/s///' > main.h << '/'
X/* ************************************************************************* *
X   xfsm - (C) Copyright 1993 Robert Gasch (rgasch@nl.oracle.com)
X
X   Permission to use, copy, modify and distribute this software for any 
X   purpose and without fee is hereby granted, provided that this copyright
X   notice appear in all copies as well as supporting documentation. All
X   work developed as a consequence of the use of this program should duly
X   acknowledge such use.
X
X   No representations are made about the suitability of this software for
X   any purpose. This software is provided "as is" without express or implied 
X   warranty.
X
X   All commercial uses of xfsm must be done by agreement with the autor.
X * ************************************************************************* */
X
X
X
X/* ****** include files ****** */
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/bitmaps/gray1>
X#include <string.h>
X#include <stdlib.h>
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/time.h>
X#if defined (SUNOS) || defined (TOS) || defined (LINUX)
X#include <sys/vfs.h>
X# else
X# ifdef SVR4
X# include <sys/statvfs.h>
X#  else
X#  ifdef AIX
X#  include <sys/statfs.h>
X#  include <sys/select.h>		/* required for msleep */
X#  endif
X# endif
X#endif
X
X
X/* ******************************************************************** */
X/* ******************** general program constants ********************* */
X/* ******************************************************************** */
X#define TRUE		1
X#define FALSE		0
X#define NOGOOD		-1
X#define MAXCPL          80
X#define MAXFS           50
X#define SLEEPT		50000L
X#define QUIT_KEY	'q'
X#define UPDATE_KEY	'u'
X#define TOGGLE_KEY	't'
X#define GET_HOSTNAME	"hostname"
X#define MAX_SLEEP_SCALE	50
X#define MILLION		1000000
X#define MB		1048576
X
X#ifdef SVR4
X#define GET_FS		"/etc/mount | cut -f1 -d\" \""
X# else
X# if defined (SUNOS) || defined (TOS) || defined (LINUX)
X# define GET_FS		"/etc/mount | cut -f3 -d\" \""
X# else
X#  ifdef AIX
X#  define GET_FS	"/etc/mount |cut -f10 -d\" \""
X#  endif
X# endif
X#endif
X
X
X#if defined (SVR4) || defined (AIX)
X#define DETAIL_NUM	10
X#else
X# if defined (SUNOS) || defined (LINUX)
X# define DETAIL_NUM	9
X# else
X#  ifdef TOS
X#  define DETAIL_NUM	7
X#  endif
X# endif
X#endif
X
X
X
X#define HELPARG		strcmp (argv[i], "-?") == NULL || \
X			strcmp (argv[i], "help") == NULL || \
X			strcmp (argv[i], "-help") == NULL
X
X#define CHECKNA		if (strcmp (s, "-1") == NULL) strcpy (s, "N.A.")
X
X#define PRINT_KNOWN_BUGS 	printf ("\n\
XKnown Bugs: \n\
X	1) When a detailed information window is opened it does not \n\
X	   receive the expose event until the mouse reenters the main window.\n\
X	2) Update field does not receive initial expose event until mouse\n\
X	   enters window.\n");
X
X#define PRINT_COPYRIGHT		printf ("\
Xxfsm v1.23 - (C) Copyright 1993 Robert Gasch (rgasch@nl.oracle.com)\n");
X
X
X
X/* ****** define window constants - these are positions and sizes ****** */
X#define WIN_X 	150
X#define WIN_Y 	150
X#define MIN_WIN_X	100
X#define MENU_HEIGHT 	15
X#define MIN_MENU_HEIGHT	4
X#define LETTER_HEIGHT	12
X#define LETTER_SPACE	15
X#define FREE_LETTER_SP	(LETTER_SPACE-LETTER_HEIGHT)
X#define NFS_TEXT_Y	(fs_win[i].y-(LETTER_SPACE-(LETTER_HEIGHT+1)))
X#define SM_MENU_WIDTH	80
X#define MENU_WIDTH 	110
X#define MENU_ITEMS	2
X#define MENU_SPACE	(MENU_HEIGHT*(MENU_ITEMS+2))
X#define BEGIN_NFS	MENU_SPACE
X#define MENU_Y		10
X#define OFF_X		10
X#define OFF_Y		10
X#define INTERVAL	((MENU_HEIGHT+FREE_LETTER_SP)*2) 
X#define	MIN_INTERVAL	(MIN_MENU_HEIGHT+FREE_LETTER_SP+MENU_HEIGHT)
X#define DETAIL_X	195
X#define DETAIL_Y	((MENU_HEIGHT*(DETAIL_NUM+3))+(OFF_X*2))
X#define DPC 		6 	/* Dots per character */
X/* ****** define constants used to identify menus and windows(buttons) ****** */
X#define UPDATE		0
X#define	QUIT		1
X
X
X
X/* ******************************************************************** */
X/* ********************* program data structures ********************** */
X/* ******************************************************************** */
X
X/* ****** XWindow struct - this simplifies function calls ****** */
Xtypedef struct {
X	Window 		win;		/* window ID */
X	GC		gc;		/* window graphics content */
X	char		text[40];	/* title (for menus) */
X	int		x, y, 		/* position */
X			width, height, 	/* size */
X			line_thick;	/* line thickness of window border */
X	unsigned long	fg, bg;		/* foreground and background */
X	long		event_mask, 	/* which events will be registered */ 
X			flags;		/* window flags */
X		} WinType, *WinTypePtr;
X
X/* *** string to hold file system name *** */
Xtypedef char string[MAXCPL];
X
X
X/* ******************************************************************** */
X/* ********************** function declarations *********************** */
X/* ******************************************************************** */
Xvoid	do_event_loop();
Xvoid	toggle_mode();
Xvoid	redraw_main_win();
Xvoid 	write_detail();
Xvoid 	write_percent();
Xvoid 	redraw_fs_win();
Xvoid	get_fs_stat();
Xvoid 	create_window ();
Xint	highlight_menu();
Xint	expose_win();
Xvoid	destroy_menu();
Xint	which_button_press();
Xvoid	msleep();
Xvoid 	init_all_windows();
/
echo x - util.c
sed '/^X/s///' > util.c << '/'
X/* ************************************************************************* *
X   xfsm - (C) Copyright 1993 Robert Gasch (rgasch@nl.oracle.com)
X
X   Permission to use, copy, modify and distribute this software for any 
X   purpose and without fee is hereby granted, provided that this copyright
X   notice appear in all copies as well as supporting documentation. All
X   work developed as a consequence of the use of this program should duly
X   acknowledge such use.
X
X   No representations are made about the suitability of this software for
X   any purpose. This software is provided "as is" without express or implied 
X   warranty.
X
X   All commercial uses of xfsm must be done by agreement with the autor.
X * ************************************************************************* */
X
X
X
X#include "main.h"
X
Xextern Display		*mydisplay;
Xextern XEvent		myevent;
Xextern WinType		main_win,
X			menu[],
X			fs_win[],
X			detail_win;
Xextern unsigned long 	fg, bg;
Xextern XSizeHints 	myhint;
Xextern int		NFS,
X			Height, 
X			root,
X			show_use,
X			gray,
X			minimize,
X			percent,
X			absolute,
X			upd_interval;
Xextern long		sec,
X			usec,
X			b_blocks;
Xextern float 		fs_perc[];
Xextern string		fs_name[],
X			hname;
X
X#if defined (SUNOS) || defined (TOS) || defined (AIX) || defined (LINUX)
Xextern struct statfs 	stats[];
X# else
X# ifdef SVR4
Xextern struct statvfs 	stats[];
X# endif
X#endif
X
X
X
Xchar *Menu_Text[MENU_ITEMS]={
X		" Update Now ",
X		"    Quit    "};
X
X
X
X/* *********************************************************************** */
X/* ********* toggle the display mode and update the windows ************** */
X/* *********************************************************************** */
Xvoid toggle_mode ()
X{
X	int i;
X
X	if (absolute)
X		absolute=FALSE;
X	else
X		absolute=TRUE;
X	for (i=0; i<NFS; i++)
X		{
X		fs_win[i].width=main_win.width-OFF_X*2;
X		if (!absolute)
X			{
X			fs_win[i].width=(int)(fs_win[i].width*
X				(((float)stats[i].f_blocks)/((float)b_blocks)));
X			if (!fs_win[i].width)
X				fs_win[i].width=1;
X			}
X		XResizeWindow (mydisplay,fs_win[i].win, fs_win[i].width,
X			fs_win[i].height);
X		redraw_fs_win (i);
X		}
X}
X
X
X
X/* *********************************************************************** */
X/* *********************** redraw the main window ************************ */
X/* *********************************************************************** */
Xvoid redraw_main_win ()
X{
X	int i;
X
X	get_fs_stat ();
X	XClearWindow (mydisplay, main_win.win);
X	for (i=0; i<NFS; i++)
X		{
X		XDrawImageString (mydisplay, main_win.win, main_win.gc, 
X			OFF_X+2, fs_win[i].y-2, fs_name[i], strlen(fs_name[i]));
X		redraw_fs_win (i);
X		if (percent)
X			write_percent (i);
X		}
X} 
X
X
X/* *********************************************************************** */
X/* ******************** write out the detailed info ********************** */
X/* *********************************************************************** */
Xvoid write_detail (i)
Xint i;
X{
X	int c=3, rhs=105;
X#if defined (SUNOS) || defined (TOS) || defined (AIX) || defined (LINUX)
X	long bsize=stats[i].f_bsize;
X#else
X	long bsize=stats[i].f_frsize;
X#endif
X	char s[30];
X
X	XClearWindow (mydisplay, detail_win.win);
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		(((DETAIL_X-OFF_X*2)/2)-(DPC/2*strlen (fs_name[i]))), 
X		OFF_Y+MENU_HEIGHT, fs_name[i], strlen (fs_name[i]));
X
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X, OFF_Y+MENU_HEIGHT*c, "Total Size", 
X		strlen ("Total Size"));
X	if (stats[i].f_blocks == -1 || bsize == -1)
X		sprintf (s, "Undefined");
X	else
X		sprintf (s, "%.2f MB", 
X		/* *** use this computational order to avoid overflows *** */
X		   (((double)(bsize)/(float)(MB)))*(double)(stats[i].f_blocks));
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X+rhs, OFF_Y+MENU_HEIGHT*c++, s, strlen (s));
X
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X, OFF_Y+MENU_HEIGHT*c, "Space Free", 
X		strlen ("Space Free"));
X	if (stats[i].f_bfree == -1 || bsize == -1)
X		sprintf (s, "Undefined");
X	else
X		sprintf (s, "%.2f MB",
X		/* *** use this computational order to avoid overflows *** */
X		(((double)(bsize)/(float)(MB)))*(double)(stats[i].f_bfree));
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X+rhs, OFF_Y+MENU_HEIGHT*c++, s, strlen (s));
X
X#ifndef TOS
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X, OFF_Y+MENU_HEIGHT*c, "Space Available", 
X		strlen ("Space Available"));
X	if (stats[i].f_bfree == -1 || bsize == -1)
X		sprintf (s, "Undefined");
X	else
X		sprintf (s, "%.2f MB",
X		/* *** use this computational order to avoid overflows *** */
X		(((double)(bsize)/(float)(MB)))*(double)(stats[i].f_bavail));
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X+rhs, OFF_Y+MENU_HEIGHT*c++, s, strlen (s));
X#endif 
X
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X, OFF_Y+MENU_HEIGHT*c, "Block Size", 
X		strlen ("Block Size"));
X	sprintf (s, "%ld", bsize);
X	CHECKNA;
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X+rhs, OFF_Y+MENU_HEIGHT*c++, s, strlen (s));
X
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X, OFF_Y+MENU_HEIGHT*c, "Blocks", strlen ("Blocks"));
X	sprintf (s, "%ld", stats[i].f_blocks);
X	CHECKNA;
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X+rhs, OFF_Y+MENU_HEIGHT*c++, s, strlen (s));
X
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X, OFF_Y+MENU_HEIGHT*c, "Blocks Free",
X		strlen ("Blocks Free"));
X	sprintf (s, "%ld", stats[i].f_bfree);
X	CHECKNA;
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X+rhs, OFF_Y+MENU_HEIGHT*c++, s, strlen (s));
X
X#ifndef TOS
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X, OFF_Y+MENU_HEIGHT*c, "Blocks Available",
X		strlen ("Blocks Available"));
X	sprintf (s, "%ld", stats[i].f_bavail);
X	CHECKNA;
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X+rhs, OFF_Y+MENU_HEIGHT*c++, s, strlen (s));
X#endif
X
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X, OFF_Y+MENU_HEIGHT*c, "File Inodes",
X		strlen ("File Inodes"));
X	sprintf (s, "%ld", stats[i].f_files);
X	CHECKNA;
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X+rhs, OFF_Y+MENU_HEIGHT*c++, s, strlen (s));
X
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X, OFF_Y+MENU_HEIGHT*c, "Free Inodes",
X		strlen ("Free Inodes"));
X	sprintf (s, "%ld", stats[i].f_ffree);
X	CHECKNA;
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X+rhs, OFF_Y+MENU_HEIGHT*c++, s, strlen (s));
X
X#ifdef SVR4
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X, OFF_Y+MENU_HEIGHT*c, "Inodes Available",
X		strlen ("Inodes Available"));
X	sprintf (s, "%ld", stats[i].f_favail);
X	CHECKNA;
X	XDrawImageString (mydisplay, detail_win.win, detail_win.gc, 
X		OFF_X+rhs, OFF_Y+MENU_HEIGHT*c++, s, strlen (s));
X#endif
X}
X
X
X
X/* *********************************************************************** */
X/* ************************* write the percentage ************************ */
X/* *********************************************************************** */
Xvoid write_percent(i)
Xint i;
X{
X	char 	s[30];
X	int	c=0;
X
X	sprintf (s, "%d%%", (int)(fs_perc[i]*100));
X	XDrawImageString (mydisplay, main_win.win, main_win.gc, 
X		(main_win.width-OFF_Y-(strlen(s)*DPC)), NFS_TEXT_Y, 
X		s, strlen (s));
X}
X
X
X
X/* *********************************************************************** */
X/* *************************** redraw the bars *************************** */
X/* *********************************************************************** */
Xvoid redraw_fs_win(i)
Xint i;
X{
X	/* *** now draw bar *** */
X	XClearWindow (mydisplay, fs_win[i].win);
X	XFillRectangle (mydisplay, fs_win[i].win, fs_win[i].gc, 
X		0, 0, (int)(fs_perc[i]*fs_win[i].width), 
X		fs_win[i].height);
X}
X
X
X
X/* *********************************************************************** */
X/* ********************** get the file system stats ********************** */
X/* *********************************************************************** */
Xvoid get_fs_stat()
X{
X	int i, t, x;
X#if defined (SVR4) || defined (LINUX)
X	string s;
X#endif
X
X 	/* *** read file system status *** */
X        for (i=0; i<NFS; i++)
X	   {
X#if defined (SUNOS) || defined (LINUX) || defined (AIX)
X           t=statfs (fs_name[i], &stats[i]);
X# else
X# ifdef SVR4
X           t=statvfs (fs_name[i], &stats[i]);
X#  else
X#  ifdef TOS
X           t=statvfs (fs_name[i], &stats[i]), sizeof (struct statfs), 0);
X#  endif
X# endif
X#endif
X
X	/* *** see if the return code is an error *** */
X	   if (t == -1)
X#if defined (SVR4) || defined (LINUX)
X		{
X		sprintf (s, "Can't get status on [%s]\n", fs_name[i]);
X                perror (s);
X		}
X#else
X                perror ("Can't get status on [%s]\n", fs_name[i]);
X#endif 
X	   else
X		{
X#ifdef DEBUG
X                printf ("Got status on %s\n", fs_name[i]);
X#endif
X		/* *** find largest file system size *** */
X		if (stats[i].f_blocks > b_blocks)
X			b_blocks=stats[i].f_blocks;
X
X		/* *** throw out file systems of size 0 *** */
X		if (stats[i].f_blocks == 0)
X			{
X			printf ("File system %s is of size 0 - removing it!\n",
X				fs_name[i]);
X			for (x=i; x<NFS; x++)
X				{
X				strcpy (fs_name[x], fs_name[x+1]) ;
X				stats[x]=stats[x+1];
X				}
X			i--;
X			NFS--;
X			}
X		else
X			{
X			/* *** figure out percentage of free blocks *** */
X			if (root)
X			   {
X	   		   if (show_use)
X				{
X	   			fs_perc[i]=((float)
X				   (stats[i].f_blocks-stats[i].f_bfree))/
X				   ((float)stats[i].f_blocks);
X#ifdef DEBUG
X	   			printf ("Free: %ld \t Total: %ld == %2f%%\n", 
X				   stats[i].f_bfree, stats[i].f_blocks, 
X				   fs_perc[i]);
X#endif
X				}
X	   		   else
X				{
X	   			fs_perc[i]=((float)stats[i].f_bfree)/
X					((float)stats[i].f_blocks);
X#ifdef DEBUG
X	   			printf ("Free: %ld \t Total: %ld == %.2f%%\n", 
X					stats[i].f_bfree, stats[i].f_blocks, 
X					fs_perc[i]);
X#endif
X				}
X			   }
X			else
X			   {
X	   		   if (show_use)
X				{
X				fs_perc[i]=((float)
X					stats[i].f_blocks-stats[i].f_bavail)/
X					((float)stats[i].f_blocks);
X#ifdef DEBUG
X	   			printf ("Free: %ld \t Total: %ld == %.2f%%\n", 
X					stats[i].f_bfree, stats[i].f_blocks, 
X					fs_perc[i]);
X#endif
X				} 
X	   		  else
X				{
X	   			fs_perc[i]=((float)stats[i].f_bavail)/
X			   		((float)stats[i].f_blocks);
X#ifdef DEBUG
X	   			printf ("Free: %ld \t Total: %ld == %.2f%%\n", 
X					stats[i].f_bfree, stats[i].f_bavail, 
X					fs_perc[i]);
X#endif
X				}
X			   }
X			}
X		}
X	}
X	/* *** No file systems left *** */
X	if (NFS < 1)
X		{
X		fprintf(stderr,"No File systems left ... Exiting\n");
X		exit (0);
X		}
X}
X
X
X/* *********************************************************************** */
X/* *********************** create a single window ************************ */
X/* *********************************************************************** */
Xvoid create_window (parent_win, this_win, argc, argv)
XWindow	parent_win; 
XWinTypePtr this_win;
Xint 	argc;
Xchar 	**argv;
X{
X	/* ***  default program-specified window attributes *** */
X	myhint.x = this_win->x; 
X	myhint.y = this_win->y; 
X	myhint.width = this_win->width;  
X	myhint.height = this_win->height;
X	myhint.flags = this_win->flags;
X
X	/* *** Create Actual Window *** */
X	this_win->win = XCreateSimpleWindow (mydisplay, parent_win, 
X		myhint.x, myhint.y, myhint.width, myhint.height,
X		this_win->line_thick, fg, bg);
X
X	if (!this_win->win)
X		{
X		fprintf (stderr,"Error creating Simple Window %s ... Exiting\n",
X			this_win->text);
X		exit (1);
X		}
X#if DEBUG
X	fprintf (stdout, "Created Simple Window %s (%d)\n", 
X		this_win->text, this_win->win);
X#endif
X
X	/* *** cheap way to set the main properties *** */
X	XSetStandardProperties(mydisplay, this_win->win, this_win->text,
X		this_win->text, None, argv, argc, &myhint);
X
X	/* *** set Graphics Content creation and initialize *** */
X	this_win->gc = XCreateGC (mydisplay, this_win->win, 0, 0);
X
X	if (! this_win->gc)
X		{
X		 fprintf (stderr, "Error creating GC for  %s ... Exiting\n",
X                        this_win->text);
X                exit (1);
X		}
X#if DEBUG
X	fprintf (stdout, "Created GC %d\n", this_win->gc);
X#endif
X
X	XSetBackground (mydisplay, this_win->gc, bg);
X	XSetForeground (mydisplay, this_win->gc, fg);
X
X	/* *** specify which input we want this window to process *** */
X	XSelectInput (mydisplay, this_win->win, this_win->event_mask);
X}
X
X
X
X
X/* *********************************************************************** */
X/* highlight menu item (window) in response to a mouse entering or leaving */
X/* *********************************************************************** */
Xint highlight_menu (menu, menu_num,highlight)
XWinType menu[];
Xint	menu_num;
Xint	highlight;
X{
X	int i, state=NOGOOD;
X
X	/* *** figure out which menu *** */
X	for (i=0; i<menu_num; i++) 
X		if (myevent.xcrossing.window==menu[i].win) 
X			{
X			state=i;
X			i=menu_num;
X			}
X	/* *** check if menu is valid and change fg & bg *** */
X  	if (state>=0 && state<menu_num)
X		{
X		if (highlight)
X			{
X#if DEBUG
X			fprintf (stdout, "Enter state in button %s\n", 
X				menu[state].text);
X#endif
X			XSetBackground (mydisplay, menu[state].gc, fg);
X			XSetForeground (mydisplay, menu[state].gc, bg);
X			}
X		else
X			{
X#if DEBUG
X			fprintf (stdout, "Exit state in button %s\n", 
X				menu[state].text);
X#endif
X			XSetBackground (mydisplay, menu[state].gc, bg);
X			XSetForeground (mydisplay, menu[state].gc, fg);
X			}
X	 	for (i=0; i<menu_num; ++i)
X    			XDrawImageString (mydisplay, menu[i].win, menu[i].gc, 1,
X			   LETTER_HEIGHT, menu[i].text, strlen(menu[i].text)); 
X		return (state);
X		}
X	else
X		return (NOGOOD);
X}
X
X
X
X
X/* *********************************************************************** */
X/* ************** redraw the string in an exposed window ***************** */
X/* *********************************************************************** */
Xint expose_win (menu, menu_num)
XWinType	menu[];
Xint	menu_num;
X{
X	int i;
X
X	for (i=0; i<menu_num; i++)
X		{
X		if (myevent.xexpose.window == menu[i].win)
X			{
X			XDrawImageString (mydisplay, menu[i].win, 	
X			   menu[i].gc, 1, LETTER_HEIGHT, menu[i].text,
X			   strlen(menu[i].text));
X			return (FALSE);
X			}
X		}
X	return (TRUE);
X}
X
X
X
X
X/* *********************************************************************** */
X/* *********************** destroy an entire menu  *********************** */
X/* *********************************************************************** */
Xvoid destroy_menu (menu, menu_num)
XWinType	menu[];
Xint	menu_num;
X{
X	int i;
X
X	for (i=0; i<menu_num; i++)
X		{
X		XDestroyWindow (mydisplay, menu[i].win);
X#if DEBUG
X		fprintf (stdout, "Destroyed menu: %s\n", menu[i].text);
X#endif
X		XFreeGC (mydisplay, menu[i].gc);
X#if DEBUG
X		fprintf (stdout, "Destroyed GC: %d\n", menu[i].gc);
X#endif
X		}
X}
X
X
X
X
X/* *********************************************************************** */
X/* *************** return the number of the button pressed *************** */
X/* *********************************************************************** */
Xint which_button_pressed (menu, menu_num)
XWinType	menu[];
Xint	menu_num;
X{
X	int i;
X
X	for (i=0; i<menu_num; i++)
X		if (myevent.xbutton.window == menu[i].win)
X			return (i);
X	return (NOGOOD);
X}
X
X
X
X/* ***************************************************************** */
X/* ****************** Process the progrma arguments **************** */
X/* ***************************************************************** */
Xvoid process_args (argc, argv)
Xint argc;
Xchar **argv;
X{
X	int i, x, t, removed=FALSE;
X
X	for (i=1; i<argc; i++)
X	   if (strcmp (argv[i], "-r") == NULL)
X		{
X		root=TRUE;
X#ifndef TOS
X		printf ("-r falg caught - will give statistics for root\n");
X#else
X		fprintf (stderr, "-r flag not available on TOS\n");
X#endif
X		}
X	   else
X	   if (strcmp (argv[i], "-b") == NULL)
X		{
X		gray=FALSE;
X		printf ("-b flag caught - will draw bars black\n");
X		}
X	   else
X	   if (strcmp (argv[i], "-m") == NULL)
X		{
X		minimize=TRUE;
X		printf ("-m flag caught - will minimize window size\n");
X		}
X	   else
X	   if (strcmp (argv[i], "-p") == NULL)
X		{
X		percent=FALSE;
X		printf ("-p flag caught - will toggle percent display off\n");
X		}
X	   else
X	   if (strcmp (argv[i], "-a") == NULL)
X		{
X		absolute=TRUE;
X		printf ("-a flag caught - will display sizes relative to \
Xabsolute FS size\n");
X		}
X	   else
X	   if (strcmp (argv[i], "-k") == NULL)
X		{
X		percent=FALSE;
X		printf ("-k flag caught - will keep file ssytem opf file 0\n");
X		}
X	   else
X	   if (strcmp (argv[i], "-s") == NULL)
X		{
X		i++;
X		if (atoi(argv[i]) < 1 || atoi(argv[i]) > MAX_SLEEP_SCALE)
X			{
X			fprintf(stderr,
X				"Supplied scaling factor out of range (1-%d)\n",
X				MAX_SLEEP_SCALE);
X			}
X		else
X			{
X			usec*=(long)atoi(argv[i]);
X			if (usec >= MILLION)
X				{
X				sec = usec/MILLION;
X				usec = (usec-(sec*MILLION));
X				}
X			else
X				{
X				sec = 0;
X				usec = usec;
X				}
X			printf ("-s flag caught - will multiply sleep \
Xtime by %d\n", atoi(argv[i]));
X			printf ("\tWarning: response may be unacceptably \
Xslow!\n");
X			}
X		}
X	   else
X	   if (strcmp (argv[i], "-f") == NULL)
X		{
X		show_use=FALSE;
X		printf("-f flag caught - will show space free rather than \
Xspace used\n");
X		}
X	   else
X	   if (strcmp (argv[i], "-i") == NULL)
X		{
X		upd_interval=atoi(argv[++i]);
X		if (upd_interval < 1)
X		   {
X		   fprintf (stderr,
X			"Supplied interval (%d) too small (minimum=1)\n",
X			upd_interval);
X		   exit (1);
X		   }
X		printf ("-i flag caught - update interval changed to %d sec\n",
X		   upd_interval);
X		}
X	   else
X	   if (strcmp (argv[i], "-d") == NULL)
X		/* *** does it begin with an "/" *** */
X		while (i<(argc-1) && argv[i+1][0]=='/')
X		   {
X		   /* *** check all file systems for arg *** */
X		   for (x=0; x<NFS; x++)
X			/* *** we found a match *** */
X			if (strcmp (argv[i+1], fs_name[x]) == NULL)
X				{
X				/* *** shift files systenms 1 down *** */
X				for (t=x; t<NFS; t++)
X					strcpy (fs_name[t], fs_name[t+1]);
X				x=--NFS;
X				removed=TRUE;
X				printf ("-d flag caught - %s will be ignored\n",
X					argv[i+1]);
X				}
X		   /* *** did we remove a file system with this arg *** */
X		   if (x==NFS)
X			fprintf (stderr,"%s is not a file system ... ignored\n",
X				argv[i]);
X		   i++;
X		   }
X	   else
X		printf ("Argument %s not recognized as an option ... ignored\n",
X			argv[i]);
X
X	if (NFS < 1)
X		{
X		fprintf(stderr,"No File systems left ... Exiting\n");
X		exit (0);
X		}
X#ifdef DEBUG
X	if (removed)
X		{
X		printf ("The following file systems remain:\n");
X		for (x=0; x<NFS; x++)
X			printf ("%s\n", fs_name[x]);
X		}
X#endif
X}
X
X
Xvoid do_help (prog)
Xchar *prog;
X{
X	PRINT_COPYRIGHT
X	printf ("\n\
X%s displays a list of bar graphs for the file systems of the host you are on.\n\
XClicking on a file system gives you detailed information - clicking on it \n\
Xagain closes the detail window. Use %c or the right mouse button to toggle \n\
Xbetween absolute and relative display modes.\n\
XThe following switches are supported:\n", prog, TOGGLE_KEY);
X#ifndef TOS
Xprintf ("	-r              graphs space available to root rather \
Xthan user\n");
X#endif
Xprintf ("	-b		 draw graphs black\n\
X	-m		minimize window size\n\
X	-p		don't display percent\n\
X	-a		toggle display mode to absolute bar size\n\
X	-f              displays percent free rather then percent in use\n\
X	-s <arg> 	scale sleep time by argument\n\
X        -i <arg>        interval at which display is updated (default = 300s)\n\
X        -d <arg1 ... argn> do not include these file systems\n\
X        -?              get this description\n");
X	PRINT_KNOWN_BUGS
X	exit (0);
X}
X
X
X
X/* **************************************************************** */
X/*  msleep will wait for n microseconds for a dummy I/O descriptor  */
X/*  **** take from Tom Boutell's Broken Throne with permission **** */
X/* **************************************************************** */
Xvoid msleep ()
X{
X	struct timeval  sleept;
X		
X	sleept.tv_sec = sec;
X	sleept.tv_usec = usec; 
X	select(FD_SETSIZE, NULL, NULL, NULL, &sleept);
X}
X
X
X
X
X/* ***************************************************************** */
X/* ********** this basically inits the window definitions ********** */
X/* ***************************************************************** */
Xvoid init_all_windows ()
X{
X        int i;
X	char s[30];
X	unsigned long 	small_event_mask, big_event_mask, fs_mask, these_flags;
X
X        these_flags = PPosition | PSize;
X	small_event_mask= PPosition | PSize | StructureNotifyMask | 
X		ExposureMask| KeyPressMask | EnterWindowMask | LeaveWindowMask;
X        big_event_mask=ButtonPressMask | ExposureMask | EnterWindowMask 
X		| LeaveWindowMask;
X	fs_mask=ButtonPressMask | ExposureMask;
X	sprintf (s, "%s", hname);
X#ifndef TOS
X	if (root)
X		sprintf (s, "%s root", s);
X	else
X		sprintf (s, "%s user", s);
X#endif
X
X	if (show_use)
X		sprintf (s, "%s used", s);
X	else
X		sprintf (s, "%s free", s);
X		
X	strcpy (main_win.text, s);
X        main_win.x=WIN_X;
X        main_win.y=WIN_Y;
X	if (minimize)
X		{
X        	main_win.width=MIN_WIN_X;
X        	main_win.height=((MIN_INTERVAL*NFS)+BEGIN_NFS);
X		}
X	else
X		{
X        	main_win.width=WIN_X;
X        	main_win.height=((INTERVAL*NFS)+BEGIN_NFS);
X		}
X        main_win.line_thick=4;
X        main_win.flags=these_flags;
X        main_win.event_mask=small_event_mask;
X        for (i=0; i<MENU_ITEMS; i++)
X                {
X                strcpy (menu[i].text, Menu_Text[i]);
X		menu[i].x=((main_win.width-SM_MENU_WIDTH)/2);
X                menu[i].y=MENU_Y+MENU_HEIGHT*i;
X                menu[i].width=SM_MENU_WIDTH;
X                menu[i].height=MENU_HEIGHT;
X                menu[i].line_thick=0;
X                menu[i].event_mask=big_event_mask;
X                menu[i].flags=these_flags;
X                }
X        for (i=0; i<NFS; i++)
X                {
X		fs_win[i].x=OFF_X;
X		if (minimize)
X			{
X                	fs_win[i].y=((MIN_INTERVAL*i)+BEGIN_NFS);
X                	fs_win[i].height=MIN_MENU_HEIGHT;
X			}
X		else
X			{
X                	fs_win[i].y=((INTERVAL*i)+BEGIN_NFS);
X                	fs_win[i].height=MENU_HEIGHT;
X			}
X        	fs_win[i].width=main_win.width-OFF_X-OFF_X; 
X		if (!absolute) 
X			{
X			fs_win[i].width=(int)(fs_win[i].width*
X				(((float)stats[i].f_blocks)/((float)b_blocks)));
X			if (!fs_win[i].width)
X				fs_win[i].width=1;
X			}
X                fs_win[i].line_thick=1;
X                fs_win[i].event_mask=fs_mask;
X                fs_win[i].flags=these_flags;
X                }
X	sprintf (s, "%s detail", hname);
X	strcpy (detail_win.text, s);
X	detail_win.x=OFF_X;
X	detail_win.y=OFF_Y;
X	detail_win.width=DETAIL_X;
X	detail_win.height=DETAIL_Y;
X	detail_win.line_thick=4;
X	detail_win.event_mask=small_event_mask;
X	detail_win.flags=these_flags;
X}
/
echo x - Manifest
sed '/^X/s///' > Manifest << '/'
XThis distribution contains the following files:
X
X Name			Amount			Description
X------------------------------------------------------------
XImakefile		1			Imakefile
XMakefile.std		1			sample Makefile
XManifest		1			This shipping list
XCopyright		1			Copyright Notice
XREADME			1			Docs
Xmain.h			1			definitions
Xmain.c			1			main and X event loop
Xutil.c			1			support routines
/

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM            | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly!      |
 "It's intuitively obvious to the most |    sources-x@imd.sterling.com
  casual observer..."                  |
