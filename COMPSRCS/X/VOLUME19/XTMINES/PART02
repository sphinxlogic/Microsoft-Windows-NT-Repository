Newsgroups: comp.sources.x
From: ttsai@crhc.uiuc.edu (Timothy Tsai)
Subject: v19i005:  xtmines - A game where you try to cross a minefield, Part02/02
Message-ID: <1993Mar8.205837.29025@sparky.imd.sterling.com>
X-Md4-Signature: 4db069b89419e65d942a22def4b3e539
Date: Mon, 8 Mar 1993 20:58:37 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: ttsai@crhc.uiuc.edu (Timothy Tsai)
Posting-number: Volume 19, Issue 5
Archive-name: xtmines/part02
Environment: X11

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 2)."
# Contents:  COMPILING COPYING Imakefile Makefile Makefile.bak
#   Makefile.std README event.c xtmines.c hiscore.c patchlevel.h
#   xtmines.h bomb.bm bombmark.bm bombmarkwrong.bm goal.bm man.bm
#   pow.bm safe.bm safewrong.bm trail.bm tstone.bm xtmines.man
# Wrapped by ttsai@haydn.crhc.uiuc.edu on Fri Feb 26 12:04:56 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'COMPILING' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'COMPILING'\"
else
echo shar: Extracting \"'COMPILING'\" \(1188 characters\)
sed "s/^X//" >'COMPILING' <<'END_OF_FILE'
X
XThe only thing you must set before compiling is the HISCORE_FILENAME in
Xhiscore.c.  Substitute the full pathname of the high scores file.
X
Xxtmines comes with an Imakefile, which means that compilation is as easy as
Xtyping xmkmf followed by make.  However, since the compilation is
Xstraightforward, you could probably compile using the Makefile that is
Xprovided.
X
XIf you don't have usleep() on your system, then uncomment the following line in
Xthe Imakefile or Makefile:
X	DEFINES = -DNOUSLEEP
X
XIf you don't have imake on your system, then use the following Makefile:
X(You might have to adjust the LIBPATH for your system.)
X
X-----------------------------------------------------------------
X
XCC = cc
XLDFLAGS = -s
XCDEBUGFLAGS = -O -s
X#DEFINES = -DNOUSLEEP
XXLIB = -lX11
XLIBPATH = -L/usr/lib/X11
XINCLUDEPATH = -I/usr/local/X11R5/include
X
XSRCS            = xtmines.c init.c play.c event.c hiscore.c
XOBJS            = xtmines.o init.o play.o event.o hiscore.o
X
Xtmines: $(OBJS)
X	$(CC) $(LDFLAGS) -o xtmines $(OBJS) $(LIBPATH) $(XLIB)
X
X.c.o:
X	$(CC) $(CDEBUGFLAGS) $(INCLUDEPATH) $(DEFINES) -c $< 
X
Xtar:
X	tar cvf xtmines.tar README COMPILING COPYING *ake* *.c *.h *.bm *.man
X	compress xtmines.tar
END_OF_FILE
if test 1188 -ne `wc -c <'COMPILING'`; then
    echo shar: \"'COMPILING'\" unpacked with wrong size!
fi
# end of 'COMPILING'
fi
if test -f 'COPYING' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'COPYING'\"
else
echo shar: Extracting \"'COPYING'\" \(333 characters\)
sed "s/^X//" >'COPYING' <<'END_OF_FILE'
XCOPYING POLICY
X
XYou may copy and modify xtmines as long as you give credit where it's due.
XSpecifically, keep my name in the man pages.  If you have any comments,
Xsuggestions, or bug reports, please email me at ttsai@uiuc.edu.  Also, if you
Xmake any significant improvements, tell me, and I will make sure the update is
Xdistributed.
END_OF_FILE
if test 333 -ne `wc -c <'COPYING'`; then
    echo shar: \"'COPYING'\" unpacked with wrong size!
fi
# end of 'COPYING'
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(201 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
X
XLOCAL_LIBRARIES	= $(XLIB)
XCDEBUGFLAGS	= -s -O
X#DEFINES	= -DNOUSLEEP
X
XSRCS		= xtmines.c init.c play.c event.c hiscore.c
XOBJS		= xtmines.o init.o play.o event.o hiscore.o
X
XComplexProgramTarget(xtmines)
END_OF_FILE
if test 201 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(530 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X
XCC = cc
XLDFLAGS = -s
X#LDFLAGS = -g
XCDEBUGFLAGS = -O -s
X#CDEBUGFLAGS = -g
X#DEFINES = -DNOUSLEEP
XXLIB = -lX11
XLIBPATH = -L/usr/lib/X11
XINCLUDEPATH = -I/usr/local/X11R5/include
X
XSRCS            = xtmines.c init.c play.c event.c hiscore.c
XOBJS            = xtmines.o init.o play.o event.o hiscore.o
X
Xtmines: $(OBJS)
X	$(CC) $(LDFLAGS) -o xtmines $(OBJS) $(LIBPATH) $(XLIB)
X
X.c.o:
X	$(CC) $(CDEBUGFLAGS) $(INCLUDEPATH) $(DEFINES) -c $< 
X
Xtar:
X	tar cvf xtmines.tar README COMPILING COPYING *ake* *.c *.h *.bm *.man
X	compress xtmines.tar
END_OF_FILE
if test 530 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'Makefile.bak' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.bak'\"
else
echo shar: Extracting \"'Makefile.bak'\" \(418 characters\)
sed "s/^X//" >'Makefile.bak' <<'END_OF_FILE'
X
XCC = cc
XLDFLAGS =
XCDEBUGFLAGS = -O
X#DEFINES = -DNOUSLEEP
XXLIB = -lX11
XLIBPATH = -L/usr/lib/X11
X
XSRCS            = xtmines.c init.c play.c event.c hiscore.c
XOBJS            = xtmines.o init.o play.o event.o hiscore.o
X
Xtmines: $(OBJS)
X	$(CC) $(LDFLAGS) -o xtmines $(OBJS) $(LIBPATH) $(XLIB)
X
X.c.o:
X	$(CC) $(CDEBUGFLAGS) $(DEFINES) -c $< 
X
Xtar:
X	tar cvf xtmines.tar README *ake* *.c *.h *.bm *.man
X	compress xtmines.tar
END_OF_FILE
if test 418 -ne `wc -c <'Makefile.bak'`; then
    echo shar: \"'Makefile.bak'\" unpacked with wrong size!
fi
# end of 'Makefile.bak'
fi
if test -f 'Makefile.std' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.std'\"
else
echo shar: Extracting \"'Makefile.std'\" \(512 characters\)
sed "s/^X//" >'Makefile.std' <<'END_OF_FILE'
X
XCC = cc
XLDFLAGS = -s
X#LDFLAGS = -g
XCDEBUGFLAGS = -O -s
X#CDEBUGFLAGS = -g
X#DEFINES = -DNOUSLEEP
XXLIB = -lX11
XLIBPATH = -L/usr/lib/X11
XINCLUDEPATH = -I/usr/local/X11R5/include
X
XSRCS            = xtmines.c init.c play.c event.c hiscore.c
XOBJS            = xtmines.o init.o play.o event.o hiscore.o
X
Xtmines: $(OBJS)
X	$(CC) $(LDFLAGS) -o xtmines $(OBJS) $(LIBPATH) $(XLIB)
X
X.c.o:
X	$(CC) $(CDEBUGFLAGS) $(INCLUDEPATH) $(DEFINES) -c $< 
X
Xtar:
X	tar cvf xtmines.tar README *ake* *.c *.h *.bm *.man
X	compress xtmines.tar
END_OF_FILE
if test 512 -ne `wc -c <'Makefile.std'`; then
    echo shar: \"'Makefile.std'\" unpacked with wrong size!
fi
# end of 'Makefile.std'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(776 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XDESCRIPTION OF XTMINES   by Timothy K. Tsai
X
Xxtmines is an X11 game.  The object of the game is to move across a grid of
Xsquares representing a minefield.  In some of the squares are hidden mines.
XYou will be told how many of the surrounding squares contain mines, and based
Xon this information, it will usually be possible to traverse the entire
Xminefield safely.  As an aid, you are given three hand grenades, which you can
Xtoss onto a square.  Once a mine explodes, all adjacent mines will also
Xexplode, causing a possible chain reaction.  Points are awarded if you
Xsuccessfully traverse the minefield on a given level.  A high scores file is
Xmaintained.
X
Xxtmines was written by Timothy K. Tsai.  You may copy or modify this program as
Xlong as the credits are not removed.
END_OF_FILE
if test 776 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'event.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'event.c'\"
else
echo shar: Extracting \"'event.c'\" \(6232 characters\)
sed "s/^X//" >'event.c' <<'END_OF_FILE'
X/* xtmines: game where you try to cross a minefield */
X/* Written by Timothy Tsai  April 13, 1992 */
X
X#include "xtmines.h"
X
X/* handle_event: given an event, it will perform some action based on what */
X/*               the event is and where is occurred;  the function is just */
X/*               one big switch statement;  thus, this is the main         */
X/*               contolling loop                                           */
Xvoid handle_event(eventptr)
XXEvent *eventptr;
X{
X	/* To avoid having to use eventptr, copy contents of *evenptr */
X	/*    to event */
X	XEvent			event=*eventptr;
X
X	/* Both of the following are filled in once the event.type */
X	/*    has been determined */
X	XButtonPressedEvent	*eventbp;
X	XKeyPressedEvent	*eventkp;
X
X	/* Used by XLookupString;  this is used to check for control, */
X	/*    shifted, or other special keys */
X	KeySym			ksym;
X
X	/* Used by XLookupString;  this is used to check for actual */
X	/*    keyboard commands not picked up by KeySym */
X	char			s;
X	char			str[MAXSTRLEN];
X
X	/* Both vx and vy are passed to setvxvy() to determine the virtual */
X	/*   position of the event */
X	int			vx,vy;
X
X      	switch(event.type) {
X
X	   case GraphicsExpose:
X	   case NoExpose:
X		break;
X	   case Expose:
X		refresh(); break;
X
X	/*---Check for button events first-----------------------------*/
X
X	   case ButtonPress:
X		eventbp = (XButtonPressedEvent *) &event;	
X
X		/* quit, but add and show scores first */
X		if (eventbp->window==wind[quit_wind])
X			show_and_add_scores();
X
X		/* toggle pause status */
X		else if (eventbp->window==wind[pause_wind])
X			do_pause();
X
X		/* toggle show status; showfig to showman, or vice versa */
X		/* also update show_wind and man bitmap or fig */
X		else if (eventbp->window==wind[show_wind]) {
X		   show = (show==sh_man) ? sh_fig : sh_man;
X		   if (show==sh_fig)
X			used_showfig = TRUE;
X		   if (used_showfig)
X			sprintf(str,"Show = *%s",
X				(show==sh_man) ? "man" : "fig");
X		   else
X			sprintf(str,"Show = %s",
X				(show==sh_man) ? "man" : "fig");
X		   WindPrint(show_wind,str);
X		   draw(bm_man,manvx,manvy);
X		}
X
X		/* throw grenade */
X		else if (eventbp->window==wind[tgrenade_wind])
X			throw_grenade();
X
X		/* surrender */
X		else if (eventbp->window==wind[giveup_wind]) {
X		   show_all_bombs();
X		   dead = TRUE;
X		}
X
X		/* toggle automark;  also update automark_wind   */
X		/*    therefore, also turn off extended_automark */
X		else if (eventbp->window==wind[automark_wind]) {
X		   automark = (automark ? FALSE : TRUE);
X		   sprintf(str,"Automark = %s",automark ? "on" : "off");
X		   WindPrint(automark_wind,str);
X		   if (!automark) {
X			extended_automark = FALSE;
X			WindPrint(eautomark_wind,"ExtAmark = off");
X		   }
X		   if (automark && (bomb_status(manvx,manvy)==0))
X			mark_allaround_ok(manvx,manvy,0);
X		}
X
X		/* toggle sanity check;  also update sanitycheck_wind */
X		else if (eventbp->window==wind[sanitycheck_wind]) {
X		   sanity = (sanity ? FALSE : TRUE);
X		   if (sanity)
X			used_sanity = TRUE;
X		   if (used_sanity)
X		   	sprintf(str,"Sanity = *%s",sanity ? "on" : "off");
X		   else
X		   	sprintf(str,"Sanity = %s",sanity ? "on" : "off");
X		   WindPrint(sanitycheck_wind,str);
X		   if (sanity)
X			do_sanity_check(manvx,manvy);
X		}
X
X		/* toggle extended automark;  also update eautomark_wind */
X		else if (eventbp->window==wind[eautomark_wind]) {
X		   /* automark must be on for extended_automark to be on */
X		   if (!automark) {
X			print_status("Must turn automark on first!");
X			XBell(disp,0);
X		   }
X		   else if (level < MIN_EXTENDED_MARK_LEVEL) {
X			sprintf(str,
X				"Minimum level for extended_automark is %s",
X				num_rank_to_words(MIN_EXTENDED_MARK_LEVEL));
X			WindPrint(status,str);
X			XBell(disp,0);
X		   }
X		   else {
X			extended_automark = (extended_automark ? FALSE : TRUE);
X			if (extended_automark)
X				used_eautomark = TRUE;
X			if (used_eautomark)
X			   sprintf(str,"ExtAmark = *%s",
X				extended_automark ? "on" : "off");
X			else
X			   sprintf(str,"ExtAmark = %s",
X				extended_automark ? "on" : "off");
X			WindPrint(eautomark_wind,str);
X			if (extended_automark && (bomb_status(manvx,manvy)==0))
X				mark_allaround_ok(manvx,manvy,0);
X		   }
X		}
X
X		/* do refresh */
X		else if (eventbp->window==wind[refresh_wind])
X   			refresh();
X
X		/* otherwise, it must be a move or mark */
X		/*    BUTTON1 (left)   : move man */
X		/*    BUTTON2 (middle) : mark unsafe (as bomb */
X		/*    BUTTON3 (right)  : mark safe */
X		/* If a mark is desired, and the square is already marked */
X		/*    as the desired mark, then the square will be unmarked */
X		else if (eventbp->window==field)
X		   if (setvxvy(eventbp->x,eventbp->y,&vx,&vy)!=OUT_OF_RANGE) {
X		   switch (eventbp->button) {
X			case BUTTON1 :	move_man(vx,vy);
X					break;
X			case BUTTON2 :	if (FIELD[vx][vy].m == fm_bomb)
X					     remove_mark(vx,vy);
X					else
X					     mark_bomb(vx,vy);
X					break;
X			case BUTTON3 :	if (FIELD[vx][vy].m == fm_safe)
X					     remove_mark(vx,vy);
X					else
X					     mark_ok(vx,vy);
X					break;
X			default      :	fprintf(stderr,
X						"Error: Illegal button\n");
X					exit(3);
X		   } /* switch */
X		   if (sanity)
X			do_sanity_check(manvx,manvy);
X		   }
X		break;
X
X	/*---Now check for keyboard events-----------------------------*/
X
X	   case KeyPress:
X		eventkp = (XKeyPressedEvent *) &event;
X   		XLookupString(&event,&s,1,&ksym,NULL);
X   		switch (ksym) {
X		/* Ignore the following;  otherwise, control-l is */
X		/*    interpreted as two keystrokes */
X		   case XK_Control_L:
X		   case XK_Shift_L:
X		   case XK_Shift_R:
X		   case XK_Caps_Lock:
X		   case XK_Meta_L:
X		   case XK_Meta_R:
X		   case XK_Alt_L:
X		   case XK_Alt_R:
X			break;
X   		   default:
X   			switch (s) {
X   			   case '':			/* refresh */
X   				refresh(); break;
X			   case 'p':
X			   case 'P':
X				do_pause();
X				break;
X			   case 'q':
X			   case 'Q':			/* quit */
X				show_and_add_scores();
X			   case ' ':			/* mark allaround */
X				mark_allaround_ok(manvx,manvy,-1);
X				if (sanity)
X					do_sanity_check(manvx,manvy);
X				break;
X			   default:
X				print_status("Illegal keyboard input");
X				XBell(disp,0); break;
X			} /* switch (s) */
X			break;
X		} /* switch (ksym) */
X		break;
X	   default:
X		fprintf(stderr,"Error: Illegal event\n");
X		exit(4);
X	} /* switch (event.type) */
X}
END_OF_FILE
if test 6232 -ne `wc -c <'event.c'`; then
    echo shar: \"'event.c'\" unpacked with wrong size!
fi
# end of 'event.c'
fi
if test -f 'xtmines.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xtmines.c'\"
else
echo shar: Extracting \"'xtmines.c'\" \(3271 characters\)
sed "s/^X//" >'xtmines.c' <<'END_OF_FILE'
X/* xtmines: game where you try to cross a minefield */
X/* Written by Timothy Tsai  April 13, 1992 */
X
X#include "xtmines.h"
X
Xint	bw = def_bw;	/* border width for all windows */
Xint	x  = def_x;	/* frame x */
Xint	y  = def_y;	/*       y */
Xint	w  = def_w;	/*       width */
Xint	h  = def_h;	/*       height */
Xint	fh = def_fh;	/* field height */
X
Xint	num_bombs_left;
Xint	num_time_left;			/* num of seconds */
Xint	num_time_left_at_start;		/* num of seconds */
Xint	num_score		= 0;
Xint	num_grenades_left	= NUM_GRENADES_AT_START;
Xint	num_tombstones		= 0;
Xint	num_lives		= STARTING_NUM_LIVES;
Xint	automark		= TRUE;
Xint	sanity			= FALSE;
Xint	extended_automark	= FALSE;
Xshowtype	show		= DEF_SHOW;
Xint	used_showfig;
Xint	used_sanity;
Xint	used_eautomark;
X
Xint	finished;	/* reach goal yet? */
Xint	dead = FALSE;
X
Xint	num_bonus;
Xint	pause_time;
Xlong	time_at_start_of_level;	/* time at start of each level */
X
XDisplay		*disp;
XWindow		root,frame,field,wind[NUMWINDS];
Xint		screen,depth;
XVisual		*visual;
Xunsigned long	white,black;
XFont		fonts,fontm,fontt;
XXFontStruct	*fontsstruct,*fontmstruct,*fonttstruct;
Xint		fontsw,fontsh,fontsa,
X		fontshoww,fontshowh,fontshowa,
X		fontmw,fontmh,fontma,
X		fonttw,fontth,fontta;
X
XXColor		color[NUMCOLORS];
XGC		gcs,gcm,gct;
XColormap	cmap;
X
Xranktype	level;
Xranktype	start_level=DEF_LEVEL;
X
Xextern int show_hiscores();
Xextern void show_and_add_scores();
X
X
Xmain(argc,argv)
Xint argc;
Xchar **argv;
X{
X	XEvent		event;
X
X
X	printf("xtmines -- by Timothy K. Tsai (ttsai@uiuc.edu)\n");
X	printf("   Version %d.%d (patchlevel %d) -- last modification on %s\n",
X		MAJOR_VERSION_NUM,MINOR_VERSION_NUM,PATCHLEVEL,LAST_MOD_DATE);
X
X	if (argc==2) {
X	   if (!strcmp(argv[1],"-s")) {
X		show_hiscores(NOX);
X		exit(0);
X	   }
X	   else if ((argv[1][0]=='-') && (argv[1][1]=='l'))
X		switch (argv[1][2]-'0') {
X			case 0	: start_level = grunt; break;
X			case 1	: start_level = corporal; break;
X			case 2	: start_level = lieutenant; break;
X			case 3	: start_level = captain; break;
X			case 4	: start_level = mmajor; break;
X			case 5	: start_level = general; break;
X			case 6	: start_level = president; break;
X			case 7	: start_level = king; break;
X			case 8	: start_level = emperor; break;
X			case 9	: start_level = angel; break;
X			default	: fprintf(stderr,
X				     "Error: Rank should be in range (0-9)\n");
X				  exit(ILLEGAL_ARGUMENT);
X		}
X	   else {
X		fprintf(stderr,"   xtmines\n");
X		fprintf(stderr,"      -s    show high scores list\n");
X		fprintf(stderr,"      -lr   start at level r\n");
X		exit(ILLEGAL_ARGUMENT);
X	   }
X	}
X	else if (argc != 1) {
X		fprintf(stderr,"   xtmines\n");
X		fprintf(stderr,"      -s    show high scores list\n");
X		fprintf(stderr,"      -lr   start at level r\n");
X		exit(ILLEGAL_ARGUMENT);
X	}
X
X	open_display();
X	load_fonts();
X	create_map_frame();
X	create_GC_colormap();
X	set_event_masks();
X
X	for (level=start_level;(level<=HIGHEST_PLAYABLE_RANK) && 
X	(num_lives>0);level++) {
X		init_values();
X
X		set_field();
X		show_bomb_status(manvx,manvy);
X		refresh();
X
X		time_at_start_of_level = time(0);
X
X		finished = FALSE;
X
X		while (!finished) {
X			if (XPending(disp) > 0) {
X				XNextEvent(disp,&event);
X				handle_event(&event);
X			}
X			else usleep(XPENDING_UDELAY);
X			if ((!dead) && (!finished))
X				dead = update_time();
X		}
X	}
X
X	show_and_add_scores();
X}
END_OF_FILE
if test 3271 -ne `wc -c <'xtmines.c'`; then
    echo shar: \"'xtmines.c'\" unpacked with wrong size!
fi
# end of 'xtmines.c'
fi
if test -f 'hiscore.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hiscore.c'\"
else
echo shar: Extracting \"'hiscore.c'\" \(6234 characters\)
sed "s/^X//" >'hiscore.c' <<'END_OF_FILE'
X/* xtmines: game where you try to cross a minefield */
X/* hiscore.c: */
X/* Written by Timothy Tsai  April 13, 1992 */
X
X#include <sys/file.h>
X#include <pwd.h>
X#include <time.h>
X#include "xtmines.h"
X
X#define MAXSCORES		10
X#define MAX_ANGEL_STARTS	5
X#define HISCORE_FILENAME	"/home/bach3/ttsai/games/xtmines/xtmines.hiscores"
X
Xtypedef struct {
X	int		uid, score;
X	ranktype	final_level,start_level;
X	long		timestamp;
X} score_t;
X
Xvoid show_final_score()
X{
X	printf("Your final score was %d\n",num_score);
X	printf("Your final rank was %s\n",num_rank_to_words(level));
X}
X
Xint add_hiscore()
X{
X	int	fd;
X	score_t
X		current, last, mine;
X	int	occ = 0;		/* num times current user */
X					/*    is on hiscore list  */
X	int	angelocc = 0;		/* num times current user is on list */
X					/*    and started on level angel */
X	int	trickle = FALSE;
X	int	myuid;
X	int	added = FALSE;		/* current score added yet? */
X
X	myuid = getuid();	/* current user's uid */
X	mine.uid = myuid;
X	mine.score = num_score;
X	mine.final_level = level;
X	mine.start_level = start_level;
X	mine.timestamp = time(0);
X
X	if ((fd=open(HISCORE_FILENAME,O_RDWR,0666)) < 0) {
X	   if ((fd=open(HISCORE_FILENAME,O_CREAT|O_WRONLY,0666)) < 0) {
X		fprintf(stderr,"Error: Can't open %s\n",HISCORE_FILENAME);
X		exit(5);
X	   }
X	   write(fd, (char *) &mine, sizeof(score_t));
X	   close(fd);
X	   return(0);
X	}
X
X
X	while (read(fd,(char *) &current,sizeof(score_t))==sizeof(score_t)) {
X		if ((!added) && (num_score > current.score) &&
X		    ((angelocc < MAX_ANGEL_STARTS) ||
X		     (angelocc == MAX_ANGEL_STARTS) && (start_level != angel))){
X		/* add to hiscore list */
X			last = mine;
X			trickle = TRUE;
X			added = TRUE;
X			occ++;
X			if (mine.start_level == angel) angelocc++;
X		}
X		if (trickle) {
X			lseek(fd, (long) -sizeof(score_t), L_INCR);
X			write(fd, (char *) &last, sizeof(score_t));
X			last = current;
X			if (myuid == current.uid) {
X				occ++;
X				if (current.start_level == angel) angelocc++;
X				if ((occ > MAXSCORES) ||
X				    ((angelocc > MAX_ANGEL_STARTS) &&
X				     (mine.start_level == angel))) {
X					trickle = FALSE;
X					if (occ > MAXSCORES) break;
X				}
X			}
X		}
X		else {
X			if (myuid == current.uid) {
X				occ++;
X				if (current.start_level == angel) angelocc++;
X				if (occ == MAXSCORES)
X					break;
X			}
X		}
X	}
X	if (trickle)
X		write(fd, (char *) &last, sizeof(score_t));
X	if ((!added) && (occ < MAXSCORES) && (angelocc < MAX_ANGEL_STARTS))
X		write(fd, (char *) &mine, sizeof(score_t));
X	close(fd);
X}
X
X#define LINE_SEP	2	/* separation between lines in hswind */
X#define LEFT_MARGIN	3	/* pixel sep from left edge of hswind */
Xint show_hiscores(dox)
Xint dox;	/* boolean:  do Xwindow show or just text */
X{
X	int	fd;
X	int	lastuid = -1;
X	int	i = 0;
X	score_t	curscore;
X	int	pcount = MAXSCORES;
X	int	myuid;
X	struct passwd *user;
X	char	*name;
X	int	lines=0,width,height;
X	Window	hswind;		/* high score window */
X	char	str[MAXSTRLEN];
X	int	px=LEFT_MARGIN,	/* pixel positions for next line */
X		py=fontmh;
X	XEvent                  event;
X	XButtonPressedEvent     *eventbp;
X	XKeyPressedEvent        *eventkp;
X	int                     wait = TRUE;
X
X	if ((fd=open(HISCORE_FILENAME,O_RDONLY,0666)) < 0) {
X		fprintf(stderr,"Error: Can't open %s\n",HISCORE_FILENAME);
X		exit(5);
X	}
X
X	myuid = getuid();
X	printf("Rank User          Score Final level  Start level  Time\n");
X	lines++;
X
X	while (read(fd,(char *)&curscore,sizeof(score_t)) == sizeof(score_t)) {
X		i++;
X		if (pcount || curscore.uid == myuid) {
X			if (lastuid != curscore.uid) {
X				user = getpwuid(curscore.uid);
X				lastuid = curscore.uid;
X			}
X			name = user->pw_name;
X			/* no \n is needed because ctime puts one there */
X			printf("%4d %-9s %9d %-11s  %-11s  %24s",
X				i,name,curscore.score,
X				num_rank_to_words(curscore.final_level),
X				((curscore.start_level<grunt) ||
X				 (curscore.start_level>god)) ?
X				" " : num_rank_to_words(curscore.start_level),
X				ctime(&curscore.timestamp));
X			lines++;
X			if (pcount) pcount--;
X		}
X	}
X	close(fd);
X	printf("There are %d scores to date\n", i);
X	lines++;
X
X	if (dox == NOX)
X		return(SUCCESS);
X
X	/* create new window */
X	lastuid = -1;
X	i = 0;
X	pcount = MAXSCORES;
X	width = fontmw*40;
X	height = (fontmh+LINE_SEP)*(lines+1);
X	hswind = XCreateSimpleWindow(disp,frame,(w-width)/2,(h-height)/2,
X		width,height,bw,black,white);
X	XSelectInput(disp,hswind,KeyPressMask|ButtonPressMask);
X	XMapRaised(disp,hswind);
X	XSetForeground(disp,gct,color[font_color].pixel);
X	XSetBackground(disp,gct,color[background_color].pixel);
X	XFlush(disp);
X
X	/* print in new window */
X	if ((fd=open(HISCORE_FILENAME,O_RDONLY,0666)) < 0) {
X		fprintf(stderr,"Error: Can't open %s\n",HISCORE_FILENAME);
X		exit(5);
X	}
X	sprintf(str,"Rank User          Score  Level");
X	XDrawImageString(disp,hswind,gct,px,py,str,strlen(str));
X	XFlush(disp);
X	py += (fontmh + LINE_SEP);
X	while (read(fd,(char *)&curscore,sizeof(score_t)) == sizeof(score_t)){
X		i++;
X		if (pcount || curscore.uid == myuid) {
X			if (lastuid != curscore.uid) {
X				user = getpwuid(curscore.uid);
X				lastuid = curscore.uid;
X			}
X			name = user->pw_name;
X			sprintf(str,"%4d %-9s %9d %s",i,name,curscore.score,
X				num_rank_to_words(curscore.final_level));
X			XDrawImageString(disp,hswind,gct,px,py,
X				str,strlen(str));
X			XFlush(disp);
X			py += (fontmh + LINE_SEP);
X			if (pcount) pcount--;
X		}
X	}
X	close(fd);
X	sprintf(str,"There are %d scores to date", i);
X	XDrawImageString(disp,hswind,gct,px,py,str,strlen(str));
X	py += (fontmh + LINE_SEP);
X	sprintf(str,"Press key or click button to end");
X	XDrawImageString(disp,hswind,gct,px,py,str,strlen(str));
X	XFlush(disp);
X
X	/* Wait for keypress or button click */
X	while (wait == TRUE) {
X	   while (!XPending(disp))
X		usleep(XPENDING_UDELAY);
X	   XNextEvent(disp,&event);
X	   if (event.type==ButtonPress) {
X		eventbp = (XButtonPressedEvent *) &event;
X		if ((eventbp->window == hswind) ||
X		    (eventbp->window == field) ||
X		    (eventbp->window == wind[quit_wind]))
X	                wait = FALSE;
X	   }
X	   else if (event.type == KeyPress) {
X		eventkp = (XKeyPressedEvent *) &event;
X		if ((eventkp->window == hswind) ||
X		    (eventkp->window == field))
X			wait = FALSE;
X	   }
X	}
X
X	return (SUCCESS);
X}
X
Xvoid show_and_add_scores()
X{
X	show_final_score();
X	add_hiscore();
X	show_hiscores(DOX);
X	exit(SUCCESS);
X}
END_OF_FILE
if test 6234 -ne `wc -c <'hiscore.c'`; then
    echo shar: \"'hiscore.c'\" unpacked with wrong size!
fi
# end of 'hiscore.c'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
echo shar: Extracting \"'patchlevel.h'\" \(21 characters\)
sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X#define PATCHLEVEL	1
END_OF_FILE
if test 21 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
fi
# end of 'patchlevel.h'
fi
if test -f 'xtmines.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xtmines.h'\"
else
echo shar: Extracting \"'xtmines.h'\" \(6031 characters\)
sed "s/^X//" >'xtmines.h' <<'END_OF_FILE'
X/* xtmines: game where you try to cross a minefield */
X/* Written by Timothy Tsai  April 13, 1992 */
X
X#define LAST_MOD_DATE		"June 19, 1992"
X#define MAJOR_VERSION_NUM	1
X#define MINOR_VERSION_NUM	2
X
X#include <stdio.h>
X#include <X11/Xlib.h>
X#define XK_MISCELLANY
X#include <X11/keysymdef.h>
X#include "patchlevel.h"
X/* bitmaps */
X#include "safe.bm"
X#include "man.bm"
X#include "bomb.bm"
X#include "tstone.bm"
X#include "goal.bm"
X#include "trail.bm"
X#include "pow.bm"
X#include "bombmark.bm"
X#include "safewrong.bm"
X#include "bombmarkwrong.bm"
X
X#define FALSE		0
X#define TRUE		1
X
X#define NUMROWS				25
X#define NUMCOLS				40
X#define BOMB_EXPLODE_UDELAY		10000
X#define XPENDING_UDELAY			50000
X#define SECONDS_PER_LEVEL		(5*60)
X#define NUM_GRENADES_AT_START		3
X#define	POINTS_PER_GRENADE		100
X#define POINTS_PER_TOMBSTONE		200
X#define POINTS_FOR_USED_SHOWFIG		50
X#define PERCENT_FOR_USED_SANITY		1
X#define PERCENT_FOR_USED_EAUTOMARK	10
X#define GRENADE_DISTANCE		5
X#define STARTING_NUM_LIVES		3
X#define LOWEST_LEVEL_FOR_REWARD		lieutenant
X#define LOWEST_SCORE_FOR_REWARD		3000
X#define MAXLIVES			6
X
X#define MAXSTRLEN	200
X#define BUTTON1		1	/* use mouse button 1 */
X#define BUTTON2		2	/* use mouse button 2 */
X#define BUTTON3		3	/* use mouse button 3 */
X/* status font */
X#define FONTS		"*courier-bold-r-normal--24*"
X/* main font */
X#define FONTM		"*courier-bold-r-normal--14*"
X/* time font */
X#define FONTT		"*courier-bold-r-normal--18*"
X#define def_fh		NUMROWS*(man_height+1)
X					/* field height */
X#define	def_bw		4       	/* border width for all windows */
X#define	def_x		0      	 	/* frame x */
X#define	def_y		0       	/*       y */
X#define	def_w		2*def_bw + NUMCOLS*(man_width+1)
X					/*       width */
X#define	def_h		def_fh+140     /*       height */
X
Xextern int	bw;	/* border width for all windows */
Xextern int	x;	/* frame x */
Xextern int	y;	/*       y */
Xextern int	w;	/*       width */
Xextern int	h;	/*       height */
Xextern int	fh;	/* field height */
X
Xextern int	finished;
Xextern int	dead;
X
X#define SUCCESS			0
X#define OUT_OF_RANGE		1
X#define NO_MARK_TO_REMOVE	2
X#define CANT_MARK		3
X#define TIME_IS_OVER		TRUE
X#define NO_GRENADES_LEFT	4
X#define TOO_FAR_TO_TOSS_GRENADE	5
X#define ILLEGAL_POSITION	6
X#define SQUARE_IS_UNSAFE	7
X#define CANT_EXPLODE		8
X#define DIED			9
X#define ILLEGAL_ARGUMENT	10
X#define NOX			11
X#define DOX			12
X#define CHECK_FAILED		13
X
Xtypedef enum {bombs_left,bonus_wind,time_left,score, grenades_left,rank,
X		lives_left,
X		automark_wind,giveup_wind,tgrenade_wind,show_wind,quit_wind,
X		refresh_wind,eautomark_wind,sanitycheck_wind,pause_wind,
X		status} windtype;
X#define NUM1WINDS	6	/* num of winds per row */
X#define	NUMWINDS	17	/* tot num of winds */
Xtypedef enum {grunt,corporal,lieutenant,captain,mmajor,general,president,
X		king,emperor,angel,god} ranktype;
X#define NUMRANKS		10	/* doesn't include god */
X#define HIGHEST_PLAYABLE_RANK	angel
X#define DEF_LEVEL	grunt
Xextern ranktype	level;
Xextern ranktype start_level;
Xextern int num_bombs_at_start[NUMRANKS];
Xextern int num_bonus;
X
Xextern int	num_bombs_left;
Xextern int	num_time_left;		/* num of seconds */
Xextern int	num_time_left_at_start;	/* num of seconds */
Xextern long	time_at_start_of_level;
Xextern int	num_score;
Xextern int	num_grenades_left;
Xextern int	num_tombstones;
Xextern int	num_lives;
Xextern int	automark;
Xextern int	extended_automark;
Xextern int	sanity;
X#define MIN_EXTENDED_MARK_LEVEL		lieutenant
Xextern int	pause_time;
X
Xextern Display		*disp;
Xextern Window		root,frame,field,wind[NUMWINDS];
Xextern int		screen,depth;
Xextern Visual		*visual;
Xextern unsigned long	white,black;
Xextern Font		fonts,fontm,fontt;
Xextern XFontStruct	*fontsstruct,*fontmstruct,*fonttstruct;
Xextern int		fontsw,fontsh,fontsa,
X			fontshoww,fontshowh,fontshowa,
X			fontmw,fontmh,fontma,
X			fonttw,fontth,fontta;
X
X#define font_color	0
X#define background_color 1
X#define field_color	2
X#define NUMCOLORS	3
X#define FONTCOLOR	"black"
X#define BACKGROUNDCOLOR	"white"
X#define FIELDCOLOR	"black"
Xextern XColor		color[NUMCOLORS];
Xextern GC		gcs,gcm,gct;
Xextern Colormap	cmap;
X
Xtypedef enum {bm_empty,bm_safe,bm_man,bm_bomb,bm_tombstone,bm_goal,
X		bm_trail,bm_pow,bm_bombmark,bm_safewrong,bm_bombmarkwrong} 
X		bmtype;
X#define NUMBITMAPS	11
Xtypedef enum {fc_empty,fc_trail,fc_man,fc_bomb,fc_tombstone,
X		fc_goal} fieldcont;
Xtypedef enum {fm_nomark,fm_safe,fm_bomb} fieldmark;
Xtypedef struct {
X		fieldcont	c;
X		fieldmark	m;
X		int		done;	/* used for mark_allaround_ok() */
X	} fieldstruct;
Xextern fieldstruct FIELD[NUMCOLS][NUMROWS];
Xtypedef enum {sh_man,sh_fig} showtype;
X#define DEF_SHOW	sh_fig
Xextern showtype show;
Xextern int used_showfig;	/* boolean: used showfig on present level? */
Xextern int used_sanity;		/* boolean: used sanity on present level? */
Xextern int used_eautomark;	/* boolean: used eautomark on present level? */
Xextern Pixmap bitmap[NUMBITMAPS];
Xextern int bmwidth[NUMBITMAPS];
Xextern int bmheight[NUMBITMAPS];
X
Xextern int manvx,manvy;		/* current virtual man position */
X
Xextern void open_display();
Xextern void load_fonts();
Xextern void create_map_frame();
Xextern void create_GC_colormap();
Xextern void set_event_masks();
Xextern void init_values();
Xextern int illegal_bomb_position();
Xextern void set_field();
X
X/* This is a kludge for system without usleep() */
X#ifdef NOUSLEEP
Xextern void usleep();
X#endif
Xextern void PrintStr();
Xextern void InvPrintStr();
Xextern void WindPrint();
Xextern char *num_rank_to_words();
Xextern char *clock_time_str();
Xextern void print_display();
Xextern void draw();
Xextern void clear();
Xextern void draw_field();
Xextern void refresh();
Xextern int setxy();
Xextern int setvxvy();
Xextern int bomb_status();
Xextern void show_bomb_status();
Xextern void show_all_bombs();
Xextern void do_promotion();
Xextern int move_man();
Xextern int remove_mark();
Xextern int mark_ok();
Xextern int mark_allaround_ok();
Xextern int mark_bomb();
Xextern void die();
Xextern int current_bonus();
Xextern int explode();
Xextern void uptdate_time();
Xextern int throw_grenade();
Xextern int update_time();
Xextern int do_sanity_check();
Xextern int do_pause();
END_OF_FILE
if test 6031 -ne `wc -c <'xtmines.h'`; then
    echo shar: \"'xtmines.h'\" unpacked with wrong size!
fi
# end of 'xtmines.h'
fi
if test -f 'bomb.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bomb.bm'\"
else
echo shar: Extracting \"'bomb.bm'\" \(506 characters\)
sed "s/^X//" >'bomb.bm' <<'END_OF_FILE'
X#define bomb_width 23
X#define bomb_height 23
Xstatic char bomb_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
X   0x00, 0x80, 0x19, 0x00, 0x5f, 0x06, 0xc0, 0x7f, 0x0c, 0xf0, 0xff, 0x09,
X   0xf0, 0xf7, 0x11, 0xf8, 0xc3, 0x0b, 0xf8, 0x83, 0x07, 0xfc, 0x0f, 0x07,
X   0xfc, 0x1f, 0x07, 0xfc, 0x3f, 0x07, 0xfc, 0xbf, 0x07, 0xfc, 0xff, 0x07,
X   0xf8, 0xff, 0x03, 0xf8, 0xff, 0x03, 0xf0, 0xff, 0x01, 0xf0, 0xff, 0x01,
X   0xc0, 0x7f, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 506 -ne `wc -c <'bomb.bm'`; then
    echo shar: \"'bomb.bm'\" unpacked with wrong size!
fi
# end of 'bomb.bm'
fi
if test -f 'bombmark.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bombmark.bm'\"
else
echo shar: Extracting \"'bombmark.bm'\" \(518 characters\)
sed "s/^X//" >'bombmark.bm' <<'END_OF_FILE'
X#define bombmark_width 23
X#define bombmark_height 23
Xstatic char bombmark_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x7f, 0x38, 0xc0, 0xff, 0x3d, 0xe0, 0xff, 0x3f,
X   0xf0, 0xc1, 0x1f, 0x78, 0x80, 0x0f, 0x3c, 0xc0, 0x1f, 0x1c, 0xe0, 0x1f,
X   0x1e, 0xf0, 0x3d, 0x0e, 0xf8, 0x38, 0x0e, 0x7c, 0x38, 0x0e, 0x3e, 0x38,
X   0x0e, 0x1f, 0x38, 0x8e, 0x0f, 0x38, 0xde, 0x07, 0x3c, 0xfc, 0x03, 0x1c,
X   0xfc, 0x01, 0x1e, 0xf8, 0x00, 0x0f, 0xfc, 0xc1, 0x07, 0xfe, 0xff, 0x03,
X   0xde, 0xff, 0x01, 0x0e, 0x7f, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 518 -ne `wc -c <'bombmark.bm'`; then
    echo shar: \"'bombmark.bm'\" unpacked with wrong size!
fi
# end of 'bombmark.bm'
fi
if test -f 'bombmarkwrong.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bombmarkwrong.bm'\"
else
echo shar: Extracting \"'bombmarkwrong.bm'\" \(533 characters\)
sed "s/^X//" >'bombmarkwrong.bm' <<'END_OF_FILE'
X#define bombmarkwrong_width 23
X#define bombmarkwrong_height 23
Xstatic char bombmarkwrong_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0x80, 0xc7, 0x3f, 0x00, 0xc2, 0x1f, 0x00, 0xc0,
X   0x0f, 0x3e, 0xe0, 0x87, 0x7f, 0xf0, 0xc3, 0x3f, 0xe0, 0xe3, 0x1f, 0xe0,
X   0xe1, 0x0f, 0xc2, 0xf1, 0x07, 0xc7, 0xf1, 0x83, 0xc7, 0xf1, 0xc1, 0xc7,
X   0xf1, 0xe0, 0xc7, 0x71, 0xf0, 0xc7, 0x21, 0xf8, 0xc3, 0x03, 0xfc, 0xe3,
X   0x03, 0xfe, 0xe1, 0x07, 0xff, 0xf0, 0x03, 0x3e, 0xf8, 0x01, 0x00, 0xfc,
X   0x21, 0x00, 0xfe, 0xf1, 0x80, 0xff, 0xff, 0xff, 0xff};
END_OF_FILE
if test 533 -ne `wc -c <'bombmarkwrong.bm'`; then
    echo shar: \"'bombmarkwrong.bm'\" unpacked with wrong size!
fi
# end of 'bombmarkwrong.bm'
fi
if test -f 'goal.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'goal.bm'\"
else
echo shar: Extracting \"'goal.bm'\" \(506 characters\)
sed "s/^X//" >'goal.bm' <<'END_OF_FILE'
X#define goal_width 23
X#define goal_height 23
Xstatic char goal_bits[] = {
X   0xff, 0xff, 0x7f, 0xab, 0x1a, 0x40, 0x55, 0xf5, 0x7f, 0xab, 0x1a, 0x40,
X   0x55, 0xf5, 0x7f, 0xab, 0x1a, 0x40, 0x55, 0xf5, 0x7f, 0xab, 0x1a, 0x40,
X   0xff, 0xff, 0x7f, 0x01, 0x00, 0x40, 0xff, 0xff, 0x7f, 0x01, 0x00, 0x40,
X   0xff, 0xff, 0x7f, 0x01, 0x00, 0x40, 0xff, 0xff, 0x7f, 0x01, 0x00, 0x00,
X   0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
X   0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00};
END_OF_FILE
if test 506 -ne `wc -c <'goal.bm'`; then
    echo shar: \"'goal.bm'\" unpacked with wrong size!
fi
# end of 'goal.bm'
fi
if test -f 'man.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'man.bm'\"
else
echo shar: Extracting \"'man.bm'\" \(493 characters\)
sed "s/^X//" >'man.bm' <<'END_OF_FILE'
X#define man_width 23
X#define man_height 23
X
Xstatic char man_bits[] = {
X 0x80, 0xff, 0x00, 0xc0, 0x80, 0x7d, 0x40, 0x22, 0x45, 0x40, 0x08, 0x45,
X 0x00, 0x3e, 0x44, 0x00, 0x00, 0x38, 0xc0, 0xff, 0x11, 0x40, 0x00, 0x11,
X 0x7e, 0x08, 0x2f, 0x7e, 0x00, 0x3f, 0x7e, 0x08, 0x2f, 0x4e, 0x00, 0x11,
X 0xce, 0xff, 0x11, 0xc4, 0xff, 0x11, 0xce, 0xff, 0x11, 0xd1, 0xff, 0x11,
X 0x9f, 0xf7, 0x10, 0x91, 0xf7, 0x10, 0x91, 0xf7, 0x10, 0x9f, 0xf7, 0x00,
X 0xc0, 0xf7, 0x01, 0xf0, 0xf7, 0x07, 0xf0, 0xf7, 0x07 };
END_OF_FILE
if test 493 -ne `wc -c <'man.bm'`; then
    echo shar: \"'man.bm'\" unpacked with wrong size!
fi
# end of 'man.bm'
fi
if test -f 'pow.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pow.bm'\"
else
echo shar: Extracting \"'pow.bm'\" \(503 characters\)
sed "s/^X//" >'pow.bm' <<'END_OF_FILE'
X#define pow_width 23
X#define pow_height 23
Xstatic char pow_bits[] = {
X   0x11, 0x51, 0x46, 0x22, 0x12, 0x22, 0x44, 0x52, 0x11, 0x88, 0x54, 0x09,
X   0x80, 0x54, 0x44, 0x1f, 0x55, 0x02, 0x3f, 0x31, 0x11, 0x33, 0x9a, 0x4a,
X   0x33, 0x50, 0x78, 0x33, 0x00, 0x00, 0x3f, 0xc7, 0x36, 0x9f, 0xcf, 0x36,
X   0xc3, 0xd8, 0x36, 0xc3, 0xd8, 0x36, 0xc3, 0xd8, 0x36, 0x83, 0xcf, 0x37,
X   0x03, 0x87, 0x19, 0x20, 0x00, 0x00, 0x90, 0x52, 0x04, 0x48, 0x50, 0x09,
X   0x64, 0x50, 0x12, 0x32, 0xd1, 0x22, 0x01, 0x91, 0x44};
END_OF_FILE
if test 503 -ne `wc -c <'pow.bm'`; then
    echo shar: \"'pow.bm'\" unpacked with wrong size!
fi
# end of 'pow.bm'
fi
if test -f 'safe.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'safe.bm'\"
else
echo shar: Extracting \"'safe.bm'\" \(506 characters\)
sed "s/^X//" >'safe.bm' <<'END_OF_FILE'
X#define safe_width 23
X#define safe_height 23
Xstatic char safe_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00,
X   0x00, 0x60, 0x00, 0x00, 0x60, 0x00, 0x00, 0x60, 0x60, 0x00, 0x60, 0x70,
X   0x00, 0x60, 0x38, 0x00, 0x60, 0x1c, 0xf8, 0x60, 0x0e, 0xfc, 0x61, 0x07,
X   0x06, 0xe3, 0x03, 0x03, 0xe6, 0x01, 0x03, 0xe6, 0x03, 0x03, 0x66, 0x07,
X   0x03, 0x66, 0x0e, 0x03, 0x66, 0x1c, 0x06, 0x63, 0x38, 0xfc, 0x61, 0x70,
X   0xf8, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 506 -ne `wc -c <'safe.bm'`; then
    echo shar: \"'safe.bm'\" unpacked with wrong size!
fi
# end of 'safe.bm'
fi
if test -f 'safewrong.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'safewrong.bm'\"
else
echo shar: Extracting \"'safewrong.bm'\" \(521 characters\)
sed "s/^X//" >'safewrong.bm' <<'END_OF_FILE'
X#define safewrong_width 23
X#define safewrong_height 23
Xstatic char safewrong_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff,
X   0xff, 0x9f, 0xff, 0xff, 0x9f, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0x9f, 0x8f,
X   0xff, 0x9f, 0xc7, 0xff, 0x9f, 0xe3, 0x07, 0x9f, 0xf1, 0x03, 0x9e, 0xf8,
X   0xf9, 0x1c, 0xfc, 0xfc, 0x19, 0xfe, 0xfc, 0x19, 0xfc, 0xfc, 0x99, 0xf8,
X   0xfc, 0x99, 0xf1, 0xfc, 0x99, 0xe3, 0xf9, 0x9c, 0xc7, 0x03, 0x9e, 0x8f,
X   0x07, 0x9f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
END_OF_FILE
if test 521 -ne `wc -c <'safewrong.bm'`; then
    echo shar: \"'safewrong.bm'\" unpacked with wrong size!
fi
# end of 'safewrong.bm'
fi
if test -f 'trail.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'trail.bm'\"
else
echo shar: Extracting \"'trail.bm'\" \(499 characters\)
sed "s/^X//" >'trail.bm' <<'END_OF_FILE'
X#define trail_width 23
X#define trail_height 23
X
Xstatic char trail_bits[] = {
X 0x55, 0x55, 0x55, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0x2a,
X 0x55, 0x55, 0x55, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0x2a,
X 0x55, 0x55, 0x55, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0x2a,
X 0x55, 0x55, 0x55, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0x2a,
X 0x55, 0x55, 0x55, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55, 0xaa, 0xaa, 0x2a,
X 0x55, 0x55, 0x55, 0xaa, 0xaa, 0x2a, 0x55, 0x55, 0x55 };
END_OF_FILE
if test 499 -ne `wc -c <'trail.bm'`; then
    echo shar: \"'trail.bm'\" unpacked with wrong size!
fi
# end of 'trail.bm'
fi
if test -f 'tstone.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tstone.bm'\"
else
echo shar: Extracting \"'tstone.bm'\" \(502 characters\)
sed "s/^X//" >'tstone.bm' <<'END_OF_FILE'
X#define tstone_width 23
X#define tstone_height 23
X
Xstatic char tstone_bits[] = {
X 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x80, 0xff, 0x00, 0xc0, 0xff, 0x01,
X 0xe0, 0xff, 0x03, 0xe0, 0xff, 0x03, 0xf0, 0xff, 0x07, 0x30, 0x16, 0x07,
X 0xb0, 0xd5, 0x06, 0xb0, 0xd5, 0x06, 0x30, 0x16, 0x07, 0xb0, 0xd4, 0x07,
X 0xb0, 0xd5, 0x07, 0xf0, 0xff, 0x07, 0x70, 0x08, 0x07, 0x30, 0x77, 0x06,
X 0xb0, 0x80, 0x06, 0x30, 0x77, 0x06, 0xb0, 0xf7, 0x06, 0xf0, 0xc1, 0x07,
X 0xfc, 0xff, 0x1f, 0xfc, 0xff, 0x1f, 0x00, 0x00, 0x00 };
END_OF_FILE
if test 502 -ne `wc -c <'tstone.bm'`; then
    echo shar: \"'tstone.bm'\" unpacked with wrong size!
fi
# end of 'tstone.bm'
fi
if test -f 'xtmines.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xtmines.man'\"
else
echo shar: Extracting \"'xtmines.man'\" \(12485 characters\)
sed "s/^X//" >'xtmines.man' <<'END_OF_FILE'
X.\" Copyright (c) 1992 Timothy K. Tsai
X.\" All rights reserved.
X.\"
X.TH XTMINES 6 "18 April 1992"
X.SH NAME
Xxtmines \- X11-based minefield game
X.SH DESCRIPTION
X.B xtmines
Xis a games that runs under X11.  To start up the game, simply type xtmines.  A
Xfew command line options are listed below under OPTIONS.
X.LP
XThe display consists of two main areas: the field at the top and the
Xinformation windows at the bottom.  The field is divided into a 40x25 grid of
Xsquares.  You are the man (indicated by the number 0) at the top-left corner.
XYour objective is to traverse the field and arrive safely at the goal (the
Xflag) at the bottom-right corner.  Along the way, hidden bombs are scattered
Xacross the field.  As you determine which squares are safe and which are
Xunsafe, you may make appropriate marks using the middle and right mouse
Xbuttons.
X.LP
XYou can only move across the field one square (horizontally, vertically, or
Xdiagonally) at a time.  You are also allowed to immediately move to any square
Xyou have previously been to (such squares will be shaded gray), or any square
Xthat you have marked as safe and which is adjacent to a square already
Xtraversed.  If you land on a square with a bomb, then you will blow up.  Any
Xbombs that are horizontally or vertically (but not diagonally) adjacent will
Xalso blow up.  This causes a possible "chain reaction" of bomb explosions.
X.LP
XTo aid your traversal of the field, you will be told how many of the adjacent
X(up to eight) squares contain bombs.  This information will usually be
Xsufficient to determine where the hidden bombs are.  Instead of having the
Xnumber of adjacent bombs shown in the square where you currently are (this
Xoption is called
X.I showfig
X) you can choose to have your current position marked by a man.  To toggle this
Xoption, click on the square labeled "Show=?".
X.LP
XAs an additional aid,
X.I sanity checking
Xis available.  This means that if you mark too many adjacent squares as being
Xeither safe or unsafe, then you will be warned.  Since, such "insane" marking
Xis the cause of many undesired explosions (especially after you have been
Xplaying for a while, and fatigue makes counting become difficult), there is a
X1% point penalty for using sanity checking on a particular level.
X.LP
X.I Automarking
Xis a feature that automatically marks all eight adjacent squares as safe if
Xthere are no bombs in those adjacent squares.  This feature has been extended
Xto be recursive (ie. if appropriate, automarking will be performed on any of
Xthe eight squares that have been marked as safe).  The 
X.I extended automarking
Xis only available starting with the level of lieutenant (otherwise, on the
Xgrunt level, the complete path from start to finish would usually be shown).
XDuring extended automarking, if any squares are found to be free of surrounding
Xbombs, then it will be shaded to mark it as though you had already traversed
Xthat square.  This will allow you to immediately skip to the "frontier" on the
Xextended automarking.  By pressing the space bar, "automarking" can be forced.
XHowever, if you do this, no check is performed to make sure that there are no
Xadjacent bombs; thus, squares could be incorrectly marked.  Extended
Xautomarking is disabled for space-bar-forced automarking.  There is a 10% point
Xpenalty for each level on which you use extended automarking.
X.LP
XYou are also given three 
X.I grenades 
Xwith which you can blow up bombs.  These grenades can only be thrown a distance
Xof five squares (count off the five squares by counting the number of
Xhorizontal and vertical moves you would have to make to go to that square).
XAgain, there is a possible chain reaction of explosions, and if you happen to
Xbe next to a square that explodes, then you will also explode.  When you
Xexplode and die, a tombstone is placed on that square, and you can no longer
Xenter that square.  There is always a guaranteed safe path from start to goal.
XThis means that it is always possible to reach the goal without removing any
Xbombs from the field by exploding them.
X.LP
XWhen you reach the goal safely (ie. with at least one life left), then you will
Xreceive points based on the time you have left, the number of bombs left
Xunexploded, the number of grenades left, the number of times you died, and
Xwhether or not you used sanity checking or extended automarking.  If your
Xcurrent rank is at least lieutenant and your current score is at least 3000,
Xthen you will receive an extra life and an extra grenade (you can have at most
Xthree grenades at the start of any level).  Also, when you reach the goal, all
Xhidden bombs will be shown.  If you have marked any squares incorrectly, then
Xthose squares will be highlighted.
X.LP
XOnce you attain the rank of angel and reach the goal as a angel, you are
Xpromoted to the rank of god, and the game ends.  Also, if you run out of time
Xor lives, the game ends.  A high scores list is implemented and is shown and
Xupdated at the end of every game.  Since very high scores can be attained by
Xsimply starting out at the angel level, a maximum of five high scores from the
Xangel starting level are permitted.  To quit the game, you must explicitly quit
X(ie. you must either click on the
X.I Quit
Xbutton or hit 'q' or 'Q').  Otherwise, you will be allowed to continue moving
Xaround on the field, being able to blow up bombs and yourself and being able to
Xthrow any remaining grenades.  The timer will stop, and you will not be able to
Xadvance to the next level or gain points.  The reason for allowing this is to
Xpermit you to analyze your position once the game ends.
X.LP
XBelow the field is a set of windows with information.
XThe topmost window below the field is the status window.  Error messages and
Xmore importantly, adjacent bomb information will be given here.  If you require
Xthe adjacent bomb information without moving, click on your current position.
X.LP
X.TP 8
XThe second row of windows contain the following info:
X.RS
X.PD 0
X.TP 18
X.I Bombs:
Xwill decrease when bombs on the field are exploded.
X.TP
X.I Bonus:
Xhow many points you would earn if you were to reach the goal at that specific
Xtime.
X.TP
X.I Time:
Xtime left before the game is over.
X.TP
X.I Score:
Xhow many points accumulated so far; points are only awarded upon reaching the
Xgoal.
X.TP
X.I Grenades:
Xhow many grenades are left.
X.TP
X.I Rank:
Xcurrent rank (determines number of bombs at start and starting time).
X.TP
X.I Lives:
Xhow many lives remaining (including the current one).  (This window is actually
Xin the third row.)
X.RE
X.PD
X.LP
XThe third row of window contain the contain buttons (which you can click on):
X.LP
X.TP 18
X.I Automark = on/off
Xtoggles automark on and off.  Automarking means that if the check for adjacent
Xbombs reveals no bombs, then all adjacent squares that can be marked as safe
Xwill be marked as safe.  This is a time-saving feature for fields with few
Xbombs.  Since most of the time, there will be no hidden bombs in adjacent
Xsquares, you will want to mark all adjacent squares as safe.  With automark=on,
Xthis will be automatically done for you.  You can force marking of all adjacent
Xsquares as safe by pressing the spacebar.  This will work regardless of what
Xautomark is set to.  If a square is already marked as dangerous, then it will
Xremain marked as dangerous.
X.TP
X.I Surrender
Xgive up on current game.  All hidden bombs will be shown.  You will be able to
Xmove around, blow up, and throw grenades, but you not cannot increase your
Xscore anymore.
X.TP
X.I Throw Grenade
Xclick to throw a grenade, and then click on the square you wish to throw the
Xgrenade on.  There is a maximum distance to the throw.  This distance is
Xcomputed by adding the minimum number of moves you would have to make to reach
Xthat square.  The current maximum throw distance is five squares.  If you
Xthrow a grenade on an empty square, any bombs (or people) on adjacent squares
Xwill also explode.
X.TP
X.I Show=?
X? will either be
X.I man
Xor
X.I fig.
XIf Show=man, then the man bitmap will be used at the current position;  if
XShow=fig, then the number of adjacent bombs will be shown at the current
Xposition.  
X.TP
X.I Quit
Xself-explanatory.  You can click here at just about any time.
X.LP
XThe fourth row of window contain the contain buttons (which you can click on):
X.LP
X.TP 18
X.I Refresh
Xforce a refresh of all windows.  This shouldn't be necessary, as most refreshes
Xshould be performed automatically.
X.TP
X.I ExtAmark
XIf ExtAmark=on, then extended automarking as described above will be
Xperformed.  You must have automark=on and be ranked at least as a lieutenant.
XSince there is a point penalty for using extended automarking on each level, if
Xyou have already used extended automarking on the current level, then an
Xasterisk will be shown after the =.  If you have already used extended
Xautomarking on a particular level, and you do not wish to use it for the next
Xlevel, make sure you turn it off before you reach the goal;  otherwise, you
Xwill still be penalized for it because you will start out using extended
Xautomarking.
X.TP
X.I Sanity
XIf Sanity=on, then sanity checking as described above is enabled.  As with
Xextended automarking, because there is a point penalty for using sanity
Xchecking, the asterisk notation is used to indicate the use of this option on
Xthe current level.  To use sanity checking you must have automark=on and be
Xranked at least as a lieutenant.
X.TP
X.I Pause/Continue
XClick on this button to pause the game (the button will then be relabeled as
XContinue).  Click on it again to continue.  During the pause, the field will be
Xcleared and the clock will be stopped.  You can also use the 'p' or 'P' keys to
Xpause and the 'c' or 'C' keys to continue.
X.RE
X.PD
X.LP
X.TP 8
XIn the field window, the following keystrokes are recognized:
X.RS
X.PD 0
X.TP 18
X.B spacebar
Xmark all surrounding squares as safe unless already marked as unsafe.  This is
Xsimilar to the automark feature, but is not automatic.  This option will
Xusually be used when you believe you have already marked all the surrounding
Xdangerous squares, and you wish to mark the remaining ones as safe.  Only the
Ximmediately surrounding squares are marked;  extended automarking is not
Xperformed.
X.TP
X.B p or P
Xpause the game.  The field will be cleared, and the clock will be stopped.  You
Xcan also click on the Pause button.
X.B c or C
Xcontinue the game after it has been paused.  You can also click on the Continue
Xbutton.
X.TP
X.B q or Q
Xquit the game.  Same as clicking on the
X.I Quit
Xbutton.
X.TP
X.B control-l
Xperform a screen refresh.
X.RE
X.PD
X.LP
X.TP 8
XIn the field window, the mouse buttons have these meanings:
X.RS
X.PD 0
X.TP 18
X.B left button
Xmoves the man to that square.  You can only move one square at a time.  You
Xcannot move to a tombstone.  When you leave a square, it is shaded to mark
Xwhere you have already been.  You can always move to any square that you have
Xalready been at, regardless of the distance.
X.TP
X.B middle button
Xwill toggle the "bomb present" marking.  This is useful as a memory aid when
Xyou believe you know where a bomb already is.  You will not be allowed to move
Xonto this square until you turn of the "bomb present" marking.
X.TP
X.B right button
Xwill toggle the "safe" marking.  Again, this is a memory aid to help you keep
Xtrack of what squares you have already determined to be safe.  Keep in mind
Xthat this designation may be erroneous.
X.br
X.ne 8
X.PD
X.SH OPTIONS
X.PD
X.LP
X.TP
X.B -s
Xshow high scores list and exit
X.TP
X.BI \-l r
Xstart at level
X.I r
X, which must be an integer from 0(grunt) to 9(angel).  The highest rank is god.
XHowever, being an xtmines god is something you have to work at.  Therefore, the
Xhighest rank you can start out at is angel.
X.SH BUGS
X.LP
XThe high scores file is not secure the way it is created.  If you don't have
Xroot privileges, you should set the set-user-id bit for the xtmines executable
Xfile by using "chmod u+s xtmines.hiscores" (without the quotes, of course).  If
Xyou do have root permissions, then you should probably place the executable in
Xthe games directory and the high scores file in the games/lib directory.  The
Xgroup for the executable should be games, and the set-group-id bit should be
Xset.
X.LP
XPlease report bugs to ttsai@uiuc.edu (Timothy Tsai).
X.SH ACKNOWLDGEMENTS
X.LP
XThe idea for xtmines came from the UNIX PC game called mines.  The high scores
Xlist functions are pretty much those used by Wayne A. Christopher in his
Xtetris game.  Thanks are also due Benjamin Tsai and Dane Dwyer for their
Xsuggestions and time spent testing out the program.
END_OF_FILE
if test 12485 -ne `wc -c <'xtmines.man'`; then
    echo shar: \"'xtmines.man'\" unpacked with wrong size!
fi
# end of 'xtmines.man'
fi
echo shar: End of archive 2 \(of 2\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM            | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly!      |
 "It's intuitively obvious to the most |    sources-x@imd.sterling.com
  casual observer..."                  |
