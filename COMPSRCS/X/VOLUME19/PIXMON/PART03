Newsgroups: comp.sources.x
From: sprave@gonzo.informatik.uni-dortmund.de (Joachim Sprave)
Subject: v19i052:  pixmon - a pixel graphics backend, Part03/03
Message-ID: <1993Mar25.151545.14951@sparky.imd.sterling.com>
X-Md4-Signature: 6318a686aad3808a2efa278ec526e7d8
Date: Thu, 25 Mar 1993 15:15:45 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: sprave@gonzo.informatik.uni-dortmund.de (Joachim Sprave)
Posting-number: Volume 19, Issue 52
Archive-name: pixmon/part03
Environment: X11, gcc

#!/bin/sh
# this is pixmon.03 (part 3 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file pixmon-0.3/COPYING continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 3; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping pixmon-0.3/COPYING'
else
echo 'x - continuing file pixmon-0.3/COPYING'
sed 's/^X//' << 'SHAR_EOF' >> 'pixmon-0.3/COPYING' &&
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.
X
Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.
X
In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.
X
X  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:
X
X    a) Accompany it with the complete corresponding machine-readable
X    source code, which must be distributed under the terms of Sections
X    1 and 2 above on a medium customarily used for software interchange; or,
X
X    b) Accompany it with a written offer, valid for at least three
X    years, to give any third party, for a charge no more than your
X    cost of physically performing source distribution, a complete
X    machine-readable copy of the corresponding source code, to be
X    distributed under the terms of Sections 1 and 2 above on a medium
X    customarily used for software interchange; or,
X
X    c) Accompany it with the information you received as to the offer
X    to distribute corresponding source code.  (This alternative is
X    allowed only for noncommercial distribution and only if you
X    received the program in object code or executable form with such
X    an offer, in accord with Subsection b above.)
X
The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.
X
If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.
X
X  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.
X
X  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.
X
X  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.
X
X  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.
X
If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.
X
It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.
X
This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.
X
X  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.
X
X  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.
X
Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.
X
X  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.
X
X			    NO WARRANTY
X
X  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.
X
X  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.
X
X		     END OF TERMS AND CONDITIONS
X
X	Appendix: How to Apply These Terms to Your New Programs
X
X  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.
X
X  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.
X
X    <one line to give the program's name and a brief idea of what it does.>
X    Copyright (C) 19yy  <name of author>
X
X    This program is free software; you can redistribute it and/or modify
X    it under the terms of the GNU General Public License as published by
X    the Free Software Foundation; either version 2 of the License, or
X    (at your option) any later version.
X
X    This program is distributed in the hope that it will be useful,
X    but WITHOUT ANY WARRANTY; without even the implied warranty of
X    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X    GNU General Public License for more details.
X
X    You should have received a copy of the GNU General Public License
X    along with this program; if not, write to the Free Software
X    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
Also add information on how to contact you by electronic and paper mail.
X
If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:
X
X    Gnomovision version 69, Copyright (C) 19yy name of author
X    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
X    This is free software, and you are welcome to redistribute it
X    under certain conditions; type `show c' for details.
X
The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.
X
You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:
X
X  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
X  `Gnomovision' (which makes passes at compilers) written by James Hacker.
X
X  <signature of Ty Coon>, 1 April 1989
X  Ty Coon, President of Vice
X
This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Library General
Public License instead of this License.
SHAR_EOF
echo 'File pixmon-0.3/COPYING is complete' &&
chmod 0640 pixmon-0.3/COPYING ||
echo 'restore of pixmon-0.3/COPYING failed'
Wc_c="`wc -c < 'pixmon-0.3/COPYING'`"
test 17982 -eq "$Wc_c" ||
	echo 'pixmon-0.3/COPYING: original size 17982, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= pixmon-0.3/pixmon.1 ==============
if test -f 'pixmon-0.3/pixmon.1' -a X"$1" != X"-c"; then
	echo 'x - skipping pixmon-0.3/pixmon.1 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting pixmon-0.3/pixmon.1 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pixmon-0.3/pixmon.1' &&
.\" $Id$
.TH PIXMON 1 "16 March 1993" "Version 0.3"
.ta 0.5i +0.5i +0.5i +0.5i +0.5i +0.5i +0.5i +0.5i +0.5i +0.5i +0.5i +0.5i +0.5i +0.5i +0.5i
X
\" this noise gets my name right!
.nr 99 \n(.s
.nr 98 \n(.f
.ds 11 "\fRo
.nr 11 \w'\s10\*(11'
.nr 10 0u
.if \n(ct>1 .nr 10 \n(10+\s10.25m\s0
.nr 13 \s10.1m\s0
.if \n(ct>1 .nr 13 \s10.15m\s0
.ds 12 \s10\v'-.67m'..\v'.67m\s0'
.nr 12 \w'\s10\*(12'
.as 11 \h'-\n(11u-\n(12u/2u+\n(13u'\v'0-\n(10u'\*(12\v'\n(10u'\h'-\n(12u+\n(11u/2u-\n(13u'
.ds o \x'0'\f1\s10\*(11\s\n(99\f\n(98
X
.SH NAME
.B pixmon
\- a simple pixel monitor for X11
X
.SH SYNOPSIS
.LP
.B pixmon
[
.I -Xt-options ...
]
[
.I -options ...
]
.TP
X        [\fB-dx \fI<pixel-data-size>\fR]
.TP
X        [\fB-dy \fI<pixel-data-size>\fR]
.TP
X        [\fB-width \fI<window-size>\fR]
.TP
X        [\fB-height \fI<window-size>\fR]
.TP
X        [\fB-scale \fI<float-value>\fR]
.TP
X        [\fB-cmap \fI<filename>[.cmap]\fR]
.TP
X        [\fB-dither\fR]
X
.SH DESCRIPTION
.B pixmon
implements a simple 
.I pixel data monitor
for use with the
.I X11
window system. It comes with the following features:
.TP \w'\(bu'u+2n
\(bu
Auto-rescale when changing the window size
.TP
\(bu
Loadable colormaps, you can display the same data with
different colors
.TP
\(bu
Autodetect mono servers, using dithering
.I (ordered dither)
instead of colors
.TP
\(bu
Run length encoding support.
X
.SH OPTIONS
.TP
.B \-dx \fIpixel-data-size\fR
Set the horizontal size of expected
.I pixel data image.
(Defaults to \fI100\fR.)
.TP
.B \-dy \fIpixel-data-size\fR
Set the vertical size of expected
.I pixel data image.
(Defaults to \fI100\fR.)
.TP
.B \-width \fIwindow-size\fR
Set the horizontal size of
.I pixmon
window in screen coordinates
(Defaults to \fIdx * scale\fR.)
.TP
.B \-height \fIwindow-size\fR
Set the vertical size of
.I pixmon
window in screen coordinates
(Defaults to \fIdy * scale\fR.)
.TP
.B \-scale \fIfloat-value\fR
Scale the window's size to
.I width = dx * float-value
and
.I height = dy * float-value
(Defaults to \fI2\fR.)
.TP
.B \-cmap \fIfilename[.cmap]\fR
Read in \fIfilename[.cmap]\fR on program start, and use the
colors when generating the pixmaps. The use of the
suffix `.cmap' is encouraged, but not enforced.
.TP
.B \-dither
Use an
.I ordered dither
for pseudo color representation on low bitplane devices,
eg.
.I monochrome
XX servers.
when used on a color device, a two color dithering generates
some interesting effects.
.PP
The following standard X Toolkit command line arguments are commonly used 
with
.BR pixmon :
.TP
.B \-bg \fIcolor\fP
This option specifies the color to use for the background of the window.  
The default is ``white.''
.TP
.B \-bd \fIcolor\fP
This option specifies the color to use for the border of the window.
The default is ``black.''
.TP
.B \-bw \fInumber\fP
This option specifies the width in pixels of the border surrounding the window.
.TP
.B \-fg \fIcolor\fP
This option specifies the color to use for displaying pixels.  The default is 
``black.''
.TP
.B \-name \fIname\fP
This option specifies the application name under which resources are to be
obtained, rather than the default executable file name.
\fIName\fP should not contain ``.'' or ``*'' characters. (Defaults to
.B ``PixMon.'')
.TP
.B \-title \fIstring\fP
This option specifies the window title string, which may be displayed by
window managers if the user so chooses.  The default title is `pixmon'.
.TP
.B \-rv
This option indicates that reverse video should be simulated by swapping
the foreground and background colors.
.TP
.B \-geometry \fIgeometry\fP
This option specifies the preferred size and position of the
.B pixmon window;
see \fIX(1)\fP.
.TP
.B \-display \fIdisplay\fP
This option specifies the X server to contact; see \fIX(1)\fP.
.TP
.B \-xrm \fIresourcestring\fP
This option specifies a resource string to be used.  This is especially
useful for setting resources that do not have separate command line options.
.TP
.B \-iconic
This option indicates that
.B pixmon
should ask the window manager to 
start it as an icon rather than as the normal window.
X
.SH OPTION SUMMARY
To give no option at all is the same as to give the following options:
.TP
-dx 100 -dy 100 -scale 2 -cmap default.cmap
X
.SH FORMATS
.TP \w'\(bu'u+2n
\(bu
.I Color map file(s), recognised by
.B pixmon
have the following
.SM ASCII
layout:
.LP
.nf
.DT
.ft B
X	# 	File:		demo.map
X	#	Creator:	Joachim Sprave (sprave@gonzo)
X	# <- this is a comment line: '#' in the 1st column
X	<red intensity 0>	<green intensity 0>	<blue intensity 0>
X	<red intensity 1>	<green intensity 1>	<blue intensity 1>
X	<red intensity 2>	<green intensity 2>	<blue intensity 2>
X				\&.\&.\&.
X	<red intensity 255>	<green intensity 255>	<blue intensity 255>
.ft R
.fi
X
Thus a color map file consist of 256 lines each one containing such a
color description. Eg. to get a greyscale `color' map, simply
use the same intensities for all colors (see
.SM EXAMPLES
below).
.TP \w'\(bu'u+2n
\(bu
A package header is defined as:
.LP
.nf
.DT
.ft B
X	typedef struct {
X		unsigned short	magic;
X		unsigned short	type;
X		short		x;
X		short		y;
X		unsigned short	dx;
X		unsigned short	dy;
X		unsigned short	sizelo;
X		unsigned short	sizehi;
X	} ImgHdr;
.ft R
.fi
X
With the following semantics:
.TP
.I magic
used to determine byte sex, must
be initialized to PIX_MAGIC
.TP
.I type
one of:
.RS
.TP
.SM PIX_DATA
Include the pixel data following 
the header into the picture 
(without displaying instantly).
.TP
.SM PIX_FLUSH
Display the internal pixmap.
.TP
.SM PIX_DATA | PIX_FLUSH
Include the pixel data following 
the header into the picture 
and display it instantly.
.TP
.SM PIX_KILL
Tells
.B pixmon
to exit, when button 1 is pressed.
.RE
.TP
.I x, y
Position of this package relative to
the upper-left corner of the window.
.TP
.I dx, dy
Width and height (in dots, not in pixels)
of this package.
.TP
.I sizelo, sizehi			
Size of the following pixel data. If
.I sizehi * 0x10000 + sizelo
.I < dx * dy,
.B pixmon
expects run length encoded data.
X
.SH ENCODING
If
.SM RUN LENGTH ENCODING (RLE)
is detected (see above), the value
.BR PIX_RLE (0xFF)
is treated as an escape value,
so the number of colors is reduced by one.
To encode your data, use the function
.B rle_encode
from
.I rle.c.
X
.SH EXAMPLES
.TP \w'\(bu'u+2n
\(bu
A
.I greyscale
color map looks like:
.LP
.nf
.DT
.ft R
X	0	0	0
X	1	1	1
X	2	2	2
X	3	3	3
X		\&.\&.\&.
X	255	255	255
.fi
.TP \w'\(bu'u+2n
\(bu
To use run length encoding of your pixel data, write:
.LP
.nf
.DT
.ft B
X	my_encode ()
X	{
X		char mybuffer[MBSIZE];
X		\&.\&.\&.
X		rle_encode (mybuffer, MBSIZE, PIX_RLE);
X		\&.\&.\&.
X	}
.ft R
.fi
X
.SH FILES
.LP
.nf
.DT
.ft R
pixmon/default.cmap		\fIdefault color map\fR
pixmon/cmaps/*.cmap		\fIexample color maps\fR
X
pixmon/examples/README	\fIguiding instructions\fR
pixmon/examples/mbx		\fIshell script that runs mbs\fR
pixmon/examples/mbs.c		\fIgenerates a mandelbrot set\fR
pixmon/examples/showpal.c	\fIgenerates a color palette\fR
.ft R
.fi
X
.SH ANIMATION
An animation companion to
.B pixmon
called
.BR playmate (1)
is also in the making, and will be distributed in near future
(refer to the
.SM AVAILABILITY
section below).
Its application is rather simple: all there is to do is to
include a ``tee-log'' in the `pixel generating pipe' eg.:
.PP
.RS
.I example%
.B mbs ... | tee >pmdata.pix
.B | pixmon ...
.RE
.PP
to collect
.B pixmon
data, that is later turned into animated pixmaps by
.BR playmate (1).
(See the
.B pixmon/examples
folder for more.)
X
.SH BUGS
The known `bugs' of
.B pixmon
are:
.TP \w'\(bu'u+2n
\(bu
`No' interaction
.TP
\(bu
Could be faster
.TP
\(bu
No private color maps
.TP
\(bu
My first
.I X11
program, ugly code :-(
X
.SH SEE ALSO
.BR X (1),
.BR hodge (1),
.BR imagemagick (1),
.BR playmate (1)
X
.SH AUTHOR
Copyright 
.if t \(co 
.if n (C)
1992, 1993 by
.if n Joachim Sprave
.if t Joachim Sprave
.nf
Systems Analysis Group, University of Dortmund, Germany.
.nf
Send bugs, comments, etc., to (sprave@ls11.informatik.uni-dortmund.de).
.fi
X
.SH CREDITS
.if n Joerg Heitkoetter
.if t J\*org Heitk\*otter
(joke@ls11.informatik.uni-dortmund.de) wrote the manual page.
.fi
X
.SH AVAILABILITY
.LP
This work is protected by the terms of the
.SM GNU
General Public License. Please refer to the
.SM COPYING
file accompanying the sources of this software package for a lengthy, boring,
but absolute complete description.
X
.SM PIXMON
is available via anonymous ftp from the group's server
.B lumpi.informatik.uni-dortmunde.de
(129.217.36.140)
as file `pixmon-0.3.tar.Z' in /pub/CA/src.
X
.SH WARRANTY
.LP
This program is free software; you can redistribute it and/or modify
it under the terms of the
.SM GNU
General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
X
This program is distributed in the hope that it will be useful,
but
.SM WITHOUT ANY WARRANTY;
without even the implied warranty of
.SM MERCHANTABILITY
or
.SM FITNESS FOR A PARTICULAR PURPOSE.
See the
.SM GNU
General Public License for more details.
X
You should have received a copy of the
.SM GNU
General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
SHAR_EOF
chmod 0600 pixmon-0.3/pixmon.1 ||
echo 'restore of pixmon-0.3/pixmon.1 failed'
Wc_c="`wc -c < 'pixmon-0.3/pixmon.1'`"
test 9181 -eq "$Wc_c" ||
	echo 'pixmon-0.3/pixmon.1: original size 9181, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= pixmon-0.3/rle.kr.c ==============
if test -f 'pixmon-0.3/rle.kr.c' -a X"$1" != X"-c"; then
	echo 'x - skipping pixmon-0.3/rle.kr.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting pixmon-0.3/rle.kr.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pixmon-0.3/rle.kr.c' &&
#include <stdlib.h>
#include "rle.h"
X
static unsigned char *rl_src_buffer;
static unsigned char rl_escape;
static unsigned long rl_src;
static unsigned long rl_src_size;
static unsigned long rl_count;
static unsigned char rl_current;
X
X
#define COUNT_MAX	0x10000
#define LO(k)		((k) & (unsigned long)0xFF)
#define HI(k)		(((k) & (unsigned long)0xFF00)>>8)
#define UNLO(c)		(c)
#define UNHI(c)		((c) << 8)
X
X
X
/*
X *	RL-encode a buffer in-place
X *	returns:	no. of bytes after encoding
X */
unsigned long
rl_encode(buffer, size, escape)
unsigned char *buffer;		/* data to encode			*/
unsigned long size;		/* no. of bytes in buffer		*/
unsigned char escape;		/* esc. byte preceding a count		*/
{
X    unsigned long src, dst;
X    unsigned long count;
X    unsigned char current;
X
X    src = dst = 0;
X    while (src < size) {
X	count = 1;
X	current = buffer[src];
X	while (++src < size && buffer[src] == current && count < COUNT_MAX)
X	    count++;
X	if (count > 3 || current == escape) {
X	    buffer[dst++] = escape;
X	    buffer[dst++] = (char) LO(count);
X	    buffer[dst++] = (char) HI(count);
X	    buffer[dst++] = current;
X	}
X	else {
X	    while (count--)
X		buffer[dst++] = current;
X	}
X    }
X    return dst;
}
X
/*
X *	RL-decode a buffer into another one
X *	returns:	no. of bytes after decoding
X *
X *	Caution: dst_buffer must be large enough to
X *	         hold the decoded data
X */
unsigned long
rl_decode(src_buffer, dst_buffer, src_size, escape)
unsigned char *src_buffer;	/* source buffer	*/
unsigned char *dst_buffer;	/* destination buffer	*/
unsigned long src_size;		/* no. of encoded bytes	*/
unsigned char escape;		/* escape code		*/
{
X    unsigned long src, dst;
X    unsigned long count;
X    unsigned char current;
X
X    src = dst = 0;
X    while (src < src_size) {
X	if (src_buffer[src] == escape) {
X	    src++;
X	    count = UNLO(src_buffer[src++]);
X	    count |= UNHI(src_buffer[src++]);
X	    current = src_buffer[src++];
X	    while (count--)
X		dst_buffer[dst++] = current;
X	}
X	else {
X	    dst_buffer[dst++] = src_buffer[src++];
X	}
X    }
X    return dst;
}
X
/*
X *	Determine the size needed for decoding
X */
unsigned long
rl_decode_length(src_buffer, src_size, escape)
unsigned char *src_buffer;	/* buffer		*/
unsigned long src_size;		/* size encoded		*/
unsigned char escape;		/* escape code		*/
{
X    unsigned long src, dst;
X    unsigned long count;
X
X    src = dst = 0;
X    while (src < src_size) {
X	if (src_buffer[src] == escape) {
X	    src++;
X	    count = UNLO(src_buffer[src++]);
X	    count |= UNHI(src_buffer[src++]);
X	    src++;
X	    dst += count;
X	}
X	else {
X	    src++;
X	    dst++;
X	}
X    }
X    return (dst);
}				/* end rl_decode_length */
X
X
/*
X *	To avoid needing a buffer to hold the entire
X *	decoded data, buffers can be decoded in pieces
X */
X
/*
X *	Initialize for decoding in pieces
X */
void
rl_decode_init(src_buffer, src_size, escape)
unsigned char *src_buffer;	/* buffer		*/
unsigned long src_size;		/* size encoded		*/
unsigned char escape;		/* esc. code		*/
{
X    rl_src_buffer = src_buffer;
X    rl_src_size = src_size;
X    rl_escape = escape;
X    rl_src = (unsigned long)0;
X    rl_count = (unsigned long)0;
}
X
X
/*
X *	Decode the next dst_size bytes from the buffer
X *	initialized before. If dst_buffer is NULL, dst_size
X *	bytes are skipped.
X *	returns:	no. of bytes written to dst_buffer
X */
X
unsigned long
rl_decode_next(dst_buffer, dst_size)
unsigned char *dst_buffer;	/* destination buffer	*/
unsigned long dst_size;		/* no. bytes to decode	*/
{
X    unsigned long dst;
X
X    dst = 0;
X    while (rl_src <= rl_src_size && dst < dst_size) {
X	while (rl_count && dst < dst_size) {
X	    if (dst_buffer != (unsigned char *) 0)	/* skip */
X		dst_buffer[dst] = rl_current;
X	    dst++;
X	    rl_count--;
X	}
X	if (rl_count == 0) {
X	    if (rl_src_buffer[rl_src] == rl_escape) {
X		rl_src++;
X		rl_count  = UNLO(rl_src_buffer[rl_src++]);
X		rl_count |= UNHI(rl_src_buffer[rl_src++]);
X	    }
X	    else {
X		rl_count = 1;
X	    }
X	    rl_current = rl_src_buffer[rl_src++];
X	}
X    }
X    return dst;
}
SHAR_EOF
chmod 0640 pixmon-0.3/rle.kr.c ||
echo 'restore of pixmon-0.3/rle.kr.c failed'
Wc_c="`wc -c < 'pixmon-0.3/rle.kr.c'`"
test 3989 -eq "$Wc_c" ||
	echo 'pixmon-0.3/rle.kr.c: original size 3989, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= pixmon-0.3/README.rle ==============
if test -f 'pixmon-0.3/README.rle' -a X"$1" != X"-c"; then
	echo 'x - skipping pixmon-0.3/README.rle (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting pixmon-0.3/README.rle (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pixmon-0.3/README.rle' &&
X
This small RLE-package has been written for pixmon. It is more
or less ANSI-C. If your compiler is not ANSI, type
X
X	mv rle.c rle.ansi.c
X	mv rle.kr.c rle.c
X
and try again.
SHAR_EOF
chmod 0640 pixmon-0.3/README.rle ||
echo 'restore of pixmon-0.3/README.rle failed'
Wc_c="`wc -c < 'pixmon-0.3/README.rle'`"
test 172 -eq "$Wc_c" ||
	echo 'pixmon-0.3/README.rle: original size 172, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= pixmon-0.3/pixmon.c ==============
if test -f 'pixmon-0.3/pixmon.c' -a X"$1" != X"-c"; then
	echo 'x - skipping pixmon-0.3/pixmon.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting pixmon-0.3/pixmon.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pixmon-0.3/pixmon.c' &&
/*
X *	pixmon - a PIXel oriented graphics MONitor
X *	(c) Joachim Sprave 1992
X */
X
/*
X *	C-lib headers
X */
#include <stdio.h>
#include <stdlib.h>
X
/*
X *	Various X headers
X */
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Xos.h>
#include <X11/cursorfont.h>
#include <X11/Xutil.h>
X
/*
X *	Application headers
X */
#include "pixmon.h"
#include "defcmap.h"
#include "dither.h"
#include "rle.h"
X
void get_coor();
void get_colors();
void repaint();
void mapped();
void mouseinput();
void flushMap();
void dots2map();
X
/*
X *	Some X macros
X */
#define APPNAME			"pixmon"
#define APPCLASS		"PixMon"
X
/*
X *	Maximum number of colors used by PixMon
X */
#define MAX_COLORS		256
X
/*
X *	Scaling macros
X */ 
#define X_OM2WI(x)	((int)((x)*MyData.Xfactor+0.99))
#define Y_OM2WI(y)	((int)((y)*MyData.Yfactor+0.99))
#define X_WI2OM(x)	((int)((x)/MyData.Xfactor+0.5))
#define Y_WI2OM(y)	((int)((y)/MyData.Yfactor+0.5))
X
#define MIN(a,b)	((a)<(b)?(a):(b))
#define MAX(a,b)	((a)<(b)?(b):(a))
X
X
typedef struct {
X
X	  int Om_width;
X	  int Om_height;
X	  int Wi_width;
X	  int Wi_height;
X	  int Wi_xpos;
X	  int Wi_ypos;
X	  float Scale;
X	  float Xfactor;
X	  float Yfactor;
X	  char *Colormap;
X	  Boolean Dither;
X	  char *Butrep;
X	  Pixel Fg, Bg;
X	  char *Progname;
X  }
ApplData;
typedef ApplData *ApplDataPtr;
X
/*
X *	Default values
X */
static int def_wi_width = 0;
static int def_wi_height = 0;
static int def_wi_xpos = 10;
static int def_wi_ypos = 10;
static int def_om_width = 100;
static int def_om_height = 100;
static float def_scale = 2.0;
static int no_of_colors = 2;
X
/*
X *	Global definitions
X */
static Pixmap stipple[N_PAT];
static Pixmap MyMap;
static unsigned long pixels[MAX_COLORS];
static Colormap cmap;
X
static int nargs;
static Arg wargs[32];
static Cursor WorkingCursor;
static Display *dpy;
static Window win;
static GC gc;
static GC cleargc;
X
static int isMapped = 0;
static int Ready2Exit = 0;
X
static Widget toplevel;
static Widget w;
X
/*
X *	buffer to hold the original dotmap
X */
static unsigned char *dotbuf;
X
/*
X *	buffer to read incoming packages
X */
static unsigned char *inpbuf;
X
/*
X * Application Data
X */
static ApplData MyData;
X
static IMGHDR fullhdr;
X
static XtResource application_resources[] =
{
X	{"name", "Name", XtRString, sizeof(char *),
X	 XtOffset(ApplDataPtr, Progname), XtRString, APPNAME},
X	{"width", "Width", XtRInt, sizeof(int),
X	 XtOffset(ApplDataPtr, Wi_width), XtRInt, (caddr_t) & def_wi_width},
X	{"height", "Height", XtRInt, sizeof(int),
X       XtOffset(ApplDataPtr, Wi_height), XtRInt, (caddr_t) & def_wi_height},
X	{"xpos", "Xpos", XtRInt, sizeof(int),
X	 XtOffset(ApplDataPtr, Wi_xpos), XtRInt, (caddr_t) & def_wi_xpos},
X	{"ypos", "Ypos", XtRInt, sizeof(int),
X	 XtOffset(ApplDataPtr, Wi_ypos), XtRInt, (caddr_t) & def_wi_ypos},
X	{"scale", "Scale", XtRFloat, sizeof(float),
X	 XtOffset(ApplDataPtr, Scale), XtRFloat, (caddr_t) & def_scale},
X	{"dx", "DeltaX", XtRInt, sizeof(int),
X	 XtOffset(ApplDataPtr, Om_width), XtRInt, (caddr_t) & def_om_width},
X	{"dy", "DeltaY", XtRInt, sizeof(int),
X       XtOffset(ApplDataPtr, Om_height), XtRInt, (caddr_t) & def_om_height},
X	{"foreground", "Foreground", XtRPixel, sizeof(Pixel),
X	 XtOffset(ApplDataPtr, Fg), XtRString, (caddr_t) "Black"},
X	{"background", "Background", XtRPixel, sizeof(Pixel),
X	 XtOffset(ApplDataPtr, Bg), XtRString, (caddr_t) "White"},
X	{"cmap", "Cmap", XtRString, sizeof(char *),
X	 XtOffset(ApplDataPtr, Colormap), XtRString, (caddr_t) "default"},
X	{"dither", "Dither", XtRBoolean, sizeof(Boolean),
X	 XtOffset(ApplDataPtr, Dither), XtRString, (caddr_t) "False"},
X	{"butrep", "ButRep", XtRString, sizeof(char *),
X	 XtOffset(ApplDataPtr, Butrep), XtRString, (caddr_t) 0},
};
X
static XrmOptionDescRec optionDescList[] =
{
X	{"-width", "*width", XrmoptionSepArg, (caddr_t) & def_om_width},
X	{"-height", "*height", XrmoptionSepArg, (caddr_t) & def_om_height},
X	{"-scale", "*scale", XrmoptionSepArg, (caddr_t) & def_scale},
X	{"-fg", "*foreground", XrmoptionSepArg, (caddr_t) NULL},
X	{"-bg", "*background", XrmoptionSepArg, (caddr_t) NULL},
X	{"-dx", "*dx", XrmoptionSepArg, (caddr_t) & def_om_width},
X	{"-dy", "*dy", XrmoptionSepArg, (caddr_t) & def_om_height},
X	{"-x", "*x", XrmoptionSepArg, (caddr_t) & def_wi_xpos},
X	{"-y", "*y", XrmoptionSepArg, (caddr_t) & def_wi_ypos},
X	{"-cmap", "*cmap", XrmoptionSepArg, (caddr_t) "default"},
X	{"-dither", "*dither", XrmoptionNoArg, (caddr_t) "True"},
X	{"-butrep", "*butrep", XrmoptionSepArg, (caddr_t) NULL},
};
X
X
X
int main(argc, argv)
int argc;
char *argv[];
{
X	int i;
X	XGCValues gcv;
X
X	toplevel = XtInitialize(argv[0], APPCLASS,
X	      optionDescList, XtNumber(optionDescList), & argc,
X				argv);
X
X	XtGetApplicationResources(toplevel, &MyData, application_resources,
X	     XtNumber(application_resources), (ArgList) NULL, (Cardinal) 0);
X
X	if (argc != 1) {
X		(void) fprintf(stderr, "Usage: %s [Xt options]\n", argv[0]);
X		exit(1);
X	}
X	fullhdr.x = fullhdr.y = 0;
X	fullhdr.dx = MyData.Om_width;
X	fullhdr.dy = MyData.Om_height;
X
X	if (MyData.Wi_width == 0) {
X		MyData.Wi_width = MyData.Om_width * MyData.Scale;
X	}
X	if (MyData.Wi_height == 0) {
X		MyData.Wi_height = MyData.Om_height * MyData.Scale;
X	}
X	MyData.Xfactor = (float) MyData.Wi_width / MyData.Om_width;
X	MyData.Yfactor = (float) MyData.Wi_height / MyData.Om_height;
X
X	nargs = 0;
X	XtSetArg(wargs[nargs], XtNwidth, MyData.Wi_width ? MyData.Wi_width : MyData.Om_width);
X	nargs++;
X	XtSetArg(wargs[nargs], XtNheight, MyData.Wi_height ? MyData.Wi_height : MyData.Om_height);
X	nargs++;
X
X	w = XtCreateManagedWidget(argv[0], widgetClass, toplevel,
X				  wargs, XtNumber(wargs));
X
X	dotbuf = (unsigned char *) calloc(MyData.Om_width * MyData.Om_height, sizeof(char));
X	inpbuf = (unsigned char *) calloc(MyData.Om_width * MyData.Om_height, sizeof(char));
X
X	if (dotbuf == NULL || inpbuf == NULL) {
X		fprintf(stderr, "%s: cannot allocate enough memory...\n", MyData.Progname);
X		exit(1);
X	}
X
X	XtAddEventHandler(w, (EventMask) (StructureNotifyMask | ExposureMask), False,
X			  repaint, "repaint");
X	XtAddEventHandler(w, (EventMask) ButtonPressMask, False,
X			  mouseinput, "input_data");
X
X	XtAddInput(fileno(stdin), XtInputReadMask, get_coor, w);
X
X	XtRealizeWidget(toplevel);
X
X	win = XtWindow(w);
X	dpy = XtDisplay(w);
X	cmap = DefaultColormap(dpy, DefaultScreen(dpy));
X
X	MyMap = XCreatePixmap(dpy, win, MyData.Wi_width, MyData.Wi_height,
X			      DefaultDepthOfScreen(XtScreen(w)));
X
X	if (strcmp(MyData.Colormap, "raster") == 0) {
X		no_of_colors = 2;
X	} else {
X		no_of_colors = DisplayCells(dpy, DefaultScreen(dpy));
X	}
X
X	WorkingCursor = XCreateFontCursor(dpy, XC_top_left_arrow);
X	XDefineCursor(dpy, win, WorkingCursor);
X
X	gcv.foreground = MyData.Fg;
X	gcv.background = MyData.Bg;
X	gcv.function = GXcopy;
X	gc = XCreateGC(dpy, win, GCForeground | GCBackground
X		       | GCFunction, &gcv);
X	gcv.foreground = MyData.Bg;
X	cleargc = XCreateGC(dpy, win, GCForeground | GCBackground
X			    | GCFunction, &gcv);
X
X	if (MyData.Dither) {
X		no_of_colors = 2;
X	}
X	if (no_of_colors == 2) {
X		XSetFillStyle(dpy, gc, FillOpaqueStippled);
X		for (i = 0; i < N_PAT; i++) {
X			stipple[i] = XCreateBitmapFromData(
X						      dpy, win, fill_pat[i],
X						     PAT_WIDTH, PAT_HEIGHT);
X		}
X	} else {
X		if (no_of_colors > MAX_COLORS)
X			no_of_colors = MAX_COLORS;
X		get_colors();
X	}
X	dots2map(&fullhdr);
X	flushMap(&fullhdr);
X
X	XtMainLoop();
}
X
X
X
void
get_colors()
{
X	int color, r, g, b;
X	XColor xcolor;
X	char cmapfile[256];
X	char line[BUFSIZ];
X	FILE *f;
X
X	color = 0;
X	f = fopen(MyData.Colormap, "r");
X	if (f == NULL) {
X		sprintf(cmapfile, "%s.cmap", MyData.Colormap);
X		f = fopen(cmapfile, "r");
X	}
X	if (f != NULL) {
X		while (color < MAX_COLORS
X		       && fgets(line, BUFSIZ, f) != NULL) {
X			if (*line != '#' && sscanf(line, "%d %d %d", &r, &g, &b) == 3) {
X				rgb_default[color].red = r;
X				rgb_default[color].green = g;
X				rgb_default[color].blue = b;
X				color++;
X			}
X		}
X		fclose(f);
X	}
X	if (color < 256) {
X		fprintf(stderr, "Color map '%s' contains %d colors.\n", cmapfile, color);
X		fprintf(stderr, "PIXMON will use defaults for %d missing colors.\n", MAX_COLORS - color);
X	}
X	for (color = 0; color < MAX_COLORS; color++) {
X		xcolor.red	= rgb_default[color].red << 8;
X		xcolor.green	= rgb_default[color].green << 8;
X		xcolor.blue	= rgb_default[color].blue << 8;
X		xcolor.flags	= DoRed | DoGreen | DoBlue;
X		XAllocColor(dpy, cmap, &xcolor);
X		pixels[color]	= xcolor.pixel;
X	}
}
X
void
setdots(x, y, dx, color)
int x, y, dx;
unsigned char color;
{
X
X
X	if (no_of_colors > 2) {
X		color = color % MAX_COLORS;
X		XSetForeground(dpy, gc, pixels[color]);
X	} else {
X		color = color % N_PAT;
X		XSetStipple(dpy, gc, stipple[color]);
X	}
X	XFillRectangle(dpy, MyMap, gc,
X		       X_OM2WI(x), Y_OM2WI(y),
X		       X_OM2WI(dx), Y_OM2WI(1));
X
}
X
X
void
dots2map(hdrp)
IMGHDR *hdrp;
{
X	int x1, x, y, x2, y2;
X	unsigned char *p, color;
X
X	x2 = hdrp->x + hdrp->dx - 1;
X	y2 = hdrp->y + hdrp->dy - 1;
X	for (y = hdrp->y; y <= y2; y++) {
X		p = dotbuf + (y * MyData.Om_width);
X		x = hdrp->x;
X		while (x <= x2) {
X			x1 = x++;
X			color = p[x1];
X			while (x <= x2 && color == p[x])
X				x++;
X			setdots(x1, y, x - x1, color);
X		}
X	}
}
X
void
flushMap(hdrp)
IMGHDR *hdrp;
{
X	XCopyArea(dpy, MyMap, win, gc,
X		  X_OM2WI(hdrp->x), Y_OM2WI(hdrp->y),
X		  X_OM2WI(hdrp->dx), Y_OM2WI(hdrp->dy),
X		  X_OM2WI(hdrp->x), Y_OM2WI(hdrp->y));
X
}
X
X
unsigned short
swapbytes(x)
unsigned short x;
{
X	unsigned short ret;
X
X	ret = (x & 0x00FF) << 8;
X	ret = ret | ((x & 0xFF00) >> 8);
X	return ret;
}
X
X
void
get_coor(data, source, id)
caddr_t data;
int *source;
XXtInputId id;
{
X	int i;
X	unsigned short magic, cigam;
X	IMGHDR inp_hdr;
X	int inp_hdr_size;
X	int line;
X	int size;
X
X	unsigned char *dotptr, *inpptr;
X	static XtWidgetGeometry xtgeom;
X	static int dirty = 1;
X
X	i = 50;
X	magic = cigam = 0;
X	while (fread(&magic, 1, sizeof(magic), stdin) == sizeof(magic)
X	       && (magic != PIX_MAGIC && (cigam = swapbytes(magic)) != PIX_MAGIC) && --i);
X
X	if (magic != PIX_MAGIC && cigam != PIX_MAGIC)
X		return;
X
X	size = fread(&inp_hdr, 1, sizeof(IMGHDR), stdin);
X
X	if (cigam == PIX_MAGIC) {
X		inp_hdr.type = swapbytes(inp_hdr.type);
X		inp_hdr.x = swapbytes(inp_hdr.x);
X		inp_hdr.y = swapbytes(inp_hdr.y);
X		inp_hdr.dx = swapbytes(inp_hdr.dx);
X		inp_hdr.dy = swapbytes(inp_hdr.dy);
X		inp_hdr.sizelo = swapbytes(inp_hdr.sizelo);
X		inp_hdr.sizehi = swapbytes(inp_hdr.sizehi);
X	}
X	inp_hdr_size = (inp_hdr.sizehi << (sizeof(short) * 8)) | inp_hdr.sizelo;
X
X	if (size != sizeof(IMGHDR)) {
X		fprintf(stderr, "%s: incomplete header received\n", MyData.Progname);
X		return;
X	}
X	if (inp_hdr.type & PIX_KILL) {
X		Ready2Exit = 1;
X		return;
X	}
X	if (inp_hdr.type & PIX_DATA && inp_hdr.x + inp_hdr.dx > MyData.Om_width
X	    || inp_hdr.y + inp_hdr.dy > MyData.Om_height) {
X		fprintf(stderr, "%s: package doesn't fit --- ignored\n", MyData.Progname);
X		return;
X	}
X	/*
X	 * Read all color values
X	 */
X	if (inp_hdr.type & PIX_DATA) {
X		if (inp_hdr_size < inp_hdr.dx * inp_hdr.dy) {
X			fread(inpbuf, sizeof(char), inp_hdr_size, stdin);
X
X			rl_decode_init(inpbuf, inp_hdr_size, PIX_RLE);
X
X			dotptr = dotbuf + inp_hdr.y * MyData.Om_width + inp_hdr.x;
X			for (line = inp_hdr.y; line < inp_hdr.y + inp_hdr.dy; line++) {
X				rl_decode_next(dotptr, inp_hdr.dx);
X				dotptr += MyData.Om_width;
X			}
X		} else {
X			fread(inpbuf, sizeof(char), inp_hdr_size, stdin);
X
X			dotptr = dotbuf + inp_hdr.y * MyData.Om_width + inp_hdr.x;
X			inpptr = inpbuf;
X
X			for (line = inp_hdr.y; line < inp_hdr.y + inp_hdr.dy; line++) {
X				memcpy(dotptr, inpptr, inp_hdr.dx);
X				dotptr += MyData.Om_width;
X				inpptr += inp_hdr.dx;
X			}
X
X		}
X		dots2map(&inp_hdr);
X		if (!(inp_hdr.type & PIX_FLUSH))
X			dirty = 1;
X	}
X	if (inp_hdr.type & PIX_FLUSH) {
X		if (dirty)
X			flushMap(&fullhdr);
X		else
X			flushMap(&inp_hdr);
X		dirty = 0;
X	}
}
X
X
X
X
void
repaint(w, data, ev)
Widget w;
caddr_t data;
XXEvent *ev;
{
X
X	XEvent event;
X
X	if (ev->type == MapNotify) {
X		isMapped = TRUE;
X		return;
X	}
X	if (ev->type == UnmapNotify) {
X		isMapped = FALSE;
X		return;
X	}
X	if (ev->type == ConfigureNotify) {
X
X		MyData.Wi_width = ev->xconfigure.width;
X		MyData.Wi_height = ev->xconfigure.height;
X		MyData.Xfactor = MyData.Wi_width / (double) MyData.Om_width;
X		MyData.Yfactor = MyData.Wi_height / (double) MyData.Om_height;
X
X		XFreePixmap(dpy, MyMap);
X		MyMap = XCreatePixmap(dpy, win, MyData.Wi_width, MyData.Wi_height,
X				      DefaultDepthOfScreen(XtScreen(w)));
X
X		dots2map(&fullhdr);
X
X	} else if (ev->type == Expose) {
X
X		if (!isMapped)
X			return;
X	}
X	while (XCheckTypedEvent(dpy, Expose, &event));
X
X	flushMap(&fullhdr);
}
X
X
void
mouseinput(w, data, ev)
Widget w;
caddr_t data;
XXEvent *ev;
{
X	int fd = 0;
X	FILE *f;
X
X	switch (ev->xany.type) {
X	case ButtonPress:
X		fputc('b', stderr);
X		if (ev->xbutton.button == Button1) {
X			if (Ready2Exit) {
X				exit(0); /* brute force */
X			}
X		}
X		break;
X	default:
X		break;
X	}
}
X
X
X
/*** EOF ***/
SHAR_EOF
chmod 0640 pixmon-0.3/pixmon.c ||
echo 'restore of pixmon-0.3/pixmon.c failed'
Wc_c="`wc -c < 'pixmon-0.3/pixmon.c'`"
test 12750 -eq "$Wc_c" ||
	echo 'pixmon-0.3/pixmon.c: original size 12750, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= pixmon-0.3/pixmon.h ==============
if test -f 'pixmon-0.3/pixmon.h' -a X"$1" != X"-c"; then
	echo 'x - skipping pixmon-0.3/pixmon.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting pixmon-0.3/pixmon.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pixmon-0.3/pixmon.h' &&
X
/*
X *	header types:
X *		PIX_FLUSH:	draw (or redraw) given area
X *		PIX_DATA:	color data for given area follows
X *		PIX_KILL:	quit PixMon
X *
X */
X
#ifndef	__PIXMON__
#define	__PIXMON__
X
X
#define PIX_FLUSH	0x1
#define PIX_DATA	0x2
#define PIX_KILL	0x4
X
#define PIX_UNKNOWN	(~(PIX_FLUSH | PIX_DATA))
X
#define PIX_MAGIC	0x2308
#define	PIX_RLE		0xFF
X
#define INIT_IMGHDR(hdr) ((hdr).type=(PIX_DATA|PIX_FLUSH),\
X			  (hdr).magic=PIX_MAGIC,\
X			  (hdr).x=(hdr).y=(hdr).dx=(hdr).dy=0,\
X			  (hdr).sizelo=(hdr).sizehi=0)
X
#define EXIT_IMGHDR(hdr) ((hdr).type=PIX_KILL,\
X			  (hdr).magic=PIX_MAGIC,\
X			  (hdr).x=(hdr).y=(hdr).dx=(hdr).dy=0,\
X			  (hdr).sizelo=(hdr).sizehi=0)
X
#define	PIX_SIZE(hdr)	(int)((hdr).sizelo | (int)(hdr).sizehi << 16)
X
#define PIX_LO(val)	(unsigned short)(((val) & 0xffff))
#define PIX_HI(val)	(unsigned short)(((val) >> 16) & 0xffff)
X
typedef struct {
X	unsigned short	magic;
X	unsigned short  type;
X	short		x;
X	short		y;
X	unsigned short	dx;
X	unsigned short	dy;
X	unsigned short	sizelo;
X	unsigned short	sizehi;
} ImgHdr;
X
typedef struct {
X	unsigned short  type;
X	short		x;
X	short		y;
X	unsigned short	dx;
X	unsigned short	dy;
X	unsigned short	sizelo;
X	unsigned short	sizehi;
} IMGHDR;
X
X
#endif	/*PIXMON*/
SHAR_EOF
chmod 0640 pixmon-0.3/pixmon.h ||
echo 'restore of pixmon-0.3/pixmon.h failed'
Wc_c="`wc -c < 'pixmon-0.3/pixmon.h'`"
test 1218 -eq "$Wc_c" ||
	echo 'pixmon-0.3/pixmon.h: original size 1218, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= pixmon-0.3/rle.c ==============
if test -f 'pixmon-0.3/rle.c' -a X"$1" != X"-c"; then
	echo 'x - skipping pixmon-0.3/rle.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting pixmon-0.3/rle.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pixmon-0.3/rle.c' &&
/*
X *	Simple run-length-encoding
X *	(c) Joachim Sprave 1992, 1993
X *	
X */
X
#include <stdlib.h>
#include "rle.h"
X
static unsigned char *rl_src_buffer;
static unsigned char rl_escape;
static unsigned long rl_src;
static unsigned long rl_src_size;
static unsigned long rl_count;
static unsigned char rl_current;
X
X
#define COUNT_MAX	0x10000
#define LO(k)		((k) & (unsigned long)0xFF)
#define HI(k)		(((k) & (unsigned long)0xFF00)>>8)
#define UNLO(c)		(c)
#define UNHI(c)		((c) << 8)
X
X
X
/*
X *	RL-encode a buffer in-place
X *	returns:	no. of bytes after encoding
X */
unsigned long
rl_encode(
unsigned char *buffer,		/* data to encode			*/
unsigned long size,		/* no. of bytes in buffer		*/
unsigned char escape) 		/* esc. byte preceding a count		*/
{
X    unsigned long src, dst;
X    unsigned long count;
X    unsigned char current;
X
X    src = dst = 0;
X    while (src < size) {
X	count = 1;
X	current = buffer[src];
X	while (++src < size && buffer[src] == current && count < COUNT_MAX)
X	    count++;
X	if (count > 3 || current == escape) {
X	    buffer[dst++] = escape;
X	    buffer[dst++] = (char) LO(count);
X	    buffer[dst++] = (char) HI(count);
X	    buffer[dst++] = current;
X	}
X	else {
X	    while (count--)
X		buffer[dst++] = current;
X	}
X    }
X    return dst;
}
X
/*
X *	RL-decode a buffer into another one
X *	returns:	no. of bytes after decoding
X *
X *	Caution: dst_buffer must be large enough to
X *	         hold the decoded data
X */
unsigned long
rl_decode(
unsigned char *src_buffer,	/* source buffer	*/
unsigned char *dst_buffer,	/* destination buffer	*/
unsigned long src_size,		/* no. of encoded bytes	*/
unsigned char escape)		/* escape code		*/
{
X    unsigned long src, dst;
X    unsigned long count;
X    unsigned char current;
X
X    src = dst = 0;
X    while (src < src_size) {
X	if (src_buffer[src] == escape) {
X	    src++;
X	    count = UNLO(src_buffer[src++]);
X	    count |= UNHI(src_buffer[src++]);
X	    current = src_buffer[src++];
X	    while (count--)
X		dst_buffer[dst++] = current;
X	}
X	else {
X	    dst_buffer[dst++] = src_buffer[src++];
X	}
X    }
X    return dst;
}
X
/*
X *	Determine the size needed for decoding
X */
unsigned long
rl_decode_length(
unsigned char *src_buffer,	/* buffer		*/
unsigned long src_size,		/* size encoded		*/
unsigned char escape)		/* escape code		*/
{
X    unsigned long src, dst;
X    unsigned long count;
X
X    src = dst = 0;
X    while (src < src_size) {
X	if (src_buffer[src] == escape) {
X	    src++;
X	    count = UNLO(src_buffer[src++]);
X	    count |= UNHI(src_buffer[src++]);
X	    src++;
X	    dst += count;
X	}
X	else {
X	    src++;
X	    dst++;
X	}
X    }
X    return (dst);
}				/* end rl_decode_length */
X
X
/*
X *	To avoid needing a buffer to hold the entire
X *	decoded data, buffers can be decoded in pieces
X */
X
/*
X *	Initialize for decoding in pieces
X */
void
rl_decode_init(
unsigned char *src_buffer,	/* buffer		*/
unsigned long src_size,		/* size encoded		*/
unsigned char escape)		/* esc. code		*/
{
X    rl_src_buffer = src_buffer;
X    rl_src_size = src_size;
X    rl_escape = escape;
X    rl_src = (unsigned long)0;
X    rl_count = (unsigned long)0;
}
X
X
/*
X *	Decode the next dst_size bytes from the buffer
X *	initialized before. If dst_buffer is NULL, dst_size
X *	bytes are skipped.
X *	returns:	no. of bytes written to dst_buffer
X */
X
unsigned long
rl_decode_next(
unsigned char *dst_buffer,	/* destination buffer	*/
unsigned long dst_size)		/* no. bytes to decode	*/
{
X    unsigned long dst;
X
X    dst = 0;
X    while (rl_src <= rl_src_size && dst < dst_size) {
X	while (rl_count && dst < dst_size) {
X	    if (dst_buffer != (unsigned char *) 0)	/* skip */
X		dst_buffer[dst] = rl_current;
X	    dst++;
X	    rl_count--;
X	}
X	if (rl_count == 0) {
X	    if (rl_src_buffer[rl_src] == rl_escape) {
X		rl_src++;
X		rl_count  = UNLO(rl_src_buffer[rl_src++]);
X		rl_count |= UNHI(rl_src_buffer[rl_src++]);
X	    }
X	    else {
X		rl_count = 1;
X	    }
X	    rl_current = rl_src_buffer[rl_src++];
X	}
X    }
X    return dst;
}
SHAR_EOF
chmod 0640 pixmon-0.3/rle.c ||
echo 'restore of pixmon-0.3/rle.c failed'
Wc_c="`wc -c < 'pixmon-0.3/rle.c'`"
test 3924 -eq "$Wc_c" ||
	echo 'pixmon-0.3/rle.c: original size 3924, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= pixmon-0.3/rle.h ==============
if test -f 'pixmon-0.3/rle.h' -a X"$1" != X"-c"; then
	echo 'x - skipping pixmon-0.3/rle.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting pixmon-0.3/rle.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pixmon-0.3/rle.h' &&
#ifdef __STDC__
X
extern
unsigned long 
rl_encode(
X	unsigned char	*buffer, 
X	unsigned long	size, 
X	unsigned char	escape
);
X
extern
unsigned long 
rl_decode (
X	unsigned char	*src_buffer, 
X	unsigned char	*dst_buffer, 
X	unsigned long	src_size, 
X	unsigned char	escape
);
X
extern
unsigned long 
rl_decode_length (
X	unsigned char	*src_buffer, 
X	unsigned long	src_size, 
X	unsigned char	escape
);
X
extern
void 
rl_decode_init(
X		unsigned char	*src_buffer, 
X		unsigned long	src_size,
X		unsigned char	escape
);
X
extern
unsigned long 
rl_decode_next(
X	        unsigned char	*dst_buffer, 
X	        unsigned long	dst_size
);
X
#else
X
extern unsigned long rl_encode();
extern unsigned long rl_decode ();
extern unsigned long rl_decode_length ();
extern void rl_decode_init();
extern unsigned long rl_decode_next();
X
#endif
SHAR_EOF
chmod 0640 pixmon-0.3/rle.h ||
echo 'restore of pixmon-0.3/rle.h failed'
Wc_c="`wc -c < 'pixmon-0.3/rle.h'`"
test 807 -eq "$Wc_c" ||
	echo 'pixmon-0.3/rle.h: original size 807, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
rm -f _shar_seq_.tmp
echo You have unpacked the last part
exit 0

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM            | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly!      |
 "It's intuitively obvious to the most |    sources-x@imd.sterling.com
  casual observer..."                  |
