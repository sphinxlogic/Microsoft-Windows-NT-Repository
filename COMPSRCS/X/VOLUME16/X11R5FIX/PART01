Path: uunet!usc!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: rws@expo.lcs.mit.edu
Newsgroups: comp.sources.x
Subject: v16i003: X11R5 public fix #9, Part01/01
Message-ID: <1992Feb4.143840.15383@msi.com>
Date: 4 Feb 92 14:38:40 GMT
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1639
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: rws@expo.lcs.mit.edu
Posting-number: Volume 16, Issue 3
Archive-name: X11R5-fix09/part01

*** 1,7 ****
  /*
   * Xau - X Authorization Database Library
   *
!  * $XConsortium: AuLock.c,v 1.7 91/04/17 10:59:27 rws Exp $
   *
   * Copyright 1988 Massachusetts Institute of Technology
   *
--- 1,7 ----
  /*
   * Xau - X Authorization Database Library
   *
!  * $XConsortium: AuLock.c,v 1.8 91/12/16 19:56:07 gildea Exp $
   *
   * Copyright 1988 Massachusetts Institute of Technology
   *
***************
*** 21,32 ****
  #include <X11/Xauth.h>
  #include <sys/types.h>
  #include <sys/stat.h>
- #ifndef X_NOT_POSIX
  #include <errno.h>
- #else
- #include <sys/errno.h>
- #endif
  
  #if NeedFunctionPrototypes
  int
  XauLockAuth (
--- 21,30 ----
  #include <X11/Xauth.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <errno.h>
  
+ extern int errno;
+ 
  #if NeedFunctionPrototypes
  int
  XauLockAuth (
***************
*** 50,56 ****
      struct stat	statb;
      long	now;
      int		creat_fd = -1;
-     extern int	errno;
  
      if (strlen (file_name) > 1022)
  	return LOCK_ERROR;
--- 48,53 ----
***************
*** 82,87 ****
--- 79,88 ----
  	if (creat_fd != -1) {
  	    if (link (creat_name, link_name) != -1)
  		return LOCK_SUCCESS;
+ 	    if (errno == ENOENT) {
+ 		creat_fd = -1;	/* force re-creat next time around */
+ 		continue;
+ 	    }
  	    if (errno != EEXIST)
  		return LOCK_ERROR;
  	}

*** /tmp/,RCSt1003431	Thu Jan 23 17:34:36 1992
--- mit/lib/X/Xsi/XlcLoad.c	Mon Dec 23 11:39:04 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XlcLoad.c,v 1.38 91/11/17 16:12:06 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XlcLoad.c,v 1.40 91/12/23 11:37:03 rws Exp $
   */
  
  /*
***************
*** 59,64 ****
--- 59,65 ----
  #endif
  #ifndef PATH_MAX
  #include <sys/param.h>
+ #ifndef PATH_MAX
  #ifdef MAXPATHLEN
  #define PATH_MAX MAXPATHLEN
  #else
***************
*** 65,70 ****
--- 66,72 ----
  #define PATH_MAX 1024
  #endif
  #endif
+ #endif
  
  #ifndef XNLSPATHDEFAULT
  #define XNLSPATHDEFAULT "/usr/lib/X11/nls"
***************
*** 1030,1035 ****
--- 1032,1038 ----
      int cscode;
      int dlen;
  
+     csid = _Xmbcsid((XLocale)state, str);
      dlen = _Xmbdlen((XLocale)state, str);
      if (dlen > 0) {
  	for (*lenp = 0; ; ) {

*** /tmp/,RCSt1003436	Thu Jan 23 17:35:35 1992
--- mit/lib/X/Xsi/XLocalIM.c	Fri Dec 27 15:14:14 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XLocalIM.c,v 1.6 91/11/17 15:59:05 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XLocalIM.c,v 1.8 91/12/27 15:12:20 rws Exp $
   */
  
  /*
***************
*** 55,60 ****
--- 55,61 ----
  #endif
  #ifndef PATH_MAX
  #include <sys/param.h>
+ #ifndef PATH_MAX
  #ifdef MAXPATHLEN
  #define PATH_MAX MAXPATHLEN
  #else
***************
*** 61,66 ****
--- 62,68 ----
  #define PATH_MAX 1024
  #endif
  #endif
+ #endif
  
  #ifdef X_NOT_STDC_ENV
  extern char *getenv();
***************
*** 199,205 ****
  typedef struct {
      char *name;
      Bool (*func)();
!     Bool (*init_func)();
  } FuncTbl;
  
  static int convert_on();
--- 201,207 ----
  typedef struct {
      char *name;
      Bool (*func)();
!     int (*init_func)();
  } FuncTbl;
  
  static int convert_on();
***************
*** 414,419 ****
--- 416,436 ----
      return (0);
  }
  
+ static int
+ is_state_command(xcvt, f, t)
+ XipLocalCvt *xcvt;
+ char *f, *t;
+ {
+     if (!*f || !*t) return(0);
+     if (!strcmp(f, "InitialState"))
+ 	if (!strcmp(t, "OnState"))
+ 	    xcvt->off = False;
+ 	else if (!strcmp(t, "OffState"))
+ 	    xcvt->off = True;
+ 	else return(0);
+     return(1);
+ }
+ 
  static FuncTbl *
  get_command(name)
  char *name;
***************
*** 449,455 ****
      return(True);
  }
  
! static Bool
  convert_on_init(xcvt, tbl, len)
  XipLocalCvt *xcvt;
  XipLocalCvtTbl *tbl;
--- 466,472 ----
      return(True);
  }
  
! static int
  convert_on_init(xcvt, tbl, len)
  XipLocalCvt *xcvt;
  XipLocalCvtTbl *tbl;
***************
*** 458,464 ****
      register XipLocalKeySymTbl *to, *from, *p;
  
      p = (XipLocalKeySymTbl *) Xmalloc(sizeof(XipLocalKeySymTbl) * (len + 1));
!     if (!to) return(False);
      for (to = p, from = tbl->fromkey; len > 0; to++, from++, len--) {
  	to->keysym = from->keysym;
  	to->state = from->state;
--- 475,481 ----
      register XipLocalKeySymTbl *to, *from, *p;
  
      p = (XipLocalKeySymTbl *) Xmalloc(sizeof(XipLocalKeySymTbl) * (len + 1));
!     if (!p) return(-1);
      for (to = p, from = tbl->fromkey; len > 0; to++, from++, len--) {
  	to->keysym = from->keysym;
  	to->state = from->state;
***************
*** 468,477 ****
      xcvt->off_tbl.to.func = tbl->to.func;
      xcvt->off_tbl.com = True;
      xcvt->off_tbl.fromkey = p;
!     return(True);
  }
  
! static Bool
  no_filter(xcvt, tbl, len)
  XipLocalCvt *xcvt;
  XipLocalCvtTbl *tbl;
--- 485,494 ----
      xcvt->off_tbl.to.func = tbl->to.func;
      xcvt->off_tbl.com = True;
      xcvt->off_tbl.fromkey = p;
!     return(0);
  }
  
! static int
  no_filter(xcvt, tbl, len)
  XipLocalCvt *xcvt;
  XipLocalCvtTbl *tbl;
***************
*** 481,490 ****
  
      nested_keysym = (XipLocalNestedKeySym *)
        Xmalloc(sizeof(XipLocalNestedKeySym));
      nested_keysym->keysym = tbl->fromkey->keysym;
      nested_keysym->next = xcvt->no_filter;
      xcvt->no_filter = nested_keysym;
!     return(True);
  }
  
  static Bool
--- 498,508 ----
  
      nested_keysym = (XipLocalNestedKeySym *)
        Xmalloc(sizeof(XipLocalNestedKeySym));
+     if (!nested_keysym) return(-1);
      nested_keysym->keysym = tbl->fromkey->keysym;
      nested_keysym->next = xcvt->no_filter;
      xcvt->no_filter = nested_keysym;
!     return(1);
  }
  
  static Bool
***************
*** 552,557 ****
--- 570,576 ----
      KeySym bs;
      FuncTbl *func_tbl;
      int line = 0;
+     int ret;
  
      strcpy(tmp_buf, xlc->xlc_db->lc_name);
      for (p = tmp_buf; *p && *p != '@'; p++);
***************
*** 580,585 ****
--- 599,605 ----
      cnt = 0;
      cvt->nmax = 0;
      cvt->no_filter = NULL;
+     cvt->off = False;
      while(fgets(buf, BUFSIZ, fp)) {
  	line++;
  	if(is_comment(*buf) || 
***************
*** 589,595 ****
  	    goto _err_ret;
  	}
  	if(!(cvt->tbl[cnt].fromkey = get_keysym(frombuf, &len))){
! 	    goto _err_ret;
  	}
  	if (len > cvt->nmax) cvt->nmax = len;
  	if (is_command(*tobuf)) {
--- 609,617 ----
  	    goto _err_ret;
  	}
  	if(!(cvt->tbl[cnt].fromkey = get_keysym(frombuf, &len))){
! 	    if (!is_state_command(cvt, frombuf, tobuf))
! 		goto _err_ret;
! 	    continue;
  	}
  	if (len > cvt->nmax) cvt->nmax = len;
  	if (is_command(*tobuf)) {
***************
*** 599,606 ****
  	    cvt->tbl[cnt].to.func = func_tbl->func;
  	    cvt->tbl[cnt].com = True;
  	    if (func_tbl->init_func) {
! 		if ((*func_tbl->init_func)(cvt, &cvt->tbl[cnt], len) == False)
  		    goto _err_ret;
  	    }
  	} else {
  	    if (is_keysym(*tobuf)) {
--- 621,631 ----
  	    cvt->tbl[cnt].to.func = func_tbl->func;
  	    cvt->tbl[cnt].com = True;
  	    if (func_tbl->init_func) {
! 		if ((ret = (*func_tbl->init_func)(cvt, &cvt->tbl[cnt], len))
! 		     == -1)
  		    goto _err_ret;
+ 		else if (ret == 0)
+ 		    continue;
  	    }
  	} else {
  	    if (is_keysym(*tobuf)) {
***************
*** 627,633 ****
  					     * (cvt->nmax + 1));
      cvt->buf_cnt = 0;
      cvt->bs = ((bs = XStringToKeysym("BackSpace"))? bs: 0x8);
-     cvt->off = True;
      fclose(fp);
      return(cvt);
  _err_ret:
--- 652,657 ----
***************
*** 659,665 ****
      new->buf = (XipLocalKeySymTbl *) Xmalloc(sizeof(XipLocalKeySymTbl)
  					     * (new->nmax + 1));
      new->buf_cnt = 0;
!     new->off = True;
      return(new);
  }
  
--- 683,689 ----
      new->buf = (XipLocalKeySymTbl *) Xmalloc(sizeof(XipLocalKeySymTbl)
  					     * (new->nmax + 1));
      new->buf_cnt = 0;
!     new->off = cvt->off;
      return(new);
  }
  
*** /tmp/,RCSt1003247	Thu Jan 23 16:14:53 1992
--- mit/lib/Xt/sharedlib.c	Mon Jan  6 17:02:29 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: sharedlib.c,v 1.12 91/07/23 12:22:07 rws Exp $
   * 
   * Copyright 1989 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: sharedlib.c,v 1.14 92/01/06 17:01:45 gildea Exp $
   * 
   * Copyright 1989 Massachusetts Institute of Technology
   *
***************
*** 60,66 ****
--- 60,77 ----
      _XtToolkitInitialize();
  }
  
+ #if NeedFunctionPrototypes
  Widget 
+ XtInitialize(
+ _Xconst char* name,
+ _Xconst char* classname,
+ XrmOptionDescRec *options,
+ Cardinal num_options,
+ int *argc,
+ String *argv
+ )
+ #else
+ Widget 
  XtInitialize(name, classname, options, num_options, argc, argv)
  String name, classname;
  XrmOptionDescRec *options;
***************
*** 67,72 ****
--- 78,84 ----
  Cardinal num_options;
  String *argv;
  int *argc;
+ #endif
  {
      extern Widget _XtInitialize();
      VENDORINIT
***************
*** 73,79 ****
--- 85,105 ----
      return _XtInitialize (name, classname, options, num_options, argc, argv);
  }
  
+ #if NeedFunctionPrototypes
  Widget
+ XtAppInitialize(
+ XtAppContext * app_context_return,
+ _Xconst char* application_class,
+ XrmOptionDescRec *options,
+ Cardinal num_options,
+ int *argc_in_out,
+ String *argv_in_out,
+ String *fallback_resources,
+ ArgList args_in,
+ Cardinal num_args_in
+ )
+ #else
+ Widget
  XtAppInitialize(app_context_return, application_class, options, num_options,
  		argc_in_out, argv_in_out, fallback_resources, 
  		args_in, num_args_in)
***************
*** 84,89 ****
--- 110,116 ----
  int *argc_in_out;
  String *argv_in_out, * fallback_resources;     
  ArgList args_in;
+ #endif
  {
      extern Widget _XtAppInitialize();
      VENDORINIT
***************
*** 92,103 ****
  			     fallback_resources, args_in, num_args_in);
  }
  
! #if NeedFunctionPrototypes
  Widget
! XtVaAppInitialize(XtAppContext *app_context_return, String application_class,
! 		  XrmOptionDescList options, Cardinal num_options,
! 		  int *argc_in_out, String *argv_in_out,
! 		  String *fallback_resources, ...)
  #else
  Widget XtVaAppInitialize(app_context_return, application_class, options,
  			 num_options, argc_in_out, argv_in_out,
--- 119,135 ----
  			     fallback_resources, args_in, num_args_in);
  }
  
! #if NeedVarargsPrototypes
  Widget
! XtVaAppInitialize(
!     XtAppContext *app_context_return,
!     _Xconst char* application_class,
!     XrmOptionDescList options,
!     Cardinal num_options,
!     int *argc_in_out,
!     String *argv_in_out,
!     String *fallback_resources,
!     ...)
  #else
  Widget XtVaAppInitialize(app_context_return, application_class, options,
  			 num_options, argc_in_out, argv_in_out,

*** /tmp/,RCSt1024386	Mon Dec 23 13:18:28 1991
--- mit/lib/Xt/Initialize.c	Thu Dec 19 19:32:53 1991
***************
*** 1,4 ****
! /* $XConsortium: Initialize.c,v 1.199 91/07/23 12:16:38 rws Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Initialize.c,v 1.200 91/12/19 19:30:59 rws Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 53,61 ****
   * If used as a shared library, generate code under a different name so that
   * the stub routines in sharedlib.c get loaded into the application binary.
   */
- #ifdef SUNSHLIB
- #define _XtInherit __XtInherit
- #endif
  #define XtToolkitInitialize _XtToolkitInitialize
  #define XtAppInitialize _XtAppInitialize
  #define XtInitialize _XtInitialize
--- 53,58 ----
***************
*** 141,146 ****
--- 138,152 ----
      return len;
  }
  
+ 
+ #ifdef SUNSHLIB
+ void _XtInherit()
+ {
+     extern void __XtInherit();
+     __XtInherit();
+ }
+ #define _XtInherit __XtInherit
+ #endif
  
  void _XtInherit()
  {

*** /tmp/,RCSt1a00686	Fri Jan  3 18:25:24 1992
--- mit/lib/Xt/Destroy.c	Fri Jan  3 18:05:36 1992
***************
*** 1,4 ****
! /* $XConsortium: Destroy.c,v 1.43 91/06/30 17:02:46 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Destroy.c,v 1.44 92/01/03 18:03:59 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 124,130 ****
  
      parent = widget->core.parent;
  
!     if (parent && parent->core.num_popups) {
  	int i;
  	for (i = 0; i < parent->core.num_popups; i++) {
  	    if (parent->core.popup_list[i] == widget) {
--- 124,130 ----
  
      parent = widget->core.parent;
  
!     if (parent && XtIsWidget(parent) && parent->core.num_popups) {
  	int i;
  	for (i = 0; i < parent->core.num_popups; i++) {
  	    if (parent->core.popup_list[i] == widget) {

*** /tmp/,RCSt1003447	Thu Jan 23 17:38:32 1992
--- mit/lib/Xmu/Imakefile	Fri Dec 20 11:22:04 1991
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.73 91/09/18 14:29:12 rws Exp $
  XCOMM
  XCOMM This library contains miscellaneous utility routines and is not part
  XCOMM of the Xlib standard.
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.74 91/12/20 11:20:22 rws Exp $
  XCOMM
  XCOMM This library contains miscellaneous utility routines and is not part
  XCOMM of the Xlib standard.
***************
*** 10,18 ****
  #define DoProfileLib ProfileLibXmu
  #include <Library.tmpl>
  
! #ifdef RsArchitecture
! REQUIREDLIBS = $(EXTENSIONSRC)/lib/libXext.a $(TOOLKITSRC)/libXt.a $(XLIBSRC)/libX11.a
  #endif
  
  /* Since people link in Xmu without Xt, we avoid references to string data. */
  #if HasSharedLibraries
--- 10,22 ----
  #define DoProfileLib ProfileLibXmu
  #include <Library.tmpl>
  
! #if defined(RsArchitecture) || SunPost411FCSLd
! #if DoNormalLib
! REQUIREDLIBS = -L../$(TOOLKITSRC) -lXt -L../$(EXTENSIONSRC)/lib -lXext -L../$(XLIBSRC) -lX11
! #else
! REQUIREDLIBS = -L$(TOOLKITSRC) -lXt -L$(EXTENSIONSRC)/lib -lXext -L$(XLIBSRC) -lX11
  #endif
+ #endif
  
  /* Since people link in Xmu without Xt, we avoid references to string data. */
  #if HasSharedLibraries
***************
*** 152,157 ****
--- 156,167 ----
  #endif
  
  #if DoSharedLib
+ #if SunPost411FCSLd
+ libXmu.so.$(SOXMUREV): $(EXTENSIONSRC)/lib/libXext.so.$(SOXEXTREV)
+ 
+ $(EXTENSIONSRC)/lib/libXext.so.$(SOXEXTREV):
+ 	cd $(EXTENSIONSRC)/lib; make libXext.so.$(SOXEXTREV)
+ #endif
  #if DoNormalLib
  SharedLibraryTarget(Xmu,$(SOXMUREV),$(OBJS),shared,..)
  #else

*** /tmp/,RCSt1008492	Fri Dec 27 15:13:39 1991
--- mit/lib/nls/Xsi/local_im_tbl/lt_LN.bit7	Fri Dec 27 15:12:27 1991
***************
*** 1,4 ****
! # $XConsortium: lt_LN.bit7,v 1.3 91/12/11 11:01:15 rws Exp $
  #
  #	Conversion file for Local Input Method
  #
--- 1,4 ----
! # $XConsortium: lt_LN.bit7,v 1.4 91/12/27 15:10:49 rws Exp $
  #
  #	Conversion file for Local Input Method
  #
***************
*** 7,17 ****
--- 7,20 ----
  #	<from>[<from>...]	[<to>[<to>...]]	[{to_string}[{to_string}...]
  #  or
  #	<from>[<from>...]	Command
+ #  or
+ #	InitialState		OnState/OffState
  #
  #  from : Input keysym
  #  to_keysym : Output keysym
  #  to_string : Output string
  #  Command : Special commad (NoFilter/ConvertOn/ConvertOff)
+ #  InitialState : Initial state (default is OnState)
  
  <Shift_L>			NoFilter
  <Shift_R>			NoFilter
*** /tmp/,RCSt1008492	Fri Dec 27 15:13:42 1991
--- mit/lib/nls/Xsi/local_im_tbl/lt_LN.bit8	Fri Dec 27 15:12:31 1991
***************
*** 1,4 ****
! # $XConsortium: lt_LN.bit8,v 1.3 91/12/11 11:01:22 rws Exp $
  #
  #	Conversion file for Local Input Method
  #
--- 1,4 ----
! # $XConsortium: lt_LN.bit8,v 1.4 91/12/27 15:11:10 rws Exp $
  #
  #	Conversion file for Local Input Method
  #
***************
*** 7,17 ****
--- 7,20 ----
  #	<from>[<from>...]	[<to>[<to>...]]	[{to_string}[{to_string}...]
  #  or
  #	<from>[<from>...]	Command
+ #  or
+ #	InitialState		OnState/OffState
  #
  #  from : Input keysym
  #  to_keysym : Output keysym
  #  to_string : Output string
  #  Command : Special commad (NoFilter/ConvertOn/ConvertOff)
+ #  InitialState : Initial state (default is OnState)
  
  <Shift_L>			NoFilter
  <Shift_R>			NoFilter

*** /tmp/,RCSt1K_wBIj	Wed Dec 11 19:51:50 1991
--- mit/fonts/lib/font/fontfile/dirfile.c	Wed Dec 11 19:49:40 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: dirfile.c,v 1.4 91/07/25 18:05:10 rws Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: dirfile.c,v 1.5 91/12/11 19:49:06 eswu Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
***************
*** 69,77 ****
--- 69,82 ----
  	    return BadFontPath;
  	}
  	dir = FontFileMakeDir(directory, i);
+ 	if (dir == NULL) {
+ 	    fclose(file);
+ 	    return BadFontPath;
+ 	}
  	dir->dir_mtime = statb.st_mtime;
  	while ((count = fscanf(file, "%s %[^\n]\n", file_name, font_name)) != EOF) {
  	    if (count != 2) {
+ 		FontFileFreeDir (dir);
  		fclose(file);
  		return BadFontPath;
  	    }
***************
*** 78,83 ****
--- 83,89 ----
  	    if (!FontFileAddFontFile (dir, font_name, file_name))
  	    {
  		FontFileFreeDir (dir);
+ 		fclose(file);
  		return BadFontPath;
  	    }
  	}
*** /tmp/,RCSt1K%YCKs	Wed Dec 11 19:51:52 1991
--- mit/fonts/lib/font/fontfile/fontdir.c	Wed Dec 11 19:49:30 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: fontdir.c,v 1.5 91/07/16 20:13:27 keith Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: fontdir.c,v 1.6 91/12/11 19:46:47 eswu Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
***************
*** 50,55 ****
--- 50,58 ----
  {
      FontScalableExtraPtr   extra;
  
+     if (entry->name.name)
+ 	xfree(entry->name.name);
+ 
      switch (entry->type)
      {
      case FONT_ENTRY_SCALABLE:
***************
*** 122,127 ****
--- 125,131 ----
  {
      FontFileFreeTable (&dir->scalable);
      FontFileFreeTable (&dir->nonScalable);
+     xfree(dir);
  }
  
  FontEntryPtr

*** /tmp/,RCSt1a07990	Tue Jan 21 15:40:32 1992
--- mit/clients/xdm/util.c	Tue Jan 21 15:40:04 1992
***************
*** 1,7 ****
  /*
   * xdm - display manager daemon
   *
!  * $XConsortium: util.c,v 1.13 91/04/17 10:06:32 rws Exp $
   *
   * Copyright 1988 Massachusetts Institute of Technology
   *
--- 1,7 ----
  /*
   * xdm - display manager daemon
   *
!  * $XConsortium: util.c,v 1.14 92/01/21 15:38:28 gildea Exp $
   *
   * Copyright 1988 Massachusetts Institute of Technology
   *
***************
*** 62,67 ****
--- 62,69 ----
  	char	*name;
  {
  	int	l = strlen (name);
+ 
+ 	if (!e) return 0;
  
  	while (*e) {
  		if ((int)strlen (*e) > l && !strncmp (*e, name, l) &&

*** /tmp/,RCSt1003252	Thu Jan 23 16:16:17 1992
--- mit/clients/xauth/process.c	Wed Jan 22 23:39:36 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: process.c,v 1.35 91/02/28 09:21:52 rws Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: process.c,v 1.41 92/01/22 23:39:12 gildea Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
***************
*** 42,48 ****
  
  #define SECURERPC "SUN-DES-1"
  
! #define XAUTH_DEFAULT_RETRIES 2		/* just a few times */
  #define XAUTH_DEFAULT_TIMEOUT 2		/* in seconds, be quick */
  #define XAUTH_DEFAULT_DEADTIME 600L	/* 10 minutes in seconds */
  
--- 42,48 ----
  
  #define SECURERPC "SUN-DES-1"
  
! #define XAUTH_DEFAULT_RETRIES 10	/* number of competitors we expect */
  #define XAUTH_DEFAULT_TIMEOUT 2		/* in seconds, be quick */
  #define XAUTH_DEFAULT_DEADTIME 600L	/* 10 minutes in seconds */
  
***************
*** 88,94 ****
  static int do_help(), do_source(), do_info(), do_exit();
  static int do_quit(), do_questionmark();
  
! CommandTable command_table[] = {	/* table of known commands */
      { "add",      2, 3, do_add,
  	"add dpyname protoname hexkey   add entry" },
      { "exit",     3, 4, do_exit,
--- 88,94 ----
  static int do_help(), do_source(), do_info(), do_exit();
  static int do_quit(), do_questionmark();
  
! static CommandTable command_table[] = {	/* table of known commands */
      { "add",      2, 3, do_add,
  	"add dpyname protoname hexkey   add entry" },
      { "exit",     3, 4, do_exit,
***************
*** 192,202 ****
  static char *skip_space (s)
      register char *s;
  {
-     register char c;
- 
      if (!s) return NULL;
  
!     for (; (c = *s) && isascii(c) && isspace(c); s++) ;
      return s;
  }
  
--- 192,201 ----
  static char *skip_space (s)
      register char *s;
  {
      if (!s) return NULL;
  
!     for ( ; *s && isascii(*s) && isspace(*s); s++)
! 	;
      return s;
  }
  
***************
*** 204,215 ****
  static char *skip_nonspace (s)
      register char *s;
  {
-     register char c;
- 
      if (!s) return NULL;
  
      /* put quoting into loop if need be */
!     for (; (c = *s) && isascii(c) && !isspace(c); s++) ;
      return s;
  }
  
--- 203,213 ----
  static char *skip_nonspace (s)
      register char *s;
  {
      if (!s) return NULL;
  
      /* put quoting into loop if need be */
!     for ( ; *s && isascii(*s) && !isspace(*s); s++)
! 	;
      return s;
  }
  
***************
*** 591,596 ****
--- 589,595 ----
  #define _signal_t void
  #endif
  
+ /* ARGSUSED */
  static _signal_t die (sig)
      int sig;
  {
***************
*** 609,615 ****
      if (sig > 0) signal (sig, die);	/* re-establish signal handler */
  #endif
      if (verbose && xauth_modified) printf ("\r\n");
!     die ();
      /* NOTREACHED */
  #ifdef SIGNALRETURNSINT
      return -1;				/* for picky compilers */
--- 608,614 ----
      if (sig > 0) signal (sig, die);	/* re-establish signal handler */
  #endif
      if (verbose && xauth_modified) printf ("\r\n");
!     die (sig);
      /* NOTREACHED */
  #ifdef SIGNALRETURNSINT
      return -1;				/* for picky compilers */
***************
*** 657,670 ****
      hexvalues['e'] = hexvalues['E'] = 0xe;
      hexvalues['f'] = hexvalues['F'] = 0xf;
  
-     exists = (access (authfilename, F_OK) == 0);
-     if (exists && access (authfilename, W_OK) != 0) {
- 	fprintf (stderr,
- 	 "%s:  %s not writable, changes will be ignored\n",
- 		 ProgramName, authfilename);
- 	xauth_allowed = False;
-     }
- 
      if (break_locks && verbose) {
  	printf ("Attempting to break locks on authority file %s\n",
  		authfilename);
--- 656,661 ----
***************
*** 692,697 ****
--- 683,697 ----
  	}
      }
  
+     /* these checks can only be done reliably after the file is locked */
+     exists = (access (authfilename, F_OK) == 0);
+     if (exists && access (authfilename, W_OK) != 0) {
+ 	fprintf (stderr,
+ 	 "%s:  %s not writable, changes will be ignored\n",
+ 		 ProgramName, authfilename);
+ 	xauth_allowed = False;
+     }
+ 
      original_umask = umask (0077);	/* disallow non-owner access */
  
      authfp = fopen (authfilename, "r");
***************
*** 750,758 ****
  	return -1;
      } 
  
      for (list = xauth_head; list; list = list->next) {
! 	XauWriteAuth (fp, list->auth);
      }
  
      (void) fclose (fp);
      return 0;
--- 750,773 ----
  	return -1;
      } 
  
+     /*
+      * Write MIT-MAGIC-COOKIE-1 first, because R4 Xlib knows
+      * only that and uses the first authorization it finds.
+      */
      for (list = xauth_head; list; list = list->next) {
! 	if (list->auth->name_length == 18
! 	    && strncmp(list->auth->name, "MIT-MAGIC-COOKIE-1", 18) == 0)
! 	{
! 	    XauWriteAuth (fp, list->auth);
! 	}
      }
+     for (list = xauth_head; list; list = list->next) {
+ 	if (list->auth->name_length != 18
+ 	    || strncmp(list->auth->name, "MIT-MAGIC-COOKIE-1", 18) != 0)
+ 	{
+ 	    XauWriteAuth (fp, list->auth);
+ 	}
+     }
  
      (void) fclose (fp);
      return 0;
***************
*** 829,835 ****
  
  static void fprintfhex (fp, len, cp)
      register FILE *fp;
!     int len;
      char *cp;
  {
      unsigned char *ucp = (unsigned char *) cp;
--- 844,850 ----
  
  static void fprintfhex (fp, len, cp)
      register FILE *fp;
!     unsigned int len;
      char *cp;
  {
      unsigned char *ucp = (unsigned char *) cp;
***************
*** 859,864 ****
--- 874,880 ----
      return;
  }
  
+ /* ARGSUSED */
  static int dump_entry (inputfilename, lineno, auth, data)
      char *inputfilename;
      int lineno;
***************
*** 933,939 ****
  }
  
  
! static int match_auth (a, b)
      register Xauth *a, *b;
  {
      return ((a->family == b->family &&
--- 949,955 ----
  }
  
  
! static int match_auth_dpy (a, b)
      register Xauth *a, *b;
  {
      return ((a->family == b->family &&
***************
*** 943,949 ****
--- 959,975 ----
  	     bcmp (a->number, b->number, a->number_length) == 0) ? 1 : 0);
  }
  
+ /* return non-zero iff display and authorization type are the same */
  
+ static int match_auth (a, b)
+     register Xauth *a, *b;
+ {
+     return ((match_auth_dpy(a, b)
+ 	     && a->name_length == b->name_length
+ 	     && bcmp(a->name, b->name, a->name_length) == 0) ? 1 : 0);
+ }
+ 
+ 
  static int merge_entries (firstp, second, nnewp, nreplp)
      AuthList **firstp, *second;
      int *nnewp, *nreplp;
***************
*** 977,983 ****
  	AuthList *next = b->next;	/* in case we free it */
  
  	a = first;
! 	while (1) {
  	    if (match_auth (a->auth, b->auth)) {  /* found a duplicate */
  		AuthList tmp;		/* swap it in for old one */
  		tmp = *a;
--- 1003,1009 ----
  	AuthList *next = b->next;	/* in case we free it */
  
  	a = first;
! 	for (;;) {
  	    if (match_auth (a->auth, b->auth)) {  /* found a duplicate */
  		AuthList tmp;		/* swap it in for old one */
  		tmp = *a;
***************
*** 1024,1030 ****
      int status;
      int errors = 0;
      Xauth proto;
!     AuthList *l;
  
      /*
       * iterate
--- 1050,1056 ----
      int status;
      int errors = 0;
      Xauth proto;
!     AuthList *l, *next;
  
      /*
       * iterate
***************
*** 1039,1046 ****
  	    continue;
  	}
  	status = 0;
! 	for (l = xauth_head; l; l = l->next) {
! 	    if (match_auth (&proto, l->auth)) {
  		if (yfunc) {
  		    status = (*yfunc) (inputfilename, lineno,
  				       l->auth, data);
--- 1065,1073 ----
  	    continue;
  	}
  	status = 0;
! 	for (l = xauth_head; l; l = next) {
! 	    next = l->next;
! 	    if (match_auth_dpy (&proto, l->auth)) {
  		if (yfunc) {
  		    status = (*yfunc) (inputfilename, lineno,
  				       l->auth, data);
***************
*** 1065,1070 ****
--- 1092,1098 ----
      return errors;
  }
  
+ /* ARGSUSED */
  static int remove_entry (inputfilename, lineno, auth, data)
      char *inputfilename;
      int lineno;
***************
*** 1073,1114 ****
  {
      int *nremovedp = (int *) data;
      AuthList **listp = &xauth_head;
!     AuthList *prev = NULL, *list = (*listp);
!     int removed = 0, notremoved = 0;
  
-     if (!list) {
- 	*nremovedp = 0;
- 	return 1;			/* if nothing to remove */
-     }
- 
      /*
!      * run through list removing any records that match
       */
!     while (list) {
! 	if (match_auth (list->auth, auth)) {
! 	    AuthList *next = list->next;	      /* next one to look at */
! 	    if (prev) {
! 		prev->next = next;		       /* unlink current one */
! 	    } else {
! 		*listp = next;			       /* bump start of list */
! 	    }
! 	    XauDisposeAuth (list->auth);                    /* free the auth */
! 	    free (list);				    /* free the link */
! 	    list = next;			  /* go look at the next one */
! 	    removed++;
! 	    xauth_modified = True;
! 	} else {
! 	    notremoved++;
! 	    prev = list;
! 	    list = list->next;
! 	}
!     }
! 
!     if (notremoved == 0) {		/* if nothing left */
! 	*listp = NULL;			/* then null out list */
!     }
!     *nremovedp = removed;
!     return 0;
  }
  
  /*
--- 1101,1119 ----
  {
      int *nremovedp = (int *) data;
      AuthList **listp = &xauth_head;
!     AuthList *list;
  
      /*
!      * unlink the auth we were asked to
       */
!     while ((list = *listp)->auth != auth)
! 	listp = &list->next;
!     *listp = list->next;
!     XauDisposeAuth (list->auth);                    /* free the auth */
!     free (list);				    /* free the link */
!     xauth_modified = True;
!     (*nremovedp)++;
!     return 1;
  }
  
  /*
***************
*** 1179,1184 ****
--- 1184,1190 ----
  /*
   * questionmark
   */
+ /* ARGSUSED */
  static int do_questionmark (inputfilename, lineno, argc, argv)
      char *inputfilename;
      int lineno;
***************
*** 1524,1529 ****
--- 1530,1536 ----
   */
  static Bool alldone = False;
  
+ /* ARGSUSED */
  static int do_exit (inputfilename, lineno, argc, argv)
      char *inputfilename;
      int lineno;
***************
*** 1538,1543 ****
--- 1545,1551 ----
  /*
   * quit
   */
+ /* ARGSUSED */
  static int do_quit (inputfilename, lineno, argc, argv)
      char *inputfilename;
      int lineno;
***************
*** 1547,1555 ****
      /* allow bogus stuff */
      die (0);
      /* NOTREACHED */
- #ifdef SIGNALRETURNSINT
      return -1;				/* for picky compilers */
- #endif
  }
  
  
--- 1555,1561 ----

*** /tmp/,RCSt1003259	Thu Jan 23 16:18:38 1992
--- mit/clients/xterm/main.c	Mon Dec 23 17:03:02 1991
***************
*** 1,5 ****
  #ifndef lint
! static char *rid="$XConsortium: main.c,v 1.195 91/07/22 12:23:31 gildea Exp $";
  #endif /* lint */
  
  /*
--- 1,5 ----
  #ifndef lint
! static char *rid="$XConsortium: main.c,v 1.199 91/12/23 17:02:24 gildea Exp $";
  #endif /* lint */
  
  /*
***************
*** 745,751 ****
  	register TScreen *screen;
  	register int i, pty;
  	int Xsocket, mode;
! 	char *basename();
  	int xerror(), xioerror();
  
  	ProgramName = argv[0];
--- 745,751 ----
  	register TScreen *screen;
  	register int i, pty;
  	int Xsocket, mode;
! 	char *base_name();
  	int xerror(), xioerror();
  
  	ProgramName = argv[0];
***************
*** 1022,1028 ****
  
  	    if (!resource.title) {
  		if (command_to_exec) {
! 		    resource.title = basename (command_to_exec[0]);
  		} /* else not reached */
  	    }
  
--- 1022,1028 ----
  
  	    if (!resource.title) {
  		if (command_to_exec) {
! 		    resource.title = base_name (command_to_exec[0]);
  		} /* else not reached */
  	    }
  
***************
*** 1092,1097 ****
--- 1092,1115 ----
  	}
  	screen->inhibit = inhibit;
  
+ #ifdef AIXV3
+ 	/* In AIXV3, xterms started from /dev/console have CLOCAL set.
+ 	 * This means we need to clear CLOCAL so that SIGHUP gets sent
+ 	 * to the slave-pty process when xterm exits. 
+ 	 */
+ 
+ 	{
+ 	    struct termio tio;
+ 
+ 	    if(ioctl(pty, TCGETA, &tio) == -1)
+ 		SysError(ERROR_TIOCGETP);
+ 
+ 	    tio.c_cflag &= ~(CLOCAL);
+ 
+ 	    if (ioctl (pty, TCSETA, &tio) == -1)
+ 		SysError(ERROR_TIOCSETP);
+ 	}
+ #endif
  #ifdef USE_SYSV_TERMIO
  	if (0 > (mode = fcntl(pty, F_GETFL, 0)))
  		Error();
***************
*** 1125,1131 ****
  	}
  }
  
! char *basename(name)
  char *name;
  {
  	register char *cp;
--- 1143,1149 ----
  	}
  }
  
! char *base_name(name)
  char *name;
  {
  	register char *cp;
***************
*** 1183,1188 ****
--- 1201,1224 ----
  #endif
  	return 0;
  #else /* ATT else */
+ #ifdef AIXV3
+ 	if ((*pty = open ("/dev/ptc", O_RDWR)) < 0) {
+ 	    return 1;
+ 	}
+ 	strcpy(ttydev, ttyname(*pty));
+ 	return 0;
+ #endif
+ #ifdef sgi
+ 	{
+ 	    char    *tty_name;
+ 
+ 	    tty_name = _getpty (pty, O_RDWR, 0622, 0);
+ 	    if (tty_name == 0)
+ 		return 1;
+ 	    strcpy (ttydev, tty_name);
+ 	    return 0;
+ 	}
+ #endif
  #ifdef __convex__
          {
  	    char *pty_name, *getpty();
***************
*** 1201,1207 ****
  #ifdef USE_GET_PSEUDOTTY
  	return ((*pty = getpseudotty (&ttydev, &ptydev)) >= 0 ? 0 : 1);
  #else
! #if defined(sgi) || (defined(umips) && defined (SYSTYPE_SYSV))
  	struct stat fstat_buf;
  
  	*pty = open ("/dev/ptc", O_RDWR);
--- 1237,1243 ----
  #ifdef USE_GET_PSEUDOTTY
  	return ((*pty = getpseudotty (&ttydev, &ptydev)) >= 0 ? 0 : 1);
  #else
! #if (defined(umips) && defined (SYSTYPE_SYSV))
  	struct stat fstat_buf;
  
  	*pty = open ("/dev/ptc", O_RDWR);
***************
*** 1532,1539 ****
  			if (tty_got_hung || errno == ENXIO || errno == EIO ||
  			    errno == ENOTTY) {
  				no_dev_tty = TRUE;
- #ifdef USE_SYSV_TERMIO
- 				tio = d_tio;
  #ifdef TIOCSLTC
  				ltc = d_ltc;
  #endif	/* TIOCSLTC */
--- 1568,1573 ----
***************
*** 1540,1554 ****
  #ifdef TIOCLSET
  				lmode = d_lmode;
  #endif	/* TIOCLSET */
  #else	/* not USE_SYSV_TERMIO */
  				sg = d_sg;
  				tc = d_tc;
  				discipline = d_disipline;
- 				ltc = d_ltc;
- 				lmode = d_lmode;
  #ifdef sony
- 				jtc = d_jtc;
  				jmode = d_jmode;
  #endif /* sony */
  #endif	/* USE_SYSV_TERMIO */
  			} else {
--- 1574,1588 ----
  #ifdef TIOCLSET
  				lmode = d_lmode;
  #endif	/* TIOCLSET */
+ #ifdef USE_SYSV_TERMIO
+ 				tio = d_tio;
  #else	/* not USE_SYSV_TERMIO */
  				sg = d_sg;
  				tc = d_tc;
  				discipline = d_disipline;
  #ifdef sony
  				jmode = d_jmode;
+ 				jtc = d_jtc;
  #endif /* sony */
  #endif	/* USE_SYSV_TERMIO */
  			} else {
***************
*** 1555,1605 ****
  			    SysError(ERROR_OPDEVTTY);
  			}
  		} else {
! 			/* get a copy of the current terminal's state */
! 
! #ifdef USE_SYSV_TERMIO
! 		        /* SVR4 fails here if xterm started
! 			   from twm from xdm from /etc/rc.
! 			   Hence the protection for the next 3 ioctl's.
! 			   Something about not having a controlling tty. */
! 		        if(ioctl(tty, TCGETA, &tio) == -1)
! #ifndef SVR4
! 				SysError(ERROR_TIOCGETP);
! #else /* SVR4 */
! 			        tio = d_tio;
! #endif /* SVR4 */
  #ifdef TIOCSLTC
  			if(ioctl(tty, TIOCGLTC, &ltc) == -1)
- #ifndef SVR4
- 				SysError(ERROR_TIOCGLTC);
- #else /* SVR4 */
  				ltc = d_ltc;
- #endif /* SVR4 */
  #endif	/* TIOCSLTC */
  #ifdef TIOCLSET
  			if(ioctl(tty, TIOCLGET, &lmode) == -1)
- #ifndef SVR4
- 				SysError(ERROR_TIOCLGET);
- #else /* SVR4 */
  				lmode = d_lmode;
- #endif /* SVR4 */
  #endif	/* TIOCLSET */
  #else	/* not USE_SYSV_TERMIO */
  			if(ioctl(tty, TIOCGETP, (char *)&sg) == -1)
! 				SysError (ERROR_TIOCGETP);
  			if(ioctl(tty, TIOCGETC, (char *)&tc) == -1)
! 				SysError (ERROR_TIOCGETC);
  			if(ioctl(tty, TIOCGETD, (char *)&discipline) == -1)
! 				SysError (ERROR_TIOCGETD);
! 			if(ioctl(tty, TIOCGLTC, (char *)&ltc) == -1)
! 				SysError (ERROR_TIOCGLTC);
! 			if(ioctl(tty, TIOCLGET, (char *)&lmode) == -1)
! 				SysError (ERROR_TIOCLGET);
  #ifdef sony
  			if(ioctl(tty, TIOCKGET, (char *)&jmode) == -1)
! 				SysError (ERROR_TIOCKGET);
  			if(ioctl(tty, TIOCKGETC, (char *)&jtc) == -1)
! 				SysError (ERROR_TIOCKGETC);
  #endif /* sony */
  #endif	/* USE_SYSV_TERMIO */
  			close (tty);
--- 1589,1624 ----
  			    SysError(ERROR_OPDEVTTY);
  			}
  		} else {
! 			/* Get a copy of the current terminal's state,
! 			 * if we can.  Some systems (e.g., SVR4 and MacII)
! 			 * may not have a controlling terminal at this point
! 			 * if started directly from xdm or xinit,     
! 			 * in which case we just use the defaults as above.
! 			 */
  #ifdef TIOCSLTC
  			if(ioctl(tty, TIOCGLTC, &ltc) == -1)
  				ltc = d_ltc;
  #endif	/* TIOCSLTC */
  #ifdef TIOCLSET
  			if(ioctl(tty, TIOCLGET, &lmode) == -1)
  				lmode = d_lmode;
  #endif	/* TIOCLSET */
+ #ifdef USE_SYSV_TERMIO
+ 		        if(ioctl(tty, TCGETA, &tio) == -1)
+ 			        tio = d_tio;
+ 
  #else	/* not USE_SYSV_TERMIO */
  			if(ioctl(tty, TIOCGETP, (char *)&sg) == -1)
! 			        sg = d_sg;
  			if(ioctl(tty, TIOCGETC, (char *)&tc) == -1)
! 			        tc = d_tc;
  			if(ioctl(tty, TIOCGETD, (char *)&discipline) == -1)
! 			        discipline = d_disipline;
  #ifdef sony
  			if(ioctl(tty, TIOCKGET, (char *)&jmode) == -1)
! 			        jmode = d_jmode;
  			if(ioctl(tty, TIOCKGETC, (char *)&jtc) == -1)
! 				jtc = d_jtc;
  #endif /* sony */
  #endif	/* USE_SYSV_TERMIO */
  			close (tty);

*** /tmp/,RCSt1a24265	Mon Dec 23 17:27:16 1991
--- mit/clients/xinit/xinit.c	Mon Dec 23 17:27:00 1991
***************
*** 1,6 ****
! #ifndef lint
! static char *rcsid_xinit_c = "$XConsortium: xinit.c,v 11.52 91/11/29 15:20:35 rws Exp $";
! #endif /* lint */
  
  /* Copyright    Massachusetts Institute of Technology    1986	*/
  
--- 1,4 ----
! /* $XConsortium: xinit.c,v 11.54 91/12/23 17:26:08 gildea Exp $ */
  
  /* Copyright    Massachusetts Institute of Technology    1986	*/
  
***************
*** 49,55 ****
  #define vfork() fork()
  #endif /* SYSV and not hpux */
  
! #ifndef X_NOT_POSIX
  #define setpgrp setpgid
  #endif
  
--- 47,55 ----
  #define vfork() fork()
  #endif /* SYSV and not hpux */
  
! /* A/UX setpgid incorrectly removes the controlling terminal.
!    Per Posix, only setsid should do that. */
! #if !defined(X_NOT_POSIX) && !defined(macII)
  #define setpgrp setpgid
  #endif
  

*** /tmp/,RCSt1000618	Thu Dec 26 15:01:42 1991
--- mit/server/ddx/cfb/cfbbresd.c	Thu Dec 26 15:01:43 1991
***************
*** 21,27 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: cfbbresd.c,v 1.10 91/07/10 14:53:50 keith Exp $ */
  #include "X.h"
  #include "misc.h"
  #include "cfb.h"
--- 21,27 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: cfbbresd.c,v 1.11 91/12/26 14:32:45 rws Exp $ */
  #include "X.h"
  #include "misc.h"
  #include "cfb.h"
***************
*** 66,72 ****
      andFg = rrops[0].and;
      xorBg = rrops[1].xor;
      andBg = rrops[1].and;
!     if ((thisDash = dashRemaining) > len)
      {
  	thisDash = len;
  	dashRemaining -= len;
--- 66,72 ----
      andFg = rrops[0].and;
      xorBg = rrops[1].xor;
      andBg = rrops[1].and;
!     if ((thisDash = dashRemaining) >= len)
      {
  	thisDash = len;
  	dashRemaining -= len;
***************
*** 80,86 ****
      if (dashIndex == numInDashList) \
  	dashIndex = 0; \
      dashRemaining = pDash[dashIndex]; \
!     if ((thisDash = dashRemaining) > len) \
      { \
  	dashRemaining -= len; \
  	thisDash = len; \
--- 80,86 ----
      if (dashIndex == numInDashList) \
  	dashIndex = 0; \
      dashRemaining = pDash[dashIndex]; \
!     if ((thisDash = dashRemaining) >= len) \
      { \
  	dashRemaining -= len; \
  	thisDash = len; \

*** /tmp/,RCSt1008508	Fri Dec 27 15:13:55 1991
--- mit/doc/I18N/Xsi/Xim/LocalIM.man	Fri Dec 27 15:13:20 1991
***************
*** 1,4 ****
! .\" $XConsortium: LocalIM.man,v 1.3 91/12/11 15:57:44 rws Exp $
  .\" Copyright 1991 by OMRON Corp.  All Rights Reserved.
  .TH LocalIM 3X11 "Release 5" "X Version 11" "XSI FUNCTIONS"
  .SH NAME
--- 1,4 ----
! .\" $XConsortium: LocalIM.man,v 1.4 91/12/27 15:11:47 rws Exp $
  .\" Copyright 1991 by OMRON Corp.  All Rights Reserved.
  .TH LocalIM 3X11 "Release 5" "X Version 11" "XSI FUNCTIONS"
  .SH NAME
***************
*** 18,23 ****
--- 18,27 ----
  or
  .br
  <from>[<from>...]  Command
+ .br
+ or
+ .br
+ InitialState  OnState/OffState
  .sp
  .RE
  .IP \fBfrom\fP 1i
***************
*** 37,47 ****
  .IP ConvertOn 1i
  If the input keysym(s) (from) is(are) pressed, the input method
  move in a conversion \fBon\fP state.
! .IP ConvertOn 1i
  If the input keysym(s) (from) is(are) pressed, the input method
  move in a conversion \fBoff\fP state.
  .sp
  .RE
  .PP
  It is possible to omit \fIto\fP or \fIstr\fP. But either must be set.
  .PP
--- 41,55 ----
  .IP ConvertOn 1i
  If the input keysym(s) (from) is(are) pressed, the input method
  move in a conversion \fBon\fP state.
! .IP ConvertOff 1i
  If the input keysym(s) (from) is(are) pressed, the input method
  move in a conversion \fBoff\fP state.
  .sp
  .RE
+ .IP InitialState 1i
+ Specifies the initial state. The second argument is OnState or
+ OffState. The default state is OnState.
+ .sp
  .PP
  It is possible to omit \fIto\fP or \fIstr\fP. But either must be set.
  .PP
***************
*** 72,77 ****
--- 80,87 ----
  .SH EXAMPLE
  .sp
  .RS
+ InitialState            OffState
+ .br
  <Meta_L>                NoFilter
  .br
  <Execute>               ConvertOn

---
-- 
Molecular Simulations, Inc.             mail: dcmartin@msi.com
796 N. Pastoria Avenue                  uucp: uunet!dcmartin
Sunnyvale, California 94086             at&t: 408/522-9236
