Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: dcc@Athena.MIT.EDU (David Carver)
Newsgroups: comp.sources.x
Subject: v16i068: Video Extension for X (v2r2), Part17/29
Message-ID: <1992Feb6.145743.668@msi.com>
Date: 6 Feb 92 14:57:43 GMT
References: <csx-16i052-vex.v2r2@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1889
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: dcc@Athena.MIT.EDU (David Carver)
Posting-number: Volume 16, Issue 68
Archive-name: vex.v2r2/part17

# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
#		"End of archive 17 (of 29)."
# Contents:  extensions/xv/server/Makefile
#   extensions/xv/server/ddx/sunrop/pip_xv.c server/ddx/cfb32/cfb.h
#   server/ddx/cfb32/cfbrctstp8.c
# Wrapped by dcmartin@fascet on Thu Feb  6 06:52:48 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'extensions/xv/server/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extensions/xv/server/Makefile'\"
else
echo shar: Extracting \"'extensions/xv/server/Makefile'\" \(13884 characters\)
sed "s/^X//" >'extensions/xv/server/Makefile' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.51 89/12/12 12:37:30 jim Exp $
X
X###########################################################################
X# Makefile generated from "Imake.tmpl" and <Imakefile>
X# $XConsortium: Imake.tmpl,v 1.77 89/12/18 17:01:37 jim Exp $
X#
X# Platform-specific parameters may be set in the appropriate .cf
X# configuration files.  Site-wide parameters may be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor doesn't define any unique symbols, you'll need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make Makefile", "make Makefiles", or "make World").
X#
X# If you absolutely can't get imake to work, you'll need to set the
X# variables at the top of each Makefile as well as the dependencies at the
X# bottom (makedepend will do this automatically).
X#
X
X###########################################################################
X# platform-specific configuration parameters - edit ultrix.cf to change
X
X# platform:  $XConsortium: ultrix.cf,v 1.20 89/12/22 15:56:14 rws Exp $
X# operating system:             Ultrix-32 4.0
X
X###########################################################################
X# site-specific configuration parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.21 89/12/06 11:46:50 jim Exp $
X
XFONTC=	$(FONTSRC)/tools/bdftopcf/bdftopcf
X
X            SHELL = 	/bin/sh
X
X              TOP = ../../../.
X      CURRENT_DIR = ./extensions/xv/server
X
X               AR = ar cq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X               RM = rm -f
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES = -DUNIX
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES = -ldnet
X             TAGS = ctags
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0664
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X          DESTDIR =
X
X     TOP_INCLUDES = -I$(TOP)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -Wf,-XNh2000 -Olimit 2000
X      COMPATFLAGS =
X
X      ALLINCLUDES = $(STD_INCLUDES) $(TOP_INCLUDES) $(INCLUDES) $(EXTRA_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(PROTO_DEFINES) $(DEFINES) $(COMPATFLAGS)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS)
X   LDCOMBINEFLAGS = -X -r
X
X        MACROFILE = ultrix.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGSRC)
X        IMAKE_CMD = $(NEWTOP)$(IMAKE) -I$(NEWTOP)$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X###########################################################################
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
X###########################################################################
X# X Window System make variables; this need to be coordinated with rules
X# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
X          PATHSEP = /
X        USRLIBDIR = $(DESTDIR)/usr/lib
X           BINDIR = $(TOP)/../bin
X          INCROOT = $(DESTDIR)/usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = $(DESTDIR)/usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           AWMDIR = $(LIBDIR)/awm
X           TWMDIR = $(LIBDIR)/twm
X           GWMDIR = $(LIBDIR)/gwm
X          MANPATH = $(DESTDIR)/usr/man
X    MANSOURCEPATH = $(MANPATH)/man
X           MANDIR = $(MANSOURCEPATH)n
X        LIBMANDIR = $(MANSOURCEPATH)3
X      XAPPLOADDIR = /wsl/share/lib/X11/r4app-defaults
X
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = $(IMAKESRC)/imake
X           DEPEND = $(DEPENDSRC)/makedepend
X              RGB = $(RGBSRC)/rgb
X            FONTC = $(BDFTOSNFSRC)/bdftosnf
X        MKFONTDIR = $(MKFONTDIRSRC)/mkfontdir
X        MKDIRHIER = 	/bin/sh $(SCRIPTSRC)/mkdirhier.sh
X
X        CONFIGSRC = $(TOP)/config
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X     MKFONTDIRSRC = $(FONTSRC)/mkfontdir
X     EXTENSIONSRC = $(TOP)/extensions
X
X  DEPEXTENSIONLIB =  $(EXTENSIONSRC)/lib/libXext.a
X     EXTENSIONLIB = 			   $(DEPEXTENSIONLIB)
X
X          DEPXLIB = $(DEPEXTENSIONLIB)  $(XLIBSRC)/libX11.a
X             XLIB = $(EXTENSIONLIB) 			  $(XLIBSRC)/libX11.a
X
X      DEPXAUTHLIB =  $(XAUTHSRC)/libXau.a
X         XAUTHLIB = 			  $(DEPXAUTHLIB)
X
X        DEPXMULIB =  $(XMUSRC)/libXmu.a
X           XMULIB = 			  $(DEPXMULIB)
X
X       DEPOLDXLIB =  $(OLDXLIBSRC)/liboldX.a
X          OLDXLIB = 			  $(DEPOLDXLIB)
X
X      DEPXTOOLLIB =  $(TOOLKITSRC)/libXt.a
X         XTOOLLIB = 			  $(DEPXTOOLLIB)
X
X        DEPXAWLIB =  $(AWIDGETSRC)/libXaw.a
X           XAWLIB = 			  $(DEPXAWLIB)
X
X LINTEXTENSIONLIB =  $(EXTENSIONSRC)/lib/llib-lXext.ln
X         LINTXLIB =  $(XLIBSRC)/llib-lX11.ln
X          LINTXMU =  $(XMUSRC)/llib-lXmu.ln
X        LINTXTOOL =  $(TOOLKITSRC)/llib-lXt.ln
X          LINTXAW =  $(AWIDGETSRC)/llib-lXaw.ln
X
X          DEPLIBS = $(LOCAL_LIBRARIES)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X###########################################################################
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.67 89/12/18 17:14:15 jim Exp $
X
X###########################################################################
X# start of Imakefile
X
X# $XConsortium: Server.tmpl,v 1.3 89/10/20 11:14:52 jim Exp $
X
X         CC = cc
X  CCOPTIONS = -Wf,-XNh2000 -Olimit 2000
XSTD_DEFINES = -DUNIX -DDPS -DSHAPE -DMITSHM -DMULTIBUFFER -DMITMISC -DXINPUT $(DGEX) -DXV -DSPECIAL_MALLOC -DXDMCP -DX11R4 -DNEW_FONTS -DFONT_CACHE
XCDEBUGFLAGS = -O
XEXT_DEFINES = -DDPS -DSHAPE -DMITSHM -DMULTIBUFFER -DMITMISC -DXINPUT $(DGEX) -DXV
X
XIMAKE_DEFINES = $(EXT_DEFINES)
X
X     DISRCS = xvmain.c xvdisp.c
X     DIOBJS = xvmain.o xvdisp.o
X     DIINCS = -I../include
X
X     PLXSRCS =
X     PLXOBJS =
X     PLXINCS =
X
X     ROPSRCS = xvrop.c
X     ROPOBJS = xvrop.o
X     ROPINCS = -I$(SERVERSRC)/ddx/dec/ws -I$(SERVERSRC)/ddx/dec/cfb
X
X        SRCS = $(DISRCS) $(PLXSRCS) $(ROPSRCS)
X        OBJS = $(DIOBJS) $(PLXOBJS) $(ROPOBJS)
X      XVINCS = $(DIINCS) $(PLXINCS) $(ROPINCS)
X    INCLUDES = -I$(INCLUDESRC) -I$(SERVERSRC)/include -I$(FONTSRC)/include $(XVINCS)
X    LINTLIBS = $(SERVERSRC)/dix/llib-ldix.ln $(SERVERSRC)/os/4.2bsd/llib-los.ln
X
Xall:: libxv.a
X
Xlibxv.a: $(OBJS)
X	$(RM) $@
X	$(AR) $@ $(OBJS)
X	$(RANLIB) $@
X
X.c.o:
X	$(RM) $@
X	$(CC) -c $(CFLAGS) $*.c
X
Xlintlib:: llib-lxv.ln
X
Xllib-lxv.ln: $(SRCS)
X	$(RM) $@
X	$(LINT) $(LINTLIBFLAG)xv $(LINTFLAGS) $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xsaber_src:
X	#load $(CFLAGS) $(SRCS)
X
Xdepend:: $(DEPEND)
X
X$(DEPEND):
X	@echo "checking $@ over in $(DEPENDSRC) first..."; \
X	cd $(DEPENDSRC); $(MAKE); \
X	echo "okay, continuing in $(CURRENT_DIR)"
X
Xdepend::
X	$(DEPEND) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
X###########################################################################
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) \#*
X
XMakefile:: $(IMAKE)
X
X$(IMAKE):
X	@(cd $(IMAKESRC); if [ -f Makefile ]; then \
X	echo "checking $@ in $(IMAKESRC) first..."; $(MAKE) all; else \
X	echo "bootstrapping $@ from Makefile.ini in $(IMAKESRC) first..."; \
X	$(MAKE) -f Makefile.ini BOOTSTRAPCFLAGS=$(BOOTSTRAPCFLAGS); fi; \
X	echo "okay, continuing in $(CURRENT_DIR)")
X
XMakefile::
X	-@if [ -f Makefile ]; then \
X		echo "	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak"; \
X		$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
X###########################################################################
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X###########################################################################
X# dependencies generated by makedepend
X
X# DO NOT DELETE
X
Xxvmain.o: /usr/include/stdio.h /usr/include/ansi_compat.h ../../.././X11/X.h
Xxvmain.o: ../../.././X11/Xproto.h ../../.././X11/Xmd.h
Xxvmain.o: ../../.././X11/Xprotostr.h ../../.././server/include/misc.h
Xxvmain.o: ../../.././server/include/os.h
Xxvmain.o: ../../.././server/include/scrnintstr.h
Xxvmain.o: ../../.././server/include/screenint.h
Xxvmain.o: ../../.././server/include/miscstruct.h
Xxvmain.o: ../../.././server/include/region.h
Xxvmain.o: ../../.././server/include/pixmap.h ../../.././server/include/gc.h
Xxvmain.o: ../../.././server/include/colormap.h
Xxvmain.o: ../../.././server/include/windowstr.h
Xxvmain.o: ../../.././server/include/window.h
Xxvmain.o: ../../.././server/include/pixmapstr.h
Xxvmain.o: ../../.././server/include/regionstr.h
Xxvmain.o: ../../.././server/include/cursor.h
Xxvmain.o: ../../.././server/include/property.h
Xxvmain.o: ../../.././server/include/resource.h
Xxvmain.o: ../../.././server/include/dix.h
Xxvmain.o: ../../.././server/include/extnsionst.h
Xxvmain.o: ../../.././server/include/extension.h
Xxvmain.o: ../../.././server/include/dixstruct.h
Xxvmain.o: ../../.././server/include/opaque.h
Xxvmain.o: ../../.././server/include/input.h ../include/Xv.h
Xxvmain.o: ../include/Xvproto.h ../include/xvdix.h
Xxvdisp.o: /usr/include/stdio.h /usr/include/ansi_compat.h ../../.././X11/X.h
Xxvdisp.o: ../../.././X11/Xproto.h ../../.././X11/Xmd.h
Xxvdisp.o: ../../.././X11/Xprotostr.h ../../.././server/include/misc.h
Xxvdisp.o: ../../.././server/include/os.h
Xxvdisp.o: ../../.././server/include/scrnintstr.h
Xxvdisp.o: ../../.././server/include/screenint.h
Xxvdisp.o: ../../.././server/include/miscstruct.h
Xxvdisp.o: ../../.././server/include/region.h
Xxvdisp.o: ../../.././server/include/pixmap.h ../../.././server/include/gc.h
Xxvdisp.o: ../../.././server/include/colormap.h
Xxvdisp.o: ../../.././server/include/windowstr.h
Xxvdisp.o: ../../.././server/include/window.h
Xxvdisp.o: ../../.././server/include/pixmapstr.h
Xxvdisp.o: ../../.././server/include/regionstr.h
Xxvdisp.o: ../../.././server/include/cursor.h
Xxvdisp.o: ../../.././server/include/property.h
Xxvdisp.o: ../../.././server/include/resource.h
Xxvdisp.o: ../../.././server/include/dix.h
Xxvdisp.o: ../../.././server/include/gcstruct.h
Xxvdisp.o: ../../.././fonts/include/font.h ../../.././fonts/include/fontos.h
Xxvdisp.o: ../../.././X11/Xmd.h ../../.././server/include/dixstruct.h
Xxvdisp.o: ../../.././server/include/opaque.h ../include/Xv.h
Xxvdisp.o: ../include/Xvproto.h ../include/xvdix.h
Xxvrop.o: /usr/include/stdio.h /usr/include/ansi_compat.h
Xxvrop.o: /usr/include/sys/types.h
Xxvrop.o: ../../.././server/ddx/dec/ws/sys/workstation.h ../../.././X11/X.h
Xxvrop.o: ../../.././X11/Xproto.h ../../.././X11/Xmd.h
Xxvrop.o: ../../.././X11/Xprotostr.h ../../.././server/include/scrnintstr.h
Xxvrop.o: ../../.././server/include/screenint.h
Xxvrop.o: ../../.././server/include/miscstruct.h
Xxvrop.o: ../../.././server/include/misc.h ../../.././server/include/os.h
Xxvrop.o: ../../.././server/include/region.h
Xxvrop.o: ../../.././server/include/pixmap.h ../../.././server/include/gc.h
Xxvrop.o: ../../.././server/include/colormap.h
Xxvrop.o: ../../.././server/include/windowstr.h
Xxvrop.o: ../../.././server/include/window.h
Xxvrop.o: ../../.././server/include/pixmapstr.h
Xxvrop.o: ../../.././server/include/regionstr.h
Xxvrop.o: ../../.././server/include/cursor.h
Xxvrop.o: ../../.././server/include/property.h
Xxvrop.o: ../../.././server/include/resource.h ../../.././server/include/dix.h
Xxvrop.o: ../../.././server/include/gcstruct.h ../../.././fonts/include/font.h
Xxvrop.o: ../../.././fonts/include/fontos.h ../../.././X11/Xmd.h
Xxvrop.o: ../../.././server/include/dixstruct.h ../include/Xv.h
Xxvrop.o: ../include/Xvproto.h ../include/xvdix.h
Xxvrop.o: ../../.././server/ddx/dec/ws/pmagro.h
Xxvrop.o: ../../.././server/ddx/dec/ws/bt463.h
Xxvrop.o: ../../.././server/ddx/dec/ws/bt431.h
Xxvrop.o: ../../.././server/ddx/dec/ws/i2c.h
Xxvrop.o: ../../.././server/ddx/dec/ws/rop.h
Xxvrop.o: ../../.././server/ddx/dec/cfb/cfb.h /usr/include/machine/cpuconf.h
Xxvrop.o: ../include/xvrop.h
END_OF_FILE
if test 13884 -ne `wc -c <'extensions/xv/server/Makefile'`; then
    echo shar: \"'extensions/xv/server/Makefile'\" unpacked with wrong size!
fi
# end of 'extensions/xv/server/Makefile'
fi
if test -f 'extensions/xv/server/ddx/sunrop/pip_xv.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extensions/xv/server/ddx/sunrop/pip_xv.c'\"
else
echo shar: Extracting \"'extensions/xv/server/ddx/sunrop/pip_xv.c'\" \(13507 characters\)
sed "s/^X//" >'extensions/xv/server/ddx/sunrop/pip_xv.c' <<'END_OF_FILE'
X/*
X** File: 
X**
X**   pip_xv.c -- XV Support routines for Picture In a Picture Option Hardware.
X**               The routines in this file interface with the xvrop.c module.
X**
X**		Copyright(c) 1991, RasterOps, Inc.
X**
X** Author: 
X**
X**   Andy Goodrich (RasterOps, Inc.)
X**
X** Revisions:
X**
X**   29.09.91 Goodrich
X**     - calling sequences and routine names are based on those in the file
X**       mit/server/ddx/dec/rop/libpip.c
X**
X*/
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/file.h>
X#include <sys/time.h>
X#include <errno.h>
X#include <sys/ioctl.h>
X
X#ifdef NOTDEF
X#include "misc.h" /* GET MAXSCREENS SYMBOL */
X#endif NOTDEF
X
X#include "pip_impl.h"
X#include "pip_obj.h"
X#include "libpip.h"
X#include "sun.h"
X#include "sunCG8C.h"
X
Xextern fbFd sunFbs[];
X
X/* DCC MOD --- MAINTAIN OUR OWN VECTOR OF PIP SCREEN STRUCTURES */
X
X#ifndef original
Xstatic Pip_Object *pipScreens[3]; /* AT MOST 3 SCREENS */
X#define HALFWAY         ((unsigned long)1<<31)
X#define AFTER(ta, tb)   ((tb) - (ta) >=  HALFWAY)
X#define BEFORE(ta, tb)  ((ta) - (tb) >=  HALFWAY)
X#endif original
X
X/*"fill_video_enable"
X *
X *	Fill a region of video enable memory to a value.
X */
Xfill_video_enable(prop, left, top, width, height, write_ok)
X    Pip_Obj	  *prop;	/* -> PIP object to access. */
X    int		  left;		/* =  left side of area to fill. */
X    int		  top;		/* =  top of area to fill. */
X    int       width;	/* =  width of area to fill. */
X    int       height;	/* =  height of area to fill. */
X	u_int	  write_ok;	/* ~= 0 if allow video writes, 0 if not. */
X{
X	(*prop->fill_video_enable)(prop, left, top, width, height, (write_ok)?-1:0);
X}
X
X/*"pip_active"
X *
X *	Return status of pip digitization.
X *
X *		= 1 if pip actively digitizing video
X *		= 0 if pip not digitizing video
X */
Xpip_active(prop)
X    Pip_Obj *prop;	/* -> PIP object to access. */
X{
X	Pip_Status	status;		/* Status of pip video generation. */
X
X	(*prop->status)(prop, &status);
X	return status.pip_generating;
X}
X
X/*"pip_brightness"
X *
X *  Set the color brightness for the incoming pip signal. This is 
X *  controlled by a register in analog implementations and a
X *  DCSC load in digital implementations.
X */
Xvoid pip_brightness(prop, level)
X    Pip_Obj *prop;	/* -> PIP object to access. */
X    int     level;	/* =  level of brightness (-1000 to 1000). */
X{
X	Pip_Levels	levels;		/* PIP color levels. */
X
X	(*prop->get_levels)(prop, &levels);
X	levels.brightness = level;
X	(*prop->set_levels)(prop, &levels);
X}
X
X/*"pip_contrast"
X *
X *  Set the color contrast for the incoming pip signal. This is 
X *  controlled by a register in analog implementations and a
X *  DCSC load in digital implementations.
X */
Xvoid pip_contrast(prop, level)
X    Pip_Obj *prop;	/* -> PIP object to access. */
X    int     level;	/* =  level of contrast (-1000 to 1000). */
X{
X	Pip_Levels	levels;		/* PIP color levels. */
X
X	(*prop->get_levels)(prop, &levels);
X	levels.brightness = level;
X	(*prop->set_levels)(prop, &levels);
X}
X
X/*"pip_dst_area"
X *
X *	Set the destination (output) area for the pip.
X */
Xvoid pip_dst_area(prop, left, top, width, height)
X    Pip_Obj	  *prop;	/* -> PIP object to access. */
X    int		  left;		/* =  left side of destination(output) area. */
X    int		  top;		/* =  top of destination(output) area. */
X    int       width;	/* =  width of destination(output) area. */	
X    int       height;	/* =  height of destination(output) area. */
X{
X
X#ifdef original
X	Pip_Src_Area	area;	/* Source signal area. */
X	(*prop->get_source_area)(prop, &area);
X	area.left = left;
X	area.top = top;
X	area.width = width;
X	area.height = height;
X	(*prop->set_source_area)(prop, &area);
X#else
X	Pip_Dst_Area	area;	/* Destination signal area. */
X	area.horizontal_flip = 0;
X	area.vertical_flip = 0;
X	area.left = left;
X	area.top = top;
X	area.width = width;
X	area.height = height;
X	(*prop->set_destination_area)(prop, &area);
X#endif
X}
X
X/*"pip_hue"
X *
X *  Set the color hue for the incoming pip signal. This is 
X *  controlled by a register. 
X */
Xvoid pip_hue(prop, level)
X    Pip_Obj *prop;	/* -> PIP object to access. */
X    int     level;	/* =  level of hue (-1000 to 1000). */
X{
X	Pip_Levels	levels;		/* PIP color levels. */
X
X	(*prop->get_levels)(prop, &levels);
X	levels.hue = level;
X	(*prop->set_levels)(prop, &levels);
X}
X
Xpip_close(index)
Xint index;
X{
X  xfree(pipScreens[index]);
X  pipScreens[index] = (Pip_Object *)0;
X}
X
X#ifdef original
X/*"pip_init"
X *
X *	Initialize pip hardware to an operable state. 
X *
X *		-> pip object for frame buffer index provided
X *		=  0 if no pip possible on frame buffer given
X */
XPip_Obj *pip_init(index, type)
X     int index;	/* =  index of frame buffer to get pip of. */
X     int type;	/* =  type of video source: see libpip.h */
X{
X	TcPrivate	*fbpr;	/* Frame buffer private data. */
X	Pip_Obj		*prop;	/* Object to return after initializing it. */
X
X	/*
X	 *	Get pointer to the pip object associated with this device.
X	 *	If there is no currently allocated, try to allocate one.
X	 *	If that fails return a zero. 
X	 */
X  	if ( !(prop = (Pip_Obj *)sunFbs[index].xvPriv) )
X	{
X		if ( (fbpr = (TcPrivate *)sunFbs[index].fbPriv) &&
X			 !strcmp(fbpr->device_type, "CG8") )	
X		{
X			/*####*/
X		}
X		else
X		{
X		}
X	}
X
X	switch( type & PIP_SOURCE_TYPE )
X	{
X	  default:
X	  case PIP_COMPOSITE: type = PS_COMPOSITE; break;
X	  case PIP_SVIDEO:    type = PS_S_VIDEO;   break;
X	  case PIP_RGB:       type = PS_RGB;       break;
X	} 
X	(*prop->initialize)(prop, type);
X  
X  	return prop;
X}
X#else
X/*"pip_init"
X *
X *	Initialize pip hardware to an operable state. 
X *
X *		-> pip object for frame buffer index provided
X *		=  0 if no pip possible on frame buffer given
X */
XPip_Obj *pip_init(index, type)
X     int index;	/* =  index of frame buffer to get pip of. */
X     int type;	/* =  type of video source: see libpip.h */
X{
X  Pip_Object *this;
X  Pip_Fb_Type host_fb; /* Host frame buffer type (this buffer!). */
X  Pip_Source source; /* Type of source to initialize to. */
X
X  /*
X   *	Get pointer to the pip object associated with this device.
X   *	If there is no currently allocated, try to allocate one.
X   *	If that fails return a zero. 
X   */
X  if (!(this = pipScreens[index]))
X    {
X      if (!(this = (Pip_Object *)xv_tcl_open(sunFbs[index].fd, 0)))
X	{
X	  return (Pip_Obj *)0;
X	}
X      pipScreens[index] = this;
X    }
X  
X  switch( type & PIP_SOURCE_TYPE )
X    {
X    default:
X    case PIP_COMPOSITE: source.type = PS_COMPOSITE; break;
X    case PIP_SVIDEO:    source.type = PS_S_VIDEO;   break;
X    case PIP_RGB:       source.type = PS_RGB;       break;
X    } 
X
X  switch( type & PIP_SOURCE_TIMING )
X    {
X    default:
X    case PIP_NTSC: 	source.timing = PT_NTSC; 	break;
X    case PIP_PAL: 	source.timing = PT_PAL; 	break;
X    case PIP_SECAM: 	source.timing = PT_SECAM; 	break;
X    } 
X
X  host_fb.pitch = 1152;
X  host_fb.frequency = -1;
X
X  (*this->trvec.initialize)(this, &source, &host_fb);
X
X  return &this->trvec;
X
X}
X#endif original
X
X/*"pip_input_connected"
X *
X *	Return status of pip digitization.
X *
X *		= 1 if pip actively digitizing video
X *		= 0 if pip not digitizing video
X */
Xpip_input_connected(prop)
X    Pip_Obj *prop;	/* -> PIP object to access. */
X{
X	Pip_Status	status;		/* Status of pip video generation. */
X
X	(*prop->status)(prop, &status);
X	return status.active_source;
X}
X
X/*"pip_installed"
X *
X *	Return if a pip is installed for a given pip object.
X *
X *		= 1 if pip present
X *		= 0 if pip not present
X */
Xpip_installed(index)
X
Xint index;
X
X{
X  Pip_Object *this;
X
X  if (!(this = pipScreens[index]))
X    {
X      if (!(this = (Pip_Object *)xv_tcl_open(sunFbs[index].fd, 0)))
X	{
X	  return 0;
X	}
X      pipScreens[index] = this;
X    }
X
X  return 1;
X}
X
X/*"pip_priority"
X *	
X *	Set priority of PIP relative to processor accesses.
X */
Xpip_priority(prop, prio)
X    Pip_Obj 	  *prop;	/* -> PIP object to access. */
X     unsigned int prio;		/* =  priority to set. */
X{
X}
X
X/*"pip_off"
X *
X *	Turn off pip and return its previous operational state.
X */
Xpip_off(prop, wait)
X    Pip_Obj *prop;	/* -> PIP object to access. */
X    int 	wait;	/* =  1 if should wait for pip to actually turn off. */
X{
X  unsigned long entryTime,currentTime;
X  struct timeval to;
X  Pip_Status	status,old_status;
X  int onoff;
X
X  (*prop->status)(prop, &old_status);
X
X  onoff = old_status.pip_on;
X
X  (*prop->off)(prop, wait);
X  if ( wait )
X    {          
X      entryTime = currentTime = GetTimeInMillis();
X      while (BEFORE(currentTime, entryTime+100))
X	{
X	  (*prop->status)(prop, &status);
X	  if (!status.pip_generating || !status.pip_on) return onoff;
X	  currentTime = GetTimeInMillis();
X	  to.tv_sec = 0;             /* Sleep for 1 millisecond */
X	  to.tv_usec = 1000;         /* (actually 4 because of */
X	  select(0,0,0,0,&to);       /* scheduler granularity)   */
X	}
X      return onoff;
X    }
X
X  return onoff;
X
X}
X
X/*"pip_off_with_timeout"
X *
X *	Turn off pip and return true if it turned on; otherwise false
X *
X *		= 1 if wait was zero, or pip has turned off
X *		= 0 if wait was one, and pip did not turn off
X */
Xpip_off_with_timeout(prop, wait)
X    Pip_Obj *prop;	/* -> PIP object to access. */
X    int 	wait;	/* =  1 if should wait for pip to actually turn off. */
X{
X	Pip_Status	status;		/* Status of pip video generation. */
X	unsigned long entryTime,currentTime;
X	struct timeval to;
X
X	(*prop->off)(prop, 0);
X
X	if ( wait )
X	{          
X	  entryTime = currentTime = GetTimeInMillis();
X	  while (BEFORE(currentTime, entryTime+100))
X	    {
X	      (*prop->status)(prop, &status);
X	      if (!status.pip_generating || !status.pip_on) return 1;
X	      currentTime = GetTimeInMillis();
X	      to.tv_sec = 0;             /* Sleep for 1 millisecond */
X	      to.tv_usec = 1000;         /* (actually 4 because of */
X	      select(0,0,0,0,&to);       /* scheduler granularity)   */
X	    }
X	  return 0;
X	}
X	else
X	{
X		return 1;
X	}
X}
X
X/*"pip_on"
X *
X *	Turn on pip and return its previous operational state.
X */
Xpip_on(prop)
X    Pip_Obj *prop;	/* -> PIP object to access. */
X{
X	return (*prop->on)(prop); 
X}
X
X/*"pip_one_shot"
X *
X *	Turn on pip and return its previous operational state.
X *
X *		= 1 if successfully turned on pip
X *		= 0 if pip did not turn on
X */
Xpip_one_shot(prop,wait)
X    Pip_Obj *prop;	/* -> PIP object to access. */
X    int 	wait;	/* =  1 if should wait for pip to turn actually on. */
X{
X	(*prop->one_shot)(prop, wait);
X	return 1;
X}
X
X/*"pip_on_with_timeout"
X *
X *	Turn on pip and return its previous operational state.
X *
X *		= 1 if successfully turned on pip
X *		= 0 if pip did not turn on
X */
Xpip_on_with_timeout(prop,wait)
X    Pip_Obj *prop;	/* -> PIP object to access. */
X    int 	wait;	/* =  1 if should wait for pip to turn actually on. */
X{
X	Pip_Status	status;		/* Status of pip video generation. */
X	unsigned long entryTime,currentTime;
X	struct timeval to;
X
X	(*prop->on)(prop);
X
X	if ( wait )
X	{          
X	  entryTime = currentTime = GetTimeInMillis();
X	  while (BEFORE(currentTime, entryTime+100))
X	    {
X	      (*prop->status)(prop, &status);
X	      if (status.pip_on && status.pip_generating) return 1;
X	      currentTime = GetTimeInMillis();
X	      to.tv_sec = 0;             /* Sleep for 1 millisecond */
X	      to.tv_usec = 1000;         /* (actually 4 because of */
X	      select(0,0,0,0,&to);       /* scheduler granularity)   */
X	    }
X	  return 0;
X	}
X	else
X	{
X		return 1;
X	}
X}
X
X/*"pip_saturation"
X *
X *  Set the color saturation level for the incoming pip
X *  signal. This is controlled by a register.
X */
Xvoid pip_saturation(prop, level)
X    Pip_Obj *prop;	/* -> PIP object to access. */
X    int	 	level;  /* =  level of saturation (-1000 to 1000). */
X{
X	Pip_Levels	levels;		/* PIP color levels. */
X
X	(*prop->get_levels)(prop, &levels);
X	levels.saturation = level;
X	(*prop->set_levels)(prop, &levels);
X}
X
X/*"pip_source_type"
X *
X *	Set the type of source being used. This involves setting the source
X *	bit in pip control status register 0, and changing certain dmsd and
X *	dcsc chip values.
X */
Xvoid pip_source_type(prop, type)
X    Pip_Obj *prop;	/* -> PIP object to access. */
X    int type;       /* =  type of source. */
X{
X	Pip_Source	source;	/* PIP's source parameters. */
X
X	(*prop->get_source_type)(prop, &source);
X	switch( type & PIP_SOURCE_TYPE )
X    {
X      default:
X      case PIP_COMPOSITE: source.type = PS_COMPOSITE; break;
X      case PIP_SVIDEO:    source.type = PS_S_VIDEO;   break;
X      case PIP_RGB:       source.type = PS_RGB;       break;
X    } 
X	(*prop->set_source_type)(prop, &source);
X}
X
X/*"pip_src_area"
X *
X *	Set the portion of the source signal to be sampled.
X *	Note the y specification is in scan lines, but the registers
X *	take scan line pairs, so we divide by 2!
X */
Xvoid pip_src_area(prop, left, top, width, height)
X    Pip_Obj *prop;		/* -> PIP object to access. */
X    int		  left;		/* =  left side of source signal area. */
X    int		  top;		/* =  top of source signal area. */
X    int       width;	/* =  width of source signal area. */	
X    int       height;	/* =  height of source signal area. */
X{
X	Pip_Src_Area	area;	/* Source signal area. */
X	int xoff=102;
X	int yoff=14;
X
X	area.left = left + xoff;
X	area.top = top + yoff;
X	area.width = width;
X	area.height = height;
X	(*prop->set_source_area)(prop, &area);
X}
X
X/*"pip_which_screen"
X *
X *	Return the number of the screen associated with a PIP object.
X *
X *		= number of screen if found
X *		= -1 if not found
X */
Xint pip_which_screen(prop)
X    Pip_Obj *prop;		/* -> PIP object to access. */
X{
X#ifdef NOTDEF
X  int i;
X  for(i = 0; i < MAXSCREENS; i++) {
X    if(prop == &ropInfo[i])
X      return i;
X  }
X  fprintf(stderr, "pip_xv.c: which_screen: screen not found!\n", i);
X  return -1;
X#endif NOTDEF
X}
END_OF_FILE
if test 13507 -ne `wc -c <'extensions/xv/server/ddx/sunrop/pip_xv.c'`; then
    echo shar: \"'extensions/xv/server/ddx/sunrop/pip_xv.c'\" unpacked with wrong size!
fi
# end of 'extensions/xv/server/ddx/sunrop/pip_xv.c'
fi
if test -f 'server/ddx/cfb32/cfb.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/ddx/cfb32/cfb.h'\"
else
echo shar: Extracting \"'server/ddx/cfb32/cfb.h'\" \(10581 characters\)
sed "s/^X//" >'server/ddx/cfb32/cfb.h' <<'END_OF_FILE'
X/************************************************************
XCopyright 1987 by Sun Microsystems, Inc. Mountain View, CA.
X
X                    All Rights Reserved
X
XPermission  to  use,  copy,  modify,  and  distribute   this
Xsoftware  and  its documentation for any purpose and without
Xfee is hereby granted, provided that the above copyright no-
Xtice  appear  in all copies and that both that copyright no-
Xtice and this permission notice appear in  supporting  docu-
Xmentation,  and  that the names of Sun or MIT not be used in
Xadvertising or publicity pertaining to distribution  of  the
Xsoftware  without specific prior written permission. Sun and
XM.I.T. make no representations about the suitability of this
Xsoftware for any purpose. It is provided "as is" without any
Xexpress or implied warranty.
X
XSUN DISCLAIMS ALL WARRANTIES WITH REGARD TO  THIS  SOFTWARE,
XINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FIT-
XNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SUN BE  LI-
XABLE  FOR  ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,  DATA  OR
XPROFITS,  WHETHER  IN  AN  ACTION OF CONTRACT, NEGLIGENCE OR
XOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
XTHE USE OR PERFORMANCE OF THIS SOFTWARE.
X
X********************************************************/
X
X#include "pixmap.h"
X#include "region.h"
X#include "gc.h"
X#include "colormap.h"
X#include "miscstruct.h"
X#include "servermd.h"
X#include "mfb.h"
X
X#ifdef MULTIDEPTH
X#include "cfbmap.h"
X#endif MULTIDEPTH
X
Xextern Bool cfbScreenInit();
Xextern void cfbQueryBestSize();
Xextern Bool cfbCreateWindow();
Xextern Bool cfbPositionWindow();
Xextern Bool cfbChangeWindowAttributes();
Xextern Bool cfbMapWindow();
Xextern Bool cfbUnmapWindow();
Xextern Bool cfbDestroyWindow();
X
Xextern Bool cfbRealizeFont();
Xextern Bool cfbUnrealizeFont();
Xextern Bool cfbRealizeCursor();
Xextern Bool cfbUnrealizeCursor();
Xextern Bool cfbScreenSaver();
Xextern Bool cfbCreateGC();
X
Xextern PixmapPtr cfbCreatePixmap();
Xextern Bool cfbDestroyPixmap();
X
Xextern void cfbCopyWindow();
Xextern void cfbPaintWindow();
X
Xextern void miPolyFillRect();
Xextern void cfbPolyFillRect();
Xextern void miPolyFillArc();
Xextern void cfbZeroPolyArcSS8Copy(), cfbZeroPolyArcSS8Xor();
Xextern void cfbZeroPolyArcSS8General();
Xextern void cfbLineSS(), cfbLineSD(), cfbSegmentSS(), cfbSegmentSD();
Xextern void cfb8LineSS1Rect(), cfb8SegmentSS1Rect ();
Xextern RegionPtr cfbCopyPlane();
Xextern void cfbPolyFillArcSolidCopy(),cfbPolyFillArcSolidXor();
Xextern void cfbPolyFillArcSolidGeneral();
Xextern RegionPtr cfbCopyArea();
Xextern void cfbFillPoly1RectCopy(), cfbFillPoly1RectGeneral();
X
Xextern void cfbPushPixels8();
Xextern void cfbSetSpans();
Xextern void cfbGetSpans();
Xextern void cfbSolidSpansCopy(), cfbSolidSpansXor(), cfbSolidSpansGeneral();
Xextern void cfbUnnaturalTileFS();
Xextern void cfbUnnaturalStippleFS();
Xextern void cfbTile32FSCopy(), cfbTile32FSGeneral();
Xextern void cfb8Stipple32FS(), cfb8OpaqueStipple32FS();
Xextern void cfbFillBoxTileOdd();
Xextern void cfbFillBoxTile32();
Xextern void cfbFillBoxSolid();
X
Xextern void cfbTEGlyphBlt();
Xextern void cfbTEGlyphBlt8();
Xextern void cfbPolyGlyphBlt8();
Xextern void cfbPolyGlyphRop8();
Xextern void cfbImageGlyphBlt8();
X
Xextern void cfbSaveAreas();
Xextern void cfbRestoreAreas();
X
X/* included from mfb.h; we can't include mfb.h directly because of other 
X * conflicts */
Xextern void mfbPushPixels();
Xextern void mfbSetSpans();
Xextern void mfbGetSpans();
Xextern void mfbUnnaturalTileFS();
Xextern void mfbUnnaturalStippleFS();
Xextern Bool mfbRealizeFont();
Xextern Bool mfbUnrealizeFont();
Xextern void mfbQueryBestSize();
Xextern RegionPtr mfbPixmapToRegion();
Xextern void mfbCopyRotatePixmap();
X
Xextern PixmapPtr cfbCopyPixmap();
Xextern void  cfbConvertRects();
Xextern void  miPolyArc();
Xextern void  miFillPolyArc();
X
Xextern void cfbPutImage();
Xextern void cfbGetImage();
Xextern RegionPtr miCopyArea();
Xextern RegionPtr miCopyPlane();
Xextern void cfbPolyPoint();
Xextern void miPushPixels();
X
X#ifdef	STATIC_COLOR
Xextern void cfbInstallColormap();
Xextern void cfbUninstallColormap();
Xextern int cfbListInstalledColormaps();
X#endif
Xextern void cfbResolveColor();
Xextern Bool cfbInitializeColormap();
Xextern Bool cfbCreateDefColormap();
X
Xextern void cfbCopyRotatePixmap();
Xextern void cfbYRotatePixmap();
Xextern void cfbXRotatePixmap();
Xextern void cfbPadPixmap();
X
X/*
X   private filed of pixmap
X   pixmap.devPrivate = (unsigned int *)pointer_to_bits
X   pixmap.devKind = width_of_pixmap_in_bytes
X*/
X
Xextern int  cfbGCPrivateIndex;
Xextern int  cfbWindowPrivateIndex;
X
X/* private field of GC */
Xtypedef struct {
X    unsigned char       rop;            /* special case rop values */
X    /* next two values unused in cfb, included for compatibility with mfb */
X    unsigned char       ropOpStip;      /* rop for opaque stipple */
X    /* this value is ropFillArea in mfb, usurped for cfb */
X    unsigned char       oneRect;	/*  drawable has one clip rect */
X    unsigned		fExpose:1;	/* callexposure handling ? */
X    unsigned		freeCompClip:1;
X    PixmapPtr		pRotatedPixmap;
X    RegionPtr		pCompositeClip; /* FREE_CC or REPLACE_CC */
X    unsigned long	xor, and;	/* reduced rop values */
X    } cfbPrivGC;
X
Xtypedef cfbPrivGC	*cfbPrivGCPtr;
X
X#define cfbGetGCPrivate(pGC)	((cfbPrivGCPtr)\
X	(pGC)->devPrivates[cfbGCPrivateIndex].ptr)
X
X/* way to carry RROP info around */
Xtypedef struct {
X    unsigned char	rop;
X    unsigned long	xor, and;
X} cfbRRopRec, *cfbRRopPtr;
X
X/* private field of window */
Xtypedef struct {
X    unsigned	char fastBorder; /* non-zero if border is 32 bits wide */
X    unsigned	char fastBackground;
X    unsigned short unused; /* pad for alignment with Sun compiler */
X    DDXPointRec	oldRotate;
X    PixmapPtr	pRotatedBackground;
X    PixmapPtr	pRotatedBorder;
X    } cfbPrivWin;
X
X/* Common macros for extracting drawing information */
X
X#ifndef MULTIDEPTH
X
X#define cfbGetTypedWidth(pDrawable,wtype) (\
X    (((pDrawable)->type == DRAWABLE_WINDOW) ? \
X     (int) (((PixmapPtr)((pDrawable)->pScreen->devPrivates))->devKind) : \
X     (int)(((PixmapPtr)pDrawable)->devKind)) / sizeof (wtype))
X
X#define cfbGetByteWidth(pDrawable) cfbGetTypedWidth(pDrawable, unsigned char)
X
X#define cfbGetLongWidth(pDrawable) cfbGetTypedWidth(pDrawable, unsigned long)
X    
X#define cfbGetTypedWidthAndPointer(pDrawable, width, pointer, wtype, ptype) {\
X    PixmapPtr   _pPix; \
X    if ((pDrawable)->type == DRAWABLE_WINDOW) \
X	_pPix = (PixmapPtr) (pDrawable)->pScreen->devPrivate; \
X    else \
X	_pPix = (PixmapPtr) (pDrawable); \
X    (pointer) = (ptype *) _pPix->devPrivate.ptr; \
X    (width) = ((int) _pPix->devKind) / sizeof (wtype); \
X}
X
X#define cfbGetByteWidthAndPointer(pDrawable, width, pointer) \
X    cfbGetTypedWidthAndPointer(pDrawable, width, pointer, unsigned char, unsigned char)
X
X#define cfbGetLongWidthAndPointer(pDrawable, width, pointer) \
X    cfbGetTypedWidthAndPointer(pDrawable, width, pointer, unsigned long, unsigned long)
X
X#define cfbGetPixelWidthAndPointer(pDrawable, width, pointer) \
X    cfbGetTypedWidthAndPointer(pDrawable, width, pointer, PixelType, PixelType)
X
X#define cfbGetWindowTypedWidthAndPointer(pWin, width, pointer, wtype, ptype) {\
X    PixmapPtr	_pPix = (PixmapPtr) (pWin)->drawable.pScreen->devPrivate; \
X    (pointer) = (ptype *) _pPix->devPrivate.ptr; \
X    (width) = ((int) _pPix->devKind) / sizeof (wtype); \
X}
X
X#define cfbGetWindowLongWidthAndPointer(pWin, width, pointer) \
X    cfbGetWindowTypedWidthAndPointer(pWin, width, pointer, unsigned long, unsigned long)
X
X#define cfbGetWindowByteWidthAndPointer(pWin, width, pointer) \
X    cfbGetWindowTypedWidthAndPointer(pWin, width, pointer, unsigned char, unsigned char)
X
X#else MULTIDEPTH
X
Xextern int cfbScreenPrivateIndex;
X
X#define cfbGetTypedWidth(pDrawable,wtype) (\
X    (((pDrawable)->type == DRAWABLE_WINDOW) ? \
X     (int) (((PixmapPtr)((pDrawable)->pScreen->devPrivates[cfbScreenPrivateIndex].ptr))->devKind) : \
X     (int)(((PixmapPtr)pDrawable)->devKind)) / sizeof (wtype))
X
X#define cfbGetByteWidth(pDrawable) cfbGetTypedWidth(pDrawable, unsigned char)
X
X#define cfbGetLongWidth(pDrawable) cfbGetTypedWidth(pDrawable, unsigned long)
X    
X#define cfbGetTypedWidthAndPointer(pDrawable, width, pointer, wtype, ptype) {\
X    PixmapPtr   _pPix; \
X    if ((pDrawable)->type == DRAWABLE_WINDOW) \
X	_pPix = (PixmapPtr) (pDrawable)->pScreen->devPrivates[cfbScreenPrivateIndex].ptr; \
X    else \
X	_pPix = (PixmapPtr) (pDrawable); \
X    (pointer) = (ptype *) _pPix->devPrivate.ptr; \
X    (width) = ((int) _pPix->devKind) / sizeof (wtype); \
X}
X
X#define cfbGetByteWidthAndPointer(pDrawable, width, pointer) \
X    cfbGetTypedWidthAndPointer(pDrawable, width, pointer, unsigned char, unsigned char)
X
X#define cfbGetLongWidthAndPointer(pDrawable, width, pointer) \
X    cfbGetTypedWidthAndPointer(pDrawable, width, pointer, unsigned long, unsigned long)
X
X#define cfbGetPixelWidthAndPointer(pDrawable, width, pointer) \
X    cfbGetTypedWidthAndPointer(pDrawable, width, pointer, PixelType, PixelType)
X
X#define cfbGetWindowTypedWidthAndPointer(pWin, width, pointer, wtype, ptype) {\
X    PixmapPtr	_pPix = (PixmapPtr) (pWin)->drawable.pScreen->devPrivates[cfbScreenPrivateIndex].ptr; \
X    (pointer) = (ptype *) _pPix->devPrivate.ptr; \
X    (width) = ((int) _pPix->devKind) / sizeof (wtype); \
X}
X
X#define cfbGetWindowLongWidthAndPointer(pWin, width, pointer) \
X    cfbGetWindowTypedWidthAndPointer(pWin, width, pointer, unsigned long, unsigned long)
X
X#define cfbGetWindowByteWidthAndPointer(pWin, width, pointer) \
X    cfbGetWindowTypedWidthAndPointer(pWin, width, pointer, unsigned char, unsigned char)
X
X#endif MULTIDEPTH
X
X/* Macros which handle a coordinate in a single register */
X
X/* Most compilers will convert divide by 65536 into a shift, if signed
X * shifts exist.  If your machine does arithmetic shifts and your compiler
X * can't get it right, add to this line.
X */
X
X/* mips compiler - what a joke - it CSEs the 65536 constant into a reg
X * forcing as to use div instead of shift.  Let's be explicit.
X */
X
X#if defined(mips) || defined(sparc)
X#define GetHighWord(x) (((int) (x)) >> 16)
X#else
X#define GetHighWord(x) (((int) (x)) / 65536)
X#endif
X
X#if IMAGE_BYTE_ORDER == MSBFirst
X#define intToCoord(i,x,y)   (((x) = GetHighWord(i)), ((y) = (int) ((short) (i))))
X#define coordToInt(x,y)	(((x) << 16) | (y))
X#define intToX(i)	(GetHighWord(i))
X#define intToY(i)	((int) ((short) i))
X#else
X#define intToCoord(i,x,y)   (((x) = (int) ((short) (i))), ((y) = GetHighWord(i)))
X#define coordToInt(x,y)	(((y) << 16) | (x))
X#define intToX(i)	((int) ((short) (i)))
X#define intToY(i)	(GetHighWord(i))
X#endif
END_OF_FILE
if test 10581 -ne `wc -c <'server/ddx/cfb32/cfb.h'`; then
    echo shar: \"'server/ddx/cfb32/cfb.h'\" unpacked with wrong size!
fi
# end of 'server/ddx/cfb32/cfb.h'
fi
if test -f 'server/ddx/cfb32/cfbrctstp8.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/ddx/cfb32/cfbrctstp8.c'\"
else
echo shar: Extracting \"'server/ddx/cfb32/cfbrctstp8.c'\" \(13554 characters\)
sed "s/^X//" >'server/ddx/cfb32/cfbrctstp8.c' <<'END_OF_FILE'
X/*
X * Fill 32 bit stippled rectangles for 8 bit frame buffers
X */
X/*
XCopyright 1989 by the Massachusetts Institute of Technology
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted,
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in
Xsupporting documentation, and that the name of M.I.T. not be used in
Xadvertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.  M.I.T. makes no
Xrepresentations about the suitability of this software for any
Xpurpose.  It is provided "as is" without express or implied warranty.
X
XAuthor: Keith Packard, MIT X Consortium
X
X*/
X
X/* $XConsortium: cfbrctstp8.c,v 1.13 91/04/10 11:41:33 keith Exp $ */
X
X#include "X.h"
X#include "Xmd.h"
X#include "servermd.h"
X#include "gcstruct.h"
X#include "window.h"
X#include "pixmapstr.h"
X#include "scrnintstr.h"
X#include "windowstr.h"
X
X#include "cfb.h"
X#include "cfbmskbits.h"
X#include "cfb8bit.h"
X
X#if (PPW == 4)
X
X
Xvoid
Xcfb8FillRectOpaqueStippled32 (pDrawable, pGC, nBox, pBox)
X    DrawablePtr	    pDrawable;
X    GCPtr	    pGC;
X    int		    nBox;	/* number of boxes to fill */
X    register BoxPtr pBox;	/* pointer to list of boxes to fill */
X{
X    unsigned long   *src;
X    int stippleHeight;
X
X    int nlwDst;		/* width in longwords of the dest pixmap */
X    int w;		/* width of current box */
X    register int h;	/* height of current box */
X    unsigned long startmask;
X    unsigned long endmask;	/* masks for reggedy bits at either end of line */
X    int nlwMiddle;	/* number of longwords between sides of boxes */
X    register int nlw;			/* loop version of nlwMiddle */
X    unsigned long *dstLine;
X    register unsigned long *dst;	/* pointer to bits we're writing */
X    unsigned long *dstTmp;
X    int y;				/* current scan line */
X
X    unsigned long *pbits;/* pointer to start of pixmap */
X    register unsigned long bits;	/* bits from stipple */
X    int	rot, lastStop, i;
X    register unsigned long  xor, and;
X    cfbPrivGCPtr	    devPriv;
X    PixmapPtr		    stipple;
X    int	    wEnd;
X
X    devPriv = ((cfbPrivGCPtr) pGC->devPrivates[cfbGCPrivateIndex].ptr);
X    stipple = devPriv->pRotatedPixmap;
X
X    cfb8CheckOpaqueStipple(pGC->alu, pGC->fgPixel, pGC->bgPixel, pGC->planemask);
X
X    stippleHeight = stipple->drawable.height;
X    src = (unsigned long *)stipple->devPrivate.ptr;
X
X    cfbGetLongWidthAndPointer (pDrawable, nlwDst, pbits)
X
X    while (nBox--)
X    {
X	w = pBox->x2 - pBox->x1;
X	h = pBox->y2 - pBox->y1;
X	y = pBox->y1;
X	dstLine = pbits + (pBox->y1 * nlwDst) + ((pBox->x1 & ~3) >> PWSH);
X	if (((pBox->x1 & PIM) + w) <= PPW)
X	{
X	    maskpartialbits(pBox->x1, w, startmask);
X	    nlwMiddle = 0;
X	    endmask = 0;
X	}
X	else
X	{
X	    maskbits (pBox->x1, w, startmask, endmask, nlwMiddle);
X	}
X	rot = (pBox->x1 & (31 & ~3));
X	pBox++;
X	y = y % stippleHeight;
X	if (cfb8StippleRRop == GXcopy)
X	{
X	    if (w < 64)
X	    {
X	    	while (h--)
X	    	{
X	    	    bits = src[y];
X	    	    y++;
X	    	    if (y == stippleHeight)
X		    	y = 0;
X	    	    if (rot)
X		    	RotBitsLeft(bits,rot);
X		    dst = dstLine;
X	    	    dstLine += nlwDst;
X	    	    if (startmask)
X	    	    {
X		    	*dst = *dst & ~startmask |
X				GetFourPixels (bits) & startmask;
X		    	dst++;
X		    	RotBitsLeft (bits, 4);
X	    	    }
X		    nlw = nlwMiddle;
X	    	    while (nlw--)
X	    	    {
X			*dst++ = GetFourPixels(bits);
X		    	RotBitsLeft (bits, 4);
X	    	    }
X	    	    if (endmask)
X	    	    {
X			*dst = *dst & ~endmask |
X			      GetFourPixels (bits) & endmask;
X	    	    }
X	    	}
X	    }
X	    else
X	    {
X		wEnd = 7 - (nlwMiddle & 7);
X		nlwMiddle = (nlwMiddle >> 3) + 1;
X	    	while (h--)
X	    	{
X		    bits = src[y];
X		    y++;
X		    if (y == stippleHeight)
X			y = 0;
X	    	    if (rot != 0)
X			RotBitsLeft (bits, rot);
X	    	    dstTmp = dstLine;
X	    	    dstLine += nlwDst;
X		    if (startmask)
X		    {
X			*dstTmp = *dstTmp & ~startmask |
X			       GetFourPixels (bits) & startmask;
X			dstTmp++;
X			RotBitsLeft (bits, 4);
X		    }
X		    w = 7 - wEnd;
X		    while (w--)
X		    {
X			nlw = nlwMiddle;
X			dst = dstTmp;
X			dstTmp++;
X			xor = GetFourPixels (bits);
X			while (nlw--)
X			{
X			    *dst = xor;
X			    dst += 8;
X			}
X			NextFourBits (bits);
X		    }
X		    nlwMiddle--;
X		    w = wEnd + 1;
X		    if (endmask)
X		    {
X			dst = dstTmp + (nlwMiddle << 3);
X			*dst = (*dst & ~endmask) |
X			       GetFourPixels (bits) & endmask;
X		    }
X		    while (w--)
X		    {
X			nlw = nlwMiddle;
X			dst = dstTmp;
X			dstTmp++;
X			xor = GetFourPixels (bits);
X			while (nlw--)
X			{
X			    *dst = xor;
X			    dst += 8;
X			}
X			NextFourBits (bits);
X		    }
X		    nlwMiddle++;
X		}
X	    }
X	}
X	else
X	{
X	    while (h--)
X	    {
X	    	bits = src[y];
X	    	y++;
X	    	if (y == stippleHeight)
X		    y = 0;
X	    	if (rot)
X		    RotBitsLeft(bits,rot);
X		dst = dstLine;
X	    	dstLine += nlwDst;
X	    	if (startmask)
X	    	{
X		    xor = GetFourBits(bits);
X		    *dst = MaskRRopPixels(*dst, xor, startmask);
X		    dst++;
X		    RotBitsLeft (bits, 4);
X	    	}
X		nlw = nlwMiddle;
X	    	while (nlw--)
X	    	{
X		    RRopFourBits(dst, GetFourBits(bits));
X		    dst++;
X		    RotBitsLeft (bits, 4);
X	    	}
X	    	if (endmask)
X	    	{
X		    xor = GetFourBits(bits);
X		    *dst = MaskRRopPixels(*dst, xor, endmask);
X	    	}
X	    }
X	}
X    }
X}
X
X
Xcfb8FillRectTransparentStippled32 (pDrawable, pGC, nBox, pBox)
X    DrawablePtr	    pDrawable;
X    GCPtr	    pGC;
X    int		    nBox;	/* number of boxes to fill */
X    BoxPtr 	    pBox;	/* pointer to list of boxes to fill */
X{
X    int		    x, y, w, h;
X    int		    nlwMiddle, nlwDst, nlwTmp;
X    unsigned long   startmask, endmask;
X    register unsigned long   *dst;
X    unsigned long   *dstLine, *pbits, *dstTmp;
X    unsigned long   *src;
X    register unsigned long   xor;
X    register unsigned long   bits, mask;
X    int		    rot;
X    int		    wEnd;
X    cfbPrivGCPtr    devPriv;
X    PixmapPtr	    stipple;
X    int		    stippleHeight;
X    register int    nlw;
X    
X    devPriv = ((cfbPrivGCPtr) pGC->devPrivates[cfbGCPrivateIndex].ptr);
X    stipple = devPriv->pRotatedPixmap;
X    src = (unsigned long *)stipple->devPrivate.ptr;
X    stippleHeight = stipple->drawable.height;
X
X    cfb8CheckStipple (pGC->alu, pGC->fgPixel, pGC->planemask);
X
X    cfbGetLongWidthAndPointer (pDrawable, nlwDst, pbits)
X
X    while (nBox--)
X    {
X	x = pBox->x1;
X    	w = pBox->x2 - x;
X	if (((x & PIM) + w) <= PPW)
X	{
X	    maskpartialbits(x, w, startmask);
X	    endmask = 0;
X	    nlwMiddle = 0;
X	}
X	else
X	{
X	    maskbits (x, w, startmask, endmask, nlwMiddle);
X	}
X	rot = (x & (31 & ~3));
X    	y = pBox->y1;
X    	dstLine = pbits + (y * nlwDst) + (x >> PWSH);
X    	h = pBox->y2 - y;
X	pBox++;
X	y %= stippleHeight;
X	if (cfb8StippleRRop == GXcopy)
X	{
X	    xor = devPriv->xor;
X	    if (w < 64)
X	    {
X	    	while (h--)
X	    	{
X		    bits = src[y];
X		    y++;
X		    if (y == stippleHeight)
X			y = 0;
X	    	    if (rot != 0)
X			RotBitsLeft (bits, rot);
X	    	    dst = dstLine;
X	    	    dstLine += nlwDst;
X	    	    if (startmask)
X	    	    {
X		    	mask = cfb8PixelMasks[GetFourBits(bits)];
X		    	*dst = (*dst & ~(mask & startmask)) |
X		       	       (xor & (mask & startmask));
X		    	dst++;
X		    	RotBitsLeft (bits, 4);
X	    	    }
X		    nlw = nlwMiddle;
X	    	    while (nlw--)
X	    	    {
X		    	WriteFourBits (dst,xor,GetFourBits(bits))
X		    	dst++;
X		    	RotBitsLeft (bits, 4);
X	    	    }
X	    	    if (endmask)
X	    	    {
X		    	mask = cfb8PixelMasks[GetFourBits(bits)];
X		    	*dst = (*dst & ~(mask & endmask)) |
X		       	       (xor & (mask & endmask));
X	    	    }
X	    	}
X	    }
X	    else
X	    {
X		wEnd = 7 - (nlwMiddle & 7);
X		nlwMiddle = (nlwMiddle >> 3) + 1;
X	    	while (h--)
X	    	{
X		    bits = src[y];
X		    y++;
X		    if (y == stippleHeight)
X			y = 0;
X	    	    if (rot != 0)
X			RotBitsLeft (bits, rot);
X	    	    dstTmp = dstLine;
X	    	    dstLine += nlwDst;
X		    if (startmask)
X		    {
X		    	mask = cfb8PixelMasks[GetFourBits(bits)];
X		    	*dstTmp = (*dstTmp & ~(mask & startmask)) |
X		       	       (xor & (mask & startmask));
X		    	dstTmp++;
X		    	RotBitsLeft (bits, 4);
X		    }
X		    w = 7 - wEnd;
X		    while (w--)
X		    {
X			nlw = nlwMiddle;
X			dst = dstTmp;
X			dstTmp++;
X#if defined(__GNUC__) && defined(mc68020)
X			mask = cfb8PixelMasks[GetFourBits(bits)];
X			xor = xor & mask;
X			mask = ~mask;
X			while (nlw--)
X			{
X			    *dst = (*dst & mask) | xor;
X			    dst += 8;
X			}
X			xor = devPriv->xor;
X#else
X#define SwitchBitsLoop(body) \
X	while (nlw--)	\
X	{		\
X	    body	\
X	    dst += 8;	\
X	}
X			SwitchFourBits(dst, xor, GetFourBits(bits));
X#undef SwitchBitsLoop
X#endif
X			NextFourBits (bits);
X		    }
X		    nlwMiddle--;
X		    w = wEnd + 1;
X		    if (endmask)
X		    {
X			mask = cfb8PixelMasks[GetFourBits(bits)];
X			dst = dstTmp + (nlwMiddle << 3);
X			*dst = (*dst & ~(mask & endmask)) |
X			       (xor &  (mask & endmask));
X		    }
X		    while (w--)
X		    {
X			nlw = nlwMiddle;
X			dst = dstTmp;
X			dstTmp++;
X#if defined(__GNUC__) && defined(mc68020)
X			mask = cfb8PixelMasks[GetFourBits(bits)];
X			xor = xor & mask;
X			mask = ~mask;
X			while (nlw--)
X			{
X			    *dst = (*dst & mask) | xor;
X			    dst += 8;
X			}
X			xor = devPriv->xor;
X#else
X#define SwitchBitsLoop(body) \
X	while (nlw--)	\
X	{		\
X	    body	\
X	    dst += 8;	\
X	}
X			SwitchFourBits(dst, xor, GetFourBits(bits));
X#undef SwitchBitsLoop
X#endif
X			NextFourBits (bits);
X		    }
X		    nlwMiddle++;
X		}
X	    }
X	}
X	else
X	{
X	    while (h--)
X	    {
X		bits = src[y];
X		y++;
X		if (y == stippleHeight)
X		    y = 0;
X	    	if (rot != 0)
X		    RotBitsLeft (bits, rot);
X	    	dst = dstLine;
X	    	dstLine += nlwDst;
X	    	if (startmask)
X	    	{
X		    xor = GetFourBits(bits);
X		    *dst = MaskRRopPixels(*dst, xor, startmask);
X		    dst++;
X		    RotBitsLeft (bits, 4);
X	    	}
X		nlw = nlwMiddle;
X	    	while (nlw--)
X	    	{
X		    RRopFourBits(dst, GetFourBits(bits));
X		    dst++;
X		    RotBitsLeft (bits, 4);
X	    	}
X	    	if (endmask)
X	    	{
X		    xor = GetFourBits(bits);
X		    *dst = MaskRRopPixels(*dst, xor, endmask);
X	    	}
X	    }
X	}
X    }
X}
X
X
Xvoid
Xcfb8FillRectStippledUnnatural (pDrawable, pGC, nBox, pBox)
X    DrawablePtr	    pDrawable;
X    GCPtr	    pGC;
X    int		    nBox;
X    register BoxPtr pBox;
X{
X    unsigned long   *pdstBase;	/* pointer to start of bitmap */
X    unsigned long   *pdstLine;	/* current destination line */
X    int		    nlwDst;	/* width in longwords of bitmap */
X    PixmapPtr	    pStipple;	/* pointer to stipple we want to fill with */
X    int		    nlwMiddle;
X    register int    nlw;
X    int		    x, y, w, h, xrem, xSrc, ySrc;
X    int		    stwidth, stippleWidth;
X    int		    stippleHeight;
X    register unsigned long  bits, inputBits;
X    register int    partBitsLeft;
X    int		    nextPartBits;
X    int		    bitsLeft, bitsWhole;
X    register unsigned long    *pdst;	/* pointer to current word in bitmap */
X    unsigned long   *srcTemp, *srcStart;
X    unsigned long   *psrcBase;
X    unsigned long   startmask, endmask;
X
X    if (pGC->fillStyle == FillStippled)
X	cfb8CheckStipple (pGC->alu, pGC->fgPixel, pGC->planemask);
X    else
X	cfb8CheckOpaqueStipple (pGC->alu, pGC->fgPixel, pGC->bgPixel, pGC->planemask);
X
X    if (cfb8StippleRRop == GXnoop)
X	return;
X
X    /*
X     *  OK,  so what's going on here?  We have two Drawables:
X     *
X     *  The Stipple:
X     *		Depth = 1
X     *		Width = stippleWidth
X     *		Words per scanline = stwidth
X     *		Pointer to pixels = pStipple->devPrivate.ptr
X     */
X
X    pStipple = pGC->stipple;
X
X    stwidth = pStipple->devKind >> 2;
X    stippleWidth = pStipple->drawable.width;
X    stippleHeight = pStipple->drawable.height;
X    psrcBase = (unsigned long *) pStipple->devPrivate.ptr;
X
X    /*
X     *	The Target:
X     *		Depth = PSZ
X     *		Width = determined from *pwidth
X     *		Words per scanline = nlwDst
X     *		Pointer to pixels = addrlBase
X     */
X
X    xSrc = pDrawable->x;
X    ySrc = pDrawable->y;
X
X    cfbGetLongWidthAndPointer (pDrawable, nlwDst, pdstBase)
X
X    /* this replaces rotating the stipple. Instead we just adjust the offset
X     * at which we start grabbing bits from the stipple.
X     * Ensure that ppt->x - xSrc >= 0 and ppt->y - ySrc >= 0,
X     * so that iline and xrem always stay within the stipple bounds.
X     */
X
X    xSrc += (pGC->patOrg.x % stippleWidth) - stippleWidth;
X    ySrc += (pGC->patOrg.y % stippleHeight) - stippleHeight;
X
X    bitsWhole = stippleWidth;
X
X    while (nBox--)
X    {
X	x = pBox->x1;
X	y = pBox->y1;
X	w = pBox->x2 - x;
X	h = pBox->y2 - y;
X	pBox++;
X	pdstLine = pdstBase + y * nlwDst + (x >> PWSH);
X	y = (y - ySrc) % stippleHeight;
X	srcStart = psrcBase + y * stwidth;
X	xrem = ((x & ~3) - xSrc) % stippleWidth;
X	if (((x & PIM) + w) < PPW)
X	{
X	    maskpartialbits (x, w, startmask);
X	    nlwMiddle = 0;
X	    endmask = 0;
X	}
X	else
X	{
X	    maskbits (x, w, startmask, endmask, nlwMiddle);
X	}
X	while (h--)
X	{
X    	    srcTemp = srcStart + (xrem >> 5);
X    	    bitsLeft = stippleWidth - (xrem & ~0x1f);
X	    NextUnnaturalStippleWord
X	    NextSomeBits (inputBits, (xrem & 0x1f));
X	    partBitsLeft -= (xrem & 0x1f);
X	    NextUnnaturalStippleBits
X	    nlw = nlwMiddle;
X	    pdst = pdstLine;
X	    if (startmask)
X	    {
X		*pdst = MaskRRopPixels(*pdst,bits,startmask);
X		pdst++;
X		NextUnnaturalStippleBits
X	    }
X	    while (nlw--)
X	    {
X		*pdst = RRopPixels(*pdst,bits);
X		pdst++;
X		NextUnnaturalStippleBits
X	    }
X	    if (endmask)
X		*pdst = MaskRRopPixels(*pdst,bits,endmask);
X	    pdstLine += nlwDst;
X	    y++;
X	    srcStart += stwidth;
X	    if (y == stippleHeight)
X	    {
X		y = 0;
X		srcStart = psrcBase;
X	    }
X	}
X    }
X}
X
X#endif
END_OF_FILE
if test 13554 -ne `wc -c <'server/ddx/cfb32/cfbrctstp8.c'`; then
    echo shar: \"'server/ddx/cfb32/cfbrctstp8.c'\" unpacked with wrong size!
fi
# end of 'server/ddx/cfb32/cfbrctstp8.c'
fi
echo shar: End of archive 17 \(of 29\).
cp /dev/null ark17isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 29 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Molecular Simulations, Inc.             mail: dcmartin@msi.com
796 N. Pastoria Avenue                  uucp: uunet!dcmartin
Sunnyvale, California 94086             at&t: 408/522-9236
