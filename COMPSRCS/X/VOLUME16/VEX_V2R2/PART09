Path: uunet!think.com!mips!msi!dcmartin
From: dcc@Athena.MIT.EDU (David Carver)
Newsgroups: comp.sources.x
Subject: v16i060: Video Extension for X (v2r2), Part09/29
Message-ID: <1992Feb6.145530.194@msi.com>
Date: 6 Feb 92 14:55:30 GMT
References: <csx-16i052-vex.v2r2@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 2517
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: dcc@Athena.MIT.EDU (David Carver)
Posting-number: Volume 16, Issue 60
Archive-name: vex.v2r2/part09

# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
#		"End of archive 9 (of 29)."
# Contents:  extensions/xv/doc/xv-lib-v2.PS.ae server/ddx/dec/tx/rop.c
# Wrapped by dcmartin@fascet on Thu Feb  6 06:52:46 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'extensions/xv/doc/xv-lib-v2.PS.ae' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extensions/xv/doc/xv-lib-v2.PS.ae'\"
else
echo shar: Extracting \"'extensions/xv/doc/xv-lib-v2.PS.ae'\" \(10815 characters\)
sed "s/^X//" >'extensions/xv/doc/xv-lib-v2.PS.ae' <<'END_OF_FILE'
X2921(of)S
X3034(the)S
X3186(drawable.)S
X720 H
X5760 V
X900(If)S
X996(the)S
X1148(still)S
X1329(is)S
X1426(successfully)S
X1944(rendered)S
X2322(an)S
X2446(XvVideoNotify)S
X3103(event)S
X3349(with)S
X3557(detail)S
X3809(XvStill)S
X4129(is)S
X4226(generated)S
X4643(for)S
X4789(the)S
X4941(drawable.)S
X720 H
X5880 V
X900(If)S
X996(the)S
X1148(port)S
X1339(is)S
X1436(grabbed)S
X1787(by)S
X1917(another)S
X2246(client,)S
X2523(this)S
X2698(request)S
X3016(is)S
X3113(ignored,)S
X3473(and)S
X3647(an)S
X3771(XvVideoNotify)S
X4428(event)S
X4674(with)S
X4882(detail)S
X720 H
X6000 V
X900(XvBusy)S
X1258(is)S
X1355(generated)S
X1772(for)S
X1918(the)S
X2070(drawable.)S
X720 H
X6168 V
X9 B
X720(Examples)S
X720 H
X6288 V
X10 C
X1150(Example)S
X1630(between)S
X2110(.EX)S
X2350(and)S
X2590(.EE)S
X2830(will)S
X3130(show)S
X3430(in)S
X3610(monospace)S
X720 H
X6516 V
X9 B
X720(Returned)S
X1127(Values)S
X720 H
X6636 V
X10 B
X900([Success])S
X720 H
X6756 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(XvPutStill\(3X\))S
X2429(completed)S
X2875(successfully.)S
X720 H
X6924 V
X10 B
X900([XvBadExtension])S
X720 H
X7044 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(the)S
X1939(Xv)S
X2091(extension)S
X2504(is)S
X2601(unavailable.)S
X720 H
X7212 V
X10 B
X900([XvBadAlloc])S
X720 H
X7692 V
X10 R
X5300(13)S
X7920 V
XEP
X%%Page: 14 14
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X720(XvPutStill)S
X1302(\()S
X1362(3X)S
X1529(\))S
X720 H
X1080 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(XvGetStill\(3X\))S
X2439(failed)S
X2696(to)S
X2804(allocate)S
X3144(memory)S
X3507(to)S
X3615(process)S
X3944(the)S
X4096(request.)S
X720 H
X1248 V
X9 B
X720(Diagnostics)S
X720 H
X1368 V
X10 B
X900([XvBadPort])S
X720 H
X1488 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(the)S
X1982(requested)S
X2394(port)S
X2585(does)S
X2798(not)S
X2956(exist.)S
X720 H
X1656 V
X10 B
X900([BadDrawable])S
X720 H
X1776 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(the)S
X1982(requested)S
X2394(drawable)S
X2789(does)S
X3002(not)S
X3160(exist.)S
X720 H
X1944 V
X10 B
X900([BadGC])S
X720 H
X2064 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(the)S
X1982(requested)S
X2394(graphics)S
X2762(context)S
X3086(does)S
X3299(not)S
X3457(exist.)S
X720 H
X2232 V
X10 B
X900([BadAlloc])S
X720 H
X2352 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(there)S
X2059(were)S
X2282(insu)S
X2449 H
X	(f)show 10 -.5 mul h (\256)show
X10 R
X2533(cient)S
X2757(resources)S
X3163(to)S
X3271(process)S
X3600(the)S
X3752(request.)S
X720 H
X2520 V
X9 B
X720(See)S
X892(Also)S
X720 H
X2640 V
X10 R
X900(XvPutVideo\(3X\),)S
X1643(XvGetStill\(3X\),)S
X2320(XvVideoNotify\(3X\))S
X720 H
X7680 V
X720(14)S
X7920 V
XEP
X%%Page: 15 15
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X4446(XvPutVideo)S
X5133(\()S
X5193(3X)S
X5360(\))S
X720 H
X1080 V
X9 B
X720(Name)S
X720 H
X1200 V
X10 R
X900(XvPutVideo)S
X1430(\261)S
X1510(write)S
X1745(video)S
X1997(into)S
X2183(a)S
X2257(drawable)S
X720 H
X1368 V
X9 B
X720(Syntax)S
X720 H
X1488 V
X10 B
X900(#include)S
X1292(<X11/extensions/Xvlib.h>)S
X720 H
X1728 V
X900(XvPutVideo\()S
X10 I
X1455(dpy,)S
X1654(port,)S
X1876(d,)S
X1981(gc,)S
X2130(vx,)S
X2273(vy,)S
X2416(vw,)S
X2582(vh,)S
X2731(dx,)S
X2880(dy,)S
X3029(dw,)S
X3201(dh)S
X10 R
X3301(\))S
X720 H
X1968 V
X10 B
X900(Display)S
X10 I
X1253(*dpy;)S
X720 H
X2088 V
X10 B
X900(XvPortID)S
X10 I
X1351(port;)S
X720 H
X2208 V
X10 B
X900(Drawable)S
X10 I
X1346(d;)S
X720 H
X2328 V
X10 B
X900(GC)S
X10 I
X1080(gc;)S
X720 H
X2448 V
X10 B
X900(int)S
X10 I
X1047(vx,)S
X1190(vy,)S
X1333(dx,)S
X1482(dy;)S
X720 H
X2568 V
X10 B
X900(unsigned)S
X1315(int)S
X10 I
X1462(vw,)S
X1628(vh;)S
X720 H
X2688 V
X10 B
X900(unsigned)S
X1315(int)S
X10 I
X1462(dw,)S
X1634(dh;)S
X720 H
X2976 V
X9 B
X720(Arguments)S
X720 H
X3096 V
X10 I
X900(dpy)S
X10 R
X1650(Speci\256es)S
X2041(the)S
X2193(display)S
X2512(screen)S
X2796(on)S
X2926(which)S
X3200(the)S
X3352(Xv)S
X3504(Server)S
X3794(is)S
X3891(to)S
X3999(accept)S
X4283(requests)S
X4640(from)S
X4864(Xv)S
X5016(clients.)S
X720 H
X3216 V
X1650(If)S
X1746(the)S
X1898(display)S
X2217(option)S
X2503(is)S
X2600(not)S
X2758(speci\256ed,)S
X3168(Xv)S
X3320(uses)S
X3522(the)S
X3674(display)S
X3993(screen)S
X4277(speci\256ed)S
X4662(by)S
X4792(your)S
X720 H
X3336 V
X1650(DISPLAY)S
X2102(environment)S
X2637(variable.)S
X3043(The)S
X3228(display)S
X3547(option)S
X3833(has)S
X3996(the)S
X4148(format)S
X4444(hostname:number.)S
X720 H
X3456 V
X1650(Using)S
X1919(two)S
X2099(colons)S
X2390(\(::\))S
X2542(instead)S
X2855(of)S
X2968(one)S
X3142(\(:\))S
X3266(indicates)S
X3651(that)S
X3831(DECnet)S
X4183(is)S
X4280(to)S
X4388(be)S
X4512(used)S
X4725(for)S
X4871(transport.)S
X720 H
X3624 V
X10 I
X900(port)S
X10 R
X1650(De\256nes)S
X1985(the)S
X2137(port)S
X2328(from)S
X2552(which)S
X2826(to)S
X2934(get)S
X3086(video.)S
X720 H
X3792 V
X10 I
X900(d)S
X10 R
X1650(De\256nes)S
X1985(the)S
X2137(drawable)S
X2532(into)S
X2718(which)S
X2992(video)S
X3244(is)S
X3341(to)S
X3449(be)S
X3573(written.)S
X720 H
X3960 V
X10 I
X900(gc)S
X10 R
X1650(De\256nes)S
X1985(the)S
X2137(graphical)S
X2538(context.)S
X2887(GC)S
X3056(components)S
X3569(are:)S
X10 I
X3748(subwindow-mode,)S
X4503(clip-x-origin,)S
X5063(clip-y-)S
X720 H
X4080 V
X1650(origin,)S
X10 R
X1950(and)S
X10 I
X2124(clip-mask.)S
X720 H
X4248 V
X900(vx,vy,vw,vh)S
X10 R
X1650(De\256ne)S
X1946(the)S
X2098(size)S
X2283(and)S
X2457(location)S
X2809(of)S
X2922(the)S
X3074(source)S
X3364(\(video\))S
X3682(region)S
X3967(to)S
X4075(be)S
X4199(written.)S
X10 I
X4567(vx)S
X10 R
X4685(and)S
X10 I
X4859(vy)S
X10 R
X4977(de\256ne)S
X5251(the)S
X720 H
X4368 V
X1650(upper-left)S
X2073(pixel)S
X2303(of)S
X2416(the)S
X2568(region.)S
X10 I
X2878(vw)S
X10 R
X3019(and)S
X10 I
X3193(vh)S
X10 R
X3317(de\256ne)S
X3591(the)S
X3743(width)S
X4001(and)S
X4175(height,)S
X4480(in)S
X4588(pixels,)S
X4882(of)S
X4995(the)S
X720 H
X4488 V
X1650(region.)S
X720 H
X4656 V
X10 I
X900(dx,dy,dw,dh)S
X10 R
X1650(De\256ne)S
X1946(the)S
X2098(location)S
X2450(and)S
X2624(size)S
X2809(of)S
X2922(the)S
X3074(destination)S
X3543(\(drawable\))S
X4004(region)S
X4289(into)S
X4475(which)S
X4749(the)S
X4901(video)S
X5153(image)S
X720 H
X4776 V
X1650(is)S
X1747(written.)S
X10 I
X2085(dx)S
X10 R
X2209(and)S
X10 I
X2383(dy)S
X10 R
X2507(de\256ne)S
X2781(the)S
X2933(upper-left)S
X3356(pixel)S
X3586(of)S
X3699(the)S
X3851(region.)S
X10 I
X4191(dw)S
X10 R
X4338(and)S
X10 I
X4512(dh)S
X10 R
X4642(de\256ne)S
X4916(the)S
X5068(width)S
X720 H
X4896 V
X1650(and)S
X1824(height,)S
X2129(in)S
X2237(pixels,)S
X2531(of)S
X2644(the)S
X2796(region.)S
X720 H
X5064 V
X9 B
X720(Description)S
X720 H
X5184 V
X10 R
X900(XvPutVideo)S
X1430(writes)S
X1704(video)S
X1956(into)S
X2142(a)S
X2216(drawable.)S
X2666(The)S
X2851(position)S
X3204(and)S
X3378(size)S
X3563(of)S
X3676(the)S
X3828(source)S
X4118(\(video\))S
X4436(rectangle)S
X4831(is)S
X4928(speci\256ed)S
X720 H
X5304 V
X900(by)S
X10 I
X1030(vx,)S
X1173(vy,)S
X1316(vw)S
X10 R
X1427(,)S
X1482(and)S
X10 I
X1656(vh)S
X10 R
X1750(.)S
X1805(The)S
X1990(position)S
X2343(and)S
X2517(size)S
X2702(of)S
X2815(the)S
X2967(destination)S
X3436(\(drawable\))S
X3897(rectangle)S
X4292(is)S
X4389(speci\256ed)S
X4774(by)S
X10 I
X4904(dx,)S
X5053(dy,)S
X5202(dw)S
X10 R
X5319(,)S
X720 H
X5424 V
X900(and)S
X10 I
X1074(dh)S
X10 R
X1174(.)S
X720 H
X5592 V
X900(Video)S
X1174(data)S
X1370(is)S
X1467(clipped)S
X1791(to)S
X1899(the)S
X2051(bounds)S
X2370(of)S
X2483(the)S
X2635(video)S
X2887(encoding,)S
X3308(scaled)S
X3587(to)S
X3695(the)S
X3847(requested)S
X4259(drawable)S
X4654(region)S
X4939(size)S
X5124(\(or)S
X5270(the)S
X720 H
X5712 V
X900(closest)S
X1202(size)S
X1387(supported\))S
X1844(and)S
X2018(clipped)S
X2342(to)S
X2450(the)S
X2602(bounds)S
X2921(of)S
X3034(the)S
X3186(drawable.)S
X720 H
X5880 V
X900(If)S
X996(video)S
X1248(is)S
X1345(successfully)S
X1863(initiated,)S
X2246(an)S
X2370(XvVideoNotify)S
X3027(event)S
X3273(with)S
X3481(detail)S
X3733(XvStarted)S
X4168(is)S
X4265(generated)S
X4682(for)S
X4828(the)S
X4980(drawable.)S
X720 H
X6000 V
X900(If)S
X996(the)S
X1148(port)S
X1339(is)S
X1436(already)S
X1759(in)S
X1867(use,)S
X2055(its)S
X2180(video)S
X2432(is)S
X2529(preempted,)S
X3005(and)S
X3179(if)S
X3270(the)S
X3422(new)S
X3618(drawable)S
X4013(is)S
X4110(di)S
X4188 H
X	(f)show 10 -.5 mul h (f)show
X10 R
X4249(erent)S
X4478(than)S
X4680(the)S
X4832(old,)S
X5015(an)S
X5139(XvVi-)S
X720 H
X6120 V
X900(deoNotify)S
X1335(event)S
X1581(with)S
X1789(detail)S
X2041(XvPreempted)S
X2620(is)S
X2717(generated)S
X3134(for)S
X3280(the)S
X3432(old)S
X3590(drawable.)S
X4040(If)S
X4136(the)S
X4288(port)S
X4479(is)S
X4576(grabbed)S
X4927(by)S
X5057(another)S
X720 H
X6240 V
X900(client,)S
X1177(this)S
X1352(request)S
X1670(is)S
X1767(ignored,)S
X2127(and)S
X2301(an)S
X2425(XvVideoNotify)S
X3082(event)S
X3328(with)S
X3536(detail)S
X3788(XvBusy)S
X4146(is)S
X4243(generated)S
X4660(for)S
X4806(the)S
X4958(drawable.)S
X720 H
X6408 V
X9 B
X720(Examples)S
X720 H
X6528 V
X10 R
X900(Example)S
X1285(between)S
X1647(.EX)S
X1835(and)S
X2009(.EE)S
X2186(will)S
X2372(show)S
X2613(in)S
X2721(monospace)S
X720 H
X6756 V
X9 B
X720(Returned)S
X1127(Values)S
X720 H
X6876 V
X10 B
X900([Success])S
X720 H
X6996 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(XvPutVideo\(3X\))S
X2505(completed)S
X2951(successfully.)S
X720 H
X7164 V
X10 B
X900([XvBadExtension])S
X720 H
X7284 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(the)S
X1939(Xv)S
X2091(extension)S
X2504(is)S
X2601(unavailable.)S
X720 H
X7764 V
X5300(15)S
X7920 V
XEP
X%%Page: 16 16
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X720(XvPutVideo)S
X1407(\()S
X1467(3X)S
X1634(\))S
X720 H
X1080 V
X10 B
X900([XvBadAlloc])S
X720 H
X1200 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(there)S
X2016(were)S
X2239(insu)S
X2406 H
X	(f)show 10 -.5 mul h (\256)show
X10 R
X2490(cient)S
X2714(resources)S
X3120(to)S
X3228(process)S
X3557(the)S
X3709(request.)S
X720 H
X1368 V
X9 B
X720(Diagnostics)S
X720 H
X1488 V
X10 B
X900([XvBadPort])S
X720 H
X1608 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(the)S
X1982(requested)S
X2394(port)S
X2585(does)S
X2798(not)S
X2956(exist.)S
X720 H
X1776 V
X10 B
X900([BadDrawable])S
X720 H
X1896 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(the)S
X1982(requested)S
X2394(drawable)S
X2789(does)S
X3002(not)S
X3160(exist.)S
X720 H
X2064 V
X10 B
X900([BadGC])S
X720 H
X2184 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(the)S
X1982(requested)S
X2394(graphics)S
X2762(context)S
X3086(does)S
X3299(not)S
X3457(exist.)S
X720 H
X2352 V
X10 B
X900([BadAlloc])S
X720 H
X2472 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(there)S
X2059(were)S
X2282(insu)S
X2449 H
X	(f)show 10 -.5 mul h (\256)show
X10 R
X2533(cient)S
X2757(resources)S
X3163(to)S
X3271(process)S
X3600(the)S
X3752(request.)S
X720 H
X2640 V
X9 B
X720(See)S
X892(Also)S
X720 H
X2760 V
X10 R
X900(XvPutStill\(3X\),)S
X1567(XvGetVideo\(3X\),)S
X2320(XvVideoNotify\(3X\))S
X720 H
X7680 V
X720(16)S
X7920 V
XEP
X%%Page: 17 17
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X4092(XvQueryAdaptors)S
X5133(\()S
X5193(3X)S
X5360(\))S
X720 H
X1080 V
X9 B
X720(Name)S
X720 H
X1200 V
X10 R
X900(XvQueryAdaptors)S
X1667(\261)S
X1747(return)S
X2015(adaptor)S
X2344(information)S
X2846(for)S
X2992(a)S
X3066(screen)S
X720 H
X1368 V
X9 B
X720(Syntax)S
X720 H
X1488 V
X10 B
X900(#include)S
X1292(<X11/extensions/Xvlib.h>)S
X720 H
X1728 V
X900(XvQueryAdaptors\()S
X10 I
X1727(dpy,)S
X1926(win,)S
X2126(p_num_adaptors,)S
X2859(pp_adaptor_info)S
X10 R
X3532(\))S
X720 H
X1968 V
X10 B
X900(Display)S
X10 I
X1253(*dpy;)S
X720 H
X2088 V
X10 B
X900(Drawable)S
X10 I
X1376(draw;)S
X720 H
X2208 V
X10 B
X900(int)S
X10 I
X1047(*p_num_adaptors)S
X10 R
X1775(;)S
X720 H
X2328 V
X10 B
X900(XvAdaptorInfo)S
X10 I
X1591(**pp_adaptor_info)S
X10 R
END_OF_FILE
if test 10815 -ne `wc -c <'extensions/xv/doc/xv-lib-v2.PS.ae'`; then
    echo shar: \"'extensions/xv/doc/xv-lib-v2.PS.ae'\" unpacked with wrong size!
fi
# end of 'extensions/xv/doc/xv-lib-v2.PS.ae'
fi
if test -f 'server/ddx/dec/tx/rop.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/ddx/dec/tx/rop.c'\"
else
echo shar: Extracting \"'server/ddx/dec/tx/rop.c'\" \(41193 characters\)
sed "s/^X//" >'server/ddx/dec/tx/rop.c' <<'END_OF_FILE'
X/***********************************************************
XCopyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
Xand the Massachusetts Institute of Technology, Cambridge, Massachusetts.
X
X                        All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the names of Digital or MIT not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XDIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XDIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X
X******************************************************************/
X/*
X** File: 
X**
X**   rop.c --- RasterOps device interface
X**
X** Author: 
X**
X**   Joel Gringorten DEC-WSL
X**
X** Revisions:
X**
X**   29.08.91 Carver
X**     - changed all interfaces to take RopPtr as first argument
X**       RopPtr is defined in rop.h
X**     - added some R5 conditional compilation
X**
X*/
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/file.h>
X#include <sys/time.h>
X#include <sys/tty.h>
X#include <errno.h>
X
X
X#include "misc.h"
X#include "X.h"
X#define NEED_EVENTS
X#include "Xproto.h"
X#include "scrnintstr.h"
X#include "pixmap.h"
X#include "input.h"
X#include "cursorstr.h"
X#include "regionstr.h"
X#include "resource.h"
X#include "dixstruct.h"
X
X#include <sys/workstation.h>
X#include <sys/inputdevice.h>
X#include "ws.h"
X
X#include "mfb.h"
X#include "xfb.h"
X#include "rop.h"
X#include "ropcolor.h"
X
X#include "maskbits.h" /* LOCATION OF DUFF MACRO IN R5 --- DCC */
X
X#include <machine/cpuconf.h>
Xextern int ws_cpu;
X#define is3MAX	(ws_cpu == DS_5000)
X#define is3min	(ws_cpu == DS_5000_100)
X
X/* XXX this is so we can compile this file without an up-to-date (4.L) copy
X    of machine/cpuconf.h.  This can cause terrible problems if you run
X    a server compiled under 4.2 and run it on a later base system version
X    if that base system uses a different value for DS_MAXINE.
X*/
X#ifndef DS_MAXINE
X#define DS_MAXINE 29
X#endif
X#define isMaxine (ws_cpu == DS_MAXINE)
X
X/* this determines whether bank switching is turned on by default */
X#define BANK_SW_DEFAULT (!(is3min || isMaxine))
X
Xextern int wsScreenPrivateIndex;
Xextern int lastEventTime;
Xextern int defaultColorVisualClass;
Xvoid wsQueryBestSize();
X
Xextern void wsQueryBestSize64();
Xextern void  wsQueryBestSize16();
X
Xextern int wsScreenInit();
Xextern int wsFd;
Xextern ws_screen_descriptor screenDesc[];
X
X
Xstatic ws_depth_descriptor depthDesc[MAXSCREENS];
Xstatic mapped[MAXSCREENS];
Xstatic char *planemask_addr;
X
Xextern	ws_event_queue	*queue;
X#undef VSYNCFIXED
X#ifdef VSYNCFIXED
X#define CURRENT_TIME	queue->time
X#else
X#define CURRENT_TIME	GetTimeInMillis()
X#endif
X
X#include "pmagro.h"
X
XropStruct ropInfo[3];
X
Xint txDebugOption = 0;
X
Xstatic void
XcolorNameToColor( pname, pred, pgreen, pblue)
X    char *      pname;
X    u_int *     pred;
X    u_int *     pgreen;
X    u_int *     pblue;
X{
X    if ( *pname == '#')
X    {
X        pname++;                /* skip over # */
X        sscanf( pname, "%2x", pred);
X        *pred <<= 8;
X
X        pname += 2;
X        sscanf( pname, "%2x", pgreen);
X        *pgreen <<= 8;
X
X        pname += 2;
X        sscanf( pname, "%2x", pblue);
X        *pblue <<= 8;
X    }
X    else /* named color */
X    {
X        *pred = *pgreen = *pblue = 0; /*OsLookupColor thinks these are shorts*/
X        OsLookupColor( 0 /*"screen", not used*/, pname, strlen( pname),
X                pred, pgreen, pblue);
X    }
X}
X
X
XBool
XropInitProc(index, pScreen, argc, argv)
X    int index;
X    ScreenPtr pScreen;
X    int argc;
X    char **argv;
X{
X    register    PixmapPtr pPixmap;
X    ColormapPtr pcmap;
X    int		dpix, dpiy, i;
X    static int  mapOnce = FALSE;
X    wsScreenPrivate *wsp;
X    Bool success = FALSE;
X    ws_depth_descriptor *dd;
X    ws_visual_descriptor vd;
X    static ws_map_control mc;
X    VisualPtr	    pVisual;
X    ColormapPtr	    pCmap;
X    int defaultRootDepth;
X    Bool useBankSwitch, useXorFix, useBStore;
X    void rop_pip_init();
X
X    /* for initializing color map entries */
X    u_int blackred      = 0x0000;
X    u_int blackgreen    = 0x0000; 
X    u_int blackblue     = 0x0000;
X    u_int whitered      = 0xffff;
X    u_int whitegreen    = 0xffff;
X    u_int whiteblue     = 0xffff;
X
X    lastEventTime = CURRENT_TIME;
X
X    wsp = (wsScreenPrivate *) Xalloc(sizeof(wsScreenPrivate));
X    wsp->pInstalledMap = NOMAPYET;
X    pScreen->devPrivates[wsScreenPrivateIndex].ptr = (pointer) wsp;
X
X    wsp->screenDesc = &screenDesc[index];    
X    wsp->args = &screenArgs[index];
X
X    /* since driver does not support unmap (yet), only map screen once */
X    if (! mapped[index]) {
X	    depthDesc[index].screen = screenDesc[index].screen;
X	    for (i = 0; i < wsp->screenDesc->allowed_depths; i++) {
X		    depthDesc[index].which_depth = i;	
X		    if (ioctl(wsFd, GET_DEPTH_INFO, &depthDesc[index]) == -1) {
X			ErrorF("GET_DEPTH_INFO failed");
X			exit (1);
X		    }
X		if (depthDesc[index].depth == 8 ||depthDesc[index].depth == 1){
X			success = TRUE;
X			break;
X		}
X	    }
X	    if (!success) return FALSE;
X
X	    mc.screen = screenDesc[index].screen;
X	    mc.which_depth = i;
X	    mc.map_unmap = MAP_SCREEN;
X	    if (ioctl(wsFd,  MAP_SCREEN_AT_DEPTH, &mc) == -1)    {
X		ErrorF("MAP_SCREEN_AT_DEPTH failed");
X		return FALSE;
X	    }
X	    /* 
X	     * reget the depth desc.  It now contains the user-mapped bitmap
X	     * addr. 
X	     */
X	    if (ioctl(wsFd, GET_DEPTH_INFO, &depthDesc[index]) == -1) {
X	     ErrorF("GET_DEPTH_INFO failed");
X	     exit (1);
X	    }
X	mapped[index] = TRUE;
X    }
X
X    /* ws routines knows how to initialize many functions, so call init. */
X    if (wsScreenInit(index, pScreen, argc, argv) == -1) return FALSE;
X
X    dd = &depthDesc[index];
X
X    if (index > 0) wsCursorControl(index, CURSOR_OFF);
X    wsScreens[index] = pScreen;
X
X/* 
X * this is really dumb.  The driver has the screen geometry in mm.
X * The screen wants it stored as mm, but the damn interface passes
X * inches.  mm => inches => mm.  What a waste.  Should we change cfbscrinit.c?
X * -jmg.
X */
X
X    if (screenArgs[index].flags & ARG_DPIX)
X	dpix = screenArgs[index].dpix;
X    else
X	dpix =  ( wsp->screenDesc->width)  / 
X		((wsp->screenDesc->monitor_type.mm_width  * 10) / 254);
X
X    if (screenArgs[index].flags & ARG_DPIY)
X	dpiy = screenArgs[index].dpiy;
X    else
X	dpiy =  ( wsp->screenDesc->height) / 
X		((wsp->screenDesc->monitor_type.mm_height * 10) / 254);
X
X    vd.screen = screenDesc[index].screen; 
X    vd.which_visual = 0;	/* jmg ? */
X     if (ioctl(wsFd, GET_VISUAL_INFO, &vd) == -1) {
X     	ErrorF("GET_VISUAL_INFO failed");
X    	exit (1);
X    }
X
X    defaultRootDepth = (defaultColorVisualClass == TrueColor
X			|| defaultColorVisualClass == DirectColor) ? 24 : 8;
X    useXorFix = TRUE;
X    useBankSwitch = BANK_SW_DEFAULT;
X    useBStore = TRUE;
X
X    rop_pip_init(index, dd->pixmap, useBankSwitch);
X
X    if (!xfbScreenInit(pScreen, ropInfo[index].bit8,
X	wsp->screenDesc->width, wsp->screenDesc->height, dpix, dpiy,
X	dd->fb_width, ropInfo[index].bit24,
X	defaultRootDepth, defaultColorVisualClass,
X	useBankSwitch, useXorFix, useBStore)) {
X	return (FALSE);
X    }
X
X    /* init hardware colormap procs: */
X    if (!ropColorInit(pScreen)) {
X	return (FALSE);
X    }
X
X#ifdef XV
X    XvropScreenInit(pScreen);
X#endif XV
X
X    if(screenArgs[index].flags & ARG_BLACKVALUE)
X	colorNameToColor(screenArgs[index].blackValue, &blackred,
X			 &blackgreen, &blackblue); 
X
X    if(screenArgs[index].flags & ARG_WHITEVALUE)
X	colorNameToColor(screenArgs[index].whiteValue, &whitered, 
X			&whitegreen, &whiteblue);
X
X
X    /* copy of cfbCreateDefColormap, except variable colors (copied from
X	R5-beta):
X    */
X    for (pVisual = pScreen->visuals;
X	 pVisual->vid != pScreen->rootVisual;
X	 pVisual++)
X	;
X
X    if (CreateColormap(pScreen->defColormap, pScreen, pVisual, &pCmap,
X		       (pVisual->class & DynamicClass) ? AllocNone : AllocAll,
X		       0)
X	!= Success)
X	return FALSE;
X    if ((AllocColor(pCmap, &whitered, &whitegreen, &whiteblue,
X		    &(pScreen->whitePixel), 0) != Success) ||
X	(AllocColor(pCmap, &blackred, &blackgreen, &blackblue,
X		    &(pScreen->blackPixel), 0) != Success))
X    {
X	return FALSE;
X    }
X    (*pScreen->InstallColormap)(pCmap);
X
X    planemask_addr = dd->plane_mask;
X    if(wsp->screenDesc->cursor_width == 64)
X	 pScreen->QueryBestSize = wsQueryBestSize64;
X    else
X	 pScreen->QueryBestSize = wsQueryBestSize16;
X
X    return TRUE;
X}
X   
X/**********************************************************
X	PIP Support 
X***********************************************************/
X/*
X *      Frame buffer access indices:
X */
X#define ACCESS_EIGHT_BIT                1
X#define ACCESS_SELECTION        2
X#define ACCESS_TRUE_COLOR       3
X#define ACCESS_VIDEO_ENABLE     4
X
X#define ACCESS_AS_WORDS         0x80
X#define ACCESS_AS_HALF_WORDS    0x40
X#define ACCESS_AS_BYTES                 0x20
X#define ACCESS_AS_BITS                  0x10
X
X#define ACCESS_TYPE_MASK                0x0f
X#define ACCESS_WIDTH_MASK               0xf0
X
X/*
X *      Mapping register related macros and definitions:
X *
X *        MAP_IS_ON:
X *              Test if mapping hardware is turned on.
X *        MAP_3MAX_LOW_BITS:
X *      Low order bits (below mapping register level.)
X *        MAP_VALUE:
X *              Mapping register value.
X *        SET_MAP:
X *              Set the mapping value in the map register.
X */
X#define MAP_IS_ON(map_reg)  ((*map_reg & 0x10) == 0)
X#define MAP_3MAX_LOW_BITS 0x0001fffff
X#define MAP_VALUE( addr ) (((addr) & 0x00e00000) >> 20)
X#define SET_MAP(map_reg, value) *(map_reg) = \
X        (*(map_reg) & 0xfffffff0) | TC1_FBC_VIDEO_ON | ((value) & 0x0000000f)
X
X/* DCC MOD --- ADDED GET_MAP --- 11.06.91 */
X#define GET_MAP(map_reg) (*(map_reg) & 0x0000000f)
X/* END DCC MOD */
X
Xtypedef union {         /* Pointer access aliases: */
X        u_char  *byte;          /* ... access pixel as an 8-bit byte. */
X        u_short *half_word;     /* ... access pixel as a 16-bit word. */
X        u_int   integer;        /* ... unsigned integer for calculations. */
X        u_int   *word;          /* ... access pixel as a 32-bit word. */
X} Access;
X
X
X/*
X *	lib3max.c:	Diagnostic support routines for peeking and poking
X *				Turbo Bus locations on a 3MAX.
X *
X *		Copyright(c) 1990, RasterOps, Inc.
X */
X/* These are already included above or are unnecessary
X#include <sys/types.h>
X#include <sys/file.h>
X#include "/sys/h/ioctl.h"
X*/
X
X#define CARRY 0x10000
X
X/*
X *	Bit access definitions:
X */
Xstatic int	bit_get[] = {		/* Mask for getting bit within byte. */
X	0x1, 0x2, 0x4, 0x8, 		/* ... */
X	0x10, 0x20, 0x40, 0x80  	/* ... */
X};								/* ... */
Xstatic int	bit_clear[] = {		/* Mask for clearing all but 1 bit within a byte. */
X	~0x1, ~0x2, ~0x4, ~0x8, 	/* ... */
X	~0x10, ~0x20, ~0x40, ~0x80 	/* ... */
X};								/* ... */
Xstatic int	bit_shift[] = {		/* Shift to move select bit to bit 0. */
X	0, 1, 2, 3, 				/* ... */
X	4, 5, 6, 7,					/* ... */
X};								/* ... */
X
X/*"fill_eight_bit"
X *
X *	Fill a rectangular region in the 8-bit memory.
X */
Xfill_eight_bit(prop, left, top, width, height, color)
X     RopPtr prop;	/* -> base address of turbo bus slot. */
X     int left;		/* =  left side of region to fill in. */
X     int top;		/* =  top side of region to fill in. */
X     int width;		/* =  width of region to fill in. */
X     int height;	/* =  height of region to fill in. */
X     u_int color;	/* =  color to fill pixels with. */
X{
X  u_int	fb;		/* Address of frame buffer. */
X  u_char *map_reg;	/* Location of mapping register. */
X  u_char  *pixel;	/* Next pixel to fill with 'color'. */
X  int x;		/* Index: next column to set pixel value in. */
X  int x_end;		/* End of strip to be filled in x direction. */
X  int y;		/* Index: next row to set pixel value in. */
X  int y_end;		/* End of region to be in filled in y direction. */
X  int old_map;		/* Save and restore map register */
X
X  /*
X   *	Set up mapping register and frame buffer addresses, 
X   *    set mapping register value.
X   *	Set loop check values and then loop filling in rows of the 
X   *    frame buffer.
X   */
X
X  map_reg = prop->mapRegister;
X  fb = (u_int)prop->bit8;
X
X  if ( MAP_IS_ON(map_reg) ) 
X    {
X      old_map = GET_MAP(map_reg);
X      SET_MAP(map_reg, MAP_VALUE(TCO_EIGHT_BIT));
X    }
X  
X  x_end = left + width;
X  y_end = top + height;
X  
X  for ( y = top; y < y_end; y++ )
X    {
X      pixel = (u_char *)( fb + (left + y * 1280) );
X      for ( x = left; x < x_end; x++ )
X	{
X	  *pixel++ = color;
X	}
X    }
X
X  if ( MAP_IS_ON(map_reg) )
X    {
X      SET_MAP(map_reg, old_map);
X    }
X
X}
X
X/*"fill_video_enable"
X * 
X *  Fill a rectangular region in the video enable memory.
X */
Xfill_selection(prop, x1, y1, width, height, color)
X     RopPtr	prop;		/* -> base address of turbo bus slot. */
X     int     	x1;       /* =  left side of region to fill in. */
X     int     	y1;        /* =  top side of region to fill in. */
X     int     	width;      /* =  width of region to fill in. */
X     int     	height;     /* =  height of region to fill in. */
X     u_int   	color;      /* =  color to fill pixels with. */
X{
X  u_int   *fb;          /* Address of frame buffer. */
X  int pitch;    	/* Number of bytes between scan lines. */
X  u_int   *pixel;       /* Next set of 8 pixels to access in the fb. */
X  u_int   startmask, endmask;
X  int	    nmiddle, nmid;
X  int	    x2, y2;
X  int	    c;
X  u_char *map_reg;		/* Location of mapping register. */
X  int old_map;
X  
X  fb = (u_int *)(prop->SelectionPlane);
X
X  color = color & 0xff;
X  color = color | color << 8;
X  color = color | color << 16;
X  
X#define ROP_PPW	32
X#define ROP_PIM	(ROP_PPW - 1)
X#define ROP_PWSH	5
X#define ROP_SCRRIGHT(bits,shift)	(((unsigned int) (bits)) << (shift))
X#define ROP_SCRLEFT(bits,shift)	(((unsigned int) (bits)) >> (shift))
X  
X  x2 = x1 + width;
X  y2 = y1 + height;
X  
X  /* COMPENSATE FOR FUNNY PIXEL PACKING */
X
X  x1 = (x1 & 7) + ((x1 >> 3) * 32);
X  x2 = (x2 & 7) + ((x2 >> 3) * 32);
X  width = x2 - x1;
X
X  pitch = 1280 >> 3;
X  
X  c = x1 & ROP_PIM;
X  
X  pixel = fb + (y1 * pitch) + (x1 >> ROP_PWSH);
X  startmask = 0;
X  if (c + width < ROP_PPW) {
X    nmiddle = 0;
X    endmask = ROP_SCRRIGHT(~0,c) ^ ROP_SCRRIGHT(~0,c+width);
X  } else {
X    nmiddle = width;
X    if (c) {
X      startmask = ROP_SCRRIGHT(~0,c);
X      nmiddle += (c - ROP_PPW);
X      pitch--;
X    }
X    nmiddle >>= ROP_PWSH;
X    endmask = ~ROP_SCRRIGHT(~0, x2 & ROP_PIM);
X    pitch -= nmiddle;
X  }
X  while (height--) {
X    if (startmask) {
X      *pixel = *pixel & ~startmask | color & startmask;
X      pixel++;
X    }
X    nmid = nmiddle;
X    while (nmid--) {
X      *pixel = color;
X      pixel++;
X    }
X    if (endmask)
X      *pixel = *pixel & ~endmask | color & endmask;
X    pixel += pitch;
X  }
X}
X
X#ifdef nomore
X
X/* DCC MOD --- RESTORES THE ADDRESS MAP UPON RETURN --- 11.06.91 */
X
X/*"fill_selection"
X *
X *	Fill a rectangular region in the selection memory. (Note this memory
X *	does not require a setting of the mapping register!)
X *
X * (edg 7/26/91) Rewrote routine and based it on MFBSOLIDFILLAREA() to make
X * things much faster.  The old code was rather inefficient.
X */
Xfill_selection(prop, left, top, width, height, color)
X    RopPtr	prop;		/* -> base address of turbo bus slot. */
X    int		left;		/* =  left side of region to fill in. */
X    int		top;		/* =  top side of region to fill in. */
X    int		width;		/* =  width of region to fill in. */
X    int		height;		/* =  height of region to fill in. */
X    u_int	color;		/* =  color to fill pixels with. */
X{
X#define nlwidth 1280/8  /* number of longwords per scanline */
X    u_int startmask;	/* bits to modify for left ragged edge */
X    u_int endmask;	/* bits to modify for right ragged edge */
X    u_int startbits, endbits;
X    int index, nlwMiddle, nlw, nlwExtra;
X    u_int *p;
X
X    /* p = adr of select memory + row offset + column offset: */
X    p = (u_int *)(prop->SelectionPlane) + (top * nlwidth) + (left >> 3);
X
X    index = left & 0x7;  /* bit index into word */
X
X    if ((index + width) < 8) {
X	/* paint a narrow strip with ragged left and right edges */
X	startmask = ~((1 << index) - 1);  /* set up left edge */
X	startmask &= (1 << (index + width)) - 1;  /* fix up right edge */
X	startbits = startmask & color;
X	Duff(height, *p = *p & ~startmask | startbits; p += nlwidth);
X    } else {
X	startmask = (index == 0) ? 0 : ~((1 << index) - 1);
X	endmask = (1 << ((left + width) & 0x7)) - 1;
X	nlwMiddle = (startmask) ? ((width - (8 - index)) >> 3) : (width >> 3);
X	nlwExtra = nlwidth - nlwMiddle;
X	startbits = color & startmask;
X	endbits = color & endmask;
X
X	if (startmask && endmask) {
X	    nlwExtra -= 1;
X	    while (height--) {
X		nlw = nlwMiddle;
X		*p = *p & ~startmask | startbits;
X		p++;
X		Duff(nlw, *p++ = color);
X		*p = *p & ~endmask | endbits;
X		p += nlwExtra;
X	    }
X	} else if (startmask && !endmask) {
X	    nlwExtra -= 1;
X	    while (height--) {
X		nlw = nlwMiddle;
X		*p = *p & ~startmask | startbits;
X		p++;
X		Duff(nlw, *p++ = color);
X		p += nlwExtra;
X	    }
X	} else if (!startmask && endmask) {
X	    while (height--) {
X		nlw = nlwMiddle;
X		Duff(nlw, *p++ = color);
X		*p = *p & ~endmask | endbits;
X		p += nlwExtra;
X	    }
X	} else /* no ragged bits at either end */ {
X	    while (height--) {
X		nlw = nlwMiddle;
X		Duff(nlw, *p++ = color);
X		p += nlwExtra;
X	    }
X	}
X    }
X}
X
X#endif nomore
X
X/*"fill_true_color"
X *
X *	Fill a rectangular region in the 24-bit true color memory.
X */
Xfill_true_color(prop, left, top, width, height, color)
X     RopPtr	prop;		/* -> base address of turbo bus slot. */
X     int	left;		/* =  left side of region to fill in. */
X     int	top;		/* =  top side of region to fill in. */
X     int	width;		/* =  width of region to fill in. */
X     int	height;		/* =  height of region to fill in. */
X     u_int	color;			/* =  color to fill pixels with. */
X{
X  u_int	fb_mapped; /* Address of frame buffer in 3max or 3min address space. */
X  u_int	fb_real;   /* Address of frame buffer  in real (non-3max) space. */
X  u_int	map_left;  /* Mapping register value at left end of line. */
X  u_int	map_right; /* Mapping register value at right end of line. */
X  u_char *map_reg; /* Location of mapping register. */
X  u_int	*pixel;	/* Where to store next pixel value (is map or = pixel_real.) */
X  u_int	pixel_offset; /* Offset of pixel within turbo bus slot. */
X  int x;	/* Loop index: next column to set pixel in. */
X  int x_end;	/* X coordinate to stop filling with. */
X  int y;	/* Loop index: next row to set pixel in. */
X  int y_end;	/* Y coordinate to stop filling with. */
X  int old_map;	/* to save and restore map <dcc> */
X  
X  /*
X   *	Set up mapping register and frame buffer addresses. Set frame buffer
X   *	offset within turbo bus slot. Set loop comparison values.
X   */
X  map_reg = prop->mapRegister;
X  fb_mapped = (u_int)prop->MappedArea;
X  fb_real = (u_int)prop->bit24;
X  x_end = left+width;
X  y_end = top+height;
X  
X  if ( MAP_IS_ON(map_reg) )
X    {
X      old_map = GET_MAP(map_reg);
X    }
X
X  /*
X   *	Loop filling scan lines. For each scan line:
X   *	  (1) If no mapping just fill the pixels.
X   *
X   *	  (2) If mapping (i.e., 3MAX) calculate the starting and ending 
X   *		  map register values:i
X   *	        (a) If they are the same just fill the line. 
X   *		(b) If the map register value changes on the line then set 
X   *				it before each pixel.
X   */
X  for ( y = top; y < y_end; y++ )
X    {
X      if ( !MAP_IS_ON(map_reg) )
X	{
X	  pixel = (u_int *)(fb_real + 4 * (left + y * 1280));
X	  for ( x = left; x < x_end; x++ )
X	    {
X	      *pixel++ = color;
X	    }
X	}
X      
X      else
X	{
X	  pixel_offset = TCO_TRUE_COLOR + 4 * (left + y * 1280);
X	  map_left = MAP_VALUE(pixel_offset);
X	  map_right = MAP_VALUE( pixel_offset + width * 4 );
X	  if ( (map_left == map_right) )
X	    {
X	      SET_MAP(map_reg, map_left);
X	      pixel = (u_int *)(fb_mapped | (pixel_offset&MAP_3MAX_LOW_BITS));
X	      for ( x = left; x < x_end; x++ )
X		{
X		  *pixel++ = color;
X		}
X	    }
X	  else
X	    {
X	      for ( x = left; x < x_end; x++ )
X		{
X		  SET_MAP(map_reg, MAP_VALUE(pixel_offset));
X		  pixel = (u_int *)(fb_mapped | (pixel_offset&MAP_3MAX_LOW_BITS));
X		  *pixel = color;
X		  pixel_offset+=4;
X		}
X	    }
X	}
X    }
X  
X  if ( MAP_IS_ON(map_reg) )
X    {
X      SET_MAP(map_reg, old_map);
X    }
X
X}
X
X
X/*"fill_video_enable"
X * 
X *  Fill a rectangular region in the video enable memory.
X */
Xfill_video_enable(prop, x1, y1, width, height, color)
X     RopPtr	prop;		/* -> base address of turbo bus slot. */
X     int     	x1;       /* =  left side of region to fill in. */
X     int     	y1;        /* =  top side of region to fill in. */
X     int     	width;      /* =  width of region to fill in. */
X     int     	height;     /* =  height of region to fill in. */
X     u_int   	color;      /* =  color to fill pixels with. */
X{
X  u_int   *fb;          /* Address of frame buffer. */
X  int pitch;    	/* Number of bytes between scan lines. */
X  u_int   *pixel;       /* Next set of 8 pixels to access in the fb. */
X  u_int   startmask, endmask;
X  int	    nmiddle, nmid;
X  int	    x2, y2;
X  int	    c;
X  u_char *map_reg;		/* Location of mapping register. */
X  int old_map;
X  
X  /*
X   *	Set up mapping register and frame buffer addresses, 
X   *    set mapping register value if
X   *	mapping is enabled. Initialize loop termination values.
X   */
X  map_reg = prop->mapRegister;
X  if ( MAP_IS_ON(map_reg) )
X    {
X      fb = (u_int *)prop->MappedArea;
X      old_map = GET_MAP(map_reg);
X      SET_MAP(map_reg, MAP_VALUE(TCO_VIDEO_ENABLE));
X    }
X  else
X    {
X      fb = (u_int *)prop->VideoEnablePlane;
X    }
X  
X  color = color & 0xff;
X  color = color | color << 8;
X  color = color | color << 16;
X  
X#define ROP_PPW	32
X#define ROP_PIM	(ROP_PPW - 1)
X#define ROP_PWSH	5
X#define ROP_SCRRIGHT(bits,shift)	(((unsigned int) (bits)) << (shift))
X#define ROP_SCRLEFT(bits,shift)	(((unsigned int) (bits)) >> (shift))
X  
X  x2 = x1 + width;
X  y2 = y1 + height;
X  
X  /* COMPENSATE FOR FUNNY PIXEL PACKING */
X
X  x1 = (x1 & 7) + ((x1 >> 3) * 32);
X  x2 = (x2 & 7) + ((x2 >> 3) * 32);
X  width = x2 - x1;
X
X  pitch = 1280 >> 3;
X  
X  c = x1 & ROP_PIM;
X  
X  pixel = fb + (y1 * pitch) + (x1 >> ROP_PWSH);
X  startmask = 0;
X  if (c + width < ROP_PPW) {
X    nmiddle = 0;
X    endmask = ROP_SCRRIGHT(~0,c) ^ ROP_SCRRIGHT(~0,c+width);
X  } else {
X    nmiddle = width;
X    if (c) {
X      startmask = ROP_SCRRIGHT(~0,c);
X      nmiddle += (c - ROP_PPW);
X      pitch--;
X    }
X    nmiddle >>= ROP_PWSH;
X    endmask = ~ROP_SCRRIGHT(~0, x2 & ROP_PIM);
X    pitch -= nmiddle;
X  }
X  while (height--) {
X    if (startmask) {
X      *pixel = *pixel & ~startmask | color & startmask;
X      pixel++;
X    }
X    nmid = nmiddle;
X    while (nmid--) {
X      *pixel = color;
X      pixel++;
X    }
X    if (endmask)
X      *pixel = *pixel & ~endmask | color & endmask;
X    pixel += pitch;
X  }
X
X  if ( MAP_IS_ON(map_reg) )
X    {
X      SET_MAP(map_reg, old_map);
X    }
X}
X
X#ifdef nomore
X
X/*"fill_video_enable"
X *
X *	Fill a rectangular region in the video enable memory. 
X */
Xfill_video_enable(prop, left, top, width, height, color)
X     RopPtr	prop;		/* -> base address of turbo bus slot. */
X     int	left;		/* =  left side of region to fill in. */
X     int	top;		/* =  top side of region to fill in. */
X     int	width;		/* =  width of region to fill in. */
X     int	height;		/* =  height of region to fill in. */
X     u_int	color;		/* =  color to fill pixels with. */
X{
X  u_int	clear_mask;		/* Mask used to clear a bit in the memory. */
X  u_int	fb;			/* Address of frame buffer. */
X  u_int	get_mask;		/* Mask used to set a bit in the memory. */
X  u_char *map_reg;		/* Location of mapping register. */
X  u_int	*pixel;			/* Next set of 8 pixels to access in the fb. */
X  int x;			/* Index: next column to set pixel value in. */
X  int x_end_left;   /* Left end of strip to be filled a bit at a time */
X  int x_end_middle; /* Middle of strip to be filled which has all 8 pixels */
X  int x_end_right;  /* Right end of strip to be filled a bit at a time */
X  int y;			/* Index: next row to set pixel value in. */
X  int y_end;		/* End of region to be in filled in y direction. */
X  int old_map;
X  
X  /*
X   *	Set up mapping register and frame buffer addresses, 
X   *    set mapping register value if
X   *	mapping is enabled. Initialize loop termination values.
X   */
X  map_reg = prop->mapRegister;
X  if ( MAP_IS_ON(map_reg) )
X    {
X      fb = (u_int)prop->MappedArea;
X      old_map = GET_MAP(map_reg);
X      SET_MAP(map_reg, MAP_VALUE(TCO_VIDEO_ENABLE));
X    }
X  else
X    {
X      fb = (u_int)prop->VideoEnablePlane;
X    }
X  
X  x_end_right = left+width;
X  x_end_middle = (x_end_right/8)*8;
X  x_end_left = ((left+7)/8)*8;
X  if ( x_end_left > x_end_right ) x_end_left = x_end_right;
X  y_end = top+height;
X  
X  /*
X   *	Fill left strip (left side pixels not in a full byte.)
X   */
X  for ( x = left; x < x_end_left; x++ )
X    {
X      pixel = (u_int *)(fb + 4 * (x/8 + top * (1280/8)));
X      clear_mask = bit_clear[x%8];
X      get_mask = bit_get[x%8];
X      for ( y = top; y < y_end; y++ )
X	{
X	  *pixel = (*pixel & clear_mask) | (color & get_mask);
X	  pixel += (1280/8);
X	}
X    }
X  
X  /*
X   *	Fill the middle strip (pixels which are in full bytes.)
X   */
X  for ( ; x < x_end_middle; x+= 8 )
X    {
X      pixel = (u_int *)(fb + 4 * (x/8 + top*(1280/8)));
X      for ( y = top; y < y_end; y++ )
X	{
X	  *pixel = color;
X	  pixel += (1280/8);
X	}
X    }
X  
X  /*
X   *	Fill in right strip (right side pixels not in a full byte.)
X   */
X  for ( ; x < x_end_right; x++ )
X    {
X      pixel = (u_int *)(fb + 4 * (x/8 + top * (1280/8)));
X      clear_mask = bit_clear[x%8];
X      get_mask = bit_get[x%8];
X      for ( y = top; y < y_end; y++ )
X	{
X	  *pixel = (*pixel & clear_mask) | (color & get_mask);
X	  pixel += (1280/8);
X	}
X    }
X
X  if ( MAP_IS_ON(map_reg) )
X    {
X      SET_MAP(map_reg, old_map);
X    }
X}
X
X#endif nomore
X
X/* END DCC MOD */
X
X#ifdef NOTDEF
X
X/*"map_slot"
X *
X *	Map in an Turbo Bus slot so it can be accessed. 
X *
X *		-> base of turbo bus slot if success
X *		=  0 if failure
X */
Xcaddr_t map_slot()
X{
X	caddr_t	address;	/* Address of mapped slot. */
X	int		fd;			/* File descriptor for slot being mapped. */
X
X	if ( (fd = open("/dev/console", O_RDWR)) < 0 )
X	{
X		return 0;
X	}
X	if ( ioctl(fd, GET_RASTEROPS_SLOT, &address) == -1 )
X	{
X		printf("map_slot: unable to map slot!\n");
X		return 0;
X	}
X	return address;
X}
X#endif NOTDEF
X
X/*"parse_access"
X *
X *	Parse the location and width of Turbo slot access to be made given
X *	the command line arguments. The parameters passed to this routine
X *	are the same ones received by 'main' from the system (e.g., argv[0]
X *	is the command name.) 
X *	Default access widths by frame buffer type are:
X *		Eight bit:    byte
X *		Selection:    bit 
X *		True Color:   word
X *		Video enable: bit 
X *	Default frame buffer to access is eight bit.
X *
X * 		= access to be made (see diag.h)
X *		= 0 if an error was detected
X */
Xparse_access(argc, argv)
X	int		argc;		/* = number of command arguments to examine. */
X	char	*argv[];	/* = vector of pointers to command arguments. */
X{
X	int		argv_i;		/* Index: entry in argv currently examining. */
X	int		char_i;		/* Index: character within argv[argv_i] examining. */
X	int		fb;			/* Frame buffer access is for. */
X	int		width;		/* Width of access. */
X
X	/*
X	 *	Process command arguments looking for access specifications.
X	 */
X	fb = 0;
X	width = 0;
X	for ( argv_i = 1; argv_i < argc; argv_i++ )
X	{
X		if ( *argv[argv_i] == '-' )
X		{
X			for ( char_i = 1; argv[argv_i][char_i]; char_i++ )
X			{
X				switch ( argv[argv_i][char_i] )
X				{
X				  case 'b':
X				  case '1':
X					width = ACCESS_AS_BYTES;
X				  case 'e':
X					fb = ACCESS_EIGHT_BIT;
X					break;
X				  case 'h':
X				  case '2':
X					width = ACCESS_AS_HALF_WORDS;
X					break;
X				  case 's':
X					fb = ACCESS_SELECTION;
X					break;
X				  case 't':
X					fb = ACCESS_TRUE_COLOR;
X					break;
X				  case 'v':
X					fb = ACCESS_VIDEO_ENABLE;
X					break;
X				  case 'w':
X				  case '4':
X					width = ACCESS_AS_WORDS;
X					break;
X				}
X			}
X		}
X	}
X
X	/*
X	 *	Perform error checking and default access width if it was not
X	 *	specified.
X	 */
X	switch( fb )
X	{
X	  default:
X		fb = ACCESS_EIGHT_BIT;
X	  case ACCESS_EIGHT_BIT:
X		if ( width == 0 ) width = ACCESS_AS_BYTES;
X		break;
X	  case ACCESS_SELECTION:
X		if ( width == 0 ) width = ACCESS_AS_BITS;
X		break;
X	  case ACCESS_TRUE_COLOR:
X		switch ( width )
X		{
X		  case ACCESS_AS_BYTES:
X		  case ACCESS_AS_HALF_WORDS:
X			printf(" *** Access to true color frame buffer must be on word boundaries\n");
X			return 0;
X		  default:
X			width = ACCESS_AS_WORDS;
X			break;
X		}
X		break;
X	  case ACCESS_VIDEO_ENABLE:
X		if ( width == 0 ) width = ACCESS_AS_BITS;
X		break;
X	}
X
X	return fb | width;
X}
X
X/*"parse_access_help"
X *
X *	Print out description of access command modifiers, which are parsed
X *	by parse_access(). (This routine is called by the various aaa_map() 
X *	routines in the diagnostic utilities.
X */
Xparse_access_help()
X{
X	printf("   -b indicates byte access\n");
X	printf("   -h indicates halfword (2 byte) access\n");
X	printf("   -e indicates 8-bit frame buffer\n");
X	printf("   -s indicates selection memory\n");
X	printf("   -t indicates 24-bit frame buffer\n");
X	printf("   -v indicates video enable memory\n");
X	printf("   -w indicates word (4 byte) access\n");
X}
X
X/*"peek"
X *
X *	Return the contents of a location in a Turbo Bus slot's
X *	address space.
X *
X *		= contents of the location
X */
Xu_int peek(base, offset, width)
X	u_int	base;		/* -> base of turbo channel slot. */
X	u_int 	offset;		/* -> location within turbo channel slot to get. */
X	int		width;		/* =  size of location (1, 2, or 4). */
X{
X	Access	access;		/* Pointer aliases. */
X	u_int	*map_reg;	/* Frame buffer control register address. */
X
X	/*
X	 *	The 3MAX implementation uses a mapping register, which maps
X	 *	addresses between 0x200000 and 0x3fffff to the range 'offset'
X	 *	through 'offset'+0x1fffff. Set the mapping register to 
X	 *	map the correct range, and set the reference address for the
X	 *	access to be within the range base+0x000000 to base+0x3fffff.
X	 */
X	map_reg = (u_int *)(base + TCO_MAP_REGISTER);
X	if ( !MAP_IS_ON(map_reg) || (offset < 0x00200000) )
X	{
X		access.integer = base + offset;
X	}
X	else
X	{
X		SET_MAP(map_reg, MAP_VALUE(offset));
X		access.integer = base + TCO_3MAX_MAP_AREA + (offset & 0x001fffff);
X	}
X		
X
X	/*
X	 *	Perform the access based on the width required:
X	 */
X	switch( width )
X	{
X	  case 1:
X		return (u_int)*access.byte;
X	  case 2:
X		return (u_int)*access.half_word;
X	  case 4:
X		return (u_int)*access.word;
X	  default:
X		printf("peek: Unknown width specification %d encountered\n", width);
X		return 0;
X	}
X}
X
X/*"pixel_get"
X *
X *	Get the value of a pixel given the offset of its frame buffer,
X *	and its ordinal number within its frame buffer. 
X *
X *		= value of pixel
X */
Xu_int pixel_get(base, fb_offset, pixel_offset)
X	u_int	base;			/* -> base of turbo channel slot virt. addr. */ 
X	u_int	fb_offset;		/* =  location within turbo channel slot of fb. */
X	u_int	pixel_offset;	/* =  number within frame buffer of pixel. */
X{
X	Access		access;			/* Pointer alias for accessing pixel on Turbo bus. */
X	int			bit_number;		/* Number of bit within byte. */
X	u_char		*map_reg;		/* Frame buffer control register address. */
X
X	map_reg = (u_char *)(base + 0x40030);
X	switch ( fb_offset )
X	{
X      case TCO_EIGHT_BIT:
X        if ( MAP_IS_ON(map_reg) ) SET_MAP(map_reg, MAP_VALUE(TCO_EIGHT_BIT));
X        access.integer = base + fb_offset + pixel_offset;
X        return *access.byte;
X      case TCO_SELECTION:
X		access.integer = base + fb_offset + ((pixel_offset/8)*4);
X		bit_number = pixel_offset % 8;
X		return (*access.word & bit_get[bit_number]) >> bit_shift[bit_number];
X      case TCO_TRUE_COLOR:
X        if ( MAP_IS_ON(map_reg) ) 
X        {    
X            SET_MAP(map_reg, MAP_VALUE(fb_offset+pixel_offset*4));
X            access.integer = base + TCO_3MAX_MAP_AREA + ((pixel_offset*4)&MAP_3MAX_LOW_BITS);
X        }    
X		else
X		{
X			access.integer = base + fb_offset + (pixel_offset*4); 
X		}
X        return *access.word;
X      case TCO_VIDEO_ENABLE:
X        if ( MAP_IS_ON(map_reg) ) 
X        { 
X            SET_MAP(map_reg, MAP_VALUE(TCO_VIDEO_ENABLE));
X            access.integer = base + TCO_3MAX_MAP_AREA + ((pixel_offset/8)*4);
X        }    
X		else
X		{
X        	access.integer = base + fb_offset + ((pixel_offset/8)*4);
X		}
X        bit_number = pixel_offset % 8;
X		return (*access.word & bit_get[bit_number]) >> bit_shift[bit_number];
X	}
X}
X
X/*"pixel_set"
X *
X *	Set the value of a pixel given the offset of its frame buffer,
X *	and its ordinal number within its frame buffer. 
X *
X */
Xu_int pixel_set(base, fb_offset, pixel_offset, value)
X	u_int	base;			/* -> base of turbo channel slot virt. addr. */ 
X	u_int	fb_offset;		/* =  location within turbo channel slot of fb. */
X	u_int	pixel_offset;	/* =  number within frame buffer of pixel. */
X	u_int	value;			/* =  value for pixel. */
X{
X	Access		access;			/* Pointer alias for accessing pixel on Turbo bus. */
X	int			bit_number;		/* Number of bit within byte. */
X	u_char		*map_reg;		/* Frame buffer control register address. */
X
X	map_reg = (u_char *)(base + TCO_MAP_REGISTER);
X	switch ( fb_offset )
X	{
X	  case TCO_EIGHT_BIT:
X		if ( MAP_IS_ON(map_reg) ) SET_MAP(map_reg, 2);
X		access.integer = base + TCO_EIGHT_BIT + pixel_offset;
X		*access.byte = value;
X		break;
X	  case TCO_SELECTION:
X		access.integer = base + fb_offset + ((pixel_offset/8)*4);
X		bit_number = pixel_offset % 8;
X		*access.word = (*access.word & bit_clear[bit_number]) | 
X			((value & 0x1)	<< bit_shift[bit_number]);
X		break;
X	  case TCO_TRUE_COLOR:
X		if ( MAP_IS_ON(map_reg) ) 
X		{
X            SET_MAP(map_reg, MAP_VALUE(fb_offset+pixel_offset*4));
X            access.integer = base + TCO_3MAX_MAP_AREA + ((pixel_offset*4)&MAP_3MAX_LOW_BITS);
X        }    
X		else
X		{
X			access.integer = base + fb_offset + (pixel_offset*4); 
X		}
X		*access.word = value;
X		break;
X	  case TCO_VIDEO_ENABLE:
X		if ( MAP_IS_ON(map_reg) )
X		{
X			if ( MAP_VALUE(*map_reg) != MAP_VALUE(TCO_VIDEO_ENABLE) )
X				SET_MAP(map_reg, MAP_VALUE(TCO_VIDEO_ENABLE));
X			access.integer = base + TCO_3MAX_MAP_AREA + ((pixel_offset/8)*4);
X		}
X		else
X		{
X			access.integer = base + fb_offset + ((pixel_offset/8)*4);
X		}
X		bit_number = pixel_offset % 8;
X		*access.word = (*access.word & bit_clear[bit_number]) | 
X			((value & 0x1)	<< bit_shift[bit_number]);
X		break;
X	}
X	return;
X}
X
X/*"poke"
X *
X *	Set the contents of a location in a Turbo Bus slot's
X *	address space.
X *
X */
Xu_int poke(base, offset, width, value)
X	u_int	base;		/* -> base of turbo channel slot. */
X	u_int 	offset;		/* -> location within turbo channel slot to set. */
X	int		width;		/* =  size of location (1, 2, or 4). */
X	u_int	value;		/* =  value to place in location. */
X{
X	Access	access;			/* Pointer aliases. */
X	u_int	*map_reg;	/* Frame buffer control register address. */
X
X	/*
X	 *	The 3MAX implementation uses a mapping register, which maps
X	 *	addresses between 0x200000 and 0x3fffff to the range 'offset'
X	 *	through 'offset'+0x1fffff. Set the mapping register to 
X	 *	map the correct range, and set the reference address for the
X	 *	access to be within the range base+0x000000 to base+0x3fffff.
X	 */
X	map_reg = (u_int *)(base + TCO_MAP_REGISTER);
X	if ( MAP_IS_ON(map_reg) && (offset >= TCO_3MAX_MAP_AREA) )
X	{
X		SET_MAP(map_reg, MAP_VALUE(offset));
X		access.integer = base + TCO_3MAX_MAP_AREA + (offset & MAP_3MAX_LOW_BITS);
X	}
X	else
X	{
X		access.integer = base + offset;
X	}
X		
X	/*
X	 *	Perform the access based on the width required:
X	 */
X	switch( width )
X	{
X	  case 1:
X		*access.byte = value;
X		break;
X	  case 2:
X		*access.half_word = value;
X		break;
X	  case 4:
X		*access.word = value;
X		break;
X	  default:
X		printf("poke: Unknown width specification %d encountered\n", width);
X	}
X	return 0;
X}
X 
X/*"vector"
X *
X *	Draw a vector given a slot base and starting offset, as well as the
X *	vector to be drawn. This vector generator always draws vectors in the positive
X *  v direction. The u direction of the vector is controlled by the pitch value.
X *  The reason a u,v coordinate notation is used is that the meaning of u and v
X *  will be different depending on the vector being drawn:
X *      if delta x >= delta y then u = x, v = y
X *      if delta x <  delta y then u = y, v = x
X */
Xvector(base, fb_offset, color, xa, ya, xb, yb)
X	u_int	base;			/* -> start of turbo bus slot. */
X	u_int	fb_offset;		/* =  offset within slot of frame buffer. */
X    int     color;          /* =  color to write vector as. */
X	int		xa;				/* =  x component of vector start. */
X	int		ya;				/* =  y component of vector start. */
X	int		xb;				/* =  x component of vector end. */
X	int		yb;				/* =  y component of vector end. */
X{
X	
X    int     abs_dx;         /* ||xb - xa||. */
X    int     abs_dy;         /* ||yb - ya||. */
X	Access	access;			/* Pointer alias for referencing fb. */
X    int     dx;             /* xb - xa. */
X    int     dy;             /* yb - ya. */
X    int     length;         /* Max(delta_x, delta_y). */
X    int     pixel_offset;   /* Offset in pixels to draw next vector point at. */
X    int     old_v_carry;    /* Value of carry bit prior to adding slope. */
X    int     slope;          /* delta v / delta u. */
X    int     start;          /* Starting offset for the vector. */
X    int     u_increment;    /* Increment to offset for u movements. */
X    int     uv_increment;   /* Increment to offset for simulatneous u,v movements. */
X    int     v;              /* Current v position relative to original start offset. */
X 
X    dx = xb - xa;
X    dy = yb - ya;
X    abs_dx = dx >= 0 ? dx : -dx;
X    abs_dy = dy >= 0 ? dy : -dy;
X 
X    /*  Positive delta y: use xa,ya as the starting point of the vector.
X     */
X    if ( dy >= 0 )
X    {
X        start = xa + (ya * 1280);
X        if ( abs_dx > abs_dy )
X        {
X            length = abs_dx+1;
X            slope = CARRY * abs_dy / dx;
X            u_increment = dx > 0 ? 1 : -1;
X            uv_increment = 1280 + u_increment;
X        }
X        else if ( abs_dy != 0 )
X        {
X            length = abs_dy+1;
X            slope = CARRY * abs_dx / dy;
X            u_increment = 1280;
X            uv_increment = dx > 0 ? u_increment+1 : u_increment-1;
X        }
X        else    /* xa and xb are the same point! */
X        {
X            return;
X        }
X 
X    }
X    /*  Negative delta y: use xb, yb as the starting point of the vector.
X     */
X    else
X    {
X        start = xb + (yb * 1280);
X        if ( abs_dx > abs_dy )
X        {
X            length = abs_dx+1;
X            slope = CARRY * abs_dy / dx;
X            u_increment = dx < 0 ? 1 : -1;
X            uv_increment = 1280 + u_increment;
X        }
X        else if ( abs_dy != 0 )
X        {
X            length = abs_dy+1;
X            slope = CARRY * abs_dx / dy;
X            u_increment = 1280;
X            uv_increment = dx < 0 ? u_increment+1 : u_increment-1;
X        }
X    }
X 
X	/*	
X	 *	Loop generating actual vector, based on which frame buffer 
X	 *	is being accessed. 
X     *	  (v = slope)
X     */
X	v = CARRY / 2;
X	pixel_offset = start;
X 
X	while ( --length >= 0 )
X	{
X		pixel_set(base, fb_offset, pixel_offset, color);
X		old_v_carry = v & CARRY;
X		v += slope;
X		if ( ( v & CARRY ) != old_v_carry )
X		{
X			pixel_offset += uv_increment;
X		}
X		else
X		{
X			pixel_offset += u_increment;
X		}
X	}
X}
X
X
Xstatic void
Xrop_pip_init(index, addr, useBankSwitch)
X  int index;
X  unsigned char *addr;
X  Bool useBankSwitch;
X{
X    unsigned char *reg;
X    unsigned char *ptr;
X    int i;
X    ropStruct *rs;
X    rs = &ropInfo[index];
X    rs->board = addr;
X    rs->bit8 = rs->board + TCO_EIGHT_BIT;
X    rs->bit24 = rs->board + TCO_TRUE_COLOR;
X    rs->SelectionPlane = rs->board + TCO_SELECTION;
X    rs->VideoEnablePlane = rs->board + TCO_VIDEO_ENABLE;
X    rs->mapRegister = rs->board + TCO_MAP_REGISTER;
X    rs->MappedArea = rs->board + TCO_3MAX_MAP_AREA;
X    rs->pipRegisters = rs->board + TCO_PIP_REGISTERS;
X    rs->dutyCycle = rs->board + TCO_DUTY_CYCLE;
X
X    fill_selection(rs, 0, 0, 1280, 1024, 0x00);
X    *rs->mapRegister = useBankSwitch ? 0x82 : 0x92;
X}
X
X#include "pixmapstr.h"
X/*
XPaint the region "pRegion" in the selection memory with the value "hwCmap".
X*/
Xvoid
XropSetSelect(pScreen, pRegion, hwCmap)
X    ScreenPtr	pScreen;
X    RegionPtr	pRegion;
X    int		hwCmap;
X{
X    int nbox, w, h;
X    BoxPtr pbox;
X    u_int *board;
X    u_int fill;
X    RopPtr prop;
X
X    prop = &ropInfo[pScreen->myNum];
X    fill = (hwCmap == 1) ? 0xff : 0x00;
X    nbox = REGION_NUM_RECTS(pRegion);
X    pbox = REGION_RECTS(pRegion);
X
X    while (nbox--) {
X	w = pbox->x2 - pbox->x1;
X	h = pbox->y2 - pbox->y1;
X	fill_selection(prop, pbox->x1, pbox->y1, w, h, fill);
X	pbox++;
X    }
X}
X
X/*
XInputs: bank = -1 for 0x2, 0 for 0x4, 1 for 0x6, 2 for 0x8, 3 for 0xA
X*/
Xvoid
XropSetBank(pScreen, bank)
X    ScreenPtr	pScreen;
X    int		bank;
X{
X    unsigned char *mapReg = ropInfo[pScreen->myNum].mapRegister;
X
X    if (bank < -1 || bank > 3) {
X	bank = -1;
X    }
X    *mapReg = (*mapReg & 0xe0) | ((bank + 2) * 2);
X}
END_OF_FILE
if test 41193 -ne `wc -c <'server/ddx/dec/tx/rop.c'`; then
    echo shar: \"'server/ddx/dec/tx/rop.c'\" unpacked with wrong size!
fi
# end of 'server/ddx/dec/tx/rop.c'
fi
echo shar: End of archive 9 \(of 29\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 29 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Molecular Simulations, Inc.             mail: dcmartin@msi.com
796 N. Pastoria Avenue                  uucp: uunet!dcmartin
Sunnyvale, California 94086             at&t: 408/522-9236
