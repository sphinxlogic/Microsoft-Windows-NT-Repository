Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: dcc@Athena.MIT.EDU (David Carver)
Newsgroups: comp.sources.x
Subject: v16i071: Video Extension for X (v2r2), Part20/29
Message-ID: <1992Feb6.145834.845@msi.com>
Date: 6 Feb 92 14:58:34 GMT
References: <csx-16i052-vex.v2r2@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 3160
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: dcc@Athena.MIT.EDU (David Carver)
Posting-number: Volume 16, Issue 71
Archive-name: vex.v2r2/part20

# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
#		"End of archive 20 (of 29)."
# Contents:  extensions/xv/doc/xv-lib-v2.PS.ab
#   extensions/xv/doc/xv-lib-v2.PS.ah
#   extensions/xv/server/ddx/sunrop/pip_impl.h
#   server/ddx/cfb32/cfbpixmap.c server/ddx/cfb32/stipmips.s
# Wrapped by dcmartin@fascet on Thu Feb  6 06:52:49 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'extensions/xv/doc/xv-lib-v2.PS.ab' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extensions/xv/doc/xv-lib-v2.PS.ab'\"
else
echo shar: Extracting \"'extensions/xv/doc/xv-lib-v2.PS.ab'\" \(11041 characters\)
sed "s/^X//" >'extensions/xv/doc/xv-lib-v2.PS.ab' <<'END_OF_FILE'
X720 H
X7680 V
X720(4)S
X7920 V
XEP
X%%Page: 5 5
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X4025(XvGetPortAttribute)S
X5133(\()S
X5193(3X)S
X5360(\))S
X720 H
X1080 V
X9 B
X720(Name)S
X720 H
X1200 V
X10 R
X900(XvGetPortAttribute)S
X1724(\261)S
X1804(return)S
X2072(current)S
X2384(port)S
X2575(attribute)S
X2938(value)S
X720 H
X1368 V
X9 B
X720(Syntax)S
X720 H
X1488 V
X10 B
X900(#include)S
X1292(<X11/extensions/Xvlib.h>)S
X720 H
X1728 V
X900(XvGetPortAttribute\()S
X10 I
X1797(dpy,)S
X1996(port,)S
X2218(attribute,)S
X2618(p_value)S
X10 R
X2934(\))S
X720 H
X1968 V
X10 B
X900(Display)S
X10 I
X1253(*dpy)S
X10 R
X1447(;)S
X720 H
X2088 V
X10 B
X900(XvPortID)S
X10 I
X1351(port)S
X10 R
X1518(;)S
X720 H
X2208 V
X10 B
X900(Atom)S
X10 I
X1168(attribute)S
X10 R
X1513(;)S
X720 H
X2328 V
X10 B
X900(int)S
X10 I
X1047(*p_vlaue)S
X10 R
X1413(;)S
X720 H
X2616 V
X9 B
X720(Arguments)S
X720 H
X2736 V
X10 I
X900(dpy)S
X10 R
X1300(Speci\256es)S
X1691(the)S
X1843(display)S
X2162(screen)S
X2446(on)S
X2576(which)S
X2850(the)S
X3002(X)S
X3104(Server)S
X3394(is)S
X3491(to)S
X3599(accept)S
X3883(requests)S
X4240(from)S
X4464(X)S
X4566(clients.)S
X4912(If)S
X5008(the)S
X720 H
X2856 V
X1300(display)S
X1619(option)S
X1905(is)S
X2002(not)S
X2160(speci\256ed,)S
X2570(X)S
X2672(uses)S
X2874(the)S
X3026(display)S
X3345(screen)S
X3629(speci\256ed)S
X4014(by)S
X4144(your)S
X4357(DISPLAY)S
X4809(environment)S
X720 H
X2976 V
X1300(variable.)S
X1706(The)S
X1891(display)S
X2210(option)S
X2496(has)S
X2659(the)S
X2811(format)S
X3107(hostname:number.)S
X3908(Using)S
X4177(two)S
X4357(colons)S
X4648(\(::\))S
X4800(instead)S
X5113(of)S
X5226(one)S
X720 H
X3096 V
X1300(\(:\))S
X1424(indicates)S
X1809(that)S
X1989(DECnet)S
X2341(is)S
X2438(to)S
X2546(be)S
X2670(used)S
X2883(for)S
X3029(transport.)S
X720 H
X3264 V
X10 I
X900(port)S
X10 R
X1300(Speci\256es)S
X1691(the)S
X1843(port,)S
X2059(associated)S
X2499(with)S
X2707(the)S
X2859(given)S
X3111(display,)S
X3455(for)S
X3601(which)S
X3875(the)S
X4027(attribute)S
X4390(values)S
X4675(are)S
X4826(to)S
X4934(be)S
X720 H
X3384 V
X1300(returned.)S
X720 H
X3552 V
X10 I
X900(attribute)S
X10 R
X1300(An)S
X1452(atom)S
X1682(that)S
X1862(identi\256es)S
X2259(the)S
X2411(attribute)S
X2774(to)S
X2882(be)S
X3006(queried)S
X3335(by)S
X3465(this)S
X3640(request.)S
X4013(Control)S
X4349(atoms)S
X4618(are)S
X4769(obtained)S
X5143(using)S
X720 H
X3672 V
X1300(the)S
X1452(XInterAtom)S
X1970(request)S
X2288(with)S
X2496(a)S
X2570(string)S
X2828(from)S
X3052(the)S
X3204(following)S
X3623(table.)S
X720 H
X3840 V
X10 I
X900(p_value)S
X10 R
X1300(Pointer)S
X1619(to)S
X1727(the)S
X1879(location)S
X2231(where)S
X2504(the)S
X2656(attribute)S
X3019(value)S
X3265(is)S
X3362(written)S
X3675(on)S
X3805(return.)S
X720 H
X4008 V
X9 B
X720(Description)S
X720 H
X4128 V
X10 R
X900(XvGetPortAttribute\(3X\))S
X1912(returns)S
X2219(the)S
X2371(current)S
X2683(value)S
X2929(of)S
X3042(the)S
X3194(requested)S
X3606(port)S
X3797(attribute)S
X4160(in)S
X4268(the)S
X4420(integer)S
X4727(pointed)S
X5057(to)S
X5165(by)S
X720 H
X4248 V
X10 I
X900(p_value)S
X10 R
X1216(.)S
X1271(The)S
X1456(attribute)S
X1819(is)S
X1916(identi\256ed)S
X2324(using)S
X2571(an)S
X2695(Atom)S
X2953(that)S
X3133(equates)S
X3462(to)S
X3570(the)S
X3722(attribute)S
X4085(name.)S
X4356(The)S
X4541(XInterAtom)S
X5059(request)S
X720 H
X4368 V
X900(can)S
X1068(be)S
X1192(used)S
X1405(with)S
X1613(one)S
X1787(of)S
X1900(the)S
X2052(strings)S
X2349(below)S
X2623(to)S
X2731(return)S
X2999(a)S
X3073(matching)S
X3475(Atom.)S
X720 H
X7680 V
X5350(5)S
X7920 V
XEP
X%%Page: 6 6
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X720(XvGetPortAttribute)S
X1828(\()S
X1888(3X)S
X2055(\))S
X720 H
X980 V
X10 Y1
X900(2)S
X924(22222222222222222222222222222222222222222222222222)S
X720 H
X1148 V
X10 HB
X900(Attribute)S
X1344(String)S
X1964(Type)S
X2724(Default)S
X720 H
X1228 V
X10 Y1
X900(2)S
X924(22222222222222222222222222222222222222222222222222)S
X720 H
X1408 V
X10 R
X900("XV_ENCODING")S
X1964(XvEncodingID)S
X2724(Server)S
X3014(dependent)S
X720 H
X1528 V
X900("XV_HUE")S
X1964([-1000...1000])S
X2724(0)S
X720 H
X1648 V
X900("XV_SATURATION")S
X1964([-1000...1000])S
X2724(0)S
X720 H
X1768 V
X900("XV_BRIGHTNESS")S
X1964([-1000...1000])S
X2724(0)S
X720 H
X1888 V
X900("XV_CONTRAST")S
X1964([-1000...1000])S
X2724(0)S
X720 H
X1968 V
X10 Y1
X900(2)S
X924(22222222222222222222222222222222222222222222222222)S
X720 H
X2136 V
X9 B
X720(Examples)S
X720 H
X2256 V
X10 C
X1150(Example)S
X1630(between)S
X2110(.EX)S
X2350(and)S
X2590(.EE)S
X2830(will)S
X3130(show)S
X3430(in)S
X3610(monospace)S
X720 H
X2484 V
X9 B
X720(Returned)S
X1127(Values)S
X720 H
X2604 V
X10 B
X900([Success])S
X720 H
X2724 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(XvGetPortAttribute\(3X\))S
X2799(completed)S
X3245(successfully.)S
X720 H
X2892 V
X10 B
X900([XvBadExtension])S
X720 H
X3012 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(the)S
X1939(Xv)S
X2091(extension)S
X2504(is)S
X2601(unavailable.)S
X720 H
X3180 V
X10 B
X900([XvBadAlloc])S
X720 H
X3300 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(XvGetPortAttribute\(3X\))S
X2799(failed)S
X3056(to)S
X3164(allocate)S
X3504(memory)S
X3867(to)S
X3975(process)S
X4304(the)S
X4456(request.)S
X720 H
X3468 V
X9 B
X720(Diagnostics)S
X720 H
X3588 V
X10 B
X900([XvBadPort])S
X720 H
X3708 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(the)S
X1982(requested)S
X2394(port)S
X2585(does)S
X2798(not)S
X2956(exist.)S
X720 H
X3876 V
X10 B
X900([BadMatch])S
X720 H
X3996 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(the)S
X1982(requested)S
X2394(attribute)S
X2757(atom)S
X2987(does)S
X3200(not)S
X3358(specify)S
X3676(an)S
X3800(attribute)S
X4163(supported)S
X4587(by)S
X4717(the)S
X4869(adaptor.)S
X720 H
X4164 V
X9 B
X720(See)S
X892(Also)S
X720 H
X4284 V
X10 R
X900(XvSetPortAttribute\(3X\),)S
X1921(XvPortNotify\(3X\))S
X720 H
X7680 V
X720(6)S
X7920 V
XEP
X%%Page: 7 7
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X4543(XvGetStill)S
X5133(\()S
X5193(3X)S
X5360(\))S
X720 H
X1080 V
X9 B
X720(Name)S
X720 H
X1200 V
X10 R
X900(XvGetStill)S
X1364(\261)S
X1444(capture)S
X1767(a)S
X1841(single)S
X2110(frame)S
X2372(of)S
X2485(video)S
X2737(from)S
X2961(a)S
X3035(drawable)S
X720 H
X1368 V
X9 B
X720(Syntax)S
X720 H
X1488 V
X10 B
X900(include)S
X1242(Xvlib.h)S
X720 H
X1728 V
X900(XvGetStill\()S
X10 I
X1383(dpy,)S
X1582(port,)S
X1804(d,)S
X1909(gc,)S
X2058(vx,)S
X2201(vy,)S
X720 H
X1968 V
X10 B
X900(register)S
X10 I
X1256(Display)S
X1597(*dpy;)S
X720 H
X2088 V
X10 B
X900(XvPortID)S
X10 I
X1351(port;)S
X720 H
X2208 V
X10 B
X900(Drawable)S
X10 I
X1346(d;)S
X720 H
X2328 V
X10 B
X900(GC)S
X10 I
X1080(gc;)S
X720 H
X2448 V
X10 B
X900(int)S
X10 I
X1047(vx,)S
X1190(vy,)S
X1333(dx,)S
X1482(dy;)S
X720 H
X2568 V
X10 B
X900(unsigned)S
X1315(int)S
X10 I
X1462(vw,)S
X1628(vh;)S
X720 H
X2688 V
X10 B
X900(unsigned)S
X1315(int)S
X10 I
X1462(dw,)S
X1634(dh;)S
X720 H
X2976 V
X9 B
X720(Arguments)S
X720 H
X3096 V
X10 I
X900(dpy)S
X10 R
X1650(Speci\256es)S
X2041(the)S
X2193(display)S
X2512(screen)S
X2796(on)S
X2926(which)S
X3200(the)S
X3352(Xv)S
X3504(Server)S
X3794(is)S
X3891(to)S
X3999(accept)S
X4283(requests)S
X4640(from)S
X4864(Xv)S
X5016(clients.)S
X720 H
X3216 V
X1650(If)S
X1746(the)S
X1898(display)S
X2217(option)S
X2503(is)S
X2600(not)S
X2758(speci\256ed,)S
X3168(Xv)S
X3320(uses)S
X3522(the)S
X3674(display)S
X3993(screen)S
X4277(speci\256ed)S
X4662(by)S
X4792(your)S
X720 H
X3336 V
X1650(DISPLAY)S
X2102(environment)S
X2637(variable.)S
X3043(The)S
X3228(display)S
X3547(option)S
X3833(has)S
X3996(the)S
X4148(format)S
X4444(hostname:number.)S
X720 H
X3456 V
X1650(Using)S
X1919(two)S
X2099(colons)S
X2390(\(::\))S
X2542(instead)S
X2855(of)S
X2968(one)S
X3142(\(:\))S
X3266(indicates)S
X3651(that)S
X3831(DECnet)S
X4183(is)S
X4280(to)S
X4388(be)S
X4512(used)S
X4725(for)S
X4871(transport.)S
X720 H
X3624 V
X10 I
X900(port)S
X10 R
X1650(De\256nes)S
X1985(the)S
X2137(port)S
X2328(to)S
X2436(which)S
X2710(the)S
X2862(still)S
X3043(is)S
X3140(outputed.)S
X720 H
X3792 V
X10 I
X900(d)S
X10 R
X1650(De\256nes)S
X1985(the)S
X2137(drawable)S
X2532(from)S
X2756(which)S
X3030(the)S
X3182(still)S
X3363(is)S
X3460(to)S
X3568(be)S
X3692(captured.)S
X720 H
X3960 V
X10 I
X900(gc)S
X10 R
X1650(De\256nes)S
X1985(the)S
X2137(graphical)S
X2538(context.)S
X2917(GC)S
X3086(components)S
X3599(are:)S
X10 I
X3778(subwindow-mode,)S
X4533(clip-x-origin,)S
X5093(clip-y-)S
X720 H
X4080 V
X1650(origin,)S
X10 R
X1950(and)S
X10 I
X2124(clip-mask.)S
X720 H
X4248 V
X900(vx,vy,vw,vh)S
X10 R
X1650(De\256ne)S
X1946(the)S
X2098(location)S
X2450(and)S
X2624(size)S
X2809(of)S
X2922(the)S
X3074(destination)S
X3543(video)S
X3795(region)S
X4080(into)S
X4266(which)S
X4540(the)S
X4692(still)S
X4873(is)S
X4970(to)S
X5078(be)S
X5202(writ-)S
X720 H
X4368 V
X1650(ten.)S
X10 I
X1857(vx)S
X10 R
X1975(and)S
X10 I
X2149(vy)S
X10 R
X2267(de\256ne)S
X2541(the)S
X10 I
X2693(x)S
X2767(and)S
X2947(y)S
X10 R
X3021(coordinates)S
X3511(of)S
X3624(the)S
X3776(upper-left)S
X4199(corner)S
X4483(of)S
X4596(the)S
X4748(video)S
X5000(region;)S
X720 H
X4488 V
X10 I
X1650(vw)S
X1791(and)S
X1971(vh)S
X10 R
X2095(de\256ne)S
X2369(the)S
X2521(width)S
X2779(and)S
X2953(height,)S
X3258(in)S
X3366(pixels,)S
X3660(of)S
X3773(the)S
X3925(video)S
X4177(region.)S
X720 H
X4656 V
X10 I
X900(dx,dy,dw,dh)S
X10 R
X1650(De\256ne)S
X1946(the)S
X2098(location)S
X2450(and)S
X2624(size)S
X2809(of)S
X2922(the)S
X3074(source)S
X3364(drawable)S
X3759(from)S
X3983(which)S
X4257(the)S
X4409(still)S
X4590(image)S
X4864(is)S
X4961(to)S
X5069(be)S
X5193(cap-)S
X720 H
X4776 V
X1650(tured.)S
X10 I
X1910(dx)S
X2034(and)S
X2214(dy)S
X10 R
X2338(de\256ne)S
X2612(the)S
X10 I
X2764(x)S
X2838(and)S
X3018(y)S
X10 R
X3092(coordinates)S
X3582(of)S
X3695(the)S
X3847(upper-left)S
X4270(corner)S
X4554(of)S
X4667(the)S
X4819(drawable)S
X720 H
X4896 V
X1650(region;)S
X10 I
X1963(dw)S
X2110(and)S
X2290(dh)S
X10 R
X2420(de\256ne)S
X2694(the)S
X2846(width)S
X3104(and)S
X3278(height,)S
X3583(in)S
X3691(pixels,)S
X3985(of)S
X4098(the)S
X4250(drawable)S
X4645(region.)S
X720 H
X5064 V
X9 B
X720(Description)S
X720 H
X5184 V
X10 TR
X916(XvGetStill)S
X10 R
X1402(captures)S
X1764(a)S
X1838(single)S
X2107(frame)S
X2369(of)S
X2482(video)S
X2734(from)S
X2958(a)S
X3032(drawable.)S
X3482(The)S
X3667(position)S
X4020(and)S
X4194(size)S
X4379(of)S
X4492(the)S
X4644(destination)S
X720 H
X5304 V
X900(\(video\))S
X1218(rectangle)S
X1613(is)S
X1710(speci\256ed)S
X2095(by)S
X10 I
X2225(vx,)S
X2368(vy,)S
X2511(vw)S
X10 R
X2622(,)S
X2677(and)S
X10 I
X2851(vh)S
X10 R
X2945(.)S
X3030(The)S
X3215(position)S
X3568(and)S
X3742(size)S
X3927(of)S
X4040(the)S
X4192(source)S
X4482(\(drawable\))S
X4943(rectangle)S
X720 H
X5424 V
X900(is)S
X997(speci\256ed)S
X1382(by)S
X10 I
X1512(dx,)S
X1661(dy,)S
X1810(dw)S
X10 R
X1927(,)S
X1982(and)S
X10 I
X2156(dh)S
X10 R
X2256(.)S
X720 H
X5592 V
X900(Drawable)S
X1317(data)S
X1513(is)S
X1610(clipped)S
X1934(to)S
X2042(the)S
X2194(bounds)S
X2513(of)S
X2626(the)S
X2778(drawable,)S
X3198(scaled)S
X3477(to)S
X3585(the)S
X3737(requested)S
X4149(video)S
X4401(region)S
X4686(size)S
X4871(\(or)S
X5017(the)S
X720 H
X5712 V
X900(closest)S
X1202(size)S
X1387(supported\))S
X1844(and)S
X2018(clipped)S
X2342(to)S
X2450(the)S
X2602(bounds)S
X2921(of)S
X3034(the)S
X3186(video)S
X3438(encoding.)S
X3889(The)S
X4074(contents)S
X4437(of)S
X4550(any)S
X4724(region)S
X5009(not)S
X720 H
X5832 V
X900(updated)S
X1246(with)S
X1454(drawable)S
X1849(data)S
X2045(is)S
X2142(unde\256ned.)S
X720 H
X6000 V
X900(If)S
X996(the)S
X1148(still)S
X1329(is)S
X1426(successfully)S
X1944(captured)S
X2317(an)S
X2441(XvVideoNotify)S
X3098(event)S
X3344(with)S
X3552(detail)S
X3804(XvStill)S
X4124(is)S
X4221(generated)S
X4638(for)S
X4784(the)S
X4936(drawable.)S
X720 H
X6120 V
X900(If)S
X996(the)S
X1148(port)S
X1339(is)S
X1436(grabbed)S
X1787(by)S
X1917(another)S
X2246(client,)S
X2523(this)S
X2698(request)S
X3016(is)S
X3113(ignored,)S
X3473(and)S
X3647(an)S
X3771(XvVideoNotify)S
X4428(event)S
END_OF_FILE
if test 11041 -ne `wc -c <'extensions/xv/doc/xv-lib-v2.PS.ab'`; then
    echo shar: \"'extensions/xv/doc/xv-lib-v2.PS.ab'\" unpacked with wrong size!
fi
# end of 'extensions/xv/doc/xv-lib-v2.PS.ab'
fi
if test -f 'extensions/xv/doc/xv-lib-v2.PS.ah' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extensions/xv/doc/xv-lib-v2.PS.ah'\"
else
echo shar: Extracting \"'extensions/xv/doc/xv-lib-v2.PS.ah'\" \(11096 characters\)
sed "s/^X//" >'extensions/xv/doc/xv-lib-v2.PS.ah' <<'END_OF_FILE'
X1787(the)S
X1939(Xv)S
X2091(extension)S
X2504(is)S
X2601(unavailable.)S
X720 H
X4932 V
X10 B
X900([XvBadAlloc])S
X720 H
X5052 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(XvSelectPortNotify\(3X\))S
X2799(failed)S
X3056(to)S
X3164(allocate)S
X3504(memory)S
X3867(to)S
X3975(process)S
X4304(the)S
X4456(request.)S
X720 H
X5220 V
X9 B
X720(Diagnostics)S
X720 H
X5340 V
X10 B
X900([XvBadPort])S
X720 H
X5460 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(the)S
X1982(requested)S
X2394(port)S
X2585(does)S
X2798(not)S
X2956(exist.)S
X720 H
X5628 V
X9 B
X720(See)S
X892(Also)S
X720 H
X5748 V
X10 R
X900(XvSetPortNotify\(3X\),)S
X1821(XvSetPortAttribute\(3X\),)S
X2842(XvPortNotify\(3X\))S
X720 H
X7680 V
X5300(23)S
X7920 V
XEP
X%%Page: 24 24
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X720(XvSelectVideoNotify)S
X1909(\()S
X1969(3X)S
X2136(\))S
X720 H
X1080 V
X9 B
X720(Name)S
X720 H
X1200 V
X10 R
X900(XvSelectVideoNotify)S
X1801(\261)S
X1881(enable)S
X2171(or)S
X2284(disable)S
X2597(VideoNotify)S
X3132(events)S
X720 H
X1368 V
X9 B
X720(Syntax)S
X720 H
X1488 V
X10 B
X900(#include)S
X10 I
X1292(<X11/extensions/Xvlib.h>)S
X720 H
X1728 V
X10 B
X900(XvSelectVideoNotify\()S
X10 I
X1820(dpy,)S
X2019(drawable,)S
X2452(ono)S
X2602 H
X	(f)show 10 -.5 mul h (f)show
X10 I
X10 R
X2653(\))S
X720 H
X1968 V
X10 B
X900(register)S
X1256(Display)S
X10 I
X1609(*dpy)S
X10 R
X1803(;)S
X720 H
X2088 V
X10 B
X900(Drawable)S
X10 I
X1346(drawable)S
X10 R
X1724(;)S
X720 H
X2208 V
X10 B
X900(Bool)S
X10 I
X1125(ono)S
X1275 H
X	(f)show 10 -.5 mul h (f)show
X10 I
X10 R
X1326(;)S
X720 H
X2376 V
X9 B
X720(Arguments)S
X720 H
X2496 V
X10 I
X900(dpy)S
X10 R
X1650(Speci\256es)S
X2041(the)S
X2193(display)S
X2512(screen)S
X2796(on)S
X2926(which)S
X3200(the)S
X3352(Xv)S
X3504(Server)S
X3794(is)S
X3891(to)S
X3999(accept)S
X4283(requests)S
X4640(from)S
X4864(Xv)S
X5016(clients.)S
X720 H
X2616 V
X1650(If)S
X1746(the)S
X1898(display)S
X2217(option)S
X2503(is)S
X2600(not)S
X2758(speci\256ed,)S
X3168(Xv)S
X3320(uses)S
X3522(the)S
X3674(display)S
X3993(screen)S
X4277(speci\256ed)S
X4662(by)S
X4792(your)S
X720 H
X2736 V
X1650(DISPLAY)S
X2102(environment)S
X2637(variable.)S
X3043(The)S
X3228(display)S
X3547(option)S
X3833(has)S
X3996(the)S
X4148(format)S
X4444(hostname:number.)S
X720 H
X2856 V
X1650(Using)S
X1919(two)S
X2099(colons)S
X2390(\(::\))S
X2542(instead)S
X2855(of)S
X2968(one)S
X3142(\(:\))S
X3266(indicates)S
X3651(that)S
X3831(DECnet)S
X4183(is)S
X4280(to)S
X4388(be)S
X4512(used)S
X4725(for)S
X4871(transport.)S
X720 H
X3024 V
X10 I
X900(drawable)S
X10 R
X1650(De\256nes)S
X1985(the)S
X2137(drawable)S
X2532(in)S
X2640(which)S
X2914(video)S
X3166(activity)S
X3496(is)S
X3593(to)S
X3701(be)S
X3825(reported.)S
X720 H
X3192 V
X10 I
X900(ono)S
X1050 H
X	(f)show 10 -.5 mul h (f)show
X10 I
X10 R
X1650(Selects)S
X1963(whether)S
X2314(video)S
X2566(noti\256cation)S
X3052(is)S
X3149(enabled)S
X3489(or)S
X3602(disabled.)S
X720 H
X3360 V
X9 B
X720(Description)S
X720 H
X3480 V
X10 R
X900(XvSelectVideoNotify\(3X\))S
X1989(enables)S
X2318(or)S
X2431(disables)S
X2783(events)S
X3068(to)S
X3176(be)S
X3300(reported)S
X3662(for)S
X3808(video)S
X4060(activity)S
X4390(in)S
X4498(a)S
X4572(drawable.)S
X720 H
X3648 V
X9 B
X720(Examples)S
X720 H
X3768 V
X10 C
X1150(Example)S
X1630(between)S
X2110(.EX)S
X2350(and)S
X2590(.EE)S
X2830(will)S
X3130(show)S
X3430(in)S
X3610(monospace)S
X720 H
X3996 V
X9 B
X720(Returned)S
X1127(Values)S
X720 H
X4116 V
X10 B
X900([Success])S
X720 H
X4236 V
X10 R
X1300(Returns)S
X1641(True)S
X1859(if)S
X1950(XvSelectVideoNotify\(3X\))S
X3039(completed)S
X3485(successfully.)S
X720 H
X4404 V
X10 B
X900([XvBadExtension])S
X720 H
X4524 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(the)S
X1939(Xv)S
X2091(extension)S
X2504(is)S
X2601(unavailable.)S
X720 H
X4692 V
X10 B
X900([XvBadAlloc])S
X720 H
X4812 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(XvSelectVideoNotify\(3X\))S
X2876(failed)S
X3133(to)S
X3241(allocate)S
X3581(memory)S
X3944(to)S
X4052(process)S
X4381(the)S
X4533(request.)S
X720 H
X4980 V
X10 B
X900([BadDrawable])S
X720 H
X5100 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(the)S
X1982(requested)S
X2394(drawable)S
X2789(does)S
X3002(not)S
X3160(exist.)S
X720 H
X5268 V
X9 B
X720(See)S
X892(Also)S
X720 H
X5388 V
X10 R
X900(XvVideoNotify)S
X720 H
X7680 V
X720(24)S
X7920 V
XEP
X%%Page: 25 25
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X4039(XvSetPortAttribute)S
X5133(\()S
X5193(3X)S
X5360(\))S
X720 H
X1080 V
X9 B
X720(Name)S
X720 H
X1200 V
X10 R
X900(XvSetPortAttribute)S
X1708(\261)S
X1788(sets)S
X1968(an)S
X2092(attribute)S
X2455(of)S
X2568(a)S
X2642(video)S
X2894(port)S
X720 H
X1368 V
X9 B
X720(Syntax)S
X720 H
X1488 V
X10 B
X900(#include)S
X1292(<X11/extensions/Xvlib.h>)S
X720 H
X1728 V
X900(XvSetPortAttribute\()S
X10 I
X1775(dpy,)S
X1974(port,)S
X2196(attribute,)S
X2596(value)S
X10 R
X2812(\))S
X720 H
X1968 V
X10 B
X900(Display)S
X10 I
X1253(*dpy)S
X10 R
X1447(;)S
X720 H
X2088 V
X10 B
X900(XvPortID)S
X10 I
X1351(port)S
X10 R
X1518(;)S
X720 H
X2208 V
X10 B
X900(Atom)S
X10 I
X1168(attribute)S
X10 R
X1513(;)S
X720 H
X2328 V
X10 B
X900(int)S
X10 I
X1047(value)S
X10 R
X1263(;)S
X720 H
X2496 V
X9 B
X720(Arguments)S
X720 H
X2616 V
X10 I
X900(dpy)S
X10 R
X1650(Speci\256es)S
X2041(the)S
X2193(display)S
X2512(screen)S
X2796(on)S
X2926(which)S
X3200(the)S
X3352(Xv)S
X3504(Server)S
X3794(is)S
X3891(to)S
X3999(accept)S
X4283(requests)S
X4640(from)S
X4864(Xv)S
X5016(clients.)S
X720 H
X2736 V
X1650(If)S
X1746(the)S
X1898(display)S
X2217(option)S
X2503(is)S
X2600(not)S
X2758(speci\256ed,)S
X3168(Xv)S
X3320(uses)S
X3522(the)S
X3674(display)S
X3993(screen)S
X4277(speci\256ed)S
X4662(by)S
X4792(your)S
X720 H
X2856 V
X1650(DISPLAY)S
X2102(environment)S
X2637(variable.)S
X3043(The)S
X3228(display)S
X3547(option)S
X3833(has)S
X3996(the)S
X4148(format)S
X4444(hostname:number.)S
X720 H
X2976 V
X1650(Using)S
X1919(two)S
X2099(colons)S
X2390(\(::\))S
X2542(instead)S
X2855(of)S
X2968(one)S
X3142(\(:\))S
X3266(indicates)S
X3651(that)S
X3831(DECnet)S
X4183(is)S
X4280(to)S
X4388(be)S
X4512(used)S
X4725(for)S
X4871(transport.)S
X720 H
X3144 V
X10 I
X900(port)S
X10 R
X1650(Speci\256es)S
X2041(the)S
X2193(port)S
X2384(for)S
X2530(which)S
X2804(the)S
X2956(attribute)S
X3319(is)S
X3416(to)S
X3524(be)S
X3648(used.)S
X720 H
X3312 V
X10 I
X900(attribute)S
X10 R
X1650(Identi\256es)S
X2052(the)S
X2204(port)S
X2395(attribute)S
X2758(to)S
X2866(be)S
X2990(set)S
X3131(by)S
X3261(this)S
X3436(request.)S
X3809(Can)S
X4000(be)S
X4124(one)S
X4298(of)S
X4411(the)S
X4563(table)S
X4787(entries)S
X5083(under)S
X720 H
X3432 V
X1650(the)S
X1802(column)S
X2132("String,")S
X2514(below.)S
X720 H
X3600 V
X10 I
X900(value)S
X10 R
X1650(Identi\256es)S
X2052(the)S
X2204(value)S
X2450(to)S
X2558(which)S
X10 I
X2832(attribute)S
X10 R
X3207(is)S
X3304(to)S
X3412(be)S
X3536(set.)S
X3732(Can)S
X3923(be)S
X4047(one)S
X4221(of)S
X4334(the)S
X4486(table)S
X4710(entries)S
X5006(under)S
X5263(the)S
X720 H
X3720 V
X1650(column)S
X1980("Type,")S
X2322(below.)S
X720 H
X3888 V
X9 B
X720(Description)S
X720 H
X4008 V
X10 R
X900(XvSetPortAttribute\(3X\))S
X1896(permits)S
X2226(a)S
X2300(client)S
X2552(to)S
X2660(set)S
X2801(the)S
X2953(port)S
X3144(attribute)S
X3507(to)S
X3615(speci\256ed)S
X4000(values.)S
X4340(This)S
X4548(request)S
X4866(supports)S
X5235(the)S
X720 H
X4128 V
X900(following)S
X1319(values:)S
X720 H
X7680 V
X5300(25)S
X7920 V
XEP
X%%Page: 26 26
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X720(XvSetPortAttribute)S
X1814(\()S
X1874(3X)S
X2041(\))S
X720 H
X980 V
X10 Y1
X900(2)S
X924(22222222222222222222222222222222222222222222222222)S
X720 H
X1148 V
X10 HB
X900(Control)S
X1283(String)S
X1964(Type)S
X2724(Default)S
X720 H
X1228 V
X10 Y1
X900(2)S
X924(22222222222222222222222222222222222222222222222222)S
X720 H
X1408 V
X10 R
X900("XV_ENCODING")S
X1964(XvEncodingID)S
X2724(Server)S
X3014(dependent)S
X720 H
X1528 V
X900("XV_HUE")S
X1964([-1000...1000])S
X2724(0)S
X720 H
X1648 V
X900("XV_SATURATION")S
X1964([-1000...1000])S
X2724(0)S
X720 H
X1768 V
X900("XV_BRIGHTNESS")S
X1964([-1000...1000])S
X2724(0)S
X720 H
X1888 V
X900("XV_CONTRAST")S
X1964([-1000...1000])S
X2724(0)S
X720 H
X1968 V
X10 Y1
X900(2)S
X924(22222222222222222222222222222222222222222222222222)S
X720 H
X2136 V
X10 R
X900(The)S
X1085(supplied)S
X1454(encoding)S
X1850(must)S
X2075(be)S
X2199(one)S
X2373(of)S
X2486(the)S
X2638(encodings)S
X3073(listed)S
X3320(for)S
X3466(the)S
X3618(adaptor,)S
X3972(otherwise)S
X4390(an)S
X4514(Encoding)S
X4927(error)S
X720 H
X2256 V
X900(results.)S
X720 H
X2424 V
X900(If)S
X996(the)S
X1148(adaptor)S
X1477(does)S
X1690(not)S
X1848(support)S
X2178(the)S
X2330(exact)S
X2570(hue,)S
X2769(saturation,)S
X3218(brightness,)S
X3684(and)S
X3858(contrast)S
X4204(levels)S
X4467(supplied,)S
X4861(the)S
X5013(closest)S
X720 H
X2544 V
X900(levels)S
X1163(supported)S
X1587(are)S
X1738(assumed.)S
X2167(Use)S
X2352(XvGetPortAttribute\(3X\))S
X3364(to)S
X3472(query)S
X3729(the)S
X3881(resulting)S
X4261(levels.)S
X720 H
X2712 V
X900(When)S
X1168(an)S
X1292(XvSetPortAttribute\(3X\))S
X2288(request)S
X2606(is)S
X2703(processed,)S
X3151(a)S
X3225(PortControlNotify\(3X\))S
X4177(event)S
X4423(is)S
X4520(generated)S
X4937(for)S
X5083(all)S
X720 H
X2832 V
X900(clients)S
X1191(that)S
X1371(have)S
X1589(requested)S
X2001(for)S
X2147(port)S
X2338(changes)S
X2689(using)S
X2936(XvSelectPortNotify\(3X\).)S
X720 H
X3000 V
X9 B
X720(Examples)S
X720 H
X3120 V
X10 C
X1150(Example)S
X1630(between)S
X2110(.EX)S
X2350(and)S
X2590(.EE)S
X2830(will)S
X3130(show)S
X3430(in)S
X3610(monospace)S
X720 H
X3348 V
X9 B
X720(Returned)S
X1127(Values)S
X720 H
X3468 V
X10 B
X900([Success])S
X720 H
X3588 V
X10 R
X1300(Returns)S
X1641(True)S
X1859(if)S
X1950(XvSetPortAttribute\(3X\))S
X2946(completed)S
X3392(successfully.)S
X720 H
X3756 V
X10 B
X900([XvBadExtension])S
X720 H
X3876 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(the)S
X1939(Xv)S
X2091(extension)S
X2504(is)S
X2601(unavailable.)S
X720 H
X4044 V
X10 B
X900([XvBadAlloc])S
X720 H
X4164 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(XvSelectVideoNotify\(3X\))S
X2876(failed)S
X3133(to)S
X3241(allocate)S
X3581(memory)S
X3944(to)S
X4052(process)S
X4381(the)S
X4533(request.)S
X720 H
X4332 V
X9 B
X720(Diagnostics)S
X720 H
X4452 V
X10 B
X900([XvBadPort])S
X720 H
X4572 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(the)S
X1982(requested)S
X2394(port)S
X2585(does)S
X2798(not)S
X2956(exist.)S
X720 H
X4740 V
X10 B
X900([XvBadEncoding])S
X720 H
X4860 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(an)S
X1954(encoding)S
X2350(is)S
X2447(speci\256ed)S
X2832(that)S
X3012(does)S
X3225(not)S
X3383(exist.)S
X720 H
X5028 V
X10 B
X900([BadMatch])S
X720 H
X5148 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(the)S
X1982(requested)S
X2394(attribute)S
X2757(atom)S
X2987(does)S
X3200(not)S
X3358(specify)S
X3676(an)S
X3800(attribute)S
X4163(supported)S
X4587(by)S
X4717(the)S
X4869(adaptor.)S
X720 H
X5316 V
X9 B
X720(See)S
X892(Also)S
X720 H
X5436 V
X10 R
X900(XvGetPortAttribute\(3X\),)S
X1937(XvSelectPortNotify\(3X\),)S
X2974(XvPortNotify\(3X\))S
X720 H
X7680 V
X720(26)S
X7920 V
XEP
X%%Page: 27 27
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X4373(XvStopVideo)S
X5133(\()S
X5193(3X)S
X5360(\))S
X720 H
X1080 V
X9 B
X720(Name)S
X720 H
X1200 V
X10 R
X900(XvStopVideo)S
X1480(\261)S
X1560(stop)S
X1757(active)S
X2025(video)S
X720 H
X1368 V
X9 B
X720(Syntax)S
X720 H
X1488 V
X10 B
X900(#include)S
X1292(<X11/extensions/Xvlib.h>)S
X720 H
X1728 V
X900(XvStopVideo\()S
X10 I
X1500(dpy,)S
X1699(port,)S
X1921(draw)S
X10 R
X2127(\))S
X720 H
X1968 V
X10 B
X900(Display)S
X10 I
X1253(*dpy)S
X10 R
X1447(;)S
X720 H
X2088 V
X10 B
X900(XvPortID)S
X10 I
X1351(port)S
X10 R
X1518(;)S
X720 H
X2208 V
X10 B
X900(Drawable)S
X10 I
X1346(draw)S
X10 R
X1552(;)S
X720 H
X2376 V
X9 B
X720(Arguments)S
X720 H
X2496 V
X10 I
X900(dpy)S
X10 R
X1650(Speci\256es)S
X2041(the)S
X2193(display)S
X2512(screen)S
X2796(on)S
X2926(which)S
X3200(the)S
X3352(Xv)S
X3504(Server)S
X3794(is)S
X3891(to)S
END_OF_FILE
if test 11096 -ne `wc -c <'extensions/xv/doc/xv-lib-v2.PS.ah'`; then
    echo shar: \"'extensions/xv/doc/xv-lib-v2.PS.ah'\" unpacked with wrong size!
fi
# end of 'extensions/xv/doc/xv-lib-v2.PS.ah'
fi
if test -f 'extensions/xv/server/ddx/sunrop/pip_impl.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extensions/xv/server/ddx/sunrop/pip_impl.h'\"
else
echo shar: Extracting \"'extensions/xv/server/ddx/sunrop/pip_impl.h'\" \(11100 characters\)
sed "s/^X//" >'extensions/xv/server/ddx/sunrop/pip_impl.h' <<'END_OF_FILE'
X/*
X *	pip_impl.h: Instance control block for XV video extension support of various
X *			    Sun based video solutions.
X */
X#ifndef pipImpl_INCLUDED
X#define pipImpl_INCLUDED 
X
X#include <sys/ioccom.h>     /* Define _IOR and _IOW */
X#include <sbusdev/memfb.h>	/* SBus memory mapped frame buf layout. */
X#include <sundev/cg8reg.h>	/* TC register definitions. */
X/* #include <sbusdev/tv2reg.h> */	/* TV register definitions. */
X#include "pip_mmap.h"		/* Memory mapping routines. */
X#include "pip_obj.h"		/* Standard interface to Pip object. */
X
X/*
X *	Per device type private data:
X */
Xtypedef struct Tcl_Private {			/* Data private to TCL card. */
X	Pip_Init_Record pip_init_record;	/* TCL: EEPROM pip init record. */
X}	Tcl_Private;
X
Xtypedef struct Tv_Private {		/* Data private to TTVcard. */
X	Pip_Levels	levels;			/* Brightness, contrast, hue, saturation. */
X	int			horiz_skew;		/* Skew of origin of pip in horizontal. */
X	int			horiz_zero;		/* Venus value: horizontal screen position 0. */
X	int			vert_zero;		/* Venus value: vertical screen position 0. */
X}	Tv_Private;
X
X/* =============================================================================
X * ||                                                                         ||
X * || X Video Extension Object For Communicating With Video Hardware Support. ||
X * ||                                                                         ||
X * =============================================================================
X */
Xtypedef struct Pip_Object {
X	Pip_Obj   	 trvec;				/* Transfer vector THIS MUST BE FIRST!*/
X	Pip_Dst_Area destination_area;	/* Current pip destination (output) area. */
X    int        	 fb_height;    		/* # of lines in host fb. */
X	int			 fb_pitch;			/* # of pixels per host fb line. */
X	int			 fd;				/* File descriptor for device. */
X	Mmap_Obj	 *mmap_obj;			/* Memory map object. */
X	int			 pip_off_semaphore;	/* Resume / suspend semaphore. */
X	int			 screen;			/* X11 screen xv is for. */
X	Pip_Source	 source;			/* Source specification. */
X	Tcl_Private	 tcl;				/* Tcl w/Pip private data. */
X	Tv_Private	 tv;				/* Video window private data. */
X} Pip_Object;
X
X#ifndef pipio_DEFINED
X#define pipio_DEFINED
X
X/*  IOCTL definitions for the Sunview Support of RasterOps SPARC(tm) Card PIP
X *
X *  Notes:
X *    (1) PIPIO_G_FB_INFO is used even if this is not a RasterOps board!, so
X *        these definitions are necessary.
X *    (2) Note the difference in operation between PIPIO_G_PIP_ON_OFF_S_OFF and
X *        PIPIO_S_PIP_ON_OFF, 0. The first ioctl will wait for the pip to become
X *        inactive, the second ioctl does not. 
X *    (3) For Sunview PIPIO_G_PIP_ON_OFF_S_OFF is utilized to enforce a linear
X *        stream of execution (i.e., the wait for inactive loop in the kernel
X *        blocks out other processes.) However, time critical events like 
X *        ethernet packets may time out. For X windows PIPIO_S_PIP w/a polling 
X *        loop is used since the server enforces a linear stream of execution.
X *    (4) See the end of this file for brief descriptions of each ioctl.
X */
X
X/*    First unused ioctl number is 43.*/
X
X/*    EEPROM Write Byte operation control information:
X */
Xtypedef struct
X{
X    int        address;        /* Address in EEPROM to write to. */
X    int        value;            /* Value to write (in low-order 8 bits.) */
X}    EEPROM_Write_Byte;
X
X/*    Frame buffer and memory mapping information ioctl:
X */
Xtypedef struct    Fb_Description { /* Frame buffer description: */
X    short    group;                /* ... Sun "plane group" of frame buffer. */
X    short    width;                /* ... width of frame buffer. */
X    short    height;               /* ... height of frame buffer. */
X    short    depth;                /* ... depth of frame buffer. */
X    u_int    linebytes;            /* ... # of bytes per scan line for fb. */
X    u_int    mmap_size;            /* ... size of mapping for frame buffer. */
X    u_int    mmap_offset;          /* ... offset for memory map of fb. */
X}    Fb_Description;
X
X#define PIP_NFBS 10  /* # of frame buffer descriptions in Pipio_Fb_Info. */
X#define FB_NPGS  12  /* # of plane groups possible. */
X
Xtypedef struct Pipio_Fb_Info {              /* Frame buffer info record: */
X  int            frame_buffer_count;        /* ... # of fbs supported. */
X  u_int          total_mmap_size;           /* ... memory map size of all fbs */
X  Fb_Description fb_descriptions[PIP_NFBS]; /* ... individual fb descriptions */
X} Pipio_Fb_Info;
X
X/*    Frame buffer emulation ioctl:
X */
Xtypedef struct Pipio_Emulation {      /* Emulation control layout: */
X    u_char  plane_groups[FB_NPGS];    /* ... plane groups to enable. */
X    u_short timing;                   /* ... timing/size regimen. */
X} Pipio_Emulation;
X#define NATIVE_TIMING 0        /* Provide standard (default) timing. */
X#define NTSC_TIMING   1        /* Provide NTSC timing. */
X#define PAL_TIMING    2        /* Provide PAL timing. */
X
X/*    I/O controls used by Sunview Pixrect library routines.
X */
X#define PIPIO_G_FB_INFO      _IOR(X, 1, Pipio_Fb_Info) /* Get info about fbs. */
X#define PIPIO_G_EMULATION_MODE _IOR(X, 3, Pipio_Emulation) 
X									/* Return current emulation mode. */
X#define PIPIO_S_EMULATION_MODE _IOW(X, 4, Pipio_Emulation) 
X									/* Set the device being emulated. */
X#define PIPIO_G_PIP_ON_OFF     _IOR(X, 5, int)        
X									/* Get the value of the pip on bit. */ 
X#define PIPIO_S_PIP_ON_OFF  _IOW(X, 7, int) /* Set or clear pip on bit. */
X#define PIPIO_G_PIP_ON_OFF_RESUME  _IOR(X, 9, int)
X                          /* Resume (pop) pip operations, return new status. */
X#define PIPIO_G_PIP_ON_OFF_SUSPEND _IOR(X, 10, int)
X                          /* Get pip status, & suspend pip ops.*/
X
X#define PIPIO_G_CURSOR_COLOR_FREEZE _IOR(X, 40, int)    
X								/* Get setting of cursor color frozen switch. */
X#define PIPIO_S_CURSOR_COLOR_FREEZE _IOW(X, 41, int)    
X								/* Set cursor color frozen switch. */
X#define PIPIO_S_MAP_SLOT  _IOW(X, 42, int)    /* Map SBus slot at offset 0x900000. */
X#define PIPIO_G_TEST      _IOR(X, 43, int)    /* For testing purposes. */
X#define PIPIO_S_TEST      _IOW(X, 44, int)    /* For testing purposes. */
X
X/*    
X * ioctl(fd, PIPIO_G_CURSOR_COLOR_FREEZE, &boolean)
X *
X *  Return the current setting of the cursor color freeze flag. When set this 
X *  flag prevents changes to the cursor color entry in the overlay lookup table. 
X *  (This allows user's to specify the color for true color windows without 
X *  having Sunview override them.)
X *
X *  fd   - file descriptor for the PIP device ( acquired via open() )
X *  flag - where to place the current value of the flag, value will be 1 or 0
X *
X * ioctl(fd, PIPIO_G_EMULATION_MODE, &characteristics)
X *
X *   Return the current device characteristics being emulated by the device 
X *   driver. The returned values will indicate which plane groups are enabled 
X *   (values of 2), what plane groups are possible (values of 1), as well as the 
X *   timing regimen being used.
X *
X *     fd      - file descriptor for the PIP device ( acquired via open() )
X *     characteristics - where to place emulation characteristics 
X *                       (Pipio_Emulation) 
X *
X * ioctl(fd, PIPIO_G_FB_INFO, &boolean)
X *
X *   Return a description of the frame buffers presented by the device whose
X *   file descriptor is fd. The format of the information returned is described
X *   by the data type Pipio_Fb_Info specified earlier in this file.
X *
X *     fd   - file descriptor for the device ( acquired via open() )
X *     info - where to place the device's description in Pipio_Fb_Info format
X *
X * ioctl(fd, PIPIO_G_PIP_ON_OFF, &boolean)
X *
X *  Return the current setting of the Picture In a Picture (PIP) bit used
X *  to indicate whether the PIP is operating or not. The value will be 1 
X *  if the PIP is operating, or 0 if the PIP is halted.
X *
X *    fd      - file descriptor for the PIP device ( acquired via open() )
X *    boolean - where to place the current state of the PIP
X *
X * ioctl(fd, PIPIO_G_PIP_ON_OFF_S_OFF, &boolean)
X *
X *  Return the current setting of the Picture In a Picture (PIP) bit used
X *  to indicate whether the PIP is operating or not, and then halt the
X *  PIP. Set the pip operations semaphore to zero. The value returned 
X *  will be 1 if the PIP is operating, or 0 if the PIP is halted. 
X *  The return from the ioctl guarantees the PIP has halted (i.e., the kernel 
X *  will poll the device until it is inactive.)
X *
X *    fd      - file descriptor for the PIP device ( acquired via open() )
X *    boolean - where to place the current state of the PIP
X *
X * ioctl(fd, PIPIO_G_PIP_ON_OFF_RESUME, &boolean)
X *
X *  Decrement the pip operations semaphore by one, turning the pip on if the
X *  semaphore goes negative. Then return the current status of the pip wrt
X *  live video operations.
X *  The value will be 1 if the PIP is operating, or 0 if the PIP is halted. 
X *
X *    fd      - file descriptor for the PIP device ( acquired via open() )
X *    boolean - where to place the current state of the PIP
X *
X * ioctl(fd, PIPIO_G_PIP_ON_OFF_SUSPEND, &boolean)
X *
X *  Save the current status of live video operations in "boolean", then turn off
X *  the pip if it is on. Increment the pip operations semaphore by one.
X *  The value of boolean will be 1 if the PIP was operating, or 0 if the PIP 
X *  was halted. Note that if the pip was operating, it may continue to do so for
X *  up to 1/30 of a second after the ioctl call. Each call to 
X *  PIPIO_G_PIP_SUSPEND should be matched by a call to PIPIO_G_PIP_RESUME.
X *
X *    fd      - file descriptor for the PIP device ( acquired via open() )
X *    boolean - where to place the previous state of the PIP
X *
X * ioctl(fd, PIPIO_S_CURSOR_COLOR_FREEZE, &boolean)
X *
X *  Specify the value of the cursor color freeze flag. When set to 1 this flag
X *  prevents changes to the cursor color entry in the overlay lookup table. 
X *  (This allows user's to specify the color for true color windows without 
X *  having Sunview override them.) When set to zero the cursor color may be 
X *  changed (by Sunview or
X *  other programs.)
X *
X *    fd   - file descriptor for the PIP device ( acquired via open() )
X *    flag - where to get the current value of the flag, value should be 1 or 0
X *
X * ioctl(fd, PIPIO_S_PIP_ON_OFF, &boolean)
X *
X *  Start or halt the operation of the Picture In a Picture (PIP) scan 
X *  conversion process. If the value is one, the pip will be turned on and the 
X *  pip operations semaphore set to 1. If the value is zero the pip will be 
X *  turned off and the pip operations semaphore set to 0. Note that the ioctl 
X *  will not wait for the PIP to halt, it may run for up to 1/30 of a second 
X *  longer. 
X *
X *    fd      - file descriptor for the PIP device ( acquired via open() )
X *    boolean - where to get the intended state of the PIP
X *
X */
X
X#endif pipio_DEFINED
X
X/* DCC MOD MISSING SYMBOLS FROM cg8var.h */
X
X#ifndef PIPIO_S_MAP_SLOT
X#define PIPIO_S_MAP_SLOT  _IOW(X, 42, int)    /* Map SBus slot at offset 0x900000. */
X#endif
X
X/* END DCC MOD */
X
X#endif pipImpl_INCLUDED
X
END_OF_FILE
if test 11100 -ne `wc -c <'extensions/xv/server/ddx/sunrop/pip_impl.h'`; then
    echo shar: \"'extensions/xv/server/ddx/sunrop/pip_impl.h'\" unpacked with wrong size!
fi
# end of 'extensions/xv/server/ddx/sunrop/pip_impl.h'
fi
if test -f 'server/ddx/cfb32/cfbpixmap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/ddx/cfb32/cfbpixmap.c'\"
else
echo shar: Extracting \"'server/ddx/cfb32/cfbpixmap.c'\" \(10944 characters\)
sed "s/^X//" >'server/ddx/cfb32/cfbpixmap.c' <<'END_OF_FILE'
X/* $XConsortium: cfbpixmap.c,v 5.7 91/07/18 23:36:46 keith Exp $ */
X/***********************************************************
XCopyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
Xand the Massachusetts Institute of Technology, Cambridge, Massachusetts.
X
X                        All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the names of Digital or MIT not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XDIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XDIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X
X******************************************************************/
X/* pixmap management
X   written by drewry, september 1986
X
X   on a monchrome device, a pixmap is a bitmap.
X*/
X
X#include "Xmd.h"
X#include "servermd.h"
X#include "pixmapstr.h"
X
X#include "cfb.h"
X#include "mi.h"
X#include "cfbmskbits.h"
X
Xextern void mfbXRotatePixmap(), mfbYRotatePixmap();
X
X#if (BITMAP_BIT_ORDER == MSBFirst)
Xstatic int masktab[32] = 
X    {
X        0x00000000,
X        0x80000000,
X        0xC0000000,
X        0xE0000000,
X        0xF0000000,
X        0xF8000000,
X        0xFC000000,
X        0xFE000000,
X        0xFF000000,
X        0xFF800000,
X        0xFFC00000,
X        0xFFE00000,
X        0xFFF00000,
X        0xFFF80000,
X        0xFFFC0000,
X        0xFFFE0000,
X        0xFFFF0000,
X        0xFFFF8000,
X        0xFFFFC000,
X        0xFFFFE000,
X        0xFFFFF000,
X        0xFFFFF800,
X        0xFFFFFC00,
X        0xFFFFFE00,
X        0xFFFFFF00,
X        0xFFFFFF80,
X        0xFFFFFFC0,
X        0xFFFFFFE0,
X        0xFFFFFFF0,
X        0xFFFFFFF8,
X        0xFFFFFFFC,
X        0xFFFFFFFE
X    };
X#else
Xstatic int masktab[32] =
X        {
X        0x00000000,
X        0x00000001,
X        0x00000003,
X        0x00000007,
X        0x0000000F,
X        0x0000001F,
X        0x0000003F,
X        0x0000007F,
X        0x000000FF,
X        0x000001FF,
X        0x000003FF,
X        0x000007FF,
X        0x00000FFF,
X        0x00001FFF,
X        0x00003FFF,
X        0x00007FFF,
X        0x0000FFFF,
X        0x0001FFFF,
X        0x0003FFFF,
X        0x0007FFFF,
X        0x000FFFFF,
X        0x001FFFFF,
X        0x003FFFFF,
X        0x007FFFFF,
X        0x00FFFFFF,
X        0x01FFFFFF,
X        0x03FFFFFF,
X        0x07FFFFFF,
X        0x0FFFFFFF,
X        0x1FFFFFFF,
X        0x3FFFFFFF,
X        0x7FFFFFFF
X        };
X#endif
X
XPixmapPtr
XcfbCreatePixmap (pScreen, width, height, depth)
X    ScreenPtr	pScreen;
X    int		width;
X    int		height;
X    int		depth;
X{
X    register PixmapPtr pPixmap;
X    int size;
X    int bitsPerPixel;
X
X    if (depth != 1 && depth != DEPTH)
X	return NullPixmap;
X
X    bitsPerPixel = depth;
X    if (depth == DEPTH)
X	bitsPerPixel = PSZ;
X    size = PixmapBytePad(width, depth);
X    pPixmap = (PixmapPtr)xalloc(sizeof(PixmapRec) + (height * size));
X    if (!pPixmap)
X	return NullPixmap;
X    pPixmap->drawable.type = DRAWABLE_PIXMAP;
X    pPixmap->drawable.class = 0;
X    pPixmap->drawable.pScreen = pScreen;
X    pPixmap->drawable.depth = depth;
X    pPixmap->drawable.bitsPerPixel = bitsPerPixel;
X    pPixmap->drawable.id = 0;
X    pPixmap->drawable.serialNumber = NEXT_SERIAL_NUMBER;
X    pPixmap->drawable.x = 0;
X    pPixmap->drawable.y = 0;
X    pPixmap->drawable.width = width;
X    pPixmap->drawable.height = height;
X    pPixmap->devKind = size;
X    pPixmap->refcnt = 1;
X    pPixmap->devPrivate.ptr = (pointer)(pPixmap + 1);
X    return pPixmap;
X}
X
XBool
XcfbDestroyPixmap(pPixmap)
X    PixmapPtr pPixmap;
X{
X    if(--pPixmap->refcnt)
X	return TRUE;
X    xfree(pPixmap);
X    return TRUE;
X}
X
XPixmapPtr
XcfbCopyPixmap(pSrc)
X    register PixmapPtr	pSrc;
X{
X    register PixmapPtr	pDst;
X    int		size;
X
X    size = pSrc->drawable.height * pSrc->devKind;
X    pDst = (PixmapPtr) xalloc(sizeof(PixmapRec) + size);
X    if (!pDst)
X	return NullPixmap;
X    pDst->drawable = pSrc->drawable;
X    pDst->drawable.id = 0;
X    pDst->drawable.serialNumber = NEXT_SERIAL_NUMBER;
X    pDst->devKind = pSrc->devKind;
X    pDst->refcnt = 1;
X    pDst->devPrivate.ptr = (pointer)(pDst + 1);
X    bcopy((char *)pSrc->devPrivate.ptr, (char *)pDst->devPrivate.ptr, size);
X    return pDst;
X}
X
X
X/* replicates a pattern to be a full 32 bits wide.
X   relies on the fact that each scnaline is longword padded.
X   doesn't do anything if pixmap is not a factor of 32 wide.
X   changes width field of pixmap if successful, so that the fast
X	cfbXRotatePixmap code gets used if we rotate the pixmap later.
X	cfbYRotatePixmap code gets used if we rotate the pixmap later.
X
X   calculate number of times to repeat
X   for each scanline of pattern
X      zero out area to be filled with replicate
X      left shift and or in original as many times as needed
X*/
Xvoid
XcfbPadPixmap(pPixmap)
X    PixmapPtr pPixmap;
X{
X    register int width = (pPixmap->drawable.width) * (pPixmap->drawable.bitsPerPixel);
X    register int h;
X    register int mask;
X    register unsigned int *p;
X    register unsigned int bits; /* real pattern bits */
X    register int i;
X    int rep;                    /* repeat count for pattern */
X 
X    if (width >= 32)
X        return;
X
X    rep = 32/width;
X    if (rep*width != 32)
X        return;
X 
X    mask = masktab[width];
X 
X    p = (unsigned int *)(pPixmap->devPrivate.ptr);
X    for (h=0; h < pPixmap->drawable.height; h++)
X    {
X        *p &= mask;
X        bits = *p;
X        for(i=1; i<rep; i++)
X        {
X#if (BITMAP_BIT_ORDER == MSBFirst) 
X            bits >>= width;
X#else
X	    bits <<= width;
X#endif
X            *p |= bits;
X        }
X        p++;
X    }    
X    pPixmap->drawable.width = 32/(pPixmap->drawable.bitsPerPixel);
X}
X
X
X#ifdef notdef
X/*
X * cfb debugging routine -- assumes pixmap is 1 byte deep 
X */
Xstatic cfbdumppixmap(pPix)
X    PixmapPtr	pPix;
X{
X    unsigned int *pw;
X    char *psrc, *pdst;
X    int	i, j;
X    char	line[66];
X
X    ErrorF(  "pPixmap: 0x%x\n", pPix);
X    ErrorF(  "%d wide %d high\n", pPix->drawable.width, pPix->drawable.height);
X    if (pPix->drawable.width > 64)
X    {
X	ErrorF(  "too wide to see\n");
X	return;
X    }
X
X    pw = (unsigned int *) pPix->devPrivate.ptr;
X    psrc = (char *) pw;
X
X/*
X    for ( i=0; i<pPix->drawable.height; ++i )
X	ErrorF( "0x%x\n", pw[i] );
X*/
X
X    for ( i = 0; i < pPix->drawable.height; ++i ) {
X	pdst = line;
X	for(j = 0; j < pPix->drawable.width; j++) {
X	    *pdst++ = *psrc++ ? 'X' : ' ' ;
X	}
X	*pdst++ = '\n';
X	*pdst++ = '\0';
X	ErrorF( "%s", line);
X    }
X}
X#endif /* notdef */
X
X/* Rotates pixmap pPix by w pixels to the right on the screen. Assumes that
X * words are 32 bits wide, and that the least significant bit appears on the
X * left.
X */
Xvoid
XcfbXRotatePixmap(pPix, rw)
X    PixmapPtr	pPix;
X    register int rw;
X{
X    register unsigned int	*pw, *pwFinal;
X    register unsigned int	t;
X    int				rot;
X
X    if (pPix == NullPixmap)
X        return;
X
X    switch (((DrawablePtr) pPix)->bitsPerPixel) {
X	case PSZ:
X	    break;
X	case 1:
X	    mfbXRotatePixmap(pPix, rw);
X	    return;
X	default:
X	    ErrorF("cfbXRotatePixmap: unsupported bitsPerPixel %d\n", ((DrawablePtr) pPix)->bitsPerPixel);
X	    return;
X    }
X    pw = (unsigned int *)pPix->devPrivate.ptr;
X    modulus (rw, (int) pPix->drawable.width, rot);
X    if(pPix->drawable.width == PPW)
X    {
X        pwFinal = pw + pPix->drawable.height;
X	while(pw < pwFinal)
X	{
X	    t = *pw;
X	    *pw++ = SCRRIGHT(t, rot) |
X		    (SCRLEFT(t, (PPW-rot)) & cfbendtab[rot]);
X	}
X    }
X    else
X    {
X        ErrorF("cfb internal error: trying to rotate odd-sized pixmap.\n");
X#ifdef notdef
X	register unsigned int *pwTmp;
X	int size, tsize;
X
X	tsize = PixmapBytePad(pPix->drawable.width - rot, depth);
X	pwTmp = (unsigned int *) ALLOCATE_LOCAL(pPix->drawable.height * tsize);
X	if (!pwTmp)
X	    return;
X	/* divide pw (the pixmap) in two vertically at (w - rot) and swap */
X	tsize >>= 2;
X	size = pPix->devKind >> 2;
X	cfbQuickBlt((int *)pw, (int *)pwTmp,
X		    0, 0, 0, 0,
X		    (int)pPix->drawable.width - rot, (int)pPix->drawable.height,
X		    size, tsize);
X	cfbQuickBlt((int *)pw, (int *)pw,
X		    (int)pPix->drawable.width - rot, 0, 0, 0,
X		    rot, (int)pPix->drawable.height,
X		    size, size);
X	cfbQuickBlt((int *)pwTmp, (int *)pw,
X		    0, 0, rot, 0,
X		    (int)pPix->drawable.width - rot, (int)pPix->drawable.height,
X		    tsize, size);
X	DEALLOCATE_LOCAL(pwTmp);
X#endif
X    }
X}
X
X/* Rotates pixmap pPix by h lines.  Assumes that h is always less than
X   pPix->drawable.height
X   works on any width.
X */
Xvoid
XcfbYRotatePixmap(pPix, rh)
X    register PixmapPtr	pPix;
X    int	rh;
X{
X    int nbyDown;	/* bytes to move down to row 0; also offset of
X			   row rh */
X    int nbyUp;		/* bytes to move up to line rh; also
X			   offset of first line moved down to 0 */
X    char *pbase;
X    char *ptmp;
X    int	rot;
X
X    if (pPix == NullPixmap)
X	return;
X    switch (((DrawablePtr) pPix)->bitsPerPixel) {
X	case PSZ:
X	    break;
X	case 1:
X	    mfbYRotatePixmap(pPix, rh);
X	    return;
X	default:
X	    ErrorF("cfbYRotatePixmap: unsupported bitsPerPixel %d\n", ((DrawablePtr) pPix)->bitsPerPixel);
X	    return;
X    }
X
X    modulus (rh, (int) pPix->drawable.height, rot);
X    pbase = (char *)pPix->devPrivate.ptr;
X
X    nbyDown = rot * pPix->devKind;
X    nbyUp = (pPix->devKind * pPix->drawable.height) - nbyDown;
X    if(!(ptmp = (char *)ALLOCATE_LOCAL(nbyUp)))
X	return;
X
X    bcopy(pbase, ptmp, nbyUp);		/* save the low rows */
X    bcopy(pbase+nbyUp, pbase, nbyDown);	/* slide the top rows down */
X    bcopy(ptmp, pbase+nbyDown, nbyUp);	/* move lower rows up to row rot */
X    DEALLOCATE_LOCAL(ptmp);
X}
X
Xvoid
XcfbCopyRotatePixmap(psrcPix, ppdstPix, xrot, yrot)
X    register PixmapPtr psrcPix, *ppdstPix;
X    int	xrot, yrot;
X{
X    register PixmapPtr pdstPix;
X
X    if ((pdstPix = *ppdstPix) &&
X	(pdstPix->devKind == psrcPix->devKind) &&
X	(pdstPix->drawable.height == psrcPix->drawable.height))
X    {
X	bcopy((char *)psrcPix->devPrivate.ptr,
X	      (char *)pdstPix->devPrivate.ptr,
X	      psrcPix->drawable.height * psrcPix->devKind);
X	pdstPix->drawable.width = psrcPix->drawable.width;
X	pdstPix->drawable.depth = psrcPix->drawable.depth;
X	pdstPix->drawable.bitsPerPixel = psrcPix->drawable.bitsPerPixel;
X	pdstPix->drawable.serialNumber = NEXT_SERIAL_NUMBER;
X    }
X    else
X    {
X	if (pdstPix)
X	    cfbDestroyPixmap(pdstPix);
X	*ppdstPix = pdstPix = cfbCopyPixmap(psrcPix);
X	if (!pdstPix)
X	    return;
X    }
X    cfbPadPixmap(pdstPix);
X    if (xrot)
X	cfbXRotatePixmap(pdstPix, xrot);
X    if (yrot)
X	cfbYRotatePixmap(pdstPix, yrot);
X}
END_OF_FILE
if test 10944 -ne `wc -c <'server/ddx/cfb32/cfbpixmap.c'`; then
    echo shar: \"'server/ddx/cfb32/cfbpixmap.c'\" unpacked with wrong size!
fi
# end of 'server/ddx/cfb32/cfbpixmap.c'
fi
if test -f 'server/ddx/cfb32/stipmips.s' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/ddx/cfb32/stipmips.s'\"
else
echo shar: Extracting \"'server/ddx/cfb32/stipmips.s'\" \(7440 characters\)
sed "s/^X//" >'server/ddx/cfb32/stipmips.s' <<'END_OF_FILE'
X/*
X * $XConsortium: stipmips.s,v 1.8 90/12/02 12:13:05 keith Exp $
X *
X * Copyright 1990 Massachusetts Institute of Technology
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of M.I.T. not be used in advertising or
X * publicity pertaining to distribution of the software without specific,
X * written prior permission.  M.I.T. makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X *
X * M.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL M.I.T.
X * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
X * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
X * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X *
X * Author:  Keith Packard, MIT X Consortium
X */
X
X/*
X * MIPS assembly code for optimized text rendering.
X *
X * Other stippling could be done in assembly, but the payoff is
X * not nearly as large.  Mostly because large areas are heavily
X * optimized already.
X */
X
X#ifdef MIPSEL
X# define BitsR		sll
X# define BitsL		srl
X# define WO(o)		o
X# define FourBits(dest,bits)	and	dest, bits, 0xf
X#else
X# define BitsR	srl
X# define BitsL	sll
X# define WO(o)		o
X# define FourBits(dest,bits)	srl	dest, bits, 28
X#endif
X
X/* reordering instructions would be fatal here */
X	.set	noreorder
X
X	
X/*
X * stipplestack(addr, stipple, value, stride, Count, Shift)
X *               4       5       6      7     16(sp) 20(sp)
X *
X *  Apply successive 32-bit stipples starting at addr, addr+stride, ...
X *
X *  Used for text rendering, but only when no data could be lost
X *  when the stipple is shifted left by Shift bits
X */
X/* arguments */
X#define addr	$4
X#define stipple	$5
X#define value	$6
X#define stride	$7
X#define Count	16($sp)
X#define Shift	20($sp)
X
X/* local variables */
X#define count	$14
X#define shift	$13
X#define atemp	$12
X#define bits	$11
X#define lshift	$9
X#define sbase	$8
X#define stemp	$2
X
X#define CASE_SIZE	6	/* case blocks are 2^6 bytes each */
X#define CASE_MASK	0x3c0	/* first case mask */
X
X#define ForEachLine	$200
X#define NextLine	$201
X#define NextLine1	$202
X#define CaseBegin	$203
X#define ForEachBits	$204
X#define ForEachBits1	$205
X#define NextBits	$206
X
X#ifdef TETEXT
X#define	stipplestack32	stipplestack32te
X#endif
X
X	.globl	stipplestack32
X	.ent	stipplestack32 2
Xstipplestack32:
X	.frame	$sp, 0, $31
X	lw	count, Count			/* fetch stack params */
X	la	sbase,CaseBegin			/* load up switch table */
X	lw	shift, Shift
X	li	lshift, 4			/* compute offset within */
X	subu	lshift, lshift, shift		/*  stipple of remaining bits */
X#ifdef MIPSEL
X	addu	shift, shift, CASE_SIZE		/* first shift for LSB */
X#else
X	addu	shift, shift, 28-CASE_SIZE	/* first shift for MSB */
X#endif
X	/* do ... while (--count > 0); */
XForEachLine:
X	lw	bits, 0(stipple)		/* get stipple bits */
X	move	atemp, addr			/* set up for this line */
X#ifdef TETEXT
X	/* Terminal emulator fonts are expanded and have many 0 rows */
X	beqz	bits, NextLine			/* skip out early on 0 */
X#endif
X	addu	addr, addr, stride		/* step for the loop */
X	BitsR	stemp, bits, shift		/* get first bits */
X	and	stemp, stemp, CASE_MASK		/* compute first branch */
X	addu	stemp, stemp, sbase		/*  ... */
X	j	stemp				/*  ... */
X	BitsL	bits, bits, lshift		/* set remaining bits */
X
XForEachBits:
X	addu	atemp, atemp, 16
XForEachBits1:
X	FourBits(stemp, bits)			/* compute jump for */
X	sll	stemp, stemp, CASE_SIZE		/*  next four bits */
X	addu	stemp, stemp, sbase		/*  ... */
X	j	stemp				/*  ... */
X	BitsL	bits, bits, 4			/* step for remaining bits */
XCaseBegin:
X	bnez	bits, ForEachBits1		/* 0 */
X	addu	atemp, atemp, 16
XNextLine:
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X
X	bnez	bits, ForEachBits		/* 1 */
X	sw	value, WO(0)(atemp)
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X					
X	bnez	bits, ForEachBits		/* 2 */
X	sw	value, WO(4)(atemp)
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X					
X	sw	value, WO(0)(atemp)
X	bnez	bits, ForEachBits		/* 3 */
X	sw	value, WO(4)(atemp)
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X					
X	bnez	bits, ForEachBits		/* 4 */
X	sw	value, WO(8)(atemp)
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X					
X	sw	value, WO(0)(atemp)		/* 5 */
X	bnez	bits, ForEachBits
X	sw	value, WO(8)(atemp)
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X					
X	sw	value, WO(4)(atemp)		/* 6 */
X	bnez	bits, ForEachBits
X	sw	value, WO(8)(atemp)
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X					
X	sw	value, WO(0)(atemp)
X	sw	value, WO(4)(atemp)
X	bnez	bits, ForEachBits		/* 7 */
X	sw	value, WO(8)(atemp)
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X					
X	bnez	bits, ForEachBits		/* 8 */
X	sw	value, WO(12)(atemp)
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X					
X	sw	value, WO(0)(atemp)		/* 9 */
X	bnez	bits, ForEachBits
X	sw	value, WO(12)(atemp)
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X					
X	sw	value, WO(4)(atemp)		/* a */
X	bnez	bits, ForEachBits
X	sw	value, WO(12)(atemp)
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X
X	sw	value, WO(0)(atemp)		/* b */
X	sw	value, WO(4)(atemp)
X	bnez	bits, ForEachBits
X	sb	value, WO(12)(atemp)
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X					
X	sw	value, WO(8)(atemp)
X	bnez	bits, ForEachBits		/* c */
X	sw	value, WO(12)(atemp)
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X					
X	sw	value, WO(0)(atemp)		/* d */
X	sw	value, WO(8)(atemp)
X	bnez	bits, ForEachBits
X	sh	value, WO(12)(atemp)
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X
X	sw	value, WO(4)(atemp)
X	sw	value, WO(8)(atemp)
X	bnez	bits, ForEachBits		/* e */
X	sw	value, WO(12)(atemp)
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X					
X	sw	value, WO(0)(atemp)
X	sw	value, WO(4)(atemp)
X	sw	value, WO(8)(atemp)
X	bnez	bits, ForEachBits		/* f */
X	sw	value, WO(12)(atemp)
X 	addu	count, count, -1
X	bnez	count, ForEachLine
X	addu	stipple, stipple, 4
X	j	$31
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X	nop
X					
X	.end	stipplestack32
END_OF_FILE
if test 7440 -ne `wc -c <'server/ddx/cfb32/stipmips.s'`; then
    echo shar: \"'server/ddx/cfb32/stipmips.s'\" unpacked with wrong size!
fi
# end of 'server/ddx/cfb32/stipmips.s'
fi
echo shar: End of archive 20 \(of 29\).
cp /dev/null ark20isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 29 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Molecular Simulations, Inc.             mail: dcmartin@msi.com
796 N. Pastoria Avenue                  uucp: uunet!dcmartin
Sunnyvale, California 94086             at&t: 408/522-9236
