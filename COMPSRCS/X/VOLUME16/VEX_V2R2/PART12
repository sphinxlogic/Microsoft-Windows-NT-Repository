Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: dcc@Athena.MIT.EDU (David Carver)
Newsgroups: comp.sources.x
Subject: v16i063: Video Extension for X (v2r2), Part12/29
Message-ID: <1992Feb6.145620.371@msi.com>
Date: 6 Feb 92 14:56:20 GMT
References: <csx-16i052-vex.v2r2@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1579
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: dcc@Athena.MIT.EDU (David Carver)
Posting-number: Volume 16, Issue 63
Archive-name: vex.v2r2/part12

# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
#		"End of archive 12 (of 29)."
# Contents:  server/ddx/cfb32/Makefile.Z.uu server/ddx/cfb32/cfbsolid.c
#   server/ddx/dec/tx/xfbxorfix.c
# Wrapped by dcmartin@fascet on Thu Feb  6 06:52:46 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'server/ddx/cfb32/Makefile.Z.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/ddx/cfb32/Makefile.Z.uu'\"
else
echo shar: Extracting \"'server/ddx/cfb32/Makefile.Z.uu'\" \(23029 characters\)
sed "s/^X//" >'server/ddx/cfb32/Makefile.Z.uu' <<'END_OF_FILE'
Xbegin 666 Makefile.Z
XM'YV0(T T";.FC)DT;,J .%/&31DY8>B4(0-"3!X0:=H05-@"!)DW(-R\H0-B
XM8AHZ(10$)(%ER!LW<][(H9.F3AL=&#46=#&&A1T0,5S8J $B1XP7,&Z\D$$T
XMQ@T=-6#H< I"SITY((K@@0."A *5(%J('4NVK-FS:-.J77L6[,""!Q,N;/@P
XMXD009N2\:0-"1!*=95S0:0.'C0@08=Q0Y/%W8]PR/L"R= E3)DV;.!OO'%S8
XM)U 7,6;@*'HTZ8L9,(#2@)I#AXS45K%JY>IU!%@H;"*:D=FFQ1PX9<:D.3@&
XM!)PP$-N4D2@'J\:+8A3.68[1#0@Z:!2&@0-';_<T=D'PL-/PHQP?/,V '?/R
XMX)DZ$&F^Q(NPS!P7($!,.5G&-W#AQ!F'7!C*,8?5'&B\40<;%$4'PG0DI6$=
XM=@H]!M8<_+E AD'X@6#$@FQ45888=2!$!E;(*21'<'LII]A=PR'FQD7');?<
XM0RBN",(8:"3&$!DNJ 16$F: D(>"<H PA'$K=O?&&/;%E.1']H4TDD<&2:C=
XMC"#4X48:<=0A71YMB/$&&W.P8*2"(-R!4(@.3006'2!!"((03SQ!Q1142!$$
XM%$,8P4001TS19G;6K4BBB1*>D=-&(*!0QQQUA,$&&Q?=@:A';S0*E@B @7"%
XM3 P>1B%]S9%$DW(I!&D;6&S%*NNLM(YU(7_^!3=<&L6QYX9[\$64QGPU$GAC
XM<]?U2%*<%-&YXUX*1;?;BG-F9UQN=$S;VV^Z!EAL@3B&51(9)SV8X89%.LNC
XMCV5\%1"&$N'454LO27G93>9*I*%!G@4E VE(*84:"*^Y9H,.--!0U559;=65
XMNV'5*O'$$H-5F&Z\Y0H@K\_^FL9[\0UKW;?'8M61220M2(<<:>"1WG4@K>L&
XM0Q!?G"UO\DY6KV4UX:LRRRZ/84:_+LR0 \ PV("4#:I--<-4-RPLF\->@?4&
XM<"'/_& ><TB$;WY@APUV%6RLW'(+,_Q+@PLR0$SQVW"K=:M$&N_::WL?!RO?
XMR ."BRQV$2T$4AAF,%>M0C9K6[>W?9<L+LKY!H8NS#OV.'.[<Y>1,[V5S=0S
XM3O!*SN]/_B(M<&H%RW!PPE(W3-M7/+GPA@X*)$ ""D,,D4)8Q=T>Z*"%[DZ"
XM"CS5SF!86(259 L@D0"$"UVS3!L0M;?QD_/0FSW]5V)WKQ\213#!! @]@)# 
XM"V)(^ *"W'O?/15/0$$^""ZX\$+]]]L?9/=#5"&%%$5P A6^0(0D2&%^]IN.
XM',@CAQ>0@0QX>('0Q)"V]KE/;$$X8/F0LR,VQ$$!^<&3GOCD)T )BE"&Z@$(
XM+RBVW,UO#&-8(0O!%H04(F8.%N3?$YH !0!.P8;L(<R*YH##&8)M"%"07_E>
XMP(8TB$&"W.D*"OA$A"\@$0H$+((1DN"$(DPA!3($00^+T,,G#,&+4QA"$XCP
XMPN*TH A2I*(5DYC%+7;QBV'L'A?Y% 3QS4]"7;,4&_+(0B:PL7P,(J3WF,!%
XM*LROB6Z@ R$9*4!&"N&$1Y@?\Q29'TK"#PI[TF08\,#)13KAD=;Q32G#UH0@
XM+ &.Y0/,*L76!"O,SWJS#!L27PB'''K/3TZPY/P@XH8FBF&%P+3D'JF R13Z
XMDH52:,(P^=("]1BQ3T\P@A'F!X<YZ,4,UG1?$Z;0RB%(X0DV;$$;BFA$$%!!
XM".,K'QW$,,AV9B4*IRQ?&>+@ACS*D8M#8$(5B.!%\JU0CE>L(Q<+JL+NR9&@
XM=F0H"(N A3X%X0M,>$(0JMA,@^:'HA;%:!*$X"<I)$&B[:0""E](AS"< 8=A
XM+"/\%'I'31+!"%5P A+/"3]?+A,*1VA"1U68QV4*@8M##0M?DE*#&A35"7RJ
XM0A)N"KQT\H4&-VCJ4_EDR:2J$P1)2]A6J0!0KRXU8308:RN=8%:PHG6L1 @"
XM,ZNJR;.*-6S+7$(3BB!4NI;OJUC5*B'+J(0B# &;>IK?"]IPDA?@(09'@8-&
XM\/"%!:4UCY_\ D %2M!T)N%VGP0C(8= 4"%4X0A>?0(G<Q<_LCX!J@8E9!\I
XM&="!,E2*F[7M%Z4(4C]I5J><]:+P4)#9W'9VN/\$KF[!Z+W90G2A-KS=;(TK
XMW#A2H8K/O>-P>WO1[%;W=C)] DV_BP+OXG&&OUMI^7Q7VM,V<[BL!6427KM;
XMZ8K/O,Q=9".3>CM/MG:W+2"")Z7H7"U"5[0S-*0ET\F$VU5A"E*P9 &E@-PL
XM3$&D),W@2>N+ NYBN*0;1O BB=#:^<)VO;AK+VJK"M\AE)B^P\WH$/J(4:JB
XM4,0@,*2+FW#4+GHU>2V0 R$)"H4 VKA0L15G$,R9S20P 99=*AO0TC/+:%IQ
XMC?.[731W1[PA+$%^Q&.#=8@G!%>"@'AB(,B99?<L'3T$62Q0P9G]L.8PT*\,
XM&AG#'+X@YY:^U)TK!8P+V/ &1[VE#$^H@R3#F(16OG*\SBRE :OP9 @O"<4N
XM9FL2"B4%W7&RT:XLPI4/*<4N7B&TMP/U*W?7@L^BP-2H1L&D*]WIX:I:U/CU
XM:::WB%HGWS;54J"T%VO] LT$AC,A K:P+9V"8@M:#@NJ$A=JEP#;R3K8M-;=
XM"Z"@%S4$APZ"(4RRK[UL8H=N7T6:=K6M/>MA:_MVY3SG%I^\W8KZ-@F[WO2\
XMA>NVN/G[WV!)WA4D])$[Z(=K7KM3B8X'A<892#*<L]?GQ-CM;X>[,Z0#C6B0
XMEH,7Q" U,&@-#&0PE7_%QG4/@]6_5_ZV@(N*X&\P^!00CF<0A,H.R $//>VS
XM@V2E 2O,HIR#V",3<KG!+A1Q$W:J$FV8LA *<D7"%,BH6$X^.,(CG?#\0+#8
XMQCXVLI.M+!MHP$0GSK+'6B\?UQE+!\="]@62':78R9Z^?K(0H.=,K-J[WO:O
XMPSWLEGV!A,; ACIL*(^F=7(!=9IW1Z(XM(1,O"$!FG8I2G[Q3-93L[$ V<A+
XM=?(Z_20"]W=WG58^U8S/$Q4VW_D9;G2-!E3LI!H8!C*T8982CCV*KYY["K^ 
XM\S%8[6MY?7H4]+[9OG*/(CW9^RRC@/=9-V"S(;EH%AKAM=?5O12/_X+=1)*=
XMWL,"%Y.0?0UN/_J^QX.$3C)++! !]N;O+_J;C0?;SY(*5X"_\[E/ASO<GH5K
XM!754@ 1;QW=N!W9R%W@:87=@LU93\ 3^<T8"2( H%H!1UVP+R$D.6 7:E 3)
XM4SX,"#:6M($=^($@, .SM%;%YX 0V&ED=('P%@10Q8%;A 7YU3TC*(,K*(,/
XM&($O.( I(']"0((U>(/N$TQ34'S<5TS@)S9%A@5_,E7:)X03UFQ/2$A0F$09
XMM5%*.'\OL!UPT +H$@8JTX1@<WT"E%Y(]E?5AU=0I5))Q%^R]H9Q-5<W]DQZ
XMY&A0EFIZR&R")TLS1&1&YGR"Z 1$X(> L2' H1BYE!]2< 1"X'R/* 1^* =G
XM<$RYA(94<&F6=U.?%"A^* 9D4#A7(S1X*!!+H(DKF(K8-V&(N ;>1P?D(F3B
XMM 03A@0G97[G4W?K@P9Q9$Y) $JO.(MHD 8/ 3UH<(KYQFF<"%KQ@WQX<P:*
XM1&+]0U9,8&G.%UH.]"0OH&@(L5J,%$![TFG9^(P2U$0-00=F*#8$U03H1(Z/
XM9XX;T@9OL(YBLV#P*$7::$RKI(G8&(]0T&RQ:(_4]8_Z:([ QTE3)P564 12
XM8)#.&)#K\Q ,M$I58(T025SFZ(WUY#UI9%+"F(\.AI'F-@;2HXZ*1%%!P$/9
XM5HX2609X0""%81^*E&E],E(9J8WXXRMF<TR!:$8Y*8]/4F60&)02:8D^Z3V%
XM>(@B^7PDJ6V)6 :+2 :2UH=-N8S,5DI0>)%2UY3XJ&U80(:KA 5?N7\X26Q8
XMT'Y-<'7-:'QG"99M4 >*!#]/P 1+0'X9^96;)TG-=053=01%,(YMJ9>_%P9W
XMH$AU201D^99F28G$=B9DD);=XWY-@$1EB6*$B06V-P:]U#U"X(GHQ%89Z8_$
XM)HJD. >_$GF@.06BV92DJ6V$9XS?ASZC2">H&4YA\YE&\(E&,)K8YX>QF8YS
XM0)ND" >F2$NL*$"NZ)J_26S!.9MM (LO(8MI0(ONTYN7*46O.7U.U'U-Z(\.
XMV9 /R9P"Y(<*5)%B U(!- 4F9I3-!I,2 1,B8X_Y(7[9>3OJ"57M26S&Y%@2
XM @>*-EBX6"CWV6$5M9[[J6W]>84K)(@'JI^O)4QJAY\/RI[TQ9_=:4Q8 )\N
XM$ 9YE)\6&DPC-3_K!C:WXZ!4@* 1.E(XII1DM)B1B&(HJJ(B*@2[(T4PZH<:
XM"ED=VH@PZGP@:F*6M#LEBJ.$N:-!X:%#]J)!P)42FA^WLY4#J*-.%)9UT*,7
XM)*5(\*1%>J),ZJ0LNJ100)F6.:(3B@)D"@5'6J6;"0=8ZCYIRJ75!J7E]:+O
XM5Z8V>HI$A@5K^:0XNI94*@98$)=OFJ5]:J;F,Z=2M*>'FJ?32$:)^:-G&JEK
XM:B8,@@6%ZCV4BJA=6J=0L*F.VCU[2I?B@Z@'69=W*9C<*:C@YJ%92JIRF@!T
XM.JIY4JJAZJ)C&@17X*?2Y9=$ )BJ6G:":IB9&GZZ&JNSRJ2[&J:<M*=.9JI1
XM^JR.J:!5F@;%.IG22J**ZJ5C*JTM&C9$!@4#.@6\B@+BNFGD^I:K"@?%^%+7
XMZH3CBJR+2D;G2J#,BJM80(D"!JUN.:W-)@0/L0;"B@5B, = XJI9JJ_RRJWY
XMFH1#RCV>%*0K&J-T*K%0A:%/="E.U )LL*%X &YB5DJ>)*ETFJ/\:4P<"WR#
XM%H+Z)4!\6@5;%Z6 >K(;V[&$&K+N,[*D&K,:B:IX2;-BD+(@R[(XV$A0> 4\
XMJZM_&9@ZBK(=2ZPX6TA&FP0\:Y_JRD1.BP76&K5%*T#U:D-2]+5'ZK3L^C'W
XM$;*K1&0+MG]F1&.6!&+\5DIJBY,Q0(ADM&!&R(YWBY/_(J-[2XEY"ZY_.P4S
XM8+=JBI.B%1 LM[@5$Q#&QG0)@1734A$+9W2.8DP0P3+VH29.<@;)D28/8I)I
XM  ?JJ":)01%D$!%V]A@X%!#0%KF;0QD2AQD@8&PN\+J;FW$Q( -U:Q1(@0-+
XM\2\Q<#!I Q6PP3"SD7**R[C,&RL7TE(S 0)O4"3&9B$0)[L\0[O56Q^>40-%
XMT[NEH13#2S D5P,Q !7_<@8F4@9VEKQ5LQ(1E[WX,@44>8S(1C1$X;LP4 -+
XM Q0B)Q6JTSKN>XI*PHDPM$+QY5HGI@ /96 UI78!EJ9A<8A(\"=P%&!]2E:F
XMI4T..<%-0'X?G$;Y@<%XB032%,%<! 47.<%88$L!-@59H%,L#%E2X%2D502F
XMM6+J%1:J!5*09E-34,%%YL&4IL$TV,$D3 4AO"0>7,(GK)@IO,(1[,*'&,-#
XM\!66ED*R.D%G, 8\L2-F( 9RX!U?/$%NHA@Q]\7J!L9B  >1=,9E',;KM ;I
XMHXYQW,8MHQ%NVBMA7,?T!&[%L<83%!=HLL=L#"&_<<=S(+I? L@@(,AAS!#J
XM:,B#_"9R, :.#,D%>R9I0 9#H,B<')F@W$1D< 1J7#ML3!,)D3:?S,=BH,IE
XMD#:F',BH/$&P_ 8/U,JI7!^X7,JGO,5A/ 9Z?,=Z4!>7K,L35,R9.P:8ZLK*
XMC!QC,,N/7,MA3,C0C,S5_";0+,V:+!&76#9W7+!TLB)WC .<61B_S,9_C,UB
XM\,?-K,YE\P3A7#;<3,UB@ -U?,<2\<<X<,=GP ;\[,]LX!W][,H?$]"T;#YL
XM#* (4M!L?,GJ2 =PX- 3! =GD@=NG,GVC .05 8N5LX=_<X3Q-%:(LTCW=%(
XM=,H*/=+3<0;LC ,M+=)A#--E< 8F/=,M/013D,X3),;V<<<=?<=H( =ZP$".
XMW--#!"0&K1$,H<@US=-A7!AY$ ,0S<Y23=68/,M83%9:Z&[STS6CRUC=!#T/
XM0A.2-;I=$Q@XQ"?!J*9%\ 1"H 1?;=9B?1]U0M=HK2]OP,!<[=8095,5?&%L
XMW=56] 0$]15PK01@R\9=S&83-,97X]AA?,8%QV::+,F)'#/9?"D0;=GV'!.D
XM_,F:O<FDC*FC#=J=;,H@T<WUP<J2_<JM+0.J/<W #-L)T<NBO<NW_4"SK<F$
XMG-F'O!S /4&+S#*-[-FUG=%P/-IS7,=VO=!YO!W(S<;"+-VC_<S'_-K8S<S:
XM;<S1/-V5?"G7_-K6?,F];<_>_,>O+<XR$1BC;<[<P0;@/=/Y/-K[7#;]/-K_
XM'-#Z/=!7D]]L?-#X[=DK'<80W343_=H6C2D93>"U3=,NO=/O'=.O#>&SS=(U
XMG=N:3-(.\='O'=(5WM$7/M,H#07SW<Y#]-I!/=I#7=0/ 6ZC[=,&^]H9X5+N
XM'=QGX.#J?!+J'>-ED]L]73:F#<]T(,\^3@?GG=R3@@8 7M&8@M5T .11_>00
XM/=NW,]ANG=@X5I":E 3XT6KXTP9A'!9>;C^,1>;X@S^#5W@;0N:H5UN=56O3
XM##:R*C:M=CO;*7AN0'B&URXBV$AK6SYI;C_D$D$:&[0,TC(K2S_Z8S_UB+4U
XM6X^+OL9A$^9A#.F(+N9BL.AAG@:8SK&,M;(R9%XVE417T -UB\%%/%5D-("P
XMX\6S@\I:U@3"0SW6ECNLUCLH\ 5.D"=8!%_OU17$$T,)<#PM &3+TSS/$SVC
XMVQ6V;CW.GCW2X^Q?(4@Z("_&-$$]"D+9'L8=BA.WD]AX9&U;1NW6ED&U+D7B
XM#D:RJF4R.*34K@#49TS7GA^'SK':CK8@<.]LD.]N .Y3U&GC/NNU7COR)T W
XM>O!4T%7 DP(3='X"%.Q7+O"B17VT8VV>%&/[Q6)Q1/$0O_"(*^\20@?G:_!N
XMB? ?+_$HL&\:7TDAKP!S$ ;1(0=?X$UC</$!06BU)T5JR&%9+%I@?=;=I"]S
XM #IX/=8X1.ZT;N[]Y02[$_1U3=90G]=JK0"$Q[[_?O$$7]9A3?70\Q53/_3N
XM;?1=+_9??^X INP3G*(I6E%<+_1I_?56'\8MS1/R,D%!3>Q;[SPFSP1.WQ4_
XM$._$_=2SDQ^#G^/$+D7ESO>WKCN\,\&?R@065@1!)8X\+_'#;CP4<>S*$Q;*
XM+NW-SOC0CCW,OCT*H(CE4>\X7CQ6GQ")<>TF7^Z'S_I<[-\)?O.&'\D />!Z
XMCP*+;^M-+SR!S_=S+P;_3-"R<_>ZC_R)O_? CSN.WP)N]*N2+Z[G)#^^@_G%
XM4^R;C^R>'^VE;^ZCO^S:$^^HKQBJ7_O,_Q57__I:[_M+K_[_3?NZS]\Z8&V]
XM?EU:Q.Z*O_2,[SO13]=AN2<#48 =QQL>V\_8>3_F ?[*G^B['N1OVA&_\)8;
XMLAON8V/ES8OUOM_7]_X>"1A^U*/X94#1IOS$P C<?OVOX#6^7#?!_D?\Z %'
XM  NP!SAP$;+? <Q\W ]Y=#X&2/H<X+.#@*#/])T_,I#^-EL%' .MC/VYOJP7
XM^^*?$1QO,40$:C/S9O=RGPF<@AJP":K X ?X!-\3I(*%#P-B0:W6[N#?%H1^
XM+## N$ H  .Q@)VP@3=&V"7 [K<#/U_X>X -4 *&P"%8!*^@>*."4;#],4&E
XMMSLHX#:C?V)@N[6R$KC=MI_SZX#"SPLF0N]& JV@(D2!CW %/CXU>/W:X RL
XM@;A#^Q$[!5@'\V#H^X&F4 A*I=3'""DA[5N"L(\0LK%+& C#V'9K9JUPF3E"
XM,\CTC(\'!('LSQ9Z-].6"Z%9,Y-UO/#_H<%-2 368!O$ S+A\MW .:@#@\SW
XMZX%ZL'H P3NX!U<A^BN&E^P8MCZL%PNW7C(;AHAPN\TR<)@%9:$R]'N1< (*
XMPV6FVM@A&4R!O1#7,4-G& /?8"B<AJ.0#EI#'A@!3Z$V3(7FSQL207OX"LGA
XM^Y-]\_ 0UL)V]N.J()';A1P0X_U"2;C.DI\5[(C-+QD^/WTH_3Q8)VP"GU :
XMQD$$&!"K8;)#B'@0&QK$TZ<0^R!(5((.40L2N218_-R910QR@$PGOL.-* \I
XM(AT@AA]1R&%"D6CR2.+T:P(G$1HF"3@8/.1@2^1\ ]$.^L"#*!-5X52RB4HQ
XM$,+"A^@$C:(X!(KR[ ("18SH_YX?/.R"1?&/&;D2*!>78D8$@&GP_9S$:$@5
XMZPL.)(59$2:BPJZ8$+\B78QG#=']Z42TB C_V#I,BD'1';I%HA@"@6(]A(SW
XM,!/B168(%5]@:NB+PN,O"L272!AC8D'TBJP0,R;&06@.^Q@]0X2HS9/]1+H7
XMRMCB&7R+'U 2QL9*>,A"61(L@W=Q&99$3O@"8V!*!(U64?.YQ&MX&L7?-MR*
XM--$P6L'=N!K+(2\D;KX1-H8R7#@=:^,&;(N0$"Y61MI8VCQB;RR/(3$X.L46
XMV ECH%14B561)2I'K$@:FZ-I#(*%,36>QTYV%L?B8B2/_%$[DK+'N!^5FE"<
XMC/%P/)*VU&8>L>. M(O@41,.QV;8'MT@=4".\C$'TD?FB!_O(S?\"GRP!,9&
XMK38.%:,L=) ,<B+",M>F%L/8BI0!MK$7XD9@6/Q>)&^T9;'M-^)#9;@>,=A)
XM/([_<"6*QN5($#OD8+2/W5 ZZK98)@-XHB"TCA#1MC%))^DB8QN!Q)&K#$9^
XMQ]M(&8.AE)1E#;)*9LG,R!0EY%/LA)\Q2,;'(;DAB^2'3 #CSTB"R)I8 E\D
XMB7R29+$0BDDF>2?W)&Z;C5*RE\7(H9@@O>0MRV5A,E BRO08(3?CA.R,;! E
XM7@U0V/-"(S5LDUHQ&\+)YY@-HZ-^Q))EX$^*Q9QX(OWDHC24O(RW <I#:2 E
XM8WC,C46155[&)=G+R*1Z#( FT3/"1[]X*1=@IC2(FU(PSDDE"2IK977,D[12
XM54Y$#N?1TF()9):#$D&*1R_)+#W<LT1I:1$9WLJ\R ]EX*3<E9;R*OI*81DL
XM2V.2_)0D3DM\M%%I(EOC/<.6B+!:FK@6^2ZU1+1\E33RI*E+$Q<&]66'FY?:
XMLE$*Q^G7+5-B@!DC5F"^/!APF1PUY+@TEUP120Y+=%DO_^6Q_(\5TZ,!S.+'
XM++DC&X.66U)&=DF.">+Z9;IT",<0. K,'DDABR,6>(\8DDT^3(E9+B6FI_R&
XM5K!C7LQ2F3'/XLDL U?R9]Y+C5@H269)2Y3,TE:N3%Q)'-E@/[R0:I)7BLM2
XM"#%KIIR\F0LQ9XJXG>DNDV:\S&D[C5Z"S .)+R4AA--I2!-L0L@SR#(+YK<\
XMF'5I\E4^ 3+!?-4 ^@)!+ GL)H:9(0%C?9235O-#8LT^>#;#)DYLE]<1IV4X
XMP\DQ<QJ@')NNDFA.R\:9X=)FY624;)-IMDRGZ2UI(.2+FU-G;CJ2F-DKJ2;-
XMC).",T3F3,?)+EECXKQGK)-:4CBQF??(IN2$E0H2PB'%CSD[ V;FY)85\CW"
XM3<D7.O<*W22=4S,P5DW4"1U5)^^L:?V15';-WDDY;=KCK)V1DPOB3ME9TV8E
XMAK.>F#,?:LYN:2>&I]PTGJ,S:H;+^3@S 2?S[)3.\WO>2?_(,RT<(KQJ50U0
XMXD],-C2U9[Z<<E,M?YK,-D;E,)F.U(P#DSVZ3"!9*1NFW^20;_)]SL3X"4"A
XMG).DG^YR?T:Y^UE D9S^[*#]TQ<632<70+-:HM2@2O-W[L,*Z0\;:-\<C1!T
XM*P;.YDDGK2 *Y9JO\X9&0=7)K8R,:.FAAB@%7#P@$!P21%_@$<%A#30*9R>]
XM&$AUF%=%QA Q&U31->J'"Q !/4?=C &* $29DN[H.3%HU631VE%$08((> -K
XM( SD 37!DR1$B= :$H+G^0\ (D (B/01 1/S&YJ\I31<EE*P\PU](2"0&!"0
XM_T  07DR*>HPB 4"<U\<6'59I!-/IR6NB-&\*BE:6 \M8C[@+LD5#06)0' ,
XM]<%D< HK01)0QE? ,Z0K#^ NV%<B7:>542-$8'>(@!$@ E3 5S@TCZ'>\:%0
XM\T-EC1X2HK4#"*" +8I;K-(7Q0A%8@N$A2*!2^L#".@"/8="6 =U4T:/:'88
XM TI4:SB/)[I+7\D4/0BIPHIB42GR2Q'#I>@Y90!-* 1JRB/,J)D8"=$##"W1
XM;9H7]L(GA0OUP06L'V[J2T/--ZU.5;1^C%-U$T:+ *MAIJ T(>C3+W$G5 \)
XM^1,]KP>(@-LA0O:$13$A+&:<'H0QF@"JZ1E-HVNT8] $-_!&'44<]1US5!S9
XM40HC D1+,TT(L; % ($8H4RKR3W-$G(!FB:+AO @J$,+P ,<51:^U,"09M8 
XM&$4!M61W#-6;^AA<0%'EJ.ET.I0$]4,28$#/.0@F[]:,&E9#!#[)A.D!$8FK
XM]@\I\%51ZO]0J57H*_B9HO?^5$I5; $&AWAL 1[1!4R>6P4P>""NNH"YB@:Z
XM  CP 8"F4( ]F?<0<-Z^>P,[S[X8$D?J\RC>5ZA'A%4.&%:=QT510(&)*!QF
XMW?4;2\I9R0)80*5TX")L4KP0#6?1MY$)Q@@K  Z2\!%(*0CH$>1!/U2!SV1 
XM#$5':*TBH922BT4#2%K*I8B%1+2=]H7>ZDE/*NY(J76T"G$*AX!'%0!QO10N
XM8 $!5X_Z7.7; N*G8Y6.#A#E^A&8ZRU-J/:!E:ZY/L=6-VMG[:Q@80@V!.%0
XM)1B"0X@/=\$BV)R-, 0AQB MI(<T,!4!+]G8"M^@RQ_WX_>\'4SEB_YKFA.P
XM1V%0 8D"V^@ K/T /K_'2= )%Y",N!BLPPD&5G\@V-_3!A8LHW.P&A;"8@$)
XM6X]6!H5E8Q2V^/57#-M@Q^N&@#O1S4TQ6 #K8LO "U@1ZNLEG-C_6F-?0&.K
XML)'LPGY8-;?GV)R-90^$1@X,LQE+9/G<BV4LBRQZU '^"62-GY#EL46VSW6=
XM1;9C&^R!%;'U"%W<!U_4C;R)GG.R-K9K/! .4657[)"U'SU6TI'9V7-FC>SZ
XM,!LSH\N"V  K8LV E] S*=;">D0LBV8GT@)Y"!U6SVJZQ>+M9BQCZ3KLC9SY
XMH@FR9%7LE?6R&G8@U5DM.Y!6QI0%-TS6RV[8$:L7)FR;O;1[UGYHVAX;B_2L
XM@>T^TVDXL=HYH!'FP!H8LY9VT+;8+/MB"UVGE0.N%L[R6AOK:Z=3H VRNI;&
XM#EL?JV<\+95]LYOVQ1:W,M 01MZQM;+)MLG:6<H6<Z)'L(VV-I;;WH%KZV8)
XMK9V% S'6VX9:<'MC:]I\,K&G-ML*VT([!N"#E/BV/=9)8(W02FY1K;;5LD,$
XM24 )?+ML"UV_E;<.=M226'4+;7ML<?L2WP?>YEK_:N8\'91UMJ#VPS[:4#=I
XMY9BM=6XG=J3ELRH+V=P4Q4VUH_;;?MD!FVC7[<I-L"3VVI9<A/MR.:R'S;!\
XM=L N7'B+8DDN&3NY__;%HEL\L&0;[K+%L2*#X!;:'UO\9B[0G;=V%LGR!NFV
XM;GLLE&VVT(;*-MV?RV*5;:&]NBHWQ [8,&L0<.UCX[I<A\XZ7%F$+I2NG96S
XM:=?,KEWCEN-\;F1[N@FWS_[9,6MT"^UY0K0WU\Q=.DTG<]%NIX.T7:.]A5PY
XM1G796',["69WLL&<<8MW:RZ![;MV]N&./'5;_,0MPG6X)HG:0MR,:VZU[-65
XMLEK7C$W>S[MLP:[+%;L)ENR:@<@K!CQOX2NS#63MKEDSX':U+-S%O>R6V>79
XM*FM[N^ZKU;M[CN^6WA>+='4L\5V]>#??QMC>^V*9KNI%8Y37^$)=+2MUE6SC
XM7;[A=O)RWNM;V:+OLO6\57?9#ET]-GXE+_9EO86V^<($G@M^)8B]E0G7MOAB
XM7BVK;U]<'J"^-C;@PH>!^WS?K_DMM ;W]>9<F%MJ2RRP[;B;K@"77^T;?.N7
XMD@V\C/:)$%Y':W&=2.*5M(Z7ZG9>Z-MU-^[/P;B*M@,O7C'P>.V8 GZP+'?!
XM%C_E)B%H+NS]/0#X!8C;]MO&WE@-/L#;=O6FWT*[?K<##Z;!;@#^GMOI.X0S
XM;^BMMI'DVB)A)6QZ?P[6_;0YV/7.8!^<A"OO#<8"LI?O E_=VW:K[!0&PKY7
XM#*O=92M\ZRZTM;Q^-OE*82Y,A9FONZT7]'?7QM\[G(3-,!U&PR^VWC8'_-N$
XM^:]W\+]SN/_\8 K<8P7P)0L,A;C7*KI(;&.M;U3[PQ38\N[<![Q_I:U)&KU'
XM&!-WXB-[)J:NC.VYH]C0,I"6NX45<1<NP8.WT6K<#AQI(7$(/L64]N-"WD2\
XMW#+Q%VZY#XV,5=D6;-=\\0+&P2]XU++B7$S'=C$@3K,6&!AK.TH,8XFN"&;&
XM(/<9M]L<VX=3L25FP;K8CFGC[EMTZ^_I1<'#.!P7XU3L>M_P%P[#UY88>\0Q
XMS(;9+IM-Q;]W#?M=/%MWBY\\]L+'& O$84#K:&-Q!)[%B'><V6)*>XVCVO0%
XMR# XP0+C^OMW+[ 4?LB,6/VFVSSL=9>P-9:Q,Q@CI^)I"X5)KQZVL^<XZX+:
XMD/R1Z["-;<<X-R+_'GALAD4R/=['NS<'YV.Y6X_I[D5NR1!YU YDOCN-4['\
XM_<G#3!O_V%1,CK^OX-7 C98E)^423(L_\$)FO*?X\')<QZN.D;)U,\8RF<#V
XM1!X'SH*RB V[ 7DB8]J ''.KK!\KRV!9&6/@XZMS&S /?LLP+B,OW2O\;.OO
XM-\;++GG+\F63W)&K,)=URV0Y+[OC@$R3XV[NK<<Y&3'/$[B,C]4P3]['/CD9
XM(U^"/)8GLV*NOT>9&A=AD-S3$G-@)LFC-P?O8(E;FCUS8$:_J7@TWV73K(WE
XM+\.MOX+XWDKF'J>7S^TAG@G_EQH[8@+<F7ES*D[ BSDL;^)K"YBUL>:-N)P8
XM-Y=B[XN+HW)K-LX4.1ICX$6[@1$R8ZG%*[C27F?*C(UW,03&9R=!T5XZ,Q &
XMNH9ZJ[*_S>3&Y;.LF6-P#J[(R]@(9K;>K&6[&.HES$&W$GLQ^/PF]C,[ML+_
XM.0M;X6L;GVTP8S989??$WN3,:X]Y+X&^% :Z_N[DQXR9&P5:#LM#F4$7:/EL
XME/EP#A[-(AI#DVB*_(13,S5&OU)010=FV<R1 _3Z^,2;ES7KYQ5]DKGO="['
XM/?K%KN8''*,+66"VS35Z^P;B^TND*6"&#M(VMO\"YQP\G"%QD7[2A5D2NXSZ
XMS(!'@@->P2G:2)]<[BR+M;('5LCAN?&69Q=\I7ET!EXL#X$A"./BA\C<-%U.
XML!]:+M]G[7QMZW1@ALEK.2S39#HMW$CTA-:R:K8,5V8)K8\I=&8FU)/,08/H
XMO4NE^3 /]M.UV413XY2,A:LLIN;/U7<PY^!O_*EC,Q,>R2W:VGKJ0OV:Q6^2
XM9K<P>O!%:FU,HZ,SE+:_@[A)TSU63:M_,[\5SO9!X%II68VE;31RCLD*UR[K
XMZ(+%JT%UFL71T#D'-^7J'($A-98FTP?93(-G"%QTUS3M+=663@/'Z8<0V3PU
XM(TO/9GG YFD1FY\+UKG^S+<:/\]E)?VLY0 H7M;%;?W ZRQ=KT6OJC[0418=
XMT^EW_:<7-)>>R1!Z]O9I@GU[&S6BKM ZV3)S:$?MH<VU<4/7\WG AFA@S8T7
XM]L7>US8:15-C4LVPG;4$^=%.F5]78_:+KTMVB8X) ]@62^<DR[+!M,76U\D6
XM6Z?@A*QXN77*-L$>&V>/Z0Z<H*GQL;[5L9KNN6QO36Z;=7).N0=;P>[I0VN1
XMVZS3-L<&^VF#V81->S&;H7;8TA9B4^,-'7SY<=.>U1D[P6[L$MVQ1_: 5K%7
XM&VF[:ENMLI.V\8O;*KM6GV@F#+?1-JI>$25900=LE7RVBS6]WL;OEF[;Z-Q,
XMB/NVX6:W4OI7OVQA7;CM].$^VBA7Q"YGJ^VW6;2]SM&*^W!/:YOMN-VTSN; 
XM/!L$,V1J+8\O]$#CG^D:3T?M=DW(.IMSYM-NNV@7:=MMLI<RUA[<G7IWPVZ3
XM#:@S]]CEVF&:=SOFLAV9%_6<O<P4>_@*;Y M:C>S\KW5H7EZS^A3[;G]=11V
XMW<J[_L+F^JNWP??P_MOW.G2SV]%MOJDWK)[;E9H;\^#:?;YQ,Y,^T;XZ.&OO
XM3 VS'W$.3L#[.VU'6&7-B8MRN,[ ._L[6^7D?;Y7=WCNR@597%LB<DV: :1L
XMC-W(6&O;9VHLK_MT=E3*HMIM>_#05K"!=U^^U5H815YP 0Z&D??SGM@/.S+3
XMZ0]NLLGVW*W8&EQM4VI/3</9=M(5S7Q;A5?"[AVX7[00GN$DG%9O9/4->C]W
XMM.;A2=QDL^]4/*1'>"<;XMC;4K_J'LNX=?6"7.&Q.7]7ZOY-G(5X8,;<=WJ 
XM>VF&.XV1^!7/V08Y@9_IGGV+'W@S=L'!N%R[<5&&P2\OLF;7\[H"4^UV'1N1
XMHE\.X=[X;:MP0X["$30Z!MB*W((S<N,=>UWX\B;#;':/3W(;;<-[,@[_XQI[
XMAVOR(ZVI375+AN(!TCFGZN]-Q8_X(M_>'_DVQVMH'=&\>"$/S%-<?,-O5,['
XM33:29N++MHM;\5X>QJ\&(@;69'Q82_(S/HESN!JW33RWC;_R,1W'4;<"1],^
XMFW5#\#Q>P;_X903ELMN92VT.CKOW^#>_U?[YD1_R87[.53:G/N'NW&";<TD]
XM:AOSH0[;,ER%MW-.+K'+=F86YQM[GF?JMFW*Q;,%W^>'&S7_:UW^?GDY0H?<
XM2_P^T_)+'<H>.A='V5E9;F-?BOX@!WKBEM;WVZ'/:#&.S"FW2-?&:+QZU^4U
XM'LVM\T&'XU Y6U?<U'V56;":]KAWG"@;N#D-*EU;'U_7&[Q&YLC3C+L3N>[N
XMZ4TR,/ON1F["5S)2Q^+Q_#"+\T']U.<QV$ZS8MMY7W)/+KVK>A]?VZ!94POU
XM+ G50S;WGN6 VT6/]2G9JAMZ03?"R]I&GN:)OL6#.4:_MG)=&U=QCOW1JVQ>
XME^(AO9CO6_WMU7UYL([9_WL2KW6?SL(W-RH^X-U96R]POS[4"Y\#Y];;7.2F
XMYP@.IR<X3]^38/*GSVX9C-0M.ALNZH?\J(-VV:;4!S0D5^U?DK5KX^*=QENX
XMF,7K5M*J0^\8KJ@U=#^_X5U]M3]T.+S#?;CS7>RRW62+[+_MO9VZ<&_KE0V(
XMQ_*XGMM5N1.OY=+ZKE/V,0G=NVU=W\/RF[IS]W$<V,DW24?NIGT/)_/$OJ71
XM.SW7W 3<9FO<:NZ=Y[BD=>^6'2O;<9![GD?N?)?@<EJ/%TM$*=K%>;MFE64]
XMH:-V=!["U_J?!.&"N\$/>##^NUT[.$?8MWV[ATH"CQ/N.59OWKZ=4>_VL/VH
XM)WR"S[NA7 [S]>-NXF$YD%;9"OU[.W@.W\K=.OF.Z!K^P9OLYXS=J3'[GO$4
XM7J,7'%FNLG\Y;M]M05YE"W/1?-Y;//\VZ<=9L3OYQA[?(;!ZCNER?%L#^4IX
XMV;ER3E_!Z)DP<^=Q_=D599)?M.S9/8.S'*\J"_R%'^= /KUGW@6OLM,YX6;S
XMO@S";VI'?N?C? FW\(&ZGKMP/]^P1_R'[^VWNI-WZ.!NYH?[%P;K6;QM$WKE
XM?M9A_"IW[HV^NX];Z<ZRO;BLG.O7G<@O;NT^Z6O\D/_N=M;(XWDYSWW+^ZV.
XMW(3=5.9YP[[>C;:4E_6.GBU7^<?^E!&X-;?ORCS3YW>;KLV_?'_?[/^]LP?X
XM;O[IJ?D32?.NN<I6-\N-XL/YFV_+!IZT![.I+,X=N^=.W]=VVH/ZYA[A8;NX
XMG^U9^\U3]6W_E;<Z3D;T*EO11^]^/$'./0N']$5>K-=[;G_C3WDBS^XTNR&+
XM 7O/E#%Z%2WIB+W*7D(W'^CA.TOWX@N?>//Y3@W)KVW$G^J6W,/?V7P>$;.;
XM-I;W#[O$=WPD^-Y3/$$VZ@+['"ZS$]]CEWJ^E_0J?[PI<7]/Q-5ZS/?XE'ZZ
XM W._2]<AOBL<Q]J=U\/X<G[S2;ZS]_7U?5O7<<QN[(O?Q7_S:KGK=)U&"(%G
XMKL)'APR?DC_S+WWUE]DF/]SO'$"#?7E>]+]^M<?P$?J%,^\R[/2Q?@W_[5R=
XMWH]\LT_<53S*[_-EO[7'[Q_>]KV^BT_9-CK&8_I;^/>'WLYWPJ%^61-^H!_P
XMJ?747L7:?A+Z_:,?V6?Z-:?C79YI=WUC6/(E\G;NP%2?FUM\[Y;KPS)0[]+0
XMW.?3PS]?M"O^Y@>#+-R>7_6-S_:+/JM_L2"?Q%?LOG\(OWIQ3^TI?^3??@&]
XM]UF\\"_\$CVMJVK>#_O?NN%/_N#^]7\WQF^*Y7MV'N217QW"=*0OV;'YTO?R
XM_)WY3W\6'O5-<.@_NP+^"QI]%G[ZM_[\QH(LO_5.?'ANHU.X^C_QEE?V&WK:
XMG\D-(<[7ZAI?&Q:FR7SWWN_'X,%V)Y">9]SU844: >C\)7_DGNOF /9[G1[T
XM![H-@/_?S%;]67GD'/:' :Y_R5[E)_5=?JJ;?L?TA7_^'P@(]7U^74<&M()9
XM?0U@\_?FM7^DUL/W 0Y_@EGK5^'=@)T?VJ>PJ7V8G(46 XY_ .#L)P!*@#)@
XMPV?R76]UGH2G_N& +I^-EKVE@#C@<E?S+7]48.$GZB5T/1\/2/U19]9?O$;T
XM/8';GPAH@BE]F1].AP*2@7U<^=>!N8!57YF7WE!F,^!H1P.V935238.=*8&>
XMWQVXZTES+I(>2 >^>I6>%%C*K7-^G2#HOEUTC5^Y%_R],HK@GT<#KGN0X#>C
XMF 6 65V(!P3&?7A=).C[V7W7'^1WY?EZ>: EF+-59=Y?EX>LK5K+UJ\5O-DR
XMGB"5YZ7E::Q@H=5J)8*F8%!6"]I9LU>M=6NQ=[]6)Y@+FFS%%BL'_.%]@> P
XMR-P5<::>=^?IQ8+-X*;G_/%@<^ B>'1I<8=?JY>K"8-[8-Y&TDUN"5\IV T:
XM:\W<M5?EB8.#H*67^!5P:J!YUA,M<,/>WD;S17I\7T\##_9N@)Z21^K9@V@:
XMNM?417C,V3V(\65X[AZ%QO&U,P*A)E@0AGR?'!_X>P1T_*#B=;MY@)R=&8@*
XM8GXFX#O8#[)_*][\Y<6!9]9=]+<,VGQ]3$)(".I\JMDNIQ%*A";;^':K+7DK
XM(3G3JQES4QK"Y[^Y92:ARI;2G7TU8.K'G%5$65]M%_75=G@@4(3__6*!G"9V
XM#AJ%K9T.R.#]A!N4/XC([8!N&5 8^V5\1F FF.C17AU1H0?#Z7[#%T GRC&%
XM'IWS]0!6A5'ACG?II80;W;+6%;:$0M@TZ!9:A0O@%KB^A70]$5UHWM&$DEM8
XM5^OEA6EAE+>E=7M+H6L4&'Y[%Z"/%_0!@D91_.=WT7FG6](WV2U]@"&7UP[B
XM<9J=F+>>M6?17@A(YJ5_9E$/Z,<YA.,<83@+HH5T'U+H!]J J&%3J,X]A:VA
XM5.@41G617&C8Q^E_7^&A=X]I@H A4H0)_G-O'D1H&)I]C=@A>!(:=+:A6JC\
XM&8-"GC,(%1*'YU=<2 '"=1^A4E06>H0@W388&RIWWZ!?:-+UALS<8&@.LH;@
XM84B8&!9\C2 '6![N>) A?=?]883$WG/H$6E^'Y-_=\!!>^^99^C9@89U45"H
XMTO6!45M1:!C.1=G>:N@3HH4$XC%(\2&"@&&"R-1-A0\B5.@@:GVV7=JW$.)S
XM\!X_)R'J=KGAG04<DH;"H5$T(1J"!-UTV,WUA\IA!!@-WF6(D5XG'1Z'U.&&
XM>!W:A5P<7L@8S82#W1CW'=Z(Q& Y2!IN;@TBJ"<2:H!@H'K((XYD[2&6]^NA
XM@1GAD4@?9H:C('ZXYNF'RQY46/I!;05B@-B 68FBX5#X'[I_<Z$'!<+-AC;:
XM7_8:R8:O(6W()=Z&6.'^EZCMAEOAFMCA984?(H48(CI&I%R)"".>B&=BBL@,
XM,G2G7G4H)L*%-MZ>R"(.BG4AJJ<-ZF: 8178'69Q?Z%E%!X:B%Q?HR@DGH=$
XM8K?FTAE%.& '5Q&6:98?L)>F\8F(XI-(WR![]R%GF!]"=I]A-Q?FB88TH)?(
XM$PJ(]TQ]0_XEA5\8D @ECHEI8IE8&[Z*:.*=Y_IQ3+;B0&@A8H(@7IQ890&+
XM<Z*;:+9%;2$BL[@ RH/(H;1X!3*'=9M*N"L2BM&=7.C%68OT(!Z6#2YIVB&Q
XMB+$)=L<<.'@3FHO6( +F(U*(NN*IV"XB?D/B2[@8;HK@XM!'$8: H.((*"IF
XM<]>6M&@JUHJ;71YH_XASL2*NJ.N=A@;C@-,&*HS*V1^X*=XW=$!^D_.]>"3B
XM#_?O)8('8Z8(^(U]_R#'Z#!*?%*=NC?HP8('([*8(1YNN1]6)_)!@ATCB&@ 
XMZHNBX*=8K:&,(Z-DF J:@$_;+LAIQ5J/(,5H,9J&IE;/&&NQ6[=@PU@QTG,^
XMXXO5"[9GOZ"MAP<$@R+CTHC2M0RWX-WW"@:",:,ZJ"("BLYAU3@T@HW2H(E(
XM#8X(.6-8%]Z-BT>6C<@UIHVOWJ.8[T6*;Z/5V".*AS]B80@SPHWJH$@X,+Z*
XM;=;N8S<BC':@EL@PUCY=HU (,29KK&'/I6()CF/CGEC\=6,,(N+(-XYZZ>%K
XM]PCN-Y<CR)@/UG:4(.<X.*J,<&*\!_<M>G*?\0,YBH;X7N"7))*"EN/@^!Z6
XM@/%A,M8TVEBN8.I5_W2.L^*6:#L>C:R6L14X)HZBUNWHG?B"3" Y.#4"C5Z<
XMZ!@YZH18H_"H->J.JB/Q&'RMA49<6]@\KHXN8J&8M^%XCZ/U6!RNC=DAHQ@[
XM/H\AF]QH"-*-U2/OV&/MA$HA>7@^7HI/'/AGGM6'!:/\D^#XASRAK!@_FEJ/
XM(_+S,%**;-RF>/S,/S,?QGBXA68;8P")0$IQ05^%!]L=D/LCR?@Y?HD5X@_H
XM0%:0%Z)N:*$5@<[BRTA!HH\89.NHX.V+D)T!:?L\CV?@9*@*!GK&8^Z(Z8V0
XMHB&VMPH"CZV@\+A!DI )5PQ):T&-R>/E%CT^<3MD>)@U*HC4(PUIW7V-S>%5
XML*PID=QB&L/IQ8B!HP!IV)&//I[;J#I:D>AB3:@NEG'+SP,I&!*03^0*23_V
XM>/8C9B@O7EL"CNQ(&B:,E"(;:0GRD):7_Y@K2HPW8QC31O*0TM<\^/)IC)6C
XM'CE'XG(1Y(,(V^V1DF#41@DBDE[AVE<Z:HB;(.HH1UJ/==_)%PH"7J/@!E;\
XM,))4&4TW*M*".*0MR#QNC>G#(-G'V9 P9"C)"^J0$P0G:33.)K,6\@@,,H^3
XMI/M8< V18A^[9>>1DJ[DM9A+]EA[W29I2D:19:.AN*SUDN$B=IA%EHNMY##9
XM1?:%D.*.*$B*C[<DW@@OZHW(9-]X'OZ-(]<,MN30D5\8'&DX I 5S3?9)2Z.
XM#M^!Z$TV-*ZAL!A(MC'F9+"X($:(9E@\>142A*3C!\D;EI/L9",)W+EAP>%8
XM&-78D]/B%-G-,31,SKCW)S:11QA!2392BU3D.IE0SHB*(KEH/@Z4_21WR!<&
XM9U]DL(=0\I'5)!GIQ7V49R2-:-=ECHPA23D1UHS\HDSG+S*)M:-$.31RD_FC
XM@8/)(#C@9$ F3C9=-Z5$ U(^ABCD ?@('C@^I=ZWYX6,/&5$PT%2A<:B!OG8
XM])0<9#X9L8EX'>(1F%3BE*SCS)@Q&G]B#%3Y4WID"N3UN!QB>D3E4ME$0I3/
XM'\GE59:4%24IEAY>E45E]Q@H3HX\6%GY52Z*A-@S&>MUE4KE76F'U7ICI%K9
XM5]:0>&0FV2^VD-@<7,E!IH'@F+&'/V)Z"PY&$X7QCRT?A-@$2F$738,C3])_
XMGB-FR>!,EO?DL9@5'H21I6;Y]E&5_MSN5]%DEJ"E6 @*)I.>I60Y+_)?A2 7
XM.%;&EJ;EBMA6ZF"N7%3#6LZ60A>.ERB.E+\E+N?J>8,;)6[96GJ'"5]@.8,5
XMEZ?DKH<8$I&KY6<)7+J5&Z#0YSI2A,^E=5D&'I87(>VH*3:6:V ; UW>B@$C
XMO$19+EN[)&>I2_Z*ZJ4%229VELMB?-E4GHX&8>WW,UE+(&15^2P:31W.B%A"
XM:I4+I+ZW7PJ8$)T?&?AACP!FLZ3IF92%EMU6+2&8?60%V!'R8!.F<:D=ZI7I
XMI;I$85Z#@&7]!<#Y2PYF=-DX3I<]7H/)7WJ,&9V_.!L";4;B@4G4!95OFD7H
XM20*,]:6'.1]>AD%D_^AAH7^N8LG$$4Z/OR1["5]J"=#AUS7_%9E*YF'68*:&
XM#QH^.5KJESU38-8R>H@-H9TH4%:9UR%:V6&B3 JEBZ9;?HM"9C2(5F*89:;:
XMV-<Q95JDSH0CIHO,Y;I(8B:9=A;\>$?*CS\3G8FH=8&*X5LY9YZ"6U::"&-J
XMER=DS?AD?I<N)6()'XZ7K=NA.4#&@:"AU[1>[F7SY7OY90)-K%^O2%\VF%?B
XMUB9E.HL'H:1Y6D:2\QX-&"UN35VF07EI=HK8XYBY:FIZ9^:R)FH.E^5CXT9B
XM.HK)I4T(1F9,.*"=N3"JD[<F6\DVGFQ^YL_4SIE@+Z8*Q@$BB=QEL$GY@9<W
XMYO>G^7&:Y^0+6.;)2[!B[J9I6IHYIL6T63*9*!G9MU_R2Z'E#]A!\G]"((F9
XMTGQ\^"5#R.AAFY^@)0E;=IL:$_+'P3&8ZB:YZ6IFC]&=BJEOFHV[I:KG;VJ8
XMNAF'26^NF[0>E"=BWGH9$\))-')]Z%MB.'!^@2\>LBEH*IN.8[XY8[*4*62B
XM&5[6=-5BB;-CDI?WXPIH;4::CM.D:6>UE^!F?_8KIISRY;9I=8F;L%/EQ"9^
XMFOYELF@Z!HPPY[EY!+J6G-GWY!BF>L;A]WC*54]#YYYY6_*;82/2"6L:E!AF
XMSZEFBHNUYK<H=<:-N69'R7/:G'>C2+EUNC3")L"W 3J=0UN@Z4Z&BF$@S8A)
XM+HM79XT);9* (.=-1W*R:4)GM0EINHH4CLKI<E::E>77J6<^64LF0,AV0D^B
XM(6[H2.J3RF+UY!O2B5EF;1<MYIU7)" I.0Z>9\#?V:\ME-FB]NAW/IW>XN9)
XM40Z;,.'W9'G"'>IC@<D^ZDZ3XCA9*8J>86>?.7:RGF7GQ75V^HMIYW9I:,*>
XML)B2J#,NFG)GHXE[9HFB'^79::IKVN;LZ2M^G3A@V"=X5D_#9R6'<QZ>4Z7P
XMR2&FEF%A0*GB,9]YHN1I=%:++0VKN73NF]BG7"E%=I[2Y^=9=2*?(UW6&6?N
XMFO;3U6A-$H5Z8_NI'-:+^F"Q67-:3['G"39[#IH&G!C8;"I.^&?NR?V%BC E
XMHPG!A9_HY=WY=:)->F>HQG<:F0NHA!-S&I^;IM I@=Z7J&40&(%:F>TF6 A0
XMRHS7IP6:?9J%)N(&ND1BGC9:,"F"BI_%Y/894:Z@D2?5N4Q>E/<G ZI1YHBZ
XM9K!7.*6>#V?4N3BUGNCAZPF VJ#U7;+9==2>A>;:B71>H!UGEN="\HS3)@P*
XM? *9S%F*TX"^9.D>:4@)RCC3IP8ZMG6@+J-JV<=8H06@W==_NJ G(AE:4&Z,
XM06B1V!.IH1*DS'G:T9BGVQOZT^2?!6CON<V9G%76BC-D(I$M9ZAV;?FAFB,%
XMRF[9?_2$O71SBI:@YLK(;LE9Q0\A^ALVG@-F"!K&$*)3)^4X>4:BBJB?*&:2
XMC3P8)GI60IW+FBCZ1\J@;"8S>8EVH@:GUMF'LJ(+Y_N)0<:+B:A# (2RF(,H
XM+!HJ&J%;V1EJ>RJA>(\NZG9ZG-$F8^E[KJ*VZ*-9_+0X1DVVR88^E%46,_KB
XMV)MK*&,HC<X$A&3F&(<B@V+ -7I="F:3X,D8QGBC72ADYHC&66 HELGHD:/Q
XM9H_I<+V.FN0$P8YVDG#G)WD"EIRD8;LFXP )5R@XJDB*HRB.?<"/-HLYYSFZ
XM;%V95B52(Y!FE69HOVC6'9T*Z8R3:C:0$>E VH:&E3,G4EF1;IQK9TOIA.Z,
XM,>5&.NRU;EGB)LG4C#V$(_C92IZDG"? Z<75.$U- ODQBI41H$EJXV2:AFA&
XM6AO"I"BIR?A\>J'.FTT:DQ*DU.<'JF5:HND#2VI^=H1LI%(*V&V8>R$.*I3V
XMI-%D<QF+CFH[J5/:@^Z6/!X/QI-FH]DE($JZK:0WZ4K9D3:A2^(3&I+JD5HI
XM?<B'$FHY3C_*<F*E?1KA,X'.DVKBJA:7EIOIZ)N(>.Z<>FDY*DE"BUMFW3.1
XMEJ"!Z0GZB3*4^)I=:F:2HK:<8YJ)0IA1EQ9IF-Z@<&95*F?N:GMI8+F51J:=
XM*8I)F?IH]N=E6H1>G$?HLGE)5FUP*:+YD?*>Q5YY:9J^I224!>6,BJ4BG!G6
XM026=@&?(."S6I@(47YJ!FJ/]7P45G/:71:D4MILRI/+F*<H  J<&%#7J2RJG
XM)=1AR)@.FW:;!L6;1FG"Y62ZK&FG!&=>&94><S/8<OKD6:6WVHAIG$:G)N:!
XM&'%2E^NI=5I_AJ6[*&K:BVZ*X*E96K5YI&EI8@F=!H;&Z!Z:C_Z8.QUH>$/)
XMI9;E\:F;5J?)9^!Y5-:&!ZIP2FKR=L4I <6@<J##Z6!:GEZH[>CD2)U".55@
XM;4F3%G$;*HCZ8.Z6V6D'%:*BA!?F=ZJBAJ?#)JSWH58YI%R(F9XRG!'J9VH!
XKPJ<6JHE*<?YL1)M]:JW$F#TJC:J?EG_N(0$ZV96H1BI.$* ZEGQH\*D  &H!
X 
Xend
END_OF_FILE
if test 23029 -ne `wc -c <'server/ddx/cfb32/Makefile.Z.uu'`; then
    echo shar: \"'server/ddx/cfb32/Makefile.Z.uu'\" unpacked with wrong size!
fi
# end of 'server/ddx/cfb32/Makefile.Z.uu'
fi
if test -f 'server/ddx/cfb32/cfbsolid.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/ddx/cfb32/cfbsolid.c'\"
else
echo shar: Extracting \"'server/ddx/cfb32/cfbsolid.c'\" \(6801 characters\)
sed "s/^X//" >'server/ddx/cfb32/cfbsolid.c' <<'END_OF_FILE'
X/*
X * $XConsortium: cfbsolid.c,v 1.5 91/07/11 21:48:24 keith Exp $
X *
X * Copyright 1990 Massachusetts Institute of Technology
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of M.I.T. not be used in advertising or
X * publicity pertaining to distribution of the software without specific,
X * written prior permission.  M.I.T. makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X *
X * M.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL M.I.T.
X * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
X * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
X * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X *
X * Author:  Keith Packard, MIT X Consortium
X */
X
X
X#include "X.h"
X#include "Xmd.h"
X#include "servermd.h"
X#include "gcstruct.h"
X#include "window.h"
X#include "pixmapstr.h"
X#include "scrnintstr.h"
X#include "windowstr.h"
X
X#include "cfb.h"
X#include "cfbmskbits.h"
X#include "cfbrrop.h"
X
X#if defined(FAST_CONSTANT_OFFSET_MODE) && (RROP != GXcopy)
X# define Expand(left,right,leftAdjust) {\
X    int part = nmiddle & 3; \
X    int widthStep; \
X    widthStep = widthDst - nmiddle - leftAdjust; \
X    nmiddle >>= 2; \
X    pdst = pdstRect; \
X    while (h--) { \
X	left \
X	pdst += part; \
X	switch (part) { \
X	    RROP_UNROLL_CASE3(pdst) \
X	} \
X	m = nmiddle; \
X	while (m) { \
X	    pdst += 4; \
X	    RROP_UNROLL_LOOP4(pdst,-4) \
X	    m--; \
X	} \
X	right \
X	pdst += widthStep; \
X    } \
X}
X#else
X# ifdef RROP_UNROLL
X#  define Expand(left,right,leftAdjust) {\
X    int part = nmiddle & RROP_UNROLL_MASK; \
X    int widthStep; \
X    widthStep = widthDst - nmiddle - leftAdjust; \
X    nmiddle >>= RROP_UNROLL_SHIFT; \
X    pdst = pdstRect; \
X    while (h--) { \
X	left \
X	pdst += part; \
X	switch (part) { \
X	    RROP_UNROLL_CASE(pdst) \
X	} \
X	m = nmiddle; \
X	while (m) { \
X	    pdst += RROP_UNROLL; \
X	    RROP_UNROLL_LOOP(pdst) \
X	    m--; \
X	} \
X	right \
X	pdst += widthStep; \
X    } \
X}
X
X# else
X#  define Expand(left, right, leftAdjust) { \
X    while (h--) { \
X	pdst = pdstRect; \
X	left \
X	m = nmiddle; \
X	while (m--) {\
X	    RROP_SOLID(pdst); \
X	    pdst++; \
X	} \
X	right \
X	pdstRect += widthDst; \
X    } \
X}
X# endif
X#endif
X	
X
Xvoid
XRROP_NAME(cfbFillRectSolid) (pDrawable, pGC, nBox, pBox)
X    DrawablePtr	    pDrawable;
X    GCPtr	    pGC;
X    int		    nBox;
X    BoxPtr	    pBox;
X{
X    register int    m;
X    register unsigned long   *pdst;
X    RROP_DECLARE
X    register unsigned long   leftMask, rightMask;
X    unsigned long   *pdstBase, *pdstRect;
X    int		    nmiddle;
X    int		    h;
X    int		    w;
X    int		    widthDst;
X    cfbPrivGCPtr    devPriv;
X
X    devPriv = ((cfbPrivGCPtr) (pGC->devPrivates[cfbGCPrivateIndex].ptr));
X
X    cfbGetLongWidthAndPointer (pDrawable, widthDst, pdstBase)
X
X    RROP_FETCH_GC(pGC)
X    
X    for (; nBox; nBox--, pBox++)
X    {
X    	pdstRect = pdstBase + pBox->y1 * widthDst;
X    	h = pBox->y2 - pBox->y1;
X	w = pBox->x2 - pBox->x1;
X#if PPW == 4
X	if (w == 1)
X	{
X	    register char    *pdstb = ((char *) pdstRect) + pBox->x1;
X	    int	    incr = widthDst << 2;
X
X	    while (h--)
X	    {
X		RROP_SOLID (pdstb);
X		pdstb += incr;
X	    }
X	}
X	else
X	{
X#endif
X	pdstRect += (pBox->x1 >> PWSH);
X	if ((pBox->x1 & PIM) + w <= PPW)
X	{
X	    maskpartialbits(pBox->x1, w, leftMask);
X	    pdst = pdstRect;
X	    while (h--) {
X		RROP_SOLID_MASK (pdst, leftMask);
X		pdst += widthDst;
X	    }
X	}
X	else
X	{
X	    maskbits (pBox->x1, w, leftMask, rightMask, nmiddle);
X	    if (leftMask)
X	    {
X		if (rightMask)	/* left mask and right mask */
X		{
X		    Expand(RROP_SOLID_MASK (pdst, leftMask); pdst++;,
X			   RROP_SOLID_MASK (pdst, rightMask);, 1)
X		}
X		else	/* left mask and no right mask */
X		{
X		    Expand(RROP_SOLID_MASK (pdst, leftMask); pdst++;,
X			   ;, 1)
X		}
X	    }
X	    else
X	    {
X		if (rightMask)	/* no left mask and right mask */
X		{
X		    Expand(;,
X			   RROP_SOLID_MASK (pdst, rightMask);, 0)
X		}
X		else	/* no left mask and no right mask */
X		{
X		    Expand(;,
X			    ;, 0)
X		}
X	    }
X	}
X#if PPW == 4
X	}
X#endif
X    }
X}
X
Xvoid
XRROP_NAME(cfbSolidSpans) (pDrawable, pGC, nInit, pptInit, pwidthInit, fSorted)
X    DrawablePtr pDrawable;
X    GCPtr	pGC;
X    int		nInit;			/* number of spans to fill */
X    DDXPointPtr pptInit;		/* pointer to list of start points */
X    int		*pwidthInit;		/* pointer to list of n widths */
X    int 	fSorted;
X{
X    unsigned long   *pdstBase;
X    int		    widthDst;
X
X    RROP_DECLARE
X    
X    register unsigned long  *pdst;
X    register int	    nlmiddle;
X    register unsigned long  startmask, endmask;
X    register int	    w;
X    int			    x;
X    
X				/* next three parameters are post-clip */
X    int		    n;		/* number of spans to fill */
X    DDXPointPtr	    ppt;	/* pointer to list of start points */
X    int		    *pwidthFree;/* copies of the pointers to free */
X    DDXPointPtr	    pptFree;
X    int		    *pwidth;
X    cfbPrivGCPtr    devPriv;
X
X    devPriv = (cfbPrivGCPtr)pGC->devPrivates[cfbGCPrivateIndex].ptr;
X    RROP_FETCH_GCPRIV(devPriv)
X    n = nInit * miFindMaxBand(devPriv->pCompositeClip);
X    pwidthFree = (int *)ALLOCATE_LOCAL(n * sizeof(int));
X    pptFree = (DDXPointRec *)ALLOCATE_LOCAL(n * sizeof(DDXPointRec));
X    if(!pptFree || !pwidthFree)
X    {
X	if (pptFree) DEALLOCATE_LOCAL(pptFree);
X	if (pwidthFree) DEALLOCATE_LOCAL(pwidthFree);
X	return;
X    }
X    pwidth = pwidthFree;
X    ppt = pptFree;
X    n = miClipSpans(devPriv->pCompositeClip,
X		     pptInit, pwidthInit, nInit,
X		     ppt, pwidth, fSorted);
X
X    cfbGetLongWidthAndPointer (pDrawable, widthDst, pdstBase)
X
X    while (n--)
X    {
X	x = ppt->x;
X	pdst = pdstBase + (ppt->y * widthDst);
X	++ppt;
X	w = *pwidth++;
X	if (!w)
X	    continue;
X#if PPW == 4
X	if (w <= 4)
X	{
X	    register char   *addrb;
X
X	    addrb = ((char *) pdst) + x;
X	    while (w--)
X	    {
X		RROP_SOLID (addrb);
X		addrb++;
X	    }
X	}
X#else
X	if ((x & PIM) + w <= PPW)
X	{
X	    pdst += x >> PWSH;
X	    maskpartialbits (x, w, startmask);
X	    RROP_SOLID_MASK (pdst, startmask);
X	}
X#endif
X	else
X	{
X	    pdst += x >> PWSH;
X	    maskbits (x, w, startmask, endmask, nlmiddle);
X	    if (startmask)
X	    {
X		RROP_SOLID_MASK (pdst, startmask);
X		++pdst;
X	    }
X	    
X	    RROP_SPAN(pdst,nlmiddle)
X	    if (endmask)
X	    {
X		RROP_SOLID_MASK (pdst, endmask);
X	    }
X	}
X    }
X    DEALLOCATE_LOCAL(pptFree);
X    DEALLOCATE_LOCAL(pwidthFree);
X}
END_OF_FILE
if test 6801 -ne `wc -c <'server/ddx/cfb32/cfbsolid.c'`; then
    echo shar: \"'server/ddx/cfb32/cfbsolid.c'\" unpacked with wrong size!
fi
# end of 'server/ddx/cfb32/cfbsolid.c'
fi
if test -f 'server/ddx/dec/tx/xfbxorfix.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/ddx/dec/tx/xfbxorfix.c'\"
else
echo shar: Extracting \"'server/ddx/dec/tx/xfbxorfix.c'\" \(22127 characters\)
sed "s/^X//" >'server/ddx/dec/tx/xfbxorfix.c' <<'END_OF_FILE'
X/***********************************************************
XCopyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
Xand the Massachusetts Institute of Technology, Cambridge, Massachusetts.
X
X                        All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the names of Digital or MIT not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XDIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XDIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X
X******************************************************************/
X/*
XTitle:		RasterOps (TX) card XOR Fix Module
XAuthor:		Edwin Goei
XCreated:	2 Aug 91
X
XThe TX card has the following hardware behavior:
X    * reading 8-bit frame buffer (fb) pixel gives blue component of 24-bit fb
X    * but writing 8-bit fb pixel writes into all (rgb) components of 24-bit fb
X
XProblem: when window managers do rubber banding in the (8-bit) root
Xwindow, they use IncludeInferiors and GXxor or GXinvert.  This fails when
Xrubber banding lines go thru 24-bit windows, because 24-bit fb pixel
Xvalues are not restored properly when XORed an even number of times.
X
XThis module solves this problem by doing the XOR using 24-bit tfb drawing
Xcode instead of 8-bit cfb drawing code.  This trick does not work for
Xall ops, however, because CopyArea and PutImage have source drawable
Xarguments that are in 8 bit-per-pixel format while the tfb drawing ops assume
X32 bit-per-pixel format.  So these ops are disabled.
X
XThis module does not fix all XOR problems.  Here is a summary of the side
Xeffects:
X    1) window manager rubber banding (8-bit root) works over 24-bit windows
X    2) CopyArea and PutImage into 8-bit root window break under certain
X	conditions (ie. whenever XOR fix is activated) -- this is the tradeoff
X	for getting #1
X    3) XORing into an arbitrary 8-bit window with 24-bit children with
X	IncludeInferiors is not affected by this fix at all
X
XThe XOR fix described above is activated under the following conditions
X    (refer to the code below in case conditions were changed):
X    1) pDrawable is the root window
X    2) pGC subwindow mode is IncludeInferiors
X    3) pGC alu is GXxor or GXinvert
X
XThis code is implemented using screen, func, and op wrappers.  This level of
Xwrappers can be called on top of xfb screen code directly or on top of the
XxfbBankSwitch module so that it will work on all machines including 3max.
X
XDepending on the particular GC, there are 3 basic states it can be in:
X    1) no XorFix GC wrapping for 24-bit GCs
X    2) "cheap" func-only wrapping for normal 8-bit GCs
X    3) func and op wrapping for 8-bit GCs that match activating conditions
X
XNote there are two sets of GC wrappers used in this code: cheap and regular,
Xcorresponding to case 2 and 3 above.  This code is similar in structure to
Xmibstore.c.  See that file for more info.
X
XOther notes:
XI've noticed the following unexpected behavior: writing pixels into the
X24-bit fb in an area where the select plane is set to 8-bit fb mode,
Xcan cause unexpected colors to appear on the display -- colors that are
Xnot in the 8-bit psuedocolor map!  This is because the hardware actually
Xhas a 512 entry DirectColor (decomposed) map and the RGB components of
Xthe first 256 entries are identical, to simulate a psuedocolor map.  The
Xselect plane is used to select either the upper or lower half of the
Xhardware colormap.  Writing into the 8-bit fb duplicates RGB components
Xinto the 24-bit fb.  The Pixel8To32() macro below duplicates RGB components
Xof the pixel value to match this hardware behavior.
X*/
X
X#include "X.h"
X#include "gcstruct.h"
X#include "scrnintstr.h"
X#include "pixmapstr.h"
X#include "windowstr.h"
X#include "tfb.h"
X#include "fontstruct.h"
X
X/* XorFix is activated under the following condition */
X#define ActivateXorFix(pGC, pDraw) \
X    ((pDraw)->type == DRAWABLE_WINDOW \
X	&& ((WindowPtr) (pDraw))->parent == NULL \
X	&& (pGC)->subWindowMode == IncludeInferiors \
X	&& ((pGC)->alu == GXxor || (pGC)->alu == GXinvert))
X
X#define Pixel8To32(pixel)	    \
X{				    \
X    unsigned long tpixel_;          \
X    tpixel_ = pixel & 0xff;	    \
X    tpixel_ |= ((tpixel_) << 8);    \
X    tpixel_ |= ((tpixel_) << 16);   \
X    pixel = tpixel_;		    \
X} /* Pixel8To32 */
X
X
X/* Screen and GC privates for XOR Fix module: */
Xtypedef struct {
X    /* screen func wrappers */
X    Bool	    (*CloseScreen)();
X    Bool	    (*CreateGC)();
X} xfbXFScreenRec, *xfbXFScreenPtr;
X
Xtypedef struct {
X    GCFuncs	*wrapFuncs;	    /* wrapped funcs */
X    GCOps	*wrapOps;	    /* wrapped ops */
X} xfbXFGCRec, *xfbXFGCPtr;
X
X
X/* Screen stuff */
Xstatic int  xfbXFScreenIndex;
Xstatic unsigned long xfbXFGeneration = 0;
X
X#define SCREEN_PROLOGUE(pScreen, field)\
X  ((pScreen)->field = \
X   ((xfbXFScreenPtr) \
X    (pScreen)->devPrivates[xfbXFScreenIndex].ptr)->field)
X
X#define SCREEN_EPILOGUE(pScreen, field, wrapper)\
X    ((pScreen)->field = wrapper)
X
X
X/* GC Stuff: */
Xstatic int  xfbXFGCIndex;
X
X/* "cheap" GC funcs: */
X/*
X * every GC in the server is initially wrapped with these
X * "cheap" functions.  This allocates no memory and is used
X * to discover GCs used by window managers for rubber banding
X */
X
Xstatic void xfbXFCheapValidateGC(), xfbXFCheapCopyGC(), xfbXFCheapDestroyGC();
Xstatic void xfbXFCheapChangeGC ();
Xstatic void xfbXFCheapChangeClip(),  xfbXFCheapDestroyClip();
Xstatic void xfbXFCheapCopyClip();
X
Xstatic GCFuncs xfbXFCheapGCFuncs = {
X    xfbXFCheapValidateGC,
X    xfbXFCheapChangeGC,
X    xfbXFCheapCopyGC,
X    xfbXFCheapDestroyGC,
X    xfbXFCheapChangeClip,
X    xfbXFCheapDestroyClip,
X    xfbXFCheapCopyClip,
X};
X
X#define CHEAP_FUNC_PROLOGUE(pGC) \
X    ((pGC)->funcs = (GCFuncs *) (pGC)->devPrivates[xfbXFGCIndex].ptr)
X
X#define CHEAP_FUNC_EPILOGUE(pGC) \
X    ((pGC)->funcs = &xfbXFCheapGCFuncs)
X
X
X/* Non-cheap GC funcs and ops: */
X
Xstatic void xfbXFValidateGC(),	xfbXFCopyGC(), xfbXFDestroyGC();
Xstatic void xfbXFChangeGC();
Xstatic void xfbXFChangeClip(), xfbXFDestroyClip(), xfbXFCopyClip();
X
Xstatic GCFuncs	xfbXFGCFuncs = {
X    xfbXFValidateGC,
X    xfbXFChangeGC,
X    xfbXFCopyGC,
X    xfbXFDestroyGC,
X    xfbXFChangeClip,
X    xfbXFDestroyClip,
X    xfbXFCopyClip,
X};
X
X#define FUNC_PROLOGUE(pGC, pPriv) \
X    ((pGC)->funcs = pPriv->wrapFuncs),\
X    ((pGC)->ops = pPriv->wrapOps)
X
X#define FUNC_EPILOGUE(pGC, pPriv) \
X    ((pGC)->funcs = &xfbXFGCFuncs),\
X    ((pGC)->ops = &xfbXFGCOps)
X
X
Xstatic void	    xfbXFFillSpans(), xfbXFSetSpans(), xfbXFPutImage();
Xstatic RegionPtr    xfbXFCopyArea(), xfbXFCopyPlane();
Xstatic void	    xfbXFPolyPoint(), xfbXFPolylines(), xfbXFPolySegment();
Xstatic void	    xfbXFPolyRectangle(), xfbXFPolyArc(), xfbXFFillPolygon();
Xstatic void	    xfbXFPolyFillRect(), xfbXFPolyFillArc();
Xstatic int	    xfbXFPolyText8(), xfbXFPolyText16();
Xstatic void	    xfbXFImageText8(), xfbXFImageText16();
Xstatic void	    xfbXFImageGlyphBlt(), xfbXFPolyGlyphBlt();
Xstatic void	    xfbXFPushPixels(), xfbXFLineHelper();
X
Xstatic GCOps xfbXFGCOps = {
X    xfbXFFillSpans,	xfbXFSetSpans,	    xfbXFPutImage,	
X    xfbXFCopyArea,	xfbXFCopyPlane,	    xfbXFPolyPoint,
X    xfbXFPolylines,	xfbXFPolySegment,    xfbXFPolyRectangle,
X    xfbXFPolyArc,	xfbXFFillPolygon,    xfbXFPolyFillRect,
X    xfbXFPolyFillArc,	xfbXFPolyText8,	    xfbXFPolyText16,
X    xfbXFImageText8,	xfbXFImageText16,    xfbXFImageGlyphBlt,
X    xfbXFPolyGlyphBlt,	xfbXFPushPixels,    xfbXFLineHelper,
X};
X
X#define OP_INIT(pGC) \
X    xfbXFGCPtr pPriv = (xfbXFGCPtr) (pGC)->devPrivates[xfbXFGCIndex].ptr; \
X    GCFuncs *oldFuncs = (pGC)->funcs;
X
X#define OP_PROLOGUE(pGC) \
X    (pGC)->ops = pPriv->wrapOps; \
X    (pGC)->funcs = pPriv->wrapFuncs;
X
X#define OP_EPILOGUE(pGC) \
X    pPriv->wrapOps = (pGC)->ops; \
X    (pGC)->ops = &xfbXFGCOps; \
X    (pGC)->funcs = oldFuncs;
X
X
X/* Screen procs: */
X
Xstatic Bool
XxfbXFCloseScreen(i, pScreen)
X    ScreenPtr	pScreen;
X{
X    xfbXFScreenPtr   pScreenPriv;
X
X    pScreenPriv = (xfbXFScreenPtr)
X	pScreen->devPrivates[xfbXFScreenIndex].ptr;
X
X    pScreen->CloseScreen = pScreenPriv->CloseScreen;
X    pScreen->CreateGC = pScreenPriv->CreateGC;
X
X    xfree((pointer) pScreenPriv);
X    return (*pScreen->CloseScreen)(i, pScreen);
X}
X
Xstatic Bool
XxfbXFCreateGC(pGC)
X    GCPtr   pGC;
X{
X    ScreenPtr	pScreen = pGC->pScreen;
X    Bool	ret;
X
X    SCREEN_PROLOGUE(pScreen, CreateGC);
X    
X    if ((ret = (*pScreen->CreateGC)(pGC)) && pGC->depth == 8) {
X	/* wrap only funcs, no ops */
X	pGC->devPrivates[xfbXFGCIndex].ptr = (pointer) pGC->funcs;
X	pGC->funcs = &xfbXFCheapGCFuncs;
X    }
X
X    SCREEN_EPILOGUE(pScreen, CreateGC, xfbXFCreateGC);
X    return (ret);
X}
X
X
X/* "Cheap" GC funcs: */
X
Xstatic void
XxfbXFCheapValidateGC(pGC, changes, pDraw)
X    GCPtr	    pGC;
X    unsigned long   changes;
X    DrawablePtr	    pDraw;
X{
X    xfbXFGCRec	*pPriv;
X
X    /* if we get here, pGC must be a depth 8 cfb GC */
X    if (ActivateXorFix(pGC, pDraw)
X	&& (pPriv = (xfbXFGCRec *) xalloc(sizeof(xfbXFGCRec)))) {
X
X	/* turn this into a tfb gc: */
X	xfbXFCheapDestroyGC(pGC);
X
X	pGC->depth = 24;  /* fake out CreateGC() */
X	/* Call down to CreateGC of next lower level to give us a tfb GC.
X	    We can't do anything about it if CreateGC fails so ignore return.
X	*/
X	(void) (*((xfbXFScreenPtr) pGC->pScreen->
X	    devPrivates[xfbXFScreenIndex].ptr)->CreateGC)(pGC);
X
X	pGC->devPrivates[xfbXFGCIndex].ptr = (pointer) pPriv;
X
X	/* wrap both funcs and ops */
X	pPriv->wrapFuncs = pGC->funcs;
X	pPriv->wrapOps = pGC->ops;
X	pGC->funcs = &xfbXFGCFuncs;
X	pGC->ops = &xfbXFGCOps;
X
X	pGC->depth = 8;  /* depth must be 8 or else get BadMatch error */
X	changes = ~0;
X
X	/* this will call xfbXFValidateGC() */
X	(*pGC->funcs->ValidateGC)(pGC, changes, pDraw);
X    } else {
X	CHEAP_FUNC_PROLOGUE(pGC);
X
X	(*pGC->funcs->ValidateGC)(pGC, changes, pDraw);
X
X	/* rewrap funcs as Validate may have changed them */
X	pGC->devPrivates[xfbXFGCIndex].ptr = (pointer) pGC->funcs;
X
X	CHEAP_FUNC_EPILOGUE(pGC);
X    }
X}
X
Xstatic void
XxfbXFCheapChangeGC (pGC, mask)
X    GCPtr   pGC;
X    unsigned long   mask;
X{
X    CHEAP_FUNC_PROLOGUE(pGC);
X
X    (*pGC->funcs->ChangeGC)(pGC, mask);
X
X    CHEAP_FUNC_EPILOGUE(pGC);
X}
X
Xstatic void
XxfbXFCheapCopyGC (pGCSrc, mask, pGCDst)
X    GCPtr   pGCSrc, pGCDst;
X    unsigned long   mask;
X{
X    CHEAP_FUNC_PROLOGUE(pGCDst);
X
X    (*pGCDst->funcs->CopyGC)(pGCSrc, mask, pGCDst);
X
X    CHEAP_FUNC_EPILOGUE(pGCDst);
X}
X
Xstatic void
XxfbXFCheapDestroyGC (pGC)
X    GCPtr   pGC;
X{
X    CHEAP_FUNC_PROLOGUE(pGC);
X
X    (*pGC->funcs->DestroyGC)(pGC);
X
X    /* leave it unwrapped */
X}
X
Xstatic void
XxfbXFCheapChangeClip (pGC, type, pvalue, nrects)
X    GCPtr   pGC;
X    int		type;
X    pointer	pvalue;
X    int		nrects;
X{
X    CHEAP_FUNC_PROLOGUE(pGC);
X
X    (*pGC->funcs->ChangeClip)(pGC, type, pvalue, nrects);
X
X    CHEAP_FUNC_EPILOGUE(pGC);
X}
X
Xstatic void
XxfbXFCheapCopyClip(pgcDst, pgcSrc)
X    GCPtr pgcDst, pgcSrc;
X{
X    CHEAP_FUNC_PROLOGUE(pgcDst);
X
X    (*pgcDst->funcs->CopyClip)(pgcDst, pgcSrc);
X
X    CHEAP_FUNC_EPILOGUE(pgcDst);
X}
X
Xstatic void
XxfbXFCheapDestroyClip(pGC)
X    GCPtr	pGC;
X{
X    CHEAP_FUNC_PROLOGUE(pGC);
X
X    (*pGC->funcs->DestroyClip)(pGC);
X
X    CHEAP_FUNC_EPILOGUE(pGC);
X}
X
X
X/* Regular (non-cheap) GC Funcs: */
X
Xstatic void
XxfbXFValidateGC(pGC, changes, pDraw)
X    GCPtr   	  pGC;
X    unsigned long changes;
X    DrawablePtr   pDraw;
X{
X    xfbXFGCPtr	pPriv = (xfbXFGCPtr) pGC->devPrivates[xfbXFGCIndex].ptr;
X
X    /* if we get here, pGC must be a tfb GC */
X    if (ActivateXorFix(pGC, pDraw)) {
X	/* duplicate fg, bg, and pm into red green blue components */
X	Pixel8To32(pGC->fgPixel);  /* comment at beginning explains this */
X	Pixel8To32(pGC->bgPixel);
X	Pixel8To32(pGC->planemask);
X
X	FUNC_PROLOGUE(pGC, pPriv);
X	pGC->funcs->ValidateGC(pGC, changes, pDraw);
X	/* rewrap funcs and ops as Validate may have changed them */
X	pPriv->wrapFuncs = pGC->funcs;
X	pPriv->wrapOps = pGC->ops;
X	FUNC_EPILOGUE(pGC, pPriv);
X    } else {
X	/* turn this back into a cfb GC: */
X	xfbXFDestroyGC(pGC);  /* frees XorFix GC private */
X
X	/* Call down to CreateGC of next lower level to give us a cfb GC.
X	    We can't do anything about it if CreateGC fails so ignore return.
X	*/
X	(void) (*((xfbXFScreenPtr) pGC->pScreen->
X	    devPrivates[xfbXFScreenIndex].ptr)->CreateGC)(pGC);
X
X	/* wrap only funcs, no ops */
X	pGC->devPrivates[xfbXFGCIndex].ptr = (pointer) pGC->funcs;
X	pGC->funcs = &xfbXFCheapGCFuncs;
X
X	changes = ~0;
X
X	/* this will call xfbXFCheapValidateGC() */
X	pGC->funcs->ValidateGC(pGC, changes, pDraw);
X    }
X}
X
Xstatic void
XxfbXFChangeGC (pGC, mask)
X    GCPtr   pGC;
X    unsigned long   mask;
X{
X    xfbXFGCPtr	pPriv = (xfbXFGCPtr) (pGC)->devPrivates[xfbXFGCIndex].ptr;
X
X    FUNC_PROLOGUE(pGC, pPriv);
X
X    (*pGC->funcs->ChangeGC)(pGC, mask);
X
X    FUNC_EPILOGUE(pGC, pPriv);
X}
X
Xstatic void
XxfbXFCopyGC (pGCSrc, mask, pGCDst)
X    GCPtr   pGCSrc, pGCDst;
X    unsigned long   mask;
X{
X    xfbXFGCPtr	pPriv = (xfbXFGCPtr) (pGCDst)->devPrivates[xfbXFGCIndex].ptr;
X
X    FUNC_PROLOGUE(pGCDst, pPriv);
X
X    (*pGCDst->funcs->CopyGC)(pGCSrc, mask, pGCDst);
X
X    FUNC_EPILOGUE(pGCDst, pPriv);
X}
X
Xstatic void
XxfbXFDestroyGC (pGC)
X    GCPtr   pGC;
X{
X    xfbXFGCPtr	pPriv = (xfbXFGCPtr) (pGC)->devPrivates[xfbXFGCIndex].ptr;
X
X    FUNC_PROLOGUE(pGC, pPriv);
X
X    (*pGC->funcs->DestroyGC)(pGC);
X
X    xfree(pPriv);
X}
X
Xstatic void
XxfbXFChangeClip(pGC, type, pvalue, nrects)
X    GCPtr	pGC;
X    int		type;
X    pointer	pvalue;
X    int		nrects;
X{
X    xfbXFGCPtr	pPriv = (xfbXFGCPtr) (pGC)->devPrivates[xfbXFGCIndex].ptr;
X
X    FUNC_PROLOGUE(pGC, pPriv);
X
X    (*pGC->funcs->ChangeClip)(pGC, type, pvalue, nrects);
X
X    FUNC_EPILOGUE(pGC, pPriv);
X}
X
Xstatic void
XxfbXFCopyClip(pgcDst, pgcSrc)
X    GCPtr pgcDst, pgcSrc;
X{
X    xfbXFGCPtr	pPriv = (xfbXFGCPtr) (pgcDst)->devPrivates[xfbXFGCIndex].ptr;
X
X    FUNC_PROLOGUE(pgcDst, pPriv);
X
X    (*pgcDst->funcs->CopyClip)(pgcDst, pgcSrc);
X
X    FUNC_EPILOGUE(pgcDst, pPriv);
X}
X
Xstatic void
XxfbXFDestroyClip(pGC)
X    GCPtr	pGC;
X{
X    xfbXFGCPtr	pPriv = (xfbXFGCPtr) (pGC)->devPrivates[xfbXFGCIndex].ptr;
X
X    FUNC_PROLOGUE(pGC, pPriv);
X
X    (*pGC->funcs->DestroyClip)(pGC);
X
X    FUNC_EPILOGUE(pGC, pPriv);
X}
X
X
X/* GC Ops */
X
Xstatic void
XxfbXFFillSpans(pDrawable, pGC, nInit, pptInit, pwidthInit, fSorted)
X    DrawablePtr pDrawable;
X    GCPtr	pGC;
X    int		nInit;			/* number of spans to fill */
X    DDXPointPtr pptInit;		/* pointer to list of start points */
X    int		*pwidthInit;		/* pointer to list of n widths */
X    int 	fSorted;
X{
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    (*pGC->ops->FillSpans)(pDrawable, pGC, nInit, pptInit, pwidthInit, fSorted);
X    OP_EPILOGUE(pGC);
X}
X
Xstatic void
XxfbXFSetSpans(pDrawable, pGC, psrc, ppt, pwidth, nspans, fSorted)
X    DrawablePtr		pDrawable;
X    GCPtr		pGC;
X    int			*psrc;
X    register DDXPointPtr ppt;
X    int			*pwidth;
X    int			nspans;
X    int			fSorted;
X{
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    (*pGC->ops->SetSpans)(pDrawable, pGC, psrc, ppt, pwidth, nspans, fSorted);
X    OP_EPILOGUE(pGC);
X}
X
X/* Ignore PutImage */
Xstatic void
XxfbXFPutImage(pDrawable, pGC, depth, x, y, w, h, leftPad, format, pBits)
X    DrawablePtr	  pDrawable;
X    GCPtr   	  pGC;
X    int		  depth;
X    int	    	  x;
X    int	    	  y;
X    int	    	  w;
X    int	    	  h;
X    int	    	  format;
X    char    	  *pBits;
X{
X    return;
X}
X
X/* Ignore CopyArea */
Xstatic RegionPtr
XxfbXFCopyArea(pSrc, pDst, pGC, srcx, srcy, w, h, dstx, dsty)
X    DrawablePtr	  pSrc;
X    DrawablePtr	  pDst;
X    GCPtr   	  pGC;
X    int	    	  srcx;
X    int	    	  srcy;
X    int	    	  w;
X    int	    	  h;
X    int	    	  dstx;
X    int	    	  dsty;
X{
X    return (NullRegion);
X}
X
Xstatic RegionPtr
XxfbXFCopyPlane(pSrc, pDst, pGC, srcx, srcy, w, h, dstx, dsty, plane)
X    DrawablePtr	  pSrc;
X    DrawablePtr	  pDst;
X    register GC   *pGC;
X    int     	  srcx,
X		  srcy;
X    int     	  w,
X		  h;
X    int     	  dstx,
X		  dsty;
X    unsigned long  plane;
X{
X    RegionPtr prgn;
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    prgn = (*pGC->ops->CopyPlane)(pSrc, pDst, pGC, srcx, srcy, w, h,
X	dstx, dsty, plane);
X    OP_EPILOGUE(pGC);
X    return (prgn);
X}
X
Xstatic void
XxfbXFPolyPoint(pDrawable, pGC, mode, npt, pptInit)
X    DrawablePtr pDrawable;
X    GCPtr	pGC;
X    int		mode;		/* Origin or Previous */
X    int		npt;
X    xPoint 	*pptInit;
X{
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    (*pGC->ops->PolyPoint)(pDrawable, pGC, mode, npt, pptInit);
X    OP_EPILOGUE(pGC);
X}
X
Xstatic void
XxfbXFPolylines(pDrawable, pGC, mode, npt, pptInit)
X    DrawablePtr	  pDrawable;
X    GCPtr   	  pGC;
X    int	    	  mode;
X    int	    	  npt;
X    DDXPointPtr	  pptInit;
X{
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    (*pGC->ops->Polylines)(pDrawable, pGC, mode, npt, pptInit);
X    OP_EPILOGUE(pGC);
X}
X
Xstatic void
XxfbXFPolySegment(pDrawable, pGC, nseg, pSegs)
X    DrawablePtr pDrawable;
X    GCPtr 	pGC;
X    int		nseg;
X    xSegment	*pSegs;
X{
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    (*pGC->ops->PolySegment)(pDrawable, pGC, nseg, pSegs);
X    OP_EPILOGUE(pGC);
X}
X
Xstatic void
XxfbXFPolyRectangle(pDrawable, pGC, nrects, pRects)
X    DrawablePtr	pDrawable;
X    GCPtr	pGC;
X    int		nrects;
X    xRectangle	*pRects;
X{
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    (*pGC->ops->PolyRectangle)(pDrawable, pGC, nrects, pRects);
X    OP_EPILOGUE(pGC);
X}
X
Xstatic void
XxfbXFPolyArc(pDrawable, pGC, narcs, parcs)
X    DrawablePtr	pDrawable;
X    GCPtr	pGC;
X    int		narcs;
X    xArc	*parcs;
X{
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    (*pGC->ops->PolyArc)(pDrawable, pGC, narcs, parcs);
X    OP_EPILOGUE(pGC);
X}
X
Xstatic void
XxfbXFFillPolygon(pDrawable, pGC, shape, mode, count, pPts)
X    DrawablePtr		pDrawable;
X    register GCPtr	pGC;
X    int			shape, mode;
X    register int	count;
X    DDXPointPtr		pPts;
X{
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    (*pGC->ops->FillPolygon)(pDrawable, pGC, shape, mode, count, pPts);
X    OP_EPILOGUE(pGC);
X}
X
Xstatic void
XxfbXFPolyFillRect(pDrawable, pGC, nrectFill, prectInit)
X    DrawablePtr pDrawable;
X    GCPtr	pGC;
X    int		nrectFill; 	/* number of rectangles to fill */
X    xRectangle	*prectInit;  	/* Pointer to first rectangle to fill */
X{
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    (*pGC->ops->PolyFillRect)(pDrawable, pGC, nrectFill, prectInit);
X    OP_EPILOGUE(pGC);
X}
X
Xstatic void
XxfbXFPolyFillArc(pDrawable, pGC, narcs, parcs)
X    DrawablePtr	pDrawable;
X    GCPtr	pGC;
X    int		narcs;
X    xArc	*parcs;
X{
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    (*pGC->ops->PolyFillArc)(pDrawable, pGC, narcs, parcs);
X    OP_EPILOGUE(pGC);
X}
X
Xstatic int
XxfbXFPolyText8(pDrawable, pGC, x, y, count, chars)
X    DrawablePtr pDrawable;
X    GCPtr	pGC;
X    int		x, y;
X    int 	count;
X    char	*chars;
X{
X    int result;
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    result = (*pGC->ops->PolyText8)(pDrawable, pGC, x, y, count, chars);
X    OP_EPILOGUE(pGC);
X    return (result);
X}
X
Xstatic int
XxfbXFPolyText16(pDrawable, pGC, x, y, count, chars)
X    DrawablePtr pDrawable;
X    GCPtr	pGC;
X    int		x, y;
X    int		count;
X    unsigned short *chars;
X{
X    int result;
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    result = (*pGC->ops->PolyText16)(pDrawable, pGC, x, y, count, chars);
X    OP_EPILOGUE(pGC);
X    return (result);
X}
X
Xstatic void
XxfbXFImageText8(pDrawable, pGC, x, y, count, chars)
X    DrawablePtr pDrawable;
X    GCPtr	pGC;
X    int		x, y;
X    int		count;
X    char	*chars;
X{
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    (*pGC->ops->ImageText8)(pDrawable, pGC, x, y, count, chars);
X    OP_EPILOGUE(pGC);
X}
X
Xstatic void
XxfbXFImageText16(pDrawable, pGC, x, y, count, chars)
X    DrawablePtr pDrawable;
X    GCPtr	pGC;
X    int		x, y;
X    int		count;
X    unsigned short *chars;
X{
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    (*pGC->ops->ImageText16)(pDrawable, pGC, x, y, count, chars);
X    OP_EPILOGUE(pGC);
X}
X
Xstatic void
XxfbXFImageGlyphBlt(pDrawable, pGC, x, y, nglyph, ppci, pglyphBase)
X    DrawablePtr pDrawable;
X    GC 		*pGC;
X    int 	x, y;
X    unsigned int nglyph;
X    CharInfoPtr *ppci;		/* array of character info */
X    pointer 	pglyphBase;	/* start of array of glyphs */
X{
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    (*pGC->ops->ImageGlyphBlt)(pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
X    OP_EPILOGUE(pGC);
X}
X
Xstatic void
XxfbXFPolyGlyphBlt(pDrawable, pGC, x, y, nglyph, ppci, pglyphBase)
X    DrawablePtr pDrawable;
X    GCPtr	pGC;
X    int 	x, y;
X    unsigned int nglyph;
X    CharInfoPtr *ppci;		/* array of character info */
X    char 	*pglyphBase;	/* start of array of glyphs */
X{
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    (*pGC->ops->PolyGlyphBlt)(pDrawable, pGC, x, y, nglyph, ppci, pglyphBase);
X    OP_EPILOGUE(pGC);
X}
X
Xstatic void
XxfbXFPushPixels(pGC, pBitMap, pDst, w, h, x, y)
X    GCPtr	pGC;
X    PixmapPtr	pBitMap;
X    DrawablePtr pDst;
X    int		w, h, x, y;
X{
X    OP_INIT(pGC);
X    OP_PROLOGUE(pGC);
X    (*pGC->ops->PushPixels)(pGC, pBitMap, pDst, w, h, x, y);
X    OP_EPILOGUE(pGC);
X}
X
Xstatic void
XxfbXFLineHelper()
X{
X    FatalError("xfbXFLineHelper called\n");
X}
X
X
X/* Init XOR Fix module, public entry point */
X
XBool
XxfbXorFixInit(pScreen)
X    ScreenPtr	pScreen;
X{
X    xfbXFScreenPtr    pScreenPriv;
X
X    if (xfbXFGeneration != serverGeneration) {
X	xfbXFScreenIndex = AllocateScreenPrivateIndex();
X	if (xfbXFScreenIndex < 0)
X	    return (FALSE);
X	xfbXFGCIndex = AllocateGCPrivateIndex();
X	xfbXFGeneration = serverGeneration;
X    }
X    if (!AllocateGCPrivate(pScreen, xfbXFGCIndex, 0))
X	return (FALSE);
X    pScreenPriv = (xfbXFScreenPtr) xalloc(sizeof(xfbXFScreenRec));
X    if (!pScreenPriv)
X	return (FALSE);
X
X    pScreenPriv->CloseScreen = pScreen->CloseScreen;
X    pScreenPriv->CreateGC = pScreen->CreateGC;
X
X    pScreen->CloseScreen = xfbXFCloseScreen;
X    pScreen->CreateGC = xfbXFCreateGC;
X
X    pScreen->devPrivates[xfbXFScreenIndex].ptr = (pointer) pScreenPriv;
X}
END_OF_FILE
if test 22127 -ne `wc -c <'server/ddx/dec/tx/xfbxorfix.c'`; then
    echo shar: \"'server/ddx/dec/tx/xfbxorfix.c'\" unpacked with wrong size!
fi
# end of 'server/ddx/dec/tx/xfbxorfix.c'
fi
echo shar: End of archive 12 \(of 29\).
cp /dev/null ark12isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 29 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Molecular Simulations, Inc.             mail: dcmartin@msi.com
796 N. Pastoria Avenue                  uucp: uunet!dcmartin
Sunnyvale, California 94086             at&t: 408/522-9236
