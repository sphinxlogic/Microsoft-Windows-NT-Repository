Path: uunet!think.com!mips!msi!dcmartin
From: dcc@Athena.MIT.EDU (David Carver)
Newsgroups: comp.sources.x
Subject: v16i052: Video Extension for X (v2r2), Part01/29
Message-ID: <csx-16i052-vex.v2r2@uunet.UU.NET>
Date: 6 Feb 92 14:53:17 GMT
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 2576
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: dcc@Athena.MIT.EDU (David Carver)
Posting-number: Volume 16, Issue 52
Archive-name: vex.v2r2/part01

# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
#		"End of archive 1 (of 29)."
# Contents:  README config extensions extensions/xv
#   extensions/xv/clients extensions/xv/doc
#   extensions/xv/doc/xv-lib-v2.PS.ag extensions/xv/include
#   extensions/xv/lib extensions/xv/man extensions/xv/man/man3
#   extensions/xv/server extensions/xv/server/ddx
#   extensions/xv/server/ddx/allrop extensions/xv/server/ddx/decrop
#   extensions/xv/server/ddx/sunrop extensions/xv/server/xvdisp.c
#   extensions/xv/test install lib lib/X server server/ddx
#   server/ddx/cfb32 server/ddx/dec server/ddx/dec/tx
#   server/ddx/dec/ws server/ddx/mi server/ddx/sun
# Wrapped by dcmartin@fascet on Thu Feb  6 06:52:43 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(5745 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XCopyright 1991 by Digital Equipment Corporation, Maynard, Massachusetts,
Xand the Massachusetts Institute of Technology, Cambridge, Massachusetts.
X
X                        All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the names of Digital or MIT not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XDIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XDIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X
XX Window System is a trademark of Massachusetts Institute of Technology.
XRasterOps is a registered trademark of RasterOps Corporation.
XDECstation is a trademark of Digital Equipment Corporation
XSPARC is a trademark of Sun Microsystems Inc.
X
X			   - - - - - - - -
X
X  Contents:
X   
X    Guide to building the X Video Extension (Xv) into the X Window System
X
X  Description:
X
X    This is the installation kit for the X Video Extension (Xv).  Xv
X    provides a means to control video input and output to displays
X    which have video adaptors: typically the video adaptor allows one
X    or more analog signals to be digitized into an X drawable.
X
X    This release supports the RasterOps display with the Picture In a
X    Picture (PIP) option for both DECstation and SPARCstation platforms.
X
X    Note the kit also contains the core DDX files needed to support
X    RasterOps displays without the PIP option, which includes support
X    32 plane CFB drawing and support for mixed depth/visual drawing.
X       
X    I want to acknowledge the efforts of Ed Goei (Digital's Western
X    Software Labs), in contributing the TX device support.
X              
X  Author: 
X
X    David Carver (Digital Workstation Engineering/Project Athena)
X
X			   - - - - - - - -
X
X
X       The Xv distribution kit contains an Xv extension source tree
X  and a core server tree which contains files that were modified to
X  integrate the Xv extension into an X11R5 source pool.
X
X  This distribution also contains the files necessary to build a Xdec
X  server that supports a DECStation5000/RasterOps and to build a Xsun
X  server that supports a SparcStation/RasterOps.
X
X	ddx/cfb32			/* 24 plane drawing code */
X	ddx/dec/tx			/* display specific code */
X	ddx/dec/ws			/* binding to ws interface */
X	ddx/sun				/* modification for RasterOps */
X
X  It should be noted the 24 plane drawing code is really the cfb
X  drawing code compiled for 24 planes, with a few modifications to
X  allow the mixing of 8 and 24 plan drawing.  In the future, cfb32
X  should be replaced by the normally distributed cfb code.
X
X  The SparcStation/RasterOps display is supported as a Sun CG8
X  display, which allow 24 plane and 1 plane windows to coexist on the
X  screen, much the same way the DECStation 5000/RasterOps display
X  allows 24 plane and 8 plane windows to coexist.  Video in either
X  case can only be written to a 24 plane window.
X
X  Xv Changes
X  ----------
X
X      No changes have been made to the Xv protocol since the alpha
X  release earlier in the summer.  The Xv extension directory has been
X  reconfigured to allow a more conventional build.  A couple bugs have
X  been fixed in the RasterOps bindings and several bugs related to
X  byte swaping were fixed in xvmain.c and xvdisp.c.
X
X  Aside from the additional device support, the biggest change has
X  been to automate the installation of Xv into the X11R5 source pool.
X
X  Xv Installation
X  ---------------
X
X  To install Xv into your X source tree use `make install`.  To
X  restore files modifed by `make install` use `make uninstall`.  Note
X  that `make uninstall` simply restores files from backup files
X  created by `make install`.  If something goes wrong during the
X  installation, I suggest using uninstall to get back to a clean slate
X  before attempting the installation again.
X
X  The installation attempts to remove all modifications made by
X  earlier installations, even those made manually according to the
X  installation instructions distributed with xv2r1.  If your xv2r1
X  installation differs significantly from the one suggested, the
X  installation may fail to clear the earlier installation.
X
X  The installation procedure edits several files in the source tree.
X  It has been tested against a generic X11R5 source tree, but if you
X  have made conflicting edits, you may find that the installation
X  fails, or that the result won't build and run.  I have included a
X  context diff for each file modified.  You may apply the changes
X  manually or use the patch utility.
X
X  The installation only modifies your source pool, it does NOT
X  automatically build the pool.  After the installation is complete
X  you can either start from scratch and `make World` in the top build
X  directory, or to save time you can cheat by performing the following
X  commands in both the .../extensions and .../server build
X  directories:
X
X	make Makefile
X	make Makefiles
X	make includes
X	make depend
X	make
X
X  After testing the results of your build, you may want to clean up a
X  bit by using `make cleanup` in Xv kit directory.
X
X  Also note that the lib/X/XErrorDB is modified and needs to be
X  installed into /usr/lib/X11 before Xlib will interpret Xv errors.
END_OF_FILE
if test 5745 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test ! -d 'config' ; then
    echo shar: Creating directory \"'config'\"
    mkdir 'config'
fi
if test ! -d 'extensions' ; then
    echo shar: Creating directory \"'extensions'\"
    mkdir 'extensions'
fi
if test ! -d 'extensions/xv' ; then
    echo shar: Creating directory \"'extensions/xv'\"
    mkdir 'extensions/xv'
fi
if test ! -d 'extensions/xv/clients' ; then
    echo shar: Creating directory \"'extensions/xv/clients'\"
    mkdir 'extensions/xv/clients'
fi
if test ! -d 'extensions/xv/doc' ; then
    echo shar: Creating directory \"'extensions/xv/doc'\"
    mkdir 'extensions/xv/doc'
fi
if test -f 'extensions/xv/doc/xv-lib-v2.PS.ag' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extensions/xv/doc/xv-lib-v2.PS.ag'\"
else
echo shar: Extracting \"'extensions/xv/doc/xv-lib-v2.PS.ag'\" \(11327 characters\)
sed "s/^X//" >'extensions/xv/doc/xv-lib-v2.PS.ag' <<'END_OF_FILE'
X3200(the)S
X3352(Xv)S
X3504(Server)S
X3794(is)S
X3891(to)S
X3999(accept)S
X4283(requests)S
X4640(from)S
X4864(Xv)S
X5016(clients.)S
X720 H
X2736 V
X1650(If)S
X1746(the)S
X1898(display)S
X2217(option)S
X2503(is)S
X2600(not)S
X2758(speci\256ed,)S
X3168(Xv)S
X3320(uses)S
X3522(the)S
X3674(display)S
X3993(screen)S
X4277(speci\256ed)S
X4662(by)S
X4792(your)S
X720 H
X2856 V
X1650(DISPLAY)S
X2102(environment)S
X2637(variable.)S
X3043(The)S
X3228(display)S
X3547(option)S
X3833(has)S
X3996(the)S
X4148(format)S
X4444(hostname:number.)S
X720 H
X2976 V
X1650(Using)S
X1919(two)S
X2099(colons)S
X2390(\(::\))S
X2542(instead)S
X2855(of)S
X2968(one)S
X3142(\(:\))S
X3266(indicates)S
X3651(that)S
X3831(DECnet)S
X4183(is)S
X4280(to)S
X4388(be)S
X4512(used)S
X4725(for)S
X4871(transport.)S
X720 H
X3144 V
X10 I
X900(port)S
X10 R
X1650(Speci\256es)S
X2041(the)S
X2193(port)S
X2384(whose)S
X2669(adaptor)S
X2998(is)S
X3095(to)S
X3203(be)S
X3327(queried)S
X3656(for)S
X3802(its)S
X3927(list)S
X4080(of)S
X4193(encodings.)S
X720 H
X3312 V
X10 I
X900(p_num_encodings)S
X720 H
X3432 V
X10 R
X1650(A)S
X1752(pointer)S
X2065(to)S
X2173(where)S
X2446(the)S
X2598(number)S
X2933(of)S
X3046(encodings)S
X3481(supported)S
X3905(by)S
X4035(the)S
X4187(adaptor)S
X4516(is)S
X4613(written.)S
X720 H
X3600 V
X10 I
X900(pp_encoding_info)S
X720 H
X3720 V
X10 R
X1650(A)S
X1752(pointer)S
X2065(to)S
X2173(where)S
X2446(the)S
X2598(list)S
X2751(of)S
X2864(returned)S
X3226(encoding)S
X3622(information)S
X4124(is)S
X4221(returned.)S
X4638(XvEncodingInfo)S
X720 H
X3840 V
X1650(has)S
X1813(the)S
X1965(following)S
X2384(structure:)S
X720 H
X4140 V
X10 C
X2140(typedef)S
X2620(struct)S
X3040({)S
X720 H
X4260 V
X2260(XvEncodingID)S
X3040(encoding_id;)S
X720 H
X4380 V
X2260(char)S
X2560(*name;)S
X720 H
X4500 V
X2260(unsigned)S
X2800(long)S
X3100(width;)S
X720 H
X4620 V
X2260(unsigned)S
X2800(long)S
X3100(height;)S
X720 H
X4740 V
X2260(XvRational)S
X2920(rate;)S
X720 H
X4860 V
X2140(})S
X2260(XvEncodingInfo;)S
X720 H
X5208 V
X10 I
X900(encoding_id)S
X10 R
X1650(Speci\256es)S
X2041(the)S
X2193(encoding-id)S
X2700(of)S
X2813(the)S
X2965(encoding.)S
X3416(The)S
X3601(encoding-id)S
X4108(is)S
X4205(used)S
X4418(to)S
X4526(identify)S
X4867(an)S
X4991(encoding)S
X720 H
X5328 V
X1650(when)S
X1896(a)S
X1970(port's)S
X2233(encoding)S
X2629(attribute)S
X2992(is)S
X3089(changed.)S
X720 H
X5496 V
X10 I
X900(name)S
X10 R
X1650(A)S
X1752(pointer)S
X2065(to)S
X2173(a)S
X2247(formatted)S
X2665(string)S
X2923(that)S
X3103(identi\256es)S
X3500(the)S
X3652(encoding.)S
X4103(The)S
X4288(string)S
X4546(has)S
X4709(the)S
X4861(format)S
X720 H
X5616 V
X1650(")S
X10 I
X1691(timing-signaltype)S
X10 R
X2391(".)S
X2517(For)S
X2686(example)S
X3054("ntsc-composite".)S
X720 H
X5784 V
X10 I
X900(width,height)S
X10 R
X1650(The)S
X1835(width)S
X2093(and)S
X2267(height,)S
X2572(in)S
X2680(pixels,)S
X2974(of)S
X3087(the)S
X3239(decoded)S
X3601(video)S
X3853(image.)S
X720 H
X5952 V
X10 I
X900(rate)S
X10 R
X1650(The)S
X1835(\256eld)S
X2043(rate)S
X2222(of)S
X2335(the)S
X2487(decoded)S
X2849(video.)S
X720 H
X6120 V
X900(The)S
X1085(XvRational)S
X1576(structure)S
X1955(is)S
X2052(used)S
X2265(to)S
X2373(specify)S
X2691(a)S
X2765(fractional)S
X3177(number.)S
X3567(It)S
X3658(has)S
X3821(the)S
X3973(following)S
X4392(structure:)S
X720 H
X6420 V
X10 C
X1390(typedef)S
X1870(struct)S
X2290({)S
X720 H
X6540 V
X1510(int)S
X1750(numerator;)S
X720 H
X6660 V
X1510(int)S
X1750(denominator;)S
X720 H
X6780 V
X1390(})S
X1510(XvRational;)S
X720 H
X7080 V
X10 R
X900(The)S
X10 I
X1085(numerator)S
X10 R
X1537(and)S
X10 I
X1711(denominator)S
X10 R
X2252(\256elds)S
X2499(specify)S
X2817(the)S
X2969(appropriate)S
X3453(parts)S
X3677(of)S
X3790(a)S
X3864(fractional)S
X4276(number.)S
X720 H
X7680 V
X720(20)S
X7920 V
XEP
X%%Page: 21 21
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X4152(XvQueryEncodings)S
X5280(\()S
X5360(\))S
X720 H
X1080 V
X9 B
X720(Description)S
X720 H
X1200 V
X10 R
X900(XvQueryEncodings\(3X\))S
X1911(returns)S
X2218(encoding)S
X2614(information)S
X3116(about)S
X3368(an)S
X3492(adaptor.)S
X3876(Each)S
X4105(encoding)S
X4501(is)S
X4598(described)S
X5010(by)S
X5140(the)S
X720 H
X1320 V
X900(XvEncodingInfo)S
X1601(structure)S
X1980(described)S
X2392(above.)S
X2715(The)S
X2900(encodings)S
X3335(are)S
X3486(identi\256ed)S
X3894(by)S
X4024(an)S
X4148(encoding-id,)S
X4680(which)S
X4954(can)S
X5122(be)S
X720 H
X1440 V
X900(used)S
X1113(to)S
X1221(set)S
X1362(or)S
X1475(get)S
X1627(the)S
X1779(encoding)S
X2175(attribute)S
X2538(of)S
X2651(a)S
X2725(port.)S
X720 H
X1608 V
X9 B
X720(Examples)S
X720 H
X1728 V
X10 C
X1150(Example)S
X1630(between)S
X2110(.EX)S
X2350(and)S
X2590(.EE)S
X2830(will)S
X3130(show)S
X3430(in)S
X3610(monospace)S
X720 H
X1956 V
X9 B
X720(Returned)S
X1127(Values)S
X720 H
X2076 V
X10 B
X900([Success])S
X720 H
X2196 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(XvQueryEncodings\(3X\))S
X2798(completed)S
X3244(successfully.)S
X720 H
X2364 V
X10 B
X900([XvBadExtension])S
X720 H
X2484 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(the)S
X1939(Xv)S
X2091(extension)S
X2504(is)S
X2601(unavailable.)S
X720 H
X2652 V
X10 B
X900([XvBadAlloc])S
X720 H
X2772 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(XvQueryEncodings\(3X\))S
X2798(failed)S
X3055(to)S
X3163(allocate)S
X3503(memory)S
X3866(to)S
X3974(process)S
X4303(the)S
X4455(request.)S
X720 H
X2940 V
X9 B
X720(Diagnostics)S
X720 H
X3060 V
X10 B
X900([XvBadPort])S
X720 H
X3180 V
X10 R
X1300(Generated)S
X1739(if)S
X1830(the)S
X1982(requested)S
X2394(port)S
X2585(does)S
X2798(not)S
X2956(exist.)S
X720 H
X3348 V
X9 B
X720(See)S
X892(Also)S
X720 H
X3468 V
X10 R
X900(XvFreeEncodingInfo\(3X\))S
X720 H
X7680 V
X5300(21)S
X7920 V
XEP
X%%Page: 22 22
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X720(XvQueryExtension)S
X1809(\()S
X1869(3X)S
X2036(\))S
X720 H
X1080 V
X9 B
X720(Name)S
X720 H
X1200 V
X10 R
X900(XvQueryExtension)S
X1701(\261)S
X1781(return)S
X2049(version)S
X2373(and)S
X2547(release)S
X2853(of)S
X2966(extension)S
X720 H
X1368 V
X9 B
X720(Syntax)S
X720 H
X1488 V
X10 B
X900(#include)S
X1292(<X11/extensions/Xvlib.h>)S
X720 H
X1728 V
X900(XvQueryExtension\()S
X10 I
X1750(p_version,)S
X2199(p_release,)S
X720 H
X1848 V
X1260(p_request_base,)S
X1942(p_event_base,)S
X2540(p_error_base)S
X10 R
X3084(\))S
X720 H
X2088 V
X10 B
X900(unsigned)S
X1315(int)S
X1462(*p_version,)S
X1984(*p_release;)S
X2496(unsigned)S
X2911(int)S
X3058(*p_request_base,)S
X3824(*p_event_base,)S
X4501(*p_error_base;)S
X720 H
X2256 V
X9 B
X720(Arguments)S
X720 H
X2376 V
X10 I
X900(p_version)S
X10 R
X1650(Pointer)S
X1969(to)S
X2077(where)S
X2350(the)S
X2502(current)S
X2814(version)S
X3138(number)S
X3473(of)S
X3586(the)S
X10 I
X3738(Xv)S
X10 R
X3873(video)S
X4125(extension)S
X4538(is)S
X4635(written.)S
X720 H
X2544 V
X10 I
X900(p_release)S
X10 R
X1650(Pointer)S
X1969(to)S
X2077(where)S
X2350(the)S
X2502(release)S
X2808(number)S
X3143(of)S
X3256(the)S
X10 I
X3408(Xv)S
X10 R
X3543(video)S
X3795(extension)S
X4208(is)S
X4305(written.)S
X720 H
X2712 V
X10 I
X900(p_request_base)S
X10 R
X1650(Pointer)S
X1969(to)S
X2077(where)S
X2350(the)S
X2502(extension)S
X2915(major)S
X3178(request)S
X3496(number)S
X3831(is)S
X3928(returned)S
X720 H
X2880 V
X10 I
X900(p_event_base)S
X10 R
X1650(Pointer)S
X1969(to)S
X2077(where)S
X2350(the)S
X2502(extension)S
X2915(event)S
X3161(base)S
X3368(is)S
X3465(returned)S
X720 H
X3048 V
X10 I
X900(p_error_base)S
X10 R
X1650(Pointer)S
X1969(to)S
X2077(where)S
X2350(the)S
X2502(extension)S
X2915(error)S
X3138(base)S
X3345(is)S
X3442(returned)S
X720 H
X3216 V
X9 B
X720(Description)S
X720 H
X3336 V
X10 R
X900(XvQueryExtension\(3X\))S
X1889(returns)S
X2196(the)S
X2348(version)S
X2672(and)S
X2846(release)S
X3152(numbers)S
X3526(for)S
X3672(the)S
X3824(Xv)S
X3976(video)S
X4228(extension)S
X4641(currently)S
X5031(loaded)S
X720 H
X3456 V
X900(on)S
X1030(the)S
X1182(system.)S
X1545(The)S
X1730(extension)S
X2143(major)S
X2406(request)S
X2724(number,)S
X3084(event)S
X3330(base,)S
X3562(and)S
X3736(error)S
X3959(base)S
X4166(are)S
X4317(also)S
X4508(returned.)S
X720 H
X3624 V
X9 B
X720(Examples)S
X720 H
X3744 V
X10 C
X1150(Example)S
X1630(between)S
X2110(.EX)S
X2350(and)S
X2590(.EE)S
X2830(will)S
X3130(show)S
X3430(in)S
X3610(monospace)S
X720 H
X3972 V
X9 B
X720(Returned)S
X1127(Values)S
X720 H
X4092 V
X10 B
X900([Success])S
X720 H
X4212 V
X10 R
X1300(Returns)S
X1641(True)S
X1859(if)S
X1950(XvQueryExtension\(3X\))S
X2939(completed)S
X3385(successfully.)S
X720 H
X4380 V
X10 B
X900([XvBadExtension])S
X720 H
X4500 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(the)S
X1939(Xv)S
X2091(video)S
X2343(extension)S
X2756(is)S
X2853(not)S
X3011(available)S
X3401(for)S
X3547(the)S
X3699(named)S
X3995(display.)S
X720 H
X4668 V
X10 B
X900([XvBadAlloc])S
X720 H
X4788 V
X10 R
X1300(Returned)S
X1696(if)S
X1787(XvQueryExtension\(3X\))S
X2776(failed)S
X3033(to)S
X3141(allocate)S
X3481(memory)S
X3844(to)S
X3952(process)S
X4281(the)S
X4433(request.)S
X720 H
X7680 V
X720(22)S
X7920 V
XEP
X%%Page: 23 23
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X4031(XvSelectPortNotify)S
X5133(\()S
X5193(3X)S
X5360(\))S
X720 H
X1080 V
X9 B
X720(Name)S
X720 H
X1200 V
X10 R
X900(XvSelectPortNotify)S
X1724(\261)S
X1804(enable)S
X2094(or)S
X2207(disable)S
X2520(XvPortNotify\(3X\))S
X3288(events)S
X720 H
X1368 V
X9 B
X720(Syntax)S
X720 H
X1488 V
X10 B
X900(#include)S
X1292(<X11/extensions/Xvlib.h>)S
X720 H
X1728 V
X900(XvSelectPortNotify\()S
X10 I
X1758(dpy,)S
X1957(port,)S
X2179(ono)S
X2329 H
X	(f)show 10 -.5 mul h (f)show
X10 I
X10 R
X2380(\))S
X720 H
X1968 V
X10 B
X900(Display)S
X10 I
X1253(*dpy)S
X10 R
X1447(;)S
X720 H
X2088 V
X10 B
X900(XvPortID)S
X10 I
X1351(port)S
X10 R
X1518(;)S
X720 H
X2208 V
X10 B
X900(Bool)S
X10 I
X1125(ono)S
X1275 H
X	(f)show 10 -.5 mul h (f)show
X10 I
X10 R
X1326(;)S
X720 H
X2376 V
X9 B
X720(Arguments)S
X720 H
X2496 V
X10 I
X900(dpy)S
X10 R
X1300(Speci\256es)S
X1691(the)S
X1843(display)S
X2162(screen)S
X2446(on)S
X2576(which)S
X2850(the)S
X3002(X)S
X3104(Server)S
X3394(is)S
X3491(to)S
X3599(accept)S
X3883(requests)S
X4240(from)S
X4464(X)S
X4566(clients.)S
X4912(If)S
X5008(the)S
X720 H
X2616 V
X1300(display)S
X1619(option)S
X1905(is)S
X2002(not)S
X2160(speci\256ed,)S
X2570(X)S
X2672(uses)S
X2874(the)S
X3026(display)S
X3345(screen)S
X3629(speci\256ed)S
X4014(by)S
X4144(your)S
X4357(DISPLAY)S
X4809(environment)S
X720 H
X2736 V
X1300(variable.)S
X1706(The)S
X1891(display)S
X2210(option)S
X2496(has)S
X2659(the)S
X2811(format)S
X3107(hostname:number.)S
X3908(Using)S
X4177(two)S
X4357(colons)S
X4648(\(::\))S
X4800(instead)S
X5113(of)S
X5226(one)S
X720 H
X2856 V
X1300(\(:\))S
X1424(indicates)S
X1809(that)S
X1989(DECnet)S
X2341(is)S
X2438(to)S
X2546(be)S
X2670(used)S
X2883(for)S
X3029(transport.)S
X720 H
X3024 V
X10 I
X900(port)S
X10 R
X1300(Speci\256es)S
X1691(the)S
X1843(port)S
X2034(for)S
X2180(which)S
X2454(PortNotify)S
X2912(events)S
X3197(are)S
X3348(to)S
X3456(be)S
X3580(generated)S
X3997(when)S
X4243(its)S
X4368(attributes)S
X4770(are)S
X4921(changed)S
X720 H
X3144 V
X1300(using)S
X1547(XvSetPortAttribute\(3X\).)S
X720 H
X3312 V
X10 I
X900(ono)S
X1050 H
X	(f)show 10 -.5 mul h (f)show
X10 I
X10 R
X1300(Speci\256es)S
X1691(whether)S
X2042(noti\256cation)S
X2528(is)S
X2625(to)S
X2733(be)S
X2857(enabled)S
X3197(or)S
X3310(disabled.)S
X720 H
X3480 V
X9 B
X720(Description)S
X720 H
X3600 V
X10 R
X900(XvSelectPortNotify\(3X\))S
X1912(enables)S
X2241(or)S
X2354(disables)S
X2706(PortNotify)S
X3164(event)S
X3410(delivery)S
X3767(to)S
X3875(the)S
X4027(requesting)S
X4473(client.)S
X720 H
X3720 V
X900(XvPortNotify\(3X\))S
X1668(events)S
X1953(are)S
X2104(generated)S
X2521(when)S
X2767(port)S
X2958(attributes)S
X3360(are)S
X3511(changed)S
X3873(using)S
X4120(XvSetPortAttribute\(3X\).)S
X720 H
X3888 V
X9 B
X720(Examples)S
X720 H
X4008 V
X10 C
X1150(Example)S
X1630(between)S
X2110(.EX)S
X2350(and)S
X2590(.EE)S
X2830(will)S
X3130(show)S
X3430(in)S
X3610(monospace)S
X720 H
X4236 V
X9 B
X720(Returned)S
X1127(Values)S
X720 H
X4356 V
X10 B
X900([Success])S
X720 H
X4476 V
X10 R
X1300(Returns)S
X1641(True)S
X1859(if)S
X1950(XvSelectPortNotify\(3X\))S
X2962(completed)S
X3408(successfully.)S
X720 H
X4644 V
X10 B
X900([XvBadExtension])S
X720 H
X4764 V
X10 R
X1300(Returned)S
X1696(if)S
END_OF_FILE
if test 11327 -ne `wc -c <'extensions/xv/doc/xv-lib-v2.PS.ag'`; then
    echo shar: \"'extensions/xv/doc/xv-lib-v2.PS.ag'\" unpacked with wrong size!
fi
# end of 'extensions/xv/doc/xv-lib-v2.PS.ag'
fi
if test ! -d 'extensions/xv/include' ; then
    echo shar: Creating directory \"'extensions/xv/include'\"
    mkdir 'extensions/xv/include'
fi
if test ! -d 'extensions/xv/lib' ; then
    echo shar: Creating directory \"'extensions/xv/lib'\"
    mkdir 'extensions/xv/lib'
fi
if test ! -d 'extensions/xv/man' ; then
    echo shar: Creating directory \"'extensions/xv/man'\"
    mkdir 'extensions/xv/man'
fi
if test ! -d 'extensions/xv/man/man3' ; then
    echo shar: Creating directory \"'extensions/xv/man/man3'\"
    mkdir 'extensions/xv/man/man3'
fi
if test ! -d 'extensions/xv/server' ; then
    echo shar: Creating directory \"'extensions/xv/server'\"
    mkdir 'extensions/xv/server'
fi
if test ! -d 'extensions/xv/server/ddx' ; then
    echo shar: Creating directory \"'extensions/xv/server/ddx'\"
    mkdir 'extensions/xv/server/ddx'
fi
if test ! -d 'extensions/xv/server/ddx/allrop' ; then
    echo shar: Creating directory \"'extensions/xv/server/ddx/allrop'\"
    mkdir 'extensions/xv/server/ddx/allrop'
fi
if test ! -d 'extensions/xv/server/ddx/decrop' ; then
    echo shar: Creating directory \"'extensions/xv/server/ddx/decrop'\"
    mkdir 'extensions/xv/server/ddx/decrop'
fi
if test ! -d 'extensions/xv/server/ddx/sunrop' ; then
    echo shar: Creating directory \"'extensions/xv/server/ddx/sunrop'\"
    mkdir 'extensions/xv/server/ddx/sunrop'
fi
if test -f 'extensions/xv/server/xvdisp.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extensions/xv/server/xvdisp.c'\"
else
echo shar: Extracting \"'extensions/xv/server/xvdisp.c'\" \(28119 characters\)
sed "s/^X//" >'extensions/xv/server/xvdisp.c' <<'END_OF_FILE'
X/***********************************************************
XCopyright 1991 by Digital Equipment Corporation, Maynard, Massachusetts,
Xand the Massachusetts Institute of Technology, Cambridge, Massachusetts.
X
X                        All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the names of Digital or MIT not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XDIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XDIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X
X******************************************************************/
X/*
X** File: 
X**
X**   xvdisp.c --- Xv server extension dispatch module.
X**
X** Author: 
X**
X**   David Carver (Digital Workstation Engineering/Project Athena)
X**
X** Revisions:
X**
X**   11.06.91 Carver
X**     - changed SetPortControl to SetPortAttribute
X**     - changed GetPortControl to GetPortAttribute
X**     - changed QueryBestSize
X**
X**   15.05.91 Carver
X**     - version 2.0 upgrade
X**
X**   24.01.91 Carver
X**     - version 1.4 upgrade
X**
X*/
X
X#include <stdio.h>
X
X#include "X.h"
X#include "Xproto.h"
X#include "misc.h"
X#include "scrnintstr.h"
X#include "windowstr.h"
X#include "pixmapstr.h"
X#include "gcstruct.h"
X#include "dixstruct.h"
X#include "resource.h"
X#include "opaque.h"
X
X#include "Xv.h"
X#include "Xvproto.h"
X#include "xvdix.h"
X
X/* EXTERNAL */
X
Xextern void (* ReplySwapVector[256]) ();
X
X/* INTERNAL */
X
Xstatic int ProcXvQueryExtension();
Xstatic int ProcXvQueryAdaptors();
Xstatic int ProcXvQueryEncodings();
Xstatic int ProcXvPutVideo();
Xstatic int ProcXvPutStill();
Xstatic int ProcXvGetVideo();
Xstatic int ProcXvGetStill();
Xstatic int ProcXvGrabPort();
Xstatic int ProcXvUngrabPort();
Xstatic int ProcXvSelectVideoNotify();
Xstatic int ProcXvSelectPortNotify();
Xstatic int ProcXvStopVideo();
Xstatic int ProcXvSetPortAttribute();
Xstatic int ProcXvGetPorAttribute();
Xstatic int ProcXvQueryBestSize();
X
Xstatic int SProcXvQueryExtension();
Xstatic int SProcXvQueryAdaptors();
Xstatic int SProcXvQueryEncodings();
Xstatic int SProcXvPutVideo();
Xstatic int SProcXvPutStill();
Xstatic int SProcXvGetVideo();
Xstatic int SProcXvGetStill();
Xstatic int SProcXvGrabPort();
Xstatic int SProcXvUngrabPort();
Xstatic int SProcXvSelectVideoNotify();
Xstatic int SProcXvSelectPortNotify();
Xstatic int SProcXvStopVideo();
Xstatic int SProcXvSetPortAttribute();
Xstatic int SProcXvGetPortAttribute();
Xstatic int SProcXvQueryBestSize();
X
Xstatic int SWriteQueryVideoReply();
Xstatic int SWriteAdaptorInfo();
Xstatic int SWriteEncodingInfo();
Xstatic int SWriteFormat();
Xstatic int SWriteGrabPortReply();
Xstatic int SWriteGetPortAttributeReply();
Xstatic int SWriteQueryBestSizeReply();
X
X#define _WriteQueryAdaptorsReply(_c,_d) \
X  if ((_c)->swapped) SWriteQueryAdaptorsReply(_c, _d); \
X  else WriteToClient(_c, sz_xvQueryAdaptorsReply, _d)
X
X#define _WriteQueryExtensionReply(_c,_d) \
X  if ((_c)->swapped) SWriteQueryExtensionReply(_c, _d); \
X  else WriteToClient(_c, sz_xvQueryExtensionReply, _d)
X
X#define _WriteQueryEncodingsReply(_c,_d) \
X  if ((_c)->swapped) SWriteQueryEncodingsReply(_c, _d); \
X  else WriteToClient(_c, sz_xvQueryEncodingsReply, _d)
X
X#define _WriteAdaptorInfo(_c,_d) \
X  if ((_c)->swapped) SWriteAdaptorInfo(_c, _d); \
X  else WriteToClient(_c, sz_xvAdaptorInfo, _d)
X
X#define _WriteEncodingInfo(_c,_d) \
X  if ((_c)->swapped) SWriteEncodingInfo(_c, _d); \
X  else WriteToClient(_c, sz_xvEncodingInfo, _d)
X
X#define _WriteFormat(_c,_d) \
X  if ((_c)->swapped) SWriteFormat(_c, _d); \
X  else WriteToClient(_c, sz_xvFormat, _d)
X
X#define _WriteGrabPortReply(_c,_d) \
X  if ((_c)->swapped) SWriteGrabPortReply(_c, _d); \
X  else WriteToClient(_c, sz_xvGrabPortReply, _d)
X
X#define _WriteGetPortAttributeReply(_c,_d) \
X  if ((_c)->swapped) SWriteGetPortAttributeReply(_c, _d); \
X  else WriteToClient(_c, sz_xvGetPortAttributeReply, _d)
X
X#define _WriteQueryBestSizeReply(_c,_d) \
X  if ((_c)->swapped) SWriteQueryBestSizeReply(_c, _d); \
X  else WriteToClient(_c, sz_xvQueryBestSizeReply, _d)
X
X#define _AllocatePort(_i,_p) \
X  ((_p)->id != _i) ? (* (_p)->pAdaptor->ddAllocatePort)(_i,_p,&_p) : Success
X
X/*
X** ProcXvDispatch
X**
X**
X**
X*/
X
Xint
XProcXvDispatch(client)
Xregister ClientPtr client;
X{
X  REQUEST(xReq);
X
X  UpdateCurrentTime();
X
X  switch (stuff->data) 
X    {
X    case xv_QueryExtension: return(ProcXvQueryExtension(client));
X    case xv_QueryAdaptors: return(ProcXvQueryAdaptors(client));
X    case xv_QueryEncodings: return(ProcXvQueryEncodings(client));
X    case xv_PutVideo: return(ProcXvPutVideo(client));
X    case xv_PutStill: return(ProcXvPutStill(client));
X    case xv_GetVideo: return(ProcXvGetVideo(client));
X    case xv_GetStill: return(ProcXvGetStill(client));
X    case xv_GrabPort: return(ProcXvGrabPort(client));
X    case xv_UngrabPort: return(ProcXvUngrabPort(client));
X    case xv_SelectVideoNotify: return(ProcXvSelectVideoNotify(client));
X    case xv_SelectPortNotify: return(ProcXvSelectPortNotify(client));
X    case xv_StopVideo: return(ProcXvStopVideo(client));
X    case xv_SetPortAttribute: return(ProcXvSetPortAttribute(client));
X    case xv_GetPortAttribute: return(ProcXvGetPortAttribute(client));
X    case xv_QueryBestSize: return(ProcXvQueryBestSize(client));
X    default:
X      if (stuff->data < xvNumRequests)
X	{
X	  SendErrorToClient(client, XvReqCode, stuff->data, 0, 
X			    BadImplementation);
X	  return(BadImplementation);
X	}
X      else
X	{
X	  SendErrorToClient(client, XvReqCode, stuff->data, 0, BadRequest);
X	  return(BadRequest);
X	}
X    }
X}
X
Xint
XSProcXvDispatch(client)
Xregister ClientPtr client;
X{
X  REQUEST(xReq);
X
X  UpdateCurrentTime();
X
X  switch (stuff->data) 
X    {
X    case xv_QueryExtension: return(SProcXvQueryExtension(client));
X    case xv_QueryAdaptors: return(SProcXvQueryAdaptors(client));
X    case xv_QueryEncodings: return(SProcXvQueryEncodings(client));
X    case xv_PutVideo: return(SProcXvPutVideo(client));
X    case xv_PutStill: return(SProcXvPutStill(client));
X    case xv_GetVideo: return(SProcXvGetVideo(client));
X    case xv_GetStill: return(SProcXvGetStill(client));
X    case xv_GrabPort: return(SProcXvGrabPort(client));
X    case xv_UngrabPort: return(SProcXvUngrabPort(client));
X    case xv_SelectVideoNotify: return(SProcXvSelectVideoNotify(client));
X    case xv_SelectPortNotify: return(SProcXvSelectPortNotify(client));
X    case xv_StopVideo: return(SProcXvStopVideo(client));
X    case xv_SetPortAttribute: return(SProcXvSetPortAttribute(client));
X    case xv_GetPortAttribute: return(SProcXvGetPortAttribute(client));
X    case xv_QueryBestSize: return(SProcXvQueryBestSize(client));
X    default:
X      if (stuff->data < xvNumRequests)
X	{
X	  SendErrorToClient(client, XvReqCode, stuff->data, 0, 
X			    BadImplementation);
X	  return(BadImplementation);
X	}
X      else
X	{
X	  SendErrorToClient(client, XvReqCode, stuff->data, 0, BadRequest);
X	  return(BadRequest);
X	}
X    }
X}
X
Xstatic int
XProcXvQueryExtension(client)
Xregister ClientPtr client;
X
X{
X  xvQueryExtensionReply rep;
X  REQUEST(xvQueryExtensionReq);
X  REQUEST_SIZE_MATCH(xvQueryExtensionReq);
X
X  rep.type = X_Reply;
X  rep.sequenceNumber = client->sequence;
X  rep.length = 0;
X  rep.version = XvVersion;
X  rep.revision = XvRevision;
X
X  _WriteQueryExtensionReply(client, &rep);
X
X  return Success;
X
X}
X
Xstatic int
XProcXvQueryAdaptors(client)
Xregister ClientPtr client;
X
X{
X  xvFormat format;
X  xvEncodingInfo einfo;
X  xvAdaptorInfo ainfo;
X  xvQueryAdaptorsReply rep;
X  int totalSize;
X  int na;
X  XvAdaptorPtr pa;
X  int nf;
X  XvFormatPtr pf;
X  WindowPtr pWin;
X  ScreenPtr pScreen;
X  XvScreenPtr pxvs;
X
X  REQUEST(xvQueryAdaptorsReq);
X  REQUEST_SIZE_MATCH(xvQueryAdaptorsReq);
X
X  if(!(pWin = (WindowPtr)LookupWindow(stuff->window, client) ))
X    {
X      client->errorValue = stuff->window;
X      return (BadWindow);
X    }
X
X  pScreen = pWin->drawable.pScreen;
X  pxvs = (XvScreenPtr)pScreen->devPrivates[XvScreenIndex].ptr;
X
X  if (!pxvs)
X    {
X      rep.type = X_Reply;
X      rep.sequenceNumber = client->sequence;
X      rep.num_adaptors = 0;
X      rep.length = 0;
X
X      _WriteQueryAdaptorsReply(client, &rep);
X
X      return Success;
X    }
X
X  (* pxvs->ddQueryAdaptors)(pScreen, &pxvs->nAdaptors, &pxvs->pAdaptors);
X
X  rep.type = X_Reply;
X  rep.sequenceNumber = client->sequence;
X  rep.num_adaptors = pxvs->nAdaptors;
X
X  /* CALCULATE THE TOTAL SIZE OF THE REPLY IN BYTES */
X
X  totalSize = pxvs->nAdaptors * sz_xvAdaptorInfo;
X
X  /* FOR EACH ADPATOR ADD UP THE BYTES FOR ENCODINGS AND FORMATS */
X
X  na = pxvs->nAdaptors;
X  pa = pxvs->pAdaptors;
X  while (na--)
X    {
X      totalSize += (strlen(pa->name) + 3) & ~3;
X      totalSize += pa->nFormats * sz_xvFormat;
X      pa++;
X    }
X
X  rep.length = totalSize >> 2;
X
X  _WriteQueryAdaptorsReply(client, &rep);
X
X  na = pxvs->nAdaptors;
X  pa = pxvs->pAdaptors;
X  while (na--)
X    {
X
X      ainfo.base_id = pa->base_id;
X      ainfo.num_ports = pa->nPorts;
X      ainfo.type = pa->type;
X      ainfo.name_size = strlen(pa->name);
X      ainfo.num_formats = pa->nFormats;
X
X      _WriteAdaptorInfo(client, &ainfo);
X
X      WriteToClient(client, strlen(pa->name), pa->name);
X
X      nf = pa->nFormats;
X      pf = pa->pFormats;
X      while (nf--)
X	{
X	  format.depth = pf->depth;
X	  format.visual = pf->visual;
X	  _WriteFormat(client, &format);
X	  pf++;
X	}
X
X      pa++;
X
X    }
X
X  return (client->noClientException);
X
X}
X
Xstatic int
XProcXvQueryEncodings(client)
Xregister ClientPtr client;
X
X{
X  xvEncodingInfo einfo;
X  xvQueryEncodingsReply rep;
X  int totalSize;
X  XvPortPtr pPort;
X  int ne;
X  XvEncodingPtr pe;
X  int status;
X
X  REQUEST(xvQueryEncodingsReq);
X  REQUEST_SIZE_MATCH(xvQueryEncodingsReq);
X
X  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
X    {
X      client->errorValue = stuff->port;
X      return (_XvBadPort);
X    }
X
X  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
X    {
X      client->errorValue = stuff->port;
X      return (status);
X    }
X
X  rep.type = X_Reply;
X  rep.sequenceNumber = client->sequence;
X  rep.num_encodings = pPort->pAdaptor->nEncodings;
X
X  /* FOR EACH ENCODING ADD UP THE BYTES FOR ENCODING NAMES */
X
X  ne = pPort->pAdaptor->nEncodings;
X  pe = pPort->pAdaptor->pEncodings;
X  totalSize = ne * sz_xvEncodingInfo;
X  while (ne--)
X    {
X      totalSize += (strlen(pe->name) + 3) & ~3;
X      pe++;
X    }
X
X  rep.length = totalSize >> 2;
X
X  _WriteQueryEncodingsReply(client, &rep);
X
X  ne = pPort->pAdaptor->nEncodings;
X  pe = pPort->pAdaptor->pEncodings;
X  do
X    {
X      einfo.encoding = pe->id;
X      einfo.name_size = strlen(pe->name);
X      einfo.width = pe->width;
X      einfo.height = pe->height;
X      einfo.rate.numerator = pe->rate.numerator;
X      einfo.rate.denominator = pe->rate.denominator;
X      _WriteEncodingInfo(client, &einfo);
X      WriteToClient(client, strlen(pe->name), pe->name);
X      pe++;
X    } while (--ne);
X
X  return (client->noClientException);
X
X}
X
Xstatic int
XProcXvPutVideo(client)
Xregister ClientPtr client;
X
X{
X  register DrawablePtr pDraw;
X  XvPortPtr pPort;
X  register GCPtr pGC;
X  int status;
X
X  REQUEST(xvPutVideoReq);
X  REQUEST_SIZE_MATCH(xvPutVideoReq);
X
X  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
X
X  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
X    {
X      client->errorValue = stuff->port;
X      return (_XvBadPort);
X    }
X
X  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
X    {
X      client->errorValue = stuff->port;
X      return (status);
X    }
X
X  if (!(pPort->pAdaptor->type & XvInputMask))
X    {
X      client->errorValue = stuff->port;
X      return (BadMatch);
X    }
X
X  status = XVCALL(diMatchPort)(pPort, pDraw);
X  if (status != Success)
X    {
X      return status;
X    }
X
X  return XVCALL(diPutVideo)(client, pDraw, pPort, pGC,
X			    stuff->vid_x, stuff->vid_y,
X			    stuff->vid_w, stuff->vid_h,
X			    stuff->drw_x, stuff->drw_y,
X			    stuff->drw_w, stuff->drw_h);
X
X}
X
Xstatic int
XProcXvPutStill(client)
Xregister ClientPtr client;
X
X{
X  register DrawablePtr pDraw;
X  XvPortPtr pPort;
X  register GCPtr pGC;
X  int status;
X
X  REQUEST(xvPutStillReq);
X  REQUEST_SIZE_MATCH(xvPutStillReq);
X
X  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
X
X  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
X    {
X      client->errorValue = stuff->port;
X      return (_XvBadPort);
X    }
X
X  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
X    {
X      client->errorValue = stuff->port;
X      return (status);
X    }
X
X  if (!(pPort->pAdaptor->type & XvInputMask))
X    {
X      client->errorValue = stuff->port;
X      return (BadMatch);
X    }
X
X  status = XVCALL(diMatchPort)(pPort, pDraw);
X  if (status != Success)
X    {
X      return status;
X    }
X
X  return XVCALL(diPutStill)(client, pDraw, pPort, pGC,
X			    stuff->vid_x, stuff->vid_y,
X			    stuff->vid_w, stuff->vid_h,
X			    stuff->drw_x, stuff->drw_y,
X			    stuff->drw_w, stuff->drw_h);
X
X}
X
X
Xstatic int
XProcXvGetVideo(client)
Xregister ClientPtr client;
X
X{
X  register DrawablePtr pDraw;
X  XvPortPtr pPort;
X  register GCPtr pGC;
X  int status;
X
X  REQUEST(xvGetVideoReq);
X  REQUEST_SIZE_MATCH(xvGetVideoReq);
X
X  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
X
X  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
X    {
X      client->errorValue = stuff->port;
X      return (_XvBadPort);
X    }
X
X  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
X    {
X      client->errorValue = stuff->port;
X      return (status);
X    }
X
X  if (!(pPort->pAdaptor->type & XvOutputMask))
X    {
X      client->errorValue = stuff->port;
X      return (BadMatch);
X    }
X
X  status = XVCALL(diMatchPort)(pPort, pDraw);
X  if (status != Success)
X    {
X      return status;
X    }
X
X  return XVCALL(diGetVideo)(client, pDraw, pPort, pGC,
X			    stuff->vid_x, stuff->vid_y,
X			    stuff->vid_w, stuff->vid_h,
X			    stuff->drw_x, stuff->drw_y,
X			    stuff->drw_w, stuff->drw_h);
X
X}
X
X
Xstatic int
XProcXvGetStill(client)
Xregister ClientPtr client;
X
X{
X  register DrawablePtr pDraw;
X  XvPortPtr pPort;
X  register GCPtr pGC;
X  int status;
X
X  REQUEST(xvGetStillReq);
X  REQUEST_SIZE_MATCH(xvGetStillReq);
X
X  VALIDATE_DRAWABLE_AND_GC(stuff->drawable, pDraw, pGC, client);
X
X  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
X    {
X      client->errorValue = stuff->port;
X      return (_XvBadPort);
X    }
X
X  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
X    {
X      client->errorValue = stuff->port;
X      return (status);
X    }
X
X  if (!(pPort->pAdaptor->type & XvOutputMask))
X    {
X      client->errorValue = stuff->port;
X      return (BadMatch);
X    }
X
X  status = XVCALL(diMatchPort)(pPort, pDraw);
X  if (status != Success)
X    {
X      return status;
X    }
X
X  return XVCALL(diGetStill)(client, pDraw, pPort, pGC,
X			    stuff->vid_x, stuff->vid_y,
X			    stuff->vid_w, stuff->vid_h,
X			    stuff->drw_x, stuff->drw_y,
X			    stuff->drw_w, stuff->drw_h);
X
X}
X
Xstatic int
XProcXvSelectVideoNotify(client)
Xregister ClientPtr client;
X
X{
X  register DrawablePtr pDraw;
X  XvPortPtr pPort;
X  REQUEST(xvSelectVideoNotifyReq);
X  REQUEST_SIZE_MATCH(xvSelectVideoNotifyReq);
X
X  if(!(pDraw = (DrawablePtr)LOOKUP_DRAWABLE(stuff->drawable, client) ))
X    {
X      client->errorValue = stuff->drawable;
X      return (BadWindow);
X    }
X
X  return XVCALL(diSelectVideoNotify)(client, pDraw, stuff->onoff);
X
X}
X
Xstatic int
XProcXvSelectPortNotify(client)
Xregister ClientPtr client;
X
X{
X  int status;
X  XvPortPtr pPort;
X  REQUEST(xvSelectPortNotifyReq);
X  REQUEST_SIZE_MATCH(xvSelectPortNotifyReq);
X
X  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
X    {
X      client->errorValue = stuff->port;
X      return (_XvBadPort);
X    }
X
X  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
X    {
X      client->errorValue = stuff->port;
X      return (status);
X    }
X
X  return XVCALL(diSelectPortNotify)(client, pPort, stuff->onoff);
X
X}
X
Xstatic int
XProcXvGrabPort(client)
Xregister ClientPtr client;
X
X{
X  int result, status;
X  XvPortPtr pPort;
X  xvGrabPortReply rep;
X  REQUEST(xvGrabPortReq);
X  REQUEST_SIZE_MATCH(xvGrabPortReq);
X
X  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
X    {
X      client->errorValue = stuff->port;
X      return (_XvBadPort);
X    }
X
X  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
X    {
X      client->errorValue = stuff->port;
X      return (status);
X    }
X
X  status = XVCALL(diGrabPort)(client, pPort, stuff->time, &result);
X
X  if (status != Success)
X    {
X      return status;
X    }
X
X  rep.type = X_Reply;
X  rep.sequenceNumber = client->sequence;
X  rep.length = 0;
X  rep.result = result;
X
X  _WriteGrabPortReply(client, &rep);
X
X  return Success;
X
X}
X
Xstatic int
XProcXvUngrabPort(client)
Xregister ClientPtr client;
X
X{
X  int status;
X  XvPortPtr pPort;
X  REQUEST(xvGrabPortReq);
X  REQUEST_SIZE_MATCH(xvGrabPortReq);
X
X  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
X    {
X      client->errorValue = stuff->port;
X      return (_XvBadPort);
X    }
X
X  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
X    {
X      client->errorValue = stuff->port;
X      return (status);
X    }
X
X  return XVCALL(diUngrabPort)(client, pPort, stuff->time);
X
X}
X
X
Xstatic int
XProcXvStopVideo(client)
Xregister ClientPtr client;
X
X{
X  int status;
X  register DrawablePtr pDraw;
X  XvPortPtr pPort;
X  REQUEST(xvStopVideoReq);
X  REQUEST_SIZE_MATCH(xvStopVideoReq);
X
X  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
X    {
X      client->errorValue = stuff->port;
X      return (_XvBadPort);
X    }
X
X  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
X    {
X      client->errorValue = stuff->port;
X      return (status);
X    }
X
X  if(!(pDraw = LOOKUP_DRAWABLE(stuff->drawable, client) ))
X    {
X      client->errorValue = stuff->drawable;
X      return (BadDrawable);
X    }
X
X  return XVCALL(diStopVideo)(client, pPort, pDraw);
X
X}
X
Xstatic int
XProcXvSetPortAttribute(client)
Xregister ClientPtr client;
X
X{
X  int status;
X  register len;
X  XvPortPtr pPort;
X  REQUEST(xvSetPortAttributeReq);
X  REQUEST_SIZE_MATCH(xvSetPortAttributeReq);
X
X  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
X    {
X      client->errorValue = stuff->port;
X      return (_XvBadPort);
X    }
X
X  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
X    {
X      client->errorValue = stuff->port;
X      return (status);
X    }
X
X  if (!ValidAtom(stuff->attribute))
X    {
X      client->errorValue = stuff->attribute;
X      return(BadAtom);
X    }
X
X  status = XVCALL(diSetPortAttribute)(client, pPort, 
X				    stuff->attribute, stuff->value);
X
X  if (status == BadMatch) 
X      client->errorValue = stuff->attribute;
X  else
X      client->errorValue = stuff->value;
X
X  return status;
X
X}
X
Xstatic int
XProcXvGetPortAttribute(client)
Xregister ClientPtr client;
X
X{
X  int value;
X  int status;
X  XvPortPtr pPort;
X  xvGetPortAttributeReply rep;
X  REQUEST(xvGetPortAttributeReq);
X  REQUEST_SIZE_MATCH(xvGetPortAttributeReq);
X
X  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
X    {
X      client->errorValue = stuff->port;
X      return (_XvBadPort);
X    }
X
X  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
X    {
X      client->errorValue = stuff->port;
X      return (status);
X    }
X
X  if (!ValidAtom(stuff->attribute))
X    {
X      client->errorValue = stuff->attribute;
X      return(BadAtom);
X    }
X
X  status = XVCALL(diGetPortAttribute)(client, pPort, stuff->attribute, &value);
X  if (status != Success)
X    {
X      client->errorValue = stuff->attribute;
X      return status;
X    }
X
X  rep.type = X_Reply;
X  rep.sequenceNumber = client->sequence;
X  rep.length = 0;
X  rep.value = value;
X 
X  _WriteGetPortAttributeReply(client, &rep);
X
X  return Success;
X}
X
Xstatic int
XProcXvQueryBestSize(client)
Xregister ClientPtr client;
X
X{
X  int status;
X  CARD16 actual_width, actual_height;
X  XvPortPtr pPort;
X  xvQueryBestSizeReply rep;
X  REQUEST(xvQueryBestSizeReq);
X  REQUEST_SIZE_MATCH(xvQueryBestSizeReq);
X
X  if(!(pPort = LOOKUP_PORT(stuff->port, client) ))
X    {
X      client->errorValue = stuff->port;
X      return (_XvBadPort);
X    }
X
X  if ((status = _AllocatePort(stuff->port, pPort)) != Success)
X    {
X      client->errorValue = stuff->port;
X      return (status);
X    }
X
X  rep.type = X_Reply;
X  rep.sequenceNumber = client->sequence;
X  rep.length = 0;
X
X  (* pPort->pAdaptor->ddQueryBestSize)(client, pPort, stuff->motion,
X				       stuff->vid_w, stuff->vid_h, 
X				       stuff->drw_w, stuff->drw_h, 
X				       &actual_width, &actual_height);
X
X  rep.actual_width = actual_width;
X  rep.actual_height = actual_height;
X 
X  _WriteQueryBestSizeReply(client, &rep);
X
X  return Success;
X}
X
X/* Swapped Procs */
X
Xstatic int
XSProcXvQueryExtension(client)
Xregister ClientPtr client;
X
X{
X  register char n;
X  REQUEST(xvQueryExtensionReq);
X  swaps(&stuff->length, n);
X  return ProcXvQueryExtension(client);
X}
X
Xstatic int
XSProcXvQueryAdaptors(client)
Xregister ClientPtr client;
X
X{
X  register char n;
X  REQUEST(xvQueryAdaptorsReq);
X  swaps(&stuff->length, n);
X  swapl(&stuff->window, n);
X  return ProcXvQueryAdaptors(client);
X}
X
Xstatic int
XSProcXvQueryEncodings(client)
Xregister ClientPtr client;
X
X{
X  register char n;
X  REQUEST(xvQueryEncodingsReq);
X  swaps(&stuff->length, n);
X  swapl(&stuff->port, n);
X  return ProcXvQueryEncodings(client);
X}
X
Xstatic int
XSProcXvGrabPort(client)
Xregister ClientPtr client;
X
X{
X  register char n;
X  REQUEST(xvGrabPortReq);
X  swaps(&stuff->length, n);
X  swapl(&stuff->port, n);
X  swapl(&stuff->time, n);
X  return ProcXvGrabPort(client);
X}
X
Xstatic int
XSProcXvUngrabPort(client)
Xregister ClientPtr client;
X
X{
X  register char n;
X  REQUEST(xvUngrabPortReq);
X  swaps(&stuff->length, n);
X  swapl(&stuff->port, n);
X  swapl(&stuff->time, n);
X  return ProcXvUngrabPort(client);
X}
X
Xstatic int
XSProcXvPutVideo(client)
Xregister ClientPtr client;
X
X{
X  register char n;
X  REQUEST(xvPutVideoReq);
X  swaps(&stuff->length, n);
X  swapl(&stuff->port, n);
X  swapl(&stuff->drawable, n);
X  swapl(&stuff->gc, n);
X  swaps(&stuff->vid_x, n);
X  swaps(&stuff->vid_y, n);
X  swaps(&stuff->vid_w, n);
X  swaps(&stuff->vid_h, n);
X  swaps(&stuff->drw_x, n);
X  swaps(&stuff->drw_y, n);
X  swaps(&stuff->drw_w, n);
X  swaps(&stuff->drw_h, n);
X  return ProcXvPutVideo(client);
X}
X
Xstatic int
XSProcXvPutStill(client)
Xregister ClientPtr client;
X
X{
X  register char n;
X  REQUEST(xvPutStillReq);
X  swaps(&stuff->length, n);
X  swapl(&stuff->port, n);
X  swapl(&stuff->drawable, n);
X  swapl(&stuff->gc, n);
X  swaps(&stuff->vid_x, n);
X  swaps(&stuff->vid_y, n);
X  swaps(&stuff->vid_w, n);
X  swaps(&stuff->vid_h, n);
X  swaps(&stuff->drw_x, n);
X  swaps(&stuff->drw_y, n);
X  swaps(&stuff->drw_w, n);
X  swaps(&stuff->drw_h, n);
X  return ProcXvPutStill(client);
X}
X
Xstatic int
XSProcXvGetVideo(client)
Xregister ClientPtr client;
X
X{
X  register char n;
X  REQUEST(xvGetVideoReq);
X  swaps(&stuff->length, n);
X  swapl(&stuff->port, n);
X  swapl(&stuff->drawable, n);
X  swapl(&stuff->gc, n);
X  swaps(&stuff->vid_x, n);
X  swaps(&stuff->vid_y, n);
X  swaps(&stuff->vid_w, n);
X  swaps(&stuff->vid_h, n);
X  swaps(&stuff->drw_x, n);
X  swaps(&stuff->drw_y, n);
X  swaps(&stuff->drw_w, n);
X  swaps(&stuff->drw_h, n);
X  return ProcXvGetVideo(client);
X}
X
Xstatic int
XSProcXvGetStill(client)
Xregister ClientPtr client;
X
X{
X  register char n;
X  REQUEST(xvGetStillReq);
X  swaps(&stuff->length, n);
X  swapl(&stuff->port, n);
X  swapl(&stuff->drawable, n);
X  swapl(&stuff->gc, n);
X  swaps(&stuff->vid_x, n);
X  swaps(&stuff->vid_y, n);
X  swaps(&stuff->vid_w, n);
X  swaps(&stuff->vid_h, n);
X  swaps(&stuff->drw_x, n);
X  swaps(&stuff->drw_y, n);
X  swaps(&stuff->drw_w, n);
X  swaps(&stuff->drw_h, n);
X  return ProcXvGetStill(client);
X}
X
Xstatic int
XSProcXvSelectVideoNotify(client)
Xregister ClientPtr client;
X
X{
X  register char n;
X  REQUEST(xvSelectVideoNotifyReq);
X  swaps(&stuff->length, n);
X  swapl(&stuff->drawable, n);
X  return ProcXvSelectVideoNotify(client);
X}
X
Xstatic int
XSProcXvSelectPortNotify(client)
Xregister ClientPtr client;
X
X{
X  register char n;
X  REQUEST(xvSelectPortNotifyReq);
X  swaps(&stuff->length, n);
X  swapl(&stuff->port, n);
X  return ProcXvSelectPortNotify(client);
X}
X
Xstatic int
XSProcXvStopVideo(client)
Xregister ClientPtr client;
X
X{
X  register char n;
X  REQUEST(xvStopVideoReq);
X  swaps(&stuff->length, n);
X  swapl(&stuff->port, n);
X  swapl(&stuff->drawable, n);
X  return ProcXvStopVideo(client);
X}
X
Xstatic int
XSProcXvSetPortAttribute(client)
Xregister ClientPtr client;
X
X{
X  register char n;
X  REQUEST(xvSetPortAttributeReq);
X  swaps(&stuff->length, n);
X  swapl(&stuff->port, n);
X  swapl(&stuff->attribute, n);
X  swapl(&stuff->value, n);
X  return ProcXvSetPortAttribute(client);
X}
X
Xstatic int
XSProcXvGetPortAttribute(client)
Xregister ClientPtr client;
X
X{
X  register char n;
X  REQUEST(xvGetPortAttributeReq);
X  swaps(&stuff->length, n);
X  swapl(&stuff->port, n);
X  swapl(&stuff->attribute, n);
X  return ProcXvGetPortAttribute(client);
X}
X
Xstatic int
XSProcXvQueryBestSize(client)
Xregister ClientPtr client;
X
X{
X  register char n;
X  REQUEST(xvQueryBestSizeReq);
X  swaps(&stuff->length, n);
X  swapl(&stuff->port, n);
X  swaps(&stuff->vid_w, n);
X  swaps(&stuff->vid_h, n);
X  swaps(&stuff->drw_w, n);
X  swaps(&stuff->drw_h, n);
X  return ProcXvQueryBestSize(client);
X}
X
Xstatic int
XSWriteQueryExtensionReply(client, rep)
Xregister ClientPtr client;
XxvQueryExtensionReply *rep;
X
X{
X  register char n;
X
X  swaps(&rep->sequenceNumber, n);
X  swapl(&rep->length, n);
X  swaps(&rep->version, n);
X  swaps(&rep->revision, n);
X  
X  (void)WriteToClient(client, sz_xvQueryExtensionReply, (char *)rep);
X
X}
X
Xstatic int
XSWriteQueryAdaptorsReply(client, rep)
Xregister ClientPtr client;
XxvQueryAdaptorsReply *rep;
X
X{
X  register char n;
X
X  swaps(&rep->sequenceNumber, n);
X  swapl(&rep->length, n);
X  swaps(&rep->num_adaptors, n);
X  
X  (void)WriteToClient(client, sz_xvQueryAdaptorsReply, (char *)rep);
X
X}
X
Xstatic int
XSWriteQueryEncodingsReply(client, rep)
Xregister ClientPtr client;
XxvQueryEncodingsReply *rep;
X
X{
X  register char n;
X
X  swaps(&rep->sequenceNumber, n);
X  swapl(&rep->length, n);
X  swaps(&rep->num_encodings, n);
X  
X  (void)WriteToClient(client, sz_xvQueryEncodingsReply, (char *)rep);
X
X}
X
Xstatic int
XSWriteAdaptorInfo(client, pAdaptor)
Xregister ClientPtr client;
XxvAdaptorInfo *pAdaptor;
X
X{
X  register char n;
X
X  swapl(&pAdaptor->base_id, n);
X  swaps(&pAdaptor->name_size, n);
X  swaps(&pAdaptor->num_ports, n);
X  swaps(&pAdaptor->num_formats, n);
X
X  (void)WriteToClient(client, sz_xvAdaptorInfo, (char *)pAdaptor);
X
X}
X
Xstatic int
XSWriteEncodingInfo(client, pEncoding)
Xregister ClientPtr client;
XxvEncodingInfo *pEncoding;
X
X{
X  register char n;
X  
X  swapl(&pEncoding->encoding, n);
X  swaps(&pEncoding->name_size, n);
X  swaps(&pEncoding->width, n);
X  swaps(&pEncoding->height, n);
X  swapl(&pEncoding->rate.numerator, n);
X  swapl(&pEncoding->rate.denominator, n);
X  (void)WriteToClient(client, sz_xvEncodingInfo, (char *)pEncoding);
X}
X
Xstatic int
XSWriteFormat(client, pFormat)
Xregister ClientPtr client;
XxvFormat *pFormat;
X
X{
X  register char n;
X
X  swapl(&pFormat->visual, n);
X  (void)WriteToClient(client, sz_xvFormat, (char *)pFormat);
X}
X
Xstatic int
XSWriteGrabPortReply(client, rep)
Xregister ClientPtr client;
XxvGrabPortReply *rep;
X
X{
X  register char n;
X
X  swaps(&rep->sequenceNumber, n);
X  swapl(&rep->length, n);
X
X  (void)WriteToClient(client, sz_xvGrabPortReply, (char *)rep);
X
X}
X
Xstatic int
XSWriteGetPortAttributeReply(client, rep)
Xregister ClientPtr client;
XxvGetPortAttributeReply *rep;
X
X{
X  register char n;
X
X  swaps(&rep->sequenceNumber, n);
X  swapl(&rep->length, n);
X  swapl(&rep->value, n);
X
X  (void)WriteToClient(client, sz_xvGetPortAttributeReply, (char *)rep);
X
X}
X
Xstatic int
XSWriteQueryBestSizeReply(client, rep)
Xregister ClientPtr client;
XxvQueryBestSizeReply *rep;
X
X{
X  register char n;
X
X  swaps(&rep->sequenceNumber, n);
X  swapl(&rep->length, n);
X  swaps(&rep->actual_width, n);
X  swaps(&rep->actual_height, n);
X
X  (void)WriteToClient(client, sz_xvQueryBestSizeReply, (char *)rep);
X
X}
END_OF_FILE
if test 28119 -ne `wc -c <'extensions/xv/server/xvdisp.c'`; then
    echo shar: \"'extensions/xv/server/xvdisp.c'\" unpacked with wrong size!
fi
# end of 'extensions/xv/server/xvdisp.c'
fi
if test ! -d 'extensions/xv/test' ; then
    echo shar: Creating directory \"'extensions/xv/test'\"
    mkdir 'extensions/xv/test'
fi
if test ! -d 'install' ; then
    echo shar: Creating directory \"'install'\"
    mkdir 'install'
fi
if test ! -d 'lib' ; then
    echo shar: Creating directory \"'lib'\"
    mkdir 'lib'
fi
if test ! -d 'lib/X' ; then
    echo shar: Creating directory \"'lib/X'\"
    mkdir 'lib/X'
fi
if test ! -d 'server' ; then
    echo shar: Creating directory \"'server'\"
    mkdir 'server'
fi
if test ! -d 'server/ddx' ; then
    echo shar: Creating directory \"'server/ddx'\"
    mkdir 'server/ddx'
fi
if test ! -d 'server/ddx/cfb32' ; then
    echo shar: Creating directory \"'server/ddx/cfb32'\"
    mkdir 'server/ddx/cfb32'
fi
if test ! -d 'server/ddx/dec' ; then
    echo shar: Creating directory \"'server/ddx/dec'\"
    mkdir 'server/ddx/dec'
fi
if test ! -d 'server/ddx/dec/tx' ; then
    echo shar: Creating directory \"'server/ddx/dec/tx'\"
    mkdir 'server/ddx/dec/tx'
fi
if test ! -d 'server/ddx/dec/ws' ; then
    echo shar: Creating directory \"'server/ddx/dec/ws'\"
    mkdir 'server/ddx/dec/ws'
fi
if test ! -d 'server/ddx/mi' ; then
    echo shar: Creating directory \"'server/ddx/mi'\"
    mkdir 'server/ddx/mi'
fi
if test ! -d 'server/ddx/sun' ; then
    echo shar: Creating directory \"'server/ddx/sun'\"
    mkdir 'server/ddx/sun'
fi
echo shar: End of archive 1 \(of 29\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 29 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Molecular Simulations, Inc.             mail: dcmartin@msi.com
796 N. Pastoria Avenue                  uucp: uunet!dcmartin
Sunnyvale, California 94086             at&t: 408/522-9236
