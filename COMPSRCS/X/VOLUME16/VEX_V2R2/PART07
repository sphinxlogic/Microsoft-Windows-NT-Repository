Path: uunet!think.com!mips!msi!dcmartin
From: dcc@Athena.MIT.EDU (David Carver)
Newsgroups: comp.sources.x
Subject: v16i058: Video Extension for X (v2r2), Part07/29
Message-ID: <1992Feb6.145456.29963@msi.com>
Date: 6 Feb 92 14:54:56 GMT
References: <csx-16i052-vex.v2r2@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1541
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: dcc@Athena.MIT.EDU (David Carver)
Posting-number: Volume 16, Issue 58
Archive-name: vex.v2r2/part07

# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
#		"End of archive 7 (of 29)."
# Contents:  extensions/xv/server/ddx/sunrop/pip_tcl.c lib/X/XErrorDB
# Wrapped by dcmartin@fascet on Thu Feb  6 06:52:45 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'extensions/xv/server/ddx/sunrop/pip_tcl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extensions/xv/server/ddx/sunrop/pip_tcl.c'\"
else
echo shar: Extracting \"'extensions/xv/server/ddx/sunrop/pip_tcl.c'\" \(42298 characters\)
sed "s/^X//" >'extensions/xv/server/ddx/sunrop/pip_tcl.c' <<'END_OF_FILE'
X/*******************************************************************************
X * *************************************************************************** *
X * *"pip_tcl.c"                                                              * *
X * *                                                                         * *
X * *    Support for Picture In a Picture option object which uses the analog * *
X * *    PIP implementation (e.g., SPARC Card (tm) TCL board).                * *
X * *                                                                         * *
X * *    Conventions:                                                         * *
X * *       (1) File is formatted assuming tab stops every four characters.   * *
X * *       (2) Routines are in alphabetical order.                           * *
X * *                                                                         * *
X * *                  Copyright 1991, RasterOps, Inc.                        * *
X * *************************************************************************** *
X *******************************************************************************/
X
X#include <sys/types.h>				/* General type defs. */
X#include <sys/param.h>              /* General system parameters and limits. */
X#include <sys/time.h>               /* General timer parameters. */
X
X#include <sys/buf.h>                /* Input / Output buffer defs. */
X#include <sys/errno.h>              /* Kernel error defs. */
X#include <sys/ioccom.h>				/* Ioctl registery and macros. */
X#include <sys/user.h>               /* User management and accounting defs. */
X#include <sys/mman.h> 				/* Virtual memory related macros. */
X
X#include <pixrect/pr_planegroups.h> /* Bit plane manipulation defs. */
X
X#include <sun/fbio.h>               /* General frame buffer ioctl defs. */
X#include <sundev/mbvar.h>           /* Main bus interface defs. */
X#include <sbusdev/memfb.h>          /* SBus memory mapped frame buf layout. */
X#include <sunwindow/cms.h>          /* Colormapseg, cms_map */
X
X#include <sundev/cg8reg.h>			/* Device dependent memory layouts, etc. */
X#include <sunwindow/rect.h>			/* Definition of Rect data structure. */
X
X#include "pip_impl.h"				/* Definition for Pip Object. */
X
X/*
X *  Bit access definitions:
X */
Xstatic int  bit_get[] = {       /* Mask for getting bit within byte. */
X    0x80, 0x40, 0x20, 0x10,     /* ... */
X    0x08, 0x04, 0x02, 0x01      /* ... */
X};                              /* ... */
Xstatic int  bit_clear[] = {     /* Mask for clearing all but 1 bit within a byte. */
X    ~0x80, ~0x40, ~0x20, ~0x10, /* ... */
X    ~0x08, ~0x04, ~0x02, ~0x01  /* ... */
X};                              /* ... */
Xstatic int  bit_shift[] = {     /* Shift to move select bit to bit 0. */
X    7, 6, 5, 4,                 /* ... */
X    3, 2, 1, 0,                 /* ... */
X};                              /* ... */
X
X/*
X *	Forward References:
X */
Xstatic int  tcl_fill_true_color(); 		/* Fill true color memory. */
Xstatic int  tcl_fill_video_enable(); 	/* Fill video enable memory. */
Xstatic void tcl_get_levels();        	/* Get the picture levels. */
Xstatic void tcl_get_destination_area(); /* Get the pip output area. */
Xstatic void tcl_get_source_area();   	/* Get the pip signal area. */
Xstatic void tcl_get_source_type();   	/* Get the pip source (e.g., rgb). */
Xstatic int  tcl_init();              	/* Initialize pip. */
Xstatic int  tcl_off();               	/* Turn off pip. */
Xstatic int	tcl_one_shot();				/* Turn pip on for one frame. */
Xstatic int  tcl_on();                	/* Turn on pip. */
Xstatic int  tcl_resume();			 	/* Pop the "off" stack by one. */
Xstatic void tcl_set_levels();        	/* Set the picture levels. */
Xstatic void tcl_set_destination_area();	/* Set pip output origin, size &rect. */
Xstatic void tcl_set_source_area();   	/* Set the pip signal area. */
Xstatic void tcl_set_source_type();   	/* Set the pip source (e.g., rgb). */
Xstatic void tcl_status();   		 	/* Return status of pip. */
Xstatic int  tcl_suspend();			 	/* Push the "off" stack by one. */
Xstatic void tcl_terminate();   		 	/* Terminate an object. */
X
X/*	Routines to support Picture In A Picture Option card.
X *
X *		Copyright(c) 1990, RasterOps, Inc.
X *
X *	Notes:
X *		(1) Control status register zero has one bit which is shared, that is, 
X *          it has different meanings on input and output. If the bit is written
X *			it directs that a one-shot grab should be done. If the bit is read 
X *			it indicates if the pip has been turned on. Because of this sharing 
X *			it is not possible to use read modify write cycles in "tcl_off".
X *		
X *		(2)	The TCP_CSR0_TURN_PIP_ON bit is used to set the pip on or off. Its 
X *			value when read (TCP_CSR0_PIP_IS_ACTIVE) indicates if the pip is 
X *			actively writing data, NOT necessarily if the pip is on. The 
X *			TCP_CSR0_PIP_IS_ON bit indicates the the pip has been turned on, or 
X *			is running. The cycle looks like:
X *
X *              PIP_ON set  Field start             PIP_OFF set   Field end
X *                      |      |                            |        |
X *                      |      V                            V        V
X *                      V      ____________...________________________
X *	PIP_IS_ACTIVE     ________/                                       \_________
X *                       __________________...________________________
X *	PIP_IS_ON         __/                                             \_________
X *
X *		(3)	In addition, TCP_CSR0_PIP_IS_ACTIVE will drop if the input source is 
X *			not present, even though it is "ON". So TCP_CSR0_PIP_IS_ON should be 
X *			examined to determine the state of the pip, not 
X *			TCP_CSR0_PIP_IS_ACTIVE.
X *
X *		(4) When turning off the pip it will continue until the end of the field, 
X *			as shown above. So TCP_CSR0_PIP_IS_ACTIVE may be polled to see if the 
X *          pip is off.
X */
X
X/*"eeprom_read"
X *
X *  Read in a portion of the eeprom on the i2c bus.
X *
X *      = 1 if success
X *      = 0 if failure
X */
Xeeprom_read( port, buffer, offset, count )
X    u_char  *port;      /* -> port for i2c bus. */
X    u_char  *buffer;    /* -> where to place data read. */
X    int     offset;     /* =  offset within eeprom to start reading at. */
X    int     count;      /* =  # of bytes to be read. */
X{
X    int     counter;    /* Index: next byte to be read. */
X    int     value;      /* Value read. */
X
X    for (counter = 0; counter < count;  counter++, offset++)
X    {
X        if ( !i2c_read(port, I2C_ADDR_EEPROM, offset, &value) )
X        {
X            return 0;
X        }
X        buffer[counter] = value;
X    }
X    return 1;
X}
X
X/*"eeprom_write"
X *
X *  Write to a portion of the eeprom on the i2c bus.
X *
X *      = 1 if success
X *      = 0 if failure
X */
Xeeprom_write( port, buffer, offset, count )
X    u_char  *port;      /* -> port for i2c bus. */
X    u_char  *buffer;    /* -> where to get data to write. */
X    int     offset;     /* =  offset within eeprom to start writing at. */
X    int     count;      /* =  # of bytes to be written. */
X{
X    int     counter;    /* Index: next byte in buffer to be write. */
X	int		delay;		/* How long to loop waiting between writes. */
X
X    for (counter = 0; counter < count;  counter++, offset++)
X    {
X		for (delay = 0; delay < 100000; delay++) ;
X        if ( !i2c_write(port, I2C_ADDR_EEPROM, offset, buffer[counter]) )
X        {
X            return 0;
X        }
X    }    
X    return 1;
X}
X
X/*"tcl_fill_true_color"
X *
X *  Fill a rectangular region in the true color memory.
X */
Xstatic tcl_fill_true_color(this, left, top, width, height, color)
X    Pip_Object *this;      /* -> control block for this xv instance. */
X    int         left;       /* =  left side of region to fill in. */
X    int         top;        /* =  top side of region to fill in. */
X    int         width;      /* =  width of region to fill in. */
X    int         height;     /* =  height of region to fill in. */
X    u_int       color;      /* =  color to fill pixels with. */
X{
X    int         col;            /* Index: next col to fill */
X    int         row;            /* Index: next row to fill */
X    u_long      *true_color;    /* True color frame buffer. */
X
X	(*this->trvec.suspend)(this);
X
X    for ( row = top; row < top+height; row++ )
X    {
X        for ( col = left; col < left+width; col++ )
X        {
X            true_color[col+row*this->fb_pitch] = color;
X        }
X    }    
X
X	(*this->trvec.resume)(this);
X}
X
X/*"tcl_fill_video_enable"
X * 
X *  Fill a rectangular region in the video enable memory.
X */
Xstatic tcl_fill_video_enable(this, left, top, width, height, color)
X	Pip_Object	*this;	 	/* -> control block for this xv instance. */
X    int     	left;       /* =  left side of region to fill in. */
X    int     	top;        /* =  top side of region to fill in. */
X    int     	width;      /* =  width of region to fill in. */
X    int     	height;     /* =  height of region to fill in. */
X    u_int   	color;      /* =  color to fill pixels with. */
X{
X    u_int   clear_mask;     /* Mask used to clear a bit in the memory. */
X    u_int   fb;             /* Address of frame buffer. */
X    u_int   get_mask;       /* Mask used to set a bit in the memory. */
X	int		pitch;			/* Number of bytes between scan lines. */
X    u_char  *pixel;         /* Next set of 8 pixels to access in the fb. */
X    int     x;              /* Index: next column to set pixel value in. */
X    int     x_end_left;     /* End of strip to be filled a bit at a time on the left. */
X    int     x_end_middle;   /* End of strip to be filled which has all 8 pixels in each word. */
X    int     x_end_right;    /* End of strip to be filled a bit at a time on the right. */
X    int     y;              /* Index: next row to set pixel value in. */
X    int     y_end;          /* End of region to be in filled in y direction. */
X 
X	(*this->trvec.suspend)(this);
X 
X	fb = (u_int)this->mmap_obj->video_enable;
X	pitch = this->fb_pitch / 8;
X
X    x_end_right = left+width;
X    x_end_middle = (x_end_right/8)*8;
X    x_end_left = ((left+7)/8)*8;
X    if ( x_end_left > x_end_right ) x_end_left = x_end_right;
X    y_end = top+height;
X
X    /*
X     *  Fill left strip (left side pixels not in a full byte.)
X     */
X    for ( x = left; x < x_end_left; x++ )
X    {
X        pixel = (u_char *)(fb + x/8 + top * pitch);        
X		clear_mask = bit_clear[x%8];
X        get_mask = bit_get[x%8];
X        for ( y = top; y < y_end; y++ )
X        {
X            *pixel = (*pixel & clear_mask) | (color & get_mask);
X            pixel += pitch;
X        }
X    }
X 
X    /*
X     *  Fill the middle strip (pixels which are in full bytes.)
X     */
X    for ( ; x < x_end_middle; x+= 8 )
X    {
X        pixel = (u_char *)(fb + x/8 + top * pitch);        
X        for ( y = top; y < y_end; y++ )
X        {
X            *pixel = color;
X            pixel += pitch;
X        }
X    }
X 
X    /*
X     *  Fill in right strip (right side pixels not in a full byte.)
X     */
X    for ( ; x < x_end_right; x++ )
X    {
X        pixel = (u_char *)(fb + x/8 + top * pitch);        
X        clear_mask = bit_clear[x%8];
X        get_mask = bit_get[x%8];
X        for ( y = top; y < y_end; y++ )
X        {
X            *pixel = (*pixel & clear_mask) | (color & get_mask);
X            pixel += pitch;
X        }
X    }
X
X	(*this->trvec.resume)(this);
X}
X
X/*"tcl_get_levels"
X *
X *  Return picture levels (brightness, contrast, hue, saturation).
X */
Xstatic void tcl_get_levels( this, levels )
X    Pip_Object *this;   /* -> control block for this xv instance. */
X    Pip_Levels *levels; /* -> where to put current levels. */
X{
X	Tc1_Device_Map	*dmap;	/* Device register area. */
X
X	dmap = (Tc1_Device_Map *)this->mmap_obj->device_regs;
X
X	switch( dmap->control_status & TCP_CSR0_SOURCE_TYPE_MASK )
X	{
X		case TCP_CSR0_RGB_SOURCE:
X			levels->brightness = (2000 * this->tcl.pip_init_record.rgb_brightness) / 63 - 1000;
X			levels->contrast = (2000 * this->tcl.pip_init_record.rgb_contrast) / 63 - 1000;
X			break;
X		default:
X			levels->brightness = (2000 * this->tcl.pip_init_record.brightness) / 63 - 1000;
X			levels->contrast = (2000 * this->tcl.pip_init_record.contrast) / 63 - 1000;
X			break;
X	}		
X	levels->hue = (2000 * this->tcl.pip_init_record.hue) / 63 - 1000;
X	levels->saturation = (2000 * this->tcl.pip_init_record.saturation) / 63 - 1000;
X}
X
X/*"tcl_get_destination_area"
X *
X *	Return the current output area information.
X */
Xstatic void tcl_get_destination_area( this, area )
X	Pip_Object		*this;	 /* -> control block for this xv instance. */
X	Pip_Dst_Area	*area;	 /* -> where to put current output area. */
X{
X	*area = this->destination_area;
X}
X	
X/*"tcl_get_source_area"
X *
X *  Return the current output area information.
X */
Xstatic void tcl_get_source_area( this, signal )
X    Pip_Object     *this;      /* -> control block for this xv instance. */
X    Pip_Src_Area   *signal;    /* -> where to put source area info. */
X{
X	Tc1_Device_Map	*dmap;		/* Device registers for Tcl. */
X
X	dmap = (Tc1_Device_Map *)this->mmap_obj->device_regs;
X
X    signal->left = dmap->x_source_start;
X    signal->width = dmap->x_source_end - signal->left;
X    signal->top  = dmap->y_source_start * 2;
X    signal->height = (dmap->y_source_end * 2) - signal->top;
X}
X	
X/*"tcl_get_source_type"
X *
X *  Get the type and timing of source being used. Update the information
X *	in the object's source fields from the hardware, and then return that
X *  information to the caller. Note, the timing cannot be determined from
X *  reading the hardware, so use the information already in the record.
X */
Xstatic void tcl_get_source_type(this, source)
X    Pip_Object  *this;      /* -> pip object. */
X    Pip_Source  *source;    /* -> source specification. */
X{
X	Tc1_Device_Map	*dmap;	/* Device register area. */
X
X	dmap = (Tc1_Device_Map *)this->mmap_obj->device_regs;
X	this->source.vtr_mode = 
X		(dmap->control_status2 & TCP_CSR2_ALTERNATE_PLL) ? 1 : 0;
X	this->source.fields_inverted = 
X		(dmap->control_status2 & TCP_CSR2_FIELD_INVERT) ? 1 : 0;
X
X	switch ( dmap->control_status & TCP_CSR0_SOURCE_TYPE_MASK )
X	{
X	  case TCP_CSR0_COMPOSITE_SOURCE: this->source.type = PS_COMPOSITE; break;
X	  case TCP_CSR0_S_VIDEO_SOURCE:   this->source.type = PS_S_VIDEO; break;
X	  case TCP_CSR0_RGB_SOURCE:       this->source.type = PS_RGB; break;
X	}
X 	*source = this->source;
X}
X
X/*"tcl_init"
X *
X *  Initialize the Picture In A Picture hardware from its on-board EEPROM.
X *
X *      = 1 if pip initialized
X *      = 0 if eeprom could not be read
X */
Xstatic tcl_init( this, source, host_fb )
X	Pip_Object	 	*this;	 	/* -> control block for this xv instance. */
X	Pip_Source		*source;	/* -> type of video source desired. */
X	Pip_Fb_Type		*host_fb;	/* -> type of frame buffer being used. */
X{
X	Tc1_Device_Map	*dmap;			/* Device register area pointer. */
X    EEPROM_Record   eeprom_record;  /* Where to read eeprom data into. */
X	int				mode;			/* EEPROM mode to load. */
X    Pip_Init_Record *pip_init;      /* Which initialization information to use. */
X    int             pll_i;          /* Index: next pll value to set. */
X    u_char          *port;          /* I2C bus port address. */
X    int             rc;             /* Our return code. */
X 
X	dmap = (Tc1_Device_Map *)this->mmap_obj->device_regs;
X    port = &dmap->control_status1;
X
X	switch (source->timing)
X	{
X	  default: printf("Unknown source timing %d, defaulting to NTSC\n", source->timing);
X	  case PT_NTSC: mode = EEPROM_NTSC; break;
X	  case PT_PAL: mode = EEPROM_PAL; break;
X	}
X 
X    /*  Read in the initialization record from the eeprom and verify it.
X     *  Determine which set of timing information to use.
X	 *	Copy the values we will use into the initialization shadow
X	 *	record provided by our caller.
X     */
X    if ( !eeprom_read(port, &eeprom_record, 0, sizeof(EEPROM_Record)) ||
X         (eeprom_record.default_mode >= EEPROM_NUM_MODES) )
X    {
X        printf("tcl_init: unable to read eeprom properly\n");
X        return 0;
X    }
X 
X    if ( mode < 0 ) mode = (u_int)eeprom_record.default_mode;
X    if ( mode >= EEPROM_NUM_MODES )
X    {
X        printf("tcl_init: illegal mode value %d\n", mode);
X        return 0;
X    }
X    pip_init = &eeprom_record.mode[mode];
X	bcopy(pip_init, this->tcl.pip_init_record, sizeof(Pip_Init_Record));
X    rc = 1;
X    
X	/*	Make sure that control registers 0, 1 and 2 have reasonable values.
X	 *	(composite input, no funny states.)
X	 */
X	dmap->control_status = 0x00;
X	dmap->control_status1 = 0xc0;
X	dmap->control_status2 = 0x00;
X 
X    /*  Load the signal boundary information.
X     */
X    dmap->x_source_start = pip_init->x_source_start;
X    dmap->x_source_end = pip_init->x_source_end;
X    dmap->y_source_start = pip_init->y_source_start;
X    dmap->y_source_end = pip_init->y_source_end;
X 
X    /*  Load the pitch and size registers to their default values.
X     */
X	this->fb_pitch = host_fb->pitch;
X
X    dmap->fb_pitch = host_fb->pitch;
X    dmap->x_source_scale = 0xfff;
X    dmap->y_source_scale = 0xfff;
X
X    /*  Load the DAC level and timing information.
X     */
X    if ( !i2c_write(port, I2C_ADDR_DACS, I2C_BRIGHTNESS, pip_init->brightness) )
X    {
X        printf("tcl_init: failed to write brightness correctly\n");
X        rc = 0;
X    }   
X    if ( !i2c_write(port, I2C_ADDR_DACS, I2C_CONTRAST, pip_init->contrast) )
X    {
X        printf("tcl_init: failed to write contrast correctly\n");
X        rc = 0;
X    }   
X    if ( !i2c_write(port, I2C_ADDR_DACS, I2C_SATURATION, pip_init->saturation) )
X    {
X        printf("tcl_init: failed to write saturation correctly\n");
X        rc = 0;
X    }
X    if ( !i2c_write(port, I2C_ADDR_DACS, I2C_HUE, pip_init->hue) )
X    {
X        printf("tcl_init: failed to write hue correctly\n");
X        rc = 0;
X    }
X    if ( !i2c_write(port, I2C_ADDR_DACS, I2C_POD_CMD, pip_init->timing_mode) )
X    {
X        printf("tcl_init: failed to write timing mode correctly\n");
X        rc = 0;
X    }
X 
X    /*  Load the phase lock loop timing information.
X     */
X    for (pll_i = 0; pll_i < TCP_NPLL; pll_i++)
X    {
X        dmap->pll.vector[pll_i] = pip_init->pll.vector[pll_i];
X    }
X 
X    return rc;
X}
X 
X/*"tcl_init_write"
X *
X *  Write initialization data to EEPROM.
X *
X *		= 1 if success
X *      = 0 if eeprom could not be read/written
X */
Xtcl_init_write( this, default_load, record )
X	Pip_Object		*this;		  /* -> control block for this xv instance. */
X	int				default_load; /* =  1 if this should be default out of EEPROM. */
X	Pip_Init_Record	*record;	  /* -> where to place pip init record used. */
X{
X    EEPROM_Record   eeprom_record;  /* Where to read eeprom data into. */
X    u_char          *port;          /* I2C bus port address. */
X	int				timing;			/* Which initialization record is being set. */
X 
X    port = (u_char *)&((Tc1_Device_Map *)
X		(this->mmap_obj->device_regs))->control_status1;
X 
X    /*  Read in the initialization record from the eeprom. Then
X	 *	update the NTSC or PAL values dependent upon which values
X	 *	were passed to us.
X     */
X    if ( !eeprom_read(port, &eeprom_record, 0, sizeof(EEPROM_Record)) )
X    {
X        printf("tcl_init_write: unable to read eeprom properly\n");
X        return 0;
X    }
X    timing = ( record->timing_mode == I2C_POD_PAL ) ? 1 : 0;
X    bcopy(record, &eeprom_record.mode[timing], sizeof(Pip_Init_Record));
X    if ( default_load ) eeprom_record.default_mode = timing;
X    if ( !eeprom_write(port, &eeprom_record, 0, sizeof(EEPROM_Record)) )
X    {
X        printf("tcl_init_write: unable to write eeprom properly\n");
X        return 0;
X    }
X    return 1;
X}
X
X/*"tcl_off"
X *
X *	Turn off live video generation, returning the previous state of the bit.
X *
X *
X *	Notes:
X *		(1) See notes 2 and 3 at the beginning of this file for a detailed
X *			explanation of all the shenanigans with bits in control status
X *			register 0 that occur here.
X *
X *		= 1 if pip was on
X *		= 0 if pip was off
X */
Xstatic int tcl_off(this, wait_for_inactive)
X	Pip_Object	*this;				/* -> device instance dependent data. */
X	int			wait_for_inactive;	/* =  1 if wait for pip to actually turn off */
X{
X	Tc1_Device_Map	*dmap;		/* -> device area on TCPIP card. */
X	int				i;			/* Index: # of times gone around wait loop. */
X	static int		off = 0;	/* Value to turn pip off. */
X	int				pip_was_on;	/* Indicates if pip was active. */
X
X	dmap = (Tc1_Device_Map *)this->mmap_obj->device_regs;
X	ioctl(this->fd, PIPIO_S_PIP_ON_OFF, &off);
X    if ( wait_for_inactive && (dmap->control_status & TCP_CSR0_PIP_IS_ACTIVE) )
X    {
X        for (i = 0; i < 10000000; i++)
X        {
X            if ( !(dmap->control_status & TCP_CSR0_PIP_IS_ACTIVE) ) break;
X        }   
X        if ( i >=       10000000 )
X        {
X            printf(" Pip did not turn off in %d loops!!!!\n", i);
X        }
X    }
X
X    /* XXX --- pip_was_on HAS NEVER BEEN INITIALIZED --- DCC */
X
X    return (pip_was_on) ? 1 : 0;
X}
X
X/*"tcl_on"
X *
X *	Turn on live video generation. (Don't do it unless there
X *	is an active data source connected.
X */
Xstatic int tcl_on(this)
X	Pip_Object   *this;   /* -> control block for this xv instance. */
X{
X	static int		on = 1;		/* Value to set pip live video with. */
X
X	ioctl(this->fd, PIPIO_S_PIP_ON_OFF, &on);
X}
X
X/*"tcl_one_shot"
X *
X *	Perform a one shot video capture, leaving the video turned off.
X *	A one-shot is generated by toggling the one-shot bit from off to on to off.
X */
Xstatic int tcl_one_shot(this)
X	Pip_Object       *this;   /* -> control block for this xv instance. */
X{
X	int				csr0;		/* Contents of control status register zero. */
X	Tc1_Device_Map	*dmap;		/* Device area pointer. */
X
X	dmap = (Tc1_Device_Map *)this->mmap_obj->device_regs;
X	csr0 = dmap->control_status & ~(TCP_CSR0_TURN_PIP_ON|TCP_CSR0_PIP_ONE_SHOT);
X	dmap->control_status = csr0 | TCP_CSR0_PIP_ONE_SHOT;
X	dmap->control_status = csr0 & ~TCP_CSR0_PIP_ONE_SHOT;
X
X}
X
X/*"tcl_source"
X *
X *	Set the source of video signals. Assumes pip has been turned off
X *	previously.
X *
X *		= 1 if success
X *		= 0 if error occurred setting brightness or contrast level
X */
Xstatic int tcl_source(this, source, record)
X	Pip_Object     *this;      /* -> control block for this xv instance. */
X	u_int			source;		/* =  video source (composite, s-video,rgb). */
X	Pip_Init_Record	*record;	/* -> init. record to use dac settings from. */
X{
X	int				brightness;	/* Brightness setting to load. */
X	Tc1_Device_Map	*dmap;		/* Device area pointer. */
X	int				contrast;	/* Contrast setting to load. */
X	u_int			csr0;		/* Contents of control status register 0. */
X    u_char      	*port;      /* I2C bus port address. */
X	int				rc;			/* Return code to send to our caller. */
X 
X	/*	Get the current value of the status register.
X	 *	Then set the new video source. Set the brightness and contrast settings
X	 *	for this source type.
X	 */
X	dmap = (Tc1_Device_Map *)this->mmap_obj->device_regs;
X	csr0 = dmap->control_status;
X	dmap->control_status = (csr0 & 
X		~(TCP_CSR0_TURN_PIP_ON|TCP_CSR0_PIP_ONE_SHOT|TCP_CSR0_SOURCE_TYPE_MASK)) 
X		| (source & TCP_CSR0_SOURCE_TYPE_MASK);
X
X	switch( source )
X	{
X		case PS_COMPOSITE:
X		case PS_S_VIDEO:
X			brightness = record->brightness;
X			contrast = record->contrast;
X			break;
X		case PS_RGB:
X			brightness = record->rgb_brightness;
X			contrast = record->rgb_contrast;
X			break;
X	}
X	rc = 1;
X    port = &dmap->control_status1;
X    if ( !i2c_write(port, I2C_ADDR_DACS, I2C_BRIGHTNESS, brightness) )
X    {
X        printf("tcl_source: failed to write brightness correctly\n");
X        rc = 0;
X    }   
X    if ( !i2c_write(port, I2C_ADDR_DACS, I2C_CONTRAST, contrast) )
X    {
X        printf("tcl_source: failed to write contrast correctly\n");
X        rc = 0;
X    }   
X	return rc;
X}
X
X
X/*"tcl_resume"
X *
X *  Pop the pip from an off state, returning an indication if the pip
X *  is now live again. (This routine should only be called if a call
X *  to (*this->trvec.suspend) was done before it at some point!) Note we use the
X *	kernel ioctl since sunview or someone else may also be suspending.
X *
X *      = 1 if pip is now live
X *      = 0 if pip is still off
X */
Xstatic int tcl_resume(this)
X    Pip_Object *this;      /* -> control block for this xv instance. */
X{
X    int current_state;      /* State of pip operations after the resume. */
X
X    ioctl(this->fd, PIPIO_G_PIP_ON_OFF_RESUME, &current_state);
X    return current_state;
X}
X
X/*"tcl_set_levels"
X *
X *  Set picture levels (brightness, contrast, hue, saturation).
X */
Xstatic void tcl_set_levels( this, levels )
X    Pip_Object *this;   /* -> control block for this xv instance. */
X    Pip_Levels *levels; /* -> where to put current levels. */
X{
X	Tc1_Device_Map	*dmap;			/* Device register area pointer. */
X    EEPROM_Record   eeprom_record;  /* Where to read eeprom data into. */
X	int				level;			/* Level converted to 0 to 63 range. */
X    Pip_Init_Record *pip_init;      /* Which initialization information to use. */
X    int             pll_i;          /* Index: next pll value to set. */
X    u_char          *port;          /* I2C bus port address. */
X    int             rc;             /* Our return code. */
X 
X	(*this->trvec.suspend)(this);
X	dmap = (Tc1_Device_Map *)this->mmap_obj->device_regs;
X    port = &dmap->control_status1;
X 
X	switch( dmap->control_status & TCP_CSR0_SOURCE_TYPE_MASK )
X	{
X	  case TCP_CSR0_RGB_SOURCE:
X		level = (63*(levels->brightness+1000)) / 2000;
X		if ( level != this->tcl.pip_init_record.rgb_brightness )
X		{
X			this->tcl.pip_init_record.rgb_brightness = level;
X			if ( !i2c_write(&dmap->control_status1, I2C_ADDR_DACS, I2C_BRIGHTNESS, 
X					level) )
X			{
X				printf("tcl_set_levels: failed to write brightness\n");
X				return ;
X			}   
X		}
X		level = (63 * (levels->contrast+1000)) / 2000;
X		if ( level != this->tcl.pip_init_record.rgb_contrast )
X		{
X			this->tcl.pip_init_record.rgb_contrast = level;
X			if ( !i2c_write(&dmap->control_status1, I2C_ADDR_DACS, I2C_BRIGHTNESS, 
X					level) )
X			{
X				printf("tcl_set_levels: failed to write contrast\n");
X				return ;
X			}   
X		}
X		break;
X	  default:
X		level = (63 * (levels->brightness+1000)) / 2000;
X		if ( level != this->tcl.pip_init_record.brightness )
X		{
X			this->tcl.pip_init_record.brightness = level;
X			if ( !i2c_write(&dmap->control_status1, I2C_ADDR_DACS, I2C_BRIGHTNESS, 
X					level) )
X			{
X				printf("tcl_set_levels: failed to write brightness\n");
X				return ;
X			}   
X		}
X		level = (63 * (levels->contrast+1000)) / 2000;
X		if ( level != this->tcl.pip_init_record.contrast )
X		{
X			this->tcl.pip_init_record.contrast = level;
X			if ( !i2c_write(&dmap->control_status1, I2C_ADDR_DACS, I2C_BRIGHTNESS, 
X					level) )
X			{
X				printf("tcl_set_levels: failed to write contrast\n");
X				return ;
X			}   
X		}
X		break;
X	}
X	level = (63 * (levels->hue+1000)) / 2000;
X	if ( level != this->tcl.pip_init_record.hue )
X	{
X		this->tcl.pip_init_record.hue = level;
X		if ( !i2c_write(&dmap->control_status1, I2C_ADDR_DACS, I2C_HUE, 
X				level) )
X		{
X			printf("tcl_set_levels: failed to write hue\n");
X			return ;
X		}   
X	}
X	level = (63 * (levels->saturation+1000)) / 2000;
X	if ( level != this->tcl.pip_init_record.saturation )
X	{
X		this->tcl.pip_init_record.saturation = level;
X		if ( !i2c_write(&dmap->control_status1, I2C_ADDR_DACS, I2C_SATURATION, 
X				level ) )
X		{
X			printf("tcl_set_levels: failed to write saturation\n");
X			return ;
X		}   
X	}
X
X	(*this->trvec.resume)(this);
X}
X
X/*"tcl_set_destination_area"
X *
X *	Set the size of the rectangle for the pip output area.
X *  Assumes pip was turned off previously.
X *
X */
Xstatic void tcl_set_destination_area(this, area)
X	Pip_Object  	*this;   	/* -> control block for this xv instance. */
X	Pip_Dst_Area	*area;		/* -> output area specification. */
X{
X  Tc1_Device_Map	*dmap;		/* Device register area pointer. */
X  int				x_offset;	/* X offset of origin. */
X  int             signal_w;   /* Width of current x video signal. */
X  unsigned int    x_size;     /* X size mask. */
X  int				y_offset;	/* Y offset of origin. */
X  int             signal_h;   /* Height of current y video signal. */
X  unsigned int    y_size;     /* Y size mask. */
X  int adjustment;
X  
X  (*this->trvec.suspend)(this);
X  
X  dmap = (Tc1_Device_Map *)this->mmap_obj->device_regs;
X  this->destination_area = *area;
X  
X  /*
X   *  Set the upper left corner of the video window display area based on
X   *	vertical and horizontal orientation of the image. If the image is 
X   *	flipped in y, use a negative pitch and start the "image top" from the 
X   *	bottom of the display. If the image is flipped in x set the count down
X   *	bit and start the "image left" from the right of the display. Also
X   *	it is necessary to add or subtract the length of 3 scan lines dependent 
X   *	upon the current vertical orientation (normal or flipped.) 
X   */  
X  
X  signal_w = (int)dmap->x_source_end - (int)dmap->x_source_start + 1;
X  signal_h = 2*((int)dmap->y_source_end - (int)dmap->y_source_start + 1);
X  
X  if(area->height <= signal_h/2 && area->height > signal_h/4) adjustment = 2;
X  else adjustment = 3;
X  
X  if ( area->vertical_flip )
X    {
X      dmap->fb_pitch = -this->fb_pitch;
X      y_offset = this->fb_pitch * 
X	((area->top+area->height) + adjustment);
X    }
X  else
X    {
X      dmap->fb_pitch = this->fb_pitch;
X      y_offset = this->fb_pitch * (area->top - adjustment);
X    }
X  if ( area->horizontal_flip )
X    {
X      dmap->control_status2 |= TCP_CSR2_COUNT_DOWN;
X      x_offset = area->left + area->width;
X    }
X  else
X    {
X      dmap->control_status2 &= ~TCP_CSR2_COUNT_DOWN;
X      x_offset = area->left;
X    }
X  dmap->pip_start_offset = (u_long)(x_offset + y_offset);
X  
X  /*  
X   *  Calculate mask for x size and load it in.
X   */
X  x_size = tcl_x_size_mask(signal_w, area->width);
X  dmap->x_source_scale = x_size;
X  
X
X    /*  
X     *	Calculate mask for y size and load it in. Note that single field
X     *  mode is used if the output height is less than or equal to half the
X     *  signal height.
X     */
X    if ( area->height <= signal_h/2 )
X    {
X        dmap->control_status1 |= TCP_CSR1_FIELD_ONLY;
X        y_size = tcl_y_size_mask(signal_h, 2*area->height);
X    }
X    else
X    {
X        dmap->control_status1 &= ~TCP_CSR1_FIELD_ONLY;
X        y_size = tcl_y_size_mask(signal_h, area->height);
X    }
X    dmap->y_source_scale = y_size;
X 
X	(*this->trvec.resume)(this);
X}
X
X/*"tcl_set_source_area"
X *
X *  Set the size of the rectangle for the signal input area.
X */
Xstatic void tcl_set_source_area(this, signal) 
X    Pip_Object     *this;      /* -> control block for this xv instance. */
X    Pip_Src_Area   *signal;    /* -> new signal input area. */ 
X{
X    Tc1_Device_Map  *dmap;  /* Device register area pointer. */
X
X	(*this->trvec.suspend)(this);
X
X    dmap = (Tc1_Device_Map *)this->mmap_obj->device_regs;
X    dmap->x_source_start = signal->left;
X    dmap->x_source_end = signal->left + signal->width;
X    dmap->y_source_start = signal->top / 2;
X    dmap->y_source_end = dmap->y_source_start + signal->height / 2;
X
X	(*this->trvec.resume)(this);
X}
X
X/*"tcl_set_source_type"
X *
X *  Set the type and timing of source being used. This involves programming
X *  of the pip register values. Only reprogram if there is a change.
X *  A value of -1 in any of the fields of "source" indicates the current
X *  setting should be used.
X */
Xstatic void tcl_set_source_type(this, source)
X    Pip_Object *this;      /* -> pip object. */
X    Pip_Source *source;    /* -> source specification. */
X{
X    int             brightness; /* Brightness setting to load. */
X    Tc1_Device_Map  *dmap;      /* Device area pointer. */
X    int             contrast;   /* Contrast setting to load. */
X    u_int           csr0;       /* Contents of control status register 0. */
X	Pip_Fb_Type		host_fb;	/* Frame buffer type. */
X    u_char          *port;      /* I2C bus port address. */
X
X#define SRC_MSK \
X	~(TCP_CSR0_TURN_PIP_ON|TCP_CSR0_PIP_ONE_SHOT|TCP_CSR0_SOURCE_TYPE_MASK) 
X
X	(*this->trvec.suspend)(this);
X	dmap = (Tc1_Device_Map *)this->mmap_obj->device_regs;
X
X    if ( source->timing != this->source.timing && source->timing != -1 )
X    {
X		host_fb.pitch = this->fb_pitch;
X		host_fb.frequency = -1;
X		(*this->trvec.initialize)( this, source, &host_fb );
X		this->source.timing = source->timing;
X	}
X
X	if ( source->vtr_mode != this->source.vtr_mode && source->vtr_mode != -1 )
X	{
X		this->source.vtr_mode = source->vtr_mode;
X		if (source->vtr_mode) dmap->control_status2 |= TCP_CSR2_ALTERNATE_PLL;
X		else 				  dmap->control_status2 &= ~TCP_CSR2_ALTERNATE_PLL;
X	}
X
X	if ( source->fields_inverted != this->source.fields_inverted && 
X		 source->fields_inverted != -1 )
X	{
X		this->source.fields_inverted = source->fields_inverted;
X		if ( source->fields_inverted ) 
X			dmap->control_status2 |= TCP_CSR2_FIELD_INVERT;
X		else 				  
X			dmap->control_status2 &= ~TCP_CSR2_FIELD_INVERT;
X	}
X
X	if ( source->type == this->source.type || source->type == -1 )
X	{
X		(*this->trvec.resume)(this);
X		return;
X	}
X	this->source.type = source->type;
X	csr0 = dmap->control_status;
X	switch( source->type )
X	{
X	  case PS_COMPOSITE:
X		dmap->control_status = TCP_CSR0_COMPOSITE_SOURCE | (csr0 & SRC_MSK);
X		brightness = this->tcl.pip_init_record.brightness;
X		contrast = this->tcl.pip_init_record.contrast;
X		break;
X	  case PS_RGB:
X		dmap->control_status = TCP_CSR0_RGB_SOURCE | (csr0 & SRC_MSK);
X		brightness = this->tcl.pip_init_record.rgb_brightness;
X		contrast = this->tcl.pip_init_record.rgb_contrast;
X		break;
X	  case PS_S_VIDEO:
X		dmap->control_status = TCP_CSR0_S_VIDEO_SOURCE | (csr0 & SRC_MSK);
X		brightness = this->tcl.pip_init_record.brightness;
X		contrast = this->tcl.pip_init_record.contrast;
X		break;
X	}
X	port = &dmap->control_status1;
X	if ( !i2c_write(port, I2C_ADDR_DACS, I2C_BRIGHTNESS, brightness) )
X	{
X		printf("tcl_source: failed to write brightness correctly\n");
X	}
X	if ( !i2c_write(port, I2C_ADDR_DACS, I2C_CONTRAST, contrast) )
X	{
X		printf("tcl_source: failed to write contrast correctly\n");
X	}
X
X	(*this->trvec.resume)(this);
X#undef SRC_MSK
X}
X
X/*"tcl_status"
X *
X *  Return current status of pip operation.
X */
Xstatic void tcl_status(this, status)
X    Pip_Object *this;   /* -> pip object. */
X	Pip_Status *status;	/* -> where to place status. */
X{
X	Tc1_Device_Map	*dmap;	/* Device register area. */
X
X	dmap = (Tc1_Device_Map *)this->mmap_obj->device_regs;
X
X	status->active_source = 
X		(dmap->control_status1 & TCP_CSR1_INPUT_CONNECTED) ? 1 : 0;
X	status->pip_generating = 
X		(dmap->control_status & TCP_CSR0_PIP_IS_ACTIVE) ? 1 : 0;
X	status->pip_on =
X		(dmap->control_status & TCP_CSR0_PIP_IS_ON) ? 1 : 0;
X}
X
X/*"tcl_suspend"
X *
X *  Push the pip to an off state, if it was on at the time of the push, wait
X *  for it to turn off. Each call to this routine must have a corresponding
X *  call to (*this->trvec.resume) (or a forced on via the PIPIO_S_LIVE, 1 ioctl.)
X *
X *      = 1 if pip was on at time of suspend
X *      = 0 if pip was off at time of suspend
X */
Xstatic int tcl_suspend(this)
X    Pip_Object *this;      /* -> control block for this xv instance. */
X{
X    int original_state;     /* State of pip when called kernel driver to turn it off. */
X
X    ioctl(this->fd, PIPIO_G_PIP_ON_OFF_SUSPEND, &original_state);
X    if ( original_state)
X    {
X        usleep(33333);
X    }
X
X    return original_state;
X}
X
X/*"tcl_terminate"
X *
X *	Terminate operations of PIP object, freeing its storage.
X */
Xstatic void tcl_terminate(this)
X	Pip_Object	*this;	/* -> object to terminate. */
X{
X	(*this->trvec.off)(this, 1);
X	free(this);
X}
X
X#ifdef original
X
X/*"tcl_x_size_mask"
X *
X *	Calculate the mask value for the pip x size register that will produce a 
X *  proper-sized viewing image, given the size of the video signal image. The 
X *  sizing mechanism is implemented with a rate multiplier, each bit in the mask 
X *  reduces the original image by one over a power of two (i.e. 1/2, 1/4, 1/8, 
X *  1/16, etc.)
X *
X *		= mask value to use
X */
Xtcl_x_size_mask(signal, view)
X    int signal;	/* = current size of signal image in pixels in x direction. */
X    int view;	/* = desired size of viewing image in pixels in x direction. */
X{
X    int bit;	/* Index: bit of mask now setting. */
X    int mask;	/* Mask value to return to our caller. */
X
X	/*	Loop through bits of mask setting them to zero or one. If the viewing 
X	 *  area is larger than the signal area associated with a bit set the bit to 
X	 *  one and reduce the viewing area by that value. Otherwise set the bit to 
X	 *  zero.
X	 */
X    for (bit = 0, mask = 0; bit < 10 && view > 0; bit++, mask <<= 1)
X    {
X        signal /= 2;
X        if ( view >= signal )
X        {
X            mask |= 1;
X            view -= signal;
X        }
X    }
X
X	/*	Set any remaining bits to one. Then shift the mask down by one, since we 
X	 *	shifted it up one too many times in this process.
X	 */
X	for (; bit < 10; bit++, mask <<= 1)
X	{
X		/*mask |= 1;*/
X	}
X    return mask >> 1;
X}
X
X/*"tcl_y_size_mask"
X *
X *	Calculate the mask value for the pip y size register that will produce a 
X *  proper-sized viewing image, given the size of the video signal image. The 
X *  sizing mechanism is implemented with a rate multiplier, each bit in the mask 
X *  reduces the original image by one over a power of two (i.e. 1/2, 1/4, 1/8, 
X *  1/16, etc.)
X *
X *		= mask value to use
X */
Xtcl_y_size_mask(signal, view)
X    int signal;	/* = current size of signal image in pixels in y direction. */
X    int view;	/* = desired size of viewing image in pixels in y direction. */
X{
X    int bit;	/* Index: bit of mask now setting. */
X    int mask;	/* Mask value to return to our caller. */
X
X	/*	Start values at half their size since scan line pairs are dropped, 
X	 *  not pixels.
X	 */
X	signal /= 2;
X	view /= 2;
X
X	/*	Loop through bits of mask setting them to zero or one. If the viewing 
X	 *  area is larger than the signal area associated with a bit set the bit to 
X	 *  one and reduce the viewing area by that value. Otherwise set the bit to 
X	 *  zero.
X	 */
X    for (bit = 0, mask = 0; bit < 9 && view > 0; bit++, mask <<= 1)
X    {
X        signal /= 2;
X        if ( view >= signal )
X        {
X            mask |= 1;
X            view -= signal;
X        }
X    }
X
X	/*	Set any remaining bits to one. Then shift the mask down by one, since we 
X	 *  shifted it up one too many times in this process.
X	 */
X	mask <<= (9-bit);
X    return mask >> 1;
X}
X#else original
X
Xint
Xtcl_x_size_mask(signal, view)
X        int signal, view;
X{
X# define PIP_X_SCALE_REG_BITS   10
X
X# define PIP_X_OVERRUN_SLOP     1
X
X        if (view < signal)
X                view -= PIP_X_OVERRUN_SLOP;
X
X        return compute_scale_reg(view, PIP_X_SCALE_REG_BITS, signal);
X}
X
Xint
Xtcl_y_size_mask(signal, view)
X        int signal, view;
X{
X# define PIP_Y_SCALE_REG_BITS   9
X/*
X# define PIP_Y_OVERRUN_SLOP     2
X        if (view < signal)
X                view -= PIP_Y_OVERRUN_SLOP;
X */
X        /* y scale reg refers to line pairs */
X        return compute_scale_reg(view/2, PIP_Y_SCALE_REG_BITS, signal/2);
X}
X/*
X * compute_scale_reg --
X * Given a size q, find a PIP scaling register value
X * to enable exactly q out of M (horizontal or vertical)
X * lines in the picture.
X *
X * The lines of the picture are numbered from [0..M-1].
X * The bits of the scaling register are numbered from [1..Mbits].
X * Each bit of the scaling register enables a (disjoint)
X * subset of lines in the picture.  The n-th bit enables
X * lines with numbers L_i = A_n/2 - 1 + i*A_n, where A_n = 2^n,
X * and i is any non-negative integer such that L_i < M.
X * Rearranging, we find
X *      i < (M-A_n/2+1)/A_n
X * so the number of L_i's in the n-th set is
X *      ceil((M-A/2+1)/A) = floor((M+A/2)/A)
X * since A_n is always a power of 2, the division may be accomplished
X * using shifts.
X */
Xint
Xcompute_scale_reg(q, Mbits, M)
X        int q; int Mbits; int M;
X{
X# define subsetsize(n, M)       (((M) + (1<<((n)-1))) >> (n))
X        int mask; int n; int s;
X
X        mask = 0;
X        for (n = 1; n <= Mbits; n++)
X                if ((s = subsetsize(n, M)) <= q)
X                        { mask |= 1<<(Mbits-n); q -= s; }
X        /* NOTE: q should always be 0 here unless q > M originally */
X        return mask;
X}
X
X#endif original
X
X/*"xv_tcl_open"
X *
X *	Open a pip connected to a tcl card as a X video extension
X *	device.
X *
X *		-> X video extension control block
X *		=  0 if failure
X */
XPip_Object *xv_tcl_open( fd, mmobj )
X	int			fd;		/* =  file descriptor for the device. */
X	Mmap_Obj	*mmobj;	/* -> memory map object or 0. */
X{
X	Pipio_Fb_Info fb_info;		/* Where to put frame buffer info. */
X	Pip_Fb_Type	  host_fb;		/* Host frame buffer type (this buffer!). */
X	int			  pgi;			/* Index: next plane group to look at. */
X	int			  pip_size;		/* Size of memory map or zero. */
X	int			  pip_offset;	/* Offset for memory mapping. */
X	Pip_Source	  source;		/* Type of source to initialize to. */
X	Pip_Object	  *this;		/* X video extension instance cb. */
X
X	/*
X	 *	Allocate pip object and fill in its transfer vector.
X	 */
X	if ( !(this = (Pip_Object *)malloc(sizeof(Pip_Object))) )
X	{
X		printf("xv_tcl_open: unable to allocate storage!!!\n");
X		return 0;
X	}
X	this->fd = fd;
X	this->trvec.fill_true_color = tcl_fill_true_color;
X	this->trvec.fill_video_enable = tcl_fill_video_enable;
X	this->trvec.get_levels = tcl_get_levels;
X	this->trvec.get_destination_area = tcl_get_destination_area;
X	this->trvec.get_source_area = tcl_get_source_area;
X	this->trvec.get_source_type = tcl_get_source_type;
X	this->trvec.initialize = tcl_init;
X	this->trvec.off = tcl_off;
X	this->trvec.on = tcl_on;
X	this->trvec.one_shot = tcl_one_shot;
X	this->trvec.resume = tcl_resume;
X	this->trvec.set_levels = tcl_set_levels;
X	this->trvec.set_destination_area = tcl_set_destination_area;
X	this->trvec.set_source_area = tcl_set_source_area;
X	this->trvec.set_source_type = tcl_set_source_type;
X	this->trvec.status = tcl_status;
X	this->trvec.suspend = tcl_suspend;
X	this->trvec.terminate = tcl_terminate;
X
X	/*
X	 *  Memory map the pip device. If a memory map object was passed in
X	 *	make sure the device area is included in the mapping. Otherwise
X	 *	call mmap_pip to perform that mapping. Then initialize the pip object.
X	 */
X	if ( mmobj )
X	{
X	  this->mmap_obj = mmobj;
X	  mmap_add_devices( mmobj );
X	}
X	else
X	{
X	  this->mmap_obj = (Mmap_Obj *)mmap_pip(fd);
X	  if (!this->mmap_obj->video_enable)
X	    {
X	      free(this);
X	      return 0;
X	    }
X	}
X
X/* DCC MOD --- DO INITIALIZATION SEPARATELY SO THAT WE CAN SELECT TIMING 
X   AND TYPE */
X
X#ifdef original 
X	source.timing = PT_NTSC;
X	source.type = PS_COMPOSITE;
X	source.fields_inverted = 0;
X	source.vtr_mode = 0;
X	host_fb.pitch = 1152;
X	host_fb.frequency = -1;
X	(*this->trvec.initialize)(this, &source, &host_fb);
X#endif
X	return this;
X}
END_OF_FILE
if test 42298 -ne `wc -c <'extensions/xv/server/ddx/sunrop/pip_tcl.c'`; then
    echo shar: \"'extensions/xv/server/ddx/sunrop/pip_tcl.c'\" unpacked with wrong size!
fi
# end of 'extensions/xv/server/ddx/sunrop/pip_tcl.c'
fi
if test -f 'lib/X/XErrorDB' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib/X/XErrorDB'\"
else
echo shar: Extracting \"'lib/X/XErrorDB'\" \(9502 characters\)
sed "s/^X//" >'lib/X/XErrorDB' <<'END_OF_FILE'
X! these are used in XGetErrorMessage.
XXlibMessage.XError: X Error of failed request
XXlibMessage.MajorCode: Major opcode of failed request:  %d
XXlibMessage.MinorCode: Minor opcode of failed request:  %d
XXlibMessage.ResourceID: Resource id in failed request:  0x%lx
XXlibMessage.Value: Value in failed request:  0x%lx
XXlibMessage.AtomID: Atom id in failed request:  0x%lx
XXlibMessage.ErrorSerial: Serial number of failed request:  %lu
XXlibMessage.CurrentSerial: Current serial number in output stream:  %lu
X! X request codes.
XXRequest.1:X_CreateWindow
XXRequest.2:X_ChangeWindowAttributes
XXRequest.3:X_GetWindowAttributes
XXRequest.4:X_DestroyWindow
XXRequest.5:X_DestroySubwindows
XXRequest.6:X_ChangeSaveSet
XXRequest.7:X_ReparentWindow
XXRequest.8:X_MapWindow
XXRequest.9:X_MapSubwindows
XXRequest.10:X_UnmapWindow
XXRequest.11:X_UnmapSubwindows
XXRequest.12:X_ConfigureWindow
XXRequest.13:X_CirculateWindow
XXRequest.14:X_GetGeometry
XXRequest.15:X_QueryTree
XXRequest.16:X_InternAtom
XXRequest.17:X_GetAtomName
XXRequest.18:X_ChangeProperty
XXRequest.19:X_DeleteProperty
XXRequest.20:X_GetProperty
XXRequest.21:X_ListProperties
XXRequest.22:X_SetSelectionOwner
XXRequest.23:X_GetSelectionOwner
XXRequest.24:X_ConvertSelection
XXRequest.25:X_SendEvent
XXRequest.26:X_GrabPointer
XXRequest.27:X_UngrabPointer
XXRequest.28:X_GrabButton
XXRequest.29:X_UngrabButton
XXRequest.30:X_ChangeActivePointerGrab
XXRequest.31:X_GrabKeyboard
XXRequest.32:X_UngrabKeyboard
XXRequest.33:X_GrabKey
XXRequest.34:X_UngrabKey
XXRequest.35:X_AllowEvents
XXRequest.36:X_GrabServer
XXRequest.37:X_UngrabServer
XXRequest.38:X_QueryPointer
XXRequest.39:X_GetMotionEvents
XXRequest.40:X_TranslateCoords
XXRequest.41:X_WarpPointer
XXRequest.42:X_SetInputFocus
XXRequest.43:X_GetInputFocus
XXRequest.44:X_QueryKeymap
XXRequest.45:X_OpenFont
XXRequest.46:X_CloseFont
XXRequest.47:X_QueryFont
XXRequest.48:X_QueryTextExtents
XXRequest.49:X_ListFonts
XXRequest.50:X_ListFontsWithInfo
XXRequest.51:X_SetFontPath
XXRequest.52:X_GetFontPath
XXRequest.53:X_CreatePixmap
XXRequest.54:X_FreePixmap
XXRequest.55:X_CreateGC
XXRequest.56:X_ChangeGC
XXRequest.57:X_CopyGC
XXRequest.58:X_SetDashes
XXRequest.59:X_SetClipRectangles
XXRequest.60:X_FreeGC
XXRequest.61:X_ClearArea
XXRequest.62:X_CopyArea
XXRequest.63:X_CopyPlane
XXRequest.64:X_PolyPoint
XXRequest.65:X_PolyLine
XXRequest.66:X_PolySegment
XXRequest.67:X_PolyRectangle
XXRequest.68:X_PolyArc
XXRequest.69:X_FillPoly
XXRequest.70:X_PolyFillRectangle
XXRequest.71:X_PolyFillArc
XXRequest.72:X_PutImage
XXRequest.73:X_GetImage
XXRequest.74:X_PolyText8
XXRequest.75:X_PolyText16
XXRequest.76:X_ImageText8
XXRequest.77:X_ImageText16
XXRequest.78:X_CreateColormap
XXRequest.79:X_FreeColormap
XXRequest.80:X_CopyColormapAndFree
XXRequest.81:X_InstallColormap
XXRequest.82:X_UninstallColormap
XXRequest.83:X_ListInstalledColormaps
XXRequest.84:X_AllocColor
XXRequest.85:X_AllocNamedColor
XXRequest.86:X_AllocColorCells
XXRequest.87:X_AllocColorPlanes
XXRequest.88:X_FreeColors
XXRequest.89:X_StoreColors
XXRequest.90:X_StoreNamedColor
XXRequest.91:X_QueryColors
XXRequest.92:X_LookupColor
XXRequest.93:X_CreateCursor
XXRequest.94:X_CreateGlyphCursor
XXRequest.95:X_FreeCursor
XXRequest.96:X_RecolorCursor
XXRequest.97:X_QueryBestSize
XXRequest.98:X_QueryExtension
XXRequest.99:X_ListExtensions
XXRequest.100:X_ChangeKeyboardMapping
XXRequest.101:X_GetKeyboardMapping
XXRequest.102:X_ChangeKeyboardControl
XXRequest.103:X_GetKeyboardControl
XXRequest.104:X_Bell
XXRequest.105:X_ChangePointerControl
XXRequest.106:X_GetPointerControl
XXRequest.107:X_SetScreenSaver
XXRequest.108:X_GetScreenSaver
XXRequest.109:X_ChangeHosts
XXRequest.110:X_ListHosts
XXRequest.111:X_SetAccessControl
XXRequest.112:X_SetCloseDownMode
XXRequest.113:X_KillClient
XXRequest.114:X_RotateProperties
XXRequest.115:X_ForceScreenSaver
XXRequest.116:X_SetPointerMapping
XXRequest.117:X_GetPointerMapping
XXRequest.118:X_SetModifierMapping
XXRequest.119:X_GetModifierMapping
XXRequest.127:X_NoOperation
X! X Error Codes
XXProtoError.0: unknown error code 0
XXProtoError.1: BadRequest (invalid request code or no such operation)
XXProtoError.2: BadValue (integer parameter out of range for operation)
XXProtoError.3: BadWindow (invalid Window parameter)
XXProtoError.4: BadPixmap (invalid Pixmap parameter)
XXProtoError.5: BadAtom (invalid Atom parameter)
XXProtoError.6: BadCursor (invalid Cursor parameter)
XXProtoError.7: BadFont (invalid Font parameter)
XXProtoError.8: BadMatch (invalid parameter attributes)
XXProtoError.9: BadDrawable (invalid Pixmap or Window parameter)
XXProtoError.10: BadAccess (attempt to access private resource denied)
XXProtoError.11: BadAlloc (insufficient resources for operation)
XXProtoError.12: BadColor (invalid Colormap parameter)
XXProtoError.13: BadGC (invalid GC parameter)
XXProtoError.14: BadIDChoice (invalid resource ID chosen for this connection)
XXProtoError.15: BadName (named color or font does not exist)
XXProtoError.16: BadLength (poly request too large or internal Xlib length error)
XXProtoError.17: BadImplementation (server does not implement operation)
X! Multi-Buffering extension, a draft X Consortium standard
XXRequest.Multi-Buffering.0: X_MbufGetBufferVersion
XXRequest.Multi-Buffering.1: X_MbufCreateImageBuffers
XXRequest.Multi-Buffering.2: X_MbufDestroyImageBuffers
XXRequest.Multi-Buffering.3: X_MbufDisplayImageBuffers
XXRequest.Multi-Buffering.4: X_MbufSetMultiBufferAttributes
XXRequest.Multi-Buffering.5: X_MbufGetMultiBufferAttributes
XXRequest.Multi-Buffering.6: X_MbufSetBufferAttributes
XXRequest.Multi-Buffering.7: X_MbufGetBufferAttributes
XXRequest.Multi-Buffering.8: X_MbufGetBufferInfo
XXRequest.Multi-Buffering.9: X_MbufCreateStereoWindow
XXProtoError.Multi-Buffering.0: BadBuffer (invalid Buffer parameter)
XXlibMessage.Multi-Buffering.0: Buffer id in failed request 0x%lx
X! SHAPE extension, an X Consortium standard
XXRequest.SHAPE.0: X_ShapeQueryVersion
XXRequest.SHAPE.1: X_ShapeRectangles
XXRequest.SHAPE.2: X_ShapeMask
XXRequest.SHAPE.3: X_ShapeCombine
XXRequest.SHAPE.4: X_ShapeOffset
XXRequest.SHAPE.5: X_ShapeQueryExtents
XXRequest.SHAPE.6: X_ShapeSelectInput
XXRequest.SHAPE.7: X_ShapeInputSelected
XXRequest.SHAPE.8: X_ShapeGetRectangles
X! Input extension, a draft X Consortium standard
XXRequest.XInputExtension.1:X_GetExtensionVersion
XXRequest.XInputExtension.2:X_ListInputDevices
XXRequest.XInputExtension.3:X_OpenDevice
XXRequest.XInputExtension.4:X_CloseDevice
XXRequest.XInputExtension.5:X_SetDeviceMode
XXRequest.XInputExtension.6:X_SelectExtensionEvent
XXRequest.XInputExtension.7:X_GetSelectedExtensionEvents
XXRequest.XInputExtension.8:X_ChangeDeviceDontPropagateList
XXRequest.XInputExtension.9:X_GetDeviceDontPropagateList
XXRequest.XInputExtension.10:X_GetDeviceMotionEvents
XXRequest.XInputExtension.11:X_ChangeKeyboardDevice
XXRequest.XInputExtension.12:X_ChangePointerDevice
XXRequest.XInputExtension.13:X_GrabDevice
XXRequest.XInputExtension.14:X_UngrabDevice
XXRequest.XInputExtension.15:X_GrabDeviceKey
XXRequest.XInputExtension.16:X_UngrabDeviceKey
XXRequest.XInputExtension.17:X_GrabDeviceButton
XXRequest.XInputExtension.18:X_UngrabDeviceButton
XXRequest.XInputExtension.19:X_AllowDeviceEvents
XXRequest.XInputExtension.20:X_GetDeviceFocus
XXRequest.XInputExtension.21:X_SetDeviceFocus
XXRequest.XInputExtension.22:X_GetFeedbackControl
XXRequest.XInputExtension.23:X_ChangeFeedbackControl
XXRequest.XInputExtension.24:X_GetDeviceKeyMapping
XXRequest.XInputExtension.25:X_ChangeDeviceKeyMapping
XXRequest.XInputExtension.26:X_GetDeviceModifierMapping
XXRequest.XInputExtension.27:X_SetDeviceModifierMapping
XXRequest.XInputExtension.28:X_GetDeviceButtonMapping
XXRequest.XInputExtension.29:X_SetDeviceButtonMapping
XXRequest.XInputExtension.30:X_QueryDeviceState
XXRequest.XInputExtension.31:X_SendExtensionEvent
XXRequest.XInputExtension.32:X_DeviceBell
XXRequest.XInputExtension.33:X_SetDeviceValuators
XXRequest.XInputExtension.34:X_GetDeviceControl
XXRequest.XInputExtension.35:X_ChangeDeviceControl
X! MIT-SHM extension, experimental, not an X Consortium standard
XXRequest.MIT-SHM.0: X_ShmQueryVersion
XXRequest.MIT-SHM.1: X_ShmAttach
XXRequest.MIT-SHM.2: X_ShmDetach
XXRequest.MIT-SHM.3: X_ShmPutImage
XXRequest.MIT-SHM.4: X_ShmGetImage
XXRequest.MIT-SHM.5: X_ShmCreatePixmap
XXProtoError.MIT-SHM.0: BadShmSeg (invalid shared segment parameter)
XXlibMessage.MIT-SHM.0: Segment id in failed request 0x%lx
X! XVideo extension, not yet an X Consortium standard
XXRequest.XVideo.0: X_XvQueryExtension                  
XXRequest.XVideo.1: X_XvQueryAdaptors                   
XXRequest.XVideo.2: X_XvQueryEncodings                  
XXRequest.XVideo.3: X_XvGrabPort                        
XXRequest.XVideo.4: X_XvUngrabPort                      
XXRequest.XVideo.5: X_XvPutVideo                        
XXRequest.XVideo.6: X_XvPutStill                        
XXRequest.XVideo.7: X_XvGetVideo                        
XXRequest.XVideo.8: X_XvGetStill                        
XXRequest.XVideo.9: X_XvStopVideo                       
XXRequest.XVideo.10: X_XvSelectVideoNotify              
XXRequest.XVideo.11: X_XvSelectPortNotify               
XXRequest.XVideo.12: X_XvQueryBestSize                  
XXRequest.XVideo.13: X_XvSetPortAttribute               
XXRequest.XVideo.14: X_XvGetPortAttribute               
XXProtoError.XVideo.0: Port (invalid Port parameter)
XXlibMessage.XVideo.0: Port id in failed request 0x%lx
XXProtoError.XVideo.1: Encoding (invalid Encoding parameter)
XXlibMessage.XVideo.1: Encoding id in failed request 0x%lx
X! MIT-SUNDRY-NONSTANDARD extension, definitely not an X Consortium standard
XXRequest.MIT-SUNDRY-NONSTANDARD.0: X_MITSetBugMode
XXRequest.MIT-SUNDRY-NONSTANDARD.1: X_MITGetBugMode
X
END_OF_FILE
if test 9502 -ne `wc -c <'lib/X/XErrorDB'`; then
    echo shar: \"'lib/X/XErrorDB'\" unpacked with wrong size!
fi
# end of 'lib/X/XErrorDB'
fi
echo shar: End of archive 7 \(of 29\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 29 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Molecular Simulations, Inc.             mail: dcmartin@msi.com
796 N. Pastoria Avenue                  uucp: uunet!dcmartin
Sunnyvale, California 94086             at&t: 408/522-9236
