Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: dcc@Athena.MIT.EDU (David Carver)
Newsgroups: comp.sources.x
Subject: v16i067: Video Extension for X (v2r2), Part16/29
Message-ID: <1992Feb6.145726.608@msi.com>
Date: 6 Feb 92 14:57:26 GMT
References: <csx-16i052-vex.v2r2@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 2543
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: dcc@Athena.MIT.EDU (David Carver)
Posting-number: Volume 16, Issue 67
Archive-name: vex.v2r2/part16

# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
#		"End of archive 16 (of 29)."
# Contents:  extensions/xv/doc/xv-lib-v2.PS.aa
#   extensions/xv/test/xvt1.c extensions/xv/test/xvt6.c
#   server/ddx/cfb32/cfbteblt8.c
# Wrapped by dcmartin@fascet on Thu Feb  6 06:52:47 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'extensions/xv/doc/xv-lib-v2.PS.aa' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extensions/xv/doc/xv-lib-v2.PS.aa'\"
else
echo shar: Extracting \"'extensions/xv/doc/xv-lib-v2.PS.aa'\" \(14747 characters\)
sed "s/^X//" >'extensions/xv/doc/xv-lib-v2.PS.aa' <<'END_OF_FILE'
X%!PS-Adobe-1.0
X%%Creator: devps (Pipeline Associates, Inc.)
X%%CreationDate: Wed Jul 17 14:26:40 1991
X%%Pages: (atend)
X%%DocumentFonts: (atend)
X
X/X{exch}def
X/r{rmoveto}def
X/m{moveto}def
X/l{lineto}def
X/rl{rlineto}def
X/lc{yc X xc X l st}def
X/mc{yc X xc X m}def
X/el{gs /a X def a div 1 X scale cp np a xc 2 div 0 360 arc st gr}def
X/ar{cp 7 2 roll np xc 5 1 roll atan 3 1 roll atan X arc st}def
X/sp{yc X xc X 6 2 roll yc X xc X 6 2 roll yc X xc X 6 2 roll ct}def
X/st{stroke}def
X/gs{gsave}def
X/gr{grestore}def
X/cp{currentpoint}def
X/np{newpath}def
X/ct{curveto}def
X/m0{0 0 moveto}def
X/BP{/devps-save save def m0}def
X/EP{
Xclear devps-save restore
Xshowpage}def
X/res 10.000000 def
X/V{res neg div 792 add
Xcurrentpoint pop X
Xm}def
X/H{res div
Xcurrentpoint X pop
Xmoveto}def
X/h{res div 0 r}def
X/v{res neg div 0 X r}def
X/xc{res div}def
X/yc{res neg div 792 add}def
X/S{X H show}def
X/psize 10 def
X/height 1 def
X/slant 0 def
X/FF{findfont X dup 12 div setlinewidth /psize X def
X    [psize 0 psize height mul slant sin slant cos div mul psize height mul 0 0]
X    makefont setfont}def
X/shade{gs
X /dy X def
X /dx X def
X np m
X setgray
X 0 dy rl
X dx 0 rl
X 0 dy neg rl
X dx neg 0 rl
X closepath
X fill
Xgr}def
X1 setlinecap
X/R{/Times-Roman FF}def
X/B{/Times-Bold FF}def
X/TB{/Helvetica-Bold FF}def
X/HB{/Helvetica-Bold FF}def
X/I{/Times-Italic FF}def
X/C{/Courier FF}def
X%% Troff special characters not on Symbol font
X%% Copyright (C) 1986 by Pipeline Associates, Inc.
X%% Version 1.1
X/altRTD 20 dict def
XaltRTD begin
X/s{setcachedevice}def
X/C{1000 1000 scale}def
X/m{moveto}def
X/c{curveto}def
X/S{stroke}def
X/l{lineto}def
X/a{arcto}def
X/p{pop}def
X/sl{setlinewidth}def
Xend
X/F_Troff 17 dict def F_Troff begin
Xsystemdict /currentpacking known
X{/SavePacking currentpacking def true setpacking}if
X/PaintType 0 def
X/FontType 3 def
X/StrokeWidth 0 def
X/UniqueID 8277003 def
X/FontMatrix [.001000 0 0 .001000 0 0] def
X/FontBBox [-12 -105 942 855 ] def
X/Encoding 256 array def
X/CD 256 1 add dict def
X/FontInfo 3 dict def FontInfo begin
X/UnderlinePosition -133 def /UnderlineThickness 20 def end
X/FontName (Troff) def
X0 1 256 1 sub{Encoding exch /.notdef put}for
XCD /.notdef{500 0 setcharwidth{}}put
XEncoding (1) 0 get /br put
X%% bold vertical rule used by tbl
XCD /br{
XC
X0 0 -.5 -.5 1 1 s
Xnp
X.05 sl
X0 -.1 m
X0 .9 l
X{S}
X}put
XEncoding (2) 0 get /ul put
X%% underline used by tbl
XCD /ul{
XC
X.5 0 -.5 -.5 1 1 s
Xnp
X.05 sl
X0 -.1 m
X.5 -.1 l
X{S}
X}put
XEncoding (3) 0 get /ru put
X%% baseline rule
XCD /ru{
XC
X.5 0 -.5 -.5 1 1 s
Xnp
X.05 sl
Xm0
X.5 0 l
X{S}
X}put
XEncoding (4) 0 get /vr put
X%% vertical rule
XCD /vr{
XC
X0 0 -.5 -.5 1 1 s
Xnp
X.05 sl
Xm0
X0 1 l
X{S}
X}put
XEncoding (5) 0 get /sq put
X%% square
XCD /sq{
XC
X.5 0 -.5 -.5 1 1 s
Xnp
X.05 sl
X0 .25 m
X0 .5 rl
X.5 0 rl
X0 -.5 rl
X-.5 0 rl
Xclosepath
X{S}
X}put
XEncoding (6) 0 get /bx put
X%% solid box
XCD /bx{
XC
X.5 0 -.5 -.5 1 1 s
Xnp
X0 .25 m
X0 .5 rl
X.5 0 rl
X0 -.5 rl
X-.5 0 rl
Xclosepath
X{fill}
X}put
XEncoding (7) 0 get /rn put
X%% radical extender
XCD /rn{
XC
X.5 0 -.5 -.5 1 1 s
Xnp
X.03 sl
X-.03 .9 m
X.5 0 rl
X{S}
X}put
XEncoding (8) 0 get /GR put
X%% gray mask
XCD /GR{
XC
X.5 0 setcharwidth
X.5 setgray
Xnp
X0 -.1 m
X0 1 rl
X.5 0 rl
X0 -1 rl
X-.5 0 rl
Xclosepath
X{fill}
X}put
XEncoding 97 /a put
XCD /a{1000 0 0 66 942 421 s 430 415
Xm 578 406 678 349 662 319 c 655 306 614 287 583
X296 c 570 300 466 340 438 332 c 365 309 335 213
X270 209 c 0 310 m 108 310 l 108 114 l 0
X114 l 0 310 l 42 161 m 42 134 l 66 134 l 66
X161 l 42 161 l 47 155 m 47 140 l 62 140 l 62
X155 l 47 155 l 110 133 m 226 113 300 66 410
X80 c 497 91 550 69 634 76 c 645 76 663 92 669
X107 c 677 125 673 141 668 160 c 725 334 m 758
X332 734 253 701 250 c 501 325 m 475 316 476 309
X473 302 c 465 282 482 263 499 257 c 552 236 615
X253 689 253 c 701 253 713 236 713 218 c 712 194
X702 168 678 161 c 671 159 663 160 655 160 c 591
X158 516 156 479 168 c 461 173 453 191 453 210 c 453
X224 456 235 466 244 c 476 253 490 252 503 255 c 459
X84 m 447 96 435 106 435 123 c 435 136 440 145 447
X155 c 453 163 462 168 469 173 c 110 293 m 173
X318 300 421 435 415 c 609 407 852 416 885 411 c 898
X409 924 411 930 380 c 942 316 828 339 742 334 c 731
X334 730 335 725 335 c 701 336 685 336 660 336 c{S}}put
XEncoding 98 /b put
XCD /b{1000 0 -12 66 930 421 s 500
X415 m 352 406 252 349 268 319 c 275 306 316 287
X347 296 c 360 300 464 340 492 332 c 565 309 595
X213 660 209 c 930 310 m 822 310 l 822 114 l 930
X114 l 930 310 l 888 161 m 888 134 l 864 134
Xl 864 161 l 888 161 l 883 155 m 883 140 l 868
X140 l 868 155 l 883 155 l 820 133 m 704 113
X630 66 520 80 c 433 91 380 69 296 76 c 285 76
X267 92 261 107 c 253 125 257 141 262 160 c 205
X334 m 172 332 196 253 229 250 c 429 325 m 455
X316 454 309 457 302 c 465 282 448 263 431 257 c 378
X236 315 253 241 253 c 229 253 217 236 217 218 c 218
X194 228 168 252 161 c 259 159 267 160 275 160 c 339
X158 414 156 451 168 c 469 173 477 191 477 210 c 477
X224 474 235 464 244 c 454 253 440 252 427 255 c 471
X84 m 483 96 495 106 495 123 c 495 136 490 145 483
X155 c 477 163 468 168 461 173 c 820 293 m 757
X318 630 421 495 415 c 321 407 78 416 45 411 c 32
X409 6 411 0 380 c -12 316 102 339 188 334 c 199
X334 200 335 205 335 c 229 336 245 336 270 336 c{S}}put
XEncoding 99 /c put
XCD /c{1000 0 184 0 827 627 s 185 315
Xm 186 488 332 627 505 625 c 682 623 827 467 815
X290 c 804 124 666 0 500 0 c 327 0 184 142 185
X315 c{S}}put
XEncoding 100 /d put
XCD /d{590 0 134 158 477 500 s 300
X160 m 208 162 134 238 135 330 c 136 423 212 500
X305 500 c 397 500 473 427 475 335 c 477 239 396
X158 300 160 c{fill}}put
XEncoding 101 /e put	% Bell Symbol
XCD /e{1010 0 -100 -210 1010 1010 s 100 sl 0 setlinecap
X420 300 450 0 360 arc
X420 650 m 420 575 l S
Xnewpath 120 125 m 720 125 l 75 sl S
X420 125 m 420 25 l S
X220 400 m 220 175 120 175 100 a p p p p
X220 400 m 220 550 420 550 80 a p p p p 
X620 400 m 620 175 720 175 100 a p p p p
X620 400 m 620 550 420 550 80 a p p p p
X295 550 m 545 550 l{S}}put
X/BuildChar{altRTD /BuildChar get exec}def end
XaltRTD begin /BuildChar{altRTD begin
X/char exch def /fontdict exch def save
X/charname fontdict /Encoding get char get def
Xfontdict /StrokeWidth get sl
Xfontdict /CD get dup charname known
X{charname}{/.notdef}ifelse get newpath exec
Xfontdict /PaintType get 0 eq{exec}{p S}ifelse
Xrestore end}def end
Xsystemdict /currentpacking known{F_Troff /SavePacking get setpacking}if
X/Troff F_Troff definefont pop
X/Y1{/Troff FF}def
X/TR{/Helvetica FF}def
X%%EndProlog
X%%Page: 1 1
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 TB
X4966(Xv)S
X5133(\()S
X5193(3X)S
X5360(\))S
X720 H
X1080 V
X9 B
X720(Name)S
X720 H
X1200 V
X10 R
X900(Xv)S
X1052(---)S
X1181(X)S
X1283(Window)S
X1657(System)S
X1982(video)S
X2234(extension)S
X720 H
X1368 V
X9 B
X720(Description)S
X720 H
X1488 V
X10 R
X900(The)S
X1085(Xv)S
X1237(extension)S
X1650(provides)S
X2024(support)S
X2354(for)S
X2500(video)S
X2752(adaptors)S
X3120(attached)S
X3482(to)S
X3590(an)S
X3714(X)S
X3816(display.)S
X4190(It)S
X4281(takes)S
X4516(the)S
X4668(approach)S
X5063(that)S
X5243(a)S
X720 H
X1608 V
X900(display)S
X1219(may)S
X1421(have)S
X1639(one)S
X1813(or)S
X1926(more)S
X2161(video)S
X2413(adaptors,)S
X2806(each)S
X3018(of)S
X3131(which)S
X3405(has)S
X3568(one)S
X3742(or)S
X3855(more)S
X4090(ports)S
X4320(though)S
X4628(which)S
X4902(independent)S
X720 H
X1728 V
X900(video)S
X1152(streams)S
X1487(pass.)S
X720 H
X1896 V
X900(An)S
X1052(adaptor)S
X1381(may)S
X1583(be)S
X1707(able)S
X1903(to)S
X2011(display)S
X2330(video)S
X2582(in)S
X2690(a)S
X2764(drawable,)S
X3184(capture)S
X3507(video)S
X3759(from)S
X3983(a)S
X4057(drawable,)S
X4477(or)S
X4590(both.)S
X4853(It)S
X4944(translates)S
X720 H
X2016 V
X900(between)S
X1262(video)S
X1514(encoding)S
X1910(\(NTSC,)S
X2254(PAL,)S
X2498(SECAM,)S
X2898(etc...\))S
X3152(and)S
X3326(drawable)S
X3721(format)S
X4017(\(depth)S
X4302(and)S
X4476(visual-id)S
X4856(pair\).)S
X5099(An)S
X720 H
X2136 V
X900(adaptor)S
X1229(may)S
X1431(support)S
X1761(multiple)S
X2125(video)S
X2377(encodings)S
X2812(and/or)S
X3097(multiple)S
X3461(drawable)S
X3856(formats.)S
X720 H
X2304 V
X900(Clients)S
X1214(use)S
X1377(Xv\(3X\))S
X1717(to)S
X1825(gain)S
X2027(access)S
X2311(and)S
X2485(manage)S
X2825(sharing)S
X3149(of)S
X3262(a)S
X3336(display's)S
X3727(video)S
X3979(resources.)S
X4440(Typically,)S
X4878(a)S
X4952(client)S
X5204(will)S
X720 H
X2424 V
X900(use)S
X1063(XvQueryExtension\(3X\))S
X2052(to)S
X2160(determine)S
X2589(the)S
X2741(status)S
X2999(of)S
X3112(the)S
X3264(extension,)S
X3702(XvQueryAdaptors\(3X\))S
X4657(to)S
X4765(get)S
X4917(a)S
X4991(descrip-)S
X720 H
X2544 V
X900(tion)S
X1086(of)S
X1199(what)S
X1423(video)S
X1675(adaptors)S
X2043(exist,)S
X2287(and)S
X2461(XvQueryEncodings\(3X\))S
X3472(to)S
X3580(get)S
X3732(a)S
X3806(description)S
X4280(of)S
X4393(what)S
X4617(video)S
X4869(encodings)S
X5304(an)S
X720 H
X2664 V
X900(adaptor)S
X1229(supports.)S
X720 H
X2832 V
X900(Once)S
X1140(a)S
X1214(client)S
X1466(has)S
X1629(determined)S
X2108(what)S
X2332(video)S
X2584(resources)S
X2990(are)S
X3141(available,)S
X3556(it)S
X3642(is)S
X3739(free)S
X3923(to)S
X4031(put)S
X4189(video)S
X4441(into)S
X4627(a)S
X4701(drawable)S
X5096(or)S
X5209(get)S
X720 H
X2952 V
X900(video)S
X1152(from)S
X1376(a)S
X1450(drawable,)S
X1870(according)S
X2293(the)S
X2445(capabilities)S
X2930(supported.)S
X3409(Clients)S
X3723(can)S
X3891(select)S
X4148(to)S
X4256(receive)S
X4573(events)S
X4858(when)S
X5104(video)S
X720 H
X3072 V
X900(activity)S
X1230(changes)S
X1581(in)S
X1689(a)S
X1763(drawable)S
X2158(and)S
X2332(when)S
X2578(port)S
X2769(attributes)S
X3171(have)S
X3389(changed.)S
X720 H
X3240 V
X9 B
X720(Summary)S
X1142(of)S
X1259(Library)S
X1606(Functions)S
X720 H
X3360 V
X10 R
X900(The)S
X1085(following)S
X1504(is)S
X1601(a)S
X1675(summary)S
X2077(of)S
X2190(Xv)S
X2342(library)S
X2638(functions:)S
X720 H
X3600 V
X900(XvGetPortAttribute\(3X\))S
X1912(\261)S
X1992(return)S
X2260(current)S
X2572(port)S
X2763(attribute)S
X3126(value)S
X720 H
X3840 V
X900(XvGetStill\(3X\))S
X1552(\261)S
X1632(capture)S
X1955(a)S
X2029(single)S
X2298(frame)S
X2560(of)S
X2673(video)S
X2925(from)S
X3149(a)S
X3223(drawable)S
X720 H
X4080 V
X900(XvGetVideo\(3X\))S
X1628(\261)S
X1708(capture)S
X2031(video)S
X2283(from)S
X2507(a)S
X2581(drawable)S
X720 H
X4320 V
X900(XvGrabPort\(3X\))S
X1606(\261)S
X1686(lock)S
X1888(port)S
X2079(for)S
X2225(exclusive)S
X2632(use)S
X2795(by)S
X2925(client)S
X720 H
X4560 V
X900(XvPortNotify\(3X\))S
X1668(\261)S
X1748(event)S
X1994(generated)S
X2411(when)S
X2657(port)S
X2848(attributes)S
X3250(change)S
X720 H
X4800 V
X900(XvPutStill\(3X\))S
X1542(\261)S
X1622(write)S
X1857(a)S
X1931(single)S
X2200(frame)S
X2462(of)S
X2575(video)S
X2827(to)S
X2935(a)S
X3009(drawable)S
X720 H
X5040 V
X900(XvPutVideo\(3X\))S
X1618(\261)S
X1698(write)S
X1933(video)S
X2185(into)S
X2371(a)S
X2445(drawable)S
X720 H
X5280 V
X900(XvQueryAdaptors\(3X\))S
X1855(\261)S
X1935(return)S
X2203(adaptor)S
X2532(information)S
X3034(for)S
X3180(a)S
X3254(screen)S
X720 H
X5520 V
X900(XvQueryBestSize\(3X\))S
X1839(\261)S
X1919(determine)S
X2348(the)S
X2500(optimum)S
X2892(drawable)S
X3287(region)S
X3572(size)S
X720 H
X5760 V
X900(XvQueryEncodings\(3X\))S
X1911(\261)S
X1991(return)S
X2259(list)S
X2412(of)S
X2525(encodings)S
X2960(for)S
X3106(an)S
X3230(adaptor)S
X720 H
X6000 V
X900(XvQueryExtension\(3X\))S
X1889(\261)S
X1969(return)S
X2237(version)S
X2561(and)S
X2735(revision)S
X3087(of)S
X3200(extension)S
X720 H
X6240 V
X900(XvSelectPortNotify\(3X\))S
X1912(\261)S
X1992(enable)S
X2282(or)S
X2395(disable)S
X2708(XvPortNotify)S
X3288(events)S
X720 H
X6480 V
X900(XvSelectVideoNotify\(3X\))S
X1989(\261)S
X2069(enable)S
X2359(or)S
X2472(disable)S
X2785(XvVideoNotify)S
X3442(events)S
X720 H
X6720 V
X900(XvSetPortAttribute\(3X\))S
X1896(\261)S
X1976(set)S
X2117(an)S
X2241(attribute)S
X2604(for)S
X2750(a)S
X2824(port)S
X720 H
X6960 V
X900(XvStopVideo\(3X\))S
X1668(\261)S
X1748(stop)S
X1945(active)S
X2213(video)S
X720 H
X7200 V
X900(XvUngrabPort\(3X\))S
X1706(\261)S
X1786(release)S
X2092(a)S
X2166(grabbed)S
X2517(port)S
X720 H
X7680 V
X5350(1)S
X7920 V
XEP
X%%Page: 2 2
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X720(Xv)S
X887(\()S
X947(3X)S
X1114(\))S
X720 H
X1080 V
X10 R
X900(XvVideoNotify\(3X\))S
X1745(\261)S
X1825(event)S
X2071(generated)S
X2488(for)S
X2634(video)S
X2886(processing)S
X720 H
X1368 V
X900(Each)S
X1129(of)S
X1242(these)S
X1477(functions)S
X1879(is)S
X1976(described)S
X2388(in)S
X2496(its)S
X2621(own)S
X2823(Xv)S
X2975(man)S
X3177(page.)S
X720 H
X7680 V
X720(2)S
X7920 V
XEP
X%%Page: 3 3
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X4033(XvFreeAdaptorInfo)S
X5133(\()S
X5193(3X)S
X5360(\))S
X720 H
X1080 V
X9 B
X720(Name)S
X720 H
X1200 V
X10 R
X900(XvFreeAdaptorInfo)S
X1722(\261)S
X1802(free)S
X1986(adaptor)S
X2315(information)S
X720 H
X1368 V
X9 B
X720(Syntax)S
X720 H
X1488 V
X10 B
X900(XvFreeAdaptorInfo\()S
X10 I
X1787(p_adaptor_info)S
X10 R
X2410(\))S
X720 H
X1728 V
X10 B
X900(XvAdaptorInfo)S
X10 I
X1591(*p_adaptor_info)S
X10 R
X2264(;)S
X720 H
X1896 V
X9 B
X720(Arguments)S
X720 H
X2016 V
X10 I
X900(p_adaptor_info)S
X720 H
X2136 V
X10 R
X1300(Pointer)S
X1619(to)S
X1727(where)S
X2000(the)S
X2152(adaptor)S
X2481(information)S
X2983(is)S
X3080(located.)S
X720 H
X2304 V
X9 B
X720(Description)S
X720 H
X2424 V
X10 R
X900(XvFreeAdaptorInfo\(3X\))S
X1910(frees)S
X2133(adaptor)S
X2462(information)S
X2964(that)S
X3144(was)S
X3329(returned)S
X3691(by)S
X3821(XvQueryAdaptors\(3X\).)S
X4831(The)S
X5016(data)S
X720 H
X2544 V
X900(structure)S
X1279(used)S
X1492(for)S
X1638(adaptor)S
X1967(information)S
X2469(is)S
X2566(de\256ned)S
X2890(in)S
X2998(the)S
X3150(reference)S
X3549(page)S
X3767(for)S
X3913(XvQueryAdaptors\(3X\).)S
X720 H
X2712 V
X9 B
X720(Examples)S
X720 H
X2832 V
X10 C
X1150(Example)S
X1630(between)S
X2110(.EX)S
X2350(and)S
X2590(.EE)S
X2830(will)S
X3130(show)S
X3430(in)S
X3610(monospace)S
X720 H
X3060 V
X9 B
X720(See)S
X892(Also)S
X720 H
X3180 V
X10 R
X900(XvQueryAdaptors\(3X\),)S
X1880(XvFreeEncodingInfo\(3X\))S
X720 H
X7680 V
X5350(3)S
X7920 V
XEP
X%%Page: 4 4
XBP
X/slant 0 def
X/height 1.000000 def
X10 R
X10 R
X72 H
X120 V
X72(|--)S
X720 H
X600 V
X12 HB
X720(XvFreeEncodingInfo)S
X1907(\()S
X1967(3X)S
X2134(\))S
X720 H
X1080 V
X9 B
X720(Name)S
X720 H
X1200 V
X10 R
X900(XvFreeEncodingInfo)S
X1778(\261)S
X1858(free)S
X2042(encoding)S
X2438(information)S
X720 H
X1368 V
X9 B
X720(Syntax)S
X720 H
X1488 V
X10 B
X900(XvFreeEncodingInfo\()S
X10 I
X1833(p_encoding_info)S
X10 R
X2505(\))S
X720 H
X1728 V
X10 B
X900(XvEncodingInfo)S
X10 I
X1637(*p_encoding_info)S
X10 R
X2359(;)S
X720 H
X1896 V
X9 B
X720(Arguments)S
X720 H
X2016 V
X10 I
X900(p_encoding_info)S
X720 H
X2136 V
X10 R
X1300(Pointer)S
X1619(to)S
X1727(where)S
X2000(the)S
X2152(encoding)S
X2548(information)S
X3050(is)S
X3147(located.)S
X720 H
X2304 V
X9 B
X720(Description)S
X720 H
X2424 V
X10 R
X900(XvFreeEncodingInfo\(3X\))S
X1966(frees)S
X2189(encoding)S
X2585(information)S
X3087(that)S
X3267(was)S
X3452(returned)S
X3814(by)S
X3944(XvQueryEncodings\(3X\).)S
X5010(The)S
X5195(data)S
X720 H
X2544 V
X900(structure)S
X1279(used)S
X1492(for)S
X1638(encoding)S
X2034(information)S
X2536(is)S
X2633(de\256ned)S
X2957(in)S
X3065(the)S
X3217(reference)S
X3616(page)S
X3834(for)S
X3980(XvQueryEncodings\(3X\).)S
X720 H
X2712 V
X9 B
X720(Examples)S
X720 H
X2832 V
X10 C
X1150(Example)S
X1630(between)S
X2110(.EX)S
X2350(and)S
X2590(.EE)S
X2830(will)S
X3130(show)S
X3430(in)S
X3610(monospace)S
X720 H
X3060 V
X9 B
X720(See)S
X892(Also)S
X720 H
X3180 V
X10 R
X900(XvQueryEncodings\(3X\))S
END_OF_FILE
if test 14747 -ne `wc -c <'extensions/xv/doc/xv-lib-v2.PS.aa'`; then
    echo shar: \"'extensions/xv/doc/xv-lib-v2.PS.aa'\" unpacked with wrong size!
fi
# end of 'extensions/xv/doc/xv-lib-v2.PS.aa'
fi
if test -f 'extensions/xv/test/xvt1.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extensions/xv/test/xvt1.c'\"
else
echo shar: Extracting \"'extensions/xv/test/xvt1.c'\" \(14126 characters\)
sed "s/^X//" >'extensions/xv/test/xvt1.c' <<'END_OF_FILE'
X/***********************************************************
XCopyright 1991 by Digital Equipment Corporation, Maynard, Massachusetts,
Xand the Massachusetts Institute of Technology, Cambridge, Massachusetts.
X
X                        All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the names of Digital or MIT not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XDIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XDIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X
X******************************************************************/
X/*
X** File: 
X**
X**   xvt1.c --- Xv test program 1
X**   
X** Author: 
X**
X**   David Carver (Digital Workstation Engineering/Project Athena)
X**
X** Revisions:
X**
X**   11.06.91 Carver
X**     - changed SetPortControl to SetPortAttribute
X**     - changed GetPortControl to GetPortAttribute
X**     - changed QueryBestSize
X**
X**   15.05.91 Carver
X**     - version 2.0 upgrade
X**
X**   24.01.91 Carver
X**     - version 1.4 upgrade
X**       
X*/
X#include <stdio.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/extensions/Xvlib.h>
X
X
Xmain()
X
X{
X  char chr;
X  int ii, jj, kk, ll, status, mask, nitems;
X  unsigned int actual_w, actual_h;
X  int screen;
X
X  Display *dpy;
X  Visual *vis,*def_vis;
X  XVisualInfo *p_vis_info, vis_info_temp;
X  XGCValues gc_attr;
X  GC gc;
X  XSetWindowAttributes win_attr;
X  Window root,main_win;
X  Colormap cmap;
X  XEvent event;
X  XColor scolor,ecolor;
X
X  unsigned long version, revision;
X  unsigned int major_opcode;
X  unsigned int event_base;
X  unsigned int error_base;
X  unsigned long nAdaptors, nEncodings;
X  XvAdaptorInfo *pAdaptors, *pAdaptor;
X  XvEncodingInfo *pEncoding, *pEncodings;
X  XvFormat *pFormat;
X  XvPortID port;
X  XvEncodingID encoding, old_encoding;
X  XvEvent *pe;
X  float rate;
X  Atom encoding_atom;
X
X  printf("\n  Welcome to Xv test program #1\n\n");
X  printf("  This program invokes all the Xv functions that are supported\n");
X  printf("  by your display.  It will list the available adaptors and\n");
X  printf("  their corresponding information.  It will create a window for \n");
X  printf("  the display of video and still images.  Then for \n");
X  printf("  each adaptor it will get/put a still image into the bottom \n");
X  printf("  window and a video image into the top. \n");
X
X  printf("\n> Press return to continue...");
X  chr = getc(stdin);
X
X  dpy = XOpenDisplay(0);
X  if (!dpy)
X    {
X      printf("\n  Couldn't open display\n");
X      printf("\n  Xv test program #1 terminated\n");
X      exit();
X    }
X
X  root = XDefaultRootWindow(dpy);
X  screen = XDefaultScreen(dpy);
X
X  XSynchronize(dpy, True);
X
X  printf("\n  QueryExtension Request\n");
X
X  status = XvQueryExtension(dpy, &version, &revision,
X			    &major_opcode, &event_base, &error_base);
X
X  if (status != Success) 
X    {
X      printf("\n  Xv video extension not available\n");
X      printf("\n  Xv test program #1 terminated\n");
X      exit();
X    }
X
X  printf("    Version = %d\n    Revision = %d\n", version, revision);
X  printf("    Opcode = %d\n    Event Base = %d\n    Error Base = %d\n",
X	 major_opcode, event_base, error_base);
X
X  printf("\n");
X
X  printf("\n  QueryAdaptors Request\n");
X
X  status = XvQueryAdaptors(dpy, root, &nAdaptors, &pAdaptors);
X
X  if (status != Success) 
X    {
X      printf("\n  XvQueryAdaptors failed with code %d\n", status);
X      printf("\n  Xv test program #1 terminated\n");
X      exit();
X    }
X
X  if (!nAdaptors)
X    {
X      printf("\n  Your display has no video adaptors\n");
X      printf("\n  Xv test program #1 terminated\n");
X      exit();
X    }
X
X  printf("\n");
X  printf("  Number of Adaptors: %d\n", nAdaptors);
X
X  printf("\n");
X
X  pAdaptor = pAdaptors;
X  for (ii=0; ii<nAdaptors; ii++)
X    {
X      printf("  Adaptor Info #%d\n", ii+1);
X      printf("    name:                 %s\n",pAdaptor->name);
X      printf("    type:                 %1x (hex)\n", pAdaptor->type);
X      printf("    base_id:              %x (hex)\n", pAdaptor->base_id);
X      printf("    num_ports:            %d\n", pAdaptor->num_ports);
X      printf("    num_formats:          %d\n", pAdaptor->num_formats);
X      printf("\n");
X
X      vis_info_temp.visualid = 0;
X
X      pFormat = pAdaptor->formats;
X      for (jj=0; jj<pAdaptor->num_formats; jj++)
X	{
X	  printf("\n");
X	  printf("    Format #%d\n", jj+1);
X	  printf("      visual_id:          %x\n",pFormat->visual_id);
X	  printf("      depth:              %d\n",pFormat->depth);
X	  pFormat++;
X	}
X      
X      pAdaptor++;
X
X      printf("\n> Press <ret> to continue ");
X      printf("or s<ret> to skip remaining adaptors...");
X      chr = getc(stdin);
X      if (chr == 's') break;
X
X    }
X
X  encoding_atom = XInternAtom(dpy,"XV_ENCODING",False);
X
X  pAdaptor = pAdaptors;
X  ii=0;
X  while (ii<nAdaptors)
X    {
X      printf("\n  Testing adaptor #%d\n", ii+1);
X
X      printf("\n  XvQueryEncodings\n");
X
X      XvQueryEncodings(dpy, pAdaptor->base_id, &nEncodings, &pEncodings);
X
X      pEncoding = pEncodings;
X      for (jj=0; jj<nEncodings; jj++)
X	{
X	  printf("    Encoding Info #%d\n", jj+1);
X	  printf("      encoding_id:        %d\n", pEncoding->encoding_id);
X	  printf("      name:               %s\n", pEncoding->name);
X	  printf("      width:              %d\n", pEncoding->width);
X	  printf("      height:             %d\n", pEncoding->height);
X
X	  rate = pEncoding->rate.numerator;
X	  rate = rate / pEncoding->rate.denominator;
X	  printf("      rate:               %.2f\n", rate);
X
X	  if (strcmp(pEncoding->name, "ntsc-svideo") == 0)
X	    encoding = pEncoding->encoding_id;
X
X	  pEncoding++;
X	}
X
X      pFormat = pAdaptor->formats;
X
X      jj=0;
X      while (jj<pAdaptor->num_formats)
X	{
X	  printf("\n    Testing format #%d\n", jj+1);
X
X	  vis_info_temp.visualid = pFormat->visual_id;
X	  p_vis_info = XGetVisualInfo(dpy, VisualIDMask, 
X				      &vis_info_temp, &nitems);
X	  if (!p_vis_info)
X	    {
X	      printf("      Error: Couldn't find visual ");
X	      printf("#%x listed for adaptor.\n", pFormat->visual_id);
X	      break;
X	    }
X	  vis = p_vis_info->visual;
X
X	  def_vis = XDefaultVisual(dpy,screen);
X	  if (vis->visualid == def_vis->visualid)
X	    cmap = XDefaultColormap(dpy,screen);
X	  else
X	    cmap = XCreateColormap(dpy, root, vis, AllocNone);
X
X	  XAllocNamedColor(dpy, cmap, "midnight blue", &scolor, &ecolor);
X
X	  win_attr.colormap = cmap;
X	  win_attr.background_pixel = scolor.pixel;
X	  win_attr.event_mask = ExposureMask;
X	  win_attr.backing_store = Always;
X	  win_attr.border_pixel = scolor.pixel;
X
X	  main_win = XCreateWindow(dpy, root, 0, 0, 672, 966, 0, 
X				   pFormat->depth, InputOutput, vis,
X				   CWColormap | CWBackPixel | CWEventMask |
X				   CWBackingStore | CWBorderPixel,
X				   &win_attr);
X
X	  XMapWindow(dpy, main_win);
X
X	  printf("\n      Waiting for window to become visible...\n");
X	  while (1)
X	    {
X	      XNextEvent(dpy, &event);
X	      if (event.type == Expose) break;
X	    }
X
X	  printf("\n      SelectVideoNotify on window\n");
X	  XvSelectVideoNotify(dpy, main_win, True);
X
X	  gc_attr.foreground = scolor.pixel;
X	  gc = XCreateGC(dpy, main_win, GCForeground, &gc_attr);
X
X	  port = pAdaptor->base_id;
X
X	  kk=0;
X	  while (kk<pAdaptor->num_ports)
X	    {
X	      printf("\n      Testing port #%x (hex)\n", port);
X
X	      printf("\n        Enable PortNotify events\n");
X	      XvSelectPortNotify(dpy, port, True);
X
X	      XvGetPortAttribute(dpy, port, 
X				 encoding_atom, (int *)&old_encoding);
X
X	      printf("\n        GetPortAttribute: encoding = %d\n", 
X		     old_encoding);
X
X	      printf("\n        SetPortAttribute: encoding = %d\n", encoding);
X	      
X	      XvSetPortAttribute(dpy, port, encoding_atom, encoding);
X
X	      printf("\n        Waiting for port notify event ...\n");
X
X	      while (1)
X		{
X		  XNextEvent(dpy, &event);
X		  if (event.type == event_base + XvPortNotify)
X		    {
X		      pe = (XvEvent *)&event;
X
X		      if (pe->xvport.attribute == encoding_atom)
X			printf("          Port encoding changed to %d\n", 
X			       pe->xvport.value);
X		      else
X			printf("          Got unexpected port notify event\n");
X		      break;
X		    }
X		}
X
X	      printf("\n        Disable PortNotify events\n");
X	      XvSelectPortNotify(dpy, port, False);
X
X	      XvGetPortAttribute(dpy, port, encoding_atom, (int *)&encoding);
X
X	      printf("\n        GetPortAttribute: encoding = %d\n", encoding);
X	      printf("\n        SetPortAttribute: encoding = %d\n", 
X		     old_encoding);
X
X	      XvSetPortAttribute(dpy, port, encoding_atom, old_encoding);
X
X	      printf("\n        QueryBestSize\n");
X	      printf("          motion:           True\n");
X	      printf("          width:            %d\n", 640);
X	      printf("          height:           %d\n", 480);
X
X	      XvQueryBestSize(dpy, port, True, 640, 480, 640, 480, 
X			      &actual_w, &actual_h);
X
X	      printf("\n        QueryBestSize Reply\n");
X	      printf("          actual width:      %d\n", actual_w);
X	      printf("          actual height:     %d\n", actual_h);
X	      
X	      printf("\n        GrabPort\n");
X
X	      status = XvGrabPort(dpy, port, CurrentTime);
X	      if (status == Success)
X		{
X		  printf("          Port Grabbed!\n");
X		}
X	      else if (status == XvAlreadyGrabbed)
X		printf("        Port Already Grabbed!\n");
X	      else if (status == XvInvalidTime)
X		printf("          Invalid Grab Time!\n");
X
X	      printf("\n        UngrabPort\n");
X	      XvUngrabPort(dpy, port, CurrentTime);
X
X	      if (pAdaptor->type & XvInputMask)
X		{
X		  printf("\n        PutVideo\n");
X		  XvPutVideo(dpy, port, main_win, gc, 0, 0, 
X			     640, 480, 16, 0, 640, 480);
X		  
X		  printf("\n        Waiting for video Started event ...\n");
X		  while (1)
X		    {
X		      XNextEvent(dpy, &event);
X		      if (event.type == event_base + XvVideoNotify)
X			{
X			  pe = (XvEvent *)&event;
X			  if (pe->xvvideo.reason == XvStarted)
X			    {
X			      printf("          Video started\n");
X			      break;
X			    }
X			  if (pe->xvvideo.reason == XvBusy)
X			    {
X			      printf("          Port busy\n");
X			      break;
X			    }
X			  if (pe->xvvideo.reason == XvHardError)
X			    {
X			      printf("          Port error\n");
X			      break;
X			    }
X			}
X		    }
X
X		  printf("\n> Press <ret> to PutStill...");
X		  chr = getc(stdin);
X
X		  printf("\n        PutStill\n");
X		  XvPutStill(dpy, port, main_win, gc, 0, 0, 
X			     640, 480, 16, 483, 640, 480);
X
X		  printf("\n> Press <ret> to StopVideo...");
X		  chr = getc(stdin);
X
X		  printf("\n        StopVideo\n");
X		  XvStopVideo(dpy, port, main_win);
X
X		  printf("\n        Waiting for video Stopped event ...\n");
X		  while (1)
X		    {
X		      XNextEvent(dpy, &event);
X		      if (event.type == event_base)
X			{
X			  pe = (XvEvent *)&event;
X			  if (pe->xvvideo.reason == XvStopped)
X			    {
X			      printf("          Video stopped\n");
X			      break;
X			    }
X			  if (pe->xvvideo.reason == XvPreempted)
X			    {
X			      printf("          Video preempted\n");
X			      break;
X			    }
X			  if (pe->xvvideo.reason == XvHardError)
X			    {
X			      printf("          Video hard error\n");
X			      break;
X			    }
X			}
X		    }
X		}
X
X	      if (pAdaptor->type & XvOutputMask)
X		{
X		  printf("\n        GetVideo\n");
X		  XvGetVideo(dpy, port, main_win, gc, 0, 0, 
X			     640, 480, 16, 0, 640, 480);
X		  
X		  printf("\n        Waiting for video Started event ...\n");
X		  while (1)
X		    {
X		      XNextEvent(dpy, &event);
X		      if (event.type == event_base)
X			{
X			  pe = (XvEvent *)&event;
X			  if (pe->xvvideo.reason == XvStarted)
X			    {
X			      printf("          Video started\n");
X			      break;
X			    }
X			  if (pe->xvvideo.reason == XvBusy)
X			    {
X			      printf("          Port busy\n");
X			      break;
X			    }
X			  if (pe->xvvideo.reason == XvHardError)
X			    {
X			      printf("          Port error\n");
X			      break;
X			    }
X			}
X		    }
X
X		  printf("\n> Press <ret> to GetStill...");
X		  chr = getc(stdin);
X
X		  printf("\n        GetStill\n");
X		  XvGetStill(dpy, port, main_win, gc, 0, 0, 
X			     640, 480, 16, 483, 640, 480);
X
X		  printf("\n> Press <ret> to StopVideo...");
X		  chr = getc(stdin);
X
X		  printf("\n        StopVideo\n");
X		  XvStopVideo(dpy, port, main_win);
X
X		  printf("\n        Waiting for video Stopped event ...\n");
X		  while (1)
X		    {
X		      XNextEvent(dpy, &event);
X		      if (event.type == event_base)
X			{
X			  pe = (XvEvent *)&event;
X			  if (pe->xvvideo.reason == XvStopped)
X			    {
X			      printf("          Video stopped\n");
X			      break;
X			    }
X			  if (pe->xvvideo.reason == XvPreempted)
X			    {
X			      printf("          Video preempted\n");
X			      break;
X			    }
X			  if (pe->xvvideo.reason == XvHardError)
X			    {
X			      printf("          Video hard error\n");
X			      break;
X			    }
X			}
X		    }
X		}
X
X	      port++;
X
X	      kk++;
X
X	      if (kk<pAdaptor->num_ports)
X		{
X		  printf("\n> Press <ret> to continue ");
X		  printf("or s<ret> to skip remaining ports...");
X		  chr = getc(stdin);
X		  if (chr == 's') break;
X		}
X
X	    }
X
X	  XDestroyWindow(dpy, main_win);
X	  XFreeGC(dpy, gc);
X
X	  pFormat++;
X
X	  jj++;
X
X	  if (jj<pAdaptor->num_formats)
X	    {
X	      printf("\n> Press <ret> to continue ");
X	      printf("or s<ret> to skip remaining formats...");
X	      chr = getc(stdin);
X	      if (chr == 's') break;
X	    }
X	}
X
X      pAdaptor++;
X
X      ii++;
X
X      if (ii<nAdaptors)
X	{
X	  printf("\n> Press <ret> to continue ");
X	  printf("or s<ret> to skip remaining adaptors...");
X	  chr = getc(stdin);
X	  if (chr == 's') break;
X	}
X    }
X
X  printf("\n  Xv test program #1 finished\n");
X
X}
END_OF_FILE
if test 14126 -ne `wc -c <'extensions/xv/test/xvt1.c'`; then
    echo shar: \"'extensions/xv/test/xvt1.c'\" unpacked with wrong size!
fi
# end of 'extensions/xv/test/xvt1.c'
fi
if test -f 'extensions/xv/test/xvt6.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'extensions/xv/test/xvt6.c'\"
else
echo shar: Extracting \"'extensions/xv/test/xvt6.c'\" \(8716 characters\)
sed "s/^X//" >'extensions/xv/test/xvt6.c' <<'END_OF_FILE'
X/***********************************************************
XCopyright 1991 by Digital Equipment Corporation, Maynard, Massachusetts,
Xand the Massachusetts Institute of Technology, Cambridge, Massachusetts.
X
X                        All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the names of Digital or MIT not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XDIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XDIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X
X******************************************************************/
X/*
X** File: 
X**
X**   xvt6.c --- Xv test program 6
X**   
X** Author: 
X**
X**   David Carver (Digital Workstation Engineering/Project Athena)
X**
X** Revisions:
X**
X**   31.05.91 Carver
X**     - origional
X**       
X*/
X#include <stdio.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/extensions/Xvlib.h>
X
X
Xmain(argc, argv)
X     int         argc;
X     char        *argv[];
X{
X  char chr;
X  int ii, jj, status, in_motion;
X  unsigned int mask;
X  int screen;
X  int dx, dy, dw, dh, px, py, cx, cy, vx, vy, vw, vh;
X  int rx,ry,wx,wy;
X  int delta;
X
X  Display *dpy;
X  Visual *vis,*def_vis;
X  XVisualInfo *p_vis_info, vis_info_tmpl;
X  unsigned long vis_id;
X  unsigned long depth;
X  XGCValues gc_attr;
X  GC gc,stillgc;
X  XSetWindowAttributes win_attr;
X  Window root,main_win,child;
X  Pixmap mskpix;
X  Colormap cmap;
X  XEvent event;
X  XColor scolor,ecolor;
X
X  unsigned long version, revision;
X  unsigned int event_base;
X  unsigned int error_base;
X  unsigned int major_opcode;
X  unsigned long nAdaptors;
X  XvAdaptorInfo *pAdaptors, *pAdaptor;
X  XvEncodingInfo *pEncoding;
X  XvFormat *pFormat;
X  unsigned long port;
X  unsigned long enc_id;
X  XvEvent *pe;
X  float rate;
X  int video;
X
X  printf("\n  Welcome to Xv test program #6\n\n");
X  printf("  This program is not interactive.  It verifies that a scaled\n");
X  printf("  video image stays within the specified bounds, for all sizes\n");
X  printf("  of source and destination rectangles.  If the white lines\n");
X  printf("  that are drawn contain any gaps, then the image didn't\n");
X  printf("  stay in the specified region.\n");
X
X  printf("\n> Press return to continue...");
X  chr = getc(stdin);
X
X  dpy = XOpenDisplay(0);
X  if (!dpy)
X    {
X      printf("\n  Couldn't open display\n");
X      printf("\n  Xv test program #6 terminated\n");
X      exit();
X    }
X
X  root = XDefaultRootWindow(dpy);
X  screen = XDefaultScreen(dpy);
X
X/*  XSynchronize(dpy, True); */
X
X  status = XvQueryExtension(dpy, &version, &revision,
X			    &major_opcode, &event_base, &error_base);
X
X  if (status != Success) 
X    {
X      printf("\n  Xv video extension not available\n");
X      printf("\n  Xv test program #6 terminated\n");
X      exit();
X    }
X
X  XvQueryAdaptors(dpy, root, &nAdaptors, &pAdaptors);
X
X  printf("\n  Xv V%01d.%d\n", version, revision);
X
X  if (!nAdaptors)
X    {
X      printf("\n  Your display has no video adaptors\n");
X      printf("\n  Xv test program #6 terminated\n");
X      exit();
X    }
X
X if (!Setup(argc, argv, nAdaptors, pAdaptors, &port, &depth, &vis_id))
X   {
X     printf("\n  Setup failed.\n");
X     printf("\n  Xv test program #6 terminated\n");
X     exit();
X   }
X
X
X  vis_info_tmpl.visualid = vis_id;
X  p_vis_info = XGetVisualInfo(dpy, VisualIDMask, &vis_info_tmpl, &ii);
X  if (!p_vis_info)
X    {
X      printf("      Error: Couldn't find visual ");
X      printf("#%x listed for adaptor.\n", pFormat->visual_id);
X      printf("\n  Xv test program #6 terminated\n");
X      return;
X    }
X
X  vis = p_vis_info->visual;
X  def_vis = XDefaultVisual(dpy,screen);
X
X  if (vis->visualid == def_vis->visualid)
X    cmap = XDefaultColormap(dpy,screen);
X  else
X    cmap = XCreateColormap(dpy, root, vis, AllocNone);
X  
X  XAllocNamedColor(dpy, cmap, "midnight blue", &scolor, &ecolor);
X
X  win_attr.colormap = cmap;
X  win_attr.background_pixel = scolor.pixel;
X  win_attr.event_mask = ExposureMask | VisibilityChangeMask | 
X    ButtonPressMask | ButtonReleaseMask | KeyPressMask;
X  win_attr.border_pixel = scolor.pixel;
X
X  main_win = XCreateWindow(dpy, root, 0, 0, 672, 512, 0, 
X			   depth, InputOutput, vis,
X			   CWColormap | CWBackPixel | CWEventMask |
X			   CWBorderPixel,
X			   &win_attr);
X
X  XMapWindow(dpy, main_win);
X
X  printf("\n  Waiting for window to become visible...\n");
X  while (1)
X    {
X      XNextEvent(dpy, &event);
X      if (event.type == VisibilityNotify) break;
X    }
X
X  printf("\n  SelectNotify on window\n");
X  XvSelectVideoNotify(dpy, main_win, True);
X
X  gc_attr.foreground = 0xffffff;
X  gc = XCreateGC(dpy, main_win, 
X		 GCForeground,
X		 &gc_attr);
X
X  vw = 640;
X  vh = 480;
X
X  while ((vw > 0) && (vh > 0))
X    {
X
X      dx = 16;
X      dy = 16;
X      dw = vw;
X      dh = vh;
X      
X      while ((dw > 0) && (dh > 0))
X	{
X	  XvPutVideo(dpy, port, main_win, gc, 0, 0, 
X		     vw, vh, dx, dy, dw, dh);
X	  
X	  XFillRectangle(dpy,main_win,gc,dx-1,0,1,512);
X	  XFillRectangle(dpy,main_win,gc,dx+dw,0,1,512);
X	  XFillRectangle(dpy,main_win,gc,0,dy-1,672,1);
X	  XFillRectangle(dpy,main_win,gc,0,dy+dh,672,1);
X	  
X	  XFlush(dpy);
X	  
X	  dx += 1;
X	  dy += 1;
X	  dw -= 2;
X	  dh -= 2;
X	  
X	}
X
X      vw -= 1;
X      vh -= 1;
X
X      XClearWindow(dpy,main_win);
X
X    }
X
X  printf("\n  Xv test program #6 finished\n");
X
X}
X
X
XSetup(argc, argv, nAdaptors, pAdaptors, p_port, p_depth, p_vis_id)
X     int         argc;
X     char        *argv[];
X     unsigned long nAdaptors;
X     XvAdaptorInfo *pAdaptors;
X     unsigned long *p_port;
X     unsigned long *p_depth;
X     unsigned long *p_vis_id;
X{
X  int ii, jj;
X  XvAdaptorInfo *pAdaptor;
X  XvFormat *pFormat;
X  int adaptor, port, depth, visual_id;
X
X  adaptor = port = depth = visual_id = -1;
X
X  /* LOOK THROUGH COMMAND LINE ARGUMENTS */
X
X  for ( ii = 1; ii < argc; ii++ )
X    {
X      if (strcmp( argv[ii], "-adaptor") == 0)
X	{
X	    if(++ii < argc)
X	      adaptor = atoi(argv[ii]);
X            else
X	      UseMsg(argv);
X	}
X      else if (strcmp( argv[ii], "-port") == 0)
X	{
X	    if(++ii < argc)
X	      port = atoi(argv[ii]);
X            else
X	      UseMsg(argv);
X	}
X      else if (strcmp( argv[ii], "-depth") == 0)
X	{
X	    if(++ii < argc)
X	      depth = atoi(argv[ii]);
X            else
X	      UseMsg(argv);
X	}
X      else if (strcmp( argv[ii], "-visual") == 0)
X	{
X	    if(++ii < argc)
X	      visual_id = atoi(argv[ii]);
X            else
X	      UseMsg(argv);
X	}
X      else if (strcmp( argv[ii], "-help") == 0)
X	{
X	  UseMsg(argv);
X	}
X    }
X
X  if (adaptor < 0)
X    {
X      pAdaptor = pAdaptors;
X    }
X  else
X    {
X      if (adaptor > nAdaptors)
X	{
X	  printf("\n  Adaptor #%d doesn't exist.\n", adaptor);
X	  return False;
X	}
X      pAdaptor = pAdaptors+(adaptor-1);
X    }
X
X  if (port < 0)
X    {
X      port = pAdaptor->base_id;
X    }
X  else
X    {
X      if (port > pAdaptor->num_ports)
X	{
X	  printf("\n  Port #%d doesn't exist for adaptor #%d.\n", 
X		 port, adaptor);
X	  return False;
X	}
X    }
X
X  pFormat = pAdaptor->formats;
X
X  if (depth < 0)
X    {
X      depth = pFormat->depth;
X    }
X  else
X    {
X      for (ii=0; ii<pAdaptor->num_formats; ii++)
X	{
X	  if (pFormat->depth == depth) break;
X	  pFormat++;
X	}
X
X      if (ii >= pAdaptor->num_formats)
X	{
X	  printf("\n  Depth %d not supported by adaptor.\n", depth);
X	  return False;
X	}
X    }
X
X  if (visual_id < 0)
X    {
X      visual_id = pFormat->visual_id;
X    }
X  else
X    {
X
X      pFormat = pAdaptor->formats;
X
X      for (ii=0; ii<pAdaptor->num_formats; ii++)
X	{
X	  if ((pFormat->visual_id == visual_id) && pFormat->depth == depth)
X	    break;
X	  pFormat++;
X	}
X
X      if (ii >= pAdaptor->num_formats)
X	{
X	  printf("\n  Visual-id %d at depth %d not supported by adaptor.\n", 
X		 depth, visual_id);
X	  return False;
X	}
X    }
X
X  *p_port = port;
X  *p_depth = depth;
X  *p_vis_id = visual_id;
X
X  return True;
X}
X
XUseMsg(argv)
X     char        *argv[];
X{
X
X  printf("use: %s [option]\n", argv[0]);
X  printf("\t-adaptor #                       adaptor number\n");
X  printf("\t-port #                          port (XID)\n");
X  printf("\t-depth #                         drawable depth (planes)\n");
X  printf("\t-visual #                        drawable visual (id)\n");
X  exit();
X}
END_OF_FILE
if test 8716 -ne `wc -c <'extensions/xv/test/xvt6.c'`; then
    echo shar: \"'extensions/xv/test/xvt6.c'\" unpacked with wrong size!
fi
# end of 'extensions/xv/test/xvt6.c'
fi
if test -f 'server/ddx/cfb32/cfbteblt8.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'server/ddx/cfb32/cfbteblt8.c'\"
else
echo shar: Extracting \"'server/ddx/cfb32/cfbteblt8.c'\" \(13789 characters\)
sed "s/^X//" >'server/ddx/cfb32/cfbteblt8.c' <<'END_OF_FILE'
X/*
X * TEGblt - ImageText expanded glyph fonts only.  For
X * 8 bit displays, in Copy mode with no clipping.
X */
X
X/*
XCopyright 1989 by the Massachusetts Institute of Technology
X
XPermission to use, copy, modify, and distribute this software and its
Xdocumentation for any purpose and without fee is hereby granted,
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in
Xsupporting documentation, and that the name of M.I.T. not be used in
Xadvertising or publicity pertaining to distribution of the software
Xwithout specific, written prior permission.  M.I.T. makes no
Xrepresentations about the suitability of this software for any
Xpurpose.  It is provided "as is" without express or implied warranty.
X*/
X
X/* $XConsortium: cfbteblt8.c,v 5.14 91/04/10 11:41:38 keith Exp $ */
X
X#include	"X.h"
X#include	"Xmd.h"
X#include	"Xproto.h"
X#include	"cfb.h"
X#include	"fontstruct.h"
X#include	"dixfontstr.h"
X#include	"gcstruct.h"
X#include	"windowstr.h"
X#include	"scrnintstr.h"
X#include	"pixmapstr.h"
X#include	"regionstr.h"
X#include	"cfbmskbits.h"
X#include	"cfb8bit.h"
X
X#if (PPW == 4)
X
X/*
X * this code supports up to 5 characters at a time.  The performance
X * differences between 4 and 5 is usually small (~7% on PMAX) and
X * frequently negative (SPARC and Sun3), so this file is compiled
X * only once for now.  If you want to use the other options, you'll
X * need to hack cfbgc.c as well.
X */
X
X#ifndef NGLYPHS
X#define NGLYPHS 4
X#endif
X
X#if NGLYPHS == 4
X#define DO_COMMON
X#endif
X
X#ifdef DO_COMMON
X#define CFBTEGBLT8 cfbTEGlyphBlt8
X#endif
X
X/*
X * On little-endian machines (or where fonts are padded to 32-bit
X * boundaries) we can use some magic to avoid the expense of getleftbits
X */
X
X#if ((BITMAP_BIT_ORDER == LSBFirst && NGLYPHS >= 4) || GLYPHPADBYTES == 4)
X
X#if GLYPHPADBYTES == 1
Xtypedef unsigned char	*glyphPointer;
X#define USE_LEFTBITS
X#endif
X
X#if GLYPHPADBYTES == 2
Xtypedef unsigned short	*glyphPointer;
X#define USE_LEFTBITS
X#endif
X
X#if GLYPHPADBYTES == 4
Xtypedef unsigned int	*glyphPointer;
X#endif
X
X#define GetBitsL    c = BitLeft (*leftChar++, lshift)
X
X#define GetBits1S   c = BitRight(*char1++, xoff1)
X#define GetBits1L   GetBitsL | BitRight(*char1++, xoff1)
X#define GetBits1U   c = *char1++
X#define GetBits2S   GetBits1S | BitRight(*char2++, xoff2)
X#define GetBits2L   GetBits1L | BitRight(*char2++, xoff2)
X#define GetBits2U   GetBits1U | BitRight(*char2++, xoff2)
X#define GetBits3S   GetBits2S | BitRight(*char3++, xoff3)
X#define GetBits3L   GetBits2L | BitRight(*char3++, xoff3)
X#define GetBits3U   GetBits2U | BitRight(*char3++, xoff3)
X#define GetBits4S   GetBits3S | BitRight(*char4++, xoff4)
X#define GetBits4L   GetBits3L | BitRight(*char4++, xoff4)
X#define GetBits4U   GetBits3U | BitRight(*char4++, xoff4)
X#define GetBits5S   GetBits4S | BitRight(*char5++, xoff5)
X#define GetBits5L   GetBits4L | BitRight(*char5++, xoff5)
X#define GetBits5U   GetBits4U | BitRight(*char5++, xoff5)
X
X#else
X
Xtypedef unsigned char	*glyphPointer;
X
X#define USE_LEFTBITS
X
X#define GetBitsL    WGetBitsL
X#define GetBits1S   WGetBits1S
X#define GetBits1L   WGetBits1L
X#define GetBits1U   WGetBits1U
X
X#define GetBits2S   GetBits1S Get1Bits (char2, tmpSrc) \
X		    c |= BitRight(tmpSrc, xoff2);
X#define GetBits2L   GetBits1L Get1Bits (char2, tmpSrc) \
X		    c |= BitRight(tmpSrc, xoff2);
X#define GetBits2U   GetBits1U Get1Bits (char2, tmpSrc) \
X		    c |= BitRight(tmpSrc, xoff2);
X
X#define GetBits3S   GetBits2S Get1Bits (char3, tmpSrc) \
X		    c |= BitRight(tmpSrc, xoff3);
X#define GetBits3L   GetBits2L Get1Bits (char3, tmpSrc) \
X		    c |= BitRight(tmpSrc, xoff3);
X#define GetBits3U   GetBits2U Get1Bits (char3, tmpSrc) \
X		    c |= BitRight(tmpSrc, xoff3);
X
X#define GetBits4S   GetBits3S Get1Bits (char4, tmpSrc) \
X		    c |= BitRight(tmpSrc, xoff4);
X#define GetBits4L   GetBits3L Get1Bits (char4, tmpSrc) \
X		    c |= BitRight(tmpSrc, xoff4);
X#define GetBits4U   GetBits3U Get1Bits (char4, tmpSrc) \
X		    c |= BitRight(tmpSrc, xoff4);
X
X#define GetBits5S   GetBits4S Get1Bits (char5, tmpSrc) \
X		    c |= BitRight(tmpSrc, xoff5);
X#define GetBits5L   GetBits4L Get1Bits (char5, tmpSrc) \
X		    c |= BitRight(tmpSrc, xoff5);
X#define GetBits5U   GetBits4U Get1Bits (char5, tmpSrc) \
X		    c |= BitRight(tmpSrc, xoff5);
X
X#endif
X
X#ifdef USE_LEFTBITS
Xextern long endtab[];
X
X#define IncChar(c)  (c = (glyphPointer) (((char *) c) + glyphBytes))
X
X#define Get1Bits(ch,dst)    glyphbits (ch, widthGlyph, glyphMask, dst); \
X			    IncChar (ch);
X
X#define glyphbits(bits,width,mask,dst)	getleftbits(bits,width,dst); \
X					dst &= mask;
X
X#define WGetBitsL   Get1Bits(leftChar,c); \
X		    c = BitLeft (c, lshift);
X#define WGetBits1S  Get1Bits (char1, c) \
X		    c = BitRight (c, xoff1);
X#define WGetBits1L  WGetBitsL Get1Bits (char1, tmpSrc) \
X		    c |= BitRight (tmpSrc, xoff1);
X#define WGetBits1U  Get1Bits (char1, c)
X
X#else
X#define WGetBitsL   GetBitsL
X#define WGetBits1S  GetBits1S
X#define WGetBits1L  GetBits1L
X#define WGetBits1U  GetBits1U
X#endif
X
X#if NGLYPHS == 2
X# define GetBitsNS GetBits2S
X# define GetBitsNL GetBits2L
X# define GetBitsNU GetBits2U
X# define LastChar char2
X#ifndef CFBTEGBLT8
X# define CFBTEGBLT8 cfbTEGlyphBlt8x2
X#endif
X#endif
X#if NGLYPHS == 3
X# define GetBitsNS GetBits3S
X# define GetBitsNL GetBits3L
X# define GetBitsNU GetBits3U
X# define LastChar char3
X#ifndef CFBTEGBLT8
X# define CFBTEGBLT8 cfbTEGlyphBlt8x3
X#endif
X#endif
X#if NGLYPHS == 4
X# define GetBitsNS GetBits4S
X# define GetBitsNL GetBits4L
X# define GetBitsNU GetBits4U
X# define LastChar char4
X#ifndef CFBTEGBLT8
X# define CFBTEGBLT8 cfbTEGlyphBlt8x4
X#endif
X#endif
X#if NGLYPHS == 5
X# define GetBitsNS GetBits5S
X# define GetBitsNL GetBits5L
X# define GetBitsNU GetBits5U
X# define LastChar char5
X#ifndef CFBTEGBLT8
X# define CFBTEGBLT8 cfbTEGlyphBlt8x5
X#endif
X#endif
X
X/* another ugly giant macro */
X#define SwitchEm    switch (ew) \
X		    { \
X		    case 0: \
X		    	break; \
X		    case 1: \
X		    	while (hTmp--) { \
X			    GetBits; \
X			    StoreBits0 \
X			    Loop \
X		    	} \
X		    	break; \
X		    case 2: \
X		    	while (hTmp--) { \
X			    GetBits; \
X			    StoreBits0 FirstStep StoreBits(1) \
X			    Loop \
X		    	} \
X		    	break; \
X		    case 3: \
X		    	while (hTmp--) { \
X			    GetBits; \
X			    StoreBits0 FirstStep StoreBits(1) Step StoreBits(2) \
X			    Loop \
X		    	} \
X		    	break; \
X		    case 4: \
X		    	while (hTmp--) { \
X			    GetBits; \
X			    StoreBits0 FirstStep StoreBits(1) Step \
X			    StoreBits(2) Step StoreBits(3) \
X			    Loop \
X		    	} \
X		    	break; \
X		    case 5: \
X		    	while (hTmp--) { \
X			    GetBits; \
X			    StoreBits0 FirstStep StoreBits(1) Step \
X			    StoreBits(2) Step StoreBits(3) Step \
X			    StoreBits(4) \
X			    Loop \
X		    	} \
X		    	break; \
X		    case 6: \
X		    	while (hTmp--) { \
X			    GetBits; \
X			    StoreBits0 FirstStep StoreBits(1) Step \
X 			    StoreBits(2) Step StoreBits(3) Step \
X			    StoreBits(4) Step StoreBits(5) \
X			    Loop \
X		    	} \
X		    	break; \
X		    case 7: \
X		    	while (hTmp--) { \
X			    GetBits; \
X			    StoreBits0 FirstStep StoreBits(1) Step \
X			    StoreBits(2) Step StoreBits(3) Step \
X			    StoreBits(4) Step StoreBits(5) Step \
X			    StoreBits(6) \
X			    Loop \
X		    	} \
X		    	break; \
X		    case 8: \
X		    	while (hTmp--) { \
X			    GetBits; \
X			    StoreBits0 FirstStep StoreBits(1) Step \
X			    StoreBits(2) Step StoreBits(3) Step \
X			    StoreBits(4) Step StoreBits(5) Step \
X			    StoreBits(6) Step StoreBits(7) \
X			    Loop \
X		    	} \
X		    	break; \
X		    }
X
X#ifdef FAST_CONSTANT_OFFSET_MODE
X#define StorePixels(o,p)    dst[o] = p
X#define Loop		    dst += widthDst;
X#else
X#define StorePixels(o,p)    *dst++ = (p)
X#define Loop		    dst += widthLeft;
X#endif
X
X#define Step		    NextFourBits(c);
X
X#if (BITMAP_BIT_ORDER == MSBFirst)
X#define StoreBits(o)	StorePixels(o,GetFourPixels(c));
X#define FirstStep	Step
X#else
X#define StoreBits(o)	StorePixels(o,*((unsigned long *) (((char *) cfb8Pixels) + (c & 0x3c))));
X#define FirstStep	c = BitLeft (c, 2);
X#endif
X
Xextern void cfbImageGlyphBlt8();
X
Xvoid
XCFBTEGBLT8 (pDrawable, pGC, xInit, yInit, nglyph, ppci, pglyphBase)
X    DrawablePtr pDrawable;
X    GC 		*pGC;
X    int 	xInit, yInit;
X    unsigned int nglyph;
X    CharInfoPtr *ppci;		/* array of character info */
X    unsigned char *pglyphBase;	/* start of array of glyphs */
X{
X    register unsigned long  c;
X    register unsigned long  *dst;
X    register unsigned long  leftMask, rightMask;
X    register int	    hTmp;
X    register int	    xoff1;
X    register int	    xoff2;
X#if NGLYPHS >= 3
X    register int	    xoff3;
X#endif
X#if NGLYPHS >= 4
X    register int	    xoff4;
X#endif
X#if NGLYPHS >= 5
X    register int	    xoff5;
X#endif
X    register glyphPointer   char1;
X    register glyphPointer   char2;
X#if NGLYPHS >= 3
X    register glyphPointer   char3;
X#endif
X#if NGLYPHS >= 4
X    register glyphPointer   char4;
X#endif
X#if NGLYPHS >= 5
X    register glyphPointer   char5;
X#endif
X
X    FontPtr		pfont = pGC->font;
X    unsigned long	*dstLine;
X    glyphPointer	oldRightChar;
X    unsigned long	*pdstBase;
X    glyphPointer	leftChar;
X    int			widthDst, widthLeft;
X    int			widthGlyph;
X    int			h;
X    int			ew;
X    int			x, y;
X    BoxRec		bbox;		/* for clipping */
X    int			lshift;
X    int			widthGlyphs;
X#ifdef USE_LEFTBITS
X    register int	    glyphMask;
X    register unsigned int   tmpSrc;
X    register int	    glyphBytes;
X#endif
X
X    widthGlyph = FONTMAXBOUNDS(pfont,characterWidth);
X    h = FONTASCENT(pfont) + FONTDESCENT(pfont);
X    if (!h)
X	return;
X    x = xInit + FONTMAXBOUNDS(pfont,leftSideBearing) + pDrawable->x;
X    y = yInit - FONTASCENT(pfont) + pDrawable->y;
X    bbox.x1 = x;
X    bbox.x2 = x + (widthGlyph * nglyph);
X    bbox.y1 = y;
X    bbox.y2 = y + h;
X
X    switch ((*pGC->pScreen->RectIn)(
X                ((cfbPrivGC *)(pGC->devPrivates[cfbGCPrivateIndex].ptr))->pCompositeClip, &bbox))
X    {
X      case rgnPART:
X	cfbImageGlyphBlt8(pDrawable, pGC, xInit, yInit, nglyph, ppci, pglyphBase);
X      case rgnOUT:
X	return;
X    }
X
X    if (!cfb8CheckPixels (pGC->fgPixel, pGC->bgPixel))
X	cfb8SetPixels (pGC->fgPixel, pGC->bgPixel);
X
X    leftChar = 0;
X
X    cfbGetLongWidthAndPointer(pDrawable, widthDst, pdstBase)
X
X#if NGLYPHS == 2
X    widthGlyphs = widthGlyph << 1;
X#else
X#if NGLYPHS == 4
X    widthGlyphs = widthGlyph << 2;
X#else
X    widthGlyphs = widthGlyph * NGLYPHS;
X#endif
X#endif
X
X#ifdef USE_LEFTBITS
X    glyphMask = endtab[widthGlyph];
X    glyphBytes = GLYPHWIDTHBYTESPADDED(*ppci);
X#endif
X
X    pdstBase += y * widthDst;
X#ifdef DO_COMMON
X    if (widthGlyphs <= 32)
X#endif
X    	while (nglyph >= NGLYPHS)
X    	{
X	    nglyph -= NGLYPHS;
X	    hTmp = h;
X	    dstLine = pdstBase + (x >> 2);
X	    xoff1 = x & 0x3;
X	    xoff2 = xoff1 + widthGlyph;
X#if NGLYPHS >= 3
X	    xoff3 = xoff2 + widthGlyph;
X#endif
X#if NGLYPHS >= 4
X	    xoff4 = xoff3 + widthGlyph;
X#endif
X#if NGLYPHS >= 5
X	    xoff5 = xoff4 + widthGlyph;
X#endif
X	    char1 = (glyphPointer) FONTGLYPHBITS(pglyphBase, *ppci++);
X	    char2 = (glyphPointer) FONTGLYPHBITS(pglyphBase, *ppci++);
X#if NGLYPHS >= 3
X	    char3 = (glyphPointer) FONTGLYPHBITS(pglyphBase, *ppci++);
X#endif
X#if NGLYPHS >= 4
X	    char4 = (glyphPointer) FONTGLYPHBITS(pglyphBase, *ppci++);
X#endif
X#if NGLYPHS >= 5
X	    char5 = (glyphPointer) FONTGLYPHBITS(pglyphBase, *ppci++);
X#endif
X	    oldRightChar = LastChar;
X	    dst = dstLine;
X	    if (xoff1)
X	    {
X		ew = ((widthGlyphs - (4 - xoff1)) >> 2) + 1;
X#ifndef FAST_CONSTANT_OFFSET_MODE
X		widthLeft = widthDst - ew;
X#endif
X	    	if (!leftChar)
X	    	{
X		    leftMask = cfbendtab[xoff1];
X		    rightMask = cfbstarttab[xoff1];
X
X#define StoreBits0	StorePixels (0,dst[0] & leftMask | \
X				       GetFourPixels(c) & rightMask);
X#define GetBits GetBitsNS
X
X		    SwitchEm
X
X#undef GetBits
X#undef StoreBits0
X
X	    	}
X	    	else
X	    	{
X		    lshift = widthGlyph - xoff1;
X    
X#define StoreBits0  StorePixels (0,GetFourPixels(c));
X#define GetBits GetBitsNL
X    
X		    SwitchEm
X    
X#undef GetBits
X#undef StoreBits0
X    
X	    	}
X	    }
X	    else
X	    {
X#if NGLYPHS == 4
X	    	ew = widthGlyph;    /* widthGlyphs >> 2 */
X#else
X	    	ew = widthGlyphs >> 2;
X#endif
X#ifndef FAST_CONSTANT_OFFSET_MODE
X		widthLeft = widthDst - ew;
X#endif
X
X#define StoreBits0  StorePixels (0,GetFourPixels(c));
X#define GetBits	GetBitsNU
X
X	    	SwitchEm
X
X#undef GetBits
X#undef StoreBits0
X
X	    }
X	    x += widthGlyphs;
X	    leftChar = oldRightChar;
X    	}
X    while (nglyph--)
X    {
X	xoff1 = x & 0x3;
X	char1 = (glyphPointer) FONTGLYPHBITS(pglyphBase, *ppci++);
X	hTmp = h;
X	dstLine = pdstBase + (x >> 2);
X	oldRightChar = char1;
X	dst = dstLine;
X	if (xoff1)
X	{
X	    ew = ((widthGlyph - (4 - xoff1)) >> 2) + 1;
X#ifndef FAST_CONSTANT_OFFSET_MODE
X	    widthLeft = widthDst - ew;
X#endif
X	    if (!leftChar)
X	    {
X		leftMask = cfbendtab[xoff1];
X		rightMask = cfbstarttab[xoff1];
X
X#define StoreBits0	StorePixels (0,dst[0] & leftMask | GetFourPixels(c) & rightMask);
X#define GetBits	WGetBits1S
X
X		SwitchEm
X#undef GetBits
X#undef StoreBits0
X
X	    }
X	    else
X	    {
X		lshift = widthGlyph - xoff1;
X
X#define StoreBits0  StorePixels (0,GetFourPixels(c));
X#define GetBits WGetBits1L
X
X		SwitchEm
X#undef GetBits
X#undef StoreBits0
X
X	    }
X	}
X	else
X	{
X	    ew = widthGlyph >> 2;
X
X#ifndef FAST_CONSTANT_OFFSET_MODE
X	    widthLeft = widthDst - ew;
X#endif
X
X#define StoreBits0  StorePixels (0,GetFourPixels(c));
X#define GetBits	WGetBits1U
X
X	    SwitchEm
X
X#undef GetBits
X#undef StoreBits0
X
X	}
X	x += widthGlyph;
X	leftChar = oldRightChar;
X    }
X    /*
X     * draw the tail of the last character
X     */
X    xoff1 = x & 3;
X    if (xoff1)
X    {
X	rightMask = cfbstarttab[xoff1];
X	leftMask = cfbendtab[xoff1];
X	lshift = widthGlyph - xoff1;
X	dst = pdstBase + (x >> 2);
X	hTmp = h;
X	while (hTmp--)
X	{
X	    GetBitsL;
X	    *dst = (*dst & rightMask) | (GetFourPixels(c) & leftMask);
X	    dst += widthDst;
X	}
X    }
X}
X#endif /* PPW == 4 */
END_OF_FILE
if test 13789 -ne `wc -c <'server/ddx/cfb32/cfbteblt8.c'`; then
    echo shar: \"'server/ddx/cfb32/cfbteblt8.c'\" unpacked with wrong size!
fi
# end of 'server/ddx/cfb32/cfbteblt8.c'
fi
echo shar: End of archive 16 \(of 29\).
cp /dev/null ark16isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 29 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Molecular Simulations, Inc.             mail: dcmartin@msi.com
796 N. Pastoria Avenue                  uucp: uunet!dcmartin
Sunnyvale, California 94086             at&t: 408/522-9236
