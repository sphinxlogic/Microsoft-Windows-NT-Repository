Newsgroups: comp.sources.x
Path: uunet!zaphod.mps.ohio-state.edu!think.com!mips!msi!dcmartin
From: chuck@trantor.harris-atd.com (Chuck Musciano)
Subject: v16i086: Contool 3.2, Part01/05
Message-ID: <1992Mar5.192238.3984@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Date: Thu, 5 Mar 1992 19:22:38 GMT
Approved: dcmartin@msi.com

Submitted-by: chuck@trantor.harris-atd.com (Chuck Musciano)
Posting-number: Volume 16, Issue 86
Archive-name: contool-3.2/part01

# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
#		"End of archive 1 (of 5)."
# Contents:  README Makefile filters.c icons images place_dialog.c
# Wrapped by dcmartin@fascet on Sat Feb 22 10:11:09 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(9604 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X/************************************************************************/
X/*	Copyright 1988-1990 by Chuck Musciano and Harris Corporation	*/
X/*									*/
X/*	Permission to use, copy, modify, and distribute this software	*/
X/*	and its documentation for any purpose and without fee is	*/
X/*	hereby granted, provided that the above copyright notice	*/
X/*	appear in all copies and that both that copyright notice and	*/
X/*	this permission notice appear in supporting documentation, and	*/
X/*	that the name of Chuck Musciano and Harris Corporation not be	*/
X/*	used in advertising or publicity pertaining to distribution	*/
X/*	of the software without specific, written prior permission.	*/
X/*	Chuck Musciano and Harris Corporation make no representations	*/
X/*	about the suitability of this software for any purpose.  It is	*/
X/*	provided "as is" without express or implied warranty.  This 	*/
X/*	software may not be sold without the prior explicit permission	*/
X/*	of Harris Corporation.						*/
X/************************************************************************/
X
X     Contool Version 3.2
X     
X     Contool will capture and display system console messages with timestamps.
XIt is a replacement for the standard Sun console, which is created with 
X"cmdtool -C".  Contool will flash its icon and beep when messages are written
Xto the icon, so you can keep it closed on your desktop until a message arrives.
XYou can modify this beeping and flashing behavior; see the man page for more
Xdetails.
X
X     You can instruct contool to filter and ignore certain common console
Xmessages.  The man page explains how to create a file of filters in 
Xcan modify this to suit yourself, and copy it to ~/.contool.
X
X     This version of contool will only work with Open Windows 2.0, from Sun,
Xor the XView 2.0 libraries available via anonymous FTP from expo.lcs.mit.edu.
XIn either case, obviously, you'll need to be running some version of X Windows.
X
X     There are no plans to produce a SunView version of contool 3.0.
X     
X     Before building contool, you need to check several site dependencies
Xin the Makefile.  These dependencies are:
X
X	In Makefile:
X		BIN		Where the executable will go, normally
X				/usr/local/bin
X
X		MANDIR		Where the man page will go, normally
X				/usr/man/manl
X
X		MANEXT		The man page extension, usually 'l',
X				for local man pages.  You may want to
X				make MANDIR /usr/man/man1, in which case
X				MANEXT should be '1'.
X
X		HELPDIR		Where the context-sensitive help file
X				will be stored.
X
X		MAILER		The full path of your system mailer.
X
X		ICON_PATH	Path to search (at runtime) for other
X				icon files.  This path will only be used
X				if the user does not have the ICON_PATH
X				environment variable defined.  Should
X				consist of a various directories
X				separated by colons.
X
X		OPENWINHOME	Where you installed Open Windows.
X				Alternately, where you installed the
X				XView toolkit shipped with X11R4.  Must
X				be a directory with a child directory
X				named "include" which contains X and
X				XView include files.
X
X		LDFLAGS		Where ld can find your XView libraries.
X				If you compile with Open Windows, the
X				default value should be correct.  If you
X				are using the X11 XView libraries, you
X				may need to modify this value.
X
X		CPPFLAGS	Where cpp can find your XView include
X				files.  If you compile with Open Windows,
X				the default value should be correct.  If
X				you are using the X11 XView toolkit, you
X				may need to modify this value.
X
XOnce you have adjusted these values, just type "make contool" or "make
Xinstall".  
X
X     Contool honors window command line options, described in xview(1),
Xso you can change the default window size, icon position, etc.  We like
Xto bring contool up closed, using "-Wi".
X
X     Fun with sounds: if your machine can play sounds, you can use the
X"Execute command with message" feature to produce all sorts of audible
Xsignals when messages arrive.  Ellery Chan here at Harris found a nifty
Xuse of sound: he plays the sound /usr/demo/SOUND/sounds/splat.au as the
Xdefault action when a message arrives, and has the window open.  When a
Xmessage arrives, he gets a satisfying "splat!" sound and contool appears
Xon his screen.  If you are running on a SPARCstation (or otherwise have
Xa copy of splat.au for your machine) give it a try.
X
X     Comments, bugs, to me, please.  I would be very interested in your 
Ximpressions of contool and any suggestions you might have to make it better.
XBy the way, there are a few convenient untility routines in misc.c you might
Xfind useful in other programs you are writing.
X
XChuck Musciano
XAdvanced Technology Department
XHarris Corporation
XPO Box 37, MS 3A/1912
XMelbourne, FL 32902
X(407) 727-6131
XARPA: chuck@trantor.harris-atd.com
X
X******************************** KNOWN XVIEW BUG ********************************
X*										*
X*      It is a known bug in XView that if you bring up a dialog box with the	*
X* pushpin out (the default) and display a menu without selecting an item from	*
X* the menu, the dialog box will be closed.  This can be demonstrated in contool	*
X* by bringing up the edit filters window, and displaying the "edit" menu 	*
X* without selecting an action.							*
X*										*
X*      This bug has been reported to Sun, but will not be fixed until version	*
X* 3.0 of XView.									*
X*										*
X*********************************************************************************
X
X*********************************************************************************
X*				Change history					*
X*********************************************************************************
X
X     	1.0	20 Jun 88	Original release
X     	1.1	30 Jun 88	Added -p option to pop open when messages
X     				   arrive.  Suggested by Doug Lind
X     				   (lind@perron.ms.washington.edu).
X     				Added alternate icon sets for more attractive
X     				   appearance when messages arrive.  Alternate
X     				   set two is from David Eckelcamp 
X     				   (eckelcamp@mcc.com).
X     				Cleaned up Makefile.  Again, courtesy of
X     				   David Eckelcamp.
X	2.0	23 Aug 88	Added automatic reload of filters when
X				   filter file is modified.  Suggested by
X				   Craig Musicant (cmusican@stanford.prime.com).
X				Filter strings are now regular expressions.
X				   Provided by jqj@hogg.cc.uoregon.edu.
X				Reworked frame menu, based upon diffs posted
X				   to sun-source@titan.rice.edu.
X				Added protection from overflowing the text edit
X				   window when too many messages arrive.
X				Filters can now be read from any file, not
X				   just ~/.contool.
X	2.1	10 Feb 89	Added logging capability, courtesy of
X				   Gregory Bond (gnb@melba.bby.oz.au).
X	2.2	19 Sep 89	Added filter editing.
X				Added icon pathname completion, courtesy of
X				   Mike Arms (sandia!marms@unmvax.cs.unm.edu).
X				Added moving the blinking icon to the front,
X				   courtesy of Peter Lennevi
X				   (etxlevi@solsta.ericsson.se).
X				Changed icon loading to use ICON_PATH, and
X				   supported ~ expansion, suggested by
X				   Larry Virden (osu-cis!chemabs!lwv27).
X				Fixed multiple message alert handling,
X				   as suggested by Ellery Chan
X				   (ellery@trantor.harris-atd.com).
X	3.0	 6 Jun 90	Ported to XView toolkit, running under
X				   Open Windows 2.0.
X				Reworked interface to be OPEN LOOK
X				   compliant.
X				Added saving of default actions to
X				   filter file.
X				Removed large number of command line
X				   options in lieu of properties
X				   dialog box.
X				Added ability to associate a command
X				   to be executed when a message arrives.
X				Added explicit filter reset capability.
X				Added the ability to print the contents
X				   of the console.  Suggested by 
X				   Danielle Heinzer
X				   (ESC1298%ESOC.BITNET@cunyvm.cuny.edu).
X				Reworked console overflow handling,
X				   courtesy of Matt Cohen
X				   (sysnmc@magic706.chron.com).
X	3.0a	18 Oct 90	Allowed reading of 1.0 filter files.
X				Fixed handling of custom default icon
X				   when blinking stops.
X				Tweaked Makefile slightly.
X				Fixed handling of dialog boxes under
X				   window managers other than olwm.
X				Add Imakefile.
X	3.0b	 1 Nov 90	Fixed "tiny icon" bug.
X				Added "About contool..." dialog.
X				Source restructuring for maintainability.
X	3.0c	15 Jan 91	Added -n option to prevent console
X				   acquisition on startup.
X				Fixed bugs in send mail dialog.
X				Changed send mail "Cancel" to close window.
X				Updated help for "File" button.
X				Dialogs no longer come up clipped by the
X				   bottom of the screen.
X	3.1	24 May 91	Added syntax to support control characters
X				   in filters.
X				Reworked handling of "Other:" mail address.
X				Added filter versions.
X				Missing end patterns are now flagged.
X				Contool now sets its class and name hints.
X				Sending SIGUSR1 (30) to contool stops blinking,
X				   suggested by Frank Peters.
X				Sending SIGHUP (1) closes and reopens the log
X				   file.
X				Added "Apply and Save" button to filter dialog.
X				Added individual message logging.
X				Finally fixed overflow handling.
X				Added multi-line filter timeout.
X	3.1a	24 Jul 91	Added support for WIN_CMDLINE attribute,
X				   from Tomas Stephanson
X				   (Tomas.Stephanson@eua.ericsson.se)
X				Fixed handling of messages without trailing
X				   newlines, suggested by Ellery Chan
X				   (ellery@trantor.harris-atd.com)
X				Fixed typos in the man page
X	3.2	16 Oct 91	Added -i option to allow reading messages
X				   from other sources.
X				Fixed minor error in abend() code.
X				Fixed bug in masking alternative icons.
X				Added message archiving.
X				Added -f option to make contool fork after acquiring 
X				   the console.
END_OF_FILE
if test 9604 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(11111 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and <Imakefile>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.68 91/07/30 11:34:39 rws Exp $
X
X# operating system:  SunOS 4.1.1
X
X# $XConsortium: sunLib.rules,v 1.6 91/03/24 17:55:58 rws Exp $
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X      PROJECTROOT = /usr/X11/R5
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/X11/R5/lib
X           BINDIR = /usr/X11/R5/bin
X          INCROOT = /usr/X11/R5/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/X11/R5/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X# $XConsortium: sunLib.tmpl,v 1.11 91/07/31 11:32:08 rws Exp $
X
XSHLIBLDFLAGS = -assert pure-text
XPICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
XOPENWINHOME	= /usr/openwin
X
XHELPDIR		= /usr/local/lib/help
X
XMAILER		= /usr/ucb/mail
X
XLOCAL_LIBRARIES = -lxview -lolgx $(XLIB)
X
XLDOPTIONS	= -L$(OPENWINHOME)/lib
X
XCPPFLAGS	= -I$(OPENWINHOME)/include
X
XCFLAGS		= -O -DMAILER=\"$(MAILER)\"
X
XEXTRA_INCLUDES	= -I$(OPENWINHOME)/include
X
XSRCS		= about.c archive.c busy.c contool.c contool_ui.c error.c expand.c filename_completion.c \
X		  filters.c getopt.c load.c load_icon.c logging.c misc.c parse.y \
X		  pinned_menu_notify.c place_dialog.c props.c regexp.c send_mail.c store.c
X
XOBJS		= about.o archive.o busy.o contool.o contool_ui.o error.o expand.o filename_completion.o \
X		  filters.o getopt.o load.o load_icon.o logging.o misc.o parse.o \
X		  pinned_menu_notify.o place_dialog.o props.o regexp.o send_mail.o store.o
X
X PROGRAM = contool
X
Xall:: contool
X
Xcontool: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xsaber_contool:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xosaber_contool:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xinstall:: contool
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  contool $(DESTDIR)$(BINDIR)
X
Xinstall.man:: contool.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) contool.man $(DESTDIR)$(MANDIR)/contool.$(MANSUFFIX)
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
Xinstall: install.man install.help
X
Xinstall.help:
X	$(INSTALL) -c $(INSTMANFLAGS) contool.info $(HELPDIR)/contool.info
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	# load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	# load $(ALLDEFINES) $(OBJS)
X
X# -------------------------------------------------------------------------
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
END_OF_FILE
if test 11111 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'filters.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'filters.c'\"
else
echo shar: Extracting \"'filters.c'\" \(28125 characters\)
sed "s/^X//" >'filters.c' <<'END_OF_FILE'
X/************************************************************************/
X/*	Copyright 1987-1991 by Chuck Musciano and Harris Corporation 	*/
X/*									*/
X/*	Full ownership of this software, and all rights pertaining to 	*/
X/*	the for-profit distribution of this software, are retained by 	*/
X/*	Chuck Musciano and Harris Corporation.  You are permitted to 	*/
X/*	use this software without fee.  This software is provided "as 	*/
X/*	is" without express or implied warranty.  You may redistribute 	*/
X/*	this software, provided that this copyright notice is retained,	*/
X/*	and that the software is not distributed for profit.  If you 	*/
X/*	wish to use this software in a profit-making venture, you must 	*/
X/*	first license this code and its underlying technology from 	*/
X/*	Harris Corporation. 						*/
X/*									*/
X/*	Bottom line: you can have this software, you can use it, you 	*/
X/*	can give it away.  You just can't sell any or all parts of it 	*/
X/*	without prior permission from Harris Corporation. 		*/
X/************************************************************************/
X
X/************************************************************************/
X/*									*/
X/*	filters.c	contool filters dialog manager			*/
X/*									*/
X/************************************************************************/
X
X#include	<stdio.h>
X#include	<sys/param.h>
X#include	<sys/types.h>
X#include	<xview/xview.h>
X#include	<xview/panel.h>
X#include	<xview/notice.h>
X#include	<xview/xv_xrect.h>
X
X#include	"manifest.h"
X#include	"contool.h"
X#include	"contool_ui.h"
X
XEXPORT	Filter	*filters = NULL;
X
XPUBLIC	contool_base_objects	*contool_base;
X
XPRIVATE	short	single_bits[] = {
X#include	"images/single.icon"
X			  };
X
XPRIVATE	short	range_bits[] = {
X#include	"images/range.icon"
X			  };
X
XPRIVATE	short	empty_bits[] = {
X#include	"images/empty.icon"
X			  };
X
XPRIVATE	Filter	*edit_set = NULL, *clipboard = NULL;
XPRIVATE	contool_filters_objects	*contool_filters = NULL;
XPRIVATE	Server_image	single, range, empty;
X
X/************************************************************************/
XPRIVATE	int	selection_count()
X
X{	int	i, s, total;
X
X	total = (int) xv_get(contool_filters->filter_list, PANEL_LIST_NROWS);
X	for (i = s = 0; i < total; i++)
X	   if (xv_get(contool_filters->filter_list, PANEL_LIST_SELECTED, i))
X	      s++;
X	return(s);
X}
X
X/************************************************************************/
XPRIVATE	int	curr_selection()
X
X{	int	i, total;
X
X	for (i = 0, total = (int) xv_get(contool_filters->filter_list, PANEL_LIST_NROWS); i < total; i++)
X	   if (xv_get(contool_filters->filter_list, PANEL_LIST_SELECTED, i))
X	      break;
X	if (i >= total)
X	   fprintf(stderr, "No item selected!\n");
X	return(i);
X}
X
X/************************************************************************/
XPRIVATE	Filter	*duplicate_filter(f)
X
XFilter	*f;
X
X{	Filter	*new;
X
X	new = (Filter *) malloc(sizeof(Filter));
X	*new = *f;
X	new->start = strsave(f->start);
X	new->stop = strsave(f->stop);
X	compile_exp(new, new->start, new->stop);
X	new->command = strsave(f->command);
X	new->comment = strsave(f->comment);
X	new->next = NULL;
X	return(new);
X}
X
X/************************************************************************/
XPRIVATE	Filter	*duplicate_list(list)
X
XFilter	*list;
X
X{	Filter	*f, *head = NULL, *curr;
X
X	for (f = list; f; f = f->next)
X	   if (head == NULL)
X	      head = curr = duplicate_filter(f);
X	   else {
X	      curr->next = duplicate_filter(f);
X	      curr = curr->next;
X	      }
X	return(head);
X}
X
X/************************************************************************/
XPRIVATE	free_filter(f)
X
XFilter	*f;
X
X{
X	cond_free(f->start);
X	cond_free(f->start_re);
X	cond_free(f->stop);
X	cond_free(f->stop_re);
X	cond_free(f->command);
X	cond_free(f->comment);
X	free(f);
X}
X
X/************************************************************************/
XEXPORT	free_list(list)
X
XFilter	*list;
X
X{	Filter	*next;
X
X	for ( ; list; list = next) {
X	   next = list->next;
X	   free_filter(list);
X	   }
X}
X
X/************************************************************************/
XPRIVATE	update_controls()
X
X{	Filter	*f;
X	int	i;
X
X	if (selection_count() == 1) {
X	   for (f = edit_set, i = 0; f; f = f->next, i++)
X	      if (xv_get(contool_filters->filter_list, PANEL_LIST_SELECTED, i))
X	         break;
X	   if (f == NULL) {
X	      error("Internal error: filters do not match scrolling list!");
X	      return;
X	      }
X	   xv_set(contool_filters->filter_update, PANEL_INACTIVE, FALSE, NULL);
X	   xv_set(contool_filters->filter_type, PANEL_INACTIVE, FALSE, PANEL_VALUE, f->stop? 1 : 0, NULL);
X	   xv_set(contool_filters->start, PANEL_INACTIVE, FALSE, PANEL_VALUE, is_null(f->start), NULL);
X	   xv_set(contool_filters->stop, PANEL_INACTIVE, f->stop == NULL, PANEL_VALUE, is_null(f->stop), NULL);
X	   xv_set(contool_filters->filter_timeout, PANEL_INACTIVE, f->stop == NULL, PANEL_VALUE, f->timeout, NULL);
X	   xv_set(contool_filters->filter_timeout_units, PANEL_INACTIVE, f->stop == NULL, NULL);
X	   xv_set(contool_filters->comment, PANEL_INACTIVE, FALSE, PANEL_VALUE, is_null(f->comment), NULL);
X	   xv_set(contool_filters->ignore, PANEL_INACTIVE, FALSE, PANEL_VALUE, f->save? 0 : 1, NULL);
X	   if (f->save) {
X	      i = 0;
X	      if (f->beep) {
X	         i |= BEEP_BIT;
X	         xv_set(contool_filters->filter_beep_count, PANEL_INACTIVE, FALSE, PANEL_VALUE, f->beep, NULL);
X	         xv_set(contool_filters->filter_beep_times, PANEL_INACTIVE, FALSE, NULL);
X	         }
X	      else {
X	         xv_set(contool_filters->filter_beep_count, PANEL_INACTIVE, TRUE, NULL);
X	         xv_set(contool_filters->filter_beep_times, PANEL_INACTIVE, TRUE, NULL);
X	         }
X	      if (f->command) {
X	         i |= COMMAND_BIT;
X	         xv_set(contool_filters->filter_command, PANEL_INACTIVE, FALSE, PANEL_VALUE, f->command, NULL);
X	         xv_set(contool_filters->filter_beep_times, PANEL_INACTIVE, FALSE, NULL);
X	         }
X	      else
X	         xv_set(contool_filters->filter_command, PANEL_INACTIVE, TRUE, NULL);
X	      if (f->flash)
X	         i |= FLASH_BIT;
X	      if (f->log)
X	         i |= LOG_BIT;
X	      if (f->open)
X	         i |= OPEN_BIT;
X	      if (f->stamp)
X	         i |= STAMP_BIT;
X	      xv_set(contool_filters->action, PANEL_INACTIVE, FALSE, PANEL_VALUE, i, NULL);
X	      }
X	   else {
X	      xv_set(contool_filters->action, PANEL_INACTIVE, TRUE, NULL);
X	      xv_set(contool_filters->filter_beep_count, PANEL_INACTIVE, TRUE, NULL);
X	      xv_set(contool_filters->filter_beep_times, PANEL_INACTIVE, TRUE, NULL);
X	      xv_set(contool_filters->filter_command, PANEL_INACTIVE, TRUE, NULL);
X	      }
X	   }
X	else {
X	   xv_set(contool_filters->filter_update,        PANEL_INACTIVE, TRUE, NULL);
X	   xv_set(contool_filters->filter_type,          PANEL_INACTIVE, TRUE, NULL);
X	   xv_set(contool_filters->filter_timeout,       PANEL_INACTIVE, TRUE, NULL);
X	   xv_set(contool_filters->filter_timeout_units, PANEL_INACTIVE, TRUE, NULL);
X	   xv_set(contool_filters->start,                PANEL_INACTIVE, TRUE, NULL);
X	   xv_set(contool_filters->stop,                 PANEL_INACTIVE, TRUE, NULL);
X	   xv_set(contool_filters->comment,              PANEL_INACTIVE, TRUE, NULL);
X	   xv_set(contool_filters->ignore,               PANEL_INACTIVE, TRUE, NULL);
X	   xv_set(contool_filters->action,               PANEL_INACTIVE, TRUE, NULL);
X	   xv_set(contool_filters->filter_beep_count,    PANEL_INACTIVE, TRUE, NULL);
X	   xv_set(contool_filters->filter_beep_times,    PANEL_INACTIVE, TRUE, NULL);
X	   xv_set(contool_filters->filter_command,       PANEL_INACTIVE, TRUE, NULL);
X	   }
X}
X
X/************************************************************************/
XPRIVATE	init_filters()
X
X{	Filter	*f;
X	int	i, total;
X
X	xv_set(contool_filters->filter_list, PANEL_PAINT, PANEL_NO_CLEAR, NULL);
X	for (total = (int) xv_get(contool_filters->filter_list, PANEL_LIST_NROWS); total > 0; total--)
X	   xv_set(contool_filters->filter_list, PANEL_LIST_DELETE, total - 1, NULL);
X	xv_set(contool_filters->filter_list, PANEL_PAINT, PANEL_CLEAR, NULL);
X	free_list(edit_set);
X	edit_set = duplicate_list(filters);
X	for (i = 0, f = edit_set; f; f = f->next, i++)
X	   xv_set(contool_filters->filter_list,
X	   	     PANEL_LIST_INSERT, i,
X	   	     PANEL_LIST_GLYPH,  i, f->stop? range : single,
X	   	     PANEL_LIST_STRING, i, f->start,
X	   	  NULL);
X	update_controls();
X}
X
X/************************************************************************/
XPRIVATE	insert_item(pos)
X
Xint	pos;
X
X{	int	i, total;
X	Filter	*f, *t;
X
X	total = (int) xv_get(contool_filters->filter_list, PANEL_LIST_NROWS);
X	for (i = 0; i < total; i++)
X	   if (xv_get(contool_filters->filter_list, PANEL_LIST_SELECTED, i))
X	      xv_set(contool_filters->filter_list, PANEL_LIST_SELECT, i, FALSE, NULL);
X	xv_set(contool_filters->filter_list, PANEL_LIST_INSERT, pos, NULL);
X	xv_set(contool_filters->filter_list, PANEL_LIST_GLYPH, pos, empty, NULL);
X	xv_set(contool_filters->filter_list, PANEL_LIST_SELECT, pos, TRUE, NULL);
X	if (pos == 0) {
X	   f = (Filter *) malloc(sizeof(Filter));
X	   f->next = edit_set;
X	   edit_set = f;
X	   }
X	else {
X	   for (i = 1, f = edit_set; i < pos; i++, f = f->next)
X	      ;
X	   t = f->next;
X	   f->next = (Filter *) malloc(sizeof(Filter));
X	   f = f->next;
X	   f->next = t;
X	   }
X	f->start = f->stop = f->comment = NULL;
X	f->beep = defaults.beep;
X	f->command = strsave(defaults.command);
X	f->flash = defaults.flash;
X	f->log = defaults.log;
X	f->open = defaults.open;
X	f->stamp = defaults.stamp;
X	f->timeout = 0;
X	f->save = TRUE;
X	update_controls();
X/* update the scrolling view */
X}
X
X/************************************************************************/
XPRIVATE	paste_items(pos)
X
Xint	pos;
X
X{	int	i;
X	Filter	*new, *tail, *f;
X
X	new = duplicate_list(clipboard);
X	for (f = new, i = 0; f; f = f->next, i++) {
X	   xv_set(contool_filters->filter_list, PANEL_LIST_INSERT, pos + i, 0);
X	   xv_set(contool_filters->filter_list,
X	   	     PANEL_LIST_STRING, pos + i, f->start,
X	   	     PANEL_LIST_GLYPH,  pos + i, f->stop? range : single,
X	   	  NULL);
X	   tail = f;
X	   }
X	if (pos == 0) {
X	   tail->next = edit_set;
X	   edit_set = new;
X	   }
X	else {
X	   for (i = 1, f = edit_set; i < pos; i++, f = f->next)
X	      ;
X	   tail->next = f->next;
X	   f->next = new;
X	   }
X	update_controls();
X}
X
X/************************************************************************/
XPRIVATE	int	update_values(f, flag)
X
XFilter	*f;
Xint	flag;
X
X{	char	*start, *stop, *msg;
X	int	i;
X
X	start = (char *) xv_get(contool_filters->start, PANEL_VALUE);
X	if (is_empty(start)) {
X	   if (flag)
X	      error("You must specify a starting message pattern");
X	   return(FALSE);
X	   }
X	if (xv_get(contool_filters->filter_type, PANEL_VALUE) == 1) {
X	   stop = (char *) xv_get(contool_filters->stop, PANEL_VALUE);
X	   if (is_empty(stop)) {
X	      if (flag)
X	         error("You must specify an ending message pattern");
X	      return(FALSE);
X	      }
X	   }
X	else
X	   stop = NULL;
X	if (msg = compile_exp(f, start, stop)) {
X	   if (flag)
X	      error(msg);
X	   return(FALSE);
X	   }
X	if ((int) xv_get(contool_filters->ignore, PANEL_VALUE) == 0) {
X	   i = (int) xv_get(contool_filters->action, PANEL_VALUE);
X	   if (i & COMMAND_BIT)
X	      if (msg = (char *) xv_get(contool_filters->filter_command, PANEL_VALUE))
X	         f->command = strsave(msg);
X	      else {
X	         if (flag)
X	            error("You must specify a command for this filter");
X	         return(FALSE);
X	         }
X	   else
X	      f->command = NULL;
X	   if (i & BEEP_BIT)
X	      f->beep = (int) xv_get(contool_filters->filter_beep_count, PANEL_VALUE);
X	   else
X	      f->beep = 0;
X	   f->flash = (i & FLASH_BIT)? TRUE : FALSE;
X	   f->log = (i & LOG_BIT)? TRUE : FALSE;
X	   f->open = (i & OPEN_BIT)? TRUE : FALSE;
X	   f->stamp = (i & STAMP_BIT)? TRUE : FALSE;
X	   f->save = TRUE;
X	   }
X	else
X	   f->save = FALSE;
X	f->timeout = (stop == NULL)? 0 : (int) xv_get(contool_filters->filter_timeout, PANEL_VALUE);
X	f->start = strsave(start);
X	f->stop = strsave(stop);
X	f->comment = strsave((char *) xv_get(contool_filters->comment, PANEL_VALUE));
X	return(TRUE);
X}
X
X/************************************************************************/
XEXPORT	Menu_item	edit_filters(item, op)
X
XMenu_item	item;
XMenu_generate	op;
X
X{	Filter	*f, *curr;
X
X	if (op == MENU_NOTIFY) {
X	   xv_set(contool_base->base, FRAME_BUSY, TRUE, NULL);
X	   if (contool_filters == NULL) {
X	      contool_filters = contool_filters_objects_initialize(NULL, contool_base->base);
X	      place_dialog(contool_base->base, contool_filters->filters);
X	      xv_set(contool_filters->filter_list, PANEL_LIST_ROW_HEIGHT, 16, NULL);
X	      single = (Server_image) xv_create(NULL, SERVER_IMAGE,
X	      					   XV_WIDTH, 16,
X	      					   XV_HEIGHT, 16,
X	      					   SERVER_IMAGE_BITS, single_bits,
X	      					0);
X	      range  = (Server_image) xv_create(NULL, SERVER_IMAGE,
X	      					   XV_WIDTH, 16,
X	      					   XV_HEIGHT, 16,
X	      					   SERVER_IMAGE_BITS, range_bits,
X	      					0);
X	      empty  = (Server_image) xv_create(NULL, SERVER_IMAGE,
X	      					   XV_WIDTH, 16,
X	      					   XV_HEIGHT, 16,
X	      					   SERVER_IMAGE_BITS, empty_bits,
X	      					0);
X	      }
X	   if (xv_get(contool_filters->filters, XV_SHOW) == FALSE) {
X	      edit_set = duplicate_list(filters);
X	      free_list(clipboard);
X	      clipboard = NULL;
X	      init_filters();
X	      }
X	   xv_set(contool_filters->filters, XV_SHOW, TRUE, NULL);
X	   xv_set(contool_base->base, FRAME_BUSY, FALSE, NULL);
X	   }
X	return item;
X}
X
X/************************************************************************/
XEXPORT	int	filter_notify(item, string, client_data, op, event)
X
XPanel_item	item;
Xchar		*string;
XXv_opaque	client_data;
XPanel_list_op	op;
XEvent		*event;
X
X{	
X	if (op == PANEL_LIST_OP_DESELECT || op == PANEL_LIST_OP_SELECT)
X	   update_controls();
X	return XV_OK;
X}
X
X/************************************************************************/
XEXPORT	Menu	filter_insert_handler(menu, op)
X
XMenu		menu;
XMenu_generate	op;
X
X{
X	xv_set(menu, MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	xv_set(contool_filters->filter_insert, PANEL_NOTIFY_STATUS, XV_ERROR, NULL);
X	return menu;
X}
X
X/************************************************************************/
XEXPORT	Menu_item	insert_at_top(item, op)
X
XMenu_item	item;
XMenu_generate	op;
X
X{
X	xv_set(item, MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	xv_set(contool_filters->filter_insert, PANEL_NOTIFY_STATUS, XV_ERROR, NULL);
X	if (op == MENU_NOTIFY)
X	   insert_item(0);
X	return item;
X}
X
X/************************************************************************/
XEXPORT	Menu_item	insert_above(item, op)
X
XMenu_item	item;
XMenu_generate	op;
X
X{
X	xv_set(item, MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	xv_set(contool_filters->filter_insert, PANEL_NOTIFY_STATUS, XV_ERROR, NULL);
X	if (op == MENU_DISPLAY)
X	   xv_set(item, MENU_INACTIVE, selection_count() != 1, NULL);
X	else if (op == MENU_NOTIFY)
X	   insert_item(curr_selection());
X	return item;
X}
X
X/************************************************************************/
XEXPORT	Menu_item	insert_below(item, op)
X
XMenu_item	item;
XMenu_generate	op;
X
X{
X	xv_set(item, MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	xv_set(contool_filters->filter_insert, PANEL_NOTIFY_STATUS, XV_ERROR, NULL);
X	if (op == MENU_DISPLAY)
X	   xv_set(item, MENU_INACTIVE, selection_count() != 1, NULL);
X	else if (op == MENU_NOTIFY)
X	   insert_item(curr_selection() + 1);
X	return item;
X}
X
X/************************************************************************/
XEXPORT	Menu_item	insert_at_bottom(item, op)
X
XMenu_item	item;
XMenu_generate	op;
X
X{
X	xv_set(item, MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	xv_set(contool_filters->filter_insert, PANEL_NOTIFY_STATUS, XV_ERROR, NULL);
X	if (op == MENU_NOTIFY)
X	   insert_item(xv_get(contool_filters->filter_list, PANEL_LIST_NROWS));
X	return item;
X}
X
X/************************************************************************/
XEXPORT	Menu	filter_edit_handler(menu, op)
X
XMenu		menu;
XMenu_generate	op;
X
X{
X	xv_set(menu, MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	xv_set(contool_filters->filter_insert, PANEL_NOTIFY_STATUS, XV_ERROR, NULL);
X	xv_set(xv_get(contool_filters->filter_edit, PANEL_ITEM_MENU), MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	return menu;
X}
X
X/************************************************************************/
XEXPORT	Menu_item	filter_cut(item, op)
X
XMenu_item	item;
XMenu_generate	op;
X
X{	int	i, total;
X	Filter	*f, *prev, *curr = NULL;
X
X	xv_set(item, MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	xv_set(contool_filters->filter_edit, PANEL_NOTIFY_STATUS, XV_ERROR, NULL);
X	xv_set(xv_get(contool_filters->filter_edit, PANEL_ITEM_MENU), MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	if (op == MENU_DISPLAY)
X	   xv_set(item, MENU_INACTIVE, selection_count() == 0, NULL);
X	else if (op == MENU_NOTIFY) {
X	   free_list(clipboard);
X	   clipboard = NULL;
X	   total = (int) xv_get(contool_filters->filter_list, PANEL_LIST_NROWS);
X	   for (prev = NULL, f = edit_set, i = 0; i < total; i++, f = f->next)
X	      if (xv_get(contool_filters->filter_list, PANEL_LIST_SELECTED, i)) {
X	         if (clipboard == NULL)
X	            clipboard = curr = f;
X	         else {
X	            curr->next = f;
X	            curr = curr->next;
X	            }
X	         if (prev == NULL)
X	            edit_set = f->next;
X	         else
X	            prev->next = f->next;
X	         xv_set(contool_filters->filter_list, PANEL_LIST_DELETE, i, NULL);
X	         i--;
X	         total--;
X	         }
X	      else
X	         prev = f;
X	   if (curr)
X	      curr->next = NULL;
X	   update_controls();
X	   xv_set(item, MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	   }
X	return item;
X}
X
X/************************************************************************/
XEXPORT	Menu_item	filter_copy(item, op)
X
XMenu_item	item;
XMenu_generate	op;
X
X{	int	i, total;
X	Filter	*f, *curr;
X
X	xv_set(item, MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	xv_set(contool_filters->filter_edit, PANEL_NOTIFY_STATUS, XV_ERROR, NULL);
X	xv_set(xv_get(contool_filters->filter_edit, PANEL_ITEM_MENU), MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	if (op == MENU_DISPLAY)
X	   xv_set(item, MENU_INACTIVE, selection_count() == 0, NULL);
X	else if (op == MENU_NOTIFY) {
X	   free_list(clipboard);
X	   clipboard = NULL;
X	   total = (int) xv_get(contool_filters->filter_list, PANEL_LIST_NROWS);
X	   for (f = edit_set, i = 0; i < total; i++, f = f->next)
X	      if (xv_get(contool_filters->filter_list, PANEL_LIST_SELECTED, i))
X	         if (clipboard == NULL)
X	            clipboard = curr = duplicate_filter(f);
X	         else {
X	            curr->next = duplicate_filter(f);
X	            curr = curr->next;
X	            }
X	   curr->next = NULL;
X	   xv_set(item, MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	   }
X	return item;
X}
X
X/************************************************************************/
XEXPORT	Menu_item	filter_delete(item, op)
X
XMenu_item	item;
XMenu_generate	op;
X
X{	int	i, total;
X	Filter	*f, *prev, *temp = NULL, *curr;
X
X	xv_set(item, MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	xv_set(contool_filters->filter_edit, PANEL_NOTIFY_STATUS, XV_ERROR, NULL);
X	xv_set(xv_get(contool_filters->filter_edit, PANEL_ITEM_MENU), MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	if (op == MENU_DISPLAY)
X	   xv_set(item, MENU_INACTIVE, selection_count() == 0, NULL);
X	else if (op == MENU_NOTIFY) {
X	   total = (int) xv_get(contool_filters->filter_list, PANEL_LIST_NROWS);
X	   for (prev = NULL, f = edit_set, i = 0; i < total; i++, f = f->next)
X	      if (xv_get(contool_filters->filter_list, PANEL_LIST_SELECTED, i)) {
X	         if (temp == NULL)
X	            temp = curr = f;
X	         else {
X	            curr->next = f;
X	            curr = curr->next;
X	            }
X	         if (prev == NULL)
X	            edit_set = f->next;
X	         else
X	            prev->next = f->next;
X	         xv_set(contool_filters->filter_list, PANEL_LIST_DELETE, i, NULL);
X	         i--;
X	         total--;
X	         }
X	      else
X	         prev = f;
X	   if (curr)
X	      curr->next = NULL;
X	   free_list(temp);
X	   update_controls();
X	   xv_set(item, MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	   }
X	return item;
X}
X
X/************************************************************************/
XEXPORT	Menu_item	filter_paste(item, op)
X
XMenu_item	item;
XMenu_generate	op;
X
X{
X	xv_set(xv_get(contool_filters->filter_edit, PANEL_ITEM_MENU), MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	if (op == MENU_DISPLAY)
X	   xv_set(item, MENU_INACTIVE, clipboard == NULL, NULL);
X	return item;
X}
X
X/************************************************************************/
XEXPORT	Menu_item	paste_at_top(item, op)
X
XMenu_item	item;
XMenu_generate	op;
X
X{
X	xv_set(xv_get(contool_filters->filter_edit, PANEL_ITEM_MENU), MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	if (op == MENU_NOTIFY)
X	   paste_items(0);
X	return item;
X}
X
X/************************************************************************/
XEXPORT	Menu_item	paste_above(item, op)
X
XMenu_item	item;
XMenu_generate	op;
X
X{
X	xv_set(xv_get(contool_filters->filter_edit, PANEL_ITEM_MENU), MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	if (op == MENU_DISPLAY)
X	   xv_set(item, MENU_INACTIVE, selection_count() != 1, NULL);
X	else if (op == MENU_NOTIFY)
X	   paste_items(curr_selection());
X	return item;
X}
X
X/************************************************************************/
XEXPORT	Menu_item	paste_below(item, op)
X
XMenu_item	item;
XMenu_generate	op;
X
X{
X	xv_set(xv_get(contool_filters->filter_edit, PANEL_ITEM_MENU), MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	if (op == MENU_DISPLAY)
X	   xv_set(item, MENU_INACTIVE, selection_count() != 1, NULL);
X	else if (op == MENU_NOTIFY)
X	   paste_items(curr_selection() + 1);
X	return item;
X}
X
X/************************************************************************/
XEXPORT	Menu_item	paste_at_bottom(item, op)
X
XMenu_item	item;
XMenu_generate	op;
X
X{
X	xv_set(xv_get(contool_filters->filter_edit, PANEL_ITEM_MENU), MENU_NOTIFY_STATUS, XV_ERROR, NULL);
X	if (op == MENU_NOTIFY)
X	   paste_items((int) xv_get(contool_filters->filter_list, PANEL_LIST_NROWS));
X	return item;
X}
X
X/************************************************************************/
XEXPORT	void	filter_update(item, event)
X
XPanel_item	item;
XEvent		*event;
X
X{	int	i, curr;
X	Filter	*f;
X
X	xv_set(item, PANEL_NOTIFY_STATUS, XV_ERROR, NULL);
X
X	curr = curr_selection();
X	for (i = 0, f = edit_set; i < curr; i++, f = f->next)
X	   ;
X	if (update_values(f, TRUE))
X	   xv_set(contool_filters->filter_list,
X		     PANEL_LIST_STRING, curr, f->start,
X		     PANEL_LIST_GLYPH,  curr, f->stop? range : single,
X	          NULL);
X}
X
X/************************************************************************/
XEXPORT	void	set_filter_type(item, value, event)
X
XPanel_item	item;
Xint		value;
XEvent		*event;
X
X{
X	xv_set(contool_filters->stop, PANEL_INACTIVE, value == 0, NULL);
X	xv_set(contool_filters->filter_timeout, PANEL_INACTIVE, value == 0, NULL);
X	xv_set(contool_filters->filter_timeout_units, PANEL_INACTIVE, value == 0, NULL);
X}
X
X/************************************************************************/
XEXPORT	void	set_filter_action(item, value, event)
X
XPanel_item	item;
Xint		value;
XEvent		*event;
X
X{	contool_filters_objects	*ip = (contool_filters_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
X
X	if (value == 0) { /* save this message */
X	   xv_set(ip->action,            PANEL_INACTIVE, FALSE, NULL);
X	   xv_set(ip->filter_beep_count, PANEL_INACTIVE, !((int) xv_get(ip->action, PANEL_VALUE) & BEEP_BIT), NULL);
X	   xv_set(ip->filter_beep_times, PANEL_INACTIVE, !((int) xv_get(ip->action, PANEL_VALUE) & BEEP_BIT), NULL);
X	   xv_set(ip->filter_command,    PANEL_INACTIVE, !((int) xv_get(ip->action, PANEL_VALUE) & COMMAND_BIT), NULL);
X	   }
X	else { /* ignore this message */
X	   xv_set(ip->action,            PANEL_INACTIVE, TRUE, NULL);
X	   xv_set(ip->filter_beep_count, PANEL_INACTIVE, TRUE, NULL);
X	   xv_set(ip->filter_beep_times, PANEL_INACTIVE, TRUE, NULL);
X	   xv_set(ip->filter_command,    PANEL_INACTIVE, TRUE, NULL);
X	   }
X}
X
X/************************************************************************/
XEXPORT	void	set_match_action(item, value, event)
X
XPanel_item	item;
Xunsigned int	value;
XEvent		*event;
X
X{	contool_filters_objects	*ip = (contool_filters_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
X	
X	xv_set(ip->filter_beep_count, PANEL_INACTIVE, !(value & BEEP_BIT), NULL);
X	xv_set(ip->filter_beep_times, PANEL_INACTIVE, !(value & BEEP_BIT), NULL);
X	xv_set(ip->filter_command,    PANEL_INACTIVE, !(value & COMMAND_BIT), NULL);
X}
X
X/************************************************************************/
XEXPORT	void	filter_done(frame)
X
XFrame		frame;
X
X{
X	free_list(edit_set);
X	edit_set = NULL;
X	free_list(clipboard);
X	clipboard = NULL;
X	xv_set(frame, XV_SHOW, FALSE, 0);
X}
X
X/************************************************************************/
XPRIVATE	int	check_for_update()
X
X{	int	i, result, curr, diff = FALSE;
X	Filter	*f, new;
X
X	if (selection_count() != 1)
X	   return(TRUE);
X	curr = curr_selection();
X	for (i = 0, f = edit_set; i < curr; i++, f = f->next)
X	   ;
X	new = *f;
X	if (update_values(&new, FALSE) == FALSE)
X	   diff = TRUE;
X	else if ((f->start != NULL && new.start == NULL) || (f->start == NULL && new.start != NULL))
X	   diff = TRUE;
X	else if ((f->stop != NULL && new.stop == NULL) || (f->stop == NULL && new.stop != NULL))
X	   diff = TRUE;
X	else if ((f->comment != NULL && new.comment == NULL) || (f->comment == NULL && new.comment != NULL))
X	   diff = TRUE;
X	else if ((f->command != NULL && new.command == NULL) || (f->command == NULL && new.command != NULL))
X	   diff = TRUE;
X	else if (new.stop && f->timeout != new.timeout)
X	   diff = TRUE;
X	else if (f->save != new.save || f->beep != new.beep || f->flash != new.flash || f->log != new.log || f->open != new.open || f->stamp != new.stamp)
X	   diff = TRUE;
X	else if (f->start && strcmp(f->start, new.start) != 0)
X	   diff = TRUE;
X	else if (f->stop && strcmp(f->stop, new.stop) != 0)
X	   diff = TRUE;
X	else if (f->comment && strcmp(f->comment, new.comment) != 0)
X	   diff = TRUE;
X	else if (f->command && strcmp(f->command, new.command) != 0)
X	   diff = TRUE;
X	if (diff) {
X	   result = notice_prompt(contool_base->base, NULL,
X	   			     NOTICE_MESSAGE_STRINGS,
X	   			        "You have modified the attributes of the selected filter.",
X	   			        " ",
X	   			        "Do you wish to perform an Update before doing an Apply?",
X	   			        NULL,
X	   			     NOTICE_BUTTON_YES, "Update, then Apply",
X	   			     NOTICE_BUTTON_NO, "Apply",
X	   			     NOTICE_BUTTON, "Cancel", 101,
X	   			  NULL);
X	   if (result == NOTICE_YES)
X	      filter_update(contool_filters->filters, NULL);
X	   return(result != 101);
X	   }
X	return(TRUE);
X}
X
X/************************************************************************/
XEXPORT	void	accept_filters(item, event)
X
XPanel_item	item;
XEvent		*event;
X
X{	Filter	*f;
X	int	i, total;
X	char	*msg = NULL;
X
X	xv_set(item, PANEL_NOTIFY_STATUS, XV_ERROR, NULL);
X
X	if (!check_for_update())
X	   return;
X
X	total = (int) xv_get(contool_filters->filter_list, PANEL_LIST_NROWS);
X	for (i = 0; i < total; i++)
X	   if (xv_get(contool_filters->filter_list, PANEL_LIST_SELECTED, i))
X	      xv_set(contool_filters->filter_list, PANEL_LIST_SELECT, i, FALSE, NULL);
X	for (f = edit_set, i = 0; f; f = f->next, i++)
X	   if (is_empty(f->start) || (msg = compile_exp(f, f->start, f->stop))) {
X	      xv_set(contool_filters->filter_list, PANEL_LIST_SELECT, i, TRUE, NULL);
X	      update_controls();
X	      error(msg? msg : "No pattern is specified for the indicated filter");
X	      return;
X	      }
X	free_list(filters);
X	filters = edit_set;
X	if (xv_get(contool_filters->filters, FRAME_CMD_PUSHPIN_IN))
X	   edit_set = duplicate_list(filters);
X	else {
X	   edit_set = NULL;
X	   free_list(clipboard);
X	   clipboard = NULL;
X	   }
X	filters_changed();
X	xv_set(item, PANEL_NOTIFY_STATUS, XV_OK, NULL);
X}
X
X/************************************************************************/
XEXPORT	void	accept_and_save_filters(item, event)
X
XPanel_item	item;
XEvent		*event;
X
X{
X	accept_filters(item, event);
X	if (xv_get(item, PANEL_NOTIFY_STATUS) == XV_OK)
X	   if (!store_filters_to_file(filter_file, TRUE, TRUE))
X	      xv_set(item, PANEL_NOTIFY_STATUS, XV_ERROR, NULL);
X}
X
X/************************************************************************/
XEXPORT	void	reset_filters(item, event)
X
XPanel_item	item;
XEvent		*event;
X
X{
X	init_filters();
X	xv_set(item, PANEL_NOTIFY_STATUS, XV_ERROR, NULL);
X}
END_OF_FILE
if test 28125 -ne `wc -c <'filters.c'`; then
    echo shar: \"'filters.c'\" unpacked with wrong size!
fi
# end of 'filters.c'
fi
if test ! -d 'icons' ; then
    echo shar: Creating directory \"'icons'\"
    mkdir 'icons'
fi
if test ! -d 'images' ; then
    echo shar: Creating directory \"'images'\"
    mkdir 'images'
fi
if test -f 'place_dialog.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'place_dialog.c'\"
else
echo shar: Extracting \"'place_dialog.c'\" \(2563 characters\)
sed "s/^X//" >'place_dialog.c' <<'END_OF_FILE'
X/************************************************************************/
X/*	Copyright 1987-1991 by Chuck Musciano and Harris Corporation 	*/
X/*									*/
X/*	Full ownership of this software, and all rights pertaining to 	*/
X/*	the for-profit distribution of this software, are retained by 	*/
X/*	Chuck Musciano and Harris Corporation.  You are permitted to 	*/
X/*	use this software without fee.  This software is provided "as 	*/
X/*	is" without express or implied warranty.  You may redistribute 	*/
X/*	this software, provided that this copyright notice is retained,	*/
X/*	and that the software is not distributed for profit.  If you 	*/
X/*	wish to use this software in a profit-making venture, you must 	*/
X/*	first license this code and its underlying technology from 	*/
X/*	Harris Corporation. 						*/
X/*									*/
X/*	Bottom line: you can have this software, you can use it, you 	*/
X/*	can give it away.  You just can't sell any or all parts of it 	*/
X/*	without prior permission from Harris Corporation. 		*/
X/************************************************************************/
X
X/************************************************************************/
X/*									*/
X/*	place_dialog.c	position a dialog box at the right place	*/
X/*									*/
X/************************************************************************/
X
X#include	<stdio.h>
X#include	<sys/param.h>
X#include	<sys/types.h>
X#include	<xview/xview.h>
X#include	<X11/Xutil.h>
X
X#include	"manifest.h"
X
X/************************************************************************/
XEXPORT	void	place_dialog(base, dialog)
X
XXv_opaque	base;
XXv_opaque	dialog;
X
X{	Rect		br, dr, sr;
X	XWMHints	*hints;
X
X	sr = *((Rect *) xv_get(base, WIN_SCREEN_RECT));
X	frame_get_rect(base, &br);
X	frame_get_rect(dialog, &dr);
X	if (rect_right(&br) + dr.r_width < sr.r_width) {
X	   dr.r_left = rect_right(&br);
X	   dr.r_top = br.r_top;
X	   }
X	else if (dr.r_width <= br.r_left) {
X	   dr.r_left = br.r_left - dr.r_width;
X	   dr.r_top = br.r_top;
X	   }
X	else {
X	   dr.r_left = br.r_left + 32;
X	   dr.r_top = br.r_top + 32;
X	   }
X	if (dr.r_top + dr.r_height > sr.r_height)
X	   dr.r_top = sr.r_height - dr.r_height;
X	if (dr.r_top < 0)
X	   dr.r_top = 0;
X	if (rect_right(&dr) > sr.r_width)
X	   dr.r_left = sr.r_width - dr.r_width;
X	if (dr.r_left < 0)
X	   dr.r_left = 0;
X	frame_set_rect(dialog, &dr);
X
X	hints = XGetWMHints(xv_get(dialog, XV_DISPLAY), xv_get(dialog, XV_XID));
X	hints->flags |= StateHint;
X	hints->initial_state = NormalState;
X	XSetWMHints(xv_get(dialog, XV_DISPLAY), xv_get(dialog, XV_XID), hints);
X	XFree(hints);
X}
X
END_OF_FILE
if test 2563 -ne `wc -c <'place_dialog.c'`; then
    echo shar: \"'place_dialog.c'\" unpacked with wrong size!
fi
# end of 'place_dialog.c'
fi
echo shar: End of archive 1 \(of 5\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
