Newsgroups: comp.sources.x
Path: uunet!think.com!mips!msi!dcmartin
From: pjs@pa.dec.com (Philip Schneider)
Subject: v16i085: Magnifier (MOTIF), Part01/01
Message-ID: <1992Feb13.190100.9618@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Date: Thu, 13 Feb 1992 19:01:00 GMT
Approved: dcmartin@msi.com

Submitted-by: pjs@pa.dec.com (Philip Schneider)
Posting-number: Volume 16, Issue 85
Archive-name: xmag/part01

# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  README Imakefile Makefile Makefile.simple mag.xbm
#   patchlevel.h xmag.c xmag.man
# Wrapped by dcmartin@fascet on Thu Feb 13 11:00:26 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(1961 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X				XMAG NOTES
X				------------
XDescription
X-----------
X    Xmag is an X11/Motif tool whose purpose is to magnify (square) regions
Xof your screen.
X
XHistory 
X--------
X    The first version of this program was written in 1987-1988 by
XDanny Shapiro of DEC Workstation Systems Engineering, using the
XDECWindows widget set.  Philip Schneider ported it to Motif 1.1.1
Xin 1991.
X
XCompiling
X---------
X    On most systems,  just typing in the following should do what you want:
X
X	xmkmf <top-level X directory> .
X	make depend
X	make
X
X    A non-imake Makefile exists for those who might want/need it, called
X    Makefile.simple.
X
X    You may need/want to change the following things in the IMakefile 
X    (or in the Makefile.simple, if you're using that) :
X
X	MOTIFLIBS	--	locations of libXm.a and libXt.a
X	MOTIFINCS	--	include file directories
X	BINDIR 		--	where to install xmag
X
X    This program has been tested only on DEC Ultrix workstations.  It
X*should* be portable to any X/Unix/Motif-"compliant" system.  Please let
Xus know if you run into problems compiling/running this program on
Xother systems.
X
XApplication Defaults / Command-line Options
X-------------------------------------------
X    Xmag (should :-) correctly parse all Xt arguments, and all the usual
XXt resources (e.g., in one's .Xdefaults file) apply to xmag. (These are
Xthings like -display, -geometry, -foreground, etc.).  There are no
Xother xmag-specific flags or resources.
X
XCopying Restrictions
X--------------------
X    Copyright 1988, 1991 Danny Shapiro and Philip Schneider.
X
X    Permission to use, copy, modify, and distribute this software
X    and documentation for any purpose other than financial gain
X    without fee, provided that the above copyright notice appears
X    in all copies.
X    It is provided "as is" without express or implied warranty.
X
XBug Reports
X-----------
X    Please send bug reports, comments, job offers, money, etc. to :
X
X	Philip Schneider
X	pjs@pa.dec.com
X	(415)853-6538
X
END_OF_FILE
if test 1961 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(325 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
X
XSRCS = xmag.c
XOBJS = xmag.o
X
X     MOTIF = /usr/lib/DXM
XMOTIF_LIBS = $(MOTIF)/lib/Xm/libXm.a $(MOTIF)/lib/Xt/libXt.a
XMOTIF_INCS = -I$(MOTIF)/lib -I$(MOTIF)/lib/Xt
X  INCLUDES = -I. $(MOTIF_INCS)
X    BINDIR = /udir/pjs/bin
X
X
XLOCAL_LIBRARIES = $(MOTIF_LIBS)
X  SYS_LIBRARIES = -lX11 -lm
X
X
Xall:: xmag
X
XComplexProgramTarget(xmag)
X
END_OF_FILE
if test 325 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(10491 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and <Imakefile>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.68 91/07/30 11:34:39 rws Exp $
X
X# operating system:  SunOS 4.1.1
X
X# $XConsortium: sunLib.rules,v 1.6 91/03/24 17:55:58 rws Exp $
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X      PROJECTROOT = /usr/X11/R5
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/X11/R5/lib
X           BINDIR = /usr/X11/R5/bin
X          INCROOT = /usr/X11/R5/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/X11/R5/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X# $XConsortium: sunLib.tmpl,v 1.11 91/07/31 11:32:08 rws Exp $
X
XSHLIBLDFLAGS = -assert pure-text
XPICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
XSRCS = xmag.c
XOBJS = xmag.o
X
X     MOTIF = /usr/lib/DXM
XMOTIF_LIBS = $(MOTIF)/lib/Xm/libXm.a $(MOTIF)/lib/Xt/libXt.a
XMOTIF_INCS = -I$(MOTIF)/lib -I$(MOTIF)/lib/Xt
X  INCLUDES = -I. $(MOTIF_INCS)
X    BINDIR = /udir/pjs/bin
X
XLOCAL_LIBRARIES = $(MOTIF_LIBS)
X  SYS_LIBRARIES = -lX11 -lm
X
Xall:: xmag
X
X PROGRAM = xmag
X
Xall:: xmag
X
Xxmag: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xsaber_xmag:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xosaber_xmag:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xinstall:: xmag
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  xmag $(DESTDIR)$(BINDIR)
X
Xinstall.man:: xmag.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) xmag.man $(DESTDIR)$(MANDIR)/xmag.$(MANSUFFIX)
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	# load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	# load $(ALLDEFINES) $(OBJS)
X
X# -------------------------------------------------------------------------
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
END_OF_FILE
if test 10491 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'Makefile.simple' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.simple'\"
else
echo shar: Extracting \"'Makefile.simple'\" \(1078 characters\)
sed "s/^X//" >'Makefile.simple' <<'END_OF_FILE'
X
XSRCS = xmag.c
XOBJS = xmag.o
X
XXLIB      = -lX11
XMOTIFLIBS = /usr/lib/DXM/lib/Xm/libXm.a /usr/lib/DXM/lib/Xt/libXt.a
X#EXTENSIONLIB = /x/R4/mit/extensions/lib/libXext.a
XSYSLIBS   = -lm
XLIBS      = $(MOTIFLIBS) $(EXTENSIONLIB) $(XLIB) $(SYSLIBS)
X
XLOCALINCS = -I.
XMOTIFINCS = -I/usr/lib/DXM/lib -I/usr/lib/DXM/lib/Xt
XINCS      = $(LOCALINCS) $(MOTIFINCS)
X
XCDEBUGFLAGS = -g
XCFLAGS = $(INCS) $(CDEBUGFLAGS)
X
XBINDIR = /udir/pjs/bin
X
XPROG  = xmag
XDEBUG = debug
X
XDEPEND = makedepend
X
X.SUFFIXES: .o .c
X
X.c.o:
X	$(CC) -c $(INCS) $(CFLAGS) $*.c
X
Xall: $(PROG)
X
X$(PROG): $(SRCS) Makefile
X	$(CC) -o $(PROG) $(CFLAGS)  $(SRCS) $(LIBS)
X	strip $(PROG)
X	rm -f *.u
X
X$(DEBUG): $(OBJS) Makefile
X	$(CC) -o $(DEBUG) $(OBJS) $(LIBS)
X
Xinstall: $(PROG)
X	install -c -s $(PROG) $(BINDIR)
X
X
Xsaber_src: 
X	#load $(CFLAGS) $(SRCS) $(LIBS) 
Xsaber_obj: $(OJBS) $(LIBOBJS)
X	#load $(CFLAGS) $(OBJS) $(LIBS) 
X  
Xlint:
X	lint $(INCS) $(SRCS) > lint_errs
X
Xclean: 
X	rm -f *~ *.bak core *.o \#*\# $(PROG) $(DEBUG) *.u lint_errs
X
Xdepend:
X	$(DEPEND) $(INCS) $(SRCS)
X
X
X# DO NOT DELETE THIS LINE -- make depend depends on it.
END_OF_FILE
if test 1078 -ne `wc -c <'Makefile.simple'`; then
    echo shar: \"'Makefile.simple'\" unpacked with wrong size!
fi
# end of 'Makefile.simple'
fi
if test -f 'mag.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mag.xbm'\"
else
echo shar: Extracting \"'mag.xbm'\" \(2261 characters\)
sed "s/^X//" >'mag.xbm' <<'END_OF_FILE'
X#define mag_width 50
X#define mag_height 50
Xstatic char mag_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x03, 0x00, 0x00, 0x00,
X   0x00, 0x80, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x3c, 0x00,
X   0x00, 0x00, 0x00, 0xf8, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00,
X   0xc0, 0x03, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
X   0x03, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x06, 0x00,
X   0x00, 0x80, 0x03, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00,
X   0x0c, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0xc0, 0x00,
X   0x00, 0x00, 0x18, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00,
X   0x60, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x30,
X   0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x60, 0x00, 0x00,
X   0x00, 0x30, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x60,
X   0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x30, 0x00,
X   0x00, 0xe0, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00,
X   0x18, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x80, 0x01,
X   0x00, 0x00, 0x0c, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x0c, 0x00, 0x00,
X   0x00, 0x03, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x07,
X   0x00, 0x00, 0x00, 0x0e, 0x00, 0x80, 0x03, 0x00, 0x00, 0x00, 0x1f, 0x00,
X   0xc0, 0x01, 0x00, 0x00, 0x80, 0x7b, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xc0,
X   0xe1, 0x01, 0x3c, 0x00, 0x00, 0x00, 0xf0, 0x80, 0xff, 0x0f, 0x00, 0x00,
X   0x00, 0x78, 0x00, 0xfe, 0x07, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x80, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
X   0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0xf0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00};
END_OF_FILE
if test 2261 -ne `wc -c <'mag.xbm'`; then
    echo shar: \"'mag.xbm'\" unpacked with wrong size!
fi
# end of 'mag.xbm'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
echo shar: Extracting \"'patchlevel.h'\" \(21 characters\)
sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X#define PATCHLEVEL 0
END_OF_FILE
if test 21 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
fi
# end of 'patchlevel.h'
fi
if test -f 'xmag.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xmag.c'\"
else
echo shar: Extracting \"'xmag.c'\" \(23199 characters\)
sed "s/^X//" >'xmag.c' <<'END_OF_FILE'
X/*
X *
X *	XMAG
X *
X *	Screen magnification program
X *
X *	Written by Danny Shapiro
X *	Workstation Systems Engineering
X *	Digital Equipment Corporation
X *	February 29, 1988
X *
X *      Ported to Motif by Philip Schneider
X *	Advanced Technology Development
X *	Digital Equipment Corporation
X *	November 5, 1991
X *
X *	Copyright 1988, 1991 Danny Shapiro and Philip Schneider 
X *
X */
X#include <stdio.h>
X
X#include <X11/Xlib.h>
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Xatom.h>
X#include <X11/Xutil.h>
X#include <X11/Xresource.h>
X#include <X11/cursorfont.h>
X
X#include <Xm/Xm.h>
X#include <Xm/Form.h>
X#include <Xm/DrawingA.h>
X#include <Xm/RowColumn.h>
X#include <Xm/CascadeB.h>
X#include <Xm/PushB.h>
X#include <Xm/ToggleB.h>
X#include <Xm/Label.h>
X#include <Xm/TextF.h>
X#include <Xm/MainW.h>
X
X#include "mag.xbm"
X
X#include "patchlevel.h"
X
X#define MINZOOM		4		/* zoom resolutions */
X#define MAXZOOM 	128
X
X#define MIN(a,b) ((a < b) ? a : b)
X#define MAX(a,b) ((a > b) ? a : b)
X
X#define GRAB		1		/* menu codes */
X#define ZOOMIN		2
X#define ZOOMOUT 	3
X#define GRID		4
X#define QUIT		5
X#define CLEAR		6
X
Xstatic	XtAppContext 	appContext;
Xstatic	Display        	*dpy;		/* display */
Xstatic  Colormap	cMap;
Xstatic	Window         	win,		/* zoom window id */
X	               	root;		/* root window id */
Xstatic	u_long       	black, white; 	/* black, white pixel values */
X
Xstatic	GC             	gc;          	/* zoom window gc */
Xstatic	GC		gcOverlay;	/* root window xor gc */
Xstatic	int 		zoom = 32;   	/* number of cells in zoom window */
Xstatic	int		w,		/* size of window in pixels */
X			h;
Xstatic	int		exX, exY,	/* expose event dimensions */
X			exW, exH;	
Xstatic	int		zX, zY;		/* x and y screen positions */
Xstatic	int		init = 0;	/* initialization flag */
Xstatic	int		grid = 0;	/* grid toggle flag */
Xstatic	int		maxX;		/* max x and y values on screen */
Xstatic	int 		maxY;
Xstatic	int		lastRow    = -1,
X  			lastColumn = -1;
Xstatic	XImage 		*image;		/* used in the getimage call */
X
X
Xstatic	Widget		work;		/* work area widget */
Xstatic	Widget		pixelValue;
Xstatic	Widget		rgbValue;
Xstatic  Widget 		grab;		/* menu buttons */
Xstatic  Widget 		zoomIn;
Xstatic  Widget 		zoomOut;
Xstatic  Widget 		gridToggle;	
Xstatic  Widget	 	quit;
Xstatic  Widget		clear;
X
X
X/*
X *	main()
X */
Xmain(argc, argv)
X    int		argc;
X    char 	*argv[];
X{
X    Widget		topLevel;		/* top level widget */
X    Widget		mainW;
X    Widget		form;
X    Widget 		menu;			/* menu widget */
X
X    Widget		pixelLabel;
X    Widget		rgbLabel;
X
X    XGCValues       	gcValues;		
X    XColor		actual,
X			closest;
X    int			success;
X    int			n;
X    Arg			args[20];
X    static Widget 	MakeMenu();	/* toolkit menu initialization */
X    Cursor          	arrow;
X
X    /*
X     *  Hack to keep Saber-C happy
X     */
X    argv[0] = "xmag";
X    
X    /*
X     *  Open up the toolkit, etc.
X     */
X    topLevel = XtAppInitialize(&appContext, "XMag", 
X			       NULL,
X			       0,
X			       (unsigned int *)&argc, argv,
X			       NULL,
X			       NULL, 0);
X    /*
X     *  Stash away some often-used X stuff
X     */
X    dpy  = XtDisplay(topLevel);
X    root = RootWindow(dpy, 0);
X    maxX = XDisplayWidth(dpy, 0);
X    maxY = XDisplayHeight(dpy, 0);
X    cMap = DefaultColormap(dpy, 0);
X
X    /*
X     * Grab some colors
X     */
X    success = XAllocNamedColor(dpy, cMap, "black",
X			       &actual, &closest);
X    if (success) {
X	black = closest.pixel;
X    } else {
X	black = BlackPixel(dpy, DefaultScreen(dpy));
X    }
X    
X    success = XAllocNamedColor(dpy, cMap, "white",
X			       &actual, &closest);
X    if (success) {
X	white = closest.pixel;
X    } else {
X	white = WhitePixel(dpy, DefaultScreen(dpy));
X    }
X    
X
X    /*
X     *  Start creating the widgets
X     */
X    /*
X     *  Create main window
X     */
X    n = 0;
X    mainW = XmCreateMainWindow(topLevel, "mainW", args, n);
X    XtManageChild(mainW);
X
X    /*
X     *  Form widget holds drawing area and pixel value display
X     */
X    n = 0;
X    form = XmCreateForm(mainW, "form", args, n);
X    XtManageChild(form);
X
X    /*
X     *  Create a menu bar and associated menus
X     */
X    menu = MakeMenu(mainW);
X
X    /*
X     *  Create the pixel and rgb value displays
X     */
X    n = 0;
X    XtSetArg(args[n], XmNtopAttachment,    XmATTACH_NONE);	n++;
X    XtSetArg(args[n], XmNbottomAttachment, XmATTACH_FORM);	n++;
X    XtSetArg(args[n], XmNbottomOffset,     4);			n++;
X    XtSetArg(args[n], XmNleftAttachment,   XmATTACH_POSITION);	n++;
X    XtSetArg(args[n], XmNleftPosition,     50);			n++;
X    XtSetArg(args[n], XmNrightAttachment,  XmATTACH_NONE);	n++;
X    rgbLabel = XmCreateLabel(form, "RGB :", args, n);
X    XtManageChild(rgbLabel);
X
X    n = 0;
X    XtSetArg(args[n], XmNtopAttachment,    XmATTACH_NONE);	n++;
X    XtSetArg(args[n], XmNbottomAttachment, XmATTACH_FORM);	n++;
X    XtSetArg(args[n], XmNbottomOffset,     4);			n++;
X    XtSetArg(args[n], XmNleftAttachment,   XmATTACH_WIDGET);	n++;
X    XtSetArg(args[n], XmNleftWidget,       rgbLabel);		n++;
X    XtSetArg(args[n], XmNrightAttachment,  XmATTACH_NONE);	n++;
X    XtSetArg(args[n], XmNrightOffset,      4);			n++;
X    XtSetArg(args[n], XmNeditable,         False);		n++;    
X    XtSetArg(args[n], XmNcolumns,          10);			n++;    
X    XtSetArg(args[n], XmNmarginHeight,     1);			n++;    
X    XtSetArg(args[n], XmNshadowThickness,  0);			n++;
X    rgbValue = XmCreateTextField(form, "rgbValue", args, n);
X    XtManageChild(rgbValue);
X
X    n = 0;
X    XtSetArg(args[n], XmNtopAttachment,    XmATTACH_NONE);	n++;
X    XtSetArg(args[n], XmNbottomAttachment, XmATTACH_FORM);	n++;
X    XtSetArg(args[n], XmNbottomOffset,     4);			n++;
X    XtSetArg(args[n], XmNleftAttachment,   XmATTACH_NONE);	n++;
X    XtSetArg(args[n], XmNrightAttachment,  XmATTACH_WIDGET);	n++;
X    XtSetArg(args[n], XmNrightWidget,      rgbLabel);		n++;
X    XtSetArg(args[n], XmNrightOffset,      10);			n++;
X    XtSetArg(args[n], XmNeditable,         False);		n++;    
X    XtSetArg(args[n], XmNcolumns,          8);			n++;    
X    XtSetArg(args[n], XmNmarginHeight,     1);			n++;    
X    XtSetArg(args[n], XmNshadowThickness,  0);			n++;
X    pixelValue = XmCreateTextField(form, "pixelValue", args, n);
X    XtManageChild(pixelValue);
X
X    n = 0;
X    XtSetArg(args[n], XmNtopAttachment,    XmATTACH_NONE);	n++;
X    XtSetArg(args[n], XmNbottomAttachment, XmATTACH_FORM);	n++;
X    XtSetArg(args[n], XmNbottomOffset,     4);			n++;
X    XtSetArg(args[n], XmNleftAttachment,   XmATTACH_NONE);	n++;
X    XtSetArg(args[n], XmNrightAttachment,  XmATTACH_WIDGET);	n++;
X    XtSetArg(args[n], XmNrightWidget,      pixelValue);		n++;
X    pixelLabel = XmCreateLabel(form, "Pixel :", args, n);
X    XtManageChild(pixelLabel);
X
X    {
X	Dimension	height;
X	
X	n = 0;
X	XtSetArg(args[n], XmNheight, &height);	n++;
X	XtGetValues(pixelValue, args, n);
X
X	n = 0;
X	XtSetArg(args[n], XmNheight, height);	n++;
X	XtSetValues(pixelLabel, args, n);
X	XtSetValues(rgbLabel, args, n);
X    }
X
X
X    /*
X     *  xmag display area
X     */
X    n = 0;
X    XtSetArg(args[n], XmNtopAttachment,    XmATTACH_FORM);	n++;
X    XtSetArg(args[n], XmNbottomAttachment, XmATTACH_WIDGET);	n++;
X    XtSetArg(args[n], XmNbottomWidget,     pixelValue);		n++;
X    XtSetArg(args[n], XmNleftAttachment,   XmATTACH_FORM);	n++;
X    XtSetArg(args[n], XmNrightAttachment,  XmATTACH_FORM);	n++;
X    XtSetArg(args[n], XmNleftOffset,	   4);			n++;
X    XtSetArg(args[n], XmNrightOffset,	   4);			n++;
X    XtSetArg(args[n], XmNtopOffset,	   4);			n++;
X    XtSetArg(args[n], XmNbottomOffset,	   4);			n++;
X    XtSetArg(args[n], XmNwidth,            w = 8 * zoom);	n++;
X    XtSetArg(args[n], XmNheight,           h = 8 * zoom);	n++;
X    work = XmCreateDrawingArea(form, "work", args, n);
X    XtManageChild (work);
X
X    {
X	static XtCallbackProc ResizeCallback();	/* Resize window callback */
X	static XtCallbackProc ExposeCallback();	/* Expose window callback */
X
X	XtAddCallback(work, XmNresizeCallback, ResizeCallback, NULL);
X	XtAddCallback(work, XmNexposeCallback, ExposeCallback, NULL);
X    }
X
X    
X    XtRealizeWidget(topLevel);
X
X
X    /*
X     *  Set minimum size for xmag
X     */
X    {
X	Dimension	width, height;
X	int		n;
X	Arg		args[3];
X	
X	n = 0;
X	XtSetArg(args[n], XmNwidth,  &width);	n++;
X	XtSetArg(args[n], XmNheight, &height);	n++;
X	XtGetValues(topLevel, args, n);
X
X	n = 0;
X	XtSetArg(args[n], XmNminWidth,  width);	n++;
X	XtSetArg(args[n], XmNminHeight, height);n++;
X	XtSetValues(topLevel, args, n);
X    }
X	
X    
X    /*
X     *  Set up GCs
X     */
X    win = XtWindow(work);
X    gc = XCreateGC(dpy, win, 0, NULL);
X    XSetBackground(dpy, gc, black);
X    
X    gcOverlay = XCreateGC(dpy, root, 0, NULL);
X    gcValues.subwindow_mode = IncludeInferiors;
X    XChangeGC(dpy, gcOverlay, GCSubwindowMode, &gcValues);
X    XSetFunction(dpy, gcOverlay, GXinvert);
X
X    XSetForeground(dpy, gcOverlay, black);
X    XSetBackground(dpy, gcOverlay, white);
X    
X    /*
X     *  Create cursors
X     */
X    arrow = XCreateFontCursor(dpy, XC_top_left_arrow);
X    XDefineCursor(dpy, XtWindow(form), arrow);
X
X
X    /*
X     *  Make a more interesting icon pixmap
X     */
X    {
X	Pixmap 	iconPixmap;
X
X	iconPixmap = XCreateBitmapFromData(XtDisplay(topLevel),
X					   XtScreen(topLevel)->root,
X					   mag_bits,
X					   mag_width, mag_height);
X	n = 0;
X	XtSetArg(args[n], XmNiconPixmap, iconPixmap);	n++;
X	XtSetValues(topLevel, args, n);
X    }
X
X
X    /*
X     *  Define actions for xmag display window
X     */
X    {
X	XtTranslations	transTable;
X	extern void	PixelPokeCallback();
X	
X	static XtActionsRec	actionsTable[] = {
X	    {"poke",	PixelPokeCallback},
X	};
X	
X	static char	newTranslations[] = "\
X	    <Btn1Down>:	poke()\n\
X	    <Btn2Down>: poke()\n\
X	    <Btn3Down>: poke()\n";
X	
X	XtAppAddActions(appContext, actionsTable, XtNumber(actionsTable));
X	transTable = XtParseTranslationTable(newTranslations);
X	XtOverrideTranslations(work, transTable);
X    }
X
X    /*
X     *  Setup main window contents
X     */
X    XmMainWindowSetAreas(mainW, menu, NULL, NULL, NULL, form);
X    
X    /*
X     *  Crank it up . . .
X     */
X    XtAppMainLoop(appContext);
X}
X
X
X/*
X *	Displays zoomed region 
X */
Xstatic void DrawZoom(flag) 
X    int flag;
X{
X    int		x, y;				/* window coordinates 	*/
X    int 	i, j;				/* loop counters 	*/
X    int 	iMin, jMin;			/* loop bounds 		*/
X    int 	iMax, jMax;			/* loop bounds 		*/
X    int 	minDim;
X    u_int 	xSize;
X    u_int 	ySize;
X    int 	xOffset;
X    int 	yOffset;
X    Dimension	width, height;
X    int		n;
X    Arg		args[3];
X    
X    if (!init || !image) {
X	/* no image grabbed yet */
X	return;
X    }
X    
X    /*
X     *  Get the actual width and height of the drawing area
X     */
X    n = 0;
X    XtSetArg(args[n], XmNwidth,  &width);	n++;
X    XtSetArg(args[n], XmNheight, &height);	n++;
X    XtGetValues(work, args, n);
X    
X    minDim = w < h ? w : h;
X    xSize = minDim / zoom;/* size of zoomed pixel */
X    ySize = minDim / zoom;
X    
X    xOffset = ((int)width - zoom * xSize) / 2;/* centers image in window */
X 	yOffset = ((int)height - zoom * ySize) / 2;
X
X    if (xSize < 1) {
X	xSize = 1;
X    }
X    if (ySize < 1) {
X	ySize = 1;
X    }
X    
X    if (!flag)	{
X	/* only need to redraw where 	*/
X	/* exposed			*/
X	jMin =
X	  MAX(0, 
X	      ((float)((exX - xOffset))) /
X	      ((int)width - xOffset - xOffset) * zoom);
X	iMin =
X	  MAX(0,
X	      ((float)((exY - yOffset))) /
X	      ((int)height - yOffset - yOffset) * zoom);
X	jMax =
X	  MIN(zoom, (int)(0.5 + 1 +
X			  ((float)(((exX+exW) - xOffset))) /
X			  ((int)width - xOffset - xOffset) * zoom));
X	iMax =
X	  MIN(zoom, (int)(0.5 + 1 +
X			  ((float)(((exY+exH) - yOffset))) /
X			  ((int)height - yOffset - yOffset) * zoom));
X    } else {					/* draw all */
X	iMax = jMax = zoom;
X	iMin = jMin = 0;
X	XSetBackground(dpy, gc, white);
X	XClearWindow(dpy, win);
X    }
X    
X    for (i = iMin; i < iMax; i++) {		/* loop through pixels */
X	y =  i * ySize + yOffset;
X	for (j = jMin; j < jMax; j++) {
X	    x = j * xSize + xOffset;
X	    XSetForeground(dpy, gc, XGetPixel(image, j, i ));
X	    XFillRectangle(dpy, win, gc, x, y, xSize, ySize);
X	}
X    }
X    
X    if (grid && xSize > 1 && ySize > 1) {	/* draw a grid */
X	XSetForeground(dpy, gc, black);
X	for (i = 0; i <= zoom; i++) {
X	    XDrawLine(dpy, win, gc, xOffset, i * ySize + yOffset, 
X		      width - xOffset, i * ySize + yOffset);
X	    XDrawLine(dpy, win, gc, i * xSize + xOffset, yOffset, 
X		      i * xSize + xOffset, height - yOffset);
X	}
X    }
X    XFlush(dpy);
X}
X
X
X
X
X/* 
X *	Draws overlay box while pointer is grabbed
X */
Xstatic void DrawBox(x, y)
X    int x, y;
X{
X    x -= (zoom / 2) + 1;			/* locate upper left corner */
X    y -= (zoom / 2) + 1;
X    
X    if (x < 0) {				/* check screen bounds */
X	x = 0;
X    } else if (x > (maxX - zoom - 1)) {
X	x = maxX - zoom - 1;
X    }
X    
X    if (y < 0) {
X	y = 0;
X    } else if (y > (maxY - zoom - 1)) {
X	y = maxY - zoom - 1;
X    }
X    
X    XDrawRectangle(dpy, root, gcOverlay, x, y, zoom + 1, zoom + 1);
X}
X
X
X/*
X *	Get pixels to zoom
X */
Xstatic void ZoomIt(x, y, flag)
X    int x, y;
X    int	flag;
X{
X    if (flag && !image) {
X	return;
X    }
X
X    x -= (zoom / 2);			/* locate upper left corner */
X    y -= (zoom / 2);
X    
X    if (x < 0) {				/* check screen bounds */
X	x = 0;
X    } else if (x > (maxX - zoom)) {
X	x = maxX - zoom;
X    }
X    
X    if (y < 0) {
X	y = 0;
X    } else if (y > (maxY - zoom)) {
X	y = maxY - zoom;
X    }
X    
X    if (image) {
X	XDestroyImage(image);		/* clear old image out */
X    }
X    image = XGetImage(dpy, root, x, y,	/* get new image */
X		      zoom, zoom, XAllPlanes(), ZPixmap);
X    DrawZoom(1);			/* display zoomed region */
X
X    {
X	XEvent	event;
X
X	while (XCheckWindowEvent(dpy, win, ExposureMask, &event));
X    }
X}
X
X
X/*
X *	Toolkit callback routine which parses menu selections
X */
Xstatic XtCallbackProc PushbuttonPressed(widget, tag, callData)
X    Widget	widget;
X    char	*tag;
X    XtPointer	callData;
X{
X    int 	done = 0;		/* flag signifies end of grab */
X    int 	button;			/* which button was pressed */
X    Window 	tmp, child;		/* used in QueryPointer */
X    int 	x, y, 			/* cursor position */
X		oX, oY, 		/* old cursor position */
X		junkX, junkY;		/* used in QueryPointer */
X    short 	state;			/* used in QueryPointer */
X    Boolean	exposed = False;
X    static Cursor	crosshair = (Cursor)NULL;
X
X    if (!crosshair) {
X	crosshair = XCreateFontCursor(dpy, XC_crosshair);
X    }
X
X    switch ((int) tag)	{	/* which pull down was selected */
X	case GRAB : {
X	    extern void ResetValueDisplay();
X
X	    ResetValueDisplay();
X	    DrawZoom(0);
X
X	    {
X		int status;
X
X		status = XtGrabPointer(work, True,
X				       ButtonPressMask, GrabModeAsync,
X				       GrabModeAsync,
X				       RootWindow(dpy, DefaultScreen(dpy)),
X				       crosshair, CurrentTime);
X		if (status != GrabSuccess) {
X		    fprintf(stderr, "Error Grabbing Pointer!\n");
X		    exit(-1);
X		}
X	    }
X
X	    XQueryPointer(dpy, root, &tmp, &child, &x, &y,
X			  &junkX, &junkY, &state);
X	    DrawBox(x, y);
X
X	    while (!done) {
X		XEvent	event;
X
X		XSync(dpy, False);
X		if (XtAppPending(appContext))  {
X		    XtAppNextEvent(appContext, &event);
X
X		    if (event.type == ButtonPress) {
X			button = ((XButtonPressedEvent *)
X				  &event)->button;
X			if (button == 1) {
X			    init = 1;
X			    XtSetSensitive(zoomIn, 1);
X			    XtSetSensitive(zoomOut, 1);
X			    XtSetSensitive(gridToggle, 1);
X			    zX = ((XButtonPressedEvent *)
X				  &event)->x_root;
X			    zY = ((XButtonPressedEvent *)
X				  &event)->y_root;
X			    DrawBox(x, y);
X			    ZoomIt(zX, zY, 0);
X			    DrawBox(x, y);
X			} else if (button == 3) {
X			    done = 1;
X			    XtUngrabPointer(work, 
X					    CurrentTime);
X			    DrawBox(x, y);
X			}
X		    } else if (event.type == Expose &&
X			       ((XExposeEvent *)(&event))->window == win) {
X			if (((XExposeEvent *)(&event))->count == 0) {
X			    exposed = True;
X			    DrawZoom(1);
X			}
X			DrawBox(x, y);
X			
X		    } else {
X			XtDispatchEvent(&event);
X		    }
X		} else {
X		    oX = x;
X		    oY = y;
X		    XQueryPointer(dpy, root, &tmp, &child, &x, &y,
X				  &junkX, &junkY, &state);
X		    if ((oX != x) || (oY != y)) {
X			if (exposed) {
X			    DrawZoom(1);
X			    exposed = False;
X			} else {
X			    DrawBox(oX, oY);
X			}
X			DrawBox(x, y);
X		    }
X		}
X	    }
X	    break;
X	}
X	case ZOOMIN : {
X	    extern void ResetValueDisplay();
X
X	    ResetValueDisplay();
X
X	    if (zoom > MINZOOM) {
X		zoom /= 2;
X		ZoomIt(zX, zY, 1);
X	    }
X	    break;
X	}
X	case ZOOMOUT : {
X	    extern void ResetValueDisplay();
X
X	    ResetValueDisplay();
X	    if (zoom < MAXZOOM) {
X		zoom *= 2;
X		ZoomIt(zX, zY, 1);
X	    }
X	    break;
X	}
X	case GRID : {
X	    grid = !grid;
X	    DrawZoom(1);
X	    break;
X	}
X	case CLEAR : {
X	    extern void Reset();
X
X	    Reset();
X	    break;
X	}
X	case QUIT : {
X	    XtUnmanageChild(widget);
X	    exit(1);
X	    break;
X	}
X    }
X}
X
X
X
Xstatic void Reset()
X{
X    int		n;
X    Arg		args[2];
X
X    if (image) {
X	XDestroyImage(image);
X	image = NULL;
X    }
X
X    XSetBackground(dpy, gc, white);
X    XClearWindow(dpy, win);
X
X    n = 0;
X    XtSetArg(args[n], XmNvalue, "  ");	n++;
X    
X    XtSetValues(pixelValue, args, n);
X    XtSetValues(rgbValue, args, n);
X}
X
X
X
X
X/*
X *	Build the pulldown menu
X */
Xstatic Widget MakeMenu(p)
X    Widget p;
X{
X    Widget 	bar;		/* menu bar */
X    Widget 	m; 		/* pulldown menu */
X    Arg 	args[10];	/* arg list */
X    int 	n = 0;		/* arg count */
X    Widget	label;
X
X    n = 0;
X    bar = XmCreateMenuBar(p, "menubar", args, n);
X
X    n = 0;
X    m = XmCreatePulldownMenu(bar, "m", args, n);
X
X    n = 0;
X    XtSetArg(args[n], XmNsubMenuId, m);	n++;
X    label = XmCreateCascadeButton(bar, "Actions", args, n);
X    XtManageChild(label);
X
X    /* create pulldown pushbuttons with callbacks */
X    n = 0;
X    grab = XmCreatePushButton(m, "Grab", args, n);
X    XtManageChild(grab);
X    XtAddCallback(grab, XmNactivateCallback, PushbuttonPressed, GRAB);
X
X    n = 0;
X    zoomIn = XmCreatePushButton(m, "Zoom In", args, n);
X    XtManageChild(zoomIn);
X    XtAddCallback(zoomIn, XmNactivateCallback, PushbuttonPressed, ZOOMIN);
X
X    n = 0;
X    zoomOut = XmCreatePushButton(m, "Zoom Out", args, n);
X    XtManageChild(zoomOut);
X    XtAddCallback(zoomOut, XmNactivateCallback, PushbuttonPressed, ZOOMOUT);
X
X    n = 0;
X    gridToggle = XmCreateToggleButton(m, "Grid", args, n);
X    XtManageChild(gridToggle);
X    XtAddCallback(gridToggle, XmNvalueChangedCallback,
X		  PushbuttonPressed, GRID);
X
X    n = 0;
X    clear = XmCreatePushButton(m, "Clear", args, n);
X    XtManageChild(clear);
X    XtAddCallback(clear, XmNactivateCallback, PushbuttonPressed, CLEAR);
X
X    n = 0;
X    quit = XmCreatePushButton(m, "Quit", args, n);
X    XtManageChild(quit);
X    XtAddCallback(quit, XmNactivateCallback, PushbuttonPressed, QUIT);
X
X
X    XtManageChild(bar);
X    XtSetSensitive(zoomIn,     False);
X    XtSetSensitive(zoomOut,    False);
X    XtSetSensitive(gridToggle, False);
X
X    return(bar);
X}
X
X
X
X
X/* 
X *	Resized window callback
X */
Xstatic XtCallbackProc ResizeCallback(widget, clientData, callData)
X    Widget			widget;
X    XtPointer			clientData;
X    XmDrawingAreaCallbackStruct	*callData;
X{
X    Dimension	width, height;
X    int		n;
X    Arg		args[3];
X    
X    n = 0;
X    XtSetArg(args[n], XmNwidth,  &width);	n++;
X    XtSetArg(args[n], XmNheight, &height);	n++;
X    XtGetValues(widget, args, n);
X
X    w = (int)width-1;				/* get new dimensions */
X    h = (int)height-1;
X    DrawZoom(1);				/* redraw window */
X}
X
X
X/* 
X *	Expose window callback
X */
Xstatic XtCallbackProc ExposeCallback(widget, clientData, callData)
X    Widget   			widget;
X    XtPointer			clientData;
X    XmDrawingAreaCallbackStruct	*callData;
X{
X    XExposeEvent	*event = (XExposeEvent *)(callData->event);
X    
X    exX = event->x;
X    exY = event->y;
X    exW = event->width;
X    exH = event->height;
X
X    DrawZoom(0);
X}
X
X
Xstatic void PixelPokeCallback(w, event, params, numParams)
X    Widget		w;
X    XButtonEvent	*event;
X    String		*params;
X    Cardinal		*numParams;
X{
X    u_int 	button;			/* which button was pressed */
X    Window 	tmp, child;		/* used in QueryPointer */
X    int 	x, y, 			/* cursor position */
X		junkX, junkY;		/* used in QueryPointer */
X    int		lastX, lastY;
X    short 	state;			/* used in QueryPointer */
X    int		done = 0;
X    extern void	DisplayPixelValue();
X    Dimension	width, height;
X
X    if (!init || !image) {
X	return;
X    }
X
X    {
X	int		n;
X	Arg		args[3];
X	
X	n = 0;
X	XtSetArg(args[n], XmNwidth,  &width);	n++;
X	XtSetArg(args[n], XmNheight, &height);	n++;
X	XtGetValues(w, args, n);
X    }
X
X    button = event->button;
X    
X    XSync(dpy, False);
X    XQueryPointer(dpy, win, &tmp, &child, &x, &y,
X		  &junkX, &junkY, &state);
X
X    lastX = junkX;
X    lastY = junkY;
X
X    DisplayPixelValue(junkX, junkY);
X
X    while (!done) {
X	XEvent	event;
X
X	XSync(dpy, False);
X	
X	if (XtAppPending(appContext))  {
X	    XtAppNextEvent(appContext, &event);
X
X	    switch (event.type) {
X		case ButtonRelease : {
X		    if (((XButtonEvent *)(&event))->button == button) {
X			done = 1;
X			return;
X		    }
X		    break;
X		}
X		case ButtonPress : 
X		case KeyPress    : {
X		    break;
X		}
X		default : {
X		    XtDispatchEvent(&event);
X		    break;
X		}
X	    }
X	} else {
X	    XQueryPointer(dpy, win, &tmp, &child, &x, &y,
X			  &junkX, &junkY, &state);
X	    if ((junkX != lastX ||
X		 junkY != lastY) &&
X		junkX >= 0 && junkX < (int)width &&
X		junkY >= 0 && junkY < (int)height) {
X		DisplayPixelValue(junkX, junkY);
X		lastX = junkX;
X		lastY = junkY;
X	    }
X	}
X    }
X}
X
X
Xstatic void DisplayPixelValue(x, y)
X    int	x, y;
X{
X    u_long	pixel;
X
X    char	pixelStr[80];
X    char	rgbStr[80];
X    int 	minDim = w < h ? w : h;
X    u_int	xSize = minDim / zoom;		  /* size of zoomed pixels */
X    u_int	ySize = minDim / zoom;
X    int 	xOffset = (w - zoom * xSize) / 2; /* centers image in window */
X    int		yOffset = (h - zoom * ySize) / 2;
X    int		row, column;
X    Dimension	width, height;
X    int		n;
X    Arg		args[3];
X    
X    if (!init) {
X	return;				/* no image grabbed yet */
X    }
X
X    n = 0;
X    XtSetArg(args[n], XmNwidth,  &width);	n++;
X    XtSetArg(args[n], XmNheight, &height);	n++;
X    XtGetValues(work, args, n);
X
X    
X    if (xSize < 1) {
X	xSize = 1;
X    }
X    if (ySize < 1) {
X	ySize = 1;
X    }
X
X    column = ((float)((x - xOffset)))/((int)width - xOffset - xOffset) * zoom;
X    row = ((float)((y - yOffset)))/((int)height - yOffset - yOffset) * zoom;
X
X    if (x >= xOffset && y >= yOffset &&
X	row >= 0 && row < zoom && column >= 0 && column < zoom) {
X	
X	if (column != lastColumn || row != lastRow) {
X	    lastColumn = column;
X	    lastRow = row;
X
X	    pixel = XGetPixel(image, column, row);
X	    
X	    sprintf(pixelStr, "%d", pixel);
X	    
X	    {
X		XColor	color;
X		
X		color.pixel = pixel;
X		XQueryColor(dpy, cMap, &color);
X		
X		sprintf(rgbStr, "%d %d %d",
X			color.red/256, color.green/256, color.blue/256);
X	    }
X	    
X	    n = 0;
X	    XtSetArg(args[n], XmNvalue, pixelStr);	n++;
X	    XtSetValues(pixelValue, args, n);
X	    
X	    n = 0;
X	    XtSetArg(args[n], XmNvalue, rgbStr);	n++;
X	    XtSetValues(rgbValue, args, n);
X	} 
X    } else {
X	n = 0;
X	XtSetArg(args[n], XmNvalue, "  ");	n++;
X	
X	XtSetValues(pixelValue, args, n);
X	XtSetValues(rgbValue, args, n);
X	
X    }
X}
X    
X
X
Xstatic void ResetValueDisplay()
X{
X    /*
X     *  This call will force the "Pixel" and "RGB"
X     *  strings to be "erased", because the arguments
X     *  put the cursor outside the window, causing
X     *  null strings to be displayed.
X     */
X    DisplayPixelValue(-100, -100);
X
X    lastRow    = -1;
X    lastColumn = -1;
X}
END_OF_FILE
if test 23199 -ne `wc -c <'xmag.c'`; then
    echo shar: \"'xmag.c'\" unpacked with wrong size!
fi
# end of 'xmag.c'
fi
if test -f 'xmag.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xmag.man'\"
else
echo shar: Extracting \"'xmag.man'\" \(1906 characters\)
sed "s/^X//" >'xmag.man' <<'END_OF_FILE'
X.TH XMAG 1 "Release 4" "X Version 11"
X.SH NAME
X.B xmag - 
XX Window System Screen Magnification Program
X.PP
X.SH SYNOPSIS
X.ta 8n
X\fBxmag\fP	[-\fItoolkit option\fP ...] 
X.PP
X.SH DESCRIPTION
X.I Xmag
Xis an application which allows square regions of the screen to be 
Xmagnified, and which shows the pixel value and RGB value for each
Xmagnified pixel. 
X.SH MENU
X.PP
XUse the left mouse button to activate the pull down menu.
X.PP
X.IP Grab 0.95i
Xgrabs the pointer.
XThe cursor will change to a crosshair.
XA square box the size of the region to be magnified will track
Xthe cursor.  Press the 
X.I left mouse button 
Xto magnify the desired region.
XPress the 
X.I right mouse button 
Xto ungrab the pointer.  
X.PP
X.IP "Zoom In" 0.95i
Xhalves the resolution.
X.PP
X.IP "Zoom Out" 0.95i
Xdoubles the resolution.
X.PP
X.IP "Grid On/Off" 0.95i
Xtoggles a grid overlay.
X.IP "Clear" 0.95i
Xclears the xmag window.
X.PP
X.IP Quit 0.95i
Xexits the application.
X.PP
X.PP
X.SH NOTES
XUse 
X.I Zoom In 
Xand 
X.I Zoom Out 
Xto adjust the dimensions of the magnifaction box.
X.PP
XResizing the window, affects the size, and not the number of magnified pixels.
X.PP
X.I Looking at pixel values
XWhen there is an image xmag display area, holding the mouse button
Xdown with the cursor in the xmag window will result in the pixel value
X(for the pixel at the current cursor location) being displayed at the
Xbottom of the xmag window, as well as the RGB value for that pixel.
X.PP
X.PP
X.SH BUGS
XIf you specify a size (with the -geometry flag) that is smaller
Xthan the normal/default size, there may not be enough room in the
Xwindow for the pixel value and RGB value display strings.
X.PP
X.SH AUTHOR
XCopyright 1988, 1991, Danny Shapiro and Philip Schneider
X.PP
X.nf
XDanny Shapiro
XDigital Equipment Corporation
XWorkstation Systems Engineering
XPalo Alto, CA  94301
X
XPhilip Schneider
XDigital Equipment Corporation
XAdvanced Technology Development
XPalo Alto, CA  94301
X
X.fi
END_OF_FILE
if test 1906 -ne `wc -c <'xmag.man'`; then
    echo shar: \"'xmag.man'\" unpacked with wrong size!
fi
# end of 'xmag.man'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Molecular Simulations, Inc.             mail: dcmartin@msi.com
796 N. Pastoria Avenue                  uucp: uunet!dcmartin
Sunnyvale, California 94086             at&t: 408/522-9236
