Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: envbvs@bea.lbl.gov (Brian V. Smith)
Newsgroups: comp.sources.x
Subject: v16i012: Xfig 2.1.3, Part07/25
Message-ID: <1992Feb4.145831.602@msi.com>
Date: 4 Feb 92 14:58:31 GMT
References: <csx-16i006-xfig-2.1.3@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1554
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: envbvs@bea.lbl.gov (Brian V. Smith)
Posting-number: Volume 16, Issue 12
Archive-name: xfig-2.1.3/part07

# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
#		"End of archive 7 (of 25)."
# Contents:  CHANGES mode.h w_drawprim.c
# Wrapped by dcmartin@fascet on Tue Feb  4 06:42:28 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CHANGES'\"
else
echo shar: Extracting \"'CHANGES'\" \(24998 characters\)
sed "s/^X//" >'CHANGES' <<'END_OF_FILE'
XVersion 2.1
X===========
X
XPatchlevel 3
XChanges to Patchlevel 2:
X
Xo pressing carriage return in value part of popup indicator buttons that take 
X	integer or float (e.g. line width) now sets the value and pops down
Xo added foreground colors to Text*, Menu* and List* widgets in default Fig-color.ad
X	this fixes problem of white-on-white text when using inverse video
Xo changes two resource names -
X	"xfig_export_menu.export_panel.just_label.flush left" to 
X	"xfig_export_menu.export_panel.just_label.justify" 
X	and 
X	"xfig_print_menu.print_panel.just_label.flush left" to
X	"xfig_print_menu.print_panel.just_label.justify"
Xo some type castings fixed
X	from Wayne D Richardson (wdr@rchland.vnet.ibm.com)
Xo fixed "open file leak" - directory wasn't closed after file popup finished
Xo fixed selection of Times-Roman font under Openwindows
Xo changed titles of popup panels to meaningful names
Xo leading blanks no longer stripped from text objects
X	from George Ferguson (ferguson@cs.rochester.edu)
Xo null strings in text objects now abort load/read of file with error message
X	from George Ferguson (ferguson@cs.rochester.edu)
Xo conditional in xfig.man to set page offset only when using troff
X	from George Ferguson (ferguson@cs.rochester.edu)
Xo added translation so that pressing return in filename window in popup FILE
X	will load the file
Xo added translation so that pressing return in filename window in popup EXPORT
X	will export the file
Xo fixed filled objects of DEFAULT color
Xo fixed bug in delete region
X	from Peter Asenstorfer (peter@audrey.levels.unisa.edu.au)
Xo cleaned up cursor stuff - no impact on user
X	from Brian Boyter (pyrdc!bimbo!boyter@uunet.UU.NET)
Xo new resource "-keyFile" to specify alternate compose key translation
X	file in the XFIGLIBDIR directory
X	From Herve Soulard (soulard@corto.inria.fr)
Xo popup message window to inform user when illegal values in figure file
X	are fixed or when converting from older file versions to newest
Xo limit on depth of objects to 1000 when reading figure file. Fixes problems
X	of infinite looping for files which were converted from Fig 2.0.
X	Also sets depth to zero (0) when reading files older than 2.1.
Xo xfig.man now tells man to run tbl so that regular tables can be used
X	from James B. Davis (james@solbourne.com)
Xo fixed Meta-Y (insert current selection), ^Y (unkill) and ^G (multiply reset) 
X	in CompKeyDB
Xo added capability to delete whole text line from text widgets with ^X
X	from Brian Boyter (pyrdc!bimbo!boyter@uunet.UU.NET)
Xo ^U no longer deletes line of text in text object mode for compatibility
X	with text widgets.  Use only ^X now.
Xo fixed problem with OpenWindows and rubberbanding objects
X	from Brian Boyter (pyrdc!bimbo!boyter@uunet.UU.NET)
Xo fixed minor bug in f_util.c line 82: assignment with '==' instead of '='
X        from pf@diab.se (Per Fogelstr|m)
Xo fixed up bug in set_tags call in w_modepanel.c
X	from Graeme Gill (graeme@labtam.labtam.oz.au)
Xo added strstr() function for systems without it
Xo warning message about redefining InstallManPage fixed
Xo removed unneeded O_NONE symbol from object.h
Xo directory code fixed to work with SVR4
X	from David Elliot (dce@krusty.smsc.sony.com)
Xo cleaned up function declarations for event handlers
X	from Anthony Datri (datri@lovecraft.convex.com)
Xo renamed Fig-co.ad to Fig-color.ad for color customization under X11R5 (see 
X	README). Fig-co.ad can be deleted (if you have an older copy of xfig)
X	from David Elliot (dce@krusty.smsc.sony.com)
X
X------------------------------------------------------------------------------
XPatchlevel 2
XChanges to Patchlevel 1:
X
Xo the font flag (LaTeX, PostScript) wasn't being changed correctly in the
X	UPDATE text object operation when switching from LaTeX to PostScript 
X	or vice versa.
X
Xo the textstep value may now be entered in floating point in the popup menu
X
Xo the eps-bitmap icon was renamed to eps-object because it can be any
X	eps object that is imported.  If it has a preview bitmap
X	that will be displayed.  Several filenames/program variables
X	were also changed to reflect this.
X
Xo there is now a more general glue mechanism for compounding objects
X
Xo text pasting into canvas now possible with F18 function key or any translation
X	desired by user.  F18 is hardwired default in program; F20 also 
X	programmed in Fig.ad to paste text.
X	Brian Boyter (pyrdc!bimbo!boyter@uunet.UU.NET)
X
Xo DEFAULT fill_style caused core dump 
X	from Jeffry R. Abramson (jra@violin.att.com)
X
Xo made the mouse-tracking markers hollow so as not to be visually obtrusive
X	as suggested by Stephen Gildea (gildea@expo.lcs.mit.edu)
X
Xo removed extraneous call to free() in add_point() (u_draw.c)
X	from Per Fogelstr|m (pf@diab.se)
X
Xo cleaned up gcc compiler warnings about type mismatches etc.
X
Xo compound objects may be rotated by arbitrary angles if there are no boxes, 
X	arc-boxes, ellipses or circles contained within.
X
Xo text rotation support is improved - markers are now shown rotated and
X	the angle attribute is set by the relevant rotate operations.
X
Xo both ps and eps modes now supported in export menu.
X
Xo new directory browsing facilities integrated with File and Export popups.
X	Allows selection of file by clicking on the filename.  Has mask to list
X	only those files of interest.  See the man pages for further details.
X
Xo Default font for Postscript fonts may now be selected and objects that
X	have default font may be edited
X
Xo FASTSERVER flag removed; now always uses smart redrawing when available
X	Additionally, smart redrawing is available more often
X
Xo fixed bug in regular polygon where some vertices were off by one pixel
X
Xo added "Use orig. size" button for eps objects to set object to original 
X	size in popup edit
X	from Peter Scott (pjs@euclid.jpl.nasa.gov)
X
Xo international characters supported (umlauts, accents, cedilla etc) using
X	compose (meta) key
X	from Herve Soulard (soulard@corto.inria.fr)
X
Xo much improved color support
X	from Henning Spruth (hns@regent.e-technik.tu-muenchen.de)
X
Xo additional pan and zoom mode with <Ctrl>Key and left/middle/right button
X	from Henning Spruth (hns@regent.e-technik.tu-muenchen.de)
X
Xo removed reference to FONTLIBDIR in Imakefile (no longer required)
X
Xo added a smart-links feature for the MOVE and COPY commands.
X	With smart links turned on, when a BOX-like object is moved
X	so are the lines which join up to it (its links).
X	Two modes are supported: one which moves just the endpoint,
X	the other slides the endlink so that it's angle doesn't change.
X	In the second mode horizontal/vertical lines remain that way.
X
Xo added the ability to save figure during quit if it is modified
X
Xo added support for scalable fonts under R5
X
Xo additional command line flags supported
X	-latexfonts flag (resource .latexfonts) to start xfig with the LaTeX
X	fonts as the default instead of PostScript fonts
X	-specialtext flag (resource .specialtext) to start xfig with special
X	text as the default
X
Xo bug fixed where number of objects count in file popup was sometimes clipped
X
X------------------------------------------------------------------------------
XPatchlevel 1
XChanges to Patchlevel 0:
X
Xo xfig now reads text size, height and length as floats and rounds to ints
X	this is done because certain programs generate floats for these
X
Xo compound object was rounded to next larger grid even if objects inside were
X	already on the grid
X
Xo Examples/logo.fig included Logo.eps instead of logo.eps
X
Xo cancellation of line drawing left single dot on screen
X
Xo filename in File popup menu didn't get set until first popup - file save 
X	shortcut would save to unnamed.fig even if xfig was started with file name
X
Xo bug fixed in not being able to delete points from certain objects
X
Xo typo in FORMAT2.1 file (and all previous) stating that text angle is int when
X	it is really float
X
Xo can now change corners of compound object with edit popup
X	also shows number of objects inside compound
X
Xo file menu now shows number of objects in figure
X
Xo some bugs fixed in calculating bounding boxes after scaling ellipses and 
X	compounds
X
Xo "#ifdefined SYSV" now reads "#if defined(SYSV) || defined(SVR4)" because X11R5
X	doesn't define SYSV if SVR4 is defined
X	David Elliott (dce@krusty.smsc.Sony.COM)
X	
Xo object depths < 0 are converted to depth = 0
X
Xo typo in Adobe font name (was "-abode-new century schoolbook-medium-r-*--*")
X	Jan Lindheim (lindheim@ccsf.caltech.edu)
X
Xo radius field for non-arcbox line objects now set to -1
X	Jan Nusteling (j.nusteling@et.tudelft.nl)
X
Xo bug fixed in not trying to load an eps bitmap file called <empty>
X	and not trying to reload an eps bitmap during a copy.
X
Xo bug fixed which caused crash after editing 0-width or 0-height ellipses
X
Xo bug fixed which caused incorrect mode after cancelling draw (int)spline
X
Xo bug fixed which caused incorrect minimum number of points for (int)spline
X
Xo bug fixed which caused erroneous large values to occur after box scale of
X	0-width or 0-height objects.  You can no longer box scale such objects
X
X------------------------------------------------------------------------------
XPatchlevel 0
XChanges to Version 2.0 Patchlevel 10:
XImplemented by Paul King (king@cs.uq.oz.au) and
XBrian Smith (envbvs@epb7.lbl.gov) with help from
XMicah Beck (beck@cs.cornell.edu) and
XBrian Boyter (pyrdc!bimbo!boyter@uunet.UU.NET) (EPS code).
X
XUSER INTERFACE
X--------------
X
Xo The buttons are now grouped into three panels:
X
X    COMMAND panel:
X        Quit, Delete all, Undo, Redraw, Paste, File popup, Export popup and 
X		Print popup buttons.  See man pages for details.
X		(see "Drawing Modes", below for description of Cut)
X    MODE panel:
X	Allow the user to select the current drawing or editing mode.
X    INDICATOR panel:
X	By default shows indicator buttons relevant to the current mode.
X	Each indicator button displays current setting of some quantity
X	(e.g. line width, area-fill) and allows it to be changed:
X        left button gives popup menu to select setting,
X        middle/right buttons provide a shortcut to inc/decrement settings.
X
Xo Pan figure by using left/middle/right button in the rulers in addition to
X	the previously supported arrow keys.  Also a pan to origin operation
X	is available by clicking in the units window (or using HOME key).
X
Xo May now print figure that hasn't been saved (i.e. print what is on the 
X	canvas, not the file)
X
Xo Zoom up or down with zoom button.
X
Xo Mouse function window shows function of active buttons
X
Xo New resources/command-line switches which affect the user interface:
X	-showallbuttons		(show all indicator buttons all the time)
X	-internalBW n		(use lines of width n between buttons/panels)
X
XDRAWING MODES
X-------------
X
Xo Regular polygon drawing button - select number of sized from bottom panel.
X        Object created is normal xfig polygon.
X
Xo Inclusion of Encapsulated Postscript files (bitmap image in EPS file is
X	displayed).
X
Xo Rubberbanding of ellipses/circles.
X
Xo Filled splines show areafill on screen now
X        also dashed/dotted line type shows on screen
X
Xo Dot-gap and dash-length can be changed in the line-style indicator popup.
X
XEDITING MODES
X-------------
X
Xo Cut to buffer operation is now part of Copy object mode & Delete object mode.
X
Xo Update button to either update objects to current settings, or update
X        indicator settings from an object.
X
Xo Rotation of certain objects by any angle (30, 45, 60, 90, 120 degrees can
X	be selected using the mouse middle/right shortcut buttons).
X
Xo Alignment horizontally and/or vertically of objects to compound object edge(s)
X
Xo Objects can be scaled (not just compounds).
X
Xo Point move or object copy/move constrainable to horizontal or vertical
X	movement (middle mouse button)
X
Xo Compound bounding corners shrink to fit enclosed objects and have markers
X	that appear the same as other objects.
X
Xo Shift-click selection should work on all editing operations.
X
Xo Only the objects relevant to a particular editing operation will
X	have their markers shown.
X
XOVERALL OPERATION
X-----------------
X
Xo Smarter redrawing (if compiled with -DFASTSERVER).
X	Only the relevant objects are redrawn after an expose or after
X	an edit operation (not all operations support this yet).
X
Xo Undo should work for all commands.
X
Xo Operations can now be cancelled (using the right button when appropriate).
X
Xo Point positioning to three resolutions:
X	magnet (1/16inch), small grid or large grid
X
Xo TransFig 2.1 features: LaTex fonts, hidden text, scalable text, "special" text
X        see TransFig man pages for description
X        scalable text sizes with resizing of figure
X
Xo Attempts to save figure if signal detected (segmentation violation, etc)
X
Xo Resizing the xfig window should now be a bit smarter.
X
Xo The philosophy behind button usage has changed. This was necessary to
X	provide a consistent (as possible) philosophy which supports the
X	use of several buttons per mode.  Now the same button used to start
X	an edit/draw operation is used to continue to the normal next step
X	in the operation.  The right button can be used to cancel an operation.
X	Watch the mouse function window until you get the hang of it.
X
X------------------------------------------------------------------------------
X------------------------------------------------------------------------------
XVersion 2.0
X===========
X
XPatchlevel 10
XChanges from patchlevel 9:
X
Xo zooming and panning is now possible for all objects except texts.
X    Use new buttons, arrow keys for panning. See the man page.
X    From Henning Spruth (hns@regent.e-technik.tu-muenchen.de)
Xo selecting one of several overlapping objects is implemented for
X    most functions.
X    Hold down Shift key while clicking on object to cycle through
X    candidate objects, release shift key for selection. See man page.
X    From Henning Spruth (hns@regent.e-technik.tu-muenchen.de)
Xo dash length and dot gap width can be modified using the Change menu
X    From Dieter Pellkofer (dip@regent.e-technik.tu-muenchen.de)
Xo dash length scaled to line width and zoom factor
X    From Henning Spruth (hns@regent.e-technik.tu-muenchen.de)
Xo multiple Grid Sizes
X    Two grids are available in the -metric mode
X    From Dieter Pellkofer (dip@regent.e-technik.tu-muenchen.de)
Xo open polygons and splines can be filled
X    From Dieter Pellkofer (dip@regent.e-technik.tu-muenchen.de)
Xo new resource 'Startfontsize' and command line option -startfontsize
X    From Georg Sigl (ges@regent.e-technik.tu-muenchen.de)
Xo point markers displayed with text objects
X    From Henning Spruth (hns@regent.e-technik.tu-muenchen.de)
Xo grid and ruler bitmaps are created dynamically
X    This was neccessary for the zoom and pan commands
X    From Henning Spruth (hns@regent.e-technik.tu-muenchen.de)
Xo changing text by clicking on it has to be finished with the left
X    button. Finishing with the middle button is no longer possible
X    (this is rather a workaround for the bug that gave interesting 
X    effects)
X    From Henning Spruth (hns@regent.e-technik.tu-muenchen.de)
Xo if a point is to be deleted from a line, at least 2 points must remain
X    From Dieter Pellkofer (dip@regent.e-technik.tu-muenchen.de)
Xo fixed bug where finishing text with middle button, saving figure
X    and trying to quit made xfig claim the figure hadn't been saved
Xo fixed bug where line of zero length with an arrow head would cause f2ps 
X    to divide by zero
Xo there is a bug in OpenWindows which causes xfig to crash when trying to 
X    create the pixmaps from one-plane bitmaps for the button icons.  According
X    to the Intrinsics manual, the XtNbitmap resource in a widget will auto-
X    matically be converted to the proper screen depth, but OpenWindows seems
X    not to do this.  Add the define "-DOPENWIN" to the "DEFINES" line
X    in the Imakefile if you are running OpenWindows.
Xo depth of objects is now honored - set object depth with popup change window
X    From Mike Lutz <mjl@cs.rit.edu>
Xo bug fixed where "create object -> read file -> undo" would delete objects
X    Tom Tkacik (tkacik@hobbes.cs.gmr.com)
Xo creation of text is now undoable
Xo text inside compound is erased properly when compound is moved/deleted etc
Xo f2ps now uses the -s (font size) option when objects are defined
X    with default font size (-1)
X    From Ian Dall <idall@augean.ua.oz.au>
Xo font spacing button value no longer crashes xfig on MIPS type machine
Xo having spline where two or more points are coincident no longer
X    gives DOMAIN error or crashes xfig
X    From Mike Lawley <lawley@muse.cs.mu.oz.au>
Xo attempting to draw arc with two or more coincident points no longer 
X    crashes xfig
Xo definition of errno, sys_nerr and sys_errlist moved to fig.h
X    From Casey Leedem <casey@gauss.llnl.gov>
Xo removed startup message printing to stdout
X
XPatchlevel 9
XChanges from patchlevel 8:
X
Xo New feature for cutting/pasting objects from figures between xfig processes.
X    Select COPY/PASTE from the popup menu.  See the man page.
X    From Tom Tkacik (tkacik@kyzyl.mi.org)
Xo New automatic text line spacing feature moves text input cursor
X    to next line (properly centered, or left/right justified) when
X    <CR> is input and automatically re-enters text input mode.
X    From Jon Tombs <jon@robots.oxford.ac.uk>
Xo print button now calls fig2dev when xfig is compiled with -DTFX option
X    From Doug Flanagan (flanagan@cs.cornell.edu)
Xo Arrows on lines, arcs, etc. are not be corrupted anymore when copying 
X    or changing objects
Xo proper centering of figures in postscript printing
X    From Mark Maybe (markm@boulder.colorado.edu)
Xo redundant $(DESTDIR) removed from Imakefile for installing troff fonts
Xo reading figure file no longer loops infinitely if text object is missing ^A
X    From Kenneth H. Carpenter (khc@eece.ksu.edu)
Xo more SYSV compatibility fixes
X    From David Elliot (dce@icky.Sony.COM)
Xo uses 'lp' printer command for print button under SYSV
X    From Bo Thide' (bt@irfu.se)
Xo object image in change object popup menu fixed (caused problems on MIPS
X    and some other machines)
X    From Ivan Herman (ivan@cwi.nl) and David Elliot (dce@icky.Sony.COM)
X
XPatchlevel 8
XChanges from patchlevel 7:
X
Xo Many bugs fixed with flipping arcs, malloc/free, popup menu 
X    going off screen, gcc warnings, etc.
X    From Isamu Wada <i-wada@srans3.sra.co.jp>
Xo Bug fixed in redisplay.c where all but the most recently created
X    compounds' objects were invisible
Xo Changed code that assumed a (char *) return value for sprintf
X    to follow POSIX and ANSI C standard of returning int.
Xo Removed conditional compilation flags for R3, since R3 is no
X    longer supported :-(
Xo Moved initializing of Fig icon in main() to work with mwm
X    From David Elliot <dce@smsc.sony.com>
Xo f2p and f2ps now return meaningful error codes: 0 for OK, 1 for error
Xo Errors in reading figure file should report correct line numbers now
Xo Handles "default" font for TransFig correctly
Xo Text input is now correctly terminated whenever a menu item is chosen,
X    not just on CR or middle-button pressed
Xo troff_ft_codes files allows ANY white space between troff font name
X    and Postscript fone name
Xo Attempting to move the center point of circle/ellipse with move-point 
X    no longer makes point markers disappear
Xo BoundingBox computed correctly for centered and right-justified text now
X    for f2ps and save-as-bitmap
X    From Tom Tkacik
Xo Font names output by f2p and f2ps fixed for -TFX option.
X    From Guy Cardwell
Xo Object icon displayed in change-object popup menu
Xo Removed rounded-corner boxes from TFX compile-time option and reverted
X    protocol version to 1.4-TFX, as per Micah Beck (beck@cs.cornell.edu) 
X
XPatchlevel 7 (4/26/90)
XChanges from patchlevel 6:
X
Xo New patch files for psfonts.c, panel.h to fix problems with those
X    files in patch level 6
Xo The patch for search.c in patch 6 was an old patch and should
X    not be applied
Xo Bug fix for f2ps where figure went off the page in landscape mode
X
XPatchlevel 6 (4/25/90)
XChanges from patchlevel 5:
X
Xo *** New popup menu to change characteristics of existing objects, 
X   e.g. line thickness, style, text options, area fill etc.
X   Not ALL things may be modified yet (e.g. arrows on lines).
X   Jon Tombs and Frank Schmuck provided this much-needed feature
Xo Because the popup menu uses the new Simple Menu widget from R4, xfig
X   will no longer compile under R3
Xo Fixed WMHints to "or" in InputHint to retain any existing Hints
X  Thanks to David Elliott
Xo Doesn't let one delete to fewer than 3 points in interpolated spline
Xo Removed unused variables
Xo Changed rounded-corner box objects to have radius component instead 
X   of using the pen component (new protocol version 2.0 and 2.0-TFX)
Xo Added back support to read protocol version 1.3 files
Xo Fixed bug where the line style wasn't passed in drawing bounding 
X   rectangle when moving/copying objects
Xo Fixed cursor for popup command menu
Xo Fixed bounding box bug for postscript output from f2ps
Xo Fixed bug that erroneously allowed filled polylines (only polygons, boxes,
X   round-corner boxes, ellipses, circles, closed splines and arcs may be filled)
Xo Fixed name of AvantGarde-Book font (was AvantGarde)
Xo Added two X fonts that are similar to AvantGarde... and Palatino...
X   From Dave Davey 
Xo Fixed bug that caused coredump when referencing a zero-radius ellipse
Xo Added back the LaTex buttons even for non-TFX mode
Xo More SYSV #ifdefs from Scott E. Garfinkle (dacseg@uts.amdahl.com)
Xo New rule in Imakefile to install troff_ft_codes file
Xo put_fmsg() uses double arguments instead of float to prevent some 
X    systems from choking on float-double-float conversions of invalid data.
Xo 8-bit characters allowed for text objects
X    From Tor Lillqvist <tml@hemuli.tik.vtt.fi>
X
XPatchlevel 5 (3/27/90)
XChanges from patchlevel 4:
X
Xo Line widths of zero now allowed for drawing borderless objects
Xo Resources now parsed in more portable way
Xo Variable "compound" changed to "cmpnd" in drag.c and search.c because 
X    SunOs 4.1 has function called compound()
Xo Unknown "-" options no longer parsed as file name
Xo Filled areas now drawn opaquely instead of transparently
Xo Ruler arrows now drawn correctly
Xo Area fill for rounded corner boxes displays properly
Xo Lower panel buttons and rulers slightly smaller to allow 9.5 inch tall
X  canvas in portrait mode on screens that are "only" 864 pixels tall
Xo Imakefile now uses XawClientDepLibs instead of $(DEPXAWLIB) $(DEPXMUlIB) ...
Xo -1 for area fill (no fill) in TransFig files handled properly
Xo u_int defined as uint for SYSV systems
Xo 'figure_modified' flag cleared when editing new file
Xo If "save in" is done and there is no current file name, then the
X  current file name is set to the one specified in the save
Xo -track default is now True as man entry states
Xo side panel resource renamed to side_panel
Xo fixed bug in f2ps where filled arcs weren't filled
Xo line width and font support for f2p (pic)
X  Thanks to Dave Davey for these additions
X
XPatchlevel 4 (3/12/90)
XChanges from patchlevel 3:
X
Xo Bug fixed in drawing zero-length lines with arrows
X    Thanks to Dave Davey for this fix
Xo Portrait/Landscape bug fixed (only appeared on Sun 4)
Xo Fig will not allow edit of new figure without confirmation if
X    current figure has been modified
Xo Widget resources work better now (e.g. xfig.form.indicator.background: green)
Xo -ri option for button panel on right side works properly now
Xo Changed some widget names for better resource hierarchy
Xo Wrapped indicator widgets in box widget
Xo Adds compatibility with Fig 1.4-TFX file format INSTEAD of 1.4X
X  as a compile time option (compiler flag -DTFX).  No change to program
X  as compiled without the -DTFX flag.  See file README.TFX.
X    Credit goes to Micah Beck (beck@cs.cornell.edu) for this one.
Xo Fixed bug where scanf was doing %lf for text angle instead of %f
X  in read_textobject()
X    Thanks to Leroy Hugues (Hugues.Leroy@irisa.fr) for this fix
Xo #include <X11/Scroll.h> put back in fig.h for R3 - XtRFloat is defined here
Xo XtPointer is only defined in R4 - uses caddr_t for R3 blink() routine
Xo Print figure on default printer, specify particular printer or print to file
X    Thanks to Daren Latham (dwl@udev.cdc.com) for this one
Xo Original FORMAT1.4 file included to compare new 1.4X format with 1.4
X  New file that describes xfig file format is called FORMAT1.4X
Xo Drawing too-narrow ellipses doesn't loop forever anymore, but they
X  are still not drawn correctly
X
XPatchlevel 3 (2/28/90)
XChanges from patchlevel 2:
X
Xo now uses XtAddTimer instead of setitimer() for blinking cursor
X  This fixes the problem with text freezing up xfig or crashing with core dump
Xo Changed include directives for Athena widgets to include/X11/Xaw directory
Xo added put_fmsg() to print messages with floating point numbers
X  Some machines (MIPS) were dumping core when passing floats as ints.
X
XPatchlevel 2 (2/23/90)
XChanges from patchlevel 1:
X
Xo removed call to free() in curve() which was causing coredumps
Xo Imakefile had .o filenames in SRCS definition
X
X
XPatchlevel 1 (2/20/90)
XChanges from patchlevel 0:
X
Xo included definition of put_msg()/FREE/CFREE in f2ps.c
END_OF_FILE
if test 24998 -ne `wc -c <'CHANGES'`; then
    echo shar: \"'CHANGES'\" unpacked with wrong size!
fi
# end of 'CHANGES'
fi
if test -f 'mode.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mode.h'\"
else
echo shar: Extracting \"'mode.h'\" \(4448 characters\)
sed "s/^X//" >'mode.h' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of M.I.T. not be used in advertising or
X * publicity pertaining to distribution of the software without specific,
X * written prior permission.  M.I.T. makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty."
X *
X */
X
X/******************  modes  ******************/
X
X#define		F_NULL			0
X#define	    FIRST_DRAW_MODE	    F_CIRCLE_BY_RAD
X#define		F_CIRCLE_BY_RAD		1
X#define		F_CIRCLE_BY_DIA		2
X#define		F_ELLIPSE_BY_RAD	3
X#define		F_ELLIPSE_BY_DIA	4
X#define		F_CIRCULAR_ARC		5
X#define		F_POLYLINE		6
X#define		F_BOX			7
X#define		F_POLYGON		8
X#define		F_TEXT			9
X#define		F_SPLINE		10
X#define		F_CLOSED_SPLINE		11
X#define		F_INTSPLINE		12
X#define		F_CLOSED_INTSPLINE	13
X#define		F_ARC_BOX		14
X#define		F_REGPOLY		15
X#define		F_EPSOBJ		16
X#define	    FIRST_EDIT_MODE	    F_GLUE
X#define		F_GLUE			30
X#define		F_BREAK			31
X#define		F_SCALE			32
X#define		F_ADD			33
X#define		F_COPY			34
X#define		F_MOVE			35
X#define		F_DELETE		36
X#define		F_MOVE_POINT		37
X#define		F_DELETE_POINT		38
X#define		F_ADD_POINT		39
X#define		F_DELETE_ARROW_HEAD	40
X#define		F_ADD_ARROW_HEAD	41
X#define		F_FLIP			42
X#define		F_ROTATE		43
X#define		F_AUTOARROW		44
X#define		F_CONVERT		45
X#define		F_CHANGE		46
X#define		F_UPDATE		47
X#define		F_ALIGN			48
X#define		F_ZOOM			49
X#define		F_LOAD			50
X#define		F_EDIT			50
X
Xextern int	cur_mode;
X
X/* alignment mode */
X#define		NONE			0
X#define		LEFT			1
X#define		TOP			1
X#define		CENTER			2
X#define		RIGHT			3
X#define		BOTTOM			3
X
Xextern int	cur_halign;
Xextern int	cur_valign;
X
X/* angle geometry */
X#define		L_UNCONSTRAINED		0
X#define		L_LATEXLINE		1
X#define		L_LATEXARROW		2
X#define		L_MOUNTHATTAN		3
X#define		L_MANHATTAN		4
X#define		L_MOUNTAIN		5
X
Xextern int	manhattan_mode;
Xextern int	mountain_mode;
Xextern int	latexline_mode;
Xextern int	latexarrow_mode;
X
X/* arrow mode */
X#define		L_NOARROWS		0
X#define		L_FARROWS		1
X#define		L_FBARROWS		2
X#define		L_BARROWS		3
X
Xextern int	autoforwardarrow_mode;
Xextern int	autobackwardarrow_mode;
X
X/* grid mode */
X#define		GRID_0			0
X#define		GRID_1			1
X#define		GRID_2			2
X
Xextern int	cur_gridmode;
X
X/* point position */
X#define		P_ANY			0
X#define		P_MAGNET		1
X#define		P_GRID1			2
X#define		P_GRID2			3
X
Xextern int	cur_pointposn;
Xextern int	posn_rnd[P_GRID2 + 1];
Xextern int	posn_hlf[P_GRID2 + 1];
Xextern int	grid_fine[P_GRID2 + 1];
Xextern int	grid_coarse[P_GRID2 + 1];
Xextern char    *grid_name[P_GRID2 + 1];
X
X/* rotn axis */
X#define		UD_FLIP			1
X#define		LR_FLIP			2
X
Xextern int	cur_rotnangle;
X
X/* smart link mode */
X#define		SMART_OFF		0
X#define		SMART_MOVE		1
X#define		SMART_SLIDE		2
X
Xextern int	cur_linkmode;
X
X/* misc */
Xextern int	action_on;
Xextern int	highlighting;
Xextern int	aborting;
Xextern int	anypointposn;
Xextern int	figure_modified;
Xextern int	cur_numsides;
X
Xextern void	reset_modifiedflag();
Xextern void	set_modifiedflag();
Xextern void	reset_action_on();
Xextern void	set_action_on();
X
X/**********************	 global mode variables	************************/
X
Xextern int	num_point;
Xextern int	min_num_points;
X
X/***************************  Print Settings  ****************************/
X
Xextern int	print_landscape;/* def. orientation for printer */
X
X#define NUM_EXP_LANG	15	/* number of export languages */
X#define LANG_EPS	7	/* position of eps starting from 0 */
X#define LANG_PS		8	/* position of ps starting from 0 */
X#define LANG_XBITMAP	14	/* position of xbm starting from 0 */
X
Xextern int	cur_exp_lang;
Xextern char    *lang_items[NUM_EXP_LANG];
Xextern char    *lang_texts[NUM_EXP_LANG];
X
X/***************************  Mode Settings  ****************************/
X
Xextern int	cur_objmask;
X
X/***************************  Text Settings  ****************************/
X
Xextern int	hidden_text_length;
Xextern float	cur_textstep;
X
X/***************************  File Settings  ****************************/
X
Xextern char	cur_dir[];
Xextern char	cur_filename[];
Xextern char	save_filename[];/* to undo load */
Xextern char	file_header[];
Xextern char	cut_buf_name[];
END_OF_FILE
if test 4448 -ne `wc -c <'mode.h'`; then
    echo shar: \"'mode.h'\" unpacked with wrong size!
fi
# end of 'mode.h'
fi
if test -f 'w_drawprim.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'w_drawprim.c'\"
else
echo shar: Extracting \"'w_drawprim.c'\" \(22909 characters\)
sed "s/^X//" >'w_drawprim.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of M.I.T. not be used in advertising or
X * publicity pertaining to distribution of the software without specific,
X * written prior permission.  M.I.T. makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty."
X *
X */
X
X/*
X * This file provides some drawing primitives which make use of the
X * underlying low-level windowing system operations.
X *
X * The file is divided into routines for:
X *
X * GRAPHICS CONTEXTS (which are used by all the following)
X * FONTS
X * LINES
X * SHADING
X */
X
X/* IMPORTS */
X
X#include "fig.h"
X#include "resources.h"
X#include "paintop.h"
X#include "mode.h"
X#include "object.h"
X#include "u_fonts.h"
X#include "w_canvas.h"
X#include "w_drawprim.h"
X#include "w_icons.h"		/* for none_ic in init_fill_pm */
X#include "w_indpanel.h"
X#include "w_setup.h"
X#include "w_util.h"
X#include "w_zoom.h"
X
X#define set_x_color(gc,col) XSetForeground(tool_d,gc,\
X	(!all_colors_available? (col==WHITE?x_bg_color.pixel:x_fg_color.pixel): \
X	(col<0||col>=NUMCOLORS)? x_fg_color.pixel:appres.color[col]))
X
X#define x_color(col)\
X	(!all_colors_available? (col==WHITE?x_bg_color.pixel:x_fg_color.pixel): \
X	(col<0||col>=NUMCOLORS)? x_fg_color.pixel:appres.color[col])
X
Xextern struct _xfstruct x_fontinfo[NUM_X_FONTS];
Xextern struct _fstruct ps_fontinfo[];	/* font names */
Xextern choice_info fillstyle_choices[];
X
X/* EXPORTS */
X
XPIX_FONT	bold_font;
XPIX_FONT	roman_font;
XPIX_FONT	canvas_font;
XPIX_FONT	canv_zoomed_font;
XPIX_FONT	button_font;
X
X/* LOCAL */
X
Xstatic int	gc_font[NUMOPS], gc_fontsize[NUMOPS];
Xstatic Pixel	gc_color[NUMOPS];
Xstatic XRectangle clip[1];
Xstatic pr_size	pfx_textwidth();
Xstatic int	parsesize();
X
X#define MAXNAMES 35
X
Xstatic struct {
X    char	   *fn;
X    int		    s;
X}		flist[MAXNAMES];
X
Xinit_font()
X{
X    struct xfont   *newfont, *nf;
X    int		    f, count, i, p, ss;
X    char	  **fontlist, **fname;
X
X    if (appres.boldFont == NULL || *appres.boldFont == NULL)
X	appres.boldFont = BOLD_FONT;
X    if (appres.normalFont == NULL || *appres.normalFont == NULL)
X	appres.normalFont = NORMAL_FONT;
X    if (appres.buttonFont == NULL || *appres.buttonFont == NULL)
X	appres.buttonFont = BUTTON_FONT;
X
X    roman_font = XLoadQueryFont(tool_d, appres.normalFont);
X    hidden_text_length = 4 * char_width(roman_font);
X    if ((bold_font = XLoadQueryFont(tool_d, appres.boldFont)) == 0) {
X	fprintf(stderr, "Can't load font: %s, using %s\n",
X		appres.boldFont, appres.normalFont);
X	bold_font = XLoadQueryFont(tool_d, appres.normalFont);
X    }
X    if ((button_font = XLoadQueryFont(tool_d, appres.buttonFont)) == 0) {
X	fprintf(stderr, "Can't load font: %s, using %s\n",
X		appres.buttonFont, appres.normalFont);
X	button_font = XLoadQueryFont(tool_d, appres.normalFont);
X    }
X    /*
X     * Now initialize the font structure for the X fonts corresponding to the
X     * Postscript fonts for the canvas.	 OpenWindows can use any LaserWriter
X     * fonts at any size, so we don't need to load anything if we are using
X     * it.
X     */
X
X#ifndef OPENWIN
X    if (!appres.SCALABLEFONTS) {/* X11R5 has scalable fonts */
X	for (f = 0; f < NUM_X_FONTS; f++) {
X	    nf = NULL;
X	    if (fontlist = XListFonts(tool_d, x_fontinfo[f].template, MAXNAMES, &count)) {
X		fname = fontlist;	/* go through the list finding point
X					 * sizes */
X		p = 0;
X		while (count--) {
X		    ss = parsesize(*fname);	/* get the point size from
X						 * the name */
X		    flist[p].fn = *fname++;	/* save name of this size
X						 * font */
X		    flist[p++].s = ss;	/* and save size */
X		}
X		for (ss = 4; ss <= 50; ss++) {
X		    for (i = 0; i < p; i++)
X			if (flist[i].s == ss)
X			    break;
X		    if (i < p && flist[i].s == ss) {
X			newfont = (struct xfont *) malloc(sizeof(struct xfont));
X			if (nf == NULL)
X			    x_fontinfo[f].xfontlist = newfont;
X			else
X			    nf->next = newfont;
X			nf = newfont;	/* keep current ptr */
X			nf->size = ss;	/* store the size here */
X			nf->fid = NULL; /* haven't loaded the font yet */
X			nf->fstruct = NULL;	/* ditto */
X			nf->fname = flist[i].fn;	/* keep actual name */
X			nf->next = NULL;
X		    }
X		}
X	    }
X	}
X    }				/* next font, f */
X#endif				/* OPENWIN */
X}
X
X/* parse the point size of font 'name' */
X/* e.g. -adobe-courier-bold-o-normal--10-100-75-75-m-60-iso8859-1 */
X
Xstatic int
Xparsesize(name)
X    char	   *name;
X{
X    int		    s;
X    char	   *np;
X
X    for (np = name; *(np + 1); np++)
X	if (*np == '-' && *(np + 1) == '-')	/* look for the -- */
X	    break;
X    s = 0;
X    if (*(np + 1)) {
X	np += 2;		/* point past the -- */
X	s = atoi(np);		/* get the point size */
X    } else
X	fprintf(stderr, "Can't parse '%s'\n", name);
X    return s;
X}
X
X/*
X * Lookup an X font corresponding to a Postscript font style that is close in
X * size
X */
X
XPIX_FONT
Xlookfont(f, s)
X    int		    f, s;
X{
X    struct xfont   *xf;
X    XFontStruct	   *fontst;
X
X#ifdef OPENWIN
X    /* to search for OpenWindows font - see below */
X    char	    fn[128];
X    int		    i;
X
X#endif
X
X    if (f == DEFAULT)
X	return roman_font;	/* pass back the -normal font font */
X    if (s < 0)
X	s = DEF_FONTSIZE;	/* default font size */
X
X#ifdef OPENWIN
X
X    for (i = 1; i < NUM_PS_FONTS + 1; i++)
X	if (ps_fontinfo[i].xfontnum == f)
X	    {
X	    sprintf(fn, "%s-%d", ps_fontinfo[i].name, s);
X	    break;
X	    }
X
X    for (i = strlen(fn) - 1; i >= 0; i--)
X	if (isupper(fn[i]))
X	    fn[i] = tolower(fn[i]);
X    if (appres.DEBUG)
X	fprintf(stderr, "Loading font %s\n", fn);
X    fontst = XLoadQueryFont(tool_d, fn);
X    if (fontst == NULL) {
X	fprintf(stderr, "xfig: Can't load font %s ?!, using %s\n",
X		fn, appres.normalFont);
X	fontst = XLoadQueryFont(tool_d, appres.normalFont);
X    }
X    return (fontst);
X
X#else
X    if (appres.SCALABLEFONTS) { /* scalable fonts! */
X	char		fn[128];
X	char		template[128];
X
X	strcpy(template, x_fontinfo[f].template);
X	template[strlen(template) - 1] = 0;
X	strcat(template, "%d-*-*-*-*-*-*-*");
X	sprintf(fn, template, s);
X	if (appres.DEBUG)
X	    fprintf(stderr, "Loading font %s\n", fn);
X	fontst = XLoadQueryFont(tool_d, fn);
X	if (fontst == NULL) {
X	    fprintf(stderr, "xfig: Can't load font %s ?!, using %s\n",
X		    fn, appres.normalFont);
X	    fontst = XLoadQueryFont(tool_d, appres.normalFont);
X	}
X	return (fontst);
X    } else {				/* prior to X11R5: get best matching font */
X
X	xf = x_fontinfo[f].xfontlist;	/* go through the linked list looking
X					 * for match */
X	if (xf == NULL)
X	    return roman_font;		/* use a default font */
X	while (1) {
X	    if (s < xf->size)		/* larger point size */
X		{
X		put_msg("Font size %d not found, using larger %d point",s,xf->size);
X		break;
X		}
X	    if (s == xf->size)		/* exact point size */
X		break;
X	    if (xf->next != NULL)	/* keep ptr to last if not found */
X		xf = xf->next;
X	    else
X		{
X		put_msg("Font size %d not found, using smaller %d point",s,xf->size);
X		break;		/* not found, use largest point size in the list */
X		}
X	}
X	if (xf->fid == NULL) {		/* if the font is not yet loaded, load it */
X	    if (appres.DEBUG)
X		fprintf(stderr, "Loading font %s\n", xf->fname);
X	    if (fontst = XLoadQueryFont(tool_d, xf->fname)) {	/* load it */
X		xf->fid = fontst->fid;	/* save the id */
X		xf->fstruct = fontst;	/* and the XFontStruct ptr */
X	    } else {
X		fprintf(stderr, "xfig: Can't load font %s ?!, using %s\n",
X			xf->fname, appres.normalFont);
X		fontst = XLoadQueryFont(tool_d, appres.normalFont);
X		xf->fid = fontst->fid;	/* save the id */
X		xf->fstruct = fontst;	/* and the XFontStruct ptr */
X	    }
X	}
X	return (xf->fstruct);
X    }
X
X#endif				/* !OPENWIN */
X
X}
X
X/* print "string" in window "w" using font number "font" and size "size" */
X
Xpw_text(w, x, y, op, font, psflag, size, string, color)
X    Window	    w;
X    int		    x, y, op, font, psflag, size;
X    char	   *string;
X    Color	    color;
X{
X    pwx_text(w, x, y, op, x_fontnum(psflag, font), size * zoomscale, string,
X	     color);
X}
X
Xpwx_text(w, x, y, op, font, size, string, color)
X    Window	    w;
X    int		    x, y, op, font, size;
X    char	   *string;
X    Color	    color;
X{
X    if (gc_font[op] != font || gc_fontsize[op] != size ||
X	gc_color[op] != x_color(color)) {
X	if (op == PAINT) {
X	    set_x_color(gccache[op], color);
X	    gc_color[op] = x_color(color);
X	}
X	canv_zoomed_font = lookfont(font, size);
X	XSetFont(tool_d, gccache[op], canv_zoomed_font->fid);
X	gc_font[op] = font;
X	gc_fontsize[op] = size;
X    }
X    zXDrawString(tool_d, w, gccache[op], x, y, string, strlen(string));
X}
X
Xpr_size
Xpf_textwidth(font, psflag, size, n, s)
X    int		    font, psflag, size, n;
X    char	   *s;
X{
X    return pfx_textwidth(x_fontnum(psflag, font), size, n, s);
X}
X
Xstatic		pr_size
Xpfx_textwidth(font, size, n, s)
X    int		    font, size, n;
X    char	   *s;
X{
X    int		    dummy;
X    XCharStruct	    ch;
X    pr_size	    ret;
X
X    canvas_font = lookfont(font, size); /* make sure it is the right font */
X    XTextExtents(canvas_font, s, n, &dummy, &dummy, &dummy, &ch);
X    ret.x = ch.width;
X    ret.y = (ch.ascent + ch.descent);
X    return (ret);
X}
X
X/* LINES */
X
Xstatic int	gc_thickness[NUMOPS], gc_line_style[NUMOPS];
X
Xstatic		GC
Xmakegc(op, fg, bg)
X    int		    op;
X    Pixel	    fg;
X    Pixel	    bg;
X{
X    register GC	    ngc;
X    XGCValues	    gcv;
X    unsigned long   gcmask;
X
X    gcv.font = roman_font->fid;
X    gcv.join_style = JoinMiter;
X    gcmask = GCJoinStyle | GCFunction | GCForeground | GCBackground | GCFont;
X    switch (op) {
X    case PAINT:
X	gcv.foreground = fg;
X	gcv.background = bg;
X	gcv.function = GXcopy;
X	break;
X    case ERASE:
X	gcv.foreground = bg;
X	gcv.background = bg;
X	gcv.function = GXcopy;
X	break;
X    case INV_PAINT:
X	gcv.foreground = fg ^ bg;
X	gcv.background = bg;
X	gcv.function = GXxor;
X	break;
X    case MERGE:
X	gcv.foreground = fg;
X	gcv.background = bg;
X	gcv.function = GXor;
X	break;
X    }
X
X    ngc = XCreateGC(tool_d, XtWindow(canvas_sw), gcmask, &gcv);
X    XCopyGC(tool_d, gc, ~(gcmask), ngc);	/* add main gc's values to
X						 * the new one */
X    return (ngc);
X}
X
Xinit_gc()
X{
X    int		    i;
X
X    gccache[PAINT] = makegc(PAINT, x_fg_color.pixel, x_bg_color.pixel);
X    gccache[ERASE] = makegc(ERASE, x_fg_color.pixel, x_bg_color.pixel);
X    gccache[INV_PAINT] = makegc(INV_PAINT, x_fg_color.pixel, x_bg_color.pixel);
X    gccache[MERGE] = makegc(MERGE, x_fg_color.pixel, x_bg_color.pixel);
X
X    for (i = 0; i < NUMOPS; i++) {
X	gc_font[i] = -1;
X	gc_color[i] = -1;
X	gc_fontsize[i] = 0;
X	gc_thickness[i] = -1;
X	gc_line_style[i] = -1;
X    }
X}
X
X/* create the gc's for fill style (PAINT and ERASE) */
X/* the fill_pm[] and unfill_pm[] must already be created */
X
Xinit_fill_gc()
X{
X    XGCValues	    gcv;
X    int		    i;
X
X    gcv.fill_style = FillOpaqueStippled;
X    gcv.arc_mode = ArcPieSlice; /* fill mode for arcs */
X    gcv.fill_rule = EvenOddRule /* WindingRule */ ;
X    for (i = 0; i < NUMFILLPATS; i++) {
X	/* make color fill pattern with black bg (fg is set later in set_x_color() */
X	fill_gc[i] = makegc(PAINT, x_fg_color.pixel, x_color(BLACK));
X	un_fill_gc[i] = makegc(ERASE, x_fg_color.pixel, x_color(BLACK));
X	/* make black fill pattern with default background */
X	black_fill_gc[i] = makegc(PAINT, x_fg_color.pixel, x_bg_color.pixel);
X	black_un_fill_gc[i] = makegc(ERASE, x_fg_color.pixel, x_bg_color.pixel);
X	gcv.stipple = fill_pm[i];
X	XChangeGC(tool_d, fill_gc[i],
X		  GCStipple | GCFillStyle | GCFillRule | GCArcMode, &gcv);
X	XChangeGC(tool_d, black_fill_gc[i],
X		  GCStipple | GCFillStyle | GCFillRule | GCArcMode, &gcv);
X	XChangeGC(tool_d, un_fill_gc[i],
X		  GCStipple | GCFillStyle | GCArcMode, &gcv);
X	XChangeGC(tool_d, black_un_fill_gc[i],
X		  GCStipple | GCFillStyle | GCArcMode, &gcv);
X    }
X}
X
X/* SHADING */
X
X/* grey images for fill patterns */
X
Xstatic char	fill_images[NUMFILLPATS][8] = {
X    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
X    {0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00},
X    {0x00, 0x40, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00},
X    {0x00, 0x40, 0x00, 0x10, 0x00, 0x04, 0x00, 0x00},
X    {0x00, 0x44, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00},
X    {0x00, 0x44, 0x00, 0x10, 0x00, 0x44, 0x00, 0x00},
X    {0x88, 0x00, 0x22, 0x00, 0x88, 0x00, 0x22, 0x00},
X    {0x88, 0x00, 0x32, 0x00, 0x88, 0x00, 0x23, 0x00},
X    {0xc4, 0x00, 0x31, 0x00, 0x8c, 0x00, 0x23, 0x00},
X    {0x99, 0x00, 0xcc, 0x00, 0x66, 0x00, 0x33, 0x00},
X    {0x55, 0x00, 0x55, 0x00, 0x55, 0x00, 0x55, 0x00},
X    {0x55, 0x22, 0x55, 0x08, 0x55, 0x22, 0x55, 0x00},
X    {0x55, 0xa2, 0x55, 0x88, 0x55, 0xa2, 0x55, 0x2a},
X    {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa},
X    {0x55, 0xaa, 0x77, 0xaa, 0x55, 0xaa, 0xdd, 0xaa},
X    {0x55, 0xae, 0x5f, 0xae, 0x55, 0xea, 0xf5, 0xea},
X    {0x5d, 0xb6, 0x7f, 0xd5, 0x7f, 0xb6, 0x5d, 0xaa},
X    {0x77, 0xff, 0x77, 0xaa, 0x77, 0xff, 0x77, 0xaa},
X    {0x77, 0xdd, 0x7f, 0xbe, 0x7f, 0xdd, 0x77, 0xaa},
X    {0x77, 0xff, 0x7f, 0xbe, 0x7f, 0xff, 0x77, 0xaa},
X    {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
X};
X
X/* generate the fill pixmaps */
X
Xinit_fill_pm()
X{
X    int		    i;
X    register	    j, k;
X    Pixmap	    tmpPM,tmpblackPM;
X
X    for (i = 0; i < NUMFILLPATS + 1; i++) {
X	fillstyle_choices[i].value = i;
X	fillstyle_choices[i].icon = &none_ic;
X    }
X    /* use same colors for "NONE" indicator for black and color */
X    fillstyle_choices[0].normalPM = 
X	fillstyle_choices[0].blackPM = XCreatePixmapFromBitmapData(tool_d,
X			XtWindow(ind_panel), none_ic.data, none_ic.width,
X			none_ic.height, x_fg_color.pixel, x_bg_color.pixel,
X			DefaultDepthOfScreen(tool_s));
X
X    for (i = 0; i < NUMFILLPATS; i++) {
X	fill_pm[i] = XCreateBitmapFromData(tool_d, XtWindow(canvas_sw),
X					   fill_images[i], 8, 8);
X	/* create fill style pixmaps for indicator button */
X	fillstyle_choices[i + 1].normalPM = XCreatePixmap(tool_d,
X		 XtWindow(canvas_sw), 32, 32, DefaultDepthOfScreen(tool_s));
X	tmpPM = XCreatePixmapFromBitmapData(tool_d, XtWindow(canvas_sw),
X				     fill_images[i], 8, 8, x_bg_color.pixel,
X			    x_fg_color.pixel, DefaultDepthOfScreen(tool_s));
X	fillstyle_choices[i + 1].blackPM = XCreatePixmap(tool_d,
X		 XtWindow(canvas_sw), 32, 32, DefaultDepthOfScreen(tool_s));
X	tmpblackPM = XCreatePixmapFromBitmapData(tool_d, XtWindow(canvas_sw),
X				     fill_images[i], 8, 8, x_fg_color.pixel,
X			    x_bg_color.pixel, DefaultDepthOfScreen(tool_s));
X	for (j = 0; j <= 24; j += 8)
X	    for (k = 0; k <= 24; k += 8)
X		{
X		XCopyArea(tool_d, tmpPM, fillstyle_choices[i + 1].normalPM,
X			  ind_button_gc, 0, 0, 8, 8, j, k);
X		XCopyArea(tool_d, tmpblackPM, fillstyle_choices[i + 1].blackPM,
X			  ind_button_gc, 0, 0, 8, 8, j, k);
X		}
X	XFreePixmap(tool_d, tmpPM);
X	XFreePixmap(tool_d, tmpblackPM);
X    }
X}
X
Xpw_vector(w, x1, y1, x2, y2, op, line_width, line_style, style_val, color)
X    Window	    w;
X    int		    x1, y1, x2, y2, op, line_width, line_style;
X    float	    style_val;
X    Color	    color;
X{
X    if (line_width == 0)
X	return;
X    set_line_stuff(line_width, line_style, style_val, op, color);
X    if (line_style == PANEL_LINE)
X	XDrawLine(tool_d, w, gccache[op], x1, y1, x2, y2);
X    else
X	zXDrawLine(tool_d, w, gccache[op], x1, y1, x2, y2);
X}
X
Xpw_curve(w, xstart, ystart, xend, yend,
X	 op, linewidth, style, style_val, fill_style, color)
X    Window	    w;
X    int		    xstart, ystart, xend, yend;
X    int		    op, linewidth, style, fill_style;
X    float	    style_val;
X    Color	    color;
X{
X    short	    xmin, ymin;
X    unsigned short  wd, ht;
X
X    xmin = (short) min2(xstart, xend);
X    ymin = (short) min2(ystart, yend);
X    wd = (unsigned short) abs(xstart - xend);
X    ht = (unsigned short) abs(ystart - yend);
X
X    /* if it's a fill pat we know about */
X    if (fill_style >= 1 && fill_style <= NUMFILLPATS) {
X	set_fillgc(fill_style, op, color);
X	zXFillArc(tool_d, w, fillgc, xmin, ymin, wd, ht, 0, 360 * 64);
X    }
X    if (linewidth == 0)
X	return;
X    if (op == ERASE) {
X	/* kludge - to speed things up we erase with thick solid lines */
X	set_line_stuff(linewidth + 3, SOLID_LINE, 0.0, op, color);	/* +2 or +3 ok */
X	zXDrawArc(tool_d, w, gccache[op], xmin, ymin, wd, ht, 0, 360 * 64);
X    } else {
X	set_line_stuff(linewidth, style, style_val, op, color);
X	zXDrawArc(tool_d, w, gccache[op], xmin, ymin, wd, ht, 0, 360 * 64);
X    }
X}
X
Xpw_point(w, x, y, line_width, op, color)
X    Window	    w;
X    int		    x, y;
X    int		    op, line_width;
X    Color	    color;
X{
X    /* pw_point doesn't use line_style or fill_style - maybe not needed */
X    /* (needs color though - hns) */
X    set_line_stuff(line_width, SOLID_LINE, 0.0, op, color);
X    zXDrawPoint(tool_d, w, gccache[op], x, y);
X}
X
Xpw_arcbox(w, xmin, ymin, xmax, ymax, radius, op,
X	  line_width, line_style, style_val, fill_style, color)
X    Window	    w;
X    int		    xmin, ymin, xmax, ymax, radius;
X    int		    op, line_width, line_style, fill_style;
X    float	    style_val;
X    Color	    color;
X{
X    GC		    gc;
X    int		    diam = 2 * radius;
X
X    /* if it's a fill pat we know about */
X    if (fill_style >= 1 && fill_style <= NUMFILLPATS) {
X	set_fillgc(fill_style, op, color);
X	/* upper left */
X	zXFillArc(tool_d, w, fillgc, xmin, ymin, diam, diam, 90 * 64, 90 * 64);
X	/* lower left */
X	zXFillArc(tool_d, w, fillgc, xmin, ymax - diam, diam, diam,
X		  180 * 64, 90 * 64);
X	/* lower right */
X	zXFillArc(tool_d, w, fillgc, xmax - diam, ymax - diam, diam, diam,
X		  270 * 64, 90 * 64);
X	/* upper right */
X	zXFillArc(tool_d, w, fillgc, xmax - diam, ymin, diam, diam,
X		  0 * 64, 90 * 64);
X	/* fill strip on left side between upper and lower arcs */
X	if (ymax - ymin - diam > 0)
X	    zXFillRectangle(tool_d, w, fillgc, xmin, ymin + radius, radius,
X			    ymax - ymin - diam);
X	/* fill middle section */
X	if (xmax - xmin - diam > 0)
X	    zXFillRectangle(tool_d, w, fillgc, xmin + radius, ymin,
X			    xmax - xmin - diam, ymax - ymin);
X	/* fill strip on right side between upper and lower arcs */
X	if (ymax - ymin - diam > 0)
X	    zXFillRectangle(tool_d, w, fillgc, xmax - radius, ymin + radius,
X			    radius, ymax - ymin - diam);
X    }
X    if (line_width == 0)
X	return;
X
X    set_line_stuff(line_width, line_style, style_val, op, color);
X    gc = gccache[op];
X    zXDrawArc(tool_d, w, gc, xmin, ymin, diam, diam, 90 * 64, 90 * 64);
X    zXDrawLine(tool_d, w, gc, xmin, ymin + radius, xmin, ymax - radius + 1);
X    zXDrawArc(tool_d, w, gc, xmin, ymax - diam, diam, diam, 180 * 64, 90 * 64);
X    zXDrawLine(tool_d, w, gc, xmin + radius, ymax, xmax - radius + 1, ymax);
X    zXDrawArc(tool_d, w, gc, xmax - diam, ymax - diam,
X	      diam, diam, 270 * 64, 90 * 64);
X    zXDrawLine(tool_d, w, gc, xmax, ymax - radius, xmax, ymin + radius - 1);
X    zXDrawArc(tool_d, w, gc, xmax - diam, ymin, diam, diam, 0 * 64, 90 * 64);
X    zXDrawLine(tool_d, w, gc, xmax - radius, ymin, xmin + radius - 1, ymin);
X}
X
Xpw_lines(w, points, npoints, op, line_width, line_style, style_val, fill_style, color)
X    Window	    w;
X    int		    npoints;
X    XPoint	   *points;
X    int		    op, line_width, line_style, fill_style;
X    float	    style_val;
X    Color	    color;
X{
X    /* if it's a fill pat we know about */
X    if (fill_style >= 1 && fill_style <= NUMFILLPATS) {
X	set_fillgc(fill_style, op, color);
X	if (line_style == PANEL_LINE)
X	    XFillPolygon(tool_d, w, fillgc, points, npoints,
X			 Complex, CoordModeOrigin);
X	else
X	    zXFillPolygon(tool_d, w, fillgc, points, npoints,
X			  Complex, CoordModeOrigin);
X    }
X    if (line_width == 0)
X	return;
X    set_line_stuff(line_width, line_style, style_val, op, color);
X    if (line_style == PANEL_LINE)
X	XDrawLines(tool_d, w, gccache[op], points, npoints, CoordModeOrigin);
X    else
X	zXDrawLines(tool_d, w, gccache[op], points, npoints, CoordModeOrigin);
X}
X
Xset_clip_window(xmin, ymin, xmax, ymax)
X    int		    xmin, ymin, xmax, ymax;
X{
X    clip_xmin = clip[0].x = xmin;
X    clip_ymin = clip[0].y = ymin;
X    clip_xmax = xmax;
X    clip_ymax = ymax;
X    clip_width = clip[0].width = xmax - xmin;
X    clip_height = clip[0].height = ymax - ymin;
X    XSetClipRectangles(tool_d, gccache[PAINT], 0, 0, clip, 1, YXBanded);
X    XSetClipRectangles(tool_d, gccache[INV_PAINT], 0, 0, clip, 1, YXBanded);
X}
X
Xset_zoomed_clip_window(xmin, ymin, xmax, ymax)
X    int		    xmin, ymin, xmax, ymax;
X{
X    set_clip_window(ZOOMX(xmin), ZOOMY(ymin), ZOOMX(xmax), ZOOMY(ymax));
X}
X
Xreset_clip_window()
X{
X    set_clip_window(0, 0, CANVAS_WD, CANVAS_HT);
X}
X
Xset_fillgc(fill_style, op, color)
X    int		    fill_style;
X    int		    op;
X    Color	    color;
X{
X    if (op == PAINT) {
X	fillgc = ((color==BLACK || 
X	     (color==DEFAULT_COLOR && x_fg_color.pixel==appres.color[BLACK]) ||
X	     (!all_colors_available && color!=WHITE))? 
X		black_fill_gc[fill_style - 1]: fill_gc[fill_style - 1]);
X	set_x_color(fillgc, color);
X    } else
X	fillgc = ((color==BLACK || 
X	     (color==DEFAULT_COLOR && x_fg_color.pixel==appres.color[BLACK]) ||
X	     (!all_colors_available && color!=WHITE))? 
X		black_un_fill_gc[fill_style - 1]: un_fill_gc[fill_style - 1]);
X    XSetClipRectangles(tool_d, fillgc, 0, 0, clip, 1, YXBanded);
X}
X
Xset_line_stuff(width, style, style_val, op, color)
X    int		    width, style, op;
X    float	    style_val;
X    Color	    color;
X{
X    XGCValues	    gcv;
X    unsigned long   mask;
X    static char	    dash_list[2] = {-1, -1};
X
X    switch (style) {
X    case RUBBER_LINE:
X	width = 0;
X	break;
X    case PANEL_LINE:
X	break;
X    default:
X	width = zoomscale * width;
X	break;
X    }
X
X    /* user zero-width lines for speed with SOLID lines */
X    /* can't do this for dashed lines because server isn't */
X    /* required to draw dashes for zero-width lines */
X    if (width == 1 && style == SOLID_LINE)
X	width = 0;
X
X    /* see if all gc stuff is already correct */
X
X    if (width == gc_thickness[op] && style == gc_line_style[op] &&
X	x_color(color) == gc_color[op] &&
X	(style != DASH_LINE && style != DOTTED_LINE ||
X	 dash_list[1] == (char) style_val * zoomscale))
X	return;			/* no need to change anything */
X
X    gcv.line_width = width;
X    mask = GCLineWidth | GCLineStyle | GCCapStyle;
X    if (op == PAINT)
X	mask |= GCForeground;
X    gcv.line_style = (style == DASH_LINE || style == DOTTED_LINE) ?
X	LineOnOffDash : LineSolid;
X    gcv.cap_style = (style == DOTTED_LINE) ? CapRound : CapButt;
X    gcv.foreground = x_color(color);
X
X    XChangeGC(tool_d, gccache[op], mask, &gcv);
X    if (style == DASH_LINE || style == DOTTED_LINE) {
X	if (style_val > 0.0) {	/* style_val of 0.0 causes problems */
X	    /* length of ON/OFF pixels */
X	    dash_list[0] = dash_list[1] = (char) style_val *zoomscale;
X
X	    if (style == DOTTED_LINE)
X		dash_list[0] = 1;	/* length of ON pixels for dotted */
X	    XSetDashes(tool_d, gccache[op], 0, dash_list, 2);
X	}
X    }
X    gc_thickness[op] = width;
X    gc_line_style[op] = style;
X    gc_color[op] = x_color(color);
X}
END_OF_FILE
if test 22909 -ne `wc -c <'w_drawprim.c'`; then
    echo shar: \"'w_drawprim.c'\" unpacked with wrong size!
fi
# end of 'w_drawprim.c'
fi
echo shar: End of archive 7 \(of 25\).
cp /dev/null ark7isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Molecular Simulations, Inc.             mail: dcmartin@msi.com
796 N. Pastoria Avenue                  uucp: uunet!dcmartin
Sunnyvale, California 94086             at&t: 408/522-9236
