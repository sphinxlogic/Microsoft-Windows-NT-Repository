Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: envbvs@bea.lbl.gov (Brian V. Smith)
Newsgroups: comp.sources.x
Subject: v16i039: Xfig 2.1.3, Part14/25 (REPOST)
Message-ID: <1992Feb5.145431.20675@msi.com>
Date: 5 Feb 92 14:54:31 GMT
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1743
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: envbvs@bea.lbl.gov (Brian V. Smith)
Posting-number: Volume 16, Issue 39
Archive-name: xfig-2.1.3/part14

# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
#		"End of archive 14 (of 25)."
# Contents:  Examples/network.fig.uu e_rotate.c w_canvas.c w_export.c
#   w_fontbits3.c.Z.uu
# Wrapped by dcmartin@fascet on Tue Feb  4 06:42:30 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Examples/network.fig.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Examples/network.fig.uu'\"
else
echo shar: Extracting \"'Examples/network.fig.uu'\" \(3848 characters\)
sed "s/^X//" >'Examples/network.fig.uu' <<'END_OF_FILE'
Xbegin 664 network.fig
XM(T9)1R`R+C`*.#`@,@HQ(#,@,"`Q(#`@,"`P(#(Q(#`N,#`P(#$@,"XP,#`@
XM,C<Y(#$Y(#,@,R`R-SD@,3D@,C@Q(#(P"C$@,R`P(#$@,"`P(#`@,C$@,"XP
XM,#`@,2`P+C`P,"`T,SD@,3D@,R`S(#0S.2`Q.2`T-#$@,C`*,2`S(#`@,2`P
XM(#`@,"`R,2`P+C`P,"`Q(#`N,#`P(#4Y.2`Q.2`S(#,@-3DY(#$Y(#8P,2`R
XM,`HQ(#,@,"`Q(#`@,"`P(#(Q(#`N,#`P(#$@,"XP,#`@-#,Y(#$U.2`S(#,@
XM-#,Y(#$U.2`T-#$@,38P"C$@,R`P(#$@,"`P(#`@,C$@,"XP,#`@,2`P+C`P
XM,"`R-SD@,CDY(#,@,R`R-SD@,CDY(#(X,2`S,#`*,2`S(#`@,2`P(#`@,"`R
XM,2`P+C`P,"`Q(#`N,#`P(#0S.2`R.3D@,R`S(#0S.2`R.3D@-#0Q(#,P,`HQ
XM(#,@,"`Q(#`@,"`P(#(Q(#`N,#`P(#$@,"XP,#`@-3DY(#(Y.2`S(#,@-3DY
XM(#(Y.2`V,#$@,S`P"C$@,R`P(#$@,"`P(#`@,C$@,"XP,#`@,2`P+C`P,"`R
XM-SD@-#<Y(#,@,R`R-SD@-#<Y(#(X,2`T-#`*,2`S(#`@,2`P(#`@,"`R,2`P
XM+C`P,"`Q(#`N,#`P(#0S.2`T-SD@,R`S(#0S.2`T-SD@-#0Q(#0T,`HQ(#,@
XM,"`Q(#`@,"`P(#(Q(#`N,#`P(#$@,"XP,#`@-3DY(#0W.2`S(#,@-3DY(#0W
XM.2`V,#$@-#0P"C(@,2`P(#$@,"`P(#`@,"`P+C`P,"`P(#`*"2`R-SD@,3$Y
XM(#(W.2`S,SD@.3DY.2`Y.3DY"C(@,B`P(#$@,"`P(#`@,"`P+C`P,"`P(#`*
XM"2`R-CD@-3D@,C@Y(#4Y(#(X.2`Q,3D@,C8Y(#$Q.2`R-CD@-3D@.3DY.2`Y
XM.3DY"C(@,2`P(#$@,"`P(#`@,"`P+C`P,"`P(#`*"2`R-SD@,3D@,C<Y(#4Y
XM(#DY.3D@.3DY.0HR(#$@,"`Q(#`@,"`P(#`@,"XP,#`@,"`P"@D@-#,Y(#$Y
XM(#0S.2`U.2`Y.3DY(#DY.3D*,B`R(#`@,2`P(#`@,"`P(#`N,#`P(#`@,`H)
XM(#0R.2`U.2`T-#D@-3D@-#0Y(#$Q.2`T,CD@,3$Y(#0R.2`U.2`Y.3DY(#DY
XM.3D*,B`Q(#`@,2`P(#`@,"`P(#`N,#`P(#`@,`H)(#0S.2`Q,3D@-#,Y(#$U
XM.2`Y.3DY(#DY.3D*,B`Q(#`@,2`P(#`@,"`P(#`N,#`P(#`@,`H)(#4Y.2`Q
XM,3D@-3DY(#$U.2`Y.3DY(#DY.3D*,B`R(#`@,2`P(#`@,"`P(#`N,#`P(#`@
XM,`H)(#4X.2`U.2`V,#D@-3D@-C`Y(#$Q.2`U.#D@,3$Y(#4X.2`U.2`Y.3DY
XM(#DY.3D*,B`Q(#`@,2`P(#`@,"`P(#`N,#`P(#`@,`H)(#4Y.2`Q.2`U.3D@
XM-3D@.3DY.2`Y.3DY"C(@,2`P(#$@,"`P(#`@,"`P+C`P,"`P(#`*"2`T,SD@
XM,C4Y(#0S.2`R.3D@.3DY.2`Y.3DY"C(@,B`P(#$@,"`P(#`@,"`P+C`P,"`P
XM(#`*"2`T,CD@,3DY(#0T.2`Q.3D@-#0Y(#(U.2`T,CD@,C4Y(#0R.2`Q.3D@
XM.3DY.2`Y.3DY"C(@,2`P(#$@,"`P(#`@,"`P+C`P,"`P(#`*"2`T,SD@,34Y
XM(#0S.2`Q.3D@.3DY.2`Y.3DY"C(@,2`P(#$@,"`P(#`@,"`P+C`P,"`P(#`*
XM"2`R-SD@,CDY(#,Q.2`R.3D@.3DY.2`Y.3DY"C(@,B`P(#$@,"`P(#`@,"`P
XM+C`P,"`P(#`*"2`S,3D@,S`Y(#,Q.2`R.#D@,S<Y(#(X.2`S-SD@,S`Y(#,Q
XM.2`S,#D@.3DY.2`Y.3DY"C(@,2`P(#$@,"`P(#`@,"`P+C`P,"`P(#`*"2`S
XM-SD@,CDY(#0S.2`R.3D@.3DY.2`Y.3DY"C(@,2`P(#$@,"`P(#`@,"`P+C`P
XM,"`P(#`*"2`T,SD@,CDY(#0Y.2`R.3D@.3DY.2`Y.3DY"C(@,B`P(#$@,"`P
XM(#`@,"`P+C`P,"`P(#`*"2`T.3D@,S`Y(#0Y.2`R.#D@-34Y(#(X.2`U-3D@
XM,S`Y(#0Y.2`S,#D@.3DY.2`Y.3DY"C(@,2`P(#$@,"`P(#`@,"`P+C`P,"`P
XM(#`*"2`U-3D@,CDY(#4Y.2`R.3D@.3DY.2`Y.3DY"C(@,2`P(#$@,"`P(#`@
XM,"`P+C`P,"`P(#`*"2`T,SD@-#,Y(#0S.2`T-SD@.3DY.2`Y.3DY"C(@,B`P
XM(#$@,"`P(#`@,"`P+C`P,"`P(#`*"2`T,C0@,S<Y(#0R-"`T,SD@-#4T(#0S
XM.2`T-30@,S<Y(#0R-"`S-SD@.3DY.2`Y.3DY"C(@,2`P(#$@,"`P(#`@,"`P
XM+C`P,"`P(#`*"2`T,SD@,CDY(#0S.2`S-SD@.3DY.2`Y.3DY"C(@,2`P(#$@
XM,"`P(#`@,"`P+C`P,"`P(#`*"2`U.3D@,34Y(#4Y.2`S-SD@.3DY.2`Y.3DY
XM"C(@,B`P(#$@,"`P(#`@,"`P+C`P,"`P(#`*"2`U.#D@,S<Y(#8P.2`S-SD@
XM-C`Y(#0S.2`U.#D@-#,Y(#4X.2`S-SD@.3DY.2`Y.3DY"C(@,2`P(#$@,"`P
XM(#`@,"`P+C`P,"`P(#`*"2`U.3D@-#,Y(#4Y.2`T-SD@.3DY.2`Y.3DY"C(@
XM,2`P(#$@,"`P(#`@,"`P+C`P,"`P(#`*"2`R-SD@,S,Y(#(W.2`S-SD@.3DY
XM.2`Y.3DY"C(@,B`P(#$@,"`P(#`@,"`P+C`P,"`P(#`*"2`R-CD@,S<Y(#(X
XM.2`S-SD@,C@Y(#0S.2`R-CD@-#,Y(#(V.2`S-SD@.3DY.2`Y.3DY"C(@,2`P
XM(#$@,"`P(#`@,"`P+C`P,"`P(#`*"2`R-SD@-#,Y(#(W.2`T-SD@.3DY.2`Y
XM.3DY"C0@,"`P(#$R(#`@,"`P(#`N,#`P(#$@.2`Q,B`U-C4@-#$T($0Y`0HT
XM(#`@,"`Q,B`P(#`@,"`P+C`P,"`Q(#D@,3(@-#`Q(#0Q-"!$.`$*-"`P(#`@
XM,3(@,"`P(#`@,"XP,#`@,2`Y(#$R(#(T-2`T,30@1#<!"C0@,"`P(#$R(#`@
XM,"`P(#`N,#`P(#$@.2`V(#(V,B`S,#(@20$*-"`P(#`@,3(@,"`P(#`@,"XP
XM,#`@,2`Y(#$X(#8P.2`S,#(@24E)`0HT(#`@,"`Q,B`P(#`@,"`P+C`P,"`Q
XM(#D@,3(@-3(U(#(W.2!$-@$*-"`P(#`@,3(@,"`P(#`@,"XP,#`@,2`Y(#$R
XM(#0T.2`R.#D@258!"C0@,"`P(#$R(#`@,"`P(#`N,#`P(#$@.2`Q,B`S-#0@
XM,C<Y($0T`0HT(#`@,"`Q,B`P(#`@,"`P+C`P,"`Q(#D@,3(@-#`U(#(S.2!$
XM-0$*-"`P(#`@,3(@,"`P(#`@,"XP,#`@,2`Y(#$R(#0T.2`Q-C,@24D!"C0@
XM,"`P(#$R(#`@,"`P(#`N,#`P(#$@.2`Q,B`U-C4@.30@1#,!"C0@,"`P(#$R
XM(#`@,"`P(#`N,#`P(#$@.2`Q,B`T,#4@.30@1#(!"C0@,"`P(#$R(#`@,"`P
X9(#`N,#`P(#$@.2`Q,B`R-#4@.30@1#$!"C0@
X`
Xend
END_OF_FILE
if test 3848 -ne `wc -c <'Examples/network.fig.uu'`; then
    echo shar: \"'Examples/network.fig.uu'\" unpacked with wrong size!
fi
# end of 'Examples/network.fig.uu'
fi
if test -f 'e_rotate.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'e_rotate.c'\"
else
echo shar: Extracting \"'e_rotate.c'\" \(11575 characters\)
sed "s/^X//" >'e_rotate.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of M.I.T. not be used in advertising or
X * publicity pertaining to distribution of the software without specific,
X * written prior permission.  M.I.T. makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty."
X *
X */
X
X#include "fig.h"
X#include "resources.h"
X#include "mode.h"
X#include "object.h"
X#include "paintop.h"
X#include "u_draw.h"
X#include "u_search.h"
X#include "u_create.h"
X#include "u_list.h"
X#include "w_canvas.h"
X#include "w_mousefun.h"
X
Xextern float	compute_angle();
X
Xstatic int	copy;
Xstatic int	rotn_dirn;
Xstatic int	init_rotate();
Xstatic int	init_copynrotate();
Xstatic int	rotate_selected();
Xstatic int	rotate_search();
Xstatic int	init_rotateline();
Xstatic int	init_rotatetext();
X
Xrotate_cw_selected()
X{
X    rotn_dirn = 1;
X    rotate_selected();
X}
X
Xrotate_ccw_selected()
X{
X    rotn_dirn = -1;
X    rotate_selected();
X}
X
Xstatic
Xrotate_selected()
X{
X    set_mousefun("rotate object", "copy & rotate", "");
X    canvas_kbd_proc = null_proc;
X    canvas_locmove_proc = null_proc;
X    init_searchproc_left(init_rotate);
X    init_searchproc_middle(init_copynrotate);
X    canvas_leftbut_proc = object_search_left;
X    canvas_middlebut_proc = object_search_middle;
X    canvas_rightbut_proc = null_proc;
X    set_cursor(pick15_cursor);
X}
X
Xstatic
Xinit_rotate(p, type, x, y, px, py)
X    char	   *p;
X    int		    type;
X    int		    x, y;
X    int		    px, py;
X{
X    copy = 0;
X    rotate_search(p, type, x, y, px, py);
X}
X
Xstatic
Xinit_copynrotate(p, type, x, y, px, py)
X    char	   *p;
X    int		    type;
X    int		    x, y;
X    int		    px, py;
X{
X    copy = 1;
X    rotate_search(p, type, x, y, px, py);
X}
X
Xstatic
Xrotate_search(p, type, x, y, px, py)
X    char	   *p;
X    int		    type;
X    int		    x, y;
X    int		    px, py;
X{
X    switch (type) {
X    case O_POLYLINE:
X	cur_l = (F_line *) p;
X	init_rotateline(cur_l, px, py);
X	break;
X    case O_ARC:
X	cur_a = (F_arc *) p;
X	init_rotatearc(cur_a, px, py);
X	break;
X    case O_ELLIPSE:
X	cur_e = (F_ellipse *) p;
X	init_rotateellipse(cur_e, px, py);
X	break;
X    case O_SPLINE:
X	cur_s = (F_spline *) p;
X	init_rotatespline(cur_s, px, py);
X	break;
X    case O_TEXT:
X	cur_t = (F_text *) p;
X	init_rotatetext(cur_t, px, py);
X	break;
X    case O_COMPOUND:
X	cur_c = (F_compound *) p;
X	init_rotatecompound(cur_c, px, py);
X	break;
X    default:
X	return;
X    }
X}
X
Xstatic
Xinit_rotateline(l, px, py)
X    F_line	   *l;
X    int		    px, py;
X{
X    F_line	   *line;
X
X    set_temp_cursor(wait_cursor);
X    line = copy_line(l);
X    rotate_line(line, px, py, rotn_dirn);
X    if (copy) {
X	add_line(line);
X    } else {
X	toggle_linemarker(l);
X	draw_line(l, ERASE);
X	change_line(l, line);
X    }
X    draw_line(line, PAINT);
X    toggle_linemarker(line);
X    reset_cursor();
X}
X
Xstatic
Xinit_rotatetext(t, px, py)
X    F_text	   *t;
X    int		    px, py;
X{
X    F_text	   *text;
X
X    text = copy_text(t);
X    rotate_text(text, t->base_x, t->base_y, rotn_dirn);
X    if (copy) {
X	add_text(text);
X    } else {
X	toggle_textmarker(t);
X	change_text(t, text);
X    }
X    toggle_textmarker(text);
X}
X
Xinit_rotateellipse(e, px, py)
X    F_ellipse	   *e;
X    int		    px, py;
X{
X    F_ellipse	   *ellipse;
X
X    set_temp_cursor(wait_cursor);
X    ellipse = copy_ellipse(e);
X    rotate_ellipse(ellipse, px, py, rotn_dirn);
X    if (copy) {
X	add_ellipse(ellipse);
X    } else {
X	toggle_ellipsemarker(e);
X	draw_ellipse(e, ERASE);
X	change_ellipse(e, ellipse);
X    }
X    draw_ellipse(ellipse, PAINT);
X    toggle_ellipsemarker(ellipse);
X    reset_cursor();
X}
X
Xinit_rotatearc(a, px, py)
X    F_arc	   *a;
X    int		    px, py;
X{
X    F_arc	   *arc;
X
X    set_temp_cursor(wait_cursor);
X    arc = copy_arc(a);
X    rotate_arc(arc, px, py, rotn_dirn);
X    if (copy) {
X	add_arc(arc);
X    } else {
X	toggle_arcmarker(a);
X	draw_arc(a, ERASE);
X	change_arc(a, arc);
X    }
X    draw_arc(arc, PAINT);
X    toggle_arcmarker(arc);
X    reset_cursor();
X}
X
Xinit_rotatespline(s, px, py)
X    F_spline	   *s;
X    int		    px, py;
X{
X    F_spline	   *spline;
X
X    set_temp_cursor(wait_cursor);
X    spline = copy_spline(s);
X    rotate_spline(spline, px, py, rotn_dirn);
X    if (copy) {
X	add_spline(spline);
X    } else {
X	toggle_splinemarker(s);
X	draw_spline(s, ERASE);
X	change_spline(s, spline);
X    }
X    draw_spline(spline, PAINT);
X    toggle_splinemarker(spline);
X    reset_cursor();
X}
X
Xinit_rotatecompound(c, px, py)
X    F_compound	   *c;
X    int		    px, py;
X{
X    F_compound	   *compound;
X
X    if (!valid_rot_angle(c)) {
X	put_msg("Invalid rotation angle for this compound object");
X	return;
X    }
X
X    set_temp_cursor(wait_cursor);
X    compound = copy_compound(c);
X    rotate_compound(compound, px, py, rotn_dirn);
X    if (copy) {
X	add_compound(compound);
X    } else {
X	toggle_compoundmarker(c);
X	draw_compoundelements(c, ERASE);
X	change_compound(c, compound);
X    }
X    draw_compoundelements(compound, PAINT);
X    toggle_compoundmarker(compound);
X    reset_cursor();
X}
X
Xrotate_line(l, x, y, rotn_dirn)
X    F_line	   *l;
X    int		    x, y, rotn_dirn;
X{
X    F_point	   *p;
X    int		    dx;
X
X    /* for speed we treat 90 degrees as a special case */
X    if (cur_rotnangle == 90) {
X	for (p = l->points; p != NULL; p = p->next) {
X	    dx = p->x - x;
X	    p->x = x + rotn_dirn * (y - p->y);
X	    p->y = y + rotn_dirn * dx;
X	}
X    } else {
X	for (p = l->points; p != NULL; p = p->next)
X	    rotate_point(p, x, y, rotn_dirn);
X    }
X}
X
Xrotate_spline(s, x, y, rotn_dirn)
X    F_spline	   *s;
X    int		    x, y, rotn_dirn;
X{
X    F_point	   *p;
X    F_control	   *cp;
X    int		    dx;
X
X    /* for speed we treat 90 degrees as a special case */
X    if (cur_rotnangle == 90) {
X	for (p = s->points; p != NULL; p = p->next) {
X	    dx = p->x - x;
X	    p->x = x + rotn_dirn * (y - p->y);
X	    p->y = y + rotn_dirn * dx;
X	}
X	for (cp = s->controls; cp != NULL; cp = cp->next) {
X	    dx = cp->lx - x;
X	    cp->lx = x + rotn_dirn * (y - cp->ly);
X	    cp->ly = y + rotn_dirn * dx;
X	    dx = cp->rx - x;
X	    cp->rx = x + rotn_dirn * (y - cp->ry);
X	    cp->ry = y + rotn_dirn * dx;
X	}
X    } else {
X	for (p = s->points; p != NULL; p = p->next)
X	    rotate_point(p, x, y, rotn_dirn);
X	if (int_spline(s))
X	    remake_control_points(s);
X    }
X}
X
Xrotate_text(t, x, y, rotn_dirn)
X    F_text	   *t;
X    int		    x, y, rotn_dirn;
X{
X    int		    dx;
X
X    if (cur_rotnangle == 90) { /* treat 90 degs as special case for speed */
X	dx = t->base_x - x;
X	t->base_x = x + rotn_dirn * (y - t->base_y);
X	t->base_y = y + rotn_dirn * dx;
X    } else {
X	rotate_xy(&t->base_x, &t->base_y, x, y, rotn_dirn);
X    }
X    t->angle -= (float) (rotn_dirn * cur_rotnangle * M_PI / 180);
X    if (t->angle < 0)
X	t->angle += 2 * M_PI;
X    else if (t->angle >= 2 * M_PI)
X	t->angle -= 2 * M_PI;
X}
X
Xrotate_ellipse(e, x, y, rotn_dirn)
X    F_ellipse	   *e;
X    int		    x, y, rotn_dirn;
X{
X    int		    dx;
X
X    dx = e->center.x - x;
X    e->center.x = x + rotn_dirn * (y - e->center.y);
X    e->center.y = y + rotn_dirn * dx;
X    dx = e->radiuses.x;
X    e->radiuses.x = e->radiuses.y;
X    e->radiuses.y = dx;
X    dx = e->start.x - x;
X    e->start.x = x + rotn_dirn * (y - e->start.y);
X    e->start.y = y + rotn_dirn * dx;
X    dx = e->end.x - x;
X    e->end.x = x + rotn_dirn * (y - e->end.y);
X    e->end.y = y + rotn_dirn * dx;
X}
X
Xrotate_arc(a, x, y, rotn_dirn)
X    F_arc	   *a;
X    int		    x, y, rotn_dirn;
X{
X    int		    dx;
X    F_pos	    p[3];
X    float	    xx, yy;
X
X    /* for speed we treat 90 degrees as a special case */
X    if (cur_rotnangle == 90) {
X	dx = a->center.x - x;
X	a->center.x = x + rotn_dirn * (y - a->center.y);
X	a->center.y = y + rotn_dirn * dx;
X	dx = a->point[0].x - x;
X	a->point[0].x = x + rotn_dirn * (y - a->point[0].y);
X	a->point[0].y = y + rotn_dirn * dx;
X	dx = a->point[1].x - x;
X	a->point[1].x = x + rotn_dirn * (y - a->point[1].y);
X	a->point[1].y = y + rotn_dirn * dx;
X	dx = a->point[2].x - x;
X	a->point[2].x = x + rotn_dirn * (y - a->point[2].y);
X	a->point[2].y = y + rotn_dirn * dx;
X    } else {
X	p[0] = a->point[0];
X	p[1] = a->point[1];
X	p[2] = a->point[2];
X	rotate_point(&p[0], x, y, rotn_dirn);
X	rotate_point(&p[1], x, y, rotn_dirn);
X	rotate_point(&p[2], x, y, rotn_dirn);
X	if (compute_arccenter(p[0], p[1], p[2], &xx, &yy)) {
X	    a->point[0].x = p[0].x;
X	    a->point[0].y = p[0].y;
X	    a->point[1].x = p[1].x;
X	    a->point[1].y = p[1].y;
X	    a->point[2].x = p[2].x;
X	    a->point[2].y = p[2].y;
X	    a->center.x = xx;
X	    a->center.y = yy;
X	    a->direction = compute_direction(p[0], p[1], p[2]);
X	}
X    }
X}
X
X/* checks to see if the objects within c can be rotated by cur_rotnangle */
X
Xvalid_rot_angle(c)
X    F_compound     *c;
X{
X    F_line         *l;
X    F_compound     *c1;
X
X    if (cur_rotnangle == 90)
X	return 1; /* always valid */
X    if (c->ellipses != NULL)
X	return 0;
X    for (l = c->lines; l != NULL; l = l->next)
X	if (l->type == T_ARC_BOX || l->type == T_BOX)
X	    return 0;
X    for (c1 = c->compounds; c1 != NULL; c1 = c1->next)
X	if (!valid_rot_angle(c1))
X	    return 0;
X    return 1;
X}
X
Xrotate_compound(c, x, y, rotn_dirn)
X    F_compound	   *c;
X    int		    x, y, rotn_dirn;
X{
X    F_line	   *l;
X    F_arc	   *a;
X    F_ellipse	   *e;
X    F_spline	   *s;
X    F_text	   *t;
X    F_compound	   *c1;
X
X    for (l = c->lines; l != NULL; l = l->next)
X	rotate_line(l, x, y, rotn_dirn);
X    for (a = c->arcs; a != NULL; a = a->next)
X	rotate_arc(a, x, y, rotn_dirn);
X    for (e = c->ellipses; e != NULL; e = e->next)
X	rotate_ellipse(e, x, y, rotn_dirn);
X    for (s = c->splines; s != NULL; s = s->next)
X	rotate_spline(s, x, y, rotn_dirn);
X    for (t = c->texts; t != NULL; t = t->next)
X	rotate_text(t, x, y, rotn_dirn);
X    for (c1 = c->compounds; c1 != NULL; c1 = c1->next)
X	rotate_compound(c1, x, y, rotn_dirn);
X
X    /*
X     * Make the bounding box exactly match the dimensions of the compound.
X     */
X    compound_bound(c, &c->nwcorner.x, &c->nwcorner.y,
X		   &c->secorner.x, &c->secorner.y);
X}
X
Xrotate_point(p, x, y, rotn)
X    F_point	   *p;
X    int		    x, y, rotn;
X{
X    /* rotate point p about coordinate (x, y) */
X    int		    dx, dy;
X    float	    cosa, sina, mag, theta;
X
X    dx = p->x - x;
X    dy = y - p->y;
X    if (dx == 0 && dy == 0)
X	return;
X
X    theta = compute_angle((float) dx, (float) dy);
X    theta -= (float) (rotn_dirn * cur_rotnangle * M_PI / 180);
X    if (theta < 0)
X	theta += 2 * M_PI;
X    else if (theta >= 2 * M_PI)
X	theta -= 2 * M_PI;
X    mag = sqrt((double) (dx * dx + dy * dy));
X    cosa = mag * cos((double) theta);
X    sina = mag * sin((double) theta);
X    p->x = x + cosa;
X    p->y = y - sina;
X}
X
Xrotate_xy(orig_x, orig_y, x, y, rotn)
X    int             *orig_x, *orig_y, x, y, rotn;
X{
X    /* rotate coord (orig_x, orig_y) about coordinate (x, y) */
X    int             dx, dy;
X    float           cosa, sina, mag, theta;
X
X    dx = *orig_x - x;
X    dy = y - *orig_y;
X    if (dx == 0 && dy == 0)
X	return;
X
X    theta = compute_angle((float) dx, (float) dy);
X    theta -= (float) (rotn_dirn * cur_rotnangle * M_PI / 180);
X    if (theta < 0)
X	theta += 2 * M_PI;
X    else if (theta >= 2 * M_PI)
X	theta -= 2 * M_PI;
X    mag = sqrt((double) (dx * dx + dy * dy));
X    cosa = mag * cos((double) theta);
X    sina = mag * sin((double) theta);
X    *orig_x = x + cosa;
X    *orig_y = y - sina;
X}
END_OF_FILE
if test 11575 -ne `wc -c <'e_rotate.c'`; then
    echo shar: \"'e_rotate.c'\" unpacked with wrong size!
fi
# end of 'e_rotate.c'
fi
if test -f 'w_canvas.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'w_canvas.c'\"
else
echo shar: Extracting \"'w_canvas.c'\" \(11983 characters\)
sed "s/^X//" >'w_canvas.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of M.I.T. not be used in advertising or
X * publicity pertaining to distribution of the software without specific,
X * written prior permission.  M.I.T. makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty."
X *
X */
X
X/*********************** IMPORTS ************************/
X
X#include <string.h>
X#include "fig.h"
X#include "resources.h"
X#include "mode.h"
X#include "paintop.h"
X#include <X11/keysym.h>
X#include "u_bound.h"
X#include "w_canvas.h"
X#include "w_mousefun.h"
X#include "w_setup.h"
X#include "w_util.h"
X#include "w_zoom.h"
X#include "sys/time.h"
X#include <X11/Xatom.h>
X
X#ifdef NOSTRSTR
Xextern char *strstr();
X#endif
X
Xextern		erase_rulermark();
Xextern		erase_objecthighlight();
Xextern		char_handler();
X
X/************** LOCAL STRUCTURE ***************/
X
Xtypedef struct _CompKey CompKey;
X
Xstruct _CompKey {
X    unsigned char   key;
X    unsigned char   first;
X    unsigned char   second;
X    CompKey	   *next;
X};
X
X/*********************** EXPORTS ************************/
X
Xint		(*canvas_kbd_proc) ();
Xint		(*canvas_locmove_proc) ();
Xint		(*canvas_leftbut_proc) ();
Xint		(*canvas_middlebut_proc) ();
Xint		(*canvas_middlebut_save) ();
Xint		(*canvas_rightbut_proc) ();
Xint		(*return_proc) ();
Xint		null_proc();
Xint		clip_xmin, clip_ymin, clip_xmax, clip_ymax;
Xint		clip_width, clip_height;
Xint		cur_x, cur_y;
X
XString		local_translations = "";
X
X/*********************** LOCAL ************************/
X
Xstatic CompKey *allCompKey = NULL;
Xstatic		canvas_selected();
Xstatic unsigned char getComposeKey();
Xstatic		readComposeKey();
Xstatic void	clear_char_string();
X
Xint		ignore_exp_cnt = 2;	/* we get 2 expose events at startup */
X
Xnull_proc()
X{
X    /* almost does nothing */
X    if (highlighting)
X	erase_objecthighlight();
X}
X
Xstatic void
Xcanvas_exposed(tool, event, params, nparams)
X    TOOL	    tool;
X    INPUTEVENT	   *event;
X    String	   *params;
X    Cardinal	   *nparams;
X{
X    static	    xmin = 9999, xmax = -9999, ymin = 9999, ymax = -9999;
X    XExposeEvent   *xe = (XExposeEvent *) event;
X    register int    tmp;
X
X    if (xe->x < xmin)
X	xmin = xe->x;
X    if (xe->y < ymin)
X	ymin = xe->y;
X    if ((tmp = xe->x + xe->width) > xmax)
X	xmax = tmp;
X    if ((tmp = xe->y + xe->height) > ymax)
X	ymax = tmp;
X    if (xe->count > 0)
X	return;
X
X    /* kludge to stop getting extra redraws at start up */
X    if (ignore_exp_cnt)
X	ignore_exp_cnt--;
X    else
X	redisplay_region(xmin, ymin, xmax, ymax);
X    xmin = 9999, xmax = -9999, ymin = 9999, ymax = -9999;
X}
X
Xstatic void canvas_paste();
X
XXtActionsRec	canvas_actions[] =
X{
X    {"EventCanv", (XtActionProc) canvas_selected},
X    {"ExposeCanv", (XtActionProc) canvas_exposed},
X    {"EnterCanv", (XtActionProc) draw_mousefun_canvas},
X    {"PasteCanv", (XtActionProc) canvas_paste},
X    {"LeaveCanv", (XtActionProc) clear_mousefun},
X    {"EraseRulerMark", (XtActionProc) erase_rulermark},
X};
X
Xstatic String	canvas_translations =
X"<Motion>:EventCanv()\n\
X    Any<BtnDown>:EventCanv()\n\
X    <Key>F18: PasteCanv()\n\
X    <EnterWindow>:EnterCanv()\n\
X    <LeaveWindow>:LeaveCanv()EraseRulerMark()\n\
X    <Key>:EventCanv()\n\
X    <Expose>:ExposeCanv()\n";
X
Xinit_canvas(tool)
X    TOOL	   tool;
X{
X    XColor	   fixcolors[2];
X
X    DeclareArgs(10);
X
X    FirstArg(XtNlabel, "");
X    NextArg(XtNwidth, CANVAS_WD);
X    NextArg(XtNheight, CANVAS_HT);
X    NextArg(XtNfromHoriz, mode_panel);
X    NextArg(XtNhorizDistance, -INTERNAL_BW);
X    NextArg(XtNfromVert, topruler_sw);
X    NextArg(XtNvertDistance, -INTERNAL_BW);
X    NextArg(XtNtop, XtChainTop);
X    NextArg(XtNleft, XtChainLeft);
X    NextArg(XtNborderWidth, INTERNAL_BW);
X
X    canvas_sw = XtCreateWidget("canvas", labelWidgetClass, tool,
X			       Args, ArgCount);
X
X    FirstArg(XtNforeground, &x_fg_color.pixel);
X    NextArg(XtNbackground, &x_bg_color.pixel);
X    GetValues(canvas_sw);
X
X    /*
X     * get the RGB values for recolor cursor use -- may want to have cursor
X     * color resource
X     */
X    fixcolors[0] = x_fg_color;
X    fixcolors[1] = x_bg_color;
X    XQueryColors(tool_d, DefaultColormapOfScreen(tool_s), fixcolors, 2);
X    x_fg_color = fixcolors[0];
X    x_bg_color = fixcolors[1];
X
X    /* now fix the global GC */
X    XSetState(tool_d, gc, x_fg_color.pixel, x_bg_color.pixel, GXcopy,
X	      AllPlanes);
X
X    /* and recolor the cursors */
X    recolor_cursors();
X
X    canvas_leftbut_proc = null_proc;
X    canvas_middlebut_proc = null_proc;
X    canvas_rightbut_proc = null_proc;
X    canvas_kbd_proc = canvas_locmove_proc = null_proc;
X    XtAppAddActions(tool_app, canvas_actions, XtNumber(canvas_actions));
X    XtAugmentTranslations(canvas_sw,
X			   XtParseTranslationTable(canvas_translations));
X
X    readComposeKey();
X
X    return (1);
X}
X
Xstatic void
Xclear_char_string()
X{
X    char_handler('\015');
X}
X
Xsetup_canvas()
X{
X    canvas_win = XtWindow(canvas_sw);
X    init_grid();
X    reset_clip_window();
X}
X
X/* macro which rounds coordinates depending on point positioning mode */
X#define		round_coords(x, y) \
X    if (cur_pointposn != P_ANY) \
X	if (!anypointposn) { \
X	    x = ((t = x%posn_rnd[cur_pointposn]) < posn_hlf[cur_pointposn]) \
X		? x - t - 1 : x + posn_rnd[cur_pointposn] - t - 1; \
X	    y = ((t = y%posn_rnd[cur_pointposn]) < posn_hlf[cur_pointposn]) \
X		? y - t - 1 : y + posn_rnd[cur_pointposn] - t - 1; \
X	}
X
Xstatic
Xcanvas_selected(tool, event, params, nparams)
X    TOOL	    tool;
X    INPUTEVENT	   *event;
X    String	   *params;
X    Cardinal	   *nparams;
X{
X    register int    x, y, t;
X    static int	    sx = -10000, sy = -10000;
X    char	    buf[1];
X    XButtonPressedEvent *be = (XButtonPressedEvent *) event;
X    XKeyPressedEvent *ke = (XKeyPressedEvent *) event;
X
X    static char	    compose_buf[2];
X    static char	    compose_key = 0;
X    unsigned char   c;
X
X    switch (event->type) {
X    case MotionNotify:
X#if defined(SMOOTHMOTION) || defined(OPENWIN)
X	/* translate from zoomed coords to object coords */
X	x = BACKX(event->x);
X	y = BACKY(event->y);
X
X	/* perform appropriate rounding if necessary */
X	round_coords(x, y);
X
X	if (x == sx && y == sy)
X	    return;
X	sx = x;
X	sy = y;
X#else
X	{
X	    Window	    rw, cw;
X	    int		    rx, ry, cx, cy;
X	    unsigned int    mask;
X
X	    XQueryPointer(event->display, event->window,
X			  &rw, &cw,
X			  &rx, &ry,
X			  &cx, &cy,
X			  &mask);
X	    cx = BACKX(cx);
X	    cy = BACKY(cy);
X
X	    /* perform appropriate rounding if necessary */
X	    round_coords(cx, cy);
X
X	    if (cx == sx && cy == sy)
X		break;
X	    x = sx = cx;	/* these are zoomed */
X	    y = sy = cy;	/* coordinates!	    */
X	}
X#endif /* SMOOTHMOTION || OPENWIN */
X	set_rulermark(x, y);
X	(*canvas_locmove_proc) (x, y);
X	break;
X    case ButtonPress:
X	/* translate from zoomed coords to object coords */
X	x = BACKX(event->x);
X	y = BACKY(event->y);
X
X	/* call interactive zoom function if control key is pressed */
X	if (be->state & ControlMask) {
X	    zoom_selected(x, y, be->button);
X	    break;
X	}
X	/* perform appropriate rounding if necessary */
X	round_coords(x, y);
X
X	if (be->button == Button1)
X	    (*canvas_leftbut_proc) (x, y, be->state & ShiftMask);
X	else if (be->button == Button2)
X	    (*canvas_middlebut_proc) (x, y, be->state & ShiftMask);
X	else if (be->button == Button3)
X	    (*canvas_rightbut_proc) (x, y, be->state & ShiftMask);
X	break;
X    case KeyPress:
X	/* we might want to check action_on */
X	/* if arrow keys are pressed, pan */
X	t = XLookupKeysym(ke, 0);
X	if (t == XK_Left ||
X	    t == XK_Right ||
X	    t == XK_Up ||
X	    t == XK_Down ||
X	    t == XK_Home ||
X	    t == XK_Multi_key) {
X	    switch (t) {
X	    case XK_Left:
X		pan_left();
X		break;
X	    case XK_Right:
X		pan_right();
X		break;
X	    case XK_Up:
X		pan_up();
X		break;
X	    case XK_Down:
X		pan_down();
X		break;
X	    case XK_Home:
X		pan_origin();
X		break;
X	    case XK_Multi_key:
X		compose_key = 1;
X		break;
X	    }
X	} else {
X	    switch (compose_key) {
X	    case 0:
X		if (XLookupString(ke, buf, sizeof(buf), NULL, NULL) > 0)
X		    (*canvas_kbd_proc) ((unsigned char) buf[0]);
X		break;
X	    case 1:
X		if (XLookupString(ke, &compose_buf[0], 1, NULL, NULL)
X		    > 0)
X		    compose_key = 2;
X		break;
X	    case 2:
X		if (XLookupString(ke, &compose_buf[1], 1, NULL, NULL)
X		    > 0) {
X		    if ((c = getComposeKey(compose_buf)) != '\0')
X			(*canvas_kbd_proc) (c);
X		    else {
X			(*canvas_kbd_proc) ((unsigned char) compose_buf[0]);
X			(*canvas_kbd_proc) ((unsigned char) compose_buf[1]);
X		    }
X		    compose_key = 0;
X		}
X		break;
X	    }
X	}
X	break;
X    }
X}
X
Xclear_canvas()
X{
X    XClearArea(tool_d, canvas_win, clip_xmin, clip_ymin,
X	       clip_width, clip_height, False);
X}
X
Xclear_region(xmin, ymin, xmax, ymax)
X    int		    xmin, ymin, xmax, ymax;
X{
X    XClearArea(tool_d, canvas_win, xmin, ymin,
X	       xmax - xmin + 1, ymax - ymin + 1, False);
X}
X
Xstatic void canvas_paste(w, paste_event)
XWidget w;
XXKeyEvent *paste_event;
X{
X	static void get_canvas_clipboard();
X	Time event_time;
X
X	if (canvas_kbd_proc != char_handler)
X		return;
X
X	if (paste_event != NULL)
X		event_time = paste_event->time;
X	   else
X		time((time_t *) &event_time);
X	/***
X	This doesn't seem to work:
X	XtGetSelectionValue(w, XInternAtom(XtDisplay(w), "XA_PRIMARY", False),
X		XA_STRING, get_canvas_clipboard, NULL, event_time);
X	***/
X	XtGetSelectionValue(w, XA_PRIMARY,
X		XA_STRING, get_canvas_clipboard, NULL, event_time);
X}
X
Xstatic void
Xget_canvas_clipboard(w, client_data, selection, type, buf, length, format)
XWidget w;
XXtPointer client_data;
XAtom *selection;
XAtom *type;
XXtPointer buf;
Xunsigned long *length;
Xint *format;
X{
X	char *c;
X	int i;
X
X	c = buf;
X	for (i=0; i<*length; i++) {
X           canvas_kbd_proc(*c);
X           c++;
X	}
X	XtFree(buf);
X}
X
Xstatic unsigned char
XgetComposeKey(buf)
X    char	   *buf;
X{
X    CompKey	   *compKeyPtr = allCompKey;
X
X    while (compKeyPtr != NULL) {
X	if (compKeyPtr->first == (unsigned char) (buf[0]) &&
X	    compKeyPtr->second == (unsigned char) (buf[1]))
X	    return (compKeyPtr->key);
X	else
X	    compKeyPtr = compKeyPtr->next;
X    }
X    return ('\0');
X}
X
Xstatic
XreadComposeKey()
X{
X    FILE	   *st;
X    CompKey	   *compKeyPtr;
X    char	    line[255];
X    char	   *p;
X    char	   *p1;
X    char	   *p2;
X    char	   *p3;
X    long	    size;
X
X    /* put together the filename from the dir name and file name */
X    strcpy(line, XFIGLIBDIR);
X    strcat(line, "/");
X    strcat(line, appres.keyFile);
X    if ((st = fopen(line, "r")) == NULL) {
X	allCompKey = NULL;
X	fprintf(stderr,"%cCan't open compose key file '%s',\n",007,line);
X	fprintf(stderr,"\tno multi-key sequences available\n");
X	return;
X    }
X    fseek(st, 0, 2);
X    size = ftell(st);
X    fseek(st, 0, 0);
X
X    local_translations = (String) malloc(size + 1);
X
X    strcpy(local_translations, "");
X    while (fgets(line, 250, st) != NULL) {
X	if (line[0] != '#') {
X	    strcat(local_translations, line);
X	    if ((p = strstr(line, "Multi_key")) != NULL) {
X		if (allCompKey == NULL) {
X		    allCompKey = (CompKey *) malloc(sizeof(CompKey));
X		    compKeyPtr = allCompKey;
X		} else {
X		    compKeyPtr->next = (CompKey *) malloc(sizeof(CompKey));
X		    compKeyPtr = compKeyPtr->next;
X		}
X
X		p1 = strstr(p, "<Key>") + strlen("<Key>");
X		p = strstr(p1, ",");
X		*p++ = '\0';
X		p2 = strstr(p, "<Key>") + strlen("<Key>");
X		p = strstr(p2, ":");
X		*p++ = '\0';
X		p3 = strstr(p, "insert-string(") + strlen("insert-string(");
X		p = strstr(p3, ")");
X		*p++ = '\0';
X
X		if (strlen(p3) == 1)
X		    compKeyPtr->key = *p3;
X		else
X		    compKeyPtr->key = strtol(p3, NULL, 16);
X		compKeyPtr->first = XStringToKeysym(p1);
X		compKeyPtr->second = XStringToKeysym(p2);
X		compKeyPtr->next = NULL;
X	    }
X	}
X    }
X
X    fclose(st);
X
X}
END_OF_FILE
if test 11983 -ne `wc -c <'w_canvas.c'`; then
    echo shar: \"'w_canvas.c'\" unpacked with wrong size!
fi
# end of 'w_canvas.c'
fi
if test -f 'w_export.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'w_export.c'\"
else
echo shar: Extracting \"'w_export.c'\" \(11875 characters\)
sed "s/^X//" >'w_export.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of M.I.T. not be used in advertising or
X * publicity pertaining to distribution of the software without specific,
X * written prior permission.  M.I.T. makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty."
X *
X */
X
X/* IMPORTS */
X
X#include <math.h>		/* for atof() */
X#include "fig.h"
X#include "mode.h"
X#include "resources.h"
X#include "w_dir.h"
X#include "w_drawprim.h"		/* for char_height */
X#include "w_setup.h"
X#include "w_util.h"
X
Xextern String	text_translations;
Xextern Widget	make_popup_menu();
Xextern char    *panel_get_value();
X
X/* LOCAL */
X
Xstatic String	file_name_translations =
X	"<Key>Return: ExportFile()\n";
Xvoid		do_export();
Xstatic XtActionsRec	file_name_actions[] =
X{
X    {"ExportFile", (XtActionProc) do_export},
X};
X
Xstatic char	default_file[60];
Xstatic char	named_file[60];
X
Xstatic char    *orient_items[] = {
X    "portrait ",
X    "landscape"};
X
Xstatic char    *just_items[] = {
X    "flush left",
X    "centered  "};
X
Xstatic void	orient_select();
Xstatic Widget	orient_panel, orient_menu, orient_lab;
X
Xstatic void	lang_select();
Xstatic Widget	lang_panel, lang_menu, lang_lab;
X
Xstatic void	just_select();
Xstatic Widget	just_panel, just_menu, just_lab;
Xstatic int	print_centered = 1;
X
Xstatic Widget	cancel_but, export_but;
Xstatic Widget	dfile_lab, dfile_text, nfile_lab;
Xstatic Widget	export_panel, export_popup, mag_lab, mag_text, export_w;
Xstatic Position xposn, yposn;
X
X/* Global so w_dir.c can access us */
X
XWidget		exp_selfile,	/* output (selected) file widget */
X		exp_mask,	/* mask widget */
X		exp_dir,	/* current directory widget */
X		exp_flist,	/* file list wiget */
X		exp_dlist;	/* dir list wiget */
X
XBoolean		export_up = False;
X
Xstatic void
Xexport_panel_dismiss()
X{
X    XtPopdown(export_popup);
X    XtSetSensitive(export_w, True);
X    export_up = False;
X}
X
Xstatic void
Xexport_panel_cancel(w, ev)
X    Widget	    w;
X    XButtonEvent   *ev;
X{
X    export_panel_dismiss();
X}
X
Xstatic char	export_msg[] = "EXPORT";
X
Xvoid
Xdo_export(w)
X    Widget	    w;
X{
X    DeclareArgs(1);
X    float	    mag;
X    char	   *fval, *dval;
X    char	    filename[100];
X
X    if (emptyfigure_msg(export_msg))
X	return;
X
X    if (export_popup) {
X	FirstArg(XtNstring, &fval);
X	GetValues(exp_selfile);
X	FirstArg(XtNstring, &dval);
X	GetValues(exp_dir);
X	if (emptyname(fval))
X	    fval = default_file;
X
X	strcpy(filename, dval);
X	strcat(filename, "/");
X	strcat(filename, fval);
X
X	/* check for XBitmap first */
X	if (cur_exp_lang == LANG_XBITMAP) {
X	    XtSetSensitive(export_but, False);
X	    if (write_bitmap(filename) == 0)
X		export_panel_dismiss();
X	    XtSetSensitive(export_but, True);
X	} else {
X	    mag = (float) atof(panel_get_value(mag_text)) / 100.0;
X	    if (mag <= 0.0)
X		mag = 1.0;
X	    XtSetSensitive(export_but, False);
X	    if (print_to_file(filename, lang_items[cur_exp_lang],
X			      mag, print_centered) == 0)
X		export_panel_dismiss();
X	    XtSetSensitive(export_but, True);
X	}
X    } else {
X	update_def_filename();
X	print_to_file(default_file, lang_items[cur_exp_lang], 0, 1.0);
X    }
X}
X
Xstatic void
Xorient_select(w, new_orient, garbage)
X    Widget	    w;
X    XtPointer	    new_orient, garbage;
X{
X    DeclareArgs(1);
X
X    FirstArg(XtNlabel, XtName(w));
X    SetValues(orient_panel);
X    print_landscape = (int) new_orient;
X}
X
Xstatic void
Xjust_select(w, new_just, garbage)
X    Widget	    w;
X    XtPointer	    new_just, garbage;
X{
X    DeclareArgs(1);
X
X    FirstArg(XtNlabel, XtName(w));
X    SetValues(just_panel);
X    print_centered = (int) new_just;
X}
X
Xstatic void
Xlang_select(w, new_lang, garbage)
X    Widget	    w;
X    XtPointer	    new_lang, garbage;
X{
X    DeclareArgs(1);
X
X    FirstArg(XtNlabel, XtName(w));
X    SetValues(lang_panel);
X    cur_exp_lang = (int) new_lang;
X    if (cur_exp_lang == LANG_XBITMAP) {
X	XtSetSensitive(mag_lab, False);
X	XtSetSensitive(mag_text, False);
X	XtSetSensitive(orient_lab, False);
X	XtSetSensitive(orient_panel, False);
X    } else {
X	XtSetSensitive(mag_lab, True);
X	XtSetSensitive(mag_text, True);
X	XtSetSensitive(orient_lab, True);
X	XtSetSensitive(orient_panel, True);
X    }
X
X    if (cur_exp_lang == LANG_PS) {
X	XtSetSensitive(just_lab, True);
X	XtSetSensitive(just_panel, True);
X    } else {
X	XtSetSensitive(just_lab, False);
X	XtSetSensitive(just_panel, False);
X    }
X
X    update_def_filename();
X    FirstArg(XtNlabel, default_file);
X    SetValues(dfile_text);
X}
X
Xpopup_export_panel(w)
X    Widget	    w;
X{
X    Widget	    image, beside, below;
X    XtTranslations  popdown_actions;
X    PIX_FONT	    temp_font;
X
X    DeclareArgs(10);
X
X    set_temp_cursor(wait_cursor);
X    XtSetSensitive(w, False);
X    export_up = True;
X
X    if (!export_popup) {
X	export_w = w;
X	XtTranslateCoords(w, (Position) 0, (Position) 0, &xposn, &yposn);
X
X	FirstArg(XtNx, xposn);
X	NextArg(XtNy, yposn + 50);
X	NextArg(XtNtitle, "Xfig: Export menu");
X	export_popup = XtCreatePopupShell("xfig_export_menu",
X					  transientShellWidgetClass,
X					  tool, Args, ArgCount);
X
X	export_panel = XtCreateManagedWidget("export_panel", formWidgetClass,
X					     export_popup, NULL, ZERO);
X	popdown_actions = XtParseTranslationTable(
X						  "<Btn1Up>:\n");
X	XtOverrideTranslations(export_panel, popdown_actions);
X
X	FirstArg(XtNlabel, "   Magnification%:");
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	mag_lab = XtCreateManagedWidget("mag_label", labelWidgetClass,
X					export_panel, Args, ArgCount);
X
X	FirstArg(XtNwidth, 40);
X	NextArg(XtNfromHoriz, mag_lab);
X	NextArg(XtNeditType, "edit");
X	NextArg(XtNstring, "100");
X	NextArg(XtNinsertPosition, 3);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	mag_text = XtCreateManagedWidget("magnification", asciiTextWidgetClass,
X					 export_panel, Args, ArgCount);
X	XtOverrideTranslations(mag_text,
X			   XtParseTranslationTable(text_translations));
X
X	FirstArg(XtNlabel, "      Orientation:");
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	NextArg(XtNfromVert, mag_text);
X	orient_lab = XtCreateManagedWidget("orient_label", labelWidgetClass,
X					   export_panel, Args, ArgCount);
X
X	FirstArg(XtNfromHoriz, orient_lab);
X	NextArg(XtNfromVert, mag_text);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	orient_panel = XtCreateManagedWidget(orient_items[print_landscape],
X					     menuButtonWidgetClass,
X					     export_panel, Args, ArgCount);
X	orient_menu = make_popup_menu(orient_items, XtNumber(orient_items),
X				      orient_panel, orient_select);
X
X	FirstArg(XtNlabel, "    Justification:");
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	NextArg(XtNfromVert, orient_panel);
X	just_lab = XtCreateManagedWidget("just_label", labelWidgetClass,
X					 export_panel, Args, ArgCount);
X
X	FirstArg(XtNlabel, just_items[print_centered]);
X	NextArg(XtNfromHoriz, just_lab);
X	NextArg(XtNfromVert, orient_panel);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	just_panel = XtCreateManagedWidget("justify",
X					   menuButtonWidgetClass,
X					   export_panel, Args, ArgCount);
X	just_menu = make_popup_menu(just_items, XtNumber(just_items),
X				    just_panel, just_select);
X
X	FirstArg(XtNlabel, "         Language:");
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	NextArg(XtNfromVert, just_panel);
X	lang_lab = XtCreateManagedWidget("lang_label", labelWidgetClass,
X					 export_panel, Args, ArgCount);
X
X	FirstArg(XtNfromHoriz, lang_lab);
X	NextArg(XtNfromVert, just_panel);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	lang_panel = XtCreateManagedWidget(lang_texts[cur_exp_lang],
X					   menuButtonWidgetClass,
X					   export_panel, Args, ArgCount);
X	lang_menu = make_popup_menu(lang_texts, XtNumber(lang_texts),
X				    lang_panel, lang_select);
X
X	FirstArg(XtNlabel, " Default Filename:");
X	NextArg(XtNfromVert, lang_panel);
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	dfile_lab = XtCreateManagedWidget("def_file_label", labelWidgetClass,
X					  export_panel, Args, ArgCount);
X
X	FirstArg(XtNlabel, default_file);
X	NextArg(XtNfromVert, lang_panel);
X	NextArg(XtNfromHoriz, dfile_lab);
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	NextArg(XtNwidth, 250);
X	dfile_text = XtCreateManagedWidget("def_file_name", labelWidgetClass,
X					   export_panel, Args, ArgCount);
X
X	FirstArg(XtNlabel, "  Output Filename:");
X	NextArg(XtNfromVert, dfile_text);
X	NextArg(XtNjustify, XtJustifyLeft);
X	NextArg(XtNborderWidth, 0);
X	nfile_lab = XtCreateManagedWidget("out_file_name", labelWidgetClass,
X					  export_panel, Args, ArgCount);
X
X	FirstArg(XtNfont, &temp_font);
X	GetValues(nfile_lab);
X
X	FirstArg(XtNwidth, 350);
X	NextArg(XtNheight, char_height(temp_font) * 2 + 4);
X	NextArg(XtNfromHoriz, nfile_lab);
X	NextArg(XtNfromVert, dfile_text);
X	NextArg(XtNeditType, "edit");
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	NextArg(XtNstring, named_file);
X	NextArg(XtNinsertPosition, strlen(named_file));
X	NextArg(XtNscrollHorizontal, XawtextScrollWhenNeeded);
X	exp_selfile = XtCreateManagedWidget("file", asciiTextWidgetClass,
X					    export_panel, Args, ArgCount);
X	XtOverrideTranslations(exp_selfile,
X			   XtParseTranslationTable(text_translations));
X
X	/* add action to export file for following translation */
X	XtAppAddActions(tool_app, file_name_actions, XtNumber(file_name_actions));
X
X	/* make <return> in the filename window export the file */
X	XtOverrideTranslations(exp_selfile,
X			   XtParseTranslationTable(file_name_translations));
X
X	create_dirinfo(export_panel, exp_selfile, &beside, &below,
X		       &exp_mask, &exp_dir, &exp_flist, &exp_dlist);
X
X	FirstArg(XtNlabel, "Cancel");
X	NextArg(XtNfromHoriz, beside);
X	NextArg(XtNfromVert, below);
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNhorizDistance, 25);
X	NextArg(XtNheight, 25);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	cancel_but = XtCreateManagedWidget("cancel", commandWidgetClass,
X					   export_panel, Args, ArgCount);
X	XtAddEventHandler(cancel_but, ButtonReleaseMask, (Boolean) 0,
X			  (XtEventHandler)export_panel_cancel, (XtPointer) NULL);
X
X	FirstArg(XtNlabel, "Export");
X	NextArg(XtNfromVert, below);
X	NextArg(XtNfromHoriz, cancel_but);
X	NextArg(XtNvertDistance, 15);
X	NextArg(XtNhorizDistance, 25);
X	NextArg(XtNheight, 25);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	export_but = XtCreateManagedWidget("export", commandWidgetClass,
X					   export_panel, Args, ArgCount);
X	XtAddEventHandler(export_but, ButtonReleaseMask, (Boolean) 0,
X			  (XtEventHandler)do_export, (XtPointer) NULL);
X
X	if (cur_exp_lang == LANG_XBITMAP) {
X	    XtSetSensitive(mag_lab, False);
X	    XtSetSensitive(mag_text, False);
X	    XtSetSensitive(orient_lab, False);
X	    XtSetSensitive(orient_panel, False);
X	}
X	if (cur_exp_lang != LANG_PS) {
X	    XtSetSensitive(just_lab, False);
X	    XtSetSensitive(just_panel, False);
X	}
X    } else {
X	Rescan();
X    }
X    update_def_filename();
X    FirstArg(XtNlabel, default_file);
X    NextArg(XtNwidth, 250);
X    SetValues(dfile_text);
X    XtPopup(export_popup, XtGrabNonexclusive);
X    reset_cursor();
X}
X
Xupdate_def_filename()
X{
X    int		    i;
X
X    (void) strcpy(default_file, cur_filename);
X    if (default_file[0] != '\0') {
X	i = strlen(default_file);
X	if (i >= 4 && strcmp(&default_file[i - 4], ".fig") == 0)
X	    default_file[i - 4] = '\0';
X	(void) strcat(default_file, ".");
X	(void) strcat(default_file, lang_items[cur_exp_lang]);
X    }
X    /* remove trailing blanks */
X    for (i = strlen(default_file) - 1; i >= 0; i--)
X	if (default_file[i] == ' ')
X	    default_file[i] = '\0';
X	else
X	    i = 0;
X}
END_OF_FILE
if test 11875 -ne `wc -c <'w_export.c'`; then
    echo shar: \"'w_export.c'\" unpacked with wrong size!
fi
# end of 'w_export.c'
fi
if test -f 'w_fontbits3.c.Z.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'w_fontbits3.c.Z.uu'\"
else
echo shar: Extracting \"'w_fontbits3.c.Z.uu'\" \(12098 characters\)
sed "s/^X//" >'w_fontbits3.c.Z.uu' <<'END_OF_FILE'
Xbegin 666 w_fontbits3.c.Z
XM'YV0+U0H *$"A)$D1T#H,!AF3!HV:>CD 6'FC1P02=S0*2.G(9TT=LJ .%+&
XM#<<P']^X ?'&#,4T9^K(*3-G8,$A;^#DD0,3#1T0*,:D !$C!XX:(,1,G%('
XMSALU()C2":,131@[:<3486/3H,J?8<B0B9A&Y9R%.'7R/.,3J%"B1G,DG2B$
XM)U405EQ$;1,1#5 Q=N;PI8,&"!LQ;%R<>6,GA<VN(J!PY#MG3MF5=-Z J#.G
XM# L08W+F^=SFS5@SHT&,G4.'I]:-GZF2 =&9#1L0A-/,H=V2SITP,T'(!A&Q
XM)D'5;\;4:5-R:LJ5%2]2G0A'IM/.Q'>CX5A&*8@S'366F7VG[YLZ/\V4\0P"
XMCAS&:<B,QVV53E?"(L.(82PRM-J>/[GQQD=CY <''&4 1]Q*8=@&6DYIT"2<
XM&[,1AE)2 _IEH7W'^;<3@" (2&!^%-*G6WN3Z6:92B$.F$:!PAV8X$5IK#1'
XM4T[)\9$;9W1%1G++-8?29;&5N"%](KD1!G,LN=2$"TFX0(5>(B8E$F?SU2@<
XM&2'IJ%N-9[ D1U?5(?9B1-1Q-%6-8.*FV6JM987>94TBR9L9O@$G4GF$G??3
XM' @Z9,:++'1U!T]T;+22>V5=A* <E*WHAEX@/!GEE""T$<8:$@H(PDSNT23D
XM<[OIYR>27=T8D7X/H5EG;KO-T=MOP44W(776O=$9I4G\=*)[\,DWFPAA[*:;
XM"(::AQX(9> 1:F5B$M<&'!#-1VMX$KF +$$VO:"  @&!0,5VV.EIIQ@1:0K'
XM;K;B1]%7F9941WM42:B"M^%" =Q/,]39[[W?LC;D&*!9)4<"^K(QI(!?"/$&
XM&V1\@2X=<VS1!0@]@+#'0"!T# ,>,,#PV<<ACPRRR""0C++*)I><\LDMKPSS
XMRRZS3+/(''L\L\T\[^QSS3_+#/300N/<L<Y$QZSTS4OWG#334+.<<]1!-UTU
XMU4\[772A1V.]M==69WVUUEP?33;8:)^M=M53KRWVVU^[O77;8]<-=]AQL]VU
XMW'CWG;;=1IL-N-]\_YTTW4";(7,,9E@= PZ$@WQ#Y(F/43;2C5/]N,F*4Y[W
XMW4PC_OGHGI<>^MYUER'S#)9KSE[/F],\N>&!ZWS#XJ_['$/NJIM>N-2H@_[[
XMX+1?7OS+O;\\ ^2:MPZ[\X.+;O+M)L< /=#6FYS\\'=+?SSWI(/M_?#;X[&\
XMX]<OGK[2X_M,_<O9-Z]]^'RW+SSQX+,?//VIK\[\QS/(7?P F+L;Y&X,-C >
XM '/ N?^Y3VC0"V#UH+<>W\',?OR[GP;GMC\+BJU\L?O8#<0PP>F1\&4YL!S=
XMRC [$9+!9&2X7@RF)[0$ONP&+<3# /%@ALS5KX/?PY\0#P?$_/VM?# HH/IH
XMJ$ =0F\,.;S!#$R&@]S!8(HOZQP*?8B',F#Q8RG4WA?U)K@->C"#'"PC&L\X
XM/ZO= 'K9H]L;2_@R*$YOAB^K(N?&> ,\?DP,%!QC&)$WQI)AD(U![%X1A[A&
XMJB%19CALX@XC";\G1M&/>-!C%OF(23$XT(LF&^3'0'G(1#;RAVI$I!%[5CX<
XMU.Z&@H2>%.GX,3O>$).:)!D?9>9),892A:@#I2E5&;U%FG&81WSEQUPYO5@V
XMDY9XL*4(<6G%79JLEX1LHBB[6,A3,K)OI5SE-\473)DQ\X9<W.8-N#C'.EX2
XMAC)D8B6;2,F/[= ,.3RF. UI3&_JLYBIS*+0,(E/DTDPBSG$YBBY:(8QFL&!
XME6LB#')X4 )JSXJ8_*<B [I/?Y(NG./LJ/XX&M*2;A1I'B7F29$ITN*!5*,I
XM/1U)8:K2-**TICB5Z4U9:M*/]C.G(GUI3(/Z4Y[2-'0ME5L?=J  @1&H8,!!
XM6(,6]H:&/8P,O6K0BR16'(MA3&-"!>HWPVK4E)(UJ6,M*EII>M:>LK&M1\T?
XM7(>:UIG2-:X75*M;RRK1N_IUI#M=ZU_G*M:5"E:LS*1;#UN64:%UDXJ.M:!Z
XM6C9%^T'/!I#DHMA""#(KKI&P?'7I(@M$69.-(;)4PX$-=6G!. 8OGT)CIP-W
XM"(/UP<^*G@6G7O'*5KWF$F1C/"=KL0;;TM&-ML6EF1*AF43T&7>W?QUF6W][
XM1<B6EKC/)2ERP[;<>2K7N>2T:V'-"EVKX2"'PJQE#L> R3&DDXLVR"@P!5?1
XMG^7NO"W3;!2Y^-L9<-&_+;-B A&GV>@25;Q!Q*_RVIO#^%+Q@'QDX'$+>,*>
XM_78,8]P=%2E:X<YNV* ,_"[=%$RR%X;VP('=JWJK%^(5+_C!OI0C)G-@XFE:
XM;;(OPRPTI6F^%GO8G0:%W(@/F$^(&AB@*>8M)'.X0Q[/P,=ZI!L9'(K)&-[1
XMH/PM8(8M&>0 :V]R=#O?RVC N^0>-KQ)/O+0F/S$,3ZYB0@T+2;[",\K*T^_
XMTV/SEZ$9Y6!F&*)E'J]N$7SF9:(6C(%LHIA=/$I,+CJ:!6QLRZ*8PVVFUXE-
XM)#$W^8S>QYXXKX16<=V$"]PZKW","HTF>AWM0-*^&+LWS"$.$CWA#V?SMK8>
XM92%M*]?R?EILI*XNW0"YYQOZV+V^5)Z/Y5.]#@--TPVEXH"#25'^HI>B-<XD
XM%UDXZ;?ZNM!U.ZU$T_E)-\N,QV5@-8QIQE^9+19YRLSD&#$,PVSG@(OT]NXR
XMUUM(3Y,-M. F8JB5[.V!J_FSWQ:U&0&N<)\:7-"B??BO$2[Q@#L\S1"7J\5C
XMMM2F.N=%4#U8PJCZA:Q"9 Q<I9A7,[:QA!,\XAB?>,%COG&8RUSF#'_YOUU^
XM\$'3O.$SO_EA<]YSG0H=Z$3/.*A_KO.Z,KWHJ'PZYZX7W($ZSL@^5QZO?68#
XM?P/=Z#5',4\Y.U'36GW,B\,ZV'4'41E8-\=>)WC2C\[/BM>-[*O-Y-D_IF,T
XM_XWL<8\[>>W>=,-^W9X0S7NP,=EWX-D=\&$3?':E3O>+5[YZK<X[NMU=6=3A
XM(-M%Z3+5C$)%_OY7W38/NUOG/CS.RL#M=<Q[#.+===/F;@8U,)D-\HX]!](@
XMN!'TL0QX;]/+\Y7U)>7L#-H[;<%QMO9YC. 8;0![V#D0^LN,8$:KOW3CBUWU
XM]RL#'.,=9YHY4 ; -RCCXPX]&>!2^Z5%?N'C/7^5SE=GST__J[-O4)EAWWSW
XM!7^QUW\2)7G>1T:4!W[%1S)P='WZ!T#,AWFZYW6SIGZFU7SX!U$&J(!]I72]
XM-5/00WHYUF%CD&UBD'LO0P9Y5P/G1X$1E'M2ED,U$ ;7Q8%K5W_'MUO0PX+%
XM]C$-\4QU='L.- ,NV$1B,&^WYV-$Z($+>'A(EW :ICS^)TA#&('P VB A4*Y
XMXV #>(75DULXQW-,F(4VV&N$!W4(>( ?F(!.:'@X^'UM.%ABJ(;TAX9LI8 =
XMYU0@-P8&(U4*LR-5)05OH"END'(5<S$L)W\]IXB"QHAA>(9C>(-V.'AL^(9I
XM6(9.1X=!AXD+-X<<Z(A#YXEQ2(:CF(.A]FX]\SYNLW5B8P;W1S,;6(H[!XF:
XMV%;E1S*,ES<R $&3YX6R$XE1IXG2)8JJQ5BZES<S0'$IAG? >(FRN'JB^&R\
XMEXM6DXQ9MS;,6(O1.(D=^&G%F$4^QH4?XXH-9'N*YF-:9'TM(WN!ICP.1([N
XMV&V2V(R=2(O#\XW+%([S1@,6.&*RA(+\1S.8Q%DXX&95EG<W )#1Q(\O(P89
XMY1F@^(3V6%*WR'55IVCO-X$MPY##]3%DX$ X0(UYM(47>4L2Q8K<Z'><N#H'
XM-(5-5#[+1T67E5%Y9P8=)H*U))++E'?BV$7Q%I,T@Y+T6(=#&39Y=SYT\W_;
XM!)0!R7<T68,ZU&K39TX\.4-TLY3R593S*(QN@X%!J9%Y=)09F6-/"8L26$=3
XM*6U-U)/X:#Y9J8T3:8EUAS2\=UG!)98RJ7MEB8MG64MYMXN95I5JN7\@(Y2F
XM6(DIZ7A)EG?;]'^N!H%Y29:1R9>^R']AADN"&806^)6/B)A%^5*RQ3D)E6@I
XMR#M\I'8 ](KV=#VFEVQ_)$L=1EN4R)69N)*]:)NI]XQK2)OUZ)EPZ9N?N(UC
XM&)%RAX=,I8<$PX=1-05YT ;[P0:&N')@)9R71YQR&)?<:)TXI9WP,YL6MG>Z
XMV81RZ9WAV9=(EDBQ*'?4N7'M(VXTHY!BHXH^XYZ4R8"<(S3\"%+R.33$UXCK
XM.8H@!9@TTY]4TW@^LW@M<SVJ*3F18Z#\Z9_8.9P)9XTTPY%UXZ#F!)XPD)_!
XMPWL$VC,8NI';^9_UQW 4.CPAFD=6ASB\ET\6*C8I:I_#&*'5^9_RF8Y=!#T5
XM*)EY)&M@%CQ[66KP=H&F-7V%9$6&J9B\J8Q'5SX].0;0PVRW5DL0Z7GQ-*!0
XM29]XL'NZQY.\]Z)"R9UP:(E:>FEC8*%O!G=K&8(0%:3554>G9U 6:@,ORGVU
XM18KCN8GE234\=J82F)33QZ;&B*5FV87CZ&X-ED]9*:;02*-H]9C1Y)6(!Y9\
XM)Z@"N8XMPWT5>:+F(S-(9)7!DZ1[JJ2XN3852#?Y-JEJFF.66I\@XZ%$*H4$
XMF&/TMVM:.8O ^8RSEVEM9I[_9P.M"C(9]:*:=Y2K0WLU)*)+VHVEZHR<"@.:
XM]V>4&JF3*:P)^DM%>HQKZ:772JC!Z:@ NDAD )[I=DW9%@:R-F_Y9*L"U4:H
XMVEY\M&686J/@6J()AZ"?1G9$:53IR:3-ZH;>A*--9XW(AZ]CFIBU*6K[>9VY
XMFJ>,NIO_:GD1"T[&Z7$#$W()0 5IP!QS8%40$YV(.)WUNH@D2K(C"Z$-FYTE
XMB[++FIMY.J,I*Z$GVYDM&XP3JY*CFK O:X:YBHI=9&8E-5GMTTH9!;3V.K.A
XM"*ZSA#P?FK#;]*:UI*%&R[ U>Y[@1F?(\Z+^JCO7LUY2R[(WBZL'N+"W>7==
XM:W:#2C)36[8[J[,(>Z,R(Z4+1$\.U$[/8UK\II?RR+-5"["WB@?R63[$)D<Y
XM9&4YUK2-.6\U6;1LB["]V;>0Y*GQIDY(:#)D=F.R=&Y)N+?.V+:/&[8/])(R
XM0[F<(T %E#NDJYG*QKES";G7F+.?"[B2BZVPY&5:-ST")$OKM;F_^+#DZ;E;
XM"S2!.[JR=*33@YJ8%FOFN+J(L[;+ZKMZ&I^SBT+%:[LB9*=+I+R:&68^5G:N
XM"[TP&T3#2[LB-$:&RW>(:Y=PAI",^[PK2[/B]%#W>4T,%45#"(;C6*6"PUZN
XMN6G?]9NNB[/ V[A_Z[<!3*JP&[R.J\ %++$)3, '?$$5BYP8J[$<Z[%8-14G
XM![)?U7)(*Y$Q2Z\AS)[OF[0C'*X?K)XI3+6@*W G?+0O;+(Q#+8/[+(+#,&&
XMQCG_Y6S>I*7K=&/DYVX\;#4Y4$TT/, V;%ZKHX1#G&"<1XJM!$FQ^+3]^KI(
XM;+-"1&J/!@/8:T&D1DJ+%,5 B(VB:L MO*_BM,5TE5A^9C4&2FI8*Z-.4\;B
XM><-)G*]T_+JDUI/">VY+;+WVA<,U++:JMT-RBP=BT&$%B;<2Y;58-K\FF8)#
XMJ(1<5 .\PSL9U7DK/**;+#_4FV=[MD*XA;:1C&ACW$6\NTP%M+O3(V'!4\4 
XMW*P[M)2:K#,V@%Z\8Z'H-I;E&ZL !)):9H['U;UV3,B#_#,ZNJ!+J+V,UD4,
XMUD8C:5#JNF-XB:JRE\<B',%#H[\ZLZ, Y%#!E<G0/$KF='LDJ&= QKV,K&\/
XM#+Y\2S('A+H^MK0?(P-G.Z3M&LVKBSQZAJH4Y6/<QLX.6\(@C#67'$KHV&$W
XMT*+C#+BMECMB@(X_ZGRY0P8)E6T%U9 8=<3%;+5WQT7GBP<Y -"=!I4XRCC3
XMD[E-=,@ ]K\BQ,I9)&F'J<UUW,!6W-%F?,PN3--XBM,.?,4>#=0Y+=1S,\$?
XMEYQ]:,$T47(:O%43<X@=[,YN:],"[-,W3=7&3-17S=-2';M:7=58W;E6#=9<
XM3= J/,/P&[2\I%DRW7K<[$AI9]-=S<!CYT!'F+8ZNW5:JJ\RB]8F3'<M&+V\
XMR*<W/->"+)=5_%)7^C$TH+*=?+#-:+!B'3EM"0,Z6=!GW--_^\4SMJ"A=T.0
XMA+QED'>79@/P:;J'/=8(_-4Y7$>@*C@?.3W9!J66J]>,Z8#5&@.29]AW#+IL
XMO+^HQW?K!:964Y$P@-O1M]69S=M8K*6-[:O3)WNSE3N_UZU\MX^:7=:/W:@I
XMIJ5O+(#V='MY\W_>[)9$RMQ!K=J33=C:FMR$V9;4Y\8/:-[6'-8[G=E;N3;>
XM;4XFB$F7>[CR76]&J) JV#+$_)EFS<(E53[EZMXV=KO*<U_G-M$ZPZGTG$E6
XMY+Q_C=^KK=[WK=,_[>$UK=U^C=D@KMPGGM\I+C5&?;'*>3!*W;&"2(@<G(@)
XMSLDE?M8\K>*LW7T<[N,KOM[+?>,S_>.M:^1H'.1'KN0C/N1VAV/"34Q:VM(=
XM;M]-SN3,*D1<"N \!<>OG>,*WN,?CE?Q7:'$]-NVW-8GCMY#35<QFK![K.8#
XMS.8AKG0&*I^0JGR>K7C^-V<.A)7'2[[6VMM8+M4&:J#B9U OE)2R!V6KTUY1
XM6K<=1@.1#I5C+N+9C8F'3KR*-D;5#3\E:4_\=93AN%X1I(&97NA$CJ+^%V_E
XMS92 BV<J6CW9UI:??=T-#7ETCN(]KF-):4[@+:2J7'HL-ICVI(\P-%M"]LI6
XMGNIBCJSMW93F7:BK^7:0&9;%OJJUY-FH_KVKSMT%VNK5"NM0JT..KK?8#C_(
XMCJH-:.F%_>T0>Z'B[N#3CK[5$^K1!.E_BCK_!X^JVI'EN>MDO38XBJ.'/$(&
XM=3VS?6X19H30D]%@-(39YKTDO-WQ_NS.CND"G]68SN,:#^^_V_%5SM4M_E0O
XMG@!:$ 9P8 9#8!5N4"!RD =?T 3CD0;+87).W54AZ\%@CN,[/O).WO-%CN4>
XMW^P;[XRR"<B6** (K*6634QD&[[-ZL,%EN5<7#ULK711"$!)SO3";C=5GT=M
XMFMI_Z_4$JU>IBL@:>F0Q&6;(^ZRQZ*>IM=A"'N1G[WS("S2?_D=K?^8_Z6A:
XM.ZO#,P9=S)D<W^QK]ZPA>$#9)@/MENU@)$#=NX651H,CYFB #TU%C-"<K^Y[
XMQ#GZ#MI6__$#EW=DX&,QT&'+W-JB#D,^=F^FE6T+K4U9GV-#R'VI[_JAA-&@
XM!U_S]DD+"JR(#_2C1H60;S[X/M*A].<^]MPKQ'TX.>A\-ULTF$>OS_R=?^S3
XMZJ?LKJP3.UWG-F-_7H6D[)'7K_N_CN[+-(27A?UUI)#1CP/G[_EJ6M^&^JIR
XM+8I:BJ.TC4+D7T?G!B0MJ#'P262&U^M_/4/N1;QL54>>B(Z"*,N.OD2W+C6O
XMOM4),U#\[P%NIEK2:@:@ ]0]0TB7Z34+%?W(0.C;=J9E0=TIPK3E[-V8:5HZ
XM#MQPJG$%0ZK?,IE3^D[*1"D;B ="&ITR*-S'W^D=RX5J6LVRX8%F8-&ACA*T
XM^ZY)W")MN6/X<#2E([_R"+Z!,O/FRZ&E:C4&H$RO(DP(< A>JLJ42=:+*]M?
XM'[ !GC)*1P$%6L@+:P9*W#"J-]?FC![(LR"^;@DB+#IXY3#>T?MP!NJY'2"O
XM=^F&'Y##>"J.4ZDQK;<^_F ?)'T_YP8H.WJD D7>(;2$2PX1$C\_6/+V4!]*
XM>2N/"( )(8 2.M93DTX\[^==0D.8"3%ADNMQ: Y^A+T$Z&X8RBPL*;&09-Q"
XMK=96:$#;*7\ZA,_IL$<VZ];.E+N%CV;_V<*6 5&NAX6J@JP%52V.IB79- H,
XM?(7\PQ=F*B?(.81A%ODO7"0,T!]-M3INH=V*)K5P&)+!%4@R\HX8>&NZD!MF
XMD:;E]-1<-61)&<^"U("!U$D<2(%#'@0%'(JN+%4.W<@328??4/ 5IOB#.E":
XM++PF_G :X:[I<0OKH7.)2#7 3LVS3\)%W \I>C1E *(HLL6!;_R'+^,ARY!6
XMY:7+!_HVH$/3'K5/A%@HQV<U'@DI.H>DQF=1.2%2 UZ40@J)T^,O:<&>\6C(
XM  ^4 :!'1VV;#-->4N(X*HEP1D<M#B4T1H#B#9&(MJ]Z *T?E@A!TJ$Q'WG/
XMCUFN<,1]0IH8:!QT _U4HS\'1R+( 2%M3*8IJL.GF&G\S\)K&;+/]$&/LPB5
XM:"#-&(E=IGUP%DEH[?#?R[!GDH6+.$0?Y';H1@T0/H$O'FV1E#81F58/ZH'K
XM91DJEETH%G_1#8$>88#[/$;OA\@*2+9Q?JBC!L 1(13HBN$H:3_7$(@9(\62
XM.W"4# !:C^8=&I3:6!OQ311Y(I(*)<Y%'D)!9IMFX3XVX!W51J&10WP6O:$;
XM-*"]W)[E.!QQ $,);']#&=(3AD(=#R-N;#7@"<H)1\_XR^ ,0J2+6:0X6J[C
XM:+F4(R136]EJ,YH,0OA?',IYU#;O$0]XQ-PDL#!):#09H_$P1L;RJ-%V8V4<
XM)9J'PGW&D^BS?);8<'K(T8'\QY<1($D&AQ(<Q$9YV!NAH?JXSZ,AC*Z1AV#'
XMPY<0'V(*VHL=T>L\&MBW("/<>:,V,"0S#D>?M<?N(GD$7%$*11:@9-=L0@EX
XMF@&XKVYY1>T!&U.=<YMGW,<JBA"AN!8%W0YQ+8+#.O:O&" 72R1ZC%HI$!C"
XM@+RH/2*@[<"*K]&@U*38 @2;9(B$5O.Q$D:.GM@R%!*(7"CS4<T5Q:.H!*,D
XM2<QU5?)*CD>^ ^RHR$"BBG0+)N(U,S 3Q5LU*GPB1"HR1/H2%JU&1C1P$!&&
XM,$FJ 1*]Y%\$ACMQRF6>&?E?!MLRH3(8*5*F(##)0TY7EZQ&7F>'Y,(]:3XX
XMHZ/DA_G1#/PE9&0IR1E!)(:IZ"!R2O/$#O'?<5&,#,7=4,.OF&I\UM;S&1(D
XM(FE#FL%]2$T,F)5X2D(*#7*(*]V'KK22K/*X72O$8:%T([LIC,]2B>$UKQ8;
XM><JR)!F($F1LFWCC(!]?:KF3E!(\[LH;M'6@X=<;&JY2ZA&]30@)5:$AJ5@6
XMR^3U(2@P!;X $2@#9B ,; 4Z4.-$EM"#;"3.7V)#.VCQWF#$1'*CCV(^3'"'
XM,1UA/O1V%5.PB16!A0P;9?-BA1,39&Y,^93T#F,C-";ET@)*S(S9I(Y5V+B0
XM/Z>RO;N0J2^!FH%Z5O0G9E*K6+8O5V'5VG2*!H[@F_\"T'@/+,-BFM!H@JX\
XM*#@.G>)A3$K("FVXHMD*4>9:FG>UY"YEOWHW-"%FT)N9[0-I8DLT^<G H- L
XMA!>3:Z9,/AGM[B5C4GU:,[UY38]9],*=0BQW;4GYN4U>UR\[IBCZF>9$UF!-
XMEVC<YN::NX,]T\UE+[YS7QC3#GN1900^%4ZY23/C%YF$</%0>? 1!;E,-,O3
XM1&$;\^*YPLX),@9DP(.<[XQS\DU^J3'1)NP<*P 3"J0!/* N$D "6!<502-\
XM >;@!NI RE$7%<,)5($F\ 4(YA<P D_ "5"!*0 "5@!1Z ),17?R3I7G._]0
XMLPB>#)-X&L^)@3RW@/)DGDP@"%"!(H %GF?TG)[8\UN<O*YQ-%0 \/P*PU->
XM1*?SV3P+)O24GM33>L: G3<UG.?!3)@+TQ 9CQCW!68<55"@4X.!XCR4\]06
XMZ,9::@[C8U70"'I!.U8&S6!:A8(6!^,1!.P 5: #1P XR >K\@;6  3M&B7T
XMA*90.;!"'48+?0)F(@[4@3+P0H]&#-4(,W2%'DR^T$,[Q@]%H2J4AP[1-(!#
XM(8(.Y:$;M&O8T#5 XY@ @"BB(&"*5E$ ,4&QJ!9]H$O4B[Z!%DKCEF@7C:)'
XM R?(A @A!["H&N4)'.$+--$T\$3=Z'F HVWT@]K1-1I'/^@<K:-HM&,@@3+ 
XM!D("@0@#6'20%M(R<$CE: [=H8F4D!K2%X%(]6@@!0&*=)*.@4IZ5?XH)+VD
XMF9214M(OX 2 PWNX Y%TD3;24BH'3JDC=:*?=(1.C5"Z2DWI&T"EEE26=@U:
XM.DI9J2OUHX\4BNK2H^$$RL =& +-02;D@2G APZ#"W6@A>B2%M-CFDQC'C-%
XM \Z4J850+#I-D:E&4*;7-)OF4HIA/+II-5VFS50,N- />D:':<<8.8"H@0ZB
XM!WI)X6F-J"KME)P6T*D23\?I'# >]I1AL-.F)D+U:==@3L[I86!14,CR7![,
XMDWDT;RS</(*Z4%6>&1"%/((44@P(VG$"IB>,*@=48;(!AGD*">CM]&JK<W9*
XMS9P%0JJ>',D@^,L)R4'4L0@I9*,T?"8.:.RWL'%3Y9CTTYO9$6PB,\I&][HF
XM3]%2/NQ^A9)@I@9/YM%!JN=&04FSM33?GMY3[8P[2:)DF]6WI:JJG*,K,W5_
XMN1LKLE61F[2SJF83'6K)NB0FIU5Y0ZM 5;\)5;;I4[DJ>2NJCO-^[%27!C*V
XMJI%:B4!*Z6C*.H-3 0SAJE8PH(FAE98:Z&H-EQLEJ.U&PC#;R3-C9]0TJLL-
XM?.2AHX:QH&G#3(6&L[).M;@)U([AQVQ6JS*.J3J2$N?RG]UIK=D,K<!6$<(6
XM7>*;%&DJ\*OZ/<99Z6X(">E^DLS=(19XF57568XQ=:('X#6=57GK,DFCFU8@
XMI-NE52V&F8[?_XEMZS"QW:L^9^S,W?9K=]1NI?Z3V>I<K>N\:7>(XW3>#U+#
XMO]0@&:P]B@6\*M<C@U0;WK!Y>)5&XK$N&4994Z?%/)L=4[,>)\YZ\O(I5+-Q
XMHA6E[LV32M>:E<!*<CR&%_([_M$X^]K?X(,5,*=Z$P>5]])E'>0IBB_R$$ZE
XMPZD6HWYD)[4LG]'6O\6IXLQQ45]MD[%A,SC$J6B =)M6&\JZ:=BKHWN"Y'PL
XM)#<V<K86LYI)@AU=[50CMJZY52/+DQKC[>0LW<%DA &(!H-0QW]S@9B(=:BE
XMJS3/W(Q;1' )ML&N5O\J,DD>(]FL+JX/^5-4J%(QZYCMKQ$,CJ'%17);/Q68
XM33$!+15AU9\: X5(A)TS>Q:N*MBCJJCD"98<@R02W/ 8,P!H>>2E0F]Y5J35
XMK:%(',=E1_MA5ZEZJ2Y7-=!("H^A,:<,4@G:,,<_- V+[&6;EL^*V?%::5#L
XM\N*TCQ"QM-I0N]'0VZ>=9Y0VI(W:R)99FDC!LVO2]76&6;*G,N%L@#VS S;-
XM1I4F8!HX0C35>5&-P1+;[R=M"9WGXDE7CJ_QIN"(8=>A8TLRW04;]=31ZC;"
XM[=T9MW!3G!S+VVHO]UILNCW!\<(UG77[CBC(0)JS].6_U"3%*FIF $]*9FNI
XMLZF_']/,!A:WO1Y'R?CQJ';( --J"]Q2L$IT+C^*F&'3WH<%4=S*6R&_B8MH
XM#6/8/*U"Q,;VV S+5:.?H V.%I>^\J3YUI/""*"JN.JUU&:F<;2@&ESK0R<P
XM5^D4HZ1$4.0E_'BW.7?H7=:\:M7:+,X0L!X5J445*I '$,2AB AQM*1&VV%K
XM;3?GT&6=_^2DY<M$:S<RBF[5'(M#M\H?K]M:PB[653-?%X'M*A2"22Y-HLLC
XM[:N91;2&F^^P7L(S0L%V:/BW@>1[[!1(0H[X:38&UC$#>$FCWK5<&>7\6*BU
XM"T:X#V"R'V07[L['#())7@\SU!Z+%]_JC!S@>#]'Y-63A-#SSD>_VT1D@.L,
XM T=1]'9<N!IZPP:EC0$O2O%:#=0[>5WON*R\?7 @+=Z^:YYHP$Q4O?6LO3A9
XMP=%Z 2#K^B0@*>[B =];CJ:4NI0DM^?AY=W/ 0'++/B)O4F6$V%?E;HJ8<!_
XMF;&HT]C*3J2K .8G_20(WI.'X$_QN3^7YQ=(G^NS??Y/^#EU.T9(3:"7U+->
X;4G]J/ RL\6"V\D$./%N#>C28KM-%%%%7EG8<
X 
Xend
END_OF_FILE
if test 12098 -ne `wc -c <'w_fontbits3.c.Z.uu'`; then
    echo shar: \"'w_fontbits3.c.Z.uu'\" unpacked with wrong size!
fi
# end of 'w_fontbits3.c.Z.uu'
fi
echo shar: End of archive 14 \(of 25\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Molecular Simulations, Inc.             mail: dcmartin@msi.com
796 N. Pastoria Avenue                  uucp: uunet!dcmartin
Sunnyvale, California 94086             at&t: 408/522-9236
