Path: uunet!cis.ohio-state.edu!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: envbvs@bea.lbl.gov (Brian V. Smith)
Newsgroups: comp.sources.x
Subject: v16i014: Xfig 2.1.3, Part09/25
Message-ID: <1992Feb4.145909.720@msi.com>
Date: 4 Feb 92 14:59:09 GMT
References: <csx-16i006-xfig-2.1.3@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1766
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: envbvs@bea.lbl.gov (Brian V. Smith)
Posting-number: Volume 16, Issue 14
Archive-name: xfig-2.1.3/part09

# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
#		"End of archive 9 (of 25)."
# Contents:  Examples/office.fig.uu u_elastic.c w_dir.c
# Wrapped by dcmartin@fascet on Tue Feb  4 06:42:28 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Examples/office.fig.uu' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Examples/office.fig.uu'\"
else
echo shar: Extracting \"'Examples/office.fig.uu'\" \(12639 characters\)
sed "s/^X//" >'Examples/office.fig.uu' <<'END_OF_FILE'
Xbegin 664 office.fig
XM(T9)1R`R+C`*.#`@,@HR(#,@,"`Q(#`@,"`P(#D@,"XP,#`@,"`P"@D@-C0V
XM(#$P-2`V-#$@,3`X(#8S-B`Q,#4@-C,V(#DS(#8T,2`Y,"`V-#8@.3,@-C0V
XM(#$P-2`Y.3DY(#DY.3D*,B`S(#`@,2`P(#`@,"`Y(#`N,#`P(#`@,`H)(#,W
XM.2`U,#$@,S<T(#4P-"`S-CD@-3`Q(#,V.2`T.#D@,S<T(#0X-B`S-SD@-#@Y
XM(#,W.2`U,#$@.3DY.2`Y.3DY"C(@,R`P(#$@,"`P(#`@.2`P+C`P,"`P(#`*
XM"2`S,3,@-3`R(#,P."`U,#4@,S`S(#4P,B`S,#,@-#DP(#,P."`T.#<@,S$S
XM(#0Y,"`S,3,@-3`R(#DY.3D@.3DY.0HR(#,@,"`Q(#`@,"`P(#D@,"XP,#`@
XM,"`P"@D@,C<W(#$P-B`R-S(@,3`Y(#(V-R`Q,#8@,C8W(#DT(#(W,B`Y,2`R
XM-S<@.30@,C<W(#$P-B`Y.3DY(#DY.3D*,B`S(#`@,2`P(#`@,"`Y(#`N,#`P
XM(#`@,`H)(#<Q,"`X,"`W,#4@.#,@-S`P(#@P(#<P,"`V."`W,#4@-C4@-S$P
XM(#8X(#<Q,"`X,"`Y.3DY(#DY.3D*,B`S(#`@,2`P(#`@,"`Y(#`N,#`P(#`@
XM,`H)(#0Q-"`Q,#`@-#`Y(#$P,R`T,#0@,3`P(#0P-"`X."`T,#D@.#4@-#$T
XM(#@X(#0Q-"`Q,#`@.3DY.2`Y.3DY"C(@,R`P(#$@,"`P(#`@.2`P+C`P,"`P
XM(#`*"2`S-#@@,3(T(#,T,R`Q,C<@,S,X(#$R-"`S,S@@,3$R(#,T,R`Q,#D@
XM,S0X(#$Q,B`S-#@@,3(T(#DY.3D@.3DY.0HR(#,@,"`Q(#`@,"`P(#D@,"XP
XM,#`@,"`P"@D@-#4Y(#4P,B`T-C(@-3`W(#0U.2`U,3(@-#0W(#4Q,B`T-#0@
XM-3`W(#0T-R`U,#(@-#4Y(#4P,B`Y.3DY(#DY.3D*,B`S(#`@,2`P(#`@,"`Y
XM(#`N,#`P(#`@,`H)(#4P.2`U,#(@-3$R(#4P-R`U,#D@-3$R(#0Y-R`U,3(@
XM-#DT(#4P-R`T.3<@-3`R(#4P.2`U,#(@.3DY.2`Y.3DY"C(@,R`P(#$@,"`P
XM(#`@.2`P+C`P,"`P(#`*"2`U.2`U-"`V,B`U.2`U.2`V-"`T-R`V-"`T-"`U
XM.2`T-R`U-"`U.2`U-"`Y.3DY(#DY.3D*,B`R(#`@,2`P(#`@,"`P(#`N,#`P
XM(#`@,`H)(#8W,"`R,C$@-C@X(#(R,2`V.#@@,C,Q(#8W,"`R,S$@-C<P(#(R
XM,2`Y.3DY(#DY.3D*,B`T(#`@,2`P(#`@,"`P(#`N,#`P(#0@,"`P"@D@-30Y
XM(#<Y(#4T.2`V.2`U-C0@-CD@-38T(#<Y(#4T.2`W.2`Y.3DY(#DY.3D*,B`R
XM(#`@,2`P(#`@,"`U(#`N,#`P(#`@,`H)(#4P(#4X,"`V-"`U.#`@-C0@-3@U
XM(#4P(#4X-2`U,"`U.#`@.3DY.2`Y.3DY"C(@,B`P(#$@,"`P(#`@-2`P+C`P
XM,"`P(#`*"2`U,S$@-C(@-30U(#8R(#4T-2`V-R`U,S$@-C<@-3,Q(#8R(#DY
XM.3D@.3DY.0HR(#(@,"`R(#`@,"`P(#`@,"XP,#`@,"`P"@D@-#(X(#0T(#,R
XM."`T-"`S,C@@,30T(#0R."`Q-#0@-#(X(#0T(#DY.3D@.3DY.0HR(#(@,"`Q
XM(#`@,"`P(#`@,"XP,#`@,"`P"@D@,C,T(#8P(#(S-"`X-2`R-#0@.#4@,C0T
XM(#8P(#(S-"`V,"`Y.3DY(#DY.3D*,B`S(#`@,2`P(#`@,"`Y(#`N,#`P(#`@
XM,`H)(#8S(#4U-2`V-B`U-C`@-C,@-38U(#4Q(#4V-2`T."`U-C`@-3$@-34U
XM(#8S(#4U-2`Y.3DY(#DY.3D*,B`R(#`@,2`P(#`@,"`P(#`N,#`P(#`@,`H)
XM(#4T.2`W.2`U-C0@-SD@-38T(#@W(#4T.2`X-R`U-#D@-SD@.3DY.2`Y.3DY
XM"C(@,2`P(#4@,"`P(#`@,"`P+C`P,"`P(#`*"2`T.2`S,#0@.#D@,S`T(#DY
XM.3D@.3DY.0HR(#$@,"`S(#`@,"`P(#`@,"XP,#`@,"`P"@D@-#D@,S$Y(#@Y
XM(#,Q.2`Y.3DY(#DY.3D*,B`Q(#`@,B`P(#`@,"`P(#`N,#`P(#`@,`H)(#0Y
XM(#,S-"`X.2`S,S0@.3DY.2`Y.3DY"C(@,2`P(#$@,"`P(#`@,"`P+C`P,"`P
XM(#`*"2`T.2`S-#D@.#D@,S0Y(#DY.3D@.3DY.0HR(#(@,"`Q(#`@,"`P(#`@
XM,"XP,#`@,"`P"@D@-#,X(#$Q-2`T,S@@,3,T(#0T-R`Q,S0@-#0W(#$Q-2`T
XM,S@@,3$U(#DY.3D@.3DY.0HR(#(@,"`Q(#`@,"`P(#`@,"XP,#`@,"`P"@D@
XM-#,S(#$U,"`T,S,@,3<Y(#0T-"`Q-SD@-#0T(#$U,"`T,S,@,34P(#DY.3D@
XM.3DY.0HR(#(@,"`Q(#`@,"`P(#`@,"XP,#`@,"`P"@D@-#,T(#$Y.2`T-#0@
XM,3DY(#0T-"`R,#D@-#,T(#(P.2`T,S0@,3DY(#DY.3D@.3DY.0HR(#$@,"`U
XM(#`@,"`P(#`@,"XP,#`@,"`P"@D@-SDT(#0Q-"`W.30@-3,T(#DY.3D@.3DY
XM.0HR(#(@,"`Q(#`@,"`P(#`@,"XP,#`@,"`P"@D@-S@Y(#0P-"`W.3D@-#`T
XM(#<Y.2`T,30@-S@Y(#0Q-"`W.#D@-#`T(#DY.3D@.3DY.0HR(#$@,"`U(#`@
XM,"`P(#`@,"XP,#`@,"`P"@D@-SDT(#(P.2`W.30@-#`T(#DY.3D@.3DY.0HR
XM(#(@,"`R(#`@,"`P(#`@,"XP,#`@,"`P"@D@,C@@-#0@,3(X(#0T(#$R."`Q
XM-#0@,C@@,30T(#(X(#0T(#DY.3D@.3DY.0HR(#(@,"`R(#`@,"`P(#`@,"XP
XM,#`@,"`P"@D@,C(X(#0T(#$R."`T-"`Q,C@@,30T(#(R."`Q-#0@,C(X(#0T
XM(#DY.3D@.3DY.0HR(#(@,"`R(#`@,"`P(#`@,"XP,#`@,"`P"@D@,C(X(#0T
XM(#,R."`T-"`S,C@@,30T(#(R."`Q-#0@,C(X(#0T(#DY.3D@.3DY.0HR(#(@
XM,"`R(#`@,"`P(#`@,"XP,#`@,"`P"@D@-#(X(#0T(#4R."`T-"`U,C@@,30T
XM(#0R."`Q-#0@-#(X(#0T(#DY.3D@.3DY.0HR(#(@,"`R(#`@,"`P(#`@,"XP
XM,#`@,"`P"@D@-3(X(#0T(#4W."`T-"`U-S@@,30T(#4R."`Q-#0@-3(X(#0T
XM(#DY.3D@.3DY.0HR(#(@,"`R(#`@,"`P(#`@,"XP,#`@,"`P"@D@-C(X(#0T
XM(#4W."`T-"`U-S@@,30T(#8R."`Q-#0@-C(X(#0T(#DY.3D@.3DY.0HR(#(@
XM,"`R(#`@,"`P(#`@,"XP,#`@,"`P"@D@-C(X(#0T(#<V."`T-"`W-C@@,C0T
XM(#8R."`R-#0@-C(X(#0T(#DY.3D@.3DY.0HR(#(@,"`R(#`@,"`P(#`@,"XP
XM,#`@,"`P"@D@-S$X(#0T(#<V."`T-"`W-C@@,3(T(#<Q."`Q,C0@-S$X(#0T
XM(#DY.3D@.3DY.0HR(#$@,"`S(#`@,"`P(#`@,"XP,#`@,"`P"@D@-#0T(#(P
XM-"`W.#D@,C`T(#DY.3D@.3DY.0HR(#(@,"`Q(#`@,"`P(#`@,"XP,#`@,"`P
XM"@D@-S@Y(#$Y.2`W.3D@,3DY(#<Y.2`R,#D@-S@Y(#(P.2`W.#D@,3DY(#DY
XM.3D@.3DY.0HR(#$@,"`U(#`@,"`P(#`@,"XP,#`@,"`P"@D@-SDT(#$Y.2`W
XM.30@.2`Y.3DY(#DY.3D*,B`R(#`@,2`P(#`@,"`P(#`N,#`P(#`@,`H)(#(S
XM-"`Q.3D@,C0T(#$Y.2`R-#0@,C`Y(#(S-"`R,#D@,C,T(#$Y.2`Y.3DY(#DY
XM.3D*,B`Q(#`@,R`P(#`@,"`P(#`N,#`P(#`@,`H)(#(S-"`R,#0@,SD@,C`T
XM(#DY.3D@.3DY.0HR(#$@,"`S(#`@,"`P(#`@,"XP,#`@,"`P"@D@-#,T(#(P
XM-"`R-#0@,C`T(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@,"XP,#`@-"`P
XM(#`*"2`T,CD@.#0@-#(Y(#DY(#0S.2`Y.2`T,SD@.#0@-#(Y(#@T(#DY.3D@
XM.3DY.0HR(#(@,"`Q(#`@,"`P(#`@,"XP,#`@,"`P"@D@-#,Y(#@T(#0S.2`Y
XM.2`T-#@@.3D@-#0X(#@T(#0S.2`X-"`Y.3DY(#DY.3D*,B`R(#`@,2`P(#`@
XM,"`P(#`N,#`P(#`@,`H)(#(P-2`T-R`R,#4@-#<@,C`U(#0W(#(P-2`T-R`R
XM,#4@-#<@.3DY.2`Y.3DY"C(@-"`P(#$@,"`P(#`@,"`P+C`P,"`T(#`@,`H)
XM(#<V-"`X.2`W-30@.#D@-S4T(#<T(#<V-"`W-"`W-C0@.#D@.3DY.2`Y.3DY
XM"C(@,B`P(#$@,"`P(#`@,"`P+C`P,"`P(#`*"2`W-30@-S0@-S4T(#@Y(#<T
XM-B`X.2`W-#8@-S0@-S4T(#<T(#DY.3D@.3DY.0HR(#0@,"`Q(#`@,"`P(#`@
XM,"XP,#`@-"`P(#`*"2`U.3D@,3$T(#4Y.2`Q,#0@-C$T(#$P-"`V,30@,3$T
XM(#4Y.2`Q,30@.3DY.2`Y.3DY"C(@,B`P(#$@,"`P(#`@,"`P+C`P,"`P(#`*
XM"2`V,30@,3`T(#4Y.2`Q,#0@-3DY(#DV(#8Q-"`Y-B`V,30@,3`T(#DY.3D@
XM.3DY.0HR(#(@,"`Q(#`@,"`P(#`@,"XP,#`@,"`P"@D@-3$@,SDV(#4Q(#0R
XM,2`V,2`T,C$@-C$@,SDV(#4Q(#,Y-B`Y.3DY(#DY.3D*,B`T(#`@,2`P(#`@
XM,"`P(#`N,#`P(#0@,"`P"@D@-C,@,S8Y(#8S(#,W.2`T."`S-SD@-#@@,S8Y
XM(#8S(#,V.2`Y.3DY(#DY.3D*,B`R(#`@,2`P(#`@,"`P(#`N,#`P(#`@,`H)
XM(#0X(#,W.2`V,R`S-SD@-C,@,S@W(#0X(#,X-R`T."`S-SD@.3DY.2`Y.3DY
XM"C(@,B`P(#$@,"`P(#`@,"`P+C`P,"`P(#`*"2`U,2`T-3<@-3$@-#,R(#8Q
XM(#0S,B`V,2`T-3<@-3$@-#4W(#DY.3D@.3DY.0HR(#(@,"`Q(#`@,"`P(#`@
XM,"XP,#`@,"`P"@D@-3(@-#<Q(#8R(#0W,2`V,B`T.#$@-3(@-#@Q(#4R(#0W
XM,2`Y.3DY(#DY.3D*,B`R(#`@,2`P(#`@,"`P(#`N,#`P(#`@,`H)(#4R(#0Y
XM,R`V,B`T.3,@-C(@-3`S(#4R(#4P,R`U,B`T.3,@.3DY.2`Y.3DY"C(@,B`P
XM(#$@,"`P(#`@,"`P+C`P,"`P(#`*"2`U,B`U,30@-C(@-3$T(#8R(#4R-"`U
XM,B`U,C0@-3(@-3$T(#DY.3D@.3DY.0HR(#(@,"`Q(#`@,"`P(#`@,"XP,#`@
XM,"`P"@D@-C$T(#0U-"`V,C0@-#4T(#8R-"`T-C0@-C$T(#0V-"`V,30@-#4T
XM(#DY.3D@.3DY.0HR(#(@,"`Q(#`@,"`P(#`@,"XP,#`@,"`P"@D@-C$T(#0V
XM.2`U.#D@-#8Y(#4X.2`T-SD@-C$T(#0W.2`V,30@-#8Y(#DY.3D@.3DY.0HR
XM(#$@,"`R(#`@,"`P(#`@,"XP,#`@,"`P"@D@-#<T(#0V.2`T-S0@-3(T(#DY
XM.3D@.3DY.0HR(#$@,"`R(#`@,"`P(#`@,"XP,#`@,"`P"@D@-#0T(#0V.2`U
XM,30@-#8Y(#DY.3D@.3DY.0HR(#$@,"`R(#`@,"`P(#`@,"XP,#`@,"`P"@D@
XM,S<Y(#0V.2`S.#D@-#8Y(#,X.2`U,C0@.3DY.2`Y.3DY"C(@,2`P(#(@,"`P
XM(#`@,"`P+C`P,"`P(#`*"2`S,C0@-#8Y(#,R-"`U,C0@.3DY.2`Y.3DY"C(@
XM,2`P(#(@,"`P(#`@,"`P+C`P,"`P(#`*"2`R.#D@-#8Y(#,U-"`T-CD@.3DY
XM.2`Y.3DY"C(@,2`P(#(@,"`P(#`@,"`P+C`P,"`P(#`*"2`U,SD@-#8Y(#4S
XM.2`U,C0@.3DY.2`Y.3DY"C(@,2`P(#(@,"`P(#`@,"`P+C`P,"`P(#`*"2`U
XM,S0@-#0T(#8S-"`T-#0@.3DY.2`Y.3DY"C(@,2`P(#(@,"`P(#`@,"`P+C`P
XM,"`P(#`*"2`R.#D@-#0T(#4P-"`T-#0@-3`T(#0P-"`Y.3DY(#DY.3D*,B`Q
XM(#`@,B`P(#`@,"`P(#`N,#`P(#`@,`H)(#(V-"`T-#0@,C`T(#0T-"`Y.3DY
XM(#DY.3D*,B`Q(#`@,B`P(#`@,"`P(#`N,#`P(#`@,`H)(#(V-"`U,C0@,C8T
XM(#0W.2`Y.3DY(#DY.3D*,B`Q(#`@,B`P(#`@,"`P(#`N,#`P(#`@,`H)(#(V
XM-"`T,S0@,C8T(#0U-"`Y.3DY(#DY.3D*,B`Q(#`@,B`P(#`@,"`P(#`N,#`P
XM(#`@,`H)(#(V-"`S-C0@,C8T(#0P.2`Y.3DY(#DY.3D*,B`R(#`@,2`P(#`@
XM,"`P(#`N,#`P(#`@,`H)(#4Y(#(T.2`U.2`R-C0@-S0@,C8T(#<T(#(T.2`U
XM.2`R-#D@.3DY.2`Y.3DY"C(@,2`P(#(@,"`P(#`@,"`P+C`P,"`P(#`*"2`S
XM.30@,S8T(#,Y-"`T-#0@.3DY.2`Y.3DY"C(@,2`P(#(@,"`P(#`@,"`P+C`P
XM,"`P(#`*"2`R.#D@,S8T(#(X.2`T,3D@.3DY.2`Y.3DY"C(@,2`P(#(@,"`P
XM(#`@,"`P+C`P,"`P(#`*"2`S,SD@,S8T(#,S.2`T,3D@.3DY.2`Y.3DY"C(@
XM,2`P(#(@,"`P(#`@,"`P+C`P,"`P(#`*"2`R-C0@,S8T(#(X-"`S-#D@.3DY
XM.2`Y.3DY"C(@,2`P(#(@,"`P(#`@,"`P+C`P,"`P(#`*"2`R-C0@,S8T(#(P
XM-"`S-C0@,C`T(#4R-"`V,S0@-3(T(#8S-"`S-C0@-3(Y(#,V-"`U,#D@,S0Y
XM(#DY.3D@.3DY.0HR(#$@,"`R(#`@,"`P(#`@,"XP,#`@,"`P"@D@-3`T(#,V
XM-"`R.#D@,S8T(#DY.3D@.3DY.0HS(#`@,"`Q(#`@,"`P(#`@,"XP,#`@,"`P
XM"@D@-S4Q(#@Y(#<U-"`R,S0@-C@Q(#(S.2`V-SD@,C,Q(#DY.3D@.3DY.0HS
XM(#`@,"`Q(#`@,"`P(#`@,"XP,#`@,"`P"@D@-3,X(#8W(#4S."`X,B`U-#D@
XM.#,@.3DY.2`Y.3DY"C,@,"`P(#$@,"`P(#`@,"`P+C`P,"`P(#`*"2`W,#4@
XM-C4@-S`U(#$U(#0W-2`Q,"`T-#4@-30@-#0T(#@T(#DY.3D@.3DY.0HS(#`@
XM,"`Q(#`@,"`P(#`@,"XP,#`@,"`P"@D@-#$T(#DT(#0R,B`Y-"`T,C0@,3`Y
XM(#0T-2`Q,#D@-#0T(#DY(#DY.3D@.3DY.0HS(#`@,"`Q(#`@,"`P(#`@,"XP
XM,#`@,"`P"@D@,C0T(#<P(#,Q-R`W,B`S,3(@,3(@-C0P(#$Y(#8T,2`Y,2`Y
XM.3DY(#DY.3D*,R`P(#`@,2`P(#`@,"`P(#`N,#`P(#`@,`H)(#(T-"`W-R`S
XM,#D@-S@@,S`Y(#$Q."`S,S@@,3$X(#DY.3D@.3DY.0HS(#`@,"`Q(#`@,"`P
XM(#`@,"XP,#`@,"`P"@D@,C0T(#8S(#(U."`V,R`R-38@,3<@-3,@,C,@-30@
XM-30@.3DY.2`Y.3DY"C,@,"`P(#$@,"`P(#`@,"`P+C`P,"`P(#`*"2`R-#0@
XM.#(@,C4Y(#@S(#(U."`Q,#`@,C8W(#$P,"`Y.3DY(#DY.3D*,R`P(#`@,2`P
XM(#`@,"`P(#`N,#`P(#`@,`H)(#8Q,2`T-SD@-C`U(#4U,B`T-3(@-38S(#,S
XM,2`U-3<@,S,Y(#0Y."`S,3,@-#DV(#DY.3D@.3DY.0HS(#`@,"`Q(#`@,"`P
XM(#`@,"XP,#`@,"`P"@D@-C`U(#0W.2`U.3D@-30U(#0P,"`U-3$@-#`U(#0Y
XM-2`S-SD@-#DU(#DY.3D@.3DY.0HS(#`@,"`Q(#`@,"`P(#`@,"XP,#`@,"`P
XM"@D@-3DY(#0W.2`U.34@-3,T(#0U,B`U,S4@-#4S(#4Q,B`Y.3DY(#DY.3D*
XM,R`P(#`@,2`P(#`@,"`P(#`N,#`P(#`@,`H)(#4Y,R`T-SD@-3@V(#4Q-R`U
XM,#8@-3$X(#4P,R`U,3(@.3DY.2`Y.3DY"C,@,"`P(#(@,"`P(#`@,"`P+C`P
XM,"`P(#`*"2`T-#0@,3<W(#0W,B`Q.#$@-#8W(#(U-2`W-"`R-30@.3DY.2`Y
XM.3DY"C,@,"`P(#(@,"`P(#`@,"`P+C`P,"`P(#`*"2`T-#0@,34T(#0V.2`Q
XM-#8@-#8Y(#$R-R`T-#<@,3(S(#DY.3D@.3DY.0HS(#`@,"`R(#`@,"`P(#`@
XM,"XP,#`@,"`P"@D@-#0X(#DR(#0Y,"`Y.2`T.3`@,30U(#0T-"`Q-3D@.3DY
XM.2`Y.3DY"C,@,"`P(#,@,"`P(#`@,"`P+C`P,"`P(#`*"2`T,SD@,3<Y(#0S
XM-2`Q.#@@-#0R(#$Y-"`T,SD@,3DY(#DY.3D@.3DY.0HS(#`@,"`R(#`@,"`P
XM(#`@,"XP,#`@,"`P"@D@-#0T(#$W,R`V-3`@,3<U(#8Y,"`Q,C0@-S(W(#<Y
XM(#<T-B`X,B`Y.3DY(#DY.3D*,R`P(#`@,B`P(#`@,"`P(#`N,#`P(#`@,`H)
XM(#0T-"`Q-CD@-3(P(#$V,"`U-38@,3(Y(#4X-B`X-B`V,#$@.#4@-C`W(#DV
XM(#DY.3D@.3DY.0HS(#`@,"`R(#`@,"`P(#`@,"XP,#`@,"`P"@D@-34V(#@W
XM(#4T-"`Q,30@-#DX(#$U,2`T-#0@,38T(#DY.3D@.3DY.0HS(#`@,"`S(#`@
XM,"`P(#`@,"XP,#`@,"`P"@D@,C,Y(#@T(#(U-B`Q,C8@,C(W(#$U."`R,SD@
XM,3@T(#(S.2`Q.3D@.3DY.2`Y.3DY"C,@,"`P(#(@,"`P(#`@,"`P+C`P,"`P
XM(#`*"2`W.#D@-#`Y(#<Q.2`S.3D@-C@Y(#0V-"`V,C0@-#4Y(#DY.3D@.3DY
XM.0HS(#`@,"`S(#`@,"`P(#`@,"XP,#`@,"`P"@D@-C$T(#0U.2`V,#$@-#4X
XM(#4Y.2`T-CD@.3DY.2`Y.3DY"C0@,"`P(#$R(#`@,"`P(#`N,#`P(#$@.2`S
XM,"`T-SD@-#@T('@V-#8X`0HT(#`@,"`Q,B`P(#`@,"`P+C`P,"`Q(#D@,S`@
XM-#,T(#0X-"!X-S0W-@$*-"`P(#`@,3(@,"`P(#`@,"XP,#`@,2`Y(#,P(#,Y
XM-"`T.#0@>#8T.#@!"C0@,"`P(#$R(#`@,"`P(#`N,#`P(#$@.2`S,"`S,CD@
XM-#@T('@W-#<R`0HT(#`@,"`Q,B`P(#`@,"`P+C`P,"`Q(#D@,3(@,S`R(#4Q
XM-R`P,P$*-"`P(#`@,3(@,"`P(#`@,"XP,#`@,2`Y(#$R(#,W,"`U,3<@,#(!
XM"C0@,"`P(#$R(#`@,"`P(#`N,#`P(#$@.2`Q,B`T-#<@-#DX(#`Q`0HT(#`@
XM,"`Q,B`P(#`@,"`P+C`P,"`Q(#D@,3@@-#DU(#0Y-R!#3TX!"C0@,"`P(#$R
XM(#`@,"`P(#`N,#`P(#$@.2`Q,B`V.3(@,C(Y(#`S`0HT(#`@,"`Q,B`P(#`@
XM,"`P+C`P,"`Q(#D@,S8@-C4V(#(Q-R!$:6%B;&\!"C0@,"`P(#$R(#`@,"`P
XM(#`N,#`P(#$@.2`Q,B`U,S4@.3,@,#(!"C0@,"`P(#$R(#`@,"`P(#`N,#`P
XM(#$@.2`S,"`W."`U.#@@36]D96T!"C0@,"`P(#$R(#`@,"`P(#`N,#`P(#$@
XM.2`Q,B`T,#,@,3$V(#`R`0HT(#`@,"`Q,B`P(#`@,"`P+C`P,"`Q(#D@,3(@
XM-C4Q(#$P,R`P,0$*-"`P(#`@,3(@,"`P(#`@,"XP,#`@,2`Y(#$R(#0X(#<W
XM(#`S`0HT(#`@,"`Q,B`P(#`@,"`P+C`P,"`Q(#D@,3(@,S,X(#$P-B`P,`$*
XM-"`P(#`@,3(@,"`P(#`@,"XP,#`@,2`Y(#$X(#(V,"`Q,C(@0T].`0HT(#`@
XM,"`Q,B`P(#`@,"`P+C`P,"`Q(#D@,3(@-C@U(#<X(#`S`0HT(#`@,"`Q,B`P
XM(#`@,"`P+C`P,"`Q(#D@-#@@-S8@-38T(%1E<FUI;F%L`0HT(#`@,"`Q,B`P
XM(#`@,"`P+C`P,"`Q(#D@-S@@.3D@,S0Y($1U;6(@=&5R;6EN86P!"C0@,"`P
XM(#$R(#`@,"`P(#`N,#`P(#$@.2`X-"`Y.2`S,S0@5&AI;FYE="!S=6)N970!
XM"C0@,"`P(#$R(#`@,"`P(#`N,#`P(#$@.2`Y,"`Y.2`S,3D@5&AI8VMN970@
XM<W5B;F5T`0HT(#`@,"`Q,B`P(#`@,"`P+C`P,"`Q(#D@-S@@.3D@,S`T($UA
XM:6X@0F%C:V)O;F4!"C0@,"`P(#$R(#`@,"`P(#`N,#`P(#$@.2`Q,B`T-3(@
XM,3(P($%4`0HT(#`@,"`Q,B`P(#`@,"`P+C`P,"`Q(#D@-B`W-SD@-#`T(%0!
XM"C0@,"`P(#$R(#`@,"`P(#`N,#`P(#$@.2`Q,B`T,#8@,38Y($1-`0HT(#`@
XM,"`Q,B`P(#`@,"`P+C`P,"`Q(#D@,C0@-C8@-3D@,S`X.`$*-"`P(#`@,3(@
XM,"`P(#`@,"XP,#`@,2`Y(#(T(#$V,R`U.2`S,#@V`0HT(#`@,"`Q,B`P(#`@
XM,"`P+C`P,"`Q(#D@,C0@,C8S(#4Y(#,P.#0!"C0@,"`P(#$R(#`@,"`P(#`N
XM,#`P(#$@.2`R-"`S-C,@-3D@,S`X,@$*-"`P(#`@,3(@,"`P(#`@,"XP,#`@
XM,2`Y(#(T(#0V,R`U.2`S,#@P`0HT(#`@,"`Q,B`P(#`@,"`P+C`P,"`Q(#D@
XM,C0@-30R(#4Y(#,P-S@!"C0@,"`P(#$R(#`@,"`P(#`N,#`P(#$@.2`R-"`U
XM.#@@-3D@,S`W-@$*-"`P(#`@,3(@,"`P(#`@,"XP,#`@,2`Y(#(T(#8U."`U
XM.2`S,#<T`0HT(#`@,"`Q,B`P(#`@,"`P+C`P,"`Q(#D@,S`@-S(X(#4Y(#,P
XM-S1!`0HT(#`@,"`Q,B`P(#`@,"`P+C`P,"`Q(#D@-B`W-SD@,3DT($(!"C0@
XM,"`P(#$R(#`@,"`P(#`N,#`P(#$@.2`V(#(R-"`Q.3D@5`$*-"`P(#`@,3(@
XM,"`P(#`@,"XP,#`@,2`Y(#8@-#(T(#$Y.2!4`0HT(#`@,"`Q,B`P(#`@,"`P
XM+C`P,"`Q(#D@.3`@-S@@,S@X(%9A>'-T871I;VX@,C`P,`$*-"`P(#`@,3(@
XM,"`P(#`@,"XP,#`@,2`Y(#<X(#<Y(#0Q-B!687AS=&%T:6]N($E)`0HT(#`@
XM,"`Q,B`P(#`@,"`P+C`P,"`Q(#D@,3(@,C8@-#0Y($1-`0HT(#`@,"`Q,B`P
XM(#`@,"`P+C`P,"`Q(#D@,S`@-S@@-#0X($1%35!2`0HT(#`@,"`Q,B`P(#`@
XM,"`P+C`P,"`Q(#D@-B`S-2`T.#`@5`$*-"`P(#`@,3(@,"`P(#`@,"XP,#`@
XM,2`Y(#8P(#<V(#0W.2!4<F%N8V5I=F5R`0HT(#`@,"`Q,B`P(#`@,"`P+C`P
XM,"`Q(#D@-B`S-2`U,#(@0@$*-"`P(#`@,3(@,"`P(#`@,"XP,#`@,2`Y(#$R
XM(#,R(#4R,R!4:`$*-"`P(#`@,3(@,"`P(#`@,"XP,#`@,2`Q,2`S-B`W-B`U
XM,#$@0G)I9&=E`0HT(#`@,"`Q,B`P(#`@,"`P+C`P,"`Q(#$P(#@T(#<V(#4S
XM."!T;R!4:&EN;F5T`0HT(#`@,"`Q,B`P(#`@,"`P+C`P,"`Q(#$P(#@T(#<V
XM(#4R,R!88V5I=F5R(%1H:6-K;F5T`0HT(#`@,"`Q,B`P(#`@,"`P+C`P,"`Q
XM(#D@,3(@-3DW(#0U-2!4:`$*-"`P(#`@,3(@,"`P(#`@,"XP,#`@,2`Y(#0X
X2(#0R(#(T-"!3=6X@,R\V,`$*
X`
Xend
END_OF_FILE
if test 12639 -ne `wc -c <'Examples/office.fig.uu'`; then
    echo shar: \"'Examples/office.fig.uu'\" unpacked with wrong size!
fi
# end of 'Examples/office.fig.uu'
fi
if test -f 'u_elastic.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'u_elastic.c'\"
else
echo shar: Extracting \"'u_elastic.c'\" \(20366 characters\)
sed "s/^X//" >'u_elastic.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of M.I.T. not be used in advertising or
X * publicity pertaining to distribution of the software without specific,
X * written prior permission.  M.I.T. makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty."
X *
X */
X
X/****************** IMPORTS *************/
X
X#include "fig.h"
X#include "resources.h"
X#include "mode.h"
X#include "object.h"
X#include "paintop.h"
X#include "u_elastic.h"
X#include "w_canvas.h"
X#include "w_zoom.h"
X
Xextern float	compute_angle();
X
X/********************** EXPORTS **************/
X
Xint		constrained;
Xint		fix_x, fix_y, work_numsides;
Xint		x1off, x2off, y1off, y2off;
XCursor		cur_latexcursor;
Xint		from_x, from_y;
Xdouble		cosa, sina;
Xint		movedpoint_num;
Xint		latex_fix_x, latex_fix_y;
XF_point	       *left_point, *right_point;
X
X/**************** LOCAL ***********/
X
Xstatic void	elastic_links();
X
X/*************************** BOXES *************************/
X
Xelastic_box(x1, y1, x2, y2)
X    int		    x1, y1, x2, y2;
X{
X    /* line_style = RUBBER_LINE so that we don't scale it */
X    pw_vector(canvas_win, x1, y1, x1, y2, INV_PAINT, 1, RUBBER_LINE, 0.0,
X	      DEFAULT_COLOR);
X    pw_vector(canvas_win, x1, y2, x2, y2, INV_PAINT, 1, RUBBER_LINE, 0.0,
X	      DEFAULT_COLOR);
X    pw_vector(canvas_win, x2, y2, x2, y1, INV_PAINT, 1, RUBBER_LINE, 0.0,
X	      DEFAULT_COLOR);
X    pw_vector(canvas_win, x2, y1, x1, y1, INV_PAINT, 1, RUBBER_LINE, 0.0,
X	      DEFAULT_COLOR);
X}
X
Xelastic_movebox()
X{
X    register int    x1, y1, x2, y2;
X
X    x1 = cur_x + x1off;
X    x2 = cur_x + x2off;
X    y1 = cur_y + y1off;
X    y2 = cur_y + y2off;
X    elastic_box(x1, y1, x2, y2);
X    elastic_links(cur_x - fix_x, cur_y - fix_y, 1.0, 1.0);
X}
X
Xmoving_box(x, y)
X    int		    x, y;
X{
X    elastic_movebox();
X    adjust_pos(x, y, fix_x, fix_y, &cur_x, &cur_y);
X    elastic_movebox();
X}
X
Xresizing_box(x, y)
X    int		    x, y;
X{
X    elastic_box(fix_x, fix_y, cur_x, cur_y);
X    cur_x = x;
X    cur_y = y;
X    elastic_box(fix_x, fix_y, cur_x, cur_y);
X}
X
Xconstrained_resizing_box(x, y)
X    int		    x, y;
X{
X    elastic_box(fix_x, fix_y, cur_x, cur_y);
X    adjust_box_pos(x, y, from_x, from_y, &cur_x, &cur_y);
X    elastic_box(fix_x, fix_y, cur_x, cur_y);
X}
X
Xscaling_compound(x, y)
X    int		    x, y;
X{
X    elastic_scalecompound(cur_c);
X    adjust_box_pos(x, y, fix_x, fix_y, &cur_x, &cur_y);
X    elastic_scalecompound(cur_c);
X}
X
Xelastic_scalecompound(c)
X    F_compound	   *c;
X{
X    int		    newx, newy, oldx, oldy, x1, y1, x2, y2;
X    float	    newd, oldd, scalefact;
X
X    newx = cur_x - fix_x;
X    newy = cur_y - fix_y;
X    newd = sqrt((double) (newx * newx + newy * newy));
X    oldx = from_x - fix_x;
X    oldy = from_y - fix_y;
X    oldd = sqrt((double) (oldx * oldx + oldy * oldy));
X    scalefact = newd / oldd;
X    x1 = fix_x + (c->secorner.x - fix_x) * scalefact;
X    y1 = fix_y + (c->secorner.y - fix_y) * scalefact;
X    x2 = fix_x + (c->nwcorner.x - fix_x) * scalefact;
X    y2 = fix_y + (c->nwcorner.y - fix_y) * scalefact;
X    elastic_box(x1, y1, x2, y2);
X}
X
X/*************************** LINES *************************/
X
Xelastic_line()
X{
X    pw_vector(canvas_win, fix_x, fix_y, cur_x, cur_y,
X	      INV_PAINT, 1, RUBBER_LINE, 0.0, DEFAULT_COLOR);
X}
X
Xfreehand_line(x, y)
X    int		    x, y;
X{
X    elastic_line();
X    cur_x = x;
X    cur_y = y;
X    elastic_line();
X}
X
Xelastic_latexline()
X{
X    int		    x, y;
X    Cursor	    c;
X
X    latex_endpoint(fix_x, fix_y, cur_x, cur_y, &x, &y, latexarrow_mode,
X		   (cur_pointposn == P_ANY) ? 1 : posn_rnd[cur_pointposn]);
X    pw_vector(canvas_win, fix_x, fix_y, x, y, INV_PAINT, 1, RUBBER_LINE, 0.0,
X	      DEFAULT_COLOR);
X    c = (x == cur_x && y == cur_y) ? null_cursor : crosshair_cursor;
X    if (c != cur_cursor) {
X	set_temp_cursor(c);
X	cur_cursor = c;
X    }
X}
X
Xlatex_line(x, y)
X    int		    x, y;
X{
X    elastic_latexline();
X    cur_x = x;
X    cur_y = y;
X    elastic_latexline();
X}
X
Xconstrainedangle_line(x, y)
X    int		    x, y;
X{
X    float	    angle, dx, dy;
X
X    dx = x - fix_x;
X    dy = fix_y - y;
X    if (sqrt((double) (dx * dx + dy * dy)) < 7)
X	return;
X    if (dx == 0)
X	angle = -90;
X    else
X	angle = 180 * atan((double) (dy / dx)) / 3.1416;
X
X    if (manhattan_mode) {
X	if (mountain_mode) {
X	    if (angle < -67.5)
X		angle90_line(x, y);
X	    else if (angle < -22.5)
X		angle135_line(x, y);
X	    else if (angle < 22.5)
X		angle0_line(x, y);
X	    else if (angle < 67.5)
X		angle45_line(x, y);
X	    else
X		angle90_line(x, y);
X	} else {
X	    if (angle < -45)
X		angle90_line(x, y);
X	    else if (angle < 45)
X		angle0_line(x, y);
X	    else
X		angle90_line(x, y);
X	}
X    } else {
X	if (angle < 0)
X	    angle135_line(x, y);
X	else
X	    angle45_line(x, y);
X    }
X}
X
Xangle0_line(x, y)
X    int		    x, y;
X{
X    if (x == cur_x && y == cur_y)
X	return;
X    pw_vector(canvas_win, fix_x, fix_y, cur_x, cur_y, INV_PAINT, 1,
X	      RUBBER_LINE, 0.0, DEFAULT_COLOR);
X    cur_x = x;
X    cur_y = fix_y;
X    pw_vector(canvas_win, fix_x, fix_y, cur_x, cur_y, INV_PAINT, 1,
X	      RUBBER_LINE, 0.0, DEFAULT_COLOR);
X}
X
Xangle90_line(x, y)
X    int		    x, y;
X{
X    if (x == cur_x && y == cur_y)
X	return;
X    pw_vector(canvas_win, fix_x, fix_y, cur_x, cur_y, INV_PAINT, 1,
X	      RUBBER_LINE, 0.0, DEFAULT_COLOR);
X    cur_y = y;
X    cur_x = fix_x;
X    pw_vector(canvas_win, fix_x, fix_y, cur_x, cur_y, INV_PAINT, 1,
X	      RUBBER_LINE, 0.0, DEFAULT_COLOR);
X}
X
Xangle45_line(x, y)
X    int		    x, y;
X{
X    if (x == cur_x && y == cur_y)
X	return;
X    pw_vector(canvas_win, fix_x, fix_y, cur_x, cur_y, INV_PAINT, 1,
X	      RUBBER_LINE, 0.0, DEFAULT_COLOR);
X    if (abs(x - fix_x) < abs(y - fix_y)) {
X	cur_x = fix_x - y + fix_y;
X	cur_y = y;
X    } else {
X	cur_y = fix_y + fix_x - x;
X	cur_x = x;
X    }
X    pw_vector(canvas_win, fix_x, fix_y, cur_x, cur_y, INV_PAINT, 1,
X	      RUBBER_LINE, 0.0, DEFAULT_COLOR);
X}
X
Xangle135_line(x, y)
X    int		    x, y;
X{
X    if (x == cur_x && y == cur_y)
X	return;
X    pw_vector(canvas_win, fix_x, fix_y, cur_x, cur_y, INV_PAINT, 1,
X	      RUBBER_LINE, 0.0, DEFAULT_COLOR);
X    if (abs(x - fix_x) < abs(y - fix_y)) {
X	cur_x = fix_x + y - fix_y;
X	cur_y = y;
X    } else {
X	cur_y = fix_y + x - fix_x;
X	cur_x = x;
X    }
X    pw_vector(canvas_win, fix_x, fix_y, cur_x, cur_y, INV_PAINT, 1,
X	      RUBBER_LINE, 0.0, DEFAULT_COLOR);
X}
X
Xreshaping_line(x, y)
X    int		    x, y;
X{
X    elastic_linelink();
X    adjust_pos(x, y, from_x, from_y, &cur_x, &cur_y);
X    elastic_linelink();
X}
X
Xreshaping_latexline(x, y)
X    int		    x, y;
X{
X    Cursor	    c;
X
X    elastic_linelink();
X    adjust_pos(x, y, from_x, from_y, &cur_x, &cur_y);
X    latex_endpoint(latex_fix_x, latex_fix_y, x, y, &cur_x, &cur_y,
X    latexarrow_mode, (cur_pointposn == P_ANY) ? 1 : posn_rnd[cur_pointposn]);
X    elastic_linelink();
X    c = (x == cur_x && y == cur_y) ? null_cursor : crosshair_cursor;
X    if (c != cur_latexcursor) {
X	set_temp_cursor(c);
X	cur_latexcursor = c;
X    }
X}
X
Xelastic_linelink()
X{
X    if (left_point != NULL) {
X	pw_vector(canvas_win, left_point->x, left_point->y,
X	       cur_x, cur_y, INV_PAINT, 1, RUBBER_LINE, 0.0, DEFAULT_COLOR);
X    }
X    if (right_point != NULL) {
X	pw_vector(canvas_win, right_point->x, right_point->y,
X	       cur_x, cur_y, INV_PAINT, 1, RUBBER_LINE, 0.0, DEFAULT_COLOR);
X    }
X}
X
Xextending_line(x, y)
X    int		    x, y;
X{
X    elastic_linelink();
X    cur_x = x;
X    cur_y = y;
X    elastic_linelink();
X}
X
Xmoving_line(x, y)
X    int		    x, y;
X{
X    elastic_moveline(new_l->points);
X    adjust_pos(x, y, fix_x, fix_y, &cur_x, &cur_y);
X    elastic_moveline(new_l->points);
X}
X
Xelastic_moveline(pts)
X    F_point	   *pts;
X{
X    F_point	   *p;
X    int		    dx, dy, x, y, xx, yy;
X
X    p = pts;
X    if (p->next == NULL) {	/* dot */
X	pw_vector(canvas_win, cur_x, cur_y, cur_x, cur_y,
X		  INV_PAINT, 1, RUBBER_LINE, 0.0, DEFAULT_COLOR);
X    } else {
X	dx = cur_x - fix_x;
X	dy = cur_y - fix_y;
X	x = p->x + dx;
X	y = p->y + dy;
X	for (p = p->next; p != NULL; x = xx, y = yy, p = p->next) {
X	    xx = p->x + dx;
X	    yy = p->y + dy;
X	    pw_vector(canvas_win, x, y, xx, yy, INV_PAINT, 1,
X		      RUBBER_LINE, 0.0, DEFAULT_COLOR);
X	}
X    }
X    elastic_links(dx, dy, 1.0, 1.0);
X}
X
Xstatic void
Xelastic_links(dx, dy, sx, sy)
X    int		    dx, dy;
X    float	    sx, sy;
X{
X    F_linkinfo	   *k;
X
X    if (cur_linkmode == SMART_OFF)
X	return;
X
X    for (k = cur_links; k != NULL; k = k->next)
X	if (k->prevpt == NULL) {/* dot */
X	    pw_vector(canvas_win, k->endpt->x, k->endpt->y,
X		      k->endpt->x, k->endpt->y,
X		      INV_PAINT, 1, RUBBER_LINE, 0.0, DEFAULT_COLOR);
X	} else {
X	    if (cur_linkmode == SMART_MOVE)
X		pw_vector(canvas_win, k->endpt->x + dx, k->endpt->y + dy,
X			  k->prevpt->x, k->prevpt->y,
X			  INV_PAINT, 1, RUBBER_LINE, 0.0, DEFAULT_COLOR);
X	    else if (cur_linkmode == SMART_SLIDE) {
X		if (k->endpt->x == k->prevpt->x) {
X		    if (!k->two_pts)
X			pw_vector(canvas_win, k->prevpt->x,
X			      k->prevpt->y, k->prevpt->x + dx, k->prevpt->y,
X			     INV_PAINT, 1, RUBBER_LINE, 0.0, DEFAULT_COLOR);
X		    pw_vector(canvas_win, k->endpt->x + dx,
X			  k->endpt->y + dy, k->prevpt->x + dx, k->prevpt->y,
X			      INV_PAINT, 1, RUBBER_LINE, 0.0, DEFAULT_COLOR);
X		} else {
X		    if (!k->two_pts)
X			pw_vector(canvas_win, k->prevpt->x,
X			      k->prevpt->y, k->prevpt->x, k->prevpt->y + dy,
X			     INV_PAINT, 1, RUBBER_LINE, 0.0, DEFAULT_COLOR);
X		    pw_vector(canvas_win, k->endpt->x + dx,
X			  k->endpt->y + dy, k->prevpt->x, k->prevpt->y + dy,
X			      INV_PAINT, 1, RUBBER_LINE, 0.0, DEFAULT_COLOR);
X		}
X	    }
X	}
X}
X
Xscaling_line(x, y)
X    int		    x, y;
X{
X    elastic_scalepts(cur_l->points);
X    adjust_box_pos(x, y, fix_x, fix_y, &cur_x, &cur_y);
X    elastic_scalepts(cur_l->points);
X}
X
Xscaling_spline(x, y)
X    int		    x, y;
X{
X    elastic_scalepts(cur_s->points);
X    adjust_box_pos(x, y, fix_x, fix_y, &cur_x, &cur_y);
X    elastic_scalepts(cur_s->points);
X}
X
Xelastic_scalepts(pts)
X    F_point	   *pts;
X{
X    F_point	   *p;
X    int		    newx, newy, oldx, oldy, ox, oy, xx, yy;
X    float	    newd, oldd, scalefact;
X
X    p = pts;
X    newx = cur_x - fix_x;
X    newy = cur_y - fix_y;
X    newd = sqrt((double) (newx * newx + newy * newy));
X
X    oldx = from_x - fix_x;
X    oldy = from_y - fix_y;
X    oldd = sqrt((double) (oldx * oldx + oldy * oldy));
X
X    scalefact = newd / oldd;
X    ox = fix_x + (p->x - fix_x) * scalefact;
X    oy = fix_y + (p->y - fix_y) * scalefact;
X    for (p = p->next; p != NULL; ox = xx, oy = yy, p = p->next) {
X	xx = fix_x + (p->x - fix_x) * scalefact;
X	yy = fix_y + (p->y - fix_y) * scalefact;
X	pw_vector(canvas_win, ox, oy, xx, yy, INV_PAINT, 1,
X		  RUBBER_LINE, 0.0, DEFAULT_COLOR);
X    }
X}
X
Xelastic_poly(x1, y1, x2, y2, numsides)
X    int		    x1, y1, x2, y2, numsides;
X{
X    register float  angle;
X    register int    nx, ny, dx, dy, i;
X    float	    init_angle, mag;
X    int		    ox, oy;
X
X    dx = x2 - x1;
X    dy = y2 - y1;
X    mag = sqrt((double) (dx * dx + dy * dy));
X    init_angle = compute_angle((float) dx, (float) dy);
X    ox = x2;
X    oy = y2;
X
X    /* now append numsides points */
X    for (i = 1; i < numsides; i++) {
X	angle = init_angle - 2.0 * M_PI * (float) i / (float) numsides;
X	if (angle < 0)
X	    angle += 2.0 * M_PI;
X	nx = x1 + round(mag * cos((double) angle));
X	ny = y1 + round(mag * sin((double) angle));
X	pw_vector(canvas_win, nx, ny, ox, oy, INV_PAINT, 1,
X		  RUBBER_LINE, 0.0, DEFAULT_COLOR);
X	ox = nx;
X	oy = ny;
X    }
X    pw_vector(canvas_win, ox, oy, x2, y2, INV_PAINT, 1,
X	      RUBBER_LINE, 0.0, DEFAULT_COLOR);
X}
X
Xresizing_poly(x, y)
X    int		    x, y;
X{
X    elastic_poly(fix_x, fix_y, cur_x, cur_y, work_numsides);
X    cur_x = x;
X    cur_y = y;
X    work_numsides = cur_numsides;
X    elastic_poly(fix_x, fix_y, cur_x, cur_y, work_numsides);
X}
X
X/*********************** ELLIPSES *************************/
X
Xelastic_ebr()
X{
X    register int    x1, y1, x2, y2;
X    int		    rx, ry;
X
X    rx = cur_x - fix_x;
X    ry = cur_y - fix_y;
X    x1 = fix_x + rx;
X    x2 = fix_x - rx;
X    y1 = fix_y + ry;
X    y2 = fix_y - ry;
X    pw_curve(canvas_win, x1, y1, x2, y2, INV_PAINT, 1,
X	     RUBBER_LINE, 0.0, 0, DEFAULT_COLOR);
X}
X
Xresizing_ebr(x, y)
X    int		    x, y;
X{
X    elastic_ebr();
X    cur_x = x;
X    cur_y = y;
X    elastic_ebr();
X}
X
Xconstrained_resizing_ebr(x, y)
X    int		    x, y;
X{
X    elastic_ebr();
X    adjust_box_pos(x, y, from_x, from_y, &cur_x, &cur_y);
X    elastic_ebr();
X}
X
Xelastic_ebd()
X{
X    pw_curve(canvas_win, fix_x, fix_y, cur_x, cur_y,
X	     INV_PAINT, 1, RUBBER_LINE, 0.0, 0, DEFAULT_COLOR);
X}
X
Xresizing_ebd(x, y)
X    int		    x, y;
X{
X    elastic_ebd();
X    cur_x = x;
X    cur_y = y;
X    elastic_ebd();
X}
X
Xconstrained_resizing_ebd(x, y)
X    int		    x, y;
X{
X    elastic_ebd();
X    adjust_box_pos(x, y, from_x, from_y, &cur_x, &cur_y);
X    elastic_ebd();
X}
X
Xelastic_cbr()
X{
X    register int    radius, x1, y1, x2, y2, rx, ry;
X
X    rx = cur_x - fix_x;
X    ry = cur_y - fix_y;
X    radius = round(sqrt((double) (rx * rx + ry * ry)));
X    x1 = fix_x + radius;
X    x2 = fix_x - radius;
X    y1 = fix_y + radius;
X    y2 = fix_y - radius;
X    pw_curve(canvas_win, x1, y1, x2, y2, INV_PAINT, 1,
X	     RUBBER_LINE, 0.0, 0, DEFAULT_COLOR);
X}
X
Xresizing_cbr(x, y)
X    int		    x, y;
X{
X    elastic_cbr();
X    cur_x = x;
X    cur_y = y;
X    elastic_cbr();
X}
X
Xelastic_cbd()
X{
X    register int    x1, y1, x2, y2;
X    int		    radius, rx, ry;
X
X    rx = (cur_x - fix_x) / 2;
X    ry = (cur_y - fix_y) / 2;
X    radius = round(sqrt((double) (rx * rx + ry * ry)));
X    x1 = fix_x + rx + radius;
X    x2 = fix_x + rx - radius;
X    y1 = fix_y + ry + radius;
X    y2 = fix_y + ry - radius;
X    pw_curve(canvas_win, x1, y1, x2, y2, INV_PAINT, 1,
X	     RUBBER_LINE, 0.0, 0, DEFAULT_COLOR);
X}
X
Xresizing_cbd(x, y)
X    int		    x, y;
X{
X    elastic_cbd();
X    cur_x = x;
X    cur_y = y;
X    elastic_cbd();
X}
X
Xconstrained_resizing_cbd(x, y)
X    int		    x, y;
X{
X    elastic_cbd();
X    adjust_box_pos(x, y, from_x, from_y, &cur_x, &cur_y);
X    elastic_cbd();
X}
X
Xelastic_moveellipse()
X{
X    register int    x1, y1, x2, y2;
X
X    x1 = cur_x + x1off;
X    x2 = cur_x + x2off;
X    y1 = cur_y + y1off;
X    y2 = cur_y + y2off;
X    pw_curve(canvas_win, x1, y1, x2, y2, INV_PAINT, 1,
X	     RUBBER_LINE, 0.0, 0, DEFAULT_COLOR);
X}
X
Xmoving_ellipse(x, y)
X    int		    x, y;
X{
X    elastic_moveellipse();
X    adjust_pos(x, y, fix_x, fix_y, &cur_x, &cur_y);
X    elastic_moveellipse();
X}
X
Xelastic_scaleellipse(e)
X    F_ellipse	   *e;
X{
X    register int    x1, y1, x2, y2;
X    int		    rx, ry;
X    int		    newx, newy, oldx, oldy;
X    float	    newd, oldd, scalefact;
X
X    newx = cur_x - fix_x;
X    newy = cur_y - fix_y;
X    newd = sqrt((double) (newx * newx + newy * newy));
X
X    oldx = from_x - fix_x;
X    oldy = from_y - fix_y;
X    oldd = sqrt((double) (oldx * oldx + oldy * oldy));
X
X    scalefact = newd / oldd;
X
X    rx = e->radiuses.x * scalefact;
X    ry = e->radiuses.y * scalefact;
X    x1 = fix_x + rx;
X    x2 = fix_x - rx;
X    y1 = fix_y + ry;
X    y2 = fix_y - ry;
X    pw_curve(canvas_win, x1, y1, x2, y2, INV_PAINT, 1,
X	     RUBBER_LINE, 0.0, 0, DEFAULT_COLOR);
X}
X
Xscaling_ellipse(x, y)
X    int		    x, y;
X{
X    elastic_scaleellipse(cur_e);
X    adjust_box_pos(x, y, fix_x, fix_y, &cur_x, &cur_y);
X    elastic_scaleellipse(cur_e);
X}
X
X/*************************** ARCS *************************/
X
Xreshaping_arc(x, y)
X    int		    x, y;
X{
X    elastic_arclink();
X    adjust_pos(x, y, cur_a->point[movedpoint_num].x,
X	       cur_a->point[movedpoint_num].y, &cur_x, &cur_y);
X    elastic_arclink();
X}
X
Xelastic_arclink()
X{
X    switch (movedpoint_num) {
X    case 0:
X	pw_vector(canvas_win, cur_x, cur_y,
X		  cur_a->point[1].x, cur_a->point[1].y,
X		  INV_PAINT, 1, RUBBER_LINE, 0.0, DEFAULT_COLOR);
X	break;
X    case 1:
X	pw_vector(canvas_win, cur_a->point[0].x, cur_a->point[0].y,
X		  cur_x, cur_y, INV_PAINT, 1, RUBBER_LINE, 0.0,
X		  DEFAULT_COLOR);
X	pw_vector(canvas_win, cur_a->point[2].x, cur_a->point[2].y,
X		  cur_x, cur_y, INV_PAINT, 1, RUBBER_LINE, 0.0,
X		  DEFAULT_COLOR);
X	break;
X    default:
X	pw_vector(canvas_win, cur_a->point[1].x, cur_a->point[1].y,
X		  cur_x, cur_y, INV_PAINT, 1, RUBBER_LINE, 0.0,
X		  DEFAULT_COLOR);
X    }
X}
X
Xmoving_arc(x, y)
X    int		    x, y;
X{
X    elastic_movearc(new_a);
X    adjust_pos(x, y, fix_x, fix_y, &cur_x, &cur_y);
X    elastic_movearc(new_a);
X}
X
Xelastic_movearc(a)
X    F_arc	   *a;
X{
X    int		    dx, dy;
X
X    dx = cur_x - fix_x;
X    dy = cur_y - fix_y;
X    pw_vector(canvas_win, a->point[0].x + dx, a->point[0].y + dy,
X	      a->point[1].x + dx, a->point[1].y + dy,
X	      INV_PAINT, 1, RUBBER_LINE, 0.0, DEFAULT_COLOR);
X    pw_vector(canvas_win, a->point[1].x + dx, a->point[1].y + dy,
X	      a->point[2].x + dx, a->point[2].y + dy,
X	      INV_PAINT, 1, RUBBER_LINE, 0.0, DEFAULT_COLOR);
X}
X
Xscaling_arc(x, y)
X    int		    x, y;
X{
X    elastic_scalearc(cur_a);
X    adjust_box_pos(x, y, fix_x, fix_y, &cur_x, &cur_y);
X    elastic_scalearc(cur_a);
X}
X
Xelastic_scalearc(a)
X    F_arc	   *a;
X{
X    int		    newx, newy, oldx, oldy;
X    float	    newd, oldd, scalefact;
X    F_pos	    p0, p1, p2;
X
X    newx = cur_x - fix_x;
X    newy = cur_y - fix_y;
X    newd = sqrt((double) (newx * newx + newy * newy));
X
X    oldx = from_x - fix_x;
X    oldy = from_y - fix_y;
X    oldd = sqrt((double) (oldx * oldx + oldy * oldy));
X
X    scalefact = newd / oldd;
X
X    p0 = a->point[0];
X    p1 = a->point[1];
X    p2 = a->point[2];
X    p0.x = fix_x + (p0.x - fix_x) * scalefact;
X    p0.y = fix_y + (p0.y - fix_y) * scalefact;
X    p1.x = fix_x + (p1.x - fix_x) * scalefact;
X    p1.y = fix_y + (p1.y - fix_y) * scalefact;
X    p2.x = fix_x + (p2.x - fix_x) * scalefact;
X    p2.y = fix_y + (p2.y - fix_y) * scalefact;
X
X    pw_vector(canvas_win, p0.x, p0.y, p1.x, p1.y,
X	      INV_PAINT, 1, RUBBER_LINE, 0.0, DEFAULT_COLOR);
X    pw_vector(canvas_win, p1.x, p1.y, p2.x, p2.y,
X	      INV_PAINT, 1, RUBBER_LINE, 0.0, DEFAULT_COLOR);
X}
X
X/*************************** TEXT *************************/
X
Xmoving_text(x, y)
X    int		    x, y;
X{
X    elastic_movetext();
X    adjust_pos(x, y, fix_x, fix_y, &cur_x, &cur_y);
X    elastic_movetext();
X}
X
Xelastic_movetext()
X{
X    pw_text(canvas_win, cur_x + x1off, cur_y + y1off, INV_PAINT,
X	    new_t->font, psfont_text(new_t), new_t->size, new_t->cstring,
X	    new_t->color);
X}
X
X
X/*************************** SPLINES *************************/
X
Xmoving_spline(x, y)
X    int		    x, y;
X{
X    elastic_moveline(new_s->points);
X    adjust_pos(x, y, fix_x, fix_y, &cur_x, &cur_y);
X    elastic_moveline(new_s->points);
X}
X
X/*********** AUXILIARY FUNCTIONS FOR CONSTRAINED MOVES ******************/
X
Xadjust_box_pos(curs_x, curs_y, orig_x, orig_y, ret_x, ret_y)
X    int		    curs_x, curs_y, orig_x, orig_y;
X    int		   *ret_x, *ret_y;
X{
X    int		    xx, sgn_csr2fix_x, yy, sgn_csr2fix_y;
X    double	    mag_csr2fix_x, mag_csr2fix_y;
X
X    switch (constrained) {
X    case MOVE_ARB:
X	*ret_x = curs_x;
X	*ret_y = curs_y;
X	break;
X    case BOX_HSTRETCH:
X	*ret_x = curs_x;
X	*ret_y = orig_y;
X	break;
X    case BOX_VSTRETCH:
X	*ret_x = orig_x;
X	*ret_y = curs_y;
X	break;
X    default:
X	/* calculate where scaled and stretched box corners would be */
X	xx = curs_x - fix_x;
X	sgn_csr2fix_x = signof(xx);
X	mag_csr2fix_x = (double) abs(xx);
X
X	yy = curs_y - fix_y;
X	sgn_csr2fix_y = signof(yy);
X	mag_csr2fix_y = (double) abs(yy);
X
X	if (mag_csr2fix_x * sina > mag_csr2fix_y * cosa) {	/* above diagonal */
X	    *ret_x = curs_x;
X	    if (constrained == BOX_SCALE)
X		*ret_y = fix_y + sgn_csr2fix_y * (int) (mag_csr2fix_x * sina / cosa);
X	    else
X		*ret_y = fix_y + sgn_csr2fix_y * abs(fix_y - orig_y);
X	} else {
X	    *ret_y = curs_y;
X	    if (constrained == BOX_SCALE)
X		*ret_x = fix_x + sgn_csr2fix_x * (int) (mag_csr2fix_y * cosa / sina);
X	    else
X		*ret_x = fix_x + sgn_csr2fix_x * abs(fix_x - orig_x);
X	}
X    }
X}
X
Xadjust_pos(curs_x, curs_y, orig_x, orig_y, ret_x, ret_y)
X    int		    curs_x, curs_y, orig_x, orig_y;
X    int		   *ret_x, *ret_y;
X{
X    if (constrained) {
X	if (abs(orig_x - curs_x) > abs(orig_y - curs_y)) {
X	    *ret_x = curs_x;
X	    *ret_y = orig_y;
X	} else {
X	    *ret_x = orig_x;
X	    *ret_y = curs_y;
X	}
X    } else {
X	*ret_x = curs_x;
X	*ret_y = curs_y;
X    }
X}
END_OF_FILE
if test 20366 -ne `wc -c <'u_elastic.c'`; then
    echo shar: \"'u_elastic.c'\" unpacked with wrong size!
fi
# end of 'u_elastic.c'
fi
if test -f 'w_dir.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'w_dir.c'\"
else
echo shar: Extracting \"'w_dir.c'\" \(18863 characters\)
sed "s/^X//" >'w_dir.c' <<'END_OF_FILE'
X/* This file is part of xdir, an X-based directory browser.
X *
X *	Created: 13 Aug 88
X *
X *	Win Treese
X *	Cambridge Research Lab
X *	Digital Equipment Corporation
X *	treese@crl.dec.com
X *
X *	$Source: /trx/u2/treese/Src/Xdir.rel/RCS/xdir.c,v $
X *
X *	    COPYRIGHT 1990
X *	  DIGITAL EQUIPMENT CORPORATION
X *	   MAYNARD, MASSACHUSETTS
X *	  ALL RIGHTS RESERVED.
X *
X * THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE AND
X * SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.
X * DIGITAL MAKES NO REPRESENTATIONS ABOUT THE SUITABILITY OF THIS SOFTWARE
X * FOR ANY PURPOSE.  IT IS SUPPLIED "AS IS" WITHOUT EXPRESS OR IMPLIED
X * WARRANTY.
X *
X * IF THE SOFTWARE IS MODIFIED IN A MANNER CREATING DERIVATIVE COPYRIGHT
X * RIGHTS, APPROPRIATE LEGENDS MAY BE PLACED ON THE DERIVATIVE WORK IN
X * ADDITION TO THAT SET FORTH ABOVE.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of Digital Equipment Corporation not be
X * used in advertising or publicity pertaining to distribution of the
X * software without specific, written prior permission.
X *
X *	Modified: 4 Dec 91 - Paul King (king@cs.uq.oz.au)
X */
X
X#include "w_util.h"
X#include "fig.h"
X#include "resources.h"
X#include "mode.h"
X#include "w_dir.h"
X#include "w_setup.h"
X#include "w_drawprim.h"		/* for char_height */
X#ifdef USE_DIRENT
X#include <dirent.h>
X#else
X#include <sys/dir.h>
X#endif
X#include <sys/param.h>
X
X/* Static variables */
X
XDeclareStaticArgs(10);
Xstatic Boolean	errorInProgress;
Xstatic String	dir_translations =
X	"<Key>Return: SetDir()\n\
X	Ctrl<Key>X: EmptyTextKey()\n\
X	<Key>F18: PastePanelKey()\n";
Xstatic String	list_panel_translations =
X	"<Btn3Up>: ParentDir()\n";
Xstatic char	CurrentSelectionName[MAXPATHLEN];
Xstatic int	file_entry_cnt, dir_entry_cnt;
Xstatic char   **file_list, **dir_list;
Xstatic char   **filelist, **dirlist;
Xstatic char    *dirmask;
X
X
X/* External variables */
X
Xextern Widget	exp_selfile, file_selfile, exp_dir, file_dir, exp_flist,
X		file_flist, exp_dlist, file_dlist, exp_mask, file_mask;
Xextern Boolean	file_up, export_up;
X
X/* Functions */
X
Xvoid		DoChangeDir(),
X		SetDir(),
X		Rescan();
X
Xstatic void	ParentDir();
X
X/* Function:	FileSelected() is called when the user selects a file.
X *		Set the global variable "CurrentSelectionName"
X *		and set either the export or file panel file name, whichever is popped up
X * Arguments:	Standard Xt callback arguments.
X * Returns:	Nothing.
X * Notes:
X */
X
Xvoid
XFileSelected(w, client_data, ret_val)
X    Widget	    w;
X    caddr_t	    client_data;
X    caddr_t	    ret_val;
X{
X    XawListReturnStruct *ret_struct = (XawListReturnStruct *) ret_val;
X
X    strcpy(CurrentSelectionName, ret_struct->string);
X    FirstArg(XtNstring, CurrentSelectionName);
X	/* I don't know why this doesn't work? */
X	/* NextArg(XtNinsertPosition, strlen(CurrentSelectionName));*/
X	if (export_up) {
X	SetValues(exp_selfile);
X		XawTextSetInsertionPoint(exp_selfile, strlen(CurrentSelectionName));
X	} else {
X	SetValues(file_selfile);
X		XawTextSetInsertionPoint(file_selfile, strlen(CurrentSelectionName));
X	}
X}
X
X/* Function:	DirSelected() is called when the user selects a directory.
X *
X * Arguments:	Standard Xt callback arguments.
X * Returns:	Nothing.
X * Notes:
X */
X
Xvoid
XDirSelected(w, client_data, ret_val)
X    Widget	    w;
X    caddr_t	    client_data;
X    caddr_t	    ret_val;
X{
X    XawListReturnStruct *ret_struct = (XawListReturnStruct *) ret_val;
X
X    strcpy(CurrentSelectionName, ret_struct->string);
X    DoChangeDir(CurrentSelectionName);
X}
X
X/*
X   come here when the user presses return in the directory path widget
X   Get the current string from the widget and set the current directory to that
X   Also, copy the dir to the current directory widget in the file popup
X*/
X
Xvoid
XSetDir()
X{
X    char	   *ndir;
X
X    /* get the string from the widget */
X    FirstArg(XtNstring, &ndir);
X    if (file_up)
X	GetValues(file_dir);
X    else
X	GetValues(exp_dir);
X    strcpy(cur_dir, ndir);
X    DoChangeDir(cur_dir);
X}
X
Xstatic String	mask_text_translations =
X"<Key>Return: Rescan()\n\
X		Ctrl<Key>J: Rescan()\n\
X		Ctrl<Key>M: Rescan()\n";
X
Xstatic XtActionsRec actionTable[] = {
X    {"ParentDir", ParentDir},
X    {"SetDir", SetDir},
X    {"Rescan", Rescan},
X};
X
Xvoid
Xcreate_dirinfo(parent, below, ret_beside, ret_below,
X	       mask_w, dir_w, flist_w, dlist_w)
X    Widget	    parent, below, *ret_beside, *ret_below, *mask_w, *dir_w,
X		   *flist_w, *dlist_w;
X
X{
X    Widget	    w;
X    Widget	    file_viewport;
X    Widget	    dir_viewport;
X    PIX_FONT	    temp_font;
X    int		    char_ht;
X
X    dir_entry_cnt = NENTRIES;
X    file_entry_cnt = NENTRIES;
X    filelist = (char **) calloc(file_entry_cnt, sizeof(char *));
X    dirlist = (char **) calloc(dir_entry_cnt, sizeof(char *));
X
X    get_directory(cur_dir);
X
X    FirstArg(XtNlabel, "     Alternatives:");
X    NextArg(XtNfromVert, below);
X    NextArg(XtNborderWidth, 0);
X    w = XtCreateManagedWidget("filename", labelWidgetClass,
X			      parent, Args, ArgCount);
X    FirstArg(XtNfont, &temp_font);
X    GetValues(w);
X    char_ht = char_height(temp_font) + 2;
X
X    FirstArg(XtNallowVert, True);
X    NextArg(XtNfromHoriz, w);
X    NextArg(XtNfromVert, below);
X    NextArg(XtNborderWidth, INTERNAL_BW);
X    NextArg(XtNwidth, 350);
X    NextArg(XtNheight, char_ht * 10);
X    file_viewport = XtCreateManagedWidget("vport", viewportWidgetClass,
X					  parent, Args, ArgCount);
X
X    FirstArg(XtNlabel, "    Filename Mask:");
X    NextArg(XtNborderWidth, 0);
X    NextArg(XtNfromVert, file_viewport);
X    w = XtCreateManagedWidget("mask_label", labelWidgetClass, parent,
X			      Args, ArgCount);
X
X    FirstArg(XtNeditType, XawtextEdit);
X    NextArg(XtNscrollHorizontal, XawtextScrollNever);
X    NextArg(XtNborderWidth, INTERNAL_BW);
X    NextArg(XtNscrollVertical, XawtextScrollNever);
X    NextArg(XtNresize, XawtextResizeWidth);
X    NextArg(XtNwidth, 100);
X    NextArg(XtNfromHoriz, w);
X    NextArg(XtNfromVert, file_viewport);
X    *mask_w = XtCreateManagedWidget("mask", asciiTextWidgetClass, parent,
X				    Args, ArgCount);
X    XtOverrideTranslations(*mask_w,
X			   XtParseTranslationTable(mask_text_translations));
X
X    /* get the first directory listing */
X    FirstArg(XtNstring, &dirmask);
X    GetValues(*mask_w);
X    if (MakeFileList(cur_dir, dirmask, &dir_list, &file_list) == 0)
X	put_msg("No files in directory?");
X
X    FirstArg(XtNlabel, "Current Directory:");
X    NextArg(XtNborderWidth, 0);
X    NextArg(XtNfromVert, *mask_w);
X    NextArg(XtNvertDistance, 15);
X    w = XtCreateManagedWidget("dirname", labelWidgetClass,
X			      parent, Args, ArgCount);
X    FirstArg(XtNstring, cur_dir);
X	NextArg(XtNinsertPosition, strlen(cur_dir));
X    NextArg(XtNheight, char_ht * 2);
X    NextArg(XtNborderWidth, INTERNAL_BW);
X    NextArg(XtNscrollHorizontal, XawtextScrollWhenNeeded);
X    NextArg(XtNeditType, XawtextEdit);
X    NextArg(XtNfromVert, *mask_w);
X    NextArg(XtNvertDistance, 15);
X    NextArg(XtNfromHoriz, w);
X    NextArg(XtNwidth, 350);
X    *dir_w = XtCreateManagedWidget("dirname", asciiTextWidgetClass,
X				   parent, Args, ArgCount);
X
X    XtOverrideTranslations(*dir_w,
X			   XtParseTranslationTable(dir_translations));
X
X    FirstArg(XtNlabel, "     Alternatives:");
X    NextArg(XtNborderWidth, 0);
X    NextArg(XtNfromVert, *dir_w);
X    w = XtCreateManagedWidget("dirname", labelWidgetClass,
X			      parent, Args, ArgCount);
X    FirstArg(XtNallowVert, True);
X    NextArg(XtNfromHoriz, w);
X    NextArg(XtNfromVert, *dir_w);
X    NextArg(XtNborderWidth, INTERNAL_BW);
X    NextArg(XtNwidth, 350);
X    NextArg(XtNheight, char_ht * 4);
X    dir_viewport = XtCreateManagedWidget("dirvport", viewportWidgetClass,
X					 parent, Args, ArgCount);
X
X    FirstArg(XtNlist, file_list);
X    *flist_w = XtCreateManagedWidget("file_list_panel", listWidgetClass,
X				     file_viewport, Args, ArgCount);
X    XtOverrideTranslations(*flist_w,
X			   XtParseTranslationTable(list_panel_translations));
X    XtAddCallback(*flist_w, XtNcallback, FileSelected,
X		  (caddr_t) NULL);
X
X    FirstArg(XtNlist, dir_list);
X    *dlist_w = XtCreateManagedWidget("dir_list_panel", listWidgetClass,
X				     dir_viewport, Args, ArgCount);
X    XtOverrideTranslations(*dlist_w,
X			   XtParseTranslationTable(list_panel_translations));
X    XtAddCallback(*dlist_w, XtNcallback, DirSelected,
X		  (caddr_t) NULL);
X
X    XtAppAddActions(tool_app, actionTable, XtNumber(actionTable));
X
X    FirstArg(XtNlabel, "Rescan");
X    NextArg(XtNfromVert, dir_viewport);
X    NextArg(XtNborderWidth, INTERNAL_BW);
X    NextArg(XtNvertDistance, 15);
X    NextArg(XtNhorizDistance, 45);
X    NextArg(XtNheight, 25);
X    w = XtCreateManagedWidget("rescan", commandWidgetClass, parent,
X			      Args, ArgCount);
X    XtAddCallback(w, XtNcallback, Rescan, NULL);
X    *ret_beside = w;
X    *ret_below = dir_viewport;
X    return;
X}
X
X/* Function:	SPComp() compares two string pointers for qsort().
X * Arguments:	s1, s2: strings to be compared.
X * Returns:	Value of strcmp().
X * Notes:
X */
X
Xstatic int
XSPComp(s1, s2)
X    char	  **s1, **s2;
X{
X    return (strcmp(*s1, *s2));
X}
X
XMakeFileList(dir_name, mask, dir_list, file_list)
X    char	   *dir_name;
X    char	   *mask, ***dir_list, ***file_list;
X{
X    DIR		   *dirp;
X    DIRSTRUCT	  *dp;
X    char	  **cur_file, **cur_directory;
X    char	  **last_file, **last_dir;
X
X    set_temp_cursor(wait_cursor);
X    cur_file = filelist;
X    cur_directory = dirlist;
X    last_file = filelist + file_entry_cnt - 1;
X    last_dir = dirlist + dir_entry_cnt - 1;
X
X    dirp = opendir(dir_name);
X    if (dirp == NULL) {
X	reset_cursor();
X	*file_list = filelist;
X	*file_list[0]="";
X	*dir_list = dirlist;
X	*dir_list[0]="..";
X	return (NULL);
X    }
X    /* process any events to ensure cursor is set to wait_cursor */
X    /*
X     * don't do this inside the following loop because this procedure could
X     * be re-entered if the user presses (e.g.) rescan
X     */
X    app_flush();
X
X    for (dp = readdir(dirp); dp != NULL; dp = readdir(dirp)) {
X	/* skip over '.' (current dir) */
X	if (!strcmp(dp->d_name, "."))
X	    continue;
X
X	if (IsDirectory(dir_name, dp->d_name)) {
X	    *cur_directory++ = SaveString(dp->d_name);
X	    if (cur_directory == last_dir) {	/* out of space, make more */
X		dirlist = (char **) realloc(dirlist,
X					2 * dir_entry_cnt * sizeof(char *));
X		cur_directory = dirlist + dir_entry_cnt - 1;
X		dir_entry_cnt = 2 * dir_entry_cnt;
X		last_dir = dirlist + dir_entry_cnt - 1;
X	    }
X	} else {
X	    /* check if matches regular expression */
X	    if ((mask == NULL) || (*mask == '\0'))
X		mask = "*";
X	    else if (*mask == '\0')
X		mask = "*";
X	    if (wild_match(dp->d_name, mask) == 0)
X		continue;	/* no, do next */
X	    if (mask[0] == '*' && dp->d_name[0] == '.')
X		continue;	/* skip files with leading . */
X	    *cur_file++ = SaveString(dp->d_name);
X	    if (cur_file == last_file) {	/* out of space, make more */
X		filelist = (char **) realloc(filelist,
X				       2 * file_entry_cnt * sizeof(char *));
X		cur_file = filelist + file_entry_cnt - 1;
X		file_entry_cnt = 2 * file_entry_cnt;
X		last_file = filelist + file_entry_cnt - 1;
X	    }
X	}
X    }
X    *cur_file = NULL;
X    *cur_directory = NULL;
X    if (cur_file != filelist)
X	qsort(filelist, cur_file - filelist - 1, sizeof(char *), SPComp);
X    if (cur_directory != dirlist)
X	qsort(dirlist, cur_directory - dirlist - 1, sizeof(char *), SPComp);
X    *file_list = filelist;
X    *dir_list = dirlist;
X    reset_cursor();
X    closedir(dirp);
X    return 1;
X}
X
X/* Function:	ParentDir() changes to the parent directory.
X * Arguments:	Standard Xt callback arguments.
X * Returns:	Nothing.
X * Notes:
X */
X
Xstatic void
XParentDir(w, client_data, call_data)
X    Widget	    w;
X    caddr_t	    client_data;
X    caddr_t	    call_data;
X{
X    DoChangeDir("..");
X}
X
X/* Function:	DoChangeDir() actually changes the directory and changes
X *		the list widget values to the new listing.
X * Arguments:	dir:	Pathname of new directory.
X * Returns:	Nothing.
X * Notes:
X *	NULL for dir means to rebuild the file list for the current directory
X *	(as in an update to the directory or change in filename filter).
X */
X
Xvoid
XDoChangeDir(dir)
X    char	   *dir;
X{
X    char	  **file_list;
X    char	  **dir_list;
X    char	   *p;
X    Arg		    args[10];
X    Cardinal	    arg_cnt;
X    char	    ndir[MAXPATHLEN], tmpdir[MAXPATHLEN];
X
X    
X    strcpy(ndir, cur_dir);
X    if (dir != NULL && dir[0] != '/') { /* relative path, prepend current dir */
X	if (dir[strlen(dir) - 1] == '/')
X	    dir[strlen(dir) - 1] = '\0';
X	if (!strcmp(dir, "..")) {	/* Parent directory. */
X	    if (*ndir == '\0')
X		return;			/* no current directory, */
X					/* can't do anything unless absolute path */
X	    p = rindex(ndir, '/');
X	    *p = EOS;
X	    if (ndir[0] == EOS)
X		strcpy(ndir, "/");
X	} else {
X	    if (strcmp(ndir, "/"))	/* At the root already */
X		strcat(ndir, "/");
X	    strcat(ndir, dir);
X	}
X    }
X    strcpy(tmpdir, cur_dir);
X    strcpy(cur_dir, ndir);
X    if (change_directory(cur_dir) != 0 ) {
X	put_msg("Can't change to directory %s", cur_dir);
X	strcpy(cur_dir, tmpdir);
X    } else if ( MakeFileList(ndir, dirmask, &dirlist, &filelist) == 0) {
X	put_msg("Unable to list directory %s", ndir);
X	strcpy(cur_dir, tmpdir);
X    }
X
X    FirstArg(XtNstring, cur_dir);
X    /* I don't know why this doesn't work? */
X    /* NextArg(XtNinsertPosition, strlen(cur_dir));*/
X    /* update the current directory and file/dir list widgets */
X    if (file_up) 
X	{
X	SetValues(file_dir);
X	XawTextSetInsertionPoint(file_dir, strlen(cur_dir));
X	XawListChange(file_flist, filelist, 0, 0, True);
X	XawListChange(file_dlist, dirlist, 0, 0, True);
X    } else {
X	SetValues(exp_dir);
X	XawTextSetInsertionPoint(exp_dir, strlen(cur_dir));
X	XawListChange(exp_flist, filelist, 0, 0, True);
X	XawListChange(exp_dlist, dirlist, 0, 0, True);
X	}
X    CurrentSelectionName[0] = '\0';
X}
X
Xvoid
XRescan()
X{
X    char	   *dir;
X
X    /*
X     * get the mask string from the File or Export mask widget and put in
X     * dirmask
X     */
X    if (file_up) {
X	FirstArg(XtNstring, &dirmask);
X	GetValues(file_mask);
X	FirstArg(XtNstring, &dir);
X	GetValues(file_dir);
X	MakeFileList(dir, dirmask, &dir_list, &file_list);
X	XawListChange(file_flist, file_list, 0, 0, True);
X	XawListChange(file_dlist, dir_list, 0, 0, True);
X    } else {
X	FirstArg(XtNstring, &dirmask);
X	GetValues(exp_mask);
X	FirstArg(XtNstring, &dir);
X	GetValues(exp_dir);
X	MakeFileList(dir, dirmask, &dir_list, &file_list);
X	XawListChange(exp_flist, file_list, 0, 0, True);
X	XawListChange(exp_dlist, dir_list, 0, 0, True);
X    }
X}
X
X
X/* Function:	SaveString() creates a copy of a string.
X * Arguments:	string: String to save.
X * Returns:	A pointer to the new copy (char *).
X * Notes:
X */
X
Xchar	       *
XSaveString(string)
X    char	   *string;
X{
X    char	   *new;
X
X    new = (char *) malloc(strlen(string) + 1);
X    strcpy(new, string);
X    return (new);
X}
X
X/* Function:	IsDirectory() tests to see if a pathname is a directory.
X * Arguments:	path:	Pathname of file to test.
X * Returns:	True or False.
X * Notes:	False is returned if the directory is not accessible.
X */
X
XBoolean
XIsDirectory(root, path)
X    char	   *root;
X    char	   *path;
X{
X    char	    fullpath[MAXPATHLEN];
X    struct stat	    statbuf;
X
X    if (path == NULL)
X	return (False);
X    MakeFullPath(root, path, fullpath);
X    if (stat(fullpath, &statbuf))	/* some error, report that it is not
X					 * a directory */
X	return (False);
X    if (statbuf.st_mode & S_IFDIR)
X	return (True);
X    else
X	return (False);
X}
X
X/* Function:	MakeFullPath() creates the full pathname for the given file.
X * Arguments:	filename:	Name of the file in question.
X *		pathname:	Buffer for full name.
X * Returns:	Nothing.
X * Notes:
X */
X
Xvoid
XMakeFullPath(root, filename, pathname)
X    char	   *root;
X    char	   *filename;
X    char	   *pathname;
X{
X    strcpy(pathname, root);
X    strcat(pathname, "/");
X    strcat(pathname, filename);
X}
X
X/* wildmatch.c - Unix-style command line wildcards
X
X   This procedure is in the public domain.
X
X   After that, it is just as if the operating system had expanded the
X   arguments, except that they are not sorted.	The program name and all
X   arguments that are expanded from wildcards are lowercased.
X
X   Syntax for wildcards:
X   *		Matches zero or more of any character (except a '.' at
X		the beginning of a name).
X   ?		Matches any single character.
X   [r3z]	Matches 'r', '3', or 'z'.
X   [a-d]	Matches a single character in the range 'a' through 'd'.
X   [!a-d]	Matches any single character except a character in the
X		range 'a' through 'd'.
X
X   The period between the filename root and its extension need not be
X   given explicitly.  Thus, the pattern `a*e' will match 'abacus.exe'
X   and 'axyz.e' as well as 'apple'.  Comparisons are not case sensitive.
X
X   The wild_match code was written by Rich Salz, rsalz@bbn.com,
X   posted to net.sources in November, 1986.
X
X   The code connecting the two is by Mike Slomin, bellcore!lcuxa!mike2,
X   posted to comp.sys.ibm.pc in November, 1988.
X
X   Major performance enhancements and bug fixes, and source cleanup,
X   by David MacKenzie, djm@ai.mit.edu. */
X
X/* Shell-style pattern matching for ?, \, [], and * characters.
X   I'm putting this replacement in the public domain.
X
X   Written by Rich $alz, mirror!rs, Wed Nov 26 19:03:17 EST 1986. */
X
X/* The character that inverts a character class; '!' or '^'. */
X#define INVERT '!'
X
Xstatic int	star();
X
X/* Return nonzero if `string' matches Unix-style wildcard pattern
X   `pattern'; zero if not. */
X
Xint
Xwild_match(string, pattern)
X    char	   *string, *pattern;
X{
X    int		    prev;	/* Previous character in character class. */
X    int		    matched;	/* If 1, character class has been matched. */
X    int		    reverse;	/* If 1, character class is inverted. */
X
X    for (; *pattern; string++, pattern++)
X	switch (*pattern) {
X	case '\\':
X	    /* Literal match with following character; fall through. */
X	    pattern++;
X	default:
X	    if (*string != *pattern)
X		return 0;
X	    continue;
X	case '?':
X	    /* Match anything. */
X	    if (*string == '\0')
X		return 0;
X	    continue;
X	case '*':
X	    /* Trailing star matches everything. */
X	    return *++pattern ? star(string, pattern) : 1;
X	case '[':
X	    /* Check for inverse character class. */
X	    reverse = pattern[1] == INVERT;
X	    if (reverse)
X		pattern++;
X	    for (prev = 256, matched = 0; *++pattern && *pattern != ']';
X		 prev = *pattern)
X		if (*pattern == '-'
X		    ? *string <= *++pattern && *string >= prev
X		    : *string == *pattern)
X		    matched = 1;
X	    if (matched == reverse)
X		return 0;
X	    continue;
X	}
X
X    return *string == '\0';
X}
X
Xstatic int
Xstar(string, pattern)
X    char	   *string, *pattern;
X{
X    while (wild_match(string, pattern) == 0)
X	if (*++string == '\0')
X	    return 0;
X    return 1;
X}
END_OF_FILE
if test 18863 -ne `wc -c <'w_dir.c'`; then
    echo shar: \"'w_dir.c'\" unpacked with wrong size!
fi
# end of 'w_dir.c'
fi
echo shar: End of archive 9 \(of 25\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Molecular Simulations, Inc.             mail: dcmartin@msi.com
796 N. Pastoria Avenue                  uucp: uunet!dcmartin
Sunnyvale, California 94086             at&t: 408/522-9236
