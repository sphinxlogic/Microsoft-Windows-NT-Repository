Path: uunet!wupost!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: envbvs@bea.lbl.gov (Brian V. Smith)
Newsgroups: comp.sources.x
Subject: v16i006: Xfig 2.1.3, Part01/25
Message-ID: <csx-16i006-xfig-2.1.3@uunet.UU.NET>
Date: 4 Feb 92 14:56:18 GMT
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1892
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: envbvs@bea.lbl.gov (Brian V. Smith)
Posting-number: Volume 16, Issue 6
Archive-name: xfig-2.1.3/part01

# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
#		"End of archive 1 (of 25)."
# Contents:  README Doc Examples d_spline.c w_indpanel.c
# Wrapped by dcmartin@fascet on Tue Feb  4 06:42:26 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(4044 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X===============================================================
XXFIG - Facility for Interactive Generation of figures under X11
X===============================================================
X
X
XXfig is a menu-driven tool that allows the user to draw and manipulate objects
Xinteractively in an X window.  The resulting pictures can be saved, printed
Xon postscript printers or converted to a variety of other formats (e.g. to
Xallow inclusion in LaTeX documents).
X
XThis file contains some notes about installing xfig, the directory
X'Examples' contains some example figures and the 'Doc' directory contains
Xsome further documentation including the manual in troff -man format.
X
XPlease report any bugs, fixes, contributions, etc. to:
X
XBrian V. Smith (bvsmith@lbl.gov)
X
X
X===================
XINSTALLATION NOTES:
X===================
X
X1. Edit the Imakefile if you need to customize it (see following notes)
X2. Type "make Makefile" or "xmkmf" if you have xmkmf
X3. Type "make install"
X4. Type "make install.man"
X5. Add the resources from Fig.ad to /usr/lib/.../app-defaults/Fig that you
X	wish to use
X6. For X11R5 color implementations, copy the Fig-color.ad to 
X	/usr/lib/.../app-defaults and specify "*customization: -color" in your 
X	.Xdefaults file.
X	NOTE: this only works under X11R5.
X
XThe SMOOTHMOTION option toggles between two methods for tracking the
Xcursor.  The first way (SMOOTHMOTION) just uses the (x,y) information given
Xin the X pointer motion event.  If your display server doesn't implement
Xmotion compression this is very slow for large movements of the mouse
Xpointer because X sends back lots of small movement events, each of which
Xcauses the rubberband box to be erased and redrawn.  The alternative
Xway (not SMOOTHMOTION) queries the position of the X cursor whenever
Xa motion event is received and if you make a large movement and then
Xstop actually turns out to involve less work even though the XQueryPointer
Xcall is quite slow.
XThe SMOOTHMOTION method is also automatically used for OpenWindows (when the
X-DOPENWIN flag is used).
X
X-----------------
XOpenWindows users
X-----------------
X
XOpenwindows has scalable fonts so xfig must be compiled with the -DOPENWIN
Xflag in order to handle this.  Also, there is a difference in the way the
Xpointer position is queried for OpenWindows.  See the SMOOTHMOTION description.
X
XThere is also a bug in OpenWindows 2.0 which relates to pixmaps in widgets.
XYou must compile xfig with the -DOPENWIN_BUG option for this problem.
X
X----------------------
XPrinting your figures:
X----------------------
X
XThe program to translate your figure into one of many printer languages
X(Postscript, LaTex, etc) is called fig2dev and is part of the TransFig
Xpackage by Micah Beck.
XIt is available from export.lcs.mit.edu in /contrib/transfig.tar.Z or
Xftp.cs.cornell.edu in the directory /pub/fig.
XSee the man pages for more information.
X
X----------------------------------------------
XPossible problems encountered installing xfig:
X----------------------------------------------
X
XPROBLEM:
X	The window oscillates and fights with the window manager when
X	I click on a mode button or try to resize the xfig window.
X
XPOSSIBLE CAUSE AND SOLUTION:
X 	Perhaps the following resource has been set
X 		*allowShellResize: true
X	because another program requires it to be true.
X	Change the resource to be specific to the programs which need it.
X
XPROBLEM:
X	Openwindows sometimes loses track of xfig's icon.
X
XPOSSIBLE CAUSE AND SOLUTION:
X	Cause unknown, here is a temporary kludge. Place the line:
X		Fig*iconPixmap:               ..../your_lib_area/fig.icon.X
X	in your .Xdefaults file and copy fig.icon.X into your lib area.
X
XPROBLEM:
X	I can't seem to get a single xfig binary to work under both
X	openwindows and standard X.
X
XPOSSIBLE CAUSE AND SOLUTION:
X	You can compile xfig so that it knows about openwindows fonts
X	but then it won't work under standard X.  If you want a single
X	binary, compile with -DOPENWIN_BUG but not -DOPENWIN.  This
X	will work on both systems but you won't be able to access the
X	openwindows fonts.
X
END_OF_FILE
if test 4044 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test ! -d 'Doc' ; then
    echo shar: Creating directory \"'Doc'\"
    mkdir 'Doc'
fi
if test ! -d 'Examples' ; then
    echo shar: Creating directory \"'Examples'\"
    mkdir 'Examples'
fi
if test -f 'd_spline.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'d_spline.c'\"
else
echo shar: Extracting \"'d_spline.c'\" \(3522 characters\)
sed "s/^X//" >'d_spline.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of M.I.T. not be used in advertising or
X * publicity pertaining to distribution of the software without specific,
X * written prior permission.  M.I.T. makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty."
X *
X */
X
X#include "fig.h"
X#include "resources.h"
X#include "mode.h"
X#include "object.h"
X#include "paintop.h"
X#include "u_create.h"
X#include "u_elastic.h"
X#include "u_list.h"
X#include "w_canvas.h"
X#include "w_mousefun.h"
X
Xstatic int	create_splineobject();
Xstatic int	init_spline_drawing();
X
Xspline_drawing_selected()
X{
X    set_mousefun("first point", "", "");
X    canvas_kbd_proc = null_proc;
X    canvas_locmove_proc = null_proc;
X    canvas_leftbut_proc = init_spline_drawing;
X    canvas_middlebut_proc = null_proc;
X    canvas_rightbut_proc = null_proc;
X    set_cursor(arrow_cursor);
X    reset_action_on();
X}
X
Xstatic
Xinit_spline_drawing(x, y)
X    int		    x, y;
X{
X    if (cur_mode == F_CLOSED_SPLINE) {
X	min_num_points = 3;
X	init_trace_drawing(x, y);
X	canvas_middlebut_save = create_splineobject;
X    } else {
X	min_num_points = 2;
X	init_trace_drawing(x, y);
X	canvas_middlebut_proc = create_splineobject;
X    }
X    return_proc = spline_drawing_selected;
X}
X
Xstatic
Xcreate_splineobject(x, y)
X    int		    x, y;
X{
X    F_spline	   *spline;
X
X    if (x != fix_x || y != fix_y || num_point < min_num_points) {
X	if (manhattan_mode || mountain_mode)
X	    get_direction(x, y);
X	else if (latexline_mode || latexarrow_mode)
X	    get_latexpoint(x, y);
X	else
X	    get_intermediatepoint(x, y);
X    }
X    elastic_line();
X    if ((spline = create_spline()) == NULL)
X	return;
X
X    spline->style = cur_linestyle;
X    spline->thickness = cur_linewidth;
X    spline->style_val = cur_styleval * (cur_linewidth + 1) / 2;
X    spline->color = cur_color;
X    spline->depth = 0;
X    spline->pen = 0;
X    spline->fill_style = cur_fillstyle;
X    /*
X     * The current fill style is saved in all spline objects (but support for
X     * filling may not be available in all fig2dev languages).
X     */
X    spline->points = first_point;
X    spline->controls = NULL;
X    spline->next = NULL;
X    /* initialise for no arrows - updated below if necessary */
X    spline->for_arrow = NULL;
X    spline->back_arrow = NULL;
X    cur_x = cur_y = fix_x = fix_y = 0;	/* used in elastic_moveline */
X    elastic_moveline(spline->points);	/* erase control vector */
X    if (cur_mode == F_CLOSED_SPLINE) {
X	spline->type = T_CLOSED_NORMAL;
X	num_point++;
X	append_point(first_point->x, first_point->y, &cur_point);
X	draw_closed_spline(spline, PAINT);
X    } else {			/* It must be F_SPLINE */
X	if (autoforwardarrow_mode)
X	    spline->for_arrow = forward_arrow();
X	if (autobackwardarrow_mode)
X	    spline->back_arrow = backward_arrow();
X	spline->type = T_OPEN_NORMAL;
X	draw_open_spline(spline, PAINT);
X    }
X    if (appres.DEBUG) {
X	int		xmin, ymin, xmax, ymax;
X
X	spline_bound(spline, &xmin, &ymin, &xmax, &ymax);
X	elastic_box(xmin, ymin, xmax, ymax);
X    }
X    add_spline(spline);
X    spline_drawing_selected();
X    draw_mousefun_canvas();
X}
END_OF_FILE
if test 3522 -ne `wc -c <'d_spline.c'`; then
    echo shar: \"'d_spline.c'\" unpacked with wrong size!
fi
# end of 'd_spline.c'
fi
if test -f 'w_indpanel.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'w_indpanel.c'\"
else
echo shar: Extracting \"'w_indpanel.c'\" \(43799 characters\)
sed "s/^X//" >'w_indpanel.c' <<'END_OF_FILE'
X/*
X * FIG : Facility for Interactive Generation of figures
X * Copyright (c) 1985 by Supoj Sutanthavibul
X *
X * "Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of M.I.T. not be used in advertising or
X * publicity pertaining to distribution of the software without specific,
X * written prior permission.  M.I.T. makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty."
X *
X */
X
X#include "fig.h"
X#include "resources.h"
X#include "object.h"
X#include "mode.h"
X#include "paintop.h"
X#include "u_fonts.h"
X#include "w_drawprim.h"
X#include "w_icons.h"
X#include "w_indpanel.h"
X#include "w_mousefun.h"
X#include "w_setup.h"
X#include "w_util.h"
X#include "w_zoom.h"
X
Xextern Pixmap	psfont_menu_bitmaps[], latexfont_menu_bitmaps[];
Xextern struct _fstruct ps_fontinfo[], latex_fontinfo[];
Xextern char    *panel_get_value();
Xextern int	show_zoom();
X
X/**************	    local variables and routines   **************/
X
Xstatic int	cur_anglegeom = L_UNCONSTRAINED;
Xstatic int	cur_indmask = I_MIN1;
X
Xstatic String	set_translations = 
X	"<Key>Return: SetValue()";
Xstatic void	nval_panel_set();
Xstatic XtActionsRec set_actions[] =
X{
X    {"SetValue", (XtActionProc) nval_panel_set},
X};
X
XDeclareStaticArgs(15);
X
X/* declarations for choice buttons */
Xstatic int	inc_choice(), dec_choice();
Xstatic int	show_valign(), show_halign(), show_textjust();
Xstatic int	show_arrowmode(), show_linestyle(), show_anglegeom();
Xstatic int	show_pointposn(), show_gridmode(), show_linkmode();
X
X/* declarations for value buttons */
Xstatic int	show_linewidth(), inc_linewidth(), dec_linewidth();
Xstatic int	show_boxradius(), inc_boxradius(), dec_boxradius();
Xstatic int	show_fillstyle(), darken_fill(), lighten_fill();
Xstatic int	show_color(), next_color(), prev_color();
Xstatic int	show_font(), inc_font(), dec_font();
Xstatic int	show_fontsize(), inc_fontsize(), dec_fontsize();
Xstatic int	show_textstep(), inc_textstep(), dec_textstep();
Xstatic int	inc_zoom(), dec_zoom();
Xstatic int	show_rotnangle(), inc_rotnangle(), dec_rotnangle();
Xstatic int	show_numsides(), inc_numsides(), dec_numsides();
X
Xstatic int	popup_fonts();
X
Xstatic char	indbuf[5];
Xstatic int	old_zoomscale = -1;
Xstatic int	old_rotnangle = -1;
X
X#define		DEF_IND_SW_HT		32
X#define		DEF_IND_SW_WD		64
X#define		FONT_IND_SW_WD		(40+PS_FONTPANE_WD)
X#define		NARROW_IND_SW_WD	56
X#define		WIDE_IND_SW_WD		76
X
X/* indicator switch definitions */
X
Xstatic choice_info anglegeom_choices[] = {
X    {L_UNCONSTRAINED, &unconstrained_ic,},
X    {L_LATEXLINE, &latexline_ic,},
X    {L_LATEXARROW, &latexarrow_ic,},
X    {L_MOUNTHATTAN, &mounthattan_ic,},
X    {L_MANHATTAN, &manhattan_ic,},
X    {L_MOUNTAIN, &mountain_ic,},
X};
X
X#define NUM_ANGLEGEOM_CHOICES (sizeof(anglegeom_choices)/sizeof(choice_info))
X
Xstatic choice_info valign_choices[] = {
X    {NONE, &none_ic,},
X    {TOP, &valignt_ic,},
X    {CENTER, &valignc_ic,},
X    {BOTTOM, &valignb_ic,},
X};
X
X#define NUM_VALIGN_CHOICES (sizeof(valign_choices)/sizeof(choice_info))
X
Xstatic choice_info halign_choices[] = {
X    {NONE, &none_ic,},
X    {LEFT, &halignl_ic,},
X    {CENTER, &halignc_ic,},
X    {RIGHT, &halignr_ic,},
X};
X
X#define NUM_HALIGN_CHOICES (sizeof(halign_choices)/sizeof(choice_info))
X
Xstatic choice_info gridmode_choices[] = {
X    {GRID_0, &none_ic,},
X    {GRID_1, &grid1_ic,},
X    {GRID_2, &grid2_ic,},
X};
X
X#define NUM_GRIDMODE_CHOICES (sizeof(gridmode_choices)/sizeof(choice_info))
X
Xstatic choice_info pointposn_choices[] = {
X    {P_ANY, &any_ic,},
X    {P_MAGNET, &fine_grid_ic,},
X    {P_GRID1, &grid1_ic,},
X    {P_GRID2, &grid2_ic,},
X};
X
X#define NUM_POINTPOSN_CHOICES (sizeof(pointposn_choices)/sizeof(choice_info))
X
Xstatic choice_info arrowmode_choices[] = {
X    {L_NOARROWS, &noarrows_ic,},
X    {L_FARROWS, &farrows_ic,},
X    {L_FBARROWS, &fbarrows_ic,},
X    {L_BARROWS, &barrows_ic,},
X};
X
X#define NUM_ARROWMODE_CHOICES (sizeof(arrowmode_choices)/sizeof(choice_info))
X
Xstatic choice_info textjust_choices[] = {
X    {T_LEFT_JUSTIFIED, &textL_ic,},
X    {T_CENTER_JUSTIFIED, &textC_ic,},
X    {T_RIGHT_JUSTIFIED, &textR_ic,},
X};
X
X#define NUM_TEXTJUST_CHOICES (sizeof(textjust_choices)/sizeof(choice_info))
X
Xstatic choice_info linestyle_choices[] = {
X    {SOLID_LINE, &solidline_ic,},
X    {DASH_LINE, &dashline_ic,},
X    {DOTTED_LINE, &dottedline_ic,},
X};
X
X#define NUM_LINESTYLE_CHOICES (sizeof(linestyle_choices)/sizeof(choice_info))
X
Xstatic choice_info linkmode_choices[] = {
X    {SMART_OFF, &smartoff_ic,},
X    {SMART_MOVE, &smartmove_ic,},
X    {SMART_SLIDE, &smartslide_ic,},
X};
X
X#define NUM_LINKMODE_CHOICES (sizeof(linkmode_choices)/sizeof(choice_info))
X
Xchoice_info	fillstyle_choices[NUMFILLPATS + 1];
X
Xchoice_info	color_choices[NUMCOLORS + 1];
Xstatic ind_sw_info *fill_style_sw;
X
X#define I_CHOICE	0
X#define I_IVAL		1
X#define I_FVAL		2
X
X#define		inc_action(z)	(z->inc_func)(z)
X#define		dec_action(z)	(z->dec_func)(z)
X#define		show_action(z)	(z->show_func)(z)
X
Xind_sw_info	ind_switches[] = {
X    {I_IVAL, I_ZOOM, "Zoom", "Scale", NARROW_IND_SW_WD,
X	&zoomscale, NULL, inc_zoom, dec_zoom, show_zoom,},
X    {I_CHOICE, I_GRIDMODE, "Grid", "Mode", DEF_IND_SW_WD,
X	&cur_gridmode, NULL, inc_choice, dec_choice, show_gridmode,
X	gridmode_choices, NUM_GRIDMODE_CHOICES, NUM_GRIDMODE_CHOICES,},
X    {I_CHOICE, I_POINTPOSN, "Point", "Posn", DEF_IND_SW_WD,
X	&cur_pointposn, NULL, inc_choice, dec_choice, show_pointposn,
X	pointposn_choices, NUM_POINTPOSN_CHOICES, NUM_POINTPOSN_CHOICES,},
X    {I_IVAL, I_ROTNANGLE, "Rotn", "Angle", NARROW_IND_SW_WD,
X	&cur_rotnangle, NULL, inc_rotnangle, dec_rotnangle, show_rotnangle,},
X    {I_IVAL, I_NUMSIDES, "Num", "Sides", NARROW_IND_SW_WD,
X	&cur_numsides, NULL, inc_numsides, dec_numsides, show_numsides,},
X    {I_CHOICE, I_VALIGN, "Vert", "Align", DEF_IND_SW_WD,
X	&cur_valign, NULL, inc_choice, dec_choice, show_valign,
X	valign_choices, NUM_VALIGN_CHOICES, NUM_VALIGN_CHOICES,},
X    {I_CHOICE, I_HALIGN, "Horiz", "Align", DEF_IND_SW_WD,
X	&cur_halign, NULL, inc_choice, dec_choice, show_halign,
X	halign_choices, NUM_HALIGN_CHOICES, NUM_HALIGN_CHOICES,},
X    {I_CHOICE, I_ANGLEGEOM, "Angle", "Geom", DEF_IND_SW_WD,
X	&cur_anglegeom, NULL, inc_choice, dec_choice, show_anglegeom,
X	anglegeom_choices, NUM_ANGLEGEOM_CHOICES, NUM_ANGLEGEOM_CHOICES / 2,},
X    {I_CHOICE, I_FILLSTYLE, "Fill", "Style", DEF_IND_SW_WD,
X	&cur_fillstyle, NULL, darken_fill, lighten_fill, show_fillstyle,
X	fillstyle_choices, NUMFILLPATS + 1, (NUMFILLPATS + 1) / 2},
X    {I_CHOICE, I_COLOR, "Color", "", WIDE_IND_SW_WD,
X	(int *) &cur_color, NULL, next_color, prev_color, show_color,
X	color_choices, NUMCOLORS + 1, (NUMCOLORS + 1) / 2},
X    {I_CHOICE, I_LINKMODE, "Smart", "Links", DEF_IND_SW_WD,
X	&cur_linkmode, NULL, inc_choice, dec_choice, show_linkmode,
X	linkmode_choices, NUM_LINKMODE_CHOICES, NUM_LINKMODE_CHOICES},
X    {I_IVAL, I_LINEWIDTH, "Line", "Width", NARROW_IND_SW_WD,
X	&cur_linewidth, NULL, inc_linewidth, dec_linewidth, show_linewidth,},
X    {I_CHOICE, I_LINESTYLE, "Line", "Style", DEF_IND_SW_WD,
X	&cur_linestyle, NULL, inc_choice, dec_choice, show_linestyle,
X	linestyle_choices, NUM_LINESTYLE_CHOICES, NUM_LINESTYLE_CHOICES,},
X    {I_IVAL, I_BOXRADIUS, "Box", "Curve", DEF_IND_SW_WD,
X	&cur_boxradius, NULL, inc_boxradius, dec_boxradius, show_boxradius,},
X    {I_CHOICE, I_ARROWMODE, "Arrow", "Mode", DEF_IND_SW_WD,
X	&cur_arrowmode, NULL, inc_choice, dec_choice, show_arrowmode,
X	arrowmode_choices, NUM_ARROWMODE_CHOICES, NUM_ARROWMODE_CHOICES,},
X    {I_CHOICE, I_TEXTJUST, "Text", "Just", DEF_IND_SW_WD,
X	&cur_textjust, NULL, inc_choice, dec_choice, show_textjust,
X	textjust_choices, NUM_TEXTJUST_CHOICES, NUM_TEXTJUST_CHOICES,},
X    {I_IVAL, I_FONTSIZE, "Text", "Size", NARROW_IND_SW_WD,
X	&cur_fontsize, NULL, inc_fontsize, dec_fontsize, show_fontsize,},
X    {I_FVAL, I_TEXTSTEP, "Text", "Step", NARROW_IND_SW_WD,
X	NULL, &cur_textstep, inc_textstep, dec_textstep, show_textstep,},
X    {I_IVAL, I_FONT, "Text", "Font", FONT_IND_SW_WD,
X	&cur_ps_font, NULL, inc_font, dec_font, show_font,},
X};
X
X#define		NUM_IND_SW	(sizeof(ind_switches) / sizeof(ind_sw_info))
X
Xstatic Arg	button_args[] =
X{
X     /* 0 */ {XtNlabel, (XtArgVal) "        "},
X     /* 1 */ {XtNwidth, (XtArgVal) 0},
X     /* 2 */ {XtNheight, (XtArgVal) 0},
X     /* 3 */ {XtNresizable, (XtArgVal) False},
X     /* 4 */ {XtNborderWidth, (XtArgVal) 0},
X     /* 5 */ {XtNresize, (XtArgVal) False},	/* keeps buttons from being
X						 * resized when there are not
X						 * a multiple of three of
X						 * them */
X     /* 6 */ {XtNbackgroundPixmap, (XtArgVal) NULL},
X};
X
X/* button selection event handler */
Xstatic void	sel_ind_but();
X
Xstatic XtActionsRec ind_actions[] =
X{
X    {"EnterIndSw", (XtActionProc) draw_mousefun_ind},
X    {"LeaveIndSw", (XtActionProc) clear_mousefun},
X};
X
Xstatic String	ind_translations =
X"<EnterWindow>:EnterIndSw()highlight()\n\
X    <LeaveWindow>:LeaveIndSw()unhighlight()\n";
X
Xinit_ind_panel(tool)
X    TOOL	    tool;
X{
X    register int    i;
X    register ind_sw_info *sw;
X
X    /* does he want to always see ALL of the indicator buttons? */
X    if (appres.ShowAllButtons) {
X	cur_indmask = I_ALL;	/* yes */
X	i = DEF_IND_SW_HT * 2;	/* two rows high when showing all buttons */
X    } else
X	i = DEF_IND_SW_HT;
X
X    FirstArg(XtNwidth, INDPANEL_WD);
X    NextArg(XtNheight, i);
X    NextArg(XtNhSpace, INTERNAL_BW);
X    NextArg(XtNvSpace, INTERNAL_BW);
X    NextArg(XtNresizable, False);
X    NextArg(XtNfromVert, canvas_sw);
X    NextArg(XtNvertDistance, -INTERNAL_BW);
X    NextArg(XtNtop, XtChainBottom);
X    NextArg(XtNbottom, XtChainBottom);
X    NextArg(XtNleft, XtChainLeft);
X    NextArg(XtNright, XtChainLeft);
X    NextArg(XtNborderWidth, 0);
X    if (appres.ShowAllButtons) {
X	NextArg(XtNorientation, XtorientVertical);	/* use two rows */
X    } else {
X	NextArg(XtNorientation, XtorientHorizontal);	/* expand horizontally */
X    }
X    NextArg(XtNmappedWhenManaged, False);
X
X    ind_panel = XtCreateWidget("ind_panel", boxWidgetClass, tool,
X			       Args, ArgCount);
X
X    XtAppAddActions(tool_app, ind_actions, XtNumber(ind_actions));
X
X    for (i = 0; i < NUM_IND_SW; ++i) {
X	sw = &ind_switches[i];
X
X	button_args[1].value = sw->sw_width;
X	button_args[2].value = DEF_IND_SW_HT;
X	sw->widget = XtCreateWidget("button", commandWidgetClass,
X			     ind_panel, button_args, XtNumber(button_args));
X	if (sw->func & cur_indmask)
X	    XtManageChild(sw->widget);
X
X	/* allow left & right buttons */
X	/* (callbacks pass same data for ANY button) */
X	XtAddEventHandler(sw->widget, ButtonReleaseMask, (Boolean) 0,
X			  sel_ind_but, (caddr_t) sw);
X	XtOverrideTranslations(sw->widget,
X			       XtParseTranslationTable(ind_translations));
X    }
X}
X
Xsetup_ind_panel()
X{
X    register int    i;
X    register ind_sw_info *isw;
X    register Display *d = tool_d;
X    register Screen *s = tool_s;
X    register Pixmap p;
X
X    /* get the foreground and background from the indicator widget */
X    /* and create a gc with those values */
X    ind_button_gc = XCreateGC(tool_d, XtWindow(ind_panel), (unsigned long) 0, NULL);
X    FirstArg(XtNforeground, &ind_but_fg);
X    NextArg(XtNbackground, &ind_but_bg);
X    GetValues(ind_switches[0].widget);
X    XSetBackground(tool_d, ind_button_gc, ind_but_bg);
X    XSetForeground(tool_d, ind_button_gc, ind_but_fg);
X    XSetFont(tool_d, ind_button_gc, button_font->fid);
X
X    /* also create gc with fore=background for blanking areas */
X    ind_blank_gc = XCreateGC(tool_d, XtWindow(ind_panel), (unsigned long) 0, NULL);
X    XSetBackground(tool_d, ind_blank_gc, ind_but_bg);
X    XSetForeground(tool_d, ind_blank_gc, ind_but_bg);
X
X    /* create a gc for the color 'palette' */
X    color_gc = XCreateGC(tool_d, XtWindow(ind_panel), (unsigned long) 0, NULL);
X
X    /* initialize the fill style gc and pixmaps */
X    init_fill_pm();
X    init_fill_gc();
X
X    FirstArg(XtNbackgroundPixmap, fillstyle_choices[NUMFILLPATS].blackPM);
X    SetValues(ind_panel);
X
X    for (i = 0; i < NUM_IND_SW; ++i) {
X	isw = &ind_switches[i];
X	if (ind_switches[i].func == I_FILLSTYLE)
X		fill_style_sw = isw;
X
X	p = XCreatePixmap(d, XtWindow(isw->widget), isw->sw_width,
X			  DEF_IND_SW_HT, DefaultDepthOfScreen(s));
X	XFillRectangle(d, p, ind_blank_gc, 0, 0,
X		       isw->sw_width, DEF_IND_SW_HT);
X	XDrawImageString(d, p, ind_button_gc, 3, 12, isw->line1, strlen(isw->line1));
X	XDrawImageString(d, p, ind_button_gc, 3, 25, isw->line2, strlen(isw->line2));
X
X	isw->normalPM = button_args[6].value = (XtArgVal) p;
X	XtSetValues(isw->widget, &button_args[6], 1);
X    }
X
X    XDefineCursor(d, XtWindow(ind_panel), arrow_cursor);
X    update_current_settings();
X
X    FirstArg(XtNmappedWhenManaged, True);
X    SetValues(ind_panel);
X}
X
Xupdate_indpanel(mask)
X    int		    mask;
X{
X    register int    i;
X    register ind_sw_info *isw;
X
X    /* only update current mask if user wants to see relevant ind buttons */
X    if (appres.ShowAllButtons)
X	return;
X
X    cur_indmask = mask;
X    XtUnmanageChild(ind_panel);
X    for (isw = ind_switches, i = 0; i < NUM_IND_SW; isw++, i++) {
X	if (isw->func & cur_indmask) {
X	    XtManageChild(isw->widget);
X	} else {
X	    XtUnmanageChild(isw->widget);
X	}
X    }
X    XtManageChild(ind_panel);
X}
X
X/* come here when a button is pressed in the indicator panel */
X
Xstatic void
Xsel_ind_but(widget, isw, event)
X    Widget	    widget;
X    ind_sw_info	   *isw;
X    XButtonEvent   *event;
X{
X    if (event->button == Button3) {	/* right button */
X	inc_action(isw);
X    } else if (event->button == Button2) {	/* middle button */
X	dec_action(isw);
X    } else {			/* left button */
X	if (isw->func == I_FONT)
X	    popup_fonts(isw);
X	else if (isw->type == I_IVAL || isw->type == I_FVAL)
X	    popup_nval_panel(isw);
X	else if (isw->type == I_CHOICE)
X	    popup_choice_panel(isw);
X    }
X}
X
Xstatic
Xupdate_string_pixmap(isw, buf, xpos)
X    ind_sw_info	   *isw;
X    char	   *buf;
X    int		    xpos;
X{
X    XDrawImageString(tool_d, isw->normalPM, ind_button_gc,
X		     xpos, 18, buf, strlen(buf));
X    /*
X     * Fool the toolkit by changing the background pixmap to 0 then giving it
X     * the modified one again.	Otherwise, it sees that the pixmap ID is not
X     * changed and doesn't actually draw it into the widget window
X     */
X    button_args[6].value = 0;
X    XtSetValues(isw->widget, &button_args[6], 1);
X
X    /* put the pixmap in the widget background */
X    button_args[6].value = isw->normalPM;
X    XtSetValues(isw->widget, &button_args[6], 1);
X}
X
Xstatic
Xupdate_choice_pixmap(isw, mode)
X    ind_sw_info	   *isw;
X    int		    mode;
X{
X    choice_info	   *tmp_choice;
X    int		    i;
X    register Pixmap p;
X
X    /* put the pixmap in the widget background */
X    p = isw->normalPM;
X    tmp_choice = isw->choices;
X    for (i = mode; i > 0; i--, tmp_choice++);
X    XPutImage(tool_d, p, ind_button_gc, tmp_choice->icon, 0, 0, 32, 0, 32, 32);
X    /*
X     * Fool the toolkit by changing the background pixmap to 0 then giving it
X     * the modified one again.	Otherwise, it sees that the pixmap ID is not
X     * changed and doesn't actually draw it into the widget window
X     */
X    button_args[6].value = 0;
X    XtSetValues(isw->widget, &button_args[6], 1);
X    button_args[6].value = p;
X    XtSetValues(isw->widget, &button_args[6], 1);
X}
X
X/********************************************************
X
X	auxiliary functions
X
X********************************************************/
X
Xstatic Widget	choice_popup;
Xstatic ind_sw_info *choice_i;
Xstatic Widget	nval_popup, form, cancel, set, beside, below, newvalue,
X		label;
Xstatic Widget	dash_length, dot_gap;
Xstatic ind_sw_info *nval_i;
X
X
Xstatic void
Xchoice_panel_dismiss()
X{
X    XtDestroyWidget(choice_popup);
X    XtSetSensitive(choice_i->widget, True);
X}
X
Xstatic void
Xchoice_panel_cancel(w, ev)
X    Widget	    w;
X    XButtonEvent   *ev;
X{
X    choice_panel_dismiss();
X}
X
Xstatic void
Xchoice_panel_set(w, sel_choice, ev)
X    Widget	    w;
X    choice_info	   *sel_choice;
X    XButtonEvent   *ev;
X{
X    (*choice_i->i_varadr) = sel_choice->value;
X    show_action(choice_i);
X
X    /* auxiliary info */
X    switch (choice_i->func) {
X    case I_LINESTYLE:
X	/* dash length */
X	cur_dashlength = (float) atof(panel_get_value(dash_length));
X	if (cur_dashlength <= 0.0)
X	    cur_dashlength = DEF_DASHLENGTH;
X	/* dot gap */
X	cur_dotgap = (float) atof(panel_get_value(dot_gap));
X	if (cur_dotgap <= 0.0)
X	    cur_dotgap = DEF_DOTGAP;
X	break;
X    }
X
X    choice_panel_dismiss();
X}
X
Xpopup_choice_panel(isw)
X    ind_sw_info	   *isw;
X{
X    Position	    x_val, y_val;
X    Dimension	    width, height;
X    char	    buf[32];
X    choice_info	   *tmp_choice;
X    Pixmap	    p;
X    Pixel	    form_fg;
X    register int    i;
X
X    choice_i = isw;
X    XtSetSensitive(choice_i->widget, False);
X
X    FirstArg(XtNwidth, &width);
X    NextArg(XtNheight, &height);
X    GetValues(tool);
X    /* position the popup 1/3 in from left and 2/3 down from top */
X    XtTranslateCoords(tool, (Position) (width / 3), (Position) (2 * height / 3),
X		      &x_val, &y_val);
X
X    FirstArg(XtNx, x_val);
X    NextArg(XtNy, y_val);
X    NextArg(XtNresize, False);
X    NextArg(XtNresizable, False);
X    NextArg(XtNtitle, "Xfig: Set indicator panel");
X
X    choice_popup = XtCreatePopupShell("xfig_set_indicator_panel",
X				      transientShellWidgetClass, tool,
X				      Args, ArgCount);
X
X    form = XtCreateManagedWidget("form", formWidgetClass, choice_popup, NULL, 0);
X
X    FirstArg(XtNborderWidth, 0);
X    sprintf(buf, "%s %s", isw->line1, isw->line2);
X    label = XtCreateManagedWidget(buf, labelWidgetClass, form, Args, ArgCount);
X
X    FirstArg(XtNlabel, "cancel");
X    NextArg(XtNfromVert, label);
X    NextArg(XtNresize, False);
X    NextArg(XtNresizable, False);
X    NextArg(XtNheight, 32);
X    NextArg(XtNborderWidth, INTERNAL_BW);
X    cancel = XtCreateManagedWidget("cancel", commandWidgetClass,
X				   form, Args, ArgCount);
X    XtAddEventHandler(cancel, ButtonReleaseMask, (Boolean) 0,
X		      (XtEventHandler)choice_panel_cancel, (XtPointer) NULL);
X
X    tmp_choice = isw->choices;
X
X    for (i = 0; i < isw->numchoices; tmp_choice++, i++) {
X	if (isw->func == I_FILLSTYLE)
X	    p = ((cur_color==BLACK || cur_color==DEFAULT_COLOR ||
X		 (!all_colors_available && cur_color!=WHITE))?
X		fillstyle_choices[i].blackPM :fillstyle_choices[i].normalPM);
X	else if (isw->func == I_COLOR) {
X	    p = NULL;
X	    tmp_choice->value = (i >= NUMCOLORS ? DEFAULT_COLOR : i);
X	} else
X	    p = XCreatePixmapFromBitmapData(tool_d, XtWindow(ind_panel),
X			    tmp_choice->icon->data, tmp_choice->icon->width,
X			   tmp_choice->icon->height, ind_but_fg, ind_but_bg,
X					    DefaultDepthOfScreen(tool_s));
X	if (i % isw->sw_per_row == 0) {
X	    if (i == 0)
X		below = label;
X	    else
X		below = beside;
X	    beside = cancel;
X	}
X	FirstArg(XtNfromVert, below);
X	NextArg(XtNfromHoriz, beside);
X	if (isw->func != I_COLOR) {
X	    NextArg(XtNbackgroundPixmap, p);
X	    NextArg(XtNwidth, tmp_choice->icon->width);
X	    NextArg(XtNheight, tmp_choice->icon->height);
X	} else {		/* Color popup menu */
X	    NextArg(XtNheight, 32);
X	    NextArg(XtNwidth, 64);
X	    if (i < NUMCOLORS && i >= 0) {	/* it's a proper color */
X		if (all_colors_available) {
X		    XColor	    col;
X
X		    col.pixel = appres.color[i];
X		    XQueryColor(tool_d, DefaultColormapOfScreen(tool_s), &col);
X		    if ((0.3 * col.red + 0.59 * col.green + 0.11 * col.blue) < 0.5 * (255 << 8))
X			form_fg = appres.color[WHITE];
X		    else
X			form_fg = appres.color[BLACK];
X		    NextArg(XtNforeground, form_fg);
X		    NextArg(XtNbackground, appres.color[i]);
X		}
X		NextArg(XtNlabel, colorNames[i + 1]);
X	    } else {		/* it's the default color */
X		NextArg(XtNforeground, x_fg_color.pixel);
X		NextArg(XtNlabel, colorNames[0]);
X	    }
X	}
X	NextArg(XtNresize, False);
X	NextArg(XtNresizable, False);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	beside = XtCreateManagedWidget(" ", commandWidgetClass,
X				       form, Args, ArgCount);
X	XtAddEventHandler(beside, ButtonReleaseMask, (Boolean) 0,
X			  (XtEventHandler)choice_panel_set, (caddr_t) tmp_choice);
X    }
X
X    /* auxiliary info */
X    switch (isw->func) {
X    case I_LINESTYLE:
X	/* dash length */
X	FirstArg(XtNfromVert, beside);
X	NextArg(XtNborderWidth, 0);
X	NextArg(XtNlabel, "Default dash length =");
X	label = XtCreateManagedWidget("default_dash_length",
X				    labelWidgetClass, form, Args, ArgCount);
X	sprintf(buf, "%1.1f", cur_dashlength);
X	FirstArg(XtNfromVert, beside);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	NextArg(XtNfromHoriz, label);
X	NextArg(XtNstring, buf);
X	NextArg(XtNinsertPosition, strlen(buf));
X	NextArg(XtNeditType, "append");
X	NextArg(XtNwidth, 40);
X	dash_length = XtCreateManagedWidget(buf, asciiTextWidgetClass,
X					    form, Args, ArgCount);
X	/* dot gap */
X	FirstArg(XtNfromVert, dash_length);
X	NextArg(XtNborderWidth, 0);
X	NextArg(XtNlabel, "    Default dot gap =");
X	label = XtCreateManagedWidget("default_dot_gap",
X				    labelWidgetClass, form, Args, ArgCount);
X	sprintf(buf, "%1.1f", cur_dotgap);
X	FirstArg(XtNfromVert, dash_length);
X	NextArg(XtNborderWidth, INTERNAL_BW);
X	NextArg(XtNfromHoriz, label);
X	NextArg(XtNstring, buf);
X	NextArg(XtNinsertPosition, strlen(buf));
X	NextArg(XtNeditType, "append");
X	NextArg(XtNwidth, 40);
X	dot_gap = XtCreateManagedWidget(buf, asciiTextWidgetClass,
X					form, Args, ArgCount);
X	break;
X    }
X
X    XtPopup(choice_popup, XtGrabExclusive);
X}
X
Xstatic void
Xnval_panel_dismiss()
X{
X    XtDestroyWidget(nval_popup);
X    XtSetSensitive(nval_i->widget, True);
X}
X
Xstatic void
Xnval_panel_cancel(w, ev)
X    Widget	    w;
X    XButtonEvent   *ev;
X{
X    nval_panel_dismiss();
X}
X
Xstatic void
Xnval_panel_set(w, ev)
X    Widget	    w;
X    XButtonEvent   *ev;
X{
X    int		    new_i_value;
X    float	    new_f_value;
X
X
X    if (nval_i->type == I_IVAL)
X	    {
X	    new_i_value = atoi(panel_get_value(newvalue));
X	    (*nval_i->i_varadr) = new_i_value;
X	    }
X    else
X	    {
X	    new_f_value = atof(panel_get_value(newvalue));
X	    (*nval_i->f_varadr) = new_f_value;
X	    }
X    nval_panel_dismiss();
X    show_action(nval_i);
X}
X
Xpopup_nval_panel(isw)
X    ind_sw_info	   *isw;
X{
X    Position	    x_val, y_val;
X    Dimension	    width, height;
X    char	    buf[32];
X
X    nval_i = isw;
X    XtSetSensitive(nval_i->widget, False);
X
X    FirstArg(XtNwidth, &width);
X    NextArg(XtNheight, &height);
X    GetValues(tool);
X    /* position the popup 1/3 in from left and 2/3 down from top */
X    XtTranslateCoords(tool, (Position) (width / 3), (Position) (2 * height / 3),
X		      &x_val, &y_val);
X
X    FirstArg(XtNx, x_val);
X    NextArg(XtNy, y_val);
X    NextArg(XtNwidth, 240);
X
X    nval_popup = XtCreatePopupShell("xfig_set_indicator_panel",
X				    transientShellWidgetClass, tool,
X				    Args, ArgCount);
X
X    form = XtCreateManagedWidget("form", formWidgetClass, nval_popup, NULL, 0);
X
X    FirstArg(XtNborderWidth, 0);
X    sprintf(buf, "%s %s", isw->line1, isw->line2);
X    label = XtCreateManagedWidget(buf, labelWidgetClass, form, Args, ArgCount);
X
X    FirstArg(XtNfromVert, label);
X    NextArg(XtNborderWidth, 0);
X    NextArg(XtNlabel, "Value =");
X    newvalue = XtCreateManagedWidget("value", labelWidgetClass,
X				     form, Args, ArgCount);
X    /* int or float? */
X    if (isw->type == I_IVAL)
X	    sprintf(buf, "%d", (*isw->i_varadr));
X    else
X	    sprintf(buf, "%4.1f", (*isw->f_varadr));
X    FirstArg(XtNfromVert, label);
X    NextArg(XtNborderWidth, INTERNAL_BW);
X    NextArg(XtNfromHoriz, newvalue);
X    NextArg(XtNstring, buf);
X    NextArg(XtNinsertPosition, strlen(buf));
X    NextArg(XtNeditType, "append");
X    NextArg(XtNwidth, 40);
X    newvalue = XtCreateManagedWidget(buf, asciiTextWidgetClass,
X				     form, Args, ArgCount);
X
X    /* add translation and action to set value on carriage return */
X    XtAppAddActions(tool_app, set_actions, XtNumber(set_actions));
X    XtOverrideTranslations(newvalue, XtParseTranslationTable(set_translations));
X
X    FirstArg(XtNlabel, "cancel");
X    NextArg(XtNfromVert, newvalue);
X    NextArg(XtNborderWidth, INTERNAL_BW);
X    cancel = XtCreateManagedWidget("cancel", commandWidgetClass,
X				   form, Args, ArgCount);
X    XtAddEventHandler(cancel, ButtonReleaseMask, (Boolean) 0,
X		      (XtEventHandler)nval_panel_cancel, (XtPointer) NULL);
X
X    FirstArg(XtNlabel, "set");
X    NextArg(XtNfromVert, newvalue);
X    NextArg(XtNfromHoriz, cancel);
X    NextArg(XtNborderWidth, INTERNAL_BW);
X    set = XtCreateManagedWidget("set", commandWidgetClass,
X				form, Args, ArgCount);
X    XtAddEventHandler(set, ButtonReleaseMask, (Boolean) 0,
X		      (XtEventHandler)nval_panel_set, (XtPointer) NULL);
X
X    XtPopup(nval_popup, XtGrabExclusive);
X}
X
X/********************************************************
X
X	commands to change indicator settings
X
X********************************************************/
X
Xupdate_current_settings()
X{
X    int		    i;
X    ind_sw_info	   *isw;
X
X    for (i = 0; i < NUM_IND_SW; ++i) {
X	isw = &ind_switches[i];
X	show_action(isw);
X    }
X}
X
Xstatic
Xdec_choice(sw)
X    ind_sw_info	   *sw;
X{
X    if (--(*sw->i_varadr) < 0)
X	(*sw->i_varadr) = sw->numchoices - 1;
X    show_action(sw);
X}
X
Xstatic
Xinc_choice(sw)
X    ind_sw_info	   *sw;
X{
X    if (++(*sw->i_varadr) > sw->numchoices - 1)
X	(*sw->i_varadr) = 0;
X    show_action(sw);
X}
X
X/* ARROW MODE		 */
X
Xstatic
Xshow_arrowmode(sw)
X    ind_sw_info	   *sw;
X{
X    update_choice_pixmap(sw, cur_arrowmode);
X    switch (cur_arrowmode) {
X    case L_NOARROWS:
X	autobackwardarrow_mode = 0;
X	autoforwardarrow_mode = 0;
X	put_msg("NO ARROWS");
X	break;
X    case L_FARROWS:
X	autobackwardarrow_mode = 0;
X	autoforwardarrow_mode = 1;
X	put_msg("Auto FORWARD ARROWS (for ARC, POLYLINE and SPLINE)");
X	break;
X    case L_FBARROWS:
X	autobackwardarrow_mode = 1;
X	autoforwardarrow_mode = 1;
X	put_msg("Auto FORWARD and BACKWARD ARROWS (for ARC, POLYLINE and SPLINE)");
X	break;
X    case L_BARROWS:
X	autobackwardarrow_mode = 1;
X	autoforwardarrow_mode = 0;
X	put_msg("Auto BACKWARD ARROWS (for ARC, POLYLINE and SPLINE)");
X	break;
X    }
X}
X
X/* LINE WIDTH		 */
X
X#define MAXLINEWIDTH 200
X
Xstatic
Xdec_linewidth(sw)
X    ind_sw_info	   *sw;
X{
X    --cur_linewidth;
X    show_linewidth(sw);
X}
X
Xstatic
Xinc_linewidth(sw)
X    ind_sw_info	   *sw;
X{
X    ++cur_linewidth;
X    show_linewidth(sw);
X}
X
Xstatic
Xshow_linewidth(sw)
X    ind_sw_info	   *sw;
X{
X    if (cur_linewidth > MAXLINEWIDTH)
X	cur_linewidth = MAXLINEWIDTH;
X    else if (cur_linewidth < 0)
X	cur_linewidth = 0;
X
X    /* erase by drawing wide, inverted (white) line */
X    pw_vector(sw->normalPM, DEF_IND_SW_WD / 2 + 2, DEF_IND_SW_HT / 2,
X	      sw->sw_width - 2, DEF_IND_SW_HT / 2, ERASE,
X	      DEF_IND_SW_HT, PANEL_LINE, 0.0, DEFAULT_COLOR);
X    /* draw current line thickness into pixmap */
X    if (cur_linewidth > 0)	/* don't draw line for zero-thickness */
X	pw_vector(sw->normalPM, DEF_IND_SW_WD / 2 + 2, DEF_IND_SW_HT / 2,
X		  sw->sw_width - 2, DEF_IND_SW_HT / 2, PAINT,
X		  cur_linewidth, PANEL_LINE, 0.0, DEFAULT_COLOR);
X
X    /*
X     * Fool the toolkit by changing the background pixmap to 0 then giving it
X     * the modified one again.	Otherwise, it sees that the pixmap ID is not
X     * changed and doesn't actually draw it into the widget window
X     */
X    button_args[6].value = 0;
X    XtSetValues(sw->widget, &button_args[6], 1);
X    /* put the pixmap in the widget background */
X    button_args[6].value = (XtArgVal) sw->normalPM;
X    XtSetValues(sw->widget, &button_args[6], 1);
X    put_msg("LINE Thickness = %d", cur_linewidth);
X}
X
X/* ANGLE GEOMETRY		 */
X
Xstatic
Xshow_anglegeom(sw)
X    ind_sw_info	   *sw;
X{
X    update_choice_pixmap(sw, cur_anglegeom);
X    switch (cur_anglegeom) {
X    case L_UNCONSTRAINED:
X	manhattan_mode = 0;
X	mountain_mode = 0;
X	latexline_mode = 0;
X	latexarrow_mode = 0;
X	put_msg("UNCONSTRAINED geometry (for POLYLINE and SPLINE)");
X	break;
X    case L_MOUNTHATTAN:
X	mountain_mode = 1;
X	manhattan_mode = 1;
X	latexline_mode = 0;
X	latexarrow_mode = 0;
X	put_msg("MOUNT-HATTAN geometry (for POLYLINE and SPLINE)");
X	break;
X    case L_MANHATTAN:
X	manhattan_mode = 1;
X	mountain_mode = 0;
X	latexline_mode = 0;
X	latexarrow_mode = 0;
X	put_msg("MANHATTAN geometry (for POLYLINE and SPLINE)");
X	break;
X    case L_MOUNTAIN:
X	mountain_mode = 1;
X	manhattan_mode = 0;
X	latexline_mode = 0;
X	latexarrow_mode = 0;
X	put_msg("MOUNTAIN geometry (for POLYLINE and SPLINE)");
X	break;
X    case L_LATEXLINE:
X	latexline_mode = 1;
X	manhattan_mode = 0;
X	mountain_mode = 0;
X	latexarrow_mode = 0;
X	put_msg("LATEX LINE geometry: allow only LaTeX line slopes");
X	break;
X    case L_LATEXARROW:
X	latexarrow_mode = 1;
X	manhattan_mode = 0;
X	mountain_mode = 0;
X	latexline_mode = 0;
X	put_msg("LATEX ARROW geometry: allow only LaTeX arrow slopes");
X	break;
X    }
X}
X
X/* LINE STYLE		 */
X
Xstatic
Xshow_linestyle(sw)
X    ind_sw_info	   *sw;
X{
X    update_choice_pixmap(sw, cur_linestyle);
X    switch (cur_linestyle) {
X    case SOLID_LINE:
X	cur_styleval = 0.0;
X	put_msg("SOLID LINE STYLE (for BOX, POLYGON and POLYLINE)");
X	break;
X    case DASH_LINE:
X	cur_styleval = cur_dashlength;
X	put_msg("DASH LINE STYLE (for BOX, POLYGON and POLYLINE)");
X	break;
X    case DOTTED_LINE:
X	cur_styleval = cur_dotgap;
X	put_msg("DOTTED LINE STYLE (for BOX, POLYGON and POLYLINE)");
X	break;
X    }
X}
X
X/* VERTICAL ALIGNMENT	 */
X
Xstatic
Xshow_valign(sw)
X    ind_sw_info	   *sw;
X{
X    update_choice_pixmap(sw, cur_valign);
X    switch (cur_valign) {
X    case NONE:
X	put_msg("No vertical alignment");
X	break;
X    case TOP:
X	put_msg("Vertically align to TOP");
X	break;
X    case CENTER:
X	put_msg("Center vertically when aligning");
X	break;
X    case BOTTOM:
X	put_msg("Vertically align to BOTTOM");
X	break;
X    }
X}
X
X/* HORIZ ALIGNMENT	 */
X
Xstatic
Xshow_halign(sw)
X    ind_sw_info	   *sw;
X{
X    update_choice_pixmap(sw, cur_halign);
X    switch (cur_halign) {
X    case NONE:
X	put_msg("No horizontal alignment");
X	break;
X    case LEFT:
X	put_msg("Horizontally align to LEFT");
X	break;
X    case CENTER:
X	put_msg("Center horizontally when aligning");
X	break;
X    case RIGHT:
X	put_msg("Horizontally align to RIGHT");
X	break;
X    }
X}
X
X/* GRID MODE	 */
X
Xstatic
Xshow_gridmode(sw)
X    ind_sw_info	   *sw;
X{
X    static int	    prev_gridmode = -1;
X
X    update_choice_pixmap(sw, cur_gridmode);
X    switch (cur_gridmode) {
X    case GRID_0:
X	put_msg("No grid");
X	break;
X    case GRID_1:
X	put_msg("Small grid");
X	break;
X    case GRID_2:
X	put_msg("Large grid");
X	break;
X    }
X    if (cur_gridmode != prev_gridmode)
X	setup_grid(cur_gridmode);
X    prev_gridmode = cur_gridmode;
X}
X
X/* POINT POSITION	 */
X
Xstatic
Xshow_pointposn(sw)
X    ind_sw_info	   *sw;
X{
X    char	    buf[80];
X
X    update_choice_pixmap(sw, cur_pointposn);
X    switch (cur_pointposn) {
X    case P_ANY:
X	put_msg("Arbitrary Positioning of Points");
X	break;
X    case P_MAGNET:
X    case P_GRID1:
X    case P_GRID2:
X	sprintf(buf,
X	  "MAGNET MODE: entered points rounded to the nearest %s increment",
X		grid_name[cur_pointposn]);
X	put_msg(buf);
X	break;
X    }
X}
X
X/* SMART LINK MODE */
X
Xstatic
Xshow_linkmode(sw)
X    ind_sw_info	   *sw;
X{
X    update_choice_pixmap(sw, cur_linkmode);
X    switch (cur_linkmode) {
X    case SMART_OFF:
X	put_msg("Do not adjust links automatically");
X	break;
X    case SMART_MOVE:
X	put_msg("Adjust links automatically by moving endpoint");
X	break;
X    case SMART_SLIDE:
X	put_msg("Adjust links automatically by sliding endlink");
X	break;
X    }
X}
X
X/* TEXT JUSTIFICATION	 */
X
Xstatic
Xshow_textjust(sw)
X    ind_sw_info	   *sw;
X{
X    update_choice_pixmap(sw, cur_textjust);
X    switch (cur_textjust) {
X    case T_LEFT_JUSTIFIED:
X	put_msg("Left justify text");
X	break;
X    case T_CENTER_JUSTIFIED:
X	put_msg("Center text");
X	break;
X    case T_RIGHT_JUSTIFIED:
X	put_msg("Right justify text");
X	break;
X    }
X}
X
X/* BOX RADIUS	 */
X
Xstatic
Xdec_boxradius(sw)
X    ind_sw_info	   *sw;
X{
X    --cur_boxradius;
X    show_boxradius(sw);
X}
X
Xstatic
Xinc_boxradius(sw)
X    ind_sw_info	   *sw;
X{
X    ++cur_boxradius;
X    show_boxradius(sw);
X}
X
X#define MAXRADIUS 30
Xstatic
Xshow_boxradius(sw)
X    ind_sw_info	   *sw;
X{
X    if (cur_boxradius > MAXRADIUS)
X	cur_boxradius = MAXRADIUS;
X    else if (cur_boxradius < 3)
X	cur_boxradius = 3;
X    /* erase by drawing wide, inverted (white) line */
X    pw_vector(sw->normalPM, DEF_IND_SW_WD / 2, DEF_IND_SW_HT / 2,
X	      DEF_IND_SW_WD, DEF_IND_SW_HT / 2, ERASE,
X	      DEF_IND_SW_HT, PANEL_LINE, 0.0, DEFAULT_COLOR);
X    /* draw current radius into pixmap */
X    curve(sw->normalPM, 0, cur_boxradius, -cur_boxradius, 0, 1,
X	  cur_boxradius, cur_boxradius, DEF_IND_SW_WD - 2, DEF_IND_SW_HT - 2,
X	  PAINT, 1, PANEL_LINE, 0.0, 0, DEFAULT_COLOR);
X
X    /*
X     * Fool the toolkit by changing the background pixmap to 0 then giving it
X     * the modified one again.	Otherwise, it sees that the pixmap ID is not
X     * changed and doesn't actually draw it into the widget window
X     */
X    button_args[6].value = 0;
X    XtSetValues(sw->widget, &button_args[6], 1);
X    /* put the pixmap in the widget background */
X    button_args[6].value = (XtArgVal) sw->normalPM;
X    XtSetValues(sw->widget, &button_args[6], 1);
X    put_msg("ROUNDED-CORNER BOX Radius = %d", cur_boxradius);
X}
X
X/* FILL STYLE */
X
Xstatic
Xdarken_fill(sw)
X    ind_sw_info	   *sw;
X{
X    if (++cur_fillstyle > NUMFILLPATS)
X	cur_fillstyle = 0;
X    show_fillstyle(sw);
X}
X
Xstatic
Xlighten_fill(sw)
X    ind_sw_info	   *sw;
X{
X    if (--cur_fillstyle < 0)
X	cur_fillstyle = NUMFILLPATS;
X    show_fillstyle(sw);
X}
X
Xstatic
Xshow_fillstyle(sw)
X    ind_sw_info	   *sw;
X{
X    if (cur_fillstyle == 0) {
X	XCopyArea(tool_d, ((cur_color==BLACK ||
X		   (cur_color==DEFAULT_COLOR && x_fg_color.pixel==appres.color[BLACK]) ||
X			(!all_colors_available && cur_color!=WHITE))? 
X			fillstyle_choices[0].blackPM: fillstyle_choices[0].normalPM),
X			sw->normalPM,
X			ind_button_gc, 0, 0, 32, 32, 32, 0);
X	put_msg("NO-FILL MODE");
X    } else {
X	/* put the pixmap in the widget background */
X	XCopyArea(tool_d, ((cur_color==BLACK ||
X		   (cur_color==DEFAULT_COLOR && x_fg_color.pixel==appres.color[BLACK]) ||
X			(!all_colors_available && cur_color!=WHITE))? 
X				fillstyle_choices[cur_fillstyle].blackPM:
X				fillstyle_choices[cur_fillstyle].normalPM),
X			sw->normalPM,
X			ind_button_gc, 0, 0, 26, 24, 35, 4);
X	put_msg("FILL MODE (black density/color intensity = %d%%)",
X		((cur_fillstyle - 1) * 100) / (NUMFILLPATS - 1));
X    }
X    button_args[6].value = 0;
X    XtSetValues(sw->widget, &button_args[6], 1);
X    button_args[6].value = (XtArgVal) sw->normalPM;
X    XtSetValues(sw->widget, &button_args[6], 1);
X}
X
X/* COLOR */
X
Xstatic
Xnext_color(sw)
X    ind_sw_info	   *sw;
X{
X    if (++cur_color >= NUMCOLORS)
X	cur_color = DEFAULT_COLOR;
X    show_color(sw);
X}
X
Xstatic
Xprev_color(sw)
X    ind_sw_info	   *sw;
X{
X    if (--cur_color < DEFAULT_COLOR)
X	cur_color = NUMCOLORS - 1;
X    show_color(sw);
X}
X
Xstatic
Xshow_color(sw)
X    ind_sw_info	   *sw;
X{
X    int		    color;
X
X    if (cur_color < 0 || cur_color >= NUMCOLORS) {
X	cur_color == DEFAULT_COLOR;
X	color = x_fg_color.pixel;
X    } else
X	color = all_colors_available ? appres.color[cur_color] : x_fg_color.pixel;
X
X    put_msg("Color set to %s", colorNames[cur_color + 1]);
X    XSetForeground(tool_d, color_gc, color);
X    /* now fill the color rectangle with the new color */
X    XFillRectangle(tool_d, sw->normalPM, color_gc, sw->sw_width - 29, 4, 26, 24);
X    /*
X     * write the widget background over old color name before writing new
X     * name
X     */
X    /* first set the foreground color to the background for the fill */
X    XSetForeground(tool_d, ind_button_gc, ind_but_bg);
X    XFillRectangle(tool_d, sw->normalPM, ind_button_gc, 0, DEF_IND_SW_HT / 2,
X		   sw->sw_width - 29, DEF_IND_SW_HT / 2);
X    /* now restore the foreground in the gc */
X    XSetForeground(tool_d, ind_button_gc, ind_but_fg);
X    XDrawImageString(tool_d, sw->normalPM, ind_button_gc, 3, 25,
X	      colorNames[cur_color + 1], strlen(colorNames[cur_color + 1]));
X    button_args[6].value = 0;
X    XtSetValues(sw->widget, &button_args[6], 1);
X    button_args[6].value = (XtArgVal) sw->normalPM;
X    XtSetValues(sw->widget, &button_args[6], 1);
X    show_fillstyle(fill_style_sw);
X}
X
X/* FONT */
X
Xstatic
Xinc_font(sw)
X    ind_sw_info	   *sw;
X{
X    if (using_ps)
X	cur_ps_font++;
X    else
X	cur_latex_font++;
X    show_font(sw);
X}
X
Xstatic
Xdec_font(sw)
X    ind_sw_info	   *sw;
X{
X    if (using_ps)
X	cur_ps_font--;
X    else
X	cur_latex_font--;
X    show_font(sw);
X}
X
Xstatic
Xshow_font(sw)
X    ind_sw_info	   *sw;
X{
X    if (using_ps) {
X	if (cur_ps_font >= NUM_PS_FONTS)
X	    cur_ps_font = DEFAULT;
X	else if (cur_ps_font < DEFAULT)
X	    cur_ps_font = NUM_PS_FONTS - 1;
X    } else {
X	if (cur_latex_font >= NUM_LATEX_FONTS)
X	    cur_latex_font = 0;
X	else if (cur_latex_font < 0)
X	    cur_latex_font = NUM_LATEX_FONTS - 1;
X    }
X
X    /* erase larger fontpane bits if we switched to smaller (Latex) */
X    XFillRectangle(tool_d, sw->normalPM, ind_blank_gc, 0, 0,
X	       32 + max2(PS_FONTPANE_WD, LATEX_FONTPANE_WD), DEF_IND_SW_HT);
X    /* and redraw info */
X    XDrawImageString(tool_d, sw->normalPM, ind_button_gc, 3, 12, sw->line1,
X		     strlen(sw->line1));
X    XDrawImageString(tool_d, sw->normalPM, ind_button_gc, 3, 25, sw->line2,
X		     strlen(sw->line2));
X
X    XCopyArea(tool_d, using_ps ? psfont_menu_bitmaps[cur_ps_font + 1] :
X	      latexfont_menu_bitmaps[cur_latex_font],
X	      sw->normalPM, ind_button_gc, 0, 0,
X	      using_ps ? PS_FONTPANE_WD : LATEX_FONTPANE_WD,
X	      using_ps ? PS_FONTPANE_HT : LATEX_FONTPANE_HT,
X	  using_ps ? 32 : 32 + (PS_FONTPANE_WD - LATEX_FONTPANE_WD) / 2, 6);
X
X    button_args[6].value = 0;
X    XtSetValues(sw->widget, &button_args[6], 1);
X    /* put the pixmap in the widget background */
X    button_args[6].value = (XtArgVal) sw->normalPM;
X    XtSetValues(sw->widget, &button_args[6], 1);
X    put_msg("Font: %s", using_ps ? ps_fontinfo[cur_ps_font + 1].name :
X	    latex_fontinfo[cur_latex_font].name);
X}
X
X/* popup menu of printer fonts */
X
Xstatic int	psflag;
Xstatic ind_sw_info *return_sw;
X
Xint		show_font_return();
X
Xstatic
Xpopup_fonts(sw)
X    ind_sw_info	   *sw;
X{
X    return_sw = sw;
X    psflag = using_ps ? 1 : 0;
X    fontpane_popup(&cur_ps_font, &cur_latex_font, &psflag,
X		   show_font_return, sw->widget);
X}
X
Xshow_font_return(w)
X    Widget	    w;
X{
X    if (psflag)
X	cur_textflags = cur_textflags | PSFONT_TEXT;
X    else
X	cur_textflags = cur_textflags & (~PSFONT_TEXT);
X    show_font(return_sw);
X}
X
X/* increase font size */
X
Xstatic
Xinc_fontsize(sw)
X    ind_sw_info	   *sw;
X{
X    if (cur_fontsize >= 100) {
X	cur_fontsize = (cur_fontsize / 10) * 10;	/* round first */
X	cur_fontsize += 10;
X    } else if (cur_fontsize >= 50) {
X	cur_fontsize = (cur_fontsize / 5) * 5;
X	cur_fontsize += 5;
X    } else if (cur_fontsize >= 20) {
X	cur_fontsize = (cur_fontsize / 2) * 2;
X	cur_fontsize += 2;
X    } else
X	cur_fontsize++;
X    show_fontsize(sw);
X}
X
X
X/* decrease font size */
X
Xstatic
Xdec_fontsize(sw)
X    ind_sw_info	   *sw;
X{
X    if (cur_fontsize > 100) {
X	cur_fontsize = (cur_fontsize / 10) * 10;	/* round first */
X	cur_fontsize -= 10;
X    } else if (cur_fontsize > 50) {
X	cur_fontsize = (cur_fontsize / 5) * 5;
X	cur_fontsize -= 5;
X    } else if (cur_fontsize > 20) {
X	cur_fontsize = (cur_fontsize / 2) * 2;
X	cur_fontsize -= 2;
X    } else if (cur_fontsize > 4)
X	cur_fontsize--;
X    show_fontsize(sw);
X}
X
Xstatic
Xshow_fontsize(sw)
X    ind_sw_info	   *sw;
X{
X    if (cur_fontsize < 4)
X	cur_fontsize = 4;
X    else if (cur_fontsize > 1000)
X	cur_fontsize = 1000;
X
X    put_msg("Font size %d", cur_fontsize);
X    /* write the font size in the background pixmap */
X    indbuf[0] = indbuf[1] = indbuf[2] = indbuf[3] = indbuf[4] = '\0';
X    sprintf(indbuf, "%4d", cur_fontsize);
X    update_string_pixmap(sw, indbuf, sw->sw_width - 28);
X}
X
Xstatic
Xinc_rotnangle(sw)
X    ind_sw_info	   *sw;
X{
X    if (cur_rotnangle < 30 || cur_rotnangle >= 120)
X	cur_rotnangle = 30;
X    else if (cur_rotnangle < 45)
X	cur_rotnangle = 45;
X    else if (cur_rotnangle < 60)
X	cur_rotnangle = 60;
X    else if (cur_rotnangle < 90)
X	cur_rotnangle = 90;
X    else if (cur_rotnangle < 120)
X	cur_rotnangle = 120;
X    show_rotnangle(sw);
X}
X
Xstatic
Xdec_rotnangle(sw)
X    ind_sw_info	   *sw;
X{
X    if (cur_rotnangle > 120 || cur_rotnangle <= 30)
X	cur_rotnangle = 120;
X    else if (cur_rotnangle > 90)
X	cur_rotnangle = 90;
X    else if (cur_rotnangle > 60)
X	cur_rotnangle = 60;
X    else if (cur_rotnangle > 45)
X	cur_rotnangle = 45;
X    else if (cur_rotnangle > 30)
X	cur_rotnangle = 30;
X    show_rotnangle(sw);
X}
X
Xstatic
Xshow_rotnangle(sw)
X    ind_sw_info	   *sw;
X{
X    if (cur_rotnangle < 1)
X	cur_rotnangle = 1;
X    else if (cur_rotnangle > 180)
X	cur_rotnangle = 180;
X
X    put_msg("Angle of rotation %d", cur_rotnangle);
X    if (cur_rotnangle == old_rotnangle)
X	return;
X
X    /* write the font size in the background pixmap */
X    indbuf[0] = indbuf[1] = indbuf[2] = indbuf[3] = indbuf[4] = '\0';
X    sprintf(indbuf, "%3d", cur_rotnangle);
X    update_string_pixmap(sw, indbuf, sw->sw_width - 22);
X
X    /* change markers if we changed to or from 90 degrees (except at start) */
X    if (old_rotnangle != -1) {
X	if (cur_rotnangle == 90)
X	    update_markers(M_ALL);
X	else if (old_rotnangle == 90)
X	    update_markers(M_ROTATE_ANGLE);
X    }
X    old_rotnangle = cur_rotnangle;
X}
X
X/* NUMSIDES */
X
Xstatic
Xinc_numsides(sw)
X    ind_sw_info	   *sw;
X{
X    cur_numsides++;
X    show_numsides(sw);
X}
X
Xstatic
Xdec_numsides(sw)
X    ind_sw_info	   *sw;
X{
X    cur_numsides--;
X    show_numsides(sw);
X}
X
Xstatic
Xshow_numsides(sw)
X    ind_sw_info	   *sw;
X{
X    if (cur_numsides < 3)
X	cur_numsides = 3;
X    else if (cur_numsides > 99)
X	cur_numsides = 99;
X
X    put_msg("Number of sides %2d", cur_numsides);
X    /* write the font size in the background pixmap */
X    indbuf[0] = indbuf[1] = indbuf[2] = indbuf[3] = indbuf[4] = '\0';
X    sprintf(indbuf, "%2d", cur_numsides);
X    update_string_pixmap(sw, indbuf, sw->sw_width - 18);
X}
X
X/* ZOOM */
X
Xstatic
Xinc_zoom(sw)
X    ind_sw_info	   *sw;
X{
X    zoomscale++;
X    show_zoom(sw);
X}
X
Xstatic
Xdec_zoom(sw)
X    ind_sw_info	   *sw;
X{
X    zoomscale--;
X    show_zoom(sw);
X}
X
Xshow_zoom(sw)
X    ind_sw_info	   *sw;
X{
X    if (zoomscale < 1)
X	zoomscale = 1;
X    else if (zoomscale > 10)
X	zoomscale = 10;
X
X    put_msg("Zoom scale %2d", zoomscale);
X    if (zoomscale == old_zoomscale)
X	return;
X
X    /* write the font size in the background pixmap */
X    indbuf[0] = indbuf[1] = indbuf[2] = indbuf[3] = indbuf[4] = '\0';
X    sprintf(indbuf, "%2d", zoomscale);
X    update_string_pixmap(sw, indbuf, sw->sw_width - 18);
X
X    /* fix up the rulers and grid */
X    reset_rulers();
X    redisplay_rulers();
X    setup_grid(cur_gridmode);
X    old_zoomscale = zoomscale;
X}
X
X/* TEXTSTEP */
X
Xstatic
Xinc_textstep(sw)
X    ind_sw_info	   *sw;
X{
X    if (cur_textstep >= 10.0) {
X	cur_textstep = (int) cur_textstep;	/* round first */
X	cur_textstep += 1.0;
X    } else if (cur_textstep >= 5.0) {
X	cur_textstep = ((int)(cur_textstep*2.0+0.01))/2.0;
X	cur_textstep += 0.5;
X    } else if (cur_textstep >= 2.0) {
X	cur_textstep = ((int)(cur_textstep*5.0+0.01))/5.0;
X	cur_textstep += 0.2;
X    } else
X	cur_textstep += 0.1;
X    show_textstep(sw);
X}
X
Xstatic
Xdec_textstep(sw)
X    ind_sw_info	   *sw;
X{
X    if (cur_textstep > 10.0) {
X	cur_textstep = (int)cur_textstep;	/* round first */
X	cur_textstep -= 1.0;
X    } else if (cur_textstep > 5.0) {
X	cur_textstep = ((int)(cur_textstep*2.0+0.01))/2.0;
X	cur_textstep -= 0.5;
X    } else if (cur_textstep > 2.0) {
X	cur_textstep = ((int)(cur_textstep*5.0+0.01))/5.0;
X	cur_textstep -= 0.2;
X    } else if (cur_textstep > 0.4)
X	cur_textstep -= 0.1;
X    show_textstep(sw);
X}
X
X/* could make this more generic - but a copy will do for font set JNT */
Xstatic
Xshow_textstep(sw)
X    ind_sw_info	   *sw;
X{
X    if (cur_textstep < 0)
X	cur_textstep = 0;
X    else if (cur_textstep > 99.0)
X	cur_textstep = 99.0;
X
X    put_fmsg("Font step %.1f", cur_textstep);
X    /* write the font size in the background pixmap */
X    indbuf[0] = indbuf[1] = indbuf[2] = indbuf[3] = indbuf[4] = '\0';
X    sprintf(indbuf, "%4.1f", cur_textstep);
X    update_string_pixmap(sw, indbuf, sw->sw_width - 28);
X}
END_OF_FILE
if test 43799 -ne `wc -c <'w_indpanel.c'`; then
    echo shar: \"'w_indpanel.c'\" unpacked with wrong size!
fi
# end of 'w_indpanel.c'
fi
echo shar: End of archive 1 \(of 25\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 25 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Molecular Simulations, Inc.             mail: dcmartin@msi.com
796 N. Pastoria Avenue                  uucp: uunet!dcmartin
Sunnyvale, California 94086             at&t: 408/522-9236
