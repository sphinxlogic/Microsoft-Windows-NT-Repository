Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: wjames@Jupiter.SAIC.Com (Bill James x6167)
Newsgroups: comp.sources.x
Subject: v16i040: engarde - an X/MOTIF strategy game, Part01/02
Message-ID: <csx-16i040-engarde@uunet.UU.NET>
Date: 5 Feb 92 14:57:27 GMT
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1709
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: Bill James x6167 <wjames@Jupiter.SAIC.Com>
Posting-number: Volume 16, Issue 40
Archive-name: engarde/part01

# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
#		"End of archive 1 (of 2)."
# Contents:  README bitmaps.h board.c engarde.c help.h menus.c menus.h
#   xboard.c
# Wrapped by dcmartin@fascet on Fri Jan 24 08:36:43 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(2884 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X			Engarde v1.0
X                           by Bill James, 1992
X-----------------------------------------------------------------------
X
XThis game was written in C, compiled by the SUN C compiler (cc), and
Xuses X11R4 and OSF/MOTIF v1.1 function calls.  The current list of
Xarchitectures under which it has been run are:
X
XSun SparcStation (1,2,SLC,ELC)
XHewlett-Packard Series 9000/300
XHewlett-Packard Apollo Series 700
X
X
XSome lines you may want to add to your .Xdefaults are:
X
XEnGarde.geometry:	700x500+100+100
XEnGarde*Menu*fontList: -adobe-helvetica-bold-o-normal--17-120-100-100-p-92-iso8859-1
XEnGarde*Message.fontList: -adobe-new century schoolbook-medium-i-normal--17-120-100-100-p-92-iso8859-1
XEnGarde*HelpText.fontList: -b&h-lucidatypewriter-medium-r-normal-sans-17-120-100-100-m-100-iso8859-1
XEnGarde*HelpOk*fontList: -adobe-new century schoolbook-medium-i-normal--17-120-100-100-p-92-iso8859-1
XEnGarde*About*fontList: -sony-fixed-medium-r-normal--24-170-100-100-c-120-iso8859-1
X
XNOTE: the HelpText.fontList font MUST be fixed width.
XNOTE: the geometry MUST be bigger than 200x200 for the game to 
X        work correctly, you'll want it bigger if you want it
X        to look good.
X
XIf you don't have the fonts listed, feel free to change them.
X
XNOTE: changing other resources has not been tested, so if it doesn't
Xwork, send me a suggestion about adding that to the list of changeable
Xresources.
X
X
X
X/********************DISCLAIMER*************************************/
X
XThis software is distributed AS IS, and no guarantees about it's 
Xperformance or compatibility are issued.  If you find bugs or
Xhave suggestions (other than "make it color",etc. I can come up
Xwith those myself), please send them to wjames@jupiter.saic.com .
X
X/*******************************************************************/
X/*******************DISTRIBUTION INSTRUCTIONS***********************/
X
XThis software is distributed in source code form, and is to be
Xdistributed only in the original form and in it's entirety.  Changes
Xto code can be documented and sent to the author, and any such changes may
Xbe incorporated into a new version without notice.
X
X/*******************************************************************/
X
X
XFeatures to come in future releases:
X
X1.  Computer player for 1-player games.
X2.  Save game ability.
X3.  Win-loss record keeping.
X4.  Faster drawing, better-looking pieces.
X
X
X***************NOTES FROM THE AUTHOR******************************
X
XThanx for trying this out, this is my first X/MOTIF program,
Xand I think the game is a decent idea.  
X
XBill James
Xwjames@jupiter.saic.com
X
XLook for B J Products computer utilities on MS-DOS BBS's in California.
X
X
X******************SPECIAL THANKS:*********************************
X
XMark Botta:  HP play-and-compile-tester, aesthetics.
XKral Ferch:  MOTIF widget help.
X 
X******************************************************************
END_OF_FILE
if test 2884 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'bitmaps.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps.h'\"
else
echo shar: Extracting \"'bitmaps.h'\" \(8067 characters\)
sed "s/^X//" >'bitmaps.h' <<'END_OF_FILE'
X/* My logo */
X#define BJ_width 40
X#define BJ_height 40
Xstatic char BJ_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00,
X   0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00,
X   0xc0, 0x03, 0x00, 0x00, 0x00, 0xc0, 0xe3, 0xff, 0xff, 0xff, 0xc7, 0x83,
X   0xff, 0xff, 0xff, 0xc1, 0x03, 0x00, 0xf0, 0x03, 0xc0, 0x03, 0x00, 0xc0,
X   0x01, 0xc0, 0x03, 0x00, 0x80, 0x01, 0xc0, 0x03, 0xe0, 0x80, 0x01, 0xc0,
X   0x03, 0xb0, 0x81, 0x01, 0xc0, 0x03, 0x10, 0x83, 0x01, 0xc0, 0x03, 0x10,
X   0x82, 0x03, 0xc0, 0x03, 0x10, 0x02, 0x03, 0xc0, 0x03, 0x10, 0x03, 0x03,
X   0xc0, 0x03, 0xf0, 0x01, 0x03, 0xc0, 0x03, 0xf0, 0x01, 0x03, 0xc0, 0x03,
X   0x10, 0x03, 0x03, 0xc0, 0x03, 0x10, 0x06, 0x03, 0xc0, 0x03, 0x10, 0x04,
X   0x07, 0xc0, 0x03, 0x10, 0x04, 0x06, 0xc0, 0x03, 0x10, 0x04, 0x06, 0xc0,
X   0x03, 0x10, 0x06, 0x06, 0xc0, 0x03, 0x30, 0x03, 0x06, 0xc0, 0x03, 0xe0,
X   0x01, 0x06, 0xc0, 0x03, 0x00, 0x00, 0x06, 0xc0, 0x03, 0x00, 0x00, 0x07,
X   0xc0, 0x03, 0x03, 0x00, 0x03, 0xc0, 0x03, 0x07, 0x80, 0x03, 0xc0, 0x03,
X   0x3e, 0xc0, 0x01, 0xc0, 0x03, 0xfc, 0xff, 0x00, 0xc0, 0x03, 0xe0, 0x7f,
X   0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0xc0,
X   0x03, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
X
X/* En Garde Label */
X#define Emblem_width 40
X#define Emblem_height 40
Xstatic char Emblem_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00,
X   0x00, 0x00, 0xc0, 0x03, 0x00, 0x7e, 0x00, 0xc0, 0x03, 0x00, 0x7f, 0x00,
X   0xc0, 0x03, 0x00, 0x03, 0x00, 0xc0, 0x03, 0x80, 0x03, 0x00, 0xc0, 0x03,
X   0x80, 0x01, 0x00, 0xc0, 0x03, 0xc0, 0x01, 0x00, 0xc0, 0x03, 0xc0, 0x00,
X   0x00, 0xc0, 0x03, 0xc0, 0x07, 0x02, 0xc0, 0x03, 0xe0, 0x07, 0x1e, 0xc0,
X   0x03, 0x60, 0x00, 0x36, 0xc0, 0x03, 0x70, 0x00, 0x23, 0xc0, 0x03, 0x30,
X   0x00, 0x21, 0xc0, 0x03, 0x38, 0x80, 0x31, 0xc0, 0x03, 0x18, 0x80, 0x10,
X   0xc0, 0x03, 0xf8, 0xc7, 0x18, 0xc0, 0x03, 0xf0, 0x47, 0x08, 0xc0, 0x03,
X   0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00,
X   0x00, 0xc0, 0xc3, 0x03, 0x00, 0x00, 0xc0, 0xf3, 0x07, 0x00, 0x00, 0xc0,
X   0x33, 0x06, 0x00, 0x30, 0xc0, 0x3b, 0x00, 0x00, 0x30, 0xc0, 0x1b, 0x00,
X   0x00, 0x30, 0xc0, 0x1b, 0x00, 0x00, 0x30, 0xc0, 0x1b, 0x00, 0x00, 0x30,
X   0xcf, 0x1b, 0xe0, 0x74, 0xbe, 0xd9, 0x9b, 0xb7, 0x7d, 0xbf, 0xd9, 0x9b,
X   0x97, 0x0d, 0xb3, 0xcf, 0x1b, 0x16, 0x0d, 0xb3, 0xc1, 0x3b, 0x96, 0x0d,
X   0xb3, 0xc1, 0x33, 0xf7, 0x0d, 0xbf, 0xcf, 0xf3, 0x63, 0x0d, 0x3e, 0xcf,
X   0xe3, 0x01, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
X
X#define winright_width 40
X#define winright_height 40
Xstatic char winright_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00,
X   0x00, 0x00, 0xc0, 0x03, 0x80, 0xff, 0x01, 0xc0, 0x03, 0xe0, 0xff, 0x07,
X   0xc0, 0x03, 0x78, 0xf0, 0x1f, 0xc0, 0x03, 0x1e, 0xf0, 0x7f, 0xc0, 0x03,
X   0x07, 0xf0, 0xff, 0xc0, 0x83, 0x01, 0xf0, 0xff, 0xc1, 0xc3, 0x00, 0xf0,
X   0xff, 0xc3, 0xc3, 0xf0, 0xf0, 0xf0, 0xc3, 0x63, 0xf0, 0xf0, 0xf0, 0xc7,
X   0x63, 0xf0, 0xf0, 0xf0, 0xc7, 0x33, 0xf0, 0xf0, 0xf0, 0xcf, 0x33, 0x00,
X   0xf0, 0xff, 0xcf, 0x1b, 0x00, 0xf0, 0xff, 0xdf, 0x1b, 0x00, 0xf0, 0xff,
X   0xdf, 0x1b, 0x00, 0xf0, 0xff, 0xdf, 0x1b, 0x00, 0xf0, 0xff, 0xdf, 0x1b,
X   0x00, 0xf0, 0xff, 0xdf, 0x1b, 0x00, 0xf0, 0xff, 0xdf, 0x1b, 0x00, 0xf0,
X   0xff, 0xdf, 0x1b, 0x00, 0xf0, 0xff, 0xdf, 0x1b, 0x00, 0xf0, 0xff, 0xdf,
X   0x1b, 0x00, 0xf0, 0x9f, 0xdf, 0x33, 0x00, 0xf0, 0x8f, 0xcf, 0x33, 0x00,
X   0xf0, 0xc7, 0xcf, 0x63, 0xe0, 0x0f, 0xe0, 0xc7, 0x63, 0xf0, 0x0f, 0xf0,
X   0xc7, 0xc3, 0x38, 0xf0, 0xff, 0xc3, 0xc3, 0x1c, 0xf0, 0xff, 0xc3, 0x83,
X   0x0d, 0xf0, 0xff, 0xc1, 0x03, 0x07, 0xf0, 0xff, 0xc0, 0x03, 0x1e, 0xf0,
X   0x7f, 0xc0, 0x03, 0x78, 0xf0, 0x1f, 0xc0, 0x03, 0xe0, 0xff, 0x07, 0xc0,
X   0x03, 0x80, 0xff, 0x01, 0xc0, 0x03, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
X
X#define winleft_width 40
X#define winleft_height 40
Xstatic char winleft_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00,
X   0x00, 0x00, 0xc0, 0x03, 0x80, 0xff, 0x01, 0xc0, 0x03, 0xe0, 0xff, 0x07,
X   0xc0, 0x03, 0x78, 0xf0, 0x1f, 0xc0, 0x03, 0x1e, 0xf0, 0x7f, 0xc0, 0x03,
X   0x07, 0xf0, 0xff, 0xc0, 0x83, 0x01, 0xf0, 0xff, 0xc1, 0xc3, 0x00, 0xf0,
X   0xff, 0xc3, 0xc3, 0xf0, 0xf0, 0xf0, 0xc3, 0x63, 0xf0, 0xf0, 0xf0, 0xc7,
X   0x63, 0xf0, 0xf0, 0xf0, 0xc7, 0x33, 0xf0, 0xf0, 0xf0, 0xcf, 0x33, 0x00,
X   0xf0, 0xff, 0xcf, 0x1b, 0x00, 0xf0, 0xff, 0xdf, 0x1b, 0x00, 0xf0, 0xff,
X   0xdf, 0x1b, 0x00, 0xf0, 0xff, 0xdf, 0x1b, 0x00, 0xf0, 0xff, 0xdf, 0x1b,
X   0x00, 0xf0, 0xff, 0xdf, 0x1b, 0x00, 0xf0, 0xff, 0xdf, 0x1b, 0x00, 0xf0,
X   0xff, 0xdf, 0x1b, 0x00, 0xf0, 0xff, 0xdf, 0x1b, 0x00, 0xf0, 0xff, 0xdf,
X   0x1b, 0x0c, 0xf0, 0xff, 0xdf, 0x33, 0x1c, 0xf0, 0xff, 0xcf, 0x33, 0x38,
X   0xf0, 0xff, 0xcf, 0x63, 0xf0, 0x0f, 0xf8, 0xc7, 0x63, 0xe0, 0x0f, 0xf0,
X   0xc7, 0xc3, 0x00, 0xf0, 0xe3, 0xc3, 0xc3, 0x00, 0xf0, 0xc7, 0xc3, 0x83,
X   0x01, 0xf0, 0xcf, 0xc1, 0x03, 0x07, 0xf0, 0xff, 0xc0, 0x03, 0x1e, 0xf0,
X   0x7f, 0xc0, 0x03, 0x78, 0xf0, 0x1f, 0xc0, 0x03, 0xe0, 0xff, 0x07, 0xc0,
X   0x03, 0x80, 0xff, 0x01, 0xc0, 0x03, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
X
X
X/* Left players turn */
X#define lturn_width 40
X#define lturn_height 40
Xstatic char lturn_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00,
X   0x00, 0x00, 0xc0, 0x03, 0x00, 0x30, 0x00, 0xc0, 0x03, 0x00, 0x38, 0x00,
X   0xc0, 0x03, 0x00, 0x3c, 0x00, 0xc0, 0x03, 0x00, 0x36, 0x00, 0xc0, 0x03,
X   0x00, 0x33, 0x00, 0xc0, 0x03, 0x80, 0x31, 0x00, 0xc0, 0x03, 0xc0, 0x30,
X   0x00, 0xc0, 0x03, 0x60, 0x30, 0x00, 0xc0, 0x03, 0x30, 0x30, 0x00, 0xc0,
X   0x03, 0x18, 0x30, 0x00, 0xc0, 0x03, 0x0c, 0xf0, 0xff, 0xcf, 0x03, 0x06,
X   0xf0, 0xff, 0xcf, 0x03, 0x03, 0x00, 0x00, 0xcc, 0x83, 0x01, 0x00, 0x00,
X   0xcc, 0xc3, 0x00, 0x00, 0x00, 0xcc, 0x63, 0x00, 0x00, 0x00, 0xcc, 0x33,
X   0x00, 0x00, 0x00, 0xcc, 0x33, 0x00, 0x00, 0x00, 0xcc, 0x63, 0x00, 0x00,
X   0x00, 0xcc, 0xc3, 0x00, 0x00, 0x00, 0xcc, 0x83, 0x01, 0x00, 0x00, 0xcc,
X   0x03, 0x03, 0x00, 0x00, 0xcc, 0x03, 0x06, 0xf0, 0xff, 0xcf, 0x03, 0x0c,
X   0xf0, 0xff, 0xcf, 0x03, 0x18, 0x30, 0x00, 0xc0, 0x03, 0x30, 0x30, 0x00,
X   0xc0, 0x03, 0x60, 0x30, 0x00, 0xc0, 0x03, 0xc0, 0x30, 0x00, 0xc0, 0x03,
X   0x80, 0x31, 0x00, 0xc0, 0x03, 0x00, 0x33, 0x00, 0xc0, 0x03, 0x00, 0x36,
X   0x00, 0xc0, 0x03, 0x00, 0x3c, 0x00, 0xc0, 0x03, 0x00, 0x38, 0x00, 0xc0,
X   0x03, 0x00, 0x30, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
X
X/* Right players turn */
X#define rturn_width 40
X#define rturn_height 40
Xstatic char rturn_bits[] = {
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00,
X   0x00, 0x00, 0xc0, 0x03, 0x00, 0x0c, 0x00, 0xc0, 0x03, 0x00, 0x1c, 0x00,
X   0xc0, 0x03, 0x00, 0x3c, 0x00, 0xc0, 0x03, 0x00, 0x7c, 0x00, 0xc0, 0x03,
X   0x00, 0xfc, 0x00, 0xc0, 0x03, 0x00, 0xfc, 0x01, 0xc0, 0x03, 0x00, 0xfc,
X   0x03, 0xc0, 0x03, 0x00, 0xfc, 0x07, 0xc0, 0x03, 0x00, 0xfc, 0x0f, 0xc0,
X   0x03, 0x00, 0xfc, 0x1f, 0xc0, 0xf3, 0xff, 0xff, 0x3f, 0xc0, 0xf3, 0xff,
X   0xff, 0x7f, 0xc0, 0xf3, 0xff, 0xff, 0xff, 0xc0, 0xf3, 0xff, 0xff, 0xff,
X   0xc1, 0xf3, 0xff, 0xff, 0xff, 0xc3, 0xf3, 0xff, 0xff, 0xff, 0xc7, 0xf3,
X   0xff, 0xff, 0xff, 0xcf, 0xf3, 0xff, 0xff, 0xff, 0xcf, 0xf3, 0xff, 0xff,
X   0xff, 0xc7, 0xf3, 0xff, 0xff, 0xff, 0xc3, 0xf3, 0xff, 0xff, 0xff, 0xc1,
X   0xf3, 0xff, 0xff, 0xff, 0xc0, 0xf3, 0xff, 0xff, 0x7f, 0xc0, 0xf3, 0xff,
X   0xff, 0x3f, 0xc0, 0x03, 0x00, 0xfc, 0x1f, 0xc0, 0x03, 0x00, 0xfc, 0x0f,
X   0xc0, 0x03, 0x00, 0xfc, 0x07, 0xc0, 0x03, 0x00, 0xfc, 0x03, 0xc0, 0x03,
X   0x00, 0xfc, 0x01, 0xc0, 0x03, 0x00, 0xfc, 0x00, 0xc0, 0x03, 0x00, 0x7c,
X   0x00, 0xc0, 0x03, 0x00, 0x3c, 0x00, 0xc0, 0x03, 0x00, 0x1c, 0x00, 0xc0,
X   0x03, 0x00, 0x0c, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0xc0, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
END_OF_FILE
if test 8067 -ne `wc -c <'bitmaps.h'`; then
    echo shar: \"'bitmaps.h'\" unpacked with wrong size!
fi
# end of 'bitmaps.h'
fi
if test -f 'board.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'board.c'\"
else
echo shar: Extracting \"'board.c'\" \(5055 characters\)
sed "s/^X//" >'board.c' <<'END_OF_FILE'
X/*********************************************************************
X                                Engarde
X                             File: board.c
X
X  This file contains the routines for the data of the board, magnet
X  comparisons, and movement legality.
X
X  Version 1:  1/9/92  (Bill James)
X*********************************************************************/
X#include <malloc.h>
X#include <stdio.h>
X#include <sys/types.h>
X#include <time.h>
X#include "board.h"
X
Xextern int H,W;
Xchar *SIGNSTRING[] = {"-","*","+"};
XBoardType *b;
X
X/* 
X   Flips piece from black to white or vice versa 
X*/
Xvoid FlipPiece(p)
XPieceType *p;
X{
X   p->color = (p->color == PIECE_BLACK)? PIECE_WHITE:PIECE_BLACK;
X}
X
X
X/* 
X   Mallocs and initializes board entity items
X*/
Xvoid InitBoard(s, h, w) 
XSideType *s;
Xint h,w;
X{
X    int i,j;
X    PieceType *pc;
X       b = (BoardType *) malloc (sizeof (BoardType));
X       b->magnets = (char **) malloc (sizeof(char*) * h);
X       b->pieces = (PieceType ***) malloc (sizeof(PieceType**) * h);
X       for (i = 0; i < h; i++) {
X          b->magnets[i] = (char *) malloc (w);
X          b->pieces[i] = (PieceType **) malloc (w * sizeof(PieceType*));
X          for (j = 0; j < w; j++) {
X              b->magnets[i][j] = 0;
X              b->pieces[i][j] = NULL;
X          }
X       }
X       for (i = 0; i < NPIECES; i++) {
X          pc = (PieceType *) malloc (sizeof(PieceType));
X          s[PIECE_ROUND].p[i] = pc;
X          s[PIECE_ROUND].p[i]->type = PIECE_ROUND;
X          s[PIECE_ROUND].p[i]->color = PIECE_ROUND;
X          pc = (PieceType *) malloc (sizeof(PieceType));
X          s[PIECE_SQUARE].p[i] = pc;
X          s[PIECE_SQUARE].p[i]->type = PIECE_SQUARE;
X          s[PIECE_SQUARE].p[i]->color = PIECE_SQUARE;
X       }
X       b->height = h;
X       b->width = w;
X}
X
X
X/*
X   Deletes board memory items
X*/
Xvoid KillBoard(s) 
XSideType s[2];
X{
X    int i,j;
X    for (i = 0 ; i < b->height; i++) {
X       if (s[0].p[i]) free(s[0].p[i]);
X       if (s[1].p[i]) free(s[1].p[i]);
X       for (j = 0; j < b->width; j++) {
X          if (b->pieces[i][j]) free(b->pieces[i][j]);
X       }
X       free((char *) b->magnets[i]);
X    }
X    free((char *) b->magnets);
X    free((char *) b->pieces);
X}
X
X
X#define GetPiece(b,h,w) (b)->pieces[(h)][(w)]
X#define GetPolarity(b,h,w) (b)->magnets[(h)][(w)]
X#define CKHW(b,h1,w1) (((h1) < (b)->height) && ((w1) < (b)->width))
X
X/*
X   Move piece from h1,w1 to h2,w2
X*/
Xint MovePiece(h1, w1, h2, w2) 
Xint h1,h2,w1,w2;
X{
X    if (!(CKHW(b,h1,w1))) return(1);
X    if (!(CKHW(b,h2,w2))) return(1);
X    if (b->pieces[h1][w1]) {
X       if (b->pieces[h2][w2]) return(1);
X       b->pieces[h2][w2] = b->pieces[h1][w1];
X       Magnetize(h2,w2);
X       b->pieces[h1][w1] = NULL;
X       return(0);
X    }
X    else return (1);
X}
X
X
X/*
X    Randomly shuffles board magnets
X*/
Xvoid BoardShuffle() 
X{
X    int i,j;
X    char k;
X    for ( i = 0; i < b->height; i++) 
X       for (j = 0; j < b->width; j++) {
X           k = (char) (random() % 2);
X           if (k) b->magnets[i][j] = 1;
X           else b->magnets[i][j] = -1;
X           k = (char) (random() % 10);
X           if (!k) b->magnets[i][j] = 0;
X           Magnetize(i,j);
X       }
X}
X
X
X
X/*
X   Sets piece color to correct color for it's shape/position
X*/
Xvoid Magnetize(h, w) 
Xint h,w;
X{
X   PieceType *p;
X   p = b->pieces[h][w];
X   if (!(b->magnets[h][w])) return;
X   if (p) {
X      if ((p->type == PIECE_ROUND) && (b->magnets[h][w] == POSITIVE))
X          p->color = PIECE_BLACK;
X      if ((p->type == PIECE_ROUND) && (b->magnets[h][w] == NEGATIVE))
X          p->color = PIECE_WHITE;
X      if ((p->type == PIECE_SQUARE) && (b->magnets[h][w] == POSITIVE))
X          p->color = PIECE_WHITE;
X      if ((p->type == PIECE_SQUARE) && (b->magnets[h][w] == NEGATIVE))
X          p->color = PIECE_BLACK;
X   }
X}
X
X
X
X/*
X   Sums the colors of the set of four pieces (i,j),(i+dx,j+dy),
X   (i+2dx,j+2dy),(i+3dx,j+3dy), or returns -1 if any of the 
X   spaces have no piece.
X*/
Xint SumSet(i,j,dx,dy) 
Xint i,j,dx,dy;
X{
Xint s,l,m,r;
X  s = 0;
X  for (r = 0, l = i, m = j; ((r < 4) && (l < W) && (l >= 0)) &&
X                            ((m < H) && (m >= 0)); r++, l+=dx, m+=dy) {
X     if (!b->pieces[l][m]) return(-1);
X     s += b->pieces[l][m]->color;
X  }
X  if (((l >= W) || (l < 0) || (m >= H) || (m < 0)) && (r < 4)) return(-1);
X  return(s);
X}
X
X
X/*
X   Checks the board to find any set of 4 spaces in a row,column,diag
X   that are the same color.
X*/
Xint CheckWinner(i, j, dx, dy)
Xint *i,*j,*dx,*dy;
X{
Xint c,d,x,y,g;
Xfor (c = 0; c < W; c++) 
X   for (d = 0; d < H; d++) 
X      for (x = -1; x < 2; x++) {
X         for (y = -1; y < 2; y++) {
X            if ((!x) && (!y)) continue;
X            g = SumSet(c,d,x,y);
X            if (g == (4 * PIECE_BLACK)) {
X                *dx = x; *dy = y; 
X                *i = c; *j = d;
X		return(1);
X            }
X            if (g == (4 * PIECE_WHITE)) {
X                *dx = x; *dy = y; 
X                *i = c; *j = d;
X		return(1);
X            }
X         }
X      }
Xreturn(0);
X}
X
X
Xvoid Randomize()
X{
Xtime_t g;
Xint *h;
X
X  g = time();
X  h = (int *) &g;
X  srandom(*h);
X}
END_OF_FILE
if test 5055 -ne `wc -c <'board.c'`; then
    echo shar: \"'board.c'\" unpacked with wrong size!
fi
# end of 'board.c'
fi
if test -f 'engarde.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'engarde.c'\"
else
echo shar: Extracting \"'engarde.c'\" \(14872 characters\)
sed "s/^X//" >'engarde.c' <<'END_OF_FILE'
X/*********************************************************************
X                                Engarde
X                            File: engarde.c
X
X  This file contains startup routines and widget initializations
X  for the display of the game.  It also calls functions to initialize
X  the board magnets, etc.
X
X  Version 1:  1/9/92  (Bill James)
X*********************************************************************/
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Xutil.h>
X#include <Xm/Xm.h>
X#include <Xm/RowColumn.h>
X#include <Xm/Form.h>
X#include <Xm/DrawingA.h>
X#include <Xm/Text.h>
X#include <Xm/Label.h>
X#include <Xm/PushB.h>
X#include <Xm/DrawnB.h>
X#include "menus.h"
X#include "board.h"
X#include "xboard.h"
X#include "bitmaps.h"
X#include "help.h"
X
XWidget draw;
XWidget lt; 
XWidget rt; 
XWidget mess;
XWidget help;
XWidget about;
Xint n, H, W;
XSideType s[2];
XPixel fore, back;
XPixmap lturn, rturn, goveright, goverleft;
X
Xvoid AddPixmap();
XWidget MakeAboutWidget();
X
X
Xstatic void quit(w, client_data, call_data)
XWidget w;
Xcaddr_t client_data;
XXmAnyCallbackStruct *call_data;
X{
X     XtCloseDisplay(XtDisplay(w));
X     exit(0);
X}
X
Xstatic xs_menu_struct menuData_Quit[] = {
X  {"Quit", quit, NULL, NULL, 0, NULL}
X};
X
Xstatic xs_menu_struct menuData_Game[] = {
X  {"New", ResetBoard, NULL, NULL, 0, NULL}
X};
X
Xstatic xs_menu_struct menuData_Help[] = {
X  {"Help", ShowHelp, NULL, NULL, 0, NULL},
X  {"About...", ShowAbout, NULL, NULL, 0, NULL}
X};
X
Xstatic xs_menu_struct menuData[] = {
X  {"Game", NULL, NULL, menuData_Game, XtNumber(menuData_Game), NULL},
X  {"Help", NULL, NULL, menuData_Help, XtNumber(menuData_Help), NULL},
X  {"Quit", NULL, NULL, menuData_Quit, XtNumber(menuData_Quit), NULL}
X};
X
X
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
XWidget menu, form, toplevel, emb, bj, helptext, helpquit; 
XArg wargs[20];
XPixmap embpix, bjpix;
Xint i,j;
XXmString str;
Xstatic XtActionsRec draw_actions[] = {
X         {"ButtonPress1",        ButtonPress1},
X};
X static char draw_translations[] =
X         "<Btn1Down>:            ButtonPress1()";
X
X
X   toplevel = XtInitialize(argv[0], "EnGarde", NULL, 0, &argc, argv);
X   form = XtCreateManagedWidget("Form", xmFormWidgetClass, toplevel, NULL, 0);
X   help = XmCreateFormDialog(toplevel,"Help", NULL, 0);
X
X   n = 0;
X   XtSetArg(wargs[n], XmNtopAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNleftAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNrightOffset, 10); n++;
X   XtSetArg(wargs[n], XmNleftOffset, 10); n++;
X   XtSetArg(wargs[n], XmNtopOffset, 5); n++;
X   menu = XmCreateMenuBar(form, "Menu", wargs, n); XtManageChild(menu);
X
X   xs_create_menu_buttons(NULL, menu, menuData, XtNumber(menuData));
X   
X   n = 0;
X   XtSetArg(wargs[n], XmNlabelType, XmPIXMAP); n++;
X   XtSetArg(wargs[n], XmNleftAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNleftOffset, 10); n++;
X   XtSetArg(wargs[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNbottomOffset, 20); n++;
X   XtSetArg(wargs[n], XmNheight, 60); n++;
X   emb = (Widget) XmCreateLabel(form, "Emblem", wargs, n);
X   XtManageChild(emb);
X   AddPixmap(emb, &embpix, Emblem_bits, Emblem_width, Emblem_height);
X   n = 0;
X   XtSetArg(wargs[n], XmNlabelPixmap, embpix); n++;
X   XtSetValues(emb, wargs, n);
X
X   n = 0;
X   XtSetArg(wargs[n], XmNlabelType, XmPIXMAP); n++;
X   XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNrightOffset, 10); n++;
X   XtSetArg(wargs[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNbottomOffset, 20); n++;
X   XtSetArg(wargs[n], XmNheight, 60); n++;
X   bj = (Widget) XmCreateLabel(form, "Bj", wargs, n);
X   XtManageChild(bj);
X   AddPixmap(bj, &bjpix, BJ_bits, BJ_width, BJ_height);
X   n = 0;
X   XtSetArg(wargs[n], XmNlabelPixmap, bjpix); n++;
X   XtSetValues(bj, wargs, n);
X
X   n = 0;
X   XtSetArg(wargs[n], XmNlabelType, XmPIXMAP); n++;
X   XtSetArg(wargs[n], XmNleftAttachment, XmATTACH_WIDGET); n++;
X   XtSetArg(wargs[n], XmNleftOffset, 10); n++;
X   XtSetArg(wargs[n], XmNleftWidget, emb); n++;
X   XtSetArg(wargs[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNbottomOffset, 20); n++;
X   XtSetArg(wargs[n], XmNheight, 60); n++;
X   lt = (Widget) XmCreateLabel(form, "Lturn", wargs, n);
X   XtManageChild(lt);
X   AddPixmap(lt, &lturn, lturn_bits, lturn_width, lturn_height);
X   n = 0;
X   XtSetArg(wargs[n], XmNlabelPixmap, lturn); n++;
X   XtSetValues(lt, wargs, n);
X
X   n = 0;
X   XtSetArg(wargs[n], XmNlabelType, XmPIXMAP); n++;
X   XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_WIDGET); n++;
X   XtSetArg(wargs[n], XmNrightWidget, bj); n++;
X   XtSetArg(wargs[n], XmNrightOffset, 10); n++;
X   XtSetArg(wargs[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNbottomOffset, 20); n++;
X   XtSetArg(wargs[n], XmNheight, 60); n++;
X   rt = (Widget) XmCreateLabel(form, "Rturn", wargs, n);
X   XtManageChild(rt);
X   AddPixmap(rt, &goveright, winright_bits, winright_width, winright_height);
X   AddPixmap(rt, &goverleft, winleft_bits, 
X                          winleft_width, winleft_height);
X   AddPixmap(rt, &rturn, rturn_bits, rturn_width, rturn_height);
X   n = 0;
X   XtSetArg(wargs[n], XmNlabelPixmap, lturn); n++;
X   XtSetValues(rt, wargs, n);
X
X   n = 0;
X   XtSetArg(wargs[n], XmNleftAttachment, XmATTACH_WIDGET); n++;
X   XtSetArg(wargs[n], XmNleftWidget, lt); n++;
X   XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_WIDGET); n++;
X   XtSetArg(wargs[n], XmNrightWidget, rt); n++;
X   XtSetArg(wargs[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNbottomOffset, 10); n++;
X   /*XtSetArg(wargs[n], XmNcolumns, 60); n++;*/
X   XtSetArg(wargs[n], XmNrows, 2); n++;
X   XtSetArg(wargs[n], XmNwordWrap, True); n++;
X   XtSetArg(wargs[n], XmNscrollVertical, True); n++;
X   XtSetArg(wargs[n], XmNscrollHorizontal, False); n++;
X   XtSetArg(wargs[n], XmNeditMode, XmMULTI_LINE_EDIT); n++;
X   XtSetArg(wargs[n], XmNeditable, False); n++;
X   XtSetArg(wargs[n], XmNheight, 60); n++;
X   XtSetArg(wargs[n], XmNcursorPositionVisible, False); n++;
X   mess = (Widget) XmCreateScrolledText(form, "Message", wargs, n);
X   XtManageChild(mess);
X
X   n = 0;
X   XtSetArg(wargs[n], XmNleftAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNleftOffset, 70); n++;
X   XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNrightOffset, 70); n++;
X   XtSetArg(wargs[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNbottomOffset, 10); n++;
X   str = XmStringCreate("OK",XmSTRING_DEFAULT_CHARSET);
X   XtSetArg(wargs[n], XmNlabelString, str); n++;
X   helpquit = (Widget) XmCreatePushButton(help, "HelpOk", wargs, n);
X   XtManageChild(helpquit);
X
X   n = 0;
X   XtSetArg(wargs[n], XmNleftAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNleftWidget, lt); n++;
X   XtSetArg(wargs[n], XmNleftOffset, 10); n++;
X   XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNrightWidget, rt); n++;
X   XtSetArg(wargs[n], XmNrightOffset, 10); n++;
X   XtSetArg(wargs[n], XmNtopAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNtopOffset, 10); n++;
X   XtSetArg(wargs[n], XmNbottomAttachment, XmATTACH_WIDGET); n++;
X   XtSetArg(wargs[n], XmNbottomWidget, helpquit); n++;
X   XtSetArg(wargs[n], XmNbottomOffset, 10); n++;
X   XtSetArg(wargs[n], XmNcolumns, 80); n++;
X   XtSetArg(wargs[n], XmNrows, 20); n++;
X   XtSetArg(wargs[n], XmNwordWrap, False); n++;
X   XtSetArg(wargs[n], XmNscrollVertical, True); n++;
X   XtSetArg(wargs[n], XmNscrollHorizontal, False); n++;
X   XtSetArg(wargs[n], XmNeditMode, XmMULTI_LINE_EDIT); n++;
X   XtSetArg(wargs[n], XmNeditable, False); n++;
X   helptext = (Widget) XmCreateScrolledText(help, "HelpText", wargs, n);
X   XtManageChild(helptext);
X
X   j = 0;
X   for (i = 0; i < HELPLINES; i++) {
X      XmTextInsert(helptext, j, helpstr[i]);
X      j += strlen(helpstr[i]);
X   }
X
X   n = 0;
X   XtSetArg(wargs[n], XmNtopAttachment, XmATTACH_WIDGET); n++;
X   XtSetArg(wargs[n], XmNtopWidget, menu); n++;
X   XtSetArg(wargs[n], XmNtopOffset, 10); n++;
X   XtSetArg(wargs[n], XmNleftOffset, 10); n++;
X   XtSetArg(wargs[n], XmNrightOffset, 10); n++;
X   XtSetArg(wargs[n], XmNleftAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNbottomAttachment, XmATTACH_WIDGET); n++;
X   XtSetArg(wargs[n], XmNbottomWidget, mess); n++;
X   XtSetArg(wargs[n], XmNbottomOffset, 10); n++;
X   XtSetArg(wargs[n], XmNwidth, 300); n++;
X   XtSetArg(wargs[n], XmNheight, 200); n++;
X   XtSetArg(wargs[n], XmNresizePolicy, XmRESIZE_ANY); n++;
X  draw = XtCreateManagedWidget("Canvas",xmDrawingAreaWidgetClass, form,wargs,n);
X
X   MakeAboutWidget(toplevel, bjpix, embpix);
X
X   n = 0;
X   XtSetArg(wargs[n], XmNforeground, &fore); n++;
X   XtSetArg(wargs[n], XmNbackground, &back); n++;
X   XtGetValues(draw, wargs, n);
X
X   XtAddCallback(draw, XmNexposeCallback, DrawGame, NULL);
X   XtAddCallback(draw, XmNresizeCallback, DrawGame, NULL);
X   XtAddCallback(helpquit, XmNactivateCallback, CloseHelp, NULL);
X   XtOverrideTranslations (draw, XtParseTranslationTable (draw_translations));
X   XtAppAddActions (XtWidgetToApplicationContext (draw), draw_actions,
X						 XtNumber (draw_actions));
X
X   W = 6; H = 6;
X   Randomize();
X   InitBoard(s,W,H);
X   BoardShuffle();
X   XtRealizeWidget(toplevel);
X   XtMainLoop();
X}
X
X
Xvoid AddPixmap(w, pix, b, wid, hgt)
XWidget w;
XPixmap *pix;
Xchar * b;
Xint wid, hgt;
X{
XPixmap bitmap;
XXGCValues vals;
XGC gc;
XArg wargs[10];
Xint n;
X   bitmap = XCreateBitmapFromData(XtDisplay(w), 
X              RootWindowOfScreen(XtScreen(w)), b, wid, hgt);
X   *pix = XCreatePixmap(XtDisplay(w),
X              RootWindowOfScreen(XtScreen(w)), 
X              wid, hgt, DefaultDepthOfScreen(XtScreen(w)));
X   n = 0;
X   XtSetArg(wargs[n],XtNforeground, &vals.foreground); n++;
X   XtSetArg(wargs[n],XtNbackground, &vals.background); n++;
X   XtGetValues(w,wargs,n);
X   gc = XtGetGC(w, GCForeground|GCBackground, &vals);
X   XCopyPlane(XtDisplay(w), bitmap, *pix, gc, 0, 0,
X              wid, hgt, 0, 0, 1);
X   XFreePixmap(XtDisplay(w), bitmap);
X   XtReleaseGC(w, gc);
X}
X
X
XWidget MakeAboutWidget(w, bjpix, embpix)
XWidget w;
XPixmap bjpix, embpix;
X{
XWidget label1,label2,label3,label4,label5,label6,button;
XArg wargs[20];
Xint n;
XXmString str[7];
XDimension x,j;
X
X
X   about = XmCreateFormDialog(w,"About", NULL, 0);
X   
X   n = 0;
X   XtSetArg(wargs[n], XmNlabelType, XmSTRING); n++;
X   XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNleftAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNtopAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNtopOffset, 20); n++;
X   XtSetArg(wargs[n], XmNrightOffset, 20); n++;
X   XtSetArg(wargs[n], XmNleftOffset, 20); n++;
X   XtSetArg(wargs[n], XmNheight, 60); n++;
X   str[0] = XmStringCreate("En Garde",XmSTRING_DEFAULT_CHARSET);
X   XtSetArg(wargs[n], XmNlabelString, str[0]); n++;
X   label1 = (Widget) XmCreateLabel(about, "AboutTitle", wargs, n);
X   XtManageChild(label1);
X
X   n = 0;
X   XtSetArg(wargs[n], XmNlabelType, XmSTRING); n++;
X   XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNleftAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNtopAttachment, XmATTACH_WIDGET); n++;
X   XtSetArg(wargs[n], XmNtopWidget, label1); n++;
X   XtSetArg(wargs[n], XmNtopOffset, 10); n++;
X   XtSetArg(wargs[n], XmNrightOffset, 20); n++;
X   XtSetArg(wargs[n], XmNleftOffset, 20); n++;
X   XtSetArg(wargs[n], XmNheight, 60); n++;
X   str[1] = XmStringCreate("Version 1.0",XmSTRING_DEFAULT_CHARSET);
X   XtSetArg(wargs[n], XmNlabelString, str[1]); n++;
X   label2 = (Widget) XmCreateLabel(about, "AboutVersion", wargs, n);
X   XtManageChild(label2);
X
X   n = 0;
X   XtSetArg(wargs[n], XmNlabelType, XmSTRING); n++;
X   XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNleftAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNtopAttachment, XmATTACH_WIDGET); n++;
X   XtSetArg(wargs[n], XmNtopWidget, label2); n++;
X   XtSetArg(wargs[n], XmNtopOffset, 10); n++;
X   XtSetArg(wargs[n], XmNrightOffset, 20); n++;
X   XtSetArg(wargs[n], XmNleftOffset, 20); n++;
X   XtSetArg(wargs[n], XmNheight, 60); n++;
X   str[2] = XmStringCreate("January, 1992",XmSTRING_DEFAULT_CHARSET);
X   XtSetArg(wargs[n], XmNlabelString, str[2]); n++;
X   label3 = (Widget) XmCreateLabel(about, "AboutDate", wargs, n);
X   XtManageChild(label3);
X
X   n = 0;
X   XtSetArg(wargs[n], XmNlabelType, XmSTRING); n++;
X   XtSetArg(wargs[n], XmNleftAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNtopAttachment, XmATTACH_WIDGET); n++;
X   XtSetArg(wargs[n], XmNtopWidget, label3); n++;
X   XtSetArg(wargs[n], XmNtopOffset, 10); n++;
X   XtSetArg(wargs[n], XmNrightOffset, 20); n++;
X   XtSetArg(wargs[n], XmNleftOffset, 20); n++;
X   XtSetArg(wargs[n], XmNheight, 60); n++;
X   str[3] = XmStringCreate("Bill James",XmSTRING_DEFAULT_CHARSET);
X   XtSetArg(wargs[n], XmNlabelString, str[3]); n++;
X   label4 = (Widget) XmCreateLabel(about, "AboutAuthor", wargs, n);
X   XtManageChild(label4);
X
X   n = 0;
X   XtSetArg(wargs[n], XmNlabelType, XmSTRING); n++;
X   XtSetArg(wargs[n], XmNrightAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNleftAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNtopAttachment, XmATTACH_WIDGET); n++;
X   XtSetArg(wargs[n], XmNtopWidget, label4); n++;
X   XtSetArg(wargs[n], XmNtopOffset, 10); n++;
X   XtSetArg(wargs[n], XmNrightOffset, 20); n++;
X   XtSetArg(wargs[n], XmNleftOffset, 20); n++;
X   XtSetArg(wargs[n], XmNheight, 60); n++;
X   str[4] = XmStringCreate("wjames@jupiter.SAIC.COM",XmSTRING_DEFAULT_CHARSET);
X   XtSetArg(wargs[n], XmNlabelString, str[4]); n++;
X   label6 = (Widget) XmCreateLabel(about, "AboutMail", wargs, n);
X   XtManageChild(label6);
X
X   n = 0;
X   XtSetArg(wargs[n], XmNleftAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNtopAttachment, XmATTACH_WIDGET); n++;
X   XtSetArg(wargs[n], XmNtopWidget, label6); n++;
X   XtSetArg(wargs[n], XmNtopOffset, 20); n++;
X   XtSetArg(wargs[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X   XtSetArg(wargs[n], XmNbottomOffset, 20); n++;
X   XtSetArg(wargs[n], XmNentryAlignment, XmALIGNMENT_CENTER); n++;
X   XtSetArg(wargs[n], XmNlabelPixmap, embpix); n++;
X   XtSetArg(wargs[n], XmNlabelType, XmPIXMAP); n++;
X   XtSetArg(wargs[n], XmNwidth, 100); n++;
X   XtSetArg(wargs[n], XmNheight, 60); n++;
X   XtSetArg(wargs[n], XmNresize, False); n++;
X   button = XmCreateDrawnButton(about, "AboutButton", wargs, n);
X   XtManageChild(button);
X
X   XtAddCallback(button, XmNactivateCallback, CloseAbout, NULL);
X
X   XtRealizeWidget (about);
X   n = 0;
X   XtSetArg(wargs[n], XmNwidth, &x); n++;
X   XtGetValues(about, wargs, n);
X   j = (x - 100) / 2;
X   if (j < 0) j = 0;
X   n = 0;
X   XtSetArg(wargs[n], XmNleftOffset, j); n++;
X   XtSetValues(button, wargs, n);
X
X}
X
END_OF_FILE
if test 14872 -ne `wc -c <'engarde.c'`; then
    echo shar: \"'engarde.c'\" unpacked with wrong size!
fi
# end of 'engarde.c'
fi
if test -f 'help.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help.h'\"
else
echo shar: Extracting \"'help.h'\" \(4562 characters\)
sed "s/^X//" >'help.h' <<'END_OF_FILE'
X/*********************************************************************
X                                Engarde
X                            File: help.h
X
X  This file contains the a C version of the engarde.RULES file to
X  be included into the help window of the game.
X
X  Version 1:  1/9/92  (Bill James)
X*********************************************************************/
X#define HELPLINES	93
Xchar *helpstr[HELPLINES] = {
X"\n",
X"                             ENGARDE v1.0\n",
X"--------------------------------------------------------------------------\n",
X"      A game written for X11R4 with OSF/MOTIF widgets by Bill James.\n",
X"--------------------------------------------------------------------------\n",
X"\n",
X"OBJECT:\n",
X"\n",
X"To have 4 pieces in a row, column, diagonal that are all of one player's \n",
X"color, that player is to be considered the winner.\n",
X"\n",
X"\n",
X"DESIGNATIONS:\n",
X"\n",
X" -  The center set of squares is know as the \"grid\".\n",
X" -  The single columns to the right and left of the grid are\n",
X"      called \"side-bars\", possible preceded by a \"left\" or \"right\".\n",
X" -  The squares and circles are called \"pieces\", with the unfilled\n",
X"      piece being \"white\", and the filled piece being \"black\".\n",
X"\n",
X"\n",
X"CHARACTERISTICS OF THE BOARD:\n",
X"\n",
X"    Each piece is to be considered a magnet with one pole painted \n",
X"white, and the other painted black.  A piece is considered to be\n",
X"white if the white side is face up, else it is black.  On circular \n",
X"pieces the positive side is painted white, while on the squares it \n",
X"is the negative side.  The grid is also merely a set of magnetized \n",
X"squares, with either the positive or negative side facing upwards.\n",
X"The grid also contains spaces that are not magnets at all, but are \n",
X"merely null spots, and do not affect the pieces at all.  \n",
X"\n",
X"Examples:\n",
X"Sample Grid :\n",
X"    \n",
X"   + + - + O -     + = positive grid face up\n",
X"   - - + - + -     - = negative grid face up\n",
X"   O - + - - +     O = null grid space\n",
X"   + + - + + -\n",
X"   - + + O - -\n",
X"   - - - - + +\n",
X"\n",
X"Every new game, the board shuffles it's magnets to form a new\n",
X"grid.\n",
X"\n",
X"When a player moves a piece onto the grid, the magnetic interactions\n",
X"cause the piece to show the color painted on the magnet side with\n",
X"the same polarity as the grid place.  e.g. when a piece moves on\n",
X"a positive grid place, the positive side of the magnet is repulsed, \n",
X"and is therefore face up.\n",
X"\n",
X"  Before Move          After Move Piece is:\n",
X"   Piece is:      When moved onto grid with magnet:\n",
X"--------------------------------------------------\n",
X"| Shape | Color ||| Positive | Negative |  Null  |\n",
X"--------------------------------------------------\n",
X"|  SQU  |  Wh   |||    Bl    |    Wh    |   Wh   |   \n",
X"|  SQU  |  Bl   |||    Bl    |    Wh    |   Bl   |\n",
X"|  CIR  |  Wh   |||    Wh    |    Bl    |   Wh   |\n",
X"|  CIR  |  Bl   |||    Wh    |    Bl    |   Bl   |\n",
X"--------------------------------------------------\n",
X"\n",
X"RULES OF MOVEMENT:\n",
X"\n",
X"The arrows to either side of the message box designate whose turn it is.\n",
X"This player has the following options:\n",
X"\n",
X"1.  The player may take a piece from his side-bar and place it\n",
X"    on any space on the center grid where there is no other piece.\n",
X"\n",
X"2.  The player may move any piece that is currently on the grid\n",
X"    EXCEPT the last piece moved to another spot guided by these rules:\n",
X"    2a.  Piece cannot move to occupied place.\n",
X"    2b.  Piece may only move in one direction.\n",
X"    2c.  Piece cannot move more than 2 spaces in a single direction,\n",
X"           either Up, Down, Left, Right, or the Diagonals.\n",
X"    2d.  Piece may only be moved 2 spaces in a direction if the first\n",
X"           space in that direction is occupied (it jumps the first piece).\n",
X"    2e.  Piece may not be placed back onto side-bar.\n",
X"    \n",
X"\n",
X"STRATEGY HINTS:\n",
X"\n",
X" - Try to save a piece on your side-bar, being able to place it anywhere\n",
X"      on the grid may save your neck.\n",
X"\n",
X" - Try to keep track of what polarity the grid locations are as you find\n",
X"      them out, they won't change until the next game.\n",
X"\n",
X" - Don't forget about the null spaces.  If a piece keeps the same color\n",
X"      when it moves, a null space is always a possibility.\n",
X"\n",
X"----------------------------------------------------------------------------\n"
X};
END_OF_FILE
if test 4562 -ne `wc -c <'help.h'`; then
    echo shar: \"'help.h'\" unpacked with wrong size!
fi
# end of 'help.h'
fi
if test -f 'menus.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'menus.c'\"
else
echo shar: Extracting \"'menus.c'\" \(2093 characters\)
sed "s/^X//" >'menus.c' <<'END_OF_FILE'
X/*********************************************************************
X                                Engarde
X                             File: menus.c
X
X  This file contains a convenience function to create menus from 
X  a structure tree.
X
X  Version 1:  1/9/92  (Bill James)
X*********************************************************************/
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <Xm/Xm.h>
X#include <Xm/Separator.h>
X#include <Xm/PushB.h>
X#include <Xm/CascadeB.h>
X#include <Xm/RowColumn.h>
X#include <Xm/Label.h>
X#include "menus.h"
X
Xvoid xs_create_menu_buttons(title, menu, menulist, nitems) 
Xchar *title;
XWidget menu;
Xxs_menu_struct *menulist;
Xint nitems;
X{
XArg wargs[1];
Xint i;
XWidgetList buttons;
Xint separators = 0;
X   buttons = (WidgetList) XtMalloc (nitems * sizeof(Widget));
X   if (title) {
X      XtCreateManagedWidget(title, xmLabelWidgetClass, menu, NULL, 0);
X      XtCreateManagedWidget("separator", xmSeparatorWidgetClass, menu, NULL,0);
X   }
X   for (i = 0; i < nitems; i++) {
X      if (menulist[i].name == NULL) {
X         XtCreateManagedWidget("separator", xmSeparatorWidgetClass, 
X				menu, NULL, 0);
X         separators++;
X      }
X      else if (menulist[i].func) {
X         buttons[i-separators] = XtCreateWidget(menulist[i].name,
X						xmPushButtonWidgetClass,
X						menu, NULL, 0);
X         XtAddCallback(buttons[i-separators], XmNactivateCallback, 
X			menulist[i].func, menulist[i].data);
X      }
X      else if (!menulist[i].sub_menu) 
X         buttons[i-separators] = XtCreateWidget(menulist[i].name,
X						xmLabelWidgetClass,
X						menu, NULL, 0);
X      else {
X         Widget sub_menu;
X         sub_menu = XmCreatePulldownMenu(menu, menulist[i].sub_menu_title,
X						NULL, 0);
X         XtSetArg(wargs[0], XmNsubMenuId, sub_menu);
X         buttons[i-separators] = XtCreateWidget(menulist[i].name,
X						xmCascadeButtonWidgetClass,
X						menu, wargs, 1);
X         xs_create_menu_buttons(menulist[i].sub_menu_title, sub_menu,
X				menulist[i].sub_menu, menulist[i].n_sub_items);
X      }
X   }
X   XtManageChildren(buttons, nitems - separators);
X}
END_OF_FILE
if test 2093 -ne `wc -c <'menus.c'`; then
    echo shar: \"'menus.c'\" unpacked with wrong size!
fi
# end of 'menus.c'
fi
if test -f 'menus.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'menus.h'\"
else
echo shar: Extracting \"'menus.h'\" \(211 characters\)
sed "s/^X//" >'menus.h' <<'END_OF_FILE'
Xtypedef struct _menu_struct {
X   char * name;
X   void (*func)();
X   caddr_t data;
X   struct _menu_struct *sub_menu;
X   int n_sub_items;
X   char *sub_menu_title;
X} xs_menu_struct;
X
Xvoid xs_create_menu_buttons();
END_OF_FILE
if test 211 -ne `wc -c <'menus.h'`; then
    echo shar: \"'menus.h'\" unpacked with wrong size!
fi
# end of 'menus.h'
fi
if test -f 'xboard.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xboard.c'\"
else
echo shar: Extracting \"'xboard.c'\" \(13185 characters\)
sed "s/^X//" >'xboard.c' <<'END_OF_FILE'
X/*********************************************************************
X                                Engarde
X                            File: xboard.c
X
X  This file contains functions to initialize board size data, display
X  board, and generally deal with all display changes during a game.
X
X  Version 1:  1/9/92  (Bill James)
X*********************************************************************/
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Xutil.h>
X#include <Xm/Xm.h>
X#include <Xm/RowColumn.h>
X#include <Xm/Form.h>
X#include <Xm/DrawingA.h>
X#include <Xm/Text.h>
X#include "board.h"
X#include "xboard.h"
X
Xextern int H,W;
Xextern SideType s[2];
Xextern BoardType *b;
Xextern Widget help; 
Xextern Widget about; 
Xextern Widget draw; 
Xextern Widget mess;
Xextern Widget lt;
Xextern Widget rt;
Xextern Pixel fore, back;
Xextern Pixmap lturn, rturn, goveright, goverleft;
X
X/*  
X   s1bxx1,bxy1 to s1bxx2,bxy2 =  left side outline.
X   s2bxx1,bxy1 to s2bxx2,bxy2 =  right side outline.
X   bxx1,bxy1 to bxx2,bxy2 =  center outline.
X   delta = size of empty space in grid box.
X   oy,ox = offsets from left and top side of window to center grid.
X   wid, hgt = width and height of window.
X   selected = whether a box is selected or not.
X   selpt = grid location of selection.
X   hold = don't allow selections until game is reset.
X   turn = 0 for left side, 1 for right side.
X   Last = location of last piece moved
X*/
X   
Xstatic int s1bxx1, s1bxx2, s2bxx1, s2bxx2;  
Xstatic int bxx1, bxy1, bxx2, bxy2;
Xstatic int delta, oy, ox; 
Xstatic Dimension wid, hgt;
Xstatic int selected = 0;
Xstatic Pt selpt;
Xstatic int hold = 0;
Xstatic int turn = 0;
Xstatic Pt Last;
X
X
X/*
X   Draws rectangle from x1,y1 to x2,y2
X*/
Xvoid DrawRect(d, w, gc, x1, y1, x2, y2)
XDisplay *d;
XWindow w;
XGC gc;
Xint x1, y1, x2, y2;
X{
X   XDrawLine(d, w, gc, x1, y1, x1, y2);
X   XDrawLine(d, w, gc, x1, y2, x2, y2);
X   XDrawLine(d, w, gc, x2, y2, x2, y1);
X   XDrawLine(d, w, gc, x2, y1, x1, y1);
X}
X
X
X/*
X   Figures the scalings necessary to fit the new size of the
X   window.
X*/
Xvoid GetXVals() 
X{
XArg wargs[20];
Xint n, i;
Xint bx, by;
X
X  n = 0;
X  hgt = 0;
X  XtSetArg(wargs[n], XmNheight, &hgt); n++;
X  XtSetArg(wargs[n], XmNwidth, &wid); n++;
X  XtGetValues(draw, wargs, n); n = 0;
X
X  bx = (wid - 22) / 12;
X  by = (hgt - 14) / 8;
X  delta = MIN2(bx,by);
X  if (delta < 0) delta = 0;
X  ox = (wid - 22 - (delta *12)) / 2 ;
X  oy = (hgt - 14 - (delta *8)) / 2;
X
X  s1bxx1 = ox + delta + 1;
X  s1bxx2 = s1bxx1 + delta + 3;
X  s2bxx1 = ox + 10 * delta + 19;
X  s2bxx2 = s2bxx1 + delta + 3;
X  bxx1 = ox + 3 * delta + 5;
X  bxx2 = bxx1 + 6 * delta + 13;
X  bxy1 = oy + delta + 1;
X  bxy2 = bxy1 + 6 * delta + 13;
X
X
X}
X
X
X/*
X   Callback function for resize and expose callbacks.  Draws the
X   game based upon window size data.
X*/
Xvoid DrawGame(w, client_data, call_data)
XWidget w;
Xcaddr_t client_data;
XXmDrawingAreaCallbackStruct call_data;
X{
XWindow win;
XDisplay *display;
XGC gc;
XXGCValues gcvals;
XXtGCMask gc_mask;
Xint i,j;
X
X  GetXVals();
X  gc_mask = 0;
X  gc = XtGetGC(draw, gc_mask, &gcvals);
X  display = XtDisplay(draw);
X  win = XtWindow(draw);
X  if (!win) return;
X
X  XClearArea(display, win, 0, 0, wid, hgt, 0);
X
X  DrawRect(display, win, gc, s1bxx1, bxy1, s1bxx2, bxy2);
X  DrawRect(display, win, gc, s2bxx1, bxy1, s2bxx2, bxy2);
X  DrawRect(display, win, gc, bxx1, bxy1, bxx2, bxy2);
X  for (i = 0; i < H; i++) {
X     DrawSpace(display, win, gc, DRAWLEFTSIDE, i);
X     DrawSpace(display, win, gc, DRAWRIGHTSIDE, i);
X     for (j = 0; j < W; j++) 
X        DrawSpace(display, win, gc, j, i);
X  }
X  for (i = 0; i < H; i++) {
X     DrawPiece(display, win, gc, DRAWLEFTSIDE, i);
X     DrawPiece(display, win, gc, DRAWRIGHTSIDE, i);
X     for (j = 0; j < W; j++) 
X        DrawPiece(display, win, gc, j, i);
X  }
X  XtReleaseGC(draw, gc);
X}
X
X
X/*
X   returns the x,y pixel location of grid spot i,j
X*/
Xvoid GetSpace(i, j, xy1, xy2)
Xint i,j;
XPt *xy1, *xy2;
X{
Xint sx;
X   if (i == DRAWLEFTSIDE) {sx = s1bxx1; i = 0;}
X   else if (i == DRAWRIGHTSIDE) {sx = s2bxx1; i = 0;}
X   else sx = bxx1;
X     
X   xy1->x = sx + (i * (delta + 2)) + 1;
X   xy2->x = xy1->x + delta + 1;
X   xy1->y = bxy1 + (j * (delta + 2)) + 1;
X   xy2->y = xy1->y + delta + 1;
X}
X
X
X/*
X   Draws grid squard i,j
X*/
Xvoid DrawSpace(d, w, gc, i, j)
XDisplay * d;
XWindow w;
XGC gc;
Xint i,j;
X{
XPt one, two;
X   GetSpace(i, j, &one, &two);
X   DrawRect(d, w, gc, one.x, one.y, two.x, two.y);
X}
X
X
X/*
X   Selects grid square i,j
X*/
Xvoid SelectSpace(i,j)
Xint i,j;
X{
XPt one, two;
XDisplay * d;
XWindow w;
XGC gc;
XXGCValues gcvals;
XXtGCMask gc_mask;
X  gc_mask = GCForeground | GCBackground;
X  gcvals.foreground = fore;
X  gcvals.background = back;
X  gc = XtGetGC(draw, gc_mask, &gcvals);
X  d = XtDisplay(draw);
X  w = XtWindow(draw);
X  GetSpace(i, j, &one, &two);
X  DrawRect(d, w, gc, one.x+1, one.y+1, two.x-1, two.y-1);
X  selected = 1;
X  XtReleaseGC(draw,gc);
X  if (!hold) XmTextSetString(mess,"");
X}
X
X
X/*
X   Unselects grid square i,j
X*/
Xvoid UnselectSpace(i,j)
Xint i,j;
X{
XPt one, two;
XDisplay * d;
XWindow w;
XGC gc;
Xint l;
XXGCValues gcvals;
XXtGCMask gc_mask;
X  gc_mask = GCForeground | GCBackground;
X  gcvals.foreground = back;
X  gcvals.background = fore;
X  gc = XtGetGC(draw, gc_mask, &gcvals);
X  d = XtDisplay(draw);
X  w = XtWindow(draw);
X  GetSpace(i, j, &one, &two);
X  DrawRect(d, w, gc, one.x+1, one.y+1, two.x-1, two.y-1);
X  selected = 0;
X  XtReleaseGC(draw,gc);
X}
X
X
X/*
X   Draws piece depending on shape and color
X*/
Xvoid DrawPiece(d, w, gc, i, j) 
XDisplay * d;
XWindow w;
XGC gc;
Xint i;
Xint j;
X{
XPt one, two;
Xint x1, y1, x2, y2, ht, wd;
X  GetSpace(i, j, &one, &two);
X  x1 = one.x+5;
X  y1 = one.y+5;
X  x2 = two.x-5;
X  y2 = two.y-5;
X  ht =  y2 - y1+1;
X  wd =  x2 - x1+1;
X  if (i == DRAWLEFTSIDE) {
X     if (s[0].p[j]) {
X        if (s[0].p[j]->type == PIECE_SQUARE) {
X           DrawRect(d, w, gc, x1, y1, x2, y2);
X           if (s[0].p[j]->color == PIECE_BLACK) 
X              XFillRectangle(d, w, gc, x1, y1, wd, ht);
X        }
X        if (s[0].p[j]->type == PIECE_ROUND) {
X           XDrawArc(d, w, gc, x1, y1, wd, ht, 0, 64*360);
X           if (s[0].p[j]->color == PIECE_BLACK) 
X              XFillArc(d, w, gc, x1, y1, wd, ht, 0, 64*360);
X        }
X     }
X  }
X  else if (i == DRAWRIGHTSIDE) { 
X     if (s[1].p[j]) {
X        if (s[1].p[j]->type == PIECE_SQUARE) {
X           DrawRect(d, w, gc, x1, y1, x2, y2);
X           if (s[1].p[j]->color == PIECE_BLACK) 
X              XFillRectangle(d, w, gc, x1, y1, wd, ht);
X        }
X        if (s[1].p[j]->type == PIECE_ROUND) {
X           XDrawArc(d, w, gc, x1, y1, wd, ht, 0, 64*360);
X           if (s[1].p[j]->color == PIECE_BLACK) 
X              XFillArc(d, w, gc, x1, y1, wd, ht, 0, 64*360);
X        }
X     }
X  }
X  else {
X     if (b->pieces[i][j]) {
X        if (b->pieces[i][j]->type == PIECE_SQUARE) {
X           XDrawRectangle(d, w, gc, x1, y1, wd, ht);
X           if (b->pieces[i][j]->color == PIECE_BLACK) 
X              XFillRectangle(d, w, gc, x1, y1, wd, ht);
X        }
X        if (b->pieces[i][j]->type == PIECE_ROUND) {
X           XDrawArc(d, w, gc, x1, y1, wd, ht, 0, 64*360);
X           if (b->pieces[i][j]->color == PIECE_BLACK) 
X              XFillArc(d, w, gc, x1, y1, wd, ht, 0, 64*360);
X        }
X     }
X  }
X}
X
X
X/*
X   Button press callback.  Determines actions based upon location
X   of pointer when button is pressed, whether a square is already
X   selected, etc.
X*/
Xvoid ButtonPress1 (wg, event, params, num_params)
XWidget wg;                                       /*The draw widget.*/
XXButtonEvent *event;                            /*The button event.*/
XString *params;                                 /*Not used.*/
XCardinal num_params;                            /*Not used.*/
X{
Xint x,y,i,j,m,n;
XPt t;
XArg wargs[2];
X   if (hold) return;
X   x = event->x;
X   y = event->y;
X   if ((y > bxy1) && (y < bxy2)) {
X      if ((x > s1bxx1) && (x < s1bxx2)) 
X         i = DRAWLEFTSIDE;
X      else if ((x > s2bxx1) && (x < s2bxx2)) 
X         i = DRAWRIGHTSIDE;
X      else if ((x > bxx1) && (x < bxx2)) 
X         i = (x-bxx1) / (delta+2);
X      else return;
X      j = (y-bxy1) / (delta+2);
X   }
X   else return;
X   if (!selected) {
X        if (DGetPiece(i,j)) {
X	   SelectSpace(i,j);
X           selected = 1;
X           selpt.x = i;
X           selpt.y = j;
X        }
X        else {
X          XmTextSetString(mess, STR_BAD_SELECT);
X        }
X   }
X   else {
X        if ((i == selpt.x) && (j == selpt.y)) {
X           UnselectSpace(selpt.x, selpt.y);
X           selected = 0;
X        }
X        else if (DGetPiece(i,j)) {
X           UnselectSpace(selpt.x, selpt.y);
X	   SelectSpace(i,j);
X           selpt.x = i;
X           selpt.y = j;
X        }
X        else {
X          t.x = i; t.y = j;
X          if (CheckMove(selpt, t)) {
X             UnselectSpace(selpt.x, selpt.y);
X             MvPiece(selpt, t);
X             Last.x = i; Last.y = j;
X             selected = 0;
X             turn ^= 1;
X             ChangeTurn();
X          }
X        }
X        if (CheckWinner(&i, &j, &x, &y)) {
X           n = 0;
X           if (b->pieces[i][j]->color == PIECE_BLACK) {
X              XmTextSetString(mess,STR_RIGHT_WIN);
X              XtSetArg(wargs[n],XmNlabelPixmap, goveright); n++;
X           }
X           else {
X              XmTextSetString(mess,STR_LEFT_WIN);
X              XtSetArg(wargs[n],XmNlabelPixmap, goverleft); n++;
X           }
X           hold = 1;
X           for (m = 0; m < 4; m++) {
X              SelectSpace(i,j);
X              i+= x; j+=y;
X           }
X           XtSetValues(lt, wargs, n);
X           XtSetValues(rt, wargs, n);
X        }
X           
X   }
X}
X
X
X/*
X   Moves piece from src grid location to dest grid location, rewriting
X   piece on screen
X*/
Xvoid MvPiece(src, dst)
XPt src,dst;
X{
XPt sone, stwo;
XPt done, dtwo;
XDisplay * d;
XWindow w;
XGC gc;
Xint l;
XXGCValues gcvals;
XXtGCMask gc_mask;
X  gc_mask = GCForeground | GCBackground;
X  gcvals.foreground = fore;
X  gcvals.background = back;
X  gc = XtGetGC(draw, gc_mask, &gcvals);
X  d = XtDisplay(draw);
X  w = XtWindow(draw);
X  GetSpace(src.x, src.y, &sone, &stwo);
X  GetSpace(dst.x, dst.y, &done, &dtwo);
X  XClearArea(d, w, sone.x+1, sone.y+1, delta, delta, 0);
X  if (dst.x == DRAWLEFTSIDE)
X     s[0].p[dst.y] = DGetPiece(src.x,src.y);
X  else if (dst.x == DRAWRIGHTSIDE)
X     s[1].p[dst.y] = DGetPiece(src.x,src.y);
X  else 
X     b->pieces[dst.x][dst.y] = DGetPiece(src.x,src.y);
X  if (src.x == DRAWLEFTSIDE)
X     s[0].p[src.y] = NULL;
X  else if (src.x == DRAWRIGHTSIDE)
X     s[1].p[src.y] = NULL;
X  else 
X     b->pieces[src.x][src.y] = NULL;
X  if ((dst.x != DRAWLEFTSIDE) && (dst.x != DRAWRIGHTSIDE))
X     Magnetize(dst.x,dst.y);
X  DrawPiece(d, w, gc, dst.x, dst.y);
X  XtReleaseGC(draw, gc);
X}
X
X
X/*
X   returns piece at location i,j
X*/
XPieceType * DGetPiece(i,j)
Xint i,j;
X{
X  if (i == DRAWLEFTSIDE) 
X     return (s[0].p[j]);
X  else if (i == DRAWRIGHTSIDE) 
X     return (s[1].p[j]);
X  else 
X     return (b->pieces[i][j]);
X}
X
X
X/*
X    Checks a move against the rules of the games
X*/
Xint CheckMove(one, two)
XPt one, two;
X{
Xint i,j,l,m;
X   if ((one.x == Last.x) && (one.y == Last.y)) {
X      XmTextSetString(mess,STR_MOVE_LAST);
X      return(0);
X   }
X   if (two.x > W) {
X      XmTextSetString(mess,STR_SIDE_MOVE);
X      return(0);
X   }
X   if (one.x > W) {
X      if (turn != (one.x - DRAWLEFTSIDE)) {
X         XmTextSetString(mess,STR_WRONG_SIDE);
X         return(0);
X      }
X      return(1);
X   }
X   i = two.x - one.x;
X   j = SGN(i);
X   i = ABS(i);
X   l = two.y - one.y;
X   m = SGN(l);
X   l = ABS(l);
X   if ((i > 2) || (l > 2)) {
X      XmTextSetString(mess,STR_FAR_MOVE);
X      return(0);
X   }
X   if ((i == 2) || (l == 2)) {
X      if (!b->pieces[one.x+((i/2)*j)][one.y+((l/2)*m)]) {
X         XmTextSetString(mess,STR_MUST_JUMP);
X         return(0);
X      }
X      if ((i == 1) || (l == 1)) {
X         XmTextSetString(mess,STR_SAME_DIR);
X         return(0);
X      }
X   }
X   return(1);
X}
X
X
X/*
X   Resets the board to start state
X*/
Xvoid ResetBoard(w, client_data, call_data)
XWidget w;
Xcaddr_t client_data;
XXmAnyCallbackStruct *call_data;
X{
X  KillBoard(s);
X  InitBoard(s,H,W); 
X  BoardShuffle();
X  DrawGame(w,client_data, call_data);
X  hold = 0;
X  selected = 0;
X  Last.x = -1;
X  Last.y = -1;
X  turn = 0;
X  XmTextSetString(mess,"");
X  ChangeTurn();
X}
X
X
X/*
X   Changes the turn pixmaps
X*/
Xvoid ChangeTurn() 
X{
XArg wargs[10];
Xint n;
X  if (turn == 1) {
X     n = 0;
X     XtSetArg(wargs[n],XmNlabelPixmap, rturn); n++;
X     XtSetValues(lt, wargs, n);
X     XtSetValues(rt, wargs, n);
X  }
X  else {
X     n = 0;
X     XtSetArg(wargs[n],XmNlabelPixmap, lturn); n++;
X     XtSetValues(lt, wargs, n);
X     XtSetValues(rt, wargs, n);
X  }
X}
X
X
X/*
X    Brings up the help window
X*/
Xvoid ShowHelp(w, client_data, call_data)
XWidget w;
Xcaddr_t client_data;
XXmAnyCallbackStruct *call_data;
X{
X   XtManageChild(help);
X}
X
X
X/*
X    Closes the help window
X*/
Xvoid CloseHelp(w, client_data, call_data)
XWidget w;
Xcaddr_t client_data;
XXmAnyCallbackStruct *call_data;
X{
X   XtUnmanageChild(help);
X}
X
X
X
X/*
X    Brings up the about window
X*/
Xvoid ShowAbout(w, client_data, call_data)
XWidget w;
Xcaddr_t client_data;
XXmAnyCallbackStruct *call_data;
X{
X   XtManageChild(about);
X}
X
X
X/*
X    Closes the about window
X*/
Xvoid CloseAbout(w, client_data, call_data)
XWidget w;
Xcaddr_t client_data;
XXmAnyCallbackStruct *call_data;
X{
X   XtUnmanageChild(about);
X}
END_OF_FILE
if test 13185 -ne `wc -c <'xboard.c'`; then
    echo shar: \"'xboard.c'\" unpacked with wrong size!
fi
# end of 'xboard.c'
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
Molecular Simulations, Inc.             mail: dcmartin@msi.com
796 N. Pastoria Avenue                  uucp: uunet!dcmartin
Sunnyvale, California 94086             at&t: 408/522-9236
