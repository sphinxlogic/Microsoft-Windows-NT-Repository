Newsgroups: comp.sources.x
Path: uunet!think.com!mips!msi!dcmartin
From: Dave Lemke <lupine!lemke@uunet.UU.NET>
Subject: v16i094: Spy vs "BoB", Part01/01
Message-ID: <1992Feb22.190436.4644@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Date: Sat, 22 Feb 1992 19:04:36 GMT
Approved: dcmartin@msi.com

[ a neat little game.. good to waste time during compiles! - dcm] 

Submitted-by: Dave Lemke <lupine!lemke@uunet.UU.NET>
Posting-number: Volume 16, Issue 94
Archive-name: spy.vs.bob/part01

# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# The tool that generated this appeared in the comp.sources.unix newsgroup;
# send mail to comp-sources-unix@uunet.uu.net if you want that tool.
# If this archive is complete, you will see the following message at the end:
#		"End of archive 1 (of 1)."
# Contents:  README Imakefile Makefile score.c svb.man svs.c
# Wrapped by dcmartin@fascet on Sat Feb 22 11:01:46 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(495 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XSpy vs "BoB" is a simple arcade game, based on Dodger by Bert Nelson
Xand an Apple ][ game, Spy vs Spy.  Its been tested with SunOS 4.x, and
Xshould run with minimal changes on any BSD-based UNIX.  Other OS's will
Xneed to come up with another way to handle select().
X
XTo install, change the Imakefile to point to the proper scorefile,
Xxmkmf and make.
X
XThe scorefile either needs to be mode 666 or the game should be setuid.
X
XSend any comments, bug fixes, enhancements to
XDave Lemke
Xlemke@ncd.com
X
END_OF_FILE
if test 495 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(139 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
XSRCS = score.c svs.c
XOBJS = score.o svs.o
XLOCAL_LIBRARIES = -lX11
XDEFINES = -DSCOREFILE=\"/tmp/svb.scorefile\"
X
XComplexProgramTarget(svb)
X
END_OF_FILE
if test 139 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(10299 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and <Imakefile>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.68 91/07/30 11:34:39 rws Exp $
X
X# operating system:  SunOS 4.1.1
X
X# $XConsortium: sunLib.rules,v 1.6 91/03/24 17:55:58 rws Exp $
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X      PROJECTROOT = /usr/X11/R5
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/X11/R5/lib
X           BINDIR = /usr/X11/R5/bin
X          INCROOT = /usr/X11/R5/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/X11/R5/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X# $XConsortium: sunLib.tmpl,v 1.11 91/07/31 11:32:08 rws Exp $
X
XSHLIBLDFLAGS = -assert pure-text
XPICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
XSRCS = score.c svs.c
XOBJS = score.o svs.o
XLOCAL_LIBRARIES = -lX11
XDEFINES = -DSCOREFILE=\"/tmp/svb.scorefile\"
X
X PROGRAM = svb
X
Xall:: svb
X
Xsvb: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xsaber_svb:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xosaber_svb:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xinstall:: svb
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  svb $(DESTDIR)$(BINDIR)
X
Xinstall.man:: svb.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) svb.man $(DESTDIR)$(MANDIR)/svb.$(MANSUFFIX)
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	# load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	# load $(ALLDEFINES) $(OBJS)
X
X# -------------------------------------------------------------------------
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
END_OF_FILE
if test 10299 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'score.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'score.c'\"
else
echo shar: Extracting \"'score.c'\" \(7183 characters\)
sed "s/^X//" >'score.c' <<'END_OF_FILE'
X/*
X * SvB score file
X */
X/*
X * Copyright 1992 David Lemke and Network Computing Devices
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of Network Computing Devices not be
X * used in advertising or publicity pertaining to distribution of the
X * software without specific, written prior permission.  Network Computing
X * Devices makes no representations about the suitability of this software
X * for any purpose.  It is provided "as is" without express or implied
X * warranty.
X *
X * NETWORK COMPUTING DEVICES DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
X * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
X * IN NO EVENT SHALL NETWORK COMPUTING DEVICES BE LIABLE FOR ANY SPECIAL,
X * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
X * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
X * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
X * OR PERFORMANCE OF THIS SOFTWARE.
X *
X * Author:
X *		Dave Lemke
X *		lemke@ncd.com
X *
X *		Network Computing Devices, Inc
X *		350 North Bernardo Ave
X *		Mountain View, CA 94043
X *
X *	@(#)score.c	1.3	92/01/20
X *
X */
X
X#include	<stdio.h>
X#include	<X11/Xos.h>
X#include	<X11/Xlib.h>
X#include	<X11/Xutil.h>
X#include	<sys/file.h>
X
Xextern Display *dpy;
Xextern Window game_win;
Xextern GC   text_gc;
X
Xextern char user_name[];
Xextern int  highscore;
X
Xextern char get_key();
X
Xstatic void find_personal_best();
Xstatic void draw_scores();
X
Xvoid        update_scores();
X
X#define	NUM_TOP_SCORES	25
X#define	SCORES_PER_USER	5
X
X#define	SCORE_Y_INC	15
X#define	TOP_SCORE_Y	30
X#define	PERSONAL_SCORE_Y	(3 * TOP_SCORE_Y + (NUM_TOP_SCORES * SCORE_Y_INC))
X#define	SCORE_X		10
X
X#define	MESSAGE_Y	(PERSONAL_SCORE_Y + (SCORES_PER_USER + 1) * SCORE_Y_INC)
X
X#ifndef SCOREFILE
X#define	SCOREFILE	"/tmp/svb.scores"
X#endif
X
Xtypedef struct _score {
X    char        name[40];
X    int         score;
X    int         ledge;
X}           Score;
X
XScore       top_scores[NUM_TOP_SCORES];
XScore       personal[SCORES_PER_USER];
XBool        read_scores = False;
X
Xstatic void
Xwait_for_key()
X{
X    XEvent      ev;
X    char        c;
X
X    while (1) {
X	XNextEvent(dpy, &ev);
X	if (ev.type == Expose && ev.xexpose.count == 0)
X	    draw_scores();
X	else if (ev.type == KeyPress) {
X	    c = get_key((XKeyPressedEvent *) & ev);
X	    if (c == 'q')
X		exit(0);
X	    else if (c == 'h') {
X		update_scores();
X		draw_scores();
X	    } else if (c == ' ' || c == 's')
X		return;
X	}
X    }
X}
X
Xstatic void
Xdraw_scores()
X{
X    int         i,
X                y;
X    char        scorebuf[256];
X
X    XClearWindow(dpy, game_win);
X    sprintf(scorebuf, "%40s", "Top Scores");
X    XDrawImageString(dpy, game_win, text_gc, SCORE_X, 15,
X		     scorebuf, strlen(scorebuf));
X    y = TOP_SCORE_Y;
X    for (i = 0; i < NUM_TOP_SCORES; i++) {
X	sprintf(scorebuf, "          %2d  %30s  %7d   Ledge %3d",
X		i + 1, top_scores[i].name, top_scores[i].score,
X		top_scores[i].ledge);
X	XDrawImageString(dpy, game_win, text_gc, SCORE_X, y,
X			 scorebuf, strlen(scorebuf));
X	y += SCORE_Y_INC;
X    }
X    sprintf(scorebuf, "%40s", "Personal Top Scores");
X    y = PERSONAL_SCORE_Y;
X    XDrawImageString(dpy, game_win, text_gc, SCORE_X, y - 2 * SCORE_Y_INC,
X		     scorebuf, strlen(scorebuf));
X    for (i = 0; i < SCORES_PER_USER; i++) {
X	sprintf(scorebuf, "          %2d  %30s  %7d   Ledge %3d",
X		i + 1, personal[i].name, personal[i].score,
X		personal[i].ledge);
X	XDrawImageString(dpy, game_win, text_gc, SCORE_X, y,
X			 scorebuf, strlen(scorebuf));
X	y += SCORE_Y_INC;
X    }
X
X    sprintf(scorebuf, "          'q' to Quit, 's' to Start");
X    XDrawImageString(dpy, game_win, text_gc, SCORE_X, MESSAGE_Y,
X		     scorebuf, strlen(scorebuf));
X}
X
Xstatic void
Xfind_personal_best()
X{
X    int         i,
X                j;
X
X    for (i = 0; i < SCORES_PER_USER; i++) {
X	strcpy(personal[i].name, user_name);
X	personal[i].score = 0;
X	personal[i].ledge = 0;
X    }
X    for (i = 0, j = 0; i < NUM_TOP_SCORES; i++) {
X	if (strcmp(top_scores[i].name, user_name) == 0) {
X	    personal[j].score = top_scores[i].score;
X	    personal[j].ledge = top_scores[i].ledge;
X	    j++;
X	    if (j == SCORES_PER_USER)
X		return;;
X	}
X    }
X}
X
X/*
X * reads/inits score file
X */
Xvoid
Xupdate_scores()
X{
X    FILE       *fp;
X    int         i;
X    char        buf[256];
X
X    fp = fopen(SCOREFILE, "r");
X    if (fp) {
X	flock(fileno(fp), LOCK_EX);
X	i = 0;
X	while (fgets(buf, 256, fp)) {
X	    sscanf(buf, "%s %d %d", top_scores[i].name, &top_scores[i].score,
X		   &top_scores[i].ledge);
X	    i++;
X	}
X	if (!read_scores)
X	    find_personal_best();
X	fclose(fp);
X    } else {
X	/* do reinit if already running and unreadable file */
X	if (read_scores)
X	    return;
X	for (i = 0; i < NUM_TOP_SCORES; i++) {
X	    strcpy(top_scores[i].name, "Nobody");
X	    top_scores[i].score = 0;
X	    top_scores[i].ledge = 0;
X	}
X	for (i = 0; i < SCORES_PER_USER; i++) {
X	    strcpy(personal[i].name, user_name);
X	    personal[i].score = 0;
X	    personal[i].ledge = 0;
X	}
X    }
X    read_scores = True;
X    highscore = personal[0].score;
X}
X
X/*
X * displays all current scores
X */
Xvoid
Xshow_scores()
X{
X    update_scores();
X    draw_scores();
X    wait_for_key();
X}
X
Xstatic void
Xwrite_scores()
X{
X    FILE       *fp;
X    int         i;
X
X    fp = fopen(SCOREFILE, "w");
X    if (fp) {
X	flock(fileno(fp), LOCK_EX);
X	for (i = 0; i < NUM_TOP_SCORES; i++)
X	    fprintf(fp, "%s %d %d\n", top_scores[i].name,
X		    top_scores[i].score, top_scores[i].ledge);
X	fclose(fp);
X    }
X}
X
X/*
X * adds score to table
X */
Xadd_score(sc, ledge)
X    int         sc;
X    int         ledge;
X{
X    int         i,
X                j;
X    int         user_count = 0;
X    int         replace;
X    int         low_user = 0;
X
X    update_scores();		/* make sure they're up-to-date */
X    for (i = 0; i < NUM_TOP_SCORES; i++) {
X	if (strcmp(top_scores[i].name, user_name) == 0) {
X	    user_count++;
X	    low_user = top_scores[i].score;
X	    replace = i;
X	}
X    }
X
X    /*
X     * punt if we have the full number of scores && the new one is too low to
X     * care about
X     */
X    if (user_count >= SCORES_PER_USER) {
X	if (sc <= low_user) {
X	    return;
X	}
X    } else {
X	replace = NUM_TOP_SCORES - 1;
X    }
X
X    for (i = 0; i < NUM_TOP_SCORES; i++) {
X	if (sc > top_scores[i].score) {
X	    for (j = replace; j > i; j--) {
X		strcpy(top_scores[j].name, top_scores[j - 1].name);
X		top_scores[j].score = top_scores[j - 1].score;
X		top_scores[j].ledge = top_scores[j - 1].ledge;
X	    }
X	    strcpy(top_scores[i].name, user_name);
X	    top_scores[i].score = sc;
X	    top_scores[i].ledge = ledge;
X	    break;
X	}
X    }
X    for (i = 0; i < SCORES_PER_USER; i++) {
X	if (sc > personal[i].score) {
X	    for (j = SCORES_PER_USER - 1; j > i; j--) {
X		personal[j].score = personal[j - 1].score;
X		personal[j].ledge = personal[j - 1].ledge;
X	    }
X	    personal[i].score = sc;
X	    personal[i].ledge = ledge;
X	    break;
X	}
X    }
X    highscore = personal[0].score;
X    write_scores();
X}
END_OF_FILE
if test 7183 -ne `wc -c <'score.c'`; then
    echo shar: \"'score.c'\" unpacked with wrong size!
fi
# end of 'score.c'
fi
if test -f 'svb.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'svb.man'\"
else
echo shar: Extracting \"'svb.man'\" \(1149 characters\)
sed "s/^X//" >'svb.man' <<'END_OF_FILE'
X.\" @(#)svb.man	1.1E%
X.TH svb 1 "11 Feb 1992"
X.SH NAME
Xsvb \- Spy vs "BoB"
X.SH SYNOPSIS
X.B svb
X[
X.BI \-display " display_name"
X]
X.SH DESCRIPTION
XIn
X.I svb,
Xyou control the Spy (Pink) who is trying to escape the building.  The
X"BoB"s in the elevators are trying to stop you.  The goal is to get
Xacross the screen without being smashed by a "BoB" before time runs 
Xout.  Any leftover time is added to your score as a bonus.
XThe "BoB"s
Xwill change speed each time they change direction.  On each ledge some
X"SLACK" will appear after a random delay.  Picking this up is
Xworth 500 bonus points.
X.PP
XOnce you reach the top, you start over at the bottom, one ledge higher.
XThe "BoB"s also travel a shorter route, so they bounce faster.
X.SH CONTROLS
XYou can control your Pinks with either the keyboard
Xor the mouse.  With the keyboard, 'j' and 'k' change your direction,
Xand 'SPACE' stops you.  With the mouse, you run as long as the button
Xis held down.  Button 1 makes you run left, and any other button 
Xmakes you run right.
X.SH SEE ALSO
X    dodger(6)
X.SH COPYRIGHT
XCopyright (c) 1992 by David Lemke & Network Computing Devices, Inc.
X.br
X(lemke@ncd.com)
END_OF_FILE
if test 1149 -ne `wc -c <'svb.man'`; then
    echo shar: \"'svb.man'\" unpacked with wrong size!
fi
# end of 'svb.man'
fi
if test -f 'svs.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'svs.c'\"
else
echo shar: Extracting \"'svs.c'\" \(25542 characters\)
sed "s/^X//" >'svs.c' <<'END_OF_FILE'
X/*
X * Spy vs "Bob"
X *
X * Based on the Apple ][ game "Spy vs Spy", and 'dodger' by Bert Nelson
X */
X
X/*
X * Copyright 1992 David Lemke and Network Computing Devices
X *
X * Permission to use, copy, modify, distribute, and sell this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of Network Computing Devices not be
X * used in advertising or publicity pertaining to distribution of the
X * software without specific, written prior permission.  Network Computing
X * Devices makes no representations about the suitability of this software
X * for any purpose.  It is provided "as is" without express or implied
X * warranty.
X *
X * NETWORK COMPUTING DEVICES DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
X * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
X * IN NO EVENT SHALL NETWORK COMPUTING DEVICES BE LIABLE FOR ANY SPECIAL,
X * INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
X * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
X * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
X * OR PERFORMANCE OF THIS SOFTWARE.
X *
X * Author:
X *		Dave Lemke
X *		lemke@ncd.com
X *
X *		Network Computing Devices, Inc
X *		350 North Bernardo Ave
X *		Mountain View, CA 94043
X *
X *	@(#)svs.c	1.9	92/02/10
X *
X */
X
X#include	<stdio.h>
X#include	<X11/Xos.h>
X#include 	<sys/types.h>
X#include 	<sys/time.h>
X#include	<errno.h>
X#include	<X11/Xlib.h>
X#include	<X11/Xutil.h>
X#include	<math.h>
X
Xextern char *getenv();
X
Xextern int  errno;
Xchar       *progname;
Xchar        user_name[40];
XBool        debug = False;
X
X#define	rnd(x)	(random() % (x))
X
X/* game stuff */
X#define	NUM_LEDGES		10
X#define	NUM_VATORS		5
X
X#define	MIN_LEDGE		3	/* tightest it will get */
X
X#define	NUM_LIVES		5
X#define	START_LEDGE		(NUM_LEDGES - 1)
X#define	START_TIME		100
X#define	DELAY_TIME		20000
X#define	ROUNDS_PER_UPDATE	8
X
X#define	GIFT_SCORE		500
X#define	GIFT_NOTYET		1
X#define	GIFT_OUT		2
X#define	GIFT_TAKEN		3
X
X
Xextern void update_scores();
Xextern void show_scores();
X
Xint         score = 0;
Xint         highscore = 0;
Xint         time_left;
Xint         time_interval = ROUNDS_PER_UPDATE;
Xint         lives = 0;
Xint         ledge_num;
Xint         ledge_side;
Xint         level;
Xint	    ledge;
Xint         vator_loc[NUM_VATORS];
Xint         vator_speed[NUM_VATORS];
Xint         vator_run;
Xint         man_x,
X            man_y;
Xint         man_speed;
Xint         man_delta;
X
Xint         gift_x,
X            gift_y;
Xint         gift_state;
XBool        refresh_gift;
Xint         gift_time;
X
X/* increase with each level */
Xdouble      level_factor = 1.0;
X
X/* speeds */
X#define	MIN_VATOR_SPEED		5
X#define	VATOR_SPEED_RANGE	10
X
X#ifdef fast
X#define	LEVEL_INCREASE		(0.2)
X#else
X#define	LEVEL_INCREASE		(0.0)
X#endif
X
X/* X stuff */
X
XDisplay    *dpy;
XWindow      game_win;
XColormap    cmap;
XGC          text_gc;
XGC          vator_gc;
XGC          draw_gc;
Xunsigned long man_color,
X            vator_color,
X            vator_bg_color,
X            timer_color,
X            gift_color,
X            splat_color,
X            ledge_color;
Xunsigned long text_color;
Xunsigned long bg_color;
XBool        paused = False;
XPixmap      man_left,
X            man_right,
X            man_stand,
X            splat_map,
X            slack_map,
X            vator_map;
X
X#define	MAN		0
X#define	VATOR		1
X#define	TIMER		2
X#define	LEDGE		3
X#define	TEXT		4
X#define	BACKGROUND	5
X#define	GIFT		6
X#define	VATOR_BG	7
X#define	SPLAT		8
X
Xstatic char *game_colors[] = {
X    "pink",			/* MAN */
X    "blue",			/* VATOR */
X    "yellow",			/* TIMER */
X    "brown",			/* LEDGE */
X    "white",			/* TEXT */
X    "black",			/* BACKGROUND */
X    "green",			/* GIFT */
X    "white",			/* VATOR_BG */
X    "pink",			/* SPLAT */
X};
X
X
Xstatic char bob_vator_bits[] = {
X    0xff, 0x01, 0x50, 0x25, 0x00, 0xfe, 0x03, 0x07, 0x00, 0xfc, 0xff, 0x03,
X    0x80, 0x03, 0x03, 0x00, 0xff, 0x5e, 0x06, 0x00, 0x03, 0x03, 0xc0, 0x97,
X    0x44, 0x0a, 0x00, 0x03, 0x03, 0xc0, 0x17, 0xa9, 0x1d, 0x00, 0x03, 0x03,
X    0xe0, 0x7f, 0xdd, 0x7f, 0x00, 0x03, 0x03, 0xf0, 0xff, 0xff, 0xf3, 0x00,
X    0x03, 0x03, 0xf0, 0xff, 0xdf, 0xf0, 0x00, 0x03, 0x03, 0xf0, 0xa5, 0x17,
X    0xf0, 0x01, 0x03, 0x03, 0xf0, 0x00, 0x00, 0xf0, 0x00, 0x03, 0x03, 0xf8,
X    0x00, 0x00, 0xe8, 0x00, 0x03, 0x03, 0xf0, 0x01, 0x00, 0xe8, 0x00, 0x03,
X    0x03, 0xf0, 0x00, 0x00, 0xe4, 0x00, 0x03, 0x03, 0xf8, 0x00, 0x00, 0xe8,
X    0x00, 0x03, 0x03, 0xf0, 0x09, 0x80, 0xfb, 0x00, 0x03, 0x03, 0xe8, 0x3e,
X    0xe0, 0xee, 0x00, 0x03, 0x03, 0xf8, 0x68, 0x70, 0xfd, 0x00, 0x03, 0x03,
X    0x30, 0xee, 0x78, 0xe3, 0x00, 0x03, 0x03, 0x30, 0xf2, 0xa8, 0x60, 0x00,
X    0x03, 0x03, 0x30, 0xb4, 0xc0, 0x63, 0x00, 0x03, 0x03, 0x30, 0x98, 0x00,
X    0x40, 0x00, 0x03, 0x03, 0x20, 0x80, 0x00, 0xa0, 0x00, 0x03, 0x03, 0xb0,
X    0x40, 0x00, 0x60, 0x00, 0x03, 0x03, 0x80, 0xd1, 0x70, 0x18, 0x00, 0x03,
X    0x03, 0xc0, 0xe9, 0x8e, 0x0d, 0x00, 0x03, 0x03, 0x80, 0xf7, 0x87, 0x3f,
X    0x00, 0x03, 0x03, 0x80, 0xfa, 0xea, 0x0c, 0x00, 0x03, 0x03, 0x80, 0x32,
X    0x49, 0x0c, 0x00, 0x03, 0x03, 0x00, 0x35, 0x35, 0x0c, 0x00, 0x03, 0x03,
X    0x00, 0xf1, 0x0f, 0x06, 0x00, 0x03, 0x03, 0x00, 0xf6, 0x15, 0x02, 0x00,
X    0x03, 0x03, 0x10, 0xda, 0x0b, 0x03, 0x00, 0x03, 0x03, 0x48, 0x4e, 0x00,
X    0x01, 0x00, 0x03, 0x03, 0x58, 0x77, 0x80, 0x00, 0x00, 0x03, 0x03, 0xe2,
X    0xf3, 0xc0, 0x00, 0x00, 0x03, 0x03, 0xcc, 0x41, 0x3f, 0x00, 0x00, 0x03,
X    0x03, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0xdc, 0x00, 0x00, 0x00,
X    0x00, 0x03, 0x07, 0x70, 0x00, 0x00, 0x00, 0x80, 0x03, 0xff, 0x01, 0x00,
X0x00, 0x00, 0xfe, 0x03};
X
Xstatic char man_left_bits[] = {
X    0x18, 0x01, 0x00, 0xf8, 0x00, 0x00, 0x7e, 0x00, 0x00, 0xfe, 0x00, 0x00,
X    0xfc, 0x01, 0x00, 0xfa, 0x03, 0x00, 0xf1, 0xff, 0x01, 0x20, 0xff, 0x01,
X    0x84, 0x1f, 0x01, 0x86, 0x3f, 0x01, 0xce, 0xff, 0x01, 0x78, 0xff, 0x03,
X    0x20, 0xff, 0x01, 0x00, 0xff, 0x00, 0x80, 0x7f, 0x04, 0xc0, 0xfe, 0x0e,
X0xc0, 0x9c, 0x0b, 0x80, 0x09, 0x09, 0x00, 0x03, 0x00, 0xc0, 0x01, 0x00};
X
Xstatic char man_right_bits[] = {
X    0x00, 0x88, 0x01, 0x00, 0xf0, 0x01, 0x00, 0xe0, 0x07, 0x00, 0xf0, 0x07,
X    0x00, 0xf8, 0x03, 0x00, 0xfc, 0x05, 0xf8, 0xff, 0x08, 0xf8, 0x4f, 0x00,
X    0x88, 0x1f, 0x02, 0xc8, 0x1f, 0x06, 0xf8, 0x3f, 0x07, 0xfc, 0xef, 0x01,
X    0xf8, 0x4f, 0x00, 0xf0, 0x0f, 0x00, 0xe2, 0x1f, 0x00, 0xf7, 0x37, 0x00,
X0x9d, 0x33, 0x00, 0x09, 0x19, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x38, 0x00};
X
Xstatic char man_stand_bits[] = {
X    0x80, 0x03, 0x00, 0xc0, 0x07, 0x00, 0xf0, 0x1f, 0x00, 0xc0, 0x07, 0x00,
X    0x80, 0x03, 0x00, 0x00, 0x01, 0x00, 0x80, 0x03, 0x00, 0xf0, 0x0f, 0x00,
X    0xfc, 0x1f, 0x00, 0xfe, 0xbf, 0x0f, 0xf3, 0x7f, 0x01, 0xf3, 0xff, 0x01,
X    0xfe, 0x1f, 0x01, 0xfc, 0x1f, 0x00, 0xf8, 0x3f, 0x00, 0xf0, 0x3f, 0x00,
X0xf0, 0x7f, 0x00, 0xc0, 0x0c, 0x00, 0xc0, 0x0c, 0x00, 0xf0, 0x3c, 0x00};
X
X
Xstatic char slack_bits[] = {
X0xeb, 0x56, 0xa9, 0x32, 0xeb, 0x32, 0xaa, 0x52, 0xbb, 0x56};
X
Xstatic char splatter_bits[] = {
X    0x68, 0x20, 0x02, 0x00, 0x2b, 0x49, 0x31, 0x1e, 0x3e, 0x92, 0x88, 0x11,
X    0x26, 0x22, 0x45, 0x1e, 0x6e, 0xec, 0xe3, 0x07, 0xf8, 0xff, 0xff, 0x00,
X    0x00, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X0x00, 0x00, 0x00, 0x00};
X
X#define	MAN_WIDTH	20
X#define	MAN_HEIGHT	20
X#define	MAN_DELTA	6	/* motion per step */
X#define	MIN_MAN_DELTA	4
X
X#define SPLAT_WIDTH	30
X#define SPLAT_HEIGHT	10
X
X#define	VATOR_WIDTH	50
X#define	VATOR_HEIGHT	40
X#define	VATOR_GAP	40	/* space between them */
X
X#define	GIFT_WIDTH	15
X#define	GIFT_HEIGHT	5
X
X#define	LEDGE_WIDTH	30
X#define	LEDGE_HEIGHT	4
X
X#define	LEDGE_GAP	((int)(VATOR_HEIGHT * 1.2 + LEDGE_HEIGHT))
X
X#define	TIMER_HEIGHT	25
X#define	TIMER_SLICE	1	/* visual size of each tick */
X
X#define	INFO_HEIGHT	100	/* size of timer, score, etc */
X
X#define	DELIM_HEIGHT	10	/* bar between game and info */
X
X#define	WIN_WIDTH	(NUM_VATORS * VATOR_WIDTH + (NUM_VATORS - 1) * VATOR_GAP + 2 * LEDGE_WIDTH)
X#define	WIN_HEIGHT	(NUM_LEDGES * LEDGE_GAP + INFO_HEIGHT + DELIM_HEIGHT)
X
X/* range of y locs for elevators */
X#define	VATOR_RUN	(WIN_HEIGHT - (INFO_HEIGHT + DELIM_HEIGHT) - VATOR_HEIGHT)
X
X/* range of man */
X#define	MAN_MAX_X	(WIN_WIDTH - MAN_DELTA - MAN_WIDTH)
X
X#define	TIMER_Y		(WIN_HEIGHT - ((INFO_HEIGHT * 2) / 3))
X#define	EXTRA_MAN_X	(WIN_WIDTH - 2 * MAN_WIDTH)
X#define	STATUS_Y	(TIMER_Y + 15)
X#define	STATUS_X	(2 * TIMER_SLICE)
X
X#define	FONTNAME	"fixed"
X
X#define	COLLISION_FUDGE	4
X
X#define	vator_pos(i) (LEDGE_WIDTH + (i) * (VATOR_GAP + VATOR_WIDTH))
X#define	man_start_pos(i)	(MAN_DELTA + (i) * (WIN_WIDTH - MAN_WIDTH - (2 * MAN_DELTA)))
X#define	man_y_pos(l)	((LEDGE_GAP * ((l) + 1)) - (LEDGE_HEIGHT + MAN_HEIGHT))
X
X#define	min(a, b)	(((a) < (b)) ? (a) : (b))
X#define	max(a, b)	(((a) > (b)) ? (a) : (b))
X
Xstatic void wait_for_start();
Xstatic void run();
Xstatic void finish_up();
X
Xstatic void draw_ledges();
Xstatic void draw_init_screen();
Xstatic void draw_scores();
Xstatic void draw_obj();
Xstatic void draw_timer();
Xstatic void draw_status();
Xstatic void draw_message();
Xstatic void draw_message2();
Xstatic void erase_obj();
Xstatic void new_man();
Xstatic void new_gift();
Xstatic void flush_keyboard();
X
Xstatic void
Xusage()
X{
X    fprintf(stderr, "Usage: %s [-display displayname]\n", progname);
X    exit(0);
X}
X
Xstatic unsigned long
Xget_color(cname)
X    char       *cname;
X{
X    XColor      col;
X
X    XParseColor(dpy, cmap, cname, &col);
X    XAllocColor(dpy, cmap, &col);
X    return col.pixel;
X}
X
Xstatic void
Xinit_display(ac, av, dname)
X    int         ac;
X    char      **av;
X    char       *dname;
X{
X    Bool        is_color = False;
X    int         screen;
X    unsigned long wmask,
X                gcmask;
X    XSetWindowAttributes wattr;
X    XGCValues   gcv;
X    XFontStruct *pfont;
X    int         x,
X                y;
X    XSizeHints  xsh;
X    XWMHints    wmhints;
X
X    dpy = XOpenDisplay(dname);
X    if (!dpy) {
X	fprintf(stderr, "%s: Couldn't open display \"%s\"\n", progname, dname);
X	exit(-1);
X    }
X    screen = DefaultScreen(dpy);
X
X    if (debug)
X	XSynchronize(dpy, 1);
X
X    if (DisplayCells(dpy, screen) > 2)
X	is_color = True;
X    cmap = DefaultColormap(dpy, screen);
X
X    /* set up colors */
X    if (is_color) {
X	man_color = get_color(game_colors[MAN]);
X	splat_color = get_color(game_colors[SPLAT]);
X	vator_color = get_color(game_colors[VATOR]);
X	vator_bg_color = get_color(game_colors[VATOR_BG]);
X	ledge_color = get_color(game_colors[LEDGE]);
X	timer_color = get_color(game_colors[TIMER]);
X	text_color = get_color(game_colors[TEXT]);
X	gift_color = get_color(game_colors[GIFT]);
X	bg_color = get_color(game_colors[BACKGROUND]);
X    } else {
X	man_color = WhitePixel(dpy, screen);
X	splat_color = WhitePixel(dpy, screen);
X	vator_color = BlackPixel(dpy, screen);
X	vator_bg_color = WhitePixel(dpy, screen);
X	ledge_color = WhitePixel(dpy, screen);
X	timer_color = WhitePixel(dpy, screen);
X	text_color = WhitePixel(dpy, screen);
X	gift_color = WhitePixel(dpy, screen);
X	bg_color = BlackPixel(dpy, screen);
X    }
X
X    x = 100;
X    y = 100;
X
X    wattr.background_pixel = bg_color;
X    wattr.event_mask = ExposureMask | KeyPressMask |
X	ButtonPressMask | ButtonReleaseMask;
X
X    wmask = CWEventMask | CWBackPixel;
X
X    game_win = XCreateWindow(dpy, RootWindow(dpy, screen), x, y, WIN_WIDTH,
X	       WIN_HEIGHT, 0, CopyFromParent, CopyFromParent, CopyFromParent,
X			     wmask, &wattr);
X
X    xsh.flags = PSize | PMinSize | PMaxSize;
X    xsh.width = xsh.min_width = xsh.max_width = WIN_WIDTH;
X    xsh.height = xsh.min_height = xsh.max_height = WIN_HEIGHT;
X    XSetStandardProperties(dpy, game_win, "Spy vs \"Bob\"", "SvB", None,
X			   av, ac, &xsh);
X
X    wmhints.input = True;
X    wmhints.flags = InputHint;
X    XSetWMHints(dpy, game_win, &wmhints);
X
X    pfont = XLoadQueryFont(dpy, FONTNAME);
X
X    gcmask = GCForeground | GCBackground;
X    gcv.foreground = text_color;
X    gcv.background = bg_color;
X    if (pfont) {
X	gcv.font = pfont->fid;
X	gcmask |= GCFont;
X    }
X    text_gc = XCreateGC(dpy, game_win, gcmask, &gcv);
X
X    gcmask = GCForeground | GCBackground | GCGraphicsExposures;
X    gcv.foreground = man_color;
X    gcv.background = bg_color;
X    gcv.graphics_exposures = False;
X    draw_gc = XCreateGC(dpy, game_win, gcmask, &gcv);
X
X    gcmask = GCForeground | GCBackground | GCGraphicsExposures;
X    gcv.foreground = vator_color;
X    gcv.background = vator_bg_color;
X    gcv.graphics_exposures = False;
X    vator_gc = XCreateGC(dpy, game_win, gcmask, &gcv);
X
X    /* make bitmaps */
X    vator_map = XCreateBitmapFromData(dpy, game_win, bob_vator_bits,
X				      VATOR_WIDTH, VATOR_HEIGHT);
X    man_left = XCreateBitmapFromData(dpy, game_win, man_left_bits,
X				     MAN_WIDTH, MAN_HEIGHT);
X    man_right = XCreateBitmapFromData(dpy, game_win, man_right_bits,
X				      MAN_WIDTH, MAN_HEIGHT);
X    man_stand = XCreateBitmapFromData(dpy, game_win, man_stand_bits,
X				      MAN_WIDTH, MAN_HEIGHT);
X    slack_map = XCreateBitmapFromData(dpy, game_win, slack_bits,
X				      GIFT_WIDTH, GIFT_HEIGHT);
X    splat_map = XCreateBitmapFromData(dpy, game_win, splatter_bits,
X				      SPLAT_WIDTH, SPLAT_HEIGHT);
X
X    XMapWindow(dpy, game_win);
X}
X
Xmain(argc, argv)
X    int         argc;
X    char      **argv;
X{
X    int         i;
X    char       *dname = NULL;
X
X    progname = argv[0];
X    for (i = 1; i < argc; i++) {
X	if (!strncmp(argv[i], "-d", 2)) {
X	    if (argv[++i])
X		dname = argv[i];
X	    else
X		usage();
X	}
X    }
X    strcpy(user_name, "Unknown");
X    if (getenv("USER"))
X	strcpy(user_name, getenv("USER"));
X    srandom(getpid());
X    init_display(argc, argv, dname);
X    update_scores();
X    draw_init_screen();
X    while (1) {
X	wait_for_start();
X	run();
X	finish_up();
X    }
X}
X
Xstatic void
Xrefresh_screen()
X{
X    int         i;
X
X    XClearWindow(dpy, game_win);
X
X    draw_ledges();
X
X    /* delimiter */
X    XFillRectangle(dpy, game_win, text_gc, 0, WIN_HEIGHT - INFO_HEIGHT,
X		   WIN_WIDTH, DELIM_HEIGHT);
X
X    for (i = 0; i < NUM_VATORS; i++) {
X	draw_obj(vator_pos(i), vator_loc[i], VATOR);
X    }
X    draw_obj(man_x, man_y, MAN);
X    if (gift_state == GIFT_OUT)
X	draw_obj(gift_x, gift_y, GIFT);
X    draw_scores();
X    draw_message(NULL);
X    draw_message2(NULL);
X}
X
Xstatic void
Xdraw_init_screen()
X{
X    int         i;
X
X    XClearWindow(dpy, game_win);
X
X    /* place some random elevators */
X    for (i = 0; i < NUM_VATORS; i++) {
X	vator_loc[i] = rnd(VATOR_RUN);
X    }
X
X    /* and the man */
X    man_x = man_start_pos(rnd(2));
X    man_y = man_y_pos(rnd(NUM_LEDGES));
X
X    gift_state = GIFT_NOTYET;
X    new_gift();
X
X    draw_message("     Spy Vs \"Bob\"     Hit 's' to Start, 'q' to Quit, 'h' for Hi Scores");
X    draw_message2("    Use 'j', 'k', SPACE or Mouse buttons to move, 'p' to Pause");
X
X    refresh_screen();
X}
X
Xchar
Xget_key(kev)
X    XKeyPressedEvent *kev;
X{
X    char        buffer[10];
X    int         len;
X
X    len = XLookupString(kev, buffer, 10, NULL, NULL);
X    if (len)
X	return buffer[0];
X    else
X	return (char) -1;
X}
X
X/*
X * draws instructions, waits for 'q' or 's'
X */
Xstatic void
Xwait_for_start()
X{
X    XEvent      ev;
X    Bool        done = False;
X    char        c;
X
X    while (!done) {
X	XNextEvent(dpy, &ev);
X	switch (ev.type) {
X	case Expose:
X	    if (ev.xexpose.count == 0)
X		refresh_screen();
X	    break;
X	case KeyPress:
X	    c = get_key((XKeyPressedEvent *) & ev);
X	    switch (c) {
X	    case 'q':
X		exit(0);
X		break;
X	    case 's':
X		done = True;
X		break;
X	    case 'h':
X		show_scores();
X                refresh_screen();
X		break;
X	    default:
X		break;
X	    }
X	}
X    }
X    score = 0;
X    draw_message("");
X    draw_message2("");
X}
X
Xstatic void
Xinit_vators()
X{
X    int         i;
X
X    for (i = 0; i < NUM_VATORS; i++) {
X	vator_loc[i] = rnd(vator_run);
X	vator_speed[i] = rnd(VATOR_SPEED_RANGE) + MIN_VATOR_SPEED;
X    }
X}
X
Xstatic void
Xgot_across()
X{
X    if (gift_state == GIFT_OUT)
X	erase_obj(gift_x, gift_y, GIFT);
X    man_speed = 0;
X    ledge_num--;
X    score += 200 + (time_left * 5);
X    ledge++;
X    if (ledge_num < 0) {	/* finished level */
X	/* shrink the game board */
X	if (level < (START_LEDGE - MIN_LEDGE)) {
X	    /* don't drop it to 0, in case anyone's that good */
X	    ledge_num = START_LEDGE - level;
X	    vator_run -= LEDGE_GAP;
X	} else {
X	    ledge_num = MIN_LEDGE;
X	}
X	lives++;
X	ledge_side = 0;
X	new_man();
X	level_factor += LEVEL_INCREASE;
X	level++;
X	time_interval--;	/* speed it up too */
X	if (time_interval < 1)
X	    time_interval = 1;
X	man_delta--;
X	if (man_delta <= MIN_MAN_DELTA)
X	    man_delta = MIN_MAN_DELTA;
X    }
X    man_y = man_y_pos(ledge_num);
X    time_left = START_TIME;
X    gift_time = START_TIME - rnd(START_TIME / 2);
X    gift_state = GIFT_NOTYET;
X    flush_keyboard();
X    draw_scores();
X}
X
Xstatic void
Xmove_man()
X{
X    erase_obj(man_x, man_y, MAN);
X    man_x += man_speed;
X    if (man_x < man_start_pos(0)) {
X	man_x = man_start_pos(0);
X	if (ledge_side == 1) {	/* made it across */
X	    ledge_side = 0;
X	    got_across();
X	}
X    }
X    if (man_x > man_start_pos(1)) {
X	man_x = man_start_pos(1);
X	if (ledge_side == 0) {
X	    ledge_side = 1;
X	    got_across();
X	}
X    }
X    draw_obj(man_x, man_y, MAN);
X}
X
Xstatic void
Xmove_vators()
X{
X    int         i;
X
X    for (i = 0; i < NUM_VATORS; i++) {
X	erase_obj(vator_pos(i), vator_loc[i], VATOR);
X	vator_loc[i] += vator_speed[i];
X	if (vator_loc[i] <= 0) {
X	    vator_loc[i] = 0;
X	    vator_speed[i] = level_factor *
X		(rnd(VATOR_SPEED_RANGE) + MIN_VATOR_SPEED);
X	} else if (vator_loc[i] >= vator_run) {
X	    vator_loc[i] = vator_run;
X	    vator_speed[i] = -level_factor *
X		(rnd(VATOR_SPEED_RANGE) + MIN_VATOR_SPEED);
X	}
X	draw_obj(vator_pos(i), vator_loc[i], VATOR);
X    }
X}
X
Xstatic void
Xnew_man()
X{
X    int         i;
X
X    erase_obj(man_x, man_y, MAN);
X    if (gift_state == GIFT_OUT)
X	erase_obj(gift_x, gift_y, GIFT);
X    for (i = 0; i < NUM_VATORS; i++)
X	erase_obj(vator_pos(i), vator_loc[i], VATOR);
X    time_left = START_TIME;
X    gift_time = START_TIME - rnd(START_TIME / 2);
X    init_vators();
X    man_speed = 0;
X    man_x = man_start_pos(ledge_side);
X    man_y = man_y_pos(ledge_num);
X    draw_obj(man_x, man_y, MAN);
X    draw_status();
X    flush_keyboard();
X}
X
Xstatic void
Xcheck_collision()
X{
X    int         i;
X
X    for (i = 0; i < NUM_VATORS; i++) {
X	if (((man_x + MAN_WIDTH - COLLISION_FUDGE) > vator_pos(i)) &&
X		(man_x < (vator_pos(i) + VATOR_WIDTH - COLLISION_FUDGE))) {
X	    if ((man_y > vator_loc[i]) &&
X		    (man_y < vator_loc[i] + VATOR_HEIGHT)) {
X		lives--;
X		draw_message("SPLAT!!!");
X		erase_obj(man_x, man_y, MAN);
X		draw_obj(vator_pos(i), vator_loc[i], VATOR);
X		draw_obj(man_x - 5, man_y + 10, SPLAT);
X		XSync(dpy, 0);
X		sleep(1);
X		refresh_screen();
X		new_man();
X		return;
X	    }
X	}
X    }
X
X    if (gift_state == GIFT_OUT) {
X	if (((man_x + MAN_WIDTH) > gift_x) &&
X		(man_x < (gift_x + GIFT_WIDTH))) {
X	    score += GIFT_SCORE;
X	    gift_state = GIFT_TAKEN;
X	    draw_scores();
X	    return;
X	}
X    }
X}
X
Xstatic void
Xflush_keyboard()
X{
X    XEvent      ev;
X
X    while (XCheckTypedEvent(dpy, KeyPress, &ev));
X    while (XCheckTypedEvent(dpy, ButtonPress, &ev));
X    while (XCheckTypedEvent(dpy, ButtonRelease, &ev));
X}
X
Xstatic void
Xnew_gift()
X{
X    if (gift_state == GIFT_NOTYET) {
X	gift_y = man_y + GIFT_HEIGHT;
X	gift_x = rnd(WIN_WIDTH - 2 * LEDGE_WIDTH) + LEDGE_WIDTH;
X	draw_obj(gift_x, gift_y, GIFT);
X	gift_state = GIFT_OUT;
X    }
X}
X
Xstatic Bool
Xhandle_event()
X{
X    char        c = '\0';
X    XEvent      ev;
X    int         button;
X
X    XNextEvent(dpy, &ev);
X    switch (ev.type) {
X    case KeyPress:
X	c = get_key((XKeyPressedEvent *) & ev);
X	switch (c) {
X	case 'q':
X	    return False;
X	case 'j':
X	    man_speed = -man_delta;
X	    break;
X	case 'k':
X	    man_speed = man_delta;
X	    break;
X	case ' ':
X	    man_speed = 0;
X	    break;
X	case 'p':
X	    paused = !paused;
X	    draw_status();
X	    break;
X	default:
X	    break;
X	}
X	break;
X    case Expose:
X	refresh_screen();
X	break;
X    case ButtonPress:
X	button = ev.xbutton.button;
X	if (button == 1) {
X	    man_speed = -man_delta;
X	} else {
X	    man_speed = man_delta;
X	}
X	break;
X    case ButtonRelease:
X	button = ev.xbutton.button;
X	man_speed = 0;
X	break;
X    }
X    return True;
X}
X
Xstatic void
Xinit_parms()
X{
X    ledge_num = START_LEDGE;
X    ledge_side = 0;
X    level = 1;
X    ledge = 0;
X    lives = NUM_LIVES;
X    man_delta = MAN_DELTA;
X    vator_run = VATOR_RUN;
X    erase_obj(gift_x, gift_y, GIFT);
X    gift_state = GIFT_NOTYET;
X    level_factor = 1.0;
X    time_interval = ROUNDS_PER_UPDATE;
X}
X
X/*
X * plays the game
X */
Xstatic void
Xrun()
X{
X    int         time = 0;
X    int         ret;
X    int         serverfd = XConnectionNumber(dpy);
X    fd_set      read_fds,
X                base;
X    struct timeval tval,
X               *tm;
X
X    FD_ZERO(&base);
X    FD_SET(serverfd, &base);
X    init_parms();
X    new_man();
X
X    tval.tv_sec = 0;
X    tval.tv_usec = DELAY_TIME;
X    while (1) {
X	if (XPending(dpy)) {
X	    if (!handle_event())
X		return;
X	    continue;
X	}
X	if (!paused)
X	    tm = &tval;
X	else
X	    tm = (struct timeval *) 0;
X	read_fds = base;
X	ret = select(serverfd + 1, &read_fds, (fd_set *) 0, (fd_set *) 0, tm);
X	if (ret == -1)
X	    if (errno == EINTR)
X		continue;
X	if (ret == 1) {
X	    if (!handle_event())
X		return;
X	    continue;
X	}
X	if (paused)
X	    continue;
X	if (time_left == 0) {
X	    lives--;
X	    draw_message("Time's Up");
X	    XSync(dpy, 0);
X	    sleep(1);
X	    new_man();
X	    time = 0;
X	}
X	if (lives == 0)
X	    return;
X
X	time++;
X	if (time >= time_interval) {
X	    time = 0;
X	    time_left--;
X	    if (gift_time <= time_left) {
X		new_gift();
X		gift_time = -1;
X	    }
X	    draw_timer();
X            /* XXX this shouldn't really be necessray, but on a slow display,
X             * output can get queueed enough that the action gets delayed
X             */
X	    XSync(dpy, 0);
X	}
X	move_vators();
X	move_man();
X	check_collision();
X	if (gift_state == GIFT_OUT)
X	    draw_obj(gift_x, gift_y, GIFT);
X    }
X}
X
X/*
X * cleans up screen, shows score
X */
Xstatic void
Xfinish_up()
X{
X    draw_message("     Spy Vs \"Bob\"     Hit 's' to Start, 'q' to Quit, 'h' for Hi Scores");
X    draw_message2("    Use 'j', 'k', SPACE or Mouse buttons to move, 'p' to Pause");
X    add_score(score, ledge);
X    draw_scores();
X    refresh_screen();
X}
X
Xstatic void
Xerase_obj(x, y, type)
X    int         x,
X                y,
X                type;
X{
X    switch (type) {
X    case VATOR:
X	XClearArea(dpy, game_win, x, y, VATOR_WIDTH, VATOR_HEIGHT, False);
X	break;
X    case GIFT:
X	XClearArea(dpy, game_win, x, y, GIFT_WIDTH, GIFT_HEIGHT, False);
X	break;
X    case MAN:
X	XClearArea(dpy, game_win, x, y, MAN_WIDTH, MAN_HEIGHT, False);
X	break;
X    }
X}
X
Xstatic void
Xdraw_obj(x, y, type)
X    int         x,
X                y,
X                type;
X{
X    Pixmap      mmap;
X
X    switch (type) {
X    case VATOR:
X	XCopyPlane(dpy, vator_map, game_win, vator_gc,
X		   0, 0, VATOR_WIDTH, VATOR_HEIGHT, x, y, 1);
X	break;
X    case GIFT:
X	XSetForeground(dpy, draw_gc, gift_color);
X	XCopyPlane(dpy, slack_map, game_win, draw_gc,
X		   0, 0, GIFT_WIDTH, GIFT_HEIGHT, x, y, 1);
X	break;
X    case MAN:
X	XSetForeground(dpy, draw_gc, man_color);
X	if (man_speed == 0)
X	    mmap = man_stand;
X	else if (man_speed < 0)
X	    mmap = man_left;
X	else
X	    mmap = man_right;
X	XCopyPlane(dpy, mmap, game_win, draw_gc,
X		   0, 0, MAN_WIDTH, MAN_HEIGHT, x, y, 1);
X	break;
X    case SPLAT:
X	XSetForeground(dpy, draw_gc, splat_color);
X	XCopyPlane(dpy, splat_map, game_win, draw_gc,
X		   0, 0, SPLAT_WIDTH, SPLAT_HEIGHT, x, y, 1);
X	break;
X    case LEDGE:
X	XSetForeground(dpy, draw_gc, ledge_color);
X	XFillRectangle(dpy, game_win, draw_gc, x, y, LEDGE_WIDTH, LEDGE_HEIGHT);
X	break;
X    }
X}
X
Xstatic void
Xdraw_ledges()
X{
X    int         i;
X    int         y;
X
X    for (i = 0; i < NUM_LEDGES; i++) {
X	y = (i + 1) * LEDGE_GAP;
X	draw_obj(0, y, LEDGE);
X	draw_obj(WIN_WIDTH - LEDGE_WIDTH, y, LEDGE);
X    }
X}
X
Xstatic void
Xdraw_scores()
X{
X    char        score_buffer[256];
X
X    sprintf(score_buffer, "Time Left      Level %2d Best %7d Score %7d Lives %2d",
X	    level, highscore, score, lives);
X    XDrawImageString(dpy, game_win, text_gc, STATUS_X, WIN_HEIGHT - 5,
X		     score_buffer, strlen(score_buffer));
X}
X
Xstatic void
Xdraw_timer()
X{
X    if (paused) {
X	draw_message("PAUSED");
X    } else {
X	XClearArea(dpy, game_win, TIMER_SLICE,
X		   TIMER_Y, TIMER_SLICE * START_TIME, TIMER_HEIGHT, False);
X	XSetForeground(dpy, draw_gc, timer_color);
X	XFillRectangle(dpy, game_win, draw_gc, TIMER_SLICE,
X		       TIMER_Y, TIMER_SLICE * time_left, TIMER_HEIGHT);
X    }
X}
X
Xstatic void
Xdraw_status()
X{
X    int         i,
X                x,
X                y;
X    int         old_sp;
X
X    XClearArea(dpy, game_win, TIMER_SLICE * (START_TIME + 1), TIMER_Y,
X	       10000, MAN_HEIGHT, False);
X    y = TIMER_Y;
X    x = EXTRA_MAN_X;
X    old_sp = man_speed;
X    man_speed = 0;		/* make sure they're standing */
X    for (i = 0; i < min(lives - 1, 7); i++) {
X	draw_obj(x, y, MAN);
X	x -= (int) (MAN_WIDTH * 1.5);
X    }
X    man_speed = old_sp;
X    draw_timer();
X    draw_scores();
X}
X
Xstatic void
Xdraw_message(str)
X    char       *str;
X{
X    static char msgbuf[256];
X
X    if (str)
X	strcpy(msgbuf, str);
X    XClearArea(dpy, game_win, TIMER_SLICE,
X	       TIMER_Y, TIMER_SLICE * START_TIME, TIMER_HEIGHT, False);
X    XDrawImageString(dpy, game_win, text_gc, STATUS_X, STATUS_Y,
X		     msgbuf, strlen(msgbuf));
X}
X
Xstatic void
Xdraw_message2(str)
X    char       *str;
X{
X    static char msgbuf2[256];
X
X    if (str)
X	strcpy(msgbuf2, str);
X    XClearArea(dpy, game_win, STATUS_X,
X	       STATUS_Y + 10, 1000, 15, False);
X    XDrawImageString(dpy, game_win, text_gc, STATUS_X, STATUS_Y + 20,
X		     msgbuf2, strlen(msgbuf2));
X}
END_OF_FILE
if test 25542 -ne `wc -c <'svs.c'`; then
    echo shar: \"'svs.c'\" unpacked with wrong size!
fi
# end of 'svs.c'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
