Newsgroups: comp.sources.x
Path: uunet!think.com!mips!msi!dcmartin
From: e_downey@hwking.cca.cr.rockwell.com (Elwood Downey)
Subject: v16i114: xephem - astronomical ephemeris program., Part03/24
Message-ID: <1992Mar6.135226.1992@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
References: <csx-16i112-xephem@uunet.UU.NET>
Date: Fri, 6 Mar 1992 13:52:26 GMT
Approved: dcmartin@msi.com

Submitted-by: e_downey@hwking.cca.cr.rockwell.com (Elwood Downey)
Posting-number: Volume 16, Issue 114
Archive-name: xephem/part03

# this is part.03 (part 3 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file constel.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 3; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping constel.c'
else
echo 'x - continuing file constel.c'
sed 's/^X//' << 'SHAR_EOF' >> 'constel.c' &&
X    {12.8333, 14.2500, -22.0000, Vir},
X    {9.0833, 9.7500, -24.0000, Hya},
X    {1.6667, 2.6500, -24.3833, Cet},
X    {2.6500, 3.7500, -24.3833, Eri},
X    {10.8333, 11.8333, -24.5000, Crt},
X    {11.8333, 12.5833, -24.5000, Crv},
X    {14.2500, 14.9167, -24.5000, Lib},
X    {16.2667, 16.7500, -24.5833, Oph},
X    {0.0000, 1.6667, -25.5000, Cet},
X    {21.3333, 21.8667, -25.5000, Cap},
X    {21.8667, 23.8333, -25.5000, Aqr},
X    {23.8333, 24.0000, -25.5000, Cet},
X    {9.7500, 10.2500, -26.5000, Hya},
X    {4.7000, 4.8333, -27.2500, Eri},
X    {4.8333, 6.1167, -27.2500, Lep},
X    {20.0000, 21.3333, -28.0000, Cap},
X    {10.2500, 10.5833, -29.1667, Hya},
X    {12.5833, 14.9167, -29.5000, Hya},
X    {14.9167, 15.6667, -29.5000, Lib},
X    {15.6667, 16.0000, -29.5000, Sco},
X    {4.5833, 4.7000, -30.0000, Eri},
X    {16.7500, 17.6000, -30.0000, Oph},
X    {17.6000, 17.8333, -30.0000, Sgr},
X    {10.5833, 10.8333, -31.1667, Hya},
X    {6.1167, 7.3667, -33.0000, CMa},
X    {12.2500, 12.5833, -33.0000, Hya},
X    {10.8333, 12.2500, -35.0000, Hya},
X    {3.5000, 3.7500, -36.0000, For},
X    {8.3667, 9.3667, -36.7500, Pyx},
X    {4.2667, 4.5833, -37.0000, Eri},
X    {17.8333, 19.1667, -37.0000, Sgr},
X    {21.3333, 23.0000, -37.0000, PsA},
X    {23.0000, 23.3333, -37.0000, Scl},
X    {3.0000, 3.5000, -39.5833, For},
X    {9.3667, 11.0000, -39.7500, Ant},
X    {0.0000, 1.6667, -40.0000, Scl},
X    {1.6667, 3.0000, -40.0000, For},
X    {3.8667, 4.2667, -40.0000, Eri},
X    {23.3333, 24.0000, -40.0000, Scl},
X    {14.1667, 14.9167, -42.0000, Cen},
X    {15.6667, 16.0000, -42.0000, Lup},
X    {16.0000, 16.4208, -42.0000, Sco},
X    {4.8333, 5.0000, -43.0000, Cae},
X    {5.0000, 6.5833, -43.0000, Col},
X    {8.0000, 8.3667, -43.0000, Pup},
X    {3.4167, 3.8667, -44.0000, Eri},
X    {16.4208, 17.8333, -45.5000, Sco},
X    {17.8333, 19.1667, -45.5000, CrA},
X    {19.1667, 20.3333, -45.5000, Sgr},
X    {20.3333, 21.3333, -45.5000, Mic},
X    {3.0000, 3.4167, -46.0000, Eri},
X    {4.5000, 4.8333, -46.5000, Cae},
X    {15.3333, 15.6667, -48.0000, Lup},
X    {0.0000, 2.3333, -48.1667, Phe},
X    {2.6667, 3.0000, -49.0000, Eri},
X    {4.0833, 4.2667, -49.0000, Hor},
X    {4.2667, 4.5000, -49.0000, Cae},
X    {21.3333, 22.0000, -50.0000, Gru},
X    {6.0000, 8.0000, -50.7500, Pup},
X    {8.0000, 8.1667, -50.7500, Vel},
X    {2.4167, 2.6667, -51.0000, Eri},
X    {3.8333, 4.0833, -51.0000, Hor},
X    {0.0000, 1.8333, -51.5000, Phe},
X    {6.0000, 6.1667, -52.5000, Car},
X    {8.1667, 8.4500, -53.0000, Vel},
X    {3.5000, 3.8333, -53.1667, Hor},
X    {3.8333, 4.0000, -53.1667, Dor},
X    {0.0000, 1.5833, -53.5000, Phe},
X    {2.1667, 2.4167, -54.0000, Eri},
X    {4.5000, 5.0000, -54.0000, Pic},
X    {15.0500, 15.3333, -54.0000, Lup},
X    {8.4500, 8.8333, -54.5000, Vel},
X    {6.1667, 6.5000, -55.0000, Car},
X    {11.8333, 12.8333, -55.0000, Cen},
X    {14.1667, 15.0500, -55.0000, Lup},
X    {15.0500, 15.3333, -55.0000, Nor},
X    {4.0000, 4.3333, -56.5000, Dor},
X    {8.8333, 11.0000, -56.5000, Vel},
X    {11.0000, 11.2500, -56.5000, Cen},
X    {17.5000, 18.0000, -57.0000, Ara},
X    {18.0000, 20.3333, -57.0000, Tel},
X    {22.0000, 23.3333, -57.0000, Gru},
X    {3.2000, 3.5000, -57.5000, Hor},
X    {5.0000, 5.5000, -57.5000, Pic},
X    {6.5000, 6.8333, -58.0000, Car},
X    {0.0000, 1.3333, -58.5000, Phe},
X    {1.3333, 2.1667, -58.5000, Eri},
X    {23.3333, 24.0000, -58.5000, Phe},
X    {4.3333, 4.5833, -59.0000, Dor},
X    {15.3333, 16.4208, -60.0000, Nor},
X    {20.3333, 21.3333, -60.0000, Ind},
X    {5.5000, 6.0000, -61.0000, Pic},
X    {15.1667, 15.3333, -61.0000, Cir},
X    {16.4208, 16.5833, -61.0000, Ara},
X    {14.9167, 15.1667, -63.5833, Cir},
X    {16.5833, 16.7500, -63.5833, Ara},
X    {6.0000, 6.8333, -64.0000, Pic},
X    {6.8333, 9.0333, -64.0000, Car},
X    {11.2500, 11.8333, -64.0000, Cen},
X    {11.8333, 12.8333, -64.0000, Cru},
X    {12.8333, 14.5333, -64.0000, Cen},
X    {13.5000, 13.6667, -65.0000, Cir},
X    {16.7500, 16.8333, -65.0000, Ara},
X    {2.1667, 3.2000, -67.5000, Hor},
X    {3.2000, 4.5833, -67.5000, Ret},
X    {14.7500, 14.9167, -67.5000, Cir},
X    {16.8333, 17.5000, -67.5000, Ara},
X    {17.5000, 18.0000, -67.5000, Pav},
X    {22.0000, 23.3333, -67.5000, Tuc},
X    {4.5833, 6.5833, -70.0000, Dor},
X    {13.6667, 14.7500, -70.0000, Cir},
X    {14.7500, 17.0000, -70.0000, TrA},
X    {0.0000, 1.3333, -75.0000, Tuc},
X    {3.5000, 4.5833, -75.0000, Hyi},
X    {6.5833, 9.0333, -75.0000, Vol},
X    {9.0333, 11.2500, -75.0000, Car},
X    {11.2500, 13.6667, -75.0000, Mus},
X    {18.0000, 21.3333, -75.0000, Pav},
X    {21.3333, 23.3333, -75.0000, Ind},
X    {23.3333, 24.0000, -75.0000, Tuc},
X    {0.7500, 1.3333, -76.0000, Tuc},
X    {0.0000, 3.5000, -82.5000, Hyi},
X    {7.6667, 13.6667, -82.5000, Cha},
X    {13.6667, 18.0000, -82.5000, Aps},
X    {3.5000, 7.6667, -85.0000, Men},
X    {0.0000, 24.0000, -90.0000, Oct},
X    {0.0000, 24.0000, -90.0000, ""}
};
X
/* given ra and dec (in rads) precessed to epoch e (an mjd)
X * point *name to a string naming the constellation at that location.
X */
confnd(r, d, e, name)
double r, d, e;
char **name;
{
X	double ra1875, de1875, mjd1875;
X	int i;
X
X	cal_mjd (1, 1.0, 1875, &mjd1875);
X	precess (e, mjd1875, &r, &d);
X	    
X	/* find constellation such that the declination entered is higher than
X	 * the lower boundary of the constellation when the upper and lower
X	 * right ascensions for the constellation bound the entered right
X	 * ascension
X	 */
X	i = 0;
X	ra1875 = radhr (r);
X	de1875 = raddeg (d);
X	while ((con_data[i].l_dec > de1875 || con_data[i].u_ra <= ra1875
X		     || con_data[i].l_ra > ra1875) && con_data[i].cons[0])
X	     i++;
X
X	*name = con_data[i].cons[0] ? con_data[i].cons : "<No constellation?!>";
}
SHAR_EOF
echo 'File constel.c is complete' &&
chmod 0644 constel.c ||
echo 'restore of constel.c failed'
Wc_c="`wc -c < 'constel.c'`"
test 20026 -eq "$Wc_c" ||
	echo 'constel.c: original size 20026, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= datamenu.c ==============
if test -f 'datamenu.c' -a X"$1" != X"-c"; then
	echo 'x - skipping datamenu.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting datamenu.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'datamenu.c' &&
/* code to manage the stuff on the "data" menu.
X */
X
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#ifdef VMS
#include <stdlib.h>
#endif
#include <Xm/Xm.h>
#include <Xm/Form.h>
#include <Xm/LabelG.h>
#include <Xm/PushBG.h>
#include <Xm/PushB.h>
#include <Xm/ToggleBG.h>
#include "fieldmap.h"
#include "astro.h"
#include "circum.h"
#include "moreobjs.h"
X
extern char *strncpy();
extern char *getenv();
extern Widget toplevel_w;
extern XmString str_width();
extern Now *mm_get_now();
extern char *objname[];
#define	XtD	XtDisplay(toplevel_w)
X
/* locations of each field.
X * these are in terms of a 1-based row/col on a 24x80 alpha screen, for
X * historical reasons.
X */
#define	NR	14
#define	NC	86
X
#define	C_OBJ		1
#define	C_CONSTEL	4
#define	C_XTRA		3
X
/* menu 1 info table */
#define	C_RA		8
#define	C_DEC		16
#define	C_AZ		23
#define	C_ALT		30
#define	C_HLONG		37
#define	C_HLAT		44
#define	C_EDIST		51
#define C_SDIST 	58
#define	C_ELONG		65
#define	C_SIZE		72
#define	C_MAG		77
#define	C_PHASE		83
X
/* planet rows */
#define	R_PLANTAB	(1)
#define	R_SUN		(R_PLANTAB+1)
#define	R_MOON		(R_PLANTAB+2)
#define	R_MERCURY	(R_PLANTAB+3)
#define	R_VENUS		(R_PLANTAB+4)
#define	R_MARS		(R_PLANTAB+5)
#define	R_JUPITER	(R_PLANTAB+6)
#define	R_SATURN	(R_PLANTAB+7)
#define	R_URANUS	(R_PLANTAB+8)
#define	R_NEPTUNE	(R_PLANTAB+9)
#define	R_PLUTO		(R_PLANTAB+10)
#define	R_OBJX		(R_PLANTAB+11)
#define	R_OBJY		(R_PLANTAB+12)
#define	R_CONTROL	(R_PLANTAB+13)
X
static FieldMap dm_field_map[] = {
X    {mkid(R_JUPITER,C_ALT), PLT, C_HLONG-C_ALT-1, 0, "Jup.Alt"}, 
X    {mkid(R_JUPITER,C_AZ), PLT, C_ALT-C_AZ-1, 0, "Jup.Az"}, 
X    {mkid(R_JUPITER,C_CONSTEL), 0, C_RA-C_CONSTEL-1}, 
X    {mkid(R_JUPITER,C_DEC), PLT, C_AZ-C_DEC-1, 0, "Jup.Dec"}, 
X    {mkid(R_JUPITER,C_EDIST), PLT, C_SDIST-C_EDIST-1, 0, "Jup.EDist"}, 
X    {mkid(R_JUPITER,C_ELONG), PLT, C_SIZE-C_ELONG-1, 0, "Jup.ELong"}, 
X    {mkid(R_JUPITER,C_HLAT), PLT, C_EDIST-C_HLAT-1, 0, "Jup.HLat"}, 
X    {mkid(R_JUPITER,C_HLONG), PLT, C_HLAT-C_HLONG-1, 0, "Jup.HLong"}, 
X    {mkid(R_JUPITER,C_MAG), PLT, C_PHASE-C_MAG-1, 0, "Jup.Mag"}, 
X    {mkid(R_JUPITER,C_PHASE), PLT, NC-C_PHASE, 0, "Jup.Phase"}, 
X    {mkid(R_JUPITER,C_RA), PLT, C_DEC-C_RA-1, 0, "Jup.RA"}, 
X    {mkid(R_JUPITER,C_SDIST), PLT, C_ELONG-C_SDIST-1, 0, "Jup.SDist"}, 
X    {mkid(R_JUPITER,C_SIZE), PLT, C_MAG-C_SIZE-1, 0, "Jup.Size"}, 
X    {mkid(R_MARS,C_ALT), PLT, C_HLONG-C_ALT-1, 0, "Mars.Alt"}, 
X    {mkid(R_MARS,C_AZ), PLT, C_ALT-C_AZ-1, 0, "Mars.Az"}, 
X    {mkid(R_MARS,C_CONSTEL), 0, C_RA-C_CONSTEL-1}, 
X    {mkid(R_MARS,C_DEC), PLT, C_AZ-C_DEC-1, 0, "Mars.Dec"}, 
X    {mkid(R_MARS,C_EDIST), PLT, C_SDIST-C_EDIST-1, 0, "Mars.EDist"}, 
X    {mkid(R_MARS,C_ELONG), PLT, C_SIZE-C_ELONG-1, 0, "Mars.ELong"}, 
X    {mkid(R_MARS,C_HLAT), PLT, C_EDIST-C_HLAT-1, 0, "Mars.HLat"}, 
X    {mkid(R_MARS,C_HLONG), PLT, C_HLAT-C_HLONG-1, 0, "Mars.HLong"}, 
X    {mkid(R_MARS,C_MAG), PLT, C_PHASE-C_MAG-1, 0, "Mars.Mag"}, 
X    {mkid(R_MARS,C_PHASE), PLT, NC-C_PHASE, 0, "Mars.Phase"}, 
X    {mkid(R_MARS,C_RA), PLT, C_DEC-C_RA-1, 0, "Mars.RA"}, 
X    {mkid(R_MARS,C_SDIST), PLT, C_ELONG-C_SDIST-1, 0, "Mars.SDist"}, 
X    {mkid(R_MARS,C_SIZE), PLT, C_MAG-C_SIZE-1, 0, "Mars.Size"}, 
X    {mkid(R_MERCURY,C_ALT), PLT, C_HLONG-C_ALT-1, 0, "Merc.Alt"}, 
X    {mkid(R_MERCURY,C_AZ), PLT, C_ALT-C_AZ-1, 0, "Merc.Az"}, 
X    {mkid(R_MERCURY,C_CONSTEL), 0, C_RA-C_CONSTEL-1}, 
X    {mkid(R_MERCURY,C_DEC), PLT, C_AZ-C_DEC-1, 0, "Merc.Dec"}, 
X    {mkid(R_MERCURY,C_EDIST), PLT, C_SDIST-C_EDIST-1, 0, "Merc.EDist"}, 
X    {mkid(R_MERCURY,C_ELONG), PLT, C_SIZE-C_ELONG-1, 0, "Merc.ELong"}, 
X    {mkid(R_MERCURY,C_HLAT), PLT, C_EDIST-C_HLAT-1, 0, "Merc.HLat"}, 
X    {mkid(R_MERCURY,C_HLONG), PLT, C_HLAT-C_HLONG-1, 0, "Merc.HLong"}, 
X    {mkid(R_MERCURY,C_MAG), PLT, C_PHASE-C_MAG-1, 0, "Merc.Mag"}, 
X    {mkid(R_MERCURY,C_PHASE), PLT, NC-C_PHASE, 0, "Merc.Phase"}, 
X    {mkid(R_MERCURY,C_RA), PLT, C_DEC-C_RA-1, 0, "Merc.RA"}, 
X    {mkid(R_MERCURY,C_SDIST), PLT, C_ELONG-C_SDIST-1, 0, "Merc.SDist"}, 
X    {mkid(R_MERCURY,C_SIZE), PLT, C_MAG-C_SIZE-1, 0, "Merc.Size"}, 
X    {mkid(R_MOON,C_ALT), PLT, C_HLONG-C_ALT-1, 0, "Moon.Alt"}, 
X    {mkid(R_MOON,C_AZ), PLT, C_ALT-C_AZ-1, 0, "Moon.Az"}, 
X    {mkid(R_MOON,C_CONSTEL), 0, C_RA-C_CONSTEL-1}, 
X    {mkid(R_MOON,C_DEC), PLT, C_AZ-C_DEC-1, 0, "Moon.Dec"}, 
X    {mkid(R_MOON,C_EDIST), PLT, C_SDIST-C_EDIST-1, 0, "Moon.EDist"}, 
X    {mkid(R_MOON,C_ELONG), PLT, C_SIZE-C_ELONG-1, 0, "Moon.ELong"}, 
X    {mkid(R_MOON,C_HLAT), PLT, C_EDIST-C_HLAT-1, 0, "Moon.HLat"}, 
X    {mkid(R_MOON,C_HLONG), PLT, C_HLAT-C_HLONG-1, 0, "Moon.HLong"}, 
X    {mkid(R_MOON,C_MAG), PLT, C_PHASE-C_MAG-1, 0, "Moon.Mag"}, 
X    {mkid(R_MOON,C_PHASE), PLT, NC-C_PHASE, 0, "Moon.Phase"}, 
X    {mkid(R_MOON,C_RA), PLT, C_DEC-C_RA-1, 0, "Moon.RA"}, 
X    {mkid(R_MOON,C_SDIST), PLT, C_ELONG-C_SDIST-1, 0, "Moon.SDist"}, 
X    {mkid(R_MOON,C_SIZE), PLT, C_MAG-C_SIZE-1, 0, "Moon.Size"}, 
X    {mkid(R_NEPTUNE,C_ALT), PLT, C_HLONG-C_ALT-1, 0, "Nep.Alt"}, 
X    {mkid(R_NEPTUNE,C_AZ), PLT, C_ALT-C_AZ-1, 0, "Nep.Az"}, 
X    {mkid(R_NEPTUNE,C_CONSTEL), 0, C_RA-C_CONSTEL-1}, 
X    {mkid(R_NEPTUNE,C_DEC), PLT, C_AZ-C_DEC-1, 0, "Nep.Dec"}, 
X    {mkid(R_NEPTUNE,C_EDIST), PLT, C_SDIST-C_EDIST-1, 0, "Nep.EDist"}, 
X    {mkid(R_NEPTUNE,C_ELONG), PLT, C_SIZE-C_ELONG-1, 0, "Nep.ELong"}, 
X    {mkid(R_NEPTUNE,C_HLAT), PLT, C_EDIST-C_HLAT-1, 0, "Nep.HLat"}, 
X    {mkid(R_NEPTUNE,C_HLONG), PLT, C_HLAT-C_HLONG-1, 0, "Nep.HLong"}, 
X    {mkid(R_NEPTUNE,C_MAG), PLT, C_PHASE-C_MAG-1, 0, "Nep.Mag"}, 
X    {mkid(R_NEPTUNE,C_PHASE), PLT, NC-C_PHASE, 0, "Nep.Phase"}, 
X    {mkid(R_NEPTUNE,C_RA), PLT, C_DEC-C_RA-1, 0, "Nep.RA"}, 
X    {mkid(R_NEPTUNE,C_SDIST), PLT, C_ELONG-C_SDIST-1, 0, "Nep.SDist"}, 
X    {mkid(R_NEPTUNE,C_SIZE), PLT, C_MAG-C_SIZE-1, 0, "Nep.Size"}, 
X    {mkid(R_OBJX,C_ALT), PLT, C_HLONG-C_ALT-1, 0, "ObjX.Alt"}, 
X    {mkid(R_OBJX,C_AZ), PLT, C_ALT-C_AZ-1, 0, "ObjX.Az"}, 
X    {mkid(R_OBJX,C_CONSTEL), 0, C_RA-C_CONSTEL-1}, 
X    {mkid(R_OBJX,C_DEC), PLT, C_AZ-C_DEC-1, 0, "ObjX.Dec"}, 
X    {mkid(R_OBJX,C_EDIST), PLT, C_SDIST-C_EDIST-1, 0, "ObjX.EDist"}, 
X    {mkid(R_OBJX,C_ELONG), PLT, C_SIZE-C_ELONG-1, 0, "ObjX.ELong"}, 
X    {mkid(R_OBJX,C_HLAT), PLT, C_EDIST-C_HLAT-1, 0, "ObjX.HLat"}, 
X    {mkid(R_OBJX,C_HLONG), PLT, C_HLAT-C_HLONG-1, 0, "ObjX.HLong"}, 
X    {mkid(R_OBJX,C_MAG), PLT, C_PHASE-C_MAG-1, 0, "ObjX.Mag"}, 
X    {mkid(R_OBJX,C_PHASE), PLT, NC-C_PHASE, 0, "ObjX.Phase"}, 
X    {mkid(R_OBJX,C_RA), PLT, C_DEC-C_RA-1, 0, "ObjX.RA"}, 
X    {mkid(R_OBJX,C_SDIST), PLT, C_ELONG-C_SDIST-1, 0, "ObjX.SDist"}, 
X    {mkid(R_OBJX,C_SIZE), PLT, C_MAG-C_SIZE-1, 0, "ObjX.Size"}, 
X    {mkid(R_OBJY,C_ALT), PLT, C_HLONG-C_ALT-1, 0, "ObjY.Alt"}, 
X    {mkid(R_OBJY,C_AZ), PLT, C_ALT-C_AZ-1, 0, "ObjY.Az"}, 
X    {mkid(R_OBJY,C_CONSTEL), 0, C_RA-C_CONSTEL-1}, 
X    {mkid(R_OBJY,C_DEC), PLT, C_AZ-C_DEC-1, 0, "ObjY.Dec"}, 
X    {mkid(R_OBJY,C_EDIST), PLT, C_SDIST-C_EDIST-1, 0, "ObjY.EDist"}, 
X    {mkid(R_OBJY,C_ELONG), PLT, C_SIZE-C_ELONG-1, 0, "ObjY.ELong"}, 
X    {mkid(R_OBJY,C_HLAT), PLT, C_EDIST-C_HLAT-1, 0, "ObjY.HLat"}, 
X    {mkid(R_OBJY,C_HLONG), PLT, C_HLAT-C_HLONG-1, 0, "ObjY.HLong"}, 
X    {mkid(R_OBJY,C_MAG), PLT, C_PHASE-C_MAG-1, 0, "ObjY.Mag"}, 
X    {mkid(R_OBJY,C_PHASE), PLT, NC-C_PHASE, 0, "ObjY.Phase"}, 
X    {mkid(R_OBJY,C_RA), PLT, C_DEC-C_RA-1, 0, "ObjY.RA"}, 
X    {mkid(R_OBJY,C_SDIST), PLT, C_ELONG-C_SDIST-1, 0, "ObjY.SDist"}, 
X    {mkid(R_OBJY,C_SIZE), PLT, C_MAG-C_SIZE-1, 0, "ObjY.Size"}, 
X    {mkid(R_PLUTO,C_ALT), PLT, C_HLONG-C_ALT-1, 0, "Pluto.Alt"}, 
X    {mkid(R_PLUTO,C_AZ), PLT, C_ALT-C_AZ-1, 0, "Pluto.Az"}, 
X    {mkid(R_PLUTO,C_CONSTEL), 0, C_RA-C_CONSTEL-1}, 
X    {mkid(R_PLUTO,C_DEC), PLT, C_AZ-C_DEC-1, 0, "Pluto.Dec"}, 
X    {mkid(R_PLUTO,C_EDIST), PLT, C_SDIST-C_EDIST-1, 0, "Pluto.EDist"}, 
X    {mkid(R_PLUTO,C_ELONG), PLT, C_SIZE-C_ELONG-1, 0, "Pluto.ELong"}, 
X    {mkid(R_PLUTO,C_HLAT), PLT, C_EDIST-C_HLAT-1, 0, "Pluto.HLat"}, 
X    {mkid(R_PLUTO,C_HLONG), PLT, C_HLAT-C_HLONG-1, 0, "Pluto.HLong"}, 
X    {mkid(R_PLUTO,C_MAG), PLT, C_PHASE-C_MAG-1, 0, "Pluto.Mag"}, 
X    {mkid(R_PLUTO,C_PHASE), PLT, NC-C_PHASE, 0, "Pluto.Phase"}, 
X    {mkid(R_PLUTO,C_RA), PLT, C_DEC-C_RA-1, 0, "Pluto.RA"}, 
X    {mkid(R_PLUTO,C_SDIST), PLT, C_ELONG-C_SDIST-1, 0, "Pluto.SDist"}, 
X    {mkid(R_PLUTO,C_SIZE), PLT, C_MAG-C_SIZE-1, 0, "Pluto.Size"}, 
X    {mkid(R_SATURN,C_ALT), PLT, C_HLONG-C_ALT-1, 0, "Sat.Alt"}, 
X    {mkid(R_SATURN,C_AZ), PLT, C_ALT-C_AZ-1, 0, "Sat.Az"}, 
X    {mkid(R_SATURN,C_CONSTEL), 0, C_RA-C_CONSTEL-1}, 
X    {mkid(R_SATURN,C_DEC), PLT, C_AZ-C_DEC-1, 0, "Sat.Dec"}, 
X    {mkid(R_SATURN,C_EDIST), PLT, C_SDIST-C_EDIST-1, 0, "Sat.EDist"}, 
X    {mkid(R_SATURN,C_ELONG), PLT, C_SIZE-C_ELONG-1, 0, "Sat.ELong"}, 
X    {mkid(R_SATURN,C_HLAT), PLT, C_EDIST-C_HLAT-1, 0, "Sat.HLat"}, 
X    {mkid(R_SATURN,C_HLONG), PLT, C_HLAT-C_HLONG-1, 0, "Sat.HLong"}, 
X    {mkid(R_SATURN,C_MAG), PLT, C_PHASE-C_MAG-1, 0, "Sat.Mag"}, 
X    {mkid(R_SATURN,C_PHASE), PLT, NC-C_PHASE, 0, "Sat.Phase"}, 
X    {mkid(R_SATURN,C_RA), PLT, C_DEC-C_RA-1, 0, "Sat.RA"}, 
X    {mkid(R_SATURN,C_SDIST), PLT, C_ELONG-C_SDIST-1, 0, "Sat.SDist"}, 
X    {mkid(R_SATURN,C_SIZE), PLT, C_MAG-C_SIZE-1, 0, "Sat.Size"}, 
X    {mkid(R_SUN,C_ALT), PLT, C_HLONG-C_ALT-1, 0, "Sun.Alt"}, 
X    {mkid(R_SUN,C_AZ), PLT, C_ALT-C_AZ-1, 0, "Sun.Az"}, 
X    {mkid(R_SUN,C_CONSTEL), 0, C_RA-C_CONSTEL-1}, 
X    {mkid(R_SUN,C_DEC), PLT, C_AZ-C_DEC-1, 0, "Sun.Dec"}, 
X    {mkid(R_SUN,C_EDIST), PLT, C_SDIST-C_EDIST-1, 0, "Sun.EDist"}, 
X    {mkid(R_SUN,C_HLONG), PLT, C_HLAT-C_HLONG-1, 0, "Sun.HLong"}, 
X    {mkid(R_SUN,C_MAG), PLT, C_PHASE-C_MAG-1, 0, "Sun.Mag"}, 
X    {mkid(R_SUN,C_RA), PLT, C_DEC-C_RA-1, 0, "Sun.RA"}, 
X    {mkid(R_SUN,C_SIZE), PLT, C_MAG-C_SIZE-1, 0, "Sun.Size"}, 
X    {mkid(R_URANUS,C_ALT), PLT, C_HLONG-C_ALT-1, 0, "Uranus.Alt"}, 
X    {mkid(R_URANUS,C_AZ), PLT, C_ALT-C_AZ-1, 0, "Uranus.Az"}, 
X    {mkid(R_URANUS,C_CONSTEL), 0, C_RA-C_CONSTEL-1}, 
X    {mkid(R_URANUS,C_DEC), PLT, C_AZ-C_DEC-1, 0, "Uranus.Dec"}, 
X    {mkid(R_URANUS,C_EDIST), PLT, C_SDIST-C_EDIST-1, 0, "Uranus.EDist"}, 
X    {mkid(R_URANUS,C_ELONG), PLT, C_SIZE-C_ELONG-1, 0, "Uranus.ELong"}, 
X    {mkid(R_URANUS,C_HLAT), PLT, C_EDIST-C_HLAT-1, 0, "Uranus.HLat"}, 
X    {mkid(R_URANUS,C_HLONG), PLT, C_HLAT-C_HLONG-1, 0, "Uranus.HLong"}, 
X    {mkid(R_URANUS,C_MAG), PLT, C_PHASE-C_MAG-1, 0, "Uranus.Mag"}, 
X    {mkid(R_URANUS,C_PHASE), PLT, NC-C_PHASE, 0, "Uranus.Phase"}, 
X    {mkid(R_URANUS,C_RA), PLT, C_DEC-C_RA-1, 0, "Uranus.RA"}, 
X    {mkid(R_URANUS,C_SDIST), PLT, C_ELONG-C_SDIST-1, 0, "Uranus.SDist"}, 
X    {mkid(R_URANUS,C_SIZE), PLT, C_MAG-C_SIZE-1, 0, "Uranus.Size"}, 
X    {mkid(R_VENUS,C_ALT), PLT, C_HLONG-C_ALT-1, 0, "Ven.Alt"}, 
X    {mkid(R_VENUS,C_AZ), PLT, C_ALT-C_AZ-1, 0, "Ven.Az"}, 
X    {mkid(R_VENUS,C_CONSTEL), 0, C_RA-C_CONSTEL-1}, 
X    {mkid(R_VENUS,C_DEC), PLT, C_AZ-C_DEC-1, 0, "Ven.Dec"}, 
X    {mkid(R_VENUS,C_EDIST), PLT, C_SDIST-C_EDIST-1, 0, "Ven.EDist"}, 
X    {mkid(R_VENUS,C_ELONG), PLT, C_SIZE-C_ELONG-1, 0, "Ven.ELong"}, 
X    {mkid(R_VENUS,C_HLAT), PLT, C_EDIST-C_HLAT-1, 0, "Ven.HLat"}, 
X    {mkid(R_VENUS,C_HLONG), PLT, C_HLAT-C_HLONG-1, 0, "Ven.HLong"}, 
X    {mkid(R_VENUS,C_MAG), PLT, C_PHASE-C_MAG-1, 0, "Ven.Mag"}, 
X    {mkid(R_VENUS,C_PHASE), PLT, NC-C_PHASE, 0, "Ven.Phase"}, 
X    {mkid(R_VENUS,C_RA), PLT, C_DEC-C_RA-1, 0, "Ven.RA"}, 
X    {mkid(R_VENUS,C_SDIST), PLT, C_ELONG-C_SDIST-1, 0, "Ven.SDist"}, 
X    {mkid(R_VENUS,C_SIZE), PLT, C_MAG-C_SIZE-1, 0, "Ven.Size"}, 
X
X    {mkid(R_PLANTAB,C_OBJ), 0, 0, "Ob"},
X    {mkid(R_PLANTAB,C_CONSTEL), 0, 0, "Cns"},
X    {mkid(R_PLANTAB,C_RA+2), 0,	0, "R.A."},
X    {mkid(R_PLANTAB,C_DEC+2), 0, 0, "Dec"},
X    {mkid(R_PLANTAB,C_AZ+2), 0,	 0, "Az"},
X    {mkid(R_PLANTAB,C_ALT+2), 0, 0, "Alt"},
X    {mkid(R_PLANTAB,C_HLONG), 0, 0, "H Long"},
X    {mkid(R_PLANTAB,C_HLAT), 0, 0, "H Lat"},
X    {mkid(R_PLANTAB,C_EDIST), 0, 0, "Ea Dst"},
X    {mkid(R_PLANTAB,C_SDIST), 0, 0, "Sn Dst"},
X    {mkid(R_PLANTAB,C_ELONG), 0, 0, "Elong"},
X    {mkid(R_PLANTAB,C_SIZE), 0, 0, "Size"},
X    {mkid(R_PLANTAB,C_MAG), 0, 0, "VMag"},
X    {mkid(R_PLANTAB,C_PHASE), 0, 0, "Phs"},
};
#define	NFM	(sizeof(dm_field_map)/sizeof(dm_field_map[0]))
#define	LFM	(&dm_field_map[NFM])
#define	fw(r,c)	(fm(r,c)->w)
X
static Widget dataform_w;
static Widget objs_w[NOBJ];	/* object selector toggle buttons */
static unsigned objs_on;	/* (1<<<OBJ>) when object is active */
static int dm_selecting;	/* set while our fields are being selected */
X
static short bodyrow[NOBJ] = {
X    R_MERCURY, R_VENUS, R_MARS, R_JUPITER, R_SATURN,
X    R_URANUS, R_NEPTUNE, R_PLUTO, R_SUN, R_MOON, R_OBJX, R_OBJY
};
X
static FieldMap *
fm(r,c)
int r, c;
{
X	FieldMap *fp;
X	int id = mkid(r,c);
X
X	for (fp = dm_field_map; fp < LFM; fp++)
X	    if (fp->id == id)
X		return (fp);
X	printf ("fm: can't find id 0x%x (%d,%d)\n", id, r, c);
X	exit (1);
X	return(0);	/* for lint */
}
X
/* method by which another module can access our field map.
X * this is used by the search compiler.
X */
dm_getfieldmap (fmpp)
FieldMap **fmpp;
{
X	*fmpp = dm_field_map;
X	return (NFM);
}
X
/* called when the data menu is activated via the main menu pulldown.
X * if never called before, create and manage all the widgets as a child of a
X * form. otherwise, just toggle whether the form is managed.
X */
dm_manage ()
{
X	if (!dataform_w) {
X	    void dm_activate_cb();
X	    void dm_obj_cb();
X	    void dm_toggle_cb();
X	    void dm_close_cb();
X	    void dm_help_cb();
X	    FieldMap *fp;
X	    Widget w;
X	    XmString str;
X	    Arg args[20];
X	    int i, n;
X
X	    /* create the form */
X	    n = 0;
X	    XtSetArg (args[n], XmNautoUnmanage, False); n++;
X	    XtSetArg (args[n], XmNdefaultPosition, False); n++;
X	    XtSetArg (args[n], XmNfractionBase, 1000); n++;
X	    XtSetArg (args[n], XmNallowOverlap, False); n++;
X	    XtSetArg (args[n], XmNwidth, NC*char_width()); n++;
X	    dataform_w = XmCreateFormDialog (toplevel_w, "Data", args, n);
X
X	    /* set some stuff in the parent DialogShell.
X	     * setting XmNdialogTitle in the Form didn't work..
X	     */
X	    n = 0;
X	    XtSetArg (args[n], XmNtitle, "xephem General Data Table"); n++;
X	    XtSetValues (XtParent(dataform_w), args, n);
X
X	    /* establish the buttons and labels */
X	    for (fp = dm_field_map; fp < LFM; fp++) {
X		int free_str;
X		n = 0;
X		XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X		XtSetArg (args[n], XmNtopPosition, ypos(fp->id)); n++;
X		XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X		XtSetArg (args[n], XmNleftPosition, xpos(fp->id)); n++;
X		free_str = 0;
X		if (fp->prompt) {
X		    str = XmStringCreate (fp->prompt,XmSTRING_DEFAULT_CHARSET);
X		    free_str = 1;
X		} else if (fp->width) {
X		    str = str_width (fp->width);
X		    XtSetArg(args[n], XmNrecomputeSize, False); n++;
X		} else {
X		    str = XmStringCreate("?",XmSTRING_DEFAULT_CHARSET);
X		    free_str = 1;
X		}
X		XtSetArg (args[n], XmNlabelString, str); n++;
X		if (fp->how) {
X		    /* pushbutton */
X		    XtSetArg (args[n], XmNalignment, XmALIGNMENT_END); n++;
X		    fp->w = XtCreateManagedWidget ("DataButton",
X				xmPushButtonWidgetClass, dataform_w, args, n);
X		    XtAddCallback (fp->w, XmNactivateCallback, dm_activate_cb,
X									fp);
X		} else {
X		    /* label */
X		    fp->w = XtCreateManagedWidget ("DataLabel",
X				    xmLabelGadgetClass, dataform_w, args, n);
X		}
X		if (free_str)
X		    XmStringFree(str);
X	    }
X
X	    /* make the object control toggle buttons */
X	    for (i = 0; i < NOBJ; i++) {
X		str = XmStringCreate (objname[i], XmSTRING_DEFAULT_CHARSET);
X		n = 0;
X		XtSetArg (args[n], XmNlabelString, str); n++;
X		XtSetArg (args[n], XmNset, objs_on&(1<<i) ? True : False);n++;
X		XtSetArg (args[n], XmNindicatorOn, False); n++;
X		XtSetArg (args[n], XmNshadowThickness, 2); n++;
X		XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X		XtSetArg (args[n], XmNtopPosition, r2ypos(bodyrow[i])); n++;
X		XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X		XtSetArg (args[n], XmNleftPosition, c2xpos(C_OBJ)); n++;
X		objs_w[i] = XmCreateToggleButtonGadget (dataform_w, "DmObjs",
X								    args, n);
X		XtAddCallback(objs_w[i], XmNvalueChangedCallback,dm_obj_cb,i);
X		XtManageChild (objs_w[i]);
X		XmStringFree (str);
X	    }
X
X	    /* make the close button */
X	    str = XmStringCreate ("Close", XmSTRING_DEFAULT_CHARSET);
X	    n = 0;
X	    XtSetArg (args[n], XmNlabelString, str); n++;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_CONTROL)); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, c2xpos(1)); n++;
X	    w = XmCreatePushButtonGadget (dataform_w, "DataClose", args, n);
X	    XtAddCallback (w, XmNactivateCallback, dm_close_cb, 0);
X	    XtManageChild (w);
X	    XmStringFree (str);
X
X	    /* make the toggle on/off pushbutton */
X
X	    str = XmStringCreate ("Toggle On/off", XmSTRING_DEFAULT_CHARSET);
X	    n = 0;
X	    XtSetArg (args[n], XmNlabelString, str); n++;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_CONTROL)); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, 450); n++;
X	    XtSetArg(args[n], XmNrecomputeSize, False); n++;
X	    w = XmCreatePushButtonGadget (dataform_w, "DataToggle", args, n);
X	    XtAddCallback (w, XmNactivateCallback, dm_toggle_cb, 0);
X	    XtManageChild (w);
X	    XmStringFree (str);
X
X	    /* make the help pushbutton */
X
X	    str = XmStringCreate ("Help", XmSTRING_DEFAULT_CHARSET);
X	    n = 0;
X	    XtSetArg (args[n], XmNlabelString, str); n++;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_CONTROL)); n++;
X	    XtSetArg (args[n], XmNrightAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNrightPosition, 1000); n++;
X	    w = XmCreatePushButtonGadget (dataform_w, "DataHelp", args, n);
X	    XtAddCallback (w, XmNactivateCallback, dm_help_cb, 0);
X	    XtManageChild (w);
X	    XmStringFree (str);
X	}
X	
X	if (XtIsManaged(dataform_w))
X	    XtUnmanageChild (dataform_w);
X	else {
X	    XtManageChild (dataform_w);
X	    dm_update (mm_get_now(), 1);
X	    dm_set_buttons (dm_selecting);
X	}
}
X
/* used by main to set the initial state of the objects to be on. */
dm_set_objs_on (mask)
int mask;
{
X	objs_on = mask;
}
X
/* called by other menus as they want to hear from our buttons or not.
X * the "on"s and "off"s stack - only really redo the buttons if it's the
X * first on or the last off.
X */
dm_selection_mode (whether)
int whether;	/* whether setting up for plotting or for not plotting */
{
X	dm_selecting += whether ? 1 : -1;
X
X	if (dataform_w && XtIsManaged(dataform_w))
X	    if (whether && dm_selecting == 1     /* first one to want on */
X		|| !whether && dm_selecting == 0 /* last one to want off */)
X		dm_set_buttons (whether);
}
X
/* go through all the buttons pickable for plotting and set whether they
X * should appear to look like buttons or just flat labels.
X */
static
dm_set_buttons (whether)
int whether;	/* whether setting up for plotting or for not plotting */
{
X	static Arg look_like_button[] = {
X	    {XmNbottomShadowColor, (XtArgVal) 0},
X	    {XmNtopShadowColor, (XtArgVal) 0},
X	    {XmNfillOnArm, (XtArgVal) True},
X	};
X	static Arg look_like_label[] = {
X	    {XmNbottomShadowColor, (XtArgVal) 0},
X	    {XmNtopShadowColor, (XtArgVal) 0},
X	    {XmNfillOnArm, (XtArgVal) False},
X	};
X	static int called;
X	FieldMap *fp;
X
X	if (!called) {
X	    Widget w;
X	    Pixel pixel;
X
X	    w = dm_field_map[0].w;
X	    if (!w) {
X		printf ("called dm_set_buttons() before widgets defined\n");
X		exit (1);
X	    }
X	    get_something (w, XmNbottomShadowColor, &pixel);
X	    look_like_button[0].value = pixel;
X	    get_something (w, XmNtopShadowColor, &pixel);
X	    look_like_button[1].value = pixel;
X	    get_something (w, XmNbackground, &pixel);
X	    look_like_label[0].value = pixel;
X	    look_like_label[1].value = pixel;
X	    called = 1;
X	}
X
X	for (fp = dm_field_map; fp < LFM; fp++)
X	    if (whether && (fp->how & PLT))
X		XtSetValues (fp->w,look_like_button,XtNumber(look_like_button));
X	    else
X		XtSetValues (fp->w,look_like_label,XtNumber(look_like_label));
}
X
/* callback from any of the data menu buttons being activated.
X */
void
dm_activate_cb (w, client, call)
Widget w;
caddr_t client;
caddr_t call;
{
X	FieldMap *fp = (FieldMap *)client;
X	if (dm_selecting) {
X	    plt_selection (fp);
X	    lst_selection (fp);
X	    srch_selection (fp);
X	}
}
X
/* callback from the Close button
X */
void
dm_close_cb (w, client, call)
Widget w;
caddr_t client;
caddr_t call;
{
X	XtUnmanageChild (dataform_w);
}
X
/* callback from the Help button
X */
void
dm_help_cb (w, client, call)
Widget w;
caddr_t client;
caddr_t call;
{
X	static char *msg[] = {
"This table displays various information about the planets and objects.",
"To reduce computation, each may be individually turned off or on."
};
X
X	hlp_dialog ("Data Table", msg, sizeof(msg)/sizeof(msg[0]));
}
X
/* callback from the "toggle on/off" push button.
X * toggle each object on or off.
X * basically we just force set all the planet buttons and let their callbacks
X *   do the real work.
X */
static void
dm_toggle_cb (w, client, call)
Widget w;
caddr_t client;
caddr_t call;
{
X	int p;
X
X	for (p = nxtbody(-1); p != -1; p = nxtbody(p)) {
X	    int state = XmToggleButtonGadgetGetState (objs_w[p]);
X	    XmToggleButtonGadgetSetState (objs_w[p], !state, True/*invoke cb*/);
X	}
}
X
/* callback for each of the object on/off toggle buttons.
X */
void
dm_obj_cb (w, client, call)
Widget w;
caddr_t client;
caddr_t call;
{
X	XmToggleButtonCallbackStruct *t = (XmToggleButtonCallbackStruct *) call;
X	int p = (int)client;
X
X	if (t->set && !(objs_on & (1<<p))) {
X	    objs_on |= 1<<p;
X	    dm_compute (p, 1, mm_get_now());
X	} else if (!t->set && (objs_on & (1<<p))) {
X	    objs_on &= ~(1<<p);
X	    dm_erase_obj (p);
X	}
}
X
/* erase all the buttons in the row corresponding to object p */
dm_erase_obj (p)
int p;
{
X	FieldMap *fp;
X	int r = bodyrow[p];
X
X	for (fp = dm_field_map; fp < LFM; fp++)
X	    if (f2r(fp->id) == r)
X		f_string (fp->w, "");
}
X
/* called to recompute and fill in values for the data menu.
X * don't bother if it doesn't exist or is unmanaged now.
X */
dm_update (np, how_much)
Now *np;
int how_much;
{
X	int p;
X	if (dataform_w && (how_much || XtIsManaged(dataform_w)))
X	    for (p = nxtbody(-1); p != -1; p = nxtbody(p))
X		if (objs_on & 1<<p) {
X		    /* if object type changes to, say fixed, some fields may
X		     * no longer be used and be left dirty.
X		     */
X		    if (p == OBJX || p == OBJY)
X			dm_erase_obj (p);
X		    dm_compute (p, how_much, np);
X		}
}
X
X
/* compute and print body info in data menu format */
static
dm_compute (p, force, np)
int p;		/* which body, as in astro.h/moreobjs.h defines */
int force;	/* whether to print for sure or only if things have changed */
Now *np;
{
X	Sky sky;
X	double as = plot_ison() || srch_ison() ? 0.0 : 60.0;
X	int row = bodyrow[p];
X
X	if (body_cir (p, as, np, &sky) || force) {
X	    show_constellation (np, row, &sky);
X	    f_ra (fw(row,C_RA), sky.s_ra);
X	    f_angle (fw(row,C_DEC), sky.s_dec);
X	    if (sky.s_hlong != NOHELIO) {
X		f_angle (fw(row,C_HLONG), sky.s_hlong);
X		if (p != SUN)
X		    f_angle (fw(row,C_HLAT), sky.s_hlat);
X	    }
X
X	    if (p == MOON) {
X		/* distance is on km, show in miles */
X		f_double (fw(R_MOON,C_EDIST), "%6.0f", sky.s_edist/1.609344);
X	    } else if (sky.s_edist > 0.0) {
X		/* show distance in au */
X		f_double (fw(row,C_EDIST),(sky.s_edist>=10.0)?"%6.3f":"%6.4f",
X								sky.s_edist);
X	    }
X	    if (sky.s_sdist > 0.0)
X		f_double (fw(row,C_SDIST),
X			(sky.s_sdist>=9.99995)?"%6.3f":"%6.4f", sky.s_sdist);
X	    if (p != SUN)
X		f_double (fw(row,C_ELONG), "%6.1f", sky.s_elong);
X	    f_double (fw(row,C_SIZE), sky.s_size >= 99.95 ?"%4.0f":"%4.1f",
X								sky.s_size);
X	    f_double (fw(row,C_MAG), sky.s_mag <= -9.95 ? "%4.0f" : "%4.1f",
X								sky.s_mag);
X	    if (sky.s_sdist > 0.0)
X		f_double (fw(row,C_PHASE), "%3.0f", sky.s_phase);
X	}
X
X	f_angle (fw(row,C_AZ), sky.s_az);
X	f_angle (fw(row,C_ALT), sky.s_alt);
}
X
static
show_constellation (np, row, sp)
Now *np;
int row;
Sky *sp;
{
X	char nm[10], *name;
X        confnd (sp->s_ra, sp->s_dec, epoch == EOD ? mjd : epoch, &name);
X	(void) sprintf (nm, "%.3s", name);
X	f_string(fw(row,C_CONSTEL), nm);
}
SHAR_EOF
chmod 0644 datamenu.c ||
echo 'restore of datamenu.c failed'
Wc_c="`wc -c < 'datamenu.c'`"
test 24197 -eq "$Wc_c" ||
	echo 'datamenu.c: original size 24197, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= eq_ecl.c ==============
if test -f 'eq_ecl.c' -a X"$1" != X"-c"; then
	echo 'x - skipping eq_ecl.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting eq_ecl.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'eq_ecl.c' &&
#include <stdio.h>
#include <math.h>
#include "astro.h"
X
#define	EQtoECL	1
#define	ECLtoEQ	(-1)
X
/* given the modified Julian date, mjd, and an equitorial ra and dec, each in
X * radians, find the corresponding geocentric ecliptic latitude, *lat, and
X * longititude, *lng, also each in radians.
X * correction for the effect on the angle of the obliquity due to nutation is
X * included.
X */
eq_ecl (mjd, ra, dec, lat, lng)
double mjd, ra, dec;
double *lat, *lng;
{
X	ecleq_aux (EQtoECL, mjd, ra, dec, lng, lat);
}
X
/* given the modified Julian date, mjd, and a geocentric ecliptic latitude,
X * *lat, and longititude, *lng, each in radians, find the corresponding
X * equitorial ra and dec, also each in radians.
X * correction for the effect on the angle of the obliquity due to nutation is
X * included.
X */
ecl_eq (mjd, lat, lng, ra, dec)
double mjd, lat, lng;
double *ra, *dec;
{
X	ecleq_aux (ECLtoEQ, mjd, lng, lat, ra, dec);
}
X
static
ecleq_aux (sw, mjd, x, y, p, q)
int sw;			/* +1 for eq to ecliptic, -1 for vv. */
double mjd, x, y;	/* sw==1: x==ra, y==dec.  sw==-1: x==lng, y==lat. */
double *p, *q;		/* sw==1: p==lng, q==lat. sw==-1: p==ra, q==dec. */
{
X	static double lastmjd = -10000;	/* last mjd calculated */
X	static double seps, ceps;	/* sin and cos of mean obliquity */
X	double sx, cx, sy, cy, ty;
X
X	if (mjd != lastmjd) {
X	    double eps;
X	    double deps, dpsi;
X	    obliquity (mjd, &eps);		/* mean obliquity for date */
X	    nutation (mjd, &deps, &dpsi);
X	    eps += deps;
X    	    seps = sin(eps);
X	    ceps = cos(eps);
X	    lastmjd = mjd;
X	}
X
X	sy = sin(y);
X	cy = cos(y);				/* always non-negative */
X        if (fabs(cy)<1e-20) cy = 1e-20;		/* insure > 0 */
X        ty = sy/cy;
X	cx = cos(x);
X	sx = sin(x);
X        *q = asin((sy*ceps)-(cy*seps*sx*sw));
X        *p = atan(((sx*ceps)+(ty*seps*sw))/cx);
X        if (cx<0) *p += PI;		/* account for atan quad ambiguity */
X	range (p, 2*PI);
}
SHAR_EOF
chmod 0644 eq_ecl.c ||
echo 'restore of eq_ecl.c failed'
Wc_c="`wc -c < 'eq_ecl.c'`"
test 1899 -eq "$Wc_c" ||
	echo 'eq_ecl.c: original size 1899, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= flog.c ==============
if test -f 'flog.c' -a X"$1" != X"-c"; then
	echo 'x - skipping flog.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting flog.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'flog.c' &&
/* this is a simple little package to manage the saving and retrieving of
X * field values, which we call field logging or "flogs". a flog consists of a
X * field location, ala rcfpack(), its value as a double and its value as
X * a string (ie, however it was printed). you can reset the list of flogs, add
X * to and remove from the list of registered fields and log a field if it has
X * been registered.
X *
X * this is used by the plotting and searching facilities of ephem to maintain
X * the values of the fields that are being plotted or used in search
X * expressions. it is used by the listing facility to generate listing files.
X *
X * a field can be in use for more than one
X * thing at a time (eg, all the X plot values may the same time field, or
X * searching and plotting might be on at one time using the same field) so
X * we consider the field to be in use as long a usage count is > 0.
X */
X
#include <X11/Xlib.h>
#include <Xm/Xm.h>
X
#if 0
extern char *strcpy(), *strncpy();
#endif
X
#define	NFLOGS	32		/* max number of distinct simultaneous logged
X				 * fields
X				 */
X
typedef struct {
X	int fl_usagecnt;	/* number of "users" logging to this field */
X	Widget fl_fld;		/* what widget we are storing this for */
X	double fl_val;		/* stored value as a double */
X	char fl_str[16];	/* stored value as a formatted string.
X				 * N.B.: never overwrite last char: keep as \0
X				 */
} FLog;
X
static FLog flog[NFLOGS];
X
/* add fld to the list. if already there, just increment usage count.
X * return 0 if ok, else -1 if no more room.
X */
flog_add (fld)
Widget fld;
{
X	FLog *flp, *unusedflp = 0;
X
X	/* scan for fld already in list, or find an unused one along the way */
X	for (flp = &flog[NFLOGS]; --flp >= flog; ) {
X	    if (flp->fl_usagecnt > 0) {
X		if (flp->fl_fld == fld) {
X		    flp->fl_usagecnt++;
X		    return (0);
X		}
X	    } else
X		unusedflp = flp;
X	}
X	if (unusedflp) {
X	    unusedflp->fl_fld = fld;
X	    unusedflp->fl_usagecnt = 1;
X	    return (0);
X	}
X	return (-1);
}
X
/* decrement usage count for flog for fld. if goes to 0 take it out of list.
X * ok if not in list i guess...
X */
flog_delete (fld)
Widget fld;
{
X	FLog *flp;
X
X	for (flp = &flog[NFLOGS]; --flp >= flog; )
X	    if (flp->fl_fld == fld && flp->fl_usagecnt > 0) {
X		if (--flp->fl_usagecnt <= 0) {
X		    flp->fl_usagecnt = 0;
X		}
X		break;
X	    }
}
X
/* if plotting, listing or searching is active then
X * if widget fld is in the fld list, set its value to val.
X * return 0 if ok, else -1 if not in list.
X */
flog_log (fld, val, str)
Widget fld;
double val;
char *str;
{
X	if (plot_ison() || listing_ison() || srch_ison()) {
X	    FLog *flp;
X	    for (flp = &flog[NFLOGS]; --flp >= flog; )
X		if (flp->fl_fld == fld && flp->fl_usagecnt > 0) {
X		    flp->fl_val = val;
X		    (void) strncpy (flp->fl_str, str, sizeof(flp->fl_str)-1);
X		    return(0);
X		}
X	    return (-1);
X	} else
X	    return (0);
}
X
/* search for fld in list. if find it, return its value and str, if str.
X * return 0 if found it, else -1 if not in list.
X */
flog_get (fld, vp, str)
Widget fld;
double *vp;
char *str;
{
X	FLog *flp;
X
X	for (flp = &flog[NFLOGS]; --flp >= flog; )
X	    if (flp->fl_fld == fld && flp->fl_usagecnt > 0) {
X		*vp = flp->fl_val;
X		if (str) 
X		    (void) strcpy (str, flp->fl_str);
X		return (0);
X	    }
X	return (-1);
}
SHAR_EOF
chmod 0644 flog.c ||
echo 'restore of flog.c failed'
Wc_c="`wc -c < 'flog.c'`"
test 3268 -eq "$Wc_c" ||
	echo 'flog.c: original size 3268, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= formats.c ==============
if test -f 'formats.c' -a X"$1" != X"-c"; then
	echo 'x - skipping formats.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting formats.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'formats.c' &&
/* basic formating routines.
X * all the screen oriented printing should go through here.
X * we always save the string in XmNlabelString.
X */
X
#include <stdio.h>
#include <math.h>
#include <ctype.h>
#ifdef VMS
#include <stdlib.h>
#endif
#include <X11/Xlib.h>
#include <Xm/Xm.h>
#include <Xm/MessageB.h>
#include "astro.h"
X
X
#if 0
extern char *strcpy();
#endif
extern Widget toplevel_w;
X
/* suppress screen io if this is true, but always flog stuff.
X */
static int f_scrnoff;
f_on ()
{
X	f_scrnoff = 0;
}
f_off ()
{
X	f_scrnoff = 1;
}
f_ison()
{
X	return (!f_scrnoff);
}
X
/* print the given value, v, in "sexadecimal" format at [r,c]
X * ie, in the form A:m.P, where A is a digits wide, P is p digits.
X * if p == 0, then no decimal point either.
X */
f_sexad (w, a, p, mod, v)
Widget w;
int a, p;	/* left space, min precision */
int mod;	/* don't let whole portion get this big */
double v;
{
X	char astr[32], str[32];
X	long dec;
X	double frac;
X	int visneg;
X	double vsav = v;
X
X	if (v >= 0.0)
X	    visneg = 0;
X	else {
X	    if (v <= -0.5/60.0*pow(10.0,-1.0*p)) {
X		v = -v;
X		visneg = 1;
X	    } else {
X		/* don't show as negative if less than the precision showing */
X		v = 0.0;
X		visneg = 0;
X	    }
X	}
X
X	dec = v;
X	frac = (v - dec)*60.0;
X	(void) sprintf (str, "59.%.*s5", p, "999999999");
X	if (frac >= atof (str)) {
X	    dec += 1;
X	    frac = 0.0;
X	}
X	dec %= mod;
X	if (dec == 0 && visneg)
X	    (void) strcpy (str, "-0");
X	else
X	    (void) sprintf (str, "%ld", visneg ? -dec : dec);
X
X	/* would just do this if Turbo-C 2.0 %?.0f" worked:
X	 * sprintf (astr, "%*s:%0*.*f", a, str, p == 0 ? 2 : p+3, p, frac);
X	 */
X	if (p == 0)
X	    (void) sprintf (astr, "%*s:%02d", a, str, (int)(frac+0.5));
X	else
X	    (void) sprintf (astr, "%*s:%0*.*f", a, str, p+3, p, frac);
X
X	(void) flog_log (w, vsav, astr);
X
X	f_string (w, astr);
}
X
/* print the given value, t, in sexagesimal format at [r,c]
X * ie, in the form T:mm:ss, where T is nd digits wide.
X * N.B. we assume nd >= 2.
X */
f_sexag (w, nd, t)
Widget w;
int nd;
double t;
{
X	char tstr[32];
X	int h, m, s;
X	int tisneg;
X	
X	dec_sex (t, &h, &m, &s, &tisneg);
X	if (h == 0 && tisneg)
X	    (void) sprintf (tstr, "%*s-0:%02d:%02d", nd-2, "", m, s);
X	else
X	    (void) sprintf (tstr, "%*d:%02d:%02d", nd, tisneg ? -h : h, m, s);
X
X	(void) flog_log (w, t, tstr);
X	f_string (w, tstr);
}
X
/* print angle ra, in radians, in ra hours as hh:mm.m at [r,c]
X * N.B. we assume ra is >= 0.
X */
f_ra (w, ra)
Widget w;
double ra;
{
X	f_sexad (w, 2, 1, 24, radhr(ra));
}
X
/* print time, t, as hh:mm:ss */
f_time (w, t)
Widget w;
double t;
{
X	f_sexag (w, 2, t);
}
X
/* print time, t, as +/-hh:mm:ss (don't show leading +) */
f_signtime (w, t)
Widget w;
double t;
{
X	f_sexag (w, 3, t);
}
X
/* print time, t, as hh:mm */
f_mtime (w, t)
Widget w;
double t;
{
X	f_sexad (w, 2, 0, 24, t);
}
X
/* print angle, a, in rads, as degress at [r,c] in form ddd:mm */
f_angle(w, a)
Widget w;
double a;
{
X	f_sexad (w, 3, 0, 360, raddeg(a));
}
X
/* print angle, a, in rads, as degress at [r,c] in form dddd:mm:ss */
f_gangle(w, a)
Widget w;
double a;
{
X	f_sexag (w, 4, raddeg(a));
}
X
/* print the given modified Julian date, jd, as the starting date at [r,c]
X * in the form mm/dd/yyyy.
X */
f_date (w, jd)
Widget w;
double jd;
{
X	char dstr[32];
X	int m, y;
X	double d, tmp;
X
X	mjd_cal (jd, &m, &d, &y);
X	(void) sprintf (dstr, "%2d/%02d/%-4d", m, (int)(d), y);
X
X	/* shadow to the plot subsystem as years. */
X	mjd_year (jd, &tmp);
X	(void) flog_log (w, tmp, dstr);
X	f_string (w, dstr);
}
X
/* print the given double as a rounded int, with the given format.
X * this is used to plot full precision, but display far less.
X * N.B. caller beware that we really do expect fmt to refer to an int, not
X *   a long for example. also beware of range that implies.
X */
f_int (w, fmt, f)
Widget w;
char fmt[];
double f;
{
X	char str[80];
X	int i;
X
X	i = (f < 0) ? (int)(f-0.5) : (int)(f+0.5);
X	(void) sprintf (str, fmt, i);
X
X	(void) flog_log (w, f, str);
X	f_string (w, str);
}
X
f_string (w, s)
Widget w;
char *s;
{
X	char *txtp;
X
X	if (f_scrnoff)
X	    return;
X	get_xmstring (w, XmNlabelString, &txtp);
X	if (strcmp (txtp, s))
X	    set_xmstring (w, XmNlabelString, s);
X	XtFree (txtp);
}
X
f_double (w, fmt, f)
Widget w;
char *fmt;
double f;
{
X	char str[80];
X	(void) sprintf (str, fmt, f);
X	(void) flog_log (w, f, str);
X	f_string (w, str);
}
X
/* print a message and possibly wait for op to hit ok */
f_msg (p, app_modal)
char *p;
int app_modal;	/* set if want msg to be set APPLICATION_MODAL */
{
X	static Widget msg_w;
X	XmString message_string;
X	Arg args[20];
X	int n;
X
X	if (!msg_w) {
X	    XmString button_string;
X	    XmString title_string;
X	    Widget w;
X
X	    button_string = XmStringCreate("Ok", XmSTRING_DEFAULT_CHARSET);
X	    title_string = XmStringCreate ("xephem Message",
X						XmSTRING_DEFAULT_CHARSET);
X
X	    /* Create MessageBox dialog. */
X	    n = 0;
X	    XtSetArg (args[n], XmNdialogTitle, title_string);  n++;
X	    XtSetArg (args[n], XmNokLabelString, button_string);  n++;
X	    msg_w = XmCreateMessageDialog (toplevel_w, "message", args, n);
X
X	    XmStringFree (title_string);
X	    XmStringFree (button_string);
X
X	    w = XmMessageBoxGetChild (msg_w, XmDIALOG_CANCEL_BUTTON);
X	    XtUnmanageChild (w);
X	    w = XmMessageBoxGetChild (msg_w, XmDIALOG_HELP_BUTTON);
X	    XtUnmanageChild (w);
X	}
X
X	message_string = XmStringCreateLtoR (p, XmSTRING_DEFAULT_CHARSET);
X
X	n = 0;
X	XtSetArg (args[n], XmNmessageString, message_string);  n++;
X	XtSetArg (args[n], XmNdialogStyle,
X	    app_modal ? XmDIALOG_APPLICATION_MODAL : XmDIALOG_MODELESS);  n++;
X	XtSetValues (msg_w, args, n);
X	XmStringFree (message_string);
X
X	/* Display help window. rely on autoUnmanage to bring back down. */
X	XtManageChild (msg_w);
}
X
/* crack a line of the form X?X?X into its components,
X *   where X is an integer and ? can be any character except '0-9' or '-',
X *   such as ':' or '/'.
X * only change those fields that are specified:
X *   eg:  ::10	only changes *s
X *        10    only changes *d
X *        10:0  changes *d and *m
X * if see '-' anywhere, first non-zero component will be made negative.
X * TODO: s should be a double *.
X */
f_sscansex (bp, d, m, s)
char *bp;
int *d, *m, *s;
{
X	char c;
X	int *p = d;
X	int *nonzp = 0;
X	int sawneg = 0;
X	int innum = 0;
X
X	while (c = *bp++)
X	    if (isdigit(c)) {
X		if (!innum) {
X		    *p = 0;
X		    innum = 1;
X		}
X		*p = *p*10 + (c - '0');
X		if (*p && !nonzp)
X		    nonzp = p;
X	    } else if (c == '-') {
X		sawneg = 1;
X	    } else if (p == s && c == '.') {
X		c = *bp++;
X		if (isdigit(c) && c >= '5') {
X		    /* round up if see at least .5 */
X		    if (++(*s) == 60) {
X			if (++(*m) == 60) {
X			    ++(*d);
X			    *m = 0;
X			}
X			*s = 0;
X		    }
X		}
X		break;
X	    } else if (c != ' ') {
X		/* advance to next component */
X		p = (p == d) ? m : s;
X		innum = 0;
X	    }
X
X	if (sawneg && nonzp)
X	    *nonzp = -*nonzp;
}
X
/* crack a floating date string, bp, of the form m/d/y, where d may be a
X *   floating point number, into its components.
X * leave any component unspecified unchanged.
X * actually, the slashes may be anything but digits or a decimal point.
X * this is functionally the same as f_sscansex() exept we allow for
X *   the day portion to be real, and we don't handle negative numbers.
X *   maybe someday we could make a combined one and use it everywhere.
X */
f_sscandate (bp, m, d, y)
char *bp;
int *m, *y;
double *d;
{
X	char *bp0, c;
X
X	bp0 = bp;
X	while ((c = *bp++) && isdigit(c))
X	    continue;
X	if (bp > bp0+1)
X	    *m = atoi (bp0);
X	if (c == '\0')
X	    return;
X	bp0 = bp;
X	while ((c = *bp++) && (isdigit(c) || c == '.'))
X	    continue;
X	if (bp > bp0+1)
X	    *d = atof (bp0);
X	if (c == '\0')
X	    return;
X	bp0 = bp;
X	while (c = *bp++)
X	    continue;
X	if (bp > bp0+1)
X	    *y = atoi (bp0);
}
X
/* just like dec_sex() but makes the first non-zero element negative if
X * x is negative (instead of returning a sign flag).
X */
f_dec_sexsign (x, h, m, s)
double x;
int *h, *m, *s;
{
X	int n;
X	dec_sex (x, h, m, s, &n);
X	if (n) {
X	    if (*h)
X		*h = -*h;
X	    else if (*m)
X		*m = -*m;
X	    else
X		*s = -*s;
X	}
}
X
/* return 1 if bp looks like a decimal year; else 0.
X * any number greater than 12 or less than 0 is assumed to be a year, or any
X * string with exactly one decimal point, an optional minus sign, and nothing
X * else but digits.
X */
decimal_year (bp)
char *bp;
{
X	char c;
X	int ndig = 0, ndp = 0, nneg = 0, nchar = 0;
X	double y = atof(bp);
X
X	while (c = *bp++) {
X	    nchar++;
X	    if (isdigit(c))
X		ndig++;
X	    else if (c == '.')
X		ndp++;
X	    else if (c == '-')
X		nneg++;
X	}
X
X	return (y > 12 || y < 0
X		    || (ndp == 1 && nneg <= 1 && nchar == ndig+ndp+nneg));
}
SHAR_EOF
chmod 0644 formats.c ||
echo 'restore of formats.c failed'
Wc_c="`wc -c < 'formats.c'`"
test 8556 -eq "$Wc_c" ||
	echo 'formats.c: original size 8556, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= help.c ==============
if test -f 'help.c' -a X"$1" != X"-c"; then
	echo 'x - skipping help.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting help.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'help.c' &&
/* this file contains the code to put up help messages.
X * the messages come from a file or, if no file is found or there is no
X * help entry for the requested subject, a small default text is provided.
X */
X
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#ifdef VMS
#include <stdlib.h>
#endif
#include <X11/Xlib.h>
#include <Xm/Xm.h>
#include <Xm/Form.h>
#include <Xm/PushB.h>
#include <Xm/Text.h>
X
extern Widget toplevel_w;
extern char *getenv();
X
#define	MAXLINE		128	/* longest allowable help file line */
#define	HLP_TAG		'@'	/* help file tag marker */
#define	HLP_NEST	'+'	/* help file nested tag marker */
X
#define	NR	15
#define	NC	75
X
static char *hlpfile;			/* !0 if set by -h option */
static char hlpfdef[] = "xephem.hlp";	/* default help file name */
X
/* put up a help dialog. it contains a scrolled text area and an Ok button.
X * make a new dialog each time so we can have several up at once.
X * this means we need an explicit callback on the Ok button to destroy it
X * again (rather than being able to use the autoUnmanage feature).
X * if can't find any help, say so.
X */
hlp_dialog (tag, deflt, ndeflt)
char *tag;	/* tag to look for in help file - also dialog title */
char *deflt[];	/* help text to use if tag not found */
int ndeflt;	/* number of strings in deflt[] */
{
X	Widget hlp_create_dialog();
X	Widget txt_w, form_w;
X
X	txt_w = hlp_create_dialog (tag);
X	form_w = XtParent(XtParent(txt_w));
X
X	if (hlp_fillfromfile(tag, txt_w, 0) < 0) {
X	    if (!deflt || ndeflt == 0) {
X		char buf[MAXLINE];
X		(void) sprintf (buf, "No help for %s", tag);
X		f_msg (buf, 0);
X		XtDestroyWidget (form_w);
X		return;
X	    } else
X		hlp_fillfromstrings(deflt, ndeflt, txt_w);
X	}
X
X	XtManageChild (form_w);
X	/* everything gets destroyed when the Ok button is selected */
}
X
/* set an alternate help file name.
X * N.B. we assume the storage pointed to by name is permanent.
X */
hlp_setfilename (name)
char *name;
{
X	hlpfile = name;
}
X
/* create the help dialog with a scrolled text area and an Ok button.
X * return the text area widget; when ready to view, manage its parent's parent:
X *   dialog -> form -> scrolled_window -> text.
X * pass the dialog widget as the client parameter of the ok activate callback
X *   so it can destroy it.
X */
static Widget
hlp_create_dialog (tag)
char *tag;
{
X	void hlp_ok_cb();
X	Widget hlp_w;
X	Widget t_w, cb_w;
X	Arg args[20];
X	char title[MAXLINE];
X	int n;
X	int l;
X
X	/* make the help shell form-dialog widget */
X
X	n = 0;
X	XtSetArg (args[n], XmNautoUnmanage, False); n++;
X	hlp_w = XmCreateFormDialog (toplevel_w, "HelpD", args, n);
X
X	(void) sprintf (title, "xephem Help on %s", tag);
X	set_something (XtParent(hlp_w), XmNtitle, title);
X
X	/* make the Ok button - make it the default for RETURN */
X
X	n = 0;
X	XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNleftAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNshowAsDefault, True); n++;
SHAR_EOF
true || echo 'restore of help.c failed'
fi
echo 'End of  part 3'
echo 'File help.c is continued in part 4'
echo 4 > _shar_seq_.tmp
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
