Newsgroups: comp.sources.x
Path: uunet!think.com!mips!msi!dcmartin
From: e_downey@hwking.cca.cr.rockwell.com (Elwood Downey)
Subject: v16i118: xephem - astronomical ephemeris program., Part07/24
Message-ID: <1992Mar6.135334.2230@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
References: <csx-16i112-xephem@uunet.UU.NET>
Date: Fri, 6 Mar 1992 13:53:34 GMT
Approved: dcmartin@msi.com

Submitted-by: e_downey@hwking.cca.cr.rockwell.com (Elwood Downey)
Posting-number: Volume 16, Issue 118
Archive-name: xephem/part07

# this is part.07 (part 7 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file pelement.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 7; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping pelement.c'
else
echo 'x - continuing file pelement.c'
sed 's/^X//' << 'SHAR_EOF' >> 'pelement.c' &&
X	int planet, i;
X
X	for (planet = 0; planet < 8; planet++) {
X	    ep = elements[planet];
X	    pp = plan[planet];
X	    aa = ep[1]*t;
X	    pp[0] = ep[0] + 360.*(aa-(long)aa) + (ep[3]*t + ep[2])*t*t;
X	    range (pp, 360.);
X	    pp[1] = (ep[1]*9.856263e-3) + (ep[2] + ep[3])/36525;
X
X	    for (i = 4; i < 20; i += 4)
X		pp[i/4+1] = ((ep[i+3]*t + ep[i+2])*t + ep[i+1])*t + ep[i+0];
X
X	    pp[6] = ep[20];
X	    pp[7] = ep[21];
X	    pp[8] = ep[22];
X	}
}
SHAR_EOF
echo 'File pelement.c is complete' &&
chmod 0644 pelement.c ||
echo 'restore of pelement.c failed'
Wc_c="`wc -c < 'pelement.c'`"
test 4797 -eq "$Wc_c" ||
	echo 'pelement.c: original size 4797, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= plans.c ==============
if test -f 'plans.c' -a X"$1" != X"-c"; then
	echo 'x - skipping plans.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting plans.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'plans.c' &&
#include <stdio.h>
#include <math.h>
#include "astro.h"
X
#define	TWOPI		(2*PI)
#define	mod2PI(x)	((x) - (long)((x)/TWOPI)*TWOPI)
X
/* given a modified Julian date, mjd, and a planet, p, find:
X *   lpd0: heliocentric longitude, 
X *   psi0: heliocentric latitude,
X *   rp0:  distance from the sun to the planet, 
X *   rho0: distance from the Earth to the planet,
X *         none corrected for light time, ie, they are the true values for the
X *         given instant.
X *   lam:  geocentric ecliptic longitude, 
X *   bet:  geocentric ecliptic latitude,
X *         each corrected for light time, ie, they are the apparent values as
X *	   seen from the center of the Earth for the given instant.
X *   dia:  angular diameter in arcsec at 1 AU, 
X *   mag:  visual magnitude when 1 AU from sun and earth at 0 phase angle.
X *
X * all angles are in radians, all distances in AU.
X * the mean orbital elements are found by calling pelement(), then mutual
X *   perturbation corrections are applied as necessary.
X *
X * corrections for nutation and abberation must be made by the caller. The RA 
X *   and DEC calculated from the fully-corrected ecliptic coordinates are then
X *   the apparent geocentric coordinates. Further corrections can be made, if
X *   required, for atmospheric refraction and geocentric parallax although the
X *   intrinsic error herein of about 10 arcseconds is usually the dominant
X *   error at this stage.
X * TODO: combine the several intermediate expressions when get a good compiler.
X */
plans (mjd, p, lpd0, psi0, rp0, rho0, lam, bet, dia, mag)
double mjd;
int p;
double *lpd0, *psi0, *rp0, *rho0, *lam, *bet, *dia, *mag;
{
X	static double plan[8][9];
X	static double lastmjd = -10000;
X	double dl;	/* perturbation correction for longitude */
X	double dr;	/*  "   orbital radius */
X	double dml;	/*  "   mean longitude */
X	double ds;	/*  "   eccentricity */
X	double dm;	/*  "   mean anomaly */
X	double da;	/*  "   semi-major axis */
X	double dhl;	/*  "   heliocentric longitude */
X	double lsn, rsn;/* true geocentric longitude of sun and sun-earth rad */
X	double mas;	/* mean anomaly of the sun */
X	double re;	/* radius of earth's orbit */
X	double lg;	/* longitude of earth */
X	double map[8];	/* array of mean anomalies for each planet */
X	double lpd, psi, rp, rho;
X	double ll, sll, cll;
X	double t;
X	double dt;
X	int pass;
X	int j;
X	double s, ma;
X	double nu, ea;
X	double lp, om;
X	double lo, slo, clo;
X	double inc, y;
X	double spsi, cpsi;
X	double rpd;
X
X	/* only need to fill in plan[] once for a given mjd */
X	if (mjd != lastmjd) {
X	    pelement (mjd, plan);
X	    lastmjd = mjd;
X	}
X
X	dt = 0;
X	t = mjd/36525.;
X	sunpos (mjd, &lsn, &rsn);
X	masun (mjd, &mas);
X        re = rsn;
X	lg = lsn+PI;
X
X	/* first find the true position of the planet at mjd.
X	 * then repeat a second time for a slightly different time based
X	 * on the position found in the first pass to account for light-travel
X	 * time.
X	 */
X	for (pass = 0; pass < 2; pass++) {
X
X	    for (j = 0; j < 8; j++)
X		map[j] = degrad(plan[j][0]-plan[j][2]-dt*plan[j][1]);
X
X	    /* set initial corrections to 0.
X	     * then modify as necessary for the planet of interest.
X	     */
X	    dl = 0;
X	    dr = 0;
X	    dml = 0;
X	    ds = 0;
X	    dm = 0;
X	    da = 0;
X	    dhl = 0;
X
X	    switch (p) {
X
X	    case MERCURY:
X		p_mercury (map, &dl, &dr);
X		break;
X
X	    case VENUS:
X		p_venus (t, mas, map, &dl, &dr, &dml, &dm);
X		break;
X
X	    case MARS:
X		p_mars (mas, map, &dl, &dr, &dml, &dm);
X		break;
X
X	    case JUPITER:
X		p_jupiter (t, plan[p][3], &dml, &ds, &dm, &da);
X		break;
X
X	    case SATURN:
X		p_saturn (t, plan[p][3], &dml, &ds, &dm, &da, &dhl);
X		break;
X
X	    case URANUS:
X		p_uranus (t, plan[p][3], &dl, &dr, &dml, &ds, &dm, &da, &dhl);
X		break;
X
X	    case NEPTUNE:
X		p_neptune (t, plan[p][3], &dl, &dr, &dml, &ds, &dm, &da, &dhl);
X		break;
X
X	    case PLUTO:
X		/* no perturbation theory for pluto */
X		break;
X	    }
X
X	    s = plan[p][3]+ds;
X	    ma = map[p]+dm;
X	    anomaly (ma, s, &nu, &ea);
X	    rp = (plan[p][6]+da)*(1-s*s)/(1+s*cos(nu));
X	    lp = raddeg(nu)+plan[p][2]+raddeg(dml-dm);
X	    lp = degrad(lp);
X	    om = degrad(plan[p][5]);
X	    lo = lp-om;
X	    slo = sin(lo);
X	    clo = cos(lo);
X	    inc = degrad(plan[p][4]);
X	    rp = rp+dr;
X	    spsi = slo*sin(inc);
X	    y = slo*cos(inc);
X	    psi = asin(spsi)+dhl;
X	    spsi = sin(psi);
X	    lpd = atan(y/clo)+om+degrad(dl);
X	    if (clo<0) lpd += PI;
X	    range (&lpd, TWOPI);
X	    cpsi = cos(psi);
X	    rpd = rp*cpsi;
X	    ll = lpd-lg;
X	    rho = sqrt(re*re+rp*rp-2*re*rp*cpsi*cos(ll));
X
X	    /* when we view a planet we see it in the position it occupied
X	     * dt days ago, where rho is the distance between it and earth,
X	     * in AU. use this as the new time for the next pass.
X	     */
X	    dt = rho*5.775518e-3;
X
X	    if (pass == 0) {
X		/* save heliocentric coordinates after first pass since, being
X		 * true, they are NOT to be corrected for light-travel time.
X		 */
X		*lpd0 = lpd;
X		range (lpd0, TWOPI);
X		*psi0 = psi;
X		*rp0 = rp;
X		*rho0 = rho;
X	    }
X	}
X
X        sll = sin(ll);
X	cll = cos(ll);
X        if (p < MARS) 
X	    *lam = atan(-1*rpd*sll/(re-rpd*cll))+lg+PI;
X	else
X	    *lam = atan(re*sll/(rpd-re*cll))+lpd;
X	range (lam, TWOPI);
X        *bet = atan(rpd*spsi*sin(*lam-lpd)/(cpsi*re*sll));
X	*dia = plan[p][7];
X	*mag = plan[p][8];
}
X
/* set auxilliary variables used for jupiter, saturn, uranus, and neptune */
static
aux_jsun (t, x1, x2, x3, x4, x5, x6)
double t;
double *x1, *x2, *x3, *x4, *x5, *x6;
{
X        *x1 = t/5+0.1;
X        *x2 = mod2PI(4.14473+5.29691e1*t);
X        *x3 = mod2PI(4.641118+2.132991e1*t);
X        *x4 = mod2PI(4.250177+7.478172*t);
X        *x5 = 5 * *x3 - 2 * *x2;
X	*x6 = 2 * *x2 - 6 * *x3 + 3 * *x4;
}
X
/* find the mean anomaly of the sun at mjd.
X * this is the same as that used in sun() but when it was converted to C it
X * was not known it would be required outside that routine.
X * TODO: add an argument to sun() to return mas and eliminate this routine.
X */
static
masun (mjd, mas)
double mjd;
double *mas;
{
X	double t, t2;
X	double a, b;
X
X	t = mjd/36525;
X	t2 = t*t;
X	a = 9.999736042e1*t;
X	b = 360.*(a-(long)a);
X	*mas = degrad (3.5847583e2-(1.5e-4+3.3e-6*t)*t2+b);
}
X
/* perturbations for mercury */
static
p_mercury (map, dl, dr)
double map[];
double *dl, *dr;
{
X	*dl = 2.04e-3*cos(5*map[2-1]-2*map[1-1]+2.1328e-1)+
X	     1.03e-3*cos(2*map[2-1]-map[1-1]-2.8046)+
X	     9.1e-4*cos(2*map[3]-map[1-1]-6.4582e-1)+
X	     7.8e-4*cos(5*map[2-1]-3*map[1-1]+1.7692e-1);
X
X	*dr = 7.525e-6*cos(2*map[3]-map[1-1]+9.25251e-1)+
X	     6.802e-6*cos(5*map[2-1]-3*map[1-1]-4.53642)+
X	     5.457e-6*cos(2*map[2-1]-2*map[1-1]-1.24246)+
X	     3.569e-6*cos(5*map[2-1]-map[1-1]-1.35699);
}
X
/* ....venus */
static
p_venus (t, mas, map, dl, dr, dml, dm)
double t, mas, map[];
double *dl, *dr, *dml, *dm;
{
X	*dml = degrad (7.7e-4*sin(4.1406+t*2.6227));
X	*dm = *dml;
X
X	*dl = 3.13e-3*cos(2*mas-2*map[2-1]-2.587)+
X	     1.98e-3*cos(3*mas-3*map[2-1]+4.4768e-2)+
X	     1.36e-3*cos(mas-map[2-1]-2.0788)+
X	     9.6e-4*cos(3*mas-2*map[2-1]-2.3721)+
X	     8.2e-4*cos(map[3]-map[2-1]-3.6318);
X
X	*dr = 2.2501e-5*cos(2*mas-2*map[2-1]-1.01592)+
X	     1.9045e-5*cos(3*mas-3*map[2-1]+1.61577)+
X	     6.887e-6*cos(map[3]-map[2-1]-2.06106)+
X	     5.172e-6*cos(mas-map[2-1]-5.08065e-1)+
X	     3.62e-6*cos(5*mas-4*map[2-1]-1.81877)+
X	     3.283e-6*cos(4*mas-4*map[2-1]+1.10851)+
X	     3.074e-6*cos(2*map[3]-2*map[2-1]-9.62846e-1);
}
X
/* ....mars */
static
p_mars (mas, map, dl, dr, dml, dm)
double mas, map[];
double *dl, *dr, *dml, *dm;
{
X	double a;
X
X	a = 3*map[3]-8*map[2]+4*mas;
X	*dml = degrad (-1*(1.133e-2*sin(a)+9.33e-3*cos(a)));
X	*dm = *dml;
X
X	*dl = 7.05e-3*cos(map[3]-map[2]-8.5448e-1)+
X	     6.07e-3*cos(2*map[3]-map[2]-3.2873)+
X	     4.45e-3*cos(2*map[3]-2*map[2]-3.3492)+
X	     3.88e-3*cos(mas-2*map[2]+3.5771e-1)+
X	     2.38e-3*cos(mas-map[2]+6.1256e-1)+
X	     2.04e-3*cos(2*mas-3*map[2]+2.7688)+
X	     1.77e-3*cos(3*map[2]-map[2-1]-1.0053)+
X	     1.36e-3*cos(2*mas-4*map[2]+2.6894)+
X	     1.04e-3*cos(map[3]+3.0749e-1);
X
X	*dr = 5.3227e-5*cos(map[3]-map[2]+7.17864e-1)+
X	     5.0989e-5*cos(2*map[3]-2*map[2]-1.77997)+
X	     3.8278e-5*cos(2*map[3]-map[2]-1.71617)+
X	     1.5996e-5*cos(mas-map[2]-9.69618e-1)+
X	     1.4764e-5*cos(2*mas-3*map[2]+1.19768)+
X	     8.966e-6*cos(map[3]-2*map[2]+7.61225e-1);
X	 *dr += 7.914e-6*cos(3*map[3]-2*map[2]-2.43887)+
X	     7.004e-6*cos(2*map[3]-3*map[2]-1.79573)+
X	     6.62e-6*cos(mas-2*map[2]+1.97575)+
X	     4.93e-6*cos(3*map[3]-3*map[2]-1.33069)+
X	     4.693e-6*cos(3*mas-5*map[2]+3.32665)+
X	     4.571e-6*cos(2*mas-4*map[2]+4.27086)+
X	     4.409e-6*cos(3*map[3]-map[2]-2.02158);
}
X
/* ....jupiter */
static
p_jupiter (t, s, dml, ds, dm, da)
double t, s;
double *dml, *ds, *dm, *da;
{
X	double dp;
X	double x1, x2, x3, x4, x5, x6, x7;
X	double sx3, cx3, s2x3, c2x3;
X        double sx5, cx5, s2x5;
X	double sx6;
X        double sx7, cx7, s2x7, c2x7, s3x7, c3x7, s4x7, c4x7, c5x7;
X
X	aux_jsun (t, &x1, &x2, &x3, &x4, &x5, &x6);
X        x7 = x3-x2;
X	sx3 = sin(x3);
X	cx3 = cos(x3);
X        s2x3 = sin(2*x3);
X	c2x3 = cos(2*x3);
X        sx5 = sin(x5);
X	cx5 = cos(x5);
X        s2x5 = sin(2*x5);
X	sx6 = sin(x6);
X        sx7 = sin(x7);
X	cx7 = cos(x7);
X        s2x7 = sin(2*x7);
X	c2x7 = cos(2*x7);
X        s3x7 = sin(3*x7);
X	c3x7 = cos(3*x7);
X        s4x7 = sin(4*x7);
X	c4x7 = cos(4*x7);
X        c5x7 = cos(5*x7);
X
X	*dml = (3.31364e-1-(1.0281e-2+4.692e-3*x1)*x1)*sx5+
X	      (3.228e-3-(6.4436e-2-2.075e-3*x1)*x1)*cx5-
X	      (3.083e-3+(2.75e-4-4.89e-4*x1)*x1)*s2x5+
X	      2.472e-3*sx6+1.3619e-2*sx7+1.8472e-2*s2x7+6.717e-3*s3x7+
X	      2.775e-3*s4x7+6.417e-3*s2x7*sx3+
X	      (7.275e-3-1.253e-3*x1)*sx7*sx3+
X	      2.439e-3*s3x7*sx3-(3.5681e-2+1.208e-3*x1)*sx7*cx3;
X        *dml += -3.767e-3*c2x7*sx3-(3.3839e-2+1.125e-3*x1)*cx7*sx3-
X	      4.261e-3*s2x7*cx3+
X	      (1.161e-3*x1-6.333e-3)*cx7*cx3+
X	      2.178e-3*cx3-6.675e-3*c2x7*cx3-2.664e-3*c3x7*cx3-
X	      2.572e-3*sx7*s2x3-3.567e-3*s2x7*s2x3+2.094e-3*cx7*c2x3+
X	      3.342e-3*c2x7*c2x3;
X	*dml = degrad(*dml);
X
X	*ds = (3606+(130-43*x1)*x1)*sx5+(1289-580*x1)*cx5-6764*sx7*sx3-
X	     1110*s2x7*sx3-224*s3x7*sx3-204*sx3+(1284+116*x1)*cx7*sx3+
X	     188*c2x7*sx3+(1460+130*x1)*sx7*cx3+224*s2x7*cx3-817*cx3+
X	     6074*cx3*cx7+992*c2x7*cx3+
X	     508*c3x7*cx3+230*c4x7*cx3+108*c5x7*cx3;
X	*ds += -(956+73*x1)*sx7*s2x3+448*s2x7*s2x3+137*s3x7*s2x3+
X	     (108*x1-997)*cx7*s2x3+480*c2x7*s2x3+148*c3x7*s2x3+
X	     (99*x1-956)*sx7*c2x3+490*s2x7*c2x3+
X	     158*s3x7*c2x3+179*c2x3+(1024+75*x1)*cx7*c2x3-
X	     437*c2x7*c2x3-132*c3x7*c2x3;
X	*ds *= 1e-7;
X
X	dp = (7.192e-3-3.147e-3*x1)*sx5-4.344e-3*sx3+
X	     (x1*(1.97e-4*x1-6.75e-4)-2.0428e-2)*cx5+
X	     3.4036e-2*cx7*sx3+(7.269e-3+6.72e-4*x1)*sx7*sx3+
X	     5.614e-3*c2x7*sx3+2.964e-3*c3x7*sx3+3.7761e-2*sx7*cx3+
X	     6.158e-3*s2x7*cx3-
X	     6.603e-3*cx7*cx3-5.356e-3*sx7*s2x3+2.722e-3*s2x7*s2x3+
X	     4.483e-3*cx7*s2x3-2.642e-3*c2x7*s2x3+4.403e-3*sx7*c2x3-
X	     2.536e-3*s2x7*c2x3+5.547e-3*cx7*c2x3-2.689e-3*c2x7*c2x3;
X
X	*dm = *dml-(degrad(dp)/s);
X
X	*da = 205*cx7-263*cx5+693*c2x7+312*c3x7+147*c4x7+299*sx7*sx3+
X	     181*c2x7*sx3+204*s2x7*cx3+111*s3x7*cx3-337*cx7*cx3-
X	     111*c2x7*cx3;
X	*da *= 1e-6;
}
X
/* ....saturn */
static
p_saturn (t, s, dml, ds, dm, da, dhl)
double t, s;
double *dml, *ds, *dm, *da, *dhl;
{
X	double dp;
X	double x1, x2, x3, x4, x5, x6, x7, x8;
X	double sx3, cx3, s2x3, c2x3, s3x3, c3x3, s4x3, c4x3;
X        double sx5, cx5, s2x5, c2x5;
X	double sx6;
X        double sx7, cx7, s2x7, c2x7, s3x7, c3x7, s4x7, c4x7, c5x7, s5x7;
X	double s2x8, c2x8, s3x8, c3x8;
X
X	aux_jsun (t, &x1, &x2, &x3, &x4, &x5, &x6);
X        x7 = x3-x2;
X	sx3 = sin(x3);
X	cx3 = cos(x3);
X        s2x3 = sin(2*x3);
X	c2x3 = cos(2*x3);
X        sx5 = sin(x5);
X	cx5 = cos(x5);
X        s2x5 = sin(2*x5);
X	sx6 = sin(x6);
X        sx7 = sin(x7);
X	cx7 = cos(x7);
X        s2x7 = sin(2*x7);
X	c2x7 = cos(2*x7);
X        s3x7 = sin(3*x7);
X	c3x7 = cos(3*x7);
X        s4x7 = sin(4*x7);
X	c4x7 = cos(4*x7);
X        c5x7 = cos(5*x7);
X
X	s3x3 = sin(3*x3);
X	c3x3 = cos(3*x3);
X	s4x3 = sin(4*x3);
X	c4x3 = cos(4*x3);
X	c2x5 = cos(2*x5);
X	s5x7 = sin(5*x7);
X	x8 = x4-x3;
X	s2x8 = sin(2*x8);
X	c2x8 = cos(2*x8);
X	s3x8 = sin(3*x8);
X	c3x8 = cos(3*x8);
X
X	*dml = 7.581e-3*s2x5-7.986e-3*sx6-1.48811e-1*sx7-4.0786e-2*s2x7-
X	      (8.14181e-1-(1.815e-2-1.6714e-2*x1)*x1)*sx5-
X	      (1.0497e-2-(1.60906e-1-4.1e-3*x1)*x1)*cx5-1.5208e-2*s3x7-
X	      6.339e-3*s4x7-6.244e-3*sx3-1.65e-2*s2x7*sx3+
X	      (8.931e-3+2.728e-3*x1)*sx7*sx3-5.775e-3*s3x7*sx3+
X	      (8.1344e-2+3.206e-3*x1)*cx7*sx3+1.5019e-2*c2x7*sx3;
X	*dml += (8.5581e-2+2.494e-3*x1)*sx7*cx3+1.4394e-2*c2x7*cx3+
X	      (2.5328e-2-3.117e-3*x1)*cx7*cx3+
X	      6.319e-3*c3x7*cx3+6.369e-3*sx7*s2x3+9.156e-3*s2x7*s2x3+
X	      7.525e-3*s3x8*s2x3-5.236e-3*cx7*c2x3-7.736e-3*c2x7*c2x3-
X	      7.528e-3*c3x8*c2x3;
X	*dml = degrad(*dml);
X
X	*ds = (-7927+(2548+91*x1)*x1)*sx5+(13381+(1226-253*x1)*x1)*cx5+
X	     (248-121*x1)*s2x5-(305+91*x1)*c2x5+412*s2x7+12415*sx3+
X	     (390-617*x1)*sx7*sx3+(165-204*x1)*s2x7*sx3+26599*cx7*sx3-
X	     4687*c2x7*sx3-1870*c3x7*sx3-821*c4x7*sx3-
X	     377*c5x7*sx3+497*c2x8*sx3+(163-611*x1)*cx3;
X	*ds += -12696*sx7*cx3-4200*s2x7*cx3-1503*s3x7*cx3-619*s4x7*cx3-
X	     268*s5x7*cx3-(282+1306*x1)*cx7*cx3+(-86+230*x1)*c2x7*cx3+
X	     461*s2x8*cx3-350*s2x3+(2211-286*x1)*sx7*s2x3-
X	     2208*s2x7*s2x3-568*s3x7*s2x3-346*s4x7*s2x3-
X	     (2780+222*x1)*cx7*s2x3+(2022+263*x1)*c2x7*s2x3+248*c3x7*s2x3+
X	     242*s3x8*s2x3+467*c3x8*s2x3-490*c2x3-(2842+279*x1)*sx7*c2x3;
X	*ds += (128+226*x1)*s2x7*c2x3+224*s3x7*c2x3+
X	     (-1594+282*x1)*cx7*c2x3+(2162-207*x1)*c2x7*c2x3+
X	     561*c3x7*c2x3+343*c4x7*c2x3+469*s3x8*c2x3-242*c3x8*c2x3-
X	     205*sx7*s3x3+262*s3x7*s3x3+208*cx7*c3x3-271*c3x7*c3x3-
X	     382*c3x7*s4x3-376*s3x7*c4x3;
X	*ds *= 1e-7;
X
X	dp = (7.7108e-2+(7.186e-3-1.533e-3*x1)*x1)*sx5-7.075e-3*sx7+
X	     (4.5803e-2-(1.4766e-2+5.36e-4*x1)*x1)*cx5-7.2586e-2*cx3-
X	     7.5825e-2*sx7*sx3-2.4839e-2*s2x7*sx3-8.631e-3*s3x7*sx3-
X	     1.50383e-1*cx7*cx3+2.6897e-2*c2x7*cx3+1.0053e-2*c3x7*cx3-
X	     (1.3597e-2+1.719e-3*x1)*sx7*s2x3+1.1981e-2*s2x7*c2x3;
X	dp += -(7.742e-3-1.517e-3*x1)*cx7*s2x3+
X	     (1.3586e-2-1.375e-3*x1)*c2x7*c2x3-
X	     (1.3667e-2-1.239e-3*x1)*sx7*c2x3+
X	     (1.4861e-2+1.136e-3*x1)*cx7*c2x3-
X	     (1.3064e-2+1.628e-3*x1)*c2x7*c2x3;
X
X	*dm = *dml-(degrad(dp)/s);
X
X	*da = 572*sx5-1590*s2x7*cx3+2933*cx5-647*s3x7*cx3+33629*cx7-
X	     344*s4x7*cx3-3081*c2x7+2885*cx7*cx3-1423*c3x7+
X	     (2172+102*x1)*c2x7*cx3-671*c4x7+296*c3x7*cx3-320*c5x7-
X	     267*s2x7*s2x3+1098*sx3-778*cx7*s2x3-2812*sx7*sx3;
X	*da += 495*c2x7*s2x3+688*s2x7*sx3+250*c3x7*s2x3-393*s3x7*sx3-
X	     856*sx7*c2x3-228*s4x7*sx3+441*s2x7*c2x3+2138*cx7*sx3+
X	     296*c2x7*c2x3-999*c2x7*sx3+211*c3x7*c2x3-642*c3x7*sx3-
X	     427*sx7*s3x3-325*c4x7*sx3+398*s3x7*s3x3-890*cx3+
X	     344*cx7*c3x3+2206*sx7*cx3-427*c3x7*c3x3;
X	*da *= 1e-6;
X
X	*dhl = 7.47e-4*cx7*sx3+1.069e-3*cx7*cx3+2.108e-3*s2x7*s2x3+
X	      1.261e-3*c2x7*s2x3+1.236e-3*s2x7*c2x3-2.075e-3*c2x7*c2x3;
X	*dhl = degrad(*dhl);
}
X
/* ....uranus */
static
p_uranus (t, s, dl, dr, dml, ds, dm, da, dhl)
double t, s;
double *dl, *dr, *dml, *ds, *dm, *da, *dhl;
{
X	double dp;
X	double x1, x2, x3, x4, x5, x6;
X	double x8, x9, x10, x11, x12;
X	double sx4, cx4, s2x4, c2x4;
X	double sx9, cx9, s2x9, c2x9;
X	double sx11, cx11;
X
X	aux_jsun (t, &x1, &x2, &x3, &x4, &x5, &x6);
X
X        x8 = mod2PI(1.46205+3.81337*t);
X        x9 = 2*x8-x4;
X	sx9 = sin(x9);
X	cx9 = cos(x9);
X        s2x9 = sin(2*x9);
X	c2x9 = cos(2*x9);
X
X	x10 = x4-x2;
X	x11 = x4-x3;
X	x12 = x8-x4;
X
X	*dml = (8.64319e-1-1.583e-3*x1)*sx9+(8.2222e-2-6.833e-3*x1)*cx9+
X	      3.6017e-2*s2x9-3.019e-3*c2x9+8.122e-3*sin(x6);
X	*dml = degrad(*dml);
X
X	dp = 1.20303e-1*sx9+6.197e-3*s2x9+(1.9472e-2-9.47e-4*x1)*cx9;
X	*dm = *dml-(degrad(dp)/s);
X
X	*ds = (163*x1-3349)*sx9+20981*cx9+1311*c2x9;
X	*ds *= 1e-7;
X
X	*da = -3.825e-3*cx9;
X
X	*dl = (1.0122e-2-9.88e-4*x1)*sin(x4+x11)+
X	     (-3.8581e-2+(2.031e-3-1.91e-3*x1)*x1)*cos(x4+x11)+
X	     (3.4964e-2-(1.038e-3-8.68e-4*x1)*x1)*cos(2*x4+x11)+
X	     5.594e-3*sin(x4+3*x12)-1.4808e-2*sin(x10)-
X	     5.794e-3*sin(x11)+2.347e-3*cos(x11)+9.872e-3*sin(x12)+
X	     8.803e-3*sin(2*x12)-4.308e-3*sin(3*x12);
X
X	sx11 = sin(x11);
X	cx11 = cos(x11);
X	sx4 = sin(x4);
X	cx4 = cos(x4);
X	s2x4 = sin(2*x4);
X	c2x4 = cos(2*x4);
X	*dhl = (4.58e-4*sx11-6.42e-4*cx11-5.17e-4*cos(4*x12))*sx4-
X	      (3.47e-4*sx11+8.53e-4*cx11+5.17e-4*sin(4*x11))*cx4+
X	      4.03e-4*(cos(2*x12)*s2x4+sin(2*x12)*c2x4);
X	*dhl = degrad(*dhl);
X
X	*dr = -25948+4985*cos(x10)-1230*cx4+3354*cos(x11)+904*cos(2*x12)+
X	     894*(cos(x12)-cos(3*x12))+(5795*cx4-1165*sx4+1388*c2x4)*sx11+
X	     (1351*cx4+5702*sx4+1388*s2x4)*cos(x11);
X	*dr *= 1e-6;
}
X
/* ....neptune */
static
p_neptune (t, s, dl, dr, dml, ds, dm, da, dhl)
double t, s;
double *dl, *dr, *dml, *ds, *dm, *da, *dhl;
{
X	double dp;
X	double x1, x2, x3, x4, x5, x6;
X	double x8, x9, x10, x11, x12;
X	double sx8, cx8;
X	double sx9, cx9, s2x9, c2x9;
X	double s2x12, c2x12;
X
X	aux_jsun (t, &x1, &x2, &x3, &x4, &x5, &x6);
X
X        x8 = mod2PI(1.46205+3.81337*t);
X        x9 = 2*x8-x4;
X	sx9 = sin(x9);
X	cx9 = cos(x9);
X        s2x9 = sin(2*x9);
X	c2x9 = cos(2*x9);
X
X	x10 = x8-x2;
X	x11 = x8-x3;
X	x12 = x8-x4;
X
X	*dml = (1.089e-3*x1-5.89833e-1)*sx9+(4.658e-3*x1-5.6094e-2)*cx9-
X	      2.4286e-2*s2x9;
X	*dml = degrad(*dml);
X
X	dp = 2.4039e-2*sx9-2.5303e-2*cx9+6.206e-3*s2x9-5.992e-3*c2x9;
X
X	*dm = *dml-(degrad(dp)/s);
X
X	*ds = 4389*sx9+1129*s2x9+4262*cx9+1089*c2x9;
X	*ds *= 1e-7;
X
X	*da = 8189*cx9-817*sx9+781*c2x9;
X	*da *= 1e-6;
X
X	s2x12 = sin(2*x12);
X	c2x12 = cos(2*x12);
X	sx8 = sin(x8);
X	cx8 = cos(x8);
X	*dl = -9.556e-3*sin(x10)-5.178e-3*sin(x11)+2.572e-3*s2x12-
X	     2.972e-3*c2x12*sx8-2.833e-3*s2x12*cx8;
X
X	*dhl = 3.36e-4*c2x12*sx8+3.64e-4*s2x12*cx8;
X	*dhl = degrad(*dhl);
X
X	*dr = -40596+4992*cos(x10)+2744*cos(x11)+2044*cos(x12)+1051*c2x12;
X	*dr *= 1e-6;
}
X
SHAR_EOF
chmod 0644 plans.c ||
echo 'restore of plans.c failed'
Wc_c="`wc -c < 'plans.c'`"
test 17647 -eq "$Wc_c" ||
	echo 'plans.c: original size 17647, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= plot.c ==============
if test -f 'plot.c' -a X"$1" != X"-c"; then
	echo 'x - skipping plot.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting plot.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'plot.c' &&
/* code to manage the stuff on the "plot" menu.
X */
X
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#ifdef VMS
#include <stdlib.h>
#endif
#include <X11/Xlib.h>
#include <Xm/Xm.h>
#include <Xm/Form.h>
#include <Xm/DrawingA.h>
#include <Xm/LabelG.h>
#include <Xm/PushBG.h>
#include <Xm/ToggleBG.h>
#include <Xm/Text.h>
#include "fieldmap.h"
/* N.B. if you need circum.h for something, beware of the height #define - it
X * interferes with the height member of the XResizeRequestEvent structure.
X */
X
extern Widget toplevel_w;
#define	XtD	XtDisplay(toplevel_w)
X
#ifdef VMS
#include <perror.h>
#include <errno.h>
#else
extern char *sys_errlist[];
extern errno;
#endif
X
#define	errsys	(sys_errlist[errno])
X
#define	MAXPLTLINES	10
X
/* locations of each field.
X * these are in terms of a 1-based row/col on a 24x80 alpha screen, for
X * historical reasons.
X */
#define	NR	(R_TABLE+MAXPLTLINES+1)	/* +1 for close/help buttons */
#define	NC	34
X
#define	R_SELECT	1
#define	R_ACTIVE	2
#define	R_SHOW		3
X
#define	R_FNLABEL	5
#define	R_FILENAME	6
X
#define	R_TLABEL	8
#define	R_TITLE		9
X
#define	R_PROMPT	11
#define	R_HEADERS	12
#define	R_TABLE		13
#define	R_CONTROL	NR
X
#define	C_TAG		(1*NC/9)
#define	C_X		(3*NC/9)
#define	C_Y		(6*NC/9)
X
static Widget plotform_w;
static Widget select_w, active_w, prompt_w;
static Widget title_w, filename_w;
static Widget table_w[MAXPLTLINES][3];	/* column indeces follow.. */
static int selecting_xy;		/* also one of ... */
#define	T	0
#define	X	1
#define	Y	2
X
#define	DEF_PLTFN	"ephem.plt"	/* default plot file name */
static FILE *plt_fp;            /* the plot file; == 0 means don't plot */
X
X
/* plt_activate_cb client values. */
#define	SELECT	0
#define	ACTIVE	1
#define	SHOW	2
X
/* store the Widget for each x and y line to track.
X * we get the label straight from the Text widget in the table as needed.
X */
typedef struct {
X    Widget pl_xw, pl_yw;
} PltLine;
static PltLine pltlines[MAXPLTLINES];
static int npltlines;		/* number of pltlines[] in actual use */
X
/* one of these gets malloced and passed to the drawing area expose callback via
X * its client parameter. be sure to free it when the parent FormDialog goes
X * away too.
X * by doing this, we can have lots of different plots up at once and yet we
X * don't have to keep track of them - they track themselves.
X */
typedef struct {
X    char *filename;	/* name of file being plotted (also malloced) */
X    FILE *fp;		/* FILE pointer for the file */
X    int flipx, flipy;	/* flip state for this instance */
X    int grid;		/* whether to include a grid */
} DrawInfo;
X
/* called when the plot menu is activated via the main menu pulldown.
X * if never called before, create and manage all the widgets as a child of a
X * form. otherwise, just toggle whether the form is managed.
X */
plot_manage ()
{
X	if (!plotform_w) {
X	    void plt_activate_cb();
X	    void plt_close_cb();
X	    void plt_help_cb();
X	    XmString str;
X	    Widget w;
X	    Arg args[20];
X	    int i, n;
X
X	    /* create form */
X	    n = 0;
X	    XtSetArg (args[n], XmNfractionBase, 1000); n++;
X	    XtSetArg (args[n], XmNautoUnmanage, False); n++;
X	    XtSetArg (args[n], XmNhorizontalSpacing, 50); n++;
X	    XtSetArg (args[n], XmNdefaultPosition, False); n++;
X	    XtSetArg (args[n], XmNresizePolicy, XmRESIZE_NONE); n++;
X	    XtSetArg (args[n], XmNwidth, char_width()*NC); n++;
X	    plotform_w = XmCreateFormDialog (toplevel_w, "Plot", args, n);
X
X	    /* set some stuff in the parent DialogShell.
X	     * setting XmNdialogTitle in the Form didn't work..
X	     */
X	    n = 0;
X	    XtSetArg (args[n], XmNtitle, "xephem Plot Control"); n++;
X	    XtSetValues (XtParent(plotform_w), args, n);
X
X	    /* make the control controls */
X
X	    str = XmStringCreate("Select fields", XmSTRING_DEFAULT_CHARSET);
X	    n = 0;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_SELECT)); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, 0); n++;
X	    XtSetArg (args[n], XmNlabelString, str); n++;
X	    select_w = XmCreateToggleButtonGadget(plotform_w, "PlotSelect",
X								    args, n);
X	    XmStringFree (str);
X	    XtManageChild (select_w);
X	    XtAddCallback(select_w,XmNvalueChangedCallback, plt_activate_cb,
X									SELECT);
X
X	    str = XmStringCreate("Plot to file", XmSTRING_DEFAULT_CHARSET);
X	    n = 0;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_ACTIVE)); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, 0); n++;
X	    XtSetArg (args[n], XmNlabelString, str); n++;
X	    active_w = XmCreateToggleButtonGadget(plotform_w, "PlotActive",
X								    args, n);
X	    XmStringFree (str);
X	    XtManageChild (active_w);
X	    XtAddCallback (active_w, XmNvalueChangedCallback, plt_activate_cb,
X									ACTIVE);
X
X	    n = 0;
X	    str = XmStringCreate("Show plot file", XmSTRING_DEFAULT_CHARSET);
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_SHOW)); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, 0); n++;
X	    XtSetArg (args[n], XmNlabelString, str); n++;
X	    w = XmCreateToggleButtonGadget(plotform_w, "PlotShow", args, n);
X	    XmStringFree (str);
X	    XtManageChild (w);
X	    XtAddCallback (w, XmNvalueChangedCallback, plt_activate_cb, SHOW);
X
X	    /* make the close button */
X
X	    str = XmStringCreate ("Close", XmSTRING_DEFAULT_CHARSET);
X	    n = 0;
X	    XtSetArg (args[n], XmNlabelString, str); n++;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_CONTROL)); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, 0); n++;
X	    w = XmCreatePushButtonGadget (plotform_w, "PlotClose", args, n);
X	    XtAddCallback (w, XmNactivateCallback, plt_close_cb, 0);
X	    XtManageChild (w);
X	    XmStringFree (str);
X
X	    /* make the help button */
X
X	    str = XmStringCreate ("Help", XmSTRING_DEFAULT_CHARSET);
X	    n = 0;
X	    XtSetArg (args[n], XmNlabelString, str); n++;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_CONTROL)); n++;
X	    XtSetArg (args[n], XmNrightAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNrightPosition, 1000); n++;
X	    w = XmCreatePushButtonGadget (plotform_w, "PlotHelp", args, n);
X	    XtAddCallback (w, XmNactivateCallback, plt_help_cb, 0);
X	    XtManageChild (w);
X	    XmStringFree (str);
X
X	    /* create filename text area and its label */
X	    n = 0;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_FILENAME)); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, 50); n++;
X	    XtSetArg (args[n], XmNrightAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNrightPosition, 950); n++;
X	    filename_w = XmCreateText (plotform_w, "PlotFilename", args, n);
X	    XmTextSetString (filename_w, DEF_PLTFN);
X	    XtManageChild (filename_w);
X
X	    n = 0;
X	    str = XmStringCreate("File name:", XmSTRING_DEFAULT_CHARSET);
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_FNLABEL)); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, 0); n++;
X	    XtSetArg (args[n], XmNlabelString, str); n++;
X	    w = XmCreateLabelGadget (plotform_w, "PlotFnL", args, n);
X	    XmStringFree (str);
X	    XtManageChild (w);
X
X	    /* create title text area and its label */
X	    n = 0;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_TITLE)); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, 50); n++;
X	    XtSetArg (args[n], XmNrightAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNrightPosition, 950); n++;
X	    title_w = XmCreateText (plotform_w, "PlotTitle", args, n);
X	    XtManageChild (title_w);
X
X	    n = 0;
X	    str = XmStringCreate("Title:", XmSTRING_DEFAULT_CHARSET);
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_TLABEL)); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, 0); n++;
X	    XtSetArg (args[n], XmNlabelString, str); n++;
X	    w = XmCreateLabelGadget (plotform_w, "PlotTL", args, n);
X	    XtManageChild (w);
X	    XmStringFree (str);
X
X	    /* create prompt line and table headings */
X
X	    n = 0;
X	    str = XmStringCreate("", XmSTRING_DEFAULT_CHARSET);
X	    XtSetArg (args[n], XmNlabelString, str); n++;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_PROMPT)); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, 50); n++;
X	    XtSetArg (args[n], XmNrightAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNrightPosition, 950); n++;
X	    XtSetArg (args[n], XmNalignment, XmALIGNMENT_BEGINNING); n++;
X	    prompt_w = XmCreateLabelGadget (plotform_w, "PlotPrompt", args, n);
X	    XtManageChild (prompt_w);
X	    XmStringFree (str);
X
X	    n = 0;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_HEADERS)); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, c2xpos(C_TAG-1));n++;
X	    XtSetArg (args[n], XmNalignment, XmALIGNMENT_BEGINNING); n++;
X	    w = XmCreateLabelGadget (plotform_w, "Tag", args, n);
X	    XtManageChild (w);
X
X	    n = 0;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_HEADERS)); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, c2xpos(C_X));n++;
X	    XtSetArg (args[n], XmNalignment, XmALIGNMENT_BEGINNING); n++;
X	    w = XmCreateLabelGadget (plotform_w, "X", args, n);
X	    XtManageChild (w);
X
X	    n = 0;
X	    XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNtopPosition, r2ypos(R_HEADERS)); n++;
X	    XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	    XtSetArg (args[n], XmNleftPosition, c2xpos(C_Y));n++;
X	    XtSetArg (args[n], XmNalignment, XmALIGNMENT_BEGINNING); n++;
X	    w = XmCreateLabelGadget (plotform_w, "Y", args, n);
X	    XtManageChild (w);
X
X	    /* make the tag/x/y controls, but don't manage them now */
X	    for (i = 0; i < MAXPLTLINES; i++) {
X		n = 0;
X		XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X		XtSetArg (args[n], XmNtopPosition, r2ypos(R_TABLE+i)); n++;
X		XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X		XtSetArg (args[n], XmNleftPosition, c2xpos(C_TAG)); n++;
X		XtSetArg (args[n], XmNmaxLength, 1); n++;
X		XtSetArg (args[n], XmNcolumns, 1); n++;
X		table_w[i][T] = XmCreateText (plotform_w, "PlotTag", args, n);
X
X		n = 0;
X		XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X		XtSetArg (args[n], XmNtopPosition, r2ypos(R_TABLE+i)); n++;
X		XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X		XtSetArg (args[n], XmNleftPosition, c2xpos(C_X)); n++;
X		table_w[i][X] = XmCreateLabelGadget (plotform_w, "PlotX",
X								    args, n);
X
X		n = 0;
X		XtSetArg (args[n], XmNtopAttachment, XmATTACH_POSITION); n++;
X		XtSetArg (args[n], XmNtopPosition, r2ypos(R_TABLE+i)); n++;
X		XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X		XtSetArg (args[n], XmNleftPosition, c2xpos(C_Y)); n++;
X		table_w[i][Y] = XmCreateLabelGadget (plotform_w, "PlotY",
X								    args, n);
X
X	    }
X	}
X	
X	if (XtIsManaged(plotform_w))
X	    XtUnmanageChild (plotform_w);
X	else
X	    XtManageChild (plotform_w);
}
X
/* called by the other menus (data, riset, etc) as their buttons are
X * selected to inform us that that button is to be included in a plot.
X */
plt_selection (fp)
FieldMap *fp;
{
X	Widget tw;
X
X	if (!plotform_w
X		|| !XtIsManaged(plotform_w)
X		|| !XmToggleButtonGadgetGetState(select_w))
X	    return;
X
X	if (flog_add(fp->w) < 0) {
X	    f_msg ("Sorry; can not log any more fields.", 0);
X	    if (selecting_xy == Y) {
X		/* if yth one won't fit, discard the xth one too */
X		Widget w = pltlines[npltlines].pl_xw;
X		(void) flog_delete (w);
X		plt_stop_selecting();
X	    }
X	    return;
X	}
X
X	tw = table_w[npltlines][selecting_xy];
X	set_xmstring (tw, XmNlabelString, fp->name);
X	XtManageChild (tw);
X
X	if (selecting_xy == X) {
X	    pltlines[npltlines].pl_xw = fp->w;
X	    selecting_xy = Y;
X	    f_string (prompt_w, "Select quantity for Y..");
X	} else {
X	    pltlines[npltlines].pl_yw = fp->w;
X	    if (++npltlines == MAXPLTLINES)
X		plt_stop_selecting();
X	    else {
X		selecting_xy = X;
X		init_next_tag();
X	    }
X	}
}
X
/* write the active plotfields to the current plot file, if one is open. */
plot()
{
X	if (plt_fp) {
X	    /* plot in order of original selection */
X	    PltLine *plp;
X	    double x, y;
X	    for (plp = pltlines; plp < &pltlines[npltlines]; plp++)
X		if (flog_get (plp->pl_xw, &x, (char *)0) == 0 
X			    && flog_get (plp->pl_yw, &y, (char *)0) == 0) {
X		    char *lbl = XmTextGetString (table_w[plp-pltlines][T]);
X		    (void) fprintf (plt_fp, "%c,%.12g,%.12g\n", lbl[0], x, y);
X		    XtFree (lbl);
X		}
X	}
}
X
plot_ison()
{
X	return (plt_fp != 0);
}
X
/* callback from any of the plot menu toggle buttons being activated.
X */
void
plt_activate_cb (w, client, call)
Widget w;
caddr_t client;
caddr_t call;
{
X	XmToggleButtonCallbackStruct *t = (XmToggleButtonCallbackStruct *) call;
X	int what = (int) client;
X
X	switch (what) {
X	case SELECT:
X	    if (t->set) {
X		/* first turn off plotting, if on, while we change things */
X		if (XmToggleButtonGadgetGetState(active_w))
X		    XmToggleButtonGadgetSetState(active_w, False, True);
X		plt_reset();	/* reset pltlines array and unmanage the table*/
X		plt_select(1);	/* inform other menus to inform us of fields */
X		init_next_tag();/* set first tag to something and show it */
X		selecting_xy = X;
X	    } else
X		plt_stop_selecting();
X	    break;
X	case ACTIVE:
X	    if (t->set) {
X		/* first turn off selecting, if on */
X		if (XmToggleButtonGadgetGetState(select_w))
X		    XmToggleButtonGadgetSetState(select_w, False, True);
X		plt_try_turn_on();
X	    } else
X		plt_turn_off();
X	    break;
X	case SHOW:
X	    /* turn off plotting, if on, to make sure file is complete. */
X	    if (XmToggleButtonGadgetGetState(active_w))
X		XmToggleButtonGadgetSetState(active_w, False, True);
X	    plt_da_manage();
X	    /* we want this to work like it was a pushbutton, really */
X	    XmToggleButtonGadgetSetState(w, False, False);
X	    break;
X	}
}
X
/* callback from the Close button.
X */
void
plt_close_cb (w, client, call)
Widget w;
caddr_t client;
caddr_t call;
{
X	XtUnmanageChild (plotform_w);
}
X
/* callback from the Help button.
X */
void
plt_help_cb (w, client, call)
Widget w;
caddr_t client;
caddr_t call;
{
static char *help_msg[] = {
"This menu controls the plot generation and display functionality of xephem.",
"Select fields to form x/y pairs, enable plotting to write them to a file on",
"each xephem iteration step, then view. Each file may be titled, as desired."
};
X	hlp_dialog ("Plot", help_msg, sizeof(help_msg)/sizeof(help_msg[0]));
}
X
/* inform the other menues whether we are setting up for them to tell us
X * what fields to plot.
X */
plt_select(whether)
int whether;
{
X	dm_selection_mode(whether);
X	mm_selection_mode(whether);
X	rm_selection_mode(whether);
X	sm_selection_mode(whether);
X	jm_selection_mode(whether);
X	srch_selection_mode(whether);
}
X
/* stop logging our collection of selected widgets, forget our list,
X * and unmanage the table.
X */
static
plt_reset()
{
X	PltLine *plp;
X	int i;
X
X	for (plp = &pltlines[npltlines]; --plp >= pltlines; ) {
X	    (void) flog_delete (plp->pl_xw);
X	    (void) flog_delete (plp->pl_yw);
X	    plp->pl_xw = plp->pl_yw = 0;
X	}
X
X	for (i = 0; i < npltlines; i++) {
X	    XtUnmanageChild (table_w[i][T]);
X	    XtUnmanageChild (table_w[i][X]);
X	    XtUnmanageChild (table_w[i][Y]);
X	}
X
X	npltlines = 0;
}
X
/* stop selecting: unmanage a partitially filled in line specs; tell
X * everybody else to drop their buttons, make sure toggle is off.
X */
static
plt_stop_selecting()
{
X	/* harmless to unmanage something already unmanaged so do them all */
X	if (npltlines < MAXPLTLINES) {
X	    XtUnmanageChild (table_w[npltlines][T]);
X	    XtUnmanageChild (table_w[npltlines][X]);
X	    XtUnmanageChild (table_w[npltlines][Y]);
X	}
X
X	XmToggleButtonGadgetSetState (select_w, False, False);
X	plt_select(0);
X	f_string (prompt_w, "");
}
X
static
plt_turn_off ()
{
X	if (plt_fp) {
X	    (void) fclose (plt_fp);
X	    plt_fp = 0;
X	}
}
X
init_next_tag()
{
X	char buf[100];
X	Widget w = table_w[npltlines][T];
X
X	f_string (prompt_w, "Select quantity for X..");
X	(void) sprintf (buf, "%d", npltlines);
X	XmTextSetString (w, buf);
X	XtManageChild (w);
}
X
/* called from the query routine when want to append to an existing plot file.*/
static void
plt_try_append()
{
X	plt_turn_on("a");
}
X
/* called from the query routine when want to overwrite to an existing plot
X * file.
X */
static void
plt_try_overwrite()
{
X	plt_turn_on("w");
}
X
/* called from the query routine when want decided not to make a plot file.  */
static void
plt_try_cancel()
{
X	XmToggleButtonGadgetSetState (active_w, False, False);
}
X
/* attempt to open file for use as a plot file.
X * if it doesn't exist, then go ahead and make it.
X * but if it does, first ask wheher to append or overwrite.
X */
static
plt_try_turn_on()
{
X	char *txt = XmTextGetString (filename_w);
X	if (access (txt, 0) == 0) {
X	    char *buf;
X	    buf = XtMalloc (strlen(txt)+100);
X	    (void) sprintf (buf, "%s exists: Append or Overwrite?", txt);
X	    query (toplevel_w, buf, "Append", "Overwrite", "Cancel",
X			    plt_try_append, plt_try_overwrite, plt_try_cancel);
X	    XtFree (buf);
X	} else
X	    plt_turn_on("w");
X	XtFree (txt);
}
X
/* turn on plotting.
X * establish a file to use (and thereby set plt_fp, the plotting_is_on flag).
X */
static
plt_turn_on (how)
char *how;	/* fopen how argument */
{
X	char *txt;
X
X	/* plotting is on if file opens ok */
X	txt = XmTextGetString (filename_w);
X	plt_fp = fopen (txt, how);
X	if (!plt_fp) {
X	    char *buf;
X	    XmToggleButtonGadgetSetState (active_w, False, False);
X	    buf = XtMalloc (strlen(txt)+100);
X	    (void) sprintf (buf, "Can not open %s: %s", txt, errsys);
X	    f_msg (buf, 0);
X	    XtFree (buf);
X	}
X	XtFree (txt);
X	
X	if (plt_fp) {
X	    /* add a title if it's not null */
X	    txt = XmTextGetString (title_w);
X	    if (txt[0] != '\0')
X		(void) fprintf (plt_fp, "* %s\n", txt);
X	    XtFree (txt);
X	}
}
X
/* make a new drawing area widget and manage it. it's unmanaged and destroyed
X *   with its own button via autoUnmanage.
X * open the plot file and save it, the current state of the flipx/flipy/grid
X *   buttons and the filename in a DrawInfo struct in the userData resource
X *   for the FormDialog where the drawingarea callback can get at it each time.
X * this way, we can have lots of different plots up at once yet we don't
X *   have to keep track of them.
X * by leaving the file open, we gain some protection against it being removed
X *   or renamed.
X */
static
plt_da_manage()
{
X	void plt_da_exp_cb(), plt_da_unmap_cb();
X	void plt_da_flipx_cb(), plt_da_flipy_cb(), plt_da_grid_cb();
X	Widget daform_w;
X	Widget da_w, w;
X	XmString str;
X	Arg args[20];
X	int n;
X	DrawInfo *di;
X	FILE *fp;
X	char *fn;
X
X	/* first make sure we can open the plot file */
X	fn = XmTextGetString (filename_w);
X	fp = fopen (fn, "r");
X	if (!fp) {
X	    char *buf;
X	    buf = XtMalloc (strlen(fn)+100);
X	    (void) sprintf (buf, "Can not open %s: %s", fn, errsys);
X	    f_msg (buf, 0);
X	    XtFree (buf);
X	    XtFree (fn);
X	    return;
X	}
X
X	/* create the form dialog parent */
X	n = 0;
X	XtSetArg (args[n], XmNunitType, XmPIXELS); n++;
X	XtSetArg (args[n], XmNwidth, 350); n++;
X	XtSetArg (args[n], XmNheight, 375); n++;
X	XtSetArg (args[n], XmNautoUnmanage, True); n++;
X	XtSetArg (args[n], XmNdefaultPosition, True); n++;
X	daform_w = XmCreateFormDialog (toplevel_w, "PlotD", args, n);
X	XtAddCallback (daform_w, XmNunmapCallback, plt_da_unmap_cb, 0);
X
X	/* make the DrawInfo structure and save it in the userData of the Form.
X	 * it gets freed when the it is unmanaged.
X	 */
X	di = (DrawInfo *) XtMalloc (sizeof(DrawInfo));
X	di->filename = fn;
X	di->fp = fp;
X	di->flipx = 0;
X	di->flipy = 0;
X	di->grid = 0;
X	set_something (daform_w, XmNuserData, (caddr_t)di);
X
X	/* set some stuff in the parent DialogShell.
X	 * setting XmNdialogTitle in the Form didn't work..
X	 */
X	n = 0;
X	XtSetArg (args[n], XmNtitle, "xephem Plot"); n++;
X	XtSetValues (XtParent(daform_w), args, n);
X
X	/* create a "Close" button. it will bring down the plot
X	 * automatically because of autoUnmanage being set in daform_w.
X	 */
X	n = 0;
X	XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNbottomOffset, 5); n++;
X	XtSetArg (args[n], XmNrightAttachment, XmATTACH_FORM); n++;
X	w = XmCreatePushButtonGadget (daform_w, "Close", args, n);
X	XtManageChild (w);
X
X	/* create the drawing area and connect plt_da_exp_cb().
X	 * N.B. be sure this guys parent is the FormDialog so exp_cb can find
X	 *   the DrawInfo by looking there at its userData.
X	 */
X	n = 0;
X	XtSetArg (args[n], XmNtopAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNbottomAttachment, XmATTACH_WIDGET); n++;
X	XtSetArg (args[n], XmNbottomOffset, 2); n++;
X	XtSetArg (args[n], XmNbottomWidget, w); n++;
X	XtSetArg (args[n], XmNleftAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNrightAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNmarginWidth, 0); n++;
X	XtSetArg (args[n], XmNmarginHeight, 0); n++;
X	da_w = XmCreateDrawingArea (daform_w, "PlotDA", args, n);
X	XtAddCallback (da_w, XmNexposeCallback, plt_da_exp_cb, 0);
X	XtAddCallback (da_w, XmNresizeCallback, plt_da_exp_cb, 0);
X	XtManageChild (da_w);
X
X	/* make the flipx/y and grid buttons */
X
X	n = 0;
X	str = XmStringCreate("Flip X", XmSTRING_DEFAULT_CHARSET);
X	XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNbottomOffset, 5); n++;
X	XtSetArg (args[n], XmNleftAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNlabelString, str); n++;
X	XtSetArg (args[n], XmNset, di->flipx); n++;
X	w = XmCreateToggleButtonGadget(daform_w, "DAFlipX", args, n);
X	XmStringFree (str);
X	XtAddCallback (w, XmNvalueChangedCallback, plt_da_flipx_cb, da_w);
X	XtManageChild (w);
X
X	n = 0;
X	str = XmStringCreate("Flip Y", XmSTRING_DEFAULT_CHARSET);
X	XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNbottomOffset, 5); n++;
X	XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	XtSetArg (args[n], XmNleftPosition, 25); n++;
X	XtSetArg (args[n], XmNlabelString, str); n++;
X	XtSetArg (args[n], XmNset, di->flipy); n++;
X	w = XmCreateToggleButtonGadget(daform_w, "DAFlipY", args, n);
X	XmStringFree (str);
X	XtAddCallback (w, XmNvalueChangedCallback, plt_da_flipy_cb, da_w);
X	XtManageChild (w);
X
X	n = 0;
X	str = XmStringCreate("Grid", XmSTRING_DEFAULT_CHARSET);
X	XtSetArg (args[n], XmNbottomAttachment, XmATTACH_FORM); n++;
X	XtSetArg (args[n], XmNbottomOffset, 5); n++;
X	XtSetArg (args[n], XmNleftAttachment, XmATTACH_POSITION); n++;
X	XtSetArg (args[n], XmNleftPosition, 50); n++;
X	XtSetArg (args[n], XmNlabelString, str); n++;
X	XtSetArg (args[n], XmNset, di->grid); n++;
X	w = XmCreateToggleButtonGadget(daform_w, "DAGrid", args, n);
X	XmStringFree (str);
X	XtAddCallback (w, XmNvalueChangedCallback, plt_da_grid_cb, da_w);
X	XtManageChild (w);
X	
X	/* go. the expose will do the actual plotting */
X	XtManageChild (daform_w);
}
X
/* unmap callback from the FormDialog managing the drawing area.
X * free the DrawInfo and destroy ourselves.
X */
static void
plt_da_unmap_cb (w, client, call)
Widget w;
caddr_t client;
caddr_t call;
{
X	DrawInfo *di;
X
X	get_something (w, XmNuserData, (caddr_t)&di);
X	fclose (di->fp);
X	XtFree(di->filename);
X	XtFree((char *)di);
X	XtDestroyWidget(w);
}
X
/* callback from the Flip X toggle button within the drawing FormDiag itself.
X * toggle the x bit in the parent's DrawInfo structure and fake an expose.
X */
static void
plt_da_flipx_cb (w, client, call)
Widget w;
caddr_t client;
caddr_t call;
{
X	XmToggleButtonCallbackStruct *t = (XmToggleButtonCallbackStruct *) call;
X	Widget da_w = (Widget) client;
X	Widget daform_w = XtParent(da_w);
X	Display *dsp = XtDisplay(da_w);
X	Window win = XtWindow(da_w);
X	DrawInfo *di;
X	XExposeEvent ev;
X	Window root;
X	int x, y;
X	unsigned int nx, ny, bw, d;
X
X	get_something (daform_w, XmNuserData, (caddr_t)&di);
X	di->flipx = t->set;
X
X	XGetGeometry(dsp, win, &root, &x, &y, &nx, &ny, &bw, &d);
X
X	ev.type = Expose;
X	ev.send_event = 1;	/* gets set anyways */
X	ev.display = dsp;
X	ev.window = win;
X	ev.x = ev.y = 0;
X	ev.width = nx;
X	ev.height = ny;
X	ev.count = 0;
X
X	XSendEvent (dsp, win, /*propagate*/False, ExposureMask, &ev);
}
X
/* callback from the Flip Y toggle button within the drawing FormDiag itself.
X * toggle the y bit in the parent's DrawInfo structure and fake an expose.
X */
static void
plt_da_flipy_cb (w, client, call)
Widget w;
caddr_t client;
caddr_t call;
{
X	XmToggleButtonCallbackStruct *t = (XmToggleButtonCallbackStruct *) call;
X	Widget da_w = (Widget) client;
X	Widget daform_w = XtParent(da_w);
X	Display *dsp = XtDisplay(da_w);
X	Window win = XtWindow(da_w);
X	DrawInfo *di;
X	XExposeEvent ev;
X	Window root;
X	int x, y;
X	unsigned int nx, ny, bw, d;
X
X	get_something (daform_w, XmNuserData, (caddr_t)&di);
X	di->flipy = t->set;
X
X	XGetGeometry(dsp, win, &root, &x, &y, &nx, &ny, &bw, &d);
X
X	ev.type = Expose;
X	ev.send_event = 1;	/* gets set anyways */
X	ev.display = dsp;
X	ev.window = win;
X	ev.x = ev.y = 0;
X	ev.width = nx;
X	ev.height = ny;
X	ev.count = 0;
X
X	XSendEvent (dsp, win, /*propagate*/False, ExposureMask, &ev);
}
X
/* callback from the grid toggle button within the drawing FormDiag itself.
X * toggle the grid flag in the parent's DrawInfo structure and fake an expose.
X */
static void
plt_da_grid_cb (w, client, call)
Widget w;
caddr_t client;
caddr_t call;
{
X	XmToggleButtonCallbackStruct *t = (XmToggleButtonCallbackStruct *) call;
X	Widget da_w = (Widget) client;
X	Widget daform_w = XtParent(da_w);
X	Display *dsp = XtDisplay(da_w);
X	Window win = XtWindow(da_w);
X	DrawInfo *di;
X	XExposeEvent ev;
X	Window root;
X	int x, y;
X	unsigned int nx, ny, bw, d;
X
X	get_something (daform_w, XmNuserData, (caddr_t)&di);
X	di->grid = t->set;
X
X	XGetGeometry(dsp, win, &root, &x, &y, &nx, &ny, &bw, &d);
X
X	ev.type = Expose;
X	ev.send_event = 1;	/* gets set anyways */
X	ev.display = dsp;
X	ev.window = win;
X	ev.x = ev.y = 0;
X	ev.width = nx;
X	ev.height = ny;
X	ev.count = 0;
X
X	XSendEvent (dsp, win, /*propagate*/False, ExposureMask, &ev);
}
X
/* plot drawing area's expose and resize callback.
X * redraw the graph to the (new?) size.
X * get a DrawInfo from our parent's userData.
X */
static void
plt_da_exp_cb (w, client, call)
Widget w;
caddr_t client;
caddr_t call;
{
X	XmDrawingAreaCallbackStruct *c = (XmDrawingAreaCallbackStruct *)call;
X	DrawInfo *di;
X	unsigned int nx, ny;
X	Window root;
X	int x, y;
X	unsigned int bw, d;
X
X	/* fill in nx and ny with our current size */
X	switch (c->reason) {
X	case XmCR_RESIZE:
X	    /* seems we can get one resize before the first expose.
X	     * hence, we don't have a good window to use yet. just let it
X	     * go; we'll get the expose soon.
X	     */
X	    if (!XtWindow(w))
X		return;
X	    XGetGeometry(XtDisplay(w),XtWindow(w),&root,&x,&y, &nx,&ny, &bw,&d);
X	    break;
X	case XmCR_EXPOSE: {
X	    XExposeEvent *e = &c->event->xexpose;
X	    /* wait for the last in the series */
X	    if (e->count != 0)
X		return;
X	    XGetGeometry(XtDisplay(w),XtWindow(w),&root,&x,&y, &nx,&ny, &bw,&d);
X	    break;
X	    }
X	default:
X	    printf ("Unexpected daform_w event. type=%d\n", c->reason);
X	    return;
X	}
X
X	/* by now, nx and ny are set to the correct window size. 
X	 * get di from the FormDiaglog parent and plot fresh.
X	 */
X
X	get_something (XtParent(w), XmNuserData, (caddr_t)&di);
X	XClearWindow (XtDisplay(w), XtWindow(w));
X	rewind (di->fp);
X	if (plot_cartesian (di->fp,w,nx,ny,di->flipx,di->flipy,di->grid) < 0) {
X	    /* had trouble, so done with this FormDialog.
X	     * it frees its DrawInfo and gets destroyed automatically when 
X	     * unmapped.
X	     */
X	    XtUnmanageChild(XtParent(w));
X	}
}
SHAR_EOF
chmod 0644 plot.c ||
echo 'restore of plot.c failed'
Wc_c="`wc -c < 'plot.c'`"
test 28540 -eq "$Wc_c" ||
	echo 'plot.c: original size 28540, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= plot_aux.c ==============
if test -f 'plot_aux.c' -a X"$1" != X"-c"; then
	echo 'x - skipping plot_aux.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting plot_aux.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'plot_aux.c' &&
/* code to manage the actual drawing of plots.
X */
X
#include <stdio.h>
#include <ctype.h>
#include <math.h>
#ifdef VMS
#include <stdlib.h>
#endif
#include <X11/Xlib.h>
#include <Xm/Xm.h>
#include <Xm/Form.h>
#include <Xm/DrawingA.h>
#include <Xm/LabelG.h>
#include <Xm/PushBG.h>
#include <Xm/ToggleBG.h>
#include <Xm/Text.h>
X
/* maximum number of unique functions (ie tags) in the plot file.
X * to be fair, it should be at least as large as the value in plot.
X */
#define	MAXPLTLINES	10
X
static GC plt_gc, plt_gcc[MAXPLTLINES];	/* annotation and plot gcs */
static XFontStruct *plt_fs;
SHAR_EOF
true || echo 'restore of plot_aux.c failed'
fi
echo 'End of  part 7'
echo 'File plot_aux.c is continued in part 8'
echo 8 > _shar_seq_.tmp
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
