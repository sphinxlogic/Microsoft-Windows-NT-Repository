Newsgroups: comp.sources.x
Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: frank@cis.ohio-state.edu (Frank Adelstein)
Subject: v16i097: xlax - send keyboard input to multiple windows, Part01/01
Message-ID: <1992Mar3.154048.7436@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Date: Tue, 3 Mar 1992 15:40:48 GMT
Approved: dcmartin@msi.com

Submitted-by: frank@cis.ohio-state.edu (Frank Adelstein)
Posting-number: Volume 16, Issue 97
Archive-name: xlax/part01

# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 03/03/1992 15:38 UTC by dcmartin@fascet
# Source directory /home/fascet/csx/src/xlax
#
# existing files will NOT be overwritten unless -c is specified
#
#                                                                          
#                                                                          
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#    522 -rw-r--r-- README
#    273 -rw-r--r-- Imakefile
#  10508 -rw-r--r-- Makefile
#   2325 -rw-r--r-- xlax.man
#   2132 -rw-r--r-- xlax.h
#  14414 -rw-r--r-- xlax.c
#     21 -rw-r--r-- patchlevel.h
#   5056 -rw-r--r-- vroot.h
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
xlax is a program that allows output to
be sent to several windows (via SendEvent()).
X
It can be useful for some tasks that require almost
the same thing to be done on different machines.
X
Send questions, comments or whatever to 
frank@cis.ohio-state.edu.
X
Author: Frank Adelstein, with code for window selection
taken from "dsimple" in MIT clients, and "vroot.h" used
so it'll work under tvtwm.
X
Standard X copying policies apply (see the copyright notice
at the beginning of code for full details).
X
--Frank Adelstein.
X
SHAR_EOF
chmod 0644 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 522 -eq "$Wc_c" ||
	echo 'README: original size 522, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Imakefile ==============
if test -f 'Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Imakefile' &&
#Imakefile for xlax
X
#   EXTRA_LOAD_FLAGS = -Bstatic
#        CDEBUGFLAGS = -g
#            DEFINES = -DDEBUG
X            DEPLIBS = XawClientDepLibs
X    LOCAL_LIBRARIES = XawClientLibs
X               SRCS = xlax.c
X               OBJS = xlax.o
X
ComplexProgramTarget(xlax)
X
X
SHAR_EOF
chmod 0644 Imakefile ||
echo 'restore of Imakefile failed'
Wc_c="`wc -c < 'Imakefile'`"
test 273 -eq "$Wc_c" ||
	echo 'Imakefile: original size 273, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile ==============
if test -f 'Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
# Makefile generated by imake - do not edit!
# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
#
# The cpp used on this machine replaces all newlines and multiple tabs and
# spaces in a macro expansion with a single space.  Imake tries to compensate
# for this, but is not always successful.
#
X
# -------------------------------------------------------------------------
# Makefile generated from "Imake.tmpl" and </tmp/IIf.a16697>
# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
#
# Platform-specific parameters may be set in the appropriate <vendor>.cf
# configuration files.  Site-specific parameters should be set in the file
# site.def.  Full rebuilds are recommended if any parameters are changed.
#
# If your C preprocessor does not define any unique symbols, you will need
# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
# "make World" the first time).
#
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that need to come before
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
# -------------------------------------------------------------------------
# platform-specific configuration parameters - edit sun.cf to change
X
# platform:  $XConsortium: sun.cf,v 1.68 91/07/30 11:34:39 rws Exp $
X
# operating system:  SunOS 4.1.1
X
# $XConsortium: sunLib.rules,v 1.6 91/03/24 17:55:58 rws Exp $
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that go after
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X      PROJECTROOT = /usr/X11/R5
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
# -------------------------------------------------------------------------
# X Window System Build Parameters
# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
# -------------------------------------------------------------------------
# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/X11/R5/lib
X           BINDIR = /usr/X11/R5/bin
X          INCROOT = /usr/X11/R5/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/X11/R5/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
# $XConsortium: sunLib.tmpl,v 1.11 91/07/31 11:32:08 rws Exp $
X
SHLIBLDFLAGS = -assert pure-text
PICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
# -------------------------------------------------------------------------
# Imake rules for building libraries, programs, scripts, and data files
# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
# -------------------------------------------------------------------------
# start of Imakefile
X
#Imakefile for xlax
X
#   EXTRA_LOAD_FLAGS = -Bstatic
#        CDEBUGFLAGS = -g
#            DEFINES = -DDEBUG
X            DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X    LOCAL_LIBRARIES = $(XAWLIB) $(XMULIB) $(XTOOLLIB) $(XLIB)
X               SRCS = xlax.c
X               OBJS = xlax.o
X
X PROGRAM = xlax
X
all:: xlax
X
xlax: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
saber_xlax:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
osaber_xlax:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
install:: xlax
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  xlax $(DESTDIR)$(BINDIR)
X
install.man:: xlax.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) xlax.man $(DESTDIR)$(MANDIR)/xlax.$(MANSUFFIX)
X
depend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
lint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
lint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
clean::
X	$(RM) $(PROGRAM)
X
# -------------------------------------------------------------------------
# common rules for all Makefiles - do not edit
X
emptyrule::
X
clean::
X	$(RM_CMD) "#"*
X
Makefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
tags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
saber:
X	# load $(ALLDEFINES) $(SRCS)
X
osaber:
X	# load $(ALLDEFINES) $(OBJS)
X
# -------------------------------------------------------------------------
# empty rules for directories that do not have SUBDIRS - do not edit
X
install::
X	@echo "install in $(CURRENT_DIR) done"
X
install.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
Makefiles::
X
includes::
X
# -------------------------------------------------------------------------
# dependencies generated by makedepend
X
SHAR_EOF
chmod 0644 Makefile ||
echo 'restore of Makefile failed'
Wc_c="`wc -c < 'Makefile'`"
test 10508 -eq "$Wc_c" ||
	echo 'Makefile: original size 10508, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xlax.man ==============
if test -f 'xlax.man' -a X"$1" != X"-c"; then
	echo 'x - skipping xlax.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xlax.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xlax.man' &&
.TH XLAX 1 "Release 5" "X Version 11"
.SH NAME
xlax - X window system program to send keyboard input to multiple windows
.SH SYNOPSIS
.B "xlax"
[-\fItoolkit options\fP]
.SH DESCRIPTION
.PP
.I Xlax
is an X Window System program that will send keyboard input it
receives to multiple selected windows.  When run, 
.I Xlax
will bring up its main window.  There will be four buttons on it,
"quit", "add window", "send string" and "kill window."
X
Quit will terminate 
.I xlax
and add window will change the cursor to a cross-hair and allow the
user to select any window on the screen by pressing a mouse button.
The user will be able to continue selecting windows until either the 
.I xlax
window or a window that has already been selected, is selected.
X
When a window is selected, its name will appear in the 
.I xlax
window.  Clicking the mouse on the window name will toggle whether
that window should receive input.  When the user types anywhere in the
.I xlax 
window, those keystrokes will be sent to all selected windows.
X
Kill window will allow the user to select a window and remove it from
.I xlax's 
list (note: the user must click on the actual window, not the name that
appears in 
.I xlax).
X
There is a window to the right of each name.  The user can type 
into it.  When Send String is selected, the specific string associated 
with each window will be sent to those windows.  Clicking the first
mouse button in that text area will clear that string and allow the 
user to re-enter the string.  Up to 150 characters are allowed.
X
This tool tends to be useful for system administration tasks that
require almost the same thing to be done in several different 
windows, but require some human intervention (e.g. some tape backups
or building multiple servers).  The string area is useful for machine
or platform specific strings (such as machine names or machine type).
X
.SH ENVIRONMENT
.PP
.TP 8
.B DISPLAY
To get default host and display number.
X
.SH CAVEATS
For 
.I xlax 
to work on an xterm, "allowSendEvents" must be enabled on the 
xterm.  Note that this means that anyone can send keystrokes
to that xterm, so this should not be run in an insecure or
unmonitored environment.
X
.SH BUGS
Probably something, but nothing that comes to mind.
.SH SEE ALSO
xterm(1)
.SH COPYRIGHT
Copyright 1992, Frank Adelstein.
.br
SHAR_EOF
chmod 0644 xlax.man ||
echo 'restore of xlax.man failed'
Wc_c="`wc -c < 'xlax.man'`"
test 2325 -eq "$Wc_c" ||
	echo 'xlax.man: original size 2325, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xlax.h ==============
if test -f 'xlax.h' -a X"$1" != X"-c"; then
	echo 'x - skipping xlax.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xlax.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xlax.h' &&
/*
X * Copyright 1992 by Frank Adelstein.  All Rights Reserved.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the authors name not be used in advertising or
X * publicity pertaining to distribution of the software without specific,
X * written prior permission.  The author makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X *
X * THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
X * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
X * OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
X * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
X * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X
/************/
/* INCLUDES */
/************/
X
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Shell.h>
X
#include <X11/Xaw/AsciiText.h>
#include <X11/Xaw/Command.h>
#include <X11/Xaw/Form.h>
#include <X11/Xaw/Label.h>
#include <X11/Xaw/Scrollbar.h>
#include <X11/Xaw/Toggle.h>
#include <X11/Xaw/Viewport.h>
X
#include <X11/cursorfont.h>
X
#include <stdio.h>
#include <errno.h>
#include <math.h>
#include <signal.h>
X
/*************/
/* DEFINES   */
/*************/
X
#define TITLE     "xlax"
#define CLASS     "Xlax"
#define MAXEVENTS 150
X
/*************/
/* types     */
/*************/
X
typedef struct {
X  Window wind;
X  int    active;
X  XKeyEvent events[MAXEVENTS];
X  int    eventindex;
X  Widget button;
X  Widget text;
} Windows_t;
X
/*************/
/* GLOBALS   */
/*************/
X
void SetupInterface();
void selectCB();
void killCB();
void keyboardCB();
void toggleCB();
void quitCB();
void senditCB();
void togglestringCB();
void stringinputCB();
SHAR_EOF
chmod 0644 xlax.h ||
echo 'restore of xlax.h failed'
Wc_c="`wc -c < 'xlax.h'`"
test 2132 -eq "$Wc_c" ||
	echo 'xlax.h: original size 2132, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xlax.c ==============
if test -f 'xlax.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xlax.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xlax.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xlax.c' &&
/*
X * Copyright 1992 by Frank Adelstein.  All Rights Reserved.
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the authors name not be used in advertising or
X * publicity pertaining to distribution of the software without specific,
X * written prior permission.  The author makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X *
X * THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
X * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT
X * OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
X * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
X * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
X
/*
X * Neat program to send typed text to multiple windows.
X *
X * by Frank Adelstein
X *
X */
X
#include "xlax.h"
#include "vroot.h"
X
XXtAppContext
X  Appcon;
X
Widget
X  Toplevel;
X
GC
X  drawGC,
X  xorGC;
X
Windows_t
X  Windows[50];
X  
int 
X  WindowIndex;
X
void DoNothing() {
X  /* stupid, but used to override button click default actions */
X  return;
}
X
void ErrorHandler(mydisp, myerr) 
Display *mydisp;
XXErrorEvent *myerr;
X
{
X  char msg[80];
X  XGetErrorText(mydisp, myerr->error_code, msg, 80);
X  (void) fprintf(stderr, "%s\n", msg);
X  if (myerr->error_code == BadWindow) {
X    return;
X  } else {
X    (void) fprintf(stderr, 
X               "Fatal!!  We got errors: error [%d] request [%d] minor [%d]\n",
X               myerr->error_code, myerr->request_code, myerr->minor_code); 
X    exit(1); 
X  } 
}
X
main (argc, argv)
int    argc;
char **argv;
X
{
X
X  void DoNothing();
X  static XtActionsRec TextActions[] = {
X    {"DoNothing", DoNothing},
X    {NULL, NULL}
X  };
X
X  /* initialize toolkit */
X  Toplevel = XtAppInitialize (&Appcon, TITLE, NULL, 0, &argc, argv,
X			      NULL, NULL, 0);
X
X  XtAppAddActions(Appcon, TextActions, XtNumber(TextActions));
X  XSetErrorHandler(ErrorHandler);
X
X  /* do all the dirty work */
X  SetupInterface();
X
X  /* sit back and process events */
X  XtAppMainLoop(Appcon);
}
X
void
SetupInterface()
X
{
X  int cnt;
X
X  Arg args[15];
X
X  Widget
X    Frame,
X    thing,
X    quit,
X    sendit,
X    view,
X    draw;
X
X  Display
X    *display;
X
X  /* create a frame widget to hold things */
X  cnt = 0;
X  Frame = XtCreateManagedWidget ("Frame", formWidgetClass, 
X				 Toplevel, args, cnt);
X
X  XtAddEventHandler (Frame, KeyPressMask, False, keyboardCB, NULL);
X
X  cnt = 0;
X  XtSetArg (args[cnt], XtNborder, 2);                       cnt++;
X  XtSetArg (args[cnt], XtNlabel, "Add Windows");            cnt++;
X
X  thing = XtCreateManagedWidget ("addbutton", 
X				 commandWidgetClass,
X				 Frame, args, cnt);
X  XtAddCallback (thing, XtNcallback, selectCB, NULL);
X
X  cnt = 0;
X  XtSetArg (args[cnt], XtNborder, 2);                       cnt++;
X  XtSetArg (args[cnt], XtNfromVert, thing);                 cnt++;
X  XtSetArg (args[cnt], XtNlabel, "Send String");            cnt++;
X
X  sendit = XtCreateManagedWidget ("senditbutton", 
X				  commandWidgetClass,
X				  Frame, args, cnt);
X  XtAddCallback (sendit, XtNcallback, senditCB, NULL);
X
X  cnt = 0;
X  XtSetArg (args[cnt], XtNborder, 2);                       cnt++;
X  XtSetArg (args[cnt], XtNlabel, "Kill Window");            cnt++;
X  XtSetArg (args[cnt], XtNfromVert, sendit);                cnt++;
X
X  thing = XtCreateManagedWidget ("killbutton", 
X				 commandWidgetClass,
X				 Frame, args, cnt);
X  XtAddCallback (thing, XtNcallback, killCB, NULL);
X
X  cnt = 0;
X  XtSetArg (args[cnt], XtNborder, 2);                       cnt++;
X  XtSetArg (args[cnt], XtNfromVert, thing);                 cnt++;
X  XtSetArg (args[cnt], XtNlabel, "Quit");                   cnt++;
X
X  quit = XtCreateManagedWidget ("quitbutton", 
X				 commandWidgetClass,
X				 Frame, args, cnt);
X  XtAddCallback (quit, XtNcallback, quitCB, NULL);
X
X  /* create a viewport widget and a frame widget to hold things */
X  cnt = 0;
X  XtSetArg (args[cnt], XtNfromHoriz, sendit);                 cnt++;
X  XtSetArg (args[cnt], XtNborder, 2);                         cnt++;
X  XtSetArg(args[cnt], XtNwidth,  400);                        cnt++;
X  XtSetArg(args[cnt], XtNheight,  150);                       cnt++;
X  XtSetArg(args[cnt], XtNallowHoriz, True);  cnt++;
X  XtSetArg(args[cnt], XtNallowVert,  True);  cnt++;
X  view = XtCreateManagedWidget("View", viewportWidgetClass,
X                               Frame, args, cnt);
X
X  /* I don't understand why I need to do this, but...*/
X  cnt = 0;
X  XtSetArg(args[cnt], XtNwidth,  10);                         cnt++;
X  XtSetArg(args[cnt], XtNheight, 10);                         cnt++;
X  XtSetValues(XtNameToWidget(Toplevel, "*clip"), args, cnt);
X
X  cnt = 0;
X
X  XtSetArg (args[cnt], XtNborder, 2);                         cnt++;
X  XtSetArg(args[cnt], XtNwidth,  200);                        cnt++;
X  XtSetArg(args[cnt], XtNheight,  150);                       cnt++;
X  draw = XtCreateWidget ("drawingarea", formWidgetClass,
X			 view, args, cnt);
X
X  XtRealizeWidget (Toplevel);
X
X  return;
X
}
X
X
/*
X * Routine to let user select a window using the mouse
X * (taken from dsimple.c from xwd)
X */
X
Window Select_Window(dpy)
X     Display *dpy;
{
X  int status;
X  Cursor cursor;
X  XEvent event;
X  Window target_win = None, root = RootWindow(dpy,DefaultScreen(dpy));
X  int buttons = 0;
X
X  /* Make the target cursor */
X  cursor = XCreateFontCursor(dpy, XC_crosshair);
X
X  /* Grab the pointer using target cursor, letting it room all over */
X  status = XGrabPointer(dpy, root, False,
X                        ButtonPressMask|ButtonReleaseMask, GrabModeSync,
X                        GrabModeAsync, root, cursor, CurrentTime);
X  if (status != GrabSuccess) {
X    fprintf(stderr, "Can't grab the mouse.");
X    exit (2);
X  }
X
X  /* Let the user select a window... */
X  while ((target_win == None) || (buttons != 0)) {
X    /* allow one more event */
X    XAllowEvents(dpy, SyncPointer, CurrentTime);
X    XWindowEvent(dpy, root, ButtonPressMask|ButtonReleaseMask, &event);
X    switch (event.type) {
X    case ButtonPress:
X      if (target_win == None) {
X        target_win = event.xbutton.subwindow; /* window selected */
X        if (target_win == None)  {
X	  fprintf(stderr, "target win = None\n");
X	  target_win = root;
X	}
X      }
X      buttons++;
X      break;
X    case ButtonRelease:
X      if (buttons > 0) /* there may have been some down before we started */
X        buttons--;
X       break;
X    }
X  }
X
X  XUngrabPointer(dpy, CurrentTime);      /* Done with pointer */
X
X  return(target_win);
}
X
void
selectCB (w, client_data, call_data)
Widget w;
caddr_t  client_data;
caddr_t  call_data;
X
{
X  Display *dpy;
X  Window target;
X  Widget frame;
X  int x, y;
X  char *name;
X
X  XtTranslations text_trans;
X  static String text_trans_str =
X    "<Btn1Down>: DoNothing() \n\
X     <Btn2Down>: DoNothing() \n\
X     <Btn3Down>: DoNothing() \n\
X     <Key>Return: insert-string(\"^M\") \n\
X     <Key>BackSpace: insert-string(\"^H\") \n\
X     <Key>Delete: insert-string(\"^?\")";
X
X  int cnt;
X  Arg args[15];
X  
X  cnt = 0;
X  XtSetArg (args[cnt], XtNlabel, "Adding...");            cnt++;
X  XtSetValues(w, args, cnt);
X  do {
X    XtAppProcessEvent (Appcon, XtIMAll);
X  } while (XtAppPending(Appcon));
X
X
X  dpy = XtDisplay(w);
X  while (1) {
X    /* keep selecting windows until the xlax window is selected */
X    target = Select_Window(dpy);
X
X    /* stupid undocumented kludge */
X    target = XmuClientWindow (dpy, target);
X
X    if (target == XmuClientWindow(dpy, XtWindow(Toplevel))) {
X       /* we just clicked on ourself...let's avoid an endless loop */
X       cnt = 0;
X       XtSetArg (args[cnt], XtNlabel, "Add Windows");            cnt++;
X       XtSetValues(w, args, cnt);
X       return;
X    }
X    /* just return if we've already got that window yet */
X    for (x = 0; x < WindowIndex; x++) 
X      {
X        if (Windows[x].wind == target) 
X	  {
X            cnt = 0;
X            XtSetArg (args[cnt], XtNlabel, "Add Windows");            cnt++;
X            XtSetValues(w, args, cnt);
X	    return;
X	  }
X      }
X
X    XFlush(dpy);
X    x = XFetchName(dpy, target, &name);
X
X    /* add a toggle button */
X    frame = XtNameToWidget (Toplevel, "*drawingarea");
X
X    cnt = 0;
X    XtSetArg (args[cnt], XtNborder, 2);                       cnt++;
X    XtSetArg (args[cnt], XtNlabel, name);                     cnt++;
X    XtSetArg (args[cnt], XtNfromVert, 
X	      (WindowIndex)?Windows[WindowIndex - 1].button:NULL);  cnt++;
X    XtSetArg (args[cnt], XtNtop, XtChainTop);                 cnt++;
X    XtSetArg (args[cnt], XtNbottom, XtChainTop);              cnt++;
X    XtSetArg (args[cnt], XtNleft, XtChainLeft);               cnt++;
X    XtSetArg (args[cnt], XtNright, XtChainLeft);              cnt++;
X    XtSetArg (args[cnt], XtNwidth, 190);                      cnt++;
X    XtSetArg (args[cnt], XtNheight, 20);                      cnt++;
X    XtSetArg (args[cnt], XtNstate, True);                     cnt++;
X    Windows[WindowIndex].button = XtCreateManagedWidget ("togglebutton", 
X						         toggleWidgetClass,
X						         frame, args, cnt);
X    /* add a toggle button */
X    frame = XtNameToWidget (Toplevel, "*drawingarea");
X
X    text_trans = XtParseTranslationTable(text_trans_str);
X    cnt = 0;
X    XtSetArg (args[cnt], XtNborder, 2);                       cnt++;
X    XtSetArg (args[cnt], XtNlabel, name);                     cnt++;
X    XtSetArg (args[cnt], XtNfromVert, 
X	      (WindowIndex)?Windows[WindowIndex - 1].text:NULL);  cnt++;
X    XtSetArg (args[cnt], XtNfromHoriz, 
X	      Windows[WindowIndex].button);                   cnt++;
X    XtSetArg (args[cnt], XtNtop, XtChainTop);                 cnt++;
X    XtSetArg (args[cnt], XtNbottom, XtChainTop);              cnt++;
X    XtSetArg (args[cnt], XtNleft, XtChainLeft);               cnt++;
X    XtSetArg (args[cnt], XtNright, XtChainLeft);              cnt++;
X    XtSetArg (args[cnt], XtNwidth, 190);                      cnt++;
X    XtSetArg (args[cnt], XtNheight, 20);                      cnt++;
X    XtSetArg (args[cnt], XtNeditType, XawtextEdit);           cnt++;
X    Windows[WindowIndex].text = XtCreateManagedWidget ("toggletext", 
X						       asciiTextWidgetClass,
X						       frame, args, cnt);
X
X    XtOverrideTranslations(Windows[WindowIndex].text, text_trans);
X
X    XtAddCallback (Windows[WindowIndex].button, XtNcallback, 
X		   toggleCB, WindowIndex);
X
X    XtAddEventHandler (Windows[WindowIndex].text, ButtonPressMask,
X		       False, togglestringCB, WindowIndex);
X
X    XtAddEventHandler (Windows[WindowIndex].text, KeyPressMask,
X		       False, stringinputCB, WindowIndex);
X
X    XtUnmanageChild(frame);
X    XtManageChild(frame);
X
X    Windows[WindowIndex].wind = target;
X    Windows[WindowIndex].eventindex = 0;
X    Windows[WindowIndex++].active = 1;
X
X  }  	/* end while (1) */  
}
X
X
void
killCB (w, client_data, call_data)
Widget w;
caddr_t  client_data;
caddr_t  call_data;
X
{
X  Display *dpy;
X  Window  target;
X  Widget  frame;
X  int     x, length;
X
X  Arg     args[10];
X  int     cnt;
X
X  dpy = XtDisplay(w);
X  /* get the selection */
X  target = Select_Window(XtDisplay(w));
X
X  /* tell me what that really means */
X  target = XmuClientWindow(dpy, target);
X
X  if (target == XmuClientWindow(dpy, XtWindow(Toplevel))) {
X    /* it's us..don't bother */
X    return;
X  } 
X
X  /* otherwise see if that window is in our list */
X  for (x = 0; x < WindowIndex; x++) {
X    if (Windows[x].wind == target) {
X      /* remove it from our list then */
X      XtDestroyWidget(Windows[x].button);
X      XtDestroyWidget(Windows[x].text);
X      frame = XtNameToWidget (Toplevel, "*drawingarea");
X      if (x+1 < WindowIndex) {
X        cnt = 0;
X        XtSetArg(args[cnt], XtNfromVert, 
X                 (x) ? Windows[x-1].button : NULL); cnt++;
X        XtSetValues(Windows[x+1].button, args, cnt);
X        cnt = 0;
X        XtSetArg(args[cnt], XtNfromVert, 
X                 (x) ? Windows[x-1].text : NULL);   cnt++;
X        XtSetValues(Windows[x+1].text, args, cnt);
X
X        length = sizeof(Windows_t) * (WindowIndex-x-1);
X        bcopy(&Windows[x+1], &Windows[x], length);
X      }
X      WindowIndex--;
X      XtUnmanageChild(frame);
X      XtManageChild(frame);
X      break;
X    }
X  }
}
X
void
keyboardCB (w, client_data, event)
Widget w;
caddr_t  client_data;
XXKeyEvent *event;
X
{
X  int x;
X
X  /* send the keys to every active window that's been selected */
X  for (x = 0; x < WindowIndex; x++)
X    {
X      if (Windows[x].active == 1)
X	{
X	  event->window = Windows[x].wind;
X	  XSendEvent(XtDisplay(w), Windows[x].wind, True, KeyPressMask, event);
X	}
X    }
X  return;
}
X
void
stringinputCB (w, index, event)
Widget w;
int  index;
XXKeyEvent *event;
X
{
X  if (Windows[index].eventindex == MAXEVENTS) {
X    /* if we've reached the max, just beep and return */
X    XBell(XtDisplay(w), 0);
X    return;
X  }
X
X  /* save each key event for that window and bump up the counter */
X  bcopy (event, 
X	 &Windows[index].events[Windows[index].eventindex], 
X	 sizeof (XKeyEvent));
X
X  Windows[index].events[Windows[index].eventindex].window 
X    = Windows[index].wind;
X  Windows[index].eventindex++;
X  
}
X
void
togglestringCB (w, index, event)
Widget w;
int  index;
XXButtonEvent *event;
X
{
X  Arg args[10];
X  int cnt ;
X  char text[500];
X
X  /* clear the text widget if button 1 was pressed */
X  if (event->button == 1) {
X    Windows[index].eventindex = 0;
X    cnt = 0;
X    XtSetArg(args[cnt], XtNstring, "");    cnt++;
X    XtSetValues(w, args, cnt);
X  }
X  return;
}
X
void
toggleCB (w, windex, state)
Widget w;
int  windex;
int  state;
X
{
X  Windows[windex].active = state;
X  return;
}
X
void 
senditCB (w, client_data, call_data)
Widget w;		/* unused */
caddr_t  client_data;	/* unused */
caddr_t  call_data;	/* unused */
X
{
X  int x, y;
X
X  for (x = 0; x < WindowIndex; x++) {
X    if (Windows[x].active == 1) {
X      for (y = 0; y < Windows[x].eventindex; y++) {
X	XSendEvent(XtDisplay(w), Windows[x].wind, True, 
X		   KeyPressMask, &Windows[x].events[y]);
X      }
X    }
X  }
X  return;
}
X
void 
quitCB (w, client_data, call_data)
Widget w;		/* unused */
caddr_t  client_data;	/* unused */
caddr_t  call_data;	/* unused */
X
{
X  exit (0);
}
SHAR_EOF
chmod 0644 xlax.c ||
echo 'restore of xlax.c failed'
Wc_c="`wc -c < 'xlax.c'`"
test 14414 -eq "$Wc_c" ||
	echo 'xlax.c: original size 14414, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= patchlevel.h ==============
if test -f 'patchlevel.h' -a X"$1" != X"-c"; then
	echo 'x - skipping patchlevel.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting patchlevel.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'patchlevel.h' &&
#define PATCHLEVEL 0
SHAR_EOF
chmod 0644 patchlevel.h ||
echo 'restore of patchlevel.h failed'
Wc_c="`wc -c < 'patchlevel.h'`"
test 21 -eq "$Wc_c" ||
	echo 'patchlevel.h: original size 21, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= vroot.h ==============
if test -f 'vroot.h' -a X"$1" != X"-c"; then
	echo 'x - skipping vroot.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting vroot.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'vroot.h' &&
/*****************************************************************************/
/**                   Copyright 1991 by Andreas Stolcke                     **/
/**               Copyright 1990 by Solbourne Computer Inc.                 **/
/**                          Longmont, Colorado                             **/
/**                                                                         **/
/**                           All Rights Reserved                           **/
/**                                                                         **/
/**    Permission to use, copy, modify, and distribute this software and    **/
/**    its documentation  for  any  purpose  and  without  fee is hereby    **/
/**    granted, provided that the above copyright notice appear  in  all    **/
/**    copies and that both  that  copyright  notice  and  this  permis-    **/
/**    sion  notice appear in supporting  documentation,  and  that  the    **/
/**    name of Solbourne not be used in advertising                         **/
/**    in publicity pertaining to distribution of the  software  without    **/
/**    specific, written prior permission.                                  **/
/**                                                                         **/
/**    ANDREAS STOLCKE AND SOLBOURNE COMPUTER INC. DISCLAIMS ALL WARRANTIES **/
/**    WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF    **/
/**    MERCHANTABILITY  AND  FITNESS,  IN  NO  EVENT SHALL ANDREAS STOLCKE  **/
/**    OR SOLBOURNE BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL    **/
/**    DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA   **/
/**    OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER    **/
/**    TORTIOUS ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE    **/
/**    OR PERFORMANCE OF THIS SOFTWARE.                                     **/
/*****************************************************************************/
/*
X * vroot.h -- Virtual Root Window handling header file
X *
X * This header file redefines the X11 macros RootWindow and DefaultRootWindow,
X * making them look for a virtual root window as provided by certain `virtual'
X * window managers like swm and tvtwm. If none is found, the ordinary root
X * window is returned, thus retaining backward compatibility with standard
X * window managers.
X * The function implementing the virtual root lookup remembers the result of
X * its last invocation to avoid overhead in the case of repeated calls
X * on the same display and screen arguments. 
X * The lookup code itself is taken from Tom LaStrange's ssetroot program.
X *
X * Most simple root window changing X programs can be converted to using
X * virtual roots by just including
X *
X * #include <X11/vroot.h>
X *
X * after all the X11 header files.  It has been tested on such popular
X * X clients as xphoon, xfroot, xloadimage, and xaqua.
X * It also works with the core clients xprop, xwininfo, xwd, and editres
X * (and is necessary to get those clients working under tvtwm).
X * It does NOT work with xsetroot; get the xsetroot replacement included in
X * the tvtwm distribution instead.
X *
X * Andreas Stolcke <stolcke@ICSI.Berkeley.EDU>, 9/7/90
X * - replaced all NULL's with properly cast 0's, 5/6/91
X * - free children list (suggested by Mark Martin <mmm@cetia.fr>), 5/16/91
X * - include X11/Xlib.h and support RootWindowOfScreen, too 9/17/91
X */
X
#ifndef _VROOT_H_
#define _VROOT_H_
X
#if !defined(lint) && !defined(SABER)
static char vroot_rcsid[] = "$Id: vroot.h,v 1.1 92/02/25 11:41:45 frank Exp $";
#endif
X
#include <X11/X.h>
#include <X11/Xatom.h>
#include <X11/Xlib.h>
X
static Window
VirtualRootWindowOfScreen(screen)
X	Screen *screen;
{
X	static Screen *save_screen = (Screen *)0;
X	static Window root = (Window)0;
X
X	if (screen != save_screen) {
X		Display *dpy = DisplayOfScreen(screen);
X		Atom __SWM_VROOT = None;
X		int i;
X		Window rootReturn, parentReturn, *children;
X		unsigned int numChildren;
X
X		root = RootWindowOfScreen(screen);
X
X		/* go look for a virtual root */
X		__SWM_VROOT = XInternAtom(dpy, "__SWM_VROOT", False);
X		if (XQueryTree(dpy, root, &rootReturn, &parentReturn,
X				 &children, &numChildren)) {
X			for (i = 0; i < numChildren; i++) {
X				Atom actual_type;
X				int actual_format;
X				unsigned long nitems, bytesafter;
X				Window *newRoot = (Window *)0;
X
X				if (XGetWindowProperty(dpy, children[i],
X					__SWM_VROOT, 0, 1, False, XA_WINDOW,
X					&actual_type, &actual_format,
X					&nitems, &bytesafter,
X					(unsigned char **) &newRoot) == Success
X				    && newRoot) {
X				    root = *newRoot;
X				    break;
X				}
X			}
X			if (children)
X				XFree((char *)children);
X		}
X
X		save_screen = screen;
X	}
X
X	return root;
}
X
#undef RootWindowOfScreen
#define RootWindowOfScreen(s) VirtualRootWindowOfScreen(s)
X
#undef RootWindow
#define RootWindow(dpy,screen) VirtualRootWindowOfScreen(ScreenOfDisplay(dpy,screen))
X
#undef DefaultRootWindow
#define DefaultRootWindow(dpy) VirtualRootWindowOfScreen(DefaultScreenOfDisplay(dpy))
X
#endif /* _VROOT_H_ */
SHAR_EOF
chmod 0644 vroot.h ||
echo 'restore of vroot.h failed'
Wc_c="`wc -c < 'vroot.h'`"
test 5056 -eq "$Wc_c" ||
	echo 'vroot.h: original size 5056, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
