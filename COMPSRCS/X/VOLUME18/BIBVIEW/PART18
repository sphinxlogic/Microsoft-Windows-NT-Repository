Newsgroups: comp.sources.x
Path: uunet!cis.ohio-state.edu!pacific.mps.ohio-state.edu!linac!att!pacbell.com!mips!msi!dcmartin
From: Armin Liebl <liebla@informatik.tu-muenchen.de>
Subject: v18i116: bibview - BibTeX GUI, Part18/20
Message-ID: <1992Aug27.161831.26142@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
References: <csx-18i099-bibview@uunet.UU.NET>
Date: Thu, 27 Aug 1992 16:18:31 GMT
Approved: dcmartin@msi.com
Lines: 1518

Submitted-by: Armin Liebl <liebla@informatik.tu-muenchen.de>
Posting-number: Volume 18, Issue 116
Archive-name: bibview/part18

#!/bin/sh
# this is part.18 (part 18 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file gui_widg.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 18; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping gui_widg.c'
else
echo 'x - continuing file gui_widg.c'
sed 's/^X//' << 'SHAR_EOF' >> 'gui_widg.c' &&
{
static Widget errShell, errForm, errIcon, errType, errText, errOKButton;
char textLabel[20];
Position dx, dy, x, y;
X
X   XtVaGetValues(desktop,
X                 XtNx, &dx,
X                 XtNy, &dy, NULL);
X   XtTranslateCoords(desktop,
X                     (Position)dx + SUBWIN_MARGIN,
X                     (Position)dy + SUBWIN_MARGIN,
X                     &x, &y);
X   errShell = XtVaCreatePopupShell("errorShell",
X	        transientShellWidgetClass, topLevel, 
X		XtNx, x, XtNy, y, NULL);
X   errForm = XtVaCreateManagedWidget("errorWin",
X	       formWidgetClass, errShell, NULL);
X   errIcon = XtVaCreateManagedWidget("errorIcon",
X	       labelWidgetClass, errForm, 
X	       XtNborderWidth, 0,
X	       XtNtop, XtChainTop,
X	       XtNleft, XtChainLeft,
X	       XtNbitmap, errorPixmap, NULL);
X   errType = XtVaCreateManagedWidget("type",
X	       labelWidgetClass, errForm, 
X	       XtNjustify, XtJustifyLeft,
X	       XtNborderWidth, 0,
X	       XtNtop, XtChainTop,
X	       XtNfromHoriz, errIcon, NULL);
X   sprintf(textLabel, "msgText%d", abs((int)errcode));
X   errText = XtVaCreateManagedWidget(textLabel,
X	       labelWidgetClass, errForm, 
X	       XtNjustify, XtJustifyLeft,
X	       XtNborderWidth, 0,
X	       XtNfromVert, errType,
X	       XtNfromHoriz, errIcon, NULL);
X   errOKButton = XtVaCreateManagedWidget("ok",
X	           commandWidgetClass, errForm, 
X		   XtNfromVert, errText,
X		   XtNbottom, XtChainBottom, 
X		   XtNfromHoriz, errIcon, NULL);
X
X   XtAddCallback(errOKButton, XtNcallback, closeMsgWin, errShell);
X
X   XtSetSensitive(mainMenu, FALSE);
X   gubSetSensitive(NULL, FALSE);
X   if (cotBeepOnError())
X      XBell(XtDisplay(topLevel), 100);
X   XtPopup(errShell, XtGrabNonexclusive);
}
X
X
/*********************************************************************/
/* guwWarning:                                                       */
/*    Display warning message in a popup shell on desktop            */
/*********************************************************************/
void
guwWarning (Errcode errcode)
{
static Widget warnShell, warnForm, warnIcon, 
X	      warnType, warnText, warnOKButton;
char textLabel[20];
Position dx, dy, x, y;
X
X   XtVaGetValues(desktop,
X                 XtNx, &dx,
X                 XtNy, &dy, NULL);
X   XtTranslateCoords(desktop,
X                     (Position)dx + SUBWIN_MARGIN,
X                     (Position)dy + SUBWIN_MARGIN,
X                     &x, &y);
X   warnShell    = XtVaCreatePopupShell("warnShell",
X	            transientShellWidgetClass, topLevel, 
X		    XtNx, x, XtNy, y, NULL);
X   warnForm     = XtVaCreateManagedWidget("warnWin",
X	            formWidgetClass, warnShell, NULL);
X   warnIcon     = XtVaCreateManagedWidget("warnIcon",
X	            labelWidgetClass, warnForm, 
X	            XtNborderWidth, 0,
X	            XtNtop, XtChainTop,
X	            XtNleft, XtChainLeft,
X	            XtNbitmap, warnPixmap, NULL);
X   warnType     = XtVaCreateManagedWidget("type",
X	            labelWidgetClass, warnForm, 
X		    XtNjustify, XtJustifyLeft,
X	            XtNborderWidth, 0,
X	            XtNtop, XtChainTop,
X	            XtNfromHoriz, warnIcon, NULL);
X   sprintf(textLabel, "msgText%d", abs((int)errcode));
X   warnText     = XtVaCreateManagedWidget(textLabel,
X	            labelWidgetClass, warnForm, 
X		    XtNjustify, XtJustifyLeft,
X	            XtNborderWidth, 0,
X	            XtNfromVert, warnType,
X	            XtNfromHoriz, warnIcon, NULL);
X   warnOKButton = XtVaCreateManagedWidget("ok",
X	            commandWidgetClass, warnForm, 
X		    XtNfromVert, warnText,
X		    XtNbottom, XtChainBottom, 
X		    XtNfromHoriz, warnIcon, NULL);
X
X   XtAddCallback(warnOKButton, XtNcallback, closeMsgWin, warnShell);
X
X   XtSetSensitive(mainMenu, FALSE);
X   gubSetSensitive(NULL, FALSE);
X   if (cotBeepOnError())
X      XBell(XtDisplay(topLevel), 100);
X   XtPopup(warnShell, XtGrabNonexclusive);
}
X
X
/*********************************************************************/
/* guwNotice:                                                        */
/*    Display notice message in a popup shell on desktop             */
/*********************************************************************/
void
guwNotice (Errcode errcode)
{
static Widget noticeShell, noticeForm, noticeIcon, noticeType, 
X	      noticeText, noticeOKButton;
char textLabel[20];
Position dx, dy, x, y;
X
X   XtVaGetValues(desktop,
X                 XtNx, &dx,
X                 XtNy, &dy, NULL);
X   XtTranslateCoords(desktop,
X                     (Position)dx + SUBWIN_MARGIN,
X                     (Position)dy + SUBWIN_MARGIN,
X                     &x, &y);
X   noticeShell    = XtVaCreatePopupShell("noticeShell",
X	              transientShellWidgetClass, topLevel, 
X		      XtNx, x, XtNy, y, NULL);
X   noticeForm     = XtVaCreateManagedWidget("noticeWin",
X	              formWidgetClass, noticeShell, NULL);
X   noticeIcon     = XtVaCreateManagedWidget("noticeIcon",
X	              labelWidgetClass, noticeForm, 
X	              XtNborderWidth, 0,
X	              XtNtop, XtChainTop,
X	              XtNleft, XtChainLeft,
X	              XtNbitmap, noticePixmap, NULL);
X   noticeType     = XtVaCreateManagedWidget("type",
X	              labelWidgetClass, noticeForm, 
X	              XtNborderWidth, 0,
X		      XtNjustify, XtJustifyLeft,
X	              XtNtop, XtChainTop,
X	              XtNfromHoriz, noticeIcon, NULL);
X   sprintf(textLabel, "msgText%d", abs((int)errcode));
X   noticeText     = XtVaCreateManagedWidget(textLabel,
X	              labelWidgetClass, noticeForm, 
X	              XtNborderWidth, 0,
X		      XtNjustify, XtJustifyLeft,
X	              XtNfromVert, noticeType,
X	              XtNfromHoriz, noticeIcon, NULL);
X   noticeOKButton = XtVaCreateManagedWidget("ok",
X	              commandWidgetClass, noticeForm, 
X		      XtNfromVert, noticeText,
X		      XtNbottom, XtChainBottom, 
X		      XtNfromHoriz, noticeIcon, NULL);
X
X   XtAddCallback(noticeOKButton, XtNcallback, closeMsgWin, noticeShell);
X
X   XtSetSensitive(mainMenu, FALSE);
X   gubSetSensitive(NULL, FALSE);
X   XtPopup(noticeShell, XtGrabNonexclusive);
}
X
X
/*********************************************************************/
/* CloseMsgWin:                                                      */
/*    Callback function for OK button in message windows             */
/*********************************************************************/
static void
closeMsgWin (Widget w, XtPointer clientData, XtPointer callData)
{
Widget shell = (Widget)clientData;
X
X   XtSetSensitive(mainMenu, TRUE);
X   gubSetSensitive(NULL, TRUE);
X   XtPopdown(shell);
}
X
X
/*********************************************************************/
/* guwProgInfo:                                                      */
/*    Display programm information                                   */
/*********************************************************************/
void
guwProgInfo (Widget w, XtPointer clientData, XtPointer callData)
{
static Widget piShell, piIcon;
Position dx, dy, x, y;
X
X   XtVaGetValues(desktop,
X                 XtNx, &dx,
X                 XtNy, &dy, NULL);
X   XtTranslateCoords(desktop,
X                     (Position)dx + SUBWIN_MARGIN,
X                     (Position)dy + SUBWIN_MARGIN,
X                     &x, &y);
X   piShell  = XtVaCreatePopupShell("progInfoShell",
X	        transientShellWidgetClass, topLevel, 
X		XtNx, x, XtNy, y, NULL);
X   piIcon  = XtVaCreateManagedWidget("progInfo",
X	       commandWidgetClass, piShell, 
X	       XtNbitmap, progInfoPixmap, NULL);
X
X   XtAddCallback(piIcon, XtNcallback, closeProgInfoWin, piShell);
X   XtPopup(piShell, XtGrabNonexclusive);
}
X
X
/*********************************************************************/
/* CloseProgInfoWin:                                                 */
/*    Callback function for OK button in message windows             */
/*********************************************************************/
static void
closeProgInfoWin (Widget w, XtPointer clientData, XtPointer callData)
{
Widget shell = (Widget)clientData;
X
X   XtPopdown(shell);
}
X
X
X
X
X
SHAR_EOF
echo 'File gui_widg.c is complete' &&
chmod 0644 gui_widg.c ||
echo 'restore of gui_widg.c failed'
Wc_c="`wc -c < 'gui_widg.c'`"
test 14942 -eq "$Wc_c" ||
	echo 'gui_widg.c: original size 14942, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= rc_file.c ==============
if test -f 'rc_file.c' -a X"$1" != X"-c"; then
	echo 'x - skipping rc_file.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting rc_file.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'rc_file.c' &&
/*********************************************************************/
/*  bibView: Administration of bibTex-Databases                      */
/*           (Verwaltung von bibTeX-Literaturdatenbanken)            */
/*                                                                   */
/*  Module:  rc_file.c                                               */
/*                                                                   */
/*             - Handling of Configuration files                     */
/*             -                                                     */
/*                                                                   */
/*  Author:  Holger Martin,  martinh@informatik.tu-muenchen.de       */
/*           Peter M. Urban, urban@informatik.tu-muenchen.de         */
/*                                                                   */
/*  History:                                                         */
/*    11.22.91  HM   created                                         */
/*    05.26.92       Version 1.0 released                            */
/*                                                                   */
/*  Copyright 1992 TU MUENCHEN                                       */
/*    See ./Copyright for complete rights and liability information. */
/*                                                                   */
/*********************************************************************/
X
#include <stdio.h>
#include <string.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include "bibview.h"
X
/* imported global variables */
/* ------------------------- */
X
X
/* macros and definitions */
/* ---------------------- */
#define STR_TRUE 		"TRUE"
#define STR_BEEP_ON_ERROR_OPT	"BeepOnError"
#define STR_ICON_ON_DESK_OPT	"IconsOnDesk"
#define STR_MAKE_BACKUPS_OPT	"MakeBackups"
#define STR_AUTO_CHECK_BIB_OPT	"AutoCheckBib"
#define STR_REQUIRED_FIELDS_OPT "RequiredFields"
X
#define MAX_TAGLEN		80
#define MAX_CFGLINELEN		255
X
typedef enum {
X   findTag,       /* Modus: Suche nach Tag in Konfigdatei        */
X   illegalTag,    /*        Tag gefunden, aber ungueltig         */
X   optionTags,    /*        Optionen-Tag, jetzt folgen Optionen  */
X   userFldTags,   /*        Benutzerdefinierte Felder folgen     */
X   predefTags,    /*        Vordefinierte Feldinhalte  folgen    */
X   latexHeadTags, /*        Kopfzeilen der LaTeX-Druckdatei      */
X   latexFootTags  /*        Fusszeilen der LaTeX-Druckdatei      */
} CfgMode;
X
typedef struct {
X   char *tagStr;
X   CfgMode mode;
} TagType;
X
X
/* local function prototypes */
/* ------------------------- */
static CfgMode  getCfgFileTag      (char *str);
static int      procOptionLine     (char *str);
static int      procPredefLine     (char *str);
static int      procUserFldLine    (char *str);
static int      procLatexHeadLine  (char *str);
static int      procLatexFootLine  (char *str);
X
X
/* exported variables */
/* ------------------ */
UserDefFld userDefFlds[MAX_BIBTEX_TYPES] = {
X   NULL, /* article */
X   NULL, /* book */
X   NULL, /* booklet */
X   NULL, /* conference */
X   NULL, /* inbook */
X   NULL, /* incollection */
X   NULL, /* inproceedings */
X   NULL, /* manual */
X   NULL, /* masterythesis */
X   NULL, /* misc */
X   NULL, /* phdthesis */
X   NULL, /* proceedings */
X   NULL, /* techreport */
X   NULL, /* unpublished */
};
X
PredefLists predefLst = {
X   NULL, /* address */
X   NULL, /* annote */
X   NULL, /* author */
X   NULL, /* booktitle */
X   NULL, /* chapter */
X   NULL, /* edition */
X   NULL, /* editor */
X   NULL, /* howpublished */
X   NULL, /* institution */
X   NULL, /* journal */
X   NULL, /* key */
X   NULL, /* month */
X   NULL, /* note */
X   NULL, /* number */
X   NULL, /* organization */
X   NULL, /* pages */
X   NULL, /* publisher */
X   NULL, /* school */
X   NULL, /* series */
X   NULL, /* title */
X   NULL, /* type */
X   NULL, /* volume */
X   NULL, /* year */
X   NULL  /* category */
};
X
char *latexHeader = NULL;
int latexHeaderLen = 0;
char *latexFooter = NULL;
int latexFooterLen = 0;
X
X
/* local global variables */
/* ---------------------- */
X
TagType tagTypes[] = {
X   { "Options",     optionTags },
X   { "Fields",      userFldTags },
X   { "Predefines",  predefTags },
X   { "LatexHeader", latexHeadTags },
X   { "LatexFooter", latexFootTags },
X   { NULL,          illegalTag }
};
X
static Boolean processOptions = TRUE,
X               prtToStd = TRUE;
X
X
X
/*********************************************************************/
/* rcfReadCfgFile:                                                   */
/*    Reads and processes .bibrc configuration file                  */
/*********************************************************************/
int
rcfReadCfgFile (char *cfgFname)
{
FILE *cfgFP;
CfgMode curMode;
char cfgLine[MAX_CFGLINELEN+1];
int  i;
char processLine;
X
X   /* throw away old values */
X   if (latexHeader) {
X      free(latexHeader);
X      latexHeaderLen = 0;
X   }
X   if (latexFooter) {
X      free(latexFooter);
X      latexFooterLen = 0;
X   }
X
X   if ((cfgFP = fopen(cfgFname, "r")) == NULL) {
X      return(ERR_NO_CFGFILE);
X   }
X
X   curMode = findTag;
X   while (TRUE) {
X      /* Zeile in Zeilenpuffer lesen */
X      for (i=0; i <= MAX_CFGLINELEN && cfgLine[i-1] != '\n'; i++) {
X         if (fread(&cfgLine[i], 1, 1, cfgFP) == 0)
X            break;
X      }
X      if (feof(cfgFP))  /* Ende der Konfigdatei */
X         break;
X      if (cfgLine[0] == '\n')  /* Leerzeilen ueberspringen */
X         continue;
X      cfgLine[i-1] = '\0';  /* Stringende setzen */
X
X      /* gelesene Zeile bearbeiten */
X      switch (cfgLine[0]) {
X         case '#':  /* Kommentarzeile */
X                    processLine = FALSE;
X                    break;
X         case '[':  /* Neuer Abschnitt in Konfigdatei */
X                    curMode = getCfgFileTag(cfgLine);
X                    if (curMode != illegalTag)
X                       continue;
X                    processLine = TRUE;
X                    break;
X         default:   /* Zeile je nach aktuellem Modus bearbeiten */
X                    processLine = TRUE;
X      } /* endswitch */
X
X      if (processLine) {
X         switch (curMode) {
X            case optionTags:  /* Optionszeilen bearbeiten */
X                              procOptionLine(cfgLine);
X                              break;
X            case predefTags:  /* Vordef.zeilen bearbeiten */
X                              procPredefLine(cfgLine);
X                              break;
X            case userFldTags: /* Ersetzungsdef bearbeiten */
X                              procUserFldLine(cfgLine);
X                              break;
X            case latexHeadTags: /* Kopfzeilen bearbeiten */
X                              procLatexHeadLine(cfgLine);
X                              break;
X            case latexFootTags: /* Fusszeilen bearbeiten */
X                              procLatexFootLine(cfgLine);
X                              break;
X            case illegalTag:  /* Fehler im Tag aufgetreten */
X                              if (prtToStd)
X				 fprintf(stderr, "bibview: illegal tag %s in %s\n", cfgLine, cfgFname); 
X                              curMode = findTag;
X                              break;
X            case findTag:
X            default:          ;
X         } /* endswitch */
X      } /* endif */
X   } /* endwhile */
X
X   fclose(cfgFP);
X   return(OK);
}
X
X
/*********************************************************************/
/* rcfSetPrintMode:                                                  */
/*    Sets whether messages go to stderr or not                      */
/*********************************************************************/
Errcode
rcfSetPrintMode (Boolean bool)
{
X   prtToStd = bool;
X   return(OK);
}
X
X
/*********************************************************************/
/* rcfReadOptions:                                                   */
/*    Sets flag whether options in rc file should be processed       */
/*********************************************************************/
Errcode
rcfReadOptions (Boolean bool)
{
X   processOptions = bool;
X   return(OK);
}
X
X
X
/*********************************************************************/
/* LOCAL FUNCTIONS                                                   */
/*********************************************************************/
X
/*********************************************************************/
/* getCfgFileTag:                                                    */
/*    Finds next paragraph of config file                            */
/*********************************************************************/
static CfgMode
getCfgFileTag (char *str)
{
char token[MAX_TAGLEN+1] = "";
TagType *tptr;
char found;
X
X   sscanf(str, "[%[^]]s", token);
X
X   for (tptr = &tagTypes[0];
X	tptr->tagStr != NULL && strcmp(token, tptr->tagStr);
X	tptr++) ;
X
X   return( (tptr->tagStr != NULL) ? tptr->mode : illegalTag);
}
X
X
/*********************************************************************/
/* procOptionLine:                                                   */
/*    Process line containing option defs                            */
/*********************************************************************/
static int
procOptionLine (char *str)
{
char token[MAX_TAGLEN+1] = "",
X     value[MAX_TAGLEN+1] = "";
char *p;
int i;
X
X   if (!processOptions)
X      return(OK);
X
X   sscanf(str, "%[^= ]s", token);
X   sscanf(strchr(str, '=')+1, " %[^= ]s", value);
X   if (strcmp(token, STR_BEEP_ON_ERROR_OPT) == 0) {
X      optionsStatus[OPT_BEEP_ON_ERROR] = 
X			       (strcmp(strupr(value), STR_TRUE) == 0);
X   }
X   else if (strcmp(token, STR_ICON_ON_DESK_OPT) == 0) {
X      optionsStatus[OPT_ICON_ON_DESKTOP] = 
X			       (strcmp(strupr(value), STR_TRUE) == 0);
X   }
X   else if (strcmp(token, STR_MAKE_BACKUPS_OPT) == 0) {
X      optionsStatus[OPT_BACKUP_ON_SAVE] = 
X			       (strcmp(strupr(value), STR_TRUE) == 0);
X   }
X   else if (strcmp(token, STR_AUTO_CHECK_BIB_OPT) == 0) {
X      optionsStatus[OPT_AUTO_CHECK_BIB] = 
X			       (strcmp(strupr(value), STR_TRUE) == 0);
X   }
X   else if (strcmp(token, STR_REQUIRED_FIELDS_OPT) == 0) {
X      optionsStatus[OPT_REQUIRED_FIELDS] = 
X			       (strcmp(strupr(value), STR_TRUE) == 0);
X   }
X   else {
X      if (prtToStd)
X	 fprintf(stderr, "bibview: Illegal option %s in config file.\n", str);
X   }
X   return(OK);
}
X
X
/*********************************************************************/
/* procPredefLine:                                                   */
/*    Process line containing predefined data for a field            */
/*********************************************************************/
static int
procPredefLine (char *str)
{
char field[MAX_TAGLEN+1] = "",
X     data[MAX_CFGLINELEN+1] = "";
ListNode **lnp;
char *p;
X
X   if ((p = strchr(str, ':')) == NULL) {
X      if (prtToStd)
X	 fprintf(stderr, "bibview: illegal [Predef] format: %s\n", str);
X      return(OK);
X   }
X
X   *p = '\0';
X   strcpy(field, str);
X   glbTrimString(field);
X   strcpy(data, p+1);
X   glbTrimString(data);
X   if (strcmp(field, "address") == 0)     lnp = &predefLst.address;
X   else if (strcmp(field, "annote") == 0) lnp = &predefLst.annote;
X   else if (strcmp(field, "author") == 0) lnp = &predefLst.author;
X   else if (strcmp(field, "booktitle") == 0) lnp = &predefLst.booktitle;
X   else if (strcmp(field, "chapter") == 0) lnp = &predefLst.chapter;
X   else if (strcmp(field, "edition") == 0) lnp = &predefLst.edition;
X   else if (strcmp(field, "editor") == 0) lnp = &predefLst.editor;
X   else if (strcmp(field, "howpublished") == 0) lnp = &predefLst.howpublished;
X   else if (strcmp(field, "institution") == 0) lnp = &predefLst.institution;
X   else if (strcmp(field, "journal") == 0) lnp = &predefLst.journal;
X   else if (strcmp(field, "key") == 0) lnp = &predefLst.key;
X   else if (strcmp(field, "month") == 0) lnp = &predefLst.month;
X   else if (strcmp(field, "note") == 0) lnp = &predefLst.note;
X   else if (strcmp(field, "number") == 0) lnp = &predefLst.number;
X   else if (strcmp(field, "organization") == 0) lnp = &predefLst.organization;
X   else if (strcmp(field, "pages") == 0) lnp = &predefLst.pages;
X   else if (strcmp(field, "publisher") == 0) lnp = &predefLst.publisher;
X   else if (strcmp(field, "school") == 0) lnp = &predefLst.school;
X   else if (strcmp(field, "series") == 0) lnp = &predefLst.series;
X   else if (strcmp(field, "title") == 0) lnp = &predefLst.title;
X   else if (strcmp(field, "type") == 0) lnp = &predefLst.type;
X   else if (strcmp(field, "volume") == 0) lnp = &predefLst.volume;
X   else if (strcmp(field, "year") == 0) lnp = &predefLst.year;
X   else if (strcmp(field, "category") == 0) lnp = &predefLst.category;
X   else { 
X      if (prtToStd)
X	 fprintf(stderr, "bibview: illegal field %s in config file.\n", field);
X      return(OK);
X   }
X
X   dbtListAppend(lnp, data);
X   return(OK);
}
X
X
/*********************************************************************/
/* procUserFldLine:                                                  */
/*    Process line containing user defined field for a card type     */
/*********************************************************************/
static int
procUserFldLine (char *str)
{
char type[MAX_TAGLEN+1] = "",
X     data[MAX_CFGLINELEN+1] = "";
CardType cardtype;
ListNode **lnp;
char *p;
int i;
X
X   if ((p = strchr(str, '=')) == NULL) {
X      if (prtToStd)
X	 fprintf(stderr, "bibview: illegal [Fields] format: %s\n", str);
X      return(OK);
X   }
X
X   *p = '\0';
X   strcpy(type, str);
X   glbTrimString(type);
X   strcpy(data, p+1);
X   glbTrimString(data);
X   if (strcmp(type, "all") == 0) {
X      for (i = 0; i < MAX_BIBTEX_TYPES; i++)
X	 dbtListAppend(&userDefFlds[i], data);
X   }
X   else if ((cardtype = glbNameToType(type)) != illegal)
X      dbtListAppend(&userDefFlds[cardtype], data);
X   else {
X      if (prtToStd)
X	 fprintf(stderr, "bibview: illegal type %s in config file.\n", 
X			 type);
X   }
X
X   return(OK);
}
X
X
/*********************************************************************/
/* procLatexHeadLine:                                                */
/*    Process line containing a line of LaTeX-Header                 */
/*********************************************************************/
static int
procLatexHeadLine (char *str)
{
int linelen;
X
X   linelen = strlen(str);
X   if (latexHeader) {
X      latexHeaderLen += linelen + 1;
X      latexHeader = (char *)realloc(latexHeader, latexHeaderLen);
X      strcat(latexHeader, str);
X      strcat(latexHeader, "\n");
X   }
X   else {
X      latexHeaderLen = linelen + 2;
X      latexHeader = (char *)malloc(latexHeaderLen);
X      strcpy(latexHeader, str);
X      strcat(latexHeader, "\n");
X   }
X
X   return(OK);
}
X
X
/*********************************************************************/
/* procLatexFootLine:                                                */
/*    Process line containing a line of LaTeX-Footer                 */
/*********************************************************************/
static int
procLatexFootLine (char *str)
{
int linelen;
X
X   linelen = strlen(str);
X   if (latexFooter) {
X      latexFooterLen += linelen + 1;
X      latexFooter = (char *)realloc(latexFooter, latexFooterLen);
X      strcat(latexFooter, str);
X      strcat(latexFooter, "\n");
X   }
X   else {
X      latexFooterLen = linelen + 2;
X      latexFooter = (char *)malloc(latexFooterLen);
X      strcpy(latexFooter, str);
X      strcat(latexFooter, "\n");
X   }
X
X   return(OK);
}
X
X
SHAR_EOF
chmod 0644 rc_file.c ||
echo 'restore of rc_file.c failed'
Wc_c="`wc -c < 'rc_file.c'`"
test 15379 -eq "$Wc_c" ||
	echo 'rc_file.c: original size 15379, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Copyright ==============
if test -f 'Copyright' -a X"$1" != X"-c"; then
	echo 'x - skipping Copyright (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Copyright (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Copyright' &&
X
X Copyright 1992 Technische Universitaet Muenchen
X
X Permission to use, copy, modify, and distribute this software
X and its documentation for any purpose is hereby granted without fee,
X provided that the above copyright notice appear in all copies and
X that both that copyright notice and this permission notice appear
X in supporting documentation.  The authors make no representations
X about the suitability of this software for any purpose.  It is
X provided "as is" without express or implied warranty.
X
X THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
X NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
X OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
X OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
X USE OR PERFORMANCE OF THIS SOFTWARE.
SHAR_EOF
chmod 0640 Copyright ||
echo 'restore of Copyright failed'
Wc_c="`wc -c < 'Copyright'`"
test 954 -eq "$Wc_c" ||
	echo 'Copyright: original size 954, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
X
X                               BIBVIEW 
X            (graphical interface for BibTeX program)
X	     by Holger Martin, Peter Urban, Armin Liebl 
X		  liebla@informatik.tu-muenchen.de
X
X
X
What "bibview" is:
------------------
X
X    The program "bibview" is a graphical interface for manipulating
X    BiBTeX databases. It supports the user in making new entries,
X    searching for entries and moving entries from one BiB to another.
X    It is possible to work with more than one BiB simultaneously. 
X    bibview is implemented with Xt and Athena Widgets.
X    There are six types of windows in bibview:
X    The main window contains menus for customizing bibview and
X    for working with BiBs on the file level.
X    The bibliography window (one for every open BiB) contains commands
X    for manipulating the BiB.
X    The list window (at most one for every open BiB) shows a list of
X    entries. It displays the fields author, title, type and year.
X    The card window (at most one for every entry) helps editing an entry. 
X    It contains boxes for each field of the entry (according to the type).
X    The fields can be edited by putting the mouse cursor into the field.
X    Macros in fields and the symbol for concatenation ('#') are marked
X    with a preceding '@'.
X
X
Installing bibview:
-------------------
X
X    bibview was tested on a HP 9000/710 running HP/UX, 
X    DECstation 2100 and MicroVax II running ULTRIX and
X    on a SUN running SunOS 4.1.
X    To install bibview, type "xmkmf" and then "make". 
X    Good luck!
X    To create the German version, insert -DGERMAN.
X
X
Questions, comments, hacked source code: 
----------------------------------------
Armin Liebl
liebla@informatik.tu-muenchen.de
X
SHAR_EOF
chmod 0640 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 1698 -eq "$Wc_c" ||
	echo 'README: original size 1698, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= patchlevel.h ==============
if test -f 'patchlevel.h' -a X"$1" != X"-c"; then
	echo 'x - skipping patchlevel.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting patchlevel.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'patchlevel.h' &&
#define VERSION 1
#define PATCHLEVEL 0
SHAR_EOF
chmod 0644 patchlevel.h ||
echo 'restore of patchlevel.h failed'
Wc_c="`wc -c < 'patchlevel.h'`"
test 39 -eq "$Wc_c" ||
	echo 'patchlevel.h: original size 39, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= gui_help.c ==============
if test -f 'gui_help.c' -a X"$1" != X"-c"; then
	echo 'x - skipping gui_help.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting gui_help.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'gui_help.c' &&
/*********************************************************************/
/*  bibView: Administration of bibTex-Databases                      */
/*           (Verwaltung von bibTeX-Literaturdatenbanken)            */
/*                                                                   */
/*  Module:  gui_help.c                                              */
/*                                                                   */
/*             GUI Help Window                                       */
/*                                                                   */
/*  Author:  Armin Liebl ,  liebla@informatik.tu-muenchen.de         */
/*                                                                   */
/*  History:                                                         */
/*    07.15.92  PMU  created                                         */
/*    05.26.92       Version 1.0 released                            */
/*                                                                   */
/*  Copyright 1992 TU MUENCHEN                                       */
/*    See ./Copyright for complete rights and liability information. */
/*                                                                   */
/*********************************************************************/
X
#include <stdio.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Xaw/Paned.h>
#include <X11/Xaw/Form.h>
#include <X11/Xaw/Box.h>
#include <X11/Xaw/List.h>
#include <X11/Xaw/Text.h>
#include <X11/Xaw/AsciiText.h>
#include <X11/Xaw/Viewport.h>
#include <X11/Xaw/Command.h>
#include <X11/Xaw/MenuButton.h>
#include <X11/Xaw/SimpleMenu.h>
#include <X11/Xaw/SmeBSB.h>
#include <X11/Xaw/SmeLine.h>
#include "bibview.h"
X
X
/* imported global variables */
/* ------------------------- */
extern Widget topLevel;
extern Pixmap helpIconPixmap;
X
/* macros and definitions */
/* ---------------------- */
X
X
/* local function prototypes */
/* ------------------------- */
Widget helpShell[6];
X
/* exported variables */
/* ------------------ */
X
X
/* local global variables */
/* ---------------------- */
static int hlp[6] = {FALSE,FALSE,FALSE,FALSE,FALSE,FALSE};
static int exists[6] = {FALSE,FALSE,FALSE,FALSE,FALSE,FALSE};
X
void hlpOpenHelpWin(int nummer, char *string1, char *string2);
void hlpQuitHelpCmd(Widget w, XtPointer clientData, XtPointer callData);
X
X
X
X
/*********************************************************************/
/* hlpOpenHelpWin:                                                   */
/*    Opens shell for Help-Window                                    */
/*********************************************************************/
void
hlpOpenHelpWin(int nummer, char *string1, char *string2)
X
{
Widget helpWin, cmdBox, close, file;
X   
X   if (exists[nummer-1])
X     {XtPopup(helpShell[nummer-1], XtGrabNone);
X      return;
X      }
X   
X   /* create popup shell for new file */
X   helpShell[nummer-1] = XtVaCreatePopupShell("helpShell",
X		  topLevelShellWidgetClass, topLevel, 
X		  XtNtitle, string1,
X		  XtNiconName, string1,
X		  XtNiconPixmap, helpIconPixmap, NULL);
X   helpWin = XtVaCreateManagedWidget("helpWin",
X		  panedWidgetClass, helpShell[nummer-1], NULL);
X
X   /* create command buttons */
X   cmdBox = XtVaCreateManagedWidget("commandBox", 
X		  boxWidgetClass, helpWin, NULL);
X   close  = XtVaCreateManagedWidget("close", 
X	          commandWidgetClass, cmdBox, NULL);
X   file   = XtVaCreateManagedWidget("helpText", 
X	          asciiTextWidgetClass, helpWin, 
X		  XtNtype, XawAsciiString,
X		  XtNstring, string2,
X		  XtNscrollHorizontal, XawtextScrollWhenNeeded,
X		  XtNscrollVertical, XawtextScrollWhenNeeded, NULL);
X   exists[nummer-1]=TRUE;
X   XtAddCallback(close, XtNcallback, hlpQuitHelpCmd,(XtPointer)nummer);
X   XtPopup(helpShell[nummer-1], XtGrabNone);
X   return;
}
X
X
/*********************************************************************/
/* hlpOpenHelpWin:                                                   */
/*    Opens shell for Help-Window                                    */
/*********************************************************************/
void
hlpOpenHelpWinCmd(Widget w, XtPointer clientData, XtPointer callData)
{
#ifdef GERMAN
X   char *line1   = "Ueberblick";
#else
X   char *line1   = "Survey";
#endif
X
#ifdef GERMAN
X   char *line2   = "Hauptfenster";
#else
X   char *line2   = "Main Window";
#endif
X
#ifdef GERMAN
X   char *line3   = "Bibliographiefenster";
#else
X   char *line3   = "Bibliography Window";
#endif
X
#ifdef GERMAN
X   char *line4   = "Listenfenster";
#else
X   char *line4   = "List window";
#endif
X
#ifdef GERMAN
X   char *line5   = "Kartenfenster";
#else
X   char *line5   = "CardWindow";
#endif
X
#ifdef GERMAN
X   char *line6   = "Andere Fenster";
#else
X   char *line6   = "Other Windows";
#endif
X
#ifdef GERMAN
X   char *string1 = "BIBVIEW - Eine graphische Benutzerschnittstelle\n\
\tzur Verwaltung von BiBTeX-Literaturdatenbanken\n\n\
AUFRUF\n\
bibview  [Standardoptionen] [-file <Dateiname>] [-rcfile <Konfdatei>]\n\n\
DESCRIPTION\n\
Bibview erleichtert die Verwaltung von BibTeX-Literaturdatenbanken\n\
(im folgenden als BiB bezeichnet). Der Benutzer wird beim\n\
Eintragen von Daten, bei der Suche nach Eintraegen und beim\n\
Kopieren von Eintraegen zwischen verschiedenen BiBs unterstuetzt.\n\
Es kann gleichzeitig mit mehreren BiBs gearbeitet werden. \n\
\n\
Es gibt sieben verschiedene Fensterarten in bibview:\n\
\n\
Das Hauptfenster (main window) enthaelt Menues zum Einstellen von\n\
Optionen und zum Arbeiten mit BiBs auf Dateiebene.\n\
\n\
Das Bibliographiefenster (bibliography window) (eines pro geoeffneter\n\
BiB) enthaelt Kommandos zum Bearbeiten der BiB.\n\
\n\
Das Listenfenster (list window) (maximal eines pro geoeffneter BiB)\n\
zeigt eine Liste von Eintraegen. Die Felder Autor, Titel, Typ\n\
und Jahr werden gezeigt.\n\
\n\
Das Kartenfenster (card window) (maximal eines pro Eintrag)\n\
dient zum Editieren der Eintraege. Es enthaelt Boxen fuer alle\n\
Felder des Eintrags (je nach dem Typ des Eintrags).\n\
Ein Feld kann editiert werden, wenn sich der Maus-Cursor in der\n\
entsprechenden Box befindet.\n\
Makros in Feldern und das Symbol fuer Konkatenation ('#') sind\n\
durch das Zeichen '@' gekennzeichnet. Die von BibTeX geforderten\n\
Felder sind durch fette Linien markiert.\n\
Ein Kartenfenster wird nach dem Anklicken des entsprechenden Eintrags\n\
im Listenfenster (mit der linken Maustaste) oder nach der Auswahl\n\
des Typs im Neu-Menue des Bibliographiefensters geoeffnet.\n\
\n\
Im Annote-Fenster (annote window) (maximal eines pro Eintrag) \n\
kann das Annote-Feld eines Eintrags editiert werden. \n\
\n\
Im Makrofenster (macro window) (maximal eines pro BiB) koennen die \n\
STRING- and PREAMBLE-Teile  einer BiB editiert werden. \n\
\n\
Das Fehlerfenster (error window) (maximal eines pro BiB) erscheint,\n\
falls in einer BiB Syntaxfehler aufgetreten sind. Die Zeile mit\n\
dem Fehler ist durch eine Balken markiert. Die Datei kann editiert\n\
und erneut geoeffnet werden.\n\n\
OPTIONEN\n\
\n\
Standardoptionen:\n\
\n\
Die Standardoptionen sind\n\
-display, -geometry, -iconic and others.\n\
\n\
-file <Dateiname>:\n\
\n\
Die BiBTeX Literaturdatenbank <Dateiname> wird geladen .\n\
\n\
-rcfile <Konfdatei>:\n\
\n\
Anstelle der Datei .bibviewrc im Homedirectory des Benutzers\n\
wird die Datei <Konfdatei> verwendet.\n\
\n\n\
EINSCHRAENKUNGEN\n\
Bei Dateien mit mehr als 1000 Eintraegen kann es aufgrund eines\n\
Fehlers bei bestimmten Servern zum Absturz kommen.\n\
Es ist nur eine Sortierung nach dem BiBTeX-Schluessel moeglich.\n\
\n\
Vorschlaege fuer weitere Features sind willkommen.\n\
\n\
COPYRIGHT\n\
Copyright 1992 Technische Universitaet Muenchen\n\
\n\
AUTOREN\n\
Holger Martin, Peter Urban and Armin Liebl.\n\
Fehlermeldungen und Erweiterungsvorschlaege bitte an\n\n\
\tliebla@informatik.tu-muenchen.de";
#else  
X   char *string1 = "BIBVIEW - an X based graphical user interface\n\
\tfor manipulating BiBTeX databases\n\n\
SYNOPSIS\n\
bibview  [standard options] [-file <bib file>] [-rcfile <conf file>]\n\n\
DESCRIPTION\n\
Bibview facilitates the manipulation of BiBTeX databases (in the \n\
following called BiB). It supports the user in making new entries,\n\
searching for entries and moving entries from one BiB to another.\n\
It is possible to work with more than one BiB simultaneously. \n\
\n\
There are seven types of windows in bibview:\n\
\n\
The main window contains menus for customizing bibview and\n\
for working with BiBs on the file level.\n\
\n\
The bibliography window (one for every open BiB) contains commands\n\
for manipulating the BiB.\n\
\n\
The list window (at most one for every open BiB) shows a list of\n\
entries. It displays the fields author, title, type and year.\n\
\n\
The card window (at most one for every entry) helps editing an \n\
entry.  It contains boxes for each field of the entry (according \n\
to the type).\n\
The fields can be edited by putting the mouse cursor into the field.\n\
Macros in fields and the symbol for concatenation ('#') are marked\n\
by a preceding '@'. The required fields are marked by bold lines.\n\
A card window is displayed after clicking an entry in the list menu\n\
(left mouse button) or selecting a type in the `New` menu of a\n\
bibliography window.\n\
\n\
The annote window (at most one for every entry) helps editing \n\
the annote field of an entry. \n\
\n\
The macro window (at most one for every open BiB) helps editing \n\
the STRING and PREAMBLE parts of a BiB. \n\
\n\
The error window (at most one for every BiB) is displayed\n\
if a BiB cannot be opened because of syntax errors. The line with\n\
the error is marked. The file can be edited and opened again.\n\n\
OPTIONS\n\
\n\
standard options:\n\
\n\
The standard options are\n\
-display, -geometry, -iconic and others.\n\
\n\
-file <bib file>:\n\
\n\
The BiBTeX database <bib file> is loaded at the start of bibview.\n\
\n\
-rcfile <conf file>:\n\
\n\
Instead of the file .bibviewrc in the home directory of the user\n\
the file <conf file> is used.\n\
\n\n\
LIMITATIONS\n\
There may be problems with files containing more than ca. 1000\n\
entries. \n\
The consistency check could be more sophisticated.\n\
Entries are sorted only by BiBTeX key.\n\
\n\
Ideas for more features are welcome.\n\
\n\
COPYRIGHT\n\
Copyright 1992 Technische Universitaet Muenchen\n\
\n\
AUTHORS\n\
Holger Martin, Peter Urban and Armin Liebl.\n\
Send bug reports and ideas for enhancement to\n\n\
\tliebla@informatik.tu-muenchen.de";
#endif  
X
#ifdef GERMAN
char *string2 = "HAUPTFENSTER\n\
\n\
Das Hauptfenster erscheint beim Starten von bibview.\n\
Es enthaelt die folgenden Menues:\n\
\n\
DATEI:  Laden und Speichern von BiBs. Der Auswahl von Dateinamen \n\
erfolgt ueber eine Fileselect-Box. Das DATEI-Menue bietet die\n\
folgende Kommandos:\n\
\tNeu             - Erzeugen einer neuen BiB.\n\
\tOeffnen         - Einlesen einer existierenden BiB.\n\
\tSchliessen      - Schliessen einer geoeffneten BiB.\n\
\tSpeichern       - Abspeichern einer  geoeffneten BiB.\n\
\tSpeichern unter - Abspeichern einer geoeffneten BiB unter\n\
\t                  neuem Namen.\n\
\tBeenden         - Beenden einer bibview-Sitzung.\n\
\n\
DIENSTE:\n\
Das DIENSTE-Menue enthaelt die folgenden Kommandos:\n\
\n\
Konsistenzcheck - \n\
\tEintraege, die nicht alle von BibTeX fuer den entsprechenden\n\
\tTyp geforderten Felder aufweisen, werden im Listenfenster\n\
\tangezeigt.\n\
\n\
Mischen - \
Alle Eintraege einer BiB werden in eine andere BiB \n\
\teingefuegt. Eintraege mit gleichem Schluessel werden \n\
\tignoriert.\n\
\n\
Druck in Datei - \
Eine LaTeX-Datei mit den Datensaetzen der BiB \n\
\twird erzeugt. \n\
\n\
Makros editieren- \n\
\tDas Makrofenster zum Editieren der Makros einer BiB\n\
\twird geoeffnet\n\
\n\
Konfiguration laden- \n\
\tEine Konfigurationsdatei wird geladen. Der Options-Teil\n\
\tder Konfigurationsdatei wird nicht ausgewertet.\n\
\n\
OPTIONEN: \n\
Das OPTIONEN-Menue dient zum Aendern der voreingestellten\n\
Optionen.\n\
\n\
Warnton bei Fehler -\n\
\tIm Falle eines Fehlers ertoent ein Warnton \n\
\t(Voreinstellung: TRUE).\n\
\n\
Sicherungskopien - \n\
\tVor dem Abspeichern einer BiB wird eine Sicherungskopie\n\
\tmit der Endung .bak erzeugt (Voreinstellung: TRUE).\n\
\n\
Icons auf Desktop - \n\
\tIcons vom Listenfenster und von Kartenfenstern werden auf\n\
\tdem zugehoerigen Bibliographiefenster abgelegt\n\
\t(Voreinstellung: FALSE).\n\
\tDiese Option funktioniert nicht bei allen Window-Managern.\n\
\n\
Autom. Ueberpruefung - \n\
\tBeim Laden einer neuen BiB findet ein Konsistenzcheck statt \n\
\t(Voreinstellung: TRUE).\n\
\n\
Zwingende Felder - \n\
\tEin Eintrag kann nur abgespeichert werden,\n\
\twenn alle von BiBTeX geforderten Felder ausgefuellt sind\n\
\t(Voreinstellung: FALSE).\n\
\n\
\n\
FENSTER: \n\
\n\
Kaskadieren - \n\
\tDie Fenster, die zur selben BiB gehoeren \n\
\t(Bibliographiefenster, Makrofenster, Kartenfenster) werden\n\
\tzusammen gruppiert.\n\
\tDas funktioniert nicht bei allen Window-Managern.\n\
\n\
HILFE: Oeffnen eines Fensters mit dem entsprechenden Hilfetext.";
#else
char *string2 = "MAIN WINDOW\n\
\n\
The main window is displayed when bibview is started.\n\
It offers the following menus:\n\
\n\
FILE:  Load and save BiBs. For choosing a name a file select box \n\
is displayed. The FILE menu consists of the following commands:\n\
\tNew\t - Create a new BiB.\n\
\tOpen\t - Read an existing BiB.\n\
\tClose\t - Close an open BiB.\n\
\tSave\t - Save an open BiB.\n\
\tSave as\t - Save an open BiB and select a new name for it.\n\
\tQuit\t - Quit a bibview session.\n\
\n\
SERVICES:\n\
The SERVICES menu consists of the following commands:\n\
\n\
Consistency Check - \n\
\tEntries that don't contain all required fields\n\
\tfor that type are shown in the list window.\n\
\t(More sophisticated tests should be implemented.)\n\
\n\
Unify - \
Insert all entries of one BiB in another. Entries with\n\
\tconflicting keys are ignored.\n\
\n\
Print - \
A LaTeX file with the entries of a BiB is created. \n\
\n\
Edit Macros - \n\
\tOpen macro window for editing the macros of a BiB.\n\
\n\
Load Configuration - \n\
\tLoad a configuration file. \n\
\n\
OPTIONS: \n\
The OPTIONS menu serves for changing default options\n\
\n\
Beep on Errors -\n\
\tBeep in case of an error (default: TRUE).\n\
\n\
Backup - \n\
\tBefore writing a BiB on disk, a backup of the file with the\n\
\tending '.bak' is created (default: TRUE).\n\
\n\
Icons on Desktop - \n\
\tIcons of list and card windows are layed down\n\
\ton the corresponding bibliography window (default: FALSE).\n\
\tThis option doesn't work with all window managers.\n\
\n\
Autom. Check - \n\
\tA consistency check takes place if a new BiB is\n\
\tloaded (default: TRUE).\n\
\n\
Required Fields - \n\
\tAn entry can only be saved if it contains all\n\
\tfields required by BiBTeX (default: FALSE).\n\
\n\
\n\
WINDOW: \n\
\n\
Cascade - \n\
\tThe windows belonging to the same BiB (bibliography window,\n\
\tmacro window, card windows) are grouped together.\n\
\tThis doesn't work with all window managers.\n\
\n\
HELP: Show help information.";
#endif
X
#ifdef GERMAN
char *string3 = "BIBLIOGRAPHIEFENSTER\n\
\n\
Der Menuebalken des Bibliographiefensters enthaelt Funktionen\n\
zum Bearbeiten der entsprechenden BiB:\n\
\n\
Neu:\t\
Einfuegen eines neuen Eintrags in die BiB. Der Typ des\n\
\tEintrags wird von einem Pulldown-Menue gewaehlt. Daraufhin\n\
\terscheint ein Kartenfenster, das an den Typ angepasst ist.\n\
\n\
Suchen: \
Suche nach Eintraegen, die bestimmte Bedingungen erfuellen\n\
\tEin Fenster erscheint, in dem fuer jedes Feld\n\
\tein regulaerer Ausdruck eingegeben werden kann.\n\
\tDas Ergebnis der Suche (alle Eintraege, bei denen die \n\
\tFelder mit den angegebenen regulaeren Ausdruecken \n\
\tuebereinstimmen) wird im Listenfenster gezeigt und kann\n\
\tweiterverarbeitet werden.\n\
\n\
Liste:\t\
Alle Eintraege der BiB werden im Listenfenster gezeigt. \n\
\tNach dem Anklicken eines Eintrags mit der linken Maus-Taste\n\
\terscheint ein Kartenfenster.\n\
\n\
Makros: \
Das Makrofenster zum Editieren der STRING- und PREAMBLE-Teile\n\
\teiner BiB wird geoeffnet.\n\
\n\
Drucken:    Eine LaTeX-Datei mit den Eintraegen der BiB wird erzeugt.\n\
\n\
Speichern:  Abspeichern der BiB. \n\
\n\
Schliessen: Schliessen der BiB. Falls Eintraege veraendert wurden\n\
X	    oder neue Eintraege erzeugt wurden, ohne dass die BiB\n\
X	    gepeichert wurde, erfolgt eine Warnung.\n\
\n\
Fenster:    Die Fenster, die zur BiB gehoeren (Bibliographiefenster,\n\
X            Makrofenster, Kartenfenster), werden zusammen gruppiert.\n\
X            Das funktioniert nicht bei allen Window-Managern.";
#else
char *string3 = "BIBLIOGRAPHY WINDOW\n\
\n\
The menu bar of the bibliography window contains functions for\n\
manipulating the corresponding BiB:\n\
\n\
New:\t\
Create a new entry. The type of the entry must be chosen\n\
\tfrom a pulldown menu.\n\
\n\
Search: \
Search for all entries that fullfill certain\n\
conditions. \n\
\tA window is displayed in which for every field a \n\
\tregular expression can be entered. The result of the search \n\
\t(the entries that match all regular expressions)\n\
\tis shown in the list window.\n\
\n\
List:\t\
All entries of the BiB are shown in the list window. \n\
\tThe card window is displayed after clicking the \n\
\tcorresponding entry with the left mouse button.\n\
\n\
Macros: \
The macro window for editing STRING und PREAMBLE\n\
\tmacros is displayed.\n\
\n\
Print:\t\
A LaTeX file with the entries of the list is created\n\
\n\
Save: \t\
Save the BiB on disk. The BiB remains loaded.\n\
\n\
Close:\t\
Close the BiB.\n\
\n\
Window:\t\
\tThe windows belonging to the BiB (bibliography window,\n\
\tmacro window, card windows) are grouped together.\n\
\tThis doesn't work with all window managers.";
#endif
X
#ifdef GERMAN
char *string4 = "LISTENFENSTER\n\n\
Ein Listenfenster erscheint nach dem Anklicken des Menuepunkts \n\
\"Liste\" im Bibliographiefenster, als Ergebnis einer Suche oder\n\
als Anzeige von fehlerhaften Eintraegen nach einem Konsistenzcheck.\n\
Der Menuebalken des Listenfenster enthaelt die folgenden Kommandos:\n\
\n\
Drucken:     Eine LaTeX-Datei mit den Eintraegen der Liste wird\n\
X	     erzeugt.\n\
X             Der Dateiname wird mit einer Fileselect-Box\n\
X	     ausgewaehlt.\n\
\n\
Speichern:   Die Eintraege der Liste werden als neue BiB gespeichert.\n\
\n\
Schliessen:  Das Listenfenster wird geschlossen.";
#else
char *string4 = "LIST WINDOW\n\n\
The list window is displayed after clicking the menu \n\
item list of the bibliography window, as result of a search\n\
or as result of a consistency check. The menu bar of the list window\n\
offers the following commands:\n\
\n\
Print:\t\
A LaTeX file with the entries of the list is created.\n\
\n\
Save:\t\
The entries of the list are saved as a new BiB.\n\
\n\
Close:\t\
The list window is closed.";
#endif
X
#ifdef GERMAN
char *string5 = "KARTENFENSTER\n\
\n\
Der Menuebalken des Kartenfensters enthaelt die folgenden\n\
Kommandos:\n\
\n\
Benutzerdaten: Das Kartenfenster wird um die Felder, die vom \n\
X	       Benutzer definiert wurden, erweitert.\n\
\n\
Annote:        Ein Fenster wird geoeffnet, in dem das \n\
X	       Annote-Feld bequem editiert werden kann.\n\
\n\
Loeschen:      Der Eintrag wird aus der BiB entfernt.\n\
\n\
Speichern:     Der Eintrag wird in der BiB gespeichert.\n\
\n\
Kopieren:      Der Eintrag wird in eine andere BiB kopiert.\n\
\n\
Schliessen:    Schliessen des Kartenfensters.";
#else
char *string5 = "CARD WINDOW\n\
\n\
The menu bar of the card window offers the following commands:\n\
\n\
User Data: \n\
\tThe card window is extended with the\n\
\tfields defined by the user.\n\
\n\
Delete:\t\
The entry is deleted from the BiB.\n\
\n\
Save: \t\
The entry is saved in the BiB.\n\
\n\
Copy: \t\
The entry is copied in another BiB.\n\
\n\
Close: \t\
Close the card window.";
#endif
X
#ifdef GERMAN
char *string6 = "ANDERE FENSTER\n\n\
Annote-Fenster\n\
\n\
Der Menuebalken des Annote-Fenster enthaelt die folgenden\n\
Kommandos:\n\
Speichern:   Speichern des Annote-Feldes eines Eintrags.\n\
Schliessen:  Schliessen des Annote-Fensters, ohne den Inhalt zu \n\
X	     speichern.\n\
\n\n\
Makrofenster\n\
\n\
Der Menuebalken des Makrofensters enthaelt die folgenden\n\
Kommandos:\n\
Speichern:   Speichern der MAKRO- und PREAMBLE-Teile des \n\
X	     Makrofensters.\n\
Schliessen:  Schliessen des Makrofensters, ohne den Inhalt zu \n\
X	     speichern.  Falls Aenderungen vorgenommen wurden,\n\
X	     erfolgt eine Rueckfrage.\n\
\n\n\
Fehlerfenster\n\
\n\
Das Fehlerfenster dient zum Korrigieren von Syntaxfehlern.\n\
Der Menuebalken des Fehlerfensters enthaelt die folgenden\n\
Kommandos:\n\
Speichern:   Speichern des Fehlerfensters.\n\
Schliessen:  Schliessen des Fehlerfensters, ohne den Inhalt zu\n\
SHAR_EOF
true || echo 'restore of gui_help.c failed'
fi
echo 'End of  part 18'
echo 'File gui_help.c is continued in part 19'
echo 19 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
