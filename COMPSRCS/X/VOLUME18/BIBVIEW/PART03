Path: uunet!dtix!darwin.sura.net!mips!msi!dcmartin
From: liebla@informatik.tu-muenchen.de (Armin Liebl)
Newsgroups: comp.sources.x
Subject: v18i101: bibview - BibTeX GUI, Part03/20
Message-ID: <1992Aug27.161403.25226@msi.com>
Date: 27 Aug 92 16:14:03 GMT
References: <csx-18i099-bibview@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1731
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: Armin Liebl <liebla@informatik.tu-muenchen.de>
Posting-number: Volume 18, Issue 101
Archive-name: bibview/part03

#!/bin/sh
# this is part.03 (part 3 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file Makefile continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 3; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping Makefile'
else
echo 'x - continuing file Makefile'
sed 's/^X//' << 'SHAR_EOF' >> 'Makefile' &&
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
# $XConsortium: sunLib.tmpl,v 1.11 91/07/31 11:32:08 rws Exp $
X
SHLIBLDFLAGS = -b
PICFLAGS = +Z
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sl
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sl
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sl
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = SharedXlibRev
X          SOXTREV = SharedXtRev
X         SOXAWREV = SharedXawRev
X        SOOLDXREV = SharedOldXRev
X         SOXMUREV = SharedXmuRev
X        SOXEXTREV = SharedXextRev
X      SOXINPUTREV = SharedXinputRev
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
# -------------------------------------------------------------------------
# Imake rules for building libraries, programs, scripts, and data files
# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
# -------------------------------------------------------------------------
# start of Imakefile
X
#
# bibView
#
#
X
SYS_LIBRARIES = -lm
CDEBUGFLAGS =
X
DEFINES = -D_HPUX_SOURCE 
SYS_LIBRARIES = -lm
CDEBUGFLAGS =
CC = cc -Aa
# 18
X
LOCAL_LIBRARIES = -lc $(XAWLIB) $(XMULIB) $(XTOOLLIB) $(XLIB)
DEPLIBS = $(DEPXLIB)
X
SRCS=	bibview.c FileNom.c gui_main.c ctl_open.c ctl_opt.c\
X	gui_bibl.c gui_help.c ctl_srch.c gui_widg.c ctl_save.c\
X	gui_list.c gui_card.c ctl_card.c ctl_serv.c\
X	db_tree.c bib_file.c globdata.c bib_flex.c\
X	ComboBo.c rc_file.c ctl_prt.c gui_edit.c
OBJS=	bibview.o FileNom.o gui_main.o ctl_open.o ctl_opt.o\
X	gui_bibl.o gui_help.o ctl_srch.o gui_widg.o ctl_save.o\
X	gui_list.o gui_card.o ctl_card.o ctl_serv.o\
X	db_tree.o bib_file.o globdata.o bib_flex.o\
X	ComboBo.o rc_file.o ctl_prt.o gui_edit.o
X
PROGRAMS = bibview
all::  $(PROGRAMS)
X
X PROGRAM = bibview
X
all:: bibview
X
bibview: $(OBJS) $(DEPLIBS)
X	if [ -f $@ ]; then $(RM) $@~; $(MV) $@ $@~; fi
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
install:: bibview
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  bibview $(DESTDIR)$(BINDIR)
X
install.man:: bibview.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) bibview.man $(DESTDIR)$(MANDIR)/bibview.$(MANSUFFIX)
X
depend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
lint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
lint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
clean::
X	$(RM) $(PROGRAM)
X
# -------------------------------------------------------------------------
# common rules for all Makefiles - do not edit
X
emptyrule::
X
clean::
X	$(RM_CMD) "#"*
X
Makefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
tags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
# -------------------------------------------------------------------------
# empty rules for directories that do not have SUBDIRS - do not edit
X
install::
X	@echo "install in $(CURRENT_DIR) done"
X
install.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
Makefiles::
X
includes::
X
# -------------------------------------------------------------------------
# dependencies generated by makedepend
X
SHAR_EOF
echo 'File Makefile is complete' &&
chmod 0640 Makefile ||
echo 'restore of Makefile failed'
Wc_c="`wc -c < 'Makefile'`"
test 10445 -eq "$Wc_c" ||
	echo 'Makefile: original size 10445, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bibview.1 ==============
if test -f 'bibview.1' -a X"$1" != X"-c"; then
	echo 'x - skipping bibview.1 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bibview.1 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bibview.1' &&
.TH BIBVIEW 1 "Jul 1992"
.SH NAME
bibview \- 
an X based graphical user interface for manipulating BiBTeX databases 
.SH SYNOPSIS
\fBbibview  [standard options] [-file <bib file>] [-rcfile <conf file>]  \fP 
.SH DESCRIPTION
X     
\fIBibview\fR facilitates the manipulation of BiBTeX databases (in the 
following called BiB). It supports the user in making new entries,
searching for entries and moving entries from one BiB to another.
It is possible to work with more than one BiB simultaneously. 
.br
There are six types of windows in \fIbibview\fR:
.br
The \fImain window\fR contains menus for customizing \fIbibview\fR and
for working with BiBs on the file level.
.br
The \fIbibliography window\fR (one for every open BiB) contains commands
for manipulating the BiB.
.br
The \fIlist window\fR (at most one for every open BiB) shows a list of
entries. It displays the fields author, title, type and year.
.br
The \fIcard window\fR (at most one for every entry) helps editing an entry. 
It contains boxes for each field of the entry (according to the type).
The fields can be edited by putting the mouse cursor into the field.
Macros in fields and the symbol for concatenation ('#') are marked
by a preceding '@'. The required fields are marked by bold lines.
A card window is displayed after clicking an entry in the list menu
(left mouse button) or selecting a type in the `New` menu of a
bibliography window.
.br
The \fImacro window\fR (at most one for every open BiB) helps editing 
the STRING and PREAMBLE parts of a BiB. 
.br
The \fIerror window\fR (at most one for every BiB) is displayed
if a BiB cannot be opened because of syntax errors. The line with
the error is marked. The file can be edited and opened again.
X
.SH Main Window
X
The \fImain window\fR is displayed at the start of \fIbibview\fR.
It offers the following menus.
.br
\fBFile\fR:  Load and save BiBs. For choosing a name a file select box 
is displayed
.br
\fINew\fR - Create a new BiB.
.br
\fIOpen\fR - Read an existing BiB.
.br
\fIClose\fR - Close an open BiB.
.br
\fISave\fR -  Save an open BiB.
.br
\fISave as\fR -  Save an open BiB and select a new name for it.
.br
\fIQuit\fR - Quit a bibview session.
.br
X
\fBServices\fR:
.br
\fIConsistency Check\fR - Entries that don't contain all required fields
for that type are shown in the list window. (More sophisticated tests
should be implemented.)
.br
\fIUnify\fR - Insert all entries of one BiB in another. Entries with
conflicting types are ignored.
.br
\fIPrint\fR - A LaTeX file with the entries of a BiB is created. 
.br
\fIEdit Macros\fR - Open \fImacro window\fR for editing the macros of a BiB.
.br
\fILoad Configuration\fR - Load a configuration file. 
X
\fBOptions\fR: Change default options
.br
\fIBeep on Errors\fR - Beep in case of an error (default: TRUE).
.br
\fIBackup\fR - Before writing a BiB on disk, a backup of the file with the
ending '.bak' is created (default: TRUE).
.br
\fIIcons on Desktop\fR - Icons of list and card windows are layed down
on the corresponding bibliography window (default: FALSE). This option 
doesn't work with all window managers.
.br
\fIAutom. Check\fR - A consistency check takes place if a new BiB is
loaded (default: TRUE).
.br
\fIRequired Fields\fR - An entry can only be saved if it contains all
fields required by BiBTeX (default: FALSE).
X               
\fBWindow\fR: 
.br
\fICascade\fR - The windows belonging to the same BiB (bibliography window,
macro window, card windows) are grouped together. This doesn't work with
all window managers.
X
\fBHelp\fR:
.br 
Help texts are offered to the following topics:
.br
\fISurvey\fR
.br
\fIMain Window\fR
.br
\fIBibliography Window\fR
.br
\fIList Window\fR
.br
\fICard Window\fR
.br
\fIMacro and Error Window\fR
.br
\fIProgram Info\fR
X
.SH Bibliography Window
X
The menu bar of the bibliography window contains functions for
manipulating the corresponding BiB:
X
\fBNew\fR: 
.br 
Create a new entry. The type of the entry must be chosen
from a pulldown menu.
.br
\fBSearch\fR: 
.br
Search for all entries that fullfill certain conditions. A window is displayed
in which for every field a regular expression can be entered. The result of
the search (the entries that match all regular expressions) is shown
in the list window.
.br
\fBList\fR:
.br
All entries of the BiB are shown in the \fIlist window\fR. The \fIcard 
window\fR is displayed after clicking the corresponding entry.
.br
\fBMacros\fR: 
.br
The \fImacro window\fR for editing STRING und PREAMBLE macros is
displayed.
.br
\fBPrint\fR:
.br
A LaTeX file with the entries of the list is created
.br
\fBSave\fR: 
.br
Save the BiB on disk. The BiB remains loaded.
.br
\fBClose\fR:
.br
Close the BiB.
X
.SH List Window
The \fIlist window\fR is displayed after clicking the menu 
item \fIlist\fR of the bibliography window, as result of a search
or as result of a consistency check. The menu bar of the \fIlist window\fR
offers the following commands:
.br
\fBPrint\fR:
.br
A LaTeX file with the entries of the list is created.
.br
\fBSave\fR:
.br
The entries of the list are saved as a new BiB.
.br
\fBClose\fR:
.br
The \fIlist\fR window is closed.
X
.SH Card Window
X
The menu bar of the \fIcard window\fR offers the following commands:
.br
\fBUser Data\fR: 
.br
The \fIcard window\fR is extended with the
fields defined by the user.
.br
\fBAnnote\fR: 
.br
The annote field of an entry can be edited in a window.
.br
\fBDelete\fR: 
.br
The entry is deleted from the BiB.
.br
\fBSave\fR: 
.br
The entry is saved in the BiB.
.br
\fBCopy\fR: 
.br
The entry is copied into another BiB.
.br
\fBClose\fR: 
.br
Close the \fIcard window\fR.
X
.SH Macro Window
X
The menu bar of the \fImacro window\fR offers the following commands:
.br
\fBSave\fR: 
.br
Save the macros and preambles of the \fImacro window\fR.
.br
\fBClose\fR: 
.br
Close the \fImacro window\fR.
X
.SH Error Window
X
The menu bar of the \fIerror window\fR offers the following commands:
.br
\fBSave\fR: 
.br
Save the content of the \fIerror window\fR.
.br
\fBClose\fR: 
.br
Close the \fIerror window\fR.
X
X
.SH Configuration File
X
With the configuration file it is possible to customize \fIbibview\fR.
The standard configuration file is the file \fI.bibviewrc\fR in the
home directory of the user. The configuration file contains
a part for setting the default options [Options], define 
additional fields for certain entries [Fields], define data for
a search [Predefines] and define header [LatexHeader] und footer
[LatexFooter] for LaTeX file. An example is given in the file
\fIbibviewrc\fR of this distribution. The Options part is not
evaluated if a configuration file is loaded by 'Load Configuration'.
X
.SH Resource File
X
The resources (width and height of windows, foreground, colours,
texts,...) can bei customized with a file \fIBibView\fR in the
home directory. A sample file is included.
X
.SH OPTIONS
X
\fBstandard options\fR:
.br
The standard options are
-display, -geometry, -iconic and others.
.br
\fB-file <bib file>\fR:
.br
The BiBTeX database <bib file> is loaded at the start of \fIbibview\fR.
.br
\fB-rcfile <configuration file>\fR:
.br
Instead of \fI.bibviewrc\fR in the home directory
the file <configuration file> is used.
X
.SH LIMITATIONS
Because of a bug in the Athena List Widget there are problems
with files with more than ca. 1000 entries. 
The \fIconsistency check\fR is not sophisticated enough.
Entries are sorted only by BiBTeX key.
.br
Ideas for more features are welcome.
X
.SH COPYRIGHT
Copyright 1992 Technische Universitaet Muenchen
X
.SH AUTHORS
Holger Martin, Peter Urban and Armin Liebl.
.br
Send bug reports and ideas for enhancement to
liebla@informatik.tu-muenchen.de 
X
SHAR_EOF
chmod 0640 bibview.1 ||
echo 'restore of bibview.1 failed'
Wc_c="`wc -c < 'bibview.1'`"
test 7641 -eq "$Wc_c" ||
	echo 'bibview.1: original size 7641, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= b.tab.h ==============
if test -f 'b.tab.h' -a X"$1" != X"-c"; then
	echo 'x - skipping b.tab.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting b.tab.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'b.tab.h' &&
# define STRING 257
# define PREAMBLE 258
# define ARTICLE 259
# define BOOK 260
# define BOOKLET 261
# define CONFERENCE 262
# define INBOOK 263
# define INCOLLECTION 264
# define INPROCEEDINGS 265
# define MANUAL 266
# define MASTERSTHESIS 267
# define MISC 268
# define PHDTHESIS 269
# define PROCEEDINGS 270
# define TECHREPORT 271
# define UNPUBLISHED 272
# define KOMMA 273
# define EQ 274
# define LGKL 275
# define RGKL 276
# define LRKL 277
# define RRKL 278
# define DAZ 279
# define ZAUN 280
# define ZEICHEN 281
# define WHITE_SPACE 282
# define BUCHSTABE_ZAHL 283
SHAR_EOF
chmod 0644 b.tab.h ||
echo 'restore of b.tab.h failed'
Wc_c="`wc -c < 'b.tab.h'`"
test 577 -eq "$Wc_c" ||
	echo 'b.tab.h: original size 577, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bib_file.c ==============
if test -f 'bib_file.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bib_file.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bib_file.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bib_file.c' &&
#ifdef __cplusplus
X   #include <stdio.h>
X   extern "C" {
X     extern void yyerror(char *);
X     extern int yylex();
X   }
#endif	/* __cplusplus */ 
#include <stdio.h>
#include <ctype.h>
#include <X11/Intrinsic.h>
#include <unistd.h>
#include "bibview.h"
X
X
#define YYSTYPE char
X
#define __RUNTIME_YYMAXDEPTH
#define YYMAXDEPTH 1000
X
#define MAX_UEBERGABE  20000
X
char uebergabe[MAX_UEBERGABE];
int ueIdx = 0;
X
FILE *tempDatei;
extern FILE *yyin;
extern YY_NEW_FILE;
extern int yy_init;
X
typedef struct _Snode {
X                       char inh;
X                       int slen;
X                       struct _Snode *next;
} Snode;
X
/*******************************************/
/* Globale Variablen                       */
/*******************************************/
X
static Snode *key = NULL;            
static Snode *fldname = NULL;       
static Snode *fldcont = NULL;      
X
static CardData *card = NULL;
static UserFld *helpufield = NULL;
static String helpFldName = NULL;
static Errcode err;
static int glbtreeIdx;
static int beginIdx;
int yynline;
int yynflexcalls;
int yynerrs;
/*******************************************/
/* Lokale Funktionen                       */
/*******************************************/
X
static void PushSign(Snode **w, char a);
static void AppendSign(Snode **w, char a);
static void FreeStack(Snode **s);
static void StackToString(Snode *s, char **text); 
static void GetKey();
static void GetFldNameCont();
X
static Errcode Scalloc(String *s1, String s2);
static char * Sncalloc(char *s2, int von, int bis);
static int SetInputFile(char *file);
static int SkipSpace(char *text, Snode **new);
static int SkipNewLineSpace(char *text);
static void StrToLower(char *text);
static int StringIsPeteEmpty(char *text);
static void WriteRecToFile(CardData *card, FILE *datei);
static long WriteLineToFile(FILE *datei, char *feld, char *inh);
static int ItIsBibFile(char *dateiName);
# define STRING 257
# define PREAMBLE 258
# define ARTICLE 259
# define BOOK 260
# define BOOKLET 261
# define CONFERENCE 262
# define INBOOK 263
# define INCOLLECTION 264
# define INPROCEEDINGS 265
# define MANUAL 266
# define MASTERSTHESIS 267
# define MISC 268
# define PHDTHESIS 269
# define PROCEEDINGS 270
# define TECHREPORT 271
# define UNPUBLISHED 272
# define KOMMA 273
# define EQ 274
# define LGKL 275
# define RGKL 276
# define LRKL 277
# define RRKL 278
# define DAZ 279
# define ZAUN 280
# define ZEICHEN 281
# define WHITE_SPACE 282
# define BUCHSTABE_ZAHL 283
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
extern int yychar;
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
X
/* __YYSCLASS defines the scoping/storage class for global objects
X * that are NOT renamed by the -p option.  By default these names
X * are going to be 'static' so that multi-definition errors
X * will not occur with multiple parsers.
X * If you want (unsupported) access to internal names you need
X * to define this to be null so it implies 'extern' scope.
X * This should not be used in conjunction with -p.
X */
#ifndef __YYSCLASS
# define __YYSCLASS static
#endif
#ifndef YYSTYPE
#define YYSTYPE int
#endif
YYSTYPE yylval;
__YYSCLASS YYSTYPE yyval;
typedef int yytabelem;
# define YYERRCODE 256
X
X
static void StrToLower(char *text)
{
X while (*text != '\0') {
X   *text++ = tolower(*text);
X }
}
X
X
X
static int SkipNewLineSpace(char *text)
{ 
X int erg, back;
X
X erg = 0;
X while (erg < MAX_UEBERGABE) {
X   if (*text == '{' ||  *text == '(') {
X     back = strlen(text);
X     text = text + back;
X     while (*text != '}' && *text != ')') { 
X       *text = '\0';
X       text--;
X     }
X     return erg;
X   }
X   text++;
X   erg++;
X }
X return 0;
}
X
X
X
X
static int SkipSpace(char *text, Snode **new)
{
X int erg, lgkl, daz, index, inmakro;
X 
X index = 0;
X lgkl = 0;
X daz = 0;
X inmakro = 0;
X
X while ((*text == ' ' || *text == '=' || *text == '\t') && index < ueIdx) { text++; index++; }
X erg = index;
X if (*text == '{') {
X   lgkl += 1;
X   index++;
X   text++; 
X   inmakro = 0;
X }
X else if (*text == '"') {
X   daz += 1;
X   index++;
X   text++; 
X   inmakro = 0;
X }
X else {
X   AppendSign(new, '@');
X   AppendSign(new, *text);
X   index++;
X   text++; 
X   inmakro = 1;
X }
X while (index < ueIdx) {
X   if (*text == '{') {
X     if (lgkl >= 1 || daz >= 1) {  /* Klammer in String */
X       AppendSign(new, *text);
X     }
X     text++;                       /* Klammer nach Zaun */
X     index++;
X     lgkl += 1;
X     inmakro = 0;
X   }
X   else if (*text == '}') {
X     if ((lgkl > 1) || (daz >= 1)) {
X       AppendSign(new, *text);
X     } 
X     text++;
X     index++;
X     lgkl -= 1;
X     inmakro = 0;
X   }
X   else if (*text == '"') {
X     if (lgkl >= 1) {
X       AppendSign(new, *text);
X       text++;
X       index++;
X     } 
X     else {
X       text++;
X       index++;
X       if (daz == 0) daz++;
X       else daz = 0;
X     }
X     inmakro = 0;
X   }
X   else if (*text == '#') {        /* Space vor/nach Konkatenation */
X     if (lgkl < 1 && daz < 1) {
X       if (text[index-1] != ' ') AppendSign(new, ' ');
X       AppendSign(new, '@');       /* # -> @# */
X       AppendSign(new, *text);
X       if (text[index+1] != ' ') AppendSign(new, ' ');
X     }
X     else {                        /* Konkatenation in String */
X       AppendSign(new, *text);
X     }
X     text++;
X     index++;
X     inmakro = 0;
X   } 
X   else if (*text == ',') {        /* Komma am Ende */
X     if (lgkl < 1 && daz != 1) break;
X     else {
X       AppendSign(new, *text);
X       text++;
X       index++;
X     }
X     inmakro = 0;
X   }
X   else if (*text == ')') {        /* runde Klammer am Ende */
X     if (lgkl < 1 && daz != 1) break;
X     else {
X       AppendSign(new, *text);
X       text++;
X       index++;
X     }
X     inmakro = 0;
X   }
X   else if (isalnum(*text)) {
X     if (lgkl < 1 && daz < 1 && (inmakro==0)) {
X       if (text[index-1] != ' ') AppendSign(new, ' ');
X       AppendSign(new, '@');       /* makro -> @makro */
X       AppendSign(new, *text);
X       inmakro = 1;
X     }
X     else {                        /* Zeichen in String */
X       AppendSign(new, *text);
X     }
X     text++;
X     index++;
X   } 
X   else {                        /* sonstiges Zeichen in String */
X     AppendSign(new, *text);
X     text++;
X     index++;
X     inmakro = 0;
X   } 
X }
X return erg;
X  
}
X
X
static void PushSign(Snode **w, char a)
{
X Snode *hnode, *oldw;
X
X if (*w == NULL) {
X   hnode = (Snode *)calloc(1,sizeof(Snode));
X   hnode->inh = a;
X   hnode->slen = 1;
X   hnode->next = NULL;
X   *w = hnode;
X }
X else {
X   oldw = *w; 
X   hnode = (Snode *)calloc(1,sizeof(Snode));
X   hnode->inh = a;
X   hnode->slen = oldw->slen + 1;
X   hnode->next = oldw;
X   *w = hnode;
}
}
X
X
static void AppendSign(Snode **w, char a)
{
X Snode *hnode, *oldw;
X int newslen;
X
X if (*w == NULL) {
X   hnode = (Snode *)calloc(1,sizeof(Snode));
X   hnode->inh = a;
X   hnode->slen = 1;
X   hnode->next = NULL;
X   *w = hnode;
X }
X else {
X   oldw = *w; 
X   newslen = 1;
X   while (oldw->next != NULL) {
X     newslen++; 
X     oldw = oldw->next;
X   }
X   newslen++; 
X   hnode = (Snode *)calloc(1,sizeof(Snode));
X   hnode->inh = a;
X   hnode->slen = 1;
X   hnode->next = NULL;
X   oldw->next = hnode;
X   oldw = *w; 
X   oldw->slen = newslen;      /* echte Laenge nur im 1. El. */
}
}
X
X
static void FreeStack(Snode **s)
{
X Snode *h, *del;
X
X del = *s;
X while (del != NULL) {
X   h = del->next;
X   free(del);
X   del = h;
X }
X *s = NULL;
} 
X
X
static void StackToString(Snode *s, char **text) 
{
X  char *help;
X
X  help = (char *)calloc(1,s->slen+1);
X  *text = help;
X  while (s != NULL) {
X    *help = s->inh; 
X    s = s->next;
X    help++;
X  }
X  *help = '\0';
X  help--;
X  while (*help == '\n') {    /* NL am Ende vom Wort loeschen */
X    *help = '\0';
X    help--;
X  }
}
X
X
X
static void GetKey()
{
X  StackToString(key, &card->mainkey);
X  FreeStack(&key);
X  err = dbtInsert(glbtreeIdx, card);
X  err = dbtDeleteCard(&card);
}
X
X
static void GetFldNameCont()
{
X  int anf, i;
X  
X  if (helpFldName != NULL) {
X    free(helpFldName);
X    helpFldName = NULL;
X  }
X  StackToString(fldname, &helpFldName);
X  StrToLower(helpFldName); 
X  anf = SkipSpace(uebergabe, &fldcont);
X
X  if (strcmp(helpFldName, "address") == 0) {
X    StackToString(fldcont, &card->address);
X  } 
X  else if (strcmp(helpFldName, "annote") == 0) {
X    StackToString(fldcont, &card->annote);
X  } 
X  else if (strcmp(helpFldName, "author") == 0) {
X    StackToString(fldcont, &card->author);
X  } 
X  else if (strcmp(helpFldName, "booktitle") == 0) {
X    StackToString(fldcont, &card->booktitle);
X  } 
X  else if (strcmp(helpFldName, "chapter") == 0) {
X    StackToString(fldcont, &card->chapter);
X  } 
X  else if (strcmp(helpFldName, "crossref") == 0) {
X    StackToString(fldcont, &card->crossref);
X  }
X  else if (strcmp(helpFldName, "edition") == 0) {
X    StackToString(fldcont, &card->edition);
X  } 
X  else if (strcmp(helpFldName, "editor") == 0) {
X    StackToString(fldcont, &card->editor);
X  } 
X  else if (strcmp(helpFldName, "howpublished") == 0) {
X    StackToString(fldcont, &card->howpublished);
X  } 
X  else if (strcmp(helpFldName, "institution") == 0) {
X    StackToString(fldcont, &card->institution);
X  } 
X  else if (strcmp(helpFldName, "journal") == 0) {
X    StackToString(fldcont, &card->journal);
X  } 
X  else if (strcmp(helpFldName, "key") == 0) {
X    StackToString(fldcont, &card->key);
X  } 
X  else if (strcmp(helpFldName, "month") == 0) {
X    StackToString(fldcont, &card->month);
X  } 
X  else if (strcmp(helpFldName, "note") == 0) {
X    StackToString(fldcont, &card->note);
X  } 
X  else if (strcmp(helpFldName, "number") == 0) {
X    StackToString(fldcont, &card->number);
X  } 
X  else if (strcmp(helpFldName, "organization") == 0) {
X    StackToString(fldcont, &card->organization);
X  } 
X  else if (strcmp(helpFldName, "pages") == 0) {
X    StackToString(fldcont, &card->pages);
X  } 
X  else if (strcmp(helpFldName, "publisher") == 0) {
X    StackToString(fldcont, &card->publisher);
X  } 
X  else if (strcmp(helpFldName, "school") == 0) {
X    StackToString(fldcont, &card->school);
X  } 
X  else if (strcmp(helpFldName, "series") == 0) {
X    StackToString(fldcont, &card->series);
X  } 
X  else if (strcmp(helpFldName, "title") == 0) {
X    StackToString(fldcont, &card->title);
X  } 
X  else if (strcmp(helpFldName, "type") == 0) {
X    StackToString(fldcont, &card->type);
X  } 
X  else if (strcmp(helpFldName, "volume") == 0) {
X    StackToString(fldcont, &card->volume);
X  } 
X  else if (strcmp(helpFldName, "year") == 0) {
X    StackToString(fldcont, &card->year);
X  } 
X  else if (strcmp(helpFldName, "category") == 0) {
X    StackToString(fldcont, &card->category);
X  } 
X  else {
X    err = dbtMakeUserFld(&helpufield);
X    Scalloc(&helpufield->fldName, helpFldName);
X    StackToString(fldcont, &helpufield->fldData); 
X    err = dbtAppendUserFld(&card->ufield, helpufield);
X  }
X  FreeStack(&fldname);
X  FreeStack(&fldcont);
}
X
X
X
/*********************************************************************/
/*  Errcode Scalloc(String *s1, String s2):                          */
/*  Platz fuer s1 bereitstellen und s2 nach s1 kopieren              */
/*********************************************************************/
X
static Errcode Scalloc(String *s1, String s2)
{
X if (s2 != NULL){
X   *s1 = (String)calloc(1,strlen(s2)+1);
X   if (*s1 == NULL) return BIF_ECALLOC;
X   strcpy(*s1, s2);
X }
X return BIF_OK;
}
X
X
X
static char * Sncalloc(char *s2, int von, int bis)
{
X char *help, *weiter;
X int i;
X
X if (s2 != NULL){
X   help = (char *)calloc(1,bis);
X   if (help == NULL) return NULL;
X   strncpy(help, &s2[von], bis - von + 1 );
X   weiter = help;
X   for (i = 0; i < bis - von + 1; i++) weiter++;
X   *weiter = '\0'; 
}
X return help;
}
X
X
X
static int SetInputFile(char *file)
{
X char *infilename; 
X    
X if (file)
X {
X  infilename = file;
X  yyin = fopen(infilename, "r" );
X
X  if ( yyin == NULL ) {
X    return BIF_EOPEN;  
X  }
X  return BIF_OK;  
X }
X else
X {
X   yyin = stdin;
X   infilename = "<stdin>";
X   return BIF_OK;  
X }
}
X
X
/*********************************************
X * Test, ob Datei im BibTeX-Format           *
X *********************************************/
static int ItIsBibFile(char *dateiName)
{
X FILE *dptr;
X char inh;
X
X dptr = fopen(dateiName, "r");
X inh = (char)getc(dptr);
X if (inh == '@') {
X   fclose(dptr); 
X   return 1;
X }
X while (inh == ' ' || inh == '\t' || inh == '\n') 
X   inh = (char)getc(dptr);
X if (inh == '@') {
X   fclose(dptr); 
X   return 1;
X }
X else {
X   fclose(dptr); 
X   return 0;
X }
}
X
X
X
/*********************************************
X * BibTeX-Datei lesen                        *
X *********************************************/
Errcode bifFileRead(BibPtr bp)
{
X  int erg;
X  int len, i;
X  char *tempName;
X
X  yynline = 1; 
X  yynflexcalls = 0;
X  bp->tempfile = (char *)tempnam(NULL, NULL);
X  bp->macrofile = (char *)tempnam(NULL, NULL);
X  tempDatei = fopen(bp->macrofile, "w" );
X  if ((erg = SetInputFile(bp->filepath)) != 1) return erg;
X  if ((erg = ItIsBibFile(bp->filepath)) != 1) return ERR_NOBIB;
X  glbtreeIdx = bp->treeIdx; 
X  erg = yyparse();
X  fclose(tempDatei);
X  uebergabe[0] = '\0';
X  ueIdx = 0;
X  if (erg == 0) {
X    if (yyin) fclose(yyin);
X    return BIF_OK;
X  }
X  else {
X    erg = -yynline;
X    yy_init = 1;
X    if (yyin) fclose(yyin);
X    return (Errcode)erg;
X  }
}
X
X
X
Errcode bifFileWrite(BibPtr bp)
{
X CardListNode *list, *hlist;
X CardData *hcard;
X Errcode erg;
X char sysStr[2*MAX_FILEPATHLEN];
X String saveName;
X int savelen;
X
CardListNode *cl = NULL;
char wcKey[] = ".";
CardData *wcCard;
Errcode status;
X
X if (bp->macrofile!=NULL){
X    sprintf(sysStr, "cp  %s %s", bp->macrofile, bp->tempfile);
X    system(sysStr);
X    tempDatei = fopen(bp->tempfile, "r+");
X    }
X else
X    {tempDatei = fopen(bp->tempfile, "w+");
X     }
X
X if (tempDatei == NULL) return BIF_EWRITE;
X
X   /* build list with wildcard search */
X   if ((status = (int)dbtMakeCard(&wcCard)) != OK) {
X      guwError(status);
X   }
X   wcCard->cardtype = (int)regexpr;
X   wcCard->mainkey = glbNewString(".");
X   if ((status = dbtSearchList(bp->treeIdx, wcCard, &cl)) != OK) {
X      guwError(status); 
X      return;
X   }
X
X while (cl != NULL) {
X   WriteRecToFile(cl->data, tempDatei);
X   cl = cl->next;
X } 
X
X fclose(tempDatei);
X sprintf(sysStr, "cp  %s %s", bp->tempfile, bp->filepath);
X system(sysStr);
X return BIF_OK;
}
X
X
Errcode bifFileListWrite(BibPtr bp, CardListNode *list, String fname)
{
X CardListNode *hlist;
X CardData *hcard;
X Errcode erg;
X char sysStr[2*MAX_FILEPATHLEN];
X String saveName;
X int savelen;
X 
X if (bp->macrofile!=NULL)
X    {sprintf(sysStr, "cp %s %s", bp->macrofile, fname);
X     system(sysStr);
X     }
X
X tempDatei = fopen(fname, "a+");
X if (tempDatei == NULL) return BIF_EWRITE;
X hlist = list;
X while (hlist != NULL) {
X   WriteRecToFile(hlist->data, tempDatei);
X   hlist = hlist->next;
X } 
X fclose(tempDatei);
X return BIF_OK;
}
X
X
static long WriteLineToFile(FILE *datei, char *feld, char *inh)
{
X  int makro = 2;    /* weder Makro, noch String */
X  long pos; 
X  char *tmp;
X
X  fprintf(datei,"     %s = ",feld);    
X  while (*inh == ' ' || *inh == '\t' || *inh == '\n') {
X    fprintf(datei,"%c",*inh);    
X    inh++;
X  }
X  if (*inh == '@') {
X    fprintf(datei," ");    
X    makro = 1;
X  }
X  else {
X    fprintf(datei,"{");    
X    fprintf(datei,"%c",*inh);    
X    makro = 0;
X  }
X  inh++;
X  while (*inh != '\0') {
X    if (*inh == '@') {
X      tmp = inh;
X      tmp++;
X      if (*tmp == '#') {                  /* KONKATENATION */
X        if (makro == 1) {
X          fprintf(datei," # ");           /* letzter Teil war ein MAKRO */ 
X          tmp++;
X          while (*tmp == ' ' || *tmp == '\t' || *tmp == '\n') {
X            fprintf(datei,"%c",*tmp);    
X            tmp++;
X          }
X          if (*tmp == '@') {              /* naechster Teil ist ein MAKRO */
X            fprintf(datei," ");    
X            makro = 1;
X          }
X          else {
X            fprintf(datei,"{");    
X            fprintf(datei,"%c",*tmp);     /* naechster Teil ist ein STRING */
X            makro = 0;
X          }
X        }
X        else if (makro == 0) {
X          fprintf(datei,"} # ");          /* letzter Teil war ein STRING */ 
X          tmp++;
X          while (*tmp == ' ' || *tmp == '\t' || *tmp == '\n') {
X            fprintf(datei,"%c",*tmp);    
X            tmp++;
X          }
X          if (*tmp == '@') {              /* naechster Teil ist ein MAKRO */
X            fprintf(datei," ");    
X            makro = 1;
X          }
X          else {
X            fprintf(datei,"{");    
X            fprintf(datei,"%c",*tmp);     /* naechster Teil ist ein STRING */
X            makro = 0;
X          }
X        }  /* else if makro == 0 */
X        inh = tmp;
X      }
X      else {                              /* AFFE nicht schreiben */
X        fprintf(datei," ");    
X        makro = 1;
X      }
X    }      /* if @ */
X    else {
X      fprintf(datei,"%c",*inh);    
X    }
X    inh++;
X  }  /* while */
X  if (makro == 0) {
X    fprintf(datei,"}");    
X  }
X 
X        
X   pos = ftell(datei);
X   fprintf(datei,",  \n");
X   return pos;
}
X
X
static void WriteRecToFile(CardData *card, FILE *datei)
{
X UserFld *h;
X String newType;
X long pos;
X
X fseek(datei, 0L, SEEK_END); 
X fprintf(datei,"\n");
X pos = ftell(datei);
X newType = glbNewString(glbTypeToName(card->cardtype));
X fprintf(datei,"@%s{%s",newType, card->mainkey);
X pos = ftell(datei);
X fprintf(datei,",\n");
X 
X if (!StringIsPeteEmpty(card->address)) {
X   pos = WriteLineToFile(datei,"ADDRESS",card->address);    
X } 
X if (!StringIsPeteEmpty(card->annote)) {
X   pos = WriteLineToFile(datei,"ANNOTE",card->annote);    
X } 
X if (!StringIsPeteEmpty(card->author)) {
X   pos = WriteLineToFile(datei,"AUTHOR",card->author);    
X } 
X if (!StringIsPeteEmpty(card->booktitle)) {
X   pos = WriteLineToFile(datei,"BOOKTITLE",card->booktitle);    
X } 
X if (!StringIsPeteEmpty(card->chapter)) {
X   pos = WriteLineToFile(datei,"CHAPTER",card->chapter);    
X } 
X if (!StringIsPeteEmpty(card->crossref)) {
X   pos = WriteLineToFile(datei,"CROSSREF",card->crossref);    
X } 
X if (!StringIsPeteEmpty(card->edition)) {
X   pos = WriteLineToFile(datei,"EDITION",card->edition);    
X } 
X if (!StringIsPeteEmpty(card->editor)) {
X   pos = WriteLineToFile(datei,"EDITOR",card->editor);    
X } 
X if (!StringIsPeteEmpty(card->howpublished)) {
X   pos = WriteLineToFile(datei,"HOWPUBLISHED",card->howpublished);    
X } 
X if (!StringIsPeteEmpty(card->institution)) {
X   pos = WriteLineToFile(datei,"INSTITUTION",card->institution);    
X } 
X if (!StringIsPeteEmpty(card->journal)) {
X   pos = WriteLineToFile(datei,"JOURNAL",card->journal);    
X } 
X if (!StringIsPeteEmpty(card->key)) {
X   pos = WriteLineToFile(datei,"KEY",card->key);    
X } 
X if (!StringIsPeteEmpty(card->month)) {
X   pos = WriteLineToFile(datei,"MONTH",card->month);    
X } 
X if (!StringIsPeteEmpty(card->note)) {
X   pos = WriteLineToFile(datei,"NOTE",card->note);    
X } 
X if (!StringIsPeteEmpty(card->number)) {
X   pos = WriteLineToFile(datei,"NUMBER",card->number);    
X } 
X if (!StringIsPeteEmpty(card->organization)) {
X   pos = WriteLineToFile(datei,"ORGANIZATION",card->organization);    
X } 
X if (!StringIsPeteEmpty(card->pages)) {
X   pos = WriteLineToFile(datei,"PAGES",card->pages);    
X } 
X if (!StringIsPeteEmpty(card->publisher)) {
X   pos = WriteLineToFile(datei,"PUBLISHER",card->publisher);    
X } 
X if (!StringIsPeteEmpty(card->school)) {
X   pos = WriteLineToFile(datei,"SCHOOL",card->school);    
X } 
X if (!StringIsPeteEmpty(card->series)) {
X   pos = WriteLineToFile(datei,"SERIES",card->series);    
X } 
X if (!StringIsPeteEmpty(card->title)) {
X   pos = WriteLineToFile(datei,"TITLE",card->title);    
X } 
X if (!StringIsPeteEmpty(card->type)) {
X   pos = WriteLineToFile(datei,"TYPE",card->type);    
X } 
X if (!StringIsPeteEmpty(card->volume)) {
X   pos = WriteLineToFile(datei,"VOLUME",card->volume);    
X } 
X if (!StringIsPeteEmpty(card->year)) {
X   pos = WriteLineToFile(datei,"YEAR",card->year);    
X } 
X if (!StringIsPeteEmpty(card->category)) {
X   pos = WriteLineToFile(datei,"CATEGORY",card->category);    
X } 
X h = card->ufield; 
X while (h) {
X   pos = WriteLineToFile(datei,h->fldName,h->fldData);    
X   h = h->next;
X }   
X fseek(datei, pos, SEEK_SET);
X fprintf(datei,"\n}\n\n");
}
X
X
X
static int StringIsPeteEmpty(char *text)
{
X if (text == NULL || *text == '\0') return 1;
X return 0;
}
X
X
X
yyerror(char *s)
{
X
X fputs(s, stderr);
X putc('\n', stderr);
}
X
#ifdef BIFMAIN
X
int main(int argc, char *argv[])
{
X Bib bp;
X int erg, b1, i;
X Errcode err;
X
#ifdef YYDEBUG
X       extern int yydebug;
X
X       yydebug = 1;
#endif
X
X strcpy(bp.filepath, argv[1]);
X dbtGetFreeTreeIdx(&b1);
X bp.treeIdx = b1;
X err = bifFileRead(&bp);
X err = bifFileWrite(&bp);
}
X
#endif
__YYSCLASS yytabelem yyexca[] ={
-1, 1,
X	0, -1,
X	-2, 0,
X	};
# define YYNPROD 161
# define YYLAST 554
__YYSCLASS yytabelem yyact[]={
X
X     8,     9,    11,    12,    13,    14,    15,    16,    17,    18,
X    19,    20,    21,    22,    23,    24,    39,   166,   135,   165,
X     4,   135,     4,   193,   175,     4,     8,     9,    11,    12,
X    13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
X    23,    24,    26,    36,   170,    38,   197,   158,     4,   171,
X     4,     4,     8,     9,    11,    12,    13,    14,    15,    16,
X    17,    18,    19,    20,    21,    22,    23,    24,   162,   153,
X   130,   155,   163,     4,   166,     4,   165,     4,    48,    49,
X    52,   179,    53,    54,    51,    50,    46,    45,    47,    48,
X    49,    52,    92,    53,    54,    51,    50,    46,    45,    47,
X   211,   213,   210,   204,   208,   209,   212,   128,   207,   205,
X   206,    48,    49,    52,   125,    53,    54,    51,    50,    46,
X    45,    47,    61,    62,    65,   112,    66,   108,    64,    63,
X    59,    58,    60,    61,    62,    65,   106,    66,   145,    64,
X    63,    59,    58,    60,   211,   213,   210,     4,   208,   209,
X   212,    97,   207,   205,   206,   188,   189,   187,   138,   185,
X   186,   181,    76,   184,   182,   183,    61,    62,    65,    75,
X    66,    74,    64,    63,    59,    58,    60,   188,   189,   187,
X   203,   185,   186,   228,   216,   184,   182,   183,     8,     9,
X    11,    12,    13,    14,    15,    16,    17,    18,    19,    20,
X    21,    22,    23,    24,    81,     8,     9,    11,    12,    13,
X    14,    15,    16,    17,    18,    19,    20,    21,    22,    23,
X    24,    43,     8,     9,    11,    12,    13,    14,    15,    16,
X    17,    18,    19,    20,    21,    22,    23,    24,   162,    77,
X    76,    78,   163,    33,   166,    35,   165,    75,     4,    74,
X     4,    30,   137,    32,   168,   148,   143,    68,     4,    69,
X     4,   196,     4,     4,    55,   180,    56,   192,   154,   129,
X   126,   124,   122,   109,    83,   120,   113,   159,    44,   164,
X    10,     2,   160,     7,    71,    27,    29,   134,     6,   133,
X    31,    34,    37,    73,     5,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,    40,     3,     0,
X     0,    25,    67,     0,     0,     0,     0,     1,    72,     0,
X    72,    28,   131,    79,    84,    85,    86,    87,    88,    89,
X    90,    91,    93,    94,    95,     0,    25,     0,     0,     0,
X     0,     0,     0,    41,    42,     0,     0,   110,     0,    25,
X     0,     0,     0,     0,     0,   115,     0,    80,     0,    72,
X    72,    82,   118,   119,     0,     0,   114,     0,   116,   117,
X     0,   123,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,   218,   219,   220,   221,
X   222,   223,   224,   225,   226,   132,   136,     0,     0,   121,
X     0,   140,   132,     0,     0,     0,     0,     0,     0,   229,
X     0,     0,     0,   142,     0,   146,   147,     0,     0,   132,
X   132,   152,   144,   149,     0,     0,    57,   157,     0,     0,
X   161,     0,   167,   169,     0,     0,   174,   173,     0,     0,
X   161,   178,   176,   139,   177,   190,   191,   144,   198,   199,
X   200,   201,   202,   194,   214,   215,     0,   161,     0,   195,
X   150,   151,    70,   144,     0,     0,     0,     0,   156,     0,
X   217,     0,     0,     0,     0,     0,     0,     0,   172,     0,
X     0,     0,   227,    96,     0,    98,    99,   100,   101,   102,
X   103,   104,   105,   107,     0,     0,   111,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,   127,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
X     0,     0,     0,   141 };
__YYSCLASS yytabelem yypact[]={
X
X  -205, -3000,   -35,  -231,  -260, -3000, -3000, -3000,   -24,   -32,
X  -232, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000,
X -3000, -3000, -3000, -3000, -3000,  -257,  -205,   -52, -3000, -3000,
X  -162,   -11,  -107,  -162,   -18,  -107,   -34,   -36,   -34,  -205,
X   -69, -3000, -3000,  -205,    -2,  -162,  -162,  -162,  -162,  -162,
X  -162,  -162,  -184,  -162,  -162,  -162,  -107,  -127,  -107,  -107,
X  -107,  -107,  -107,  -107,  -107,  -140,  -151,    -3,  -162,  -107,
X  -153,     3,  -112,  -260,  -112,  -112, -3000,   -34,   -34,     2,
X -3000,  -205, -3000, -3000, -3000, -3000, -3000, -3000, -3000, -3000,
X -3000,    -4,  -162, -3000, -3000,    -5,  -164, -3000, -3000, -3000,
X -3000, -3000, -3000, -3000, -3000,    -6,  -107,  -171, -3000, -3000,
X    -7,  -208, -3000,  -262,  -260, -3000, -3000, -3000,   -21,  -115,
X  -262, -3000,  -162, -3000, -3000, -3000,  -107, -3000, -3000, -3000,
X -3000,   -20,  -265,  -135,   -19,  -265, -3000,  -262,  -262,  -209,
X -3000, -3000,    -8, -3000,  -202,  -262, -3000,  -227,  -207, -3000,
X   -22,  -234,  -229, -3000, -3000,  -262, -3000,  -265,  -207,  -256,
X  -260,   -37,  -195,  -118, -3000,  -264,  -264,    -9, -3000,  -255,
X -3000, -3000, -3000,  -265,  -256,  -207, -3000,  -260,   -15, -3000,
X  -233, -3000,   -96,   -96,   -96,   -96,   -96,  -173,   -96,   -96,
X -3000, -3000, -3000, -3000,  -256, -3000, -3000, -3000, -3000, -3000,
X -3000, -3000, -3000,   -92,   -96,  -129,  -129,  -129,  -129,  -129,
X  -129,  -129,  -129,  -129, -3000, -3000,   -96, -3000, -3000, -3000,
X -3000, -3000, -3000,   -93, -3000, -3000, -3000, -3000,  -129, -3000 };
__YYSCLASS yytabelem yypgo[]={
X
X     0,   317,   281,   308,   294,   288,   283,   278,   426,   280,
X   284,   322,   293,   289,   287,   277,   282,   265,   279,   180 };
__YYSCLASS yytabelem yyr1[]={
X
X     0,     1,     1,     1,     1,     1,     1,     1,     1,     1,
X     1,     1,     1,     1,     3,     3,     3,     4,     4,     4,
X     4,     5,     5,     5,     5,     7,     7,     7,     7,     7,
X     7,     7,     7,     7,     7,     7,     7,     7,     7,     7,
X     7,     7,     7,     7,     7,     7,     7,     8,     8,     8,
X     8,     8,     8,     8,     8,     8,     8,     8,     8,     8,
X     8,     8,     8,     8,     8,     8,     8,     6,     6,     6,
X     6,     6,     6,     6,     6,     9,     9,     9,     9,     9,
X     9,     9,     9,     9,     9,     9,     9,     9,     9,    10,
X    10,    10,    10,    12,    12,    12,    12,    12,    11,    11,
X    11,    11,    11,    11,    11,    11,    11,    13,    13,    14,
X    14,     2,     2,    15,    15,    15,    15,    15,    16,    16,
X    16,    16,    16,    18,    18,    18,    18,    17,    17,    17,
X    17,    17,    17,    17,    17,    17,    17,    17,    17,    17,
X    17,    17,    17,    17,    19,    19,    19,    19,    19,    19,
X    19,    19,    19,    19,    19,    19,    19,    19,    19,    19,
X    19 };
__YYSCLASS yytabelem yyr2[]={
X
X     0,     8,     6,    10,     8,     6,     4,     6,     4,     8,
X     6,     4,     2,     2,     2,     2,     2,     9,    11,     9,
X    11,     9,    11,     9,    11,     4,     4,     4,     4,     4,
X     4,     4,     8,     6,     6,     4,     4,     4,     2,     2,
X     2,     2,     2,     2,     2,     2,     2,     4,     4,     4,
X     4,     4,     4,     4,     8,     6,     6,     4,     6,     4,
X     2,     2,     2,     2,     2,     2,     2,    15,    17,    13,
X    15,    15,    17,    13,    15,     3,     3,     3,     3,     3,
X     3,     3,     3,     3,     3,     3,     3,     3,     3,     4,
X     4,     6,     2,     5,     5,     3,     3,     3,     8,     6,
X     6,     8,     4,     6,     4,     2,     4,     9,     7,     5,
X     3,     4,     2,     6,     2,     4,     4,     6,     6,     6,
X     4,     4,     2,     4,     4,     2,     2,     4,     4,     4,
X     4,     4,     6,     8,     4,     6,     2,     2,     4,     4,
X     2,     2,     2,     2,     4,     4,     4,     4,     4,     6,
X     8,     2,     2,     4,     4,     4,     2,     2,     2,     2,
X     2 };
__YYSCLASS yytabelem yychk[]={
X
X -3000,    -1,    -2,    -3,   282,    -4,    -5,    -6,   257,   258,
X    -9,   259,   260,   261,   262,   263,   264,   265,   266,   267,
X   268,   269,   270,   271,   272,    -3,   273,    -2,    -1,    -2,
X   275,    -2,   277,   275,    -2,   277,   275,    -2,   277,   273,
X    -2,    -1,    -1,   273,    -7,   282,   281,   283,   273,   274,
X   280,   279,   275,   277,   278,   275,   277,    -8,   282,   281,
X   283,   273,   274,   280,   279,   275,   277,    -7,   275,   277,
X    -8,   -10,    -2,   -12,   283,   281,   274,   275,   277,   -10,
X    -1,   273,    -1,   276,    -7,    -7,    -7,    -7,    -7,    -7,
X    -7,    -7,   276,    -7,    -7,    -7,    -8,   278,    -8,    -8,
X    -8,    -8,    -8,    -8,    -8,    -8,   276,    -8,   278,   276,
X    -7,    -8,   278,   273,   -12,    -2,   -12,   -12,   -10,   -10,
X   273,    -1,   276,    -7,   276,   278,   276,    -8,   278,   276,
X   278,   -11,    -2,   -13,   -14,   283,    -2,   273,   273,   -11,
X    -7,    -8,    -2,   276,   -13,   273,    -2,    -2,   274,   -14,
X   -11,   -11,    -2,   278,   276,   273,   -11,    -2,   274,   -15,
X   -16,    -2,   275,   279,   -18,   283,   281,    -2,   276,    -2,
X   278,   278,   -11,    -2,   -15,   280,    -2,   -16,    -7,   276,
X   -17,   279,   282,   283,   281,   277,   278,   275,   273,   274,
X   -18,   -18,   276,   278,   -15,    -2,   276,   279,   -17,   -17,
X   -17,   -17,   -17,   -19,   276,   282,   283,   281,   277,   278,
X   275,   273,   279,   274,   -17,   -17,   276,   -17,   -19,   -19,
X   -19,   -19,   -19,   -19,   -19,   -19,   -19,   -17,   276,   -19 };
__YYSCLASS yytabelem yydef[]={
X
X     0,    -2,    13,    12,   112,    14,    15,    16,     0,     0,
X     0,    75,    76,    77,    78,    79,    80,    81,    82,    83,
X    84,    85,    86,    87,    88,    11,     8,    13,     6,   111,
X     0,     0,     0,     0,     0,     0,     0,     0,     0,     7,
X    13,     5,     2,    10,     0,    38,    39,    40,    41,    42,
X    43,    44,     0,    45,    46,     0,     0,     0,    60,    61,
X    62,    63,    64,    65,    66,     0,     0,     0,     0,     0,
X     0,     0,     0,    92,    95,    96,    97,     0,     0,     0,
X     1,     9,     4,    17,    25,    26,    27,    28,    29,    30,
X    31,     0,    35,    36,    37,     0,     0,    19,    47,    48,
X    49,    50,    51,    52,    53,     0,    57,     0,    59,    21,
X     0,     0,    23,     0,    89,    90,    93,    94,     0,     0,
X     0,     3,    34,    33,    18,    20,    56,    55,    58,    22,
X    24,     0,     0,   105,     0,   110,    91,     0,     0,     0,
X    32,    54,     0,    69,   104,   102,   106,     0,     0,   109,
X     0,     0,     0,    73,    67,   100,    99,   103,     0,   108,
X   114,     0,     0,     0,   122,   125,   126,     0,    70,     0,
X    74,    71,    98,   101,   107,     0,   115,   116,     0,   121,
X     0,   120,   136,   137,   140,   141,   142,     0,   143,     0,
X   123,   124,    68,    72,   113,   117,   118,   119,   127,   128,
X   129,   130,   131,     0,   134,   151,   152,   156,   157,   158,
X     0,   159,   160,     0,   138,   139,   132,   135,   144,   145,
X   146,   147,   148,     0,   153,   154,   155,   133,   149,   150 };
typedef struct { char *t_name; int t_val; } yytoktype;
#ifndef YYDEBUG
#	define YYDEBUG	0	/* don't allow debugging */
#endif
X
#if YYDEBUG
X
__YYSCLASS yytoktype yytoks[] =
{
X	"STRING",	257,
X	"PREAMBLE",	258,
X	"ARTICLE",	259,
X	"BOOK",	260,
X	"BOOKLET",	261,
X	"CONFERENCE",	262,
X	"INBOOK",	263,
X	"INCOLLECTION",	264,
X	"INPROCEEDINGS",	265,
X	"MANUAL",	266,
X	"MASTERSTHESIS",	267,
X	"MISC",	268,
X	"PHDTHESIS",	269,
X	"PROCEEDINGS",	270,
X	"TECHREPORT",	271,
X	"UNPUBLISHED",	272,
X	"KOMMA",	273,
X	"EQ",	274,
X	"LGKL",	275,
X	"RGKL",	276,
X	"LRKL",	277,
X	"RRKL",	278,
X	"DAZ",	279,
X	"ZAUN",	280,
X	"ZEICHEN",	281,
X	"WHITE_SPACE",	282,
X	"BUCHSTABE_ZAHL",	283,
X	"-unknown-",	-1	/* ends search */
};
X
__YYSCLASS char * yyreds[] =
{
X	"-no such reduction-",
X	"datei : leerraum entry KOMMA datei",
X	"datei : entry KOMMA datei",
X	"datei : leerraum entry leerraum KOMMA datei",
X	"datei : entry leerraum KOMMA datei",
X	"datei : leerraum entry datei",
X	"datei : entry datei",
X	"datei : leerraum entry KOMMA",
X	"datei : entry KOMMA",
X	"datei : leerraum entry leerraum KOMMA",
X	"datei : entry leerraum KOMMA",
X	"datei : leerraum entry",
X	"datei : entry",
X	"datei : leerraum",
X	"entry : string",
X	"entry : preamble",
X	"entry : eintrag",
X	"string : STRING LGKL allstringG RGKL",
X	"string : STRING leerraum LGKL allstringG RGKL",
X	"string : STRING LRKL allstringR RRKL",
X	"string : STRING leerraum LRKL allstringR RRKL",
X	"preamble : PREAMBLE LGKL allstringG RGKL",
X	"preamble : PREAMBLE leerraum LGKL allstringG RGKL",
X	"preamble : PREAMBLE LRKL allstringR RRKL",
X	"preamble : PREAMBLE leerraum LRKL allstringR RRKL",
X	"allstringG : WHITE_SPACE allstringG",
X	"allstringG : ZEICHEN allstringG",
X	"allstringG : BUCHSTABE_ZAHL allstringG",
X	"allstringG : KOMMA allstringG",
X	"allstringG : EQ allstringG",
X	"allstringG : ZAUN allstringG",
X	"allstringG : DAZ allstringG",
X	"allstringG : LGKL allstringG RGKL allstringG",
X	"allstringG : LGKL RGKL allstringG",
X	"allstringG : LGKL allstringG RGKL",
X	"allstringG : LGKL RGKL",
X	"allstringG : LRKL allstringG",
X	"allstringG : RRKL allstringG",
X	"allstringG : WHITE_SPACE",
X	"allstringG : ZEICHEN",
X	"allstringG : BUCHSTABE_ZAHL",
X	"allstringG : KOMMA",
X	"allstringG : EQ",
X	"allstringG : ZAUN",
X	"allstringG : DAZ",
X	"allstringG : LRKL",
X	"allstringG : RRKL",
X	"allstringR : WHITE_SPACE allstringR",
X	"allstringR : ZEICHEN allstringR",
X	"allstringR : BUCHSTABE_ZAHL allstringR",
X	"allstringR : KOMMA allstringR",
X	"allstringR : EQ allstringR",
X	"allstringR : ZAUN allstringR",
X	"allstringR : DAZ allstringR",
X	"allstringR : LGKL allstringR RGKL allstringR",
X	"allstringR : LGKL RGKL allstringR",
X	"allstringR : LGKL allstringR RGKL",
X	"allstringR : LGKL RGKL",
X	"allstringR : LRKL allstringR RRKL",
X	"allstringR : LRKL RRKL",
X	"allstringR : WHITE_SPACE",
SHAR_EOF
true || echo 'restore of bib_file.c failed'
fi
echo 'End of  part 3'
echo 'File bib_file.c is continued in part 4'
echo 4 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
