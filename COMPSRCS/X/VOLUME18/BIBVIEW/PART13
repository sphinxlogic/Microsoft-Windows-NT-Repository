Path: uunet!decwrl!elroy.jpl.nasa.gov!swrinde!mips!msi!dcmartin
From: liebla@informatik.tu-muenchen.de (Armin Liebl)
Newsgroups: comp.sources.x
Subject: v18i111: bibview - BibTeX GUI, Part13/20
Message-ID: <1992Aug27.161713.25846@msi.com>
Date: 27 Aug 92 16:17:13 GMT
References: <csx-18i099-bibview@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1749
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: Armin Liebl <liebla@informatik.tu-muenchen.de>
Posting-number: Volume 18, Issue 111
Archive-name: bibview/part13

#!/bin/sh
# this is part.13 (part 13 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file fb_res.h continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 13; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping fb_res.h'
else
echo 'x - continuing file fb_res.h'
sed 's/^X//' << 'SHAR_EOF' >> 'fb_res.h' &&
"BibView*helpMenu*item4*label:		List Window",
"BibView*helpMenu*item5*label:		Card Window",
"BibView*helpMenu*item6*label:		Other Windows",
"BibView*helpMenu*info*label:		Program Info",
"BibView*bibWin.orientation:		vertical",
"BibView*bibWin.width:			450",
"BibView*bibWin.height:			350",
"BibView*bibWin*showGrip:		false",
"BibView*bibWin*commandBox.width: 	450",
"BibView*bibWin*commandBox.vSpace: 	0",
"BibView*bibWin*commandBox.hSpace: 	0",
"BibView*bibWin*commandBox.min: 		21",
"BibView*bibWin*commandBox*new.label:	New",
"BibView*bibWin*new.menuName:		newMenu",
"BibView*bibWin*newMenu.label:		New Menu",
"BibView*bibWin*newMenu*item2*label:	Book",
"BibView*bibWin*newMenu*item3*label:	Booklet",
"BibView*bibWin*newMenu*item5*label:	Inbook",
"BibView*bibWin*newMenu*item6*label:	Incollection",
"BibView*bibWin*newMenu*item1*label:	Article",
"BibView*bibWin*newMenu*item4*label:	Conference",
"BibView*bibWin*newMenu*item12*label:	Proceedings",
"BibView*bibWin*newMenu*item7*label:	Inproceedings",
"BibView*bibWin*newMenu*item13*label:	Techreport",
"BibView*bibWin*newMenu*item9*label:	Mastersthesis",
"BibView*bibWin*newMenu*item11*label:	Phdthesis",
"BibView*bibWin*newMenu*item8*label:	Manual",
"BibView*bibWin*newMenu*item14*label:	Unpublished",
"BibView*bibWin*newMenu*item10*label:	Misc",
"BibView*bibWin*commandBox*search.label:	Search",
"BibView*bibWin*commandBox*list.label:	List",
"BibView*bibWin*commandBox*macro.label:	Macros",
"BibView*bibWin*commandBox*print.label:	Print",
"BibView*bibWin*commandBox*save.label:	Save",
"BibView*bibWin*commandBox*close.label:	Close",
"BibView*bibWin*window.label:		Window",
"BibView*bibWin*window.menuName:		windowMenu",
"BibView*bibWin*window*leftMargin: 	20",
"BibView*bibWin*windowMenu.label:	Window-Menu",
"BibView*bibWin*windowMenu*item1.label:	Cascade",
"BibView*bibWin.bibdesk.label:",
"BibView*bibWin.bibdesk.width:   	450",
"BibView*bibWin.bibdesk.height:    	350",
"BibView*bibWin.bibdesk.min:    		350	",
"BibView*bibWin.bibdesk.fromVert:  	commandBox",
"BibView*listWin*allowShellResize:	true",
"BibView*listWin*allowResize:		true",
"BibView*listWin*foreground:			Maroon",
"BibView*listWin.height:			650",
"BibView*listWin.width:			530",
"BibView*listWin.horizDistance:		235",
"BibView*listWin.vertDistance:		20",
"BibView*listWin.borderWidth:		2",
"BibView*listWin.orientation:		vertical",
"BibView*listWin*showGrip:		false",
"BibView*listWin.commandBox.vSpace: 	0",
"BibView*listWin.commandBox.hSpace: 	0",
"BibView*listWin.commandBox.min: 	21",
"BibView*listWin.commandBox*print.label:	Print",
"BibView*listWin.commandBox*save.label:	Save",
"BibView*listWin.commandBox*quit.label:	Close",
"BibView*listWin*listVport.fromVert:	commandBox",
"BibView*listWin*listVport*font: 	*fixed-bold-r-*-100-*",
"BibView*listWin*head1.label:		Author",
"BibView*listWin*head1.width:		200",
"BibView*listWin*head2.label:		Title",
"BibView*listWin*head2.width:		390",
"BibView*listWin*head3.label:		Type",
"BibView*listWin*head3.width:		85",
"BibView*listWin*head4.label:		Year",
"BibView*listWin*head4.width:		30",
"BibView*listWin*list.verticalList:	true",
"BibView*listWin*list.forceColumns:	true",
"BibView*listWin*list.defaultColumns:	1",
"BibView*macWin*allowResize:		true",
"BibView*macWin.height:			300",
"BibView*macWin.width:			450",
"BibView*macWin.borderWidth:		2",
"BibView*macWin.orientation:		vertical",
"BibView*macWin*showGrip:		false",
"BibView*macWin.commandBox.vSpace: 	0",
"BibView*macWin.commandBox.hSpace: 	0",
"BibView*macWin.commandBox.min: 	21",
"BibView*macWin.commandBox*save.label:	Save",
"BibView*macWin.commandBox*close.label:	Close",
"BibView*macText.fromVert:		commandBox",
"BibView*macText*font: 			*fixed-bold-r-*-100-*",
"BibView*macText*textSource.editType:	edit",
"BibView*macText*input: 			true",
"BibView*helpWin*allowResize:		true",
"BibView*helpWin.height:			300",
"BibView*helpWin.width:			500",
"BibView*helpWin.borderWidth:		2",
"BibView*helpWin.orientation:		vertical",
"BibView*helpWin*showGrip:		false",
"BibView*helpWin.commandBox.vSpace: 	0",
"BibView*helpWin.commandBox.hSpace: 	0",
"BibView*helpWin.commandBox.min: 	21",
"BibView*helpWin.commandBox*close.label:	Close",
"BibView*helpText.fromVert:		commandBox",
"BibView*helpText*font: 			*fixed-bold-r-*-100-*",
"BibView*helpText*input: 			true",
"BibView*annoteWin*allowResize:		true",
"BibView*annoteWin.height:		300",
"BibView*annoteWin.width:		500",
"BibView*annoteWin.borderWidth:		2",
"BibView*annoteWin.orientation:		vertical",
"BibView*annoteWin*showGrip:		false",
"BibView*annoteWin.commandBox.vSpace: 	0",
"BibView*annoteWin.commandBox.hSpace: 	0",
"BibView*annoteWin.commandBox.min: 	21",
"BibView*annoteWin.commandBox*close.label:	Close",
"BibView*annoteWin.commandBox*save.label:	Save",
"BibView*annoteText.fromVert:		commandBox",
"BibView*annoteText*font: 			*fixed-bold-r-*-100-*",
"BibView*annoteText*input: 			true",
"BibView*srchShell.title:		Search",
"BibView*srchWin.height:			400",
"BibView*srchWin.width:			380",
"BibView*srchWin.borderWidth:		2",
"BibView*srchWin.orientation:		vertical",
"BibView*srchWin*showGrip:		false",
"BibView*srchWin.commandBox.vSpace: 	0",
"BibView*srchWin.commandBox.hSpace: 	0",
"BibView*srchWin.commandBox.min: 	21",
"BibView*srchWin.commandBox*ok.label:	Start search",
"BibView*srchWin.commandBox*cancel.label:Cancel",
"BibView*srchWin*srchFlds*borderwidth:	0",
"BibView*srchWin*srchFlds*vSpace:	0",
"BibView*srchWin*srchFlds*font: 		*helvetica-bold-r-*-100-*",
"BibView*srchWin*ComboBox.borderWidth:	0",
"BibView*srchWin*ComboBox.margin:	4",
"BibView*srchWin*ComboBox*Text.width:	250",
"BibView*srchWin*ComboBox*Toggle.width:	100",
"BibView*srchWin*ComboBox*Toggle.justify:left",
"BibView*srchWin*ComboBox*Viewport.borderWidth:	4",
"BibView*srchWin*ComboBox*Viewport.width:	300",
"BibView*srchWin*ComboBox*Viewport.height:	100",
"BibView*srchWin*cbTitle*name:		Title:",
"BibView*srchWin*cbAuthor*name:		Author:",
"BibView*srchWin*cbCategory*name:	Category:",
"BibView*srchWin*cbMonth*name:		Month:",
"BibView*srchWin*cbYear*name:		Year:",
"BibView*srchWin*cbNote*name:		Note:",
"BibView*srchWin*cbAnnote*name:		Annote:",
"BibView*srchWin*cbJournal*name:		Journal:",
"BibView*srchWin*cbEditor*name:		Editor:",
"BibView*srchWin*cbOrganization*name:	Organization:",
"BibView*srchWin*cbInstitution*name:	Institution:",
"BibView*srchWin*cbPublisher*name:	Publisher:",
"BibView*srchWin*cbSchool*name:		School:",
"BibView*srchWin*cbAddress*name:		Address:",
"BibView*srchWin*cbEdition*name:		Edition:",
"BibView*srchWin*cbChapter*name:		Chapter:",
"BibView*srchWin*cbSeries*name:		Series:",
"BibView*srchWin*cbPages*name:		Pages:",
"BibView*srchWin*cbVolume*name:		Volume:",
"BibView*srchWin*cbNumber*name:		Number:",
"BibView*srchWin*cbBooktitle*name:	Booktitle:",
"BibView*srchWin*cbHowpublished*name:	Howpublished:",
"BibView*srchWin*cbType*name:		Type:",
"BibView*srchWin*cbKey*name:		Key:",
"BibView*srchWin*cbMainkey*name:		bibTeX-Key:",
"BibView*srchWin*cbCrossref*name:	Crossref:",
"BibView*cardShell.allowShellResize:	true",
"BibView*cardWin*Text*scrollHorizontal:	whenNeeded",
"BibView*cardWin*Text*scrollVertical:	whenNeeded",
"BibView*cardWin*Text*thickness:		8",
"BibView*cardWin*Text.height:		28",
"BibView*cardWin*Text*textSource.editType:	edit",
"BibView*cardWin*Text*input: 		true",
"BibView*cardWin*Label*justify:		left",
"BibView*cardWin.foreground:			Violet",
"BibView*cardWin.width:			450",
"BibView*cardWin.borderWidth:		2",
"BibView*cardWin.commandBox.showGrip:	false",
"BibView*cardWin.commandBox.width: 	400",
"BibView*cardWin.commandBox.vSpace: 	0",
"BibView*cardWin.commandBox.hSpace: 	0",
"BibView*cardWin.commandBox.min: 	21",
"BibView*cardWin.commandBox.skipAdjust: 	true",
"BibView*cardWin.commandBox*userDef.label:	UserData",
"BibView*cardWin.commandBox*annote.label:	Annote",
"BibView*cardWin.commandBox*save.label:		Save",
"BibView*cardWin.commandBox*change.label:	Change",
"BibView*cardWin.commandBox*delete.label:	Delete",
"BibView*cardWin.commandBox*copy.label:		Copy",
"BibView*cardWin.commandBox*quit.label:		Close",
"BibView*cardWin.userFldVport*font: 	*helvetica-bold-r-*-100-*",
"BibView*cardWin.userFldVport.allowResize: true",
"BibView*cardWin.userFldVport.min:	100",
"BibView*cardWin.userFldVport.max:	150",
"BibView*cardWin*userFieldL.width:	150",
"BibView*cardWin*userField.width:	225",
"BibView*cardWin*userFldHead.label:	Userdefined Fields",
"BibView*cardWin*userFldHead.width:	380",
"BibView*cardWin*userFldHead.borderWidth:	2",
"BibView*cardWin*userFldHead.justify:	center",
"BibView*cardWin.carddesk*font: 		*helvetica-bold-r-*-100-*",
"BibView*cardWin.carddesk*Label*borderWidth:	0",
"BibView*cardWin.carddesk.defaultDistance:	0",
"BibView*cardWin.carddesk*mainkeyLabel.label:	BibTeX-Key:",
"BibView*cardWin.carddesk*mainkey.width:	        110",
"BibView*cardWin.carddesk*crossrefLabel.label:	Crossref:",
"BibView*cardWin.carddesk*crossref.width:     	148",
"BibView*cardWin.carddesk*addressLabel.label:	Address:",
"BibView*cardWin.carddesk*address.width:	        300",
"BibView*cardWin.carddesk*address.height:        40",
"BibView*cardWin.carddesk*annoteLabel.label:	Annote:",
"BibView*cardWin.carddesk*annote.width:		325",
"BibView*cardWin.carddesk*annote.height:		60",
"BibView*cardWin.carddesk*authorLabel.label:	Author:",
"BibView*cardWin.carddesk*author.width:		355",
"BibView*cardWin.carddesk*author.height:		30",
"BibView*cardWin.carddesk*booktitleLabel.label:	Booktitle:",
"BibView*cardWin.carddesk*booktitle.width:	340",
"BibView*cardWin.carddesk*categoryLabel.label:	Category:",
"BibView*cardWin.carddesk*category.width:	133",
"BibView*cardWin.carddesk*chapterLabel.label:	Chapter:",
"BibView*cardWin.carddesk*chapter.width:		350",
"BibView*cardWin.carddesk*editionLabel.label:	Edition:",
"BibView*cardWin.carddesk*editorLabel.label:	Editor:",
"BibView*cardWin.carddesk*editor.width:		320",
"BibView*cardWin.carddesk*editor.height:		30",
"BibView*cardWin.carddesk*howpublishedLabel.label:	Howpublished:",
"BibView*cardWin.carddesk*howpublished.width:	275",
"BibView*cardWin.carddesk*institutionLabel.label:	Institution:",
"BibView*cardWin.carddesk*institutionLabel.width:	60",
"BibView*cardWin.carddesk*institution.width:	334",
"BibView*cardWin.carddesk*journalLabel.label:	Journal:",
"BibView*cardWin.carddesk*journal.width:		345",
"BibView*cardWin.carddesk*keyLabel.label:	Key:",
"BibView*cardWin.carddesk*monthLabel.label:	Month:",
"BibView*cardWin.carddesk*month.width:		210",
"BibView*cardWin.carddesk*noteLabel.label:	Note:",
"BibView*cardWin.carddesk*note.width:		345",
"BibView*cardWin.carddesk*note.height:		60",
"BibView*cardWin.carddesk*numberLabel.label:	Number:",
"BibView*cardWin.carddesk*number.width:		145",
"BibView*cardWin.carddesk*organizationLabel.label:	Organization:",
"BibView*cardWin.carddesk*organization.width:	317",
"BibView*cardWin.carddesk*pagesLabel.label:	Pages:",
"BibView*cardWin.carddesk*pages.width:		80",
"BibView*cardWin.carddesk*publisherLabel.label:	Publisher:",
"BibView*cardWin.carddesk*publisher.width:	350",
"BibView*cardWin.carddesk*publisher.height:	30",
"BibView*cardWin.carddesk*schoolLabel.label:	School:",
"BibView*cardWin.carddesk*school.width:  	315",
"BibView*cardWin.carddesk*seriesLabel.label:	Series:",
"BibView*cardWin.carddesk*series.width:  	335",
"BibView*cardWin.carddesk*titleLabel.label:	Title:",
"BibView*cardWin.carddesk*title.width:		360",
"BibView*cardWin.carddesk*title.height:		40",
"BibView*cardWin.carddesk*typeLabel.label:	Type:",
"BibView*cardWin.carddesk*type.width:		365",
"BibView*cardWin.carddesk*volumeLabel.label:	Volume:",
"BibView*cardWin.carddesk*volume.width:		115",
"BibView*cardWin.carddesk*yearLabel.label:	Year:",
"BibView*cardWin*article.borderWidth:		0",
"BibView*cardWin*book.borderWidth:		0",
"BibView*cardWin*booklet.borderWidth:		0",
"BibView*cardWin*conference.borderWidth:		0",
"BibView*cardWin*inbook.borderWidth:		0",
"BibView*cardWin*incollection.borderWidth:	0",
"BibView*cardWin*inproceedings.borderWidth:	0",
"BibView*cardWin*manual.borderWidth:		0",
"BibView*cardWin*mastersthesis.borderWidth:	0",
"BibView*cardWin*misc.borderWidth:		0",
"BibView*cardWin*phdthesis.borderWidth:		0",
"BibView*cardWin*proceedings.borderWidth:	0",
"BibView*cardWin*techreport.borderWidth:		0",
"BibView*cardWin*unpublished.borderWidth:	0",
"BibView*confirmLoadShell.title:		Load?",
"BibView*confirmLoadBox.label:		File is loaded.\\nTake saved version?",
"BibView*confirmLoadBox*ok.label:	OK",
"BibView*confirmLoadBox*cancel.label:	Cancel",
"BibView*confirmBibQuitShell.title:	Close Bibliography?",
"BibView*confirmBibQuitBox.label:	There are unsaved changes!\\nDo you really want to quit?",
"BibView*confirmBibQuitBox*ok.label:	Quit",
"BibView*confirmBibQuitBox*cancel.label:	Save",
"BibView*confirmQuitCardShell.title:	Close Card?",
"BibView*confirmQuitCardBox.label:	REALLY close without saving?",
"BibView*confirmQuitCardBox*ok.label:	Close",
"BibView*confirmQuitCardBox*cancel.label:	First Save",
"BibView*confirmMacQuitShell.title:	Close Macros?",
"BibView*confirmMacQuitBox.label:	Macros were changed!\\nSave macros or quit?",
"BibView*confirmMacQuitBox*save.label:	Save",
"BibView*confirmMacQuitBox*quit.label:	Quit",
"BibView*fileSelectBoxShell.title:	BibView Filemanager",
"BibView*fileSelectBoxShell.iconName:	BibView Filemanager",
"BibView*fileLoadHead.label:		Choose bibTeX-file:",
"BibView*fileRenameHead.label:		Rename bibTeX-file:",
"BibView*filePrintHead.label:		LaTeX file:",
"BibView*configLoadHead.label:		Configuration file:",
"BibView*fileListSaveHead.label:		Save list as bibTeX-file:",
"BibView*bibselShell.title:		BibView-file-Selection",
"BibView*bibselWin*closeHead.label:	Close",
"BibView*bibselWin*saveHead.label:	Save",
"BibView*bibselWin*saveAsHead.label:	Save as",
"BibView*bibselWin*copyHead.label:	Copy to",
"BibView*bibselWin*collSrcHead.label:	Take entries from",
"BibView*bibselWin*collDestHead.label:	Insert into",
"BibView*bibselWin*checkHead.label:	Check",
"BibView*bibselWin*printHead.label:	Print",
"BibView*bibselWin*macroHead.label:	Edit Macros",
"BibView*bibselWin*cancel.label:		Cancel",
"BibView*errorShell.title:	BibView Message",
"BibView*errorWin*type.label:	ERROR:",
"BibView*errorWin*type.foreground: red",
"BibView*errorWin*ok.label:	OK",
"BibView*errorIcon*foreground:	red",
"BibView*warnShell.title:	BibView Message",
"BibView*warnWin*type.label:	WARNING:",
"BibView*warnWin*type.foreground:	red",
"BibView*warnWin*ok.label:	OK",
"BibView*warnIcon*foreground:	red",
"BibView*noticeShell.title:	BibView Message",
"BibView*noticeWin*type.label:	HINT:",
"BibView*noticeWin*type.foreground: blue",
"BibView*noticeWin*ok.label:	OK",
"BibView*noticeIcon*foreground:	blue",
"BibView*msgText10.label:  Not yet implemented.",
"BibView*msgText11.label:  No storage!",
"BibView*msgText12.label:  No BibTeX file!",
"BibView*msgText14.label:  No BibTeX file opened.",
"BibView*msgText15.label:  File cannot be unified!.",
"BibView*msgText16.label:  Card cannot be copied.",
"BibView*msgText30.label:  Windows can't be cascaded!",
"BibView*msgText50.label:  File can't be opened!",
"BibView*msgText51.label:  No Configuration file.",
"BibView*msgText52.label:  Temporary file can't be opened!",
"BibView*msgText53.label:  Macros can't be saved!",
"BibView*msgText54.label:  Please close Error-Window!",
"BibView*msgText60.label:  There are inconsistencies.\\nThe cards are shown in List.",
"BibView*msgText61.label:  No inconsistencies.",
"BibView*msgText62.label:  There are syntactic problems.\\n Please correct error and load again.",
"BibView*msgText63.label:  Some required fields are not entered.\\nThe entry was saved.",
"BibView*msgText100.label: Double Keys are not allowed.\\nCard in Tree.",
"BibView*msgText101.label: No regular expression.",
"BibView*msgText102.label: No entries found in file.",
"BibView*msgText104.label: Card incomplete: no Author.",
"BibView*msgText105.label: Card incomplete: no Title.",
"BibView*msgText106.label: Card incomplete: no Journal.",
"BibView*msgText107.label: Card incomplete: no Year.",
"BibView*msgText108.label: Card incomplete: no Publisher.",
"BibView*msgText109.label: Card incomplete: no Booktitle.",
"BibView*msgText110.label: Card incomplete: no Chapter.",
"BibView*msgText111.label: Card incomplete: no School.",
"BibView*msgText112.label: Card incomplete: no Institution.",
"BibView*msgText113.label: Card incomplete: no Notice.",
"BibView*msgText114.label: Card incomplete: no Author or Editor.",
"BibView*msgText115.label: Card incomplete: no Chapter and/or Page.",
"BibView*msgText120.label: No further Files loadable.\\nPlease close bibliography.",
"BibView*msgText121.label: Internal Bug: Nr. 121",
"BibView*quit*accelerators:\
X	<Key>q: notify()",
"BibView*mainwin*services*accelerators:\
X	<Key>i: notify()",
"BibView*mainwin*options*accelerators:\
X	<Key>o: notify()",
"BibView*mainwin*window*accelerators:\
X	<Key>f: notify()",
"BibView*mainwin*help*accelerators:\
X	<Key>h: notify()",
SHAR_EOF
echo 'File fb_res.h is complete' &&
chmod 0644 fb_res.h ||
echo 'restore of fb_res.h failed'
Wc_c="`wc -c < 'fb_res.h'`"
test 19496 -eq "$Wc_c" ||
	echo 'fb_res.h: original size 19496, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= flexsrc/b.l ==============
if test ! -d 'flexsrc'; then
    echo 'x - creating directory flexsrc'
    mkdir 'flexsrc'
fi
if test -f 'flexsrc/b.l' -a X"$1" != X"-c"; then
	echo 'x - skipping flexsrc/b.l (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting flexsrc/b.l (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'flexsrc/b.l' &&
%{
#include "b.tab.h"
#include <X11/Intrinsic.h>
#include "bibview.h"
X
extern char yylval;
extern int ueIdx;
extern char uebergabe[];
extern int yynline;
extern int yynflexcalls;
X
X
%}
X
X
%%
X
X
"@string"  {
X            yynflexcalls += 1;
X	    return STRING; 
X           }
X
"@preamble"  {
X              yynflexcalls += 1;
X              return PREAMBLE; 
X             }
X
X
"@article"        {
X                   yynflexcalls += 1;
X                   return ARTICLE;
X                  }
X
"@book"          {
X                   yynflexcalls += 1;
X                   return BOOK;
X                  }
X
"@booklet"        {
X                   yynflexcalls += 1;
X                   return BOOKLET;
X                  }
X
"@conference"     {
X                   yynflexcalls += 1;
X                   return CONFERENCE;
X                  }
X
"@inbook"         {
X                   yynflexcalls += 1;
X                   return INBOOK;
X                  }
X
"@incollection"   {
X                   yynflexcalls += 1;
X                   return INCOLLECTION;
X                  }
X
"@inproceedings"  {
X                   yynflexcalls += 1;
X                   return INPROCEEDINGS;
X                  }
X
"@manual"         {
X                   yynflexcalls += 1;
X                   return MANUAL;
X                  }
X
"@mastersthesis"  {
X                   yynflexcalls += 1;
X                   return MASTERSTHESIS;
X                  }
X
"@misc"           {
X                   yynflexcalls += 1;
X                   return MISC;
X                  }
X
"@phdthesis"      {
X                   yynflexcalls += 1;
X                   return PHDTHESIS;
X                  }
X
"@proceedings"    {
X                   yynflexcalls += 1;
X                   return PROCEEDINGS;
X                  }
X
"@techreport"     {
X                   yynflexcalls += 1;
X                   return TECHREPORT;
X                  }
X
"@unpublished"    {
X                   yynflexcalls += 1;
X                   return UNPUBLISHED;
X                  }
X
"#"        {
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return ZAUN;
X           }
X
X
","        {
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return KOMMA;
X           }
X
"("        {
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return LRKL;
X           }
X
")"        {
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return RRKL;
X           }
X
"{"        {
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return LGKL;
X           }
X
"}"        {
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return RGKL;
X           }
X
"="        {
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return EQ;
X           }
X
[\"]        {
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return DAZ;
X           }
X
[ \t\n]    {
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             if (yytext[0] == '\n') yynline += 1;
X             return WHITE_SPACE;
X           }
X
[a-zA-Z0-9]  {
X               yynflexcalls += 1;
X               yylval = yytext[0];
X               uebergabe[ueIdx] = yytext[0];
X               uebergabe[ueIdx+1] = '\0';
X               ueIdx++;
X               return BUCHSTABE_ZAHL;
X             }
X
<<EOF>>  {
X           yynflexcalls += 1;
X           YY_NEW_FILE;
X  /*         uebergabe[0] = '\0'; */
X           ueIdx = 0;
X           return 0;
X         }
X
.          {
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return ZEICHEN;
X           }
X
X
%%
X
SHAR_EOF
chmod 0640 flexsrc/b.l ||
echo 'restore of flexsrc/b.l failed'
Wc_c="`wc -c < 'flexsrc/b.l'`"
test 4688 -eq "$Wc_c" ||
	echo 'flexsrc/b.l: original size 4688, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= flexsrc/b.y ==============
if test -f 'flexsrc/b.y' -a X"$1" != X"-c"; then
	echo 'x - skipping flexsrc/b.y (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting flexsrc/b.y (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'flexsrc/b.y' &&
%{
#include <stdio.h>
#include <ctype.h>
#include <X11/Intrinsic.h>
#include <unistd.h>
#include "bibview.h"
X
X
#define YYSTYPE char
X
#define __RUNTIME_YYMAXDEPTH
#define YYMAXDEPTH 1000
X
#define MAX_UEBERGABE  20000
X
char uebergabe[MAX_UEBERGABE];
int ueIdx = 0;
X
FILE *tempDatei;
extern FILE *yyin;
extern YY_NEW_FILE;
extern int yy_init;
X
typedef struct _Snode {
X                       char inh;
X                       int slen;
X                       struct _Snode *next;
} Snode;
X
/*******************************************/
/* Globale Variablen                       */
/*******************************************/
X
static Snode *key = NULL;            
static Snode *fldname = NULL;       
static Snode *fldcont = NULL;      
X
static CardData *card = NULL;
static UserFld *helpufield = NULL;
static String helpFldName = NULL;
static Errcode err;
static int glbtreeIdx;
static int beginIdx;
int yynline;
int yynflexcalls;
int yynerrs;
/*******************************************/
/* Lokale Funktionen                       */
/*******************************************/
X
static void PushSign(Snode **w, char a);
static void AppendSign(Snode **w, char a);
static void FreeStack(Snode **s);
static void StackToString(Snode *s, char **text); 
static void GetKey();
static void GetFldNameCont();
X
static Errcode Scalloc(String *s1, String s2);
static char * Sncalloc(char *s2, int von, int bis);
static int SetInputFile(char *file);
static int SkipSpace(char *text, Snode **new);
static int SkipNewLineSpace(char *text);
static void StrToLower(char *text);
static int StringIsPeteEmpty(char *text);
static void WriteRecToFile(CardData *card, FILE *datei);
static long WriteLineToFile(FILE *datei, char *feld, char *inh);
static int ItIsBibFile(char *dateiName);
%}
%token  STRING
%token  PREAMBLE
%token  ARTICLE
%token  BOOK
%token  BOOKLET
%token  CONFERENCE
%token  INBOOK
%token  INCOLLECTION
%token  INPROCEEDINGS
%token  MANUAL
%token  MASTERSTHESIS
%token  MISC
%token  PHDTHESIS
%token  PROCEEDINGS
%token  TECHREPORT
%token  UNPUBLISHED
%token  KOMMA
%token  EQ
%token  LGKL
%token  RGKL
%token  LRKL
%token  RRKL
%token  DAZ
%token  ZAUN
%token  ZEICHEN
%token  WHITE_SPACE
%token  BUCHSTABE_ZAHL
X
X
%%
X
datei  
X         :  leerraum entry KOMMA datei
X         |  entry KOMMA datei
X         |  leerraum entry leerraum KOMMA datei
X         |  entry leerraum KOMMA datei
X         |  leerraum entry datei
X         |  entry datei
X         |  leerraum entry KOMMA
X         |  entry KOMMA
X         |  leerraum entry leerraum KOMMA 
X         |  entry leerraum KOMMA 
X         |  leerraum entry 
X         |  entry
X         |  leerraum
X
entry
X	 :  string
X	 |  preamble
X	 |  eintrag
X	 
string
X         :  STRING LGKL allstringG RGKL
X              {         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@STRING"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } 
X         |  STRING leerraum LGKL allstringG RGKL
X              {         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@STRING"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } 
X         |  STRING LRKL allstringR RRKL 
X              {         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@STRING"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } 
X         |  STRING leerraum LRKL allstringR RRKL
X              {         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@STRING"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } 
X
preamble
X         :  PREAMBLE LGKL allstringG RGKL
X              {         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@PREAMBLE"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } 
X         |  PREAMBLE leerraum LGKL allstringG RGKL 
X              {         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@PREAMBLE"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } 
X         |  PREAMBLE LRKL allstringR RRKL
X              {         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@PREAMBLE"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } 
X         |  PREAMBLE leerraum LRKL allstringR RRKL
X              {         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@PREAMBLE"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } 
X
allstringG
X         :  WHITE_SPACE allstringG
X         |  ZEICHEN  allstringG
X         |  BUCHSTABE_ZAHL allstringG
X         |  KOMMA allstringG
X         |  EQ allstringG
X         |  ZAUN allstringG
X         |  DAZ allstringG
X         |  LGKL allstringG RGKL allstringG
X         |  LGKL RGKL allstringG
X         |  LGKL allstringG RGKL
X         |  LGKL RGKL
X         |  LRKL allstringG
X         |  RRKL allstringG
X         |  WHITE_SPACE
X         |  ZEICHEN
X         |  BUCHSTABE_ZAHL
X         |  KOMMA
X         |  EQ
X         |  ZAUN
X         |  DAZ
X         |  LRKL
X         |  RRKL 
X
allstringR
X         :  WHITE_SPACE allstringR
X         |  ZEICHEN  allstringR
X         |  BUCHSTABE_ZAHL allstringR
X         |  KOMMA allstringR
X         |  EQ allstringR
X         |  ZAUN allstringR
X         |  DAZ allstringR
X         |  LGKL allstringR RGKL allstringR
X         |  LGKL RGKL allstringR
X         |  LGKL allstringR RGKL
X         |  LGKL RGKL
X         |  LRKL allstringR RRKL
X         |  LRKL RRKL
X         |  WHITE_SPACE
X         |  ZEICHEN
X         |  BUCHSTABE_ZAHL
X         |  KOMMA
X         |  EQ
X         |  ZAUN
X         |  DAZ
eintrag 
X         :  eingabetyp LGKL schluessel KOMMA felder leerraum RGKL 
X                {                 
X                  GetKey();
X                }
X         |  eingabetyp leerraum LGKL schluessel KOMMA felder leerraum RGKL 
X                {
X                  GetKey();
X                }
X         |  eingabetyp LGKL schluessel KOMMA felder RGKL 
X                {
X                  GetKey();
X                }
X         |  eingabetyp leerraum LGKL schluessel KOMMA felder RGKL
X                {
X                  GetKey();
X                }
X         |  eingabetyp LRKL schluessel KOMMA felder leerraum RRKL 
X                {
X                  GetKey();
X                }
X         |  eingabetyp leerraum LRKL schluessel KOMMA felder leerraum RRKL
X                {
X                  GetKey();
X                }
X         |  eingabetyp LRKL schluessel KOMMA felder RRKL 
X                {
X                  GetKey();
X                }
X         |  eingabetyp leerraum LRKL schluessel KOMMA felder RRKL
X                {
X                  GetKey();
X                }
X
eingabetyp
X	  :  ARTICLE
X                {
X		  err = dbtMakeCard(&card);
X		  card->cardtype = article; 
X		  Scalloc(&card->cardtypestr, "article");
X                }
X	  |  BOOK
X                {
X		  err = dbtMakeCard(&card);
X		  card->cardtype = book; 
X		  Scalloc(&card->cardtypestr, "book");
X                }
X	  |  BOOKLET
X                {
X		  err = dbtMakeCard(&card);
X		  card->cardtype = booklet; 
X		  Scalloc(&card->cardtypestr, "booklet");
X                }
X	  |  CONFERENCE
X                {
X		  err = dbtMakeCard(&card);
X		  card->cardtype = conference; 
X		  Scalloc(&card->cardtypestr, "conference");
X                }
X	  |  INBOOK
X                {
X		  err = dbtMakeCard(&card);
X		  card->cardtype = inbook; 
X		  Scalloc(&card->cardtypestr, "inbook");
X                }
X	  |  INCOLLECTION
X                {
X		  err = dbtMakeCard(&card);
X		  card->cardtype = incollection; 
X		  Scalloc(&card->cardtypestr, "incollection");
X                }
X	  |  INPROCEEDINGS
X                {
X		  err = dbtMakeCard(&card);
X		  card->cardtype = inproceedings; 
X		  Scalloc(&card->cardtypestr, "inproceedings");
X                }
X	  |  MANUAL
X                {
X		  err = dbtMakeCard(&card);
X		  card->cardtype = manual; 
X		  Scalloc(&card->cardtypestr, "manual");
X                }
X	  |  MASTERSTHESIS
X                {
X		  err = dbtMakeCard(&card);
X		  card->cardtype = mastersthesis; 
X		  Scalloc(&card->cardtypestr, "mastersthesis");
X                }
X	  |  MISC
X                {
X		  err = dbtMakeCard(&card);
X		  card->cardtype = misc; 
X		  Scalloc(&card->cardtypestr, "misc");
X                }
X	  |  PHDTHESIS
X                {
X		  err = dbtMakeCard(&card);
X		  card->cardtype = phdthesis; 
X		  Scalloc(&card->cardtypestr, "phdthesis");
X                }
X	  |  PROCEEDINGS
X                {
X		  err = dbtMakeCard(&card);
X		  card->cardtype = proceedings; 
X		  Scalloc(&card->cardtypestr, "proceedings");
X                }
X	  |  TECHREPORT
X                {
X		  err = dbtMakeCard(&card);
X		  card->cardtype = techreport; 
X		  Scalloc(&card->cardtypestr, "techreport");
X                }
X	  |  UNPUBLISHED
X                {
X		  err = dbtMakeCard(&card);
X		  card->cardtype = unpublished; 
X		  Scalloc(&card->cardtypestr, "unpublished");
X                }
X
schluessel 
X            :  leerraum schl
X            |  schl leerraum
X            |  leerraum schl leerraum
X            |  schl
X
X
schl
X            :  BUCHSTABE_ZAHL schl
X                {
X                  PushSign(&key, $1);
X                }
X            |  ZEICHEN schl
X                {
X                  PushSign(&key, $1);
X                }
X            |  BUCHSTABE_ZAHL 
X                {
X                  PushSign(&key, $1);
X                }
X            |  ZEICHEN 
X                {
X                  PushSign(&key, $1);
X                }
X            |  EQ
X                {
X                  PushSign(&key, $1);
X                }
X
felder 
X          :  leerraum feld KOMMA felder
X          |  feld KOMMA felder
X          |  leerraum feld KOMMA
X          |  leerraum feld KOMMA leerraum
X          |  feld KOMMA 
X          |  feld KOMMA  leerraum
X          |  leerraum feld
X          |  feld
X          |  feld leerraum
X
feld 
X          :  feldname leerraum EQ konkatenation
X                {
X                  GetFldNameCont();
X                }
X          |  feldname EQ konkatenation 
X                {
X                  GetFldNameCont();
X                }
X
feldname
X          :  BUCHSTABE_ZAHL feldname
X                {
X                  PushSign(&fldname, $1);
X                  ueIdx = 0;
X                }
X          |  BUCHSTABE_ZAHL
X                {
X                  PushSign(&fldname, $1);
X                  ueIdx = 0;
X                }
X
leerraum
X          :  WHITE_SPACE  leerraum
X          |  WHITE_SPACE
X
X      
konkatenation
X             :  konkatenation ZAUN konkatenation
X             |  feldinhalt
X             |  feldinhalt leerraum
X             |  leerraum feldinhalt 
X             |  leerraum feldinhalt leerraum
X
feldinhalt
X          :  LGKL allstringG RGKL
X          |  DAZ dazfeldinhalt DAZ 
X          |  DAZ DAZ 
X          |  LGKL RGKL
X          |  makro
X
makro
X            :  BUCHSTABE_ZAHL makro
X            |  ZEICHEN makro
X            |  BUCHSTABE_ZAHL 
X            |  ZEICHEN 
X
dazfeldinhalt
X          :  WHITE_SPACE dazfeldinhalt
X          |  BUCHSTABE_ZAHL dazfeldinhalt
X          |  ZEICHEN dazfeldinhalt
X          |  LRKL dazfeldinhalt
X          |  RRKL dazfeldinhalt
X          |  LGKL dazdaz RGKL
X          |  LGKL dazdaz RGKL dazfeldinhalt
X          |  LGKL RGKL
X          |  LGKL RGKL dazfeldinhalt
X          |  WHITE_SPACE
X          |  BUCHSTABE_ZAHL
X          |  KOMMA dazfeldinhalt
X          |  EQ dazfeldinhalt
X          |  ZEICHEN
X          |  LRKL
X          |  RRKL
X          |  KOMMA
X
dazdaz
X          :  WHITE_SPACE dazdaz
X          |  BUCHSTABE_ZAHL dazdaz
X          |  ZEICHEN dazdaz
X          |  LRKL dazdaz
X          |  RRKL dazdaz
X          |  LGKL dazdaz RGKL
X          |  LGKL dazdaz RGKL dazdaz
X          |  WHITE_SPACE
X          |  BUCHSTABE_ZAHL
X          |  KOMMA dazdaz
X          |  DAZ dazdaz
X          |  EQ dazdaz
X          |  ZEICHEN
X          |  LRKL
X          |  RRKL
X          |  KOMMA
X          |  DAZ
X
%%
X
static void StrToLower(char *text)
{
X while (*text != '\0') {
X   *text++ = tolower(*text);
X }
}
X
X
X
static int SkipNewLineSpace(char *text)
{ 
X int erg, back;
X
X erg = 0;
X while (erg < MAX_UEBERGABE) {
X   if (*text == '{' ||  *text == '(') {
X     back = strlen(text);
X     text = text + back;
X     while (*text != '}' && *text != ')') { 
X       *text = '\0';
X       text--;
X     }
X     return erg;
X   }
X   text++;
X   erg++;
X }
X return 0;
}
X
X
X
X
static int SkipSpace(char *text, Snode **new)
{
X int erg, lgkl, daz, index, inmakro;
X 
X index = 0;
X lgkl = 0;
X daz = 0;
X inmakro = 0;
X
X while ((*text == ' ' || *text == '=' || *text == '\t') && index < ueIdx) { text++; index++; }
X erg = index;
X if (*text == '{') {
X   lgkl += 1;
X   index++;
X   text++; 
X   inmakro = 0;
X }
X else if (*text == '"') {
X   daz += 1;
X   index++;
X   text++; 
X   inmakro = 0;
X }
X else {
X   AppendSign(new, '@');
X   AppendSign(new, *text);
X   index++;
X   text++; 
X   inmakro = 1;
X }
X while (index < ueIdx) {
X   if (*text == '{') {
X     if (lgkl >= 1 || daz >= 1) {  /* Klammer in String */
X       AppendSign(new, *text);
X     }
X     text++;                       /* Klammer nach Zaun */
X     index++;
X     lgkl += 1;
X     inmakro = 0;
X   }
X   else if (*text == '}') {
X     if ((lgkl > 1) || (daz >= 1)) {
X       AppendSign(new, *text);
X     } 
X     text++;
X     index++;
X     lgkl -= 1;
X     inmakro = 0;
X   }
X   else if (*text == '"') {
X     if (lgkl >= 1) {
X       AppendSign(new, *text);
X       text++;
X       index++;
X     } 
X     else {
X       text++;
X       index++;
X       if (daz == 0) daz++;
X       else daz = 0;
X     }
X     inmakro = 0;
X   }
X   else if (*text == '#') {        /* Space vor/nach Konkatenation */
X     if (lgkl < 1 && daz < 1) {
X       if (text[index-1] != ' ') AppendSign(new, ' ');
X       AppendSign(new, '@');       /* # -> @# */
X       AppendSign(new, *text);
X       if (text[index+1] != ' ') AppendSign(new, ' ');
X     }
X     else {                        /* Konkatenation in String */
X       AppendSign(new, *text);
X     }
X     text++;
X     index++;
X     inmakro = 0;
X   } 
X   else if (*text == ',') {        /* Komma am Ende */
X     if (lgkl < 1 && daz != 1) break;
X     else {
X       AppendSign(new, *text);
X       text++;
X       index++;
X     }
X     inmakro = 0;
X   }
X   else if (*text == ')') {        /* runde Klammer am Ende */
X     if (lgkl < 1 && daz != 1) break;
X     else {
X       AppendSign(new, *text);
X       text++;
X       index++;
X     }
X     inmakro = 0;
X   }
X   else if (isalnum(*text)) {
X     if (lgkl < 1 && daz < 1 && (inmakro==0)) {
X       if (text[index-1] != ' ') AppendSign(new, ' ');
X       AppendSign(new, '@');       /* makro -> @makro */
X       AppendSign(new, *text);
X       inmakro = 1;
X     }
X     else {                        /* Zeichen in String */
X       AppendSign(new, *text);
X     }
X     text++;
X     index++;
X   } 
X   else {                        /* sonstiges Zeichen in String */
X     AppendSign(new, *text);
X     text++;
X     index++;
X     inmakro = 0;
X   } 
X }
X return erg;
X  
}
X
X
static void PushSign(Snode **w, char a)
{
X Snode *hnode, *oldw;
X
X if (*w == NULL) {
X   hnode = (Snode *)calloc(1,sizeof(Snode));
X   hnode->inh = a;
X   hnode->slen = 1;
X   hnode->next = NULL;
X   *w = hnode;
X }
X else {
X   oldw = *w; 
X   hnode = (Snode *)calloc(1,sizeof(Snode));
X   hnode->inh = a;
X   hnode->slen = oldw->slen + 1;
X   hnode->next = oldw;
X   *w = hnode;
}
}
X
X
static void AppendSign(Snode **w, char a)
{
X Snode *hnode, *oldw;
X int newslen;
X
X if (*w == NULL) {
X   hnode = (Snode *)calloc(1,sizeof(Snode));
X   hnode->inh = a;
X   hnode->slen = 1;
X   hnode->next = NULL;
X   *w = hnode;
X }
X else {
X   oldw = *w; 
X   newslen = 1;
X   while (oldw->next != NULL) {
X     newslen++; 
X     oldw = oldw->next;
X   }
X   newslen++; 
X   hnode = (Snode *)calloc(1,sizeof(Snode));
X   hnode->inh = a;
X   hnode->slen = 1;
X   hnode->next = NULL;
X   oldw->next = hnode;
X   oldw = *w; 
X   oldw->slen = newslen;      /* echte Laenge nur im 1. El. */
}
}
X
X
static void FreeStack(Snode **s)
{
X Snode *h, *del;
X
X del = *s;
X while (del != NULL) {
X   h = del->next;
X   free(del);
X   del = h;
X }
X *s = NULL;
} 
X
X
static void StackToString(Snode *s, char **text) 
{
X  char *help;
X
X  help = (char *)calloc(1,s->slen+1);
X  *text = help;
X  while (s != NULL) {
X    *help = s->inh; 
X    s = s->next;
X    help++;
X  }
X  *help = '\0';
X  help--;
X  while (*help == '\n') {    /* NL am Ende vom Wort loeschen */
X    *help = '\0';
X    help--;
X  }
}
X
X
X
static void GetKey()
{
X  StackToString(key, &card->mainkey);
X  FreeStack(&key);
X  err = dbtInsert(glbtreeIdx, card);
X  err = dbtDeleteCard(&card);
}
X
X
static void GetFldNameCont()
{
X  int anf, i;
X  
X  if (helpFldName != NULL) {
X    free(helpFldName);
X    helpFldName = NULL;
X  }
X  StackToString(fldname, &helpFldName);
X  StrToLower(helpFldName); 
X  anf = SkipSpace(uebergabe, &fldcont);
X
X  if (strcmp(helpFldName, "address") == 0) {
X    StackToString(fldcont, &card->address);
X  } 
X  else if (strcmp(helpFldName, "annote") == 0) {
X    StackToString(fldcont, &card->annote);
X  } 
X  else if (strcmp(helpFldName, "author") == 0) {
X    StackToString(fldcont, &card->author);
X  } 
X  else if (strcmp(helpFldName, "booktitle") == 0) {
X    StackToString(fldcont, &card->booktitle);
X  } 
X  else if (strcmp(helpFldName, "chapter") == 0) {
X    StackToString(fldcont, &card->chapter);
X  } 
X  else if (strcmp(helpFldName, "crossref") == 0) {
X    StackToString(fldcont, &card->crossref);
X  }
X  else if (strcmp(helpFldName, "edition") == 0) {
X    StackToString(fldcont, &card->edition);
X  } 
X  else if (strcmp(helpFldName, "editor") == 0) {
X    StackToString(fldcont, &card->editor);
X  } 
X  else if (strcmp(helpFldName, "howpublished") == 0) {
X    StackToString(fldcont, &card->howpublished);
X  } 
X  else if (strcmp(helpFldName, "institution") == 0) {
X    StackToString(fldcont, &card->institution);
X  } 
X  else if (strcmp(helpFldName, "journal") == 0) {
X    StackToString(fldcont, &card->journal);
X  } 
X  else if (strcmp(helpFldName, "key") == 0) {
X    StackToString(fldcont, &card->key);
X  } 
X  else if (strcmp(helpFldName, "month") == 0) {
X    StackToString(fldcont, &card->month);
X  } 
X  else if (strcmp(helpFldName, "note") == 0) {
X    StackToString(fldcont, &card->note);
X  } 
X  else if (strcmp(helpFldName, "number") == 0) {
X    StackToString(fldcont, &card->number);
X  } 
X  else if (strcmp(helpFldName, "organization") == 0) {
X    StackToString(fldcont, &card->organization);
X  } 
X  else if (strcmp(helpFldName, "pages") == 0) {
X    StackToString(fldcont, &card->pages);
X  } 
X  else if (strcmp(helpFldName, "publisher") == 0) {
X    StackToString(fldcont, &card->publisher);
X  } 
X  else if (strcmp(helpFldName, "school") == 0) {
X    StackToString(fldcont, &card->school);
X  } 
X  else if (strcmp(helpFldName, "series") == 0) {
X    StackToString(fldcont, &card->series);
X  } 
X  else if (strcmp(helpFldName, "title") == 0) {
X    StackToString(fldcont, &card->title);
X  } 
X  else if (strcmp(helpFldName, "type") == 0) {
X    StackToString(fldcont, &card->type);
X  } 
X  else if (strcmp(helpFldName, "volume") == 0) {
X    StackToString(fldcont, &card->volume);
X  } 
X  else if (strcmp(helpFldName, "year") == 0) {
X    StackToString(fldcont, &card->year);
X  } 
X  else if (strcmp(helpFldName, "category") == 0) {
X    StackToString(fldcont, &card->category);
X  } 
X  else {
X    err = dbtMakeUserFld(&helpufield);
X    Scalloc(&helpufield->fldName, helpFldName);
X    StackToString(fldcont, &helpufield->fldData); 
X    err = dbtAppendUserFld(&card->ufield, helpufield);
X  }
X  FreeStack(&fldname);
X  FreeStack(&fldcont);
}
X
X
X
/*********************************************************************/
/*  Errcode Scalloc(String *s1, String s2):                          */
/*  Platz fuer s1 bereitstellen und s2 nach s1 kopieren              */
/*********************************************************************/
X
static Errcode Scalloc(String *s1, String s2)
{
X if (s2 != NULL){
X   *s1 = (String)calloc(1,strlen(s2)+1);
X   if (*s1 == NULL) return BIF_ECALLOC;
X   strcpy(*s1, s2);
X }
X return BIF_OK;
}
X
X
X
static char * Sncalloc(char *s2, int von, int bis)
{
X char *help, *weiter;
X int i;
X
X if (s2 != NULL){
X   help = (char *)calloc(1,bis);
X   if (help == NULL) return NULL;
X   strncpy(help, &s2[von], bis - von + 1 );
X   weiter = help;
X   for (i = 0; i < bis - von + 1; i++) weiter++;
X   *weiter = '\0'; 
}
X return help;
}
X
X
X
static int SetInputFile(char *file)
{
X char *infilename; 
X    
X if (file)
X {
X  infilename = file;
X  yyin = fopen(infilename, "r" );
X
X  if ( yyin == NULL ) {
X    return BIF_EOPEN;  
X  }
X  return BIF_OK;  
X }
X else
X {
X   yyin = stdin;
X   infilename = "<stdin>";
X   return BIF_OK;  
X }
}
X
X
/*********************************************
X * Test, ob Datei im BibTeX-Format           *
X *********************************************/
static int ItIsBibFile(char *dateiName)
{
X FILE *dptr;
X char inh;
X
X dptr = fopen(dateiName, "r");
X inh = (char)getc(dptr);
X if (inh == '@') {
X   fclose(dptr); 
X   return 1;
X }
X while (inh == ' ' || inh == '\t' || inh == '\n') 
X   inh = (char)getc(dptr);
X if (inh == '@') {
X   fclose(dptr); 
X   return 1;
X }
X else {
X   fclose(dptr); 
X   return 0;
X }
}
X
X
X
/*********************************************
X * BibTeX-Datei lesen                        *
X *********************************************/
Errcode bifFileRead(BibPtr bp)
{
X  int erg;
X  int len, i;
X  char *tempName;
X
X  yynline = 1; 
X  yynflexcalls = 0;
X  bp->tempfile = (char *)tempnam(NULL, NULL);
X  bp->macrofile = (char *)tempnam(NULL, NULL);
X  tempDatei = fopen(bp->macrofile, "w" );
X  if ((erg = SetInputFile(bp->filepath)) != 1) return erg;
X  if ((erg = ItIsBibFile(bp->filepath)) != 1) return ERR_NOBIB;
X  glbtreeIdx = bp->treeIdx; 
X  erg = yyparse();
X  fclose(tempDatei);
X  uebergabe[0] = '\0';
X  ueIdx = 0;
X  if (erg == 0) {
X    if (yyin) fclose(yyin);
X    return BIF_OK;
X  }
X  else {
X    erg = -yynline;
X    yy_init = 1;
X    if (yyin) fclose(yyin);
X    return (Errcode)erg;
X  }
}
X
X
X
Errcode bifFileWrite(BibPtr bp)
{
X CardListNode *list, *hlist;
X CardData *hcard;
X Errcode erg;
X char sysStr[2*MAX_FILEPATHLEN];
X String saveName;
X int savelen;
X
CardListNode *cl = NULL;
char wcKey[] = ".";
CardData *wcCard;
Errcode status;
X
X if (bp->macrofile!=NULL){
X    sprintf(sysStr, "cp  %s %s", bp->macrofile, bp->tempfile);
X    system(sysStr);
X    tempDatei = fopen(bp->tempfile, "r+");
X    }
X else
X    {tempDatei = fopen(bp->tempfile, "w+");
X     }
X
X if (tempDatei == NULL) return BIF_EWRITE;
X
X   /* build list with wildcard search */
X   if ((status = (int)dbtMakeCard(&wcCard)) != OK) {
X      guwError(status);
X   }
X   wcCard->cardtype = (int)regexpr;
X   wcCard->mainkey = glbNewString(".");
X   if ((status = dbtSearchList(bp->treeIdx, wcCard, &cl)) != OK) {
X      guwError(status); 
X      return;
X   }
X
X while (cl != NULL) {
X   WriteRecToFile(cl->data, tempDatei);
X   cl = cl->next;
X } 
X
X fclose(tempDatei);
X sprintf(sysStr, "cp  %s %s", bp->tempfile, bp->filepath);
X system(sysStr);
X return BIF_OK;
}
X
X
Errcode bifFileListWrite(BibPtr bp, CardListNode *list, String fname)
{
X CardListNode *hlist;
X CardData *hcard;
X Errcode erg;
X char sysStr[2*MAX_FILEPATHLEN];
X String saveName;
X int savelen;
X 
X if (bp->macrofile!=NULL)
X    {sprintf(sysStr, "cp %s %s", bp->macrofile, fname);
X     system(sysStr);
X     }
X
X tempDatei = fopen(fname, "a+");
X if (tempDatei == NULL) return BIF_EWRITE;
X hlist = list;
X while (hlist != NULL) {
X   WriteRecToFile(hlist->data, tempDatei);
X   hlist = hlist->next;
X } 
X fclose(tempDatei);
X return BIF_OK;
}
X
X
static long WriteLineToFile(FILE *datei, char *feld, char *inh)
{
X  int makro = 2;    /* weder Makro, noch String */
X  long pos; 
X  char *tmp;
X
X  fprintf(datei,"     %s = ",feld);    
X  while (*inh == ' ' || *inh == '\t' || *inh == '\n') {
X    fprintf(datei,"%c",*inh);    
X    inh++;
X  }
X  if (*inh == '@') {
X    fprintf(datei," ");    
X    makro = 1;
X  }
X  else {
X    fprintf(datei,"{");    
X    fprintf(datei,"%c",*inh);    
X    makro = 0;
X  }
X  inh++;
X  while (*inh != '\0') {
X    if (*inh == '@') {
X      tmp = inh;
X      tmp++;
X      if (*tmp == '#') {                  /* KONKATENATION */
X        if (makro == 1) {
X          fprintf(datei," # ");           /* letzter Teil war ein MAKRO */ 
X          tmp++;
X          while (*tmp == ' ' || *tmp == '\t' || *tmp == '\n') {
X            fprintf(datei,"%c",*tmp);    
X            tmp++;
X          }
X          if (*tmp == '@') {              /* naechster Teil ist ein MAKRO */
X            fprintf(datei," ");    
X            makro = 1;
X          }
X          else {
X            fprintf(datei,"{");    
X            fprintf(datei,"%c",*tmp);     /* naechster Teil ist ein STRING */
X            makro = 0;
X          }
X        }
X        else if (makro == 0) {
X          fprintf(datei,"} # ");          /* letzter Teil war ein STRING */ 
X          tmp++;
X          while (*tmp == ' ' || *tmp == '\t' || *tmp == '\n') {
X            fprintf(datei,"%c",*tmp);    
X            tmp++;
X          }
X          if (*tmp == '@') {              /* naechster Teil ist ein MAKRO */
X            fprintf(datei," ");    
X            makro = 1;
X          }
X          else {
X            fprintf(datei,"{");    
X            fprintf(datei,"%c",*tmp);     /* naechster Teil ist ein STRING */
X            makro = 0;
X          }
X        }  /* else if makro == 0 */
X        inh = tmp;
X      }
X      else {                              /* AFFE nicht schreiben */
X        fprintf(datei," ");    
X        makro = 1;
X      }
X    }      /* if @ */
X    else {
X      fprintf(datei,"%c",*inh);    
X    }
X    inh++;
X  }  /* while */
X  if (makro == 0) {
X    fprintf(datei,"}");    
X  }
X 
X        
X   pos = ftell(datei);
X   fprintf(datei,",  \n");
X   return pos;
}
X
X
static void WriteRecToFile(CardData *card, FILE *datei)
SHAR_EOF
true || echo 'restore of flexsrc/b.y failed'
fi
echo 'End of  part 13'
echo 'File flexsrc/b.y is continued in part 14'
echo 14 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
