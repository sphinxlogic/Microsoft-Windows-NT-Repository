Path: uunet!dtix!darwin.sura.net!mips!msi!dcmartin
From: liebla@informatik.tu-muenchen.de (Armin Liebl)
Newsgroups: comp.sources.x
Subject: v18i102: bibview - BibTeX GUI, Part04/20
Message-ID: <1992Aug27.161419.25285@msi.com>
Date: 27 Aug 92 16:14:19 GMT
References: <csx-18i099-bibview@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1881
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: Armin Liebl <liebla@informatik.tu-muenchen.de>
Posting-number: Volume 18, Issue 102
Archive-name: bibview/part04

#!/bin/sh
# this is part.04 (part 4 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file bib_file.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 4; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping bib_file.c'
else
echo 'x - continuing file bib_file.c'
sed 's/^X//' << 'SHAR_EOF' >> 'bib_file.c' &&
X	"allstringR : ZEICHEN",
X	"allstringR : BUCHSTABE_ZAHL",
X	"allstringR : KOMMA",
X	"allstringR : EQ",
X	"allstringR : ZAUN",
X	"allstringR : DAZ",
X	"eintrag : eingabetyp LGKL schluessel KOMMA felder leerraum RGKL",
X	"eintrag : eingabetyp leerraum LGKL schluessel KOMMA felder leerraum RGKL",
X	"eintrag : eingabetyp LGKL schluessel KOMMA felder RGKL",
X	"eintrag : eingabetyp leerraum LGKL schluessel KOMMA felder RGKL",
X	"eintrag : eingabetyp LRKL schluessel KOMMA felder leerraum RRKL",
X	"eintrag : eingabetyp leerraum LRKL schluessel KOMMA felder leerraum RRKL",
X	"eintrag : eingabetyp LRKL schluessel KOMMA felder RRKL",
X	"eintrag : eingabetyp leerraum LRKL schluessel KOMMA felder RRKL",
X	"eingabetyp : ARTICLE",
X	"eingabetyp : BOOK",
X	"eingabetyp : BOOKLET",
X	"eingabetyp : CONFERENCE",
X	"eingabetyp : INBOOK",
X	"eingabetyp : INCOLLECTION",
X	"eingabetyp : INPROCEEDINGS",
X	"eingabetyp : MANUAL",
X	"eingabetyp : MASTERSTHESIS",
X	"eingabetyp : MISC",
X	"eingabetyp : PHDTHESIS",
X	"eingabetyp : PROCEEDINGS",
X	"eingabetyp : TECHREPORT",
X	"eingabetyp : UNPUBLISHED",
X	"schluessel : leerraum schl",
X	"schluessel : schl leerraum",
X	"schluessel : leerraum schl leerraum",
X	"schluessel : schl",
X	"schl : BUCHSTABE_ZAHL schl",
X	"schl : ZEICHEN schl",
X	"schl : BUCHSTABE_ZAHL",
X	"schl : ZEICHEN",
X	"schl : EQ",
X	"felder : leerraum feld KOMMA felder",
X	"felder : feld KOMMA felder",
X	"felder : leerraum feld KOMMA",
X	"felder : leerraum feld KOMMA leerraum",
X	"felder : feld KOMMA",
X	"felder : feld KOMMA leerraum",
X	"felder : leerraum feld",
X	"felder : feld",
X	"felder : feld leerraum",
X	"feld : feldname leerraum EQ konkatenation",
X	"feld : feldname EQ konkatenation",
X	"feldname : BUCHSTABE_ZAHL feldname",
X	"feldname : BUCHSTABE_ZAHL",
X	"leerraum : WHITE_SPACE leerraum",
X	"leerraum : WHITE_SPACE",
X	"konkatenation : konkatenation ZAUN konkatenation",
X	"konkatenation : feldinhalt",
X	"konkatenation : feldinhalt leerraum",
X	"konkatenation : leerraum feldinhalt",
X	"konkatenation : leerraum feldinhalt leerraum",
X	"feldinhalt : LGKL allstringG RGKL",
X	"feldinhalt : DAZ dazfeldinhalt DAZ",
X	"feldinhalt : DAZ DAZ",
X	"feldinhalt : LGKL RGKL",
X	"feldinhalt : makro",
X	"makro : BUCHSTABE_ZAHL makro",
X	"makro : ZEICHEN makro",
X	"makro : BUCHSTABE_ZAHL",
X	"makro : ZEICHEN",
X	"dazfeldinhalt : WHITE_SPACE dazfeldinhalt",
X	"dazfeldinhalt : BUCHSTABE_ZAHL dazfeldinhalt",
X	"dazfeldinhalt : ZEICHEN dazfeldinhalt",
X	"dazfeldinhalt : LRKL dazfeldinhalt",
X	"dazfeldinhalt : RRKL dazfeldinhalt",
X	"dazfeldinhalt : LGKL dazdaz RGKL",
X	"dazfeldinhalt : LGKL dazdaz RGKL dazfeldinhalt",
X	"dazfeldinhalt : LGKL RGKL",
X	"dazfeldinhalt : LGKL RGKL dazfeldinhalt",
X	"dazfeldinhalt : WHITE_SPACE",
X	"dazfeldinhalt : BUCHSTABE_ZAHL",
X	"dazfeldinhalt : KOMMA dazfeldinhalt",
X	"dazfeldinhalt : EQ dazfeldinhalt",
X	"dazfeldinhalt : ZEICHEN",
X	"dazfeldinhalt : LRKL",
X	"dazfeldinhalt : RRKL",
X	"dazfeldinhalt : KOMMA",
X	"dazdaz : WHITE_SPACE dazdaz",
X	"dazdaz : BUCHSTABE_ZAHL dazdaz",
X	"dazdaz : ZEICHEN dazdaz",
X	"dazdaz : LRKL dazdaz",
X	"dazdaz : RRKL dazdaz",
X	"dazdaz : LGKL dazdaz RGKL",
X	"dazdaz : LGKL dazdaz RGKL dazdaz",
X	"dazdaz : WHITE_SPACE",
X	"dazdaz : BUCHSTABE_ZAHL",
X	"dazdaz : KOMMA dazdaz",
X	"dazdaz : DAZ dazdaz",
X	"dazdaz : EQ dazdaz",
X	"dazdaz : ZEICHEN",
X	"dazdaz : LRKL",
X	"dazdaz : RRKL",
X	"dazdaz : KOMMA",
X	"dazdaz : DAZ",
};
#endif /* YYDEBUG */
#define YYFLAG  (-3000)
/* @(#) $Revision: 66.3 $ */    
X
/*
** Skeleton parser driver for yacc output
*/
X
#if defined(NLS) && !defined(NL_SETN)
#include <msgbuf.h>
#endif
X
#ifndef nl_msg
#define nl_msg(i,s) (s)
#endif
X
/*
** yacc user known macros and defines
*/
#define YYERROR		goto yyerrlab
X
#ifndef __RUNTIME_YYMAXDEPTH
#define YYACCEPT	return(0)
#define YYABORT		return(1)
#else
#define YYACCEPT	{free_stacks(); return(0);}
#define YYABORT		{free_stacks(); return(1);}
#endif
X
#define YYBACKUP( newtoken, newvalue )\
{\
X	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
X	{\
X		yyerror( (nl_msg(30001,"syntax error - cannot backup")) );\
X		goto yyerrlab;\
X	}\
X	yychar = newtoken;\
X	yystate = *yyps;\
X	yylval = newvalue;\
X	goto yynewstate;\
}
#define YYRECOVERING()	(!!yyerrflag)
#ifndef YYDEBUG
#	define YYDEBUG	1	/* make debugging available */
#endif
X
/*
** user known globals
*/
int yydebug;			/* set to 1 to get debugging */
X
/*
** driver internal defines
*/
/* define for YYFLAG now generated by yacc program. */
/*#define YYFLAG		(FLAGVAL)*/
X
/*
** global variables used by the parser
*/
# ifndef __RUNTIME_YYMAXDEPTH
__YYSCLASS YYSTYPE yyv[ YYMAXDEPTH ];	/* value stack */
__YYSCLASS int yys[ YYMAXDEPTH ];		/* state stack */
# else
__YYSCLASS YYSTYPE *yyv;			/* pointer to malloc'ed value stack */
__YYSCLASS int *yys;			/* pointer to malloc'ed stack stack */
X
static int allocate_stacks(); 
static void free_stacks();
# ifndef YYINCREMENT
# define YYINCREMENT (YYMAXDEPTH/2) + 10
# endif
# endif	/* __RUNTIME_YYMAXDEPTH */
long  yymaxdepth = YYMAXDEPTH;
X
__YYSCLASS YYSTYPE *yypv;			/* top of value stack */
__YYSCLASS int *yyps;			/* top of state stack */
X
__YYSCLASS int yystate;			/* current state */
__YYSCLASS int yytmp;			/* extra var (lasts between blocks) */
X
int yynerrs;			/* number of errors */
__YYSCLASS int yyerrflag;			/* error recovery flag */
int yychar;			/* current input token number */
X
X
X
/*
** yyparse - return 0 if worked, 1 if syntax error not recovered from
*/
int
yyparse()
{
X	register YYSTYPE *yypvt;	/* top of value stack for $vars */
X
X	/*
X	** Initialize externals - yyparse may be called more than once
X	*/
# ifdef __RUNTIME_YYMAXDEPTH
X	if (allocate_stacks()) YYABORT;
# endif
X	yypv = &yyv[-1];
X	yyps = &yys[-1];
X	yystate = 0;
X	yytmp = 0;
X	yynerrs = 0;
X	yyerrflag = 0;
X	yychar = -1;
X
X	goto yystack;
X	{
X		register YYSTYPE *yy_pv;	/* top of value stack */
X		register int *yy_ps;		/* top of state stack */
X		register int yy_state;		/* current state */
X		register int  yy_n;		/* internal state number info */
X
X		/*
X		** get globals into registers.
X		** branch to here only if YYBACKUP was called.
X		*/
X	yynewstate:
X		yy_pv = yypv;
X		yy_ps = yyps;
X		yy_state = yystate;
X		goto yy_newstate;
X
X		/*
X		** get globals into registers.
X		** either we just started, or we just finished a reduction
X		*/
X	yystack:
X		yy_pv = yypv;
X		yy_ps = yyps;
X		yy_state = yystate;
X
X		/*
X		** top of for (;;) loop while no reductions done
X		*/
X	yy_stack:
X		/*
X		** put a state and value onto the stacks
X		*/
#if YYDEBUG
X		/*
X		** if debugging, look up token value in list of value vs.
X		** name pairs.  0 and negative (-1) are special values.
X		** Note: linear search is used since time is not a real
X		** consideration while debugging.
X		*/
X		if ( yydebug )
X		{
X			register int yy_i;
X
X			printf( "State %d, token ", yy_state );
X			if ( yychar == 0 )
X				printf( "end-of-file\n" );
X			else if ( yychar < 0 )
X				printf( "-none-\n" );
X			else
X			{
X				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
X					yy_i++ )
X				{
X					if ( yytoks[yy_i].t_val == yychar )
X						break;
X				}
X				printf( "%s\n", yytoks[yy_i].t_name );
X			}
X		}
#endif /* YYDEBUG */
X		if ( ++yy_ps >= &yys[ yymaxdepth ] )	/* room on stack? */
X		{
# ifndef __RUNTIME_YYMAXDEPTH
X			yyerror( (nl_msg(30002,"yacc stack overflow")) );
X			YYABORT;
# else
X			/* save old stack bases to recalculate pointers */
X			YYSTYPE * yyv_old = yyv;
X			int * yys_old = yys;
X			yymaxdepth += YYINCREMENT;
X			yys = (int *) realloc(yys, yymaxdepth * sizeof(int));
X			yyv = (YYSTYPE *) realloc(yyv, yymaxdepth * sizeof(YYSTYPE));
X			if (yys==0 || yyv==0) {
X			    yyerror( (nl_msg(30002,"yacc stack overflow")) );
X			    YYABORT;
X			    }
X			/* Reset pointers into stack */
X			yy_ps = (yy_ps - yys_old) + yys;
X			yyps = (yyps - yys_old) + yys;
X			yy_pv = (yy_pv - yyv_old) + yyv;
X			yypv = (yypv - yyv_old) + yyv;
# endif
X
X		}
X		*yy_ps = yy_state;
X		*++yy_pv = yyval;
X
X		/*
X		** we have a new state - find out what to do
X		*/
X	yy_newstate:
X		if ( ( yy_n = yypact[ yy_state ] ) <= YYFLAG )
X			goto yydefault;		/* simple state */
#if YYDEBUG
X		/*
X		** if debugging, need to mark whether new token grabbed
X		*/
X		yytmp = yychar < 0;
#endif
X		if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
X			yychar = 0;		/* reached EOF */
#if YYDEBUG
X		if ( yydebug && yytmp )
X		{
X			register int yy_i;
X
X			printf( "Received token " );
X			if ( yychar == 0 )
X				printf( "end-of-file\n" );
X			else if ( yychar < 0 )
X				printf( "-none-\n" );
X			else
X			{
X				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
X					yy_i++ )
X				{
X					if ( yytoks[yy_i].t_val == yychar )
X						break;
X				}
X				printf( "%s\n", yytoks[yy_i].t_name );
X			}
X		}
#endif /* YYDEBUG */
X		if ( ( ( yy_n += yychar ) < 0 ) || ( yy_n >= YYLAST ) )
X			goto yydefault;
X		if ( yychk[ yy_n = yyact[ yy_n ] ] == yychar )	/*valid shift*/
X		{
X			yychar = -1;
X			yyval = yylval;
X			yy_state = yy_n;
X			if ( yyerrflag > 0 )
X				yyerrflag--;
X			goto yy_stack;
X		}
X
X	yydefault:
X		if ( ( yy_n = yydef[ yy_state ] ) == -2 )
X		{
#if YYDEBUG
X			yytmp = yychar < 0;
#endif
X			if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
X				yychar = 0;		/* reached EOF */
#if YYDEBUG
X			if ( yydebug && yytmp )
X			{
X				register int yy_i;
X
X				printf( "Received token " );
X				if ( yychar == 0 )
X					printf( "end-of-file\n" );
X				else if ( yychar < 0 )
X					printf( "-none-\n" );
X				else
X				{
X					for ( yy_i = 0;
X						yytoks[yy_i].t_val >= 0;
X						yy_i++ )
X					{
X						if ( yytoks[yy_i].t_val
X							== yychar )
X						{
X							break;
X						}
X					}
X					printf( "%s\n", yytoks[yy_i].t_name );
X				}
X			}
#endif /* YYDEBUG */
X			/*
X			** look through exception table
X			*/
X			{
X				register int *yyxi = yyexca;
X
X				while ( ( *yyxi != -1 ) ||
X					( yyxi[1] != yy_state ) )
X				{
X					yyxi += 2;
X				}
X				while ( ( *(yyxi += 2) >= 0 ) &&
X					( *yyxi != yychar ) )
X					;
X				if ( ( yy_n = yyxi[1] ) < 0 )
X					YYACCEPT;
X			}
X		}
X
X		/*
X		** check for syntax error
X		*/
X		if ( yy_n == 0 )	/* have an error */
X		{
X			/* no worry about speed here! */
X			switch ( yyerrflag )
X			{
X			case 0:		/* new error */
X				yyerror( (nl_msg(30003,"syntax error")) );
X				yynerrs++;
X				goto skip_init;
X			yyerrlab:
X				/*
X				** get globals into registers.
X				** we have a user generated syntax type error
X				*/
X				yy_pv = yypv;
X				yy_ps = yyps;
X				yy_state = yystate;
X				yynerrs++;
X			skip_init:
X			case 1:
X			case 2:		/* incompletely recovered error */
X					/* try again... */
X				yyerrflag = 3;
X				/*
X				** find state where "error" is a legal
X				** shift action
X				*/
X				while ( yy_ps >= yys )
X				{
X					yy_n = yypact[ *yy_ps ] + YYERRCODE;
X					if ( yy_n >= 0 && yy_n < YYLAST &&
X						yychk[yyact[yy_n]] == YYERRCODE)					{
X						/*
X						** simulate shift of "error"
X						*/
X						yy_state = yyact[ yy_n ];
X						goto yy_stack;
X					}
X					/*
X					** current state has no shift on
X					** "error", pop stack
X					*/
#if YYDEBUG
#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
X					if ( yydebug )
X						printf( _POP_, *yy_ps,
X							yy_ps[-1] );
#	undef _POP_
#endif
X					yy_ps--;
X					yy_pv--;
X				}
X				/*
X				** there is no state on stack with "error" as
X				** a valid shift.  give up.
X				*/
X				YYABORT;
X			case 3:		/* no shift yet; eat a token */
#if YYDEBUG
X				/*
X				** if debugging, look up token in list of
X				** pairs.  0 and negative shouldn't occur,
X				** but since timing doesn't matter when
X				** debugging, it doesn't hurt to leave the
X				** tests here.
X				*/
X				if ( yydebug )
X				{
X					register int yy_i;
X
X					printf( "Error recovery discards " );
X					if ( yychar == 0 )
X						printf( "token end-of-file\n" );
X					else if ( yychar < 0 )
X						printf( "token -none-\n" );
X					else
X					{
X						for ( yy_i = 0;
X							yytoks[yy_i].t_val >= 0;
X							yy_i++ )
X						{
X							if ( yytoks[yy_i].t_val
X								== yychar )
X							{
X								break;
X							}
X						}
X						printf( "token %s\n",
X							yytoks[yy_i].t_name );
X					}
X				}
#endif /* YYDEBUG */
X				if ( yychar == 0 )	/* reached EOF. quit */
X					YYABORT;
X				yychar = -1;
X				goto yy_newstate;
X			}
X		}/* end if ( yy_n == 0 ) */
X		/*
X		** reduction by production yy_n
X		** put stack tops, etc. so things right after switch
X		*/
#if YYDEBUG
X		/*
X		** if debugging, print the string that is the user's
X		** specification of the reduction which is just about
X		** to be done.
X		*/
X		if ( yydebug )
X			printf( "Reduce by (%d) \"%s\"\n",
X				yy_n, yyreds[ yy_n ] );
#endif
X		yytmp = yy_n;			/* value to switch over */
X		yypvt = yy_pv;			/* $vars top of value stack */
X		/*
X		** Look in goto table for next state
X		** Sorry about using yy_state here as temporary
X		** register variable, but why not, if it works...
X		** If yyr2[ yy_n ] doesn't have the low order bit
X		** set, then there is no action to be done for
X		** this reduction.  So, no saving & unsaving of
X		** registers done.  The only difference between the
X		** code just after the if and the body of the if is
X		** the goto yy_stack in the body.  This way the test
X		** can be made before the choice of what to do is needed.
X		*/
X		{
X			/* length of production doubled with extra bit */
X			register int yy_len = yyr2[ yy_n ];
X
X			if ( !( yy_len & 01 ) )
X			{
X				yy_len >>= 1;
X				yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
X				yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
X					*( yy_ps -= yy_len ) + 1;
X				if ( yy_state >= YYLAST ||
X					yychk[ yy_state =
X					yyact[ yy_state ] ] != -yy_n )
X				{
X					yy_state = yyact[ yypgo[ yy_n ] ];
X				}
X				goto yy_stack;
X			}
X			yy_len >>= 1;
X			yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
X			yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
X				*( yy_ps -= yy_len ) + 1;
X			if ( yy_state >= YYLAST ||
X				yychk[ yy_state = yyact[ yy_state ] ] != -yy_n )
X			{
X				yy_state = yyact[ yypgo[ yy_n ] ];
X			}
X		}
X					/* save until reenter driver code */
X		yystate = yy_state;
X		yyps = yy_ps;
X		yypv = yy_pv;
X	}
X	/*
X	** code supplied by user is placed in this switch
X	*/
X	switch( yytmp )
X	{
X		
case 17:{         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@STRING"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } break;
case 18:{         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@STRING"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } break;
case 19:{         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@STRING"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } break;
case 20:{         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@STRING"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } break;
case 21:{         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@PREAMBLE"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } break;
case 22:{         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@PREAMBLE"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } break;
case 23:{         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@PREAMBLE"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } break;
case 24:{         
X                beginIdx = SkipNewLineSpace(uebergabe);
X                fprintf(tempDatei,"@PREAMBLE"); 
X                fprintf(tempDatei,"%s\n",&uebergabe[beginIdx]); 
X                ueIdx = 0;
X              } break;
case 67:{                 
X                  GetKey();
X                } break;
case 68:{
X                  GetKey();
X                } break;
case 69:{
X                  GetKey();
X                } break;
case 70:{
X                  GetKey();
X                } break;
case 71:{
X                  GetKey();
X                } break;
case 72:{
X                  GetKey();
X                } break;
case 73:{
X                  GetKey();
X                } break;
case 74:{
X                  GetKey();
X                } break;
case 75:{
X		  err = dbtMakeCard(&card);
X		  card->cardtype = article; 
X		  Scalloc(&card->cardtypestr, "article");
X                } break;
case 76:{
X		  err = dbtMakeCard(&card);
X		  card->cardtype = book; 
X		  Scalloc(&card->cardtypestr, "book");
X                } break;
case 77:{
X		  err = dbtMakeCard(&card);
X		  card->cardtype = booklet; 
X		  Scalloc(&card->cardtypestr, "booklet");
X                } break;
case 78:{
X		  err = dbtMakeCard(&card);
X		  card->cardtype = conference; 
X		  Scalloc(&card->cardtypestr, "conference");
X                } break;
case 79:{
X		  err = dbtMakeCard(&card);
X		  card->cardtype = inbook; 
X		  Scalloc(&card->cardtypestr, "inbook");
X                } break;
case 80:{
X		  err = dbtMakeCard(&card);
X		  card->cardtype = incollection; 
X		  Scalloc(&card->cardtypestr, "incollection");
X                } break;
case 81:{
X		  err = dbtMakeCard(&card);
X		  card->cardtype = inproceedings; 
X		  Scalloc(&card->cardtypestr, "inproceedings");
X                } break;
case 82:{
X		  err = dbtMakeCard(&card);
X		  card->cardtype = manual; 
X		  Scalloc(&card->cardtypestr, "manual");
X                } break;
case 83:{
X		  err = dbtMakeCard(&card);
X		  card->cardtype = mastersthesis; 
X		  Scalloc(&card->cardtypestr, "mastersthesis");
X                } break;
case 84:{
X		  err = dbtMakeCard(&card);
X		  card->cardtype = misc; 
X		  Scalloc(&card->cardtypestr, "misc");
X                } break;
case 85:{
X		  err = dbtMakeCard(&card);
X		  card->cardtype = phdthesis; 
X		  Scalloc(&card->cardtypestr, "phdthesis");
X                } break;
case 86:{
X		  err = dbtMakeCard(&card);
X		  card->cardtype = proceedings; 
X		  Scalloc(&card->cardtypestr, "proceedings");
X                } break;
case 87:{
X		  err = dbtMakeCard(&card);
X		  card->cardtype = techreport; 
X		  Scalloc(&card->cardtypestr, "techreport");
X                } break;
case 88:{
X		  err = dbtMakeCard(&card);
X		  card->cardtype = unpublished; 
X		  Scalloc(&card->cardtypestr, "unpublished");
X                } break;
case 93:{
X                  PushSign(&key, yypvt[-1]);
X                } break;
case 94:{
X                  PushSign(&key, yypvt[-1]);
X                } break;
case 95:{
X                  PushSign(&key, yypvt[-0]);
X                } break;
case 96:{
X                  PushSign(&key, yypvt[-0]);
X                } break;
case 97:{
X                  PushSign(&key, yypvt[-0]);
X                } break;
case 107:{
X                  GetFldNameCont();
X                } break;
case 108:{
X                  GetFldNameCont();
X                } break;
case 109:{
X                  PushSign(&fldname, yypvt[-1]);
X                  ueIdx = 0;
X                } break;
case 110:{
X                  PushSign(&fldname, yypvt[-0]);
X                  ueIdx = 0;
X                } break;
X	}
X	goto yystack;		/* reset registers in driver code */
}
X
# ifdef __RUNTIME_YYMAXDEPTH
X
static int allocate_stacks() {
X	/* allocate the yys and yyv stacks */
X	yys = (int *) malloc(yymaxdepth * sizeof(int));
X	yyv = (YYSTYPE *) malloc(yymaxdepth * sizeof(YYSTYPE));
X
X	if (yys==0 || yyv==0) {
X	   yyerror( (nl_msg(30004,"unable to allocate space for yacc stacks")) );
X	   return(1);
X	   }
X	else return(0);
X
}
X
X
static void free_stacks() {
X	if (yys!=0) free((char *) yys);
X	if (yyv!=0) free((char *) yyv);
}
X
# endif  /* defined(__RUNTIME_YYMAXDEPTH) */
X
SHAR_EOF
echo 'File bib_file.c is complete' &&
chmod 0644 bib_file.c ||
echo 'restore of bib_file.c failed'
Wc_c="`wc -c < 'bib_file.c'`"
test 54434 -eq "$Wc_c" ||
	echo 'bib_file.c: original size 54434, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bib_flex.c ==============
if test -f 'bib_flex.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bib_flex.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bib_flex.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bib_flex.c' &&
/* A lexical scanner generated by flex */
X
/* scanner skeleton version:
X * $Header: /usr/fsys/odin/a/vern/flex/RCS/flex.skel,v 2.16 90/08/03 14:09:36 vern Exp $
X */
X
#define FLEX_SCANNER
X
#include <stdio.h>
X
X
/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif
X
X
#ifdef __cplusplus
X
#include <stdlib.h>
#include <osfcn.h>
X
/* use prototypes in function declarations */
#define YY_USE_PROTOS
X
/* the "const" storage-class-modifier is valid */
#define YY_USE_CONST
X
#else	/* ! __cplusplus */
X
#ifdef __STDC__
X
#ifdef __GNUC__
#else
#include <stdlib.h>
#endif	/* __GNUC__ */
X
#define YY_USE_PROTOS
#define YY_USE_CONST
X
#endif	/* __STDC__ */
#endif	/* ! __cplusplus */
X
X
#ifdef __TURBOC__
#define YY_USE_CONST
#endif
X
X
#ifndef YY_USE_CONST
#define const
#endif
X
X
#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
/* we can't get here if it's an ANSI C compiler, or a C++ compiler,
X * so it's got to be a K&R compiler, and therefore there's no standard
X * place from which to include these definitions
X */
char *malloc();
int free();
int read();
#endif
X
X
/* amount of stuff to slurp up with each read */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif
X
/* returned upon end-of-file */
#define YY_END_TOK 0
X
/* copy whatever the last rule matched to the standard output */
X
/* cast to (char *) is because for 8-bit chars, yytext is (unsigned char *) */
/* this used to be an fputs(), but since the string might contain NUL's,
X * we now use fwrite()
X */
#define ECHO (void) fwrite( (char *) yytext, yyleng, 1, yyout )
X
/* gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
X * is returned in "result".
X */
#define YY_INPUT(buf,result,max_size) \
X	if ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \
X	    YY_FATAL_ERROR( "read() in flex scanner failed" );
#define YY_NULL 0
X
/* no semi-colon after return; correct usage is to write "yyterminate();" -
X * we don't want an extra ';' after the "return" because that will cause
X * some compilers to complain about unreachable statements.
X */
#define yyterminate() return ( YY_NULL )
X
/* report a fatal error */
X
/* The funky do-while is used to turn this macro definition into
X * a single C statement (which needs a semi-colon terminator).
X * This avoids problems with code like:
X *
X * 	if ( something_happens )
X *		YY_FATAL_ERROR( "oops, the something happened" );
X *	else
X *		everything_okay();
X *
X * Prior to using the do-while the compiler would get upset at the
X * "else" because it interpreted the "if" statement as being all
X * done when it reached the ';' after the YY_FATAL_ERROR() call.
X */
X
#define YY_FATAL_ERROR(msg) \
X	do \
X		{ \
X		(void) fputs( msg, stderr ); \
X		(void) putc( '\n', stderr ); \
X		exit( 1 ); \
X		} \
X	while ( 0 )
X
/* default yywrap function - always treat EOF as an EOF */
#define yywrap() 1
X
/* enter a start condition.  This macro really ought to take a parameter,
X * but we do it the disgusting crufty way forced on us by the ()-less
X * definition of BEGIN
X */
#define BEGIN yy_start = 1 + 2 *
X
/* action number for EOF rule of a given start state */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
X
/* special action meaning "start processing a new file" */
#define YY_NEW_FILE \
X	do \
X		{ \
X		yy_init_buffer( yy_current_buffer, yyin ); \
X		yy_load_buffer_state(); \
X		} \
X	while ( 0 )
X
/* default declaration of generated scanner - a define so the user can
X * easily add parameters
X */
#define YY_DECL int yylex YY_PROTO(( void )) 
X
/* code executed at the end of each rule */
#define YY_BREAK break;
X
#define YY_END_OF_BUFFER_CHAR 0
X
#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2) /* size of default input buffer */
#endif
X
typedef struct yy_buffer_state *YY_BUFFER_STATE;
X
#define YY_CHAR char
# line 1 "b.l"
#define INITIAL 0
# line 2 "b.l"
#include "b.tab.h"
#include <X11/Intrinsic.h>
#include "bibview.h"
X
extern char yylval;
extern int ueIdx;
extern char uebergabe[];
extern int yynline;
extern int yynflexcalls;
X
X
# line 16 "b.l"
X
/* done after the current pattern has been matched and before the
X * corresponding action - sets up yytext
X */
#define YY_DO_BEFORE_ACTION \
X	yytext = yy_bp; \
X	yyleng = yy_cp - yy_bp; \
X	yy_hold_char = *yy_cp; \
X	*yy_cp = '\0'; \
X	yy_c_buf_p = yy_cp;
X
#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2
X
/* return all but the first 'n' matched characters back to the input stream */
#define yyless(n) \
X	do \
X		{ \
X		/* undo effects of setting up yytext */ \
X		*yy_cp = yy_hold_char; \
X		yy_c_buf_p = yy_cp = yy_bp + n; \
X		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
X		} \
X	while ( 0 )
X
#define unput(c) yyunput( c, yytext )
X
X
struct yy_buffer_state
X    {
X    FILE *yy_input_file;
X
X    YY_CHAR *yy_ch_buf;		/* input buffer */
X    YY_CHAR *yy_buf_pos;	/* current position in input buffer */
X
X    /* size of input buffer in bytes, not including room for EOB characters*/
X    int yy_buf_size;	
X
X    /* number of characters read into yy_ch_buf, not including EOB characters */
X    int yy_n_chars;
X
X    int yy_eof_status;		/* whether we've seen an EOF on this buffer */
#define EOF_NOT_SEEN 0
X    /* "pending" happens when the EOF has been seen but there's still
X     * some text process
X     */
#define EOF_PENDING 1
#define EOF_DONE 2
X    };
X
static YY_BUFFER_STATE yy_current_buffer;
X
/* we provide macros for accessing buffer states in case in the
X * future we want to put the buffer states in a more general
X * "scanner state"
X */
#define YY_CURRENT_BUFFER yy_current_buffer
X
X
/* yy_hold_char holds the character lost when yytext is formed */
static YY_CHAR yy_hold_char;
X
static int yy_n_chars;		/* number of characters read into yy_ch_buf */
X
X
X
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif
X
#ifndef YY_USER_INIT
#define YY_USER_INIT
#endif
X
extern YY_CHAR *yytext;
extern int yyleng;
extern FILE *yyin, *yyout;
X
YY_CHAR *yytext;
int yyleng;
X
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
X
#define YY_END_OF_BUFFER 30
typedef int yy_state_type;
static const short int yy_accept[141] =
X    {   0,
X        0,    0,   30,   28,   25,   25,   24,   17,   19,   20,
X       18,   26,   23,   28,   21,   22,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    4,    0,    0,    0,    0,    0,    0,   12,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        0,    0,    0,    7,    0,    0,   10,    0,    0,    0,
X        0,    1,    0,    0,    3,    5,    0,    0,    0,    0,
X
X        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
X        2,    0,    0,    0,    0,    0,    0,    0,   13,    0,
X        0,    0,    6,    0,    0,    0,    0,   15,    0,    0,
X        0,    0,   14,   16,    8,    0,    0,    9,   11,    0
X    } ;
X
static const YY_CHAR yy_ec[128] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    2,    1,    4,    5,    1,    1,    1,    1,    6,
X        7,    1,    1,    8,    1,    1,    1,    9,    9,    9,
X        9,    9,    9,    9,    9,    9,    9,    1,    1,    1,
X       10,    1,    1,   11,   12,   13,   14,   15,   16,   17,
X       18,   19,   20,    9,   21,   22,   23,   24,   25,   26,
X        9,   27,   28,   29,   30,    9,    9,    9,    9,    9,
X        1,    1,    1,    1,    1,    1,   12,   13,   14,   15,
X
X       16,   17,   18,   19,   20,    9,   21,   22,   23,   24,
X       25,   26,    9,   27,   28,   29,   30,    9,    9,    9,
X        9,    9,   31,    1,   32,    1,    1
X    } ;
X
static const YY_CHAR yy_meta[33] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
X        1,    1
X    } ;
X
static const short int yy_base[142] =
X    {   0,
X        0,   32,  155,  156,  156,  156,  156,  156,  156,  156,
X      156,  156,  156,   53,  156,  156,  127,  128,  127,  127,
X        0,    0,  121,  133,  124,  118,  121,  121,    0,    0,
X      116,  128,    0,  115,  127,  114,  119,  117,  120,  111,
X      110,  107,  103,  103,  117,  101,  117,  114,  107,  107,
X       95,  110,  101,  106,   96,   98,   94,  106,  101,  156,
X       97,   92,   98,   89,   85,   98,   88,   93,   81,   86,
X       84,   91,   82,   76,   86,   88,   84,   81,   82,   75,
X       80,   66,   78,  156,   77,   76,  156,   63,   62,   67,
X       73,  156,   61,   66,  156,  156,   61,   70,   64,   49,
X
X       57,   59,   54,   47,   43,   56,   40,   53,   43,   33,
X      156,   36,   32,   39,   41,   36,   35,   38,  156,   35,
X       23,   35,  156,   25,   25,   20,   19,  156,   31,   21,
X       26,   21,  156,  156,  156,    2,    1,  156,  156,  156,
X        8
X    } ;
X
static const short int yy_def[142] =
X    {   0,
X      141,  141,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,    0,
X      140
X    } ;
X
static const short int yy_nxt[189] =
X    {   0,
X        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
X       14,   30,   40,   41,  140,   47,  140,  140,   32,   31,
X      140,  140,  140,   43,   48,   42,   33,   44,  139,  138,
X       15,   16,    4,    5,    6,    7,    8,    9,   10,   11,
X      137,   13,   14,  136,  135,  134,  133,  132,  131,  130,
X      129,  128,  127,  126,  125,  124,  123,  122,  121,  120,
X      119,  118,   15,   16,   17,   18,   19,  117,  116,  115,
X      114,  113,   20,  112,  111,   21,  110,  109,   22,  108,
X       23,   24,   25,  107,  106,  105,  104,  103,  102,  101,
X      100,   99,   98,   97,   96,   95,   94,   93,   92,   91,
X
X       90,   89,   88,   87,   86,   85,   84,   83,   82,   81,
X       80,   79,   78,   77,   76,   75,   74,   73,   72,   71,
X       70,   69,   68,   67,   66,   65,   64,   63,   62,   61,
X       60,   59,   58,   57,   56,   55,   54,   53,   52,   51,
X       50,   49,   46,   45,   39,   38,   37,   36,   35,   34,
X       29,   28,   27,   26,  140,    3,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140
X    } ;
X
static const short int yy_chk[189] =
X    {   0,
X        1,    1,    1,    1,    1,    1,    1,    1,  141,    1,
X        1,   21,   29,   29,    0,   33,    0,    0,   22,   21,
X        0,    0,    0,   30,   33,   29,   22,   30,  137,  136,
X        1,    1,    2,    2,    2,    2,    2,    2,    2,    2,
X      132,    2,    2,  131,  130,  129,  127,  126,  125,  124,
X      122,  121,  120,  118,  117,  116,  115,  114,  113,  112,
X      110,  109,    2,    2,   14,   14,   14,  108,  107,  106,
X      105,  104,   14,  103,  102,   14,  101,  100,   14,   99,
X       14,   14,   14,   98,   97,   94,   93,   91,   90,   89,
X       88,   86,   85,   83,   82,   81,   80,   79,   78,   77,
X
X       76,   75,   74,   73,   72,   71,   70,   69,   68,   67,
X       66,   65,   64,   63,   62,   61,   59,   58,   57,   56,
X       55,   54,   53,   52,   51,   50,   49,   48,   47,   46,
X       45,   44,   43,   42,   41,   40,   39,   38,   37,   36,
X       35,   34,   32,   31,   28,   27,   26,   25,   24,   23,
X       20,   19,   18,   17,    3,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140,  140,  140,
X      140,  140,  140,  140,  140,  140,  140,  140
X    } ;
X
static yy_state_type yy_last_accepting_state;
static YY_CHAR *yy_last_accepting_cpos;
X
/* the intent behind this definition is that it'll catch
X * any uses of REJECT which flex missed
X */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
X
/* these variables are all declared out here so that section 3 code can
X * manipulate them
X */
/* points to current character in buffer */
static YY_CHAR *yy_c_buf_p = (YY_CHAR *) 0;
int yy_init = 1;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */
X
/* flag which is used to allow yywrap()'s to do buffer switches
X * instead of setting up a fresh yyin.  A bit of a hack ...
X */
static int yy_did_buffer_switch_on_eof;
X
static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( void ));
static void yyunput YY_PROTO(( YY_CHAR c, YY_CHAR *buf_ptr ));
void yyrestart YY_PROTO(( FILE *input_file ));
void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
void yy_load_buffer_state YY_PROTO(( void ));
YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
X
#define yy_new_buffer yy_create_buffer
X
#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif
X
YY_DECL
X    {
X    register yy_state_type yy_current_state;
X    register YY_CHAR *yy_cp, *yy_bp;
X    register int yy_act;
X
X
X
X
X
X    if ( yy_init )
X	{
X	YY_USER_INIT;
X
X	if ( ! yy_start )
X	    yy_start = 1;	/* first start state */
X
X	if ( ! yyin )
X	    yyin = stdin;
X
X	if ( ! yyout )
X	    yyout = stdout;
X
X	if ( yy_current_buffer )
X	    yy_init_buffer( yy_current_buffer, yyin );
X	else
X	    yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
X
X	yy_load_buffer_state();
X
X	yy_init = 0;
X	}
X
X    while ( 1 )		/* loops until end-of-file is reached */
X	{
X	yy_cp = yy_c_buf_p;
X
X	/* support of yytext */
X	*yy_cp = yy_hold_char;
X
X	/* yy_bp points to the position in yy_ch_buf of the start of the
X	 * current run.
X	 */
X	yy_bp = yy_cp;
X
X	yy_current_state = yy_start;
yy_match:
X	do
X	    {
X	    register YY_CHAR yy_c = yy_ec[*yy_cp];
X	    if ( yy_accept[yy_current_state] )
X		{
X		yy_last_accepting_state = yy_current_state;
X		yy_last_accepting_cpos = yy_cp;
X		}
X	    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X		{
X		yy_current_state = yy_def[yy_current_state];
X		if ( yy_current_state >= 141 )
X		    yy_c = yy_meta[yy_c];
X		}
X	    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	    ++yy_cp;
X	    }
X	while ( yy_current_state != 140 );
X	yy_cp = yy_last_accepting_cpos;
X	yy_current_state = yy_last_accepting_state;
X
yy_find_action:
X	yy_act = yy_accept[yy_current_state];
X
X	YY_DO_BEFORE_ACTION;
X	YY_USER_ACTION;
X
do_action:	/* this label is used only to access EOF actions */
X
X
X	switch ( yy_act )
X	    {
X	    case 0: /* must backtrack */
X	    /* undo the effects of YY_DO_BEFORE_ACTION */
X	    *yy_cp = yy_hold_char;
X	    yy_cp = yy_last_accepting_cpos;
X	    yy_current_state = yy_last_accepting_state;
X	    goto yy_find_action;
X
case 1:
# line 19 "b.l"
{
X            yynflexcalls += 1;
X	    return STRING; 
X           }
X	YY_BREAK
case 2:
# line 26 "b.l"
{
X              yynflexcalls += 1;
X              return PREAMBLE; 
X             }
X	YY_BREAK
case 3:
# line 32 "b.l"
{
X                   yynflexcalls += 1;
X                   return ARTICLE;
X                  }
X	YY_BREAK
case 4:
# line 37 "b.l"
{
X                   yynflexcalls += 1;
X                   return BOOK;
X                  }
X	YY_BREAK
case 5:
# line 42 "b.l"
{
X                   yynflexcalls += 1;
X                   return BOOKLET;
X                  }
X	YY_BREAK
case 6:
# line 47 "b.l"
{
X                   yynflexcalls += 1;
X                   return CONFERENCE;
X                  }
X	YY_BREAK
case 7:
# line 52 "b.l"
{
X                   yynflexcalls += 1;
X                   return INBOOK;
X                  }
X	YY_BREAK
case 8:
# line 57 "b.l"
{
X                   yynflexcalls += 1;
X                   return INCOLLECTION;
X                  }
X	YY_BREAK
case 9:
# line 62 "b.l"
{
X                   yynflexcalls += 1;
X                   return INPROCEEDINGS;
X                  }
X	YY_BREAK
case 10:
# line 67 "b.l"
{
X                   yynflexcalls += 1;
X                   return MANUAL;
X                  }
X	YY_BREAK
case 11:
# line 72 "b.l"
{
X                   yynflexcalls += 1;
X                   return MASTERSTHESIS;
X                  }
X	YY_BREAK
case 12:
# line 77 "b.l"
{
X                   yynflexcalls += 1;
X                   return MISC;
X                  }
X	YY_BREAK
case 13:
# line 82 "b.l"
{
X                   yynflexcalls += 1;
X                   return PHDTHESIS;
X                  }
X	YY_BREAK
case 14:
# line 87 "b.l"
{
X                   yynflexcalls += 1;
X                   return PROCEEDINGS;
X                  }
X	YY_BREAK
case 15:
# line 92 "b.l"
{
X                   yynflexcalls += 1;
X                   return TECHREPORT;
X                  }
X	YY_BREAK
case 16:
# line 97 "b.l"
{
X                   yynflexcalls += 1;
X                   return UNPUBLISHED;
X                  }
X	YY_BREAK
case 17:
# line 102 "b.l"
{
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return ZAUN;
X           }
X	YY_BREAK
case 18:
# line 113 "b.l"
{
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return KOMMA;
X           }
X	YY_BREAK
case 19:
# line 123 "b.l"
{
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return LRKL;
X           }
X	YY_BREAK
case 20:
# line 133 "b.l"
{
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return RRKL;
X           }
X	YY_BREAK
case 21:
# line 143 "b.l"
{
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return LGKL;
X           }
X	YY_BREAK
case 22:
# line 153 "b.l"
{
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return RGKL;
X           }
X	YY_BREAK
case 23:
# line 163 "b.l"
{
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return EQ;
X           }
X	YY_BREAK
case 24:
# line 173 "b.l"
{
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return DAZ;
X           }
X	YY_BREAK
case 25:
# line 183 "b.l"
{
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             if (yytext[0] == '\n') yynline += 1;
X             return WHITE_SPACE;
X           }
X	YY_BREAK
case 26:
# line 194 "b.l"
{
X               yynflexcalls += 1;
X               yylval = yytext[0];
X               uebergabe[ueIdx] = yytext[0];
X               uebergabe[ueIdx+1] = '\0';
X               ueIdx++;
X               return BUCHSTABE_ZAHL;
X             }
X	YY_BREAK
case YY_STATE_EOF(INITIAL):
# line 204 "b.l"
{
X           yynflexcalls += 1;
X           YY_NEW_FILE;
X  /*         uebergabe[0] = '\0'; */
X           ueIdx = 0;
X           return 0;
X         }
X	YY_BREAK
case 28:
# line 214 "b.l"
{
X             yynflexcalls += 1;
X             yylval = yytext[0];
X             uebergabe[ueIdx] = yytext[0];
X             uebergabe[ueIdx+1] = '\0';
X             ueIdx++;
X             return ZEICHEN;
X           }
X	YY_BREAK
case 29:
# line 225 "b.l"
ECHO;
X	YY_BREAK
X
X	    case YY_END_OF_BUFFER:
X		{
X		/* amount of text matched not including the EOB char */
X		int yy_amount_of_matched_text = yy_cp - yytext - 1;
X
X		/* undo the effects of YY_DO_BEFORE_ACTION */
X		*yy_cp = yy_hold_char;
X
X		/* note that here we test for yy_c_buf_p "<=" to the position
X		 * of the first EOB in the buffer, since yy_c_buf_p will
X		 * already have been incremented past the NUL character
X		 * (since all states make transitions on EOB to the end-
X		 * of-buffer state).  Contrast this with the test in yyinput().
X		 */
X		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X		    /* this was really a NUL */
X		    {
X		    yy_state_type yy_next_state;
X
X		    yy_c_buf_p = yytext + yy_amount_of_matched_text;
X
X		    yy_current_state = yy_get_previous_state();
X
X		    /* okay, we're now positioned to make the
X		     * NUL transition.  We couldn't have
X		     * yy_get_previous_state() go ahead and do it
X		     * for us because it doesn't know how to deal
X		     * with the possibility of jamming (and we
X		     * don't want to build jamming into it because
X		     * then it will run more slowly)
X		     */
X
X		    yy_next_state = yy_try_NUL_trans( yy_current_state );
X
X		    yy_bp = yytext + YY_MORE_ADJ;
X
X		    if ( yy_next_state )
X			{
X			/* consume the NUL */
X			yy_cp = ++yy_c_buf_p;
X			yy_current_state = yy_next_state;
X			goto yy_match;
X			}
X
X		    else
X			{
X			    yy_cp = yy_last_accepting_cpos;
X			    yy_current_state = yy_last_accepting_state;
X			goto yy_find_action;
X			}
X		    }
X
X		else switch ( yy_get_next_buffer() )
X		    {
X		    case EOB_ACT_END_OF_FILE:
X			{
X			yy_did_buffer_switch_on_eof = 0;
X
X			if ( yywrap() )
X			    {
X			    /* note: because we've taken care in
X			     * yy_get_next_buffer() to have set up yytext,
X			     * we can now set up yy_c_buf_p so that if some
X			     * total hoser (like flex itself) wants
X			     * to call the scanner after we return the
X			     * YY_NULL, it'll still work - another YY_NULL
X			     * will get returned.
X			     */
X			    yy_c_buf_p = yytext + YY_MORE_ADJ;
X
X			    yy_act = YY_STATE_EOF((yy_start - 1) / 2);
X			    goto do_action;
X			    }
X
X			else
X			    {
X			    if ( ! yy_did_buffer_switch_on_eof )
X				YY_NEW_FILE;
X			    }
X			}
X			break;
X
X		    case EOB_ACT_CONTINUE_SCAN:
X			yy_c_buf_p = yytext + yy_amount_of_matched_text;
X
X			yy_current_state = yy_get_previous_state();
X
X			yy_cp = yy_c_buf_p;
X			yy_bp = yytext + YY_MORE_ADJ;
X			goto yy_match;
X
X		    case EOB_ACT_LAST_MATCH:
X			yy_c_buf_p =
X			    &yy_current_buffer->yy_ch_buf[yy_n_chars];
X
X			yy_current_state = yy_get_previous_state();
X
X			yy_cp = yy_c_buf_p;
X			yy_bp = yytext + YY_MORE_ADJ;
X			goto yy_find_action;
X		    }
X		break;
X		}
X
X	    default:
#ifdef FLEX_DEBUG
X		printf( "action # %d\n", yy_act );
#endif
X		YY_FATAL_ERROR(
X			"fatal flex scanner internal error--no action found" );
X	    }
X	}
X    }
X
X
/* yy_get_next_buffer - try to read in a new buffer
X *
X * synopsis
X *     int yy_get_next_buffer();
X *     
X * returns a code representing an action
X *     EOB_ACT_LAST_MATCH - 
X *     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
X *     EOB_ACT_END_OF_FILE - end of file
X */
X
static int yy_get_next_buffer()
X
X    {
X    register YY_CHAR *dest = yy_current_buffer->yy_ch_buf;
X    register YY_CHAR *source = yytext - 1; /* copy prev. char, too */
X    register int number_to_move, i;
X    int ret_val;
X
X    if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
X	YY_FATAL_ERROR(
X		"fatal flex scanner internal error--end of buffer missed" );
X
X    /* try to read more data */
X
X    /* first move last chars to start of buffer */
X    number_to_move = yy_c_buf_p - yytext;
X
X    for ( i = 0; i < number_to_move; ++i )
X	*(dest++) = *(source++);
X
X    if ( yy_current_buffer->yy_eof_status != EOF_NOT_SEEN )
X	/* don't do the read, it's not guaranteed to return an EOF,
X	 * just force an EOF
X	 */
X	yy_n_chars = 0;
X
X    else
X	{
X	int num_to_read = yy_current_buffer->yy_buf_size - number_to_move - 1;
X
X	if ( num_to_read > YY_READ_BUF_SIZE )
X	    num_to_read = YY_READ_BUF_SIZE;
X
X	else if ( num_to_read <= 0 )
X	    YY_FATAL_ERROR( "fatal error - scanner input buffer overflow" );
X
X	/* read in more data */
X	YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
X		  yy_n_chars, num_to_read );
X	}
X
X    if ( yy_n_chars == 0 )
X	{
X	if ( number_to_move == 1 )
X	    {
X	    ret_val = EOB_ACT_END_OF_FILE;
X	    yy_current_buffer->yy_eof_status = EOF_DONE;
X	    }
X
X	else
X	    {
X	    ret_val = EOB_ACT_LAST_MATCH;
X	    yy_current_buffer->yy_eof_status = EOF_PENDING;
X	    }
X	}
X
X    else
X	ret_val = EOB_ACT_CONTINUE_SCAN;
X
X    yy_n_chars += number_to_move;
X    yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
X    yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
X
X    /* yytext begins at the second character in yy_ch_buf; the first
X     * character is the one which preceded it before reading in the latest
X     * buffer; it needs to be kept around in case it's a newline, so
X     * yy_get_previous_state() will have with '^' rules active
X     */
X
X    yytext = &yy_current_buffer->yy_ch_buf[1];
X
X    return ( ret_val );
X    }
X
X
/* yy_get_previous_state - get the state just before the EOB char was reached
X *
X * synopsis
X *     yy_state_type yy_get_previous_state();
X */
X
static yy_state_type yy_get_previous_state()
X
X    {
X    register yy_state_type yy_current_state;
X    register YY_CHAR *yy_cp;
X
X    yy_current_state = yy_start;
X
X    for ( yy_cp = yytext + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
X	{
X	register YY_CHAR yy_c = (*yy_cp ? yy_ec[*yy_cp] : 1);
X	if ( yy_accept[yy_current_state] )
X	    {
X	    yy_last_accepting_state = yy_current_state;
X	    yy_last_accepting_cpos = yy_cp;
X	    }
X	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	    {
X	    yy_current_state = yy_def[yy_current_state];
X	    if ( yy_current_state >= 141 )
X		yy_c = yy_meta[yy_c];
X	    }
X	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X	}
X
X    return ( yy_current_state );
X    }
X
X
/* yy_try_NUL_trans - try to make a transition on the NUL character
X *
X * synopsis
X *     next_state = yy_try_NUL_trans( current_state );
X */
X
#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( register yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
register yy_state_type yy_current_state;
#endif
X
X    {
X    register int yy_is_jam;
X    register YY_CHAR *yy_cp = yy_c_buf_p;
X
X    register YY_CHAR yy_c = 1;
X    if ( yy_accept[yy_current_state] )
X	{
X	yy_last_accepting_state = yy_current_state;
X	yy_last_accepting_cpos = yy_cp;
X	}
X    while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
X	{
X	yy_current_state = yy_def[yy_current_state];
X	if ( yy_current_state >= 141 )
X	    yy_c = yy_meta[yy_c];
X	}
X    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
X    yy_is_jam = (yy_current_state == 140);
X
X    return ( yy_is_jam ? 0 : yy_current_state );
X    }
X
X
#ifdef YY_USE_PROTOS
static void yyunput( YY_CHAR c, register YY_CHAR *yy_bp )
#else
static void yyunput( c, yy_bp )
YY_CHAR c;
register YY_CHAR *yy_bp;
#endif
X
X    {
X    register YY_CHAR *yy_cp = yy_c_buf_p;
X
X    /* undo effects of setting up yytext */
X    *yy_cp = yy_hold_char;
X
X    if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
SHAR_EOF
true || echo 'restore of bib_flex.c failed'
fi
echo 'End of  part 4'
echo 'File bib_flex.c is continued in part 5'
echo 5 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
