Path: uunet!dtix!darwin.sura.net!mips!msi!dcmartin
From: liebla@informatik.tu-muenchen.de (Armin Liebl)
Newsgroups: comp.sources.x
Subject: v18i103: bibview - BibTeX GUI, Part05/20
Message-ID: <1992Aug27.161434.25344@msi.com>
Date: 27 Aug 92 16:14:34 GMT
References: <csx-18i099-bibview@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1559
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: Armin Liebl <liebla@informatik.tu-muenchen.de>
Posting-number: Volume 18, Issue 103
Archive-name: bibview/part05

#!/bin/sh
# this is part.05 (part 5 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file bib_flex.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 5; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping bib_flex.c'
else
echo 'x - continuing file bib_flex.c'
sed 's/^X//' << 'SHAR_EOF' >> 'bib_flex.c' &&
X	{ /* need to shift things up to make room */
X	register int number_to_move = yy_n_chars + 2; /* +2 for EOB chars */
X	register YY_CHAR *dest =
X	    &yy_current_buffer->yy_ch_buf[yy_current_buffer->yy_buf_size + 2];
X	register YY_CHAR *source =
X	    &yy_current_buffer->yy_ch_buf[number_to_move];
X
X	while ( source > yy_current_buffer->yy_ch_buf )
X	    *--dest = *--source;
X
X	yy_cp += dest - source;
X	yy_bp += dest - source;
X	yy_n_chars = yy_current_buffer->yy_buf_size;
X
X	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
X	    YY_FATAL_ERROR( "flex scanner push-back overflow" );
X	}
X
X    if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
X	yy_cp[-2] = '\n';
X
X    *--yy_cp = c;
X
X    /* note: the formal parameter *must* be called "yy_bp" for this
X     *       macro to now work correctly
X     */
X    YY_DO_BEFORE_ACTION; /* set up yytext again */
X    }
X
X
#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
X
X    {
X    int c;
X    YY_CHAR *yy_cp = yy_c_buf_p;
X
X    *yy_cp = yy_hold_char;
X
X    if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
X	{
X	/* yy_c_buf_p now points to the character we want to return.
X	 * If this occurs *before* the EOB characters, then it's a
X	 * valid NUL; if not, then we've hit the end of the buffer.
X	 */
X	if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
X	    /* this was really a NUL */
X	    *yy_c_buf_p = '\0';
X
X	else
X	    { /* need more input */
X	    yytext = yy_c_buf_p;
X	    ++yy_c_buf_p;
X
X	    switch ( yy_get_next_buffer() )
X		{
X		case EOB_ACT_END_OF_FILE:
X		    {
X		    if ( yywrap() )
X			{
X			yy_c_buf_p = yytext + YY_MORE_ADJ;
X			return ( EOF );
X			}
X
X		    YY_NEW_FILE;
X
#ifdef __cplusplus
X		    return ( yyinput() );
#else
X		    return ( input() );
#endif
X		    }
X		    break;
X
X		case EOB_ACT_CONTINUE_SCAN:
X		    yy_c_buf_p = yytext + YY_MORE_ADJ;
X		    break;
X
X		case EOB_ACT_LAST_MATCH:
#ifdef __cplusplus
X		    YY_FATAL_ERROR( "unexpected last match in yyinput()" );
#else
X		    YY_FATAL_ERROR( "unexpected last match in input()" );
#endif
X		}
X	    }
X	}
X
X    c = *yy_c_buf_p;
X    yy_hold_char = *++yy_c_buf_p;
X
X    return ( c );
X    }
X
X
#ifdef YY_USE_PROTOS
void yyrestart( FILE *input_file )
#else
void yyrestart( input_file )
FILE *input_file;
#endif
X
X    {
X    yy_init_buffer( yy_current_buffer, input_file );
X    yy_load_buffer_state();
X    }
X
X
#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif
X
X    {
X    if ( yy_current_buffer == new_buffer )
X	return;
X
X    if ( yy_current_buffer )
X	{
X	/* flush out information for old buffer */
X	*yy_c_buf_p = yy_hold_char;
X	yy_current_buffer->yy_buf_pos = yy_c_buf_p;
X	yy_current_buffer->yy_n_chars = yy_n_chars;
X	}
X
X    yy_current_buffer = new_buffer;
X    yy_load_buffer_state();
X
X    /* we don't actually know whether we did this switch during
X     * EOF (yywrap()) processing, but the only time this flag
X     * is looked at is after yywrap() is called, so it's safe
X     * to go ahead and always set it.
X     */
X    yy_did_buffer_switch_on_eof = 1;
X    }
X
X
#ifdef YY_USE_PROTOS
void yy_load_buffer_state( void )
#else
void yy_load_buffer_state()
#endif
X
X    {
X    yy_n_chars = yy_current_buffer->yy_n_chars;
X    yytext = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
X    yyin = yy_current_buffer->yy_input_file;
X    yy_hold_char = *yy_c_buf_p;
X    }
X
X
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif
X
X    {
X    YY_BUFFER_STATE b;
X
X    b = (YY_BUFFER_STATE) malloc( sizeof( struct yy_buffer_state ) );
X
X    if ( ! b )
X	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
X
X    b->yy_buf_size = size;
X
X    /* yy_ch_buf has to be 2 characters longer than the size given because
X     * we need to put in 2 end-of-buffer characters.
X     */
X    b->yy_ch_buf = (YY_CHAR *) malloc( (unsigned) (b->yy_buf_size + 2) );
X
X    if ( ! b->yy_ch_buf )
X	YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
X
X    yy_init_buffer( b, file );
X
X    return ( b );
X    }
X
X
#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif
X
X    {
X    if ( b == yy_current_buffer )
X	yy_current_buffer = (YY_BUFFER_STATE) 0;
X
X    free( (char *) b->yy_ch_buf );
X    free( (char *) b );
X    }
X
X
#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif
X
X    {
X    b->yy_input_file = file;
X
X    /* we put in the '\n' and start reading from [1] so that an
X     * initial match-at-newline will be true.
X     */
X
X    b->yy_ch_buf[0] = '\n';
X    b->yy_n_chars = 1;
X
X    /* we always need two end-of-buffer characters.  The first causes
X     * a transition to the end-of-buffer state.  The second causes
X     * a jam in that state.
X     */
X    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
X    b->yy_ch_buf[2] = YY_END_OF_BUFFER_CHAR;
X
X    b->yy_buf_pos = &b->yy_ch_buf[1];
X
X    b->yy_eof_status = EOF_NOT_SEEN;
X    }
# line 225 "b.l"
X
X
SHAR_EOF
echo 'File bib_flex.c is complete' &&
chmod 0644 bib_flex.c ||
echo 'restore of bib_flex.c failed'
Wc_c="`wc -c < 'bib_flex.c'`"
test 33489 -eq "$Wc_c" ||
	echo 'bib_flex.c: original size 33489, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bibview.c ==============
if test -f 'bibview.c' -a X"$1" != X"-c"; then
	echo 'x - skipping bibview.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bibview.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bibview.c' &&
/*********************************************************************/
/*  bibView: Administration of bibTex-Databases                      */
/*           (Verwaltung von bibTeX-Literaturdatenbanken)            */
/*                                                                   */
/*  Module:  bibview.c                                               */
/*                                                                   */
/*             - Main Program                                        */
/*             - Signal Handling                                     */
/*                                                                   */
/*  Author:  Holger Martin,  martinh@informatik.tu-muenchen.de       */
/*           Peter M. Urban, urban@informatik.tu-muenchen.de         */
/*                                                                   */
/*  History:                                                         */
/*    11.22.91  PMU  created                                         */
/*    05.26.92       Version 1.0 released                            */
/*                                                                   */
/*  Copyright 1992 TU MUENCHEN				 	     */
/*    See ./Copyright for complete rights and liability information. */
/*                                                                   */
/*********************************************************************/
X
X
#include <stdio.h>
#include <unistd.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Shell.h>
#include <X11/Xaw/Form.h>
#include <X11/Xaw/Paned.h>
#include <X11/Xaw/Box.h>
#include <X11/Xaw/Command.h>
#include <X11/Xaw/MenuButton.h>
#include <X11/Xaw/SimpleMenu.h>
#include <X11/Xaw/SmeBSB.h>
#include <X11/Xaw/SmeLine.h>
#include <X11/Xos.h>
#include "bibview.h"
#include "bitmaps/bv_ico64"
#include "bitmaps/bv_lst64"
#include "bitmaps/bv_mac64"
#include "bitmaps/bv_crd64"
#include "bitmaps/bv_hlp64"
#include "bitmaps/bv_ann64"
#include "bitmaps/chkmrk16"
#include "bitmaps/error32"
#include "bitmaps/warn32"
#include "bitmaps/notice32"
#include "bitmaps/quest32"
#ifdef GERMAN
#include "bitmaps/proggerm.xbm"
#else
#include "bitmaps/proginfo.xbm"
#endif
X
X
/* external global variables */
/* ------------------------- */
extern Widget desktop;
extern char *latexHeader, *latexFooter;
extern int latexHeaderLen, latexFooterLen;
X
X
/* exported global variables */
/* ------------------------- */
XXtAppContext app_context;
Widget topLevel;
Pixmap bvIconPixmap;
String bvIconName;
Pixmap lstIconPixmap;
Pixmap macIconPixmap;
Pixmap crdIconPixmap;
Pixmap helpIconPixmap;
Pixmap annoteIconPixmap;
Pixmap chkmarkPixmap;
Pixmap errorPixmap;
Pixmap warnPixmap;
Pixmap noticePixmap;
Pixmap questPixmap;
Pixmap progInfoPixmap;
X
X
/* local global variables */
/* ---------------------- */
X
/* fallback resources */
static char *fallback_resources[424] = {
#ifdef GERMAN
X   #include "fb_ger.h"
#else
X   #include "fb_res.h"
#endif
X   NULL
};
X
X
/* command line options */
typedef struct {
X   Boolean quiet;
X   Boolean iconsOnDesk;
X   Boolean makeBackup;
X   Boolean autoCheck;
X   Boolean reqFields;
X   String  bibfile;
X   String  rcfile;
} OptionsRec;
OptionsRec options;
X
#define Offset(field)  XtOffsetOf(OptionsRec, field)
XXtResource resources[] = {
X   { "quiet", "Quiet", XtRBoolean, sizeof(Boolean),
X        Offset(quiet), XtRImmediate, (XtPointer) FALSE },
X   { "iconsOnDesk", "IconsOnDesk", XtRBoolean, sizeof(Boolean),
X	Offset(iconsOnDesk), XtRImmediate, (XtPointer)FALSE },
X   { "makeBackup", "MakeBackup", XtRBoolean, sizeof(Boolean),
X	Offset(makeBackup), XtRImmediate, (XtPointer)TRUE },
X   { "autoCheck", "AutoCheck", XtRBoolean, sizeof(Boolean),
X	Offset(autoCheck), XtRImmediate, (XtPointer)TRUE },
X   { "reqFields", "ReqFields", XtRBoolean, sizeof(Boolean),
X	Offset(reqFields), XtRImmediate, (XtPointer)FALSE },
X   { "bibfile", "Bibfile", XtRString, sizeof(String),
X	Offset(bibfile), XtRString, (XtPointer)NULL },
X   { "rcfile", "Rcfile", XtRString, sizeof(String),
X	Offset(rcfile), XtRString, (XtPointer)NULL }
};
#undef Offset
X
static XrmOptionDescRec optionDesc[] = {
X   { "-quiet",       "*quiet",       XrmoptionNoArg, (XtPointer)"on" },
X   { "-iconsOnDesk", "*iconsOnDesk", XrmoptionNoArg, (XtPointer)"on" },
X   { "-makeBackup",  "*makeBackup",  XrmoptionNoArg, (XtPointer)"on" },
X   { "-autoCheck",   "*autoCheck",   XrmoptionNoArg, (XtPointer)"on" },
X   { "-reqFields",   "*reqFields",   XrmoptionNoArg, (XtPointer)"on" },
X   { "-file",        "*bibfile",     XrmoptionSepArg, (XtPointer)NULL },
X   { "-rcfile",      "*rcfile",      XrmoptionSepArg, (XtPointer)NULL }
};
X
X
/* local function prototypes */
static void printHelp (int argc, char **argv);
static void processCommandlineOptions (void);
static Boolean readBibfile (XtPointer clientData);
static void makeIconPixmaps (void);
static void installErrorHandlers (void);
static XtErrorHandler Xt_warningHandler (String warn);
static XtErrorHandler Xt_errorHandler (String error);
static int X_errorHandler (Display *dsp, XErrorEvent *event);
static int IO_errorHandler (Display *dsp);
static void signalHandler (int signal, int code);
static Errcode saveDataToTmpFiles (void);
static char *getErrorText (unsigned char code);
X
X
X
/*********************************************************************/
/* MAIN:                                                             */
/*********************************************************************/
int
main(int argc, char *argv[])
{
static char iconname[MAX_ICONNAMELEN+1];
static char *p, path[MAX_FILEPATHLEN+1];
int i, status;
X
X   topLevel = XtVaAppInitialize(&app_context, /* Appl context */
X                 "BibView",                   /* Appl class */
X                 optionDesc,                  /* cmdline options */ 
X		 XtNumber(optionDesc),
X                 &argc, argv,                 /* command line args */
X                 (String *)fallback_resources,/* fallback resources */
X		 NULL);                       /* end varargs list */
X
X   /* process commandline options */
X   XtGetApplicationResources(topLevel,
X                             (XtPointer) &options,
X                             resources, XtNumber(resources),
X                             (Arg *)NULL, 0);
X   if (argc > 1)
X      printHelp(argc, argv);
X   processCommandlineOptions();
X
X   /* read rc options file */
X   if (options.rcfile != NULL)
X      rcfReadCfgFile(options.rcfile);
X   else if (access(DEFAULT_RCFILE, R_OK) != -1) {
X      /* read file in current directory */
X      rcfReadCfgFile(DEFAULT_RCFILE);
X   }
X   else {
X      /* look for file in $HOME-Directory */
X      if ((p = (char *)getenv("HOME")) != NULL) {
X         strcpy(path, p);
X	 strcat(path, "/");
X	 strcat(path, DEFAULT_RCFILE);
X	 if (access(path, R_OK) != -1)
X	    rcfReadCfgFile(path);
X      }
X   }
X
X   /* create icon pixmaps, initialize main icon for bibview */
X   makeIconPixmaps();
X   sprintf(iconname, "%s %d.%d", PROGNAME, VERSION, PATCHLEVEL);
X   bvIconName = iconname;
X   XtVaSetValues(topLevel, 
X		 XtNiconPixmap, bvIconPixmap,
X		 XtNtitle, bvIconName,
X		 XtNiconName, bvIconName, NULL);
X
X   /* instance main window */
X   status = gwmMainWin();
X
X   XtRealizeWidget(topLevel);
/* XtInstallAllAccelerators(topLevel, topLevel); */
X
X   /* load a file from command line */
X   if (options.bibfile != NULL)
X      XtAppAddWorkProc(app_context, readBibfile, options.bibfile);
X
X   rcfSetPrintMode(FALSE);
X   rcfReadOptions(FALSE);
X   XtAppMainLoop(app_context);
}
X
X
X
/*********************************************************************/
/* LOCAL FUNCTIONS                                                   */
/*********************************************************************/
X
/*********************************************************************/
/* printHelp:                                                        */
/*   Process excess options and show help                            */
/*********************************************************************/
static void 
printHelp (int argc, char **argv)
{
static char *help[] = {
X "\n",
X "bibview: Usage\n",
X "         bibview understands all standard Xt command-line options.\n",
X "\n",
X "Additional options are as follows:\n",
X "   Option        Valid Range     Function\n",
X "   -quiet        none            Turn on/off beep on error\n",
X "   -iconsOnDesk  none            Keep icons on bibview desktop\n",
X "   -makeBackup   none            Save files to backup on save\n",
X "   -autoCheck    none            Turn on/off consistency checking\n",
X "   -reqFields    none            Disallow empty required fields\n",
X "   -file         bibTeX File     Load bibTeX-File on startup\n",
X "   -rcfile       bibview rcFile  Use specific configuration file\n",
X "   -help         none            Show this list\n",
X "\n",
X NULL
};
char **p;
int  i;
X
X   /* print help message */
X   p = help;
X   while (*p) {
X      fprintf(stderr, *p);
X      p++;
X   }
X
X   /* show illegal arguments */
X   if (strcmp(argv[1], "-help")) {
X      fprintf(stderr, "bibview: command line option unknown:\n");
X      for (i=1; i < argc; i++)
X         fprintf(stderr, " option: %s\n", argv[i]);
X   }
X   else {
X      /* just show help and exit */
X      exit(0);
X   }
}
X
X
/*********************************************************************/
/* processCommandlineOptions:                                        */
/*   Process options not controlling widgets                         */
/*********************************************************************/
static void 
processCommandlineOptions (void)
{
X   optionsStatus[OPT_BEEP_ON_ERROR]   = !options.quiet;
X   optionsStatus[OPT_BACKUP_ON_SAVE]  = options.makeBackup;
X   optionsStatus[OPT_ICON_ON_DESKTOP] = options.iconsOnDesk;
X   optionsStatus[OPT_AUTO_CHECK_BIB]  = options.autoCheck;
X   optionsStatus[OPT_REQUIRED_FIELDS] = options.reqFields;
}
X
X
/*********************************************************************/
/* readBibfile:                                                      */
/*   Read a bibfile with name given on command line                  */
/*********************************************************************/
static Boolean
readBibfile (XtPointer clientData)
{
String filename = (String)clientData;
BibPtr bp;
Position x;
Errcode status;
X
X   /* check whether desktop positioned already */
X   if (XtWindow(desktop) == (Window) NULL)
X      return(False);
X   XtVaGetValues(topLevel, XtNx, &x, NULL);
X   if (x == 0)
X      return(False);
X
X   /* desktop is there, open file and window */
X   if ((status = glbNewBibListEl(&bp)) != OK) {
X      guwError(status);
X      return(True);
X   }
X   strcpy(bp->filename, filename);
X   if ((filename[0]!='/') && (filename[0]!='~')){
X      getcwd(bp->filepath, MAX_FILEPATHLEN);
X      strcat(bp->filepath, "/");
X      strcat(bp->filepath, filename);
X      }
X   else
X      strcpy(bp->filepath, filename);
X   bp->mw=NULL;
X   bp->ew=NULL;
X
X   if ((status = bifFileRead(bp)) == BIF_EOPEN) {
X      glbDelBibListEl(bp);
X      guwError(status);
X      return(True);
X   }
X   if (status != BIF_OK) {
X      status = gueOpenBibErrWin(bp, (int)status); 
X      if (status == ERR_NOBIB)
X        glbDelBibListEl(bp); 
X      return(True);
X   }
X   if ((status = gubOpenBibWin(bp)) != OK) {
/*      glbDelBibListEl(bp); */
X      guwError(status);
X      return(True);
X   }
X
X
X   /* check cards, if option is on */
X   if (cotAutoCheckBib()) 
X      cseCheckBib(bp, False);      
X
X   return(True);
}
X
X
/*********************************************************************/
/* makeIconPixmaps:                                                  */
/*   Create all pixmaps for application                              */
/*********************************************************************/
static void 
makeIconPixmaps (void)
{
X   bvIconPixmap = XCreateBitmapFromData(XtDisplay(topLevel),
X	            RootWindowOfScreen(XtScreen(topLevel)),
X	            (char *)bv_ico64_bits,
X	            bv_ico64_width, bv_ico64_height);
X   lstIconPixmap = XCreateBitmapFromData(XtDisplay(topLevel),
X	            RootWindowOfScreen(XtScreen(topLevel)),
X	            (char *)bv_lst64_bits,
X	            bv_lst64_width, bv_lst64_height);
X   macIconPixmap = XCreateBitmapFromData(XtDisplay(topLevel),
X	            RootWindowOfScreen(XtScreen(topLevel)),
X	            (char *)bv_mac64_bits,
X	            bv_mac64_width, bv_mac64_height);
X   helpIconPixmap = XCreateBitmapFromData(XtDisplay(topLevel),
X	            RootWindowOfScreen(XtScreen(topLevel)),
X	            (char *)bv_help64_bits,
X	            bv_help64_width, bv_help64_height);
X   annoteIconPixmap = XCreateBitmapFromData(XtDisplay(topLevel),
X	            RootWindowOfScreen(XtScreen(topLevel)),
X	            (char *)bv_annote64_bits,
X	            bv_annote64_width, bv_annote64_height);
X   crdIconPixmap = XCreateBitmapFromData(XtDisplay(topLevel),
X	            RootWindowOfScreen(XtScreen(topLevel)),
X	            (char *)bv_crd64_bits,
X	            bv_crd64_width, bv_crd64_height);
X   chkmarkPixmap = XCreateBitmapFromData(XtDisplay(topLevel),
X	            RootWindowOfScreen(XtScreen(topLevel)),
X	            (char *)chkmrk16_bits,
X	            chkmrk16_width, chkmrk16_height);
X   errorPixmap   = XCreateBitmapFromData(XtDisplay(topLevel),
X	            RootWindowOfScreen(XtScreen(topLevel)),
X	            (char *)error32_bits,
X	            error32_width, error32_height);
X   warnPixmap    = XCreateBitmapFromData(XtDisplay(topLevel),
X	            RootWindowOfScreen(XtScreen(topLevel)),
X	            (char *)warn32_bits,
X	            warn32_width, warn32_height);
X   noticePixmap  = XCreateBitmapFromData(XtDisplay(topLevel),
X	            RootWindowOfScreen(XtScreen(topLevel)),
X	            (char *)notice32_bits,
X	            notice32_width, notice32_height);
X   questPixmap   = XCreateBitmapFromData(XtDisplay(topLevel),
X	            RootWindowOfScreen(XtScreen(topLevel)),
X	            (char *)quest32_bits,
X	            quest32_width, quest32_height);
X   progInfoPixmap =XCreateBitmapFromData(XtDisplay(topLevel),
X	            RootWindowOfScreen(XtScreen(topLevel)),
X	            (char *)proginfo_bits,
X	            proginfo_width, proginfo_height);
}
X
X
/*********************************************************************/
/* ERROR HANDLING FUNCTIONS                                          */
/*********************************************************************/
X
/*********************************************************************/
/* installErrorHandlers:                                             */
/*   Register signal, warning and error handlers                     */
/*********************************************************************/
static void
installErrorHandlers (void)
{
int i;
X
X   /* install signal handler */
X   for (i = 1; i<= 15; i++)
X      signal(i, signalHandler); 
X
X   /* install Xtoolkit handlers */
X   XtSetWarningHandler((XtErrorHandler)Xt_warningHandler);
X   XtSetErrorHandler((XtErrorHandler)Xt_errorHandler);
X
X   /* install X error handler */
X   XSetErrorHandler(X_errorHandler);
X   XSetIOErrorHandler(IO_errorHandler);
}
X
X
/*********************************************************************/
/* Xt_warningHandler:                                                */
/*   Xt warning handler                                              */
/*********************************************************************/
static XtErrorHandler
XXt_warningHandler (String warn)
{
}
X
X
/*********************************************************************/
/* Xt_errorHandler:                                                  */
/*   Xt warning handler                                              */
/*********************************************************************/
static XtErrorHandler
XXt_errorHandler (String error)
{
}
X
X
/*********************************************************************/
/* X_errorHandler:                                                   */
/*   Service X protocol errors                                       */
/*********************************************************************/
static int
XX_errorHandler (Display *dsp, XErrorEvent *event)
{
X  char msg[80];
X  XGetErrorText(dsp, event->error_code, msg, 80);
X  fprintf(stderr, "Error code %s\n", msg);
X  return(0);
}
X
X
/*********************************************************************/
/* IO_errorHandler:                                                  */
/*   Service I/O errors from X                                       */
/*********************************************************************/
static int
IO_errorHandler (Display *dsp)
{ 
X  fprintf(stderr, "Fatal Error on X Display %s\n",
X		  (char *)XDisplayName(NULL));
X  exit(1);
X
}
X
X
/*********************************************************************/
/* signalHandler:                                                    */
/*   Service signals                                                 */
/*********************************************************************/
static void
signalHandler (int signal, int code)
{
X
}
X
X
/*********************************************************************/
/* saveDataToTmpFiles:                                               */
/*   Attempt to save all loaded data to temp files                   */
/*********************************************************************/
static Errcode
saveDataToTmpFiles (void)
{
X
X   return(OK);
}
X
X
/*********************************************************************/
/* getErrorText:                                                     */
/*   Reads XerrorDB and returns string containing error description  */
/*********************************************************************/
static char *
getErrorText (unsigned char code)
{
X
}
X
X
SHAR_EOF
chmod 0644 bibview.c ||
echo 'restore of bibview.c failed'
Wc_c="`wc -c < 'bibview.c'`"
test 17691 -eq "$Wc_c" ||
	echo 'bibview.c: original size 17691, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bibview.h ==============
if test -f 'bibview.h' -a X"$1" != X"-c"; then
	echo 'x - skipping bibview.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bibview.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bibview.h' &&
/*********************************************************************/
/*  bibView: Administration of bibTex-Databases                      */
/*           (Verwaltung von bibTeX-Literaturdatenbanken)            */
/*                                                                   */
/*  Module:  bibview.h                                               */
/*                                                                   */
/*             - Headerfile                                          */
/*             -                                                     */
/*                                                                   */
/*  Author:  Holger Martin,  martinh@informatik.tu-muenchen.de       */
/*           Peter M. Urban, urban@informatik.tu-muenchen.de         */
/*                                                                   */
/*  History:                                                         */
/*    11.22.91  PMU  created                                         */
/*    05.26.92       Version 1.0 released                            */
/*                                                                   */
/*  Copyright 1991 Martin, Urban                                     */
/*    See ./Copyright for complete rights and liability information. */
/*                                                                   */
/*********************************************************************/
X
#include "patchlevel.h"
X
/* Macros and Definitions */
/* ---------------------- */
X
/* general stuff */
#define PROGNAME	   "bibView"
#define DEFAULT_RCFILE     ".bibviewrc"
#define MAX_BIBTEX_TYPES   14
#define MAX_ICONNAMELEN	   25
#define MAX_FILEPATHLEN    1024
#define MAX_FILENAMELEN    256
#define MAX_OPENFILE       256
#define MAXTREEROOTS       MAX_OPENFILE
#define MAX_NEW_USERDEF_FLDS 3
#define OK		   1
X
/* defines for window spacing */
#define BIBWIN_MARGIN	   20
#define SUBWIN_MARGIN	   20
#define BV_ICON_MARGIN	   10
#define BV_ICON_WIDTH	   75
#define LST_ICON_WIDTH	   75
#define LST_ICON_MARGIN	   10
#define CARDWIN_MARGIN     20
#define CARD_ICON_MARGIN   10
#define CARD_ICON_WIDTH	   75
#define BIBWIN_HSPACE	   40
#define BIBWIN_VSPACE	   60
#define CARDWIN_HSPACE	   40
#define CARDWIN_VSPACE	   40
X
#define LST_WHITESPACE		2
#define LST_TYPE_WIDTH	        13
#define LST_TITLE_WIDTH		50
#define LST_AUTHOR_WIDTH	30
#define LST_YEAR_WIDTH		4
#define LST_ENTRY_LEN		(LST_TYPE_WIDTH + LST_TITLE_WIDTH +\
X				 LST_AUTHOR_WIDTH + LST_YEAR_WIDTH +\
X				 (3*LST_WHITESPACE) + 1)
X
/* errors of type Errcode */
typedef int Errcode;  /* return type for error codes */
X
/* general errors */
#define ERR_NOT_IMPLEMENTED     -10
#define ERR_NOMALLOC            -11
#define ERR_NOBIB               -12
#define ERR_NOCARD              -13
#define ERR_NOBIBOPEN		-14
#define ERR_COLL_SAME_BIB       -15
#define ERR_COPY_SAME_BIB       -16
#define ERR_NO_USER_FLDS        -17
X
/* gui errors */
#define ERR_NOCASCADE		-30
X
/* file errors */
#define ERR_NO_OPEN_FILE        -50
#define ERR_NO_CFGFILE          -51
#define ERR_NO_OPEN_TMP         -52
#define ERR_SAVING_TMP          -53
#define ERR_IS_CORRECTED        -54
#define BIF_OK  		1
#define BIF_ECALLOC 		-11
#define BIF_EWRITE  		-55
#define BIF_EOPEN   		-50
X
/* card errors */
#define ERR_ILLEGAL_CARDS       -60
#define ERR_NO_ILLEGAL_CARDS    -61
#define ERR_ERROR_IN_FILE	-62
#define ERR_REQFIELDS           -63
X
/* database tree errors */
#define DBT_OK                    1
#define DBT_ECALLOC             -11
#define DBT_EDUPKEY             -100
#define DBT_ECOMP               -101
#define DBT_ENOMATCH            -102
#define DBT_ENOCARD             -103
#define DBT_EAUTHOR             -104
#define DBT_ETITLE              -105
#define DBT_EJOURNAL            -106
#define DBT_EYEAR               -107
#define DBT_EPUBLISHER          -108
#define DBT_EBOOKTITLE          -109 
#define DBT_ECHAPTER            -110
#define DBT_ESCHOOL             -111
#define DBT_EINSTITUTION        -112
#define DBT_ENOTE               -113
#define DBT_EAUTHOR_EDITOR      -114
#define DBT_ECHAPTER_PAGES      -115
#define DBT_ROOTSFULL           -120
#define DBT_ENONODE             -121
X
X
/* structure for single linked list of strings */
typedef struct _ListNode {
X   String data;
X   struct _ListNode *next;
} ListNode;
X
/* structure to hold lists of predefined field data */
typedef struct {
X   ListNode *address,
X            *annote,
X            *author,
X            *booktitle,
X            *chapter,
X            *edition,
X            *editor,
X            *howpublished,
X            *institution,
X            *journal,
X            *key,
X            *month,
X            *note,
X            *number,
X            *organization,
X            *pages,
X            *publisher,
X            *school,
X            *series,
X            *title,
X            *type,
X            *volume,
X            *year,
X            *category,
X	    *crossref,
X	    *mainkey;
} PredefLists;
X
/* type to hold lists of user defined fields */
typedef ListNode *UserDefFld;
X
/* card types possible in a bibTeX file */
typedef enum {  article,
X                book,
X                booklet,
X                conference,
X                inbook,
X                incollection,
X                inproceedings,
X                manual,
X                mastersthesis,
X                misc,
X                phdthesis,
X                proceedings,
X                techreport,
X                unpublished,
X                bibrc,
X                regexpr,
X		illegal
} CardType;
X
X
/* structure for user defined fields */
typedef struct _UserFld {  
X   String fldName;
X   String fldData;
X   Widget fldLabel;
X   Widget fldText;
X   struct _UserFld *next;
} UserFld;
X
X
/* structure for all possible data of any card */
typedef struct {
X   CardType cardtype;
X   Boolean  annoteDisplayed,
X            annoteChanged;
X   String   cardtypestr;
X   String   address,
X            annote,
X            author,
X            booktitle,
X            chapter,
X            edition,
X            editor,
X            howpublished,
X            institution,
X            journal,
X            key,
X            month,
X            note,
X            number,
X            organization,
X            pages,
X            publisher,
X            school,
X            series,
X            title,
X            type,
X            volume,
X            year,
X            category,
X	    crossref,
X	    mainkey;
X   UserFld  *ufield;
} CardData, *CardDataPtr;
X
typedef struct _CardListNode {
X                              CardData *data;
X                              struct _CardListNode *next;
} CardListNode, *CardDataList;
X
/* structure to hold all widget pointers for all card types */
typedef struct {
X   Widget address,	addressL,
X	  annoteShell,
X          annote,	annoteL,
X          author,	authorL,
X          booktitle,	booktitleL,
X          chapter,	chapterL,
X          edition,	editionL,
X          editor,	editorL,
X          howpublished,	howpublishedL,
X          institution,	institutionL,
X          journal,	journalL,
X          key,		keyL,
X          month,	monthL,
X          note,		noteL,
X          number,	numberL,
X          organization,	organizationL,
X          pages,	pagesL,
X          publisher,	publisherL,
X          school,	schoolL,
X          series,	seriesL,
X          title,	titleL,
X          type,		typeL,
X          volume,	volumeL,
X          year,		yearL,
X	  category,	categoryL,
X	  crossref,	crossrefL,
X	  mainkey,      mainkeyL;
} CardWidgets, *CardWidgetsPtr;
X
/* structure that hold widgets for displaying card data */
typedef struct {
X   CardWidgets cw;     	/* structure of all possible widgets */
X   CardData buf;	/* pointers in textBuf for string buffers */
X   String textBuf;      /* ptr to memory malloc'ed in one block */
} CardTextWin, *CardTextWinPtr;
X
/* structure for card window within bibliography wins */
typedef struct {
X   String shellName;	/* label for window */
X   Widget cardShell,	/* popup shell */
X	  cardWin,	/* paned window */
X	  cmdBox,	/* command box */
X	  userDef,	/* user defined command button */
X	  annote,	/* annote command button */
X	  delete,	/* delete command button */
X	  change,	/* change command button */
X	  copy,		/* copy command button */
X	  close,	/* close command button */
X	  cardDesk,	/* desktop for general attribs for all cards */
X	  cardFlds,	/* desktop on which to place display widgets */
X          usrFldVport,  /* vieport for user def fields */
X	  usrFldDesk,   /* desktop for user def fields */
X	  usrFldHead;   /* heading for user def fields */
X   Dimension width,     /* Values of Shell without user def fields */
X	     height,
X	     borderWidth;
X   CardTextWin ct;	/* structure of widgets to display data */
X   Position winX,	/* x-coord of cardWin relativ to bibDesk */
X	    winY,	/* y-coord of cardWin relativ to bibDesk */
X	    iconX,	/* x-coord of icon for shell */
X	    iconY;	/* y-coord of icon for shell */
} CardWin, *CardWinPtr;
X
/* structure for opened bibliography card */
typedef struct {
X   CardDataPtr cd;	/* ptr to card bibliography data */
X   CardWinPtr cw;	/* ptr to card window data */
X   Boolean extended;    /* user fields displayed (T/F) */
X   Boolean changed;	/* card changed flag */
X   void  *bp;		/* ptr to bib card belongs to */
} Card, *CardPtr;
X
/* structure for linked list of bib cards */
typedef struct _CardEl {
X   Card card;
X   struct _CardEl *next,
X	          *prev;
} CardEl, *CardList;
X
/* structure for list windows within bibliography wins */
typedef struct {
X   String shellName;	/* name of popup shell */
X   Widget lstShell,	/* popup shell */
X	  lstWin,	/* paned window for menu, list and cmds */
X	  lstVp, 	/* viewport for list */
X	  vpWin, 	/* child of viewport */
X	  cmdBox,	/* command box (menu bar) */
X	  list,		/* window containing list */
X	  headBox,	/* heading for list */
X	  save,	        /* save command button */
X	  print,	/* print command button */
X	  quit;		/* quit command button */
X   int listArgc;	/* no of entries in list */
X   String *listArgv;	/* argv of ptr to list entries */
X   String strs;		/* buffer for list entries */
X   CardListNode *cardLst; /* argv of ptr to cards in list */
X   Position winX,	/* x-coord of list window */
X	    winY,	/* y-coord of list window */
X	    iconX,	/* x-coord of icon for shell */
X	    iconY;	/* y-coord of icon for shell */
} LstWin, *LstWinPtr;
X
/* structure for macro windows within bibliograhpy wins */
typedef struct {
X   String shellName;	/* name of popup shell */
X   Widget macShell,	/* popup shell */
X	  macWin,	/* paned window for menu, list and cmds */
X	  cmdBox,	/* command box (menu bar) */
X	  save, 	/* save command button */
X	  close,	/* close command button */
X          file;         /* text widget for macro file */
X   Position winX,	/* x-coord of shell */
X	    winY,	/* y-coord of shell */
X	    iconX,	/* x-coord of icon for shell */
X	    iconY;	/* y-coord of icon for shell */
X   Boolean changed;	/* macros changed flag */
} MacroWin, *MacroWinPtr;
X
/* structure for bibliography windows */
typedef struct {
X   String shellName;	/* label for popup shell */
X   Widget bibShell,	/* popup shell */
X          bibWin,	/* main window */
X	  cmdBox,	/* command box */
X	  bibdesk,	/* desktop for cardWins */
X	  new,		/* new command button */
X	  search,	/* search command button */
X	  list,		/* list command button */
X	  macro,	/* macro command button */
X	  print,	/* print command button */
X	  save,		/* save command button */
X	  close,	/* close command button */
X	  window,	/* window command button */
X	  newMenu,	/* pulldown menu new */
X	  windowMenu;	/* pulldown menu window */
X   Position winX,	/* x-coord of shell */
X	    winY,	/* y-coord of shell */
X	    iconX,	/* x-coord of icon for shell */
X	    iconY;	/* y-coord of icon for shell */
} BibWin, *BibWinPtr;
X
/* structure for an opened bibTeX-file */
typedef struct {
X   char filepath[MAX_FILEPATHLEN];	/* bibTex filename */
X   char filename[MAX_FILENAMELEN];	/* bibTex filename */
X   char *tempfile;			/* temp   filename */
X   char *macrofile;			/* macro   filename */
X   Boolean changed;			/* file changed flag */
X   int treeIdx;				/* handle of data tree */
X   BibWinPtr bw;			/* ptr to bib window data */
X   LstWinPtr lw;			/* ptr to list window data */
X   MacroWinPtr mw;			/* ptr to macro win data */
X   MacroWinPtr ew;			/* ptr to edit win data */
X   CardList  cl;			/* ptr to list of open cards */
X   int noOfCardWins;			/* number of opened cards */
X   int nextCardPos;			/* pos of next opened card */
} Bib, *BibPtr;
X   
X
/* codes and macros for options functions */
#define OPT_MAX_OPTION		5+1 /* plus line in menu */
#define OPT_BEEP_ON_ERROR       1
#define OPT_BACKUP_ON_SAVE      2
#define OPT_ICON_ON_DESKTOP     3
#define OPT_AUTO_CHECK_BIB      4
#define OPT_REQUIRED_FIELDS     5
#if !defined(COT_OPT)
extern Boolean optionsStatus[];
#endif
#define cotBeepOnError()	(optionsStatus[OPT_BEEP_ON_ERROR])
#define cotBackupBeforeSave()	(optionsStatus[OPT_BACKUP_ON_SAVE])
#define cotIconizeOnDesktop()	(optionsStatus[OPT_ICON_ON_DESKTOP])
#define cotAutoCheckBib()	(optionsStatus[OPT_AUTO_CHECK_BIB])
#define cotRequiredFields()	(optionsStatus[OPT_REQUIRED_FIELDS])
X
X
/* Prototypes */
/* ---------- */
X
/* types */
typedef Errcode (*CtlFuncPtr) (BibPtr bp);
X
/* bibview.c */
X
/* gui_main.c */
int gumMainWin (void);
X
/* ctl_open.c */
void copNewCmd (Widget w, XtPointer clientData, XtPointer callData);
void copOpenCmd (Widget w, XtPointer clientData, XtPointer callData);
void copLoadBibFile (Widget w, XtPointer clientData, XtPointer callData);
X
/* ctl_save.c */
void csaQuitBibviewCmd (Widget w, XtPointer clientData, XtPointer callData);
void csaCloseBibCmd (Widget w, XtPointer clientData, XtPointer callData);
void csaCloseCmd (Widget w, XtPointer clientData, XtPointer callData);
Errcode csaCloseBib (BibPtr bp);
void csaSaveBibCmd (Widget w, XtPointer clientData, XtPointer callData);
void csaSaveCmd (Widget w, XtPointer clientData, XtPointer callData);
void csaSaveAsBibCmd (Widget w, XtPointer clientData, XtPointer callData);
Errcode csaSaveBib (BibPtr bp);
Errcode csaSaveAsBib (BibPtr bp);
X
/* ctl_serv.c */
void cseCollateBibCmd (Widget w, XtPointer clientData, XtPointer callData);
Errcode cseCollateBibs (BibPtr sbp, BibPtr dbp);
void cseCheckBibCmd (Widget w, XtPointer clientData, XtPointer callData);
Errcode cseCheckBib (BibPtr bp, Boolean sayOkMsg);
void cseEditMacrosCmd (Widget w, XtPointer clientData, XtPointer callData);
void cseMacrosCmd (Widget w, XtPointer clientData, XtPointer callData);
Errcode cseEditMacros (BibPtr bp);
void cseSetMacroChangeFlag (Widget w, XtPointer clientData, XtPointer callData);
void cseQuitMacrosCmd (Widget w, XtPointer clientData, XtPointer callData);
void cseSaveMacrosCmd (Widget w, XtPointer clientData, XtPointer callData);
void cseLoadConfigCmd (Widget w, XtPointer clientData, XtPointer callData);
X
/* ctl_opt.c */
void cotOptionsControl (Widget w, XtPointer client_data, XtPointer call_data);
void cotOptionIconOnDeskCmd (Widget w, XtPointer clientData, XtPointer callData);
X
/* gui_bibl.c */
int gubOpenBibWin(BibPtr bp);
int gubNoOfOpenBibs (void);
void gubCloseBibWinCmd(Widget w, XtPointer clientData, XtPointer callData);
Errcode gubCloseBibWin (BibPtr bp);
void gubCascadeCmd(Widget w, XtPointer clientData, XtPointer callData);
Errcode gubCascade(void);
Errcode gubSetWindowCoords (Boolean calcOnly);
Errcode gubSetIconCoords (Boolean calcOnly);
Errcode gubUnsetIconCoords (Boolean calcOnly);
X
/* ctl_srch.c */
void csrSearchCmd (Widget w, XtPointer clientData, XtPointer callData);
void csrListCmd (Widget w, XtPointer clientData, XtPointer callData);
void csrDisplayCardCmd (Widget w, XtPointer clientData, XtPointer callData);
X
/* gui_card.c */
Errcode gucOpenCardWin (BibPtr bp, CardPtr cp, Boolean isNew);
void gucCloseCardCmd (Widget w, XtPointer clientData, XtPointer callData);
Errcode gucCloseCardWin (CardPtr cp);
Errcode gucOpenUserFields (CardPtr cp);
Errcode gucCloseUserFields (CardPtr cp);
Errcode gucSaveCardData (CardPtr cp);
Errcode gucSaveUserFields (CardPtr cp);
Boolean gucStdFldsChanged (CardPtr cp);
void gucCascadeCmd (Widget w, XtPointer clientData, XtPointer callData);
Errcode gucCascade (BibPtr bp);
Errcode gucSetWindowCoords (BibPtr bp, Boolean calcOnly);
Errcode gucSetIconCoords (BibPtr bp, Boolean calcOnly);
Errcode gucUnsetIconCoords (BibPtr bp, Boolean calcOnly);
X
/* ctl_card.c */
void ccdNewCardCmd (Widget w, XtPointer clientData, XtPointer callData);
void ccdUserdataCmd (Widget w, XtPointer clientData, XtPointer callData);
void ccdSaveCardCmd (Widget w, XtPointer clientData, XtPointer callData);
void ccdDeleteCardCmd (Widget w, XtPointer clientData, XtPointer callData);
void ccdAnnoteCardCmd (Widget w, XtPointer clientData, XtPointer callData);
void ccdChangeCardCmd (Widget w, XtPointer clientData, XtPointer callData);
void ccdCopyCardCmd (Widget w, XtPointer clientData, XtPointer callData);
Errcode ccdCopyCard1 (BibPtr bp);
Errcode ccdCopyCard (BibPtr bp, CardPtr cp);
void ccdSetChangeFlag (Widget w, XtPointer clientData, XtPointer callData);
void ccdCloseCardCmd (Widget w, XtPointer clientData, XtPointer callData);
Errcode ccdCloseCard (BibPtr bp, CardPtr cp);
X
/* ctl_prt.c */
void cprPrintBibCmd (Widget widget, XtPointer clientData, XtPointer callData);
void cprPrintCmd (Widget widget, XtPointer clientData, XtPointer callData);
Errcode cprPrintBib (BibPtr bp);
void cprPrintListCmd (Widget widget, XtPointer clientData, XtPointer callData);
Errcode cprPrintList (CardListNode *lp, String fname);
void cprSaveListCmd(Widget widget, XtPointer clientData, XtPointer callData);
X
/* gui_list.c */
Errcode gulOpenListWin (BibPtr bp, CardDataList cl); 
Boolean gulListWinExists (BibPtr bp);
Errcode gulReplaceListData (BibPtr bp, CardDataList cl);
void gulCloseListWinCmd (Widget w, XtPointer clientData, XtPointer callData);
Errcode gulCloseListWin (BibPtr bp);
Errcode gulCascade (BibPtr bp);
Errcode gulSetWindowCoords (BibPtr bp, Boolean calcOnly);
Errcode gulSetIconCoords (BibPtr bp, Boolean calcOnly);
Errcode gulUnsetIconCoords (BibPtr bp, Boolean calcOnly);
X
/* gui_edit.c */
Errcode gueOpenListWin (BibPtr bp);
Boolean gueMacroWinExists (BibPtr bp);
void    gueCloseMacroWinCmd (Widget w, XtPointer clientData, XtPointer callData);
Errcode gueCloseMacroWin (BibPtr bp);
Errcode gueSaveMacrosToFile (BibPtr bp);
Errcode gueCascade (BibPtr bp);
Errcode gueSetWindowCoords (BibPtr bp, Boolean calcOnly);
Errcode gueSetIconCoords (BibPtr bp, Boolean calcOnly);
Errcode gueUnsetIconCoords (BibPtr bp, Boolean calcOnly);
Errcode gueOpenBibErrWin(BibPtr bp, int line);
Errcode gueCloseBibErrWin (BibPtr bp);
void gueCloseBibErrWinCmd (Widget w, XtPointer clientData, XtPointer callData);
X
/* gui_widg.c */
Errcode guwSelectBib (String head, CtlFuncPtr fct);
void    guwNotImpl (Widget w, XtPointer clientData, XtPointer callData);
void hlpOpenHelpWinCmd (Widget w, XtPointer clientData, XtPointer callData);
void guwError(Errcode errcode);
void guwWarning(Errcode errcode);
void guwNotice(Errcode errcode);
void guwProgInfo (Widget w, XtPointer clientData, XtPointer callData);
X
/* bib_file */
Errcode bifFileRead(BibPtr bp);
Errcode bifFileWrite(BibPtr bp);
Errcode bifFileListWrite(BibPtr bp, CardListNode *list, String fname);
X
/* rc_file.c */
Errcode rcfReadCfgFile (char *cfgFname);
Errcode rcfReadOptions (Boolean bool);
Errcode rcfSetPrintMode (Boolean bool);
X
/* globdata.c */
char *strupr (char *s);
String glbNewString (String s);
String glbTrimString (String s);
Boolean glbIsStringEmpty (String s);
String glbTypeToName (CardType type);
CardType glbNameToType (String name);
Errcode glbNewBibListEl (BibPtr *bp);
Errcode glbDelBibListEl (BibPtr bp);
BibPtr glbFirstBibListEl (void);
BibPtr glbPrevBibListEl (BibPtr bp);
BibPtr glbNextBibListEl (BibPtr bp);
BibPtr glbLastBibListEl (void);
Boolean glbIsBibListEl (BibPtr bp);
Errcode glbNewCardListEl (BibPtr bp, CardPtr *cp, CardDataPtr cd);
Errcode glbDelCardListEl (BibPtr bp, CardPtr cp);
CardPtr glbFirstCardListEl (BibPtr bp);
CardPtr glbPrevCardListEl (BibPtr bp, CardPtr cp);
CardPtr glbNextCardListEl (BibPtr bp, CardPtr cp);
CardPtr glbLastCardListEl (BibPtr bp);
Boolean glbIsCardListEl (BibPtr bp, CardPtr cp);
CardPtr glbFindCard (BibPtr bp, CardDataPtr cd);
X
/* db_tree.c */
Errcode dbtInsert (int treeIdx, CardData *card);
Errcode dbtDelete (int treeIdx, CardData *card);
Errcode dbtSearch (int treeIdx, CardData **card);
Errcode dbtMakeCard (CardData **card);
Errcode dbtDeleteCard (CardData **card);
Errcode dbtMakeTreeList (int treeIdx, int listIdx);
Errcode dbtGetFreeTreeIdx (int *treeIdx);
Errcode dbtGetFreeListIdx (int *listIdx);
Errcode dbtSearchList (int treeIdx, CardData *card, CardListNode **list);
Errcode dbtTestCard (CardData *c);
Errcode dbtCheckAllCards (int treeIdx, CardListNode **list);
Errcode dbtDeleteTree (int treeIdx);
Errcode dbtAppendUserFld(UserFld **list, UserFld *obj);
Errcode dbtMakeListNode (ListNode **list);
Errcode dbtListAppend (ListNode **list, String word);
Errcode dbtCardListDelete(CardListNode **list); 
SHAR_EOF
chmod 0644 bibview.h ||
echo 'restore of bibview.h failed'
Wc_c="`wc -c < 'bibview.h'`"
test 21014 -eq "$Wc_c" ||
	echo 'bibview.h: original size 21014, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bibviewrc ==============
if test -f 'bibviewrc' -a X"$1" != X"-c"; then
	echo 'x - skipping bibviewrc (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bibviewrc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bibviewrc' &&
# bibviewrc: configuration file for bibview
# -------------------------------------------
X
# The following sections are allowed
#  [Options]       (optional)
#  [Fields]        (optional)
#  [Predefines]    (optional)
#  [LatexHeader]   (optional)
#  [LatexFooter]   (optional)
# All lines must start in the first column
X
X
[Options]
#
# The following options are recognized:
#  Option			  Function                  Default
#  ----------------------------------------------------------------
#  BeepOnError    = (true|false)  Beep on error             true
#  IconsOnDesk    = (true|false)  Icons on Desktop          false
#  MakeBackups    = (true|false)  Backups before Save       true
#  AutoCheckBib   = (true|false)  Autom. check              true
#  RequiredFields = (true|false)  Check before Save.        true
X
BeepOnError = false
IconsOnDesk = true
MakeBackups = true
AutoCheckBib = true
RequiredFields= false
X
X
X
[Fields]
# Define user defined fields for certain types.
# If the field should be in ALL types,
# as type you must enter 'all'
#
#  type = fieldname
# ----------------------
article = library
article = read
book = owner
all = available 
X
[Predefines]
# Predefined data for search window
#
#  field : data
# --------------------
address:New York
address : Berlin
address:  Washington
X
author: Hartson
author: Hesketh
author: Hix
author: McCormack
author: Nye
author: O'Reilly
X
category: ^unix
category: ^x
X
title: X Toolkit Intrinsics
X
year: 198
year: 199
X
X
[LatexHeader]
# header of LaTeX file
# The following lines until the next section are written as header of the
# LaTeX file.
# \begin{enumerate} is necessary because the entries are
# written as LaTeX list
X
\documentstyle{article}
\begin{document}
{\large \bf Content of BibTeX file -- \today}
\begin{enumerate} 
X
[LatexFooter]
# end of LaTeX file
# The following lines until the next section are written as footer of the
# LaTeX file.
X
\end{enumerate} 
\end{document}
X
X
SHAR_EOF
chmod 0640 bibviewrc ||
echo 'restore of bibviewrc failed'
Wc_c="`wc -c < 'bibviewrc'`"
test 1949 -eq "$Wc_c" ||
	echo 'bibviewrc: original size 1949, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bitmaps/bv_crd64 ==============
if test ! -d 'bitmaps'; then
    echo 'x - creating directory bitmaps'
    mkdir 'bitmaps'
fi
if test -f 'bitmaps/bv_crd64' -a X"$1" != X"-c"; then
	echo 'x - skipping bitmaps/bv_crd64 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bitmaps/bv_crd64 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bitmaps/bv_crd64' &&
#define bv_crd64_width 64
#define bv_crd64_height 64
static unsigned char bv_crd64_bits[] = {
X   0x25, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x21, 0x00, 0xf0,
X   0xdc, 0xf3, 0x01, 0x21, 0x89, 0x10, 0x00, 0x10, 0x49, 0x44, 0x00, 0x12,
X   0x44, 0x08, 0x00, 0x10, 0x49, 0x44, 0x00, 0x0c, 0x22, 0x04, 0x00, 0xf0,
X   0xc8, 0x43, 0x00, 0x0c, 0x11, 0x02, 0x00, 0xf0, 0xc9, 0x47, 0x7c, 0x0c,
X   0x08, 0x01, 0x00, 0x10, 0x49, 0x44, 0x04, 0x0c, 0x84, 0x00, 0x00, 0x10,
X   0x49, 0x44, 0x04, 0x12, 0x42, 0x00, 0x00, 0xf0, 0xdc, 0x43, 0x3c, 0x21,
X   0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x10, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,
X   0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x02, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x81, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x03, 0x02,
X   0x00, 0x00, 0x00, 0x00, 0xf0, 0x41, 0x04, 0xfe, 0xff, 0xff, 0xff, 0x01,
X   0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
SHAR_EOF
true || echo 'restore of bitmaps/bv_crd64 failed'
fi
echo 'End of  part 5'
echo 'File bitmaps/bv_crd64 is continued in part 6'
echo 6 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
