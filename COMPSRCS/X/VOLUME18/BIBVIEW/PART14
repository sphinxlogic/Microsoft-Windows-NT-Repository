Path: uunet!paladin.american.edu!gatech!swrinde!mips!msi!dcmartin
From: liebla@informatik.tu-muenchen.de (Armin Liebl)
Newsgroups: comp.sources.x
Subject: v18i112: bibview - BibTeX GUI, Part14/20
Message-ID: <1992Aug27.161729.25905@msi.com>
Date: 27 Aug 92 16:17:29 GMT
References: <csx-18i099-bibview@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1635
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: Armin Liebl <liebla@informatik.tu-muenchen.de>
Posting-number: Volume 18, Issue 112
Archive-name: bibview/part14

#!/bin/sh
# this is part.14 (part 14 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file flexsrc/b.y continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 14; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping flexsrc/b.y'
else
echo 'x - continuing file flexsrc/b.y'
sed 's/^X//' << 'SHAR_EOF' >> 'flexsrc/b.y' &&
{
X UserFld *h;
X String newType;
X long pos;
X
X fseek(datei, 0L, SEEK_END); 
X fprintf(datei,"\n");
X pos = ftell(datei);
X newType = glbNewString(glbTypeToName(card->cardtype));
X fprintf(datei,"@%s{%s",newType, card->mainkey);
X pos = ftell(datei);
X fprintf(datei,",\n");
X 
X if (!StringIsPeteEmpty(card->address)) {
X   pos = WriteLineToFile(datei,"ADDRESS",card->address);    
X } 
X if (!StringIsPeteEmpty(card->annote)) {
X   pos = WriteLineToFile(datei,"ANNOTE",card->annote);    
X } 
X if (!StringIsPeteEmpty(card->author)) {
X   pos = WriteLineToFile(datei,"AUTHOR",card->author);    
X } 
X if (!StringIsPeteEmpty(card->booktitle)) {
X   pos = WriteLineToFile(datei,"BOOKTITLE",card->booktitle);    
X } 
X if (!StringIsPeteEmpty(card->chapter)) {
X   pos = WriteLineToFile(datei,"CHAPTER",card->chapter);    
X } 
X if (!StringIsPeteEmpty(card->crossref)) {
X   pos = WriteLineToFile(datei,"CROSSREF",card->crossref);    
X } 
X if (!StringIsPeteEmpty(card->edition)) {
X   pos = WriteLineToFile(datei,"EDITION",card->edition);    
X } 
X if (!StringIsPeteEmpty(card->editor)) {
X   pos = WriteLineToFile(datei,"EDITOR",card->editor);    
X } 
X if (!StringIsPeteEmpty(card->howpublished)) {
X   pos = WriteLineToFile(datei,"HOWPUBLISHED",card->howpublished);    
X } 
X if (!StringIsPeteEmpty(card->institution)) {
X   pos = WriteLineToFile(datei,"INSTITUTION",card->institution);    
X } 
X if (!StringIsPeteEmpty(card->journal)) {
X   pos = WriteLineToFile(datei,"JOURNAL",card->journal);    
X } 
X if (!StringIsPeteEmpty(card->key)) {
X   pos = WriteLineToFile(datei,"KEY",card->key);    
X } 
X if (!StringIsPeteEmpty(card->month)) {
X   pos = WriteLineToFile(datei,"MONTH",card->month);    
X } 
X if (!StringIsPeteEmpty(card->note)) {
X   pos = WriteLineToFile(datei,"NOTE",card->note);    
X } 
X if (!StringIsPeteEmpty(card->number)) {
X   pos = WriteLineToFile(datei,"NUMBER",card->number);    
X } 
X if (!StringIsPeteEmpty(card->organization)) {
X   pos = WriteLineToFile(datei,"ORGANIZATION",card->organization);    
X } 
X if (!StringIsPeteEmpty(card->pages)) {
X   pos = WriteLineToFile(datei,"PAGES",card->pages);    
X } 
X if (!StringIsPeteEmpty(card->publisher)) {
X   pos = WriteLineToFile(datei,"PUBLISHER",card->publisher);    
X } 
X if (!StringIsPeteEmpty(card->school)) {
X   pos = WriteLineToFile(datei,"SCHOOL",card->school);    
X } 
X if (!StringIsPeteEmpty(card->series)) {
X   pos = WriteLineToFile(datei,"SERIES",card->series);    
X } 
X if (!StringIsPeteEmpty(card->title)) {
X   pos = WriteLineToFile(datei,"TITLE",card->title);    
X } 
X if (!StringIsPeteEmpty(card->type)) {
X   pos = WriteLineToFile(datei,"TYPE",card->type);    
X } 
X if (!StringIsPeteEmpty(card->volume)) {
X   pos = WriteLineToFile(datei,"VOLUME",card->volume);    
X } 
X if (!StringIsPeteEmpty(card->year)) {
X   pos = WriteLineToFile(datei,"YEAR",card->year);    
X } 
X if (!StringIsPeteEmpty(card->category)) {
X   pos = WriteLineToFile(datei,"CATEGORY",card->category);    
X } 
X h = card->ufield; 
X while (h) {
X   pos = WriteLineToFile(datei,h->fldName,h->fldData);    
X   h = h->next;
X }   
X fseek(datei, pos, SEEK_SET);
X fprintf(datei,"\n}\n\n");
}
X
X
X
static int StringIsPeteEmpty(char *text)
{
X if (text == NULL || *text == '\0') return 1;
X return 0;
}
X
X
X
yyerror(char *s)
{
X
X fputs(s, stderr);
X putc('\n', stderr);
}
X
#ifdef BIFMAIN
X
int main(int argc, char *argv[])
{
X Bib bp;
X int erg, b1, i;
X Errcode err;
X
#ifdef YYDEBUG
X       extern int yydebug;
X
X       yydebug = 1;
#endif
X
X strcpy(bp.filepath, argv[1]);
X dbtGetFreeTreeIdx(&b1);
X bp.treeIdx = b1;
X err = bifFileRead(&bp);
X err = bifFileWrite(&bp);
}
X
#endif
SHAR_EOF
echo 'File flexsrc/b.y is complete' &&
chmod 0640 flexsrc/b.y ||
echo 'restore of flexsrc/b.y failed'
Wc_c="`wc -c < 'flexsrc/b.y'`"
test 29693 -eq "$Wc_c" ||
	echo 'flexsrc/b.y: original size 29693, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= flexsrc/cm ==============
if test -f 'flexsrc/cm' -a X"$1" != X"-c"; then
	echo 'x - skipping flexsrc/cm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting flexsrc/cm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'flexsrc/cm' &&
yacc -dlv b.y
mv y.tab.h b.tab.h
mv y.tab.c bib_file.c
flex -iv b.l
mv lex.yy.c bib_flex.c
SHAR_EOF
chmod 0740 flexsrc/cm ||
echo 'restore of flexsrc/cm failed'
Wc_c="`wc -c < 'flexsrc/cm'`"
test 91 -eq "$Wc_c" ||
	echo 'flexsrc/cm: original size 91, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= globdata.c ==============
if test -f 'globdata.c' -a X"$1" != X"-c"; then
	echo 'x - skipping globdata.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting globdata.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'globdata.c' &&
/*********************************************************************/
/*  bibView: Administration of bibTex-Databases                      */
/*           (Verwaltung von bibTeX-Literaturdatenbanken)            */
/*                                                                   */
/*  Module:  globdata.c                                              */
/*                                                                   */
/*             Handling of global data                               */
/*             - List of bibdata                                     */
/*                                                                   */
/*  Author:  Holger Martin,  martinh@informatik.tu-muenchen.de       */
/*           Peter M. Urban, urban@informatik.tu-muenchen.de         */
/*                                                                   */
/*  History:                                                         */
/*    12.05.91  PMU  created                                         */
/*    05.26.92       Version 1.0 released                            */
/*                                                                   */
/*  Copyright 1992 TU MUENCHEN                                       */
/*    See ./Copyright for complete rights and liability information. */
/*                                                                   */
/*********************************************************************/
X
#include <stdio.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include "bibview.h"
X
X
/* macros and definitions */
/* ---------------------- */
X
/* list type for opened bibliographies */
typedef struct bl {
X   Bib bib;
X   struct bl *prev,
X	     *next;
} BibEl, *BibList;
X
/* CardEl and CardList are part of Bib in bibview.h */
X
X
/* local function prototypes */
/* ------------------------- */
static BibList FindBibListEl (BibPtr bp);
static CardList FindCardListEl (BibPtr bp, CardPtr cp);
X
X
/* external global variables */
/* ------------------------- */
X
X
/* exported global variables */
/* ---------------------- */
X
X
/* local global variables */
/* ------------------------- */
X
/* names for card types */
static String cardNames[] = {
X   "article",
X   "book",
X   "booklet",
X   "conference",
X   "inbook",
X   "incollection",
X   "inproceedings",
X   "manual",
X   "mastersthesis",
X   "misc",
X   "phdthesis",
X   "proceedings",
X   "techreport",
X   "unpublished",
X   "userdefined"
};
X
/* list of opened bibliographies */
static BibList bibList = NULL;
X
X
X
/*********************************************************************/
/* strupr:                                                           */
/*    Convert characters 'a'..'z' to 'A'..'Z'                        */
/*********************************************************************/
char *
strupr (char *s)
{
char *p = s;
X
X   while (*p) {
X      if (*p >= 'a' && *p <= 'z')
X	 *p = *p - 32;
X      p++;
X   }
X
X   return(s);
}
X
X
/*********************************************************************/
/* glbNewString:                                                     */
/*    Copy an instance of a String                                   */
/*********************************************************************/
String
glbNewString (String s)
{
String str;
X
X   if (s == NULL)
X      return(NULL);
X
X   if ((str = (char *)malloc(strlen(s)+1)) == NULL)
X      return(NULL);
X
X   strcpy(str, s);
X   return(str);
}
X
X
/*********************************************************************/
/* glbTrimString:                                                    */
/*    Remove whitespace before and after string                      */
/*********************************************************************/
String
glbTrimString (String s)
{
String p;
X
X   while (*s == ' ' || *s == '\t') {
X      p = s;
X      while (*p) {
X	 *p = *(p+1);
X	 p++;
X      }
X   }
X
X   p = s+strlen(s)-1;
X   while (*p == ' ' || *p == '\t')
X      *p-- = '\0';
X   return(s);
}
X
X
/*********************************************************************/
/* glbIsStringEmpty:                                                 */
/*    Check for empty string                                         */
/*********************************************************************/
Boolean
glbIsStringEmpty (String s)
{
X   if (s == NULL || *s == '\0') 
X      return(TRUE);
X
X   while (*s) {
X      if (*s != ' ' || *s != '\t') 
X          return(FALSE);
X      s++;
X   }
X
X   return(TRUE);
}
X
X
/*********************************************************************/
/* glbTypeToName:                                                    */
/*    Return String name of card type                                */
/*********************************************************************/
String
glbTypeToName (CardType type)
{
X   return(cardNames[type]);
}
X
X
/*********************************************************************/
/* glbNameToType:                                                    */
/*    Return card type corresponding to name                         */
/*********************************************************************/
CardType
glbNameToType (String name)
{
int i = 0;
X
X   for (i = 0; i < MAX_BIBTEX_TYPES; i++) {
X      if (strcmp(name, cardNames[i]) == 0)
X         return((CardType)i);
X   }
X   return(illegal);
}
X
X
/*********************************************************************/
/* glbNewBibListEl:                                                  */
/*    Create new bliography list element                             */
/*********************************************************************/
Errcode
glbNewBibListEl (BibPtr *bp)
{
BibList bl, p;
Errcode status;
X   /* malloc new list entry */
X   if ((bl = (BibList)XtMalloc(sizeof(BibEl))) == NULL) {
X      *bp = NULL;
X      return(ERR_NOMALLOC);
X   }
X
X
X   /* initialize required data */
X   if ((status = dbtGetFreeTreeIdx(&bl->bib.treeIdx)) != OK) {
X
X      free(bl);
X      return(status);
X   }
X   bl->bib.changed = FALSE;
X   bl->bib.filename[0] = '\0';
X   bl->bib.filepath[0] = '\0';
X   bl->bib.tempfile = NULL;
X   bl->bib.macrofile = NULL;
X   bl->bib.bw = NULL;
X   bl->bib.lw = NULL;
X   bl->bib.mw = NULL;
X   bl->bib.cl = NULL;
X   bl->bib.noOfCardWins = 0;
X   bl->bib.nextCardPos = 0;
X
X   /* if list is empty, start new list */
X   if (bibList == NULL) {
X      bl->next = bl->prev = NULL;
X      bibList = bl;
X      *bp = &bl->bib;
X      return(OK);
X   }
X
X   p = bibList;
X   while (p->next != NULL)	/* find last element in list */
X      p = p->next;
X
X   bl->prev = p;		/* append new win to list */
X   bl->next = NULL;
X   p->next = bl;
X
X   *bp = &bl->bib;
X   return(OK);
}
X
X
/*********************************************************************/
/* glbDelBibListEl:                                                  */
/*    Delete bibliography list element                               */
/*********************************************************************/
Errcode
glbDelBibListEl (BibPtr bp)
{
BibList bn;	/* node of card to delete */
X
X   /* check if card is really in list */
X   if ((bn = FindBibListEl(bp)) == NULL)
X      return(ERR_NOBIB);
X   if (bp->tempfile != NULL)
X      {unlink(bp->tempfile);
X       free(bp->tempfile);
X       }
X   if (bp->macrofile != NULL)
X      {unlink(bp->macrofile);
X       free(bp->macrofile);
X       }
X   /* is it root of list? */
X   if (bn == bibList) {
X      bibList->prev = NULL;
X      bibList = bn->next;
X   }
X   else {
X      bn->prev->next = bn->next;
X      if (bn->next != NULL)
X         bn->next->prev = bn->prev;
X   }
X   free(bn); /* all other frees must be done before */
X   return(OK);
}
X
X
/*********************************************************************/
/* glbFirstBibListEl:                                                */
/*    Get element in root of list                                    */
/*********************************************************************/
BibPtr
glbFirstBibListEl (void)
{
X   if (bibList != NULL)
X      return(&bibList->bib);
X   return(NULL);
}
X
X
/*********************************************************************/
/* glbPrevBibListEl:                                                 */
/*    Get element previous to bp in list of bibs                     */
/*********************************************************************/
BibPtr
glbPrevBibListEl (BibPtr bp)
{
BibList bl;
X
X   if ((bl = FindBibListEl(bp)) == NULL)
X      return(NULL);
X   return(&bl->prev->bib);
}
X
X
/*********************************************************************/
/* glbNextBibListEl:                                                 */
/*    Get element after to bp in list of bibs                        */
/*********************************************************************/
BibPtr
glbNextBibListEl (BibPtr bp)
{
BibList bl;
X
X   if ((bl = FindBibListEl(bp)) == NULL)
X      return(NULL);
X   return(&bl->next->bib);
}
X
X
/*********************************************************************/
/* glbLastBibListEl:                                                 */
/*    Get last element in list of bibs                               */
/*********************************************************************/
BibPtr
glbLastBibListEl (void)
{
BibList bl = bibList;
X
X   if (bibList != NULL) {
X      while (bl->next != NULL)
X	 bl = bl->next;
X      return(&bl->bib);
X   }
X   else
X      return(NULL);
}
X
X
/*********************************************************************/
/* glbIsBibListEl:                                                   */
/*    Test whether bib is really an element of bib list              */
/*********************************************************************/
Boolean
glbIsBibListEl (BibPtr bp)
{
X   if (FindBibListEl(bp) != NULL)
X      return(TRUE);
X   return(FALSE);
}
X
X
/*********************************************************************/
/* FindBibListEl:                                                    */
/*    Find bib bp in list of bibs                                    */
/*********************************************************************/
static BibList
FindBibListEl (BibPtr bp)
{
BibList p;
X
X   p = bibList;
X   while (p != NULL) {
X      if (&p->bib == bp)
X	 return(p);
X      p = p->next;
X   }
X   return(NULL);
}
X
X
/*********************************************************************/
/* glbNewCardListEl:                                                 */
/*    Create new bibliography card list element                      */
/*********************************************************************/
Errcode
glbNewCardListEl (BibPtr bp, CardPtr *cp, CardDataPtr cd)
{
CardList cl, p;
Errcode status;
X
X   /* malloc new list entry */
X   if ((cl = (CardList)malloc(sizeof(CardEl))) == NULL) {
X      *cp = NULL;
X      return(ERR_NOMALLOC);
X   }
X
X   /* initialize required data */
X   cl->card.bp = bp;
X   cl->card.cd = NULL;
X   if ((status = CopyCard(&cl->card.cd, cd)) != DBT_OK) {
X      free(cl);
X      return(status);
X   }
X   cl->card.cw = NULL;
X   cl->card.changed = FALSE;
X   cl->card.extended = FALSE;
X
X   /* if list is empty, start new list */
X   if (bp->cl == NULL) {
X      cl->next = cl->prev = NULL;
X      bp->cl = cl;
X      *cp = &cl->card;
X      return(OK);
X   }
X
X   p = bp->cl;
X   while (p->next != NULL)	/* find last element in list */
X      p = p->next;
X
X   cl->prev = p;		/* append new win to list */
X   cl->next = NULL;
X   p->next = cl;
X
X   *cp = &cl->card;
X   return(OK);
}
X
X
/*********************************************************************/
/* glbDelCardListEl:                                                 */
/*    Delete bibliography card list element                          */
/*********************************************************************/
Errcode
glbDelCardListEl (BibPtr bp, CardPtr cp)
{
CardList cn;	/* node of card to delete */
X
X   /* check if card is really in list */
X   if ((cn = FindCardListEl(bp, cp)) == NULL)
X      return(ERR_NOCARD);
X
X   /* is it root of list? */
X   if (cn == bp->cl) {
X      bp->cl->prev = NULL;
X      bp->cl = cn->next;
X   }
X   else {
X      cn->prev->next = cn->next;
X      if (cn->next != NULL)
X         cn->next->prev = cn->prev;
X   }
X   free(cn); /* all other frees must be done before */
X   return(OK);
}
X
X
/*********************************************************************/
/* glbFirstCardListEl:                                               */
/*    Get element in root of list                                    */
/*********************************************************************/
CardPtr
glbFirstCardListEl (BibPtr bp)
{
X   if (bp->cl != NULL)
X      return(&bp->cl->card);
X   return(NULL);
}
X
X
/*********************************************************************/
/* glbPrevCardListEl:                                                */
/*    Get element previous to cp in list of cards                    */
/*********************************************************************/
CardPtr
glbPrevCardListEl (BibPtr bp, CardPtr cp)
{
CardList cl;
X
X   if ((cl = FindCardListEl(bp, cp)) == NULL)
X      return(NULL);
X   return(&cl->prev->card);
}
X
X
/*********************************************************************/
/* glbNextCardListEl:                                                */
/*    Get element after to cp in list of cards                       */
/*********************************************************************/
CardPtr
glbNextCardListEl (BibPtr bp, CardPtr cp)
{
CardList cl;
X
X   if ((cl = FindCardListEl(bp, cp)) == NULL)
X      return(NULL);
X   return(&cl->next->card);
}
X
X
/*********************************************************************/
/* glbLastCardListEl:                                                */
/*    Get last element in list of cards                              */
/*********************************************************************/
CardPtr
glbLastCardListEl (BibPtr bp)
{
CardList cl = bp->cl;
X
X   if (cl != NULL) {
X      while (cl->next != NULL)
X	 cl = cl->next;
X      return(&cl->card);
X   }
X   else
X      return(NULL);
}
X
X
/*********************************************************************/
/* glbIsCardListEl:                                                  */
/*    Test whether card is really an element of card list            */
/*********************************************************************/
Boolean
glbIsCardListEl (BibPtr bp, CardPtr cp)
{
X   if (FindCardListEl(bp, cp) != NULL)
X      return(TRUE);
X   return(FALSE);
}
X
X
/*********************************************************************/
/* glbFindCard:                                                      */
/*    Search for card in list of opened card windows                 */
/*********************************************************************/
CardPtr
glbFindCard (BibPtr bp, CardDataPtr cd)
{
CardPtr cp = NULL;
X
X   if ((cp = glbFirstCardListEl(bp)) == NULL)
X      return(NULL);
X
X   while (cp != NULL) {
X      if (strcmp(cd->mainkey, cp->cd->mainkey) == 0)
X	 return(cp);
X      cp = glbNextCardListEl(bp, cp);
X   }
X   return(NULL);
}
X
X
/*********************************************************************/
/* FindCardListEl:                                                   */
/*    Find card cp in list of cards of bp                            */
/*********************************************************************/
static CardList
FindCardListEl (BibPtr bp, CardPtr cp)
{
CardList p;
X
X   p = bp->cl;
X   while (p != NULL) {
X      if (&p->card == cp)
X	 return(p);
X      p = p->next;
X   }
X   return(NULL);
}
X
X
X
X
SHAR_EOF
chmod 0644 globdata.c ||
echo 'restore of globdata.c failed'
Wc_c="`wc -c < 'globdata.c'`"
test 15414 -eq "$Wc_c" ||
	echo 'globdata.c: original size 15414, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= gui_bibl.c ==============
if test -f 'gui_bibl.c' -a X"$1" != X"-c"; then
	echo 'x - skipping gui_bibl.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting gui_bibl.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'gui_bibl.c' &&
/*********************************************************************/
/*  bibView: Administration of bibTex-Databases                      */
/*           (Verwaltung von bibTeX-Literaturdatenbanken)            */
/*                                                                   */
/*  Module:  gui_bibl.c                                              */
/*                                                                   */
/*             GUI: Bibliography Window                              */
/*             - Menu functions New                                  */
/*                                                                   */
/*  Author:  Holger Martin,  martinh@informatik.tu-muenchen.de       */
/*           Peter M. Urban, urban@informatik.tu-muenchen.de         */
/*                                                                   */
/*  History:                                                         */
/*    12.05.91  PMU  created                                         */
/*    05.26.92       Version 1.0 released                            */
/*                                                                   */
/*  Copyright 1992 TU MUENCHEN                                       */
/*    See ./Copyright for complete rights and liability information. */
/*                                                                   */
/*********************************************************************/
X
#include <stdio.h>
#include <X11/Intrinsic.h>
#include <X11/Shell.h>
#include <X11/StringDefs.h>
#include <X11/Xaw/Form.h>
#include <X11/Xaw/Paned.h>
#include <X11/Xaw/Box.h>
#include <X11/Xaw/Command.h>
#include <X11/Xaw/MenuButton.h>
#include <X11/Xaw/SimpleMenu.h>
#include <X11/Xaw/SmeBSB.h>
#include <X11/Xaw/SmeLine.h>
#include "bibview.h"
X
X
/* macros and definitions */
/* ---------------------- */
X
/* structure for pulldown menu items */
typedef struct {
X   String name;		/* Xt name (instance) of item */
X   XtCallbackProc cb;	/* associated callback function */
} MenuEntry;
X
X
/* local function prototypes */
/* ------------------------- */
static Errcode calcNextBibWinPos (int n, Position *x, Position *y);
static Errcode calcNextBibIconPos (int curIcon, Position *x, Position *y);
static void createMenu (String menuName, MenuEntry item[], Widget parent, Widget *menu, BibPtr bp);
X
/* external global variables */
/* ------------------------- */
extern Widget topLevel, desktop;
extern Pixmap bvIconPixmap;
X
X
/* exported global variables */
/* ---------------------- */
X
X
/* local global variables */
/* ------------------------- */
X
/* names for pulldown menu entries */
static MenuEntry newEntry[] = {
X   { "line1", NULL },
X   { "item2",  ccdNewCardCmd },
X   { "item3",  ccdNewCardCmd },
X   { "item5",  ccdNewCardCmd },
X   { "item6",  ccdNewCardCmd },
X   { "item1",  ccdNewCardCmd },
X   { "item4",  ccdNewCardCmd },
X   { "item7",  ccdNewCardCmd },
X   { "item12", ccdNewCardCmd },
X   { "item13", ccdNewCardCmd },
X   { "item9",  ccdNewCardCmd },
X   { "item11", ccdNewCardCmd },
X   { "item8",  ccdNewCardCmd },
X   { "item14", ccdNewCardCmd },
X   { "line2",  NULL },
X   { "item10", ccdNewCardCmd },
X   { NULL, NULL }
};
X
static MenuEntry windowEntry[] = {
X   { "line1", NULL },
X   { "item1",  gucCascadeCmd },
X   { NULL, NULL }
};
X
static int noOfBibWins = 0;
static int nextBibPos = 0;
X
X
X
/*********************************************************************/
/* gubOpenBibWin:                                                    */
/*    Creates an instance of a bibliography window                   */
/*********************************************************************/
int
gubOpenBibWin (BibPtr bp)
{
Position x, y;
Dimension dwidth, dheight;
BibWinPtr bw;
BibPtr lastBib;
int status;
X
X   /* allocate memory for new element of window list */
X   if ((bw = (BibWinPtr) malloc(sizeof(BibWin))) == NULL) {
X      /* error-handling is done in control modules */
X      return(ERR_NOMALLOC);
X   }
X
X   /* allocate memory for label of new shell */
X   if ((bw->shellName = 
X      (String) calloc(strlen(PROGNAME)+strlen(bp->filename)+4, 
X		      sizeof(char))) == NULL) {
X      return(ERR_NOMALLOC);
X   }
X
X   bp->bw = bw;
X   sprintf(bw->shellName, "%s: %s", PROGNAME, bp->filename);
X
X   /* create popup shell for new file */
X   bw->bibShell = XtVaCreatePopupShell("bibShell",
X		  topLevelShellWidgetClass, desktop, 
/*  		  XtNtransient, TRUE,
X		  XtNwindowGroup, XtWindow(topLevel), */
X		  XtNtitle, bw->shellName, 
X		  XtNiconPixmap, bvIconPixmap,
X		  XtNiconName, bp->filename, NULL);
X   bw->bibWin = XtVaCreateManagedWidget("bibWin",
X		  panedWidgetClass, bw->bibShell, NULL);
X
X   /* create command buttons */
X   bw->cmdBox = XtVaCreateManagedWidget("commandBox", 
X		  boxWidgetClass, bw->bibWin, NULL);
X   bw->new = XtVaCreateManagedWidget("new", 
X	       menuButtonWidgetClass, bw->cmdBox, NULL);  
X   bw->search = XtVaCreateManagedWidget("search", 
X	          commandWidgetClass, bw->cmdBox, NULL);
X   bw->list = XtVaCreateManagedWidget("list", 
X	        commandWidgetClass, bw->cmdBox, NULL);
X   bw->macro = XtVaCreateManagedWidget("macro", 
X	        commandWidgetClass, bw->cmdBox, NULL);
X   bw->print = XtVaCreateManagedWidget("print", 
X	         commandWidgetClass, bw->cmdBox, NULL);
X   bw->save = XtVaCreateManagedWidget("save", 
X	        commandWidgetClass, bw->cmdBox, NULL);
X   bw->close = XtVaCreateManagedWidget("close", 
X	         commandWidgetClass, bw->cmdBox, NULL);
X   bw->window = XtVaCreateManagedWidget("window", 
X	         menuButtonWidgetClass, bw->cmdBox, NULL); 
X
X   /* make pulldownmenus for command boxes */
X   createMenu("newMenu", newEntry, bw->new, &bw->newMenu, bp);
X   createMenu("windowMenu", windowEntry, bw->window, &bw->windowMenu, bp); 
X
X   XtAddCallback(bw->search, XtNcallback, csrSearchCmd, (XtPointer)bp);
X   XtAddCallback(bw->print, XtNcallback, cprPrintCmd, (XtPointer)bp);
X   XtAddCallback(bw->list, XtNcallback, csrListCmd, (XtPointer)bp);
X   XtAddCallback(bw->macro, XtNcallback, cseMacrosCmd, (XtPointer)bp);
X   XtAddCallback(bw->save, XtNcallback, csaSaveCmd, (XtPointer)bp);
X   XtAddCallback(bw->close, XtNcallback, csaCloseCmd, (XtPointer)bp);
X
X   /* create bibliography window desktop */
X   bw->bibdesk = XtVaCreateManagedWidget("bibdesk",
X                   formWidgetClass, bw->bibWin, NULL); 
X
X   /* Position window near main desktop */
X   noOfBibWins++;
X   calcNextBibWinPos(nextBibPos, &bw->winX, &bw->winY);
X   XtVaSetValues(bw->bibShell,
X		 XtNx, bw->winX,
X		 XtNy, bw->winY, NULL);
X   nextBibPos++;
X
X   /* if option on, set icon position on desktop */
X   if (cotIconizeOnDesktop()) {
X      calcNextBibIconPos(noOfBibWins, &bw->iconX, &bw->iconY);
X      XtVaSetValues(bw->bibShell,
X		    XtNiconX, bw->iconX,
X		    XtNiconY, bw->iconY, NULL);
X   }
X
X   XtPopup(bw->bibShell, XtGrabNone);
X   return(OK);
}
X
X
/*********************************************************************/
/* gubNoOfOpenBibs:                                                  */
/*    Returns number of opened bibliogarohies                        */
/*********************************************************************/
int
gubNoOfOpenBibs (void)
{
X   return(noOfBibWins);
}
X
X
/*********************************************************************/
/* gubCloseBibWinCmd:                                                */
/*    Callback for close bibwin command                              */
/*********************************************************************/
void
gubCloseBibWinCmd (Widget w, XtPointer clientData, XtPointer callData)
{
BibPtr bp = (BibPtr)clientData;
Errcode status;
X
X   if ((status = gubCloseBibWin(bp)) != OK) {
X      guwError(status);
X   }
}
X
X
/*********************************************************************/
/* gubCloseBibWin:                                                   */
/*    Close a bibliography window                                    */
/*********************************************************************/
Errcode
gubCloseBibWin (BibPtr bp)
{
CardPtr cp;
Errcode status;
X
X   /* close all opened card windows */
X   while ((cp = glbFirstCardListEl(bp)) != NULL) {
X      if ((status = gucCloseCardWin(cp)) != OK) {
X         guwError(status);
X      }
X   }
X
X   /* close possibly opened list window */
X   if (bp->lw != NULL) {
X      if ((status = gulCloseListWin(bp)) != OK) {
X         guwError(status);
X      }
X   }
X
X   /* close possibly opened macro window */
X   if (bp->mw != NULL) {
X      if ((status = gueCloseMacroWin(bp)) != OK) {
X         guwError(status);
X      }
X   }
X
X   /* close this bibliography window */
X   XtPopdown(bp->bw->bibShell); 
X   noOfBibWins--;
X   if (glbLastBibListEl() == bp)
X      nextBibPos -= 1;
X   free(bp->bw->shellName);
X   free(bp->bw);
X   glbDelBibListEl(bp);
X   if (glbFirstBibListEl() == NULL)
X      nextBibPos = 0;
X
X   return(OK);
}
X
X
/*********************************************************************/
/* gubCascadeCmd:                                                    */
/*    Callback for Cascade-Function                                  */
/*********************************************************************/
void
gubCascadeCmd (Widget w, XtPointer clientData, XtPointer callData)
{
Errcode status;
X
X   if ((status = gubCascade()) != OK) {
X      guwWarning(status);
X   }
}
X
X
/*********************************************************************/
/* gubCascade:                                                       */
/*    Layout the bibliography windows                                */
/*********************************************************************/
Errcode
gubCascade (void)
{
X   gubSetWindowCoords(FALSE);
X   if (cotIconizeOnDesktop())
X      gubSetIconCoords(FALSE);
X   return(OK);
}
X
X
/*********************************************************************/
/* gubSetWindowCoords:                                               */
/*    Set positions of bibliography windows                          */
/*********************************************************************/
Errcode
gubSetWindowCoords (Boolean calcOnly)
{
BibPtr bp, last_bp;
Errcode status;
int i;
X 
X   if ((bp = glbFirstBibListEl()) == NULL)
X      return(OK);
X   for (i = 0; i < noOfBibWins; i++) {
X      calcNextBibWinPos(i, &bp->bw->winX, &bp->bw->winY);
X      if (!calcOnly) {
X         XtVaSetValues(bp->bw->bibShell,
X                       XtNx, bp->bw->winX,
X		       XtNy, bp->bw->winY, NULL);
X	 if (XtIsRealized(bp->bw->bibShell)) {
X            XRaiseWindow(XtDisplay(bp->bw->bibShell),
X		         XtWindow(bp->bw->bibShell));
X	 }
X      }
X      bp = glbNextBibListEl(bp);
X   } /* endfor */
X
X   bp = glbFirstBibListEl();
X   for (i = 0; i < noOfBibWins; i++) {
X      if ((status = gucCascade(bp)) != OK)
X         guwWarning(status);
X      if ((status = gueCascade(bp)) != OK)
X         guwWarning(status);
X      if ((status = gulCascade(bp)) != OK)
X         guwWarning(status);
X      bp = glbNextBibListEl(bp);
X   } /* endfor */
X
X   return(OK);
}
X
X
/*********************************************************************/
/* gubSetIconCoords:                                                 */
/*    Set positions of bibliography windows icons                    */
/*********************************************************************/
Errcode
gubSetIconCoords (Boolean calcOnly)
{
BibPtr bp;
int curIcon = 0;
X 
X   if ((bp = glbFirstBibListEl()) != NULL) {
X      calcNextBibIconPos(curIcon, &bp->bw->iconX, &bp->bw->iconY);
X      if (!calcOnly) {
X         XtVaSetValues(bp->bw->bibShell,
X		       XtNiconX, bp->bw->iconX,
X		       XtNiconY, bp->bw->iconY, NULL);
X      }
X
X      while ((bp = glbNextBibListEl(bp)) != NULL) {
X         curIcon++;
X         calcNextBibIconPos(curIcon, &bp->bw->iconX, &bp->bw->iconY);
X         if (!calcOnly) {
X            XtVaSetValues(bp->bw->bibShell,
X		          XtNiconX, bp->bw->iconX,
X		          XtNiconY, bp->bw->iconY, NULL);
X         }
X      }  /* endwhile */
X   } /* endif */
X
X   return(OK);
}
X
X
/*********************************************************************/
/* gubUnsetIconCoords:                                               */
/*    Set positions of bibliography windows icons                    */
/*********************************************************************/
Errcode
gubUnsetIconCoords (Boolean calcOnly)
{
BibPtr bp;
X 
X   if ((bp = glbFirstBibListEl()) != NULL) {
X      bp->bw->iconX = bp->bw->iconY = -1;
X      if (!calcOnly) {
X         XtVaSetValues(bp->bw->bibShell,
X		       XtNiconX, bp->bw->iconX,
X		       XtNiconY, bp->bw->iconY, NULL);
X      }
X
X      while ((bp = glbNextBibListEl(bp)) != NULL) {
X         bp->bw->iconX = bp->bw->iconY = -1;
X         if (!calcOnly) {
X            XtVaSetValues(bp->bw->bibShell,
X		          XtNiconX, bp->bw->iconX,
X		          XtNiconY, bp->bw->iconY, NULL);
X         }
X      }  /* endwhile */
X   } /* endif */
X
X   return(OK);
}
X
X
/*********************************************************************/
/* gubSetSensitive:                                                  */
/*    Set the sensitivity state of one or all bibl windows           */
/*********************************************************************/
void
gubSetSensitive (BibPtr bib, Boolean sensitive)
{
CardPtr card;
X
X   if (bib == NULL) { /* set all bib windows and subs to sensitive? */
X      bib = glbFirstBibListEl();
X      while (bib != NULL) {
X	 if (bib->bw != NULL) {
X	    XtSetSensitive(bib->bw->bibWin, sensitive);
X	    if (bib->lw != NULL) /* handle list window */
X	       XtSetSensitive(bib->lw->lstWin, sensitive);
X	    card = glbFirstCardListEl(bib); /* handle all cards */
X	    while (card != NULL) {
X	       if (card->cw != NULL)
X		  XtSetSensitive(card->cw->cardWin, sensitive);
X	       card = glbNextCardListEl(bib, card);
X	    }
X	 }
X	 bib = glbNextBibListEl(bib);
X      }
X   }
X   else { /* set only one bib win and subs to sensitive */
X      if (glbIsBibListEl(bib) && bib->bw != NULL) {
X         XtSetSensitive(bib->bw->bibWin, sensitive);
X	 if (bib->lw != NULL) /* handle list window */
X	    XtSetSensitive(bib->lw->lstWin, sensitive);
X	 card = glbFirstCardListEl(bib); /* handle all cards */
X	 while (card != NULL) {
X	    if (card->cw != NULL)
X	       XtSetSensitive(card->cw->cardWin, sensitive);
X	    card = glbNextCardListEl(bib, card);
X	 } /* endwhile */
X      } /* endif */
X   } /* endelse */
}
X
X
/*********************************************************************/
/* LOCAL FUNCTIONS                                                   */
/*********************************************************************/
X
/*********************************************************************/
/* calcNextBibWinPos:                                                */
/*    Calculate coords of next bibliography window                   */
/*********************************************************************/
static Errcode
calcNextBibWinPos (int n, Position *x, Position *y)
{
Dimension dwidth, dheight, twidth = BIBWIN_MARGIN;
BibPtr bp;
int i;
X
X   /* calc width of all previous bibwins */
X   if ((bp = glbFirstBibListEl()) == NULL)
X      return(OK);
X   for (i = 0; i < n; i++) {
X      XtVaGetValues(bp->bw->bibWin,
X		    XtNwidth, &dwidth, NULL);
X      twidth += dwidth + BIBWIN_MARGIN;
X      bp = glbNextBibListEl(bp);
X   }
X
X   XtVaGetValues(desktop,
X		 XtNwidth, &dwidth,
X		 XtNheight, &dheight, NULL);
X   XtTranslateCoords(desktop,
X		     (Position)twidth,
X		     (Position)dheight - BIBWIN_MARGIN,
X		     x, y);
X   return(OK);
}
X
X
/*********************************************************************/
/* calcNextBibIconPos:                                               */
/*    Calculate coords of next bibliography window icon              */
/*********************************************************************/
static Errcode
calcNextBibIconPos (int curIcon, Position *x, Position *y)
{
Position curX, curY;
Dimension dwidth, dheight;
X
X   if (curIcon == 0) { /* position 1st bibwin */
X      curX = 1;
X      curY = BV_ICON_MARGIN;
X      XtTranslateCoords(desktop,
X		       curX, curY,
X		       x, y);
X   }
X   else {  /* position icon after curIcon */
X      curX = curIcon * (BV_ICON_MARGIN + BV_ICON_WIDTH);
X      curY = BV_ICON_MARGIN;
X      XtTranslateCoords(desktop,
X		       curX, curY,
X		       x, y);
X   }
}
X
X
/*********************************************************************/
/* createMenu:                                                       */
/*    Build pulldown menus in a bibliography window                  */
/*********************************************************************/
static void
createMenu (String menuName, MenuEntry item[], Widget parent, Widget *menu, BibPtr bp)
{
static Widget w;
int i = 0;
String iname;
X
X   *menu = XtVaCreatePopupShell(menuName, 
X             simpleMenuWidgetClass, parent, NULL);
X   i = 0;
X   while ((iname = item[i].name) != NULL) { 
X      if (strncmp("line", iname, 4) == 0)   /* use a line pane */
X         w = XtVaCreateManagedWidget(iname,
X               smeLineObjectClass, *menu, NULL);
X      else {
X         w = XtVaCreateManagedWidget(iname, 
X	       smeBSBObjectClass, *menu, NULL);
X         XtAddCallback(w, XtNcallback, item[i].cb, (XtPointer)bp);
X      }
X      i++;
X   }
}
X
X
X
X
SHAR_EOF
chmod 0644 gui_bibl.c ||
echo 'restore of gui_bibl.c failed'
Wc_c="`wc -c < 'gui_bibl.c'`"
test 17139 -eq "$Wc_c" ||
	echo 'gui_bibl.c: original size 17139, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= gui_card.c ==============
if test -f 'gui_card.c' -a X"$1" != X"-c"; then
	echo 'x - skipping gui_card.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting gui_card.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'gui_card.c' &&
/*********************************************************************/
/*  bibView: Administration of bibTex-Databases                      */
/*           (Verwaltung von bibTeX-Literaturdatenbanken)            */
/*                                                                   */
/*  Module:  gui_card.c                                              */
/*                                                                   */
/*             GUI: Card Windows                                     */
/*             -                                                     */
/*                                                                   */
/*  Author:  Holger Martin,  martinh@informatik.tu-muenchen.de       */
/*           Peter M. Urban, urban@informatik.tu-muenchen.de         */
/*                                                                   */
/*  History:                                                         */
/*    12.19.91  PMU  created                                         */
/*    05.26.92       Version 1.0 released                            */
/*                                                                   */
/*  Copyright 1992 TU MUENCHEN                                       */
/*    See ./Copyright for complete rights and liability information. */
/*                                                                   */
/*********************************************************************/
X
#include <stdio.h>
#include <X11/Intrinsic.h>
#include <X11/Shell.h>
#include <X11/StringDefs.h>
#include <X11/Xaw/Form.h>
#include <X11/Xaw/Paned.h>
#include <X11/Xaw/Box.h>
#include <X11/Xaw/Command.h>
#include <X11/Xaw/MenuButton.h>
#include <X11/Xaw/SimpleMenu.h>
#include <X11/Xaw/SmeBSB.h>
#include <X11/Xaw/SmeLine.h>
#include <X11/Xaw/Text.h>
#include <X11/Xaw/AsciiText.h>
#include <X11/Xaw/Viewport.h>
#include "bibview.h"
X
X
/* macros and definitions */
/* ---------------------- */
X
/* function to create widgets for card window */
typedef void (*CreateWidgetFuncPtr)(BibPtr bp, CardPtr cp);
X
/* function to save data from card window */
typedef Errcode (*SaveWidgetFuncPtr)(CardPtr cp);
X
/* structure for pulldown menu items */
typedef struct {
X   String name;		/* Xt name (instance) of item */
X   XtCallbackProc cb;	/* associated callback function */
} MenuEntry;
X
X
/* local function prototypes */
/* ------------------------- */
static Errcode calcNextCardWinPos (Widget desk, int n, Position *x, Position *y);
static Errcode calcNextCardIconPos (Widget desk, int curIcon, Position *x, Position *y);
static void createMenu (String menuName, MenuEntry item[], Widget parent, Widget *menu);
static void createStdWidgetFlds (BibPtr bp, CardPtr cp);
static void CreateArticleWidgets (BibPtr bp, CardPtr cp);
static void CreateBookWidgets (BibPtr bp, CardPtr cp);
static void CreateBookletWidgets (BibPtr bp, CardPtr cp);
static void CreateConferenceWidgets (BibPtr bp, CardPtr cp);
static void CreateInbookWidgets (BibPtr bp, CardPtr cp);
static void CreateIncollectionWidgets (BibPtr bp, CardPtr cp);
static void CreateInproceedingsWidgets (BibPtr bp, CardPtr cp);
static void CreateManualWidgets (BibPtr bp, CardPtr cp);
static void CreateMasterthesisWidgets (BibPtr bp, CardPtr cp);
static void CreateMiscWidgets (BibPtr bp, CardPtr cp);
static void CreatePhdthesisWidgets (BibPtr bp, CardPtr cp);
static void CreateProceedingsWidgets (BibPtr bp, CardPtr cp);
static void CreateTechreportWidgets (BibPtr bp, CardPtr cp);
static void CreateUnpublishedWidgets (BibPtr bp, CardPtr cp);
static void CreateDummyWidgets (BibPtr bp, CardPtr cp);
static Errcode saveStdWidgetFlds (CardPtr cp);
static Errcode SaveArticleWidgets (CardPtr cp);
static Errcode SaveBookWidgets (CardPtr cp);
static Errcode SaveBookletWidgets (CardPtr cp);
static Errcode SaveConferenceWidgets (CardPtr cp);
static Errcode SaveInbookWidgets (CardPtr cp);
static Errcode SaveIncollectionWidgets (CardPtr cp);
static Errcode SaveInproceedingsWidgets (CardPtr cp);
static Errcode SaveManualWidgets (CardPtr cp);
static Errcode SaveMasterthesisWidgets (CardPtr cp);
static Errcode SaveMiscWidgets (CardPtr cp);
static Errcode SavePhdthesisWidgets (CardPtr cp);
static Errcode SaveProceedingsWidgets (CardPtr cp);
static Errcode SaveTechreportWidgets (CardPtr cp);
static Errcode SaveUnpublishedWidgets (CardPtr cp);
static Errcode SaveDummyWidgets (CardPtr cp);
X
X
X
/* external global variables */
/* ------------------------- */
extern Widget topLevel, desktop;
extern Pixmap crdIconPixmap;
extern UserDefFld userDefFlds[];
X
X
/* exported global variables */
/* ---------------------- */
X
X
/* local global variables */
/* ------------------------- */
X
/* pointers to strings of widget names for each card type */
static char *cardWidgetName[] = {
X   "article",
X   "book",
X   "booklet",
X   "conference",
X   "inbook",
X   "incollection",
X   "inproceedings",
X   "manual",
X   "mastersthesis",
X   "misc",
X   "phdthesis",
X   "proceedings",
X   "techreport",
X   "unpublished"
};
X
/* pointers to functions for creating widgets in card windows */
static CreateWidgetFuncPtr createWidgetFunc[] = {
X   CreateArticleWidgets,
X   CreateBookWidgets,
X   CreateBookletWidgets,
X   CreateConferenceWidgets,
X   CreateInbookWidgets,
X   CreateIncollectionWidgets,
X   CreateInproceedingsWidgets,
X   CreateManualWidgets,
X   CreateMasterthesisWidgets,
X   CreateMiscWidgets,
X   CreatePhdthesisWidgets,
X   CreateProceedingsWidgets,
X   CreateTechreportWidgets,
X   CreateUnpublishedWidgets
};
X
/* pointers to functions for saving data from widgets */
static SaveWidgetFuncPtr saveWidgetFunc[] = {
X   SaveArticleWidgets,
X   SaveBookWidgets,
X   SaveBookletWidgets,
X   SaveConferenceWidgets,
X   SaveInbookWidgets,
X   SaveIncollectionWidgets,
X   SaveInproceedingsWidgets,
X   SaveManualWidgets,
X   SaveMasterthesisWidgets,
X   SaveMiscWidgets,
X   SavePhdthesisWidgets,
X   SaveProceedingsWidgets,
X   SaveTechreportWidgets,
X   SaveUnpublishedWidgets
};
X
X
X
/*********************************************************************/
/* gucOpenCardWin:                                                   */
/*    Creates an instance of a bibliography window                   */
/*********************************************************************/
Errcode
gucOpenCardWin (BibPtr bp, CardPtr cp, Boolean isNew)
{
CardPtr lastCard;
CardWinPtr cw;
int status;
X
X   /* allocate memory for new element of window list */
X   if ((cw = (CardWinPtr) calloc(1, sizeof(CardWin))) == NULL) {
X      /* error-handling is done in control modules */
X      return(ERR_NOMALLOC);
X   }
X
X   /* allocate memory for text buffers of card widget */
X   /* not needed: handled by widget */
X
X   /* build label of new shell */
X   if ((cw->shellName = (String)calloc(strlen(bp->filename) +
X	                               strlen(glbTypeToName(cp->cd->cardtype))+4,
X	                               sizeof(char))) == NULL) {
X      free(cw);
X      return(ERR_NOMALLOC);
X   }
X   sprintf(cw->shellName, "%s: %s", bp->filename, 
X				    glbTypeToName(cp->cd->cardtype));
X
X   /* create popup shell for new file */
X   cw->cardShell = XtVaCreatePopupShell("cardShell",
X                     topLevelShellWidgetClass, topLevel,
X                     XtNtransientFor, bp->bw->bibShell,
X                     XtNwindowGroup, XtWindow(bp->bw->bibShell), 
X                     XtNtitle, cw->shellName,
X                     XtNiconPixmap, crdIconPixmap,
X                     XtNiconName, cp->cd->key, NULL);
X
X   /* create widgets for card */
X   cw->cardWin = XtVaCreateManagedWidget("cardWin",
X		   panedWidgetClass, cw->cardShell, NULL);
X   cw->cmdBox = XtVaCreateManagedWidget("commandBox", 
X		  boxWidgetClass, cw->cardWin, NULL);
X   cw->userDef = XtVaCreateManagedWidget("userDef", 
X	           commandWidgetClass, cw->cmdBox, NULL);
X   cw->annote = XtVaCreateManagedWidget("annote", 
X	           commandWidgetClass, cw->cmdBox, NULL);
X   cw->delete = XtVaCreateManagedWidget("delete", 
X	          commandWidgetClass, cw->cmdBox, NULL);
X   cw->change = XtVaCreateManagedWidget("save", 
X         	  commandWidgetClass, cw->cmdBox, NULL);
X   cw->copy = XtVaCreateManagedWidget("copy", 
X	        commandWidgetClass, cw->cmdBox, NULL);
X   cw->close = XtVaCreateManagedWidget("quit", 
X	         commandWidgetClass, cw->cmdBox, NULL);
X
X   XtAddCallback(cw->close, XtNcallback, ccdCloseCardCmd, (XtPointer)cp);
X   XtAddCallback(cw->userDef, XtNcallback, ccdUserdataCmd, (XtPointer)cp);
X   XtAddCallback(cw->delete, XtNcallback, ccdDeleteCardCmd, (XtPointer)cp);
X   XtAddCallback(cw->annote, XtNcallback, ccdAnnoteCardCmd, (XtPointer)cp);
X   if (isNew)
X      XtAddCallback(cw->change, XtNcallback, ccdSaveCardCmd, (XtPointer)cp);
X   else
X      XtAddCallback(cw->change, XtNcallback, ccdChangeCardCmd, (XtPointer)cp);
X   XtAddCallback(cw->copy, XtNcallback, ccdCopyCardCmd, (XtPointer)cp);
X
X   /* create card window desktop */
X   cw->cardDesk = XtVaCreateManagedWidget("carddesk", 
X	            formWidgetClass, cw->cardWin, NULL);
X   cw->cardFlds = XtVaCreateManagedWidget(cardWidgetName[cp->cd->cardtype], 
X	            formWidgetClass, cw->cardDesk, NULL);
X
X   /* set card pointer to new struct, new window created */
X   cp->cw = cw;
X   bp->noOfCardWins++;
X
X   /* Position window near bibliography desktop */
X   calcNextCardWinPos(bp->bw->bibdesk, bp->nextCardPos, &cw->winX, &cw->winY);
X   XtVaSetValues(cw->cardShell,
X                 XtNx, cw->winX,
X                 XtNy, cw->winY, NULL);
X
X   /* if option on, set icon position on desktop */
X   if (cotIconizeOnDesktop()) {
X      calcNextCardIconPos(bp->bw->bibdesk, bp->noOfCardWins, &cw->iconX, &cw->iconY);
X      XtVaSetValues(cw->cardShell,
X                    XtNiconX, cw->iconX,
X                    XtNiconY, cw->iconY, NULL);
X   }
X   bp->nextCardPos++;
X
X   /* build only widgets for specific card type */
X   createStdWidgetFlds(bp, cp);
X   (createWidgetFunc[cp->cd->cardtype])(bp, cp);
X
X   XtPopup(cw->cardShell, XtGrabNone);
X   return(OK);
}
X
X
/*********************************************************************/
/* gucStdFldsChanged:                                                */
/*    Returns true, if user made changes to standard bibTeX fields   */
/*********************************************************************/
#define WidgetChanged(w) (XawAsciiSourceChanged(XawTextGetSource(w)))
Boolean
gucStdFldsChanged (CardPtr cp)
{
CardWidgetsPtr cwp = &cp->cw->ct.cw;	/* ptr to widget ids */
X
X   if (cwp->address && WidgetChanged(cwp->address)) 
X       return(TRUE);
X   else if (cwp->annote && (cp->cd->annoteChanged==TRUE))
X      return(TRUE);
X   else if (cwp->author && WidgetChanged(cwp->author)) 
X      return(TRUE);
X   else if (cwp->booktitle && WidgetChanged(cwp->booktitle)) 
X      return(TRUE);
X   else if (cwp->chapter && WidgetChanged(cwp->chapter)) 
X      return(TRUE);
SHAR_EOF
true || echo 'restore of gui_card.c failed'
fi
echo 'End of  part 14'
echo 'File gui_card.c is continued in part 15'
echo 15 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
