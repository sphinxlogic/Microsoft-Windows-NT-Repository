Newsgroups: comp.sources.x
Path: uunet!uunet!darwin.sura.net!mips!msi!dcmartin
From: jvb7u@fermi.clas.Virginia.EDU (Jon Brinkmann)
Subject: v18i070: xsol - solitare game for X windows, Part03/04
Message-ID: <1992Jul29.175808.15338@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
References: <csx-18i068-xsol@uunet.UU.NET>
Date: Wed, 29 Jul 1992 17:58:08 GMT
Approved: dcmartin@msi.com
Lines: 1472

Submitted-by: jvb7u@fermi.clas.Virginia.EDU (Jon Brinkmann)
Posting-number: Volume 18, Issue 70
Archive-name: xsol/part03

#!/bin/sh
# this is part.03 (part 3 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file cards.bm continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 3; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping cards.bm'
else
echo 'x - continuing file cards.bm'
sed 's/^X//' << 'SHAR_EOF' >> 'cards.bm' &&
X   0x80, 0x01, 0xf8, 0x00, 0x3e, 0x80, 0x01, 0xfc, 0x01, 0x7f, 0x80, 0x01,
X   0xfc, 0x01, 0x7f, 0x80, 0x01, 0xa8, 0x00, 0x2a, 0x80, 0x01, 0x20, 0x00,
X   0x08, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x9f, 0x01, 0x00,
X   0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x00, 0x88, 0x01, 0x00, 0x00, 0x00,
X   0x88, 0x01, 0x00, 0x00, 0x00, 0x84, 0x01, 0x00, 0x00, 0x00, 0x84, 0x01,
X   0x00, 0x00, 0x00, 0x82, 0x01, 0x00, 0x00, 0x00, 0x82, 0x01, 0x00, 0x00,
X   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00,
X   0x00, 0x00, 0x80, 0x71, 0x00, 0x00, 0x00, 0x80, 0x89, 0x00, 0x00, 0x00,
X   0x80, 0x89, 0x00, 0x00, 0x00, 0x80, 0x71, 0x00, 0x00, 0x00, 0x80, 0x89,
X   0x00, 0x00, 0x00, 0x80, 0x89, 0x00, 0x00, 0x00, 0x80, 0x89, 0x00, 0x00,
X   0x00, 0x80, 0x71, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80,
X   0x01, 0x20, 0x00, 0x08, 0x80, 0x01, 0x70, 0x00, 0x1c, 0x80, 0x01, 0xf8,
X   0x00, 0x3e, 0x80, 0x01, 0xfc, 0x01, 0x7f, 0x80, 0x01, 0xfc, 0x01, 0x7f,
X   0x80, 0x01, 0xa8, 0x00, 0x2a, 0x80, 0x01, 0x20, 0x00, 0x08, 0x80, 0x01,
X   0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00,
X   0x00, 0x80, 0x01, 0x20, 0x00, 0x08, 0x80, 0x01, 0x70, 0x00, 0x1c, 0x80,
X   0x01, 0xf8, 0x00, 0x3e, 0x80, 0x01, 0xfc, 0x01, 0x7f, 0x80, 0x01, 0xfc,
X   0x01, 0x7f, 0x80, 0x01, 0xa8, 0x00, 0x2a, 0x80, 0x01, 0x20, 0x00, 0x08,
X   0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01,
X   0x00, 0x00, 0x00, 0x80, 0x01, 0x20, 0x00, 0x08, 0x80, 0x01, 0x70, 0x00,
X   0x1c, 0x80, 0x01, 0xf8, 0x00, 0x3e, 0x80, 0x01, 0xfc, 0x01, 0x7f, 0x80,
X   0x01, 0xfc, 0x01, 0x7f, 0x80, 0x01, 0xa8, 0x00, 0x2a, 0x80, 0x01, 0x20,
X   0x00, 0x08, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
X   0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x20, 0x00, 0x08, 0x80, 0x01,
X   0x70, 0x00, 0x1c, 0x80, 0x01, 0xf8, 0x00, 0x3e, 0x80, 0x01, 0xfc, 0x01,
X   0x7f, 0x80, 0x01, 0xfc, 0x01, 0x7f, 0x80, 0x01, 0xa8, 0x00, 0x2a, 0x80,
X   0x01, 0x20, 0x00, 0x08, 0x80, 0x01, 0x00, 0x00, 0x00, 0x8e, 0x01, 0x00,
X   0x00, 0x00, 0x91, 0x01, 0x00, 0x00, 0x00, 0x91, 0x01, 0x00, 0x00, 0x00,
X   0x8e, 0x01, 0x00, 0x00, 0x00, 0x91, 0x01, 0x00, 0x00, 0x00, 0x91, 0x01,
X   0x00, 0x00, 0x00, 0x91, 0x01, 0x00, 0x00, 0x00, 0x8e, 0x01, 0x00, 0x00,
X   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00,
X   0x00, 0x00, 0x80, 0x71, 0x00, 0x00, 0x00, 0x80, 0x89, 0x00, 0x00, 0x00,
X   0x80, 0x89, 0x00, 0x00, 0x00, 0x80, 0x89, 0x00, 0x00, 0x00, 0x80, 0xf1,
X   0x00, 0x00, 0x00, 0x80, 0x81, 0x00, 0x00, 0x00, 0x80, 0x89, 0x00, 0x00,
X   0x00, 0x80, 0x71, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80,
X   0x01, 0x20, 0x00, 0x08, 0x80, 0x01, 0x70, 0x00, 0x1c, 0x80, 0x01, 0xf8,
X   0x00, 0x3e, 0x80, 0x01, 0xfc, 0x01, 0x7f, 0x80, 0x01, 0xfc, 0x01, 0x7f,
X   0x80, 0x01, 0xa8, 0x00, 0x2a, 0x80, 0x01, 0x20, 0x00, 0x08, 0x80, 0x01,
X   0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00,
X   0x00, 0x80, 0x01, 0x20, 0x00, 0x08, 0x80, 0x01, 0x70, 0x00, 0x1c, 0x80,
X   0x01, 0xf8, 0x00, 0x3e, 0x80, 0x01, 0xfc, 0x01, 0x7f, 0x80, 0x01, 0xfc,
X   0x01, 0x7f, 0x80, 0x01, 0xa8, 0x10, 0x2a, 0x80, 0x01, 0x20, 0x38, 0x08,
X   0x80, 0x01, 0x00, 0x7c, 0x00, 0x80, 0x01, 0x00, 0xfe, 0x00, 0x80, 0x01,
X   0x00, 0xfe, 0x00, 0x80, 0x01, 0x20, 0x54, 0x08, 0x80, 0x01, 0x70, 0x10,
X   0x1c, 0x80, 0x01, 0xf8, 0x00, 0x3e, 0x80, 0x01, 0xfc, 0x01, 0x7f, 0x80,
X   0x01, 0xfc, 0x01, 0x7f, 0x80, 0x01, 0xa8, 0x00, 0x2a, 0x80, 0x01, 0x20,
X   0x00, 0x08, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
X   0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x20, 0x00, 0x08, 0x80, 0x01,
X   0x70, 0x00, 0x1c, 0x80, 0x01, 0xf8, 0x00, 0x3e, 0x80, 0x01, 0xfc, 0x01,
X   0x7f, 0x80, 0x01, 0xfc, 0x01, 0x7f, 0x80, 0x01, 0xa8, 0x00, 0x2a, 0x80,
X   0x01, 0x20, 0x00, 0x08, 0x80, 0x01, 0x00, 0x00, 0x00, 0x8e, 0x01, 0x00,
X   0x00, 0x00, 0x91, 0x01, 0x00, 0x00, 0x00, 0x91, 0x01, 0x00, 0x00, 0x00,
X   0x91, 0x01, 0x00, 0x00, 0x00, 0x9e, 0x01, 0x00, 0x00, 0x00, 0x90, 0x01,
X   0x00, 0x00, 0x00, 0x91, 0x01, 0x00, 0x00, 0x00, 0x8e, 0x01, 0x00, 0x00,
X   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00,
X   0x00, 0x00, 0x80, 0xc9, 0x00, 0x00, 0x00, 0x80, 0x29, 0x01, 0x00, 0x00,
X   0x80, 0x29, 0x01, 0x00, 0x00, 0x80, 0x29, 0x01, 0x00, 0x00, 0x80, 0x29,
X   0x01, 0x00, 0x00, 0x80, 0x29, 0x01, 0x00, 0x00, 0x80, 0x29, 0x01, 0x00,
X   0x00, 0x80, 0xc9, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80,
X   0x01, 0x20, 0x00, 0x08, 0x80, 0x01, 0x70, 0x00, 0x1c, 0x80, 0x01, 0xf8,
X   0x00, 0x3e, 0x80, 0x01, 0xfc, 0x01, 0x7f, 0x80, 0x01, 0xfc, 0x01, 0x7f,
X   0x80, 0x01, 0xa8, 0x10, 0x2a, 0x80, 0x01, 0x20, 0x38, 0x08, 0x80, 0x01,
X   0x00, 0x7c, 0x00, 0x80, 0x01, 0x00, 0xfe, 0x00, 0x80, 0x01, 0x00, 0xfe,
X   0x00, 0x80, 0x01, 0x20, 0x54, 0x08, 0x80, 0x01, 0x70, 0x10, 0x1c, 0x80,
X   0x01, 0xf8, 0x00, 0x3e, 0x80, 0x01, 0xfc, 0x01, 0x7f, 0x80, 0x01, 0xfc,
X   0x01, 0x7f, 0x80, 0x01, 0xa8, 0x00, 0x2a, 0x80, 0x01, 0x20, 0x00, 0x08,
X   0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01,
X   0x00, 0x00, 0x00, 0x80, 0x01, 0x20, 0x00, 0x08, 0x80, 0x01, 0x70, 0x00,
X   0x1c, 0x80, 0x01, 0xf8, 0x00, 0x3e, 0x80, 0x01, 0xfc, 0x01, 0x7f, 0x80,
X   0x01, 0xfc, 0x01, 0x7f, 0x80, 0x01, 0xa8, 0x10, 0x2a, 0x80, 0x01, 0x20,
X   0x38, 0x08, 0x80, 0x01, 0x00, 0x7c, 0x00, 0x80, 0x01, 0x00, 0xfe, 0x00,
X   0x80, 0x01, 0x00, 0xfe, 0x00, 0x80, 0x01, 0x20, 0x54, 0x08, 0x80, 0x01,
X   0x70, 0x10, 0x1c, 0x80, 0x01, 0xf8, 0x00, 0x3e, 0x80, 0x01, 0xfc, 0x01,
X   0x7f, 0x80, 0x01, 0xfc, 0x01, 0x7f, 0x80, 0x01, 0xa8, 0x00, 0x2a, 0x80,
X   0x01, 0x20, 0x00, 0x08, 0x80, 0x01, 0x00, 0x00, 0x80, 0x8c, 0x01, 0x00,
X   0x00, 0x80, 0x92, 0x01, 0x00, 0x00, 0x80, 0x92, 0x01, 0x00, 0x00, 0x80,
X   0x92, 0x01, 0x00, 0x00, 0x80, 0x92, 0x01, 0x00, 0x00, 0x80, 0x92, 0x01,
X   0x00, 0x00, 0x80, 0x92, 0x01, 0x00, 0x00, 0x80, 0x8c, 0x01, 0x00, 0x00,
X   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00,
X   0x00, 0x00, 0x80, 0xc1, 0x01, 0x00, 0x00, 0x80, 0x81, 0x00, 0x00, 0x00,
X   0x80, 0x81, 0x00, 0x00, 0x00, 0x80, 0x81, 0x00, 0x00, 0x00, 0x80, 0x81,
X   0x00, 0x00, 0x00, 0x80, 0x89, 0x00, 0x00, 0x00, 0x80, 0x89, 0x00, 0x00,
X   0x00, 0x80, 0x71, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x00, 0x80, 0x41, 0x00, 0x00, 0x00, 0x80, 0xe1, 0x00,
X   0x00, 0x00, 0x80, 0xf1, 0x01, 0x00, 0x00, 0x80, 0xf9, 0x03, 0x00, 0x00,
X   0x80, 0xf9, 0x03, 0x00, 0x00, 0x80, 0x51, 0x01, 0x00, 0x00, 0x80, 0x41,
X   0x00, 0x00, 0x00, 0x80, 0x01, 0x20, 0x08, 0x02, 0x80, 0x01, 0x60, 0x14,
X   0x03, 0x80, 0x01, 0xa0, 0xa2, 0x02, 0x80, 0x01, 0x20, 0x41, 0x02, 0x80,
X   0x01, 0xe0, 0xff, 0x03, 0x80, 0x01, 0x20, 0x00, 0x02, 0x80, 0x01, 0x20,
X   0x00, 0x02, 0x80, 0x01, 0xa0, 0xe3, 0x02, 0x80, 0x01, 0x20, 0x08, 0x02,
X   0x80, 0x01, 0x20, 0x08, 0x02, 0x80, 0x01, 0x20, 0x08, 0x02, 0x80, 0x01,
X   0x20, 0x1c, 0x02, 0x80, 0x01, 0x20, 0x00, 0x02, 0x80, 0x01, 0x40, 0x00,
X   0x01, 0x80, 0x01, 0x40, 0x3e, 0x01, 0x80, 0x01, 0x80, 0x80, 0x00, 0x80,
X   0x01, 0x80, 0x80, 0x00, 0x80, 0x01, 0x00, 0x41, 0x00, 0x80, 0x01, 0x00,
X   0x3e, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
X   0x82, 0x01, 0x00, 0x00, 0x00, 0x87, 0x01, 0x00, 0x00, 0x80, 0x8f, 0x01,
X   0x00, 0x00, 0xc0, 0x9f, 0x01, 0x00, 0x00, 0xc0, 0x9f, 0x01, 0x00, 0x00,
X   0x80, 0x8a, 0x01, 0x00, 0x00, 0x00, 0x82, 0x01, 0x00, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x9c, 0x01, 0x00,
X   0x00, 0x00, 0x88, 0x01, 0x00, 0x00, 0x00, 0x88, 0x01, 0x00, 0x00, 0x00,
X   0x88, 0x01, 0x00, 0x00, 0x00, 0x88, 0x01, 0x00, 0x00, 0x80, 0x88, 0x01,
X   0x00, 0x00, 0x80, 0x88, 0x01, 0x00, 0x00, 0x00, 0x87, 0x01, 0x00, 0x00,
X   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00,
X   0x00, 0x00, 0x80, 0xf1, 0x00, 0x00, 0x00, 0x80, 0x09, 0x01, 0x00, 0x00,
X   0x80, 0x09, 0x01, 0x00, 0x00, 0x80, 0x09, 0x01, 0x00, 0x00, 0x80, 0x09,
X   0x01, 0x00, 0x00, 0x80, 0x49, 0x01, 0x00, 0x00, 0x80, 0x89, 0x01, 0x00,
X   0x00, 0x80, 0xf1, 0x00, 0x00, 0x00, 0x80, 0x01, 0x01, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x00, 0x80, 0x41, 0x00, 0x00, 0x00, 0x80, 0xe1, 0x00,
X   0x00, 0x00, 0x80, 0xf1, 0x01, 0x00, 0x00, 0x80, 0xf9, 0x03, 0x00, 0x00,
X   0x80, 0xf9, 0x03, 0x00, 0x00, 0x80, 0x51, 0x21, 0x22, 0x02, 0x80, 0x41,
X   0x20, 0x22, 0x02, 0x80, 0x01, 0x50, 0x55, 0x05, 0x80, 0x01, 0x50, 0x55,
X   0x05, 0x80, 0x01, 0x90, 0x88, 0x04, 0x80, 0x01, 0x10, 0x00, 0x04, 0x80,
X   0x01, 0xf0, 0xff, 0x07, 0x80, 0x01, 0x30, 0x00, 0x06, 0x80, 0x01, 0x30,
X   0x00, 0x06, 0x80, 0x01, 0xb0, 0xe3, 0x06, 0x80, 0x01, 0x30, 0x08, 0x06,
X   0x80, 0x01, 0x30, 0x08, 0x06, 0x80, 0x01, 0x30, 0x08, 0x06, 0x80, 0x01,
X   0x30, 0x1c, 0x06, 0x80, 0x01, 0x30, 0x00, 0x06, 0x80, 0x01, 0x70, 0x22,
X   0x07, 0x80, 0x01, 0x70, 0x3e, 0x07, 0x80, 0x01, 0xf8, 0x80, 0x0f, 0x80,
X   0x01, 0xfe, 0x80, 0x3f, 0x80, 0x01, 0x3c, 0x63, 0x1e, 0x80, 0x01, 0x00,
X   0x1c, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
X   0x82, 0x01, 0x00, 0x00, 0x00, 0x87, 0x01, 0x00, 0x00, 0x80, 0x8f, 0x01,
X   0x00, 0x00, 0xc0, 0x9f, 0x01, 0x00, 0x00, 0xc0, 0x9f, 0x01, 0x00, 0x00,
X   0x80, 0x8a, 0x01, 0x00, 0x00, 0x00, 0x82, 0x01, 0x00, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x8f, 0x01, 0x00,
X   0x00, 0x80, 0x90, 0x01, 0x00, 0x00, 0x80, 0x90, 0x01, 0x00, 0x00, 0x80,
X   0x90, 0x01, 0x00, 0x00, 0x80, 0x90, 0x01, 0x00, 0x00, 0x80, 0x94, 0x01,
X   0x00, 0x00, 0x80, 0x98, 0x01, 0x00, 0x00, 0x00, 0x8f, 0x01, 0x00, 0x00,
X   0x00, 0x90, 0x01, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00,
X   0x00, 0x00, 0x80, 0x89, 0x00, 0x00, 0x00, 0x80, 0x89, 0x00, 0x00, 0x00,
X   0x80, 0x49, 0x00, 0x00, 0x00, 0x80, 0x29, 0x00, 0x00, 0x00, 0x80, 0x19,
X   0x00, 0x00, 0x00, 0x80, 0x29, 0x00, 0x00, 0x00, 0x80, 0x49, 0x00, 0x00,
X   0x00, 0x80, 0x89, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x00, 0x80, 0x41, 0x00, 0x00, 0x00, 0x80, 0xe1, 0x00,
X   0x00, 0x00, 0x80, 0xf1, 0x01, 0x00, 0x00, 0x80, 0xf9, 0x03, 0x00, 0x00,
X   0x80, 0xf9, 0x03, 0x00, 0x00, 0x80, 0x51, 0x21, 0x22, 0x02, 0x80, 0x41,
X   0x20, 0x22, 0x02, 0x80, 0x01, 0x50, 0x55, 0x05, 0x80, 0x01, 0x50, 0x55,
X   0x05, 0x80, 0x01, 0x90, 0x88, 0x04, 0x80, 0x01, 0x10, 0x00, 0x04, 0x80,
X   0x01, 0xf0, 0xff, 0x07, 0x80, 0x01, 0x10, 0x00, 0x04, 0x80, 0x01, 0x10,
X   0x00, 0x04, 0x80, 0x01, 0x90, 0xe3, 0x04, 0x80, 0x01, 0x10, 0x08, 0x04,
X   0x80, 0x01, 0x10, 0x08, 0x04, 0x80, 0x01, 0x10, 0x08, 0x04, 0x80, 0x01,
X   0x10, 0x1c, 0x04, 0x80, 0x01, 0x10, 0x00, 0x04, 0x80, 0x01, 0x30, 0x00,
X   0x06, 0x80, 0x01, 0x20, 0x3e, 0x02, 0x80, 0x01, 0x60, 0x00, 0x03, 0x80,
X   0x01, 0xc0, 0x80, 0x01, 0x80, 0x01, 0xc0, 0xe3, 0x01, 0x80, 0x01, 0x80,
X   0xff, 0x00, 0x80, 0x01, 0x00, 0x7f, 0x00, 0x80, 0x01, 0x00, 0x7f, 0x00,
X   0x82, 0x01, 0x00, 0x3e, 0x00, 0x87, 0x01, 0x00, 0x1c, 0x80, 0x8f, 0x01,
X   0x00, 0x00, 0xc0, 0x9f, 0x01, 0x00, 0x00, 0xc0, 0x9f, 0x01, 0x00, 0x00,
X   0x80, 0x8a, 0x01, 0x00, 0x00, 0x00, 0x82, 0x01, 0x00, 0x00, 0x00, 0x80,
X   0x01, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x91, 0x01, 0x00,
X   0x00, 0x00, 0x91, 0x01, 0x00, 0x00, 0x00, 0x89, 0x01, 0x00, 0x00, 0x00,
X   0x85, 0x01, 0x00, 0x00, 0x00, 0x83, 0x01, 0x00, 0x00, 0x00, 0x85, 0x01,
X   0x00, 0x00, 0x00, 0x89, 0x01, 0x00, 0x00, 0x00, 0x91, 0x01, 0x00, 0x00,
X   0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff};
SHAR_EOF
echo 'File cards.bm is complete' &&
chmod 0644 cards.bm ||
echo 'restore of cards.bm failed'
Wc_c="`wc -c < 'cards.bm'`"
test 97581 -eq "$Wc_c" ||
	echo 'cards.bm: original size 97581, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= club.bm ==============
if test -f 'club.bm' -a X"$1" != X"-c"; then
	echo 'x - skipping club.bm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting club.bm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'club.bm' &&
#define club_width 11
#define club_height 11
static char club_bits[] = {
X   0x20, 0x00, 0x70, 0x00, 0xf8, 0x00, 0x74, 0x01, 0xae, 0x03, 0xff, 0x07,
X   0xae, 0x03, 0x24, 0x01, 0x20, 0x00, 0x20, 0x00, 0x70, 0x00};
SHAR_EOF
chmod 0644 club.bm ||
echo 'restore of club.bm failed'
Wc_c="`wc -c < 'club.bm'`"
test 212 -eq "$Wc_c" ||
	echo 'club.bm: original size 212, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= cursor.bm ==============
if test -f 'cursor.bm' -a X"$1" != X"-c"; then
	echo 'x - skipping cursor.bm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting cursor.bm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'cursor.bm' &&
#define cursor_width 16
#define cursor_height 16
#define cursor_x_hot 2
#define cursor_y_hot 0
static char cursor_bits[] = {
X   0x1c, 0x00, 0x24, 0x00, 0x48, 0x00, 0x90, 0x10, 0x20, 0x29, 0x70, 0x2a,
X   0x90, 0x2c, 0x1c, 0x21, 0x64, 0x20, 0x0a, 0x20, 0x32, 0x40, 0x04, 0x40,
X   0x18, 0x80, 0x60, 0x40, 0x80, 0x21, 0x00, 0x1e};
SHAR_EOF
chmod 0644 cursor.bm ||
echo 'restore of cursor.bm failed'
Wc_c="`wc -c < 'cursor.bm'`"
test 327 -eq "$Wc_c" ||
	echo 'cursor.bm: original size 327, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= diamond.bm ==============
if test -f 'diamond.bm' -a X"$1" != X"-c"; then
	echo 'x - skipping diamond.bm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting diamond.bm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'diamond.bm' &&
#define diamond_width 11
#define diamond_height 11
static char diamond_bits[] = {
X   0x20, 0x00, 0x70, 0x00, 0xf8, 0x00, 0xfc, 0x01, 0xfe, 0x03, 0xff, 0x07,
X   0xfe, 0x03, 0xfc, 0x01, 0xf8, 0x00, 0x70, 0x00, 0x20, 0x00};
SHAR_EOF
chmod 0644 diamond.bm ||
echo 'restore of diamond.bm failed'
Wc_c="`wc -c < 'diamond.bm'`"
test 221 -eq "$Wc_c" ||
	echo 'diamond.bm: original size 221, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= draw.bm ==============
if test -f 'draw.bm' -a X"$1" != X"-c"; then
	echo 'x - skipping draw.bm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting draw.bm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'draw.bm' &&
#define draw_width 16
#define draw_height 16
static short draw_bits[] = {
X   0x8181, 0x4242, 0x2424, 0x1818,
X   0x1818, 0x2424, 0x4242, 0x8181,
X   0x8181, 0x4242, 0x2424, 0x1818,
X   0x1818, 0x2424, 0x4242, 0x8181};
SHAR_EOF
chmod 0644 draw.bm ||
echo 'restore of draw.bm failed'
Wc_c="`wc -c < 'draw.bm'`"
test 215 -eq "$Wc_c" ||
	echo 'draw.bm: original size 215, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= draw2.bm ==============
if test -f 'draw2.bm' -a X"$1" != X"-c"; then
	echo 'x - skipping draw2.bm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting draw2.bm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'draw2.bm' &&
#define draw2_width 16
#define draw2_height 16
static char draw2_bits[] = {
X   0x81, 0x81, 0x42, 0x42, 0x24, 0x24, 0x18, 0x18, 0x18, 0x18, 0x24, 0x24,
X   0x42, 0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x42, 0x24, 0x24, 0x18, 0x18,
X   0x18, 0x18, 0x24, 0x24, 0x42, 0x42, 0x81, 0x81};
SHAR_EOF
chmod 0644 draw2.bm ||
echo 'restore of draw2.bm failed'
Wc_c="`wc -c < 'draw2.bm'`"
test 278 -eq "$Wc_c" ||
	echo 'draw2.bm: original size 278, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= exit.bm ==============
if test -f 'exit.bm' -a X"$1" != X"-c"; then
	echo 'x - skipping exit.bm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting exit.bm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'exit.bm' &&
#define exit_width 48
#define exit_height 16
static char exit_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x92, 0x0f, 0x00,
X   0x00, 0xe0, 0x23, 0x12, 0x02, 0x00, 0x00, 0x20, 0x40, 0x11, 0x02, 0x00,
X   0x00, 0x20, 0x80, 0x10, 0x02, 0x00, 0x00, 0x20, 0x40, 0x11, 0x02, 0x00,
X   0x00, 0x20, 0x20, 0x12, 0x02, 0x00, 0x00, 0xe0, 0x27, 0x12, 0x02, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 exit.bm ||
echo 'restore of exit.bm failed'
Wc_c="`wc -c < 'exit.bm'`"
test 674 -eq "$Wc_c" ||
	echo 'exit.bm: original size 674, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= flip.bm ==============
if test -f 'flip.bm' -a X"$1" != X"-c"; then
	echo 'x - skipping flip.bm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting flip.bm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'flip.bm' &&
#define flip_width 48
#define flip_height 16
static char flip_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0xe0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x90, 0x07, 0x00,
X   0x00, 0xe0, 0x23, 0x90, 0x08, 0x00, 0x00, 0x20, 0x20, 0x90, 0x08, 0x00,
X   0x00, 0x20, 0x20, 0x90, 0x07, 0x00, 0x00, 0x20, 0x20, 0x90, 0x00, 0x00,
X   0x00, 0x20, 0x20, 0x90, 0x00, 0x00, 0x00, 0x20, 0xe0, 0x93, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 flip.bm ||
echo 'restore of flip.bm failed'
Wc_c="`wc -c < 'flip.bm'`"
test 674 -eq "$Wc_c" ||
	echo 'flip.bm: original size 674, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= gray3.bitmap ==============
if test -f 'gray3.bitmap' -a X"$1" != X"-c"; then
	echo 'x - skipping gray3.bitmap (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting gray3.bitmap (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'gray3.bitmap' &&
#define gray3_width 16
#define gray3_height 16
static char gray3_bits[] = {
X   0x11, 0x11, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00, 0x11, 0x11, 0x00, 0x00,
X   0x44, 0x44, 0x00, 0x00, 0x11, 0x11, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00,
X   0x11, 0x11, 0x00, 0x00, 0x44, 0x44, 0x00, 0x00};
SHAR_EOF
chmod 0644 gray3.bitmap ||
echo 'restore of gray3.bitmap failed'
Wc_c="`wc -c < 'gray3.bitmap'`"
test 278 -eq "$Wc_c" ||
	echo 'gray3.bitmap: original size 278, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= heart.bm ==============
if test -f 'heart.bm' -a X"$1" != X"-c"; then
	echo 'x - skipping heart.bm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting heart.bm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'heart.bm' &&
#define heart_width 11
#define heart_height 11
static char heart_bits[] = {
X   0x8c, 0xf9, 0xde, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
X   0xfe, 0xfb, 0xfc, 0xf9, 0xf8, 0xf8, 0x70, 0xf8, 0x20, 0xf8};
SHAR_EOF
chmod 0644 heart.bm ||
echo 'restore of heart.bm failed'
Wc_c="`wc -c < 'heart.bm'`"
test 215 -eq "$Wc_c" ||
	echo 'heart.bm: original size 215, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= mkPixmap.c ==============
if test -f 'mkPixmap.c' -a X"$1" != X"-c"; then
	echo 'x - skipping mkPixmap.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting mkPixmap.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mkPixmap.c' &&
#include	<X11/Xlib.h>
X
Pixmap 
MakePixmap(dpy, scr, root, data, width, height, ximage)
Display	*dpy;
int	scr;
Drawable root;
short *data;
int width, height;
XXImage	*ximage;
{
X    GC pgc;
X    XGCValues gcv;
X    Pixmap pid;
X
X    pid = XCreatePixmap(dpy, root, width, height, DefaultDepth(dpy, scr));
X
X    gcv.foreground = BlackPixel(dpy, scr);
X    gcv.background = WhitePixel(dpy, scr);
X    pgc = XCreateGC(dpy, pid, GCForeground | GCBackground, &gcv);
X
X    ximage->height = height;
X    ximage->width = width;
X    ximage->xoffset = 0;
X    ximage->format = XYBitmap;
X    ximage->data = (char *)data;
X    ximage->byte_order = LSBFirst;
X    ximage->bitmap_unit = 16;
X    ximage->bitmap_bit_order = LSBFirst;
X    ximage->bitmap_pad = 16;
X    ximage->bytes_per_line = (width+7)/8;
X    ximage->depth = 1;
X
X    XPutImage(dpy, pid, pgc, ximage, 0, 0, 0, 0, width, height);
X    XFreeGC(dpy, pgc);
X    return(pid);
}
X
MakeImage(width, height, data, ximage)
int	width, height;
char	*data;
XXImage	*ximage;
{
X    ximage->height = height;
X    ximage->width = width;
X    ximage->xoffset = 0;
X    ximage->format = XYBitmap;
X    ximage->data = (char *)data;
X    ximage->byte_order = LSBFirst;
X    ximage->bitmap_unit = 16;
X    ximage->bitmap_bit_order = LSBFirst;
X    ximage->bitmap_pad = 16;
X    ximage->bytes_per_line = (width+7)/8;
X    ximage->depth = 1;
}
SHAR_EOF
chmod 0644 mkPixmap.c ||
echo 'restore of mkPixmap.c failed'
Wc_c="`wc -c < 'mkPixmap.c'`"
test 1341 -eq "$Wc_c" ||
	echo 'mkPixmap.c: original size 1341, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= restart.bm ==============
if test -f 'restart.bm' -a X"$1" != X"-c"; then
	echo 'x - skipping restart.bm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting restart.bm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'restart.bm' &&
#define restart_width 48
#define restart_height 16
static char restart_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00,
X   0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x84, 0x78, 0x9c, 0x8f, 0x71, 0x7c,
X   0x7c, 0x08, 0x02, 0x42, 0x92, 0x10, 0x44, 0x08, 0x02, 0x42, 0x92, 0x10,
X   0x44, 0x38, 0x0c, 0xc2, 0x73, 0x10, 0x84, 0x08, 0x10, 0x42, 0x52, 0x10,
X   0x84, 0x08, 0x10, 0x42, 0x92, 0x10, 0x04, 0x79, 0x0e, 0x42, 0x92, 0x10,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 restart.bm ||
echo 'restore of restart.bm failed'
Wc_c="`wc -c < 'restart.bm'`"
test 683 -eq "$Wc_c" ||
	echo 'restart.bm: original size 683, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= spade.bm ==============
if test -f 'spade.bm' -a X"$1" != X"-c"; then
	echo 'x - skipping spade.bm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting spade.bm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'spade.bm' &&
#define spade_width 11
#define spade_height 11
static char spade_bits[] = {
X   0x20, 0x00, 0x70, 0x00, 0xf8, 0x00, 0xfc, 0x01, 0xfe, 0x03, 0xff, 0x07,
X   0xff, 0x07, 0xff, 0x07, 0xae, 0x03, 0x20, 0x00, 0x70, 0x00};
SHAR_EOF
chmod 0644 spade.bm ||
echo 'restore of spade.bm failed'
Wc_c="`wc -c < 'spade.bm'`"
test 215 -eq "$Wc_c" ||
	echo 'spade.bm: original size 215, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xsol.c ==============
if test -f 'xsol.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xsol.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xsol.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xsol.c' &&
/*
X * solitaire.c - A simple solitaire card game for X Windows. 
X * Written by David W. Burleigh, April 1987, for the 
X * Workstation Sales Support Training.
X * 
X */
/*
X * Converted to handle B & W displays 
X * Dave Lemke, 
X * 7/13/87, 
X * UCDavis Computer Science
X * 
X * 
X * Args: 
X * hostname:display -r	
X * -r	flag to turn off black cards reversed in B & W 
X *	- makes them simpler to read
X */
/*
X * converted to X11, 7/16/87 - 8/6/87 Dave Lemke
X */
/*
X * Final conversion work, optimizing, cleanup:
X * Dave Lemke
X * lemke@sun.com
X * Wed Jul 20 21:52:00 PDT 1988
X */
X
/************************************************************
Copyright 1988 by Sun Microsystems, Inc. Mountain View, CA.
X
X		All Rights Reserved
X
Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Sun or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific prior written permission. Sun and M.I.T. 
make no representations about the suitability of this software for 
any purpose. It is provided "as is" without any express or implied warranty.
X
SUN DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE. IN NO EVENT SHALL SUN BE LIABLE FOR ANY SPECIAL, INDIRECT
OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
OR PERFORMANCE OF THIS SOFTWARE.
************************************************************/
X
#include <X11/Xos.h>
#include <X11/Xlib.h>
#include <X11/X10.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <stdio.h>
#include <strings.h>
#include "cards.bm"		/* Bitmaps for playing cards */
#include "draw.bm"		/* Bitmap for back of card deck */
#include "heart.bm"		/* Bitmaps for suits */
#include "club.bm"
#include "diamond.bm"
#include "spade.bm"
#include "cursor.bm"		/* Bitmap for cursor */
#include "restart.bm"		/* Bitmap for Restart button */
#include "flip.bm"		/* Bitmap for Flip button - Added JB */
#include "exit.bm"		/* Bitmap for Exit button */
X
#include "gray3.bitmap"	/* bitmap for B & W background */
X
#define	Border_width	3
#define	Defwidth	360	/* Default dimensions for window */
#define	Defheight	500
#define	Offset		25	/* y offset for stacking cards */
X
#define	Hearts		0
#define	Diamonds	1
#define	Clubs		2
#define	Spades		3
X
#define	Ace		1
#define	King		13
X
#define	Draw		52	/* Array index for draw window */
X
int ndeck;			/* Number of cards in deck - Added JB */
X
struct Card {
X	Window          self;	/* window id */
X	short           suit;	/* Hearts,Diamonds,Clubs,Spades */
X	short           value;	/* Ace,2,3,4,5,6,7,8,9,10,Jack,Queen,King */
X	short           x, y;	/* Origin coordinates */
X	short           stack;	/* Indicates which stack the card is in */
X	struct Card    *prev;	/* Points to previous stacked card */
X	struct Card    *next;	/* Points to next stacked card */
X	XImage          image;	/* windows image */
}               deck[Draw];
struct Card     card_window;
X
struct {			/* Locations for stacking card windows */
X	short           x, y;
X	short           count;
}               stack[12] = {
X	59, 9, 52, 
X	9, 79, 0, 
X	59, 79, 0, 
X	109, 79, 0,
X	159, 79, 0, 
X	209, 79, 0, 
X	259, 79, 0, 
X	309, 79, 0,
X	129, 9, 0, 
X	179, 9, 0, 
X	229, 9, 0, 
X	279, 9, 0
};
X
#define	CNULL	(struct Card *) 0
X
#define	TRUE	1
#define	FALSE	0
X
short           iscolor = False;
short           rflag = 42;
X
short           order[Draw][2];	/* Shuffling array */
X
XXAssocTable    *Key;		/* Pointer to the association table for
X				 * matching windows to data structures */
X
static XColor   foreground = {0L, 65535, 65535, 65535};
static XColor   bground = {0L, 0, 0, 0};
X
XXColor          Red, Green, Black, White;
Window          Table, Restart, Exit;	/* Display window and button ids */
Window		Flip;			/* Added JB */
GC              gc, rgc, Redgc, out_gc;
XXImage          res_image, exit_image;
XXImage		flip_image;		/* Added JB */
Pixmap          background, draw_pixmap;
Pixmap		icon_pixmap;
Atom		protocol_atom, kill_atom;
X
Bool	have_card = False;
Bool	no_drag = False;
X
#define	Usage	{fprintf(stderr, "xsol: [-d display] [-r] [-nodrag]\n"); exit(0);}
X
Display        *dpy;
int             screen;
X
main(argc, argv)
X	int             argc;	/* Number of arguments  */
X	char           *argv[];	/* Array of pointers to arguments          */
{
X	register int    i;
X	Pixmap          cursor_bitmap;
X	struct Card    *from = (struct Card *) 0,
X		       *to = (struct Card *) 0;	/* User-selected cards */
X	char           *display = NULL;
X	XImage          timage;
X	char           *progname;
X	XSizeHints	hints;
X
X	progname = argv[0];
X	for (i = 1; i < argc; i++) {
X		if (index(argv[i], ':'))
X			display = argv[i];
X		else if (strncmp(argv[i], "-d", 2) == 0)	{
X			if (argv[++i])
X				display = argv[i];
X			else Usage;
X		}
X		else if (strncmp(argv[i], "-r", 2) == 0)
X			rflag = 1;
X		else if (strncmp(argv[i], "+r", 2) == 0)
X			rflag = 0;
X		else if (strncmp(argv[i], "-n", 2) == 0)
X			no_drag = True;
X		else
X			Usage;
X	}
X
X	if (!(dpy = XOpenDisplay(display))) {
X		fprintf(stderr, "%s: Can't open display.\n", progname);
X		exit(1);
X	}
X	screen = DefaultScreen(dpy);
X
X	gc = XCreateGC(dpy, RootWindow(dpy, screen), 0, NULL);
X	rgc = XCreateGC(dpy, RootWindow(dpy, screen), 0, NULL);
X	Redgc = XCreateGC(dpy, RootWindow(dpy, screen), 0, NULL);
X	out_gc = XCreateGC(dpy, RootWindow(dpy, screen), 0, NULL);
X
X	XSetForeground(dpy, gc, BlackPixel(dpy, screen));
X	XSetForeground(dpy, rgc, WhitePixel(dpy, screen));
X
X	XSetBackground(dpy, gc, WhitePixel(dpy, screen));
X	XSetBackground(dpy, rgc, BlackPixel(dpy, screen));
X
X	XSetForeground(dpy, out_gc, BlackPixel(dpy, screen));
X	XSetFunction(dpy, out_gc, GXxor);
X	XSetSubwindowMode(dpy, out_gc, IncludeInferiors);
X
X	if (DisplayCells(dpy, screen) > 2)
X		iscolor = TRUE;
X	if (iscolor) {
X		XAllocNamedColor(dpy, DefaultColormap(dpy, screen),
X				 "red", &Red, &Red);
X		XAllocNamedColor(dpy, DefaultColormap(dpy, screen),
X				 "green", &Green, &Green);
X		XAllocNamedColor(dpy, DefaultColormap(dpy, screen),
X				 "black", &Black, &Black);
X		XAllocNamedColor(dpy, DefaultColormap(dpy, screen),
X				 "white", &White, &White);
X		XSetForeground(dpy, Redgc, Red.pixel);
X		XSetBackground(dpy, Redgc, White.pixel);
X		if (rflag == 42)
X			rflag = 0;
X	}
X	if (!iscolor && rflag == 42)
X		rflag = 1;
X		
X	/* Fill in parent window parameters */
X
X	if (!iscolor) {
X		background = MakePixmap(dpy, screen, RootWindow(dpy, screen),
X			    gray3_bits, gray3_width, gray3_height, &timage);
X	}
X	/* Store pixmaps for tiling areas */
X
X	draw_pixmap = MakePixmap(dpy, screen, RootWindow(dpy, screen),
X			       draw_bits, draw_width, draw_height, &timage);
X
X	icon_pixmap = XCreatePixmap(dpy, RootWindow(dpy, screen),
X		32, 32, DefaultDepth(dpy, screen));
X
X	{
X	XImage	temp;
X	GC	redgc = (iscolor) ? Redgc : gc;
X	GC	icon_gc, redicon_gc;
X
X	icon_gc = XCreateGC(dpy, icon_pixmap, 0, NULL);
X	redicon_gc = XCreateGC(dpy, icon_pixmap, 0, NULL);
X	if (iscolor)	{
X	    XSetForeground(dpy, icon_gc, Green.pixel);
X	    XFillRectangle(dpy, icon_pixmap, icon_gc, 0, 0, 32, 32);
X	    XSetForeground(dpy, redicon_gc, Red.pixel);
X	    XSetBackground(dpy, redicon_gc, Green.pixel);
X	    XSetForeground(dpy, icon_gc, BlackPixel(dpy, screen));
X	    XSetBackground(dpy, icon_gc, Green.pixel);
X	} else	{
X	    XSetForeground(dpy, icon_gc, WhitePixel(dpy, screen));
X	    XSetBackground(dpy, icon_gc, WhitePixel(dpy, screen));
X	    XSetBackground(dpy, redicon_gc, WhitePixel(dpy, screen));
X	    XFillRectangle(dpy, icon_pixmap, icon_gc, 0, 0, 32, 32);
X	    XSetForeground(dpy, icon_gc, BlackPixel(dpy, screen));
X	    XSetForeground(dpy, redicon_gc, BlackPixel(dpy, screen));
X	}
X
X	MakeImage(spade_width, spade_height, spade_bits, &temp);
X	XPutImage(dpy, icon_pixmap, icon_gc, &temp, 0, 0, 2, 2, 
X		spade_width, spade_height);
X	MakeImage(heart_width, heart_height, heart_bits, &temp);
X	XPutImage(dpy, icon_pixmap, redicon_gc, &temp, 0, 0, 17, 2, 
X		heart_width, heart_height);
X	MakeImage(club_width, club_height, club_bits, &temp);
X	XPutImage(dpy, icon_pixmap, icon_gc, &temp, 0, 0, 17, 17, 
X		club_width, club_height);
X	MakeImage(diamond_width, diamond_height, diamond_bits, &temp);
X	XPutImage(dpy, icon_pixmap, redicon_gc, &temp, 0, 0, 2, 17, 
X		diamond_width, diamond_height);
X	XFreeGC(dpy, icon_gc);
X	XFreeGC(dpy, redicon_gc);
X	}
X
X	/* Try to create the display window and icon window */
X
X	Table = XCreateSimpleWindow(dpy, RootWindow(dpy, screen), 100, 100,
X		 Defwidth, Defheight, Border_width, BlackPixel(dpy, screen),
X				    BlackPixel(dpy, screen));
X	if (iscolor)
X		XSetWindowBackground(dpy, Table, Green.pixel);
X	else
X		XSetWindowBackgroundPixmap(dpy, Table, background);
X
X	protocol_atom = XInternAtom(dpy, "WM_PROTOCOLS", False);
X	kill_atom = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
X	XSetWMProtocols(dpy, Table, &kill_atom, 1);
X
X	if (!Table) {
X		fprintf(stderr, "%s: can't create display window.\n", progname);
X		exit(1);
X	}
X	
X	hints.flags = PSize | PMinSize | PMaxSize;
X	/* doesn't like to be resized */
X	hints.width = hints.min_width = hints.max_width = Defwidth;
X	hints.height = hints.min_height = hints.max_height = Defheight;
X
X	XSetStandardProperties(dpy, Table, "Xsol", "Xsol", icon_pixmap,
X		argv, argc, &hints);
X
X	/* Create windows for Restart and Exit buttons */
X
X	Restart = XCreateSimpleWindow(dpy, Table, 0, Defheight - restart_height,
X		restart_width, restart_height, 1, BlackPixel(dpy, screen), 
X		WhitePixel(dpy, screen));
X	MakeImage(restart_width, restart_height, restart_bits, &res_image);
X
X	Exit = XCreateSimpleWindow(dpy, Table, Defwidth - exit_width,
X		Defheight - exit_height, exit_width, exit_height,
X		1, BlackPixel(dpy, screen), WhitePixel(dpy, screen));
X	MakeImage(exit_width, exit_height, exit_bits, &exit_image);
X
/* ++	Create window for Flip button - Added by Jon Brinkmann 7/20/90 */
X
X	Flip = XCreateSimpleWindow(dpy, Table, (Defwidth - flip_width) / 2,
X		Defheight - flip_height, flip_width, flip_height, 1,
X		BlackPixel(dpy, screen), WhitePixel(dpy, screen));
X	MakeImage(flip_width, flip_height, flip_bits, &flip_image);
X	if (!(Restart && Flip && Exit)) {
/* -- */
/*	if (!(Restart && Exit)) { */
X		fprintf(stderr, "%s: can't create button subwindows.\n", 
X			progname);
X		exit(1);
X	}
X
X	/* Associate the cursor with the display window */
X	cursor_bitmap = XCreateBitmapFromData(dpy, RootWindow(dpy, screen),
X		cursor_bits, cursor_width, cursor_height);
X
X	XDefineCursor(dpy, Table, XCreatePixmapCursor(dpy, cursor_bitmap,
X		cursor_bitmap, &bground, &foreground, 0, 0));
X
X	/* Initialize subwindow structures and create card subwindows */
X
X	if (!InitCardWindows(Table)) {
X		fprintf(stderr, "%s: Can't create subwindows.\n", progname);
X		exit(1);
X	}
X	/* Tell the X-window server which events we're interested in */
X
X	XSelectInput(dpy, card_window.self, ButtonPressMask);
X	/* table sucks buttons so they don't slide through to parent
X	 * when player slips off card */
X	XSelectInput(dpy, Table, ExposureMask | ButtonPressMask |
X		((no_drag) ? PointerMotionMask : 0));
X	XSelectInput(dpy, Restart, ExposureMask | ButtonPressMask);
X	XSelectInput(dpy, Flip, ExposureMask | ButtonPressMask); /* Added JB */
X	XSelectInput(dpy, Exit, ExposureMask | ButtonPressMask);
X
X	DealCards();		/* Shuffle cards and deal to playing field */
X
X	XMapWindow(dpy, Table);
X	XMapWindow(dpy, Restart);
X	XMapWindow(dpy, Flip);	/* Added JB */
X	XMapWindow(dpy, Exit);
X	XMapWindow(dpy, card_window.self);
X
X	while (1) {		/* Process events */
X		XEvent          event;
X		int	oldx, oldy;
X		int	mx, my;
X		int	num_cards;
X		struct Card	*t;
X
X		XNextEvent(dpy, &event);
X
X		switch (event.type) {
X
X		case ClientMessage:
X		    {
X		    XClientMessageEvent	*ev = (XClientMessageEvent *)&event;
X
X		    if (ev->message_type == protocol_atom && 
X			ev->data.l[0] == kill_atom)
X			exit(0);
X		    }
X		    break;
X		case Expose:
X			DisplayCard(event.xexpose.window);
X			break;
X		case ButtonPress:
X		    if (!have_card)	{
X			SelectCard(event.xbutton.window, &from);
X			if (from)	{
X				/* count cards */
X				for (num_cards = 0, t = from; t->next; 
X				    t = t->next, num_cards++)
X					;
X				oldx = oldy = -1;
X				mx = event.xbutton.x;
X				my = event.xbutton.y;
X				}
X			}
X		    else	{
X			if (from != CNULL)	/* only w/ no_drag */
X				/* erase old outline */
X				draw_outline(oldx, oldy, num_cards);
X				have_card = False;
X				MoveCard(event.xbutton.window, 
X					&from, &to);
X				}
X			break;
X		case MotionNotify:
X			if (have_card)	{
X				draw_outline(oldx, oldy, num_cards);
X				oldx = ((XMotionEvent *) &(event))->x_root - mx;
X				oldy = ((XMotionEvent *) &(event))->y_root - my;
X				draw_outline(oldx, oldy, num_cards);
X				}
X			break;
X		case ButtonRelease:	/* only w/o nodrag */
X			if (from != CNULL)	{
X				/* erase old outline */
X				draw_outline(oldx, oldy, num_cards);
X				have_card = False;
X				MoveCard(event.xbutton.window, &from, &to);
X				}
X			break;
X		}
X	}
}
X
InitCardWindows(Table)		/* Fill in subwindow structures */
X	Window          Table;
X
{
X	register int    i;
X	XAssocTable    *XCreateAssocTable();
X	XSetWindowAttributes watt;
X	Pixmap	pmap;
X
X	/* Initialize OpaqueFrame structures and shuffling array */
X
X	watt.backing_store = Always;
X	for (i = 0; i < Draw; i++) {
X		deck[i].x = stack[0].x;
X		deck[i].y = stack[0].y;
X		deck[i].stack = 0;
X		deck[i].next = deck[i].prev = CNULL;
X		deck[i].self = XCreateSimpleWindow(dpy, Table, 
X			deck[i].x, deck[i].y, card_width, card_height, 
X			0, (Pixmap) 0, WhitePixel(dpy, screen));
X		XSelectInput(dpy, deck[i].self,
X			ExposureMask | ButtonPressMask |
X			((no_drag) ? 0 :
X			(ButtonReleaseMask | OwnerGrabButtonMask 
X			| Button1MotionMask)));
X		XChangeWindowAttributes(dpy, deck[i].self, 
X			CWBackingStore, &watt);
X		MakeImage(card_width, card_height, card_bits[i],
X			&(deck[i].image));
X	}
X	card_window.x = card_window.y = 9;
X	card_window.self = XCreateSimpleWindow(dpy, Table, 
X		card_window.x, card_window.y, 
X		(card_width - 4), (card_height - 4), 
X		2, BlackPixel(dpy, 0), (Pixmap) 0);
X	XSetWindowBackgroundPixmap(dpy, card_window.self, draw_pixmap);
X
X	/* Make a table for associating window ids to Card structures */
X
X	if (!(Key = XCreateAssocTable(16)))	/* 16-bucket hash table */
X		return (0);
X
X	for (i = 0; i < Draw; i++) {
X
X		/* Associate address of card with card's window id */
X		XMakeAssoc(dpy, Key, deck[i].self, &deck[i]);
X	}
X
X	/* Initialize the cards to their suits and values */
X
X	for (i = 0; i < 13; i++) {
X		deck[i].suit = Hearts;
X		deck[i].value = i + 1;
X	}
X	for (; i < 26; i++) {
X		deck[i].suit = Diamonds;
X		deck[i].value = i - 12;
X	}
X	for (; i < 39; i++) {
X		deck[i].suit = Clubs;
X		deck[i].value = i - 25;
X	}
X	for (; i < Draw; i++) {
X		deck[i].suit = Spades;
X		deck[i].value = i - 38;
X	}
X
X	srandom((int) time(0));	/* Seed the random number generator with the
X				 * system time */
X
X	return (1);
}
X
DealCards()
{
X	register int    i, j, k;
X	int             compare();
X
X	for (i = 0; i < Draw; i++) {
X		order[i][0] = i;	/* Moved here from InitCardWindows JB */
X		order[i][1] = random();	/* Fill the shuffling array with
X					 * random numbers */
X	}
X
X	qsort((char *) order, Draw, 4, compare);	/* Shuffle by sorting the
X						 * random numbers */
X
X	/* Deal the cards to the field stacks */
X
X	ndeck = Draw;			/* Added JB */
X
X	for (i = 1; i < 8; i++) {
X		for (j = i; j < 8; j++) {
X			/* Get index of next card in deck */
X			k = order[--stack[0].count][0];	
X			ndeck--;				/* Added JB */
X			/* Move it to its new stack */
X			XMoveWindow(dpy, deck[k].self,
X				stack[j].x, stack[j].y);
X			if (j == i) /* Make it visible if its on the top */
X				XMapRaised(dpy, deck[k].self);	
X			deck[k].x = stack[j].x;	/* Update locator fields */
X			deck[k].y = stack[j].y;
X			deck[k].stack = j;	/* Update stack number */
X			++stack[j].count;	/* Update card count in stack */
X		}
X	}
X
X	/* map later, so we don't give any hints about what's in each stack */
X	for (i = 0; i < Draw; i++)	{
X		/* don't map cards in draw deck */
/*		if (deck[i].y != stack[0].y)	*/
X		if (deck[i].stack != 0)
X			XMapWindow(dpy, deck[i].self);
X		}
X	/* map first draw */
X	XMapRaised(dpy, deck[order[--stack[0].count][0]].self);
}
X
compare(arg1, arg2)		/* Compare low-order word only, for use in
X				 * qsort */
X	long           *arg1, *arg2;
X
{
#if defined(vax) || defined(i386)
X	return ((*arg2 & 0xffff0000) - (*arg1 & 0xffff0000));
#else
X	return ((*arg2 & 0xffff) - (*arg1 & 0xffff));
#endif
}
X
DisplayCard(window)		/* Service ExposeWindow events */
X	Window          window;
X
{
X	if (window == Restart)
X		XPutImage(dpy, Restart, gc, &res_image, 0, 0, 0, 0,
X			  restart_width, restart_height);
/* ++	Added by Jon Brinkmann 7/20/90 */
X	else if (window == Flip)
X		XPutImage(dpy, Flip, gc, &flip_image, 0, 0, 0, 0,
X			  flip_width, flip_height);
/* -- */
X	else if (window == Exit)
X		XPutImage(dpy, Exit, gc, &exit_image, 0, 0, 0, 0, 
X			exit_width, exit_height);
X	else if (window == Table)
X		;		/* noop (for now) */
X	else {
X		struct Card    *c;
X
X		/* Find the card structure that corresponds to the window */
X
X		c = (struct Card *) XLookUpAssoc(dpy, Key, window);
X
X		/* Fill the card window with its bitmap */
X
X		if (iscolor)
X		    if (rflag)
X			XPutImage(dpy, window, (c->suit < 2) ? Redgc : rgc, 
X				&(c->image), 0, 0, 0, 0, 
X				card_width, card_height);
X		    else
X			XPutImage(dpy, window, (c->suit < 2) ? Redgc : gc, 
X				&(c->image), 0, 0, 0, 0, 
X				card_width, card_height);
X		else if (rflag)
X			XPutImage(dpy, window, (c->suit < 2) ? gc : rgc, 
X				&(c->image), 0, 0, 0, 0, 
X				card_width, card_height);
X		else
X			XPutImage(dpy, window, gc, &(c->image), 
X				0, 0, 0, 0, card_width, card_height);
X	}
X	return;
}
X
SelectCard(window, pfrom)	/* Service ButtonPressed events */
X	Window          window;
X	struct Card   **pfrom;
X
{
X	if (window == Restart)	{
X		NewGame();
X		}
/* ++	Added by Jon Brinkmann 7/20/90 */
X	else if (window == Flip)	{
X		if (stack[0].count <= 0)	{
X			if (ndeck > 1) XMapWindow(dpy, card_window.self); /*	Remove deck */
X			stack[0].count = ndeck;
X			while (stack[0].count)
X				XUnmapWindow(dpy, deck[order[--stack[0].count][0]].self);
X			stack[0].count = ndeck;
/*	Display top card */
X			XMapRaised(dpy, deck[order[--stack[0].count][0]].self);
X			return;
X		} else	XBell(dpy, 50);
X	}
/* -- */
X	else if (window == Table)
X		*pfrom = (struct Card *) 0;
X	else if (window == Exit)
X		exit(0);
X	else if (window == card_window.self) {  /* Draw next card, if any */
X		if (stack[0].count)     {
X			XMapRaised(dpy, deck[order[--stack[0].count][0]].self);
X			if (stack[0].count == 0)        {
X				/* pull draw stack card */
X				XUnmapWindow(dpy, card_window.self);
X				}
X			}
X		else
X			/* should never happen */
X			XBell(dpy, 50);
X	} else {		/* Select an exposed card */
X		register int    i;
X		struct Card    *from, *to;
X
X		from = *pfrom = (struct Card *) XLookUpAssoc(dpy, Key, window);
X
X		if (from->stack > 7) {	/* Can't move a card from the home
X					 * stacks */
X			XBell(dpy, 50);
X			*pfrom = NULL;
X			return;
X		} else {	/* Aces and Kings are moved automatically
X				 * upon selection; others are moved at
X				 * ButtonReleased event */
X
X			if (from->value == Ace) {/* Move Ace to home area */
X				/* Skip non-vacant stacks */
X				for (i = 8; stack[i].count; i++)
X					;
X
X				/*
X				 * Reset card location fields and stack
X				 * counters
X				 */
X
X				updateOrder(from);	/* Added JB */
X
X				if (from->stack)
X					--stack[from->stack].count;
X				++stack[i].count;
X				from->stack = i;
X				from->x = stack[i].x;
X				from->y = stack[i].y;
X
X				/*
X				 * Move the card window, and signal that
X				 * we've done it
X				 */
X
X				XRaiseWindow(dpy, window);
X				XMoveWindow(dpy, window, from->x, from->y);
X				*pfrom = NULL;
X				return;
X			} else if (from->value == King) {	
X			/* Move King to the first vacant column */
X
X				if (from->stack) {
X					if (stack[from->stack].count == 1)
X						return;
X				}
X				/* Look for a vacancy */
X				for (i = 1; ((i < 8) && stack[i].count); i++)
X					;
X				if (i < 8) {
X
X					/*
X					 * Reset card location fields and
X					 * stack counters
X					 */
X
X					updateOrder(from);	/* Added JB */
X
X					if (from->stack)
X						--stack[from->stack].count;
X					++stack[i].count;
X					from->stack = i;
X					from->x = stack[i].x;
X					from->y = stack[i].y;
X
X					/*
X					 * Move the card window, and any
X					 * cards stacked upon it
X					 */
X
X					XRaiseWindow(dpy, window);
X					XMoveWindow(dpy, window, 
X						from->x, from->y);
X
X					if (from->next != CNULL) {
X						to = from;
X						from = from->next;
X						Restack(&from, &to);
X					}
X					*pfrom = NULL;
X					return;
X				}
X			}
X		else
X			have_card = True;
X		}
X	}
}
X
MoveCard(window, pfrom, pto)
X	Window		window;
X	struct Card   **pfrom, **pto;
X
{
X	struct Card    *from, *to;	/* Locals to make syntax less funky */
X
X	from = *pfrom;
X	to = *pto = (struct Card *) XLookUpAssoc(dpy, Key, window);
X
X	if (to == NULL)
X		return;
X
X	if (to->next == CNULL) {/* Can't move here unless it's top card */
X		if (to->stack > 7) {	/* Try to move card to home area */
X			if ((from->next == CNULL) && (to->suit == from->suit)
X				&& (to->value == (from->value - 1))) {
X
X				updateOrder(from);	/* Added JB */
X
X				XRaiseWindow(dpy, from->self);
X				XMoveWindow(dpy, from->self, to->x, to->y);
X				/* Fix underlying card's forward pointer */
X				if (from->prev != CNULL)
X					(from->prev)->next = CNULL;	
X				from->prev = to;	/* Fix back pointer */
X				from->x = to->x;
X				from->y = to->y;
X				if (from->stack)
X					--stack[from->stack].count;
X				++stack[to->stack].count;
X				from->stack = to->stack;
X
X				return;
X			}
X		} else if (to->stack) {	/* Try to restack the card */
X			if ((to->value == (from->value + 1)) &&
X			    (((to->suit < 2) && (from->suit > 1)) ||
X			     ((to->suit > 1) && (from->suit < 2)))) {
X
X				updateOrder(from);	/* Added JB */
X
X				to->next = from;
X				/* Fix underlying card's forward pointer */
X				if (from->prev != CNULL)
X					(from->prev)->next = CNULL;	
X				from->prev = to;	/* Fix back pointer */
X				Restack(&from, &to);	/* Move this card and
X							 * any stacked on top of
X							 * it */
X				return;
X			}
X		}
X	}
X	XBell(dpy, 50);		/* Illegal move */
X	return;
}
X
Restack(pfrom, pto)		/* Recursive function to restack cards */
X	struct Card   **pfrom, **pto;
X
{
X	struct Card    *from, *to;
X
X	from = *pfrom;
X	to = *pto;
X	from->x = to->x;
X	from->y = to->y + Offset;
X	XMoveWindow(dpy, from->self, from->x, from->y);
X	XRaiseWindow(dpy, from->self);
X	if (from->stack)
X		--stack[from->stack].count;
X	++stack[to->stack].count;
X	from->stack = to->stack;
X	if (from->next != CNULL) {
X		to = from;
X		from = from->next;
X		Restack(&from, &to);
X	}
X	return;
}
X
/* ++	Added by Jon Brinkmann 7/20/90 */
#define	CardIndex(card)	13 * card->suit + card->value - 1
X
#define	Suite(index)	(index) / 13 + 1
#define	Value(index)	(index) % 13 + 1
static char *suite[4] = {"Hearts", "Diamonds", "Clubs", "Spades"};
static char *value[13]= {"Ace", "2", "3", "4", "5", "6", "7", "8", "9", "10",
X	"Jack", "Queen", "King"};
#define	Ssuite(index)	suite[(index) / 13]
#define	Svalue(index)	value[(index) % 13]
X
updateOrder(card)
X	struct Card   *card;
{
X	register int i, j;
X
X	if (card->stack == 0) {
X		j = CardIndex(card);
X		for (i = stack[0].count; i < ndeck; i++) {
X			if (j == order[i][0]) {
/*				printf ("%d %d Card %d %d (%s of %s) taken\n",
X					stack[0].count, ndeck, i, j,
X					Svalue(j), Ssuite(j));	*/
X				for (j = i; j < ndeck; j++)
X					order[j][0] = order[j + 1][0];
X				ndeck--;
/*				for (j = i; j < ndeck; j++)
X					printf ("%2d %2d (%s of %s)\n", j, order[j][0],
X						Svalue(order[j][0]), Ssuite(order[j][0]));	*/
X				return;
X			}
X		}	
X		fprintf (stderr, "Can't find card!\n");
X		exit(1);
X	}
X	return;
}
/* --	*/
NewGame()
{				/* Re-initialize the card deck, shuffle and
X				 * deal */
X	register int    i;
X
X	XUnmapSubwindows(dpy, Table);
X	XMapRaised(dpy, card_window.self);
X	XMapRaised(dpy, Restart);
X	XMapRaised(dpy, Flip);	/* Added JB */
X	XMapRaised(dpy, Exit);
X
X	/* Relocate all cards to the draw stack */
X
X	for (i = 0; i < Draw; i++) {
X		deck[i].x = stack[0].x;
X		deck[i].y = stack[0].y;
X		deck[i].stack = 0;
X		deck[i].prev = deck[i].next = CNULL;
X		XMoveWindow(dpy, deck[i].self, stack[0].x, stack[0].y);
X	}
X
X	stack[0].count = Draw;
X	for (i = 1; i < 12; i++)
X		stack[i].count = 0;
X
X	DealCards();
X
X	return;
}
X
draw_outline(x, y, n)
int	x, y, n;
{
X	if ((x == -1) && (y == -1))
X		return;
X	XDrawRectangle(dpy, RootWindow(dpy, screen), out_gc, x, y, 
X		card_width, card_height + n * 25);
}
SHAR_EOF
chmod 0644 xsol.c ||
echo 'restore of xsol.c failed'
Wc_c="`wc -c < 'xsol.c'`"
test 24628 -eq "$Wc_c" ||
	echo 'xsol.c: original size 24628, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xsol.man ==============
if test -f 'xsol.man' -a X"$1" != X"-c"; then
	echo 'x - skipping xsol.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xsol.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xsol.man' &&
.\" @(#)xsol.man 1.4 89/06/16; Copyright (c) 1988 - Sun Microsystems
.TH xsol 1 "15 Aug 1988"
.SH NAME
xsol \- play solitaire
.SH SYNOPSIS
.B xsol
[
.BI \-display " connection"
]
[
.BI \-nodrag
]
[
.BI [\-,+]r
]
.SH DESCRIPTION
.I xsol
plays a solitaire game simliar to Klondike.  
The playing field is made up of seven slots,
where stacks are built in descending value with alternating suits.
Aces are built on at the top, and ascending order in the same suit.
Kings can be moved to any empty space in the playing field.
The deck is gone through only once, card by card.
SHAR_EOF
true || echo 'restore of xsol.man failed'
fi
echo 'End of  part 3'
echo 'File xsol.man is continued in part 4'
echo 4 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
