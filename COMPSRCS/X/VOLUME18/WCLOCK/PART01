Newsgroups: comp.sources.x
Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: R.Caley@ed.ac.uk (Richard Caley)
Subject: v18i011: Wclock - another X clock, Part01/04
Message-ID: <csx-18i011-wclock@uunet.UU.NET>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Date: Mon, 13 Jul 1992 15:33:48 GMT
Approved: dcmartin@msi.com
Lines: 1658

Submitted-by: R.Caley@ed.ac.uk (Richard Caley)
Posting-number: Volume 18, Issue 11
Archive-name: wclock/part01

From the README:

Yes, yet another X clock.

Wclock's distinguishing feature is that it uses a rather unusual method
to indicate the current time -- hands are so old fashioned don't you
think. It is perhaps more useful as a conversation piece than as a time
piece. I, being strange, actually do use it.

There are three sets of defaults in the application defaults file,
the two non-default sets are named roseClock and eyeClock

#!/bin/sh
# This is a shell archive (produced by shar 3.50)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 07/13/1992 15:29 UTC by dcmartin@fascet
# Source directory /home/fascet/dcmartin/csx/src/tmp
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#    273 -r--r--r-- Imakefile
#   1219 -rw-rw-rw- Makefile.std
#   3285 -r--r--r-- Outline.c
#   1680 -r--r--r-- Outline.h
#   1733 -r--r--r-- OutlineP.h
#   1557 -r--r--r-- README
#   1472 -r--r--r-- Wclock.ad
#  21042 -r--r--r-- Wclock.c
#   4180 -r--r--r-- Wclock.h
#   3038 -r--r--r-- WclockP.h
#  11829 -r--r--r-- eye.mask
#  11829 -r--r--r-- eye.mask1
#  11829 -r--r--r-- eye.xbm
#     51 -r--r--r-- patchlevel.h
#  41150 -r--r--r-- rose.mask
#  41150 -r--r--r-- rose.xbm
#   5723 -r--r--r-- wclock.c
#   5949 -r--r--r-- wclock.man
#   1615 -r--r--r-- wclock.mask
#   1590 -r--r--r-- wclock.xbm
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= Imakefile ==============
if test -f 'Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Imakefile' &&
X  SYS_LIBRARIES = -lm
X        DEPLIBS = XawClientDepLibs
LOCAL_LIBRARIES = XawClientLibs
X        DEFINES = ExtensionDefines
X    CDEBUGFLAGS = -O
X
SRCS=  wclock.c Wclock.c Outline.c
OBJS=  wclock.o Wclock.o Outline.o
X
ComplexProgramTarget(wclock)
InstallAppDefaults(Wclock)
SHAR_EOF
chmod 0444 Imakefile ||
echo 'restore of Imakefile failed'
Wc_c="`wc -c < 'Imakefile'`"
test 273 -eq "$Wc_c" ||
	echo 'Imakefile: original size 273, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile.std ==============
if test -f 'Makefile.std' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile.std (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile.std (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile.std' &&
X
X ######################################################################
X #                                                                    #
X # Boring Makefile for wclock.                                        #
X #                                                                    #
X ######################################################################
X
WCLOCK=wclock
X
# places to put things. 
X
BINDIR=/usr/local/bin/X11
MANDIR=/usr/man
MANSEC=l
X
WCLOCK_SRC=wclock.c Wclock.c Outline.c
WCLOCK_OBJ=$(WCLOCK_SRC:.c=.o)
X
LIBS= -lXaw -lXmu -lXt -lXext -lX11 -lm
X
# places to look for X things
X
INCLUDE_DIRS= -I/usr/local/include
LIB_DIRS=
X
DEFINES=-DSHAPE
CDEBUGFLAGS=-O
X
CFLAGS= $(CDEBUGFLAGS) $(DEFINES) $(INCLUDE_DIRS) $(LIB_DIRS)
X
wclock: $(WCLOCK_OBJ)
X	$(CC) $(CFLAGS) -o wclock $(WCLOCK_OBJ) $(LIBS)
X
Outline.o : Outline.c OutlineP.h Outline.h
Wclock.o : Wclock.c WclockP.h Wclock.h Outline.h /usr/include/math.h
wclock.o : wclock.c Wclock.h Outline.h patchlevel.h wclock.xbm wclock.mask
X
install: wclock wclock.man
X	install -s -m755 wclock $(BINDIR)
X	install -m644 wclock.man $(MANDIR)/man$(MANSEC)/wclock.$(MANSEC)
X
clean:
X	rm -f $(WCLOCK_OBJ) $(WCLOCK)
X
lint:
X	$(LINT) $(DEFINES) $(INCLUDES) $(WCLOCK_SRC)
SHAR_EOF
chmod 0666 Makefile.std ||
echo 'restore of Makefile.std failed'
Wc_c="`wc -c < 'Makefile.std'`"
test 1219 -eq "$Wc_c" ||
	echo 'Makefile.std: original size 1219, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Outline.c ==============
if test -f 'Outline.c' -a X"$1" != X"-c"; then
	echo 'x - skipping Outline.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Outline.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Outline.c' &&
X
/*
X * This file hacked from Weekday.c in the xdiary distribution by RJC.
X */
X
/*
X * Original author: Jason Baietto, jason@ssd.csd.harris.com
X *
X * Permission to use, copy, modify, and distribute, this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the copyright holder be used in
X * advertising or publicity pertaining to distribution of the software with
X * specific, written prior permission, and that no fee is charged for further
X * distribution of this software, or any modifications thereof.  The copyright
X * holder makes no representations about the suitability of this software for
X * any purpose.  It is provided "as is" without express or implied warranty.
X *
X * THE COPYRIGHT HOLDER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, AND IN NO
X * EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ITS USE,
X * LOSS OF DATA, PROFITS, QPA OR GPA, WHETHER IN AN ACTION OF CONTRACT,
X * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH
X * THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
#include <stdio.h>
#include <ctype.h>
#include <X11/StringDefs.h>
#include <X11/IntrinsicP.h>
#include "OutlineP.h"
X
#define MAX_STRING_LEN 256
X
/*==========================================================================*/
/*                                 Quarks:                                  */
/*==========================================================================*/
XXrmQuark XtQNoOutline;
XXrmQuark XtQBitmap;
XXrmQuark XtQCircle;
X
X
/*==========================================================================*/
/*                         Outline Type Converter:                          */
/*==========================================================================*/
static void downcase_string(source, dest)
char * source;
char * dest;
{
X   for (; *source != 0; source++, dest++) {
X      if ( isupper(*source) )
X	  *dest = tolower(*source);
X      else
X	  *dest = *source;
X   }
X   *dest = 0;
}
X
X
X
/*ARGSUSED*/
void OutlineConverter(args, num_args, fromVal, toVal)
XXrmValuePtr args;
Cardinal    *num_args;
XXrmValuePtr fromVal;
XXrmValuePtr toVal;
{
X   static int initialized = FALSE;
X   static XtOutline Outline;
X   XrmQuark q;
X   char lowerName[MAX_STRING_LEN];
X
X   if (!initialized) {
X      /* Create quarks the first time we're called. */
X      XtQBitmap     = XrmStringToQuark(XtNbitmap);
X      XtQCircle   = XrmStringToQuark(XtNcircle);
X      XtQNoOutline   = XrmStringToQuark(XtNnoOutline);
X   }
X
X   downcase_string((char*)fromVal->addr, lowerName);
X   q = XrmStringToQuark(lowerName);
X
X   toVal->size = sizeof(XtOutline);
X   toVal->addr = (XtPointer) &Outline;
X
X   if (q == XtQBitmap) {
X      Outline = Bitmap;
X   } else if (q == XtQCircle) {
X      Outline = Circle;
X   } else if (q == XtQNoOutline) {
X      Outline = NoOutline;
X   } else {
X      XtStringConversionWarning(fromVal->addr, "XtROutline");
X      toVal->addr = NULL;
X      toVal->size = 0;
X   }
}
X
X
SHAR_EOF
chmod 0444 Outline.c ||
echo 'restore of Outline.c failed'
Wc_c="`wc -c < 'Outline.c'`"
test 3285 -eq "$Wc_c" ||
	echo 'Outline.c: original size 3285, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Outline.h ==============
if test -f 'Outline.h' -a X"$1" != X"-c"; then
	echo 'x - skipping Outline.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Outline.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Outline.h' &&
/*
X * This file hacked from Weekday.c in the xdiary distribution by RJC.
X */
X
/*
X * Original author: Jason Baietto, jason@ssd.csd.harris.com
X * xdiary Copyright 1990 Harris Computer Systems Division
X *
X * Permission to use, copy, modify, and distribute, this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the copyright holder be used in
X * advertising or publicity pertaining to distribution of the software with
X * specific, written prior permission, and that no fee is charged for further
X * distribution of this software, or any modifications thereof.  The copyright
X * holder makes no representations about the suitability of this software for
X * any purpose.  It is provided "as is" without express or implied warranty.
X *
X * THE COPYRIGHT HOLDER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, AND IN NO
X * EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ITS USE,
X * LOSS OF DATA, PROFITS, QPA OR GPA, WHETHER IN AN ACTION OF CONTRACT,
X * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH
X * THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
#ifndef _OutlineConverter_h
#define _OutlineConverter_h
X
extern void OutlineConverter();
X
#define XtROutline "Outline"
X
typedef enum {
X    NoOutline,
X    Bitmap,
X    Circle,
} XtOutline;
X
#endif /* _OutlineConverter_h */
SHAR_EOF
chmod 0444 Outline.h ||
echo 'restore of Outline.h failed'
Wc_c="`wc -c < 'Outline.h'`"
test 1680 -eq "$Wc_c" ||
	echo 'Outline.h: original size 1680, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= OutlineP.h ==============
if test -f 'OutlineP.h' -a X"$1" != X"-c"; then
	echo 'x - skipping OutlineP.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting OutlineP.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'OutlineP.h' &&
/*
X * This file hacked from Weekday.c in the xdiary distribution by RJC.
X */
X
/*
X * Original author: Jason Baietto, jason@ssd.csd.harris.com
X * xdiary Copyright 1990 Harris Corporation
X *
X * Permission to use, copy, modify, and distribute, this software and its
X * documentation for any purpose is hereby granted without fee, provided that
X * the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of the copyright holder be used in
X * advertising or publicity pertaining to distribution of the software with
X * specific, written prior permission, and that no fee is charged for further
X * distribution of this software, or any modifications thereof.  The copyright
X * holder makes no representations about the suitability of this software for
X * any purpose.  It is provided "as is" without express or implied warranty.
X *
X * THE COPYRIGHT HOLDER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, AND IN NO
X * EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM ITS USE,
X * LOSS OF DATA, PROFITS, QPA OR GPA, WHETHER IN AN ACTION OF CONTRACT,
X * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH
X * THE USE OR PERFORMANCE OF THIS SOFTWARE.
X */
X
#ifndef _OutlineConverterP_h
#define _OutlineConverterP_h
X
#include "Outline.h"
X
#define XtNbitmap    "bitmap"
#define XtNcircle    "circle"
#define XtNnoOutline "none"
X
extern XrmQuark XtQBitmap;
extern XrmQuark XtQCircle;
extern XrmQuark XtQNoOutline;
X
#endif /* _OutlineConverter_h */
SHAR_EOF
chmod 0444 OutlineP.h ||
echo 'restore of OutlineP.h failed'
Wc_c="`wc -c < 'OutlineP.h'`"
test 1733 -eq "$Wc_c" ||
	echo 'OutlineP.h: original size 1733, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
X
Yes, yet another X clock.
X
Wclock's distinguishing feature is that it uses a rather unusual method
to indicate the current time -- hands are so old fashioned don't you
think. It is perhaps more useful as a conversation piece than as a time
piece. I, being strange, actually do use it.
X
There are three sets of defaults in the application defaults file,
the two non-default sets are named roseClock and eyeClock
X
It should work as is.  Just make it and install the defaults (or stick
them in your Xdefaults). The more interesting behaviour depends on the
MIT Shape extension, so if you haven't got that you will be stuck with
a boring clock. It is a good idea to make sure your window manager
doesn't decorate the clock as this (a) spoils the effect and (b)
causes the WM (well, tvtwm at least) to get very frustrated
redecorating when the clock reshapes itself.
X
Start it as
X	wclock -debug 60 -update 5
X
to get it to run fast so you can get the idea of what it does. Then
try
X
X	wclock -name roseClock -debug 60 -update 5
X
and
X
X	wclock -name eyeClock -debug 60 -update 5
X
to see what else is possible.
X
Having read and taken to heart Henry Spencer's advice on not reinventing
wheels, I produced wclock by cannibalising bits of xclock, xcal and
xbiff. Kudos to those who did the hard bits (see manual page).
X
Many thanks to whoever originally scanned the images, unfortunately I
have had them for a while and don't know who originally did them.  The
eye belongs to Kate Bush, in case you're interested. 
X
X	- Richard Caley
X
--
R.Caley@ed.ac.uk			_O_
X					 |<
SHAR_EOF
chmod 0444 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 1557 -eq "$Wc_c" ||
	echo 'README: original size 1557, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Wclock.ad ==============
if test -f 'Wclock.ad' -a X"$1" != X"-c"; then
	echo 'x - skipping Wclock.ad (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Wclock.ad (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Wclock.ad' &&
X
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!                                                                    !
! Application defaults for wclock. There are three sets of defaults  !
! here so that three types of clock can be selected by naming the    !
! instance of wclock.                                                !
!                                                                    !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
X
X
! First a clock which displays as a picture of a rose.
X
roseClock*input: false
roseClock*debugInc: 0
roseClock*update: 60
X
roseClock*externalOutline: Bitmap
roseClock*internalOutline: None
X
roseClock*externalBitmap: rose.mask
roseClock*backgroundBitmap: rose.xbm
X
roseClock*forceShape: true
roseClock*plotSegment: false
roseClock*shapeSegment: true
X
roseClock*sliceWidth: 0
roseClock*sliceSpace: 60
X
! Similarly an eye.
X
eyeClock*input: false
eyeClock*debugInc: 0
eyeClock*update: 60
X
eyeClock*externalOutline: Bitmap
eyeClock*internalOutline: None
X
eyeClock*externalBitmap: eye.mask
eyeClock*backgroundBitmap: eye.xbm
X
eyeClock*forceShape: true
eyeClock*plotSegment: false
eyeClock*shapeSegment: true
X
eyeClock*sliceWidth: 0
eyeClock*sliceSpace: 60
X
! finally the default stripy wheel.
X
*input: false
*debugInc: 0
*update: 60
X
*externalOutline: Circle
*internalOutline: Circle
X
*forceShape: true
*plotSegment: false
*shapeSegment: true
X
*sliceWidth: 30
*sliceSpace: 60
X
X
SHAR_EOF
chmod 0444 Wclock.ad ||
echo 'restore of Wclock.ad failed'
Wc_c="`wc -c < 'Wclock.ad'`"
test 1472 -eq "$Wc_c" ||
	echo 'Wclock.ad: original size 1472, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Wclock.c ==============
if test -f 'Wclock.c' -a X"$1" != X"-c"; then
	echo 'x - skipping Wclock.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Wclock.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Wclock.c' &&
#ifndef lint
static char Xrcsid[] = "$XConsortium: Wclock.c,v 1.50 89/12/06 15:23:24 kit Exp $";
#endif /* lint */
X
/*
X * Hacked from Clock.c by RJC
X *
X * the code to shape the parent shell was pinched from xbiff.
X */
X
X
/***********************************************************
Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
X
X                        All Rights Reserved
X
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  
X
DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.
X
******************************************************************/
X
#include <X11/Xlib.h>
#include <X11/StringDefs.h>
#include <X11/IntrinsicP.h>
#include <X11/Xaw/XawInit.h>
#include "WclockP.h"
#include "Outline.h"
#include "math.h"
#ifdef SHAPE
#include <X11/extensions/shape.h>
#endif
X
extern long time();
static void Wclock_tic(), draw_segment();
X	
/* Private Definitions */
X
#define PI			3.14159265358979
#define TWOPI			(2. * PI)
#define EPSILON 		(0.00001)
#define CONVERT_A(A)		((3.0 * PI / 2.0) + (A))
X
#define WCLOCK_SIZE_DEFAULT (150)
X
#define max(a, b) ((a) > (b) ? (a) : (b))
#define min(a, b) ((a) < (b) ? (a) : (b))
#define abs(a) ((a) < 0 ? -(a) : (a))
X
X
/* Initialization of defaults */
X
#define offset(field) XtOffset(WclockWidget,Wclock.field)
#define goffset(field) XtOffset(Widget,core.field)
X
static Pixmap nopix = None;
X
static XtResource resources[] = {
X    {XtNwidth, XtCWidth, XtRDimension, sizeof(Dimension),
X	goffset(width), XtRImmediate, (caddr_t) 0},
X    {XtNheight, XtCHeight, XtRDimension, sizeof(Dimension),
X	goffset(height), XtRImmediate, (caddr_t) 0},
X    {XtNbackground, XtCBackground, XtRPixel, sizeof(Pixel),
X	goffset(background_pixel), XtRString, "XtdefaultBackground"},
X    {XtNupdate, XtCInterval, XtRInt, sizeof(int), 
X        offset(update), XtRImmediate, (caddr_t) 60 },
X    {XtNdebugInc, XtCInterval, XtRInt, sizeof(int), 
X        offset(debugInc), XtRImmediate, (caddr_t) 0 },
X    {XtNforeground, XtCForeground, XtRPixel, sizeof(Pixel),
X        offset(fgpixel), XtRString, "XtdefaultForeground"},
X    {XtNbackingStore, XtCBackingStore, XtRBackingStore, sizeof (int),
X    	offset (backing_store), XtRString, "default"},
X    {XtNinternalOutline, XtCOutline, XtROutline, sizeof(int),
X	 offset (internalOutline), XtRString, "None"},
X    {XtNinternalPercent, XtCMargin, XtRInt, sizeof(int),
X	 offset (internalPercent), XtRImmediate, (caddr_t) 80 },
X    {XtNinternalBitmap, XtCMask, XtRBitmap, sizeof(Pixmap),
X	 offset (internalBitmap), XtRBitmap, (caddr_t) &nopix },
X    {XtNexternalOutline, XtCOutline, XtROutline, sizeof(int),
X	 offset (externalOutline), XtRString, "None"},
X    {XtNexternalPercent, XtCMargin, XtRInt, sizeof(int),
X	 offset (externalPercent), XtRImmediate, (caddr_t) 100 },
X    {XtNexternalBitmap, XtCMask, XtRBitmap, sizeof(Pixmap),
X	 offset (externalBitmap), XtRBitmap, (caddr_t) &nopix },
X    {XtNforceShape, XtCForceShape, XtRBoolean, sizeof(Boolean),
X        offset (forceShape), XtRImmediate, (caddr_t)False },
X    {XtNplotSegment, XtCPlotSegment, XtRBoolean, sizeof(Boolean),
X        offset (plotSegment), XtRImmediate, (caddr_t)True },
X    {XtNshapeSegment, XtCShapeSegment, XtRBoolean, sizeof(Boolean),
X        offset (shapeSegment), XtRImmediate, (caddr_t)False },
X    {XtNbackgroundBitmap, XtCBitmap, XtRBitmap, sizeof(Pixmap),
X	 offset (backgroundBitmap), XtRBitmap, (caddr_t) &nopix },
X    {XtNsliceOffset, XtCSlice, XtRInt, sizeof(int),
X	 offset (sliceOffset), XtRImmediate, (caddr_t) 0 },
X    {XtNsliceSpace, XtCSlice, XtRInt, sizeof(int),
X	 offset (sliceSpace), XtRImmediate, (caddr_t) 300 },
X    {XtNsliceWidth, XtCSlice, XtRInt, sizeof(int),
X	 offset (sliceWidth), XtRImmediate, (caddr_t) 0 },
};
X
#undef offset
#undef goffset
X
static void ClassInitialize();
static void Initialize(), Realize(), Destroy(), Resize(), Redisplay();
static Boolean SetValues();
X
WclockClassRec wclockClassRec = {
X    { /* core fields */
X    /* superclass		*/	&widgetClassRec,
X    /* class_name		*/	"Wclock",
X    /* widget_size		*/	sizeof(WclockRec),
X    /* class_initialize		*/	ClassInitialize,
X    /* class_part_initialize	*/	NULL,
X    /* class_inited		*/	FALSE,
X    /* initialize		*/	Initialize,
X    /* initialize_hook		*/	NULL,
X    /* realize			*/	Realize,
X    /* actions			*/	NULL,
X    /* num_actions		*/	0,
X    /* resources		*/	resources,
X    /* resource_count		*/	XtNumber(resources),
X    /* xrm_class		*/	NULL,
X    /* compress_motion		*/	TRUE,
X    /* compress_exposure	*/	TRUE,
X    /* compress_enterleave	*/	TRUE,
X    /* visible_interest		*/	FALSE,
X    /* destroy			*/	Destroy,
X    /* resize			*/	Resize,
X    /* expose			*/	Redisplay,
X    /* set_values		*/	SetValues,
X    /* set_values_hook		*/	NULL,
X    /* set_values_almost	*/	XtInheritSetValuesAlmost,
X    /* get_values_hook		*/	NULL,
X    /* accept_focus		*/	NULL,
X    /* version			*/	XtVersion,
X    /* callback_private		*/	NULL,
X    /* tm_table			*/	NULL,
X    /* query_geometry           */	XtInheritQueryGeometry,
X    /* display_accelerator      */	XtInheritDisplayAccelerator,
X    /* extension                */	NULL
X    }
};
X
WidgetClass wclockWidgetClass = (WidgetClass) &wclockClassRec;
X
/****************************************************************
X *
X * Private Procedures
X *
X ****************************************************************/
X
static void ClassInitialize()
{
X    XawInitializeWidgetSet();
X    XtAddConverter( XtRString, XtRBackingStore, XmuCvtStringToBackingStore,
X		    NULL, 0 );
X    XtAddConverter( XtRString, XtROutline, OutlineConverter,
X		    NULL, 0 );
}
X
/* ARGSUSED */
static void Initialize (request, new)
X    Widget request, new;
{
X    WclockWidget w = (WclockWidget)new;
X    Display *dpy = XtDisplay(new);
X    XtGCMask		valuemask;
X    XGCValues	myXGCV;
X    int min_height, min_width;
X
X    valuemask = GCForeground | GCBackground | GCLineWidth |GCFunction;
X
X
X    if ( w->Wclock.backgroundBitmap != None )
X    	{
X	unsigned int width, height, bw, d;
X	Window root;
X	int x,y;
X        XGetGeometry(dpy, w->Wclock.backgroundBitmap,
X                     &root, &x, &y, &width, &height, &bw, &d);
X
X	min_width = width;
X	min_height = height;
X	}
X    else
X	{
X	min_width = min_height = WCLOCK_SIZE_DEFAULT;
X	}
X
X    if (w->core.width == 0)
X	w->core.width = min_width;
X    if (w->core.height == 0)
X	w->core.height = min_height;
X
X    myXGCV.foreground = w->Wclock.fgpixel;
X    myXGCV.background = w->core.background_pixel;
X    myXGCV.function   = GXcopy;
X    myXGCV.line_width = 0;
X    
X    w->Wclock.myGC = XtGetGC((Widget)w, valuemask, &myXGCV);
X
X    valuemask = GCForeground | GCLineWidth ;
X    myXGCV.foreground = w->core.background_pixel;
X    w->Wclock.EraseGC = XtGetGC((Widget)w, valuemask, &myXGCV);
X
X    w->Wclock.setGC = NULL;
X
X    w->Wclock.unsetGC = NULL;
X
X    w->Wclock.invertGC = NULL;
X
X    if (w->Wclock.update <= 0)
X	w->Wclock.update = 60;	/* make invalid update's use a default */
X    w->Wclock.interval_id = 0;
X
X
}
X
static void Realize (gw, valueMask, attrs)
X     Widget gw;
X     XtValueMask *valueMask;
X     XSetWindowAttributes *attrs;
{
X     WclockWidget	w = (WclockWidget) gw;
X
X     switch (w->Wclock.backing_store) {
X     case Always:
X     case NotUseful:
X     case WhenMapped:
X     	*valueMask |=CWBackingStore;
X	attrs->backing_store = w->Wclock.backing_store;
X	break;
X     }
X     XtCreateWindow( gw, InputOutput, (Visual *)CopyFromParent,
X		     *valueMask, attrs);
X
X
X     Resize(gw);
}
X
static void Destroy (gw)
X     Widget gw;
{
X     Display *dpy = XtDisplay(gw);
X     WclockWidget w = (WclockWidget) gw;
X
X     if (w->Wclock.interval_id) XtRemoveTimeOut (w->Wclock.interval_id);
X
X     XtDestroyGC (w->Wclock.myGC);
X     XtDestroyGC (w->Wclock.EraseGC);
X     if (w->Wclock.setGC != NULL)
X	 XtDestroyGC (w->Wclock.setGC);
X     if (w->Wclock.unsetGC != NULL)
X	 XtDestroyGC (w->Wclock.unsetGC);
X     if (w->Wclock.invertGC != NULL)
X	 XtDestroyGC (w->Wclock.invertGC);
X     XFreePixmap (dpy, w->Wclock.segmentPM);
X     XFreePixmap (dpy, w->Wclock.outlinePM);
}
X
X
static void
SetupBackground(w)
WclockWidget w;
X
{
Display *dpy = XtDisplay(w);
Window win = XtWindow(w);
Pixmap pm;
unsigned int width, height, bw, d;
Window root;
int x,y, secs;
X
if ( w->Wclock.backgroundBitmap != None 
X     || w->Wclock.sliceWidth != 0)
X    {
X    pm=XCreatePixmap(dpy, win, 
X		     w->core.width,
X		     w->core.height,
X		     w->core.depth);
X
X    XFillRectangle(dpy, pm, w->Wclock.EraseGC, 
X		   0,0, w->core.width, w->core.height);
X
X    if ( w->Wclock.backgroundBitmap != None )
X	{
X	XGetGeometry(dpy, w->Wclock.backgroundBitmap, 
X		     &root, &x, &y, &width, &height, &bw, &d);
X	
X	XCopyPlane(dpy, w->Wclock.backgroundBitmap, pm, w->Wclock.myGC,
X		   0, 0, width, height,
X		   (w->core.width-width)/2,
X		   (w->core.height - height)/2,
X		   1);
X	}
X
X    if ( w->Wclock.sliceWidth != 0 )
X	{
X	for (secs=w->Wclock.sliceOffset; secs < 3600 ; secs +=w->Wclock.sliceSpace)
X	    draw_segment(dpy, pm, w->Wclock.myGC,
X			 w->Wclock.centerX,
X			 w->Wclock.centerY,
X			 CONVERT_A(secs * TWOPI/3600),
X			 CONVERT_A((secs+w->Wclock.sliceWidth) * TWOPI/3600)
X			 );
X	}
X			 
X
X    XSetWindowBackgroundPixmap(dpy, win, pm);
X    XFreePixmap(dpy, pm);
X    XClearWindow(dpy, win);	/* force rewrite */
X    }
X
X     
}
X
static void
CreateOutline(w)
WclockWidget w;
X
{
Display *dpy = XtDisplay(w);
Pixmap pm = w->Wclock.outlinePM;
int hb, vb;
unsigned int width, height, bw, d;
Window root;
int x,y;
X
if (w->Wclock.setGC == NULL)
X    {
X    XGCValues myXGCV;
X    XtGCMask valuemask;
X
X    valuemask = GCForeground | GCBackground |GCFunction;
X    myXGCV.foreground = 1;
X    myXGCV.background = 0;
X    myXGCV.function   = GXcopy;
X    w->Wclock.setGC = XCreateGC(dpy, pm, valuemask, &myXGCV);
X    
X    myXGCV.foreground = 0;
X    myXGCV.background = 1;
X    w->Wclock.unsetGC = XCreateGC(dpy, pm, valuemask, &myXGCV);
X    
X    
X    myXGCV.function   = GXcopyInverted;
X    w->Wclock.invertGC = XCreateGC(dpy, pm, valuemask, &myXGCV);
X    }
X
switch(w->Wclock.externalOutline)
X    {
X case NoOutline:
X
X    XFillRectangle(dpy, pm, w->Wclock.setGC, 
X		   0,0, w->core.width, w->core.height);
X    break;
X
X case Circle:
X
X    hb = (float)w->core.width * (100 - w->Wclock.externalPercent) / 200;
X    vb = (float)w->core.height * (100 - w->Wclock.externalPercent) / 200;
X
X    XFillRectangle(dpy, pm, w->Wclock.unsetGC, 
X		   0,0, w->core.width, w->core.height);
X    XFillArc(dpy, pm, w->Wclock.setGC,
X	     hb, vb,
X	     w->core.width-2*hb, w->core.height-2*vb,
X	     0, 64*360);		  
X    break;
X
X case Bitmap:
X    XFillRectangle(dpy, pm, w->Wclock.unsetGC, 
X		   0,0, w->core.width, w->core.height);
X
X    if ( w->Wclock.externalBitmap == None )
X	{
X	printf("No bitmap give for external outline\n");
X	break;
X	}
X
X    XGetGeometry(dpy, w->Wclock.externalBitmap, 
X		 &root, &x, &y, &width, &height, &bw, &d);
X
X    x=(w->core.width-width)/2;
X    y=(w->core.height-height)/2;
X
X    XCopyArea(dpy, w->Wclock.externalBitmap, pm, w->Wclock.setGC,
X	       0, 0, width, height, 
X	       x,y);
X    break;
X    }
X
switch(w->Wclock.internalOutline)
X    {
X case NoOutline:
X    break;
X
X case Circle:
X
X    hb = (float)w->core.width * (100 - w->Wclock.internalPercent) / 200;
X    vb = (float)w->core.height * (100 - w->Wclock.internalPercent) / 200;
X
X    XFillArc(dpy, pm, w->Wclock.unsetGC,
X	     hb, vb,
X	     w->core.width-2*hb, w->core.height-2*vb,
X	     0, 64*360);		  
X    break;
X
X case Bitmap:
X    if ( w->Wclock.internalBitmap == None )
X	{
X	printf("No bitmap give for internal outline\n");
X	break;
X	}
X
X    XGetGeometry(dpy, w->Wclock.internalBitmap, 
X		 &root, &x, &y, &width, &height, &bw, &d);
X
X    x=(w->core.width-width)/2;
X    y=(w->core.height-height)/2;
X
X    XCopyArea(dpy, pm, w->Wclock.internalBitmap, w->Wclock.invertGC,
X	       0, 0, width, height, 
X	       x,y);
X    break;
X    }
X
}
X
X
static void
ImposeShape(w, outline, additional)
WclockWidget w;
Pixmap outline, additional;
X
{
Widget parent;
Window win=XtWindow(w);
int x=0, y=0;
X
#ifdef SHAPE
X    XShapeCombineMask (XtDisplay(w), win,
X		       ShapeBounding, x, y, 
X		       outline,
X		       ShapeSet);
X
X    if (additional != NULL)
X	XShapeCombineMask (XtDisplay(w), win,
X			   ShapeBounding, x, y, 
X			   additional,
X			   ShapeIntersect);
X
X    if ( w->Wclock.forceShape )
X	{
X	for (parent = (Widget) w; XtParent(parent);
X	     parent = XtParent(parent)) 
X	    {
X	    x += parent->core.x + parent->core.border_width;
X	    y += parent->core.y + parent->core.border_width;
X	    }
X
X	XShapeCombineMask (XtDisplay(parent), XtWindow(parent),
X			   ShapeBounding, x, y, 
X			   outline,
X			   ShapeSet);
X
X	if (additional != NULL)
X	    XShapeCombineMask (XtDisplay(parent), XtWindow(parent),
X			       ShapeBounding, x, y, 
X			       additional,
X			       ShapeIntersect);
X	}
#endif
}
X
static void Resize (gw) 
X    Widget gw;
{
X    WclockWidget w = (WclockWidget) gw;
X    Display *dpy = XtDisplay(w);
X    Window win = XtWindow(w);
X
X    /* don't do this computation if window hasn't been realized yet. */
X    if (XtIsRealized(gw)) {
X	/* need signed value since Dimension is unsigned */
X
X        w->Wclock.centerX = w->core.width / 2;
X        w->Wclock.centerY = w->core.height / 2;
X
X	if (w->Wclock.segmentPM != NULL)
X	    XFreePixmap (dpy, w->Wclock.segmentPM);
X
X	if (w->Wclock.outlinePM != NULL )
X	    XFreePixmap (dpy, w->Wclock.outlinePM);
X
X	w->Wclock.segmentPM = XCreatePixmap(dpy, win,
X					    w->core.width,
X					    w->core.height,
X					    1);
X
X	w->Wclock.outlinePM = XCreatePixmap(dpy, win,
X					  w->core.width,
X					  w->core.height,
X					  1);
X
X	CreateOutline(w);
X	ImposeShape(w, w->Wclock.outlinePM, None);
X	SetupBackground(w);
X	w->Wclock.otm.tm_min = -1; /* force refreash */
X    }
}
X
/* ARGSUSED */
static void Redisplay (gw, event, region)
X    Widget gw;
X    XEvent *event;		/* unused */
X    Region region;		/* unused */
{
X    WclockWidget w = (WclockWidget) gw;
X
X    Wclock_tic((caddr_t)w, (XtIntervalId *)0);
}
X
/* ARGSUSED */
static void Wclock_tic(client_data, id)
X        caddr_t client_data;
X        XtIntervalId *id;
{
X        WclockWidget w = (WclockWidget)client_data;    
X	struct tm *localtime();
X	struct tm tm; 
X	long	time_value;
X        register Display *dpy = XtDisplay(w);
X        register Window win = XtWindow(w);
X
X
X	if (id || !w->Wclock.interval_id)
X	    w->Wclock.interval_id =
X		XtAppAddTimeOut( XtWidgetToApplicationContext( (Widget) w),
X				w->Wclock.update*1000, 
X				Wclock_tic, (caddr_t)w );
X
X	if ( w->Wclock.debugInc == 0 )
X	    {
X	    (void) time(&time_value);
X	    tm = *localtime(&time_value);
X	    }
X	else
X	    {
X	    tm.tm_sec = w->Wclock.otm.tm_sec;
X	    tm.tm_min = w->Wclock.otm.tm_min;
X	    tm.tm_hour = w->Wclock.otm.tm_hour;
X
X	    tm.tm_sec += w->Wclock.debugInc;
X
X	    while (tm.tm_sec >= 60)
X		{
X		tm.tm_sec -=60;
X		tm.tm_min++;
X		}
X
X	     while (tm.tm_min >= 60)
X		{
X		tm.tm_min -=60;
X		tm.tm_hour++;
X		}
X	    
X	    while ( tm.tm_hour > 24 )
X		tm.tm_hour -= 24;
X	    }
X
X	/*
X	 * 12 hour Wclock.
X	 */
X	if(tm.tm_hour > 12)
X	    tm.tm_hour -= 12;
X
X	
X	if (tm.tm_min != w->Wclock.otm.tm_min ||
X	    tm.tm_hour != w->Wclock.otm.tm_hour) 
X	    {
X	    int twelvemins = tm.tm_min / 12; /* how many fifths of an hour */
X
X	    /* draw the segment from the position of the hour hand
X	     * to that of the minute hand plus half a second.
X	     */
X
X	    if (w->Wclock.shapeSegment)
X		{
X		XFillRectangle(dpy, w->Wclock.segmentPM, w->Wclock.unsetGC, 
X			       0,0, w->core.width, w->core.height);
X
X		draw_segment(dpy, w->Wclock.segmentPM, w->Wclock.setGC,
X			     w->Wclock.centerX,
X			     w->Wclock.centerY,
X			     CONVERT_A(tm.tm_hour * TWOPI/12 + twelvemins * TWOPI/60),
X			     CONVERT_A(tm.tm_min * TWOPI/60 + PI/60));
X		}
X
X	    if ( w->Wclock.plotSegment )
X		{
X		XClearWindow(dpy, win);
X		draw_segment(dpy, win, w->Wclock.setGC,
X			     w->Wclock.centerX,
X			     w->Wclock.centerY,
X			     CONVERT_A(tm.tm_hour * TWOPI/12 + twelvemins * TWOPI/60),
X			     CONVERT_A(tm.tm_min * TWOPI/60 + PI/60));
X		}
X
X	    if ( w->Wclock.shapeSegment )
X		ImposeShape(w, w->Wclock.segmentPM, w->Wclock.outlinePM);
X
X
X	    w->Wclock.otm.tm_sec = tm.tm_sec;
X	    w->Wclock.otm.tm_min = tm.tm_min;
X	    w->Wclock.otm.tm_hour = tm.tm_hour;
X	    }
}
X
/*
X * draw a segment in the window starting at startrad radians and
X * ending at endrad radians.
X */
X
static void
project_onto_unit_square(th, xp, yp)
X
double th;
double *xp, *yp;
X
{
if ( th < PI/4 )
X    {
X    *xp=1;
X    *yp=tan(th);
X    }
else if ( th < 3*PI/4)
X    {
X    *xp=1/tan(th);
X    *yp=1;
X    }
else if ( th < 5*PI/4)
X    {
X    *xp= -1;
X    *yp= -tan(th);
X    }
else if ( th < 7 * PI/4)
X    {
X    *xp=-1/tan(th);
X    *yp= -1;
X    }
else
X    {
X    *xp=1;
X    *yp=tan(th);
X    }
X
}
X
static void
draw_segment(dsp, dr, gc, centreX, centreY, startrad, endrad)
X
Display *dsp;
Drawable dr;
GC gc;
int centreX, centreY;
double startrad, endrad;
X
{
XXPoint segment[10];
static struct 
X    {
X    double rad;
X    short xoff;
X    short yoff;
X    } vertices[] =
X    {
X    { PI/4, 	 1, -1},
X    { 3*PI/4,   -1, -1},
X    { 5*PI/4, 	-1,  1},
X    { 7*PI/4, 	 1,  1},
X    { 2*PI, 	 1,  0},
X    };
#define NUM_VERT (sizeof(vertices)/sizeof(*vertices))
int vertex;
int p=0;
unsigned int width, height, bw, d;
Window root;
int x,y;
double px, py;
X
while ( startrad >= TWOPI )
X    startrad -= TWOPI;
X
while ( endrad >= TWOPI )
X    endrad -= TWOPI;
X
XXGetGeometry(dsp, dr, &root, &x, &y, &width, &height, &bw, &d);
X
segment[p].x=centreX;
segment[p++].y=centreY;
X
project_onto_unit_square(startrad, &px, &py);
X
segment[p].x= centreX + px * centreX;
segment[p++].y= centreY + py * centreY;
X
for (vertex=0; vertex <NUM_VERT ; vertex++)
X    if ( startrad < vertices[vertex].rad + EPSILON)
X	break;
X
if ( endrad >= startrad )
X    {
X    for ( ; vertex < NUM_VERT ; vertex++)
X	if ( endrad + EPSILON < vertices[vertex].rad )
X	    break;
X	else
X	    {
X	    segment[p].x = centreX + vertices[vertex].xoff * centreX;
X	    segment[p++].y = centreY - vertices[vertex].yoff * centreY;
X	    }
X    }
else
X    {
X    for ( ; vertex < NUM_VERT ; vertex++)
X	    {
X	    segment[p].x = centreX + vertices[vertex].xoff * centreX;
X	    segment[p++].y = centreY - vertices[vertex].yoff * centreY;
X	    }
X    for ( vertex=0; vertex < NUM_VERT ; vertex++)
X	if ( endrad + EPSILON < vertices[vertex].rad  )
X	    break;
X	else
X	    {
X	    segment[p].x = centreX + vertices[vertex].xoff * centreX;
X	    segment[p++].y = centreY - vertices[vertex].yoff * centreY;
X	    }
X    }
X
project_onto_unit_square(endrad, &px, &py);
X
segment[p].x= centreX + px * centreX;
segment[p++].y= centreY + py * centreY;
X
segment[p].x=centreX;
segment[p++].y=centreY;
X
XXFillPolygon(dsp, dr, gc, segment, p, Nonconvex, CoordModeOrigin);
}
X	
/* ARGSUSED */
static Boolean SetValues (gcurrent, grequest, gnew)
X    Widget gcurrent, grequest, gnew;
{
X      WclockWidget current = (WclockWidget) gcurrent;
X      WclockWidget new = (WclockWidget) gnew;
X      Boolean redisplay = FALSE;
X      XtGCMask valuemask;
X      XGCValues	myXGCV;
X
X      /* first check for changes to Wclock-specific resources.  We'll accept all
X         the changes, but may need to do some computations first. */
X
X      if (new->Wclock.update != current->Wclock.update) {
X	  if (current->Wclock.interval_id)
X	      XtRemoveTimeOut (current->Wclock.interval_id);
X	  if (XtIsRealized(new))
X	      new->Wclock.interval_id = XtAppAddTimeOut( 
X                                         XtWidgetToApplicationContext(gnew),
X					 new->Wclock.update*1000,
X				         Wclock_tic, (caddr_t)gnew);
X
X      }
X
X
X      if ((new->Wclock.fgpixel != current->Wclock.fgpixel)
X          || (new->core.background_pixel != current->core.background_pixel)) {
X          valuemask = GCForeground | GCBackground | GCLineWidth;
X	  myXGCV.foreground = new->Wclock.fgpixel;
X	  myXGCV.background = new->core.background_pixel;
X	  myXGCV.line_width = 0;
X	  XtDestroyGC (current->Wclock.myGC);
X	  new->Wclock.myGC = XtGetGC(gcurrent, valuemask, &myXGCV);
X	  redisplay = TRUE;
X          }
X
X      if (new->core.background_pixel != current->core.background_pixel) {
X          valuemask = GCForeground | GCLineWidth;
X	  myXGCV.foreground = new->core.background_pixel;
X	  myXGCV.line_width = 0;
X	  XtDestroyGC (current->Wclock.EraseGC);
X	  new->Wclock.EraseGC = XtGetGC((Widget)gcurrent, valuemask, &myXGCV);
X	  redisplay = TRUE;
X	  }
X     
X     return (redisplay);
}
X
X
X
SHAR_EOF
chmod 0444 Wclock.c ||
echo 'restore of Wclock.c failed'
Wc_c="`wc -c < 'Wclock.c'`"
test 21042 -eq "$Wc_c" ||
	echo 'Wclock.c: original size 21042, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Wclock.h ==============
if test -f 'Wclock.h' -a X"$1" != X"-c"; then
	echo 'x - skipping Wclock.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Wclock.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Wclock.h' &&
/*
* $XConsortium: Wclock.h,v 1.28 89/07/20 14:54:38 jim Exp $
*/
X
/*
X * Hacked from Clock.h by RJC
X */
X
X
/***********************************************************
Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
X
X                        All Rights Reserved
X
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  
X
DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.
X
******************************************************************/
X
#ifndef _XawWclock_h
#define _XawWclock_h
X
/***********************************************************************
X *
X * Wclock Widget
X *
X ***********************************************************************/
X
#include <X11/Xmu/Converters.h>
#include "Outline.h"
X
/* Parameters:
X
X Name		     Class		RepType		Default Value
X ----		     -----		-------		-------------
X background	     Background		Pixel		white
X backgroundBitmap    Pixmap             Bitmap          None
X backingStore	     BackingStore	BackingStore	default
X border		     BorderColor	Pixel		Black
X borderWidth	     BorderWidth	Dimension	1
X debugInc	     DebugInc		int		0
X destroyCallback     Callback		Pointer		NULL
X forceShape          forceShape         Boolean         False
X foreground	     Foreground		Pixel		black
X height		     Height		Dimension	164
X internalOutline     Outline            Outline         NoOutline
X internalPercent     Margin             int             20
X internalBitmap      Pixmap             Bitmap          None
X externalOutline     Outline            Outline         NoOutline
X externalPercent     Margin             int             20
X externalBitmap      Mask               Bitmap          None
X mappedWhenManaged   MappedWhenManaged	Boolean		True
X padding	     Margin		int		8
X plotSegment         PlotSegment        Boolean         True
X shapeSegment        ShapeSegment       Boolean         False
X sliceOffset         Slice              int             0
X sliceSpace          Slice              int             0
X sliceWidth          Slice              int             0
X update		     Interval		int		60 (seconds)
X width		     Width		Dimension	164
X x		     Position		Position	0
X y		     Position		Position	0
X
*/
X
/* Resource names used to the Wclock widget */
X
#define XtNdebugInc "debugInc"
#define XtNinternalOutline "internalOutline"
#define XtNinternalPercent "internalPercent"
#define XtNinternalBitmap  "internalBitmap"
#define XtNexternalOutline "externalOutline"
#define XtNexternalPercent "externalPercent"
#define XtNexternalBitmap  "externalBitmap"
#define XtNforceShape      "forceShape"
#define XtNplotSegment     "plotSegment"
#define XtNshapeSegment    "shapeSegment"
#define XtNbackgroundBitmap "backgroundBitmap"
#define XtNsliceWidth      "sliceWidth"
#define XtNsliceSpace      "sliceSpace"
#define XtNsliceOffset     "sliceOffset"
X
#define XtCOutline "Outline"
#define XtCMask    "Mask"
#define XtCForceShape "ForceShape"
#define XtCPlotSegment     "PlotSegment"
#define XtCShapeSegment    "ShapeSegment"
#define XtCSlice   "Slice"
X
typedef struct _WclockRec *WclockWidget;  /* completely defined in WclockPrivate.h */
typedef struct _WclockClassRec *WclockWidgetClass;    /* completely defined in WclockPrivate.h */
X
extern WidgetClass wclockWidgetClass;
X
#endif /* _XawWclock_h */
/* DON'T ADD STUFF AFTER THIS #endif */
SHAR_EOF
chmod 0444 Wclock.h ||
echo 'restore of Wclock.h failed'
Wc_c="`wc -c < 'Wclock.h'`"
test 4180 -eq "$Wc_c" ||
	echo 'Wclock.h: original size 4180, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= WclockP.h ==============
if test -f 'WclockP.h' -a X"$1" != X"-c"; then
	echo 'x - skipping WclockP.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting WclockP.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'WclockP.h' &&
/*
* $XConsortium: WclockP.h,v 1.19 89/12/06 15:23:06 kit Exp $
*/
X
/*
X * Hacked from ClockP.h by RJC
X */
X
X
/***********************************************************
Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
X
X                        All Rights Reserved
X
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  
X
DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.
X
******************************************************************/
X
#ifndef _XawWclockP_h
#define _XawWclockP_h
X
#include <X11/Xos.h>		/* Needed for struct tm. */
#include "Wclock.h"
#include <X11/CoreP.h>
X
/* New fields for the Wclock widget instance record */
typedef struct {
X	 Pixel	fgpixel;	/* color index for text */
X	 GC	myGC;		/* pointer to GraphicsContext */
X	 GC	EraseGC;	/* eraser GC */
X	 GC	setGC;		/* pointer to GraphicsContext */
X	 GC	unsetGC;		/* pointer to GraphicsContext */
X	 GC	invertGC;		/* pointer to GraphicsContext */
X	 Pixmap segmentPM;	/* Holds the segment representing time */
X	 Pixmap outlinePM;	/* Holds the shape pixmap */
X	 int    externalOutline;
X	 int    externalPercent;
X	 Pixmap externalBitmap;
X	 int    internalOutline;
X	 int    internalPercent;
X	 Pixmap internalBitmap;
X	 Pixmap backgroundBitmap;
X	 int    sliceWidth;
X	 int    sliceSpace;
X	 int    sliceOffset;
X	 Boolean forceShape;
X	 Boolean plotSegment;
X	 Boolean shapeSegment;
/* start of graph stuff */
X	 int	update;		/* update frequence */
X	 int    debugInc;	/* how many seconds to add per update */
X	 Dimension radius;		/* radius factor */
X	 int	backing_store;	/* backing store type */
X	 Position centerX;
X	 Position centerY;
X	 XPoint	*hour, *min;
X	 struct tm  otm ;
X	 XtIntervalId interval_id;
X   } WclockPart;
X
/* Full instance record declaration */
typedef struct _WclockRec {
X   CorePart core;
X   WclockPart Wclock;
X   } WclockRec;
X
/* New fields for the Wclock widget class record */
typedef struct {int dummy;} WclockClassPart;
X
/* Full class record declaration. */
typedef struct _WclockClassRec {
X   CoreClassPart core_class;
X   WclockClassPart Wclock_class;
X   } WclockClassRec;
X
/* Class pointer. */
extern WclockClassRec wclockClassRec;
X
#endif /* _XawWclockP_h */
SHAR_EOF
chmod 0444 WclockP.h ||
echo 'restore of WclockP.h failed'
Wc_c="`wc -c < 'WclockP.h'`"
test 3038 -eq "$Wc_c" ||
	echo 'WclockP.h: original size 3038, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= eye.mask ==============
if test -f 'eye.mask' -a X"$1" != X"-c"; then
	echo 'x - skipping eye.mask (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting eye.mask (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'eye.mask' &&
#define eye_width 146
#define eye_height 99
static char eye_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
X   0x20, 0x22, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x02, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x48, 0x88, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x02, 0x40, 0x00, 0x01, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x10, 0x09, 0x52, 0x40,
X   0x80, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0xa0, 0x04, 0xff, 0x0f, 0x00, 0x01, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x81, 0x20, 0x09,
X   0xfd, 0xff, 0x7f, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0xf4, 0xff, 0xff, 0xff, 0x21, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
X   0x28, 0xfa, 0xff, 0xff, 0xff, 0x07, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0xd0, 0xff, 0xff, 0xff, 0xff,
X   0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x40, 0x10, 0xf5, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xf8, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x08, 0x29, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0xa0, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x20, 0xc8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf4, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x08, 0x91, 0xfa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x24, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0xfe,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20,
X   0x40, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x89, 0xff, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
SHAR_EOF
true || echo 'restore of eye.mask failed'
fi
echo 'End of  part 1'
echo 'File eye.mask is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
