Path: uunet!dtix!darwin.sura.net!mips!msi!dcmartin
From: gildea@EXPO.LCS.MIT.EDU (Stephen Gildea)
Newsgroups: comp.sources.x
Subject: v18i045: X11R5 public fix #13, Part04/05
Message-ID: <1992Jul22.150802.18817@msi.com>
Date: 22 Jul 92 15:08:02 GMT
References: <csx-18i042-X11R5-fix13@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1642
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: gildea@EXPO.LCS.MIT.EDU (Stephen Gildea)
Posting-number: Volume 18, Issue 45
Archive-name: X11R5-fix13/part04

#!/bin/sh
# this is part.04 (part 4 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file fix-13 continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 4; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping fix-13'
else
echo 'x - continuing file fix-13'
sed 's/^X//' << 'SHAR_EOF' >> 'fix-13' &&
***************
*** 524,533 ****
X      }
X      authp->authname = 0;
X      authp->authdata = 0;
!     if (index >= 0)
X      {
! 	authp->authname = (char *) fsalloc(acp[index].namelen + 1);
! 	authp->authdata = (char *) fsalloc(acp[index].datalen + 1);
X  	if (!authp->authname || !authp->authdata) {
X  	    fsfree((char *) authp->authname);
X  	    fsfree((char *) authp->authdata);
--- 530,539 ----
X      }
X      authp->authname = 0;
X      authp->authdata = 0;
!     if (index > 0)
X      {
! 	authp->authname = (char *) fsalloc(acp[index - 1].namelen + 1);
! 	authp->authdata = (char *) fsalloc(acp[index - 1].datalen + 1);
X  	if (!authp->authname || !authp->authdata) {
X  	    fsfree((char *) authp->authname);
X  	    fsfree((char *) authp->authdata);
***************
*** 534,542 ****
X  	    fsfree((char *) authp);
X  	    goto alloc_failure;
X  	}
! 	bcopy(acp[index].name, authp->authname, acp[index].namelen);
! 	bcopy(acp[index].data, authp->authdata, acp[index].datalen);
X      }
X      authp->acid = stuff->acid;
X      if (!AddResource(client->index, stuff->acid, RT_AUTHCONT,(pointer) authp)) 
X      {
--- 540,550 ----
X  	    fsfree((char *) authp);
X  	    goto alloc_failure;
X  	}
! 	bcopy(acp[index - 1].name, authp->authname, acp[index - 1].namelen);
! 	bcopy(acp[index - 1].data, authp->authdata, acp[index - 1].datalen);
X      }
+     else
+ 	size = 0;
X      authp->acid = stuff->acid;
X      if (!AddResource(client->index, stuff->acid, RT_AUTHCONT,(pointer) authp)) 
X      {
***************
*** 549,559 ****
X      DEALLOCATE_LOCAL(acp);
X      rep.type = FS_Reply;
X      rep.status = accept;
-     if (index < 0)
-     {
- 	size = 0;
- 	index = 0;
-     }
X      rep.auth_index = index;
X      rep.sequenceNumber = client->sequence;
X      rep.length = (sizeof(fsCreateACReply) + size) >> 2;
--- 557,562 ----
***************
*** 566,571 ****
--- 569,575 ----
X      return client->noClientException;
X  }
X  
+ /* ARGSUSED */
X  int
X  DeleteAuthCont (value, id)
X      pointer value;
***************
*** 659,667 ****
X      WriteReplyToClient(client, sizeof(fsGetResolutionReply), &reply);
X      if (client->swapped)
X  	client->pSwapReplyFunc = CopySwap16Write;
-     WriteSwappedDataToClient(client, client->resolutions,
- 			   (client->num_resolutions * sizeof(fsResolution)));
X  
X      return client->noClientException;
X  }
X  
--- 663,672 ----
X      WriteReplyToClient(client, sizeof(fsGetResolutionReply), &reply);
X      if (client->swapped)
X  	client->pSwapReplyFunc = CopySwap16Write;
X  
+     WriteSwappedDataToClient(client,
+        (client->num_resolutions * sizeof(fsResolution)), client->resolutions);
+ 
X      return client->noClientException;
X  }
X  
***************
*** 709,721 ****
X      }
X      if (stuff->format_hint != 0 &&
X  	    stuff->format_hint & ~ALL_FORMAT_BITS) {
! 	SendErrToClient(client, FSBadFormat,
! 			(pointer) &stuff->format_hint);
X  	return FSBadFormat;
X      }
X      if (stuff->format_mask & ~ALL_FORMAT_MASK_BITS) {
! 	SendErrToClient(client, FSBadFormat,
! 			(pointer) &stuff->format_mask);
X  	return FSBadFormat;
X      }
X      err = OpenFont(client, stuff->fid, stuff->format_hint, stuff->format_mask,
--- 714,724 ----
X      }
X      if (stuff->format_hint != 0 &&
X  	    stuff->format_hint & ~ALL_FORMAT_BITS) {
! 	SendErrToClient(client, FSBadFormat, (pointer) &stuff->format_hint);
X  	return FSBadFormat;
X      }
X      if (stuff->format_mask & ~ALL_FORMAT_MASK_BITS) {
! 	SendErrToClient(client, FSBadFormat, (pointer) &stuff->format_mask);
X  	return FSBadFormat;
X      }
X      err = OpenFont(client, stuff->fid, stuff->format_hint, stuff->format_mask,
***************
*** 750,760 ****
X      reply.sequenceNumber = client->sequence;
X  
X      /* get the header */
!     err = LoadFontHeader(&cfp->font->info, &reply.header, &prop_info);
X  
!     if (err != Successful) {
! 	SendErrToClient(client, FontToFSError(err), (pointer) NULL);
X  	return err;
X      }
X      lendata = sizeof(fsPropInfo) +
X  	prop_info->num_offsets * sizeof(fsPropOffset) +
--- 753,772 ----
X      reply.sequenceNumber = client->sequence;
X  
X      /* get the header */
!     err = LoadXFontInfo(client, &cfp->font->info, &reply.header, &prop_info);
X  
!     switch (err)
!     {
!     case Successful:
! 	break;
!     case AllocError:
! 	SendErrToClient(client, FSBadAlloc, (pointer) 0);
X  	return err;
+     default:
+ 	ErrorF("ProcQueryXInfo: unexpected return val %d from LoadXFontInfo",
+ 	       err);
+ 	SendErrToClient(client, FSBadImplementation, (pointer) 0);
+ 	return err;
X      }
X      lendata = sizeof(fsPropInfo) +
X  	prop_info->num_offsets * sizeof(fsPropOffset) +
***************
*** 772,778 ****
X  }
X  
X  int
! ProcQueryXExtents8(client)
X      ClientPtr   client;
X  {
X      ClientFontPtr cfp;
--- 784,790 ----
X  }
X  
X  int
! ProcQueryXExtents(client)
X      ClientPtr   client;
X  {
X      ClientFontPtr cfp;
***************
*** 801,807 ****
X  }
X  
X  int
! ProcQueryXBitmaps8(client)
X      ClientPtr   client;
X  {
X      ClientFontPtr cfp;
--- 813,819 ----
X  }
X  
X  int
! ProcQueryXBitmaps(client)
X      ClientPtr   client;
X  {
X      ClientFontPtr cfp;
***************
*** 858,889 ****
X  CloseDownClient(client)
X      ClientPtr   client;
X  {
!     if (client->clientGone == CLIENT_ALIVE) {
X  	client->clientGone = CLIENT_GONE;
X  	CloseDownConnection(client);
! 	FreeClientResources(client);
! 	if (ClientIsAsleep(client))
! 	    ClientSignal(client);
! 	if (client->index < nextFreeClientID)
! 	    nextFreeClientID = client->index;
! 	clients[client->index] = NullClient;
! 	fsfree(client);
! 	--nClients;
X  
X  #ifdef NOTYET
X  	/* reset server when last client goes away */
X  	if (client->requestVector != InitialVector && nClients == 0)
X  	    dispatchException |= DE_RESET;
X  #endif
!     } else {
! 	FreeClientResources(client);
! 	if (ClientIsAsleep(client))
! 	    ClientSignal(client);
! 	if (client->index < nextFreeClientID)
! 	    nextFreeClientID = client->index;
! 	clients[client->index] = NullClient;
! 	fsfree(client);
!     }
X  
X  #ifdef DEBUG
X      fprintf(stderr, "Shut down client\n");
--- 870,899 ----
X  CloseDownClient(client)
X      ClientPtr   client;
X  {
!     int client_alive = client->clientGone == CLIENT_ALIVE;
! 
!     if (client_alive) {
X  	client->clientGone = CLIENT_GONE;
X  	CloseDownConnection(client);
!     }
!     FreeClientResources(client);
!     if (ClientIsAsleep(client))
! 	ClientSignal(client);
!     if (client->index < nextFreeClientID)
! 	nextFreeClientID = client->index;
!     clients[client->index] = NullClient;
X  
+     if (client_alive) {
+ 	--nClients;
X  #ifdef NOTYET
X  	/* reset server when last client goes away */
X  	if (client->requestVector != InitialVector && nClients == 0)
X  	    dispatchException |= DE_RESET;
X  #endif
!     } 
!     if (currentClient == client)
! 	currentClient = serverClient;
!     fsfree(client);
X  
X  #ifdef DEBUG
X      fprintf(stderr, "Shut down client\n");
***************
*** 987,991 ****
X  MarkClientException(client)
X      ClientPtr   client;
X  {
!     client->noClientException = -1;
X  }
--- 997,1001 ----
X  MarkClientException(client)
X      ClientPtr   client;
X  {
!     client->noClientException = -2;
X  }
*** /tmp/da29150	Tue Jul 14 18:08:45 1992
--- mit/fonts/server/difs/fonts.c	Tue Jul 14 18:08:44 1992
***************
*** 1,4 ****
! /* $XConsortium: fonts.c,v 1.8 91/07/18 22:36:11 keith Exp $ */
X  /*
X   * font control
X   */
--- 1,4 ----
! /* $XConsortium: fonts.c,v 1.13 92/05/28 17:17:15 gildea Exp $ */
X  /*
X   * font control
X   */
***************
*** 7,31 ****
X   * Portions Copyright 1987 by Digital Equipment Corporation and the
X   * Massachusetts Institute of Technology
X   *
!  * Permission to use, copy, modify, and distribute this protoype software
!  * and its documentation to Members and Affiliates of the MIT X Consortium
!  * any purpose and without fee is hereby granted, provided
X   * that the above copyright notice appear in all copies and that both that
X   * copyright notice and this permission notice appear in supporting
X   * documentation, and that the names of Network Computing Devices, Digital or
!  * MIT not be used in advertising or publicity pertaining to distribution of
!  * the software without specific, written prior permission.
X   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
!  * AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES, DIGITAL OR MIT BE
!  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * $NCDId: @(#)fonts.c,v 4.14 1991/06/27 19:01:42 lemke Exp $
!  *
X   */
X  
X  #include        "FS.h"
--- 7,28 ----
X   * Portions Copyright 1987 by Digital Equipment Corporation and the
X   * Massachusetts Institute of Technology
X   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
X   * that the above copyright notice appear in all copies and that both that
X   * copyright notice and this permission notice appear in supporting
X   * documentation, and that the names of Network Computing Devices, Digital or
!  * M.I.T. not be used in advertising or publicity pertaining to distribution
!  * of the software without specific, written prior permission.
X   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
!  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
!  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
!  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
!  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
!  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
!  * THIS SOFTWARE.
X   */
X  
X  #include        "FS.h"
***************
*** 40,45 ****
--- 37,43 ----
X  #include	"globals.h"
X  
X  extern void (*ReplySwapVector[NUM_PROC_VECTORS]) ();
+ extern FSID FakeClientID();
X  
X  static FontPathElementPtr *font_path_elements = (FontPathElementPtr *) 0;
X  static int  num_fpes = 0;
***************
*** 153,159 ****
X  }
X  
X  /* ARGSUSED */
! int
X  FontWakeup(data, count, LastSelectMask)
X      pointer     data;
X      int         count;
--- 151,157 ----
X  }
X  
X  /* ARGSUSED */
! void
X  FontWakeup(data, count, LastSelectMask)
X      pointer     data;
X      int         count;
***************
*** 163,176 ****
X      FontPathElementPtr fpe;
X  
X      if (count < 0)
! 	return FSSuccess;	/* ignore -1 return from select XXX */
X      /* wake up any fpe's that may be waiting for information */
X      for (i = 0; i < num_slept_fpes; i++) {
X  	fpe = slept_fpes[i];
X  	(void) (*fpe_functions[fpe->type].wakeup_fpe) (fpe, LastSelectMask);
X      }
- 
-     return FSSuccess;
X  }
X  
X  static Bool
--- 161,172 ----
X      FontPathElementPtr fpe;
X  
X      if (count < 0)
! 	return;			/* ignore -1 return from select XXX */
X      /* wake up any fpe's that may be waiting for information */
X      for (i = 0; i < num_slept_fpes; i++) {
X  	fpe = slept_fpes[i];
X  	(void) (*fpe_functions[fpe->type].wakeup_fpe) (fpe, LastSelectMask);
X      }
X  }
X  
X  static Bool
***************
*** 581,587 ****
X      int		len;
X      int		type;
X      char       *cp = paths;
-     char       *colon;
X      FontPathElementPtr fpe,
X                 *fplist;
X  
--- 577,582 ----
***************
*** 705,713 ****
X      ClientPtr   client;
X      LFclosurePtr c;
X  {
!     int         err;
X      fsListFontsReply reply;
!     FontNamesPtr names;
X      FontPathElementPtr fpe;
X      int         stringLens,
X                  i,
--- 700,708 ----
X      ClientPtr   client;
X      LFclosurePtr c;
X  {
!     int         err = Successful;
X      fsListFontsReply reply;
!     FontNamesPtr names = NULL;
X      FontPathElementPtr fpe;
X      int         stringLens,
X                  i,
***************
*** 840,848 ****
X  {
X      LFclosurePtr c;
X  
-     if (!num_fpes)
- 	return FSSuccess;
- 
X      c = make_list_fonts_closure(client, pattern, length, maxnames);
X      if (!c)
X  	return FSBadAlloc;
--- 835,840 ----
***************
*** 851,856 ****
--- 843,851 ----
X      return FSSuccess;
X  }
X  
+ static int padlength[4] = {0, 3, 2, 1};
+ static char padding[3];
+ 
X  do_list_fonts_with_info(client, c)
X      ClientPtr   client;
X      LFWXIclosurePtr c;
***************
*** 966,972 ****
X  		name = c->savedName;
X  		namelen = strlen(name);
X  	    }
! 	    err = LoadFontHeader(pFontInfo, &hdr, &prop_info);
X  	    if (err != Successful)
X  		break;
X  	    lenpropdata = sizeof(fsPropInfo) +
--- 961,967 ----
X  		name = c->savedName;
X  		namelen = strlen(name);
X  	    }
! 	    err = LoadXFontInfo(client, pFontInfo, &hdr, &prop_info);
X  	    if (err != Successful)
X  		break;
X  	    lenpropdata = sizeof(fsPropInfo) +
***************
*** 975,981 ****
X  
X  	    reply->type = FS_Reply;
X  	    reply->length =
! 		(sizeof(fsListFontsWithXInfoReply) + sizeof(fsFontHeader) +
X  		 lenpropdata + namelen + 3) >> 2;
X  	    reply->sequenceNumber = client->sequence;
X  	    reply->nameLength = namelen;
--- 970,976 ----
X  
X  	    reply->type = FS_Reply;
X  	    reply->length =
! 		(sizeof(fsListFontsWithXInfoReply) +
X  		 lenpropdata + namelen + 3) >> 2;
X  	    reply->sequenceNumber = client->sequence;
X  	    reply->nameLength = namelen;
***************
*** 982,996 ****
X  	    reply->nReplies = numFonts;
X  	    reply->header = hdr;
X  	    WriteReplyToClient(client, sizeof(fsListFontsWithXInfoReply), reply);
- 	    (void) WriteToClient(client, namelen, name);
X  	    if (client->swapped)
X  		SwapPropInfo(prop_info);
! 	    (void) WriteToClient(client, lenpropdata, (char *) prop_info);
X  	    if (pFontInfo == &fontInfo) {
X  		fsfree(fontInfo.props);
X  		fsfree(fontInfo.isStringProp);
X  	    }
X  	    fsfree(prop_info);
X  	    --c->current.max_names;
X  	    if (c->current.max_names < 0)
X  		abort();
--- 977,1001 ----
X  	    reply->nReplies = numFonts;
X  	    reply->header = hdr;
X  	    WriteReplyToClient(client, sizeof(fsListFontsWithXInfoReply), reply);
X  	    if (client->swapped)
X  		SwapPropInfo(prop_info);
! 	    if (client->major_version > 1)
! 	    {
! 		(void)WriteToClientUnpadded(client, lenpropdata, (char *) prop_info);
! 		(void)WriteToClientUnpadded(client, namelen, name);
! 		(void)WriteToClientUnpadded(client,
! 					    padlength[(lenpropdata+namelen)&3],
! 					    padding);
! 	    } else {
! 		(void) WriteToClient(client, namelen, name);
! 		(void) WriteToClient(client, lenpropdata, (char *) prop_info);
! 	    }
X  	    if (pFontInfo == &fontInfo) {
X  		fsfree(fontInfo.props);
X  		fsfree(fontInfo.isStringProp);
X  	    }
X  	    fsfree(prop_info);
+ 
X  	    --c->current.max_names;
X  	    if (c->current.max_names < 0)
X  		abort();
***************
*** 997,1019 ****
X  	}
X      }
X  
X      if (err == Successful) {
! 	reply = c->reply;
! 	length = sizeof(fsListFontsWithXInfoReply);
X  	if (c->length < length) {
! 	    reply = (fsListFontsWithXInfoReply *) fsrealloc(c->reply, length);
! 	    if (reply) {
! 		c->reply = reply;
X  		c->length = length;
X  	    } else
X  		err = AllocError;
X  	}
X  	if (err == Successful) {
! 	    bzero((char *) reply, sizeof(fsListFontsWithXInfoReply));
! 	    reply->type = FS_Reply;
! 	    reply->sequenceNumber = client->sequence;
! 	    reply->length = sizeof(fsListFontsWithXInfoReply) >> 2;
! 	    WriteReplyToClient(client, length, reply);
X  	}
X      }
X      if (err != Successful)
--- 1002,1032 ----
X  	}
X      }
X  
+     /*
+      * send the final reply
+      */
X      if (err == Successful) {
! 	fsGenericReply *final_reply;
! 
! 	final_reply = (fsGenericReply *)c->reply;
! 	if (client->major_version > 1)
! 	    length = sizeof(fsGenericReply);
! 	else
! 	    length = sizeof(fsListFontsWithXInfoReply);
X  	if (c->length < length) {
! 	    final_reply = (fsGenericReply *) fsrealloc(c->reply, length);
! 	    if (final_reply) {
! 		c->reply = (fsListFontsWithXInfoReply *)final_reply;
X  		c->length = length;
X  	    } else
X  		err = AllocError;
X  	}
X  	if (err == Successful) {
! 	    final_reply->type = FS_Reply;
! 	    final_reply->data1 = 0; /* notes that this is final */
! 	    final_reply->sequenceNumber = client->sequence;
! 	    final_reply->length = length >> 2;
! 	    WriteReplyToClient(client, length, final_reply);
X  	}
X      }
X      if (err != Successful)
***************
*** 1128,1138 ****
X  find_old_font(id)
X      FSID        id;
X  {
!     ClientFontPtr cfp;
! 
!     cfp = (ClientFontPtr) LookupIDByType(SERVER_CLIENT, id, RT_NONE);
! 
!     return cfp->font;
X  }
X  
X  Font
--- 1141,1147 ----
X  find_old_font(id)
X      FSID        id;
X  {
!     return (FontPtr) LookupIDByType(SERVER_CLIENT, id, RT_NONE);
X  }
X  
X  Font
***************
*** 1160,1166 ****
X  
X  init_fs_handlers(fpe, block_handler)
X      FontPathElementPtr fpe;
!     int         (*block_handler) ();
X  {
X      /* if server has reset, make sure the b&w handlers are reinstalled */
X      if (last_server_gen < serverGeneration) {
--- 1169,1175 ----
X  
X  init_fs_handlers(fpe, block_handler)
X      FontPathElementPtr fpe;
!     void         (*block_handler) ();
X  {
X      /* if server has reset, make sure the b&w handlers are reinstalled */
X      if (last_server_gen < serverGeneration) {
***************
*** 1184,1190 ****
X  
X  remove_fs_handlers(fpe, block_handler, all)
X      FontPathElementPtr fpe;
!     int         (*block_handler) ();
X      Bool        all;
X  {
X      if (all) {
--- 1193,1199 ----
X  
X  remove_fs_handlers(fpe, block_handler, all)
X      FontPathElementPtr fpe;
!     void        (*block_handler) ();
X      Bool        all;
X  {
X      if (all) {
*** /tmp/da29246	Tue Jul 14 18:08:53 1992
--- mit/fonts/server/difs/Imakefile	Tue Jul 14 18:08:52 1992
***************
*** 1,13 ****
! XCOMM $XConsortium: Imakefile,v 1.8 91/07/17 16:06:01 gildea Exp $
X  #undef ServerDefines
X  #include <Server.tmpl>
X  
X  SRCS =	main.c dispatch.c extensions.c globals.c events.c tables.c \
! 	fontinfo.c swapreq.c swaprep.c resource.c \
X  	fonts.c difsutils.c cache.c initfonts.c atom.c
X  
X  OBJS =  main.o dispatch.o extensions.o globals.o events.o tables.o \
! 	fontinfo.o swapreq.o swaprep.o resource.o \
X  	fonts.o difsutils.o cache.o initfonts.o atom.o
X  
X  
--- 1,13 ----
! XCOMM $XConsortium: Imakefile,v 1.9 92/05/12 18:08:03 gildea Exp $
X  #undef ServerDefines
X  #include <Server.tmpl>
X  
X  SRCS =	main.c dispatch.c extensions.c globals.c events.c tables.c \
! 	fontinfo.c charinfo.c swapreq.c swaprep.c resource.c \
X  	fonts.c difsutils.c cache.c initfonts.c atom.c
X  
X  OBJS =  main.o dispatch.o extensions.o globals.o events.o tables.o \
! 	fontinfo.o charinfo.o swapreq.o swaprep.o resource.o \
X  	fonts.o difsutils.o cache.o initfonts.o atom.o
X  
X  
*** /tmp/da29310	Tue Jul 14 18:08:58 1992
--- mit/fonts/server/difs/swaprep.c	Tue Jul 14 18:08:57 1992
***************
*** 1,4 ****
! /* $XConsortium: swaprep.c,v 1.5 91/07/27 02:30:02 keith Exp $ */
X  /*
X   * font server reply swapping
X   */
--- 1,4 ----
! /* $XConsortium: swaprep.c,v 1.7 92/05/28 16:43:00 gildea Exp $ */
X  /*
X   * font server reply swapping
X   */
***************
*** 7,32 ****
X   * Portions Copyright 1987 by Digital Equipment Corporation and the
X   * Massachusetts Institute of Technology
X   *
!  * Permission to use, copy, modify, and distribute this protoype software
!  * and its documentation to Members and Affiliates of the MIT X Consortium
!  * any purpose and without fee is hereby granted, provided
X   * that the above copyright notice appear in all copies and that both that
X   * copyright notice and this permission notice appear in supporting
X   * documentation, and that the names of Network Computing Devices, Digital or
!  * MIT not be used in advertising or publicity pertaining to distribution of
!  * the software without specific, written prior permission.
X   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
!  * AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES, DIGITAL OR MIT BE
!  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * $NCDId: @(#)swaprep.c,v 4.2 1991/06/27 16:34:43 lemke Exp $
!  *
X   */
X  #include	"FSproto.h"
X  #include	"clientstr.h"
X  #include	"misc.h"
--- 7,30 ----
X   * Portions Copyright 1987 by Digital Equipment Corporation and the
X   * Massachusetts Institute of Technology
X   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
X   * that the above copyright notice appear in all copies and that both that
X   * copyright notice and this permission notice appear in supporting
X   * documentation, and that the names of Network Computing Devices, Digital or
!  * M.I.T. not be used in advertising or publicity pertaining to distribution
!  * of the software without specific, written prior permission.
X   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
!  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
!  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
!  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
!  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
!  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
!  * THIS SOFTWARE.
X   */
+ 
X  #include	"FSproto.h"
X  #include	"clientstr.h"
X  #include	"misc.h"
***************
*** 321,330 ****
X  }
X  
X  void
! SQueryXExtents8Reply(client, size, pRep)
X      ClientPtr   client;
X      int         size;
!     fsQueryXExtents8Reply *pRep;
X  {
X      int         n;
X  
--- 319,328 ----
X  }
X  
X  void
! SQueryXExtentsReply(client, size, pRep)
X      ClientPtr   client;
X      int         size;
!     fsQueryXExtents8Reply *pRep; /* QueryXExtents16Reply is the same */
X  {
X      int         n;
X  
***************
*** 335,344 ****
X  }
X  
X  void
! SQueryXBitmaps8Reply(client, size, pRep)
X      ClientPtr   client;
X      int         size;
!     fsQueryXBitmaps8Reply *pRep;
X  {
X      int         n;
X  
--- 333,342 ----
X  }
X  
X  void
! SQueryXBitmapsReply(client, size, pRep)
X      ClientPtr   client;
X      int         size;
!     fsQueryXBitmaps8Reply *pRep; /* QueryXBitmaps16Reply is the same */
X  {
X      int         n;
X  
***************
*** 376,382 ****
X  
X      pInfoT = pInfoTBase = (char *) ALLOCATE_LOCAL(size);
X      if (!pInfoT) {
! 	client->noClientException = -1;
X  	return;
X      }
X      SwapConnSetupAccept(pConnSetup, (fsConnSetupAccept *) pInfoT);
--- 374,380 ----
X  
X      pInfoT = pInfoTBase = (char *) ALLOCATE_LOCAL(size);
X      if (!pInfoT) {
! 	client->noClientException = -2;
X  	return;
X      }
X      SwapConnSetupAccept(pConnSetup, (fsConnSetupAccept *) pInfoT);
*** /tmp/da29353	Tue Jul 14 18:09:02 1992
--- mit/fonts/server/difs/swapreq.c	Tue Jul 14 18:09:02 1992
***************
*** 1,4 ****
! /* $XConsortium: swapreq.c,v 1.3 91/07/16 20:23:43 keith Exp $ */
X  /*
X   * swapped requests
X   */
--- 1,4 ----
! /* $XConsortium: swapreq.c,v 1.5 92/05/28 16:43:04 gildea Exp $ */
X  /*
X   * swapped requests
X   */
***************
*** 7,31 ****
X   * Portions Copyright 1987 by Digital Equipment Corporation and the
X   * Massachusetts Institute of Technology
X   *
!  * Permission to use, copy, modify, and distribute this protoype software
!  * and its documentation to Members and Affiliates of the MIT X Consortium
!  * any purpose and without fee is hereby granted, provided
X   * that the above copyright notice appear in all copies and that both that
X   * copyright notice and this permission notice appear in supporting
X   * documentation, and that the names of Network Computing Devices, Digital or
!  * MIT not be used in advertising or publicity pertaining to distribution of
!  * the software without specific, written prior permission.
X   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
!  * AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES, DIGITAL OR MIT BE
!  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * $NCDId: @(#)swapreq.c,v 4.2 1991/06/27 16:34:49 lemke Exp $
!  *
X   */
X  
X  #include	"misc.h"
--- 7,28 ----
X   * Portions Copyright 1987 by Digital Equipment Corporation and the
X   * Massachusetts Institute of Technology
X   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
X   * that the above copyright notice appear in all copies and that both that
X   * copyright notice and this permission notice appear in supporting
X   * documentation, and that the names of Network Computing Devices, Digital or
!  * M.I.T. not be used in advertising or publicity pertaining to distribution
!  * of the software without specific, written prior permission.
X   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
!  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
!  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
!  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
!  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
!  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
!  * THIS SOFTWARE.
X   */
X  
X  #include	"misc.h"
***************
*** 250,279 ****
X  }
X  
X  int
! SProcQueryXExtents8(client)
X      ClientPtr   client;
X  {
X      char        n;
X  
!     REQUEST(fsQueryXExtents8Req);
X      swaps(&stuff->length, n);
X      swapl(&stuff->fid, n);
X  
!     return ((*ProcVector[FS_QueryXExtents8]) (client));
X  }
X  
X  int
! SProcQueryXBitmaps8(client)
X      ClientPtr   client;
X  {
X      char        n;
X  
!     REQUEST(fsQueryXBitmaps8Req);
X      swaps(&stuff->length, n);
X      swapl(&stuff->fid, n);
X      swapl(&stuff->format, n);
X  
!     return ((*ProcVector[FS_QueryXBitmaps8]) (client));
X  }
X  
X  SwapConnClientPrefix(pCCP)
--- 247,278 ----
X  }
X  
X  int
! SProcQueryXExtents(client)
X      ClientPtr   client;
X  {
X      char        n;
X  
!     REQUEST(fsQueryXExtents8Req); /* 8 and 16 are the same here */
X      swaps(&stuff->length, n);
X      swapl(&stuff->fid, n);
+     swapl(&stuff->num_ranges, n);
X  
!     return ((*ProcVector[stuff->reqType]) (client));
X  }
X  
X  int
! SProcQueryXBitmaps(client)
X      ClientPtr   client;
X  {
X      char        n;
X  
!     REQUEST(fsQueryXBitmaps8Req); /* 8 and 16 are the same here */
X      swaps(&stuff->length, n);
X      swapl(&stuff->fid, n);
X      swapl(&stuff->format, n);
+     swapl(&stuff->num_ranges, n);
X  
!     return ((*ProcVector[stuff->reqType]) (client));
X  }
X  
X  SwapConnClientPrefix(pCCP)
*** /tmp/da29375	Tue Jul 14 18:09:04 1992
--- mit/fonts/server/difs/tables.c	Tue Jul 14 18:09:04 1992
***************
*** 1,4 ****
! /* $XConsortium: tables.c,v 1.3 91/07/16 20:23:45 keith Exp $ */
X  /*
X   * all the dispatch, error, event and reply vectors
X   */
--- 1,4 ----
! /* $XConsortium: tables.c,v 1.5 92/05/28 16:43:08 gildea Exp $ */
X  /*
X   * all the dispatch, error, event and reply vectors
X   */
***************
*** 7,42 ****
X   * Portions Copyright 1987 by Digital Equipment Corporation and the
X   * Massachusetts Institute of Technology
X   *
!  * Permission to use, copy, modify, and distribute this protoype software
!  * and its documentation to Members and Affiliates of the MIT X Consortium
!  * any purpose and without fee is hereby granted, provided
X   * that the above copyright notice appear in all copies and that both that
X   * copyright notice and this permission notice appear in supporting
X   * documentation, and that the names of Network Computing Devices, Digital or
!  * MIT not be used in advertising or publicity pertaining to distribution of
!  * the software without specific, written prior permission.
X   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND MIT DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
!  * AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES, DIGITAL OR MIT BE
!  * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * $NCDId: @(#)tables.c,v 4.2 1991/06/27 16:34:38 lemke Exp $
!  *
X   */
- #include	"globals.h"
X  
X  extern int  ProcInitialConnection(), ProcEstablishConnection();
X  
! extern int  ProcSetAuthorization(), ProcGetAuthorization(),
X              ProcSetResolution(), ProcGetResolution(), ProcNoop(),
X              ProcListExtensions(), ProcQueryExtension(),
X              ProcListFonts(), ProcListFontsWithXInfo(),
!             ProcOpenBitmapFont(), ProcQueryXInfo(), ProcQueryXExtents8(),
!             ProcQueryXBitmaps8(), ProcCloseFont(),
X              ProcListCatalogues(), ProcSetCatalogues(), ProcGetCatalogues(),
X              ProcSetEventMask(), ProcGetEventMask(),
X              ProcCreateAC(), ProcFreeAC();
--- 7,40 ----
X   * Portions Copyright 1987 by Digital Equipment Corporation and the
X   * Massachusetts Institute of Technology
X   *
!  * Permission to use, copy, modify, distribute, and sell this software and
!  * its documentation for any purpose is hereby granted without fee, provided
X   * that the above copyright notice appear in all copies and that both that
X   * copyright notice and this permission notice appear in supporting
X   * documentation, and that the names of Network Computing Devices, Digital or
!  * M.I.T. not be used in advertising or publicity pertaining to distribution
!  * of the software without specific, written prior permission.
X   *
!  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
!  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
!  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
!  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
!  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
!  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
!  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
!  * THIS SOFTWARE.
X   */
X  
+ #include "globals.h"
+ 
X  extern int  ProcInitialConnection(), ProcEstablishConnection();
X  
! extern int  ProcSetAuthorization(),
X              ProcSetResolution(), ProcGetResolution(), ProcNoop(),
X              ProcListExtensions(), ProcQueryExtension(),
X              ProcListFonts(), ProcListFontsWithXInfo(),
!             ProcOpenBitmapFont(), ProcQueryXInfo(), ProcQueryXExtents(),
!             ProcQueryXBitmaps(), ProcCloseFont(),
X              ProcListCatalogues(), ProcSetCatalogues(), ProcGetCatalogues(),
X              ProcSetEventMask(), ProcGetEventMask(),
X              ProcCreateAC(), ProcFreeAC();
***************
*** 43,53 ****
X  
X  extern int  SProcSimpleRequest(), SProcResourceRequest(),
X  	    SProcListCatalogues(),
!             SProcSetResolution(), SProcGetResolution(),
!             SProcListExtensions(), SProcQueryExtension(),
X              SProcListFonts(), SProcListFontsWithXInfo(),
!             SProcOpenBitmapFont(), SProcQueryXExtents8(),
!             SProcQueryXBitmaps8(),
X              SProcCreateAC();
X  
X  extern void SErrorEvent();
--- 41,51 ----
X  
X  extern int  SProcSimpleRequest(), SProcResourceRequest(),
X  	    SProcListCatalogues(),
!             SProcSetResolution(),
!             SProcQueryExtension(),
X              SProcListFonts(), SProcListFontsWithXInfo(),
!             SProcOpenBitmapFont(), SProcQueryXExtents(),
!             SProcQueryXBitmaps(),
X              SProcCreateAC();
X  
X  extern void SErrorEvent();
***************
*** 58,65 ****
X              SQueryExtensionReply(),
X              SListFontsReply(), SListFontsWithXInfoReply(),
X              SOpenBitmapFontReply(),
!             SQueryXInfoReply(), SQueryXExtents8Reply(),
!             SQueryXBitmaps8Reply(),
X              SGetEventMaskReply(), SCreateACReply(), SGetResolutionReply(),
X              SOpenBitmapFontReply();
X  
--- 56,63 ----
X              SQueryExtensionReply(),
X              SListFontsReply(), SListFontsWithXInfoReply(),
X              SOpenBitmapFontReply(),
!             SQueryXInfoReply(), SQueryXExtentsReply(),
!             SQueryXBitmapsReply(),
X              SGetEventMaskReply(), SCreateACReply(), SGetResolutionReply(),
X              SOpenBitmapFontReply();
X  
***************
*** 90,99 ****
X      ProcListFontsWithXInfo,
X      ProcOpenBitmapFont,		/* 15 */
X      ProcQueryXInfo,
!     ProcQueryXExtents8,
!     ProcQueryXExtents8,
!     ProcQueryXBitmaps8,
!     ProcQueryXBitmaps8,		/* 20 */
X      ProcCloseFont,
X      0,
X      0,
--- 88,97 ----
X      ProcListFontsWithXInfo,
X      ProcOpenBitmapFont,		/* 15 */
X      ProcQueryXInfo,
!     ProcQueryXExtents,
!     ProcQueryXExtents,
!     ProcQueryXBitmaps,
!     ProcQueryXBitmaps,		/* 20 */
X      ProcCloseFont,
X      0,
X      0,
***************
*** 104,110 ****
X  {
X      SProcSimpleRequest,		/* 0 */
X      SProcSimpleRequest,
!     ProcQueryExtension,
X      SProcListCatalogues,
X      SProcSimpleRequest,		/* SetCatalogues */
X      SProcSimpleRequest,		/* 5 */
--- 102,108 ----
X  {
X      SProcSimpleRequest,		/* 0 */
X      SProcSimpleRequest,
!     SProcQueryExtension,
X      SProcListCatalogues,
X      SProcSimpleRequest,		/* SetCatalogues */
X      SProcSimpleRequest,		/* 5 */
***************
*** 119,128 ****
X      SProcListFontsWithXInfo,
X      SProcOpenBitmapFont,	/* 15 */
X      SProcResourceRequest,
!     SProcQueryXExtents8,
!     SProcQueryXExtents8,
!     SProcQueryXBitmaps8,
!     SProcQueryXBitmaps8,	/* 20 */
X      SProcResourceRequest,
X      0,
X      0,
--- 117,126 ----
X      SProcListFontsWithXInfo,
X      SProcOpenBitmapFont,	/* 15 */
X      SProcResourceRequest,
!     SProcQueryXExtents,
!     SProcQueryXExtents,
!     SProcQueryXBitmaps,
!     SProcQueryXBitmaps,		/* 20 */
X      SProcResourceRequest,
X      0,
X      0,
***************
*** 160,169 ****
X      SListFontsWithXInfoReply,
X      SOpenBitmapFontReply,	/* 15 */
X      SQueryXInfoReply,
!     SQueryXExtents8Reply,
!     SQueryXExtents8Reply,
!     SQueryXBitmaps8Reply,
!     SQueryXBitmaps8Reply,	/* 20 */
X      NotImplemented,		/* Close */
X      NotImplemented,
X      NotImplemented
--- 158,167 ----
X      SListFontsWithXInfoReply,
X      SOpenBitmapFontReply,	/* 15 */
X      SQueryXInfoReply,
!     SQueryXExtentsReply,
!     SQueryXExtentsReply,
!     SQueryXBitmapsReply,
!     SQueryXBitmapsReply,	/* 20 */
X      NotImplemented,		/* Close */
X      NotImplemented,
X      NotImplemented
*** /dev/null	Tue Jul 14 18:06:05 1992
--- mit/fonts/server/difs/charinfo.c	Tue Jul 14 18:09:06 1992
***************
*** 0 ****
--- 1,592 ----
+ /* $XConsortium: charinfo.c,v 1.6 92/05/28 15:57:19 gildea Exp $ */
+ /*
+  * Copyright 1990, 1991 Network Computing Devices;
+  * Portions Copyright 1987 by Digital Equipment Corporation and the
+  * Massachusetts Institute of Technology
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and
+  * its documentation for any purpose is hereby granted without fee, provided
+  * that the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the names of Network Computing Devices, Digital or
+  * M.I.T. not be used in advertising or publicity pertaining to distribution
+  * of the software without specific, written prior permission.
+  *
+  * NETWORK COMPUTING DEVICES, DIGITAL AND M.I.T. DISCLAIM ALL WARRANTIES WITH
+  * REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
+  * MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NETWORK COMPUTING DEVICES,
+  * DIGITAL OR M.I.T. BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
+  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+  * THIS SOFTWARE.
+  */
+ /*
+  * Defines GetExtents() and GetBitmaps(), which are
+  * called from routines in fontinfo.c.
+  * This file was once on the other side of
+  * the font library interface as util/fsfuncs.c.
+  */
+ 
+ #include <X11/Xos.h>
+ #include "misc.h"
+ #include "fontstruct.h"
+ #include "clientstr.h"
+ #define FSMD_H
+ #include "FSproto.h"
+ 
+ extern void TwoByteSwap();
+ extern void FourByteSwap();
+ 
+ #define GLWIDTHBYTESPADDED(bits,nbytes) \
+ 	((nbytes) == 1 ? (((bits)+7)>>3)        /* pad to 1 byte */ \
+ 	:(nbytes) == 2 ? ((((bits)+15)>>3)&~1)  /* pad to 2 bytes */ \
+ 	:(nbytes) == 4 ? ((((bits)+31)>>3)&~3)  /* pad to 4 bytes */ \
+ 	:(nbytes) == 8 ? ((((bits)+63)>>3)&~7)  /* pad to 8 bytes */ \
+ 	: 0)
+ 
+ #define GLYPH_SIZE(ch, nbytes)          \
+ 	GLWIDTHBYTESPADDED((ch)->metrics.rightSideBearing - \
+ 			(ch)->metrics.leftSideBearing, (nbytes))
+ 
+ #define n2dChars(pfi)   (((pfi)->lastRow - (pfi)->firstRow + 1) * \
+                          ((pfi)->lastCol - (pfi)->firstCol + 1))
+ 
+ static CharInfoRec  junkDefault;
+ 
+ static int
+ getCharInfos (pfont, num_ranges, range, ink_metrics, nump, retp)
+     FontPtr	pfont;
+     int		num_ranges;
+     fsRange	*range;
+     Bool	ink_metrics;
+     int		*nump;		/* return */
+     CharInfoPtr	**retp;		/* return */
+ {
+     CharInfoPtr	*xchars, *xci;
+     int		nchars;
+     FontInfoPtr pinfo = &pfont->info;
+     unsigned int r, c;
+     unsigned char   ch[2];
+     int         firstCol = pinfo->firstCol;
+     int         firstRow = pinfo->firstRow;
+     int         lastRow = pinfo->lastRow;
+     int         lastCol = pinfo->lastCol;
+     int		minCol, maxCol;
+     int         num_cols = lastCol - firstCol + 1;
+     fsRange	local_range, *rp;
+     int		i;
+     FontEncoding    encoding;
+     int		err;
+     unsigned long   glyphCount;
+     unsigned short  defaultCh;
+     CharInfoPtr	    defaultPtr;
+     int (*metrics_func) ();
+     
+     /*
+      * compute nchars
+      */
+     if (num_ranges == 0) {
+ 	if (lastRow)
+ 	    nchars = n2dChars(pinfo);
+ 	else
+ 	    nchars = lastCol - firstCol + 1;
+ 	local_range.min_char.low = firstCol;
+ 	local_range.min_char.high = firstRow;
+ 	local_range.max_char.low = lastCol;
+ 	local_range.max_char.high = lastRow;
+ 	range = &local_range;
+ 	num_ranges = 1;
+     } else {
+ 	nchars = 0;
+ 	for (i = 0, rp = range; i < num_ranges; i++, rp++) {
+ 	    if (rp->min_char.high > rp->max_char.high)
+ 		return BadCharRange;
+ 	    if (rp->min_char.high == rp->max_char.high)
+ 	    {
+ 		if (rp->min_char.low > rp->max_char.low)
+ 		    return BadCharRange;
+ 		nchars += rp->max_char.low - rp->min_char.low + 1;
+ 	    }
+ 	    else
+ 	    {
+ 		nchars += lastRow - rp->min_char.low + 1;
+ 		nchars += (rp->max_char.high - rp->min_char.high - 1) * num_cols;
+ 		nchars += rp->max_char.low - firstRow + 1;
+ 	    }
+ 	}
+     }
+ 
+     xchars = (CharInfoPtr *) fsalloc (sizeof (CharInfoPtr) * nchars);
+     if (!xchars)
+ 	return AllocError;
+ 
+     if (ink_metrics)
+ 	metrics_func = pfont->get_metrics;
+     else
+ 	metrics_func = pfont->get_glyphs;
+ 
+     xci = xchars;
+     encoding = Linear16Bit;
+     if (lastRow)
+ 	encoding = TwoD16Bit;
+     defaultCh = pinfo->defaultCh;
+     ch[0] = defaultCh >> 8;
+     ch[1] = defaultCh & 0xff;
+     /* get the default character */
+     (*metrics_func) (pfont, 1, ch, encoding,
+ 			  &glyphCount, &defaultPtr);
+     if (glyphCount != 1)
+ 	defaultPtr = 0;
+     
+     /* for each range, get each character individually, undoing the
+      default character substitution so we get zero metrics for
+      non-existent characters. */
+     for (i = 0, rp = range; i < num_ranges; i++, rp++) {
+ 	for (r = rp->min_char.high; r <= rp->max_char.high; r++)
+ 	{
+ 	    minCol = firstCol;
+ 	    if (r == rp->min_char.high)
+ 		minCol = rp->min_char.low;
+ 	    maxCol = lastCol;
+ 	    if (r == rp->max_char.high)
+ 		maxCol = rp->max_char.low;
+ 	    for (c = minCol; c <= maxCol; c++) {
+ 		ch[0] = r;
+ 		ch[1] = c;
+ 		err = (*metrics_func) (pfont, 1, ch, encoding,
+ 					    &glyphCount, xci);
+ 		if (err != Successful)
+ 		{
+ 		    fsfree (xchars);
+ 		    return err;
+ 		}
+ 		if (glyphCount != 1 || 
+ 		    *xci == defaultPtr && defaultCh != ((r<<8)+c))
+ 		    *xci = &junkDefault;
+ 		xci++;
+ 	    }
+ 	}
+     }
+     *retp = xchars;
+     *nump = nchars;
+     return Successful;
+ }
+ 
+ int
+ GetExtents(client, pfont, flags, num_ranges, range, num_extents, data)
+     ClientPtr     client;
+     FontPtr     pfont;
+     Mask        flags;
+     unsigned long num_ranges;
+     fsRange    *range;
+     unsigned long *num_extents;	/* return */
+     fsCharInfo **data;		/* return */
+ {
+     unsigned long size;
+     fsCharInfo *ci,
+     *pci;
+     CharInfoPtr	*xchars, *xcharsFree, xci;
+     int		nchars;
+     int		err;
+     
+     if (flags & LoadAll)
+ 	num_ranges = 0;
+     err = getCharInfos (pfont, num_ranges, range,
+ 			client->major_version > 1 ? TRUE : FALSE,
+ 			&nchars, &xchars);
+     if (err != Successful)
+ 	return err;
+     
+     size = sizeof(fsCharInfo) * nchars;
+     pci = ci = (fsCharInfo *) fsalloc(size);
+     if (!ci) {
+ 	fsfree (xchars);
+ 	return AllocError;
+     }
+     
+     *num_extents = nchars;
+     xcharsFree = xchars;
+     
+     while (nchars--) {
+ 	xci = *xchars++;
+ 	pci->ascent = xci->metrics.ascent;
+ 	pci->descent = xci->metrics.descent;
+ 	pci->left = xci->metrics.leftSideBearing;
+ 	pci->right = xci->metrics.rightSideBearing;
+ 	pci->width = xci->metrics.characterWidth;
+ 	pci->attributes = 0;
+ 	pci++;
+     }
+     
+     fsfree (xcharsFree);
+     
+     *data = ci;
+     
+     return Successful;
+ }
+ 
+ static int
+ packGlyphs (client, pfont, format, flags, num_ranges, range, tsize, num_glyphs,
+ 		offsets, data, freeData)
+     ClientPtr   client;
+     FontPtr     pfont;
+     int         format;
+     Mask        flags;
+     unsigned long num_ranges;
+     fsRange    *range;
+     int        *tsize;
+     unsigned long *num_glyphs;
+     fsOffset  **offsets;
+     pointer    *data;
+     int		*freeData;
+ {
+     int         i;
+     fsOffset	*lengths, *l;
+     unsigned long size = 0;
+     pointer     gdata,
+     gd;
+     int         bitorder, byteorder, scanlinepad, scanlineunit, mappad;
+     int		height, dstbpr, charsize;
+     int		dst_off, src_off;
+     Bool	contiguous, reformat;
+     int		nchars;
+     int         src_glyph_pad = pfont->glyph;
+     int         src_bit_order = pfont->bit;
+     int         src_byte_order = pfont->byte;
+     int         err;
+     int		max_ascent, max_descent;
+     int		min_left, max_right;
+     int		srcbpr;
+     int		lshift = 0, rshift = 0, dst_left_bytes = 0, src_left_bytes = 0;
+     unsigned char   *srcp;
+     unsigned char   *dstp;
+     unsigned char   bits1, bits2;
+     int		    width;
+     int		    src_extra;
+     int		    dst_extra;
+     int		    r, w;
+     CharInfoPtr	*bitChars, *bitCharsFree, bitc;
+     CharInfoPtr	*inkChars, *inkCharsFree = 0, inkc;
+     FontInfoPtr	pinfo = &pfont->info;
+     xCharInfo	*bitm, *inkm;
+     
+     err = CheckFSFormat(format, (fsBitmapFormatMask) ~ 0,
+ 			&bitorder, &byteorder, &scanlineunit, &scanlinepad, &mappad);
+     
+     if (err != Successful)
+ 	return err;
+     
+     if (flags & LoadAll)
+ 	num_ranges = 0;
+     
+     err = getCharInfos (pfont, num_ranges, range, FALSE, &nchars, &bitCharsFree);
+     
+     if (err != Successful)
+ 	return err;
+     
+     /* compute dstbpr for padded out fonts */
+     reformat = bitorder != src_bit_order || byteorder != src_byte_order;
+ 
+     /* we need the ink metrics when shrink-wrapping a TE font (sigh),
+      * but only for protocol version > 1 */
+     if (mappad != BitmapFormatImageRectMax &&
+ 	pinfo->inkMetrics &&
+ 	client->major_version > 1)
+     {
+ 	err = getCharInfos (pfont, num_ranges, range, TRUE, &nchars, &inkCharsFree);
+ 	if (err != Successful)
+ 	{
+ 	    fsfree (bitCharsFree);
+ 	    return err;
+ 	}
+ 	reformat = TRUE;
+     }
+ 
+     /* get space for glyph offsets */
+     lengths = (fsOffset *) fsalloc(sizeof(fsOffset) * nchars);
+     if (!lengths) {
+ 	fsfree (bitCharsFree);
+ 	fsfree (inkCharsFree);
+ 	return AllocError;
+     }
+     
+     switch (mappad)
+     {
+     case BitmapFormatImageRectMax:
+ 	max_ascent = FONT_MAX_ASCENT(pinfo);
+ 	max_descent = FONT_MAX_DESCENT(pinfo);
+ 	height = max_ascent + max_descent;
+ 	/* do font ascent and font descent match bitmap bounds ? */
+ 	if (height != pinfo->minbounds.ascent + pinfo->minbounds.descent)
+ 	    reformat = TRUE;
+ 	/* fall through */
+     case BitmapFormatImageRectMaxWidth:
+ 	min_left = FONT_MIN_LEFT(pinfo);
+ 	max_right = FONT_MAX_RIGHT(pinfo);
+ 	if (min_left != pinfo->maxbounds.leftSideBearing)
+ 	    reformat = TRUE;
+ 	if (max_right != pinfo->maxbounds.rightSideBearing)
+ 	    reformat = TRUE;
+ 	dstbpr = GLWIDTHBYTESPADDED(max_right - min_left, scanlinepad);
+ 	break;
+     case BitmapFormatImageRectMin:
+ 	break;
+     }
+     if (mappad == BitmapFormatImageRectMax)
+ 	charsize = dstbpr * height;
+     size = 0;
+     gdata = 0;
+     contiguous = TRUE;
+     l = lengths;
+     inkChars = inkCharsFree;
+     bitChars = bitCharsFree;
+     for (i = 0; i < nchars; i++)
+     {
+     	inkc = bitc = *bitChars++;
+ 	/* when ink metrics != bitmap metrics, use ink metrics */
+ 	if (inkChars)
+ 	    inkc = *inkChars++;
+     	l->position = size;
+     	if (bitc && bitc->bits) {
+ 	    if (!gdata)
+ 		gdata = (pointer) bitc->bits;
+ 	    if ((char *) gdata + size != bitc->bits)
+ 		contiguous = FALSE;
+ 	    if (mappad == BitmapFormatImageRectMin)
+ 		dstbpr = GLYPH_SIZE(inkc, scanlinepad);
+ 	    if (mappad != BitmapFormatImageRectMax)
+ 	    {
+ 		height = inkc->metrics.ascent + inkc->metrics.descent;
+ 		charsize = height * dstbpr;
+ 	    }
+ 	    l->length = charsize;
+ 	    size += charsize;
+ 	}
+ 	else
+ 	    l->length = 0;
+ 	l++;
+     }
+     if (contiguous && !reformat)
+     {
+ 	*num_glyphs = nchars;
+ 	*freeData = FALSE;
+ 	*data = gdata;
+ 	*tsize = size;
+ 	*offsets = lengths;
+ 	fsfree (bitCharsFree);
+ 	fsfree (inkCharsFree);
+ 	return Successful;
+     }
+     if (size)
+     {
+ 	gdata = (pointer) fsalloc(size);
+ 	if (!gdata) {
+ 	    fsfree (bitCharsFree);
+ 	    fsfree (inkCharsFree);
+ 	    fsfree (lengths);
+ 	    return AllocError;
+ 	}
+ 	bzero ((char *) gdata, size);
+     }
+     else
+ 	gdata = NULL;
+     
+     *freeData = TRUE;
+     l = lengths;
+     gd = gdata;
+     
+     /* finally do the work */
+     bitChars = bitCharsFree;
+     inkChars = inkCharsFree;
+     for (i = 0; i < nchars; i++, l++) 
+     {
+ 	inkc = bitc = *bitChars++;
+ 	if (inkChars)
+ 	    inkc = *inkChars++;
+ 
+ 	/* ignore missing chars */
+ 	if (l->length == 0)
+ 	    continue;
+ 	
+ 	bitm = &bitc->metrics;
+ 	inkm = &inkc->metrics;
+ 
+ 	/* start address for the destination of bits for this char */
+ 
+ 	dstp = gd;
+ 
+ 	/* adjust destination and calculate shift offsets */
+ 	switch (mappad) {
+ 	case BitmapFormatImageRectMax:
+ 	    /* leave the first padded rows blank */
+ 	    dstp += dstbpr * (max_ascent - inkm->ascent);
+ 	    /* fall thru */
+ 	case BitmapFormatImageRectMaxWidth:
+ 	    dst_off = inkm->leftSideBearing - min_left;
+ 	    break;
+ 	case BitmapFormatImageRectMin:
+ 	    dst_off = 0;
+ 	    dstbpr = GLYPH_SIZE(inkc, scanlinepad);
+ 	    break;
+ 	}
+ 
+ 	srcbpr = GLYPH_SIZE (bitc, src_glyph_pad);
+ 	srcp = (unsigned char *) bitc->bits;
+ 
+ 	/* adjust source */
+ 	src_off = 0;
+ 	if (inkm != bitm)
+ 	{
+ 	    srcp += (bitm->ascent - inkm->ascent) * srcbpr;
+ 	    src_off = inkm->leftSideBearing - bitm->leftSideBearing;
+ 	}
+ 
+ 	dst_left_bytes = dst_off >> 3;
+ 	dst_off &= 7;
+ 	src_left_bytes = src_off >> 3;
+ 	src_off &= 7;
+ 
+ 	/* minimum of source/dest bytes per row */
+ 	width = srcbpr;
+ 	if (srcbpr > dstbpr)
+ 	    width = dstbpr;
+ 	/* extra bytes in source and dest for padding */
+ 	src_extra = srcbpr - width - src_left_bytes;
+ 	dst_extra = dstbpr - width - dst_left_bytes;
+ 	
+ #define MSBBitLeft(b,c)	((b) << (c))
+ #define MSBBitRight(b,c)	((b) >> (c))
+ #define LSBBitLeft(b,c)	((b) >> (c))
+ #define LSBBitRight(b,c)	((b) << (c))
+ 
+ 	if (dst_off == src_off)
+ 	{
+ 	    if (srcbpr == dstbpr && src_left_bytes == dst_left_bytes)
+ 	    {
+ 		r = (inkm->ascent + inkm->descent) * width;
SHAR_EOF
true || echo 'restore of fix-13 failed'
fi
echo 'End of  part 4'
echo 'File fix-13 is continued in part 5'
echo 5 > _shar_seq_.tmp
exit 0
-- 
---
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
