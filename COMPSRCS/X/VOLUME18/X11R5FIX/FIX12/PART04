Newsgroups: comp.sources.x
Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: rws@EXPO.LCS.MIT.EDU (Bob Scheifler)
Subject: v18i040: X11R5 public fix #12, Part04/05
Message-ID: <1992Jul20.155643.2712@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
References: <csx-18i037-X11R5-fix12@uunet.UU.NET>
Date: Mon, 20 Jul 1992 15:56:43 GMT
Approved: dcmartin@msi.com
Lines: 1500

Submitted-by: rws@EXPO.LCS.MIT.EDU (Bob Scheifler)
Posting-number: Volume 18, Issue 40
Archive-name: X11R5-fix12/part04

#!/bin/sh
# this is part.04 (part 4 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file fix-12 continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 4; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping fix-12'
else
echo 'x - continuing file fix-12'
sed 's/^X//' << 'SHAR_EOF' >> 'fix-12' &&
! 					}
X  					p_rect->x  = p_rect->y  = 0;
X  					p_rect->width   = ic->core.preedit_attr.area_needed.width;
X  					p_rect->height  = ic->core.preedit_attr.area_needed.height;
X  				} else {
! 				        *return_name = p->name;
X  				        return(False);
X  				}
X  			}
+ 			*((XRectangle **)(p->value)) = p_rect;
X  		} else if(strcmp(p->name, XNSpotLocation)==0) {
X  			if(im_preedit_flag) {
! 				if((p_point = (XPoint *)Xmalloc(sizeof(XPoint))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
X  				p_point->x = preedit_data->SpotLocation.x;
X  				p_point->y = preedit_data->SpotLocation.y;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_SPOTL_MASK) {
! 					if((p_point = (XPoint *)Xmalloc(sizeof(XPoint))) == NULL) {
! 						*return_name = p->name;
! 						return(False);
! 					}
X  					p_point->x = ic->core.preedit_attr.spot_location.x;
X  					p_point->y = ic->core.preedit_attr.spot_location.y;
X  				} else {
! 				        *return_name = p->name;
X  				        return(False);
X  				}
X  			}
+ 			*((XPoint **)(p->value)) = p_point;
X  		} else if(  strcmp(p->name, XNColormap)==0
X  		        || strcmp(p->name, XNStdColormap)==0) {
X  			if(im_preedit_flag) {
! 			         *((Colormap *)(p->value)) = preedit_data->Colormap;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_COLORMAP_MASK) {
! 				         *((Colormap *)(p->value)) = ic->core.preedit_attr.colormap;
X  				} else {
! 					*return_name = p->name;
X  					return(False);
X  				}
X  			}
X  		} else if(strcmp(p->name, XNBackground)==0) {
X  			if(im_preedit_flag) {
! 			         *((unsigned long *)(p->value)) = preedit_data->Background;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_BG_MASK) {
! 				         *((unsigned long *)(p->value)) = ic->core.preedit_attr.background;
X  				} else {
! 					*return_name = p->name;
X  					return(False);
X  				}
X  			}
X  		} else if(strcmp(p->name, XNForeground)==0) {
X  			if(im_preedit_flag) {
! 			         *((unsigned long *)(p->value)) = preedit_data->Foreground;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_FG_MASK) {
! 				         *((unsigned long *)(p->value)) = ic->core.preedit_attr.foreground;
X  				} else {
! 					*return_name = p->name;
X  					return(False);
X  				}
X  			}
X  		} else if(strcmp(p->name, XNBackgroundPixmap)==0) {
X  			if(im_preedit_flag) {
! 			         *((Pixmap *)(p->value)) = preedit_data->Bg_Pixmap;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_BGPIXMAP_MASK) {
! 				         *((Pixmap *)(p->value)) = ic->core.preedit_attr.background_pixmap;
X  				} else {
! 					*return_name = p->name;
X  					return(False);
X  				}
X  			}
X  		} else if(strcmp(p->name, XNFontSet)==0) {
X  			if(ic->ximp_icpart->proto_mask & XIMP_PRE_FONT_MASK) {
! 			         *((XFontSet *)(p->value)) = ic->core.preedit_attr.fontset;
X  			} else {
! 				*return_name = p->name;
X  				return(False);
X  			}
X  		} else if(strcmp(p->name, XNLineSpace)==0) {
X  			if(im_preedit_flag) {
! 			         *((int *)(p->value)) = preedit_data->LineSpacing;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_LINESP_MASK) {
! 				         *((int *)(p->value)) = ic->core.preedit_attr.line_space;
X  				} else {
! 					*return_name = p->name;
X  					return(False);
X  				}
X  			}
X  		} else if(strcmp(p->name, XNCursor)==0) {
X  			if(im_preedit_flag) {
! 			         *((Cursor *)(p->value)) = preedit_data->Cursor;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_CURSOR_MASK) {
! 				         *((Cursor *)(p->value)) = ic->core.preedit_attr.cursor;
X  				} else {
! 					*return_name = p->name;
X  					return(False);
X  				}
X  			}
X  		} else if(strcmp(p->name, XNPreeditStartCallback)==0) {
X  			if((int)ic->core.preedit_attr.callbacks.start.callback) {
! 
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
X  				p_callback->client_data =
X  					ic->core.preedit_attr.callbacks.start.client_data;
X  				p_callback->callback =
X  					ic->core.preedit_attr.callbacks.start.callback;
+ 				*((XIMCallback **)(p->value)) = p_callback;
X  			} else {
! 				*return_name = p->name;
X  				return(False);
X  			}
X  		} else if(strcmp(p->name, XNPreeditDrawCallback)==0) {
X  			if((int)ic->core.preedit_attr.callbacks.draw.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
X  				p_callback->client_data =
X  					ic->core.preedit_attr.callbacks.draw.client_data;
X  				p_callback->callback =
X  					ic->core.preedit_attr.callbacks.draw.callback;
+ 				*((XIMCallback **)(p->value)) = p_callback;
X  			} else {
! 				*return_name = p->name;
X  				return(False);
X  			}
X  		} else if(strcmp(p->name, XNPreeditDoneCallback)==0) {
X  			if((int)ic->core.preedit_attr.callbacks.done.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
X  				p_callback->client_data =
X  					ic->core.preedit_attr.callbacks.done.client_data;
X  				p_callback->callback =
X  					ic->core.preedit_attr.callbacks.done.callback;
+ 				*((XIMCallback **)(p->value)) = p_callback;
X  			} else {
! 				*return_name = p->name;
X  				return(False);
X  			}
X  		} else if(strcmp(p->name, XNPreeditCaretCallback)==0) {
X  			if((int)ic->core.preedit_attr.callbacks.caret.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
X  				p_callback->client_data =
X  					ic->core.preedit_attr.callbacks.caret.client_data;
X  				p_callback->callback =
X  					ic->core.preedit_attr.callbacks.caret.callback;
+ 				*((XIMCallback **)(p->value)) = p_callback;
X  			} else {
! 				*return_name = p->name;
X  				return(False);
X  			}
X  		}
X  	}
! 	if( preedit_data )
! 		XFree(preedit_data);
X  	return(True);
X  }
X  
***************
*** 389,408 ****
X  _Ximp_StatusGetAttributes(ic, vl, return_name)
X  	Ximp_XIC	 ic;
X  	XIMArg	 	*vl;
! 	char		*return_name;
X  {
X  	XIMArg		*p;
X  	XRectangle	*p_rect;
- 	XPoint		*p_point;
- 	long		*p_long;
X  	unsigned long	 mask;
X  	int		 im_status_flag = 0;
! 	int		 im_font_flag    = 0;
! 	Ximp_StatusPropRec	*status_data;
X  	XIMCallback 	*p_callback;
- 	XPointer	*xptr;
X  
! 	if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver) {
X  		for(mask = 0, p = vl; p->name != NULL; p++) {
X  			if(strcmp(p->name, XNArea)==0)
X  				mask |= XIMP_STS_AREA_MASK;
--- 413,428 ----
X  _Ximp_StatusGetAttributes(ic, vl, return_name)
X  	Ximp_XIC	 ic;
X  	XIMArg	 	*vl;
! 	char		**return_name;
X  {
X  	XIMArg		*p;
X  	XRectangle	*p_rect;
X  	unsigned long	 mask;
X  	int		 im_status_flag = 0;
! 	Ximp_StatusPropRec	*status_data = NULL;
X  	XIMCallback 	*p_callback;
X  
! 	if(((Ximp_XIM)ic->core.im)->ximp_impart->connectserver) {
X  		for(mask = 0, p = vl; p->name != NULL; p++) {
X  			if(strcmp(p->name, XNArea)==0)
X  				mask |= XIMP_STS_AREA_MASK;
***************
*** 422,429 ****
X  				mask |= XIMP_STS_LINESP_MASK;
X  			else if(strcmp(p->name, XNCursor)==0)
X  				mask |= XIMP_STS_CURSOR_MASK;
- 			else if(strcmp(p->name, XNFontSet)==0)
- 				im_font_flag = 1;
X  		}
X  		if(mask) {
X  			status_data = (Ximp_StatusPropRec *)_Ximp_GetRequestIM(ic, mask,
--- 442,447 ----
***************
*** 437,443 ****
X  	for(p = vl; p->name != NULL; p++) {
X  		if(strcmp(p->name, XNArea)==0) {
X  			if(im_status_flag) {
! 				p_rect = (XRectangle *)(p->value) ;
X  				p_rect->x       = status_data->Area.x;
X  				p_rect->y       = status_data->Area.y;
X  				p_rect->width   = status_data->Area.width;
--- 455,464 ----
X  	for(p = vl; p->name != NULL; p++) {
X  		if(strcmp(p->name, XNArea)==0) {
X  			if(im_status_flag) {
! 				if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
X  				p_rect->x       = status_data->Area.x;
X  				p_rect->y       = status_data->Area.y;
X  				p_rect->width   = status_data->Area.width;
***************
*** 444,604 ****
X  				p_rect->height  = status_data->Area.height;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREA_MASK) {
! 					p_rect = (XRectangle *)(p->value) ;
X  					p_rect->x       = ic->core.status_attr.area.x;
X  					p_rect->y       = ic->core.status_attr.area.y;
X  					p_rect->width   = ic->core.status_attr.area.width;
X  					p_rect->height  = ic->core.status_attr.area.height;
X  				} else {
! 				        return_name = p->name;
X  				        return(False);
X  				}
X  			}
X  		} else if(strcmp(p->name, XNAreaNeeded)==0) {
X  			if(im_status_flag) {
! 				p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle));
! 				xptr = (XPointer *)p->value;
! 				*xptr = (XPointer)p_rect;
X  				p_rect->x  = p_rect->y  = 0;
X  				p_rect->width   = status_data->AreaNeeded.width;
X  				p_rect->height  = status_data->AreaNeeded.height;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREANEED_MASK) {
! 					p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle));
! 					xptr = (XPointer *)p->value;
! 					*xptr = (XPointer)p_rect;
X  					p_rect->x  = p_rect->y  = 0;
X  					p_rect->width   = ic->core.status_attr.area_needed.width;
X  					p_rect->height  = ic->core.status_attr.area_needed.height;
X  				} else {
! 					return_name = p->name;
X  					return(False);
X  				}
X  			}
X  		} else if(  strcmp(p->name, XNColormap)==0
X  		        || strcmp(p->name, XNStdColormap)==0) {
X  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = status_data->Colormap;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_COLORMAP_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.status_attr.colormap;
X  				} else {
! 					return_name = p->name;
X  					return(False);
X  				}
X  			}
X  		} else if(strcmp(p->name, XNBackground)==0) {
X  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = status_data->Background;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_BG_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.status_attr.background;
X  				} else {
! 					return_name = p->name;
X  					return(False);
X  			        }
X  			}
X  		} else if(strcmp(p->name, XNForeground)==0) {
X  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = status_data->Foreground;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_FG_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.status_attr.foreground;
X  				} else {
! 					return_name = p->name;
X  					return(False);
X  				}
X  			}
X  		} else if(strcmp(p->name, XNBackgroundPixmap)==0) {
X  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = status_data->Bg_Pixmap;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_BGPIXMAP_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.status_attr.background_pixmap;
X  				} else {
! 					return_name = p->name;
X  					return(False);
X  			        }
X  			}
X  		} else if(strcmp(p->name, XNFontSet)==0) {
X  			if(ic->ximp_icpart->proto_mask & XIMP_STS_FONT_MASK) {
! 			         p_long = (long *)(p->value);
! 				*p_long = (long)ic->core.status_attr.fontset;
X  			} else {
! 				return_name = p->name;
X  				return(False);
X  			}
X  		} else if(strcmp(p->name, XNLineSpace)==0) {
X  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = status_data->LineSpacing;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_LINESP_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.status_attr.line_space;
X  				} else {
! 					return_name = p->name;
X  					return(False);
X  				}
- 
X  			}
X  		} else if(strcmp(p->name, XNCursor)==0) {
X  			if(im_status_flag) {
! 			         p_long = (long *)(p->value);
! 				*p_long = status_data->Cursor;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_CURSOR_MASK) {
! 				         p_long = (long *)(p->value);
! 					*p_long = ic->core.status_attr.cursor;
X  				} else { 
! 					return_name = p->name;
X  					return(False);
X  			        }
X  			}
X  		} else if(strcmp(p->name, XNStatusStartCallback)==0) {
X  			if((int)ic->core.status_attr.callbacks.start.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
X  				p_callback->client_data =
X  					ic->core.status_attr.callbacks.start.client_data;
X  				p_callback->callback =
X  					ic->core.status_attr.callbacks.start.callback;
X  			} else {
! 				return_name = p->name;
! 				break;
X  			}
X  		} else if(strcmp(p->name, XNStatusDrawCallback)==0) {
X  			if((int)ic->core.status_attr.callbacks.draw.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
X  				p_callback->client_data =
X  					ic->core.status_attr.callbacks.draw.client_data;
X  				p_callback->callback =
X  					ic->core.status_attr.callbacks.draw.callback;
X  			} else {
! 				return_name = p->name;
! 				break;
X  			}
X  		} else if(strcmp(p->name, XNStatusDoneCallback)==0) {
X  			if((int)ic->core.status_attr.callbacks.done.callback) {
! 			        p_callback = (XIMCallback *)(p->value) ;
X  				p_callback->client_data =
X  					ic->core.status_attr.callbacks.done.client_data;
X  				p_callback->callback =
X  					ic->core.status_attr.callbacks.done.callback;
X  			} else {
! 				return_name = p->name;
! 				break;
X  			}
X  		}
X  	}
! 	XFree(status_data);
X  	return(True);
X  }
X  
--- 465,631 ----
X  				p_rect->height  = status_data->Area.height;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREA_MASK) {
! 					if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 						*return_name = p->name;
! 						return(False);
! 					}
X  					p_rect->x       = ic->core.status_attr.area.x;
X  					p_rect->y       = ic->core.status_attr.area.y;
X  					p_rect->width   = ic->core.status_attr.area.width;
X  					p_rect->height  = ic->core.status_attr.area.height;
X  				} else {
! 				        *return_name = p->name;
X  				        return(False);
X  				}
X  			}
+ 			*((XRectangle **)(p->value)) = p_rect;
X  		} else if(strcmp(p->name, XNAreaNeeded)==0) {
X  			if(im_status_flag) {
! 				if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
X  				p_rect->x  = p_rect->y  = 0;
X  				p_rect->width   = status_data->AreaNeeded.width;
X  				p_rect->height  = status_data->AreaNeeded.height;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREANEED_MASK) {
! 					if((p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle))) == NULL) {
! 						*return_name = p->name;
! 						return(False);
! 					}
X  					p_rect->x  = p_rect->y  = 0;
X  					p_rect->width   = ic->core.status_attr.area_needed.width;
X  					p_rect->height  = ic->core.status_attr.area_needed.height;
X  				} else {
! 					*return_name = p->name;
X  					return(False);
X  				}
X  			}
+ 			*((XRectangle **)(p->value)) = p_rect;
X  		} else if(  strcmp(p->name, XNColormap)==0
X  		        || strcmp(p->name, XNStdColormap)==0) {
X  			if(im_status_flag) {
! 			         *((Colormap *)(p->value)) = status_data->Colormap;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_COLORMAP_MASK) {
! 				         *((Colormap *)(p->value)) = ic->core.status_attr.colormap;
X  				} else {
! 					*return_name = p->name;
X  					return(False);
X  				}
X  			}
X  		} else if(strcmp(p->name, XNBackground)==0) {
X  			if(im_status_flag) {
! 			         *((unsigned long *)(p->value)) = status_data->Background;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_BG_MASK) {
! 				         *((unsigned long *)(p->value)) = ic->core.status_attr.background;
X  				} else {
! 					*return_name = p->name;
X  					return(False);
X  			        }
X  			}
X  		} else if(strcmp(p->name, XNForeground)==0) {
X  			if(im_status_flag) {
! 			         *((unsigned long *)(p->value)) = status_data->Foreground;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_FG_MASK) {
! 				         *((unsigned long *)(p->value)) = ic->core.status_attr.foreground;
X  				} else {
! 					*return_name = p->name;
X  					return(False);
X  				}
X  			}
X  		} else if(strcmp(p->name, XNBackgroundPixmap)==0) {
X  			if(im_status_flag) {
! 			         *((Pixmap *)(p->value)) = status_data->Bg_Pixmap;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_BGPIXMAP_MASK) {
! 				         *((Pixmap *)(p->value)) = ic->core.status_attr.background_pixmap;
X  				} else {
! 					*return_name = p->name;
X  					return(False);
X  			        }
X  			}
X  		} else if(strcmp(p->name, XNFontSet)==0) {
X  			if(ic->ximp_icpart->proto_mask & XIMP_STS_FONT_MASK) {
! 			         *((XFontSet *)(p->value)) = ic->core.status_attr.fontset;
X  			} else {
! 				*return_name = p->name;
X  				return(False);
X  			}
X  		} else if(strcmp(p->name, XNLineSpace)==0) {
X  			if(im_status_flag) {
! 			         *((int *)(p->value)) = status_data->LineSpacing;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_LINESP_MASK) {
! 				         *((int *)(p->value)) = ic->core.status_attr.line_space;
X  				} else {
! 					*return_name = p->name;
X  					return(False);
X  				}
X  			}
X  		} else if(strcmp(p->name, XNCursor)==0) {
X  			if(im_status_flag) {
! 			         *((Cursor *)(p->value)) = status_data->Cursor;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_CURSOR_MASK) {
! 				         *((Cursor *)(p->value)) = ic->core.status_attr.cursor;
X  				} else { 
! 					*return_name = p->name;
X  					return(False);
X  			        }
X  			}
X  		} else if(strcmp(p->name, XNStatusStartCallback)==0) {
X  			if((int)ic->core.status_attr.callbacks.start.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
X  				p_callback->client_data =
X  					ic->core.status_attr.callbacks.start.client_data;
X  				p_callback->callback =
X  					ic->core.status_attr.callbacks.start.callback;
+ 				*((XIMCallback **)(p->value)) = p_callback;
X  			} else {
! 				*return_name = p->name;
! 				return(False);
X  			}
X  		} else if(strcmp(p->name, XNStatusDrawCallback)==0) {
X  			if((int)ic->core.status_attr.callbacks.draw.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
X  				p_callback->client_data =
X  					ic->core.status_attr.callbacks.draw.client_data;
X  				p_callback->callback =
X  					ic->core.status_attr.callbacks.draw.callback;
+ 				*((XIMCallback **)(p->value)) = p_callback;
X  			} else {
! 				*return_name = p->name;
! 				return(False);
X  			}
X  		} else if(strcmp(p->name, XNStatusDoneCallback)==0) {
X  			if((int)ic->core.status_attr.callbacks.done.callback) {
! 				if((p_callback = (XIMCallback *)Xmalloc(sizeof(XIMCallback))) == NULL) {
! 					*return_name = p->name;
! 					return(False);
! 				}
X  				p_callback->client_data =
X  					ic->core.status_attr.callbacks.done.client_data;
X  				p_callback->callback =
X  					ic->core.status_attr.callbacks.done.callback;
+ 				*((XIMCallback **)(p->value)) = p_callback;
X  			} else {
! 				*return_name = p->name;
! 				return(False);
X  			}
X  		}
X  	}
! 	if( status_data )
! 		XFree(status_data);
X  	return(True);
X  }
X  
***************
*** 612,617 ****
--- 639,658 ----
X  }
X  #endif /* XIMP_SIGNAL */
X  
+ static Bool Check_Message(display, event, arg)
+     Display *display;
+     XEvent  *event;
+     XPointer arg;
+ {
+     if ( event->type == ClientMessage && 
+ 	 event->xclient.message_type == 
+ 	 ((Ximp_XIM)arg)->ximp_impart->improtocol_id )
+ 	return True;
+     else
+ 	return False;
+ }
+ 
+ 
X  static XPointer
X  _Ximp_GetRequestIM(ic, mask, get_atom_id, atom_id)
X  	Ximp_XIC	 ic;
***************
*** 637,655 ****
X  #endif /* XIMP_SIGNAL */
X  
X  	while(_time_flag != 1) {
! 		if( (XCheckTypedEvent(ic->core.im->core.display, ClientMessage, &event)) == False) {
X  #ifdef XIMP_SIGNAL
- 			sleep(1);
- #endif /* XIMP_SIGNAL */
- 			continue;
- 		}
- 		if(event.xclient.message_type == ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id) {
- #ifdef XIMP_SIGNAL
X  			alarm(0);
X  #endif /* XIMP_SIGNAL */
X  			break;
X  		} else {
! 			XPutBackEvent(ic->core.im->core.display, &event);
X  			continue;
X  		}
X  	}
--- 678,693 ----
X  #endif /* XIMP_SIGNAL */
X  
X  	while(_time_flag != 1) {
! 		if (XCheckIfEvent(ic->core.im->core.display, &event, 
! 			Check_Message, (XPointer)ic->core.im) ) {
X  #ifdef XIMP_SIGNAL
X  			alarm(0);
X  #endif /* XIMP_SIGNAL */
X  			break;
X  		} else {
! #ifdef XIMP_SIGNAL
! 			sleep(1);
! #endif /* XIMP_SIGNAL */
X  			continue;
X  		}
X  	}
*** /tmp/d17338	Sun May  3 18:48:42 1992
--- mit/lib/X/Ximp/XimpICS.c	Sun May  3 18:48:40 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpICS.c,v 1.2 91/10/07 17:48:43 rws Exp $ */
X  /******************************************************************
X  
!               Copyright 1991, by FUJITSU LIMITED
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpICS.c,v 1.3 92/04/14 13:29:14 rws Exp $ */
X  /******************************************************************
X  
!               Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporaion
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
***************
*** 8,29 ****
X  provided that the above copyright notice appear in all copies and
X  that both that copyright notice and this permission notice appear
X  in supporting documentation, and that the name of FUJITSU LIMITED
! not be used in advertising or publicity pertaining to distribution
! of the software without specific, written prior permission.
! FUJITSU LIMITED makes no representations about the suitability of
! this software for any purpose.  It is provided "as is" without
! express or implied warranty.
X  
! FUJITSU LIMITED DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
! INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
! IN NO EVENT SHALL FUJITSU LIMITED BE LIABLE FOR ANY SPECIAL, INDIRECT
! OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
! OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
! OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
X  OR PERFORMANCE OF THIS SOFTWARE.
X  
X    Author: Takashi Fujiwara     FUJITSU LIMITED 
!                                fujiwara@a80.tech.yk.fujitsu.co.jp
X  
X  ******************************************************************/
X  
--- 9,32 ----
X  provided that the above copyright notice appear in all copies and
X  that both that copyright notice and this permission notice appear
X  in supporting documentation, and that the name of FUJITSU LIMITED
! and Sony Corporaion not be used in advertising or publicity
! pertaining to distribution of the software without specific,
! written prior permission.
! FUJITSU LIMITED and Sony Corporaion make no representations about
! the suitability of this software for any purpose.  It is provided
! "as is" without express or implied warranty.
X  
! FUJITSU LIMITED AND SONY CORPORATION DISCLAIM ALL WARRANTIES WITH
! REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND
! SONY CORPORATION BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
! DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
! OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
! TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
X  OR PERFORMANCE OF THIS SOFTWARE.
X  
X    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporaion
X  
X  ******************************************************************/
X  
***************
*** 43,48 ****
--- 46,52 ----
X  extern void		_Ximp_SetStatusAtr();
X  extern void		_Ximp_SetStatusFont();
X  extern void		_Ximp_IM_SendMessage();
+ extern Bool		_Ximp_XimFilter_Keypress();
X  
X  static Bool		_Ximp_PreSetAttributes();
X  static Bool		_Ximp_StatusSetAttributes();
***************
*** 56,77 ****
X  	char		*ret;
X  	int		 change_mask = 0;
X  
! 	ret = _Ximp_SetICValueData(ic, values, XIMP_SET_IC, &change_mask);
X  
X  	if(   (ic->ximp_icpart->value_mask & XIMP_RES_NAME)
X  	   || (ic->ximp_icpart->value_mask & XIMP_RES_CLASS) )
X  		_Ximp_SetValue_Resource(ic, &change_mask);
X  
! 	if(ic->ximp_icpart->icid == NULL)
X  		return(ret);
X  
! 	if(change_mask == XIMP_PRE_SPOTL_MASK) {
!  		_Ximp_IM_SendMessage(ic, XIMP_MOVE,
X  				ic->ximp_icpart->preedit_attr.SpotLocation.x,
X  				ic->ximp_icpart->preedit_attr.SpotLocation.y,
X  				NULL);
! 		return(ret);
X  		}
X  	if(change_mask & XIMP_PROP_FOCUS)
X  		_Ximp_SetFocusWindow(ic);
X  	if(!(   (ic->core.input_style & XIMPreeditCallbacks)
--- 60,100 ----
X  	char		*ret;
X  	int		 change_mask = 0;
X  
! 	if((ret = _Ximp_SetICValueData(ic, values, XIMP_SET_IC, &change_mask)))
! 		return(ret);
X  
X  	if(   (ic->ximp_icpart->value_mask & XIMP_RES_NAME)
X  	   || (ic->ximp_icpart->value_mask & XIMP_RES_CLASS) )
X  		_Ximp_SetValue_Resource(ic, &change_mask);
X  
! 	if(ic->ximp_icpart->icid == NULL) {
! 		if(change_mask & XIMP_PROP_FOCUS) {
! 			if(ic->ximp_icpart->filter_mode & 0x1) {
! 				_XUnregisterFilter (ic->core.im->core.display,
! 						ic->ximp_icpart->back_focus_win,
! 						_Ximp_XimFilter_Keypress,
! 						(XPointer)ic);
! 				}
! 			_XRegisterFilterByType (ic->core.im->core.display,
! 						ic->core.focus_window,
! 						KeyPress, KeyPress,
! 						_Ximp_XimFilter_Keypress,
! 						(XPointer)ic);
! 			ic->ximp_icpart->filter_mode |= 0x1;
! 			}
X  		return(ret);
+ 		}
X  
! 	if(ic->core.input_style & XIMPreeditPosition) {
! 		if(change_mask == XIMP_PRE_SPOTL_MASK) {
! 			if(ic->ximp_icpart->input_mode)
! 			    _Ximp_IM_SendMessage(ic, XIMP_MOVE,
X  				ic->ximp_icpart->preedit_attr.SpotLocation.x,
X  				ic->ximp_icpart->preedit_attr.SpotLocation.y,
X  				NULL);
! 			return(ret);
X  		}
+ 	}
X  	if(change_mask & XIMP_PROP_FOCUS)
X  		_Ximp_SetFocusWindow(ic);
X  	if(!(   (ic->core.input_style & XIMPreeditCallbacks)
***************
*** 94,100 ****
X  	else {
X  		change_mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
X  		}
!  	_Ximp_IM_SendMessage(ic, XIMP_SETVALUE, change_mask, NULL, NULL);
X  	return(ret);
X  	}
X  
--- 117,124 ----
X  	else {
X  		change_mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
X  		}
! 	if(change_mask)
!  		_Ximp_IM_SendMessage(ic, XIMP_SETVALUE, change_mask, NULL, NULL);
X  	return(ret);
X  	}
X  
***************
*** 119,126 ****
X  			}
X  		else if(strcmp(p->name, XNClientWindow)==0) {
X  			if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
! 				ic->core.client_window = (Window)p->value;
! 				ic->ximp_icpart->value_mask |= XIMP_CLIENT_WIN;
X  				}
X  			else {
X  				return_name = p->name;
--- 143,168 ----
X  			}
X  		else if(strcmp(p->name, XNClientWindow)==0) {
X  			if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
! 				if(mode == XIMP_SET_IC && (ic->ximp_icpart->icid)) {
! 					_Ximp_IM_SendMessage(ic, XIMP_DESTROY, NULL, NULL, NULL);
! 					XDestroyWindow(ic->core.im->core.display,
! 						       ic->core.client_window);
! 					ic->core.client_window = (Window)p->value;
! 					ic->ximp_icpart->value_mask |= XIMP_CLIENT_WIN;
! 					if(_Ximp_SetOpenXIMP(ic, mode) == False) {
! 						return_name = p->name;
! 						break;
! 						}
! 					*change_mask = NULL;
! 					}
! 				else { /* XIMP_CREATE_IC | (XIMP_SET_IC && XIMP_START_IC) */
! 					ic->core.client_window = (Window)p->value;
! 					ic->ximp_icpart->value_mask |= XIMP_CLIENT_WIN;
! 					if(!(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK)) {
! 						ic->core.focus_window = ic->core.client_window;
! 						ic->ximp_icpart->proto_mask |= XIMP_FOCUS_WIN_MASK;
! 						}
! 					}
X  				}
X  			else {
X  				return_name = p->name;
***************
*** 151,156 ****
--- 193,199 ----
X  					     new_focus_window,
X  					     dummy_mask);
X  				}
+ 			ic->ximp_icpart->back_focus_win = ic->core.focus_window;
X  			ic->core.focus_window = (Window)p->value;
X  			ic->ximp_icpart->proto_mask |= XIMP_FOCUS_WIN_MASK;
X  			*change_mask                |= XIMP_FOCUS_WIN_MASK;
***************
*** 282,287 ****
--- 325,332 ----
X  		else if(strcmp(p->name, XNFontSet)==0) {
X  			ic->core.preedit_attr.fontset = (XFontSet)p->value;
X  			if(p->value != NULL) {
+ 				if(ic->ximp_icpart->preedit_font)
+ 	    				Xfree(ic->ximp_icpart->preedit_font);
X  				list_ret = XFontsOfFontSet(
X  					ic->core.preedit_attr.fontset,
X  					&struct_list, &name_list);
***************
*** 288,294 ****
X  				for(i = 0, len = 0; i < list_ret; i++) {
X  					len += strlen(name_list[i]);
X  					}
! 				tmp = Xmalloc(len + i);
X  				tmp[0] = NULL;
X  				for(i = 0; i < list_ret; i++) {
X  					strcat(tmp, name_list[i]);
--- 333,339 ----
X  				for(i = 0, len = 0; i < list_ret; i++) {
X  					len += strlen(name_list[i]);
X  					}
! 				tmp = Xmalloc(len + i + 1);
X  				tmp[0] = NULL;
X  				for(i = 0; i < list_ret; i++) {
X  					strcat(tmp, name_list[i]);
***************
*** 321,326 ****
--- 366,372 ----
X  				((XIMCallback *)p->value)->client_data;
X  			ic->core.preedit_attr.callbacks.start.callback =
X  				((XIMCallback *)p->value)->callback;
+ 			ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
X  			}
X  		else if(strcmp(p->name, XNPreeditDoneCallback)==0) {
X  			ic->core.preedit_attr.callbacks.done.client_data =
***************
*** 327,332 ****
--- 373,379 ----
X  				((XIMCallback *)p->value)->client_data;
X  			ic->core.preedit_attr.callbacks.done.callback =
X  				((XIMCallback *)p->value)->callback;
+ 			ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
X  			}
X  		else if(strcmp(p->name, XNPreeditDrawCallback)==0) {
X  			ic->core.preedit_attr.callbacks.draw.client_data =
***************
*** 333,338 ****
--- 380,386 ----
X  				((XIMCallback *)p->value)->client_data;
X  			ic->core.preedit_attr.callbacks.draw.callback =
X  				((XIMCallback *)p->value)->callback;
+ 			ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
X  			}
X  		else if(strcmp(p->name, XNPreeditCaretCallback)==0) {
X  			ic->core.preedit_attr.callbacks.caret.client_data =
***************
*** 339,344 ****
--- 387,393 ----
X  				((XIMCallback *)p->value)->client_data;
X  			ic->core.preedit_attr.callbacks.caret.callback =
X  				((XIMCallback *)p->value)->callback;
+ 			ic->ximp_icpart->value_mask |= XIMP_PRE_CALLBAK;
X  			}
X  		}
X  	return(True);
***************
*** 423,428 ****
--- 472,479 ----
X  		else if(strcmp(p->name, XNFontSet)==0) {
X  			ic->core.status_attr.fontset = (XFontSet)p->value;
X  			if (p->value != NULL) {
+ 				if(ic->ximp_icpart->status_font)
+ 	    				Xfree(ic->ximp_icpart->status_font);
X  				list_ret = XFontsOfFontSet(
X  					ic->core.status_attr.fontset,
X  					&struct_list, &name_list);
***************
*** 429,435 ****
X  				for(i = 0, len = 0; i < list_ret; i++) {
X  					len += strlen(name_list[i]);
X  					}
! 				tmp = Xmalloc(len + i);
X  				tmp[0] = NULL;
X  				for(i = 0; i < list_ret; i++) {
X  					strcat(tmp, name_list[i]);
--- 480,486 ----
X  				for(i = 0, len = 0; i < list_ret; i++) {
X  					len += strlen(name_list[i]);
X  					}
! 				tmp = Xmalloc(len + i + 1);
X  				tmp[0] = NULL;
X  				for(i = 0; i < list_ret; i++) {
X  					strcat(tmp, name_list[i]);
***************
*** 454,461 ****
X  		else if(strcmp(p->name, XNCursor)==0) {
X  			ic->core.status_attr.cursor = (Cursor)p->value;
X  			attr->Cursor = ic->core.status_attr.cursor;
! 			ic->ximp_icpart->proto_mask |= XIMP_PRE_CURSOR_MASK;
! 			*change_mask                |= XIMP_PRE_CURSOR_MASK;
X  			}
X  		else if(strcmp(p->name, XNStatusStartCallback)==0) {
X  			ic->core.status_attr.callbacks.start.client_data =
--- 505,512 ----
X  		else if(strcmp(p->name, XNCursor)==0) {
X  			ic->core.status_attr.cursor = (Cursor)p->value;
X  			attr->Cursor = ic->core.status_attr.cursor;
! 			ic->ximp_icpart->proto_mask |= XIMP_STS_CURSOR_MASK;
! 			*change_mask                |= XIMP_STS_CURSOR_MASK;
X  			}
X  		else if(strcmp(p->name, XNStatusStartCallback)==0) {
X  			ic->core.status_attr.callbacks.start.client_data =
***************
*** 462,467 ****
--- 513,519 ----
X  				((XIMCallback *)p->value)->client_data;
X  			ic->core.status_attr.callbacks.start.callback =
X  				((XIMCallback *)p->value)->callback;
+ 			ic->ximp_icpart->value_mask |= XIMP_STS_CALLBAK;
X  			}
X  		else if(strcmp(p->name, XNStatusDoneCallback)==0) {
X  			ic->core.status_attr.callbacks.done.client_data =
***************
*** 468,473 ****
--- 520,526 ----
X  				((XIMCallback *)p->value)->client_data;
X  			ic->core.status_attr.callbacks.done.callback =
X  				((XIMCallback *)p->value)->callback;
+ 			ic->ximp_icpart->value_mask |= XIMP_STS_CALLBAK;
X  			}
X  		else if(strcmp(p->name, XNStatusDrawCallback)==0) {
X  			ic->core.status_attr.callbacks.draw.client_data =
***************
*** 474,479 ****
--- 527,533 ----
X  				((XIMCallback *)p->value)->client_data;
X  			ic->core.status_attr.callbacks.draw.callback =
X  				((XIMCallback *)p->value)->callback;
+ 			ic->ximp_icpart->value_mask |= XIMP_STS_CALLBAK;
X  			}
X  		}
X  	return(True);
*** /tmp/d17360	Sun May  3 18:48:55 1992
--- mit/lib/X/Ximp/XimpMPer.c	Sun May  3 18:48:53 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpMPer.c,v 1.1 91/07/09 17:37:12 rws Exp $ */
X  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
X   *
X   * Permission to use, copy, modify, distribute, and sell this software and its
X   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpMPer.c,v 1.2 92/04/14 13:29:43 rws Exp $ */
X  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
X   *
X   * Permission to use, copy, modify, distribute, and sell this software and its
X   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 29,35 ****
X  
X  /******************************************************************
X  
!               Copyright 1991, by FUJITSU LIMITED
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
--- 29,35 ----
X  
X  /******************************************************************
X  
!               Copyright 1991, 1992 by FUJITSU LIMITED
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17382	Sun May  3 18:49:06 1992
--- mit/lib/X/Ximp/XimpMPrTxt.c	Sun May  3 18:49:04 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpMPrTxt.c,v 1.2 91/10/07 17:50:17 rws Exp $ */
X  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
X   *
X   * Permission to use, copy, modify, distribute, and sell this software and its
X   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpMPrTxt.c,v 1.3 92/04/14 13:29:46 rws Exp $ */
X  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
X   *
X   * Permission to use, copy, modify, distribute, and sell this software and its
X   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
X  
X  /******************************************************************
X  
!               Copyright 1991, by FUJITSU LIMITED
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
X  
X  /******************************************************************
X  
!               Copyright 1991, 1992 by FUJITSU LIMITED
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
***************
*** 109,116 ****
X      buf_ptr = buf;
X      for (i = 0; i < count; i++) {
X  	list[i] = str_ptr;
! 	strcpy(str_ptr, buf_ptr);
! 	tmp_len = strlen(str_ptr) + 1;
X  	str_ptr += tmp_len;
X  	buf_ptr += tmp_len;
X      }
--- 109,116 ----
X      buf_ptr = buf;
X      for (i = 0; i < count; i++) {
X  	list[i] = str_ptr;
! 	strcpy((char *)str_ptr, (char *)buf_ptr);
! 	tmp_len = strlen((char *)str_ptr) + 1;
X  	str_ptr += tmp_len;
X  	buf_ptr += tmp_len;
X      }
*** /tmp/d17404	Sun May  3 18:49:19 1992
--- mit/lib/X/Ximp/XimpMTxtPr.c	Sun May  3 18:49:16 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpMTxtPr.c,v 1.2 91/10/07 17:50:20 rws Exp $ */
X  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
X   *
X   * Permission to use, copy, modify, distribute, and sell this software and its
X   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpMTxtPr.c,v 1.3 92/04/14 13:29:49 rws Exp $ */
X  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
X   *
X   * Permission to use, copy, modify, distribute, and sell this software and its
X   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
X  
X  /******************************************************************
X  
!               Copyright 1991, by FUJITSU LIMITED
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
X  
X  /******************************************************************
X  
!               Copyright 1991, 1992 by FUJITSU LIMITED
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17426	Sun May  3 18:49:30 1992
--- mit/lib/X/Ximp/XimpPrTxt.c	Sun May  3 18:49:27 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpPrTxt.c,v 1.2 91/10/07 17:50:23 rws Exp $ */
X  /*
!  * Copyright 1990, 1991 by TOSHIBA Corp.
!  * Copyright 1990, 1991 by SORD Computer Corp.
X   *
X   * Permission to use, copy, modify, distribute, and sell this software and its
X   * documentation for any purpose is hereby granted without fee, provided that
--- 1,7 ----
! /* $XConsortium: XimpPrTxt.c,v 1.3 92/04/14 13:29:53 rws Exp $ */
X  /*
!  * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
!  * Copyright 1990, 1991, 1992 by SORD Computer Corp.
X   *
X   * Permission to use, copy, modify, distribute, and sell this software and its
X   * documentation for any purpose is hereby granted without fee, provided that
***************
*** 28,34 ****
X  
X  /******************************************************************
X  
!               Copyright 1991, by FUJITSU LIMITED
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
--- 28,34 ----
X  
X  /******************************************************************
X  
!               Copyright 1991, 1992 by FUJITSU LIMITED
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
*** /tmp/d17448	Sun May  3 18:49:43 1992
--- mit/lib/X/Ximp/XimpRm.c	Sun May  3 18:49:39 1992
***************
*** 1,7 ****
! /* $XConsortium: XimpRm.c,v 1.3 92/03/03 11:03:30 rws Exp $ */
X  /******************************************************************
X  
!               Copyright 1991, by FUJITSU LIMITED
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpRm.c,v 1.4 92/04/14 13:29:56 rws Exp $ */
X  /******************************************************************
X  
!               Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporaion
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
***************
*** 8,29 ****
X  provided that the above copyright notice appear in all copies and
X  that both that copyright notice and this permission notice appear
X  in supporting documentation, and that the name of FUJITSU LIMITED
! not be used in advertising or publicity pertaining to distribution
! of the software without specific, written prior permission.
! FUJITSU LIMITED makes no representations about the suitability of
! this software for any purpose.  It is provided "as is" without
! express or implied warranty.
X  
! FUJITSU LIMITED DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
! INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
! IN NO EVENT SHALL FUJITSU LIMITED BE LIABLE FOR ANY SPECIAL, INDIRECT
! OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
! OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
! OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
X  OR PERFORMANCE OF THIS SOFTWARE.
X  
X    Author: Takashi Fujiwara     FUJITSU LIMITED 
!                                fujiwara@a80.tech.yk.fujitsu.co.jp
X  
X  ******************************************************************/
X  
--- 9,32 ----
X  provided that the above copyright notice appear in all copies and
X  that both that copyright notice and this permission notice appear
X  in supporting documentation, and that the name of FUJITSU LIMITED
! and Sony Corporaion not be used in advertising or publicity
! pertaining to distribution of the software without specific,
! written prior permission.
! FUJITSU LIMITED and Sony Corporation make no representations about
! the suitability of this software for any purpose.  It is provided
! "as is" without express or implied warranty.
X  
! FUJITSU LIMITED AND SONY CORPORATION DISCLAIM ALL WARRANTIES WITH
! REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND
! SONY CORPORATION BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
! DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
! OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
! TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
X  OR PERFORMANCE OF THIS SOFTWARE.
X  
X    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporaion
X  
X  ******************************************************************/
X  
***************
*** 52,63 ****
X  		strcpy(res_class, "*");
X  	else	{
X  		strcpy(res_class, im->core.res_class);
! 		strcat(res_name, ".");
X  		}
X  	strcat(res_name, "ximp.");
X  	strcat(res_class, "Ximp.");
X  	}
X  
X  Bool
X  _Ximp_OpenIM_Resource(im)
X  	Ximp_XIM	 im;
--- 55,174 ----
X  		strcpy(res_class, "*");
X  	else	{
X  		strcpy(res_class, im->core.res_class);
! 		strcat(res_class, ".");
X  		}
X  	strcat(res_name, "ximp.");
X  	strcat(res_class, "Ximp.");
X  	}
X  
+ 
+ #ifndef	isalnum
+ #define	isalnum(c)	\
+     (('0' <= (c) && (c) <= '9')  || \
+      ('A' <= (c) && (c) <= 'Z')  || \
+      ('a' <= (c) && (c) <= 'z'))
+ #endif
+ 
+ static void	_Ximp_parse( im, event )
+ Ximp_XIM	 im;
+ char		*event;
+ {
+     static Ximp_Key	key;
+     char		*modifier, *detail;
+     char		*ss;
+     int			ii;
+     Bool		exclamation, tilde;
+     Ximp_KeyList	*keylist;
+     static struct {
+ 	char	*name;
+ 	int	len;
+ 	long	mask;
+     } mod[] = {
+ 	{ "Ctrl",	4,	ControlMask	},
+ 	{ "Lock",	4,	LockMask	},
+ 	{ "Caps",	4,	LockMask	},
+ 	{ "Shift",	5,	ShiftMask	},
+ 	{ "Alt",	3,	Mod1Mask	},
+ 	{ "Meta",	4,	Mod1Mask	},
+ 	{ NULL,		0,	0		}};
+     extern char		*_Ximp_Strstr();
+ #define	AllMask	(ControlMask | LockMask | ShiftMask | Mod1Mask)
+ 
+     if( (ss = _Ximp_Strstr( event, "<Key>" )) == NULL )
+ 	return;
+     detail = ss + 5;
+     *ss = NULL;
+ 
+     modifier = event;
+     key.modifier = 0;
+     key.modifier_mask = 0;
+     key.keysym = XK_VoidSymbol;
+     exclamation = False;
+     do {
+ 	while( *modifier == ' '  ||  *modifier == '\t' )
+ 	    modifier++;
+ 	if( *modifier == NULL )
+ 	    break;
+ 	if( strncmp( modifier, "None", 4 ) == 0 ) {
+ 	    if( key.modifier_mask != 0  ||  exclamation )
+ 		return;
+ 	    key.modifier_mask = AllMask;
+ 	    modifier += 4;
+ 	}
+ 	else {
+ 	    if( *modifier == '!' ) {
+ 		if( key.modifier_mask != 0  ||  exclamation )
+ 		    return;
+ 		key.modifier_mask = AllMask;
+ 		exclamation = True;
+ 		modifier++;
+ 		continue;
+ 	    }
+ 	    if( (tilde = (*modifier == '~')) ) {
+ 		modifier++;
+ 		while( *modifier == ' '  ||  *modifier == '\t' )
+ 		    modifier++;
+ 	    }
+ 	    for( ii = 0; mod[ii].name != NULL; ii++ ) {
+ 		if( strncmp( modifier, mod[ii].name, mod[ii].len ) == 0 ) {
+ 		    key.modifier_mask |= mod[ii].mask;
+ 		    if( !tilde )
+ 			key.modifier |= mod[ii].mask;
+ 		    modifier += mod[ii].len;
+ 		    break;
+ 		}
+ 	    }
+ 	}
+ 	if( mod[ii].name == NULL )
+ 	    return;
+     } while( *modifier != NULL );
+ 
+     while( *detail == ' '  ||  *detail == '\t' )
+ 	detail++;
+     for( ss = detail; isalnum(*ss)  ||  *ss == '_'; ss++ );
+     *ss = NULL;
+     if( (key.keysym = XStringToKeysym( detail )) != NoSymbol ) {
+ 	if( !(keylist = im->ximp_impart->process_start_keys) ) {
+ 	    if( (keylist = (Ximp_KeyList *)Xcalloc(1, sizeof(Ximp_KeyList))) == NULL )
+ 		return;
+ 	    if((keylist->keys_list = (Ximp_Key *)Xmalloc(sizeof(Ximp_Key))) == NULL) {
+ 		Xfree( keylist );
+ 		return;
+ 	    }
+ 	}
+ 	else {
+ 	    Ximp_Key	*keys_list;
+ 	    if( (keys_list = (Ximp_Key *)Xrealloc(keylist->keys_list, sizeof(Ximp_Key) * (keylist->count_keys + 1))) == NULL )
+ 		return;
+ 	    keylist->keys_list = keys_list;
+ 	}
+ 	keylist->keys_list[keylist->count_keys] = key;
+ 	keylist->count_keys++;
+ 	im->ximp_impart->process_start_keys = keylist;
+     }
+ }
+ 
+ 
X  Bool
X  _Ximp_OpenIM_Resource(im)
X  	Ximp_XIM	 im;
***************
*** 68,73 ****
--- 179,185 ----
X  	XrmValue	 value;
X  	Bool		 ret = False;
X  	KeySym		 keysym = NoSymbol;
+ 	Ximp_KeyList	*keylist;
X  
X  	if(im->core.rdb == NULL)
X  		return(ret);
***************
*** 87,97 ****
X  				str_type, &value) == True) { 
X  				keysym = XStringToKeysym(value.addr);
X  				}
! 			if(keysym == NoSymbol)
! 				ret = False;
! 			else {
! 				im->ximp_impart->def_startkeysym = keysym;
! 				ret = True;
X  				}
X  			}
X  		}
--- 199,246 ----
X  				str_type, &value) == True) { 
X  				keysym = XStringToKeysym(value.addr);
X  				}
! 			ret = False;
! 			if(keysym != NoSymbol) {
! 				if((keylist = (Ximp_KeyList *)Xmalloc(sizeof(Ximp_KeyList))) != NULL ) {
! 					if((keylist->keys_list = (Ximp_Key *)Xmalloc(sizeof(Ximp_Key)))!= NULL) {
! 						keylist->count_keys = 1;
! 						keylist->keys_list[0].modifier = 0;
! 						keylist->keys_list[0].modifier_mask = 0;
! 						keylist->keys_list[0].keysym = keysym;
! 						im->ximp_impart->process_start_keys = keylist;
! 						ret = True;
! 						}
! 					else
! 						Xfree(keylist);
! 					}
! 				}
! 
! 			/* ProcessStartKeys */
! 			_Ximp_Get_resource_name(im, res_name, res_class);
! 			strcat(res_name, "processStartKeys");
! 			strcat(res_class, "ProcessStartKeys");
! 			if(XrmGetResource(im->core.rdb, res_name, res_class,
! 						str_type, &value)  == True) {
! 				char	*string, *ss, c;
! 				char	*line;
! 
! 				if( (line = Xmalloc(value.size)) != NULL ) {
! 					string = value.addr;
! 					do {
! 						ss = line;
! 						while( (c = *string) != NULL ) {
! 							string++;
! 							if( c == '\n' )
! 								break;
! 							*ss++ = c;
! 							}
! 						*ss = NULL;
! 						_Ximp_parse( im, line );
! 					} while( *string != NULL );
! 					Xfree( line );
! 					if( im->ximp_impart->process_start_keys )
! 						ret = True;
! 					}
X  				}
X  			}
X  		}
*** /tmp/d17470	Sun May  3 18:49:55 1992
--- mit/lib/X/Ximp/XimpSJIS.c	Sun May  3 18:49:53 1992
***************
*** 1,26 ****
! /* $XConsortium: XimpSJIS.c,v 1.3 91/10/07 17:50:33 rws Exp $ */
! /*
!  * Copyright 1991 Sony Corporation
!  *
!  * Permission to use, copy, modify, distribute, and sell this software and its
!  * documentation for any purpose is hereby granted without fee, provided that
!  * the above copyright notice appear in all copies and that both that
!  * copyright notice and this permission notice appear in supporting
!  * documentation, and that the name of Sony not be used in advertising or
!  * publicity pertaining to distribution of the software without specific,
!  * written prior permission.  Sony makes no representations about the
!  * suitability of this software for any purpose.  It is provided "as is"
!  * without express or implied warranty.
!  *
!  * SONY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
!  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SONY
!  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
!  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
!  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!  *
!  * Author: Masaki Takeuchi, Sony Corporation
!  */
X  
X  #include "Xlibint.h"
X  #include "Xlcint.h"
--- 1,30 ----
! /* $XConsortium: XimpSJIS.c,v 1.4 92/04/14 13:29:59 rws Exp $ */
SHAR_EOF
true || echo 'restore of fix-12 failed'
fi
echo 'End of  part 4'
echo 'File fix-12 is continued in part 5'
echo 5 > _shar_seq_.tmp
exit 0
-- 
---
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
