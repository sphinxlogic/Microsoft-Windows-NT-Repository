Newsgroups: comp.sources.x
Path: uunet!europa.asd.contel.com!darwin.sura.net!mips!msi!dcmartin
From: rws@EXPO.LCS.MIT.EDU (Bob Scheifler)
Subject: v18i034: X11R5 public fix #10, Part01/02
Message-ID: <csx-18i034-X11R5-fix10@uunet.UU.NET>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Date: Mon, 20 Jul 1992 15:46:12 GMT
Approved: dcmartin@msi.com
Lines: 1765

Submitted-by: rws@EXPO.LCS.MIT.EDU (Bob Scheifler)
Posting-number: Volume 18, Issue 34
Archive-name: X11R5-fix10/part01

Fix 10 corrects the following problems:

config: new SunOS ld (post-4.1.1 or 4.1.2) is still causing stupid problems
Xlib: XrmGetQSearchList fails if db has only terminal resources
Xlib: _XcmsResolveColorString fails to apply white adjust procedure
Xlib: CIELuv conversion sometimes off by factor of 100
Xlib: XListFonts gets lost if font name length >= 128 chars
Xlib: GC flushing doesn't give extension access to dirty bits
Xlib: (Xsi) XCreateFontSet doesn't free work area
Xlib: (Xsi) XwcLookupString discards partial conversions
Xlib: (Xsi) XOpenIM fails when network is disabled
Xlib: (Xsi) UDC area incorrect in ja_JP.ujis
Xlib: (Xsi) cannot draw JISX0212/CNS11643 2nd plane character
Xlib: (Ximp) XGetICValues wrong for Area, AreaNeeded, SpotLocation
Xlib: (Ximp) error in parsing CT extended segment
Xt: shell RootGeometryManager missing resize in GeometryDone case
Xt: shell RootGeometryManager does not implement Done semantics
Xt: caching of failed conversions causes problems
Xt: SetValues on override and transient resources has problems
Xt: fails to set some WM_NORMAL_HINTS fields to reasonable values
Xt: event handler setting cont_to_dispatch = False does not stop TM actions
Xt: hangs while parsing certain translations
Xt: fails to parse productions with event count and detail
Xt: fails parsing translations with atom details on multiple displays
Xt: obscure typo involving converters & multiple application contexts
Xaw: Panner realize method envelops superclass method incorrectly
xterm: public patch 9 introduced SGI pty problems
xterm: fails to update menu when keyboard grab is forcibly deactivated
xterm: ESC seq not updating App Cursor Keys menu
xterm: restore ESC seq not updating Margin Bell menu
xauth: use of getchar fails on some systems
editres: will sometimes refuse to pop up the resource box

#!/bin/sh
# This is a shell archive (produced by shar 3.50)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 07/20/1992 15:42 UTC by dcmartin@fascet
# Source directory /home/fascet/dcmartin/csx/src/tmp
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#  85909 -rw-r--r-- fix-10
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= fix-10 ==============
if test -f 'fix-10' -a X"$1" != X"-c"; then
	echo 'x - skipping fix-10 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting fix-10 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'fix-10' &&
XFrom: Bob Scheifler <rws@expo.lcs.mit.edu>
Subject: v17i110: X11R5-fix10, Part01/01
Newsgroups: comp.sources.x
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Approved: dcmartin@msi.com
X
Submitted-by: Bob Scheifler <rws@expo.lcs.mit.edu>
Posting-number: Volume 17, Issue 110
Archive-name: X11R5-fix10/part01
X
To apply this patch:
X
cd to the top of the source tree (to the directory containing the "mit"
and "contrib" subdirectories) and do:
X	patch -p -s < ThisFile
Patch will work silently unless an error occurs.
If you want to watch patch do its thing, leave out the "-s" argument to patch.
X
If you are running SunOS 4.1.2, change OSTeenyVersion in mit/config/sun.cf to
have a value of 2.
X
Finally, to rebuild after applying this patch, cd to the "mit" subdirectory
and do (if you are on a Sun running SunOS 4.1.2, or are running SunOS 4.1.1
and have set SunPost411FCSLd to YES (see Patch #9)):
X	make Everything >& every.log
or do (if you are on an SGI or Cray):
X	make Everything >& every.log
otherwise do:
X	make -k >& make.log
X
Brief notes on what this patch fixes:
X
config: new SunOS ld (post-4.1.1 or 4.1.2) is still causing stupid problems
XXlib: XrmGetQSearchList fails if db has only terminal resources
XXlib: _XcmsResolveColorString fails to apply white adjust procedure
XXlib: CIELuv conversion sometimes off by factor of 100
XXlib: XListFonts gets lost if font name length >= 128 chars
XXlib: GC flushing doesn't give extension access to dirty bits
XXlib: (Xsi) XCreateFontSet doesn't free work area
XXlib: (Xsi) XwcLookupString discards partial conversions
XXlib: (Xsi) XOpenIM fails when network is disabled
XXlib: (Xsi) UDC area incorrect in ja_JP.ujis
XXlib: (Xsi) cannot draw JISX0212/CNS11643 2nd plane character
XXlib: (Ximp) XGetICValues wrong for Area, AreaNeeded, SpotLocation
XXlib: (Ximp) error in parsing CT extended segment
XXt: shell RootGeometryManager missing resize in GeometryDone case
XXt: shell RootGeometryManager does not implement Done semantics
XXt: caching of failed conversions causes problems
XXt: SetValues on override and transient resources has problems
XXt: fails to set some WM_NORMAL_HINTS fields to reasonable values
XXt: event handler setting cont_to_dispatch = False does not stop TM actions
XXt: hangs while parsing certain translations
XXt: fails to parse productions with event count and detail
XXt: fails parsing translations with atom details on multiple displays
XXt: obscure typo involving converters & multiple application contexts
XXaw: Panner realize method envelops superclass method incorrectly
xterm: public patch 9 introduced SGI pty problems
xterm: fails to update menu when keyboard grab is forcibly deactivated
xterm: ESC seq not updating App Cursor Keys menu
xterm: restore ESC seq not updating Margin Bell menu
xauth: use of getchar fails on some systems
editres: will sometimes refuse to pop up the resource box
X
X
Prereq: public-patch-9
X
*** /tmp/,RCSt1001439	Wed Mar 18 12:16:10 1992
--- mit/bug-report	Wed Mar 18 12:16:45 1992
***************
*** 2,8 ****
X  Subject: [area]: [synopsis]   [replace with actual area and short description]
X  
X  VERSION:
!     R5, public-patch-9
X      [MIT public patches will edit this line to indicate the patch level]
X  
X  CLIENT MACHINE and OPERATING SYSTEM:
--- 2,8 ----
X  Subject: [area]: [synopsis]   [replace with actual area and short description]
X  
X  VERSION:
!     R5, public-patch-10
X      [MIT public patches will edit this line to indicate the patch level]
X  
X  CLIENT MACHINE and OPERATING SYSTEM:
*** /tmp/,RCSt1001488	Wed Mar 18 13:14:29 1992
--- mit/config/sun.cf	Wed Mar 18 13:14:30 1992
***************
*** 1,9 ****
! XCOMM platform:  $XConsortium: sun.cf,v 1.71 91/12/20 11:18:34 rws Exp $
X  
X  #define OSName            SunOS 4.1.1
X  XCOMM operating system:  OSName
X  #define OSMajorVersion    4
X  #define OSMinorVersion    1
X  
X  #if OSMajorVersion < 4 || (OSMajorVersion == 4 && OSMinorVersion < 1)
X  /* We do not guarantee this will work */
--- 1,10 ----
! XCOMM platform:  $XConsortium: sun.cf,v 1.72.1.1 92/03/18 13:13:37 rws Exp $
X  
X  #define OSName            SunOS 4.1.1
X  XCOMM operating system:  OSName
X  #define OSMajorVersion    4
X  #define OSMinorVersion    1
+ #define OSTeenyVersion    1
X  
X  #if OSMajorVersion < 4 || (OSMajorVersion == 4 && OSMinorVersion < 1)
X  /* We do not guarantee this will work */
***************
*** 11,18 ****
X  #define StandardDefines   -DNOSTDHDRS
X  #endif
X  
! /* You ALSO need this if you have Sun ld patch 100170-06 to 4.1.1 */
! #if OSMajorVersion == 4 && OSMinorVersion > 1
X  #define SunPost411FCSLd	  YES
X  #endif
X  
--- 12,19 ----
X  #define StandardDefines   -DNOSTDHDRS
X  #endif
X  
! /* You ALSO need this if you have Sun ld patch 100170-06 or later to 4.1.1 */
! #if OSMajorVersion == 4 && (OSMinorVersion > 1 || (OSMinorVersion == 1 && OSTeenyVersion > 1))
X  #define SunPost411FCSLd	  YES
X  #endif
X  
*** /tmp/,RCSt1000717	Tue Mar 17 14:59:21 1992
--- mit/config/sunLib.tmpl	Tue Mar 17 14:59:24 1992
***************
*** 1,4 ****
! XCOMM $XConsortium: sunLib.tmpl,v 1.14 91/12/20 11:19:05 rws Exp $
X  
X  /*
X   * SunOS shared library template
--- 1,4 ----
! XCOMM $XConsortium: sunLib.tmpl,v 1.14.1.1 92/03/17 14:58:46 rws Exp $
X  
X  /*
X   * SunOS shared library template
***************
*** 48,54 ****
X  /* Sun shared libraries are deficient in link semantics */
X          DEPXMULIB = _UseCat($(USRLIBDIR),$(XMUSRC),/libXmu.sa.$(SOXMUREV))
X         XMULIBONLY = _Use(-lXmu,-L$(XMUSRC) -lXmu)
!            XMULIB = _Use(-lXmu,-L$(XMUSRC) -lXmu -L$(TOOLKITSRC))
X  #if !defined(UseInstalled) && !defined(XawClientLibs)
X  #define XawClientLibs $(XAWLIB) $(XMULIBONLY) $(XTOOLLIB) $(XLIB)
X  #endif
--- 48,54 ----
X  /* Sun shared libraries are deficient in link semantics */
X          DEPXMULIB = _UseCat($(USRLIBDIR),$(XMUSRC),/libXmu.sa.$(SOXMUREV))
X         XMULIBONLY = _Use(-lXmu,-L$(XMUSRC) -lXmu)
!            XMULIB = _Use(-lXmu,-L$(XMUSRC) -lXmu -L$(TOOLKITSRC) -L$(EXTENSIONSRC)/lib -L$(XLIBSRC))
X  #if !defined(UseInstalled) && !defined(XawClientLibs)
X  #define XawClientLibs $(XAWLIB) $(XMULIBONLY) $(XTOOLLIB) $(XLIB)
X  #endif
*** /tmp/,RCSt1029830	Tue Mar 17 11:34:54 1992
--- mit/lib/X/Xrm.c	Fri Jan 10 17:25:50 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: Xrm.c,v 1.70 91/11/21 19:18:45 rws Exp $
X   */
X  
X  /***********************************************************
--- 1,5 ----
X  /*
!  * $XConsortium: Xrm.c,v 1.72 92/01/10 14:21:12 rws Exp $
X   */
X  
X  /***********************************************************
***************
*** 1004,1009 ****
--- 1004,1010 ----
X   *	Arguments: db - the database.
X   *                 str - a pointer to the string containing the database.
X   *                 filename - source filename, if any.
+  *                 doall - whether to do all lines or just one
X   */
X  
X  /*
***************
*** 1019,1028 ****
X  
X  static void GetIncludeFile();
X  
! static void GetDatabase(db, str, filename)
X      XrmDatabase db;
X      register char *str;
X      char *filename;
X  {
X      register char *ptr;
X      register XrmBits bits = 0;
--- 1020,1030 ----
X  
X  static void GetIncludeFile();
X  
! static void GetDatabase(db, str, filename, doall)
X      XrmDatabase db;
X      register char *str;
X      char *filename;
+     Bool doall;
X  {
X      register char *ptr;
X      register XrmBits bits = 0;
***************
*** 1039,1044 ****
--- 1041,1047 ----
X      XrmBinding bindings[LIST_SIZE];
X      XrmValue value;
X      Bool only_pcs;
+     Bool dolines;
X  
X      if (!db)
X  	return;
***************
*** 1048,1054 ****
X  
X      (*db->methods->mbinit)(db->mbstate);
X      str--;
!     while (!is_EOF(bits)) {
X  
X  	/*
X  	 * First: Remove extra whitespace. 
--- 1051,1059 ----
X  
X      (*db->methods->mbinit)(db->mbstate);
X      str--;
!     dolines = True;
!     while (!is_EOF(bits) && dolines) {
! 	dolines = doall;
X  
X  	/*
X  	 * First: Remove extra whitespace. 
***************
*** 1441,1447 ****
X  #endif
X  {
X      if (!*pdb) *pdb = NewDatabase();
!     GetDatabase(*pdb, line, (char *)NULL);
X  }
X  
X  #if NeedFunctionPrototypes
--- 1446,1452 ----
X  #endif
X  {
X      if (!*pdb) *pdb = NewDatabase();
!     GetDatabase(*pdb, line, (char *)NULL, False);
X  }
X  
X  #if NeedFunctionPrototypes
***************
*** 1455,1461 ****
X      XrmDatabase     db;
X  
X      db = NewDatabase();
!     GetDatabase(db, data, (char *)NULL);
X      return db;
X  }
X  
--- 1460,1466 ----
X      XrmDatabase     db;
X  
X      db = NewDatabase();
!     GetDatabase(db, data, (char *)NULL, True);
X      return db;
X  }
X  
***************
*** 1520,1526 ****
X      }
X      if (!(str = ReadInFile(realfname)))
X  	return;
!     GetDatabase(db, str, realfname);
X      Xfree(str);
X  }
X  
--- 1525,1531 ----
X      }
X      if (!(str = ReadInFile(realfname)))
X  	return;
!     GetDatabase(db, str, realfname, True);
X      Xfree(str);
X  }
X  
***************
*** 1539,1545 ****
X  	return (XrmDatabase)NULL;
X  
X      db = NewDatabase();
!     GetDatabase(db, str, filename);
X      Xfree(str);
X      return db;
X  }
--- 1544,1550 ----
X  	return (XrmDatabase)NULL;
X  
X      db = NewDatabase();
!     GetDatabase(db, str, filename, True);
X      Xfree(str);
X      return db;
X  }
***************
*** 1567,1573 ****
X  	    *target = db = NewDatabase();
X      } else
X  	db = NewDatabase();
!     GetDatabase(db, str, filename);
X      Xfree(str);
X      if (!override)
X  	XrmCombineDatabase(db, target, False);
--- 1572,1578 ----
X  	    *target = db = NewDatabase();
X      } else
X  	db = NewDatabase();
!     GetDatabase(db, str, filename, True);
X      Xfree(str);
X      if (!override)
X  	XrmCombineDatabase(db, target, False);
***************
*** 2127,2134 ****
X      if (db) {
X  	table = db->table;
X  	if (*names) {
! 	    if (table && !table->leaf &&
! 		SearchNEntry(table, names, classes, &closure))
X  		return False;
X  	} else {
X  	    if (table && !table->leaf)
--- 2132,2143 ----
X      if (db) {
X  	table = db->table;
X  	if (*names) {
! 	    if (table && !table->leaf) {
! 		if (SearchNEntry(table, names, classes, &closure))
! 		    return False;
! 	    } else if (table && table->hasloose &&
! 		       AppendLooseLEntry((LTable)table, names, classes,
! 					 &closure))
X  		return False;
X  	} else {
X  	    if (table && !table->leaf)
***************
*** 2393,2402 ****
X  	    if (table && !table->leaf) {
X  		if (GetNEntry(table, names, classes, &closure))
X  		    return True;
! 		table = table->next;
! 	    }
! 	    if (table && table->hasloose &&
! 		GetLooseVEntry((LTable)table, names, classes, &closure))
X  		return True;
X  	} else {
X  	    if (table && !table->leaf)
--- 2402,2409 ----
X  	    if (table && !table->leaf) {
X  		if (GetNEntry(table, names, classes, &closure))
X  		    return True;
! 	    } else if (table && table->hasloose &&
! 		       GetLooseVEntry((LTable)table, names, classes, &closure))
X  		return True;
X  	} else {
X  	    if (table && !table->leaf)
*** /tmp/,RCSt1000469	Tue Mar 17 12:04:43 1992
--- mit/lib/X/CIELuv.c	Tue Mar  3 14:16:34 1992
***************
*** 1,4 ****
! /* $XConsortium: CIELuv.c,v 1.9 91/07/25 01:07:28 rws Exp $" */
X  
X  /*
X   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: CIELuv.c,v 1.10 92/03/03 14:15:02 rws Exp $" */
X  
X  /*
X   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 366,372 ****
X  	Luv_return.L_star = 
X  	    (pColor->spec.CIEuvY.Y < 0.008856)
X  	    ?
! 	    (pColor->spec.CIEuvY.Y * 9.0329)
X  	    :
X  	    ((XcmsFloat)(XCMS_CUBEROOT(pColor->spec.CIEuvY.Y) * 116.0) - 16.0);
X  	tmpVal = 13.0 * (Luv_return.L_star / 100.0);
--- 366,372 ----
X  	Luv_return.L_star = 
X  	    (pColor->spec.CIEuvY.Y < 0.008856)
X  	    ?
! 	    (pColor->spec.CIEuvY.Y * 903.29)
X  	    :
X  	    ((XcmsFloat)(XCMS_CUBEROOT(pColor->spec.CIEuvY.Y) * 116.0) - 16.0);
X  	tmpVal = 13.0 * (Luv_return.L_star / 100.0);
*** /tmp/,RCSt1000489	Tue Mar 17 12:06:40 1992
--- mit/lib/X/XFontNames.c	Tue Mar  3 14:22:26 1992
***************
*** 1,4 ****
! /* $XConsortium: XFontNames.c,v 11.25 91/01/29 08:39:45 rws Exp $ */
X  /* Copyright    Massachusetts Institute of Technology    1986	*/
X  
X  /*
--- 1,4 ----
! /* $XConsortium: XFontNames.c,v 11.26 92/03/03 14:21:22 rws Exp $ */
X  /* Copyright    Massachusetts Institute of Technology    1986	*/
X  
X  /*
***************
*** 68,79 ****
X  	/*
X  	 * unpack into null terminated strings.
X  	 */
! 	length = *ch;
X  	*ch = 1; /* make sure it is non-zero for XFreeFontNames */
X  	for (i = 0; i < rep.nFonts; i++) {
X  	    flist[i] = ch + 1;  /* skip over length */
X  	    ch += length + 1;  /* find next length ... */
! 	    length = *ch;
X  	    *ch = '\0';  /* and replace with null-termination */
X  	}
X      }
--- 68,79 ----
X  	/*
X  	 * unpack into null terminated strings.
X  	 */
! 	length = *(unsigned char *)ch;
X  	*ch = 1; /* make sure it is non-zero for XFreeFontNames */
X  	for (i = 0; i < rep.nFonts; i++) {
X  	    flist[i] = ch + 1;  /* skip over length */
X  	    ch += length + 1;  /* find next length ... */
! 	    length = *(unsigned char *)ch;
X  	    *ch = '\0';  /* and replace with null-termination */
X  	}
X      }
*** /tmp/,RCSt1000509	Tue Mar 17 12:07:37 1992
--- mit/lib/X/XCrGC.c	Wed Mar  4 09:23:07 1992
***************
*** 1,4 ****
! /* $XConsortium: XCrGC.c,v 11.36 91/04/14 13:53:01 rws Exp $ */
X  /* Copyright    Massachusetts Institute of Technology    1986	*/
X  
X  /*
--- 1,4 ----
! /* $XConsortium: XCrGC.c,v 11.38 92/03/04 09:22:18 rws Exp $ */
X  /* Copyright    Massachusetts Institute of Technology    1986	*/
X  
X  /*
***************
*** 47,52 ****
--- 47,54 ----
X      4		/* dashes (list [4,4]) */
X  };
X  
+ static void _XGenerateGCList();
+ 
X  GC XCreateGC (dpy, d, valuemask, values)
X       register Display *dpy;
X       Drawable d;		/* Window or Pixmap for which depth matches */
***************
*** 80,88 ****
X          _XGenerateGCList (dpy, gc, (xReq *) req);
X      ext = dpy->ext_procs;
X      while (ext) {		/* call out to any extensions interested */
! 	if (ext->create_GC != NULL) (*ext->create_GC)(dpy, gc, &ext->codes);
X  	ext = ext->next;
X  	}    
X      UnlockDisplay(dpy);
X      SyncHandle();
X      return (gc);
--- 82,91 ----
X          _XGenerateGCList (dpy, gc, (xReq *) req);
X      ext = dpy->ext_procs;
X      while (ext) {		/* call out to any extensions interested */
! 	if (ext->create_GC) (*ext->create_GC)(dpy, gc, &ext->codes);
X  	ext = ext->next;
X  	}    
+     gc->dirty = 0L; /* allow extensions to see dirty bits */
X      UnlockDisplay(dpy);
X      SyncHandle();
X      return (gc);
***************
*** 90,99 ****
X  
X  /*
X   * GenerateGCList looks at the GC dirty bits, and appends all the required
!  * long words to the request being generated.  Clears the dirty bits in
!  * the GC.
X   */
X  
X  _XGenerateGCList (dpy, gc, req)
X      register Display *dpy;
X      xReq *req;
--- 93,102 ----
X  
X  /*
X   * GenerateGCList looks at the GC dirty bits, and appends all the required
!  * long words to the request being generated.
X   */
X  
+ static void
X  _XGenerateGCList (dpy, gc, req)
X      register Display *dpy;
X      xReq *req;
***************
*** 145,151 ****
X  
X      nvalues <<= 2;
X      Data32 (dpy, (long *) values, nvalues);
-     gc->dirty = 0L;
X  
X      }
X  
--- 148,153 ----
***************
*** 315,323 ****
X          _XGenerateGCList (dpy, gc, (xReq *) req);
X  	ext = dpy->ext_procs;
X  	while (ext) {		/* call out to any extensions interested */
! 		if (ext->flush_GC != NULL) (*ext->flush_GC)(dpy, gc, &ext->codes);
X  		ext = ext->next;
X  	}    
X      }
X  }
X  
--- 317,326 ----
X          _XGenerateGCList (dpy, gc, (xReq *) req);
X  	ext = dpy->ext_procs;
X  	while (ext) {		/* call out to any extensions interested */
! 		if (ext->flush_GC) (*ext->flush_GC)(dpy, gc, &ext->codes);
X  		ext = ext->next;
X  	}    
+ 	gc->dirty = 0L; /* allow extensions to see dirty bits */
X      }
X  }
X  
*** /tmp/,RCSt1000428	Tue Mar 17 12:02:16 1992
--- mit/lib/X/XcmsColNm.c	Tue Mar  3 12:17:04 1992
***************
*** 1,4 ****
! /* $XConsortium: XcmsColNm.c,v 1.24 91/11/06 17:55:19 rws Exp $" */
X  
X  /*
X   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: XcmsColNm.c,v 1.25 92/03/03 12:16:07 rws Exp $" */
X  
X  /*
X   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 1014,1022 ****
X  			ScreenWhitePointOfCCC(ccc), result_format,
X  			pColor_exact_return, 1, (Bool *)NULL));
X  	    } else {
! 		if (_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			&dbWhitePt, 1, XcmsCIEXYZFormat) == XcmsFailure) {
! 		    return(XcmsFailure);
X  		}
X  		return (_XcmsDDConvertColors(ccc, pColor_exact_return, 1,
X  			result_format, (Bool *)NULL));
--- 1014,1024 ----
X  			ScreenWhitePointOfCCC(ccc), result_format,
X  			pColor_exact_return, 1, (Bool *)NULL));
X  	    } else {
! 		if (pColor_exact_return->format != XcmsCIEXYZFormat) {
! 		    if (_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			    &dbWhitePt, 1, XcmsCIEXYZFormat) == XcmsFailure) {
! 			return(XcmsFailure);
! 		    }
X  		}
X  		return (_XcmsDDConvertColors(ccc, pColor_exact_return, 1,
X  			result_format, (Bool *)NULL));
***************
*** 1025,1044 ****
X  	    /*
X  	     * Target format is Device-Independent
X  	     *	Therefore, DI --> DI conversion
- 	     *
- 	     * Since DI->DI, we don't apply WhiteAdjustProc.
X  	     */
! 	    if (_XcmsEqualWhitePts(ccc,
X  		    &dbWhitePt, pClientWhitePt)) {
! 		return (_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			&dbWhitePt, 1, result_format));
X  	    } else {
! 		if (_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			&dbWhitePt, 1, XcmsCIEXYZFormat) == XcmsFailure) {
! 		    return(XcmsFailure);
X  		}
! 		return(_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			pClientWhitePt, 1, result_format));
X  	    }
X  	}
X      }
--- 1027,1080 ----
X  	    /*
X  	     * Target format is Device-Independent
X  	     *	Therefore, DI --> DI conversion
X  	     */
! 	    if (ccc->whitePtAdjProc && !_XcmsEqualWhitePts(ccc,
X  		    &dbWhitePt, pClientWhitePt)) {
! 		/*
! 		 * The calling routine wants to resolve this color
! 		 * in terms if it's white point (i.e. Client White Point).
! 		 * Therefore, apply white adjustment for the displacement
! 		 * between dbWhitePt to clientWhitePt.
! 		 */
! 		return((*ccc->whitePtAdjProc)(ccc, &dbWhitePt,
! 			pClientWhitePt, result_format,
! 			pColor_exact_return, 1, (Bool *)NULL));
! 	    } else if (_XcmsEqualWhitePts(ccc,
! 		    &dbWhitePt, pClientWhitePt)) {
! 		/*
! 		 * Can use either dbWhitePt or pClientWhitePt to
! 		 * convert to the result_format.
! 		 */
! 		if (pColor_exact_return->format == result_format) {
! 		    return(XcmsSuccess);
! 		} else {
! 		    return (_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			    &dbWhitePt, 1, result_format));
! 		}
X  	    } else {
! 		/*
! 		 * Need to convert to a white point independent color
! 		 * space (let's choose CIEXYZ) then convert to the
! 		 * target color space.  Why? Lets assume that
! 		 * pColor_exact_return->format and result format
! 		 * are white point dependent format (e.g., CIELUV, CIELAB,
! 		 * TekHVC ... same or any combination). If so, we'll
! 		 * need to convert the color with dbWhitePt to an absolute
! 		 * spec (i.e.  non-white point dependent) then convert that
! 		 * absolute value with clientWhitePt to the result_format.
! 		 */
! 		if (pColor_exact_return->format != XcmsCIEXYZFormat) {
! 		    if (_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			    &dbWhitePt, 1, XcmsCIEXYZFormat) == XcmsFailure) {
! 			return(XcmsFailure);
! 		    }
X  		}
! 		if (result_format == XcmsCIEXYZFormat) {
! 		    return(XcmsSuccess);
! 		} else {
! 		    return(_XcmsDIConvertColors(ccc, pColor_exact_return,
! 			    pClientWhitePt, 1, result_format));
! 		}
X  	    }
X  	}
X      }
*** /tmp/,RCSt1000153	Tue Mar 17 11:52:11 1992
--- mit/lib/X/Xsi/ProtoFlt.c	Tue Mar  3 10:02:26 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: ProtoFlt.c,v 1.25 91/12/02 16:50:26 rws Exp $
X   */
X  
X  /*
--- 1,5 ----
X  /*
!  * $XConsortium: ProtoFlt.c,v 1.26 92/03/03 10:01:17 rws Exp $
X   */
X  
X  /*
***************
*** 95,101 ****
X  	    ret = _XConvertCTToMB(ic->mb, (unsigned char *)ic->ct_buf, length,
X  				  mbuf, &mb_len, &scanned_bytes,
X  				  (_State *)NULL);
! 	    if (ret == Success) {
X  #ifdef macII
X  		wc_len = 0;
X  #else
--- 95,101 ----
X  	    ret = _XConvertCTToMB(ic->mb, (unsigned char *)ic->ct_buf, length,
X  				  mbuf, &mb_len, &scanned_bytes,
X  				  (_State *)NULL);
! 	    if (ret >= 0) {
X  #ifdef macII
X  		wc_len = 0;
X  #else
***************
*** 106,112 ****
X  		    return;
X  	    }
X  #endif
! 	    if (ret != Success) {
X  		return;
X  	    }
X  	} else {
--- 106,112 ----
X  		    return;
X  	    }
X  #endif
! 	    if (ret < 0) {
X  		return;
X  	    }
X  	} else {
***************
*** 256,262 ****
X  		ret = _XConvertCTToMB(ic->mb, (unsigned char *)ic->ct_buf,
X  				      length, mbuf, &mb_len, &scanned_bytes,
X  				      (_State *)NULL);
! 		if (ret == Success) {
X  #ifdef macII
X  		    wc_len = 0;
X  #else
--- 256,262 ----
X  		ret = _XConvertCTToMB(ic->mb, (unsigned char *)ic->ct_buf,
X  				      length, mbuf, &mb_len, &scanned_bytes,
X  				      (_State *)NULL);
! 		if (ret >= 0) {
X  #ifdef macII
X  		    wc_len = 0;
X  #else
***************
*** 267,273 ****
X  			return;
X  		}
X  #endif
! 		if (ret != Success) {
X  		    return;
X  		}
X  	    } else {
--- 267,273 ----
X  			return;
X  		}
X  #endif
! 		if (ret < 0) {
X  		    return;
X  		}
X  	    } else {
*** /tmp/,RCSt1000172	Tue Mar 17 11:52:21 1992
--- mit/lib/X/Xsi/XConnIM.c	Tue Mar  3 10:03:10 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: XConnIM.c,v 1.16 91/08/12 17:22:22 rws Exp $
X   */
X  
X  /*
--- 1,5 ----
X  /*
!  * $XConsortium: XConnIM.c,v 1.17 92/03/03 10:02:09 rws Exp $
X   */
X  
X  /*
***************
*** 61,69 ****
X      im->fd = -1;
X      return(False);
X  #else
- #ifdef	UNIXCONN
-     char		hostname[256];	/* My host name buffer */
- #endif
X      char		im_hostname[256];/* Input manager host name buffer */
X      Atom		actual_type;
X      int			actual_format;
--- 61,66 ----
***************
*** 84,89 ****
--- 81,87 ----
X      ximNormalReply	reply;
X      unsigned long	i;
X      unsigned short	s;
+     int			inet_ok = 0;
X  
X      im->fd = -1;
X      /*
***************
*** 109,123 ****
X      if (im->major_version != XIM_MAJOR_VERSION) return(False);
X      if (!(im->minor_version >= XIM_MINOR_VERSION)) return(False);
X  
! #ifdef	UNIXCONN
!     if (gethostname(hostname, 256) < 0) {
! 	hostname[0] = '\0';
X      }
X      /*
!      * If the hostname of gethostname is null or the hostname of the input
!      * manager is null, attempts to open UNIX domain socket.
X       */
!     if ((hostname[0] == '\0') || (im_hostname[0] == '\0')) {
X  	saddr.sun_family = AF_UNIX;
X  	strcpy(saddr.sun_path, XIM_UNIX_PATH);
X  	if ((sd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
--- 107,136 ----
X      if (im->major_version != XIM_MAJOR_VERSION) return(False);
X      if (!(im->minor_version >= XIM_MINOR_VERSION)) return(False);
X  
! #ifdef TCPCONN
!     /*
!      * Attempts to open INET domain socket.
!      */
!     if (hp = gethostbyname(im_hostname)) {
! 	bzero((char *)&saddr_in, (int)sizeof(saddr_in));
! 	bcopy(hp->h_addr, (char *)&saddr_in.sin_addr, hp->h_length);
! 	saddr_in.sin_family = AF_INET;
! 	saddr_in.sin_port = htons(port);
! 	if ((sd = socket(AF_INET, SOCK_STREAM, 0)) >= 0) {
! 	    if (connect(sd, &saddr_in, sizeof(saddr_in)) >= 0) {
! 		inet_ok = 1;
! 	    } else {
! 		close(sd);
! 		sd = -1;
! 	    }
! 	}
X      }
+ #endif
+ #ifdef	UNIXCONN
X      /*
!      * Attempts to open UNIX domain socket.
X       */
!     if (inet_ok == 0) {
X  	saddr.sun_family = AF_UNIX;
X  	strcpy(saddr.sun_path, XIM_UNIX_PATH);
X  	if ((sd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
***************
*** 127,156 ****
X  	    close(sd);
X  	    return(False);
X  	}
-     } else {
- #endif	/* UNIXCONN */
- #ifdef TCPCONN
- 	/*
- 	 * Attempts to open INET domain socket.
- 	 */
- 	if ((hp = gethostbyname(im_hostname)) == NULL) {
- 	    return(False);
- 	}
- 	bzero((char *)&saddr_in, (int)sizeof(saddr_in));
- 	bcopy(hp->h_addr, (char *)&saddr_in.sin_addr, hp->h_length);
- 	saddr_in.sin_family = AF_INET;
- 	saddr_in.sin_port = htons(port);
- 	if ((sd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
- 	    return(False);
- 	}
- 	if (connect(sd, &saddr_in, sizeof(saddr_in)) < 0) {
- 	    close(sd);
- 	    return(False);
- 	}
- #endif
- #ifdef	UNIXCONN
X      }
X  #endif	/* UNIXCONN */
X  
X      /*
X       * Send the display name to the input manager. 
--- 140,148 ----
X  	    close(sd);
X  	    return(False);
X  	}
X      }
X  #endif	/* UNIXCONN */
+     if (sd == -1) return(False);
X  
X      /*
X       * Send the display name to the input manager. 
*** /tmp/,RCSt1000191	Tue Mar 17 11:52:32 1992
--- mit/lib/X/Xsi/XCrFntSet.c	Tue Mar  3 10:01:24 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: XCrFntSet.c,v 1.43 91/12/02 16:49:48 rws Exp $
X   */
X  
X  /*
--- 1,5 ----
X  /*
!  * $XConsortium: XCrFntSet.c,v 1.44 92/03/03 10:00:34 rws Exp $
X   */
X  
X  /*
***************
*** 440,453 ****
X  	    if (matchCharset(fn, cset->cs_name, cset->cs_GLorGR) == True) {
X  		dbg_printf("findFont: matched\n", 0, 0);
X  		ret++;
- 		f_tmp[i] = fn;
X  #ifdef PRELOAD
X  		if (!(s_tmp[i] = XLoadQueryFont(dpy, fn))) ret--;
X  #else /* PRELOAD */
X  		if (!info)
X  		    list = XListFontsWithInfo(dpy, fname, 1, &count, &info);
! 		if(! (s_tmp[i] = (XFontStruct *) Xmalloc(sizeof(XFontStruct))))
X  		    return ret;
X  # ifndef MUSTCOPY
X  		s_tmp[i] = info[0];
X  # else /* MUSTCOPY */
--- 440,454 ----
X  	    if (matchCharset(fn, cset->cs_name, cset->cs_GLorGR) == True) {
X  		dbg_printf("findFont: matched\n", 0, 0);
X  		ret++;
X  #ifdef PRELOAD
X  		if (!(s_tmp[i] = XLoadQueryFont(dpy, fn))) ret--;
X  #else /* PRELOAD */
X  		if (!info)
X  		    list = XListFontsWithInfo(dpy, fname, 1, &count, &info);
! 		if(! (s_tmp[i] = (XFontStruct *) Xmalloc(sizeof(XFontStruct)))){
! 		    Xfree((char *)fn);
X  		    return ret;
+ 		}
X  # ifndef MUSTCOPY
X  		s_tmp[i] = info[0];
X  # else /* MUSTCOPY */
***************
*** 457,462 ****
--- 458,468 ----
X  		s_tmp[i]->fid = 0;
X  #endif /* PRELOAD */
X  		id_tmp[i] = cset->cs_id;
+ 		if(! (f_tmp[i] = (char *) Xmalloc(strlen(fn) + 1))) {
+ 		    Xfree((char *)fn);
+ 		    return --ret;
+ 		}
+ 		strcpy(f_tmp[i], fn);
X  	    } else {
X  		f_tmp[i] = NULL;
X  	    }
***************
*** 466,471 ****
--- 472,478 ----
X      if (info) {
X  	XFreeFontInfo(list, info, count);
X      }
+     Xfree((char *)fn);
X      return ret;
X  
X  }
***************
*** 678,684 ****
X      }
X  
X      if (!loadASCIIFONT) {
! 	f_tmp[0] = "fixed";	/* use defalt font */
X  	s_tmp[0] = XLoadQueryFont(dpy, f_tmp[0]);
X      }
X  
--- 685,693 ----
X      }
X  
X      if (!loadASCIIFONT) {
! 	if(! (f_tmp[0] = (char *)Xmalloc(strlen("fixed") + 1)))
! 	    return NULL;
! 	strcpy(f_tmp[0], "fixed");	/* use defalt font */
X  	s_tmp[0] = XLoadQueryFont(dpy, f_tmp[0]);
X      }
X  
***************
*** 704,709 ****
--- 713,721 ----
X  		      &font_set->min_bounds, &font_set->max_bounds,
X  		      &font_set->ascent, &font_set->descent);
X      font_set->core.default_string = NULL;
+     for (i = 0; (int)i < found; i++) {
+ 	Xfree((char *)f_tmp[i]);
+     }
X  
X      /*
X       * set the ink bounding box of font_set.
***************
*** 867,872 ****
--- 879,887 ----
X  		      &font_set->min_bounds, &font_set->max_bounds,
X  		      &font_set->ascent, &font_set->descent);
X      font_set->core.default_string = NULL;
+     for (i = 0; (int)i < found; i++) {
+ 	Xfree((char *)f_tmp[i]);
+     }
X  
X      /*
X       * set the ink bounding box of font_set.
*** /tmp/,RCSt1000211	Tue Mar 17 11:52:41 1992
--- mit/lib/X/Xsi/XIMKeyBind.c	Tue Mar  3 10:02:30 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: XIMKeyBind.c,v 1.21 91/12/02 16:42:44 rws Exp $
X   */
X  
X  /*
--- 1,5 ----
X  /*
!  * $XConsortium: XIMKeyBind.c,v 1.22 92/03/03 10:01:53 rws Exp $
X   */
X  
X  /*
***************
*** 67,73 ****
X  	    mbuf = _XAllocScratch(ev->display, ret_len);
X  	    ret = _XConvertCTToMB(ic->mb, ptr, length, mbuf,
X  				  &ret_len, &scanned_bytes, (_State *)NULL);
! 	    if (ret == Success) {
X  #ifdef macII
X  		ret_len = 0;
X  #else
--- 67,73 ----
X  	    mbuf = _XAllocScratch(ev->display, ret_len);
X  	    ret = _XConvertCTToMB(ic->mb, ptr, length, mbuf,
X  				  &ret_len, &scanned_bytes, (_State *)NULL);
! 	    if (ret >= 0) {
X  #ifdef macII
X  		ret_len = 0;
X  #else
***************
*** 78,84 ****
X  		    ret = XBufferOverflow;
X  	    }
X  #endif
! 	    if (ret != Success) {
X  		*status = XBufferOverflow;
X  		return(0);
X  	    }
--- 78,84 ----
X  		    ret = XBufferOverflow;
X  	    }
X  #endif
! 	    if (ret < 0) {
X  		*status = XBufferOverflow;
X  		return(0);
X  	    }
***************
*** 104,112 ****
X  	    }
X  #ifdef X_WCHAR
X  	    /* XXX BUG Need to save current status */
! 	    _XConvertMBToWC(ic->wc, (unsigned char *)buf, ret_len,
X  			    (wchar *)buffer, &nchars, &scanned_bytes,
X  			    (_State *)NULL);
X  	    ret_len = nchars;
X  	    /* XXX BUG Need to restore saved status */
X  #else
--- 104,116 ----
X  	    }
X  #ifdef X_WCHAR
X  	    /* XXX BUG Need to save current status */
! 	    ret = _XConvertMBToWC(ic->wc, (unsigned char *)buf, ret_len,
X  			    (wchar *)buffer, &nchars, &scanned_bytes,
X  			    (_State *)NULL);
+ 	    if (ret < 0) {
+ 		*status = XBufferOverflow;
+ 		return(0);
+ 	    }
X  	    ret_len = nchars;
X  	    /* XXX BUG Need to restore saved status */
X  #else
***************
*** 150,156 ****
X  	    ret_len = nbytes;
X  	    ret = _XConvertCTToMB(ic->mb, ptr, length, (unsigned char *)buffer,
X  				  &ret_len, &scanned_bytes, (_State *)NULL);
! 	    if (ret != Success) {
X  		*status = XBufferOverflow;
X  		return(0);
X  	    }
--- 154,160 ----
X  	    ret_len = nbytes;
X  	    ret = _XConvertCTToMB(ic->mb, ptr, length, (unsigned char *)buffer,
X  				  &ret_len, &scanned_bytes, (_State *)NULL);
! 	    if (ret < 0) {
X  		*status = XBufferOverflow;
X  		return(0);
X  	    }
***************
*** 163,169 ****
X  				      (unsigned char *)buffer,
X  				      &ret_len, &scanned_bytes,
X  				      (_State *)NULL);
! 		if (ret != Success) {
X  		    *status = XBufferOverflow;
X  		    return(0);
X  		}
--- 167,173 ----
X  				      (unsigned char *)buffer,
X  				      &ret_len, &scanned_bytes,
X  				      (_State *)NULL);
! 		if (ret < 0) {
X  		    *status = XBufferOverflow;
X  		    return(0);
X  		}
*** /tmp/,RCSt1000782	Tue Mar 17 15:30:58 1992
--- mit/lib/X/Xsi/XInitCT.c	Tue Mar  3 10:04:01 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: XInitCT.c,v 1.16 91/09/18 16:29:54 rws Exp $
X   */
X  
X  /*
--- 1,5 ----
X  /*
!  * $XConsortium: XInitCT.c,v 1.17 92/03/03 10:02:52 rws Exp $
X   */
X  
X  /*
***************
*** 546,554 ****
X      _CSID			ind, i;
X      _CSID 			n = ISOStateTableNum;
X  
! #define PosSub(s1, s2) ((s1 >= s2) ? (s1 - s2) : ~0L)
X  
X      *woffset = ptr->state_woffset;
X      ind = CODESET0;
X      disp_min = PosSub(wc, ptr->state_woffset);
X      if (disp_min == (wchar) ~0L) {
--- 546,555 ----
X      _CSID			ind, i;
X      _CSID 			n = ISOStateTableNum;
X  
! #define PosSub(s1, s2) (((s1) >= (s2)) ? ((s1) - (s2)) : ~0L)
X  
X      *woffset = ptr->state_woffset;
+     wc &= ~0x7f;
X      ind = CODESET0;
X      disp_min = PosSub(wc, ptr->state_woffset);
X      if (disp_min == (wchar) ~0L) {
***************
*** 558,566 ****
X      if (disp_min < 0x80)
X  	return(CODESET0);
X      for (i = 1, ptr++; i < n; i++, ptr++) {
!         if (((new = PosSub(wc, ptr->state_woffset)) > 0) && (new < disp_min)) {
X              *woffset = ptr->state_woffset;
! 	    if ((new < 0x80) || (ptr->state_length == 2 && new < 0x8000))
X  		return(i);
X              ind = i;
X              disp_min = new;
--- 559,571 ----
X      if (disp_min < 0x80)
X  	return(CODESET0);
X      for (i = 1, ptr++; i < n; i++, ptr++) {
! 	if (ptr->state_length == 2)
! 	    new = PosSub(wc & ~0x7f00, ptr->state_woffset);
! 	else
! 	    new = PosSub(wc, ptr->state_woffset);
!         if ((new >= 0) && (new < disp_min)) {
X              *woffset = ptr->state_woffset;
! 	    if (new < 0x80)
X  		return(i);
X              ind = i;
X              disp_min = new;
*** /tmp/,RCSt1000246	Tue Mar 17 11:54:17 1992
--- mit/lib/nls/Xsi/ja_JP.ujis	Tue Mar  3 10:00:18 1992
***************
*** 1,5 ****
X  #
! # $XConsortium: ja_JP.ujis,v 1.7 91/06/29 20:02:02 xguest Exp $
X  #
X  # Copyright 1990, 1991 by OMRON Corporation, NTT Software Corporation,
X  #                      and Nippon Telegraph and Telephone Corporation
--- 1,5 ----
X  #
! # $XConsortium: ja_JP.ujis,v 1.8 92/03/03 09:59:32 rws Exp $
X  #
X  # Copyright 1990, 1991 by OMRON Corporation, NTT Software Corporation,
X  #                      and Nippon Telegraph and Telephone Corporation
***************
*** 103,109 ****
X  (8fa1a1=2121:7e7e)
X  #
X  # UDC
! (f5a1=2121:2d7e)
X  END XLC_CODESET
X  #
X  # END OF FILE
--- 103,109 ----
X  (8fa1a1=2121:7e7e)
X  #
X  # UDC
! (f5a1=2121:2a7e)
X  END XLC_CODESET
X  #
X  # END OF FILE
*** /tmp/,RCSt1000330	Tue Mar 17 11:57:46 1992
--- mit/lib/X/Ximp/XimpIC.c	Tue Mar  3 11:03:57 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpIC.c,v 1.4 91/10/07 17:48:30 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XimpIC.c,v 1.5 92/03/03 11:03:14 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, by FUJITSU LIMITED
***************
*** 58,63 ****
--- 58,71 ----
X  static void 		_Ximp_AttributesSetL();
X  extern void 		_Ximp_IM_SendMessage();
X  
+ #if NeedFunctionPrototypes
+ extern Bool _Ximp_XimFilter_Keypress (
+ 	Display *d, 
+ 	Window w, 
+ 	XEvent *ev, 
+ 	XPointer client_data);
+ #endif
+ 
X  static XICMethodsRec Ximp_ic_methods = {
X  				_Ximp_DestroyIC, 	/* destroy */
X  				_Ximp_SetFocus,  	/* set_focus */
***************
*** 75,81 ****
X  	Display		*d;
X  	Window		w;
X  	XEvent		*ev;
! 	XPointer	*client_data;
X  {
X  	extern Bool	_Ximp_Keypress ();
X  
--- 83,89 ----
X  	Display		*d;
X  	Window		w;
X  	XEvent		*ev;
! 	XPointer	client_data;
X  {
X  	extern Bool	_Ximp_Keypress ();
X  
***************
*** 138,144 ****
X  				ic->core.focus_window,
X  				KeyPress, KeyPress,
X  				_Ximp_XimFilter_Keypress,
! 				ic);
X  		current_xic = ic;
X  	}
X  	return((XIC)ic);
--- 146,152 ----
X  				ic->core.focus_window,
X  				KeyPress, KeyPress,
X  				_Ximp_XimFilter_Keypress,
! 				(XPointer)ic);
X  		current_xic = ic;
X  	}
X  	return((XIC)ic);
***************
*** 159,165 ****
X  			_XUnregisterFilter (ic->core.im->core.display,
X  					ic->core.focus_window,
X  					_Ximp_XimFilter_Keypress,
! 					current_xic);
X  			current_xic = 0;
X  		}
X  	}
--- 167,173 ----
X  			_XUnregisterFilter (ic->core.im->core.display,
X  					ic->core.focus_window,
X  					_Ximp_XimFilter_Keypress,
! 					(XPointer)current_xic);
X  			current_xic = 0;
X  		}
X  	}
***************
*** 177,188 ****
X  			_XUnregisterFilter (ic->core.im->core.display,
X  						ic->core.focus_window,
X  						_Ximp_XimFilter_Keypress,
! 						current_xic);
X  		_XRegisterFilterByType (ic->core.im->core.display,
X  					ic->core.focus_window,
X  					KeyPress, KeyPress,
X  					_Ximp_XimFilter_Keypress,
! 					ic);
X  		current_xic = ic;
X  	}
X  	return;
--- 185,196 ----
X  			_XUnregisterFilter (ic->core.im->core.display,
X  						ic->core.focus_window,
X  						_Ximp_XimFilter_Keypress,
! 						(XPointer)current_xic);
X  		_XRegisterFilterByType (ic->core.im->core.display,
X  					ic->core.focus_window,
X  					KeyPress, KeyPress,
X  					_Ximp_XimFilter_Keypress,
! 					(XPointer)ic);
X  		current_xic = ic;
X  	}
X  	return;
***************
*** 198,204 ****
X  			_XUnregisterFilter (ic->core.im->core.display,
X  					ic->core.focus_window,
X  					_Ximp_XimFilter_Keypress,
! 					current_xic);
X  			current_xic = 0;
X  		}
X  	}
--- 206,212 ----
X  			_XUnregisterFilter (ic->core.im->core.display,
X  					ic->core.focus_window,
X  					_Ximp_XimFilter_Keypress,
! 					(XPointer)current_xic);
X  			current_xic = 0;
X  		}
X  	}
*** /tmp/,RCSt1000347	Tue Mar 17 11:57:56 1992
--- mit/lib/X/Ximp/XimpLkup.c	Tue Mar  3 11:04:03 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpLkup.c,v 1.5 91/10/07 17:49:03 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, by Sony Corporation
--- 1,4 ----
! /* $XConsortium: XimpLkup.c,v 1.6 92/03/03 11:03:23 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, by Sony Corporation
***************
*** 71,76 ****
--- 71,84 ----
X  static void		_Ximp_CallCallback();
X  static void		_Ximp_ProcError();
X  
+ #if NeedFunctionPrototypes
+ static Bool
+ _Ximp_ResetPredicate(
+ 	Display *d,
+ 	XEvent *ev,
+ 	XPointer parg);
+ #endif
+ 
X  typedef struct {
X  	Atom type;
X  	ICID icid;
***************
*** 78,88 ****
X  } XimpResetPredArgRec, *XimpResetPredArg;
X  
X  static Bool
! _Ximp_ResetPredicate(d, ev, arg)
X  Display *d;
X  XEvent *ev;
! XimpResetPredArg arg;
X  {
X  	if (ev->type == ClientMessage) {
X  		if (ev->xclient.message_type == arg->type) {
X  			if ((ev->xclient.format == 32) &&
--- 86,97 ----
X  } XimpResetPredArgRec, *XimpResetPredArg;
X  
X  static Bool
! _Ximp_ResetPredicate(d, ev, parg)
X  Display *d;
X  XEvent *ev;
! XPointer parg;
X  {
+ 	XimpResetPredArg arg = (XimpResetPredArg)parg;
X  	if (ev->type == ClientMessage) {
X  		if (ev->xclient.message_type == arg->type) {
X  			if ((ev->xclient.format == 32) &&
***************
*** 128,134 ****
X  		Arg.icid = ic->ximp_icpart->icid;
X  		Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
X  		while(_time_flag != 1) {
! 			if( (XCheckIfEvent(ic->core.im->core.display, &event, _Ximp_ResetPredicate, &Arg)) == False) {
X  #ifdef XIMP_SIGNAL
X  				sleep(1);
X  #endif /* XIMP_SIGNAL */
--- 137,143 ----
X  		Arg.icid = ic->ximp_icpart->icid;
X  		Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
X  		while(_time_flag != 1) {
! 			if( (XCheckIfEvent(ic->core.im->core.display, &event, _Ximp_ResetPredicate, (XPointer)&Arg)) == False) {
X  #ifdef XIMP_SIGNAL
X  				sleep(1);
X  #endif /* XIMP_SIGNAL */
***************
*** 198,204 ****
X  
X  	if (!ct) return(NULL);
X  	mb = Xmalloc(length);
! 	_Ximp_cttombs(ic->core.im->core.lcd, ct, strlen(ct), mb, &length, NULL);
X  	mb[length] = '\0';
X  	return(mb);
X  }
--- 207,213 ----
X  
X  	if (!ct) return(NULL);
X  	mb = Xmalloc(length);
! 	_Ximp_cttombs(ic->core.im->core.lcd, ct, strlen((char *)ct), mb, &length, NULL);
X  	mb[length] = '\0';
X  	return(mb);
X  }
***************
*** 213,219 ****
X  
X  	if (!ct) return(NULL);
X  	wc = (wchar_t *)Xmalloc(length * sizeof(wchar_t));
! 	_Ximp_cttowcs(ic->core.im->core.lcd, ct, strlen(ct), wc, &length, NULL);
X  	wc[length] = (wchar_t)0;
X  	return(wc);
X  }
--- 222,228 ----
X  
X  	if (!ct) return(NULL);
X  	wc = (wchar_t *)Xmalloc(length * sizeof(wchar_t));
! 	_Ximp_cttowcs(ic->core.im->core.lcd, ct, strlen((char *)ct), wc, &length, NULL);
X  	wc[length] = (wchar_t)0;
X  	return(wc);
X  }
***************
*** 547,553 ****
X  	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
X  			((Ximp_XIM)ic->core.im)->ximp_impart->version_id,
X  			XA_STRING, 8, PropModeReplace,
! 			XIMP_PROTOCOL_VERSION, strlen(XIMP_PROTOCOL_VERSION));
X  	XFlush(ic->core.im->core.display);
X  
X  	mask = ic->ximp_icpart->proto_mask;
--- 556,562 ----
X  	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
X  			((Ximp_XIM)ic->core.im)->ximp_impart->version_id,
X  			XA_STRING, 8, PropModeReplace,
! 			(unsigned char *)XIMP_PROTOCOL_VERSION, strlen(XIMP_PROTOCOL_VERSION));
X  	XFlush(ic->core.im->core.display);
X  
X  	mask = ic->ximp_icpart->proto_mask;
***************
*** 849,855 ****
X  			_Ximp_ProcKeypress (d, w, ev);
X  			_Ximp_MakeKeypress (d, w, ev);
X  			ev->send_event = False ;
! 			XPutBackEvent(d, ev);
X  			break ;
X  		case XIMP_CREATE_RETURN:
X  			_Ximp_ProcCreateReturn (d, w, ev);
--- 858,864 ----
X  			_Ximp_ProcKeypress (d, w, ev);
X  			_Ximp_MakeKeypress (d, w, ev);
X  			ev->send_event = False ;
! 			XPutBackEvent(d, (XEvent *)ev);
X  			break ;
X  		case XIMP_CREATE_RETURN:
X  			_Ximp_ProcCreateReturn (d, w, ev);
***************
*** 864,870 ****
X  			_Ximp_ProcReadProperty (d, w, ev);
X  			_Ximp_MakeKeypress (d, w, ev);
X  			ev->send_event = False ;
! 			XPutBackEvent(d, ev);
X  			break ;
X  		case XIMP_ERROR:
X  			_Ximp_ProcError (d, w, ev);
--- 873,879 ----
X  			_Ximp_ProcReadProperty (d, w, ev);
X  			_Ximp_MakeKeypress (d, w, ev);
X  			ev->send_event = False ;
! 			XPutBackEvent(d, (XEvent *)ev);
X  			break ;
X  		case XIMP_ERROR:
X  			_Ximp_ProcError (d, w, ev);
***************
*** 891,897 ****
X  		_Ximp_ProcReadMessage (d, w, ev);
X  		_Ximp_MakeKeypress (d, w, ev);
X  		ev->send_event = False ;
! 		XPutBackEvent(d, ev);
X          }
X  	return (True);
X  }
--- 900,906 ----
X  		_Ximp_ProcReadMessage (d, w, ev);
X  		_Ximp_MakeKeypress (d, w, ev);
X  		ev->send_event = False ;
! 		XPutBackEvent(d, (XEvent *)ev);
X          }
X  	return (True);
X  }
*** /tmp/,RCSt1000365	Tue Mar 17 11:58:07 1992
--- mit/lib/X/Ximp/XimpCT.c	Tue Mar  3 11:03:18 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpCT.c,v 1.2 91/07/30 14:27:12 rws Exp $ */
X  /*
X   * Copyright 1990, 1991 by TOSHIBA Corp.
X   * Copyright 1990, 1991 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: XimpCT.c,v 1.3 92/03/03 11:02:11 rws Exp $ */
X  /*
X   * Copyright 1990, 1991 by TOSHIBA Corp.
X   * Copyright 1990, 1991 by SORD Computer Corp.
***************
*** 213,219 ****
X  	    if (ctext_len < 1)
X  		return -1;
X  
! 	    if (ctext_len > 4 && *ctptr++ == '%') {
X  		ch = *ctptr++;
X  		if (ch < 0x30 || ch > 0x3f)
X  		    goto unknown;
--- 213,219 ----
X  	    if (ctext_len < 1)
X  		return -1;
X  
! 	    if (ctext_len > 4 && *ctptr++ == '/') {
X  		ch = *ctptr++;
X  		if (ch < 0x30 || ch > 0x3f)
X  		    goto unknown;
*** /tmp/,RCSt1000382	Tue Mar 17 11:58:16 1992
--- mit/lib/X/Ximp/XimpICG.c	Tue Mar  3 11:02:23 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpICG.c,v 1.5 91/10/10 20:08:25 rws Exp $ */
X  /******************************************************************
X  
X      Copyright 1991, by FUJITSU LIMITED.
--- 1,4 ----
! /* $XConsortium: XimpICG.c,v 1.6 92/03/03 11:01:06 rws Exp $ */
X  /******************************************************************
X  
X      Copyright 1991, by FUJITSU LIMITED.
***************
*** 153,158 ****
--- 153,159 ----
X  	int		 im_font_flag    = 0;
X  	Ximp_PreeditPropRec	*preedit_data;
X  	XIMCallback 	*p_callback;
+ 	XPointer	*xptr;
X  
X  	if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver) {
X  		for(mask = 0, p = vl; p->name != NULL; p++) {
***************
*** 209,221 ****
X  			}
X  		} else if(strcmp(p->name, XNAreaNeeded)==0) {
X  			if(im_preedit_flag) {
! 				p_rect =  (XRectangle *)(p->value) ;
X  				p_rect->x  = p_rect->y  = 0;
X  				p_rect->width   = preedit_data->AreaNeeded.width;
X  				p_rect->height  = preedit_data->AreaNeeded.height;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_AREANEED_MASK) {
! 				        p_rect = (XRectangle *)(p->value) ;
X  					p_rect->x  = p_rect->y  = 0;
X  					p_rect->width   = ic->core.preedit_attr.area_needed.width;
X  					p_rect->height  = ic->core.preedit_attr.area_needed.height;
--- 210,226 ----
X  			}
X  		} else if(strcmp(p->name, XNAreaNeeded)==0) {
X  			if(im_preedit_flag) {
! 				p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle));
! 				xptr = (XPointer *)p->value;
! 				*xptr = (XPointer)p_rect;
X  				p_rect->x  = p_rect->y  = 0;
X  				p_rect->width   = preedit_data->AreaNeeded.width;
X  				p_rect->height  = preedit_data->AreaNeeded.height;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_AREANEED_MASK) {
! 					p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle));
! 					xptr = (XPointer *)p->value;
! 					*xptr = (XPointer)p_rect;
X  					p_rect->x  = p_rect->y  = 0;
X  					p_rect->width   = ic->core.preedit_attr.area_needed.width;
X  					p_rect->height  = ic->core.preedit_attr.area_needed.height;
***************
*** 226,237 ****
X  			}
X  		} else if(strcmp(p->name, XNSpotLocation)==0) {
X  			if(im_preedit_flag) {
! 			        p_point = (XPoint *)(p->value);
X  				p_point->x = preedit_data->SpotLocation.x;
X  				p_point->y = preedit_data->SpotLocation.y;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_SPOTL_MASK) {
! 				        p_point = (XPoint *)(p->value);
X  					p_point->x = ic->core.preedit_attr.spot_location.x;
X  					p_point->y = ic->core.preedit_attr.spot_location.y;
X  				} else {
--- 231,246 ----
X  			}
X  		} else if(strcmp(p->name, XNSpotLocation)==0) {
X  			if(im_preedit_flag) {
! 				p_point = (XPoint *)Xmalloc(sizeof(XPoint));
! 				xptr = (XPointer *)p->value;
! 				*xptr = (XPointer)p_point;
X  				p_point->x = preedit_data->SpotLocation.x;
X  				p_point->y = preedit_data->SpotLocation.y;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_PRE_SPOTL_MASK) {
! 					p_point = (XPoint *)Xmalloc(sizeof(XPoint));
! 					xptr = (XPointer *)p->value;
! 					*xptr = (XPointer)p_point;
X  					p_point->x = ic->core.preedit_attr.spot_location.x;
X  					p_point->y = ic->core.preedit_attr.spot_location.y;
X  				} else {
***************
*** 391,396 ****
--- 400,406 ----
X  	int		 im_font_flag    = 0;
X  	Ximp_StatusPropRec	*status_data;
X  	XIMCallback 	*p_callback;
+ 	XPointer	*xptr;
X  
X  	if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver) {
X  		for(mask = 0, p = vl; p->name != NULL; p++) {
***************
*** 446,458 ****
X  			}
X  		} else if(strcmp(p->name, XNAreaNeeded)==0) {
X  			if(im_status_flag) {
! 				p_rect =  (XRectangle *)(p->value) ;
X  				p_rect->x  = p_rect->y  = 0;
X  				p_rect->width   = status_data->AreaNeeded.width;
X  				p_rect->height  = status_data->AreaNeeded.height;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREANEED_MASK) {
! 					p_rect =  (XRectangle *)(p->value) ;
X  					p_rect->x  = p_rect->y  = 0;
X  					p_rect->width   = ic->core.status_attr.area_needed.width;
X  					p_rect->height  = ic->core.status_attr.area_needed.height;
--- 456,472 ----
X  			}
X  		} else if(strcmp(p->name, XNAreaNeeded)==0) {
X  			if(im_status_flag) {
! 				p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle));
! 				xptr = (XPointer *)p->value;
! 				*xptr = (XPointer)p_rect;
X  				p_rect->x  = p_rect->y  = 0;
X  				p_rect->width   = status_data->AreaNeeded.width;
X  				p_rect->height  = status_data->AreaNeeded.height;
X  			} else {
X  				if(ic->ximp_icpart->proto_mask & XIMP_STS_AREANEED_MASK) {
! 					p_rect = (XRectangle *)Xmalloc(sizeof(XRectangle));
! 					xptr = (XPointer *)p->value;
! 					*xptr = (XPointer)p_rect;
X  					p_rect->x  = p_rect->y  = 0;
X  					p_rect->width   = ic->core.status_attr.area_needed.width;
X  					p_rect->height  = ic->core.status_attr.area_needed.height;
*** /tmp/,RCSt1000399	Tue Mar 17 11:58:24 1992
--- mit/lib/X/Ximp/XimpRm.c	Tue Mar  3 11:04:09 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpRm.c,v 1.2 91/10/07 17:50:27 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XimpRm.c,v 1.3 92/03/03 11:03:30 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, by FUJITSU LIMITED
***************
*** 124,130 ****
X  	XColor		 screen_def, exact_def;
X  	int		 num;
X  
! 	im = (Ximp_XIM)XIMOfIC(ic);
X  	if(im->core.rdb == NULL)
X  		return;
X  
--- 124,130 ----
X  	XColor		 screen_def, exact_def;
X  	int		 num;
X  
! 	im = (Ximp_XIM)XIMOfIC((XIC)ic);
X  	if(im->core.rdb == NULL)
X  		return;
X  
*** /tmp/,RCSt1029884	Tue Mar 17 11:38:34 1992
--- mit/lib/Xt/Shell.c	Fri Feb 21 12:42:37 1992
***************
*** 1,4 ****
! /* $XConsortium: Shell.c,v 1.120 91/12/06 16:16:40 converse Exp $ */
X  
X  /***********************************************************
X  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Shell.c,v 1.124 92/02/21 12:34:32 converse Exp $ */
X  
X  /***********************************************************
X  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 1104,1111 ****
X  	    || sizep->max_aspect.y != XtUnspecifiedShellInt) {
X  	    sizep->flags |= PAspect;
X  	}
! 	if(w->wm.base_width != XtUnspecifiedShellInt
! 	   || w->wm.base_height != XtUnspecifiedShellInt) {
SHAR_EOF
true || echo 'restore of fix-10 failed'
fi
echo 'End of  part 1'
echo 'File fix-10 is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
-- 
---
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
