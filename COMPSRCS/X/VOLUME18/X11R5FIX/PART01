Newsgroups: comp.sources.x
From: Donna Converse <converse@expo.lcs.mit.edu>
Subject: v18i060: X11R5 public fix #14, Part01/02
Message-ID: <csx-18i060-X11R5-fix14@uunet.UU.NET>
Date: Tue, 28 Jul 1992 21:50:27 GMT
Approved: dcmartin@msi.com

Submitted-by: Donna Converse <converse@expo.lcs.mit.edu>
Posting-number: Volume 18, Issue 60
Archive-name: X11R5-fix14/part01

Fix 14 corrects the following problems:

An enhancement to Xlib for the X Consortium's Xlib and X Protocol Test Suite:
the test suite can now use the internal interface _XConnectDisplay to obtain
raw connections to the X server, thus allowing maximum portable protocol test
coverage.  In order to ensure this coverage, set XP_OPEN_DIS to XlibXtst.c
when configuring the Xlib and X Protocol Test Suite.

Xlib: IO error during connect may dereference NULL
Xlib: duplicate free() in XCloseDisplay from IO error handler
Xlib: could use better _XConnectDisplay interface for test suite
Xlib: XCloseDisplay does not free memory
Xlib: endian definition is missing when compiling XConnDis.c for OSF1
Xlib and Xt: LATIN2 keysyms are not handled correctly in ConvertCase
Xlib and Xt: Latin-3 case converter
Xt: XIM w/ keycode 0 (as defined by Xlib I18N) does not work with Xt
Xt: XtCreateWidget errs when parent is an Object, not a Widget
Xt: SetValues on TopLevelShell's iconic resource when popped_up is True
Xt: set values on iconic resource should not affect initialState
Xt: identifyWindows hack clobbers real information
Xt: frees memory returned by Xlib with Xt interface
Xt: unintentional reference inside Display structure
Xt: geometry requests with SetValues 
Xt: release of passive grab not recognized
Xt: XtOpenDisplay ignores -name when appl_name parameter is present
Xt: XtOpenDisplay should check that argv[0] isn't the empty string
Xt: XtCloseDisplay frees NULL per-display keysyms
Xext: XShmPutImage missing gc update
fonts: missing copyright for Bitstream Courier Speedo fonts

#!/bin/sh
# This is a shell archive (produced by shar 3.50)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 07/28/1992 21:47 UTC by dcmartin@fascet
# Source directory /n/merlin/u2/src/X11R5/fixes
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#  66153 -rw-r--r-- fix-14
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= fix-14 ==============
if test -f 'fix-14' -a X"$1" != X"-c"; then
	echo 'x - skipping fix-14 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting fix-14 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'fix-14' &&
X                      Release 5 Public Patch #14
X                           MIT X Consortium
X
To apply this patch:
X
cd to the top of the source tree (to the directory containing the "mit"
and "contrib" subdirectories) and do:
X        patch -p -s < ThisFile
Patch will work silently unless an error occurs.
If you want to watch patch do its thing, leave out the "-s" argument to patch.
X
Finally, to rebuild after applying this patch, cd to the "mit" subdirectory
and do:
X        make -k >& make.log
X
X
Brief notes on what this patch fixes:
X
An enhancement to Xlib for the X Consortium's Xlib and X Protocol Test Suite:
the test suite can now use the internal interface _XConnectDisplay to obtain
raw connections to the X server, thus allowing maximum portable protocol test
coverage.  In order to ensure this coverage, set XP_OPEN_DIS to XlibXtst.c
when configuring the Xlib and X Protocol Test Suite.
X
XXlib: IO error during connect may dereference NULL
XXlib: duplicate free() in XCloseDisplay from IO error handler
XXlib: could use better _XConnectDisplay interface for test suite
XXlib: XCloseDisplay does not free memory
XXlib: endian definition is missing when compiling XConnDis.c for OSF1
XXlib and Xt: LATIN2 keysyms are not handled correctly in ConvertCase
XXlib and Xt: Latin-3 case converter
XXt: XIM w/ keycode 0 (as defined by Xlib I18N) does not work with Xt
XXt: XtCreateWidget errs when parent is an Object, not a Widget
XXt: SetValues on TopLevelShell's iconic resource when popped_up is True
XXt: set values on iconic resource should not affect initialState
XXt: identifyWindows hack clobbers real information
XXt: frees memory returned by Xlib with Xt interface
XXt: unintentional reference inside Display structure
XXt: geometry requests with SetValues 
XXt: release of passive grab not recognized
XXt: XtOpenDisplay ignores -name when appl_name parameter is present
XXt: XtOpenDisplay should check that argv[0] isn't the empty string
XXt: XtCloseDisplay frees NULL per-display keysyms
XXext: XShmPutImage missing gc update
fonts: missing copyright for Bitstream Courier Speedo fonts
X
X
Prereq: public-patch-13
X
*** /tmp/da4676	Thu Jul 23 17:28:01 1992
--- mit/bug-report	Thu Jul 23 17:28:00 1992
***************
*** 2,8 ****
X  Subject: [area]: [synopsis]   [replace with actual area and short description]
X  
X  VERSION:
!     R5, public-patch-13
X      [MIT public patches will edit this line to indicate the patch level]
X  
X  CLIENT MACHINE and OPERATING SYSTEM:
--- 2,8 ----
X  Subject: [area]: [synopsis]   [replace with actual area and short description]
X  
X  VERSION:
!     R5, public-patch-14
X      [MIT public patches will edit this line to indicate the patch level]
X  
X  CLIENT MACHINE and OPERATING SYSTEM:
*** /tmp/,RCSt1a12623	Wed Jul 22 16:13:32 1992
--- mit/lib/X/XClDisplay.c	Wed Jul 22 16:13:32 1992
***************
*** 1,4 ****
! /* $XConsortium: XClDisplay.c,v 11.22 90/12/09 16:27:45 rws Exp $ */
X  /*
X  
X  Copyright 1985, 1990 by the Massachusetts Institute of Technology
--- 1,4 ----
! /* $XConsortium: XClDisplay.c,v 11.24 91/12/19 18:06:28 rws Exp $ */
X  /*
X  
X  Copyright 1985, 1990 by the Massachusetts Institute of Technology
***************
*** 19,27 ****
X  
X  /* 
X   * XCloseDisplay - XSync the connection to the X Server, close the connection,
!  * and free all associated storage.  This is the only routine that can be
!  * called from or after an IOError handler, so the lower levels need to be able
!  * to deal with broken connections.  Extension close procs should only free
X   * memory and must be careful about the types of requests they generate.
X   */
X  
--- 19,25 ----
X  
X  /* 
X   * XCloseDisplay - XSync the connection to the X Server, close the connection,
!  * and free all associated storage.  Extension close procs should only free
X   * memory and must be careful about the types of requests they generate.
X   */
X  
***************
*** 32,54 ****
X  	register int i;
X  	extern void _XFreeQ();
X  
! 	dpy->flags |= XlibDisplayClosing;
! 	for (i = 0; i < dpy->nscreens; i++) {
! 		register Screen *sp = &dpy->screens[i];
! 		XFreeGC (dpy, sp->default_gc);
X  	}
- 	if (dpy->cursor_font != None) {
- 	    XUnloadFont (dpy, dpy->cursor_font);
- 	}
- 	XSync(dpy, 1);  /* throw away pending input events */
- 	ext = dpy->ext_procs;
- 	while (ext) {		/* call out to any extensions interested */
- 		if (ext->close_display != NULL) 
- 			(*ext->close_display)(dpy, &ext->codes);
- 		ext = ext->next;
- 	}    
-         LockDisplay(dpy);
X  	_XDisconnectDisplay(dpy->fd);
X  	_XFreeQ ();
X  	return;
X  }
--- 30,55 ----
X  	register int i;
X  	extern void _XFreeQ();
X  
! 	if (!(dpy->flags & XlibDisplayClosing))
! 	{
! 	    dpy->flags |= XlibDisplayClosing;
! 	    for (i = 0; i < dpy->nscreens; i++) {
! 		    register Screen *sp = &dpy->screens[i];
! 		    XFreeGC (dpy, sp->default_gc);
! 	    }
! 	    if (dpy->cursor_font != None) {
! 		XUnloadFont (dpy, dpy->cursor_font);
! 	    }
! 	    ext = dpy->ext_procs;
! 	    while (ext) {	/* call out to any extensions interested */
! 		    if (ext->close_display != NULL) 
! 			    (*ext->close_display)(dpy, &ext->codes);
! 		    ext = ext->next;
! 	    }    
! 	    XSync(dpy, 1);  /* throw away pending input events */
X  	}
X  	_XDisconnectDisplay(dpy->fd);
+ 	_XFreeDisplayStructure (dpy);
X  	_XFreeQ ();
X  	return;
X  }
*** /tmp/,RCSt1a12630	Wed Jul 22 16:13:34 1992
--- mit/lib/X/XConnDis.c	Wed Jul 22 16:13:34 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: XConnDis.c,v 11.86 91/09/09 18:54:35 rws Exp $
X   *
X   * Copyright 1989 Massachusetts Institute of Technology
X   *
--- 1,5 ----
X  /*
!  * $XConsortium: XConnDis.c,v 11.88 91/12/17 17:55:57 rws Exp $
X   *
X   * Copyright 1989 Massachusetts Institute of Technology
X   *
***************
*** 58,63 ****
--- 58,64 ----
X  extern int _XMakeStreamsConnection();
X  #endif
X  
+ static void GetAuthorization();
X  
X  static char *copystring (src, len)
X      char *src;
***************
*** 91,105 ****
X   *     o  TCP to local host
X   */
X  int _XConnectDisplay (display_name, fullnamep, dpynump, screenp,
! 		      familyp, saddrlenp, saddrp)
X      char *display_name;
X      char **fullnamep;			/* RETURN */
X      int *dpynump;			/* RETURN */
X      int *screenp;			/* RETURN */
!     int *familyp;			/* RETURN */
!     int *saddrlenp;			/* RETURN */
!     char **saddrp;			/* RETURN, freed by caller */
X  {
X      char *lastp, *p;			/* char pointers */
X      char *phostname = NULL;		/* start of host of display */
X      char *pdpynum = NULL;		/* start of dpynum of display */
--- 92,110 ----
X   *     o  TCP to local host
X   */
X  int _XConnectDisplay (display_name, fullnamep, dpynump, screenp,
! 		      auth_namep, auth_namelenp, auth_datap, auth_datalenp)
X      char *display_name;
X      char **fullnamep;			/* RETURN */
X      int *dpynump;			/* RETURN */
X      int *screenp;			/* RETURN */
!     char **auth_namep;			/* RETURN */
!     int *auth_namelenp;			/* RETURN */
!     char **auth_datap;			/* RETURN */
!     int *auth_datalenp;			/* RETURN */
X  {
+     int family;
+     int saddrlen;
+     char *saddr;
X      char *lastp, *p;			/* char pointers */
X      char *phostname = NULL;		/* start of host of display */
X      char *pdpynum = NULL;		/* start of dpynum of display */
***************
*** 113,120 ****
X  
X      p = display_name;
X  
!     *saddrlenp = 0;			/* set so that we can clear later */
!     *saddrp = NULL;
X  
X      /*
X       * Step 1, find the hostname.  This is delimited by the required 
--- 118,125 ----
X  
X      p = display_name;
X  
!     saddrlen = 0;			/* set so that we can clear later */
!     saddr = NULL;
X  
X      /*
X       * Step 1, find the hostname.  This is delimited by the required 
***************
*** 250,263 ****
X  	char hostnamebuf[256];
X  	int len = _XGetHostname (hostnamebuf, sizeof hostnamebuf);
X  
! 	*familyp = FamilyLocal;
X  	if (len > 0) {
! 	    *saddrp = Xmalloc (len + 1);
! 	    if (*saddrp) {
! 		strcpy (*saddrp, hostnamebuf);
! 		*saddrlenp = len;
X  	    } else {
! 		*saddrlenp = 0;
X  	    }
X  	}
X      }
--- 255,268 ----
X  	char hostnamebuf[256];
X  	int len = _XGetHostname (hostnamebuf, sizeof hostnamebuf);
X  
! 	family = FamilyLocal;
X  	if (len > 0) {
! 	    saddr = Xmalloc (len + 1);
! 	    if (saddr) {
! 		strcpy (saddr, hostnamebuf);
! 		saddrlen = len;
X  	    } else {
! 		saddrlen = 0;
X  	    }
X  	}
X      }
***************
*** 272,278 ****
X       * too many times).
X       */
X      if ((fd = (*connfunc) (phostname, idisplay, X_CONNECTION_RETRIES,
! 			   familyp, saddrlenp, saddrp)) < 0)
X        goto bad;
X      if (fd >= OPEN_MAX)
X  	goto bad;
--- 277,283 ----
X       * too many times).
X       */
X      if ((fd = (*connfunc) (phostname, idisplay, X_CONNECTION_RETRIES,
! 			   &family, &saddrlen, &saddr)) < 0)
X        goto bad;
X      if (fd >= OPEN_MAX)
X  	goto bad;
***************
*** 306,311 ****
--- 311,319 ----
X      if (phostname) Xfree (phostname);
X      if (pdpynum) Xfree (pdpynum);
X      if (pscrnum) Xfree (pscrnum);
+ 
+     GetAuthorization(fd, family, saddr, saddrlen, idisplay,
+ 		     auth_namep, auth_namelenp, auth_datap, auth_datalenp);
X      return fd;
X  
X  
***************
*** 314,324 ****
X       */
X    bad:
X      if (fd >= 0) (void) close (fd);
!     if (*saddrp) {
! 	Xfree (*saddrp);
! 	*saddrp = NULL;
!     }
!     *saddrlenp = 0;
X      if (phostname) Xfree (phostname);
X      if (pdpynum) Xfree (pdpynum);
X      if (pscrnum) Xfree (pscrnum);
--- 322,328 ----
X       */
X    bad:
X      if (fd >= 0) (void) close (fd);
!     if (saddr) Xfree (saddr);
X      if (phostname) Xfree (phostname);
X      if (pdpynum) Xfree (pdpynum);
X      if (pscrnum) Xfree (pscrnum);
***************
*** 358,363 ****
--- 362,370 ----
X  #endif
X  #endif
X  #ifndef NO_TCP_H
+ #ifdef __OSF1__
+ #include <sys/param.h>
+ #endif
X  #include <netinet/tcp.h>
X  #endif
X  #endif /* NEED_BSDISH */
***************
*** 421,426 ****
--- 428,434 ----
X  #ifdef UNIXCONN
X  #include <sys/un.h>
X  
+ /*ARGSUSED*/
X  static int MakeUNIXSocketConnection (phostname, idisplay, retries,
X  				     familyp, saddrlenp, saddrp)
X      char *phostname;
***************
*** 670,677 ****
X  
X  
X  
- #undef NULL
- #define NULL ((char *) 0)
X  /*
X   * This is an OS dependent routine which:
X   * 1) returns as soon as the connection can be written on....
--- 678,683 ----
***************
*** 693,699 ****
X          BITSET(w_mask, dpy->fd);
X  
X  	do {
! 	    nfound = select (dpy->fd + 1, r_mask, w_mask, NULL, NULL);
X  	    if (nfound < 0 && errno != EINTR)
X  		_XIOError(dpy);
X  	} while (nfound <= 0);
--- 699,706 ----
X          BITSET(w_mask, dpy->fd);
X  
X  	do {
! 	    nfound = select (dpy->fd + 1, r_mask, w_mask,
! 			     (char *)NULL, (char *)NULL);
X  	    if (nfound < 0 && errno != EINTR)
X  		_XIOError(dpy);
X  	} while (nfound <= 0);
***************
*** 746,752 ****
X      CLEARBITS(r_mask);
X      do {
X  	BITSET(r_mask, dpy->fd);
! 	result = select(dpy->fd + 1, r_mask, NULL, NULL, NULL);
X  	if (result == -1 && errno != EINTR) _XIOError(dpy);
X      } while (result <= 0);
X  }
--- 753,760 ----
X      CLEARBITS(r_mask);
X      do {
X  	BITSET(r_mask, dpy->fd);
! 	result = select(dpy->fd + 1, r_mask,
! 			(char *)NULL, (char *)NULL, (char *)NULL);
X  	if (result == -1 && errno != EINTR) _XIOError(dpy);
X      } while (result <= 0);
X  }
***************
*** 816,819 ****
--- 824,1154 ----
X  #endif
X  #endif
X      return len == 0;
+ }
+ 
+ 
+ #ifdef STREAMSCONN
+ #ifdef SVR4
+ #include <tiuser.h>
+ #else
+ #undef HASXDMAUTH
+ #endif
+ #endif
+ 
+ #ifdef SECURE_RPC
+ #include <rpc/rpc.h>
+ #ifdef ultrix
+ #include <time.h>
+ #include <rpc/auth_des.h>
+ #endif
+ #endif
+ 
+ /*
+  * First, a routine for setting authorization data
+  */
+ static int xauth_namelen = 0;
+ static char *xauth_name = NULL;	 /* NULL means use default mechanism */
+ static int xauth_datalen = 0;
+ static char *xauth_data = NULL;	 /* NULL means get default data */
+ 
+ /*
+  * This is a list of the authorization names which Xlib currently supports.
+  * Xau will choose the file entry which matches the earliest entry in this
+  * array, allowing us to prioritize these in terms of the most secure first
+  */
+ 
+ static char *default_xauth_names[] = {
+ #ifdef SECURE_RPC
+     "SUN-DES-1",
+ #endif
+ #ifdef HASXDMAUTH
+     "XDM-AUTHORIZATION-1",
+ #endif
+     "MIT-MAGIC-COOKIE-1"
+ };
+ 
+ static int default_xauth_lengths[] = {
+ #ifdef SECURE_RPC
+     9,	    /* strlen ("SUN-DES-1") */
+ #endif
+ #ifdef HASXDMAUTH
+     19,	    /* strlen ("XDM-AUTHORIZATION-1") */
+ #endif
+     18	    /* strlen ("MIT-MAGIC-COOKIE-1") */
+ };
+ 
+ #define NUM_DEFAULT_AUTH    (sizeof (default_xauth_names) / sizeof (default_xauth_names[0]))
+     
+ static char **xauth_names = default_xauth_names;
+ static int  *xauth_lengths = default_xauth_lengths;
+ 
+ static int  xauth_names_length = NUM_DEFAULT_AUTH;
+ 
+ void XSetAuthorization (name, namelen, data, datalen)
+     int namelen, datalen;		/* lengths of name and data */
+     char *name, *data;			/* NULL or arbitrary array of bytes */
+ {
+     char *tmpname, *tmpdata;
+ 
+     if (xauth_name) Xfree (xauth_name);	 /* free any existing data */
+     if (xauth_data) Xfree (xauth_data);
+ 
+     xauth_name = xauth_data = NULL;	/* mark it no longer valid */
+     xauth_namelen = xauth_datalen = 0;
+ 
+     if (namelen < 0) namelen = 0;	/* check for bogus inputs */
+     if (datalen < 0) datalen = 0;	/* maybe should return? */
+ 
+     if (namelen > 0)  {			/* try to allocate space */
+ 	tmpname = Xmalloc ((unsigned) namelen);
+ 	if (!tmpname) return;
+ 	bcopy (name, tmpname, namelen);
+     } else {
+ 	tmpname = NULL;
+     }
+ 
+     if (datalen > 0)  {
+ 	tmpdata = Xmalloc ((unsigned) datalen);
+ 	if (!tmpdata) {
+ 	    if (tmpname) (void) Xfree (tmpname);
+ 	    return;
+ 	}
+ 	bcopy (data, tmpdata, datalen);
+     } else {
+ 	tmpdata = NULL;
+     }
+ 
+     xauth_name = tmpname;		/* and store the suckers */
+     xauth_namelen = namelen;
+     if (tmpname)
+     {
+ 	xauth_names = &xauth_name;
+ 	xauth_lengths = &xauth_namelen;
+ 	xauth_names_length = 1;
+     }
+     else
+     {
+ 	xauth_names = default_xauth_names;
+ 	xauth_lengths = default_xauth_lengths;
+ 	xauth_names_length = NUM_DEFAULT_AUTH;
+     }
+     xauth_data = tmpdata;
+     xauth_datalen = datalen;
+     return;
+ }
+ 
+ #ifdef SECURE_RPC
+ /*
+  * Create a credential that we can send to the X server.
+  */
+ static int
+ auth_ezencode(servername, window, cred_out, len)
+         char           *servername;
+         int             window;
+ 	char	       *cred_out;
+         int            *len;
+ {
+         AUTH           *a;
+         XDR             xdr;
+ 
+         a = authdes_create(servername, window, NULL, NULL);
+         if (a == (AUTH *)NULL) {
+                 perror("auth_create");
+                 return 0;
+         }
+         xdrmem_create(&xdr, cred_out, *len, XDR_ENCODE);
+         if (AUTH_MARSHALL(a, &xdr) == FALSE) {
+                 perror("auth_marshall");
+                 AUTH_DESTROY(a);
+                 return 0;
+         }
+         *len = xdr_getpos(&xdr);
+         AUTH_DESTROY(a);
+ 	return 1;
+ }
+ #endif
+ 
+ static void
+ GetAuthorization(fd, family, saddr, saddrlen, idisplay,
+ 		 auth_namep, auth_namelenp, auth_datap, auth_datalenp)
+     int fd;
+     int family;
+     int saddrlen;
+     int idisplay;
+     char *saddr;
+     char **auth_namep;			/* RETURN */
+     int *auth_namelenp;			/* RETURN */
+     char **auth_datap;			/* RETURN */
+     int *auth_datalenp;			/* RETURN */
+ {
+ #ifdef SECURE_RPC
+     char rpc_cred[MAX_AUTH_BYTES];
+ #endif
+ #ifdef HASXDMAUTH
+     char xdmcp_data[192/8];
+ #endif
+     char *auth_name;
+     int auth_namelen;
+     char *auth_data;
+     int auth_datalen;
+     Xauth *authptr = NULL;
+ 
+ /*
+  * Look up the authorization protocol name and data if necessary.
+  */
+     if (xauth_name && xauth_data) {
+ 	auth_namelen = xauth_namelen;
+ 	auth_name = xauth_name;
+ 	auth_datalen = xauth_datalen;
+ 	auth_data = xauth_data;
+     } else {
+ 	char dpynumbuf[40];		/* big enough to hold 2^64 and more */
+ 	(void) sprintf (dpynumbuf, "%d", idisplay);
+ 
+ 	authptr = XauGetBestAuthByAddr ((unsigned short) family,
+ 				    (unsigned short) saddrlen,
+ 				    saddr,
+ 				    (unsigned short) strlen (dpynumbuf),
+ 				    dpynumbuf,
+ 				    xauth_names_length,
+ 				    xauth_names,
+ 				    xauth_lengths);
+ 	if (authptr) {
+ 	    auth_namelen = authptr->name_length;
+ 	    auth_name = (char *)authptr->name;
+ 	    auth_datalen = authptr->data_length;
+ 	    auth_data = (char *)authptr->data;
+ 	} else {
+ 	    auth_namelen = 0;
+ 	    auth_name = NULL;
+ 	    auth_datalen = 0;
+ 	    auth_data = NULL;
+ 	}
+     }
+ #ifdef HASXDMAUTH
+     /*
+      * build XDM-AUTHORIZATION-1 data
+      */
+     if (auth_namelen == 19 && !strncmp (auth_name, "XDM-AUTHORIZATION-1", 19))
+     {
+ 	int     j;
+ 	long    now;
+ 	for (j = 0; j < 8; j++)
+ 	    xdmcp_data[j] = auth_data[j];
+ #ifdef STREAMSCONN /* && SVR4 */
+ 	{
+ 	    int			i;
+ 	    struct netbuf	netb;
+ 	    char		addrret[1024];
+ 
+ 	    netb.maxlen = sizeof addrret;
+ 	    netb.buf = addrret;
+ 	    if (t_getname (fd, &netb, LOCALNAME) == -1)
+ 		t_error ("t_getname");
+ 	    /*
+ 	     * XXX - assumes that the return data
+ 	     * are in a struct sockaddr_in, and that
+ 	     * the data structure is layed out in
+ 	     * the normal fashion.  This WILL NOT WORK
+ 	     * on a non 32-bit machine (same in Xstreams.c)
+ 	     */
+ 	    for (i = 4; i < 8; i++)
+ 		xdmcp_data[j++] = netb.buf[i];
+ 	    for (i = 2; i < 4; i++)
+ 		xdmcp_data[j++] = netb.buf[i];
+ 	}
+ #else
+ 	{
+ 	    unsigned long	addr;
+ 	    unsigned short	port;
+ #ifdef TCPCONN
+ 	    int	    addrlen;
+ 	    struct sockaddr_in	in_addr;
+ 
+ 	    addrlen = sizeof (in_addr);
+ 	    if (getsockname (fd,
+ 			     (struct sockaddr *) &in_addr,
+ 			     &addrlen) != -1 &&
+ 		addrlen >= sizeof in_addr &&
+ 		in_addr.sin_family == AF_INET)
+ 	    {
+ 		addr = ntohl (in_addr.sin_addr.s_addr);
+ 		port = ntohs (in_addr.sin_port);
+ 	    }
+ 	    else
+ #endif
+ 	    {
+ 		static unsigned long	unix_addr = 0xFFFFFFFF;
+ 		addr = unix_addr--;
+ 		port = getpid ();
+ 	    }
+ 	    xdmcp_data[j++] = (addr >> 24) & 0xFF;
+ 	    xdmcp_data[j++] = (addr >> 16) & 0xFF;
+ 	    xdmcp_data[j++] = (addr >>  8) & 0xFF;
+ 	    xdmcp_data[j++] = (addr >>  0) & 0xFF;
+ 	    xdmcp_data[j++] = (port >>  8) & 0xFF;
+ 	    xdmcp_data[j++] = (port >>  0) & 0xFF;
+ 	}
+ #endif
+ 	time (&now);
+ 	xdmcp_data[j++] = (now >> 24) & 0xFF;
+ 	xdmcp_data[j++] = (now >> 16) & 0xFF;
+ 	xdmcp_data[j++] = (now >>  8) & 0xFF;
+ 	xdmcp_data[j++] = (now >>  0) & 0xFF;
+ 	while (j < 192 / 8)
+ 	    xdmcp_data[j++] = 0;
+ 	XdmcpWrap (xdmcp_data, auth_data + 8,
+ 		      xdmcp_data, j);
+ 	auth_data = xdmcp_data;
+ 	auth_datalen = j;
+     }
+ #endif /* HASXDMAUTH */
+ #ifdef SECURE_RPC
+     /*
+      * The SUN-DES-1 authorization protocol uses the
+      * "secure RPC" mechanism in SunOS 4.0+.
+      */
+     if (auth_namelen == 9 && !strncmp(auth_name, "SUN-DES-1", 9)) {
+ 	char servernetname[MAXNETNAMELEN + 1];
+ 
+ 	/*
+ 	 * Copy over the server's netname from the authorization
+ 	 * data field filled in by XauGetAuthByAddr().
+ 	 */
+ 	if (auth_datalen > MAXNETNAMELEN) {
+ 	    auth_datalen = 0;
+ 	    auth_data = NULL;
+ 	} else {
+ 	    bcopy(auth_data, servernetname, auth_datalen);
+ 	    servernetname[auth_datalen] = '\0';
+ 
+ 	    auth_datalen = sizeof (rpc_cred);
+ 	    if (auth_ezencode(servernetname, 100, rpc_cred,
+ 			      &auth_datalen))
+ 		auth_data = rpc_cred;
+ 	    else
+ 		auth_data = NULL;
+ 	}
+     }
+ #endif
+     if (saddr) Xfree (saddr);
+     if (*auth_namelenp = auth_namelen)
+     {
+ 	if (*auth_namep = Xmalloc(auth_namelen))
+ 	    bcopy(auth_name, *auth_namep, auth_namelen);
+ 	else
+ 	    *auth_namelenp = 0;
+     }
+     else
+ 	*auth_namep = NULL;
+     if (*auth_datalenp = auth_datalen)
+     {
+ 	if (*auth_datap = Xmalloc(auth_datalen))
+ 	    bcopy(auth_data, *auth_datap, auth_datalen);
+ 	else
+ 	    *auth_datalenp = 0;
+     }
+     else
+ 	*auth_datap = NULL;
+     if (authptr) XauDisposeAuth (authptr);
X  }
*** /tmp/,RCSt1a12637	Wed Jul 22 16:13:36 1992
--- mit/lib/X/XFont.c	Wed Jul 22 16:13:36 1992
***************
*** 1,4 ****
! /* $XConsortium: XFont.c,v 11.37 91/01/06 11:45:39 rws Exp $ */
X  /* Copyright    Massachusetts Institute of Technology    1986	*/
X  
X  /*
--- 1,4 ----
! /* $XConsortium: XFont.c,v 11.38 91/12/19 18:14:14 rws Exp $ */
X  /* Copyright    Massachusetts Institute of Technology    1986	*/
X  
X  /*
***************
*** 81,86 ****
--- 81,88 ----
X  	ext = ext->next;
X  	}    
X      GetResReq (CloseFont, fs->fid, req);
+     UnlockDisplay(dpy);
+     SyncHandle();
X      _XFreeExtData(fs->ext_data);
X      if (fs->per_char)
X         Xfree ((char *) fs->per_char);
***************
*** 87,94 ****
X      if (fs->properties)
X         Xfree ((char *) fs->properties);
X      Xfree ((char *) fs);
-     UnlockDisplay(dpy);
-     SyncHandle();
X  }
X  
X  /*
--- 89,94 ----
*** /tmp/,RCSt1a12644	Wed Jul 22 16:13:37 1992
--- mit/lib/X/XFreeGC.c	Wed Jul 22 16:13:38 1992
***************
*** 1,4 ****
! /* $XConsortium: XFreeGC.c,v 11.11 91/05/02 18:16:02 rws Exp $ */
X  /* Copyright    Massachusetts Institute of Technology    1986	*/
X  
X  /*
--- 1,4 ----
! /* $XConsortium: XFreeGC.c,v 11.12 91/12/19 18:13:13 rws Exp $ */
X  /* Copyright    Massachusetts Institute of Technology    1986	*/
X  
X  /*
***************
*** 22,36 ****
X      register xResourceReq *req;
X      register _XExtension *ext;
X      LockDisplay(dpy);
-     GetResReq (FreeGC, gc->gid, req);
X      ext = dpy->ext_procs;
X      while (ext) {		/* call out to any extensions interested */
X  	if (ext->free_GC != NULL) (*ext->free_GC)(dpy, gc, &ext->codes);
X  	ext = ext->next;
X  	}    
!     _XFreeExtData(gc->ext_data);
!     Xfree ((char *) gc);
X      UnlockDisplay(dpy);
X      SyncHandle();
X      }
X      
--- 22,36 ----
X      register xResourceReq *req;
X      register _XExtension *ext;
X      LockDisplay(dpy);
X      ext = dpy->ext_procs;
X      while (ext) {		/* call out to any extensions interested */
X  	if (ext->free_GC != NULL) (*ext->free_GC)(dpy, gc, &ext->codes);
X  	ext = ext->next;
X  	}    
!     GetResReq (FreeGC, gc->gid, req);
X      UnlockDisplay(dpy);
X      SyncHandle();
+     _XFreeExtData(gc->ext_data);
+     Xfree ((char *) gc);
X      }
X      
*** /tmp/,RCSt1a12651	Wed Jul 22 16:13:39 1992
--- mit/lib/X/XOpenDis.c	Wed Jul 22 16:13:40 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: XOpenDis.c,v 11.120 91/09/09 14:47:58 rws Exp $
X   */
X  
X  /* Copyright    Massachusetts Institute of Technology    1985, 1986	*/
--- 1,5 ----
X  /*
!  * $XConsortium: XOpenDis.c,v 11.123 91/12/20 16:04:29 rws Exp $
X   */
X  
X  /* Copyright    Massachusetts Institute of Technology    1985, 1986	*/
***************
*** 16,50 ****
X  without express or implied warranty.
X  */
X  
- /* Converted to V11 by jg */
- 
X  #include <X11/Xlibint.h>
X  #include <X11/Xos.h>
- #ifdef HASXDMAUTH
- #include "Xlibnet.h"
- #if TCPCONN
- #include <sys/socket.h>
- #endif
- #endif
- #include <X11/Xauth.h>
X  #include <X11/Xatom.h>
- 
- #ifdef STREAMSCONN
- #ifdef SVR4
- #include <tiuser.h>
- #else
- #undef HASXDMAUTH
- #endif
- #endif
- 
- #ifdef SECURE_RPC
- #include <rpc/rpc.h>
- #ifdef ultrix
- #include <time.h>
- #include <rpc/auth_des.h>
- #endif
- #endif
- 
X  #include <stdio.h>
X  
X  #ifdef X_NOT_STDC_ENV
--- 16,24 ----
***************
*** 61,193 ****
X  	0, 0, 0
X  };
X  
- /*
-  * First, a routine for setting authorization data
-  */
- static int xauth_namelen = 0;
- static char *xauth_name = NULL;	 /* NULL means use default mechanism */
- static int xauth_datalen = 0;
- static char *xauth_data = NULL;	 /* NULL means get default data */
- 
- /*
-  * This is a list of the authorization names which Xlib currently supports.
-  * Xau will choose the file entry which matches the earliest entry in this
-  * array, allowing us to prioritize these in terms of the most secure first
-  */
- 
- static char *default_xauth_names[] = {
- #ifdef SECURE_RPC
-     "SUN-DES-1",
- #endif
- #ifdef HASXDMAUTH
-     "XDM-AUTHORIZATION-1",
- #endif
-     "MIT-MAGIC-COOKIE-1"
- };
- 
- static int default_xauth_lengths[] = {
- #ifdef SECURE_RPC
-     9,	    /* strlen ("SUN-DES-1") */
- #endif
- #ifdef HASXDMAUTH
-     19,	    /* strlen ("XDM-AUTHORIZATION-1") */
- #endif
-     18	    /* strlen ("MIT-MAGIC-COOKIE-1") */
- };
- 
- #define NUM_DEFAULT_AUTH    (sizeof (default_xauth_names) / sizeof (default_xauth_names[0]))
-     
- static char **xauth_names = default_xauth_names;
- static int  *xauth_lengths = default_xauth_lengths;
- 
- static int  xauth_names_length = NUM_DEFAULT_AUTH;
- 
X  static OutOfMemory();
X  
- void XSetAuthorization (name, namelen, data, datalen)
-     int namelen, datalen;		/* lengths of name and data */
-     char *name, *data;			/* NULL or arbitrary array of bytes */
- {
-     char *tmpname, *tmpdata;
- 
-     if (xauth_name) Xfree (xauth_name);	 /* free any existing data */
-     if (xauth_data) Xfree (xauth_data);
- 
-     xauth_name = xauth_data = NULL;	/* mark it no longer valid */
-     xauth_namelen = xauth_datalen = 0;
- 
-     if (namelen < 0) namelen = 0;	/* check for bogus inputs */
-     if (datalen < 0) datalen = 0;	/* maybe should return? */
- 
-     if (namelen > 0)  {			/* try to allocate space */
- 	tmpname = Xmalloc ((unsigned) namelen);
- 	if (!tmpname) return;
- 	bcopy (name, tmpname, namelen);
-     } else {
- 	tmpname = NULL;
-     }
- 
-     if (datalen > 0)  {
- 	tmpdata = Xmalloc ((unsigned) datalen);
- 	if (!tmpdata) {
- 	    if (tmpname) (void) Xfree (tmpname);
- 	    return;
- 	}
- 	bcopy (data, tmpdata, datalen);
-     } else {
- 	tmpdata = NULL;
-     }
- 
-     xauth_name = tmpname;		/* and store the suckers */
-     xauth_namelen = namelen;
-     if (tmpname)
-     {
- 	xauth_names = &xauth_name;
- 	xauth_lengths = &xauth_namelen;
- 	xauth_names_length = 1;
-     }
-     else
-     {
- 	xauth_names = default_xauth_names;
- 	xauth_lengths = default_xauth_lengths;
- 	xauth_names_length = NUM_DEFAULT_AUTH;
-     }
-     xauth_data = tmpdata;
-     xauth_datalen = datalen;
-     return;
- }
- 
- #ifdef SECURE_RPC
- /*
-  * Create a credential that we can send to the X server.
-  */
- static int
- auth_ezencode(servername, window, cred_out, len)
-         char           *servername;
-         int             window;
- 	char	       *cred_out;
-         int            *len;
- {
-         AUTH           *a;
-         XDR             xdr;
- 
-         a = authdes_create(servername, window, NULL, NULL);
-         if (a == (AUTH *)NULL) {
-                 perror("auth_create");
-                 return 0;
-         }
-         xdrmem_create(&xdr, cred_out, *len, XDR_ENCODE);
-         if (AUTH_MARSHALL(a, &xdr) == FALSE) {
-                 perror("auth_marshall");
-                 AUTH_DESTROY(a);
-                 return 0;
-         }
-         *len = xdr_getpos(&xdr);
-         AUTH_DESTROY(a);
- 	return 1;
- }
- #endif
- 
X  extern Bool _XWireToEvent();
X  extern Status _XUnknownNativeEvent();
X  extern Bool _XUnknownWireEvent();
--- 35,42 ----
***************
*** 211,217 ****
X  	xConnClientPrefix client;	/* client information */
X  	xConnSetupPrefix prefix;	/* prefix information */
X  	int vendorlen;			/* length of vendor string */
! 	char *setup;			/* memory allocated at startup */
X  	char *fullname = NULL;		/* expanded name of display */
X  	int idisplay;			/* display number */
X  	int iscreen;			/* screen number */
--- 60,66 ----
X  	xConnClientPrefix client;	/* client information */
X  	xConnSetupPrefix prefix;	/* prefix information */
X  	int vendorlen;			/* length of vendor string */
! 	char *setup = NULL;		/* memory allocated at startup */
X  	char *fullname = NULL;		/* expanded name of display */
X  	int idisplay;			/* display number */
X  	int iscreen;			/* screen number */
***************
*** 225,247 ****
X  		xVisualType *vp;
X  	} u;				/* proto data returned from server */
X  	long setuplength;	/* number of bytes in setup message */
- 	Xauth *authptr = NULL;
- 	char *server_addr = NULL;
- 	int server_addrlen = 0;
X  	char *conn_auth_name, *conn_auth_data;
X  	int conn_auth_namelen, conn_auth_datalen;
- 	int conn_family;
X  	unsigned long mask;
X  	extern Bool _XSendClientPrefix();
X  	extern int _XConnectDisplay();
X  	extern XID _XAllocID();
- #ifdef SECURE_RPC
- 	char	rpc_cred[MAX_AUTH_BYTES];
- #endif
-  
- #ifdef HASXDMAUTH
- 	char    xdmcp_data[192/8];
- #endif
X  
X  	/*
X  	 * If the display specifier string supplied as an argument to this 
--- 74,85 ----
***************
*** 286,435 ****
X   */
X  
X  	if ((dpy->fd = _XConnectDisplay (display_name, &fullname, &idisplay,
! 					 &iscreen, &conn_family,
! 					 &server_addrlen, &server_addr)) < 0) {
X  		Xfree ((char *) dpy);
X  		UnlockMutex(&lock);
X  		return(NULL);
X  	}
X  
X  /*
!  * Look up the authorization protocol name and data if necessary.
X   */
! 	if (xauth_name && xauth_data) {
! 	    conn_auth_namelen = xauth_namelen;
! 	    conn_auth_name = xauth_name;
! 	    conn_auth_datalen = xauth_datalen;
! 	    conn_auth_data = xauth_data;
! 	} else {
! 	    char dpynumbuf[40];		/* big enough to hold 2^64 and more */
! 	    (void) sprintf (dpynumbuf, "%d", idisplay);
X  
! 	    authptr = XauGetBestAuthByAddr ((unsigned short) conn_family,
! 					(unsigned short) server_addrlen,
! 					server_addr,
! 					(unsigned short) strlen (dpynumbuf),
! 					dpynumbuf,
! 					xauth_names_length,
! 					xauth_names,
! 					xauth_lengths);
! 	    if (authptr) {
! 		conn_auth_namelen = authptr->name_length;
! 		conn_auth_name = (char *)authptr->name;
! 		conn_auth_datalen = authptr->data_length;
! 		conn_auth_data = (char *)authptr->data;
! 	    } else {
! 		conn_auth_namelen = 0;
! 		conn_auth_name = NULL;
! 		conn_auth_datalen = 0;
! 		conn_auth_data = NULL;
! 	    }
X  	}
! #ifdef HASXDMAUTH
! 	/*
! 	 * build XDM-AUTHORIZATION-1 data
! 	 */
! 	if (conn_auth_namelen == 19 &&
! 	    !strncmp (conn_auth_name, "XDM-AUTHORIZATION-1", 19))
! 	{
! 	    int	    i, j;
! 	    long    now;
! 	    for (j = 0; j < 8; j++)
! 		xdmcp_data[j] = conn_auth_data[j];
! #ifdef STREAMSCONN /* && SVR4 */
! 	    {
! 	    	struct netbuf	netb;
! 	    	char		addrret[1024];
!     
! 	    	netb.maxlen = sizeof addrret;
! 	    	netb.buf = addrret;
! 	    	if (t_getname (dpy->fd, &netb, LOCALNAME) == -1)
! 		    t_error ("t_getname");
! 		/*
! 		 * XXX - assumes that the return data
! 		 * are in a struct sockaddr_in, and that
! 		 * the data structure is layed out in
! 		 * the normal fashion.  This WILL NOT WORK
! 		 * on a non 32-bit machine (same in Xstreams.c)
! 		 */
! 		for (i = 4; i < 8; i++)
! 		    xdmcp_data[j++] = netb.buf[i];
! 		for (i = 2; i < 4; i++)
! 		    xdmcp_data[j++] = netb.buf[i];
! 	    }
! #else
! 	    {
! 	    	unsigned long	addr;
! 	    	unsigned short	port;
! #ifdef TCPCONN
! 	    	int	    addrlen;
! 	    	struct sockaddr_in	in_addr;
!     
! 	    	addrlen = sizeof (in_addr);
! 	    	if (getsockname (dpy->fd,
! 				 (struct sockaddr *) &in_addr,
!  				 &addrlen) != -1 &&
! 		    addrlen >= sizeof in_addr &&
! 		    in_addr.sin_family == AF_INET)
! 	    	{
! 		    addr = ntohl (in_addr.sin_addr.s_addr);
! 		    port = ntohs (in_addr.sin_port);
! 	    	}
! 	    	else
! #endif
! 	    	{
! 		    static unsigned long	unix_addr = 0xFFFFFFFF;
! 		    addr = unix_addr--;
! 		    port = getpid ();
! 	    	}
! 	    	xdmcp_data[j++] = (addr >> 24) & 0xFF;
! 	    	xdmcp_data[j++] = (addr >> 16) & 0xFF;
! 	    	xdmcp_data[j++] = (addr >>  8) & 0xFF;
! 	    	xdmcp_data[j++] = (addr >>  0) & 0xFF;
! 	    	xdmcp_data[j++] = (port >>  8) & 0xFF;
! 	    	xdmcp_data[j++] = (port >>  0) & 0xFF;
! 	    }
! #endif
! 	    time (&now);
! 	    xdmcp_data[j++] = (now >> 24) & 0xFF;
! 	    xdmcp_data[j++] = (now >> 16) & 0xFF;
! 	    xdmcp_data[j++] = (now >>  8) & 0xFF;
! 	    xdmcp_data[j++] = (now >>  0) & 0xFF;
! 	    while (j < 192 / 8)
! 		xdmcp_data[j++] = 0;
! 	    XdmcpWrap (xdmcp_data, conn_auth_data + 8,
! 			  xdmcp_data, j);
! 	    conn_auth_data = xdmcp_data;
! 	    conn_auth_datalen = j;
X  	}
- #endif /* HASXDMAUTH */
- #ifdef SECURE_RPC
-         /*
-          * The SUN-DES-1 authorization protocol uses the
-          * "secure RPC" mechanism in SunOS 4.0+.
-          */
-         if (conn_auth_namelen == 9 && !strncmp(conn_auth_name,
-             "SUN-DES-1", 9)) {
-             static char servernetname[MAXNETNAMELEN + 1];
X  
-             /*
-              * Copy over the server's netname from the authorization
-              * data field filled in by XauGetAuthByAddr().
-              */
-             if (conn_auth_datalen > MAXNETNAMELEN) {
-                 return 0;
-             }
-             bcopy(conn_auth_data, servernetname, conn_auth_datalen);
-             servernetname[conn_auth_datalen] = '\0';
- 
- 	    conn_auth_datalen = sizeof (rpc_cred);
-             if (auth_ezencode(servernetname, 100, rpc_cred, &conn_auth_datalen))
- 		conn_auth_data = rpc_cred;
- 	    else
- 		conn_auth_data = NULL;
-         }
- #endif
- 	if (server_addr) (void) Xfree (server_addr);
X  /*
X   * The xConnClientPrefix describes the initial connection setup information
X   * and is followed by the authorization information.  Sites that are interested
--- 124,211 ----
X   */
X  
X  	if ((dpy->fd = _XConnectDisplay (display_name, &fullname, &idisplay,
! 					 &iscreen, &conn_auth_name,
! 					 &conn_auth_namelen, &conn_auth_data,
! 					 &conn_auth_datalen)) < 0) {
X  		Xfree ((char *) dpy);
X  		UnlockMutex(&lock);
X  		return(NULL);
X  	}
X  
+ 	/* Initialize as much of the display structure as we can */
+ 	dpy->display_name	= fullname;
+ 	dpy->keysyms		= (KeySym *) NULL;
+ 	dpy->modifiermap	= NULL;
+ 	dpy->lock_meaning	= NoSymbol;
+ 	dpy->keysyms_per_keycode = 0;
+ 	dpy->current		= None;
+ 	dpy->xdefaults		= (char *)NULL;
+ 	dpy->scratch_length	= 0L;
+ 	dpy->scratch_buffer	= NULL;
+ 	dpy->key_bindings	= NULL;
+ 	dpy->ext_procs		= (_XExtension *)NULL;
+ 	dpy->ext_data		= (XExtData *)NULL;
+ 	dpy->ext_number 	= 0;
+ 	dpy->event_vec[X_Error] = _XUnknownWireEvent;
+ 	dpy->event_vec[X_Reply] = _XUnknownWireEvent;
+ 	dpy->wire_vec[X_Error]  = _XUnknownNativeEvent;
+ 	dpy->wire_vec[X_Reply]  = _XUnknownNativeEvent;
+ 	for (i = KeyPress; i < LASTEvent; i++) {
+ 	    dpy->event_vec[i] 	= _XWireToEvent;
+ 	    dpy->wire_vec[i] 	= NULL;
+ 	}
+ 	for (i = LASTEvent; i < 128; i++) {
+ 	    dpy->event_vec[i] 	= _XUnknownWireEvent;
+ 	    dpy->wire_vec[i] 	= _XUnknownNativeEvent;
+ 	}
+ 	dpy->resource_id	= 0;
+ 	dpy->db 		= (struct _XrmHashBucketRec *)NULL;
+ 	dpy->cursor_font	= None;
+ 	dpy->flags		= 0;
+ /* 
+  * Initialize pointers to NULL so that XFreeDisplayStructure will
+  * work if we run out of memory
+  */
+ 
+ 	dpy->screens = NULL;
+ 	dpy->vendor = NULL;
+ 	dpy->buffer = NULL;
+ 	dpy->atoms = NULL;
+ 	dpy->error_vec = NULL;
+ 	dpy->context_db = NULL;
+ 
X  /*
!  * Setup other information in this display structure.
X   */
! 	dpy->vnumber = X_PROTOCOL;
! 	dpy->resource_alloc = _XAllocID;
! 	dpy->synchandler = NULL;
! 	dpy->request = 0;
! 	dpy->last_request_read = 0;
! 	dpy->default_screen = iscreen;  /* Value returned by ConnectDisplay */
! 	dpy->last_req = (char *)&_dummy_request;
X  
! 	/* Set up the output buffers. */
! 	if ((dpy->bufptr = dpy->buffer = Xmalloc(BUFSIZE)) == NULL) {
! 	        OutOfMemory (dpy, setup);
! 		UnlockMutex(&lock);
! 		return(NULL);
X  	}
! 	dpy->bufmax = dpy->buffer + BUFSIZE;
!  
! 	/* Set up the input event queue and input event queue parameters. */
! 	dpy->head = dpy->tail = NULL;
! 	dpy->qlen = 0;
! 
! 	/* Set up free-function record */
! 	if ((dpy->free_funcs = (_XFreeFuncRec *)Xcalloc(1,
! 							sizeof(_XFreeFuncRec)))
! 	    == NULL) {
! 	    OutOfMemory (dpy, setup);
! 	    UnlockMutex(&lock);
! 	    return(NULL);
X  	}
X  
X  /*
X   * The xConnClientPrefix describes the initial connection setup information
X   * and is followed by the authorization information.  Sites that are interested
***************
*** 452,458 ****
X  	    UnlockMutex(&lock);
X  	    return(NULL);
X  	}	    
! 	if (authptr) XauDisposeAuth (authptr);
X  /*
X   * Now see if connection was accepted...
X   */
--- 228,235 ----
X  	    UnlockMutex(&lock);
X  	    return(NULL);
X  	}	    
! 	if (conn_auth_name) Xfree(conn_auth_name);
! 	if (conn_auth_data) Xfree(conn_auth_data);
X  /*
X   * Now see if connection was accepted...
X   */
***************
*** 490,498 ****
X  		(void) fwrite (u.failure, sizeof(char),
X  			(int)prefix.lengthReason, stderr);
X  		(void) fwrite ("\r\n", sizeof(char), 2, stderr);
! 		_XDisconnectDisplay (dpy->fd);
! 		Xfree ((char *)dpy);
! 		Xfree (setup);
X  		UnlockMutex(&lock);
X  		return (NULL);
X  	}
--- 267,273 ----
X  		(void) fwrite (u.failure, sizeof(char),
X  			(int)prefix.lengthReason, stderr);
X  		(void) fwrite ("\r\n", sizeof(char), 2, stderr);
! 		OutOfMemory(dpy, setup);
X  		UnlockMutex(&lock);
X  		return (NULL);
X  	}
***************
*** 508,522 ****
X  	dpy->resource_mask	= u.setup->ridMask;
X  	dpy->min_keycode	= u.setup->minKeyCode;
X  	dpy->max_keycode	= u.setup->maxKeyCode;
- 	dpy->keysyms		= (KeySym *) NULL;
- 	dpy->modifiermap	= NULL;
- 	dpy->lock_meaning	= NoSymbol;
- 	dpy->keysyms_per_keycode = 0;
- 	dpy->current		= None;
- 	dpy->xdefaults		= (char *)NULL;
- 	dpy->scratch_length	= 0L;
- 	dpy->scratch_buffer	= NULL;
- 	dpy->key_bindings	= NULL;
X  	dpy->motion_buffer	= u.setup->motionBufferSize;
X  	dpy->nformats		= u.setup->numFormats;
X  	dpy->nscreens		= u.setup->numRoots;
--- 283,288 ----
***************
*** 525,546 ****
X  	dpy->bitmap_pad		= u.setup->bitmapScanlinePad;
X  	dpy->bitmap_bit_order   = u.setup->bitmapBitOrder;
X  	dpy->max_request_size	= u.setup->maxRequestSize;
- 	dpy->ext_procs		= (_XExtension *)NULL;
- 	dpy->ext_data		= (XExtData *)NULL;
- 	dpy->ext_number 	= 0;
- 	dpy->event_vec[X_Error] = _XUnknownWireEvent;
- 	dpy->event_vec[X_Reply] = _XUnknownWireEvent;
- 	dpy->wire_vec[X_Error]  = _XUnknownNativeEvent;
- 	dpy->wire_vec[X_Reply]  = _XUnknownNativeEvent;
- 	for (i = KeyPress; i < LASTEvent; i++) {
- 	    dpy->event_vec[i] 	= _XWireToEvent;
- 	    dpy->wire_vec[i] 	= NULL;
- 	}
- 	for (i = LASTEvent; i < 128; i++) {
- 	    dpy->event_vec[i] 	= _XUnknownWireEvent;
- 	    dpy->wire_vec[i] 	= _XUnknownNativeEvent;
- 	}
- 	dpy->resource_id	= 0;
X  	mask = dpy->resource_mask;
X  	dpy->resource_shift	= 0;
X  	while (!(mask & 1)) {
--- 291,296 ----
***************
*** 547,568 ****
X  	    dpy->resource_shift++;
X  	    mask = mask >> 1;
X  	}
- 	dpy->db 		= (struct _XrmHashBucketRec *)NULL;
- 	dpy->cursor_font	= None;
- 	dpy->flags		= 0;
- /* 
-  * Initialize pointers to NULL so that XFreeDisplayStructure will
-  * work if we run out of memory
-  */
- 
- 	dpy->screens = NULL;
- 	dpy->display_name = NULL;
- 	dpy->vendor = NULL;
- 	dpy->buffer = NULL;
- 	dpy->atoms = NULL;
- 	dpy->error_vec = NULL;
- 	dpy->context_db = NULL;
- 
X  /*
X   * now extract the vendor string...  String must be null terminated,
X   * padded to multiple of 4 bytes.
--- 297,302 ----
***************
*** 687,727 ****
X  		
X  
X  /*
-  * Setup other information in this display structure.
-  */
- 	dpy->vnumber = X_PROTOCOL;
- 	dpy->resource_alloc = _XAllocID;
- 	dpy->synchandler = NULL;
- 	dpy->request = 0;
- 	dpy->last_request_read = 0;
- 	dpy->default_screen = iscreen;  /* Value returned by ConnectDisplay */
- 	dpy->last_req = (char *)&_dummy_request;
- 
- 	/* Salt away the host:display string for later use */
- 	dpy->display_name = fullname;
-  
- 	/* Set up the output buffers. */
- 	if ((dpy->bufptr = dpy->buffer = Xmalloc(BUFSIZE)) == NULL) {
- 	        OutOfMemory (dpy, setup);
- 		UnlockMutex(&lock);
- 		return(NULL);
- 	}
- 	dpy->bufmax = dpy->buffer + BUFSIZE;
-  
- 	/* Set up the input event queue and input event queue parameters. */
- 	dpy->head = dpy->tail = NULL;
- 	dpy->qlen = 0;
- 
- 	/* Set up free-function record */
- 	if ((dpy->free_funcs = (_XFreeFuncRec *)Xcalloc(1,
- 							sizeof(_XFreeFuncRec)))
- 	    == NULL) {
- 	    OutOfMemory (dpy, setup);
- 	    UnlockMutex(&lock);
- 	    return(NULL);
- 	}
- 
- /*
X   * Now start talking to the server to setup all other information...
X   */
X  
--- 421,426 ----
***************
*** 827,832 ****
--- 526,555 ----
X  _XFreeDisplayStructure(dpy)
X  	register Display *dpy;
X  {
+ 	while (dpy->ext_procs) {
+ 	    _XExtension *ext = dpy->ext_procs;
+ 	    dpy->ext_procs = ext->next;
+ 	    if (ext->name)
+ 		Xfree (ext->name);
+ 	    Xfree ((char *)ext);
+ 	}
+ 	if (dpy->im_filters)
+ 	   (*dpy->free_funcs->im_filters)(dpy);
+ 	if (dpy->cms.clientCmaps)
+ 	   (*dpy->free_funcs->clientCmaps)(dpy);
+ 	if (dpy->cms.defaultCCCs)
+ 	   (*dpy->free_funcs->defaultCCCs)(dpy);
+ 	if (dpy->cms.perVisualIntensityMaps)
+ 	   (*dpy->free_funcs->intensityMaps)(dpy);
+ 	if (dpy->atoms)
+ 	    (*dpy->free_funcs->atoms)(dpy);
+ 	if (dpy->modifiermap)
+ 	   (*dpy->free_funcs->modifiermap)(dpy->modifiermap);
+ 	if (dpy->key_bindings)
+ 	   (*dpy->free_funcs->key_bindings)(dpy);
+ 	if (dpy->context_db)
+ 	   (*dpy->free_funcs->context_db)(dpy);
+ 
X  	if (dpy->screens) {
X  	    register int i;
X  
***************
*** 872,907 ****
X  
X          if (dpy->buffer)
X  	   Xfree (dpy->buffer);
- 	if (dpy->atoms)
- 	    (*dpy->free_funcs->atoms)(dpy);
X  	if (dpy->keysyms)
X  	   Xfree ((char *) dpy->keysyms);
- 	if (dpy->modifiermap)
- 	   (*dpy->free_funcs->modifiermap)(dpy->modifiermap);
X  	if (dpy->xdefaults)
X  	   Xfree (dpy->xdefaults);
- 	if (dpy->key_bindings)
- 	   (*dpy->free_funcs->key_bindings)(dpy);
X  	if (dpy->error_vec)
X  	    Xfree ((char *)dpy->error_vec);
- 	if (dpy->context_db)
- 	   (*dpy->free_funcs->context_db)(dpy);
- 	if (dpy->cms.defaultCCCs)
- 	   (*dpy->free_funcs->defaultCCCs)(dpy);
- 	if (dpy->cms.clientCmaps)
- 	   (*dpy->free_funcs->clientCmaps)(dpy);
- 	if (dpy->cms.perVisualIntensityMaps)
- 	   (*dpy->free_funcs->intensityMaps)(dpy);
- 	if (dpy->im_filters)
- 	   (*dpy->free_funcs->im_filters)(dpy);
- 
- 	while (dpy->ext_procs) {
- 	    _XExtension *ext = dpy->ext_procs;
- 	    dpy->ext_procs = ext->next;
- 	    if (ext->name)
- 		Xfree (ext->name);
- 	    Xfree ((char *)ext);
- 	}
X  
X  	_XFreeExtData (dpy->ext_data);
X  	Xfree ((char *)dpy->free_funcs);
--- 595,606 ----
*** /tmp/,RCSt1a12658	Wed Jul 22 16:13:41 1992
--- mit/lib/X/XcmsCCC.c	Wed Jul 22 16:13:41 1992
***************
*** 1,4 ****
! /* $XConsortium: XcmsCCC.c,v 1.10 91/07/25 01:08:25 rws Exp $" */
X  
X  /*
X   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: XcmsCCC.c,v 1.11 91/12/20 15:58:21 rws Exp $" */
X  
X  /*
X   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 237,243 ****
X   *
X   */
X  {
!     if (ccc == XcmsDefaultCCC(ccc->dpy, ccc->screenNumber)) {
X  	/* do not allow clients to free DefaultCCC's */
X  	return;
X      }
--- 237,244 ----
X   *
X   */
X  {
!     if (ccc->dpy->cms.defaultCCCs &&
! 	ccc == ((XcmsCCC)ccc->dpy->cms.defaultCCCs) + ccc->screenNumber) {
X  	/* do not allow clients to free DefaultCCC's */
X  	return;
X      }
*** /tmp/da3910	Thu Jul 23 16:56:56 1992
--- mit/lib/X/XKeyBind.c	Thu Jul 23 16:56:54 1992
***************
*** 1,4 ****
! /* $XConsortium: XKeyBind.c,v 11.66 91/05/04 13:51:17 rws Exp $ */
X  /* Copyright 1985, 1987, Massachusetts Institute of Technology */
X  
X  /*
--- 1,4 ----
! /* $XConsortium: XKeyBind.c,v 11.67 92/05/19 11:23:14 converse Exp $ */
X  /* Copyright 1985, 1987, Massachusetts Institute of Technology */
X  
X  /*
***************
*** 275,283 ****
X  	    *upper -= (XK_scaron - XK_Scaron);
X  	else if (sym >= XK_zcaron && sym <= XK_zabovedot)
X  	    *upper -= (XK_zcaron - XK_Zcaron);
! 	else if (sym <= XK_Racute && sym <= XK_Tcedilla)
X  	    *lower += (XK_racute - XK_Racute);
! 	else if (sym <= XK_racute && sym <= XK_tcedilla)
X  	    *upper -= (XK_racute - XK_Racute);
X  	break;
X  #endif
--- 275,283 ----
X  	    *upper -= (XK_scaron - XK_Scaron);
X  	else if (sym >= XK_zcaron && sym <= XK_zabovedot)
X  	    *upper -= (XK_zcaron - XK_Zcaron);
! 	else if (sym >= XK_Racute && sym <= XK_Tcedilla)
X  	    *lower += (XK_racute - XK_Racute);
! 	else if (sym >= XK_racute && sym <= XK_tcedilla)
X  	    *upper -= (XK_racute - XK_Racute);
X  	break;
X  #endif
***************
*** 295,301 ****
X  	else if (sym >= XK_Cabovedot && sym <= XK_Scircumflex)
X  	    *lower += (XK_cabovedot - XK_Cabovedot);
X  	else if (sym >= XK_cabovedot && sym <= XK_scircumflex)
! 	    *lower += (XK_cabovedot - XK_Cabovedot);
X  	break;
X  #endif
X  #ifdef XK_LATIN4
--- 295,301 ----
X  	else if (sym >= XK_Cabovedot && sym <= XK_Scircumflex)
X  	    *lower += (XK_cabovedot - XK_Cabovedot);
X  	else if (sym >= XK_cabovedot && sym <= XK_scircumflex)
! 	    *upper -= (XK_cabovedot - XK_Cabovedot);
X  	break;
X  #endif
X  #ifdef XK_LATIN4
*** /tmp/da3946	Thu Jul 23 16:57:02 1992
--- mit/lib/Xt/Create.c	Thu Jul 23 16:57:01 1992
***************
*** 1,4 ****
! /* $XConsortium: Create.c,v 1.87 91/05/09 18:09:13 swick Exp $ */
X  
X  /***********************************************************
X  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Create.c,v 1.88 92/05/11 16:38:19 converse Exp $ */
X  
X  /***********************************************************
X  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 167,173 ****
X      char        *name, *class;
X      WidgetClass widget_class;
X      Widget      parent;
!     Screen*     default_screen;
X      ArgList     args;		/* must be NULL if typed_args is non-NULL */
X      Cardinal    num_args;
X      XtTypedArgList typed_args;	/* must be NULL if args is non-NULL */
--- 167,173 ----
X      char        *name, *class;
X      WidgetClass widget_class;
X      Widget      parent;
!     Screen*     default_screen; /* undefined when creating a nonwidget */
X      ArgList     args;		/* must be NULL if typed_args is non-NULL */
X      Cardinal    num_args;
X      XtTypedArgList typed_args;	/* must be NULL if args is non-NULL */
***************
*** 355,360 ****
--- 355,362 ----
X  			      params, &num_params);
X  	    }
X  	}
+     } else {
+ 	default_screen = parent->core.screen;
X      }
X  
X      if (XtIsConstraint(parent)) {
***************
*** 362,368 ****
X      } else {
X  	cwc = NULL;
X      }
-     default_screen = parent->core.screen;
X      widget = _XtCreate(name, (char *)NULL, widget_class, parent,
X  		       default_screen, args, num_args,
X  		       typed_args, num_typed_args, cwc);
--- 364,369 ----
*** /tmp/da3982	Thu Jul 23 16:57:09 1992
--- mit/lib/Xt/Display.c	Thu Jul 23 16:57:08 1992
***************
*** 1,4 ****
! /* $XConsortium: Display.c,v 1.81 91/07/12 13:45:00 rws Exp $ */
X  
X  /***********************************************************
X  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Display.c,v 1.85 92/06/08 11:24:21 converse Exp $ */
X  
X  /***********************************************************
X  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 176,188 ****
X  	String language = NULL;
X  
X  	/* parse the command line for name, display, and/or language */
! 	if (!applName || !displayName || app->process->globalLangProcRec.proc)
! 	    db = _XtPreparseCommandLine(urlist, num_urs, *argc, argv,
! 					&applName, &displayName, &language);
X  	d = XOpenDisplay(displayName);
X  
X  	if (! applName && !(applName = getenv("RESOURCE_NAME"))) {
! 	    if (*argc > 0 && argv[0]) {
X  		char *ptr = rindex(argv[0], '/');
X  		if (ptr) applName = ++ptr;
X  		else applName = argv[0];
--- 176,189 ----
X  	String language = NULL;
X  
X  	/* parse the command line for name, display, and/or language */
! 	db = _XtPreparseCommandLine(urlist, num_urs, *argc, argv, &applName,
! 				    (displayName ? NULL : &displayName),
! 				    (app->process->globalLangProcRec.proc ?
! 				     &language : NULL));
X  	d = XOpenDisplay(displayName);
X  
X  	if (! applName && !(applName = getenv("RESOURCE_NAME"))) {
! 	    if (*argc > 0 && argv[0] && *argv[0]) {
X  		char *ptr = rindex(argv[0], '/');
X  		if (ptr) applName = ++ptr;
X  		else applName = argv[0];
***************
*** 486,492 ****
X  	    if (xtpd->mapping_callbacks != NULL)
X  		_XtRemoveAllCallbacks(&xtpd->mapping_callbacks);
X  	    XtDeleteFromAppContext(dpy, xtpd->appContext);
!             XtFree((char *) xtpd->keysyms);
X              XtFree((char *) xtpd->modKeysyms);
X              XtFree((char *) xtpd->modsToKeysyms);
X              xtpd->keysyms_per_keycode = 0;
--- 487,494 ----
X  	    if (xtpd->mapping_callbacks != NULL)
X  		_XtRemoveAllCallbacks(&xtpd->mapping_callbacks);
X  	    XtDeleteFromAppContext(dpy, xtpd->appContext);
! 	    if (xtpd->keysyms)
! 		XFree((char *) xtpd->keysyms);
X              XtFree((char *) xtpd->modKeysyms);
X              XtFree((char *) xtpd->modsToKeysyms);
SHAR_EOF
true || echo 'restore of fix-14 failed'
fi
echo 'End of  part 1'
echo 'File fix-14 is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
