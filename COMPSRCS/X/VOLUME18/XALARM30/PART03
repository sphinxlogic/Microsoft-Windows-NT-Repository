Newsgroups: comp.sources.x
Path: uunet!darwin.sura.net!mips!msi!dcmartin
From: Simon Marshall <S.Marshall@sequent.cc.hull.ac.uk>
Subject: v18i004: Xalarm 3.04, Part03/05
Message-ID: <1992Jul8.154413.20488@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
References: <csx-18i002-xalarm-3.04@uunet.UU.NET>
Date: Wed, 8 Jul 1992 15:44:13 GMT
Approved: dcmartin@msi.com
Lines: 1702

Submitted-by: Simon Marshall <S.Marshall@sequent.cc.hull.ac.uk>
Posting-number: Volume 18, Issue 4
Archive-name: xalarm-3.04/part03

# this is part.03 (part 3 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file README continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 3; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping README'
else
echo 'x - continuing file README'
sed 's/^X//' << 'SHAR_EOF' >> 'README' &&
X  warnings times, and the message xalarm will display when the alarm is
X  triggered.
X
X  This form is suitable for inclusion as a menu option under a window manager.
X
X  You can make xalarm read alarm times, dates, and the messages to display from
X  a file, either as a one-off or periodically using an xalarm daemon.  The
X  alarms will only be set on the dates specified in the file.  This way you can
X  have an appointments file.
X
X  This form is suitable for inclusion in an X start up or initialisation
X  script.
X
X  To help you, xalarm shows the current time, and the alarm also displays the
X  time since the alarm triggered.  Even if you end an X session before xalarm
X  has finished, xalarm will save its alarm.  It will then be re-started (if the
X  time has not passed) next time you invoke xalarm.
X
X  xalarm allows you to snooze the alarm after it is triggered, to give you an
X  opportunity to carry on and be late anyway.  It can also pester you after it
X  has triggered.  Even after you have set the alarm and confirmed it, you can
X  reset the alarm as long as you know the xalarm process number; xalarm can
X  list other xalarm pids.
X
X  xalarm makes maximum use of resources, as well as having a number of command
X  line options, and these can be used to control most of the appearance of
X  xalarm and (just about) all of its behaviour.
X
X  The current xalarm options include:
X	-daemon +days|daily|weekly
X	-file +days|date|today|tomorrow|weekly
X	-date +days|date|today|tomorrow|week
X	-time +time|time|now|noon
X	-warn time[,time...]				-nowarn
X	-confirm					-noconfirm
X	-warnwords number				-nowarnwords
X	-list
X	-reset pid|all
X	-kill pid|all
X	-pester time					-nopester
X	-snooze time
X	-alarmaudio bell|beep|quiet|shell_script
X	-warningaudio bell|beep|quiet|shell_script
X	-quiet						-volume	percent
X	-help						-version
X
X  Also supplied is xmemo, a front end to xalarm.  By default, make tries to
X  create xfortune and xyow (front ends to xmemo).  Note that they require the
X  fortune and yow programs respectively, they don't come with this.
X
X  See the file INSTALL and PROBLEMS for help with installation and problems.
X
X
THE END
~~~~~~~
X
X  Xalarm uses Xt & Xaw stuff only, and may well be a useful aid to someone
X  trying to learn X, as I was/am.
X
X  You may have problems with X function names if using R3 or earlier;
X  application contexts are used, but this should not take much changing - using
X  #defines may do most of the job.
X
X  Written in an attempt to learn X Windows in as short a time as possible; it
X  may be written badly, but makes as much use of resources as possible.  I
X  don't think it is (but I wouldn't, would I?) and I have found it is very
X  useful for me now I'm to be responsible for giving lectures...
X
X	Simon.
_______________________________________________________________________________
X    Simon Marshall, Dept. Computer Science, University of Hull, HU6 7RX, UK
X    S.Marshall@Hull.ac.UK
SHAR_EOF
echo 'File README is complete' &&
chmod 0644 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 4281 -eq "$Wc_c" ||
	echo 'README: original size 4281, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= XAlarm.ad ==============
if test -f 'XAlarm.ad' -a X"$1" != X"-c"; then
	echo 'x - skipping XAlarm.ad (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting XAlarm.ad (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'XAlarm.ad' &&
! We can't surround this by "#ifdef COLOR ... #endif" and have it in
! .../lib/X11/app-defaults/XAlarm because stuff in there is not pre-processed
! with cpp like wot xrdb does.  Now why is that...?
! If you want colour, you have to stick this in your ~/.xresources file (where
! you can surround it with #ifdefs).
! #ifdef COLOR
! XAlarm*background:			LightYellow
! XAlarm*foreground:			IndianRed
! XAlarm*Command.background:		IndianRed
! XAlarm*Command.foreground:		LightYellow
! #endif
X
XXAlarm.confirm:				True
XXAlarm.warnings:			5,15
XXAlarm.warningwords:			0
XXAlarm.pester:				0
XXAlarm.snooze:				0
XXAlarm.volume:				50
XXAlarm.alarmaudio:			bell
XXAlarm.warningaudio:			bell
X
XXAlarm*background:			White
XXAlarm*foreground:			Black
XXAlarm*font:				-*-times-bold-r-*-*-14-*-*-*-p-*-iso8859-1
XXAlarm*allowShellResize:		True
XXAlarm*resizable:			True
X
XXAlarm*top:				ChainTop
XXAlarm*bottom:				ChainTop
XXAlarm*left:				ChainLeft
XXAlarm*right:				ChainLeft
X
XXAlarm*Command.background:		Black
XXAlarm*Command.foreground:		White
XXAlarm*Command.ShapeStyle:		rectangle
XXAlarm*Command.cursor:			hand2
XXAlarm*Label.justify:			left
XXAlarm*Label.cursor:			question_arrow
XXAlarm*Text.cursor:			pencil
X
XXAlarm*quit.label:			Quit
XXAlarm*reset.label:			Reset
X
XXAlarm.Alarm!.alarm.background:				Black
XXAlarm.Alarm!.alarm.message.cursor:			gumby
XXAlarm.Alarm!.alarm.message.label:			Alarm Call!!!
XXAlarm.Alarm!.alarm.message.font:			-*-times-bold-i-*-*-34-*-*-*-p-*-iso8859-1
XXAlarm.Alarm!.alarm.message.internalWidth:		10
XXAlarm.Alarm!.alarm.message.internalHeight:		5
XXAlarm.Alarm!.alarm.message.bottom:			ChainBottom
X
XXAlarm.Alarm!.alarm.buttons.snooze.label:		Snooze
XXAlarm.Alarm!.alarm.buttons.snooze1.label:		+1 min
XXAlarm.Alarm!.alarm.buttons.snooze5.label:		+5 mins
XXAlarm.Alarm!.alarm.buttons.snooze15.label:		+15 mins
XXAlarm.Alarm!.alarm.buttons.snooze.fromHoriz:		quit
XXAlarm.Alarm!.alarm.buttons.snooze1.fromHoriz:		snooze
XXAlarm.Alarm!.alarm.buttons.snooze5.fromHoriz:		snooze1
XXAlarm.Alarm!.alarm.buttons.snooze15.fromHoriz:		snooze5
XXAlarm.Alarm!.alarm.buttons.snoozetime.fromHoriz:	snooze15
XXAlarm.Alarm!.alarm.message.fromVert:			buttons
X
XXAlarm.When?.when.background:			Black
XXAlarm.When?.when.defaultDistance:		0
X
XXAlarm.When?.when.time.background:		Black
XXAlarm.When?.when.time.ok.label:		Enter time
XXAlarm.When?.when.time.value.translations:	#override <Key>Return: EnteredTime()
X
XXAlarm.When?.when.date.background:		Black
XXAlarm.When?.when.date.ok.label:		Enter date
XXAlarm.When?.when.date.value.translations:	#override <Key>Return: EnteredDate()
X
XXAlarm.When?.when.warnings.background:		Black
XXAlarm.When?.when.warnings.ok.label:		Enter warnings
XXAlarm.When?.when.warnings.value.translations:	#override <Key>Return: EnteredWarnings()
X
XXAlarm.When?.when.confirm.background:		Black
XXAlarm.When?.when.confirm.value*font:		-*-times-bold-i-*-*-14-*-*-*-p-*-iso8859-1
XXAlarm.When?.when.confirm.ok.label:		Confirm time
XXAlarm.When?.when.confirm.cancel.label:		Re-edit
XXAlarm.When?.when.confirm.save.label:		Save
XXAlarm.When?.when.confirm.value.translations:	#override <Key>Return: Confirmed()
X
XXAlarm.When?*edittime.label:		Time
XXAlarm.When?*editdate.label:		Date
XXAlarm.When?*editwarnings.label:	Warnings
X
XXAlarm.When?*value*font:		9x15bold
XXAlarm.When?*value.bottom:		ChainBottom
XXAlarm.When?*value.right:		ChainRight
XXAlarm.When?*Command.top:		ChainBottom
XXAlarm.When?*Command.bottom:		ChainBottom
X
XXAlarm.Warning!.warning.background:		Black
XXAlarm.Warning!.warning.dismiss.label:		Dismiss
XXAlarm.Warning!.warning.message.fromHoriz:	dismiss
XXAlarm.Warning!.warning.message.cursor:		clock
XXAlarm.Warning!.warning.reset.fromHoriz:	message
XXAlarm.Warning!.warning.quit.fromHoriz:		reset
SHAR_EOF
chmod 0644 XAlarm.ad ||
echo 'restore of XAlarm.ad failed'
Wc_c="`wc -c < 'XAlarm.ad'`"
test 3684 -eq "$Wc_c" ||
	echo 'XAlarm.ad: original size 3684, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= XAlarm.ad+ ==============
if test -f 'XAlarm.ad+' -a X"$1" != X"-c"; then
	echo 'x - skipping XAlarm.ad+ (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting XAlarm.ad+ (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'XAlarm.ad+' &&
! We can't surround this by "#ifdef COLOR ... #endif" and have it in
! .../lib/X11/app-defaults/XAlarm because stuff in there is not pre-processed
! with cpp like wot xrdb does.  Now why is that...?
X
! If you want colour, you have to stick this in your ~/.xresources file (where
! you can surround it with #ifdefs).
X
#ifdef COLOR
XXAlarm*background:			LightYellow
XXAlarm*foreground:			IndianRed
XXAlarm*Command.background:		IndianRed
XXAlarm*Command.foreground:		LightYellow
#endif
X
! If you want a smaller button box in the alarm window, uncomment & try these
! for size in your ~/.xresources file:
X
!XAlarm.Alarm!.alarm.buttons.snooze1.fromVert:		quit
! This will vary depending on the button labels & font...
!XAlarm.Alarm!.alarm.buttons.snooze1.horizDistance:	-93
!XAlarm.Alarm!.alarm.buttons.snooze5.fromVert:		quit
!XAlarm.Alarm!.alarm.buttons.snooze15.fromVert:		quit
!XAlarm.Alarm!.alarm.buttons.snoozetime.fromHoriz:	snooze
X
! If you want the button box next to the alarm window, uncomment & try this:
X
!XAlarm.Alarm!.alarm.message.fromHoriz:			buttons
! This will vary depending on the button labels & font...
!XAlarm.Alarm!.alarm.message.vertDistance:		-33
SHAR_EOF
chmod 0644 XAlarm.ad+ ||
echo 'restore of XAlarm.ad+ failed'
Wc_c="`wc -c < 'XAlarm.ad+'`"
test 1165 -eq "$Wc_c" ||
	echo 'XAlarm.ad+: original size 1165, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= alarm.c ==============
if test -f 'alarm.c' -a X"$1" != X"-c"; then
	echo 'x - skipping alarm.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting alarm.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'alarm.c' &&
/*
X      Copyright (c) 1991, 1992 by Simon Marshall, University of Hull, UK
X
X		   If you still end up late, don't blame me!
X				       
X  Permission to use, copy, modify, distribute, and sell this software and its
X       documentation for any purpose and without fee is hereby granted,
X    provided that the above copyright notice appear in all copies and that
X	both that copyright notice and this permission notice appear in
X			   supporting documentation.
X				       
X  This software is provided AS IS with no warranties of any kind.  The author
X    shall have no liability with respect to the infringement of copyrights,
X     trade secrets or any patents by this file or any part thereof.  In no
X      event will the author be liable for any lost revenue or profits or
X	      other special, indirect and consequential damages.
*/
X
/* 
X * The stuff needed for the alarm call widget to appear on the screen, 
X * and the stuff for snoozing it.
X */
X
X
#include "xalarm.h"
#include <X11/Xaw/Label.h>
#include <X11/Xaw/Command.h>
#include <X11/Xaw/Form.h>
X
X
#define		NAMEFORMAT	"%s: %s@%s"
#define		REALNAMEFORMAT	" (%s)"
#define		TIMEFORMAT	" (%d:%02d)"
X
X
X
void		CreateAlarmWidget(), WakeUp(), ShowClickToZero(), ShowSnoozeValue();
SIGRET		ResetAlarm();
static void	SnoozeAmount(), Snooze(), TimeTracker();
extern void	PopupAndAsk(), AddTimeOuts(), SetWMName(), SetGeometry(),
X		EnsureNotGrownOffScreen(), Audio(), QuitWarning(), Quit();
extern unsigned long DateToMilliSeconds();
extern long	TimeToMilliSeconds();
extern XtIntervalId ResetTracker();
extern String	getenv(), UserName(), MachineName();
extern time_t	time();
extern struct tm *localtime();
X
X
X
extern AlarmData        xalarm;
X
X
X
/* 
X * Create the widget that holds the alarm itself.
X */
X
void CreateAlarmWidget (alarmmessage)
X  String   alarmmessage;
{
X    Widget 	  alarm, alarmbox, message, buttonbox,
X		  quit, snooze, snooze1, snooze5, snooze15, snoozetime;
X    static char   snoozetimetranslations [] =
X		      "<EnterWindow>:	highlight() ShowClickToZero() \n\
X		       <LeaveWindow>:	ShowSnoozeValue() unhighlight()";
X
X    alarm = XtVaCreatePopupShell ("Alarm!", transientShellWidgetClass, xalarm.toplevel,
X				  NULL);
X
X    alarmbox = XtVaCreateManagedWidget ("alarm", formWidgetClass, alarm, NULL);
X
X    buttonbox = XtVaCreateManagedWidget ("buttons", formWidgetClass, alarmbox, NULL);
X
X    CreateManagedButton (quit, "quit", buttonbox, Quit, NULL);
X    CreateManagedButton (snooze, "snooze", buttonbox, Snooze, NULL);
X    CreateManagedButton (snooze1, "snooze1", buttonbox, SnoozeAmount, 1);
X    CreateManagedButton (snooze5, "snooze5", buttonbox, SnoozeAmount, 5);
X    CreateManagedButton (snooze15, "snooze15" ,buttonbox, SnoozeAmount, 15);
X    CreateManagedButton (snoozetime, "snoozetime", buttonbox, SnoozeAmount, 0);
X
X    if (NONNIL (String, alarmmessage))
X	message = XtVaCreateManagedWidget ("message", labelWidgetClass, alarmbox, XtNlabel,
X					   (XtArgVal) (xalarm.messagestr = alarmmessage),
X					   NULL);
X    else {
X	message = XtVaCreateManagedWidget ("message", labelWidgetClass, alarmbox, NULL);
X	XtVaGetValues (message, XtNlabel, &xalarm.messagestr, NULL);
X    }
X
X    XtOverrideTranslations (snoozetime,
X			    XtParseTranslationTable (snoozetimetranslations));
X
X    xalarm.alarmwidget = alarm;
X    xalarm.snoozetimebutton = snoozetime;
X    xalarm.messagewidget = message;
}
X
X
X
/* 
X * This is for the snoozetime button which doubles as the label showing how 
X * much time the snooze is selected for.
X */
X
void ShowClickToZero ()
{
X    XtVaSetValues (xalarm.snoozetimebutton, XtNlabel, (XtArgVal) "Zero time", NULL);
X    EnsureNotGrownOffScreen (xalarm.alarmwidget);
}
X  
X
X
void ShowSnoozeValue ()
{  
X    char   buf[TEXT];
X
X    MAKETIMESTRING (buf, (int) (xalarm.timeout / MSECSIN1MIN));
X    XtVaSetValues (xalarm.snoozetimebutton, XtNlabel, (XtArgVal) buf, NULL);
X    EnsureNotGrownOffScreen (xalarm.alarmwidget);
}
X
X
X
/* 
X * Add to the amount that is currently the amount to snooze by.
X */
X
static void SnoozeAmount (widget, clientdata, calldata)
X  Widget      widget;
X  XtPointer   clientdata, calldata;
{
X    int   mins = (int) clientdata;
X
X    if (mins == 0) {
X	xalarm.timeout = xalarm.dateout = 0;
X	ShowClickToZero ();
X    } else {
X	xalarm.timeout += (mins*MSECSIN1MIN);
X	ShowSnoozeValue ();
X    }
}
X
X
X
/* 
X * Time to sleep.  Add the time outs & disappear.
X */
X
static void Snooze (widget, clientdata, calldata)
X  Widget      widget;
X  XtPointer   clientdata, calldata;
{
X    AddTimeOuts ();
X    if (ISVALID (xalarm.pesterid)) {
X	XtRemoveTimeOut (xalarm.pesterid);
X	xalarm.pesterid = INVALID;
X    }
X    if (ISVALID (xalarm.alarmid)) {
X	XtRemoveTimeOut (xalarm.alarmid);
X	xalarm.alarmid = INVALID;
X    }
X
X    XtPopdown (xalarm.alarmwidget);
}
X
X
X
/* 
X * Time to wake up.
X */
X
void WakeUp (clientdata, id)
X  XtPointer 	 clientdata;
X  XtIntervalId 	 id;
{
X    xalarm.timeout = xalarm.dateout = 0;
X    xalarm.saveonshutdown = False;
X    SnoozeAmount ((Widget) NULL, (XtPointer) xalarm.snooze, (XtPointer) NULL);
X
X    if (ISNONID (xalarm.alarmid))
X	TimeTracker ((XtPointer) xalarm.alarmwidget, (XtIntervalId) NULL);
X    SetGeometry (xalarm.alarmwidget);
X    XtPopup (xalarm.alarmwidget, XtGrabNone);
X    XFlush (XtDisplay (xalarm.alarmwidget));
X    Audio (xalarm.alarmaudio);
X
X    if (xalarm.pester > 0) {
X	XRaiseWindow (XtDisplay (xalarm.alarmwidget), XtWindow (xalarm.alarmwidget));
X	xalarm.pesterid =
X	    XtAppAddTimeOut (xalarm.appcon, TIMEOUT (xalarm.pester * MSECSIN1MIN),
X			     (XtTimerCallbackProc) WakeUp, (XtPointer) NULL);
X    }
X
X    if (ISWIDGET (xalarm.warningwidget))
X	QuitWarning ((Widget) NULL,
X		     (XtPointer) (XtParent (XtParent (xalarm.warningwidget))),
X		     (XtPointer) NULL);
}
X
X
X
/* 
X * Track the time for this widget.  Puts a clock in the WM name,
X * along with the user's name etc.
X */
X
static void TimeTracker (clientdata, id)
X  XtPointer 	 clientdata;
X  XtIntervalId 	 id;
{
X    String 	 user = UserName(), host = MachineName(), name = getenv ("NAME");
X    char 	 wmname[TEXT];
X    time_t 	 now;
X    struct tm 	*clock;
X
X    (void) time (&now);
X    clock = localtime (&now);
X    now -= (time_t) xalarm.offtime;
X
X    (void) sprintf (wmname, NAMEFORMAT, xalarm.proggie, user, host);
X    if (NONNIL (String, name))
X	(void) sprintf (ENDOF (wmname), REALNAMEFORMAT, name);
X    if (now >= 60) {
X	(void) strcat (wmname, " +");
X	MAKETIMESTRING (ENDOF (wmname), now / SECSIN1MIN);
X    }
X    (void) sprintf (ENDOF (wmname), TIMEFORMAT, clock->tm_hour, clock->tm_min);
X
X    SetWMName ((Widget) clientdata, wmname);
X
X    xalarm.alarmid = ResetTracker (TimeTracker, clientdata, (int) (xalarm.offtime % 60));
}
X
X
X
/* 
X * Let's popup to reset our alarm.
X */
X
SIGRET ResetAlarm (sig, code, scp, addr)
X  int 		      sig, code;
X  struct sigcontext  *scp;
X  char 		     *addr;
{
X    unsigned long   timeout = SUMTIMEOUTS (xalarm.dateout, xalarm.timeout);
X    time_t 	    now;
X    int 	    i;
X
X    now = time ((time_t *) NULL);
X    timeout -= (now - xalarm.settime);
X
X    for (i=0; i<xalarm.numwarnings; i++)
X	if (timeout  > xalarm.warnings[i])
X	    XtRemoveTimeOut (xalarm.timeoutid[i]);
X    XtRemoveTimeOut (xalarm.timeoutid[xalarm.numwarnings]);
X
X    if (ISVALID (xalarm.pesterid)) {
X	XtRemoveTimeOut (xalarm.pesterid);
X	xalarm.pesterid = INVALID;
X    }
X
X    xalarm.dateout = DateToMilliSeconds (xalarm.datestr);
X    xalarm.timeout = TimeToMilliSeconds (xalarm.timestr);
X
X    PopupAndAsk ();
}
SHAR_EOF
chmod 0644 alarm.c ||
echo 'restore of alarm.c failed'
Wc_c="`wc -c < 'alarm.c'`"
test 7396 -eq "$Wc_c" ||
	echo 'alarm.c: original size 7396, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= config.1st ==============
if test -f 'config.1st' -a X"$1" != X"-c"; then
	echo 'x - skipping config.1st (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting config.1st (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'config.1st' &&
#!/bin/sh
X
# Just try to find out the full path names for kill, ps, grep & colrm which
# are used within fns.c to do process listing.
X
echo -n '
I need to find the path of a few things on your system.  If I guess wrongly,
say so at the end, and I will try again.  If I do not know where they reside, I
will ask you.  Default answers are in brackets.  If you do not know where they
are on your system, first try "which <command>" (or equivalent) in a shell, or
ask your local System Guru or Manager.
X
+ If you do not have "kill", "ps", "grep" or "colrm" (or equivalent), do not
X  panic, xalarm only uses them when it is attempting to list the process ids of
X  other xalarms.  If you do not have these commands, just hit RETURN.
X
X  You can make xalarm, but you will not be able to use the -reset, -kill or
X  -list options.
X
X  I need to know because xalarm should use full path names.
X
+ If you do not have "fortune" or "yow", you cannot have the X equivalent since
X  they are just front ends to them!  But do not panic, they are not necessary
X  for xalarm, so if you do not have them just hit RETURN when asked for their
X  whereabouts.
X
Hit RETURN when ready...'
read dummy
echo " "
X
if test "$1" = "-quick"; then
X	mode=-quick
X	shift
else
X	mode=
fi
X
kill=`./fullpath $mode kill`
ps=`./fullpath $mode ps`
grep=`./fullpath $mode grep`
colrm=`./fullpath $mode colrm`
X
echo '/*
X * Get xalarm pids:
X *     list user processes | filter for xalarm | pid #s only | filter us out
X *
X * Where "us" is where the xalarm pid# running this will go.
X *
X * Normally we use ps(1), grep(1), colrm(1) and grep(1) again, respectively.
X * Typically:
X *    "/bin/ps -cx | /bin/grep -w xalarm | /usr/ucb/colrm 7 | /bin/grep -v %d"
X */
X
#define	GETXALARMPIDS	\
X    "'$ps' -cx | '$grep' -w xalarm | '$colrm' 7 | '$grep' -v %d"
X
/*
X * Full path of kill(1), typically "/bin/kill".
X */
X
#define	KILLPATH	"'$kill'"
' > fns.h
X
echo "+ Created fns.h using these."
echo " "
X
for program in $*; do
X	progpath=`./fullpath $mode $program`
X	if test -f "$progpath"; then
X		echo '#!/bin/sh
exec xmemo -name x'$program' ${1+"$@"} "`'$progpath'`"' > x$program
X		echo "+ Created x$program using this."
X	else
X		echo '#!/bin/sh
exec xmemo -name x'$program' "Sorry, x'$program' is unavailable - no '$program'!"' > x$program
X		echo "+ Created x$program with an apologetic message."
X	fi
X	chmod +x x$program
done
X
echo -n "
Are these OK? [y] "
read ans
case $ans in
X	""|"y"*|"Y"*)	touch .config
X			echo "
Thank you.
";;
X	*)		./config.1st $*;;
esac
SHAR_EOF
chmod 0755 config.1st ||
echo 'restore of config.1st failed'
Wc_c="`wc -c < 'config.1st'`"
test 2498 -eq "$Wc_c" ||
	echo 'config.1st: original size 2498, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= dates.c ==============
if test -f 'dates.c' -a X"$1" != X"-c"; then
	echo 'x - skipping dates.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting dates.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dates.c' &&
/*
X      Copyright (c) 1991, 1992 by Simon Marshall, University of Hull, UK
X
X		   If you still end up late, don't blame me!
X				       
X  Permission to use, copy, modify, distribute, and sell this software and its
X       documentation for any purpose and without fee is hereby granted,
X    provided that the above copyright notice appear in all copies and that
X	both that copyright notice and this permission notice appear in
X			   supporting documentation.
X				       
X  This software is provided AS IS with no warranties of any kind.  The author
X    shall have no liability with respect to the infringement of copyrights,
X     trade secrets or any patents by this file or any part thereof.  In no
X      event will the author be liable for any lost revenue or profits or
X	      other special, indirect and consequential damages.
*/
X
/* 
X * Parse dates.
X */
X
X
X
#include "xalarm.h"
#include "dates.h"
X
X
Boolean		AppointmentWithin();
unsigned long	DateToMilliSeconds();
int		DaysTo();
static int	DaysBetween(), DaysBeforeDate();
static Boolean	ParseDateString();
extern Boolean	ParseTimeString(), IsInteger();
extern String	NextWord();
extern long	TimeToMilliSeconds();
extern time_t	time();
extern struct tm *localtime();
X
X
X
extern AlarmData xalarm;
X
X
X
/* 
X * Is the number of days before the date within the number of days given.
X */
X
Boolean AppointmentWithin (withindays, line, timestr, datestr, chpos)
X  String   line, *timestr, *datestr;
X  int 	   withindays, *chpos;
{
X    String 	    date, word;
X    Boolean 	    dummy;
X    unsigned long   dateout;
X    long 	    timeout;
X    int 	    days, dayofweek, dayofmonth, month, year, hrs, mins;
X
X    if ((*line == '\n') or (*line == '#') or (*line == '!') or (*line == '\0'))
X	return (False);
X
X    /* 
X     * Get the date.
X     */
X    date = XtMalloc (TEXT);
X    date[0] = '\0';
X    while (strcmp (word = NextWord (line, chpos), "-"))
X	if (*word == '\0')
X	    break;
X	else if (date[0] == '\0')
X	    (void) strcpy (date, word);
X	else
X	    (void) sprintf (ENDOF (date), " %s", word);
X
X    if (date[0] == '\0')
X	*datestr = XtNewString ("today");
X    else
X	*datestr = XtNewString (date);
X
X    if (not ParseDateString (*datestr, &days, &dayofweek, &dayofmonth, &month, &year)) {
X	(void) fprintf (stderr, "%s%s", xalarm.errormessage, line);
X	return (False);
X    }
X
X    /*
X     * Get the time.
X     * There might not be a time there, so we ignore any errors.
X     */
X    if (*word == '\0')
X	*timestr = XtNewString ("+0");
X    else {
X	*timestr = NextWord (line, chpos);
X	if (not ParseTimeString (*timestr, &hrs, &mins, &dummy)) {
X	    if (*timestr[0] != '\0')
X		do
X		    (*chpos)--;
X		while (line[*chpos] != ' ');
X	    *timestr = XtNewString ("+0");
X	}
X    }
X    
X    dateout = DateToMilliSeconds (*datestr);
X    timeout = TimeToMilliSeconds (*timestr);
X
X    if (ISVALID (dateout)) {
X	/* 
X	 * We can't just see if the sum is positive 'cos dateout is unsigned...
X	 */
X	days = (int) (dateout / MSECSIN1DAY);
X	return (((days > 0) and (days <= withindays)) or
X		((days == 0) and (timeout >= 0)));
X    } else {
X	/* 
X	 * We don't report errors if the alarm is just too far ahead or gone...
X	 */
X	(void) DateToMilliSeconds (*datestr);
X	if (not (ERRORIS (TOOFARAHEAD) or ERRORIS (DATEPASSED) or ERRORIS (TIMEPASSED)))
X	    (void) fprintf (stderr, "%s%s", xalarm.errormessage, line);
X	return (False);
X    }
}
X
X
X
/* 
X * Returns the number of milliseconds to the date given in datestr.
X */
X
unsigned long DateToMilliSeconds (datestr)
X  String   datestr;
{
X    char   baddate[TEXT];
X    int    days, dayofweek, dayofmonth, month, year;
X
X    if (*datestr == '\0')
X	return ((unsigned long) 0);
X    else if (not ParseDateString (datestr, &days, &dayofweek, &dayofmonth, &month, &year))
X	return ((unsigned long) INVALID);
X
X    if (ISINVALID (days))
X	days = DaysBeforeDate (dayofweek, dayofmonth, month, year);
X
X    if (((days > 0) and (days <= MAXDAYS)) or
X	((days == 0) and (ISINVALID (xalarm.timeout) or (xalarm.timeout >= 0))))
X	return ((unsigned long) days * MSECSIN1DAY);
X    else {
X	if ((days == 0) and (ISVALID (xalarm.timeout)) and (xalarm.timeout < 0)) {
X	    ADDERROR (TIMEPASSED, (String) NULL);
X	} else if (days < 0) {
X	    (void) sprintf (baddate, "%d days", days);
X	    ADDERROR (DATEPASSED, baddate);
X	} else {
X	    (void) sprintf (baddate, "+%d days", days);
X	    ADDERROR (TOOFARAHEAD, baddate);
X	}
X	return ((unsigned long) INVALID);
X    }
}
X
X
X
/* 
X * Parse that string.  I did this one myself!
X * Works in whole days only.
X */
X
static Boolean ParseDateString (str, days, dayofweek, dayofmonth, month, year)
X  String   str;
X  int 	  *days, *dayofweek, *dayofmonth, *month, *year;
{
X    static int 	  daysin[] = {DAYSINMONTHS};
X    static char   strings[][4] = {WEEKDAYS, MONTHS, TODAY, DAILY, TOMORROW, WEEK, WEEKLY,
X				  "!!!", "!!!"};
X    String 	  word, monthstr = (String) NULL;
X    time_t 	  now;
X    struct tm 	 *today;
X    int 	  thisyear, num, i, chpos = 0;
X    
X    RESETERROR ();
X    
X    *days = *dayofweek = *dayofmonth = *month = *year = -1;
X
X    (void) time (&now);
X    today = localtime (&now);
X
X    if ((*str == '+') and (IsInteger (str)))
X	*days = atoi (str);
X    else
X	while (strcmp (word = NextWord (str, &chpos), "")) {
X	    i = 0;
X	    while ((not (STREQUAL (word, strings[i]))) and (i < XtNumber (strings)))
X		i++;
X
X	    if (i == 19)				/* TODAY. */
X		*days = 0;
X	    else if (i == 20)				/* DAILY. */
X		*days = 1;
X	    else if (i == 21)				/* TOMORROW. */
X		if (*days < 0)
X		    *days = 1;
X		else
X		    (*days)++;
X	    else if ((i == 22) or (i == 23))		/* WEEK or WEEKLY. */
X		if (*days < 0)
X		    *days = 7;
X		else
X		    (*days) += 7;
X	    else if (i < 7)				/* Weekday. */
X		if (*dayofweek < 0)
X		    *dayofweek = i;
X		else {
X		    ADDERROR (ANOTHERWEEKDAY, word);
X		    return (False);
X		}
X	    else if (i < 19)				/* Month. */
X		if (*month < 0) {
X		    *month = i-7;
X		    monthstr = word;
X		} else {
X		    ADDERROR (ANOTHERMONTH, word);
X		    return (False);
X		}
X	    else if (((num = atoi (word)) <= 0) or (not IsInteger (word))) {
X		    ADDERROR (UNRECOGNISED, word);
X		    return (False);
X		}
X		/*
X		 * Otherwise assume it's a year or a month day.
X		 */
X		else if (num > 90)
X		    if (*year < 0)
X			*year = num;
X		    else {
X			ADDERROR (ANOTHERYEAR, word);
X			return (False);
X		    }
X		else
X		    if (*dayofmonth < 0)
X			*dayofmonth = num;
X		    else {
X			ADDERROR (ANOTHERMONTH, word);
X			return (False);
X		    }
X	}
X    
X    /* 
X     * Have we been given a day + day of week, like "week tues"?
X     */
X    if ((*days > 0) and (*dayofweek >= 0))
X	(*days) += ((*dayofweek + 7) - today->tm_wday) % 7;
X
X    /* 
X     * Check that the day of month is OK for this month.
X     */
X    if ((*month >= 0) and (*dayofmonth > 0)) {
X	if ((thisyear = *year) < 0)
X	    thisyear = today->tm_year + 1900;
X	daysin[1] = DAYSINFEB (thisyear);
X	if (*dayofmonth > daysin[*month]) {
X	    ADDERROR (WRONGDAYSMONTH, monthstr);
X	    return (False);
X	}
X    }
X    
X    return (True);
}
X
X
X
/* 
X * Calculates the number of *whole* days before the date given by the args.
X */
X
static int DaysBeforeDate (dayofweek, dayofmonth, month, year)
X  int 	   dayofweek, dayofmonth, month, year;
{
X    static int 	 daysin[] = {DAYSINMONTHS};
X    struct tm 	 today, *date;
X    time_t 	 now;
X
X    (void) time (&now);
X    date = localtime (&now);
X    today.tm_yday = date->tm_yday;
X    today.tm_year = date->tm_year;
X
X    if (year > 99)
X	year = year - 1900;
X
X    if (dayofweek < 0) {
X	/* 
X	 * If no day of week is given, just use the day/month/year date.
X	 * Cycle through the month/year.
X	 */
X	if (dayofmonth >= 0)		date->tm_mday = dayofmonth;
X	if (month >= 0)			date->tm_mon = month;
X	if (year >= 0)			date->tm_year = year;
X	while ((year < 0) and (date->tm_year < (2500-1900)) and
X	       (DaysBetween (&today, date) < 0))
X	    if (month < 0)
X		date->tm_mon = (date->tm_mon + 1) % 12;
X	    else
X		date->tm_year++;
X    } else
X	/* 
X	 * We assume Buck Rodgers will have something better than xalarm...
X	 * Cycle through dates until we find it.
X	 */
X	while ((date->tm_year < (2500-1900)) and 
X	       (((dayofweek >= 0) and	(dayofweek != date->tm_wday)) or
X		((dayofmonth >= 0) and	(dayofmonth != date->tm_mday)) or
X		((month >= 0) and	(month != date->tm_mon)) or
X		((year >= 0) and	(year != date->tm_year)))) {
X	    /* 
X	     * Just add one to the week day & month day...
X	     */
X	    date->tm_wday = (date->tm_wday + 1) % 7;
X	    date->tm_mday++;
X	    daysin[1] = DAYSINFEB (date->tm_year + 1900);
X	    if (date->tm_mday > daysin[date->tm_mon]) {
X		date->tm_mday = 1;
X		date->tm_mon++;
X		if (date->tm_mon > 11) {
X		    date->tm_mon = 0;
X		    date->tm_year++;
X		}
X	    }
X	}
X
X    return (DaysBetween (&today, date));
}
X
X
X
/* 
X * Why oh why don't all systems have timelocal()?
X */
X
static int DaysBetween (today, date)
X  struct tm  *today, *date;
{
X    static int 	 daysin[] = {DAYSINMONTHS};
X    int 	 i, dayofyear = date->tm_mday-1, daysbetween = 0;
X
X    for (i=0; i<date->tm_mon; i++)
X	if (i == 1)
X	    dayofyear += DAYSINFEB (date->tm_year + 1900);
X	else
X	    dayofyear += daysin[i];
X
X    if (date->tm_year == today->tm_year)
X	return (dayofyear - today->tm_yday);
X    else {
X	for (i = 1 + MIN (date->tm_year, today->tm_year);
X	     i < MAX (date->tm_year, today->tm_year); i++)
X	    daysbetween += DAYSINYEAR (i + 1900);
X
X	daysbetween += (date->tm_year > today->tm_year) ?
X			dayofyear + (DAYSINYEAR (today->tm_year+1900) - today->tm_yday) :
X			today->tm_yday + (DAYSINYEAR (date->tm_year+1900) - dayofyear);
X
X	return ((date->tm_year > today->tm_year) ? daysbetween : -daysbetween);
X    }
}
X
X
X
/* 
X * Returns the number of days before the date given.  WEEK is special.
X * WEEK means until the end of the current week.
X */
X
int DaysTo (datestr, inst)
X  String     datestr;
X  Instance   inst;
{
X    time_t 	    abstime;
X    struct tm 	   *now;
X    unsigned long   millisecs;
X
X    (void) time (&abstime);
X    now = localtime (&abstime);
X
X    if (STREQUAL (datestr, WEEK))
X	if (inst == Daemon)
X	    return (DAEMONWEEKLY);
X	else
X	    return (7 - now->tm_wday);
X    else
X	if (ISVALID (millisecs = DateToMilliSeconds (datestr)))
X	    return ((int) (millisecs / MSECSIN1DAY));
X	else
X	    return (INVALID);
}
SHAR_EOF
chmod 0644 dates.c ||
echo 'restore of dates.c failed'
Wc_c="`wc -c < 'dates.c'`"
test 10134 -eq "$Wc_c" ||
	echo 'dates.c: original size 10134, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= dates.h ==============
if test -f 'dates.h' -a X"$1" != X"-c"; then
	echo 'x - skipping dates.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting dates.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dates.h' &&
/*
X      Copyright (c) 1991, 1992 by Simon Marshall, University of Hull, UK
X
X		   If you still end up late, don't blame me!
X				       
X  Permission to use, copy, modify, distribute, and sell this software and its
X       documentation for any purpose and without fee is hereby granted,
X    provided that the above copyright notice appear in all copies and that
X	both that copyright notice and this permission notice appear in
X			   supporting documentation.
X				       
X  This software is provided AS IS with no warranties of any kind.  The author
X    shall have no liability with respect to the infringement of copyrights,
X     trade secrets or any patents by this file or any part thereof.  In no
X      event will the author be liable for any lost revenue or profits or
X	      other special, indirect and consequential damages.
*/
X
/* 
X * Various stuff to do with dates & times.
X * 
X * Maximum allowed days based on a 32-bit unsigned long, ie. 2^32 / 24*60*60*1000.
X */
X
#define		MAXDAYS		(49)
X
/*
X * Change these if you want a different notation/language.  Keep it to 
X * 3 chars each, lower case only.
X */
X
#define		WEEKDAYS	"sun", "mon", "tue", "wed", "thu", "fri", "sat"
#define		MONTHS		"jan", "feb", "mar", "apr", "may", "jun", \
X				"jul", "aug", "sep", "oct", "nov", "dec"
#define		DAYSINMONTHS	31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
#define		TODAY		"tod"
#define		DAILY		"dai"
#define		TOMORROW	"tom"
#define		WEEK		"wee"
#define		WEEKLY		"wee"
#define		NOW		"now"
#define		NOON		"noo"
X
/* 
X * Error messages.
X */
X
#define		DATEPASSED	"The date has passed."
#define		TOOFARAHEAD	"Too far ahead, I'm afraid."
#define		ANOTHERWEEKDAY	"Another weekday?"
#define		ANOTHERMONTH	"Another month?"
#define		ANOTHERYEAR	"Another year?"
#define		WRONGDAYSMONTH	"Wrong days in month?"
#define		WRONGNUMDIGITS	"Wrong number of digits."
#define		TIMEPASSED	"The time has passed today."
#define		EXPECTEDAMPM	"Expected am/pm."
#define		BADHOURS	"Bad number of hours."
#define		BADMINUTES	"Bad number of minutes."
#define		UNRECOGNISED	"Don't recognise this."
SHAR_EOF
chmod 0644 dates.h ||
echo 'restore of dates.h failed'
Wc_c="`wc -c < 'dates.h'`"
test 2064 -eq "$Wc_c" ||
	echo 'dates.h: original size 2064, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= file.c ==============
if test -f 'file.c' -a X"$1" != X"-c"; then
	echo 'x - skipping file.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting file.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'file.c' &&
/*
X      Copyright (c) 1991, 1992 by Simon Marshall, University of Hull, UK
X
X		   If you still end up late, don't blame me!
X				       
X  Permission to use, copy, modify, distribute, and sell this software and its
X       documentation for any purpose and without fee is hereby granted,
X    provided that the above copyright notice appear in all copies and that
X	both that copyright notice and this permission notice appear in
X			   supporting documentation.
X				       
X  This software is provided AS IS with no warranties of any kind.  The author
X    shall have no liability with respect to the infringement of copyrights,
X     trade secrets or any patents by this file or any part thereof.  In no
X      event will the author be liable for any lost revenue or profits or
X	      other special, indirect and consequential damages.
*/
X
/* 
X * Deal with the appointments alarm file.
X */
X
X
#include "xalarm.h"
#include "dates.h"
X
#include <X11/Xaw/Dialog.h>
X
/* 
X * We use fcntl() to lock files, or we can use flock() or lockf():
X */
X
#if defined (USEFLOCK)
#include <sys/file.h>
#elif defined (USELOCKF)
#include <unistd.h>
#elif not defined (SEEK_SET)
#define SEEK_SET 0
#endif
X
X
#define		ALARMFILEFORMAT		"\n%s %s %2d - %s\t%s\n"
#define		DIALOGVALUE(widget)	(XtNewString (XawDialogGetValueString (widget)))
#define		UPCASE(ch)		(((ch) >= 'a') and ((ch) <= 'z') ? \
X					 ((ch) - 'a' + 'A') : (ch))
X
X
void		SaveAlarmSettings(), AlarmDying(), RestartDiedAlarms();
int		ParseAlarmFile();
static Boolean	SaveAlarm();
static void	RenameFile();
extern Boolean	AppointmentWithin();
extern long	TimeToMilliSeconds();
extern unsigned long DateToMilliSeconds();
extern String	ReplaceNewlines(), HomeDirectory(), DisplayName(), getenv();
extern void	DoAlarm(), EditedText(), MakeConfirmMessage(), EnsureNotGrownOffScreen();
extern FORKRET	fork();
extern time_t	time();
extern struct tm *localtime();
X
X
X
extern AlarmData	xalarm;
X
X
X
/* 
X * Parse each line of the alarm file, if it's around.  If the 
X * appointment is within that given, fork and do the alarm.  Returns
X * number forked.
X */
X
int ParseAlarmFile (days, argv, argc)
X  String  *argv;
X  int 	   days, argc;
{
X    FILE     *file;
X    String    timestr, datestr, alarmfilepath = getenv ("XALARMFILEPATH"),
X	      home = HomeDirectory ();
X    Boolean   failed = True;
X    char      alarmpath[TEXT], filename[TEXT], line[TEXT];
X    int       newargc, endofdate, start, finish = 0, kids = 0;
X    
X    (void) sprintf (alarmpath, "%s/.xalarms", HomeDirectory ());
X    if (NONNIL (String, alarmfilepath))
X	(void) sprintf (ENDOF (alarmpath), ":%s", alarmfilepath);
X
X    do {
X	/* 
X	 * Try each file in the path list.
X	 */
X	start = finish;
X	while ((alarmpath[finish] != '\0') and (alarmpath[finish] != ':'))
X	    finish++;
X
X	if (alarmpath[start] == '/') {
X	    (void) strncpy (filename, alarmpath+start, finish-start);
X	    filename[finish-start] = '\0';
X	} else {
X	    (void) sprintf (filename, "%s/", home);
X	    (void) strncpy (ENDOF (filename), alarmpath+start, finish-start);
X	    filename[finish-start + strlen (home)+1] = '\0';
X	}
X
X	if (NONNIL (FILE *, (file = fopen (filename, "r")))) {
X	    /* 
X	     * Deal with this file.
X	     */
X	    failed = False;
X
X	    while (NONNIL (String, fgets (line, TEXT, file))) {
X		endofdate = 0;
X		if (AppointmentWithin (days, line, &timestr, &datestr, &endofdate)) {
X		    while (isspace (line[endofdate]))
X			endofdate++;
X		    
X		    newargc = argc;
X		    argv[newargc++] = XtNewString ("-time");
X		    argv[newargc++] = timestr;
X		    argv[newargc++] = XtNewString ("-date");
X		    argv[newargc++] = datestr;
X		    
X		    if (line[endofdate] != '\0') {
X			line[strlen (line) - 1] = '\0';
X			argv[newargc++] = line+endofdate;
X		    }
X
X		    switch ((int) fork ()) {
X		     case -1:
X			perror ("xalarm");
X			exit (-1);
X		     case 0:
X			DoAlarm (argv, newargc);
X		     default:
X			kids++;
X		    }
X		}
X	    }
X	}
X	
X	while (alarmpath[finish] == ':')
X	    finish++;
X    } while (alarmpath[finish] != '\0');
X
X    if (failed)
X	fprintf (stderr, "Failed to open any of these alarm files:\n%s\n", alarmpath);
X
X    return (kids);
}
X
X
X
/* 
X * Save the alarm settings in the alarm file.
X */
X
void SaveAlarmSettings (widget, clientdata, calldata)
X  Widget      widget;
X  XtPointer   clientdata, calldata;
{
X    String   message = DIALOGVALUE (xalarm.confirmwidget);
X    char     buf[TEXT], filename[TEXT];
X    
X    if (*message != '\0')
X	XtVaSetValues (xalarm.messagewidget, XtNlabel,
X		       (XtArgVal) (xalarm.messagestr = message), NULL);
X    
X    MakeConfirmMessage (buf);
X    (void) sprintf (filename, "%s/%s", HomeDirectory (), XALARMFILE);
X    if (not SaveAlarm (filename))
X	(void) sprintf (ENDOF (buf), "\nCouldn't open %s", filename);
X    else {
X	(void) sprintf (ENDOF (buf), "\nSaved in %s", filename);
X	EditedText ((Widget) NULL, (XtPointer) NULL, (XtPointer) False);
X    }
X
X    XtVaSetValues (xalarm.confirmwidget, XtNlabel, (XtArgVal) buf, NULL);
X    EnsureNotGrownOffScreen (XtParent (XtParent (xalarm.confirmwidget)));
}
X
X
X
/* 
X * Save the alarm in the alarm-died file.  Can be resurrected later.
X */
X
void AlarmDying (display)
X  Display  *display;
{
X    char   filename[TEXT];
X
X    if (xalarm.saveonshutdown) {
X	(void) sprintf (filename, "%s/%s.died", HomeDirectory (), XALARMFILE);
X	if (not SaveAlarm (filename))
X	    (void) fprintf (stderr, "xalarm: Couldn't open %s\n", filename);
X    }
X
X    exit (0);
}
X
X
X
/* 
X * Save the current alarm.
X */
X
static Boolean SaveAlarm (filename)
X  String   filename;
{
X    FILE 	  *file;
X    static char    days[][4] = {WEEKDAYS}, months[][4] = {MONTHS};
#if not (defined (USEFLOCK) or defined (USELOCKF))
X    struct flock   lock;
#endif
X    time_t 	   now;
X    struct tm 	  *alarmtime;
X
X    (void) umask (63);
X    if (NONNIL (FILE *, (file = fopen (filename, "a")))) {
#if defined (USEFLOCK)
X	flock (fileno (file), LOCK_EX);
#elif defined (USELOCKF)
X	lockf (fileno (file), F_LOCK, (long) 0);
#else
X	lock.l_type = F_WRLCK;
X	lock.l_whence = SEEK_SET;
X	lock.l_start = lock.l_len = (long) 0;
X	fcntl (fileno (file), F_SETFL, O_SYNC);
X	fcntl (fileno (file), F_SETLKW, &lock);
#endif
X
X	(void) time (&now);
X	now += ((TimeToMilliSeconds (xalarm.timestr) +
X		 DateToMilliSeconds (xalarm.datestr)) / MSECSIN1SEC);
X	alarmtime = localtime (&now);
X
X	days[alarmtime->tm_wday][0] = UPCASE (days[alarmtime->tm_wday][0]);
X	months[alarmtime->tm_mon][0] = UPCASE (months[alarmtime->tm_mon][0]);
X
#if defined (USELSEEK)
X	lseek (fileno (file), (off_t) 0, L_XTND);
#else
X	fseek (file, (long) 0, 2);
#endif
X
X	(void) fprintf (file, ALARMFILEFORMAT, days[alarmtime->tm_wday],
X			months[alarmtime->tm_mon], alarmtime->tm_mday,
X			xalarm.timestr, ReplaceNewlines (xalarm.messagestr));
X
X	fflush (file);
#if defined (USEFLOCK)
X	flock (fileno (file), LOCK_UN);
#elif defined (USELOCKF)
X	lockf (fileno (file), F_ULOCK, (long) 0);
#else
X	lock.l_type = F_UNLCK;
X	fcntl (fileno (file), F_SETLK, &lock);
#endif
X	fclose (file);
X    }
X
X    return (NONNIL (FILE *, file));
}
X
X
X
/* 
X * Check to see if there are any old alarms, then restart them.
X */
X
void RestartDiedAlarms (argv, argc)
X  String  *argv;
X  int 	   argc;
{
X    Display  *display;
X    char      diedfilename[TEXT], livefilename[TEXT], tmp[TEXT];
X    int       kids;
X    
X    (void) sprintf (diedfilename, "%s/%s.died", HomeDirectory (), XALARMFILE);
X    if (access (diedfilename, R_OK) == 0)
X	if (NIL (Display *, (display = XOpenDisplay (DisplayName (argv, argc)))))
X	    (void) fprintf (stderr, "xalarm: Can't open display to restart alarms.\n");
X	else {
X	    /* Save the current alarm file. */
X	    (void) sprintf (livefilename, "%s/%s", HomeDirectory (), XALARMFILE);
X	    (void) sprintf (tmp, "%s/%s.%05d", HomeDirectory (), XALARMFILE, getpid ());
X	    if (access (livefilename, R_OK) == 0)
X		RenameFile (livefilename, tmp);
X	    RenameFile (diedfilename, livefilename);
X	    
X	    /* Parse this file as if it were the alarm file. */
X	    xalarm.saveonshutdown = True;
X	    kids = ParseAlarmFile (MAXDAYS, argv, argc);
X	    while (kids-- > 0)
X		(void) wait ((int *) NULL);
X	    (void) unlink (livefilename);
X	    
X	    /* Restore the alarm file. */
X	    if (access (tmp, R_OK) == 0)
X		RenameFile (tmp, livefilename);
X	    XCloseDisplay (display);
X	}
}
X
X
X
/* 
X * Rename the file.
X */
X
static void RenameFile (from, to)
X  String   from, to;
{
#if defined (USERENAME)
X    (void) rename (from, to);
#else
X    (void) unlink (to);
X    (void) link (from, to);
X    (void) unlink (from);
#endif
}
SHAR_EOF
chmod 0644 file.c ||
echo 'restore of file.c failed'
Wc_c="`wc -c < 'file.c'`"
test 8441 -eq "$Wc_c" ||
	echo 'file.c: original size 8441, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= fns.c ==============
if test -f 'fns.c' -a X"$1" != X"-c"; then
	echo 'x - skipping fns.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting fns.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'fns.c' &&
/*
X      Copyright (c) 1991, 1992 by Simon Marshall, University of Hull, UK
X
X		   If you still end up late, don't blame me!
X				       
X  Permission to use, copy, modify, distribute, and sell this software and its
X       documentation for any purpose and without fee is hereby granted,
X    provided that the above copyright notice appear in all copies and that
X	both that copyright notice and this permission notice appear in
X			   supporting documentation.
X				       
X  This software is provided AS IS with no warranties of any kind.  The author
X    shall have no liability with respect to the infringement of copyrights,
X     trade secrets or any patents by this file or any part thereof.  In no
X      event will the author be liable for any lost revenue or profits or
X	      other special, indirect and consequential damages.
*/
X
/* 
X * Just a few bits and bobs.
X */
X
X
#include "xalarm.h"
#include "fns.h"
X
#if defined (USEGETPWUID)
#include <pwd.h>
#else
extern String	getenv();
#endif
X
#if defined (USEUNAME)
#include <sys/utsname.h>
#endif
X
X
#define		FILEOPTION1	"-file"
#define		FILEOPTION2	"-f"
#define		DAEMONOPTION1	"-daemon"
#define		DAEMONOPTION2	"-demon"
#define		RESTARTONLY1	"-restartonly"
#define		RESTARTONLY2	"-restart"
X
#define		COMMANDLIST	"echo xalarms: `%s`"
#define		COMMANDRESET	"%s -USR1 `%s`"
#define		COMMANDKILL	"%s -USR2 `%s`"
#define		DOWNCASE(ch)	(((ch) >= 'A') and ((ch) <= 'Z') ? \
X				 ((ch) - 'A' + 'a') : (ch))
X
X
X
String		Concat(), ReplaceNewlines(), NextWord(), DisplayName(),
X		UserName(), HomeDirectory(), MachineName();
Boolean		IsInteger();
Instance	PreParseArgList();
XXtIntervalId	ResetTracker();
SIGRET		KillAlarm();
void		Initialise(), AddTimeOuts(), SetWMName(), StartDaemon(),
X		SetGeometry(), EnsureNotGrownOffScreen(), Audio(), Quit();
static void	CentreWidgetUnderPointer(), ParseGeometry();
static SIGRET	KillDaemon();
extern void	DoAlarm(), Warning(), WakeUp(), PopupAndAsk();
extern FORKRET	fork();
extern int	ParseAlarmFile(), DaysTo();
extern long	TimeToMilliSeconds();
extern unsigned long DateToMilliSeconds();
extern time_t	time();
extern struct tm *localtime();
X
X
X
extern AlarmData   xalarm;
X
X
/* 
X * Just give a bit of help etc.
X * Fork off a child otherwise.
X */
X
void Initialise (proggie, data)
X  String     proggie;
X  ApplData  *data;
{
X    char   getpids[TEXT], command[TEXT];
X
X    if (NIL (String, data->proggie))
X	data->proggie = proggie;
X
X    if (data->version)
X	(void) printf ("%s: using xalarm version %s\n", data->proggie, XALARMVERSION);
X
X    if (data->help) {
X	(void) printf ("Usage: %s [options] [text]\n\n", data->proggie);
X	(void) printf ("Default values for these resources/options are used by %s,\n\t",
X		       data->proggie);
X	(void) printf ("but may be over-ruled.\n");
X	(void) printf ("Usual X options, plus:\n\t");
X	(void) printf ("-file +days|date\tSet alarms up to date from alarm file(s).\n\t");
X	(void) printf ("-daemon +days|date\tStart a daemon to look at alarm file(s).\n\t");
X	(void) printf ("-date +days|date\tDate at which to trigger %s.\n\t",
X		       data->proggie+1);
X	(void) printf ("-time +time|time\tTime at which to trigger %s.\n\t",
X		       data->proggie+1);
X	(void) printf ("-[no]confirm\t\t[Don't] ask for confirmation.\n\t");
X	(void) printf ("-warn time[,time...]\tTimes before %s for warnings.\n\t",
X		       data->proggie+1);
X	(void) printf ("-warnwords number\tWords from %s message in warning.\n\t",
X		       data->proggie+1);
X	(void) printf ("-list\t\t\tList xalarm process numbers (pids).\n\t");
X	(void) printf ("-reset pid|all\t\tReset xalarm process number pid/all xalarms.\n\t");
X	(void) printf ("-kill pid|all\t\tKill xalarm process number pid/all xalarms.\n\t");
X	(void) printf ("-restart\t\tOnly try to restart previous alarms.\n\t");
X	(void) printf ("-alarmaudio method\tWhat noise to make on the alarm.\n\t");
X	(void) printf ("-warningaudio method\tWhat noise to make on warnings.\n\t");
X	(void) printf ("-volume percentage\tPercentage volume for the terminal bell.\n\t");
X	(void) printf ("-quiet\t\t\tDon't make a sound.\n\t");
X	(void) printf ("-pester time\t\tTime after which %s re-triggers.\n\t",
X		       data->proggie+1);
X	(void) printf ("-snooze time\t\tSet initial alarm snooze time value.\n\t");
X	(void) printf ("-nowarn\t\t\tNo warnings.\n\t");
X	(void) printf ("-nowarnwords\t\tNo words from %s message in warning.\n\t",
X		       data->proggie+1);
X	(void) printf ("-nopester\t\tDon't persecute after %s triggers.\n",
X		       data->proggie+1);
X    }
X
X    if (data->list) {
X	(void) sprintf (getpids, GETXALARMPIDS, getpid ());
X	(void) sprintf (command, COMMANDLIST, getpids);
X	if (system (command) != 0)
X	    perror (data->proggie);
X    }
X
X    if (NONNIL (String, data->reset))
X	if (not STREQUAL (data->reset, ALL)) {
X	    if (kill (atoi (data->reset), SIGUSR1) == -1)
X		perror (data->proggie);
X	} else {
X	    (void) sprintf (getpids, GETXALARMPIDS, getpid ());
X	    (void) sprintf (command, COMMANDRESET, KILLPATH, getpids);
X	    if (system (command) != 0)
X		perror (data->proggie);
X	}
X
X    if (NONNIL (String, data->kill))
X	if (not STREQUAL (data->kill, ALL)) {
X	    if (kill (atoi (data->kill), SIGUSR2) == -1)
X		perror (data->proggie);
X	} else {
X	    (void) sprintf (getpids, GETXALARMPIDS, getpid ());
X	    (void) sprintf (command, COMMANDKILL, KILLPATH, getpids);
X	    if (system (command) != 0)
X		perror (data->proggie);
X	}
X
X    if ((data->list) or (data->version) or (data->help) or
X	(NONNIL (String, data->kill)) or (NONNIL (String, data->reset)))
X	exit (0);
X
X    /* 
X     * Fork & exit the parent.  If the fork fails, carry on anyway.
X     * Is this OK?  Should we sleep a bit first?
X     */
X
X    switch ((int) fork ()) {
X     case -1:
X	perror (data->proggie);
X     case 0:
X	break;
X     default:
X	exit (0);
X    }
}
X
X
X
/* 
X * Check to see if we're to do the appointments thing, and copy out 
X * the arg list, then clear the original to prevent others snooping.
X */
X
Instance PreParseArgList (argv, argc, days, args)
X  String  *argv, **args;
X  int 	  *argc, *days;
{
X    String     ch;
X    Instance   instance = Alarm;
X    int        last = *argc, i;
X
X    *args = (String *) XtCalloc (*argc+4, sizeof (String *));
X    (*args)[0] = XtNewString (argv[0]);
X    *argc = 1;
X
X    for (i=1; i<last; i++)
X	if ((STREQUAL (argv[i], RESTARTONLY1)) or (STREQUAL (argv[i], RESTARTONLY2)))
X	    instance = RestartOnly;
X	else if ((STREQUAL (argv[i], FILEOPTION1)) or
X		 (STREQUAL (argv[i], FILEOPTION2))) {
X	    if (++i == last) {
X		(void) fprintf (stderr, "No file date to parse alarm file with.\n");
X		exit (-1);
X	    } else if (ISINVALID (*days = DaysTo (argv[i], instance = File))) {
X		(void) fprintf (stderr, "Can't use file date: %s", xalarm.errormessage);
SHAR_EOF
true || echo 'restore of fns.c failed'
fi
echo 'End of  part 3'
echo 'File fns.c is continued in part 4'
echo 4 > _shar_seq_.tmp
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
