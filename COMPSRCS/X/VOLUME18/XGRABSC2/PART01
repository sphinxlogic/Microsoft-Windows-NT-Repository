Path: uunet!ogicse!uwm.edu!caen!sdd.hp.com!mips!msi!dcmartin
From: bruce@SLC.COM (Bruce Schuchardt)
Newsgroups: comp.sources.x
Subject: v18i052: xgrabsc v2.1 - grab screen dump, Part01/05
Message-ID: <csx-18i052-xgrabsc-2.1@uunet.UU.NET>
Date: 23 Jul 92 14:01:26 GMT
Article-I.D.: uunet.csx-18i052-xgrabsc-2.1
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1760
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: bruce@SLC.COM (Bruce Schuchardt)
Posting-number: Volume 18, Issue 52
Archive-name: xgrabsc-2.1/part01

INTRO TO xgrabsc

When I first wrote xgrabsc, there were a number of programs available
for getting X-Window screen dumps (e.g., xwd and xwps), but they
were all restricted to dumping a single window in a single format.
I wrote xgrabsc in an effort to get around these restrictions.

The main contribution of this program is its use of root-window
rubberbanding to allow capture of arbitrary portions of the screen,
and its multiple output formats (x-bitmap, x-pixmap, xwd, puzzle,
"simple", and several Postscript formats).

The Postscript dumps will use run-length encoding if it results in
any savings in size.  A typical xterm window dump on a mono system
runs around 40K bytes (20K for binary output).  An xwd dump on the
same screen will be around 650K bytes.  While the xpr program has a
"compress" option, it only compresses white samples.  Reducing the 
size of the output increases the cost of computing the dump and the
final printing of the dump, but it reduces the cost of storage and
the time to transfer the dump to your printer.  The latter is
especially important for large screen dumps.

This release (2.1) adds the following features:

* xgrabsc no longer uses getopt(), and most command line switches have been
  changed from single-characters to keywords.  Users of previous versions
  of xgrabsc should make sure any XGRABSC environment variables are updated
  to reflect this change.
  
* Command line switches may be preceded with '-' (e.g., -preview) or
  '--' (e.g., --preview).  A double dash turns off an option, while a
  single or omitted dash turns on an option.  Each argument and switch must
  be seperated with white space.

* New xgrabsc options

  preview	a preview option for encapsulated postscript output
  page		page size and border specification
  nodither	turns off any selected dithering options
  colproc	adds/removes the colorImage operator from color postscript
		output
  bm3		write color output in XPM3 format

* All xgrab text fields but the Alternate Display are now set in XGrab.ad
  instead of xgrab.c.  This means you can now put defaults for these fields
  in your .Xdefaults

* border removal now attempts to remove the window-mgr's title as well.

#!/bin/sh
# This is a shell archive (produced by shar 3.50)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 07/23/1992 13:57 UTC by dcmartin@fascet
# Source directory /home/fascet/dcmartin/csx/src/tmp/xgrabsc.2_1
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#    988 -rw-r--r-- ad2c.sed
#  36231 -rw-r--r-- write.hc
#  15159 -rw-r--r-- xgrabsc.man
#   3103 -rw-r--r-- Bugs
#   5078 -rw-r--r-- README
#   3026 -rw-r--r-- README.2_1
#    552 -rw-r--r-- VMSMAKE.COM
#   3313 -rw-r--r-- XWDFile.h
#   4635 -rw-r--r-- Xmd.h
#   2917 -rw-r--r-- cmdopts.h
#   3177 -rw-r--r-- config.h
#   7414 -rw-r--r-- get.hc
#   7579 -rw-r--r-- process.hc
#   5078 -rw-r--r-- ps_color.h
#   4071 -rw-r--r-- xgrab.man
#   1104 -rw-r--r-- Acks
#    976 -rw-r--r-- Imakefile
#    960 -rw-r--r-- checkvm.h
#   1443 -rw-r--r-- cpyright.h
#   1651 -rw-r--r-- mem.hc
#    856 -rw-r--r-- patchlevel.h
#   1493 -rw-r--r-- showvm.ps
#   2375 -rw-r--r-- virtual.h
#   8449 -rw-r--r-- XGrab.ad
#   9241 -rw-r--r-- convert.hc
#   1725 -rw-r--r-- simple.mak
#  12758 -rw-r--r-- xgrab.c
#  18405 -rw-r--r-- xgrabsc.c
#  10735 -rw-r--r-- Makefile
#   8142 -rw-r--r-- xgrab_ad.h
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= ad2c.sed ==============
if test -f 'ad2c.sed' -a X"$1" != X"-c"; then
	echo 'x - skipping ad2c.sed (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ad2c.sed (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ad2c.sed' &&
#========================================================================
#
# Name - ad2c.sed
#
# Version:	1.2
#
# ccsid:	@(#)ad2c.sed	1.2 - 7/9/92 12:48:17
# from: 	ccs/s.ad2c.sed
# date: 	7/9/92 13:35:26
#
#  Name - ad2c.sed, part of the ad2c package by George Ferguson
#
#  Description:
#
#	Convert app-defaults file to C strings decls.
#
#	Invoke by: sed -n -f ad2c.sed
#
#
#  This is part of an older version of the ad2c package.
#  If you need to create fallback resources from .ad files, get the full
#  package.
#
# ========================================================================
X
: read
# remove comments
/^!/d
/^#/d
# remove blanks
/^$/d
# escape quotes
s/"/\\"/g
# escape backslash
s/\\/\\\\/g
# except the line continuation ones
s/\\$//g
# add leading quote
s/^/"/
#
: test
/\\$/b slash
s/$/",/
p
n
b read
#
: slash
p
n
# just like "read" only doesn't add leading quote
/^!/d
/^$/d
s/"/\\"/g
s/\\\\/\\/g
s/\\n/\\\\n/g
s/\\t/\\\\t/g
s/\\f/\\\\f/g
s/\\b/\\\\b/g
b test
SHAR_EOF
chmod 0644 ad2c.sed ||
echo 'restore of ad2c.sed failed'
Wc_c="`wc -c < 'ad2c.sed'`"
test 988 -eq "$Wc_c" ||
	echo 'ad2c.sed: original size 988, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= write.hc ==============
if test -f 'write.hc' -a X"$1" != X"-c"; then
	echo 'x - skipping write.hc (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting write.hc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'write.hc' &&
/*========================================================================
X *
X * Name - write.hc
X *
X * ccs version:	1.3
X *
X * ccsid:	@(#)write.hc	1.3 - 7/9/92 12:49:14
X * from: 	ccs/s.write.hc
X * date: 	7/9/92 13:35:29
X *
X * Description:  output conversions for xgrabsc
X *
X *               see cpyright.h for copyright information
X *
X *
X *========================================================================
X */
X
X
/* swap the bits in a byte */
swapbits(b)
X  byte b;
{
X  byte b2;
X
X  b2 = 0;
X  b2 |= (b & 0x01) << 7;
X  b2 |= (b & 0x02) << 5;
X  b2 |= (b & 0x04) << 3;
X  b2 |= (b & 0x08) << 1;
X  b2 |= (b & 0x10) >> 1;
X  b2 |= (b & 0x20) >> 3;
X  b2 |= (b & 0x40) >> 5;
X  b2 |= (b & 0x80) >> 7;
X  return b2;
}
X
X
X
X
/* swap the bytes in a long int */
swapbytes(pDblw)
X  dw *pDblw;
X  {
X  union {
X    dw  dbl;
X    byte bytes[4];
X    } cnv;
X  byte aByte;
X
X  cnv.dbl = *pDblw;
X  aByte = cnv.bytes[0];
X  cnv.bytes[0] = cnv.bytes[3];
X  cnv.bytes[3] = aByte;
X  aByte = cnv.bytes[1];
X  cnv.bytes[1] = cnv.bytes[2];
X  cnv.bytes[2] = aByte;
X  *pDblw = cnv.dbl;
X  }
X
X
X
/* swap some long ints.  (n is number of BYTES, not number of longs) */
swapdws (bp, n)
X  register char *bp;
X  register unsigned n;
{
X  register char c;
X  register char *ep = bp + n;
X  register char *sp;
X
X  while (bp < ep) {
X    sp = bp + 3;
X    c = *sp;
X    *sp = *bp;
X    *bp++ = c;
X    sp = bp + 1;
X    c = *sp;
X    *sp = *bp;
X    *bp++ = c;
X    bp += 2;
X  }
}
X
X
X
/* swap some short ints */
swapwords (bp, n)
X  register char *bp;
X  register unsigned n;
{
X  register char c;
X  register char *ep = bp + n;
X
X  while (bp < ep) {
X    c = *bp;
X    *bp = *(bp + 1);
X    bp++;
X    *bp++ = c;
X  }
}
X
X
X
X
X
writeSimple(image, outfile)
X  imageInfo *image;
X  FILE *outfile;
{
X  dw width, height, hasColormap, colormapSize;
X  dw swaptest = 1;
X  int i, w, h;
X
X  if (verbose)
X    fprintf("%s: writing in simple output format\n", programName);
X  if (image->ximage->depth != 8) {
X    fprintf("%s: can't write simple image format if depth is not 8\n",
X            programName);
X    return;
X  }
X  width        = image->ximage->width;
X  height       = image->ximage->height;
X  hasColormap  = 1;
X  colormapSize = image->numcells;
X  if (*(char *)&swaptest==0) {
X    swapdws(&width,        1);
X    swapdws(&height,       1);
X    swapdws(&hasColormap,  1);
X    swapdws(&colormapSize, 1);
X  }
X  fwrite(&width, 4, 1, outfile);
X  fwrite(&height, 4, 1, outfile);
X  fwrite(&hasColormap, 4, 1, outfile);
X  fwrite(&colormapSize, 4, 1, outfile);
X  for (i=0; i<image->numcells; i++)
X    fputc((byte)(image->red[i]>>8), outfile);
X  for (i=0; i<image->numcells; i++)
X    fputc((byte)(image->green[i]>>8), outfile);
X  for (i=0; i<image->numcells; i++)
X    fputc((byte)(image->blue[i]>>8), outfile);
X  for (i=0; i<image->numcells; i++)
X    fputc((byte)(image->used[i]), outfile);
X  for (h=0; h<image->ximage->height; h++)
X    for (w=0; w<image->ximage->width; w++)
X      fputc(XGetPixel(image->ximage, w, h), outfile);
}
X
X
X
X
X
X
X
/*
X * makePSImage returns an XImage structure that contains the samples
X * to be written.  If the input image is monochrome, its XImage structure
X * will be returned.  Otherwise a new structure is allocated and returned.
X */
X
XXImage* makePSImage(image, desiredDepth, depth, bpl, spb)
X    imageInfo* image;
X    int desiredDepth;  /* 0 = don't care */
X    int* depth;
X    int* bpl;
X    int* spb;
{
X    register byte* ptr;
X    int lshift, lmask;
X    long p;
X    int x, y, i;
X    XImage* ximage = image->ximage;
X    XImage* psimage;
X
X  /* use depth as the number of bits in output samples */
X  *depth = ximage->depth;
X  /* postscript only supports 1, 2, 4, or 8 */
X  if (*depth > 8) *depth = 8;     /* max postscript bits/sample */
X  if (*depth < 8 && *depth > 4) *depth = 8;
X  if (*depth == 3) *depth = 4;
X    
X    if (desiredDepth == 0) {
X	desiredDepth = *depth;
X    }
X
X
X  *bpl = ((ximage->width * desiredDepth) + 7) / 8;
X
X  if (*depth == 1)
X	/* Same image */
X    psimage = ximage;
X  else {
X    /* colors have to be changed to luminescence */
X    ptr = (byte *)malloc(ximage->height * *bpl);
X    psimage = XCreateImage(hDisplay, DefaultVisual(hDisplay, hScreen),
X                  desiredDepth, ZPixmap,
X                  0, ptr,
X                  ximage->width, ximage->height,
X                  8, *bpl);
X    if (!psimage) {
X      fprintf(stderr, "%s: could not create image for Postscript conversion\n",
X        programName);
X      exit(3);
X    }
X    /* force the bits_per_pixel to be what is needed */
X    psimage->bits_per_pixel = desiredDepth;
X  }
X
X  *spb = 8 / psimage->bits_per_pixel;    /* samples per byte */
X
X  if (*depth > 1) {
X    /* translate colors into grays */
X    lshift = 16 - psimage->bits_per_pixel;
X    lmask  = (1 << psimage->bits_per_pixel) - 1;
X    for (y = 0; y < ximage->height; y++) {
X      for (x = 0; x < ximage->width; x++) {
X        p = XGetPixel(ximage, x, y);
X        i = (0.30*(double)image->red[p]) +
X            (0.59*(double)image->green[p])+
X            (0.11*(double)image->blue[p]);
X        i = (i >> lshift) & lmask;
X        XPutPixel(psimage, x, y, i);
X      }
X    }
X  }
X  *depth = desiredDepth;  /* The final resolution */
X  return psimage;
}
X
X
X
X
X
X
X
writePreview(image, outfile, defaultImage, ditherKind)
X  imageInfo *image;
X  XImage *defaultImage;
X  FILE *outfile;
X  ditherType ditherKind;
{
X  register byte b, *ptr;
X  int depth, bpl, spb;
X  int reverse, x, y;
X  int widthcount, lines;
X  XImage* ximage;
X  XImage* psimage = (XImage *)NULL;
X    
X  if (image->ximage->depth > 1) {
X    /* required to use black and white for the preview image */
X    if (ditherKind == MAP_BW) {
X      if (verbose) fprintf(stderr, "%s: previewing with a bitmap\n", programName);
X      pixmap2bitmap(image);
X    }
X    else {
X      if (ditherKind == NO_DITHER)
X        ditherKind = FS_DITHER;
X      if (verbose) fprintf(stderr, "%s: previewing with a dither\n", programName);
X      pixmap2halftone(image, ditherKind);
X    }
X    psimage = makePSImage(image, 1, &depth, &bpl, &spb);
X  }
X  else
X    /* the image is already monochrome, so use the psimage that's already
X     * been processed */
X    psimage = defaultImage;
X    
X
X  /* compute the number of lines in the preview output so
X   * apps reading the file can easily skip it */
X  lines = (bpl * psimage->height) / 30;
X  if (lines % 30 > 0) lines++;
X
X  fprintf(outfile, "%%%%BeginPreview: %d %d %d %d\n%%",
X	    psimage->width, psimage->height, psimage->depth, lines);
X
X    
X  /* if the bits haven't been swizzled yet, we have to check for color
X   * reversal */
X  if (psimage == image->ximage)
X    reverse = BlackPixel(hDisplay,hScreen)==1;
X  else
X    reverse = FALSE;
X
X  widthcount = 0;
X  for (y=0; y<psimage->height; y++) {
X    /* note that depth 1 images are already padded to even byte boundaries
X     * under X, so there is no need to shift bits around to do padding of
X     * the preview image */
X    for (x=0, ptr=(byte *)(psimage->data+(y * psimage->bytes_per_line));
X         x<psimage->width;
X         x+=spb, ptr++) {
X      b = *ptr;
X      if (reverse) b = ~b;
X      if (depth == 1  &&  psimage->bitmap_bit_order == LSBFirst)
X        b = swapbits(b);
X      fprintf(outfile, "%02.2x", b);
X      widthcount += 2;
X      if (widthcount >= 60) {
X	fputs("\n%", outfile);
X        widthcount = 0;
X      }
X    }
X  }
X  fprintf(outfile, "\n%%%%EndPreview\n");
X    
X  if (psimage && psimage != defaultImage) {
X    free(psimage->data);
X    free(psimage);
X  }
}
X
X
X
/*
X * Write an image in Postscript format
X */
writePostscript(image, outfile, encode, encapsulate, preview,
X  previewDither, landscape, binary, checkLimits)
X  imageInfo *image;
X  FILE *outfile;
X  int encode;       /* TRUE if we're to encode the Postscript output */
X  int encapsulate;  /* TRUE if encapsulated Postscript output is wanted */
X  int preview;      /* TRUE if EPSI preview image is to be written with EPS output */
X  ditherType previewDither;  /* type of dither to use for preview image */
X  int landscape;    /* TRUE if landscape format is wanted */
X  int binary;       /* TRUE if binary output is wanted */
X  int checkLimits;  /* TRUE if PS interpreter memory checks should be made */
{
X  register byte b, *ptr;
X  register int x, y;
X  register int i;
X  XImage *ximage = image->ximage;
X  XImage *psimage;
X  double xdpi, ydpi, xscale, yscale, f;
X  int lshift, lmask;
X  int depth, bpl, spb;
X  int reverse;
X  long p;
X  /* rle variables */
X  int rlecount;
X  byte rlesample;
X  dw  rletotal;
X  int widthcount;
X  int firstSample;
X
X  if (verbose)
X    fprintf(stderr, "%s: formatting Postscript output\n", programName);
X
X  if (preview)
X    encapsulate = TRUE;
X
X  if (encapsulate)
X    landscape = FALSE;  /* landscape uses a transformation matrix */
X
X  psimage = makePSImage(image, 0, &depth, &bpl, &spb);
X
#ifndef NO_RLE_CHECKS
X  if (encode) {
X    rletotal = 0;
X    rlecount = 0;
X    firstSample = TRUE;
X    for (y=0; y<psimage->height; y++)
X      for (x=0, ptr=(byte *)(psimage->data + (y * psimage->bytes_per_line));
X           x<psimage->width; x+=spb, ptr++) {
X        b = *ptr;
X	if (firstSample || b != rlesample || rlecount==254) {
X	  if (!firstSample)
X	    rletotal += 2;
X	  else
X	    firstSample = FALSE;
X	  rlecount = 0;
X	  rlesample = b;
X	}
X	else
X	  rlecount++;
X      }
X    if (!firstSample)
X      rletotal += 2;
X    f = (float)(rletotal) / (float)(psimage->height*bpl);
X    if (verbose)
X      fprintf(stderr, "%s: encoding would change to %5.1f%% of orig size\n",
X            programName, f * 100.0);
X    encode = f <= 0.95;
X  }
#endif
X
X
X
X  if (verbose)
X    fprintf(stderr, "%s: image will %sbe encoded\n", programName,
X            encode? "" : "not ");
X
X  if (encapsulate) {
X    fprintf(outfile, "%%!PS-Adobe-2.0 EPSF-2.0\n");
X    fprintf(outfile, "%%%%BoundingBox: %d %d %d %d\n",
X                0, 0, psimage->width, psimage->height);
X  }
X  else
X    fprintf(outfile, "%%!\n");
X
X  fprintf(outfile, "%%%%Creator: xgrabsc\n");
X  fprintf(outfile, "%%%%Title: %s\n", imageName);
X  time(&p);
X  fprintf(outfile, "%%%%CreationDate: %s", ctime(&p));
X  fprintf(outfile, "%%%%EndComments\n");
X  fprintf(outfile, "%%\n");
X  fprintf(outfile, "%%\n");
X
X  /* if the user wants a preview image, EPS 2.0 says it must go here */
X  if (preview)
X    writePreview(image, outfile, psimage, previewDither);
X
X
X  if (encapsulate) {
X    fprintf(outfile, "%%%%EndProlog\n");
X    fprintf(outfile, "%%%%Page: 1 1\n");
X  }
X
X  /* standard inch procedure */
X  fputs("/inch {72 mul} def\n", outfile);
X
X
X  /* define a string to hold image bytes */
X  if (encode) {
X    fputs("/rlebuffer 2 string def\n", outfile);
X    fprintf(outfile, "/samples %d string def\n", 256);  /* max bytes per burst */
X  }
X  else
X    fprintf(outfile, "/picstr %d string def\n", bpl);
X
X  if (binary) {
X    fputs("/endstr 1 string def\n", outfile);
X    if (encode) fputs("/ccount 0 def\n", outfile);
X  }
X
X  /* define the image plotting procedure */
X  fputs("/plotimage\n", outfile);
X
X  fprintf(outfile, "{%d %d %d ",
X        psimage->width, psimage->height, psimage->bits_per_pixel);
X
X
X
X  /* transformation matrix */
X  if (landscape)
X    fprintf(outfile, "[0 %d %d 0 0 0]\n", psimage->width, psimage->height);
X  else
X    fprintf(outfile, "[%d 0 0 -%d 0 %d]\n",
X        psimage->width, psimage->height, psimage->height);
X
X  /* line reading function  */
X
X  if (encode) {
X  fputs("% run-length decoding block\n",                                       outfile);
X    if (binary) {
X      fputs("  { currentfile rlebuffer readstring pop pop\n", outfile);
X      fputs("    /ccount ccount 2 add def                 %% count binary chars\n",outfile);
X      fputs("    ccount 60 ge                             %% test for >60 chars\n",outfile);
X      fputs("    { /ccount 0 def                          %% reset character counter\n",outfile);
X      fputs("      currentfile endstr readline pop pop    %% skip newline\n",outfile);
X      fputs("    } if                                     %% skip newlines after 60 chars\n",outfile);
X    }
X    else
X      fputs("  { currentfile rlebuffer readhexstring pop pop\n",                 outfile);
X    fputs("    rlebuffer 0 get 1 add       %% number of copies of the sample\n", outfile);
X    fputs("    /nsamples exch store        %% save it away\n",                   outfile);
X    fputs("    /lum rlebuffer 1 get store  %% the sample itself\n",              outfile);
X    fputs("    0 1 nsamples 1 sub { samples exch lum put } for\n",               outfile);
X    fputs("    samples 0 nsamples getinterval %% leave the pixels on the stack\n",outfile);
X    fputs("  }\n", outfile);
X  }
X  else {
X    if (binary) {
X      /* Do a "readline" after each "readstring" so we can seperate each
X         scanline of binary data with a "newline" */
X      fputs("   {currentfile picstr readstring pop\n", outfile);
X      fputs("    currentfile endstr readline pop pop}\n", outfile);
X    }
X    else
X      fputs("  {currentfile picstr readhexstring pop}\n", outfile);
X  }
X
X  fputs("  image\n} def\n", outfile);
X
X
X  /* emit some code to check for resource availability */
X  if (!encapsulate  &&  checkLimits) {
X    for (x=0; CheckVM[x] != NULL; x++) {
X      fputs(CheckVM[x], outfile);
X      fputc('\n', outfile);
X    }
X    fprintf(outfile, "\n\n");
X    fprintf(outfile, "%d checkvm\n", psimage->height * bpl);
X  }
X
X  /* save context and move to a nice origin */
X  fputs("gsave\n", outfile);
X
X  if (encapsulate) {
X    /* for encapsulated postscript, we need a scale factor that is equal
X     * to the image width/height in samples */
X    fprintf(outfile, "%d %d scale\n", psimage->width, psimage->height);
X  }
X  else {
X    /* For physical output we need a scale factor that will create
X      * the same size image, and we need to center it on the page.
X      *   -Figure out the physical dimensions on the screen
X      *    and make it come out the same on the printer. */
X    xdpi = (((double)DisplayWidth(hDisplay,hScreen)) * 25.4) /
X            ((double)DisplayWidthMM(hDisplay,hScreen));
X    ydpi = (((double)DisplayHeight(hDisplay,hScreen)) * 25.4) /
X            ((double)DisplayHeightMM(hDisplay,hScreen));
X    xscale = ((double)psimage->width) / xdpi;
X    yscale = ((double)psimage->height) / ydpi;
X    if (landscape) {
X      f = xscale; xscale = yscale; yscale = f;
X    }
X    if (xscale > horizInset) {
X      yscale *= horizInset / xscale;
X      xscale = horizInset;
X    }
X    else if (yscale > vertInset) {
X      xscale *= vertInset / yscale;
X      yscale = vertInset;
X    }
X    fprintf(outfile, "%1.2g inch %1.2g inch translate\n",
X                  (pageWidth - xscale) / 2.0, (pageHeight - yscale) / 2.0);
X    if (landscape)
X      fprintf(outfile, "%1.2g inch %1.2g inch scale\n", yscale, xscale);
X    else
X      fprintf(outfile, "%1.2g inch %1.2g inch scale\n", xscale, yscale);
X  }
X
X
X
X  if (binary)
X    fprintf(outfile,"%%%%BeginBinary: %d\n",
X	    encode ? rletotal+11+rletotal/60
X	    : ximage->height*(ximage->width+1)+10);
X
X  fputs("plotimage\n", outfile);
X
X
X  reverse = depth == 1? BlackPixel(hDisplay,hScreen)==1 : FALSE;
X  if (encode) {
X    rletotal = 0;
X    rlecount = 0;
X    firstSample = TRUE;
X  }
X  widthcount = 0;
X  for (y=0; y<psimage->height; y++) {
X    for (x=0, ptr=(byte *)(psimage->data+(y * psimage->bytes_per_line));
X         x<psimage->width;
X         x+=spb, ptr++) {
X      b = *ptr;
X      if (reverse) b = ~b;
X      if (depth == 1  &&  psimage->bitmap_bit_order == LSBFirst)
X        b = swapbits(b);
X      if (encode) {
X        if (firstSample || b != rlesample || rlecount==254) {
X	  if (!firstSample) {
X	    if (binary) {
X	      putc((byte)rlecount,outfile);
X	      putc((byte)rlesample,outfile);
X	      widthcount += 2;
X	    }
X	    else {
X	      fprintf(outfile, "%02.2x%02.2x", rlecount, rlesample);
X	      widthcount += 4;
X	    }
X	    rletotal += 2;
X	    if (widthcount >= 60) {
X	      fputc('\n', outfile);
X	      widthcount = 0;
X	    }
X	  }
X	  else
X	    firstSample = FALSE;
X	  rlecount = 0;
X	  rlesample = b;
X	}
X	else
X	  rlecount++;
X      }
X      else {
X	if (binary)
X	  putc((byte)b,outfile);
X	else {
X          fprintf(outfile, "%02.2x", b);
X	  widthcount += 2;
X	  if (widthcount >= 60) {
X	    fputc('\n', outfile);
X            widthcount = 0;
X          }
X        }
X      }
X    }
X    if (binary && !encode) putc('\n',outfile);
X  }
X
X  if (encode) {
X    if (!firstSample) {
X      if (binary) {
X	putc((byte)rlecount,outfile);
X	putc((byte)rlesample,outfile);
X      }
X      else
X        fprintf(outfile, "%02.2x%02.2x\n", rlecount, rlesample);
X      rletotal += 2;
X    }
X    putc('\n',outfile);
X    if (binary) fputs("%%EndBinary\n",outfile);
X    fputs("%\n", outfile);
X    fprintf(outfile, "%% Run-length encoding savings = %5.1f%%\n",
X          100.0 - ((float)(rletotal) * 100.0 / (float)(psimage->height * bpl)));
X    fputs("%\n", outfile);
X  }
X  else if (binary) fputs("%%EndBinary\n",outfile);
X
X  fputs("\n\n\ngrestore\nshowpage\n", outfile);
X
X
X  if (psimage != ximage) {
X    free(psimage->data);
X    free(psimage);
X  }
}
X
X
X
X
X
/*
X * Write an image in Color Postscript format
X */
writeColorPS(image, outfile, encode, encapsulate, preview,
X  previewDither, landscape, binary, checkLimits)
X  imageInfo *image;
X  FILE *outfile;
X  int encode;       /* TRUE if we're to encode the Postscript output    */
X  int encapsulate;  /* TRUE if encapsulated Postscript output is wanted */
X  int preview;      /* TRUE if EPSI preview image is to be written with EPS output */
X  ditherType previewDither; /* type of dither to use for preview image */
X  int landscape;    /* TRUE if landscape output is wanted               */
X  int binary;       /* TRUE if binary Postscript output is wanted */
X  int checkLimits;  /* TRUE if PS interpreter memory checks should be made */
{
X  register byte *ptr, b;
X  register int x, y;
X  XImage *ximage = image->ximage;
X  double xdpi, ydpi, xscale, yscale, f;
X  double left, top;
X  int depth, bpl, spb;
X  long p;
X  /* rle variables */
X  int rlecount;
X  dw  rletotal;
X  byte rlesample;
X  int firstSample;
X  int widthcount;
X
X
X  if (verbose)
X    fprintf(stderr, "%s: formatting Color Postscript output\n", programName);
X
X  if (encapsulate)
X    landscape = FALSE;  /* landscape uses a transformation matrix */
X
X  depth = 8;                                  /* bits per sample  */
X  spb   = 1;                                  /* samples per byte */
X  bpl = ((ximage->width * depth) + 7) / 8;    /* bytes per line   */
X
X
#ifndef NO_RLE_CHECKS
X  if (encode) {
X    rletotal = 0;
X    rlecount = 0;
X    firstSample = TRUE;
X    for (y=0; y<ximage->height; y++)
X      for (x=0, ptr=(byte *)(ximage->data + (y * ximage->bytes_per_line));
X           x<ximage->width; x+=spb, ptr++) {
X        b = *ptr;
X	if (firstSample || b != rlesample || rlecount==254) {
X	  if (!firstSample)
X	    rletotal += 2;
X	  else
X	    firstSample = FALSE;
X	  rlecount = 0;
X	  rlesample = b;
X	}
X	else
X	  rlecount++;
X      }
X    rletotal += 2;
X    f = (float)(rletotal) / (float)(ximage->height*bpl);
X    if (verbose)
X      fprintf(stderr, "%s: encoding would change to %5.1f%% of orig size\n",
X            programName, f * 100.0);
X    encode = f <= 0.95;
X  }
#endif
X
X  if (encapsulate) {
X    fprintf(outfile, "%%!PS-Adobe-2.0 EPSF-2.0\n");
X  }
X  else
X    fprintf(outfile, "%%!\n");
X
X  fprintf(outfile, "%%%%Creator: xgrabsc\n");
X  fprintf(outfile, "%%%%Title: %s\n", imageName);
X  if (encapsulate) {
X    fprintf(outfile, "%%%%Pages: 1\n");
X    fprintf(outfile, "%%%%BoundingBox: %d %d %d %d\n",
X                0, 0, ximage->width, ximage->height);
X  }
X  time(&p);
X  fprintf(outfile, "%%%%CreationDate: %s", ctime(&p));
X  fprintf(outfile, "%%%%EndComments\n");
X
X  /* if the user wants a preview image, EPS 2.0 says it must go here */
X  if (preview)
X    writePreview(image, outfile, image->ximage, previewDither);
X
X  if (encapsulate) {
X    fprintf(outfile, "%%%%EndProlog\n");
X    fprintf(outfile, "%%%%Page: 1 1\n");
X  }
X  fprintf(outfile, "\n\ngsave\n\n");
X
X
X  if (needColorImageProc) {
X    /* put a colorImage procedure into the output file so a monochrome
X    * printer can handle the file as well
X    */
X    for (x=0; ColorImage[x] != NULL; x++) {
X      fputs(ColorImage[x], outfile);
X      fputc('\n', outfile);
X    }
X    fprintf(outfile, "\n\n\n");
X  }
X
X  fputs("/inch {72 mul} def\n", outfile);
X
X  /* emit some code to check for resource availability */
X  if (!encapsulate  &&  checkLimits) {
X    for (x=0; CheckVM[x] != NULL; x++) {
X      fputs(CheckVM[x], outfile);
X      fputc('\n', outfile);
X    }
X    fprintf(outfile, "\n\n");
X    fprintf(outfile, "%d checkvm\n\n", ximage->height * bpl);
X  }
X
X  if (encapsulate) {
X    /* don't translate the image for encapsulated postscript.  The
X     * scale should match the data dimensions of the image in samples.  */
X    fprintf(outfile, "%d %d scale\n", ximage->width, ximage->height);
X  }
X  else {
X    /* For physical output we need a scale factor that will create
X     * the same size image, and we need to center it on the page.
X     *   -Figure out the physical dimensions on the screen
X     *    and make it come out the same on the printer.
X     */
X    xdpi = (((double)DisplayWidth(hDisplay,hScreen)) * 25.4) /
X            ((double)DisplayWidthMM(hDisplay,hScreen));
X    ydpi = (((double)DisplayHeight(hDisplay,hScreen)) * 25.4) /
X            ((double)DisplayHeightMM(hDisplay,hScreen));
X    xscale = ((double)ximage->width) / xdpi;
X    yscale = ((double)ximage->height) / ydpi;
X    if (landscape) {
X      f = xscale; xscale = yscale; yscale = f;
X    }
X    if (xscale > horizInset) {
X      yscale *= horizInset / xscale;
X      xscale = horizInset;
X    }
X    else if (yscale > vertInset) {
X      xscale *= vertInset / yscale;
X      yscale = vertInset;
X    }
X     
X
X    left = ((pageWidth - xscale) / 2.0);
X    top  = ((pageHeight - yscale) / 2.0);
X    fprintf(outfile, "%1.2g inch %1.2g inch translate\n", left, top);
X    if (landscape)
X      fprintf(outfile, "%1.2g inch %1.2g inch scale\n", yscale, xscale);
X    else
X      fprintf(outfile, "%1.2g inch %1.2g inch scale\n", xscale, yscale);
X    fprintf(outfile, "\n\n\n");
X  }
X
X  if (binary) {
X    fputs("/endstr 1 string def\n", outfile);
X    fputs("/ccount 0 def\n", outfile);
X  }
X
X  if (encode) {
X    /* define a drawcolormappedimage procedure geared to this image
X    */
X    fprintf(outfile, "/rgbstr %d string def\n", 256 * 3); /* max pixels per burst */
X    fprintf(outfile, "/buffer %d string def\n", 2);
X    fputs("/rgb (000) def\n", outfile);
X    fprintf(outfile, "/rgbmap %d string def\n", image->numcells * 3);
X    fputs("\n\n", outfile);
X
X    fputs("/drawcolormappedimage {\n", outfile);
X    fprintf(outfile, "  %d %d %d\n", ximage->width, ximage->height,depth);
X    if (landscape)
X      fprintf(outfile, "  [0 %d %d 0 0 0]\n", ximage->width, ximage->height);
X    else
X      fprintf(outfile, "  [%d 0 0 -%d 0 %d]\n", ximage->width, ximage->height,
X                                                ximage->height);
X    fputs("  %% define a block of code to read and decode the rle input stream\n", outfile);
X
X    if (binary) {
X      fputs("  { currentfile buffer readstring pop pop    %% run length and index\n", outfile);
X      fputs("    /ccount ccount 2 add def                 %% count binary chars\n",outfile);
X      fputs("    ccount 60 ge                             %% test for >60 chars\n",outfile);
X      fputs("    { /ccount 0 def                          %% reset character counter\n",outfile);
X      fputs("      currentfile endstr readline pop pop    %% skip newline\n",outfile);
X      fputs("    } if                                     %% skip newlines after 60 chars\n",outfile);
X    }
X    else
X      fputs("  { currentfile buffer readhexstring pop pop %% run length and index\n", outfile);
X
X    fputs("    /npixels buffer 0 get 1 add 3 mul store  %% number of bytes\n", outfile);
X    fputs("    /color buffer 1 get 3 mul store          %% fix index into rgb map\n", outfile);
X    fputs("    /rgb rgbmap color 3 getinterval store    %% and get the colors\n", outfile);
X    fputs("    0 3 npixels 1 sub {                      %% loop to store the rgb bytes\n", outfile);
X    fputs("      rgbstr exch rgb putinterval\n", outfile);
X    fputs("    } for\n", outfile);
X    fputs("    rgbstr 0 npixels getinterval\n", outfile);
X    fputs("  }\n", outfile);
X    fputs("  false 3 colorimage\n", outfile);
X    fputs("} bind def\n", outfile);
X    fprintf(outfile, "\n\n\n");
X
X
X  }
X
X
X  else {
X    /* define a drawcolorimage procedure geared to this image
X    */
X    fprintf(outfile, "/buffer %d string def\n", 1);
X    fprintf(outfile, "/rgbmap %d string def\n", image->numcells * 3);
X    fputs("\n\n", outfile);
X
X    fputs("/onepixel 3 string store\n", outfile);
X    fputs("/drawcolormappedimage {\n", outfile);
X    fprintf(outfile, "  %d %d %d\n", ximage->width, ximage->height,depth);
X    if (landscape)
X      fprintf(outfile, "  [0 %d %d 0 0 0]\n", ximage->width, ximage->height);
X    else
X      fprintf(outfile, "  [%d 0 0 -%d 0 %d]\n", ximage->width, ximage->height,
X                                                ximage->height);
X    fputs("  %% define a block of code to read and decode the rle input stream\n", outfile);
X    if (binary) {
X      fputs("  { currentfile buffer readstring pop pop    %% run length and index\n", outfile);
X      fprintf(outfile,"    /ccount ccount %d add def                 %% count binary chars\n",encode ? 2 : 1);
X      fputs("    ccount 60 ge                             %% test for >60 chars\n",outfile);
X      fputs("    { /ccount 0 def                          %% reset character counter\n",outfile);
X      fputs("      currentfile endstr readline pop pop    %% skip newline\n",outfile);
X      fputs("    } if                                     %% skip newlines after 60 chars\n",outfile);
X    }
X    else
X      fputs("  { currentfile buffer readhexstring pop pop  %% index\n", outfile);
X    fputs("    rgbmap buffer 0 get 3 mul 3 getinterval   %% color bytes\n", outfile);
X    fputs("  }\n", outfile);
X    fputs("  false 3 colorimage\n", outfile);
X    fputs("} bind def\n", outfile);
X    fprintf(outfile, "\n\n\n");
X
X  }
X
X
X  /* write the rgb map */
X  fputs("%% get the rgb map\n", outfile);
X  fputs("currentfile rgbmap readhexstring pop pop\n", outfile);
X  for (x=0; x<image->numcells; x++)
X    fprintf(outfile, "%02.2x%02.2x%02.2x\n",
X                      (byte)((image->red[x]   >> 8) & 0xff),
X		      (byte)((image->green[x] >> 8) & 0xff),
X		      (byte)((image->blue[x]  >> 8) & 0xff) );
X  fputs("\n\n", outfile);
X
X
X  if (binary)
X    fprintf(outfile,"%%%%BeginBinary: %d\n",
X	    encode ? rletotal+22+rletotal/60
X	    : ximage->height*ximage->width+22+
X	      (ximage->height*ximage->width)/60);
X
X  fputs("drawcolormappedimage\n", outfile);
X
X  /* write the map indexes */
X  rletotal = 0;
X  rlecount = 0;
X  firstSample = TRUE;
X  widthcount = 0;
X  for (y=0; y<ximage->height; y++) {
X    for (x=0, ptr=(byte *)(ximage->data+(y * ximage->bytes_per_line));
X        x<ximage->width;
X        x+=spb, ptr++) {
X      b = *ptr;
X      if (encode) {
X        if (firstSample || b != rlesample || rlecount==254) {
X	  if (!firstSample) {
X	    if (binary) {
X	      putc((byte)rlecount,outfile);
X	      putc((byte)rlesample,outfile);
X	      widthcount += 2;
X	    }
X	    else {
X	      fprintf(outfile, "%02.2x%02.2x", rlecount, rlesample);
X	      widthcount += 4;
X	    }
X	    rletotal += 2;
X	    if (widthcount >= 60) {
X	      fputc('\n', outfile);
X	      widthcount = 0;
X	    }
X	  }
X	  else
X	    firstSample = FALSE;
X	  rlecount = 0;
X	  rlesample = b;
X        }
X        else
X	  rlecount++;
X      }
X      else {
X	if (binary) {
X	  putc((byte)b,outfile);
X	  ++widthcount;
X	}
X	else {
X	  fprintf(outfile, "%02.2x", b & 0xFF);
X	  widthcount += 2;
X	}
X	if (widthcount >= 60) {
X	  fputc('\n', outfile);
X	  widthcount = 0;
X	}
X      }
X    }
X  }
X
X  if (encode) {
X    if (!firstSample) {
X      if (binary) {
X	putc((byte)rlecount,outfile);
X	putc((byte)rlesample,outfile);
X      }
X      else
X        fprintf(outfile, "%02.2x%02.2x\n", rlecount, rlesample);
X      rletotal += 2;
X    }
X  }
X  if (binary)
X    fprintf(outfile,"\n%%%%EndBinary\n");
X
X  /* print some statistics */
X  if (encode) {
X    fputs("%\n", outfile);
X    fprintf(outfile, "%% Run-length encoding savings = %5.1f%%\n",
X          100.0 - ((float)(rletotal) * 100.0 / (float)(ximage->height * bpl)));
X  }
X
X  fputs("%\n", outfile);
X  fputs("\ngrestore\nshowpage\n%%Trailer\n", outfile);
}
X
X
X
X
X
X
X
X
X
X
X
/*
X * Write an image in 'puzzle' format, suitable for loading with
X * "puzzle -picture".
X */
writePuzzle(image, outfile)
X  imageInfo *image;
X  FILE *outfile;
{
X  XImage *ximage = image->ximage;
X  int nc, width, height, w, h, cidx;
X  dw swaptest = 1;
X
X  if (verbose)
X    fprintf(stderr, "%s: formatting Puzzle output\n", programName);
X
X  if (ximage->depth > 8) {
X    fprintf(stderr, "%s: Puzzle converter can't handle depth > 8 yet\n",
X            programName);
X    return;
X  }
X
X  nc     = image->numcells;
X  width  = ximage->width;
X  height = ximage->height;
X  if (*(char *)&swaptest) {
X    swapbytes(&width);
X    swapbytes(&height);
X  }
X  fwrite(&width, 4, 1, outfile);
X  fwrite(&height, 4, 1, outfile);
X  fputc(nc, outfile);
X  for (cidx=0; cidx<nc; cidx++) {
X    fputc(image->red[cidx]>>8,   outfile);
X    fputc(image->green[cidx]>>8, outfile);
X    fputc(image->blue[cidx]>>8,  outfile);
X  }
X  for (h=0; h<ximage->height; h++)
X    if (ximage->bits_per_pixel == 8)
X      fwrite(ximage->data+(h*ximage->bytes_per_line),ximage->width,1,outfile);
X    else
X      /* this won't work if depth > 8 */
X      for (w=0; w<ximage->width; w++)
X        fputc(XGetPixel(ximage, w, h), outfile);
}
X
X
X
X
X
X
X
writeXWD(image, outfile)
X  imageInfo *image;
X  FILE *outfile;
{
X  XImage   *ximage = image->ximage;
X  XWDFileHeader header;
X  Visual   *visual = DefaultVisual(hDisplay, hScreen);
X  XColor    color;
X  dw        visMask = (visual->red_mask
X                      | visual->green_mask
X                      | visual->blue_mask);
X  dw        swaptest = 1;
X  int       i;
X
X  if (verbose)
X    fprintf(stderr, "%s: formatting xwd output\n", programName);
X
X  header.header_size    = (CARD32)(sizeof(header)+strlen(imageName)+1);
X  header.file_version   = (CARD32) XWD_FILE_VERSION;
X  header.pixmap_format  = (CARD32)(ximage->depth>1? ZPixmap : XYPixmap);
X  header.pixmap_depth   = (CARD32) ximage->depth;
X  header.pixmap_width   = (CARD32) ximage->width;
X  header.pixmap_height  = (CARD32) ximage->height;
X  header.xoffset        = (CARD32) ximage->xoffset;
X  header.byte_order     = (CARD32) ximage->byte_order;
X  header.bitmap_unit    = (CARD32) ximage->bitmap_unit;
X  header.bitmap_bit_order = (CARD32) ximage->bitmap_bit_order;
X  header.bitmap_pad     = (CARD32) ximage->bitmap_pad;
X  header.bits_per_pixel = (CARD32) ximage->bits_per_pixel;
X  header.bytes_per_line = (CARD32) ximage->bytes_per_line;
X  header.visual_class   = (CARD32)visual->class;
X  header.red_mask       = (CARD32)visual->red_mask;
X  header.green_mask     = (CARD32)visual->green_mask;
X  header.blue_mask      = (CARD32)visual->blue_mask;
X  header.bits_per_rgb   = (CARD32)visual->bits_per_rgb;
X  header.colormap_entries = (CARD32)visual->map_entries;
X  header.ncolors        = image->numcells;
X  header.window_width   = (CARD32)ximage->width;
X  header.window_height  = (CARD32)ximage->height;
X  header.window_x       = 0;
X  header.window_y       = 0;
X  header.window_bdrwidth = 0;
X
X  if (*(char *) &swaptest)
X    swapdws(&header, sizeof(header));
X
X  fwrite(&header, sizeof(header), 1, outfile);
X  fwrite(imageName, 1, strlen(imageName)+1, outfile);
X
X  for (i=0; i<image->numcells; i++) {
X    color.pixel = i;
X    color.red   = image->red[i];
X    color.green = image->green[i];
X    color.blue  = image->blue[i];
X    color.flags = visMask;
X    color.pad   = 0;
X    if (*(char *) &swaptest) {
X      swapdws(&color.pixel, sizeof(color.pixel));
X      swapwords(&color.red, 3 * sizeof(color.red)); /* assume g and b follow r */
X    }
X    fwrite(&color, sizeof(XColor), 1, outfile);
X  }
X
X  fwrite(ximage->data, ximage->height * ximage->bytes_per_line, 1, outfile);
}
X
X
X
X
X
/*
X * Write a monochrome image out in Bitmap format.  XWriteBitmapToFile
X * requires a Pixmap as input & we'd have to invent one before we could
X * use it.
X */
X
writeXYPixmap(image, outfile)
X  imageInfo *image;
X  FILE *outfile;
{
X  XImage *ximage = image->ximage;
X  int w, h;
X  byte b, *line;
X  int lcount;
X  int reverse = BlackPixel(hDisplay, hScreen) == 0;
X  int swap    = ximage->bitmap_bit_order != LSBFirst;
X
X  if (verbose)
X    fprintf(stderr, "%s: formatting Bitmap output\n", programName);
X
X  if (ximage->depth != 1) {
X    fprintf(stderr, "%s: can't write polychrome images in XY bitmap format\n",
X      programName);
X    return;
X  }
X
X  fprintf(outfile, "#define %s_width %d\n",  imageName, ximage->width);
X  fprintf(outfile, "#define %s_height %d\n", imageName, ximage->height);
X  fprintf(outfile, "#define %s_x_hot 0\n",   imageName);
X  fprintf(outfile, "#define %s_y_hot 0\n",   imageName);
X  fprintf(outfile, "static char %s_bits[] = {\n", imageName);
X  lcount = 0;
X  fputs("  ", outfile);
X  for (h=0; h<ximage->height; h++) {
X    line = (byte *)(ximage->data + (h * ximage->bytes_per_line));
X    for (w=0; w<ximage->width; w+=8) {
X      b = line[w/8];
X      if (reverse) b = ~b;
X      if (swap)    b = swapbits(b);
X      fprintf(outfile, " 0x%02x", b);
X      if (h<ximage->height || w+8<ximage->width)
X        fputc(',', outfile);
X      lcount++;
X      if (lcount >= 12) {
X        fputs("\n  ", outfile);
X        lcount = 0;
X      }
X    }
X  }
X  fputs("  };\n", outfile);
}
X
X
X
X
X
X
X
X
/*
X * Write a color image out in Pixmap format.
X * Supported output formats are xpm1 (original xpm), xpm2  and xpm3
X */
writeZPixmap(xpmFormat, image, outfile)
X  imageInfo *image;
X  FILE *outfile;
{
X  XImage *ximage = image->ximage;
X  int nc, width, height, w, h, cidx, cpp;
X  char mne[MAX_CELLS][3];
X
X  if (verbose) {
X    switch (xpmFormat) {
X    case 3:
X      fprintf(stderr, "%s: formatting XPM3 Pixmap output\n", programName);
X      break;
X    case 2:
X      fprintf(stderr, "%s: formatting XPM2 Pixmap output\n", programName);
X      break;
X    default:
X    case 1:
X      fprintf(stderr, "%s: formatting XPM output\n", programName);
X      break;
X    }
X  }
X
X  nc  = image->numcells;
X  cpp = image->numcells <= 26? 1 : 2;
X  switch (xpmFormat) {
X  case 3:
X    fprintf(outfile, "/* XPM */\nstatic char * image_name [] = {\n\"%d %d %d %d\",.\n",
X      ximage->width, ximage->height, image->numcells, cpp);
X    fputs("/* pixels*/\n", outfile);
X    break;
X  case 2:
X    fprintf(outfile, "! XPM2  \n%d %d %d %d\n", ximage->width,
X      ximage->height, image->numcells, cpp);
X    fputs("! pixels\n", outfile);
X    break;
X  case 1:
X  default:
X    fprintf(outfile, "#define %s_format 1\n",   imageName);
X    fprintf(outfile, "#define %s_width %d\n",   imageName, ximage->width);
X    fprintf(outfile, "#define %s_height %d\n",  imageName, ximage->height);
X    fprintf(outfile, "#define %s_ncolors %d\n", imageName, image->numcells);
X    fprintf(outfile, "#define %s_chars_per_pixel %d\n",     imageName, cpp);
X    fprintf(outfile, "static char * %s_colors[] = {\n", imageName);
X    break;
X  }
X
X  for (cidx=0; cidx<image->numcells; cidx++) {
X    if (cpp > 1) {
X      mne[cidx][0] = (char)(cidx / 10) + 'a';
X      mne[cidx][1] = (char)(cidx % 10) + '0';
X      mne[cidx][2] = '\0';
X    }
X    else {
X      mne[cidx][0] = (char)cidx + (cidx? 'A' : ' ');
X      mne[cidx][1] = '\0';
X    }
X    switch (xpmFormat) {
X    case 3:
X      fprintf(outfile, "\"%s\tc #%4.4x%4.4x%4.4x\",\n",mne[cidx],
X                image->red[cidx], image->green[cidx], image->blue[cidx]);
X      break;
X    case 2:
X      fprintf(outfile, "%s c #%4.4x%4.4x%4.4x\n", mne[cidx],
X                image->red[cidx], image->green[cidx], image->blue[cidx]);
X      break;
X    default:
X    case 1:
X      fprintf(outfile, "\"%s\", \"#%4.4x%4.4x%4.4x\"\n", mne[cidx],
X                image->red[cidx], image->green[cidx], image->blue[cidx]);
X      break;
X    }
X  }
X  if (xpmFormat == 1) {
X    fputs("} ;\n", outfile);
X    fprintf(outfile, "static char * %s_pixels[] = {\n", imageName);
X  }
X  for (h=0; h<ximage->height; h++) {
X    if (xpmFormat != 2)
X      fputs("\"", outfile);
X    for (w=0; w<ximage->width; w++)
X      fputs(mne[XGetPixel(ximage, w, h)], outfile);
X    if (xpmFormat == 2)
X      fputs("\n", outfile);
X    else
X      fputs("\",\n", outfile);
X  }
X  if (xpmFormat == 3)
X    fputs("};\n", outfile);
X  else if (xpmFormat != 2)
X    fputs("} ;\n", outfile);
}
X
X
X
X
SHAR_EOF
chmod 0644 write.hc ||
echo 'restore of write.hc failed'
Wc_c="`wc -c < 'write.hc'`"
test 36231 -eq "$Wc_c" ||
	echo 'write.hc: original size 36231, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xgrabsc.man ==============
if test -f 'xgrabsc.man' -a X"$1" != X"-c"; then
	echo 'x - skipping xgrabsc.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xgrabsc.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xgrabsc.man' &&
.\"========================================================================
.\"
.\" Name - xgrabsc.man
.\"
.\" ccs version: 1.11
.\"
.\" ccsid:	@(#)xgrabsc.man	1.11 - 7/9/92 12:49:29
.\" from: 	ccs/s.xgrabsc.man
.\" date: 	7/9/92 13:35:31
.\"
.\" Copyright (C) 1990-92 Bruce Schuchardt
.\" See the end of this document for full copyright information.
.\"
.\" Description:  Man page for xgrabsc
.\"
.\"========================================================================
.\"
.TH XGRABSC 1X
.\"
.SH NAME
xgrabsc \- grab rectangular screen images and store in files
.\"
.SH SYNOPSIS
.in +8n
.ti -8n
\fIxgrabsc\fR
[\fB\-d\fP\ \fIdisplay\fP]
[\fB\-id\fP\ \fIwindowId\fP]
[\fB\-o\fP\ \fIoutputFile\fP]
[\fB\-s\fP\ \fIseconds\fP]
[\fB\-post\fP\ \fIseconds\fP]
[\fB\-b\fP\ \fIpercent\fP]
[\fB\-and\fP\ \fIandBits\fP]
[\fB\-or\fP\ \fIorBits\fP]
[\fB\-page\fP\ \fIwidthxheight-hmarg-vmarg\fP]
[\fB\-bell -grab -verbose -bdrs -nobdrs -key -stretch -root -click
.br
-reverse -bw -mdither -dither -halftone -nodither
.br
-ps -cps -simple -xwd -bm -bm2 -bm3 -puzzle
.br
-bin -comp -eps -l -limit -preview -prev -colproc\fP]
.in -8n
.\"
.\"
.\"
.SH DESCRIPTION
\fIxgrabsc\fR lets you grab arbitrary rectangular images from an
XX server and writes them to standard output in a variety of formats.
.PP
Command line options also allow reduction of colormaps, halftoning
and dithering of color images, and direct mapping of color images
to monochrome.  Options must be seperated with spaces or tabs, and many
can be preceded by two dashes instead of one to them turn off.
.PP
The default output format is gray-scale non-encapsulated Postscript, with
image compression (if image compression significantly reduces the amount of
output).
.\"
.\"
.\"
.\"
.SH GENERAL OPTIONS
.TP 8
-d \fIdisplayName\fP or -display \fIdisplayName\fP
.br
Use an alternate display.  If no display is specified on the command line,
xgrabsc looks for the environment variable DISPLAY for the name of the
display and screen to grab from.  Note that you must have permission to
access the display on another computer.
.TP
-bell
The display's bell is normally rung while the screen is being accessed.
This turns the bell on or off (\fI--bell\fP will turn it \fIoff\fP).
.TP
-grab
Enable server grabs.  Normally xgrabsc will "grab" the server so
that the screen is frozen while a rectangle is selected and the image
is extracted.  If the screen is not frozen, rubber-banding may cause
video droppings on portions of the screen that are changing.  Use \fI--grab\fP
to turn off server grabs.
.TP
-o \fIoutput-file\fP or -output \fIoutput-file\fP
.br
Write output to \fIoutput-file\fP instead of standard output.  The
output-file name, minus directory and extension, is used as the internal
name for the image in formats supporting image names.  Postscript,
xwd, pixmap and bitmap formats all support image names.
.TP
-s \fIseconds\fP or -sleep \fIseconds\fP
.br
Sleep for \fIseconds\fP seconds before commencing operation.  This
should be used if you need some time to get the target image ready.
.TP
-post \fIseconds\fP
Sleep for \fIseconds\fP seconds after window/rectangle selection.  This is
commonly used to pop up menus after a window has been selected but before
xgrabsc takes its snapshot.
.TP
-verbose
Display processing information on standard error output (stderr).
.sp 3
.\"
.\"
.\"
.\"
.\"
.SH SELECTION OPTIONS
.TP
-id \fIwindow ID\fP
Dump the window with the given ID.
.TP
-key
Select the window under the mouse when the Control key is pressed.  This
option is normally used in getting images of menus.  Pop up the menu,
optionally move the pointer to the window containing the menu, and strike
the Control key to begin the dump.
.TP
-root
Dump the entire screen (root window).
.TP
-stretch
Use rubber-band rectangle to select region to grab.  This is the
default.
.TP
-click
Wait for a click on a window and dump the selected window.
.\"
.\"
.\"
.\"
.\"
.sp 3
.SH IMAGE PROCESSING OPTIONS
.TP
-nobdrs or -noborders
.br
Remove window-manager borders from window images.  This option
applies only to selection by ID (\fI\-id\fP) or xwd-style selection
(\fI-click\fP).
.TP
-bdrs or -borders
.br
Include window-manager borders in window images.  This option
applies only to selection by ID (\fI\-id\fP) or xwd-style selection
(\fI-click\fP).  It is provided as a convenience since \fI--noborders\fP
doesn't exactly flow from most peoples minds.
.TP
-b \fIpercent\fR or -brighten \fIpercent\fR
.br
brighten or darken the image by \fIpercent\fR.  Percentages are given
as integers. 100 is the base and a larger number will brighten the image
while a smaller number will darken the image.
.TP
-and \fIandBits\fR
Clear all colormap bits up to the given plane.  This has the effect of
darkening the image somewhat and shrinking the apparent depth of the image
(and, consequently, the size of the color table).  \fIAndBits\fR should
be in the range [1-8] inclusive.
.TP
-or \fIorBits\fR
Set all colormap bits up to the given plane.  This brightens the image
somewhat and also shrinks the apparent depth of the image.  When
both \-A and \-O are specified, ANDing will occur before ORing.
.TP
-reverse
Reverse the colors in the image.  The bits of each color used in the
image are inverted.
.TP
-bw
Convert the source color image to a monochrome bitmap.  All colors
falling below the average color intensity are mapped to black.  Others
are mapped to white.
.TP
-halftone
Convert the source color image to a halftoned monchrome bitmap.
Resolution is maintained by increasing the size of the image by
a factor of four on both axes.
.TP
-mdither
Convert the source color image to a dithered monochrome bitmap.
This is like halftoning, but resolution is sacrificed to keep the
resulting image the same size as the original.  The matrix dithering
algorithm used with this option is most suitable for line-drawings
and text.  For more complex graphics the \fI-dither\fR option is recommended.
.TP
-dither
Convert the source color image to a dithered monochrome bitmap with
the Floyd-Steinberg algorithm.
.sp 3
.\"
.\"
.\"
.\"
.SH OUTPUT FORMAT OPTIONS
.TP
-cps
Write output in \fIPostscript\fP format using the colorimage operator
for color printers.
Color to grayscale conversion is bundled into the output so you can actually
use either color or cheaper grayscale printers.  For monochrome displays, the
\fI-ps\fP option will give more compact output.
.TP
-ps
Write output in \fIPostscript\fP format for greyscale printers.
The number of bits per Postscript sample is determined by the depth of the
image.
.TP
-xwd
Write output in \fIxwd\fP format.  Use this if you want to convert to another
output format with \fBPbm+\fP.
.TP
-bm
Write the output in X Bitmap format if the image is black and white, or
XX Pixmap format if the image is gray or color.
.TP
-bm2
Write the output in X Bitmap format if the image is black and white, or
XX Pixmap format 2 if the image is gray or color.
-bm3
Write the output in X Bitmap format if the image is black and white, or
XX Pixmap format 3 if the image is gray or color.
.TP
-puzzle
Write output in a format suitable for loading into the \fIpuzzle\fP
program (see example below).
.sp 2
.\"
.\"
.\"
.\"
.\"
.SH POSTSCRIPT OPTIONS
.TP
-compress
Enable or suppress Postscript image run-length encoding.  Postscript output
is
normally compressed to minimize the size of output.  If your printer
can't handle compressed output, you should use \fI--compress\fP to turn
off compression.
.TP
-eps
Create Encapsulated Postscript output, rather than normal stand-alone
Postscript.  This adds EPSF header comments and removes all scaling and
translation of the image.
.TP
-l or -landscape
.br
Use landscape layout (11 x 8.5) for Postscript output.  This option is
ignored if Encapsulated Postscript output is requested.
.TP
-bin
Write Postscript output in binary rather than using hexidecimal encoding.
This causes the image portion of the output to use half as much space,
decreasing transmission time to the printer.  Note that not all print
spoolers can handle 8 bit binary data, so this may not work on your system!
.TP
-limit
For Postscript output, check printer memory availability before attempting
to print an image (the code to perform the checks is integrated into the
output of xgrabsc).  This is turned off if Encapsulated Postscript output
is requested, and may be disabled completely when building the xgrabsc
program.  On the command line it may be turned off with \fI--limit\fP.
.TP
-preview or -prev
.br
Selects Encapsulated Postscript output with an EPSI preview image in its
header.  The preview image is dithered to black and white.  Programs such
as xfig can display these preview images.  Ghostscript and other Postscript
interpreters can be used to preview EPS files without generating preview
images, so if you have one of these packages there is not much point in using
this option.
.TP
-page \fIwidthxheight-marginWidth-marginHeight\fP
Sets the size of the paper and the borders you desire around the edge of the
paper.  Xgrabsc will reduce the image if necessary to keep it within the
borders you specify.  The default page size and margins are set when
SHAR_EOF
true || echo 'restore of xgrabsc.man failed'
fi
echo 'End of  part 1'
echo 'File xgrabsc.man is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
-- 
---
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
