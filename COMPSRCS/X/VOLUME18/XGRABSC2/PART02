Path: uunet!ogicse!hp-cv!sdd.hp.com!mips!msi!dcmartin
From: bruce@SLC.COM (Bruce Schuchardt)
Newsgroups: comp.sources.x
Subject: v18i053: xgrabsc v2.1 - grab screen dump, Part02/05
Message-ID: <1992Jul23.140149.27003@msi.com>
Date: 23 Jul 92 14:01:49 GMT
Article-I.D.: msi.1992Jul23.140149.27003
References: <csx-18i052-xgrabsc-2.1@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1669
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: bruce@SLC.COM (Bruce Schuchardt)
Posting-number: Volume 18, Issue 53
Archive-name: xgrabsc-2.1/part02

#!/bin/sh
# this is part.02 (part 2 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file xgrabsc.man continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 2; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping xgrabsc.man'
else
echo 'x - continuing file xgrabsc.man'
sed 's/^X//' << 'SHAR_EOF' >> 'xgrabsc.man' &&
xgrabsc is built.  Measurements are in inches (e.g., 8.5x11.0-0.5-0.5)
.sp 3
.\"
.\"
.\"
.\"
.\"
.\"
.\"
.SH PROCESSING ORDER
It is helpful to know the order of processing when multiple processing
options are given on the command line.
.PP
Processing is done in five phases:  1) set up, 2) obtain image,
3) process colors, 4) poly->monochrome conversions, and 5) output conversion.
.PP
The set-up phase includes processing command-line options, sleeping,
connecting to X-Windows, freezing the screen, and grabbing the mouse if
necessary.
.PP
If the mouse is grabbed for rubber-banding, an upper-left-corner cursor is
displayed until the left mouse button is pressed.  A lower-left-corner
cursor is then displayed while drawing rubber-rectangles until the mouse
button is released.
.PP
If the mouse is grabbed for xwd-style window selection, an xwd-style cursor
is displayed until the left mouse button is pressed.
.PP
The mouse is then released.
.PP
The bell is then run and the image is pulled from the screen.
.PP
Following the image-grab, the bell is run twice and the screen is released.
.PP
If the image is not monochrome, the color manipulation functions are
then applied in this order: brighten, AND, and OR, reverse.
.PP
Only one polychrome to monochrome conversion is allowed.  If none of
these is chosen, the color table of a polychrome image is compressed
in preparation for output conversion.
.PP
The output stream is then opened and the image is written in the selected
output format.
.sp 2
.SH ENVIRONMENT
XXGRABSC - specifies command line arguments to be processed before those
actually entered on the command line.
.PP
DISPLAY - specifies the name of the display that xgrabsc should grab from.
.sp 2
.SH EXAMPLES
The simplest form of use, giving Postscript output, is
.sp
.ti +5
xgrabsc >outfile.ps
.sp
.PP
To write output in \fIPostscript\fP format and send to the printer,
use
.sp
.ti +5
xgrabsc | lpr
.sp
It is sometimes helpful to brighten an image somewhat before it is
formatted for Postscript output.  E.g., to brighten by 30%
.sp
.ti +5
xgrabsc -b 130 | lpr
.sp
.PP
If your printer supports color, and your display is color, you can
have xgrabsc generate color output instead of gray scale:
.sp
.ti +5
xgrabsc -cps | lpr
.sp
.PP
The default Postscript output attempts to scale the image so that
it will all fit on one page, and is centered on the page.  If you
are grabbing images to include in documents, such as with FrameMaker,
you should ask for Encapsulated Postscript output with the \fI-eps\fP
switch.  For example:
.sp
.ti +5
X  xgrabsc -eps -o image1.eps
.PP
To select an entire window, write output in \fIpuzzle\fP format
and read into the puzzle program, use the commands
.sp
.ti +5
xgrabsc -click -puzzle >outfile.pzl
.br
.ti +5
puzzle -picture outfile.pzl
.sp
.PP
To have xgrabsc sleep for three seconds before rubber-banding, display
processing information, and have the result displayed with xwud,
.sp
.ti +5
xgrabsc -xwd -verbose -s 3 | xwud
.sp
.PP
To grab an image from another server and then reduce the colormap
to three bits by ANDing, use
.sp
.ti +5
xgrabsc -d other:0.0 -and 5 -bm >outfile.xpm
.sp
You will, of course, have to go to the other machine to select the
image with that machine's mouse.
.sp 2
.SH LIMITATIONS
Colormaps larger than 256 entries are not currently supported. This
means that it won't work with your fancy 24-bit display.
.PP
The default screen visual is used as the visual for the image.
Visuals are associated with particular windows, and xgrabsc pretends
ignorance about any windows but the root.
.PP
This software has been tested with StaticGray and 8-plane PseudoColor
on DECStations (using both UWS 2.2 and X11 Release 4).  It has also
been tested with 8-plane PseudoColor on Sun SparcStations and various
other platforms using X11 Release 4 and Release 5.
.PP
XX11 Pixmap format is rather verbose.
You may want to run large images through the \fIcompress\fP utility
before storing them in a file.  E.g.,
.sp
.ti +5
xgrabsc -bm | compress >outfile.xpm.Z
.sp
.SH AUTHOR
.nf
X     Bruce Schuchardt
X    Servio Corporation
X      bruce@slc.com
.fi
.sp 2
.SH ACKNOWLEGEMENTS
.PP
Some of the source code for xgrabsc came from
the xloadimage project by Jim Frost (jimf@saber.com) and others.  Jim's
copyright has been included both here and in the source code.
.PP
The idea for using run-length encoding for Postscript output came from
the xwd2ps project by Robert Tatar and Craig A. McGowan, as did the
colorimage hack for monochrome display devices.
.PP
The ad2c.sed script that makes it possible to let you run xgrab without
installing XGrab.ad everywhere is part of the ad2c package developed by
George Ferguson.
.sp 2
.SH CONTRIBUTORS
.PP
Johan Garpendal did the initial color postscript work.
.PP
Hal R. Brand wrote the binary Postscript enhancements.
.PP
Yves Arrouye wrote the EPS Preview and page-configuration enhancements.
.sp 2
.SH COPYRIGHT
Copyright (c) 1990-92 Bruce Schuchardt
.PP
\fIXgrabsc\fR is copywritten material with a very loose copyright
allowing unlimited modification and distribution if the copyright
notices are left intact.  Various portions are copywritten by various
people, but all use a modification of the MIT copyright notice.
Please check the source for complete copyright information.  The
intent is to keep the source free, not to stifle its distribution, so
please write to me if you have any questions.
.PP
THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR
CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
USE OR PERFORMANCE OF THIS SOFTWARE.
.s 2
.SH SEE ALSO
XX(1X), xhost(1), xwd(1X), xwud(1X), xwd2ps(1X), xloadimage(1X), xpm(1X),
xpr(1X), puzzle(1X), compress(1), uncompress(1), xv(1X)
SHAR_EOF
echo 'File xgrabsc.man is complete' &&
chmod 0644 xgrabsc.man ||
echo 'restore of xgrabsc.man failed'
Wc_c="`wc -c < 'xgrabsc.man'`"
test 15159 -eq "$Wc_c" ||
	echo 'xgrabsc.man: original size 15159, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Bugs ==============
if test -f 'Bugs' -a X"$1" != X"-c"; then
	echo 'x - skipping Bugs (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Bugs (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Bugs' &&
/*========================================================================
*
* Name - Bugs
*
* Version:	1.4
*
* ccsid:	@(#)Bugs	1.4 - 7/9/92 12:47:40
* from: 	ccs/s.Bugs
* date: 	7/9/92 13:35:24
*
* Description: Known bugs and problems.  This list does not include
*              bugs that have been fixed.  See the patch set README
*              files for descriptions of the bugs they fix.
*
*========================================================================*/
X
*  Postscript images produced by xgrabsc don't get printed
X
This is almost always a memory requirement problem.  Xgrabsc v2.0 
can generate checks for memory availability so you can at least 
see how much memory you're lacking to be able to print your 
document.  I'd like to be able to preempt the transfer of the 
rest of the file when there isn't enough memory to process it, 
but haven't been able to make this happen.
X
X
*  The puzzle program won't display xgrabsc output
X
While xgrabsc can create puzzle picture files from monochrome 
screens, the puzzle program will not display pictures with "-
picture" on monochrome systems. This is not a "bug" in xgrabsc, 
but is a "confusing feature".
X
X
*  When started from a window-manager menu, xgrabsc fails to grab an image.
X
If you run xgrabsc from a Twm menu, be sure to end your exec 
command with "&". The program may not be able to grab the pointer 
or server unless you do this.  This will likely happen with any 
window manager, but has been reported onlyfor Twm.
X
X
*  Encapsulate Postscript images are not centered or scaled when printed
X
This isn't a problem with xgrabsc.  EPS files are not supposed to
contain scaling or transformation commands.
X
X
*  The X cursor isn't included in images
X
If someone can tell me how to grab an image with the X cursor, I'd
be much obliged.  Most X servers explicitely hide the cursor when
processing getImage requests.
X
X
* BadMatch errors are generated when grabbing with the keyboard (-k) and
X  the cursor is on a menubar
X
I haven't been able to reproduce this error.
X
X
* Can't grab xeyes
X
I haven't been able to reproduce this problem.
X
X
* Dithered output sent to "xpr" for a laserjet doesn't produce an image
X
I have no laserjet to test with.
X
X
* The halftoning algorithm in xgrabsc should be improved
X
Someone have a better algorithm?  If so, please send it to me.  I'm
not interested in supporting zillions of different dithering
algorithms, but would be happy to improve the ones already in xgrabsc.
X
X
* Postscript output doesn't center properly when printed
X
The paper size is hard-coded into xgrabsc.  If you're not using the
US Letter size (8.5 x 11 inches), you'll have to change the constants
in config.h to the size of paper you use.  Paper size selection will
be a command-line option in a future release of xgrabsc.
X
X
* Binary Postscript images appear dark when printed
X
Your print spooler is probably stripping off the top bits of the binary
data, causing the samples to be darker.  Some systems have "lpr" options
to tell the spooler that the file you're printing contains binary data.
Consult your lpr documentation.
X
X
SHAR_EOF
chmod 0644 Bugs ||
echo 'restore of Bugs failed'
Wc_c="`wc -c < 'Bugs'`"
test 3103 -eq "$Wc_c" ||
	echo 'Bugs: original size 3103, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
*========================================================================
*
* Name - README
*
* Version:	1.9
*
* ccsid:	@(#)README	1.9 - 7/9/92 12:47:46
* from: 	ccs/s.README
* date: 	7/9/92 13:35:25
*
* Copyright (C) 1990-92 Bruce Schuchardt
* See either the man page or the file cpyright.h for full copyright
* information.
*
* Description:  README for xgrabsc v2.1
*
*========================================================================
X
INTRO TO xgrabsc
X
When I first wrote xgrabsc, there were a number of programs available
for getting X-Window screen dumps (e.g., xwd and xwps), but they
were all restricted to dumping a single window in a single format.
I wrote xgrabsc in an effort to get around these restrictions.
X
The main contribution of this program is its use of root-window
rubberbanding to allow capture of arbitrary portions of the screen,
and its multiple output formats (x-bitmap, x-pixmap, xwd, puzzle,
"simple", and several Postscript formats).
X
The Postscript dumps will use run-length encoding if it results in
any savings in size.  A typical xterm window dump on a mono system
runs around 40K bytes (20K for binary output).  An xwd dump on the
same screen will be around 650K bytes.  While the xpr program has a
"compress" option, it only compresses white samples.  Reducing the 
size of the output increases the cost of computing the dump and the
final printing of the dump, but it reduces the cost of storage and
the time to transfer the dump to your printer.  The latter is
especially important for large screen dumps.
X
The xgrabsc program is not interactive.  You specify all processing
options on the command line with obscure option characters.  These
are all detailed in the man page.  An interactive interface to xgrabsc,
named xgrab, is also included in this release.  xgrab allows you to
do most of the setup with a mouse, and then uses the xgrabsc program
to actually do the processing.  To use xgrab you must have the xgrabsc
program in your execution path.
X
X
X
OPTIONS FOR BUILDING xgrabsc
X
The file config.h contains all the configuration options for xgrabsc.
Please take a moment to look through that file before building xgrabsc.
X
X
X
BUILDING xgrabsc
X
XXgrabsc should build easily enough.  If you don't have the imake
program, use simple.mak (i.e., make -f simple.mak).  There are targets
for xgrabsc, install, install.man, and clean.  E.g.,
X  make
X  make install
X  make install.man
X  make clean
X
The install target will put xgrabsc in /usr/bin/X11 and the
man page in /usr/man/man1.  Change simple.mak before installing
with it if you don't like these locations.
X
For Vax/VMS installations, this release includes a VMSMAKE.COM script that was
contributed by a user, as well as a GETOPT.C module that implements the
getopt() function.  I am informed that you will also need a copy of the
XXWDfile.h include file from the MIT XWindows distribution, so I've included a
copy of that file.  I do not have a Vax to test with so I can't claim you won't
have problems in building xgrabsc under VMS, but this gives you a running start
at it. 
X
X
X
Please send comments, bugs, and enhancements to bruce@slc.com.  Please
read the Bugs file before sending bug reports.
X
X
X Manifest
X ---------------------------------
X README              this file
X README.xx_yy        files describing incremental changes to xgrabsc
X
X Acks                acknowledgements for code gleaned from other
X                     systems, and people who have been very helpful
X                     in adding features and removing bugs from xgrabsc
X
X Bugs                known bugs - read this before sending bug reports
X
X Imakefile           Input for "imake" program
X simple.mak          Simpler input for standard "make"
X
X checkvm.h           Memory-check Postscript operator
X config.h            Configuration options
X cpyright.h          Copyright notice for this software (READ IT)
X cmdopts.h	     Command line options for xgrabsc
X ps_color.h          Bob Tatar's colorimage operator for mono systems
X patchlevel.h        Current patch level
X virtual.h           Support for virtual window managers
X xgrab.c             Source for window interface to xgrabsc
X xgrabsc.c           Program source
X
X *.hc                function include files for xgrabsc.c
X
X VMSMAKE.COM         a DCL command script to make xgrabsc and xgrab under VMS
X                     (this is untested - I no longer have a VAX at my disposal)
X XWDfile.h           xwd structure definition needed for VAX/VMS builds
X 
X ad2c.sed            sed script to convert XGrab.ad to fallback resources
X                     for xgrab
X
X xgrabsc.man         Man page for xgrabsc
X xgrab.man           Man page for xgrab
X
X XGrab.ad            Resources for the xgrab program
X
X
X
BUGS:
X
Common problems and known bugs are described in the Bugs file.
X
X
X
TO DO:
X
Support for 24-bit displays.  If someone wants to give this a shot, please
let me know.
X
Selectable paper size for Postscript output.
X
X
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X  Bruce Schuchardt          bruce@SLC.COM
X  Servio Corp.
X  Beaverton, OR
SHAR_EOF
chmod 0644 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 5078 -eq "$Wc_c" ||
	echo 'README: original size 5078, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README.2_1 ==============
if test -f 'README.2_1' -a X"$1" != X"-c"; then
	echo 'x - skipping README.2_1 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README.2_1 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README.2_1' &&
/*========================================================================
*
* Name - README.2_1
*
* Version:	1.1
*
* ccsid:	@(#)README.2_1	1.1 - 7/9/92 12:39:15
* from: 	ccs/s.README.2_1
* date: 	7/9/92 13:35:25
*
* Description: Notes on release 2.1
*
*========================================================================
X
X
This release adds the following features:
X
* xgrabsc no longer uses getopt(), and most command line switches have been
X  changed from single-characters to keywords.  Users of previous versions
X  of xgrabsc should make sure any XGRABSC environment variables are updated
X  to reflect this change.
X  
* Command line switches may be preceded with '-' (e.g., -preview) or
X  '--' (e.g., --preview).  A double dash turns off an option, while a
X  single or omitted dash turns on an option.  Each argument and switch must
X  be seperated with white space.
X
* New xgrabsc options
X
X  preview	a preview option for encapsulated postscript output
X  page		page size and border specification
X  nodither	turns off any selected dithering options
X  colproc	adds/removes the colorImage operator from color postscript
X		output
X  bm3		write color output in XPM3 format
X
* All xgrab text fields but the Alternate Display are now set in XGrab.ad
X  instead of xgrab.c.  This means you can now put defaults for these fields
X  in your .Xdefaults
X
* border removal now attempts to remove the window-mgr's title as well.
X
X
Notes section:
X
Added attribution for ad2c.sed.  George Ferguson wrote ad2c and every person
who uses xgrab without installing XGrab.ad should be grateful to George for
ad2c, which is used to create the fallback resource set for the xgrab program.
X
Removed use of getopt() from xgrabsc, and changed all switches to be
more verbose.  I was running out of letters and numbers and things were
starting to get a bit silly.
X
Allow compression of images in EPS output.
X
Allow selection of colorImage proc output in config.h, and provide
command-line option for adding/removing it.
X
Fixed border-removal switch in xgrab.  It was doing the reverse of what it
advertised.
X
Made landscape and encapsulated postscript options mutually exclusive, and
added preview option for encapsulated postscript.  The preview image is in
EPSI format.  That is, it's the transportable image format, not TIFF or PICT.
X
Changed shapes of radio buttons in xgrab to make them distinguishable from
toggle buttons and command buttons.
X
Removed setting of the text of all text fields in xgrab except the display.
The display text is taken from your DISPLAY environment variable.  You can
now set the other strings in your .Xdefaults file (see XGrab.ad for examples).
X
Added page-config option.  
X
Changed bitmap_pad in XCreateImage calls from 0 to 8.  The manual says it
has to be 8, 16 or 32.  Zero isn't an option.  Odd that no-one has mentioned
this before.
X
Added basic XPM3 output format
X
Made border removal search for a client window of the selected window if
selection style is click or key.  This gets rid of the wm title too.
SHAR_EOF
chmod 0644 README.2_1 ||
echo 'restore of README.2_1 failed'
Wc_c="`wc -c < 'README.2_1'`"
test 3026 -eq "$Wc_c" ||
	echo 'README.2_1: original size 3026, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= VMSMAKE.COM ==============
if test -f 'VMSMAKE.COM' -a X"$1" != X"-c"; then
	echo 'x - skipping VMSMAKE.COM (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting VMSMAKE.COM (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'VMSMAKE.COM' &&
$!
$! Name - VMSMAKE.COM
$!
$! ccs version:	1.2
$!
$! ccsid:	@(#)VMSMAKE.COM	1.2 - 7/9/92 13:07:31
$! from: 	ccs/s.VMSMAKE.COM
$! date: 	7/9/92 13:35:25
$!
$! This is an UNTESTED command file for building xgrabsc under Vax/VMS
$!
$!
$ define x11 decw$include
$ cc xgrabsc
$ link xgrabsc,sys$input/opt
sys$library:decw$xlibshr/share
sys$library:vaxcrtl/share
$!
$! the link for xgrab is questionable - it probably needs an Athena
$! widget library
$!
$ cc xgrab
$ link xgrab,sys$input/opt
sys$library:decw$xlibshr/share
sys$library:vaxcrtl/share
$ exit
SHAR_EOF
chmod 0644 VMSMAKE.COM ||
echo 'restore of VMSMAKE.COM failed'
Wc_c="`wc -c < 'VMSMAKE.COM'`"
test 552 -eq "$Wc_c" ||
	echo 'VMSMAKE.COM: original size 552, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= XWDFile.h ==============
if test -f 'XWDFile.h' -a X"$1" != X"-c"; then
	echo 'x - skipping XWDFile.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting XWDFile.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'XWDFile.h' &&
#include <X11/copyright.h>
X
/* Copyright 1985, 1986, Massachusetts Institute of Technology */
X
/* $XConsortium: XWDFile.h,v 1.12 89/10/08 16:33:57 rws Exp $ */
/*
X * XWDFile.h	MIT Project Athena, X Window system window raster
X *		image dumper, dump file format header file.
X *
X *  Author:	Tony Della Fera, DEC
X *		27-Jun-85
X * 
X * Modifier:    William F. Wyatt, SAO
X *              18-Nov-86  - version 6 for saving/restoring color maps
X */
X
X
/*
X * This is not portable between machines of differing word sizes.  To make
X * it portable, do the following things:
X *
X *     o  #include <X11/Xmd.h>
X *     o  remove the typedef for xwdval
X *     o  replace all instances of xwdval with the appropriate CARD32 ... B32
X *     o  make sure that XWDFileHeader is padded to quadword boundaries
X *     o  make sure the window name is written out quadword aligned
X *     o  create an XWDColor structure that contains the same fields as XColor
X *        but which is defined in terms of CARD32 B32, CARD16 B16, and CARD8
X *     o  convert XColor structures to XWDColor structures in xwd
X *     o  remove all xwdval casts from xwd
X *     o  pack image data before writing out if necessary
X *     o  replace casts from xwdval objects in xwud with cvtINT macros
X *     o  convert XWDColor structures to XColor structures
X *     o  unpack data after reading in if necessary
X */
X
X
#include "Xmd.h"
X
#define XWD_FILE_VERSION 7
#ifdef WORD64
#define sz_XWDheader 104
#else
#define sz_XWDheader 100
#endif
#define sz_XWDColor 12
X
typedef CARD32 xwdval;		/* for old broken programs */
X
typedef struct _xwd_file_header {
X	CARD32 header_size B32;  /* Size of the entire file header (bytes). */
X	CARD32 file_version B32;	/* XWD_FILE_VERSION */
X	CARD32 pixmap_format B32;	/* Pixmap format */
X	CARD32 pixmap_depth B32;	/* Pixmap depth */
X	CARD32 pixmap_width B32;	/* Pixmap width */
X	CARD32 pixmap_height B32;	/* Pixmap height */
X	CARD32 xoffset B32;		/* Bitmap x offset */
X	CARD32 byte_order B32;		/* MSBFirst, LSBFirst */
X	CARD32 bitmap_unit B32;		/* Bitmap unit */
X	CARD32 bitmap_bit_order B32;	/* MSBFirst, LSBFirst */
X	CARD32 bitmap_pad B32;		/* Bitmap scanline pad */
X	CARD32 bits_per_pixel B32;	/* Bits per pixel */
X	CARD32 bytes_per_line B32;	/* Bytes per scanline */
X	CARD32 visual_class B32;	/* Class of colormap */
X	CARD32 red_mask B32;		/* Z red mask */
X	CARD32 green_mask B32;		/* Z green mask */
X	CARD32 blue_mask B32;		/* Z blue mask */
X	CARD32 bits_per_rgb B32;	/* Log2 of distinct color values */
X	CARD32 colormap_entries B32;	/* Number of entries in colormap */
X	CARD32 ncolors B32;		/* Number of Color structures */
X	CARD32 window_width B32;	/* Window width */
X	CARD32 window_height B32;	/* Window height */
X	CARD32 window_x B32;		/* Window upper left X coordinate */
X	CARD32 window_y B32;		/* Window upper left Y coordinate */
X	CARD32 window_bdrwidth B32;	/* Window border width */
#ifdef WORD64
X	CARD32 header_end B32;		/* Pad to fill out word */
#endif
} XWDFileHeader;
X
struct {
X        CARD32	pixel B32;
X        CARD16	red B16;
X	CARD16	green B16;
X	CARD16	blue B16;
X        CARD8	flags;
X        CARD8	pad;
} XWDColor;
X
X
/*
X * Name - XWDFile.h
X *
X * ccs version:	1.1
X *
X * ccsid:	@(#)XWDFile.h	1.1 - 7/2/92 16:01:52
X * from: 	ccs/s.XWDFile.h
X * date: 	7/9/92 13:35:26
X *
X * This is XWDFile.h from XWindows v11r4
X */
SHAR_EOF
chmod 0644 XWDFile.h ||
echo 'restore of XWDFile.h failed'
Wc_c="`wc -c < 'XWDFile.h'`"
test 3313 -eq "$Wc_c" ||
	echo 'XWDFile.h: original size 3313, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xmd.h ==============
if test -f 'Xmd.h' -a X"$1" != X"-c"; then
	echo 'x - skipping Xmd.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xmd.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xmd.h' &&
/***********************************************************
Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
X
X                        All Rights Reserved
X
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  
X
DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.
X
******************************************************************/
#ifndef XMD_H
#define XMD_H 1
/* $XConsortium: Xmd.h,v 1.35 89/08/15 14:38:57 jim Exp $ */
/*
X *  Xmd.h: MACHINE DEPENDENT DECLARATIONS.
X */
X
/*
X * Special per-machine configuration flags.
X */
#ifdef CRAY
#define WORD64				/* 64-bit architecture */
#define UNSIGNEDBITFIELDS		/* bit fields do not honor sign */
#endif
X
X
/*
X * Stuff to handle large architecture machines; the constants were generated
X * on a 32-bit machine and must coorespond to the protocol.
X */
#ifdef WORD64
#define MUSTCOPY
#endif /* WORD64 */
X
X
/*
X * Definition of macro used to set constants for size of network structures;
X * machines with preprocessors that can't handle all of the sz_ symbols
X * can define this macro to be sizeof(x) if and only if their compiler doesn't
X * pad out structures (esp. the xTextElt structure which contains only two 
X * one-byte fields).  Network structures should always define sz_symbols.
X *
X * The sz_ prefix is used instead of something more descriptive so that the
X * symbols are no more than 32 characters long (which causes problems for some
X * compilers and preprocessors).
X */
#if defined(__STDC__) && !defined(UNIXCPP)
#define SIZEOF(x) sz_##x
#else
#define SIZEOF(x) sz_/**/x
#endif /* if ANSI C compiler else not */
X
X
X
/*
X * ibm pcc doesn't understand pragmas.
X */
#if defined(ibm032) && defined(__HIGHC__)
pragma on(pointers_compatible);
pragma off(char_default_unsigned);
#endif
X
X
/*
X * Bitfield suffixes for the protocol structure elements, if you
X * need them.  Note that bitfields are not guarranteed to be signed
X * (or even unsigned) according to ANSI C.
X */
#ifdef WORD64
#define B32 :32
#define B16 :16
#else
#define B32
#define B16
#endif
X
typedef long           INT32;
typedef short          INT16;
typedef char           INT8;
X
typedef unsigned long CARD32;
typedef unsigned short CARD16;
typedef unsigned char  CARD8;
X
typedef unsigned long		BITS32;
typedef unsigned short		BITS16;
typedef unsigned char		BYTE;
X
typedef unsigned char            BOOL;
X
X
/*
X * definitions for sign-extending bitfields on 64-bit architectures
X */
#if defined(WORD64) && defined(UNSIGNEDBITFIELDS)
#define cvtINT8toInt(val)   (((val) & 0x00000080) ? ((val) | 0xffffffffffffff00) : (val))
#define cvtINT16toInt(val)  (((val) & 0x00008000) ? ((val) | 0xffffffffffff0000) : (val))
#define cvtINT32toInt(val)  (((val) & 0x80000000) ? ((val) | 0xffffffff00000000) : (val))
#define cvtINT8toLong(val)  cvtINT8toInt(val)
#define cvtINT16toLong(val) cvtINT16toInt(val)
#define cvtINT32toLong(val) cvtINT32toInt(val)
#else
#define cvtINT8toInt(val) (val)
#define cvtINT16toInt(val) (val)
#define cvtINT32toInt(val) (val)
#define cvtINT8toLong(val) (val)
#define cvtINT16toLong(val) (val)
#define cvtINT32toLong(val) (val)
#endif /* WORD64 and UNSIGNEDBITFIELDS */
X
X
X
#ifdef MUSTCOPY
/*
X * This macro must not cast or else pointers will get aligned and be wrong
X */
#define NEXTPTR(p,t)  (((char *) p) + SIZEOF(t))
#else /* else not MUSTCOPY, this is used for 32-bit machines */
/*
X * this version should leave result of type (t *), but that should only be 
X * used when not in MUSTCOPY
X */  
#define NEXTPTR(p,t) (((t *)(p)) + 1)
#endif /* MUSTCOPY - used machines whose C structs don't line up with proto */
X
#endif /* XMD_H */
X
/*
X * Name - Xmd.h
X *
X * ccs version:	1.1
X *
X * ccsid:	@(#)Xmd.h	1.1 - 7/2/92 16:01:53
X * from: 	ccs/s.Xmd.h
X * date: 	7/9/92 13:35:26
X *
X * This is Xmd.h from XWindows v11r4
X */
SHAR_EOF
chmod 0644 Xmd.h ||
echo 'restore of Xmd.h failed'
Wc_c="`wc -c < 'Xmd.h'`"
test 4635 -eq "$Wc_c" ||
	echo 'Xmd.h: original size 4635, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= cmdopts.h ==============
if test -f 'cmdopts.h' -a X"$1" != X"-c"; then
	echo 'x - skipping cmdopts.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting cmdopts.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'cmdopts.h' &&
/*========================================================================
X *
X * Name - cmdopts.h
X *
X * ccs version:	1.1
X *
X * ccsid:	@(#)cmdopts.h	1.1 - 7/9/92 13:18:35
X * from: 	ccs/s.cmdopts.h
X * date: 	7/9/92 13:35:26
X *
X * Copyright (c) 1990-92 Bruce Schuchardt.
X * Read the file cpyright.h for full copyright information.
X *
X *
X * Description:
X *
X * command line options for xgrabsc
X *
X *========================================================================
X */
X
typedef enum {
X  CMD_BELL,
X  CMD_GRABSERVER,
X  CMD_DISPLAY,
X  CMD_OUTPUT,
X  CMD_PRESLEEP,
X  CMD_POSTSLEEP,
X  CMD_VERBOSE,
X  CMD_BORDERS,
X  CMD_NOBORDERS,
X
X  CMD_SOURCE_KEY,
X  CMD_SOURCE_ID,
X  CMD_SOURCE_RECT,
X  CMD_SOURCE_ROOT,
X  CMD_SOURCE_WD,
X
X  CMD_AND,
X  CMD_OR,
X  CMD_NOT,
X  CMD_BRIGHTEN,
X
X  CMD_DITHER_MAP,
X  CMD_DITHER_MATRIX,
X  CMD_DITHER_FS,
X  CMD_DITHER_HALFTONE,
X  CMD_DITHER_NONE,
X
X  CMD_OUTPUT_PS,
X  CMD_OUTPUT_CPS,
X  CMD_OUTPUT_SIMPLE,
X  CMD_OUTPUT_XWD,
X  CMD_OUTPUT_XPM,
X  CMD_OUTPUT_XPM2,
X  CMD_OUTPUT_XPM3,
X  CMD_OUTPUT_PIXMAP,
X  CMD_OUTPUT_PUZZLE,
X
X  CMD_BIN,
X  CMD_COMPRESS,
X  CMD_EPS,
X  CMD_LANDSCAPE,
X  CMD_LIMIT,
X  CMD_PAGE,
X  CMD_PREVIEW,
X  CMD_COLORPROC
X
X  } commandEnum;
X
X
typedef struct {
X  commandEnum	command;
X  int		numargs;
X  char		*userstr;
X  } commandType;
X
commandType commands[] = {
X {  CMD_BELL,		0, "bell"	},
X {  CMD_GRABSERVER,	0, "grab"	},
X {  CMD_DISPLAY,	1, "d"		},
X {  CMD_DISPLAY,	1, "display"	},
X {  CMD_OUTPUT,		1, "o"		},
X {  CMD_OUTPUT,		1, "out"	},
X {  CMD_PRESLEEP,	1, "s"		},
X {  CMD_PRESLEEP,	1, "sleep"	},
X {  CMD_POSTSLEEP,	1, "post"	},
X {  CMD_VERBOSE,	0, "verbose"	},
X {  CMD_BORDERS,	0, "borders"	},
X {  CMD_BORDERS,	0, "bdrs"	},
X {  CMD_NOBORDERS,	0, "nobdrs"	},
X {  CMD_NOBORDERS,	0, "noborders"	},
X
X {  CMD_SOURCE_KEY,	0, "key"	},
X {  CMD_SOURCE_ID,	1, "id"		},
X {  CMD_SOURCE_RECT,	0, "stretch"	},
X {  CMD_SOURCE_ROOT,	0, "root"	},
X {  CMD_SOURCE_WD,	0, "click"	},
X
X {  CMD_AND,		1, "and"	},
X {  CMD_OR,		1, "or"		},
X {  CMD_NOT,		0, "reverse"	},
X {  CMD_BRIGHTEN,	1, "b"		},
X {  CMD_BRIGHTEN,	1, "brighten"	},
X
X {  CMD_DITHER_MAP,	0, "bw"		},
X {  CMD_DITHER_MATRIX,	0, "mdither"	},
X {  CMD_DITHER_FS,	0, "dither"	},
X {  CMD_DITHER_HALFTONE,0, "halftone"	},
X {  CMD_DITHER_NONE,    0, "nodither"   },
X
X {  CMD_OUTPUT_PS,	0, "ps"		},
X {  CMD_OUTPUT_CPS,	0, "cps"	},
X {  CMD_OUTPUT_SIMPLE,	0, "simple"	},
X {  CMD_OUTPUT_XWD,	0, "xwd"	},
X {  CMD_OUTPUT_PIXMAP,	0, "bm"		},
X {  CMD_OUTPUT_XPM2,	0, "bm2"	},
X {  CMD_OUTPUT_XPM3,	0, "bm3"	},
X {  CMD_OUTPUT_PUZZLE,	0, "puzzle"	},
X
X {  CMD_BIN,    	0, "bin"	},
X {  CMD_COMPRESS, 	0, "comp"	},
X {  CMD_COMPRESS, 	0, "compress"	},
X {  CMD_EPS,    	0, "eps"	},
X {  CMD_LANDSCAPE,	0, "l"		},
X {  CMD_LANDSCAPE,	0, "landscape"	},
X {  CMD_LIMIT,		0, "limit"	},
X {  CMD_PAGE,		1, "page"	},
X {  CMD_PREVIEW,	0, "preview"	},
X {  CMD_PREVIEW,	0, "prev"	},
X {  CMD_COLORPROC,	0, "colproc"    }
X 
};
X
int numCmds = sizeof(commands) / sizeof(commandType);
SHAR_EOF
chmod 0644 cmdopts.h ||
echo 'restore of cmdopts.h failed'
Wc_c="`wc -c < 'cmdopts.h'`"
test 2917 -eq "$Wc_c" ||
	echo 'cmdopts.h: original size 2917, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= config.h ==============
if test -f 'config.h' -a X"$1" != X"-c"; then
	echo 'x - skipping config.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting config.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'config.h' &&
/*========================================================================
X *
X * Name - config.h
X *
X * Version:	1.5
X *
X * ccsid:	@(#)config.h	1.5 - 7/9/92 12:48:31
X * from: 	ccs/s.config.h
X * date: 	7/9/92 13:35:27
X *
X * Copyright (c) 1991-92 Bruce Schuchardt.
X * Read the file cpyright.h for full copyright information.
X *
X *
X * Description:
X *   configuration options for xgrabsc
X *
X *========================================================================
X */
X
/* if you do not have memcpy routines but do have bcopy, define the following */
/* #define BCOPY */
X
/* if you have neither memcpy nor bcopy, or for some other reason would like
X * to use xgrabsc's version of memcpy, define the following */
/* #define MEMCPY */
X
/* if you want to use some other key than Control for selection, define
X * the following and replace ControlMask with the mask of your choice */
/* #define SELECTION_MASK ControlMask */
X
/* when forming postscript output and the "-c" option has not been specified,
X * xgrabsc will make a pass over the image to determine whether run-length
X * encoding will shrink the output appreciably.  If you are building xgrabsc
X * for a slower machine, you may wish to avoid this overhead.  If so,
X * define the following */
/* #define NO_RLE_CHECKS */
X
/* When forming color postscript output, xgrabsc will include a color to
X * greyscale converter in the output so that it can also be printed on
X * non-color printers.  If you prefer to have this converter omitted from
X * color postscript output by default, change the following to FALSE */
#define DEFAULT_NEED_COLORIMAGE_PROC  TRUE
X
X
/* Xgrabsc will dither Encapsulated Postscript preview images to be black
X * and white.  You can choose the default type of dithering.  Choices are
X * FS_DITHER (Floyd-Steinberg), MATRIX_HALFTONE (increases size of image),
X * MATRIX_DITHER (good for line-drawings), or MAP_BW (maps colors to black/
X * white based on grayscale brightness). */
#define PREVIEW_DITHER FS_DITHER
X
/* Xgrabsc will look for a virtual-window manager's root window for
X * window dumps.  If the virtual-window manager support code gives you
X * trouble, define the following to omit it */
/* #define NO_VIRTUAL_WINDOW */
X
/* Xgrabsc will write code to check printer memory availability before
X * attempting to display an image.  Postscript previewers may cause problems
X * with this since they usually allocate memory as needed, and so will
X * often fail memory-availability checks.
X * Editors, such as FrameMaker can also cause problems like this, so
X * the checks are turned off when Encapsulated Postscript format is
X * requested.
X * A command line switch can also turn checks off, but they can be disabled
X * totally here. */
/* #define NO_PRINTER_MEMORY_CHECKS */
X
X
/* xgrabsc has a hard-coded notion of the size of your printer's paper.
X * The default is for US Letter size (8.5x11.0 inch).
X * The inset sizes control the maximum size of the image on the page.
X * These are preset to leave at least a 0.5 inch border around the image.
X */
#define PAPER_WIDTH         8.5   /* inches are assumed */
#define PAPER_HEIGHT       11.0
X
#define VERT_MARGIN	    0.5
#define HORIZ_MARGIN	    0.5
X
X
SHAR_EOF
chmod 0644 config.h ||
echo 'restore of config.h failed'
Wc_c="`wc -c < 'config.h'`"
test 3177 -eq "$Wc_c" ||
	echo 'config.h: original size 3177, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= get.hc ==============
if test -f 'get.hc' -a X"$1" != X"-c"; then
	echo 'x - skipping get.hc (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting get.hc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'get.hc' &&
/*========================================================================
X *
X * Name - get.hc
X *
X * ccs version:	1.3
X *
X * ccsid:	@(#)get.hc	1.3 - 7/9/92 12:48:40
X * from: 	ccs/s.get.hc
X * date: 	7/9/92 13:35:27
X *
X * Description:  image grabbing functions for xgrabsc
X *
X *               see cpyright.h for copyright information
X *
X *
X *========================================================================
X */
X
/*
X * Get the image bounded by the given rectangle.
X * The associated colormap information is also extracted and returned.
X * TRUE is returned if an image was successfully grabbed, and FALSE
X * otherwise.
X */
getImage(xrect, image, window)
X  XRectangle *xrect;
X  imageInfo *image;
X  Window window;
{
X  XImage *ximage;
X  int depth, ncolors, cmapSize, numCmaps;
X  int h, w;
X  long i;
X  XColor colors[MAX_CELLS];
X  Colormap *cmaps, cmap;
X
X  if (xrect->width == 0  || xrect->height == 0)
X    return FALSE;
X
X  /* get the image */
X  depth  = DefaultDepth(hDisplay, hScreen);
X  ximage = XGetImage(hDisplay, window,
X            xrect->x, xrect->y, xrect->width, xrect->height, AllPlanes,
X            depth==1 ? XYPixmap : ZPixmap);
X  image->ximage = ximage;
X
X  /* get the colormap info */
X  cmaps = XListInstalledColormaps(hDisplay, window, &numCmaps);
X  if (numCmaps == 0)
X    cmap = DefaultColormap(hDisplay, hScreen);
X  else {
X    cmap = *cmaps;
X    if (numCmaps > 1)
X      fprintf(stderr,
X        "%s: more than one colormap found - using first encountered",
X        programName);
X  }
X  XFree(cmaps);
X
X  ncolors = DisplayCells(hDisplay, hScreen);
X  /* this won't cut the mustard for DirectColor */
X  for (i=0; i<ncolors; i++)
X    colors[i].pixel = i;
X
X  XQueryColors(hDisplay, cmap, colors, ncolors);
X  for (i=0; i<ncolors; i++) {
X    image->red[i]   = colors[i].red;
X    image->green[i] = colors[i].green;
X    image->blue[i]  = colors[i].blue;
X  }
X
X  /* figure out which colormap entries are actually used by the image */
X  ncolors = cmapSize = 0;
X  memset((char *)image->used, 0, MAX_CELLS);
X  for (h=0; h<ximage->height; h++)
X    for (w=0; w<ximage->width; w++) {
X      i = XGetPixel(ximage, w, h);
X      if (!image->used[i]) {
X        image->used[i] = TRUE;
X        if (i+1 > cmapSize)      /* keep track of colormap size */
X          cmapSize = i+1;
X        ncolors++;
X      }
X    }
X  image->numcells = cmapSize;
X  if (verbose)
X    fprintf(stderr, "%s: image has %d colors\n", programName, ncolors);
X
X  return TRUE;
}
X
X
X
/*
X * Let the user stretch a rectangle on the screen and return its values.
X * It may be wise to grab the server before calling this routine.  If the
X * screen is allowed to change during XOR drawing video droppings may result.
X */
getRectangle(xrect)
X  XRectangle *xrect;
{
X  XEvent event;
X  unsigned int x, y, rootx, rooty;
X  GC gc;
X  Cursor pointer1, pointer2;
X  int boxDrawn = False;
X  int rx, ry, rw, rh;
X
X  /* get some cursors for rectangle formation */
X  pointer1 = XCreateFontCursor(hDisplay, XC_ul_angle);
X  pointer2 = XCreateFontCursor(hDisplay, XC_lr_angle);
X
X  /* grab the pointer */
X  if (GrabSuccess != XGrabPointer(hDisplay, hRoot, False, ButtonPressMask,
X        GrabModeAsync, GrabModeAsync, hRoot, pointer1, CurrentTime)) {
X    fprintf(stderr,"%s - could not grab pointer!\n", programName);
X    exit(3);
X  }
X
X  /* create a graphics context to draw with */
X  gc = XCreateGC(hDisplay, hRoot, 0, NULL);
X  if (!gc) {
X    fprintf(stderr,"%s - could not get drawing resources\n", programName);
X    exit(3);
X  }
X  XSetSubwindowMode(hDisplay, gc, IncludeInferiors);
X  XSetForeground(hDisplay, gc, 255);
X  XSetFunction(hDisplay, gc, GXxor);
X
X  /* get a button-press and pull out the root location */
X  XMaskEvent(hDisplay, ButtonPressMask, &event);
X  rootx = rx = event.xbutton.x_root;
X  rooty = ry = event.xbutton.y_root;
X
X  /* get pointer motion events */
X  XChangeActivePointerGrab(hDisplay, ButtonMotionMask | ButtonReleaseMask,
X        pointer2, CurrentTime);
X
X
X  /* MAKE_RECT converts the original root coordinates and the event root
X   * coordinates into a rectangle in xrect */
#define MAKE_RECT(etype) \
X  x = event.etype.x_root;       \
X  y = event.etype.y_root;       \
X  rw  = x - rootx;              \
X  if (rw  < 0) rw  = -rw;       \
X  rh  = y - rooty;              \
X  if (rh  < 0) rh  = -rh;       \
X  rx = x < rootx ? x : rootx;   \
X  ry = y < rooty ? y : rooty
X
X  /* loop to let the user drag a rectangle */
X  while (TRUE) {
X    XNextEvent(hDisplay, &event);
X    switch(event.type) {
X      case ButtonRelease:
X        if (boxDrawn) {
X          XDrawRectangle(hDisplay, hRoot, gc, rx, ry, rw, rh);
X          boxDrawn = False;
X        }
X        XFlush(hDisplay);
X        /* record the final location */
X        MAKE_RECT(xbutton);
X        /* release resources */
X        XFreeGC(hDisplay, gc);
X        XFreeCursor(hDisplay, pointer1);
X        XFreeCursor(hDisplay, pointer2);
X        xrect->x      = rx;
X        xrect->y      = ry;
X        xrect->width  = rw;
X        xrect->height = rh;
X        XUngrabPointer(hDisplay, CurrentTime);
X	XSync(hDisplay, FALSE);
X        return True;
X      case MotionNotify:
X        if (boxDrawn) {
X          XDrawRectangle(hDisplay, hRoot, gc, rx, ry, rw, rh);
X          boxDrawn = False;
X        }
X        while (XCheckTypedEvent(hDisplay, MotionNotify, &event))
X          {}
X        MAKE_RECT(xmotion);
X        XDrawRectangle(hDisplay, hRoot, gc, rx, ry, rw, rh);
X        boxDrawn = True;
X        break;
X    }
X  }
}
X
X
X
X
X
X
/*
X * find the window under the mouse pointer when one of the bits in keyMask
X * is satisfied.
X */
Window getWindowWhenKeyIsPressed(keyMask)
X  unsigned int keyMask;
{
X  Bool status;
X  Window result;
X  Window root, child;
X  int root_x, root_y, win_x, win_y;
X  unsigned int keys_buttons;
X
X  if (verbose)
X    fprintf(stderr, "%s: waiting for keypress\n", programName);
X
X  do {
X    status = XQueryPointer(hDisplay, vRoot, &root, &child,
X              &root_x, &root_y, &win_x, &win_y, &keys_buttons);
X    if (!status)
X      return (Window)0;
X  } while ((keyMask != 0) && ((keyMask & keys_buttons) == 0));
X
X  if (child == (Window)0) {
X    if (verbose) {
X      fprintf(stderr, "%s: unable to find a non-root window under pointer.\n",
X              programName);
X      fprintf(stderr, "%s: using root window.\n", programName);
X    }
X    result = (Window)vRoot;
X  }
X  else
X    result = child;
X
X  if (verbose)
X    fprintf(stderr, "%s: returning window id %d\n", programName, result);
X
X  return result;
}
X
X
X
X
/*
X * choose a window as in xwd
X */
X
Window getWindow() {
X  int status;
X  Cursor cursor;
X  XEvent event;
X  Window result;
X
X  result = None;
X
X  cursor = XCreateFontCursor(hDisplay, XC_target);
X
X  status = XGrabPointer(hDisplay, vRoot, FALSE,
X         ButtonPressMask|ButtonReleaseMask, GrabModeSync,
X         GrabModeAsync, hRoot, cursor, CurrentTime);
X  if (status != GrabSuccess) {
X    fprintf(stderr, "%s: can't grab mouse\n", programName);
X    exit(3);
X  }
X
X  while (TRUE) {
X    XAllowEvents(hDisplay, SyncPointer, CurrentTime);
X    XWindowEvent(hDisplay, vRoot, ButtonPressMask|ButtonReleaseMask, &event);
X
X    switch (event.type) {
X      case ButtonRelease:
X        result = event.xbutton.subwindow;
X        if (result == None)
X          result = hRoot;
X        XUngrabPointer(hDisplay, CurrentTime);      /* Done with pointer */
X        if (verbose)
X          fprintf(stderr, "%s: found window with id 0x%x\n", programName, result);
X        return result;
X        break;
X    }
X  }
X
}
X
X
X
X
SHAR_EOF
chmod 0644 get.hc ||
echo 'restore of get.hc failed'
Wc_c="`wc -c < 'get.hc'`"
test 7414 -eq "$Wc_c" ||
	echo 'get.hc: original size 7414, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= process.hc ==============
if test -f 'process.hc' -a X"$1" != X"-c"; then
	echo 'x - skipping process.hc (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting process.hc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'process.hc' &&
/*========================================================================
X *
X * Name - process.hc
X *
X * ccs version:	1.2
X *
X * ccsid:	@(#)process.hc	1.2 - 7/6/92 10:52:51
X * from: 	ccs/s.process.hc
X * date: 	7/9/92 13:35:28
X *
X * Description:  color processing functions for xgrabsc
X *
X *               see cpyright.h for copyright information
X *
X *
X *========================================================================
X */
X
/*
X * Alter colors by setting or clearing bits in rgb values.
X * This effectively reduces the depth of the image, causing the
X * number of colors used to be reduced.  Equivalent colors are
X * merged in the image, and the used flags of remapped colors are
X * cleared.
X *
X * The number of eliminated colormap entries is returned.  The colormap
X * is not compressed.
X */
alterPlanes(image, modeIsAnd, bits)
X  imageInfo *image;
X  int modeIsAnd;      /* if TRUE, combine mask with AND; if FALSE, use OR */
X  unsigned int bits;
{
X  int nc, cidx, ridx, h, w;
X  long p;
X  XImage *ximage = image->ximage;
X  long map[MAX_CELLS];
X  int remapCount;
X  word mask;
X
X  if (ximage->depth <= 1)
X    return 0;
X
X  mask = 0xFFFF ^ ((1 << (bits+8)) - 1);
X  if (!modeIsAnd)
X    mask = ~mask & 0xFFFF;
X
X  if (verbose) {
X    fprintf(stderr, "%s: %s color with mask %x...", programName,
X            modeIsAnd? "ANDing" : "ORing", mask);
X    fflush(stderr);
X  }
X
X  nc = image->numcells;
X  if (modeIsAnd)
X    for (cidx=0; cidx<nc; cidx++) {
X      nr[cidx] = image->red[cidx]   & mask;
X      ng[cidx] = image->green[cidx] & mask;
X      nb[cidx] = image->blue[cidx]  & mask;
X    }
X  else
X    for (cidx=0; cidx<nc; cidx++) {
X      nr[cidx] = image->red[cidx]   | mask;
X      ng[cidx] = image->green[cidx] | mask;
X      nb[cidx] = image->blue[cidx]  | mask;
X    }
X
X  /* now eliminate redundant colors */
X  for (cidx=0; cidx<nc; cidx++)
X    map[cidx] = cidx;
X  remapCount = 0;
X  for (cidx=0; cidx<nc; cidx++)
X    if (image->used[cidx])
X      for (ridx=cidx+1; ridx<nc; ridx++)
X        if (image->used[ridx]  &&
X            nr[cidx]==nr[ridx] &&
X            ng[cidx]==ng[ridx] &&
X            nb[cidx]==nb[ridx]) {
X          /* the colors match - remap this pixel to the one we're scanning with */
X          map[ridx] = cidx;
X          image->used[ridx] = FALSE;
X          remapCount++;
X        }
X
X  memcpy((char *)image->red,   (char *)nr, nc*sizeof(word));
X  memcpy((char *)image->green, (char *)ng, nc*sizeof(word));
X  memcpy((char *)image->blue,  (char *)nb, nc*sizeof(word));
X
X  /* remap redundant pixels in the image */
X  if (remapCount)
X    for (h=0; h<ximage->height; h++)
X      for (w=0; w<ximage->width; w++) {
X        p = XGetPixel(ximage, w, h);
X        if (p != map[p])
X          XPutPixel(ximage, w, h, map[p]);
X      }
X
X  if (verbose)
X    fprintf(stderr, "  %d colors remapped\n", remapCount, nc);
X  return remapCount;
}
X
X
X
X
X
/* Brighten or darken colors in the image by the given amount ('percent').
X * The amount is an integer that, if less than 100 will darken the image
X * and if greater than 100 will brighten the image.  After modifying
X * colors equivalent colors are merged (as in alterPlanes).  The number
X * of eliminated colors is returned.
X */
brightenColors(image, percent)
X  imageInfo *image;
X  int percent;
{
X  int nc, cidx, ridx, h, w;
X  long p;
X  XImage *ximage = image->ximage;
X  float  adjustment;
X  long map[MAX_CELLS];
X  int remapCount;
X  dw new;
X
X  if (ximage->depth <= 1)
X    return 0;
X
X  if (verbose) {
X    fprintf(stderr, "%s: adjusting intensity by %d...", programName, percent);
X    fflush(stderr);
X  }
X
X  adjustment = (float)percent / 100.0;
X  nc = image->numcells;
X  for (cidx=0; cidx<nc; cidx++) {
X    new = image->red[cidx] * adjustment;
X    if (new > (dw)0xFFFF) new = (dw)0xFFFF;
X    nr[cidx] = new;
X    new = image->green[cidx] * adjustment;
X    if (new > (dw)0xFFFF) new = (dw)0xFFFF;
X    ng[cidx] = new;
X    new = image->blue[cidx] * adjustment;
X    if (new > (dw)0xFFFF) new = (dw)0xFFFF;
X    nb[cidx] = new;
X  }
X
X  /* now eliminate redundant colors */
X  for (cidx=0; cidx<nc; cidx++)
X    map[cidx] = cidx;
X  remapCount = 0;
X  for (cidx=0; cidx<nc; cidx++)
X    if (image->used[cidx])
X      for (ridx=cidx+1; ridx<nc; ridx++)
X        if (image->used[ridx]  &&
X            nr[cidx]==nr[ridx] &&
X            ng[cidx]==ng[ridx] &&
X            nb[cidx]==nb[ridx]) {
X          map[ridx] = cidx;
X          image->used[ridx] = FALSE;
X          remapCount++;
X        }
X
X  memcpy((char *)image->red,   (char *)nr, nc*sizeof(word));
X  memcpy((char *)image->green, (char *)ng, nc*sizeof(word));
X  memcpy((char *)image->blue,  (char *)nb, nc*sizeof(word));
X
X  /* remap redundant pixels in the image */
X  if (remapCount)
X    for (h=0; h<ximage->height; h++)
X      for (w=0; w<ximage->width; w++) {
X        p = XGetPixel(ximage, w, h);
X        if (p != map[p])
X          XPutPixel(ximage, w, h, map[p]);
X      }
X
X
X  if (verbose)
X    fprintf(stderr, "  %d colors remapped\n", remapCount, nc);
X
X  return remapCount;
}
X
X
X
X
X
/* Reverse the colors in the image */
reverseColors(image)
X  imageInfo *image;
{
X  int nc, cidx;
X  long size, idx;
X  unsigned char *data;
SHAR_EOF
true || echo 'restore of process.hc failed'
fi
echo 'End of  part 2'
echo 'File process.hc is continued in part 3'
echo 3 > _shar_seq_.tmp
exit 0
-- 
---
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
