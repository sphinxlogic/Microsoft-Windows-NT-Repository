Newsgroups: comp.sources.x
Path: uunet!paladin.american.edu!darwin.sura.net!wupost!usc!sdd.hp.com!mips!msi!dcmartin
From: jef@netcom.com (Jef Poskanzer)
Subject: v18i018: Xsplinefun, Part01/01
Message-ID: <1992Jul14.151016.14450@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Date: Tue, 14 Jul 1992 15:10:16 GMT
Approved: dcmartin@msi.com
Lines: 1353

Submitted-by: jef@netcom.com (Jef Poskanzer)
Posting-number: Volume 18, Issue 18
Archive-name: xsplinefun/part01

Xsplinefun displays colorful moving splines in the X11 root window.
This is more impressive on a fast-displaying machine like an Indigo
or a SparcStation 2.

#!/bin/sh
# This is a shell archive (produced by shar 3.50)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 07/14/1992 15:06 UTC by dcmartin@fascet
# Source directory /home/fascet/dcmartin/csx/src/tmp
#
# existing files will NOT be overwritten unless -c is specified
#
#                                                                          
#                                                                          
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#    547 -rw-r--r-- Imakefile
#  10777 -rw-r--r-- Makefile.std
#    558 -rw-r--r-- README
#  17478 -rw-r--r-- xsplinefun.c
#   1878 -rw-r--r-- xsplinefun.man
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= Imakefile ==============
if test -f 'Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Imakefile' &&
# Copyright (C) 1992 by Jef Poskanzer
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted, provided
# that the above copyright notice appear in all copies and that both that
# copyright notice and this permission notice appear in supporting
# documentation.  This software is provided "as is" without express or
# implied warranty.
X
LOCAL_LIBRARIES =	$(XLIB)
DEPLIBS =		$(DEPXLIB)
SRCS =			xsplinefun.c
OBJS =			xsplinefun.o
X
ComplexProgramTarget(xsplinefun)
SHAR_EOF
chmod 0644 Imakefile ||
echo 'restore of Imakefile failed'
Wc_c="`wc -c < 'Imakefile'`"
test 547 -eq "$Wc_c" ||
	echo 'Imakefile: original size 547, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile.std ==============
if test -f 'Makefile.std' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile.std (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile.std (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile.std' &&
# Makefile generated by imake - do not edit!
# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
#
# The cpp used on this machine replaces all newlines and multiple tabs and
# spaces in a macro expansion with a single space.  Imake tries to compensate
# for this, but is not always successful.
#
X
# -------------------------------------------------------------------------
# Makefile generated from "Imake.tmpl" and </tmp/IIf.a07273>
# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
#
# Platform-specific parameters may be set in the appropriate <vendor>.cf
# configuration files.  Site-specific parameters should be set in the file
# site.def.  Full rebuilds are recommended if any parameters are changed.
#
# If your C preprocessor does not define any unique symbols, you will need
# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
# "make World" the first time).
#
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that need to come before
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
# -------------------------------------------------------------------------
# platform-specific configuration parameters - edit sun.cf to change
X
# platform:  $XConsortium: sun.cf,v 1.68 91/07/30 11:34:39 rws Exp $
X
# operating system:  SunOS 4.1.1
X
# $XConsortium: sunLib.rules,v 1.6 91/03/24 17:55:58 rws Exp $
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that go after
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X      PROJECTROOT = /usr/X11/R5
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
# -------------------------------------------------------------------------
# X Window System Build Parameters
# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
# -------------------------------------------------------------------------
# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/X11/R5/lib
X           BINDIR = /usr/X11/R5/bin
X          INCROOT = /usr/X11/R5/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/X11/R5/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
# $XConsortium: sunLib.tmpl,v 1.11 91/07/31 11:32:08 rws Exp $
X
SHLIBLDFLAGS = -assert pure-text
PICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
# -------------------------------------------------------------------------
# Imake rules for building libraries, programs, scripts, and data files
# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
# -------------------------------------------------------------------------
# start of Imakefile
X
# Copyright (C) 1992 by Jef Poskanzer
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose and without fee is hereby granted, provided
# that the above copyright notice appear in all copies and that both that
# copyright notice and this permission notice appear in supporting
# documentation.  This software is provided "as is" without express or
# implied warranty.
X
LOCAL_LIBRARIES =	$(XLIB)
DEPLIBS =		$(DEPXLIB)
SRCS =			xsplinefun.c
OBJS =			xsplinefun.o
X
X PROGRAM = xsplinefun
X
all:: xsplinefun
X
xsplinefun: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
saber_xsplinefun:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
osaber_xsplinefun:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
install:: xsplinefun
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  xsplinefun $(DESTDIR)$(BINDIR)
X
install.man:: xsplinefun.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) xsplinefun.man $(DESTDIR)$(MANDIR)/xsplinefun.$(MANSUFFIX)
X
depend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
lint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
lint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
clean::
X	$(RM) $(PROGRAM)
X
# -------------------------------------------------------------------------
# common rules for all Makefiles - do not edit
X
emptyrule::
X
clean::
X	$(RM_CMD) "#"*
X
Makefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
tags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
saber:
X	# load $(ALLDEFINES) $(SRCS)
X
osaber:
X	# load $(ALLDEFINES) $(OBJS)
X
# -------------------------------------------------------------------------
# empty rules for directories that do not have SUBDIRS - do not edit
X
install::
X	@echo "install in $(CURRENT_DIR) done"
X
install.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
Makefiles::
X
includes::
X
# -------------------------------------------------------------------------
# dependencies generated by makedepend
X
SHAR_EOF
chmod 0644 Makefile.std ||
echo 'restore of Makefile.std failed'
Wc_c="`wc -c < 'Makefile.std'`"
test 10777 -eq "$Wc_c" ||
	echo 'Makefile.std: original size 10777, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
X                           xsplinefun
X                     Distribution of 02may92
X                  Previous distribution NONE
X
XXsplinefun displays colorful moving splines in the X11 root window.
X
Files in this distribution:
X
X    README		this
X    Imakefile		guess
X    xsplinefun.c	source file
X    xsplinefun.man	manual entry
X
To compile: do an xmkmf, make depend, make.
X
Feedback is welcome - send bug reports, enhancements, checks, money orders,
gold bullion, drugs, etc. to the addresses below.
X
X    Jef Poskanzer
X    jef@netcom.com
X    jef@well.sf.ca.us
SHAR_EOF
chmod 0644 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 558 -eq "$Wc_c" ||
	echo 'README: original size 558, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xsplinefun.c ==============
if test -f 'xsplinefun.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xsplinefun.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xsplinefun.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xsplinefun.c' &&
/* xsplinefun.c - X11 version of spline fun #3
**
** Displays colorful moving splines in the X11 root window.
**
** Copyright (C) 1992 by Jef Poskanzer
**
** Permission to use, copy, modify, and distribute this software and its
** documentation for any purpose and without fee is hereby granted, provided
** that the above copyright notice appear in all copies and that both that
** copyright notice and this permission notice appear in supporting
** documentation.  This software is provided "as is" without express or
** implied warranty.
*/
X
#include <stdio.h>
#include <errno.h>
#include <malloc.h>
#include <signal.h>
#include <pwd.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/ioctl.h>
X
#if defined(SYSV) || defined(SVR4)
#include <string.h>
#define index strchr
#include <sys/termio.h>
#else /*SYSV*/
#include <strings.h>
#endif /*SYSV*/
X
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>
#include <X11/Xresource.h>
#define XTSTRINGDEFINES
#include <X11/StringDefs.h>
X
X
/* Definitions. */
X
#define X_CLASS "Xsplinefun"
X
#define DEFAULT_MAX_COLORS 256
#define DEFAULT_LOOPS_PER_SECOND 50
X
#define MIN_COLORS 4
#define INITIAL_LOOPS_PER_SLEEP 10
#define MIN_LOOPS_PER_SLEEP 1
#define INITIAL_SLEEP_USECS 100000
#define MIN_SLEEP_USECS 50000
X
#define POINTS 5
#define MAX_DELTA 3
#define MAX_COLOR_DELTA (3*256)
X
#define SPLINE_THRESH 5
X
X
/* Externals. */
X
extern char* getenv();
extern long random();
X
X
/* Forward routines. */
X
static void x_init();
static void x_alloc_colors();
static void x_cleanup();
static Window VirtualRootWindowOfScreen();
static void x_rdb_init();
static char* x_get_resource();
static int x_str_to_bool();
static void stealth();
static void main_loop();
static void sigcatch();
static void init_timing();
static void timing();
static void init_splines();
static void rotate_colormap();
static void new_color();
static void move_splines();
static void XDrawSpline();
X
X
/* Routines. */
X
static char* argv0;
static char* app_name;
static int forwards, backwards;
static int max_colors;
static int loops_per_second;
X
static int loops_per_sleep;
static int sleep_usecs;
X
void
main( argc, argv )
X    int argc;
X    char* argv[];
X    {
X    char* rval;
X    char* usage = "usage: %s [-display d] [-forwards|-backwards] [-maxcolors n] [-loops n] [-id]\n";
X
X    argv0 = argv[0];
X    app_name = "xsplinefun";
X    forwards = backwards = False;
X    max_colors = DEFAULT_MAX_COLORS;
X    loops_per_second = DEFAULT_LOOPS_PER_SECOND;
X    loops_per_sleep = INITIAL_LOOPS_PER_SLEEP;
X    sleep_usecs = INITIAL_SLEEP_USECS;
X
X    /* Parse args and initialize X stuff. */
X    x_init( &argc, argv );
X
X    /* Check usage. */
X    if ( argc != 1 )
X	{
X	(void) fprintf( stderr, usage, argv[0] );
X	exit( 1 );
X	}
X
X    /* Check rotation. */
X    rval = x_get_resource( "rotation", "Rotation" );
X    if ( rval != (char*) 0 )
X	if ( rval[0] == 'f' || rval[0] == 'F' )
X	    forwards = True;
X	else if ( rval[0] == 'b' || rval[0] == 'B' )
X	    backwards = True;
X
X    /* Check max colors. */
X    rval = x_get_resource( "maxcolors", "Maxcolors" );
X    if ( rval != (char*) 0 )
X	max_colors = atoi(rval);
X    x_alloc_colors();
X
X    /* Check loops. */
X    rval = x_get_resource( "loops", "Loops" );
X    if ( rval != (char*) 0 )
X	loops_per_second = atoi(rval);
X
X    /* Initialize the random number generator. */
X    srandom( (int) ( time( (long*) 0 ) ^ getpid() ) );
X
X    /* Initialize the splines. */
X    init_splines();
X
X    /* Fork, if necessary. */
X    rval = x_get_resource( "id", "Id" );
X    if ( rval != (char*) 0 )
X	if ( x_str_to_bool( rval ) )
X	    stealth();
X
X    /* Main loop. */
X    main_loop();
X    
X    /* Done. */
X    x_cleanup();
X    exit( 0 );
X    }
X
X
/* X stuff. */
X
static Display* display = (Display*) 0;
static int screennum;
static Screen* screen;
static Window root;
static int width, height;
static int depth;
static GC gc;
static Colormap cmap;
static int ncolors;
static unsigned long pixels[DEFAULT_MAX_COLORS];
X
static void
x_init( argcP, argv )
X    int* argcP;
X    char** argv;
X    {
X    char* display_name;
X    char* rval;
X    int i, d;
X
X    /* Scan args looking for -display. */
X    display_name = (char*) 0;
X    for ( i = 1; i + 1 < *argcP; ++i )
X	{
X	if ( strcmp( argv[i], "-display" ) == 0 ||
X	     strcmp( argv[i], "-displa" ) == 0 ||
X	     strcmp( argv[i], "-displ" ) == 0 ||
X	     strcmp( argv[i], "-disp" ) == 0 ||
X	     strcmp( argv[i], "-dis" ) == 0 ||
X	     strcmp( argv[i], "-di" ) == 0 ||
X	     strcmp( argv[i], "-d" ) == 0 )
X	    {
X	    display_name = argv[i + 1];
X	    for ( i = i + 2; i <= *argcP; ++i )
X		argv[i - 2] = argv[i];
X	    *argcP -= 2;
X	    break;
X	    }
X	}
X
X    display = XOpenDisplay( display_name );
X    if ( display == (Display*) 0 )
X	{
X	(void) fprintf(
X	    stderr, "%s: can't open display \"%s\"\n", argv0,
X	    XDisplayName( display_name ) );
X	exit( 1 );
X	}
X
X    screennum = DefaultScreen( display );
X    screen = ScreenOfDisplay( display, DefaultScreen( display ) );
X    root = VirtualRootWindowOfScreen( screen );
X    width = WidthOfScreen( screen );
X    height = HeightOfScreen( screen );
X    depth = DefaultDepthOfScreen( screen );
X    if ( depth <= 1 )
X	{
X	(void) fprintf(
X	    stderr, "%s: screen depth must be greater than 1\n", argv0 );
X	exit( 1 );
X	}
X    gc = XCreateGC( display, root, 0, (XGCValues*) 0 );
X    cmap = DefaultColormapOfScreen( screen );
X
X    x_rdb_init( argcP, argv );
X
X    rval = x_get_resource( XtNname, "Name" );
X    if ( rval != (char*) 0 )
X	app_name = rval;
X
X    rval = x_get_resource( "synchronous", "Synchronous" );
X    if ( rval != (char*) 0 )
X	if ( x_str_to_bool( rval ) )
X	    XSynchronize( display, True );
X    }
X
static void
x_alloc_colors()
X    {
X    for ( ncolors = max_colors; ncolors >= MIN_COLORS; --ncolors )
X	if ( XAllocColorCells(
X		display, cmap, False, (unsigned long*) 0, 0, pixels, ncolors ) )
X	    break;
X    if ( ncolors < MIN_COLORS )
X	{
X	(void) fprintf( stderr, "%s: can't allocate enough colors\n", argv0 );
X	exit( 1 );
X	}
X    if ( ncolors < max_colors )
X	(void) fprintf(
X	    stderr, "%s: only %d colors available\n", argv0, ncolors );
X    }
X
static void
x_cleanup()
X    {
X    XClearArea( display, root, 0, 0, width, height, True );
X    XFreeColors( display, cmap, pixels, ncolors, (unsigned long) 0 );
X    XFreeGC( display, gc );
X    XCloseDisplay( display );
X    }
X
X
/* From vroot.h by Andreas Stolcke. */
X
static Window
VirtualRootWindowOfScreen( screenP )
X    Screen* screenP;
X    {
X    static Window root = (Window) 0;
X    Display* dpy = DisplayOfScreen( screenP );
X    Atom __SWM_VROOT = None;
X    int i;
X    Window rootReturn, parentReturn;
X    Window* children;
X    unsigned int numChildren;
X
X    root = RootWindowOfScreen( screenP );
X
X    /* Go look for a virtual root. */
X    __SWM_VROOT = XInternAtom( dpy, "__SWM_VROOT", False );
X    if ( XQueryTree(
X	     dpy, root, &rootReturn, &parentReturn, &children,
X	     &numChildren ) )
X	{
X	for ( i = 0; i < numChildren; ++i )
X	    {
X	    Atom actual_type;
X	    int actual_format;
X	    unsigned long nitems, bytesafter;
X	    Window* newRoot = (Window*) 0;
X
X	    if ( XGetWindowProperty(
X		     dpy, children[i], __SWM_VROOT, 0, 1, False, XA_WINDOW,
X		     &actual_type, &actual_format, &nitems, &bytesafter,
X		     (unsigned char**) &newRoot ) == Success && newRoot )
X		{
X		root = *newRoot;
X		break;
X		}
X	    }
X	if ( children )
X	    XFree( (char*) children );
X	}
X
X    return root;
X    }
X
X
/* X resources stuff. */
X
static XrmDatabase rdb;
X
static XrmOptionDescRec x_options[] = {
X    { "-forwards",       "*rotation",       XrmoptionNoArg,  (caddr_t) "f" },
X    { "-backwards",      "*rotation",       XrmoptionNoArg,  (caddr_t) "b" },
X    { "-maxcolors",      "*maxcolors",      XrmoptionSepArg, (caddr_t) 0 },
X    { "-loops",          "*loops",          XrmoptionSepArg, (caddr_t) 0 },
X    { "-id",             "*id",             XrmoptionNoArg,  (caddr_t) "on" },
X    { "-name",           ".name",           XrmoptionSepArg, (caddr_t) 0 },
X    { "-synchronous",    "*synchronous",    XrmoptionNoArg,  (caddr_t) "on" },
X    { "-xrm",            (char*) 0,         XrmoptionResArg, (caddr_t) 0 },
X    };
X
static void
x_rdb_init( argcP, argv )
X    int* argcP;
X    char** argv;
X    {
X    char* resource_string;
X    char* xenv;
X    XrmDatabase xenv_rdb;
X
X    XrmInitialize();
X
X    /* Look for resource databases on server. */
X    resource_string = XResourceManagerString( display );
X    if ( resource_string != (char*) 0 )
X	rdb = XrmGetStringDatabase( resource_string );
X    else
X	{
X	/* No server databases, try ~/.Xdefaults */
X	char* cp;
X	char buf[500];
X
X	cp = getenv( "HOME" );
X	if ( cp != (char*) 0 )
X	    (void) strcpy( buf, cp );
X	else
X	    {
X	    struct passwd* pw;
X
X	    cp = getenv( "USER" );
X	    if ( cp != (char*) 0 )
X		pw = getpwnam( cp );
X	    else
X		pw = getpwuid( getuid() );
X	    if ( pw != (struct passwd*) 0 )
X		(void) strcpy( buf, pw->pw_dir );
X	    else
X		(void) strcpy( buf, "." );	/* best we can do */
X	    }
X	(void) strcat( buf, "/.Xdefaults" );
X	rdb = XrmGetFileDatabase( buf );
X	}
X
X    /* Merge in XENVIRONMENT, if any. */
X    xenv = getenv( "XENVIRONMENT" );
X    if ( xenv != (char*) 0 )
X	{
X	xenv_rdb = XrmGetFileDatabase( xenv );
X	XrmMergeDatabases( xenv_rdb, &rdb );
X	}
X
X    /* And add command line options. */
X    XrmParseCommand(
X	&rdb, x_options, sizeof(x_options) / sizeof(*x_options),
X	app_name, argcP, argv );
X    }
X
static char*
x_get_resource( name, class )
X    char* name;
X    char* class;
X    {
X    char rname[500], rclass[500];
X    char* type;
X    XrmValue value;
X
X    (void) sprintf( rname, "%s.%s", app_name, name );
X    (void) sprintf( rclass, "%s.%s", X_CLASS, class );
X    if ( XrmGetResource( rdb, rname, rclass, &type, &value ) == True )
X	if ( strcmp( type, XtRString ) == 0 )
X	    return (char*) value.addr;
X    return (char*) 0;
X    }
X
static int
x_str_to_bool( str )
X    char* str;
X    {
X    if ( strcmp( str, "True" ) == 0 ||
X         strcmp( str, "true" ) == 0 ||
X         strcmp( str, "Yes" ) == 0 ||
X         strcmp( str, "yes" ) == 0 ||
X         strcmp( str, "On" ) == 0 ||
X         strcmp( str, "on" ) == 0 ||
X         strcmp( str, "Si" ) == 0 ||
X         strcmp( str, "si" ) == 0 ||
X         strcmp( str, "Da" ) == 0 ||
X         strcmp( str, "da" ) == 0 ||
X         strcmp( str, "T" ) == 0 ||
X         strcmp( str, "t" ) == 0 ||
X         strcmp( str, "Y" ) == 0 ||
X         strcmp( str, "y" ) == 0 ||
X         strcmp( str, "1" ) == 0 )
X	return True;
X    return False;
X    }
X
X
/* Generic application stuff. */
X
static void
stealth()
X    {
X    int pid, tty;
X
X    pid = fork();
X    if ( pid < 0 )
X	{
X	perror( "fork" );
X	exit( 1 );
X	}
X    else if ( pid > 0 )
X	/* Parent just exits. */
X	exit( 0 );
X    (void) printf( "%d\n", getpid() );
X    (void) fflush( stdout );
X
X    /* Go stealth (ditch our controlling tty). */
X    tty = open( "/dev/tty", 0 );
X    if ( tty < 0 )
X	{
X	/* ENXIO means that there is no controlling terminal, so we don't
X	** have to detach anything.
X	*/
X        if ( errno != ENXIO )
X	    {
X	    (void) fprintf( stderr, "%s: ", argv0 );
X	    perror( "/dev/tty open" );
X	    exit( 1 );
X	    }
X	}
X    else
X	{
#ifdef TIOCNOTTY
X	if ( ioctl( tty, TIOCNOTTY, 0 ) < 0 )
X	    {
X	    (void) fprintf( stderr, "%s: ", argv0 );
X	    perror( "TIOCNOTTY ioctl" );
X	    exit( 1 );
X	    }
#endif /*TIOCNOTTY*/
X	(void) close( tty );
X	}
X    }
X
static int goflag;
static int loops;
X
static void
sigcatch()
X    {
X    goflag = 0;
X    }
X
static int then_loops;
static time_t then;
X
static void
init_timing()
X    {
X    then = time( (time_t*) 0 );
X    then_loops = 0;
X    }
X
static void
timing()
X    {
X    float ratio;
X    int t;
X    time_t now;
X
X    if ( sleep_usecs > 0 && loops_per_sleep > 0 &&
X	 loops % loops_per_sleep == 0 )
X	{
X	XFlush( display );
X	usleep( sleep_usecs );
X	if ( loops_per_second > 0 )
X	    {
X	    now = time( (time_t*) 0 );
X	    if ( now != then )
X		{
X		if ( then_loops != 0 )
X		    {
X		    ratio = (float) ( loops - then_loops ) /
X			    (float) loops_per_second;
X		    if ( ratio > 1.0 )
X			{
X			/* We're going too fast. */
X			t = loops_per_sleep / ratio;
X			if ( t >= MIN_LOOPS_PER_SLEEP )
X			    loops_per_sleep = t;
X			else
X			    sleep_usecs *= ratio;
X			}
X		    else if ( ratio < 1.0 )
X			{
X			/* We're going too slow. */
X			t = sleep_usecs * ratio;
X			if ( t >= MIN_SLEEP_USECS )
X			    sleep_usecs = t;
X			else
X			    {
X			    loops_per_sleep /= ratio;
X			    if ( loops_per_sleep > 3 * loops_per_second )
X				loops_per_sleep = 0;	/* give up */
X			    }
X			}
X		    }
X		then_loops = loops;
X		then = now;
X		}
X	    }
X	}
X    }
X
static void
main_loop()
X    {
X    /* Set up for signal catching. */
X    goflag = 1;
X    (void) signal( SIGHUP, sigcatch );
X    (void) signal( SIGINT, sigcatch );
X    (void) signal( SIGTERM, sigcatch );
X
X    /* Do it. */
X    for ( loops = 1; goflag; ++loops )
X	{
X	move_splines();
X	timing();
X	}
X    }
X
X
/* Spline-fun smarts. */
X
static int x[POINTS], y[POINTS], dx[POINTS], dy[POINTS];
static int nred, ngreen, nblue, dred, dgreen, dblue;
static int color;
static XColor xcolors[DEFAULT_MAX_COLORS];
X
static void
init_splines()
X    {
X    int i;
X
X    /* Initialize points. */
X    for ( i = 0; i < POINTS; ++i )
X	{
X	x[i] = random() % width;
X	y[i] = random() % height;
X	dx[i] = random() % ( MAX_DELTA * 2 ) - MAX_DELTA;
X	if ( dx[i] <= 0 ) --dx[i];
X	dy[i] = random() % ( MAX_DELTA * 2 ) - MAX_DELTA;
X	if ( dy[i] <= 0 ) --dy[i];
X	}
X
X    /* Initalize colors. */
X    for ( color = 0; color < ncolors; ++color )
X	{
X	xcolors[color].red = xcolors[color].green = xcolors[color].blue = 0;
X	xcolors[color].pixel = pixels[color];
X	xcolors[color].flags = DoRed|DoGreen|DoBlue;
X	}
X    color = 0;
X    nred = ngreen = nblue = 0;
X    dred = random() % ( MAX_COLOR_DELTA * 2 ) - MAX_COLOR_DELTA;
X    if ( dred <= 0 ) --dred;
X    dgreen = random() % ( MAX_COLOR_DELTA * 2 ) - MAX_COLOR_DELTA;
X    if ( dgreen <= 0 ) --dgreen;
X    dblue = random() % ( MAX_COLOR_DELTA * 2 ) - MAX_COLOR_DELTA;
X    if ( dblue <= 0 ) --dblue;
X    }
X
static void
rotate_colormap()
X    {
X    int t, i;
X
X    if ( forwards )
X	{
X	t = xcolors[0].pixel;
X	for ( i = 0; i < ncolors - 1; ++i )
X	    xcolors[i].pixel = xcolors[i + 1].pixel;
X	xcolors[ncolors - 1].pixel = t;
X	XStoreColors(display, cmap, xcolors, ncolors );
X	}
X    else if ( backwards )
X	{
X	t = xcolors[ncolors - 1].pixel;
X	for ( i = ncolors - 1; i > 0; --i )
X	    xcolors[i].pixel = xcolors[i - 1].pixel;
X	xcolors[0].pixel = t;
X	XStoreColors(display, cmap, xcolors, ncolors );
X	}
X    }
X
static void
new_color()
X    {
X    int t;
X
X    for ( ; ; )
X	{
X	t = (int) nred + dred;
X	if ( t >= 0 && t < 65536 ) break;
X	dred = random() % ( MAX_COLOR_DELTA * 2 ) - MAX_COLOR_DELTA;
X	if ( dred <= 0 ) --dred;
X	}
X    xcolors[color].red = nred = t;
X    for ( ; ; )
X	{
X	t = (int) ngreen + dgreen;
X	if ( t >= 0 && t < 65536 ) break;
X	dgreen = random() % ( MAX_COLOR_DELTA * 2 ) - MAX_COLOR_DELTA;
X	if ( dgreen <= 0 ) --dgreen;
X	}
X    xcolors[color].green = ngreen = t;
X    for ( ; ; )
X	{
X	t = (int) nblue + dblue;
X	if ( t >= 0 && t < 65536 ) break;
X	dblue = random() % ( MAX_COLOR_DELTA * 2 ) - MAX_COLOR_DELTA;
X	if ( dblue <= 0 ) --dblue;
X	}
X    xcolors[color].blue = nblue = t;
X    XStoreColor(display, cmap, &(xcolors[color]) );
X    XSetForeground( display, gc, xcolors[color].pixel );
X    if ( ++color >= ncolors ) color -= ncolors;
X    }
X
static void
move_splines()
X    {
X    int i, t, px, py, zx, zy, nx, ny;
X
X    /* Rotate colormap if necessary. */
X    rotate_colormap();
X
X    /* Choose new color. */
X    new_color();
X
X    /* Backwards rotation requires two new colors each loop. */
X    if ( backwards )
X	new_color();
X
X    /* Move the points. */
X    for ( i = 0; i < POINTS; i++ )
X	{
X	for ( ; ; )
X	    {
X	    t = x[i] + dx[i];
X	    if ( t >= 0 && t < width ) break;
X	    dx[i] = random() % ( MAX_DELTA * 2 ) - MAX_DELTA;
X	    if ( dx[i] <= 0 ) --dx[i];
X	    }
X	x[i] = t;
X	for ( ; ; )
X	    {
X	    t = y[i] + dy[i];
X	    if ( t >= 0 && t < height ) break;
X	    dy[i] = random() % ( MAX_DELTA * 2 ) - MAX_DELTA;
X	    if ( dy[i] <= 0 ) --dy[i];
X	    }
X	y[i] = t;
X	}
X
X    /* Draw the figure. */
X    px = zx = ( x[0] + x[POINTS-1] ) / 2;
X    py = zy = ( y[0] + y[POINTS-1] ) / 2;
X    for ( i = 0; i < POINTS-1; ++i )
X	{
X	nx = ( x[i+1] + x[i] ) / 2;
X	ny = ( y[i+1] + y[i] ) / 2;
X	XDrawSpline( display, root, gc, px, py, x[i], y[i], nx, ny );
X	px = nx;
X	py = ny;
X	}
X    XDrawSpline(
X	display, root, gc, px, py, x[POINTS-1], y[POINTS-1], zx, zy );
X    }
X
X
/* X spline routine. */
X
#define abs(x) ((x) < 0 ? -(x) : (x))
X
static void
XXDrawSpline( display, d, gc, x0, y0, x1, y1, x2, y2 )
Display* display;
Drawable d;
GC gc;
int x0, y0, x1, y1, x2, y2;
X    {
X    register int xa, ya, xb, yb, xc, yc, xp, yp;
X
X    xa = ( x0 + x1 ) / 2;
X    ya = ( y0 + y1 ) / 2;
X    xc = ( x1 + x2 ) / 2;
X    yc = ( y1 + y2 ) / 2;
X    xb = ( xa + xc ) / 2;
X    yb = ( ya + yc ) / 2;
X
X    xp = ( x0 + xb ) / 2;
X    yp = ( y0 + yb ) / 2;
X    if ( abs( xa - xp ) + abs( ya - yp ) > SPLINE_THRESH )
X	XDrawSpline( display, d, gc, x0, y0, xa, ya, xb, yb );
X    else
X	XDrawLine( display, d, gc, x0, y0, xb, yb );
X
X    xp = ( x2 + xb ) / 2;
X    yp = ( y2 + yb ) / 2;
X    if ( abs( xc - xp ) + abs( yc - yp ) > SPLINE_THRESH )
X	XDrawSpline( display, d, gc, xb, yb, xc, yc, x2, y2 );
X    else
X	XDrawLine( display, d, gc, xb, yb, x2, y2 );
X    }
X
X
#ifdef SYSV
X
/* Most SysV's don't have a usleep.  Sone of them have select. */
X
usleep( usecs )
int usecs;
X    {
X    struct timeval timeout;
X
X    timeout.tv_sec = usecs / 1000000;
X    timeout.tv_usec = usecs % 1000000;
X    select( 0, 0, 0, 0, &timeout );
X    }
X
#endif /*SYSV*/
SHAR_EOF
chmod 0644 xsplinefun.c ||
echo 'restore of xsplinefun.c failed'
Wc_c="`wc -c < 'xsplinefun.c'`"
test 17478 -eq "$Wc_c" ||
	echo 'xsplinefun.c: original size 17478, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xsplinefun.man ==============
if test -f 'xsplinefun.man' -a X"$1" != X"-c"; then
	echo 'x - skipping xsplinefun.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xsplinefun.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xsplinefun.man' &&
.TH xsplinefun 1 "2 May 1992"
.SH NAME
xsplinefun - display colorful moving splines in the X11 root window
.SH SYNOPSIS
.B xsplinefun
.RB [ -display
.IR d ]
.RB [ -forwards | -backwards ]
.RB [ -maxcolors
.IR n ]
.RB [ -loops
.IR n ]
.RB [ -id ]
.SH DESCRIPTION
.PP
.I Xsplinefun
displays colorful moving splines in the root window.
.SH OPTIONS
.PP
.I Xsplinefun
accepts all the usual X flags and resources, such as
.BR -display ,
.BR -sync ,
and
.BR -xrm .
.PP
.I Xsplinefun
also accepts the following flags:
.TP
.B -forwards
Rotates the colormap forwards.
XX resource:
.BR "rotation: f" .
.TP
.B -backwards
Rotates the colormap backwards.
XX resource:
.BR "rotation: b" .
.TP
.B -maxcolors
Specifies the maximum number of colormap entries that will be used.
If this many are not available, fewer will be used, but if more than
this many are available they will be left free for other applications.
XX resource:
.BR maxcolors .
Default: 256.
.TP
.B -loops
Specifies the desired number of loops per second.
.I Xsplinefun
attempts to maintain this speed by adaptively varying the duration
and freqency of sleeps.
If your X server is not capable of the requested speed, it will do the
best it can.
XX resource:
.BR loops .
Default: 50.
.TP
.B -id
Forks a background process and prints the process-id to stdout.
Useful if you want to make a menu command to kill
.IR xsplinefun .
XX resource:
.BR id .
Default: off.
.SH "SEE ALSO"
.IR xsetroot (1)
.SH AUTHOR
Copyright (C) 1992 by Jef Poskanzer
.\" Permission to use, copy, modify, and distribute this software and its
.\" documentation for any purpose and without fee is hereby granted, provided
.\" that the above copyright notice appear in all copies and that both that
.\" copyright notice and this permission notice appear in supporting
.\" documentation.  This software is provided "as is" without express or
.\" implied warranty.
SHAR_EOF
chmod 0644 xsplinefun.man ||
echo 'restore of xsplinefun.man failed'
Wc_c="`wc -c < 'xsplinefun.man'`"
test 1878 -eq "$Wc_c" ||
	echo 'xsplinefun.man: original size 1878, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
exit 0
-- 
--
mail: dcmartin@msi.com			Senior Systems Scientist
uucp: uunet!dcmartin			Molecular Simulations, Inc.
at&t: 408/522-9236			796 N. Pastoria Avenue
