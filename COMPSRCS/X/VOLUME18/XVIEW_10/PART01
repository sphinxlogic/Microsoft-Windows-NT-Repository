Path: uunet!ogicse!uwm.edu!caen!sdd.hp.com!mips!msi!dcmartin
From: jung@dia.informatik.uni-stuttgart.de (Norbert Jung)
Newsgroups: comp.sources.x
Subject: v18i057: xvier v1.0 - cute GO'ish game, Part01/02
Message-ID: <csx-18i057-xview-1.0@uunet.UU.NET>
Date: 23 Jul 92 14:16:33 GMT
Article-I.D.: uunet.csx-18i057-xview-1.0
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1800
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: Norbert Jung <jung@dia.informatik.uni-stuttgart.de>
Posting-number: Volume 18, Issue 57
Archive-name: xview-1.0/part01

xvier is a simple game where you and your opponent alternately throw
stones into free columns. The stones pile up in the columns, and the
goal is to get four stones in a row, in a column or diagonally. The
game compiles without modifications at least on

	Sun Sun4		SunOS 4.0, 4.1.1
	Sun Sun3/60		SunOS 4.0
	IBM RS6000		AIX 3.1
	HP 9000/720		HP-UX 8.05
	HP 9000/350		HP-UX 8.00
	DEC VS3100		Ultrix-32 V3.1
	DEC DS5400		Ultrix 4.2
	Sequent Symmetry	Dynix 3.0.17.9

#!/bin/sh
# This is a shell archive (produced by shar 3.50)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 07/23/1992 14:14 UTC by dcmartin@fascet
# Source directory /home/fascet/dcmartin/csx/src/tmp/xvier-1.0
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#    901 -rw-r--r-- Imakefile
#   1251 -rw-r--r-- Makefile.std
#   1502 -rw-r--r-- README
#     42 -rw-r--r-- patchlevel.h
#    322 -rw-r--r-- qdown.xbm
#    290 -rw-r--r-- qdownm.xbm
#    322 -rw-r--r-- qleft.xbm
#    290 -rw-r--r-- qleftm.xbm
#    327 -rw-r--r-- qright.xbm
#    293 -rw-r--r-- qrightm.xbm
#    312 -rw-r--r-- qup.xbm
#    284 -rw-r--r-- qupm.xbm
#  17343 -rw-r--r-- vier.c
#    307 -rw-r--r-- vier.h
#   2741 -rw-r--r-- vierinit.c
#  39330 -rw-r--r-- xvier.c
#    149 -rw-r--r-- xvier.h
#   2486 -rw-r--r-- xvier.man
#  11332 -rw-r--r-- Makefile
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= Imakefile ==============
if test -f 'Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Imakefile' &&
# I've seen window managers which couldn't handle aspect ratio hints.
# Uncomment if you have resize problems.
#XVIER_ASPECT	= -DXVIER_WM_ASPECT_BUG
X
# Some systems don't provide FD_SET #define's. HP 9000 and IBM RS6000
# are handled in xvier.h, but on other systems you can uncomment this.
#NO_FD_SET = -DNO_FD_SET
X
# If "select" is missing, but you have "poll", try this:
#NO_SELECT = -DNO_SELECT
X
# And if "getdtablesize" is missing, use the following:
#NO_GETDTABSIZE = -DNO_GETDTABSIZE
X
PROGNAME	= $(LIBDIR)$(PATHSEP)xvier_prog
DEFINES		= $(XVIER_ASPECT) $(NO_FD_SET) $(NO_SELECT) \
X			$(NO_GETDTABSIZE) -DPROGNAME=\"$(PROGNAME)\"
X
PROGRAMS	= xvier xvier_prog
X
SRCS1		= xvier.c
OBJS1		= xvier.o
SRCS2		= vierinit.c vier.c
OBJS2		= vierinit.o vier.o
X
ComplexProgramTarget_1(xvier, $(XLIB), /**/)
NormalProgramTarget(xvier_prog, $(OBJS2), /**/, /**/, /**/)
X
InstallProgram(xvier_prog, $(PROGNAME))
SHAR_EOF
chmod 0644 Imakefile ||
echo 'restore of Imakefile failed'
Wc_c="`wc -c < 'Imakefile'`"
test 901 -eq "$Wc_c" ||
	echo 'Imakefile: original size 901, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile.std ==============
if test -f 'Makefile.std' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile.std (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile.std (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile.std' &&
# I've seen window managers which couldn't handle aspect ratio hints.
# Uncomment if you have resize problems.
#XVIER_ASPECT = -DXVIER_WM_ASPECT_BUG
X
# Some systems don't provide FD_SET #define's. HP 9000 and IBM RS6000
# are handled in xvier.h, but on other systems you can uncomment this.
#NO_FD_SET = -DNO_FD_SET
X
# If "select" is missing, but you have "poll", try this:
#NO_SELECT = -DNO_SELECT
X
# And if "getdtablesize" is missing, use the following:
#NO_GETDTABSIZE = -DNO_GETDTABSIZE
X
CFLAGS = -O $(XVIER_ASPECT) $(NO_FD_SET) $(NO_SELECT) $(NO_GETDTABSIZE)
XX11LIB = -lX11
DESTDIR = /usr/local/bin
PROGDESTDIR = /usr/local/lib
PROGDEST = -DPROGNAME=\"$(PROGDESTDIR)/xvier_prog\"
MANDESTDIR = /usr/local/man
MANSECT = 6
X
all:	xvier xvier_prog
X
xvier:	xvier.c xvier.h qdown.xbm qleft.xbm qright.xbm qup.xbm\
X		qdownm.xbm qleftm.xbm qrightm.xbm qupm.xbm patchlevel.h
X	$(CC) -o xvier $(CFLAGS) $(PROGDEST) xvier.c $(X11LIB)
X
xvier_prog:	vier.o vierinit.o
X	$(CC) -o xvier_prog vier.o vierinit.o
X
vier.o:     vier.h vier.c xvier.h
vierinit.o: vier.h vierinit.c xvier.h
X
install: all xvier.man
X	cp xvier_prog $(PROGDESTDIR)
X	cp xvier $(DESTDIR)
X	cp xvier.man $(MANDESTDIR)/man$(MANSECT)/xvier.$(MANSECT)
X
clean::
X	-rm *.o *~ xvier vier core xvier_prog
SHAR_EOF
chmod 0644 Makefile.std ||
echo 'restore of Makefile.std failed'
Wc_c="`wc -c < 'Makefile.std'`"
test 1251 -eq "$Wc_c" ||
	echo 'Makefile.std: original size 1251, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
xvier is a simple game where you and your opponent alternately throw
stones into free columns. The stones pile up in the columns, and the
goal is to get four stones in a row, in a column or diagonally. The
game compiles without modifications at least on
X
X	Sun Sun4		SunOS 4.0, 4.1.1
X	Sun Sun3/60		SunOS 4.0
X	IBM RS6000		AIX 3.1
X	HP 9000/720		HP-UX 8.05
X	HP 9000/350		HP-UX 8.00
X	DEC VS3100		Ultrix-32 V3.1
X	DEC DS5400		Ultrix 4.2
X	Sequent Symmetry	Dynix 3.0.17.9
X
To install xvier:
X
1. If you use Makefile.std, copy it to Makefile and choose locations
X   for the X11-binary (default: /usr/local/bin), the game program
X   (default: /usr/local/lib), and the manual page (default:
X   /usr/local/man/man6).
X   If you use imake, type "xmkmf" and "make depend".
X
2. Type "make".
X
3. Test the game with "./xvier -prog ./xvier_prog"
X
4. If it works, type "make install" (and "make install.man" with
X   imake).
X
If you have problems with the compilation, look at the comments in
Makefile.std or Imakefile.
X
The game program uses a simple search tree, and the levels correspond
to the depth of this tree. Thus the higher levels are quite slow, but
normally I don't need them to get a good opponent ;-)
It's interesting that level 1 seems to be weaker than level 0.
X
You may use, copy, modify, and distribute this software and its
documentation for any purpose and without fee. It is provided "as is"
without any express or implied warranty.
X
Have fun!
X
X	Norbert Jung
X	Email: jung@dia.informatik.uni-stuttgart.de
SHAR_EOF
chmod 0644 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 1502 -eq "$Wc_c" ||
	echo 'README: original size 1502, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= patchlevel.h ==============
if test -f 'patchlevel.h' -a X"$1" != X"-c"; then
	echo 'x - skipping patchlevel.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting patchlevel.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'patchlevel.h' &&
#define XVIER_VERSION "xvier Version 1.0"
SHAR_EOF
chmod 0644 patchlevel.h ||
echo 'restore of patchlevel.h failed'
Wc_c="`wc -c < 'patchlevel.h'`"
test 42 -eq "$Wc_c" ||
	echo 'patchlevel.h: original size 42, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= qdown.xbm ==============
if test -f 'qdown.xbm' -a X"$1" != X"-c"; then
	echo 'x - skipping qdown.xbm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting qdown.xbm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'qdown.xbm' &&
#define qdown_width 16
#define qdown_height 16
#define qdown_x_hot 8
#define qdown_y_hot 8
static char qdown_bits[] = {
X   0x00, 0x00, 0x80, 0x01, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01,
X   0x80, 0x01, 0x80, 0x01, 0xc0, 0x00, 0x60, 0x00, 0x30, 0x18, 0x30, 0x18,
X   0x30, 0x18, 0x60, 0x0c, 0xc0, 0x07, 0x00, 0x00};
SHAR_EOF
chmod 0644 qdown.xbm ||
echo 'restore of qdown.xbm failed'
Wc_c="`wc -c < 'qdown.xbm'`"
test 322 -eq "$Wc_c" ||
	echo 'qdown.xbm: original size 322, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= qdownm.xbm ==============
if test -f 'qdownm.xbm' -a X"$1" != X"-c"; then
	echo 'x - skipping qdownm.xbm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting qdownm.xbm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'qdownm.xbm' &&
#define qdownmask_width 16
#define qdownmask_height 16
static char qdownmask_bits[] = {
X   0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03,
X   0xc0, 0x03, 0xe0, 0x03, 0xf0, 0x03, 0xf8, 0x3d, 0xf8, 0x3c, 0x78, 0x3c,
X   0xf8, 0x3e, 0xf8, 0x3f, 0xf0, 0x1f, 0xe0, 0x0f};
SHAR_EOF
chmod 0644 qdownm.xbm ||
echo 'restore of qdownm.xbm failed'
Wc_c="`wc -c < 'qdownm.xbm'`"
test 290 -eq "$Wc_c" ||
	echo 'qdownm.xbm: original size 290, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= qleft.xbm ==============
if test -f 'qleft.xbm' -a X"$1" != X"-c"; then
	echo 'x - skipping qleft.xbm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting qleft.xbm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'qleft.xbm' &&
#define qleft_width 16
#define qleft_height 16
#define qleft_x_hot 7
#define qleft_y_hot 8
static char qleft_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x7c, 0x00,
X   0xc6, 0x00, 0x82, 0x67, 0x02, 0x67, 0x02, 0x00, 0x06, 0x00, 0x3c, 0x00,
X   0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 qleft.xbm ||
echo 'restore of qleft.xbm failed'
Wc_c="`wc -c < 'qleft.xbm'`"
test 322 -eq "$Wc_c" ||
	echo 'qleft.xbm: original size 322, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= qleftm.xbm ==============
if test -f 'qleftm.xbm' -a X"$1" != X"-c"; then
	echo 'x - skipping qleftm.xbm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting qleftm.xbm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'qleftm.xbm' &&
#define qleftmask_width 16
#define qleftmask_height 16
static char qleftmask_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0xfe, 0x00, 0xff, 0x01,
X   0xff, 0xff, 0xef, 0xff, 0xc7, 0xff, 0x8f, 0xff, 0x7f, 0x00, 0x7f, 0x00,
X   0x7e, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 qleftm.xbm ||
echo 'restore of qleftm.xbm failed'
Wc_c="`wc -c < 'qleftm.xbm'`"
test 290 -eq "$Wc_c" ||
	echo 'qleftm.xbm: original size 290, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= qright.xbm ==============
if test -f 'qright.xbm' -a X"$1" != X"-c"; then
	echo 'x - skipping qright.xbm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting qright.xbm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'qright.xbm' &&
#define qright_width 16
#define qright_height 16
#define qright_x_hot 8
#define qright_y_hot 7
static char qright_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x3c, 0x00, 0x60,
X   0x00, 0x40, 0xe6, 0x40, 0xe6, 0x41, 0x00, 0x63, 0x00, 0x3e, 0x00, 0x1c,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 qright.xbm ||
echo 'restore of qright.xbm failed'
Wc_c="`wc -c < 'qright.xbm'`"
test 327 -eq "$Wc_c" ||
	echo 'qright.xbm: original size 327, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= qrightm.xbm ==============
if test -f 'qrightm.xbm' -a X"$1" != X"-c"; then
	echo 'x - skipping qrightm.xbm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting qrightm.xbm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'qrightm.xbm' &&
#define qrightmask_width 16
#define qrightmask_height 16
static char qrightmask_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x7e, 0x00, 0xfe, 0x00, 0xfe,
X   0xff, 0xf1, 0xff, 0xe3, 0xff, 0xf7, 0xff, 0xff, 0x80, 0xff, 0x00, 0x7f,
X   0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 qrightm.xbm ||
echo 'restore of qrightm.xbm failed'
Wc_c="`wc -c < 'qrightm.xbm'`"
test 293 -eq "$Wc_c" ||
	echo 'qrightm.xbm: original size 293, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= qup.xbm ==============
if test -f 'qup.xbm' -a X"$1" != X"-c"; then
	echo 'x - skipping qup.xbm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting qup.xbm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'qup.xbm' &&
#define qup_width 16
#define qup_height 16
#define qup_x_hot 7
#define qup_y_hot 7
static char qup_bits[] = {
X   0x00, 0x00, 0xe0, 0x03, 0x30, 0x06, 0x18, 0x0c, 0x18, 0x0c, 0x18, 0x0c,
X   0x00, 0x06, 0x00, 0x03, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x00, 0x00,
X   0x00, 0x00, 0x80, 0x01, 0x80, 0x01, 0x00, 0x00};
SHAR_EOF
chmod 0644 qup.xbm ||
echo 'restore of qup.xbm failed'
Wc_c="`wc -c < 'qup.xbm'`"
test 312 -eq "$Wc_c" ||
	echo 'qup.xbm: original size 312, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= qupm.xbm ==============
if test -f 'qupm.xbm' -a X"$1" != X"-c"; then
	echo 'x - skipping qupm.xbm (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting qupm.xbm (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'qupm.xbm' &&
#define qupmask_width 16
#define qupmask_height 16
static char qupmask_bits[] = {
X   0xf0, 0x07, 0xf8, 0x0f, 0xfc, 0x1f, 0x7c, 0x1f, 0x3c, 0x1e, 0x3c, 0x1f,
X   0xbc, 0x1f, 0xc0, 0x0f, 0xc0, 0x07, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03,
X   0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03, 0xc0, 0x03};
SHAR_EOF
chmod 0644 qupm.xbm ||
echo 'restore of qupm.xbm failed'
Wc_c="`wc -c < 'qupm.xbm'`"
test 284 -eq "$Wc_c" ||
	echo 'qupm.xbm: original size 284, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= vier.c ==============
if test -f 'vier.c' -a X"$1" != X"-c"; then
	echo 'x - skipping vier.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting vier.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'vier.c' &&
#include <stdio.h>
#include <sys/types.h>
#include <sys/time.h>
X
time_t time();
X
#include "vier.h"
#include "xvier.h"
X
int rows, columns, vnum;
int row_col, row_1_col, row_2_col;
int *brett, *weiss, *schwarz, **freip, **doublesp;
int frei[MAXRC], reihenfolge[MAXRC], doubles[MAXRC];
int (*pu)[4];
int *_p_h_, **pp;
struct oldv *stack, *sp, **zugstack;
int bewertung = 0;
X
int zugstackp = 0, level = 2;
X
#define WEISS    1
#define SCHWARZ  2
#define W_WINS   4
#define S_WINS   8
#define USELESS 16
X
char read_char(ch)
char *ch;
{
X  if (read(0, ch, 1) < 1) {
X    perror("xvier_prog read failed");
X    exit(1);
X  }
X  return *ch;
}
X
void write_char(ch)
char ch;
{
X  if (write(1, &ch, 1) < 1) {
X    perror("xvier_prog write failed");
X    exit(1);
X  }
}
X
void w_test(pos)
int pos;
{
X  register int *p, j;
X  int oben;
X
X  /* leere Position suchen */
X  for (p = pu[pos]; brett[*p] & (WEISS | SCHWARZ); p++);
X  if (brett[j = *p] & (W_WINS | USELESS))
X    return;
X  sp -> pos = brett + j;
X  sp++ -> value = brett[j];
X  brett[j] |= W_WINS;
X  if (*doublesp[j] == SCHWARZ &&
X      j > *freip[j] &&
X      j < row_1_col &&
X      !(brett[j+columns] & USELESS)) {
X    sp -> pos = doublesp[j];
X    sp++ -> value = SCHWARZ;
X    *doublesp[j] = 0;
X  }
X  if (!*doublesp[j] &&
X      ((j > *freip[j] + columns &&
X	(brett[(oben = j) - columns] & W_WINS)) ||
X       (j > *freip[j] && j < row_1_col &&
X	(brett[oben = j + columns] & W_WINS)))) {
X    register int k;
X
X    for (k = *freip[j]; k < oben; k += columns)
X      if (brett[k] & S_WINS)
X	goto no_double;
X    sp -> pos = doublesp[j];
X    sp++ -> value = 0;
X    *doublesp[j] = WEISS;
X  }
X no_double:
X  if (j < row_1_col &&
X      ((brett[oben = j] & S_WINS) ||
X       (j > *freip[j] && (brett[j - columns] & W_WINS)) ||
X       (j < row_2_col &&
X	(brett[oben = j + columns] & W_WINS))))
X    for (j = oben + columns;
X	 j < row_col && !(brett[j] & USELESS);
X	 j += columns) {
X      register int h1, h2;
X
X      /* Vierer darueber sind nutzlos */
X      sp -> pos = brett + j;
X      sp++ -> value = brett[j];
X      brett[j] |= USELESS;
X      p = pp[j];
X      while ((h1 = *(p++)) >= 0) {
X	if ((h2 = weiss[h1]) >= 0) {
X	  sp -> pos = &weiss[h1];
X	  sp++ -> value = h2;
X	  weiss[h1] = -1;
X	  bewertung -= h2;
X	}
X	if ((h2 = schwarz[h1]) >= 0) {
X	  sp -> pos = &schwarz[h1];
X	  sp++ -> value = h2;
X	  schwarz[h1] = -1;
X	  bewertung += h2;
X	}
X      }
X    }
}
X 
void s_test(pos)
int pos;
{
X  register int *p, j;
X  int oben;
X
X  /* leere Position suchen */
X  for (p = pu[pos]; brett[*p] & (WEISS | SCHWARZ); p++);
X  if (brett[j = *p] & (S_WINS | USELESS))
X    return;
X  sp -> pos = brett + j;
X  sp++ -> value = brett[j];
X  brett[j] |= S_WINS;
X  if (*doublesp[j] == WEISS &&
X      j > *freip[j] &&
X      j < row_1_col &&
X      !(brett[j+columns] & USELESS)) {
X    sp -> pos = doublesp[j];
X    sp++ -> value = WEISS;
X    *doublesp[j] = 0;
X  }
X  if (!*doublesp[j] &&
X      ((j > *freip[j] + columns &&
X	(brett[(oben = j) - columns] & S_WINS)) ||
X       (j > *freip[j] && j < row_1_col &&
X	(brett[oben = j + columns] & S_WINS)))) {
X    register int k;
X
X    for (k = *freip[j]; k < oben; k += columns)
X      if (brett[k] & W_WINS)
X	goto no_double;
X    sp -> pos = doublesp[j];
X    sp++ -> value = 0;
X    *doublesp[j] = SCHWARZ;
X  }
X no_double:
X  if (j < row_1_col &&
X      ((brett[oben = j] & W_WINS) ||
X       (j > *freip[j] && (brett[j - columns] & S_WINS)) ||
X       (j < row_2_col &&
X	(brett[oben = j + columns] & S_WINS))))
X    for (j = oben + columns;
X	 j < row_col && !(brett[j] & USELESS);
X	 j += columns) {
X      register int h1, h2;
X
X      /* Vierer darueber sind nutzlos */
X      sp -> pos = brett + j;
X      sp++ -> value = brett[j];
X      brett[j] |= USELESS;
X      p = pp[j];
X      while ((h1 = *(p++)) >= 0) {
X	if ((h2 = weiss[h1]) >= 0) {
X	  sp -> pos = &weiss[h1];
X	  sp++ -> value = h2;
X	  weiss[h1] = -1;
X	  bewertung -= h2;
X	}
X	if ((h2 = schwarz[h1]) >= 0) {
X	  sp -> pos = &schwarz[h1];
X	  sp++ -> value = h2;
X	  schwarz[h1] = -1;
X	  bewertung += h2;
X	}
X      }
X    }
}
X
int w_zugzwang(remain)
int remain;
{
X  register int i, pos, poslev = 7, p_s_p = 0;
X  int p_stack[MAXRC];
X
X  for (i = 0; i < columns; i++) {
X    register int f = frei[i];
X
X    if (f < row_col) {
X      if (brett[f] & W_WINS)
X	return 8 + 8 * remain;
X      if (brett[f] & S_WINS) {
X	pos = i;
X	poslev = 1;
X      } else if (poslev > 2) {
X	if (doubles[i] == WEISS) {
X	  pos = i;
X	  poslev = 2;
X	} else if (poslev > 3) {
X	  if (f >= row_1_col ||
X	      ((brett[f + columns] & (W_WINS | S_WINS)) == 0 &&
X	       !doubles[i])) {
X	    pos = i;
X	    poslev = 3;
X	  } else if (poslev > 4) {
X	    if ((brett[f + columns] & (W_WINS | S_WINS)) == 0) {
X	      pos = i;
X	      poslev = 4;
X	    } else if ((brett[f + columns] & S_WINS) == 0) {
X	      p_stack[p_s_p++] = pos = i;
X	      poslev = 5;
X	    } else if (poslev > 6) {
X	      pos = i;
X	      poslev = 6;
X	    }
X	  }
X	}
X      }
X    }
X  }
X  if (poslev == 7)
X    return 0;
X  if (poslev == 5 && p_s_p > 1) {
X    int m;
X
X    frei[p_stack[0]] += columns;
X    m = s_zugzwang(remain-1);
X    frei[p_stack[0]] -= columns;
X    for (i = 1; i < p_s_p; i++) {
X      register int tmp;
X
X      frei[p_stack[i]] += columns;
X      if ((tmp = s_zugzwang(remain-1)) > m)
X	m = tmp;
X      frei[p_stack[i]] -= columns;
X    }
X    return m;
X  } else {
X    frei[pos] += columns;
X    i = s_zugzwang(remain-1);
X    frei[pos] -= columns;
X    return i;
X  }
}
X
int s_zugzwang(remain)
int remain;
{
X  register int i, pos, poslev = 7, p_s_p = 0;
X  int p_stack[MAXRC];
X
X  for (i = 0; i < columns; i++) {
X    register int f = frei[i];
X
X    if (f < row_col) {
X      if (brett[f] & S_WINS)
X	return -8 - 8 * remain;
X      if (brett[f] & W_WINS) {
X	pos = i;
X	poslev = 1;
X      } else if (poslev > 2) {
X	if (doubles[i] == SCHWARZ) {
X	  pos = i;
X	  poslev = 2;
X	} else if (poslev > 3) {
X	  if (f >= row_1_col ||
X	      ((brett[f + columns] & (W_WINS | S_WINS)) == 0 &&
X	       !doubles[i])) {
X	    pos = i;
X	    poslev = 3;
X	  } else if (poslev > 4) {
X	    if ((brett[f + columns] & (W_WINS | S_WINS)) == 0) {
X	      pos = i;
X	      poslev = 4;
X	    } else if ((brett[f + columns] & W_WINS) == 0) {
X	      p_stack[p_s_p++] = pos = i;
X	      poslev = 5;
X	    } else if (poslev > 6) {
X	      pos = i;
X	      poslev = 6;
X	    }
X	  }
X	}
X      }
X    }
X  }
X  if (poslev == 7)
X    return 0;
X  if (poslev == 5 && p_s_p > 1) {
X    int m;
X
X    frei[p_stack[0]] += columns;
X    m = w_zugzwang(remain-1);
X    frei[p_stack[0]] -= columns;
X    for (i = 1; i < p_s_p; i++) {
X      register int tmp;
X
X      frei[p_stack[i]] += columns;
X      if ((tmp = w_zugzwang(remain-1)) < m)
X	m = tmp;
X      frei[p_stack[i]] -= columns;
X    }
X    return m;
X  } else {
X    frei[pos] += columns;
X    i = w_zugzwang(remain-1);
X    frei[pos] -= columns;
X    return i;
X  }
}
X
int comp_weiss(pos, lev, limit)
int pos, lev, limit;
{
X  register int  h1, h2, i, j, *p;
X  int   *frp, wert;
X  struct oldv *sold;
X
X  if (brett[pos] & W_WINS)
X    return 50000 - lev;
X  /* Zug fuer Weiss ausfuehren */
X  sold = sp;
X  sp -> pos = frp = freip[pos];
X  sp++ -> value = *frp;
X  sp -> pos = brett + pos;
X  sp++ -> value = brett[pos];
X  sp -> pos = &bewertung;
X  sp++ -> value = bewertung;
X  *frp += columns;
X  brett[pos] |= WEISS;
X  p = pp[pos];
X  while ((h1 = *(p++)) >= 0) {
X    if ((h2 = weiss[h1]) >= 0) {
X      sp -> pos = &weiss[h1];
X      sp++ -> value = h2;
X      weiss[h1]++;
X      bewertung++;
X      if (h2 == 3)
X	w_test (h1);
X    }
X    if ((h2 = schwarz[h1]) >= 0) {
X      sp -> pos = &schwarz[h1];
X      sp++ -> value = h2;
X      schwarz[h1] = -1;
X      bewertung += h2;
X    }
X  }
X  h1 = -1;
X  for (i = 0; i < columns; i++) {
X    register int f = frei[i];
X
X    if (f < row_col) {
X      if (brett[f] & S_WINS) {
X	wert = -49999 + lev;
X	goto end;
X      }
X      if (brett[f] & W_WINS)
X	h1 = f;
X    }
X  }
X  if (h1 >= 0) {
X    level++;
X    wert = comp_schwarz(h1, lev + 1, 100000);
X    level--;
X  } else if (lev >= level)
X    wert = bewertung + s_zugzwang(40 - lev - zugstackp);
X  else {
X    register int    zw;
X
X    wert = 100000;
X    for (i = 0; i < columns; i++) {
X      j = frei[reihenfolge[i]];
X      if (j < row_col)
X	if ((zw = comp_schwarz (j, lev + 1, wert)) < wert)
X	  if ((wert = zw) <= limit)
X	    break;
X      /* Schwarz wird wohl den fuer ihn guenstigsten Zug auswaehlen */
X    }
X    if (wert == 100000)
X      wert = 0;		/* unentschieden */
X  }
X end:
X  while (sp != sold) {
X    sp--;
X    *(sp -> pos) = sp -> value;
X  }
X  return (wert);
}
X
int comp_schwarz(pos, lev, limit)
int pos, lev, limit;
{
X  register int  h1, h2, i, j, *p;
X  int   *frp, wert;
X  struct oldv *sold;
X
X  if (brett[pos] & S_WINS)
X    return -50000 + lev;
X  /* Zug fuer Schwarz ausfuehren */
X  sold = sp;
X  sp -> pos = frp = freip[pos];
X  sp++ -> value = *frp;
X  sp -> pos = brett + pos;
X  sp++ -> value = brett[pos];
X  sp -> pos = &bewertung;
X  sp++ -> value = bewertung;
X  *frp += columns;
X  brett[pos] |= SCHWARZ;
X  p = pp[pos];
X  while ((h1 = *(p++)) >= 0) {
X    if ((h2 = schwarz[h1]) >= 0) {
X      sp -> pos = &schwarz[h1];
X      sp++ -> value = h2;
X      schwarz[h1]++;
X      bewertung--;
X      if (h2 == 3)
X	s_test (h1);
X    }
X    if ((h2 = weiss[h1]) >= 0) {
X      sp -> pos = &weiss[h1];
X      sp++ -> value = h2;
X      weiss[h1] = -1;
X      bewertung -= h2;
X    }
X  }
X  h1 = -1;
X  for (i = 0; i < columns; i++) {
X    register int f = frei[i];
X
X    if (f < row_col) {
X      if (brett[f] & W_WINS) {
X	wert = 49999 - lev;
X	goto end;
X      }
X      if (brett[f] & S_WINS)
X	h1 = f;
X    }
X  }
X  if (h1 >= 0) {
X    level++;
X    wert = comp_weiss(h1, lev + 1, -100000);
X    level--;
X  } else if (lev >= level)
X    wert = bewertung + w_zugzwang(40 - lev - zugstackp);
X  else {
X    register int    zw;
X
X    wert = -100000;
X    for (i = 0; i < columns; i++) {
X      j = frei[reihenfolge[i]];
X      if (j < row_col)
X	if ((zw = comp_weiss (j, lev + 1, wert)) > wert)
X	  if ((wert = zw) >= limit)
X	    break;
X    }
X    if (wert == -100000)
X      wert = 0;		/* unentschieden */
X  }
X end:
X  while (sp != sold) {
X    sp--;
X    *(sp -> pos) = sp -> value;
X  }
X  return (wert);
}
X
int main(argc, argv)
int argc;
char **argv;
{
X  int  i, j, h1, zj, *p, wert, zi;
X  char ch, buf[10];
X  int  same[MAXRC], same_n;
X
X  if (argc != 3 ||
X      (rows = atoi(argv[1])) < 4 || rows > MAXRC ||
X      (columns = atoi(argv[2])) < 4 || columns > MAXRC) {
X    fprintf(stderr, "Usage: %s <rows> <columns>\n", *argv);
X    exit(1);
X  }
X  vierinit();
X  sprintf(buf, "%dR%dC", rows, columns);
X  for (i = 0; buf[i] != '\0'; i++)
X    write_char(buf[i]);
X  srand((int) time(NULL));
X  while (1) {
X  mensch:
X    read_char(&ch);
X    switch (ch) {
X    case '0': case '1': case '2': case '3': case '4':
X    case '5': case '6': case '7': case '8': case '9':
X      write_char(ch);
X      level = ch - '0' + 2;
X      break;
X    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':
X    case 'h': case 'i': case 'j': case 'k': case 'l': case 'm':
X      if (ch - 'a' >= columns ||
X	  (j = frei[ch - 'a']) >= row_col) {
X	write_char('x');
X	break;
X      }
X      if (brett[j] & W_WINS) {
X	write_char('w');
X	while (read_char(&ch) != 'u')
X	  switch (ch) {
X	  case '0': case '1': case '2': case '3': case '4':
X	  case '5': case '6': case '7': case '8': case '9':
X	    write_char(ch);
X	    level = ch - '0' + 2;
X	    break;
X	  case 'n':
X	    goto newgame;
X	  default:
X	    write_char('x');
X	    break;
X	  }
X	write_char('v');
X	break;
X      }
X      zugstack[zugstackp++] = sp;
X      sp -> pos = brett + j;
X      sp++ -> value = brett[j];
X      sp -> pos = frei + ch - 'a';
X      sp++ -> value = frei[ch - 'a'];
X      sp -> pos = &bewertung;
X      sp++ -> value = bewertung;
X      brett[j] |= WEISS;
X      frei[ch - 'a'] += columns;
X      p = pp[j];
X      while ((h1 = *(p++)) >= 0) {
X	if ((weiss[h1]) >= 0) {
X	  sp -> pos = weiss + h1;
X	  sp++ -> value = weiss[h1];
X	  weiss[h1]++;
X	  bewertung++;
X	  if (weiss[h1] == 4)
X	    w_test(h1);
X	}
X	if ((schwarz[h1]) >= 0) {
X	  sp -> pos = schwarz + h1;
X	  sp++ -> value = schwarz[h1];
X	  bewertung += schwarz[h1];
X	  schwarz[h1] = -1;
X	}
X      }
X    computer:
X      same_n = 0;
X      for (i = 0; i < columns; i++) {
X	int f = frei[i];
X	
X	if (f < row_col) {
X	  if (brett[f] & S_WINS) {
X	    zi = i;
X	    goto calculate_end;
X	  }
X	  if (brett[f] & W_WINS)
X	    same[same_n++] = i;
X	}
X      }
X      if (same_n == 0) {
X	wert = 100000;
X	for (i = 0; i < columns; i++) {
X	  register int zw;
X	  
X	  if ((j = frei[reihenfolge[i]]) < row_col)
X	    if ((zw = comp_schwarz (j, 0, wert + 1)) < wert) {
X	      wert = zw;
X	      same_n = 1;
X	      same[0] = reihenfolge[i];
X	    } else if (zw == wert)
X	      same[same_n++] = reihenfolge[i];
X	}
X      }
X      if (same_n == 0) {
X	write_char('z');
X	while (read_char(&ch) != 'u')
X	  switch (ch) {
X	  case '0': case '1': case '2': case '3': case '4':
X	  case '5': case '6': case '7': case '8': case '9':
X	    write_char(ch);
X	    level = ch - '0' + 2;
X	    break;
X	  case 'n':
X	    goto newgame;
X	  default:
X	    write_char('x');
X	    break;
X	  }
X	write_char('v');
X	zugstackp--;
X	while (sp != zugstack[zugstackp]) {
X	  sp--;
X	  *(sp -> pos) = sp -> value;
X	}
X	break;
X      }
X      if (same_n == 1)
X	zi = same[0];
X      else
X	zi = same[rand() % same_n];
X    calculate_end:
X      zj = frei[zi];
X      if (brett[zj] & S_WINS) {
X	write_char('A' + zi);
X	while (read_char(&ch) != 'u')
X	  switch (ch) {
X	  case '0': case '1': case '2': case '3': case '4':
X	  case '5': case '6': case '7': case '8': case '9':
X	    write_char(ch);
X	    level = ch - '0' + 2;
X	    break;
X	  case 'n':
X	    goto newgame;
X	  default:
X	    write_char('x');
X	    break;
X	  }
X	write_char('u');
X	zugstackp--;
X	while (sp != zugstack[zugstackp]) {
X	  sp--;
X	  *(sp -> pos) = sp -> value;
X	}
X	break;
X      }
X      zugstack[zugstackp++] = sp;
X      sp -> pos = brett + zj;
X      sp++ -> value = brett[zj];
X      sp -> pos = frei + zi;
X      sp++ -> value = zj;
X      sp -> pos = &bewertung;
X      sp++ -> value = bewertung;
X      brett[zj] |= SCHWARZ;
X      frei[zi] += columns;
X      p = pp[zj];
X      while ((h1 = *(p++)) >= 0) {
X	if ((schwarz[h1]) >= 0) {
X	  sp -> pos = schwarz + h1;
X	  sp++ -> value = schwarz[h1];
X	  schwarz[h1]++;
X	  bewertung--;
X	  if (schwarz[h1] == 4)
X	    s_test(h1);
X	}
X	if ((weiss[h1]) >= 0) {
X	  sp -> pos = weiss + h1;
X	  sp++ -> value = weiss[h1];
X	  bewertung -= weiss[h1];
X	  weiss[h1] = -1;
X	}
X      }
X      if (frei[zi] < row_col && (brett[frei[zi]] & USELESS)) {
X	/* user didn't recognize a double */
X	for (i = frei[zi]; i < row_col; i+= columns) {
X	  int w_wins = 0, s_wins = 0;
X
X	  sp -> pos = brett + i;
X	  sp++ -> value = brett[i];
X	  brett[i] = 0;
X	  p = pp[i];
X	  while ((h1 = *(p++)) >= 0) {
X	    int wval = 1, sval = 1;
X
X	    for (j = 0; j < 4; j++) {
X	      if (brett[pu[h1][j]] & USELESS) {
X		wval = -1;
X		sval = -1;
X	      } else if (brett[pu[h1][j]] & WEISS) {
X		if (wval > 0)
X		  wval++;
X	      } else if (brett[pu[h1][j]] & SCHWARZ) {
X		if (sval > 0)
X		  sval++;
X	      }
X	    }
X	    if (wval > 0) {
X	      bewertung += wval;
X	      sp -> pos = weiss + h1;
X	      sp++ -> value = weiss[h1];
X	      weiss[h1] = wval;
X	      if (wval == 4)
X		w_wins = 1;
X	    }
X	    if (sval > 0) {
X	      bewertung -= sval;
X	      sp -> pos = schwarz + h1;
X	      sp++ -> value = schwarz[h1];
X	      schwarz[h1] = sval;
X	      if (sval == 4)
X		s_wins = 1;
X	    }
X	  }
X	  if (w_wins && s_wins) {
X	    brett[i] |= (W_WINS | S_WINS);
X	    if (i > frei[zi] + columns) {
X	      if (brett[i - columns] & W_WINS) {
X		if (*doublesp[i] != WEISS) {
X		  sp -> pos = doublesp[i];
X		  sp++ -> value = *doublesp[i];
X		  *doublesp[i] = WEISS;
X		}
X	      } else if (brett[i - columns] & S_WINS) {
X		if (*doublesp[i] != SCHWARZ) {
X		  sp -> pos = doublesp[i];
X		  sp++ -> value = *doublesp[i];
X		  *doublesp[i] = SCHWARZ;
X		}
X	      }
X	    }
X	    break;
X	  } else if (w_wins) {
X	    brett[i] |= W_WINS;
X	    if (i > frei[zi] + columns && (brett[i - columns] & W_WINS)) {
X	      if (*doublesp[i] != WEISS) {
X		sp -> pos = doublesp[i];
X		sp++ -> value = *doublesp[i];
X		*doublesp[i] = WEISS;
X	      }
X	      break;
X	    }
X	  } else if (s_wins) {
X	    brett[i] |= S_WINS;
X	    if (i > frei[zi] + columns  && (brett[i - columns] & S_WINS)) {
X	      if (*doublesp[i] != SCHWARZ) {
X		sp -> pos = doublesp[i];
X		sp++ -> value = *doublesp[i];
X		*doublesp[i] = SCHWARZ;
X	      }
X	      break;
X	    }
X	  }
X	}
X      }
X      for (i = 0; i < columns; i++)
X	if (frei[i] < row_col) {
X	  write_char('a' + zi);
X	  goto mensch;
X	}
X      /* unentschieden */
X      write_char('N' + zi);
X      while (read_char(&ch) != 'u')
X	switch (ch) {
X	case '0': case '1': case '2': case '3': case '4':
X	case '5': case '6': case '7': case '8': case '9':
X	  write_char(ch);
X	  level = ch - '0' + 2;
X	  break;
X	case 'n':
X	  goto newgame;
X	default:
X	  write_char('x');
X	  break;
X	}
X      write_char('u');
X      zugstackp -= 2;
X      while (sp != zugstack[zugstackp]) {
X	sp--;
X	*(sp -> pos) = sp -> value;
X      }
X      break;
X    case 'n':
X    newgame:
X      write_char('n');
X      zugstackp = 0;
X      while (sp != stack) {
X	sp--;
X	*(sp -> pos) = sp -> value;
X      }
X      break;
X    case 'u':
X      if (zugstackp < 2)
X	goto newgame;
X      write_char('u');
X      zugstackp -= 2;
X      while (sp != zugstack[zugstackp]) {
X	sp--;
X	*(sp -> pos) = sp -> value;
X      }
X      break;
X    case 's':
X      if (zugstackp == 0)
X	goto computer;
X      /* else fall through */
X    default:
X      write_char('x');
X      break;
X    }
X  }
}
SHAR_EOF
chmod 0644 vier.c ||
echo 'restore of vier.c failed'
Wc_c="`wc -c < 'vier.c'`"
test 17343 -eq "$Wc_c" ||
	echo 'vier.c: original size 17343, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= vier.h ==============
if test -f 'vier.h' -a X"$1" != X"-c"; then
	echo 'x - skipping vier.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting vier.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'vier.h' &&
char *malloc();
X
extern int rows, columns, vnum;
extern int row_col, row_1_col, row_2_col;
extern int *brett, *weiss, *schwarz, **freip, **doublesp;
extern int frei[], reihenfolge[], doubles[];
extern int (*pu)[4];
extern int *_p_h_, **pp;
extern struct oldv {
X  int *pos, value;
} *stack, *sp, **zugstack;
SHAR_EOF
chmod 0644 vier.h ||
echo 'restore of vier.h failed'
Wc_c="`wc -c < 'vier.h'`"
test 307 -eq "$Wc_c" ||
	echo 'vier.h: original size 307, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= vierinit.c ==============
if test -f 'vierinit.c' -a X"$1" != X"-c"; then
	echo 'x - skipping vierinit.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting vierinit.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'vierinit.c' &&
#include <stdio.h>
X
#include "xvier.h"
#include "vier.h"
X
void vierinit()
{
X  int i, j, pui;
X
X  vnum = rows * (columns - 3) + columns * (rows - 3) +
X    2 * (columns - 3) * (rows - 3);
X  row_col = rows * columns;
X  row_1_col = row_col - columns;
X  row_2_col = row_1_col - columns;
X  brett = (int *)malloc(row_col * sizeof(int));
X  for (i = 0; i < (row_col); i++)
X    brett[i] = 0;
X  weiss = (int *)malloc(vnum * sizeof(int));
X  schwarz = (int *)malloc(vnum * sizeof(int));
X  for (i = 0; i < vnum; i++)
X    weiss[i] = schwarz[i] = 1;
X  for (i = 0; i < columns; i++) {
X    frei[i] = i;
X    doubles[i] = 0;
X  }
X  freip = (int **)malloc(row_col * sizeof(int *));
X  for (j = 0; j < rows; j++)
X    for (i = 0; i < columns; i++)
X      freip[j * columns + i] = frei + i;
X  doublesp = (int **)malloc(row_col * sizeof(int *));
X  for (j = 0; j < rows; j++)
X    for (i = 0; i < columns; i++)
X      doublesp[j * columns + i] = doubles + i;
X  j = 0;
X  i = ((columns - 1) >> 1);
X  if (columns & 1)
X    reihenfolge[j++] = i;
X  else {
X    reihenfolge[j++] = i;
X    reihenfolge[j++] = i + 1;
X  }
X  for (i--; i >= 0; i--) {
X    reihenfolge[j++] = i;
X    reihenfolge[j++] = columns - 1 - i;
X  }
X  pu = (int (*)[4])malloc(vnum * sizeof(*pu));
X  pui = 0;
X  for (i = (rows - 1) * columns; i >= 0; i -= columns)
X    for (j = 0; j <= columns - 4; j++) {
X      pu[pui][0] = i + j;
X      pu[pui][1] = i + j + 1;
X      pu[pui][2] = i + j + 2;
X      pu[pui][3] = i + j + 3;
X      pui++;
X    }
X  for (i = (rows - 4) * columns; i >= 0; i -= columns)
X    for (j = 0; j < columns; j++) {
X      pu[pui][0] = i + j;
X      pu[pui][1] = i + j + columns;
X      pu[pui][2] = i + j + 2 * columns;
X      pu[pui][3] = i + j + 3 * columns;
X      pui++;
X    }
X  for (i = (rows - 4) * columns; i >= 0; i -= columns)
X    for (j = 3; j < columns; j++) {
X      pu[pui][0] = i + j;
X      pu[pui][1] = i + j + columns - 1;
X      pu[pui][2] = i + j + 2 * (columns - 1);
X      pu[pui][3] = i + j + 3 * (columns - 1);
X      pui++;
X    }
X  for (i = (rows - 4) * columns; i >= 0; i -= columns)
X    for (j = 0; j <= columns - 4; j++) {
X      pu[pui][0] = i + j;
X      pu[pui][1] = i + j + columns + 1;
X      pu[pui][2] = i + j + 2 * (columns + 1);
X      pu[pui][3] = i + j + 3 * (columns + 1);
X      pui++;
X    }
X  _p_h_ = (int *)malloc((row_col + 4 * vnum) * sizeof(int));
X  pp = (int **)malloc(row_col * sizeof(int));
X  for (pui = i = 0; i < row_col; i++) {
X    pp[i] = _p_h_ + pui;
X    for (j = 0; j < vnum; j++)
X      if (pu[j][0] == i || pu[j][1] == i || pu[j][2] == i || pu[j][3] == i)
X	_p_h_[pui++] = j;
X    _p_h_[pui++] = -1;
X  }
X  sp = stack = (struct oldv *)
X    malloc(4 * (vnum + row_col) * sizeof(struct oldv));
X  zugstack = (struct oldv **)malloc(row_col * sizeof(struct oldv *));
}
SHAR_EOF
chmod 0644 vierinit.c ||
echo 'restore of vierinit.c failed'
Wc_c="`wc -c < 'vierinit.c'`"
test 2741 -eq "$Wc_c" ||
	echo 'vierinit.c: original size 2741, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xvier.c ==============
if test -f 'xvier.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xvier.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xvier.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xvier.c' &&
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/cursorfont.h>
#include <stdio.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
X
#include "xvier.h"
X
char *malloc();
X
char *displayname = NULL, *geostring = NULL, *fontpattern = NULL;
int iconic = 0, level = 0;
int rows = 6, columns = 7;
Display *mydisplay;
int myscreen;
Window topwindow, boardwindow, quitwindow,
X       newwindow, undowindow, startwindow, changewindow;
#define TOPBORDERWIDTH 5
#define DEFAULTWIDTH	(((10 + 50 * columns) * 5 + 3) / 4)
#define DEFAULTHEIGHT	(10 + 50 * rows)
#define MINWIDTH	((DEFAULTWIDTH * 2) / 5)
#define MINHEIGHT	((DEFAULTHEIGHT * 2) / 5)
#ifndef XVIER_WM_ASPECT_BUG
#define MINASPECTWIDTH	DEFAULTWIDTH
#define MINASPECTHEIGHT	(2 * DEFAULTHEIGHT)
#define MAXASPECTWIDTH	(2 * DEFAULTWIDTH)
#define MAXASPECTHEIGHT	DEFAULTHEIGHT
#endif
GC stonegc[2], buttongc, textgc;
XXEvent myevent;
KeySym mykey;
XXSizeHints myhint;
XXClassHint myclass;
XXWMHints *mywmhints;
unsigned long PixelArray[5];
#define WHITE  PixelArray[0]
#define BLACK  PixelArray[1]
#define BLUE   PixelArray[2]
#define YELLOW PixelArray[3]
#define RED    PixelArray[4]
Colormap cmap;
int private_cmap = 0;
Cursor cursor_normal, cursor_q[4];
#include "qup.xbm"
#include "qupm.xbm"
#include "qright.xbm"
#include "qrightm.xbm"
#include "qdown.xbm"
#include "qdownm.xbm"
#include "qleft.xbm"
#include "qleftm.xbm"
Pixmap qup, qupmask, qright, qrightmask, qdown, qdownmask, qleft, qleftmask;
XXColor cursorforeground, cursorbackground;
int cursor_num;
#ifndef NO_SELECT
struct timeval selectval;
#endif
unsigned long valuemask;
XXSetWindowAttributes attributes;
Pixmap bgpixmap, iconpixmap;
int icon_w_x[6] = {0, 0, 1, 1, 2, 3},
X    icon_w_y[6] = {1, 3, 1, 2, 1, 3},
X    icon_b_x[6] = {0, 1, 1, 2, 2, 3},
X    icon_b_y[6] = {2, 0, 3, 2, 3, 2};
#define DEFAULTICONSIZE 64
#include "patchlevel.h"
char Title[] = XVIER_VERSION;
int c_index = 1, message_index = 0;
char *playercolor[2], levelnumstring[2] = "0",
X     *messagestring[5], yellowmovestring[20],
X     redmovestring[20];
#define DEFAULTFONTPATTERN "*-Helvetica-Medium-R-Normal-*"
#define MAXFONTS 100
XXFontStruct *fontstructarray[MAXFONTS];
int fontnum, quitposx, quitposy, newposx, newposy,
X    undoposx, undoposy, startposx, startposy, changeposx, changeposy;
int text1x, text2x, levely, humany, compy, movey;
int topwidth = 0, topheight = 0, boardwidth,
X    buttonwidth, buttonheight, buttonspace,
X    piece_dx, piece_dy, piece_width, piece_height,
X    *stone_x[2], *stone_y[2], stone_n[2] = {0, 0};
XXArc *stone[2], *holes;
int pipei[2], pipeo[2], pid, processing;
char *progname = PROGNAME;
#ifdef NO_SELECT
#include <poll.h>
struct pollfd pfd[2];
unsigned long npfd;
#else
#ifdef NO_FD_SET
int readfds, fullfds;
#else
fd_set readfds, fullfds;
#endif
#endif
int *columnfill;
X
struct _rgb_vals {
X  unsigned short red, green, blue;
} color_values[5] = {
X    { 65535, 65535, 65535 },
X    {     0,     0,     0 },
X    {     0,     0, 65535 },
X    { 65535, 65535,     0 },
X    { 65535,     0,     0 }},
X  gray_values[5] = {
X    { 65535, 65535, 65535 },
X    {     0,     0,     0 },
X    { 32767, 32767, 32767 },
X    { 65535, 65535, 65535 },
X    {     0,     0,     0 }},
X  *rgb_values;
X
int font_cmp(p1, p2)
XXFontStruct **p1, **p2;
{
X  int ret = ((*p1)->max_bounds.rbearing + (*p1)->max_bounds.lbearing) -
X	    ((*p2)->max_bounds.rbearing + (*p2)->max_bounds.lbearing);
X
X  if (ret == 0)
X    ret = ((*p1)->max_bounds.ascent + (*p1)->max_bounds.descent) -
X	  ((*p2)->max_bounds.ascent + (*p2)->max_bounds.descent);
X  return ret;
}
X
void change_cursor()
{
X  if (cursor_num == 3)
X    cursor_num = 0;
X  else
X    cursor_num++;
X  XDefineCursor(mydisplay, topwindow, cursor_q[cursor_num]);
}
X
void write_prog(ch)
char ch;
{
X  if (processing)
X    XBell(mydisplay, 0);
X  else {
X    if (write(pipeo[1], &ch, 1) < 1) {
X      perror("write to xvier_prog failed");
X      exit(1);
X    }
X    processing = 1;
X    cursor_num = 0;
X    XDefineCursor(mydisplay, topwindow, cursor_q[0]);
X  }
}
X
void message(newindex)
int newindex;
{
X  message_index = newindex;
X  XClearArea(mydisplay, topwindow, boardwidth,
X	     topheight - movey + compy, 0, 0, False);
X  XDrawImageString(mydisplay, topwindow, textgc, text1x, movey,
X		   messagestring[newindex], strlen(messagestring[newindex]));
}
X
void domove(ind, col)
int ind, col;
{
X  int n = stone_n[ind]++;
X
X  stone_x[ind][n] = col;
X  stone_y[ind][n] = columnfill[col]++;
X  stone[ind][n].x = piece_dx + stone_x[ind][n] * (piece_dx + piece_width);
X  stone[ind][n].y = piece_dy +
X    (rows - 1 - stone_y[ind][n]) * (piece_dy + piece_height);
X  stone[ind][n].width = piece_width;
X  stone[ind][n].height = piece_height;
X  XFillArc(mydisplay, boardwindow, stonegc[ind], stone[ind][n].x,
X	   stone[ind][n].y, piece_width, piece_height, 0, 360 * 64);
}
X
void undomove(ind)
int ind;
{
X  int n = --stone_n[ind], col = stone_x[ind][n];
X
X  columnfill[col]--;
X  XClearArea(mydisplay, boardwindow, piece_dx / 2 +
X	     col * (piece_dx + piece_width), piece_dy / 2 +
X	     (rows - 1 - stone_y[ind][n]) * (piece_dy + piece_height),
X	     piece_dx + piece_width, piece_dy + piece_height, False);
X  XDrawArc(mydisplay, boardwindow, textgc, 1 + piece_dx +
X	   col * (piece_dx + piece_width), 1 + piece_dy +
X	   (rows - 1 - stone_y[ind][n]) * (piece_dy + piece_height),
X	   piece_width - 2, piece_height - 2, 0, 360 * 64);
}
X
void recalculate(width, height)
int width, height;
{
X  int i, j, fontid, d1, d2, d3, maxtextwidth, maxtextheight;
X  XCharStruct tmpsize;
X
X  if (width == topwidth && height == topheight)
X    return;
X  topwidth = width;
X  topheight = height;
X  boardwidth = (topwidth * 4) / 5;
X  buttonspace = (topwidth - boardwidth) / 10;
X  buttonwidth = (topwidth - boardwidth) - 2 * buttonspace;
X  buttonheight = (topheight / 2 - 4 * buttonspace) / 4;
X  if (buttonheight < 2 * buttonspace) {
X    buttonspace = topheight / 24;
X    buttonwidth = (topwidth - boardwidth) - 2 * buttonspace;
X    buttonheight = (topheight / 2 - 4 * buttonspace) / 4;
X  }
X  for (i = 0; i < fontnum; i++) {
X    int cpx, cpy, qpx, qpy, npx, npy, upx, upy;
X
X    XTextExtents(fontstructarray[i], "Change", 6, &d1, &d2, &d3, &tmpsize);
X    if (i > 0 && (tmpsize.rbearing + tmpsize.lbearing > buttonwidth - 2 ||
X		  tmpsize.ascent + tmpsize.descent > buttonheight - 2))
X      continue;
X    cpx = (buttonwidth - tmpsize.lbearing - tmpsize.rbearing) / 2 +
X      tmpsize.lbearing;
X    cpy = (buttonheight - tmpsize.ascent - tmpsize.descent) / 2 +
X      tmpsize.ascent;
X    XTextExtents(fontstructarray[i], "Quit", 4, &d1, &d2, &d3, &tmpsize);
X    if (i > 0 && (tmpsize.rbearing + tmpsize.lbearing > buttonwidth - 2 ||
X		  tmpsize.ascent + tmpsize.descent > buttonheight - 2))
X      continue;
X    qpx = (buttonwidth - tmpsize.lbearing - tmpsize.rbearing) / 2 +
X      tmpsize.lbearing;
X    qpy = (buttonheight - tmpsize.ascent - tmpsize.descent) / 2 +
X      tmpsize.ascent;
X    XTextExtents(fontstructarray[i], "New", 3, &d1, &d2, &d3, &tmpsize);
X    if (i > 0 && (tmpsize.rbearing + tmpsize.lbearing > buttonwidth - 2 ||
X		  tmpsize.ascent + tmpsize.descent > buttonheight - 2))
X      continue;
X    npx = (buttonwidth - tmpsize.lbearing - tmpsize.rbearing) / 2 +
X      tmpsize.lbearing;
X    npy = (buttonheight - tmpsize.ascent - tmpsize.descent) / 2 +
X      tmpsize.ascent;
X    XTextExtents(fontstructarray[i], "Undo", 4, &d1, &d2, &d3, &tmpsize);
X    if (i > 0 && (tmpsize.rbearing + tmpsize.lbearing > buttonwidth - 2 ||
X		  tmpsize.ascent + tmpsize.descent > buttonheight - 2))
X      continue;
X    upx = (buttonwidth - tmpsize.lbearing - tmpsize.rbearing) / 2 +
X      tmpsize.lbearing;
X    upy = (buttonheight - tmpsize.ascent - tmpsize.descent) / 2 +
X      tmpsize.ascent;
X    XTextExtents(fontstructarray[i], "Start", 5, &d1, &d2, &d3, &tmpsize);
X    if (i > 0 && (tmpsize.rbearing + tmpsize.lbearing > buttonwidth - 2 ||
X		  tmpsize.ascent + tmpsize.descent > buttonheight - 2))
X      continue;
X    changeposx = cpx; changeposy = cpy;
X    quitposx = qpx; quitposy = qpy;
X    newposx = npx; newposy = npy;
X    undoposx = upx; undoposy = upy;
X    startposx = (buttonwidth - tmpsize.lbearing - tmpsize.rbearing) / 2 +
X      tmpsize.lbearing;
X    startposy = (buttonheight - tmpsize.ascent - tmpsize.descent) / 2 +
X      tmpsize.ascent;
X    fontid = fontstructarray[i]->fid;
X  }
X  XSetFont(mydisplay, buttongc, fontid);
X  maxtextheight = (topheight  - 5 * (buttonspace + buttonheight)) / 5;
X  maxtextwidth = topwidth - boardwidth - maxtextheight / 4;
X  for (i = 0; i < fontnum; i++) {
X    int max1x = 0, max2x = 0, j;
X
X    if (i > 0) {
X      if (fontstructarray[i]->max_bounds.ascent +
X	  fontstructarray[i]->max_bounds.descent > maxtextheight)
X	goto next_font;
X      for (j = 0; j < 5; j++) {
X	XTextExtents(fontstructarray[i], messagestring[j],
X		     strlen(messagestring[j]), &d1, &d2, &d3, &tmpsize);
X	if (tmpsize.rbearing +
X	    fontstructarray[i]->max_bounds.lbearing > maxtextwidth)
X	  goto next_font;
X      }
X    }
X    XTextExtents(fontstructarray[i], "Level: ", 7,
X		 &d1, &d2, &d3, &tmpsize);
X    if (tmpsize.rbearing > max1x)
X      max1x = tmpsize.rbearing;
X    XTextExtents(fontstructarray[i], "You: ", 5,
X		 &d1, &d2, &d3, &tmpsize);
X    if (tmpsize.rbearing > max1x)
X      max1x = tmpsize.rbearing;
X    XTextExtents(fontstructarray[i], "Me: ", 4,
X		 &d1, &d2, &d3, &tmpsize);
X    if (tmpsize.rbearing > max1x)
X      max1x = tmpsize.rbearing;
X    XTextExtents(fontstructarray[i], playercolor[0], strlen(playercolor[0]),
X		 &d1, &d2, &d3, &tmpsize);
X    if (tmpsize.rbearing > max2x)
X      max2x = tmpsize.rbearing;
X    XTextExtents(fontstructarray[i], playercolor[1], strlen(playercolor[1]),
X		 &d1, &d2, &d3, &tmpsize);
X    if (tmpsize.rbearing > max2x)
X      max2x = tmpsize.rbearing;
X    if (i > 0 && max1x + max2x +
X	2 * fontstructarray[i]->max_bounds.lbearing > maxtextwidth)
X      goto next_font;
X    fontid = fontstructarray[i]->fid;
X    text1x  = boardwidth + fontstructarray[i]->max_bounds.lbearing +
X      (topwidth - boardwidth - maxtextwidth) / 2;
X    text2x = text1x + max1x  + fontstructarray[i]->max_bounds.lbearing;
X    movey = topheight - maxtextheight / 8 -
X      fontstructarray[i]->max_bounds.descent -
X	(maxtextheight - fontstructarray[i]->max_bounds.ascent -
X	 fontstructarray[i]->max_bounds.descent) / 2;
X    compy = movey - maxtextheight - maxtextheight / 4;
X    humany = compy - maxtextheight - maxtextheight / 4;
X    levely = humany - maxtextheight - maxtextheight / 4;
X  next_font:
X    ;
X  }
X  XSetFont(mydisplay, textgc, fontid);
X  piece_dx = boardwidth / (columns * 5 + 1);
X  piece_width = (boardwidth - (columns + 1) * piece_dx) / columns;
X  piece_dy = topheight / (rows * 5 + 1);
X  piece_height = (topheight - (rows + 1) * piece_dy) / rows;
X  for (i = 0; i < stone_n[0]; i++) {
X    stone[0][i].x = piece_dx + stone_x[0][i] * (piece_dx + piece_width);
X    stone[0][i].y = piece_dy +
X      (rows - 1 - stone_y[0][i]) * (piece_dy + piece_height);
X    stone[0][i].width = piece_width;
X    stone[0][i].height = piece_height;
X  }
X  for (i = 0; i < stone_n[1]; i++) {
X    stone[1][i].x = piece_dx + stone_x[1][i] * (piece_dx + piece_width);
X    stone[1][i].y = piece_dy +
X      (rows - 1 - stone_y[1][i]) * (piece_dy + piece_height);
X    stone[1][i].width = piece_width;
X    stone[1][i].height = piece_height;
X  }
X  for (i = 0; i < rows; i++)
X    for (j = 0; j < columns; j++) {
X      holes[i*columns+j].x = 1 + piece_dx + j * (piece_dx + piece_width);
X      holes[i*columns+j].y = 1 + piece_dy + i * (piece_dy + piece_height);
X      holes[i*columns+j].width = piece_width - 2;
X      holes[i*columns+j].height = piece_height - 2;
X    }
X  XResizeWindow(mydisplay, boardwindow, boardwidth, topheight);
X  XMoveResizeWindow(mydisplay, quitwindow, boardwidth + buttonspace,
X		    buttonspace, buttonwidth, buttonheight);
X  XMoveResizeWindow(mydisplay, newwindow, boardwidth + buttonspace,
X		    2 * buttonspace + buttonheight,
X		    buttonwidth, buttonheight);
X  XMoveResizeWindow(mydisplay, undowindow, boardwidth + buttonspace,
X		    buttonspace + 2 * (buttonheight + buttonspace),
X		    buttonwidth, buttonheight);
X  XMoveResizeWindow(mydisplay, startwindow, boardwidth + buttonspace,
X		    buttonspace + 3 * (buttonheight + buttonspace),
X		    buttonwidth, buttonheight);
X  XMoveResizeWindow(mydisplay, changewindow, boardwidth + buttonspace,
X		    buttonspace + 4 * (buttonheight + buttonspace),
X		    buttonwidth, buttonheight);
X  XSetWindowBorderWidth(mydisplay, quitwindow,
X			((buttonspace / 8 < 1) ? 1 : buttonspace / 8));
X  XSetWindowBorderWidth(mydisplay, newwindow,
X			((buttonspace / 8 < 1) ? 1 : buttonspace / 8));
X  XSetWindowBorderWidth(mydisplay, undowindow,
X			((buttonspace / 8 < 1) ? 1 : buttonspace / 8));
X  XSetWindowBorderWidth(mydisplay, startwindow,
X			((buttonspace / 8 < 1) ? 1 : buttonspace / 8));
X  XSetWindowBorderWidth(mydisplay, changewindow,
X			((buttonspace / 8 < 1) ? 1 : buttonspace / 8));
}
X
#define Repaint_topwindow() XClearArea(mydisplay, topwindow, boardwidth,\
X			      5 * (buttonspace + buttonheight), 0, 0, True)
X
int main(argc, argv)
int    argc;
char **argv;
{
X  char text[10], **fontnames, *av[4], row_string[3], column_string[3];
X  int i, j, geo_ret, userx, usery, userwidth, userheight;
X  int iconsize, Ilistsize;
X  XIconSize *Ilist;
X
X  for (i = 1; i < argc; i++) {
X    if (strcmp(argv[i], "-display") == 0)
X      if (++i == argc)
X	goto usage;
X      else
X	displayname = argv[i];
X    else if (strcmp(argv[i], "-geometry") == 0)
X      if (++i == argc)
X	goto usage;
X      else
X	geostring = argv[i];
X    else if (strcmp(argv[i], "-fn") == 0)
X      if (++i == argc)
X	goto usage;
X      else
X	fontpattern = argv[i];
X    else if (strcmp(argv[i], "-prog") == 0)
X      if (++i == argc)
X	goto usage;
X      else
X	progname = argv[i];
X    else if (strcmp(argv[i], "-rows") == 0)
X      if (++i == argc)
X	goto usage;
X      else {
X	if ((rows = atoi(argv[i])) < 4 || rows > MAXRC)
X	  goto usage;
X      }
X    else if (strcmp(argv[i], "-columns") == 0)
X      if (++i == argc)
X	goto usage;
X      else {
X	if ((columns = atoi(argv[i])) < 4 || columns > MAXRC)
SHAR_EOF
true || echo 'restore of xvier.c failed'
fi
echo 'End of  part 1'
echo 'File xvier.c is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
-- 
---
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
