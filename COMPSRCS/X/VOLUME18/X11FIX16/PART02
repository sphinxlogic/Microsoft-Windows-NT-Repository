Newsgroups: comp.sources.x
Path: uunet!paladin.american.edu!darwin.sura.net!mips!msi!dcmartin
From: Bob Scheifler <rws@expo.lcs.mit.edu>
Subject: v18i079: X11R5 public fix #16, Part02/03
Message-ID: <1992Aug3.143856.29904@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
References: <csx-18i078-X11-fix16@uunet.UU.NET>
Date: Mon, 3 Aug 1992 14:38:56 GMT
Approved: dcmartin@msi.com
Lines: 1772

Submitted-by: Bob Scheifler <rws@expo.lcs.mit.edu>
Posting-number: Volume 18, Issue 79
Archive-name: X11-fix16/part02

#!/bin/sh
# this is part.02 (part 2 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file fix-16 continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 2; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping fix-16'
else
echo 'x - continuing file fix-16'
sed 's/^X//' << 'SHAR_EOF' >> 'fix-16' &&
! 		XFree(prop);
X  		return(False);
+ 	}
X  	strncpy(version, prop, nitems);
X  	version[nitems] = '\0';
X  	XFree(prop);
***************
*** 271,276 ****
--- 273,279 ----
X  	}
X  	if((imstyle = (XIMStyles *)Xmalloc(sizeof(XIMStyles))) == NULL) {
X  		_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL);
+ 		XFree((XPointer)prop_long);
X  		return(False);
X  	}
X  	if((imstyle->supported_styles =
***************
*** 277,282 ****
--- 280,286 ----
X  		(XIMStyle *)Xmalloc(sizeof(XIMStyle) * nitems)) == NULL) {
X  		Xfree(imstyle);
X  		_Ximp_SetupFree(version, NULL, NULL, NULL, NULL, NULL, NULL);
+ 		XFree((XPointer)prop_long);
X  		return(False);
X  	}
X  	for(i=0; i < nitems; i++) {
***************
*** 295,300 ****
--- 299,305 ----
X  	}
X  	if((keylist = (Ximp_KeyList *)Xmalloc(sizeof(Ximp_KeyList))) == NULL) {
X  		_Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL);
+ 		XFree((XPointer)prop_int);
X  		return(False);
X  	}
X  	count = nitems / 3;
***************
*** 301,306 ****
--- 306,312 ----
X  	if((keylist->keys_list = (Ximp_Key *)Xmalloc(sizeof(Ximp_Key) * count)) == NULL) {
X  		Xfree(keylist);
X  		_Ximp_SetupFree(version, imstyle, NULL, NULL, NULL, NULL, NULL);
+ 		XFree((XPointer)prop_int);
X  		return(False);
X  	}
X  	for(i=0,n=0; n < count; n++) {
***************
*** 321,326 ****
--- 327,333 ----
X  	}
X  	if((server_name = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
X  		_Ximp_SetupFree(version, imstyle, keylist, NULL, NULL, NULL, NULL);
+ 		XFree(prop);
X  		return(False);
X  	}
X  	strncpy(server_name, prop, nitems);
***************
*** 337,342 ****
--- 344,350 ----
X  	}
X  	if((server_vl = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
X  		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
+ 		XFree(prop);
X  		return(False);
X  	}
X  	strncpy(server_vl, prop, nitems);
***************
*** 353,358 ****
--- 361,367 ----
X  	}
X  	if((vendor_name = (char *)Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
X  		_Ximp_SetupFree(version, imstyle, keylist, server_name, NULL, NULL, NULL);
+ 		XFree(prop);
X  		return(False);
X  	}
X  	strncpy(vendor_name, prop, nitems);
***************
*** 369,380 ****
X  	}
X  	if((ext_list = (Atom *)Xmalloc((sizeof(Atom) * (nitems + 1)))) == NULL) {
X  		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
X  		return(False);
X  	}
X  	for(i=0; i < nitems; i++)
X  		ext_list[i] = prop_int[i];
X  	ext_list[nitems] = NULL;
! 	if(prop_int) XFree((XPointer)prop_int);
X  
X  	im->ximp_impart->fe_window	    = fe_window_id;
X  	Protocol_ID                 = XInternAtom(dpy, _XIMP_PROTOCOL, False);
--- 378,392 ----
X  	}
X  	if((ext_list = (Atom *)Xmalloc((sizeof(Atom) * (nitems + 1)))) == NULL) {
X  		_Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
+ 		if( prop_int )
+ 		    XFree((XPointer)prop_int);
X  		return(False);
X  	}
X  	for(i=0; i < nitems; i++)
X  		ext_list[i] = prop_int[i];
X  	ext_list[nitems] = NULL;
! 	if( prop_int )
! 	    XFree((XPointer)prop_int);
X  
X  	im->ximp_impart->fe_window	    = fe_window_id;
X  	Protocol_ID                 = XInternAtom(dpy, _XIMP_PROTOCOL, False);
***************
*** 403,414 ****
--- 415,436 ----
X  
X  	if(Ximp_Xim_List == (Ximp_XIM *)NULL){
X  		Ximp_Xim_List = (Ximp_XIM *)Xmalloc(sizeof(Ximp_XIM));
+ 		if( Ximp_Xim_List == NULL ) {
+ 		    _Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
+ 		    return( False );
+ 		}
X  		Ximp_Xim_List[0] = im;
X  		Ximp_Xim_count = 1;
X  	}
X  	else {
+ 		Ximp_XIM	*ximp_xim;
+ 
X  		n = 0;
X  		for(i=0; i < Ximp_Xim_count; i++) {
+ 			if( Ximp_Xim_List[i] == im ) {
+ 				n = 1;
+ 				break;
+ 			}
X  			if(Ximp_Xim_List[i] == NULL) {
X  				Ximp_Xim_List[i] = im;
X  				n = 1;
***************
*** 416,424 ****
X  			}
X  		}
X  		if(n == 0) {
! 			Ximp_Xim_List = (Ximp_XIM *)Xrealloc(Ximp_Xim_List, ((i + 1) * sizeof(Ximp_XIM)));
! 			Ximp_Xim_List[i-1] = im;
! 			Ximp_Xim_count = i;
X  		}
X  	}
X  
--- 438,451 ----
X  			}
X  		}
X  		if(n == 0) {
! 			ximp_xim = (Ximp_XIM *)Xrealloc(Ximp_Xim_List, ((i + 1) * sizeof(Ximp_XIM)));
! 			if( ximp_xim == NULL ) {
! 			    _Ximp_SetupFree(version, imstyle, keylist, server_name, server_vl, vendor_name, NULL);
! 			    return( False );
! 			}
! 			Ximp_Xim_List = ximp_xim;
! 			Ximp_Xim_List[Ximp_Xim_count] = im;
! 			Ximp_Xim_count++;
X  		}
X  	}
X  
***************
*** 473,479 ****
X  	Ximp_XIC	pic;
X  
X  	for(i = 0; i < Ximp_Xim_count; i++) {
! 		pim = Ximp_Xim_List[i];
X  		for(pic = (Ximp_XIC)pim->core.ic_chain; pic; pic = (Ximp_XIC)pic->core.next) {
X  			if(pic->ximp_icpart->icid == icid)
X  				return(pic);
--- 500,507 ----
X  	Ximp_XIC	pic;
X  
X  	for(i = 0; i < Ximp_Xim_count; i++) {
! 		if( (pim = Ximp_Xim_List[i]) == NULL )
! 			continue;
X  		for(pic = (Ximp_XIC)pim->core.ic_chain; pic; pic = (Ximp_XIC)pic->core.next) {
X  			if(pic->ximp_icpart->icid == icid)
X  				return(pic);
***************
*** 499,505 ****
X  			    + p->count_styles * sizeof(XIMStyle))) == NULL)
X  		return(False);
X  	(*p_style)->count_styles = p->count_styles;
! 	(*p_style)->supported_styles = (XIMStyle *)(*p_style + sizeof(XIMStyles));
X  	for(i=0; i < (int)p->count_styles; i++) {
X  		(*p_style)->supported_styles[i] = p->supported_styles[i];
X  	}
--- 527,533 ----
X  			    + p->count_styles * sizeof(XIMStyle))) == NULL)
X  		return(False);
X  	(*p_style)->count_styles = p->count_styles;
! 	(*p_style)->supported_styles = (XIMStyle *)((char *)*p_style + sizeof(XIMStyles));
X  	for(i=0; i < (int)p->count_styles; i++) {
X  		(*p_style)->supported_styles[i] = p->supported_styles[i];
X  	}
*** /tmp/d13824	Sat Aug  1 11:07:39 1992
--- mit/lib/X/Ximp/XimpLkup.c	Sat Aug  1 11:07:34 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpLkup.c,v 1.7 92/04/14 13:29:28 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, 1992 by Sony Corporation
--- 1,4 ----
! /* $XConsortium: XimpLkup.c,v 1.8 92/07/29 10:16:17 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, 1992 by Sony Corporation
***************
*** 43,61 ****
X  
X  #include "Ximplc.h"
X  
- #ifdef XIMP_SIGNAL
- #include <sys/signal.h>
- #endif /* XIMP_SIGNAL */
- 
- static int	 _time_flag = 0;
- #ifdef XIMP_SIGNAL
- static int
- _time_out()
- 	{
- 	_time_flag = 1;
- 	}
- #endif /* XIMP_SIGNAL */
- 
X  extern Ximp_XIC		_Ximp_LookupXIC();
X  extern Atom		_Ximp_Protocol_id();
X  extern Bool 		_Ximp_XimFilter_Client();
--- 43,48 ----
***************
*** 72,121 ****
X  static void		_Ximp_CallCallback();
X  extern void		_Ximp_ProcError();
X  
! typedef struct {
! 	Atom type;
! 	ICID icid;
! 	Window owner;
! } XimpResetPredArgRec, *XimpResetPredArg;
X  
! static Bool
! #if NeedFunctionPrototypes
! _Ximp_ResetPredicate(
!     Display *d,
!     XEvent *ev,
!     XPointer arg0)
! #else
! _Ximp_ResetPredicate(d, ev, arg0)
X  Display *d;
X  XEvent *ev;
X  XPointer arg0;
- #endif
X  {
!     XimpResetPredArg arg = (XimpResetPredArg) arg0 ;
X  
! 	if (ev->type == ClientMessage) {
! 		if (ev->xclient.message_type == arg->type) {
! 			if ((ev->xclient.format == 32) &&
! 				(ev->xclient.data.l[1] == arg->icid)) {
! 				switch (ev->xclient.data.l[0]) {
! 				case XIMP_RESET_RETURN:
! 				case XIMP_ERROR:
! 				case XIMP_PREEDITDONE:
! 				case XIMP_PREEDITDRAW:
! 				case XIMP_PREEDITDRAW_CM:
! 				case XIMP_STATUSDONE:
! 				case XIMP_STATUSDRAW:
! 				case XIMP_STATUSDRAW_CM:
! 					return(True);
! 				}
! 			}
! 		}
! 	} else if (ev->type == DestroyNotify) {
! 		if (ev->xdestroywindow.window == arg->owner) {
! 			return(True);
! 		}
X  	}
! 	return(False);
X  }
X  
X  static unsigned char *
--- 59,113 ----
X  static void		_Ximp_CallCallback();
X  extern void		_Ximp_ProcError();
X  
! Bool
! _XimpIfEvent( ic, event, predicate, arg )
! Ximp_XIC	ic;
! XEvent		*event;
! Bool		(*predicate)(
! #if NeedNestedPrototypes
! 	Display*,
! 	XEvent*,
! 	char*
! #endif
! );
! char		*arg;
! {
!     XIfEvent( ic->core.im->core.display, event, predicate, arg );
!     if( event->type == DestroyNotify ) {
! 	XPutBackEvent( ic->core.im->core.display, event );
! 	return( False );
!     }
!     else if( event->type == ClientMessage  &&  event->xclient.format == 32  &&
! 	     event->xclient.data.l[0] == XIMP_ERROR ) {
! 	_Ximp_ProcError( ic, ic->core.im->core.display, NULL, event );
! 	return( False );
!     }
!     return( True );
! }
X  
! 
! Bool
! _Ximp_CMPredicate(d, ev, arg0)
X  Display *d;
X  XEvent *ev;
X  XPointer arg0;
X  {
!     XimpCMPredicateArg arg = (XimpCMPredicateArg)arg0;
X  
!     if( ev->type == ClientMessage ) {
! 	if( ev->xclient.message_type == arg->type  &&
! 	    ev->xclient.format == 32 ) {
! 	    if( arg->icid == 0  ||  (ev->xclient.data.l[1] == arg->icid) )
! 		if( ev->xclient.data.l[0] == arg->protocol  ||
! 		    ev->xclient.data.l[0] == XIMP_ERROR )
! 		    return(True);
X  	}
!     } else if( ev->type == DestroyNotify) {
! 	if( ev->xdestroywindow.window == arg->owner ) {
! 	    return( True );
! 	}
!     }
!     return( False );
X  }
X  
X  static unsigned char *
***************
*** 122,199 ****
X  _Ximp_Reset(ic)
X  	Ximp_XIC	 ic;
X  {
! 	XEvent		 Message;
! 	XEvent		 event;
! 	XimpResetPredArgRec Arg;
X  
! 	if(ic->ximp_icpart->icid) {
! 		/* ClientMessage Send */
! 		_Ximp_IM_SendMessage(ic, XIMP_RESET, NULL, NULL, NULL);
X  
! #ifdef XIMP_SIGNAL
! 		signal(SIGALRM, _time_out);
! 		alarm(XIMP_TIME_OUT);
! #endif /* XIMP_SIGNAL */
! 		Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 		Arg.icid = ic->ximp_icpart->icid;
! 		Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 		while(_time_flag != 1) {
! 			if( (XCheckIfEvent(ic->core.im->core.display, &event, _Ximp_ResetPredicate, (XPointer)&Arg)) == False) {
! #ifdef XIMP_SIGNAL
! 				sleep(1);
! #endif /* XIMP_SIGNAL */
! 				continue;
! 				}
! 			if (event.type == ClientMessage) {
! 				switch (event.xclient.data.l[0]) {
! 				case XIMP_RESET_RETURN:
! 					{
! 						int rval;
! 						Atom actual_type_return;
! 						int actual_format_return;
! 						unsigned long nitems_return, bytes_after_return;
! 						unsigned char *p = NULL;
! #ifdef XIMP_SIGNAL
! 						alarm(0);
! #endif /* XIMP_SIGNAL */
! 						ic->ximp_icpart->icid = (ICID)event.xclient.data.l[1];
! 						rval = XGetWindowProperty(ic->core.im->core.display,
! 									((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
! 									(Atom)event.xclient.data.l[2], 0, 1024, True,
! 									AnyPropertyType, &actual_type_return,
! 									&actual_format_return, &nitems_return,
! 									&bytes_after_return, &p);
! 						return(p);
! 						}
! 				case XIMP_ERROR:
! 					_Ximp_ProcError (ic->core.im->core.display,
! 							 NULL, &event);
! 					_time_flag = 0;
! 					return(NULL);
! 				case XIMP_PREEDITDONE:
! 				case XIMP_PREEDITDRAW:
! 				case XIMP_PREEDITDRAW_CM:
! 				case XIMP_PREEDITDRAW_TINY:
! 				case XIMP_STATUSDONE:
! 				case XIMP_STATUSDRAW:
! 				case XIMP_STATUSDRAW_CM:
! 					_Ximp_CallCallback (ic->core.im->core.display, event.xclient.window, &event);
! 					break;
! 					}
! 				}
! 			else {
! #ifdef XIMP_SIGNAL
! 				alarm(0);
! #endif /* XIMP_SIGNAL */
! 				_Ximp_ProcError (ic->core.im->core.display,
! 							 NULL, &event);
! 				_time_flag = 0;
! 				return(NULL);
! 				}
! 			}
! 		_time_flag = 0;
! 		}
! 	return((unsigned char *)NULL);
X  }
X  
X  #define XIMP_MAXBUF 1024
--- 114,149 ----
X  _Ximp_Reset(ic)
X  	Ximp_XIC	 ic;
X  {
!     XEvent			Message;
!     XEvent			event;
!     XimpCMPredicateArgRec	Arg;
!     int				rval;
!     Atom			actual_type_return;
!     int				actual_format_return;
!     unsigned long		nitems_return, bytes_after_return;
!     unsigned char		*p = NULL;
X  
!     if(ic->ximp_icpart->icid) {
! 	/* ClientMessage Send */
! 	_Ximp_IM_SendMessage(ic, XIMP_RESET, NULL, NULL, NULL);
X  
! 	Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 	Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 	Arg.protocol = XIMP_RESET_RETURN;
! 	Arg.icid = ic->ximp_icpart->icid;
! 	if( !_XimpIfEvent( ic, &event, _Ximp_CMPredicate, (XPointer)&Arg ) )
! 	    return( NULL );
! 
! 	ic->ximp_icpart->icid =(ICID)event.xclient.data.l[1];
! 	rval = XGetWindowProperty( ic->core.im->core.display,
! 		    ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
! 		    (Atom)event.xclient.data.l[2], 0, 1024, True,
! 		    AnyPropertyType, &actual_type_return,
! 		    &actual_format_return, &nitems_return,
! 		    &bytes_after_return, &p );
! 	return( p );
!     }
!     return( (unsigned char *)NULL );
X  }
X  
X  #define XIMP_MAXBUF 1024
***************
*** 207,213 ****
X  	unsigned char *ct = _Ximp_Reset(ic);
X  
X  	if (!ct) return(NULL);
! 	mb = Xmalloc(length);
X  	_Ximp_cttombs(ic->core.im->core.lcd, ct, strlen((char *)ct), mb, &length, NULL);
X  	mb[length] = '\0';
X  	return(mb);
--- 157,163 ----
X  	unsigned char *ct = _Ximp_Reset(ic);
X  
X  	if (!ct) return(NULL);
! 	mb = Xmalloc(length+1);
X  	_Ximp_cttombs(ic->core.im->core.lcd, ct, strlen((char *)ct), mb, &length, NULL);
X  	mb[length] = '\0';
X  	return(mb);
***************
*** 222,228 ****
X  	unsigned char *ct = _Ximp_Reset(ic);
X  
X  	if (!ct) return(NULL);
! 	wc = (wchar_t *)Xmalloc(length * sizeof(wchar_t));
X  	_Ximp_cttowcs(ic->core.im->core.lcd, ct, strlen((char *)ct), wc, &length, NULL);
X  	wc[length] = (wchar_t)0;
X  	return(wc);
--- 172,178 ----
X  	unsigned char *ct = _Ximp_Reset(ic);
X  
X  	if (!ct) return(NULL);
! 	wc = (wchar_t *)Xmalloc((length + 1) * sizeof(wchar_t));
X  	_Ximp_cttowcs(ic->core.im->core.lcd, ct, strlen((char *)ct), wc, &length, NULL);
X  	wc[length] = (wchar_t)0;
X  	return(wc);
***************
*** 399,405 ****
X  	extern Ximp_XIM	*Ximp_Xim_List;
X  
X  	for(i = 0; i < Ximp_Xim_count; i++) {
! 		pim = Ximp_Xim_List[i];
X  		for (pic = (Ximp_XIC)pim->core.ic_chain;
X  			pic; pic = (Ximp_XIC)pic->core.next) {
X  			if(pic->core.focus_window == window &&
--- 349,356 ----
X  	extern Ximp_XIM	*Ximp_Xim_List;
X  
X  	for(i = 0; i < Ximp_Xim_count; i++) {
! 		if( (pim = Ximp_Xim_List[i]) == NULL )
! 			continue;
X  		for (pic = (Ximp_XIC)pim->core.ic_chain;
X  			pic; pic = (Ximp_XIC)pic->core.next) {
X  			if(pic->core.focus_window == window &&
***************
*** 484,615 ****
X  		NULL);
X  	_Ximp_IM_SendMessage(ic, XIMP_BEGIN, NULL, NULL, NULL);
X  	XFlush(ic->core.im->core.display);
X  	return(True);
X  }
X  
- 
- typedef struct {
- 	Atom type;
- 	Window owner;
- } XimpCreatePredArgRec, *XimpCreatePredArg;
- 
- static Bool
- _Ximp_CreatePredicate(d, ev, arg0)
- Display *d;
- XEvent *ev;
- XPointer arg0;
- {
-     XimpCreatePredArg arg = (XimpCreatePredArg) arg0;
- 
- 	if (ev->type == ClientMessage) {
- 		if (ev->xclient.message_type == arg->type) {
- 			if (ev->xclient.format == 32) {
- 				switch (ev->xclient.data.l[0]) {
- 				case XIMP_CREATE_RETURN:
- 				case XIMP_ERROR:
- 					return(True);
- 				}
- 			}
- 		}
- 	} else if (ev->type == DestroyNotify) {
- 		if (ev->xdestroywindow.window == arg->owner) {
- 			return(True);
- 		}
- 	}
- 	return(False);
- }
- 
X  Bool
X  _Ximp_SetOpenXIMP(ic, mode)
X  	Ximp_XIC	ic;
X  	int		mode;
X  {
! 	unsigned long	 mask;
! 	XEvent		 event;
! 	XimpCreatePredArgRec Arg;
X  
! 	if(mode == XIMP_CREATE_IC) {  /* XCretaeIC() */
! 		if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
! 			ic->core.client_window = XCreateSimpleWindow(
! 				ic->core.im->core.display,
! 				DefaultRootWindow(ic->core.im->core.display),
! 				0, 0, 1, 1, 1, 0, 0);
! 		}
X  	}
X  
! 	if(!(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK)) {
! 		ic->core.focus_window = ic->core.client_window;
! 	}
X  	
! 	/* Property Data Set */
! 	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->version_id,
! 			XA_STRING, 8, PropModeReplace,
! 			(unsigned char *)XIMP_PROTOCOL_VERSION, strlen(XIMP_PROTOCOL_VERSION));
! 	XFlush(ic->core.im->core.display);
X  
! 	mask = ic->ximp_icpart->proto_mask;
! 	_Ximp_SetFocusWindow(ic);
! 	mask |= XIMP_FOCUS_WIN_MASK;
! 	if(!(   (ic->core.input_style & XIMPreeditCallbacks)
! 	     || (ic->core.input_style & XIMPreeditNone) ) ) { 
! 		if(mask & XIMP_PROP_PREEDIT)
! 			_Ximp_SetPreeditAtr(ic);
! 		if(mask & XIMP_PROP_PREFONT)
! 			_Ximp_SetPreeditFont(ic);
! 		}
! 	else {
! 		mask &= ~(XIMP_PROP_PREEDIT | XIMP_PROP_PREFONT);
! 		}
! 	if(!(   (ic->core.input_style & XIMStatusCallbacks)
! 	     || (ic->core.input_style & XIMStatusNone) ) ) { 
! 		if(mask & XIMP_PROP_STATUS)
! 			_Ximp_SetStatusAtr(ic);
! 		if(mask & XIMP_PROP_STSFONT)
! 			_Ximp_SetStatusFont(ic);
! 		}
! 	else {
! 		mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
! 		}
X  
! 	/* ClientMessage Send */
! 	_Ximp_IM_SendMessage(ic, XIMP_CREATE, ic->core.input_style, mask, NULL);
X  
! #ifdef XIMP_SIGNAL
! 	signal(SIGALRM, _time_out);
! 	alarm(XIMP_TIME_OUT);
! #endif /* XIMP_SIGNAL */
! 	Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 	Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 	while(_time_flag != 1) {
! 		if( (XCheckIfEvent(ic->core.im->core.display, &event, _Ximp_CreatePredicate, (XPointer)&Arg)) == False) {
! #ifdef XIMP_SIGNAL
! 			sleep(1);
! #endif /* XIMP_SIGNAL */
! 			continue;
! 			}
! 		if(event.type == ClientMessage &&
! 		   event.xclient.data.l[0] == XIMP_CREATE_RETURN) {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			ic->ximp_icpart->icid = (ICID)event.xclient.data.l[1];
! 			_Ximp_A_CreateExtension(ic);
! 			_time_flag = 0;
! 			return(True);
! 			}
! 		else {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			_Ximp_ProcError (ic->core.im->core.display, NULL, &event);
! 			_time_flag = 0;
! 			/* return(False); */
! 			continue;
! 			}
! 		}
! 	_time_flag = 0;
! 	return(False);
X  }
X  
X  void
--- 435,537 ----
X  		NULL);
X  	_Ximp_IM_SendMessage(ic, XIMP_BEGIN, NULL, NULL, NULL);
X  	XFlush(ic->core.im->core.display);
+ 	_Ximp_CallRestartCallbackExtension( ic );
X  	return(True);
X  }
X  
X  Bool
X  _Ximp_SetOpenXIMP(ic, mode)
X  	Ximp_XIC	ic;
X  	int		mode;
X  {
!     unsigned long	mask;
!     XEvent		event;
!     XimpCMPredicateArgRec	Arg;
X  
!     if(mode == XIMP_CREATE_IC) {  /* XCretaeIC() */
! 	if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN)) {
! 	    ic->core.client_window = XCreateSimpleWindow(
! 	    ic->core.im->core.display,
! 	    DefaultRootWindow(ic->core.im->core.display),
! 	    0, 0, 1, 1, 1, 0, 0);
X  	}
+     }
X  
!     if(!(ic->ximp_icpart->proto_mask & XIMP_FOCUS_WIN_MASK)) {
! 	ic->core.focus_window = ic->core.client_window;
!     }
X  	
!     /* Property Data Set */
!     XChangeProperty(ic->core.im->core.display, ic->core.client_window,
! 		    ((Ximp_XIM)ic->core.im)->ximp_impart->version_id,
! 		    XA_STRING, 8, PropModeReplace,
! 		    (unsigned char *)XIMP_PROTOCOL_VERSION, strlen(XIMP_PROTOCOL_VERSION));
!     XFlush(ic->core.im->core.display);
X  
!     mask = ic->ximp_icpart->proto_mask;
!     _Ximp_SetFocusWindow(ic);
!     mask |= XIMP_FOCUS_WIN_MASK;
!     if(!(   (ic->core.input_style & XIMPreeditCallbacks)
! 	 || (ic->core.input_style & XIMPreeditNone) ) ) { 
! 	    if(mask & XIMP_PROP_PREEDIT)
! 		    _Ximp_SetPreeditAtr(ic);
! 	    if(mask & XIMP_PROP_PREFONT)
! 		    _Ximp_SetPreeditFont(ic);
!     }
!     else {
! 	mask &= ~(XIMP_PROP_PREEDIT | XIMP_PROP_PREFONT);
!     }
!     if(!(   (ic->core.input_style & XIMStatusCallbacks)
! 	 || (ic->core.input_style & XIMStatusNone) ) ) { 
! 	if(mask & XIMP_PROP_STATUS)
! 	    _Ximp_SetStatusAtr(ic);
! 	if(mask & XIMP_PROP_STSFONT)
! 	    _Ximp_SetStatusFont(ic);
!     }
!     else {
! 	mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
!     }
X  
!     /* ClientMessage Send */
!     _Ximp_IM_SendMessage(ic, XIMP_CREATE, ic->core.input_style, mask, NULL);
X  
!     Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
!     Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
!     Arg.protocol = XIMP_CREATE_RETURN;
!     Arg.icid = 0;
!     if( _XimpIfEvent( ic, &event, _Ximp_CMPredicate, (XPointer)&Arg ) ) {
! 	ic->ximp_icpart->icid = (ICID)event.xclient.data.l[1];
! 	_Ximp_A_CreateExtension(ic);
! 	return(True);
!     }
!     else {
! 	XDeleteProperty( ic->core.im->core.display,
! 			ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id );
! 	if( !((ic->core.input_style & XIMPreeditCallbacks)  ||
! 	    (ic->core.input_style & XIMPreeditNone)) ) { 
! 	    if( mask & XIMP_PROP_PREEDIT )
! 		XDeleteProperty( ic->core.im->core.display,
! 			 ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id );
! 	    if( mask & XIMP_PROP_PREFONT )
! 		XDeleteProperty( ic->core.im->core.display,
! 			ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id );
! 	}
! 	if( !((ic->core.input_style & XIMStatusCallbacks)  ||
! 	    (ic->core.input_style & XIMStatusNone)) ) { 
! 	    if( mask & XIMP_PROP_STATUS )
! 		XDeleteProperty( ic->core.im->core.display,
! 			ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id );
! 	    if( mask & XIMP_PROP_STSFONT )
! 		XDeleteProperty( ic->core.im->core.display,
! 			ic->core.client_window,
! 			((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id );
! 	}
! 	return( False );
!     }
X  }
X  
X  void
***************
*** 622,628 ****
X  	ev->keycode = 0;
X  }
X  
! void
X  _Ximp_ProcKeypress (d, w, ev, kev)
X  	Display			*d;
X  	Window			w;
--- 544,550 ----
X  	ev->keycode = 0;
X  }
X  
! Bool
X  _Ximp_ProcKeypress (d, w, ev, kev)
X  	Display			*d;
X  	Window			w;
***************
*** 633,638 ****
--- 555,562 ----
X  	Ximp_XIC 		ic;
X  
X  	icid = ev->data.l[1];
+ 	if( (ic = _Ximp_LookupXIC(icid)) == NULL )
+ 	    return( False );
X  	kev->type = KeyPress;
X  	kev->serial = ev->serial;
X  	kev->send_event = False;
***************
*** 648,657 ****
X  	kev->keycode = ev->data.l[2];
X  	kev->state = ev->data.l[3];
X  	kev->same_screen = True;
- 	ic = _Ximp_LookupXIC(icid);
X  	if(ic->ximp_icpart->input_mode) { /* ON : input_mode */
X  		ic->ximp_icpart->putback_key_event = True;
X  	}
X  }
X  
X  static void
--- 572,581 ----
X  	kev->keycode = ev->data.l[2];
X  	kev->state = ev->data.l[3];
X  	kev->same_screen = True;
X  	if(ic->ximp_icpart->input_mode) { /* ON : input_mode */
X  		ic->ximp_icpart->putback_key_event = True;
X  	}
+ 	return( True );
X  }
X  
X  static void
***************
*** 677,683 ****
X  	unsigned long		dummy_mask;
X  
X  	icid = ev->data.l[1];
! 	ic   = _Ximp_LookupXIC(icid);
X  
X  	if(ic->ximp_icpart->input_mode) /* ON : input_mode */
X  		return;
--- 601,608 ----
X  	unsigned long		dummy_mask;
X  
X  	icid = ev->data.l[1];
! 	if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 	    return;
X  
X  	if(ic->ximp_icpart->input_mode) /* ON : input_mode */
X  		return;
***************
*** 709,715 ****
X  	Ximp_XIC		ic;
X  
X  	icid = ev->data.l[1];
! 	ic   = _Ximp_LookupXIC(icid);
X  	XSelectInput(d, ic->core.focus_window, ic->ximp_icpart->back_mask );
X  	XFlush(d);
X  	ic->ximp_icpart->input_mode = 0;
--- 634,641 ----
X  	Ximp_XIC		ic;
X  
X  	icid = ev->data.l[1];
! 	if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 	    return;
X  	XSelectInput(d, ic->core.focus_window, ic->ximp_icpart->back_mask );
X  	XFlush(d);
X  	ic->ximp_icpart->input_mode = 0;
***************
*** 735,741 ****
X  	}
X  	icid      = ev->data.l[1];
X  	read_prop = ev->data.l[2];
! 	ic   = _Ximp_LookupXIC(icid);
X  	rval = XGetWindowProperty( d,
X  				((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
X  				read_prop, 0, 1024, True,
--- 661,668 ----
X  	}
X  	icid      = ev->data.l[1];
X  	read_prop = ev->data.l[2];
! 	if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 	    return;
X  	rval = XGetWindowProperty( d,
X  				((Ximp_XIM)ic->core.im)->ximp_impart->fe_window,
X  				read_prop, 0, 1024, True,
***************
*** 751,757 ****
X  }
X  
X  void
! _Ximp_ProcError (d, w, ev)
X  	Display			*d;
X  	Window			w;
X  	XClientMessageEvent	*ev;
--- 678,685 ----
X  }
X  
X  void
! _Ximp_ProcError (ic0, d, w, ev)
! 	Ximp_XIC		ic0;
X  	Display			*d;
X  	Window			w;
X  	XClientMessageEvent	*ev;
***************
*** 766,773 ****
X  	 *	you should modify this routine.
X  	 */
X  
! 	icid = ev->data.l[1];
! 	ic   = _Ximp_LookupXIC(icid);
X  	if (ic->ximp_icpart->error.callback) {
X  		data[0] = ev->data.l[2];
X  		data[2] = ev->data.l[4];
--- 694,706 ----
X  	 *	you should modify this routine.
X  	 */
X  
! 	if( (icid = ev->data.l[1]) != 0 ) {
! 		if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 			return;
! 	}
! 	else if( (ic = ic0) == NULL )
! 		return;
! 
X  	if (ic->ximp_icpart->error.callback) {
X  		data[0] = ev->data.l[2];
X  		data[2] = ev->data.l[4];
***************
*** 812,818 ****
X  	Ximp_XIC	ic;
X  
X  	icid = ev->data.l[1];
! 	ic   = _Ximp_LookupXIC(icid);
X  	switch (ev->data.l[0]) {
X  		case XIMP_GEOMETRY:
X  			_Ximp_CallGeometryCallback (ic, ev);
--- 745,752 ----
X  	Ximp_XIC	ic;
X  
X  	icid = ev->data.l[1];
! 	if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 	    return;
X  	switch (ev->data.l[0]) {
X  		case XIMP_GEOMETRY:
X  			_Ximp_CallGeometryCallback (ic, ev);
***************
*** 866,873 ****
X  	if (ev->format == 32) {
X  		switch (ev->data.l[0]) {
X  		case XIMP_KEYPRESS:
! 			_Ximp_ProcKeypress (d, w, ev, &kev);
! 			XPutBackEvent(d, (XEvent *)&kev);
X  			break ;
X  		case XIMP_CREATE_RETURN:
X  			_Ximp_ProcCreateReturn (d, w, ev);
--- 800,809 ----
X  	if (ev->format == 32) {
X  		switch (ev->data.l[0]) {
X  		case XIMP_KEYPRESS:
! 			if( _Ximp_ProcKeypress (d, w, ev, &kev) )
! 			    XPutBackEvent(d, (XEvent *)&kev);
! 			else
! 			    return( False );
X  			break ;
X  		case XIMP_CREATE_RETURN:
X  			_Ximp_ProcCreateReturn (d, w, ev);
***************
*** 885,891 ****
X  			XPutBackEvent(d, (XEvent *)ev);
X  			break ;
X  		case XIMP_ERROR:
! 			_Ximp_ProcError (d, w, ev);
X  			break;
X  		case XIMP_GEOMETRY:
X  		case XIMP_PREEDITSTART:
--- 821,827 ----
X  			XPutBackEvent(d, (XEvent *)ev);
X  			break ;
X  		case XIMP_ERROR:
! 			_Ximp_ProcError (NULL, d, w, ev);
X  			break;
X  		case XIMP_GEOMETRY:
X  		case XIMP_PREEDITSTART:
***************
*** 947,952 ****
--- 883,889 ----
X  		ximp_impart->fe_window = (Window)NULL;
X  		for(ic = Ximp_Xim_List[i]->core.ic_chain; ic; ic = ic->core.next) {
X  			((Ximp_XIC)ic)->ximp_icpart->icid = NULL;
+ 			_Ximp_CallDestroyCallbackExtension( ic );
X  			_XUnregisterFilter(d,
X  					   ic->core.focus_window,
X  					   _Ximp_XimFilter_Client,
*** /tmp/d14114	Sat Aug  1 11:11:05 1992
--- mit/lib/X/Ximp/Ximplc.h	Sat Aug  1 11:10:57 1992
***************
*** 1,4 ****
! /* $XConsortium: Ximplc.h,v 1.5 92/04/14 13:30:42 rws Exp $ */
X  /*
X   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
X   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
--- 1,4 ----
! /* $XConsortium: Ximplc.h,v 1.6 92/07/29 10:16:27 rws Exp $ */
X  /*
X   * Copyright 1990, 1991, 1992 by TOSHIBA Corp.
X   * Copyright 1990, 1991, 1992 by SORD Computer Corp.
***************
*** 72,77 ****
--- 72,80 ----
X  #include "XIMProto.h"
X  
X  #define USE_SJIS	True
+ #ifdef SVR4
+ #define FIX_EUC32	True
+ #endif
X  
X  #define GL		0x00
X  #define GR		0x80
***************
*** 354,359 ****
--- 357,364 ----
X   	/* Extended Callback attribute */
X  	Bool			 use_lookup_choices;
X  	ICExtLookupAttributes	 lookup_attr;
+ 	XIMCallback		 restart;
+ 	XIMCallback		 destroy;
X  
X  	void			*ictype;
X  	} XICXimpRec;
***************
*** 366,368 ****
--- 371,391 ----
X  	XICCoreRec	 core;
X  	XICXimpRec	*ximp_icpart;
X  	} Ximp_XICRec;
+ 
+ /*
+  * predicate argument
+  */
+ typedef struct {
+ 	Atom	type;
+ 	Window	owner;
+ 	int	protocol;
+ 	ICID	icid;
+ } XimpCMPredicateArgRec, *XimpCMPredicateArg;
+ 
+ typedef struct {
+ 	Atom	type;
+ 	Window	owner;
+ 	ICID	icid;
+ 	Window	window;
+ 	Atom	atom;
+ } XimpPNPredicateArgRec, *XimpPNPredicateArg;
*** /tmp/d14313	Sat Aug  1 11:13:12 1992
--- mit/lib/X/Ximp/XimpExten.c	Sat Aug  1 11:13:05 1992
***************
*** 1,33 ****
! /* $XConsortium: XimpExten.c,v 1.5 92/04/14 13:29:00 rws Exp $ */
X  /******************************************************************
X  
X      Copyright 1991, 1992 by FUJITSU LIMITED.
X      Copyright 1991, 1992 by Sun Microsystems, Inc.
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
X  provided that the above copyright notice appear in all copies and that
X  both that copyright notice and this permission notice appear in
! supporting documentation, and that the name of FUJITSU LIMITED or Sun
! Microsystems, Inc.  not be used in advertising or publicity pertaining
! to distribution of the software without specific, written prior
! permission.  FUJITSU LIMITED and Sun Microsystems, Inc. make no
! representations about the suitability of this software for any
! purpose.  It is provided "as is" without express or implied warranty.
X  
! FUJITSU LIMITED AND SUN MICROSYSTEMS, INC. DISCLAIMS ALL WARRANTIES
! WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU LIMITED AND SUN
! MICROSYSTEMS, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
! CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
! USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
! OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
! PERFORMANCE OF THIS SOFTWARE.
X  
X  Author: Takashi Fujiwara     FUJITSU LIMITED
- 		       fujiwara@a80.tech.yk.fujitsu.co.jp
X          Hideki Hiura         Sun Microsystems, Inc.
! 	               hhiura@Sun.COM
X  ******************************************************************/
X  
X  #define NEED_EVENTS
--- 1,34 ----
! /* $XConsortium: XimpExten.c,v 1.6 92/07/29 10:15:43 rws Exp $ */
X  /******************************************************************
X  
X      Copyright 1991, 1992 by FUJITSU LIMITED.
X      Copyright 1991, 1992 by Sun Microsystems, Inc.
+     Copyright 1991, 1992 by Sony Corporation
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
X  provided that the above copyright notice appear in all copies and that
X  both that copyright notice and this permission notice appear in
! supporting documentation, and that the name of FUJITSU LIMITED, Sun
! Microsystems, Inc. and Sony Corporation not be used in advertising
! or publicity pertaining to distribution of the software without
! specific, written prior permission. FUJITSU LIMITED, Sun Microsystems,
! Inc. and Sony Corporation make no representations about the suitability
! of this software for any purpose.  It is provided "as is" without
! express or implied warranty.
X  
! FUJITSU LIMITED, SUN MICROSYSTEMS, INC. AND SONY CORPORATION DISCLAIMS
! ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
! WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJITSU
! LIMITED, SUN MICROSYSTEMS, INC. AND SONY CORPORATION BE LIABLE FOR
! ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
! OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X  
X  Author: Takashi Fujiwara     FUJITSU LIMITED
X          Hideki Hiura         Sun Microsystems, Inc.
!         Makoto Wakamatsu     Sony Corporation
X  ******************************************************************/
X  
X  #define NEED_EVENTS
***************
*** 37,54 ****
X  #include "Xlcint.h"
X  #include "Ximplc.h"
X  
- #ifdef XIMP_SIGNAL
- #include <sys/signal.h>
- #endif /* XIMP_SIGNAL */
- static int	_time_flag = 0;
- #ifdef XIMP_SIGNAL
- static int
- _time_out()
- 	{
- 	_time_flag = 1;
- 	}
- #endif /* XIMP_SIGNAL */
- 
X  #define		XIM_UNKNOWN_KEYSYM	0x77777777
X  #define		XIM_UNDETERMINED	0x77777776
X  
--- 38,43 ----
***************
*** 144,149 ****
--- 133,140 ----
X  #define XNExtXimp_AuxProcessCallback    "XNExtXimp_AuxProcessCallback"
X  #define XNExtXimp_AuxDoneCallback       "XNExtXimp_AuxDoneCallback"
X  #define XNExtXimp_LookupBegin	        "XNExtXimp_LookupBegin"
+ #define XNExtXimp_RestartCallback	"XNExtXimp_RestartCallback"
+ #define XNExtXimp_DestroyCallback	"XNExtXimp_DestroyCallback"
X  
X  /*
X   * Ximp properties for extented XIC attribute
***************
*** 202,207 ****
--- 193,200 ----
X  Private int     ximp_ext_aux_draw_callback();
X  Private int     ximp_ext_aux_process_callback();
X  Private int     ximp_ext_aux_done_callback();
+ Private int     ximp_ext_restart_callback();
+ Private int     ximp_ext_destroy_callback();
X  Private int	nested_list();
X  
X  /* If you need to extend IC attributes, please add function here */
***************
*** 228,233 ****
--- 221,228 ----
X  	XNExtXimp_AuxProcessCallback, ximp_ext_aux_process_callback,
X  	XNExtXimp_AuxDoneCallback, ximp_ext_aux_done_callback,
X  	XNExtXimp_LookupBegin, ximp_ext_lookup_begin,
+ 	XNExtXimp_RestartCallback, ximp_ext_restart_callback,
+ 	XNExtXimp_DestroyCallback, ximp_ext_destroy_callback,
X      /*
X       * If you need to extend IC attributes, please add attribute/function
X       * here
***************
*** 302,310 ****
X  
X  
X  typedef struct {
! 	Atom message_type;
! 	Atom ext_type;
! 	Window owner;
X  } XimpConversionPredArgRec, *XimpConversionPredArg;
X  
X  Private Bool
--- 297,306 ----
X  
X  
X  typedef struct {
! 	Atom	message_type;
! 	Atom	ext_type;
! 	Window	owner;
! 	ICID	icid;
X  } XimpConversionPredArgRec, *XimpConversionPredArg;
X  
X  Private Bool
***************
*** 323,344 ****
X  {
X      XimpConversionPredArg arg = (XimpConversionPredArg) arg0;
X  
! 	if (ev->type == ClientMessage) {
! 		if (ev->xclient.message_type == arg->message_type) {
! 			if (ev->xclient.format == 32) {
! 				if(ev->xclient.data.l[0] == XIMP_ERROR)
! 					return(True);
! 				else if(ev->xclient.data.l[0] == XIMP_EXTENSION
! 				     && ev->xclient.data.l[3] == arg->ext_type)
! 					return(True);
! 			}
! 		}
! 	} else if (ev->type == DestroyNotify) {
! 		if (ev->xdestroywindow.window == arg->owner) {
! 			return(True);
! 		}
X  	}
! 	return(False);
X  }
X  
X  Private int
--- 319,340 ----
X  {
X      XimpConversionPredArg arg = (XimpConversionPredArg) arg0;
X  
!     if( ev->type == ClientMessage ) {
! 	if( ev->xclient.message_type == arg->message_type  &&
! 	    ev->xclient.format == 32  &&
! 	    ev->xclient.data.l[1] == arg->icid ) {
! 	    if( ev->xclient.data.l[0] == XIMP_ERROR )
! 		return( True );
! 	    else if( ev->xclient.data.l[0] == XIMP_EXTENSION  &&
! 		     ev->xclient.data.l[2] == arg->ext_type )
! 		return( True );
X  	}
!     } else if( ev->type == DestroyNotify ) {
! 	if( ev->xdestroywindow.window == arg->owner ) {
! 	    return( True );
! 	}
!     }
!     return( False );
X  }
X  
X  Private int
***************
*** 376,428 ****
X  	return True;
X  	break;
X      case XICOpGet:
! 	if(ic->ximp_icpart->icid == NULL) {
! 		if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver)
! 			return (False);
! 		*((long *) value) = (long)(ext_im->extension_conversion);
! 		return (True);
! 		}
! 	_Ximp_IM_SendMessage(ic, XIMP_EXTENSION,
X  		     ext_im->extension_conversion_id,
X  		     False,	/* GetICVelues */
! 		     value);
! #ifdef XIMP_SIGNAL
! 	signal(SIGALRM, _time_out);
! 	alarm(XIMP_TIME_OUT);
! #endif /* XIMP_SIGNAL */
X  	Arg.message_type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 	Arg.ext_type     = ext_im->extension_conversion_id;
X  	Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 	while(_time_flag != 1) {
! 		if( (XCheckIfEvent(ic->core.im->core.display, &event, ximp_ext_conversionPredicate, (XPointer)&Arg)) == False) {
! #ifdef XIMP_SIGNAL
! 			sleep(1);
! #endif /* XIMP_SIGNAL */
! 			continue;
! 			}
! 		if(event.type == ClientMessage &&
! 		   event.xclient.data.l[0] == XIMP_EXTENSION) {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			ext_im->extension_conversion = (Bool)event.xclient.data.l[4];
! 			*((long *) value) = (long)(ext_im->extension_conversion);
! 			_time_flag = 0;
! 			return(True);
! 			}
! 		else {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			_Ximp_ProcError (ic->core.im->core.display, NULL, &event);
! 			_time_flag = 0;
! 			/* return(False); */
! 			continue;
! 			}
! 		}
! 	_time_flag = 0;
! 	return(False);
! 	break;
X      }
X      return (False);
X  }
--- 372,396 ----
X  	return True;
X  	break;
X      case XICOpGet:
! 	if( ic->ximp_icpart->icid == NULL ) {
! 	    if(((Ximp_XIM)ic->core.im)->ximp_impart->inputserver)
! 		return( False );
! 	    *((long *) value) = (long)(ext_im->extension_conversion);
! 	    return (True);
! 	}
! 	_Ximp_IM_SendMessage( ic, XIMP_EXTENSION,
X  		     ext_im->extension_conversion_id,
X  		     False,	/* GetICVelues */
! 		     value );
X  	Arg.message_type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
! 	Arg.ext_type = ext_im->extension_conversion_id;
X  	Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
! 	Arg.icid = ic->ximp_icpart->icid;
! 	if( !_XimpIfEvent( ic, &event, ximp_ext_conversionPredicate, (XPointer)&Arg ) )
! 	    return( False );
! 	ext_im->extension_conversion = (Bool)event.xclient.data.l[4];
! 	*((long *) value) = (long)(ext_im->extension_conversion);
! 	return( True );
X      }
X      return (False);
X  }
***************
*** 714,719 ****
--- 682,733 ----
X      return (False);
X  }
X  
+ Private int
+ ximp_ext_restart_callback( ic, op, value )
+ Ximp_XIC        ic;
+ XICOp_t         op;
+ long            value;
+ {
+     switch( op ) {
+       case XICOpCreate:
+       case XICOpSet:
+ 	ic->ximp_icpart->restart.client_data = ((XIMCallback *)value)->client_data;
+ 	ic->ximp_icpart->restart.callback = ((XIMCallback *)value)->callback;
+ 	return( True );
+ 	break;
+ 
+       case XICOpGet:
+ 	/*
+ 	 * NOT surely implemented Yet. Need attention.
+ 	 */
+ 	break;
+     }
+     return( False );
+ }
+ 
+ Private int
+ ximp_ext_destroy_callback( ic, op, value )
+ Ximp_XIC        ic;
+ XICOp_t         op;
+ long            value;
+ {
+     switch( op ) {
+       case XICOpCreate:
+       case XICOpSet:
+ 	ic->ximp_icpart->destroy.client_data = ((XIMCallback *)value)->client_data;
+ 	ic->ximp_icpart->destroy.callback = ((XIMCallback *)value)->callback;
+ 	return( True );
+ 	break;
+ 
+       case XICOpGet:
+ 	/*
+ 	 * NOT surely implemented Yet. Need attention.
+ 	 */
+ 	break;
+     }
+     return( False );
+ }
+ 
X  static void _Ximp_Extlookupstart();
X  static void _Ximp_Extlookupdraw();
X  static void _Ximp_Extlookupprocess();
***************
*** 1277,1283 ****
X  
X      icid = ev->data.l[1];
X      ext_id = ev->data.l[2];
!     ic = _Ximp_LookupXIC(icid);
X  
X      im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
X      ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
--- 1291,1298 ----
X  
X      icid = ev->data.l[1];
X      ext_id = ev->data.l[2];
!     if( (ic = _Ximp_LookupXIC(icid)) == NULL )
! 	return;
X  
X      im_impart = ((Ximp_XIM)ic->core.im)->ximp_impart;
X      ext_im = (Ximp_ExtXIMRec *) im_impart->imtype;
***************
*** 1290,1293 ****
--- 1305,1333 ----
X      } else;
X      /* Add extension here */
X      return;
+ }
+ 
+ 
+ void
+ _Ximp_CallRestartCallbackExtension( xic )
+ Ximp_XIC		xic;
+ {
+     register	XIMCallback	*cb;
+ 
+     cb = &xic->ximp_icpart->restart;
+     if( cb->callback ) {
+ 	(*cb->callback)( xic, cb->client_data, NULL );
+     }
+ }
+ 
+ void
+ _Ximp_CallDestroyCallbackExtension( xic )
+ Ximp_XIC		xic;
+ {
+     register	XIMCallback	*cb;
+ 
+     cb = &xic->ximp_icpart->destroy;
+     if( cb->callback ) {
+ 	(*cb->callback)( xic, cb->client_data, NULL );
+     }
X  }
*** /tmp/d14350	Sat Aug  1 11:13:38 1992
--- mit/lib/X/Ximp/XimpICG.c	Sat Aug  1 11:13:33 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpICG.c,v 1.8 92/04/22 15:46:03 rws Exp $ */
X  /******************************************************************
X  
X      Copyright 1991, 1992 by FUJITSU LIMITED.
--- 1,4 ----
! /* $XConsortium: XimpICG.c,v 1.9 92/07/29 10:15:56 rws Exp $ */
X  /******************************************************************
X  
X      Copyright 1991, 1992 by FUJITSU LIMITED.
***************
*** 28,34 ****
X  
X  Author: Takashi Fujiwara     FUJITSU LIMITED
X          Hideki Hiura         Sun Microsystems, Inc.
!         Makoto Wakamatsu     Sony Corporaion
X  
X  ******************************************************************/
X  
--- 28,34 ----
X  
X  Author: Takashi Fujiwara     FUJITSU LIMITED
X          Hideki Hiura         Sun Microsystems, Inc.
!         Makoto Wakamatsu     Sony Corporation
X  
X  ******************************************************************/
X  
***************
*** 40,51 ****
X  
X  #include "Ximplc.h"
X  
- #ifdef XIMP_SIGNAL
- #include <sys/signal.h>
- #endif /* XIMP_SIGNAL */
- 
X  extern char 		*_Ximp_GetICValues();
X  extern Bool		 _Ximp_GetICExtension();
X  
X  static Bool 		 _Ximp_PreGetAttributes();
X  static Bool 		 _Ximp_StatusGetAttributes();
--- 40,48 ----
X  
X  #include "Ximplc.h"
X  
X  extern char 		*_Ximp_GetICValues();
X  extern Bool		 _Ximp_GetICExtension();
+ extern Bool		_Ximp_CMPredicate();
X  
X  static Bool 		 _Ximp_PreGetAttributes();
X  static Bool 		 _Ximp_StatusGetAttributes();
***************
*** 629,658 ****
X  	return(True);
X  }
X  
- static int	 _time_flag = 0;
- 
- #ifdef XIMP_SIGNAL
- static int
- _time_out()
- {
- 	_time_flag = 1;
- }
- #endif /* XIMP_SIGNAL */
- 
- static Bool Check_Message(display, event, arg)
-     Display *display;
-     XEvent  *event;
-     XPointer arg;
- {
-     if ( event->type == ClientMessage && 
- 	 event->xclient.message_type == 
- 	 ((Ximp_XIM)arg)->ximp_impart->improtocol_id )
- 	return True;
-     else
- 	return False;
- }
- 
- 
X  static XPointer
X  _Ximp_GetRequestIM(ic, mask, get_atom_id, atom_id)
X  	Ximp_XIC	 ic;
--- 626,631 ----
***************
*** 659,708 ****
X  	unsigned long	 mask;
X  	Atom		 get_atom_id, atom_id;
X  {
! 	XEvent		 event;
! 	Atom            actual_type_ret;
! 	int		actual_format_ret;
! 	unsigned long   nitems_ret;
! 	unsigned long   bytes_after_ret;
! 	unsigned char   *data;
X  
! 	if(ic->ximp_icpart->icid == (ICID)NULL)
! 		return(NULL);
! 	if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN))
! 		return(NULL);
X  
! 	_Ximp_IM_SendMessage(ic, XIMP_GETVALUE, mask, NULL, NULL);
! #ifdef XIMP_SIGNAL
! 	signal(SIGALRM, _time_out);
! 	alarm(XIMP_TIME_OUT);
! #endif /* XIMP_SIGNAL */
X  
! 	while(_time_flag != 1) {
! 		if (XCheckIfEvent(ic->core.im->core.display, &event, 
! 			Check_Message, (XPointer)ic->core.im) ) {
! #ifdef XIMP_SIGNAL
! 			alarm(0);
! #endif /* XIMP_SIGNAL */
! 			break;
! 		} else {
! #ifdef XIMP_SIGNAL
! 			sleep(1);
! #endif /* XIMP_SIGNAL */
! 			continue;
! 		}
! 	}
! 	_time_flag = 0;
X  
! 	if(event.xclient.data.l[0] != XIMP_GETVALUE_RETURN)
! 		return(NULL);
! 
! 	XGetWindowProperty(ic->core.im->core.display,
! 			   ic->core.client_window,
! 			   get_atom_id, 0L, 1000000L, True, atom_id,
! 			   &actual_type_ret, &actual_format_ret, &nitems_ret,
! 			   &bytes_after_ret, &data);
! 
!         if(actual_format_ret == 0 || nitems_ret == 0)
! 		return(NULL);
! 	return((XPointer)data);
X  }
--- 632,665 ----
X  	unsigned long	 mask;
X  	Atom		 get_atom_id, atom_id;
X  {
!     XEvent		event;
!     Atom        	actual_type_ret;
!     int			actual_format_ret;
!     unsigned long	nitems_ret;
!     unsigned long	bytes_after_ret;
!     unsigned char	*data;
!     XimpCMPredicateArgRec	Arg;
X  
!     if(ic->ximp_icpart->icid == (ICID)NULL)
! 	return(NULL);
!     if(!(ic->ximp_icpart->value_mask & XIMP_CLIENT_WIN))
! 	return(NULL);
X  
!     _Ximp_IM_SendMessage(ic, XIMP_GETVALUE, mask, NULL, NULL);
!     Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
!     Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
!     Arg.protocol = XIMP_GETVALUE_RETURN;
!     Arg.icid = ic->ximp_icpart->icid;
!     if( !_XimpIfEvent( ic, &event, _Ximp_CMPredicate, (XPointer)&Arg ) )
! 	return( NULL );
X  
!     XGetWindowProperty(ic->core.im->core.display,
! 		       ic->core.client_window,
! 		       get_atom_id, 0L, 1000000L, True, atom_id,
! 		       &actual_type_ret, &actual_format_ret, &nitems_ret,
! 		       &bytes_after_ret, &data);
X  
!     if(actual_format_ret == 0 || nitems_ret == 0)
! 	return(NULL);
!     return((XPointer)data);
X  }
*** /tmp/d14390	Sat Aug  1 11:14:08 1992
--- mit/lib/X/Ximp/XimpICS.c	Sat Aug  1 11:13:58 1992
***************
*** 1,8 ****
! /* $XConsortium: XimpICS.c,v 1.3 92/04/14 13:29:14 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporaion
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpICS.c,v 1.4 92/07/29 10:16:04 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporation
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
***************
*** 26,35 ****
X  OR PERFORMANCE OF THIS SOFTWARE.
X  
X    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporaion
X  
X  ******************************************************************/
X  
X  #include "Xlibint.h"
X  #include "Xlcint.h"
X  
--- 26,36 ----
X  OR PERFORMANCE OF THIS SOFTWARE.
X  
X    Author: Takashi Fujiwara     FUJITSU LIMITED 
!           Makoto Wakamatsu     Sony Corporation
X  
X  ******************************************************************/
X  
+ #define	NEED_EVENTS
X  #include "Xlibint.h"
X  #include "Xlcint.h"
X  
***************
*** 51,56 ****
--- 52,128 ----
X  static Bool		_Ximp_PreSetAttributes();
X  static Bool		_Ximp_StatusSetAttributes();
X  
+ 
+ static Bool
+ _Ximp_PNPredicate( d, ev, arg0 )
+ Display		*d;
+ XEvent		*ev;
+ XPointer	arg0;
+ {
+     XimpPNPredicateArg arg = (XimpPNPredicateArg)arg0;
+ 
+     if( ev->type == PropertyNotify ) {
+ 	if( ev->xproperty.window == arg->window  &&
+ 	    ev->xproperty.atom == arg->atom  &&
+ 	    ev->xproperty.state == PropertyDelete ) {
+ 	    return(True);
+ 	}
+     }
+     else if( ev->type == ClientMessage ) {
+ 	if( ev->xclient.message_type == arg->type  &&
+ 	    ev->xclient.format == 32  &&
+ 	    ev->xclient.data.l[1] == arg->icid  &&
+ 	    ev->xclient.data.l[0] == XIMP_ERROR )
+ 	    return( True );
+     }
+     else if( ev->type == DestroyNotify ) {
+ 	if( ev->xdestroywindow.window == arg->owner ) {
+ 	    return( True );
+ 	}
+     }
+     return( False );
+ }
+ 
+ Bool
+ _XimpPNIfEvent( ic, atom )
+ Ximp_XIC	ic;
+ Atom		atom;
+ {
+     XEvent			event;
+     XimpPNPredicateArgRec	Arg;	
+ 
+     Arg.type = ((Ximp_XIM)ic->core.im)->ximp_impart->improtocol_id;
+     Arg.owner = ((Ximp_XIM)ic->core.im)->ximp_impart->fe_window;
+     Arg.icid = ic->ximp_icpart->icid;
+     Arg.window = ic->core.client_window;
+     Arg.atom = atom;
+     XIfEvent( ic->core.im->core.display, &event, _Ximp_PNPredicate, (XPointer)&Arg );
+     if( event.type != PropertyNotify ) {
+ 	XPutBackEvent( ic->core.im->core.display, &event );
+ 	XDeleteProperty( ic->core.im->core.display,
+ 			 ic->core.client_window,
+ 			 ((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id );
+ 	XDeleteProperty( ic->core.im->core.display,
+ 			 ic->core.client_window,
+ 			 ((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id );
+ 	XDeleteProperty( ic->core.im->core.display,
+ 			 ic->core.client_window,
+ 			 ((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id );
+ 	XDeleteProperty( ic->core.im->core.display,
+ 			 ic->core.client_window,
+ 			 ((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id );
+ 	XDeleteProperty( ic->core.im->core.display,
+ 			 ic->core.client_window,
+ 			 ((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id );
+ 	if( event.type == DestroyNotify )
+ 	    XPutBackEvent( ic->core.im->core.display, &event );
+ 	else
+ 	    _Ximp_ProcError( ic, ic->core.im->core.display, NULL, &event );
+ 	return( False );
+     }
+     return( True );
+ }
+ 
X  char *
X  _Ximp_SetICValues(ic, values)
X  	Ximp_XIC	 ic;
***************
*** 117,126 ****
X  	else {
X  		change_mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
X  		}
! 	if(change_mask)
!  		_Ximp_IM_SendMessage(ic, XIMP_SETVALUE, change_mask, NULL, NULL);
! 	return(ret);
X  	}
X  
X  char *
X  _Ximp_SetICValueData(ic, values, mode, change_mask)
--- 189,222 ----
X  	else {
X  		change_mask &= ~(XIMP_PROP_STATUS | XIMP_PROP_STSFONT);
X  		}
! 	if(change_mask) {
! 	    XWindowAttributes		war;
! 	    long			mask;
! 
! 	    XGetWindowAttributes( ic->core.im->core.display,
! 				  ic->core.client_window, &war );
! 	    XSelectInput( ic->core.im->core.display, ic->core.client_window,
! 			  war.your_event_mask | PropertyChangeMask );
! 	    _Ximp_IM_SendMessage(ic, XIMP_SETVALUE, change_mask, NULL, NULL);
! 	    if( change_mask & XIMP_PROP_FOCUS )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_PREEDIT )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_PREFONT )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_STATUS )
! 		if( !_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id ) )
! 		    change_mask = 0;
! 	    if( change_mask & XIMP_PROP_STSFONT )
! 		!_XimpPNIfEvent( ic, ((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id );
SHAR_EOF
true || echo 'restore of fix-16 failed'
fi
echo 'End of  part 2'
echo 'File fix-16 is continued in part 3'
echo 3 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
