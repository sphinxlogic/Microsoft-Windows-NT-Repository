Path: uunet!elroy.jpl.nasa.gov!swrinde!mips!msi!dcmartin
From: rws@expo.lcs.mit.edu (Bob Scheifler)
Newsgroups: comp.sources.x
Subject: v18i078: X11R5 public fix #16, Part01/03
Message-ID: <csx-18i078-X11-fix16@uunet.UU.NET>
Date: 3 Aug 92 14:38:30 GMT
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1791
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: Bob Scheifler <rws@expo.lcs.mit.edu>
Posting-number: Volume 18, Issue 78
Archive-name: X11-fix16/part01

Fix 16 corrects the following problems:

Xlib: fix-14 was generated against the wrong version of one file, introducing
	a free of static memory
Xlib: (Xsi) XSetICValues does not permit changing XNResource{Name,Class}
Xlib: (Xsi) _XConvertMBToWC() returns unkindly error code
Xlib: (Xsi) XmbTextPerCharExtents returns wrong ink dimensions
Xlib: (Xsi) X{wc/mb}LookupString don't work at XBufferOverflow
Xlib: (Xsi) close some memory leaks
Xlib: (Ximp) memory destroyed when XGetIMValues is called
Xlib: (Ximp) error processing is incorrect

#!/bin/sh
# This is a shell archive (produced by shar 3.50)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 08/03/1992 14:37 UTC by dcmartin@fascet
# Source directory /n/merlin/u2/src/X11R5/fixes
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
# 109408 -rw-r--r-- fix-16
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= fix-16 ==============
if test -f 'fix-16' -a X"$1" != X"-c"; then
	echo 'x - skipping fix-16 (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting fix-16 (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'fix-16' &&
X		      Release 5 Public Patch #16
X			   MIT X Consortium
X
To apply this patch:
X
cd to the top of the source tree (to the directory containing the "mit"
and "contrib" subdirectories) and do:
X	patch -p -s < ThisFile
Patch will work silently unless an error occurs.
If you want to watch patch do its thing, leave out the "-s" argument to patch.
X
Finally, to rebuild after applying this patch, cd to the "mit" subdirectory
and do:
X        make -k >& make.log
X
Brief notes on what this patch fixes:
X
XXlib: fix-14 was generated against the wrong version of one file, introducing
X	a free of static memory
XXlib: (Xsi) XSetICValues does not permit changing XNResource{Name,Class}
XXlib: (Xsi) _XConvertMBToWC() returns unkindly error code
XXlib: (Xsi) XmbTextPerCharExtents returns wrong ink dimensions
XXlib: (Xsi) X{wc/mb}LookupString don't work at XBufferOverflow
XXlib: (Xsi) close some memory leaks
XXlib: (Ximp) memory destroyed when XGetIMValues is called
XXlib: (Ximp) error processing is incorrect
X
Prereq: public-patch-15
X
*** /tmp/,RCSt1022087	Sat Aug  1 12:44:11 1992
--- mit/bug-report	Sat Aug  1 12:42:11 1992
***************
*** 2,8 ****
X  Subject: [area]: [synopsis]   [replace with actual area and short description]
X  
X  VERSION:
!     R5, public-patch-15
X      [MIT public patches will edit this line to indicate the patch level]
X  
X  CLIENT MACHINE and OPERATING SYSTEM:
--- 2,8 ----
X  Subject: [area]: [synopsis]   [replace with actual area and short description]
X  
X  VERSION:
!     R5, public-patch-16
X      [MIT public patches will edit this line to indicate the patch level]
X  
X  CLIENT MACHINE and OPERATING SYSTEM:
*** /tmp/,RCSt1016014	Sat Aug  1 11:32:02 1992
--- mit/lib/X/XcmsInt.c	Sat Aug  1 11:32:06 1992
***************
*** 1,4 ****
! /* $XConsortium: XcmsInt.c,v 1.8 91/07/25 01:08:44 rws Exp $" */
X  
X  /*
X   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: XcmsInt.c,v 1.9 92/01/02 19:27:32 rws Exp $" */
X  
X  /*
X   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 268,275 ****
X  		(*((XcmsFunctionSet *)ccc->pPerScrnInfo->functionSet)->screenFreeProc)
X  			(ccc->pPerScrnInfo->screenData);
X  	    }
X  	}
- 	Xfree(ccc->pPerScrnInfo);
X      }
X  
X      /*
--- 268,275 ----
X  		(*((XcmsFunctionSet *)ccc->pPerScrnInfo->functionSet)->screenFreeProc)
X  			(ccc->pPerScrnInfo->screenData);
X  	    }
+ 	    Xfree(ccc->pPerScrnInfo);
X  	}
X      }
X  
X      /*
*** /tmp/,RCSt1016078	Sat Aug  1 11:32:50 1992
--- mit/lib/X/XcmsLRGB.c	Sat Aug  1 11:32:58 1992
***************
*** 1,4 ****
! /* $XConsortium: XcmsLRGB.c,v 1.20 91/08/20 13:51:23 keith Exp $" */
X  
X  /*
X   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
--- 1,4 ----
! /* $XConsortium: XcmsLRGB.c,v 1.22 92/01/02 19:28:13 rws Exp $" */
X  
X  /*
X   * Code and supporting documentation (c) Copyright 1990 1991 Tektronix, Inc.
***************
*** 637,643 ****
X  	  default:
X  	    XFree (property_return);
X  	    goto FreeSCCData;
- 	    break;
X  	}
X  
X  	/*
--- 637,642 ----
***************
*** 835,842 ****
X   *	SYNOPSIS
X   */
X  static void
! LINEAR_RGB_FreeSCCData(pScreenData)
!     LINEAR_RGB_SCCData *pScreenData;
X  /*
X   *	DESCRIPTION
X   *
--- 834,841 ----
X   *	SYNOPSIS
X   */
X  static void
! LINEAR_RGB_FreeSCCData(pScreenDataTemp)
!     XPointer pScreenDataTemp;
X  /*
X   *	DESCRIPTION
X   *
***************
*** 846,852 ****
X   *
X   */
X  {
!     if (pScreenData) {
X  	if (pScreenData->pRedTbl) {
X  	    if (pScreenData->pGreenTbl) {
X  		if (pScreenData->pRedTbl->pBase != 
--- 845,853 ----
X   *
X   */
X  {
!     LINEAR_RGB_SCCData *pScreenData = (LINEAR_RGB_SCCData *) pScreenDataTemp;
! 
!     if (pScreenData && pScreenData != &Default_RGB_SCCData) {
X  	if (pScreenData->pRedTbl) {
X  	    if (pScreenData->pGreenTbl) {
X  		if (pScreenData->pRedTbl->pBase != 
*** /tmp/d11541	Sat Aug  1 10:38:33 1992
--- mit/lib/X/Xsi/TextPerBd.c	Sat Aug  1 10:38:24 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: TextPerBd.c,v 1.15 91/10/08 14:19:10 rws Exp $
X   */
X  
X  /*
--- 1,5 ----
X  /*
!  * $XConsortium: TextPerBd.c,v 1.16 92/07/29 11:39:57 rws Exp $
X   */
X  
X  /*
***************
*** 114,120 ****
X                          byte2 > fnt->max_char_or_byte2)
X                          ind = 0;
X                      else
!                         ind  = (byte1 - fnt->min_byte1) * d + byte2;
X                  }
X                  if (fnt->per_char != NULL)
X                      onechar = fnt->per_char + ind;
--- 114,121 ----
X                          byte2 > fnt->max_char_or_byte2)
X                          ind = 0;
X                      else
!                         ind  = (byte1 - fnt->min_byte1) * d
! 			     + (byte2 - fnt->min_char_or_byte2);
X                  }
X                  if (fnt->per_char != NULL)
X                      onechar = fnt->per_char + ind;
*** /tmp/d11650	Sat Aug  1 10:39:40 1992
--- mit/lib/X/Xsi/XCnvWCToMB.c	Sat Aug  1 10:39:35 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: XCnvWCToMB.c,v 1.23 92/04/14 15:54:49 rws Exp $
X   */
X  
X  /*
--- 1,5 ----
X  /*
!  * $XConsortium: XCnvWCToMB.c,v 1.24 92/07/29 11:44:21 rws Exp $
X   */
X  
X  /*
***************
*** 48,54 ****
X  /*
X    _IsValidEscSequence()
X    if str is valid escape sequence returns length of it in bytes.
!   else if str is not valid escape sequence returns -1.
X  
X    ISO 2022
X      6.3.3 Categories of escape sequence
--- 48,55 ----
X  /*
X    _IsValidEscSequence()
X    if str is valid escape sequence returns length of it in bytes.
!   else if str is not valid escape sequence returns BadEncoding.
!   else if str has not enough data returns BadTerminate.
X  
X    ISO 2022
X      6.3.3 Categories of escape sequence
***************
*** 86,92 ****
X      int i;
X  
X      if (len <= 0)
! 	return (-1);
X  
X      if (*str == ESC) {
X  	if (len == 1)	/* Only ESC */
--- 87,93 ----
X      int i;
X  
X      if (len <= 0)
! 	return (BadTerminate);
X  
X      if (*str == ESC) {
X  	if (len == 1)	/* Only ESC */
***************
*** 98,117 ****
X  	} else if (*str >= 0x30 && *str <= 0x7e) {
X  	    return (2);
X  	} else if (*str >= 0x20 && *str <= 0x2f) {
! 	    for (i++; len > 0; str++,i++, len--) {
X  		if (*str >= 0x30 && *str <= 0x7e)
X  		    return(i);
X  		if (*str < 0x20 || *str >= 0x7f)
! 		    return (-1); /* Not valid Escape seqence */
X  	    }
! 	    return (-1);
X  	} else {
! 	    return (-1);
X  	}
X      } else if (*str == CSI) {
X  	len--; i = 1; str++;
X      } else {
! 	return (-1);	/* Not Escape sequence */
X      }
X  
X      if (len == 0)
--- 99,118 ----
X  	} else if (*str >= 0x30 && *str <= 0x7e) {
X  	    return (2);
X  	} else if (*str >= 0x20 && *str <= 0x2f) {
! 	    for (i++, len--, str++; len > 0; str++,i++, len--) {
X  		if (*str >= 0x30 && *str <= 0x7e)
X  		    return(i);
X  		if (*str < 0x20 || *str >= 0x7f)
! 		    return (BadEncoding); /* Not valid Escape seqence */
X  	    }
! 	    return (BadTerminate);
X  	} else {
! 	    return (BadEncoding);
X  	}
X      } else if (*str == CSI) {
X  	len--; i = 1; str++;
X      } else {
! 	return (BadEncoding);	/* Not Escape sequence */
X      }
X  
X      if (len == 0)
***************
*** 121,129 ****
X  	if (*str >= 0x40 && *str <= 0x7e)
X  	    return(i);
X  	if (*str < 0x20 || *str >= 0x7f)
! 	    return (-1); /* Not valid Escape seqence */
X      }
!     return (-1);
X  }
X  
X  
--- 122,130 ----
X  	if (*str >= 0x40 && *str <= 0x7e)
X  	    return(i);
X  	if (*str < 0x20 || *str >= 0x7f)
! 	    return (BadEncoding); /* Not valid Escape seqence */
X      }
!     return (BadTerminate);
X  }
X  
X  
***************
*** 199,205 ****
X  		}
X  		continue;
X  	    }
! 	    Return(BadEncoding);
X  	}
X          /*
X           * filter control characters.
--- 200,206 ----
X  		}
X  		continue;
X  	    }
! 	    Return(len);
X  	}
X          /*
X           * filter control characters.
*** /tmp/,RCSt1016201	Sat Aug  1 11:34:06 1992
--- mit/lib/X/Xsi/XConnIM.c	Sat Aug  1 11:34:10 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: XConnIM.c,v 1.17 92/03/03 10:02:09 rws Exp $
X   */
X  
X  /*
--- 1,5 ----
X  /*
!  * $XConsortium: XConnIM.c,v 1.18 92/07/29 13:55:35 rws Exp $
X   */
X  
X  /*
***************
*** 104,109 ****
--- 104,110 ----
X      im->major_version = (long)ntohl(i);
X      bcopy((char *)(prop + offset_of_minor_version), (char *)&i, version_size);
X      im->minor_version = (long)ntohl(i);
+     Xfree((char *)prop);
X      if (im->major_version != XIM_MAJOR_VERSION) return(False);
X      if (!(im->minor_version >= XIM_MINOR_VERSION)) return(False);
X  
*** /tmp/d11780	Sat Aug  1 10:41:01 1992
--- mit/lib/X/Xsi/XCrIC.c	Sat Aug  1 10:40:55 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: XCrIC.c,v 1.31 92/04/14 15:44:17 rws Exp $
X   */
X  
X  /*
--- 1,5 ----
X  /*
!  * $XConsortium: XCrIC.c,v 1.34 92/07/29 13:54:58 rws Exp $
X   */
X  
X  /*
***************
*** 41,47 ****
X  # define Va_start(a,b) va_start(a)
X  #endif
X  
! #if __STDC__ && !defined(VMS)
X  #define RConst const
X  #else
X  #define RConst /**/
--- 41,47 ----
X  # define Va_start(a,b) va_start(a)
X  #endif
X  
! #if __STDC__ && !defined(NORCONST)
X  #define RConst const
X  #else
X  #define RConst /**/
***************
*** 88,93 ****
--- 88,95 ----
X      _XUnregisterFilter(im->core.display, ic->core.focus_window,
X  		       ic->prototype_filter, (XPointer)ic);
X  
+     if (ic->mb) _XlcFreeLocale(ic->mb);
+     if (ic->wc) _XlcFreeLocale(ic->wc);
X  #ifdef	XML
X      if (ic->xlc_num > 0) {
X  	int i;
***************
*** 97,104 ****
--- 99,112 ----
X  	    _XlcFreeLocale(ic->wc_temp[i]);
X  	}
X      }
+     if (ic->mb_temp) Xfree(ic->mb_temp);
+     if (ic->wc_temp) Xfree(ic->wc_temp);
X      if (ic->values.using_language) Xfree(ic->values.using_language);
+     if (ic->values.current_language) Xfree(ic->values.current_language);
X  #endif	/* XML */
+     if (ic->ct_buf) Xfree(ic->ct_buf);
+     if (ic->wc_buf) Xfree(ic->wc_buf);
+     (void) _XipFreeAllICQueue(ic);
X  }
X  
X  static RConst XICMethodsRec ic_methods = {
***************
*** 139,146 ****
X      }
X  }
X  
! static unsigned long
! _ReadRdb(display, ic, mask, rdb, res_name, res_class)
X      Display *display;
X      XipIC ic;
X      unsigned long mask;
--- 147,154 ----
X      }
X  }
X  
! unsigned long
! _XipReadRdb(display, ic, mask, rdb, res_name, res_class)
X      Display *display;
X      XipIC ic;
X      unsigned long mask;
***************
*** 312,318 ****
X      }
X      im->default_ic->core.im = (XIM)im;
X  
!     im->default_mask = _ReadRdb(im->core.display, im->default_ic,
X  				(unsigned long)0,
X  				im->core.rdb, im->core.res_name,
X  				im->core.res_class);
--- 320,326 ----
X      }
X      im->default_ic->core.im = (XIM)im;
X  
!     im->default_mask = _XipReadRdb(im->core.display, im->default_ic,
X  				(unsigned long)0,
X  				im->core.rdb, im->core.res_name,
X  				im->core.res_class);
***************
*** 374,380 ****
X      }
X  
X      if (im->core.rdb && ic->values.res_name && ic->values.res_class) {
! 	mask |= _ReadRdb(im->core.display, ic, mask, im->core.rdb,
X  			 ic->values.res_name, ic->values.res_class);
X      }
X  	
--- 382,388 ----
X      }
X  
X      if (im->core.rdb && ic->values.res_name && ic->values.res_class) {
! 	mask |= _XipReadRdb(im->core.display, ic, mask, im->core.rdb,
X  			 ic->values.res_name, ic->values.res_class);
X      }
X  	
***************
*** 438,445 ****
X      for (;;) {
X  	if ((_XipReadFromIM(im, (char *)&reply1, sz_ximEventReply) < 0) ||
X  	    (reply1.state == 0xffff)) {
! 	    Xfree((char *)ic);
! 	    return(NULL);
X  	}
X  	if (reply1.detail == XIM_CALLBACK) {
X  	    /*
--- 446,452 ----
X      for (;;) {
X  	if ((_XipReadFromIM(im, (char *)&reply1, sz_ximEventReply) < 0) ||
X  	    (reply1.state == 0xffff)) {
! 	    goto _err_ret;
X  	}
X  	if (reply1.detail == XIM_CALLBACK) {
X  	    /*
***************
*** 446,462 ****
X  	     * Call the callback routines.
X  	     */
X  	    if (_XipCallCallbacks(ic) < 0) {
! 		Xfree((char *)ic);
! 		return(NULL);
X  	    }
X  	} else if (reply1.detail == XIM_IC) {
X  	    if (_XipReadFromIM(im, (char *)&reply, sz_ximCreateICReply) < 0) {
! 		Xfree((char *)ic);
! 		return(NULL);
X  	    }
X  	    if (reply.state != 0) {
! 		Xfree((char *)ic);
! 		return(NULL);
X  	    }
X  	    ic->icid = reply.xic;
X  	    break;
--- 453,466 ----
X  	     * Call the callback routines.
X  	     */
X  	    if (_XipCallCallbacks(ic) < 0) {
! 		goto _err_ret;
X  	    }
X  	} else if (reply1.detail == XIM_IC) {
X  	    if (_XipReadFromIM(im, (char *)&reply, sz_ximCreateICReply) < 0) {
! 		goto _err_ret;
X  	    }
X  	    if (reply.state != 0) {
! 		goto _err_ret;
X  	    }
X  	    ic->icid = reply.xic;
X  	    break;
***************
*** 487,492 ****
--- 491,513 ----
X      }
X  #endif	/* XML */
X      return((XIC)ic);
+ 
+ _err_ret:
+     if (ic->mb) _XlcFreeLocale(ic->mb);
+     if (ic->wc) _XlcFreeLocale(ic->wc);
+ #ifdef  XML
+     if (ic->xlc_num > 0) {
+ 	for (i = 0; i < ic->xlc_num; i++) {
+ 	    _XlcFreeLocale(ic->mb_temp[i]);
+ 	    _XlcFreeLocale(ic->wc_temp[i]);
+ 	}
+     }
+     if (ic->mb_temp) Xfree(ic->mb_temp);
+     if (ic->wc_temp) Xfree(ic->wc_temp);
+     if (ic->values.using_language) Xfree(ic->values.using_language);
+ #endif  /* XML */
+     Xfree((char *)ic);
+     return(NULL);
X  }
X  
X  /*
*** /tmp/d11909	Sat Aug  1 10:42:19 1992
--- mit/lib/X/Xsi/XICSetVal.c	Sat Aug  1 10:42:14 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: XICSetVal.c,v 1.28 92/04/24 16:14:45 rws Exp $
X   */
X  
X  /*
--- 1,5 ----
X  /*
!  * $XConsortium: XICSetVal.c,v 1.29 92/07/28 17:54:11 rws Exp $
X   */
X  
X  /*
***************
*** 360,365 ****
--- 360,370 ----
X      err = _XipICSetValues(ic, args, &mask);
X      if (err)
X  	return(err);
+     if (im->core.rdb &&
+ 	(mask & (1L << ICResourceClass | 1L << ICResourceName))) {
+ 	mask |= _XipReadRdb(im->core.display, ic, mask, im->core.rdb,
+ 			    ic->values.res_name, ic->values.res_class);
+     }
X      
X      if (mask & (1L << ICFocusWindow)) {
X  	_XUnregisterFilter(im->core.display, old_focus_window,
*** /tmp/d11947	Sat Aug  1 10:42:44 1992
--- mit/lib/X/Xsi/XIMKeyBind.c	Sat Aug  1 10:42:40 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: XIMKeyBind.c,v 1.23 92/04/24 16:14:56 rws Exp $
X   */
X  
X  /*
--- 1,5 ----
X  /*
!  * $XConsortium: XIMKeyBind.c,v 1.25 92/07/29 12:10:04 rws Exp $
X   */
X  
X  /*
***************
*** 51,62 ****
X      int			ret_len, scanned_bytes;
X      int			ret;
X      unsigned char	buf[32];
X  #ifndef X_WCHAR
X      char		*mbuf;
X  #endif
X  
X      if (ev->keycode == 0) {
! 	(void)_XipGetNextICQueue(ic, &type, &length, keysym, (char **)&ptr);
X  	if (type == XIM_STRING || (type == XIM_KEYSYM && length > 0)) {
X  #ifdef X_WCHAR
X  	    ret_len = nchars;
--- 51,67 ----
X      int			ret_len, scanned_bytes;
X      int			ret;
X      unsigned char	buf[32];
+     KeySym		tmp_ks;
X  #ifndef X_WCHAR
X      char		*mbuf;
X  #endif
X  
X      if (ev->keycode == 0) {
! 	if (ev->state > 0) {
! 	    _XipGetOverflowICQueue(ic, &type, &length, &tmp_ks, (char **)&ptr);
! 	} else {
! 	    _XipGetNextICQueue(ic, &type, &length, &tmp_ks, (char **)&ptr);
! 	}
X  	if (type == XIM_STRING || (type == XIM_KEYSYM && length > 0)) {
X  #ifdef X_WCHAR
X  	    ret_len = nchars;
***************
*** 75,103 ****
X  		ret_len = mbstowcs(buffer, mbuf, nchars);
X  #endif
X  		if (ret_len == nchars)
! 		    ret = XBufferOverflow;
X  	    }
X  #endif
! 	    if (ret < 0) {
X  		*status = XBufferOverflow;
X  		return(0);
X  	    }
! 	    if (type == XIM_STRING)
! 		*status = XLookupChars;
! 	    else
X  		*status = XLookupBoth;
X  	    return(ret_len);
! 	} else if (type == XIM_KEYSYM) {
X  	    *status = XLookupKeySym;
X  	    return(0);
X  	} else {
! 	    *status = 0;
X  	    return(0);
X  	}
X      } else {
! 	ret_len = XLookupString(ev, (char *)buf, 32, keysym, NULL);
X  	if (ret_len > 0) {
! 	    if (*keysym != NoSymbol) {
X  		*status = XLookupBoth;
X  	    } else {
X  		*status = XLookupChars;
--- 80,117 ----
X  		ret_len = mbstowcs(buffer, mbuf, nchars);
X  #endif
X  		if (ret_len == nchars)
! 		    ret = BadBuffer;
X  	    }
X  #endif
! 	    if (ret == BadBuffer) {
! 		_XipSaveOverflowICQueue(ic, type, length, tmp_ks, ptr);
! 		ev->state = 1;
X  		*status = XBufferOverflow;
X  		return(0);
+ 	    } else if (ret < 0) {
+ 		*status = XLookupNone;
+ 		return(0);
X  	    }
! 	    if (type == XIM_KEYSYM && keysym) {
! 		*keysym = tmp_ks;
X  		*status = XLookupBoth;
+ 	    } else {
+ 		*status = XLookupChars;
+ 	    }
X  	    return(ret_len);
! 	} else if (type == XIM_KEYSYM && keysym) {
! 	    *keysym = tmp_ks;
X  	    *status = XLookupKeySym;
X  	    return(0);
X  	} else {
! 	    *status = XLookupNone;
X  	    return(0);
X  	}
X      } else {
! 	ret_len = XLookupString(ev, (char *)buf, 32, &tmp_ks, NULL);
X  	if (ret_len > 0) {
! 	    if (tmp_ks != NoSymbol && keysym) {
! 		*keysym = tmp_ks;
X  		*status = XLookupBoth;
X  	    } else {
X  		*status = XLookupChars;
***************
*** 107,115 ****
X  	    ret = _XConvertMBToWC(ic->wc, (unsigned char *)buf, ret_len,
X  			    (wchar *)buffer, &nchars, &scanned_bytes,
X  			    (_State *)NULL);
! 	    if (ret < 0) {
X  		*status = XBufferOverflow;
X  		return(0);
X  	    }
X  	    ret_len = nchars;
X  	    /* XXX BUG Need to restore saved status */
--- 121,132 ----
X  	    ret = _XConvertMBToWC(ic->wc, (unsigned char *)buf, ret_len,
X  			    (wchar *)buffer, &nchars, &scanned_bytes,
X  			    (_State *)NULL);
! 	    if (ret == BadBuffer) {
X  		*status = XBufferOverflow;
X  		return(0);
+ 	    } else if (ret < 0) {
+ 		*status = XLookupNone;
+ 		return(0);
X  	    }
X  	    ret_len = nchars;
X  	    /* XXX BUG Need to restore saved status */
***************
*** 122,128 ****
X  #endif
X  #endif
X  	} else {
! 	    if (*keysym != NoSymbol) {
X  		*status = XLookupKeySym;
X  	    } else {
X  		*status = XLookupNone;
--- 139,146 ----
X  #endif
X  #endif
X  	} else {
! 	    if (tmp_ks != NoSymbol && keysym) {
! 		*keysym = tmp_ks;
X  		*status = XLookupKeySym;
X  	    } else {
X  		*status = XLookupNone;
***************
*** 147,162 ****
X      unsigned char	*ptr;
X      int			ret_len, scanned_bytes;
X      int			ret;
X  
X      if (ev->keycode == 0) {
! 	_XipGetNextICQueue(ic, &type, &length, keysym, (char **)&ptr);
X  	if (type == XIM_STRING) {
X  	    ret_len = nbytes;
X  	    ret = _XConvertCTToMB(ic->mb, ptr, length, (unsigned char *)buffer,
X  				  &ret_len, &scanned_bytes, (_State *)NULL);
! 	    if (ret < 0) {
X  		*status = XBufferOverflow;
X  		return(0);
X  	    }
X  	    *status = XLookupChars;
X  	    return(ret_len);
--- 165,190 ----
X      unsigned char	*ptr;
X      int			ret_len, scanned_bytes;
X      int			ret;
+     KeySym		tmp_ks;
X  
X      if (ev->keycode == 0) {
! 	if (ev->state > 0) {
! 	    _XipGetOverflowICQueue(ic, &type, &length, &tmp_ks, (char **)&ptr);
! 	} else {
! 	    _XipGetNextICQueue(ic, &type, &length, &tmp_ks, (char **)&ptr);
! 	}
X  	if (type == XIM_STRING) {
X  	    ret_len = nbytes;
X  	    ret = _XConvertCTToMB(ic->mb, ptr, length, (unsigned char *)buffer,
X  				  &ret_len, &scanned_bytes, (_State *)NULL);
! 	    if (ret == BadBuffer) {
! 		_XipSaveOverflowICQueue(ic, type, length, tmp_ks, ptr);
! 		ev->state = 1;
X  		*status = XBufferOverflow;
X  		return(0);
+ 	    } else if (ret < 0) {
+ 		*status = XLookupNone;
+ 		return(0);
X  	    }
X  	    *status = XLookupChars;
X  	    return(ret_len);
***************
*** 167,195 ****
X  				      (unsigned char *)buffer,
X  				      &ret_len, &scanned_bytes,
X  				      (_State *)NULL);
! 		if (ret < 0) {
X  		    *status = XBufferOverflow;
X  		    return(0);
X  		}
! 		*status = XLookupBoth;
X  		return(length);
X  	    }
- 	    *status = XLookupKeySym;
X  	    return(0);
X  	} else {
! 	    *status = 0;
X  	    return(0);
X  	}
X      } else {
! 	ret_len = XLookupString(ev, buffer, nbytes, keysym, NULL);
X  	if (ret_len > 0) {
! 	    if (*keysym != NoSymbol) {
X  		*status = XLookupBoth;
X  	    } else {
X  		*status = XLookupChars;
X  	    }
X  	} else {
! 	    if (*keysym != NoSymbol) {
X  		*status = XLookupKeySym;
X  	    } else {
X  		*status = XLookupNone;
--- 195,239 ----
X  				      (unsigned char *)buffer,
X  				      &ret_len, &scanned_bytes,
X  				      (_State *)NULL);
! 		if (ret == BadBuffer) {
! 		    _XipSaveOverflowICQueue(ic, type, length, tmp_ks, ptr);
! 		    ev->state = 1;
X  		    *status = XBufferOverflow;
X  		    return(0);
+ 		} else if (ret < 0) {
+ 		    *status = XLookupNone;
+ 		    return(0);
X  		}
! 		if (keysym) {
! 		    *keysym = tmp_ks;
! 		    *status = XLookupBoth;
! 		} else {
! 		    *status = XLookupChars;
! 		}
X  		return(length);
+ 	    } else if (keysym) {
+ 		*keysym = tmp_ks;
+ 		*status = XLookupKeySym;
+ 	    } else {
+ 		*status = XLookupNone;
X  	    }
X  	    return(0);
X  	} else {
! 	    *status = XLookupNone;
X  	    return(0);
X  	}
X      } else {
! 	ret_len = XLookupString(ev, buffer, nbytes, &tmp_ks, NULL);
X  	if (ret_len > 0) {
! 	    if (tmp_ks != NoSymbol && keysym) {
! 		*keysym = tmp_ks;
X  		*status = XLookupBoth;
X  	    } else {
X  		*status = XLookupChars;
X  	    }
X  	} else {
! 	    if (tmp_ks != NoSymbol && keysym) {
! 		*keysym = tmp_ks;
X  		*status = XLookupKeySym;
X  	    } else {
X  		*status = XLookupNone;
***************
*** 212,256 ****
X      int			length;
X      char		*ptr;
X      int			ret_len;
X  
X      if (ev->keycode == 0) {
! 	_XipGetNextICQueue(ic, &type, &length, keysym, &ptr);
X  	if (type == XIM_STRING) {
X  	    if (length > nbytes) {
X  		*status = XBufferOverflow;
X  		return(0);
X  	    }
X  	    (void)strncpy(buffer, ptr, length);
! 	    buffer[length] = 0;
X  	    *status = XLookupChars;
X  	    return(nbytes);
X  	} else if (type == XIM_KEYSYM) {
X  	    if (length > 0) {
X  		if (length > nbytes) {
X  		    *status = XBufferOverflow;
X  		    return(0);
X  		}
X  		(void)strncpy(buffer, ptr, length);
! 		buffer[length] = 0;
! 		*status = XLookupBoth;
X  		return(nbytes);
X  	    }
- 	    *status = XLookupKeySym;
X  	    return(0);
X  	} else {
! 	    *status = 0;
X  	    return(0);
X  	}
X      } else {
! 	ret_len = XLookupString(ev, buffer, nbytes, keysym, NULL);
X  	if (ret_len > 0) {
! 	    if (*keysym != NoSymbol) {
X  		*status = XLookupBoth;
X  	    } else {
X  		*status = XLookupChars;
X  	    }
X  	} else {
! 	    if (*keysym != NoSymbol) {
X  		*status = XLookupKeySym;
X  	    } else {
X  		*status = XLookupNone;
--- 256,319 ----
X      int			length;
X      char		*ptr;
X      int			ret_len;
+     KeySym		tmp_ks;
X  
X      if (ev->keycode == 0) {
! 	if (ev->state > 0) {
! 	    _XipGetOverflowICQueue(ic, &type, &length, &tmp_ks, (char **)&ptr);
! 	} else {
! 	    _XipGetNextICQueue(ic, &type, &length, &tmp_ks, &ptr);
! 	}
X  	if (type == XIM_STRING) {
X  	    if (length > nbytes) {
+ 		_XipSaveOverflowICQueue(ic, type, length, tmp_ks, ptr);
+ 		ev->state = 1;
X  		*status = XBufferOverflow;
X  		return(0);
X  	    }
X  	    (void)strncpy(buffer, ptr, length);
! 	    if (length < nbytes) buffer[length] = 0;
X  	    *status = XLookupChars;
X  	    return(nbytes);
X  	} else if (type == XIM_KEYSYM) {
X  	    if (length > 0) {
X  		if (length > nbytes) {
+ 		    _XipSaveOverflowICQueue(ic, type, length, tmp_ks, ptr);
+ 		    ev->state = 1;
X  		    *status = XBufferOverflow;
X  		    return(0);
X  		}
X  		(void)strncpy(buffer, ptr, length);
! 		if (length < nbytes) buffer[length] = 0;
! 		if (keysym) {
! 		    *keysym = tmp_ks;
! 		    *status = XLookupBoth;
! 		} else {
! 		    *status = XLookupChars;
! 		}
X  		return(nbytes);
+ 	    } else if (keysym) {
+ 		*status = XLookupKeySym;
+ 	    } else {
+ 		*status = XLookupNone;
X  	    }
X  	    return(0);
X  	} else {
! 	    *status = XLookupNone;
X  	    return(0);
X  	}
X      } else {
! 	ret_len = XLookupString(ev, buffer, nbytes, &tmp_ks, NULL);
X  	if (ret_len > 0) {
! 	    if (tmp_ks != NoSymbol && keysym) {
! 		*keysym = tmp_ks;
X  		*status = XLookupBoth;
X  	    } else {
X  		*status = XLookupChars;
X  	    }
X  	} else {
! 	    if (tmp_ks != NoSymbol && keysym) {
! 		*keysym = tmp_ks;
X  		*status = XLookupKeySym;
X  	    } else {
X  		*status = XLookupNone;
*** /tmp/d12010	Sat Aug  1 10:43:28 1992
--- mit/lib/X/Xsi/XIMQueue.c	Sat Aug  1 10:43:23 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: XIMQueue.c,v 1.9 91/11/17 15:58:54 rws Exp $
X   */
X  
X  /*
--- 1,5 ----
X  /*
!  * $XConsortium: XIMQueue.c,v 1.11 92/07/29 13:55:40 rws Exp $
X   */
X  
X  /*
***************
*** 138,144 ****
X  		if (_XipReadFromIM(im, ic->in->ptr, ic->in->length) < 0)
X  		    return(-1);
X  	    } else {
! 		(void) strcpy(ic->in->ptr, (char *)str);
X  	    }
X  	}
X      } else if (type == XIM_STRING) {
--- 138,144 ----
X  		if (_XipReadFromIM(im, ic->in->ptr, ic->in->length) < 0)
X  		    return(-1);
X  	    } else {
! 		(void) strncpy(ic->in->ptr, (char *)str, length);
X  	    }
X  	}
X      } else if (type == XIM_STRING) {
***************
*** 185,188 ****
--- 185,252 ----
X      }
X  }
X  
+ void
+ _XipFreeAllICQueue(ic)
+     XipIC ic;
+ {
+     register XIMQueue *start = ic->in;
+     register XIMQueue *p, *f;
+     for (p = ic->in; p;) {
X  
+ 	if (p->buf_max > 0) Xfree((char *)p->ptr);
+ 	f = p;
+ 	p = p->next;
+ 	Xfree((char *)f);
+ 	if (p == start) break;
+     }
+ }
+ 
+ /*
+  * Save to Overflow Queue
+  */
+ void
+ _XipSaveOverflowICQueue(ic, type, length, keysym, ptr)
+     XipIC ic;
+     short type;
+     int length;
+     KeySym keysym;
+     char *ptr;
+ {
+     register XIMQueue *q = &ic->overflow;
+ 
+     q->type = type;
+     q->length = length;
+     q->keysym = keysym;
+     q->state = 0;
+     if (q->length > 0) {
+ 	if (q->buf_max < q->length) {
+ 	    q->ptr = (char *)Xrealloc((char *)q->ptr, (unsigned)q->length);
+ 	    q->buf_max = q->length;
+ 	}
+ 	(void) bcopy(ptr, q->ptr, (unsigned)q->length);
+     }
+ }
+ 
+ /*
+  * Get from Overflow Queue
+  */
+ void
+ _XipGetOverflowICQueue(ic, type, length, keysym, ptr)
+     XipIC ic;
+     short *type;
+     int *length;
+     KeySym *keysym;
+     char **ptr;
+ {
+     register XIMQueue *q = &ic->overflow;
+ 
+     if (q->type == XIM_STRING || q->type == XIM_KEYSYM) {
+ 	*type = q->type;
+ 	*length = q->length;
+ 	if (keysym != NULL) *keysym = q->keysym;
+ 	*ptr = q->ptr;
+ 	q->type = 0;
+     } else {
+ 	*type = 0;
+     }
+ }
*** /tmp/d12081	Sat Aug  1 10:44:15 1992
--- mit/lib/X/Xsi/XOpenIM.c	Sat Aug  1 10:44:11 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: XOpenIM.c,v 1.17 91/08/12 17:20:36 rws Exp $
X   */
X  
X  /*
--- 1,5 ----
X  /*
!  * $XConsortium: XOpenIM.c,v 1.19 92/07/28 17:52:13 rws Exp $
X   */
X  
X  /*
***************
*** 41,47 ****
X  extern int getuid();
X  #endif
X  
! #if __STDC__ && !defined(VMS)
X  #define RConst const
X  #else
X  #define RConst /**/
--- 41,47 ----
X  extern int getuid();
X  #endif
X  
! #if __STDC__ && !defined(NORCONST)
X  #define RConst const
X  #else
X  #define RConst /**/
***************
*** 72,80 ****
X      { XNFocusWindow, sizeof(Window), offset(core.focus_window),
X        (unsigned short)IMResourceReadWrite, ICFocusWindow },
X      { XNResourceName, sizeof(char *), offset(values.res_name),
!       (unsigned short)IMResourceReadWrite, -1 },
X      { XNResourceClass, sizeof(char *), offset(values.res_class),
!       (unsigned short)IMResourceReadWrite, -1 },
X      { XNFilterEvents, sizeof(long), offset(core.filter_events),
X        (unsigned short)IMResourceRead, ICFilterEvents },
X      { XNPreeditAttributes, sizeof(ICAttributes *), offset(core.preedit_attr),
--- 72,80 ----
X      { XNFocusWindow, sizeof(Window), offset(core.focus_window),
X        (unsigned short)IMResourceReadWrite, ICFocusWindow },
X      { XNResourceName, sizeof(char *), offset(values.res_name),
!       (unsigned short)IMResourceReadWrite, ICResourceName },
X      { XNResourceClass, sizeof(char *), offset(values.res_class),
!       (unsigned short)IMResourceReadWrite, ICResourceClass },
X      { XNFilterEvents, sizeof(long), offset(core.filter_events),
X        (unsigned short)IMResourceRead, ICFilterEvents },
X      { XNPreeditAttributes, sizeof(ICAttributes *), offset(core.preedit_attr),
*** /tmp/d12485	Sat Aug  1 10:48:37 1992
--- mit/lib/X/Xsi/XIMlibint.h	Sat Aug  1 10:48:32 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: XIMlibint.h,v 1.11 91/11/17 15:59:01 rws Exp $
X   */
X  
X  /*
--- 1,5 ----
X  /*
!  * $XConsortium: XIMlibint.h,v 1.13 92/07/29 13:55:45 rws Exp $
X   */
X  
X  /*
***************
*** 60,65 ****
--- 60,68 ----
X  extern void	_XipFreeNextICQueue();
X  extern int	_XipPutICQueue();
X  extern void	_XipGetNextICQueue();
+ extern void	_XipFreeAllICQueue();
+ extern void	_XipSaveOverflowICQueue();
+ extern void	_XipGetOverflowICQueue();
X  extern int	_XipWriteToIM();
X  extern int	_XipReadFromIM();
X  extern int	_XipFlushToIM();
*** /tmp/d12549	Sat Aug  1 10:49:16 1992
--- mit/lib/X/Xsi/Xi18nint.h	Sat Aug  1 10:49:12 1992
***************
*** 1,5 ****
X  /*
!  * $XConsortium: Xi18nint.h,v 1.19 92/04/14 15:45:50 rws Exp $
X   */
X  
X  /*
--- 1,5 ----
X  /*
!  * $XConsortium: Xi18nint.h,v 1.20 92/07/29 11:58:18 rws Exp $
X   */
X  
X  /*
***************
*** 117,123 ****
X  typedef struct {
X      XICMethods		methods;		/* method list of this IC */
X      XICCoreRec		core;			/* core data of this IC */
!     struct _XIMQueue	*in, *out, *prev;
X      Bool		(*prototype_filter)();
X      XLocale		mb;
X      XLocale		wc;
--- 117,123 ----
X  typedef struct {
X      XICMethods		methods;		/* method list of this IC */
X      XICCoreRec		core;			/* core data of this IC */
!     struct _XIMQueue	*in, *out, *prev, overflow;
X      Bool		(*prototype_filter)();
X      XLocale		mb;
X      XLocale		wc;
*** /tmp/d13599	Sat Aug  1 11:05:16 1992
--- mit/lib/X/Ximp/XIMProto.h	Sat Aug  1 11:05:12 1992
***************
*** 1,4 ****
! /* $XConsortium: XIMProto.h,v 1.5 92/04/14 13:28:34 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, 1992 by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XIMProto.h,v 1.6 92/07/29 10:15:02 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, 1992 by FUJITSU LIMITED
***************
*** 28,34 ****
X  ******************************************************************/
X  
X  /* Ximp implementation revision */
! #define XIMP_REVISION "Ximp Revision 3.2"
X  
X  /* Ximp Protocol Version */
X  #define XIMP_PROTOCOL_VERSION "XIMP.3.5"
--- 28,34 ----
X  ******************************************************************/
X  
X  /* Ximp implementation revision */
! #define XIMP_REVISION "Ximp Revision 3.3"
X  
X  /* Ximp Protocol Version */
X  #define XIMP_PROTOCOL_VERSION "XIMP.3.5"
*** /tmp/d13631	Sat Aug  1 11:05:35 1992
--- mit/lib/X/Ximp/XimpCallbk.c	Sat Aug  1 11:05:31 1992
***************
*** 1,9 ****
! /* $XConsortium: XimpCallbk.c,v 1.5 92/04/14 13:28:40 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, 1992 by Fuji Xerox Co.,Ltd.
X                Copyright 1991, 1992 by FUJITSU LIMITED
X                Copyright 1991, 1992 by Sun Microsystems, Inc.
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
--- 1,10 ----
! /* $XConsortium: XimpCallbk.c,v 1.6 92/07/29 10:15:36 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, 1992 by Fuji Xerox Co.,Ltd.
X                Copyright 1991, 1992 by FUJITSU LIMITED
X                Copyright 1991, 1992 by Sun Microsystems, Inc.
+               Copyright 1991, 1992 by Sony Corporation
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
***************
*** 10,36 ****
X  provided that the above copyright notice appear in all copies and that
X  both that copyright notice and this permission notice appear in
X  supporting documentation, and that the name of Fuji Xerox Co.,Ltd.,
! FUJITSU LIMITED, Sun Microsystems, Inc. not be used in advertising or
! publicity pertaining to distribution of the software without specific,
! written prior permission.  Fuji Xerox Co.,Ltd., FUJITSU LIMITED makes
X  no representations about the suitability of this software for any
X  purpose.  It is provided "as is" without express or implied warranty.
X  
! FUJI XEROX CO.,LTD., FUJITSU LIMITED, SUN MICROSYSTEMS DISCLAIMS ALL
! WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED
! WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL FUJI
! XEROX CO.,LTD., FUJITSU LIMITED, SUN MICROSYSTEMS BE LIABLE FOR ANY
! SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X  RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X  CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
X  CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X  
X    Auther: Kazunori Nishihara,  Fuji Xerox Co.,Ltd.
-                                kaz@ssdev.ksp.fujixerox.co.jp
X            Takashi Fujiwara     FUJITSU LIMITED
-                                fujiwara@a80.tech.yk.fujitsu.co.jp
X            Hideki Hiura         Sun Microsystems, Inc.
!                                hhiura@Sun.COM
X  ******************************************************************/
X  
X  #define NEED_EVENTS
--- 11,37 ----
X  provided that the above copyright notice appear in all copies and that
X  both that copyright notice and this permission notice appear in
X  supporting documentation, and that the name of Fuji Xerox Co.,Ltd.,
! FUJITSU LIMITED, Sun Microsystems, Inc. and Sony Corporation not be
! used in advertising or publicity pertaining to distribution of the
! software without specific, written prior permission.
! Fuji Xerox Co.,Ltd., FUJITSU LIMITED and Sony Corporation make
X  no representations about the suitability of this software for any
X  purpose.  It is provided "as is" without express or implied warranty.
X  
! FUJI XEROX CO.,LTD., FUJITSU LIMITED, SUN MICROSYSTEMS AND
! SONY CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
! INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
! IN NO EVENT SHALL FUJI XEROX CO.,LTD., FUJITSU LIMITED,
! SUN MICROSYSTEMS AND SONY CORPORATION BE LIABLE FOR ANY SPECIAL,
! INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
X  RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
X  CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
X  CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X  
X    Auther: Kazunori Nishihara,  Fuji Xerox Co.,Ltd.
X            Takashi Fujiwara     FUJITSU LIMITED
X            Hideki Hiura         Sun Microsystems, Inc.
!           Makoto Wakamatsu     Sony Corporation
X  ******************************************************************/
X  
X  #define NEED_EVENTS
***************
*** 266,280 ****
X      }
X  }
X  
! static int      _time_flag = 0;
! #ifdef XIMP_SIGNAL
! static int
! _time_out()
X  {
!     _time_flag = 1;
X  }
- #endif				/* XIMP_SIGNAL */
X  
X  void
X  _Ximp_CallPreeditDrawCallback2(xic, event)
X      Ximp_XIC        xic;
--- 267,307 ----
X      }
X  }
X  
! static Bool
! _Ximp_DCMPredicate( d, ev, arg0 )
! Display		*d;
! XEvent		*ev;
! XPointer	arg0;
X  {
!     XimpCMPredicateArg	arg = (XimpCMPredicateArg)arg0;
!     ICID		icid;
!     int			n;
! 
!     if( ev->type == ClientMessage ) {
! 	if( ev->xclient.message_type == arg->type ) {
! 	    if( ev->xclient.format == 8 ) {
! 		for( icid = 0, n = 0; n < 4; n++ ) {
! 		    icid <<= 8;
! 		    icid += ev->xclient.data.b[n];
! 		}
! 		if( icid == arg->icid )
! 		    return( True );
! 	    }
! 	    else if( ev->xclient.format == 32  &&
! 		     ev->xclient.data.l[0] == XIMP_ERROR  &&
! 		     ev->xclient.data.l[1] == arg->icid ) {
! 		return( True );
! 	    }
! 	}
!     }
!     else if( ev->type == DestroyNotify ) {
! 	if( ev->xdestroywindow.window == arg->owner ) {
! 	    return( True );
! 	}
!     }
X  }
X  
+ 
X  void
X  _Ximp_CallPreeditDrawCallback2(xic, event)
X      Ximp_XIC        xic;
***************
*** 291,296 ****
--- 318,324 ----
X      Atom            type;
X      int             format;
X      unsigned long   nitems, after;
+     XimpCMPredicateArgRec	Arg;
X  
X      bzero(&CallData, sizeof(XIMPreeditDrawCallbackStruct));
X      bzero(&cbtext, sizeof(XIMText));
***************
*** 347,377 ****
X  	    /*
X  	     * Following Client message must be the preedit string.
X  	     */
! #ifdef XIMP_SIGNAL
! 	    signal(SIGALRM, _time_out);
! 	    alarm(XIMP_TIME_OUT);
! #endif				/* XIMP_SIGNAL */
! 	    while (_time_flag != 1) {
! 		if ((XCheckTypedEvent(xic->core.im->core.display, ClientMessage, &ev)) == False) {
! #ifdef XIMP_SIGNAL
! 		    sleep(1);
! #endif				/* XIMP_SIGNAL */
! 		    continue;
! 		}
! 		if (ev.xclient.message_type != ((Ximp_XIM) xic->core.im)->ximp_impart->improtocol_id) {
! 		    XPutBackEvent(xic->core.im->core.display, &ev);
! 		    continue;
! 		} else {
! #ifdef XIMP_SIGNAL
! 		    alarm(0);
! #endif				/* XIMP_SIGNAL */
! 		    break;
! 		}
! 	    }
X  
X  	    ctlen = ev.xclient.data.b[4];
X  	    length = ctlen * XIMP_MB_CUR_MAX(xic->core.im->core.lcd);
- 	    _time_flag = 0;
X  	    
X  	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
X  		cbtext.string.wide_char = (wchar_t *) Xmalloc((length + 1) * sizeof(wchar_t));
--- 375,388 ----
X  	    /*
X  	     * Following Client message must be the preedit string.
X  	     */
! 	    Arg.type = ((Ximp_XIM)xic->core.im)->ximp_impart->improtocol_id;
! 	    Arg.owner = ((Ximp_XIM)xic->core.im)->ximp_impart->fe_window;
! 	    Arg.icid = xic->ximp_icpart->icid;
! 	    if( !_XimpIfEvent( xic, &ev, _Ximp_DCMPredicate, (XPointer)&Arg ) )
! 		return;
X  
X  	    ctlen = ev.xclient.data.b[4];
X  	    length = ctlen * XIMP_MB_CUR_MAX(xic->core.im->core.lcd);
X  	    
X  	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
X  		cbtext.string.wide_char = (wchar_t *) Xmalloc((length + 1) * sizeof(wchar_t));
***************
*** 648,659 ****
X      Ximp_XIC        xic;
X      XClientMessageEvent *event;
X  {
!     register XIMCallback *cb;
!     char           *text;
!     int             length;
X      XIMStatusDrawCallbackStruct CallData;
!     XIMText         cbtext;
!     XEvent          ev;
X  
X      cb = &xic->core.status_attr.callbacks.draw;
X      CallData.type = ToXIMStatusDataType(event->data.l[2]);
--- 659,671 ----
X      Ximp_XIC        xic;
X      XClientMessageEvent *event;
X  {
!     register XIMCallback	*cb;
!     char			*text;
!     int             		length;
X      XIMStatusDrawCallbackStruct CallData;
!     XIMText         		cbtext;
!     XEvent          		ev;
!     XimpCMPredicateArgRec	Arg;
X  
X      cb = &xic->core.status_attr.callbacks.draw;
X      CallData.type = ToXIMStatusDataType(event->data.l[2]);
***************
*** 660,687 ****
X      if (CallData.type == XIMTextType) {
X  	CallData.data.text = &cbtext;
X  
! #ifdef XIMP_SIGNAL
! 	signal(SIGALRM, _time_out);
! 	alarm(XIMP_TIME_OUT);
! #endif				/* XIMP_SIGNAL */
! 	while (_time_flag != 1) {
! 	    if ((XCheckTypedEvent(xic->core.im->core.display, ClientMessage, &ev)) == False) {
! #ifdef XIMP_SIGNAL
! 		sleep(1);
! #endif				/* XIMP_SIGNAL */
! 		continue;
! 	    }
! 	    if (ev.xclient.message_type != ((Ximp_XIM) xic->core.im)->ximp_impart->improtocol_id) {
! 		XPutBackEvent(xic->core.im->core.display, &ev);
! 		continue;
! 	    } else {
! #ifdef XIMP_SIGNAL
! 		alarm(0);
! #endif				/* XIMP_SIGNAL */
! 		break;
! 	    }
! 	}
! 	_time_flag = 0;
X  	if (cb->callback) {
X  	    length = ev.xclient.data.b[4];
X  	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
--- 672,683 ----
X      if (CallData.type == XIMTextType) {
X  	CallData.data.text = &cbtext;
X  
! 	Arg.type = ((Ximp_XIM)xic->core.im)->ximp_impart->improtocol_id;
! 	Arg.owner = ((Ximp_XIM)xic->core.im)->ximp_impart->fe_window;
! 	Arg.icid = xic->ximp_icpart->icid;
! 	if( !_XimpIfEvent( xic, &ev, _Ximp_DCMPredicate, (XPointer)&Arg ) )
! 	    return;
! 
X  	if (cb->callback) {
X  	    length = ev.xclient.data.b[4];
X  	    if (((Ximp_XIM) xic->core.im)->ximp_impart->use_wchar) {
*** /tmp/d13727	Sat Aug  1 11:06:32 1992
--- mit/lib/X/Ximp/XimpIC.c	Sat Aug  1 11:06:28 1992
***************
*** 1,4 ****
! /* $XConsortium: XimpIC.c,v 1.6 92/04/14 13:29:06 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, 1992 by FUJITSU LIMITED
--- 1,4 ----
! /* $XConsortium: XimpIC.c,v 1.7 92/07/29 10:15:50 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, 1992 by FUJITSU LIMITED
***************
*** 136,142 ****
X  						_Ximp_XimFilter_Keypress,
X  						(XPointer)ic);
X  			ic->ximp_icpart->filter_mode |= 0x1;
! 		}
X  	}
X  	return((XIC)ic);
X  
--- 136,147 ----
X  						_Ximp_XimFilter_Keypress,
X  						(XPointer)ic);
X  			ic->ximp_icpart->filter_mode |= 0x1;
! 			_XRegisterFilterByType(ic->core.im->core.display,
! 					       ic->core.focus_window,
! 					       ClientMessage, ClientMessage,
! 					       _Ximp_XimFilter_Client, NULL);
! 			ic->ximp_icpart->filter_mode |= 0x2;
! 		    }
X  	}
X  	return((XIC)ic);
X  
***************
*** 162,167 ****
--- 167,176 ----
X  				   _Ximp_XimFilter_Client, (XPointer)NULL);
X  	}
X   	_Ximp_IM_SendMessage(ic, XIMP_DESTROY, NULL, NULL, NULL);
+ 	if( ic->ximp_icpart->preedit_font )
+ 	    Xfree( ic->ximp_icpart->preedit_font );
+ 	if( ic->ximp_icpart->status_font )
+ 	    Xfree( ic->ximp_icpart->status_font );
X  	Xfree(ic->ximp_icpart);
X  	return;
X  }
***************
*** 201,222 ****
X  _Ximp_SetFocusWindow(ic)
X  	Ximp_XIC	 ic;
X  {
- 	Atom		 actual_type;
- 	int		 actual_format;
- 	unsigned long	 nitems, bytes_after;
- 	int		*prop_int;
- 
- 	while(1) {
- 		XGetWindowProperty(ic->core.im->core.display,
- 			ic->core.client_window,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id,
- 			0L, 1000000L, False, XA_WINDOW,
- 			&actual_type, &actual_format, &nitems, &bytes_after,
- 			(unsigned char **)&prop_int);
- 		if(nitems == 0)
- 			break;
- 		XFree((XPointer)prop_int);
- 		}
X  	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
X  			((Ximp_XIM)ic->core.im)->ximp_impart->focus_win_id,
X  			XA_WINDOW, 32, PropModeReplace,
--- 210,215 ----
***************
*** 253,262 ****
X  	Ximp_XIC		 ic;
X  {
X  	Ximp_PreeditPropRec	*preedit_atr;
- 	Atom			 actual_type;
- 	int			 actual_format;
- 	unsigned long		 nitems, bytes_after;
- 	int			*prop_int;
X  	unsigned char		 prop_data[XIMP_PREEDIT_MAX_CHAR];
X  
X  	preedit_atr = &(ic->ximp_icpart->preedit_attr);
--- 246,251 ----
***************
*** 275,292 ****
X  	_Ximp_AttributesSetL(prop_data, preedit_atr->SpotLocation.x,    48);
X  	_Ximp_AttributesSetL(prop_data, preedit_atr->SpotLocation.y,    52);
X  
- 	while(1) {
- 		XGetWindowProperty(ic->core.im->core.display,
- 			ic->core.client_window,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
- 			0L, 1000000L, False,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
- 			&actual_type, &actual_format, &nitems, &bytes_after,
- 			(unsigned char **)(&prop_int));
- 		if(nitems == 0)
- 			break;
- 		XFree((XPointer)prop_int);
- 		}
X  	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
X  			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
X  			((Ximp_XIM)ic->core.im)->ximp_impart->preedit_atr_id,
--- 264,269 ----
***************
*** 298,320 ****
X  _Ximp_SetPreeditFont(ic)
X  	Ximp_XIC		 ic;
X  {
- 	Atom			actual_type;
- 	int			actual_format;
- 	unsigned long		nitems, bytes_after;
- 	char			*prop;
- 
X  	if (ic->core.preedit_attr.fontset != NULL) {
- 	    while(1) {
- 		XGetWindowProperty(ic->core.im->core.display,
- 			ic->core.client_window,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id,
- 			0L, 1000000L, False, XA_STRING,
- 			&actual_type, &actual_format, &nitems, &bytes_after,
- 			(unsigned char **)&prop);
- 		if(nitems == 0)
- 			break;
- 		XFree((XPointer)prop);
- 	        }
X  	    XChangeProperty(ic->core.im->core.display, ic->core.client_window,
X  			((Ximp_XIM)ic->core.im)->ximp_impart->preeditfont_id,
X  			XA_STRING, 8, PropModeReplace,
--- 275,281 ----
***************
*** 329,338 ****
X  	Ximp_XIC		 ic;
X  {
X  	Ximp_StatusPropRec	*status_atr;
- 	Atom			 actual_type;
- 	int			 actual_format;
- 	unsigned long		 nitems, bytes_after;
- 	int			*prop_int;
X  	unsigned char		 prop_data[XIMP_STATUS_MAX_CHAR];
X  
X  	status_atr = &(ic->ximp_icpart->status_attr);
--- 290,295 ----
***************
*** 350,367 ****
X  	_Ximp_AttributesSetL(prop_data, status_atr->AreaNeeded.height, 44);
X  	_Ximp_AttributesSetL(prop_data, status_atr->window,            48);
X  
- 	while(1) {
- 		XGetWindowProperty(ic->core.im->core.display,
- 			ic->core.client_window,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
- 			0L, 1000000L, False,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
- 			&actual_type, &actual_format, &nitems, &bytes_after,
- 			(unsigned char **)&prop_int);
- 		if(nitems == 0)
- 			break;
- 		XFree((XPointer)prop_int);
- 		}
X  	XChangeProperty(ic->core.im->core.display, ic->core.client_window,
X  			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
X  			((Ximp_XIM)ic->core.im)->ximp_impart->status_atr_id,
--- 307,312 ----
***************
*** 373,395 ****
X  _Ximp_SetStatusFont(ic)
X  	Ximp_XIC		ic;
X  {
- 	Atom			actual_type;
- 	int			actual_format;
- 	unsigned long		nitems, bytes_after;
- 	char			*prop;
- 
X  	if (ic->core.status_attr.fontset != NULL) {
- 	    while(1) {
- 		XGetWindowProperty(ic->core.im->core.display,
- 			ic->core.client_window,
- 			((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id,
- 			0L, 1000000L, False, XA_STRING,
- 			&actual_type, &actual_format, &nitems, &bytes_after,
- 			(unsigned char **)&prop);
- 		if(nitems == 0)
- 			break;
- 		XFree((XPointer)prop);
- 		}
X  	    XChangeProperty(ic->core.im->core.display, ic->core.client_window,
X  			((Ximp_XIM)ic->core.im)->ximp_impart->statusfont_id,
X  			XA_STRING, 8, PropModeReplace,
--- 318,324 ----
*** /tmp/d13760	Sat Aug  1 11:06:52 1992
--- mit/lib/X/Ximp/XimpIM.c	Sat Aug  1 11:06:47 1992
***************
*** 1,8 ****
! /* $XConsortium: XimpIM.c,v 1.6 92/04/14 13:29:18 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporaion
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
--- 1,8 ----
! /* $XConsortium: XimpIM.c,v 1.8 92/07/29 10:16:10 rws Exp $ */
X  /******************************************************************
X  
X                Copyright 1991, 1992 by FUJITSU LIMITED
!               Copyright 1991, 1992 by Sony Corporation
X  
X  Permission to use, copy, modify, distribute, and sell this software
X  and its documentation for any purpose is hereby granted without fee,
***************
*** 26,32 ****
X  PERFORMANCE OF THIS SOFTWARE.
X  
X    Author: Takashi Fujiwara     FUJITSU LIMITED 
! 	  Makoto Wakamatsu     Sony Corporaion
X  
X  ******************************************************************/
X  
--- 26,32 ----
X  PERFORMANCE OF THIS SOFTWARE.
X  
X    Author: Takashi Fujiwara     FUJITSU LIMITED 
! 	  Makoto Wakamatsu     Sony Corporation
X  
X  ******************************************************************/
X  
***************
*** 156,168 ****
X  		XFree( ximp_impart->process_start_keys->keys_list );
X  		XFree( ximp_impart->process_start_keys );
X  	}
! 	if(ximp_impart->connectserver) {
! 		for(i=0; i < Ximp_Xim_count; i++) {
! 			if(Ximp_Xim_List[i] == im) {
! 				Ximp_Xim_List[i] = NULL;
! 				break;
! 			}
X  		}
X  		_Ximp_SetupFreeExtension(im);
X  		_Ximp_SetupFree(ximp_impart->im_proto_vl,
X  				ximp_impart->im_styles,
--- 156,168 ----
X  		XFree( ximp_impart->process_start_keys->keys_list );
X  		XFree( ximp_impart->process_start_keys );
X  	}
! 	for(i=0; i < Ximp_Xim_count; i++) {
! 		if(Ximp_Xim_List[i] == im) {
! 			Ximp_Xim_List[i] = NULL;
! 			break;
X  		}
+ 	}
+ 	if(ximp_impart->connectserver) {
X  		_Ximp_SetupFreeExtension(im);
X  		_Ximp_SetupFree(ximp_impart->im_proto_vl,
X  				ximp_impart->im_styles,
***************
*** 255,262 ****
X  			XA_STRING, &actual_type, &actual_format, &nitems,
X  			&bytes_after, (unsigned char **)(&prop)) != Success)
X  		return(False);
! 	if((version = Xmalloc((sizeof(char) * nitems + 1))) == NULL)
X  		return(False);
X  	strncpy(version, prop, nitems);
X  	version[nitems] = '\0';
X  	XFree(prop);
--- 255,264 ----
X  			XA_STRING, &actual_type, &actual_format, &nitems,
X  			&bytes_after, (unsigned char **)(&prop)) != Success)
X  		return(False);
! 	if((version = Xmalloc((sizeof(char) * nitems + 1))) == NULL) {
SHAR_EOF
true || echo 'restore of fix-16 failed'
fi
echo 'End of  part 1'
echo 'File fix-16 is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
