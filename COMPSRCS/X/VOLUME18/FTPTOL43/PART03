Path: uunet!sun-barr!ames!elroy.jpl.nasa.gov!swrinde!mips!msi!dcmartin
From: Mike.Sullivan@EBay.Sun.COM (Mike Sullivan {AKA Simon BarSinister})
Newsgroups: comp.sources.x
Subject: v18i085: Ftptool 4.3 (XVIEW), Part03/12
Message-ID: <1992Aug18.153554.28670@msi.com>
Date: 18 Aug 92 15:35:54 GMT
References: <csx-18i083-ftptool-4.3@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 2223
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: Mike.Sullivan@EBay.Sun.COM (Mike Sullivan {AKA Simon BarSinister})
Posting-number: Volume 18, Issue 85
Archive-name: ftptool-4.3/part03

#!/bin/sh
# this is part.03 (part 3 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file ftptool.h continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 3; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping ftptool.h'
else
echo 'x - continuing file ftptool.h'
sed 's/^X//' << 'SHAR_EOF' >> 'ftptool.h' &&
X	Panel_item user_perms;
X	Panel_item group_perms;
X	Panel_item other_perms;
X	Panel_item dismiss;	/* for non-OPEN LOOK window managers */
};
X
EXTERN struct file_property_window local_file_properties, remote_file_properties;
X
struct about_window {
X	Frame	frame;
X	Panel	panel;
X	Textsw	message;
X	Panel_item	bottom_panel;
X	Panel_item	mail;
X	Panel_item	dismiss;	/* for non-OPEN LOOK window managers */
X	char	geometry[MAXGEOMETRYSIZE];
};
X
EXTERN struct about_window about_window;
X
struct feedback_window {
X	Frame	frame;
X	Panel	panel;
X	Panel_item	which;
X	Panel_item	other;
X	Textsw	feedback;
X	Panel_item	bottom_panel;
X	Panel_item	send;
X	Panel_item	cancel;
};
X
EXTERN struct feedback_window feedback_window;
X
struct schedule_window {
X	Frame	frame;
X	Panel	panel;
X	Panel_item	current_time;
X	Panel_item	process;
X	Panel_item	hosts;
X	Panel_item	options;
X	Panel_item	direction;
X	Panel_item	menu_name;
X	Panel_item	hour;
X	Panel_item	minute;
X	Panel_item	month;
X	Panel_item	day;
X	Panel_item	year;
X	Panel_item	send_list;
X	Panel_item	receive_list;
X	Panel_item	dismiss;	/* for non-OPEN LOOK window managers */
X	Frame	lsframe;
X	Panel_item	filename;
X	Panel_item	lsbutton;
X	int		visible;
X	char	geometry[MAXGEOMETRYSIZE];
};
X
EXTERN struct schedule_window schedule_window;
X
EXTERN Frame	tar_frame;
EXTERN Panel_item	tar_text;
EXTERN Panel_item	tar_button;
EXTERN Panel_item	tar_quit_button;	/* for non-OPEN LOOK window managers */
X
EXTERN Xv_font	list_font;
EXTERN Xv_font	bold_list_font;
X
EXTERN Xv_Cursor	busy_cursor;
EXTERN Xv_Cursor	normal_cursor;
X
EXTERN char *program_name;
EXTERN char *header_name;
EXTERN char *list_label;
X
#define MAXLINE 1024
X
EXTERN char	response_line[MAXLINE];
X
EXTERN char	scratch[MAXPATHLEN + MAXNAMLEN + 10];
EXTERN char	myhostname[MAXHOSTNAMELEN + 1];
X
EXTERN int connected;
EXTERN char icon_label[9];
EXTERN int dowhat;
X
EXTERN int local_list_nfiles;
EXTERN int local_list_ndirs;
EXTERN int local_list_nothers;
EXTERN int remote_list_nfiles;
EXTERN int remote_list_ndirs;
EXTERN int remote_list_nothers;
X
EXTERN int		timedout;
EXTERN int		list_changed;
EXTERN int		timestamped;
EXTERN int		nhostlist_items;
EXTERN int		nsenditems;
EXTERN int		nreceiveitems;
EXTERN int		current_year;
EXTERN int		current_month;
X
/* Properties */
EXTERN int		logging;
EXTERN int		keepalive;
EXTERN int		ignore_case;
EXTERN int		unique_local_names;
EXTERN int		unique_remote_names;
EXTERN int		remote_showdotfiles;
EXTERN int		local_showdotfiles;
EXTERN int		confirmdeletes;
EXTERN int		remote_sort_mode;
EXTERN int		remote_sort_direction;
EXTERN int		group_remote_files;
EXTERN int		local_sort_mode;
EXTERN int		local_sort_direction;
EXTERN int		group_local_files;
EXTERN char		*default_viewer;
EXTERN char		*archive_viewer;
EXTERN char		*postscript_viewer;
X
EXTERN double		click_timeout;
EXTERN int nbusyicons;
EXTERN Server_image busy_glyphs[];
EXTERN Server_image busy_glyphs[];
X
EXTERN Server_image directory_glyph;
EXTERN Server_image file_glyph;
EXTERN Server_image dotdot_glyph;
EXTERN Server_image unknown_glyph;
X
EXTERN unsigned short icon_array[];
X
EXTERN Server_image ftptool_glyph;
X
EXTERN struct hostlist *hostlist_head;
X
EXTERN FILE	*commandfp;
EXTERN FILE	*responsefp;
X
EXTERN char	*anonftp_password;
EXTERN char	*login_name;
X
EXTERN int	ftp_port;
EXTERN int	ftp_passthru_port;
EXTERN int	try_proxy;
EXTERN int	auto_connect;
X
EXTERN int	abort_transfer;
X
EXTERN int openlook_mode;
EXTERN int show_status;
X
EXTERN int non_unix;
X
EXTERN char *netrc_filename;
X
EXTERN char *dir_pattern;
X
/*
X FTP externs
X */
EXTERN int code;
X
EXTERN struct	sockaddr_in hisctladdr;
EXTERN struct	sockaddr_in data_addr;
EXTERN int	data;
EXTERN int	abrtflag;
EXTERN int	ptflag;
EXTERN int	verbose;
EXTERN int	debug;
EXTERN int	code;
EXTERN int	cpend;
EXTERN int	curtype;
EXTERN int	crflag;
EXTERN int	runique;
EXTERN int	sendport;
EXTERN struct sockaddr_in myctladdr;
EXTERN off_t	restart_point;
X
SHAR_EOF
echo 'File ftptool.h is complete' &&
chmod 0644 ftptool.h ||
echo 'restore of ftptool.h failed'
Wc_c="`wc -c < 'ftptool.h'`"
test 9377 -eq "$Wc_c" ||
	echo 'ftptool.h: original size 9377, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= tar_view.c ==============
if test -f 'tar_view.c' -a X"$1" != X"-c"; then
	echo 'x - skipping tar_view.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting tar_view.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'tar_view.c' &&
#include "ftptool.h"
X
static Panel_button_item	list_button;
static Panel_button_item	extract_button;
static Textsw	tar_output;
static Frame	cd_frame;
static Panel	cd_panel;
static Panel	cd_text;
X
static char *tarfile;
X
static int insert_error;
X
static unsigned short tar_icon_array[] = {
#include "./tar.viewer.icon"
};
X
#ifdef USE_PROTOTYPES
void handle_tarfile(char *filename)
#else
void handle_tarfile(filename)
char	*filename;
#endif
{
X	char	dir[MAXPATHLEN + 2];
X	Panel_button_item ex_button;
X	Rect	*butrect;
X	Icon	frame_icon;
X	Server_image tar_glyph;
X	void	tar_quit_proc();
X
X	if (getcwd(dir, sizeof(dir)) == NULL) {
X		fprintf(stderr, "getwd: %s\n", dir);
X		exit(1);
X	}
X
X	if (filename[0] != '/') {
X		/* should be in current directory. */
X		tarfile = (char *)malloc((unsigned int)(strlen(dir)+1+strlen(filename)+1));
X		if (tarfile == NULL) {
X			fprintf(stderr, "malloc failed\n");
X			exit(1);
X		}
X		sprintf(tarfile, "%s/%s", dir, filename);
X	} else
X		tarfile = strdup(filename);
X
X	sprintf(scratch, "Tar File Viewer - %s", filename);
X
X	base_window.frame = xv_create(XV_NULL, FRAME,
X		XV_LABEL, scratch,
X		XV_WIDTH, 430,
X		NULL);
X
X	tar_glyph = (Server_image )xv_create(XV_NULL,SERVER_IMAGE,
X        XV_WIDTH, 64,
X        XV_HEIGHT,64,
X        SERVER_IMAGE_DEPTH, 1,
X        SERVER_IMAGE_BITS,tar_icon_array,
X        NULL);
X
X	frame_icon = (Icon)xv_get(base_window.frame, FRAME_ICON);
X
X	xv_set(frame_icon, 
X		ICON_IMAGE, tar_glyph, 
X		ICON_TRANSPARENT, TRUE,
X		NULL);
X
X
X	base_window.panel = xv_create(base_window.frame, PANEL,
X		PANEL_LAYOUT, PANEL_HORIZONTAL,
X		XV_HELP_DATA, "ftptool:TarFileViewer",
X		NULL);
X	
X	list_button = xv_create(base_window.panel, PANEL_BUTTON,
X		PANEL_LABEL_STRING, "List Contents",
X		PANEL_NOTIFY_PROC, list_proc,
X		XV_HELP_DATA, "ftptool:TarFileListContents",
X		NULL);
X
X	extract_button = xv_create(base_window.panel, PANEL_BUTTON,
X		PANEL_LABEL_STRING, "Extract Files",
X		PANEL_NOTIFY_PROC, tar_extract_proc,
X		XV_HELP_DATA, "ftptool:TarFileExtractFiles",
X		NULL);
X
X	openlook_mode = defaults_get_boolean(
X		"ftptool.OpenLookMode", "Ftptool.OpenLookMode", TRUE);
X
X	if (!openlook_mode) {
X		tar_quit_button = xv_create(base_window.panel, PANEL_BUTTON,
X			PANEL_LABEL_STRING, "Quit",
X			PANEL_NOTIFY_PROC, tar_quit_proc,
X			XV_HELP_DATA, "ftptool:TarQuitButton",
X			NULL);
X	}
X
X	xv_set(base_window.panel, PANEL_LAYOUT, PANEL_HORIZONTAL, NULL);
X	window_fit_height(base_window.panel);
X
X	tar_output = xv_create(base_window.frame, TEXTSW,
X		XV_LABEL, "Tar Output",
X		XV_HEIGHT, 100,
X		NULL);
X	
X	window_fit(base_window.frame);
X
X	xv_set(base_window.frame, XV_SHOW, TRUE, NULL);
X
X	cd_frame = xv_create(base_window.frame, FRAME_CMD,
X		XV_LABEL, "Extract Directory",
X		NULL);
X
X	dpy = (Display *)xv_get(base_window.frame, XV_DISPLAY);
X	cd_panel = xv_get(cd_frame, FRAME_CMD_PANEL);
X
X	xv_set(cd_panel, 
X		PANEL_LAYOUT, PANEL_VERTICAL, 
X		NULL);
X
X	cd_text = xv_create(cd_panel, PANEL_TEXT,
X		PANEL_VALUE_DISPLAY_LENGTH, 40,
X		PANEL_VALUE_STORED_LENGTH, MAXPATHLEN + 1,
X		PANEL_LABEL_STRING, "Directory: ",
X		PANEL_LAYOUT, PANEL_HORIZONTAL,
X		PANEL_VALUE,dir,
X		XV_HELP_DATA, "ftptool:TarFileNameText",
X		NULL);
X
X	ex_button = xv_create(cd_panel, PANEL_BUTTON,
X		PANEL_NOTIFY_PROC, doextract_proc,
X		PANEL_LABEL_STRING, "Extract",
X		XV_HELP_DATA, "ftptool:TarFileNameButton",
X		NULL);
X	
X	xv_set(cd_panel, 
X		PANEL_DEFAULT_ITEM, ex_button, 
X		NULL);
X
X	window_fit(cd_panel);
X	window_fit(cd_frame);
X
X	butrect = (Rect *)xv_get(ex_button, XV_RECT);
X	xv_set(ex_button, 
X		XV_X, (int)xv_get(cd_panel, XV_WIDTH)/2 - butrect->r_width, 
X		NULL);
X
X	notify_interpose_destroy_func(base_window.frame, tar_destroy_func);
X	XFlush(dpy);
X	notify_start();
X
X	exit(0);
}
X
#ifdef USE_PROTOTYPES
void list_proc(void)
#else
void list_proc()
#endif
{
X	xv_set(base_window.frame, 
X		FRAME_BUSY, TRUE, 
X		NULL);
X	start_tar("tf", tarfile);
}
X
#ifdef USE_PROTOTYPES
void doextract_proc(void)
#else
void doextract_proc()
#endif
{
X	char	*dir;
X	extern char *sys_errlist[];
X	int		rval;
X
X	xv_set(base_window.frame, 
X		FRAME_BUSY, TRUE, 
X		NULL);
X	dir = (char *)xv_get(cd_text, PANEL_VALUE);
X	if (dir[0] == '\0') {
X		footer_message("Please type in a directory name", (char *)NULL);
X		xv_set(base_window.frame, 
X			FRAME_BUSY, FALSE, 
X			NULL);
X		return;
X	}
X	dir = expand_dirname(dir);
X	if (dir == NULL) {
X		fprintf(stderr, "Out of memory.\n");
X		xv_set(base_window.frame, 
X			FRAME_BUSY, FALSE, 
X			NULL);
X		return;
X	}
X	if (chdir(dir) == -1) {
X		if (errno == ENOENT) {
X			if (rval = ask_make_dir(dir)) {
X				if (rval != -1) {
X					footer_message("Could not make directory. Reason: %s",
X						sys_errlist[rval], (char *)NULL);
X				}
X				xv_set(base_window.frame, 
X					FRAME_BUSY, FALSE, 
X					NULL);
X				return;
X			}
X			if (chdir(dir) == -1) {
X				perror("chdir");
X				exit(1);
X			}
X		} else {
X			footer_message("Could not make directory. Reason: %s",
X					sys_errlist[errno], (char *)NULL);
X			xv_set(base_window.frame, 
X				FRAME_BUSY, FALSE, 
X				NULL);
X			return;
X		}
X	}
X	free(dir);
X	start_tar("xvf", tarfile);
}
X
#ifdef USE_PROTOTYPES
void tar_extract_proc(void)
#else
void tar_extract_proc()
#endif
{
X	int	x = xv_get(base_window.frame, XV_X) - 5;
X	int y = xv_get(base_window.frame, XV_Y);
X	int height = xv_get(cd_frame, XV_HEIGHT)  * 2;
X
X	y -= height;
X	if (x < 0 || x >= display_width)
X		x = 0;
X	if (y < 0 || y >= display_height)
X		y = 0;
X	xv_set(cd_frame, 
X		XV_X, x, 
X		XV_Y, y, 
X		XV_SHOW, TRUE, 
X		NULL);
}
X
#ifdef USE_PROTOTYPES
void start_tar(char *options, char *filename)
#else
void start_tar(options, filename)
char	*options;
char	*filename;
#endif
{
X	int		pipe_fds[2];
X	int		pid;
X
X	textsw_erase(tar_output, 0, TEXTSW_INFINITY);
X	if (pipe(pipe_fds) == -1) {
X		perror("pipe");
X		exit(1);
X	}
X	insert_error = 0;
X    switch(pid = fork()) {
X    case -1:
X        perror("fork");
X        exit(1);
X        break;
X    case 0: /* child */
X		/* dup standard out to pipe */
X		dup2(pipe_fds[1], 1);
X		dup2(pipe_fds[1], 2);
X		close(pipe_fds[0]);
X		close(pipe_fds[1]);
X        execlp("tar", "tar", options, filename, (char *)NULL);
X        perror("can not start viewer");
X        exit(1);
X    default:/* parent */
X		close(pipe_fds[1]);
X        notify_set_wait3_func(base_window.frame, notify_default_wait3, pid);
X
X        break;
X    }
X
X	notify_set_input_func(base_window.frame, input_func, pipe_fds[0]);
X	notify_set_wait3_func(base_window.frame, notify_default_wait3, pid);
}
X
#ifdef USE_PROTOTYPES
Notify_value input_func(Notify_client client, int fd)
#else
Notify_value input_func(client, fd)
Notify_client	client;
int	fd;
#endif
{
X	char	buf[80];
X	int		nread;
X
X	for (;;) {
X		nread = read(fd, buf, sizeof(buf));
X		if (nread == 0) {
X			notify_set_input_func(client, NOTIFY_FUNC_NULL, fd);
X			close(fd);
X			xv_set(base_window.frame, FRAME_BUSY, FALSE, NULL);
X			break;
X		}
X		if (nread == -1)
X			if (errno == EWOULDBLOCK) 
X				break;
X			else {
X				perror("read");
X				exit(1);
X			}
X		if (!insert_error && textsw_insert(tar_output,buf, nread) != nread)
X			insert_error = 1;
X		XFlush(dpy);
X	} 
X
X	return NOTIFY_DONE;
}
X
#ifdef USE_PROTOTYPES
Notify_value tar_destroy_func(Notify_client client, Destroy_status status)
#else
Notify_value tar_destroy_func(client, status)
Notify_client   client;
Destroy_status  status;
#endif
{
X    switch(status) {
X    case DESTROY_CHECKING:
X		break;
X    case DESTROY_CLEANUP:
X		return notify_next_destroy_func(client, status);
X		break;
X    case DESTROY_SAVE_YOURSELF:
X		break;
X    case DESTROY_PROCESS_DEATH:
X		break;
X    }
X    return NOTIFY_DONE;
}
X
X
#ifdef USE_PROTOTYPES
void	tar_quit_proc(void)
#else
void	tar_quit_proc()
#endif
{
X	exit(0);
}
SHAR_EOF
chmod 0644 tar_view.c ||
echo 'restore of tar_view.c failed'
Wc_c="`wc -c < 'tar_view.c'`"
test 7548 -eq "$Wc_c" ||
	echo 'tar_view.c: original size 7548, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= view_file.c ==============
if test -f 'view_file.c' -a X"$1" != X"-c"; then
	echo 'x - skipping view_file.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting view_file.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'view_file.c' &&
#include "ftptool.h"
X
#ifdef USE_PROTOTYPES
int start_viewer(char *filename, int isremote)
#else
int start_viewer(filename, isremote)
char	*filename;
int		isremote;
#endif
{
X	int		which;
X
X	which = file_type(filename);
X
X	switch(which) {
X	case COMPRESSED:
X		/* uncompress file */
X		if (isremote)
X			footer_message("Uncompressing %s\n", filename, (char *)NULL);
X		else
X			local_footer_message("Uncompressing %s\n", filename, (char *)NULL);
X		uncompress_file(filename, "-vf");
X		break;
X	case POSTSCRIPT:
X		if (isremote) {
X			footer_message("Starting PostScript viewer %s", 
X				postscript_viewer, (char *)NULL);
X		} else {
X			local_footer_message("Starting PostScript viewer %s", 
X				postscript_viewer, (char *)NULL);
X		}
X		fork_viewer(postscript_viewer, filename);
X		break;
X	case TARFILE:
X		if (isremote)
X			footer_message("Starting tar viewer", (char *)NULL);
X		else
X			local_footer_message("Starting tar viewer", (char *)NULL);
X		fork_viewer(archive_viewer, filename);
X		break;
X	default:
X		if (isremote) {
X			footer_message("Starting default viewer %s", 
X				default_viewer, (char *)NULL);
X		} else {
X			local_footer_message("Starting default viewer %s", 
X				default_viewer, (char *)NULL);
X		}
X		fork_viewer(default_viewer, filename);
X		break;
X	}
X	return which;
}
X
#ifdef USE_PROTOTYPES
void fork_viewer(char *program, char *filename)
#else
void fork_viewer(program, filename)
char	*program;
char	*filename;
#endif
{
X	int	pid;
X	char	**argv;
X	int		argc;
X	char	*arg;
X	int		percentf=0;
X
X	switch(pid = fork()) {
X	case -1:   
X		perror("fork");
X		break; 
X	case 0: /* child */
X		/* count number of words */
X		argc = 0;
X		arg = program;
X		while (*arg && isspace(*arg))
X			arg++;
X		while (*arg) {
X			/* found an arg */
X			argc++;
X			/* skip arg */
X			while (*arg && !isspace(*arg))	
X				arg++;
X			/* skip WS */
X			while (*arg && isspace(*arg))
X				arg++;
X		}
X		if (argc == 0) {
X			fprintf(stderr, "Null viewer.\n");
X			exit(1);
X		}
X		/* allocate argv[]  (extra entry in case no %f specified) */
X		argv = (char **)malloc((argc+2) * sizeof(char *));
X		if (argv == NULL) {
X			fprintf(stderr, "No memory. Cannot start viewer '%s'.\n",
X				program);
X			exit(1);
X		}
X		/* can munge program here, since it's in the child */
X		argc = 0;
X		arg = strtok(program, " \t\n");
X		while (arg) {
X			if (!strcmp(arg, "%f")) {
X				percentf++;
X				argv[argc] = filename;
X			} else {
X				argv[argc] = arg;
X			}
X			argc++;
X			arg = strtok((char *)NULL, " \t\n");
X		}
X		if (!percentf) {
X			argv[argc] = filename;
X			argc++;
X		}
X		argv[argc] = NULL;
X		/* %f means program name */
X		execvp(argv[0], argv);
X		fprintf(stderr, "viewer '%s' failed:", program);
X		perror("");
X		exit(1);
X	default:/* parent */
X		notify_set_wait3_func(base_window.frame, notify_default_wait3, pid);                    
X		break;                                  
X	}
}
X
#ifdef USE_PROTOTYPES
int file_type(char *filename)
#else
int file_type(filename)
char	*filename;
#endif
{
X	int		fd;
X	char	buf[10];
X	int		nread;
X	char	*ext;
X
X	if ((fd = open(filename, O_RDONLY)) == -1) {
X		goto out;
X	}
X	notify_do_dispatch();
X	nread = read(fd, buf, sizeof(buf));
X	notify_no_dispatch();
X	if (nread == -1) {
X		goto out;
X	}
X	close(fd);
X	/* check for compressed file. '.Z' and magic value from /etc/magic */
X	/*
X	 0       string          \037\235        compressed data
X	 */
X	if (strlen(filename) > (unsigned int)2) {
X		ext = filename + (strlen(filename) - 2);
X		if (!strcmp(ext, ".Z") && (buf[0] == '\037') && (buf[1] == '\235')) {
X				return COMPRESSED;
X		}
X	}
X	/* check for postscript. */
X	/*
X	 0       string          %!              PostScript document
X	 */
X	if ((buf[0] == '%') && (buf[1] == '!')) {
X		return POSTSCRIPT;
X	}
X	if (strlen(filename) > (unsigned int)3) {
X		ext = filename + (strlen(filename) - 3);
X		if (!strcmp(ext, ".ps"))
X				return POSTSCRIPT;
X	}
X	/* try .tar */
X	if (strlen(filename) > (unsigned int)4)  {
X		ext = filename + (strlen(filename) - 4);
X		if (!strcmp(ext, ".tar")) {
X			return TARFILE;
X		}
X	}
out:
X	return UNKNOWN;
}
X
#ifdef USE_PROTOTYPES
void uncompress_file(char *filename, char *options)
#else
void uncompress_file(filename, options)
char	*filename;
char	*options;
#endif
{
X	static char *argv[] = {
X		"uncompress",
X		"-vf",
X		0,
X		NULL,
X	};
X
X	argv[1] = options;
X	argv[2] = filename;
X	pipe_program(argv);
X
}
X
#ifdef USE_PROTOTYPES
void compress_file(char *filename, char *options)
#else
void compress_file(filename, options)
char	*filename;
char	*options;
#endif
{
X	static char *argv[] = {
X		"compress",
X		"-vf",
X		0,
X		NULL,
X	};
X
X	argv[1] = options;
X	argv[2] = filename;
X	pipe_program(argv);
X
}
X
#ifdef USE_PROTOTYPES
void pipe_program(char *argv[])
#else
void pipe_program(argv)
char	*argv[];
#endif
{
X	int	pid;
X	int pipe_fds[2];
X	char scratch[100];
X	FILE	*fp;
X
X	if (pipe(pipe_fds) == -1) {
X		perror("ftptool:pipe");
X		return;
X	}
X
X	switch(pid = fork()) {
X	case -1:   
X		perror("fork");
X		break; 
X	case 0: /* child */
X		dup2(pipe_fds[1], 1);
X		dup2(pipe_fds[1], 2);
X		close(pipe_fds[0]);
X		close(pipe_fds[1]);
X		execvp(argv[0], argv);
X		perror("can not start program");
X		exit(1);
X	default:/* parent */
X		notify_set_wait3_func(base_window.frame, notify_default_wait3, pid);
X		close(pipe_fds[1]);
X		break;                                  
X	}
X	fp = fdopen(pipe_fds[0], "r");
X	if (fp == NULL) {
X		perror("fopen");
X		close(pipe_fds[0]);
X		return;
X	}
X	notify_do_dispatch();
X	while (fgets(scratch, sizeof(scratch), fp) != NULL) {
X		notify_no_dispatch();
X		log_message(scratch);
X		notify_do_dispatch();
X	}
X	notify_no_dispatch();
X	fclose(fp);
}
X
#ifdef USE_PROTOTYPES
int view_local_file(char *name, int which, int *dirchanged)
#else
int view_local_file(name, which, dirchanged)
char	*name;
int		which;
int		*dirchanged;
#endif
{
X	char *dot;
X	struct stat buf;
X
X	if (stat(name, &buf) == -1) {
X		local_footer_message("%s: %s.", name, sys_errlist[errno]);
X		return 1;
X	}   
X	if (!S_ISREG(buf.st_mode)) {
X		local_footer_message("%s is not a regular file.", name);
X		return 1;
X	}
X	if (start_viewer(name,which==DOREMOTEVIEW) == COMPRESSED) {
X		dot = rindex(name, '.');
X		if (dot) {
X			*dot = '\0';
X			if (which == DOLOCALVIEW && dirchanged != NULL)
X				*dirchanged = 1;
X			start_viewer(name, which == DOREMOTEVIEW);
X		}
X	}
X	return 0;
}
X
char *newname;
X
#ifdef USE_PROTOTYPES
int view_remote_file(char *name, size_t size)
#else
int view_remote_file(name, size)
char	*name;
size_t	size;
#endif
{
X	static char *tmpname;
X
X	if (tmpname == NULL || (access(tmpname, F_OK) == -1 && errno == ENOENT)) {
X		tmpname = tempnam("/var/tmp", "ftptl");
X		if (tmpname == NULL || (mkdir(tmpname, 0777) == -1)) {
X			footer_message("Can't create temporary directory.", (char *)NULL);
X			return 1;
X		}
X	}
X	sprintf(scratch, "%s/%s", tmpname, name);
X	/* newname will be set if a unique local name is generated */
X	newname = NULL;
X	if (get_file(name, scratch, size)) {
X		return 1;
X	}
X
X	if (newname)
X		strcpy(scratch, newname);
X	
X	return view_local_file(scratch, DOREMOTEVIEW, (int *)NULL);
}
SHAR_EOF
chmod 0644 view_file.c ||
echo 'restore of view_file.c failed'
Wc_c="`wc -c < 'view_file.c'`"
test 6916 -eq "$Wc_c" ||
	echo 'view_file.c: original size 6916, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile ==============
if test -f 'Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
# Makefile generated by imake - do not edit!
# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
#
# The cpp used on this machine replaces all newlines and multiple tabs and
# spaces in a macro expansion with a single space.  Imake tries to compensate
# for this, but is not always successful.
#
X
# -------------------------------------------------------------------------
# Makefile generated from "Imake.tmpl" and </tmp/IIf.a13102>
# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
#
# Platform-specific parameters may be set in the appropriate <vendor>.cf
# configuration files.  Site-specific parameters should be set in the file
# site.def.  Full rebuilds are recommended if any parameters are changed.
#
# If your C preprocessor does not define any unique symbols, you will need
# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
# "make World" the first time).
#
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that need to come before
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
# -------------------------------------------------------------------------
# platform-specific configuration parameters - edit sun.cf to change
X
# platform:  $XConsortium: sun.cf,v 1.72.1.1 92/03/18 13:13:37 rws Exp $
X
# operating system:  SunOS 4.1.1
X
# $XConsortium: sunLib.rules,v 1.7 91/12/20 11:19:47 rws Exp $
X
.c.o:
X	$(CC) -c $(CFLAGS) $*.c
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that go after
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = gcc -fstrength-reduce -fpcc-struct-return
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = gcc -fstrength-reduce -fpcc-struct-return -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS = -B/usr/bin/
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -g kmem -m 2755
X
X      PROJECTROOT = /usr/X11/R5
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O2
X        CCOPTIONS =
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
# -------------------------------------------------------------------------
# X Window System Build Parameters
# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
# -------------------------------------------------------------------------
# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/X11/R5/lib
X           BINDIR = /usr/X11/R5/bin
X          INCROOT = /usr/X11/R5/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/X11/R5/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
# $XConsortium: sunLib.tmpl,v 1.14.1.1 92/03/17 14:58:46 rws Exp $
X
SHLIBLDFLAGS = -assert pure-text
PICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X       XMULIBONLY = -lXmu
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
# -------------------------------------------------------------------------
# Imake rules for building libraries, programs, scripts, and data files
# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
# -------------------------------------------------------------------------
# start of Imakefile
X
#OPENWINHOME = /usr/local/OW3
X
#Uncomment the appropriate one if necessary. You should not need
#either, as it should be determined by the program.
#XVIEW= -DXVIEW3
#XVIEW= -DXVIEW2
X
#Uncomment the following line for SunOS 4.X
DEFINES= $(XVIEW)
X
#Uncomment the following lines for SunOS 5.0.
#DEFINES= -DSYSV -DSVR4
#LIBSUNOS5= -R /usr/openwin/lib:/opt/openwin/lib:/usr/opt/openwin/lib \
#	-lsocket -lnsl
X
#Uncomment the following line for 386 SVR4.
#DEFINES= -DSYSV386 -DSYSV -DSVR4
X
SYS_LIBRARIES 	= -lm
LOCAL_LIBRARIES = -lxview -lolgx $(XLIB) $(LIBSUNOS5)
LDOPTIONS 		= -L$(OPENWINHOME)/lib
INCLUDES 		= -I$(OPENWINHOME)/include
X
HELPDIR			= $(OPENWINHOME)/lib/help
X
ICONS = busy1.ftptool.icon busy2.ftptool.icon busy3.ftptool.icon \
X	busy4.ftptool.icon ftptool.icon tar.viewer.icon
X
HEADERS = ftptool.h
X
SUBHEADERS= batch.h batch_struct.h button_funcs.h change_dir.h config.h \
X	create_main.h create_other.h dircache.h dircache_struct.h dirlist.h \
X	dirlist_struct.h dofuncs.h event.h ftp_var.h host_list.h \
X	host_list_struct.h main.h menu_funcs.h misc.h patchlevel.h readdir.h \
X	schedule.h schedule_struct.h tar_view.h transfer.h view_file.h
X
INFOFILES = ftptool.info
X
MANPAGES = ftptool.man
X
SRCS = batch.c button_funcs.c change_dir.c create_main.c create_other.c \
X	dircache.c dirlist.c dofuncs.c event.c ftp.c host_list.c lex.l main.c \
X	menu_funcs.c misc.c readdir.c schedule.c tar_view.c transfer.c view_file.c
X
OBJS = batch.o button_funcs.o change_dir.o create_main.o create_other.o \
X	dircache.o dirlist.o dofuncs.o event.o ftp.o host_list.o lex.o main.o \
X	menu_funcs.o misc.o readdir.o schedule.o tar_view.o transfer.o view_file.o
X
ALLFILES = ${HEADERS} ${INFOFILES} ${MANPAGES} ${ICONS} ${SRCS}
X
all:: ftptool
X
$(OBJS): $(HEADERS) $(SUBHEADERS)
X
X PROGRAM = ftptool
X
all:: ftptool
X
ftptool: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
install:: ftptool
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  ftptool $(DESTDIR)$(BINDIR)
X
install.man:: ftptool.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) ftptool.man $(DESTDIR)$(MANDIR)/ftptool.$(MANSUFFIX)
X
depend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
lint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
lint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
clean::
X	$(RM) $(PROGRAM)
X
install::
X	$(INSTALL) -c $(INSTMANFLAGS) ftptool.info $(HELPDIR)/ftptool.info
X
# -------------------------------------------------------------------------
# common rules for all Makefiles - do not edit
X
emptyrule::
X
clean::
X	$(RM_CMD) "#"*
X
Makefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
tags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
# -------------------------------------------------------------------------
# empty rules for directories that do not have SUBDIRS - do not edit
X
install::
X	@echo "install in $(CURRENT_DIR) done"
X
install.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
Makefiles::
X
includes::
X
# -------------------------------------------------------------------------
# dependencies generated by makedepend
X
SHAR_EOF
chmod 0644 Makefile ||
echo 'restore of Makefile failed'
Wc_c="`wc -c < 'Makefile'`"
test 11937 -eq "$Wc_c" ||
	echo 'Makefile: original size 11937, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= dirlist.c ==============
if test -f 'dirlist.c' -a X"$1" != X"-c"; then
	echo 'x - skipping dirlist.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting dirlist.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dirlist.c' &&
#include "ftptool.h"
X
#ifdef USE_PROTOTYPES
struct dirlist *new_dirlist(char *name, char *date, char *owner, 
X	char *group, mode_t mode, size_t size)
#else
struct dirlist *new_dirlist(name, date, owner, group, mode, size)
char	*name;
char	*date;
char	*owner;
char	*group;
mode_t	mode;
size_t	size;
#endif
{
X	struct dirlist *tmp;
X
X	tmp = (struct dirlist *)malloc(sizeof(struct dirlist));
X	if (tmp == NULL)
X		return NULL;
X	bzero((char *)tmp, sizeof(struct dirlist));
X	tmp->name = (char *)malloc((unsigned int)(strlen(name) + 1));
X	if (tmp->name == NULL) {
X		free_dirlist(tmp);
X		return NULL;
X	}
X
X	tmp->date = (char *)malloc((unsigned int)(strlen(date) + 1));
X	if (tmp->date == NULL) {
X		free_dirlist(tmp);
X		return NULL;
X	}
X
X	tmp->owner = (char *)malloc((unsigned int)(strlen(owner) + 1));
X	if (tmp->owner == NULL) {
X		free_dirlist(tmp);
X		return NULL;
X	}
X
X	tmp->group = (char *)malloc((unsigned int)(strlen(group) + 1));
X	if (tmp->group == NULL) {
X		free_dirlist(tmp);
X		return NULL;
X	}
X
X	strcpy(tmp->name, name);
X	strcpy(tmp->date, date);
X	strcpy(tmp->owner, owner);
X	strcpy(tmp->group, group);
X	tmp->mode = mode;
X	tmp->size = size;
X	tmp->next = NULL;
X	return tmp;
}
X
#ifdef USE_PROTOTYPES
struct dirlist *add_dirname(struct dirlist *head, char *name, char *date, 
X	char *owner, char *group, mode_t mode, size_t size, int sort_mode, 
X	int sort_direction)
#else
struct dirlist *add_dirname(head, name, date, owner, group, mode, 
X	size, sort_mode, sort_direction)
struct dirlist *head;
char	*name;
char	*date;
char	*owner;
char	*group;
mode_t	mode;
size_t	size;
int sort_mode;
int	sort_direction;
#endif
{
X	struct dirlist *tmp;
X	struct dirlist *oldnext = NULL;
X
X	if (non_unix)
X		sort_mode = SORTBYNAME;
X	switch(sort_mode) {
X	default:
X		fprintf(stderr, "Unknown sort mode in add_dirname.\n");
X		/* Fall through */
X	case SORTBYNAME:
X		if (sort_direction == ASCENDING)
X			tmp = sortupbyname(head, name);
X		else
X			tmp = sortdownbyname(head, name);
X		break;
X	case SORTBYDATE:
X		if (sort_direction == ASCENDING)
X			tmp = sortupbydate(head, date);
X		else
X			tmp = sortdownbydate(head, date);
X		break;
X	case SORTBYSIZE:
X		if (sort_direction == ASCENDING)
X			tmp = sortupbysize(head, size);
X		else
X			tmp = sortdownbysize(head, size);
X		break;
X	}
X	oldnext = tmp->next;
X	tmp->next = new_dirlist(name, date, owner, group, mode, size);
X	if (tmp->next == NULL) {
X		tmp->next = oldnext;
X		return NULL;
X	}
X
X	tmp->next->next = oldnext;
X	return head;
}
X
#ifdef USE_PROTOTYPES
struct dirlist *add_dirlist_struct(struct dirlist *head, 
X	struct dirlist *dlist, int sort_mode, int sort_direction)
#else
struct dirlist *add_dirlist_struct(head, dlist, sort_mode, sort_direction)
struct dirlist *head;
struct dirlist *dlist;
int sort_mode;
int	sort_direction;
#endif
{
X	struct dirlist *tmp;
X
X	if (non_unix)
X		sort_mode = SORTBYNAME;
X	switch(sort_mode) {
X	default:
X		fprintf(stderr, "Unknown sort mode in add_dirlist_struct.\n");
X		/* Fall through */
X	case SORTBYNAME:
X		if (sort_direction == ASCENDING)
X			tmp = sortupbyname(head, dlist->name);
X		else
X			tmp = sortdownbyname(head, dlist->name);
X		break;
X	case SORTBYDATE:
X		if (sort_direction == ASCENDING)
X			tmp = sortupbydate(head, dlist->date);
X		else
X			tmp = sortdownbydate(head, dlist->date);
X		break;
X	case SORTBYSIZE:
X		if (sort_direction == ASCENDING)
X			tmp = sortupbysize(head, dlist->size);
X		else
X			tmp = sortdownbysize(head, dlist->size);
X		break;
X	}
X	dlist->next = tmp->next;
X	tmp->next = dlist;
X	return head;
}
X
#ifdef USE_PROTOTYPES
void free_dirlist(struct dirlist *head)
#else
void free_dirlist(head)
struct dirlist *head;
#endif
{
X	struct dirlist *tmp;
X
X	while (head) {
X		tmp = head->next;
X		if (head->name)
X			free(head->name);
X		if (head->date)
X			free(head->date);
X		if (head->owner)
X			free(head->owner);
X		if (head->group)
X			free(head->group);
X		free((char *)head);
X		head = tmp;
X	}
}
X
/* alphabetical order */
#ifdef USE_PROTOTYPES
struct dirlist *sortupbyname(struct dirlist *head, char *name)
#else
struct dirlist *sortupbyname(head, name)
struct dirlist *head;
char	*name;
#endif
{
X	struct dirlist *tmp;
X	int		rval;
X
X	for (tmp = head; tmp->next != NULL; tmp = tmp->next) {
X		if (ignore_case)
X			rval = strcasecmp(name, tmp->next->name);
X		else
X			rval = strcmp(name, tmp->next->name);
X		if (rval < 0)
X			break; /* need to go before next entry. */
X	}
X	return tmp;
}
X
/* least recently modified */
#ifdef USE_PROTOTYPES
struct dirlist *sortupbydate(struct dirlist *head, char *date)
#else
struct dirlist *sortupbydate(head, date)
struct dirlist *head;
char	*date;
#endif
{
X	struct dirlist *tmp;
X
X	for (tmp = head; tmp->next != NULL; tmp = tmp->next) {
X		if (isearlier(date, tmp->next->date)) 
X			break; /* need to go before next entry. */
X	}
X	return tmp;
}
X
/* smallest to largest */
#ifdef USE_PROTOTYPES
struct dirlist *sortupbysize(struct dirlist *head, size_t size)
#else
struct dirlist *sortupbysize(head, size)
struct dirlist *head;
size_t	size;
#endif
{
X	struct dirlist *tmp;
X
X	for (tmp = head; tmp->next != NULL; tmp = tmp->next)
X		if (size <= tmp->next->size) 
X			break; /* need to go before next entry. */
X	return tmp;
}
X
static int cummonthdays[] = {
X	0,
X	31,
X	59,
X	90,
X	120,
X	151,
X	181,
X	212,
X	243,
X	273,
X	304,
X	334
};
X
#ifdef USE_PROTOTYPES
long	datetotime(char *date)
#else
long	datetotime(date)
char	*date;
#endif
{
X	struct tm tm;
X
X	/* "Aug 19 19:47" */
X	/* "Jan 10  1990" */
X
X	if (index(date, ':')) {
X		hour_time(date, &tm);
X		if (tm.tm_mon > current_month) 
X			tm.tm_year = current_year - 1;
X		else
X			tm.tm_year = current_year;
X	} else {
X		year_time(date, &tm);
X		tm.tm_hour = 0;
X		tm.tm_min = 0;
X	}
X	return (tm.tm_min + tm.tm_hour * 60
X		+ (tm.tm_year * 365 + tm.tm_mday + cummonthdays[tm.tm_mon]) * 1440);
}
X
#ifdef USE_PROTOTYPES
int isearlier(char *date1, char *date2)
#else
int isearlier(date1, date2)
char	*date1, *date2;
#endif
{
X	long	time1;
X	long	time2;
X
X
X	time1 = datetotime(date1);
X	time2 = datetotime(date2);
X
X	if (time1 < time2)
X		return 1;
X	return 0;
}
X
/* reverse alphabetical order */
#ifdef USE_PROTOTYPES
struct dirlist *sortdownbyname(struct dirlist *head, char *name)
#else
struct dirlist *sortdownbyname(head, name)
struct dirlist *head;
char	*name;
#endif
{
X	struct dirlist *tmp;
X	int		rval;
X
X	for (tmp = head; tmp->next != NULL; tmp = tmp->next) {
X		if (ignore_case)
X			rval = strcasecmp(name, tmp->next->name);
X		else
X			rval = strcmp(name, tmp->next->name);
X		if (rval > 0)
X			break; /* need to go before next entry. */
X	}
X	return tmp;
}
X
/* most recently modified */
#ifdef USE_PROTOTYPES
struct dirlist *sortdownbydate(struct dirlist *head, char *date)
#else
struct dirlist *sortdownbydate(head, date)
struct dirlist *head;
char	*date;
#endif
{
X	struct dirlist *tmp;
X
X	for (tmp = head; tmp->next != NULL; tmp = tmp->next) {
X		if (!isearlier(date, tmp->next->date)) {
X			break; /* need to go before next entry. */
X		}
X	}
X	return tmp;
}
X
/* largest to smallest */
#ifdef USE_PROTOTYPES
struct dirlist *sortdownbysize(struct dirlist *head, size_t size)
#else
struct dirlist *sortdownbysize(head, size)
struct dirlist *head;
size_t	size;
#endif
{
X	struct dirlist *tmp;
X
X	for (tmp = head; tmp->next != NULL; tmp = tmp->next)
X		if (size >= tmp->next->size) 
X			break; /* need to go before next entry. */
X	return tmp;
}
X
#ifdef USE_PROTOTYPES
void clear_slist(Panel panel_list)
#else
void clear_slist(panel_list)
Panel panel_list;
#endif
{
X	int		nitems, row;
X	struct dirlist *dotdot;
X
X	nitems = xv_get(panel_list, PANEL_LIST_NROWS);
X	if (nitems && (dotdot = (struct dirlist *)xv_get(panel_list, 
X		PANEL_LIST_CLIENT_DATA, 0))) {
X		dotdot->next = NULL;
X		free_dirlist(dotdot);
X	}
X	for (row = nitems - 1; row >= 0; row--) {
X		xv_set(panel_list,
X			PANEL_LIST_DELETE, row,
X			PANEL_PAINT, PANEL_NONE,
X			NULL);
X	}
X	panel_paint(panel_list, PANEL_CLEAR);
}
X
#ifdef USE_PROTOTYPES
void actual_dirlist_to_slist(Panel panel_list, struct dirlist *head, 
X	mode_t type, int showdotfiles)
#else
void actual_dirlist_to_slist(panel_list, head, type, showdotfiles)
Panel	panel_list;
struct dirlist *head;
mode_t	type;
int		showdotfiles;
#endif
{
X	struct dirlist *tmp;
X	int	row;
X	Xv_font	entry_font;
X	char *d;
X	Server_image entry_glyph;
X
X	row = 0;
X	for (tmp = head->next; tmp != NULL; tmp = tmp->next) {
X		if (type && ((type & S_IFMT) != (tmp->mode & S_IFMT)))
X			continue;
X		if ((tmp != head->next) && (tmp->name[0] == '.' && !showdotfiles))
X			continue;
X		d = tmp->date;
X		if (!strcmp(tmp->date, "unknown"))
X			d = "";
X		if (tmp->size == -1)
X			sprintf(scratch, "  %12s  %10s  %s", d, "", tmp->name);
X		else
X			sprintf(scratch, "  %12s  %10d  %s", d, tmp->size, tmp->name);
X
X		if (S_ISDIR(tmp->mode)) {
X			entry_font = bold_list_font;
X			if (row != 0)
X				entry_glyph = directory_glyph;
X			else
X				entry_glyph = dotdot_glyph;
X			strcat(scratch, "/");
X		} else if (S_ISREG(tmp->mode)) {
X			entry_font = list_font;
X			entry_glyph = file_glyph;
X		} else {
X			entry_font = list_font;
X			entry_glyph = unknown_glyph;
X		}
X		xv_set(panel_list,
X			PANEL_LIST_INSERT, row,
X			PANEL_LIST_STRING, row, scratch,
X			PANEL_LIST_FONT, row, entry_font,
X			PANEL_LIST_GLYPH, row, entry_glyph,
X			PANEL_LIST_CLIENT_DATA, row, tmp,
X			PANEL_PAINT, PANEL_NONE,
X			NULL);
X		row++;
X	} 
X
}
X
#ifdef USE_PROTOTYPES
void dirlist_to_slist(Panel panel_list, struct dirlist *head)
#else
void dirlist_to_slist(panel_list, head)
Panel	panel_list;
struct dirlist *head;
#endif
{
X	struct dirlist *tmp;
X	int	dotypesort = 0;
X	int	showdotfiles = 0;
X
X	add_dotdot(head);
X
X	if (panel_list == local_window.list) {
X		showdotfiles = local_showdotfiles;
X		if (group_local_files)
X			dotypesort = 1;
X	} else {
X		/* panel_list == base_window.list */
X		showdotfiles = remote_showdotfiles;
X		if (group_remote_files)
X			dotypesort = 1;
X	}
X			
X	if (dotypesort) {
X		/* have to insert backwards, since the routine inserts at 0 */
#ifdef S_IFIFO
X		actual_dirlist_to_slist(panel_list, head, S_IFIFO, showdotfiles);
#endif
#ifdef S_IFSOCK
X		actual_dirlist_to_slist(panel_list, head, S_IFSOCK, showdotfiles);
#endif
X		actual_dirlist_to_slist(panel_list, head, S_IFBLK, showdotfiles);
X		actual_dirlist_to_slist(panel_list, head, S_IFCHR, showdotfiles);
X		actual_dirlist_to_slist(panel_list, head, S_IFLNK, showdotfiles);
X		actual_dirlist_to_slist(panel_list, head, S_IFREG, showdotfiles);
X		actual_dirlist_to_slist(panel_list, head, S_IFDIR, showdotfiles);
X	} else {
X		actual_dirlist_to_slist(panel_list, head, 0, showdotfiles);
X	}
X
X	/* now remove '..' from list */
X	tmp = head->next;
X	head->next = head->next->next;
X	tmp->next = NULL;
X
X	/* all entries attached as client_data */
X	xv_set(panel_list, 
X		XV_SHOW, TRUE, 
X		NULL);
}
X
#ifdef USE_PROTOTYPES
void add_dotdot(struct dirlist *head)
#else
void add_dotdot(head)
struct dirlist *head;
#endif
{
X	struct dirlist *tmp;
X
X	tmp = new_dirlist("..", "unknown", "", "", S_IFDIR, (size_t)-1);
X	if (tmp == NULL)
X		return;
X
X	tmp->next = head->next;
X	head->next = tmp;
}
X
#ifdef USE_PROTOTYPES
struct dirlist *sort_dirlist(struct dirlist *head, int sort_mode, 
X	int sort_direction)
#else
struct dirlist *sort_dirlist(head, sort_mode, sort_direction)
struct dirlist *head;
int	sort_mode;
int	sort_direction;
#endif
{
X	struct dirlist *tmp;
X	struct dirlist *next;
X
X	if (head == NULL)
X		return NULL;
X	/* sort current list into new one */
X	tmp = head->next;
X	head->next = NULL;
X	while (tmp) {
X		next = tmp->next;
X		tmp->next = NULL;
X		add_dirlist_struct(head, tmp, sort_mode, sort_direction);
X		tmp = next;
X	}
X	return head;
}
X
static char *abbrev_month[] = {
X	"Jan", "Feb", "Mar", "Apr", "May", "Jun",
X	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
};
X
#ifdef USE_PROTOTYPES
void hour_time(char *date, struct tm *tm)
#else
void hour_time(date, tm)
char	*date;
struct tm *tm;
#endif
{
X	char	month[10];
X	int		i;
X
X	bzero((char *)tm, sizeof(struct tm));
X	sscanf(date, "%s%d%d:%d", month, &tm->tm_mday, 
X		&tm->tm_hour, &tm->tm_min);
X	for (i = 0; i < 12; i++)
X		if (!strncmp(month, abbrev_month[i], 3))
X			break;
X	if (i != 12)
X		tm->tm_mon = i;
}
X
#ifdef USE_PROTOTYPES
void year_time(char *date, struct tm *tm)
#else
void year_time(date, tm)
char	*date;
struct tm *tm;
#endif
{
X	char	month[10];
X	int		i;
X
X	bzero((char *)tm, sizeof(struct tm));
X	sscanf(date, "%s%d%d", month, &tm->tm_mday, &tm->tm_year);
X	for (i = 0; i < 12; i++)
X		if (!strncmp(month, abbrev_month[i], 3))
X			break;
X	if (i != 12)
X		tm->tm_mon = i;
X	if (tm->tm_year > 1900)
X		tm->tm_year -= 1900;
}
SHAR_EOF
chmod 0644 dirlist.c ||
echo 'restore of dirlist.c failed'
Wc_c="`wc -c < 'dirlist.c'`"
test 12320 -eq "$Wc_c" ||
	echo 'dirlist.c: original size 12320, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= lex.c ==============
if test -f 'lex.c' -a X"$1" != X"-c"; then
	echo 'x - skipping lex.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting lex.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'lex.c' &&
# include <stdio.h>
# define U(x) x
# define NLSTATE yyprevious=YYNEWLINE
# define BEGIN yybgin = yysvec + 1 +
# define INITIAL 0
# define YYLERR yysvec
# define YYSTATE (yyestate-yysvec-1)
# define YYOPTIM 1
# define YYLMAX 200
# define output(c) (void)putc(c,yyout)
#if defined(__cplusplus) || defined(__STDC__)
X	int yyback(int *, int);
X	int yyinput(void);
X	int yylook(void);
X	void yyoutput(int);
X	int yyracc(int);
X	int yyreject(void);
X	void yyunput(int);
X
#ifndef __STDC__
#ifndef yyless
X	void yyless(int);
#endif
#ifndef yywrap
X	int yywrap(void);
#endif
#endif
X
#endif
# define input() (((yytchar=yysptr>yysbuf?U(*--yysptr):getc(yyin))==10?(yylineno++,yytchar):yytchar)==EOF?0:yytchar)
# define unput(c) {yytchar= (c);if(yytchar=='\n')yylineno--;*yysptr++=yytchar;}
# define yymore() (yymorfg=1)
# define ECHO (void)fprintf(yyout, "%s",yytext)
# define REJECT { nstr = yyreject(); goto yyfussy;}
int yyleng; extern char yytext[];
int yymorfg;
extern char *yysptr, yysbuf[];
int yytchar;
FILE *yyin = {stdin}, *yyout = {stdout};
extern int yylineno;
struct yysvf { 
X	struct yywork *yystoff;
X	struct yysvf *yyother;
X	int *yystops;};
struct yysvf *yyestate;
extern struct yysvf yysvec[], *yybgin;
#undef ECHO
#include "ftptool.h"
X
#undef input
extern char *lex_string;
# define input() (((yytchar=yysptr>yysbuf?U(*--yysptr):*lex_string++)==10?(yylineno++,yytchar):yytchar)==0?0:yytchar)
# define YYNEWLINE 10
yylex(){
int nstr; extern int yyprevious;
while((nstr = yylook()) >= 0)
yyfussy: switch(nstr){
case 0:
if(yywrap()) return(0); break;
case 1:
X
# line 10 "lex.l"
{return(' ');}
break;
case 2:
X
# line 11 "lex.l"
X	{return(PERMS);}
break;
case 3:
X
# line 12 "lex.l"
X	{return(LINKS);}
break;
case 4:
X
# line 13 "lex.l"
X	{return(USER);}
break;
case 5:
X
# line 14 "lex.l"
X	{return(GROUP);}
break;
case 6:
X
# line 15 "lex.l"
X	{return(SIZE);}
break;
case 7:
X
# line 16 "lex.l"
X	{return(MONTH);}
break;
case 8:
X
# line 17 "lex.l"
X		{return(DAY);}
break;
case 9:
X
# line 18 "lex.l"
X	{return(TIME);}
break;
case 10:
X
# line 19 "lex.l"
X	{return(NAME);}
break;
case 11:
X
# line 20 "lex.l"
X	{return(SKIP);}
break;
case 12:
X
# line 21 "lex.l"
X	{return(NONUNIX);}
break;
case 13:
X
# line 22 "lex.l"
X	{return(LOWERNAME);}
break;
case 14:
X
# line 23 "lex.l"
X		{return(yytext[0]);}
break;
case -1:
break;
default:
(void)fprintf(yyout,"bad switch yylook %d",nstr);
} return(0); }
/* end of yylex */
X
yywrap()
{
X	return 1;
}
int yyvstop[] = {
0,
X
14,
0,
X
1,
14,
0,
X
1,
0,
X
14,
0,
X
14,
0,
X
14,
0,
X
14,
0,
X
14,
0,
X
14,
0,
X
14,
0,
X
14,
0,
X
14,
0,
X
14,
0,
X
8,
0,
X
10,
0,
X
6,
0,
X
11,
0,
X
9,
0,
X
4,
0,
X
5,
0,
X
3,
0,
X
7,
0,
X
2,
0,
X
13,
0,
X
12,
0,
0};
# define YYTYPE unsigned char
struct yywork { YYTYPE verify, advance; } yycrank[] = {
0,0,	0,0,	1,3,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	1,4,	1,5,	
4,5,	4,5,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	4,5,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	0,0,	0,0,	0,0,	
0,0,	1,6,	0,0,	51,57,	
0,0,	0,0,	7,17,	16,28,	
0,0,	1,7,	12,23,	27,39,	
1,8,	33,44,	9,19,	11,21,	
14,26,	1,9,	1,10,	1,11,	
2,6,	1,12,	6,16,	8,18,	
1,13,	1,14,	1,15,	10,20,	
2,7,	11,22,	13,24,	2,8,	
13,25,	15,27,	17,29,	18,30,	
2,9,	2,10,	2,11,	19,31,	
2,12,	20,32,	21,33,	2,13,	
2,14,	2,15,	22,34,	23,35,	
24,36,	25,37,	26,38,	28,40,	
30,41,	31,42,	32,43,	34,45,	
35,46,	36,47,	37,48,	38,49,	
39,50,	40,51,	41,52,	42,53,	
43,54,	45,55,	46,56,	55,58,	
58,59,	0,0,	0,0,	0,0,	
0,0};
SHAR_EOF
true || echo 'restore of lex.c failed'
fi
echo 'End of  part 3'
echo 'File lex.c is continued in part 4'
echo 4 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
