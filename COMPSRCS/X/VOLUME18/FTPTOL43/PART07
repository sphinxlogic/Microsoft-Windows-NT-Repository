Path: uunet!usc!elroy.jpl.nasa.gov!swrinde!mips!msi!dcmartin
From: Mike.Sullivan@EBay.Sun.COM (Mike Sullivan {AKA Simon BarSinister})
Newsgroups: comp.sources.x
Subject: v18i089: Ftptool 4.3 (XVIEW), Part07/12
Message-ID: <1992Aug18.153701.28906@msi.com>
Date: 18 Aug 92 15:37:01 GMT
References: <csx-18i083-ftptool-4.3@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1893
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: Mike.Sullivan@EBay.Sun.COM (Mike Sullivan {AKA Simon BarSinister})
Posting-number: Volume 18, Issue 89
Archive-name: ftptool-4.3/part07

#!/bin/sh
# this is part.07 (part 7 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file main.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 7; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping main.c'
else
echo 'x - continuing file main.c'
sed 's/^X//' << 'SHAR_EOF' >> 'main.c' &&
X        XV_WIDTH, 16,
X        XV_HEIGHT,16,
X        SERVER_IMAGE_DEPTH, 1,
X        SERVER_IMAGE_BITS,file_pr_array,
X        NULL);
X
X    dotdot_glyph = (Server_image )xv_create(XV_NULL,SERVER_IMAGE,
X        XV_WIDTH, 16,
X        XV_HEIGHT,16,
X        SERVER_IMAGE_DEPTH, 1,
X        SERVER_IMAGE_BITS,dotdot_pr_array,
X        NULL);
X
X    unknown_glyph = (Server_image )xv_create(XV_NULL,SERVER_IMAGE,
X        XV_WIDTH, 16,
X        XV_HEIGHT,16,
X        SERVER_IMAGE_DEPTH, 1,
X        SERVER_IMAGE_BITS,unknown_pr_array,
X        NULL);
X
X	create_base_window();
X
X	frame_icon = (Icon)xv_get(base_window.frame, FRAME_ICON);
X	xv_set(frame_icon, 
X		ICON_IMAGE, ftptool_glyph, 
X		ICON_TRANSPARENT, TRUE,
X		NULL);
X
X	normal_cursor = xv_create(base_window.frame, CURSOR,
X		CURSOR_SRC_CHAR, OLC_BASIC_PTR,
X		CURSOR_MASK_CHAR, OLC_BASIC_MASK_PTR,
X		CURSOR_OP, PIX_SRC | PIX_DST,
X		NULL);
X
X	busy_cursor = xv_create(base_window.frame, CURSOR,
X		CURSOR_SRC_CHAR, OLC_BUSY_PTR,
X		CURSOR_MASK_CHAR, OLC_BUSY_MASK_PTR,
X		CURSOR_OP, PIX_SRC | PIX_DST,
X		NULL);
X
X	busy_glyphs[0] = (Server_image )xv_create(XV_NULL,SERVER_IMAGE,
X        XV_WIDTH, 64,
X        XV_HEIGHT,64,
X        SERVER_IMAGE_DEPTH, 1,
X        SERVER_IMAGE_BITS,busy1_icon_array,
X        NULL);
X
X	busy_glyphs[1] = (Server_image )xv_create(XV_NULL,SERVER_IMAGE,
X        XV_WIDTH, 64,
X        XV_HEIGHT,64,
X        SERVER_IMAGE_DEPTH, 1,
X        SERVER_IMAGE_BITS,busy2_icon_array,
X        NULL);
X
X	busy_glyphs[2] = (Server_image )xv_create(XV_NULL,SERVER_IMAGE,
X        XV_WIDTH, 64,
X        XV_HEIGHT,64,
X        SERVER_IMAGE_DEPTH, 1,
X        SERVER_IMAGE_BITS,busy3_icon_array,
X        NULL);
X
X	busy_glyphs[3] = (Server_image )xv_create(XV_NULL,SERVER_IMAGE,
X        XV_WIDTH, 64,
X        XV_HEIGHT,64,
X        SERVER_IMAGE_DEPTH, 1,
X        SERVER_IMAGE_BITS,busy4_icon_array,
X        NULL);
X
X	create_local_window();
X
X	create_host_popup();
X
X	create_session_log();
X
X	create_property_window();
X
X	create_file_property_window(&local_file_properties, 
X		"Ftptool:Local File Properties");
X	create_file_property_window(&remote_file_properties, 
X		"Ftptool:Remote File Properties");
X
X	create_tar_file_popup();
X
X	create_about_window();
X
X	create_feedback_window();
X
X	create_schedule_window();
X
X	create_status_window();
X
X
X	/* make it so ftp doesn't blow when the data connection is closed */
X	/* if the remote filesystem fills up. */
X	signal(SIGPIPE, SIG_IGN);
X
X	/*
X	 * Turn control over to XView.
X	 */
X	notify_interpose_destroy_func(base_window.frame, destroy_func);
X	notify_set_signal_func(base_window.frame, sig_func, SIGINT, NOTIFY_SYNC);
X	notify_set_itimer_func(schedule_window.current_time, date_wrapper,
X		ITIMER_REAL, &date_timer, (struct itimerval *)NULL);
X	change_local_dir(".", 0);
X
X	xv_set(base_window.frame,
X		XV_SHOW, TRUE,
X		NULL);
X
X	XFlush(dpy);
X
X	update_date(1);
X
X	closed = xv_get(base_window.frame, FRAME_CLOSED);
X
X	XFlush(dpy);
X
X	if (host_window.visible) {
X		xv_set(host_window.frame,
X			XV_SHOW, TRUE,
#ifdef XVIEW3
X			FRAME_CMD_PIN_STATE, FRAME_CMD_PIN_IN,
#else
X			FRAME_CMD_PUSHPIN_IN, TRUE,
#endif
X			FRAME_CLOSED, closed,
X			NULL);
X	}
X	if (host_window.advanced.visible)
X		plus_proc();
X
X	XFlush(dpy);
X
X	if (local_window.visible) {
X		xv_set(local_window.frame,
X			XV_SHOW, TRUE,
#ifdef XVIEW3
X			FRAME_CMD_PIN_STATE, FRAME_CMD_PIN_IN,
#else
X			FRAME_CMD_PUSHPIN_IN, TRUE,
#endif
X			FRAME_CLOSED, closed,
X			NULL);
X	}
X
X	XFlush(dpy);
X
X	if (schedule_window.visible) {
X		xv_set(schedule_window.frame,
X			XV_SHOW, TRUE,
#ifdef XVIEW3
X			FRAME_CMD_PIN_STATE, FRAME_CMD_PIN_IN,
#else
X			FRAME_CMD_PUSHPIN_IN, TRUE,
#endif
X			FRAME_CLOSED, closed,
X			NULL);
X	}
X
X	XFlush(dpy);
X
X	if (status_window.visible) {
X		xv_set(status_window.frame,
X			XV_SHOW, TRUE,
#ifdef XVIEW3
X			FRAME_CMD_PIN_STATE, FRAME_CMD_PIN_IN,
#else
X			FRAME_CMD_PUSHPIN_IN, TRUE,
#endif
X			FRAME_CLOSED, closed,
X			NULL);
X	}
X
X	XFlush(dpy);
X
X	if (logging) {
X		xv_set(session_window.frame,
X			XV_SHOW, TRUE,
#ifdef XVIEW3
X			FRAME_CMD_PIN_STATE, FRAME_CMD_PIN_IN,
#else
X			FRAME_CMD_PUSHPIN_IN, TRUE,
#endif
X			FRAME_CLOSED, closed,
X			NULL);
X	}
X
X	XFlush(dpy);
X
X	for (;;) {
X		XFlush(dpy);
X		notify_start();
X		switch(dowhat) {
X		case DOCONNECT:
X			(void)doconnect();
X			break;
X		case DOGET:
X			doget();
X			break;
X		case DOBATCHGET:
X			dobatchget();
X			break;
X		case DOPUT:
X			doput();
X			break;
X		case DOBATCHPUT:
X			dobatchput();
X			break;
X		case DOLOCALVIEW:
X		case DOREMOTEVIEW:
X			doview(dowhat);
X			break;
X		case DOUNCOMPRESS:
X		case DOEXTRACT:
X		case DOCOMPRESS:
X		case DOTAR:
X		case DOGETTARFILENAME:
X			dofileop(dowhat);
X			break;
X		case DOREMOTECD:
X			doremotecd(0);
X			break;
X		case DOREMOTECDFORCE:
X			doremotecd(1);
X			break;
X		case DOREMOTEDOUBLECLICK:
X			remote_doubleclick();
X			break;
X		case DOSCHEDULE:
X			doschedule();
X			break;
X		case DODIR:
X		case DOLS:
X			list_remote_dir();
X			break;
X		case DOQUIT:
X			exit(0);
X			break;
X		}
X	}
}
X
#ifdef USE_PROTOTYPES
void load_xdefaults(void)
#else
void load_xdefaults()
#endif
{
X	char	*str;
X	int		ct;
X	char	*xapplresdir, res_file[MAXPATHLEN + 10];
X	char	*ftptool_defaults;
X	char	*ftptool_layout;
X
X	if ((xapplresdir = getenv("XAPPLRESDIR")) != NULL) {
X		sprintf(res_file, "%s/Ftptool", xapplresdir);
X		if (access(res_file, R_OK) == 0) {
X			defaults_load_db(res_file);
X		}
X	}
X	ftptool_defaults = find_dotfile(FTPTOOL_DEFAULTS);
X	if (ftptool_defaults) {
X		defaults_load_db(ftptool_defaults);
X		free(ftptool_defaults);
X	}
X	ftptool_layout = find_dotfile(FTPTOOL_LAYOUT);
X	if (ftptool_layout) {
X		defaults_load_db(ftptool_layout);
X		free(ftptool_layout);
X	}
X
X	ct = defaults_get_integer(
X		"openWindows.multiClickTimeout","OpenWindows.MultiClickTimeout",4);
X
X	click_timeout = ct/10.0;
X
X	logging = defaults_get_boolean(
X		"ftptool.LogSession", "Ftptool.LogSession", FALSE);
X
X	keepalive = defaults_get_boolean(
X		"ftptool.KeepConnectionAlive", "Ftptool.KeepConnectionAlive", FALSE);
X
X	if (keepalive != FALSE)
X		keepalive = 1 << 1;
X
X	auto_connect = defaults_get_boolean(
X		"ftptool.AutoConnect", "Ftptool.AutoConnect", FALSE);
X
X	show_status = defaults_get_boolean(
X		"ftptool.AutoShowStatus", "Ftptool.AutoShowStatus", FALSE);
X
X	if (show_status != FALSE)
X		show_status = 1 << 1;
X
X	try_proxy = defaults_get_boolean(
X		"ftptool.TryProxy", "Ftptool.TryProxy", FALSE);
X
X	if (try_proxy != FALSE)
X		try_proxy = 1 << 2;
X
X	unique_local_names = defaults_get_boolean(
X		"ftptool.GenUniqueLocalNames", "Ftptool.GenUniqueLocalNames", FALSE);
X
X	unique_remote_names = defaults_get_boolean(
X		"ftptool.GenUniqueRemoteNames", "Ftptool.GenUniqueRemoteNames", FALSE);
X	
X	if (unique_remote_names != FALSE)
X		unique_remote_names = 1 << 1;
X
X	str = defaults_get_string(
X		"ftptool.TransferMode", "Ftptool.TransferMode", "Binary");
X
X	confirmdeletes = defaults_get_boolean(
X		"ftptool.ConfirmDeletes", "Ftptool.ConfirmDeletes", TRUE);
X
X	dircache_size = defaults_get_integer_check(
X		"ftptool.DirectoryCacheSize", "Ftptool.DirectoryCacheSize", 5, 0, 20);
X
X
X	str = defaults_get_string(
X		"ftptool.SortField", "Ftptool.SortField", "Name");
X
X	remote_sort_mode = SORTBYNAME;
X
X	if (!strcmp(str, "Date"))
X		remote_sort_mode = SORTBYDATE;
X	else if (!strcmp(str, "Size"))
X		remote_sort_mode = SORTBYSIZE;
X
X	remote_sort_direction = defaults_get_integer(
X		"ftptool.SortOrder", "Ftptool.SortOrder", ASCENDING);
X
X	remote_showdotfiles = defaults_get_boolean(
X		"ftptool.ShowHiddenFiles", "Ftptool.ShowHiddenFiles", FALSE);
X
X	group_remote_files  = defaults_get_boolean(
X		"ftptool.SortGrouping", "Ftptool.SortGrouping", FALSE);
X
X	str = defaults_get_string(
X		"ftptool.LocalSortField", "Ftptool.LocalSortField", "Name");
X
X	local_sort_mode = SORTBYNAME;
X
X	if (!strcmp(str, "Date"))
X		local_sort_mode = SORTBYDATE;
X	else if (!strcmp(str, "Size"))
X		local_sort_mode = SORTBYSIZE;
X
X	local_sort_direction = defaults_get_integer(
X		"ftptool.LocalSortOrder", "Ftptool.LocalSortOrder", ASCENDING);
X
X	local_showdotfiles = defaults_get_boolean(
X		"ftptool.LocalShowHiddenFiles", "Ftptool.LocalShowHiddenFiles", FALSE);
X
X	group_local_files  = defaults_get_boolean(
X		"ftptool.LocalSortGrouping", "Ftptool.LocalSortGrouping", FALSE);
X
X	anonftp_password = defaults_get_string(
X		"ftptool.InitialPassword", "Ftptool.InitialPassword", (char *)NULL);
X
X	
X	if (anonftp_password)
X		anonftp_password = strdup(anonftp_password);
X
X	default_viewer = defaults_get_string(
X		"ftptool.DefaultViewer", "Ftptool.DefaultViewer", "textedit %f");
X
X	default_viewer = strdup(default_viewer);
X
X	archive_viewer = defaults_get_string(
X		"ftptool.ArchiveViewer", "Ftptool.ArchiveViewer", program_name);
X
X	archive_viewer = strdup(archive_viewer);
X
X	postscript_viewer = defaults_get_string(
X		"ftptool.PostScriptViewer", "Ftptool.PostScriptViewer", "pageview %f");
X
X	postscript_viewer = strdup(postscript_viewer);
X
X	openlook_mode = defaults_get_boolean(
X		"ftptool.OpenLookMode", "Ftptool.OpenLookMode", TRUE);
X
X	ignore_case = defaults_get_boolean(
X		"ftptool.IgnoreCase", "Ftptool.IgnoreCase", FALSE);
X
X	/* Windows */
X
X	host_window.visible = defaults_get_boolean(
X		"ftptool.HostInfoVisible", "Ftptool.HostInfoVisible", FALSE);
X
X	host_window.advanced.visible = defaults_get_boolean(
X		"ftptool.HostInfoAdvancedVisible", "Ftptool.HostInfoAdvancedVisible", 
X		FALSE);
X
X	local_window.visible = defaults_get_boolean(
X		"ftptool.LocalWindowVisible", "Ftptool.LocalWindowVisible", FALSE);
X
X	schedule_window.visible = defaults_get_boolean(
X		"ftptool.BatchWindowVisible", "Ftptool.BatchWindowVisible",FALSE);
X
X	status_window.visible = defaults_get_boolean(
X		"ftptool.StatusWindowVisible", "Ftptool.StatusWindowVisible",FALSE);
X
X	strcpy(base_window.geometry, 
X		defaults_get_string("ftptool.RemoteWindowGeometry",
X			"Ftptool.RemoteWindowGeometry", "")); 
X
X	strcpy(local_window.geometry, 
X		defaults_get_string("ftptool.LocalWindowGeometry",
X			"Ftptool.LocalWindowGeometry", "")); 
X
X	strcpy(host_window.geometry, 
X		defaults_get_string("ftptool.HostWindowGeometry",
X			"Ftptool.HostWindowGeometry", "")); 
X
X	strcpy(schedule_window.geometry, 
X		defaults_get_string("ftptool.BatchWindowGeometry",
X			"Ftptool.BatchWindowGeometry", "")); 
X
X	strcpy(session_window.geometry, 
X		defaults_get_string("ftptool.SessionWindowGeometry",
X			"Ftptool.SessionWindowGeometry", "")); 
X
X	strcpy(status_window.geometry, 
X		defaults_get_string("ftptool.StatusWindowGeometry",
X			"Ftptool.StatusWindowGeometry", "")); 
}
X
#ifdef USE_PROTOTYPES
void set_xdefaults(void)
#else
void set_xdefaults()
#endif
{
X	char	*str;
X
X	defaults_set_boolean("ftptool.LogSession", logging & 0x1);
X
X	defaults_set_boolean("ftptool.KeepConnectionAlive", keepalive & 0x2);
X
X	defaults_set_boolean("ftptool.GenUniqueLocalNames", 
X		unique_local_names & 0x1);
X
X	defaults_set_boolean("ftptool.GenUniqueRemoteNames", 
X		unique_remote_names & 0x2);
X
X	defaults_set_boolean("ftptool.ConfirmDeletes", confirmdeletes);
X
X	defaults_set_boolean("ftptool.AutoConnect", auto_connect & 0x1);
X
X	defaults_set_boolean("ftptool.AutoShowStatus", show_status & 0x2);
X
X	defaults_set_boolean("ftptool.TryProxy", try_proxy & 0x4);
X
X	defaults_set_integer("ftptool.DirectoryCacheSize", dircache_size);
X
X	switch(remote_sort_mode) {
X	default:
X		fprintf(stderr, "Unknown remote sort mode in set_xdefaults.\n");
X		/* Fall through */
X	case SORTBYNAME:
X		str = "Name";
X		break;
X	case SORTBYDATE:
X		str = "Date";
X		break;
X	case SORTBYSIZE:
X		str = "Size";
X		break;
X	}
X	defaults_set_string("ftptool.SortField", str);
X
X	defaults_set_integer("ftptool.SortOrder", remote_sort_direction);
X
X	defaults_set_boolean("ftptool.ShowHiddenFiles", remote_showdotfiles);
X
X	defaults_set_boolean("ftptool.SortGrouping", group_remote_files);
X
X	switch(local_sort_mode) {
X	default:
X		fprintf(stderr, "Unknown local sort mode in set_xdefaults.\n");
X		/* Fall through */
X	case SORTBYNAME:
X		str = "Name";
X		break;
X	case SORTBYDATE:
X		str = "Date";
X		break;
X	case SORTBYSIZE:
X		str = "Size";
X		break;
X	}
X
X	defaults_set_string("ftptool.LocalSortField", str);
X
X	defaults_set_integer("ftptool.LocalSortOrder", local_sort_direction);
X
X	defaults_set_boolean("ftptool.LocalShowHiddenFiles", local_showdotfiles);
X
X	defaults_set_boolean("ftptool.LocalSortGrouping", group_local_files);
X
X	defaults_set_boolean("ftptool.OpenLookMode", openlook_mode);
X
X	defaults_set_string("ftptool.DefaultViewer", default_viewer);
X
X	defaults_set_string("ftptool.ArchiveViewer", archive_viewer);
X
X	defaults_set_string("ftptool.PostScriptViewer", postscript_viewer);
X
X	defaults_set_string("ftptool.InitialPassword", anonftp_password);
X
}
X
#ifdef USE_PROTOTYPES
void save_xdefaults(void)
#else
void save_xdefaults()
#endif
{
X    char    *filename=NULL;
X	FILE	*fp;
X	char	*str;
X	char	*true = "True";
X	char	*false = "False";
X
X	filename = find_dotfile(FTPTOOL_DEFAULTS);
X	if (filename == NULL)
X		if ((filename = create_dotfile(FTPTOOL_DEFAULTS, 0644)) == NULL)
X			return;
X	if ((fp = fopen(filename, "w")) == NULL) {
X		footer_message("Could not save defaults: %s", sys_errlist[errno],
X			(char *)NULL);
X		return;
X	}
X	fprintf(fp, "ftptool.ArchiveViewer:\t%s\n", archive_viewer);
X	fprintf(fp, "ftptool.AutoConnect:\t%s\n", 
X		(auto_connect == 0) ? false : true);
X	fprintf(fp, "ftptool.AutoShowStatus:\t%s\n", 
X		((show_status & 2) == 0) ? false : true);
X	fprintf(fp, "ftptool.ConfirmDeletes:\t%s\n", 
X		(confirmdeletes == 0) ? false : true);
X	fprintf(fp, "ftptool.DefaultViewer:\t%s\n", default_viewer);
X	fprintf(fp, "ftptool.DirectoryCacheSize:\t%d\n", dircache_size);
X	fprintf(fp, "ftptool.GenUniqueLocalNames:\t%s\n", 
X		((unique_local_names & 1) == 0) ? false : true);
X	fprintf(fp, "ftptool.GenUniqueRemoteNames:\t%s\n", 
X		((unique_remote_names & 2) == 0) ? false : true);
X	fprintf(fp, "ftptool.IgnoreCase:\t%s\n", 
X		(ignore_case == 0) ? false : true);
X	fprintf(fp, "ftptool.InitialPassword:\t%s\n", anonftp_password);
X	fprintf(fp, "ftptool.KeepConnectionAlive:\t%s\n", 
X		((keepalive & 2) == 0) ? false : true);
X
X	fprintf(fp, "ftptool.LocalShowHiddenFiles:\t%s\n", 
X		(local_showdotfiles == 0) ? false : true);
X
X	switch(local_sort_mode) {
X	default:
X		fprintf(stderr, "Unknown local sort mode in save_xdefaults.\n");
X		/* Fall through */
X	case SORTBYNAME:
X		str = "Name";
X		break;
X	case SORTBYDATE:
X		str = "Date";
X		break;
X	case SORTBYSIZE:
X		str = "Size";
X		break;
X	}
X	fprintf(fp, "ftptool.LocalSortField:\t%s\n", str);
X	fprintf(fp, "ftptool.LocalSortGrouping:\t%d\n", group_local_files);
X	fprintf(fp, "ftptool.LocalSortOrder:\t%d\n", local_sort_direction);
X
X	fprintf(fp, "ftptool.LogSession:\t%s\n", 
X		((logging & 1) == 0) ? false : true);
X	fprintf(fp, "ftptool.OpenLookMode:\t%s\n", 
X		(openlook_mode == 0) ? false : true);
X	fprintf(fp, "ftptool.PostScriptViewer:\t%s\n", postscript_viewer);
X
X	fprintf(fp, "ftptool.ShowHiddenFiles:\t%s\n", 
X		(remote_showdotfiles == 0) ? false : true);
X	switch(remote_sort_mode) {
X	default:
X		fprintf(stderr, "Unknown remote sort mode in save_xdefaults.\n");
X		/* Fall through */
X	case SORTBYNAME:
X		str = "Name";
X		break;
X	case SORTBYDATE:
X		str = "Date";
X		break;
X	case SORTBYSIZE:
X		str = "Size";
X		break;
X	}
X	fprintf(fp, "ftptool.SortField:\t%s\n", str);
X	fprintf(fp, "ftptool.SortGrouping:\t%d\n", group_remote_files);
X	fprintf(fp, "ftptool.SortOrder:\t%d\n", remote_sort_direction);
X
X	fprintf(fp, "ftptool.TryProxy:\t%s\n", 
X		(try_proxy == 0) ? false : true);
X
X	fclose(fp);
X	footer_message("Defaults saved to %s.", filename, (char *)NULL);
X	free(filename);
}
SHAR_EOF
echo 'File main.c is complete' &&
chmod 0644 main.c ||
echo 'restore of main.c failed'
Wc_c="`wc -c < 'main.c'`"
test 18317 -eq "$Wc_c" ||
	echo 'main.c: original size 18317, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ftptool.man ==============
if test -f 'ftptool.man' -a X"$1" != X"-c"; then
	echo 'x - skipping ftptool.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ftptool.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ftptool.man' &&
.TH FTPTOOL 1 "22 June 1992" "X Version 11"
.SH NAME
ftptool \- A windowed interface to ftp.
.SH SYNOPSIS
.B ftptool 
[
.I 
generic-tool-arguments 
]
[
.I 
filename.tar
]
.SH DESCRIPTION
.LP
Ftptool is a (hopefully) easier interface to ftp. It hides the interaction with
ftp and the need for knowing commands like 'get' and 'put', and the difference
between 'get' and 'mget'. It provides the ability to transfer directories, 
which ftp by itself does not do, and has an extended form of ftp's .netrc file.
.SH OPTIONS
.TP
.B generic-tool-arguments
ftptool (should) accept the generic tool arguments described in xview(1).
.TP
.B filename.tar
The argument is a tar file (extension .tar). Instead of starting up as ftptool,
start up to examine the tar file. This is a simple tool to list the contents
of the tar file, and extract into a specified directory. Provided in this
manner to avoid a proliferation of programs.
.SH USAGE
.SS .Xdefaults File Options
.LP
You can specify a number of defaults using the .Xdefaults file. These can all
be set using the Properties window (options affecting window placement or
visibility are currently set depending on the current window configuration). 
Other than those controlling the size and placement of the windows, the 
options are, with the first value being the default:
X
.in +4
X
ftptool.ArchiveViewer              (ftptool)
ftptool.AutoConnect                (False/True)
ftptool.AutoShowStatus             (False/True)
ftptool.BatchWindowVisible         (False/True)
ftptool.ConfirmDeletes             (True/False)
ftptool.DefaultViewer              (textedit %f)
ftptool.DirectoryCacheSize         (5 {0 - 20})
ftptool.GenUniqueLocalNames        (False/True)
ftptool.GenUniqueRemoteNames       (False/True)
ftptool.HostInfoVisible            (False/True)
ftptool.HostInfoAdvancedVisible    (False/True)
ftptool.IgnoreCase                 (False/True)
ftptool.InitialPassword            (login@hostname)
ftptool.KeepConnectionAlive        (False/True)
ftptool.LocalShowHiddenFiles       (False/True)
ftptool.LocalSortField             (Name/Date/Size)
ftptool.LocalSortGrouping          (False/True)
ftptool.LocalSortOrder             (0/1) {Alphabetical}
ftptool.LocalWindowVisible         (False/True)
ftptool.LogSession                 (False/True)
ftptool.OpenLookMode               (True/False)
ftptool.PostScriptViewer           (pageview %f)
ftptool.ShowHiddenFiles            (False/True)
ftptool.SortField                  (Name/Date/Size)
ftptool.SortGrouping               (False/True)
ftptool.SortOrder                  (0/1) {Alphabetical}
ftptool.TryProxy                            (False/True)
X
.in -4
.LP
When saving defaults, ftptool now saves them in .ftptooldefaults in your
home directory (overwritting the existing information).
.SS Batch mode
.LP
Ftptool has a batch mode. Instead of selecting files in a directory, then having
to transfer all those files before leaving the directory, selections will
be saved in either a Send or Receive list. When you finally decide to copy
the files, they will all be copied at once (and they can be in different
directories). The hierarchy on the source machine is duplicated starting
at the current directory on the destination machine. For example, if you 
have these files in your Batch Receive list:
.in +4
X	/export/source/BSD
X	/usr/source/Games/NetHack3.10.tar.Z
X	/pub/gnu/gcc.tar.Z
.in -4
If your current local directory is /var/tmp, copying these to the local 
machine will create the files:
.in +4
X	/var/tmp/export/source/BSD
X	/var/tmp/usr/source/Games/NetHack3.10.tar.Z
X	/var/tmp/pub/gnu/gcc.tar.Z
.in -4
(and any other directories and files that are in a selected directory. 
Directories are recursively copied, as always). When this occurs is determined
by the Batch window.
X
.SS The Remote Window
.LP
This is where you usually interact with ftptool. It operates from the various
buttons described below.
X
.sp .5
.B File Menu
.sp .5
.RS
.TP 10
.B Copy
Copy selected files and/or directories from the local machine to the remote
machine, or from the remote machine to the local machine.
.TP
.B Delete
Delete selected files from the local machine, or the remote machine.
.TP
.B List Directory
List the current remote directory in the Session Log window. There are
two options, DIR and LS. They do the corresponding ftp commands. DIR can
be used to determine the output format of the host, so you can set the
DIR template appropriately.
.TP
.B Compress File
Compress the selected local files.
.TP
.B Uncompress File
Uncompress the selected local files.
.TP
.B Create Tar File
Create a tar file containing the selected local files.
.TP
.B Extract Tar File
Extract the selected tar files. This starts the 'tar viewer' for each file, 
which by default is ftptool.
.RE
.LP
.B View Menu
.sp .5
.RS
.TP 10
.B Remote File
Transfer the remote file to a temporary directory, uncompress if necessary,
then start the appropriate file viewer on the file. This will be the tar
viewer if the file ends in .tar, pageview if it is a PostScript file, or
the default viewer (textedit) otherwise.
.TP
.B Local File
Uncompress if necessary, then start the appropriate file viewer on the file.
This will be the tar viewer if the file ends in .tar, pageview if it is a
PostScript file, or the default viewer (textedit) otherwise.
.TP
.B Local Directory List
Show the local directory window.
.TP
.B Session Log
Show the session log window. Only active if logging is enabled.
.TP
.B Host Information
Show the host information window.
.TP
.B Transfer Status
Show the transfer status window.
.TP
.B Batch Schedule
Show the Batch Schedule window
.TP
.B About Ftptool
Show the About window.
.RE
.LP
.LP
.B Properties Menu
.sp .5
.RS
.TP 10
.B Tool Properties
Bring up the tool properties window. See the Properties section.
.TP
.B Local File
Show the local file properties window. This shows such elements as
permissions, owner, and group for the last selected file.
.TP
.B Remote File
Show the remote file properties window. This shows such elements as
permissions, owner, and group for the last selected file. If connected
to a non-UNIX machine, or one that has non-ls style 'dir' command output,
most fields will be "unknown".
.TP
.B Save Layout
Save the layout of ftptool. This includes the sizes of the windows, and
whether some of them are visibile. The layout is now saved in the 
file .ftptooldefaults in your home directory.
.RE
.TP
.B Connect Button
Try to connect to the host listed in the Host Information window. If
that window is not displayed, it will be displayed and a connection
will not be attempted.
.TP
.B Abort Button
Active only during a transfer. Abort the transfer of all the files selected
after the current one completes.
.TP
.B Remote Directory Field
Shows the current remote directory. This field is also editable, so you can
type in a directory and press return to change to it.
.TP
.B Remote Directory List
List of remote files in the current remote directory. Directories are
in bold, with a trailing '/'. You can double-click on a directory to change
to it, or use the pop-up menu. Sorting is controlled by properties. Several
useful functions are in the pop-up menu.
.SS Host Information Window
.TP
.B New Connection
Selecting this button clears the fields in the window. This would be selected
if you wish to connect to a new site. It does not try to connect.
.TP
.B Hosts
This is a menu of the hosts in your host list. Selecting a host fills in
the information below. In addition, if auto-connect is set, it will try
to connect to the host.
.TP
.B Host List
.sp .5
.RS
.TP 10
.B Save
Save the current host list. It will attempt to save to a file named .ftptoolrc
in your home directory. If that fails, it goes to the current directory.
.TP
.B Load 
Load the current host list. It will attempt to load from a file named .ftptoolrc
in your home directory. If that fails, it looks in your current directory.
.TP
.B Append .netrc
When ftptool is first started, it automatically reads the .ftptoolrc file.
If that is not found, it will look for a .netrc file and load from that using
a (very) basic method. If you already have a .ftptoolrc, and want to load
the .netrc too, use this option (this is primarily for earlier versions that
did not read the .netrc).
.B Add 
Add the current information into the list, based on the name in
the Alias field.
.TP
.B Change
This is the same as Add, but it will not ask for confirmation if the
alias already exists.
.TP
.B Delete
Delete the alias named by the Alias field from the list.
.RE
.LP
.TP
.B The Plus Button
When pressed, show the more advanced options of ftptool. There is
a companion Minus button which will hide those options.
.TP
.B Alias
The alias name. When .netrc entries are loaded, they appear as 'machine login'.
.TP
.B Last Visited
The last time you successfully connected to the host described by this alias.
If you have never connected, then "Never" is displayed. When ftptool updates
this field, the host alias list is marked as modified. It is not automatically
saved for you at this point. This field is only updated if you connect through
the host list, and not the current host window.
.B Comment
A comment describing this ftp sit (X sources, GNU software).
.TP
.B Proxy Host
The name of the host supporting proxy ftp. ftptool handles this the
way the Iftp program does (which is part of some consulting special).
.TP
.B Remote Host
The name of the remote host.
.TP
.B Login
The login name to use on the remote host.
.TP
.B Password
The password to give on the remote host. Characters in your password will 
be displayed as '*'. In the .ftptoolrc file, this field will be encrypted.
WARNING: The encryption algorithm is fairly simple, and made even more
breakable since ftptool source is freely available. Encrypting the password
allows you to look at it without divulging your passwords, but is not
unbreakable. For this reason, the .ftptoolrc file is mode 600.
.TP
.B Transfer Mode
The mode of transfer to use on the remote host. Before any transfer, this
is read, so you can change it as you work.
.TP
.B Remote Directory
The remote directory to change to upon connection. Perhaps you always want to
go to /pub/gnu on prep.ai.mit.edu.
.TP
.B Local Directory
The local directory to change to upon connection. Perhaps you always want to
go to /home/gnu when connecting to prep.ai.mit.edu.
.TP
.B DIR Template
Since ftptool can not know the format the 'dir' command (which is used to 
fill the remote list) displays on each host, you can tell ftptool the
format on a per-host basis. ftptool uses a default format, so unless
you have problems, you probably should leave it alone. If you need to
determine the format, either connect using normal ftp, or connect with
ftptool and use 'dir' in the Custom field. This will display in the session
window, so make sure you are logging.
X
The template is a series of keywords separated by whitespace or characters
that must match (so if there are dashes in the date, you theoretically
give MONTH-DAY-YEAR). The keywords are:
.in +4
.nf
PERMS - Normal UNIX permissions (drwxrwxrwx)
LINKS - Link count. Currently matched, but discarded.
USER - User name/number
GROUP - Group name/number
SIZE - File size
MONTH - Month (Dec, Jan, ...)
DAY	 - Day of week (number)
TIME - Hour:minute (09:49) or year (1991)
NAME - Filename.
SKIP - Discard characters until the next whitespace.
.fi
.in -4
Anything else must be matched exactly. The default is given in ftptool.h
as:
.in +4
PERMS LINKS USER GROUP SIZE MONTH DAY TIME NAME
.in -4
which matches the 'ls -lg' output:
X
.nf
-rw-r--r--  1 mike_s   develop      8636 Dec 20 09:49 transfer.o
.fi
A special case is the pattern NONUNIX. If this is present anywhere
in the template, it sets non-UNIX mode. Ftptool will only use 'ls' to
get directory listings, and will not expand environment variables
when trying to cd with the Remote Directory text field.
Also, ftptool will assume that all directory entries are normal files.
You can still attempt to double-click on the files to cd, though.
X
Another special case is the pattern LOWERNAMES. This causes all file
names read from the remote machine to be converted to lowercase. This
is for those machines that output data in uppercase, but can't handle
it in return (such as VMS).
X
.SS Local Directory Window
.TP
.B Local Directory Field
Shows the current local directory. This field is also editable, so you can
type in a directory and press return to change to it.
.TP
.B Free Space
Gives the amount and percentage of free space available in the file system
the directory is in.
.TP
.B Local Directory List
List of local files in the current local directory. Directories are
in bold, with a trailing '/'. You can double-click on a directory to change
to it, or use the pop-up menu. Sorting is controlled by properties. Several
useful functions are in the pop-up menu.
X
.SS Session Log Window
.LP
Shows all data sent to ftp, as well as all responses from ftp. This is
primarily for debugging, but is also useful if the remote machine shows
a message of the day.
X
.SS Transfer Status Window
.LP
This shows you how far along each file transfer is. It shows the name
and transfer direction, the size, and a gauge showing the percent complete.
It updates every 8K block transferred.
X
.SS Batch Schedule Window
.LP
This allows you to perform batch transfers. The Batch Send list 
shows all the files pending transfer from the local host to the remote host,
and the Batch Receive list shows all the files pending transfer from the remote
host to the local one. Only one list is shown at a time, based on the
setting of the Action item. Addition to a list is performed by selecting the 
files (or directories) in either the Remote Window (for the Receive list) or 
the Local Window (for the Send list), then selecting the 'Add to Batch List'
option on the list pop-up. Deletion or starting the batch transfer is
accomplished in the list pop-up. To schedule a batch transfer, construct
a list, and use Set Current to create the appropriate batch name. Then,
set appropriate parameters on the Host Information window (such as the
remote and local directories). Also, set the time for the transfer. You
can do this for multiple hosts, but nothing will happen until you choose
the Process Batch item. At that point, the batch list will be processed.
Make sure that you bring up the session log before you start or you will
not have a log.
X
.SS About Ftptool Window
.LP
Shows information about Ftptool. Who I am, why it was written, and a few
credits. Also allows you to send feedback to me.
X
.SS Properties
.LP
In addition to the properties listed below, applying your properties will
also save the current state of your pop-up windows (visible or non-visible).
At this time, location is not saved.
X
.RE
.LP
.TP
.B Ftptool options
.sp .5
.RS
.TP 10
.B FTP options
The Log Session option causes ftptool to display the Session Log, and
to actually write to it. The Keep Connection Alive option is not part of ftp, 
but by choosing it ftptool will send a command every 10 minutes so that the 
remote server does not time out and disconnect (which it does after 15 
minutes of inactivity).
.TP
.B Generate unique
The Local Filenames options cause ftptool to generate unique local
filenames of the form N.filename, where N is a number, if filename
already exists on the local machine. The Remote Filenames option
causes ftptool to use the Store Unique FTP command when sending
files, to make the remote server generate unique filenames if filename
exists.
.TP
.B Automatically
The Connect option causes ftptool to try to immediately try to connect 
to the host selected from the Hosts menu. The Show Status option forces
the Transfer Status window to be displayed when beginning a transfer.
The Try Sun Proxy FTP option causes ftptool to automatically try to 
use Sun's proxy FTP (from Sun Consulting) if it cannot resolve the 
hostname (the host is unknown) or it receives a 'Network unreachable' 
error when connecting.  This is primarily used by Sun folks trying 
to get out to the Internet.
.TP
.B Window manager
If selected, ftptool assumes it is running under an OPEN LOOK Window Manager,
and does not provide a Quit button. Also, Viewing a window that is 
already displayed will cause it to be hidden.
.TP
.B Initial Password
The initial password to use, primarily for anonymous ftp.
.TP
.B Case sensitivity
Controls whether or not to respect the case of characters when
sorting the Hosts menu and the directory lists.
.TP
.B Deletions
Controls whether or not to request confirmation when deleting files. If
you delete directories with this on, it will ask for each file in the
directory.
.RE
.LP
.TP
.B Directory List options
.sp .5
.RS
.TP 10
.B Unlimit Cache Size
This option causes ftptool to cache _all_ directories. It could be quite 
a memory waster.
.TP
.B Directory Cache Size
Determines how many directory listings ftptool will remember. This is managed 
as an LRU cache, so every time you CD into a directory ftptool first looks in 
the cache. If it finds it, then instead of actually reading the directory it 
just displays the list in the cache. This can speed up directory listings on 
slow links.  The larger you make the cache, the more memory you will use and 
(if you keep listing the same directories) the less likely you'll have to 
talk to the remote server. However, the larger the cache, the less likely it 
is that you'll see any changes being made on the cached directories. To 
effectively not cache at all, set this to 1. 
X 
There are two caches, one for local directories and one for remote. 
This property controls both (setting it to 2 actually means you'll
cache 4 directories: 2 local and 2 remote). 
.TP
.B Sort remote files by
Controls which field in the remote file list to sort by
You can sort by name, date, size, or type.
.TP
.B Sort order
Controls how to sort the field. For sorting by name: either alphabetical 
or reverse alphabetical. For sorting by the date: either least recently
changed or most recently changed. For sorting by the size: either smallest 
first or largest first. For sorting by type: either alphabetical or
reverse alphabetical (within the types of files).
.TP
.B Hidden files
Controls whether or not to display hidden files (those beginning with a
period).
.TP
.B Group files by type
If set, then files are grouped by types (directories first, then regular
files, ...) in addition to being sorted as normal.
.TP
.B Sort local files by
Controls which field in the local file list to sort by
You can sort by name, date, size, or type.
.TP
.B Sort order
Controls how to sort the field. For sorting by name: either alphabetical 
or reverse alphabetical. For sorting by the date: either least recently
changed or most recently changed. For sorting by the size: either smallest 
first or largest first. For sorting by type: either alphabetical or
reverse alphabetical (within the types of files).
.TP
.B Hidden files
Controls whether or not to display hidden files (those beginning with a
period).
.TP
.B Group files by type
If set, then files are grouped by types (directories first, then regular
files, ...) in addition to being sorted as normal.
.RE
.LP
.TP
.B Viewer options
.sp .5
.RS
.TP 10
.B File viewer
The default viewer for files of unknown (usually text) type. This is a
command line, which will be broken up into arguments. '%f' will be
replaced by the file name to view; if not specified, the file name will
be passed as the last argument.
.TP
.B Archive viewer
The program to use to view archives, which right now are 'tar' archives.
This is a command line, which will be broken up into arguments. '%f' 
will be replaced by the file name to view; if not specified, the file 
name will be passed as the last argument.
.TP
.B PostScript viewer
The program to use to view PostScript files. This is a command line, 
which will be broken up into arguments. '%f' will be replaced by the 
file name to view; if not specified, the file name will be passed
as the last argument.
.SH AUTHOR
.RE
.LP
Mike Sullivan (Mike.Sullivan@Sun.COM)
SHAR_EOF
chmod 0644 ftptool.man ||
echo 'restore of ftptool.man failed'
Wc_c="`wc -c < 'ftptool.man'`"
test 20101 -eq "$Wc_c" ||
	echo 'ftptool.man: original size 20101, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= misc.c ==============
if test -f 'misc.c' -a X"$1" != X"-c"; then
	echo 'x - skipping misc.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting misc.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'misc.c' &&
#include "ftptool.h"
X
#ifdef USE_PROTOTYPES
void log_char(char ch)
#else
void log_char(ch)
char	ch;
#endif
{
X	if (logging) {
X		if (textsw_insert(session_window.log, &ch, 1) != 1) {
X			logging = 0;
X			xv_set(tool_property_window.ftptool.options,
X				PANEL_VALUE, logging | keepalive,
X				NULL);
X		}
X	}
}
X
#ifdef USE_PROTOTYPES
void log_message(char *s)
#else
void log_message(s)
char	*s;
#endif
{
X	if (logging) {
X		if (textsw_insert(session_window.log, s, strlen(s)) != strlen(s)) {
X			logging = 0;
X			xv_set(tool_property_window.ftptool.options,
X				PANEL_VALUE, logging | keepalive,
X				NULL);
X		}
X	}
}
X
#ifdef USE_PROTOTYPES
char	*ftp_error(char ch, char *def)
#else
char	*ftp_error(ch, def)
char	ch;
char	*def;
#endif
{
X	char	*str;
X	char	*nl;
X
X	if (str = index(response_line, ch)) {
X		if (nl = index(str, '\n'))
X			*nl = '\0';
X		return str+1;
X	}
X	return def;
}
X
#ifdef USE_PROTOTYPES
void footer_message(char *format, ...)
#else
/*VARARGS0*/
void footer_message(va_alist)
va_dcl
#endif
{
#ifndef USE_PROTOTYPES
X	char	*format;
#endif
X	va_list	argptr;
X	static char	scratch[MAXPATHLEN + 1];
X
#ifdef USE_PROTOTYPES
X	va_start(argptr, format);
#else
X	va_start(argptr);
X	format = (char *)va_arg(argptr, char *);
#endif
X	vsprintf(scratch, format, argptr);
X	xv_set(base_window.frame, 
X		FRAME_LEFT_FOOTER, scratch, 
X		NULL);
X	va_end(argptr);
}
X
#ifdef USE_PROTOTYPES
void local_footer_message(char *format, ...)
#else
/*VARARGS0*/
void local_footer_message(va_alist)
va_dcl
#endif
{
#ifndef USE_PROTOTYPES
X	char	*format;
#endif
X	va_list	argptr;
X	static char	scratch[MAXPATHLEN + 1];
X
#ifdef USE_PROTOTYPES
X	va_start(argptr, format);
#else
X	va_start(argptr);
X	format = (char *)va_arg(argptr, char *);
#endif
X	vsprintf(scratch, format, argptr);
X	xv_set(local_window.frame, 
X		FRAME_LEFT_FOOTER, scratch, 
X		NULL);
X	va_end(argptr);
}
X
#ifdef USE_PROTOTYPES
void right_footer_message(char *format, ...)
#else
/*VARARGS0*/
void right_footer_message(va_alist)
va_dcl
#endif
{
#ifndef USE_PROTOTYPES
X	char	*format;
#endif
X	va_list	argptr;
X	static char	scratch[MAXPATHLEN + 1];
X
#ifdef USE_PROTOTYPES
X	va_start(argptr, format);
#else
X	va_start(argptr);
X	format = (char *)va_arg(argptr, char *);
#endif
X	vsprintf(scratch, format, argptr);
X	xv_set(base_window.frame, 
X		FRAME_RIGHT_FOOTER, scratch, 
X		NULL);
X	va_end(argptr);
}
X
#ifdef USE_PROTOTYPES
void local_right_footer_message(char *format, ...)
#else
/*VARARGS0*/
void local_right_footer_message(va_alist)
va_dcl
#endif
{
#ifndef USE_PROTOTYPES
X	char	*format;
#endif
X	va_list	argptr;
X	static char	scratch[MAXPATHLEN + 1];
X
#ifdef USE_PROTOTYPES
X	va_start(argptr, format);
#else
X	va_start(argptr);
X	format = (char *)va_arg(argptr, char *);
#endif
X	vsprintf(scratch, format, argptr);
X	xv_set(local_window.frame, 
X		FRAME_RIGHT_FOOTER, scratch, 
X		NULL);
X	va_end(argptr);
}
X
#ifdef USE_PROTOTYPES
void schedule_footer_message(char *format, ...)
#else
/*VARARGS0*/
void schedule_footer_message(va_alist)
va_dcl
#endif
{
#ifndef USE_PROTOTYPES
X	char	*format;
#endif
X	va_list	argptr;
X	static char	scratch[MAXPATHLEN + 1];
X
#ifdef USE_PROTOTYPES
X	va_start(argptr, format);
#else
X	va_start(argptr);
X	format = (char *)va_arg(argptr, char *);
#endif
X	vsprintf(scratch, format, argptr);
X	xv_set(schedule_window.frame, 
X		FRAME_LEFT_FOOTER, scratch, 
X		NULL);
X	va_end(argptr);
}
X
#ifdef USE_PROTOTYPES
void status_footer_message(char *format, ...)
#else
/*VARARGS0*/
void status_footer_message(va_alist)
va_dcl
#endif
{
#ifndef USE_PROTOTYPES
X	char	*format;
#endif
X	va_list	argptr;
X	static char	scratch[MAXPATHLEN + 1];
X
#ifdef USE_PROTOTYPES
X	va_start(argptr, format);
#else
X	va_start(argptr);
X	format = (char *)va_arg(argptr, char *);
#endif
X	vsprintf(scratch, format, argptr);
X	xv_set(status_window.frame, 
X		FRAME_LEFT_FOOTER, scratch, 
X		NULL);
X	va_end(argptr);
}
X
#ifdef USE_PROTOTYPES
void timeout_disconnect(void)
#else
void timeout_disconnect()
#endif
{
X	footer_message("Disconnected (timeout).", (char *)NULL);
X	disconnect();
}
X
#ifdef USE_PROTOTYPES
void close_files(void)
#else
void close_files()
#endif
{
X	if (commandfp) 
X		(void) fclose(commandfp);
X	commandfp = NULL;
X	if (responsefp) 
X		(void) fclose(responsefp);
X	responsefp = NULL;
}
X
#ifdef USE_PROTOTYPES
void quit_ftp(void)
#else
void quit_ftp()
#endif
{
X	connected=0;
X
X	if (!timedout && commandfp)
X		(void) command("QUIT");
X	close_files();
X	data = -1;
X
X	/* remove /usr/tmp files */
X	system("rm -rf /usr/tmp/sched* /usr/tmp/ftptl*");
}
X
#ifdef USE_PROTOTYPES
void disconnect(void)
#else
void disconnect()
#endif
{
X	if (timedout > 1)
X		fprintf(stderr, "multiple timeouts?\n");
X
X	quit_ftp();
X
X	xv_set(schedule_window.process,
X		PANEL_INACTIVE, FALSE,
X		NULL);
X
X	xv_set(frame_icon, 
X		ICON_LABEL, "", 
X		NULL);
X	xv_set(base_window.frame, 
X		XV_LABEL, header_name, 
X		NULL);
X
X	non_unix = 0;
X
X	xv_set(tool_property_window.directory_lists.remote_sort,  
X		PANEL_INACTIVE, FALSE, 
X		NULL); 
X
X
X	/* inactivate buttons */
X    end_busy_cycle();
X    cursor_normal();
X	idle_timer_off();
X
X	remote_list_nfiles = 0;
X	remote_list_ndirs = 0;
X	remote_list_nothers = 0;
X
X	/*
X	free_batchlist(receive_window.list, 0);
X	 */
X	nreceiveitems = 0;
X
X	change_remote_list_menu();
X
X	clear_slist(base_window.list);
X	free_dircache(&remote_dircache);
X	right_footer_message("", (char *)NULL);
X
X	/* inactivate buttons */
X	xv_set(host_window.basic.connect, 
X		PANEL_INACTIVE, FALSE, 
X		PANEL_LABEL_STRING, " Connect  ",
X		XV_HELP_DATA, "ftptool:ConnectButton",
X		NULL);
X
X	xv_set(base_window.connect, 
X		PANEL_INACTIVE, FALSE, 
X		PANEL_LABEL_STRING, " Connect... ",
X		XV_HELP_DATA, "ftptool:ConnectButton",
X		NULL);
X
X	xv_set(base_window.directory,
X		PANEL_INACTIVE, TRUE,
X		PANEL_VALUE, "",
X		NULL);
X
X	xv_set(base_window.file, 
X		PANEL_INACTIVE, FALSE, 
X		NULL);
X	xv_set(base_window.view, 
X		PANEL_INACTIVE, FALSE, 
X		NULL);
X	xv_set(local_window.directory, 
X		PANEL_READ_ONLY, FALSE, 
X		NULL);
X	xv_set(local_window.list, 
X		PANEL_INACTIVE, FALSE, 
X		NULL);
X
X	xv_set(tool_property_window.apply, 
X		PANEL_INACTIVE, FALSE, 
X		NULL);
X
X	xv_set(base_window.abort, 
X		PANEL_INACTIVE, TRUE, 
X		NULL);
X
X
X	xv_set(base_window.list, 
X		XV_SHOW, TRUE, 
X		NULL);
}
X
#ifdef USE_PROTOTYPES
void xfer_buttons_inactive(void)
#else
void xfer_buttons_inactive()
#endif
{
X	footer_message("", (char *)NULL);
X	local_footer_message("", (char *)NULL);
X	idle_timer_off();
X	start_busy_cycle();
X	cursor_busy();
X	xv_set(base_window.file, 
X		PANEL_INACTIVE, TRUE, 
X		NULL);
X	xv_set(base_window.view, 
X		PANEL_INACTIVE, TRUE, 
X		NULL);
X	xv_set(host_window.basic.connect, 
X		PANEL_INACTIVE, TRUE, 
X		NULL);
X	xv_set(base_window.connect, 
X		PANEL_INACTIVE, TRUE, 
X		NULL);
X	xv_set(base_window.directory, 
X		PANEL_READ_ONLY, TRUE, 
X		NULL);
X	xv_set(base_window.list, 
X		PANEL_INACTIVE, TRUE, 
X		NULL);
X	xv_set(local_window.directory, 
X		PANEL_READ_ONLY, TRUE, 
X		NULL);
X	xv_set(local_window.list, 
X		PANEL_INACTIVE, TRUE, 
X		NULL);
X
X	xv_set(tool_property_window.apply, 
X		PANEL_INACTIVE, TRUE, 
X		NULL);
X	xv_set(tool_property_window.category, 
X		PANEL_INACTIVE, TRUE, 
X		NULL);
}
X
#ifdef USE_PROTOTYPES
void xfer_buttons_active(void)
#else
void xfer_buttons_active()
#endif
{
X	if (abort_transfer)
X		xv_set(base_window.frame,
X			FRAME_BUSY, FALSE,
X			NULL);
X	cursor_normal();
X	end_busy_cycle();
X	idle_timer_on();
X
X	xv_set(base_window.file, 
X		PANEL_INACTIVE, FALSE, 
X		NULL);
X	xv_set(base_window.view, 
X		PANEL_INACTIVE, FALSE, 
X		NULL);
X	xv_set(host_window.basic.connect, 
X		PANEL_INACTIVE, FALSE, 
X		NULL);
X	xv_set(base_window.connect, 
X		PANEL_INACTIVE, FALSE, 
X		NULL);
X	xv_set(base_window.directory, 
X		PANEL_READ_ONLY, FALSE, 
X		NULL);
X	xv_set(base_window.list, 
X		PANEL_INACTIVE, FALSE, 
X		NULL);
X	xv_set(local_window.directory, 
X		PANEL_READ_ONLY, FALSE, 
X		NULL);
X	xv_set(local_window.list, 
X		PANEL_INACTIVE, FALSE, 
X		NULL);
X
X	xv_set(tool_property_window.apply, 
X		PANEL_INACTIVE, FALSE, 
X		NULL);
X	xv_set(tool_property_window.category, 
X		PANEL_INACTIVE, FALSE, 
X		NULL);
X
X	xv_set(base_window.abort, 
X		PANEL_INACTIVE, TRUE, 
X		NULL);
}
X
#ifdef USE_PROTOTYPES
void cursor_busy(void)
#else
void cursor_busy()
#endif
{
X	Xv_Window	window;
X
X	window = xv_get(base_window.panel, CANVAS_NTH_PAINT_WINDOW, 0);
X	xv_set(window, 
X		WIN_CURSOR, busy_cursor, 
X		NULL);
X	window = xv_get(local_window.panel, CANVAS_NTH_PAINT_WINDOW, 0);
X	xv_set(window, 
X		WIN_CURSOR, busy_cursor, 
X		NULL);
X	window = xv_get(tool_property_window.panel, CANVAS_NTH_PAINT_WINDOW, 0);
X	xv_set(window, 
X		WIN_CURSOR, busy_cursor, 
X		NULL);
}
X
#ifdef USE_PROTOTYPES
void cursor_normal(void)
#else
void cursor_normal()
#endif
{
X	Xv_Window	window;
X
X	window = xv_get(base_window.panel, CANVAS_NTH_PAINT_WINDOW, 0);
X	xv_set(window, 
X		WIN_CURSOR, normal_cursor, 
X		NULL);
X	window = xv_get(local_window.panel, CANVAS_NTH_PAINT_WINDOW, 0);
X	xv_set(window, 
X		WIN_CURSOR, normal_cursor, 
X		NULL);
X	window = xv_get(tool_property_window.panel, CANVAS_NTH_PAINT_WINDOW, 0);
X	xv_set(window, 
X		WIN_CURSOR, normal_cursor, 
X		NULL);
}
X
#ifdef USE_PROTOTYPES
void show_stats(struct file_property_window *file_props,
X	struct dirlist *tmp)
#else
void show_stats(file_props,tmp)
struct file_property_window *file_props;
struct dirlist *tmp;
#endif
{
X	int		user_perms,group_perms,other_perms;
X	char	*type;
X
X	switch (tmp->mode & S_IFMT) {
X		case S_IFREG:
X			type = "Regular File";
X			break;
X		case S_IFDIR:
X			type = "Directory";
X			break;
X		case S_IFLNK:
X			type = "Symbolic Link";
X			break;
X		case S_IFCHR:
X			type = "Character Device";
X			break;
X		case S_IFBLK:
X			type = "Block Device";
X			break;
X		case S_IFSOCK:
X			type = "Socket";
X			break;
X		case S_IFIFO:
X			type = "Named Pipe";
X			break;
X		default:
X			type = "unknown";
X			break;
X	}
X
X	user_perms = 0;
X	if (tmp->mode & S_IRUSR) 
X		user_perms |= 1;
X	if (tmp->mode & S_IWUSR) 
X		user_perms |= 2;
X	if (tmp->mode & S_IXUSR) 
X		user_perms |= 4;
X
X	group_perms = 0;
X	if (tmp->mode & S_IRGRP) 
X		group_perms |= 1;
X	if (tmp->mode & S_IWGRP) 
X		group_perms |= 2;
X	if (tmp->mode & S_IXGRP) 
X		group_perms |= 4;
X
X	other_perms = 0;
X	if (tmp->mode & S_IROTH) 
X		other_perms |= 1;
X	if (tmp->mode & S_IWOTH) 
X		other_perms |= 2;
X	if (tmp->mode & S_IXOTH) 
X		other_perms |= 4;
X
X	/* show stats in window */
X	xv_set(file_props->filename, 
X		PANEL_VALUE, tmp->name,
X		PANEL_INACTIVE, FALSE,
X		NULL);
X	xv_set(file_props->owner, 
X		PANEL_LABEL_STRING, tmp->owner,
X		PANEL_INACTIVE, FALSE,
X		NULL);
X	xv_set(file_props->group, 
X		PANEL_LABEL_STRING, tmp->group,
X		PANEL_INACTIVE, FALSE,
X		NULL);
X	xv_set(file_props->modtime, 
X		PANEL_LABEL_STRING, tmp->date,
X		PANEL_INACTIVE, FALSE,
X		NULL);
X	xv_set(file_props->type, 
X		PANEL_LABEL_STRING, type,
X		PANEL_INACTIVE, FALSE,
X		NULL);
X	sprintf(scratch, "%d", tmp->size);
X	xv_set(file_props->size, 
X		PANEL_LABEL_STRING, scratch,
X		PANEL_INACTIVE, FALSE,
X		NULL);
X	xv_set(file_props->user_perms, 
X		PANEL_VALUE, user_perms,
X		PANEL_INACTIVE, FALSE,
X		NULL);
X	xv_set(file_props->group_perms, 
X		PANEL_VALUE, group_perms,
X		PANEL_INACTIVE, FALSE,
X		NULL);
X	xv_set(file_props->other_perms, 
X		PANEL_VALUE, other_perms,
X		PANEL_INACTIVE, FALSE,
X		NULL);
}
X
#ifdef USE_PROTOTYPES
void inactivate_props(struct file_property_window *file_props)
#else
void inactivate_props(file_props)
struct file_property_window *file_props;
#endif
{
X	xv_set(file_props->filename, 
X		PANEL_INACTIVE, TRUE,
X		NULL);
X	xv_set(file_props->owner, 
X		PANEL_INACTIVE, TRUE,
X		NULL);
X	xv_set(file_props->group, 
X		PANEL_INACTIVE, TRUE,
X		NULL);
X	xv_set(file_props->modtime, 
X		PANEL_INACTIVE, TRUE,
X		NULL);
X	xv_set(file_props->type, 
X		PANEL_INACTIVE, TRUE,
X		NULL);
X	xv_set(file_props->size, 
X		PANEL_INACTIVE, TRUE,
X		NULL);
X	xv_set(file_props->user_perms, 
X		PANEL_INACTIVE, TRUE,
X		NULL);
X	xv_set(file_props->group_perms, 
X		PANEL_INACTIVE, TRUE,
X		NULL);
X	xv_set(file_props->other_perms, 
X		PANEL_INACTIVE, TRUE,
X		NULL);
}
X
#ifdef USE_PROTOTYPES
int ask_make_dir(char *s)
#else
int ask_make_dir(s)
char	*s;
#endif
{
X	int		answer;
#ifdef XVIEW3
X	Xv_notice notice;
#endif
X
X	sprintf(scratch, "%s does not exist.", s);
#ifdef XVIEW3
X	notice = xv_create(local_window.panel, NOTICE,
X		NOTICE_MESSAGE_STRINGS,
X			scratch,
X			"You can:",
X			NULL,
X		NOTICE_BUTTON, 		"Cancel", 4,
X		NOTICE_BUTTON,      "Try to create it", 3,
X		NOTICE_STATUS, &answer,
X		XV_SHOW, TRUE,
X		NULL);
X	xv_destroy_safe(notice);
#else
X	answer = notice_prompt(local_window.panel, NULL,
X		NOTICE_MESSAGE_STRINGS,
X			scratch,
X			"You can:",
X			NULL,
X		NOTICE_BUTTON, 		"Cancel", 4,
X		NOTICE_BUTTON,      "Try to create it", 3,
X		NULL);
#endif
X	if (answer == 4) 
X		return -1;
X
X	return make_dirs(s, 1);
}
X
#ifdef USE_PROTOTYPES
SHAR_EOF
true || echo 'restore of misc.c failed'
fi
echo 'End of  part 7'
echo 'File misc.c is continued in part 8'
echo 8 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
