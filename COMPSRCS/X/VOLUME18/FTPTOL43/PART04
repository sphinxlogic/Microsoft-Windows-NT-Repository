Path: uunet!sun-barr!ames!elroy.jpl.nasa.gov!swrinde!mips!msi!dcmartin
From: Mike.Sullivan@EBay.Sun.COM (Mike Sullivan {AKA Simon BarSinister})
Newsgroups: comp.sources.x
Subject: v18i086: Ftptool 4.3 (XVIEW), Part04/12
Message-ID: <1992Aug18.153610.28729@msi.com>
Date: 18 Aug 92 15:36:10 GMT
References: <csx-18i083-ftptool-4.3@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 2211
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: Mike.Sullivan@EBay.Sun.COM (Mike Sullivan {AKA Simon BarSinister})
Posting-number: Volume 18, Issue 86
Archive-name: ftptool-4.3/part04

#!/bin/sh
# this is part.04 (part 4 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file lex.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 4; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping lex.c'
else
echo 'x - continuing file lex.c'
sed 's/^X//' << 'SHAR_EOF' >> 'lex.c' &&
struct yysvf yysvec[] = {
0,	0,	0,
yycrank+-1,	0,		0,	
yycrank+-20,	yysvec+1,	0,	
yycrank+0,	0,		yyvstop+1,
yycrank+3,	0,		yyvstop+3,
yycrank+0,	yysvec+4,	yyvstop+6,
yycrank+4,	0,		yyvstop+8,
yycrank+1,	0,		yyvstop+10,
yycrank+1,	0,		yyvstop+12,
yycrank+1,	0,		yyvstop+14,
yycrank+8,	0,		yyvstop+16,
yycrank+10,	0,		yyvstop+18,
yycrank+1,	0,		yyvstop+20,
yycrank+17,	0,		yyvstop+22,
yycrank+3,	0,		yyvstop+24,
yycrank+10,	0,		yyvstop+26,
yycrank+2,	0,		0,	
yycrank+5,	0,		0,	
yycrank+16,	0,		0,	
yycrank+21,	0,		0,	
yycrank+23,	0,		0,	
yycrank+25,	0,		0,	
yycrank+28,	0,		0,	
yycrank+25,	0,		0,	
yycrank+18,	0,		0,	
yycrank+36,	0,		0,	
yycrank+33,	0,		0,	
yycrank+2,	0,		0,	
yycrank+34,	0,		0,	
yycrank+0,	0,		yyvstop+28,
yycrank+27,	0,		0,	
yycrank+38,	0,		0,	
yycrank+30,	0,		0,	
yycrank+4,	0,		0,	
yycrank+30,	0,		0,	
yycrank+39,	0,		0,	
yycrank+48,	0,		0,	
yycrank+38,	0,		0,	
yycrank+50,	0,		0,	
yycrank+38,	0,		0,	
yycrank+52,	0,		0,	
yycrank+42,	0,		0,	
yycrank+40,	0,		0,	
yycrank+52,	0,		0,	
yycrank+0,	0,		yyvstop+30,
yycrank+47,	0,		0,	
yycrank+43,	0,		0,	
yycrank+0,	0,		yyvstop+32,
yycrank+0,	0,		yyvstop+34,
yycrank+0,	0,		yyvstop+36,
yycrank+0,	0,		yyvstop+38,
yycrank+1,	0,		0,	
yycrank+0,	0,		yyvstop+40,
yycrank+0,	0,		yyvstop+42,
yycrank+0,	0,		yyvstop+44,
yycrank+54,	0,		0,	
yycrank+0,	0,		yyvstop+46,
yycrank+0,	0,		yyvstop+48,
yycrank+40,	0,		0,	
yycrank+0,	0,		yyvstop+50,
0,	0,	0};
struct yywork *yytop = yycrank+128;
struct yysvf *yybgin = yysvec+1;
char yymatch[] = {
00  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,011 ,012 ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
011 ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
01  ,01  ,01  ,01  ,01  ,01  ,01  ,01  ,
0};
char yyextra[] = {
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0};
/*	Copyright (c) 1989 AT&T	*/
/*	  All Rights Reserved  	*/
X
/*	THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF AT&T	*/
/*	The copyright notice above does not evidence any   	*/
/*	actual or intended publication of such source code.	*/
X
#ident	"@(#)RELEASE VERSION SC2.0 3/27/92"
X
int yylineno =1;
# define YYU(x) x
# define NLSTATE yyprevious=YYNEWLINE
char yytext[YYLMAX];
struct yysvf *yylstate [YYLMAX], **yylsp, **yyolsp;
char yysbuf[YYLMAX];
char *yysptr = yysbuf;
int *yyfnd;
extern struct yysvf *yyestate;
int yyprevious = YYNEWLINE;
#if defined(__cplusplus) || defined(__STDC__)
int yylook(void)
#else
yylook()
#endif
{
X	register struct yysvf *yystate, **lsp;
X	register struct yywork *yyt;
X	struct yysvf *yyz;
X	int yych, yyfirst;
X	struct yywork *yyr;
# ifdef LEXDEBUG
X	int debug;
# endif
X	char *yylastch;
X	/* start off machines */
# ifdef LEXDEBUG
X	debug = 0;
# endif
X	yyfirst=1;
X	if (!yymorfg)
X		yylastch = yytext;
X	else {
X		yymorfg=0;
X		yylastch = yytext+yyleng;
X		}
X	for(;;){
X		lsp = yylstate;
X		yyestate = yystate = yybgin;
X		if (yyprevious==YYNEWLINE) yystate++;
X		for (;;){
# ifdef LEXDEBUG
X			if(debug)fprintf(yyout,"state %d\n",yystate-yysvec-1);
# endif
X			yyt = yystate->yystoff;
X			if(yyt == yycrank && !yyfirst){  /* may not be any transitions */
X				yyz = yystate->yyother;
X				if(yyz == 0)break;
X				if(yyz->yystoff == yycrank)break;
X				}
X			*yylastch++ = yych = input();
X			if(yylastch > &yytext[YYLMAX]) {
X				fprintf(yyout,"Input string too long, limit %d\n",YYLMAX);
X				exit(1);
X			}
X			yyfirst=0;
X		tryagain:
# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"char ");
X				allprint(yych);
X				putchar('\n');
X				}
# endif
X			yyr = yyt;
X			if ( (int)yyt > (int)yycrank){
X				yyt = yyr + yych;
X				if (yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					if(lsp > &yylstate[YYLMAX]) {
X						fprintf(yyout,"Input string too long, limit %d\n",YYLMAX);
X						exit(1);
X					}
X					goto contin;
X					}
X				}
# ifdef YYOPTIM
X			else if((int)yyt < (int)yycrank) {		/* r < yycrank */
X				yyt = yyr = yycrank+(yycrank-yyt);
# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"compressed state\n");
# endif
X				yyt = yyt + yych;
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transitions */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					if(lsp > &yylstate[YYLMAX]) {
X						fprintf(yyout,"Input string too long, limit %d\n",YYLMAX);
X						exit(1);
X					}
X					goto contin;
X					}
X				yyt = yyr + YYU(yymatch[yych]);
# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"try fall back character ");
X					allprint(YYU(yymatch[yych]));
X					putchar('\n');
X					}
# endif
X				if(yyt <= yytop && yyt->verify+yysvec == yystate){
X					if(yyt->advance+yysvec == YYLERR)	/* error transition */
X						{unput(*--yylastch);break;}
X					*lsp++ = yystate = yyt->advance+yysvec;
X					if(lsp > &yylstate[YYLMAX]) {
X						fprintf(yyout,"Input string too long, limit %d\n",YYLMAX);
X						exit(1);
X					}
X					goto contin;
X					}
X				}
X			if ((yystate = yystate->yyother) && (yyt= yystate->yystoff) != yycrank){
# ifdef LEXDEBUG
X				if(debug)fprintf(yyout,"fall back to state %d\n",yystate-yysvec-1);
# endif
X				goto tryagain;
X				}
# endif
X			else
X				{unput(*--yylastch);break;}
X		contin:
# ifdef LEXDEBUG
X			if(debug){
X				fprintf(yyout,"state %d char ",yystate-yysvec-1);
X				allprint(yych);
X				putchar('\n');
X				}
# endif
X			;
X			}
# ifdef LEXDEBUG
X		if(debug){
X			fprintf(yyout,"stopped at %d with ",*(lsp-1)-yysvec-1);
X			allprint(yych);
X			putchar('\n');
X			}
# endif
X		while (lsp-- > yylstate){
X			*yylastch-- = 0;
X			if (*lsp != 0 && (yyfnd= (*lsp)->yystops) && *yyfnd > 0){
X				yyolsp = lsp;
X				if(yyextra[*yyfnd]){		/* must backup */
X					while(yyback((*lsp)->yystops,-*yyfnd) != 1 && lsp > yylstate){
X						lsp--;
X						unput(*yylastch--);
X						}
X					}
X				yyprevious = YYU(*yylastch);
X				yylsp = lsp;
X				yyleng = yylastch-yytext+1;
X				yytext[yyleng] = 0;
# ifdef LEXDEBUG
X				if(debug){
X					fprintf(yyout,"\nmatch ");
X					sprint(yytext);
X					fprintf(yyout," action %d\n",*yyfnd);
X					}
# endif
X				return(*yyfnd++);
X				}
X			unput(*yylastch);
X			}
X		if (yytext[0] == 0  /* && feof(yyin) */)
X			{
X			yysptr=yysbuf;
X			return(0);
X			}
X		yyprevious = yytext[0] = input();
X		if (yyprevious>0)
X			output(yyprevious);
X		yylastch=yytext;
# ifdef LEXDEBUG
X		if(debug)putchar('\n');
# endif
X		}
X	}
#if defined(__cplusplus) || defined(__STDC__)
int yyback(int *p, int m)
#else
yyback(p, m)
X	int *p;
#endif
{
X	if (p==0) return(0);
X	while (*p) {
X		if (*p++ == m)
X			return(1);
X	}
X	return(0);
}
X	/* the following are only used in the lex library */
#if defined(__cplusplus) || defined(__STDC__)
int yyinput(void)
#else
yyinput()
#endif
{
X	return(input());
X	}
#if defined(__cplusplus) || defined(__STDC__)
void yyoutput(int c)
#else
yyoutput(c)
X  int c; 
#endif
{
X	output(c);
X	}
#if defined(__cplusplus) || defined(__STDC__)
void yyunput(int c)
#else
yyunput(c)
X   int c; 
#endif
{
X	unput(c);
X	}
SHAR_EOF
echo 'File lex.c is complete' &&
chmod 0644 lex.c ||
echo 'restore of lex.c failed'
Wc_c="`wc -c < 'lex.c'`"
test 11513 -eq "$Wc_c" ||
	echo 'lex.c: original size 11513, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= readdir.c ==============
if test -f 'readdir.c' -a X"$1" != X"-c"; then
	echo 'x - skipping readdir.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting readdir.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'readdir.c' &&
#include "ftptool.h"
X
extern int dirlastmtime;
X
#ifdef USE_PROTOTYPES
struct dirlist *read_local_dir(char *dirname)
#else
struct dirlist *read_local_dir(dirname)
char	*dirname;
#endif
{
X	struct dirlist *head;
X	DIR	*dir;
X	struct dirent *dp;
X	struct passwd *psswd;
X	struct group *grp;
X	struct stat buf;
X	time_t	curtime;
X	time_t	time();
X	char	date[DATELEN];
X	struct tm *tm;
X	char	owner[20];
X	char	group[20];
X	
X
X	head = new_dirlist("", "", "", "", 0, (size_t)0);
X    if (head == NULL) {
X        fprintf(stderr, "Out of memory\n");
X        goto out;
X    }
X
X	if (lstat(dirname, &buf) == -1) {
X        local_footer_message("Could not stat directory %s.", 
X			dirname, (char *)NULL);
X		goto out;
X	}
X
X	dirlastmtime = buf.st_mtime;
X
X    if ((dir = opendir(dirname)) == NULL) {
X        local_footer_message("Could not open directory %s.", 
X			dirname, (char *)NULL);
X        goto out;
X    }
X 
X    curtime = time((time_t *)NULL);
X
X
X    while (dp = readdir(dir)) {
X        if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, ".."))
X            continue;
X        bzero((char *)&buf, sizeof(buf));
X        if (lstat(dp->d_name, &buf) == -1) {
X            buf.st_mode = 0;
X            buf.st_uid = 0;
X            buf.st_gid = 0;
X            buf.st_size = 0;
X            buf.st_mtime = 0;
X        }
X		tm = localtime(&buf.st_mtime);
X        if ((curtime - buf.st_mtime) < (6 * 30 * 24 * 60 * 60))
X            strftime(date, sizeof(date), "%h %e %H:%M", tm);
X        else
X            strftime(date, sizeof(date), "%h %e  %Y", tm);
X
X		/* determine user and group ids */
X		psswd = getpwuid(buf.st_uid);
X		if (psswd == NULL) {
X			sprintf(owner, "%d", buf.st_uid);
X		} else
X			strcpy(owner, psswd->pw_name);
X
X		grp = getgrgid(buf.st_gid);
X		if (grp == NULL) {
X			sprintf(group, "%d", buf.st_gid);
X		} else
X			strcpy(group, grp->gr_name);
X
X		/* if a link, format name to 'name -> link' as ftp would */
X		if (S_ISLNK(buf.st_mode)) {
X			char	*linkvalue;
X			int		nbytes;
X
X			linkvalue = (char *)malloc(MAXPATHLEN + 1);
X			if ((nbytes = readlink(dp->d_name,linkvalue,(int)buf.st_size))== -1)
X				strcpy(linkvalue, "unknown");
X			else
X				linkvalue[nbytes] = '\0';
X			sprintf(scratch, "%s -> %s", dp->d_name, linkvalue);
X			free(linkvalue);
X		} else
X			strcpy(scratch, dp->d_name);
X        if (add_dirname(head, scratch, date, owner, group, buf.st_mode, 
X			(size_t)buf.st_size, local_sort_mode, local_sort_direction) == NULL)
X            goto out;
X    }
X    closedir(dir);
X
out:
X	if (head)
X		return (head);
X	return NULL;
}
X
#ifdef USE_PROTOTYPES
struct dirlist *read_remote_dir(char *dname)
#else
struct dirlist *read_remote_dir(dname)
char	*dname;
#endif
{
X	struct dirlist *head = NULL;
X	int	old_unix, temp_non_unix = 0;
X	FILE	*din = NULL, *open_remote_ls();
X	char	*next_remote_line();
X
restart:
X	old_unix = temp_non_unix;
X	head = new_dirlist("", "", "", "", 0, (size_t)0);
X    if (head == NULL) {
X        fprintf(stderr, "Out of memory\n");
X        goto out;
X    }
X    /* read the remote directory, adding files and directories to a list */
X    /* send dir command */
X	if (non_unix || temp_non_unix) {
X		din = open_remote_ls(1);
X	} else {
X		din = open_remote_ls(0);
X	}
X	if (din == NULL) {
X		/* always have .. */
X		return head;
X	}
X
X    for (;;) {
X        if (next_remote_line(din) == NULL)
X			goto out;
X        if (!strncmp(response_line, "226", 3) || !strncmp(response_line,"250", 3)) {
X            /* done */
X            log_message(response_line);
X            break;
X        }
X		/* ignore blank lines */
X		if (*response_line == '\n' || *response_line == '\0')
X			continue;
X		/* VMS also prints the directory name */
X		if (dname && !strncmp(response_line, dname, strlen(dname))
X			&& (response_line[strlen(dname)] == '\n')) {
X			continue;
X		}
X		/* VMS goofy total line before 226 */
X		if (!strncmp(response_line, "Total of", 8))
X			continue;
X		if (parse_line(head, response_line, &temp_non_unix)) {
X			goto out;
X		}
X		if (old_unix != temp_non_unix) {
X			/* start over */
X			free_dirlist(head);
X			head = NULL;
X			while (getc(din) != -1)
X				/* NULL */ ;
X			close_remote_ls(din);
X			din = NULL;
X			goto restart;
X		}
X    }
X 
out:
X	if (din)
X		close_remote_ls(din);
X	if (timedout) {
X		if (head)
X			free_dirlist(head);
X		timeout_disconnect();
X		return NULL;
X	}
X	if (head)
X		return (head);
X	return (NULL);
}
X
X
#define NULLCHECK() if (*curr == '\0') {non_unix = 1; goto restart;}
X
#ifdef USE_PROTOTYPES
int	parse_line(struct dirlist *head, char *line, int *temp_non_unix)
#else
int	parse_line(head, line, temp_non_unix)
struct dirlist *head;
char	*line;
int		*temp_non_unix;
#endif
{
X	/* default mode is a symbolic link. This is so if you don't have */
X	/* UNIX PERMS, it can be either a file or a directory. Maybe.  */
X	mode_t	mode = S_IFLNK;
X	int		intmode;
X	char	*curr;
X	static char	date[20];
X	static char	month[10];
X	static char	day[10];
X	static char	timeyear[10];
X	static char	name[MAXPATHLEN + 1];
X	static char owner[25];
X	static char group[25];
X	size_t	size = (size_t)-1;
X	char	*tmp;
X	char	*dirtmp;
X
X	month[0] = '\0';
X	day[0] = '\0';
X	timeyear[0] = '\0';
X	date[0] = '\0';
X	name[0] = '\0';
X	strcpy(owner, "unknown");
X	strcpy(group, "unknown");
restart: /* really only get here if non-unix machine */
X	/* Or, actually, assume that if the first character is upper case, */
X	/* it is non-unix (since ls never puts upper case as the type */
X	/* And it appears that the filename is all the characters at the */
X	/* start of the line up to but not including white space on VMS and */
X	/* tops20. This would make it functional, partially at least */
X	/* Also, may need to turn on temp_non_unix_mode, so that cd is */
X	/* possible on anything, since we can't tell if they're directories. */
X	/* or not */
X	curr=line;
X
X	if (non_unix || *temp_non_unix) {
X	/*
X		if (curr[1] == ':') {
X			ftperr = ftp_error(' ', "Permission denied");
X			footer_message(ftperr, (char *)NULL);
X			return 0;
X		} else if (!strncmp(curr, ". unreadable", 12)) {
X			footer_message(". unreadable", (char *)NULL);
X			return 0;
X		}
X	*/
X		while (*curr && isspace(*curr))
X			curr++;
X		tmp = name;
X		while (*curr && !isspace(*curr)) {
X			*tmp = *curr;
X			tmp++;
X			curr++;
X		}
X		*tmp = '\0';
X		curr++;
X		if (add_dirname(head, name, "unknown", "unknown", "unknown", S_IFLNK, 
X			(size_t)-1, remote_sort_mode, remote_sort_direction) == NULL) {
X			fprintf(stderr, "add_dirname failed!\n");
X			return 1;
X		}
X		return 0;
X	}
X	dirtmp = dir_pattern;
X	while (*dirtmp != '\0') {
X		NULLCHECK();
X		switch(*dirtmp) {
X		case ' ':
X			while (isspace(*curr))
X				curr++;
X			break;
X		case SKIP:
X			while (!isspace(*curr))
X				curr++;
X			break;
X		case PERMS:
X			intmode = perms(curr, temp_non_unix);
X			if (intmode == 0)
X				return 0;
X			else if (intmode == -1)
X				goto restart;
X			mode = (mode_t)intmode;
X			while (!isspace(*curr))
X				curr++;
X			break;
X		case LINKS:
X			/* dump link count */
X			while (isdigit(*curr))
X				curr++;
X			break;
X		case USER:
X			/*
X			 * this should be the user name, surrounded by white space
X			 */
X			tmp = owner;
X			while (!isspace(*curr)) {
X				*tmp = *curr;
X				tmp++;
X				curr++;
X			}
X			*tmp = '\0';
X			break;
X		case GROUP:
X			/*
X			 * this should be the group name, surrounded by white space
X			 */
X			tmp = group;
X			while (!isspace(*curr)) {
X				*tmp = *curr;
X				tmp++;
X				curr++;
X			}
X			*tmp = '\0';
X			break;
X		case SIZE:
X			/* first test only true for UNIX case, where we have */
X			/* seen the perms */
X			if (S_ISCHR(mode) || S_ISBLK(mode)) {
X				/* size is actually major, minor */
X				while (isdigit(*curr) || *curr == ',')
X					curr++;
X				NULLCHECK();
X				while (isspace(*curr))
X					curr++;
X				NULLCHECK();
X				while (isdigit(*curr))
X					curr++;
X				size = -1;
X			} else {
X				sscanf(curr, "%d", &size);
X				while (isdigit(*curr))
X					curr++;
X			}
X			break;
X		case MONTH:
X			tmp = month;
X			while (isalpha(*curr)) {
X				*tmp = *curr;
X				tmp++;
X				curr++;
X			}
X			*tmp = '\0';
X			break;
X		case DAY:
X			tmp = day;
X			while (isdigit(*curr)) {
X				*tmp = *curr;
X				tmp++;
X				curr++;
X			}
X			*tmp = '\0';
X			break;
X		case TIME:
X			tmp = timeyear;
X			while (isdigit(*curr) || (*curr == ':')) {
X				*tmp = *curr;
X				tmp++;
X				curr++;
X			}
X			*tmp = '\0';
X			break;
X		case NAME:
X		case LOWERNAME:
X			tmp = name;
X			/* the following test makes sure we have seen the PERMS field */
X			/* if not, the permissions will still be 0. symlinks normally */
X			/* have 777 for permissions */
X			if (mode != S_IFLNK && S_ISLNK(mode)) {
X				while (*curr && *curr != '\n') {
X					*tmp = *curr;
X					tmp++;
X					curr++;
X				}
X			} else {
X				while (!isspace(*curr) && *curr != ';') {
X					*tmp = *curr;
X					tmp++;
X					curr++;
X				}
X				/* VMS */
X				if (*curr == ';') {
X					while (!isspace(*curr))
X						curr++;
X				}
X			}
X			*tmp = '\0';
X			if (*dirtmp == LOWERNAME) {
X				for (tmp = name; *tmp != '\0'; tmp++)
X					if (isupper(*tmp))
X						*tmp = tolower(*tmp);
X			}
X			break;
X		default:
X			if (*dirtmp == *curr) {
X				curr++;
X			} else {
X				*temp_non_unix=1;
X				goto restart;
X			}
X		}
X		dirtmp++;
X	}
X	sprintf(date, "%s %2s %5s", month, day, timeyear);
X
X	if (add_dirname(head, name, date, owner, group, mode, size, 
X		remote_sort_mode, remote_sort_direction) == NULL) {
X		fprintf(stderr, "add_dirname failed!\n");
X		return 1;
X	}
X	return 0;
}
X
X
/*
X take the dir_parse string, in the form of
X	PERMS LINKS USER GROUP SIZE MONTH DAY TIME NAME
X and return a NULL-terminated array of character values of the above
X
X The values would be control-characters, so they are not in danger
X of being typed (right!). A ' ' represents whitespace, any other character
X must be matched exactly.
X */
X
char	*lex_string;
X
#ifdef USE_PROTOTYPES
char *dir_parse_to_pattern(char *dir_parse)
#else
char *dir_parse_to_pattern(dir_parse)
char	*dir_parse;
#endif
{
X	static char pattern[MAXPATHLEN+1];
X	char	*nextpos = pattern;
X	char	*s;
X	int		token;
X	int		found_bitmask = 0;
X	int		yylex();
X	static char *tokval[] = {
X		"",
X		"PERMS",
X		"LINKS",
X		"USER",
X		"GROUP",
X		"SIZE",
X		"MONTH",
X		"DAY",
X		"TIME",
X		"NAME",
X		"SKIP",
X		"NONUNIX",
X		"LOWERNAME",
X	};
X
X	lex_string = strdup(dir_parse);
X	if (lex_string == NULL) {
X		fprintf(stderr, "Out of memory\n");
X		exit(1);
X	}
X	s = lex_string;
X	while (token = yylex()) {
X		*nextpos = (char)token;
X		nextpos++;
X		if (token <= MAXTOKENS) {
X			if (found_bitmask & (1 << token)) {
X				fprintf(stderr, "Duplicate token %s in DIR template.\n", 
X					tokval[token]);
X				free(s);
X				return NULL;
X			}
X			if (token != SKIP)
X				found_bitmask |= 1 << token;
X		}
X	}
X	*nextpos = '\0';
X	free(s);
X	if ((found_bitmask & (1 << NONUNIX)) != 0) {
X		pattern[0] = (char)NONUNIX;
X		return pattern;
X	}
X	/* make sure that we have a filename, at least */
X	if ((found_bitmask & (1 << NAME)) == 0  
X		&& (found_bitmask & (1 << LOWERNAME)) == 0) {
X		fprintf(stderr,"You must specify a NAME token in your parse field.\n");
X		return NULL;
X	}
X	return pattern;
}
X
#undef NULLCHECK
#define NULLCHECK() if (*s == '\0') {*temp_non_unix = 1; return -1;}
X
#ifdef USE_PROTOTYPES
int perms(char *s, int *temp_non_unix)
#else
int perms(s, temp_non_unix)
char	*s;
int		*temp_non_unix;
#endif
{
X	int mode;
X
X	switch (*s) {
X	case 'd':
X			mode = S_IFDIR;
X			break;
X	case 'F':
X	case 'f':
X	case 'm': /* Cray and convex migrated files */
X	case '-':
X			mode = S_IFREG;
X			break;
X	case 'l':
X			mode = S_IFLNK;
X			break;
X	case 'b':
X			mode = S_IFBLK;
X			break;
X	case 'c':
X			mode = S_IFCHR;
X			break;
X	case 's':
X			mode = S_IFSOCK;
X			break;
X	case 'p':
X			mode = S_IFIFO;
X			break;
X	case 'D':
X			mode = S_IFDIR;
X			break;
X	case 'B':
X			mode = S_IFBLK;
X			break;
X	case 'C':
X			mode = S_IFCHR;
X			break;
X	case 'S':
X			mode = S_IFSOCK;
X			break;
X	case 'P':
X			mode = S_IFIFO;
X			break;
X	case 't':
X			if (!strncmp(s, "total", 5))
X				return 0;
X			/* fall through */
#ifdef notdef
X	case '.':
X		if (s[1] == ':') {
X			ftperr = ftp_error(' ', "Permission denied");
X			footer_message(ftperr, (char *)NULL);
X			return 0;
X		} else if (!strncmp(s, ". unreadable", 12)) {
X			footer_message(". unreadable", (char *)NULL);
X			return 0;
X		}
#endif
X	default:
X			*temp_non_unix = 1;
#ifdef notdef
X			sprintf(scratch, "%s (non-UNIX?)", 
X				(char *)xv_get(base_window.frame, XV_LABEL));
X			xv_set(base_window.frame, XV_LABEL, scratch, NULL);
X			remote_sort_mode = SORTBYNAME;
X			xv_set(tool_property_window.directory_lists.remote_sort, 
X				PANEL_VALUE, remote_sort_mode,
X				PANEL_INACTIVE, TRUE,
X				NULL);
X			set_remote_sort_order(SORTBYNAME);
#endif
X			return -1;
X			break;
X	}
X
X	s++;
X	if (*s == ' ' || *s == '\0' || *s == '\t')
X		return mode; /* OK to not have permissions */
X	NULLCHECK();
X	/*
X	 Determine permissions.
X	 */
X	if (*s++ == 'r')
X		mode |= S_IRUSR;
X	NULLCHECK();
X	if (*s++ == 'w')
X		mode |= S_IWUSR;
X	NULLCHECK();
X	if (*s == 'x' || *s == 's')
X		mode |= S_IXUSR;
X	s++;
X	NULLCHECK();
X	if (*s++ == 'r')
X		mode |= S_IRGRP;
X	NULLCHECK();
X	if (*s++ == 'w')
X		mode |= S_IWGRP;
X	NULLCHECK();
X	if (*s == 'x' || *s == 's')
X		mode |= S_IXGRP;
X	s++;
X	NULLCHECK();
X	if (*s++ == 'r')
X		mode |= S_IROTH;
X	NULLCHECK();
X	if (*s++ == 'w')
X		mode |= S_IWOTH;
X	NULLCHECK();
X	if (*s == 'x' || *s == 't')
X		mode |= S_IXOTH;
X	s++;
X	NULLCHECK();
X	return mode;
}
SHAR_EOF
chmod 0644 readdir.c ||
echo 'restore of readdir.c failed'
Wc_c="`wc -c < 'readdir.c'`"
test 13063 -eq "$Wc_c" ||
	echo 'readdir.c: original size 13063, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= change_dir.c ==============
if test -f 'change_dir.c' -a X"$1" != X"-c"; then
	echo 'x - skipping change_dir.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting change_dir.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'change_dir.c' &&
#include "ftptool.h"
X
int dirlastmtime;
X
#ifdef USE_PROTOTYPES
int	checkdir(char *dirname)
#else
int	checkdir(dirname)
char	*dirname;
#endif
{
X	struct stat buf;
X
X	if (lstat(dirname, &buf) == -1) {
X		if (errno == ENOENT) 
X			return ENOENT;
X		return 1;
X	}
X
X	if (buf.st_mtime > local_dircache.first->mtime) {
X		return 1;
X	}
X	return 0;
}
X
#ifdef USE_PROTOTYPES
int dirwasmodified(void)
#else
int dirwasmodified()
#endif
{
X	int	error;
X	char	*dirname = local_dircache.first->name;
X
X	if (cache_lookup(&local_dircache, dirname) == NULL)
X		return 0;
X	/* first now */
X
X	error = checkdir(dirname);
X	if (error == ENOENT) {
X		if (xv_get(local_window.frame, XV_SHOW) == FALSE) {
X			xv_set(local_window.frame, 
X				XV_SHOW, TRUE, 
X				NULL);
X		}
X		local_footer_message("Current directory was deleted. Changing to /tmp.",
X			(char *)NULL);
X		clear_slist(local_window.list);
X		xv_set(local_window.list, 
X			XV_SHOW, TRUE, 
X			NULL);
X		dircache_delete(&local_dircache, dirname);
X		change_local_dir("/tmp", 0);
X		return 1;
X	} else if (error != 0) {
X		local_footer_message("Current directory was modified. Rereading.", 
X			(char *)NULL);
X		if (xv_get(local_window.frame, XV_SHOW) == FALSE) {
X			xv_set(local_window.frame, 
X				XV_SHOW, TRUE, 
X				NULL);
X		}
X		clear_slist(local_window.list);
X		xv_set(local_window.list, 
X			XV_SHOW, TRUE, 
X			NULL);
X		dircache_delete(&local_dircache, dirname);
X		change_local_dir(dirname, 0);
X		return 1;
X	}
X	return 0;
}
X
#ifdef USE_PROTOTYPES
int change_local_dir(char *s, int force)
#else
int change_local_dir(s, force)
char	*s;
int		force;
#endif
{
X	static char	cld[MAXPATHLEN + 2];
X	extern char *sys_errlist[];
X	struct dirlist *head = NULL;
X	int		wasinactive;
X	int		rval = 0;
X	int		error;
X	char	*dir = NULL;
#if defined(SYSV) || defined(SYSV386)
X	struct statvfs fsbuf;
#else
X	struct statfs fsbuf;
#endif
X
X	wasinactive = xv_get(local_window.list, PANEL_INACTIVE);
X	if (wasinactive == FALSE) {
X		xv_set(local_window.list, 
X			PANEL_INACTIVE, TRUE, 
X			NULL);
X	}
X	cursor_busy();
X	local_footer_message("Reading directory...", (char *)NULL);
X	local_right_footer_message("", (char *)NULL);
X	dir = expand_dirname(s);
X	if (dir == NULL) {
X		fprintf(stderr, "out of memory\n");
X		goto out;
X	}
X	if (chdir(dir) == -1) {
X        if (errno == ENOENT) {
X            if (rval = ask_make_dir(dir)) { 
X				if (rval == -1) {
X					local_footer_message("", (char *)NULL);
X					/* user canceled. */
X					goto out;
X				}
X				local_footer_message("Could not make directory: %s",
X                        sys_errlist[rval], (char *)NULL);
X                goto out;
X            }
X			if (chdir(dir) == -1) {
X				rval = errno;
X				local_footer_message("Could not change to directory: %s",
X                        sys_errlist[rval], (char *)NULL);
X				goto out;
X			}
X		} else {
X			rval = errno;
X			local_footer_message("Could not change to directory: %s",
X					sys_errlist[rval], (char *)NULL);
X			goto out;
X		}
X	}
X
X	clear_slist(local_window.list);
X
X	local_list_ndirs = 0;
X	local_list_nfiles = 0;
X	local_list_nothers = 0;
X	change_local_list_menu();
X
X	if (getcwd(cld, sizeof(cld)) == NULL) {
X		/* Failure */
X		goto out;
X	}
X
X	xv_set(local_window.directory, 
X		PANEL_VALUE, cld, 
X		NULL);
X
#if defined(SYSV) || defined(SYSV386)
X	if (statvfs(cld, &fsbuf) == -1) {
X		sprintf(scratch, "statvfs failed: %s", sys_errlist[errno]);
X	} 
#else
X	if (statfs(cld, &fsbuf) == -1) {
X		sprintf(scratch, "statfs failed: %s", sys_errlist[errno]);
X	}
#endif
X	else {
X		sprintf(scratch, "%d Kbytes (%d%% free)", 
X			(int)(fsbuf.f_bsize / 1024.0 * fsbuf.f_bavail), 
X			(int)(100.0 * fsbuf.f_bavail / 
X				(fsbuf.f_blocks - (fsbuf.f_bfree - fsbuf.f_bavail))));
X	}
X	xv_set(local_window.space,
X		PANEL_LABEL_STRING, scratch,
X		NULL);
X
X	if (force)
X		dircache_delete(&local_dircache, cld);
X
X	head = cache_lookup(&local_dircache, cld);
X	if (head == NULL) {
X		/* cache miss */
X		head = read_local_dir(cld);
X		if (head == NULL) {
X			fprintf(stderr, "Out of memory\n");
X			rval = 1;
X			goto out;
X		}
X		/* add to cache */
X		dircache_add(&local_dircache, cld, head);
X		local_dircache.first->mtime = dirlastmtime;
X	} else if (error = checkdir(cld)) {
X		dircache_delete(&local_dircache, cld);
X		if (error == ENOENT) {
X			local_footer_message("%s does not exist.", cld, (char *)NULL);
X			goto out;
X		}
X		/* else reread */
X		head = read_local_dir(cld);
X		if (head == NULL) {
X			fprintf(stderr, "Out of memory\n");
X			rval = 1;
X			goto out;
X		}
X		/* add to cache */
X		dircache_add(&local_dircache, cld, head);
X		local_dircache.first->mtime = dirlastmtime;
X	}
X
X
X	dirlist_to_slist(local_window.list, head);
X
X	local_show_items();
X	local_footer_message("", (char *)NULL);
out:
X	cursor_normal();
X
X	if (dir)
X		free(dir);
X	if (wasinactive == FALSE) {
X		xv_set(local_window.list, 
X			PANEL_INACTIVE, FALSE, 
X			NULL);
X	}
X	XFlush(dpy);
X	return rval;
}
X
#ifdef USE_PROTOTYPES
int change_remote_dir(char *s, int force)
#else
int change_remote_dir(s, force)
char	*s;
int	force;
#endif
{
X	char	*ftperr;
X	char	crd[MAXPATHLEN + 1];
X	struct dirlist *head = NULL;
X	int		wasinactive;
X	char	*dir=NULL;
X	int		rval=0;
X	int		pwdfailed = 0;
X	char	*quote;
X
X	wasinactive = xv_get(base_window.list, PANEL_INACTIVE);
X	if (wasinactive == FALSE) {
X		xv_set(base_window.list, 
X			PANEL_INACTIVE, TRUE, 
X			NULL);
X	}
X	if (ping_server())
X		goto out;
X	cursor_busy();
X	/* send cd command */
X	footer_message("Reading directory...", (char *)NULL);
X	right_footer_message("", (char *)NULL);
X	dir = strdup(s);
X	if (dir == NULL)
X		goto out;
X	if (!strcmp(dir, "..")) {
X		if (up_one_level())
X			goto out;
X	} else if (strcmp(dir, ".")) {
X		extern int code;
X
X		code = -1;
X		command("CWD %s", dir);
X		/* success */
X		/*
X		 250 CWD command successful.
X		 */
X		/* failure */
X		/*
X		 550 k: No such file or directory
X		 */
X	 	if (code == 550) {
X			ftperr = index(response_line, ':');
X			if (ftperr == NULL) {
X				rval = 1;
X				goto out;
X			}
X			if (!strncmp(ftperr, ": Not a directory.", 18)) {
X				footer_message("%s is not a directory.", dir, (char *)NULL);
X				rval = ENOTDIR;
X				goto out;
X			}
X			if (rval = ask_make_remote_dir(dir)) {
X				if (rval == -1) {
X					footer_message("", (char *)NULL);
X					/* user cancelled */
X					goto out;
X				}
X				footer_message("Could not make directory.", (char *)NULL);
X				goto out;
X			}
X			command("CWD %s", dir);
X			if (code == 550) {
X				sprintf(scratch, "%s: No such file or directory.", dir);
X				ftperr = ftp_error(' ', scratch);
X				footer_message(ftperr, (char *)NULL);
X				rval = 1;
X				goto out;
X			}
X		} 
X	}
X
X	clear_slist(base_window.list);
X
X	remote_list_ndirs = 0;
X	remote_list_nfiles = 0;
X	remote_list_nothers = 0;
X
X	change_remote_list_menu();
X
X	/* set current directory */
X	if (command("PWD") == ERROR && code == 500) {
X		/*
X		footer_message("pwd not recognized.", (char *)NULL);
X		*/
X		/* try quote xpwd */
X		if (command("XPWD") == ERROR && code == 500) {
X			footer_message("pwd and xpwd not recognized.", (char *)NULL);
X			pwdfailed = 1;
X		}
X	}
X	/* response */
X	/*
X	 25[17] "/" is current directory.
X	 257 PWD: "/Print_Output" is current directory.
X	 * 
X	 * Skip to first double-quote, since they seem to have that.
X	 */
X	crd[0] = '\0';
X	if (pwdfailed) {
X		force = 1;
X	} else if (!strncmp(response_line, "257", 3)) {
X		quote = strchr(response_line, '\"');
X		if (quote != NULL)
X			sscanf (quote, "\"%[^\"]\"", crd);
X	} else if (!strncmp(response_line, "251", 3)) {
X		quote = strchr(response_line, '\"');
X		if (quote != NULL)
X			sscanf (response_line, "\"%[^\"]\"", crd);
X	} else {
X		footer_message("pwd or xpwd returned bad response.", (char *)NULL);
X		force = 1;
X	}
X	xv_set(base_window.directory, 
X		PANEL_VALUE, crd, 
X		NULL);
X
X	if (force)
X		dircache_delete(&remote_dircache, crd);
X	head = cache_lookup(&remote_dircache, crd);
X	if (head == NULL) {
X		/* cache miss */
X		head = read_remote_dir(crd);
X		if (head == NULL) {
X			rval = ETIMEDOUT;
X			goto out;
X		}
X		dircache_add(&remote_dircache, crd, head);
X	}
X
X
X	dirlist_to_slist(base_window.list, head);
X
X	remote_show_items();
out:
X	if (rval == 0)
X		footer_message("", (char *)NULL);
X	cursor_normal();
X	if (dir)
X		free(dir);
/*
X	if (head)
X		free_dirlist(head);
*/
X	if (wasinactive == FALSE) {
X		xv_set(base_window.list, 
X			PANEL_INACTIVE, FALSE, 
X			NULL);
X	}
X	if (timedout)
X		timeout_disconnect();
X	XFlush(dpy);
X	return rval;
}
X
#ifdef USE_PROTOTYPES
char *expand_dirname(char *arg)
#else
char *expand_dirname(arg)
char	*arg;
#endif
{
X	char 	*slash;
X	char	*lastpart = "";
X	char	*path;
X	struct passwd *pwd;
X	char	*firstpart="";
X	char	*s;
X
X	if (arg[0] == '/' || (arg[0] != '~' && arg[0] != '$')) {
X		path = strdup(arg);
X		return path;
X	}
X	s = strdup(arg);
X	if (s == NULL)
X		return NULL;
X	if (slash = index(s, '/')) {
X		*slash = 0;
X		lastpart = slash + 1;
X	}
X	switch (s[0]) {
X	case '~': /* ~ or ~user */
X		if (s[1] == '\0') {
X			pwd = getpwuid(getuid());
X			if (pwd == NULL) {
X				footer_message("You are unknown to the system.", (char *)NULL);
X				free(s);
X				return NULL;
X			}
X		} else {
X			pwd = getpwnam(&s[1]);
X			if (pwd == NULL) {
X				footer_message("Unknown user %s.", &s[1], (char *)NULL);
X				free(s);
X				return NULL;
X			}
X		}
X		firstpart = pwd->pw_dir;
X		break;
X	case '$': /* Environment variable */
X		firstpart = getenv(&s[1]);
X		if (firstpart == NULL) {
X			footer_message("Unknown variable %s.", &s[1], (char *)NULL);
X			free(s);
X			return NULL;
X		}
X		break;
X	}
X	path = (char *)malloc((unsigned int)(strlen(firstpart)+1+strlen(lastpart)+1));
X	if (path == NULL) {
X		footer_message("Memory allocation failed.", (char *)NULL);
X		free(s);
X		return NULL;
X	}
X	if (lastpart[0] != '\0')
X		sprintf(path, "%s/%s", firstpart, lastpart);
X	else
X		strcpy(path, firstpart);
X	free(s);
X	return (path);
}
X
#ifdef USE_PROTOTYPES
int	delete_local_dir(char *dir)
#else
int	delete_local_dir(dir)
char	*dir;
#endif
{
X	struct dirlist *head = NULL;
X	struct dirlist *tmp;
X	extern char *sys_errlist[];
X	int	rval = 0;
X
X	if (chdir(dir) == -1) {
X		local_footer_message("Can not change to %s: %s", 
X			dir, sys_errlist[errno], (char *)NULL);
X		return errno;
X	}
X	head = read_local_dir(".");
X	if (head == NULL) {
X		fprintf(stderr, "Out of memory\n");
X		rval = ENOMEM;
X		goto out;
X	}
X	for (tmp = head->next; tmp != NULL; tmp = tmp->next)
X		if (S_ISDIR(tmp->mode)) {
X			if (rval = delete_local_dir(tmp->name))
X				goto out;
X		} else if (rval = delete_local_file(tmp->name, unlink))
X				goto out;
out:
X	if (head)
X		free_dirlist(head);
X	if (chdir("..") == -1) {
X		local_footer_message("Can not cd ..: %s", 
X			sys_errlist[errno], (char *)NULL);
X		return errno;
X	}
X	/* delete parent */
X	if (rval == 0)
X		rval = delete_local_file(dir, rmdir);
X	return rval;
}
X
#ifdef USE_PROTOTYPES
int delete_local_file(char *filename, int (*deletefunc)(const char *filename))
#else
int delete_local_file(filename, deletefunc)
char	*filename;
int		(*deletefunc)();
#endif
{
X	int	answer;
X	extern char *sys_errlist[];
#ifdef XVIEW3
X	Xv_notice notice;
#endif
X
X	if (confirmdeletes) {
X		sprintf(scratch, "Really delete %s?", filename);
#ifdef XVIEW3
X		notice = xv_create(base_window.panel, NOTICE,
X			NOTICE_MESSAGE_STRINGS,
X				scratch,
X				NULL,
X			NOTICE_BUTTON_YES, "Cancel",
X			NOTICE_BUTTON_NO, "Delete",
X			NOTICE_STATUS, &answer,
X			XV_SHOW, TRUE,
X			NULL);
X		xv_destroy_safe(notice);
#else
X		answer =  notice_prompt(base_window.panel, NULL,
X			NOTICE_MESSAGE_STRINGS,
X				scratch,
X				NULL,
X			NOTICE_BUTTON_YES, "Cancel",
X			NOTICE_BUTTON_NO, "Delete",
X			NULL);
#endif
X	} else
X		answer = NOTICE_NO;
X
X	if (answer == NOTICE_NO) {
X		local_footer_message("Deleting %s", filename, (char *)NULL);
X		if ((*deletefunc)(filename) == -1) {
X			local_footer_message("delete %s failed: %s", filename,
X				sys_errlist[errno], (char *)NULL);
X			return 1;
X		}
X		return 0;
X	}
X	return 1; /* deletion aborted */
}
X
#ifdef USE_PROTOTYPES
int	delete_remote_dir(char *dir)
#else
int	delete_remote_dir(dir)
char	*dir;
#endif
{
X	struct dirlist *head = NULL;
X	struct dirlist *tmp;
X	int	rval = 0;
X	char	*ftperr;
X
X	if (command("CWD %s", dir) == ERROR && code == 550) {
X		sprintf(scratch, "Can not change to %s", dir);
X		ftperr = ftp_error(' ', scratch);
X		footer_message(ftperr, (char *)NULL);
X		return 1;
X	}
X	head = read_remote_dir((char *)NULL);
X	if (head == NULL) {
X		rval = ENOMEM;
X		goto out;
X	}
X	for (tmp = head->next; tmp != NULL; tmp = tmp->next)
X		if (S_ISDIR(tmp->mode)) {
X			if (rval = delete_remote_dir(tmp->name))
X				goto out;
X		} else if (rval = delete_remote_file(tmp->name, "DELE"))
X				goto out;
out:
X	if (head)
X		free_dirlist(head);
X	if (up_one_level())
X		footer_message("Can not cd ..", (char *)NULL);
X		
X	/* delete parent */
X	if (rval == 0)
X		rval = delete_remote_file(dir, "RMD");
X	return rval;
}
X
#ifdef USE_PROTOTYPES
int delete_remote_file(char *filename, char *deletecmd)
#else
int delete_remote_file(filename, deletecmd)
char	*filename;
char	*deletecmd;
#endif
{
X	char	*ftperr;
X	int	answer;
#ifdef XVIEW3
X	Xv_notice notice;
#endif
X
X	if (confirmdeletes) {
X		sprintf(scratch, "Really delete %s?", filename);
#ifdef XVIEW3
X		notice = xv_create(base_window.panel, NOTICE,
X			NOTICE_MESSAGE_STRINGS,
X				scratch,
X				NULL,
X			NOTICE_BUTTON_YES, "Cancel",
X			NOTICE_BUTTON_NO, "Delete",
X			NOTICE_STATUS, &answer,
X			XV_SHOW, TRUE,
X			NULL);
X		xv_destroy_safe(notice);
#else
X		answer = notice_prompt(base_window.panel, NULL,
X			NOTICE_MESSAGE_STRINGS,
X				scratch,
X				NULL,
X			NOTICE_BUTTON_YES, "Cancel",
X			NOTICE_BUTTON_NO, "Delete",
X			NULL);
#endif
X	} else
X		answer = NOTICE_NO;
X
X	if (answer == NOTICE_NO) {
X		footer_message("Deleting %s", filename, (char *)NULL);
X		sprintf(scratch, "%s %s", deletecmd, filename);
X		if (command(scratch) == ERROR) {
X			sprintf(scratch, "delete %s failed", filename);
X			ftperr = ftp_error(' ', scratch);
X			footer_message(ftperr, (char *)NULL);
X			return 1;
X		}
X		return 0;
X	}
X	return 1; /* deletion aborted */
}
X
#ifdef USE_PROTOTYPES
int up_one_level(void)
#else
int up_one_level()
#endif
{
X	if (command("CDUP") == ERROR && code == 500) {
X		if (!strncmp(response_line, "500", 3)) {
X			/*
X			footer_message("cdup not recognized.", (char *)NULL);
X			*/
X			/* try quote xcup */
X			if (command("XCUP") == ERROR && code == 500) {
X				/* try cd .. */
X				code = -1;
X				if (command("CWD ..") == ERROR && code == 550) {
X					footer_message("cdup, xcup, and 'cd ..' failed. Try manually.", (char *)NULL);
X					return 1;
X				}
X			}
X		}
X	} 
X	return 0;
}
SHAR_EOF
chmod 0644 change_dir.c ||
echo 'restore of change_dir.c failed'
Wc_c="`wc -c < 'change_dir.c'`"
test 14252 -eq "$Wc_c" ||
	echo 'change_dir.c: original size 14252, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= event.c ==============
if test -f 'event.c' -a X"$1" != X"-c"; then
	echo 'x - skipping event.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting event.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'event.c' &&
#include "ftptool.h"
X
#ifdef USE_PROTOTYPES
void	local_cd_select(void)
#else
void	local_cd_select()
#endif
{
X	int 	nitems, selection, row;
X	struct dirlist *tmp;
X
X	local_footer_message("", (char *)NULL);
X	/* check to see that only one item is selected, and it is a directory */
X	nitems = xv_get(local_window.list, PANEL_LIST_NROWS);
X
X	selection = 0;
X	for (row = 0; row < nitems; row++)
X		if (xv_get(local_window.list, PANEL_LIST_SELECTED, row)) {
X			tmp = (struct dirlist *)xv_get(local_window.list, 
X				PANEL_LIST_CLIENT_DATA, row);
X			if (S_ISDIR(tmp->mode)) {
X				selection = row;
X				break;
X			}
X		}
X
X	tmp = (struct dirlist *)xv_get(local_window.list, 
X		PANEL_LIST_CLIENT_DATA, selection);
X
X	xv_set(local_window.list, 
X		PANEL_LIST_SELECT, selection, FALSE, 
X		NULL);
X	change_local_dir(tmp->name, 0);
}
X
#ifdef USE_PROTOTYPES
void	local_cd_text(void)
#else
void	local_cd_text()
#endif
{
X	char	*dir;
X
X	local_footer_message("", (char *)NULL);
X	dir = (char *)xv_get(local_window.directory, PANEL_VALUE);
X	if (*dir == '\0') {
X		local_footer_message("Please type in a pathname first.",(char *)NULL);
X		return;
X	}
X	change_local_dir(dir, 0);
}
X
#ifdef USE_PROTOTYPES
void	local_cd_dotdot(void)
#else
void	local_cd_dotdot()
#endif
{
X	local_footer_message("", (char *)NULL);
X	change_local_dir("..", 0);
}
X
#ifdef USE_PROTOTYPES
void	remote_cd_select(void)
#else
void	remote_cd_select()
#endif
{
X	int 	nitems, selection, row;
X	struct dirlist *tmp;
X
X	footer_message("", (char *)NULL);
X	/* check to see that only one item is selected, and it is a directory */
X	nitems = xv_get(base_window.list, PANEL_LIST_NROWS);
X	selection = 0;
X	for (row = 0; row < nitems; row++)
X		if (xv_get(base_window.list, PANEL_LIST_SELECTED, row)) {
X			tmp = (struct dirlist *)xv_get(base_window.list, 
X				PANEL_LIST_CLIENT_DATA, row);
X			if (non_unix || S_ISDIR(tmp->mode)) {
X				selection = row;
X				break;
X			}
X		}
X
X	tmp = (struct dirlist *)xv_get(base_window.list, 
X		PANEL_LIST_CLIENT_DATA, selection);
X
X	xv_set(base_window.list, 
X		PANEL_LIST_SELECT, selection, FALSE, 
X		NULL);
X	which_remote_file = strdup(tmp->name);
X	if (which_remote_file == NULL) {
X		fprintf(stderr, "Out of memory.\n");
X		return;
X	}
X	dowhat = DOREMOTECD;
X	notify_stop();
}
X
#ifdef USE_PROTOTYPES
void	remote_cd_text(void)
#else
void	remote_cd_text()
#endif
{
X	footer_message("", (char *)NULL);
X	which_remote_file = (char *)xv_get(base_window.directory, PANEL_VALUE);
X	if (*which_remote_file == '\0') {
X		footer_message("Please type in a pathname first.",(char *)NULL);
X		return;
X	}
X	if (!non_unix)
X		which_remote_file = expand_dirname(which_remote_file);
X	else
X		which_remote_file = strdup(which_remote_file);
X	if (which_remote_file == NULL)
X		return;
X	dowhat = DOREMOTECD;
X	notify_stop();
}
X
#ifdef USE_PROTOTYPES
void	remote_cd_dotdot(void)
#else
void	remote_cd_dotdot()
#endif
{
X	footer_message("", (char *)NULL);
X	which_remote_file = strdup("..");
X	if (which_remote_file == NULL) {
X		fprintf(stderr,"Out of memory.\n");
X		return;
X	}
X	dowhat = DOREMOTECD;
X	notify_stop();
}
X
#ifdef USE_PROTOTYPES
Notify_value destroy_func(Notify_client client, Destroy_status status)
#else
Notify_value destroy_func(client, status)
Notify_client	client;
Destroy_status	status;
#endif
{
X	int	answer;
X	static int triedonce;
#ifdef XVIEW3
X	Xv_notice notice;
#endif
X
X	if (status == DESTROY_SAVE_YOURSELF) {
X		/* save state. Not a death */
X		return NOTIFY_DONE;
X	}
X	if (connected) {
#ifdef XVIEW3
X		notice = xv_create(base_window.panel, NOTICE,
X			NOTICE_MESSAGE_STRINGS,
X				"You are still connected.",
X				NULL,
X			NOTICE_BUTTON_YES,  "Cancel",
X			NOTICE_BUTTON_NO,	"Quit anyway",
X			NOTICE_STATUS, &answer,
X			XV_SHOW, TRUE,
X			NULL);
X		xv_destroy_safe(notice);
#else
X		answer = notice_prompt(base_window.panel, NULL,
X			NOTICE_MESSAGE_STRINGS,
X				"You are still connected.",
X				NULL,
X			NOTICE_BUTTON_YES,  "Cancel",
X			NOTICE_BUTTON_NO,	"Quit anyway",
X			NULL);
#endif
X		if (answer == NOTICE_YES)
X			return (Notify_value)notify_veto_destroy(client);
X	}
X	if (list_changed) {
X		if (status == DESTROY_CHECKING) {
#ifdef XVIEW3
X			notice = xv_create(base_window.panel, NOTICE,
X				NOTICE_MESSAGE_STRINGS,
X					"Your host list has changed. You can",
X					NULL,
X				NOTICE_BUTTON_YES,  "Save changes",
X				NOTICE_BUTTON,      "Quit anyway", 2,
X				NOTICE_BUTTON,      "Cancel quit", 3,
X				NOTICE_STATUS, &answer,
X				XV_SHOW, TRUE,
X				NULL);
X			xv_destroy_safe(notice);
#else
X			answer = notice_prompt(base_window.panel, NULL,
X				NOTICE_MESSAGE_STRINGS,
X					"Your host list has changed. You can",
X					NULL,
X				NOTICE_BUTTON_YES,  "Save changes",
X				NOTICE_BUTTON,      "Quit anyway", 2,
X				NOTICE_BUTTON,      "Cancel quit", 3,
X				NULL);
#endif
X			triedonce = 1;
X		} else if (!triedonce) {
#ifdef XVIEW3
X			notice = xv_create(base_window.panel, NOTICE,
X				NOTICE_MESSAGE_STRINGS,
X					"Your host list has changed. You can",
X					NULL,
X				NOTICE_BUTTON_YES,  "Save changes",
X				NOTICE_BUTTON,      "Quit anyway", 2,
X				NOTICE_STATUS, &answer,
X				XV_SHOW, TRUE,
X				NULL);
X			xv_destroy_safe(notice);
#else
X			answer = notice_prompt(base_window.panel, NULL,
X				NOTICE_MESSAGE_STRINGS,
X					"Your host list has changed. You can",
X					NULL,
X				NOTICE_BUTTON_YES,  "Save changes",
X				NOTICE_BUTTON,      "Quit anyway", 2,
X				NULL);
#endif
X		} else {
X			/* perhaps something has gone wrong. */
X			answer = 2;
X		}
X
X		switch (answer) {
X		case NOTICE_YES:
X			list_changed=0;
X			timestamped = 0;
X			write_ftptoolrc();
X			break;
X		case 2:
X			/* avoid saving timestamps, if they are there */
X			timestamped = 0;
X			break;
X		case 3:
X			return (Notify_value)notify_veto_destroy(client);
X			break;
X		}
X	}
X	if (timestamped) {
X		timestamped = 0;
X		write_ftptoolrc();
X	}
X
X	quit_ftp();
X
X	dowhat = DOQUIT;
X
X	switch(status) {
X	case DESTROY_CHECKING:
X		break;
X	case DESTROY_CLEANUP:
X		return notify_next_destroy_func(client, status);
X		break;
X	case DESTROY_PROCESS_DEATH:
X		exit(1);
X		break;
X	case DESTROY_SAVE_YOURSELF:
X		fprintf(stderr, "Impossible DESTROY_SAVE_YOURSELF event in last switch of destroy_func.\n");
X		break;
X	}
X	return NOTIFY_DONE;
}
X
#ifdef USE_PROTOTYPES
Notify_value sig_func(void)
#else
Notify_value sig_func()
#endif
{
X	if (xv_destroy_safe(base_window.frame) == XV_OK) {
X		quit_ftp();
X		exit(1);
X	}
X	return NOTIFY_DONE;
}
X
#ifdef USE_PROTOTYPES
void cycle_busy_icon(void)
#else
void cycle_busy_icon()
#endif
{
X	static int i;
X
X	xv_set(frame_icon, 
X		ICON_IMAGE, busy_glyphs[i], 
X		ICON_TRANSPARENT, TRUE,
X		NULL);
X	i++;
X	if (i == nbusyicons)
X		i = 0;
}
X
static struct itimerval busy_itimer = {
X	{0, 200000,},
X	{0, 200000,}
};
X
#ifdef USE_PROTOTYPES
void start_busy_cycle(void)
#else
void start_busy_cycle()
#endif
{
X	notify_set_itimer_func(base_window.frame, (Notify_func)cycle_busy_icon, 
X		ITIMER_REAL, &busy_itimer, (struct itimerval *)NULL);
}
X
#ifdef USE_PROTOTYPES
void end_busy_cycle(void)
#else
void end_busy_cycle()
#endif
{
X	notify_set_itimer_func(base_window.frame, NOTIFY_FUNC_NULL, ITIMER_REAL,
X		&busy_itimer, (struct itimerval *)NULL);
X	xv_set(frame_icon, 
X		ICON_IMAGE, ftptool_glyph,
X		ICON_TRANSPARENT, TRUE,
X		NULL);
}
X
#ifdef USE_PROTOTYPES
void props_event_proc(Panel panel, Event *event)
#else
void props_event_proc(panel, event)
Panel	panel;
Event *event;
#endif
{
X	if (event_action(event) == ACTION_PROPS) {
X		xv_set(tool_property_window.frame, 
X			XV_SHOW, TRUE, 
X			NULL);
X	}
}
X
#ifdef USE_PROTOTYPES
void base_event_proc(Xv_Window window, Event *event)
#else
void base_event_proc(window, event)
XXv_Window	window;
Event *event;
#endif
{
X	int height;
X	int	y;
X	int	rows;
X	int	rowsize;
X	int	width;
X
X	switch(event_id(event)) {
X	case WIN_RESIZE:
X		height = xv_get(base_window.panel, XV_HEIGHT);
X		width = xv_get(base_window.panel, XV_WIDTH);
X		y = xv_get(base_window.list, PANEL_ITEM_Y);
X		rowsize = xv_get(base_window.list, PANEL_LIST_ROW_HEIGHT);
X		rows = (height - y - 45) / rowsize;
X		if (rows <= 0)
X			rows = 1;
X		xv_set(base_window.list, 
X			PANEL_LIST_DISPLAY_ROWS, rows,
X			PANEL_LIST_WIDTH, width - 30, 
X			PANEL_PAINT, PANEL_NONE,
X			NULL);
X		panel_paint(base_window.list, PANEL_CLEAR);
X		break;
X	default:
X		break;
X	}
}
X
#ifdef USE_PROTOTYPES
void resize_window(Panel panel, Panel_item list, Panel_item dismiss)
#else
void resize_window(panel, list, dismiss)
Panel	panel;
Panel_item	list;
Panel_item	dismiss;
#endif
{
X	int height;
X	int	y;
X	int	rows;
X	int	rowsize;
X	int	width;
X	Rect	*butrect;
X
X	height = xv_get(panel, XV_HEIGHT);
X	width = xv_get(panel, XV_WIDTH);
X	y = xv_get(list, PANEL_ITEM_Y);
X	rowsize = xv_get(list, PANEL_LIST_ROW_HEIGHT);
X	rows = (height - y - 45) / rowsize;
X	/* leave room for dismiss button */
X	if (!openlook_mode)
X		rows -= 1;
X	if (rows <= 0)
X		rows = 1;
X	xv_set(list, 
X		PANEL_LIST_DISPLAY_ROWS, rows,
X		PANEL_LIST_WIDTH, width - 30, 
X		PANEL_PAINT, PANEL_NONE,
X		NULL);
X	panel_paint(list, PANEL_CLEAR);
X	/* for non-openlook mode */
X	butrect = (Rect *)xv_get(dismiss, XV_RECT);
X	xv_set(dismiss,
X		XV_X, width/2 - butrect->r_width/2,
X		XV_Y, height - butrect->r_height,
X		NULL);
}
X
#ifdef USE_PROTOTYPES
void local_event_proc(Xv_Window window, Event *event)
#else
void local_event_proc(window, event)
XXv_Window	window;
Event *event;
#endif
{
X	switch(event_id(event)) {
X	case WIN_RESIZE:
X		resize_window(local_window.panel, local_window.list,
X			local_window.dismiss);
X		break;
X	default:
X		break;
X	}
}
X
#ifdef USE_PROTOTYPES
void schedule_event_proc(Xv_Window window, Event *event)
#else
void schedule_event_proc(window, event)
XXv_Window	window;
Event *event;
#endif
{
X	int height;
X	int	y;
X	int	rows;
X	int	rowsize;
X	int	width;
X
X	switch(event_id(event)) {
X	case WIN_RESIZE:
X		height = xv_get(schedule_window.panel, XV_HEIGHT);
X		width = xv_get(schedule_window.panel, XV_WIDTH);
X		y = xv_get(schedule_window.send_list, PANEL_ITEM_Y);
X		rowsize = xv_get(schedule_window.send_list, PANEL_LIST_ROW_HEIGHT);
X		rows = (height - y - 45) / rowsize;
X		if (rows <= 0)
X			rows = 1;
X		xv_set(schedule_window.send_list, 
X			PANEL_LIST_DISPLAY_ROWS, rows,
X			PANEL_LIST_WIDTH, width - 30, 
X			PANEL_PAINT, PANEL_NONE,
X			NULL);
X		xv_set(schedule_window.receive_list, 
X			PANEL_LIST_DISPLAY_ROWS, rows,
X			PANEL_LIST_WIDTH, width - 30, 
X			PANEL_PAINT, PANEL_NONE,
X			NULL);
X		if (xv_get(schedule_window.send_list, XV_SHOW) == TRUE)
X			panel_paint(schedule_window.send_list, PANEL_CLEAR);
X		else
X			panel_paint(schedule_window.receive_list, PANEL_CLEAR);
X		break;
X	default:
X		break;
X	}
}
X
#ifdef USE_PROTOTYPES
void host_event_proc(Xv_Window window, Event *event)
#else
void host_event_proc(window, event)
XXv_Window	window;
Event *event;
#endif
{
X	int	width;
X	int panelwidth;
X	Rect	*connect_rect;
X	Rect	*dismiss_rect;
X	int	space;
X	int	pos;
X	int	y;
X	Panel_item	item;
X	Panel_item_type	item_type;
X
X	switch(event_id(event)) {
X	case WIN_RESIZE:
X		width = xv_get(host_window.frame, XV_WIDTH);
X		if (xv_get(host_window.advanced.panel, XV_SHOW) == TRUE)
X			panelwidth = width / 2;
X		else
X			panelwidth = width - 2;
X		xv_set(host_window.panel, 
X			XV_WIDTH, width,
X			NULL);
X		xv_set(host_window.basic.panel, 
X			XV_WIDTH, panelwidth,
X			NULL);
X		xv_set(host_window.advanced.panel, 
X			XV_WIDTH, panelwidth + 2,
X			XV_X, panelwidth - 3,
X			NULL);
X		PANEL_EACH_ITEM(host_window.basic.panel, item) {
X			item_type = (Panel_item_type)xv_get(item, PANEL_ITEM_CLASS);
X			if (item_type == PANEL_TEXT_ITEM)
X				resize_text_item(host_window.basic.panel, item);
X		} PANEL_END_EACH;
X		PANEL_EACH_ITEM(host_window.advanced.panel, item) {
X			item_type = (Panel_item_type)xv_get(item, PANEL_ITEM_CLASS);
X			if (item_type == PANEL_TEXT_ITEM)
SHAR_EOF
true || echo 'restore of event.c failed'
fi
echo 'End of  part 4'
echo 'File event.c is continued in part 5'
echo 5 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
