Path: uunet!sun-barr!ames!elroy.jpl.nasa.gov!swrinde!mips!msi!dcmartin
From: Mike.Sullivan@EBay.Sun.COM (Mike Sullivan {AKA Simon BarSinister})
Newsgroups: comp.sources.x
Subject: v18i084: Ftptool 4.3 (XVIEW), Part02/12
Message-ID: <1992Aug18.153539.28611@msi.com>
Date: 18 Aug 92 15:35:39 GMT
References: <csx-18i083-ftptool-4.3@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1949
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: Mike.Sullivan@EBay.Sun.COM (Mike Sullivan {AKA Simon BarSinister})
Posting-number: Volume 18, Issue 84
Archive-name: ftptool-4.3/part02

#!/bin/sh
# this is part.02 (part 2 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file menu_funcs.h continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 2; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping menu_funcs.h'
else
echo 'x - continuing file menu_funcs.h'
sed 's/^X//' << 'SHAR_EOF' >> 'menu_funcs.h' &&
void change_local_list_menu(void);
void change_remote_list_menu(void);
Menu props_menu_gen(Menu m, Menu_generate op);
Menu send_list_menu_gen(Menu m, Menu_generate op);
Menu receive_list_menu_gen(Menu m, Menu_generate op);
Menu host_menu_gen(Menu m, Menu_generate op);
X
#else
X
Menu file_menu_gen();
Menu file_copy_menu_gen();
Menu file_delete_menu_gen();
Menu view_menu_gen();
void change_local_list_menu();
void change_remote_list_menu();
Menu props_menu_gen();
Menu send_list_menu_gen();
Menu receive_list_menu_gen();
Menu host_menu_gen();
X
#endif
SHAR_EOF
echo 'File menu_funcs.h is complete' &&
chmod 0644 menu_funcs.h ||
echo 'restore of menu_funcs.h failed'
Wc_c="`wc -c < 'menu_funcs.h'`"
test 770 -eq "$Wc_c" ||
	echo 'menu_funcs.h: original size 770, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= misc.h ==============
if test -f 'misc.h' -a X"$1" != X"-c"; then
	echo 'x - skipping misc.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting misc.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'misc.h' &&
X
#ifdef USE_PROTOTYPES
X
void log_char(char ch);
void log_message(char *s);
char *ftp_error(char ch, char *def);
void footer_message(char *format, ...);
void local_footer_message(char *format, ...);
void right_footer_message(char *format, ...);
void local_right_footer_message(char *format, ...);
void schedule_footer_message(char *format, ...);
void status_footer_message(char *format, ...);
void timeout_disconnect(void);
void close_files(void);
void quit_ftp(void);
void disconnect(void);
void xfer_buttons_inactive(void);
void xfer_buttons_active(void);
void cursor_busy(void);
void cursor_normal(void);
void show_stats(struct file_property_window *file_props,
X	struct dirlist *tmp);
void inactivate_props(struct file_property_window *file_props);
int ask_make_dir(char *s);
int make_dirs(char *s, int make_last);
int ask_make_remote_dir(char *s);
int make_remote_dirs(char *s, int make_last);
void set_geometry(char *s, Frame frame, int def_width, int def_height, 
X	int def_x, int def_y);
void save_geometry(char *s, Frame frame);
void justify_items(Panel panel, int resize);
void resize_text_item(Panel panel, Panel_item text_item);
char *linkval(char *string);
char *linkname(char *string);
void add_dismiss(Panel panel, Panel_item first, Panel_item dismiss);
void update_date(int doscheddefault);
Notify_value date_wrapper(void);
void local_show_items(void);
void remote_show_items(void);
int ping_server(void);
X
#else
X
void log_char();
void log_message();
char *ftp_error();
void footer_message();
void local_footer_message();
void right_footer_message();
void local_right_footer_message();
void schedule_footer_message();
void status_footer_message();
void timeout_disconnect();
void close_files();
void quit_ftp();
void disconnect();
void xfer_buttons_inactive();
void xfer_buttons_active();
void cursor_busy();
void cursor_normal();
void show_stats();
void inactivate_props();
int ask_make_dir();
int make_dirs();
int ask_make_remote_dir();
int make_remote_dirs();
void set_geometry();
void save_geometry();
void justify_items();
void resize_text_item();
char *linkval();
char *linkname();
void add_dismiss();
void update_date();
Notify_value date_wrapper();
void local_show_items();
void remote_show_items();
int ping_server();
X
#endif
SHAR_EOF
chmod 0644 misc.h ||
echo 'restore of misc.h failed'
Wc_c="`wc -c < 'misc.h'`"
test 2248 -eq "$Wc_c" ||
	echo 'misc.h: original size 2248, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= more ==============
if test -f 'more' -a X"$1" != X"-c"; then
	echo 'x - skipping more (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting more (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'more' &&
|: No such file or directory
SHAR_EOF
chmod 0644 more ||
echo 'restore of more failed'
Wc_c="`wc -c < 'more'`"
test 29 -eq "$Wc_c" ||
	echo 'more: original size 29, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= patchlevel.h ==============
if test -f 'patchlevel.h' -a X"$1" != X"-c"; then
	echo 'x - skipping patchlevel.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting patchlevel.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'patchlevel.h' &&
#define VERSION		4
#define PATCHLEVEL	3
SHAR_EOF
chmod 0644 patchlevel.h ||
echo 'restore of patchlevel.h failed'
Wc_c="`wc -c < 'patchlevel.h'`"
test 40 -eq "$Wc_c" ||
	echo 'patchlevel.h: original size 40, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= readdir.h ==============
if test -f 'readdir.h' -a X"$1" != X"-c"; then
	echo 'x - skipping readdir.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting readdir.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'readdir.h' &&
X
#define PERMS		1
#define LINKS		2
#define USER		3
#define GROUP		4
#define SIZE		5
#define MONTH		6
#define DAY			7
#define TIME		8
#define NAME		9
#define SKIP		10
#define NONUNIX		11
#define LOWERNAME	12
#define MAXTOKENS	12
X
#ifdef USE_PROTOTYPES
X
struct dirlist *read_local_dir(char *dirname);
struct dirlist *read_remote_dir(char *dname);
int	parse_line(struct dirlist *head, char *line, int *temp_non_unix);
char *dir_parse_to_pattern(char *dir_parse);
int perms(char *s, int *temp_non_unix);
X
#else
X
struct dirlist *read_local_dir();
struct dirlist *read_remote_dir();
int	parse_line();
char *dir_parse_to_pattern();
int perms();
X
#endif
SHAR_EOF
chmod 0644 readdir.h ||
echo 'restore of readdir.h failed'
Wc_c="`wc -c < 'readdir.h'`"
test 646 -eq "$Wc_c" ||
	echo 'readdir.h: original size 646, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= schedule.h ==============
if test -f 'schedule.h' -a X"$1" != X"-c"; then
	echo 'x - skipping schedule.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting schedule.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'schedule.h' &&
X
#ifdef USE_PROTOTYPES
X
struct schedule *new_schedule(char *menu_name, int direction, 
X	time_t date, char *filename, struct hostlist *hl);
struct schedule *add_schedule(struct schedule *head, char *menu_name, 
X	int direction, time_t date, char *filename, struct hostlist *hl);
void free_schedule(struct schedule *head);
void delete_schedule(struct schedule *head, char *menu_name, int direction);
void reorder_list(struct schedule *head);
void load_schedule(void);
void set_current_schedule_proc(Menu menu, Menu_item menu_item);
int schedule_exists(struct schedule *head, char *menu_name, 
X	int direction);
void enter_schedule_info(int warnchange);
void schedule_add_proc(Menu menu, Menu_item menu_item);
void schedule_change_proc(Menu menu, Menu_item menu_item);
void schedule_delete_proc(Menu menu, Menu_item menu_item);
void schedule_item_proc(Menu menu, Menu_item menu_item);
void reload_schedule_menu(struct schedule *head);
void action_choice_proc(Panel_item item, unsigned int value, 
X	Event *event);
Notify_value schedule_timer_proc(void);
void activate_schedule_timer(void);
void batch_process_proc(Panel_item item, Event *event);
void doschedule(void);
X
#else
X
struct schedule *new_schedule();
struct schedule *add_schedule();
void free_schedule();
void delete_schedule();
void reorder_list();
void load_schedule();
void set_current_schedule_proc();
int schedule_exists();
void enter_schedule_info();
void schedule_add_proc();
void schedule_change_proc();
void schedule_delete_proc();
void schedule_item_proc();
void reload_schedule_menu();
void action_choice_proc();
Notify_value schedule_timer_proc();
void activate_schedule_timer();
void batch_process_proc();
void doschedule();
X
#endif
SHAR_EOF
chmod 0644 schedule.h ||
echo 'restore of schedule.h failed'
Wc_c="`wc -c < 'schedule.h'`"
test 1700 -eq "$Wc_c" ||
	echo 'schedule.h: original size 1700, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= schedule_struct.h ==============
if test -f 'schedule_struct.h' -a X"$1" != X"-c"; then
	echo 'x - skipping schedule_struct.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting schedule_struct.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'schedule_struct.h' &&
struct schedule {
X	char	*menu_name;
X	int		direction;
X	time_t	date;
X	char	*filename;
X	struct hostlist *hl;
X	struct schedule *next;
};
X
#define RECV	0
#define	SEND	1
X
SHAR_EOF
chmod 0644 schedule_struct.h ||
echo 'restore of schedule_struct.h failed'
Wc_c="`wc -c < 'schedule_struct.h'`"
test 165 -eq "$Wc_c" ||
	echo 'schedule_struct.h: original size 165, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= tar.viewer.icon ==============
if test -f 'tar.viewer.icon' -a X"$1" != X"-c"; then
	echo 'x - skipping tar.viewer.icon (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting tar.viewer.icon (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'tar.viewer.icon' &&
/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0C00,	0x0000,	0x0000,
X	0x0000,	0x0C00,	0x0000,	0x0000,
X	0x0000,	0x0C00,	0x0000,	0x0000,
X	0x0000,	0x0C00,	0x0000,	0x0000,
X	0x0000,	0x3F07,	0xC0CC,	0x0000,
X	0x0000,	0x3F0F,	0xE0DC,	0x0000,
X	0x0000,	0x0C18,	0x70FC,	0x0000,
X	0x0000,	0x0C18,	0x30E0,	0x0000,
X	0x0000,	0x0C00,	0x30C0,	0x0000,
X	0x0000,	0x0C01,	0xF0C0,	0x0000,
X	0x0000,	0x0C0F,	0xF0C0,	0x0000,
X	0x0000,	0x0C1E,	0x30C0,	0x0000,
X	0x0000,	0x0C38,	0x30C0,	0x0000,
X	0x0000,	0x0C30,	0x30C0,	0x0000,
X	0x0000,	0x0C30,	0x70C0,	0x0000,
X	0x0000,	0x0C38,	0xF0C0,	0x0000,
X	0x0000,	0x0F1F,	0xB8C0,	0x0000,
X	0x0000,	0x070F,	0x18C0,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x6000,	0x0000,	0x0000,
X	0x0000,	0x6000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0186,	0x61E1,	0x8C61,	0xE1B0,
X	0x0186,	0x63F1,	0x8C63,	0xF1B0,
X	0x0186,	0x6619,	0x8C66,	0x19C0,
X	0x00CC,	0x6618,	0xCCC6,	0x1980,
X	0x00CC,	0x67F8,	0xCCC7,	0xF980,
X	0x00CC,	0x6600,	0xD2C6,	0x0180,
X	0x0048,	0x6600,	0x5286,	0x0180,
X	0x0078,	0x6718,	0x7387,	0x1980,
X	0x0030,	0x63F8,	0x3303,	0xF980,
X	0x0030,	0x61E0,	0x3301,	0xE180,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
X	0x0000,	0x0000,	0x0000,	0x0000,
SHAR_EOF
chmod 0644 tar.viewer.icon ||
echo 'restore of tar.viewer.icon failed'
Wc_c="`wc -c < 'tar.viewer.icon'`"
test 2190 -eq "$Wc_c" ||
	echo 'tar.viewer.icon: original size 2190, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= tar_view.h ==============
if test -f 'tar_view.h' -a X"$1" != X"-c"; then
	echo 'x - skipping tar_view.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting tar_view.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'tar_view.h' &&
X
#ifdef USE_PROTOTYPES
X
void handle_tarfile(char *filename);
void list_proc(void);
void doextract_proc(void);
void tar_extract_proc(void);
void start_tar(char *options, char *filename);
Notify_value input_func(Notify_client client, int fd);
Notify_value tar_destroy_func(Notify_client client, Destroy_status status);
void tar_quit_proc(void);
X
#else
X
void handle_tarfile();
void list_proc();
void doextract_proc();
void tar_extract_proc();
void start_tar();
Notify_value input_func();
Notify_value tar_destroy_func();
void tar_quit_proc();
X
#endif
SHAR_EOF
chmod 0644 tar_view.h ||
echo 'restore of tar_view.h failed'
Wc_c="`wc -c < 'tar_view.h'`"
test 548 -eq "$Wc_c" ||
	echo 'tar_view.h: original size 548, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= transfer.h ==============
if test -f 'transfer.h' -a X"$1" != X"-c"; then
	echo 'x - skipping transfer.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting transfer.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'transfer.h' &&
X
#ifdef USE_PROTOTYPES
X
int get_file(char *name, char *localname, size_t size);
int put_file(char *name, char *remote_name, size_t size);
int get_dir(char *parent_remote_dir, char *parent_local_dir, 
X	char *name, char *localname);
int put_dir(char *parent_remote_dir, char *parent_local_dir, 
X	char *name, char *localname);
char *make_path(char *parent, char *curdir);
void init_status(int total);
void end_status(void);
void update_status_label(char *direction, char *name, size_t size);
void update_status_gauge(long bytes);
int sum_local_dir(char *parent, char *dir);
int sum_local_size(void);
int sum_remote_dir(char *parent, char *dir);
int sum_remote_size(void);
int sum_remote_batch_size(void);
int sum_local_batch_size(void);
X
#else
X
int get_file();
int put_file();
int get_dir();
int put_dir();
char *make_path();
void init_status();
void end_status();
void update_status_label();
void update_status_gauge();
int sum_local_dir();
int sum_local_size();
int sum_remote_dir();
int sum_remote_size();
int sum_remote_batch_size();
int sum_local_batch_size();
X
#endif
SHAR_EOF
chmod 0644 transfer.h ||
echo 'restore of transfer.h failed'
Wc_c="`wc -c < 'transfer.h'`"
test 1071 -eq "$Wc_c" ||
	echo 'transfer.h: original size 1071, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= unknown.pr ==============
if test -f 'unknown.pr' -a X"$1" != X"-c"; then
	echo 'x - skipping unknown.pr (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting unknown.pr (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'unknown.pr' &&
/* Format_version=1, Width=16, Height=16, Depth=1, Valid_bits_per_item=16
X */
X	0xFFFF,
X	0x8001,
X	0x8001,
X	0x8381,
X	0x8441,
X	0x8441,
X	0x8041,
X	0x8081,
X	0x8101,
X	0x8101,
X	0x8001,
X	0x8101,
X	0x8001,
X	0x8001,
X	0x8001,
X	0xFFFF
X
SHAR_EOF
chmod 0644 unknown.pr ||
echo 'restore of unknown.pr failed'
Wc_c="`wc -c < 'unknown.pr'`"
test 222 -eq "$Wc_c" ||
	echo 'unknown.pr: original size 222, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= view_file.h ==============
if test -f 'view_file.h' -a X"$1" != X"-c"; then
	echo 'x - skipping view_file.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting view_file.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'view_file.h' &&
#define UNKNOWN     (-1)
#define COMPRESSED  1
#define POSTSCRIPT  2
#define TARFILE     3
X
#ifdef USE_PROTOTYPES
X
int start_viewer(char *filename, int isremote);
void fork_viewer(char *program, char *filename);
int file_type(char *filename);
void uncompress_file(char *filename, char *options);
void compress_file(char *filename, char *options);
void pipe_program(char *argv[]);
int view_local_file(char *name, int which, int *dirchanged);
int view_remote_file(char *name, size_t size);
X
#else
X
int start_viewer();
void fork_viewer();
int file_type();
void uncompress_file();
void compress_file();
void pipe_program();
int view_local_file();
int view_remote_file();
X
#endif
SHAR_EOF
chmod 0644 view_file.h ||
echo 'restore of view_file.h failed'
Wc_c="`wc -c < 'view_file.h'`"
test 675 -eq "$Wc_c" ||
	echo 'view_file.h: original size 675, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
X
The source for ftptool is, as far as I'm concerned freely distributable as 
long as I recieve credit for it (my bosses agree, though Sun hasn't spoken).
X
You should be able to compile and run it on 4.1.X, OW2 or better. You
might want to use xview3, which is available with the OW3 CD or from
export.lcs.mit.edu in /contrib/xview3. For a sun3, you may also need
the unofficial patch /contrib/xview3/Fixes/xview3.0_unofficial_patch
(unless Patch-02 fixed those problems).  Other operating
systems (besides SunOS 5.0) have not been tested by me, though I believe 
it works under Ultrix and 386SVR4.
X
You can either use the supplied Makefile.sun, or use the Imakefile (which
seems to work, but I'm not an Imakefile expert so I'm not sure. I _have_ been
using a Makefile generated from this one though). You should be able to
compile a version for SunOS 5.0 (internal to Sun) by modifying Makefile.sun.
X
Also, make sure config.h is set up appropriately for your system.
X
Author: Mike Sullivan (Mike.Sullivan@Sun.COM)
X
Ported to 386 SVR4 by Jerry Whelan <guru@stasi.bradley.edu>.
X
Ported to Ultrix by Robert Evans <Robert.Evans@cm.cf.ac.uk>.
X
Note, the ftp code was taken from the Berkeley ftp. Primarily, the following
notice applies to ftp.c.
X
/*
X * Copyright (c) 1985, 1989 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
SHAR_EOF
chmod 0644 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 3069 -eq "$Wc_c" ||
	echo 'README: original size 3069, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= batch.c ==============
if test -f 'batch.c' -a X"$1" != X"-c"; then
	echo 'x - skipping batch.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting batch.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'batch.c' &&
#include "ftptool.h"
X
#ifdef USE_PROTOTYPES
struct batchlist *new_batchlist(void)
#else
struct batchlist *new_batchlist()
#endif
{
X	struct batchlist *tmp;
X
X	tmp = (struct batchlist *)malloc(sizeof(struct batchlist));
X	if (tmp == NULL)
X		return NULL;
X	bzero((char *)tmp, sizeof(struct batchlist));
X	tmp->name = NULL;
X	return tmp;
}
X
#ifdef USE_PROTOTYPES
struct batchlist *add_batchname(Panel panel_list, char *name, mode_t mode,
X	size_t size, char *dir)
#else
struct batchlist *add_batchname(panel_list, name, mode, size, dir)
Panel	panel_list;
char	*name;
mode_t	mode;
size_t		size;
char	*dir;
#endif
{
X	struct batchlist *tmp;
X	int	nitems;
X	char	*fullname;
X	Xv_font	entry_font;
X
X	if (!S_ISDIR(mode) && !S_ISREG(mode) && !S_ISLNK(mode))
X		return NULL;
X	if (dir != NULL && *name != '/') {
X		fullname = (char *)malloc((unsigned int)(strlen(dir)+1+strlen(name)+1));
X		if (fullname == NULL)
X			return NULL;
X		strcpy(fullname, dir);
X		if (strcmp(dir, "/"))
X			strcat(fullname, "/");
X		strcat(fullname, name);
X	} else {
X		fullname = strdup(name);
X		if (fullname == NULL)
X			return NULL;
X	}
X
X	/* just add to the end */
X	if (batchentry_exists(panel_list, fullname) != -1) {
X		free(fullname);
X		return NULL;
X	}
X	tmp = new_batchlist();
X	if (tmp == NULL)
X		return NULL;
X	
X	nitems = xv_get(panel_list, PANEL_LIST_NROWS);
X	tmp->name = fullname;
X	tmp->mode = mode;
X	tmp->row = nitems;
X	tmp->size = size;
X
X	if (S_ISDIR(tmp->mode)) {
X		entry_font = bold_list_font;
X		sprintf(scratch, "%s/", tmp->name);
X	} else {
X		entry_font = list_font;
X		strcpy(scratch, tmp->name);
X	}
X
X	xv_set(panel_list, 
X		PANEL_LIST_INSERT, nitems,
X		PANEL_LIST_STRING, nitems, scratch,
X		PANEL_LIST_FONT, nitems, entry_font,
X		PANEL_LIST_CLIENT_DATA, nitems, tmp,
X		PANEL_PAINT, PANEL_NONE,
X		NULL);
X
X	panel_paint(panel_list, PANEL_CLEAR);
X	return tmp;
}
X
#ifdef USE_PROTOTYPES
void free_batchlist(Panel panel_list, int only_selected)
#else
void free_batchlist(panel_list, only_selected)
Panel	panel_list;
int		only_selected;
#endif
{
X	int	nitems, row;
X	struct batchlist *tmp;
X
X    nitems = xv_get(panel_list, PANEL_LIST_NROWS);
X    for (row = nitems - 1; row >= 0; row--) {
X		if (only_selected && 
X			(xv_get(panel_list, PANEL_LIST_SELECTED, row) == FALSE))
X			continue;
X        tmp = (struct batchlist *)xv_get(panel_list, 
X			PANEL_LIST_CLIENT_DATA, row);        
X		if (only_selected)
X			if (panel_list == schedule_window.receive_list)
X				nreceiveitems--;
X			else
X				nsenditems--;
X        free(tmp->name);
X		free((char *)tmp);
X        xv_set(panel_list,
X            PANEL_LIST_DELETE, row,
X            PANEL_PAINT, PANEL_NONE,
X            NULL);
X    }
X	panel_paint(panel_list, PANEL_CLEAR);
}
X
#ifdef USE_PROTOTYPES
int batchentry_exists(Panel panel_list, char *name)
#else
int batchentry_exists(panel_list, name)
Panel	panel_list;
char	*name;
#endif
{
X	int	nitems, row;
X	struct batchlist *tmp;
X
X	nitems = xv_get(panel_list, PANEL_LIST_NROWS);
X	for (row = 0; row < nitems; row++) {
X		tmp = (struct batchlist *)xv_get(panel_list, 
X			PANEL_LIST_CLIENT_DATA, row);
X		if (!strcmp(tmp->name, name))
X			return row;
X	}
X	return -1;
}
X
#ifdef USE_PROTOTYPES
void receive_list_delete_proc(void)
#else
void receive_list_delete_proc()
#endif
{
X	free_batchlist(schedule_window.receive_list, 1);
}
X
#ifdef USE_PROTOTYPES
void send_list_delete_proc(void)
#else
void send_list_delete_proc()
#endif
{
X	free_batchlist(schedule_window.send_list, 1);
}
X
#ifdef USE_PROTOTYPES
void dobatchget(void)
#else
void dobatchget()
#endif
{
X	int 	nitems, row;
X	struct batchlist *tmp;
X	int		rval;
X	int		mode;
X	int		dirchanged=0;
X
X	xfer_buttons_inactive();
X	abort_transfer = 0;
X	if (ping_server())
X		goto out;
X	if (show_status)
X		xv_set(status_window.frame,
X			XV_SHOW, TRUE,
X			NULL);
X	init_status(sum_remote_batch_size());
X	settype((int)xv_get(host_window.advanced.transfer_mode, PANEL_VALUE));
X	/* loop over each element, and do a get, then unselect */
X	nitems = xv_get(schedule_window.receive_list, PANEL_LIST_NROWS);
X	for (row = nitems - 1; row >= 0; row--) {
X		tmp = (struct batchlist *)xv_get(schedule_window.receive_list, 
X			PANEL_LIST_CLIENT_DATA, row);
X		mode = tmp->mode & S_IFMT;
X		if (non_unix) {
X			/* we can't transfer whole dirs on non-unix machines */
X			mode = S_IFREG;
X		}
X		switch(mode) {
X		case S_IFDIR:
X			if (rval = get_dir(remote_dircache.first->name, 
X				local_dircache.first->name, tmp->name, tmp->name + 1)) {
X				/* XXX? - fail or property here */
X				/*
X				if (rval == EEXIST) 
X					footer_message("%s already exists.", tmp->name, (char *)NULL);
X				else
X					goto out;
X				*/
X			}
X			dirchanged++;
X			break;
X		case S_IFREG:
X			if (rval = make_dirs(tmp->name + 1, 0)) {
X			/* XXX? - fail or property here */
X			/*
X				goto out;
X			*/
X			}
X			if (get_file(tmp->name, tmp->name + 1, tmp->size))
X				goto out;
X			dirchanged++;
X			break;
X		case S_IFLNK:
X			if (rval = make_dirs(tmp->name + 1, 0)) {
X			/* XXX? - fail or property here */
X			/*
X				goto out;
X			*/
X			}
X			rval = get_file(tmp->name, tmp->name + 1, tmp->size);
X			if (rval == EPERM) {
X				if (rval = get_dir(remote_dircache.first->name, 
X					local_dircache.first->name, tmp->name, tmp->name + 1)) {
X				/* XXX? - fail or property here */
X				/*
X					if (rval == EEXIST) 
X						footer_message("%s already exists.", tmp->name, (char *)NULL);
X					else
X						goto out;
X				*/
X				}
X			} else if (rval != 0) {
X				goto out;
X			}
X			dirchanged++;
X			break;
X		default:
X			footer_message("Ignoring non-file/directory %s.", 
X				tmp->name, (char *)NULL);
X			log_message("Can only transfer files.\n");
X			break;
X		}
X		free(tmp->name);
X		free((char *)tmp);
X        xv_set(schedule_window.receive_list,
X            PANEL_LIST_DELETE, row,
X            PANEL_PAINT, PANEL_NONE,
X            NULL);
X		panel_paint(schedule_window.receive_list, PANEL_CLEAR);
X	}
X
out:
X	if (dirchanged)
X		change_local_dir(".", 1);
X	if (show_status)
X		xv_set(status_window.frame,
X			XV_SHOW, FALSE,
X			NULL);
X	update_status_label("Not", "transferring", (size_t)0);
X	end_status();
X	xfer_buttons_active();
X	if (timedout)
X		timeout_disconnect();
X	return;
}
X
#ifdef USE_PROTOTYPES
void dobatchput(void)
#else
void dobatchput()
#endif
{
X	int 	nitems, row;
X	struct batchlist *tmp;
X	int		rval = 0;
X	int		mode;
X	int		dirchanged=0;
X
X	xfer_buttons_inactive();
X	abort_transfer = 0;
X	if (ping_server())
X		goto out;
X	if (show_status)
X		xv_set(status_window.frame,
X			XV_SHOW, TRUE,
X			NULL);
X	init_status(sum_local_batch_size());
X	settype((int)xv_get(host_window.advanced.transfer_mode, PANEL_VALUE));
X
X	/* loop over each element, and do a get, then unselect */
X	nitems = xv_get(schedule_window.send_list, PANEL_LIST_NROWS);
X	for (row = nitems-1; row >= 0; row--) {
X		tmp = (struct batchlist *)xv_get(schedule_window.send_list, 
X			PANEL_LIST_CLIENT_DATA, row);
X		mode = tmp->mode & S_IFMT;
X		if (non_unix) {
X			/* we can't transfer whole dirs on non-unix machines */
X			mode = S_IFREG;
X		}
X		switch(mode) {
X		case S_IFDIR:
X			dirchanged++;
X			if (rval = put_dir(remote_dircache.first->name, 
X				local_dircache.first->name, tmp->name + 1, tmp->name)) {
X				/* XXX? - fail or property here */
X				/*
X				goto out;
X				*/
X			}
X			break;
X		case S_IFREG:
X			if (rval = make_remote_dirs(tmp->name + 1, 0)) {
X			/* XXX? - fail or property here */
X			/*
X				goto out;
X			*/
X			}
X			dirchanged++;
X			if (rval = put_file(tmp->name, tmp->name+1, tmp->size))
X				goto out;
X			break;
X		case S_IFLNK:
X			if (rval = make_remote_dirs(tmp->name + 1, 0)) {
X			/* XXX? - fail or property here */
X			/*
X				goto out;
X			*/
X			}
X			dirchanged++;
X			rval = put_file(tmp->name, tmp->name+1, tmp->size);
X			if (rval == EPERM) {
X				if (rval = put_dir(remote_dircache.first->name, 
X					local_dircache.first->name, tmp->name + 1, tmp->name)) {
X					/* XXX? - fail or property here */
X					/*
X					goto out;
X					*/
X				}
X			} else if (rval != 0) {
X				goto out;
X			}
X			break;
X		default:
X			local_footer_message("Ignoring non-file/directory %s.", 
X				tmp->name, (char *)NULL);
X			log_message("Can only transfer files.\n");
X			break;
X		}
X		free(tmp->name);
X		free((char *)tmp);
X		xv_set(schedule_window.send_list,
X			PANEL_LIST_DELETE, row,
X			PANEL_PAINT, PANEL_NONE,
X			NULL);
X		panel_paint(schedule_window.send_list, PANEL_CLEAR);
X	}
X
X
out:
X	if (dirchanged)
X		change_remote_dir(".", 1);
X	if (show_status)
X		xv_set(status_window.frame,
X			XV_SHOW, FALSE,
X			NULL);
X	update_status_label("Not", "transferring", (size_t)0);
X	end_status();
X	xfer_buttons_active();
X	if (rval == ENOSPC) {
X		disconnect();
X	}
X	if (timedout)
X		timeout_disconnect();
X	return;
}
X
#ifdef USE_PROTOTYPES
int save_batch_list(Panel list, char *filename)
#else
int save_batch_list(list, filename)
Panel	list;
char	*filename;
#endif
{
X	FILE	*fp;
X	int	isdir;
X	extern char *sys_errlist[];
X	int		nitems, row;
X	struct batchlist *tmp;
X	
X	if ((fp = fopen(filename, "w")) == NULL) {
X		footer_message("%s:%s", filename, sys_errlist[errno], (char *)NULL);
X		return 1;
X	}
X	/* save */
X	fprintf(fp, "#name:isdir:size\n");
X	nitems = xv_get(list, PANEL_LIST_NROWS);
X	for (row = 0; row < nitems; row++) {
X		tmp = (struct batchlist *)xv_get(list, 
X			PANEL_LIST_CLIENT_DATA, row);
X		isdir = 0;
X		if (S_ISDIR(tmp->mode))
X			isdir = 1;
X		fprintf(fp, "%s:%d:%d\n", tmp->name, isdir, tmp->size);
X	}
X	fclose(fp);
X	return 0;
}
X
#ifdef USE_PROTOTYPES
int load_batch_list(Panel list, char *filename)
#else
int load_batch_list(list, filename)
Panel	list;
char	*filename;
#endif
{
X	char	fname[MAXPATHLEN+1];
X	int	isdir;
X	size_t		size;
X	mode_t		mode;
X	int	ch;
X	FILE	*fp;
X	extern char *sys_errlist[];
X	
X	if ((fp = fopen(filename, "r")) == NULL) {
X		footer_message("%s:%s", filename, sys_errlist[errno], (char *)NULL);
X		return 1;
X	}
X	if (list == schedule_window.receive_list)
X		nreceiveitems = 0;
X	else
X		nsenditems = 0;
X	free_batchlist(list, 0);
X
X	/* load */
X	/*
X	 Alias
X	 host
X	 login
X	 encrypted password
X	 */
X
X	for (;;) {
X		ch = getc(fp);
X		if (ch == EOF)
X			break;
X		if (ch == '#') {
X			while (((ch = getc(fp)) != '\n') && (ch != EOF))
X				/* null */ ;
X			continue;
X		} else
X			ungetc(ch, fp);
X		if (fscanf(fp,"%[^:]:%d:%d\n", fname, &isdir, &size) != 3) 
X			break;
X		mode = S_IFREG;
X		if (isdir)
X			mode = S_IFDIR;
X		if (add_batchname(list, fname, mode, size, (char *)NULL) == NULL)
X			return 1;
X	}
X	return 0;
}
SHAR_EOF
chmod 0644 batch.c ||
echo 'restore of batch.c failed'
Wc_c="`wc -c < 'batch.c'`"
test 10213 -eq "$Wc_c" ||
	echo 'batch.c: original size 10213, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= button_funcs.h ==============
if test -f 'button_funcs.h' -a X"$1" != X"-c"; then
	echo 'x - skipping button_funcs.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting button_funcs.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'button_funcs.h' &&
#ifdef USE_PROTOTYPES
X
void	connect_proc(void);
void	local_properties(void);
void	remote_properties(void);
void	props_proc(void);
void	get_proc(void);
void	batchget_proc(void);
void	uncompress_proc(void);
void	compress_proc(void);
void	tar_proc(void);
void	create_tar_proc(void);
void	extract_proc(void);
void	put_proc(void);
void	batchput_proc(void);
void	remote_view(void);
void	local_view(void);
void	local_dir_view(void);
void	session_view(void);
void	status_view(void);
void	host_view(void);
void	schedule_view(void);
void	abort_proc(void);
int local_list_proc(Panel_item item, char *string, Xv_opaque client_data,
X	Panel_list_op op, Event *event);
int remote_list_proc(Panel_item item, char *string, Xv_opaque client_data,
X	Panel_list_op op, Event *event);
int send_list_proc(Panel_item item, char *string, Xv_opaque client_data,
X	Panel_list_op op,Event *event);
int receive_list_proc(Panel_item item, char *string, Xv_opaque client_data,
X	Panel_list_op op, Event *event);
void apply_changes(void);
void ftptool_props_apply_proc(void);
void directory_lists_props_apply_proc(void);
void viewers_props_apply_proc(void);
void ftptool_props_reset_proc(void);
void directory_lists_props_reset_proc(void);
void viewers_props_reset_proc(void);
void about_proc(void);
void	remote_sort_choice_proc(void);
void set_remote_sort_order(int val);
void	local_sort_choice_proc(void);
void set_local_sort_order(int val);
void	about_send_proc(void);
void	feedback_address_proc(Panel_item item, unsigned int value, 
X	Event *event);
void	feedback_send_proc(Panel_item item, Event *event);
void	feedback_cancel_proc(void);
Panel_setting	reject_spaces(Panel_item item, Event *event);
void	host_window_choice_proc(Panel_item item, unsigned int value, 
X	Event *event);
void	remote_delete_proc(void);
void	local_delete_proc(void);
void	show_load_receive_list_proc(void);
void	show_save_receive_list_proc(void);
void	show_load_send_list_proc(void);
void	show_save_send_list_proc(void);
void	load_send_list_proc(void);
void	save_send_list_proc(void);
void	load_receive_list_proc(void);
void	save_receive_list_proc(void);
void add_batch_send_proc(void);
void add_batch_receive_proc(void);
void	props_inf_check_box(Panel_item item, Event *event);
void	quit_proc(void);
void switch_category(int value, int show);
void category_proc(void);
void	dismiss_local_window(void);
void	dismiss_host_window(void);
void	dismiss_about_window(void);
void	dismiss_file_props_window(Panel_item item, Event *event);
void	dismiss_schedule_window(void);
void	dismiss_status_window(void);
void dir_list_proc(void);
void ls_list_proc(void);
void list_remote_dir(void);
void save_layout_func(void);
void local_doubleclick(struct dirlist *tmp);
void remote_doubleclick(void);
void plus_proc(void);
void minus_proc(void);
X
#else
X
void	connect_proc();
void	local_properties();
void	remote_properties();
void	props_proc();
void	get_proc();
void	batchget_proc();
void	uncompress_proc();
void	compress_proc();
void	tar_proc();
void	create_tar_proc();
void	extract_proc();
void	put_proc();
void	batchput_proc();
void	remote_view();
void	local_view();
void	local_dir_view();
void	session_view();
void	status_view();
void	host_view();
void	schedule_view();
void	abort_proc();
int local_list_proc();
int remote_list_proc();
int send_list_proc();
int receive_list_proc();
void apply_changes();
void ftptool_props_apply_proc();
void directory_lists_props_apply_proc();
void viewers_props_apply_proc();
void ftptool_props_reset_proc();
void directory_lists_props_reset_proc();
void viewers_props_reset_proc();
void about_proc();
void	remote_sort_choice_proc();
void set_remote_sort_order();
void	local_sort_choice_proc();
void set_local_sort_order();
void	about_send_proc();
void	feedback_address_proc();
void	feedback_send_proc();
void	feedback_cancel_proc();
Panel_setting	reject_spaces();
void	host_window_choice_proc();
void	remote_delete_proc();
void	local_delete_proc();
void	show_load_receive_list_proc();
void	show_save_receive_list_proc();
void	show_load_send_list_proc();
void	show_save_send_list_proc();
void	load_send_list_proc();
void	save_send_list_proc();
void	load_receive_list_proc();
void	save_receive_list_proc();
void add_batch_send_proc();
void add_batch_receive_proc();
void	props_inf_check_box();
void	quit_proc();
void switch_category();
void category_proc();
void	dismiss_local_window();
void	dismiss_host_window();
void	dismiss_about_window();
void	dismiss_file_props_window();
void	dismiss_schedule_window();
void	dismiss_status_window();
void dir_list_proc();
void ls_list_proc();
void list_remote_dir();
void save_layout_func();
void local_doubleclick();
void remote_doubleclick();
void plus_proc();
void minus_proc();
X
#endif
SHAR_EOF
chmod 0644 button_funcs.h ||
echo 'restore of button_funcs.h failed'
Wc_c="`wc -c < 'button_funcs.h'`"
test 4698 -eq "$Wc_c" ||
	echo 'button_funcs.h: original size 4698, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= dircache.c ==============
if test -f 'dircache.c' -a X"$1" != X"-c"; then
	echo 'x - skipping dircache.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting dircache.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'dircache.c' &&
#include "ftptool.h"
X
#ifdef USE_PROTOTYPES
int dircache_add(struct dircache *dcache, char *name, struct dirlist *dlist)
#else
int dircache_add(dcache, name, dlist)
struct dircache *dcache;
char	*name;
struct dirlist *dlist;
#endif
{
X	struct dirlist_header *new_header;
X	struct dirlist_header *last;
X
X	if (dircache_size != 0 && dircache_size == dcache->ndirs) {
X		last = dcache->last;
X		if (dcache->ndirs == 1) {
X			dcache->first = NULL;
X			dcache->last = NULL;
X		} else {
X			dcache->last = dcache->last->prev;
X			dcache->last->next = NULL;
X		}
X		free_dirlist_header(last);
X		dcache->ndirs--;
X	}
X	new_header = new_dirlist_header(name, dlist);
X	if (new_header == NULL)
X		return ENOMEM;
X	if (dcache->ndirs == 0) {
X		dcache->first = new_header;
X		dcache->last = new_header;
X		new_header->next = NULL;
X		new_header->prev = NULL;
X	} else {
X		new_header->prev = NULL;
X		new_header->next = dcache->first;
X		dcache->first->prev = new_header;
X		dcache->first = new_header;
X	}
X
X	dcache->ndirs++;
X
X	return 0;
}
X
#ifdef USE_PROTOTYPES
void dircache_delete(struct dircache *dcache, char *name)
#else
void dircache_delete(dcache, name)
struct dircache *dcache;
char	*name;
#endif
{
X	struct dirlist_header *first;
X
X	if (cache_lookup(dcache, name) == NULL)
X		return;
X	/* now at top of list */
X	first = dcache->first;
X	if (dcache->ndirs == 1) {
X		dcache->first = NULL;
X		dcache->last = NULL;
X	} else {
X		dcache->first = first->next;
X		dcache->first->prev = NULL;
X	}
X	free_dirlist_header(first);
X
X	dcache->ndirs--;
X
X	return;
}
X
#ifdef USE_PROTOTYPES
void dircache_shrink(struct dircache *dcache, int newsize)
#else
void dircache_shrink(dcache, newsize)
struct dircache *dcache;
int	newsize;
#endif
{
X	struct dirlist_header *last;
X
X	if (newsize == 0) 
X		return;
X	while (dcache->ndirs > newsize) {
X		last = dcache->last;
X		dcache->last = dcache->last->prev;
X		dcache->last->next = NULL;
X		free_dirlist_header(last);
X		dcache->ndirs--;
X	} 
}
X
#ifdef USE_PROTOTYPES
void free_dircache(struct dircache *dcache)
#else
void free_dircache(dcache)
struct dircache *dcache;
#endif
{
X	struct dirlist_header *next;
X	struct dirlist_header *tmp;
X
X	for (tmp = dcache->first; tmp != NULL;) {
X		next = tmp->next;
X		free_dirlist_header(tmp);
X		tmp = next;
X	}
X	dcache->ndirs = 0;
X	dcache->first = NULL;
X	dcache->last = NULL;
}
X
#ifdef USE_PROTOTYPES
struct dirlist *cache_lookup(struct dircache *dcache, char *dirname)
#else
struct dirlist *cache_lookup(dcache, dirname)
struct dircache *dcache;
char	*dirname;
#endif
{
X	struct dirlist_header *tmp;
X
X	for (tmp = dcache->first; tmp != NULL; tmp=tmp->next) 
X		if (!strcmp(tmp->name, dirname)) {
X			/* match! move to top of cache */
X			if (tmp == dcache->first) {
X				/* nothing to do */
X				return tmp->dlist;
X			} else if (tmp == dcache->last) {
X				/* at least 2 */
X				/* off list */
X				dcache->last = dcache->last->prev;
X				dcache->last->next = NULL;
X			} else {
X				/* in the middle */
X				/* off list */
X				tmp->prev->next = tmp->next;
X				tmp->next->prev = tmp->prev;
X			}
X			/* now add to front */
X			tmp->next = dcache->first;
X			tmp->prev = NULL;
X			dcache->first->prev = tmp;
X			dcache->first = tmp;
X			
X			return tmp->dlist;
X		}
X	/* no match */
X	return NULL;
}
X
#ifdef USE_PROTOTYPES
struct dirlist_header *new_dirlist_header(char *name, struct dirlist *dlist)
#else
struct dirlist_header *new_dirlist_header(name, dlist)
char	*name;
struct dirlist *dlist;
#endif
{
X	struct dirlist_header *tmp;
X
X	tmp = (struct dirlist_header *)malloc(sizeof(struct dirlist_header));
X	if (tmp == NULL)
X		return NULL;
X	bzero((char *)tmp, sizeof(struct dirlist_header));
X	tmp->name = strdup(name);
X	if (tmp->name == NULL) {
X		free((char *)tmp);
X		return NULL;
X	}
X	tmp->next = NULL;
X	tmp->prev = NULL;
X	tmp->dlist = dlist;
X	return tmp;
}
X
#ifdef USE_PROTOTYPES
void free_dirlist_header(struct dirlist_header *head)
#else
void free_dirlist_header(head)
struct dirlist_header *head;
#endif
{
X	free_dirlist(head->dlist);
X	free(head->name);
X	free((char *)head);
}
X
#ifdef notdef
X
#ifdef USE_PROTOTYPES
void show_dircache(struct dircache *dcache)
#else
void show_dircache(dcache)
struct dircache *dcache;
#endif
{
X	struct dirlist_header *tmp;
X
X	printf("cache contains\n");
X	printf("--------------\n");
X	for (tmp = dcache->first; tmp != NULL; tmp=tmp->next) {
X		printf("%s\n", tmp->name);
X	}
X	printf("--------------\n");
}
X
#endif
SHAR_EOF
chmod 0644 dircache.c ||
echo 'restore of dircache.c failed'
Wc_c="`wc -c < 'dircache.c'`"
test 4331 -eq "$Wc_c" ||
	echo 'dircache.c: original size 4331, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ftp_var.h ==============
if test -f 'ftp_var.h' -a X"$1" != X"-c"; then
	echo 'x - skipping ftp_var.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ftp_var.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ftp_var.h' &&
/*
X * Copyright (c) 1985, 1989 Regents of the University of California.
X * All rights reserved.
X *
X * Redistribution and use in source and binary forms, with or without
X * modification, are permitted provided that the following conditions
X * are met:
X * 1. Redistributions of source code must retain the above copyright
X *    notice, this list of conditions and the following disclaimer.
X * 2. Redistributions in binary form must reproduce the above copyright
X *    notice, this list of conditions and the following disclaimer in the
X *    documentation and/or other materials provided with the distribution.
X * 3. All advertising materials mentioning features or use of this software
X *    must display the following acknowledgement:
X *	This product includes software developed by the University of
X *	California, Berkeley and its contributors.
X * 4. Neither the name of the University nor the names of its contributors
X *    may be used to endorse or promote products derived from this software
X *    without specific prior written permission.
X *
X * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
X * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
X * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
X * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
X * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
X * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
X * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
X * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
X * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
X * SUCH DAMAGE.
X */
X
#define strerror(e) sys_errlist[e]
extern char *sys_errlist[];
X
#ifdef USE_PROTOTYPES
X
int ftp_hookup(char *host, int port);
int ftp_login(char *user, char *pass);
int command(char *fmt, ...);
int command_dataconn(FILE **a_file, char *lmode, char *fmt, ...);
int getreply(int expecteof);
int empty(fd_set *mask, int sec);
int sendrequest(char *cmd, char *local, char *remote, size_t size);
int recvrequest(char *cmd, char *local, char *remote, 
X	char *lmode, size_t size);
int initconn(void);
FILE *dataconn(char *lmode);
char *gunique(char *local);
void abort_remote(FILE *din);
void lostpeer(void);
FILE *open_remote_ls(int nlst);
char *next_remote_line(FILE *din);
void close_remote_ls(FILE *din);
void settype(int type);
X
#else
X
int ftp_hookup();
int ftp_login();
int command();
int command_dataconn();
int getreply();
int empty();
int sendrequest();
int recvrequest();
int initconn();
FILE *dataconn();
char *gunique();
void abort_remote();
void lostpeer();
FILE *open_remote_ls();
char *next_remote_line();
void close_remote_ls();
void settype();
X
#endif
SHAR_EOF
chmod 0644 ftp_var.h ||
echo 'restore of ftp_var.h failed'
Wc_c="`wc -c < 'ftp_var.h'`"
test 2888 -eq "$Wc_c" ||
	echo 'ftp_var.h: original size 2888, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ftptool.h ==============
if test -f 'ftptool.h' -a X"$1" != X"-c"; then
	echo 'x - skipping ftptool.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ftptool.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ftptool.h' &&
/*
X Ftptool - written by Mike Sullivan
X
X The more I add, the nastier it gets. I used to _like_ this code,
X and I usually _hate_ using globals.
X */
X
#include <stdio.h>
#include <errno.h>
#include <math.h>
X
#include <X11/Xos.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xresource.h>
X
#ifndef LINT
#include <unistd.h>
#endif
X
#include <sys/param.h>
#include <sys/stat.h>
X
#if defined(SYSV) || defined(SYSV386)
#include <sys/statvfs.h>
#else
#	ifdef ultrix
#	include <sys/mount.h>
#	include <nfs/nfs_clnt.h>
#	include <nfs/vfs.h>
#	else
#	include <sys/vfs.h>
#	endif
#endif
X
#include <termios.h>
#include <signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <arpa/ftp.h>
#include <arpa/telnet.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <malloc.h>
#include <dirent.h>
#include <xview/xview.h>
#include <xview/panel.h>
#include <xview/notice.h>
#include <xview/textsw.h>
#include <xview/font.h>
#include <xview/canvas.h>
#include <xview/xv_xrect.h>
#include <xview/cursor.h>
#include <xview/defaults.h>
#include <pwd.h>
#include <grp.h>
#include <setjmp.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
X
#if !defined(XVIEW2) && !defined(XVIEW3)
#	ifdef FRAME_CMD_PIN_STATE
#	define XVIEW3
#	else
#	define XVIEW2
#	endif
#endif
X
#if defined(XVIEW2)
#undef XVIEW3
#endif
X
#if defined(XVIEW3)
#undef XVIEW2
#endif
X
#ifndef USE_PROTOTYPES
extern time_t time();
#endif
X
#include "config.h"
X
#ifdef USE_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif
X
struct file_property_window; /* for prototypes */
X
#include "batch_struct.h"
#include "dircache_struct.h"
#include "dirlist_struct.h"
#include "host_list_struct.h"
#include "schedule_struct.h"
X
#include "batch.h"
#include "button_funcs.h"
#include "change_dir.h"
#include "create_main.h"
#include "create_other.h"
#include "dircache.h"
#include "dirlist.h"
#include "dofuncs.h"
#include "event.h"
#include "ftp_var.h"
#include "host_list.h"
#include "main.h"
#include "menu_funcs.h"
#include "misc.h"
#include "patchlevel.h"
#include "readdir.h"
#include "schedule.h"
#include "tar_view.h"
#include "transfer.h"
#include "view_file.h"
X
extern char *getwd();
X
#ifndef EXTERN
#define EXTERN extern
#endif
X
/*
X * Global object definitions.
X */
X
EXTERN Icon	frame_icon;
EXTERN Display *dpy;
EXTERN int	display_width;
EXTERN int	display_height;
X
#define MAXGEOMETRYSIZE 20
X
EXTERN struct dircache local_dircache;
EXTERN struct dircache remote_dircache;
EXTERN int dircache_size;
EXTERN char *which_remote_file;
EXTERN mode_t which_remote_mode;
EXTERN size_t which_remote_size;
X
EXTERN struct schedule schedule_list;
X
struct base_window {
X	Frame	frame;
X	Panel	panel;
X	Panel_item file;
X	Panel_item view;
X	Panel_item props;
X	Panel_item connect;
X	Panel_item abort;
X	Panel_item quit;	/* for non-OPEN LOOK window managers */
X	Panel_item directory;
X	Panel_item list;
X	char	geometry[MAXGEOMETRYSIZE];
};
X
EXTERN struct base_window base_window;
X
struct host_window {
X	Frame	frame;
X	Panel	panel;
X	Panel_item	new;
X	Panel_item	anonymous;
X	Panel_item	hosts;
X	Panel_item	host_list_ops;
X	struct {
X		Panel	panel;
X		Panel_item	host;
X		Panel_item	login;
X		Panel_item	password;
X		Panel_item	dismiss;	/* for non-OPEN LOOK window managers */
X		Panel_item  connect;
X		Panel_item	plus;
X	} basic;
X	struct {
X		Panel	panel;
X		Panel_item	alias;
X		Panel_item	last_visited;
X		Panel_item	comment;
X		Panel_item	proxy;
X		Panel_item	transfer_mode;
X		Panel_item	remote_auto_cd;
X		Panel_item	local_auto_cd;
X		Panel_item	dir_parse;
X		Panel_item	minus;
X		int		visible;
X	} advanced;
X	int		visible;
X	char	geometry[MAXGEOMETRYSIZE];
};
X
EXTERN struct host_window host_window;
X
struct local_window {
X	Frame	frame;
X	Panel	panel;
X	Panel_item	directory;
X	Panel_item	space;
X	Panel_item	list;
X	Panel_item	dismiss;	/* for non-OPEN LOOK window managers */
X	int		visible;
X	char	geometry[MAXGEOMETRYSIZE];
};
X
EXTERN struct local_window local_window;
X
struct status_window {
X	Frame	frame;
X	Panel	panel;
X	Panel_item message;
X	Panel_item size;
#ifdef notdef
X	Panel_item file_gauge;
#endif
X	Panel_item total_gauge;
X	Panel_item dismiss;	/* for non-OPEN LOOK window managers */
X	int		visible;
X	char	geometry[MAXGEOMETRYSIZE];
};
X
EXTERN struct status_window status_window;
X
struct session_window {
X	Frame	frame;
X	Panel	panel;
X	Textsw	log;
X	char	geometry[MAXGEOMETRYSIZE];
};
X
EXTERN struct session_window session_window;
X
struct tool_property_window {
X	Frame	frame;
X	Panel	panel;
X	Textsw	log;
X	Panel_item category;
X	struct {
X		Panel panel;
X		Panel_item options;
X		Panel_item unique;
X		Panel_item automatic;
X		Panel_item openlook;
X		Panel_item anonftp;
X		Panel_item confirm;
X		Panel_item ignore_case;
X		Panel_item apply;
X	} ftptool;
X	struct {
X		Panel panel;
X		Panel_item cache;
X		Panel_item cache_inf;
X		Panel_item remote_sort;
X		Panel_item remote_sortdir;
X		Panel_item remote_dotfiles;
X		Panel_item remote_group;
X		Panel_item local_sort;
X		Panel_item local_sortdir;
X		Panel_item local_group;
X		Panel_item local_dotfiles;
X		Panel_item apply;
X	} directory_lists;
X	struct {
X		Panel panel;
X		Panel_item viewer;
X		Panel_item archive;
X		Panel_item postscript;
X		Panel_item apply;
X	} viewers;
X	Panel_button_item apply;
};
X
EXTERN struct tool_property_window tool_property_window;
X
struct file_property_window	{
X	Frame	frame;
X	Panel	panel;
X	Panel_item filename;
X	Panel_item owner;
X	Panel_item group;
X	Panel_item modtime;
X	Panel_item size;
X	Panel_item type;
X	Panel_item perms_message;
SHAR_EOF
true || echo 'restore of ftptool.h failed'
fi
echo 'End of  part 2'
echo 'File ftptool.h is continued in part 3'
echo 3 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
