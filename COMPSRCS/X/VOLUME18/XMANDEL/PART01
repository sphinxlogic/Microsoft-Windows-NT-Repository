Newsgroups: comp.sources.x
Path: uunet!darwin.sura.net!mips!msi!dcmartin
From: tony@ajfcal.cuc.ab.ca (Tony Field)
Subject: v18i015: Xmandelbrot, Part01/03
Message-ID: <csx-18i015-xmandel@uunet.UU.NET>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Date: Mon, 13 Jul 1992 15:46:10 GMT
Approved: dcmartin@msi.com
Lines: 1717

Submitted-by: tony@ajfcal.cuc.ab.ca (Tony Field)
Posting-number: Volume 18, Issue 15
Archive-name: xmandel/part01

This is a revised version of the old xmandel programme.  Enhancements include:

	1. Athena or Motif widgets for the GUI
	2. gif output files
	3. support for 1, 2, 4, or 8 bit displays
	4. zooming on both the Mandelbrot or Julia sets
	5. honouring of exposure events.

This version of xmandel works with the following systems:
	SysV-386 Interactive Unix, X11R4  (Athena and Motif)
	Sun Sparc (Athena tested only) 
	HP9000s720 (Athena and Motif)
	
#!/bin/sh
# This is a shell archive (produced by shar 3.50)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 07/13/1992 15:40 UTC by dcmartin@fascet
# Source directory /home/fascet/dcmartin/csx/src/tmp
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   1130 -rw-r--r-- Imakefile
#    548 -rw-r--r-- MANIFEST
#  11508 -rw-r--r-- Makefile.std
#   2547 -rw-r--r-- README
#   9512 -rw-r--r-- julia.c
#    276 -rw-r--r-- main.c
#  27742 -rw-r--r-- mainaw.c
#  30806 -rw-r--r-- mainmotif.c
#   7543 -rw-r--r-- mandel.bit
#  15435 -rw-r--r-- mandel.c
#   4079 -rw-r--r-- mandel.h
#  17660 -rw-r--r-- writegif.c
#   8293 -rw-r--r-- xmandel.man
#    929 -rw-r--r-- xmandel.mot.ad
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= Imakefile ==============
if test -f 'Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Imakefile' &&
#  xmandel - Mandelbrot set and Julia generator
# 
# CC=gcc
X
# If you want ATHENA widgets, uncomment the following line
MYLIBS = $(XAWLIB)
X
# If you want MOTIF rather than Athena widgets uncomment 2 lines
# MOTIF = -DMOTIF
# MYLIBS = $(MRMLIB) $(XMLIB)
X
# If your version of Motif needs X11/VaSimple.h
# Interactive Unix X11R4 does with cc, not with gcc
# VASIMPLE = -DVASIMPLE
X
# If you have bcopy() but not memcpy
# BCOPY=-DHAVEBCOPY
X
# If you don't have bcopy() or memcpy()
# MEMCPY=-DNEEDMEMCPY
X
# --- end config ---
X
LOCAL_LIBRARIES = $(MYLIBS) $(XTOOLLIB) $(XMULIB) $(XLIB) 
DEFINES = $(MOTIF) $(BCOPY) $(MEMCPY) $(VASIMPLE)
SRCS = main.c mandel.c julia.c writegif.c
OBJS = main.o mandel.o julia.o writegif.o
X
ComplexProgramTarget(xmandel)
X
main.o:	mainaw.c mainmotif.c
X
tar:
X	tar cvf mandel.tar README Imakefile Makefile Makefile.unix main.c mainaw.c mainmotif.c mandel.h mandel.c julia.c writegif.c xmandel.man xmandel.mot.ad mandel.bit
X
shar:
X	makekit -m  README Imakefile Makefile.unix main.c mainaw.c mainmotif.c mandel.h mandel.c julia.c writegif.c xmandel.man xmandel.mot.ad mandel.bit
X
InstallAppDefaults(XMandel)
X
X
SHAR_EOF
chmod 0644 Imakefile ||
echo 'restore of Imakefile failed'
Wc_c="`wc -c < 'Imakefile'`"
test 1130 -eq "$Wc_c" ||
	echo 'Imakefile: original size 1130, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= MANIFEST ==============
if test -f 'MANIFEST' -a X"$1" != X"-c"; then
	echo 'x - skipping MANIFEST (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting MANIFEST (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'MANIFEST' &&
X   File Name		Archive #	Description
-----------------------------------------------------------
X Imakefile                  1	
X MANIFEST                   1	This shipping list
X Makefile.unix              1	
X README                     1	
X julia.c                    1	
X main.c                     1	
X mainaw.c                   3	
X mainmotif.c                4	
X mandel.bit                 1	
X mandel.c                   2	
X mandel.h                   1	
X writegif.c                 2	
X xmandel.man                1	
X xmandel.mot.ad             1	
SHAR_EOF
chmod 0644 MANIFEST ||
echo 'restore of MANIFEST failed'
Wc_c="`wc -c < 'MANIFEST'`"
test 548 -eq "$Wc_c" ||
	echo 'MANIFEST: original size 548, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile.std ==============
if test -f 'Makefile.std' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile.std (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile.std (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile.std' &&
# Makefile generated by imake - do not edit!
# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
#
# The cpp used on this machine replaces all newlines and multiple tabs and
# spaces in a macro expansion with a single space.  Imake tries to compensate
# for this, but is not always successful.
#
X
# -------------------------------------------------------------------------
# Makefile generated from "Imake.tmpl" and </tmp/IIf.a03033>
# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
#
# Platform-specific parameters may be set in the appropriate <vendor>.cf
# configuration files.  Site-specific parameters should be set in the file
# site.def.  Full rebuilds are recommended if any parameters are changed.
#
# If your C preprocessor does not define any unique symbols, you will need
# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
# "make World" the first time).
#
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that need to come before
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
# -------------------------------------------------------------------------
# platform-specific configuration parameters - edit sun.cf to change
X
# platform:  $XConsortium: sun.cf,v 1.68 91/07/30 11:34:39 rws Exp $
X
# operating system:  SunOS 4.1.1
X
# $XConsortium: sunLib.rules,v 1.6 91/03/24 17:55:58 rws Exp $
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that go after
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X      PROJECTROOT = /usr/X11/R5
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
# -------------------------------------------------------------------------
# X Window System Build Parameters
# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
# -------------------------------------------------------------------------
# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/X11/R5/lib
X           BINDIR = /usr/X11/R5/bin
X          INCROOT = /usr/X11/R5/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/X11/R5/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
# $XConsortium: sunLib.tmpl,v 1.11 91/07/31 11:32:08 rws Exp $
X
SHLIBLDFLAGS = -assert pure-text
PICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
# -------------------------------------------------------------------------
# Imake rules for building libraries, programs, scripts, and data files
# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
# -------------------------------------------------------------------------
# start of Imakefile
X
#  xmandel - Mandelbrot set and Julia generator
#
# CC=gcc
X
# If you want ATHENA widgets, uncomment the following line
MYLIBS = $(XAWLIB)
X
# If you want MOTIF rather than Athena widgets uncomment 2 lines
# MOTIF = -DMOTIF
# MYLIBS = $(MRMLIB) $(XMLIB)
X
# If your version of Motif needs X11/VaSimple.h
# Interactive Unix X11R4 does with cc, not with gcc
# VASIMPLE = -DVASIMPLE
X
# If you have bcopy() but not memcpy
# BCOPY=-DHAVEBCOPY
X
# If you don't have bcopy() or memcpy()
# MEMCPY=-DNEEDMEMCPY
X
# --- end config ---
X
LOCAL_LIBRARIES = $(MYLIBS) $(XTOOLLIB) $(XMULIB) $(XLIB)
DEFINES = $(MOTIF) $(BCOPY) $(MEMCPY) $(VASIMPLE)
SRCS = main.c mandel.c julia.c writegif.c
OBJS = main.o mandel.o julia.o writegif.o
X
X PROGRAM = xmandel
X
all:: xmandel
X
xmandel: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
saber_xmandel:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
osaber_xmandel:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
install:: xmandel
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  xmandel $(DESTDIR)$(BINDIR)
X
install.man:: xmandel.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) xmandel.man $(DESTDIR)$(MANDIR)/xmandel.$(MANSUFFIX)
X
depend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
lint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
lint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
clean::
X	$(RM) $(PROGRAM)
X
main.o:	mainaw.c mainmotif.c
X
tar:
X	tar cvf mandel.tar README Imakefile Makefile Makefile.unix main.c mainaw.c mainmotif.c mandel.h mandel.c julia.c writegif.c xmandel.man xmandel.mot.ad mandel.bit
X
shar:
X	makekit -m  README Imakefile Makefile.unix main.c mainaw.c mainmotif.c mandel.h mandel.c julia.c writegif.c xmandel.man xmandel.mot.ad mandel.bit
X
install:: XMandel.ad
X	@if [ -d $(DESTDIR)$(XAPPLOADDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XAPPLOADDIR)); fi
X	$(INSTALL) -c $(INSTAPPFLAGS) XMandel.ad $(DESTDIR)$(XAPPLOADDIR)/XMandel
X
# -------------------------------------------------------------------------
# common rules for all Makefiles - do not edit
X
emptyrule::
X
clean::
X	$(RM_CMD) "#"*
X
Makefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
tags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
saber:
X	# load $(ALLDEFINES) $(SRCS)
X
osaber:
X	# load $(ALLDEFINES) $(OBJS)
X
# -------------------------------------------------------------------------
# empty rules for directories that do not have SUBDIRS - do not edit
X
install::
X	@echo "install in $(CURRENT_DIR) done"
X
install.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
Makefiles::
X
includes::
X
# -------------------------------------------------------------------------
# dependencies generated by makedepend
X
SHAR_EOF
chmod 0644 Makefile.std ||
echo 'restore of Makefile.std failed'
Wc_c="`wc -c < 'Makefile.std'`"
test 11508 -eq "$Wc_c" ||
	echo 'Makefile.std: original size 11508, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
X		XMANDEL          May, 1992
X
This is a modified version of XMANDEL written originally by John L
Freedman (jlf@cray.com). It has been suitably hacked and added to make it
run on Interactive Unix X11R4 as well as SunOS.
X
The following enhacements to the original code have been made:
X
X	1. Athena or Motif GUI
X	2. zooming on both the Mandelbrot or Julia sets
X	3. support for 1,2,4 or 8 bit display systems
X	4. GIF file output of images.
X	5. exposure events are honoured
X	6. the images may be rotated through the default colour map
X
GIF code was borrowed from the John Bradley's (bradley@cis.upenn.edu)
XXV.2.11 sources.
X
The "quality" of the images is almost completely dependent upon the
choice of the colour map! (It is unfortunate that this edition of xmandel
cannot alter the colour map).  Usually, a decent default colour map
may be installed with "xcolors".  Detailed editing of the color may
may be done with xcoloredit, cpicker/pixedit or other color editors.
X
Still missing from this version:
X	1. a GOOD method to colour the mandelbrot/julia images
X	2. a history file of "pretty image" coordinates with
X	   the associated colour map.
X	3. an XView3 implementation of the GUI.
X
TIMINGS: (full, unzoomed Mandelbrot set generation)
========
On a 33mHz 386 with a 1024x768 image, display time = 13min 28 seconds
On an HP9000s720 with 1024x768 image, display time = 24 seconds.
X
INSTALLATION
============
An Imakefile is provided for use with imake/xmkmf.
A Makefile.unix is useful if imake/xmkmf is not available.
X
Mofify the Imakefile or Makefile.unix to select the Athena or the Motif
widget set. You may also need to specify the use of bcopy().
X
Follow normal make proceedures with "make", imake" or "xmkmf".
X
MOTIF RESOURCE FILE
===================
If the MOTIF version of xmandel is created the "xmandel.mot.ad" file
should be used to set reasonable mouse actions for the buttons. I
attempted to hard code these translations into my Interactive Unix X11R4
version of Motif, however it failed miserably. Thus, the application
resource file should be created in the appropriate directory, eg:
X
X	cp xmandel.mot.ad /usr/lib/X11/app-defaults/XMandel
X
This file is NOT needed for the Athena widget version of xmandel.
X
BUGS
====
Some event processing might not be done in the proper way in
mandel.c and julia.c.
X
XXmandel does NOT run on an Apollo!  It fails on a call to XtDisplay:
X
X	display = XtDisplay(toplevel);
X
for "no reason".
X
X
===================================================
Tony Field      tony@ajfcal.cuc.ab.ca             May, 1992
SHAR_EOF
chmod 0644 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 2547 -eq "$Wc_c" ||
	echo 'README: original size 2547, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= julia.c ==============
if test -f 'julia.c' -a X"$1" != X"-c"; then
	echo 'x - skipping julia.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting julia.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'julia.c' &&
/* ta=4 */
X
#include <stdio.h>
#include <X11/Intrinsic.h>
#include "mandel.h"
X
struct imageparm juliaparm = { 0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0, 0, 0, 0, 0, 0, NULL, NULL, "\0", "\0", "\0", "\0" };
static struct zoomd *zoomtmp;
extern struct imageparm manparm;
X
void julia ();
X
int	 julia_in_progress = 0;
X
extern Display *display;
extern Screen *screen;
extern int depth;
extern int dots_per_byte;
X
static int scanline = -1;
static int bottomscan = 0;
X
static GC draw_gc;
static XImage *ximage = NULL;
static char *image_data = NULL;
static XWindowAttributes draw_wattr;
static double a = 1.2;
static double b = 1.2;
X
/************************************************************************
*	do_mandel()			button: mandel, 	compute mandelbort set		*
************************************************************************/
X
void start_julia (destroy_pixmap, newimage)
int		destroy_pixmap;
int		newimage;
{
X	if (juliaparm.window == 0)
X		return;
X	if (juliaparm.zoom)
X	{	while (zoomtmp = juliaparm.zoom->zp) 
X		{	free(juliaparm.zoom);
X			juliaparm.zoom = zoomtmp;
X		}
X	} 
X	else 
X	{	juliaparm.zoom = (struct zoomd *) malloc(sizeof (struct zoomd));
X		juliaparm.zoom->zp = NULL;	/* NULL means last in stack - don't pop */
X	}
X	juliaparm.zoom->lx = juliaparm.lx;
X	juliaparm.zoom->ux = juliaparm.ux;
X	juliaparm.zoom->ly = juliaparm.ly;
X	juliaparm.zoom->uy = juliaparm.uy;
X
X	julia (destroy_pixmap, 1);
}
X
X
/************************************************************************
*	do_julia()			button:	julia		compute julia set.			*
************************************************************************/
X
void julia (destroy_pixmap, newimage)
int		destroy_pixmap;
int		newimage;
{
X	XEvent ev;
X	double wx, wy, oldwx;
X	double sx, x, y;
X	double incrx, incry;
X	int ix, iy;
X	long	save_event_mask;
X	int		shift, mirror;
X	Visual *draw_v;
X
X	if (manparm.zoom == NULL  ||  juliaparm.window == 0)
X		return;
X	juliaparm.lx = juliaparm.zoom->lx;
X	juliaparm.ly = juliaparm.zoom->ly;
X	juliaparm.ux = juliaparm.zoom->ux;
X	juliaparm.uy = juliaparm.zoom->uy;
X	update_coordinates (&juliaparm, 1);
X
X	scanline = -1;
X	julia_in_progress = 1;
X
X	draw_gc = screen->default_gc;
X	draw_v = screen->root_visual;
X	XGetWindowAttributes(display, manparm.window, &draw_wattr);
X	save_event_mask = draw_wattr.your_event_mask;
X
X	if (newimage)
X	{
X		/*	user must provide a point in the Mandelbrot window */
X
X		a = b = 0;
X		XSelectInput (display, manparm.window, ButtonPressMask | ButtonReleaseMask
X					| PointerMotionHintMask | PointerMotionMask | ExposureMask);
X		while (1) 
X		{	XEvent report;
X
X			XNextEvent (display, &report);
X			if (report.type == ButtonRelease  &&  report.xmotion.window == manparm.window)
X			{	a = ( (double) report.xbutton.x / (double) draw_wattr.width);
X				b = ( (double) report.xbutton.y / (double) draw_wattr.height);
X				a = (a * (manparm.zoom->ux - manparm.zoom->lx)) + manparm.zoom->lx;
X				b = manparm.zoom->uy - (b * (manparm.zoom->uy - manparm.zoom->ly));
X				juliaparm.px = a;
X				juliaparm.py = b;
X				update_point (&juliaparm);
X				break;
X			}
X			else if (report.type == MotionNotify)
X			{	Window	root,  child;
X				int		pos_x, pos_y;
X				unsigned int keys_buttons;
X				int		root_x, root_y;
X				if (XQueryPointer (display, report.xmotion.window,
X						&root, &child, &root_x, &root_y,
X						&pos_x, &pos_y, &keys_buttons)  &&  report.xmotion.window  == manparm.window)
X				{
X					a = ( (double) pos_x / (double) draw_wattr.width);
X					b = ( (double) pos_y / (double) draw_wattr.height);
X					a = (a * (manparm.zoom->ux - manparm.zoom->lx)) + manparm.zoom->lx;
X					b = manparm.zoom->uy - (b * (manparm.zoom->uy - manparm.zoom->ly));
X					juliaparm.px = a;
X					juliaparm.py = b;
X					juliaparm.pcolour = pixel_colour (&manparm, pos_x, pos_y);
X					update_point (&juliaparm);
X				}
X			}
X			else
X				XtDispatchEvent (&report);
X			continue;
X		}
X	}
X	XSelectInput (display, manparm.window, save_event_mask);
X
X	XGetWindowAttributes (display, juliaparm.window, &draw_wattr);
X	if (destroy_pixmap)
X	{	if (ximage)
X			XDestroyImage(ximage); 			/* also deallocated image_data */
X		if (juliaparm.pix)
X			free (juliaparm.pix);
X		image_data 		= NULL;  
X		juliaparm.pix 	= NULL; 
X		ximage 			= NULL;
X		juliaparm.pixwidth = juliaparm.pixheight = -9999;
X
X	}
X
X	XClearWindow (display, juliaparm.window);
X	XSelectInput(display, juliaparm.window, ExposureMask | ButtonPressMask | ButtonReleaseMask);
X	if (juliaparm.pixwidth != draw_wattr.width  ||  juliaparm.pixheight != draw_wattr.height)
X	{
X		/*	if window changes size, rebuild the image information */
X	
X		juliaparm.pixwidth = draw_wattr.width;
X		juliaparm.bytewidth = (juliaparm.pixwidth + dots_per_byte - 1) / dots_per_byte;
X
X		if (ximage)
X			XDestroyImage (ximage); 
X		if (juliaparm.pix)
X			free (juliaparm.pix);
X
X		image_data = malloc (juliaparm.bytewidth + 1);
X		juliaparm.pix = (unsigned char *) malloc (draw_wattr.height * juliaparm.bytewidth);
X		if (image_data == NULL  ||  juliaparm.pix == NULL) 
X		{	printf ("malloc failed\n"); 
X			return; 
X		}
X		ximage = XCreateImage (display, draw_v, depth, ZPixmap, 0, image_data, juliaparm.pixwidth, 1, 8, juliaparm.bytewidth);
X		ximage->byte_order = MSBFirst;
X		ximage->bitmap_bit_order = MSBFirst;
X	}
X	juliaparm.pixheight = draw_wattr.height;
X
X
X	/*	compute julia set for given coordinates */
X
X	sx = x = juliaparm.lx;
X	y = juliaparm.uy;
X	incrx = (juliaparm.ux - juliaparm.lx)  / draw_wattr.width;
X	incry = (juliaparm.ly - juliaparm.uy)  / draw_wattr.height;
X	scanline = -1;
X	bottomscan = draw_wattr.height;
X	for (iy = 0; iy < draw_wattr.height;  iy++, y+=incry) 
X	{	int i;
X
X		x = sx;
X		if (depth < 8) 
X		{	for (i = 0 ; i < juliaparm.bytewidth; i++) 
X				*(image_data + i) = 0;
X		}
X
X		/*	build all points for one scan line of output */
X
X		for (ix = 0; ix < draw_wattr.width; ix++, x+=incrx) 
X		{
X			/*	compute the colour of a single pixel */
X
X			wx = x; wy = y;
X			for (i = 0; i < ITERATION_DEPTH; i++) 
X			{	oldwx = wx;
X				wx = wx * wx - wy * wy + a;
X				wy = 2 * oldwx * wy + b;
X				if (wx * wx + wy * wy > 4) 
X					goto useit;
X			}
X			if (depth == 8)
X			{	if (INFINITY_COLOR >= 0)
X					i = INFINITY_COLOR - COLOR_BIAS;
X			}
X			else
X			{	if (INFINITY_COLOR >= 0)
X					i = INFINITY_COLOR;
X			}
X
useit:		/*	assign colour to point based on screen depth */
X
X			switch (depth)
X			{
X			case 8:
X				*(image_data + ix) = i + COLOR_BIAS;
X				break;
X
X			case 4:
X				if (ix % 2)
X					image_data[ix >> 1] |= (i % 16);
X				else
X					image_data[ix >> 1] |= ((i % 16) << 4);
X				break;
X
X			case 2:
X				switch (ix % 4)
X				{
X				case 0:		shift = 6;	break;
X				case 1:		shift = 4;	break;
X				case 2:		shift = 2;	break;
X				case 3:		shift = 0;	break;
X				}
X				image_data[ix >> 2] |= (i % 4) << shift;
X				break;
X			case 1:
X				if (i % 2)
X					image_data[ix >> 3] |= 1 << (7 - ix%8);
X			}
X		}
X
X		/*	save a copy of the scan line for exposure events or gif output */
X
X		memcpy (juliaparm.pix + iy * juliaparm.bytewidth, image_data, juliaparm.bytewidth);
X		scanline = iy;
X		/*	send the image line to the screen */
X
X		XPutImage (display, juliaparm.window, draw_gc, ximage, 0,0, 0, iy, juliaparm.pixwidth, 1);
X
X		/*	handle exposure or button pressed events */
X
X		if (iy % EXPOSURE_TEST == 0)
X		{	XSync (display, False);
X			while (XCheckTypedEvent (display, Expose, &ev) == True)
X				XtDispatchEvent (&ev);
X			while (XCheckWindowEvent (display, juliaparm.window, ButtonPressMask | ButtonReleaseMask, &ev) == True)
X			{	if (ev.type == ButtonRelease)
X					goto escape;
X			}
X		}
X	}
escape:
X	XSync (display, False);
X	julia_in_progress = 0;
}
X
X
/************************************************************************
*	expose_julia()		handle exposure event on julia window.			*
************************************************************************/
X
void expose_julia (w, unused, event)
Widget w;
caddr_t unused;
XXExposeEvent *event;
{
X	if (juliaparm.window == 0)
X		return;
X	if (event  &&  juliaparm.pix  && scanline >= 0)
X		redraw_julia (event);
}
X
/************************************************************************
*	redraw_julia()		send julia from image bit vectors				*
************************************************************************/
X
void redraw_julia (event)
XXExposeEvent *event;
{
X	int  iy;
X	XWindowAttributes draw_wattr;
X	int		jump;
X	int	maxy;
X
X	if (juliaparm.window == 0)
X		return;
X	if (juliaparm.pix == NULL  ||  scanline < 0)
X		return;
X
X	XGetWindowAttributes (display, juliaparm.window, &draw_wattr);
X	jump = 1;
X	if (event == NULL)
X	{
X		/*	refresh entire image */
X
X		maxy = MIN (draw_wattr.height, juliaparm.pixheight);
X		for (iy = 0; iy <= scanline; iy++) 
X		{	memcpy (image_data, juliaparm.pix + iy * juliaparm.bytewidth, juliaparm.bytewidth);
X			XPutImage (display, juliaparm.window, draw_gc, ximage, 0,0, 0, iy, juliaparm.pixwidth, 1);
X		}
X	}
X	else
X	{	/*	refresh only exposed area */
X
X		int	first_byte, last_byte, nbytes, first_dot, last_dot, ndots;
X
X		if (event->x < juliaparm.pixwidth)
X		{	first_byte = event->x / dots_per_byte;
X			first_dot  = first_byte * dots_per_byte;
X			last_dot   = MIN (juliaparm.pixwidth - 1, event->x + event->width - 1);
X			last_byte  = (last_dot + dots_per_byte - 1) / dots_per_byte;
X			nbytes     = last_byte - first_byte + 1;
X			ndots      = last_dot - first_dot + 1;
X			maxy       = MIN (event->y + event->height, juliaparm.pixheight);
X			for (iy = event->y; iy <= scanline; iy++) 
X			{	memcpy (image_data, juliaparm.pix + iy * juliaparm.bytewidth + first_byte , nbytes);
X				XPutImage (display, juliaparm.window, draw_gc, ximage, 0,0, event->x, iy, ndots, 1);
X			}
X		}
X	}
X	XFlush(display);
}
X
SHAR_EOF
chmod 0644 julia.c ||
echo 'restore of julia.c failed'
Wc_c="`wc -c < 'julia.c'`"
test 9512 -eq "$Wc_c" ||
	echo 'julia.c: original size 9512, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= main.c ==============
if test -f 'main.c' -a X"$1" != X"-c"; then
	echo 'x - skipping main.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting main.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'main.c' &&
/* ta=4 */
/************************************************************************
*			mandebrot and julia set generator							*
************************************************************************/
X
#ifdef MOTIF
#include "mainmotif.c"
#else
#include "mainaw.c"
#endif
X
SHAR_EOF
chmod 0644 main.c ||
echo 'restore of main.c failed'
Wc_c="`wc -c < 'main.c'`"
test 276 -eq "$Wc_c" ||
	echo 'main.c: original size 276, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= mainaw.c ==============
if test -f 'mainaw.c' -a X"$1" != X"-c"; then
	echo 'x - skipping mainaw.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting mainaw.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'mainaw.c' &&
/* ta=4	 (tabstop=4)
X *
X * Xmandel - written by John Freeman at Cray Research
X *
X *	modified to work on Interactive Unix X11 R4 and added gif output.
X *	  Tony Field (tony@ajfcal.cuc.ab.ca)
X *
X * This file contains the main routine for driving the mandelbrot generator
X */
X
#include <X11/IntrinsicP.h>
#include <X11/Shell.h>
#include <X11/StringDefs.h>
#include <X11/Xaw/Cardinals.h>
#include <X11/Xaw/Box.h>
#include <X11/Xaw/Form.h>
#include <X11/Xaw/Command.h>
#include <X11/Xaw/Paned.h>
#include <X11/Xaw/Dialog.h>
X
#include <stdio.h>
#include "mandel.h"
#include "mandel.bit"
X
#ifdef __STDC__
static void do_mandel(Widget w, caddr_t client_data, caddr_t call_data);
static void do_julia(Widget w, caddr_t client_data, caddr_t call_data);
static void do_remove(Widget w, caddr_t client_data, caddr_t call_data);
static void do_quit(Widget w, caddr_t client_data, caddr_t call_data);
static void do_toggle(Widget w, caddr_t client_data, caddr_t call_data);
static void do_recalc(Widget w, caddr_t client_data, caddr_t call_data);
static void set_image(char *s);
static void do_gif(Widget w, caddr_t client_data, caddr_t call_data);
static String tidy(String s);
static void MandelFname(Widget w, caddr_t client_data, caddr_t call_data);
static void JuliaFname(Widget w, caddr_t client_data, caddr_t call_data);
static void FnameCancel(Widget w, caddr_t client_data, caddr_t call_data);
static void do_colour(Widget w, caddr_t client_data, caddr_t call_data);
static void MandelRotate(Widget w, caddr_t client_data, caddr_t call_data);
static void JuliaRotate(Widget w, caddr_t client_data, caddr_t call_data);
static void rotate_selected(void);
static void rotateplus(Widget w, caddr_t client_data, caddr_t call_data);
static void rotateminus(Widget w, caddr_t client_data, caddr_t call_data);
static void CancelRotate(Widget w, caddr_t client_data, caddr_t call_data);
static void rotate(struct imageparm *parm, int val);
static XtActionProc nothing(Widget w, XButtonEvent *event, String *params, Cardinal *num_params);
static void reshape_widgets(Widget parent, char **full_size, char **small_size);
static Widget *ConvertNamesToWidgets(Widget parent, char **names);
#else
static void do_mandel();
static void do_julia();
static void do_remove();
static void do_quit();
static void do_toggle();
static void do_recalc();
static void set_image();
static void do_gif();
static String tidy();
static void MandelFname();
static void JuliaFname();
static void FnameCancel();
static void do_colour();
static void MandelRotate();
static void JuliaRotate();
static void rotate_selected();
static void rotateplus();
static void rotateminus();
static void CancelRotate();
static void rotate();
static XtActionProc nothing();
static void reshape_widgets();
static Widget *ConvertNamesToWidgets();
#endif
X
Display *display;
Screen	*screen;
Widget drawform;
Window root;
int depth;							/*	bits per pixel (colour depth) 	*/
int dots_per_byte;					/*	pixel dots in a byte			*/
X
extern struct imageparm manparm;
extern struct imageparm juliaparm;
struct imageparm *activeimage = &manparm;
static Widget toplevel, juliashell = NULL;
extern int julia_in_progress;
X
static Pixmap 		mandel_pixmap, julim_pixmap;
X
Widget pshell, pressme, fnameDialog, dialogDone, dialogCancel, juliaFname;
Widget jshell, cshell, colourit, rotate_mandel, rotate_julia, rotate_cancel;
Widget toggle;
X
/*	kill use of the carriage return */
X
char *kset = "#override \n\
X    Ctrl<Key>M:     nothing() \n\
X    <Key>Return:    nothing()";
X
XXtActionsRec gif_actions[] =
{	{ (String) "nothing", (XtActionProc) nothing }
} ;
X
X
/*	buttons name, callback, parent for basic user buttons	*/
X
struct button_list button[] = 
{	{ "mandel",		do_mandel	 },
X	{ "julia",		do_julia	 },
X	{ "toggle",		do_toggle	 },
X	{ "zoom",		do_zoom		 },
X	{ "unzoom",		do_unzoom	 },
X	{ "colour",		do_colour	 },
X	{ "+colour",	rotateplus	 },
X	{ "-colour",	rotateminus	 },
X	{ "recalc",		do_recalc    },
X	{ "gif",		do_gif		 },
X	{ "remove",		do_remove	 },
X	{ "quit",		do_quit		 },
X	{ NULL,			NULL		 }
};
X
char *is_mandel = "Image: Mandel ";
char *is_julia  = "Image: Julia  ";
int	mandel_window_high;
X
main (argc, argv)
int argc;
char **argv;
{
X	Widget pane, box, form, new;
X	Arg av[10];
X	Cardinal i;
X	int	n;
X	int	wide, high;
X	double dx, dy;
X	char depth_str[10];
X	XtTranslations mytranslations;
X	static char *on_separate_lines[] = { "label", "value", NULL };
X	static char *on_single_line[] = { "Mandelbrot", "Julia", "Cancel", NULL };
X
X	toplevel = XtInitialize (argv[0], "XMandel", NULL, 0, &argc, argv);
X
X	display = XtDisplay(toplevel);
X	root = RootWindow (display, DefaultScreen(display));
X	depth = DefaultDepthOfScreen (XtScreen(toplevel));
X	screen  = XtScreen (toplevel);
X	switch (depth)
X	{
X	case 8:		dots_per_byte = 1;  break;
X	case 4:		dots_per_byte = 2;  break;
X	case 2:		dots_per_byte = 4;	break;
X	case 1:		dots_per_byte = 8;	break;
X	default:	printf ("Cannot handle %d bit colour\n", depth);
X				exit (1);
X	}
X	sprintf (depth_str, "%d", depth);		/*	default for "colour" button */
X	manparm.rotation = juliaparm.rotation = depth;
X	printf ("%d bit color\n", depth);
X	manparm.totrot   = 0;
X	manparm.window   = 0;
X	manparm.pix      = NULL;
X	juliaparm.totrot = 0;
X	juliaparm.window = 0;
X	juliaparm.pix    = NULL;
X
X	/*	create a resizable container for user buttons and graphics */
X
X	pane = XtCreateManagedWidget ("pane", panedWidgetClass, toplevel, NULL, ZERO);
X
X	/*	create a button box within the pane for user selection */
X
X	box = XtCreateManagedWidget ("box", boxWidgetClass, pane, NULL, ZERO);
X
X	/*	create all user button widgets + associated callbacks, add to "box" */
X
X	for (n = 0;  button[n].ident;  n++)
X	{	new =  XtCreateManagedWidget (button[n].ident, commandWidgetClass, box, NULL, ZERO);
X		XtAddCallback (new, XtNcallback, button[n].bcall , 0);
X	}
X
X    new = XtNameToWidget (box, "mandel");
X	i = 0;	
X	XtSetArg (av[i], XtNlabel, "  Mandelbrot  "); i++;
X	XtSetValues(new, av, i);
X
X    new = XtNameToWidget (box, "julia");
X	i = 0;	
X	XtSetArg (av[i], XtNlabel, "    Julia     "); i++;
X	XtSetValues(new, av, i);
X
X	toggle = XtNameToWidget (box, "toggle");
X	set_image (is_mandel);
X
X	/*	create a form widget within the pane to hold the graphics. */
X
X	form = XtCreateManagedWidget ("form", formWidgetClass, pane, NULL, ZERO);
X
X	dx = START_UX - START_LX;
X	dx = ABS (dx);
X	dy = START_UY - START_LY;
X	dy = ABS (dy);
X	wide = 225;
X	high = (double) wide * (dy / dx);
X	mandel_window_high = high;
X
X	/*	add the drawing area to the form widget */
X
X	i = 0;
X	XtSetArg (av[i], XtNtop, XtChainTop); i++;
X	XtSetArg (av[i], XtNbottom, XtChainBottom); i++;
X	XtSetArg (av[i], XtNleft, XtChainLeft); i++;
X	XtSetArg (av[i], XtNright, XtChainRight); i++;
X	XtSetArg (av[i], XtNwidth, wide); i++;
X	XtSetArg (av[i], XtNheight, high); i++;
X	drawform = XtCreateManagedWidget ("mandelbrot", widgetClass, form, av, i);
X
X	/*	popup to request gif output file name */
X
X	i = 0;
X	pshell = XtCreatePopupShell("Write Gif", transientShellWidgetClass, toplevel, av, i);
X
X	i = 0;
X    XtSetArg (av[i], XtNvalue, ""); i++;
X    XtSetArg (av[i], XtNlabel, "Output GIF file name. Select Mandelbrot or Julia.");  i++;
X	fnameDialog = XtCreateManagedWidget("fname", dialogWidgetClass, pshell, av, i);
X
X	i = 0;
X	dialogDone = XtCreateManagedWidget("Mandelbrot", commandWidgetClass, fnameDialog, av, i);
X
X	i = 0;
X	juliaFname = XtCreateManagedWidget("Julia", commandWidgetClass, fnameDialog, av, i);
X
X	i = 0;
X	dialogCancel = XtCreateManagedWidget("Cancel", commandWidgetClass, fnameDialog, av, i);
X
X	XtAddCallback(dialogDone, XtNcallback, MandelFname, fnameDialog);
X	XtAddCallback(juliaFname, XtNcallback, JuliaFname, fnameDialog);
X	XtAddCallback(dialogCancel, XtNcallback, FnameCancel, fnameDialog);
X
X	/*	popup to request colour rotate */
X
X	i = 0;
X	cshell = XtCreatePopupShell("Colour Rotate", transientShellWidgetClass, toplevel, av, i);
X
X	i = 0;
X    XtSetArg (av[i], XtNvalue, ""); i++;
X    XtSetArg (av[i], XtNlabel, "Rotate current colour values by:");  i++;
X    XtSetArg (av[i], XtNvalue, depth_str);  i++;
X	colourit = XtCreateManagedWidget("colour", dialogWidgetClass, cshell, av, i);
X
X	i = 0;
X	rotate_mandel = XtCreateManagedWidget("Mandelbrot", commandWidgetClass, colourit, av, i);
X
X	i = 0;
X	rotate_julia = XtCreateManagedWidget("Julia", commandWidgetClass, colourit, av, i);
X
X	i = 0;
X	rotate_cancel = XtCreateManagedWidget("Cancel", commandWidgetClass, colourit, av, i);
X
X	XtAddCallback(rotate_mandel, XtNcallback, MandelRotate, colourit);
X	XtAddCallback(rotate_julia, XtNcallback, JuliaRotate, colourit);
X	XtAddCallback(rotate_cancel, XtNcallback, CancelRotate, colourit);
X
X	/*	disable <enter> in fnameDialog box */
X
X	XtAddActions (gif_actions, XtNumber (gif_actions));
X
X	/*	create julia window as a popup shell */
X
X	i = 0;
X	jshell = XtCreatePopupShell("Julia Set", transientShellWidgetClass, toplevel, av, i);
X	XtAddEventHandler (jshell, ExposureMask, FALSE,  expose_julia, NULL);
X
X	/*	setup function to handle exposure events	*/
X
X	XtAddEventHandler (drawform, ExposureMask, FALSE,  expose_mandel, NULL);
X	reshape_widgets (fnameDialog, on_separate_lines, on_single_line);
X	reshape_widgets (colourit, on_separate_lines, on_single_line);
X
X	/*	kill use of the carriage return */
X
X    new = XtNameToWidget (fnameDialog, "value");
X	mytranslations = XtParseTranslationTable (kset);
X	XtOverrideTranslations (new,   mytranslations);
X
X    new = XtNameToWidget (colourit, "value");
X	mytranslations = XtParseTranslationTable (kset);
X	XtOverrideTranslations (new,   mytranslations);
X
X	mandel_pixmap = XCreateBitmapFromData (XtDisplay (toplevel),
X						RootWindowOfScreen (XtScreen (toplevel)),
X						mandel_bits,
X						mandel_width,
X						mandel_height);
X	XtSetArg (av[0], XtNiconPixmap, mandel_pixmap);
X	XtSetValues (toplevel, av, 1);
X
X	XtRealizeWidget (toplevel);
X	juliaparm.pix = NULL;
X	manparm.pix = NULL;
X	XtMainLoop ();
}
X
/*	callbacks	/
X
/************************************************************************
*	do_mandel()		button = mandel:	create/use mandelbrot window	*
************************************************************************/
X
static void do_mandel (w, client_data, call_data)
Widget w;
caddr_t client_data;
caddr_t call_data;
{	unsigned int	high, wide;
X	double			dx, dy;
X
X	manparm.lx = START_LX;
X	manparm.ly = START_LY;
X	manparm.ux = START_UX;
X	manparm.uy = START_UY;
X	dx = START_UX - START_LX;
X	dx = ABS (dx);
X	dy = START_UY - START_LY;
X	dy = ABS (dy);
X	wide = 225;
X	high = (double) wide * (dy / dx);
X	manparm.window = XtWindow (drawform);
X	manparm.totrot = 0;
X	start_mandel ();
}
X
/************************************************************************
*	do_julia()		button = julia:		create/use julia window			*
************************************************************************/
X
static void do_julia (w, client_data, call_data)
Widget w;
caddr_t client_data;
caddr_t call_data;
{	int		i;
X	Arg		av[10];
X
X	if (manparm.window == 0)
X		return;
X
X	juliaparm.lx = -1.5;
X	juliaparm.ly = -1.5;
X	juliaparm.ux = 1.5;
X	juliaparm.uy = 1.5;
X	if (juliaparm.window == 0)
X	{
X		if (juliashell == NULL)
X		{	i = 0;
X			XtSetArg (av[i], XtNwidth,   	mandel_window_high);		i++;
X			XtSetArg (av[i], XtNheight,  	mandel_window_high);		i++;
X			XtSetArg (av[i], XtNtitle,		"Julia");					i++;
X			XtSetArg (av[i], XtNiconName,	"Julia");					i++;
X			juliashell = XtCreateApplicationShell ("Juliashell", topLevelShellWidgetClass, av, i);
X			XtAddEventHandler (juliashell, ExposureMask, FALSE,  expose_julia, NULL);
X
X			julim_pixmap = XCreateBitmapFromData (XtDisplay (juliashell),
X						RootWindowOfScreen (XtScreen (juliashell)),
X						julim_bits,
X						julim_width,
X						julim_height);
X			XtSetArg (av[0], XtNiconPixmap, julim_pixmap);
X			XtSetValues (juliashell, av, 1);
X
X			XtRealizeWidget (juliashell);
X		}
X		else
X			XtMapWidget (juliashell);
X		juliaparm.window = XtWindow (juliashell);
X	}
X	juliaparm.window = XtWindow (juliashell);
X	juliaparm.totrot = 0;
X	start_julia (1, 1);
X	printf ("\n");
}
X
/************************************************************************
*	do_recalc			button = recalc.	recalculate current set.	*
************************************************************************/
X
static void do_recalc (w, client_data, call_data)
Widget w;
caddr_t client_data;
caddr_t call_data;
{
X	if (activeimage == &manparm)
X		redo_mandel();
X	else
X		julia (1,0);
}
X
X
/************************************************************************
*	do_remove():		button = remove.  unmap julia widget			*
************************************************************************/
X
static void do_remove (w, client_data, call_data)
Widget w;
caddr_t client_data;
caddr_t call_data;
{
X	if (julia_in_progress)
X		return;
X
X	if (juliaparm.window)
X		XtUnmapWidget (juliashell);
X
X	juliaparm.window = 0;
X	activeimage = &manparm;
X	set_image (is_mandel);
}
X
/************************************************************************
*	do_quit():		button = quit,   leave xmandel.						*
************************************************************************/
X
static void do_quit (w, client_data, call_data)
Widget w;
caddr_t client_data;
caddr_t call_data;
{
X	printf ("\n");
X	exit (0);
}
X
/************************************************************************
*	do_toggle():		button = quit,   leave xmandel.						*
************************************************************************/
X
static void do_toggle (w, client_data, call_data)
Widget w;
caddr_t client_data;
caddr_t call_data;
{	char	*which;
X
X	if (juliaparm.window == 0)
X		return;
X	if (activeimage == &manparm)
X	{	activeimage = &juliaparm;
X		which = is_julia;
X	}
X	else
X	{	activeimage = &manparm;
X		which = is_mandel;
X	}
X	set_image (which);
X		
}
X
static void set_image (s)
char *s;
{	int		i;
X	Arg		av[10];
X
X	i = 0;	
X	XtSetArg (av[i], XtNlabel, s); i++;
X	XtSetValues(toggle, av, i);
}
X
/************************************************************************
*	do_gif ()		button = gif,   ask user for file name				*
************************************************************************/
X
static void do_gif (w, client_data, call_data)
Widget w;
caddr_t client_data;
caddr_t call_data;
{
X	Position x, y;
X	Dimension width, height;
X	Arg arg[2];
X	int i;
X
X	/*	 get the coordinates of the middle of toplevel widget.	*/
X
X	i = 0;
X	XtSetArg(arg[i], XtNwidth, &width);    i++;
X	XtSetArg(arg[i], XtNheight, &height);  i++;
X	XtGetValues(toplevel, arg, i);
X	
X	/*	translate coordinates in application top-level window
X		into coordinates from root window origin.
X	*/
X	XtTranslateCoords(toplevel,				/* Widget */
X                (Position) width/2,			/* x */
X                (Position) height/2,		/* y */
X                &x, &y);					/* coords on root window */
X
X	/* move popup shell to this position (it's not visible yet) */
X
X	i = 0;
X	XtSetArg(arg[i], XtNx, x);  		i++;
X	XtSetArg(arg[i], XtNy, y);  		i++;
X	XtSetValues(pshell, arg, i);
X
X	/*	Indicate to user that no other application functions are
X		valid while fnameDialog is popped up...
X	*/
X	XtPopup(pshell, XtGrabNonexclusive);
}
X
/************************************************************************
*	tidy()		return the first non-blank word (ascii dependent!)		*
************************************************************************/
X
static String tidy (s)
String s;
{	String cs;
X
X	while (*s  &&  *s == ' ')
X		s++;
X	cs = s;
X	while (*s  &&  *s > ' '  &&  *s <= 'z')
X		s++;
X	*s = 0;
X	return (cs);
}
X
/************************************************************************
*	MandelFname ()	button = gif/accept   write image to gif file		*
************************************************************************/
X
static void MandelFname (w, client_data, call_data)
Widget w;
caddr_t client_data;
caddr_t call_data;
{
X	String string, s;
X
X    string = XawDialogGetValueString(fnameDialog);
X	s = tidy (string);
X	if (*s  && manparm.pix)
X	{	activeimage = &manparm;
X		printf ("Mandelbrot gif file = %s\n", s);
X	    write_gif_image (s, activeimage);
X	}
X    XtPopdown(pshell);
X    set_image (is_mandel);
X    XFlush (display);
}
X
/************************************************************************
*	JuliaFname ()	button = gif/accept   write image to gif file		*
************************************************************************/
X
static void JuliaFname (w, client_data, call_data)
Widget w;
caddr_t client_data;
caddr_t call_data;
{
X	String string, s;
X
X    string = XawDialogGetValueString(fnameDialog);
X	s = tidy (string);
X	if (*s  &&  juliaparm.pix)
X	{	activeimage = &juliaparm;
X		printf ("Julia gif file = %s\n", s);
X	    write_gif_image (s, activeimage);
X	}
X    XtPopdown(pshell);
X    set_image (is_julia);
X    XFlush (display);
}
X
/************************************************************************
*	FnameCancel()		button = gif/cancel		ignore file write rq.	*
************************************************************************/
X
static void FnameCancel (w, client_data, call_data)
Widget w;
caddr_t client_data;
caddr_t call_data;
{
X	XtPopdown(pshell);
X    XFlush (display);
}
X
X
/************************************************************************
*	do_colour()		button = gif,   ask user for file name				*
************************************************************************/
X
static void do_colour (w, client_data, call_data)
Widget w;
caddr_t client_data;
caddr_t call_data;
{
X	Position x, y;
X	Dimension width, height;
X	Arg arg[2];
X	int i;
X
X	/*	 get the coordinates of the middle of toplevel widget.	*/
X
X	i = 0;
X	XtSetArg(arg[i], XtNwidth, &width);    i++;
X	XtSetArg(arg[i], XtNheight, &height);  i++;
X	XtGetValues(w, arg, i);
X
X	XtTranslateCoords(w,					/* Widget */
X                (Position) 0,			/* x */
X                (Position) height+2,		/* y */
X                &x, &y);					/* coords on root window */
X
X	/* move popup shell to this position (it's not visible yet) */
X
X	i = 0;
X	XtSetArg(arg[i], XtNx, x);  		i++;
X	XtSetArg(arg[i], XtNy, y);  		i++;
X	XtSetValues(cshell, arg, i);
X
X	/*	Indicate to user that no other application functions are
X		valid while fnameDialog is popped up...
X	*/
X	XtPopup(cshell, XtGrabNonexclusive);
}
X
/************************************************************************
*	MandelRotate	 		button = colour/mandelbort:	rotate colour	*
************************************************************************/
X
static void MandelRotate (w, client_data, call_data)
Widget w;
caddr_t client_data;
caddr_t call_data;
{
X	if (manparm.window)
X	{	activeimage = &manparm;
X		set_image (is_mandel);
X		rotate_selected ();
X	}
}
X
/************************************************************************
*	JuliaRotate()			button = colour/julia	rotate julia colour	*
************************************************************************/
X
static void JuliaRotate (w, client_data, call_data)
Widget w;
caddr_t client_data;
caddr_t call_data;
{
X	if (juliaparm.window)
X	{	activeimage = &juliaparm;
X		set_image (is_julia);
X		rotate_selected ();
X	}
}
X
/************************************************************************
*	JuliaRotate()			button = colour/julia	rotate julia colour	*
************************************************************************/
X
static void rotate_selected ()
{	String string, s;
X	int		atoi();
X
X    XtPopdown(cshell);
X    XFlush (display);
X    string = XawDialogGetValueString(colourit);
X	s = tidy (string);
X	if (*s  && manparm.pix)
X	{	activeimage->rotation = atoi (s);
X	}
}
X
/************************************************************************
*	rotateplus			button = +colour	rotate colour positive		*
************************************************************************/
X
static void rotateplus (w, client_data, call_data)
Widget w;
caddr_t client_data;
caddr_t call_data;
{
X	rotate (activeimage,  activeimage->rotation);
SHAR_EOF
true || echo 'restore of mainaw.c failed'
fi
echo 'End of  part 1'
echo 'File mainaw.c is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
