Newsgroups: comp.sources.x
Path: uunet!uunet!darwin.sura.net!mips!msi!dcmartin
From: jipping@cs.hope.edu (Mike Jipping)
Subject: v18i063: XVTDL 3.0, Part02/06
Message-ID: <1992Jul29.175029.14890@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
References: <csx-18i062-xvtdl-3.0@uunet.UU.NET>
Date: Wed, 29 Jul 1992 17:50:29 GMT
Approved: dcmartin@msi.com
Lines: 1796

Submitted-by: jipping@cs.hope.edu (Mike Jipping)
Posting-number: Volume 18, Issue 63
Archive-name: xvtdl-3.0/part02

#!/bin/sh
# this is part.02 (part 2 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file bitmaps/tdl.pr continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 2; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping bitmaps/tdl.pr'
else
echo 'x - continuing file bitmaps/tdl.pr'
sed 's/^X//' << 'SHAR_EOF' >> 'bitmaps/tdl.pr' &&
X	0xC000,0x0800,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xC000,0x0000,0x0000,0x1800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800
SHAR_EOF
echo 'File bitmaps/tdl.pr is complete' &&
chmod 0644 bitmaps/tdl.pr ||
echo 'restore of bitmaps/tdl.pr failed'
Wc_c="`wc -c < 'bitmaps/tdl.pr'`"
test 1997 -eq "$Wc_c" ||
	echo 'bitmaps/tdl.pr: original size 1997, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bitmaps/tdl_empty.pr ==============
if test -f 'bitmaps/tdl_empty.pr' -a X"$1" != X"-c"; then
	echo 'x - skipping bitmaps/tdl_empty.pr (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bitmaps/tdl_empty.pr (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bitmaps/tdl_empty.pr' &&
/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0xFFFF,	0xFFFF,	0xFFFF,	0xF800,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xF800,
X	0xC000,	0x0000,	0x0000,	0x18F8,
X	0xC000,	0x0000,	0x0000,	0x19FC,
X	0xC000,	0x0000,	0x0000,	0x19FC,
X	0xC003,	0xE01F,	0x0000,	0x19FC,
X	0xC002,	0xA009,	0x8000,	0x19FC,
X	0xC000,	0x8608,	0x9800,	0x1904,
X	0xC000,	0x8908,	0xA400,	0x1904,
X	0xC000,	0x8908,	0xA400,	0x1904,
X	0xC000,	0x8909,	0xA400,	0x19FC,
X	0xC001,	0xC61F,	0x1800,	0x1904,
X	0xC000,	0x0000,	0x0000,	0x1904,
X	0xC000,	0x0000,	0x0000,	0x1904,
X	0xC000,	0x0000,	0x0000,	0x19FC,
X	0xC000,	0x0000,	0x0000,	0x19FC,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x1954,
X	0xC000,	0x0000,	0x0000,	0x19FC,
X	0xC000,	0x0000,	0x0000,	0x1904,
X	0xC000,	0x0000,	0x0000,	0x1904,
X	0xC000,	0x0000,	0x0000,	0x1888,
X	0xC000,	0x0000,	0x0000,	0x1888,
X	0xC000,	0x0000,	0x0000,	0x1888,
X	0xC000,	0x0000,	0x0000,	0x18F8,
X	0xC000,	0x0000,	0x0000,	0x1870,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xF870,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xF820,
SHAR_EOF
chmod 0644 bitmaps/tdl_empty.pr ||
echo 'restore of bitmaps/tdl_empty.pr failed'
Wc_c="`wc -c < 'bitmaps/tdl_empty.pr'`"
test 2190 -eq "$Wc_c" ||
	echo 'bitmaps/tdl_empty.pr: original size 2190, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bitmaps/tdl_full.pr ==============
if test -f 'bitmaps/tdl_full.pr' -a X"$1" != X"-c"; then
	echo 'x - skipping bitmaps/tdl_full.pr (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bitmaps/tdl_full.pr (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bitmaps/tdl_full.pr' &&
/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0xFFFF,	0xFFFF,	0xFFFF,	0xF81C,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xF83E,
X	0xC000,	0x0000,	0x0000,	0x187F,
X	0xC000,	0x0000,	0x0000,	0x189F,
X	0xC000,	0x0000,	0x0000,	0x198F,
X	0xC003,	0xE01F,	0x0000,	0x1A46,
X	0xC002,	0xA009,	0x8000,	0x1E24,
X	0xC000,	0x8608,	0x9800,	0x1B18,
X	0xC000,	0x8908,	0xA400,	0x1490,
X	0xC000,	0x8908,	0xA400,	0x2960,
X	0xC000,	0x8909,	0xA400,	0x5240,
X	0xC001,	0xC61F,	0x1800,	0xA480,
X	0xC000,	0x0000,	0x0001,	0x4900,
X	0xFFFF,	0xFFFF,	0xFFFE,	0x9200,
X	0xC000,	0x0000,	0x0005,	0x2400,
X	0xC000,	0x0000,	0x000A,	0x4800,
X	0xC000,	0x0000,	0x0014,	0x9800,
X	0xC007,	0xCC06,	0x0029,	0x3800,
X	0xC102,	0x2402,	0x0052,	0x5800,
X	0xC302,	0x2402,	0x00A4,	0x9800,
X	0xC103,	0xC463,	0x8149,	0x1800,
X	0xC102,	0x2492,	0x4292,	0x1800,
X	0xC102,	0x2472,	0x4524,	0x1800,
X	0xC102,	0x2492,	0x4A48,	0x1800,
X	0xC3A7,	0xCEFB,	0x5490,	0x1800,
X	0xC000,	0x0000,	0x2920,	0x1800,
X	0xC000,	0x0000,	0x5240,	0x1800,
X	0xC000,	0x0000,	0xA480,	0x1800,
X	0xC000,	0x0001,	0x4900,	0x1800,
X	0xC000,	0x0002,	0x9200,	0x1800,
X	0xC180,	0x7CC5,	0x2400,	0x1800,
X	0xC240,	0x224A,	0x4800,	0x1800,
X	0xC240,	0x2254,	0x9000,	0x1800,
X	0xC040,	0x3C29,	0x2000,	0x1800,
X	0xC080,	0x2252,	0x4000,	0x1800,
X	0xC100,	0x22E4,	0x8000,	0x1800,
X	0xC208,	0x2329,	0x0000,	0x1800,
X	0xC3C8,	0x7D12,	0x0000,	0x1800,
X	0xC000,	0x020C,	0x0000,	0x1800,
X	0xC000,	0x0218,	0x0000,	0x1800,
X	0xC000,	0x0660,	0x0000,	0x1800,
X	0xC000,	0x0780,	0x0000,	0x1800,
X	0xC000,	0x0E00,	0x0000,	0x1800,
X	0xC180,	0x7CC0,	0x6000,	0x1800,
X	0xC240,	0x2240,	0x2000,	0x1800,
X	0xC040,	0x2240,	0x2000,	0x1800,
X	0xC180,	0x3C46,	0x3800,	0x1800,
X	0xC040,	0x2249,	0x2400,	0x1800,
X	0xC240,	0x2247,	0x2400,	0x1800,
X	0xC248,	0x2249,	0x2400,	0x1800,
X	0xC188,	0x7CEF,	0xB600,	0x1800,
X	0xC000,	0x0000,	0x0000,	0x1800,
X	0xC000,	0x0000,	0x0000,	0x1800,
X	0xC000,	0x0000,	0x0000,	0x1800,
X	0xC000,	0x0000,	0x0000,	0x1800,
X	0xC000,	0x0000,	0x0000,	0x1800,
X	0xC000,	0x0000,	0x0000,	0x1800,
X	0xC000,	0x0000,	0x0000,	0x1800,
X	0xC000,	0x0000,	0x0000,	0x1800,
X	0xC000,	0x0000,	0x0000,	0x1800,
X	0xC000,	0x0000,	0x0000,	0x1800,
X	0xC000,	0x0000,	0x0000,	0x1800,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xF800,
X	0xFFFF,	0xFFFF,	0xFFFF,	0xF800,
SHAR_EOF
chmod 0644 bitmaps/tdl_full.pr ||
echo 'restore of bitmaps/tdl_full.pr failed'
Wc_c="`wc -c < 'bitmaps/tdl_full.pr'`"
test 2190 -eq "$Wc_c" ||
	echo 'bitmaps/tdl_full.pr: original size 2190, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bitmaps/tdl_mask.pr ==============
if test -f 'bitmaps/tdl_mask.pr' -a X"$1" != X"-c"; then
	echo 'x - skipping bitmaps/tdl_mask.pr (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bitmaps/tdl_mask.pr (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bitmaps/tdl_mask.pr' &&
/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0xFFFF,0xFFFF,0xFFFF,0xF81C,
X	0xFFFF,0xFFFF,0xFFFF,0xF83E,
X	0xFFFF,0xFFFF,0xFFFF,0xF87F,
X	0xFFFF,0xFFFF,0xFFFF,0xF8FF,
X	0xFFFF,0xFFFF,0xFFFF,0xF9FF,
X	0xFFFF,0xFFFF,0xFFFF,0xFBFE,
X	0xFFFF,0xFFFF,0xFFFF,0xFFFC,
X	0xFFFF,0xFFFF,0xFFFF,0xFFF8,
X	0xFFFF,0xFFFF,0xFFFF,0xFFF0,
X	0xFFFF,0xFFFF,0xFFFF,0xFFE0,
X	0xFFFF,0xFFFF,0xFFFF,0xFFC0,
X	0xFFFF,0xFFFF,0xFFFF,0xFF80,
X	0xFFFF,0xFFFF,0xFFFF,0xFF00,
X	0xFFFF,0xFFFF,0xFFFF,0xFE00,
X	0xFFFF,0xFFFF,0xFFFF,0xFC00,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800,
X	0xFFFF,0xFFFF,0xFFFF,0xF800
SHAR_EOF
chmod 0644 bitmaps/tdl_mask.pr ||
echo 'restore of bitmaps/tdl_mask.pr failed'
Wc_c="`wc -c < 'bitmaps/tdl_mask.pr'`"
test 1997 -eq "$Wc_c" ||
	echo 'bitmaps/tdl_mask.pr: original size 1997, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= cursor.c ==============
if test -f 'cursor.c' -a X"$1" != X"-c"; then
	echo 'x - skipping cursor.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting cursor.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'cursor.c' &&
/*
X * $Id: cursor.c,v 2.2 1992/07/13 14:23:29 jipping Exp $
X * **********************************************************************
X *
X * Cursor.c --> Routines for manipulating the cursors.
X *
X * Just a few routines to make cursor changing easy: a creation routine
X * and a changer.
X *
X * ----------------------------------------------------------------------
X * Copyright (c) 1992 by Mike Jipping and Hope College
X *
X * Permission is granted to copy and distribute this file in modified or
X * unmodified form, for noncommercial use, provided (a) this copyright notice
X * is preserved, (b) no attempt is made to restrict redistribution of this
X * file, and (c) this file is not distributed as part of any collection whose
X * redistribution is restricted by a compilation copyright.
X * ----------------------------------------------------------------------
X *
X * Revision History:
X *
X * $Log: cursor.c,v $
X * Revision 2.2  1992/07/13  14:23:29  jipping
X * Added "tdl_list" to cursors to change -- so list will change too.
X *
X * Revision 2.1  1992/07/13  13:53:22  jipping
X * Placed all cursor bitmaps in subdirectory.
X *
X * Revision 2.0  1992/07/06  12:49:13  jipping
X * Initial release.
X *
X */
X
#include "globaldefs.h"
X
short edit_bits[] = {
#include "bitmaps/edit.pr"
};
Server_image edit_glyph = NULL;
XXv_cursor edit_cursor;
X
short cut_bits[] = {
#include "bitmaps/cut.pr"
};
Server_image cut_glyph = NULL;
XXv_cursor cut_cursor;
X
XXv_cursor copy_cursor;
XXv_cursor basic_cursor;
X
void create_cursors ()
{
X	basic_cursor = xv_create(NULL, CURSOR,
X									 CURSOR_SRC_CHAR, OLC_BASIC_PTR,
X									 0);
X
X	copy_cursor = xv_create(NULL, CURSOR,
X									CURSOR_SRC_CHAR, OLC_MOVE_PTR,
X									0);
X
X	edit_glyph = (Server_image)xv_create(NULL, SERVER_IMAGE,
X														 XV_WIDTH, 16,
X														 XV_HEIGHT, 16,
X														 SERVER_IMAGE_BITS, edit_bits,
X														 0);
X	edit_cursor = (Xv_Cursor) xv_create(NULL, CURSOR,
X														CURSOR_IMAGE,  edit_glyph,
X														CURSOR_XHOT, 8,
X														CURSOR_YHOT,  8,
X														0);
X
X	cut_glyph = (Server_image)xv_create(NULL, SERVER_IMAGE,
X															  XV_WIDTH, 16,
X															  XV_HEIGHT, 16,
X															  SERVER_IMAGE_BITS, cut_bits,
X															  0);
X	cut_cursor = (Xv_Cursor) xv_create(NULL, CURSOR,
X															 CURSOR_IMAGE,  cut_glyph,
X															 CURSOR_XHOT, 8,
X															 CURSOR_YHOT,  8,
X															 0);
X	
}
X
extern Panel tdl_control, tdl_title, tdl_list;
X
/*
X *  Change the cursor.  Note that this has a bug: this does not change the
X *  cursor over all parts of the todo list window.
X */
void set_cursor (cursor)
XXv_cursor cursor;
{
X	xv_set(xv_get(tdl_title, CANVAS_NTH_PAINT_WINDOW, 0),
X			 WIN_CURSOR, cursor,
X			 0);
X	xv_set(xv_get(tdl_control, CANVAS_NTH_PAINT_WINDOW, 0),
X			 WIN_CURSOR, cursor,
X			 0);
X	xv_set(xv_get(tdl_list, CANVAS_NTH_PAINT_WINDOW, 0),
X			 WIN_CURSOR, cursor,
X			 0);
}
SHAR_EOF
chmod 0644 cursor.c ||
echo 'restore of cursor.c failed'
Wc_c="`wc -c < 'cursor.c'`"
test 2909 -eq "$Wc_c" ||
	echo 'cursor.c: original size 2909, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= entry_ui.h ==============
if test -f 'entry_ui.h' -a X"$1" != X"-c"; then
	echo 'x - skipping entry_ui.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting entry_ui.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'entry_ui.h' &&
#ifndef	entry_HEADER
#define	entry_HEADER
X
/*
X * entry_ui.h - User interface object and function declarations.
X * This file was generated by `gxv' from `entry.G'.
X * DO NOT EDIT BY HAND.
X */
X
extern Attr_attribute	INSTANCE;
X
X
typedef struct {
X	Xv_opaque	entry_frame;
X	Xv_opaque	entry_panel;
X	Xv_opaque	entry_type;
X	Xv_opaque	entry_category;
X	Xv_opaque	recurring;
X	Xv_opaque	entry_text;
X	Xv_opaque	entry_priority;
X	Xv_opaque	entry_cancel;
X	Xv_opaque	entry_done;
} entry_entry_frame_objects;
X
extern entry_entry_frame_objects	*entry_entry_frame_objects_initialize();
X
extern Xv_opaque	entry_entry_frame_entry_frame_create();
extern Xv_opaque	entry_entry_frame_entry_panel_create();
extern Xv_opaque	entry_entry_frame_entry_type_create();
extern Xv_opaque	entry_entry_frame_entry_category_create();
extern Xv_opaque	entry_entry_frame_recurring_create();
extern Xv_opaque	entry_entry_frame_entry_text_create();
extern Xv_opaque	entry_entry_frame_entry_priority_create();
extern Xv_opaque	entry_entry_frame_entry_cancel_create();
extern Xv_opaque	entry_entry_frame_entry_done_create();
#endif
SHAR_EOF
chmod 0644 entry_ui.h ||
echo 'restore of entry_ui.h failed'
Wc_c="`wc -c < 'entry_ui.h'`"
test 1088 -eq "$Wc_c" ||
	echo 'entry_ui.h: original size 1088, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= globaldefs.h ==============
if test -f 'globaldefs.h' -a X"$1" != X"-c"; then
	echo 'x - skipping globaldefs.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting globaldefs.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'globaldefs.h' &&
/*
X *  Global (external) definitions for the XVTDL software
X */
X
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <time.h>
#include <pwd.h>
#include <sys/types.h>
#include <sys/file.h>
#include <errno.h>
X
#include <X11/X.h>
#include <X11/Xlib.h>
X
#include <xview/xview.h>
#include <xview/panel.h>
#include <xview/textsw.h>
#include <xview/svrimage.h>
#include <xview/font.h>
#include <xview/icon.h>
#include <xview/xv_xrect.h>
#include <xview/openmenu.h>
#include <xview/notify.h>
#include <xview/notice.h>
#include <xview/cursor.h>
X
#include "print_ui.h"
#include "entry_ui.h"
#include "props_ui.h"
X
#define PRINT_PROLOG1 "/home/hydra/jipping/misc/tdl/prolog1.ps"
#define PRINT_PROLOG2 "/home/hydra/jipping/misc/tdl/prolog2.ps"
X
#if !defined(XVIEW2) && !defined(XVIEW3)
#       ifdef FRAME_FOCUS_UP_WIDTH
#       define XVIEW3
#       else
#       define XVIEW2
#       endif
#endif
X
#if defined(XVIEW2)
#undef XVIEW3
#endif
X 
#if defined(XVIEW3)
#undef XVIEW2
#endif
X
#define NEW(A) ((A *) malloc(sizeof(A)))
#define EQUAL(s1,s2) strcmp(s1, s2) == 0
X
#define MASK(n)          ((unsigned long)(1 << (n)))
#define BIT_IS_SET(x,n)  ((x) & MASK(n))
#define SET_BIT(x,n)     x |= MASK(n)
#define UNSET_BIT(x,n)   x &= ~MASK(n)
X
#define FILENAMESIZ 200
#define LINESIZ     200
#define BIG        1000
X
#define LOG_AT_CHECKED 0
#define LOG_AT_QUIT    1
#define LOG_NEVER      2
#define LOG_TIMESTAMP  0
#define LOG_USER_SPEC  1
X
extern int debug;
extern int verbose;
extern int editing, copying, cutting;
X
entry_entry_frame_objects	*entry_editor;
print_print_base_objects   *print_print_base;
X
extern char fname[FILENAMESIZ];
char default_printer[25], log_preference[10], log_file[LINESIZ];
char priority_listing[13], log_info_pref[25];
int postscriptmode,logging;
X
extern Frame tdlist, entry_frame, recurring_frame;
X
extern struct tm current, *tm, today, *localtime();
extern int curr_month, curr_day, curr_year;
X
extern Server_image checked_on, checked_off;
extern Server_image checks[10];
X
extern Xv_cursor basic_cursor, copy_cursor, cut_cursor, edit_cursor;
X
extern Canvas calendar;
extern Panel_item todo, entry_text, entry_done, categories, recurring;
extern Panel_item entry_type, entry_category;
extern Panel_item freq, day_of_week, day_of_week2, weeks, week_of_month;
X
extern int zeller(), daysinmonth();
extern int changed;
X
extern int log_level, log_info_level;
X
struct recurrence_list {
X	int starting_day_code;
X	char text[LINESIZ];
X	int priority;
X	int daily, weekly, biweekly, monthly, yearly;
X	int dow;
X	int mwf, tt;
X	int week_number, number_of_weeks;
X	struct recurrence_list *next;
};
X
struct day_entry {
X	char text[LINESIZ];
X	int checked, recurring_entry;
X	int priority;
X	struct day_entry *prev, *next;
};
X
extern struct day_entry *cut_buffer;
X
struct entry_list {
X	int day_code;
X	int recurring_checked;
X	struct day_entry *first, *last, *rl_first, *rl_last;
X	struct entry_list *next;
};
X
extern struct entry_list *entry_head, *entry_tail;
X
extern struct recurrence_list *rl_head, *rl_tail;
X
struct category_rec {
X	char name[LINESIZ];
X	struct entry_list *entry_head, *entry_tail;
X	struct recurrence_list *rl_head, *rl_tail;
X	struct category_rec *next;
};
X
extern struct category_rec *category_head;
SHAR_EOF
chmod 0644 globaldefs.h ||
echo 'restore of globaldefs.h failed'
Wc_c="`wc -c < 'globaldefs.h'`"
test 3226 -eq "$Wc_c" ||
	echo 'globaldefs.h: original size 3226, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= logedit_ui.h ==============
if test -f 'logedit_ui.h' -a X"$1" != X"-c"; then
	echo 'x - skipping logedit_ui.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting logedit_ui.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'logedit_ui.h' &&
#ifndef	logedit_HEADER
#define	logedit_HEADER
X
/*
X * logedit_ui.h - User interface object and function declarations.
X * This file was generated by `gxv' from `logedit.G'.
X * DO NOT EDIT BY HAND.
X */
X
extern Attr_attribute	INSTANCE;
X
X
typedef struct {
X	Xv_opaque	log_edit;
X	Xv_opaque	log_editor;
X	Xv_opaque	controls1;
X	Xv_opaque	log_editor_cancel;
X	Xv_opaque	log_editor_done;
} logedit_log_edit_objects;
X
extern logedit_log_edit_objects	*logedit_log_edit_objects_initialize();
X
extern Xv_opaque	logedit_log_edit_log_edit_create();
extern Xv_opaque	logedit_log_edit_log_editor_create();
extern Xv_opaque	logedit_log_edit_controls1_create();
extern Xv_opaque	logedit_log_edit_log_editor_cancel_create();
extern Xv_opaque	logedit_log_edit_log_editor_done_create();
#endif
SHAR_EOF
chmod 0644 logedit_ui.h ||
echo 'restore of logedit_ui.h failed'
Wc_c="`wc -c < 'logedit_ui.h'`"
test 768 -eq "$Wc_c" ||
	echo 'logedit_ui.h: original size 768, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= patchlevel.h ==============
if test -f 'patchlevel.h' -a X"$1" != X"-c"; then
	echo 'x - skipping patchlevel.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting patchlevel.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'patchlevel.h' &&
/*  Version number... */
X
#define VERSION 3
#define PATCHLEVEL 0
SHAR_EOF
chmod 0644 patchlevel.h ||
echo 'restore of patchlevel.h failed'
Wc_c="`wc -c < 'patchlevel.h'`"
test 65 -eq "$Wc_c" ||
	echo 'patchlevel.h: original size 65, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= print_ui.h ==============
if test -f 'print_ui.h' -a X"$1" != X"-c"; then
	echo 'x - skipping print_ui.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting print_ui.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'print_ui.h' &&
#ifndef	print_HEADER
#define	print_HEADER
X
/*
X * print_ui.h - User interface object and function declarations.
X * This file was generated by `gxv' from `print.G'.
X * DO NOT EDIT BY HAND.
X */
X
extern Attr_attribute	INSTANCE;
X
X
typedef struct {
X	Xv_opaque	print_base;
X	Xv_opaque	controls1;
X	Xv_opaque	postscript;
X	Xv_opaque	printer;
X	Xv_opaque	scale;
X	Xv_opaque	categories;
X	Xv_opaque	incl_checked_items;
X	Xv_opaque	cancel_print;
X	Xv_opaque	exec_print;
} print_print_base_objects;
X
extern print_print_base_objects	*print_print_base_objects_initialize();
X
extern Xv_opaque	print_print_base_print_base_create();
extern Xv_opaque	print_print_base_controls1_create();
extern Xv_opaque	print_print_base_postscript_create();
extern Xv_opaque	print_print_base_printer_create();
extern Xv_opaque	print_print_base_scale_create();
extern Xv_opaque	print_print_base_categories_create();
extern Xv_opaque	print_print_base_incl_checked_items_create();
extern Xv_opaque	print_print_base_cancel_print_create();
extern Xv_opaque	print_print_base_exec_print_create();
#endif
SHAR_EOF
chmod 0644 print_ui.h ||
echo 'restore of print_ui.h failed'
Wc_c="`wc -c < 'print_ui.h'`"
test 1056 -eq "$Wc_c" ||
	echo 'print_ui.h: original size 1056, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= prolog2.ps ==============
if test -f 'prolog2.ps' -a X"$1" != X"-c"; then
	echo 'x - skipping prolog2.ps (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting prolog2.ps (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'prolog2.ps' &&
62.08 703.39 M
X 63.16 705.19 63.16 705.19 65.46 708 D
X 67.77 710.81 67.77 710.81 69.5 709.3 D
X 71.22 707.78 71.22 707.78 72.95 705.05 D
X 74.75 702.31 74.75 702.31 75.33 700.08 D
X 75.83 697.85 75.83 697.85 83.61 716.42 D
X 91.31 735 91.31 735 93.83 732.19 D
X 96.28 729.38 96.28 729.38 96.35 730.25 D
X 96.42 731.04 96.42 731.04 98.22 729.02 D
X 100.02 726.94 100.02 726.94 87.21 706.42 D
X 74.46 685.82 74.46 685.82 73.38 689.71 D
X 72.3 693.53 72.3 693.53 69.71 696.34 D
X 67.19 699.14 67.19 699.14 64.1 700.37 D
X 61 701.59 61 701.59 62.08 703.39 D
O
V
0.2 H
0 Z
N
65.9 690.79 88.29 712.9 R
N
90 642 558 642 2 L
0.5 H
2 Z
N
X
SHAR_EOF
chmod 0644 prolog2.ps ||
echo 'restore of prolog2.ps failed'
Wc_c="`wc -c < 'prolog2.ps'`"
test 619 -eq "$Wc_c" ||
	echo 'prolog2.ps: original size 619, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= props_ui.h ==============
if test -f 'props_ui.h' -a X"$1" != X"-c"; then
	echo 'x - skipping props_ui.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting props_ui.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'props_ui.h' &&
#ifndef	props_HEADER
#define	props_HEADER
X
/*
X * props_ui.h - User interface object and function declarations.
X * This file was generated by `gxv' from `props.G'.
X * DO NOT EDIT BY HAND.
X */
X
extern Attr_attribute	INSTANCE;
X
X
typedef struct {
X	Xv_opaque	props_frame;
X	Xv_opaque	logging_panel;
X	Xv_opaque	logging_msg;
X	Xv_opaque	log_preference;
X	Xv_opaque	log_info;
X	Xv_opaque	log_filename;
X	Xv_opaque	other_panel;
X	Xv_opaque	other_msg;
X	Xv_opaque	priority_direction;
X	Xv_opaque	def_printer;
X	Xv_opaque	def_print_mode;
X	Xv_opaque	controls1;
X	Xv_opaque	done_button;
X	Xv_opaque	reset_button;
} props_props_frame_objects;
X
extern props_props_frame_objects	*props_props_frame_objects_initialize();
X
extern Xv_opaque	props_props_frame_props_frame_create();
extern Xv_opaque	props_props_frame_logging_panel_create();
extern Xv_opaque	props_props_frame_logging_msg_create();
extern Xv_opaque	props_props_frame_log_preference_create();
extern Xv_opaque	props_props_frame_log_info_create();
extern Xv_opaque	props_props_frame_log_filename_create();
extern Xv_opaque	props_props_frame_other_panel_create();
extern Xv_opaque	props_props_frame_other_msg_create();
extern Xv_opaque	props_props_frame_priority_direction_create();
extern Xv_opaque	props_props_frame_def_printer_create();
extern Xv_opaque	props_props_frame_def_print_mode_create();
extern Xv_opaque	props_props_frame_controls1_create();
extern Xv_opaque	props_props_frame_done_button_create();
extern Xv_opaque	props_props_frame_reset_button_create();
#endif
SHAR_EOF
chmod 0644 props_ui.h ||
echo 'restore of props_ui.h failed'
Wc_c="`wc -c < 'props_ui.h'`"
test 1509 -eq "$Wc_c" ||
	echo 'props_ui.h: original size 1509, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= todo.l ==============
if test -f 'todo.l' -a X"$1" != X"-c"; then
	echo 'x - skipping todo.l (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting todo.l (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'todo.l' &&
X
number		[0-9]+(\.[0-9]+)?
string		\".*\"
comment         #.*
X
whitespace	[ \n\r\t]
X
%%
{whitespace}	{/* do nothing for now */}
X
category        {return CATEGORY;}
{number}	{number_value = atoi(yytext); return NUMBER;}
{comment}       {/* do nothing with comments */}
{string}	{return STRING;}
\/              {return SLASH;}
\:		{return COLON;}
\|              {return BAR;}
D               {return BIGD;}
N               {return BIGN;}
W               {return BIGW;}
M               {return BIGM;}
T               {return BIGT;}
d               {return LITTLED;}
w               {return LITTLEW;}
b               {return LITTLEB;}
m               {return LITTLEM;}
y               {return LITTLEY;}
X
SHAR_EOF
chmod 0644 todo.l ||
echo 'restore of todo.l failed'
Wc_c="`wc -c < 'todo.l'`"
test 702 -eq "$Wc_c" ||
	echo 'todo.l: original size 702, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= calendar.c ==============
if test -f 'calendar.c' -a X"$1" != X"-c"; then
	echo 'x - skipping calendar.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting calendar.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'calendar.c' &&
/* $Id: calendar.c,v 2.0 1992/07/01 19:02:35 jipping Exp $
X *
X * **********************************************************************
X *
X *    Calendar.c ==> Calendar-related routines.
X *
X *    This set of routines implements the calendar in the upper left of
X *    the todo list.  It stops short of implementing a calendar widget 
X *    for XView.
X *
X *    Copyright (C) 1991 by Mike Jipping and Hope College
X *
X * Revision History:
X *
X * $Log: calendar.c,v $
X * Revision 2.0  1992/07/01  19:02:35  jipping
X * Initial release version.
X *
X * Revision 1.0  1991/07/02  12:02:21  jipping
X * Initial revision
X *
X *
X * **********************************************************************
X */
X
#include "globaldefs.h"
X
char *monthname[12] = {
X   "January", "February", "March", "April", "May", "June", "July",
X   "August", "September", "October", "November", "December"
};
X
/*
X * Determines whether a given year is a leap year
X */
X
int leapyear (year)
int year;
{
X  if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0))
X     return (1);
X  else
X     return (0);
}
X
/*
X *  Returns #days in month given month and year, taking
X *    leap years into account for February.
X */
X
int daysinmonth (month, year)
int month, year;
{
X  if (month == 2)          /* Is it February?             */
X     if (leapyear (year))  /* If so, is it a leap year?   */
X        return (29);       /* 29 days in Feb in leap year */
X     else
X        return (28);       /* 28 days if not              */
X  else{
X     if (month > 7)        /* Is it August -> December?   */
X        month++;           /* Invert even/odd state if so */
X     if (month & 1)        /* Odd months have 31 days     */
X        return (31);
X     else
X        return (30);       /* Even months have 30 days    */
X  }
}
X
/*  Determines whether a given date is valid
X */
X
int validdate (month, day, year)
int month, day, year;
{
X  if (month < 1 || month > 12 || day < 1 ||
X     day > daysinmonth (month, year) ||
X     year < 1583 || year > 9999)
X        return (0);
X  else
X        return (1);
}
X
/*  Given a valid date (month, day, and year) Zeller will
X *    return an integer representing the day of week that
X *    date will fall on. 0 = Sunday, 6 = Saturday.
X */
X
int zeller (month, day, year)
int month, day, year;
{
X  int century;
X  month -= 2;       /* Years start on March 1 so adjust standard date */
X  if (month < 1) {
X     month += 12;
X     year--;
X  }
X  century = year / 100;
X  year = (int)year % (int)100;
X  return ((int)((2.6 * month - 0.1) + day + year + year / 4  + century / 4 - century * 2) % 7);
}
X
/*
X * print_header: prints the name of the month and the year
X */
X
print_header(month, year)
int month, year;
{
X   Xv_font font;
X   Display *dpy = (Display *)xv_get(calendar, XV_DISPLAY);
X   XGCValues gcvalues;
X   GC gc;
X   Window xwin = xv_get(canvas_paint_window(calendar), XV_XID);
X   char title[15];
X
X   font = xv_find(calendar, FONT,
X                  FONT_FAMILY,  FONT_FAMILY_LUCIDA,
X                  FONT_STYLE,   FONT_STYLE_BOLD_ITALIC,
X                  FONT_SCALE,   WIN_SCALE_LARGE,
X                  0);
X   gcvalues.font = xv_get(font, XV_XID);
X   gcvalues.foreground = BlackPixel(dpy, DefaultScreen(dpy));
X   gcvalues.background = WhitePixel(dpy, DefaultScreen(dpy));
X   gcvalues.graphics_exposures = False;
X   gc = XCreateGC(dpy, RootWindow(dpy, DefaultScreen(dpy)),
X                  GCForeground | GCBackground | GCFont | GCGraphicsExposures,
X                  &gcvalues);
X      
X   XClearWindow(dpy, xwin);
X   sprintf(title, "%s %4d", monthname[month-1], year);
X   XDrawString(dpy, xwin, gc, 10, 10, title, strlen(title));
}
X
/*
X * Given the day of the week, and the week number, this routine prints
X * the "day" (date) at comuted coordinates in the calendar.
X */
X
print_day(week, dow, day)
int week, dow, day;
{
X   Display *dpy = (Display *)xv_get(calendar, XV_DISPLAY);
X   GC gc = DefaultGC(dpy, DefaultScreen(dpy));
X   Window xwin = xv_get(canvas_paint_window(calendar), XV_XID);
X   char daystr[3];
X   
X   sprintf(daystr, "%2d", day);
X   XDrawString(dpy, xwin, gc,
X               24*dow, 30+12*(week-1),
X               daystr, strlen(daystr));
X
}
X
/*
X * This routine adds a "highlight" (rectangle) on the current day. 
X */
X
highlite (week, dow)
int week, dow;
{
X   Display *dpy = (Display *)xv_get(calendar, XV_DISPLAY);
X   GC gc = DefaultGC(dpy, DefaultScreen(dpy));
X   Window xwin = xv_get(canvas_paint_window(calendar), XV_XID);
X
X   XDrawRectangle(dpy, xwin, gc,
X                  24*dow-4, 30+12*(week-2)+1,
X                  20, 12);
}
X
/*
X * Here we control the actual calendar generation --> calling
X * print_header and print_day as needed.
X */
X
print_calendar(month, year)
int month, year;
{
X   int start, days, dow, week, day;
X
X   start = zeller(month, 1, year);
X   days = daysinmonth(month, year);
X
X   print_header(month, year);
X   week = 1;
X   dow = start;
X   for (day=1; day <= days; day++) {
X      dow = dow % 7;
X      if ( (dow == 0) && (day != 1) ) week++;
X      print_day(week, dow, day);
X      if (day == curr_day) highlite(week, dow);
X      dow++;
X   }
}
X
/*
X * event_proc()
X *      Called when an event is received in the canvas window.
X *      Only button events are monitored in this window, and any button
X *      event will cause a move to the day the event was on.  We first
X *      compute the day the button event occured over, then we move to
X *      that day.
X */
void
calendar_event_proc(window, event)
XXv_Window window;
Event    *event;
{
X   int dow, week, first, date;
X
X	if (! event_is_button(event)) return;
X   if (event_is_up(event)) return;   /* only react on button-down events */
X
X   /* Compute the date the event occured over */
X   dow = event_x(event) / 24;
X   week = (event_y(event) - 18) / 12 + 1;
X   first = zeller(curr_month, 1, curr_year);
X   date = 1 + (dow - first) + 7*(week-1);
X
X   /*
X    * The date is in terms of the current month.  If it is between 1 and
X    * the number of days in the month, we only need to move in the
X    * current month.  However, "date" could be negative, meaning we need
X    * to move to last month, or > the days in the current month, meaning
X    * we need to move to next month.
X    */
X   if ((date > 0) & (date <= daysinmonth(curr_month, curr_year))) {
X      curr_day = date;
X   } else if (date > daysinmonth(curr_month, curr_year)) {
X      curr_day = date - daysinmonth(curr_month, curr_year);
X      curr_month = (curr_month+1) % 12;
X      if (curr_month == 0) curr_month = 12;
X      if (curr_month == 1) curr_year++;
X   } else {
X      curr_month = (curr_month-1) % 12;
X      if (curr_month == 0) {
X         curr_month = 12;
X         curr_year --;
X      }
X      curr_day = daysinmonth(curr_month, curr_year) + date;
X   }
X
X   /* Move to the date specified. */
X   print_calendar(curr_month, curr_year);
X   reset_date_message();
X   display_list(curr_month, curr_day, curr_year);  
}
X
SHAR_EOF
chmod 0644 calendar.c ||
echo 'restore of calendar.c failed'
Wc_c="`wc -c < 'calendar.c'`"
test 6846 -eq "$Wc_c" ||
	echo 'calendar.c: original size 6846, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= entry_ui.c ==============
if test -f 'entry_ui.c' -a X"$1" != X"-c"; then
	echo 'x - skipping entry_ui.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting entry_ui.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'entry_ui.c' &&
/*
X * entry_ui.c - User interface object initialization functions.
X * This file was generated by `gxv' from `entry.G'.
X * DO NOT EDIT BY HAND.
X */
X
#include <stdio.h>
#include <sys/param.h>
#include <sys/types.h>
#include <xview/xview.h>
#include <xview/canvas.h>
#include <xview/panel.h>
#include <xview/scrollbar.h>
#include <xview/svrimage.h>
#include <xview/termsw.h>
#include <xview/text.h>
#include <xview/tty.h>
#include <xview/xv_xrect.h>
#include "entry_ui.h"
X
/*
X * Initialize an instance of object `entry_frame'.
X */
entry_entry_frame_objects *
entry_entry_frame_objects_initialize(ip, owner)
X	entry_entry_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	if (!ip && !(ip = (entry_entry_frame_objects *) calloc(1, sizeof (entry_entry_frame_objects))))
X		return (entry_entry_frame_objects *) NULL;
X	if (!ip->entry_frame)
X		ip->entry_frame = entry_entry_frame_entry_frame_create(ip, owner);
X	if (!ip->entry_panel)
X		ip->entry_panel = entry_entry_frame_entry_panel_create(ip, ip->entry_frame);
X	if (!ip->entry_type)
X		ip->entry_type = entry_entry_frame_entry_type_create(ip, ip->entry_panel);
X	if (!ip->entry_category)
X		ip->entry_category = entry_entry_frame_entry_category_create(ip, ip->entry_panel);
X	if (!ip->recurring)
X		ip->recurring = entry_entry_frame_recurring_create(ip, ip->entry_panel);
X	if (!ip->entry_text)
X		ip->entry_text = entry_entry_frame_entry_text_create(ip, ip->entry_panel);
X	if (!ip->entry_priority)
X		ip->entry_priority = entry_entry_frame_entry_priority_create(ip, ip->entry_panel);
X	if (!ip->entry_cancel)
X		ip->entry_cancel = entry_entry_frame_entry_cancel_create(ip, ip->entry_panel);
X	if (!ip->entry_done)
X		ip->entry_done = entry_entry_frame_entry_done_create(ip, ip->entry_panel);
X	return ip;
}
X
/*
X * Create object `entry_frame' in the specified instance.
X */
XXv_opaque
entry_entry_frame_entry_frame_create(ip, owner)
X	entry_entry_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, FRAME_CMD,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_WIDTH, 545,
X		XV_HEIGHT, 165,
X		XV_LABEL, "Entry Editor",
X		FRAME_SHOW_FOOTER, TRUE,
X		FRAME_SHOW_RESIZE_CORNER, TRUE,
X		FRAME_CMD_PUSHPIN_IN, FALSE,
X		NULL);
X	xv_set(xv_get(obj, FRAME_CMD_PANEL), WIN_SHOW, FALSE, NULL);
X	return obj;
}
X
/*
X * Create object `entry_panel' in the specified instance.
X */
XXv_opaque
entry_entry_frame_entry_panel_create(ip, owner)
X	entry_entry_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 0,
X		XV_Y, 0,
X		XV_WIDTH, WIN_EXTEND_TO_EDGE,
X		XV_HEIGHT, WIN_EXTEND_TO_EDGE,
X		WIN_BORDER, FALSE,
X		NULL);
X	return obj;
}
X
/*
X * Create object `entry_type' in the specified instance.
X */
XXv_opaque
entry_entry_frame_entry_type_create(ip, owner)
X	entry_entry_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	extern void		change_entry_type();
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_CHOICE,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 42,
X		XV_Y, 13,
X		PANEL_CHOICE_NROWS, 1,
X		PANEL_LAYOUT, PANEL_HORIZONTAL,
X		PANEL_CHOOSE_NONE, FALSE,
X		PANEL_NOTIFY_PROC, change_entry_type,
X		PANEL_CHOICE_STRINGS,
X			"List Item",
X			"Category",
X			NULL,
X		NULL);
X	return obj;
}
X
/*
X * Create object `entry_category' in the specified instance.
X */
XXv_opaque
entry_entry_frame_entry_category_create(ip, owner)
X	entry_entry_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_CHOICE, PANEL_DISPLAY_LEVEL, PANEL_CURRENT,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 206,
X		XV_Y, 13,
X		PANEL_CHOICE_NROWS, 1,
X		PANEL_LAYOUT, PANEL_HORIZONTAL,
X		PANEL_LABEL_STRING, "Category:",
X		NULL);
X	return obj;
}
X
/*
X * Create object `recurring' in the specified instance.
X */
XXv_opaque
entry_entry_frame_recurring_create(ip, owner)
X	entry_entry_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	extern void		create_recurring();
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_BUTTON,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 429,
X		XV_Y, 15,
X		PANEL_LABEL_STRING, "Recurring...",
X		PANEL_NOTIFY_PROC, create_recurring,
X		NULL);
X	return obj;
}
X
/*
X * Create object `entry_text' in the specified instance.
X */
XXv_opaque
entry_entry_frame_entry_text_create(ip, owner)
X	entry_entry_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_TEXT,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 100,
X		XV_Y, 58,
X		PANEL_VALUE_DISPLAY_LENGTH, 40,
X		PANEL_VALUE_STORED_LENGTH, 80,
X		PANEL_LABEL_STRING, "Text:",
X		PANEL_LAYOUT, PANEL_HORIZONTAL,
X		PANEL_READ_ONLY, FALSE,
X		NULL);
X	return obj;
}
X
/*
X * Create object `entry_priority' in the specified instance.
X */
XXv_opaque
entry_entry_frame_entry_priority_create(ip, owner)
X	entry_entry_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_NUMERIC_TEXT,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 101,
X		XV_Y, 79,
X		PANEL_VALUE_DISPLAY_LENGTH, 1,
X		PANEL_VALUE_STORED_LENGTH, 80,
X		PANEL_LABEL_STRING, "Priority:",
X		PANEL_LAYOUT, PANEL_HORIZONTAL,
X		PANEL_MAX_VALUE, 9,
X		PANEL_MIN_VALUE, 1,
X		PANEL_VALUE, 5,
X		PANEL_READ_ONLY, FALSE,
X		NULL);
X	return obj;
}
X
/*
X * Create object `entry_cancel' in the specified instance.
X */
XXv_opaque
entry_entry_frame_entry_cancel_create(ip, owner)
X	entry_entry_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	extern void		close_create();
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_BUTTON,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 91,
X		XV_Y, 119,
X		PANEL_LABEL_STRING, "Cancel",
X		PANEL_NOTIFY_PROC, close_create,
X		NULL);
X	return obj;
}
X
/*
X * Create object `entry_done' in the specified instance.
X */
XXv_opaque
entry_entry_frame_entry_done_create(ip, owner)
X	entry_entry_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	extern void		create_it();
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_BUTTON,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 351,
X		XV_Y, 119,
X		PANEL_LABEL_STRING, "Done",
X		PANEL_NOTIFY_PROC, create_it,
X		NULL);
X	return obj;
}
X
SHAR_EOF
chmod 0644 entry_ui.c ||
echo 'restore of entry_ui.c failed'
Wc_c="`wc -c < 'entry_ui.c'`"
test 5824 -eq "$Wc_c" ||
	echo 'entry_ui.c: original size 5824, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= logedit_ui.c ==============
if test -f 'logedit_ui.c' -a X"$1" != X"-c"; then
	echo 'x - skipping logedit_ui.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting logedit_ui.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'logedit_ui.c' &&
/*
X * logedit_ui.c - User interface object initialization functions.
X * This file was generated by `gxv' from `logedit.G'.
X * DO NOT EDIT BY HAND.
X */
X
#include <stdio.h>
#include <sys/param.h>
#include <sys/types.h>
#include <xview/xview.h>
#include <xview/canvas.h>
#include <xview/panel.h>
#include <xview/scrollbar.h>
#include <xview/svrimage.h>
#include <xview/termsw.h>
#include <xview/text.h>
#include <xview/tty.h>
#include <xview/xv_xrect.h>
#include "logedit_ui.h"
X
/*
X * Initialize an instance of object `log_edit'.
X */
logedit_log_edit_objects *
logedit_log_edit_objects_initialize(ip, owner)
X	logedit_log_edit_objects	*ip;
X	Xv_opaque	owner;
{
X	if (!ip && !(ip = (logedit_log_edit_objects *) calloc(1, sizeof (logedit_log_edit_objects))))
X		return (logedit_log_edit_objects *) NULL;
X	if (!ip->log_edit)
X		ip->log_edit = logedit_log_edit_log_edit_create(ip, owner);
X	if (!ip->log_editor)
X		ip->log_editor = logedit_log_edit_log_editor_create(ip, ip->log_edit);
X	if (!ip->controls1)
X		ip->controls1 = logedit_log_edit_controls1_create(ip, ip->log_edit);
X	if (!ip->log_editor_cancel)
X		ip->log_editor_cancel = logedit_log_edit_log_editor_cancel_create(ip, ip->controls1);
X	if (!ip->log_editor_done)
X		ip->log_editor_done = logedit_log_edit_log_editor_done_create(ip, ip->controls1);
X	return ip;
}
X
/*
X * Create object `log_edit' in the specified instance.
X */
XXv_opaque
logedit_log_edit_log_edit_create(ip, owner)
X	logedit_log_edit_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, FRAME_CMD,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_WIDTH, 532,
X		XV_HEIGHT, 334,
X		XV_LABEL, "Edit Log Entry",
X		FRAME_SHOW_FOOTER, TRUE,
X		FRAME_SHOW_RESIZE_CORNER, TRUE,
X		FRAME_CMD_PUSHPIN_IN, FALSE,
X		NULL);
X	xv_set(xv_get(obj, FRAME_CMD_PANEL), WIN_SHOW, FALSE, NULL);
X	return obj;
}
X
/*
X * Create object `log_editor' in the specified instance.
X */
XXv_opaque
logedit_log_edit_log_editor_create(ip, owner)
X	logedit_log_edit_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, TEXTSW,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 0,
X		XV_Y, 0,
X		XV_WIDTH, WIN_EXTEND_TO_EDGE,
X		XV_HEIGHT, 291,
X		OPENWIN_SHOW_BORDERS, TRUE,
X		NULL);
X	return obj;
}
X
/*
X * Create object `controls1' in the specified instance.
X */
XXv_opaque
logedit_log_edit_controls1_create(ip, owner)
X	logedit_log_edit_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 0,
X		XV_Y, (int)xv_get(ip->log_editor, XV_Y) +
X		      (int)xv_get(ip->log_editor, XV_HEIGHT),
X		XV_WIDTH, WIN_EXTEND_TO_EDGE,
X		XV_HEIGHT, WIN_EXTEND_TO_EDGE,
X		WIN_BORDER, FALSE,
X		NULL);
X	return obj;
}
X
/*
X * Create object `log_editor_cancel' in the specified instance.
X */
XXv_opaque
logedit_log_edit_log_editor_cancel_create(ip, owner)
X	logedit_log_edit_objects	*ip;
X	Xv_opaque	owner;
{
X	extern void		cancel_log_edit();
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_BUTTON,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 123,
X		XV_Y, 13,
X		PANEL_LABEL_STRING, "Cancel",
X		PANEL_NOTIFY_PROC, cancel_log_edit,
X		NULL);
X	return obj;
}
X
/*
X * Create object `log_editor_done' in the specified instance.
X */
XXv_opaque
logedit_log_edit_log_editor_done_create(ip, owner)
X	logedit_log_edit_objects	*ip;
X	Xv_opaque	owner;
{
X	extern void		log_log_edit();
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_BUTTON,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 363,
X		XV_Y, 13,
X		PANEL_LABEL_STRING, "Done",
X		PANEL_NOTIFY_PROC, log_log_edit,
X		NULL);
X	return obj;
}
X
SHAR_EOF
chmod 0644 logedit_ui.c ||
echo 'restore of logedit_ui.c failed'
Wc_c="`wc -c < 'logedit_ui.c'`"
test 3472 -eq "$Wc_c" ||
	echo 'logedit_ui.c: original size 3472, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= logger.c ==============
if test -f 'logger.c' -a X"$1" != X"-c"; then
	echo 'x - skipping logger.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting logger.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'logger.c' &&
/*
X * $Id: logger.c,v 1.2 1992/07/28 12:04:52 jipping Exp $
X * **********************************************************************
X *
X *   Logger.c ==> Logging routines for XVTDL.
X *
X * ----------------------------------------------------------------------
X * Copyright (c) 1992 by Mike Jipping and Hope College
X *
X * Permission is granted to copy and distribute this file in modified or
X * unmodified form, for noncommercial use, provided (a) this copyright notice
X * is preserved, (b) no attempt is made to restrict redistribution of this
X * file, and (c) this file is not distributed as part of any collection whose
X * redistribution is restricted by a compilation copyright.
X * ----------------------------------------------------------------------
X *
X * Revision History:
X * $Log: logger.c,v $
X * Revision 1.2  1992/07/28  12:04:52  jipping
X * Added an unlink of temp log file with "%" attached.
X *
X * Revision 1.1  1992/07/27  18:38:29  jipping
X * Initial revision
X *
X *
X */
X
#include "globaldefs.h"
#include "logedit_ui.h"
X
int log_level, log_info_level;
char log_file[LINESIZ];
X
logedit_log_edit_objects	*logedit_log_edit;
X
/*
X ***********************************************************************
X *  A dummy routine to call a GUIDE initialize function for the 
X *  log editor.
X */
void initialize_log_editor()
{
X	logedit_log_edit = logedit_log_edit_objects_initialize(NULL, tdlist);
}
X
/*
X * **********************************************************************
X * This routines logs a day_entry structure in a way appropriate to 
X * the setting of "log_level" and "log_info_level".
X */
void log_entry (de)
struct day_entry *de;
{
X	FILE *logfd;
X	FILE *tmp;
X	char *temp_file;
X   struct timeval tv;
X
X	logfd = fopen(log_file, "a+");
X	if (logfd == NULL) {
X		fprintf(stderr, "Problems opening log file (%s) -- no log made\n", log_file);
X		return;
X	}
X
X   gettimeofday(&tv, 0);
X   tm = localtime(&tv.tv_sec);
X
X	if ((log_level == LOG_AT_QUIT) || (log_info_level == LOG_TIMESTAMP)) {
X		if (de->checked) {
X			fprintf(logfd, "%s...COMPLETED \"%s\"\n\n", asctime(tm), de->text);
X		} else {
X			fprintf(logfd, "%s...UNCHECKED \"%s\"\n\n", asctime(tm), de->text);
X		}
X		fclose(logfd);
X	} else {
X		if ( (temp_file = tempnam(NULL, "log")) == NULL) {
X			fprintf(stderr, "Unable to create temporary log file name\n");
X			return;
X		}
X		if ( (tmp = fopen(temp_file, "w")) == NULL) {
X			fprintf(stderr, "Unable to open temp file %s\n", temp_file);
X			free(temp_file);
X			return;
X		}
X		if (de->checked) {
X			fprintf(tmp, "%s...COMPLETED \"%s\"\n\n", asctime(tm), de->text);
X		} else {
X			fprintf(tmp, "%s...UNCHECKED \"%s\"\n\n", asctime(tm), de->text);
X		}
X		fclose(tmp);
X
X		xv_set(logedit_log_edit->log_editor_done, PANEL_CLIENT_DATA, logfd, 0);
X		xv_set(logedit_log_edit->log_editor, TEXTSW_FILE, temp_file, 0);
X		xv_set(logedit_log_edit->log_edit, XV_SHOW, TRUE, 0);
X	}
X
}
X
/*
X * **********************************************************************
X * Callback routine for the "Done" button on the log editor.  Logs the
X * comments into the log file.
X */
void log_log_edit(item, event)
Panel_item	item;
Event		*event;
{
X	logedit_log_edit_objects *ip =
X		(logedit_log_edit_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
X	FILE *logfd;
X
X	logfd = (FILE *)xv_get(ip->log_editor_done, PANEL_CLIENT_DATA);
X
X	textsw_save(ip->log_editor, 20, 20);
X	copyfile2(xv_get(ip->log_editor, TEXTSW_FILE), logfd);
X	fprintf(logfd, "\n");
X
X	fclose(logfd);
X	unlink(xv_get(ip->log_editor, TEXTSW_FILE));
X	unlink(strcat(xv_get(ip->log_editor, TEXTSW_FILE),"%"));
X	xv_set(logedit_log_edit->log_editor, TEXTSW_FILE, NULL, 0);
X	xv_set(logedit_log_edit->log_edit, XV_SHOW, FALSE, 0);
}
X
/*
X * **********************************************************************
X * Callback routine for the "cancel" button on the log editor.  Note that
X * we still log the message...just throw away any edits.
X */
void cancel_log_edit(item, event)
Panel_item	item;
Event		*event;
{
X	textsw_reset(logedit_log_edit->log_editor, 0, 0);
X	log_log_edit(item, event);
}
SHAR_EOF
chmod 0644 logger.c ||
echo 'restore of logger.c failed'
Wc_c="`wc -c < 'logger.c'`"
test 4019 -eq "$Wc_c" ||
	echo 'logger.c: original size 4019, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= main.c ==============
if test -f 'main.c' -a X"$1" != X"-c"; then
	echo 'x - skipping main.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting main.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'main.c' &&
/* $Id: main.c,v 3.0 1992/07/27 18:40:26 jipping Exp $
X *
X * **********************************************************************
X *
X *  Main program for Xvtdl.
X *
X *  This routine sets up parameters from the command line, parses the
X *  specified todo database, and creates the windows, and sits back 
X *  to gather events.
X *
X *  Copyright (c) 1992 by Mike Jipping and Hope College
X * 
X *  Permission is granted to copy and distribute this file in modified or
X *  unmodified form, for noncommercial use, provided (a) this copyright notice
X *  is preserved, (b) no attempt is made to restrict redistribution of this
X *  file, and (c) this file is not distributed as part of any collection whose
X *  redistribution is restricted by a compilation copyright.
X *
X *  Revision History:
X *
X *  $Log: main.c,v $
X * Revision 3.0  1992/07/27  18:40:26  jipping
X * Release 3.0 includes:
X * * changed from "version.h" to "patchlevel.h" for comp.windows.x
X * * check X resources through a call to "load_xdefaults"
X * * fixed timer initialization
X * * interpose a destroy function
X *
X * Revision 2.5  1992/07/16  16:16:35  jipping
X * Fixed a bug with the Printer resource when none is present.
SHAR_EOF
true || echo 'restore of main.c failed'
fi
echo 'End of  part 2'
echo 'File main.c is continued in part 3'
echo 3 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
