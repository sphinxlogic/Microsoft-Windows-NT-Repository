Newsgroups: comp.sources.x
Path: uunet!uunet!darwin.sura.net!mips!msi!dcmartin
From: jipping@cs.hope.edu (Mike Jipping)
Subject: v18i065: XVTDL 3.0, Part04/06
Message-ID: <1992Jul29.175100.15008@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
References: <csx-18i062-xvtdl-3.0@uunet.UU.NET>
Date: Wed, 29 Jul 1992 17:51:00 GMT
Approved: dcmartin@msi.com
Lines: 1818

Submitted-by: jipping@cs.hope.edu (Mike Jipping)
Posting-number: Volume 18, Issue 65
Archive-name: xvtdl-3.0/part04

#!/bin/sh
# this is part.04 (part 4 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file props_ui.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 4; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping props_ui.c'
else
echo 'x - continuing file props_ui.c'
sed 's/^X//' << 'SHAR_EOF' >> 'props_ui.c' &&
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 0,
X		XV_Y, 0,
X		XV_WIDTH, WIN_EXTEND_TO_EDGE,
X		XV_HEIGHT, 126,
X		WIN_BORDER, TRUE,
X		NULL);
X	return obj;
}
X
/*
X * Create object `logging_msg' in the specified instance.
X */
XXv_opaque
props_props_frame_logging_msg_create(ip, owner)
X	props_props_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_MESSAGE,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 8,
X		XV_Y, 8,
X		PANEL_LABEL_STRING, "Logging Info...",
X		PANEL_LABEL_BOLD, TRUE,
X		NULL);
X	return obj;
}
X
/*
X * Create object `log_preference' in the specified instance.
X */
XXv_opaque
props_props_frame_log_preference_create(ip, owner)
X	props_props_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	extern void		set_log_preference();
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_CHOICE,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 42,
X		XV_Y, 31,
X		PANEL_CHOICE_NROWS, 1,
X		PANEL_LAYOUT, PANEL_HORIZONTAL,
X		PANEL_CHOOSE_NONE, FALSE,
X		PANEL_LABEL_STRING, "Log Preference:",
X		PANEL_NOTIFY_PROC, set_log_preference,
X		PANEL_CHOICE_STRINGS,
X			"When Checked",
X			"At Quit/Propagation",
X			"Never",
X			NULL,
X		PANEL_VALUE, 2,
X		NULL);
X	return obj;
}
X
/*
X * Create object `log_info' in the specified instance.
X */
XXv_opaque
props_props_frame_log_info_create(ip, owner)
X	props_props_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_CHOICE,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 42,
X		XV_Y, 57,
X		PANEL_CHOICE_NROWS, 1,
X		PANEL_LAYOUT, PANEL_HORIZONTAL,
X		PANEL_CHOOSE_NONE, FALSE,
X		PANEL_LABEL_STRING, "Log Info:",
X		PANEL_CHOICE_STRINGS,
X			"Timestamp Only",
X			"User Specified",
X			NULL,
X		PANEL_INACTIVE, TRUE,
X		NULL);
X	return obj;
}
X
/*
X * Create object `log_filename' in the specified instance.
X */
XXv_opaque
props_props_frame_log_filename_create(ip, owner)
X	props_props_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_TEXT,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 42,
X		XV_Y, 91,
X		PANEL_VALUE_DISPLAY_LENGTH, 20,
X		PANEL_VALUE_STORED_LENGTH, 80,
X		PANEL_LABEL_STRING, "Log Filename:",
X		PANEL_LAYOUT, PANEL_HORIZONTAL,
X		PANEL_INACTIVE, TRUE,
X		PANEL_READ_ONLY, FALSE,
X		NULL);
X	return obj;
}
X
/*
X * Create object `other_panel' in the specified instance.
X */
XXv_opaque
props_props_frame_other_panel_create(ip, owner)
X	props_props_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 0,
X		XV_Y, 128,
X		XV_WIDTH, WIN_EXTEND_TO_EDGE,
X		XV_HEIGHT, 192,
X		WIN_BORDER, TRUE,
X		NULL);
X	return obj;
}
X
/*
X * Create object `other_msg' in the specified instance.
X */
XXv_opaque
props_props_frame_other_msg_create(ip, owner)
X	props_props_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_MESSAGE,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 8,
X		XV_Y, 8,
X		PANEL_LABEL_STRING, "Other Information...",
X		PANEL_LABEL_BOLD, TRUE,
X		NULL);
X	return obj;
}
X
/*
X * Create object `priority_direction' in the specified instance.
X */
XXv_opaque
props_props_frame_priority_direction_create(ip, owner)
X	props_props_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	Xv_opaque		priority_direction_image0;
X	static unsigned short	priority_direction_bits0[] = {
#include "bitmaps/1to9.pr"
X	};
X	Xv_opaque		priority_direction_image1;
X	static unsigned short	priority_direction_bits1[] = {
#include "bitmaps/9to1.pr"
X	};
X	
X	priority_direction_image0 = xv_create(XV_NULL, SERVER_IMAGE,
X		SERVER_IMAGE_DEPTH, 1,
X		SERVER_IMAGE_BITS, priority_direction_bits0,
X		XV_WIDTH, 48,
X		XV_HEIGHT, 48,
X		NULL);
X	priority_direction_image1 = xv_create(XV_NULL, SERVER_IMAGE,
X		SERVER_IMAGE_DEPTH, 1,
X		SERVER_IMAGE_BITS, priority_direction_bits1,
X		XV_WIDTH, 48,
X		XV_HEIGHT, 48,
X		NULL);
X	obj = xv_create(owner, PANEL_CHOICE,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 40,
X		XV_Y, 34,
X		PANEL_CHOICE_NROWS, 1,
X		PANEL_LAYOUT, PANEL_HORIZONTAL,
X		PANEL_CHOOSE_NONE, FALSE,
X		PANEL_LABEL_STRING, "Priority Preference:",
X		PANEL_CHOICE_IMAGES,
X			priority_direction_image0,
X			priority_direction_image1,
X			NULL,
X		PANEL_VALUE, 1,
X		NULL);
X	return obj;
}
X
/*
X * Create object `def_printer' in the specified instance.
X */
XXv_opaque
props_props_frame_def_printer_create(ip, owner)
X	props_props_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_TEXT,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 40,
X		XV_Y, 110,
X		PANEL_VALUE_DISPLAY_LENGTH, 8,
X		PANEL_VALUE_STORED_LENGTH, 25,
X		PANEL_LABEL_STRING, "Default Printer:",
X		PANEL_LAYOUT, PANEL_HORIZONTAL,
X		PANEL_READ_ONLY, FALSE,
X		NULL);
X	return obj;
}
X
/*
X * Create object `def_print_mode' in the specified instance.
X */
XXv_opaque
props_props_frame_def_print_mode_create(ip, owner)
X	props_props_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_CHOICE,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 40,
X		XV_Y, 142,
X		PANEL_CHOICE_NROWS, 1,
X		PANEL_LAYOUT, PANEL_HORIZONTAL,
X		PANEL_CHOOSE_NONE, FALSE,
X		PANEL_LABEL_STRING, "Default Printer Mode:",
X		PANEL_CHOICE_STRINGS,
X			"Normal",
X			"PostScript",
X			NULL,
X		NULL);
X	return obj;
}
X
/*
X * Create object `controls1' in the specified instance.
X */
XXv_opaque
props_props_frame_controls1_create(ip, owner)
X	props_props_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 0,
X		XV_Y, 323,
X		XV_WIDTH, WIN_EXTEND_TO_EDGE,
X		XV_HEIGHT, WIN_EXTEND_TO_EDGE,
X		WIN_BORDER, FALSE,
X		NULL);
X	return obj;
}
X
/*
X * Create object `done_button' in the specified instance.
X */
XXv_opaque
props_props_frame_done_button_create(ip, owner)
X	props_props_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	extern void		close_props();
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_BUTTON,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 352,
X		XV_Y, 12,
X		PANEL_LABEL_STRING, "Done",
X		PANEL_NOTIFY_PROC, close_props,
X		NULL);
X	return obj;
}
X
/*
X * Create object `reset_button' in the specified instance.
X */
XXv_opaque
props_props_frame_reset_button_create(ip, owner)
X	props_props_frame_objects	*ip;
X	Xv_opaque	owner;
{
X	extern void		reset_props();
X	Xv_opaque	obj;
X	
X	obj = xv_create(owner, PANEL_BUTTON,
X		XV_KEY_DATA, INSTANCE, ip,
X		XV_X, 109,
X		XV_Y, 13,
X		PANEL_LABEL_STRING, "Reset",
X		PANEL_NOTIFY_PROC, reset_props,
X		NULL);
X	return obj;
}
X
SHAR_EOF
echo 'File props_ui.c is complete' &&
chmod 0644 props_ui.c ||
echo 'restore of props_ui.c failed'
Wc_c="`wc -c < 'props_ui.c'`"
test 9258 -eq "$Wc_c" ||
	echo 'props_ui.c: original size 9258, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= recur.c ==============
if test -f 'recur.c' -a X"$1" != X"-c"; then
	echo 'x - skipping recur.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting recur.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'recur.c' &&
/*
X * $Id: recur.c,v 3.0 1992/07/27 18:43:46 jipping Exp $
X * **********************************************************************
X *
X * Recur.c --> routines for manipulating recurrence properties of todo
X *             list items.
X *
X * ----------------------------------------------------------------------
X * Copyright (c) 1992 by Mike Jipping and Hope College
X *
X * Permission is granted to copy and distribute this file in modified or
X * unmodified form, for noncommercial use, provided (a) this copyright notice
X * is preserved, (b) no attempt is made to restrict redistribution of this
X * file, and (c) this file is not distributed as part of any collection whose
X * redistribution is restricted by a compilation copyright.
X * ----------------------------------------------------------------------
X *
X * Revision History:
X *
X * $Log: recur.c,v $
X * Revision 3.0  1992/07/27  18:43:46  jipping
X * Release 3.0.  Fixed a bug that did not reassign head and tail vars
X * on list manipulation to the original categories.
X *
X * Revision 2.2  1992/07/16  13:38:02  jipping
X * Tweaked list management.
X *
X * Revision 2.1  1992/07/13  14:29:02  jipping
X * Cleaned up code to avoid compilation warnings.
X *
X * Revision 2.0  1992/07/06  15:55:28  jipping
X * Initial release.
X *
X *
X */
X
#include "globaldefs.h"
X
struct recurrence_list *rl_head, *rl_tail;
X
/*
X ***********************************************************************
X *  Utility routine that is used as a timestamp routine/
X */
int days_since_1990(month, day, year)
{
X	int days=0;
X	int count;
X
X	for (count=1990; count<year; count++) days += leapyear(count)?366:365;
X	for (count=1; count<month; count++)   days += daysinmonth(count, year);
X	days += day;
X
X	return(days);
}
X
/*
X * **********************************************************************
X * This routine is given a datecode and a recurrence specification and
X * returns a boolean value depicting whether that datecode matches 
X * the recurrence spec.  This is determined by starting date and 
X * recurrence property.
X */
int datecode_matches(datecode,rl)
int datecode;
struct recurrence_list *rl;
{
X	int curr_week, week_difference, dow, wks1, wks2;
X
X   /*
X    *  If the spec is DAILY -- it's always true!
X    */
X	if (rl->daily) return TRUE;
X
X   /*
X    * In order to check the rest, we must compute a few things...
X	 * namely, current day of week, current weeks-since-1990, the
X    * weeks-since-1990 for the starting date of the spec, and
X    * the difference between the week computation.
X    */
X	dow = zeller(curr_month, curr_day, curr_year);
X	curr_week = ((curr_day-
X					 (1+(dow - zeller(curr_month, 1, curr_year)))) / 7) + 1;
X	wks1 = days_since_1990((datecode-(datecode/10000)*10000)/100,
X								  datecode-(datecode/10000)*10000-(datecode-(datecode/10000)*10000)/100*100,
X								  datecode/10000+1990) / 7;
X	wks2 = days_since_1990((rl->starting_day_code-(rl->starting_day_code/10000)*10000)/100,
X								  rl->starting_day_code-(rl->starting_day_code/10000)*10000-(rl->starting_day_code-(rl->starting_day_code/10000)*10000)/100*100,
X								  rl->starting_day_code/10000+1990) / 7;
X	week_difference = wks1 - wks2;
X
X	/*
X    *  Check the rest of the possible recurrence properties.
X    */
X	if (rl->weekly & (week_difference < rl->number_of_weeks) &
X		 (week_difference >= 0) &
X		 ( (dow == rl->dow) | (rl->mwf & (dow == 1 | dow == 3 | dow == 5))
X		                    | (rl->tt  & (dow == 2 | dow == 4)) ) )
X		 return TRUE;
X
X	if (rl->monthly & (curr_week == rl->week_number) &
X		 ( (dow == rl->dow) | (rl->mwf & (dow == 1 | dow == 3 | dow == 5))
X		                    | (rl->tt  & (dow == 2 | dow == 4)) ) )
X		 return TRUE;
X		 
X	if (rl->yearly & (rl->starting_day_code % 10000 == datecode % 10000)) return TRUE;
X
X	/* if nothing matches.... */
X	return FALSE;
}
X
/*
X * **********************************************************************
X * Callback notify function for the "Recurring..." button.  Basically,
X * we set up the window widgets (for creating or editing).
X */
void choose_recurring()
{
X	int fre;
X
X	fre = xv_get(freq, PANEL_VALUE);
X	xv_set(day_of_week, PANEL_INACTIVE, TRUE, 0);
X	xv_set(weeks, PANEL_INACTIVE, TRUE, 0);
X	xv_set(week_of_month, PANEL_INACTIVE, TRUE, 0);
X	
X	switch (fre) {
X   	case 0:  /* daily -- no more action needed */
X	   case 1:
X		   break;
X		case 2:  /* weekly -- need dow and number of weeks */
X		case 3:
X			xv_set(day_of_week, PANEL_INACTIVE, FALSE, 0);
X			xv_set(weeks, PANEL_INACTIVE, FALSE, 0);
X			break;
X		case 4:  /* monthly -- need week of month and dow */
X			xv_set(day_of_week, PANEL_INACTIVE, FALSE, 0);
X			xv_set(week_of_month, PANEL_INACTIVE, FALSE, 0);
X			break;
X		case 5:  /* yearly -- no more action needed */
X			break;
X	}
}
X
/*
X * **********************************************************************
X * Callback notify function for the "Done" button in the recurrence
X * editor window.
X *
X * Here, we setup -- or destroy -- a recurrence record.  When we return,
X * the PANEL_CLIENT_DATA on the frequency item is set to TRUE if we have
X * left specifying a recurrence property or to FALSE if we have gone 
X * from a recurrence property to nothing.
X */
void close_recurring(item, event)
Panel_item item; 
Event      *event;
{
X	int frequency, dow, d, diff, diff2;
X	struct recurrence_list *tmprl;
X	struct recurrence_list *rl, *rlp;
X	int datecode, value;
X	struct category_rec *cr;
X
X	/*
X    *  Start by finding out the category we are specifying in...
X    */
X	value = xv_get(entry_category, PANEL_VALUE);
X	for (cr=category_head; cr!=NULL; cr=cr->next) {
X		if (EQUAL(xv_get(entry_category, PANEL_CHOICE_STRING, value), cr->name)) break;
X	}
X
X	/*
X    * We might be EDITING a recurrence property.  Find it if we can.
X    */
X	tmprl = NULL;
X	rlp = NULL;
X	datecode = (curr_year-1990)*10000 + curr_month*100 + curr_day;
X	for (rl = cr->rl_head; rl != NULL; rlp = rl, rl = rl->next) {
X		if (datecode_matches(datecode, rl)) {
X			if (EQUAL(xv_get(entry_text, PANEL_VALUE), rl->text)) {
X				tmprl = rl;
X				break;
X			}
X		}
X	}
X
X	/* 
X	 *  Now, start to set up the recurrence property, if we are creating
X    *  or editing.
X    */
X	frequency = xv_get(freq, PANEL_VALUE);
X	if (frequency > 0) {
X
X		/** Create a recurrence structure if we need to **/
X		if (tmprl == NULL) {
X			tmprl = NEW(struct recurrence_list);
X			if (cr->rl_head == NULL) {
X				cr->rl_head = cr->rl_tail = tmprl;
X			} else {
X				cr->rl_tail->next = tmprl;
X				cr->rl_tail = tmprl;
X			}
X		}
X
X		/*
X       *  If the category menu for the editing window is different 
X       *  than that for the main window, temporarily reset the proper
X       *  variables.
X       */
X		if (cr == (struct category_rec *)xv_get(categories, PANEL_CLIENT_DATA)) {
X			rl_head = cr->rl_head;
X			rl_tail = cr->rl_tail;
X		}
X		
X		/*
X       *  AND NOW...fill in the blanks of the recurrence structure
X       */
X		tmprl->starting_day_code = (curr_year-1990)*10000 + curr_month*100 + curr_day;
X      if ((frequency != 1) && (frequency != 5)) {
X			dow = zeller(curr_month, curr_day, curr_year);
X			d = xv_get(day_of_week, PANEL_VALUE);
X			if (d < 7) {
X				diff = d - dow;
X				if (diff < 0) diff = diff + 7;
X			} else if (dow = 7) {
X				diff = 2 - dow;
X				if (diff < 0) diff = diff + 7;
X				diff2 = 4 - dow;
X				if (diff2 < 0) diff2 = diff2 + 7;
X				if (diff > diff2) diff = diff2;
X			} else {
X				diff = 1 - dow;
X				if (diff < 0) diff = diff + 7;
X				diff2 = 3 - dow;
X				if (diff2 < 0) diff2 = diff2 + 7;
X				if (diff > diff2) diff = diff2;
X				diff2 = 5 - dow;
X				if (diff2 < 0) diff2 = diff2 + 7;
X				if (diff > diff2) diff = diff2;
X			}
X			tmprl->starting_day_code += diff;
X		}
X		tmprl->daily = tmprl->weekly = tmprl->biweekly = tmprl->monthly = tmprl->yearly = FALSE;
X		tmprl->dow = -1;
X		tmprl->mwf = tmprl->tt = FALSE;
X		tmprl->week_number = tmprl->number_of_weeks = 0;
X		tmprl->next = NULL;
X		
X		switch (frequency) {
X	      case 1:    /* daily */
X			   tmprl->daily = TRUE;
X		      break;
X
X		   case 2:  /* weekly -- need dow and number of weeks */
X				tmprl->weekly = TRUE;
X				tmprl->number_of_weeks = xv_get(weeks, PANEL_VALUE);
X				dow = xv_get(day_of_week, PANEL_VALUE);
X				if (dow == 7) {
X					tmprl->mwf = TRUE;
X				} else {
X					if (dow == 8) {
X						tmprl->tt = TRUE;
X					} else {
X						tmprl->dow = dow;
X					}
X				}
X				break;
X
X		   case 3:  /* biweekly */
X				tmprl->biweekly = TRUE;
X				tmprl->number_of_weeks = xv_get(weeks, PANEL_VALUE);
X				dow = xv_get(day_of_week, PANEL_VALUE);
X				if (dow == 7) {
X					tmprl->mwf = TRUE;
X				} else {
X					if (dow == 8) {
X						tmprl->tt = TRUE;
X					} else {
X						tmprl->dow = dow;
X					}
X				}
X				break;
X			case 4:  /* monthly -- need week of month and dow */
X				tmprl->monthly = TRUE;
X				tmprl->week_number = xv_get(week_of_month, PANEL_VALUE);
X				dow = xv_get(day_of_week, PANEL_VALUE);
X				if (dow == 7) {
X					tmprl->mwf = TRUE;
X				} else {
X					if (dow == 8) {
X						tmprl->tt = TRUE;
X					} else {
X						tmprl->dow = dow;
X					}
X				}
X				break;
X
X			case 5:  /* yearly -- no more action needed */
X				tmprl->yearly = TRUE;
X				break;
X		}
X		xv_set(freq, PANEL_CLIENT_DATA, TRUE, 0);
X
X	} else {
X      /*
X       * We are switching from recurring to non-recurring.
X       * Reset PANEL_CLIEBNT_DATA and destroy the recurrence structure
X       * if we need to.
X       */
X		xv_set(freq, PANEL_CLIENT_DATA, FALSE, 0);
X		if (tmprl != NULL) {  /* get rid of the RL (we went to NONE) */
X			if (rlp == NULL) {
X				cr->rl_head = tmprl->next;
X				if (cr->rl_tail == tmprl) cr->rl_tail = NULL;
X			} else {
X				rlp->next = tmprl->next;
X				if (cr->rl_tail == tmprl) cr->rl_tail = rlp;
X			}
X			free(tmprl);
X			if (cr == (struct category_rec *)xv_get(categories, PANEL_CLIENT_DATA)) {
X				rl_head = cr->rl_head;
X				rl_tail = cr->rl_tail;
X			}
X		}
X	}
X
X	/** Done!  Close the window **/
X	xv_set(recurring_frame, XV_SHOW, FALSE, 0);
X	xv_set(entry_frame, XV_SHOW, TRUE, 0);
}
SHAR_EOF
chmod 0644 recur.c ||
echo 'restore of recur.c failed'
Wc_c="`wc -c < 'recur.c'`"
test 9828 -eq "$Wc_c" ||
	echo 'recur.c: original size 9828, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xvtdl.man ==============
if test -f 'xvtdl.man' -a X"$1" != X"-c"; then
	echo 'x - skipping xvtdl.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xvtdl.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xvtdl.man' &&
.\" @(#)xvtdl.man	3.0 xvtdl version 7/28/92
.TH XVTDL 1 "28 July 1992"
.SH NAME
xvtdl \- A To Do List Manager Using the XView Toolkit
.SH SYNOPSIS
.B xvtdl
[
.I options
]
.\" ========================================================================
.SH DESCRIPTION
.LP
.B xvtdl
is a "to do" list manager that features multiple to do lists with items
that propagate through time (when not "checked off") and items that can 
be recurring in various time/calendar increments.  Multi-level logging
allows items to be logged in several modes when checked off or on.
Lists can be printed
to "regular" and PostScript printers.  In normal use,
.B xvtdl
can be started with the window system and left running (usually in an
iconic state), as it uses very
little CPU time and automatically propagates items at midnight every
night.  
.LP
.B xvtdl
uses the XView toolkit from Sun Microsystems to implement the OPEN LOOK 
graphical user interface.
.LP
Unless otherwise directed by the "-f" option, 
.B xvtdl
maintains a database of to do list items in the $HOME/.tododb file.
This database is in ASCII format and is written at various times
throughout its execution lifespan (e.g., whenever items are propagated or
when new items are added to a list).  
.\" ========================================================================
.SH OPTIONS
.LP
.TP
-f file
Use "file" instead of $HOME/.tododb
.\" ========================================================================
.SH USING XVTDL
.LP
When 
.B xvtdl
is started, there are three areas that will recognize events.  These are
the calendar area on the upper left, the control area above the to do
list, and the to do list itself.  
.LP
The calendar area will respond to any mouse click.  Clicking in the
calendar will move the current list to the date clicked on.  If the mouse
click is not on a number,
.B xvtdl
tries to deduce what date would be there if the previous or next months
numbers were displayed.
.LP
The control area has the following controls:
X
.RS
Left and Right arrow buttons:  
.RS
These move incrementally through the calendar.  Left moves back in time;
right moves forward in time.  Without any other keys down, the effect is
to move one day backward or forward.  With the control key down, the
increment is one week.  With the shift key pressed, the increment is one
month.  With the Meta key down, the increment is one year.
X
.RE
Category Menu:
.RS
This is a menu (bring it up with the right mouse button) containing all
the categories/todo lists that are in the database.  Selecting one from
this menu will display that particular list.
X
.RE
The "Create..." button:
.RS
This opens the entry window to create either new list items or new
categories.  See the description of the entry window below.
X
.RE
The "Edit" button:
.RS
This is a menu button that allows the following operations:
.RS
Modify
.RS
Select this menu item, then a list item on the list or a category from
the menu.  Selecting a list
item brings up the entry
window, with the items initialized by the list edit just selected.  The
attributes -- including the recurring properties -- can be changed and
the "Done" button will refresh the item with its new attributes.
Selecting a category name will allow the name to be changed when the
"Done" button is pressed.
.RE
Copy
.RS
Select this item, then a list item.  A copy of the list item is placed in
an edit buffer, ready for pasting.  One cannot copy categories.
.RE
Cut
.RS
After selecting this menu item, select either a list item or an item from
the category menu.  If you select a list item, that item is placed
in an edit buffer and deleted from the current list.  If you select a
category, that category is deleted from the menu (and made inaccessible).
.PP
.B Note
that there must be at least one category in the system at all times.
Starting 
.B xvtdl
with no database creates an empty category called "Every Day".  Likewise,
deleting the last category automatically creates the empty "Every Day"
category.  To get rid of the "Every Day" category, create another
category, then cut the "Every Day" category.
.RE
Paste
.RS
Selecting this menu item will insert the contents of the edit buffer into
the current list.  An error will be flagged if the edit buffer is empty.
.PP
Categories cannot be pasted.
.RE
Properties...
.RS
Selecting this menu item will pop up the properties window.  Use of this
window is detailed below.  Properties are used to manipulate the X
resources connected with this program.
.RE
.RE
X
.RE
The "Today" button:
.RS
This displays the current list for the current date.
X
.RE
The "List All" button:
.RS
This causes 
.B xvtdl
to display all list items from all categories in priority order on the
todo list.  When this list is displayed, it can be manipulated as a
"normal" list from a category.  Items may be checked off and on
-- the effect of this will be reflected in the category that item appears
in -- and the "global list" can be printed through the print window.
Selecting an option that redisplays a list (e.g., the "Today" button or a
new category selection) will revert the list back to normal displays.
.PP
Printing the global list works as it does with any other list, with one
exception.  The "Categories:" field is rendered inactive, because there
is only one list to print.  This field is activated again for other,
"normal" lists.
.PP
.B Note
that the category specifier does not change for the global list.  During
the time the global list is displayed, the indication in the category
item is incorrect.
X
.RE
The "Print..." button:
.RS
This opens the Print window for printing lists.  This window is detailed
below.  
X
.RE
The "Done" button:
.RS
This causes the program to update the todo database and close to an
iconic form.
.I This way is preferred 
for closing over using the window menu.
X
.RE
The "Quit" button:
.RS
This cause the program to terminate.
.RE
.RE
.LP
Creating and editing items and creating categories is done through the
entry window.  This window will pop up when the "Create..." button is
pressed or the edit mkenu item is selected.  This window is detailed
below.
X
.RS
The "List Item/Category" Selection:
.RS
For creation, you can create either list items or categories.  This
choice item lets the user to specify which object is being created.  For
editing, since only list items may edited, an error will be flagged if
the this choice item is specified as "Category".
X
.RE
Category Menu:
.RS
This menu, only active for list item creation, allows the user to select
the list category the newly created item will be placed into.
X
.RE
The "Recurring..." button:
.RS
This will pop up the recurrence editor, a window that lets the user
specify the recurrence properties of the item being created or edited.
The recurrence editor lets the user choose the frequency and length of
time that the item should recur.  Choosing "Done" in the recurrence
window will install the recurrence propoerties specified; choosing
"Cancel" will ignore the recurrence choices.
X
.RE
The "Text:" field:
.RS
This is the actual text of the to do list item.
X
.RE
The "Priority:" field:
.RS
This field specifies the priority of item being created/edited.  Highest
priority is 9; the lowest priority is 1 (in the current version).
X
.RE
The "Cancel" and "Done" buttons:
.RS
"Cancel" cancels the creation or editing operation, ignoring the settings
in the window.  "Done" completes the creation or editing operation,
installing the changes.  Both choices close the editing window.
.RE
.RE
.LP               
Printing lists is done through the print window.  Printing can be done in
a no-frills ASCII mode or in a PostScript mode.  Through this window, the
user must specify the printer name, the printing mode, and whether to
print checked off items.  If PostScript mode is selected, the user can
also specify the scaling factor on the printout (useful for insertion
into organizational notebooks/datebooks).  The user can print the current
categories or all categories by specifying the proper selection on the
"Categories" item.  The user can cancel or
complete the print action by selecting the appropriate buttons in the
window.  
.LP
Invoking the "Properties..." item in the edit menu will open the
properties window.  This window controls the X resources used to control
.B xvtdl
and will create and maintain a file in the user's home directory that
contains the resource specifications.  This file, called ".xvtdlrc", will
be automatically updated when the properties are updated.  The property
items work as follows:
X
.RS
Log Preference:
.RS
This specifies when to log an entry.  Choices are "When Checked", which
allow logging when the item is checked on or off, "At Quit/Propagation",
which logs a checked off item when the program propagates at midnight or
the program is terminated, or "Never", which disables logging.
X
.RE
Log Info:
.RS
This specifies the kind of information to occur in the log file.  This
can be either "Timestamp Only", which places a timestamp and the item
string in the file without user intervention, or "User Specified", which
constructs a minimal log entry and starts an editor containing that entry
that the user can use to customize it.  This editor window contains an
editor window and two buttons: "Cancel" will cancel any edits, entering
the original log entry in the log file, and "Done" will save any edits
made, entering the new version in the log file.
X
.RE
Log Filename:
.RS
This gives the name of the log file.  This is can be a relative or
absolute filename.
X
.RE
Priority Preference:
.RS
.B Note
that in version 3.0, this feature can be specified but is not
implemented.
.PP
This provides a way to customize what order the user wishes priorities to
be listed: either with high = 1 down to low = 9 or with high = 9 and low
= 1.  The default situation is the latter.
X
.RE
Default Printer:
.RS
This is the printer that will come up as the default in the print window.
It is specified here because changing the printer in the print window
does not manipulate the X resource.
X
.RE
Default Printer Mode:
.RS
This is the printer mode (normal or PostScript) that will come up as the
default in the print window. 
It is specified here because changing the printer in the print window
does not manipulate the X resource.
X
.RE
The "Reset" Button:
.RS
Pressing this button will cause the window to be reset with the current
setting of X resources.  
X
.RE
The "Done" Button:
.RS
This button causes the program to reset the X resources in the X resource
database for the user's display server and to write the values out to the
".xvtdlrc" file to be read next time the program is invoked.
.RE
.RE
.\" ========================================================================
.SH TO DO LIST DATABASE FORMAT
.LP
The database is an ASCII file oriented in a line-by-line manner.  Each
line represents either a category specification or a todo list item.
Category specifications are given as
.RS
.PP
category: "category name"
.PP
.RE
All entries up to the next category specification or the end of file
designate todo list items in the category listed.
.LP
To do list items are given in the form
.RS
.PP
date[|recurring-part]:priority:"list item text"
.PP
.RE
The "date" is given in mm/dd/yy format.  The recurring part is optional
and is specified by a string of characters:
.RS
.PP
one of "d", "w", "b", "m", or "y" to indicate daily, weekly,
biweekly, monthly, or yearly repitition.
.PP
if weekly or biweekly, this is followed by "M", "T", or "D" with a number 0-6,
indicating Monday/Wednesday/Friday, Tuesday/Thursday, or a specific day
of the week (0 = Sunday) 
.PP
if weekly or biweekly, this is followed by a "W" and a number, indicating
the number of weeks this item is to repeat
.PP
if monthly, a "N" and a number is concatenated to indication the week
number in the month to repeat the item
.RE
.LP
The priority part is an integer from 1-9.  
.\" ==========================================================================
.SH RESOURCES TO CONTROL XVTDL
.LP
There are currently two resources added to the resource database that
.B xvtdl
looks for.  They are
.LP
.TP
Printer
a string which specifies the default printer to use in the print window
.TP
PostScript
a boolean resource specifying whether to initialize the print window to
use PostScript mode.
.TP
Logging
a boolean resource specifying whether to log list item activity
.TP
LogPreference
a string resource that can contain two values: "atchecked" indicates that
logging should occur when an item is checked off or on, "atquit"
indicates that logging should occur at propagation or termination of the
program 
.TP
LogInfoPreference
a string resource that can contain one of two values: "timestamp"
indicates only timestamps are to be logged in the log file, "userspec"
indicates that the user is to specify the contents of the log entry
.TP
LogFileName
a string resource giving the name of the log file
.TP
PriorityListing
a string resource that can be either "ascending" or "descending",
indicating which direction, high to low, the priorities should be listed
.\" ========================================================================
.SH COPYRIGHTS
.LP
The X Window system is a trademark of the Massachusetts Institute of
Technology.
.br
OPEN LOOK is a trademark of AT&T.
.br
OpenWindows is a trademark of Sun Microsystems, Inc.
.br
Portions not covered under the above copyrights are (c) 1992 by Mike
Jipping and Hope College.
.br
Please see the COPYRIGHT file for full disclosure of copyright
information.
.\" =======================================================================
.SH FILES 
.LP
.TP
$HOME/.tododb
This is the default to do list database.
.TP
$HOME/.xvtdlrc
This file holds the X resources required to control this program.  It is
created and maintained through the property window.
.TP
/tmp/xvtdl*
When printing, this temporary file is used to store the list prior to
sending to the printer.
.TP
/tmp/log*
When logging, this temporary file is used to store the log entry prior to
editing by the user.
.\" =======================================================================
.SH SEE ALSO
cm(1) 
.\" =======================================================================
.SH AUTHOR
.LP
The 
.B xvtdl
program was written by Mike Jipping, Hope College Department of Computer
Science.  All comments, praises, bug reports, and flames should be sent
to him at "jipping@cs.hope.edu".  He'll at least read your message.
.\" =======================================================================
.SH KNOWN BUGS
.LP
There are currently no known aspects of the program that corrupt the data
or crash the program.
.LP
There are some annoying bugs. If a category name is
very long, the right arrow button will be partially obscured even if a
short category name is displayed.  
SHAR_EOF
chmod 0644 xvtdl.man ||
echo 'restore of xvtdl.man failed'
Wc_c="`wc -c < 'xvtdl.man'`"
test 14810 -eq "$Wc_c" ||
	echo 'xvtdl.man: original size 14810, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= control.c ==============
if test -f 'control.c' -a X"$1" != X"-c"; then
	echo 'x - skipping control.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting control.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'control.c' &&
/*
X * $Id: control.c,v 3.0 1992/07/27 18:30:59 jipping Exp $
X *
X *   Control.c ==> Routines that focus on window system interaction.
X *
X *   In reality, this file is WAY TOO LARGE.  But it contains all window
X *   reaction routines/callbacks.  
X *
X * ----------------------------------------------------------------------
X * Copyright (c) 1992 by Mike Jipping and Hope College
X *
X * Permission is granted to copy and distribute this file in modified or
X * unmodified form, for noncommercial use, provided (a) this copyright notice
X * is preserved, (b) no attempt is made to restrict redistribution of this
X * file, and (c) this file is not distributed as part of any collection whose
X * redistribution is restricted by a compilation copyright.
X * ----------------------------------------------------------------------
X *
X * Revision History:
X *
X * $Log: control.c,v $
X * Revision 3.0  1992/07/27  18:30:59  jipping
X * Release 3.0 changes:
X * corrected pinning behavior (removed calls to make FRAME_CMD_PUSHPIN_IN
X * FALSE)
X * * corrected many list management bugs
X * * added callbacks to list all categories
X * * added traps for the "Quit" from window menu
X * * added callback for "Done" button (close_tdlist)
X *
X * Revision 2.6  1992/07/16  13:30:24  jipping
X * Enabled the editing and deletion of categories through
X * modifications to edit_it and switch_category
X *
X * Revision 2.5  1992/07/14  12:32:04  jipping
X * Eliminated callback for the text item in entry window.
X *
X * Revision 2.4  1992/07/13  17:03:34  jipping
X * More cleanup.  Nicer code in several spots.
X *
X * Revision 2.3  1992/07/13  15:52:22  jipping
X * Added a notify proc for the base window to allow resizing of todo
X * list when window is resized.
X *
X * Revision 2.2  1992/07/13  13:44:27  jipping
X * Fixed a 50-character display limit bug,
X *
X * Revision 2.0.1.1  1992/07/10  17:47:18  jipping
X * Attempted (without success) to squelch the bug where the edit window
X * does not disappear with first Return on entry text.
X *
X * Revision 2.0  1992/07/10  16:43:11  jipping
X * Initial Release.
X *
X *
X */
X
#include "globaldefs.h"
X
void edit_it();
struct entry_list *entry_search();
extern Panel tdl_list;
X
int editing=FALSE, copying=FALSE, cutting=FALSE;
X	
/*
X *  go_forward -- move ahead the required number of days, depending on 
X *                whether the control or shift keys are pressed. 
X *
X *  Called from the "right arrow" button.
X */
X
void go_forward(item, event)
Panel_item item; 
Event      *event;
{
X	if (event_shift_is_down(event)) {  /* move ahead a month */
X		curr_month = (curr_month+1) % 12;
X      if (curr_month == 0) curr_month = 12;
X		if (curr_month == 1) curr_year++;
X
X	} else if (event_ctrl_is_down(event)) {  /* move ahead a week */
X		curr_day += 7;
X		if (curr_day > daysinmonth(curr_month, curr_year)) {
X			curr_day = curr_day - daysinmonth(curr_month, curr_year);
X			curr_month = (curr_month+1) % 12;
X			if (curr_month == 0) curr_month = 12;
X			if (curr_month == 1) curr_year++;
X		}
X
X	} else if (event_meta_is_down(event)) {  /* move ahead a year */
X		curr_year++;
X
X	} else {      /* only move ahead a day */
X		if ((curr_month == 12) & (curr_day == 31)) {
X			curr_year ++;
X			curr_day = curr_month = 1;
X		} else if (curr_day < daysinmonth(curr_month, curr_year)) {
X			curr_day ++;
X		} else {
X			curr_month ++;
X			curr_day = 1;
X		}
X	}
X
X	print_calendar(curr_month, curr_year);
X	reset_date_message();
X	display_list(curr_month, curr_day, curr_year);
}
X
/*
X *  go_backward -- move ahead the required number of days, depending on 
X *                 whether the control or shift keys are pressed. 
X *
X *  Called from the "left arrow" button.
X */
X
void go_backward(item, event)
Panel_item item; 
Event      *event;
{
X	if (event_shift_is_down(event)) {  /* month */
X		curr_month = (curr_month-1) % 12;
X      if (curr_month == 0) {
X			curr_month = 12;
X			curr_year --;
X		}
X	} else if (event_ctrl_is_down(event)) {  /* week */
X		curr_day -= 7;
X		if (curr_day <= 0) {
X			curr_month = (curr_month-1) % 12;
X			if (curr_month == 0) {
X				curr_month = 12;
X				curr_year --;
X			}
X			curr_day = curr_day + daysinmonth(curr_month, curr_year);
X		}
X	} else if (event_meta_is_down(event)) {  /* year */
X		curr_year--;
X	} else {  /* daily */
X		if ((curr_month == 1) & (curr_day == 1)) {
X			curr_year --;
X			curr_day = 31;
X			curr_month = 12;
X		} else if (curr_day > 1) {
X			curr_day --;
X		} else {
X			curr_month --;
X			curr_day = daysinmonth(curr_month, curr_year);
X		}
X	}
X	print_calendar(curr_month, curr_year);
X	reset_date_message();
X	display_list(curr_month, curr_day, curr_year);
}
X
/*
X * go_today -- Go to the current (real) date.
X *
X * Connected to the "Today" button.
X */
void go_today(item, event)
Panel_item item; 
Event      *event;
{
X   curr_month = today.tm_mon+1;
X   curr_day = today.tm_mday;
X   curr_year = today.tm_year+1900;
X	
X	print_calendar(curr_month, curr_year);
X	reset_date_message();
X	display_list(curr_month, curr_day, curr_year);
}
X
/*
X * **********************************************************************
X * Utility routine...copying the contents of the file denoted by "str"
X * into the file denoted by the descriptor "fd".
X */
X
void copyfile2(str, fd)
char *str;
FILE *fd;
{
X	FILE    *spfp;
X	char    t;
X	
X	if((spfp=fopen(str,"r")) == NULL) {
X		fprintf(stderr,"Unable to open file %s\n",str);
X		return;
X	}
X	while ((t=getc(spfp)) != EOF ) {
X		putc(t, fd);
X	}
X	fclose(spfp);
}
X
/*
X * **********************************************************************
X * Closes the create/edit window.  Called from the "Cancel" button.
X */
X
void close_create(item, event)
Panel_item item; 
Event      *event;
{
X	xv_set(entry_text, PANEL_VALUE, "", 0);
X	xv_set(entry_frame,
X			 XV_SHOW, FALSE,
X			 0);
X	editing = FALSE;
}
X
/*
X * **********************************************************************
X * Closes the create/edit window and creates the item whose description
X * is given.  Called from the "Done" button.
X */
void create_it(item, event)
Panel_item item; 
Event      *event;
{
X	char text[LINESIZ];
X	struct category_rec *cr, *currcr;
X	int value, priority;
X
X	strcpy(text, xv_get(entry_text, PANEL_VALUE));
X	priority = xv_get(entry_editor->entry_priority, PANEL_VALUE);
X	if (xv_get(entry_type, PANEL_VALUE) == 0) {
X		value = xv_get(entry_category, PANEL_VALUE);
X		for (cr=category_head; cr!=NULL; cr=cr->next) {
X			if (EQUAL(xv_get(entry_category, PANEL_CHOICE_STRING, value), cr->name)) break;
X		}
X		if ((int)xv_get(freq, PANEL_CLIENT_DATA)) {
X			strcpy(cr->rl_tail->text, text);
X			cr->rl_tail->priority = priority;
X		} else {
X			entry_head = cr->entry_head;
X			entry_tail = cr->entry_tail;
X			add_to(cr, curr_month, curr_day, curr_year, text, priority);
X			cr = (struct category_rec *)xv_get(categories, PANEL_CLIENT_DATA);
X			entry_head = cr->entry_head;
X			entry_tail = cr->entry_tail;
X		}
X		display_list(curr_month, curr_day, curr_year);
X	} else {
X		new_category(text);
X	}
X	xv_set(entry_text, PANEL_VALUE, "", 0);
X	xv_set(entry_frame,
X			 XV_SHOW, FALSE,
X			 0);
X	refresh_db(FALSE);
X	changed = TRUE;
}
X
/*
X * **********************************************************************
X * Called from the "Create..." button, this routine clears the entry
X * window, then opens it.
X */
void create(item, event)
Panel_item item; 
Event      *event;
{
X	int choice, choices;
X	struct category_rec *cr;
X
X	xv_set(entry_category, PANEL_CHOICE_STRINGS, "", 0, 0);
X
X	for (choice=0,cr=category_head; cr!=NULL; choice++,cr=cr->next) {
X		xv_set(entry_category, PANEL_CHOICE_STRING, choice, cr->name, 0);
X	}
X	xv_set(entry_category, PANEL_VALUE, xv_get(categories, PANEL_VALUE), 0);
X	xv_set(freq, PANEL_CLIENT_DATA, FALSE, 0);
X	xv_set(entry_done, PANEL_NOTIFY_PROC, create_it, 0);
X	xv_set(entry_frame,
X			 XV_SHOW, TRUE,
X			 0);
}
X
/*
X * **********************************************************************
X * Called from the "Done" button in the create/edit window (the edit
X * setup changes the NOTIFY procedure).  Simply replaces the information
X * in the appropriate fields.
X */
void edit_it(item, event)
Panel_item item; 
Event      *event;
{
X	char text[LINESIZ];
X	int si, datecode, priority;
X	struct day_entry *de, *tde, pde, *trl, *prl;
X	struct entry_list *el;
X	struct category_rec *cr;
X
X	strcpy(text, xv_get(entry_text, PANEL_VALUE));
X
X	if (xv_get(entry_type, PANEL_VALUE) == 0) {
X		priority = xv_get(entry_editor->entry_priority, PANEL_VALUE);
X		si = xv_get(entry_done, PANEL_CLIENT_DATA);
X		de = (struct day_entry *)xv_get(todo, PANEL_LIST_CLIENT_DATA, si);
X		
X		if ((int)xv_get(freq, PANEL_CLIENT_DATA)) {
X			strcpy(rl_tail->text, text);
X			rl_tail->priority = priority;
X			if (de->prev != NULL) {
X				if (de->next != NULL) de->next->prev = de->prev;
X				de->prev->next = de->next;
X				free(de);
X			} else {
X				if (de->next != NULL) de->next->prev = NULL;
X				datecode = (curr_year-1990)*10000 + curr_month*100 + curr_day;
X				el = entry_search(datecode, FALSE, NULL);
X				if (de->recurring_entry) {
X					el->rl_first = de->next;
X					if (el->rl_last == de) el->rl_last = NULL;
X				} else {
X					el->first = de->next;
X					if (el->last == de) el->last = NULL;
X				}
X			}
X		} else {
X			strcpy(de->text, text);
X			de->priority = priority;
X			if (de->recurring_entry) {  /* i.e., reverting to non-recurring */
X				datecode = (curr_year-1990)*10000 + curr_month*100 + curr_day;
X				el = entry_search(datecode, FALSE, NULL);
X				
X				/* remove from RL list */
X				prl = NULL;
X				for (trl = el->rl_first; trl != NULL; prl = trl,trl = trl->next) 
X					if (trl == de) break;
X				if (prl == NULL) {
X					el->rl_first = de->next;
X				} else {
X					prl->next = de->next;
X				}
X				if (de->next != NULL) de->next->prev = de->prev;
X				if (el->rl_last == de) el->rl_last = NULL;
X				
X				/* add to regular day entry list */
X				if (el->last == NULL) {
X					el->first = el->last = de;
X					de->prev = de->next = NULL;
X				} else {
X				   el->last->next = de;
X					de->prev = el->last;
X					de->next = NULL;
X					el->last = de;
X				}
X				de->recurring_entry = FALSE;
X			}
X			xv_set(entry_editor->entry_priority, PANEL_VALUE, 5, 0);
X			xv_set(entry_category, PANEL_INACTIVE, FALSE, 0);
X		}
X	} else {
X		cr = (struct category_rec *)xv_get(item, PANEL_CLIENT_DATA);
X		for (si=0;
X			  si<xv_get(xv_get(categories, PANEL_ITEM_MENU), MENU_NITEMS);
X			  si++)
X			if (EQUAL((char *)xv_get(categories, PANEL_CHOICE_STRING, si),cr->name))
X				break;
X		xv_set(categories, PANEL_CHOICE_STRING, si, text, 0);
X		strcpy(cr->name, text);
X	}
X
X	xv_set(entry_text, PANEL_VALUE, "", 0);
X	xv_set(entry_frame,
X			 XV_SHOW, FALSE,
X			 0);
X
X	display_list(curr_month, curr_day, curr_year);
X	refresh_db(FALSE);
X	editing = FALSE;
}
X
/*
X * Menu handler for the Edit/Modify menu item
X */
Menu_item
edit(item, op)
X	Menu_item	item;
X	Menu_generate	op;
{
X	switch (op) {
X	case MENU_DISPLAY:
X		break;
X
X	case MENU_DISPLAY_DONE:
X		break;
X
X	case MENU_NOTIFY:
X		editing = TRUE;
X		copying = FALSE;
X		cutting = FALSE;
X		set_cursor(edit_cursor);
X		break;
X
X	case MENU_NOTIFY_DONE:
X		break;
X	}
X	return item;
}
X
/*
X * Menu handler for the Edit/Copy menu item
X */
Menu_item
copy(item, op)
X	Menu_item	item;
X	Menu_generate	op;
{
X	switch (op) {
X	case MENU_DISPLAY:
X		break;
X
X	case MENU_DISPLAY_DONE:
X		break;
X
X	case MENU_NOTIFY:
X		editing = FALSE;
X		copying = TRUE;
X		cutting = FALSE;
X		set_cursor(copy_cursor);
X		break;
X
X	case MENU_NOTIFY_DONE:
X		break;
X	}
X	return item;
}
X
/*
X * Menu handler for the Edit/Cut menu item
X */
Menu_item
cut(item, op)
X	Menu_item	item;
X	Menu_generate	op;
{
X	switch (op) {
X	case MENU_DISPLAY:
X		break;
X
X	case MENU_DISPLAY_DONE:
X		break;
X
X	case MENU_NOTIFY:
X		editing = FALSE;
X		copying = FALSE;
X		cutting = TRUE;
X		set_cursor(cut_cursor);
X		break;
X
X	case MENU_NOTIFY_DONE:
X		break;
X	}
X	return item;
}
X
/*
X * Menu handler for the Edit/Paste menu item
X */
Menu_item
paste(item, op)
X	Menu_item	item;
X	Menu_generate	op;
{
X	switch (op) {
X	case MENU_DISPLAY:
X		break;
X
X	case MENU_DISPLAY_DONE:
X		break;
X
X	case MENU_NOTIFY:
X		paste_selection();
X		break;
X
X	case MENU_NOTIFY_DONE:
X		break;
X	}
X	return item;
}
X
/*
X * **********************************************************************
X * Start up the recurring editor on a new entry.  Called from the 
X * "Recurring..." button
X */
X	
void create_recurring(item, event)
Panel_item item; 
Event      *event;
{
X	xv_set(freq, PANEL_CLIENT_DATA, FALSE, 0);
X	xv_set(recurring_frame, XV_SHOW, TRUE, 0);
}
X
/*
X * **********************************************************************
X * Close up the recurring editor.  Called from the "cancel" button.
X */
void cancel_recurring(item, event)
Panel_item item; 
Event      *event;
{
X	xv_set(recurring_frame, XV_SHOW, FALSE, 0);
X	xv_set(entry_frame, XV_SHOW, TRUE, 0);
}
X
/*
X * **********************************************************************
X * Switch OR CUT categories here!  We need to look up which category was
X * chosen, then find it.  If cutting mode is on, then we cut the category
X * and adjust the menu.  If not, we simply display the new category.
X */
void choose_new_category (item, value, event)
Panel_item item;
int value;
Event *event;
{
X	int i, pos;
X	Menu cm;
X	struct category_rec *cr, *pcr, *currcr;
X	struct entry_list *currel, *prevel;
X	struct recurrence_list *currrl, *prevrl;
X
X	/* 
X	 *  Find the category.
X    */
X	pcr = NULL;
X	cr = category_head;
X	for (i=0; i<value; i++) {pcr = cr; cr = cr->next;}
X
X	/*
X    *  We need to edit this thing.  So set up the edit window accordingly.
X    */
X	if (editing) {
X		xv_set(entry_text, PANEL_VALUE, cr->name, 0);
X		xv_set(entry_type, PANEL_VALUE, 1, 0);
X		xv_set(entry_category, PANEL_INACTIVE, TRUE, 0);
X		xv_set(recurring, PANEL_INACTIVE, TRUE, 0);
X		xv_set(entry_editor->entry_priority, PANEL_INACTIVE, TRUE, 0);
X		xv_set(entry_done,
X				 PANEL_NOTIFY_PROC, edit_it,
X				 PANEL_CLIENT_DATA, cr,
X				 0);
X
X		set_cursor(basic_cursor);
X		
X		xv_set(entry_frame,
X				 XV_SHOW, TRUE,
X				 0);
X
X	/*
X    *  We need to cut this thing.  So (1) cut it from the category list,
X    *  (2) rebuild the category menu, and (3) free the data structure.
X    */
X	} else if (cutting) {
X		currcr = (struct category_rec *)xv_get(categories, PANEL_CLIENT_DATA);
X		if (pcr == NULL) {
X			category_head = cr->next;
X		} else {
X			pcr->next = cr->next;
X		}
X
X		/*  If the category cut is the one displayed, display another one! */
X		if ((struct category_rec *)xv_get(categories, PANEL_CLIENT_DATA) == cr) {
X			if (cr->next == NULL) {
X				category_head = (struct category_rec *)new_category("Every Day");
X				entry_head = category_head->entry_head;
X				entry_tail = category_head->entry_tail;
X				rl_head = category_head->rl_head;
X				rl_tail = category_head->rl_tail;
X				display_list(curr_month, curr_day, curr_year);
X			} else {
X				entry_head = cr->next->entry_head;
X				entry_tail = cr->next->entry_tail;
X				rl_head = cr->next->rl_head;
X				rl_tail = cr->next->rl_tail;
X				xv_set(categories,
X						 PANEL_CLIENT_DATA, cr->next,
X						 0);
X				display_list(curr_month, curr_day, curr_year);
X			}
X		}
X
X		/* rebuild the menu */
X		xv_set(categories, PANEL_CHOICE_STRINGS, category_head->name, 0, NULL);
X		pos = 1;
X		for (pcr = category_head->next; pcr != NULL; pcr = pcr->next)
X			xv_set(categories,
X					 PANEL_CHOICE_STRING, pos++, pcr->name,
X					 0);
X
X		/* free the data structure. */
X		prevel = NULL;
X		for (currel=cr->entry_head;
X			  currel != NULL;
X			  prevel=currel,currel=currel->next,free(prevel));
X		prevrl = NULL;
X		for (currrl=cr->rl_head;
X			  currrl != NULL;
X			  prevrl=currrl,currrl=currrl->next,free(prevrl));
X		free(cr);
X		
X		/* clean up */
X		cutting = FALSE;
X		set_cursor(basic_cursor);
X	} else {
X		entry_head = cr->entry_head;
X		entry_tail = cr->entry_tail;
X		rl_head = cr->rl_head;
X		rl_tail = cr->rl_tail;
X		xv_set(categories,
X				 PANEL_CLIENT_DATA, cr,
X				 0);
X		xv_set(print_print_base->categories, PANEL_INACTIVE, FALSE, 0);
X		display_list(curr_month, curr_day, curr_year);
X	}
X	
}
X
/*
X * **********************************************************************
X * Switch from specifying list items to specifying categories and back.
X */
void change_entry_type (item, value, event)
Panel_item item;
int value;
Event *event;
{
X	if (value == 0) {
X		xv_set(entry_category, PANEL_INACTIVE, FALSE, 0);
X		xv_set(recurring, PANEL_INACTIVE, FALSE, 0);
X		xv_set(entry_editor->entry_priority, PANEL_INACTIVE, FALSE, 0);
X	} else {
X		if (editing) {
X         notice_prompt(tdlist, NULL,
X							  NOTICE_MESSAGE_STRINGS,
X							     "You cannot switch modes",
X							     "while editing.",
X							     0,
X							  NOTICE_BUTTON, "Ok", 1,
SHAR_EOF
true || echo 'restore of control.c failed'
fi
echo 'End of  part 4'
echo 'File control.c is continued in part 5'
echo 5 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
