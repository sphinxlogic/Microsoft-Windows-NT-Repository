Newsgroups: comp.sources.x
Path: uunet!gatech!darwin.sura.net!mips!msi!dcmartin
From: bri@ukc.ac.uk
Subject: v18i081: bricons - iconic command panel, Part01/02
Message-ID: <csx-18i081-bricons-1.0@uunet.UU.NET>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Date: Mon, 3 Aug 1992 19:20:36 GMT
Approved: dcmartin@msi.com
Lines: 1897

Submitted-by: bri@ukc.ac.uk
Posting-number: Volume 18, Issue 81
Archive-name: bricons-1.0/part01

	The bricons program allows the user to start up applications 
	from a configured command panel on a workstation display 
	running X.  The bricons interface can consist of up to sixteen
	buttons which can display some text or an icon. Each button is 
	used to execute a shell command using the Bourne shell.
	Each button can be configured to display a single spring 
	loaded popup menu with up to ten more buttons.

#!/bin/sh
# This is a shell archive (produced by shar 3.50)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 08/03/1992 16:40 UTC by dcmartin@fascet
# Source directory /home/fascet/dcmartin/csx/src/bricons
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#    511 -rw-r--r-- Imakefile
#    635 -rw-r--r-- Makefile.std
#    342 -rw-r--r-- Xbricons
#    440 -rw-r--r-- .briconsrc
#   6754 -rw-r--r-- bricons.l
#   8068 -rw-r--r-- bricons.txt
#   1515 -rwxr-xr-x README
#   1802 -rw-r--r-- gen.h
#     22 -rw-r--r-- patchlevel.h
#   1066 -rw-r--r-- trans.h
#    162 -rw-r--r-- widgets.h
#   4594 -rw-r--r-- action.c
#  10097 -rw-r--r-- buttons.c
#   2863 -rw-r--r-- gen.c
#   7959 -rw-r--r-- main.c
#   7867 -rw-r--r-- parser.c
#   2378 -rw-r--r-- bitmaps/help
#   1871 -rw-r--r-- bitmaps/calander
#   1883 -rw-r--r-- bitmaps/letters
#   1965 -rw-r--r-- bitmaps/dclock
#   2256 -rw-r--r-- bitmaps/dragon
#   2256 -rw-r--r-- bitmaps/games
#    875 -rw-r--r-- bitmaps/load
#   1748 -rw-r--r-- bitmaps/readNews
#  10825 -rw-r--r-- Makefile
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= Imakefile ==============
if test -f 'Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Imakefile' &&
/**/# static char* sccs_imake = "%W%%G%";
/**/# Imakefile,v 1 25 June 1991
/**/#
/**/# MTI: Build srcs
/**/#
/**/# #include "/s/bri/Xstuff/Xukc.tmpl"
/**/# #define PassCDebugFlags
X
X        DEPLIBS = XawClientDepLibs
LOCAL_LIBRARIES = XawClientLibs
X
SRCS =  main.c \
X	action.c \
X	buttons.c \
X	gen.c \
X	parser.c \
X	gen.h \
X	trans.h \
X	widgets.h
X
OBJS =  main.o \
X	buttons.o \
X	action.o \
X	parser.o \
X	gen.o 
X
X
TARGET = bricons 
INSTALLBIN = /s/bri/bin/mbins/$Mbin
X
ComplexProgramTarget($(TARGET))
X
DependTarget()
SHAR_EOF
chmod 0644 Imakefile ||
echo 'restore of Imakefile failed'
Wc_c="`wc -c < 'Imakefile'`"
test 511 -eq "$Wc_c" ||
	echo 'Imakefile: original size 511, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile.std ==============
if test -f 'Makefile.std' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile.std (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile.std (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile.std' &&
X
OBJS=main.o gen.o action.o buttons.o parser.o
X
#CC=gcc
CC=cc
#CFLAGS= -ansi -pedantic
CFLAGS= -g
#CFLAGS= -O2
X
LIBS= -lXaw -lXmu -lXt -lXext -lX11 
X
TARGET= bricons
X
X
all:	$(OBJS)
X	$(CC) $(CFLAGS) -o $(TARGET) $(OBJS) $(LIBS)
X
main.o:		gen.h widgets.h trans.h main.c
X		$(CC) $(CFLAGS) -c main.c
X
gen.o:		gen.h gen.c
X		$(CC) $(CFLAGS) -c gen.c
X
action.o:	gen.h widgets.h action.c
X		$(CC) $(CFLAGS) -c action.c
X
buttons.o:	gen.h widgets.h trans.h buttons.c
X		$(CC) $(CFLAGS) -c buttons.c
X
parser.o: 	gen.h parser.c
X		$(CC) $(CFLAGS) -c parser.c	
X
install:
X	strip $(TARGET)
X	mv $(TARGET) /s/bri/bin/mbins/$Mbin
X
clean:
X	rm $(TARGET) *.o
SHAR_EOF
chmod 0644 Makefile.std ||
echo 'restore of Makefile.std failed'
Wc_c="`wc -c < 'Makefile.std'`"
test 635 -eq "$Wc_c" ||
	echo 'Makefile.std: original size 635, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbricons ==============
if test -f 'Xbricons' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbricons (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbricons (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbricons' &&
! Application resources file for bricons program
! B.R. Ingram 9th Sept 1991
*no_of_cols: 			16
*icon_file: 			/home/cur/bri/.briconsrc
*help_file:			/home/cur/bri/Man/bricons.l
.bitmapFilePath:		/usr/local/include/X11/bitmaps:/s/bri/Pics
*borderColor:			yellow
*popup_layout*.borderColor:	black
*background:			#ffd28e
*box.background:		gray
SHAR_EOF
chmod 0644 Xbricons ||
echo 'restore of Xbricons failed'
Wc_c="`wc -c < 'Xbricons'`"
test 342 -eq "$Wc_c" ||
	echo 'Xbricons: original size 342, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= .briconsrc ==============
if test -f '.briconsrc' -a X"$1" != X"-c"; then
	echo 'x - skipping .briconsrc (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting .briconsrc (Text)'
sed 's/^X//' << 'SHAR_EOF' > '.briconsrc' &&
# <-- a line starting with a '#' is a comment line
#
X
# first line must have keyword %icon or %text
# to indicate if button is an icon
%icon help
xterm -e vi `pwd`/bricons.txt
%icon letters
xterm -e mail 
%icon calander
cal 1992
%text Sub-\nmenu
%sub_menu
X	%text bitmap\neditor
X	bitmap `pwd`/bitmaps/dclock
X	%icon dclock
X	xclock
X	%icon load
X	xload
X	%text Shell
X	xterm -n Shell
%end_sub_menu
%icon readNews
xterm -name rn -e rn -r -S1 -t -m
SHAR_EOF
chmod 0644 .briconsrc ||
echo 'restore of .briconsrc failed'
Wc_c="`wc -c < '.briconsrc'`"
test 440 -eq "$Wc_c" ||
	echo '.briconsrc: original size 440, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bricons.l ==============
if test -f 'bricons.l' -a X"$1" != X"-c"; then
	echo 'x - skipping bricons.l (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bricons.l (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bricons.l' &&
.\" static char* sccs_bricons_c = "%W%%G%";
.\"  bricons.l  B. Ingram version 1.0 24th June 1991
.TH BRICONS l "28th March 1992"
.SH NAME
bricons \- quick start up utility for applications using text, icons and pop-up
menus on an X display
.SH SYNOPSIS
.B bricons
\ [options]
.br
[\fB\-file\fP] [\fB\-col\fP] [\fB\-help\fP] [\fB\-sensitive\fP] [\fB\-bmdir\fP]
.br
.SH DESCRIPTION
.LP
Bricons program allows the user to quickly start up applications
by selecting the appropriate button from the display and pressing the left 
mouse button.  A maximum of up to sixteen main menu buttons can be displayed.  
Each main menu button can launch an application or pop-up a sub menu containing 
more buttons. The buttons can be represented as a bitmap or as text.
.LP
Information on how the program is to present each button (either as a bitmap 
or text) and the application that is to be executed if that button is selected 
is contained in script file called .briconsrc.  This file should be stored in 
the same directory as the program is executed from.
.LP
The \&.briconsrc file contains a number of key words which are used to
indicate if the button label is some text or a bitmap and if the button is to
pop-up a sub menu or launch a program.  These key words are explained below:
.LP
The .briconsrc file should start with the keyword
.B %icon
or
.B %text
The key word %icon indicates that the button label is a bitmap.  This should be
followed by the file name containing the bitmap.  For example:
.sp
.ce
%icon clock.icon
.LP
The key word %text indicates that the button label is some text.  The text can
be split over three lines by using the new line character \\n.  For 
example:
.sp
.ce
%text Line1\\nLine2\\nLine3
.LP
would be presented as:
.ce 3
Line1
Line2
Line3
.LP
Once a button has been selected it is prevented from accidentally being 
re-selected by "graying out" the button (default action).  Sometimes however 
it maybe desirable to allow the button to be selected more than once.  This
can be done be using the keyword
.B %icon+
or 
.B %text+
.LP
The next line in the \&.briconsrc file should either contain the key word
%sub_menu or the application to be started.  If the name of an 
application  is given then a check is made to see if such an program can be 
executed.  If the program does not exist or is not in the users path then an 
error message is printed and the button associated with the application is 
ignored.
.LP
If the key word %sub_menu is used then a pop-up sub menu is created.  Any
further buttons defined in the briconsrc file will appear in the sub menu for
that button until the key word %end_sub_menu is found.  A maximum of
ten buttons are allowed in a single pop-up sub menu.
.LP
Any line in the \&.briconsrc file starting with a # character is 
treated as a comment and will be ignored.  
.LP
This program has four default buttons labelled source, edit, help and quit.
The edit button allows the user to edit there icon file (default being an empty
./briconsrc file) and to add or delete buttons from the script file.  The 
source button causes the program to distory all the current buttons being 
displayed and re-read the icon file and display the new buttons.
.SH OPTIONS
.LP
bricons accepts all of the standard X  Toolkit  command  line options along 
with the additional options listed below:
.TP
-file
Tells the program to read this file instead of the default file.
.TP
-col
Indicates the number of buttons in a column before starting a new row.  The 
default number of columns is 15.
.TP
-help
Tells the program the path for the help file.
.TP
-sensitive
Toggle used for default "graying out" of selected buttons.  If set to TRUE 
then buttons will "gray out" unless specifically requested not to.
.TP
-bmdir
This program will search the default bitmap directory (./bitmaps) for any 
bitmaps that are to be used to represent buttons.  If you wish to add 
different bitmap directories then use this command line argument followed by
a colon separated list of path names.  For example if the program needs to find
bitmaps in two different directories then the following can be entered at the
command line:
.sp
.ce
bricons -bmdir /usr/local/bitmaps:/usr/mydir/bitmaps
.sp
.SH X DEFAULTS
.LP
The bricons program reads the .Xdefaults file and Xbricons resource file
during startup and uses the appropriate resource specification to
customise the appearance or characteristics of its display.  This program 
understands all of the core resource names and classes as well as:
.TP
no_of_cols
Specifies the number of buttons in a column.
.TP
icon_file
Specifies path name for icon file to be read.
.TP
help_file
Specifies path name for help file.
.TP
icon_dirs
Specifies path name for bitmap directories.
.sp
.SH "SETTING BITMAP DIRECTORIES"
.LP
This section explains how to specify bitmap file paths using the .Xdefaults
file.  For the quickest and simplest method see the OPTIONS section under
-bmdir.
.LP
This program will search the default bitmap directory for any bitmaps that
are to be used to represent buttons. If the user wishes the program to
search other directories for bitmap files then this should be specified in
the users .X11defaults file.  *BitmapFilePath: should be added followed by
colon separated path names where the bitmap files can be found.  For example:
.sp
.ce
*BitmapFilePath:	/usr/local/include/X11/bitmaps:/usr/mydir/bitmaps
.LP
.SH RESOURCE FILES
.LP
The Xbricons file specifies the required resources.  To make sure the program
uses the resources file set the following line in your .login:
.ce
setenv  XUSERFILESEARCHPATH ~/app_defaults/%N
.LP
and place all all resources in the app_defaults directory.
.SH WIDGETS
.LP
The bricons program is a toolkit-based application which consists of a 
combination of widgets.  In order to specify resources, it is useful to know
the hierarchy of the widgets which compose bricons.  In the list below, 
indentation indicates hierarchical structure.  The widget class name is given 
first, followed by the widget instance name.
.sp
.nf
X	Xbricons	toplevel	
X		Form	box
X			Command	action[18]
X			OverrideShell	popup_shell
X				Form	popup_layout
X				Command	sub_action[10]
.fi
.SH EXAMPLE
.LP
Below is an example of a simple \&.briconsrc file:
.sp
.nf
# <-- a line starting with a '#' is a comment line
#
#       Bri's icon file
#
X
# first line must have keyword %icon or %text
# to indicate if button is an icon
X
%icon calculator
xcalc
%text Games\\n sub\\n menu
%sub_menu
X	%text xeyes
X	xeyes
X	%text othello
X	othello 
%end_sub_menu
.if
.sp
.SH BUGS
After selecting the source button the buttons may not be re-displayed 
correctly.  Selecting the source button a second time may help.
.SH AUTHOR
Bruce R Ingram, University of Kent at Canterbury.
SHAR_EOF
chmod 0644 bricons.l ||
echo 'restore of bricons.l failed'
Wc_c="`wc -c < 'bricons.l'`"
test 6754 -eq "$Wc_c" ||
	echo 'bricons.l: original size 6754, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bricons.txt ==============
if test -f 'bricons.txt' -a X"$1" != X"-c"; then
	echo 'x - skipping bricons.txt (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bricons.txt (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bricons.txt' &&
X
X
X
BRICONS(l)        MISC. REFERENCE MANUAL PAGES         BRICONS(l)
X
X
X
NAME
X     bricons - quick start  up  utility  for  applications  using
X     text, icons and pop-up menus on an X display
X
SYNOPSIS
X     bricons  [options]
X     [-file] [-col] [-help] [-sensitive] [-bmdir]
X
DESCRIPTION
X     Bricons program allows the user to quickly start up applica-
X     tions  by  selecting the appropriate button from the display
X     and pressing the left mouse button.  A maximum of up to six-
X     teen main menu buttons can be displayed. Each main menu but-
X     ton can launch an application or pop-up a sub menu  contain-
X     ing more buttons. The buttons can be represented as a bitmap
X     or as text.
X
X     Information on how the program is  to  present  each  button
X     (either  as a bitmap or text) and the application that is to
X     be executed if that  button  is  selected  is  contained  in
X     script  file  called .briconsrc.  This file should be stored
X     in the same directory as the program is executed from.
X
X     The .briconsrc file contains a number of key words which are
X     used  to indicate if the button label is some text or a bit-
X     map and if the button is to pop-up a sub menu  or  launch  a
X     program.  These key words are explained below:
X
X     The .briconsrc file should start with the keyword  %icon  or
X     %text  The key word %icon indicates that the button label is
X     a bitmap.  This should be followed by the file name contain-
X     ing the bitmap.  For example:
X
X                           %icon clock.icon
X
X     The key word %text indicates that the button label  is  some
X     text.   The  text can be split over three lines by using the
X     new line character \n.  For example:
X
X                      %text Line1\nLine2\nLine3
X
X     would be presented as:
X                                Line1
X                                Line2
X                                Line3
X
X     Once a  button  has  been  selected  it  is  prevented  from
X     accidentally  being  re-selected by "graying out" the button
X     (default action).  Sometimes however it maybe  desirable  to
X     allow the button to be selected more than once.  This can be
X     done be using the keyword %icon+ or %text+
X
X
X
X
Sun Release 4.1   Last change: 28th March 1992                  1
X
X
X
X
X
X
BRICONS(l)        MISC. REFERENCE MANUAL PAGES         BRICONS(l)
X
X
X
X     The next line in the .briconsrc file should  either  contain
X     the key word %sub_menu or the application to be started.  If
X     the name of an application  is given then a check is made to
X     see if such an program can be executed.  If the program does
X     not exist or is not in the users path then an error  message
X     is printed and the button associated with the application is
X     ignored.
X
X     If the key word %sub_menu is used then a pop-up sub menu  is
X     created.   Any further buttons defined in the briconsrc file
X     will appear in the sub menu for that button  until  the  key
X     word  %end_sub_menu  is found.  A maximum of ten buttons are
X     allowed in a single pop-up sub menu.
X
X     Any line in the .briconsrc file starting with a #  character
X     is treated as a comment and will be ignored.
X
X     This program has four default buttons labelled source, edit,
X     help  and  quit.   The  edit  button allows the user to edit
X     there icon file (default being an empty source button causes
X     the  program  to  distory  all  the  current  buttons  being
X     displayed and re-read the icon file and display the new but-
X     tons.
X
OPTIONS
X     bricons accepts all of  the  standard  X   Toolkit   command
X     line options along with the additional options listed below:
X
X     -file
X          Tells the program to read  this  file  instead  of  the
X          default file.
X
X     -col Indicates the number of  buttons  in  a  column  before
X          starting  a  new row.  The default number of columns is
X          15.
X
X     -help
X          Tells the program the path for the help file.
X
X     -sensitive
X          Toggle used for default "graying out" of selected  but-
X          tons.   If  set  to  TRUE  then buttons will "gray out"
X          unless specifically requested not to.
X
X     -bmdir
X          This program will search the default  bitmap  directory
X          (./bitmaps)  for  any  bitmaps  that  are to be used to
X          represent buttons.  If you wish to add different bitmap
X          directories  then  use  this command line argument fol-
X          lowed by a colon separated list  of  path  names.   For
X          example  if  the  program  needs to find bitmaps in two
X          different directories then the following can be entered
X
X
X
Sun Release 4.1   Last change: 28th March 1992                  2
X
X
X
X
X
X
BRICONS(l)        MISC. REFERENCE MANUAL PAGES         BRICONS(l)
X
X
X
X          at the command line:
X
X           bricons -bmdir /usr/local/bitmaps:/usr/mydir/bitmaps
X
X
XX DEFAULTS
X     The bricons program reads the .Xdefaults file  and  Xbricons
X     resource  file  during  startup  and  uses  the  appropriate
X     resource  specification  to  customise  the  appearance   or
X     characteristics  of  its  display.  This program understands
X     all of the core resource names and classes as well as:
X
X     no_of_cols
X          Specifies the number of buttons in a column.
X
X     icon_file
X          Specifies path name for icon file to be read.
X
X     help_file
X          Specifies path name for help file.
X
X     icon_dirs
X          Specifies path name for bitmap directories.
X
X
SETTING BITMAP DIRECTORIES
X     This section explains how to specify bitmap file paths using
X     the  .Xdefaults  file.  For the quickest and simplest method
X     see the OPTIONS section under -bmdir.
X
X     This program will search the default  bitmap  directory  for
X     any bitmaps that are to be used to represent buttons. If the
X     user wishes the program to search other directories for bit-
X     map  files  then  this  should  be  specified  in  the users
X     .X11defaults file.  *BitmapFilePath: should  be  added  fol-
X     lowed  by  colon separated path names where the bitmap files
X     can be found.  For example:
X
X     *BitmapFilePath:    /usr/local/include/X11/bitmaps:/usr/mydir/bitmaps
X
RESOURCE FILES
X     The Xbricons file specifies the required resources.  To make
X     sure  the  program uses the resources file set the following
X     line in your .login:
X            setenv  XUSERFILESEARCHPATH ~/app_defaults/%N
X
X     and place all all resources in the app_defaults directory.
X
WIDGETS
X     The bricons program is  a  toolkit-based  application  which
X     consists  of  a combination of widgets.  In order to specify
X     resources, it is useful to know the hierarchy of the widgets
X
X
X
Sun Release 4.1   Last change: 28th March 1992                  3
X
X
X
X
X
X
BRICONS(l)        MISC. REFERENCE MANUAL PAGES         BRICONS(l)
X
X
X
X     which compose bricons.  In the list below, indentation indi-
X     cates hierarchical structure.   The  widget  class  name  is
X     given first, followed by the widget instance name.
X
X          Xbricons  toplevel
X               Form box
X                    Command   action[18]
X                    OverrideShell  popup_shell
X                         Form popup_layout
X                         Command   sub_action[10]
X
EXAMPLE
X     Below is an example of a simple .briconsrc file:
X
X     # <-- a line starting with a '#' is a comment line
X     #
X     #       Bri's icon file
X     #
X
X     # first line must have keyword %icon or %text
X     # to indicate if button is an icon
X
X     %icon calculator
X     xcalc
X     %text Games\n sub\n menu
X     %sub_menu
X          %text xeyes
X          xeyes
X          %text othello
X          othello
X     %end_sub_menu
X
X
X
BUGS
X     After selecting the source button the  buttons  may  not  be
X     re-displayed  correctly.   Selecting  the  source  button  a
X     second time may help.
X
AUTHOR
X     Bruce R Ingram, University of Kent at Canterbury.
X
X
X
X
X
X
X
X
X
X
X
X
X
X
Sun Release 4.1   Last change: 28th March 1992                  4
X
X
X
SHAR_EOF
chmod 0644 bricons.txt ||
echo 'restore of bricons.txt failed'
Wc_c="`wc -c < 'bricons.txt'`"
test 8068 -eq "$Wc_c" ||
	echo 'bricons.txt: original size 8068, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
PROGRAM
X	bricons
X
DESCRIPTION
X	The bricons program allows the user to start up applications 
X	from a configured command panel on a workstation display 
X	running X.  The bricons interface can consist of up to sixteen
X	buttons which can display some text or an icon. Each button is 
X	used to execute a shell command using the Bourne shell.
X	Each button can be configured to display a single spring 
X	loaded popup menu with up to ten more buttons.
X
COMPILATION
X	Assuming a good X installation at your site, simply:
X
X		xmkmf ; make
X
X	Otherwise use the Makefile provided.
X
CONFIGURATION
X	Once the bricons program has been successfully compiled it can
X	be executed straight away it should display some example buttons
X	one of which is a sub menu.
X
X	The bricons program looks for a .briconsrc configuration file in
X	your home directory otherwise it looks in the current directory
X	for the file.
X
PORTABILITY
X	The bricons program has been compiled and tested on the following:
X
X	machine 		SPARC workstation1 	SPARC workstation2 
X	operating system	SunOS 4.1.1		SunOS 4.1.2_ER
X
X	machine			DEC3100 		VAX station
X	operating system	Ultrix Worksystem V2.1	Ultrix-32 V3.1
X				(Rev 14)		(Rev. 9)
X
X	machine			Sun3
X	operating system	SunOS 4.1.1	
X
ACKNOWLEDGEMENTS
X	Many thanks go to Richard Hesketh and Martin Davy for all their
X	help and advice.
X
___________________________________________________________________________
X	Bruce Ingram	email	bri@ukc.ac.uk
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SHAR_EOF
chmod 0755 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 1515 -eq "$Wc_c" ||
	echo 'README: original size 1515, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= gen.h ==============
if test -f 'gen.h' -a X"$1" != X"-c"; then
	echo 'x - skipping gen.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting gen.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'gen.h' &&
static char* sccs_gen_h = "%W%%G%";
X
#include <stdio.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <X11/Xos.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Xaw/Form.h>
#include <X11/Xaw/Command.h>
#include <X11/Xaw/MenuButton.h>
#include <X11/Shell.h>
#include <X11/Xaw/Cardinals.h>
#include <stdlib.h> 
#include <malloc.h>
#include <ctype.h>
#include <unistd.h>
X
/*
X	Macro for using prototypes if ANSI C is available.
*/
#ifdef __STDC__
#define PROTO(x) x
#else
#define PROTO(x) ()
#endif
X
#define	MAXLINE		500	
#define	MAXBUTTONS	16		/* max number of "buttons" */
#define	MAXSUBBUTTONS	9	/* max number of sub menu buttons */
#define NO_OF_COLS  18		/* default number of columns */
#define	W_WIDTH		55		/* width of "button" widgets */
#define	W_HEIGHT	55		/* height of "button" widgets */
X
#define	EDITOR		"xterm -e vi "	/* editor used to edit icon file. */
#define	FORMATTER	"xterm -e vi "  /* text formatter for help file */
#define	HELP_VIEWER	" "		/* viewer for help file */
X
#define	MAXPROCS	20
X
#define	ICON		1	
#define	TEXT		2
#define	SUB_MENU	3
#define	END_SUB_MENU	4
#define	UNKNOWN		5
#define	END		6
#define	TEXTPLUS	7
#define	ICONPLUS	8
X
#ifndef MAXPATHLEN
#define MAXPATHLEN	1024
#endif
X
#define	RESOURCE_NAME	".bitmapFilePath: "
#define	RESOURCE_VALUE	"/bitmaps"
/*
X	structure for holding info on number of buttons created, number of
X	columns & file to be read.
*/
typedef struct	info{
X		int	no_of_buttons;
X		int	no_of_columns;
X		Boolean	sensitive;
X		Boolean	default_buttons;
X		char	*icon_file;
X		char	*help_file;
}Info;
X
typedef struct	c_id{
X		int	child_id;
X		Widget	w_id;
}ChildInfo;
X
ChildInfo	ci_ptr[MAXPROCS];
X
/* forward declarations */
int	fprintf(), ungetc(), fclose(), fscanf();
char	*strcpy(), *getenv(), *malloc(); 
X
typedef int     bool_t;
X
SHAR_EOF
chmod 0644 gen.h ||
echo 'restore of gen.h failed'
Wc_c="`wc -c < 'gen.h'`"
test 1802 -eq "$Wc_c" ||
	echo 'gen.h: original size 1802, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= patchlevel.h ==============
if test -f 'patchlevel.h' -a X"$1" != X"-c"; then
	echo 'x - skipping patchlevel.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting patchlevel.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'patchlevel.h' &&
#define PATCH_LEVEL 0
SHAR_EOF
chmod 0644 patchlevel.h ||
echo 'restore of patchlevel.h failed'
Wc_c="`wc -c < 'patchlevel.h'`"
test 22 -eq "$Wc_c" ||
	echo 'patchlevel.h: original size 22, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= trans.h ==============
if test -f 'trans.h' -a X"$1" != X"-c"; then
	echo 'x - skipping trans.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting trans.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'trans.h' &&
static char* sccs_trans_h = "%W%%G%";
X
/*
X	translations for the main menu buttons to popup the sub menu.  
X	SetPopup positions the shell.  MenuPopup realizes the shell.
*/
X
static	String pb_Trans =
X	"<EnterWindow>:	highlight() \n\
X	<LeaveWindow>:	unhighlight() \n\
X	<Btn1Down>:	set_popup(box.action%d.popup_menu) MenuPopup(popup_menu) unhighlight()";
X
/*
X	translations for the command buttons of the popup menus the
X	command callback is invoked when the button is released with
X	the pointer in the command widget.
*/
X
static	String cb_Trans =
X	"<EnterWindow>:	set() \n\
X	<LeaveWindow>:	unset() \n\
X	<Btn1Up>:	notify() delay() reset()";
X
/*
X	translations for the shell of the popup menu.  When the button
X	is released the shell catches it and pops itself down.
*/
X
static	String pm_Trans =
X	"<Btn1Up>:	MenuPopdown()";
X
/* add new actions to this program */
X
static	XtActionsRec	menu_actions[] = {
X	{ "set_popup", set_popup },
X	{ "delay", delay }
};
X
/*  the name of the shell, used by SetPopup and MenuPopup actions */
static  String popup_menu_name = "popup_menu";
X
SHAR_EOF
chmod 0644 trans.h ||
echo 'restore of trans.h failed'
Wc_c="`wc -c < 'trans.h'`"
test 1066 -eq "$Wc_c" ||
	echo 'trans.h: original size 1066, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= widgets.h ==============
if test -f 'widgets.h' -a X"$1" != X"-c"; then
	echo 'x - skipping widgets.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting widgets.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'widgets.h' &&
X
Widget  toplevel,       /* must exist on which to place other widgets */
X		box,
X			action[MAXBUTTONS + 1],
X			popup_shell,
X				popup_layout,
X				sub_action[10];
SHAR_EOF
chmod 0644 widgets.h ||
echo 'restore of widgets.h failed'
Wc_c="`wc -c < 'widgets.h'`"
test 162 -eq "$Wc_c" ||
	echo 'widgets.h: original size 162, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= action.c ==============
if test -f 'action.c' -a X"$1" != X"-c"; then
	echo 'x - skipping action.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting action.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'action.c' &&
#include "gen.h"
#include "widgets.h"
#include <signal.h>
#include <sys/wait.h>
#include <stdio.h>
X
extern	XtAppContext	app_context;
X
static void 	catch_child();
static void	ResetButton PROTO((XtPointer,XtIntervalId *));
extern  int     ProcessFile PROTO((Info*, char*));
extern  void    PositionButtons PROTO((int,int));
extern	void	ManageButtons();
X
extern void 
Quit(widget, client_data,call_data)
Widget          widget;
XXtPointer       client_data;
XXtPointer       call_data;
{
X	/* exit graciously */
X	XtDestroyWidget(toplevel);
X        exit(0);
}
X
X
extern void 
MultiAction(widget,client_data,call_data)
Widget          widget;
XXtPointer       client_data;
XXtPointer       call_data;
{
X	char	*command = (char*) client_data;
X	int	pid;
X	static	bool_t first_time = TRUE;
X	char	*exec_command;	/* for "exec " + command */
X
#define PREPEND "exec "
X
X        if (first_time) 
X	{
X        	first_time = FALSE;
X		if ((int) signal(SIGCHLD, catch_child) == -1) 
X		{
X			(void) fprintf(stderr,"unable to install child catcher");
X			exit(1);
X		}
X	}
X
X	switch(pid = fork())
X	{
X		case -1:
X			(void) fprintf(stderr,"ERROR: Process cannot fork\n");
X			(void) fprintf(stderr,"Sorry unable to execute command\n");
X			break;
X		case 0:
X			/* child */
X			exec_command = malloc((unsigned) sizeof(PREPEND) +
X				strlen(command) + 1);
X			if(exec_command == NULL)
X			{
X				(void) fprintf(stderr,"ERROR: out of memory\n");
X				exit(1);
X			}
X			strcpy(exec_command,PREPEND);
X			strcat(exec_command,command);
X			(void)execlp("/bin/sh","sh","-c",exec_command,(char *) 0);
X			exit(127);
X			break;
X	}
}
X
X
extern void 
SingleAction(widget,client_data,call_data)
Widget          widget;
XXtPointer       client_data;
XXtPointer       call_data;
{
X	char	*command = (char*) client_data;
X	int	pid;
X	int	i = 0;
X	static	bool_t first_time = TRUE;
X	char	*exec_command;	/* for "exec " + command */
X
#define PREPEND "exec "
X
/*
X	This section of code was taken from xalias written by Godfrey Paul
X        First time only, arrange for SIGCHLD to be called.
*/
X        if (first_time) 
X	{
X        	first_time = FALSE;
X		if ((int) signal(SIGCHLD, catch_child) == -1) 
X		{
X			(void) fprintf(stderr,"unable to install child catcher");
X			exit(1);
X		}
X	}
X
X	switch(pid = fork())
X	{
X		case -1:
X			(void) fprintf(stderr,"ERROR: Process cannot fork\n");
X			(void) fprintf(stderr,"Sorry unable to execute command\n");
X			break;
X		case 0:
X			/* child */
X			exec_command = malloc((unsigned) sizeof(PREPEND) +
X				strlen(command) + 1);
X			if(exec_command == NULL)
X			{
X				(void) fprintf(stderr,"ERROR: out of memory\n");
X				exit(1);
X			}
X			strcpy(exec_command,PREPEND);
X			strcat(exec_command,command);
X			(void)execlp("/bin/sh","sh","-c",exec_command,(char *) 0);
X			exit(127);
X			break;
X	}
X	while((ci_ptr[i].child_id != 0) && (i < MAXPROCS))
X			i++;
X	if(i < MAXPROCS)
X	{
X		ci_ptr[i].child_id = pid;
X		ci_ptr[i].w_id = widget;
X		XtSetSensitive(widget,False);
X	}
X	else
X		(void) printf("\nWarning: unable to deactivate selected button\n");
X
}
X
X
/*
X	This section of code was taken from xalias written by Godfrey Paul
*/
static void
catch_child()
{
X        int     	pid;
X	int		i = 0;
X        union wait      status;
X
X
X        /*
X         * wait3() returns -1 if the are no children left, or 0
X         * if there are no exited children.
X         */
X        while ((pid = wait3(&status, WNOHANG, (struct rusage *) NULL)) > 0)
X	{
X
X		while((ci_ptr[i].child_id != pid) && (i < MAXPROCS))
X				i++;
X		if(ci_ptr[i].child_id == pid)
X		{
X			XtAppAddTimeOut(app_context,50,ResetButton,pid);
X		}
X	}
X        return;
}
X
extern void
Source(widget,client_data,call_data)
Widget          widget;
XXtPointer       client_data;
XXtPointer       call_data;
{
X	Info    *data = (Info*) client_data;
X
X	int		x = 0;
X	WidgetList	w_list;
X	Cardinal	num_childern, i;
X	if(data->no_of_buttons >= 0)
X	{
X		while(x < MAXPROCS)
X		{
X			ci_ptr[x].child_id = 0;
X			ci_ptr[x].w_id = NULL;
X			x++;
X		}
X		XtUnmanageChild(box);
X		XtVaGetValues(
X			box,
X			XtNchildren,
X			&w_list,
X			XtNnumChildren,
X			&num_childern,
X			NULL);
X
X		for(i = 0; i < num_childern; i++)
X		{
X			XtDestroyWidget(w_list[i]);
X		}
X		data->no_of_buttons = 0;
X		data->no_of_buttons = ProcessFile(data, "bricons");
X		PositionButtons(data->no_of_buttons,data->no_of_columns);
X		ManageButtons();
X		XtManageChild(box);
X	}
}
X
static void
ResetButton(client_data,id)
XXtPointer       client_data;
XXtIntervalId	*id;
{
X	int	c_pid = (int) client_data;
X	int	i = 0;
X	while((ci_ptr[i].child_id != c_pid) && (i < MAXPROCS))
X			i++;
X	if(ci_ptr[i].child_id == c_pid)
X	{
X		XtSetSensitive(ci_ptr[i].w_id,True);
X		ci_ptr[i].child_id = 0;
X	}
}
SHAR_EOF
chmod 0644 action.c ||
echo 'restore of action.c failed'
Wc_c="`wc -c < 'action.c'`"
test 4594 -eq "$Wc_c" ||
	echo 'action.c: original size 4594, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= buttons.c ==============
if test -f 'buttons.c' -a X"$1" != X"-c"; then
	echo 'x - skipping buttons.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting buttons.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'buttons.c' &&
static char* sccs_buttons_c = "%W%%G%";
X
#include "gen.h"
#include "widgets.h"
X
X
extern void	CreateSubButton PROTO((Info*, int, int, char*));
extern	void	CreateMainMenuButton PROTO((Info*, int, int, char*, char*));
static	void	CreateDefaultSubButton PROTO((int, char*, int));
extern  void    Quit PROTO((Widget,XtPointer,XtPointer)),
X		SingleAction PROTO((Widget,XtPointer,XtPointer)),
X		MultiAction PROTO((Widget,XtPointer,XtPointer)),
X                ReadALine PROTO((FILE*,char **)),
X                Source PROTO((Widget,XtPointer,XtPointer));
extern  void    set_popup PROTO((Widget,XEvent *,String *,Cardinal *));
extern	void	delay PROTO((Widget,XEvent *,String *,Cardinal *));
X
static  void    SetButton PROTO((int,char *,int));
static  void    SetSubMenuButton PROTO((int,char *,int));
static	void	CreatePopupShell PROTO((int));
extern	void	CreateSubMenuButton PROTO((int, char *, int, char*, int));
extern	void	DefaultButtons PROTO((Info *,int));
X
#include "trans.h"
X
X
extern void
CreateSubButton(data, button_no, is_icon, label)
Info	*data;
int		button_no;
int		is_icon;
char	*label;
{
X	char	w_buffer[80];
X	char	ptrans[250];
X
X	/* 
X		create translations for the button that 
X		pops up the sub menu
X	*/
X	(void) sprintf(ptrans, pb_Trans, button_no, popup_menu_name);
X
X	/* create main menu button that will popup sub menu */
X	(void) sprintf(w_buffer, "action%d", button_no);
X	action[button_no] = XtVaCreateWidget(
X			w_buffer,
X			commandWidgetClass,
X			box,
X			NULL);
X
X	XtVaSetValues(action[button_no],
X			XtNtranslations,
X			XtParseTranslationTable(ptrans),
X			NULL);
X
X	SetButton(is_icon, label, button_no);
X	CreatePopupShell(button_no);
}
X
X
extern void
CreateMainMenuButton(data, button_no, is_icon, label, command)
Info	*data;
int	button_no;
int	is_icon;
char	*label;
char	*command;
{
X		char	w_buffer[80];
X
X		(void) sprintf(w_buffer, "action%d", button_no);
X
X		action[button_no] = XtVaCreateWidget(
X				w_buffer, 	     /* widget name */	
X				commandWidgetClass,  /* widget class */
X				box,	            /* parent widget */
X				NULL);	   /* terminate varargs list */
X
X		SetButton(is_icon, label, button_no);
X
X		/* add callback for this button */
X		if(data->sensitive)
X		{
X			if((is_icon == TEXT) || (is_icon == ICON))
X				XtAddCallback(action[button_no],XtNcallback, SingleAction, command);
X			else
X				XtAddCallback(action[button_no],XtNcallback,
X					MultiAction,command);
X		} 
X		else
X		{
X			if((is_icon == TEXT) || (is_icon == ICON))
X				XtAddCallback(action[button_no],XtNcallback,
X					MultiAction,command);
X			else
X				XtAddCallback(action[button_no],XtNcallback,
X					SingleAction,command);
X		}
}
X
static	void
SetButton(is_icon,icon,button_num)
int	is_icon;
char	*icon;
int	button_num;
{
X
X	/* if button title is a string then */
X	if((is_icon == TEXT) || (is_icon == TEXTPLUS))
X	{
X		XtVaSetValues(
X			action[button_num],
X			XtNwidth,
X			W_WIDTH,
X			XtNheight,
X			W_HEIGHT,
X			XtNlabel,
X			icon,	/* button title */
X			NULL);
X	}
X	/* if button title is a bitmap then */
X	if((is_icon == ICON) || (is_icon == ICONPLUS))	
X	{
X		XtVaSetValues(
X			action[button_num],
X			XtNwidth,
X			W_WIDTH,
X			XtNheight,
X			W_HEIGHT,
X			XtVaTypedArg,
X			XtNbitmap,
X			XtRString,
X			icon,	/* button title (bitmap) */
X			strlen(icon) +1,
X			NULL);
X	}
}
X
static	void
SetSubMenuButton(is_icon,icon,button_num)
int	is_icon;
char	*icon;
int	button_num;
{
X
X	/* if button title is a string then */
X	if((is_icon == TEXT) || (is_icon == TEXTPLUS))
X	{
X		XtVaSetValues(
X			sub_action[button_num],
X			XtNwidth,
X			W_WIDTH,
X			XtNheight,
X			W_HEIGHT,
X			XtNlabel,
X			icon,	/* button title */
X			NULL);
X	}
X	/* if button title is a bitmap then */
X	if((is_icon == ICON) || (is_icon == ICONPLUS))	
X	{
X		XtVaSetValues(
X			sub_action[button_num],
X			XtNwidth,
X			W_WIDTH,
X			XtNheight,
X			W_HEIGHT,
X			XtVaTypedArg,
X			XtNbitmap,
X			XtRString,
X			icon,	/* button title (bitmap) */
X			strlen(icon) +1,
X			NULL);
X	}
X	if(button_num > 0)
X		XtVaSetValues(sub_action[button_num], XtNfromVert,
X				sub_action[button_num - 1],NULL);
}
X
/*
X	The function PositionButtons places each button next to the 
X	previous button one until the number of buttons equals the 
X	number of columns.  Then a new row is started.
*/
extern void
PositionButtons(i,columns)
int	i;
int	columns;
{
X	int	button_no;
X	int	position = 0;
X
X	button_no = 1;
X	while((button_no < columns) && (button_no <= i))
X	{
X		XtVaSetValues(action[button_no],
X			XtNfromHoriz,action[button_no - 1], NULL);
X		button_no++;
X	}
X	position = columns;
X	while(button_no <= i)
X	{
X		if(position == columns)
X		{
X			XtVaSetValues(action[button_no],
X				XtNfromVert,action[button_no - columns],NULL);
X			position = 0;
X		}
X		else
X		{
X			XtVaSetValues(action[button_no],
X				XtNfromVert,action[button_no - columns],NULL);
X			XtVaSetValues(action[button_no],
X				XtNfromHoriz,action[button_no -1],NULL);
X		}
X		position++;
X		button_no++;
X	}
}
X
/*
X	Once all the buttons have been created then make sure they are 
X	managed.
*/
extern void
ManageButtons()
{
X	WidgetList      w_list;
X	Cardinal        num_childern, i;
X
X	XtVaGetValues(box,
X		XtNchildren,
X		&w_list,
X		XtNnumChildren,
X		&num_childern,
X		NULL);
X
X	for(i = 0; i < num_childern; i++)
X		XtManageChild(w_list[i]);
}
X
static	void
CreatePopupShell(shell_no)
int	shell_no;
{
X
X	popup_shell = XtCreatePopupShell(
X			"popup_menu",
X			overrideShellWidgetClass,
X			action[shell_no],
X			NULL,
X			0);
X
X	XtVaSetValues(popup_shell,
X			XtNtranslations,
X			XtParseTranslationTable(pm_Trans),
X			NULL);
X
X	popup_layout = XtCreateManagedWidget(
X			"popup_layout",
X			formWidgetClass,
X			popup_shell,
X			NULL,
X			0);
}
X
static	void
CreateDefaultSubButton(key_word,button_name,button_num)
int     key_word;
char    *button_name;
int     button_num;
{
X        char    w_buffer[80];
X
X        (void) sprintf(w_buffer,"sub_action%d",button_num);
X        sub_action[button_num] = XtVaCreateManagedWidget(
X                        w_buffer,
X                        menuButtonWidgetClass,
X                        popup_layout,
X                        NULL);
X
X        SetSubMenuButton(key_word,button_name,button_num); 
}
X
extern	void
CreateSubMenuButton(key_word, button_name, button_num, command, sensitive)
int	key_word;
char	*button_name;
int	button_num;
char	*command;
int	sensitive;
{
X	char	w_buffer[80];
X
X	(void) sprintf(w_buffer,"sub_action%d", button_num);
X	sub_action[button_num] = XtVaCreateManagedWidget(
X			w_buffer,
X			menuButtonWidgetClass,
X			popup_layout,
X			NULL);
X
X	SetSubMenuButton(key_word, button_name, button_num); 
X
X	if(sensitive)
X	{
X		if((key_word == TEXT) || (key_word == ICON))
X			XtAddCallback(sub_action[button_num],
X			XtNcallback,SingleAction,command);
X		else
X			XtAddCallback(sub_action[button_num],
X			XtNcallback,MultiAction,command);
X	}
X	else
X	{
X		if((key_word == TEXT) || (key_word == ICON))
X			XtAddCallback(sub_action[button_num],
X			XtNcallback,MultiAction,command);
X		else
X			XtAddCallback(sub_action[button_num],
X			XtNcallback,SingleAction,command);
X	}
X
X	XtVaSetValues(sub_action[button_num],
X			XtNtranslations,
X			XtParseTranslationTable(cb_Trans),
X			NULL);
}
X
extern	void
set_popup(w,event,params,num_params)
Widget	w;
XXEvent	*event;	/* unused */
String	*params;
Cardinal	*num_params;
{
X	/*
X		position the menu, whose name was passed as the first and
X		only parameter at position (20,5) relative to the widget w.
X	*/
X	Widget	a_shell;
X	Position	x,y;
X
X	if(*num_params != 1)
X		XtError("Wrong parameter count passed to set_popup()");
X	
X	/* get the internal Widget id of the named shell */
X	a_shell = XtNameToWidget(toplevel,params[0]);
X	if(a_shell == NULL)
X		XtError("FATAL ERROR: Wrong shell name passed to set_popup()\n\
X			please check icon file is correct");
X	XtTranslateCoords(w,(Position) 5,(Position) 5, &x,&y);
X	XtVaSetValues(a_shell,XtNx,x,XtNy,y,NULL);
}
X
extern	void
delay(w,event,params,num_params)
Widget  w;
XXEvent  *event; /* unused */
String  *params;
Cardinal        *num_params;
{
X	(void) sleep(1);
}
X
extern	void
DefaultButtons(data,last_button)
Info	*data;
int	last_button;
{
X	int	string_length;
X	char	w_buffer[80];
X	char	ptrans[250];
X	char	*edit_file, *h_file;
X
X	/* create default sub menu which will contain source, edit & quit */
X	/* buttons.  Default menu button is called Manage  */
X
X	/* create main menu button */
X	(void) sprintf(ptrans,pb_Trans,last_button,popup_menu_name);
X
X	(void) sprintf(w_buffer,"action%d",last_button);
X	action[last_button] = XtVaCreateWidget(
X			w_buffer,
X			commandWidgetClass,
X			box,
X			NULL);
X
X	XtVaSetValues(action[last_button],XtNtranslations,
X			XtParseTranslationTable(ptrans),NULL);
X
X	SetButton(TEXT,"Edit\nIcons",last_button);
X
X	/* create popup shell */
X	CreatePopupShell(last_button);
X
X	CreateDefaultSubButton(TEXT,"Source",0);
X
X	XtAddCallback(sub_action[0],XtNcallback,Source,data);
X
X	XtVaSetValues(sub_action[0],XtNtranslations,
X				XtParseTranslationTable(cb_Trans),NULL);
X
X	CreateDefaultSubButton(TEXT,"Edit",1);
X
X	string_length = strlen(EDITOR);
X	string_length += strlen(data->icon_file);
X	if((edit_file = malloc(string_length +1)) == NULL)
X	{
X		(void) fprintf(stderr,"ERROR: out of memory for string edit_file.  In function CreateButtons.\n");
X		exit(1);
X	}
X	strcpy(edit_file,EDITOR);
X	strcat(edit_file,data->icon_file);
X
X	XtAddCallback(sub_action[1],XtNcallback,SingleAction,edit_file);
X
X	XtVaSetValues(sub_action[1],XtNtranslations,
X				XtParseTranslationTable(cb_Trans),NULL);
X
X	CreateDefaultSubButton(TEXT,"Help",2);
X
X	string_length = 0;
X	string_length = strlen(FORMATTER);
X	string_length += strlen(HELP_VIEWER);
X	string_length += strlen(data->help_file);
X	if((h_file = malloc(string_length +1)) == NULL)
X	{
X		(void) fprintf(stderr,"ERROR: out of memory for string edit_file.  In function CreateButtons.\n");
X		exit(1);
X	}
X	strcpy(h_file,FORMATTER);
X	strcat(h_file,data->help_file);
X	strcat(h_file,HELP_VIEWER);
X	XtAddCallback(sub_action[2],XtNcallback,SingleAction,h_file);
X
X	XtVaSetValues(sub_action[2],XtNtranslations,
X				XtParseTranslationTable(cb_Trans),NULL);
X
X	CreateDefaultSubButton(TEXT,"Quit",3);
X
X	XtAddCallback(sub_action[3],XtNcallback,Quit,NULL);
X
X	XtVaSetValues(sub_action[3],XtNtranslations,
X				XtParseTranslationTable(cb_Trans),NULL);
}
X
SHAR_EOF
chmod 0644 buttons.c ||
echo 'restore of buttons.c failed'
Wc_c="`wc -c < 'buttons.c'`"
test 10097 -eq "$Wc_c" ||
	echo 'buttons.c: original size 10097, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= gen.c ==============
if test -f 'gen.c' -a X"$1" != X"-c"; then
	echo 'x - skipping gen.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting gen.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'gen.c' &&
static char* sccs_gen_c = "%W%%G%";
X
#include "gen.h"
#include <stdio.h>
X
static	int	IsExecutable PROTO((char *,char *)), 
X		Executable PROTO((char *));
extern	int	GetCommand PROTO((char*, char*, char*, char*, int));
extern	void	GetPath PROTO((char*));
X
/*
X	IsExecutable function searches along the users path trying to
X	locate the file program.  If found a check is made to see if it
X	is executable.  If it is TRUE is returned, otherwise FALSE is
X	returned.
*/
static int
IsExecutable(path,program)
char	*path;
char	*program;
{
X	int i, j;
X	char	pathname[MAXPATHLEN];
X
X	i = 0;
X	if(*program == '/')
X	{
X		if(Executable(program))
X			return(TRUE);
X		else
X			return(FALSE);
X	}
X	while (path[i] != '\0')
X	{
X		if (path[i] == ' ')
X			++i;
X		for (j = 0; path[i] != ' ' && path[i] != '\0'; ++i, ++j)
X			pathname[j] = path[i];
X		pathname[j++] = '/';
X		strcpy(&pathname[j], program);
X		if(Executable(pathname)) 
X			return(TRUE);
X	}
X	return(FALSE);
}
X
X
/*
X	GetCommand reads a line of text from the file pointed at by file
X	pointer fp.  It then checks if the first word is a valid command.
*/
extern int
GetCommand(path, command, source_file, exe_name, line_no)
char	*path;
char	*command;
char	*source_file;
char	*exe_name;
int	line_no;
{
X	int	i = 0;
X	int	is_binary = FALSE;
X	char	prog_name[MAXPATHLEN];
X	char	*c_ptr;
X
X	prog_name[0] = '\0';
X	if(*command != NULL)
X	{
X		c_ptr = command;
X		/* get first word from line of text */
X		while((*c_ptr != ' ') && (*c_ptr != '\0') && (*c_ptr != ';') &&
X				(*c_ptr != '\n'))
X		{
X			if(*c_ptr == '`')
X				c_ptr++;
X			prog_name[i++] = *c_ptr++;
X		}
X		prog_name[i] = '\0';
X		if(IsExecutable(path,prog_name))
X			is_binary = TRUE;
X		else
X		{
X			(void) fprintf(stderr,"%s: Errr... in ", exe_name);
X			(void) fprintf(stderr,"\"%s\" file\nline: %d cannot execute [%s] (not on path?).\n", source_file, line_no, prog_name);
X		}
X	}
X	return(is_binary);
}
X
X
X
/*
X	The function GetPath fills in the given char array with the value of 
X	the environmental variable PATH, with spaces instead of colons, and a 
X	'.' in the appropriate place.
*/
extern void
GetPath(p)
char *p;
{
X        char *path;
X
X        path = getenv("PATH");
X        if (*path == ':')
X                *p++ = '.';
X        while (*path != '\0') {
X                if (*path == ':')
X                        *p++ = ' ';
X                else
X                        *p++ = *path;
X                ++path;
X        }
X        if (*--path == ':')
X                *p++ = '.';
X        *p = '\0';
}
X
X
/*
X	The Executable  function returns True if file exists and is a directly 
X	executable Regular file. Otherwise False is returned.
X */
static int
Executable(file)
char *file;
{
X        struct stat st_buf;
X
X        if ( stat(file, &st_buf) != 0 )
X           return (FALSE); 
X        else 
X           return (S_IFREG & st_buf.st_mode) && (access(file,1)==0) && 
X		( !(S_IFDIR & st_buf.st_mode) ) ; 
}
SHAR_EOF
chmod 0644 gen.c ||
echo 'restore of gen.c failed'
Wc_c="`wc -c < 'gen.c'`"
test 2863 -eq "$Wc_c" ||
	echo 'gen.c: original size 2863, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= main.c ==============
if test -f 'main.c' -a X"$1" != X"-c"; then
	echo 'x - skipping main.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting main.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'main.c' &&
static char* sccs_main_c = "%W%%G%"; 
X
/* 
X * Copyright 1992 Bruce. R. Ingram.
X * University of Kent at Canterbury, UK
X *
X * Permission  to   use, copy, modify  and  distribute  this  software  and its
X * documentation   for any purpose is hereby granted without fee, provided that
X * the   above  copyright  notice  appear  in  all  copies  and  that both that
X * copyright  notice   and  this   permission   notice  appear  in   supporting
X * documentation,  and  that  the name  of the author and The University  of
X * Kent  at  Canterbury  not be  used in advertising or publicity pertaining to
X * distribution  of  the  software  without specific, written prior permission.
X * The   author  and   The   University   of   Kent at   Canterbury   make  no
X * representations  about  the  suitability  of this  software for any purpose.
X * It is provided "as is" without express or implied warranty.
X *
X * THE   AUTHOR  AND  THE  UNIVERSITY  OF KENT  AT   CANTERBURY  DISCLAIMS ALL
X * WARRANTIES  WITH  REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED  WARRANTIES
X * OF   MERCHANTABILITY  AND  FITNESS,  IN NO  EVENT  SHALL THE AUTHOR  OR THE
X * UNIVERSITY  OF KENT  AT  CANTERBURY  BE LIABLE FOR ANY SPECIAL, INDIRECT  OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS  OF USE,
X * DATA  OR  PROFITS,  WHETHER  IN  AN ACTION OF CONTRACT, NEGLIGENCE  OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
X * OF THIS SOFTWARE.
X *
X * Author:
X *
X * Mr  B. R. Ingram email bri@ukc.ac.uk
*/
X
#include "gen.h"
#include "widgets.h"
X
X
/*  Forward  references  */
X
extern	void	GetPath PROTO((char *));
extern	void	PositionButtons PROTO((int,int)), ManageButtons();
extern  void    set_popup PROTO((Widget,XEvent *,String *,Cardinal *));
extern	void	delay PROTO((Widget,XEvent *,String *,Cardinal *));
extern	void	Quit PROTO((Widget,XtPointer,XtPointer));
static	void	AddResource PROTO((char *, char *, int));
extern	int	ProcessFile PROTO((Info*, char*));
X
#include "trans.h"
X
/*
X	We set various default resources for the various widgets.
*/
String fallback_resources[] = {
"*borderColor:		black",
SHAR_EOF
true || echo 'restore of main.c failed'
fi
echo 'End of  part 1'
echo 'File main.c is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
