Path: uunet!usc!elroy.jpl.nasa.gov!swrinde!mips!msi!dcmartin
From: nathan@inmos.co.uk (Nathan Sidwell)
Newsgroups: comp.sources.x
Subject: v18i025: Xmris - an X video game, Part04/09
Message-ID: <1992Jul16.171738.1768@msi.com>
Date: 16 Jul 92 17:17:38 GMT
References: <csx-18i022-xmris@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1784
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: Nathan Sidwell <nathan@inmos.co.uk>
Posting-number: Volume 18, Issue 25
Archive-name: xmris/part04

# this is part.04 (part 4 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file draw.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 4; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping draw.c'
else
echo 'x - continuing file draw.c'
sed 's/^X//' << 'SHAR_EOF' >> 'draw.c' &&
X    case 2: case 4:
X    {
X      COORD     offset;
X      COORD     pixel;
X      unsigned  bits;
X	
X      pixel.x = player.old_ball.pixel.x - BALL_WIDTH / 2;
X      pixel.y = player.old_ball.pixel.y - BALL_HEIGHT / 2;
X      if(player.old_ball.count)
X	{
X	  offset.x = player.old_ball.count * BALL_EX;
X	  offset.y = player.old_ball.count * BALL_EY;
X	  bits = 0xFF;
X	  /*{{{  set clips*/
X	  {
X	    if(pixel.x < offset.x)
X	      bits &= 0xF8;
X	    if(pixel.y < offset.y)
X	      bits &= 0x3E;
X	    if(pixel.x + offset.x > BOARD_WIDTH)
X	      bits &= 0x8F;
X	    if(pixel.y + offset.y > BOARD_HEIGHT)
X	      bits &= 0xE3;
X	  }
X	  /*}}}*/
X	  /*{{{  do inner bits*/
X	  {
X	    if(bits & 0x01)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x - offset.x, pixel.y - offset.y);
X	    if(bits & 0x02)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x - offset.x, pixel.y);
X	    if(bits & 0x04)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x - offset.x, pixel.y + offset.y);
X	    if(bits & 0x08)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x, pixel.y + offset.y);
X	    if(bits & 0x10)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x + offset.x, pixel.y + offset.y);
X	    if(bits & 0x20)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x + offset.x, pixel.y);
X	    if(bits & 0x40)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x + offset.x, pixel.y - offset.y);
X	    if(bits & 0x80)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x, pixel.y - offset.y);
X	  }
X	  /*}}}*/
X	  offset.x *= 2;
X	  offset.y *= 2;
X	  /*{{{  set clips*/
X	  {
X	    if(pixel.x < offset.x)
X	      bits &= 0xF8;
X	    if(pixel.y < offset.y)
X	      bits &= 0x3E;
X	    if(pixel.x + offset.x > BOARD_WIDTH)
X	      bits &= 0x8F;
X	    if(pixel.y + offset.y > BOARD_HEIGHT)
X	      bits &= 0xE3;
X	  }
X	  /*}}}*/
X	  /*{{{  do outer bits*/
X	  {
X	    if(bits & 0x01)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x - offset.x, pixel.y - offset.y);
X	    if(bits & 0x02)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x - offset.x, pixel.y);
X	    if(bits & 0x04)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x - offset.x, pixel.y + offset.y);
X	    if(bits & 0x08)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x, pixel.y + offset.y);
X	    if(bits & 0x10)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x + offset.x, pixel.y + offset.y);
X	    if(bits & 0x20)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x + offset.x, pixel.y);
X	    if(bits & 0x40)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x + offset.x, pixel.y - offset.y);
X	    if(bits & 0x80)
X	      XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X		  0, 0, BALL_WIDTH, BALL_HEIGHT,
X		  pixel.x, pixel.y - offset.y);
X	  }
X	  /*}}}*/
X	}
X      else
X	XCopyArea(display.display, ball_xor, display.window, GCN(GC_BALL),
X	    0, 0, BALL_WIDTH, BALL_HEIGHT, pixel.x, pixel.y);
X      break;
X    }
X    /*}}}*/
X    /*{{{  case 3:*/
X    case 3:
X      break;
X    /*}}}*/
X  }
X  return;
}
/*}}}*/
/*{{{  void zoom_board()*/
extern void zoom_board FUNCARGVOID
/* zooms out on the initial board */
{
X  unsigned  count;
X    
X  XFillRectangle(display.display, display.copy, GCN(GC_CLEAR),
X      BORDER_LEFT + 1, BORDER_TOP + 1, BOARD_WIDTH - 2, BOARD_HEIGHT - 2);
X  XCopyArea(display.display, display.copy, display.window, GCN(GC_COPY),
X      0, 0, WINDOW_WIDTH, WINDOW_HEIGHT, 0, 0);
X  XCopyArea(display.display, display.back, display.copy, GCN(GC_COPY),
X      BORDER_LEFT + 1, BORDER_TOP + 1, BOARD_WIDTH - 2, BOARD_HEIGHT - 2,
X      BORDER_LEFT + 1, BORDER_TOP + 1);
X  /*{{{  do the apple sprites*/
X  {
X    int       i;
X    APPLE     *aptr;
X      
X    for(aptr = apple.list, i = apple.apples; i--; aptr++)
X      {
X	SPRITE    *sptr;
X      
X	sptr = &sprites[SPRITE_APPLE];
X	XCopyArea(display.display, sptr->mask, display.copy, GCN(GC_MASK),
X	    0, 0, CELL_WIDTH, CELL_HEIGHT, aptr->pixel.x, aptr->pixel.y);
X	XCopyArea(display.display, sptr->image, display.copy, GCN(GC_OR),
X	    0, 0, CELL_WIDTH, CELL_HEIGHT, aptr->pixel.x, aptr->pixel.y);
X      }
X  }
X  /*}}}*/
X  timer_start(ZOOM_RATE);
X  for(count = 0; count < BOARD_HEIGHT / (2 * ZOOM_Y); count += 1)
X    {
X      XCopyArea(display.display, display.copy, display.window, GCN(GC_COPY),
X	  BORDER_LEFT + BOARD_WIDTH / 2 - ZOOM_X - count * ZOOM_X,
X	  BORDER_TOP + BOARD_HEIGHT / 2 - ZOOM_Y- count * ZOOM_Y,
X	  ZOOM_X, count * 2 * ZOOM_Y + 2 * ZOOM_Y,
X	  BORDER_LEFT + BOARD_WIDTH / 2 - ZOOM_X - count * ZOOM_X,
X	  BORDER_TOP + BOARD_HEIGHT / 2 - ZOOM_Y - count * ZOOM_Y);
X      XCopyArea(display.display, display.copy, display.window, GCN(GC_COPY),
X	  BORDER_LEFT + BOARD_WIDTH / 2 + count * ZOOM_X,
X	  BORDER_TOP + BOARD_HEIGHT / 2 - ZOOM_Y - count * ZOOM_Y,
X	  ZOOM_X, count * 2 * ZOOM_Y + 2 * ZOOM_Y,
X	  BORDER_LEFT + BOARD_WIDTH / 2 + count * ZOOM_X,
X	  BORDER_TOP + BOARD_HEIGHT / 2 - ZOOM_Y - count * ZOOM_Y);
X      XCopyArea(display.display, display.copy, display.window, GCN(GC_COPY),
X	  BORDER_LEFT + BOARD_WIDTH / 2 - count * ZOOM_X,
X	  BORDER_TOP + BOARD_HEIGHT / 2 - ZOOM_Y - count * ZOOM_Y,
X	  count * 2 * ZOOM_X, ZOOM_Y,
X	  BORDER_LEFT + BOARD_WIDTH / 2 - count * ZOOM_X,
X	  BORDER_TOP + BOARD_HEIGHT / 2 - ZOOM_Y - count * ZOOM_Y);
X      XCopyArea(display.display, display.copy, display.window, GCN(GC_COPY),
X	  BORDER_LEFT + BOARD_WIDTH / 2 - count * ZOOM_X,
X	  BORDER_TOP + BOARD_HEIGHT / 2 + count * ZOOM_Y,
X	  count * 2 * ZOOM_X, ZOOM_Y,
X	  BORDER_LEFT + BOARD_WIDTH / 2 - count * ZOOM_X,
X	  BORDER_TOP + BOARD_HEIGHT / 2 + count * ZOOM_Y);
X      XSync(display.display, False);
X      timer_wait();
X    }
X  timer_stop();
X  return;
}
/*}}}*/
SHAR_EOF
echo 'File draw.c is complete' &&
chmod 0644 draw.c ||
echo 'restore of draw.c failed'
Wc_c="`wc -c < 'draw.c'`"
test 23961 -eq "$Wc_c" ||
	echo 'draw.c: original size 23961, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= monster.c ==============
if test -f 'monster.c' -a X"$1" != X"-c"; then
	echo 'x - skipping monster.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting monster.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'monster.c' &&
/*{{{  (C) 1992 Nathan Sidwell*/
/*****************************************************************************
X			X M R I S V1.01
X			---------------
X		    (C) 1992 Nathan Sidwell
X
This program is copyright (C) 1992 Nathan Sidwell. This software and documentation
is in the public domain. Permission is granted to distribute and compile
verbatim copies of this software for non-commercial, non-profit use,
without fee. The software may be modified, provided that both the above copyright
notice and this permission notice appear.
X
No guarantee is given as to the robustness or suitability of this
software for your computer.
X
Nathan Sidwell  INMOS UK |                 | nathan@inmos.co.uk       DoD#0390
*****************************************************************************/
/*}}}*/
#include "xmris.h"
/*{{{  prototypes*/
static void extra_dies PROTOARGLIST((void));
/*}}}*/
/*{{{  MONSTER *extra_escape()*/
extern MONSTER *extra_escape FUNCARGVOID
/*
X * remove the extra monster from the top, so it
X * can run around
X */
{
X  int       x;
X  
X  extra.escape = 1;
X  x = XTRA_X + extra.select * XTRA_SPACING;
X  XFillRectangle(display.display, display.back, GCN(GC_CLEAR),
X      x, XTRA_Y, CELL_WIDTH, CELL_HEIGHT);
X  add_background(x, XTRA_Y, CELL_WIDTH, CELL_HEIGHT);
X  x -= BORDER_LEFT + GAP_WIDTH;
X  assert(x % (CELL_WIDTH + GAP_WIDTH) % VEL_X == 0);
X  return spawn_monster(2, 1, 1, x / (CELL_WIDTH + GAP_WIDTH), 0,
X      x % (CELL_WIDTH + GAP_WIDTH), XTRA_Y - BORDER_TOP);
}
/*}}}*/
/*{{{  void extra_dies()*/
static void extra_dies FUNCARGVOID
/*
X * the extra monster has died,
X * put it back at the top
X * and maybe alter the state
X */
{
X  unsigned  got;
X  
X  if(global.state == 2)
X    {
X      global.state = 3;
X      monster.den = 0;
X      monster.delay = 0;
X    }
X  got = extra.got & (1 << extra.select);
X  extra.got |= 1 << extra.select;
X  extra.escape = 0;
X  if(!got)
X    create_xtra_monster(extra.select);
X  draw_extra();
X  return;
}
/*}}}*/
/*{{{  void fall_monsters()*/
extern void fall_monsters FUNCARGVOID
/*
X * makes all the monsters fall
X */
{
X  unsigned  i;
X  MONSTER   *mptr;
X
X  for(mptr = monster.list, i = monster.monsters; i--; mptr++)
X    if(mptr->apple)
X      {
X	/*{{{  just hit?*/
X	if(mptr->face < 8)
X	  {
X	    if(BOARDCELL(mptr->cell.x, mptr->cell.y)->distance ==
X	      monster.nearest)
X	    global.difficulty++;
X	    new_face(mptr);
X	    if(mptr == &monster.list[0])
X	      mptr->shot = 1;
X	    else
X	      {
X		mptr->chew = 0;
X		if(mptr->type < 2)
X		  monster.normals--;
X		else if(mptr->type == 2)
X		  extra_dies();
X		else if(mptr->type == 3)
X		  monster.drones--;
X	      }
X	  }
X	/*}}}*/
X	mptr->pixel.y = mptr->apple->pixel.y + CELL_HEIGHT;
X	if(mptr->apple && mptr->apple->state > 3)
X	  {
X	    if(mptr->type != 4)
X	      mptr->type = 5;
X	    else
X	      mptr->apple = NULL;
X	  }
X      }
X  return;
}
/*}}}*/
/*{{{  void move_monsters()*/
extern void move_monsters FUNCARGVOID
/*
X * moves all the monsters
X */
{
X  MONSTER   *mptr;
X  unsigned  i;
X  unsigned  nearest;
X  unsigned  farthest;
X
X  nearest = 255;
X  farthest = 0;
X  for(mptr = &monster.list[1], i = monster.monsters - 1; i--; mptr++)
X    {
X      if(mptr->shot || (mptr->type == 3 && global.state == 3))
X	/*{{{  shot*/
X	{
X	  if(BOARDCELL(mptr->cell.x, mptr->cell.y)->distance ==
X	      monster.nearest)
X	    global.difficulty++;
X	  if(mptr->type < 2)
X	    monster.normals--;
X	  else
X	    /*{{{  convert to apple*/
X	    {
X	      APPLE     *aptr;
X	      CELL      *cptr;
X			  
X	      if(mptr->type == 2)
X		extra_dies();
X	      else if(mptr->type == 3)
X		monster.drones--;
X	      if(mptr->offset.x > (CELL_WIDTH + GAP_WIDTH) / 2)
X		{
X		  mptr->offset.x -= CELL_WIDTH + GAP_WIDTH;
X		  mptr->cell.x++;
X		}
X	      else if(mptr->offset.x < -(CELL_WIDTH + GAP_WIDTH) / 2)
X		{
X		  mptr->offset.x += CELL_WIDTH + GAP_WIDTH;
X		  mptr->cell.x--;
X		}
X	      cptr = BOARDCELL(mptr->cell.x, mptr->cell.y);
X	      aptr = spawn_apple(mptr->cell.x, mptr->cell.y,
X		  mptr->offset.x, mptr->offset.y);
X	      if(mptr->cell.y == CELLS_DOWN - 1)
X		aptr->state = 2;
X	      else if(mptr->offset.y < cptr->depths[1])
X		aptr->state = 2;
X	      else if(!mptr->offset.y && cptr[CELL_STRIDE].visit)
X		{
X		  aptr->state = 1;
X		  aptr->count = APPLE_ROCK_DELAY;
X		}
X	    }
X	    /*}}}*/
X	  if(mptr->shot)
X	    add_score(500, mptr->pixel.x + CELL_WIDTH / 2,
X		mptr->pixel.y + CELL_HEIGHT / 2);
X	  mptr->type = 5;
X	}
X	/*}}}*/
X      else if(mptr->apple)
X	/*EMPTY*/;
X      else if(mptr->chew)
X	/*{{{  chewing*/
X	{
X	  if(mptr->chew == 1)
X	    {
X	      mptr->chew = 2;
X	      mptr->count = CHOMP_DELAY;
X	      mptr->image = 0;
X	      mptr->cycle = MONSTER_CYCLES - 1;
X	    }
X	  mptr->count--;
X	  if(!mptr->count)
X	    mptr->chew = 0;
X	  if(!mptr->cycle)
X	    {
X	      mptr->image = (mptr->image + 1) % MONSTER_IMAGES;
X	      mptr->cycle = MONSTER_CYCLES;
X	    }
X	  mptr->cycle--;
X	}
X	/*}}}*/
X      else if(global.state != 4)
X	{
X	  CELL      *cptr;
X
X	  cptr = BOARDCELL(mptr->cell.x, mptr->cell.y);
X	  assert((cptr->distance || global.broken) && cptr->visit);
X	  if(!mptr->cycle)
X	    {
X	      mptr->cycle = MONSTER_CYCLES;
X	      mptr->image++;
X	      if(mptr->image == MONSTER_IMAGES)
X		mptr->image = 0;
X	    }
X	  if((!mptr->count || mptr->type & 2) && !mptr->pause)
X	    mptr->cycle--;
X	  if(mptr->type & 2 || global.state != 2)
X	    {
X	      if(nearest > cptr->distance)
X		nearest = cptr->distance;
X	      if(farthest < cptr->distance)
X		farthest = cptr->distance;
X	    }
X	  switch(mptr->type)
X	  {
X	    /*{{{  case 0: case 1: (normal or muncher)*/
X	    case 0: case 1:
X	    {
X	      int     valid;
X			  
X	      valid = valid_directions(mptr, cptr);
X	      if(mptr->count)
X		mptr->count--;
X	      if(!mptr->type && random() < CONT_TOGGLE_PROB)
X		/*{{{  toggle the cont & maybe turn round*/
X		{
X		  mptr->cont = !mptr->cont;
X		  if(mptr->pause || mptr->stop)
X		    {
X		      mptr->dir ^= 1;
X		      new_face(mptr);
X		    }
X		}
X		/*}}}*/
X	      if(mptr->push)
X		/*{{{  disable left or right*/
X		{
X		  if(mptr->push < 0)
X		    valid &= 0x77;
X		  else
X		    valid &= 0xBB;
X		}
X		/*}}}*/
X	      else if(mptr->count)
X		valid = 0;
X	      else if(mptr->pause)
X		{
X		  if(!mptr->type)
X		    {
X		      if(random() < GO_MUNCH_PROB * global.difficulty)
X			mptr->gomunch = 1;
X		      valid = 0;
X		    }
X		  else if(mptr->stop || random() < PUSH_TURN_PROB)
X		    {
X		      mptr->dir ^= 1;
X		      new_face(mptr);
X		      valid = 0;
X		    }
X		  mptr->stop = 0;
X		  mptr->pause = 0;
X		}
X	      else if(global.state == 2)
X		valid = 0;
X	      else if(!mptr->offset.x && !mptr->offset.y)
X		{
X		  mptr->fast = 0;
X		  if(!mptr->type && global.state == 3)
X		    mptr->fast = 1;
X		  if(mptr->gomunch)
X		    {
X		      mptr->gomunch = 0;
X		      mptr->type = 1;
X		      mptr->count = GO_MUNCH_DELAY;
X		    }
X		  else if(mptr->type)
X		    {
X		      int       temp;
X			
X		      temp = valid & 0xF;
X		      if((temp & -temp) != temp)
X			{
X			  APPLE     *aptr;
X			  unsigned  i;
X			  int       x;
X				      
X			  mptr->type = 0;
X			  mptr->count = STOP_MUNCH_DELAY;
X			  valid = 0;
X			  x = mptr->pixel.x - CELL_WIDTH + GAP_WIDTH * 2;
X			  for(aptr = apple.list, i = apple.apples; i--; aptr++)
X			    {
X			      if(!aptr->state && aptr->pixel.x - x >= 0 &&
X				  aptr->pixel.x - x < CELL_WIDTH * 2 - GAP_WIDTH * 4 &&
X				  aptr->cell.y == mptr->cell.y - 1)
X				{
X				  aptr->state = 1;
X				  aptr->count = APPLE_ROCK_DELAY;
X				}
X			    }
X			}
X		    }
X		  else if(!mptr->type && random() <
X		      GO_MUNCH_PROB * global.difficulty)
X		    mptr->gomunch = 1;
X		}
X	      if(!valid)
X		/*EMPTY*/;
X	      else if(mptr->type)
X		/*{{{  move the muncher*/
X		{
X		  if(mptr->offset.x || mptr->offset.y)
X		    /*{{{  carry on*/
X		    {
X		      CELL      *nptr;
X					  
X		      nptr = move_muncher(mptr);
X		      if(nptr)
X			{
X			  cptr = nptr;
X			  if(nptr->sprite == SPRITE_CHERRY)
X			    {
X			      global.cherries--;
X			      nptr->sprite = 0;
X			    }
X			}
X		    }
X		    /*}}}*/
X		  else
X		    /*{{{  pick new direction*/
X		    {
X		      int     temp;
X					  
X		      temp = ~valid & 0xF;
X		      if(!mptr->cell.y)
X			temp &= 0xE;
X		      else if(mptr->cell.y == CELLS_DOWN - 1)
X			temp &= 0xD;
X		      if(!mptr->cell.x)
X			temp &= 0xB;
X		      else if(mptr->cell.x == CELLS_ACROSS - 1)
X			temp &= 0x7;
X		      if(!temp)
X			temp = valid & 0xF;
X		      if(mptr->pixel.x < monster.list[0].pixel.x)
X			valid = 0x8;
X		      else if(mptr->pixel.x > monster.list[0].pixel.x)
X			valid = 0x4;
X		      else
X			valid = 0;
X		      if(!(valid & temp))
X			{
X			  if(mptr->pixel.y < monster.list[0].pixel.y)
X			    valid = 0x2;
X			  else if(mptr->pixel.y > monster.list[0].pixel.y)
X			    valid = 0x1;
X			  if(!(valid & temp))
X			    valid = temp;
X			}
X		      assert(valid);
X		      for(temp = 0; !(valid & 1); temp++)
X			valid >>= 1;
X		      if(temp != mptr->dir)
X			{
X			  mptr->dir = temp;
X			  new_face(mptr);
X			}
X		      move_muncher(mptr);
X		    }
X		    /*}}}*/
X		}
X		/*}}}*/
X	      else
X		/*{{{  pick a direction*/
X		{
X		  unsigned  temp;
X				  
X		  if(mptr->cont)
X		    {
X		      valid &= 0xF;
X		      temp = valid & ~(1 << (mptr->dir ^ 1));
X		      if(temp)
X			valid = temp;
X		    }
X		  else if(valid & 0xF0)
X		    valid = valid & valid >> 4;
X		  valid = choose_direction(valid);
X		  temp = mptr->dir;
X		  if(valid != mptr->dir)
X		    {
X		      mptr->dir = valid;
X		      if(mptr->push && (valid ^ temp) != 1)
X			{
X			  mptr->push = 0;
X			  mptr->cont = 1;
X			}
X		      new_face(mptr);
X		    }
X		  if(!apple_stop(mptr, cptr))
X		    cptr = move_movable(mptr, cptr);
X		  if(mptr->push)
X		    {
X		      mptr->dir = temp;
X		      mptr->push = 0;
X		    }
X		}
X		/*}}}*/
X	      break;
X	    }
X	    /*}}}*/
X	    /*{{{  case 2: case 3: (xtra or drone)*/
X	    case 2: case 3:
X	    {
X	      int     valid;
X	      int     temp;
X			  
X	      /*{{{  giving birth?*/
X	      if(monster.delay && mptr->type == 2 && global.state == 2)
X		{
X		  monster.delay--;
X		  if(monster.delay)
X		    break;
X		  if(monster.den)
X		    {
X		      monster.delay = XTRA_BIRTH_DELAY;
X		      monster.den--;
X		      spawn_monster(3, mptr->dir, mptr->face,
X			  mptr->cell.x, mptr->cell.y,
X			  mptr->offset.x, mptr->offset.y);
X		      monster.drones++;
X		      i++;
X		    }
X		}
X	      /*}}}*/
X	      valid = valid_directions(mptr, cptr);
X	      if(global.state == 3 && !mptr->offset.x && ! mptr->offset.y)
X		mptr->fast = 1;
X	      /*{{{  pick a direction*/
X	      {
X		if(valid & 0xF0 &&
X		    (mptr->type != 2 || player.ball.state ||
X		    (global.state == 2 ? mptr->count == monster.farthest :
X		     mptr->count != monster.nearest)))
X		  {
X		    mptr->cont = 0;
X		    valid >>= 4;
X		  }
X		else
X		  {
X		    temp = valid & ((valid >> 4) ^ 0xF);
X		    if(temp)
X		      valid = temp;
X		    else
X		      valid &= 0xF;
X		  }
X		valid = choose_direction(valid);
X		if(valid != mptr->dir)
X		  {
X		    mptr->dir = valid;
X		    new_face(mptr);
X		  }
X		mptr->count = cptr->distance;
X		cptr = move_movable(mptr, cptr);
X		/*{{{  walked into apple?*/
X		{
X		  unsigned  i;
X		  APPLE     *aptr;
X		  int       x, y;
X		  int       width, height;
X				  
X		  x = mptr->pixel.x;
X		  y = mptr->pixel.y;
X		  /*{{{  set offset*/
X		  if(mptr->dir & 2)
X		    {
X		      x -= CELL_WIDTH / 2;
X		      y -= CELL_HEIGHT / 4;
X		      width = CELL_WIDTH;
X		      height = CELL_HEIGHT / 2;
X		    }
X		  else
X		    {
X		      x -= CELL_WIDTH / 4;
X		      y -= CELL_HEIGHT / 2;
X		      width = CELL_WIDTH / 2;
X		      height = CELL_HEIGHT;
X		    }
X		  /*}}}*/
X		  for(aptr = apple.list, i = apple.apples; i--; aptr++)
X		    {
X		      if(aptr->state < 3 &&
X			  aptr->pixel.x - x >= 0 &&
X			  aptr->pixel.x - x < width &&
X			  aptr->pixel.y - y >= 0 &&
X			  aptr->pixel.y - y < height)
X			{
X			  mptr->chew = 1;
X			  aptr->chewed = 1;
X			  break;
X			}
X		    }
X		}
X		/*}}}*/
X	      }
X	      /*}}}*/
X	      break;
X	    }
X	    /*}}}*/
X	    /*{{{  default:*/
X	    default:
X	      assert(0);
X	      break;
X	    /*}}}*/
X	  }
X	}
X    }
X  monster.nearest = nearest;
X  monster.farthest = farthest;
X  return;
}
/*}}}*/
/*{{{  void new_xtra()*/
extern void new_xtra FUNCARGVOID
/*
X * increments the extra monster, and draws it up
X */
{
X  draw_extra_letter(extra.select);
X  if(extra.select == 4)
X    extra.select = 0;
X  else
X    extra.select++;
X  create_xtra_monster(extra.select);
X  draw_extra();
X  return;
}
/*}}}*/
/*{{{  MONSTER *spawn_monster(type, dir, face, cx, cy, ox, oy)*/
extern MONSTER *spawn_monster FUNCARGLIST((type, dir, face, cx, cy, ox, oy))
int       type  FUNCARGSEP  /* type of monster 0-4 */
int       dir   FUNCARGSEP  /* direction 0-3 */
int       face  FUNCARGSEP  /* face 0-5 */
int       cx    FUNCARGSEP  /* cell x */
int       cy    FUNCARGSEP  /* cell y */
int       ox    FUNCARGSEP  /* offset x */
int       oy    FUNCARGTERM /* offset y */
/*
X * creates a new monster onto the monster list
X * returns a pointer to the new monster
X */
{
X  MONSTER *mptr;
X
X  assert(monster.monsters != MONSTERS);
X  assert(!(ox % VEL_X) && !(oy % VEL_Y));
X  mptr = &monster.list[monster.monsters++];
X  mptr->dir = dir;
X  mptr->type = type;
X  mptr->face = face;
X  mptr->apple = NULL;
X  mptr->push = 0;
X  mptr->gomunch = mptr->cont = mptr->chew = mptr->pause = mptr->stop = 0;
X  mptr->fast = mptr->pushing = 0;
X  mptr->count = 0;
X  mptr->cell.x = cx;
X  mptr->cell.y = cy;
X  mptr->offset.x = ox;
X  mptr->offset.y = oy;
X  mptr->pixel.x = PIXELX(cx, ox);
X  mptr->pixel.y = PIXELY(cy, oy);
X  mptr->image = random() % MONSTER_IMAGES;
X  mptr->cycle = random() % MONSTER_CYCLES;
X  mptr->shot = 0;
X  mptr->old_sprite = 0;
X  return mptr;
}
/*}}}*/
SHAR_EOF
chmod 0644 monster.c ||
echo 'restore of monster.c failed'
Wc_c="`wc -c < 'monster.c'`"
test 13476 -eq "$Wc_c" ||
	echo 'monster.c: original size 13476, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= move.c ==============
if test -f 'move.c' -a X"$1" != X"-c"; then
	echo 'x - skipping move.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting move.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'move.c' &&
/*{{{  (C) 1992 Nathan Sidwell*/
/*****************************************************************************
X			X M R I S V1.01
X			---------------
X		    (C) 1992 Nathan Sidwell
X
This program is copyright (C) 1992 Nathan Sidwell. This software and documentation
is in the public domain. Permission is granted to distribute and compile
verbatim copies of this software for non-commercial, non-profit use,
without fee. The software may be modified, provided that both the above copyright
notice and this permission notice appear.
X
No guarantee is given as to the robustness or suitability of this
software for your computer.
X
Nathan Sidwell  INMOS UK |                 | nathan@inmos.co.uk       DoD#0390
*****************************************************************************/
/*}}}*/
#include "xmris.h"
/*{{{  prototypes*/
static void munch_back PROTOARGLIST((int, int, int, int, int, int, SPRITE *));
/*}}}*/
/*{{{  unsigned choose_direction(valid)*/
extern unsigned choose_direction FUNCARGLIST((valid))
unsigned  valid FUNCARGTERM
/* picks a direction at random from the valid ones */
{
X  unsigned  choices;
X  unsigned  temp;
X  unsigned  choice;
X  
X  assert(valid && !(valid & ~0xF));
X  for(choices = 0, temp = valid; temp; choices++)
X    temp ^= temp & -temp;
X  if(choices == 1)
X    choice = 0;
X  else if(choices == 3)
X    choice = random() % 3;
X  else
X    choice = random() & (choices - 1);
X  do
X    {
X      temp = valid & -valid;
X      valid ^= temp;
X    }
X  while(choice--);
X  assert(temp);
X  for(valid = 0; !(temp & 1); valid++)
X    temp >>= 1;
X  return valid;
}
/*}}}*/
/*{{{  CELL *drop_apple(aptr, cptr)*/
extern CELL *drop_apple FUNCARGLIST((aptr, cptr))
APPLE   *aptr FUNCARGSEP
CELL    *cptr FUNCARGTERM
/*
X * deals with apples which break through to the cell below
X * the apple has already been moved to the new coordinate
X * returns NULL if we stay in the same cell, or a pointer
X * to the new cell
X */
{
X  CELL      *new;
X  COORD     pixel;
X
X  update.set = 0;
X  pixel.x = aptr->pixel.x - aptr->offset.x;
X  pixel.y = aptr->pixel.y - aptr->offset.y;
X  if(aptr->offset.y <= cptr[0].depths[1])
X    new = NULL;
X  else if(cptr[CELL_STRIDE].visit)
X    /*{{{  break through below*/
X    {
X      /*{{{  munch*/
X      {
X	SPRITE      *sptr;
X		      
X	sptr = &sprites[SPRITE_EDGE_BASE + 1];
X	/*{{{  munch the left half of the edge below*/
X	{
X	  unsigned  type;
X			
X	  type = 0;
X	  if(cptr[0].depths[2] < -VEL_X)
X	    type = GAP_HEIGHT;
X	  if(cptr[CELL_STRIDE].depths[2] < -VEL_X)
X	    type += 2 * GAP_HEIGHT;
X	  if(type == 3 * GAP_HEIGHT &&
X	      (cptr[-1].depths[1] > VEL_Y ||
X	      cptr[CELL_STRIDE-1].depths[0] < -VEL_Y))
X	    type = 4 * GAP_HEIGHT;
X	  munch_back(0, type,
X	      EDGE_WIDTH >> 1, GAP_HEIGHT,
X	      pixel.x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1),
X	      pixel.y + CELL_HEIGHT, sptr);
X	  if(!cptr[0].depths[2])
X	    munch_back(0, 0, EDGE_WIDTH >> 1, GAP_HEIGHT,
X		pixel.x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1),
X		pixel.y + CELL_HEIGHT - GAP_WIDTH, sptr);
X	  if(!cptr[CELL_STRIDE].depths[2])
X	    munch_back(0, 0, EDGE_WIDTH >> 1, GAP_HEIGHT,
X		pixel.x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1),
X		pixel.y + CELL_HEIGHT + GAP_HEIGHT, sptr);
X	}
X	/*}}}*/
X	/*{{{  munch the right half of the edge below*/
X	{
X	  unsigned  type;
X			
X	  type = 0;
X	  if(cptr[0].depths[3] > VEL_X)
X	    type = GAP_HEIGHT;
X	  if(cptr[CELL_STRIDE].depths[3] > VEL_X)
X	    type += 2 * GAP_HEIGHT;
X	  if(type == 3 * GAP_HEIGHT &&
X	      (cptr[1].depths[1] > VEL_Y ||
X	      cptr[CELL_STRIDE+1].depths[0] < -VEL_Y))
X	    type = 4 * GAP_HEIGHT;
X	  munch_back(EDGE_WIDTH >> 1, type,
X	      EDGE_WIDTH >> 1, GAP_HEIGHT,
X	      pixel.x + (CELL_WIDTH >> 1),
X	      pixel.y + CELL_HEIGHT, sptr);
X	  if(!cptr[0].depths[3])
X	    munch_back(EDGE_WIDTH >> 1, 0,
X		EDGE_WIDTH >> 1, GAP_HEIGHT,
X		pixel.x + (CELL_WIDTH >> 1),
X		pixel.y + CELL_HEIGHT - GAP_WIDTH, sptr);
X	  if(!cptr[CELL_STRIDE].depths[3])
X	    munch_back(EDGE_WIDTH >> 1, 0,
X		EDGE_WIDTH >> 1, GAP_HEIGHT,
X		pixel.x + (CELL_WIDTH >> 1),
X		pixel.y + CELL_HEIGHT + GAP_HEIGHT, sptr);
X	}
X	/*}}}*/
X      }
X      /*}}}*/
X      aptr->offset.y -= CELL_HEIGHT + GAP_HEIGHT;
X      aptr->cell.y += 1;
X      pixel.y += CELL_HEIGHT + GAP_HEIGHT;
X      global.broken = 1;
X      cptr[0].depths[1] = CELL_HEIGHT + GAP_HEIGHT;
X      new = cptr + CELL_STRIDE;
X      cptr[CELL_STRIDE].depths[0] = -(CELL_HEIGHT + GAP_HEIGHT);
X    }
X    /*}}}*/
X  else if(aptr->offset.y - cptr[CELL_STRIDE * 2].depths[0] >=
X      CELL_HEIGHT + GAP_HEIGHT)
X    /*{{{  breakthrough 2 below*/
X    {
X      aptr->offset.y -= CELL_HEIGHT + GAP_HEIGHT;
X      aptr->cell.y += 1;
X      pixel.y += CELL_HEIGHT + GAP_HEIGHT;
X      global.broken = 1;
X      cptr[CELL_STRIDE].visit = 1;
X      cptr[0].depths[1] = CELL_HEIGHT + GAP_HEIGHT;
X      cptr[CELL_STRIDE].depths[0] = -(CELL_HEIGHT + GAP_HEIGHT);
X      cptr[CELL_STRIDE].depths[1] = CELL_HEIGHT + GAP_HEIGHT;
X      cptr[CELL_STRIDE * 2].depths[0] = -(CELL_HEIGHT + GAP_HEIGHT);
X      if(cptr[CELL_STRIDE - 1].depths[3])
X	{
X	  cptr[CELL_STRIDE].depths[2] = -(CELL_WIDTH + GAP_WIDTH);
X	  cptr[CELL_STRIDE-1].depths[3] = CELL_WIDTH + GAP_WIDTH;
X	}
X      if(cptr[CELL_STRIDE+1].depths[2])
X	{
X	  cptr[CELL_STRIDE].depths[3] = CELL_WIDTH + GAP_WIDTH;
X	  cptr[CELL_STRIDE+1].depths[2] = -(CELL_WIDTH + GAP_WIDTH);
X	}
X      munch_hole(cptr + CELL_STRIDE, pixel.x, pixel.y);
X      new = cptr + CELL_STRIDE;
X    }
X    /*}}}*/
X  else
X    new = NULL;
X  /*{{{  redraw prize?*/
X  if(new && new->sprite)
X    {
X      SPRITE    *sptr;
X	
X      sptr = &sprites[new->sprite];
X      if(display.background != COLOUR_ZERO)
X	XCopyArea(display.display, sptr->mask, display.back, GCN(GC_MASK),
X	    0, 0, CELL_WIDTH, CELL_HEIGHT,
X	    pixel.x, pixel.y);
X      XCopyArea(display.display, sptr->image, display.back, GCN(GC_OR),
X	  0, 0, CELL_WIDTH, CELL_HEIGHT,
X	  pixel.x, pixel.y);
X    }
X  /*}}}*/
X  if(update.set)
X    add_background(update.tl.x, update.tl.y,
X	update.br.x - update.tl.x, update.br.y - update.tl.y);
X  return new;
}
/*}}}*/
/*{{{  CELL *move_movable(mptr, cptr)*/
extern CELL *move_movable FUNCARGLIST((mptr, cptr))
MONSTER   *mptr FUNCARGSEP
CELL      *cptr FUNCARGTERM
{
X  unsigned  delta;
X  
X  switch(mptr->dir)
X  {
X    /*{{{  case 0: (up)*/
X    case 0:
X      if(!mptr->fast)
X	delta = VEL_Y;
X      else if(mptr->offset.y > (CELL_HEIGHT + GAP_HEIGHT) - VEL_Y_FAST * FAST_STEPS)
X	delta = VEL_Y_FAST;
X      else if(mptr->offset.y > GAP_HEIGHT + VEL_Y_FAST * FAST_STEPS)
X	delta = VEL_Y;
X      else if(mptr->offset.y > GAP_HEIGHT)
X	delta = VEL_Y_FAST;
X      else if(mptr->offset.y > 0)
X	delta = VEL_Y;
X      else if(mptr->offset.y > - VEL_Y_FAST * FAST_STEPS)
X	delta = VEL_Y_FAST;
X      else if(mptr->offset.y > - CELL_HEIGHT + VEL_Y_FAST * FAST_STEPS)
X	delta = VEL_Y;
X      else if(mptr->offset.y > - CELL_HEIGHT)
X	delta = VEL_Y_FAST;
X      else
X	delta = VEL_Y;
X      mptr->pixel.y -= delta;
X      mptr->offset.y -= delta;
X      if(mptr->offset.y == -(CELL_HEIGHT + GAP_HEIGHT))
X	{
X	  mptr->offset.y = 0;
X	  mptr->cell.y -= 1;
X	  cptr -= CELL_STRIDE;
X	}
X      assert(cptr->visit && !mptr->offset.x && mptr->cell.y >= 0);
X      break;
X    /*}}}*/
X    /*{{{  case 1: (down)*/
X    case 1:
X      if(!mptr->fast)
X	delta = VEL_Y;
X      else if(mptr->offset.y < -(CELL_HEIGHT + GAP_HEIGHT) + VEL_Y_FAST * FAST_STEPS)
X	delta = VEL_Y_FAST;
X      else if(mptr->offset.y < - GAP_HEIGHT - VEL_Y_FAST * FAST_STEPS)
X	delta = VEL_Y;
X      else if(mptr->offset.y < -GAP_HEIGHT)
X	delta = VEL_Y_FAST;
X      else if(mptr->offset.y < 0)
X	delta = VEL_Y;
X      else if(mptr->offset.y < VEL_Y_FAST * FAST_STEPS)
X	delta = VEL_Y_FAST;
X      else if(mptr->offset.y < CELL_HEIGHT - VEL_Y_FAST * FAST_STEPS)
X	delta = VEL_Y;
X      else if(mptr->offset.y < CELL_HEIGHT)
X	delta = VEL_Y_FAST;
X      else
X	delta = VEL_Y;
X      mptr->pixel.y += delta;
X      mptr->offset.y += delta;
X      if(mptr->offset.y == CELL_HEIGHT + GAP_HEIGHT)
X	{
X	  mptr->offset.y = 0;
X	  mptr->cell.y += 1;
X	  cptr += CELL_STRIDE;
X	}
X      assert(cptr->visit && mptr->cell.y < CELLS_DOWN &&
X	  (!mptr->offset.x || (!mptr->cell.y && mptr->offset.y <= 0)));
X      break;
X    /*}}}*/
X    /*{{{  case 2: (left)*/
X    case 2:
X      if(!mptr->fast)
X	delta = VEL_X;
X      else if(mptr->offset.x > (CELL_WIDTH + GAP_WIDTH) - VEL_X_FAST * FAST_STEPS)
X	delta = VEL_X_FAST;
X      else if(mptr->offset.x > GAP_WIDTH + VEL_X_FAST * FAST_STEPS)
X	delta = VEL_X;
X      else if(mptr->offset.x > GAP_WIDTH)
X	delta = VEL_X_FAST;
X      else if(mptr->offset.x > 0)
X	delta = VEL_X;
X      else if(mptr->offset.x > - VEL_X_FAST * FAST_STEPS)
X	delta = VEL_X_FAST;
X      else if(mptr->offset.x > - CELL_WIDTH + VEL_X_FAST * FAST_STEPS)
X	delta = VEL_X;
X      else if(mptr->offset.x > -CELL_WIDTH)
X	delta = VEL_X_FAST;
X      else
X	delta = VEL_X;
X      mptr->pixel.x -= delta;
X      mptr->offset.x -= delta;
X      if(mptr->offset.x == -(CELL_WIDTH + GAP_WIDTH))
X	{
X	  mptr->offset.x = 0;
X	  mptr->cell.x -= 1;
X	  cptr -= 1;
X	}
X      assert(cptr->visit && !mptr->offset.y && mptr->cell.x >= 0);
X      break;
X    /*}}}*/
X    /*{{{  case 3: (right)*/
X    case 3:
X      if(!mptr->fast)
X	delta = VEL_X;
X      else if(mptr->offset.x < -(CELL_WIDTH + GAP_WIDTH) + VEL_X_FAST * FAST_STEPS)
X	delta = VEL_X_FAST;
X      else if(mptr->offset.x < - GAP_WIDTH - VEL_X_FAST * FAST_STEPS)
X	delta = VEL_X;
X      else if(mptr->offset.x < -GAP_WIDTH)
X	delta = VEL_X_FAST;
X      else if(mptr->offset.x < 0)
X	delta = VEL_X;
X      else if(mptr->offset.x < VEL_X_FAST * FAST_STEPS)
X	delta = VEL_X_FAST;
X      else if(mptr->offset.x < CELL_WIDTH - VEL_X_FAST * FAST_STEPS)
X	delta = VEL_X;
X      else if(mptr->offset.x < CELL_WIDTH)
X	delta = VEL_X_FAST;
X      else
X	delta = VEL_X;
X      mptr->pixel.x += delta;
X      mptr->offset.x += delta;
X      if(mptr->offset.x == CELL_WIDTH + GAP_WIDTH)
X	{
X	  mptr->offset.x = 0;
X	  mptr->cell.x += 1;
X	  cptr += 1;
X	}
X      assert(cptr->visit && !mptr->offset.y && mptr->cell.x < CELLS_ACROSS);
X      break;
X    /*}}}*/
X  }
X  return cptr;
}
/*}}}*/
/*{{{  CELL *move_muncher(mptr)*/
extern CELL *move_muncher FUNCARGLIST((mptr))
MONSTER   *mptr FUNCARGTERM /* the object to move */
/*
X * moves and munches the board for an object which can munch
X * apple checking is performed here too
X * (ie the man, or a munch monster)
X * the board array is updated as required
X * returns a pointer to the new cell, if we have arrived elsewhere
X * or NULL if we stayed on the same cell
X */
{
X  unsigned  broke;
X  CELL      *nptr;
X  CELL      *cherry;
X  CELL      *cptr;
X  COORD     pixel;
X  COORD     cell;
X  SPRITE    *sptr;
X  int       knocked;
X
X  assert(!mptr->stop && !mptr->pause);
X  broke = 0;
X  nptr = NULL;
X  cherry = NULL;
X  update.set = 0;
X  cell.x = mptr->cell.x;
X  cell.y = mptr->cell.y;
X  cptr = BOARDCELL(cell.x, cell.y);
X  pixel.x = PIXELX(cell.x, 0);
X  pixel.y = PIXELY(cell.y, 0);
X  knocked = 0;
X  if(!apple_stop(mptr, cptr))
X    {
X      switch(mptr->dir)
X      {
X	/*{{{  case 0: (up)*/
X	case 0:
X	  /*
X	   * if the depth upwards is less than the future depth,
X	   * then we have to do some munching
X	   */
X	  mptr->offset.y -= VEL_Y;
X	  mptr->pixel.y = pixel.y + mptr->offset.y;
X	  if(cptr[0].depths[0] > mptr->offset.y)
X	    /*{{{  munch*/
X	    {
X	      cptr[0].depths[0] = mptr->offset.y;
X	      sptr = &sprites[SPRITE_MUNCH_BASE + 0];
X	      munch_back(0, 0, CELL_WIDTH, MUNCH_HEIGHT >> 1,
X		  pixel.x, pixel.y + cptr->depths[0], sptr);
X	      if(mptr->offset.y == -VEL_Y && cptr[-CELL_STRIDE].visit)
X		{
X		  sptr = &sprites[SPRITE_EDGE_BASE + 1];
X		  /*{{{  munch the left half of the edge above*/
X		  {
X		    unsigned  type;
X						    
X		    type = 0;
X		    if(cptr[0].depths[2] < -VEL_X)
X		      type = 2 * GAP_HEIGHT;
X		    if(cptr[-CELL_STRIDE].depths[2] < -VEL_X)
X		      type += GAP_HEIGHT;
X		    if(type == 3 * GAP_HEIGHT &&
X			(cptr[-1].depths[0] < -VEL_Y ||
X			cptr[-CELL_STRIDE-1].depths[1] > VEL_Y))
X		      type = 4 * GAP_HEIGHT;
X		    munch_back(0, type,
X			EDGE_WIDTH >> 1, GAP_HEIGHT,
X			pixel.x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1),
X			pixel.y - GAP_HEIGHT, sptr);
X		    if(!cptr[-CELL_STRIDE].depths[2])
X		      munch_back(0, 0, EDGE_WIDTH >> 1, GAP_HEIGHT,
X			  pixel.x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1),
X			  pixel.y - GAP_HEIGHT * 2, sptr);
X		  }
X		  /*}}}*/
X		  /*{{{  munch the right half of the edge above*/
X		  {
X		    unsigned  type;
X						    
X		    type = 0;
X		    if(cptr[0].depths[3] > VEL_X)
X		      type = 2 * GAP_HEIGHT;
X		    if(cptr[-CELL_STRIDE].depths[3] > VEL_X)
X		      type += GAP_HEIGHT;
X		    if(type == 3 * GAP_HEIGHT &&
X			(cptr[1].depths[0] < -VEL_Y ||
X			cptr[-CELL_STRIDE+1].depths[1] > VEL_Y))
X		      type = 4 * GAP_HEIGHT;
X		    munch_back(EDGE_WIDTH >> 1, type,
X			EDGE_WIDTH >> 1, GAP_HEIGHT,
X			pixel.x + (CELL_WIDTH >> 1),
X			pixel.y - GAP_HEIGHT, sptr);
X		    if(!cptr[-CELL_STRIDE].depths[3])
X		      munch_back(EDGE_WIDTH >> 1, 0,
X			  EDGE_WIDTH >> 1, GAP_HEIGHT,
X			  pixel.x + (CELL_WIDTH >> 1),
X			  pixel.y - GAP_HEIGHT * 2, sptr);
X		  }
X		  /*}}}*/
X		  cptr[0].depths[0] = -(CELL_HEIGHT + GAP_HEIGHT);
X		  cptr[-CELL_STRIDE].depths[1] = CELL_HEIGHT + GAP_HEIGHT;
X		  broke = 1;
X		}
X	      else
X		{
X		  if(mptr->offset.y == -(VEL_Y * 2))
X		    {
X		      sptr = &sprites[SPRITE_EDGE_BASE + 1];
X		      /*{{{  round top left corner?*/
X		      if(cptr[0].depths[2] < -VEL_X)
X			munch_back(0, 2 * GAP_HEIGHT,
X			    EDGE_WIDTH >> 1, GAP_HEIGHT,
X			    pixel.x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1),
X			    pixel.y - GAP_HEIGHT, sptr);
X		      /*}}}*/
X		      /*{{{  round top right corner?*/
X		      if(cptr[0].depths[3] > VEL_X)
X			munch_back(EDGE_WIDTH >> 1, 2 * GAP_HEIGHT,
X			    EDGE_WIDTH >> 1, GAP_HEIGHT,
X			    pixel.x + (CELL_WIDTH >> 1),
X			    pixel.y - GAP_HEIGHT, sptr);
X		      /*}}}*/
X		    }
X		  /*{{{  knocked through?*/
X		  /*
X		   * have we bumped into any of the following ?
X		   * path from 2 above me
X		   * path from above left
X		   * path from above right
X		   */
X		  if((cptr[-CELL_STRIDE*2].depths[1] - cptr[0].depths[0] >=
X		      CELL_HEIGHT + GAP_HEIGHT * 2) ||
X		      (cptr[-CELL_STRIDE-1].depths[3] &&
X			cptr[-CELL_STRIDE-1].depths[3] - cptr[0].depths[0] >=
X			KNOCK_THROUGH) ||
X		      (cptr[-CELL_STRIDE+1].depths[2] &&
X			cptr[-CELL_STRIDE+1].depths[2] + cptr[0].depths[0] <=
X			-KNOCK_THROUGH))
X		    {
X		      knocked = -CELL_STRIDE;
X		      pixel.y -= CELL_HEIGHT + GAP_HEIGHT;
X		      cell.y -= 1;
X		    }
X		  else
X		    {
X		      if(cptr->depths[0] == -(CELL_HEIGHT + GAP_HEIGHT))
X			{
X			  cptr[-CELL_STRIDE].visit = 1;
X			  cptr[-CELL_STRIDE].depths[1] =
X			      CELL_HEIGHT + GAP_HEIGHT;
X			}
X		      cherry = cptr - CELL_STRIDE;
X		      pixel.y -= CELL_HEIGHT + GAP_HEIGHT;
X		    }
X		  /*}}}*/
X		}
X	    }
X	    /*}}}*/
X	  else if(mptr->offset.y < -VEL_Y)
X	    {
X	      cherry = cptr - CELL_STRIDE;
X	      pixel.y -= CELL_HEIGHT + GAP_HEIGHT;
X	    }
X	  if(mptr->offset.y == -(CELL_HEIGHT + GAP_HEIGHT))
X	    {
X	      mptr->offset.y = 0;
X	      mptr->cell.y--;
X	      nptr = cptr - CELL_STRIDE;
X	    }
X	  break;
X	/*}}}*/
X	/*{{{  case 1: (down)*/
X	case 1:
X	{
X	  mptr->offset.y += VEL_Y;
X	  mptr->pixel.y = pixel.y + mptr->offset.y;
X	  if(cptr->depths[1] < mptr->offset.y)
X	    /*{{{  munch*/
X	    {
X	      cptr->depths[1] = mptr->offset.y;
X	      sptr = &sprites[SPRITE_MUNCH_BASE + 0];
X	      munch_back(0, MUNCH_HEIGHT >> 1,
X		  CELL_WIDTH, MUNCH_HEIGHT >> 1,
X		  pixel.x, pixel.y + cptr[0].depths[1] +
X		  CELL_HEIGHT - (MUNCH_HEIGHT >> 1), sptr);
X	      if(mptr->offset.y == VEL_Y && cptr[CELL_STRIDE].visit)
X		{
X		  sptr = &sprites[SPRITE_EDGE_BASE + 1];
X		  /*{{{  munch the left half of the edge below*/
X		  {
X		    unsigned  type;
X						    
X		    type = 0;
X		    if(cptr[0].depths[2] < -VEL_X)
X		      type = GAP_HEIGHT;
X		    if(cptr[CELL_STRIDE].depths[2] < -VEL_X)
X		      type += 2 * GAP_HEIGHT;
X		    if(type == 3 * GAP_HEIGHT &&
X			(cptr[-1].depths[1] > VEL_Y ||
X			cptr[CELL_STRIDE-1].depths[0] < -VEL_Y))
X		      type = 4 * GAP_HEIGHT;
X		    munch_back(0, type,
X			EDGE_WIDTH >> 1, GAP_HEIGHT,
X			pixel.x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1),
X			pixel.y + CELL_HEIGHT, sptr);
X		    if(!cptr[CELL_STRIDE].depths[2])
X		      munch_back(0, 0, EDGE_WIDTH >> 1, GAP_HEIGHT,
X			  pixel.x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1),
X			  pixel.y + CELL_HEIGHT + GAP_HEIGHT, sptr);
X		  }
X		  /*}}}*/
X		  /*{{{  munch the right half of the edge below*/
X		  {
X		    unsigned  type;
X						    
X		    type = 0;
X		    if(cptr[0].depths[3] > VEL_X)
X		      type = GAP_HEIGHT;
X		    if(cptr[CELL_STRIDE].depths[3] > VEL_X)
X		      type += 2 * GAP_HEIGHT;
X		    if(type == 3 * GAP_HEIGHT &&
X			(cptr[1].depths[1] > VEL_Y ||
X			cptr[CELL_STRIDE+1].depths[0] < -VEL_Y))
X		      type = 4 * GAP_HEIGHT;
X		    munch_back(EDGE_WIDTH >> 1, type,
X			EDGE_WIDTH >> 1, GAP_HEIGHT,
X			pixel.x + (CELL_WIDTH >> 1),
X			pixel.y + CELL_HEIGHT, sptr);
X		    if(!cptr[CELL_STRIDE].depths[3])
X		      munch_back(EDGE_WIDTH >> 1, 0,
X			  EDGE_WIDTH >> 1, GAP_HEIGHT,
X			  pixel.x + (CELL_WIDTH >> 1),
X			  pixel.y + CELL_HEIGHT + GAP_HEIGHT, sptr);
X		  }
X		  /*}}}*/
X		  cptr[0].depths[1] = CELL_HEIGHT + GAP_HEIGHT;
X		  cptr[CELL_STRIDE].depths[0] = -(CELL_HEIGHT + GAP_HEIGHT);
X		  broke = 1;
X		}
X	      else
X		{
X		  if(mptr->offset.y == (VEL_Y * 2))
X		    {
X		      sptr = &sprites[SPRITE_EDGE_BASE + 1];
X		      /*{{{  round bottom left corner?*/
X		      if(cptr[0].depths[2] < -VEL_X)
X			munch_back(0, GAP_HEIGHT,
X			    EDGE_WIDTH >> 1, GAP_HEIGHT,
X			    pixel.x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1),
X			    pixel.y + CELL_HEIGHT, sptr);
X		      /*}}}*/
X		      /*{{{  round bottom right corner?*/
X		      if(cptr[0].depths[3] > VEL_X)
X			munch_back(EDGE_WIDTH >> 1, GAP_HEIGHT,
X			    EDGE_WIDTH >> 1, GAP_HEIGHT,
X			    pixel.x + (CELL_WIDTH >> 1),
X			    pixel.y + CELL_HEIGHT, sptr);
X		      /*}}}*/
X		    }
X		  /*{{{  knocked through?*/
X		  /*
X		   * have we bumped into any of the following ?
X		   * path from 2 below me
X		   * path from below left
X		   * path from below right
X		   */
X		  if((cptr[0].depths[1] - cptr[CELL_STRIDE*2].depths[0] >=
X		      CELL_HEIGHT + GAP_HEIGHT * 2) ||
X		      (cptr[CELL_STRIDE-1].depths[3] &&
X			cptr[CELL_STRIDE-1].depths[3] + cptr[0].depths[1] >=
X			KNOCK_THROUGH) ||
X		      (cptr[CELL_STRIDE+1].depths[2] &&
X			cptr[0].depths[1] - cptr[CELL_STRIDE+1].depths[2] >=
X			KNOCK_THROUGH))
X		    {
X		      knocked = CELL_STRIDE;
X		      pixel.y += CELL_HEIGHT + GAP_HEIGHT;
X		      cell.y += 1;
X		    }
X		  else
X		    {
X		      if(cptr->depths[1] == (CELL_HEIGHT + GAP_HEIGHT))
X			{
X			  cptr[CELL_STRIDE].visit = 1;
X			  cptr[CELL_STRIDE].depths[0] =
X			      -(CELL_HEIGHT + GAP_HEIGHT);
X			}
X		      cherry = cptr + CELL_STRIDE;
X		      pixel.y += CELL_HEIGHT + GAP_HEIGHT;
X		    }
X		  /*}}}*/
X		}
X	    }
X	    /*}}}*/
X	  else if(mptr->offset.y > VEL_Y)
X	    {
X	      cherry = cptr + CELL_STRIDE;
X	      pixel.y += CELL_HEIGHT + GAP_HEIGHT;
X	    }
X	  if(mptr->offset.y == (CELL_HEIGHT + GAP_HEIGHT))
X	    {
X	      mptr->offset.y = 0;
X	      mptr->cell.y++;
X	      nptr = cptr + CELL_STRIDE;
X	    }
X	  break;
X	}
X	/*}}}*/
X	/*{{{  case 2: (left)*/
X	case 2:
X	{
X	  mptr->offset.x -= VEL_X;
X	  mptr->pixel.x = pixel.x + mptr->offset.x;
X	  if(cptr[0].depths[2] > mptr->offset.x)
X	    /*{{{  munch*/
X	    {
X	      cptr[0].depths[2] = mptr->offset.x;
X	      sptr = &sprites[SPRITE_MUNCH_BASE + 1];
X	      munch_back(0, 0, MUNCH_WIDTH >> 1, CELL_HEIGHT,
X		  pixel.x + cptr[0].depths[2], pixel.y, sptr);
X	      if(mptr->offset.x == -VEL_X && cptr[-1].visit)
X		{
X		  sptr = &sprites[SPRITE_EDGE_BASE + 0];
X		  /*{{{  munch the top half of the edge left*/
X		  {
X		    unsigned  type;
X						    
X		    type = 0;
X		    if(cptr[0].depths[0] < -VEL_Y)
X		      type = 2 * GAP_WIDTH;
X		    if(cptr[-1].depths[0] < -VEL_Y)
X		      type += GAP_WIDTH;
X		    if(type == 3 * GAP_WIDTH &&
X			(cptr[-CELL_STRIDE].depths[2] < -VEL_X ||
X			cptr[-CELL_STRIDE-1].depths[3] > VEL_X))
X		      type = 4 * GAP_WIDTH;
X		    munch_back(type, 0,
X			GAP_HEIGHT, EDGE_HEIGHT >> 1,
X			pixel.x - GAP_WIDTH,
X			pixel.y + (CELL_HEIGHT >> 1) - (EDGE_HEIGHT >> 1),
X			sptr);
X		    if(!cptr[-1].depths[0])
X		      munch_back(0, 0, GAP_WIDTH, EDGE_HEIGHT >> 1,
X			  pixel.x - GAP_WIDTH * 2,
X			  pixel.y + (CELL_HEIGHT >> 1) - (EDGE_HEIGHT >> 1),
X			  sptr);
X		  }
X		  /*}}}*/
X		  /*{{{  munch the bottom half of the edge left*/
X		  {
X		    unsigned  type;
X						    
X		    type = 0;
X		    if(cptr[0].depths[1] > VEL_Y)
X		      type = 2 * GAP_WIDTH;
X		    if(cptr[-1].depths[1] > VEL_Y)
X		      type += GAP_WIDTH;
X		    if(type == 3 * GAP_WIDTH &&
X			(cptr[CELL_STRIDE].depths[2] < -VEL_X ||
X			cptr[CELL_STRIDE-1].depths[3] > VEL_X))
X		      type = 4 * GAP_WIDTH;
X		    munch_back(type, EDGE_HEIGHT >> 1,
X			GAP_WIDTH, EDGE_HEIGHT >> 1,
X			pixel.x - GAP_WIDTH,
X			pixel.y + (CELL_HEIGHT >> 1), sptr);
X		    if(!cptr[-1].depths[1])
X		      munch_back(0, EDGE_HEIGHT >> 1,
X			  GAP_WIDTH, EDGE_HEIGHT >> 1,
X			  pixel.x - GAP_WIDTH * 2,
X			  pixel.y + (CELL_HEIGHT >> 1), sptr);
X		  }
X		  /*}}}*/
X		  cptr[0].depths[2] = -(CELL_WIDTH + GAP_WIDTH);
X		  cptr[-1].depths[3] = CELL_WIDTH + GAP_WIDTH;
X		  broke = 1;
X		}
X	      else
X		{
X		  if(mptr->offset.x == -(VEL_X * 2))
X		    {
X		      sptr = &sprites[SPRITE_EDGE_BASE + 0];
X		      /*{{{  round left top corner?*/
X		      if(cptr[0].depths[0] < -VEL_Y)
X			munch_back(2 * GAP_WIDTH, 0,
X			    GAP_WIDTH, EDGE_HEIGHT >> 1,
X			    pixel.x - GAP_WIDTH,
X			    pixel.y + (CELL_HEIGHT >> 1) - (EDGE_HEIGHT >> 1),
X			    sptr);
X		      /*}}}*/
X		      /*{{{  round left bottom corner?*/
X		      if(cptr[0].depths[1] > VEL_Y)
X			munch_back(2 * GAP_HEIGHT, EDGE_HEIGHT >> 1,
X			    GAP_WIDTH, EDGE_HEIGHT >> 1,
X			    pixel.x - GAP_WIDTH,
X			    pixel.y + (CELL_HEIGHT >> 1), sptr);
X		      /*}}}*/
X		    }
X		  /*{{{  knocked through?*/
X		  /*
X		   * have we bumped into any of the following ?
X		   * path from 2 left me
X		   * path from left above
X		   * path from left below
X		   */
X		  if((cptr[-2].depths[3] - cptr[0].depths[2] >=
X		      CELL_WIDTH + GAP_WIDTH * 2) ||
X		      (cptr[-CELL_STRIDE-1].depths[1] &&
X			cptr[-CELL_STRIDE-1].depths[1] - cptr[0].depths[2] >=
X			KNOCK_THROUGH) ||
X		      (cptr[CELL_STRIDE-1].depths[0] &&
X			cptr[CELL_STRIDE-1].depths[0] + cptr[0].depths[2] <=
X			-KNOCK_THROUGH))
X		    {
X		      knocked = -1;
X		      pixel.x -= CELL_WIDTH + GAP_WIDTH;
X		      cell.x -= 1;
X		    }
X		  else
X		    {
X		      if(cptr->depths[2] == -(CELL_WIDTH + GAP_WIDTH))
X			{
X			  cptr[-1].visit = 1;
X			  cptr[-1].depths[3] = CELL_WIDTH + GAP_WIDTH;
X			}
X		      cherry = cptr - 1;
X		      pixel.x -= CELL_WIDTH + GAP_WIDTH;
X		    }
X		  /*}}}*/
X		}
X	    }
X	    /*}}}*/
X	  else if(mptr->offset.x < -VEL_X)
X	    {
X	      cherry = cptr - 1;
X	      pixel.x -= CELL_WIDTH + GAP_WIDTH;
X	    }
X	  if(mptr->offset.x == -(CELL_WIDTH + GAP_WIDTH))
X	    {
X	      mptr->offset.x = 0;
X	      mptr->cell.x--;
X	      nptr = cptr - 1;
X	    }
X	  break;
X	}
X	/*}}}*/
X	/*{{{  case 3: (right)*/
X	case 3:
X	{
X	  mptr->offset.x += VEL_X;
X	  mptr->pixel.x = pixel.x + mptr->offset.x;
X	  if(cptr->depths[3] < mptr->offset.x)
X	    /*{{{  munch*/
X	    {
X	      cptr->depths[3] = mptr->offset.x;
X	      sptr = &sprites[SPRITE_MUNCH_BASE + 1];
X	      munch_back(MUNCH_WIDTH >> 1, 0,
X		  MUNCH_WIDTH >> 1, CELL_HEIGHT,
X		  pixel.x + cptr->depths[3] +
X		  CELL_HEIGHT - (MUNCH_WIDTH >> 1), pixel.y, sptr);
X	      if(mptr->offset.x == VEL_X && cptr[1].visit)
X		{
X		  sptr = &sprites[SPRITE_EDGE_BASE + 0];
X		  /*{{{  munch the top half of the edge right*/
X		  {
X		    unsigned  type;
X						    
X		    type = 0;
X		    if(cptr[0].depths[0] < -VEL_Y)
X		      type = GAP_WIDTH;
X		    if(cptr[1].depths[0] < -VEL_Y)
X		      type += 2 * GAP_WIDTH;
X		    if(type == 3 * GAP_WIDTH &&
X		      (cptr[-CELL_STRIDE].depths[3] > VEL_X ||
X			cptr[-CELL_STRIDE+1].depths[2] < -VEL_X))
X		      type = 4 * GAP_WIDTH;
X		    munch_back(type, 0,
X			GAP_WIDTH, EDGE_HEIGHT >> 1,
X			pixel.x + CELL_WIDTH, pixel.y +
X			(CELL_HEIGHT >> 1) - (EDGE_HEIGHT >> 1), sptr);
X		    if(!cptr[1].depths[0])
X		      munch_back(0, 0, GAP_WIDTH, EDGE_HEIGHT >> 1,
X			  pixel.x + CELL_WIDTH + GAP_WIDTH, pixel.y +
X			  (CELL_HEIGHT >> 1) - (EDGE_HEIGHT >> 1), sptr);
X		  }
X		  /*}}}*/
X		  /*{{{  munch the bottom half of the edge right*/
X		  {
X		    unsigned  type;
X						    
X		    type = 0;
X		    if(cptr[0].depths[1] > VEL_Y)
X		      type = GAP_WIDTH;
X		    if(cptr[1].depths[1] > VEL_Y)
X		      type += 2 * GAP_WIDTH;
X		    if(type == 3 * GAP_WIDTH &&
X			(cptr[CELL_STRIDE].depths[3] > VEL_X ||
X			cptr[CELL_STRIDE+1].depths[2] < -VEL_X))
X		      type = 4 * GAP_WIDTH;
X		    munch_back(type, EDGE_HEIGHT >> 1,
X			GAP_WIDTH, EDGE_HEIGHT >> 1,
X			pixel.x + CELL_WIDTH,
X			pixel.y + (CELL_HEIGHT >> 1), sptr);
X		    if(!cptr[1].depths[1])
X		      munch_back(0, EDGE_HEIGHT >> 1,
X			  GAP_WIDTH, EDGE_HEIGHT >> 1,
X			  pixel.x + CELL_WIDTH + GAP_WIDTH,
X			  pixel.y + (CELL_HEIGHT >> 1), sptr);
X		  }
X		  /*}}}*/
X		  cptr[0].depths[3] = CELL_WIDTH + GAP_WIDTH;
X		  cptr[1].depths[2] = -(CELL_WIDTH + GAP_WIDTH);
X		  broke = 1;
X		}
X	      else
X		{
X		  if(mptr->offset.x == (VEL_X * 2))
X		    {
X		      sptr = &sprites[SPRITE_EDGE_BASE + 0];
X		      /*{{{  round right top corner?*/
X		      if(cptr[0].depths[0] < -VEL_Y)
X			munch_back(GAP_HEIGHT, 0,
X			    GAP_WIDTH, EDGE_HEIGHT >> 1,
X			    pixel.x + CELL_WIDTH, pixel.y +
X			    (CELL_HEIGHT >> 1) - (EDGE_HEIGHT >> 1), sptr);
X		      /*}}}*/
X		      /*{{{  round right bottom corner?*/
X		      if(cptr[0].depths[1] > VEL_Y)
X			munch_back(GAP_WIDTH, EDGE_HEIGHT >> 1,
X			    GAP_WIDTH, EDGE_HEIGHT >> 1,
X			    pixel.x + CELL_WIDTH, pixel.y +
X			    (CELL_HEIGHT >> 1), sptr);
X		      /*}}}*/
X		    }
X		  /*{{{  knocked through?*/
X		  /*
X		   * have we bumped into any of the following ?
X		   * path from 2 right me
X		   * path from right above
X		   * path from right below
X		   */
X		  if((cptr[0].depths[3] - cptr[2].depths[2] >=
X		      CELL_WIDTH + GAP_WIDTH * 2) ||
X		      (cptr[-CELL_STRIDE+1].depths[1] &&
X			cptr[-CELL_STRIDE+1].depths[1] + cptr[0].depths[3] >=
X			KNOCK_THROUGH) ||
X		      (cptr[CELL_STRIDE+1].depths[0] &&
X			cptr[0].depths[3] - cptr[CELL_STRIDE+1].depths[0] >=
X			KNOCK_THROUGH))
X		    {
X		      knocked = 1;
X		      pixel.x += CELL_WIDTH + GAP_WIDTH;
X		      cell.x += 1;
X		    }
X		  else
X		    {
X		      if(cptr->depths[3] == (CELL_WIDTH + GAP_WIDTH))
X			{
X			  cptr[1].visit = 1;
X			  cptr[1].depths[2] = -(CELL_WIDTH + GAP_WIDTH);
X			}
X		      cherry = cptr + 1;
X		      pixel.x += CELL_WIDTH + GAP_WIDTH;
X		    }
X		  /*}}}*/
X		}
X	    }
X	    /*}}}*/
X	  else if(mptr->offset.x > VEL_X)
X	    {
X	      cherry = cptr + 1;
X	      pixel.x += CELL_WIDTH + GAP_WIDTH;
X	    }
X	  if(mptr->offset.x == (CELL_WIDTH + GAP_WIDTH))
X	    {
X	      mptr->offset.x = 0;
X	      mptr->cell.x++;
X	      nptr = cptr + 1;
X	    }
X	  break;
X	}
X	/*}}}*/
X      }
X      apple_under(mptr, nptr ? nptr : cptr);
X    }
X  /*{{{  knocked through?*/
X  /*
X   * if we knocked through to an adjoining cell
X   * we clear out the specified cell and check all the corners
X   * note, cell has already been altered correctly
X   * we must also check to se if this launches an apple
X   */
X  if(knocked)
X    {
X      unsigned  i;
X      APPLE     *aptr;
X	
X      broke = 1;
X      cherry = cptr += knocked;
X      cptr[0].visit = 1;
X      /*{{{  alter the depths*/
X      {
X	if(cptr[-CELL_STRIDE].depths[1])
X	  {
X	    cptr[0].depths[0] = -(CELL_HEIGHT + GAP_HEIGHT);
SHAR_EOF
true || echo 'restore of move.c failed'
fi
echo 'End of  part 4'
echo 'File move.c is continued in part 5'
echo 5 > _shar_seq_.tmp
exit 0
-- 
---
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
