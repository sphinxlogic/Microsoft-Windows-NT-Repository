Newsgroups: comp.sources.x
Path: uunet!uunet!elroy.jpl.nasa.gov!sdd.hp.com!mips!msi!dcmartin
From: Nathan Sidwell <nathan@inmos.co.uk>
Subject: v18i075: xmris version 2.00, Patch1, Part04/05
Message-ID: <1992Jul29.181129.15707@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
References: <csx-18i072-xmris@uunet.UU.NET>
Date: Wed, 29 Jul 1992 18:11:29 GMT
Approved: dcmartin@msi.com
Lines: 1725

Submitted-by: Nathan Sidwell <nathan@inmos.co.uk>
Posting-number: Volume 18, Issue 75
Archive-name: xmris/patch1.04
Patch-To: xmris: Volume XXX, Issue XXX

#!/bin/sh
# this is part.04 (part 4 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file patch.v2.00 continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 4; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping patch.v2.00'
else
echo 'x - continuing file patch.v2.00'
sed 's/^X//' << 'SHAR_EOF' >> 'patch.v2.00' &&
X  			cptr[-CELL_STRIDE-1].depths[1] > VEL_Y))
X  		      type = 4 * GAP_HEIGHT;
! 		    munch_back(0, (int)type,
X  			EDGE_WIDTH >> 1, GAP_HEIGHT,
X  			pixel.x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1),
X  			pixel.y - GAP_HEIGHT, sptr);
***************
*** 412,418 ****
X  		  /*{{{  munch the right half of the edge above*/
X  		  {
X  		    unsigned  type;
! 						    
X  		    type = 0;
X  		    if(cptr[0].depths[3] > VEL_X)
X  		      type = 2 * GAP_HEIGHT;
--- 396,402 ----
X  		  /*{{{  munch the right half of the edge above*/
X  		  {
X  		    unsigned  type;
! 												    
X  		    type = 0;
X  		    if(cptr[0].depths[3] > VEL_X)
X  		      type = 2 * GAP_HEIGHT;
***************
*** 422,428 ****
X  			(cptr[1].depths[0] < -VEL_Y ||
X  			cptr[-CELL_STRIDE+1].depths[1] > VEL_Y))
X  		      type = 4 * GAP_HEIGHT;
! 		    munch_back(EDGE_WIDTH >> 1, type,
X  			EDGE_WIDTH >> 1, GAP_HEIGHT,
X  			pixel.x + (CELL_WIDTH >> 1),
X  			pixel.y - GAP_HEIGHT, sptr);
--- 406,412 ----
X  			(cptr[1].depths[0] < -VEL_Y ||
X  			cptr[-CELL_STRIDE+1].depths[1] > VEL_Y))
X  		      type = 4 * GAP_HEIGHT;
! 		    munch_back(EDGE_WIDTH >> 1, (int)type,
X  			EDGE_WIDTH >> 1, GAP_HEIGHT,
X  			pixel.x + (CELL_WIDTH >> 1),
X  			pixel.y - GAP_HEIGHT, sptr);
***************
*** 525,531 ****
X  		  /*{{{  munch the left half of the edge below*/
X  		  {
X  		    unsigned  type;
! 						    
X  		    type = 0;
X  		    if(cptr[0].depths[2] < -VEL_X)
X  		      type = GAP_HEIGHT;
--- 509,515 ----
X  		  /*{{{  munch the left half of the edge below*/
X  		  {
X  		    unsigned  type;
! 												    
X  		    type = 0;
X  		    if(cptr[0].depths[2] < -VEL_X)
X  		      type = GAP_HEIGHT;
***************
*** 535,541 ****
X  			(cptr[-1].depths[1] > VEL_Y ||
X  			cptr[CELL_STRIDE-1].depths[0] < -VEL_Y))
X  		      type = 4 * GAP_HEIGHT;
! 		    munch_back(0, type,
X  			EDGE_WIDTH >> 1, GAP_HEIGHT,
X  			pixel.x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1),
X  			pixel.y + CELL_HEIGHT, sptr);
--- 519,525 ----
X  			(cptr[-1].depths[1] > VEL_Y ||
X  			cptr[CELL_STRIDE-1].depths[0] < -VEL_Y))
X  		      type = 4 * GAP_HEIGHT;
! 		    munch_back(0, (int)type,
X  			EDGE_WIDTH >> 1, GAP_HEIGHT,
X  			pixel.x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1),
X  			pixel.y + CELL_HEIGHT, sptr);
***************
*** 548,554 ****
X  		  /*{{{  munch the right half of the edge below*/
X  		  {
X  		    unsigned  type;
! 						    
X  		    type = 0;
X  		    if(cptr[0].depths[3] > VEL_X)
X  		      type = GAP_HEIGHT;
--- 532,538 ----
X  		  /*{{{  munch the right half of the edge below*/
X  		  {
X  		    unsigned  type;
! 												    
X  		    type = 0;
X  		    if(cptr[0].depths[3] > VEL_X)
X  		      type = GAP_HEIGHT;
***************
*** 558,564 ****
X  			(cptr[1].depths[1] > VEL_Y ||
X  			cptr[CELL_STRIDE+1].depths[0] < -VEL_Y))
X  		      type = 4 * GAP_HEIGHT;
! 		    munch_back(EDGE_WIDTH >> 1, type,
X  			EDGE_WIDTH >> 1, GAP_HEIGHT,
X  			pixel.x + (CELL_WIDTH >> 1),
X  			pixel.y + CELL_HEIGHT, sptr);
--- 542,548 ----
X  			(cptr[1].depths[1] > VEL_Y ||
X  			cptr[CELL_STRIDE+1].depths[0] < -VEL_Y))
X  		      type = 4 * GAP_HEIGHT;
! 		    munch_back(EDGE_WIDTH >> 1, (int)type,
X  			EDGE_WIDTH >> 1, GAP_HEIGHT,
X  			pixel.x + (CELL_WIDTH >> 1),
X  			pixel.y + CELL_HEIGHT, sptr);
***************
*** 660,666 ****
X  		  /*{{{  munch the top half of the edge left*/
X  		  {
X  		    unsigned  type;
! 						    
X  		    type = 0;
X  		    if(cptr[0].depths[0] < -VEL_Y)
X  		      type = 2 * GAP_WIDTH;
--- 644,650 ----
X  		  /*{{{  munch the top half of the edge left*/
X  		  {
X  		    unsigned  type;
! 												    
X  		    type = 0;
X  		    if(cptr[0].depths[0] < -VEL_Y)
X  		      type = 2 * GAP_WIDTH;
***************
*** 670,676 ****
X  			(cptr[-CELL_STRIDE].depths[2] < -VEL_X ||
X  			cptr[-CELL_STRIDE-1].depths[3] > VEL_X))
X  		      type = 4 * GAP_WIDTH;
! 		    munch_back(type, 0,
X  			GAP_HEIGHT, EDGE_HEIGHT >> 1,
X  			pixel.x - GAP_WIDTH,
X  			pixel.y + (CELL_HEIGHT >> 1) - (EDGE_HEIGHT >> 1),
--- 654,660 ----
X  			(cptr[-CELL_STRIDE].depths[2] < -VEL_X ||
X  			cptr[-CELL_STRIDE-1].depths[3] > VEL_X))
X  		      type = 4 * GAP_WIDTH;
! 		    munch_back((int)type, 0,
X  			GAP_HEIGHT, EDGE_HEIGHT >> 1,
X  			pixel.x - GAP_WIDTH,
X  			pixel.y + (CELL_HEIGHT >> 1) - (EDGE_HEIGHT >> 1),
***************
*** 685,691 ****
X  		  /*{{{  munch the bottom half of the edge left*/
X  		  {
X  		    unsigned  type;
! 						    
X  		    type = 0;
X  		    if(cptr[0].depths[1] > VEL_Y)
X  		      type = 2 * GAP_WIDTH;
--- 669,675 ----
X  		  /*{{{  munch the bottom half of the edge left*/
X  		  {
X  		    unsigned  type;
! 												    
X  		    type = 0;
X  		    if(cptr[0].depths[1] > VEL_Y)
X  		      type = 2 * GAP_WIDTH;
***************
*** 695,701 ****
X  			(cptr[CELL_STRIDE].depths[2] < -VEL_X ||
X  			cptr[CELL_STRIDE-1].depths[3] > VEL_X))
X  		      type = 4 * GAP_WIDTH;
! 		    munch_back(type, EDGE_HEIGHT >> 1,
X  			GAP_WIDTH, EDGE_HEIGHT >> 1,
X  			pixel.x - GAP_WIDTH,
X  			pixel.y + (CELL_HEIGHT >> 1), sptr);
--- 679,685 ----
X  			(cptr[CELL_STRIDE].depths[2] < -VEL_X ||
X  			cptr[CELL_STRIDE-1].depths[3] > VEL_X))
X  		      type = 4 * GAP_WIDTH;
! 		    munch_back((int)type, EDGE_HEIGHT >> 1,
X  			GAP_WIDTH, EDGE_HEIGHT >> 1,
X  			pixel.x - GAP_WIDTH,
X  			pixel.y + (CELL_HEIGHT >> 1), sptr);
***************
*** 799,805 ****
X  		  /*{{{  munch the top half of the edge right*/
X  		  {
X  		    unsigned  type;
! 						    
X  		    type = 0;
X  		    if(cptr[0].depths[0] < -VEL_Y)
X  		      type = GAP_WIDTH;
--- 783,789 ----
X  		  /*{{{  munch the top half of the edge right*/
X  		  {
X  		    unsigned  type;
! 												    
X  		    type = 0;
X  		    if(cptr[0].depths[0] < -VEL_Y)
X  		      type = GAP_WIDTH;
***************
*** 809,815 ****
X  		      (cptr[-CELL_STRIDE].depths[3] > VEL_X ||
X  			cptr[-CELL_STRIDE+1].depths[2] < -VEL_X))
X  		      type = 4 * GAP_WIDTH;
! 		    munch_back(type, 0,
X  			GAP_WIDTH, EDGE_HEIGHT >> 1,
X  			pixel.x + CELL_WIDTH, pixel.y +
X  			(CELL_HEIGHT >> 1) - (EDGE_HEIGHT >> 1), sptr);
--- 793,799 ----
X  		      (cptr[-CELL_STRIDE].depths[3] > VEL_X ||
X  			cptr[-CELL_STRIDE+1].depths[2] < -VEL_X))
X  		      type = 4 * GAP_WIDTH;
! 		    munch_back((int)type, 0,
X  			GAP_WIDTH, EDGE_HEIGHT >> 1,
X  			pixel.x + CELL_WIDTH, pixel.y +
X  			(CELL_HEIGHT >> 1) - (EDGE_HEIGHT >> 1), sptr);
***************
*** 822,828 ****
X  		  /*{{{  munch the bottom half of the edge right*/
X  		  {
X  		    unsigned  type;
! 						    
X  		    type = 0;
X  		    if(cptr[0].depths[1] > VEL_Y)
X  		      type = GAP_WIDTH;
--- 806,812 ----
X  		  /*{{{  munch the bottom half of the edge right*/
X  		  {
X  		    unsigned  type;
! 												    
X  		    type = 0;
X  		    if(cptr[0].depths[1] > VEL_Y)
X  		      type = GAP_WIDTH;
***************
*** 832,838 ****
X  			(cptr[CELL_STRIDE].depths[3] > VEL_X ||
X  			cptr[CELL_STRIDE+1].depths[2] < -VEL_X))
X  		      type = 4 * GAP_WIDTH;
! 		    munch_back(type, EDGE_HEIGHT >> 1,
X  			GAP_WIDTH, EDGE_HEIGHT >> 1,
X  			pixel.x + CELL_WIDTH,
X  			pixel.y + (CELL_HEIGHT >> 1), sptr);
--- 816,822 ----
X  			(cptr[CELL_STRIDE].depths[3] > VEL_X ||
X  			cptr[CELL_STRIDE+1].depths[2] < -VEL_X))
X  		      type = 4 * GAP_WIDTH;
! 		    munch_back((int)type, EDGE_HEIGHT >> 1,
X  			GAP_WIDTH, EDGE_HEIGHT >> 1,
X  			pixel.x + CELL_WIDTH,
X  			pixel.y + (CELL_HEIGHT >> 1), sptr);
***************
*** 1003,1009 ****
X    if(cherry && cherry->sprite)
X      {
X        SPRITE    *sptr;
!       
X        if(!nptr || cherry->sprite == SPRITE_DEN ||
X  	  cherry->sprite == SPRITE_NORMAL + 2 ||
X  	  (cherry->sprite != SPRITE_CHERRY && mptr->type != 4))
--- 987,993 ----
X    if(cherry && cherry->sprite)
X      {
X        SPRITE    *sptr;
! 	
X        if(!nptr || cherry->sprite == SPRITE_DEN ||
X  	  cherry->sprite == SPRITE_NORMAL + 2 ||
X  	  (cherry->sprite != SPRITE_CHERRY && mptr->type != 4))
***************
*** 1026,1054 ****
X    /*}}}*/
X    if(update.set)
X      add_background(update.tl.x, update.tl.y,
! 	update.br.x - update.tl.x, update.br.y - update.tl.y);
X    if(broke || nptr)
X      global.broken = 1;
X    assert(!nptr || nptr->visit);
!   assert(mptr->cell.y >= 0 && mptr->cell.y < CELLS_DOWN &&
!       mptr->cell.x >= 0 && mptr->cell.x < CELLS_ACROSS &&
!       (mptr->cell.x || mptr->offset.x >= 0) &&
!       (mptr->cell.y || mptr->offset.y >= 0) &&
!       (mptr->cell.x < CELLS_ACROSS - 1 || mptr->offset.x <= 0) &&
!       (mptr->cell.y < CELLS_DOWN - 1 || mptr->offset.y <= 0) &&
!       (!mptr->offset.x || !mptr->offset.y));
X    return nptr;
X  }
X  /*}}}*/
X  /*{{{  void munch_back(sx, sy, width, height, dx, dy, sprite)*/
X  static void munch_back FUNCARGLIST((sx, sy, width, height, dx, dy, sprite))
! int     sx      FUNCARGSEP
! int     sy      FUNCARGSEP
! int     width   FUNCARGSEP
! int     height  FUNCARGSEP
! int     dx      FUNCARGSEP
! int     dy      FUNCARGSEP
! SPRITE  *sprite FUNCARGTERM
X  /*
X   * munches the background image with the specified sprite
X   */
--- 1010,1040 ----
X    /*}}}*/
X    if(update.set)
X      add_background(update.tl.x, update.tl.y,
! 	(unsigned)(update.br.x - update.tl.x), 
! 	(unsigned)(update.br.y - update.tl.y));
X    if(broke || nptr)
X      global.broken = 1;
+   /*  check we haven't wandered off the board */
X    assert(!nptr || nptr->visit);
!   assert(mptr->cell.y >= 0 && mptr->cell.y < CELLS_DOWN);
!   assert(mptr->cell.x >= 0 && mptr->cell.x < CELLS_ACROSS);
!   assert(mptr->cell.x || mptr->offset.x >= 0);
!   assert(mptr->cell.y || mptr->offset.y >= 0);
!   assert(mptr->cell.x < CELLS_ACROSS - 1 || mptr->offset.x <= 0);
!   assert(mptr->cell.y < CELLS_DOWN - 1 || mptr->offset.y <= 0);
!   assert(!mptr->offset.x || !mptr->offset.y);
X    return nptr;
X  }
X  /*}}}*/
X  /*{{{  void munch_back(sx, sy, width, height, dx, dy, sprite)*/
X  static void munch_back FUNCARGLIST((sx, sy, width, height, dx, dy, sprite))
! int       sx      FUNCARGSEP
! int       sy      FUNCARGSEP
! unsigned  width   FUNCARGSEP
! unsigned  height  FUNCARGSEP
! int       dx      FUNCARGSEP
! int       dy      FUNCARGSEP
! SPRITE    *sprite FUNCARGTERM
X  /*
X   * munches the background image with the specified sprite
X   */
***************
*** 1113,1119 ****
X  	if(type == 3 * GAP_HEIGHT && (cptr[-1].depths[0] < -VEL_Y ||
X  	    cptr[-CELL_STRIDE-1].depths[1] > VEL_Y))
X  	  type = 4 * GAP_HEIGHT;
! 	munch_back(0, type, EDGE_WIDTH >> 1, GAP_HEIGHT,
X  	    x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1), y - GAP_HEIGHT, sptr);
X        }
X        /*}}}*/
--- 1099,1105 ----
X  	if(type == 3 * GAP_HEIGHT && (cptr[-1].depths[0] < -VEL_Y ||
X  	    cptr[-CELL_STRIDE-1].depths[1] > VEL_Y))
X  	  type = 4 * GAP_HEIGHT;
! 	munch_back(0, (int)type, EDGE_WIDTH >> 1, GAP_HEIGHT,
X  	    x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1), y - GAP_HEIGHT, sptr);
X        }
X        /*}}}*/
***************
*** 1129,1135 ****
X  	if(type == 3 * GAP_HEIGHT && (cptr[1].depths[0] < -VEL_Y ||
X  	    cptr[-CELL_STRIDE+1].depths[1] > VEL_Y))
X  	  type = 4 * GAP_HEIGHT;
! 	munch_back(EDGE_WIDTH >> 1, type, EDGE_WIDTH >> 1, GAP_HEIGHT,
X  	    x + (CELL_WIDTH >> 1), y - GAP_HEIGHT, sptr);
X        }
X        /*}}}*/
--- 1115,1121 ----
X  	if(type == 3 * GAP_HEIGHT && (cptr[1].depths[0] < -VEL_Y ||
X  	    cptr[-CELL_STRIDE+1].depths[1] > VEL_Y))
X  	  type = 4 * GAP_HEIGHT;
! 	munch_back(EDGE_WIDTH >> 1, (int)type, EDGE_WIDTH >> 1, GAP_HEIGHT,
X  	    x + (CELL_WIDTH >> 1), y - GAP_HEIGHT, sptr);
X        }
X        /*}}}*/
***************
*** 1150,1156 ****
X  	if(type == 3 * GAP_HEIGHT && (cptr[-1].depths[1] > VEL_Y ||
X  	    cptr[CELL_STRIDE-1].depths[0] < -VEL_Y))
X  	  type = 4 * GAP_HEIGHT;
! 	munch_back(0, type, EDGE_WIDTH >> 1, GAP_HEIGHT,
X  	    x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1),
X  	    y + CELL_HEIGHT, sptr);
X        }
--- 1136,1142 ----
X  	if(type == 3 * GAP_HEIGHT && (cptr[-1].depths[1] > VEL_Y ||
X  	    cptr[CELL_STRIDE-1].depths[0] < -VEL_Y))
X  	  type = 4 * GAP_HEIGHT;
! 	munch_back(0, (int)type, EDGE_WIDTH >> 1, GAP_HEIGHT,
X  	    x + (CELL_WIDTH >> 1) - (EDGE_WIDTH >> 1),
X  	    y + CELL_HEIGHT, sptr);
X        }
***************
*** 1168,1174 ****
X  	    (cptr[1].depths[1] > VEL_Y ||
X  	    cptr[CELL_STRIDE+1].depths[0] < -VEL_Y))
X  	  type = 4 * GAP_HEIGHT;
! 	munch_back(EDGE_WIDTH >> 1, type, EDGE_WIDTH >> 1, GAP_HEIGHT,
X  	    x + (CELL_WIDTH >> 1), y + CELL_HEIGHT, sptr);
X        }
X        /*}}}*/
--- 1154,1160 ----
X  	    (cptr[1].depths[1] > VEL_Y ||
X  	    cptr[CELL_STRIDE+1].depths[0] < -VEL_Y))
X  	  type = 4 * GAP_HEIGHT;
! 	munch_back(EDGE_WIDTH >> 1, (int)type, EDGE_WIDTH >> 1, GAP_HEIGHT,
X  	    x + (CELL_WIDTH >> 1), y + CELL_HEIGHT, sptr);
X        }
X        /*}}}*/
***************
*** 1191,1197 ****
X  	    (cptr[-CELL_STRIDE].depths[2] < -VEL_X ||
X  	    cptr[-CELL_STRIDE-1].depths[3] > VEL_X))
X  	  type = 4 * GAP_WIDTH;
! 	munch_back(type, 0, GAP_HEIGHT, EDGE_HEIGHT >> 1,
X  	    x - GAP_WIDTH, y + (CELL_HEIGHT >> 1) - (EDGE_HEIGHT >> 1),
X  	    sptr);
X        }
--- 1177,1183 ----
X  	    (cptr[-CELL_STRIDE].depths[2] < -VEL_X ||
X  	    cptr[-CELL_STRIDE-1].depths[3] > VEL_X))
X  	  type = 4 * GAP_WIDTH;
! 	munch_back((int)type, 0, GAP_HEIGHT, EDGE_HEIGHT >> 1,
X  	    x - GAP_WIDTH, y + (CELL_HEIGHT >> 1) - (EDGE_HEIGHT >> 1),
X  	    sptr);
X        }
***************
*** 1209,1215 ****
X  	    (cptr[CELL_STRIDE].depths[2] < -VEL_X ||
X  	    cptr[CELL_STRIDE-1].depths[3] > VEL_X))
X  	  type = 4 * GAP_WIDTH;
! 	munch_back(type, EDGE_HEIGHT >> 1, GAP_WIDTH, EDGE_HEIGHT >> 1,
X  	    x - GAP_WIDTH, y + (CELL_HEIGHT >> 1), sptr);
X        }
X        /*}}}*/
--- 1195,1201 ----
X  	    (cptr[CELL_STRIDE].depths[2] < -VEL_X ||
X  	    cptr[CELL_STRIDE-1].depths[3] > VEL_X))
X  	  type = 4 * GAP_WIDTH;
! 	munch_back((int)type, EDGE_HEIGHT >> 1, GAP_WIDTH, EDGE_HEIGHT >> 1,
X  	    x - GAP_WIDTH, y + (CELL_HEIGHT >> 1), sptr);
X        }
X        /*}}}*/
***************
*** 1231,1237 ****
X  	    (cptr[-CELL_STRIDE].depths[3] > VEL_X ||
X  	    cptr[-CELL_STRIDE+1].depths[2] < -VEL_X))
X  	  type = 4 * GAP_WIDTH;
! 	munch_back(type, 0, GAP_WIDTH, EDGE_HEIGHT >> 1,
X  	    x + CELL_WIDTH, y + (CELL_HEIGHT >> 1) - (EDGE_HEIGHT >> 1),
X  	    sptr);
X        }
--- 1217,1223 ----
X  	    (cptr[-CELL_STRIDE].depths[3] > VEL_X ||
X  	    cptr[-CELL_STRIDE+1].depths[2] < -VEL_X))
X  	  type = 4 * GAP_WIDTH;
! 	munch_back((int)type, 0, GAP_WIDTH, EDGE_HEIGHT >> 1,
X  	    x + CELL_WIDTH, y + (CELL_HEIGHT >> 1) - (EDGE_HEIGHT >> 1),
X  	    sptr);
X        }
***************
*** 1249,1255 ****
X  	    (cptr[CELL_STRIDE].depths[3] > VEL_X ||
X  	    cptr[CELL_STRIDE+1].depths[2] < -VEL_X))
X  	  type = 4 * GAP_WIDTH;
! 	munch_back(type, EDGE_HEIGHT >> 1, GAP_WIDTH, EDGE_HEIGHT >> 1,
X  	    x + CELL_WIDTH, y + (CELL_HEIGHT >> 1), sptr);
X        }
X        /*}}}*/
--- 1235,1241 ----
X  	    (cptr[CELL_STRIDE].depths[3] > VEL_X ||
X  	    cptr[CELL_STRIDE+1].depths[2] < -VEL_X))
X  	  type = 4 * GAP_WIDTH;
! 	munch_back((int)type, EDGE_HEIGHT >> 1, GAP_WIDTH, EDGE_HEIGHT >> 1,
X  	    x + CELL_WIDTH, y + (CELL_HEIGHT >> 1), sptr);
X        }
X        /*}}}*/
diff -c -r exp.v1.01/patchlevel.h exp.v2.00/patchlevel.h
*** exp.v1.01/patchlevel.h	Fri Jul 24 09:55:56 1992
--- exp.v2.00/patchlevel.h	Fri Jul 24 13:43:03 1992
***************
*** 1 ****
! #define XMRISVERSION "V1.01"
--- 1,2 ----
! #define XMRISVERSION "V2.00"
! #define DATE "24 Jul 1992"
diff -c -r exp.v1.01/player.c exp.v2.00/player.c
*** exp.v1.01/player.c	Fri Jul 24 09:56:13 1992
--- exp.v2.00/player.c	Fri Jul 24 13:43:20 1992
***************
*** 1,21 ****
! /*{{{  (C) 1992 Nathan Sidwell*/
! /*****************************************************************************
! 			X M R I S V1.01
! 			---------------
! 		    (C) 1992 Nathan Sidwell
! 
! This program is copyright (C) 1992 Nathan Sidwell. This software and documentation
! is in the public domain. Permission is granted to distribute and compile
! verbatim copies of this software for non-commercial, non-profit use,
! without fee. The software may be modified, provided that both the above copyright
! notice and this permission notice appear.
! 
! No guarantee is given as to the robustness or suitability of this
! software for your computer.
! 
! Nathan Sidwell  INMOS UK |                 | nathan@inmos.co.uk       DoD#0390
! *****************************************************************************/
! /*}}}*/
X  #include "xmris.h"
X  /*{{{  void bounce_ball()*/
X  extern void bounce_ball FUNCARGVOID
--- 1,4 ----
! /* (C) 1992 Nathan Sidwell */
X  #include "xmris.h"
X  /*{{{  void bounce_ball()*/
X  extern void bounce_ball FUNCARGVOID
***************
*** 179,185 ****
X  	  {
X  	    unsigned  quadrant;
X  	    /* quadrants to, bo, lo, ro, ti, bi, li, ri, t, b, l, r */
! 		    
X  	    /* work out where we are in the cell */
X  	    quadrant = 0x000;
X  	    /*{{{  y place*/
--- 162,168 ----
X  	  {
X  	    unsigned  quadrant;
X  	    /* quadrants to, bo, lo, ro, ti, bi, li, ri, t, b, l, r */
! 						    
X  	    /* work out where we are in the cell */
X  	    quadrant = 0x000;
X  	    /*{{{  y place*/
***************
*** 219,225 ****
X  		if(quadrant & 0x808)
X  		  {
X  		    unsigned  mask;
! 				  
X  		    if(quadrant & 0x800)
X  		      mask = 0x93;
X  		    else
--- 202,208 ----
X  		if(quadrant & 0x808)
X  		  {
X  		    unsigned  mask;
! 								  
X  		    if(quadrant & 0x800)
X  		      mask = 0x93;
X  		    else
***************
*** 259,265 ****
X  		if(quadrant & 0x404)
X  		  {
X  		    unsigned  mask;
! 				  
X  		    if(quadrant & 0x400)
X  		      mask = 0x63;
X  		    else
--- 242,248 ----
X  		if(quadrant & 0x404)
X  		  {
X  		    unsigned  mask;
! 								  
X  		    if(quadrant & 0x400)
X  		      mask = 0x63;
X  		    else
***************
*** 299,305 ****
X  		if(quadrant & 0x202)
X  		  {
X  		    unsigned  mask;
! 				  
X  		    if(quadrant & 0x200)
X  		      mask = 0xAC;
X  		    else
--- 282,288 ----
X  		if(quadrant & 0x202)
X  		  {
X  		    unsigned  mask;
! 								  
X  		    if(quadrant & 0x200)
X  		      mask = 0xAC;
X  		    else
***************
*** 320,326 ****
X  		if(quadrant & 0x101)
X  		  {
X  		    unsigned  mask;
! 				  
X  		    if(quadrant & 0x100)
X  		      mask = 0x5C;
X  		    else
--- 303,309 ----
X  		if(quadrant & 0x101)
X  		  {
X  		    unsigned  mask;
! 								  
X  		    if(quadrant & 0x100)
X  		      mask = 0x5C;
X  		    else
***************
*** 338,350 ****
X  	  {
X  	    unsigned  i;
X  	    APPLE     *aptr;
! 		    
X  	    for(aptr = apple.list, i = apple.apples; i--; aptr++)
X  	      {
X  		int     x, y;
X  		int     edge;
X  		/* edge ot, ob, ol, or, t, b, l, r */
! 			  
X  		if(aptr->state < 4)
X  		  {
X  		    x = aptr->pixel.x;
--- 321,333 ----
X  	  {
X  	    unsigned  i;
X  	    APPLE     *aptr;
! 						    
X  	    for(aptr = apple.list, i = apple.apples; i--; aptr++)
X  	      {
X  		int     x, y;
X  		int     edge;
X  		/* edge ot, ob, ol, or, t, b, l, r */
! 							  
X  		if(aptr->state < 4)
X  		  {
X  		    x = aptr->pixel.x;
***************
*** 530,536 ****
X  	{
X  	  unsigned  i;
X  	  MONSTER   *mptr;
! 		
X  	  for(mptr = monster.list, i = monster.monsters; i--; mptr++)
X  	    if(!mptr->shot && !mptr->apple &&
X  		player.ball.pixel.x - mptr->pixel.x >= 0 &&
--- 513,519 ----
X  	{
X  	  unsigned  i;
X  	  MONSTER   *mptr;
! 						
X  	  for(mptr = monster.list, i = monster.monsters; i--; mptr++)
X  	    if(!mptr->shot && !mptr->apple &&
X  		player.ball.pixel.x - mptr->pixel.x >= 0 &&
***************
*** 610,751 ****
X  {
X    CELL      *cptr;
X    unsigned  dir;
X  
X    dir = monster.list[0].dir;
!   /*{{{  motionevent?*/
!   if(player.motionevent && !player.keyboard &&
!       (!monster.list[0].stop ||
!        player.raw_mouse.x - player.mouse.x * (CELL_WIDTH + GAP_WIDTH) >
! 	  BORDER_LEFT + GAP_WIDTH / 2 + (CELL_WIDTH + GAP_WIDTH) / 4 +
! 	  CELL_WIDTH + GAP_WIDTH ||
!        player.raw_mouse.y - (int)player.mouse.y * (CELL_HEIGHT + GAP_HEIGHT) >
! 	  BORDER_TOP + GAP_HEIGHT / 2 + (CELL_HEIGHT + GAP_HEIGHT) / 4 +
! 	  CELL_HEIGHT + GAP_HEIGHT ||
!        player.raw_mouse.x - (int)player.mouse.x * (CELL_WIDTH + GAP_WIDTH) <
! 	  BORDER_LEFT + GAP_WIDTH / 2 - (GAP_WIDTH + CELL_WIDTH) / 4||
!        player.raw_mouse.y - (int)player.mouse.y * (CELL_HEIGHT + GAP_HEIGHT) <
! 	  BORDER_TOP + GAP_HEIGHT / 2 - (GAP_HEIGHT + CELL_HEIGHT) / 4))
!     /*
!      * for mouse motion, we get the cell number for the mouse, and
!      * set dir & mouse dir to point towards it
!      */
!     {
!       int       x, y;
! 	
!       x = (player.raw_mouse.x - BORDER_LEFT - GAP_WIDTH / 2) /
! 	  (GAP_WIDTH + CELL_WIDTH);
!       y = (player.raw_mouse.y - BORDER_TOP - GAP_HEIGHT / 2) /
! 	  (GAP_HEIGHT + CELL_HEIGHT);
!       /*{{{  clip x*/
!       if(x < 0)
! 	x = 0;
!       else if(x > CELLS_ACROSS - 1)
! 	x = CELLS_ACROSS - 1;
!       /*}}}*/
!       /*{{{  clip y*/
!       if(y < 0)
! 	y = 0;
!       else if(y > CELLS_DOWN - 1)
! 	y = CELLS_DOWN - 1;
!       /*}}}*/
!       if(y != player.mouse.y || x != player.mouse.x)
! 	{
! 	  unsigned  dir;
! 	  unsigned  second;
! 	
! 	  player.mouse.x = x;
! 	  player.mouse.y = y;
! 	  /*{{{  calc x direction*/
! 	  if(x == monster.list[0].cell.x && !monster.list[0].offset.x)
! 	    x = 0;
! 	  else if(x < monster.list[0].cell.x ||
! 	      (x == monster.list[0].cell.x && monster.list[0].offset.x > 0))
! 	    x = 6;
! 	  else
! 	    x = 7;
! 	  /*}}}*/
! 	  /*{{{  calc y direction*/
! 	  if(y == monster.list[0].cell.y && !monster.list[0].offset.y)
! 	    y = 0;
! 	  else if(y < monster.list[0].cell.y ||
! 	      (y == monster.list[0].cell.y && monster.list[0].offset.y > 0))
! 	    y = 4;
! 	  else
! 	    y = 5;
! 	  /*}}}*/
! 	  /*{{{  select which way round to do them*/
! 	  if(monster.list[0].dir & 2)
! 	    {
! 	      if(monster.list[0].dir != x)
! 		{
! 		  dir = y;
! 		  second = x;
! 		}
! 	      else
! 		{
! 		  dir = x;
! 		  second = y;
! 		}
! 	    }
! 	  else
! 	    {
! 	      if(monster.list[0].dir != y)
! 		{
! 		  dir = x;
! 		  second = y;
! 		}
! 	      else
! 		{
! 		  dir = y;
! 		  second = x;
! 		}
! 	    }
! 	  /*}}}*/
! 	  player.next_dir = 0;
! 	  /*{{{  do u turn fiddling*/
! 	  if(!dir)
! 	    dir = second;
! 	  else if(!second)
! 	    second = dir;
! 	  else if(monster.list[0].offset.x && !(dir & 2))
! 	    {
! 	      player.next_dir = dir;
! 	      if(monster.list[0].offset.x < -(CELL_WIDTH + GAP_WIDTH) * 3 / 4)
! 		dir = 6;
! 	      else if(monster.list[0].offset.x > (CELL_WIDTH + GAP_WIDTH) * 3 / 4)
! 		dir = 7;
! 	      else if(monster.list[0].offset.x > 0 &&
! 		  monster.list[0].offset.x <= (CELL_WIDTH + GAP_WIDTH) / 4)
! 		dir = 6;
! 	      else if(monster.list[0].offset.x < 0 &&
! 		  monster.list[0].offset.x >= -(CELL_WIDTH + GAP_WIDTH) / 4)
! 		dir = 7;
! 	      else
! 		dir = monster.list[0].dir | 4;
! 	    }
! 	  else if(monster.list[0].offset.y && (dir & 2))
! 	    {
! 	      player.next_dir = dir;
! 	      if(monster.list[0].offset.y < -(CELL_HEIGHT + GAP_HEIGHT) * 3 / 4)
! 		dir = 4;
! 	      else if(monster.list[0].offset.y > (CELL_HEIGHT + GAP_HEIGHT) * 3 / 4)
! 		dir = 5;
! 	      else if(monster.list[0].offset.y > 0 &&
! 		  monster.list[0].offset.y <= (CELL_HEIGHT + GAP_HEIGHT) / 4)
! 		dir = 4;
! 	      else if(monster.list[0].offset.y < 0 &&
! 		  monster.list[0].offset.y >= -(CELL_HEIGHT + GAP_HEIGHT) / 4)
! 		dir = 5;
! 	      else
! 		dir = monster.list[0].dir | 4;
! 	    }
! 	  /*}}}*/
! 	  monster.list[0].dir = dir & 3;
! 	  monster.list[0].stop = !(dir & 4);
! 	  player.mouse_dir = second;
! 	}
!     }
!   /*}}}*/
X    /*{{{  key change?*/
X    if(player.bashed || (player.old_pressed ^ player.pressed) & 0xF)
X    /*
--- 593,604 ----
X  {
X    CELL      *cptr;
X    unsigned  dir;
+   unsigned  onestep;
+   unsigned  was_stop;
X  
X    dir = monster.list[0].dir;
!   onestep = 0;
!   was_stop = monster.list[0].stop;
X    /*{{{  key change?*/
X    if(player.bashed || (player.old_pressed ^ player.pressed) & 0xF)
X    /*
***************
*** 757,766 ****
X    {
X      unsigned  valid;
X      unsigned  pressed;
!     
!     player.mouse_dir = 0;
!     pressed = player.pressed & ~player.bashed;
X      if(!pressed)
X        pressed = player.pressed;
X      valid = 0xF;
X      /*{{{  work out valid direction and the edges*/
--- 610,636 ----
X    {
X      unsigned  valid;
X      unsigned  pressed;
! 	
!     pressed = player.pressed;
X      if(!pressed)
+       {
+ 	if(dir == 0 && monster.list[0].offset.y <=
+ 	    VEL_Y * STEP_OFF - CELL_HEIGHT - GAP_HEIGHT)
+ 	  pressed = 0x1;
+ 	else if(dir == 1 && monster.list[0].offset.y >=
+ 	    CELL_HEIGHT + GAP_HEIGHT - VEL_Y * STEP_OFF)
+ 	  pressed = 0x2;
+ 	else if(dir == 2 && monster.list[0].offset.x <=
+ 	    VEL_X * STEP_OFF - CELL_WIDTH - GAP_WIDTH)
+ 	  pressed = 0x4;
+ 	else if(dir == 3 && monster.list[0].offset.x >=
+ 	    CELL_WIDTH + GAP_WIDTH - VEL_X * STEP_OFF)
+ 	  pressed = 0x8;
+ 	if(pressed)
+ 	  onestep = 1;
+       }
+     pressed &= ~player.bashed;
+     if(!pressed)
X        pressed = player.pressed;
X      valid = 0xF;
X      /*{{{  work out valid direction and the edges*/
***************
*** 799,804 ****
--- 669,675 ----
X        pressed &= 0x3;
X      if(!pressed)
X        {
+ 	onestep = 0;
X  	monster.list[0].stop = 1;
X  	player.next_dir = 0;
X        }
***************
*** 805,811 ****
X      else if((valid & pressed) == pressed)
X        {
X  	unsigned  dir;
!     
X  	if((pressed & 0x3) && (pressed & 0xC))
X  	  pressed &= monster.list[0].dir & 2 ? 0x3 : 0xC;
X  	for(dir = 0; !(pressed & 1); dir++, pressed >>= 1)
--- 676,682 ----
X      else if((valid & pressed) == pressed)
X        {
X  	unsigned  dir;
! 	
X  	if((pressed & 0x3) && (pressed & 0xC))
X  	  pressed &= monster.list[0].dir & 2 ? 0x3 : 0xC;
X  	for(dir = 0; !(pressed & 1); dir++, pressed >>= 1)
***************
*** 817,823 ****
X      else
X        {
X  	unsigned  dir;
!     
X  	pressed &= ~valid;
X  	for(dir = 0; !(pressed & 1); pressed >>= 1)
X  	  dir++;
--- 688,694 ----
X      else
X        {
X  	unsigned  dir;
! 	
X  	pressed &= ~valid;
X  	for(dir = 0; !(pressed & 1); pressed >>= 1)
X  	  dir++;
***************
*** 878,884 ****
X        player.bashed = 0x10;
X    }
X    /*}}}*/
-   player.old_pressed = player.pressed;
X    if(player.throw == 2)
X      {
X        if(!player.button)
--- 749,754 ----
***************
*** 887,893 ****
X    else if(player.throw == 0)
X      player.throw = player.button;
X    if(dir != monster.list[0].dir)
!     new_face(&monster.list[0]);
X    if(monster.list[0].pause)
X      {
X        player.cherry = player.distance = 0;
--- 757,767 ----
X    else if(player.throw == 0)
X      player.throw = player.button;
X    if(dir != monster.list[0].dir)
!     {
!       if(was_stop || dir == monster.list[0].dir ^ 1)
! 	monster.list[0].pause = 1;
!       new_face(&monster.list[0]);
!     }
X    if(monster.list[0].pause)
X      {
X        player.cherry = player.distance = 0;
***************
*** 947,954 ****
X  	      cptr->sprite < SPRITE_PRIZE_BASE + SPRITE_PRIZES)
X  	    /*{{{  eat prize*/
X  	    {
! 	      int     score;
! 			
X  	      history.prize |= 1;
X  	      cptr->sprite = 0;
X  	      score = player.screen * 500 + 500;
--- 821,828 ----
X  	      cptr->sprite < SPRITE_PRIZE_BASE + SPRITE_PRIZES)
X  	    /*{{{  eat prize*/
X  	    {
! 	      unsigned  score;
! 							
X  	      history.prize |= 1;
X  	      cptr->sprite = 0;
X  	      score = player.screen * 500 + 500;
***************
*** 964,969 ****
--- 838,845 ----
X  	    /*}}}*/
X  	}
X      }
+   if(!onestep)
+     player.old_pressed = player.pressed;
X    if(player.distance)
X      player.distance--;
X    else
***************
*** 972,993 ****
X    if(monster.list[0].stop ||
X        monster.list[0].offset.x || monster.list[0].offset.y)
X      /*EMPTY*/;
-   else if(player.mouse_dir &&
-       monster.list[0].cell.x == player.mouse.x &&
-       monster.list[0].cell.y == player.mouse.y)
-     {
-       player.next_dir = player.mouse_dir = 0;
-       monster.list[0].stop = 1;
-     }
-   else if(player.mouse_dir &&
-       monster.list[0].dir != (player.mouse_dir & 3) &&
-       (monster.list[0].cell.x == player.mouse.x ||
-        monster.list[0].cell.y == player.mouse.y))
-     {
-       monster.list[0].dir = player.mouse_dir & 3;
-       player.next_dir = 0;
-       new_face(&monster.list[0]);
-     }
X    else if((!monster.list[0].cell.x && monster.list[0].dir == 2) ||
X        (!monster.list[0].cell.y && monster.list[0].dir == 0) ||
X        (monster.list[0].cell.x == CELLS_ACROSS - 1 &&
--- 848,853 ----
***************
*** 1005,1032 ****
X        player.next_dir = 0;
X        new_face(&monster.list[0]);
X      }
X    /*}}}*/
X    if(!monster.list[0].shot)
-     /*{{{  hit monster?*/
X      {
X        unsigned  i;
X        MONSTER   *mptr;
X        int       x, y;
X  	
!       x = monster.list[0].pixel.x - CELL_WIDTH + GAP_WIDTH;
!       y = monster.list[0].pixel.y - CELL_HEIGHT + GAP_HEIGHT;
X        for(mptr = &monster.list[1], i = monster.monsters - 1; i--; mptr++)
! 	if(!mptr->chew && !mptr->shot && !mptr->apple &&
! 	    mptr->pixel.x - x > 0 &&
! 	    mptr->pixel.x - x < 2 * (CELL_WIDTH - GAP_WIDTH) &&
! 	    mptr->pixel.y - y > 0 &&
! 	    mptr->pixel.y - y < 2 * (CELL_HEIGHT - GAP_HEIGHT))
X  	  {
! 	    monster.list[0].shot = 1;
! 	    break;
X  	  }
X      }
-     /*}}}*/
X    return;
X  }
X  /*}}}*/
--- 865,909 ----
X        player.next_dir = 0;
X        new_face(&monster.list[0]);
X      }
+   else if(onestep)
+     monster.list[0].stop = 1;
X    /*}}}*/
+   return;
+ }
+ /*}}}*/
+ /*{{{  void killed_player()*/
+ extern void killed_player FUNCARGVOID
+ /* 
+  * sees if the player has walked into a live monster
+  */
+ {
X    if(!monster.list[0].shot)
X      {
X        unsigned  i;
X        MONSTER   *mptr;
X        int       x, y;
X  	
!       x = monster.list[0].pixel.x;
!       y = monster.list[0].pixel.y;
X        for(mptr = &monster.list[1], i = monster.monsters - 1; i--; mptr++)
! 	if(!mptr->chew && !mptr->shot && !mptr->apple)
X  	  {
! 	    int     dx, dy;
! 	    
! 	    dx = mptr->pixel.x - x;
! 	    dy = mptr->pixel.y - y;
! 	    if(dx < 0)
! 	      dx = -1 - dx;
! 	    if(dy < 0)
! 	      dy = -1 - dy;
! 	    if(dx * CELL_HEIGHT + dy * CELL_WIDTH < 
! 		CELL_WIDTH * CELL_HEIGHT)
! 	      {
! 		monster.list[0].shot = 1;
! 		break;
! 	      }
X  	  }
X      }
X    return;
X  }
X  /*}}}*/
diff -c -r exp.v1.01/timer.c exp.v2.00/timer.c
*** exp.v1.01/timer.c	Fri Jul 24 09:56:15 1992
--- exp.v2.00/timer.c	Fri Jul 24 13:43:20 1992
***************
*** 1,21 ****
! /*{{{  (C) 1992 Nathan Sidwell*/
! /*****************************************************************************
! 			X M R I S V1.01
! 			---------------
! 		    (C) 1992 Nathan Sidwell
! 
! This program is copyright (C) 1992 Nathan Sidwell. This software and documentation
! is in the public domain. Permission is granted to distribute and compile
! verbatim copies of this software for non-commercial, non-profit use,
! without fee. The software may be modified, provided that both the above copyright
! notice and this permission notice appear.
! 
! No guarantee is given as to the robustness or suitability of this
! software for your computer.
! 
! Nathan Sidwell  INMOS UK |                 | nathan@inmos.co.uk       DoD#0390
! *****************************************************************************/
! /*}}}*/
X  #include "xmris.h"
X  #include <time.h>
X  #include <sys/time.h>
--- 1,4 ----
! /* (C) 1992 Nathan Sidwell */
X  #include "xmris.h"
X  #include <time.h>
X  #include <sys/time.h>
***************
*** 89,95 ****
X    timer.interval.it_value.tv_usec = 0;
X    timer_wait();
X    XDrawLine(display.display, display.window, GCN(GC_BALL),
!       WINDOW_WIDTH - global.missed, WINDOW_HEIGHT - 1,
X        WINDOW_WIDTH, WINDOW_HEIGHT - 1);
X    global.missed = 0;
X    return;
--- 72,78 ----
X    timer.interval.it_value.tv_usec = 0;
X    timer_wait();
X    XDrawLine(display.display, display.window, GCN(GC_BALL),
!       WINDOW_WIDTH - (int)global.missed, WINDOW_HEIGHT - 1,
X        WINDOW_WIDTH, WINDOW_HEIGHT - 1);
X    global.missed = 0;
X    return;
***************
*** 104,129 ****
X  {
X    if(!timer.counter)
X      {
X        int     mask;
X        
X        mask = sigblock(sigmask(SIGALRM));
X        if(!timer.counter)
X  	{
X  	  if(global.missed)
X  	    {
X  	      XDrawPoint(display.display, display.window, GCN(GC_BALL),
! 		  WINDOW_WIDTH - global.missed, WINDOW_HEIGHT - 1);
X  	      global.missed--;
X  	    }
X  	  sigpause(0);
X  	}
X        sigsetmask(mask);
X      }
X    else if(global.missed < WINDOW_WIDTH)
X      {
X        global.missed++;
X        XDrawPoint(display.display, display.window, GCN(GC_BALL),
! 	  WINDOW_WIDTH - global.missed, WINDOW_HEIGHT - 1);
X      }
X    timer.counter = 0;
X    setitimer(ITIMER_REAL, &timer.interval, (struct itimerval *)NULL);
--- 87,120 ----
X  {
X    if(!timer.counter)
X      {
+ #ifdef SYSV
+     sighold(SIGALRM);
+ #else
X        int     mask;
X        
X        mask = sigblock(sigmask(SIGALRM));
+ #endif
X        if(!timer.counter)
X  	{
X  	  if(global.missed)
X  	    {
X  	      XDrawPoint(display.display, display.window, GCN(GC_BALL),
! 		  WINDOW_WIDTH - (int)global.missed, WINDOW_HEIGHT - 1);
X  	      global.missed--;
X  	    }
X  	  sigpause(0);
X  	}
+ #ifdef SYSV
+       sigrelse(SIGALRM);
+ #else
X        sigsetmask(mask);
+ #endif
X      }
X    else if(global.missed < WINDOW_WIDTH)
X      {
X        global.missed++;
X        XDrawPoint(display.display, display.window, GCN(GC_BALL),
! 	  WINDOW_WIDTH - (int)global.missed, WINDOW_HEIGHT - 1);
X      }
X    timer.counter = 0;
X    setitimer(ITIMER_REAL, &timer.interval, (struct itimerval *)NULL);
Only in exp.v1.01: xmris.01
Only in exp.v1.01: xmris.02
Only in exp.v1.01: xmris.03
Only in exp.v1.01: xmris.04
Only in exp.v1.01: xmris.05
Only in exp.v1.01: xmris.06
Only in exp.v1.01: xmris.07
Only in exp.v1.01: xmris.08
Only in exp.v1.01: xmris.09
diff -c -r exp.v1.01/xmris.c exp.v2.00/xmris.c
*** exp.v1.01/xmris.c	Fri Jul 24 09:56:16 1992
--- exp.v2.00/xmris.c	Fri Jul 24 13:43:22 1992
***************
*** 1,30 ****
! /*{{{  (C) 1992 Nathan Sidwell*/
! /*****************************************************************************
! 			X M R I S V1.01
! 			---------------
! 		    (C) 1992 Nathan Sidwell
! 
! This program is copyright (C) 1992 Nathan Sidwell. This software and documentation
! is in the public domain. Permission is granted to distribute and compile
! verbatim copies of this software for non-commercial, non-profit use,
! without fee. The software may be modified, provided that both the above copyright
! notice and this permission notice appear.
! 
! No guarantee is given as to the robustness or suitability of this
! software for your computer.
! 
! Nathan Sidwell  INMOS UK |                 | nathan@inmos.co.uk       DoD#0390
! *****************************************************************************/
! /*}}}*/
X  #include "xmris.h"
X  #include <time.h>
X  /*{{{  prototypes*/
X  static void age_scores PROTOARGLIST((void));
X  static void parse_args PROTOARGLIST((int, char **));
X  /*}}}*/
X  /*{{{  void add_score(increment, x, y)*/
X  extern void add_score FUNCARGLIST((points, x, y))
! int       points  FUNCARGSEP
X  int       x       FUNCARGSEP
X  int       y       FUNCARGTERM
X  /*
--- 1,14 ----
! /* (C) 1992 Nathan Sidwell */
X  #include "xmris.h"
X  #include <time.h>
X  /*{{{  prototypes*/
X  static void age_scores PROTOARGLIST((void));
X  static void parse_args PROTOARGLIST((int, char **));
+ static int xio_error PROTOARGLIST((Display *));
X  /*}}}*/
X  /*{{{  void add_score(increment, x, y)*/
X  extern void add_score FUNCARGLIST((points, x, y))
! unsigned  points  FUNCARGSEP
X  int       x       FUNCARGSEP
X  int       y       FUNCARGTERM
X  /*
***************
*** 38,58 ****
X    {
X      unsigned  length;
X      char      text[10];
-     int       ascent, descent;
-     int       direction;
-     XCharStruct chars;
X      int       x, y;
X  	
X      length = itoa(text, player.score, 0);
!     XQueryTextExtents(display.display, font.font, text, length,
! 	&direction, &ascent, &descent, &chars);
!     x = BORDER_LEFT + (CELL_WIDTH + GAP_WIDTH) * 4 -
! 	CELL_WIDTH / 2 - chars.width;
!     y = (CELL_HEIGHT - ascent - descent) / 2 + ascent +
! 	BORDER_TOP - CELL_HEIGHT;
X      XDrawImageString(display.display, display.back, GCN(GC_TEXT),
! 	x, y, text, length);
!     add_background(x, y - ascent, chars.width, ascent + descent);
X    }
X    /*}}}*/
X    /*{{{  board score?*/
--- 22,36 ----
X    {
X      unsigned  length;
X      char      text[10];
X      int       x, y;
X  	
X      length = itoa(text, player.score, 0);
!     x = PIXELX(4, -GAP_WIDTH) - (length + 2) * font.width;
!     y = PIXELY(-1, CELL_HEIGHT / 2) + font.center;
X      XDrawImageString(display.display, display.back, GCN(GC_TEXT),
! 	x, y, text, (int)length);
!     add_background(x, y - font.ascent, 
! 	length * font.width, (unsigned)(font.ascent + font.descent));
X    }
X    /*}}}*/
X    /*{{{  board score?*/
***************
*** 74,80 ****
X  	      DIGIT_WIDTH * 4, DIGIT_HEIGHT);
X  	  update.score.scores--;
X  	  memmove(&update.score.list[0], &update.score.list[1],
! 	      sizeof(SCORE) * update.score.scores);
X  	}
X        /*}}}*/
X        sptr = &update.score.list[update.score.scores++];
--- 52,58 ----
X  	      DIGIT_WIDTH * 4, DIGIT_HEIGHT);
X  	  update.score.scores--;
X  	  memmove(&update.score.list[0], &update.score.list[1],
! 	      (size_t)(sizeof(SCORE) * update.score.scores));
X  	}
X        /*}}}*/
X        sptr = &update.score.list[update.score.scores++];
***************
*** 86,98 ****
X  	{
X  	  x = (4 - length) * (DIGIT_WIDTH / 2);
X  	  XCopyArea(display.display, dptr->image, sptr->image, GCN(GC_COPY),
! 	      10 * DIGIT_WIDTH, 0, x, DIGIT_HEIGHT, 0, 0);
X  	  XCopyArea(display.display, dptr->image, sptr->image, GCN(GC_COPY),
! 	      10 * DIGIT_WIDTH, 0, x, DIGIT_HEIGHT, 4 * DIGIT_WIDTH - x, 0);
X  	  XCopyArea(display.display, dptr->mask, sptr->mask, GCN(GC_COPY),
! 	      10 * DIGIT_WIDTH, 0, x, DIGIT_HEIGHT, 0, 0);
X  	  XCopyArea(display.display, dptr->mask, sptr->mask, GCN(GC_COPY),
! 	      10 * DIGIT_WIDTH, 0, x, DIGIT_HEIGHT, 4 * DIGIT_WIDTH - x, 0);
X  	}
X        else
X  	x = 0;
--- 64,76 ----
X  	{
X  	  x = (4 - length) * (DIGIT_WIDTH / 2);
X  	  XCopyArea(display.display, dptr->image, sptr->image, GCN(GC_COPY),
! 	      10 * DIGIT_WIDTH, 0, (unsigned)x, DIGIT_HEIGHT, 0, 0);
X  	  XCopyArea(display.display, dptr->image, sptr->image, GCN(GC_COPY),
! 	      10 * DIGIT_WIDTH, 0, (unsigned)x, DIGIT_HEIGHT, 4 * DIGIT_WIDTH - x, 0);
X  	  XCopyArea(display.display, dptr->mask, sptr->mask, GCN(GC_COPY),
! 	      10 * DIGIT_WIDTH, 0, (unsigned)x, DIGIT_HEIGHT, 0, 0);
X  	  XCopyArea(display.display, dptr->mask, sptr->mask, GCN(GC_COPY),
! 	      10 * DIGIT_WIDTH, 0, (unsigned)x, DIGIT_HEIGHT, 4 * DIGIT_WIDTH - x, 0);
X  	}
X        else
X  	x = 0;
***************
*** 242,252 ****
X    exit(1);
X  }
X  /*}}}*/
! /*{{{  int itoa(text, n, width)*/
! extern int itoa FUNCARGLIST((text, number, digits))
! char    *text   FUNCARGSEP  /* output text (include 0) */
! int     number  FUNCARGSEP  /* number to convert */
! int     digits  FUNCARGTERM /* field width to convert into */
X  /*
X   * formats an integer to a string
X   * in the specified number of digits
--- 220,230 ----
X    exit(1);
X  }
X  /*}}}*/
! /*{{{  unsigned itoa(text, n, width)*/
! extern unsigned itoa FUNCARGLIST((text, number, digits))
! char      *text   FUNCARGSEP  /* output text (include 0) */
! unsigned  number  FUNCARGSEP  /* number to convert */
! unsigned  digits  FUNCARGTERM /* field width to convert into */
X  /*
X   * formats an integer to a string
X   * in the specified number of digits
***************
*** 288,300 ****
X  char    **argv  FUNCARGTERM
X  {
X  #ifndef __STDC__
!   sprintf(title_text[1], "%s %s", XMRISVERSION, DATE);
X  #endif
X    /*{{{  set defaults*/
X    {
X      argv[argc] = NULL;
X      display.name = NULL;
-     font.name = FONT_NAME;
X      flags.gender = GAME_GENDER;
X    }
X    /*}}}*/
--- 266,277 ----
X  char    **argv  FUNCARGTERM
X  {
X  #ifndef __STDC__
!   sprintf(title_text[1].text, "%s %s", XMRISVERSION, DATE);
X  #endif
X    /*{{{  set defaults*/
X    {
X      argv[argc] = NULL;
X      display.name = NULL;
X      flags.gender = GAME_GENDER;
X    }
X    /*}}}*/
***************
*** 315,332 ****
X  	      break;
X  	}
X        fprintf(stderr, "%s [option ...]\n", ptr);
!       fprintf(stderr, "%s %s\n", game_name, title_text[1]);
!       fprintf(stderr, "%s\n", title_text[0]);
X        for(aptr = args; aptr->arg; aptr++)
X  	fprintf(stderr, "  %-8s %s\n", aptr->arg, aptr->help);
X        return 0;
X      }
X    /*}}}*/
X    create_resources(argc, argv);
X    timer_open();
X    XMapWindow(display.display, display.window);
-   XSelectInput(display.display, display.window, display.event_mask |
-       KeyPressMask | ButtonPressMask | KeyReleaseMask | PointerMotionMask);
X    while(!demo_mode())
X      /*{{{  game*/
X      {
--- 292,326 ----
X  	      break;
X  	}
X        fprintf(stderr, "%s [option ...]\n", ptr);
!       fprintf(stderr, "%s %s\n", game_name, title_text[1].text);
!       fprintf(stderr, "%s\n", title_text[0].text);
X        for(aptr = args; aptr->arg; aptr++)
X  	fprintf(stderr, "  %-8s %s\n", aptr->arg, aptr->help);
X        return 0;
X      }
X    /*}}}*/
+   display.display = XOpenDisplay(display.name);
+   /*{{{  opened?*/
+   if(!display.display)
+     fatal_error("Cannot open display \"%s\"",
+ 	display.name ? display.name : "DEFAULT", stderr);
+   /*}}}*/
+   read_xdefaults();
+   if(!font.name)
+     font.name = FONT_NAME;
+   if(!score_file)
+     score_file = SCORE_FILE;
X    create_resources(argc, argv);
+ #if !HIGH_SCORE_FILE
+   if(score_file)
+     fputs("Warning: High score file not supported\n", stderr);
+ #endif
+   init_scores();
+   XSetIOErrorHandler(xio_error);
X    timer_open();
+   XSelectInput(display.display, display.window, (int)display.event_mask |
+       KeyPressMask | KeyReleaseMask | EnterWindowMask | LeaveWindowMask);
X    XMapWindow(display.display, display.window);
X    while(!demo_mode())
X      /*{{{  game*/
X      {
***************
*** 338,344 ****
X        player.lives = START_LIVES;
X        player.score = 0;
X        player.screen = 0;
!       player.pressed = 0;
X        while(player.lives)
X  	{
X  	  new_board();
--- 332,338 ----
X        player.lives = START_LIVES;
X        player.score = 0;
X        player.screen = 0;
!       /*{{{  bop til you drop*/
X        while(player.lives)
X  	{
X  	  new_board();
***************
*** 354,362 ****
X  	      count = SCORE_SHOW;
X  	      /*{{{  initialize stuff*/
X  	      {
! 		player.mouse.x = PLAYER_START_X;
! 		player.mouse.y = PLAYER_START_Y;
! 		player.mouse_dir = player.next_dir = 0;
X  		global.state = 0;
X  		monster.monsters = 0;
X  		monster.delay = 0;
--- 348,354 ----
X  	      count = SCORE_SHOW;
X  	      /*{{{  initialize stuff*/
X  	      {
! 		player.next_dir = 0;
X  		global.state = 0;
X  		monster.monsters = 0;
X  		monster.delay = 0;
***************
*** 365,370 ****
--- 357,363 ----
X  		spawn_monster(4, 2, 2, PLAYER_START_X, PLAYER_START_Y, 0, 0);
X  		monster.list[0].stop = 1;
X  		player.pressed = 0;
+ 		player.bashed = 0;
X  		player.ball.state = 8;
X  		player.ball.count = 0;
X  		player.old_ball.state = 0;
***************
*** 378,384 ****
X  	      while(count)
X  	      {
X  		age_scores();
! 		if(process_xevents(1))
X  		  {
X  		    player.lives = 1;
X  		    monster.list[0].shot = 1;
--- 371,377 ----
X  	      while(count)
X  	      {
X  		age_scores();
! 		if(process_xevents(!monster.list[0].shot))
X  		  {
X  		    player.lives = 1;
X  		    monster.list[0].shot = 1;
***************
*** 399,410 ****
X  		      {
X  			monster.delay--;
X  			if(!(monster.delay % DEN_ESCAPE_FLASH))
! 			  draw_center(monster.delay / DEN_ESCAPE_FLASH &
! 			      1 ? SPRITE_NORMAL + 4 : SPRITE_DEN);
X  			if(!monster.delay)
X  			  {
X  			    MONSTER   *mptr;
! 											      
X  			    mptr = spawn_monster(0, 2, 2, DEN_X, DEN_Y, 0, 0);
X  			    monster.den--;
X  			    if(!monster.den)
--- 392,403 ----
X  		      {
X  			monster.delay--;
X  			if(!(monster.delay % DEN_ESCAPE_FLASH))
! 			  draw_center((unsigned)(monster.delay / DEN_ESCAPE_FLASH &
! 			      1 ? SPRITE_NORMAL + 4 : SPRITE_DEN));
X  			if(!monster.delay)
X  			  {
X  			    MONSTER   *mptr;
! 																							      
X  			    mptr = spawn_monster(0, 2, 2, DEN_X, DEN_Y, 0, 0);
X  			    monster.den--;
X  			    if(!monster.den)
***************
*** 421,426 ****
--- 414,420 ----
X  		    !monster.den && !monster.drones)
X  		  global.state = 3;
X  		fall_monsters();
+ 		killed_player();
X  		/*{{{  ending?*/
X  		if(global.state == 4)
X  		  {
***************
*** 430,436 ****
X  		      {
X  			APPLE   *aptr;
X  			int     i;
! 											
X  			for(aptr = apple.list, i = apple.apples; i--; aptr++)
X  			  if(aptr->state)
X  			    {
--- 424,430 ----
X  		      {
X  			APPLE   *aptr;
X  			int     i;
! 																							
X  			for(aptr = apple.list, i = apple.apples; i--; aptr++)
X  			  if(aptr->state)
X  			    {
***************
*** 452,458 ****
X  		if(!extra.escape)
X  		  {
X  		    unsigned  temp;
! 										    
X  		    if(random() < NEXT_XTRA_PROB)
X  		      new_xtra();
X  		    temp = player.score / 5000;
--- 446,452 ----
X  		if(!extra.escape)
X  		  {
X  		    unsigned  temp;
! 																						    
X  		    if(random() < NEXT_XTRA_PROB)
X  		      new_xtra();
X  		    temp = player.score / 5000;
***************
*** 497,503 ****
X  		  unsigned  i;
X  		  unsigned  base, offset;
X  		  MONSTER   *mptr;
! 										
X  		  player.ball.count = 8;
X  		  i = monster.list[0].face;
X  		  if(i >= 6)
--- 491,497 ----
X  		  unsigned  i;
X  		  unsigned  base, offset;
X  		  MONSTER   *mptr;
! 																						
X  		  player.ball.count = 8;
X  		  i = monster.list[0].face;
X  		  if(i >= 6)
***************
*** 511,517 ****
X  		  for(i = 0; i != 8; i++)
X  		    {
X  		      unsigned  delay;
! 										
X  		      if(process_xevents(0))
X  			player.lives = 1;
X  		      monster.list[0].type =
--- 505,511 ----
X  		  for(i = 0; i != 8; i++)
X  		    {
X  		      unsigned  delay;
! 																						
X  		      if(process_xevents(0))
X  			player.lives = 1;
X  		      monster.list[0].type =
***************
*** 528,536 ****
X  		  if(player.lives)
X  		    {
X  		      XFillRectangle(display.display, display.back, GCN(GC_CLEAR),
! 			  PIXELX(player.lives - 1, 0), PIXELY(CELLS_DOWN, 0),
X  			  CELL_WIDTH, CELL_HEIGHT);
! 		      add_background(PIXELX(player.lives - 1, 0),
X  			  PIXELY(CELLS_DOWN, 0), CELL_WIDTH, CELL_HEIGHT);
X  		    }
X  		  if(extra.escape)
--- 522,530 ----
X  		  if(player.lives)
X  		    {
X  		      XFillRectangle(display.display, display.back, GCN(GC_CLEAR),
! 			  PIXELX((int)player.lives - 1, 0), PIXELY(CELLS_DOWN, 0),
X  			  CELL_WIDTH, CELL_HEIGHT);
! 		      add_background(PIXELX((int)player.lives - 1, 0),
X  			  PIXELY(CELLS_DOWN, 0), CELL_WIDTH, CELL_HEIGHT);
X  		    }
X  		  if(extra.escape)
***************
*** 547,552 ****
--- 541,548 ----
X  	  while(monster.list[0].shot && player.lives);
X  	  timer_stop();
X  	}
+       /*}}}*/
+       high_score(player.score, player.screen);
X      }
X      /*}}}*/
X    release_resources();
***************
*** 583,589 ****
X    /*{{{  parse all the arguments*/
X    while(*++vptr)
X      {
!       while(**vptr != '-')
X  	vptr++;
X        if(*vptr)
X  	{
--- 579,585 ----
X    /*{{{  parse all the arguments*/
X    while(*++vptr)
X      {
!       while(*vptr && **vptr != '-')
X  	vptr++;
X        if(*vptr)
X  	{
***************
*** 609,625 ****
X  extern int process_xevents FUNCARGLIST((pausable))
X  int     pausable  FUNCARGTERM
X  {
X    int       quit;
X    int       paused;
X  
!   player.motionevent = 0;
X    quit = 0;
!   paused = 0;
X    /*{{{  read the events*/
X    while(QLength(display.display) || paused)
X      {
X        XEvent    event;
X  	
X        XNextEvent(display.display, &event);
X        if(event.xany.window != display.window)
X  	continue;
--- 605,647 ----
X  extern int process_xevents FUNCARGLIST((pausable))
X  int     pausable  FUNCARGTERM
X  {
+   static    int outside = 0;
X    int       quit;
X    int       paused;
X  
!   if(flags.iconic)
!     {
!       flags.iconic = 0;
!       XIconifyWindow(display.display, display.window, display.screen);
!     }
X    quit = 0;
!   paused = (pausable && outside) || (global.state == MODE_KEY_DEF ? 2 : 0);
X    /*{{{  read the events*/
X    while(QLength(display.display) || paused)
X      {
X        XEvent    event;
X  	
+       /*{{{  started to pause?*/
+       if(paused == 1)
+ 	{
+ 	  char const *text = "Space to continue, Q to quit";
+ 	  unsigned  length;
+ 		
+ 	  paused++;
+ 	  length = strlen(text);
+ 	  add_background(0, PIXELY(CELLS_DOWN, 0), WINDOW_WIDTH, CELL_HEIGHT);
+ 	  XFillRectangle(display.display, display.copy, GCN(GC_CLEAR),
+ 	      0, PIXELY(CELLS_DOWN, 0), WINDOW_WIDTH, CELL_HEIGHT);
+ 	  XDrawImageString(display.display, display.copy, GCN(GC_TEXT),
+ 	      WINDOW_WIDTH / 2 - (int)(length * font.width / 2),
+ 	      PIXELY(CELLS_DOWN, CELL_HEIGHT / 2) + font.center,
+ 	      text, (int)length);
+ 	  XCopyArea(display.display, display.copy, display.window, GCN(GC_COPY),
+ 	      0, PIXELY(CELLS_DOWN, 0), WINDOW_WIDTH, CELL_HEIGHT,
+ 	      0, PIXELY(CELLS_DOWN, 0));
+ 	  XSync(display.display, False);
+ 	}
+       /*}}}*/
X        XNextEvent(display.display, &event);
X        if(event.xany.window != display.window)
X  	continue;
***************
*** 632,669 ****
X  	 * a control key. If so, then we set the relevant pressed bit.
X  	 */
X  	{
- 	  char      chr;
X  	  KeySym    symbol;
! 	  XComposeStatus status;
SHAR_EOF
true || echo 'restore of patch.v2.00 failed'
fi
echo 'End of  part 4'
echo 'File patch.v2.00 is continued in part 5'
echo 5 > _shar_seq_.tmp
exit 0
-- 
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
Sunnyvale, California 94086		fax: 408/732-0831
