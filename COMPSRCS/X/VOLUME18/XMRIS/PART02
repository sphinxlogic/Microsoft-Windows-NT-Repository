Path: uunet!usc!elroy.jpl.nasa.gov!swrinde!mips!msi!dcmartin
From: nathan@inmos.co.uk (Nathan Sidwell)
Newsgroups: comp.sources.x
Subject: v18i023: Xmris - an X video game, Part02/09
Message-ID: <1992Jul16.171707.1650@msi.com>
Date: 16 Jul 92 17:17:07 GMT
References: <csx-18i022-xmris@uunet.UU.NET>
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Lines: 1722
Approved: dcmartin@msi.com
Originator: dcmartin@fascet

Submitted-by: Nathan Sidwell <nathan@inmos.co.uk>
Posting-number: Volume 18, Issue 23
Archive-name: xmris/part02

# this is part.02 (part 2 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file xmris.h continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 2; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping xmris.h'
else
echo 'x - continuing file xmris.h'
sed 's/^X//' << 'SHAR_EOF' >> 'xmris.h' &&
EXTERN struct
/* player specific information
X * note, the playe place info is stored as monster 0
X */
{
X  unsigned  screen;     /* current screen number */
X  unsigned  score;      /* our score */
X  unsigned  lives;      /* lives we have left (including on screen) */
X  COORD     mouse;      /* mouse destination square */
X  unsigned  throw;      /* throw the ball */
X  unsigned  button;     /* throw button state */
X  unsigned  mouse_dir;  /* mouse direction */
X  unsigned  next_dir;   /* direction at next intersection */
X  unsigned  pressed;    /* keys we have pressed */
X  unsigned  bashed;     /* we bashed into a wall */
X  BALL      old_ball;   /* what was the ball */
X  BALL      ball;       /* ball information */
X  unsigned  keyboard;   /* use keyboard */
X  unsigned  cherry;     /* consecutive cherry count */
X  unsigned  distance;   /* distance to next cherry */
X  COORD     raw_mouse;  /* the raw mouse input */
X  unsigned  old_pressed; /* old keys pressed */
X  unsigned  motionevent; /* the mouse moved */
} player;
/*}}}*/
EXTERN unsigned long seed; /* random number seed */
EXTERN char const *game_name; /* name of the game */
/*{{{  global*/
EXTERN struct
{
X  unsigned  difficulty;     /* increments in to make it harder */
X  unsigned  broken;         /* broken through a new path */
X  unsigned  cherries;       /* number of cherries left */
X  unsigned  state;          /* den state
X			     * 0 - den on screen
X			     * 1 - cake on screen
X			     * 2 - xtras & drone running around
X			     * 3 - done xtras
X			     * 4 - end game
X			     * 5 - extra life
X			     * 6 - demo
X			     * 7 - high scores
X			     * 8 - history
X			     */
X  unsigned  missed;         /* missed interrupt count */
} global;
/*}}}*/
/*{{{  extra*/
EXTERN struct
{
X  unsigned  got;      /* one we've got */
X  unsigned  select;   /* the one which is selected */
X  unsigned  escape;   /* its out */
X  unsigned  score;    /* last checked score */
} extra;
/*}}}*/
/*{{{  apple*/
EXTERN struct
{
X  APPLE     list[APPLES]; /* apple list */
X  unsigned  apples;       /* number of apples out */
} apple;
/*}}}*/
/*{{{  history*/
EXTERN struct
{
X  unsigned  prize;
X  unsigned  ending;
} history;
/*}}}*/
/*{{{  monster*/
EXTERN struct
{
X  MONSTER   list[MONSTERS]; /* monsters [0] is player */
X  unsigned  monsters;       /* number of monsters out (inc player) */
X  unsigned  delay;          /* escape delay */
X  unsigned  den;            /* monster spawn count */
X  unsigned  normals;        /* normal monsters alive */
X  unsigned  drones;         /* drones out */
X  unsigned  nearest;        /* what was the nearest distance to player */
X  unsigned  farthest;       /* what was the farthest distance to player */
} monster;
/*}}}*/
/*{{{  update*/
EXTERN struct
{
X  COORD     tl;       /* top left */
X  COORD     br;       /* bottom right */
X  unsigned  set;      /* tl & br set */
X  struct
X  {
X    unsigned  backs; /* number of areas to update to window */
X    BACKGROUND list[BACK_UPDATES]; /* the area information */
X  } back;
X  struct
X  {
X    unsigned  scores;  /* number of displayed scores */
X    SCORE     list[BOARD_SCORES];   /* the displayed scores */
X  } score;
} update;
/*}}}*/
/*{{{  tables*/
extern ARG const args[];
/*{{{  sprite numbers*/
#define SPRITE_CENTER_BASE     0
#define SPRITE_MUNCH_BASE      2
#define SPRITE_EDGE_BASE       4
#define SPRITE_FILL_BASE       6
#define SPRITE_DIGITS         10
#define SPRITE_CHERRY         11
#define SPRITE_DEN            12
#define SPRITE_BALL           13
#define SPRITE_APPLE          14
#define SPRITE_EXTRA          20
#define SPRITE_XTRA_SOURCE    22
#define SPRITE_MONSTERS       24
#define SPRITE_NORMAL         24
#define SPRITE_MUNCHER        36
#define SPRITE_XTRA           48
#define SPRITE_DRONE          60
#define SPRITE_PLAYER         72
#define SPRITE_PLAYER_PUSH    84
#define SPRITE_PLAYER_DEAD    88
#define SPRITE_SQUISHED       90
#define SPRITE_CHOMP          100
#define SPRITE_MRIS           102
#define SPRITE_PRIZE_BASE     110
#define SPRITES               115
/*}}}*/
#define SPRITE_FILLS           4
#define SPRITE_PRIZES          5
/*{{{  random sizes*/
#define MUNCH_WIDTH     (VEL_X * 4) 
#define MUNCH_HEIGHT    (VEL_Y * 4)
#define EDGE_WIDTH      (CELL_WIDTH + GAP_WIDTH * 2)
#define EDGE_HEIGHT     (CELL_HEIGHT + GAP_HEIGHT * 2)
#define DIGIT_HEIGHT    (CELL_HEIGHT / 2)
#define DIGIT_WIDTH     (CELL_WIDTH / 4)
#define DECAY_WIDTH     (CELL_WIDTH / 2 * 3)
#define DECAY_HEIGHT    (CELL_HEIGHT / 4 * 3)
#define ROT_WIDTH       (CELL_WIDTH / 2 * 3)
#define ROT_HEIGHT      (CELL_HEIGHT / 2)
/*}}}*/
#define BALL_WIDTH    6
#define BALL_HEIGHT   6
extern SPRITE sprites[SPRITES];
extern APPLE_SIZE const apple_sizes[6];
#define BOARDS 10
extern BOARD const boards[BOARDS];
extern char keystrokes[5];
extern COORD const ball_hold[16];
extern COORD const ball_throw[8];
extern int const ball_dir[8];
extern int const player_dies[8];
extern char const *title_text[];
#define SQUISH_SCORES 7
extern int const squish_scores[SQUISH_SCORES];
/*}}}*/
/*{{{  prototypes*/
/*{{{  apple*/
extern APPLE *apple_search PROTOARGLIST((int, int, unsigned, unsigned, unsigned));
extern int apple_stop PROTOARGLIST((MONSTER *, CELL *));
extern void apple_under PROTOARGLIST((MONSTER *, CELL *));
extern void move_apples PROTOARGLIST((void));
extern APPLE *spawn_apple PROTOARGLIST((int, int, int, int));
/*}}}*/
/*{{{  create*/
extern void create_resources PROTOARGLIST((int, char **));
extern void create_xtra_monster PROTOARGLIST((int));
extern void draw_extra_letter PROTOARGLIST((int));
extern void release_resources PROTOARGLIST((void));
/*}}}*/
/*{{{  demo*/
extern int demo_mode PROTOARGLIST((void));
extern void extra_life PROTOARGLIST((void));
extern void show_history PROTOARGLIST((void));
/*}}}*/
/*{{{  draw*/
extern void add_background PROTOARGLIST((int, int, int, int));
extern void bounding_box PROTOARGLIST((int, int, unsigned, unsigned));
extern void draw_center PROTOARGLIST((int));
extern void draw_extra PROTOARGLIST((void));
extern void new_board PROTOARGLIST((void));
extern void refresh_window PROTOARGLIST((void));
extern void show_updates PROTOARGLIST((void));
extern void text_size PROTOARGLIST((char const *, unsigned, TEXT *));
extern void zoom_board PROTOARGLIST((void));
/*}}}*/
/*{{{  monster*/
extern MONSTER *extra_escape PROTOARGLIST((void));
extern void fall_monsters PROTOARGLIST((void));
extern void move_monsters PROTOARGLIST((void));
extern void new_xtra PROTOARGLIST((void));
extern MONSTER *spawn_monster PROTOARGLIST((int, int, int, int, int, int, int));
/*}}}*/
/*{{{  move*/
extern unsigned choose_direction PROTOARGLIST((unsigned));
extern CELL *drop_apple PROTOARGLIST((APPLE *, CELL *));
extern CELL *move_movable PROTOARGLIST((MONSTER *, CELL *));
extern CELL *move_muncher PROTOARGLIST((MONSTER *));
extern void munch_hole PROTOARGLIST((CELL *, int, int));
extern void new_face PROTOARGLIST((MONSTER *));
extern int valid_directions PROTOARGLIST((MONSTER *, CELL *));
/*}}}*/
/*{{{  player*/
extern void bounce_ball PROTOARGLIST((void));
extern void move_player PROTOARGLIST((void));
/*}}}*/
/*{{{  timer*/
extern void timer_close PROTOARGLIST((void));
extern void timer_open PROTOARGLIST((void));
extern void timer_start PROTOARGLIST((unsigned long));
extern void timer_stop PROTOARGLIST((void));
extern void timer_wait PROTOARGLIST((void));
/*}}}*/
/*{{{  xmris*/
extern void add_score PROTOARGLIST((int, int, int));
extern void calc_distances PROTOARGLIST((void));
extern void fatal_error PROTOARGLIST((char const *, ...));
extern int itoa PROTOARGLIST((char *, int, int));
extern int main PROTOARGLIST((int, char **));
extern int process_xevents PROTOARGLIST((int));
extern unsigned random PROTOARGLIST((void));
/*}}}*/
/*}}}*/
SHAR_EOF
echo 'File xmris.h is complete' &&
chmod 0644 xmris.h ||
echo 'restore of xmris.h failed'
Wc_c="`wc -c < 'xmris.h'`"
test 22124 -eq "$Wc_c" ||
	echo 'xmris.h: original size 22124, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= apple.c ==============
if test -f 'apple.c' -a X"$1" != X"-c"; then
	echo 'x - skipping apple.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting apple.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'apple.c' &&
/*{{{  (C) 1992 Nathan Sidwell*/
/*****************************************************************************
X			X M R I S V1.01
X			---------------
X		    (C) 1992 Nathan Sidwell
X
This program is copyright (C) 1992 Nathan Sidwell. This software and documentation
is in the public domain. Permission is granted to distribute and compile
verbatim copies of this software for non-commercial, non-profit use,
without fee. The software may be modified, provided that both the above copyright
notice and this permission notice appear.
X
No guarantee is given as to the robustness or suitability of this
software for your computer.
X
Nathan Sidwell  INMOS UK |                 | nathan@inmos.co.uk       DoD#0390
*****************************************************************************/
/*}}}*/
#include "xmris.h"
/*{{{  APPLE *apple_search(x, y, width, height, found)*/
extern APPLE *apple_search FUNCARGLIST((x, y, width, height, found))
int       x       FUNCARGSEP  /* x coord start */
int       y       FUNCARGSEP  /* y coord start */
unsigned  width   FUNCARGSEP  /* width of box */
unsigned  height  FUNCARGSEP  /* hieght of box */
unsigned  found   FUNCARGTERM /* already found ones */
/*
X * looks for an apple in the specified box
X * and returns a ptr to it, if found
X */
{
X  unsigned  i;
X  APPLE     *aptr;
X  
X  for(aptr = apple.list, i = 0; i != apple.apples; i++, aptr++, found >>= 1)
X    if(!(found & 1) && aptr->pixel.x + aptr->push - x >= 0 &&
X	aptr->pixel.x + aptr->push - x < width &&
X	aptr->pixel.y - y >= 0 && aptr->pixel.y - y < height)
X      return aptr;
X  return NULL;
}
/*}}}*/
/*{{{  int apple_stop(mptr, cptr)*/
extern int apple_stop FUNCARGLIST((mptr, cptr))
MONSTER   *mptr FUNCARGSEP
CELL      *cptr FUNCARGTERM
/*
X * sees if the monster is about to walk into an apple
X * returns 0 if clear, 1 if stopped
X * sets mptr->pause & mptr->stop as required
X * the apples and other monsters are altered
X * if they're pushed about
X * called before we've moved the monster
X */
{
X  unsigned  stop;
X  unsigned  pause;
X  pause = stop = 0;
X  switch(mptr->dir)
X  {
X    /*{{{  case 0: (up)*/
X    case 0:
X    {
X      if(mptr->offset.y == -VEL_Y)
X	/*{{{  walked into apple?*/
X	{
X	  unsigned  i;
X	  APPLE     *aptr;
X	  int       px, py;
X			
X	  px = mptr->pixel.x;
X	  py = mptr->pixel.y;
X	  for(aptr = apple.list, i = apple.apples; i--; aptr++)
X	    {
X	      if(aptr->pixel.x + aptr->push - px < CELL_WIDTH &&
X		  aptr->pixel.x + aptr->push - px > -CELL_WIDTH &&
X		  py - aptr->pixel.y > 0 &&
X		  py - aptr->pixel.y <= CELL_HEIGHT)
X		{
X		  stop = 1;
X		  break;
X		}
X	    }
X	}
X	/*}}}*/
X      break;
X    }
X    /*}}}*/
X    /*{{{  case 1: (down)*/
X    case 1:
X    {
X      unsigned  i;
X      APPLE     *aptr;
X      int       px, py;
X	
X      px = mptr->pixel.x;
X      py = mptr->pixel.y;
X      for(aptr = apple.list, i = apple.apples; i--; aptr++)
X	{
X	  if(aptr->pixel.x + aptr->push - px < CELL_WIDTH &&
X	      aptr->pixel.x + aptr->push - px > -CELL_WIDTH &&
X	      aptr->pixel.y + apple_sizes[aptr->state].offset.y - py <=
X		  CELL_HEIGHT &&
X	      aptr->pixel.y + apple_sizes[aptr->state].offset.y - py > 0)
X	    {
X	      stop = 1;
X	      break;
X	    }
X	}
X      break;
X    }
X    /*}}}*/
X    /*{{{  case 2: (left)*/
X    case 2:
X    {
X      unsigned  found;
X      int       x, y;
X      int       width;
X      APPLE     *final;
X	  
X      found = 0;
X      final = NULL;
X      width = VEL_X;
X      x = mptr->pixel.x - CELL_WIDTH + 1 - width;
X      y = mptr->pixel.y - CELL_HEIGHT + VEL_Y;
X      /*{{{  look for apple*/
X      for(;;)
X      {
X	APPLE     *aptr;
X	CELL      *cptr;
X	      
X	aptr = apple_search(x, y,
X	    width + CELL_WIDTH / 2, 2 * (CELL_HEIGHT - VEL_Y), found);
X	if(!aptr)
X	  break;
X	else if(aptr->state > 3 || aptr->push ||
X	    aptr->pixel.x - width < PIXELX(0, 0))
X	  {
X	    stop = 1;
X	    break;
X	  }
X	else if(aptr->state == 2 && ((mptr->type != 1 && mptr->type != 4) ||
X	    (aptr->offset.x < 0 &&
X	    (cptr = BOARDCELL(aptr->cell.x, aptr->cell.y +
X		(aptr->offset.y <= 0)))->depths[2] > aptr->offset.x &&
X		  !cptr[-1].visit)))
X	  break;
X	else
X	  {
X	    final = aptr;
X	    found |= 1 << (aptr - apple.list);
X	    width = aptr->pixel.x - x + 1;
X	    aptr->maypush = width;
X	    x = aptr->pixel.x - CELL_WIDTH + 1 - width;
X	    if(aptr->state != 2 && aptr->offset.y > 0 &&
X		apple_search(x, aptr->pixel.y - aptr->offset.y +
X		CELL_HEIGHT, width, aptr->offset.y, found))
X	      {
X		stop = 1;
X		break;
X	      }
X	    y = aptr->pixel.y - CELL_HEIGHT + VEL_Y;
X	    if(!width || aptr->state == 2)
X	      break;
X	  }
X      }
X      /*}}}*/
X      if(found && !stop)
X	{
X	  /*{{{  check if against monster*/
X	  if(width)
X	    {
X	      unsigned  i;
X	      MONSTER   *mptr;
X	      MONSTER   *list;
X			    
X	      list = NULL;
X	      for(mptr = monster.list, i = monster.monsters; i--; mptr++)
X		{
X		  if(mptr->pixel.x - x >= 0 &&
X		      mptr->pixel.x - x < width + CELL_WIDTH &&
X		      mptr->pixel.y - y >= 0 &&
X		      mptr->pixel.y - y < 2 * (CELL_HEIGHT - VEL_Y))
X		    {
X		      if(mptr->type == 1)
X			{
X			  if(mptr->dir & 2 ||
X			      mptr->pixel.x - x >= width + CELL_WIDTH / 2)
X			    stop = 1;
X			}
X		      else if(mptr->pixel.x - x >= width + CELL_WIDTH / 2)
X			/*(EMPTY*/;
X		      else if(mptr->type == 4)
X			stop = 1;
X		      else if(mptr->type == 0)
X			{
X			  CELL      *cptr;
X			    
X			  cptr = BOARDCELL(mptr->cell.x, mptr->cell.y);
X			  if(cptr->depths[2] <= mptr->offset.x - width ||
X			      ((cptr->depths[1] || cptr->depths[0]) &&
X			      mptr->offset.x >= 0))
X			    {
X			      mptr->list = list;
X			      list = mptr;
X			      mptr->push = -1;
X			    }
X			  else
X			    stop = 1;
X			}
X		    }
X		}
X	      if(final->state < 2)
X		final->list = list;
X	    }
X	  /*}}}*/
X	  if(!stop)
X	  {
X	    pause = 1;
X	    /*{{{  push the apples*/
X	    {
X	      unsigned  i;
X	      APPLE     *aptr;
X				  
X	      for(aptr = apple.list, i = apple.apples; i--; aptr++, found >>= 1)
X		if(found & 1)
X		  aptr->push = -aptr->maypush;
X	    }
X	    /*}}}*/
X	  }
X	}
X      break;
X    }
X    /*}}}*/
X    /*{{{  case 3: (right)*/
X    case 3:
X    {
X      unsigned  found;
X      int       x, y;
X      int       width;
X      APPLE     *final;
X	  
X      found = 0;
X      final = NULL;
X      width = VEL_X;
X      x = mptr->pixel.x + CELL_WIDTH;
X      y = mptr->pixel.y - CELL_HEIGHT + VEL_Y;
X      /*{{{  look for apple*/
X      for(;;)
X      {
X	APPLE       *aptr;
X	      
X	aptr = apple_search(x - CELL_WIDTH / 2, y,
X	    width + CELL_WIDTH / 2, 2 * (CELL_HEIGHT - VEL_Y), found);
X	if(!aptr)
X	  break;
X	else if(aptr->state > 3 || aptr->push ||
X	    aptr->pixel.x + width > PIXELX(CELLS_ACROSS - 1, 0))
X	  {
X	    stop = 1;
X	    break;
X	  }
X	else if(aptr->state == 2 && ((mptr->type != 1 && mptr->type != 4) ||
X	    (aptr->offset.x > 0 &&
X	    (cptr = BOARDCELL(aptr->cell.x, aptr->cell.y +
X		(aptr->offset.y <= 0)))->depths[3] < aptr->offset.x &&
X		  !cptr[1].visit)))
X	  break;
X	else
X	  {
X	    final = aptr;
X	    found |= 1 << (aptr - apple.list);
X	    width -= aptr->pixel.x - x;
X	    aptr->maypush = width;
X	    x = aptr->pixel.x + CELL_WIDTH;
X	    if(aptr->state != 2 && aptr->offset.y > 0 &&
X		apple_search(x, aptr->pixel.y - aptr->offset.y +
X		CELL_HEIGHT, width, aptr->offset.y, found))
X	      {
X		stop = 1;
X		break;
X	      }
X	    y = aptr->pixel.y - CELL_HEIGHT + VEL_Y;
X	    if(!width || aptr->state == 2)
X	      break;
X	  }
X      }
X      /*}}}*/
X      /*{{{  check if against monster*/
X      if(found && width)
X	{
X	  unsigned  i;
X	  MONSTER   *mptr;
X	  MONSTER   *list;
X		
X	  list = NULL;
X	  for(mptr = monster.list, i = monster.monsters; i--; mptr++)
X	    {
X	      if(mptr->pixel.x - x >= -CELL_WIDTH &&
X		  mptr->pixel.x - x < width &&
X		  mptr->pixel.y - y >= 0 &&
X		  mptr->pixel.y - y < 2 * (CELL_HEIGHT - VEL_Y))
X		{
X		  if(mptr->type == 1)
X		    {
X		      if(mptr->dir & 2 ||
X			  mptr->pixel.x - x < -CELL_WIDTH / 2)
X			stop = 1;
X		    }
X		  else if(mptr->pixel.x - x < -CELL_WIDTH / 2)
X		    /*EMPTY*/;
X		  else if(mptr->type == 4)
X		    stop = 1;
X		  else if(mptr->type == 0)
X		    {
X		      CELL      *cptr;
X	    
X		      cptr = BOARDCELL(mptr->cell.x, mptr->cell.y);
X		      if(cptr->depths[3] >= mptr->offset.x + width ||
X			  ((cptr->depths[1] || cptr->depths[0]) &&
X			  mptr->offset.x <= 0))
X			{
X			  mptr->list = list;
X			  list = mptr;
X			  mptr->push = 1;
X			}
X		      else
X			stop = 1;
X		    }
X		}
X	    }
X	  if(final->state < 2)
X	    final->list = list;
X	}
X      /*}}}*/
X      if(found && !stop)
X	{
X	  pause = 1;
X	  /*{{{  push the apples*/
X	  {
X	    unsigned  i;
X	    APPLE     *aptr;
X			      
X	    for(aptr = apple.list, i = apple.apples; i--; aptr++, found >>= 1)
X	      if(found & 1)
X		aptr->push = aptr->maypush;
X	  }
X	  /*}}}*/
X	}
X      break;
X    }
X    /*}}}*/
X  }
X  mptr->stop = stop;
X  mptr->pause = pause | stop;
X  return stop;
}
/*}}}*/
/*{{{  void apple_under(mptr, cptr)*/
extern void apple_under FUNCARGLIST((mptr, cptr))
MONSTER   *mptr FUNCARGSEP
CELL      *cptr FUNCARGTERM
/*
X * deals with walking under apples
X * so that they start or stop rocking
X * called after we've done the move
X * only for player and muncher
X */
{
X  assert(mptr->type == 4 || mptr->type == 1);
X  switch(mptr->dir)
X  {
X    /*{{{  case 0: (up)*/
X    case 0:
X      if(!mptr->offset.y)
X	/*{{{  stop apple rocking?*/
X	{
X	  unsigned  i;
X	  APPLE     *aptr;
X			  
X	  for(aptr = apple.list, i = apple.apples; i--; aptr++)
X	    {
X	      if(aptr->pixel.x - mptr->pixel.x <= CELL_WIDTH / 2 &&
X		 aptr->pixel.x - mptr->pixel.x >= -(CELL_WIDTH / 2) &&
X		  aptr->state == 1 && mptr->cell.y == aptr->cell.y + 1)
X	      {
X		aptr->state = 0;
X		aptr->count = 1;
X	      }
X	  }
X	}
X	/*}}}*/
X      break;
X    /*}}}*/
X    /*{{{  case 1: (down)*/
X    case 1:
X      if(mptr->offset.y == VEL_Y)
X	/*{{{  start apple rocking?*/
X	{
X	  unsigned  i;
X	  APPLE     *aptr;
X			
X	  for(aptr = apple.list, i = apple.apples; i--; aptr++)
X	    {
X	      if(aptr->pixel.x - mptr->pixel.x <= CELL_WIDTH / 2 &&
X		  aptr->pixel.x - mptr->pixel.x >= -(CELL_WIDTH / 2) &&
X		  !aptr->state && mptr->cell.y == aptr->cell.y + 1)
X		{
X		  aptr->state = 1;
X		  aptr->count = APPLE_ROCK_DELAY;
X		}
X	    }
X	}
X	/*}}}*/
X      break;
X    /*}}}*/
X    /*{{{  case 2: (left)*/
X    case 2:
X    {
X      unsigned  i;
X      APPLE     *aptr;
X      int       px, py;
X      int       cy;
X	
X      px = mptr->pixel.x;
X      py = mptr->pixel.y;
X      cy = mptr->cell.y;
X      /*{{{  walking under apple?*/
X      for(aptr = apple.list, i = apple.apples; i--; aptr++)
X	{
X	  if(aptr->cell.y + 1 != cy)
X	    /*EMPTY*/;
X	  else if(aptr->pixel.x - px == CELL_WIDTH / 2 && !aptr->state)
X	    {
X	      aptr->state = 1;
X	      aptr->count = APPLE_ROCK_DELAY;
X	    }
X	  else if(mptr->type == 4 && aptr->state == 1 &&
X	      aptr->pixel.x - px == -CELL_WIDTH / 2)
X	    {
X	      aptr->state = 0;
X	      aptr->count = 1;
X	    }
X	}
X      /*}}}*/
X      break;
X    }
X    /*}}}*/
X    /*{{{  case 3: (right)*/
X    case 3:
X    {
X      unsigned  i;
X      APPLE     *aptr;
X      int       px, py;
X      int       cy;
X	
X      px = mptr->pixel.x;
X      py = mptr->pixel.y;
X      cy = mptr->cell.y;
X      /*{{{  walking under apple?*/
X      for(aptr = apple.list, i = apple.apples; i--; aptr++)
X	{
X	  if(aptr->cell.y + 1 != cy)
X	    /*EMPTY*/;
X	  else if(px - aptr->pixel.x == CELL_WIDTH / 2 && !aptr->state)
X	    {
X	      aptr->state = 1;
X	      aptr->count = APPLE_ROCK_DELAY;
X	    }
X	  else if(mptr->type == 4  && aptr->state == 1 &&
X	      px - aptr->pixel.x == -CELL_WIDTH / 2)
X	    {
X	      aptr->state = 0;
X	      aptr->count = 1;
X	    }
X	}
X      /*}}}*/
X      break;
X    }
X    /*}}}*/
X  }
X  return;
}
/*}}}*/
/*{{{  void move_apples()*/
extern void move_apples FUNCARGVOID
/*
X * moves all the apples
X */
{
X  APPLE     *aptr;
X  unsigned  i;
X
X  for(aptr = apple.list, i = apple.apples; i--; aptr++)
X    {
X      CELL      *cptr;
X  
X      cptr = BOARDCELL(aptr->cell.x, aptr->cell.y);
X      if(aptr->chewed)
X	{
X	  if(aptr->monsters)
X	    add_score(squish_scores[aptr->monsters >= SQUISH_SCORES ?
X		SQUISH_SCORES - 1 : aptr->monsters],
X		aptr->pixel.x + CELL_WIDTH / 2,
X		aptr->pixel.y + apple_sizes[4].size.y / 2);
X	  aptr->state = 6;
X	}
X      else
X	switch(aptr->state)
X	{
X	  /*{{{  case 0: (static) case 1: (rock)*/
X	  case 0: case 1:
X	    if(aptr->push)
X	      {
X		aptr->pixel.x += aptr->push;
X		aptr->offset.x += aptr->push;
X		if(aptr->offset.x < -(CELL_WIDTH / 2))
X		  {
X		    aptr->offset.x += CELL_WIDTH + GAP_WIDTH;
X		    aptr->cell.x -= 1;
X		    cptr -= 1;
X		  }
X		else if(aptr->offset.x > (CELL_WIDTH / 2))
X		  {
X		    aptr->offset.x -= CELL_WIDTH + GAP_WIDTH;
X		    aptr->cell.x += 1;
X		    cptr += 1;
X		  }
X		if(cptr[0].depths[1] > aptr->offset.y)
X		  aptr->state = 2;
X		else if(aptr->state == 0 && cptr[CELL_STRIDE].visit)
X		  {
X		    aptr->state = 1;
X		    aptr->count = APPLE_ROCK_DELAY;
X		  }
X		else if(aptr->state == 1 && !cptr[CELL_STRIDE].visit)
X		  {
X		    aptr->state = 0;
X		    aptr->count = 1;
X		  }
X	      }
X	    if(aptr->state == 1 && !aptr->count--)
X	      aptr->state = 2;
X	    if(aptr->state == 2)
X	      {
X		MONSTER   *mptr;
X				  
X		aptr->count = APPLE_ACC;
X		aptr->distance = 0;
X		if(!cptr[0].visit)
X		  {
X		    aptr->cell.y += 1;
X		    aptr->offset.y -= CELL_HEIGHT + GAP_HEIGHT;
X		  }
X		if(cptr[CELL_STRIDE].visit || cptr[0].depths[1])
X		  /*EMPTY*/;
X		else if(cptr[CELL_STRIDE-1].depths[3] +
X		    cptr[CELL_STRIDE+1].depths[2] > 0)
X		  {
X		    aptr->cell.x--;
X		    aptr->offset.x += CELL_WIDTH + GAP_WIDTH;
X		  }
X		else if(cptr[CELL_STRIDE-1].depths[3] +
X		    cptr[CELL_STRIDE+1].depths[2] < 0)
X		  {
X		    aptr->cell.x++;
X		    aptr->offset.x -= CELL_WIDTH + GAP_WIDTH;
X		  }
X		else
X		  {
X		    aptr->state = 0;
X		    aptr->list = NULL;
X		  }
X		for(mptr = aptr->list; mptr; mptr = mptr->list)
X		  {
X		    mptr->apple = aptr;
X		    aptr->monsters++;
X		    aptr->distance = APPLE_FALL_SPLIT;
X		  }
X	      }
X	    else
X	      aptr->list = NULL;
X	    break;
X	  /*}}}*/
X	  /*{{{  case 2: (fall)*/
X	  case 2:
X	  {
X	    unsigned  j;
X	    APPLE     *optr;
X	    COORD     pixel;
X			    
X	    /*{{{  horizontal movement*/
X	    if(aptr->push)
X	      {
X		aptr->pixel.x += aptr->push;
X		aptr->offset.x += aptr->push;
X		if(aptr->offset.x < -(CELL_WIDTH / 2))
X		  {
X		    aptr->offset.x += CELL_WIDTH + GAP_WIDTH;
X		    aptr->cell.x -= 1;
X		    cptr -= 1;
X		  }
X		else if(aptr->offset.x > (CELL_WIDTH / 2))
X		  {
X		    aptr->offset.x -= CELL_WIDTH + GAP_WIDTH;
X		    aptr->cell.x += 1;
X		    cptr += 1;
X		  }
X	      }
X	    else if(aptr->waspushed)
X	      /*EMPTY*/;
X	    else if(aptr->offset.x < 0)
X	      {
X		aptr->offset.x += APPLE_VEL_X;
X		aptr->pixel.x += APPLE_VEL_X;
X		assert(aptr->offset.x <= 0);
X	      }
X	    else if(aptr->offset.x > 0)
X	      {
X		aptr->offset.x -= APPLE_VEL_X;
X		aptr->pixel.x -= APPLE_VEL_X;
X		assert(aptr->offset.x >= 0);
X	      }
X	    /*}}}*/
X	    pixel.x = aptr->pixel.x - aptr->offset.x;
X	    pixel.y = aptr->pixel.y - aptr->offset.y;
X	    aptr->offset.y += aptr->count;
X	    aptr->pixel.y += aptr->count;
X	    aptr->distance += aptr->count;
X	    aptr->count += APPLE_ACC;
X	    if(aptr->count > APPLE_VEL_Y)
X	      aptr->count = APPLE_VEL_Y;
X	    /*{{{  bashes into another?*/
X	    {
X	      int       x, y;
X				
X	      x = aptr->pixel.x - CELL_WIDTH;
X	      y = pixel.y + aptr->offset.y;
X	      for(optr = apple.list, j = apple.apples; j--; optr++)
X		if(optr != aptr &&
X		    optr->pixel.x - x > 0 &&
X		    optr->pixel.x - x < CELL_WIDTH * 2 &&
X		    optr->pixel.y + apple_sizes[optr->state].offset.y - y > 0 &&
X		    optr->pixel.y + apple_sizes[optr->state].offset.y - y <
X		    CELL_HEIGHT - APPLE_VEL_Y && (optr->state ||
X		    BOARDCELL(optr->cell.x, optr->cell.y)->visit))
X		  {
X		    if(optr->state < 3)
X		      {
X			optr->state = 3;
X			optr->count = APPLE_SPLIT_DELAY;
X		      }
X		    optr = NULL;
X		    break;
X		  }
X	    }
X	    /*}}}*/
X	    if(!optr)
X	      {
X		aptr->state = 3;
X		aptr->count = APPLE_SPLIT_DELAY;
X	      }
X	    else if(aptr->offset.y >= cptr[0].depths[1])
X	      {
X		if(drop_apple(aptr, cptr))
X		  /*EMPTY*/;
X		else if(aptr->distance >= APPLE_FALL_SPLIT ||
X		    aptr->cell.y == CELLS_DOWN - 1)
X		  /*{{{  fell too far*/
X		  {
X		    aptr->state = 3;
X		    aptr->count = APPLE_SPLIT_DELAY;
X		    aptr->offset.y = cptr[0].depths[1];
X		  }
X		  /*}}}*/
X		else
X		  /*{{{  only fell a short way*/
X		  {
X		    aptr->state = 0;
X		    aptr->offset.y = cptr[0].depths[1];
X		  }
X		  /*}}}*/
X	      }
X	    else if(aptr->offset.y > 0 && cptr[CELL_STRIDE].depths[0])
X	      /*{{{  fall into next cell*/
X	      {
X		aptr->cell.y += 1;
X		aptr->offset.y -= CELL_HEIGHT + GAP_HEIGHT;
X		pixel.y += CELL_HEIGHT + GAP_HEIGHT;
X	      }
X	      /*}}}*/
X	    /*{{{  crushed someone?*/
X	    {
X	      unsigned  i;
X	      MONSTER   *mptr;
X	      int       x, y;
X				  
X	      x = pixel.x + aptr->offset.x - CELL_WIDTH + VEL_X;
X	      y = pixel.y + aptr->offset.y - APPLE_VEL_Y;
X	      for(mptr = monster.list, i = monster.monsters; i--; mptr++)
X		if(!mptr->apple && !mptr->shot && mptr->type != 5 &&
X		    mptr->pixel.x - x > 0 &&
X		    mptr->pixel.x - x < 2 * (CELL_WIDTH - VEL_X) &&
X		    mptr->pixel.y - y > 0 &&
X		    mptr->pixel.y - y < CELL_WIDTH / 2 + APPLE_VEL_Y &&
X		    (!(mptr->type & 2) || global.state == 4 ||
X		      aptr->monsters || mptr->chew || mptr->dir == 1 ||
X		      (mptr->dir == 2 && mptr->pixel.x - x <
X			CELL_WIDTH - VEL_X + CELL_WIDTH / 2) ||
X		      (mptr->dir == 3 && mptr->pixel.x - x >
X			CELL_WIDTH - VEL_X -  CELL_WIDTH / 2)))
X		  {
X		    if(mptr->type & 2 && !mptr->dir && !mptr->chew &&
X			!aptr->monsters && global.state != 4)
X		      {
X			aptr->chewed = 1;
X			mptr->chew = 1;
X		      }
X		    else
X		      {
X			if(mptr != &monster.list[0])
X			  aptr->monsters++;
X			mptr->apple = aptr;
X			aptr->distance = APPLE_FALL_SPLIT;
X			if(!aptr->state)
X			  {
X			    aptr->state = 3;
X			    aptr->count = APPLE_SPLIT_DELAY;
X			  }
X		      }
X		  }
X	    }
X	    /*}}}*/
X	    aptr->pixel.y = pixel.y + aptr->offset.y;
X	    break;
X	  }
X	  /*}}}*/
X	  /*{{{  case 3: (split)*/
X	  case 3:
X	    if(!aptr->count--)
X	      {
X		aptr->state = 4;
X		aptr->count = APPLE_DECAY_DELAY;
X		if(aptr->monsters)
X		  add_score(squish_scores[aptr->monsters >= SQUISH_SCORES ?
X		      SQUISH_SCORES - 1 : aptr->monsters],
X		      aptr->pixel.x + CELL_WIDTH / 2,
X		      aptr->pixel.y + apple_sizes[4].size.y / 2);
X	      }
X	    break;
X	  /*}}}*/
X	  /*{{{  case 4: (decay)*/
X	  case 4:
X	    if(!aptr->count--)
X	      {
X		aptr->state = 5;
X		aptr->count = APPLE_ROT_DELAY;
X	      }
X	    break;
X	  /*}}}*/
X	  /*{{{  case 5: (rot)*/
X	  case 5:
X	    if(!aptr->count--)
X	      aptr->state = 6;
X	    break;
X	  /*}}}*/
X	  /*{{{  default:*/
X	  default:
X	    assert(0);
X	  /*}}}*/
X	}
X      aptr->waspushed = aptr->push;
X      aptr->push = 0;
X    }
X  return;
}
/*}}}*/
/*{{{  APPLE *spawn_apple(cx, cy, ox, oy)*/
extern APPLE *spawn_apple FUNCARGLIST((cx, cy, ox, oy))
int       cx FUNCARGSEP
int       cy FUNCARGSEP
int       ox FUNCARGSEP
int       oy FUNCARGTERM
/*
X * spawns a new apple in state 0
X */
{
X  APPLE     *aptr;
X
X  assert(apple.apples != APPLES);
X  aptr = &apple.list[apple.apples++];
X  aptr->state = 0;
X  aptr->cell.x = cx;
X  aptr->cell.y = cy;
X  aptr->offset.x = ox = ox / APPLE_VEL_X * APPLE_VEL_X;
X  aptr->offset.y = oy;
X  aptr->count = 1;
X  aptr->old_pixel.x = aptr->pixel.x = PIXELX(cx, ox);
X  aptr->old_pixel.y = aptr->pixel.y = PIXELY(cy, oy);
X  aptr->distance = 0;
X  aptr->monsters = 0;
X  aptr->push = 0;
X  aptr->chewed = 0;
X  aptr->old_state = 7;
X  return aptr;
}
/*}}}*/
SHAR_EOF
chmod 0644 apple.c ||
echo 'restore of apple.c failed'
Wc_c="`wc -c < 'apple.c'`"
test 19361 -eq "$Wc_c" ||
	echo 'apple.c: original size 19361, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= create.c ==============
if test -f 'create.c' -a X"$1" != X"-c"; then
	echo 'x - skipping create.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting create.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'create.c' &&
/*{{{  (C) 1992 Nathan Sidwell*/
/*****************************************************************************
X			X M R I S V1.01
X			---------------
X		    (C) 1992 Nathan Sidwell
X
This program is copyright (C) 1992 Nathan Sidwell. This software and documentation
is in the public domain. Permission is granted to distribute and compile
verbatim copies of this software for non-commercial, non-profit use,
without fee. The software may be modified, provided that both the above copyright
notice and this permission notice appear.
X
No guarantee is given as to the robustness or suitability of this
software for your computer.
X
Nathan Sidwell  INMOS UK |                 | nathan@inmos.co.uk       DoD#0390
*****************************************************************************/
/*}}}*/
#define EXTERN
#include "xmris.h"
/*{{{  bitmaps*/
/*{{{  bitmaps/icon/.*/
#include "bitmaps/icon/mris.h"
#include "bitmaps/icon/msit.h"
#include "bitmaps/icon/cursor.h"
#include "bitmaps/icon/cursorm.h"
#include "bitmaps/icon/solidm.h"
#include "bitmaps/icon/solidr.h"
#include "bitmaps/icon/solidi.h"
#include "bitmaps/icon/solids.h"
#include "bitmaps/icon/solidt.h"
#include "bitmaps/icon/shellm.h"
#include "bitmaps/icon/shellr.h"
#include "bitmaps/icon/shelli.h"
#include "bitmaps/icon/shells.h"
#include "bitmaps/icon/shellt.h"
#include "bitmaps/icon/bigm.h"
#include "bitmaps/icon/bigr.h"
#include "bitmaps/icon/bigi.h"
#include "bitmaps/icon/bigs.h"
#include "bitmaps/icon/bigt.h"
/*}}}*/
/*{{{  bitmaps/board/.*/
#include "bitmaps/board/oblong.h"
#include "bitmaps/board/rect.h"
#include "bitmaps/board/munchtb.h"
#include "bitmaps/board/munchlr.h"
#include "bitmaps/board/edgetb.h"
#include "bitmaps/board/edgelr.h"
#include "bitmaps/board/fill0.h"
#include "bitmaps/board/fill1.h"
#include "bitmaps/board/fill2.h"
#include "bitmaps/board/fill3.h"
#include "bitmaps/board/digits.h"
#include "bitmaps/board/digitsm.h"
#include "bitmaps/board/cherry.h"
#include "bitmaps/board/cherrym.h"
/*}}}*/
/*{{{  bitmaps/apple/.*/
#include "bitmaps/apple/apple.h"
#include "bitmaps/apple/applem.h"
#include "bitmaps/apple/rock.h"
#include "bitmaps/apple/rockm.h"
#include "bitmaps/apple/split.h"
#include "bitmaps/apple/splitm.h"
#include "bitmaps/apple/decay.h"
#include "bitmaps/apple/decaym.h"
#include "bitmaps/apple/rot.h"
#include "bitmaps/apple/rotm.h"
/*}}}*/
/*{{{  bitmaps/player/.*/
#include "bitmaps/player/ball.h"
#include "bitmaps/player/plyrrt1.h"
#include "bitmaps/player/plyrrt1m.h"
#include "bitmaps/player/plyrrt2.h"
#include "bitmaps/player/plyrrt2m.h"
#include "bitmaps/player/plyrup1.h"
#include "bitmaps/player/plyrup1m.h"
#include "bitmaps/player/plyrup2.h"
#include "bitmaps/player/plyrup2m.h"
#include "bitmaps/player/plyrps1.h"
#include "bitmaps/player/plyrps1m.h"
#include "bitmaps/player/plyrps2.h"
#include "bitmaps/player/plyrps2m.h"
#include "bitmaps/player/plyrsq.h"
#include "bitmaps/player/plyrsqm.h"
/*}}}*/
/*{{{  bitmaps/normal/.*/
#include "bitmaps/normal/normrt1.h"
#include "bitmaps/normal/normrt1m.h"
#include "bitmaps/normal/normrt2.h"
#include "bitmaps/normal/normrt2m.h"
#include "bitmaps/normal/normup1.h"
#include "bitmaps/normal/normup1m.h"
#include "bitmaps/normal/normup2.h"
#include "bitmaps/normal/normup2m.h"
#include "bitmaps/normal/normsq.h"
#include "bitmaps/normal/normsqm.h"
#include "bitmaps/normal/den.h"
#include "bitmaps/normal/denm.h"
/*}}}*/
/*{{{  bitmaps/munch/.*/
#include "bitmaps/munch/mnchrt1.h"
#include "bitmaps/munch/mnchrt1m.h"
#include "bitmaps/munch/mnchrt2.h"
#include "bitmaps/munch/mnchrt2m.h"
#include "bitmaps/munch/mnchup1.h"
#include "bitmaps/munch/mnchup1m.h"
#include "bitmaps/munch/mnchup2.h"
#include "bitmaps/munch/mnchup2m.h"
#include "bitmaps/munch/mnchsq.h"
#include "bitmaps/munch/mnchsqm.h"
/*}}}*/
/*{{{  bitmaps/xtra/.*/
#include "bitmaps/xtra/xtra1.h"
#include "bitmaps/xtra/xtra1m.h"
#include "bitmaps/xtra/xtra2.h"
#include "bitmaps/xtra/xtra2m.h"
#include "bitmaps/xtra/xtrasq.h"
#include "bitmaps/xtra/xtrasqm.h"
#include "bitmaps/xtra/xtrbold.h"
#include "bitmaps/xtra/xtrfaint.h"
/*}}}*/
/*{{{  bitmaps/drone/.*/
#include "bitmaps/drone/dronrt1.h"
#include "bitmaps/drone/dronrt1m.h"
#include "bitmaps/drone/dronrt2.h"
#include "bitmaps/drone/dronrt2m.h"
#include "bitmaps/drone/dronup1.h"
#include "bitmaps/drone/dronup1m.h"
#include "bitmaps/drone/dronup2.h"
#include "bitmaps/drone/dronup2m.h"
#include "bitmaps/drone/dronsq.h"
#include "bitmaps/drone/dronsqm.h"
/*}}}*/
/*{{{  bitmaps/chomp/.*/
#include "bitmaps/chomp/chmpopn.h"
#include "bitmaps/chomp/chmpopnm.h"
#include "bitmaps/chomp/chmpcls.h"
#include "bitmaps/chomp/chmpclsm.h"
/*}}}*/
/*{{{  bitmaps/prize/.*/
#include "bitmaps/prize/cake.h"
#include "bitmaps/prize/cakem.h"
#include "bitmaps/prize/spanner.h"
#include "bitmaps/prize/spannerm.h"
#include "bitmaps/prize/brolly.h"
#include "bitmaps/prize/brollym.h"
#include "bitmaps/prize/mushrm.h"
#include "bitmaps/prize/mushrmm.h"
#include "bitmaps/prize/clock.h"
#include "bitmaps/prize/clockm.h"
/*}}}*/
/*}}}*/
#define XTRA_LETTER_X   ((xtra1_x_hot + xtra2_x_hot) >> 1)
#define XTRA_LETTER_Y   ((xtra1_y_hot + xtra2_y_hot) >> 1)
static unsigned long const colour_zero = 0;
static unsigned long const colour_one = ~0;
/*{{{  typedef struct Context*/
typedef struct Context
/* GC definer */
{
X  int       function;         /* graphics function */
X  unsigned long const *fgp;   /* foreground colour pointer */
X  unsigned long const *bgp;   /* background colour pointer */
} CONTEXT;
/*}}}*/
/*{{{  gcsdefine*/
static CONTEXT gcsdefine[GCS] =
{
X    {GXcopy,        &colour_one,    &colour_zero},
X    {GXcopy,        &display.white, &colour_zero},
X    {GXcopy,        &display.black, &colour_zero},
X    {GXandInverted, &colour_one,    &colour_zero},
X    {GXor,          &colour_one,    &colour_zero},
X    {GXor,          &display.white, &colour_zero},
X    {GXxor,         &display.xor,   &colour_zero},
X    {GXcopy,        &display.black, &display.white},
X    {GXand,         &colour_one,    &colour_zero},
X    {GXcopy,        &display.black, &display.white},
};
/*}}}*/
/*{{{  tables*/
/*{{{  ARG const args[] =*/
ARG const args[] =
{
X  {"help",    1, &flags.help,     "This help"},
X  {"display",-1, &display.name,   "Display to run on"},
X  {"font",   -1, &font.name,      "Font name"},
X  {"rv",      1, &flags.reverse,  "Reverse video"},
X  {"bw",      1, &flags.bw,       "Force black and white"},
X  {"iconic",  1, &flags.iconic,   "Start iconic"},
X  {"mris",    0, &flags.gender,   "Male version"},
X  {"msit",    1, &flags.gender,   "Female version"},
X  {NULL}
};
/*}}}*/
/*{{{  SPRITE sprites[] =*/
SPRITE sprites[] =
{
X  /*{{{  2:center masks (oblong, rect)*/
X  {NULL, oblong_bits, oblong_width, oblong_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {NULL, rect_bits, rect_width, rect_height, {CELL_WIDTH, CELL_HEIGHT}},
X  /*}}}*/
X  /*{{{  2:munch masks (tb,lr)*/
X  {NULL, munchtb_bits, munchtb_width, munchtb_height, {CELL_WIDTH, MUNCH_HEIGHT}},
X  {NULL, munchlr_bits, munchlr_width, munchlr_height, {MUNCH_WIDTH, CELL_HEIGHT}},
X  /*}}}*/
X  /*{{{  2:edge masks (tb, lr)*/
X  {NULL, edgetb_bits, edgetb_width, edgetb_height, {GAP_WIDTH * 5, EDGE_HEIGHT}},
X  {NULL, edgelr_bits, edgelr_width, edgelr_height, {EDGE_WIDTH, GAP_HEIGHT * 5}},
X  /*}}}*/
X  /*{{{  4:fills (0,1,2,3)*/
X  {fill0_bits, NULL, fill0_width, fill0_height, {0, 0}},
X  {fill1_bits, NULL, fill1_width, fill1_height, {0, 0}},
X  {fill2_bits, NULL, fill2_width, fill2_height, {0, 0}},
X  {fill3_bits, NULL, fill3_width, fill3_height, {0, 0}},
X  /*}}}*/
X  /*{{{  1:digits (0,1,2,3,4,5,6,7,8,9,' ')*/
X  {digits_bits, digitsm_bits, digits_width, digits_height, {DIGIT_WIDTH * 11, DIGIT_HEIGHT}},
X  /*}}}*/
X  /*{{{  1:cherry*/
X  {cherry_bits, cherrym_bits, cherry_width, cherry_height, {CELL_WIDTH, CELL_HEIGHT}},
X  /*}}}*/
X  /*{{{  1:den*/
X  {den_bits, denm_bits, den_width, den_height, {CELL_WIDTH, CELL_HEIGHT}},
X  /*}}}*/
X  /*{{{  1:ball*/
X  {ball_bits, ball_bits, ball_width, ball_height, {BALL_WIDTH, BALL_HEIGHT}},
X  /*}}}*/
X  /*{{{  6:apples (apple, rock, apple, split, decay, rot)*/
X  {apple_bits, applem_bits, apple_width, apple_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {rock_bits,  rockm_bits,  rock_width,  rock_height,  {CELL_WIDTH, CELL_HEIGHT}},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_APPLE, 0},
X  {split_bits, splitm_bits, split_width, split_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {decay_bits, decaym_bits, decay_width, decay_height, {DECAY_WIDTH, DECAY_HEIGHT}},
X  {rot_bits,   rotm_bits,   rot_width,   rot_height, {ROT_WIDTH, ROT_HEIGHT}},
X  /*}}}*/
X  /*{{{  2:extra (bold, faint)*/
X  {xtrbold_bits,  xtrbold_bits, xtrbold_width,  xtrbold_height, {CELL_WIDTH / 2 * 5, CELL_HEIGHT / 2}},
X  {xtrfaint_bits, xtrbold_bits, xtrfaint_width, xtrfaint_height, {CELL_WIDTH / 2 * 5, CELL_HEIGHT / 2}},
X  /*}}}*/
X  /*{{{  2:xtra source*/
X  {xtra1_bits, xtra1m_bits, xtra1_width, xtra1_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {xtra2_bits, xtra2m_bits, xtra2_width, xtra2_height, {CELL_WIDTH, CELL_HEIGHT}},
X  /*}}}*/
X  /*{{{  12:normal (ul, dr, l, r, ur, dl)*/
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_NORMAL + 8, 1},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_NORMAL + 9, 1},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_NORMAL + 8, 2},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_NORMAL + 9, 2},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_NORMAL + 6, 1},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_NORMAL + 7, 1},
X  {normrt1_bits, normrt1m_bits, normrt1_width, normrt1_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {normrt2_bits, normrt2m_bits, normrt2_width, normrt2_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {normup1_bits, normup1m_bits, normup1_width, normup1_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {normup2_bits, normup2m_bits, normup2_width, normup1_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_NORMAL + 0, 2},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_NORMAL + 1, 2},
X  /*}}}*/
X  /*{{{  12:muncher (ul, dr, l, r, ur, dl)*/
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_MUNCHER + 8, 1},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_MUNCHER + 9, 1},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_MUNCHER + 8, 2},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_MUNCHER + 9, 2},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_MUNCHER + 6, 1},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_MUNCHER + 7, 1},
X  {mnchrt1_bits, mnchrt1m_bits, mnchrt1_width, mnchrt1_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {mnchrt2_bits, mnchrt2m_bits, mnchrt2_width, mnchrt2_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {mnchup1_bits, mnchup1m_bits, mnchup1_width, mnchup1_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {mnchup2_bits, mnchup2m_bits, mnchup2_width, mnchup2_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_MUNCHER + 0, 2},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_MUNCHER + 1, 2},
X  /*}}}*/
X  /*{{{  12:xtra (ul, dr, l, r, ur, dl)*/
X  {xtra1_bits, xtra1m_bits, xtra1_width, xtra1_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {xtra2_bits, xtra2m_bits, xtra2_width, xtra2_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_XTRA + 0, 0},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_XTRA + 1, 0},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_XTRA + 0, 0},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_XTRA + 1, 0},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_XTRA + 0, 0},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_XTRA + 1, 0},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_XTRA + 0, 0},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_XTRA + 1, 0},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_XTRA + 0, 0},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_XTRA + 1, 0},
X  /*}}}*/
X  /*{{{  12:drone (ul, dr, l, r, ur, dl)*/
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_DRONE + 8, 1},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_DRONE + 9, 1},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_DRONE + 8, 2},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_DRONE + 9, 2},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_DRONE + 6, 1},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_DRONE + 7, 1},
X  {dronrt1_bits, dronrt1m_bits, dronrt1_width, dronrt1_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {dronrt2_bits, dronrt2m_bits, dronrt2_width, dronrt2_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {dronup1_bits, dronup1m_bits, dronup1_width, dronup1_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {dronup2_bits, dronup2m_bits, dronup2_width, dronup2_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_DRONE + 0, 2},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_DRONE + 1, 2},
X  /*}}}*/
X  /*{{{  12:player (ul, dr, l, r, ur, dl)*/
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_PLAYER + 8, 1},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_PLAYER + 9, 1},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_PLAYER + 8, 2},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_PLAYER + 9, 2},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_PLAYER + 6, 1},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_PLAYER + 7, 1},
X  {plyrrt1_bits, plyrrt1m_bits, plyrrt1_width, plyrrt1_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {plyrrt2_bits, plyrrt2m_bits, plyrrt2_width, plyrrt2_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {plyrup1_bits, plyrup1m_bits, plyrup1_width, plyrup1_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {plyrup2_bits, plyrup2m_bits, plyrup2_width, plyrup2_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_PLAYER + 0, 2},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_PLAYER + 1, 2},
X  /*}}}*/
X  /*{{{  4:player push (l, r)*/
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_PLAYER_PUSH + 2, 1},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_PLAYER_PUSH + 3, 1},
X  {plyrps1_bits, plyrps1m_bits, plyrps1_width, plyrps1_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {plyrps2_bits, plyrps2m_bits, plyrps2_width, plyrps2_height, {CELL_WIDTH, CELL_HEIGHT}},
X  /*}}}*/
X  /*{{{  2:player dead (l, r)*/
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_PLAYER + 4, 2},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_PLAYER + 6, 2},
X  /*}}}*/
X  /*{{{  10:squished*/
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_SQUISHED + 1, 1},
X  {normsq_bits, normsqm_bits, normsq_width, normsq_height, {CELL_WIDTH, CELL_HEIGHT / 4}},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_SQUISHED + 3, 1},
X  {mnchsq_bits, mnchsqm_bits, mnchsq_width, mnchsq_height, {CELL_WIDTH, CELL_HEIGHT / 4}},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_SQUISHED + 5, 0},
X  {xtrasq_bits, xtrasqm_bits, xtrasq_width, xtrasq_height, {CELL_WIDTH, CELL_HEIGHT / 4}},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_SQUISHED + 7, 1},
X  {dronsq_bits, dronsqm_bits, dronsq_width, dronsq_height, {CELL_WIDTH, CELL_HEIGHT / 4}},
X  {NULL, NULL, 0, 0, {0, 0}, SPRITE_SQUISHED + 9, 1},
X  {plyrsq_bits, plyrsqm_bits, plyrsq_width, plyrsq_height, {CELL_WIDTH, CELL_HEIGHT / 4}},
X  /*}}}*/
X  /*{{{  2:chomp (open, closed)*/
X  {chmpopn_bits, chmpopnm_bits, chmpopn_width, chmpopn_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {chmpcls_bits, chmpclsm_bits, chmpcls_width, chmpcls_height, {CELL_WIDTH, CELL_HEIGHT}},
X  /*}}}*/
X  /*{{{  8:m r i s*/
X  {solidm_bits, bigm_bits, solidm_width, solidm_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {solidr_bits, bigr_bits, solidr_width, solidr_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {solidi_bits, bigi_bits, solidi_width, solidi_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {solids_bits, bigs_bits, solids_width, solids_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {shellm_bits, bigm_bits, shellm_width, shellm_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {shellr_bits, bigr_bits, shellr_width, shellr_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {shelli_bits, bigi_bits, shelli_width, shelli_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {shells_bits, bigs_bits, shells_width, shells_height, {CELL_WIDTH, CELL_HEIGHT}},
X  /*}}}*/
X  /*{{{  5:prizes*/
X  {cake_bits,    cakem_bits,    cake_width,    cake_height,    {CELL_WIDTH, CELL_HEIGHT}},
X  {spanner_bits, spannerm_bits, spanner_width, spanner_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {brolly_bits,  brollym_bits,  brolly_width,  brolly_height,  {CELL_WIDTH, CELL_HEIGHT}},
X  {mushrm_bits,  mushrmm_bits,  mushrm_width,  mushrm_height,  {CELL_WIDTH, CELL_HEIGHT}},
X  {clock_bits,   clockm_bits,   clock_width,   clock_height,   {CELL_WIDTH, CELL_HEIGHT}},
X  /*}}}*/
};
/*}}}*/
/*{{{  static SPRITE spritet[2] =*/
static SPRITE spritet[2] =
{
X  {solidt_bits, bigt_bits, solidt_width, solidt_height, {CELL_WIDTH, CELL_HEIGHT}},
X  {shellt_bits, bigt_bits, shellt_width, shellt_height, {CELL_WIDTH, CELL_HEIGHT}},
};
/*}}}*/
/*{{{  static SPRITE icons[2] =*/
static SPRITE icons[2] =
{
X  {NULL, mris_bits, mris_width, mris_height},
X  {NULL, msit_bits, msit_width, msit_height},
};
/*}}}*/
/*{{{  APPLE_SIZE const apple_sizes[6] =*/
APPLE_SIZE const apple_sizes[6] =
X  {
X    {{CELL_WIDTH, CELL_HEIGHT}, {0, 0}},
X    {{CELL_WIDTH, CELL_HEIGHT}, {0, 0}},
X    {{CELL_WIDTH, CELL_HEIGHT}, {0, 0}},
X    {{CELL_WIDTH, CELL_HEIGHT}, {0, 0}},
X    {{DECAY_WIDTH, DECAY_HEIGHT},
X	  {(CELL_WIDTH - DECAY_WIDTH) / 2, CELL_HEIGHT - DECAY_HEIGHT}},
X    {{ROT_WIDTH, ROT_HEIGHT},
X	  {(CELL_WIDTH - ROT_WIDTH) / 2, CELL_HEIGHT - ROT_HEIGHT}},
X  };
/*}}}*/
/*{{{  BOARD const boards[10] =*/
#if BOARDS != 10
X  #error BOARDS != 10
#endif
/*
X * the initial board maps are stored as character arrays
X * X for a path
X * @ for cherry
X */
BOARD const boards[BOARDS] =
X  {
X    /*{{{  board 0*/
X    {
X      0,
X      {
X	"..XXXXXXXX..",
X	".XX......XX.",
X	"XXXX......XX",
X	"X..XX..@@@@X",
X	"X...XX.@@@@X",
X	"X@@@@X.....X",
X	"X@@@@X...@@X",
X	"X....XX..@@X",
X	"X@@@@.XX.@@X",
X	"X@@@@..XX@@X",
X	"XX..@@@@XXXX",
X	".XX.@@@@.XX.",
X	"..XXXXXXXX..",
X      }
X    },
X    /*}}}*/
X    /*{{{  board 1*/
X    {
X      0,
X      {
X	"....XXXXXX..",
X	"@@...X...XX.",
X	"@@...X@@@@XX",
X	"@@.@@X@@@@.X",
X	"@@.@@X.....X",
X	"...@@X.....X",
X	"...@@X..@@.X",
X	".....X..@@.X",
X	"@@@@.X..@@.X",
X	"@@@@.X..@@.X",
X	"XXX..X....XX",
X	"X.X..X...XX.",
X	"XXXXXXXXXX..",
X      }
X    },
X    /*}}}*/
X    /*{{{  board 2*/
X    {
X      1,
X      {
X	"..XXXXXXXX..",
X	".XX......XX.",
X	"XX@@@@....XX",
X	"X.@@@@..@@.X",
X	"........@@.X",
X	"@@......@@.X",
X	"@@...X..@@XX",
X	"@@...XXXXXX.",
X	"@@.XXX....@@",
X	".XXX@@@@..@@",
X	"XX..@@@@..@@",
X	"X.........@@",
X	"XXXXXXXXXXXX",
X      }
X    },
X    /*}}}*/
X    /*{{{  board 3*/
X    {
X      2,
X      {
X	"..XXXXXXXX..",
X	".XX......XX.",
X	"XX........XX",
X	"X..@@@@.@@.X",
X	"@@.@@@@.@@.X",
X	"@@......@@.X",
X	"@@...X..@@XX",
X	"@@..XXXXXXX.",
X	"...@@.....XX",
X	"...@@..@@@@X",
X	"X..@@..@@@@X",
X	"XX.@@.....XX",
X	".XXXXXXXXXX.",
X      }
X    },
X    /*}}}*/
X    /*{{{  board 4*/
X    {
X      2,
X      {
X	"....XXXXXX..",
X	"@@@@X....X..",
X	"@@@@X....X@@",
X	"...XX....X@@",
X	"@@.X...@@X@@",
X	"@@XX...@@X@@",
X	"@@X..X.@@X..",
X	"@@XXXX.@@X..",
X	"XXX......X..",
X	"X........X..",
X	"XXXXXXXXXXXX",
X	".@@@@....X..",
X	".@@@@XXXXX..",
X      }
X    },
X    /*}}}*/
X    /*{{{  board 5*/
X    {
X      2,
X      {
X	"XXXXXXXXXXXX",
X	"X...........",
X	"X.@@@@......",
X	"X.@@@@..@@@@",
X	"X.......@@@@",
X	"XXXXXXXXXXX.",
X	"....XXX...XX",
X	".@@.XXX..@@X",
X	".@@......@@X",
X	".@@.@@@@.@@X",
X	"X@@.@@@@.@@X",
X	"XX........XX",
X	".XXXXXXXXXX.",
X      }
X    },
X    /*}}}*/
X    /*{{{  board 6*/
X    {
X      2,
X      {
X	"..XXXXXXXXXX",
X	".XX.........",
X	"XX..........",
X	"X.@@.@@@@.@@",
X	"X.@@.@@@@.@@",
X	"X.@@......@@",
X	"X.@@.X....@@",
X	"XXXXXXXXXXX.",
X	"X.........XX",
X	"X@@@@......X",
X	"X@@@@.@@@@.X",
X	"XX....@@@@XX",
X	".XXXXXXXXXX.",
X      }
X    },
X    /*}}}*/
X    /*{{{  board 7*/
X    {
X      3,
X      {
X	"XXXXXXXXXXXX",
X	"X..........X",
X	".@@.......XX",
X	".@@.@@@@.XX.",
X	".@@.@@@@XX..",
X	".@@....XX.@@",
X	".....XXX..@@",
X	".....XX...@@",
X	"@@@@.X.@@.@@",
X	"@@@@.X.@@...",
X	".....X.@@...",
X	".....X.@@...",
X	".....X......",
X      }
X    },
X    /*}}}*/
X    /*{{{  board 8*/
X    {
X      3,
X      {
X	"..XXXXXXXX..",
X	".XX......XX.",
X	"XX@@.@@.@@XX",
X	"X.@@.@@.@@.X",
X	"X.@@.@@.@@.X",
X	"XX@@.@@.@@XX",
X	".XX..X...XX.",
X	"..XXXXXXXX..",
X	"XXX......XXX",
X	"X@@@@......X",
X	"X@@@@.@@@@.X",
X	"XX....@@@@XX",
X	".XXXXXXXXXX.",
X      }
X    },
X    /*}}}*/
X    /*{{{  board 9*/
X    {
X      3,
X      {
X	"..XXXXXXXX..",
X	".XX......XX.",
X	"XX...@@@@.XX",
X	"X.@@.@@@@..X",
X	"X.@@.......X",
X	"X.@@...@@@@X",
X	"XX@@.X.@@@@X",
X	".XXXXXXXXXXX",
X	"@@.........X",
X	"@@....@@@@.X",
X	"@@....@@@@XX",
X	"@@.......XX.",
X	"XXXXXXXXXX..",
X      }
X    },
X    /*}}}*/
X  };
/*}}}*/
char keystrokes[5] = {'\'', '/', 'z', 'x', ' '};
/*{{{  COORD const ball_hold[16] =*/
/*{{{  held ball offsets*/
#define PLAYER_RIGHT1_BALL_X   (plyrrt1_x_hot - CELL_WIDTH / 2)
#define PLAYER_RIGHT1_BALL_Y   (plyrrt1_y_hot - CELL_HEIGHT / 2)
#define PLAYER_UP1_BALL_X      (plyrup1_x_hot - CELL_WIDTH / 2)
#define PLAYER_UP1_BALL_Y      (plyrup1_y_hot - CELL_HEIGHT / 2)
#define PLAYER_RIGHT2_BALL_X   (plyrrt2_x_hot - CELL_WIDTH / 2)
#define PLAYER_RIGHT2_BALL_Y   (plyrrt2_y_hot - CELL_HEIGHT / 2)
#define PLAYER_UP2_BALL_X      (plyrup2_x_hot - CELL_WIDTH / 2)
#define PLAYER_UP2_BALL_Y      (plyrup2_y_hot - CELL_HEIGHT / 2)
#define PLAYER_PUSH1_BALL_X    (plyrps1_x_hot - CELL_WIDTH / 2)
#define PLAYER_PUSH1_BALL_Y    (plyrps1_y_hot - CELL_HEIGHT / 2)
#define PLAYER_PUSH2_BALL_X    (plyrps2_x_hot - CELL_WIDTH / 2)
#define PLAYER_PUSH2_BALL_Y    (plyrps2_y_hot - CELL_HEIGHT / 2)
/*}}}*/
COORD const ball_hold[16] =
{
X {-PLAYER_UP1_BALL_X - BALL_WIDTH / 2,  PLAYER_UP1_BALL_Y - BALL_HEIGHT / 2},
SHAR_EOF
true || echo 'restore of create.c failed'
fi
echo 'End of  part 2'
echo 'File create.c is continued in part 3'
echo 3 > _shar_seq_.tmp
exit 0
-- 
---
Senior Systems Scientist		mail: dcmartin@msi.com
Molecular Simulations, Inc.		uucp: uunet!dcmartin
796 North Pastoria Avenue		at&t: 408/522-9236
