Newsgroups: comp.sources.x
From: jck@kimba.catt.citri.edu.au (Justin Kibell)
Subject: v20i115:  xboing - a simple blockout type game, Part08/26
Message-ID: <1993Sep3.123220.7219@sparky.sterling.com>
X-Md4-Signature: fbd880999bdd8e9cb49eb1114b3529d4
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Fri, 3 Sep 1993 12:32:20 GMT
Approved: chris@sterling.com

Submitted-by: jck@kimba.catt.citri.edu.au (Justin Kibell)
Posting-number: Volume 20, Issue 115
Archive-name: xboing/part08
Environment: X11, xpm, color

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  blocks.c2 highscore.c score.h
# Wrapped by chris@sparky on Fri Sep  3 07:14:44 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 8 (of 26)."'
if test -f 'blocks.c2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'blocks.c2'\"
else
  echo shar: Extracting \"'blocks.c2'\" \(24327 characters\)
  sed "s/^X//" >'blocks.c2' <<'END_OF_FILE'
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r, c+1, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r-1, c, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r, c-1, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r-1, c-1, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r-1, c+1, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r+1, c-1, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r+1, c+1, 
X									frame + EXPLODE_DELAY);
X
X								/* Special effect where screen shakes 
X								 * during explosion 
X								 */
X								SetSfxEndFrame(frame + 70);
X								changeSfxMode(SFX_SHAKE);
X								break;
X
X							case BULLET_BLK:
X								SetCurrentMessage(display, messWindow, 
X									"More ammunition, cool!", True);
X								AddABullet(display);
X								AddABullet(display);
X								AddABullet(display);
X								AddABullet(display);
X								break;
X
X							case BONUS_BLK:
X								IncNumberBonus();
X
X								if (GetNumberBonus() <= MAX_BONUS)
X									sprintf(str, 
X										"- Bonus #%d -", GetNumberBonus());
X								else
X									sprintf(str, "- Super Bonus -");
X
X								SetCurrentMessage(display, messWindow, str, 
X									True);
X								bonusBlock = False;
X
X								/* Turn on killer mode after 10 bonuses */
X								if (GetNumberBonus() == 10)
X								{
X									/* Turn on killer mode */
X									ToggleKiller(display, True);
X									DrawSpecials(display);
X
X									SetCurrentMessage(display, messWindow, 
X										"- Killer Mode -", True);
X								}
X								break;
X
X							case BONUSX2_BLK:
X								Togglex2Bonus(display, True);
X								Togglex4Bonus(display, False);
X								DrawSpecials(display);
X
X								bonusBlock = False;
X								SetCurrentMessage(display, messWindow, 
X									"- x2 Bonus -", True);
X								break;
X
X							case BONUSX4_BLK:
X								Togglex2Bonus(display, False);
X								Togglex4Bonus(display, True);
X								DrawSpecials(display);
X
X								bonusBlock = False;
X								SetCurrentMessage(display, messWindow, 
X									"- x4 Bonus -", True);
X								break;
X
X							default :
X								break;
X						}
X
X						/* Reset to a non exploding block */
X						ClearBlock(r, c);
X					}
X				}
X			}
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid DrawTheBlock(Display *display, Window window, int x, int y, 
X	int blockType, int slide)
X#else
Xvoid DrawTheBlock(display, window, x, y, blockType, slide)
X	Display *display;
X	Window window;
X	int x;
X	int y; 
X	int blockType;
X	int slide;
X#endif
X{
X	switch(blockType)
X	{
X		case PAD_SHRINK_BLK:	/* Paddle shrink block */
X			RenderShape(display, window, paddleshrink,
X				paddleshrinkM, x, y, 40, 15, True);
X			break;
X
X		case PAD_EXPAND_BLK:	/* Paddle expand block */
X			RenderShape(display, window, paddleexpand,
X				paddleexpandM, x, y, 40, 15, True);
X			break;
X
X		case BULLET_BLK:	/* Draw a bullet shape */
X			RenderShape(display, window, yellowblock, yellowblockM, 
X				x, y, 40, 20, True);
X			DrawTheBullet(display, window, x+6, y+10);
X			DrawTheBullet(display, window, x+15, y+10);
X			DrawTheBullet(display, window, x+24, y+10);
X			DrawTheBullet(display, window, x+33, y+10);
X			break;
X
X		case MULTIBALL_BLK:	/* Draw multiple ball block */
X			RenderShape(display, window, multiball, multiballM, 
X				x, y, 40, 20, True);
X			break;
X
X		case STICKY_BLK:	/* Draw sticky block */
X			RenderShape(display, window, sticky, stickyM, 
X				x, y, 32, 32, True);
X			break;
X
X		case RED_BLK:	/* Draw a red block shape */
X			RenderShape(display, window, redblock, redblockM, 
X				x, y, 40, 20, True);
X			break;
X
X		case BLACK_BLK:		/* Draw a solid wall block */	
X			RenderShape(display, window, blackblock, blackblockM, 
X				x, y, 50, 30, True);
X			break;
X
X		case GREEN_BLK:		/* Draw a green block */
X			RenderShape(display, window, greenblock, greenblockM, 
X				x, y, 40, 20, True);
X			break;
X
X		case BLUE_BLK:		/* Draw a blue block */
X			RenderShape(display, window, blueblock, blueblockM, 
X				x, y, 40, 20, True);
X			break;
X
X		case YELLOW_BLK:	/* Draw a yellow block */
X			RenderShape(display, window, yellowblock, yellowblockM, 
X				x, y, 40, 20, True);
X			break;
X
X		case TAN_BLK:		/* Draw a tan block */
X			RenderShape(display, window, tanblock, tanblockM, 
X				x, y, 40, 20, True);
X			break;
X
X		case PURPLE_BLK:	/* Draw a purple block */
X			RenderShape(display, window, purpleblock, purpleblockM, 
X				x, y, 40, 20, True);
X			break;
X
X		case COUNTER_BLK:	/* Draw a frame of counter block */
X			RenderShape(display, window, counterblock[slide], 
X				counterblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case BONUSX2_BLK:	/* Draw a bonus x2 coin block */
X			RenderShape(display, window, x2bonus[slide], 
X				x2bonusM[slide], x, y, 27, 27, True);
X			break;
X
X		case BONUSX4_BLK:	/* Draw a bonus x4 coin block */
X			RenderShape(display, window, x4bonus[slide], 
X				x4bonusM[slide], x, y, 27, 27, True);
X			break;
X
X		case BONUS_BLK:	/* Draw a bonus coin block */
X			RenderShape(display, window, Bonus[slide], 
X				BonusM[slide], x, y, 27, 27, True);
X			break;
X
X		case BOMB_BLK:		/* Draw a bomb block */
X			RenderShape(display, window, bombblock, bombblockM, 
X				x, y, 30, 30, True);
X			break;
X
X		case DEATH_BLK:		/* Draw the pirate death block */
X			RenderShape(display, window, death[slide], deathM[slide], 
X				x, y, 30, 30, True);
X			break;
X
X		case REVERSE_BLK:	/* Draw the reverse block */
X			RenderShape(display, window, revblock, revblockM, 
X				x, y, 33, 16, True);
X			break;
X
X		case EXTRABALL_BLK:	/* Draw the extra ball block */
X			RenderShape(display, window, extraball[slide], extraballM[slide], 
X				x, y, 30, 19, True);
X			break;
X
X		case HYPERSPACE_BLK:	/* Draw the hyperspace block */
X			RenderShape(display, window, hyperblock, hyperblockM, 
X				x, y, 31, 31, True);
X			break;
X
X		case MGUN_BLK:	/* Draw the machine gun block */
X			RenderShape(display, window, mgunblock, mgunblockM, 
X				x, y, 35, 15, True);
X			break;
X
X		case WALLOFF_BLK:	/* Draw the wall off block */
X			RenderShape(display, window, walloffblock, walloffblockM, 
X				x, y, 27, 23, True);
X			break;
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void SetBlockUpForExplosion(int row, int col, int frame)
X#else
Xstatic void SetBlockUpForExplosion(row, col, frame)
X	int row;
X	int col;
X	int frame;
X#endif
X{
X    struct aBlock *blockP;
X
X	if (row < 0 || row >= MAX_ROW) return;
X	if (col < 0 || col >= MAX_COL) return;
X
X	/* Obtain a pointer to the affected block */
X	blockP = &blocks[row][col];
X
X	/* Do not have any effect on a specials block */
X	if (blockP->blockType == HYPERSPACE_BLK) return;
X
X	/* If it isn't occupied then why blow it up */
X	if (blockP->occupied == 1 && blockP->exploding == False)
X	{
X		/* Keep track of how many blocks are exploding */
X		blocksExploding++;
X
X		/* Some special variables used for timing */
X		blockP->explodeStartFrame 	= frame;
X		blockP->explodeNextFrame 	= frame;
X		blockP->explodeSlide 		= 1;
X		blockP->exploding 			= True;
X	}
X}
X
X
X#if NeedFunctionPrototypes
Xvoid DrawBlock(Display *display, Window window, int row, int col, int blockType)
X#else
Xvoid DrawBlock(display, window, row, col, blockType)
X	Display *display;
X	Window window;
X	int row;
X	int col;
X	int blockType;
X#endif
X{
X	struct aBlock *blockP;
X
X	if (row < 0 || row > MAX_ROW) 
X	{
X		ErrorMessage("Block out of bounds row.");
X		return;
X	}
X
X	if (col < 0 || col > MAX_COL) 
X	{
X		ErrorMessage("Block out of bounds column.");
X		return;
X	}
X
X	/* Pointer to the block in question */
X	blockP = &blocks[row][col];
X
X	switch(blockType)
X	{
X		case KILL_BLK:		/* Special block - blow it up */
X			PlaySoundForBlock(blockP->blockType);
X
X			if (blockP->blockType != BLACK_BLK)
X				SetBlockUpForExplosion(row, col, frame);
X			break;
X
X		default:			/* Your average block - draw it */
X			DrawTheBlock(display, window, blockP->x, blockP->y, 
X				blockType, blockP->counterSlide);
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid FreeBlockPixmaps(Display *display)
X#else
Xvoid FreeBlockPixmaps(display)
X	Display *display;
X#endif
X{
X	int i;
X
X	/* Free the memory associated with the block pixmaps */
X	if (redblock)		XFreePixmap(display, redblock);			
X	if (redblockM)		XFreePixmap(display, redblockM);
X	if (blueblock)		XFreePixmap(display, blueblock);		
X	if (blueblockM)		XFreePixmap(display, blueblockM);
X	if (greenblock)		XFreePixmap(display, greenblock);		
X	if (greenblockM)	XFreePixmap(display, greenblockM);
X	if (tanblock)		XFreePixmap(display, tanblock);			
X	if (tanblockM)		XFreePixmap(display, tanblockM);
X	if (yellowblock)	XFreePixmap(display, yellowblock);		
X	if (yellowblockM)	XFreePixmap(display, yellowblockM);
X	if (purpleblock)	XFreePixmap(display, purpleblock);		
X	if (purpleblockM)	XFreePixmap(display, purpleblockM);
X	if (blackblock)		XFreePixmap(display, blackblock);		
X	if (blackblockM)	XFreePixmap(display, blackblockM);
X	if (bombblock)		XFreePixmap(display, bombblock);		
X	if (bombblockM)		XFreePixmap(display, bombblockM);
X	if (revblock)		XFreePixmap(display, revblock);		
X	if (revblockM)		XFreePixmap(display, revblockM);
X	if (hyperblock)		XFreePixmap(display, hyperblock);		
X	if (hyperblockM)	XFreePixmap(display, hyperblockM);
X	if (mgunblock)		XFreePixmap(display, mgunblock);		
X	if (mgunblockM)		XFreePixmap(display, mgunblockM);
X	if (walloffblock)	XFreePixmap(display, walloffblock);		
X	if (walloffblockM)	XFreePixmap(display, walloffblockM);
X	if (multiball)		XFreePixmap(display, multiball);		
X	if (multiballM)		XFreePixmap(display, multiballM);
X	if (sticky)			XFreePixmap(display, sticky);		
X	if (stickyM)		XFreePixmap(display, stickyM);
X	if (paddleexpand)	XFreePixmap(display, paddleexpand);		
X	if (paddleexpandM)	XFreePixmap(display, paddleexpandM);
X	if (paddleshrink)	XFreePixmap(display, paddleshrink);		
X	if (paddleshrinkM)	XFreePixmap(display, paddleshrinkM);
X
X	for (i = 0; i < 5; i++)
X	{
X		/* Free the frames for the death block */
X		if (death[i])	XFreePixmap(display, death[i]); 	
X		if (deathM[i])	XFreePixmap(display, deathM[i]);
X	}
X
X	for (i = 0; i < 6; i++)
X	{
X		if (counterblock[i])	XFreePixmap(display, counterblock[i]); 	
X		if (counterblockM[i])	XFreePixmap(display, counterblockM[i]);
X	}
X
X	for (i = 0; i < 4; i++)
X	{
X		if (x2bonus[i])			XFreePixmap(display, x2bonus[i]); 	
X		if (x2bonusM[i])		XFreePixmap(display, x2bonusM[i]);
X
X		if (x4bonus[i])			XFreePixmap(display, x4bonus[i]); 	
X		if (x4bonusM[i])		XFreePixmap(display, x4bonusM[i]);
X
X		if (Bonus[i])			XFreePixmap(display, Bonus[i]); 	
X		if (BonusM[i])			XFreePixmap(display, BonusM[i]);
X	}
X
X	for (i = 0; i < 2; i++)
X	{
X		if (extraball[i])		XFreePixmap(display, extraball[i]); 	
X		if (extraballM[i])		XFreePixmap(display, extraballM[i]);
X	}
X
X	for (i = 0; i < 3; i++)
X	{
X		if (exgreenblock[i])   	XFreePixmap(display, exgreenblock[i]); 	
X		if (exgreenblockM[i])   XFreePixmap(display, exgreenblockM[i]);
X
X		if (exyellowblock[i])   XFreePixmap(display, exyellowblock[i]);
X		if (exyellowblockM[i])  XFreePixmap(display, exyellowblockM[i]);
X
X		if (exredblock[i])     	XFreePixmap(display, exredblock[i]);
X		if (exredblockM[i])     XFreePixmap(display, exredblockM[i]);
X
X		if (exblueblock[i])     XFreePixmap(display, exblueblock[i]);
X		if (exblueblockM[i])    XFreePixmap(display, exblueblockM[i]);
X
X		if (extanblock[i])     	XFreePixmap(display, extanblock[i]);
X		if (extanblockM[i])     XFreePixmap(display, extanblockM[i]);
X
X		if (excounterblock[i])  XFreePixmap(display, excounterblock[i]);
X		if (excounterblockM[i]) XFreePixmap(display, excounterblockM[i]);
X
X		if (exbombblock[i])     XFreePixmap(display, exbombblock[i]);
X		if (exbombblockM[i])    XFreePixmap(display, exbombblockM[i]);
X		
X		if (expurpleblock[i])   XFreePixmap(display, expurpleblock[i]);
X		if (expurpleblockM[i])  XFreePixmap(display, expurpleblockM[i]);
X		
X		if (exx2bonus[i])     	XFreePixmap(display, exx2bonus[i]);
X		if (exx2bonusM[i])     	XFreePixmap(display, exx2bonusM[i]);
X
X		if (exdeath[i])			XFreePixmap(display, exdeath[i]); 	
X		if (exdeathM[i])		XFreePixmap(display, exdeathM[i]);
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void CalculateBlockGeometry(int row, int col)
X#else
Xstatic void CalculateBlockGeometry(row, col)
X	int row, col;
X#endif
X{
X	struct aBlock *blockP;
X	XPoint points[4];
X	int halfWidth, halfHeight;
X
X	/* Pointer to the correct block we need - speed things up */
X	blockP = &blocks[row][col];
X
X	switch (blockP->blockType)
X	{
X		case COUNTER_BLK:
X			blockP->width 			= BLOCK_WIDTH;
X			blockP->height			= BLOCK_HEIGHT;
X			blockP->blockOffsetX	= (colWidth - BLOCK_WIDTH) / 2;
X			blockP->blockOffsetY 	= (rowHeight - BLOCK_HEIGHT) / 2;
X			break;
X
X		case MGUN_BLK:
X			blockP->width 			= 35;
X			blockP->height			= 15;
X			blockP->blockOffsetX	= (colWidth - 35) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 15) / 2;
X			break;
X
X		case WALLOFF_BLK:
X			blockP->width 			= 27;
X			blockP->height			= 23;
X			blockP->blockOffsetX	= (colWidth - 27) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 23) / 2;
X			break;
X
X		case REVERSE_BLK:
X			blockP->width 			= 33;
X			blockP->height			= 16;
X			blockP->blockOffsetX	= (colWidth - 33) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 16) / 2;
X			break;
X
X		case EXTRABALL_BLK:
X			blockP->width 			= 30;
X			blockP->height			= 19;
X			blockP->blockOffsetX	= (colWidth - 30) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 19) / 2;
X			break;
X
X		case HYPERSPACE_BLK:
X			blockP->width 			= 31;
X			blockP->height			= 31;
X			blockP->blockOffsetX	= (colWidth - 31) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 31) / 2;
X			break;
X
X		case BOMB_BLK:
X		case DEATH_BLK:
X			blockP->width 			= 30;
X			blockP->height			= 30;
X			blockP->blockOffsetX	= (colWidth - 30) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 30) / 2;
X			break;
X
X		case STICKY_BLK:
X			blockP->width 			= 32;
X			blockP->height			= 32;
X			blockP->blockOffsetX	= (colWidth - 32) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 32) / 2;
X			break;
X
X		case BLACK_BLK:
X			blockP->width 			= 50;
X			blockP->height			= 30;
X			blockP->blockOffsetX	= (colWidth - 50) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 30) / 2;
X			break;
X
X        case PAD_SHRINK_BLK:
X		case PAD_EXPAND_BLK:
X			blockP->width 			= 40;
X			blockP->height			= 15;
X			blockP->blockOffsetX	= (colWidth - 40) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 15) / 2;
X			break;
X
X		case BONUS_BLK:
X		case BONUSX4_BLK:
X		case BONUSX2_BLK:
X			blockP->width 			= 27;
X			blockP->height			= 27;
X			blockP->blockOffsetX	= (colWidth - 27) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 27) / 2;
X			break;
X
X		default:		/* All other blocks */
X			blockP->width 			= BLOCK_WIDTH;
X			blockP->height			= BLOCK_HEIGHT;
X			blockP->blockOffsetX	= (colWidth - BLOCK_WIDTH) / 2;
X			blockP->blockOffsetY 	= (rowHeight - BLOCK_HEIGHT) / 2;
X			break;
X
X	}	
X
X	/* Calculate the offset within the block grid */
X	blockP->x = (col * colWidth) + blockP->blockOffsetX;
X	blockP->y = (row * rowHeight) + blockP->blockOffsetY;
X
X	/* Used below */
X	halfWidth = blockP->x + (blockP->width / 2);
X	halfHeight = blockP->y + (blockP->height / 2);
X
X	/* Create the XPoint array for the top region */
X	points[0].x = blockP->x;
X	points[0].y = blockP->y;
X	points[1].x = halfWidth;
X	points[1].y = halfHeight;
X	points[2].x = blockP->x + blockP->width;
X	points[2].y = blockP->y;
X	points[3].x = points[0].x;
X	points[3].y = points[0].y;
X
X	/* Create the top region for the block */
X    blockP->regionTop = XPolygonRegion(points, 4, EvenOddRule);
X
X	/* Create the XPoint array for the bottom region */
X	points[0].x = blockP->x;
X	points[0].y = blockP->y + blockP->height;
X	points[1].x = halfWidth;
X	points[1].y = halfHeight;
X	points[2].x = blockP->x + blockP->width;
X	points[2].y = points[0].y;
X	points[3].x = points[0].x;
X	points[3].y = points[0].y;
X
X	/* Create the bottom region for the block */
X    blockP->regionBottom = XPolygonRegion(points, 4, EvenOddRule);
X
X	/* Create the XPoint array for the left region */
X	points[0].x = blockP->x;
X	points[0].y = blockP->y;
X	points[1].x = halfWidth;
X	points[1].y = halfHeight;
X	points[2].x = blockP->x;
X	points[2].y = blockP->y + blockP->height;
X	points[3].x = points[0].x;
X	points[3].y = points[0].y;
X
X	/* Create the left region for the block */
X    blockP->regionLeft = XPolygonRegion(points, 4, EvenOddRule);
X
X	/* Create the XPoint array for the right region */
X	points[0].x = blockP->x + blockP->width;
X	points[0].y = blockP->y;
X	points[1].x = halfWidth;
X	points[1].y = halfHeight;
X	points[2].x = points[0].x;
X	points[2].y = blockP->y + blockP->height;
X	points[3].x = points[0].x;
X	points[3].y = points[0].y;
X
X	/* Create the right region for the block */
X    blockP->regionRight = XPolygonRegion(points, 4, EvenOddRule);
X}
X
X#if NeedFunctionPrototypes
Xvoid AddNewBlock(Display *display, Window window, int row, int col,
X	int blockType, int counterSlide)
X#else
Xvoid AddNewBlock(display, window, row, col, blockType, counterSlide)
X	Display *display;
X	Window window;
X	int row;
X	int col;
X	int blockType;
X	int counterSlide;
X#endif
X{
X	struct aBlock *blockP;
X
X	if (row > MAX_ROW || row < 0) return;
X	if (col > MAX_COL || col < 0) return;
X
X	/* Pointer to the block we want */
X	blockP = &blocks[row][col];
X
X	/* Now set the block structure with new values */
X	blockP->blockType 		= blockType;
X	blockP->occupied 		= 1;
X	blockP->counterSlide 	= counterSlide;
X
X	/* Handle the special case for a random block */
X	if (blockType == RANDOM_BLK)
X	{
X		/* Setup the random block so it has a next frame and new type */
X		blockP->random 	  = True;
X		blockP->blockType = RED_BLK;
X		blockP->nextFrame = frame + 1;
X	}
X
X	/* Work out all the block geometry stuff */
X	CalculateBlockGeometry(row, col);
X	
X	/* Add the number of points that will be awarded for each block */
X	switch(blockType)
X	{
X		case BULLET_BLK:
X			blockP->hitPoints = 50;
X			break;
X
X		case RED_BLK:
X			blockP->hitPoints = 100;
X			break;
X
X		case GREEN_BLK:
X			blockP->hitPoints = 120;
X			break;
X
X		case BLUE_BLK:
X			blockP->hitPoints = 110;
X			break;
X
X		case TAN_BLK:
X			blockP->hitPoints = 130;
X			break;
X
X		case YELLOW_BLK:
X			blockP->hitPoints = 140;
X			break;
X
X		case PURPLE_BLK:
X			blockP->hitPoints = 150;
X			break;
X
X		case BOMB_BLK:
X			blockP->hitPoints = 50;
X			break;
X
X		case COUNTER_BLK:
X			blockP->hitPoints = 200;
X			break;
X
X		case EXTRABALL_BLK:
X			blockP->nextFrame = frame + EXTRABALL_DELAY;
X			blockP->hitPoints = 100;
X			break;
X
X		case HYPERSPACE_BLK:
X		case MGUN_BLK:
X		case WALLOFF_BLK:
X		case REVERSE_BLK:
X		case MULTIBALL_BLK:
X		case STICKY_BLK:
X        case PAD_SHRINK_BLK:
X		case PAD_EXPAND_BLK:
X			blockP->hitPoints = 100;
X			break;
X
X		case DEATH_BLK:
X			blockP->hitPoints = -1000;
X			blockP->nextFrame = frame + DEATH_DELAY2;
X			break;
X
X		default:
X			break;
X	}
X
X	/* Draw the blocks please */
X	DrawBlock(display, window, row, col, blockType);
X}
X
X#if NeedFunctionPrototypes
Xvoid SkipToNextLevel(Display *display, Window window)
X#else
Xvoid SkipToNextLevel(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X    struct aBlock *blockP;
X	int r, c;
X
X	/* This will kill all blocks that need to go before next level can
X	 * be reached. Used in debug mode and maybe in special bonus mode.
X	 */
X
X	for (r = 0; r < MAX_ROW; r++)
X		for (c = 0; c < MAX_COL; c++)
X		{
X			/* Pointer to the block we want */
X			blockP = &blocks[r][c];
X
X			if (blockP->occupied == True) 
X			{
X				switch (blockP->blockType)
X				{
X					case BONUSX2_BLK:
X					case BONUSX4_BLK:
X					case BONUS_BLK:
X					case BLACK_BLK:
X					case BULLET_BLK:
X					case BOMB_BLK:
X					case DEATH_BLK:
X					case REVERSE_BLK:
X					case HYPERSPACE_BLK:
X					case EXTRABALL_BLK:
X					case MGUN_BLK:
X					case WALLOFF_BLK:
X					case MULTIBALL_BLK:
X					case STICKY_BLK:
X        			case PAD_SHRINK_BLK:
X					case PAD_EXPAND_BLK:
X						break;
X
X					default:
X						DrawBlock(display, window, r, c, KILL_BLK);
X						break;
X				}
X			}
X		}
X}
X
X#if NeedFunctionPrototypes
Xvoid RedrawAllBlocks(Display *display, Window window)
X#else
Xvoid RedrawAllBlocks(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X    struct aBlock *blockP;
X	int r, c;
X
X	for (r = 0; r < MAX_ROW; r++)
X		for (c = 0; c < MAX_COL; c++)
X		{
X			/* Pointer to the block we want */
X			blockP = &blocks[r][c];
X
X			if (blockP->occupied == True)
X				DrawBlock(display, window, r, c, blockP->blockType);
X		}
X}
X
X#if NeedFunctionPrototypes
Xint StillActiveBlocks(void)
X#else
Xint StillActiveBlocks()
X#endif
X{
X    struct aBlock *blockP;
X	int r, c;
X
X	/* Check all blocks to see if they still are active */
X	for (r = 0; r < MAX_ROW; r++)
X		for (c = 0; c < MAX_COL; c++)
X		{
X			/* Pointer to the block we want */
X			blockP = &blocks[r][c];
X
X			if (blockP->occupied == True) 
X			{
X				switch (blockP->blockType)
X				{
X					/* These blocks don't count */
X					case BONUSX2_BLK:
X					case BONUSX4_BLK:
X					case BONUS_BLK:
X					case BLACK_BLK:
X					case BULLET_BLK:
X					case BOMB_BLK:
X					case DEATH_BLK:
X					case REVERSE_BLK:
X					case HYPERSPACE_BLK:
X					case EXTRABALL_BLK:
X					case MGUN_BLK:
X					case WALLOFF_BLK:
X					case MULTIBALL_BLK:
X					case STICKY_BLK:
X        			case PAD_SHRINK_BLK:
X					case PAD_EXPAND_BLK:
X						break;
X
X					default:
X						return True;
X				}
X			}
X		}
X	
X	/* Only all done when explosions are finished */
X	if (blocksExploding > 0)
X		return True;
X	else
X		return False;
X}
X
X#if NeedFunctionPrototypes
Xstatic void ClearBlock(int row, int col)
X#else
Xstatic void ClearBlock(row, col)
X	int row;
X	int col;
X#endif
X{
X    struct aBlock *blockP;
X
X	/* Pointer to the block we want */
X	blockP = &blocks[row][col];
X
X	/* Initialise everything in block */
X	blockP->occupied 			= False;
X	blockP->exploding 			= False;
X	blockP->x 					= 0;
X	blockP->y 					= 0;
X	blockP->width 				= 0;
X	blockP->height 				= 0;
X	blockP->hitPoints 			= 0;
X	blockP->blockType 			= NONE_BLK;
X	blockP->explodeStartFrame 	= 0;
X	blockP->explodeNextFrame 	= 0;
X	blockP->explodeSlide 		= 0;
X	blockP->counterSlide 		= 0;
X	blockP->bonusSlide 			= 0;
X	blockP->blockOffsetY 		= 0;
X	blockP->blockOffsetX 		= 0;
X	blockP->lastFrame 			= 0;
X	blockP->nextFrame 			= 0;
X	blockP->currentFrame 		= 0;
X	blockP->random 				= False;
X	blockP->ballHitIndex 		= 0;
X	blockP->balldx 				= 0;
X	blockP->balldy 				= 0;
X
X	/* Destroy the top region of the block */
X	if (blockP->regionTop != (Region) NULL)
X	{
X		XDestroyRegion(blockP->regionTop);
X		blockP->regionTop = (Region) NULL;
X	}
X
X	/* Destroy the bottom region of the block */
X	if (blockP->regionBottom != (Region) NULL)
X	{
X		XDestroyRegion(blockP->regionBottom);
X		blockP->regionBottom = (Region) NULL;
X	}
X
X	/* Destroy the left region of the block */
X	if (blockP->regionLeft != (Region) NULL)
X	{
X		XDestroyRegion(blockP->regionLeft);
X		blockP->regionLeft = (Region) NULL;
X	}
X
X	/* Destroy the right region of the block */
X	if (blockP->regionRight != (Region) NULL)
X	{
X		XDestroyRegion(blockP->regionRight);
X		blockP->regionRight = (Region) NULL;
X	}
X}
X
X
X#if NeedFunctionPrototypes
Xvoid ClearBlockArray(void)
X#else
Xvoid ClearBlockArray()
X#endif
X{
X	int r, c;
X
X	/* Scan through all block entries and erase their contents */
X	for (r = 0; r < MAX_ROW; r++)
X	{
X		for (c = 0; c < MAX_COL; c++)
X		{
X			/* Clear the block thanks */
X			ClearBlock(r, c);
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid SetupStage(Display *display, Window window)
X#else
Xvoid SetupStage(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	char levelPath[1024];
X	char *str;
X	char str2[1024];
X	static int bgrnd = 1;
X	u_long newLevel;
X
X	bgrnd++;
X	if (bgrnd == 12) bgrnd = 2;
X	DrawStageBackground(display, window, bgrnd);
X
X	ClearAllBalls();
X	currentPaddleSize   = PADDLE_HUGE;
X	ResetPaddleStart(display, window);
X	ResetBallStart(display, playWindow);
X
X	ClearBullets();
X	SetNumberBullets(NUMBER_OF_BULLETS_NEW_LEVEL);
X	ResetNumberBonus();
X
X	TurnSpecialsOff(display);		
X	SetReverseOff();
X	DisplayScore(display, scoreWindow, score);
X	DisplayLevelInfo(display, levelWindow, level);
X	DrawSpecials(display);
X
X    /* map the level number for the filename so that after the maximum
X	 * level is reached it will wrap around to 1 again but will not
X  	 * affect the level number
X   	 */
X   	newLevel = level % (MAX_NUM_LEVELS + 1);
X  	if (newLevel == 0) newLevel = 1;
X
X	/* Construct the level filename */
X	if ((str = getenv("XBOING_LEVELS_DIR")) != NULL)
X		sprintf(levelPath, "%s/level%ld.data", str, newLevel);
X	else
X		sprintf(levelPath, "%s/level%ld.data", LEVEL_INSTALL_DIR, newLevel);
X
X	if (ReadNextLevel(display, window, levelPath) == False)
X		ShutDown(display, 1, "Sorry, email: jck@citri.edu.au with bug.");
X	
X	/* Display level name for all to see */
X	sprintf(str2, "- %s -", GetLevelName());
X	SetCurrentMessage(display, messWindow, str2, True);
X
X	XFlush(display);
X}
END_OF_FILE
  if test 24327 -ne `wc -c <'blocks.c2'`; then
    echo shar: \"'blocks.c2'\" unpacked with wrong size!
  fi
  # end of 'blocks.c2'
fi
if test -f 'highscore.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'highscore.c'\"
else
  echo shar: Extracting \"'highscore.c'\" \(26283 characters\)
  sed "s/^X//" >'highscore.c' <<'END_OF_FILE'
X#include "copyright.h"
X
X/*
X *  Include file dependencies:
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <stddef.h>
X#include <ctype.h>
X#include <unistd.h>
X#include <sys/time.h>
X#include <sys/param.h>
X#include <sys/types.h>
X#include <netinet/in.h>
X#include <pwd.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#include <xpm.h>
X
X#include "error.h"
X#include "misc.h"
X#include "main.h"
X#include "audio.h"
X#include "special.h"
X#include "init.h"
X#include "inst.h"
X#include "stage.h"
X#include "blocks.h"
X#include "ball.h"
X#include "score.h"
X#include "paddle.h"
X#include "level.h"
X#include "mess.h"
X#include "intro.h"
X
X#include "bitmaps/highscores.xpm"
X
X#include "highscore.h"
X
X/*
X *  Internal macro definitions:
X */
X
X#define GAP				13
X#define NUM_HIGHSCORES	10
X
X#ifndef MAXPATHLEN
X#define MAXPATHLEN 1024
X#endif
X
X/*
X *  Internal type declarations:
X */
X
X#if NeedFunctionPrototypes
Xstatic void SetHighScoreWait(int newMode, int waitFrame);
Xstatic void InitialiseHighScores(void);
Xstatic void SortHighScores(void);
Xstatic char *GetHomeDir(void);
Xstatic void DeleteScore(int index);
Xstatic int LockUnlock(int cmd);
X#else
Xstatic int LockUnlock();
Xstatic void DeleteScore();
Xstatic char *GetHomeDir();
Xstatic void SetHighScoreWait();
Xstatic void InitialiseHighScores();
Xstatic void SortHighScores();
X#endif
X
X/*
X *  Internal variable declarations:
X */
X
Xstatic int nextFrame = 0;
Xstatic int endFrame = 0;
Xenum HighScoreStates HighScoreState;
Xstatic Pixmap titlePixmap, titlePixmapM;
Xstatic int waitingFrame, waitMode;
Xstatic int sparkley = 0;
Xstatic int sindex = 0;
Xstatic int si = 0;
Xstatic int scoreType = GLOBAL;
X
XhighScoreEntry highScores[NUM_HIGHSCORES];
X
X#if NeedFunctionPrototypes
Xvoid SetUpHighScore(Display *display, Window window, Colormap colormap)
X#else
Xvoid SetUpHighScore(display, window, colormap)
X	Display *display;
X	Window window;
X	Colormap colormap;
X#endif
X{
X	XpmAttributes   attributes;
X	int             XpmErrorStatus;
X
X	attributes.valuemask = XpmColormap;
X	attributes.colormap = colormap;
X
X	/* Load the highscore title pixmap */
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, highscores_xpm,
X		&titlePixmap, &titlePixmapM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseHighScore()");
X
X    /* Free the xpm pixmap attributes */
X	XpmFreeAttributes(&attributes);
X
X	/* Setup the high score table */
X	InitialiseHighScores();
X	ResetHighScore(GLOBAL);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoTitle(Display *display, Window window)
X#else
Xstatic void DoTitle(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	char string[80];
X
X	/* Clear */
X    DrawStageBackground(display, window, BACKGROUND_0);
X
X	/* Draw the highscore title */
X	RenderShape(display, window, titlePixmap, titlePixmapM,
X		59, 20, 377, 37, False);
X
X	/* Let the dudes know how to start the game */
X	strcpy(string, "Press <Space> to start the game");
X	DrawShadowCentredText(display, window, textFont,
X		string, PLAY_HEIGHT - 40, tann, PLAY_WIDTH);
X
X	/* Set the message window to have the other display toggle key */
X	if (scoreType == GLOBAL)
X		SetCurrentMessage(display, messWindow, 
X			"<H> - Personal Best", False);
X	else
X		SetCurrentMessage(display, messWindow, 
X			"<h> - Roll of Honour", False);
X
X	SetHighScoreWait(HIGHSCORE_SHOW, frame + 10);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoHighScores(Display *display, Window window)
X#else
Xstatic void DoHighScores(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int i, len, plen;
X	int xr = 30;
X	int ym = 75;
X	int xs = xr + 30;
X	int xl = xs + 80;
X	int xt = xl + 35;
X	int xg = xt + 55;
X	int xn = xg + 90;
X	int y = 180;
X	char string[80];
X	char string2[80];
X	char *p;
X
X	/* Read the high score table */
X	if (ReadHighScoreTable(GLOBAL) == False)
X		InitialiseHighScores();
X
X	/* Draw the boing master at top of the list */
X	strcpy(string, "Boing Master");
X	DrawShadowCentredText(display, window, textFont, 
X		string, ym, red, PLAY_WIDTH);
X	ym += textFont->ascent + GAP;
X
X	/* Render the boing master's name */
X	strcpy(string, highScores[0].name);
X	DrawShadowCentredText(display, window, titleFont, 
X		string, ym, yellow, PLAY_WIDTH);
X	ym += textFont->ascent + GAP * 2;
X
X	/* Read the high score table */
X	if (ReadHighScoreTable(scoreType) == False)
X		InitialiseHighScores();
X
X	/* Explain that this is the roll of honour */
X	if (scoreType == GLOBAL)
X		strcpy(string, "- The Roll of Honour -");
X	else
X		strcpy(string, "- Personal Best -");
X	DrawShadowCentredText(display, window, textFont, 
X		string, ym, green, PLAY_WIDTH);
X	ym += textFont->ascent + GAP;
X
X	/* Draw the titles for the highscore table */
X	strcpy(string, "#");
X	len = strlen(string);
X	DrawText(display, window, xr+2, y+2, textFont, black, string, len);
X	DrawText(display, window, xr, y, textFont, yellow, string, len);
X
X	strcpy(string, "Score");
X	len = strlen(string);
X	DrawText(display, window, xs+2, y+2, textFont, black, string, len);
X	DrawText(display, window, xs, y, textFont, yellow, string, len);
X
X	strcpy(string, "L");
X	len = strlen(string);
X	DrawText(display, window, xl+2, y+2, textFont, black, string, len);
X	DrawText(display, window, xl, y, textFont, yellow, string, len);
X
X	strcpy(string, "Time");
X	len = strlen(string);
X	DrawText(display, window, xt+2, y+2, textFont, black, string, len);
X	DrawText(display, window, xt, y, textFont, yellow, string, len);
X
X	strcpy(string, "Date");
X	len = strlen(string);
X	DrawText(display, window, xg+2, y+2, textFont, black, string, len);
X	DrawText(display, window, xg, y, textFont, yellow, string, len);
X
X	strcpy(string, "Player");
X	len = strlen(string);
X	DrawText(display, window, xn+2, y+2, textFont, black, string, len);
X	DrawText(display, window, xn, y, textFont, yellow, string, len);
X
X	y += textFont->ascent + GAP / 2;
X
X	/* Draw the line above the table */
X	DrawLine(display, window, 22, y+2, PLAY_WIDTH - 18, y+2, black, 3);
X	DrawLine(display, window, 20, y, PLAY_WIDTH - 20, y, white, 3);
X
X	y += textFont->ascent;
X
X	/* Draw the scores into the table */
X	for (i = 0; i < NUM_HIGHSCORES; i++)
X	{
X		if (ntohl(highScores[i].score) > (u_long) 0)
X		{
X			/* Draw the rank */
X			sprintf(string, "%d", i+1);
X			if (ntohl(highScores[i].score) != score)
X				DrawShadowText(display, window, textFont, string, xr, y, tann);
X			else
X				DrawShadowText(display, window, textFont, string, xr, y, green);
X
X			/* Draw the score */
X			sprintf(string, "%ld", ntohl(highScores[i].score));
X			if (highScores[i].score != score)
X				DrawShadowText(display, window, textFont, string, xs, y, red);
X			else
X				DrawShadowText(display, window, textFont, string, xs, y, green);
X
X			/* Write out the level reached */
X			sprintf(string, "%ld", ntohl(highScores[i].level));
X			DrawShadowText(display, window, textFont, string, xl, y, green);
X
X			/* Game duration in minutes and seconds */
X			sprintf(string, "%d'%d\"",
X				highScores[i].gameTime / 60, highScores[i].gameTime % 60);
X			if (ntohl(highScores[i].score) != score)
X				DrawShadowText(display, window, textFont, string, xt, y, tann);
X			else
X				DrawShadowText(display, window, textFont, string, xt, y, green);
X
X			/* Construct the date for the highscore entry */
X			strftime(string, 10, "%d %b %y", localtime(&highScores[i].time));
X			string[9] = '\0';	/* Just to be sure */
X			if (ntohl(highScores[i].score) != score)
X				DrawShadowText(display, window, textFont, string, xg, y, white);
X			else	
X				DrawShadowText(display, window, textFont, string, xg, y, green);
X
X			/* Name of the boing master */
X			strcpy(string, highScores[i].name);
X			plen = XTextWidth(textFont, string, len);
X
X			/* Only use the first name if too big for screen */
X			if ((plen + xn) > PLAY_WIDTH)
X			{
X				/* Find the first space and null terminate there */
X				p = strchr(string, ' ');
X				*p = '\0';
X				strcpy(string2, string);
X
X				/* Draw a much smaller version of your name */
X				if (ntohl(highScores[i].score) != score)
X					DrawShadowText(display, window, textFont, string2, xn, y, 
X						yellow);
X				else
X					DrawShadowText(display, window, textFont, string2, xn, y, 
X						green);
X			}
X			else
X			{
X				/* Write out users name */
X				if (ntohl(highScores[i].score) != score)
X					DrawShadowText(display, window, textFont, string, xn, y, 
X						yellow);
X				else
X					DrawShadowText(display, window, textFont, string, xn, y, 
X						green);
X			}
X
X		}
X		else
X		{
X			/* This bit is for when the table entry is blank */
X			sprintf(string, "%d", i+1);
X			DrawShadowText(display, window, textFont, string, xr, y, tann);
X
X			/* Draw dashes for blank entries */
X			strcpy(string, "--");
X			DrawShadowText(display, window, textFont, string, xs, y, red);
X			DrawShadowText(display, window, textFont, string, xl, y, green);
X			DrawShadowText(display, window, textFont, string, xt, y, tann);
X			DrawShadowText(display, window, textFont, string, xg, y, white);
X			DrawShadowText(display, window, textFont, string, xn, y, yellow);
X		}
X
X		y += textFont->ascent + GAP;
X	}
X
X	/* Draw the line above the table */
X	DrawLine(display, window, 22, y+2, PLAY_WIDTH - 18, y+2, black, 3);
X	DrawLine(display, window, 20, y, PLAY_WIDTH - 20, y, white, 3);
X
X	SetHighScoreWait(HIGHSCORE_SPARKLE, frame + 2);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoSparkle(Display *display, Window window)
X#else
Xstatic void DoSparkle(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	static Pixmap store;	/* backing store for the sparkle */
X	static int x = 6;		/* X position of the sparkle */
X
X	if (!store)
X	{
X		/* Create some backing store for the sparkle star */
X		store = XCreatePixmap(display, window, 20, 20,
X			DefaultDepth(display, XDefaultScreen(display)));
X	}
X
X	if (frame == endFrame)
X	{
X		/* Bug out of the sparkle and goto next sequence */
X		si = 0;
X		sindex = 0;
X		sparkley = 180 + textFont->ascent + 20;
X
X		/* End the sparkle and now set up for finish */
X		SetHighScoreWait(HIGHSCORE_FINISH, frame + 1000);
X		return;
X	}
X
X	if (sindex == 0)
X		XCopyArea(display, window, store, gc, x, sparkley, 20, 20, 0, 0);
X
X	if (frame == nextFrame)
X	{
X		/* Draw the sparkle frame */
X		RenderShape(display, window, stars[sindex], starsM[sindex],
X			x, sparkley, 20, 20, False);
X
X		sindex++;
X		nextFrame = frame + 15;
X
X		/* Last frame of sparkle so reset */
X		if (sindex == 11)
X		{
X			XCopyArea(display, store, window, gc, 0, 0, 20, 20, x, sparkley);
X
X			sindex = 0;
X			nextFrame = frame + 100;
X			sparkley += textFont->ascent + GAP;
X
X			si++;
X
X			if ((ntohl(highScores[si].score) <= (u_long) 0) || (si == 10))
X			{
X				si = 0;
X				sindex = 0;
X				sparkley = 180 + textFont->ascent + 20;
X			}
X		}
X	}
X}
X
X
X
X#if NeedFunctionPrototypes
Xstatic void SetHighScoreWait(int newMode, int waitFrame)
X#else
Xstatic void SetHighScoreWait(newMode, waitFrame)
X	int newMode;
X	int waitFrame;
X#endif
X{
X	waitingFrame = waitFrame;
X	waitMode = newMode;
X	HighScoreState = HIGHSCORE_WAIT;
X}
X
X#if NeedFunctionPrototypes
Xvoid DoHighScoreWait(void)
X#else
Xvoid DoHighScoreWait()
X#endif
X{
X	/* Wait for the end frame then change mode */
X	if (frame == waitingFrame)
X		HighScoreState = waitMode;
X}
X
X#if NeedFunctionPrototypes
Xstatic void DoFinish(Display *display, Window window)
X#else
Xstatic void DoFinish(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	mode = MODE_INTRO;
X	HighScoreState = HIGHSCORE_TITLE;
X	ResetIntroduction();
X
X	if (noSound == False)
X		playSoundFile("weeek", 100);
X
X	SetGameSpeed(FAST_SPEED);
X}
X
X#if NeedFunctionPrototypes
Xvoid HighScore(Display *display, Window window)
X#else
Xvoid HighScore(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	/* Switch on the highscore table state */
X	switch (HighScoreState)
X	{
X		case HIGHSCORE_TITLE:
X			DoTitle(display, window);
X			break;
X
X		case HIGHSCORE_SHOW:
X			DoHighScores(display, window);
X			break;
X
X		case HIGHSCORE_SPARKLE:
X			DoSparkle(display, window);
X			if ((frame % FLASH) == 0)
X				RandomDrawSpecials(display);
X			break;
X
X		case HIGHSCORE_FINISH:
X			DoFinish(display, window);
X			break;
X
X		case HIGHSCORE_WAIT:
X			DoHighScoreWait();
X			break;
X
X		default:
X			break;
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid CommandlineHighscorePrint(void)
X#else
Xvoid CommandlineHighscorePrint()
X#endif
X{
X	char string[11];
X	int i;
X
X	InitialiseHighScores();
X
X	/* Must have table initialised with scores */
X	if (ReadHighScoreTable(GLOBAL) == False)
X		InitialiseHighScores();
X
X	/* Print out a pretty title message for scores */
X	fprintf(stdout, "XBoing Roll of Honour\n\n");
X	fprintf(stdout, "Rank\tScore\t  Level\tTime\tDate       Name\n");
X	fprintf(stdout, 
X		"----------------------------------------------------------------\n");
X
X	/* Zoom through the highscore table from the top */
X	for (i = 0; i < NUM_HIGHSCORES; i++)
X	{
X		strftime(string, 10, "%d %b %y", localtime(&highScores[i].time));
X
X		if (ntohl(highScores[i].score) > 0)
X		{
X			/* Print out the actual record */
X			fprintf(stdout, "%d\t%ld\t  %ld\t%d'%d\"\t%s  %s\n", 
X				i + 1, ntohl(highScores[i].score), 
X				ntohl(highScores[i].level),
X				highScores[i].gameTime / 60, highScores[i].gameTime % 60, 
X				string, highScores[i].name);
X		}
X	}
X
X	/* Print a trailing line to make the table look good */
X	fprintf(stdout, 
X		"----------------------------------------------------------------\n");
X	fflush(stdout);
X
X	/* Now display the personal highscore table */
X
X	InitialiseHighScores();
X
X	/* Must have table initialised with scores */
X	if (ReadHighScoreTable(PERSONAL) == False)
X		InitialiseHighScores();
X
X	/* Print out a pretty title message for scores */
X	fprintf(stdout, "\nPersonal Best\n\n");
X	fprintf(stdout, "Rank\tScore\t  Level\tTime\tDate       Name\n");
X	fprintf(stdout, 
X		"----------------------------------------------------------------\n");
X
X	/* Zoom through the highscore table from the top */
X	for (i = 0; i < NUM_HIGHSCORES; i++)
X	{
X		strftime(string, 10, "%d %b %y", localtime(&highScores[i].time));
X
X		if (ntohl(highScores[i].score) > 0)
X		{
X			/* Print out the actual record */
X			fprintf(stdout, "%d\t%ld\t  %ld\t%d'%d\"\t%s  %s\n", 
X				i + 1, ntohl(highScores[i].score), 
X				ntohl(highScores[i].level),
X				highScores[i].gameTime / 60, highScores[i].gameTime % 60, 
X				string, highScores[i].name);
X		}
X	}
X
X	/* Print a trailing line to make the table look good */
X	fprintf(stdout, 
X		"----------------------------------------------------------------\n");
X	fflush(stdout);
X}
X
X#if NeedFunctionPrototypes
Xint GetHighScoreRanking(u_long score)
X#else
Xint GetHighScoreRanking(score)
X	u_long score;
X#endif
X{
X	int i;
X
X	/* Must have table initialised with scores */
X	if (ReadHighScoreTable(GLOBAL) == False)
X		InitialiseHighScores();
X
X	/* Zoom through the highscore table from the top */
X	for (i = 0; i < NUM_HIGHSCORES; i++)
X	{
X		/* Is my score better than theirs */
X		if (score >= ntohl(highScores[i].score))
X			return (i + 1);
X	}
X
X	/* Not even in highscore table yet! */
X	return -1;
X}
X
X#if NeedFunctionPrototypes
Xstatic void ShiftScoresDown(int index, u_long score, u_long level, 
X	time_t gameTime, char *name)
X#else
Xstatic void ShiftScoresDown(index, score, level, gameTime, name)
X	int index;
X	u_long score;
X	u_long level;
X	time_t gameTime;
X	char *name;
X#endif
X{
X	/* This function will shift all score below the index down
X	 * towards the end and kill off the last dude. Sorry mate.
X	 */
X	int i;
X
X	/* Move all the scores down one notch */
X	for (i = NUM_HIGHSCORES-1; i > index; i--)
X	{
X		/* Shift the scores down one notch */
X		highScores[i].score 	= highScores[i-1].score;
X		highScores[i].level 	= highScores[i-1].level;
X		highScores[i].time 		= highScores[i-1].time;
X		highScores[i].gameTime 	= highScores[i-1].gameTime;
X		strcpy(highScores[i].name, highScores[i-1].name);
X	}
X
X	/* Add our new high score to the high score table */
X	highScores[index].score 	= htonl(score);
X	highScores[index].level 	= htonl(level);
X	highScores[index].gameTime 	= gameTime;
X	highScores[index].time 		= time(NULL);
X	strcpy(highScores[index].name, name);
X}
X
X#if NeedFunctionPrototypes
Xchar *getUsersFullName(void)
X#else
Xchar *getUsersFullName()
X#endif
X{
X	struct passwd   *pass;
X	char *comma;
X    char *cp1, *cp2;
X    static char fullname[80];
X
X	/* Get user information from password file */
X	if (!(pass = getpwuid(getuid())))
X		return("Anonymous?");		/* Unknown user oops. */
X
X	/* find a comma indicating further info after name */
X	comma = index(pass->pw_gecos, ',');
X
X	/* NULL out the comma */
X	if (comma) *comma = '\0';
X
X    cp1 = pass->pw_gecos;
X    cp2 = fullname;
X
X	/* Search through the gecos field looking for an '&' which on very
X     * old UNIX systems is supposed to be the users user name with the
X     * first letter uppercased.
X	 */
X    while(*cp1)
X    {
X		/* Look for the '&' symbol */
X    	if(*cp1 != '&')
X        	*cp2++ = *cp1++;
X        else
X        {
X			/* A ha. Now copy the users name to be in place of '&' */
X            strcpy(cp2, pass->pw_name);
X			
X			/* Convert the first letter to uppercase. */
X            if(islower(*cp2)) 
X				*cp2 = toupper(*cp2);
X
X			/* Continue with the remaining string */
X            while(*cp2) cp2++;
X            	cp1++;
X        }
X    }
X
X	/* Return their name without any trailing stuff */
X	return(fullname);
X}
X
X#if NeedFunctionPrototypes
Xstatic void DeleteScore(int index)
X#else
Xstatic void DeleteScore(index)
X	int index;
X#endif
X{
X	/* Delete the given score and shift all others up to fill in the hole */
X	int i;
X
X	/* Move all the scores down one notch */
X	for (i = index; i < NUM_HIGHSCORES-1; i++)
X	{
X		/* Shift the scores up one notch */
X		highScores[i].score 	= highScores[i+1].score;
X		highScores[i].level 	= highScores[i+1].level;
X		highScores[i].time 		= highScores[i+1].time;
X		highScores[i].gameTime 	= highScores[i+1].gameTime;
X		strcpy(highScores[i].name, highScores[i+1].name);
X	}
X
X	highScores[i].score 	= htonl((u_long)0);
X	highScores[i].level 	= htonl((u_long)1);
X	highScores[i].gameTime 	= 0;
X	highScores[i].time 		= time(NULL);
X	strcpy(highScores[i].name, "To be announced!");
X}
X
X#if NeedFunctionPrototypes
Xint CheckAndAddScoreToHighScore(u_long score, u_long level, time_t gameTime,
X	int type)
X#else
Xint CheckAndAddScoreToHighScore(score, level, gameTime, type)
X	u_long score;
X	u_long level;
X	time_t gameTime;
X	int type;
X#endif
X{
X	int i;
X	int id = -1;
X	char name[80];
X
X	/* Lock the file for me only */
X	if (type == GLOBAL)
X		id = LockUnlock(F_LOCK);
X
X	/* Read in the lastest scores */
X	if (ReadHighScoreTable(type) == False)
X		InitialiseHighScores();
X
X	/* Speed up by obtaining users name */
X	strcpy(name, getUsersFullName());
X
X	if (type == GLOBAL)
X	{
X		/* Go through the highscore table */
X		for (i = 0; i < NUM_HIGHSCORES; i++)
X		{
X			if (strcmp(highScores[i].name, name) == 0)
X			{
X				/* Can the last score be added to the highscores */
X				if (score > ntohl(highScores[i].score))
X				{
X					/* Delete and move up all old scores */
X					DeleteScore(i);
X
X					break;
X				}
X				else
X				{
X					/* Don't add as score is smaller */
X					return False;
X				}
X			}
X		}	/* for */
X
X		/* Now add the new score into the table */
X		for (i = 0; i < NUM_HIGHSCORES; i++)
X		{
X			/* Can the last game be added to the highscores */
X			if (score > ntohl(highScores[i].score))
X			{
X				ShiftScoresDown(i, score, level, gameTime, name);
X
X				/* Add to the highscore by writing it out */
X				(void) WriteHighScoreTable(type);
X
X				/* Unlock the file now thanks */
X				if (id != -1) LockUnlock(F_ULOCK);
X
X				/* Yes - it was placed in the highscore */
X				return True;
X			}
X		}
X
X		/* Unlock the file now thanks */
X		if (id != -1) LockUnlock(F_ULOCK);
X
X		/* Not even a highscore - loser! */
X		return False;
X	}
X	else	/* Type == PERSONAL */
X	{
X		/* Go through the highscore table */
X		for (i = 0; i < NUM_HIGHSCORES; i++)
X		{
X			/* Can the last game be added to the highscores */
X			if (score > ntohl(highScores[i].score))
X			{
X				ShiftScoresDown(i, score, level, gameTime, name);
X
X				/* Add to the highscore by writing it out */
X				(void) WriteHighScoreTable(type);
X
X				/* Yes - it was placed in the highscore */
X				return True;
X			}
X		}
X
X		/* Not even a highscore - loser! */
X		return False;
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void SortHighScores(void)
X#else
Xstatic void SortHighScores()
X#endif
X{
X	int i, j;
X	highScoreEntry tempHighScore;
X
X	/* The old bubble sort strikes again :-) */
X	for (i = 0; i < NUM_HIGHSCORES - 1; ++i)
X	{
X		for (j = NUM_HIGHSCORES - 1; j > i; --j)
X		{
X			/* Who has the higher score */
X			if (highScores[j-1].score < highScores[j].score)
X			{
X				/* Swap the entries around - use memcpy in future */
X				tempHighScore.score 		= highScores[j-1].score;
X				tempHighScore.level 		= highScores[j-1].level;
X				tempHighScore.gameTime 		= highScores[j-1].gameTime;
X				strcpy(tempHighScore.name, highScores[j-1].name);
X
X				highScores[j-1].score 		= highScores[j].score;
X				highScores[j-1].level 		= highScores[j].level;
X				highScores[j-1].gameTime 	= highScores[j].gameTime;
X				strcpy(highScores[j-1].name, highScores[j].name);
X
X				highScores[j].score 		= tempHighScore.score;
X				highScores[j].level 		= tempHighScore.level;
X				highScores[j].gameTime 		= tempHighScore.gameTime;
X				strcpy(highScores[j].name, tempHighScore.name);
X			}
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void InitialiseHighScores(void)
X#else
Xstatic void InitialiseHighScores()
X#endif
X{
X	int i;
X
X	/* Loop down table clearing everything out */
X	for (i = 0; i < NUM_HIGHSCORES; i++)
X	{
X		/* Null out all entries */
X		highScores[i].score = htonl((u_long) 0);
X		highScores[i].level = htonl((u_long) 1);
X		highScores[i].gameTime = 0;
X		highScores[i].time = time(NULL);
X		strcpy(highScores[i].name, "To be announced!");
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic char *GetHomeDir(void)
X#else
Xstatic char *GetHomeDir()
X#endif
X{
X    int uid;
X    struct passwd *pw;
X    register char *ptr;
X	static char dest[MAXPATHLEN];
X
X    /* This function will return the home directory of the user
X     * by either using the HOME environment variable or constructing
X     * it through the USER environment variable.
X     */
X
X    if ((ptr = getenv("HOME")) != NULL)
X        (void) strcpy(dest, ptr);
X    else
X    {
X        /* HOME variable is not present so get USER var */
X        if ((ptr = getenv("USER")) != NULL)
X            pw = getpwnam(ptr);
X        else
X        {
X            /* Obtain user id etc. */
X            uid = getuid();
X            pw = getpwuid(uid);
X        }
X
X        if (pw)
X            (void) strcpy(dest, pw->pw_dir);
X        else
X            *dest = '\0';
X    }
X
X    /* This will be NULL on error or the actual path */
X    return dest;
X}
X
X#if NeedFunctionPrototypes
Xint ReadHighScoreTable(int type)
X#else
Xint ReadHighScoreTable(type)
X	int type;
X#endif
X{
X	/* Read the high score table into memory structure */
X	FILE *hsfp;
X	int i;
X	char filename[MAXPATHLEN];
X	char *str;
X
X	/* Are we going to use the global or personal highscore file */
X	if (type == GLOBAL)
X	{
X		/* Use the environment variable if it exists */
X		if ((str = getenv("XBOING_SCORE_FILE")) != NULL)
X			strcpy(filename, str);
X		else
X			strcpy(filename, HIGH_SCORE_FILE);
X	}
X	else
X		sprintf(filename, "%s/.xboing-scores", GetHomeDir());
X
X	/* Open the high score file */
X    if ((hsfp = fopen(filename, "r")) == NULL)
X	{
X		/* Cannot open the high score file */
X		ErrorMessage("Warning: Cannot open high score file for reading.");
X		return False;
X	}
X
X	/* Read all high score entries */
X	for (i = 0; i < NUM_HIGHSCORES; i++)
X	{
X		/* Read the highscore entry */
X    	if (fread(&highScores[i], sizeof(highScoreEntry), 1, hsfp) != 1)
X		{
X			if (fclose(hsfp) < 0)
X				ErrorMessage("Warning: Cannot close high score file.");
X			return False;
X		}
X	}
X
X	/* Close the high score file */
X	if (fclose(hsfp) < 0)
X		ErrorMessage("Warning: Cannot close high score file.");
X
X	return True;
X}
X
X
X#if NeedFunctionPrototypes
Xint WriteHighScoreTable(int type)
X#else
Xint WriteHighScoreTable(type)
X	int type;
X#endif
X{
X	/* write the high score table to the high score file */
X	FILE *hsfp;
X	int i;
X	char filename[MAXPATHLEN];
X	char *str;
X
X	/* Make sure the table is sorted */
X	SortHighScores();
X
X	/* Are we going to use the global or personal highscore file */
X	if (type == GLOBAL)
X	{
X		/* Use the environment variable if it exists */
X		if ((str = getenv("XBOING_SCORE_FILE")) != NULL)
X			strcpy(filename, str);
X		else
X			strcpy(filename, HIGH_SCORE_FILE);
X	}	
X	else
X		sprintf(filename, "%s/.xboing-scores", GetHomeDir());
X
X	/* Open the high score file */
X    if ((hsfp = fopen(filename, "w+")) == NULL)
X	{
X		/* Cannot open the high score file */
X		ErrorMessage("Warning: Cannot open high score file for writing.");
X		return False;
X	}
X
X	/* Write out all high score entries */
X	for (i = 0; i < NUM_HIGHSCORES; i++)
X	{
X		/* Write the highscore entry */
X    	if (fwrite(&highScores[i], sizeof(highScoreEntry), 1, hsfp) != 1)
X		{
X			if (fclose(hsfp) < 0)
X				ErrorMessage("Warning: Cannot close high score file.");
X			return False;
X		}
X	}
X	
X	/* Make sure that the permissions on the file are rw for everyone */
X	fchmod(fileno(hsfp), 0666);
X	
X	/* Close the high score file */
X	if (fclose(hsfp) < 0)
X		ErrorMessage("Warning: Cannot close high score file.");
X
X	return True;
X}
X
X#if NeedFunctionPrototypes
Xvoid RedrawHighScore(Display *display, Window window)
X#else
Xvoid RedrawHighScore(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	/* Draw the title screen for highscore table */
X	DoTitle(display, window);
X}
X
X#if NeedFunctionPrototypes
Xvoid FreeHighScore(Display *display)
X#else
Xvoid FreeHighScore(display)
X	Display *display;
X#endif
X{
X	/* Free up those memory leaks thanks */
X	if (titlePixmap) 	XFreePixmap(display, titlePixmap);
X	if (titlePixmapM) 	XFreePixmap(display, titlePixmapM);
X}
X
X#if NeedFunctionPrototypes
Xvoid ResetHighScore(int type)
X#else
Xvoid ResetHighScore(type)
X	int type;
X#endif
X{
X	HighScoreState = HIGHSCORE_TITLE;
X	nextFrame = frame + 100;
X	endFrame = frame + 4000;
X
X	/* Reset the sparkles for the names */
X	sparkley = 180 + textFont->ascent + 20;
X	sindex = 0;
X	si = 0;
X	scoreType = type;
X}
X
X#if NeedFunctionPrototypes
Xstatic int LockUnlock(int cmd)
X#else
Xstatic int LockUnlock(cmd)
X	int cmd;
X#endif
X{
X	int inter;
X	char filename[1024];
X	char *str;
X
X	/* Use the environment variable if it exists */
X	if ((str = getenv("XBOING_SCORE_FILE")) != NULL)
X		strcpy(filename, str);
X	else
X		strcpy(filename, HIGH_SCORE_FILE);
X
X	/* Open the highscore file for both read & write */
X	inter = open(filename, O_RDWR);
X
X	/* Ok - if successful then lock or unlock the file */
X	if (inter != -1) lockf(inter, cmd, sizeof(highScores));
X
X	/* Return success */
X	return inter;
X}
END_OF_FILE
  if test 26283 -ne `wc -c <'highscore.c'`; then
    echo shar: \"'highscore.c'\" unpacked with wrong size!
  fi
  # end of 'highscore.c'
fi
if test -f 'score.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'score.h'\"
else
  echo shar: Extracting \"'score.h'\" \(713 characters\)
  sed "s/^X//" >'score.h' <<'END_OF_FILE'
X#ifndef _SCORE_H_
X#define _SCORE_H_
X
X#include "copyright.h"
X
X/*
X *  Dependencies on other include files:
X */
X
X#include <X11/Xlib.h>
X
X/*
X *  Constants and macros:
X */
X
X/*
X *  Type declarations:
X */
X
X/*
X *  Function prototypes:
X */
X
X#if NeedFunctionPrototypes
Xvoid InitialiseScoreDigits(Display *display, Window window, Colormap colormap);
Xvoid FreeScoreDigits(Display *display);
Xvoid DisplayScore(Display *display, Window window, u_long score);
Xvoid DrawOutNumber(Display *display, Window window, u_long score, int x, int y);
Xvoid AddToScore(u_long inc);
X#else
Xvoid AddToScore();
Xvoid InitialiseScoreDigits();
Xvoid FreeScoreDigits();
Xvoid DisplayScore();
Xvoid DrawOutNumber();
X#endif
X
Xextern u_long score;
X
X#endif
END_OF_FILE
  if test 713 -ne `wc -c <'score.h'`; then
    echo shar: \"'score.h'\" unpacked with wrong size!
  fi
  # end of 'score.h'
fi
echo shar: End of archive 8 \(of 26\).
cp /dev/null ark8isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 26 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo "merging split files..."
    cat blocks.c[12] > blocks.c
    rm blocks.c[12]
    echo "blocks.c done"
    cat bitmaps/earth.xpm.Z.u.[ab] > bitmaps/earth.xpm.Z.uue
    rm bitmaps/earth.xpm.Z.u.[ab]
    echo "bitmaps/earth.xpm.Z.uue done"
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
