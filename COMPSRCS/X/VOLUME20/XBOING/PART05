Newsgroups: comp.sources.x
From: jck@kimba.catt.citri.edu.au (Justin Kibell)
Subject: v20i112:  xboing - a simple blockout type game, Part05/26
Message-ID: <1993Sep3.123109.6887@sparky.sterling.com>
X-Md4-Signature: 89ba0f554fa382ad2330f921865c33b1
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Fri, 3 Sep 1993 12:31:09 GMT
Approved: chris@sterling.com

Submitted-by: jck@kimba.catt.citri.edu.au (Justin Kibell)
Posting-number: Volume 20, Issue 112
Archive-name: xboing/part05
Environment: X11, xpm, color

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  bitmaps/earth.xpm.Z.u.b blocks.c1
# Wrapped by chris@sparky on Fri Sep  3 07:14:42 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 5 (of 26)."'
if test -f 'bitmaps/earth.xpm.Z.u.b' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'bitmaps/earth.xpm.Z.u.b'\"
else
  echo shar: Extracting \"'bitmaps/earth.xpm.Z.u.b'\" \(20450 characters\)
  sed "s/^X//" >'bitmaps/earth.xpm.Z.u.b' <<'END_OF_FILE'
XMT3IDBK%W%^F+0*7T\FEM:&Z.,*\I7&AC=+;R%(FY,5=BH;Q,$H4&>Y5AP;0\
XM'X9=?*BD#W:+T_$1PJ\()),R4 V"RZD&S'#PBBPT*T@]W1Z=P9X(MZ8W).<5
XM!Z,/XR)/9B;OON=H&AY-^&07*KRS($!"FPA%@O QC0Q;[QV/$NSHSP8+$]<H
XMO9B+5HR#7=?$Z$6AO& ^6W*=19)TE#FR)M8N@P)BM:HQP(G3H=9&ZG$6&0+B
XMQ[Z$8S)Q2"2'#&+:0'T5$"PL#HQ]$]Q!+GC18FUQ*2@MUR'\E@O)3G/)+!KA
XMG&XBZ,21R)XP9R"4D_EU]*HGTI721MJS*X:,.SX1FU"4X\*8E" O0'D?"OQ 
XM>41* H,#"M?NI3BLXS<V,224FD_5EQ3G8=?,DD>D), HPL@]T=<RK('>R$^R
XM@-1@RI6QW_A26U+5<6A>749G T)HV;%2P0D$F(RE'D01OK';#@8$WW&ZU-9 
XML<0=Z:G[#BHDK!.3.O<E*E!'B! 83"_N0'5AR^ <4LX. @DS4DHQ=R#/U+Q8
XM]1"8**1)@^(CTW!F:AO<,!28"[\K9E='.Z*T,KUL/;PX&9&M0QWA9(C8(7=&
XM'BH<EP4=4D8$_:7-,$OQ.$>/%#/4X6LH<[@Q(?GI/,.&IT7&DXK,_=&*@_&T
XM@(Y!!P\2#S]/KB%8ZJB0N[8S*D;/4QIDYI&H$!U&.U,Z:9SRQXQ"5OFFN6'<
XM+CN&\<P/8AIC/A7%JBQJ3[@++C!"D)TEP42WK#AAA%!3WC-#3W!._Z+.TZTT
XM(&AR*"36)/H!@ZF2=$O (:J;(-".$/6/'=)-.NRH_R)K#LV<A)W#&5CZ(I>M
XMUAR!%*0H1Z6BUH3A4V9(.VPSTD;97V_E=&2O&I69'_%5UTZSUE)(##7)U'=1
XM@0X3YJ1B#H(A:7>3.';. N>,00(,1-#FQ^E+\:(5&:H-0Z\NB, .H^9RH%>%
XM!*E;&E"(2W E^?$.BGB8H*Q]:4H+CKY".>E#X,P<$[8<7(WVY?Q#IY-(JJ]-
XM\(Q)LLI_AF@C@. 1ZN(MO2"(J[4XI*I!IV#F$ 7BR[0INKL"W\%O+_5TBI[H
XMEQ">+$Z*TX'!Q 8%O6BA#ER58\PA!UDFGK 8ZA*4%B2..(WC1\(BI-"TN%K=
XM3RZ"K*J"#[GFQ:"^@@JABT!I)Q\8C4^FA3"(B,*@$R2@+QZF1APM%>@S.VIH
XM.-\B.2"(5=-FR<B!:Y8!M,:&6[4XI%5B<@'62"II^GY<&*R+FH9"PV3+65KI
XM0LE4. L/E-0#");R>U1<O;0/OYWGY@OA^6>9W'WR/N$> 2SIY"O$W?CJX&'X
XM+1 )&*V"A;7PCY1$BQ@1*;U^IA=(TEUB(:IU*/Q9&DR'6-' #9"!S(:6PL1%
XM.0 >.A&,S<4RRNGXH)JM;\ADL\*L0%+M/?8TE%$^JS9)IS$6EFIH9;*.^26Y
XM]HA47*@,''NG++*&Z;4PDW8T$[KYR&OHUC&(P'<9.NNA#- _Q&@RU6-]VF#)
XM$  WW+^-2(R*"$J(T5# GEX,)!AD(:&1K;?J $:T,)V9HX-Y@T^&'H&BR=U8
XM(CDI4),FD('Q)$F7:'<\,(*  D24WU;M$,J6O$FFZ@QEX2&[T)UA.[0KP@B:
XM#EY"ZE N6;#F8S#VFP?QJ0A6)\:85PG@SG'UFV(RYXXL-1KE!<)F>0'<08RF
XMTJ)&4CLA&?@ AZ!;<-R4&CT&?AP3%7,+]23H9&!VYK)Z.]&X0G:MY1?IU$S(
XM6J@34U&U E$KSL)%*=!(.$I,G@FDAA6QO_/ D(/9S%AKO35"WT.S#94#X2*\
XMB<X_]"GLPDT%R6@D@B;=)UMUJC@HQ<D,262L&;OXO^A/VR,4QG"P?@;@L5%A
XM+&<0"E =9=NRP56\VH?E(]P^LP^)0@<PLU.ZR:)@P XH+0;&0_#(O!D\6OW4
XM)B!V@+ZB@O# ,P%^]---]WYEQDP0"<]KRL%\<.3$1]$<]\451VVDXH'R:Y,-
XMQ4Y^,I'[V._0;]2-B-.%8R1J>8CD7\>(94)ZZ4T9,2@L7A7IB?SEFY7%6;4P
XMM:8(B:_?'3J3"U3%6EMFD-9><(^KE_HG83&\BXIH!Q-V3X.R@S+B)*/?2_^(
XMX^0IH=$DA:"T!JF7?!RP$D97OX]A4GI0'&%;D<KH0=B'>X1 P_C$&()W)(.1
XM#4=H;DC_EX]O#6'(\)S@-5Y:=".F@@UO2^0T2"&-7?QVN1&!7C.*[(/^2P%Y
XM+N=!HU"RE(HLP)A P&%8?9"==)RK&R &TD5UB'XL\!H7"T_ITT^GK-#R4OWT
XM37((;Z<H:-FHJGFB6^Z(1@=TGM'3W#WEVE=HH-@%,D@IO;!E:# G+\$.[!_-
XM8G0Z@#)+*;3,W<?\R_/U^8H5"R#'5 V+E^*3&HCU$N"3"A!T5XL%__=),&Q^
XMAM1L51).TBK2Q09GX(]XWG8(X8E;Z?%+,>HKFFI=(40)#@M*A0$#!R>IL/$ 
XM:EQ2X1@M(_!&@4 G.ATV2Q4S72SO&VO4*GJF?)FX$-Z-1L,%3G>#(=+GN)TH
XM2O(H):AT2J]%!Y &VZ8MPUZ.(LS0E_]KF4 %; [JI20_[1N*4JFC?/&$23,P
XMK/01T0>)R4:D81(=ZGQ8$7AV=2^#Y"UGX /G>4LH?-2>Q4)<ETV+TR&)HYA(
XM%N ).ZTAG*R.ZRG-''8Y9,(K^I?(ST),<9 )X9AN[%BCK"QHPDER0^DC=4F$
XM%3Z+5(IW9SG2CZ+ "#^2;>Q_Q XI95%M:K8Z8Z')P0QI]<<.1^>*Q<F9S,;P
XM9=8HB3HNTBH'1%&U6CQ9-Q93!J!KX#8%8Q(#(JK]T9H8FKD43  CRA$BQ8+:
XM0U46>ZIHH<T"QT 0"9W$RH@5)2K%5$"CSH(#6MM1;,8]"SA^$Z3S*DI%2U(\
XM2Z41)[K3G*($!8%8F(C\-3 AW8UW9WAAD>&NFI7UM.H<V[!GU>7B.2*'Y&RE
XM/E]7'Z2^5>,'$\2BV@Y)2&Y1P S@'B&A;D0P@("E2:FFL8,E!LQ+;T'%:()-
XM(_,3!:6GZ>6@8QF>2I"8:%(Q>Z\U1.?A;Q,0L]/<#=4LGC>D@H>+CM"0? 7A
XMYLZ4 2"SYS[A$#%U,)MJ3$=7RH5IRB4,?:;-F+ZI#P8875%MJ48#B_.\LU+,
XM*[5;$K2H'&DP&F>K[' II)Y(:RQ.HHQ"S] N+*)\O"(KZQ^]7DJEUT!KRMT\
XM-&UA6XN^Q)U3?6H>6M^M%+A(R 7WA0(!RH#6:(JY+!-"RZZ1U'[2WL5PTP":
XM29R$P8:Y 9=K@&H[+4,02AL)M,N8!RD-ZV"B$%!X/XTGG C_"(>L,T;GR(&P
XM<MY$70C04;G"#[2W0#@-3F069,'$X@C!,%.SA%:E/QI/@"RWQ85IWR%@M _6
XMW]Z=9HY5H.:3-?+N$-TT;U"A&90\XA9F&!,?W-$T%LINJXGD!,%GS&!V&*2N
XM#^M(PHK(U<,.E\>(.$3^$3Y6"@G$4/N!H+43M4$28/8--X3T 8>J.F0\N3\D
XM5B9IF[^1:6X"RC2M,#@(&683"K^D'%T%N824; =I*#A!\,]QB#?EM&$J8<:8
XM34(;NLG9'\<J#-BN^O&-330?K(9;::2(PB-(/3RM:6Q"+XP8C0L'4O::V57\
XM)B)K)M3M15)"M2,0R<U<#B%6=%+C9%A")9DH59MNM8(1D(=+P_>QP5":&1XR
XM'Q88H)L?W^/3FV$:D5X6/[ ?T< A2]  W[+*@17MG;P(U:8<2;2IQ(G^FBQL
XM5,2GH0U%T#/(_L;<9+E0-UY=K1;0$100S9:4Z(G24'M14:,'4N!,);$9F5K8
XMGVPH1T*P8KT%&.3M0Y945(U!J2+2T%OL;F2^X7F8;E02&DH=*7O4DTH5O4!6
XM$'A5>0?>V&8#16-J*6]0_Y"06)?3&[AHZ%596@*A:W07Y!AKW?:@3G'.TGM2
XM,?])^SE[U&S"JE8,44>B"T5$.0APA5@/Y\:>*,!YA$*8J$6&R'QB'./1L?4T
XM0',6?SLAC5IS-8EP8$]H,0@-)!&<'D*MF)%S,*F4UQH/N[HB(LZ124AB*.)5
XM$&:J,55PATP59A)*E3F0O'"J\M%;F.AL)L+,T'X>$C!W$[I;B?<#Z7&8>'R-
XM= X-.+.=DAMP@+6[$>L(A[8KH\^IXDUDPU*(07ADEVJ2SR"[$/@MS^/38@$I
XM.]@A#8A"794@Z=!,779"(3!#=(FE6+?!N('PN760JS(-/(J#1H:BH[)*T)#X
XM<3P*>#M5&2U)'CHH=:*N39&6'E,JP],"HL!'L$\$7<H9-0K<3]\4'ME"&6U8
XM)$HG"A&D A<K=5IJ@D30?YY!>KSB$R"1]UCM$*\TA_@CU L7AU%L';D.%4A]
XM=394D0M7J 3-[^EAY.%T&$RAP<9PG7LJ&VEI:?,L(JPB<QX;QX8$#(A>X3HH
XM6;80)CG71^!$YIG!^33LZM*44P?<Z:$T+_GG:Q^4TE(S@$ LR&'"F ":882,
XMH.QE]P\8QR(HRW,]"V)!IH8L*:0J3R,E]5CB:DE10@X&#:^MQ0;MGZ6. R"5
XM-I!>C8U)A7JK0D.?"9VP-T)B5)3?HRNKK I(/2(,6$=;OHJ*WBCMV9-@)1V-
XM->\3,U#HAZR$ZTFZ.62D-;8*;5/G:J 44GI)M:DR'MLN> ?Q DU!G[ ^P'^,
XM(<XBE*]*W]9L28K)*%$9:WH(]:+KB= CHP1\ O"D**,-(ZR1 1.#I4 GV?.0
XM5WX3\JXKF>Y$8=)A^!WP)C*::QFA0_,3840DQ6Y:1VNH=S&:C:;#3#)EI7=T
XM&[R)JJ?_2_ .V21C3#$J<7 Q@)KSY574+IFAK$U(4<>IY0-F ILUEP%A "6,
XM](H,[#+A#\-#%3%)$XD!.Y@DOB_K"='NB=5=03%6=E@F,BHACG!NC$9&VX&"
XM>6)C9S(^1]9P5%*_L?E-XG8\WA!+)UR((Z%Z9+)"38D["*G2)?FS9;*3H,7\
XM',0.QC(U4S<$VO-N" !2/+><C\ZEI89R$P.X**!F1>VFM];R@F$"18-#J""X
XM/YA_ZT8C21SL:O8NLPO!0"9QT2 KB+.&<+6O&4((5KY9XZV]UA&BOI6?V'*X
XMCYZ0& D6P!N5J*3"HVD.)S</,DK5V(?,>-(Y33I]6^MMF5:]00.!1[J_,&E\
XMFH!:TJ)LD.5!,N3#E*8P5*PY"$W0J*&4$^-)]9A^4NT+2Q XS5\M@8J<+'&2
XMXHH].A6-AB_SP6F"*LGX8Y"#@*AHH4D%(]%#\9>L5NP?YYHJ3;<'NV8_"K[%
XM_8IB_Z_\Y&7CJ@"(DSQ&\=XB7+RCGZK!TBH$:K(Z69UL,RAJ8#VN&W)$.<'T
XM-, .J8=:C/%B0UI9LN<-3@81905T9N, R,EJY5<>)S6L=E.['<4"P_"8,%QD
XM3> *6\D_FG/J&()&"P'"5M%GIA:WBGWH4G,MZ2R4;[Y&?SRF!%;K/)9:4-NT
XM&NT<,PBPQH1M^6?S[+'F<O25-\WVHF-C,I=S<S@H4W&7BJH]XM=+WM#O8O.T
XM:-(4>X;K2[5HPJ%N,7O:Z\Q$3Y0TGN N_"<!'<!<+"F>>DGV 1G"P4!9X'B(
XM$7JGBX2$V\+%/^%$] X2G<YD2,23#T4"\552$>C94O<=FT<!8G/H.@2JL1')
XMK&I[QA<UF0Y)&;IP48SY,GLMSTD]&.E)XLIZ@V2 !ST^>8L.S<F5R6<RPU#D
XM$20F% :# V-$R_IUPJGA//:2GR1&HUL'F*=738]26".!CJ"40V$T_A"M8918
XM)0@M^%;Q@7O"]$(OTU$,0;X;12[$5^ED>I$EM71-.K0F=18C%50.Z[+'48>M
XM070M,<9K6)_%0Y8$S'D27-5L!I&@J7]+<Z>AJ7,0G4(:2*62*Z[ [;H\Z7U2
XM4H /!U.^#A1H3B&;J'$X.&@\1 X9ISP.]RFL(FUB,.T&YKM7J PDE^ESY9U>
XM*]IGBH5,*HGAH_E4ZN)I=3(?"(_P(;$,[(&;RD&(0V@S/K)W5.5FC":"*4?5
XMNWY.!@6ZB']45AA#.TL1!%D<XRV0)\'+[_%1@'^E14(WP\+&S  6W*I;NE>H
XM9T2$^ 1QGWC"Y]%YL(4455@Z(M!1&05+0[/;#)2F*4U!<H4"J8YT=RIBY:GF
XM&>:JFRP4!$B!CG<^R/1!'RZ:9)@-2\/C]C/@RH  $= *R:-$TIN(R(.F&;;D
XMYWI=^[E8V#]K$ZDH$Y<I.X!N[S,09YP$,-CFN?V( E>@^);;ZP+43" S\%R5
XM(' //E-@1DDDN0'MD,6(58M8_KP8DH!.8YIM'(VR8QL(00<#QJU.S-IF<,6:
XM&APW'H_>Z4COU;!'"(*E\U)CV88I1M90O5'^>& <1P*#TXQ]@TMU=9.4I&40
XM;QY<UQ6;V68,=49<?*01J(Y:U)60PU(BTLJM.#6,S80@Q2^Z2<!I-UB /3SP
XMBH0-W*,Q2;C(\/@]\4&<.@\.["MTE76-\+J#F]M16(,17*O<FH()593$&C'P
XM5.D0.8R"1N\A6Z+'" ?F.2X<QXPW!98UZ.+]$)8<:I)V2Q5O203'9^2E2M/P
XM#'9>74+^Z@N-/@:$BX5)MPR8K:F:0XUEF3&9RTVD3[2QVUB6AG3.@&FK7'=1
XM@^A;THS 5(>C(/.K,6ZH,=2Q9E..:2-A+XLH+?P50YV90@NN5G)C5[,GH:YN
XM(9(6S(- 1_0#HUE7@FI0+Z,;J"/&$9<T66A=,%55C/YR))78Y(8-JA'Z0HO^
XMR3!_[J0"Q_ BSU,VFGB2<C*'6D&LAQ(6S\F$/1*L[WJ039C"* 1%;#>%W;B(
XM. "PQY1A#5OKZ_)CP["Z1W^S/5GXZ+J00]E'2.:E%T S\PVAAO+"H B?F"8<
XM$O:%%I*;!/>1%\*5?)RN.J)#%\[E9Y!IE7-"J)AB459RFB=0AC(VB[6)Q/S=
XMQR9OS2'F&'GFN?G0D%\E/JPO" =Z"J,'+9N696F01XA-N8I8'0*56!(697YX
XM(G(A;Y/2!. P1M=\M>J14_N5!53(@PTR^XI/N2TD' P2(QYW0N]T**M%.#KU
XM((0D  HV!\9BFI7E"I[V1"@BLS0WR";(WQ*[X*4]FH07 L3_6VBC>&9F@V/N
XM(8,;%5>-B]9#4+14^7PP6RPL(@$RP4$)=*JO%%08O9XUUIRB!CG6# +?4(U\
XM4^AJ.)AGXR^+YE>*Q:3Z0?.2QDF@Q %B$^(8:5A88!ZCC@?WP0+C_-$@26BH
XM.3PL68_#8%,L^@"#(B$$&KY5/RG$%/$%I^*42#LQQN0I9ZFEV82,#":6*TQY
XM*]0JP(M)A@@.E( DW62\,R6Q;0+0*7ZV'R26L(%T%VP(_I6/#UE%R6 JX_*-
XM: Z<2DOTY:JUA?E',"JX336FV[_C["M6=4)1H D" CVLRCZ\0Y\6@H-" UHV
XM(I9"WJK^1G0VL(1<P9*\I"!"K+FTU))!A&G54@VFS;9SAQ#)1PX"_E$(H;^\
XM#@8AFU-P1!GI[=*:+8ZA>12+54T$;(7UQF*X^^O@45(3GPC**49+E9E_BUJ5
XM7ARB[E%8J\Q3-EN-G./]ZQ8IA W%PE](A@!7J$.0$K=<SX]FB"X&SR3%.#GX
XML\!]%JM[!DUC[/7@VN6H9(QA'C*&B&M+ 0'Z"HD9&Q815I*4CC%)?@<WRY4<
XMR>)O -9.IIM@?;=VF9VRKCZ:F8C: KFD!S$NF?=D=#*.:Y;6J/^PC[FQPSUL
XM4I\DBI*'J* T!2%?\'0,,F:NJ;ERK2+OR-@.E$L,$F9.G$$$#@M$Y(K $>R<
XM#*)%IM;=R8MEKD8RV!,ERT9LEJZF([WLEQE,)#PML':5]@C>7J0-GSCE0$6L
XM9J4$A"-![3JV0FE!2GX(/ 89C0J<7JWCD$!'8<SEG? 2R5?[W<'JHW"@3="2
XM;7.JT0_D1F_A#P)G0D@$'?X?F4*D8+,%#J%[K,F8/\EYFL#23#!1J;.V\@Q2
XMH&([U]1=D4"$FQ$@JXF-SC)K?\^ &>.C&;J05'7=,.(B,)PM;6N$/NLY-?.H
XM+! U"%K,HM[P=P&JJ+[RE=82(@@GC"<+)>.)^V7\3QVB:M.00C'44MN7G8BD
XM1E,00@WOS77#P:"/Y9V^.E0)!R\6!PO)\I#30 %:.F,X9R'-#U2.@9#^&ZF$
XM;.05."<79"-%Z)?Y++,9U7@M>K9<#;8A!B2=Z718) I]U)Y;AS?P:0NU'<D.
XM"7(?^+;-Q$OU&^DU=!A-4'84MB:OF]=&H5#W[(NQ-)5&(4FH@Y,VGQ&\(T-(
XM45UE 3/[1'RA3Z)(A1I>^PHGT;W"1++,+RIY@-W\JPHAWY"O$<O)5,5X.()9
XM(I0DA1YEG)(ABY+)6),IRI9AWC*:F*&M:-HB0KW@</XE<)K<70'C518KL[A0
XM;BNWEMNF R;VB1I,:4AF;0<0UXBNA8Y.&Z*ENI&IBN872XU4BOI'K,"ZY?Z1
XM]"XWE=K?SN/E&2=V#1W!'9H6LEA^*'%$I)#D0TJ]C'Q!#QRHW1VC:A5NX5W8
XM1CJD4XKJ'4V(#F*[DA52$$U?[*WAQ.SLOTCJ%'\&?YPLWD;51#I/QY"I2)YX
XM;X<$LBRS4H C^6 W1>5-/OZSGYG/S*<"YC?0,U*D2#@,,;X!PJ?H)$7#4[NM
XM3RZ'?]76HIN"O8D1(W#I?LX+XP8ZKDC!5_6:R6C0W:0(G#"FQB*"SJ*;.^>-
XM(!=RFIWOQ(@R&M7BB)<%U[0"]#&'AP?MIL96+(2P2FP=CATND/=B1,$B63)<
XM00&UXHN2!W6R7$CL?(8^6O$6*!ABRO,"Z6)'$O[])]-YF:QOGI!+RHBB4!XT
XM<W$B#91#J0VRLZ&S[)D #SUD^BJE1!W"=*B)P. (GY(7VL_$'_S%0=%Y^AL2
XM#')UHH@_V#5(E8<PX)#==I: U\O/F*4+7/@PZ5[J-)M(M9#D63=)>^+UA'KD
XM$$H;)]SLI@=CP,K@$1&61A=UZTL8KOHFMO(V\?8]H+2),]#H'ELO!@%4* Q>
XMF>1S#,2;)&L#F$?#.YU$'T@?G#'H+=_T0 9!H%HBZ-@+E,9:Y2.Q-7&(VO=T
XM/WY!S!BO1)M$AJ?<<; ,4!0A)@#3HG,/*; :XZ:-RW!33B_80N^GNO3 R$_*
XM5<]WWILM O=VMOK&)1(0=/,59LJIU8FK5 7=8>C"<!5>[POWY&K% ;+(/-2J
XM1AP[' T,R$ZGSZ)<P7IT*T 0PY/0B,G-7J;\JXD]""T*;UB.#HSJ;7N*/;%]
XM*1ZZ3X"NAM(E8G10:!L )U)%888Q8@ AA@. HY!YU2Z&-C/<F2]2TD@:M!M]
XM2S<IFK<9Q X/-S1!".BR+=D$:CA:)MGV_P&P8+H)7@80/PC=Q!MT=O* PK.(
XMM_"L-\<'R;H$>]'-J*JM=JMJ? Y/EQ/UL%!4!,9^/XF+_R]B7_2A@=*_I-_6
XM[?P/"B\<5=7HMK<N8'/@H#XGLJO;!GH!0K-W:MUD)E1D+%,)F^YP0C8&$X/E
XMQ"ALM;+/T/T/R%#Q</X%;C!U?I(G2%/7TN8N,)A*5^V@3YNP2VF$\"+,I4-\
XM\XRY^8KEP?PAF-=N48MTI'8E(S_NYZS,5:?B.R#X.Q(KECXRV8$MC79@6A]P
XM25@.*K*36&_N;,1>XZM8=@0QCX]]35"'E6$';- D=K0\E+I+!ND,G59.>X8]
XMPU:#M+/+GDL)5A=2TFYT5>L6\060B7BW6/LDD,[AVZ80Z00RQ7POK?778+)8
XM=5<5.8ET8MZFC$F%@!_81# 9+X[6+CODXJI]\J8=<(&.7*SUA)JL62;@98;Q
XM6D::?<0 %/JQY?'3F3GR;Y)9I-O$%ZX,^QA,8LX(B98N$A%31(L(W';5&H-!
XMR_9DOLBQ8>$M&>/II"/LT)@:.JN+#17'LGN9E*7H<NUUIAM0:IP!<<&E()@(
XM7LPSFY:/#W_Q6\-BX2K$5 \(1E8KAB;-X+C-D,5),69E58Q8R,UF+N<Q74 0
XM!#N*NT+4XO_M;5M*\/S80!0&(:CAB$RF85)TP_YL@Q1?""3<"6/1Y=-*6L/4
XMQT1H D(]WTXW,/;MI,8P*-,/T0VCBH(#X7!HH!.$+^Z\ZT5G[D3AY]7IL#GY
XM9S<M$Y55Q&-C<87RF(! 405TM9"3SQ8%FP0N/8VZQFHB+ KWUK^V#+%)N7IP
XMT#J\U3))X\=F0Y%=DP,Y9%")/A#)5 >7@7M* A]XPNBH?:<J71-&8;#S BG"
XM_Q!H(%':6= 6,<B"341,1[JX\@D3E(HW9#*))=.L9?-&$#MW2(O&O)K4<H&5
XM8]4W18EG;3GHD$C/B3W&!P,+K8Y4Q"WV"%?DK?9Z-6BV7IPO OYC.G*:$5'$
XMCK@>1C"@VD;Q,W84F+,]P<B#YQN22%8/]%#T\&]LWY01&B)"Q4+NK4*:.60)
XM%E0'ZC=!VF!/3'B]E);!MQ)?.(853; #P_$/<DR //XI+-XH07DWXN/"7)24
XM1M4Q=2/ZA5_". 'QK59L9#R6JJLUBQ'CCX+ITR8]+(U%[J2@*L6#GJ*-PWIT
XMW+Y 0@5U',R,3!9#([2!#N4? :W<FGG5FL(+.5?HW\IRE J+Y::NI4#3/4&P
XM0/JNJZBA98L/\VDF-!"6OJ)R/D]CQ!&7<+$71,$")H"- I#QKFM6VZ)/B?&Z
XM$U2R_;#YB_<$9T*7-<]D,!25JZMME-<A<PJ>K,9<8P]&)\W:U!3CJC;6/?DX
XMGE@R@,P+DA7)]#CBPTVY!E>#]%2 @SKN\C-<$6J%:A9M)!Z\R*IN.=8]2 &5
XMDABI>**<3(IC:!;_BS3V(C%_CU^_)_FEF\)(<F^LQ2 79(Z$K;<U<( Q6%U)
XM7[NC#R57C$H%?;OYB$H45>H7:AM_E3+N/&+1/(8TX2X70Y#UC02-&M/BF%EJ
XMWL >F(V'"49"6.3, S\"&9]U9+#1EQB,T)?>*Q8U'_$DF8FG6YL'"*!FTRL5
XMG]Y!UI2SE7=+Y]1/<K1&/.B^]+%TF0BXY:N3O.@69=LMM[P/'/8BZ++4'=Q$
XM?:4$:]G5S_G7<!(E0B6 %1YT9!5CRIO"-4+,<">]GPY;C IDB8HGGH68\&D=
XM/8X0 +O%#CAD!< C9)<9^XYFV(82VM\5@? 0M76P^RBBX[*E&M"-S 'S2&0I
XM<3"4R;4 $DI&S>:'R4WM:Q*,DYCTP<U23IL%;O<MU<QL%=&JC,*D4K*_^?QU
XM($5/=%[6;,&7ML'Y9<6298@;+P@Z)UBAU9#LW0&G-@04AJH(9,5*1I$UVG6\
XMZ6I3>M)G@V+%8&#_T&Z8P2HE%HQ34G)E]+@?O$&N;G&M>!GYAR4-N[<5*/IA
XMO;P.3K2Y$YO)GP13>MYU71XOQQ[SB[7Q5*D,[?W2?2NR*M^7&&ED^P+\Z;, 
XMZB8B]!-5 ^;W3_("A@%S?@&<>(AW0M%"TS#?>_YY*%8;A^#_175#&X)GP*-,
XMLBX+JSF;;/#AJK(ND,751F!=.(P='N<NGQMF(SYF)^(*!@3OYU)-5[@$E+,5
XMU[@DGJ[SC=X!'9,G%&=F4Z C51K[X[]D6L=E8FK=99:\(5U#&<XS%3B"NKV(
XM;U(C\J]D3 YG%"'^Q>7Z"6+  $Y]PEA/R'9DT#EN0SBE/Q=R!4@5-Q'#N0%'
XM?-\F<Q* 6C3DCI%INHY@C5I*-UL&AD[DP\'=&7#Q'&9.G5Y!*=+2ZW$*7 (B
XM!0IMT[*#26C#:&0^FT:$##AD/@#^QFRLW:7]2,ED3!H>*C%O&;(-2O>/^K[X
XM?L0FF!*8RINGP] "%L &"H[!Y=3; N>V$F&0P"WL3Y I%0R.! KP$9IN?-;"
XM5KTI%A9Y"UR7U9CER5R<?>DEF^#X6R%A.-$_*'*59,8Z:J8>[B#B-E43=E&.
XMP2Q=)+;@V'Z.)6,EC <ITRP@78V3R67*#)FSXI;99%,[71PW9DBCVXF6FB-Z
XMA,9>"@UNYV^(:N%0T"'4/HK!S9SIVERJ7%@9G%-D8/X-)XJ43 X!?$(I556D
XM;S!L09)@\ !"\8*9DW.$ ;4_0(5#""4&)T'_P.G9/]H<1$BJQ;!4#B2QO..E
XM'%02?\\]F3D-I CK+=R:SK1C1K!_EC,##<*I0K-TMU) >9ZZWU9G.21RZAM9
XM+L*?4Q1[YZ!5Y_6)M7(N/U(1$@VO3!ZX>PL:#@W'),NI@EDJ;)7BLI)V8)$*
XMN9(I^$Y=I=Q!DYG@4)>H1IP=E!6JJT4*= +5,%L:.T@E&1%\,&>P<L%G/+<=
XM>#%=F]1J(%@57.@L&[%]>%V4FC@'"H>VFY3B<"PR%A-K=",)VGA%1$)K(JB5
XMNMY\YHW:YQ4C,F:J)0WI5,0GXAN<6D%C/<P>W@/;9V.2(UNB3=C!AN*B:"(>
XM-?2OT5ZTBL\DO*&;3<W<,.)OQ0=4DZAJ4R**..4(B@Q@5PL%6L^D/^:KJY5 
XM,#;!:<Z%QZPL2Y<1V9>AI=I]+[3J[IRV)JP-+;BH0QJ9-=Q7W\& F0&=,I7)
XMR7Q?/]X0J.ACGK+5[$DV-_YH5P^0K)ZDVL"8Z1- 0>Z\9]/VB!@"\&(-=E[\
XM3J,^(E/<BD;EF *]$.DQ3=%TJ#"I7);4:O=<"4JRR[P7R".(!ZG'IO*[\;3!
XML28>]\XA8/)/C$MPU9G!%<'$?N'=87JVE 1!@*=<,0=S3X!3!"NU-A:(L@$.
XM)PQ E)6,A$7RCF'LV*CH2XR$;E6KF@9O!4$COK0F8,9/HTP][\(W4N*)D-&B
XM>,0._YJT,&Z%GLH38Z00WY(E*A[;+FP7P2/M\00RH*YJJ(@"3\3C-$,0JU?\
XM;O2ZQ\O0F7W7TCD$?-;="AV_Q\2X8ICL^L79 7/R)8M;2)WU05A7 *33 K+"
XM=7&(R1*+)/7B-69Z>'8P[D!Q#<(K[0.A(>R):0]'O-[#L-8]+_O7&L&16&X 
XM<SB?Y8W;RF5C2:*( D=<4+49OT5,G\6#V!&I6*08)49P;@Q,AL*#,YCS2T;P
XMX?8<>0QV5H,.]*58.A *W8"99&*R(?6N.+FD\5%>HS)W?9F8Q51.B:&V[:9H
XMJ!+&#PG="B7DLZ$^ TP%^^0FZ S-K]071VQ,D!B_<).] P@YC=;P")A, 7LL
XM.]8IH:/8;NCLOBL8>5A*358M?,HWQS9S0^)F#9U 1YX\2B6/AC>)EWIINKK<
XM@NV]7\*XXH#0+TS E62\=*LW)R>#7Z0A,=+":?%,(P(:91GN7ZPC.(,:U)0\
XM=HB'AH*Z2?GWR!M*$!03@ND3#]_OR6]I04(:J3_91A2]W$],G\'QBL$\;0(K
XM21P8C@L+!I0I:69.$LY%)HD@H$^&")N&:)HY68YF])0FCC31ET^W5DCT!8E>
XM2@6.6YFC4'@3DV B0>)D9,5],CR( A\2.-$%"YHT1'(.+$@#2A<!I1BVL!&W
XM"6YL206HB) MP<HC!D+,)R)+>XN+4QRD?/(Y#@\7>47&ZPU97.1$3('#$Q%C
XM!3.6NC/BGF-2V'#)^/VE4-@0B;F28ARQ'Q@"#O"Z*),"^-YNVI5IN[(7[ YU
XMK1HD-S!;W%#3A"@W8&-]1B8AUHV0QM8$6(=GZ+9&C1W&6(+)L6>B1[(LQCGP
XMB#<@WF,.B)MB'SSL\YF(/:HLC]Z.[P>TFY&EZ^XBV*07Q8X2E+PRB4&[0P_[
XM6NYOTSPZ48?(?%,Z)E#]O_JU>%]PXP(X*4#WC98-A)&05I)%4/$XN<0#X7H0
XM.-82PJ)ETKWOD^&B@818+C@?&]B 1548ZFL]7MAVBI:(W+NBA8OBXU/53;P,
XM+EH;4"83<OFD6:'H_6@$03 9CJ3+QC5-4@J5(+)]0[H5-.1!:[,B-Z5.0XL9
XM0O9SI;$?\H[SQ'HHP\09/4W%.S/?(3 39SPA$Y>MQ"PQKA[M5G %/D0%.GX\
XM$* FU31B!VNDIMHH_"TPC'4L&&0N092*AE=Y:-'<4? 7;(=,"Q[EHPN19*?!
XM.&PC^T7\8WT4,Q7O6\VAD*UMBHP^!W4C/#1.L:J51=0;40>Q!U(#BH"DBX6M
XM/$=H26'VQJ=2BJ$[S@)?B -D%5EH,@ 9)/9K7/0T4$@'3]CYXKSS=18\#7$H
XM,5\(? ;9:N18:EPE0!;#>.^C7@YF\><!X%&D'::0)SFQ$XXC(/EX3X.S(AW/
XM_9!*Z9PV,M5FE8K/O89$.4BS&4OAJ@V/^]=IVCPV;U6#?([R5%D/<C(Z.^'Y
XM#O?&4M+T9[B-D-89(\\=]R)R7)#9I^:1:K,E]L!8-9N^GV0N,J4 "Y L;HTN
XM@R?&Y:S1 U7#QLLC)OE2OCC&HHXVA>!%<F+94JMD,PY&@T&W HLBJC3Y<!JN
XM@+!722Z)6OU5:Z8U$Z%!0IRB6I9TRL(1YWGY;-X^P_1\_V,!V+;57I:1.]=F
XM+<YQ%@OKA03-RE(V$FT.;%0-%F0P1BC92^#D6B10' XG&Q!M0X-CZB9ZT+< 
XM(> MXV.?2;HEG2F7>(8<'!:F9V3K4&UL0YH-X<<8B2]H; [*H:LN$)/%VG'Z
XMWYA>)D7KH65M-3&N>#D:/<&-.K-*VDX7=R8Z<V9,181R/I/Y(LO-5_>4&&:H
XMC%0IH!8&1DC9C3M6MH>*Y(0?0HMNB9['_T+. F*PD'AC#-:"QRJBPZ&Y0&WP
XM.@!':]O(9'SIE)1N&V;<(-HEU W)@M$$%E'V(6D";KT]]3+#LJ'L:\=/W8>(
XM;X8J6Y1N!MH0/_;A720W.M-F3*7%BUHE0W/R[2K+BM4[BH,S3*5DM$Q:[B+7
XM";)NJ.6:0M+O(]'3P$80,_P:+[NCC9)AB!):GF;QD#(7 LUC!IQJ O9$L<5H
XM.=QZL#K!#F"*V[C3)#TH6-";W1;WQ]*L7[LN,VL8535P*(-TUG-'*C-PA6@^
XME,5M^5HXB?%@(]&F^V>T.3:Y>A"S#^F@OJN*Z!.'+LC)A1OTLDKB#$L1;CM\
XM&LVW38E+71_5)=N8-# S,SC&^Y'^1W"9WX'14',Q32PG"QPP'+4.1F5Q@=W@
XM'YE%KRC:"_ P3DOWH5&@@><5&C,($':)VRD3LYEU-9UA^+'.&-&(@"@)&6Y8
XM72"7?HMPH.+ B&&Y*-L4BT6RI>4P07QWL])!-FDL<4>=SJFP")$-6?)\<)1"
XM)CL9(Y!2'(5D.D2U8)Q>6C A.9,,"%TMIV2$)((@#'Q2RR>7& ;WV'%><%@I
XMJV)0VZU!S9&X9*KHW8PE3Q=C7V+<5$3I-JG"J9)0QF(X8J^4C.LV%_*Q$">#
XM+U#,]E!HE\HALR ?3M=E-(BOO*#DQ=Q68C'6.&(H>W.Q&9'"WG1$*<:DFJT,
XMSK8OF8O_R,,B)T7!T74D97 Y"(O%4[<HJ#/>PF_QJ;8D,M'"%V_IU_'WU$EB
XM?T<;CN1L1'X28G0,R?GU@\8?UPBN2$@63X%JMH>*",<-VV.=PR,B.4OR74WL
XM9G9NN(Y?<=]W433(J>^2-9\O[F6/1*7DJTN<R/19@O41U"+@BCXU>>4ZT6*P
XMA^*UV"$$%L* #18)J]9=C:08BK%]+5RQ7_LM$W7,*VD(< ISCO;F1=PXR83<
XM<E4:Y69%1]8-G< =;5$(>FPZW#\E2+#. 6M4@0&R&XG&Y>%T#B#E<D(_<6]L
XM*#J/X.94!<2$M:&4J$+4NZX\)(>L H;-@W1^DCZ5."]?L4<3:_%,WPM4(PCC
XM+-D;#8_32ZI"2(PIX8">F8T&:68R@7R*E(R&.,'D'$"-PKXC878C-;%3NS# 
XM$SIF[I8NCBIUQ$%]8!.GVU8G$V:2AK*%.-788R9QX:Y3  2YH.K3@V2M@T\:
XM5D#%F.8RF6+7_Z8 9BZV=BF3&97RB2V*^$!>_HZ8E_T$9[MDL%LB4K(IJ^4&
XM+$"=K:\2G1=U::%V<XT2)Y0DE]-JS'OCG]C%,<XMN0H+LQCY$ =F:UN56\A9
XM/169JXLV$DTF5-.UVMMP\2K#>C)GK$A,2HH?LPS?&F^-F!),R?_"Q$QNSCJ#
XM8K;..>*!Q@1E)3N>4+P*GX +FX]:HPRU-K+  ?(:N7 3CIV-+B3K6W%SMC,P
XM6Z2RXZJ,'9&$1!>["D)RE=8/8T"7Z#HQC;,U% ^?6+/,B^9V<4>9Q)P"WBUL
XMD=D:QF<S0<>MNFI*WO"56_)AA!-2Q-&#VU!FG#M\.<81[(V?!V^II^,J[D[^
XM<D"F'R$P8($DP?!-TWHD@/J$*5%S[G^+CYEN2CR)^P(D[C2R<097;<C.*F:6
XM&EX;W(?(Q$@BY$PF(#[>%#05LPD:3MNAXA!=A: P>^)"7=40#*DDKKQ609+P
XM/'HH\^57(D[MF9'-XUC\4;@1LYP2,#ODU>/8^^9^#:I@L@R9*"J8]QK9W%KR
XM3L#"76/-DG^$YIOU0N9B=QK/;(_\LSK#YJKG_5W0'58-'H;P8^?'52*0PCK9
XM2> ^^&6OG0QENV)GP&SX6OHC4XX%#9/ASS9/6Y#MG(DK&]+#Y"OP7WEE+#8:
XMI59Q-PVV'K3V5T-^P83P>;XTE(C*PM4Y\RN&5F>XAM"L1 A^X;D%I'H';:JP
XM"?$-:+>M8.&+8'$\:B/7/^!0F<-\,L1DNTNPL+"P4E4?8^-3- 2,4?L3XV0$
XMF%$7"TER@@;'KC*#LK3H#:L/][\]],6">LF_@*,P)@:^*^A*M)DG=>?YE7*H
XMDU<\0(MEA/".C;KI"_'$.;K'1XQN\J1TGWB;56UTHR5I%Y&[\HMX?4-*T7/8
XMHF"W7C#?S007\-10N6D>50(S-4W? T^F'P:9Y$1W,9YQS(@9ZAZ"!:W.> ,4
XM<ENN+8=Z!V."H[#G:5[P>?JYFZZ*QH)&@0:RL/^]332ZN^;ZR,,&0,%TA5I8
XM)/)QF8MBA]J0D205TFQ((SU"] :)5J3E^34%A2DX]10C,*.X$$3"PR"YJ2.!
XMH:O'M +L&A7U)[+/R E]&)98T8LU6%(7LP.1E&3 #="8<^ JBV/'P?'!ZH(!
XM2)0?=XR<PQDF':EXAC V*U(C 0VQ*O2!20<Q4G=HZH23, 5/&W8"Q$IVVR=2
XM[*RK;H>G[Z@ M&(EN$2_H/UA@@T"Q=+B#J8M$U-P_RBZ.8B2!FQ$Q-$HK3]R
XM+XR&)AA-B?%W6^JIJ$=/2H]'%!WM+7QU*?U6::((+[P? A/]U]4A4MH!G%#$
XMNI0O" F87SI%<.<_0SB(I6<1RF@/Q@M*61R);DP0<MX,+N:==&\''1;G>.CI
XM9G!(I&.\S*8,I82BF/H\1L +FS6P\%^BF[P#%4YD2CP;@QUU9KV5TB&_BBW 
XMFJZU3H2(XLVUE?5-><6\0=VDK0=^])M /C5ND#S()X(7L@EQ(,7XI]% ^3QX
XM1-"MD(NB;HP"F.,VR]!Y>% I_92NY#=:UMCH11%[?P,ULS!'S37D/S-A+;_:
XM(&V3Q[VS+EH'1'5NFR4Y%'Y 8H5ZQXOD54"6+MQ@U[3"/ VU-*>68-&2!6@(
XM@Q0I9@[F"M5"@OP0X;E$-\P+P1XWBKO1,0GS$ILQ3]%L]B>Q@W6(>957$<-%
XMZS2+=SP/=>EJ-A?,@[I]BQ870@=S6!J"8W@KZ$]S";8EK&;*,_Y"<E,QAG;(
XM&3P<&+2WR6;C\KK2H0RV8CHN@PUS&+6G?&HVIHW8*# 7(N,5F]WK)(FBGL:8
XM)Y:*3D5]Y ]AW"M>?1U E?RKK 99PB3Z,_QXOA2X ( A*5)H!?Z"?[)#4K:4
XM4MVJ8V';"\ZJ73E6O8IAPH .%[X#$"_8%-W:#7&$6K1/RY2*W,<FDT6R,(]=
XM@PL-<\Y?'+:.MJ+L^T86M/R C=:7](DY,RU+V4PO:YX]F]HOA8M&?8-V@3SM
XM;VTONE[8:GV"JJ%1@'  //POE@VA] 2#A:Q<<8.:5V!J?R,+C$[#\>!I$R_5
XM*/!=185<#FGZ3LN0JM_B(' >D5A>@8L:3$!2QMZ<E+\-089,"T+D+8$RC1(S
XMI+,7YH5%RN0Y=7P1?O^B@-,B:1&[M$($J8%VD:O&>&4]0!KUUJ[8C3JR0(P\
XM<E)*EH< )8H7N J$.,/="W;580)_M(0C-M'7J"Q<C8\2R0U3Q>&CRD+BZ#-X
XM&OR ]D?B*:##_?LYMC,O6=[*CHP?80_X)!5 P?*D)O ,78[4J("*ZO.*L8W)
XM3SD9NPM%M<F"4>TGV$R'D1<6GMM3<M*8,7(TP3,34Y 2"99=\;Z$(^QNR5Z(
XM-2K5B)SJ<QS$I]440RK<0D0,V\(>Q&5OO6=>^&@6C!=1*(@]W//E/T(]QC(H
XMI_\$XR>X7;1"HP"6ELMBCC$8QA32[[Z9*H,*,_;Y;M(Y8PULA-,MU8'@<:'T
XM49;00S5/%[FJL)EL>!#9;JD^"4%FT+I9+BNR0$Z?JW_6@ (L /8&#;NV#;Z>
XM6W0.$Q6/!<-A?'*7?KX8^W@.IY<AU-%&/.VF*)Z4-2*O\CY+F%&4#</+DB;L
XM9N02D5',\PV83WVK3DH?(;;4B^HN-:I@_+2NUE3P&!*ISHJK;HW7#ITZCG9H
XM1=3.4IGPL "8D>0:.;P$FJ6]7%^(AF%5:GV+'/WR,+1O 4I5I )UK&!2)4XH
XM0236G )T]9J I+RL 4E$-DXC] [TK4X:T*%]:7[@*/##Y>-URZNL9Q)HGD.P
XMS8H;6ZR'PZIC&VI2[A^!14B_5!OM'Z2$])N[<+U KB,%NFLVP7\:6B'HN#]P
XM,784<&N -9P"&MPXR4@;6!X[O%BOB.;"N"JG@VXD-E[7"U-*Q!Y:H?$=-*^(
XM>+N*"EAS2RD'6# Y"%^["=!:D>@,0\_"@US'2%];5'0F.V#B"HMF@LJYOLV2
XM3-$JQC:Z-)W(6BJ8KN^*)XXF!)D^S5?TZ_!C8$R".28,^VFG MJZ4> "@+UM
XMA4W#1PWBZ\9%XU*L#F^0-;N*LX^EF%^B_M18+I\80Z8]WAI^X=S4+P+D*J\@
XMK0>#S@LP1!QB@GM_-C>LL%G8O.O)\TUZAN$C=F#C<3G74NNT+0T; W*Z3A27
XMI\_&EQ2!3)D:A?7!VGP@4^ M_PFWPN58M"MI^E[GKI_8D *,@8"*&5&Q=6TT
XM)FP05=TS=">6*A-J,4H8VQ[.(U,N"B%GB/BQ$&0/,(90NI *0VLY:WNN<.\V
XML8\%!NP[013[<-)Y&-*Z&GH:\F$NAB="*M/%B7%P,GIAMS![\Y5DD<&]\5S[
XM5QO2.(^2R$,BP6IN60#UK.D'D6P\ 5K+# VPL4$D-8X2%DT_MM\:(1E&=11]
XM8M,EJ2PZ,":20+V!L5UCLD&[1<.?A^G7D)'"OA_$L@,'584$]H/VLWO5)2,G
XM:S87Y9*%"##;/;,??9/ D1T[H>7BB0[)\L"YT,!<LL=S(HL\A!M;5?#,KEC7
XMONRN] EK=I.DCRVNV/I2/TX5O3/)'FRUDRVJAG'@B;^#?0Z>RV;+:%W<L*!R
XMK]$K8H-U-CL;CBTJ<!9,5O?8-&:"S%C%\Q#:G4, :V'49Z_90G<2!!H@AN$^
XM0]P=KHV.R15VE:UD8"K@KL_6%.M5@;-@A70Y'FFSAK'9)H[0,FOJ365 ?5/+
XMK=UZ&I?+W)D"F!M"ODO75!3:2 >&]N3Z^:;*[C:0-3 ;NDKQR2KIBQF>.)?L
XM-AT+F(H^@UXOM^(C-C*(>%RRU1ZKR2L;FX![Y6HC"8+6@":XM6>FF.*^)A_K
XM=,['*>0R\X&I+Z'?;;Q,M T39FP:CY6!@.W5/D_6M9T$T((VS3/:!S&O+I>4
XMCP_/%(^/1EC#APTZ?G\,B6W7<H@AHO?85_)( &K[K%/:SXFJ FK"@;V^+K"0
XMCU/(9VW,MEE[L^W#!O\"9</-VH_9@6,;I2VY]FHK#<H^C8D^=E$EAD)J>5\K
XM4\0:BN(#B[ABD)U6"")LM>_:"EO<=K;# @)H8N^NMJW6?11*:7XX? +>X5$4
XM4:@JNNT_:FD[N7U&<0&4CQA I^1 +T-WNGUN5>+9MNG:S&T7\'([NQU(=6Y7
XMKU0HW&-T2S#7&GS=.'=05;#;W&V'<'J;I7%UVS]+L5L4((D'"*QJ6H#>7F^C
XMF;?;]NW\=G(:LJW?[F]?D/';_NT MV1"J"W@+G#[>@G<!NX$]XH7P*W@;G"O
XA*Q#<#NX(]WU;PDWA#FKSMRO<&&ZK<(9[PTV!Z /L !0 
X 
Xend
END_OF_FILE
  if test 20450 -ne `wc -c <'bitmaps/earth.xpm.Z.u.b'`; then
    echo shar: \"'bitmaps/earth.xpm.Z.u.b'\" unpacked with wrong size!
  fi
  # end of 'bitmaps/earth.xpm.Z.u.b'
fi
if test -f 'blocks.c1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'blocks.c1'\"
else
  echo shar: Extracting \"'blocks.c1'\" \(31252 characters\)
  sed "s/^X//" >'blocks.c1' <<'END_OF_FILE'
X#include "copyright.h"
X
X/*
X *  Include file dependencies:
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <stddef.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#include <xpm.h>
X
X#include "bitmaps/blueblock.xpm"
X#include "bitmaps/exblueblock1.xpm"
X#include "bitmaps/exblueblock2.xpm"
X#include "bitmaps/exblueblock3.xpm"
X
X#include "bitmaps/redblock.xpm"
X#include "bitmaps/exredblock1.xpm"
X#include "bitmaps/exredblock2.xpm"
X#include "bitmaps/exredblock3.xpm"
X
X#include "bitmaps/yellowblock.xpm"
X#include "bitmaps/exyellowblock1.xpm"
X#include "bitmaps/exyellowblock2.xpm"
X#include "bitmaps/exyellowblock3.xpm"
X
X#include "bitmaps/greenblock.xpm"
X#include "bitmaps/exgreenblock1.xpm"
X#include "bitmaps/exgreenblock2.xpm"
X#include "bitmaps/exgreenblock3.xpm"
X
X#include "bitmaps/tanblock.xpm"
X#include "bitmaps/extanblock1.xpm"
X#include "bitmaps/extanblock2.xpm"
X#include "bitmaps/extanblock3.xpm"
X
X#include "bitmaps/purpleblock.xpm"
X#include "bitmaps/expurpleblock1.xpm"
X#include "bitmaps/expurpleblock2.xpm"
X#include "bitmaps/expurpleblock3.xpm"
X
X#include "bitmaps/bombblock.xpm"
X#include "bitmaps/exbombblock1.xpm"
X#include "bitmaps/exbombblock2.xpm"
X#include "bitmaps/exbombblock3.xpm"
X
X#include "bitmaps/counterblock1.xpm"
X#include "bitmaps/counterblock2.xpm"
X#include "bitmaps/counterblock3.xpm"
X#include "bitmaps/counterblock4.xpm"
X#include "bitmaps/counterblock5.xpm"
X#include "bitmaps/counterblock.xpm"
X#include "bitmaps/excounterblock1.xpm"
X#include "bitmaps/excounterblock2.xpm"
X#include "bitmaps/excounterblock3.xpm"
X
X#include "bitmaps/blackblock.xpm"
X#include "bitmaps/reverse.xpm"
X#include "bitmaps/hyperspace.xpm"
X#include "bitmaps/machinegun.xpm"
X#include "bitmaps/walloff.xpm"
X#include "bitmaps/multiballblock.xpm"
X#include "bitmaps/stickyblock.xpm"
X#include "bitmaps/paddleshrink.xpm"
X#include "bitmaps/paddleexpand.xpm"
X
X#include "bitmaps/xtraball.xpm"
X#include "bitmaps/xtraball2.xpm"
X
X#include "bitmaps/x2bonus1.xpm"
X#include "bitmaps/x2bonus2.xpm"
X#include "bitmaps/x2bonus3.xpm"
X#include "bitmaps/x2bonus4.xpm"
X
X#include "bitmaps/x4bonus1.xpm"
X#include "bitmaps/x4bonus2.xpm"
X#include "bitmaps/x4bonus3.xpm"
X#include "bitmaps/x4bonus4.xpm"
X
X#include "bitmaps/bonus1.xpm"
X#include "bitmaps/bonus2.xpm"
X#include "bitmaps/bonus3.xpm"
X#include "bitmaps/bonus4.xpm"
X
X#include "bitmaps/exx2bonus1.xpm"
X#include "bitmaps/exx2bonus2.xpm"
X#include "bitmaps/exx2bonus3.xpm"
X
X#include "bitmaps/death1.xpm"
X#include "bitmaps/death2.xpm"
X#include "bitmaps/death3.xpm"
X#include "bitmaps/death4.xpm"
X#include "bitmaps/death5.xpm"
X
X#include "bitmaps/exdeath1.xpm"
X#include "bitmaps/exdeath2.xpm"
X#include "bitmaps/exdeath3.xpm"
X#include "bitmaps/exdeath4.xpm"
X
X#include "audio.h"
X#include "misc.h"
X#include "mess.h"
X#include "gun.h"
X#include "error.h"
X#include "bonus.h"
X#include "special.h"
X#include "main.h"
X#include "init.h"
X#include "stage.h"
X#include "ball.h"
X#include "score.h"
X#include "paddle.h"
X#include "level.h"
X#include "sfx.h"
X
X#include "blocks.h"
X
X/*
X *  Internal macro definitions:
X */
X
X#define EXPLODE_DELAY				10	
X#define BONUS_DELAY					150	
X#define BONUS_LENGTH				2000
X#define NUMBER_OF_BULLETS_NEW_LEVEL 4
X#define DEATH_DELAY1				100
X#define DEATH_DELAY2				700
X#define EXTRABALL_DELAY				300
X#define RANDOM_DELAY				500
X
X/*
X *  Internal type declarations:
X */
X
X#if NeedFunctionPrototypes
Xstatic void ClearBlock(int row, int col);
Xstatic void CalculateBlockGeometry(int row, int col);
Xstatic void SetBlockUpForExplosion(int row, int col, int frame);
X#else
Xstatic void SetBlockUpForExplosion();
Xstatic void ClearBlock();
Xstatic void CalculateBlockGeometry();
X#endif
X
X/*
X *  Internal variable declarations:
X */
X
Xstatic Pixmap	exredblock[3],		exredblockM[3];
Xstatic Pixmap	extanblock[3],		extanblockM[3];
Xstatic Pixmap	exyellowblock[3],	exyellowblockM[3];
Xstatic Pixmap	exgreenblock[3],	exgreenblockM[3];
Xstatic Pixmap	exblueblock[3],		exblueblockM[3];
Xstatic Pixmap	expurpleblock[3],	expurpleblockM[3];
Xstatic Pixmap	exbombblock[3],		exbombblockM[3];
Xstatic Pixmap	excounterblock[3],	excounterblockM[3];
Xstatic Pixmap	exx2bonus[3],		exx2bonusM[3];
Xstatic Pixmap	x2bonus[4],			x2bonusM[4];
Xstatic Pixmap	x4bonus[4],			x4bonusM[4];
Xstatic Pixmap	Bonus[4],			BonusM[4];
Xstatic Pixmap	death[5],			deathM[5];
Xstatic Pixmap	exdeath[5],			exdeathM[5];
Xstatic Pixmap	counterblock[6],	counterblockM[6];
Xstatic Pixmap	extraball[3],		extraballM[3];
X
Xstatic Pixmap	redblock, greenblock, blueblock, yellowblock, purpleblock;	
Xstatic Pixmap	tanblock, blackblock, bombblock, revblock, 	hyperblock;
Xstatic Pixmap	mgunblock, walloffblock, multiball, sticky, paddleshrink;
Xstatic Pixmap	paddleexpand;
X
Xstatic Pixmap	redblockM, greenblockM, blueblockM, yellowblockM, purpleblockM;	
Xstatic Pixmap	tanblockM, blackblockM, bombblockM, revblockM, 	hyperblockM;
Xstatic Pixmap	mgunblockM, walloffblockM, multiballM, stickyM, paddleshrinkM;
Xstatic Pixmap	paddleexpandM;
X
Xstruct aBlock 	blocks[MAX_ROW][MAX_COL];
Xint			blocksExploding = 0;
Xint			rowHeight;
Xint			colWidth;
X
X#if NeedFunctionPrototypes
Xvoid InitialiseBlocks(Display *display, Window window, Colormap colormap)
X#else
Xvoid InitialiseBlocks(display, window, colormap)
X	Display *display;
X	Window window;
X	Colormap colormap;
X#endif
X{
X	XpmAttributes   attributes;
X	int 			XpmErrorStatus;
X
X	attributes.valuemask = XpmColormap;
X	attributes.colormap = colormap;
X
X	/* Create all xpm pixmap blocks from the files */
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, redblock_xpm, 
X		&redblock, &redblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(red)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, blueblock_xpm, 
X		&blueblock, &blueblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(blue)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, greenblock_xpm, 
X		&greenblock, &greenblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(green)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, yellowblock_xpm, 
X		&yellowblock, &yellowblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(yellow)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, tanblock_xpm, 
X		&tanblock, &tanblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(tan)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, purpleblock_xpm, 
X		&purpleblock, &purpleblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(purple)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, blackblock_xpm, 
X		&blackblock, &blackblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(wall)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, bombblock_xpm, 
X		&bombblock, &bombblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(bomb)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, reverse_xpm, 
X		&revblock, &revblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(reverse)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, hyperspace_xpm, 
X		&hyperblock, &hyperblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(hyperspace)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, machinegun_xpm, 
X		&mgunblock, &mgunblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(machinegun)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, walloff_xpm, 
X		&walloffblock, &walloffblockM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(walloff)");
X
X	/* Explosion for yellow block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exyellowblock1_xpm, &exyellowblock[0], &exyellowblockM[0], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exyellow)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exyellowblock2_xpm, &exyellowblock[1], &exyellowblockM[1], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exyellow)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exyellowblock3_xpm, &exyellowblock[2], &exyellowblockM[2], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exyellow)");
X
X	/* Explosion for red block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, exredblock1_xpm, 
X		&exredblock[0], &exredblockM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exred)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, exredblock2_xpm, 
X		&exredblock[1], &exredblockM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exred)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, exredblock3_xpm, 
X		&exredblock[2], &exredblockM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exred)");
X
X	/* Explosion for green block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exgreenblock1_xpm, &exgreenblock[0], &exgreenblockM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exgreen)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exgreenblock2_xpm, &exgreenblock[1], &exgreenblockM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exgreen)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exgreenblock3_xpm, &exgreenblock[2], &exgreenblockM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exgreen)");
X
X	/* Explosion for blue block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exblueblock1_xpm, &exblueblock[0], &exblueblockM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exblue)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exblueblock2_xpm, &exblueblock[1], &exblueblockM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exblue)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exblueblock3_xpm, &exblueblock[2], &exblueblockM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exblue)");
X
X	/* Explosion for tan block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		extanblock1_xpm, &extanblock[0], &extanblockM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(extan)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		extanblock2_xpm, &extanblock[1], &extanblockM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(extan)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		extanblock3_xpm, &extanblock[2], &extanblockM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(extan)");
X
X	/* Explosion for purple block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		expurpleblock1_xpm, &expurpleblock[0], &expurpleblockM[0], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(expurple)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		expurpleblock2_xpm, &expurpleblock[1], &expurpleblockM[1], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(expurple)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		expurpleblock3_xpm, &expurpleblock[2], &expurpleblockM[2], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(expurple)");
X
X	/* Explosion for bomb block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exbombblock1_xpm, &exbombblock[0], &exbombblockM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exbomb)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exbombblock2_xpm, &exbombblock[1], &exbombblockM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exbomb)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exbombblock3_xpm, &exbombblock[2], &exbombblockM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exbomb)");
X
X	/* Explosion for counter block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		excounterblock1_xpm, &excounterblock[0], &excounterblockM[0], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(excounter)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		excounterblock2_xpm, &excounterblock[1], &excounterblockM[1], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(excounter)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		excounterblock3_xpm, &excounterblock[2], &excounterblockM[2], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(excounter)");
X
X	/* countdown for counter block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		counterblock_xpm, &counterblock[0], &counterblockM[0], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(counter0)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		counterblock1_xpm, &counterblock[1], &counterblockM[1], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(counter1)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		counterblock2_xpm, &counterblock[2], &counterblockM[2], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(counter2)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		counterblock3_xpm, &counterblock[3], &counterblockM[3], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(counter3)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		counterblock4_xpm, &counterblock[4], &counterblockM[4], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(counter4)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		counterblock5_xpm, &counterblock[5], &counterblockM[5], 
X		&attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(counter5)");
X
X	/* Bonus block stuff */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x2bonus1_xpm, &x2bonus[0], &x2bonusM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x2bonus1)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x2bonus2_xpm, &x2bonus[1], &x2bonusM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x2bonus2)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x2bonus3_xpm, &x2bonus[2], &x2bonusM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x2bonus3)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x2bonus4_xpm, &x2bonus[3], &x2bonusM[3], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x2bonus4)");
X
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x4bonus1_xpm, &x4bonus[0], &x4bonusM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x4bonus1)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x4bonus2_xpm, &x4bonus[1], &x4bonusM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x4bonus2)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x4bonus3_xpm, &x4bonus[2], &x4bonusM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x4bonus3)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		x4bonus4_xpm, &x4bonus[3], &x4bonusM[3], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(x4bonus4)");
X
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		bonus1_xpm, &Bonus[0], &BonusM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(bonus1)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		bonus2_xpm, &Bonus[1], &BonusM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(bonus2)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		bonus3_xpm, &Bonus[2], &BonusM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(bonus3)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		bonus4_xpm, &Bonus[3], &BonusM[3], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(bonus4)");
X
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exx2bonus1_xpm, &exx2bonus[0], &exx2bonusM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exbonus)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exx2bonus2_xpm, &exx2bonus[1], &exx2bonusM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exbonus)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exx2bonus3_xpm, &exx2bonus[2], &exx2bonusM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exbonus)");
X
X	/* Death block initialisation */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		death1_xpm, &death[0], &deathM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(death)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		death2_xpm, &death[1], &deathM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(death)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		death3_xpm, &death[2], &deathM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(death)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		death4_xpm, &death[3], &deathM[3], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(death)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		death5_xpm, &death[4], &deathM[4], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(death)");
X
X	/* Death block explosion init */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exdeath1_xpm, &exdeath[0], &exdeathM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exdeath)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exdeath2_xpm, &exdeath[1], &exdeathM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exdeath)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exdeath3_xpm, &exdeath[2], &exdeathM[2], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exdeath)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		exdeath4_xpm, &exdeath[3], &exdeathM[3], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(exdeath)");
X
X	/* Extra balll pixmaps */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		xtraball_xpm, &extraball[0], &extraballM[0], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(extraball)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		xtraball2_xpm, &extraball[1], &extraballM[1], &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(extraball)");
X
X	/* Multiple ball pixmap */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		multiballblock_xpm, &multiball, &multiballM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(multiball)");
X
X	/* Sticky block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		stickyblock_xpm, &sticky, &stickyM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(sticky)");
X
X	/* paddle shrink and expand block */
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		paddleshrink_xpm, &paddleshrink, &paddleshrinkM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(paddleshrink)");
X
X	XpmErrorStatus = XpmCreatePixmapFromData(display, window, 
X		paddleexpand_xpm, &paddleexpand, &paddleexpandM, &attributes);
X	HandleXPMError(display, XpmErrorStatus, "InitialiseBlocks(paddleexpand)");
X
X	/* Free the xpm pixmap attributes */
X	XpmFreeAttributes(&attributes);
X}
X
X#if NeedFunctionPrototypes
Xvoid PlaySoundForBlock(int type)
X#else
Xvoid PlaySoundForBlock(type)
X	int type;
X#endif
X{
X	/* If no sound the no sound */
X	if (noSound == True) return;
X
X	/* Play the sound effect for the block being hit */
X	switch (type)
X	{
X		case BOMB_BLK:		
X			playSoundFile("bomb", 50);
X			break;
X
X		case BULLET_BLK:
X			playSoundFile("ammo", 50);
X			break;
X
X		case RED_BLK:
X		case GREEN_BLK:		
X		case BLUE_BLK:	
X		case TAN_BLK:
X		case PURPLE_BLK:	
X		case YELLOW_BLK:
X		case COUNTER_BLK:
X		case RANDOM_BLK:
X			playSoundFile("touch", 100);
X			break;
X
X		case BONUSX2_BLK:	
X		case BONUSX4_BLK:	
X		case BONUS_BLK:	
X		case MGUN_BLK:	
X		case EXTRABALL_BLK:	
X		case WALLOFF_BLK:	
X		case REVERSE_BLK:	
X		case MULTIBALL_BLK:
X		case STICKY_BLK:
X		case PAD_SHRINK_BLK:
X		case PAD_EXPAND_BLK:
X			playSoundFile("bonus", 50);
X			break;
X
X		case DEATH_BLK:	
X			playSoundFile("evillaugh", 100);
X			break;
X
X		case BLACK_BLK:		
X			playSoundFile("touch", 50);
X			break;
X
X		case HYPERSPACE_BLK:
X			playSoundFile("hyperspace", 70);
X			break;
X
X		case KILL_BLK:
X			ErrorMessage("Error: kill block type in PlaySoundForBlock()");
X			break;
X
X		default:
X			ErrorMessage("Error: Unknown block type in PlaySoundForBlock()");
X			break;
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid ExplodeBlockType(Display *display, Window window, int x, int y, 
X	int type, int slide)
X#else
Xvoid ExplodeBlockType(display, window, x, y, type, slide)
X	Display *display;
X	Window window;
X	int x;
X	int y; 
X	int type;
X	int slide;
X#endif
X{
X	/* Draw a frame from the blocks explode animation */
X	switch (type)
X	{
X		case BOMB_BLK:		/* Draw the bomb block explosion slide */
X			RenderShape(display, window, exbombblock[slide], 
X				exbombblockM[slide], x, y, 30, 30, True);
X			break;
X
X		case MULTIBALL_BLK:
X		case RED_BLK:		/* Draw a red block explosion slide */
X			RenderShape(display, window, exredblock[slide], 
X				exredblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case GREEN_BLK:		/* Draw a green block explosion slide */
X			RenderShape(display, window, exgreenblock[slide], 
X				exgreenblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case BLUE_BLK:		/* Draw a blue block explosion slide */
X			RenderShape(display, window, exblueblock[slide], 
X				exblueblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case TAN_BLK:		/* Draw a tan block explosion slide */
X			RenderShape(display, window, extanblock[slide], 
X				extanblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case PURPLE_BLK:	/* Draw a purple block explosion slide */
X			RenderShape(display, window, expurpleblock[slide], 
X				expurpleblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case BULLET_BLK:	/* Draw a bullet block explosion slide */
X		case YELLOW_BLK:	/* Draw a yellow block explosion slide */
X			RenderShape(display, window, exyellowblock[slide], 
X				exyellowblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case COUNTER_BLK:	/* Draw a counter block explosion slide */
X			RenderShape(display, window, excounterblock[slide], 
X				excounterblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case BONUS_BLK:		/* Draw a bonus coin block explosion slide */
X		case BONUSX4_BLK:	/* Draw a bonus x2 oin block explosion slide */
X		case BONUSX2_BLK:	/* Draw a bonus x4 coin block explosion slide */
X			RenderShape(display, window, exx2bonus[slide], 
X				exx2bonusM[slide], x, y, 27, 27, True);
X			break;
X
X		case DEATH_BLK:		/* Draw a pirate death block explosion slide */
X			RenderShape(display, window, exdeath[slide], 
X				exdeathM[slide], x, y, 30, 30, True);
X			break;
X
X		case BLACK_BLK:		/* The wall doesn't have any animation */
X		case REVERSE_BLK:	/* The reverse doesn't have any animation */
X		case HYPERSPACE_BLK:/* The hyperspace doesn't have any animation */
X		case EXTRABALL_BLK:	/* The extra ball doesn't have any animation */
X		case MGUN_BLK:		/* The machine gun doesn't have any animation */
X		case WALLOFF_BLK:	/* The wall off doesn't have any animation */
X		case STICKY_BLK:	/* No animation for sticky block either */
X		case PAD_SHRINK_BLK:
X		case PAD_EXPAND_BLK:
X			break;
X
X			break;
X
X		default:
X			ErrorMessage("Error: Unknown block type in ExplodeBlockType()");
X			break;
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid AddBonusBlock(Display *display, Window window, int *row, int *col, 
X	int type)
X#else
Xvoid AddBonusBlock(display, window, row, col, type)
X	Display *display;
X	Window window;
X	int *row;
X	int *col;
X	int type;
X#endif
X{
X	int r, c;
X	struct aBlock *blockP;
X
X	/* Give me a new random block position */
X	r = rand() % (MAX_ROW - 4);
X	c = rand() % MAX_COL;
X
X	/* Pointer to the correct block we need - speed things up */
X	blockP = &blocks[r][c];
X
X	/* Add a bonus coin in this block only if it isn't occupied and 
X	 * it isn't exploding.
X	 */
X	if ((blockP->occupied == False) && (blockP->explodeStartFrame == 0))
X	{
X		AddNewBlock(display, window, r, c, type, 0);
X		bonusBlock = True;
X
X		/* Setup the block structure for new block */
X		blockP->nextFrame 		= frame + BONUS_DELAY;
X		blockP->lastFrame 		= frame + BONUS_LENGTH;
X		blockP->bonusSlide 		= 3;
X
X		/* Return the new bonus row & coloumn position */
X		*row = r; *col = c;
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic int GetRandomType(void)
X#else
Xstatic int GetRandomType()
X#endif
X{
X	/* This function will return a random new block block type */
X	switch (rand() % 7)
X	{
X		case 0:
X			return RED_BLK;
X
X		case 1:
X			return BLUE_BLK;
X
X		case 2:
X			return GREEN_BLK;
X
X		case 3:
X			return TAN_BLK;
X
X		case 4:
X			return YELLOW_BLK;
X
X		case 5:
X			return PURPLE_BLK;
X
X		case 6:
X			return BULLET_BLK;
X	}
X
X	/* Shouldn't get here but it stops warnings on compiler */
X	return YELLOW_BLK;
X}
X
X#if NeedFunctionPrototypes
Xvoid HandlePendingBonuses(Display *display, Window window, int type, 
X	int r, int c)
X#else
Xvoid HandlePendingBonuses(display, window, type, r, c)
X	Display *display;
X	Window window;
X	int type;
X	int r, c;
X#endif
X{
X	struct aBlock *blockP;
X
X	blockP = &blocks[r][c];
X
X	if (blockP->nextFrame == frame) 
X	{
X		if (frame <= blockP->lastFrame)
X		{
X			/* Advance to the next frame of animation */
X			DrawTheBlock(display, window, 
X				blockP->x, blockP->y, 
X				type, blockP->bonusSlide);
X
X				blockP->nextFrame = frame + BONUS_DELAY;
X				blockP->bonusSlide--;
X
X				if (blockP->bonusSlide < 0)
X				blockP->bonusSlide = 3;
X		}
X		else
X		{
X			/* Kill off bonus block */
X			bonusBlock = False;
X			blockP->occupied = False;
X			XClearArea(display, window, 
X				blockP->x, blockP->y,
X				blockP->width, blockP->height, 
X				False);
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid HandlePendingAnimations(Display *display, Window window)
X#else
Xvoid HandlePendingAnimations(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int r, c;
X	struct aBlock *blockP;
X
X	/* Cycle through all rows and columns and update any animations that
X	 * need to be done every frame. ie: bonus etc
X	 */
X	for (r = 0; r < MAX_ROW; r++)
X	{
X		for (c = 0; c < MAX_COL; c++)
X		{
X			blockP = &blocks[r][c];
X
X			/* Only bother if the block is occupied! */
X			if (blockP->occupied == True) 
X			{
X				switch (blockP->blockType)
X				{
X					case BONUS_BLK:	/* Bonus coin symbol */
X						HandlePendingBonuses(display, window, BONUS_BLK, r, c);
X						break;
X
X					case BONUSX2_BLK:	/* Bonus x2 coin symbol */
X						HandlePendingBonuses(display, window, BONUSX2_BLK, r,c);
X						break;
X
X					case BONUSX4_BLK:	/* Bonus x4 coin symbol */
X						HandlePendingBonuses(display, window, BONUSX4_BLK, r,c);
X						break;
X
X					case DEATH_BLK:	/* Death block animation */
X						if (blockP->nextFrame == frame) 
X						{
X							/* Advance to the next frame of animation */
X							DrawTheBlock(display, window, 
X								blockP->x, blockP->y, 
X								DEATH_BLK, blockP->bonusSlide);
X
X							blockP->nextFrame = frame + DEATH_DELAY1;
X							blockP->bonusSlide++;
X
X							/* Have the delay bit between winks */
X							if (blockP->bonusSlide > 4)
X							{
X								blockP->bonusSlide = 0;
X								blockP->nextFrame = frame + DEATH_DELAY2;
X								DrawTheBlock(display, window, 
X									blockP->x, blockP->y, 
X									DEATH_BLK, blockP->bonusSlide);
X							}
X						}
X						break;
X
X					case EXTRABALL_BLK:	/* extra ball block animation */
X						if (blockP->nextFrame == frame) 
X						{
X							/* Advance to the next frame of animation */
X							DrawTheBlock(display, window, 
X								blockP->x, blockP->y, 
X								EXTRABALL_BLK, blockP->bonusSlide);
X
X							blockP->nextFrame = frame + EXTRABALL_DELAY;
X							blockP->bonusSlide++;
X
X							/* Have the delay bit between flashes */
X							if (blockP->bonusSlide > 1)
X								blockP->bonusSlide = 0;
X						}
X						break;
X				}
X
X				/* If it is a random block then change? */
X				if (blockP->random == True)
X				{
X					if (blockP->nextFrame == frame) 
X					{
X						/* Change the block to a new block block. We should
X						 * be allright in just changing the blocktype etc.
X						 * as the blocks are all the same .
X						 */
X						blockP->blockType = GetRandomType();
X						blockP->bonusSlide = 0;
X
X						DrawTheBlock(display, window, 
X							blockP->x, blockP->y, 
X							blockP->blockType, blockP->bonusSlide);
X
X						blockP->nextFrame = 
X							frame + (rand() % RANDOM_DELAY) + 300;
X					}	
X				}
X			}
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid ExplodeBlocksPending(Display *display, Window window)
X#else
Xvoid ExplodeBlocksPending(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	int r, c, x, y, type;
X	struct aBlock *blockP;
X	char str[50];
X
X	/* If none are exploding then bug out */
X	if (blocksExploding == 0) return;
X
X	/* Cycle through all blocks exploding pending animation blocks */
X	for (r = 0; r < MAX_ROW; r++)
X	{
X		for (c = 0; c < MAX_COL; c++)
X		{
X			/* Get the pointer to the block we need */
X			blockP = &blocks[r][c];
X
X			/* Will be non-zero if animation is required */
X			if (blockP->explodeStartFrame)
X			{
X				/* Is it time to explode this frame */
X				if (blockP->explodeNextFrame == frame) 
X				{
X					x = blockP->x;
X					y = blockP->y;
X					type = blockP->blockType;
X
X					/* Switch on slide of animation */
X					switch (blockP->explodeSlide)
X					{
X						case 1:	/* First frame of animation */
X							ExplodeBlockType(display, window, x, y, type, 0);
X							blockP->explodeNextFrame =
X								blockP->explodeStartFrame;
X							break;
X	
X						case 2:	/* Second frame of animation */
X							ExplodeBlockType(display, window, x, y, type, 1);
X							break;
X	
X						case 3:	/* Third frame of animation */
X							ExplodeBlockType(display, window, x, y, type, 2);
X							break;
X	
X						case 4:	/* Last frame of animation  - clear */
X							XClearArea(display, window, x, y, 
X								blockP->width, 
X								blockP->height, False);
X							break;
X					}
X	
X					/* procede to next frame in animation */
X					blockP->explodeSlide++;
X					blockP->explodeNextFrame += EXPLODE_DELAY;
X	
X					/* last frame so clean up animation and block */
X					if (blockP->explodeSlide > 4)
X					{
X						blocksExploding--;
X						blockP->occupied = 0;
X						blockP->exploding = False;
X
X						AddToScore((u_long) blockP->hitPoints);
X						DisplayScore(display, scoreWindow, score);
X
X						switch (blockP->blockType)
X						{
X							case BLACK_BLK:
X							case PAD_SHRINK_BLK:
X							case PAD_EXPAND_BLK:
X								break;
X
X							case BOMB_BLK:
X								/* Explode all the ones around it */
X								SetBlockUpForExplosion(r+1, c, 
END_OF_FILE
  if test 31252 -ne `wc -c <'blocks.c1'`; then
    echo shar: \"'blocks.c1'\" unpacked with wrong size!
  fi
  # end of 'blocks.c1'
fi
echo shar: End of archive 5 \(of 26\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 26 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo "merging split files..."
    cat blocks.c[12] > blocks.c
    rm blocks.c[12]
    echo "blocks.c done"
    cat bitmaps/earth.xpm.Z.u.[ab] > bitmaps/earth.xpm.Z.uue
    rm bitmaps/earth.xpm.Z.u.[ab]
    echo "bitmaps/earth.xpm.Z.uue done"
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
