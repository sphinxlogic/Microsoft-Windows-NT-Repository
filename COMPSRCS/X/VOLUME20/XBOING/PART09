Newsgroups: comp.sources.x
From: jck@kimba.catt.citri.edu.au (Justin Kibell)
Subject: v20i116:  xboing - a simple blockout type game, Part09/26
Message-ID: <1993Sep3.123236.7290@sparky.sterling.com>
X-Md4-Signature: 238ed23b807b02c28a7d0a546b3751ff
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Fri, 3 Sep 1993 12:32:36 GMT
Approved: chris@sterling.com

Submitted-by: jck@kimba.catt.citri.edu.au (Justin Kibell)
Posting-number: Volume 20, Issue 116
Archive-name: xboing/part09
Environment: X11, xpm, color

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  main.c sounds/weeek.au.uue xab
# Wrapped by chris@sparky on Fri Sep  3 07:14:45 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 9 (of 26)."'
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
  echo shar: Extracting \"'main.c'\" \(22087 characters\)
  sed "s/^X//" >'main.c' <<'END_OF_FILE'
X#include "copyright.h"
X
X/*
X *  Include file dependencies:
X */
X
X#include <stdio.h>
X#include <stdlib.h>
X#include <stddef.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xos.h>
X#include <X11/keysym.h>
X
X#include "score.h"
X#include "presents.h"
X#include "special.h"
X#include "audio.h"
X#include "mess.h"
X#include "ball.h"
X#include "gun.h"
X#include "sfx.h"
X#include "init.h"
X#include "blocks.h"
X#include "level.h"
X#include "bonus.h"
X#include "stage.h"
X#include "paddle.h"
X#include "intro.h"
X#include "inst.h"
X#include "highscore.h"
X#include "keys.h"
X
X#include "main.h"
X
X/*
X *  Internal macro definitions:
X */
X
X#define PADDLE_ANIMATE_DELAY	5
X#define BONUS_SEED				2000	
X
X/*
X *  Internal type declarations:
X */
X
X#if NeedFunctionPrototypes
Xstatic KeySym 	GetKeySym(XEvent event);
Xstatic void 	handleGameMode(Display *display);
Xstatic void 	handleEventLoop(Display *display);
Xstatic void 	ToggleGamePaused(Display *display, Window window);
Xstatic void 	SetGamePaused(Display *display);
Xstatic void 	handleGameStates(Display *display);
Xstatic void 	sleepSync(Display *display, unsigned long ms);
X#else
Xstatic void 	sleepSync();
Xstatic void 	handleGameStates();
Xstatic KeySym 	GetKeySym();
Xstatic void 	handleGameMode();
Xstatic void 	handleEventLoop();
Xstatic void 	ToggleGamePaused();
Xstatic void 	SetGamePaused();
X#endif
X
X/*
X *  Internal variable declarations:
X */
X
X
Xint paddleMotion = 0;
Xint paddleDx = 0;
Xint speedLevel = 5;
Xint frame, gameActive;
Xint mode;
Xstatic int iconified = False;
Xlong speed;
Xstatic int userDelay = 1;
Xstatic int paddleControl;
Xstatic time_t pauseStartTime;
Xtime_t pausedTime;
X
X#if NeedFunctionPrototypes
Xvoid SetUserSpeed(int delay)
X#else
Xvoid SetUserSpeed(delay)
X	int delay;
X#endif
X{
X	int temp;
X
X	/* Set an entire game speedup or slowdown speed */
X	temp = (long) (speed / userDelay);
X	userDelay = delay;
X	speed = (long) (temp * userDelay);
X	speedLevel = 10 - delay;
X}
X
X#if NeedFunctionPrototypes
Xint GetPaddleControlMode(void)
X#else
Xint GetPaddleControlMode()
X#endif
X{
X	/* Get the paddle control mode */
X	return paddleControl;
X}
X
X#if NeedFunctionPrototypes
Xvoid SetPaddleControlMode(int type)
X#else
Xvoid SetPaddleControlMode(type)
X	int type;
X#endif
X{
X	/* Set the paddle control mode to the new mode */
X	paddleControl = type;
X}
X
X#if NeedFunctionPrototypes
Xvoid SetGameSpeed(int delay)
X#else
Xvoid SetGameSpeed(delay)
X	int delay;
X#endif
X{
X	/* This is the speed used in the sleeping routine */
X	if (delay >= 0)
X		speed = (long) (delay * userDelay);
X}
X
X#if NeedFunctionPrototypes
Xstatic void sleepSync(Display *display, unsigned long ms)
X#else
Xstatic void sleepSync(display, ms)
X	Display *display;
X	unsigned long ms;
X#endif
X{
X    struct timeval st, et;
X    long SyncTime;
X
X    gettimeofday(&st, NULL);
X    XSync(display, False);
X    gettimeofday(&et, NULL);
X
X    SyncTime = (((et.tv_sec - st.tv_sec) * 1000) +
X               ((et.tv_usec - st.tv_usec) / 1000) );
X
X    if ((ms) > ((1000 / 60) + SyncTime))
X        ms_sleep(ms - SyncTime);
X}
X
X#if NeedFunctionPrototypes
Xstatic KeySym GetKeySym(XEvent event)
X#else
Xstatic KeySym GetKeySym(event)
X	XEvent event;
X#endif
X{
X	int count;
X	char key;
X	KeySym keysym;
X	XComposeStatus compose;
X
X	/* Lookup a keysym using the event key */
X	count = XLookupString(&event.xkey, &key, 1, &keysym, &compose);
X
X	return keysym;
X}
X
X#if NeedFunctionPrototypes
Xint paddleIsMoving(void)
X#else
Xint paddleIsMoving()
X#endif
X{
X	/* Returns direction of paddle 1 right -1 left 0 stopped */
X	return paddleMotion;
X}
X
X#if NeedFunctionPrototypes
Xvoid handlePaddleMoving(Display *display)
X#else
Xvoid handlePaddleMoving(display)
X	Display *display;
X#endif
X{
X	static oldx = 0;
X	int rx, ry, x, y;
X	unsigned int mask;
X	Window root, child;
X
X	if (paddleControl == CONTROL_KEYS)
X	{
X		switch (paddleMotion)
X		{
X			case 1:		/* Move the paddle to the right 1 increment */
X				MovePaddle(display, playWindow, 
X					PADDLE_RIGHT, currentPaddleSize, 0);
X				break;
X
X			case -1:		/* Move the paddle to the left 1 increment */
X				MovePaddle(display, playWindow, 
X					PADDLE_LEFT, currentPaddleSize, 0);
X				break;
X
X			default:
X				break;
X		}
X	} else if (paddleControl == CONTROL_MOUSE)
X	{
X		/* Obtain the position of the pointer in the play window */
X		if (XQueryPointer(display, playWindow, &root, &child, 
X			&rx, &ry, &x, &y, &mask) == True)
X		{
X			/* Has the pointer moved since our last poll */
X			if (x != oldx)
X			{
X				paddleDx = x - oldx;
X
X				/* Move the paddle to the position of the mouse pointer */
X				MovePaddle(display, playWindow, 
X					PADDLE_NONE, currentPaddleSize, x);
X				oldx = x;
X
X				/* Adjust the paddle motion variable so the ball moves when in
X				 * the BALL_READY state and BALL_CREATE state.
X				 */
X				if (x > oldx)
X					paddleMotion = 1;
X				else
X					paddleMotion = -1;
X			}
X			else
X			{
X				/* Reset to no motion */
X				paddleMotion = 0;
X				paddleDx = 0;
X			}
X		}
X	}
X}
X
X
X#if NeedFunctionPrototypes
Xstatic void ToggleGamePaused(Display *display, Window window)
X#else
Xstatic void ToggleGamePaused(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	if (mode == MODE_PAUSE)
X	{
X		/* Finished pause resume game */
X		mode = MODE_GAME;
X		SetCurrentMessage(display, messWindow, "- Play ball -", False);
X		
X		/* How many seconds were we paused for? */
X		pausedTime += (time(NULL) - pauseStartTime);
X
X 		XSelectInput(display, mainWindow, 
X			KeyPressMask | KeyReleaseMask | ButtonPressMask |
X   			ButtonReleaseMask | ExposureMask | StructureNotifyMask);
X
X 		GrabPointer(display, window);
X	}
X	else 
X		SetGamePaused(display);
X}
X
X#if NeedFunctionPrototypes
Xstatic void SetGamePaused(Display *display)
X#else
Xstatic void SetGamePaused(display)
X	Display *display;
X#endif
X{
X	if (mode == MODE_GAME)
X	{
X		/* Set game to paused mode */
X		mode = MODE_PAUSE;
X		SetCurrentMessage(display, messWindow, 
X			"- Game paused -", False);
X		
X		/* we need to keep track of how long we were paused so that later
X		 * in the highscore thing I can take that off the time.
X		 */
X		pauseStartTime = time(NULL);
X
X		XSelectInput(display, mainWindow, 
X			KeyPressMask | ExposureMask | StructureNotifyMask);
X
X		UnGrabPointer(display);
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid handleIconify(Display *display, XUnmapEvent *event)
X#else
Xvoid handleIconify(display, event)
X	Display *display;
X	XUnmapEvent *event;
X#endif
X{
X	ToggleGamePaused(display, mainWindow);
X}
X
X#if NeedFunctionPrototypes
Xvoid SelectiveRedraw(Display *display)
X#else
Xvoid SelectiveRedraw(display)
X	Display *display;
X#endif
X{
X	switch (mode)
X	{
X		case MODE_GAME:
X		case MODE_PAUSE:
X			RedrawPlayWindow(display, playWindow);
X			break;
X
X		case MODE_INTRO:
X			RedrawIntroduction(display, playWindow);
X			break;
X
X		case MODE_INSTRUCT:
X			RedrawInstructions(display, playWindow);
X			break;
X
X		case MODE_KEYS:
X			RedrawKeys(display, playWindow);
X			break;
X
X		case MODE_BONUS:
X			RedrawBonus(display, mainWindow);
X			break;
X
X		case MODE_HIGHSCORE:
X			RedrawHighScore(display, playWindow);
X			break;
X
X		default:
X			break;
X	}
X
X	/* Redisplay the message and the level/score info */
X	RedrawLevelInfo(display, levelWindow);
X	DisplayCurrentMessage(display, messWindow);
X
X	/* To be sure - to be sure */
X	XFlush(display);
X}
X
X#if NeedFunctionPrototypes
Xvoid handleExposure(Display *display, XEvent event)
X#else
Xvoid handleExposure(display, event)
X	Display *display;
X	XEvent event;
X#endif
X{
X	/* Only redraw window once so wait until all expose events have sent
X	 * and then redraw all that we need to redraw based on current game
X	 * mode.
X	 */
X	if (event.xexpose.count == 0)
X		SelectiveRedraw(display);
X}
X
X#if NeedFunctionPrototypes
Xvoid handleMouseButtons(Display *display, XEvent event, int Down)
X#else
Xvoid handleMouseButtons(display, event, Down)
X	Display *display;
X	XEvent event;
X	int Down;
X#endif
X{
X	if (Down == True)
X	{
X		/* Button pressed down */
X		switch(event.xbutton.button)
X		{
X			/* Shoot a bullet */
X			case Button1:
X			case Button2: 
X			case Button3:
X				/* If we are playing the game and a ball needs to be started
X				 * then start it otherwise shoot a bullet.
X				 */
X				if (mode == MODE_GAME)
X					if (ActivateWaitingBall() == False)
X						shootBullet(display, playWindow);
X				break;
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid handleKeyPress(Display *display, KeySym keysym, int Pressed)
X#else
Xvoid handleKeyPress(display, keysym, Pressed)
X	Display *display;
X	KeySym keysym;
X	int Pressed;
X#endif
X{
X	int temp;
X
X	if (Pressed == False)
X	{
X		/* key was released */
X		paddleMotion = 0;
X	}
X	else
X	{
X		/* Switch on the key just pressed down */
X		switch (keysym)
X		{
X			case XK_Left:
X			case XK_j:
X			case XK_J:
X				/* Set paddle to move left */
X				if (mode == MODE_GAME)
X					paddleMotion = -1;
X				break;
X	
X			case XK_k:
X			case XK_K:
X				/* Shoot a bullet if available */
X				if (mode == MODE_GAME)
X					if (ActivateWaitingBall() == False)
X						shootBullet(display, playWindow);
X				break;
X	
X			case XK_Right:
X			case XK_l:
X			case XK_L:
X				/* Set paddle to move right */
X				if (mode == MODE_GAME)
X					paddleMotion = 1;
X				break;
X
X			case XK_Escape:
X				if (mode == MODE_GAME)
X				{
X					/* Abort game and return to intros */
X					SetGameSpeed(FAST_SPEED);
X					ResetIntroduction();
X					mode = MODE_INTRO;
X
X					SetCurrentMessage(display, messWindow, 
X						"Game aborted.", True);
X				}
X				break;
X
X            case XK_minus:
X                if (mode == MODE_GAME)
X                {
X                    SkipToNextLevel(display, playWindow);
X                    SetCurrentMessage(display, messWindow,
X                        "Skipping to next level ...", True);
X                }
X                break;
X
X			case XK_space:
X				if (mode == MODE_INTRO || mode == MODE_HIGHSCORE 
X				  || mode == MODE_INSTRUCT || mode == MODE_KEYS)
X				{
X					SetGameSpeed(FAST_SPEED);
X					gameActive = False;
X					mode = MODE_GAME;
X				}
X
X				if (mode == MODE_BONUS)
X					SetBonusWait(BONUS_FINISH, frame);
X				else if (mode == MODE_PRESENTS)	
X					QuickFinish(display, mainWindow);
X				break;
X
X
X			case XK_H:	/* Personal highscores */
X				if (mode == MODE_INTRO || mode == MODE_INSTRUCT 
X					|| mode == MODE_KEYS || mode == MODE_HIGHSCORE)
X				{
X					SetGameSpeed(FAST_SPEED);
X					ResetHighScore(PERSONAL);
X					mode = MODE_HIGHSCORE;
X
X					/* Play a bit of sound */
X					if (noSound == False)
X						playSoundFile("toggle", 50);
X					
X				}
X				break;
X
X			case XK_h:	/* Global highscores */
X				if (mode == MODE_INTRO || mode == MODE_INSTRUCT 
X					|| mode == MODE_KEYS || mode == MODE_HIGHSCORE)
X				{
X					SetGameSpeed(FAST_SPEED);
X					ResetHighScore(GLOBAL);
X					mode = MODE_HIGHSCORE;
X
X					/* Play a bit of sound */
X					if (noSound == False)
X						playSoundFile("toggle", 50);
X				}
X				break;
X
X			case XK_c:
X			case XK_C:
X				/* Cycle through the introduction screens if note in a game */
X				if (mode == MODE_INTRO)
X				{
X					SetGameSpeed(FAST_SPEED);
X					ResetInstructions();
X					mode = MODE_INSTRUCT;
X				} else if (mode == MODE_INSTRUCT)
X				{
X					SetGameSpeed(FAST_SPEED);
X					ResetKeys();
X					mode = MODE_KEYS;
X				} else if (mode == MODE_KEYS)
X				{
X					SetGameSpeed(FAST_SPEED);
X					ResetHighScore(GLOBAL);
X					mode = MODE_HIGHSCORE;
X				} else if (mode == MODE_HIGHSCORE)
X				{
X					SetGameSpeed(FAST_SPEED);
X					ResetIntroduction();
X					mode = MODE_INTRO;
X				} 
X				break;
X
X			case XK_a:
X			case XK_A:
X				if (noSound == False)
X				{
X					/* Try and turn audio off */
X					FreeAudioSystem();
X
X					noSound = True;
X					SetCurrentMessage(display, messWindow, 
X						"- Audio OFF -", True);
X				}
X				else
X				{
X					/* Try and turn audio on */
X					if (SetUpAudioSystem(display) == False)
X					{
X						/* Unable to turn audio on */
X						noSound = True;
X						SetCurrentMessage(display, messWindow, 
X							"- Audio unavailable -", True);
X					}
X					else
X					{
X						/* Audio is now active */
X						noSound = False;
X						SetCurrentMessage(display, messWindow, 
X							"- Audio ON -", True);
X					}
X				}
X				break;
X
X			case XK_s:
X			case XK_S:
X				if (mode == MODE_INTRO || mode == MODE_INSTRUCT 
X					|| mode == MODE_KEYS || mode == MODE_HIGHSCORE)
X				{
X					/* toggle the special effects system */
X					if (getSpecialEffects(display) == True)
X					{
X						/* Turn off special effects */
X						useSpecialEffects(False);
X
X						SetCurrentMessage(display, messWindow, 
X							"- SFX OFF -", True);
X					}
X					else
X					{
X						/* Cannot use sfx on this display */
X						if (getSpecialEffects(display) == -1)
X						{
X							SetCurrentMessage(display, messWindow, 
X								"- SFX Unavailable -", True);
X						}
X						else
X						{
X							/* Try and turn on special effects */
X							useSpecialEffects(True);
X
X							SetCurrentMessage(display, messWindow, 
X								"- SFX ON -", True);
X						}
X					}
X				}
X				break;
X
X			case XK_g:
X			case XK_G:
X				/* Toggle game mode */
X				if (GetPaddleControlMode() == CONTROL_KEYS)
X				{
X					SetCurrentMessage(display, messWindow, 
X						"Control: Mouse", True);
X					SetPaddleControlMode(CONTROL_MOUSE);
X				}
X				else
X				{
X					SetCurrentMessage(display, messWindow, 
X						"Control: Keys", True);
X					SetPaddleControlMode(CONTROL_KEYS);
X				}
X
X				/* Play a bit of sound */
X				if (noSound == False)
X					playSoundFile("toggle", 50);
X					
X				/* If looking at the keys screen then update the text
X				 * indicating which control mode you are using.
X				 */
X				if (mode == MODE_KEYS)
X					RedrawKeys(display, playWindow);
X
X				break;
X
X			case XK_p:
X			case XK_P:
X				ToggleGamePaused(display, mainWindow);
X				break;
X
X			case XK_i:
X			case XK_I:
X				/* Iconify the window quickly */
X				XIconifyWindow(display, mainWindow, 0);
X				break;
X
X			case XK_d:	
X			case XK_D:	
X				/* Kill the ball - why I don't know */
X				if (mode == MODE_GAME)
X				{
X					if ((temp = GetAnActiveBall()) >= 0)
X					{
X						/* Erase and reset ball to new one */
X						ClearBallNow(display, playWindow, temp);
X					}
X
X				}
X				break;
X
X			case XK_1:	/* Set speed to speed 1 */
X				SetUserSpeed(9);
X				SetCurrentMessage(display, messWindow, "Warp 1", True);
X				if (noSound == False) playSoundFile("tone1", 50);
X				break;
X
X			case XK_2:	/* Set speed to speed 2 */
X				SetUserSpeed(8);
X				SetCurrentMessage(display, messWindow, "Warp 2", True);
X				if (noSound == False) playSoundFile("tone2", 50);
X				break;
X
X			case XK_3:	/* Set speed to speed 3 */
X				SetUserSpeed(7);
X				SetCurrentMessage(display, messWindow, "Warp 3", True);
X				if (noSound == False) playSoundFile("tone3", 50);
X				break;
X
X			case XK_4:	/* Set speed to speed 4 */
X				SetUserSpeed(6);
X				SetCurrentMessage(display, messWindow, "Warp 4", True);
X				if (noSound == False) playSoundFile("tone4", 50);
X				break;
X
X			case XK_5:	/* Set speed to speed 5 */
X				SetUserSpeed(5);
X				SetCurrentMessage(display, messWindow, "Warp 5", True);
X				if (noSound == False) playSoundFile("tone5", 50);
X				break;
X
X			case XK_6:	/* Set speed to speed 6 */
X				SetUserSpeed(4);
X				SetCurrentMessage(display, messWindow, "Warp 6", True);
X				if (noSound == False) playSoundFile("tone6", 50);
X				break;
X
X			case XK_7:	/* Set speed to speed 7 */
X				SetUserSpeed(3);
X				SetCurrentMessage(display, messWindow, "Warp 7", True);
X				if (noSound == False) playSoundFile("tone7", 50);
X				break;
X
X			case XK_8:	/* Set speed to speed 8 */
X				SetUserSpeed(2);
X				SetCurrentMessage(display, messWindow, "Warp 8", True);
X				if (noSound == False) playSoundFile("tone8", 50);
X				break;
X
X			case XK_9:	/* Set speed to speed 9 */
X				SetUserSpeed(1);
X				SetCurrentMessage(display, messWindow, "Warp 9", True);
X				if (noSound == False) playSoundFile("tone9", 50);
X				break;
X
X			case XK_Q:
X			case XK_q:
X				if (mode == MODE_GAME || mode == MODE_BONUS)
X				{
X					/* Save out scores when quitting */
X					UpdateHighScores();
X				}
X
X				/* Shut down and exit game */
X				ShutDown(display, 0, "Thank you for playing XBoing.");
X				break;
X
X			default:
X				/* Do nothing */
X				break;
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void handleGameMode(Display *display)
X#else
Xstatic void handleGameMode(display)
X	Display *display;
X#endif
X{
X	static int bonusRow = 0;
X	static int bonusCol = 0;
X	static int nextBonusFrame = 0;
X
X	/* If we are going to play then setup first level */
X	if (gameActive == False)
X	{
X		/* Choose a random velocity for the ball */
X
X		/* Always start at level 1 or level specified */
X		SetLevelNumber(GetStartingLevel());
X
X		/* Set some important variables */
X		livesLeft 			= 3;
X		score 				= 0;
X		nextBonusFrame 		= 0;
X		currentPaddleSize 	= PADDLE_HUGE;
X		pausedTime			= 0;
X		bonusBlock 			= False;
X
X		/* Setup the stage and load 1st level */
X		SetupStage(display, playWindow);
X
X		/* Start game play */
X		gameActive = True;
X
X		/* Keep track of the game duration - shown in highscores */
X		gameTime = time(NULL);
X	}
X
X	/* If we need to move the paddle then do so */
X	if ((frame % PADDLE_ANIMATE_DELAY) == 0)
X		handlePaddleMoving(display);
X
X	if (mode == MODE_GAME)
X	{
X		HandleBallMode(display, playWindow);
X
X		/* Add bonus coin block at random intervals */
X		if (nextBonusFrame == 0 && bonusBlock == False)
X			nextBonusFrame = frame + (rand() % BONUS_SEED);
X
X		/* Do we need to add a bonus coin? */
X		if (nextBonusFrame <= frame && bonusBlock == False)
X		{
X			/* Add the bonus block now - different types */
X			switch (rand() % 10)
X			{
X				case 0: case 1: 
X				case 2: case 3: 
X				case 4: case 5: 
X				case 6: case 7:
X					/* Add a normal bonus block */
X					AddBonusBlock(display, playWindow, &bonusRow, &bonusCol, 
X						BONUS_BLK);
X					break;
X
X				case 8:
X					/* Add the x2 bonus block */
X					AddBonusBlock(display, playWindow, &bonusRow, &bonusCol, 
X						BONUSX2_BLK);
X					break;
X
X				case 9:
X					/* Add the x4 bonus block */
X					AddBonusBlock(display, playWindow, &bonusRow, &bonusCol, 
X						BONUSX4_BLK);
X					break;
X
X			}
X
X			nextBonusFrame = 0;
X		}
X	}
X
X	HandleBulletMode(display, playWindow);
X
X	/* If any blocks need exploding then do so */
X	ExplodeBlocksPending(display, playWindow);
X
X	/* So blocks need animation all the time so do it */
X	HandlePendingAnimations(display, playWindow);
X
X	/* See if the level is finished and update level info if needed */
X	if (mode == MODE_GAME)
X		CheckGameRules(display, playWindow);
X}
X
X#if NeedFunctionPrototypes
Xstatic void handleGameStates(Display *display)
X#else
Xstatic void handleGameStates(display)
X	Display *display;
X#endif
X{
X	/* Update the message window if any new messages come along */
X	DisplayCurrentMessage(display, messWindow);
X
X	/* In game effects */
X	switch (currentSfxMode())
X	{
X		case SFX_SHAKE:
X			/* Something exploded or bumped the screen */
X			WindowShakeEffect(display, playWindow);
X			break;
X
X		case SFX_NONE:
X		default:
X			break;
X	}
X
X	switch (mode)
X	{
X		case MODE_GAME:
X			handleGameMode(display);
X			break;
X
X		case MODE_PRESENTS:
X			Presents(display, mainWindow);
X			break;
X
X		case MODE_BONUS:
X			DoBonus(display, mainWindow);
X			break;
X
X		case MODE_INTRO:
X			Introduction(display, playWindow);
X			break;
X
X		case MODE_INSTRUCT:
X			Instructions(display, playWindow);
X			break;
X
X		case MODE_KEYS:
X			Keys(display, playWindow);
X			break;
X
X		case MODE_HIGHSCORE:
X			HighScore(display, playWindow);
X			break;
X
X		case MODE_PAUSE:
X			break;
X	}
X
X	/* Flush the display */
X	XFlush(display);
X}
X
X#if NeedFunctionPrototypes
Xstatic void handleEventLoop(Display *display)
X#else
Xstatic void handleEventLoop(display)
X	Display *display;
X#endif
X{
X	XEvent event;
X	int pending;
X	KeySym keysym;
X
X	pending = frame = 0;
X
X	/* Initial mode for game is Introduction */
X	mode = MODE_PRESENTS;
X
X	/* No special effects yet */
X	changeSfxMode(SFX_NONE);
X
X	/* Flush all events until app is fully mapped */
X    do
X	{
X		/* handle audio device events if they exist */
X		audioDeviceEvents();
X
X		/* Get the next event */
X		XNextEvent(display, &event);
X	}
X	while (event.type != MapNotify);
X
X	/* Grab the pointer to the main window */
X	GrabPointer(display, mainWindow);
X
X	/* Loop forever and ever */
X	while (True)
X	{
X		/* handle and audio device events if supported */
X		audioDeviceEvents();
X
X		/* Sleep a bit if not iconified */
X		if (iconified == False)
X			sleepSync(display, speed);
X
X		/* See if any events are waiting for me to handle */
X		if (iconified == False && mode != MODE_PAUSE)
X		{
X			/* Get an event but don't wait if none arrives */
X			pending = XPending(display);
X			frame++;
X		}
X		else
X		{
X			/* Wait here for an event and then get the number waiting */
X			XPeekEvent(display, &event);
X			pending = XPending(display);
X		}
X		
X		/* Handle any events pending */
X		while (pending > 0)
X		{
X			/* Get the next X event thanks */
X			XNextEvent(display, &event);
X
X			switch(event.type)
X			{
X				case UnmapNotify:
X					/* Turn off just all events except the mapping ones */
X    				XSelectInput(display, mainWindow, StructureNotifyMask);
X					handleIconify(display, (XUnmapEvent *) &event);
X					iconified = True;
X					break;
X
X				case MapNotify:
X					/* Turn back on all the events that are needed */
X    				XSelectInput(display, mainWindow, 
X						KeyPressMask | KeyReleaseMask | ButtonPressMask |
X       					ButtonReleaseMask | ExposureMask | StructureNotifyMask);
X
X					SelectiveRedraw(display);
X 					GrabPointer(display, mainWindow);
X					iconified = False;
X
X					break;
X
X				case ButtonRelease:
X					handleMouseButtons(display, event, False);
X					break;
X
X				case ButtonPress:
X					handleMouseButtons(display, event, True);
X					break;
X
X				case KeyRelease:
X					keysym = GetKeySym(event);
X					handleKeyPress(display, keysym, False);
X					break;
X
X				case KeyPress:
X					keysym = GetKeySym(event);
X					handleKeyPress(display, keysym, True);
X					break;
X
X				case Expose:
X					handleExposure(display, event);
X					break;
X
X				default:
X					break;
X			}
X
X			/* Decrement the number of pending events */
X			pending--;
X		}
X
X		/* handle all game states and animations */
X		if (iconified == False) 
X			handleGameStates(display);
X	}
X
X	/* NOT REACHED */
X}
X
X#if NeedFunctionPrototypes
Xvoid main(int argc, char **argv)
X#else
Xvoid main(argc, argv)
X	int argc;
X	char **argv;
X#endif
X{
X	static Display *display;
X
X	/* Initialise everything and return display */
X	display = InitialiseGame(argv, argc);
X
X	SetGameSpeed(FAST_SPEED);
X	gameActive = False;
X	iconified = False;
X
X	/* main event loop */
X	handleEventLoop(display);
X
X	/* NOTREACHED */
X}
END_OF_FILE
  if test 22087 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
  fi
  chmod +x 'main.c'
  # end of 'main.c'
fi
if test -f 'sounds/weeek.au.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'sounds/weeek.au.uue'\"
else
  echo shar: Extracting \"'sounds/weeek.au.uue'\" \(4799 characters\)
  sed "s/^X//" >'sounds/weeek.au.uue' <<'END_OF_FILE'
Xbegin 664 weeek.au
XM+G-N9    "    UG     0  'T     !          !S>O[W\^_LZ>CGY.+@
XMW^#BY.7FYN?J[>_S^?Y]>G=S<6]M;W-V=GA[?OSY^GUY>G=R;6IE85Y=7F!D
XM9VIJ;7!V?'_Z]O'MZ^GGY>'?W]_@XN3FY^GK[>_S]_KZ^WYY=7-R<W9V='5Z
XM?7Y_?WIU=75P;6IE7UU=75Y@8V9H:W!X?/[W\>[LZ>?DX=_=W=W>W^'CY>?I
XM[/#W_OY]>'-O;FYO<7-U>7W[^OO]?'=R<G%N:V=A7EQ<75Y@9&9I;7%W?/KO
XMZNGGY>3CX-[>WM_AY.?HZ.GJ[O/X_/W_>G=U=GAX>7M\?_[^_G][=F]M;6MH
XM96!=6UM<7E]B96AK;G)]^N_JZ>?EY.'?WMW=W=[@X^;EYNGL[O/X^_Y]=W1S
XM;V]O<W9Y>GM[>WUV<&]O;FIG85U<6UQ=7F%F:&IM<GWX[^KHY^7CX-[=W-S=
XMW^'CY.3EZ.WQ]/K_?7IV<W%O;G!W>W[__?S\?W=O;FYL:&9?7%I96EQ=8&9G
XM:6UR?/7NZNCGY.'?WMS;V]S=W^'CY>7H[/#U^/Q^>W=S<&]O<'1W>WQ]?GUX
XM;VQL;&MH96!<6UI;75YA9VEJ;W1^]N_JZ.?DX=_>W-O;W=[?X.'BX^;J[>_U
XM^?U\>'%N;&QL;G%T=WI\?GQQ;6UL:69D7UQ:65I<7F!F9VEO=_KQ[.?GY>+@
XMWMW<V]K<W=[?W^'BY>KN\?G^>W=T;FQL;&QO<G9Y>'EW;VMJ:VIG96!<65A9
XM7%U?9&AJ;'+]].WGY.+@WMW;V]K:W-W?W^#AXN3I[O3X_7MT<G%N;&UN;W-W
XM?'MW<6MH9VAF8V!<65A96EU>869H:VYU_?#KY.'@W][<V]K:VMO=WM[?X.+F
XMZ^[R]OG_=6]L:FEI:VYO=7IX<VQF9F9E8F)?6UA76%M>869J:FUS?^_LYN+A
XMX-_=VMG8V-K;W-[?X.'DZ.[V_7Q[=7%M:FIJ;&UO<WAV<FQG9F=H961A7%E7
XM5UI=7V5F:&IM>O3NZ>3@W][<VMC8V-G:V]W>WM_BY>KP^GUZ=&]M:6=H:&QO
XM=7=U;FAC8F5F9&%>6UA765M>86=J;&UN>?+LY^+@WMW<V=?6U]C9V]W>WN#E
XMZN[T_7MV=&]M:VII:FUR=W9O:&)@86)B8F!=6E=86UY@9&=I;&YT_O#JY-_>
XMWMS:U];6U]?9V]W?W^'DZ>_Z>W5R;VQI:&IK;&UQ=7%K9&!A9&)?7UU:6%=8
XM6UUA9VIL;G+^\NOGX=W;VMK8U];5UM?9W-W?X>7I[?'\=V]M;&IG9VAJ;&UP
XM;FIE86)A7EY>7%I75UE=7V-I;7!O<'GX[>CBWMS:V=C6U=;6U=;8V]W@Y.GM
XM]/QX;VMI:&=H:FUN;VYI8UY>7EU=7%I85E976EQ@9FUU=W9[^.[IXMW9U]?7
XMUM;5U=75U]C;WN/H[?+Y?WAO;&EH9F=J;7!M95Y<6EA65E975U=76%E;76%K
XM>?GQ[.GFXM_=VM?5T]'1T=/6V=K;W=_AY.CN^'MQ:VAF9FEL;FYI8UY;6%11
XM4%!14U176EQ=7V%F;GKX[>7?V]G8U=34T]+1T=+3U-;8V][BZ.[X?GAR;FMJ
XM:VQN;&9?7%E544]-34Y/4%-76EU?86AN=OKOY=[;V-;4TM'0S\_/S]?BS\W=
XMY>_GYOKHV-?:ULS+T'-*1#\[/#X]0D0X-C@T/5%4UK_)Q\G=P+2XMK>^PMM@
XM^,_#RG!94E+NWM'!T/;DYL.WN;U^,RHO1TY"+1\D*S!/:T]82%JTHZ&MRM"W
XMJ*O03T ^:G933SPX5<&]Q-?@OK*ZQL3%N:Z_/RDF5<8P'AHFZE0M)CZ[M+/ 
XML*JSK*RNQTO4Q=,X+$K3338^UK[*U[RXO;NUM+RZMK7T)2/1S!X;)2T_+"D[
XM2%>QJM_#IJ2IQL"ON<KB2T)68UDY.,W45];'P[ZYN+J\M+=7-S#P92$J,2(N
XM22DF3FU3R='1M*VNM;ROL+N\S]C!R6Y=Y=OXW6U3T-)NXNQC2SQ.:#<Y2S0W
XM>$0S4F9!;=A7;\G*WM'$S,S!R\^^OLK Q,_'Q]]LZ>]WY^;P4D3DV3Y-4#1$
XM5SHX0D8_4V9)5^E\YN3<W-S&T=*^P<*\O;Z[O,78W=[LS<S?U6! 4-=#-CPR
XM-#TZ/#U$7U57_%]LT]/Y_,W,SL'&Q;NWN[[ Q<K;Z6AOZ6WFZ'E>0UCN1$A+
XM0$M,4$9%7%-<6%IB5V_?;V;HY-O:V-GBU]K7T]',T,_-SL_.T]G4W.KO[/9M
XM:5Y:5E543DM+3$Q+3DU+3U555%A>9FE[].W?UM#-RLG'Q\7%Q<;(R,S3U];-
XMSUA'3$],2$18041,1TM&1TI53TQ-3_O0S.SLW-[/YFN]Q]7#O;V^N;^[R<Z[
XMQMY2/3@X1D<U-CE(0CY&/#@_94\_2E%TW\7"Q;*MLKJTL+6YN[FZNK/(3%/=
XM_CHS+R@L,3$G)3 W.#T\.4G O=;0N+*OKK&RKZFLM[*PK[2TK[S?/#M+."\I
XM(R,F*BDC*"XZ0#I/Y+^OM+BSK:FLKZVOKJVRM;JZMKFXU2\W3#XS*"8F)C,N
XM(RDM/#XY9F;1L+2YM*^HJZZJL:^KK[*]O+"\5#H\03PR*R,D+# J*"DN.CU,
XM3EG&MK:XM:VJK*NNLJRJK;*WL;A!2UD[.R\K)R0N+B4L*C W,U=,4+V]N[:T
XMJZZMJ:^MIZJMLK*P2T;01CHS+"DF*R\D)RPL,S$_3D;-N<*WLJVJKZBIK::I
XMJZNPPE-LST<R+B@J*"HH(B8J+C P/D]SO;ZZLJZFJJFDIZ.EIZB^[,3J73LL
XM*R8I+"(A)R,K+BTV.WK"S+BQKZ6FIJ*FH*&EI<;QN=A:.R@I)R<N'AXF("TN
XM*3@\V+G3LJZLGZ6DH**>H:FZW[W!93TI*"DG+1\=(2(N+"@T.MJYR;>NIY^B
XMH*"BGJ2VO,'#UD4T*B@L+20>'B0H+"TK.E;%NK^NIZ2>GZ&?IZNON+K17$4W
XM+RTK)A\A)2,I*"LU/L_&PZVGI)^?GZ>MJJ^TOMY</ST\+2@D(R@F*"@I-D!5
XMS\>PJ:2@I:NMKJNOO,QJ65U&.2PF+"PJ*R@M-T!N]N&RJ:6HKK*TK:ZXT5=G
XM[E1(+B8R,#(O*3,]2LK?V["JI:R[OKBSM<).0FUK3SXH+38S/"TL1%3+O<>T
XMK*JKOKR\O+?434I!3$XN+B\O.3HU.4[8NK6YKZZ\L;#+O<;SSU=!534O/3$N
XM-3<[7>W(N;VRL-2[L\^\SEW-24W9,C-!-3L].TG;R+JUP[R\QKJ^\NIP[?4_
XM2C<S/3HZ.3YOPKVWN;K!N;+0P<U8V.9 4#HN1C0O/3A"P\+!M,*]M[:^P<YM
XMT=9'2$,M/CPN/#E"O,#+M<7-K;3+N]MHN7A <"\R5"\O03?JMN;&OTZPKOF_
XMV$JXSS]?,3=^.#-*2<6OR,3?V*NZT^1"UL)'2"XL5#PW/3_/L;6_\]*LK[K[
XM0\C'5U J+4\W/CXZR[>WW52_MZZ^/=_*8,TW*D4_2ME"?;+ S\/5QK3)2^!2
XM/O(S+4,Y?[Y5S+]IM+CFP-;9OD8V2S@]3T9JQ\#+6L:\Q<-,>=D[4D0N5L_3
XMQNI?R[G!V&U*U-TV.D1 O\!4SU;6K/]0TDK8:#(Y0UV]S4_7XKNR6WWFZ\P[
XM,SY&RL5=9/K:K\Q&RFO,WR\_1EVYVT[8<+RS1WC5;,@V,DD_Q,-)[N_=KN!'
XMQ6+.7"U&0V&W7D_.:;:X/\W0Y<LR.E1(N<I TVS'KT)4Q5O+.B]20<&[/7G>
XMVJQ:0KYJQTTM3D?.LT),TNBNV#K&YLY8+4)*UK!,0,W<K\,XSLS3:"X\4-^P
XM5SG0W++ ->')VFDO.5+>KV4VU-"ROC;WQ=%V,3A3SZYQ--[&L,(W6\?,7# U
XM3,FN73/NOZ_%.5S$RE\P-$[#KU$P8;ROT3=6Q<A9,#52NJY),6NVKN W7,7'
XM6"\U6K2O/C%MLZYB-ES+QE$O-%RPL3LQ?:^N43I=T,)7+S1KK;,W,O"OL5 \
XM3-V_6S$S^JNW-S3RK[-=/T#UOF@U,^*KO#LX?+.VZD,Y6\'_.3/CKL-$/V:Z
XMNLQ,-U#*WD4YWK?/6D]DR<#$6SI)Y^Q21MG(<W[Y^=G.R&Q#4%IA7F3)TU=O
XMX=;4V-=72UU965%FR-1=9OS:T,S44DM87FY=;-7F:_;IXM[0U5]66%9H:??6
XMZ6=D;^[FV-Y?5EIA^?7PW^UM;_7L\^3>=F-H8FW^^^_N=&=L_.SBWNM\?GIS
XM>G=W>W-I96M[[>7G[_=]<')R<7MW;&AH=^WIZNWR^7AX=G?X^7EM:7;Q[.KL
XM\OMX=&]O???^<6QT^^_IZNWU>'%L;'WY_7MN;WG][^OO^'EN:FMX^/3U_G[_
XM^^SHZ^WZ<FIG;WW^_'MT<W3Z[NSL]7EN;7?\^/7W_/[\]?#N[_5]<F]P=7O]
XM^??W^/G[^_GW^GIQ<7-U>_OU\N_R^O[[]?9_>'1Q;W)X>_W[_7U^_?K[_O[]
XM_/O]_OW[]_3W_/W\_7QZ>GU^>W5R=O_Y^?S\_/Q]>7Q__OU_>GO\^/G[^/?\
XK?7=U=GAZ>GW^_/O^??SX^GUW>7W__?]_^?3U^?[[^/G^>GK__GUY=WW]_O?\
X 
Xend
END_OF_FILE
  if test 4799 -ne `wc -c <'sounds/weeek.au.uue'`; then
    echo shar: \"'sounds/weeek.au.uue'\" unpacked with wrong size!
  fi
  # end of 'sounds/weeek.au.uue'
fi
if test -f 'xab' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xab'\"
else
  echo shar: Extracting \"'xab'\" \(24327 characters\)
  sed "s/^X//" >'xab' <<'END_OF_FILE'
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r, c+1, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r-1, c, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r, c-1, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r-1, c-1, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r-1, c+1, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r+1, c-1, 
X									frame + EXPLODE_DELAY);
X								SetBlockUpForExplosion(r+1, c+1, 
X									frame + EXPLODE_DELAY);
X
X								/* Special effect where screen shakes 
X								 * during explosion 
X								 */
X								SetSfxEndFrame(frame + 70);
X								changeSfxMode(SFX_SHAKE);
X								break;
X
X							case BULLET_BLK:
X								SetCurrentMessage(display, messWindow, 
X									"More ammunition, cool!", True);
X								AddABullet(display);
X								AddABullet(display);
X								AddABullet(display);
X								AddABullet(display);
X								break;
X
X							case BONUS_BLK:
X								IncNumberBonus();
X
X								if (GetNumberBonus() <= MAX_BONUS)
X									sprintf(str, 
X										"- Bonus #%d -", GetNumberBonus());
X								else
X									sprintf(str, "- Super Bonus -");
X
X								SetCurrentMessage(display, messWindow, str, 
X									True);
X								bonusBlock = False;
X
X								/* Turn on killer mode after 10 bonuses */
X								if (GetNumberBonus() == 10)
X								{
X									/* Turn on killer mode */
X									ToggleKiller(display, True);
X									DrawSpecials(display);
X
X									SetCurrentMessage(display, messWindow, 
X										"- Killer Mode -", True);
X								}
X								break;
X
X							case BONUSX2_BLK:
X								Togglex2Bonus(display, True);
X								Togglex4Bonus(display, False);
X								DrawSpecials(display);
X
X								bonusBlock = False;
X								SetCurrentMessage(display, messWindow, 
X									"- x2 Bonus -", True);
X								break;
X
X							case BONUSX4_BLK:
X								Togglex2Bonus(display, False);
X								Togglex4Bonus(display, True);
X								DrawSpecials(display);
X
X								bonusBlock = False;
X								SetCurrentMessage(display, messWindow, 
X									"- x4 Bonus -", True);
X								break;
X
X							default :
X								break;
X						}
X
X						/* Reset to a non exploding block */
X						ClearBlock(r, c);
X					}
X				}
X			}
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid DrawTheBlock(Display *display, Window window, int x, int y, 
X	int blockType, int slide)
X#else
Xvoid DrawTheBlock(display, window, x, y, blockType, slide)
X	Display *display;
X	Window window;
X	int x;
X	int y; 
X	int blockType;
X	int slide;
X#endif
X{
X	switch(blockType)
X	{
X		case PAD_SHRINK_BLK:	/* Paddle shrink block */
X			RenderShape(display, window, paddleshrink,
X				paddleshrinkM, x, y, 40, 15, True);
X			break;
X
X		case PAD_EXPAND_BLK:	/* Paddle expand block */
X			RenderShape(display, window, paddleexpand,
X				paddleexpandM, x, y, 40, 15, True);
X			break;
X
X		case BULLET_BLK:	/* Draw a bullet shape */
X			RenderShape(display, window, yellowblock, yellowblockM, 
X				x, y, 40, 20, True);
X			DrawTheBullet(display, window, x+6, y+10);
X			DrawTheBullet(display, window, x+15, y+10);
X			DrawTheBullet(display, window, x+24, y+10);
X			DrawTheBullet(display, window, x+33, y+10);
X			break;
X
X		case MULTIBALL_BLK:	/* Draw multiple ball block */
X			RenderShape(display, window, multiball, multiballM, 
X				x, y, 40, 20, True);
X			break;
X
X		case STICKY_BLK:	/* Draw sticky block */
X			RenderShape(display, window, sticky, stickyM, 
X				x, y, 32, 32, True);
X			break;
X
X		case RED_BLK:	/* Draw a red block shape */
X			RenderShape(display, window, redblock, redblockM, 
X				x, y, 40, 20, True);
X			break;
X
X		case BLACK_BLK:		/* Draw a solid wall block */	
X			RenderShape(display, window, blackblock, blackblockM, 
X				x, y, 50, 30, True);
X			break;
X
X		case GREEN_BLK:		/* Draw a green block */
X			RenderShape(display, window, greenblock, greenblockM, 
X				x, y, 40, 20, True);
X			break;
X
X		case BLUE_BLK:		/* Draw a blue block */
X			RenderShape(display, window, blueblock, blueblockM, 
X				x, y, 40, 20, True);
X			break;
X
X		case YELLOW_BLK:	/* Draw a yellow block */
X			RenderShape(display, window, yellowblock, yellowblockM, 
X				x, y, 40, 20, True);
X			break;
X
X		case TAN_BLK:		/* Draw a tan block */
X			RenderShape(display, window, tanblock, tanblockM, 
X				x, y, 40, 20, True);
X			break;
X
X		case PURPLE_BLK:	/* Draw a purple block */
X			RenderShape(display, window, purpleblock, purpleblockM, 
X				x, y, 40, 20, True);
X			break;
X
X		case COUNTER_BLK:	/* Draw a frame of counter block */
X			RenderShape(display, window, counterblock[slide], 
X				counterblockM[slide], x, y, 40, 20, True);
X			break;
X
X		case BONUSX2_BLK:	/* Draw a bonus x2 coin block */
X			RenderShape(display, window, x2bonus[slide], 
X				x2bonusM[slide], x, y, 27, 27, True);
X			break;
X
X		case BONUSX4_BLK:	/* Draw a bonus x4 coin block */
X			RenderShape(display, window, x4bonus[slide], 
X				x4bonusM[slide], x, y, 27, 27, True);
X			break;
X
X		case BONUS_BLK:	/* Draw a bonus coin block */
X			RenderShape(display, window, Bonus[slide], 
X				BonusM[slide], x, y, 27, 27, True);
X			break;
X
X		case BOMB_BLK:		/* Draw a bomb block */
X			RenderShape(display, window, bombblock, bombblockM, 
X				x, y, 30, 30, True);
X			break;
X
X		case DEATH_BLK:		/* Draw the pirate death block */
X			RenderShape(display, window, death[slide], deathM[slide], 
X				x, y, 30, 30, True);
X			break;
X
X		case REVERSE_BLK:	/* Draw the reverse block */
X			RenderShape(display, window, revblock, revblockM, 
X				x, y, 33, 16, True);
X			break;
X
X		case EXTRABALL_BLK:	/* Draw the extra ball block */
X			RenderShape(display, window, extraball[slide], extraballM[slide], 
X				x, y, 30, 19, True);
X			break;
X
X		case HYPERSPACE_BLK:	/* Draw the hyperspace block */
X			RenderShape(display, window, hyperblock, hyperblockM, 
X				x, y, 31, 31, True);
X			break;
X
X		case MGUN_BLK:	/* Draw the machine gun block */
X			RenderShape(display, window, mgunblock, mgunblockM, 
X				x, y, 35, 15, True);
X			break;
X
X		case WALLOFF_BLK:	/* Draw the wall off block */
X			RenderShape(display, window, walloffblock, walloffblockM, 
X				x, y, 27, 23, True);
X			break;
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void SetBlockUpForExplosion(int row, int col, int frame)
X#else
Xstatic void SetBlockUpForExplosion(row, col, frame)
X	int row;
X	int col;
X	int frame;
X#endif
X{
X    struct aBlock *blockP;
X
X	if (row < 0 || row >= MAX_ROW) return;
X	if (col < 0 || col >= MAX_COL) return;
X
X	/* Obtain a pointer to the affected block */
X	blockP = &blocks[row][col];
X
X	/* Do not have any effect on a specials block */
X	if (blockP->blockType == HYPERSPACE_BLK) return;
X
X	/* If it isn't occupied then why blow it up */
X	if (blockP->occupied == 1 && blockP->exploding == False)
X	{
X		/* Keep track of how many blocks are exploding */
X		blocksExploding++;
X
X		/* Some special variables used for timing */
X		blockP->explodeStartFrame 	= frame;
X		blockP->explodeNextFrame 	= frame;
X		blockP->explodeSlide 		= 1;
X		blockP->exploding 			= True;
X	}
X}
X
X
X#if NeedFunctionPrototypes
Xvoid DrawBlock(Display *display, Window window, int row, int col, int blockType)
X#else
Xvoid DrawBlock(display, window, row, col, blockType)
X	Display *display;
X	Window window;
X	int row;
X	int col;
X	int blockType;
X#endif
X{
X	struct aBlock *blockP;
X
X	if (row < 0 || row > MAX_ROW) 
X	{
X		ErrorMessage("Block out of bounds row.");
X		return;
X	}
X
X	if (col < 0 || col > MAX_COL) 
X	{
X		ErrorMessage("Block out of bounds column.");
X		return;
X	}
X
X	/* Pointer to the block in question */
X	blockP = &blocks[row][col];
X
X	switch(blockType)
X	{
X		case KILL_BLK:		/* Special block - blow it up */
X			PlaySoundForBlock(blockP->blockType);
X
X			if (blockP->blockType != BLACK_BLK)
X				SetBlockUpForExplosion(row, col, frame);
X			break;
X
X		default:			/* Your average block - draw it */
X			DrawTheBlock(display, window, blockP->x, blockP->y, 
X				blockType, blockP->counterSlide);
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid FreeBlockPixmaps(Display *display)
X#else
Xvoid FreeBlockPixmaps(display)
X	Display *display;
X#endif
X{
X	int i;
X
X	/* Free the memory associated with the block pixmaps */
X	if (redblock)		XFreePixmap(display, redblock);			
X	if (redblockM)		XFreePixmap(display, redblockM);
X	if (blueblock)		XFreePixmap(display, blueblock);		
X	if (blueblockM)		XFreePixmap(display, blueblockM);
X	if (greenblock)		XFreePixmap(display, greenblock);		
X	if (greenblockM)	XFreePixmap(display, greenblockM);
X	if (tanblock)		XFreePixmap(display, tanblock);			
X	if (tanblockM)		XFreePixmap(display, tanblockM);
X	if (yellowblock)	XFreePixmap(display, yellowblock);		
X	if (yellowblockM)	XFreePixmap(display, yellowblockM);
X	if (purpleblock)	XFreePixmap(display, purpleblock);		
X	if (purpleblockM)	XFreePixmap(display, purpleblockM);
X	if (blackblock)		XFreePixmap(display, blackblock);		
X	if (blackblockM)	XFreePixmap(display, blackblockM);
X	if (bombblock)		XFreePixmap(display, bombblock);		
X	if (bombblockM)		XFreePixmap(display, bombblockM);
X	if (revblock)		XFreePixmap(display, revblock);		
X	if (revblockM)		XFreePixmap(display, revblockM);
X	if (hyperblock)		XFreePixmap(display, hyperblock);		
X	if (hyperblockM)	XFreePixmap(display, hyperblockM);
X	if (mgunblock)		XFreePixmap(display, mgunblock);		
X	if (mgunblockM)		XFreePixmap(display, mgunblockM);
X	if (walloffblock)	XFreePixmap(display, walloffblock);		
X	if (walloffblockM)	XFreePixmap(display, walloffblockM);
X	if (multiball)		XFreePixmap(display, multiball);		
X	if (multiballM)		XFreePixmap(display, multiballM);
X	if (sticky)			XFreePixmap(display, sticky);		
X	if (stickyM)		XFreePixmap(display, stickyM);
X	if (paddleexpand)	XFreePixmap(display, paddleexpand);		
X	if (paddleexpandM)	XFreePixmap(display, paddleexpandM);
X	if (paddleshrink)	XFreePixmap(display, paddleshrink);		
X	if (paddleshrinkM)	XFreePixmap(display, paddleshrinkM);
X
X	for (i = 0; i < 5; i++)
X	{
X		/* Free the frames for the death block */
X		if (death[i])	XFreePixmap(display, death[i]); 	
X		if (deathM[i])	XFreePixmap(display, deathM[i]);
X	}
X
X	for (i = 0; i < 6; i++)
X	{
X		if (counterblock[i])	XFreePixmap(display, counterblock[i]); 	
X		if (counterblockM[i])	XFreePixmap(display, counterblockM[i]);
X	}
X
X	for (i = 0; i < 4; i++)
X	{
X		if (x2bonus[i])			XFreePixmap(display, x2bonus[i]); 	
X		if (x2bonusM[i])		XFreePixmap(display, x2bonusM[i]);
X
X		if (x4bonus[i])			XFreePixmap(display, x4bonus[i]); 	
X		if (x4bonusM[i])		XFreePixmap(display, x4bonusM[i]);
X
X		if (Bonus[i])			XFreePixmap(display, Bonus[i]); 	
X		if (BonusM[i])			XFreePixmap(display, BonusM[i]);
X	}
X
X	for (i = 0; i < 2; i++)
X	{
X		if (extraball[i])		XFreePixmap(display, extraball[i]); 	
X		if (extraballM[i])		XFreePixmap(display, extraballM[i]);
X	}
X
X	for (i = 0; i < 3; i++)
X	{
X		if (exgreenblock[i])   	XFreePixmap(display, exgreenblock[i]); 	
X		if (exgreenblockM[i])   XFreePixmap(display, exgreenblockM[i]);
X
X		if (exyellowblock[i])   XFreePixmap(display, exyellowblock[i]);
X		if (exyellowblockM[i])  XFreePixmap(display, exyellowblockM[i]);
X
X		if (exredblock[i])     	XFreePixmap(display, exredblock[i]);
X		if (exredblockM[i])     XFreePixmap(display, exredblockM[i]);
X
X		if (exblueblock[i])     XFreePixmap(display, exblueblock[i]);
X		if (exblueblockM[i])    XFreePixmap(display, exblueblockM[i]);
X
X		if (extanblock[i])     	XFreePixmap(display, extanblock[i]);
X		if (extanblockM[i])     XFreePixmap(display, extanblockM[i]);
X
X		if (excounterblock[i])  XFreePixmap(display, excounterblock[i]);
X		if (excounterblockM[i]) XFreePixmap(display, excounterblockM[i]);
X
X		if (exbombblock[i])     XFreePixmap(display, exbombblock[i]);
X		if (exbombblockM[i])    XFreePixmap(display, exbombblockM[i]);
X		
X		if (expurpleblock[i])   XFreePixmap(display, expurpleblock[i]);
X		if (expurpleblockM[i])  XFreePixmap(display, expurpleblockM[i]);
X		
X		if (exx2bonus[i])     	XFreePixmap(display, exx2bonus[i]);
X		if (exx2bonusM[i])     	XFreePixmap(display, exx2bonusM[i]);
X
X		if (exdeath[i])			XFreePixmap(display, exdeath[i]); 	
X		if (exdeathM[i])		XFreePixmap(display, exdeathM[i]);
X	}
X}
X
X#if NeedFunctionPrototypes
Xstatic void CalculateBlockGeometry(int row, int col)
X#else
Xstatic void CalculateBlockGeometry(row, col)
X	int row, col;
X#endif
X{
X	struct aBlock *blockP;
X	XPoint points[4];
X	int halfWidth, halfHeight;
X
X	/* Pointer to the correct block we need - speed things up */
X	blockP = &blocks[row][col];
X
X	switch (blockP->blockType)
X	{
X		case COUNTER_BLK:
X			blockP->width 			= BLOCK_WIDTH;
X			blockP->height			= BLOCK_HEIGHT;
X			blockP->blockOffsetX	= (colWidth - BLOCK_WIDTH) / 2;
X			blockP->blockOffsetY 	= (rowHeight - BLOCK_HEIGHT) / 2;
X			break;
X
X		case MGUN_BLK:
X			blockP->width 			= 35;
X			blockP->height			= 15;
X			blockP->blockOffsetX	= (colWidth - 35) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 15) / 2;
X			break;
X
X		case WALLOFF_BLK:
X			blockP->width 			= 27;
X			blockP->height			= 23;
X			blockP->blockOffsetX	= (colWidth - 27) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 23) / 2;
X			break;
X
X		case REVERSE_BLK:
X			blockP->width 			= 33;
X			blockP->height			= 16;
X			blockP->blockOffsetX	= (colWidth - 33) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 16) / 2;
X			break;
X
X		case EXTRABALL_BLK:
X			blockP->width 			= 30;
X			blockP->height			= 19;
X			blockP->blockOffsetX	= (colWidth - 30) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 19) / 2;
X			break;
X
X		case HYPERSPACE_BLK:
X			blockP->width 			= 31;
X			blockP->height			= 31;
X			blockP->blockOffsetX	= (colWidth - 31) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 31) / 2;
X			break;
X
X		case BOMB_BLK:
X		case DEATH_BLK:
X			blockP->width 			= 30;
X			blockP->height			= 30;
X			blockP->blockOffsetX	= (colWidth - 30) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 30) / 2;
X			break;
X
X		case STICKY_BLK:
X			blockP->width 			= 32;
X			blockP->height			= 32;
X			blockP->blockOffsetX	= (colWidth - 32) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 32) / 2;
X			break;
X
X		case BLACK_BLK:
X			blockP->width 			= 50;
X			blockP->height			= 30;
X			blockP->blockOffsetX	= (colWidth - 50) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 30) / 2;
X			break;
X
X        case PAD_SHRINK_BLK:
X		case PAD_EXPAND_BLK:
X			blockP->width 			= 40;
X			blockP->height			= 15;
X			blockP->blockOffsetX	= (colWidth - 40) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 15) / 2;
X			break;
X
X		case BONUS_BLK:
X		case BONUSX4_BLK:
X		case BONUSX2_BLK:
X			blockP->width 			= 27;
X			blockP->height			= 27;
X			blockP->blockOffsetX	= (colWidth - 27) / 2;
X			blockP->blockOffsetY 	= (rowHeight - 27) / 2;
X			break;
X
X		default:		/* All other blocks */
X			blockP->width 			= BLOCK_WIDTH;
X			blockP->height			= BLOCK_HEIGHT;
X			blockP->blockOffsetX	= (colWidth - BLOCK_WIDTH) / 2;
X			blockP->blockOffsetY 	= (rowHeight - BLOCK_HEIGHT) / 2;
X			break;
X
X	}	
X
X	/* Calculate the offset within the block grid */
X	blockP->x = (col * colWidth) + blockP->blockOffsetX;
X	blockP->y = (row * rowHeight) + blockP->blockOffsetY;
X
X	/* Used below */
X	halfWidth = blockP->x + (blockP->width / 2);
X	halfHeight = blockP->y + (blockP->height / 2);
X
X	/* Create the XPoint array for the top region */
X	points[0].x = blockP->x;
X	points[0].y = blockP->y;
X	points[1].x = halfWidth;
X	points[1].y = halfHeight;
X	points[2].x = blockP->x + blockP->width;
X	points[2].y = blockP->y;
X	points[3].x = points[0].x;
X	points[3].y = points[0].y;
X
X	/* Create the top region for the block */
X    blockP->regionTop = XPolygonRegion(points, 4, EvenOddRule);
X
X	/* Create the XPoint array for the bottom region */
X	points[0].x = blockP->x;
X	points[0].y = blockP->y + blockP->height;
X	points[1].x = halfWidth;
X	points[1].y = halfHeight;
X	points[2].x = blockP->x + blockP->width;
X	points[2].y = points[0].y;
X	points[3].x = points[0].x;
X	points[3].y = points[0].y;
X
X	/* Create the bottom region for the block */
X    blockP->regionBottom = XPolygonRegion(points, 4, EvenOddRule);
X
X	/* Create the XPoint array for the left region */
X	points[0].x = blockP->x;
X	points[0].y = blockP->y;
X	points[1].x = halfWidth;
X	points[1].y = halfHeight;
X	points[2].x = blockP->x;
X	points[2].y = blockP->y + blockP->height;
X	points[3].x = points[0].x;
X	points[3].y = points[0].y;
X
X	/* Create the left region for the block */
X    blockP->regionLeft = XPolygonRegion(points, 4, EvenOddRule);
X
X	/* Create the XPoint array for the right region */
X	points[0].x = blockP->x + blockP->width;
X	points[0].y = blockP->y;
X	points[1].x = halfWidth;
X	points[1].y = halfHeight;
X	points[2].x = points[0].x;
X	points[2].y = blockP->y + blockP->height;
X	points[3].x = points[0].x;
X	points[3].y = points[0].y;
X
X	/* Create the right region for the block */
X    blockP->regionRight = XPolygonRegion(points, 4, EvenOddRule);
X}
X
X#if NeedFunctionPrototypes
Xvoid AddNewBlock(Display *display, Window window, int row, int col,
X	int blockType, int counterSlide)
X#else
Xvoid AddNewBlock(display, window, row, col, blockType, counterSlide)
X	Display *display;
X	Window window;
X	int row;
X	int col;
X	int blockType;
X	int counterSlide;
X#endif
X{
X	struct aBlock *blockP;
X
X	if (row > MAX_ROW || row < 0) return;
X	if (col > MAX_COL || col < 0) return;
X
X	/* Pointer to the block we want */
X	blockP = &blocks[row][col];
X
X	/* Now set the block structure with new values */
X	blockP->blockType 		= blockType;
X	blockP->occupied 		= 1;
X	blockP->counterSlide 	= counterSlide;
X
X	/* Handle the special case for a random block */
X	if (blockType == RANDOM_BLK)
X	{
X		/* Setup the random block so it has a next frame and new type */
X		blockP->random 	  = True;
X		blockP->blockType = RED_BLK;
X		blockP->nextFrame = frame + 1;
X	}
X
X	/* Work out all the block geometry stuff */
X	CalculateBlockGeometry(row, col);
X	
X	/* Add the number of points that will be awarded for each block */
X	switch(blockType)
X	{
X		case BULLET_BLK:
X			blockP->hitPoints = 50;
X			break;
X
X		case RED_BLK:
X			blockP->hitPoints = 100;
X			break;
X
X		case GREEN_BLK:
X			blockP->hitPoints = 120;
X			break;
X
X		case BLUE_BLK:
X			blockP->hitPoints = 110;
X			break;
X
X		case TAN_BLK:
X			blockP->hitPoints = 130;
X			break;
X
X		case YELLOW_BLK:
X			blockP->hitPoints = 140;
X			break;
X
X		case PURPLE_BLK:
X			blockP->hitPoints = 150;
X			break;
X
X		case BOMB_BLK:
X			blockP->hitPoints = 50;
X			break;
X
X		case COUNTER_BLK:
X			blockP->hitPoints = 200;
X			break;
X
X		case EXTRABALL_BLK:
X			blockP->nextFrame = frame + EXTRABALL_DELAY;
X			blockP->hitPoints = 100;
X			break;
X
X		case HYPERSPACE_BLK:
X		case MGUN_BLK:
X		case WALLOFF_BLK:
X		case REVERSE_BLK:
X		case MULTIBALL_BLK:
X		case STICKY_BLK:
X        case PAD_SHRINK_BLK:
X		case PAD_EXPAND_BLK:
X			blockP->hitPoints = 100;
X			break;
X
X		case DEATH_BLK:
X			blockP->hitPoints = -1000;
X			blockP->nextFrame = frame + DEATH_DELAY2;
X			break;
X
X		default:
X			break;
X	}
X
X	/* Draw the blocks please */
X	DrawBlock(display, window, row, col, blockType);
X}
X
X#if NeedFunctionPrototypes
Xvoid SkipToNextLevel(Display *display, Window window)
X#else
Xvoid SkipToNextLevel(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X    struct aBlock *blockP;
X	int r, c;
X
X	/* This will kill all blocks that need to go before next level can
X	 * be reached. Used in debug mode and maybe in special bonus mode.
X	 */
X
X	for (r = 0; r < MAX_ROW; r++)
X		for (c = 0; c < MAX_COL; c++)
X		{
X			/* Pointer to the block we want */
X			blockP = &blocks[r][c];
X
X			if (blockP->occupied == True) 
X			{
X				switch (blockP->blockType)
X				{
X					case BONUSX2_BLK:
X					case BONUSX4_BLK:
X					case BONUS_BLK:
X					case BLACK_BLK:
X					case BULLET_BLK:
X					case BOMB_BLK:
X					case DEATH_BLK:
X					case REVERSE_BLK:
X					case HYPERSPACE_BLK:
X					case EXTRABALL_BLK:
X					case MGUN_BLK:
X					case WALLOFF_BLK:
X					case MULTIBALL_BLK:
X					case STICKY_BLK:
X        			case PAD_SHRINK_BLK:
X					case PAD_EXPAND_BLK:
X						break;
X
X					default:
X						DrawBlock(display, window, r, c, KILL_BLK);
X						break;
X				}
X			}
X		}
X}
X
X#if NeedFunctionPrototypes
Xvoid RedrawAllBlocks(Display *display, Window window)
X#else
Xvoid RedrawAllBlocks(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X    struct aBlock *blockP;
X	int r, c;
X
X	for (r = 0; r < MAX_ROW; r++)
X		for (c = 0; c < MAX_COL; c++)
X		{
X			/* Pointer to the block we want */
X			blockP = &blocks[r][c];
X
X			if (blockP->occupied == True)
X				DrawBlock(display, window, r, c, blockP->blockType);
X		}
X}
X
X#if NeedFunctionPrototypes
Xint StillActiveBlocks(void)
X#else
Xint StillActiveBlocks()
X#endif
X{
X    struct aBlock *blockP;
X	int r, c;
X
X	/* Check all blocks to see if they still are active */
X	for (r = 0; r < MAX_ROW; r++)
X		for (c = 0; c < MAX_COL; c++)
X		{
X			/* Pointer to the block we want */
X			blockP = &blocks[r][c];
X
X			if (blockP->occupied == True) 
X			{
X				switch (blockP->blockType)
X				{
X					/* These blocks don't count */
X					case BONUSX2_BLK:
X					case BONUSX4_BLK:
X					case BONUS_BLK:
X					case BLACK_BLK:
X					case BULLET_BLK:
X					case BOMB_BLK:
X					case DEATH_BLK:
X					case REVERSE_BLK:
X					case HYPERSPACE_BLK:
X					case EXTRABALL_BLK:
X					case MGUN_BLK:
X					case WALLOFF_BLK:
X					case MULTIBALL_BLK:
X					case STICKY_BLK:
X        			case PAD_SHRINK_BLK:
X					case PAD_EXPAND_BLK:
X						break;
X
X					default:
X						return True;
X				}
X			}
X		}
X	
X	/* Only all done when explosions are finished */
X	if (blocksExploding > 0)
X		return True;
X	else
X		return False;
X}
X
X#if NeedFunctionPrototypes
Xstatic void ClearBlock(int row, int col)
X#else
Xstatic void ClearBlock(row, col)
X	int row;
X	int col;
X#endif
X{
X    struct aBlock *blockP;
X
X	/* Pointer to the block we want */
X	blockP = &blocks[row][col];
X
X	/* Initialise everything in block */
X	blockP->occupied 			= False;
X	blockP->exploding 			= False;
X	blockP->x 					= 0;
X	blockP->y 					= 0;
X	blockP->width 				= 0;
X	blockP->height 				= 0;
X	blockP->hitPoints 			= 0;
X	blockP->blockType 			= NONE_BLK;
X	blockP->explodeStartFrame 	= 0;
X	blockP->explodeNextFrame 	= 0;
X	blockP->explodeSlide 		= 0;
X	blockP->counterSlide 		= 0;
X	blockP->bonusSlide 			= 0;
X	blockP->blockOffsetY 		= 0;
X	blockP->blockOffsetX 		= 0;
X	blockP->lastFrame 			= 0;
X	blockP->nextFrame 			= 0;
X	blockP->currentFrame 		= 0;
X	blockP->random 				= False;
X	blockP->ballHitIndex 		= 0;
X	blockP->balldx 				= 0;
X	blockP->balldy 				= 0;
X
X	/* Destroy the top region of the block */
X	if (blockP->regionTop != (Region) NULL)
X	{
X		XDestroyRegion(blockP->regionTop);
X		blockP->regionTop = (Region) NULL;
X	}
X
X	/* Destroy the bottom region of the block */
X	if (blockP->regionBottom != (Region) NULL)
X	{
X		XDestroyRegion(blockP->regionBottom);
X		blockP->regionBottom = (Region) NULL;
X	}
X
X	/* Destroy the left region of the block */
X	if (blockP->regionLeft != (Region) NULL)
X	{
X		XDestroyRegion(blockP->regionLeft);
X		blockP->regionLeft = (Region) NULL;
X	}
X
X	/* Destroy the right region of the block */
X	if (blockP->regionRight != (Region) NULL)
X	{
X		XDestroyRegion(blockP->regionRight);
X		blockP->regionRight = (Region) NULL;
X	}
X}
X
X
X#if NeedFunctionPrototypes
Xvoid ClearBlockArray(void)
X#else
Xvoid ClearBlockArray()
X#endif
X{
X	int r, c;
X
X	/* Scan through all block entries and erase their contents */
X	for (r = 0; r < MAX_ROW; r++)
X	{
X		for (c = 0; c < MAX_COL; c++)
X		{
X			/* Clear the block thanks */
X			ClearBlock(r, c);
X		}
X	}
X}
X
X#if NeedFunctionPrototypes
Xvoid SetupStage(Display *display, Window window)
X#else
Xvoid SetupStage(display, window)
X	Display *display;
X	Window window;
X#endif
X{
X	char levelPath[1024];
X	char *str;
X	char str2[1024];
X	static int bgrnd = 1;
X	u_long newLevel;
X
X	bgrnd++;
X	if (bgrnd == 12) bgrnd = 2;
X	DrawStageBackground(display, window, bgrnd);
X
X	ClearAllBalls();
X	currentPaddleSize   = PADDLE_HUGE;
X	ResetPaddleStart(display, window);
X	ResetBallStart(display, playWindow);
X
X	ClearBullets();
X	SetNumberBullets(NUMBER_OF_BULLETS_NEW_LEVEL);
X	ResetNumberBonus();
X
X	TurnSpecialsOff(display);		
X	SetReverseOff();
X	DisplayScore(display, scoreWindow, score);
X	DisplayLevelInfo(display, levelWindow, level);
X	DrawSpecials(display);
X
X    /* map the level number for the filename so that after the maximum
X	 * level is reached it will wrap around to 1 again but will not
X  	 * affect the level number
X   	 */
X   	newLevel = level % (MAX_NUM_LEVELS + 1);
X  	if (newLevel == 0) newLevel = 1;
X
X	/* Construct the level filename */
X	if ((str = getenv("XBOING_LEVELS_DIR")) != NULL)
X		sprintf(levelPath, "%s/level%ld.data", str, newLevel);
X	else
X		sprintf(levelPath, "%s/level%ld.data", LEVEL_INSTALL_DIR, newLevel);
X
X	if (ReadNextLevel(display, window, levelPath) == False)
X		ShutDown(display, 1, "Sorry, email: jck@citri.edu.au with bug.");
X	
X	/* Display level name for all to see */
X	sprintf(str2, "- %s -", GetLevelName());
X	SetCurrentMessage(display, messWindow, str2, True);
X
X	XFlush(display);
X}
END_OF_FILE
  if test 24327 -ne `wc -c <'xab'`; then
    echo shar: \"'xab'\" unpacked with wrong size!
  fi
  # end of 'xab'
fi
echo shar: End of archive 9 \(of 26\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 26 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo "merging split files..."
    cat blocks.c[12] > blocks.c
    rm blocks.c[12]
    echo "blocks.c done"
    cat bitmaps/earth.xpm.Z.u.[ab] > bitmaps/earth.xpm.Z.uue
    rm bitmaps/earth.xpm.Z.u.[ab]
    echo "bitmaps/earth.xpm.Z.uue done"
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
