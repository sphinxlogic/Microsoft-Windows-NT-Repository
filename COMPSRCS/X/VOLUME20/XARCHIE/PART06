Newsgroups: comp.sources.x
From: ferguson@cs.rochester.edu (George Ferguson)
Subject: v20i034:  xarchie - An X browser interface to Archie, v2.0.6, Part06/24
Message-ID: <1993Jun15.223225.29976@sparky.imd.sterling.com>
X-Md4-Signature: f4abd6ca99b8442e9eb32b2ecd046ee2
Sender: chris@sparky.imd.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Tue, 15 Jun 1993 22:32:25 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: ferguson@cs.rochester.edu (George Ferguson)
Posting-number: Volume 20, Issue 34
Archive-name: xarchie/part06
Environment: X11
Supersedes: xarchie: Volume 14, Issue 82-90

Submitted-by: ferguson@cs.rochester.edu
Archive-name: xarchie-2.0.6/part06

#!/bin/sh
# this is Part.06 (part 6 of xarchie-2.0.6)
# do not concatenate these parts, unpack them in order with /bin/sh
# file xarchie-2.0.6/config.h.in continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 6; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping xarchie-2.0.6/config.h.in'
else
echo 'x - continuing file xarchie-2.0.6/config.h.in'
sed 's/^X//' << 'SHAR_EOF' >> 'xarchie-2.0.6/config.h.in' &&
/* Define if your sys/select.h declares FD_SET.  */
#undef FD_SET_IN_SYS_SELECT_H
/* Define if your sys/inet.h declares FD_SET.  */
#undef FD_SET_IN_SYS_INET_H
X
/* Define if you have re_comp() and re_exec() */
#undef HAVE_RE_COMP
/* Some systems use regcmp() and regex() instead (like AIX) */
#undef HAVE_REGCMP
X
/* Define if you have strcasecmp() */
#undef HAVE_STRCASECMP
X
/* Define if you have random() */
#undef HAVE_RANDOM
/* Some systems use rand() instead (like HPUX) */
#undef HAVE_RAND
X
/* Define if you have the ANSI function strerror() */
#undef HAVE_STRERROR
X
/* Define if you have errno (who doesn't)? */
#undef HAVE_ERRNO
X
/* Define if you have sys_errlist (not needed if you have strerror) */
#undef HAVE_SYS_ERRLIST
X
/* Define if you have getlogin() (who doesn't?) */
#undef HAVE_GETLOGIN
X
/* Define if you have getpwuid() defined in <pwd.h> */
#undef HAVE_GETPWUID
X
/* Define if you have strspn() */
#undef HAVE_STRSPN
X
/* Define this if you need -lresolv in your link line (used by imake) */
#undef NEED_LRESOLV
X
#endif /*!_CONFIG_H*/
SHAR_EOF
echo 'File xarchie-2.0.6/config.h.in is complete' &&
chmod 0644 xarchie-2.0.6/config.h.in ||
echo 'restore of xarchie-2.0.6/config.h.in failed'
Wc_c="`wc -c < 'xarchie-2.0.6/config.h.in'`"
test 1659 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/config.h.in: original size 1659, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/configure ==============
if test -f 'xarchie-2.0.6/configure' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/configure (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/configure (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/configure' &&
#!/bin/sh
# Guess values for system-dependent variables and create Makefiles.
# Generated automatically using autoconf.
# Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.
X
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
X
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
X
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X
# Usage: configure [--srcdir=DIR] [--host=HOST] [--gas] [--nfp] [--no-create]
#        [--prefix=PREFIX] [--exec-prefix=PREFIX] [--with-PACKAGE] [TARGET]
# Ignores all args except --srcdir, --prefix, --exec-prefix, --no-create, and
# --with-PACKAGE unless this script has special code to handle it.
X
X
for arg
do
X  # Handle --exec-prefix with a space before the argument.
X  if test x$next_exec_prefix = xyes; then exec_prefix=$arg; next_exec_prefix=
X  # Handle --host with a space before the argument.
X  elif test x$next_host = xyes; then next_host=
X  # Handle --prefix with a space before the argument.
X  elif test x$next_prefix = xyes; then prefix=$arg; next_prefix=
X  # Handle --srcdir with a space before the argument.
X  elif test x$next_srcdir = xyes; then srcdir=$arg; next_srcdir=
X  else
X    case $arg in
X     # For backward compatibility, also recognize exact --exec_prefix.
X     -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* | --exec=* | --exe=* | --ex=* | --e=*)
X	exec_prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- | --exec | --exe | --ex | --e)
X	next_exec_prefix=yes ;;
X
X     -gas | --gas | --ga | --g) ;;
X
X     -host=* | --host=* | --hos=* | --ho=* | --h=*) ;;
X     -host | --host | --hos | --ho | --h)
X	next_host=yes ;;
X
X     -nfp | --nfp | --nf) ;;
X
X     -no-create | --no-create | --no-creat | --no-crea | --no-cre | --no-cr | --no-c | --no- | --no)
X        no_create=1 ;;
X
X     -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
X	prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
X	next_prefix=yes ;;
X
X     -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=* | --s=*)
X	srcdir=`echo $arg | sed 's/[-a-z_]*=//'` ;;
X     -srcdir | --srcdir | --srcdi | --srcd | --src | --sr | --s)
X	next_srcdir=yes ;;
X
X     -with-* | --with-*)
X       package=`echo $arg|sed 's/-*with-//'`
X       # Delete all the valid chars; see if any are left.
X       if test -n "`echo $package|sed 's/[-a-zA-Z0-9_]*//g'`"; then
X         echo "configure: $package: invalid package name" >&2; exit 1
X       fi
X       eval "with_`echo $package|sed s/-/_/g`=1" ;;
X
X     *) ;;
X    esac
X  fi
done
X
trap 'rm -f conftest* core; exit 1' 1 3 15
X
rm -f conftest*
compile='${CC-cc} $DEFS conftest.c -o conftest $LIBS >/dev/null 2>&1'
X
# A filename unique to this package, relative to the directory that
# configure is in, which we can look for to find out if srcdir is correct.
unique_file=xarchie.c
X
# Find the source files, if location was not specified.
if test -z "$srcdir"; then
X  srcdirdefaulted=yes
X  # Try the directory containing this script, then `..'.
X  prog=$0
X  confdir=`echo $prog|sed 's%/[^/][^/]*$%%'`
X  test "X$confdir" = "X$prog" && confdir=.
X  srcdir=$confdir
X  if test ! -r $srcdir/$unique_file; then
X    srcdir=..
X  fi
fi
if test ! -r $srcdir/$unique_file; then
X  if test x$srcdirdefaulted = xyes; then
X    echo "configure: Can not find sources in \`${confdir}' or \`..'." 1>&2
X  else
X    echo "configure: Can not find sources in \`${srcdir}'." 1>&2
X  fi
X  exit 1
fi
# Preserve a srcdir of `.' to avoid automounter screwups with pwd.
# But we can't avoid them for `..', to make subdirectories work.
case $srcdir in
X  .|/*|~*) ;;
X  *) srcdir=`cd $srcdir; pwd` ;; # Make relative path absolute.
esac
X
X
if test -z "$CC"; then
X  echo checking for gcc
X  saveifs="$IFS"; IFS="${IFS}:"
X  for dir in $PATH; do
X    test -z "$dir" && dir=.
X    if test -f $dir/gcc; then
X      CC="gcc"
X      break
X    fi
X  done
X  IFS="$saveifs"
fi
test -z "$CC" && CC="cc"
X
# Find out if we are using GNU C, under whatever name.
cat > conftest.c <<EOF
#ifdef __GNUC__
X  yes
#endif
EOF
${CC-cc} -E conftest.c > conftest.out 2>&1
if egrep yes conftest.out >/dev/null 2>&1; then
X  GCC=1 # For later tests.
fi
rm -f conftest*
X
echo checking how to run the C preprocessor
if test -z "$CPP"; then
X  CPP='${CC-cc} -E'
X  cat > conftest.c <<EOF
#include <stdio.h>
EOF
err=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
if test -z "$err"; then
X  :
else
X  CPP=/lib/cpp
fi
rm -f conftest*
fi
X
if test -n "$GCC"; then
X  echo checking whether -traditional is needed
X  pattern="Autoconf.*'x'"
X  prog='#include <sgtty.h>
Autoconf TIOCGETP'
X  cat > conftest.c <<EOF
$prog
EOF
eval "$CPP $DEFS conftest.c > conftest.out 2>&1"
if egrep "$pattern" conftest.out >/dev/null 2>&1; then
X  need_trad=1
fi
rm -f conftest*
X
X
X  if test -z "$need_trad"; then
X    prog='#include <termio.h>
Autoconf TCGETA'
X    cat > conftest.c <<EOF
$prog
EOF
eval "$CPP $DEFS conftest.c > conftest.out 2>&1"
if egrep "$pattern" conftest.out >/dev/null 2>&1; then
X  need_trad=1
fi
rm -f conftest*
X
X  fi
X  test -n "$need_trad" && CC="$CC -traditional"
fi
X
echo checking for POSIXized ISC
if test -d /etc/conf/kconfig.d &&
X  grep _POSIX_VERSION /usr/include/sys/unistd.h >/dev/null 2>&1
then
X  ISC=1 # If later tests want to check for ISC.
X  DEFS="$DEFS -D_POSIX_SOURCE=1"
SEDDEFS="${SEDDEFS}\${SEDdA}_POSIX_SOURCE\${SEDdB}_POSIX_SOURCE\${SEDdC}1\${SEDdD}
\${SEDuA}_POSIX_SOURCE\${SEDuB}_POSIX_SOURCE\${SEDuC}1\${SEDuD}
\${SEDeA}_POSIX_SOURCE\${SEDeB}_POSIX_SOURCE\${SEDeC}1\${SEDeD}
"
X  if test -n "$GCC"; then
X    CC="$CC -posix"
X  else
X    CC="$CC -Xp"
X  fi
fi
X
echo checking for IRIX libsun
if test -f /usr/lib/libsun.a; then
X  LIBS="$LIBS -lsun"
fi
X
echo checking for ANSI C header files
cat > conftest.c <<EOF
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <float.h>
EOF
err=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
if test -z "$err"; then
X  # SunOS string.h does not declare mem*, contrary to ANSI.
echo '#include <string.h>' > conftest.c
eval "$CPP $DEFS conftest.c > conftest.out 2>&1"
if egrep "memchr" conftest.out >/dev/null 2>&1; then
X  # SGI's /bin/cc from Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
cat > conftest.c <<EOF
#include <ctype.h>
#define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
#define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
#define XOR(e,f) (((e) && !(f)) || (!(e) && (f)))
int main () { int i; for (i = 0; i < 256; i++)
if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
exit (0); }
X
EOF
eval $compile
if test -s conftest && (./conftest; exit) 2>/dev/null; then
X  DEFS="$DEFS -DSTDC_HEADERS=1"
SEDDEFS="${SEDDEFS}\${SEDdA}STDC_HEADERS\${SEDdB}STDC_HEADERS\${SEDdC}1\${SEDdD}
\${SEDuA}STDC_HEADERS\${SEDuB}STDC_HEADERS\${SEDuC}1\${SEDuD}
\${SEDeA}STDC_HEADERS\${SEDeB}STDC_HEADERS\${SEDeC}1\${SEDeD}
"
fi
rm -f conftest*
fi
rm -f conftest*
X
fi
rm -f conftest*
X
for hdr in string.h memory.h sys/param.h
do
trhdr=HAVE_`echo $hdr | tr '[a-z]./' '[A-Z]__'`
echo checking for ${hdr}
cat > conftest.c <<EOF
#include <${hdr}>
EOF
err=`eval "$CPP $DEFS conftest.c 2>&1 >/dev/null"`
if test -z "$err"; then
X  DEFS="$DEFS -D${trhdr}=1"
SEDDEFS="${SEDDEFS}\${SEDdA}${trhdr}\${SEDdB}${trhdr}\${SEDdC}1\${SEDdD}
\${SEDuA}${trhdr}\${SEDuB}${trhdr}\${SEDuC}1\${SEDuD}
\${SEDeA}${trhdr}\${SEDeB}${trhdr}\${SEDeC}1\${SEDeD}
"
fi
rm -f conftest*
done
X
echo checking for fd_set in sys/types.h
cat > conftest.c <<EOF
#include <stdio.h>
#include <sys/types.h>
main() { exit(0); } 
t() { fd_set foo; }
EOF
if eval $compile; then
X  DEFS="$DEFS -DFD_SET_IN_SYS_TYPES_H=1"
SEDDEFS="${SEDDEFS}\${SEDdA}FD_SET_IN_SYS_TYPES_H\${SEDdB}FD_SET_IN_SYS_TYPES_H\${SEDdC}1\${SEDdD}
\${SEDuA}FD_SET_IN_SYS_TYPES_H\${SEDuB}FD_SET_IN_SYS_TYPES_H\${SEDuC}1\${SEDuD}
\${SEDeA}FD_SET_IN_SYS_TYPES_H\${SEDeB}FD_SET_IN_SYS_TYPES_H\${SEDeC}1\${SEDeD}
"
else
X  echo checking for fd_set in sys/select.h
cat > conftest.c <<EOF
#include <stdio.h>
#include <sys/select.h>
main() { exit(0); } 
t() { fd_set foo; }
EOF
if eval $compile; then
X  DEFS="$DEFS -DFD_SET_IN_SYS_SELECT_H=1"
SEDDEFS="${SEDDEFS}\${SEDdA}FD_SET_IN_SYS_SELECT_H\${SEDdB}FD_SET_IN_SYS_SELECT_H\${SEDdC}1\${SEDdD}
\${SEDuA}FD_SET_IN_SYS_SELECT_H\${SEDuB}FD_SET_IN_SYS_SELECT_H\${SEDuC}1\${SEDuD}
\${SEDeA}FD_SET_IN_SYS_SELECT_H\${SEDeB}FD_SET_IN_SYS_SELECT_H\${SEDeC}1\${SEDeD}
"
else
X  echo checking for fd_set in sys/inet.h
cat > conftest.c <<EOF
#include <stdio.h>
#include <sys/inet.h>
main() { exit(0); } 
t() { fd_set foo; }
EOF
if eval $compile; then
X  DEFS="$DEFS -DFD_SET_IN_SYS_INET_H=1"
SEDDEFS="${SEDDEFS}\${SEDdA}FD_SET_IN_SYS_INET_H\${SEDdB}FD_SET_IN_SYS_INET_H\${SEDdC}1\${SEDdD}
\${SEDuA}FD_SET_IN_SYS_INET_H\${SEDuB}FD_SET_IN_SYS_INET_H\${SEDuC}1\${SEDuD}
\${SEDeA}FD_SET_IN_SYS_INET_H\${SEDeB}FD_SET_IN_SYS_INET_H\${SEDeC}1\${SEDeD}
"
fi
rm -f conftest*
X
fi
rm -f conftest*
X
fi
rm -f conftest*
X
echo checking for struct tm in time.h
cat > conftest.c <<EOF
#include <sys/types.h>
#include <time.h>
main() { exit(0); } 
t() { struct tm *tp; }
EOF
if eval $compile; then
X  :
else
X  DEFS="$DEFS -DTM_IN_SYS_TIME=1"
SEDDEFS="${SEDDEFS}\${SEDdA}TM_IN_SYS_TIME\${SEDdB}TM_IN_SYS_TIME\${SEDdC}1\${SEDdD}
\${SEDuA}TM_IN_SYS_TIME\${SEDuB}TM_IN_SYS_TIME\${SEDuC}1\${SEDuD}
\${SEDeA}TM_IN_SYS_TIME\${SEDeB}TM_IN_SYS_TIME\${SEDeC}1\${SEDeD}
"
fi
rm -f conftest*
X
for func in re_comp regcmp strcasecmp random rand strerror getlogin getpwuid
do
trfunc=HAVE_`echo $func | tr '[a-z]' '[A-Z]'`
echo checking for ${func}
cat > conftest.c <<EOF
#include <stdio.h>
main() { exit(0); } 
t() { 
#ifdef __stub_${func}
choke me
#else
/* Override any gcc2 internal prototype to avoid an error.  */
extern char ${func}(); ${func}();
#endif
X }
EOF
if eval $compile; then
X  DEFS="$DEFS -D${trfunc}=1"
SEDDEFS="${SEDDEFS}\${SEDdA}${trfunc}\${SEDdB}${trfunc}\${SEDdC}1\${SEDdD}
\${SEDuA}${trfunc}\${SEDuB}${trfunc}\${SEDuC}1\${SEDuD}
\${SEDeA}${trfunc}\${SEDeB}${trfunc}\${SEDeC}1\${SEDeD}
"
fi
rm -f conftest*
#endif
done
X
for func in strspn
do
trfunc=HAVE_`echo $func | tr '[a-z]' '[A-Z]'`
echo checking for ${func}
cat > conftest.c <<EOF
#include <stdio.h>
main() { exit(0); } 
t() { 
#ifdef __stub_${func}
choke me
#else
/* Override any gcc2 internal prototype to avoid an error.  */
extern char ${func}(); ${func}();
#endif
X }
EOF
if eval $compile; then
X  DEFS="$DEFS -D${trfunc}=1"
SEDDEFS="${SEDDEFS}\${SEDdA}${trfunc}\${SEDdB}${trfunc}\${SEDdC}1\${SEDdD}
\${SEDuA}${trfunc}\${SEDuB}${trfunc}\${SEDuC}1\${SEDuD}
\${SEDeA}${trfunc}\${SEDeB}${trfunc}\${SEDeC}1\${SEDeD}
"
fi
rm -f conftest*
#endif
done
X
echo checking for errno
cat > conftest.c <<EOF
X
main() { exit(0); } 
t() { extern int errno; int i=errno; }
EOF
if eval $compile; then
X  DEFS="$DEFS -DHAVE_ERRNO=1"
SEDDEFS="${SEDDEFS}\${SEDdA}HAVE_ERRNO\${SEDdB}HAVE_ERRNO\${SEDdC}1\${SEDdD}
\${SEDuA}HAVE_ERRNO\${SEDuB}HAVE_ERRNO\${SEDuC}1\${SEDuD}
\${SEDeA}HAVE_ERRNO\${SEDeB}HAVE_ERRNO\${SEDeC}1\${SEDeD}
"
fi
rm -f conftest*
X
echo checking for sys_errlist
cat > conftest.c <<EOF
X
main() { exit(0); } 
t() { extern char **sys_errlist; char *s=*sys_errlist; }
EOF
if eval $compile; then
X  DEFS="$DEFS -DHAVE_SYS_ERRLIST=1"
SEDDEFS="${SEDDEFS}\${SEDdA}HAVE_SYS_ERRLIST\${SEDdB}HAVE_SYS_ERRLIST\${SEDdC}1\${SEDdD}
\${SEDuA}HAVE_SYS_ERRLIST\${SEDuB}HAVE_SYS_ERRLIST\${SEDuC}1\${SEDuD}
\${SEDeA}HAVE_SYS_ERRLIST\${SEDeB}HAVE_SYS_ERRLIST\${SEDeC}1\${SEDeD}
"
fi
rm -f conftest*
X
echo checking whether -lresolv is needed
cat > conftest.c <<EOF
#include "resolv.c"
EOF
eval $compile
if test -s conftest && (./conftest; exit) 2>/dev/null; then
X  :
else
X  DEFS="$DEFS -DNEED_LRESOLV=1"
SEDDEFS="${SEDDEFS}\${SEDdA}NEED_LRESOLV\${SEDdB}NEED_LRESOLV\${SEDdC}1\${SEDdD}
\${SEDuA}NEED_LRESOLV\${SEDuB}NEED_LRESOLV\${SEDuC}1\${SEDuD}
\${SEDeA}NEED_LRESOLV\${SEDeB}NEED_LRESOLV\${SEDeC}1\${SEDeD}
"
fi
rm -f conftest*
if test -n "$prefix"; then
X  test -z "$exec_prefix" && exec_prefix='${prefix}'
X  prsub="s%^prefix\\([ 	]*\\)=\\([ 	]*\\).*$%prefix\\1=\\2$prefix%"
fi
if test -n "$exec_prefix"; then
X  prsub="$prsub
s%^exec_prefix\\([ 	]*\\)=\\([ 	]*\\).*$%\
exec_prefix\\1=\\2$exec_prefix%"
fi
X
trap 'rm -f config.status; exit 1' 1 3 15
echo creating config.status
rm -f config.status
cat > config.status <<EOF
#!/bin/sh
# Generated automatically by configure.
# Run this file to recreate the current configuration.
# This directory was configured as follows,
# on host `(hostname || uname -n) 2>/dev/null`:
#
# $0 $*
X
for arg
do
X  case "\$arg" in
X    -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
X    exec /bin/sh $0 $* ;;
X    *) echo "Usage: config.status --recheck" 2>&1; exit 1 ;;
X  esac
done
X
trap 'rm -f  config.h conftest*; exit 1' 1 3 15
CC='$CC'
CPP='$CPP'
FD_SET_IN_SYS_TYPES_H='$FD_SET_IN_SYS_TYPES_H'
FD_SET_IN_SYS_SELECT_H='$FD_SET_IN_SYS_SELECT_H'
FD_SET_IN_SYS_INET_H='$FD_SET_IN_SYS_INET_H'
HAVE_ERRNO='$HAVE_ERRNO'
HAVE_SYS_ERRLIST='$HAVE_SYS_ERRLIST'
NEED_LRESOLV='$NEED_LRESOLV'
LIBS='$LIBS'
srcdir='$srcdir'
prefix='$prefix'
exec_prefix='$exec_prefix'
prsub='$prsub'
EOF
cat >> config.status <<\EOF
X
top_srcdir=$srcdir
for file in .. ; do if [ "x$file" != "x.." ]; then
X  srcdir=$top_srcdir
X  # Remove last slash and all that follows it.  Not all systems have dirname.
X  dir=`echo $file|sed 's%/[^/][^/]*$%%'`
X  if test "$dir" != "$file"; then
X    test "$top_srcdir" != . && srcdir=$top_srcdir/$dir
X    test ! -d $dir && mkdir $dir
X  fi
X  echo creating $file
X  rm -f $file
X  echo "# Generated automatically from `echo $file|sed 's|.*/||'`.in by configure." > $file
X  sed -e "
$prsub
s%@CC@%$CC%g
s%@CPP@%$CPP%g
s%@FD_SET_IN_SYS_TYPES_H@%$FD_SET_IN_SYS_TYPES_H%g
s%@FD_SET_IN_SYS_SELECT_H@%$FD_SET_IN_SYS_SELECT_H%g
s%@FD_SET_IN_SYS_INET_H@%$FD_SET_IN_SYS_INET_H%g
s%@HAVE_ERRNO@%$HAVE_ERRNO%g
s%@HAVE_SYS_ERRLIST@%$HAVE_SYS_ERRLIST%g
s%@NEED_LRESOLV@%$NEED_LRESOLV%g
s%@LIBS@%$LIBS%g
s%@srcdir@%$srcdir%g
s%@DEFS@%-DHAVE_CONFIG_H%" $top_srcdir/${file}.in >> $file
fi; done
X
echo creating config.h
# These sed commands are put into SEDDEFS when defining a macro.
# They are broken into pieces to make the sed script easier to manage.
# They are passed to sed as "A NAME B NAME C VALUE D", where NAME
# is the cpp macro being defined and VALUE is the value it is being given.
# Each defining turns into a single global substitution command.
#
# SEDd sets the value in "#define NAME VALUE" lines.
SEDdA='s@^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
SEDdB='\([ 	][ 	]*\)[^ 	]*@\1#\2'
SEDdC='\3'
SEDdD='@g'
# SEDu turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
SEDuA='s@^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
SEDuB='\([ 	]\)@\1#\2define\3'
SEDuC=' '
SEDuD='\4@g'
# SEDe turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
SEDeA='s@^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
SEDeB='$@\1#\2define\3'
SEDeC=' '
SEDeD='@g'
rm -f conftest.sed
cat > conftest.sed <<CONFEOF
EOF
# Turn off quoting long enough to insert the sed commands.
cat >> config.status <<EOF
$SEDDEFS
EOF
cat >> config.status <<\EOF
CONFEOF
rm -f conftest.h
# Break up the sed commands because old seds have small limits.
cp $top_srcdir/config.h.in conftest.h1
while :
do
X  lines=`grep -c . conftest.sed`
X  if test -z "$lines" || test "$lines" -eq 0; then break; fi
X  rm -f conftest.s1 conftest.s2 conftest.h2
X  sed 40q conftest.sed > conftest.s1 # Like head -40.
X  sed 1,40d conftest.sed > conftest.s2 # Like tail +41.
X  sed -f conftest.s1 < conftest.h1 > conftest.h2
X  rm -f conftest.s1 conftest.h1 conftest.sed
X  mv conftest.h2 conftest.h1
X  mv conftest.s2 conftest.sed
done
rm -f conftest.sed conftest.h
echo "/* config.h.  Generated automatically by configure.  */" > conftest.h
cat conftest.h1 >> conftest.h
rm -f conftest.h1
if cmp -s config.h conftest.h 2>/dev/null; then
X  # The file exists and we would not be changing it.
X  rm -f conftest.h
else
X  rm -f config.h
X  mv conftest.h config.h
fi
X
EOF
chmod +x config.status
test -n "$no_create" || ./config.status
X
SHAR_EOF
chmod 0755 xarchie-2.0.6/configure ||
echo 'restore of xarchie-2.0.6/configure failed'
Wc_c="`wc -c < 'xarchie-2.0.6/configure'`"
test 16545 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/configure: original size 16545, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/configure.in ==============
if test -f 'xarchie-2.0.6/configure.in' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/configure.in (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/configure.in (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/configure.in' &&
dnl Process this file with autoconf to produce a configure script.
dnl
AC_INIT(xarchie.c)
AC_CONFIG_HEADER(config.h)
AC_PROG_CC
AC_PROG_CPP
AC_GCC_TRADITIONAL
AC_ISC_POSIX
AC_IRIX_SUN
AC_STDC_HEADERS
AC_HAVE_HEADERS(string.h memory.h [sys/param.h])
AC_COMPILE_CHECK([fd_set in sys/types.h],
[#include <stdio.h>
#include <sys/types.h>], [fd_set foo;],
X AC_DEFINE(FD_SET_IN_SYS_TYPES_H,1),
X AC_COMPILE_CHECK([fd_set in sys/select.h],
[#include <stdio.h>
#include <sys/select.h>], [fd_set foo;],
X AC_DEFINE(FD_SET_IN_SYS_SELECT_H,1),
X AC_COMPILE_CHECK([fd_set in sys/inet.h],
[#include <stdio.h>
#include <sys/inet.h>], [fd_set foo;],
X AC_DEFINE(FD_SET_IN_SYS_INET_H,1))))
AC_SUBST(FD_SET_IN_SYS_TYPES_H)dnl 
AC_SUBST(FD_SET_IN_SYS_SELECT_H)dnl 
AC_SUBST(FD_SET_IN_SYS_INET_H)dnl 
AC_STRUCT_TM
AC_HAVE_FUNCS(re_comp regcmp strcasecmp random rand strerror getlogin getpwuid)
AC_HAVE_FUNCS(strspn)
AC_COMPILE_CHECK(errno, , [extern int errno; int i=errno;],
X AC_DEFINE(HAVE_ERRNO))
AC_SUBST(HAVE_ERRNO)dnl
AC_COMPILE_CHECK(sys_errlist, ,
X [extern char **sys_errlist; char *s=*sys_errlist;],
X AC_DEFINE(HAVE_SYS_ERRLIST))
AC_SUBST(HAVE_SYS_ERRLIST)dnl
dnl To test for -lresolv we use the provided test program, resolv.c:
echo checking whether -lresolv is needed
AC_TEST_PROGRAM([#include "resolv.c"], , AC_DEFINE(NEED_LRESOLV))
AC_SUBST(NEED_LRESOLV)dnl
AC_OUTPUT()
SHAR_EOF
chmod 0644 xarchie-2.0.6/configure.in ||
echo 'restore of xarchie-2.0.6/configure.in failed'
Wc_c="`wc -c < 'xarchie-2.0.6/configure.in'`"
test 1360 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/configure.in: original size 1360, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/confirm.c ==============
if test -f 'xarchie-2.0.6/confirm.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/confirm.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/confirm.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/confirm.c' &&
/*
X * confirm.c : Confirmer popup
X *
X * George Ferguson, ferguson@cs.rochester.edu, 23 Apr 1993.
X */
X
#include <X11/Intrinsic.h>
#include "popups.h"
X
/*
X * Functions defined here:
X */
int confirm0();
static void confirmCallback();
X
/*
X * Data defined here:
X */
static Widget confirmShell;
static int confirmResult;
X
/*	-	-	-	-	-	-	-	-	*/
X
int
confirm0(str)
char *str;
{
X    if (confirmShell == NULL)
X	confirmShell = createPopup("confirm",2,confirmCallback);
X    setPopupLabel(confirmShell,"confirm",str);
X    popupMainLoop(confirmShell);
X    return(confirmResult);
}
X
/*ARGSUSED*/
static void
confirmCallback(w,client_data,call_data)
Widget w;
XXtPointer client_data;		/* button number */
XXtPointer call_data;
{
X    switch ((int)client_data) {
X      case 0:			/* YES */
X	confirmResult = 1;
X	break;
X      case 1:			/* NO */
X	confirmResult = 0;
X	break;
X    }
X    popupDone();
}
SHAR_EOF
chmod 0644 xarchie-2.0.6/confirm.c ||
echo 'restore of xarchie-2.0.6/confirm.c failed'
Wc_c="`wc -c < 'xarchie-2.0.6/confirm.c'`"
test 875 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/confirm.c: original size 875, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/confirm.h ==============
if test -f 'xarchie-2.0.6/confirm.h' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/confirm.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/confirm.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/confirm.h' &&
/*
X * confirm.h : External defs for confirmer functions
X *
X * George Ferguson, ferguson@cs.rochester.edu, 23 Apr 1993.
X */
X
#ifndef _CONFIRM_H
#define _CONFIRM_H
X
extern int confirm0();
X
#endif
SHAR_EOF
chmod 0644 xarchie-2.0.6/confirm.h ||
echo 'restore of xarchie-2.0.6/confirm.h failed'
Wc_c="`wc -c < 'xarchie-2.0.6/confirm.h'`"
test 194 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/confirm.h: original size 194, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/copyright.h ==============
if test -f 'xarchie-2.0.6/copyright.h' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/copyright.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/copyright.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/copyright.h' &&
/* These are the uw-copyright.h and usc-copyright.h files that appear in
X   the Prospero distribution.  */
X
/* 
X  Copyright (c) 1989, 1990, 1991 by the University of Washington
X
X  Permission to use, copy, modify, and distribute this software and its
X  documentation for non-commercial purposes and without fee is hereby
X  granted, provided that the above copyright notice appear in all copies
X  and that both the copyright notice and this permission notice appear in
X  supporting documentation, and that the name of the University of
X  Washington not be used in advertising or publicity pertaining to
X  distribution of the software without specific, written prior
X  permission.  The University of Washington makes no representations
X  about the suitability of this software for any purpose.  It is
X  provided "as is" without express or implied warranty.
X
X  Prospero was written by Clifford Neuman (bcn@isi.edu).
X
X  Questions concerning this software should be directed to 
X  info-prospero@isi.edu.
X
X  */
X
/* 
X  Copyright (c) 1991, 1992 by the University of Southern California
X  All rights reserved.
X
X  Permission to use, copy, modify, and distribute this software and its
X  documentation in source and binary forms for non-commercial purposes
X  and without fee is hereby granted, provided that the above copyright
X  notice appear in all copies and that both the copyright notice and
X  this permission notice appear in supporting documentation. and that
X  any documentation, advertising materials, and other materials related
X  to such distribution and use acknowledge that the software was
X  developed by the University of Southern California, Information
X  Sciences Institute.  The name of the University may not be used to
X  endorse or promote products derived from this software without
X  specific prior written permission.
X
X  THE UNIVERSITY OF SOUTHERN CALIFORNIA makes no representations about
X  the suitability of this software for any purpose.  THIS SOFTWARE IS
X  PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
X  INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
X  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
X
X  Other copyrights might apply to parts of the Prospero distribution
X  and are so noted when applicable.
X
X  Prospero was originally written by Clifford Neuman (bcn@isi.edu).
X  Contributors include Benjamin Britt (britt@isi.edu)
X  and others identified in individual modules.
X
X  Questions concerning this software should be directed to 
X  info-prospero@isi.edu.
X
X  */
SHAR_EOF
chmod 0644 xarchie-2.0.6/copyright.h ||
echo 'restore of xarchie-2.0.6/copyright.h failed'
Wc_c="`wc -c < 'xarchie-2.0.6/copyright.h'`"
test 2519 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/copyright.h: original size 2519, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/db.c ==============
if test -f 'xarchie-2.0.6/db.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/db.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/db.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/db.c' &&
/*
X * db.c : Database routines for xarchie
X *
X * George Ferguson, ferguson@cs.rochester.edu, 2 Nov 1991.
X * Version 2.0: 23 Apr 1993.
X */
X
#include <stdio.h>
#include "db.h"
#include "weight.h"
#include "stringdefs.h"
#include "debug.h"
X
#ifdef XARCHIE
# include <X11/Intrinsic.h>
#else /*!XARCHIE*/
# include "xtypes.h"
#endif
X
/*
X * Functions defined here:
X */
DbEntry *newEntry();
void clearEntries();
DbEntry *addEntry();
DbEntry *lastEntry();
DbEntry *findEntryFromString();
DbEntry *findEntryFromIndex();
int findIndexFromEntry();
void setEntryData(), freeEntryData();
void sortEntriesRecursively(), sortEntries();
int cmpEntryNames(), cmpEntryDates(), cmpEntryWeights();
X
static void clearEntriesInternal();
static char *entryDate(),*hostDate(),*locationDate();
X
/*	-	-	-	-	-	-	-	-	*/
X
DbEntry *
newEntry()
{
X    DbEntry *new;
X
X    new = XtNew(DbEntry);
X    new->name = NULL;
X    new->type = DB_NOTYPE;
X    new->size = -1;
X    new->modes = "";
X    new->date = "";
X    new->gt_date = "";
X    new->vlink = NULL;
X    new->selected = -1;
X    new->entries = NULL;
X    new->next = new->prev = new->parent = NULL;
X    return(new);
}
X
void
clearEntries(dbp)
DbEntry *dbp;
{
X    if (dbp == NULL) {
X	fprintf(stderr,"DB Error: Attempt to clear NULL list\n");
X	return;
X    } else {
X	clearEntriesInternal(dbp->entries);
X	dbp->entries = NULL;
X    }
}
X
static void
clearEntriesInternal(dbp)
DbEntry *dbp;
{
X    DbEntry *t;
X
X    while (dbp != NULL) {
X	clearEntriesInternal(dbp->entries);
X	freeEntryData(dbp);
X	t = dbp;
X	dbp = dbp->next;
X	XtFree((char *)t);
X    }
}
X
/*	-	-	-	-	-	-	-	-	*/
X
DbEntry *
addEntry(parent,before)
DbEntry *parent;
DbEntry *before;
{
X    DbEntry *new,*last;
X
X    DEBUG2("adding entry to 0x%x before 0x%x\n",parent,before);
X    if (parent == NULL) {
X	fprintf(stderr,"DB error: attempt to add entry to NULL list\n");
X	return(NULL);
X    } else if (parent->entries == NULL) {
X	/* No items already in list */
X	DEBUG0("  inserting as new list\n");
X	new = XtNew(DbEntry);
X	DEBUG1("  new entry is 0x%x\n",new);
X	parent->entries = new;
X	new->prev = NULL;
X	new->next = NULL;
X    } else if (before == NULL) {
X	/* Insert at end of list */
X	DEBUG0("  inserting at end of list\n");
X	last = lastEntry(parent);
X	new = XtNew(DbEntry);
X	DEBUG1("  new entry is 0x%x\n",new);
X	last->next = new;
X	new->prev = last;
X	new->next = NULL;
X    } else if (before->prev == NULL) {
X	/* Insert at head of list */
X	DEBUG0("  inserting at head of list\n");
X	new = XtNew(DbEntry);
X	DEBUG1("  new entry is 0x%x\n",new);
X	parent->entries = new;
X	new->prev = NULL;
X	new->next = before;
X	before->prev = new;
X    } else {
X	/* Insert somewhere in the middle of list */
X	DEBUG0("  inserting in middle of list\n");
X	new = XtNew(DbEntry);
X	DEBUG1("  new entry is 0x%x\n",new);
X	before->prev->next = new;
X	new->prev = before->prev;
X	new->next = before;
X	before->prev = new;
X    }
X    new->parent = parent;
X    new->entries = NULL;
X    new->name = NULL;
X    new->type = DB_NOTYPE;
X    new->size = -1;
X    new->modes = "";
X    new->date = "";
X    new->gt_date = "";
X    new->vlink = NULL;
X    DEBUG0("  done adding new entry\n");
X    return(new);
}
X
DbEntry *
lastEntry(parent)
DbEntry *parent;
{
X    DbEntry *dbp;
X
X    DEBUG1("finding last entry in entries for 0x%x\n",parent);
X    if (parent == NULL) {
X	fprintf(stderr,"DB error: attempt to find last entry of NULL list\n");
X	return(NULL);
X    } else if (parent->entries == NULL) {
X	DEBUG1("no entries for 0x%x, returning NULL\n",parent);
X	return(NULL);
X    } else {
X	for (dbp=parent->entries; dbp->next != NULL; dbp=dbp->next)
X	    /* EMPTY */ ;
X	DEBUG2("last entry for 0x%x is 0x%x\n",parent,dbp);
X	return(dbp);
X    }
}
X
DbEntry *
findEntryFromString(parent,string)
DbEntry *parent;
char *string;
{
X    DbEntry *dbp;
X
X    DEBUG2("finding entry \"%s\" in entries for 0x%x\n",string,parent);
X    if (parent == NULL) {
X	fprintf(stderr,"DB error: attempt to find \"%s\" in NULL list",string);
X	return(NULL);
X    } else {
X	for (dbp=parent->entries; dbp != NULL &&
X				  strcmp(dbp->name,string) != 0; dbp=dbp->next)
X	    /* EMPTY */ ;
X	DEBUG1("  find returning 0x%x\n",dbp);
X	return(dbp);
X    }
}
X
DbEntry *
findEntryFromIndex(parent,index)
DbEntry *parent;
int index;
{
X    DbEntry *dbp;
X
X    DEBUG2("finding entry with index %d in entries for 0x%x\n",index,parent);
X    if (parent == NULL) {
X	fprintf(stderr,"DB error: attempt to find index %d in NULL list",index);
X	return(NULL);
X    } else {
X	for (dbp=parent->entries; dbp != NULL && index--; dbp=dbp->next)
X	    /* EMPTY */ ;
X	DEBUG1("  find returning 0x%x\n",dbp);
X	return(dbp);
X    }
}
X
int
findIndexFromEntry(parent,entry)
DbEntry *parent,*entry;
{
X    DbEntry *dbp;
X    int index;
X
X    DEBUG2("finding index for entry 0x%x in entries for 0x%x\n",entry,parent);
X    index = 0;
X    if (parent == NULL) {
X	fprintf(stderr,"DB error: attempt to find entry 0x%x in NULL list",entry);
X	return(0);
X    } else {
X	for (dbp=parent->entries; dbp != NULL; dbp=dbp->next) {
X	    if (strcmp(entry->name,dbp->name) == 0) {
X		DEBUG1("  return index %d\n",index);
X		return(index);
X	    }
X	    index += 1;
X	}
X    }
X    return(-1);
}
X
/*	-	-	-	-	-	-	-	-	*/
/*
X * Allocate and set the data for the given DbEntry.
X */
void
setEntryData(dbp,name,type,size,modes,date,gt_date,vlink)
DbEntry *dbp;
char *name;
int type;
int size;
char *modes,*date,*gt_date;
VLINK vlink;
{
X    XtFree(dbp->name);
X    dbp->name = XtNewString(name);
X    dbp->type = type;
X    dbp->size = size;
X    dbp->modes = XtNewString(modes);
X    dbp->date = XtNewString(date);
X    dbp->gt_date = XtNewString(gt_date);
X    dbp->vlink = vlink;
X    DEBUG2("set data for entry 0x%x, name=\"%s\"\n",dbp,dbp->name);
}
X
/*
X * Free up anything associated with the given DbEntry.
X */
void
freeEntryData(dbp)
DbEntry *dbp;
{
X    XtFree((char *)(dbp->name));
X    if (dbp->vlink)
X	vlfree(dbp->vlink);
}
X
/*	-	-	-	-	-	-	-	-	*/
/*
X * Sorts entries of parent and then calls itself on each of them.
X */
void
sortEntriesRecursively(parent,cmp_proc)
DbEntry *parent;
int (*cmp_proc)();
{
X    DbEntry *dbp;
X
X    if (parent == NULL || cmp_proc == NULL)
X	return;
X    DEBUG1(" sorting entries recursively for 0x%x\n",parent);
X    sortEntries(parent,cmp_proc);
X    for (dbp=parent->entries; dbp != NULL; dbp = dbp->next)
X	sortEntriesRecursively(dbp->entries,cmp_proc);
X    DEBUG1(" done sorting entries recursively for 0x%x\n",parent);
}
X
/*
X * Sorts entries of parent using a selection sort and the given cmp_proc.
X */
void
sortEntries(parent,cmp_proc)
DbEntry *parent;
int (*cmp_proc)();
{
X    DbEntry *p,*nextp,*lowest,*q,*pnext,*pprev;
X
X    DEBUG1("  sorting entries for 0x%x\n",parent);
X    for (p = parent->entries; p != NULL; p = nextp) {
X	nextp = p->next;
X	lowest = p;
X	for (q = p->next; q != NULL; q = q->next)
X	    if ((*cmp_proc)(q,lowest) < 0)
X		lowest = q;
X	if (p != lowest) {
X	    /* swap the two links */
X	    pnext = p->next;
X	    pprev = p->prev;
X	    if (lowest->next != NULL)
X		lowest->next->prev = p;
X	    p->next = lowest->next;
X	    if (nextp == lowest) {
X		p->prev = lowest;
X	    } else {
X		lowest->prev->next = p;
X		p->prev = lowest->prev;
X	    }
X	    if (nextp == lowest) {
X		lowest->next = p;
X	    } else {
X		pnext->prev = lowest;
X		lowest->next = pnext;
X	    }
X	    if (pprev != NULL)
X		pprev->next = lowest;
X	    lowest->prev = pprev;
X	    /* keep the head of the list in the right place */
X	    if (parent->entries == p)
X		parent->entries = lowest;
X	}
X    }
X    DEBUG1("  done sorting entries for 0x%x\n",parent);
}
X
/*
X * cmpEntryNames(p,q) : Compare entries by name. Returns < 0 if p belongs
X *	before q, > 0 if q belongs before p, and == 0 if names are identical.
X */
int
cmpEntryNames(p,q)
DbEntry *p,*q;
{
X    return(strcmp(p->name,q->name));
}
X
/*
X * cmpEntryDates(p,q) : Compare entries by date. If the dates are the same
X *	or both entries don't have a date, then compare by name.
X *
X * To make this useful, I've made it sort hosts and locations by the
X * newest thing in them. To make it faster, it caches the computed date
X * in the otherwise unused date field.
X */
int
cmpEntryDates(p,q)
DbEntry *p,*q;
{
X    int result;
X
X    if (!*(p->gt_date))
X	p->gt_date = entryDate(p);
X    if (!*(q->gt_date))
X	q->gt_date = entryDate(q);
X    if ((result=strcmp(q->gt_date,p->gt_date)) != 0) /* note order! */
X	return(result);
X    else
X	return(cmpEntryNames(p,q));
}
X
static char *
entryDate(dbp)
DbEntry *dbp;
{
X    if (dbp->type == DB_HOST)
X	return(hostDate(dbp));
X    else if (dbp->type == DB_LOCATION)
X	return(locationDate(dbp));
X    else
X	return(dbp->gt_date);
}
X
/*
X * Returns the date of the newest (biggest date) location in the host.
X */
static char *
hostDate(dbp)
DbEntry *dbp;
{
X    DbEntry *loc;
X    char *date = "";
X    char *locdate;
X
X    for (loc=dbp->entries; loc != NULL; loc=loc->next) {
X	locdate = locationDate(loc);
X	if (!*date || strcmp(date,locdate) < 0)
X	    date = locdate;
X    }
X    return(date);
}
X
/*
X * Returns the date of the newest (biggest date) entry in the location.
X */
static char *
locationDate(dbp)
DbEntry *dbp;
{
X    DbEntry *file;
X    char *date = "";
X
X    for (file=dbp->entries; file != NULL; file=file->next) {
X	if (!*date || strcmp(date,file->gt_date) < 0)
X	    date = file->gt_date;
X    }
X    return(date);
}
X
/*
X * cmpEntryWeights(p,q) : Compare entries by user-defined "weights".
X */
int
cmpEntryWeights(p,q)
DbEntry *p,*q;
{
X    int result;
X
X    if ((result=hostWeight(p->name)-hostWeight(q->name)) != 0)
X	return(result);
X    else
X	return(cmpEntryNames(p,q));
}
SHAR_EOF
chmod 0644 xarchie-2.0.6/db.c ||
echo 'restore of xarchie-2.0.6/db.c failed'
Wc_c="`wc -c < 'xarchie-2.0.6/db.c'`"
test 9438 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/db.c: original size 9438, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/db.h ==============
if test -f 'xarchie-2.0.6/db.h' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/db.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/db.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/db.h' &&
/*
X * db.h : Definitions of the database record type, and external defs of
X *	the database functions.
X *
X * George Ferguson, ferguson@cs.rochester.edu, 2 Nov 1991.
X * Version 2.0: 23 Apr 1993.
X */
X
#ifndef DB_H
#define DB_H
X
#include "pfs.h"		/* for VLINK */
X
#define DB_NOTYPE	0
#define DB_FILE		1
#define DB_DIRECTORY	2
#define DB_LOCATION	3
#define DB_HOST		4
X
typedef struct _DbEntry {
X    char *name;			/* print name */
X    int type;			/* DB_{FILE,DIRECTORY} */
#ifdef MSDOS
X    unsigned long size;
#else
X    int size;
#endif
X    char *modes;		/* drwxrwxrwx + \0 */
X    char *date;			/* "mmm dd yyyy\0" or "mmm dd hh:mm\0" */
X    char *gt_date;		/* YYYYMMDDHHMMSSZ\0 */
X    int selected;		/* Selected in browser? Where? */
X    VLINK vlink;		/* Prospero VLINK for expansion */
X    struct _DbEntry *entries;		/* children */
X    struct _DbEntry *next,*prev;	/* siblings */
X    struct _DbEntry *parent;		/* parent */
} DbEntry;
X
extern DbEntry*newEntry();
extern void clearEntries();
extern DbEntry *addEntry();
extern DbEntry *lastEntry();
extern DbEntry *findEntryFromString();
extern DbEntry *findEntryFromIndex();
extern int findIndexFromEntry();
extern void setEntryData(), freeEntryData();
extern void sortEntriesRecursively(), sortEntries();
extern int cmpEntryNames(), cmpEntryDates(), cmpEntryWeights();
X
#define DB_ISDIR(dbp) ((dbp)->type == DB_DIRECTORY)
X
#endif /* DB_H */
SHAR_EOF
chmod 0644 xarchie-2.0.6/db.h ||
echo 'restore of xarchie-2.0.6/db.h failed'
Wc_c="`wc -c < 'xarchie-2.0.6/db.h'`"
test 1386 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/db.h: original size 1386, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/debug.h ==============
if test -f 'xarchie-2.0.6/debug.h' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/debug.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/debug.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/debug.h' &&
/*
X * debug.h : Macros for debug messages
X *
X * George Ferguson, ferguson@cs.rochester.edu, 23 Apr 1993.
X */
X
#ifdef DEBUG
#define DEBUG0(S)		fprintf(stderr,S)
#define DEBUG1(S,A1)		fprintf(stderr,S,A1)
#define DEBUG2(S,A1,A2)		fprintf(stderr,S,A1,A2)
#define DEBUG3(S,A1,A2,A3)	fprintf(stderr,S,A1,A2,A3)
#else
/*SUPPRESS 558*//* Saber: condition always false */
/*SUPPRESS 530*//* Saber: empty body of loop */
#define DEBUG0(S)
#define DEBUG1(S,A1)
#define DEBUG2(S,A1,A2)
#define DEBUG3(S,A1,A2,A3)
#endif
SHAR_EOF
chmod 0644 xarchie-2.0.6/debug.h ||
echo 'restore of xarchie-2.0.6/debug.h failed'
Wc_c="`wc -c < 'xarchie-2.0.6/debug.h'`"
test 509 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/debug.h: original size 509, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/dirsend.c ==============
if test -f 'xarchie-2.0.6/dirsend.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/dirsend.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/dirsend.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/dirsend.c' &&
/*
X * Copyright (c) 1989, 1990, 1991 by the University of Washington
X *
X * For copying and distribution information, please see the file
X * <copyright.h>.
X *
X * xarchie v2.0 - (gf)     - Sync with archie-1.4.1 (uses config.h)
X * v1.2.3 - 11/04/91 (bcn) - removed host comparison and replaced with check
X 			     for connection id (undoes effect of v1.2.2.).
X * v1.2.2 - 11/02/91 (gf)  - removed extra inet_ntoa() calls and stuff for
X			     multi-interface nets (lmjm@doc.imperial.ac.uk)
X * v1.2.1 - 10/20/91 (gf)  - asynch implementation
X * v1.2.0 - 09/17/91 (bpk) - added BULL & USG stuff, thanks to Jim Sillas
X * v1.1.2 - 08/30/91 (bpk) - added VMS support
X * v1.1.1 - 08/29/91 (bcn) - changed backoff handling
X * v1.1.0 - 08/13/91 (gf)  - added XArchie status calls
X *
X * gf: 20 Oct 1991:
X *  Broken into pieces so that under X dirsend() doesn't block in select()
X *  but rather uses Xt calls to allow continued event processing. If
X *  XARCHIE is not defined, can still be used since processEvent() will
X *  use select() in this case.
X *
X * bpk: For archie client v1.3.2:
X * If you're going to hack on this, I'd suggest using unifdef with -UCUTCP
X * and possibly -UVMS, for your working copy.  When you've got your changes
X * done, come back and add them into this main file.  It's getting pretty
X * nasty down there.
X */
X
#include <copyright.h>
#include <stdio.h>
#include <errno.h>
X
/*
X * Complaints or suggestions regarding the portability or lack thereof
X * of these includes and defines should be directed to Brendan Kehoe,
X * brendan@cs.widener.edu.
X */
#ifdef VMS
# ifdef WOLLONGONG
#  include "twg$tcp:[netdist.include]netdb.h"
# else /* not Wollongong */
#  ifdef UCX
#   include <netdb.h>
#  else /* Multinet */
#   include "multinet_root:[multinet.include]netdb.h"
#  endif
# endif
# include <vms.h>
#else /* not VMS */
# ifdef PCNFS
#  include <tklib.h>
#  include <tk_errno.h>
#  include <sys/nfs_time.h>
# endif
# include "config.h"				/* gf */
# include "stringdefs.h"			/* gf */
# include "selectdefs.h"			/* gf */
# include <sys/time.h>				/* gf */
# ifdef CUTCP
#  include <msdos/cutcp.h>
#  include <msdos/netevent.h>
#  include <msdos/hostform.h>
# else /* not CUTCP */
#  include <netdb.h>
#  include <sys/socket.h>
# endif
# ifndef IN_H
#  ifndef _TYPES_
#   include <sys/types.h>
#  endif
#  include <netinet/in.h>
#  define IN_H
# endif
# if !defined(hpux) && !defined(PCNFS)
#  include <arpa/inet.h>
# endif
#endif /* !VMS */
X
/* Interactive UNIX keeps some of the socket definitions in funny places.  */
#ifdef ISC
# include <net/errno.h>
#endif /* ISC */
/* PC-NFS Toolkit 4.0 keeps important forward definitions here. */
#ifdef PCNFS
# include <in_addr.h>
#endif
X
#include <pfs.h>
#include <pprot.h>
#include <pcompat.h>
#include <perrno.h>
X
/* gf: Removed SUN_GNU_FIX stuff since inet_ntoa.c is now included. */
X
static int notprived = 0;
#ifndef MSDOS
extern int errno;
#endif
extern int perrno;
#ifdef DEBUG
extern int pfs_debug;
#endif
extern int pfs_disable_flag;
X
char	*nlsindex();
X
#define max(X, Y)  ((X) > (Y) ? (X) : (Y))
X
static int		dir_udp_port = 0;	/* Remote UDP port number */
X
#ifdef CUTCP
# define	NS_TIMEOUT	15
#endif
X
static unsigned short	next_conn_id = 0;
X
/* Always needed externally */
int client_dirsrv_timeout = CLIENT_DIRSRV_TIMEOUT;
int client_dirsrv_retry = CLIENT_DIRSRV_RETRY; 
int rdgram_priority = 0;			/* gf: was in rdgram.h */
X
/* These were parameters to dirsend() */
static PTEXT pkt;
static char *hostname;
static struct sockaddr_in *hostaddr;
X
/* These were locals in dirsend(). Note that the initializations here
X * are really meaningless since we have to redo them for each call to
X * dirsend() since they were formerly automatically initialized.
X */
static PTEXT		first = NULL;	/* First returned packet	 */
static PTEXT		next;		/* The one we are waiting for 	 */
static PTEXT		vtmp;           /* For reorganizing linked list  */
static PTEXT		comp_thru;	/* We have all packets though    */
static int		lp = -1;	/* Opened UDP port	         */
static int		hdr_len;	/* Header Length                 */
static int		nd_pkts;	/* Number of packets we want     */
static int		no_pkts;	/* Number of packets we have     */
static int		pkt_cid;        /* Packet connection identifier  */
static unsigned short	this_conn_id;	/* Connection ID we are using    */
static unsigned short	recvd_thru;	/* Received through              */
static short		priority;	/* Priority for request          */
static short		one = 0;	/* Pointer to value 1            */
static short		zero = 0;	/* Pointer to value 0		 */
static char		*seqtxt;	/* Pointer to text w/ sequence # */
static struct sockaddr_in  us;		/* Our address                   */
static struct sockaddr_in  to;		/* Address to send query	 */
static struct sockaddr_in  from;	/* Reply received from		 */
static int		from_sz;	/* Size of from structure	 */
static struct hostent	*host;		/* Host info from gethostbyname  */
static long		newhostaddr;    /* New host address from *host   */
static int		req_udp_port=0; /* Requested port (optional)     */
static char		*openparen;	/* Delimits port in name         */
static char		hostnoport[500];/* Host name without port        */
static int		ns;		/* Number of bytes actually sent */
static int		nr;		/* Number of bytes received      */
static fd_set	readfds;	/* Used for select		 */
static int		tmp;
static char		*ctlptr;	/* Pointer to control field      */
static short		stmp;		/* Temp short for conversions    */
static int		backoff;	/* Server requested backoff      */
static unsigned char	rdflag11;	/* First byte of flags (bit vect)*/
static unsigned char	rdflag12;	/* Second byte of flags (int)    */
static int		scpflag = 0;	/* Set if any sequencd cont pkts */
static int		ackpend = 0;    /* Acknowledgement pending      */
static int		gaps = 0;	/* Gaps present in recvd pkts   */
static struct timeval	timeout;	/* Time to wait for response    */
static struct timeval	ackwait;	/* Time to wait before acking   */
static struct timeval	gapwait;	/* Time to wait b4 filling gaps */
static struct timeval	*selwait;	/* Time to wait for select      */
static int		retries;	/* was = client_dirsrv_retry    */
char   to_hostname[512];		/* lmjm: saves inet_ntoa() str  */
X
/* These are added so dirsend() "blocks" properly */
static PTEXT dirsendReturn;
static int dirsendDone;
X
/* And here are the values for dirsendDone */
#define DSRET_DONE		1
#define DSRET_SEND_ERROR	-1
#define DSRET_RECV_ERROR	-2
#define DSRET_SELECT_ERROR	-3
#define DSRET_TIMEOUT		-4
#define DSRET_ABORTED		-5
X
/* New procedures to break up dirsend() */
static int initDirsend();
static void retryDirsend(), keepWaitingDirsend();
static void timeoutProc();
static void readProc();
X
/* Wrappers around X calls to allow non-X usage */
static void addInputSource(), removeInputSource();
static void addTimeOut(), removeTimeOut();
static void processEvent();
X
/* External status procedures */
extern void status0(),status1(),status2();
X
#if defined(XARCHIE) || defined(VARCHIE)
static int packetCounter;
#endif
X
/* Extra stuff for the asynchronous X version of dirsend() */
#ifdef XARCHIE
#include <X11/Intrinsic.h>
extern XtAppContext appContext;
#else
#ifdef VARCHIE
#include "xtypes.h"
#else
typedef char *XtPointer;
typedef char *XtInputId;
typedef char *XtIntervalId;
#endif /* VARCHIE */
#endif /* XARCHIE */
X
static XtInputId inputId;
static XtIntervalId timerId = (XtIntervalId)0;
X
/*
X * dirsend - send packet and receive response
X *
X *   DIRSEND takes a pointer to a structure of type PTEXT, a hostname,
X *   and a pointer to a host address.  It then sends the supplied
X *   packet off to the directory server on the specified host.  If
X *   hostaddr points to a valid address, that address is used.  Otherwise,
X *   the hostname is looked up to obtain the address.  If hostaddr is a
X *   non-null pointer to a 0 address, then the address will be replaced
X *   with that found in the hostname lookup.
X *
X *   DIRSEND will wait for a response and retry an appropriate
X *   number of times as defined by timeout and retries (both static
X *   variables).  It will collect however many packets form the reply, and
X *   return them in a structure (or structures) of type PTEXT.
X *
X *   DIRSEND will free the packet that it is presented as an argument.
X *   The packet is freed even if dirsend fails.
X */
PTEXT
dirsend(pkt_p,hostname_p,hostaddr_p)
X    PTEXT pkt_p;
X    char *hostname_p;
X    struct sockaddr_in	*hostaddr_p;
{
X    /* copy parameters to globals since other routines use them */
X    pkt = pkt_p;
X    hostname = hostname_p;
X    hostaddr = hostaddr_p;
X    /* Do the initializations of formerly auto variables */
X    first = NULL;
X    lp = -1;
X    one = 0;
X    zero = 0;
X    req_udp_port=0;
X    scpflag = 0;
X    ackpend = 0;
X    gaps = 0;
X    retries = client_dirsrv_retry;
X
X    if (initDirsend() < 0)
X	return(NULL);
X    addInputSource();
X    /* set the first timeout */
X    retryDirsend();
X
X    dirsendReturn = NULL;
X    dirsendDone = 0;
X    /* Until one of the callbacks says to return, keep processing events */
X    while (!dirsendDone)
X	processEvent();
X    /* Clean up event generators */
X    removeTimeOut();
X    removeInputSource();
#if defined(XARCHIE) || defined(VARCHIE)
X    /* Set status if needed (has to be outside of loop or X will crash) */
X    switch (dirsendDone) {
X	case DSRET_SEND_ERROR: status0("Send error"); break;
X	case DSRET_RECV_ERROR: status0("Recv error"); break;
X        case DSRET_TIMEOUT:
X		status1("Connection to %s timed out",to_hostname);
X		break;
X        case DSRET_ABORTED: status0("Aborted"); break;
X    }
#endif
X    /* Return whatever we're supposed to */
X    return(dirsendReturn);
}
X
X
/*	-	-	-	-	-	-	-	-	*/
/* This function does all the initialization that used to be done at the
X * start of dirsend(), including opening the socket descriptor "lp". It
SHAR_EOF
true || echo 'restore of xarchie-2.0.6/dirsend.c failed'
fi
echo 'End of xarchie-2.0.6 part 6'
echo 'File xarchie-2.0.6/dirsend.c is continued in part 7'
echo 7 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM       | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@imd.sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
