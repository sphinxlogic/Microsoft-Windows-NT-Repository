Newsgroups: comp.sources.x
From: ferguson@cs.rochester.edu (George Ferguson)
Subject: v20i044:  xarchie - An X browser interface to Archie, v2.0.6, Part16/24
Message-ID: <1993Jun15.223431.1197@sparky.imd.sterling.com>
X-Md4-Signature: 75361862115bc76d47bad84e28719b59
Sender: chris@sparky.imd.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Tue, 15 Jun 1993 22:34:31 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: ferguson@cs.rochester.edu (George Ferguson)
Posting-number: Volume 20, Issue 44
Archive-name: xarchie/part16
Environment: X11
Supersedes: xarchie: Volume 14, Issue 82-90

Submitted-by: ferguson@cs.rochester.edu
Archive-name: xarchie-2.0.6/part16

#!/bin/sh
# this is Part.16 (part 16 of xarchie-2.0.6)
# do not concatenate these parts, unpack them in order with /bin/sh
# file xarchie-2.0.6/types.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 16; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping xarchie-2.0.6/types.c'
else
echo 'x - continuing file xarchie-2.0.6/types.c'
sed 's/^X//' << 'SHAR_EOF' >> 'xarchie-2.0.6/types.c' &&
X *		             to-font-struct converter.
X */
X
#include <X11/IntrinsicP.h>
#include <X11/StringDefs.h>
#include <X11/Xaw/Form.h>
#include <X11/Xaw/Cardinals.h>
#include "types.h"
#include "xarchie.h"
#include "appres.h"
#include "stringdefs.h"
extern void XmuCvtStringToWidget();	/* original old-style converter */
X
/*
X * In R5, more of the default converters are available externally.
X * For R4 however, the string-to-font converters are static, so we
X * include the appropriate code below.
X */
#if XtSpecificationRelease<5
static Boolean CvtStringToFontStruct();		/* original static converter */
static int CompareISOLatin1();
#else
extern Boolean XtCvtStringToFontStruct();	/* original converter */
#endif
X
/*
X * Functions defined here:
X */
void initConverters();
SearchType stringToSearchType();
SortType stringToSortType();
char *searchTypeToString(),*sortTypeToString();
X
static void strcpyLowered();
static Boolean cvtStringToSearchType(),cvtStringToSortType();
static Boolean cvtStringToFontStruct();
static void cvtStringToWidget(); /* old-style converter */
X
/* Straight from the Xt manual... */
#define done(TYPE,VALUE)\
{							\
X    if (toVal->addr != NULL) {				\
X	if (toVal->size < sizeof(TYPE)) {		\
X	    toVal->size = sizeof(TYPE);			\
X	    return(False);				\
X	}						\
X	*(TYPE *)(toVal->addr) = (VALUE);		\
X    } else {						\
X	static TYPE static_val;				\
X	static_val = (VALUE);				\
X	toVal->addr = (XtPointer)&static_val;		\
X    }							\
X    toVal->size = sizeof(TYPE);				\
X    return(True);					\
}
X							
void
initConverters(appContext)
XXtAppContext appContext;
{
X    static XtConvertArgRec parentCvtArgs[] = {
X        {XtBaseOffset, (caddr_t)XtOffset(Widget, core.parent), sizeof(Widget)}
X    };
X    static XtConvertArgRec displayCvtArgs[] = {
X	{XtAddress, (XtPointer)&display, sizeof(Display*)},
X    };
X
X    /* Specify XtCacheNone for some reason, broke otherwise */
X    XtSetTypeConverter(XtRString,GfRSearchType,cvtStringToSearchType,
X		       NULL,ZERO,XtCacheNone,NULL);
X    XtSetTypeConverter(XtRString,GfRSortType,cvtStringToSortType,
X		       NULL,ZERO,XtCacheNone,NULL);
X    /* Override default here */
X    XtSetTypeConverter(XtRString,XtRFontStruct,cvtStringToFontStruct,
X		       displayCvtArgs,XtNumber(displayCvtArgs),
X		       XtCacheByDisplay,NULL);
X    /* Have to initialize Form class first or our converter will be	*/
X    /* overidden by the class initialization function.			*/
X    /* Use the old style here on purpose since that what the default is.*/
X    XtInitializeWidgetClass(formWidgetClass);
X    XtAppAddConverter(appContext,XtRString,XtRWidget,cvtStringToWidget,
X					parentCvtArgs,XtNumber(parentCvtArgs));
}
X
/*	-	-	-	-	-	-	-	-	*/
/* Xt converters */
static void
strcpyLowered(dst,src)
char *dst,*src;
{
X    do {
X	if (*src >= 'A' && *src <= 'Z')
X	    *dst++ = *src - 'A' + 'a';
X	else
X	    *dst++ = *src;
X    } while (*src++);
}
X
/* ARGSUSED */
static Boolean
cvtStringToSearchType(display,args,num_args,fromVal,toVal,data)
X    Display *display;
X    XrmValuePtr args;		/* unused */
X    Cardinal    *num_args;      /* unused */
X    XrmValuePtr fromVal;
X    XrmValuePtr toVal;
X    XtPointer *data;		/* unused */
{
X    char message[256];
X    SearchType type;
X
X    strcpyLowered(message,(char*)(fromVal->addr));
X    if ((type=stringToSearchType(message)) != GfError)
X	done(SearchType,type);
X    XtDisplayStringConversionWarning(display,fromVal->addr,GfRSearchType);
X    toVal->addr = NULL;
X    toVal->size = 0;
X    return(False);
}
X
/* ARGSUSED */
static Boolean
cvtStringToSortType(display,args,num_args,fromVal,toVal,data)
X    Display *display;
X    XrmValuePtr args;		/* unused */
X    Cardinal    *num_args;      /* unused */
X    XrmValuePtr fromVal;
X    XrmValuePtr toVal;
X    XtPointer *data;		/* unused */
{
X    char message[256];
X    SortType type;
X
X    strcpyLowered(message,(char*)(fromVal->addr));
X    if ((type=stringToSortType(message)) != GfError)
X	done(SortType,type);
X    XtDisplayStringConversionWarning(display,fromVal->addr,GfRSortType);
X    toVal->addr = NULL;
X    toVal->size = 0;
X    return(False);
}
X
/*	-	-	-	-	-	-	-	-	*/
/*
X * cvtStringToFontStruct() : This just checks for the two special names
X *	"xarchieFont" and "xarchieBoldFont" and returns the appropriate
X *	application resource. Otherwise invokes the default converter.
X */
X
/* ARGSUSED */
static Boolean
cvtStringToFontStruct(display,args,num_args,fromVal,toVal,data)
X    Display *display;
X    XrmValuePtr args;
X    Cardinal    *num_args;
X    XrmValuePtr fromVal;
X    XrmValuePtr toVal;
X    XtPointer *data;
{
X    char message[256];
X
X    strcpyLowered(message,(char*)(fromVal->addr));
X    if (strcmp(message,"xarchiefont") == 0)
X	done(XFontStruct*,appResources.xarchieFont);
X    if (strcmp(message,"xarchieboldfont") == 0)
X	done(XFontStruct*,appResources.xarchieBoldFont);
#if XtSpecificationRelease<5
X    return(CvtStringToFontStruct(display,args,num_args,fromVal,toVal,data));
#else
X    return(XtCvtStringToFontStruct(display,args,num_args,fromVal,toVal,data));
#endif
}
X
/*	-	-	-	-	-	-	-	-	*/
/*
X * cvtStringToWidget() : Allows us to specify "NULL" as a widget name in
X *	a resource file to override compiled-in defaults for composite
X *	widget layouts. Simply calls the regular converter if the string
X *	is not "NULL". Note that this must be registered *after* the
X *	Form class is initialized.
X */
static void
cvtStringToWidget(args,num_args,fromVal,toVal)
XXrmValuePtr args;
Cardinal *num_args;
XXrmValuePtr fromVal;
XXrmValuePtr toVal;
{
X    if (strcasecmp(fromVal->addr,"null") == 0) {
X	toVal->addr = NULL;
X	toVal->size = 0;
X    } else {
X	XmuCvtStringToWidget(args,num_args,fromVal,toVal);
X    }
}
X
/*	-	-	-	-	-	-	-	-	*/
/* Useful generic converters */
X
SearchType
stringToSearchType(s)
char *s;
{
X    if (strcmp(s,GfNExact) == 0)
X	return(GfExact);
X    if (strcmp(s,GfNSubstr) == 0)
X	return(GfSubstr);
X    if (strcmp(s,GfNSubcase) == 0)
X	return(GfSubcase);
X    if (strcmp(s,GfNRegexp) == 0)
X	return(GfRegexp);
X    if (strcmp(s,GfNExactSubstr) == 0)
X	return(GfExactSubstr);
X    if (strcmp(s,"GfNExactSubcase") == 0)
X	return(GfExactSubcase);
X    if (strcmp(s,"GfNExactRegexp") == 0)
X	return(GfExactRegexp);
X    return(GfError);
}
X
char *
searchTypeToString(type)
SearchType type;
{
X    switch (type) {
X	case GfExact :		return(GfNExact);
X	case GfSubstr : 	return(GfNSubstr);
X	case GfSubcase :	return(GfNSubcase);
X	case GfRegexp :  	return(GfNRegexp);
X	case GfExactSubstr :	return(GfNExactSubstr);
X	case GfExactSubcase :	return(GfNExactSubcase);
X	case GfExactRegexp :	return(GfNExactRegexp);
X	default: return("UNKNOWN");
X    }
}
X
SortType
stringToSortType(s)
char *s;
{
X    if (strcmp(s,GfNName) == 0)
X	return(GfName);
X    if (strcmp(s,GfNDate) == 0)
X	return(GfDate);
X    if (strcmp(s,GfNWeight) == 0)
X	return(GfWeight);
X    return(GfError);
}
X
char *
sortTypeToString(type)
SortType type;
{
X    switch (type) {
X	case GfName : return(GfNName);
X	case GfDate : return(GfNDate);
X	case GfWeight : return(GfNWeight);
X	default: return("UNKNOWN");
X    }
}
X
/*	-	-	-	-	-	-	-	-	*/
/* The string-to-font-struct converter was static in R4 (and earlier?)
X * so we include it here if necessary. This code is taken from the
X * file lib/Xt/Converters.c in the R4 distribution.
X */
X
#if XtSpecificationRelease<5
/***********************************************************
Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
X
X                        All Rights Reserved
X
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Digital or MIT not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  
X
DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.
X
******************************************************************/
X
#include <X11/keysym.h>
#include <X11/Quarks.h>
X
/*ARGSUSED*/
static Boolean
CvtStringToFontStruct(dpy, args, num_args, fromVal, toVal, closure_ret)
X    Display*	dpy;
X    XrmValuePtr args;
X    Cardinal    *num_args;
X    XrmValuePtr	fromVal;
X    XrmValuePtr	toVal;
X    XtPointer	*closure_ret;
{
X    XFontStruct	    *f;
X    Display*	display;
X
X    if (*num_args != 1)
X     XtAppErrorMsg(XtDisplayToApplicationContext(dpy),
X	     "wrongParameters","cvtStringToFontStruct","XtToolkitError",
X             "String to font conversion needs display argument",
X              (String *) NULL, (Cardinal *)NULL);
X
X    display = *(Display**)args[0].addr;
X
X    if (CompareISOLatin1((String)fromVal->addr, XtDefaultFont) != 0) {
X	f = XLoadQueryFont(display, (char *)fromVal->addr);
X	if (f != NULL) {
X  Done:	    done( XFontStruct*, f);
X	}
X
X	XtDisplayStringConversionWarning( dpy, (char*)fromVal->addr,
X					  "FontStruct" );
X    }
X
X    /* try and get the default font */
X
X    {
X	XrmName xrm_name[2];
X	XrmClass xrm_class[2];
X	XrmRepresentation rep_type;
X	XrmValue value;
X
X	xrm_name[0] = XrmStringToName ("xtDefaultFont");
X	xrm_name[1] = NULL;
X	xrm_class[0] = XrmStringToClass ("XtDefaultFont");
X	xrm_class[1] = NULL;
X	if (XrmQGetResource(XtDatabase(dpy), xrm_name, xrm_class, 
X			    &rep_type, &value)) {
X	    if (rep_type == XtQString) {
X		f = XLoadQueryFont(display, (char*)value.addr);
X		if (f != NULL)
X		    goto Done;
X		else {
X		    XtDisplayStringConversionWarning( dpy, (char*)value.addr,
X						      "FontStruct" );
X		}
X	    } else if (rep_type == XtQFont) {
X		f = XQueryFont(dpy, *(Font*)value.addr );
X		if (f != NULL) goto Done;
X	    } else if (rep_type == XtQFontStruct) {
X		f = (XFontStruct*)value.addr;
X		goto Done;
X	    }
X	}
X    }
X    /* Should really do XListFonts, but most servers support this */
X    f = XLoadQueryFont(dpy,"-*-*-*-R-*-*-*-120-*-*-*-*-ISO8859-1");
X    if (f != NULL)
X	goto Done;
X
X    XtAppErrorMsg(XtDisplayToApplicationContext(dpy),
X	     "noFont","cvtStringToFontStruct","XtToolkitError",
X             "Unable to load any useable ISO8859-1 font",
X              (String *) NULL, (Cardinal *)NULL);
X    
X    return False;
}
X
static int CompareISOLatin1 (first, second)
X    char *first, *second;
{
X    register unsigned char *ap, *bp;
X
X    for (ap = (unsigned char *) first, bp = (unsigned char *) second;
X	 *ap && *bp; ap++, bp++) {
X	register unsigned char a, b;
X
X	if ((a = *ap) != (b = *bp)) {
X	    /* try lowercasing and try again */
X
X	    if ((a >= XK_A) && (a <= XK_Z))
X	      a += (XK_a - XK_A);
X	    else if ((a >= XK_Agrave) && (a <= XK_Odiaeresis))
X	      a += (XK_agrave - XK_Agrave);
X	    else if ((a >= XK_Ooblique) && (a <= XK_Thorn))
X	      a += (XK_oslash - XK_Ooblique);
X
X	    if ((b >= XK_A) && (b <= XK_Z))
X	      b += (XK_a - XK_A);
X	    else if ((b >= XK_Agrave) && (b <= XK_Odiaeresis))
X	      b += (XK_agrave - XK_Agrave);
X	    else if ((b >= XK_Ooblique) && (b <= XK_Thorn))
X	      b += (XK_oslash - XK_Ooblique);
X
X	    if (a != b) break;
X	}
X    }
X    return (((int) *bp) - ((int) *ap));
}
#endif /* <R5 */
SHAR_EOF
echo 'File xarchie-2.0.6/types.c is complete' &&
chmod 0644 xarchie-2.0.6/types.c ||
echo 'restore of xarchie-2.0.6/types.c failed'
Wc_c="`wc -c < 'xarchie-2.0.6/types.c'`"
test 11840 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/types.c: original size 11840, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/types.h ==============
if test -f 'xarchie-2.0.6/types.h' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/types.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/types.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/types.h' &&
/*
X * types.h : Definitions of SearchType and SortType
X *
X * George Ferguson, ferguson@cs.rochester.edu, 4 Sep 1991.
X * Version 2.0: 23 Apr 1993.
X */
X
#ifndef TYPES_H
#define TYPES_H
X
/* These codes correspond to Prospero key letters */
#define GfExact		'='
#define GfSubstr	'S'
#define GfSubcase	'C'
#define GfRegexp	'R'
#define GfExactSubstr	's'
#define GfExactSubcase	'c'
#define GfExactRegexp	'r'
X
typedef char SearchType;
X
#define GfRSearchType	"SearchType"
#define GfNExact	"exact"
#define GfNSubstr	"substr"
#define GfNSubcase	"subcase"
#define GfNRegexp	"regexp"
#define GfNExactSubstr	"exactsubstr"
#define GfNExactSubcase	"exactsubcase"
#define GfNExactRegexp	"exactregexp"
X
/* This puke is so the bloody converters work. Argh! */
#define GfName		'\001'
#define GfDate		'\002'
#define GfWeight	'\003'
X
typedef char SortType;
X
#define GfRSortType	"SortType"
#define GfNName		"name"
#define GfNDate		"date"
#define GfNWeight	"weight"
X
/* Since these are both char's we can use one constant for errors */
#define GfError		'\0'
X
extern void initConverters();
extern SearchType stringToSearchType();
extern SortType stringToSortType();
extern char *searchTypeToString(),*sortTypeToString();
X
#endif /* TYPES_H */
SHAR_EOF
chmod 0644 xarchie-2.0.6/types.h ||
echo 'restore of xarchie-2.0.6/types.h failed'
Wc_c="`wc -c < 'xarchie-2.0.6/types.h'`"
test 1218 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/types.h: original size 1218, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/udp.c ==============
if test -f 'xarchie-2.0.6/udp.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/udp.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/udp.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/udp.c' &&
/*
X * udp - Check if UDP traffic is allowed on this host; we open port 1527 on
X *       a system (default of cs.widener.edu), which is expecting it; the
X *       date is output (e.g. very similar to the daytime service).  This
X *       will conclusively tell us if UDP traffic on ports > 1000 is allowed.
X *
X *	It should print out the date if UDP traffic's not blocked on your
X *	system.  If it just hangs, try these tests too:
X *	  a. run it with -d  (e.g. "udp -d"); that goes to the normal UDP port
X *	     to print the date.  If it works, then you can be sure that any
X *	     UDP traffic > port 1000 is blocked on your system.
X *	  b. if it hangs too, try "telnet 147.31.254.130 13" and see if
X *	     _that_ prints the date; if it doesn't, it's another problem (your
X *	     network can't get to me, e.g.).
X *
X * Compile by: cc -o udp udp.c
X *
X * Brendan Kehoe, brendan@cs.widener.edu, Oct 1991.
X */
X
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#ifndef hpux
# include <arpa/inet.h>
#endif
X
#define	SIZE	2048
#define	HOST	"147.31.254.130"	/* cs.widener.edu */
#define PORT	1527
X
main (argc, argv)
X     int argc;
X     char **argv;
{
X  int s, len;
X  struct sockaddr_in server, sa;
X  char buf[SIZE];
X
X  if ((s = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
X    {
X      perror ("socket()");
X      exit (1);
X    }
X
X  bzero ((char *) &sa, sizeof (sa));
X  sa.sin_family = AF_INET;
X  sa.sin_addr.s_addr = htonl (INADDR_ANY);
X  sa.sin_port = htons (0);
X
X  if (bind (s, (struct sockaddr *) &sa, sizeof (sa)) < 0)
X    {
X      perror ("bind()");
X      exit (1);
X    }
X
X  bzero ((char *) &server, sizeof (server));
X  server.sin_family = AF_INET;
X  server.sin_addr.s_addr = inet_addr (HOST);
X  if (argc > 1 && strcmp(*(argv + 1), "-d") == 0)
X    server.sin_port = htons ((unsigned short) 13);
X  else
X    server.sin_port = htons ((unsigned short) PORT);
X
X  /* yoo hoo, we're here .. */
X  if (sendto (s, "\n", 1, 0, &server, sizeof (server)) < 0)
X    {
X      perror ("sendto()");
X      exit (1);
X    }
X
X  /* slurp */
X  len = sizeof (server);
X  if (recvfrom (s, buf, sizeof (buf), 0, &server, &len) < 0)
X    {
X      perror ("recvfrom");
X      exit (1);
X    }
X
X  printf ("%s", buf);
X  close (s);
}
SHAR_EOF
chmod 0644 xarchie-2.0.6/udp.c ||
echo 'restore of xarchie-2.0.6/udp.c failed'
Wc_c="`wc -c < 'xarchie-2.0.6/udp.c'`"
test 2234 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/udp.c: original size 2234, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/username.c ==============
if test -f 'xarchie-2.0.6/username.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/username.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/username.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/username.c' &&
/*
X * username.c : Some people are tricky about this...
X *
X * George Ferguson, ferguson@cs.rochester.edu, 23 Apr 1993.
X *
X * Compile-time parameters (config.h):
X *	HAVE_PWD :      File <pwd.h> defines getpwuid()
X *	HAVE_GETLOGIN : Function char *getlogin() exists
X */
#include <stdio.h>
#include "config.h"
X
#include <sys/types.h>
extern uid_t getuid();		/* not in stdlib.h, but is in unistd.h */
extern char *getenv();
#ifdef HAVE_GETPWUID
#include <pwd.h>
#endif
#ifdef HAVE_GETLOGIN
extern char *getlogin();
#endif
X
char *
GetUsername()
{
X    char *username;
X
#ifdef HAVE_GETPWUID
X    struct passwd *pwe;
X    if ((pwe=getpwuid(getuid())) != NULL)
X	    username = pwe->pw_name;
X    else
#endif
#ifdef HAVE_GETLOGIN
X	if ((username=getlogin()) == NULL)
#endif
X	    if ((username=getenv("USER")) == NULL) {
X		fprintf(stderr,"Couldn't find username, you should set $USER");
X		username = "anonymous";
X	    }
X    return(username);
}
X
#ifdef STANDALONE
main()
{
X    printf("%s\n",GetUsername());
X    exit(0);
}
#endif /* STANDALONE */
SHAR_EOF
chmod 0644 xarchie-2.0.6/username.c ||
echo 'restore of xarchie-2.0.6/username.c failed'
Wc_c="`wc -c < 'xarchie-2.0.6/username.c'`"
test 1030 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/username.c: original size 1030, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/username.h ==============
if test -f 'xarchie-2.0.6/username.h' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/username.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/username.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/username.h' &&
/*
X * username.h : Definition of "portable" username function
X *
X * George Ferguson, ferguson@cs.rochester.edu, 23 Apr 1993.
X */
X
extern char *GetUsername();
SHAR_EOF
chmod 0644 xarchie-2.0.6/username.h ||
echo 'restore of xarchie-2.0.6/username.h failed'
Wc_c="`wc -c < 'xarchie-2.0.6/username.h'`"
test 158 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/username.h: original size 158, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/view-file.c ==============
if test -f 'xarchie-2.0.6/view-file.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/view-file.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/view-file.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/view-file.c' &&
/*
X * view-file.c : Routines for the windows when files are "opened" via ftp
X *
X * George Ferguson, ferguson@cs.rochester.edu, 23 Apr 1993.
X */
#include <stdio.h>
#include <X11/Intrinsic.h>
#include <X11/Shell.h>
#include <X11/StringDefs.h>
#include <X11/Xaw/Form.h>
#include <X11/Xaw/Label.h>
#include <X11/Xaw/Command.h>
#include <X11/Xaw/AsciiText.h>
#include "config.h"
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#include "xarchie.h"
#include "fchooser.h"
#include "stringdefs.h"
#include "xutil.h"
#include "syserr.h"
#include "debug.h"
X
/*
X * Functions defined here:
X */
void viewFile();
X
static void nonmaskableEventHandler();
static void viewDone(),viewDown(),viewUp(),viewSave();
static void viewSaveOk(),viewSaveCancel();
static int fileCopy();
X
/*
X * Data defined here:
X */
typedef struct _ViewFileInfo {
X    Widget shell;
X    Widget text;
X    String filename;
} ViewFileInfo;
X
/*	-	-	-	-	-	-	-	-	*/
X
void
viewFile(filename)
char *filename;
{
X    ViewFileInfo *vfinfo;
X    Widget form,button;
X    Arg args[2];
X
X    vfinfo = XtNew(ViewFileInfo);
X    vfinfo->filename = XtNewString(filename);
X    XtSetArg(args[0],XtNtitle,filename);
X    vfinfo->shell = XtCreatePopupShell("viewShell",topLevelShellWidgetClass,
X				       toplevel,args,1);
X    form = XtCreateManagedWidget("viewForm",formWidgetClass,
X				 vfinfo->shell,NULL,0);
X    button = XtCreateManagedWidget("viewDoneButton",commandWidgetClass,
X				   form,NULL,0);
X    XtAddCallback(button,XtNcallback,viewDone,(XtPointer)vfinfo);
X    button = XtCreateManagedWidget("viewDownButton",commandWidgetClass,
X				   form,NULL,0);
X    XtAddCallback(button,XtNcallback,viewDown,(XtPointer)vfinfo);
X    button = XtCreateManagedWidget("viewUpButton",commandWidgetClass,
X				   form,NULL,0);
X    XtAddCallback(button,XtNcallback,viewUp,(XtPointer)vfinfo);
X    button = XtCreateManagedWidget("viewSaveButton",commandWidgetClass,
X				   form,NULL,0);
X    XtAddCallback(button,XtNcallback,viewSave,(XtPointer)vfinfo);
X    XtSetArg(args[0],XtNtype,XawAsciiFile);
X    XtSetArg(args[1],XtNstring,filename);
X    vfinfo->text = XtCreateManagedWidget("viewText",asciiTextWidgetClass,
X					 form,args,2);
X    XtRealizeWidget(vfinfo->shell);
X    /* Allow WM_DELETE_WINDOW to the Shell to be Done */
X    (void)XSetWMProtocols(XtDisplay(vfinfo->shell),XtWindow(vfinfo->shell),
X			  &WM_DELETE_WINDOW,1);
X    XtAddEventHandler(vfinfo->shell,NoEventMask,True,
X		      nonmaskableEventHandler,(XtPointer)vfinfo);
X    XtPopup(vfinfo->shell,XtGrabNone);
}
X
/*
X * Nonmaskable event handler for Shell: If the event is a ClientMessage
X * of WM_PROTOCOLS then act as if Done had been clicked.
X */
/*ARGSUSED*/
static void
nonmaskableEventHandler(w,client_data,event,continue_to_dispatch)
Widget w;
XXtPointer client_data;
XXEvent *event;
Boolean *continue_to_dispatch;
{
X    DEBUG1("nonmaskableHandler: w=0x%x\n",w);
X    if (event->type == ClientMessage &&
X        event->xclient.data.l[0] == WM_DELETE_WINDOW) {
X	DEBUG0("nonmaskableHandler: calling cancelButtonCallback\n");
X	viewDone(NULL,client_data,NULL);
X    }
X    DEBUG0("nonmaskableHandler: done\n");
}
X
/*	-	-	-	-	-	-	-	-	*/
/* Callbacks for the view window */
X
/*ARGSUSED*/
static void
viewDone(w,client_data,call_data)
Widget w;
XXtPointer client_data;		/* ViewFileInfo */
XXtPointer call_data;		/* not used */
{
X    ViewFileInfo *vfinfo = (ViewFileInfo *)client_data;
X    char *name;
X
X    DEBUG0("viewDone...\n");
X    name = getWidgetString(vfinfo->text);
X    if (name != NULL && *name != '\0') {
X	DEBUG1("viewDone: unlinking \"%s\"\n",name);
X	if (unlink(name) < 0)
X	    sysError(name);
X    }
X    XtPopdown(vfinfo->shell);
X    XtUnrealizeWidget(vfinfo->shell);
X    XtDestroyWidget(vfinfo->shell);
X    XtFree(vfinfo->filename);
X    XtFree((char*)vfinfo);
X    DEBUG0("viewDone: done\n");
}
X
/*ARGSUSED*/
static void
viewDown(w,client_data,call_data)
Widget w;
XXtPointer client_data;		/* ViewFileInfo */
XXtPointer call_data;		/* not used */
{
X    ViewFileInfo *vfinfo = (ViewFileInfo *)client_data;
X
X    XtCallActionProc(vfinfo->text,"next-page",NULL,NULL,0);
}
X
/*ARGSUSED*/
static void
viewUp(w,client_data,call_data)
Widget w;
XXtPointer client_data;		/* ViewFileInfo */
XXtPointer call_data;		/* not used */
{
X    ViewFileInfo *vfinfo = (ViewFileInfo *)client_data;
X
X    XtCallActionProc(vfinfo->text,"previous-page",NULL,NULL,0);
}
X
/*ARGSUSED*/
static void
viewSave(w,client_data,call_data)
Widget w;
XXtPointer client_data;		/* ViewFileInfo */
XXtPointer call_data;		/* not used */
{
X    ViewFileInfo *vfinfo = (ViewFileInfo *)client_data;
X    FileChooserInfo *fcinfo;
X    Widget shell,form,text;
X    char *name,*basename;
X    Arg args[1];
X
X    DEBUG0("viewSave...\n");
X    setBusyStatus(True);
X    shell = XtCreatePopupShell("viewSaveShell",topLevelShellWidgetClass,
X			       vfinfo->shell,NULL,0);
X    form = XtCreateManagedWidget("viewSaveForm",formWidgetClass,
X				 shell,NULL,0);
X    (void)XtCreateManagedWidget("viewSaveLabel",labelWidgetClass,
X				form,NULL,0);
X    text = XtCreateManagedWidget("viewSaveLabelText",asciiTextWidgetClass,
X				 form,NULL,0);
X    name = vfinfo->filename;
X    setWidgetString(text,name);
X    fcinfo = createFileChooser(shell,form,"viewSave",viewSaveOk,
X			       viewSaveCancel,(XtPointer)vfinfo);
X    /* Adjust vertical layout */
X    XtSetArg(args[0],XtNfromVert,text);
#ifdef FILECHOOSER
X    XtSetValues(fcinfo->fcw,args,1);
#else
X    XtSetValues(fcinfo->text,args,1);
#endif
X    /* Realize them all */
X    XtRealizeWidget(shell);
X    /* Set initial filename (has to be after realize for some reason) */
X    if ((basename=rindex(name,'/')) != NULL)
X	name = basename+1;
X    setWidgetString(fcinfo->text,name);
X    /* Register window for WM */
X    (void)XSetWMProtocols(XtDisplay(shell),XtWindow(shell),
X			  &WM_DELETE_WINDOW,1);
X    /* Here we go */
X    XtPopup(shell,XtGrabNone);
X    setBusyStatus(False);
X    DEBUG0("viewSave: done\n");
}
X
/*	-	-	-	-	-	-	-	-	*/
/* Callbacks from the view-save FileChooser */
X
/*ARGSUSED*/
static void
viewSaveOk(fcinfo,filename,client_data)
FileChooserInfo *fcinfo;
char *filename;
XXtPointer client_data;		/* ViewFileInfo */
{
X    ViewFileInfo *vfinfo = (ViewFileInfo *)client_data;
X
X    DEBUG1("viewSaveOk: fcinfo=0x%x\n",fcinfo);
X    DEBUG2("viewSaveOk: copying \"%s\" to \"%s\"\n",vfinfo->filename,filename);
X    if (fileCopy(vfinfo->filename,filename) >= 0) {
X	/* Remove the File Selector if successful */
X	XtPopdown(fcinfo->shell);
X	XtUnrealizeWidget(fcinfo->shell);
X	XtDestroyWidget(fcinfo->shell);
X	XtFree((char*)fcinfo);
X    }
X    DEBUG0("viewSaveOk: done\n");
}
X
/*ARGSUSED*/
static void
viewSaveCancel(fcinfo,client_data)
FileChooserInfo *fcinfo;
XXtPointer client_data;		/* ViewFileInfo */
{
X    DEBUG1("viewSaveCancel: fcinfo=0x%x\n",fcinfo);
X    XtPopdown(fcinfo->shell);
X    XtUnrealizeWidget(fcinfo->shell);
X    XtDestroyWidget(fcinfo->shell);
X    XtFree((char*)fcinfo);
X    DEBUG0("viewSaveCancel: done\n");
}
X
/*	-	-	-	-	-	-	-	-	*/
/* Misc. functions */
X
static int
fileCopy(path1,path2)
char *path1,*path2;
{
X    FILE *infp,*outfp;
X    char buf[BUFSIZ];
X    int n,retcode;
X
X    DEBUG2("fileCopy: \"%s\" \"%s\"\n",path1,path2);
X    if ((infp=fopen(path1,"r")) == NULL) {
X	sysError(path1);
X	return(-1);
X    }
X    if ((outfp=fopen(path2,"w")) == NULL) {
X	sysError(path2);
X	return(-1);
X    }
X    retcode = 0;
X    while (!feof(infp)) {
X	if ((n=fread(buf,1,sizeof(buf),infp)) <= 0) {
X	    sysError("read");
X	    retcode = -1;
X	    break;
X	}
X	if (fwrite(buf,1,n,outfp) != n) {
X	    sysError("write");
X	    retcode = -1;
X	    break;
X	}
X    }
X    fclose(infp);
X    fclose(outfp);
X    DEBUG0("fileCopy: done\n");
X    return(retcode);
}
SHAR_EOF
chmod 0644 xarchie-2.0.6/view-file.c ||
echo 'restore of xarchie-2.0.6/view-file.c failed'
Wc_c="`wc -c < 'xarchie-2.0.6/view-file.c'`"
test 7619 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/view-file.c: original size 7619, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/view-file.h ==============
if test -f 'xarchie-2.0.6/view-file.h' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/view-file.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/view-file.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/view-file.h' &&
/*
X * view-file.c : Defs for the popus when files are "opened" via ftp
X *
X * George Ferguson, ferguson@cs.rochester.edu, 23 Apr 1993.
X */
X
extern void initViewerActions();
extern void viewFile();
SHAR_EOF
chmod 0644 xarchie-2.0.6/view-file.h ||
echo 'restore of xarchie-2.0.6/view-file.h failed'
Wc_c="`wc -c < 'xarchie-2.0.6/view-file.h'`"
test 196 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/view-file.h: original size 196, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/vl_comp.c ==============
if test -f 'xarchie-2.0.6/vl_comp.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/vl_comp.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/vl_comp.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/vl_comp.c' &&
/*
X * Copyright (c) 1989, 1990, 1991 by the University of Washington
X *
X * For copying and distribution information, please see the file
X * <copyright.h>.
X */
X
#include <copyright.h>
#include <pfs.h>
X
/*
X * vl_comp - compare the names of two virtual links
X *
X *           VL_COMP compares the names of two links.  It returns
X *           0 if they are equal, negative if vl1 < vl2, and positive if
X *           vl1 > vl2.
X *
X *    ARGS:  vl1,vl2 - Virtual links to be compared
X * 
X * RETURNS:  0 if equal, + is vl1 > vl2, - if vl1 < vl2
X *
X *   NOTES:  Order of significance is as follows.  Existence,
X *           name.  If names do not exist, then hosttype, host,
X *           native filenametype, native filename.  The only time
X *           the name will not exist if if the link is a union link.
X */
int
vl_comp(vl1,vl2)
X    VLINK	vl1;
X    VLINK	vl2;
X    {
X	int	retval;
X
X	if(vl1->name && !vl2->name) return(1);
X	if(!vl1->name && vl2->name) return(-1);
X	if(vl1->name && vl2->name && (*(vl1->name) || *(vl2->name)))
X	    return(strcmp(vl1->name,vl2->name));
X
X	retval = strcmp(vl1->hosttype,vl2->hosttype);
X	if(!retval) retval = strcmp(vl1->host,vl2->host);
X	if(!retval) retval = strcmp(vl1->nametype,vl2->nametype);
X	if(!retval) retval = strcmp(vl1->filename,vl2->filename);
X	return(retval);
X    }
X
/*
X * vl_equal - compare the values of two virtual links
X *
X *           VL_EQUAL compares the values of two links.  It returns
X *           1 if all important fields are the same, and 0 otherwise.
X *
X *    ARGS:  vl1,vl2 - Virtual links to be compared
X * 
X * RETURNS:  1 if equal, 0 if not equal
X *
X */
int
vl_equal(vl1,vl2)
X    VLINK	vl1;
X    VLINK	vl2;
X    {
X      return strcmp(vl1->name, vl2->name) == 0         &&
X	     vl1->linktype == vl2->linktype            &&
X	     strcmp(vl1->type, vl2->type) == 0         &&
X	     strcmp(vl1->hosttype, vl2->hosttype) == 0 &&
X	     strcmp(vl1->host, vl2->host) == 0         &&
X	     strcmp(vl1->nametype, vl2->nametype) == 0 &&
X	     strcmp(vl1->filename, vl2->filename) == 0 &&
X	     vl1->version == vl2->version              &&
X	     vl1->f_magic_no == vl2->f_magic_no        ;
X
X    }
X
SHAR_EOF
chmod 0644 xarchie-2.0.6/vl_comp.c ||
echo 'restore of xarchie-2.0.6/vl_comp.c failed'
Wc_c="`wc -c < 'xarchie-2.0.6/vl_comp.c'`"
test 2137 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/vl_comp.c: original size 2137, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/vlalloc.c ==============
if test -f 'xarchie-2.0.6/vlalloc.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/vlalloc.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/vlalloc.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/vlalloc.c' &&
/*
X * Copyright (c) 1989, 1990, 1991 by the University of Washington
X *
X * For copying and distribution information, please see the file
X * <copyright.h>.
X *
X * v1.1.2 - gf  11/02/91 - renamed ZERO() to BZERO() for X
X */
X
#include <copyright.h>
#include <stdio.h>
X
#include <pfs.h>
#include "config.h"				/* gf */
#include "stringdefs.h"				/* gf */
X
static VLINK	lfree = NULL;
int		vlink_count = 0;
int		vlink_max = 0;
X
/*
X * vlalloc - allocate and initialize vlink structure
X *
X *    VLALLOC returns a pointer to an initialized structure of type
X *    VLINK.  If it is unable to allocate such a structure, it
X *    returns NULL.
X */
VLINK
vlalloc()
X    {
X	VLINK	vl;
X	if(lfree) {
X	    vl = lfree;
X	    lfree = lfree->next;
X	}
X	else {
X	    vl = (VLINK) malloc(sizeof(VLINK_ST));
X	    if (!vl) return(NULL);
X	    vlink_max++;
X	}
X
X	vlink_count++;
X
X	/* Initialize and fill in default values */
X	/* Since all but four are set to a zero-value,
X	   why not just wipe it clean?  */
X	BZERO(vl);
X
X	vl->linktype = 'L';
X	vl->type = stcopy("FILE");
X	vl->hosttype = stcopy("INTERNET-D");
X	vl->nametype = stcopy("ASCII");
X
X	return(vl);
X    }
X
/*
X * vlfree - free a VLINK structure
X *
X *    VLFREE takes a pointer to a VLINK structure and adds it to
X *    the free list for later reuse.
X */
void
vlfree(vl)
X    VLINK	vl;
X    {
X        extern int string_count;
X
X	if(vl->dontfree) return;
X	/* many of these don't need to call stfree(); since a check
X	   for pointer validity's already done before even calling
X	   it, we can just call free() here then do one big decrement
X	   of string_count at the end.  */
X	if(vl->name) free(vl->name);
X	stfree(vl->type);
X	if(vl->replicas) vllfree(vl->replicas);
X	stfree(vl->hosttype);
X	if(vl->host) free(vl->host);
X	stfree(vl->nametype);
X	if(vl->filename) free(vl->filename);
X	if(vl->args) free(vl->args);
X	if(vl->lattrib) atlfree(vl->lattrib);
X	/* No allocation routines for f_info yet */
X	vl->f_info = NULL;
X	vl->next = lfree;
X	vl->previous = NULL;
X	lfree = vl;
X	vlink_count--;
X	string_count -= 4; /* freed name, host, filename, and args */
X    }
X
/*
X * vllfree - free a VLINK structure
X *
X *    VLLFREE takes a pointer to a VLINK structure frees it and any linked
X *    VLINK structures.  It is used to free an entrie list of VLINK
X *    structures.
X */
void
vllfree(vl)
X    VLINK	vl;
X    {
X	VLINK	nxt;
X
X	while((vl != NULL) && !vl->dontfree) {
X	    nxt = vl->next;
X	    vlfree(vl);
X	    vl = nxt;
X	}
X    }
X
SHAR_EOF
chmod 0644 xarchie-2.0.6/vlalloc.c ||
echo 'restore of xarchie-2.0.6/vlalloc.c failed'
Wc_c="`wc -c < 'xarchie-2.0.6/vlalloc.c'`"
test 2430 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/vlalloc.c: original size 2430, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/weight.c ==============
if test -f 'xarchie-2.0.6/weight.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/weight.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/weight.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/weight.c' &&
/*
X * weight.c : Routines for ordering hosts by "weight"
X *
X * George Ferguson, ferguson@cs.rochester.edu, 23 Apr 1993.
X * Based on a suggestion from Peter J Nilsson (pjn@ida.liu.se).
X * 13 May 1993: Add "org" to US weights and make sure others have proper
X *		US lists.
X *  7 Jun 1993: Added weights for Norway, from janl@ifi.uio.no.
X */
X
#include <stdio.h>
#include "sysdefs.h"
#include "stringdefs.h"
#include "xtypes.h"
#include "appres.h"
#include "weight.h"
#include "hostname.h"
#include "debug.h"
X
#define Number(arr) (sizeof(arr) / sizeof(arr[0]))
X
#define ISSPACE(C) ((C) == ' ' || (C) == '\t' || (C) == '\n')
#define ISDIGIT(C) ((C) >= '0' && (C) <= '9')
X
#define UNKNOWN_WEIGHT 99
X
/*
X * Functions defined here:
X */
void initHostWeights(),reinitHostWeights();
int hostWeight();
X
static int parseHostWeights();
X
/*
X * Data defined here:
X */
static HostWeightRec *hostWeightList;
static int hostWeightListLen;
X
/*
X * These weight lists are used if the hostWeights resource isn't given.
X * We attempt to determine a useful one by looking at the last component
X * of the hostname, if there is one.
X * The formatting is ugly so we don't have extra spaces on the Settings
X * panel.
X */
static struct _HostWeightDefault {
X    char *domain;
X    char *weights;
} defaults[] = {
X    /* North America, from gf (also used as default) */
X    { "us", "1   edu com net gov mil us org\n\
2   ca\n\
3   uk de nl fi fr eu.net\n\
100 au nz jp" },
/* For Sweden, from Peter J Nilsson (pjn@ida.liu.se) */
X    { "se", "1   se\n\
2   fi dk no\n\
10  eu.net nl fr de\n\
20  edu com gov net mil us org\n\
100 au nz jp" },
/* For Norway, from gf (based on se) */
X    { "no", "1   no\n\
2   fi dk se\n\
10  eu.net nl fr de\n\
20  edu com gov net mil us org\n\
100 au nz jp" },
/* For Finland, from gf (based on se) */
X    { "fi", "1   si\n\
2   se dk no\n\
10  eu.net nl fr de\n\
20  edu com gov net mil us org\n\
100 au nz jp" },
/* For the UK, from gf */
X    { "uk", "1   uk\n\
2   se fi dk no nl fr de eu.net\n\
20  edu com gov net mil us org\n\
100 au nz jp" },
/* For New Zealand, from Andy.Linton@comp.vuw.ac.nz */
X    { "nz", "1   nz\n\
10  edu com gov net mil us org jp\n\
20  se fi dk no nl fr de eu.net uk au" },
/* For Australia, from gf (based on nz) */
X    { "au", "1   au\n\
10  edu com gov net mil us org jp\n\
20  se fi dk no nl fr de eu.net uk nz" },
/* For Japan, from gf (a total guess) */
X    { "jp", "1   jp\n\
10  edu com gov net mil us org\n\
20  au nz\
30  se fi dk no nl fr de eu.net uk" },
/* For Norway, from janl@ifi.uio.no */
X    { "no", "1   no\n\
2   fi dk se\n\
10  eu.net nl fr\n\
20  edu com gov net de\n\
100 au nz jp" },
};
X
X
/*	-	-	-	-	-	-	-	-	*/
void
initHostWeights()
{
X    char *hostname,*dot;
X    int i,found;
X
X    if (appResources.hostWeights == NULL) {
X	found = 0;	/* default if none matches */
X	hostname = GetHostname();
X	if ((dot=rindex(hostname,'.')) != NULL) {
X	    dot += 1;
X	    for (i=0; i < Number(defaults); i++) {
X		if (strcasecmp(dot,defaults[i].domain) == 0) {
X		    found = i;
X		    break;
X		}
X	    }
X	}
X	appResources.hostWeights = XtNewString(defaults[found].weights);
X    }
X    reinitHostWeights();
}
X
X
/*
X * This function is called whenever the weight list changes, eg, on
X * the Settings panel as well as at startup.
X */
X
void
reinitHostWeights()
{
X    /* Count how many entries there are */
X    hostWeightListLen = parseHostWeights(appResources.hostWeights,0);
X    /* Allocate the array to store them */
X    if (hostWeightList != NULL)
X	free((char*)hostWeightList);
X    hostWeightList = (HostWeightRec *)calloc(hostWeightListLen,
X					     sizeof(HostWeightRec));
X    /* Rescan and parse for real */
X    (void)parseHostWeights(appResources.hostWeights,1);
}
X
/*
X * Classes are of the form "[weight] host [host] [host] {,\n\0}"
X */
X
/* Each class of hosts is separated by this: */
#define ISCLASSSEP(C)	((C) == ',' || (C) == '\n')
/* Within classes, each host is separated by this: */
#define ISHOSTSEP(C)	ISSPACE(C)
X
static int
parseHostWeights(s,saveit)
char *s;
int saveit;
{
X    char buf[256];
X    int i,n,weight;
X
X    n = 0;
X    weight = 0;
X    while (*s) {
X	/* Skip spaces and empty classes */
X	while (ISSPACE(*s) || ISCLASSSEP(*s))
X	    s += 1;
X	/* Get the weight, if given */
X	i = 0;
X	while (ISDIGIT(*s))
X	    buf[i++] = *s++;
X	buf[i] = '\0';
X	if (saveit && i > 0) {
X	    weight = atoi(buf);
X	}
X	/* Get the hosts in the class */
X	while (*s && !ISCLASSSEP(*s)) {
X	    /* Skip spaces, if any */
X	    while (ISSPACE(*s) || ISHOSTSEP(*s))
X		s += 1;
X	    /* Get the host string */
X	    i = 0;
X	    while (*s && !ISHOSTSEP(*s) && !ISCLASSSEP(*s))
X		buf[i++] = *s++;
X	    buf[i] = '\0';
X	    /* Save this host */
X	    if (saveit && i > 0) {
X		XtFree(hostWeightList[n].name);
X		hostWeightList[n].name = XtMalloc(strlen(buf)+1);
X		strcpy(hostWeightList[n].name,buf);
X		hostWeightList[n].weight = weight;
X		DEBUG2("Set weight of \"%s\" = %d\n",buf,weight);
X	    }
X	    /* Keep track of how many */
X	    n += 1;
X	}
X    }
X    /* Return total hosts */
X    return(n);
}
X
int
hostWeight(host)
char *host;
{
X    int i,offs,hostlen;
X
X    hostlen = strlen(host);
X    for (i=0; i < hostWeightListLen; i++) {
X	if ((offs=hostlen-strlen(hostWeightList[i].name)) < 0)
X	    offs = 0;
X	if (!strcasecmp(host+offs,hostWeightList[i].name)) {
X	    DEBUG3("Weight of \"%s\" (\"%s\") = %d\n",
X		   host,host+offs,hostWeightList[i].weight);
X	    return(hostWeightList[i].weight);
X	}
X    }
X    return(UNKNOWN_WEIGHT);
}
SHAR_EOF
chmod 0644 xarchie-2.0.6/weight.c ||
echo 'restore of xarchie-2.0.6/weight.c failed'
Wc_c="`wc -c < 'xarchie-2.0.6/weight.c'`"
test 5440 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/weight.c: original size 5440, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/weight.h ==============
if test -f 'xarchie-2.0.6/weight.h' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/weight.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/weight.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/weight.h' &&
/*
X * weight.h : Routines for ordering hosts by "weight"
X *
X * George Ferguson, ferguson@cs.rochester.edu, 23 Apr 1993.
X * Based on a suggestion from Peter J Nilsson (pjn@ida.liu.se).
X */
X
typedef struct _hostWeightRec {
X    char *name;
X    int weight;
} HostWeightRec;
X
extern void initHostWeights(),reinitHostWeights();
extern int hostWeight(/* char *host */);
SHAR_EOF
chmod 0644 xarchie-2.0.6/weight.h ||
echo 'restore of xarchie-2.0.6/weight.h failed'
Wc_c="`wc -c < 'xarchie-2.0.6/weight.h'`"
test 363 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/weight.h: original size 363, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/xarchie.c ==============
if test -f 'xarchie-2.0.6/xarchie.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/xarchie.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/xarchie.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/xarchie.c' &&
/*
X * xarchie : An X browser interface to Archie
X *
X * George Ferguson, ferguson@cs.rochester.edu, 2 Nov 1991.
X * Version 2.0: 23 Apr 1993.
X * 28 Apr 1993: Change default host to "archie.sura.net(1526)".
X * 13 May 1993: Apply icon resources to realToplevel.
X *		Don't call XtMapWidget() or -iconic is ignored.
X *		Apply tilde expansion to initial value of ftpLocalDir resource.
X */
X
#include <stdio.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Shell.h>	
#include <X11/Xaw/Form.h>
#include <X11/Xaw/Label.h>
#include <X11/Xaw/Command.h>
#include <X11/Xaw/Paned.h>
#include <X11/Xaw/Viewport.h>
#include <X11/Xaw/AsciiText.h>
#include <X11/Xaw/MenuButton.h>
#include <X11/Xaw/SimpleMenu.h>
#include <X11/Xaw/Scrollbar.h>
#include <X11/Xaw/Cardinals.h>	
#include <X11/cursorfont.h>
#ifdef MULTILIST
#include <MultiList.h>
#else
#include <X11/Xaw/List.h>
#endif
#include "sysdefs.h"
#include "xarchie.h"
#include "types.h"
#include "appres.h"
#include "weight.h"
#include "db.h"
#include "actions.h"
#include "display.h"
#include "settings.h"
#include "menu.h"
#include "m-defs.h"
#include "status.h"
#include "browser.h"
#include "selection.h"
#include "file-panel.h"
#include "ftp-actions.h"
#include "about.h"
#ifdef HELP
# include "help.h"
#endif
#include "view-file.h"
#include "username.h"
#include "hostname.h"
#include "tilde.h"
#include "syntax.h"
#include "xarchie.xbm"
#include "busy.xbm"
X
/*	-	-	-	-	-	-	-	-	*/
/*
X * Functions defined in this file:
X */
/* main() */
void bye();
void setBusyStatus(),setIconStatus();
X
static void initGraphics(),initColors(),initMenus(),initWidgets();
static void initErrorHandlers(), initMisc();
static void browserCallback();
static void setWindowBusyStatus();
static void iconifyEventHandler();
#ifdef DEBUG
static void xerror();
#endif
X
/*
X * Global graphics data
X */
Display *display;
Screen *screen;
Window root;
Atom WM_DELETE_WINDOW,WM_PROTOCOLS,WM_STATE;
X
/*
X * Local graphics data
X */
static Cursor busyCursor;
X
/*
X * Global widget data
X */
XXtAppContext appContext;
Widget toplevel,realToplevel;
Widget fileButton,settingsButton;
Widget queryButton,abortButton;
#ifdef HELP
Widget helpButton;
#endif
Widget statusText;
Widget browserForm;
Widget browserUpButton,browserDownButton;
Widget browserViewports[NUM_BROWSER_PANES];
Widget browserScrollbars[NUM_BROWSER_PANES];
Widget browserLists[NUM_BROWSER_PANES];
Widget searchText;
Widget hostText,locationText,fileText,sizeText,modesText,dateText;
X
/*
X * Other global data
X */
DbEntry *db;
char *program;
char *tmpDirectory;
X
/*
X * The application resources
X */
AppResources appResources;
X
/*
X * Non-widget resources obtained from resource manager
X */
static XtResource resources[] = {
X    { "searchType", "SearchType", GfRSearchType, sizeof(SearchType),
X      XtOffset(AppResources *,searchType), XtRImmediate, (XtPointer)GfExact },
X    { "sortType", "SortType", GfRSortType, sizeof(SortType),
X      XtOffset(AppResources *,sortType), XtRImmediate, (XtPointer)GfName },
X    { "archieHost", "ArchieHost", XtRString, sizeof(String),
X      XtOffset(AppResources *,archieHost), XtRImmediate, "archie.sura.net" },
X    { "numHosts", "numHosts", XtRInt, sizeof(int),
X      XtOffset(AppResources *,numHosts), XtRImmediate, (XtPointer)1 },
X    { "maxHits", "MaxHits", XtRInt, sizeof(int),
X      XtOffset(AppResources *,maxHits), XtRImmediate, (XtPointer)99 },
X    { "offset", "Offset", XtRInt, sizeof(int),
X      XtOffset(AppResources *,offset), XtRImmediate, (XtPointer)0 },
X    { "timeout", "Timeout", XtRInt, sizeof(int),
X      XtOffset(AppResources *,timeout), XtRImmediate, (XtPointer)0 },
X    { "retries", "Retries", XtRInt, sizeof(int),
X      XtOffset(AppResources *,retries), XtRImmediate, (XtPointer)0 },
X    { "niceLevel", "NiceLevel", XtRInt, sizeof(int),
X      XtOffset(AppResources *,niceLevel), XtRImmediate, (XtPointer)0 },
X    { "ftpLocalDir", "FtpLocalDir", XtRString, sizeof(String),
X      XtOffset(AppResources *,ftpLocalDir), XtRImmediate, "" },
X    { "ftpType", "FtpType", XtRString, sizeof(String),
X      XtOffset(AppResources *,ftpType), XtRImmediate, "binary" },
X    { "ftpPrompt", "FtpPrompt", XtRBoolean, sizeof(Boolean),
X      XtOffset(AppResources *,ftpPrompt), XtRImmediate, (XtPointer)False },
X    { "ftpTrace", "FtpTrace", XtRBoolean, sizeof(Boolean),
X      XtOffset(AppResources *,ftpTrace), XtRImmediate, (XtPointer)False },
X    { "ftpStrip", "FtpStrip", XtRBoolean, sizeof(Boolean),
X      XtOffset(AppResources *,ftpStrip), XtRImmediate, (XtPointer)True },
X    { "ftpMailAddress", "FtpMailAddress", XtRString, sizeof(String),
X      XtOffset(AppResources *,ftpMailAddress), XtRImmediate, "%s@%s" },
X    { "debugLevel", "DebugLevel", XtRInt, sizeof(int),
X      XtOffset(AppResources *,debugLevel), XtRImmediate, (XtPointer)0 },
X    { "fileWriteOnePerLine", "FileWriteOnePerLine", XtRBoolean,sizeof(Boolean),
X      XtOffset(AppResources *,fileWriteOnePerLine), XtRImmediate,
X	  						(XtPointer)False },
X    { "xarchieFont", "Font", XtRFontStruct, sizeof(XFontStruct*),
X      XtOffset(AppResources *,xarchieFont), XtRString, XtDefaultFont },
X    { "xarchieBoldFont", "Font", XtRFontStruct, sizeof(XFontStruct*),
X      XtOffset(AppResources *,xarchieBoldFont), XtRString, XtDefaultFont },
X    { "hostWeights", "HostWeights", XtRString, sizeof(String),
X      XtOffset(AppResources *,hostWeights), XtRImmediate, NULL },
X    { "autoScroll", "AutoScroll", XtRBoolean, sizeof(Boolean),
X      XtOffset(AppResources *,autoScroll), XtRImmediate, (XtPointer)True },
X    { "pasteBuffer", "PasteBuffer", XtRBoolean, sizeof(Boolean),
X      XtOffset(AppResources *,pasteBuffer), XtRImmediate, (XtPointer)True },
X    { "visualType", "VisualType", XtRString, sizeof(String),
X      XtOffset(AppResources *,visualType), XtRImmediate, (XtPointer)"" },
X    { "defaultIcon", "Icon", XtRBitmap, sizeof(Pixmap),
X      XtOffset(AppResources *,defaultIcon), XtRImmediate, None },
X    { "busyIcon", "Icon", XtRBitmap, sizeof(Pixmap),
X      XtOffset(AppResources *,busyIcon), XtRImmediate, None },
};
X
/*
X * Non-widget resources set on command line.
X */
static XrmOptionDescRec options[] = {
X    { "-search",  ".searchType", XrmoptionSepArg, (XtPointer)"exact" },
X    { "-e",	  ".searchType", XrmoptionNoArg,  (XtPointer)"exact" },
X    { "-s",	  ".searchType", XrmoptionNoArg,  (XtPointer)"substr" },
X    { "-c",	  ".searchType", XrmoptionNoArg,  (XtPointer)"subcase" },
X    { "-r",	  ".searchType", XrmoptionNoArg,  (XtPointer)"regexp" },
X    { "-es",	  ".searchType", XrmoptionNoArg,  (XtPointer)"exactSubstr" },
X    { "-ec",	  ".searchType", XrmoptionNoArg,  (XtPointer)"exactSubcase" },
X    { "-er",	  ".searchType", XrmoptionNoArg,  (XtPointer)"exactRegexp" },
X    { "-sort",	  ".sortType",	 XrmoptionSepArg, (XtPointer)"name" },
X    { "-t",	  ".sortType",	 XrmoptionNoArg,  (XtPointer)"date" },
X    { "-w",	  ".sortType",	 XrmoptionNoArg,  (XtPointer)"weight" },
X    { "-host",	  ".archieHost", XrmoptionSepArg,
X					(XtPointer)"archie.sura.ca" },
X    { "-maxhits", ".maxHits",	 XrmoptionSepArg, (XtPointer)"99" },
X    { "-offset",  ".offset",	 XrmoptionSepArg, (XtPointer)"0" },
X    { "-nice",	  ".niceLevel",	 XrmoptionSepArg, (XtPointer)"0" },
X    { "-N",	  ".niceLevel",	 XrmoptionSepArg, (XtPointer)"0" },
X    { "-debug",	  ".debugLevel", XrmoptionSepArg, (XtPointer)"1" },
X    { "-D",	  ".debugLevel", XrmoptionSepArg, (XtPointer)"1" },
X    { "-noscroll",".autoScroll", XrmoptionNoArg,  (XtPointer)"False" },
X    { "-mono",	  ".visualType", XrmoptionNoArg,  (XtPointer)"mono" },
X    { "-gray",	  ".visualType", XrmoptionNoArg,  (XtPointer)"gray" },
X    { "-color",	  ".visualType", XrmoptionNoArg,  (XtPointer)"color" },
};
X
/*
X * Widget and non-widget resources if the application defaults
X * file can't be found.
X * Generated automatically from Xarchie.ad by "ad2c".
X * Comment out the include line (but not the NULL) if you don't want
X * any resources compiled in.
SHAR_EOF
true || echo 'restore of xarchie-2.0.6/xarchie.c failed'
fi
echo 'End of xarchie-2.0.6 part 16'
echo 'File xarchie-2.0.6/xarchie.c is continued in part 17'
echo 17 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM       | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@imd.sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
