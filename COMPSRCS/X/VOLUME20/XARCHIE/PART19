Newsgroups: comp.sources.x
From: ferguson@cs.rochester.edu (George Ferguson)
Subject: v20i047:  xarchie - An X browser interface to Archie, v2.0.6, Part19/24
Message-ID: <1993Jun15.223507.1617@sparky.imd.sterling.com>
X-Md4-Signature: 1701ae8245c6300ae6496830b1ca8f0c
Sender: chris@sparky.imd.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Tue, 15 Jun 1993 22:35:07 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: ferguson@cs.rochester.edu (George Ferguson)
Posting-number: Volume 20, Issue 47
Archive-name: xarchie/part19
Environment: X11
Supersedes: xarchie: Volume 14, Issue 82-90

Submitted-by: ferguson@cs.rochester.edu
Archive-name: xarchie-2.0.6/part19

#!/bin/sh
# this is Part.19 (part 19 of xarchie-2.0.6)
# do not concatenate these parts, unpack them in order with /bin/sh
# file xarchie-2.0.6/Ad2c/Makefile continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 19; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping xarchie-2.0.6/Ad2c/Makefile'
else
echo 'x - continuing file xarchie-2.0.6/Ad2c/Makefile'
sed 's/^X//' << 'SHAR_EOF' >> 'xarchie-2.0.6/Ad2c/Makefile' &&
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
XXFILESEARCHPATHDEFAULT = $(LIBDIR)/%L/%T/%N%S:$(LIBDIR)/%l/%T/%N%S:$(LIBDIR)/%T/%N%S
X	         ERRORDB = $(LIBDIR)/XtErrorDB
X
X        SOXLIBREV = 4.4
X          SOXTREV = 4.1
X         SOXAWREV = 4.0
X        SOOLDXREV = 4.0
X         SOXMUREV = 4.0
X        SOXEXTREV = 4.0
X
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X            FONTC = bdftosnf
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier.sh
X
X        CONFIGSRC = $(TOP)/config
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X     MKFONTDIRSRC = $(FONTSRC)/mkfontdir
X     EXTENSIONSRC = $(TOP)/extensions
X
X  DEPEXTENSIONLIB = $(USRLIBDIR)/libXext.a
X     EXTENSIONLIB =  -L$(USRLIBDIR) -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -L$(USRLIBDIR) -lX11
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -L$(USRLIBDIR) -lXau
X
X        DEPXMULIB =
X           XMULIB = -L$(USRLIBDIR) -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -L$(USRLIBDIR) -loldX
X
X      DEPXTOOLLIB =
X         XTOOLLIB = -L$(USRLIBDIR) -lXt
X
X        DEPXAWLIB =
X           XAWLIB = -L$(USRLIBDIR) -lXaw
X
X LINTEXTENSIONLIB = $(USRLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(USRLIBDIR)/llib-lX11.ln
X          LINTXMU = $(USRLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(USRLIBDIR)/llib-lXt.ln
X          LINTXAW = $(USRLIBDIR)/llib-lXaw.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
###########################################################################
# Imake rules for building libraries, programs, scripts, and data files
# rules:  $XConsortium: Imake.rules,v 1.67 89/12/18 17:14:15 jim Exp $
X
###########################################################################
# start of Imakefile
X
#
#	Imakefile for ad2c - Convert X resources to C decls
#
#	George Ferguson, ferguson@cs.rochester.edu, 19 Mar 1991.
#
X
# Where do you want this (if the default isn't okay)?
#BINDIR = bin
#MANDIR = man/man1
# Default suffix is "1", change if you change MANDIR I guess
##undef 1
##define 1 l
X
# Why is this not the default?
INSTPGMFLAGS = -m 0755
X
all:: ad2c
depend:
X	@echo 'no need to depend for ad2c'
ad2c:
X	@echo 'ad2c is up to date'
X
install:: ad2c.script
X	$(INSTALL) -c $(INSTPGMFLAGS) ad2c.script $(BINDIR)/ad2c
X
install.man:: ad2c.man
X	$(INSTALL) -c $(INSTMANFLAGS) ad2c.man $(MANDIR)/ad2c.1
X
###########################################################################
# common rules for all Makefiles - do not edit
X
emptyrule::
X
clean::
X	$(RM_CMD) \#*
X
Makefile::
X	-@if [ -f Makefile ]; then \
X	echo "	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak"; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
tags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
saber:
X	#load $(ALLDEFINES) $(SRCS)
X
osaber:
X	#load $(ALLDEFINES) $(OBJS)
X
###########################################################################
# empty rules for directories that do not have SUBDIRS - do not edit
X
install::
X	@echo "install in $(CURRENT_DIR) done"
X
install.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
Makefiles::
X
includes::
X
###########################################################################
# dependencies generated by makedepend
X
SHAR_EOF
echo 'File xarchie-2.0.6/Ad2c/Makefile is complete' &&
chmod 0644 xarchie-2.0.6/Ad2c/Makefile ||
echo 'restore of xarchie-2.0.6/Ad2c/Makefile failed'
Wc_c="`wc -c < 'xarchie-2.0.6/Ad2c/Makefile'`"
test 8882 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/Ad2c/Makefile: original size 8882, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/Ad2c/ad2c.man ==============
if test -f 'xarchie-2.0.6/Ad2c/ad2c.man' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/Ad2c/ad2c.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/Ad2c/ad2c.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/Ad2c/ad2c.man' &&
.TH ad2c 1 "19 Apr 1993"
.SH NAME
ad2c \- convert resource files to C declarations
.SH SYNOPSIS
.I ad2c
[ files ]
.SH DESCRIPTION
.LP
.I Ad2c
converts X resource files into C declarations, appropriate for
inclusion as fallback resources.  The program is a
.IR sed (1)
script which is effectively a finite state machine, escaping quotes
and backslashes (and newlines where necessary), and adding quotes and
commas as needed for array initialization.
.LP
It reads from the given files (or stdin if none are given) and writes
the C declarations to stdout.
.SH USAGE
The following example shows a typical use of
.I ad2c
to ensure that an application always has the latest version of its
resources compiled into the executable.  Suppose the application
defaults file is named "Foobar.ad", for application
.IR foobar .
Then the following lines in a Makefile or Imakefile will indicate
how and when to run
.IR ad2c :
X
.nf
.na
X    Foobar.ad.h: Foobar.ad
X            ad2c Foobar.ad >Foobar.ad.h
.ad
.fi
X
The resulting C strings should be included (say in "foobar.c"):
X
.nf
.na
X    static char fallback_resources[] = {
X        #include "Foobar.ad.h"
X        NULL
X    };
.ad
.fi
X
This array of strings can then be given as a parameter to
.IR XtAppInitialize (3X)
or otherwise used to initialize the application's resources.  Running
.I makedepend
or adding the line
X
.nf
.na
X    foobar.c: Foobar.ad.h
.ad
.fi
X
to the Makefile or Imakefile will ensure that "foobar.c" is
recompiled when necessary (ie., whenever "Foobar.ad" changes).
.SH "RETURN VALUE"
.LP
.I Ad2c
returns as for
.IR sed .
.SH "SEE ALSO"
sed(1)
.SH DISCLAIMER
.LP
This software is provided as is with no warranty expressed or implied.
I hope you find it useful, but I won't be held responsable for
any damage that may occur from reading, compiling, installing or
using it.
.LP
You are free to use any part of this code for other purposes. It
would be nice if you could keep my name on some part of whatever the
final product is.
.SH AUTHOR
.LP
George Ferguson, ferguson@cs.rochester.edu.
.LP
Man page by Joseph Beckenbach, jerbil@ultra.com. Usage section added
by George Ferguson. Example corrected by Tim Theisen, tim@cs.wisc.edu.
Example further corrected by David Wojtowicz, davidw@vista.atmos.uiuc.edu.
.LP
Modified to work with Gnu and IBM sed by Charles Hannum,
mycroft@gnu.ai.mit.edu.
SHAR_EOF
chmod 0644 xarchie-2.0.6/Ad2c/ad2c.man ||
echo 'restore of xarchie-2.0.6/Ad2c/ad2c.man failed'
Wc_c="`wc -c < 'xarchie-2.0.6/Ad2c/ad2c.man'`"
test 2347 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/Ad2c/ad2c.man: original size 2347, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/Ad2c/ad2c.script ==============
if test -f 'xarchie-2.0.6/Ad2c/ad2c.script' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/Ad2c/ad2c.script (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/Ad2c/ad2c.script (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/Ad2c/ad2c.script' &&
#!/bin/sh
#
#	ad2c : Convert app-defaults file to C strings decls.
#
#	George Ferguson, ferguson@cs.rcohester.edu, 12 Nov 1990.
#	19 Mar 1991: gf
#		Made it self-contained.
#	6 Jan 1992: mycroft@gnu.ai.mit.edu (Charles Hannum)
#		Removed use of "-n" and ":read" label since Gnu and
#		IBM sed print pattern space on "n" command. Still works
#		with Sun sed, of course.
#	7 Jan 1992: matthew@sunpix.East.Sun.COM (Matthew Stier)
#		Escape quotes after escaping backslashes.
#	8 Jul 1992: Version 1.6
#		Manpage fixes.
#	19 Apr 1993: Version 1.7
#		Remove comments that were inside the sed command since
#		some versions of sed don't like them. The comments are
#		now given here in the header.
#
# Comments on the script by line:
# /^!/d		Remove comments
# /^$/d		Remove blanks
# s/\\/\\\\/g	Escape backslashes...
# s/\\$//g	...except the line continuation ones
# s/"/\\"/g	Escape quotes
# s/^/"/	Add leading quote
# : test	Establish label for later branch
# /\\$/b slash	Branch to label "slash" if line ends in backslash
# s/$/",/	Otherwise add closing quote and comma...
# p		...output the line...
# d		...and clear the pattern space so it's not printed again
# : slash	Branch comes here if line ends in backslash
# n		Read next line, append to pattern space
# [...]		The "d" and "s" commands that follow just delete
#		comments and blank lines and escape control sequences
# b test	Branch up to see if the line ends in backslash or not
#
X
sed '
/^!/d
/^$/d
s/\\/\\\\/g
s/\\$//g
s/"/\\"/g
s/^/"/
: test
/\\$/b slash
s/$/",/
p
d
: slash
n
/^!/d
/^$/d
s/"/\\"/g
s/\\\\/\\/g
s/\\n/\\\\n/g
s/\\t/\\\\t/g
s/\\f/\\\\f/g
s/\\b/\\\\b/g
b test' "$@"
SHAR_EOF
chmod 0755 xarchie-2.0.6/Ad2c/ad2c.script ||
echo 'restore of xarchie-2.0.6/Ad2c/ad2c.script failed'
Wc_c="`wc -c < 'xarchie-2.0.6/Ad2c/ad2c.script'`"
test 1641 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/Ad2c/ad2c.script: original size 1641, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/FWF/README ==============
if test ! -d 'xarchie-2.0.6/FWF'; then
    echo 'x - creating directory xarchie-2.0.6/FWF'
    mkdir 'xarchie-2.0.6/FWF'
fi
if test -f 'xarchie-2.0.6/FWF/README' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/FWF/README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/FWF/README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/FWF/README' &&
=================================== README ===================================
X
X	*****************************************************************
X	*                                                               *
X	*           The Free Widget Foundation Widget Release           *
X	*                          Version 3.0                          *
X	*                                                               *
X	*                         May 19,  1992                         *
X	*                                                               *
X	*****************************************************************
X
X	This is the Free Widget Foundation widget release.  In case you
X	only have this Makefile, the current set of widgets can be obtained
X	via anonymous ftp from the machine a.cs.uiuc.edu (128.174.252.1)
X	in the file pub/fwf.shar.Z.
X
X	The release is also available via anonymous ftp from the site
X	ftp.informatik.tu-muenchen.de, and via email, by sending the
X	command 'GET /pub/X11/contrib/lib/fwf/fwf-2.14.tar.Z'
X	to the account: FTP-Mailer@ftp.informatik.tu-muenchen.de.
X
X	The Free Widget Foundation project was started summer 1990 in order
X	to collect existing widgets in a well-publicized location to prevent
X	duplication of effort.  Numerous people have expressed interest
X	in submitting widgets to the collection.  The collection process is
X	going slowly because of lack of time and organizational needs.  The
X	"Free Widget Foundation" is a pun on the "Free Software Foundation"
X	title.  While the two organizations share some similar goals, that is
X	the improvement of the quality and quantity of public software, this
X	organization is in no way related to the Free Software Foundation or
X	the GNU projects.  In fact, we aren't even a "foundation" in the
X	legal meaning of the word.  We are solely a group of volunteers
X	attempting to build up a working set of usable widgets in an efficient
X	manner.
X
X	The widgets contained in this distribution are only a small subset
X	of widgets which have been offered.  Integration of the donated
X	widgets will begin when the compilation infrastructure has been
X	decided.
X
X	The following files may be of interest in describing other parts of
X	the system:
X
X	README			This file
X	README.FWF		Information about the Free Widget Foundation
X	README.BUILD		How to build the free widgets
X	README.INDEX		Index of widgets contained in this release
X	README.IMAKE		Details about the imake structure
X	README.NOTES		Assorted notes about the state of the release
X	README.TODO		Bugs, inadequacies, planned changes, requests
X	README.SUBMISSION	How to submit your widgets to the FWF
X	VERSION			Current FWF release version
X
SHAR_EOF
chmod 0644 xarchie-2.0.6/FWF/README ||
echo 'restore of xarchie-2.0.6/FWF/README failed'
Wc_c="`wc -c < 'xarchie-2.0.6/FWF/README'`"
test 2662 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/FWF/README: original size 2662, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/FWF/README.FWF ==============
if test -f 'xarchie-2.0.6/FWF/README.FWF' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/FWF/README.FWF (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/FWF/README.FWF (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/FWF/README.FWF' &&
================================= README.FWF =================================
X
X	The Free Widget Foundation project was started summer 1990 in order
X	to collect existing widgets in a well-publicized location to prevent
X	duplication of effort.  Numerous people have expressed interest
X	in submitting widgets to the collection.  The collection process is
X	going slowly because of lack of time and organizational needs.  The
X	"Free Widget Foundation" is a pun on the "Free Software Foundation"
X	title.  While the two organizations share some similar goals, that is
X	the improvement of the quality and quantity of public software, this
X	organization is in no way related to the Free Software Foundation or
X	the GNU projects.  In fact, we aren't even a "foundation" in the
X	legal meaning of the word.  We are solely a group of volunteers
X	attempting to build up a working set of usable widgets in an efficient
X	manner.
X
X	There is a mailing list set up to discuss the development of the
X	free widgets set.  To be added to the mailing list, send mail to
X	free-widgets-request@kazoo.cs.uiuc.edu.
SHAR_EOF
chmod 0644 xarchie-2.0.6/FWF/README.FWF ||
echo 'restore of xarchie-2.0.6/FWF/README.FWF failed'
Wc_c="`wc -c < 'xarchie-2.0.6/FWF/README.FWF'`"
test 1088 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/FWF/README.FWF: original size 1088, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/FWF/COPYRIGHT ==============
if test -f 'xarchie-2.0.6/FWF/COPYRIGHT' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/FWF/COPYRIGHT (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/FWF/COPYRIGHT (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/FWF/COPYRIGHT' &&
/*
X * Copyright 1990,1991,1992 Brian Totty
X * 
X * Permission to use, copy, modify, distribute, and sell this software
X * and its documentation for any purpose is hereby granted without fee,
X * provided that the above copyright notice appears in all copies and that
X * both that copyright notice and this permission notice appear in
X * supporting documentation, and that the name of Brian Totty or
X * University of Illinois not be used in advertising or publicity
X * pertaining to distribution of the software without specific, written
X * prior permission.  Brian Totty and University of Illinois make no
X * representations about the suitability of this software for any
X * purpose.  It is provided "as is" without express or implied warranty.
X *
X * Brian Totty and University of Illinois disclaim all warranties with
X * regard to this software, including all implied warranties of
X * merchantability and fitness, in no event shall Brian Totty or
X * University of Illinois be liable for any special, indirect or
X * consequential damages or any damages whatsoever resulting from loss of
X * use, data or profits, whether in an action of contract, negligence or
X * other tortious action, arising out of or in connection with the use or
X * performance of this software.
X *
X * Author:
X * 	Brian Totty
X * 	Department of Computer Science
X * 	University Of Illinois at Urbana-Champaign
X *	1304 West Springfield Avenue
X * 	Urbana, IL 61801
X * 
X * 	totty@cs.uiuc.edu
X * 	
X */ 
SHAR_EOF
chmod 0644 xarchie-2.0.6/FWF/COPYRIGHT ||
echo 'restore of xarchie-2.0.6/FWF/COPYRIGHT failed'
Wc_c="`wc -c < 'xarchie-2.0.6/FWF/COPYRIGHT'`"
test 1466 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/FWF/COPYRIGHT: original size 1466, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/FWF/Dir/DirMgr.c ==============
if test ! -d 'xarchie-2.0.6/FWF/Dir'; then
    echo 'x - creating directory xarchie-2.0.6/FWF/Dir'
    mkdir 'xarchie-2.0.6/FWF/Dir'
fi
if test -f 'xarchie-2.0.6/FWF/Dir/DirMgr.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/FWF/Dir/DirMgr.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/FWF/Dir/DirMgr.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/FWF/Dir/DirMgr.c' &&
/****************************************************************************
X
X	DirMgr.c
X
X	This file contains the C code to implement the DirectoryMgr system.
X
X	This system is intended to manage filtered and sorted directory
X	lists.
X
X ****************************************************************************/
/*
X * Copyright 1990,1991,1992 Brian Totty
X * 
X * Permission to use, copy, modify, distribute, and sell this software
X * and its documentation for any purpose is hereby granted without fee,
X * provided that the above copyright notice appears in all copies and that
X * both that copyright notice and this permission notice appear in
X * supporting documentation, and that the name of Brian Totty or
X * University of Illinois not be used in advertising or publicity
X * pertaining to distribution of the software without specific, written
X * prior permission.  Brian Totty and University of Illinois make no
X * representations about the suitability of this software for any
X * purpose.  It is provided "as is" without express or implied warranty.
X *
X * Brian Totty and University of Illinois disclaim all warranties with
X * regard to this software, including all implied warranties of
X * merchantability and fitness, in no event shall Brian Totty or
X * University of Illinois be liable for any special, indirect or
X * consequential damages or any damages whatsoever resulting from loss of
X * use, data or profits, whether in an action of contract, negligence or
X * other tortious action, arising out of or in connection with the use or
X * performance of this software.
X *
X * Author:
X * 	Brian Totty
X * 	Department of Computer Science
X * 	University Of Illinois at Urbana-Champaign
X *	1304 West Springfield Avenue
X * 	Urbana, IL 61801
X * 
X * 	totty@cs.uiuc.edu
X * 	
X */ 
X
#include <DirMgr.h>
X
#ifndef NO_REGEXP
#include <RegExp.h>
#endif
X
#define	DIR_MGR_FSM_SIZE 1024
X
/*---------------------------------------------------------------------------*
X
X                   S I M P L E    I N T E R F A C E
X
X *---------------------------------------------------------------------------*/
X
DirectoryMgr *DirectoryMgrSimpleOpen(path,sort_type,pattern)
char *path;
int sort_type;
char *pattern;
{
X	DirectoryMgr *dm;
X	PFI f_func,s_func;
X	char *f_data;
X
X	if (pattern == NULL) pattern = "*";
X	if (!DirectoryMgrSimpleFilterFunc(pattern,&f_func,&f_data))
X	{
X		return(NULL);
X	}
X	if (!DirectoryMgrSimpleSortingFunc(sort_type,&s_func))
X	{
X		free(f_data);
X		return(NULL);
X	}
X	dm = DirectoryMgrOpen(path,s_func,f_func,f_data,TRUE);
X	return(dm);
} /* End DirectoryMgrSimpleOpen */
X
X
int DirectoryMgrSimpleRefilter(dm,pattern)
DirectoryMgr *dm;
char *pattern;
{
X	PFI f_func;
X	char *f_data;
X
X	if (!DirectoryMgrSimpleFilterFunc(pattern,&f_func,&f_data))
X	{
X		return(FALSE);
X	}
X	DirectoryMgrRefilter(dm,f_func,f_data,TRUE);
X	return(TRUE);
} /* End DirectoryMgrSimpleRefilter */
X
X
int DirectoryMgrSimpleResort(dm,sort_type)
DirectoryMgr *dm;
int sort_type;
{
X	PFI c_func;
X
X	if (!DirectoryMgrSimpleSortingFunc(sort_type,&c_func))
X	{
X		return(FALSE);
X	}
X	DirectoryMgrResort(dm,c_func);
X	return(TRUE);
} /* End DirectoryMgrSimpleResort */
X
X
/*---------------------------------------------------------------------------*
X
X                    N O R M A L    I N T E R F A C E
X
X *---------------------------------------------------------------------------*/
X
DirectoryMgr *DirectoryMgrOpen(path,c_func,f_func,f_data,free_data)
char *path;
PFI c_func,f_func;
char *f_data;
int free_data;
{
X	DirectoryMgr *dm;
X
X	dm = (DirectoryMgr *)calloc(1,sizeof(DirectoryMgr));
X	if (dm == NULL)
X	{
X		if (free_data && f_data) free(f_data);
X		return(NULL);
X	}
X	if (DirectoryOpen(path,DirectoryMgrDir(dm)) == FALSE)
X	{
X		free((char *)dm);
X		if (free_data && f_data) free((char *)f_data);
X		return(NULL);
X	}
X	DirectoryMgrCompFunc(dm) = c_func;
X	DirectoryMgrRefilter(dm,f_func,f_data,free_data);
X	return(dm);
} /* End DirectoryMgrOpen */
X
X
void DirectoryMgrClose(dm)
DirectoryMgr *dm;
{
X	free((char *)DirectoryMgrData(dm));
X	free((char *)DirectoryMgrSortedPtrs(dm));
X	if (DirectoryMgrFilterData(dm) && DirectoryMgrFreeFilterData(dm))
X	{
X		free((char *)DirectoryMgrFilterData(dm));
X	}
X	DirectoryClose(DirectoryMgrDir(dm));
X	free((char *)dm);
} /* End DirectoryMgrClose */
X
X
int DirectoryMgrRefilter(dm,f_func,f_data,f_free)
DirectoryMgr *dm;
PFI f_func;
char *f_data;
int f_free;
{
X	if (DirectoryMgrFilterData(dm) && DirectoryMgrFreeFilterData(dm))
X	{
X		free(DirectoryMgrFilterData(dm));
X	}
X	DirectoryMgrFilterFunc(dm) = f_func;
X	DirectoryMgrFilterData(dm) = f_data;
X	DirectoryMgrFreeFilterData(dm) = f_free;
X	DirectoryMgrRefresh(dm);
X	return(0);	/* gf: what should this be?? */
} /* End DirectoryMgrRefilter */
X
X
int DirectoryMgrRefresh(dm)
DirectoryMgr *dm;
{
X	int err,data_size,ptrs_size,i;
X	DirEntryCons *head,*tail,*cons;
X	DirEntry *dm_data,**dm_ptrs;
X	PFI f_func;
X	char *f_data;
X
X	DirectoryMgrTotalCount(dm) = 0;
X	DirectoryMgrFilteredCount(dm) = 0;
X	DirectoryRestart(DirectoryMgrDir(dm));
X	if (DirectoryMgrData(dm))
X	    free((char *)DirectoryMgrData(dm));
X	if (DirectoryMgrSortedPtrs(dm))
X	    free((char *)DirectoryMgrSortedPtrs(dm));
X	head = NULL;
X	f_func = DirectoryMgrFilterFunc(dm);
X	f_data = DirectoryMgrFilterData(dm);
X	while (1)
X	{
X		cons = (DirEntryCons *)malloc(sizeof(DirEntryCons));
X		if (cons == NULL)
X		{
X			fprintf(stderr,
X				"DirectoryMgrRefresh: Can't Alloc Cons\n");
X			exit(-1);
X		}
X		err = DirectoryReadNextEntry(DirectoryMgrDir(dm),
X					     &(cons->dir_entry));
X		if (err == FALSE)
X		{
X			free((char *)cons);
X			break;
X		}
X		++ DirectoryMgrTotalCount(dm);
X		if ((f_func == NULL) ||
X		    (f_func && f_func(&(cons->dir_entry),f_data)))
X		{
X			cons->next = NULL;
X			if (head == NULL)
X				head = cons;
X			    else
X				tail->next = cons;
X			tail = cons;
X			++ DirectoryMgrFilteredCount(dm);
X		}
X		    else			/* Filter Failed */
X		{
X			free((char *)cons);
X		}
X	}
X
X	data_size = sizeof(DirEntry) * DirectoryMgrFilteredCount(dm);
X	ptrs_size = sizeof(DirEntry *) * DirectoryMgrFilteredCount(dm);
X	dm_data = (DirEntry *)malloc(data_size);
X	dm_ptrs = (DirEntry **)malloc(ptrs_size);
X	if ((dm_data == NULL) || (dm_ptrs == NULL))
X	{
X		fprintf(stderr,"DirectoryMgrRefresh: Out of memory\n");
X		exit(1);
X	}
X	DirectoryMgrData(dm) = dm_data;
X	DirectoryMgrSortedPtrs(dm) = dm_ptrs;
X
X	for (i = 0; i < DirectoryMgrFilteredCount(dm); i++)
X	{
X		DirectoryMgrData(dm)[i] = head->dir_entry;
X		DirectoryMgrSortedPtrs(dm)[i] = &(DirectoryMgrData(dm)[i]);
X		cons = head->next;
X		free((char *)head);
X		head = cons;
X	}
X
X	DirectoryMgrResort(dm,DirectoryMgrCompFunc(dm));
X	DirectoryMgrRestart(dm);
X	return(TRUE);
} /* End DirectoryMgrRefresh */
X
X
void DirectoryMgrResort(dm,c_func)
DirectoryMgr *dm;
PFI c_func;
{
X	DirectoryMgrCompFunc(dm) = c_func;
X	if (c_func != NULL)
X	{
X		qsort(DirectoryMgrSortedPtrs(dm),DirectoryMgrFilteredCount(dm),
X		      sizeof(DirEntry *),DirectoryMgrCompFunc(dm));
X	}
X	DirectoryMgrRestart(dm);
} /* End DirectoryMgrResort */
X
/*---------------------------------------------------------------------------*
X
X                  I T E R A T I O N    C O M M A N D S
X
X *---------------------------------------------------------------------------*/
X
int DirectoryMgrGotoItem(dm,i)
DirectoryMgr *dm;
int i;
{
X	if (i < 0 || i >= DirectoryMgrFilteredCount(dm)) return(FALSE);
X	DirectoryMgrCurrentIndex(dm) = i;
X	return(TRUE);
} /* End DirectoryMgrGotoItem */
X
X
int DirectoryMgrGotoNamedItem(dm,name)
DirectoryMgr *dm;
char *name;
{
X	int i;
X	DirEntry *entry;
X
X	for (i = 0; i < DirectoryMgrFilteredCount(dm); i++)
X	{
X		entry = DirectoryMgrSortedPtrs(dm)[i];
X		if (strcmp(DirEntryFileName(entry),name) == 0)
X		{
X			DirectoryMgrCurrentIndex(dm) = i;
X			return(TRUE);
X		}
X	}
X	return(FALSE);
} /* End DirectoryMgrGotoNamedItem */
X
X
void DirectoryMgrRestart(dm)
DirectoryMgr *dm;
{
X	DirectoryMgrCurrentIndex(dm) = 0;
} /* End DirectoryMgrRestart */
X
X
DirEntry *DirectoryMgrCurrentEntry(dm)
DirectoryMgr *dm;
{
X	int index;
X
X	index = DirectoryMgrCurrentIndex(dm);
X	if (index < 0 || index >= DirectoryMgrFilteredCount(dm)) return(NULL);
X	return(DirectoryMgrSortedPtrs(dm)[index]);
} /* End DirectoryMgrCurrentEntry */
X
X
DirEntry *DirectoryMgrNextEntry(dm)
DirectoryMgr *dm;
{
X	int index;
X
X	index = DirectoryMgrCurrentIndex(dm);
X	if (index >= DirectoryMgrFilteredCount(dm)) return(NULL);
X	++ DirectoryMgrCurrentIndex(dm);
X	return(DirectoryMgrSortedPtrs(dm)[index]);
} /* End DirectoryMgrNextEntry */
X
X
DirEntry *DirectoryMgrPrevEntry(dm)
DirectoryMgr *dm;
{
X	int index;
X
X	index = DirectoryMgrCurrentIndex(dm) - 1;
X	if (index < 0) return(NULL);
X	-- DirectoryMgrCurrentIndex(dm);
X	return(DirectoryMgrSortedPtrs(dm)[index]);
} /* End DirectoryMgrPrevEntry */
X
/*---------------------------------------------------------------------------*
X
X                   U T I L I T Y    F U N C T I O N S
X
X *---------------------------------------------------------------------------*/
X
int DirectoryMgrSimpleFilterFunc(pattern,ff_ptr,fd_ptr)
char *pattern;
PFI *ff_ptr;
char **fd_ptr;
{
#ifndef	NO_REGEXP
X	char regexp[2048];
X
X	*ff_ptr = DirectoryMgrFilterName;
X	*fd_ptr = (char *)malloc(sizeof(char) * DIR_MGR_FSM_SIZE);
X	if (*fd_ptr == NULL) return(FALSE);
X	RegExpPatternToRegExp(pattern,regexp);
X	RegExpCompile(regexp,*fd_ptr,DIR_MGR_FSM_SIZE);
#endif
X	return(TRUE);
} /* End DirectoryMgrSimpleFilterFunc */
X
X
int DirectoryMgrSimpleSortingFunc(sort_type,sf_ptr)
int sort_type;
PFI *sf_ptr;
{
X	*sf_ptr = NULL;
X	switch (sort_type)
X	{
X	    case DIR_MGR_SORT_NONE:
X		break;
X	    case DIR_MGR_SORT_NAME:
X		*sf_ptr = DirectoryMgrCompareName;
X		break;
X	    case DIR_MGR_SORT_SIZE_ASCENDING:
X		*sf_ptr = DirectoryMgrCompareSizeAscending;
X		break;
X	    case DIR_MGR_SORT_SIZE_DESCENDING:
X		*sf_ptr = DirectoryMgrCompareSizeDescending;
X		break;
X	    case DIR_MGR_SORT_NAME_DIRS_FIRST:
X		*sf_ptr = DirectoryMgrCompareNameDirsFirst;
X		break;
X	    case DIR_MGR_SORT_ACCESS_ASCENDING:
X		*sf_ptr = DirectoryMgrCompareLastAccessAscending;
X		break;
X	    case DIR_MGR_SORT_ACCESS_DESCENDING:
X		*sf_ptr = DirectoryMgrCompareLastAccessDescending;
X		break;
X	    default:
X		fprintf(stderr,"Bad sort type %d\n",sort_type);
X		return(FALSE);
X	}
X	return(TRUE);
} /* End DirectoryMgrSimpleSortingFunc */
X
/*---------------------------------------------------------------------------*
X
X                    S O R T I N G    R O U T I N E S
X
X *---------------------------------------------------------------------------*/
X
int DirectoryMgrCompareName(e1p,e2p)
DirEntry **e1p,**e2p;
{
X	return(strcmp(DirEntryFileName(*e1p),DirEntryFileName(*e2p)));
} /* End DirectoryMgrCompareName */
X
X
int DirectoryMgrCompareNameDirsFirst(e1p,e2p)
DirEntry **e1p,**e2p;
{
X	if (DirEntryLeadsToDir(*e1p))
X	{
X		if (!DirEntryLeadsToDir(*e2p)) return(-1);
X	}
X	    else if (DirEntryLeadsToDir(*e2p))
X	{
X		return(1);
X	}
X	return(strcmp(DirEntryFileName(*e1p),DirEntryFileName(*e2p)));
} /* End DirectoryMgrCompareNameDirsFirst */
X
X
int DirectoryMgrCompareSizeAscending(e1p,e2p)
DirEntry **e1p,**e2p;
{
X	if (DirEntryFileSize(*e1p) < DirEntryFileSize(*e2p))
X		return (-1);
X	    else if (DirEntryFileSize(*e1p) == DirEntryFileSize(*e2p))
X		return (0);
X	    else
X		return (1);
} /* End DirectoryMgrCompareSizeAscending */
X
X
int DirectoryMgrCompareSizeDescending(e1p,e2p)
DirEntry **e1p,**e2p;
{
X	if (DirEntryFileSize(*e1p) > DirEntryFileSize(*e2p))
X		return (-1);
X	    else if (DirEntryFileSize(*e1p) == DirEntryFileSize(*e2p))
X		return (0);
X	    else
X		return (1);
} /* End DirectoryMgrCompareSizeDescending */
X
X
int DirectoryMgrCompareLastAccessAscending(e1p,e2p)
DirEntry **e1p,**e2p;
{
X	return((long)DirEntryLastAccess(*e1p) >
X	       (long)DirEntryLastAccess(*e2p));
} /* End DirectoryMgrCompareLastAccessAscending */
X
X
int DirectoryMgrCompareLastAccessDescending(e1p,e2p)
DirEntry **e1p,**e2p;
{
X	return((long)DirEntryLastAccess(*e1p) <
X	       (long)DirEntryLastAccess(*e2p));
} /* End DirectoryMgrCompareLastAccessDescending */
X
/*---------------------------------------------------------------------------*
X
X                     F I L T E R    R O U T I N E S
X
X *---------------------------------------------------------------------------*/
X
int DirectoryMgrFilterName(de,fsm)
DirEntry *de;
char *fsm;
{
#ifndef	NO_REGEXP
X	return(RegExpMatch(DirEntryFileName(de),fsm));
#else
X	return(TRUE);
#endif
} /* End DirectoryMgrFilterName */
SHAR_EOF
chmod 0644 xarchie-2.0.6/FWF/Dir/DirMgr.c ||
echo 'restore of xarchie-2.0.6/FWF/Dir/DirMgr.c failed'
Wc_c="`wc -c < 'xarchie-2.0.6/FWF/Dir/DirMgr.c'`"
test 12237 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/FWF/Dir/DirMgr.c: original size 12237, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/FWF/Dir/DirMgr.h ==============
if test -f 'xarchie-2.0.6/FWF/Dir/DirMgr.h' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/FWF/Dir/DirMgr.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/FWF/Dir/DirMgr.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/FWF/Dir/DirMgr.h' &&
/****************************************************************************
X
X	DirMgr.h
X
X	This file contains the C declarations and definitions for the
X	DirectoryMgr system.
X
X	This system is intended to managed filtered and sorted directory
X	lists.
X
X ****************************************************************************/
/*
X * Copyright 1990,1991,1992 Brian Totty
X * 
X * Permission to use, copy, modify, distribute, and sell this software
X * and its documentation for any purpose is hereby granted without fee,
X * provided that the above copyright notice appears in all copies and that
X * both that copyright notice and this permission notice appear in
X * supporting documentation, and that the name of Brian Totty or
X * University of Illinois not be used in advertising or publicity
X * pertaining to distribution of the software without specific, written
X * prior permission.  Brian Totty and University of Illinois make no
X * representations about the suitability of this software for any
X * purpose.  It is provided "as is" without express or implied warranty.
X *
X * Brian Totty and University of Illinois disclaim all warranties with
X * regard to this software, including all implied warranties of
X * merchantability and fitness, in no event shall Brian Totty or
X * University of Illinois be liable for any special, indirect or
X * consequential damages or any damages whatsoever resulting from loss of
X * use, data or profits, whether in an action of contract, negligence or
X * other tortious action, arising out of or in connection with the use or
X * performance of this software.
X *
X * Author:
X * 	Brian Totty
X * 	Department of Computer Science
X * 	University Of Illinois at Urbana-Champaign
X *	1304 West Springfield Avenue
X * 	Urbana, IL 61801
X * 
X * 	totty@cs.uiuc.edu
X * 	
X */ 
X
#ifndef _DIRECTORY_MGR_H_
#define	_DIRECTORY_MGR_H_
X
#include <Directory.h>
X
/*---------------------------------------------------------------------------*
X
X        Simple DirectoryMgr Interface
X
X		DirectoryMgrSimpleOpen();
X		DirectoryMgrSimpleRefilter();
X		DirectoryMgrSimpleResort();
X
X	Standard DirectoryMgr Interface
X
X		DirectoryMgrOpen();
X		DirectoryMgrClose();
X		DirectoryMgrRefilter();
X		DirectoryMgrRefresh();
X		DirectoryMgrResort();
X
X	Moving Around Items
X
X		DirectoryMgrGotoItem();
X		DirectoryMgrGotoNamedItem();
X		DirectoryMgrRestart();
X		DirectoryMgrGetIndex();
X		DirectoryMgrCurrentEntry();
X		DirectoryMgrNextEntry();
X		DirectoryMgrPrevEntry();
X
X	Utility Functions
X
X		DirectoryMgrSimpleFilterFunc();
X		DirectoryMgrSimpleSortingFunc();
X
X	Comparison Functions
X
X		DirectoryMgrCompareName();
X		DirectoryMgrCompareSizeAscending();
X		DirectoryMgrCompareSizeDescending();
X
X	Macros
X
X		DirectoryMgrDir();
X		DirectoryMgrData();
X		DirectoryMgrSortedPtrs();
X		DirectoryMgrFilterFunc();
X		DirectoryMgrCompFunc();
X		DirectoryMgrFilterData();
X		DirectoryMgrFreeFilterData();
X		DirectoryMgrTotalCount();
X		DirectoryMgrFilteredCount();
X		DirectoryMgrCurrentIndex();
X
X
X *---------------------------------------------------------------------------*/
X
#ifndef PFI
typedef int (*PFI)();
#endif
X
typedef struct entry_cons
{
X	DIR_ENTRY dir_entry;
X	struct entry_cons *next;
} DIR_ENTRY_CONS;
X
typedef	DIR_ENTRY_CONS DirEntryCons;
X
typedef struct
{
X	DIRECTORY dir;
X	DIR_ENTRY *data;
X	DIR_ENTRY **sorted_ptrs;
X	int total_count;
X	int filtered_count;
X	PFI filter_func;
X	char *filter_data;
X	int free_filter_data;
X	PFI comp_func;
X	int current_index;
} DIRECTORY_MGR;
X
typedef	DIRECTORY_MGR DirectoryMgr;
X
#define	DIR_MGR_SORT_NONE			0
#define	DIR_MGR_SORT_NAME			1
#define	DIR_MGR_SORT_NAME_DIRS_FIRST		2
#define DIR_MGR_SORT_SIZE_ASCENDING		3
#define DIR_MGR_SORT_SIZE_DESCENDING		4
#define	DIR_MGR_SORT_ACCESS_ASCENDING		5
#define	DIR_MGR_SORT_ACCESS_DESCENDING		6
X
#define	DirectoryMgrDir(dm)		(&((dm)->dir))
#define	DirectoryMgrData(dm)		((dm)->data)
#define	DirectoryMgrSortedPtrs(dm)	((dm)->sorted_ptrs)
#define	DirectoryMgrFilterFunc(dm)	((dm)->filter_func)
#define	DirectoryMgrCompFunc(dm)	((dm)->comp_func)
#define	DirectoryMgrFilterData(dm)	((dm)->filter_data)
#define	DirectoryMgrFreeFilterData(dm)	((dm)->free_filter_data)
#define	DirectoryMgrTotalCount(dm)	((dm)->total_count)
#define	DirectoryMgrFilteredCount(dm)	((dm)->filtered_count)
#define	DirectoryMgrCurrentIndex(dm)	((dm)->current_index)
X
#if (!NeedFunctionPrototypes)
X
DirectoryMgr *	DirectoryMgrSimpleOpen();
int		DirectoryMgrSimpleRefilter();
int		DirectoryMgrSimpleResort();
X
DirectoryMgr *	DirectoryMgrOpen();
void		DirectoryMgrClose();
int		DirectoryMgrRefilter();
int		DirectoryMgrRefresh();
void		DirectoryMgrResort();
X
int		DirectoryMgrGotoItem();
int		DirectoryMgrGotoNamedItem();
void		DirectoryMgrRestart();
int		DirectoryMgrGetIndex();
DirEntry *	DirectoryMgrCurrentEntry();
DirEntry *	DirectoryMgrNextEntry();
DirEntry *	DirectoryMgrPrevEntry();
X
int		DirectoryMgrSimpleFilterFunc();
int		DirectoryMgrSimpleSortingFunc();
X
int		DirectoryMgrCompareName();
int		DirectoryMgrCompareNameDirsFirst();
int		DirectoryMgrCompareSizeAscending();
int		DirectoryMgrCompareSizeDescending();
int		DirectoryMgrCompareLastAccessAscending();
int		DirectoryMgrCompareLastAccessDescending();
X
int		DirectoryMgrFilterName();
X
#else
X
DirectoryMgr *	DirectoryMgrSimpleOpen(char *path, int sort_type,
X			char *pattern);
int		DirectoryMgrSimpleRefilter(DirectoryMgr *dm, char *pattern);
int		DirectoryMgrSimpleResort(DirectoryMgr *dm, int sort_type);
X
DirectoryMgr *	DirectoryMgrOpen(char *path, PFI c_func, PFI f_func,
X			char *f_data, int free_data);
void		DirectoryMgrClose(DirectoryMgr *dm);
int		DirectoryMgrRefilter(DirectoryMgr *dm, PFI f_func,
X			char *f_data, int f_free);
int		DirectoryMgrRefresh(DirectoryMgr *dm);
void		DirectoryMgrResort(DirectoryMgr *dm, PFI c_func);
X
int		DirectoryMgrGotoItem(DirectoryMgr *dm, int i);
int		DirectoryMgrGotoNamedItem(DirectoryMgr *dm, char *name);
void		DirectoryMgrRestart(DirectoryMgr *dm);
DirEntry *	DirectoryMgrCurrentEntry(DirectoryMgr *dm);
DirEntry *	DirectoryMgrNextEntry(DirectoryMgr *dm);
DirEntry *	DirectoryMgrPrevEntry(DirectoryMgr *dm);
X
int		DirectoryMgrSimpleFilterFunc(char *pattern, PFI *ff_ptr,
X			char **fd_ptr);
int		DirectoryMgrSimpleSortingFunc(int sort_type, PFI *sf_ptr);
X
int		DirectoryMgrCompareName(DirEntry **e1p, DirEntry **e2p);
int		DirectoryMgrCompareNameDirsFirst(DirEntry **e1p,
X			DirEntry **e2p);
int		DirectoryMgrCompareSizeAscending(DirEntry **e1p,
X			DirEntry **e2p);
int		DirectoryMgrCompareSizeDescending(DirEntry **e1p,
X			DirEntry **e2p);
int		DirectoryMgrCompareLastAccessAscending(DirEntry **e1p,
X			DirEntry **e2p);
int		DirectoryMgrCompareLastAccessDescending(DirEntry **e1p,
X			DirEntry **e2p);
X
int		DirectoryMgrFilterName(DirEntry *de, char *fsm);
X
#endif
X
#endif
SHAR_EOF
chmod 0644 xarchie-2.0.6/FWF/Dir/DirMgr.h ||
echo 'restore of xarchie-2.0.6/FWF/Dir/DirMgr.h failed'
Wc_c="`wc -c < 'xarchie-2.0.6/FWF/Dir/DirMgr.h'`"
test 6706 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/FWF/Dir/DirMgr.h: original size 6706, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/FWF/Dir/DirMgrT.c ==============
if test -f 'xarchie-2.0.6/FWF/Dir/DirMgrT.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/FWF/Dir/DirMgrT.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/FWF/Dir/DirMgrT.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/FWF/Dir/DirMgrT.c' &&
/*
X * Copyright 1990,1991,1992 Brian Totty
X * 
X * Permission to use, copy, modify, distribute, and sell this software
X * and its documentation for any purpose is hereby granted without fee,
X * provided that the above copyright notice appears in all copies and that
X * both that copyright notice and this permission notice appear in
X * supporting documentation, and that the name of Brian Totty or
X * University of Illinois not be used in advertising or publicity
X * pertaining to distribution of the software without specific, written
X * prior permission.  Brian Totty and University of Illinois make no
X * representations about the suitability of this software for any
X * purpose.  It is provided "as is" without express or implied warranty.
X *
X * Brian Totty and University of Illinois disclaim all warranties with
X * regard to this software, including all implied warranties of
X * merchantability and fitness, in no event shall Brian Totty or
X * University of Illinois be liable for any special, indirect or
X * consequential damages or any damages whatsoever resulting from loss of
X * use, data or profits, whether in an action of contract, negligence or
X * other tortious action, arising out of or in connection with the use or
X * performance of this software.
X *
X * Author:
X * 	Brian Totty
X * 	Department of Computer Science
X * 	University Of Illinois at Urbana-Champaign
X *	1304 West Springfield Avenue
X * 	Urbana, IL 61801
X * 
X * 	totty@cs.uiuc.edu
X * 	
X */ 
#include <stdio.h>
#include <DirMgr.h>
X
int main(argc,argv)
int argc;
char **argv;
{
X	DIRECTORY_MGR *dm;
X	DIR_ENTRY *de;
X	char *path,*pat;
X	int sort_mode;
X
X	if (argc != 3 && argc != 4)
X	{
X		fprintf(stderr,"usage: %s path sort_mode [pattern]\n",argv[0]);
X		exit(-1);
X	}
X	path = argv[1];
X	sort_mode = atoi(argv[2]);
X	if (argc == 4)
X		pat = argv[3];
X	    else
X		pat = NULL;
X	dm = DirectoryMgrSimpleOpen(path,sort_mode,pat);
X	if (dm == NULL)
X	{
X		fprintf(stderr,"Can't open directory mgr for '%s'\n",path);
X		exit(-1);
X	}
X	while (1)
X	{
X		de = DirectoryMgrNextEntry(dm);
X		if (de == NULL) break;
X		DirEntryDump(stderr,de);
X	}
X
X	printf("Changing sort mode to 1\n");
X	DirectoryMgrSimpleResort(dm,1);
X	while (1)
X	{
X		de = DirectoryMgrNextEntry(dm);
X		if (de == NULL) break;
X		DirEntryDump(stderr,de);
X	}
X
X
X	DirectoryMgrClose(dm);
X	return(1);
}
SHAR_EOF
chmod 0644 xarchie-2.0.6/FWF/Dir/DirMgrT.c ||
echo 'restore of xarchie-2.0.6/FWF/Dir/DirMgrT.c failed'
Wc_c="`wc -c < 'xarchie-2.0.6/FWF/Dir/DirMgrT.c'`"
test 2302 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/FWF/Dir/DirMgrT.c: original size 2302, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/FWF/Dir/Directory.c ==============
if test -f 'xarchie-2.0.6/FWF/Dir/Directory.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/FWF/Dir/Directory.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/FWF/Dir/Directory.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/FWF/Dir/Directory.c' &&
/****************************************************************************
X
X        Directory.c
X
X	This file contains the C code that implements the directory
X	iteration and file information subsystem.
X
X	This code is intended to be used as a convenient, machine
X	independent interface to iterate through the contents of a
X	directory.
X
X ****************************************************************************/
/*
X * Copyright 1990,1991,1992 Brian Totty
X * 
X * Permission to use, copy, modify, distribute, and sell this software
X * and its documentation for any purpose is hereby granted without fee,
X * provided that the above copyright notice appears in all copies and that
X * both that copyright notice and this permission notice appear in
X * supporting documentation, and that the name of Brian Totty or
X * University of Illinois not be used in advertising or publicity
X * pertaining to distribution of the software without specific, written
X * prior permission.  Brian Totty and University of Illinois make no
X * representations about the suitability of this software for any
X * purpose.  It is provided "as is" without express or implied warranty.
X *
X * Brian Totty and University of Illinois disclaim all warranties with
X * regard to this software, including all implied warranties of
X * merchantability and fitness, in no event shall Brian Totty or
X * University of Illinois be liable for any special, indirect or
X * consequential damages or any damages whatsoever resulting from loss of
X * use, data or profits, whether in an action of contract, negligence or
X * other tortious action, arising out of or in connection with the use or
X * performance of this software.
X *
X * Author:
X * 	Brian Totty
X * 	Department of Computer Science
X * 	University Of Illinois at Urbana-Champaign
X *	1304 West Springfield Avenue
X * 	Urbana, IL 61801
X * 
X * 	totty@cs.uiuc.edu
X * 	
X */ 
X
#include <Directory.h>
#include <RegExp.h>
X
/*--------------------------------------------------------------------------*
X
X        L O W    L E V E L    D I R E C T O R Y    I N T E R F A C E
X
X *--------------------------------------------------------------------------*/
X
int DirectoryOpen(dir_name,dp)
char *dir_name;
Directory *dp;
{
X	DirectoryDir(dp) = opendir(dir_name);
X	if (DirectoryDir(dp) == NULL) return(FALSE);
X	if (DirectoryPathExpand(dir_name,DirectoryPath(dp)) == NULL)
X	{
X		closedir(DirectoryDir(dp));
X		return(FALSE);
X	}
X	return(TRUE);
} /* End DirectoryOpen */
X
X
void DirectoryRestart(dp)
Directory *dp;
{
X	rewinddir(DirectoryDir(dp));
} /* End DirectoryRestart */
X
X
void DirectoryClose(dp)
Directory *dp;
{
X	closedir(DirectoryDir(dp));
} /* End DirectoryClose */
X
X
long DirectoryTellPosition(dp)
Directory *dp;
{
X	return(telldir(DirectoryDir(dp)));
} /* End DirectoryTellPosition */
X
X
void DirectorySetPosition(dp,pos)
Directory *dp;
long pos;
{
X	seekdir(DirectoryDir(dp),pos);
} /* End DirectorySetPosition */
X
X
int DirectoryReadNextEntry(dp,de)
Directory *dp;
DirEntry *de;
{
X	u_short orig_file_type;
X	static struct dirent *_ep;
X	static struct stat _lstats,_stats;
X	char full_path[MAXPATHLEN + 2];
X
X	_ep = readdir(DirectoryDir(dp));
X	if (_ep == NULL) return(FALSE);
X	strcpy(DirEntryFileName(de),_ep->d_name);
X	strcpy(full_path,DirectoryPath(dp));
X	strcat(full_path,DirEntryFileName(de));
X
X	if (lstat(full_path,&_lstats) != 0) return(FALSE);
X
X	orig_file_type = _lstats.st_mode & S_IFMT;
X	switch (orig_file_type)
X	{
X	    case S_IFDIR:
X		DirEntryType(de) = F_TYPE_DIR;
X		break;
X	    case S_IFREG:
X		DirEntryType(de) = F_TYPE_FILE;
X		break;
X	    case S_IFCHR:
X		DirEntryType(de) = F_TYPE_CHAR_SPECIAL;
X		break;
X	    case S_IFBLK:
X		DirEntryType(de) = F_TYPE_BLOCK_SPECIAL;
X		break;
X	    case S_IFLNK:
X		DirEntryType(de) = F_TYPE_SYM_LINK;
X		break;
X	    case S_IFSOCK:
X		DirEntryType(de) = F_TYPE_SOCKET;
X		break;
#ifdef S_IFIFO
X	    case S_IFIFO:
X		DirEntryType(de) = F_TYPE_FIFO;
X		break;
#endif
X	    default:
X		DirEntryType(de) = orig_file_type;
X		break;
X	}
X
X	DirEntryIsBrokenLink(de) = FALSE;
X	DirEntryIsDirectoryLink(de) = FALSE;
X	if (DirEntryIsSymLink(de))			/* Symbolic Link */
X	{
X		if (stat(full_path,&_stats) != 0)	/* Can't Stat File */
X		{
X			DirEntryIsBrokenLink(de) = TRUE;
X			_stats = _lstats;
X		}
X		    else				/* Link Not Broken */
X		{
#ifdef SLOW_DIRLINK_TEST
X		        char temp_path[MAXPATHLEN + 2];
X			if (DirectoryPathExpand(full_path,temp_path) != NULL)
X			{
#else
X			if ((_stats.st_mode & S_IFMT) == S_IFDIR)
X			{
#endif
X				DirEntryIsDirectoryLink(de) = TRUE;
X			}
X
X		}
X	}
X	    else					/* Not Symbolic Link */
X	{
X		_stats = _lstats;
X	}
X
X	FileInfoOrigMode(DirEntrySelfInfo(de)) = _lstats.st_mode;
X	FileInfoProt(DirEntrySelfInfo(de)) = _lstats.st_mode & 0777;
X	FileInfoUserID(DirEntrySelfInfo(de)) = _lstats.st_uid;
X	FileInfoGroupID(DirEntrySelfInfo(de)) = _lstats.st_gid;
X	FileInfoFileSize(DirEntrySelfInfo(de)) = _lstats.st_size;
X	FileInfoLastAccess(DirEntrySelfInfo(de)) = _lstats.st_atime;
X	FileInfoLastModify(DirEntrySelfInfo(de)) = _lstats.st_mtime;
X	FileInfoLastStatusChange(DirEntrySelfInfo(de)) = _lstats.st_ctime;
X
X	FileInfoOrigMode(DirEntryActualInfo(de)) = _stats.st_mode;
X	FileInfoProt(DirEntryActualInfo(de)) = _stats.st_mode & 0777;
X	FileInfoUserID(DirEntryActualInfo(de)) = _stats.st_uid;
X	FileInfoGroupID(DirEntryActualInfo(de)) = _stats.st_gid;
X	FileInfoFileSize(DirEntryActualInfo(de)) = _stats.st_size;
X	FileInfoLastAccess(DirEntryActualInfo(de)) = _stats.st_atime;
X	FileInfoLastModify(DirEntryActualInfo(de)) = _stats.st_mtime;
X	FileInfoLastStatusChange(DirEntryActualInfo(de)) = _stats.st_ctime;
X
X	return(TRUE);
} /* End DirectoryReadNextEntry */
X
X
char *DirectoryPathExpand(old_path,new_path)
char *old_path,*new_path;
{
X	register char *p;
X	char path[MAXPATHLEN + 2];
X
X	if (getwd(path) == NULL) return(NULL);
X	if (chdir(old_path) != 0) return(NULL);
X	if (getwd(new_path) == NULL) strcpy(new_path,old_path);
X	if (chdir(path) != 0) return(NULL);
X	for (p = new_path; *p != '\0'; p++)
X	    /*EMPTY*/;
X	if ((p != new_path) && *(p - 1) != '/')
X	{
X		*p++ = '/';
X		*p = '\0';
X	}
X	return(new_path);
} /* End DirectoryPathExpand */
X
X
/*---------------------------------------------------------------------------*
X
X             D I R E C T O R Y    E N T R Y    R O U T I N E S
X
X *---------------------------------------------------------------------------*/
X
void DirEntryDump(fp,de)
FILE *fp;
DirEntry *de;
{
X	fprintf(fp,"%20s, Size %7d, Prot %3o\n",
X		DirEntryFileName(de),DirEntryFileSize(de),DirEntryProt(de));
} /* End DirEntryDump */
SHAR_EOF
chmod 0644 xarchie-2.0.6/FWF/Dir/Directory.c ||
echo 'restore of xarchie-2.0.6/FWF/Dir/Directory.c failed'
Wc_c="`wc -c < 'xarchie-2.0.6/FWF/Dir/Directory.c'`"
test 6473 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/FWF/Dir/Directory.c: original size 6473, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/FWF/Dir/Directory.h ==============
if test -f 'xarchie-2.0.6/FWF/Dir/Directory.h' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/FWF/Dir/Directory.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/FWF/Dir/Directory.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/FWF/Dir/Directory.h' &&
/****************************************************************************
X
X	Directory.h
X
X	This file contains the C definitions and declarations for the
X	Directory.c directory iteration code.
X
X	This code is intended to be used as a convenient, machine
X	independent interface to iterate through the contents of a
X	directory.
X
X ****************************************************************************/
/*
X * Copyright 1990,1991,1992 Brian Totty
X * 
X * Permission to use, copy, modify, distribute, and sell this software
X * and its documentation for any purpose is hereby granted without fee,
X * provided that the above copyright notice appears in all copies and that
X * both that copyright notice and this permission notice appear in
X * supporting documentation, and that the name of Brian Totty or
X * University of Illinois not be used in advertising or publicity
X * pertaining to distribution of the software without specific, written
SHAR_EOF
true || echo 'restore of xarchie-2.0.6/FWF/Dir/Directory.h failed'
fi
echo 'End of xarchie-2.0.6 part 19'
echo 'File xarchie-2.0.6/FWF/Dir/Directory.h is continued in part 20'
echo 20 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM       | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@imd.sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
