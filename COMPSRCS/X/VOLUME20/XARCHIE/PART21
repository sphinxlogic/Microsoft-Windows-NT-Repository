Newsgroups: comp.sources.x
From: ferguson@cs.rochester.edu (George Ferguson)
Subject: v20i049:  xarchie - An X browser interface to Archie, v2.0.6, Part21/24
Message-ID: <1993Jun15.223532.1873@sparky.imd.sterling.com>
X-Md4-Signature: 41ea0e40f9111a080ee810b8d504c0f3
Sender: chris@sparky.imd.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Tue, 15 Jun 1993 22:35:32 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: ferguson@cs.rochester.edu (George Ferguson)
Posting-number: Volume 20, Issue 49
Archive-name: xarchie/part21
Environment: X11
Supersedes: xarchie: Volume 14, Issue 82-90

Submitted-by: ferguson@cs.rochester.edu
Archive-name: xarchie-2.0.6/part21

#!/bin/sh
# this is Part.21 (part 21 of xarchie-2.0.6)
# do not concatenate these parts, unpack them in order with /bin/sh
# file xarchie-2.0.6/FWF/FileChooser/FChooser.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 21; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping xarchie-2.0.6/FWF/FileChooser/FChooser.c'
else
echo 'x - continuing file xarchie-2.0.6/FWF/FileChooser/FChooser.c'
sed 's/^X//' << 'SHAR_EOF' >> 'xarchie-2.0.6/FWF/FileChooser/FChooser.c' &&
XXfwfFileChooserWidget fcw;
{
X    int i;
X
X    XtFree(FCCurrentDirectory(fcw));
X    XtFree(FCCurrentFile(fcw));
X    XtFree(FCPattern(fcw));
X    if (FCFileNames(fcw) != NULL) {
X	for (i=0; i < FCNumFileNames(fcw); i++)
X	    XtFree(FCFileNames(fcw)[i]);
X	XtFree((char *)FCFileNames(fcw));
X    }
X    if (FCDirNames(fcw) != NULL) {
X	for (i=0; i < FCNumDirNames(fcw); i++)
X	    XtFree(FCDirNames(fcw)[i]);
X	XtFree((char *)FCDirNames(fcw));
X    }
} /* End Destroy */
X
/*---------------------------------------------------------------------------*
X
X	Resize()
X
X	This function is called to resize a FileChooser widget.
X
X *---------------------------------------------------------------------------*/
X
static void
Resize(w) 
Widget w;
{
X    XfwfFileChooserWidget fcw = (XfwfFileChooserWidget)w;
X
X    ChildrenUpdate(fcw);
} /* End Resize */
X
/*---------------------------------------------------------------------------*
X
X	SetValues()
X
X	This function is the external interface for setting resources.
X
X *---------------------------------------------------------------------------*/
X
/* ARGSUSED */
static Boolean
SetValues(current,request,new)
Widget current,request,new;
{
X    XfwfFileChooserWidget fcw_current = (XfwfFileChooserWidget)current;
X    XfwfFileChooserWidget fcw_new = (XfwfFileChooserWidget)new;
X
X    if (FCCurrentDirectory(fcw_current) != FCCurrentDirectory(fcw_new)){
X	strcpy(FCCurrentDirectory(fcw_current),FCCurrentDirectory(fcw_new));
X	FCCurrentDirectory(fcw_new) = FCCurrentDirectory(fcw_current);
X	Chdir(fcw_new);
X    }
X    if (FCCurrentFile(fcw_current) != FCCurrentFile(fcw_new)) {
X	char *new_name;
X
X	new_name = FCCurrentFile(fcw_new);
X	FCCurrentFile(fcw_new) = FCCurrentFile(fcw_current);
X	SelectFileByName(fcw_new,new_name);
X    }
X    if (FCPattern(fcw_current) != FCPattern(fcw_new)) {
X	XtFree(FCPattern(fcw_current));
X	FCPattern(fcw_new) = XtNewString(FCPattern(fcw_current));
X	Chdir(fcw_new);
X    }
X    if (FCSortMode(fcw_current) != FCSortMode(fcw_new)) {
X	Chdir(fcw_new);
X    }
X    return(False);
} /* End SetValues() */
X
/*---------------------------------------------------------------------------*
X
X	GeometryManager(w,request,reply)
X
X	This routine acts as the geometry_manager method for the
X	FileChooser widget.  It is called when a child wants to
X	resize/reposition itself.
X
X	Currently, we allow all requests.
X
X *---------------------------------------------------------------------------*/
X
/* ARGSUSED */
static XtGeometryResult
GeometryManager(w,request,reply)
Widget w;
XXtWidgetGeometry *request;
XXtWidgetGeometry *reply;
{
X    return(XtGeometryYes);
} /* End GeometryManager */
X
/*---------------------------------------------------------------------------*
X
X                     L O C A L    R O U T I N E S
X
X *---------------------------------------------------------------------------*/
X
/*---------------------------------------------------------------------------*
X
X	ChildrenCreate(fcw)
X
X	This routine creates the initial child widgets for the
X	file selector widget and places them in the widget fcw.
X	No placement or resizing is done.  That is done by
X	ChildrenUpdate().
X
X *---------------------------------------------------------------------------*/
X
static void
ChildrenCreate(fcw)
XXfwfFileChooserWidget fcw;
{
X    Arg args[2];
X    static char *str = NULL;
X
X    XtSetArg(args[0],XtNmenuName,FC_DIR_MENU_NAME);
X    FCDirMenuButton(fcw) =
X	XtCreateManagedWidget(FC_DIR_MENU_BUTTON_NAME,menuButtonWidgetClass,
X			      (Widget)fcw,args,1);
X    XtSetArg(args[0],XtNallowVert,True);
X    XtSetArg(args[1],XtNforceBars,True);
X    FCFileViewport(fcw) =
X	XtCreateManagedWidget(FC_FILE_VIEWPORT_NAME,viewportWidgetClass,
X			      (Widget)fcw,args,2);
X    XtSetArg(args[0],XtNlist,&str);
X    XtSetArg(args[1],XtNverticalList,True);
X    FCFileList(fcw) = XtCreateManagedWidget(FC_FILE_LIST_NAME,listWidgetClass,
X					    FCFileViewport(fcw),args,2);
X    XtAddCallback(FCFileList(fcw),XtNcallback,
X		  (XtCallbackProc)FileCallback,(XtPointer)fcw);
} /* End ChildrenCreate */
X
/*---------------------------------------------------------------------------*
X
X	ChildrenRealize(fcw)
X
X	This routine realizes the child widgets.  The widgets must
X	already have been created and initialized.  Their coordinates
X	should already have been set.
X
X *---------------------------------------------------------------------------*/
X
static void
ChildrenRealize(fcw)
XXfwfFileChooserWidget fcw;
{
X    XtRealizeWidget(FCDirMenuButton(fcw));
X    XtRealizeWidget(FCFileViewport(fcw));
X    XtRealizeWidget(FCFileList(fcw));
} /* End ChildrenRealize */
X
/*---------------------------------------------------------------------------*
X
X	ChildrenUpdate(fcw)
X
X	This routine takes a FileChooser widget fcw and updates
X	the child widgets by recalculating their coordinates based
X	on the current size of the FileChooser, and setting the
X	appropriate resources.
X
X	We go to some trouble to get something useful displayed in the
X	FCDirMenuButton(fcw) if the current directory name is too long
X	to fit in the button. It would be nice if the "justify" resource
X	of the MenuButton widget did this, but...
X
X *---------------------------------------------------------------------------*/
X
static void
ChildrenUpdate(fcw)
XXfwfFileChooserWidget fcw;
{
X    Dimension w,h;
X    int gap;
X    Dimension menuButtonW,menuButtonH,fileListW,fileListH;
X    Position menuButtonX,menuButtonY,fileListX,fileListY;
X    XtWidgetGeometry parent_idea,child_idea;
X    Arg args[3];
X    XFontStruct *fs;
X    char *label;
X    Dimension intw;
X
X    if (!XtIsRealized((Widget)fcw)) {
X	return;
X    }
X    w = CoreWidth(fcw);
X    h = CoreHeight(fcw);
X    gap = 3;
X    /* Get The Child Widgets Current Widths And Heights */
X    /* (although we don't actually use the existing values... */
X    menuButtonW = CoreWidth(FCDirMenuButton(fcw));
X    menuButtonH = CoreHeight(FCDirMenuButton(fcw));
X    fileListW = CoreWidth(FCFileList(fcw));
X    fileListH = CoreHeight(FCFileList(fcw));
X    /* Adjust Widths */
X    menuButtonW = w;
X    fileListW = w;
X    /* Adjust menu button label if too small */
X    /* It would be nice if the "justify" resource of MenuButton did this... */
X    XtSetArg(args[0],XtNinternalWidth,&intw);
X    XtSetArg(args[1],XtNfont,&fs);
X    XtGetValues(FCDirMenuButton(fcw),args,2);
X    label = FCCurrentDirectory(fcw);
X    if (XTextWidth(fs,label,strlen(label)) > (int)(menuButtonW-intw)) {
X	char newLabel[MAXPATHLEN];
X	while (*label && XTextWidth(fs,label,strlen(label)) >
X	                                           (int)(menuButtonW-intw)) {
X	    label += 1;
X	}
X	if (*label)
X	    label += 1;
X	strcpy(newLabel,"<");
X	strcat(newLabel,label);
X	XtSetArg(args[0],XtNlabel,newLabel);
X	XtSetValues(FCDirMenuButton(fcw),args,1);
X    }
X    /* Adjust Heights */
X    fileListH = h - menuButtonH - gap;
X    /* Listen To Child Height Request For List */
X    parent_idea.request_mode = CWWidth | CWHeight;
X    parent_idea.width = fileListW;
X    parent_idea.height = fileListH;
X    XtQueryGeometry(FCFileList(fcw),&parent_idea,&child_idea);
X    if ((child_idea.request_mode & CWHeight) &&
X	(child_idea.height < parent_idea.height)) {
X	fileListH = child_idea.height;
X    }
X    /* Vertical Positions */
X    menuButtonY = 0;
X    fileListY = menuButtonH + gap;
X    /* Horizontal Positions */
X    menuButtonX = 0;
X    fileListX = 0;
X    /* Move them */
X    XtMoveWidget(FCDirMenuButton(fcw),menuButtonX,menuButtonY);
X    XtMoveWidget(FCFileViewport(fcw),fileListX,fileListY);
X    /* Resize them */
X    XtResizeWidget(FCDirMenuButton(fcw),menuButtonW,menuButtonH,
X		   CoreBorderWidth(FCDirMenuButton(fcw)));
X    XtResizeWidget(FCFileViewport(fcw),fileListW,fileListH,
X		   CoreBorderWidth(FCFileViewport(fcw)));
} /* End ChildrenUpdate */
X
/*---------------------------------------------------------------------------*
X
X                 I N T E R N A L    C A L L B A C K S
X
X *---------------------------------------------------------------------------*/
X
/*---------------------------------------------------------------------------*
X
X	DirectoryCallback(w,client_data,call_data)
X
X	This is called when the user selects an ancestor directory from
X	the menu. The argument "w" is the selected object (hence the two
X	calls to XtParent()) and "client_data" is it's index in the menu.
X
X *---------------------------------------------------------------------------*/
X
/*ARGSUSED*/
static void
DirectoryCallback(w,client_data,call_data)
Widget w;
XXtPointer client_data;	/* index */
XXtPointer call_data;	/* not used */
{
X    int index = (int)client_data;
X    XfwfFileChooserWidget fcw = (XfwfFileChooserWidget)XtParent(XtParent(w));
X    int i;
X
X    strcpy(FCCurrentDirectory(fcw),"/");
X    for (i = 1; i <= index; i++) {
X	strcat(FCCurrentDirectory(fcw),FCDirNames(fcw)[i]);
X	strcat(FCCurrentDirectory(fcw),"/");
X    }
X    Chdir(fcw);
} /* End DirectoryCallback */
X
/*---------------------------------------------------------------------------*
X
X	FileCallback(w,client_data,call_data)
X
X	This is called when the user selects a file in the fileList.
X	The argument "client_data" is the FileChooser widget, "call_data"
X	is a pointer to the standard List widget callback information.
X
X *---------------------------------------------------------------------------*/
X
/*ARGSUSED*/
static void
FileCallback(w,client_data,call_data)
Widget w;
XXtPointer client_data;	/* fcw */
XXtPointer call_data;	/* return struct */
{
X    XfwfFileChooserWidget fcw = (XfwfFileChooserWidget)client_data;
X    XawListReturnStruct *ret = (XawListReturnStruct *)call_data;
X
X    if (ret->list_index == -1) {
X	UnselectAll(fcw);		/* Click On Blank Space */
X	Notify(fcw);
X    } else {
X	SelectFileByIndex(fcw,ret->list_index);
X    }
} /* End FileCallback */
X
/*---------------------------------------------------------------------------*
X
X             I N T E R N A L    S U P P O R T    R O U T I N E S
X
X *---------------------------------------------------------------------------*/
X
static void
SelectFileByIndex(fcw,index)
XXfwfFileChooserWidget fcw;
int index;
{
X    DirEntry *dir_entry;
X
X    DirectoryMgrGotoItem(FCDirMgr(fcw),index);
X    if ((dir_entry=DirectoryMgrCurrentEntry(FCDirMgr(fcw))) == NULL) {
X	fprintf(stderr,"SelectFileByIndex: Entry %d invalid\n",index);
X	XtAppErrorMsg(XtWidgetToApplicationContext((Widget)fcw),
X		      "selectFailed","SelectFileByIndex","XfwfError",
X		      "FileChooser: SelectFileByIndex failed.",
X		      (String*)NULL,(Cardinal*)NULL);
X    }
X    if (DirEntryIsDir(dir_entry) || DirEntryIsDirectoryLink(dir_entry)) {
X	strcat(FCCurrentDirectory(fcw),DirEntryFileName(dir_entry));
X	Chdir(fcw);
X    } else if (!DirEntryIsBrokenLink(dir_entry)) {	/* File */
X	strcpy(FCCurrentFile(fcw),DirEntryFileName(dir_entry));
X	XawListHighlight(FCFileList(fcw),index);
X	Notify(fcw);
X    } else {						/* Broken Link */
X	XBell(XtDisplay(fcw),0);
X	UnselectAll(fcw);
X    }
} /* End SelectFileByIndex */
X
static Boolean
SelectFileByName(fcw,name)
XXfwfFileChooserWidget fcw;
char *name;
{
X    if (DirectoryMgrGotoNamedItem(FCDirMgr(fcw),name) == FALSE) {
X	return(False);
X    }
X    SelectFileByIndex(fcw,DirectoryMgrCurrentIndex(FCDirMgr(fcw)));
X    return(True);
} /* End SelectFileByName */
X
static void
UnselectAll(fcw)
XXfwfFileChooserWidget fcw;
{
X    Boolean selected = FCCurrentFile(fcw)[0] != '\0';
X
X    FCCurrentFile(fcw)[0] = '\0';
X    XawListUnhighlight(FCFileList(fcw));
X    if (selected)
X	Notify(fcw);
} /* End UnselectAll */
X
static void
Notify(fcw)
XXfwfFileChooserWidget fcw;
{
X    XfwfFileChooserReturnStruct ret;
X
X    if (FCCurrentFile(fcw)[0] != '\0') {
X	ret.directory = FCCurrentDirectory(fcw);
X	ret.file = FCCurrentFile(fcw);
X    } else {
X	ret.directory = NULL;
X	ret.file = NULL;
X    }
X    XtCallCallbacks((Widget)fcw,XtNcallback,(XtPointer)&ret);
} /* End Notify */
X
/*---------------------------------------------------------------------------*
X
X	GotoDeepestLegalDirectory(fcw)
X
X	This function takes a FileChooser widget <fcw> and modifies the
X	directory string in FCCurrentDirectory(fcw) to be the deepest
X	legal directory above the string.  Partial or incorrect directory
X	names are stripped starting at the end.
X
X	It then calls UpdateLists() to reset the information dislayed in
X	the FileChooser.
X
X *---------------------------------------------------------------------------*/
X
static void
GotoDeepestLegalDirectory(fcw)
XXfwfFileChooserWidget fcw;
{
X    char *dir,*end;
X    char temp[MAXPATHLEN + 2];
X
X    dir = FCCurrentDirectory(fcw);
X    for (end=dir; *end != '\0'; ++end)
X	/*EMPTY*/;
X    while (1) {
X	if (DirectoryPathExpand(dir,temp) == NULL) {
X	    while (*end != '/' && end != dir) {
X		end -= 1;
X	    }
X	    *end = '\0';
X	} else {
X	    strcpy(FCCurrentDirectory(fcw),temp);
X	    break;
X	}
X    }
X    UnselectAll(fcw);
X    UpdateLists(fcw);
} /* End GotoDeepestLegalDirectory */
X
/*---------------------------------------------------------------------------*
X
X	UpdateLists(fcw)
X
X	This routine resets the information displayed in a FileChooser
X	widget by doing the following:
X	1. It changes the cursor to the value of the "busyCursor" resource.
X	2. The old directory manager (FCDirMgr(fcw)) is closed and a
X	   new one opened based on the value of FCCurrentDirectory(fcw).
X	3. Any old string arrays are freed, and any existing directory
X	   menu is destroyed.
X	4. A new array of strings (FCFileNames(fcw)) is allocated and filled
X	   with the names of the files in the directory, then this array
X	   is used to set what is displayed in the FCFileList(fcw) widget.
X	5. A new array of strings (FCDirNames(fcw)) is allocated and filled
X	   with the names of the ancestor directories. These are also used
X	   to create a new FCDirMenu(fcw), and the label FCDirMenuButton(fcw)
X	   is set to the name of the directory.
X	6. Finally, the cursor is restored.
X
X *---------------------------------------------------------------------------*/
X
static void
UpdateLists(fcw)
XXfwfFileChooserWidget fcw;
{
X    Arg args[1];
X    int i,count;
X    char *dir,*start;
X    DirEntry *dir_entry;
X    char temp[MAXPATHLEN + 2];
X    Widget menuItem;
X
X    if (XtIsRealized((Widget)fcw)) {
X	/* This is puke-ola. */
X	XDefineCursor(XtDisplay(fcw),XtWindow(fcw),FCBusyCursor(fcw));
X	XDefineCursor(XtDisplay(fcw),XtWindow(FCFileList(fcw)),
X		      FCBusyCursor(fcw));
X	XDefineCursor(XtDisplay(fcw),XtWindow(FCDirMenuButton(fcw)),
X		      FCBusyCursor(fcw));
X	XFlush(XtDisplay(fcw));
X    }
X    if (FCDirMgr(fcw))
X	DirectoryMgrClose(FCDirMgr(fcw));
X    FCDirMgr(fcw) = DirectoryMgrSimpleOpen(FCCurrentDirectory(fcw),
X					   FCSortMode(fcw),FCPattern(fcw));
X
X    /* Throw away old info */
X    if (FCFileNames(fcw) != NULL) {
X	for (i = 0; i < FCNumFileNames(fcw); i++)
X	    XtFree(FCFileNames(fcw)[i]);
X	XtFree((char *)FCFileNames(fcw));
X    }
X    if (FCDirNames(fcw) != NULL) {
X	for (i = 0; i < FCNumDirNames(fcw); i++)
X	    XtFree(FCDirNames(fcw)[i]);
X	XtFree((char *)FCDirNames(fcw));
X    }
X    if (FCDirMenu(fcw) != NULL)
X	XtDestroyWidget(FCDirMenu(fcw));
X
X    /* Count how many files and dirs we have now */
X    FCNumFileNames(fcw) = DirectoryMgrFilteredCount(FCDirMgr(fcw));
X    FCNumDirNames(fcw) = 1;
X    for (dir=FCCurrentDirectory(fcw)+1; *dir != '\0'; dir++) {
X	if (*dir == '/') 
X	    FCNumDirNames(fcw) += 1;
X    }
X
X    /* Make the array of filenames and set the fileList widget */
X    FCFileNames(fcw) = (char **)XtCalloc(FCNumFileNames(fcw)+1,sizeof(char *));
X    for (i=0; i < FCNumFileNames(fcw); i++) {
X	dir_entry = DirectoryMgrNextEntry(FCDirMgr(fcw));
X	if (dir_entry == NULL)
X	    XtError("Inconsistent Directory");
X	strcpy(temp,DirEntryFileName(dir_entry));
X	if (DirEntryIsDir(dir_entry))
X	    strcat(temp,"/");
X	else if (DirEntryIsBrokenLink(dir_entry))
X	    strcat(temp," X");
X	else if (DirEntryIsDirectoryLink(dir_entry))
X	    strcat(temp,"/");
X	else if (DirEntryIsSymLink(dir_entry))
X	    strcat(temp," @");
X	FCFileNames(fcw)[i] = XtNewString(temp);
X    }
X    FCFileNames(fcw)[i] = NULL;
X    XawListChange(FCFileList(fcw),FCFileNames(fcw),FCNumFileNames(fcw),0,True);
X
X    /* Make the array of dirnames and build a new dirMenu widget */
X    FCDirNames(fcw) = (char **)XtCalloc(FCNumDirNames(fcw)+1,sizeof(char *));
X    FCDirNames(fcw)[0] = XtNewString("/");
X    FCDirMenu(fcw) = XtCreatePopupShell(FC_DIR_MENU_NAME,simpleMenuWidgetClass,
X					(Widget)fcw,NULL,0);
X    menuItem = XtCreateManagedWidget("/",smeBSBObjectClass,FCDirMenu(fcw),
X				     NULL,0);
X    XtAddCallback(menuItem,XtNcallback,DirectoryCallback,(XtPointer)0);
X    start = FCCurrentDirectory(fcw);
X    for (i = 1; i < FCNumDirNames(fcw); i++) {
X	while (*start != '\0' && *start == '/')
X	    start += 1;
X	count = 0;
X	while (*start != '\0' && *start != '/')
X	    temp[count++] = *start++;
X	temp[count] = '\0';
X	FCDirNames(fcw)[i] = XtNewString(temp);
X	XtSetArg(args[0],XtNlabel,temp);
X	menuItem = XtCreateManagedWidget("dirMenuItem",smeBSBObjectClass,
X					 FCDirMenu(fcw),args,1);
X        XtAddCallback(menuItem,XtNcallback,DirectoryCallback,(XtPointer)i);
X    }
X    XtSetArg(args[0],XtNlabel,FCCurrentDirectory(fcw));
X    XtSetValues(FCDirMenuButton(fcw),args,1);
X    if (XtIsRealized((Widget)fcw)) {
X	XUndefineCursor(XtDisplay(fcw),XtWindow(fcw));
X	XUndefineCursor(XtDisplay(fcw),XtWindow(FCFileList(fcw)));
X	XUndefineCursor(XtDisplay(fcw),XtWindow(FCDirMenuButton(fcw)));
X    }
} /* End UpdateLists */
X
static void Chdir(fcw)
XXfwfFileChooserWidget fcw;
{
X    GotoDeepestLegalDirectory(fcw);
X    ChildrenUpdate(fcw);
} /* End Chdir */
X
/*---------------------------------------------------------------------------*
X
X                    E X T E R N A L    R O U T I N E S
X
X *---------------------------------------------------------------------------*/
X
void
XXfwfFileChooserChangeDirectory(fcw,dir)
XXfwfFileChooserWidget fcw;
char *dir;
{
X    strcpy(FCCurrentDirectory(fcw),dir);
X    Chdir(fcw);
} /* End XfwfFileChooserChangeDirectory */
X
void
XXfwfFileChooserRefresh(fcw)
XXfwfFileChooserWidget fcw;
{
X    XfwfFileChooserChangeDirectory(fcw,".");
} /* End XfwfFileChooserRefresh */
X
char *
XXfwfFileChooserCurrentDirectory(fcw)
XXfwfFileChooserWidget fcw;
{
X    return(FCCurrentDirectory(fcw));
} /* End XfwfFileChooserCurrentDirectory */
X
char *
XXfwfFileChooserCurrentFile(fcw)
XXfwfFileChooserWidget fcw;
{
X    return(FCCurrentFile(fcw));
} /* End XfwfFileChooserCurrentFile */
X
SHAR_EOF
echo 'File xarchie-2.0.6/FWF/FileChooser/FChooser.c is complete' &&
chmod 0644 xarchie-2.0.6/FWF/FileChooser/FChooser.c ||
echo 'restore of xarchie-2.0.6/FWF/FileChooser/FChooser.c failed'
Wc_c="`wc -c < 'xarchie-2.0.6/FWF/FileChooser/FChooser.c'`"
test 28282 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/FWF/FileChooser/FChooser.c: original size 28282, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/FWF/FileChooser/FChooser.h ==============
if test -f 'xarchie-2.0.6/FWF/FileChooser/FChooser.h' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/FWF/FileChooser/FChooser.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/FWF/FileChooser/FChooser.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/FWF/FileChooser/FChooser.h' &&
/*
X * FChooser.h : Public header file for the FileChooser widget
X *
X * George Ferguson, ferguson@cs.rochester.edu, 21 Jan 1993.
X *
X * This code is derived from the FileSelector widget by Brian Totty,
X * hence the following copyright applies:
X *
X * Copyright 1990,1991,1992 Brian Totty
X * 
X * Permission to use, copy, modify, distribute, and sell this software
X * and its documentation for any purpose is hereby granted without fee,
X * provided that the above copyright notice appears in all copies and that
X * both that copyright notice and this permission notice appear in
X * supporting documentation, and that the name of Brian Totty or
X * University of Illinois not be used in advertising or publicity
X * pertaining to distribution of the software without specific, written
X * prior permission.  Brian Totty and University of Illinois make no
X * representations about the suitability of this software for any
X * purpose.  It is provided "as is" without express or implied warranty.
X *
X * Brian Totty and University of Illinois disclaim all warranties with
X * regard to this software, including all implied warranties of
X * merchantability and fitness, in no event shall Brian Totty or
X * University of Illinois be liable for any special, indirect or
X * consequential damages or any damages whatsoever resulting from loss of
X * use, data or profits, whether in an action of contract, negligence or
X * other tortious action, arising out of or in connection with the use or
X * performance of this software.
X *
X * Author:
X * 	Brian Totty
X * 	Department of Computer Science
X * 	University Of Illinois at Urbana-Champaign
X *	1304 West Springfield Avenue
X * 	Urbana, IL 61801
X * 
X * 	totty@cs.uiuc.edu
X * 	
X */ 
X
#ifndef _FCHOOSER_H
#define _FCHOOSER_H
X
#include <DirMgr.h>
X
extern WidgetClass xfwfFileChooserWidgetClass;
X
typedef struct _XfwfFileChooserClassRec	*XfwfFileChooserWidgetClass;
typedef struct _XfwfFileChooserRec	*XfwfFileChooserWidget;
X
#define	XtNcurrentDirectory		"currentDirectory"
#define	XtNcurrentFile			"currentFile"
#define	XtNsortMode			"sortMode"
#define	XtNpattern			"pattern"
X
#define	XtCPathname			"Pathname"
#define	XtCFilename			"Filename"
X
typedef struct _XfwfFileChooserReturnStruct
{
X	char *directory;
X	char *file;
} XfwfFileChooserReturnStruct;
X
/*---------------------------------------------------------------------------*
X
X                  E X T E R N A L    F U N C T I O N S
X
X *---------------------------------------------------------------------------*/
X
#if (!NeedFunctionPrototypes)
X
void	XfwfFileChooserChangeDirectory();
void	XfwfFileChooserRefresh();
char	*XfwfFileChooserCurrentDirectory();
char	*XfwfFileChooserCurrentFile();
X
#else
X
void	XfwfFileChooserChangeDirectory(XfwfFileChooserWidget fcw, char *dir);
void	XfwfFileChooserRefresh(XfwfFileChooserWidget fcw);
char	*XfwfFileChooserCurrentDirectory(XfwfFileChooserWidget fcw);
char	*XfwfFileChooserCurrentFile(XfwfFileChooserWidget fcw);
X
#endif /* !NeedFunctionPrototypes */
#endif /* !_FCHOOSER_H */
SHAR_EOF
chmod 0644 xarchie-2.0.6/FWF/FileChooser/FChooser.h ||
echo 'restore of xarchie-2.0.6/FWF/FileChooser/FChooser.h failed'
Wc_c="`wc -c < 'xarchie-2.0.6/FWF/FileChooser/FChooser.h'`"
test 3001 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/FWF/FileChooser/FChooser.h: original size 3001, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/FWF/FileChooser/FChooser.man ==============
if test -f 'xarchie-2.0.6/FWF/FileChooser/FChooser.man' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/FWF/FileChooser/FChooser.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/FWF/FileChooser/FChooser.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/FWF/FileChooser/FChooser.man' &&
'\" t
.TH "FileChooser" "3" "28 Jan 1993" "Version 1.0" "Free Widget Foundation"
.SH Name
FileChooser \- Another widget for choosing a file
.SH Synopsis
.nf
#include <Xfwf/FChooser.h>
X
widget = XtCreateManagedWidget(name, xfwfFileChooserWidgetClass, ...);
.fi
.SH Class Hierarchy
The following describes the classes from which XfwfFileChooser
inherits resources:
.ce
Core-->Composite-->XfwfFileChooser
.SH Widget Hierarchy
.PP
The XfwfFileChooser widget is a composite widget with the following
internal structure:
.RS 5
.nf
MenuButton dirMenuButton
SimpleMenu dirMenu
Viewport fileViewport
X    List fileList
.fi
.RE
You can use these names to specify resources for FileChooser
children, or use XtNameToWidget() to locate them programmatically.
.SH Description
XXfwfFileChooser provides a list of files in the current directory, and
a dynamically-updated menu of ancestor directories. A file can be
selected from the list, or a directory can be selected from either the
list (a sub-directory) or the menu (an ancestor directory). When a
directory is selected (from the menu or the list), the list is
re-filled with the contents of the new directory.  Callback procedures
are called whenever the selected file or directory changes.
.PP
This widget is meant to function within, say, a Form, which would
provide buttons and perhaps a Text item for entering new filenames.
In this sense, it is different from the XfwfFileSelector widget that
provides builtin additional functionality but at the cost of more
screen real estate and some inflexibility in terms of input policy.
The sample program distributed with the widget presents an example of
such usage.
.PP
The source code in the Dir directory of the FWF distribution contains
system-independent file listing functions that are required by 
FileChooser.
.SH Resources
In addition to the resources defined by superclasses, this widget
defines the following:
.TS
tab(/) ;
lB lB lB lB.
Name/Class/Type/Default
.T&
lB l l l.
XXtNwidth/Width/Dimension/250
XXtNheight/Height/Dimension/500
XXtNbackground/Background/Pixel/XtDefaultBackground
XXtNcallback/Callback/Callback/NULL
XXtNcurrentDirectory/Pathname/String/current directory
XXtNcurrentFile/Filename/String/NULL
XXtNsortMode/Int/Int/2
XXtNpattern/Filename/String/NULL
.TE
.PP
The XtNcurrentDirectory and XtNcurrentFile resources can be used to
specify the initial contents and selection of the XfwfFileChooser
widget. Changing them after creation results in the contents being
recomputed appropriately and the callbacks being invoked (see below).
.PP
The filter pattern is specified in the string XtNpattern.  The method
used to sort the file list is specified in XtNsortMode.  The sort mode
is encoded as an integer.  The integers are defined in the DirMgr.h
file which is part of the libDir directory management package included
in the FWF release.  Sample XtNsortMode values are depicted below:
.RS 5
.TS
tab(/) ;
lB lB lB.
XXtNsortMode Name/Value/Sort By
.T&
lB l l.
SORT_NONE/0/No sorting
SORT_NAME/1/File name
SORT_NAME_DIRS_FIRST/2/File name, directories first
SORT_SIZE_ASCENDING/3/Ascending file size
SORT_SIZE_DESCENDING/4/Descending file size
SORT_ACCESS_ASCENDING/5/Ascending access time
SORT_ACCESS_DESCENDING/6/Descending access time
.TE
.RE
.ne 4
.SH Callbacks
.PP
The XfwfFileChooser widget provides a single callback list,
XXtNcallback. This callback is called whenever the contents of the
XXfwfFileChooser change, either because the user selected a file or
directory (or selected the background, which unselects any selected
file) or because the XtNcurrentDirectry or XtNcurrentFile resources
were changed programmatically. The call_data parameter of the call
contains an instance of the following structure:
.sp
.RS 5
.nf
typedef struct _XfwfFileChooserReturnStruct
{
X        String directory;
X        String file;
} XfwfFileChooserReturnStruct;
.fi
.RE
.sp
The "file" member is NULL if no file is selected in the fileList.
.RE
.SH Public Functions
.nf
.ta 3i
void XfwfFileChooserChangeDirectory(fcw,dir)
XXfwfFileChooserWidget fcw;
char *dir;
.fi
.sp
.RS 5
This routine changes the current directory of the XfwfFileChooser
widget \fIfcw\fP to be \fIdir\fP, and invokes the callbacks.
.RE
.sp
.nf
void XfwfFileChooserRefresh(fcw)
XXfwfFileChooserWidget fcw;
.fi
.sp
.RS 5
This routine causes the XfwfFileChooser widget \fIfcw\fP to re-read
the current directory, refreshing the widget.  Changes to the file
system will not automatically propogate to the widget.  This routine
forces the refresh.
.RE
.sp
.nf
void XfwfFileChooserCurrentDirectory(fcw)
XXfwfFileChooserWidget fcw;
.fi
.sp
.RS 5
Returns the value of the XtNcurrentDirectory resource for the
XXfwfFileChooser widget \fIfcw\fP.
.RE
.sp
.nf
void XfwfFileChooserCurrentFile(fcw)
XXfwfFileChooserWidget fcw;
.fi
.sp
.RS 5
Returns the value of the XtNcurrentFile resource for the
XXfwfFileChooser widget \fIfcw\fP.
.RE
.ne 4
.SH Restrictions
.PP
The filter function is currently limited to shell-style pattern matching,
even though the underlying directory management functions support arbitrary
filter functions.
.PP
Layout parameters of the XfwfFileChooser widget's children cannot be
changed, but other resources can using the names described above under
"Widget Hierarchy".
.PP
The slider bars of the viewports do not "snap back" when a smaller
directory is loaded, and the sliders are down at the bottom.
.PP
The stupid List widget doesn't notify when the background is selected,
although it unhighlights the item. Blech. This means your callbacks
won't always be called when you think they should.
.SH Author
.PP
George Ferguson, ferguson@cs.rochester.edu.
.PP
Based on FileSelector by:
.RS 5
.nf
Brian Totty, \fItotty@cs.uiuc.edu\fR
Department of Computer Science,
University of Illinois at Urbana-Champaign
1304 W. Springfield Avenue
Urbana, IL 61801
.fi
.RE
SHAR_EOF
chmod 0644 xarchie-2.0.6/FWF/FileChooser/FChooser.man ||
echo 'restore of xarchie-2.0.6/FWF/FileChooser/FChooser.man failed'
Wc_c="`wc -c < 'xarchie-2.0.6/FWF/FileChooser/FChooser.man'`"
test 5827 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/FWF/FileChooser/FChooser.man: original size 5827, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/FWF/FileChooser/FChooserP.h ==============
if test -f 'xarchie-2.0.6/FWF/FileChooser/FChooserP.h' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/FWF/FileChooser/FChooserP.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/FWF/FileChooser/FChooserP.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/FWF/FileChooser/FChooserP.h' &&
/*
X * FChooserP.h : Private header file for the FileChooser widget
X *
X * George Ferguson, ferguson@cs.rochester.edu, 21 Jan 1993.
X *
X * This code is derived from the FileSelector widget by Brian Totty,
X * hence the following copyright applies:
X *
X * Copyright 1990,1991,1992 Brian Totty
X * 
X * Permission to use, copy, modify, distribute, and sell this software
X * and its documentation for any purpose is hereby granted without fee,
X * provided that the above copyright notice appears in all copies and that
X * both that copyright notice and this permission notice appear in
X * supporting documentation, and that the name of Brian Totty or
X * University of Illinois not be used in advertising or publicity
X * pertaining to distribution of the software without specific, written
X * prior permission.  Brian Totty and University of Illinois make no
X * representations about the suitability of this software for any
X * purpose.  It is provided "as is" without express or implied warranty.
X *
X * Brian Totty and University of Illinois disclaim all warranties with
X * regard to this software, including all implied warranties of
X * merchantability and fitness, in no event shall Brian Totty or
X * University of Illinois be liable for any special, indirect or
X * consequential damages or any damages whatsoever resulting from loss of
X * use, data or profits, whether in an action of contract, negligence or
X * other tortious action, arising out of or in connection with the use or
X * performance of this software.
X *
X * Author:
X * 	Brian Totty
X * 	Department of Computer Science
X * 	University Of Illinois at Urbana-Champaign
X *	1304 West Springfield Avenue
X * 	Urbana, IL 61801
X * 
X * 	totty@cs.uiuc.edu
X * 	
X */ 
X
#ifndef	_FCHOOSERP_H
#define	_FCHOOSERP_H
X
#include <DirMgr.h>
X
#include <X11/CoreP.h>
#include <X11/Core.h>
X
/*---------------------------------------------------------------------------*
X
X			    C O N S T A N T S
X
X *---------------------------------------------------------------------------*/
X
#define FC_DIR_MENU_NAME	"dirMenu"
#define FC_DIR_MENU_BUTTON_NAME	"dirMenuButton"
#define FC_FILE_VIEWPORT_NAME	"fileViewport"
#define FC_FILE_LIST_NAME	"fileList"
X
/*---------------------------------------------------------------------------*
X
X      S T R U C T U R E   &   W I D G E T    A C C E S S    M A C R O S
X
X *---------------------------------------------------------------------------*/
X
#define	FCCorePart(w)		(&((w)->core))
#define	FCCompositePart(w)	(&((w)->composite))
#define	FCFCPart(w)		(&((w)->fileChooser))
X
#define	FCDirMgr(w)		(FCFCPart(w)->dir_mgr)
#define	FCDirMenu(w)		(FCFCPart(w)->dir_menu)
#define	FCDirMenuButton(w)	(FCFCPart(w)->dir_menu_button)
#define	FCFileViewport(w)	(FCFCPart(w)->file_viewport)
#define	FCFileList(w)		(FCFCPart(w)->file_list)
#define	FCCurrentDirectory(w)	(FCFCPart(w)->current_dir)
#define	FCCurrentFile(w)	(FCFCPart(w)->current_file)
#define	FCDirNames(w)		(FCFCPart(w)->dir_names)
#define	FCNumDirNames(w)	(FCFCPart(w)->num_dir_names)
#define	FCFileNames(w)		(FCFCPart(w)->file_names)
#define	FCNumFileNames(w)	(FCFCPart(w)->num_file_names)
#define	FCBusyCursor(w)		(FCFCPart(w)->busy_cursor)
#define	FCSortMode(w)		(FCFCPart(w)->sort_mode)
#define	FCPattern(w)		(FCFCPart(w)->pattern)
X
#define CoreWidth(w)            ((w)->core.width)
#define CoreHeight(w)           ((w)->core.height)
#define CoreBorderWidth(w)      ((w)->core.border_width)
X
/*---------------------------------------------------------------------------*
X
X           W I D G E T    S T R U C T U R E    D E F I N I T I O N
X
X *---------------------------------------------------------------------------*/
X
typedef struct
{
X	DIRECTORY_MGR	*dir_mgr;
X	Widget		dir_menu;
X	Widget		dir_menu_button;
X	Widget		file_viewport;
X	Widget		file_list;
X	char		*current_dir;
X	char		*current_file;
X	char		**dir_names;
X	int		num_dir_names;
X	char		**file_names;
X	int		num_file_names;
X	XtCallbackList	callbacks;
X	Cursor		busy_cursor;
X	int		sort_mode;
X	char		*pattern;
} XfwfFileChooserPart;
X
typedef struct _XfwfFileChooserClassPart
{
X	int    empty;
} XfwfFileChooserClassPart;
X
typedef struct _XfwfFileChooserClassRec
{
X	CoreClassPart			core_class;
X	CompositeClassPart		composite_class;
X	XfwfFileChooserClassPart	fileChooser_class;
} XfwfFileChooserClassRec;
X
X	/* This Is What A Widget Instance Points To */
X
typedef struct _XfwfFileChooserRec
{
X	CorePart		core;
X	CompositePart		composite;
X	XfwfFileChooserPart	fileChooser;
} XfwfFileChooserRec;
X
extern XfwfFileChooserClassRec xfwfFileChooserClassRec;
X
#endif /* !_FCHOOSERP_H */
SHAR_EOF
chmod 0644 xarchie-2.0.6/FWF/FileChooser/FChooserP.h ||
echo 'restore of xarchie-2.0.6/FWF/FileChooser/FChooserP.h failed'
Wc_c="`wc -c < 'xarchie-2.0.6/FWF/FileChooser/FChooserP.h'`"
test 4545 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/FWF/FileChooser/FChooserP.h: original size 4545, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/FWF/FileChooser/FChooserT.c ==============
if test -f 'xarchie-2.0.6/FWF/FileChooser/FChooserT.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/FWF/FileChooser/FChooserT.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/FWF/FileChooser/FChooserT.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/FWF/FileChooser/FChooserT.c' &&
/*
X * FChooserT.c : Test program for the FileChooser widget
X *
X * George Ferguson, ferguson@cs.rochester.edu, 21 Jan 1993.
X *
X * This program illustrates use of a FileChooser together with "Ok"
X * and "Cancel" buttons, and with a Text widget for new filenames.
X * Messages are printed to stdout whenever something is selected in
X * in the FileChooser, or prior to exiting after selecting one of the
X * buttons. Typing <Return> in the Text window is equivalent to
X * clicking on "Ok". Note that it is the responsability of the program
X * to keep the FileChooser and Text widget in sync -- the FileChooser
X * knows nothing about buttons or Text widgets, deliberately.
X * I added a menu for changing the sort mode, and another Text item
X * for changing the filter pattern. I guess that makes this a bit overly
X * complicated, but I wanted to show everything.
X */
#include <stdio.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Shell.h>
#include <X11/Xaw/Form.h>
#include <X11/Xaw/Label.h>
#include <X11/Xaw/Command.h>
#include <X11/Xaw/MenuButton.h>
#include <X11/Xaw/SimpleMenu.h>
#include <X11/Xaw/SmeBSB.h>
#include <X11/Xaw/AsciiText.h>
#include <Xfwf/FChooser.h>
X
static void selectionChangedCallback();
static void okCallback(),cancelCallback();
static void sortModeCallback();
static void okAction();
static void filterAction();
X
static XtAppContext appContext;
static Widget toplevel;
static Widget chooser;
static Widget filterText,fileText;
X
static XtActionsRec actionTable[] = {
X    { "ok",	okAction },
X    { "filter",	filterAction },
};
X
static char *sortMenuItemNames[] = {
X    "None", "Name", "Name, dirs first",
X    "Size, ascending", "Size, descending",
X    "Access, ascending", "Access, descending",
};
X
main(argc,argv)
int argc;
char **argv;
{
X    Widget form,button,menu,menuItem,label;
X    Arg args[4];
X    int i;
X
X    toplevel = XtAppInitialize(&appContext,"FileChooserTest",
X			       NULL, 0,&argc,argv,NULL,NULL,0);
X    XtAppAddActions(appContext,actionTable,XtNumber(actionTable));
X
X    form = XtCreateManagedWidget("form",formWidgetClass,toplevel,NULL,0);
X
X    XtSetArg(args[0],XtNwidth,300);
X    chooser = XtCreateManagedWidget("chooser",xfwfFileChooserWidgetClass,
X				    form,args,1);
X    XtAddCallback(chooser,XtNcallback,selectionChangedCallback,NULL);
X
X    XtSetArg(args[0],XtNlabel,"Ok");
X    XtSetArg(args[1],XtNfromHoriz,chooser);
X    XtSetArg(args[2],XtNvertDistance,40);
X    XtSetArg(args[3],XtNborderWidth,3);
X    button = XtCreateManagedWidget("ok",commandWidgetClass,form,args,4);
X    XtAddCallback(button,XtNcallback,okCallback,NULL);
X
X    XtSetArg(args[0],XtNlabel,"Cancel");
X    XtSetArg(args[1],XtNfromHoriz,chooser);
X    XtSetArg(args[2],XtNfromVert,button);
X    button = XtCreateManagedWidget("cancel",commandWidgetClass,form,args,3);
X    XtAddCallback(button,XtNcallback,cancelCallback,NULL);
X
X    menu = XtCreatePopupShell("sortMenu",simpleMenuWidgetClass,form,NULL,0);
X    for (i = 0; i < XtNumber(sortMenuItemNames); i++) {
X	XtSetArg(args[0],XtNlabel,sortMenuItemNames[i]);
X	menuItem = XtCreateManagedWidget("sortMenuItem",smeBSBObjectClass,
X					 menu,args,1);
X        XtAddCallback(menuItem,XtNcallback,sortModeCallback,(XtPointer)i);
X    }
X
X    XtSetArg(args[0],XtNlabel,"Sort Mode");
X    XtSetArg(args[1],XtNfromHoriz,chooser);
X    XtSetArg(args[2],XtNfromVert,button);
X    XtSetArg(args[3],XtNmenuName,"sortMenu");
X    button = XtCreateManagedWidget("sort",menuButtonWidgetClass,form,args,4);
X
X    XtSetArg(args[0],XtNlabel,"Filter:");
X    XtSetArg(args[1],XtNborderWidth,0);
X    XtSetArg(args[2],XtNfromVert,chooser);
X    label = XtCreateManagedWidget("filterLabel",labelWidgetClass,form,args,3);
X
X    XtSetArg(args[0],XtNfromVert,chooser);
X    XtSetArg(args[1],XtNfromHoriz,label);
X    XtSetArg(args[2],XtNwidth,300);
X    XtSetArg(args[3],XtNeditType,XawtextEdit);
X    filterText = XtCreateManagedWidget("filterText",asciiTextWidgetClass,
X				       form,args,4); 
X    XtOverrideTranslations(filterText,
X	     XtParseTranslationTable("<Key>Return: filter()"));
X
X    XtSetArg(args[0],XtNlabel,"File:");
X    XtSetArg(args[1],XtNborderWidth,0);
X    XtSetArg(args[2],XtNfromVert,label);
X    label = XtCreateManagedWidget("fileLabel",labelWidgetClass,form,args,3);
X
X    XtSetArg(args[0],XtNfromVert,filterText);
X    XtSetArg(args[1],XtNfromHoriz,label);
X    XtSetArg(args[2],XtNwidth,300);
X    XtSetArg(args[3],XtNeditType,XawtextEdit);
X    fileText = XtCreateManagedWidget("fileText",asciiTextWidgetClass,
X				     form,args,3);
X    XtOverrideTranslations(fileText,
X	     XtParseTranslationTable("<Key>Return: ok()"));
X
X    XtRealizeWidget(toplevel);
X    XtAppMainLoop(appContext);
X    /*NOTREACHED*/
}
X
/*
X * CALLBACKS:
X */
X
/*ARGSUSED*/
static void
selectionChangedCallback(w,client_data,call_data)
Widget w;
XXtPointer client_data;	/* not used */
XXtPointer call_data;	/* return struct */
{
X    XfwfFileChooserReturnStruct *ret =
X	(XfwfFileChooserReturnStruct *)call_data;
X    Arg args[1];
X
X    if (ret->directory == NULL || ret->file == NULL) {
X	printf("No selection\n");
X	XtSetArg(args[0],XtNstring,"");
X    } else {
X	printf("Directory: \"%s\"\n",ret->directory);
X	printf("File: \"%s\"\n",ret->file);
X	XtSetArg(args[0],XtNstring,ret->file);
X    }
X    XtSetValues(fileText,args,1);
}
X
/*ARGSUSED*/
static void
okCallback(w,client_data,call_data)
Widget w;
XXtPointer client_data;	/* not used */
XXtPointer call_data;	/* not used */
{
X    Arg args[1];
X    char *dir,*file;
X
X    printf("Ok!\n");
X    /* Get directory from chooser (or use XfwfFileChooserCurrentDirectory()) */
X    XtSetArg(args[0],XtNcurrentDirectory,&dir);
X    XtGetValues(chooser,args,1);
X    /* But get file from text item (might differ from XtNcurrentFile) */
X    XtSetArg(args[0],XtNstring,&file);
X    XtGetValues(fileText,args,1);
X    /* Sanity check */
X    if (dir == NULL || !*dir || file == NULL || !*file) {
X	printf("You need to select something before saying Ok!\n");
X	return;
X    }
X    /* Everything ok */
X    printf("Directory: \"%s\"\n",dir);
X    printf("File: \"%s\"\n",file);
X    /* Say goodbye */
X    XtDestroyApplicationContext(appContext);
X    exit(0);
}
X
/*ARGSUSED*/
static void
cancelCallback(w,client_data,call_data)
Widget w;
XXtPointer client_data;	/* not used */
XXtPointer call_data;	/* not used */
{
X    printf("Cancel!\n");
X    XtDestroyApplicationContext(appContext);
X    exit(0);
}
X
/*ARGSUSED*/
static void
sortModeCallback(w,client_data,call_data)
Widget w;
XXtPointer client_data;	/* not used */
XXtPointer call_data;	/* item index == sort mode */
{
X    int sortMode = (int)client_data;
X    Arg args[1];
X
X    printf("Setting sort mode to %s\n",sortMenuItemNames[sortMode]);
X    XtSetArg(args[0],XtNsortMode,sortMode);
X    XtSetValues(chooser,args,1);
}
X
/*
X * ACTIONS:
X */
X
/*ARGSUSED*/
static void
okAction(w,event,params,num_params)
Widget w;
XXEvent *event;
String *params;
Cardinal *num_params;
{
X    okCallback(NULL,NULL,NULL);
}
X
/*ARGSUSED*/
static void
filterAction(w,event,params,num_params)
Widget w;
XXEvent *event;
String *params;
Cardinal *num_params;
{
X    Arg args[1];
X    char *s;
X
X    XtSetArg(args[0],XtNstring,&s);
X    XtGetValues(filterText,args,1);
X    printf("Setting filter pattern to \"%s\"\n",s);
X    XtSetArg(args[0],XtNpattern,s);
X    XtSetValues(chooser,args,1);
}
SHAR_EOF
chmod 0644 xarchie-2.0.6/FWF/FileChooser/FChooserT.c ||
echo 'restore of xarchie-2.0.6/FWF/FileChooser/FChooserT.c failed'
Wc_c="`wc -c < 'xarchie-2.0.6/FWF/FileChooser/FChooserT.c'`"
test 7260 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/FWF/FileChooser/FChooserT.c: original size 7260, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/FWF/FileChooser/FChooserT.man ==============
if test -f 'xarchie-2.0.6/FWF/FileChooser/FChooserT.man' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/FWF/FileChooser/FChooserT.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/FWF/FileChooser/FChooserT.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/FWF/FileChooser/FChooserT.man' &&
.TH "FChooserT" "1" "28 Jan 1993" "Version 1.0" "Free Widget Foundation"
.SH NAME
FChooserT \- Test Program For The FileChooser Widget
.SH DESCRIPTION
.PP
.I FChooserT
is a simple program that creates and tests a FileChooser widget in a
Form with some other buttons to indicate typical usage.  The source
may be useful is seeing how the FileChooser widget can be used.
.PP
The test program allows you to traverse the directory hierarchy by
selecting files or directories from the FileChooser by clicking on
them with the mouse. A message is printed each time the selection
changes. The current directory is shown in the FileChooser on the
MenuButton above the list of files. Clicking on it pops up a menu from
which an ancestor directory can be selected if you want to go up the
tree. This functionality is all part of the FileChooser itself.
.PP
The test program provides some other things to allow you to experiemnt
with the functionality and to provide usage examples. The Text item
below the FileChooser labelled "File" is updated whenever you select a
file, and it can be edited, for example to enter new filenames. The
"Ok" button exits the program, printing the current directory (from
the FileChooser) and current file (from the Text item, in case you
edited it). Hitting Return in the Text item is like clicking on "Ok".
The "Cancel" button exits without printing anything. The "Sort Mode"
button allows you change the sorting of files in the FileChooser by
selecting a different sort mode from the menu. You can change the
FileChooser's filter pattern (a shell-like "globbing" pattern) by
typing in the Text item labelled "Filter" and hitting Return.
.SH AUTHOR
.PP
George Ferguson, ferguson@cs.rochester.edu.
SHAR_EOF
chmod 0644 xarchie-2.0.6/FWF/FileChooser/FChooserT.man ||
echo 'restore of xarchie-2.0.6/FWF/FileChooser/FChooserT.man failed'
Wc_c="`wc -c < 'xarchie-2.0.6/FWF/FileChooser/FChooserT.man'`"
test 1720 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/FWF/FileChooser/FChooserT.man: original size 1720, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/FWF/FileChooser/Imakefile ==============
if test -f 'xarchie-2.0.6/FWF/FileChooser/Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/FWF/FileChooser/Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/FWF/FileChooser/Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/FWF/FileChooser/Imakefile' &&
#
# Imakefile for FileChooser
#
# Note that this Imakefile is just sufficient to build the FileChooser
# for use with xarchie. The original FWF distribution contains a more
# elaborate Imakefile for a variety of purposes. See the file ../README.
#
# George Ferguson, ferguson@cs.rochester.edu, 28 Jan 1993.
#
X
SRCS = FChooser.c
OBJS = FChooser.o
X
INCLUDES = -I. -I../Dir
X
NormalLibraryTarget(FChooser,$(OBJS))
X
DependTarget()
SHAR_EOF
chmod 0644 xarchie-2.0.6/FWF/FileChooser/Imakefile ||
echo 'restore of xarchie-2.0.6/FWF/FileChooser/Imakefile failed'
Wc_c="`wc -c < 'xarchie-2.0.6/FWF/FileChooser/Imakefile'`"
test 426 -eq "$Wc_c" ||
	echo 'xarchie-2.0.6/FWF/FileChooser/Imakefile: original size 426, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xarchie-2.0.6/FWF/FileChooser/Makefile ==============
if test -f 'xarchie-2.0.6/FWF/FileChooser/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping xarchie-2.0.6/FWF/FileChooser/Makefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xarchie-2.0.6/FWF/FileChooser/Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xarchie-2.0.6/FWF/FileChooser/Makefile' &&
# Makefile generated by imake - do not edit!
# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
#
# The cpp used on this machine replaces all newlines and multiple tabs and
# spaces in a macro expansion with a single space.  Imake tries to compensate
# for this, but is not always successful.
#
X
# -------------------------------------------------------------------------
# Makefile generated from "Imake.tmpl" and </tmp/IIf.a12634>
# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
#
# Platform-specific parameters may be set in the appropriate <vendor>.cf
# configuration files.  Site-specific parameters should be set in the file
# site.def.  Full rebuilds are recommended if any parameters are changed.
#
# If your C preprocessor does not define any unique symbols, you will need
# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
# "make World" the first time).
#
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that need to come before
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
# -------------------------------------------------------------------------
# platform-specific configuration parameters - edit sun.cf to change
X
# platform:  $XConsortium: sun.cf,v 1.72.1.1 92/03/18 13:13:37 rws Exp $
X
# operating system:  SunOS 4.1.1
X
# $XConsortium: sunLib.rules,v 1.7 91/12/20 11:19:47 rws Exp $
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that go after
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = ../../.
X      CURRENT_DIR = ./FWF/FileChooser
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
SHAR_EOF
true || echo 'restore of xarchie-2.0.6/FWF/FileChooser/Makefile failed'
fi
echo 'End of xarchie-2.0.6 part 21'
echo 'File xarchie-2.0.6/FWF/FileChooser/Makefile is continued in part 22'
echo 22 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM       | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@imd.sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
