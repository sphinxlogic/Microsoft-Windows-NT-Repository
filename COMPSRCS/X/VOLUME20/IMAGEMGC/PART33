Newsgroups: comp.sources.x
From: cristy@eplrx7.es.duPont.com (Cristy)
Subject: v20i089:  imagemagic - X11 image processing and display, Part33/38
Message-ID: <1993Jul14.232220.23319@sparky.sterling.com>
X-Md4-Signature: ec31088fd201c700d23f4f459271de9b
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Wed, 14 Jul 1993 23:22:20 GMT
Approved: chris@sterling.com

Submitted-by: cristy@eplrx7.es.duPont.com (Cristy)
Posting-number: Volume 20, Issue 89
Archive-name: imagemagic/part33
Environment: X11
Supersedes: imagemagic: Volume 13, Issue 17-37

#!/bin/sh
# this is magick.33 (part 33 of ImageMagick)
# do not concatenate these parts, unpack them in order with /bin/sh
# file ImageMagick/utility.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 33; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping ImageMagick/utility.c'
else
echo 'x - continuing file ImageMagick/utility.c'
sed 's/^X//' << 'SHAR_EOF' >> 'ImageMagick/utility.c' &&
X  buffer[1]=(unsigned char) ((value) >> 8);
X  (void) fwrite((char *) buffer,1,2,file);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  M S B F i r s t O r d e r L o n g                                          %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function MSBFirstOrderLong converts a least-significant byte first buffer
%  of longegers to most-significant byte first.
%
%  The format of the MSBFirstOrderLong routine is:
%
%       MSBFirstOrderLong(p,length);
%
%  A description of each parameter follows.
%
%   o  p:  Specifies a pointer to a buffer of integers.
%
%   o  length:  Specifies the length of the buffer.
%
%
*/
void MSBFirstOrderLong(p,length)
register char
X  *p;
X
register unsigned int
X  length;
{
X  register char
X    c,
X    *q,
X    *sp;
X
X  q=p+length;
X  while (p < q)
X  {
X    sp=p+3;
X    c=(*sp);
X    *sp=(*p);
X    *p++=c;
X    sp=p+1;
X    c=(*sp);
X    *sp=(*p);
X    *p++=c;
X    p+=2;
X  }
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  M S B F i r s t O r d e r S h o r t                                        %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function MSBFirstOrderShort converts a least-significant byte first buffer
%  of shortegers to most-significant byte first.
%
%  The format of the MSBFirstOrderShort routine is:
%
%       MSBFirstOrderLongShort(p,length);
%
%  A description of each parameter follows.
%
%   o  p:  Specifies a pointer to a buffer of integers.
%
%   o  length:  Specifies the length of the buffer.
%
%
*/
void MSBFirstOrderShort(p,length)
register char
X  *p;
X
register unsigned int
X  length;
{
X  register char
X    c,
X    *q;
X
X  q=p+length;
X  while (p < q)
X  {
X    c=(*p);
X    *p=(*(p+1));
X    p++;
X    *p++=c;
X  }
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  M S B F i r s t R e a d S h o r t                                          %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function MSBFirstReadShort reads a short value as a 16 bit quantity in
%  most-significant byte first order.
%
%  The format of the MSBFirstReadShort routine is:
%
%       value=MSBFirstReadShort(file)
%
%  A description of each parameter follows.
%
%    o value:  Function MSBFirstReadShort returns an unsigned short read from
%      the file.
%
%   o  file:  Specifies the file to read the data from.
%
%
*/
unsigned short MSBFirstReadShort(file)
FILE
X  *file;
{
X  unsigned char
X    buffer[2];
X
X  unsigned int
X    status;
X
X  unsigned short
X    value;
X
X  status=ReadData((char *) buffer,1,2,file);
X  if (status == False)
X    return((unsigned long) ~0);
X  value=(unsigned int) (buffer[0] << 8);
X  value|=(unsigned int) (buffer[1]);
X  return(value);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  M S B F i r s t R e a d L o n g                                            %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function MSBFirstReadLong reads a long value as a 32 bit quantity in
%  most-significant byte first order.
%
%  The format of the MSBFirstReadLong routine is:
%
%       value=MSBFirstReadLong(file)
%
%  A description of each parameter follows.
%
%    o value:  Function MSBFirstReadLong returns an unsigned long read from
%      the file.
%
%   o  file:  Specifies the file to read the data from.
%
%
*/
unsigned long MSBFirstReadLong(file)
FILE
X  *file;
{
X  unsigned char
X    buffer[4];
X
X  unsigned int
X    status;
X
X  unsigned long
X    value;
X
X  status=ReadData((char *) buffer,1,4,file);
X  if (status == False)
X    return((unsigned long) ~0);
X  value=(unsigned int) (buffer[0] << 24);
X  value|=(unsigned int) (buffer[1] << 16);
X  value|=(unsigned int) (buffer[2] << 8);
X  value|=(unsigned int) (buffer[3]);
X  return(value);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  M S B F i r s t W r i t e L o n g                                          %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function MSBFirstWriteLong writes a long value as a 32 bit quantity in
%  most-significant byte first order.
%
%  The format of the MSBFirstWriteLong routine is:
%
%       MSBFirstWriteLong(value,file)
%
%  A description of each parameter follows.
%
%   o  value:  Specifies the value to write.
%
%   o  file:  Specifies the file to write the data to.
%
%
*/
void MSBFirstWriteLong(value,file)
unsigned long
X  value;
X
FILE
X  *file;
{
X  unsigned char
X    buffer[4];
X
X  buffer[0]=(unsigned char) ((value) >> 24);
X  buffer[1]=(unsigned char) ((value) >> 16);
X  buffer[2]=(unsigned char) ((value) >> 8);
X  buffer[3]=(unsigned char) (value);
X  (void) fwrite((char *) buffer,1,4,file);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  M S B F i r s t W r i t e S h o r t                                        %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function MSBFirstWriteShort writes a long value as a 16 bit quantity in
%  most-significant byte first order.
%
%  The format of the MSBFirstWriteShort routine is:
%
%       MSBFirstWriteShort(value,file)
%
%  A description of each parameter follows.
%
%   o  value:  Specifies the value to write.
%
%   o  file:  Specifies the file to write the data to.
%
%
*/
void MSBFirstWriteShort(value,file)
unsigned int
X  value;
X
FILE
X  *file;
{
X  unsigned char
X    buffer[2];
X
X  buffer[0]=(unsigned char) ((value) >> 8);
X  buffer[1]=(unsigned char) (value);
X  (void) fwrite((char *) buffer,1,2,file);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  R e a d D a t a                                                            %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function ReadData reads data from the image file and returns it.  If it
%  cannot read the requested number of items, False is returned indicating
%  an error.
%
%  The format of the ReadData routine is:
%
%      status=ReadData(data,size,number_items,file)
%
%  A description of each parameter follows:
%
%    o status:  Function ReadData returns True if all the data requested
%      is obtained without error, otherwise False.
%
%    o data:  Specifies an area to place the information reuested from
%      the file.
%
%    o size:  Specifies an integer representing the length of an
%      individual item to be read from the file.
%
%    o number_items:  Specifies an integer representing the number of items
%      to read from the file.
%
%    o file:  Specifies a file to read the data.
%
%
*/
unsigned int ReadData(data,size,number_items,file)
char
X  *data;
X
int
X  size,
X  number_items;
X
FILE
X  *file;
{
X  size*=number_items;
X  while (size > 0)
X  {
X    number_items=fread(data,1,size,file);
X    if (number_items <= 0)
X      return(False);
X    size-=number_items;
X    data+=number_items;
X  }
X  return(True);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  R e a d D a t a B l o c k                                                  %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function ReadDataBlock reads data from the image file and returns it.  The
%  amount of data is determined by first reading a count byte.  If
%  ReadDataBlock cannot read the requested number of items, `-1' is returned
%  indicating an error.
%
%  The format of the ReadData routine is:
%
%      status=ReadData(data,file)
%
%  A description of each parameter follows:
%
%    o status:  Function ReadData returns the number of characters read
%      unless the is an error, otherwise `-1'.
%
%    o data:  Specifies an area to place the information reuested from
%      the file.
%
%    o file:  Specifies a file to read the data.
%
%
*/
int ReadDataBlock(data,file)
char
X  *data;
X
FILE
X  *file;
{
X  unsigned char
X    count;
X
X  unsigned int
X    status;
X
X  status=ReadData((char *) &count,1,1,file);
X  if (status == False)
X    return(-1);
X  if (count == 0)
X    return(0);
X  status=ReadData(data,1,(int) count,file);
X  if (status == False)
X    return(-1);
X  return(count);
}
SHAR_EOF
echo 'File ImageMagick/utility.c is complete' &&
chmod 0644 ImageMagick/utility.c ||
echo 'restore of ImageMagick/utility.c failed'
Wc_c="`wc -c < 'ImageMagick/utility.c'`"
test 21343 -eq "$Wc_c" ||
	echo 'ImageMagick/utility.c: original size 21343, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/quantize.man ==============
if test -f 'ImageMagick/quantize.man' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/quantize.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/quantize.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/quantize.man' &&
.ad l
.nh
.TH quantize 9 "10 October 1992" "ImageMagick"
.SH NAME
Quantize - ImageMagick's color reduction algorithm.
.SH SYNOPSIS
.B #include <image.h>
.SH DESCRIPTION
This document describes how \fBImageMagick\fP performs color reduction on an
image.  To fully understand this document, you should have a knowledge
of basic imaging techniques and the tree data structure and terminology.
.PP
For purposes of color allocation, an image is a set of \fIn\fP pixels,
where each pixel is a point in RGB space.  RGB space is a 3-dimensional
vector space, and each pixel, \fIp\d\s-3i\s0\u\fP,  is defined by an
ordered triple of red, green, and blue coordinates, (\fIr\d\s-3i\s0\u,
g\d\s-3i\s0\u, b\d\s-3i\s0\u\fP).
.PP
Each primary color component (red, green, or blue) represents an
intensity which varies linearly from 0 to a maximum value,
\fIc\d\s-3max\s0\u\fP, which corresponds to full saturation of that
color.  Color allocation is defined over a domain consisting of the
cube in RGB space with opposite vertices at (0,0,0) and
(\fIc\d\s-3max\s0\u,c\d\s-3max\s0\u,c\d\s-3max\s0\u\fP).  \fBImageMagick\fP
requires \fIc\d\s-3max\s0\u = 255\fP.
.PP
The algorithm maps this domain onto a tree in which each node
represents a cube within that domain.  In the following discussion,
these cubes are defined by the coordinate of two opposite vertices: The
vertex nearest the origin in RGB space and the vertex farthest from the
origin.
.PP
The tree's root node represents the the entire domain, (0,0,0) through
(\fIc\d\s-3max\s0\u,c\d\s-3max\s0\u,c\d\s-3max\s0\u\fP).  Each lower level in
the tree is generated by subdividing one node's cube into eight smaller
cubes of equal size.  This corresponds to bisecting the parent cube
with planes passing through the midpoints of each edge.
.PP
The basic algorithm operates in three phases:  \fBClassification,
Reduction\fP, and \fBAssignment\fP.  \fBClassification\fP builds a
color description tree for the image.  \fBReduction\fP collapses the
tree until the number it represents, at most, is the number of colors
desired in the output image.  \fBAssignment\fP defines the output
image's color map and sets each pixel's color by reclassification in
the reduced tree.
.PP
\fBClassification\fP begins by initializing a color description tree of
sufficient depth to represent each possible input color in a leaf.
However, it is impractical to generate a fully-formed color description
tree in the classification phase for realistic values of
\fIc\d\s-3max\s0\u\fP.  If color components in the input image are
quantized to \fIk\fP-bit precision, so that \fIc\d\s-3max\s0\u =
2\u\s-3k\s0\d-1\fP, the tree would need \fIk\fP levels below the root
node to allow representing each possible input color in a leaf.  This
becomes prohibitive because the tree's total number of nodes is
.PP
X        \fI\s+6\(*S\u\s-9 k\d\di=1\s0 8k\fP\s0\u
.PP
A complete tree would require 19,173,961 nodes for \fIk = 8,
c\d\s-3max\s0\u = 255\fP.  Therefore, to avoid building a fully
populated tree, \fBImageMagick\fP: (1) Initializes data structures for
nodes only as they are needed; (2) Chooses a maximum depth for the tree
as a function of the desired number of colors in the output image
(currently \fIlog\d\s-34\s0\u(colormap size)\+2\fP).  A tree of this
depth generally allows the best representation of the source image with
the fastest computational speed and the least amount of memory.
However, the default depth is inappropriate for some images.
Therefore, the caller can request a specific tree depth.
.PP
For each pixel in the input image, classification scans downward from
the root of the color description tree.  At each level of the tree, it
identifies the single node which represents a cube in RGB space
containing the pixel's color.  It updates the following data for each
such node:
.TP 5
.B n\d\s-31\s0\u:
Number of pixels whose color is contained in the RGB cube which this
node represents;
.TP 5
.B n\d\s-32\s0\u:
Number of pixels whose color is not represented in a node at lower
depth in the tree;  initially,  \fIn\d\s-32\s0\u = 0\fP for all nodes
except leaves of the tree.
.TP 5
.B S\d\s-3r\s0\u, S\d\s-3g\s0\u, S\d\s-3b\s0\u:
Sums of the red, green, and blue component values for all pixels not
classified at a lower depth.  The combination of these sums and
\fIn\d\s-32\s0\u\fP will ultimately characterize the mean color of a
set of pixels represented by this node.
.PP
\fBReduction\fP repeatedly prunes the tree until the number of nodes with
\fIn\d\s-32\s0\u  > 0\fP is less than or equal to the maximum number of colors
allowed in the output image.  On any given iteration over the tree, it
selects those nodes whose \fIn\d\s-31\s0\u\fP count is minimal for pruning and
merges their color statistics upward.  It uses a pruning threshold,
\fIn\d\s-3p\s0\u\fP, to govern node selection as follows:
.PP
X  n\d\s-3p\s0\u = 0
X  while number of nodes with (n\d\s-32\s0\u > 0) > required maximum number of colors
X      prune all nodes such that n\d\s-31\s0\u <= n\d\s-3p\s0\u
X      Set n\d\s-3p\s0\u  to minimum n\d\s-31\s0\u  in remaining nodes
.PP
When a node to be pruned has offspring, the pruning procedure invokes
itself recursively in order to prune the tree from the leaves upward.
The values of \fIn\d\s-32\s0\u  S\d\s-3r\s0\u, S\d\s-3g\s0\u,\fP  and
\fIS\d\s-3b\s0\u\fP in a node being pruned are always added to the
corresponding data in that node's parent.  This retains the pruned
node's color characteristics for later averaging.
.PP
For each node,  \fIn\d\s-32\s0\u\fP pixels exist for which that node
represents the smallest volume in RGB space containing those pixel's
colors.  When \fIn\d\s-32\s0\u  > 0\fP the node will uniquely define a
color in the output image.  At the beginning of reduction,
\fIn\d\s-32\s0\u = 0\fP  for all nodes except the leaves of the tree
which represent colors present in the input image.
.PP
The other pixel count, \fIn\d\s-31\s0\u\fP,  indicates the total
number of colors within the cubic volume which the node represents.
This includes \fIn\d\s-31\s0\u - n\d\s-32\s0\u\fP pixels whose colors
should be defined by nodes at a lower level in the tree.
.PP
\fBAssignment\fP generates the output image from the pruned tree.  The
output image consists of two parts:  (1)  A color map, which is an
array of color descriptions (RGB triples) for each color present in the
output image; (2)  A pixel array, which represents each pixel as an
index into the color map array.
.PP
First, the assignment phase makes one pass over the pruned color
description tree to establish the image's color map.  For each node
with \fIn\d\s-32\s0\u > 0\fP, it divides \fIS\d\s-3r\s0\u,
S\d\s-3g\s0\u\fP, and \fPS\d\s-3b\s0\u\fP by \fIn\d\s-32\s0\u\fP.  This
produces the mean color of all pixels that classify no lower than this
node.  Each of these colors becomes an entry in the color map.
.PP
Finally, the assignment phase reclassifies each pixel in the pruned
tree to identify the deepest node containing the pixel's color.  The
pixel's value in the pixel array becomes the index of this node's mean
color in the color map.
.PP
Empirical evidence suggests that distances in color spaces such as
YUV, or YIQ correspond to perceptual color differences more closely
than do distances in RGB space.  These color spaces may give better
results when color reducing an image.  Here the algorithm is as described
except each pixel is a point in the alternate color space.  For convenience,
the color components are normalized to the range 0 to a maximum value,
\fIc\d\s-3max\s0\u\fP.  The color reduction can then proceed as described.
.SH "MEASURING COLOR REDUCTION ERROR"
.PP
Depending on the image, the color reduction error may be obvious or
invisible.  Images with high spatial frequencies (such as hair or
grass) will show error much less than pictures with large smoothly
shaded areas (such as faces).  This is because the high-frequency
contour edges introduced by the color reduction process are masked by
the high frequencies in the image.
.PP
To measure the difference between the original and color reduced images
(the total color reduction error), \fBImageMagick\fP sums over all pixels
in an image the distance squared in RGB space between each original
pixel value and its color reduced value. \fBImageMagick\fP prints several error
measurements including the mean error per pixel, the normalized mean error,
and the normalized maximum error.
.PP
The normalized error measurement can be used to compare images.  In
general, the closer the mean error is to zero the more the quantized
image resembles the source image.  Ideally, the error should be
perceptually-based, since the human eye is the final judge of
quantization quality.
.PP
These errors are measured and printed when \fB-verbose\fP and \fB-colors\fI
are specified on the command line:
.TP 5
.B mean error per pixel:
is the mean error for any single pixel in the image.
.TP 5
.B normalized mean square error:
is the normalized mean square quantization error for any single pixel in the
image.
X
This distance measure is normalized to a range between 0 and 1.  It is
independent of the range of red, green, and blue values in the image.
.TP 5
.B normalized maximum square error:
is the largest normalized square quantization error for any single
pixel in the image.
X
This distance measure is normalized to a range between 0 and 1.  It is
independent of the range of red, green, and blue values in the image.
.SH SEE ALSO
.B
display(1), animate(1), mogrify(1), import(1), miff(5)
.SH COPYRIGHT
Copyright 1993 E. I. du Pont de Nemours & Company
.PP
Permission to use, copy, modify, distribute, and sell this software and
its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of E. I. du Pont de Nemours
& Company not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior
permission.  E. I. du Pont de Nemours & Company makes no representations
about the suitability of this software for any purpose.  It is provided
"as is" without express or implied warranty.
.PP
E. I. du Pont de Nemours & Company disclaims all warranties with regard
to this software, including all implied warranties of merchantability
and fitness, in no event shall E. I. du Pont de Nemours & Company be
liable for any special, indirect or consequential damages or any
damages whatsoever resulting from loss of use, data or profits, whether
in an action of contract, negligence or other tortious action, arising
out of or in connection with the use or performance of this software.
.SH ACKNOWLEDGEMENTS
Paul Raveling, USC Information Sciences Institute, for the original
idea of using space subdivision for the color reduction algorithm.
With Paul's permission, this document is an adaptation from a document he
wrote.
.SH AUTHORS
John Cristy, E.I. du Pont de Nemours & Company Incorporated
SHAR_EOF
chmod 0644 ImageMagick/quantize.man ||
echo 'restore of ImageMagick/quantize.man failed'
Wc_c="`wc -c < 'ImageMagick/quantize.man'`"
test 11046 -eq "$Wc_c" ||
	echo 'ImageMagick/quantize.man: original size 11046, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/utility.h ==============
if test -f 'ImageMagick/utility.h' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/utility.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/utility.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/utility.h' &&
X
/*
X  Utilities routines.
*/
extern int
X  ReadDataBlock _Declare((char *,FILE *));
X
extern unsigned int
X  ReadData _Declare((char *,int,int,FILE *));
X
extern unsigned long
X  LSBFirstReadLong _Declare((FILE *)),
X  MSBFirstReadLong _Declare((FILE *));
X
extern unsigned short
X  LSBFirstReadShort _Declare((FILE *)),
X  MSBFirstReadShort _Declare((FILE *));
X
extern void
X  LSBFirstWriteLong _Declare((unsigned long,FILE *)),
X  LSBFirstWriteShort _Declare((unsigned int,FILE *)),
X  MSBFirstOrderLong _Declare((char *,unsigned int)),
X  MSBFirstOrderShort _Declare((char *,unsigned int)),
X  MSBFirstWriteLong _Declare((unsigned long,FILE *)),
X  MSBFirstWriteShort _Declare((unsigned int,FILE *));
SHAR_EOF
chmod 0644 ImageMagick/utility.h ||
echo 'restore of ImageMagick/utility.h failed'
Wc_c="`wc -c < 'ImageMagick/utility.h'`"
test 690 -eq "$Wc_c" ||
	echo 'ImageMagick/utility.h: original size 690, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/signature.c ==============
if test -f 'ImageMagick/signature.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/signature.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/signature.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/signature.c' &&
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%        SSSSS  IIIII   GGGG  N   N   AAA   TTTTT  U   U  RRRR   EEEEE        %
%        SS       I    G      NN  N  A   A    T    U   U  R   R  E            %
%         SSS     I    G  GG  N N N  AAAAA    T    U   U  RRRR   EEE          %
%           SS    I    G   G  N  NN  A   A    T    U   U  R R    E            %
%        SSSSS  IIIII   GGG   N   N  A   A    T     UUU   R  R   EEEEE        %
%                                                                             %
%                                                                             %
%               Compute a Digital Signature for a Image Colormap              %
%                                                                             %
%                                                                             %
%                                                                             %
%                           Software Design                                   %
%                             John Cristy                                     %
%                            December 1992                                    %
%                                                                             %
%  Copyright 1993 E. I. du Pont de Nemours & Company                          %
%                                                                             %
%  Permission to use, copy, modify, distribute, and sell this software and    %
%  its documentation for any purpose is hereby granted without fee,           %
%  provided that the above Copyright notice appear in all copies and that     %
%  both that Copyright notice and this permission notice appear in            %
%  supporting documentation, and that the name of E. I. du Pont de Nemours    %
%  & Company not be used in advertising or publicity pertaining to            %
%  distribution of the software without specific, written prior               %
%  permission.  E. I. du Pont de Nemours & Company makes no representations   %
%  about the suitability of this software for any purpose.  It is provided    %
%  "as is" without express or implied warranty.                               %
%                                                                             %
%  E. I. du Pont de Nemours & Company disclaims all warranties with regard    %
%  to this software, including all implied warranties of merchantability      %
%  and fitness, in no event shall E. I. du Pont de Nemours & Company be       %
%  liable for any special, indirect or consequential damages or any           %
%  damages whatsoever resulting from loss of use, data or profits, whether    %
%  in an action of contract, negligence or other tortious action, arising     %
%  out of or in connection with the use or performance of this software.      %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Routine ColormapSignature computes a digital signature from the image
%  colormap.  This signature uniquely identifies the colormap and is convenient
%  for determining if the colormap of a sequence of images is identical when
%  animating.  The digital signature is from RSA Data Security MD5 Digest
%  Algorithm described in Internet draft [MD5], July 1992.
%
%
*/
X
/*
X  Include declarations.
*/
#include "display.h"
#include "image.h"
X
/*
X  Typedef declarations.
*/
typedef struct _MessageDigest
{
X  unsigned long
X    number_bits[2],
X    accumulator[4];
X
X  unsigned char
X    message[64],
X    digest[16];
} MessageDigest;
X
/*
X  External declarations.
*/
extern char
X  *client_name;
X
/*
X  Forward declarations.
*/
static void
X  TransformMessageDigest _Declare((MessageDigest *,unsigned long *)),
X  UpdateMessageDigest _Declare((MessageDigest *,unsigned char *,unsigned long));
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   C o m p u t e M e s s a g e D i g e s t                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function ComputeMessageDigest computes the message digest.
%
%  The format of the ComputeMessageDigest routine is:
%
%      ComputeMessageDigest(message_digest,input_message,message_length)
%
%  A description of each parameter follows:
%
%    o message_digest: The address of a structure of type MessageDigest.
%
%
*/
static void ComputeMessageDigest(message_digest)
MessageDigest
X  *message_digest;
{
X  int
X    number_bytes;
X
X  register unsigned char
X    *p;
X
X  register unsigned int
X    i;
X
X  unsigned char
X    padding[64];
X
X  unsigned long
X    message[16],
X    padding_length;
X
X  /*
X    Save number of bits.
X  */
X  message[14]=message_digest->number_bits[0];
X  message[15]=message_digest->number_bits[1];
X  /*
X    Compute number of bytes mod 64.
X  */
X  number_bytes=(int) ((message_digest->number_bits[0] >> 3) & 0x3F);
X  /*
X    Pad message to 56 mod 64.
X  */
X  padding_length=(number_bytes < 56) ? (56-number_bytes) : (120-number_bytes);
X  padding[0]=0x80;
X  for (i=1; i < padding_length; i++)
X    padding[i]=(char) 0;
X  UpdateMessageDigest(message_digest,padding,padding_length);
X  /*
X    Append length in bits and transform.
X  */
X  p=message_digest->message;
X  for (i=0; i < 14; i++)
X  {
X    message[i]=(unsigned long) (*p++);
X    message[i]|=((unsigned long) (*p++)) << 8;
X    message[i]|=((unsigned long) (*p++)) << 16;
X    message[i]|=((unsigned long) (*p++)) << 24;
X  }
X  TransformMessageDigest(message_digest,message);
X  /*
X    Store message in digest.
X  */
X  p=message_digest->digest;
X  for (i=0; i < 4; i++)
X  {
X    *p++=(unsigned char) (message_digest->accumulator[i] & 0xff);
X    *p++=(unsigned char) ((message_digest->accumulator[i] >> 8) & 0xff);
X    *p++=(unsigned char) ((message_digest->accumulator[i] >> 16) & 0xff);
X    *p++=(unsigned char) ((message_digest->accumulator[i] >> 24) & 0xff);
X  }
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   I n i t i a l i z e M e s s a g e D i g e s t                             %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function InitializeMessageDigest initializes the message digest structure.
%
%  The format of the InitializeMessageDigest routine is:
%
%      InitializeMessageDigest(message_digest)
%
%  A description of each parameter follows:
%
%    o message_digest: The address of a structure of type MessageDigest.
%
%
*/
static void InitializeMessageDigest(message_digest)
MessageDigest
X  *message_digest;
{
X  message_digest->number_bits[0]=(unsigned long) 0;
X  message_digest->number_bits[1]=(unsigned long) 0;
X  /*
X    Load magic initialization constants.
X  */
X  message_digest->accumulator[0]=(unsigned long) 0x67452301;
X  message_digest->accumulator[1]=(unsigned long) 0xefcdab89;
X  message_digest->accumulator[2]=(unsigned long) 0x98badcfe;
X  message_digest->accumulator[3]=(unsigned long) 0x10325476;
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   T r a n s f o r m M e s s a g e D i g e s t                               %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function TransformMessageDigest updates the message digest.
%
%  The format of the TransformMessageDigest routine is:
%
%      TransformMessageDigest(message_digest,message)
%
%  A description of each parameter follows:
%
%    o message_digest: The address of a structure of type MessageDigest.
%
%
*/
static void TransformMessageDigest(message_digest,message)
MessageDigest
X  *message_digest;
X
unsigned long
X  *message;
{
#define F(x,y,z)  (((x) & (y)) | ((~x) & (z)))
#define G(x,y,z)  (((x) & (z)) | ((y) & (~z)))
#define H(x,y,z)  ((x) ^ (y) ^ (z))
#define I(x,y,z)  ((y) ^ ((x) | (~z)))
#define RotateLeft(x,n)  (((x) << (n)) | (((x) & 0xffffffff) >> (32-(n))))
X
X  static unsigned long
X    additive_constant[64]=  /* 4294967296*abs(sin(i)), i in radians */
X    {
X      0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf,
X      0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af,
X      0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e,
X      0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
X      0xd62f105d, 0x2441453,  0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6,
X      0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8,
X      0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122,
X      0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
X      0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x4881d05,  0xd9d4d039,
X      0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97,
X      0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d,
X      0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
X      0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,
X    };
X
X  register int
X    i;
X
X  register unsigned int
X    j;
X
X  register unsigned long
X    a,
X    b,
X    c,
X    d,
X    *p;
X
X  /*
X    Save accumulator.
X  */
X  a=message_digest->accumulator[0];
X  b=message_digest->accumulator[1];
X  c=message_digest->accumulator[2];
X  d=message_digest->accumulator[3];
X  /*
X    a=b+((a+F(b,c,d)+X[k]+t) <<< s).
X  */
X  p=additive_constant;
X  j=0;
X  for (i=0; i < 4; i++)
X  {
X    a+=F(b,c,d)+message[j & 0x0f]+(*p++);
X    a=RotateLeft(a,7)+b;
X    j++;
X    d+=F(a,b,c)+message[j & 0x0f]+(*p++);
X    d=RotateLeft(d,12)+a;
X    j++;
X    c+=F(d,a,b)+message[j & 0x0f]+(*p++);
X    c=RotateLeft(c,17)+d;
X    j++;
X    b+=F(c,d,a)+message[j & 0x0f]+(*p++);
X    b=RotateLeft(b,22)+c;
X    j++;
X  }
X  /*
X    a=b+((a+G(b,c,d)+X[k]+t) <<< s).
X  */
X  j=1;
X  for (i=0; i < 4; i++)
X  {
X    a+=G(b,c,d)+message[j & 0x0f]+(*p++);
X    a=RotateLeft(a,5)+b;
X    j+=5;
X    d+=G(a,b,c)+message[j & 0x0f]+(*p++);
X    d=RotateLeft(d,9)+a;
X    j+=5;
X    c+=G(d,a,b)+message[j & 0x0f]+(*p++);
X    c=RotateLeft(c,14)+d;
X    j+=5;
X    b+=G(c,d,a)+message[j & 0x0f]+(*p++);
X    b=RotateLeft(b,20)+c;
X    j+=5;
X  }
X  /*
X    a=b+((a+H(b,c,d)+X[k]+t) <<< s).
X  */
X  j=5;
X  for (i=0; i < 4; i++)
X  {
X    a+=H(b,c,d)+message[j & 0x0f]+(*p++);
X    a=RotateLeft(a,4)+b;
X    j+=3;
X    d+=H(a,b,c)+message[j & 0x0f]+(*p++);
X    d=RotateLeft(d,11)+a;
X    j+=3;
X    c+=H(d,a,b)+message[j & 0x0f]+(*p++);
X    c=RotateLeft(c,16)+d;
X    j+=3;
X    b+=H(c,d,a)+message[j & 0x0f]+(*p++);
X    b=RotateLeft(b,23)+c;
X    j+=3;
X  }
X  /*
X    a=b+((a+I(b,c,d)+X[k]+t) <<< s).
X  */
X  j=0;
X  for (i=0; i < 4; i++)
X  {
X    a+=I(b,c,d)+message[j & 0x0f]+(*p++);
X    a=RotateLeft(a,6)+b;
X    j+=7;
X    d+=I(a,b,c)+message[j & 0x0f]+(*p++);
X    d=RotateLeft(d,10)+a;
X    j+=7;
X    c+=I(d,a,b)+message[j & 0x0f]+(*p++);
X    c=RotateLeft(c,15)+d;
X    j+=7;
X    b+=I(c,d,a)+message[j & 0x0f]+(*p++);
X    b=RotateLeft(b,21)+c;
X    j+=7;
X  }
X  /*
X    Increment accumulator.
X  */
X  message_digest->accumulator[0]+=a;
X  message_digest->accumulator[1]+=b;
X  message_digest->accumulator[2]+=c;
X  message_digest->accumulator[3]+=d;
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   U p d a t e M e s s a g e D i g e s t                                     %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function UpdateMessageDigest updates the message digest.
%
%  The format of the UpdateMessageDigest routine is:
%
%      UpdateMessageDigest(message_digest,input_message,message_length)
%
%  A description of each parameter follows:
%
%    o message_digest: The address of a structure of type MessageDigest.
%
%
*/
static void UpdateMessageDigest(message_digest,input_message,message_length)
MessageDigest
X  *message_digest;
X
unsigned char
X  *input_message;
X
unsigned long
X  message_length;
{
X  int
X    number_bytes;
X
X  register unsigned char
X    *p;
X
X  register unsigned int
X    i;
X
X  unsigned long
X    message[16];
X
X  /*
X    Compute number of bytes mod 64.
X  */
X  number_bytes=(int) ((message_digest->number_bits[0] >> 3) & 0x3F);
X  /*
X    Update number of bits.
X  */
X  if (((message_digest->number_bits[0]+(message_length << 3)) & 0xffffffff) <
X      message_digest->number_bits[0])
X    message_digest->number_bits[1]++;
X  message_digest->number_bits[0]+=message_length << 3;
X  message_digest->number_bits[1]+=message_length >> 29;
X  while (message_length--)
X  {
X    /*
X      Add new character to message.
X    */
X    message_digest->message[number_bytes++]=(*input_message++);
X    if (number_bytes == 0x40)
X      {
X        /*
X          Transform message digest 64 bytes at a time.
X        */
X        p=message_digest->message;
X        for (i=0; i < 16; i++)
X        {
X          message[i]=(unsigned long) (*p++);
X          message[i]|=((unsigned long) (*p++)) << 8;
X          message[i]|=((unsigned long) (*p++)) << 16;
X          message[i]|=((unsigned long) (*p++)) << 24;
X        }
X        TransformMessageDigest(message_digest,message);
X        number_bytes=0;
X      }
X  }
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   C o l o r m a p S i g n a t u r e                                         %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Fucntion ColormapSignature computes a digital signature from the image
%  colormap.  This signature uniquely identifies the colormap and is convenient
%  for determining if the colormap of a sequence of images is identical when
%  animating.  The digital signature is from RSA Data Security MD5 Digest
%  Algorithm described in Internet draft [MD5], July 1992.
%
%  The format of the ColormapSignature routine is:
%
%      ColormapSignature(image)
%
%  A description of each parameter follows:
%
%    o image: The address of a structure of type Image.
%
%
%
*/
void ColormapSignature(image)
Image
X  *image;
{
X  char
X    *hex;
X
X  MessageDigest
X    message_digest;
X
X  register int
X    i;
X
X  register unsigned char
X    *p;
X
X  unsigned char
X    *colormap;
X
X  if (image->class != PseudoClass)
X    return;
X  /*
X    Allocate colormap.
X  */
X  colormap=(unsigned char *) malloc(3*image->colors*sizeof(unsigned char));
X  if (colormap == (unsigned char *) NULL)
X    {
X      Warning("unable to compute colormap signature",
X        "memory allocation failed");
X      return;
X    }
X  p=colormap;
X  for (i=0; i < image->colors; i++)
X  {
X    *p++=image->colormap[i].red;
X    *p++=image->colormap[i].green;
X    *p++=image->colormap[i].blue;
X  }
X  /*
X    Compute program colormap signature.
X  */
X  InitializeMessageDigest(&message_digest);
X  UpdateMessageDigest(&message_digest,colormap,
X    (unsigned long) (image->colors*3));
X  ComputeMessageDigest(&message_digest);
X  (void) free((char *) colormap);
X  /*
X    Allocate memory for signature.
X  */
X  if (image->signature != (char *) NULL)
X    (void) free((char *) image->signature);
X  image->signature=(char *) malloc(33*sizeof(char));
X  if (image->signature == (char *) NULL)
X    {
X      Warning("unable to compute colormap signature",
X        "memory allocation failed");
X      return;
X    }
X  /*
X    Convert digital signature to a 32 character hex string.
X  */
X  p=(unsigned char *) image->signature;
X  hex="0123456789abcdef";
X  for (i=0; i < 16; i++)
X  {
X    *p++=hex[(message_digest.digest[i] >> 4) & 0xf];
X    *p++=hex[message_digest.digest[i] & 0xf];
X  }
X  *p='\0';
}
SHAR_EOF
chmod 0644 ImageMagick/signature.c ||
echo 'restore of ImageMagick/signature.c failed'
Wc_c="`wc -c < 'ImageMagick/signature.c'`"
test 17852 -eq "$Wc_c" ||
	echo 'ImageMagick/signature.c: original size 17852, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/encode.c ==============
if test -f 'ImageMagick/encode.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/encode.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/encode.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/encode.c' &&
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                   EEEEE  N   N   CCCC   OOO   DDDD   EEEEE                  %
%                   E      NN  N  C      O   O  D   D  E                      %
%                   EEE    N N N  C      O   O  D   D  EEE                    %
%                   E      N  NN  C      O   O  D   D  E                      %
%                   EEEEE  N   N   CCCC   OOO   DDDD   EEEEE                  %
%                                                                             %
%                                                                             %
%                    Utility Routines to Write Image Formats                  %
%                                                                             %
%                                                                             %
%                                                                             %
%                             Software Design                                 %
%                               John Cristy                                   %
%                              January 1992                                   %
%                                                                             %
%                                                                             %
%  Copyright 1993 E. I. du Pont de Nemours & Company                          %
%                                                                             %
%  Permission to use, copy, modify, distribute, and sell this software and    %
%  its documentation for any purpose is hereby granted without fee,           %
%  provided that the above Copyright notice appear in all copies and that     %
%  both that Copyright notice and this permission notice appear in            %
%  supporting documentation, and that the name of E. I. du Pont de Nemours    %
%  & Company not be used in advertising or publicity pertaining to            %
%  distribution of the software without specific, written prior               %
%  permission.  E. I. du Pont de Nemours & Company makes no representations   %
%  about the suitability of this software for any purpose.  It is provided    %
%  "as is" without express or implied warranty.                               %
%                                                                             %
%  E. I. du Pont de Nemours & Company disclaims all warranties with regard    %
%  to this software, including all implied warranties of merchantability      %
%  and fitness, in no event shall E. I. du Pont de Nemours & Company be       %
%  liable for any special, indirect or consequential damages or any           %
%  damages whatsoever resulting from loss of use, data or profits, whether    %
%  in an action of contract, negligence or other tortious action, arising     %
%  out of or in connection with the use or performance of this software.      %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Functions in this library convert to and from `alien' image formats to the
%  MIFF image format.
%
%
*/
X
/*
X  Include declarations.
*/
#include "display.h"
#include "image.h"
#include "X.h"
#include "compress.h"
#include "utility.h"
#include "XWDFile.h"
X
/*
X  Forward declarations.
*/
static unsigned int
X  WriteMIFFImage _Declare((Image *));
X
/*
X  External declarations.
*/
extern char
X  *client_name;
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   W r i t e A L P H A I m a g e                                             %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function WriteALPHAImage writes an mage of alpha bytes to a file.  It
%  consists of data from the alpha component of the image [0..255].
%
%  The format of the WriteALPHAImage routine is:
%
%      status=WriteALPHAImage(image)
%
%  A description of each parameter follows.
%
%    o status: Function WriteALPHAImage return True if the image is written.
%      False is returned is there is a memory shortage or if the image file
%      fails to write.
%
%    o image:  A pointer to a Image structure.
%
%
*/
static unsigned int WriteALPHAImage(image)
Image
X  *image;
{
X  register int
X    i,
X    j;
X
X  register RunlengthPacket
X    *p;
X
X  register unsigned char
X    *q;
X
X  unsigned char
X    *alpha_pixels;
X
X  if (image->class != DirectClass)
X    {
X      Warning("image must be of type DirectClass",image->filename);
SHAR_EOF
true || echo 'restore of ImageMagick/encode.c failed'
fi
echo 'End of ImageMagick part 33'
echo 'File ImageMagick/encode.c is continued in part 34'
echo 34 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
