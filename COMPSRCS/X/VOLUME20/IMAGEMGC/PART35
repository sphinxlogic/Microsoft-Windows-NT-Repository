Newsgroups: comp.sources.x
From: cristy@eplrx7.es.duPont.com (Cristy)
Subject: v20i091:  imagemagic - X11 image processing and display, Part35/38
Message-ID: <1993Jul14.232255.23575@sparky.sterling.com>
X-Md4-Signature: 942fc65fdbded2ac9dd5310a2ec2b912
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Wed, 14 Jul 1993 23:22:55 GMT
Approved: chris@sterling.com

Submitted-by: cristy@eplrx7.es.duPont.com (Cristy)
Posting-number: Volume 20, Issue 91
Archive-name: imagemagic/part35
Environment: X11
Supersedes: imagemagic: Volume 13, Issue 17-37

#!/bin/sh
# this is magick.35 (part 35 of ImageMagick)
# do not concatenate these parts, unpack them in order with /bin/sh
# file ImageMagick/encode.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 35; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping ImageMagick/encode.c'
else
echo 'x - continuing file ImageMagick/encode.c'
sed 's/^X//' << 'SHAR_EOF' >> 'ImageMagick/encode.c' &&
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function WritePCXImage writes an image in the ZSoft IBM PC Paintbrush file
%  format.
%
%  The format of the WritePCXImage routine is:
%
%      status=WritePCXImage(image)
%
%  A description of each parameter follows.
%
%    o status: Function WritePCXImage return True if the image is written.
%      False is returned is there is a memory shortage or if the image file
%      fails to write.
%
%    o image:  A pointer to a Image structure.
%
%
*/
static unsigned int WritePCXImage(image)
Image
X  *image;
{
X  typedef struct _PCXHeader
X  {
X    unsigned char
X      identifier,
X      version,
X      encoding,
X      bits_per_pixel;
X
X    short int
X      left,
X      top,
X      right,
X      bottom,
X      horizonal_resolution,
X      vertical_resolution;
X
X    unsigned char
X      reserved,
X      planes;
X
X    short int
X      bytes_per_line,
X      palette_info;
X
X    unsigned char
X      colormap_signature;
X  } PCXHeader;
X
X  PCXHeader
X    pcx_header;
X
X  register int
X    i,
X    j,
X    x,
X    y;
X
X  register RunlengthPacket
X    *p;
X
X  register unsigned char
X    *q;
X
X  unsigned char
X    count,
X    packet,
X    *pcx_colormap,
X    *pcx_pixels,
X    previous;
X
X  unsigned int
X    grayscale;
X
X  /*
X    Open output image file.
X  */
X  OpenImage(image,"w");
X  if (image->file == (FILE *) NULL)
X    {
X      Warning("unable to open file",image->filename);
X      return(False);
X    }
X  /*
X    PCX colormap must be 256 entries or less.
X  */
X  if ((image->class == DirectClass) || (image->colors > 256))
X    QuantizeImage(image,256,8,False,RGBColorspace,True);
X  /*
X    Initialize PCX raster file header.
X  */
X  pcx_header.identifier=0x0a;
X  pcx_header.version=5;
X  pcx_header.encoding=1;
X  /*
X    Determine if image is grayscale.
X  */
X  grayscale=True;
X  for (i=0; i < image->colors; i++)
X    if ((image->colormap[i].red != image->colormap[i].green) ||
X        (image->colormap[i].green != image->colormap[i].blue))
X      {
X        grayscale=False;
X        break;
X      }
X  if ((image->colors > 2) || !grayscale)
X    pcx_header.bits_per_pixel=8;
X  else
X    pcx_header.bits_per_pixel=1;
X  pcx_header.left=0;
X  pcx_header.top=0;
X  pcx_header.right=image->columns-1;
X  pcx_header.bottom=image->rows-1;
X  pcx_header.horizonal_resolution=image->columns;
X  pcx_header.vertical_resolution=image->rows;
X  pcx_header.reserved=0;
X  pcx_header.planes=1;
X  pcx_header.bytes_per_line=(image->columns*pcx_header.bits_per_pixel+7)/8;
X  pcx_header.palette_info=1;
X  pcx_header.colormap_signature=0x0c;
X  /*
X    Write PCX header.
X  */
X  (void) fwrite(&pcx_header.identifier,1,1,image->file);
X  (void) fwrite(&pcx_header.version,1,1,image->file);
X  (void) fwrite(&pcx_header.encoding,1,1,image->file);
X  (void) fwrite(&pcx_header.bits_per_pixel,1,1,image->file);
X  LSBFirstWriteShort(pcx_header.left,image->file);
X  LSBFirstWriteShort(pcx_header.top,image->file);
X  LSBFirstWriteShort(pcx_header.right,image->file);
X  LSBFirstWriteShort(pcx_header.bottom,image->file);
X  LSBFirstWriteShort(pcx_header.horizonal_resolution,image->file);
X  LSBFirstWriteShort(pcx_header.vertical_resolution,image->file);
X  /*
X    Dump colormap to file.
X  */
X  pcx_colormap=(unsigned char *) malloc(3*256*sizeof(unsigned char));
X  if (pcx_colormap == (unsigned char *) NULL)
X    {
X      Warning("unable to allocate memory",(char *) NULL);
X      return(False);
X    }
X  q=pcx_colormap;
X  for (i=0; i < image->colors; i++)
X  {
X    *q++=image->colormap[i].red;
X    *q++=image->colormap[i].green;
X    *q++=image->colormap[i].blue;
X  }
X  (void) fwrite((char *) pcx_colormap,3,16,image->file);
X  (void) fwrite(&pcx_header.reserved,1,1,image->file);
X  (void) fwrite(&pcx_header.planes,1,1,image->file);
X  LSBFirstWriteShort(pcx_header.bytes_per_line,image->file);
X  LSBFirstWriteShort(pcx_header.palette_info,image->file);
X  for (i=0; i < 58; i++)
X    (void) fwrite("\0",1,1,image->file);
X  /*
X    Convert MIFF to PCX raster pixels.
X  */
X  pcx_pixels=(unsigned char *)
X    malloc(pcx_header.bytes_per_line*image->rows*sizeof(unsigned char));
X  if (pcx_pixels == (unsigned char *) NULL)
X    {
X      Warning("unable to allocate memory",(char *) NULL);
X      return(False);
X    }
X  x=0;
X  y=0;
X  p=image->pixels;
X  q=pcx_pixels;
X  if (pcx_header.bits_per_pixel > 1)
X    for (i=0; i < image->packets; i++)
X    {
X      for (j=0; j <= (int) p->length; j++)
X      {
X        *q++=p->index;
X        x++;
X        if (x == image->columns)
X          {
X            x=0;
X            y++;
X            q=pcx_pixels+y*pcx_header.bytes_per_line;
X          }
X      }
X      p++;
X    }
X  else
X    {
X      register unsigned char
X        bit,
X        byte,
X        polarity;
X
X      /*
X        Convert PseudoClass image to a PCX monochrome image.
X      */
X      polarity=(Intensity(image->colormap[0]) <
X        Intensity(image->colormap[1]) ? 1 : 0);
X      bit=0;
X      byte=0;
X      for (i=0; i < image->packets; i++)
X      {
X        for (j=0; j <= (int) p->length; j++)
X        {
X          byte<<=1;
X          if (p->index == polarity)
X            byte|=0x01;
X          bit++;
X          if (bit == 8)
X            {
X              *q++=byte;
X              bit=0;
X              byte=0;
X            }
X          x++;
X          if (x == image->columns)
X            {
X              /*
X                Advance to the next scanline.
X              */
X              if (bit != 0)
X                *q++=byte << (8-bit);
X              bit=0;
X              byte=0;
X              x=0;
X              y++;
X              q=pcx_pixels+y*pcx_header.bytes_per_line;
X           }
X        }
X        p++;
X      }
X    }
X  /*
X    Runlength-encoded PCX pixels.
X  */
X  for (y=0; y < image->rows; y++)
X  {
X    q=pcx_pixels+y*pcx_header.bytes_per_line;
X    previous=(*q++);
X    count=1;
X    for (x=0; x < (pcx_header.bytes_per_line-1); x++)
X    {
X      packet=(*q++);
X      if ((packet == previous) && (count < 63))
X        {
X          count++;
X          continue;
X        }
X      if ((count > 1) || ((previous & 0xc0) == 0xc0))
X        {
X          count|=0xc0;
X          (void) fwrite(&count,1,1,image->file);
X        }
X      (void) fwrite(&previous,1,1,image->file);
X      previous=packet;
X      count=1;
X    }
X    if ((count > 1) || ((previous & 0xc0) == 0xc0))
X      {
X        count|=0xc0;
X        (void) fwrite(&count,1,1,image->file);
X      }
X    (void) fwrite(&previous,1,1,image->file);
X  }
X  if (image->colors > 16)
X    {
X      (void) fwrite(&pcx_header.colormap_signature,1,1,image->file);
X      (void) fwrite((char *) pcx_colormap,3,256,image->file);
X    }
X  (void) free((char *) pcx_pixels);
X  (void) free((char *) pcx_colormap);
X  CloseImage(image);
X  return(True);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   W r i t e P I C T I m a g e                                               %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function WritePICTImage writes an image to a file in the Apple Macintosh
%  QuickDraw/PICT image format.
%
%  The format of the WritePICTImage routine is:
%
%      status=WritePICTImage(image)
%
%  A description of each parameter follows.
%
%    o status: Function WritePICTImage return True if the image is written.
%      False is returned is there is a memory shortage or if the image file
%      fails to write.
%
%    o image:  A pointer to a Image structure.
%
%
*/
static unsigned int WritePICTImage(image)
Image
X  *image;
{
#define MaxCount  128
#define PictClipRegion  0x01
#define PictEndOfPicture  0xff
#define PictHeaderOp  0x0C00
#define PictHeaderSize  512
#define PictPackBitsRectangle  0x98
#define PictVersion  0x11
X
X  int
X    count;
X
X  register int
X    i,
X    j,
X    x;
X
X  register RunlengthPacket
X    *p;
X
X  register unsigned char
X    *q;
X
X  unsigned char
X    *buffer,
X    *packed_scanline,
X    *scanline;
X
X  unsigned short
X    blue,
X    red,
X    green;
X
X  /*
X    Open output image file.
X  */
X  OpenImage(image,"w");
X  if (image->file == (FILE *) NULL)
X    {
X      Warning("unable to open file",image->filename);
X      return(False);
X    }
X  /*
X    PICT colormap must be 256 entries or less.
X  */
X  if ((image->class == DirectClass) || (image->colors > 256))
X    QuantizeImage(image,256,8,False,RGBColorspace,True);
X  /*
X    Allocate memory.
X  */
X  buffer=(unsigned char *) malloc(PictHeaderSize*sizeof(unsigned char));
X  packed_scanline=(unsigned char *)
X    malloc((image->columns+image->columns/MaxCount+1)*sizeof(unsigned char));
X  scanline=(unsigned char *) malloc(image->columns*sizeof(unsigned char));
X  if ((buffer == (unsigned char *) NULL) ||
X      (packed_scanline == (unsigned char *) NULL) ||
X      (scanline == (unsigned char *) NULL))
X    {
X      Warning("unable to allocate memory",(char *) NULL);
X      return(False);
X    }
X  /*
X    Write header.
X  */
X  for (i=0; i < PictHeaderSize; i++)
X    buffer[i]=0;
X  (void) fwrite((char *) buffer,1,PictHeaderSize,image->file);
X  /*
X    Write picture size and frame.
X  */
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(image->rows,image->file);
X  MSBFirstWriteShort(image->columns,image->file);
X  /*
X    Write version.
X  */
X  MSBFirstWriteShort(PictVersion,image->file);
X  MSBFirstWriteShort(0x02FF,image->file);
X  MSBFirstWriteShort(PictHeaderOp,image->file);
X  MSBFirstWriteLong((unsigned long) -1L,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(image->columns,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(image->rows,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteLong(0L,image->file);
X  /*
X    Write clipping region.
X  */
X  MSBFirstWriteShort(PictClipRegion,image->file);
X  MSBFirstWriteShort(10,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(image->rows,image->file);
X  MSBFirstWriteShort(image->columns,image->file);
X  /*
X    Write pack bits rectangle.
X  */
X  MSBFirstWriteShort(PictPackBitsRectangle,image->file);
X  MSBFirstWriteShort((image->columns | 0x8000),image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(image->rows,image->file);
X  MSBFirstWriteShort(image->columns,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteLong(0L,image->file);
X  /*
X    Write resolution.
X  */
X  MSBFirstWriteShort(72,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(72,image->file);
X  MSBFirstWriteShort(0,image->file);
X  /*
X    Write miscellanious.
X  */
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(8,image->file);
X  MSBFirstWriteShort(1,image->file);
X  MSBFirstWriteShort(8,image->file);
X  MSBFirstWriteLong(0L,image->file);
X  MSBFirstWriteLong(0L,image->file);
X  MSBFirstWriteLong(0L,image->file);
X  MSBFirstWriteLong(0L,image->file);
X  MSBFirstWriteShort(0,image->file);
X  /*
X    Write colormap.
X  */
X  MSBFirstWriteShort((unsigned short) (image->colors-1),image->file);
X  for (i=0; i < image->colors; i++)
X  {
X    red=(image->colormap[i].red*65535)/(unsigned int) MaxRGB;
X    green=(image->colormap[i].green*65535)/(unsigned int) MaxRGB;
X    blue=(image->colormap[i].blue*65535)/(unsigned int) MaxRGB;
X    MSBFirstWriteShort((unsigned int) i,image->file);
X    MSBFirstWriteShort(red,image->file);
X    MSBFirstWriteShort(green,image->file);
X    MSBFirstWriteShort(blue,image->file);
X  }
X  /*
X    Write source and destination rectangle.
X  */
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(image->rows,image->file);
X  MSBFirstWriteShort(image->columns,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(0,image->file);
X  MSBFirstWriteShort(image->rows,image->file);
X  MSBFirstWriteShort(image->columns,image->file);
X  MSBFirstWriteShort(0,image->file);
X  /*
X    Write picture data.
X  */
X  count=0;
X  x=0;
X  p=image->pixels;
X  q=scanline;
X  for (i=0; i < image->packets; i++)
X  {
X    for (j=0; j <= (int) p->length; j++)
X    {
X      *q++=(unsigned char) p->index;
X      x++;
X      if (x == image->columns)
X        {
X          count+=PackbitsEncodeImage(image,scanline,packed_scanline);
X          q=scanline;
X          x=0;
X        }
X    }
X    p++;
X  }
X  if (count & 0x1)
X    (void) fputc('\0',image->file);
X  MSBFirstWriteShort(PictEndOfPicture,image->file);
X  (void) free((char *) scanline);
X  (void) free((char *) packed_scanline);
X  (void) free((char *) buffer);
X  CloseImage(image);
X  return(True);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   W r i t e P N M I m a g e                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Procedure WritePNMImage writes an image to a file in the PNM rasterfile
%  format.
%
%  The format of the WritePNMImage routine is:
%
%      status=WritePNMImage(image)
%
%  A description of each parameter follows.
%
%    o status: Function WritePNMImage return True if the image is written.
%      False is returned is there is a memory shortage or if the image file
%      fails to write.
%
%    o image:  A pointer to a Image structure.
%
%
*/
static unsigned int WritePNMImage(image)
Image
X  *image;
{
X  register int
X    i,
X    j;
X
X  register RunlengthPacket
X    *p;
X
X  register unsigned char
X    *q;
X
X  unsigned char
X    format,
X    *pnm_pixels;
X
X  unsigned int
X    packets;
X
X  /*
X    Open output image file.
X  */
X  OpenImage(image,"w");
X  if (image->file == (FILE *) NULL)
X    {
X      Warning("unable to open file",image->filename);
X      return(False);
X    }
X  /*
X    Promote/Demote image based on image type.
X  */
X  if (strcmp(image->magick,"PBM") == 0)
X    QuantizeImage(image,2,8,False,GRAYColorspace,True);
X  else
X    if (strcmp(image->magick,"PGM") == 0)
X      QuantizeImage(image,256,8,False,GRAYColorspace,True);
X    else
X      if (strcmp(image->magick,"PPM") == 0)
X        image->class=DirectClass;
X  /*
X    Write PNM file header.
X  */
X  packets=image->columns*image->rows;
X  if ((image->class == DirectClass) || (image->colors > 256))
X    {
X      format='6';
X      packets*=3;
X    }
X  else
X    {
X      /*
X        Determine if image is gray scale.
X      */
X      format='5';
X      if (image->colors == 2)
X        format='4';
X      for (i=0; i < image->colors; i++)
X        if ((image->colormap[i].red != image->colormap[i].green) ||
X            (image->colormap[i].green != image->colormap[i].blue))
X          {
X            format='6';
X            packets*=3;
X            break;
X          }
X    }
X  (void) fprintf(image->file,"P%c\n# created by ImageMagick\n%u %u\n",
X    format,image->columns,image->rows);
X  /*
X    Convert MIFF to PNM raster pixels.
X  */
X  pnm_pixels=(unsigned char *) malloc(packets*sizeof(unsigned char));
X  if (pnm_pixels == (unsigned char *) NULL)
X    {
X      Warning("unable to allocate memory",(char *) NULL);
X      return(False);
X    }
X  p=image->pixels;
X  q=pnm_pixels;
X  switch (format)
X  {
X    case '4':
X    {
X      register unsigned char
X        bit,
X        byte,
X        polarity;
X
X      unsigned int
X        x;
X
X      /*
X        Convert image to a PBM image.
X      */
X      polarity=(Intensity(image->colormap[0]) <
X        Intensity(image->colormap[1]) ? 0 : 1);
X      bit=0;
X      byte=0;
X      x=0;
X      for (i=0; i < image->packets; i++)
X      {
X        for (j=0; j <= (int) p->length; j++)
X        {
X          byte<<=1;
X          if (p->index == polarity)
X            byte|=0x01;
X          bit++;
X          if (bit == 8)
X            {
X              *q++=byte;
X              bit=0;
X              byte=0;
X            }
X          x++;
X          if (x == image->columns)
X            {
X              /*
X                Advance to the next scanline.
X              */
X              if (bit != 0)
X                *q++=byte << (8-bit);
X              bit=0;
X              byte=0;
X              x=0;
X           }
X        }
X        p++;
X      }
X      packets=q-pnm_pixels;
X      break;
X    }
X    case '5':
X    {
X      /*
X        Convert image to a PGM image.
X      */
X      (void) fprintf(image->file,"%d\n",MaxRGB);
X      for (i=0; i < image->packets; i++)
X      {
X        for (j=0; j <= ((int) p->length); j++)
X          *q++=image->colormap[p->index].red;
X        p++;
X      }
X      break;
X    }
X    case '6':
X    {
X      /*
X        Convert image to a PNM image.
X      */
X      (void) fprintf(image->file,"%d\n",MaxRGB);
X      for (i=0; i < image->packets; i++)
X      {
X        for (j=0; j <= ((int) p->length); j++)
X        {
X          *q++=p->red;
X          *q++=p->green;
X          *q++=p->blue;
X        }
X        p++;
X      }
X      break;
X    }
X  }
X  (void) fwrite((char *) pnm_pixels,1,(int) packets,image->file);
X  (void) free((char *) pnm_pixels);
X  CloseImage(image);
X  return(True);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   W r i t e R L E I m a g e                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function WriteRLEImage writes an image in the Utah Run length encoded image
%  format.
%
%  The format of the WriteRLEImage routine is:
%
%      status=WriteRLEImage(image)
%
%  A description of each parameter follows.
%
%    o status: Function WriteRLEImage return True if the image is written.
%      False is returned is there is a memory shortage or if the image file
%      fails to write.
%
%    o image:  A pointer to a Image structure.
%
%
*/
static unsigned int WriteRLEImage(image)
Image
X  *image;
{
X  unsigned int
X    status;
X
X  Warning("Cannot write RLE images",image->filename);
X  status=WriteMIFFImage(image);
X  return(status);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   W r i t e P S I m a g e                                                   %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function WritePSImage translates a MIFF image to encapsulated Postscript
%  Level I for printing.  If the supplied geometry is null, the image is
%  centered on the Postscript page.  Otherwise, the image is positioned as
%  specified by the geometry.
%
%  The format of the WritePSImage routine is:
%
%      status=WritePSImage(image,geometry,density,encapsulated)
%
%  A description of each parameter follows:
%
%    o status: Function WritePSImage return True if the image is printed.
%      False is returned if the image file cannot be opened for printing.
%
%    o image: The address of a structure of type Image;  returned from
%      ReadImage.
%
%    o geometry: A pointer to a geometry string.  Specifies the width and
%      height of the Postscript image.
%
%    o density: A pointer to a density string.  Specifies the dots-per-inch
%      of the Postscript image.
%
%    o encapsulated:  A non-zero value indicates the output is Encapsulated
%      Postscript.
%
%
*/
static unsigned int WritePSImage(image,geometry,density,encapsulated)
Image
X  *image;
X
char
X  *geometry,
X  *density;
X
unsigned int
X  encapsulated;
{
#define PageSideMargin 18
#define PageTopMargin 94
#define PageWidth  612
#define PageHeight 792
#define XResolution  72
#define YResolution  72
X
X  static char
X    *Postscript[]=
X    {
X      "%%BeginProlog",
X      "%",
X      "% Display a color image.  The image is displayed in color on",
X      "% Postscript viewers or printers that support color, otherwise",
X      "% it is displayed as grayscale.",
X      "%",
X      "/buffer 512 string def",
X      "/byte 1 string def",
X      "/color_packet 3 string def",
X      "/pixels 768 string def",
X      "",
X      "/DirectClassPacket",
X      "{",
X      "  %",
X      "  % Get a DirectClass packet.",
X      "  %",
X      "  % Parameters: ",
X      "  %   red.",
X      "  %   green.",
X      "  %   blue.",
X      "  %   length: number of pixels minus one of this color (optional).",
X      "  %",
X      "  currentfile color_packet readhexstring pop pop",
X      "  compression 0 gt",
X      "  {",
X      "    /number_pixels 3 def",
X      "  }",
X      "  {",
X      "    currentfile byte readhexstring pop 0 get",
X      "    /number_pixels exch 1 add 3 mul def",
X      "  } ifelse",
X      "  0 3 number_pixels 1 sub",
X      "  {",
X      "    pixels exch color_packet putinterval",
X      "  } for",
X      "  pixels 0 number_pixels getinterval",
X      "} bind def",
X      "",
X      "/DirectClassImage",
X      "{",
X      "  %",
X      "  % Display a DirectClass image.",
X      "  %",
X      "  systemdict /colorimage known",
X      "  {",
X      "    columns rows 8",
X      "    [",
X      "      columns 0 0",
X      "      rows neg 0 rows",
X      "    ]",
X      "    { DirectClassPacket } false 3 colorimage",
X      "  }",
X      "  {",
X      "    %",
X      "    % No colorimage operator;  convert to grayscale.",
X      "    %",
X      "    columns rows 8",
X      "    [",
X      "      columns 0 0",
X      "      rows neg 0 rows",
X      "    ]",
X      "    { GrayDirectClassPacket } image",
X      "  } ifelse",
X      "} bind def",
X      "",
X      "/GrayDirectClassPacket",
X      "{",
X      "  %",
X      "  % Get a DirectClass packet;  convert to grayscale.",
X      "  %",
X      "  % Parameters: ",
X      "  %   red",
X      "  %   green",
X      "  %   blue",
X      "  %   length: number of pixels minus one of this color (optional).",
X      "  %",
X      "  currentfile color_packet readhexstring pop pop",
X      "  color_packet 0 get 0.299 mul",
X      "  color_packet 1 get 0.587 mul add",
X      "  color_packet 2 get 0.114 mul add",
X      "  cvi",
X      "  /gray_packet exch def",
X      "  compression 0 gt",
X      "  {",
X      "    /number_pixels 1 def",
X      "  }",
X      "  {",
X      "    currentfile byte readhexstring pop 0 get",
X      "    /number_pixels exch 1 add def",
X      "  } ifelse",
X      "  0 1 number_pixels 1 sub",
X      "  {",
X      "    pixels exch gray_packet put",
X      "  } for",
X      "  pixels 0 number_pixels getinterval",
X      "} bind def",
X      "",
X      "/GrayPseudoClassPacket",
X      "{",
X      "  %",
X      "  % Get a PseudoClass packet;  convert to grayscale.",
X      "  %",
X      "  % Parameters: ",
X      "  %   index: index into the colormap.",
X      "  %   length: number of pixels minus one of this color (optional).",
X      "  %",
X      "  currentfile byte readhexstring pop 0 get",
X      "  /offset exch 3 mul def",
X      "  /color_packet colormap offset 3 getinterval def",
X      "  color_packet 0 get 0.299 mul",
X      "  color_packet 1 get 0.587 mul add",
X      "  color_packet 2 get 0.114 mul add",
X      "  cvi",
X      "  /gray_packet exch def",
X      "  compression 0 gt",
X      "  {",
X      "    /number_pixels 1 def",
X      "  }",
X      "  {",
X      "    currentfile byte readhexstring pop 0 get",
X      "    /number_pixels exch 1 add def",
X      "  } ifelse",
X      "  0 1 number_pixels 1 sub",
X      "  {",
X      "    pixels exch gray_packet put",
X      "  } for",
X      "  pixels 0 number_pixels getinterval",
X      "} bind def",
X      "",
X      "/PseudoClassPacket",
X      "{",
X      "  %",
X      "  % Get a PseudoClass packet.",
X      "  %",
X      "  % Parameters: ",
X      "  %   index: index into the colormap.",
X      "  %   length: number of pixels minus one of this color (optional).",
X      "  %",
X      "  currentfile byte readhexstring pop 0 get",
X      "  /offset exch 3 mul def",
X      "  /color_packet colormap offset 3 getinterval def",
X      "  compression 0 gt",
X      "  {",
X      "    /number_pixels 3 def",
X      "  }",
X      "  {",
X      "    currentfile byte readhexstring pop 0 get",
X      "    /number_pixels exch 1 add 3 mul def",
X      "  } ifelse",
X      "  0 3 number_pixels 1 sub",
X      "  {",
X      "    pixels exch color_packet putinterval",
X      "  } for",
X      "  pixels 0 number_pixels getinterval",
X      "} bind def",
X      "",
X      "/PseudoClassImage",
X      "{",
X      "  %",
X      "  % Display a PseudoClass image.",
X      "  %",
X      "  % Parameters: ",
X      "  %   colors: number of colors in the colormap.",
X      "  %   colormap: red, green, blue color packets.",
X      "  %",
X      "  currentfile buffer readline pop",
X      "  token pop /colors exch def pop",
X      "  /colors colors 3 mul def",
X      "  /colormap colors string def",
X      "  currentfile colormap readhexstring pop pop",
X      "  systemdict /colorimage known",
X      "  {",
X      "    columns rows 8",
X      "    [",
X      "      columns 0 0",
X      "      rows neg 0 rows",
X      "    ]",
X      "    { PseudoClassPacket } false 3 colorimage",
X      "  }",
X      "  {",
X      "    %",
X      "    % No colorimage operator;  convert to grayscale.",
X      "    %",
X      "    columns rows 8",
X      "    [",
X      "      columns 0 0",
X      "      rows neg 0 rows",
X      "    ]",
X      "    { GrayPseudoClassPacket } image",
X      "  } ifelse",
X      "} bind def",
X      "",
X      "/DisplayImage",
X      "{",
X      "  %",
X      "  % Display a DirectClass or PseudoClass image.",
X      "  %",
X      "  % Parameters: ",
X      "  %   x & y translation.",
X      "  %   x & y scale.",
X      "  %   image columns & rows.",
X      "  %   class: 0-DirectClass or 1-PseudoClass.",
X      "  %   compression: 0-RunlengthEncodedCompression or 1-NoCompression.",
X      "  %   hex color packets.",
X      "  %",
X      "  gsave",
X      "  currentfile buffer readline pop",
X      "  token pop /x exch def",
X      "  token pop /y exch def pop",
X      "  x y translate",
X      "  currentfile buffer readline pop",
X      "  token pop /x exch def",
X      "  token pop /y exch def pop",
X      "  x y scale",
X      "  currentfile buffer readline pop",
X      "  token pop /columns exch def",
X      "  token pop /rows exch def pop",
X      "  currentfile buffer readline pop",
X      "  token pop /class exch def pop",
X      "  currentfile buffer readline pop",
X      "  token pop /compression exch def pop",
X      "  class 0 gt { PseudoClassImage } { DirectClassImage } ifelse",
X      "  grestore",
X      "  showpage",
X      "} bind def",
X      "%%EndProlog",
X      "%%Page:  1 1",
X      NULL
X    };
X
X  char
X    **q;
X
X  int
X    flags,
X    x,
X    y;
X
X  register RunlengthPacket
X    *p;
X
X  register int
X    i,
X    j;
X
X  time_t
X    timer;
X
X  unsigned int
X    height,
X    page_width,
X    page_height,
X    x_resolution,
X    y_resolution,
X    width;
X
X  unsigned long
X    scale_factor;
X
X  /*
X    Open output image file.
X  */
X  OpenImage(image,"w");
X  if (image->file == (FILE *) NULL)
X    {
X      Warning("unable to open file",image->filename);
X      return(False);
X    }
X  /*
X    Scale image to size of Postscript page.
X  */
X  if (encapsulated)
X    {
X      x=0;
X      y=0;
X      width=image->columns;
X      height=image->rows;
X      if (geometry != (char *) NULL)
X        (void) XParseGeometry(geometry,&x,&y,&page_width,&page_height);
X    }
X  else
X    {
X      /*
X        Center image on Postscript page.
X      */
X      page_width=PageWidth;
X      page_height=PageHeight;
X      flags=XParseGeometry(geometry,&x,&y,&page_width,&page_height);
X      scale_factor=UpShift(page_width-(2*PageSideMargin))/image->columns;
X      if (scale_factor > (UpShift(page_height-(2*PageTopMargin))/image->rows))
X        scale_factor=UpShift(page_height-(2*PageTopMargin))/image->rows;
X      width=DownShift(image->columns*scale_factor);
X      height=DownShift(image->rows*scale_factor);
X      if (((flags & XValue) == 0) && ((flags & YValue) == 0))
X        {
X          int
X            delta_x,
X            delta_y;
X
X          delta_x=page_width-(width+(2*PageSideMargin));
X          delta_y=page_height-(height+(2*PageTopMargin));
X          if (delta_x >= 0)
X            x=delta_x/2+PageSideMargin;
X          else
X            x=PageSideMargin;
X          if (delta_y >= 0)
X            y=delta_y/2+PageTopMargin;
X          else
X            y=PageTopMargin;
X        }
X    }
X  /*
X    Scale relative to dots-per-inch.
X  */
X  x_resolution=XResolution;
X  y_resolution=YResolution;
X  if (density != (char *) NULL)
X    {
X      int
X        z;
X
X      /*
X        User specified density.
X      */
X      flags=XParseGeometry(density,&z,&z,&x_resolution,&y_resolution);
X      if ((flags & WidthValue) == 0)
X        x_resolution=XResolution;
X      if ((flags & HeightValue) == 0)
X        y_resolution=x_resolution;
X    }
X  scale_factor=UpShift(XResolution)/x_resolution;
X  width=DownShift(width*scale_factor);
X  scale_factor=UpShift(YResolution)/y_resolution;
X  height=DownShift(height*scale_factor);
X  /*
X    Output Postscript header.
X  */
X  if (!encapsulated)
X    (void) fprintf(image->file,"%%!PS-Adobe-3.0\n");
X  else
X    (void) fprintf(image->file,"%%!PS-Adobe-3.0 EPSF-3.0\n");
X  (void) fprintf(image->file,"%%%%Title: %s\n",image->filename);
X  (void) fprintf(image->file,"%%%%Creator: ImageMagick\n");
X  timer=time((time_t *) NULL);
X  (void) localtime(&timer);
X  (void) fprintf(image->file,"%%%%CreationDate: %s",ctime(&timer));
X  (void) fprintf(image->file,"%%%%BoundingBox: %d %d %d %d\n",x,y,x+(int) width,
X    y+(int) height);
X  if (!encapsulated)
X    {
X      (void) fprintf(image->file,"%%%%Orientation: Portrait\n");
X      (void) fprintf(image->file,"%%%%PageOrder: Ascend\n");
X    }
X  (void) fprintf(image->file,"%%%%Pages: %d\n",!encapsulated);
X  (void) fprintf(image->file,"%%%%EndComments\n");
X  /*
X    Output Postscript commands.
X  */
X  for (q=Postscript; *q; q++)
X    (void) fprintf(image->file,"%s\n",*q);
X  if (encapsulated)
X    (void) fprintf(image->file,"userdict begin\n");
X  (void) fprintf(image->file,"%%%%BeginData:\n");
X  (void) fprintf(image->file,"DisplayImage\n");
X  /*
X    Output image data.
X  */
X  if (image->compression == RunlengthEncodedCompression)
X    CompressImage(image);
X  p=image->pixels;
X  switch (image->class)
X  {
X    case DirectClass:
X    {
X      (void) fprintf(image->file,"%d %d\n%u %u\n%u %u\n%d\n%d\n",x,y,width,
X        height,image->columns,image->rows,(image->class == PseudoClass),
X        image->compression == NoCompression);
X      switch (image->compression)
X      {
X        case RunlengthEncodedCompression:
X        default:
X        {
X          /*
X            Dump runlength-encoded DirectColor packets.
X          */
X          x=0;
X          for (i=0; i < image->packets; i++)
X          {
X            x++;
X            (void) fprintf(image->file,"%02x%02x%02x%02x",p->red,p->green,
X              p->blue,p->length);
X            if (x == 9)
X              {
X                x=0;
X                (void) fprintf(image->file,"\n");
X              }
X            p++;
X          }
X          break;
X        }
X        case NoCompression:
X        {
X          /*
X            Dump uncompressed DirectColor packets.
X          */
X          x=0;
X          for (i=0; i < image->packets; i++)
X          {
X            for (j=0; j <= ((int) p->length); j++)
X            {
X              x++;
X              (void) fprintf(image->file,"%02x%02x%02x",p->red,p->green,
X                p->blue);
X              if (x == 12)
X                {
X                  x=0;
X                  (void) fprintf(image->file,"\n");
X                }
X            }
X            p++;
X          }
X          break;
X        }
X      }
X      break;
X    }
X    case PseudoClass:
X    {
X      (void) fprintf(image->file,"%d %d\n%u %u\n%u %u\n%d\n%d\n",x,y,width,
X        height,image->columns,image->rows,(image->class == PseudoClass),
X        image->compression == NoCompression);
X      /*
X        Dump number of colors and colormap.
X      */
X      (void) fprintf(image->file,"%u\n",image->colors);
X      for (i=0; i < image->colors; i++)
X        (void) fprintf(image->file,"%02x%02x%02x\n",image->colormap[i].red,
X          image->colormap[i].green,image->colormap[i].blue);
X      switch (image->compression)
X      {
X        case RunlengthEncodedCompression:
X        default:
X        {
X          /*
X            Dump runlength-encoded PseudoColor packets.
X          */
X          x=0;
X          for (i=0; i < image->packets; i++)
X          {
X            x++;
X            (void) fprintf(image->file,"%02x%02x",p->index,p->length);
X            if (x == 18)
X              {
X                x=0;
X                (void) fprintf(image->file,"\n");
X              }
X            p++;
X          }
X          break;
X        }
X        case NoCompression:
X        {
X          /*
X            Dump uncompressed PseudoColor packets.
X          */
X          x=0;
X          for (i=0; i < image->packets; i++)
X          {
X            for (j=0; j <= ((int) p->length); j++)
X            {
X              x++;
X              (void) fprintf(image->file,"%02x",p->index);
X              if (x == 36)
X                {
X                  x=0;
X                  (void) fprintf(image->file,"\n");
X                }
X            }
X            p++;
X          }
X          break;
X        }
X      }
X    }
X  }
X  (void) fprintf(image->file,"\n");
X  (void) fprintf(image->file,"%%%%EndData\n");
X  if (encapsulated)
X    (void) fprintf(image->file,"end\n");
X  (void) fprintf(image->file,"%%%%PageTrailer\n");
X  (void) fprintf(image->file,"%%%%Trailer\n");
X  (void) fprintf(image->file,"%%%%EOF\n");
X  CloseImage(image);
X  return(True);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   W r i t e P S 2 I m a g e                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function WritePS2Image translates a MIFF image to encapsulated Postscript
%  Level II for printing.  If the supplied geometry is null, the image is
%  centered on the Postscript page.  Otherwise, the image is positioned as
%  specified by the geometry.
%
%  The format of the WritePS2Image routine is:
%
%      status=WritePS2Image(image,geometry,density,encapsulated)
%
%  A description of each parameter follows:
%
%    o status: Function WritePS2Image return True if the image is printed.
%      False is returned if the image file cannot be opened for printing.
%
%    o image: The address of a structure of type Image;  returned from
%      ReadImage.
%
%    o geometry: A pointer to a geometry string.  Specifies the width and
%      height of the Postscript image.
%
%    o density: A pointer to a density string.  Specifies the dots-per-inch
%      of the Postscript image.
%
%    o encapsulated:  A non-zero value indicates the output is Encapsulated
%      Postscript.
%
%
*/
static unsigned int WritePS2Image(image,geometry,density,encapsulated)
Image
X  *image;
X
char
X  *geometry,
X  *density;
X
unsigned int
X  encapsulated;
{
#define PageSideMargin 18
#define PageTopMargin 94
#define PageWidth  612
#define PageHeight 792
#define XResolution  72
#define YResolution  72
X
X  static char
X    *Postscript[]=
X    {
X      "%%BeginProlog",
X      "%",
X      "% Display a color image.  The image is displayed in color on",
X      "% Postscript viewers or printers that support color, otherwise",
X      "% it is displayed as grayscale.",
X      "%",
X      "/buffer 512 string def",
X      "",
X      "/DirectClassImage",
X      "{",
X      "  %",
X      "  % Display a DirectClass image.",
X      "  %",
X      "  /DeviceRGB setcolorspace",
X      "  <<",
X      "    /ImageType 1",
X      "    /Interpolate true",
X      "    /Width columns",
X      "    /Height rows",
X      "    /BitsPerComponent 8",
X      "    /Decode [0 1 0 1 0 1]",
X      "    /ImageMatrix [columns 0 0 rows neg 0 rows]",
X      "    compression 0 gt",
X      "    {",
X      "      /DataSource currentfile /ASCIIHexDecode filter",
X      "    }",
X      "    {",
X      "      /DataSource currentfile /ASCIIHexDecode filter /LZWDecode filter",
X      "    } ifelse",
X      "  >> image",
X      "} bind def",
X      "",
X      "/PseudoClassImage",
X      "{",
X      "  %",
X      "  % Display a PseudoClass image.",
X      "  %",
X      "  % Parameters: ",
X      "  %   colors: number of colors in the colormap.",
X      "  %   colormap: red, green, blue color packets.",
X      "  %",
X      "  currentfile buffer readline pop",
X      "  token pop /colors exch def pop",
X      "  /colormap colors 3 mul string def",
X      "  currentfile colormap readhexstring pop pop",
X      "  [ /Indexed /DeviceRGB colors 1 sub colormap ] setcolorspace",
X      "  <<",
X      "    /ImageType 1",
X      "    /Interpolate true",
X      "    /Width columns",
X      "    /Height rows",
X      "    /BitsPerComponent 8",
X      "    /Decode [0 255]",
X      "    /ImageMatrix [columns 0 0 rows neg 0 rows]",
X      "    compression 0 gt",
X      "    {",
X      "      /DataSource currentfile /ASCIIHexDecode filter",
X      "    }",
X      "    {",
X      "      /DataSource currentfile /ASCIIHexDecode filter /LZWDecode filter",
X      "    } ifelse",
X      "  >> image",
X      "} bind def",
X      "",
X      "/DisplayImage",
X      "{",
X      "  %",
X      "  % Display a DirectClass or PseudoClass image.",
X      "  %",
X      "  % Parameters: ",
X      "  %   x & y translation.",
X      "  %   x & y scale.",
X      "  %   image columns & rows.",
X      "  %   class: 0-DirectClass or 1-PseudoClass.",
X      "  %   compression: 0-RunlengthEncodedCompression or 1-NoCompression.",
X      "  %   hex color packets.",
X      "  %",
X      "  gsave",
X      "  currentfile buffer readline pop",
X      "  token pop /x exch def",
X      "  token pop /y exch def pop",
X      "  x y translate",
X      "  currentfile buffer readline pop",
X      "  token pop /x exch def",
X      "  token pop /y exch def pop",
X      "  x y scale",
X      "  currentfile buffer readline pop",
X      "  token pop /columns exch def",
X      "  token pop /rows exch def pop",
X      "  currentfile buffer readline pop",
X      "  token pop /class exch def pop",
X      "  currentfile buffer readline pop",
X      "  token pop /compression exch def pop",
X      "  class 0 gt { PseudoClassImage } { DirectClassImage } ifelse",
X      "  grestore",
X      "  showpage",
X      "} bind def",
X      "%%EndProlog",
X      "%%Page:  1 1",
X      NULL
X    };
X
X  char
X    **q;
X
X  int
X    flags,
X    x,
X    y;
X
X  register RunlengthPacket
X    *p;
X
X  register int
X    i,
X    j;
X
X  time_t
X    timer;
X
X  unsigned char
X    *pixels;
X
X  unsigned int
X    height,
X    number_packets,
X    page_width,
X    page_height,
X    x_resolution,
X    y_resolution,
X    width;
X
X  unsigned long
X    scale_factor;
X
X  /*
X    Open output image file.
X  */
X  OpenImage(image,"w");
X  if (image->file == (FILE *) NULL)
X    {
X      Warning("unable to open file",image->filename);
X      return(False);
X    }
X  /*
X    Scale image to size of Postscript page.
X  */
X  if (encapsulated)
X    {
X      x=0;
X      y=0;
X      width=image->columns;
X      height=image->rows;
X      (void) XParseGeometry(geometry,&x,&y,&page_width,&page_height);
X    }
X  else
X    {
X      /*
X        Center image on Postscript page.
X      */
X      page_width=PageWidth;
X      page_height=PageHeight;
X      flags=XParseGeometry(geometry,&x,&y,&page_width,&page_height);
X      scale_factor=UpShift(page_width-(2*PageSideMargin))/image->columns;
X      if (scale_factor > (UpShift(page_height-(2*PageTopMargin))/image->rows))
X        scale_factor=UpShift(page_height-(2*PageTopMargin))/image->rows;
X      width=DownShift(image->columns*scale_factor);
X      height=DownShift(image->rows*scale_factor);
X      if (((flags & XValue) == 0) && ((flags & YValue) == 0))
X        {
X          int
X            delta_x,
X            delta_y;
X
X          delta_x=page_width-(width+(2*PageSideMargin));
X          delta_y=page_height-(height+(2*PageTopMargin));
X          if (delta_x >= 0)
X            x=delta_x/2+PageSideMargin;
X          else
X            x=PageSideMargin;
X          if (delta_y >= 0)
X            y=delta_y/2+PageTopMargin;
X          else
X            y=PageTopMargin;
X        }
X    }
X  /*
X    Scale relative to dots-per-inch.
X  */
X  x_resolution=XResolution;
X  y_resolution=YResolution;
X  if (density != (char *) NULL)
X    {
X      int
X        z;
X
X      /*
X        User specified density.
X      */
X      flags=XParseGeometry(density,&z,&z,&x_resolution,&y_resolution);
X      if ((flags & WidthValue) == 0)
X        x_resolution=XResolution;
X      if ((flags & HeightValue) == 0)
X        y_resolution=x_resolution;
X    }
X  scale_factor=UpShift(XResolution)/x_resolution;
X  width=DownShift(width*scale_factor);
X  scale_factor=UpShift(YResolution)/y_resolution;
X  height=DownShift(height*scale_factor);
X  /*
X    Output Postscript header.
X  */
X  if (!encapsulated)
X    (void) fprintf(image->file,"%%!PS-Adobe-3.0\n");
X  else
X    (void) fprintf(image->file,"%%!PS-Adobe-3.0 EPSF-3.0\n");
X  (void) fprintf(image->file,"%%%%Title: %s\n",image->filename);
X  (void) fprintf(image->file,"%%%%Creator: ImageMagick\n");
X  timer=time((time_t) NULL);
X  (void) localtime(&timer);
X  (void) fprintf(image->file,"%%%%CreationDate: %s",ctime(&timer));
X  (void) fprintf(image->file,"%%%%BoundingBox: %d %d %d %d\n",x,y,x+(int) width,
X    y+(int) height);
X  if (!encapsulated)
X    {
X      (void) fprintf(image->file,"%%%%Orientation: Portrait\n");
X      (void) fprintf(image->file,"%%%%PageOrder: Ascend\n");
X    }
X  (void) fprintf(image->file,"%%%%Pages: %d\n",!encapsulated);
X  (void) fprintf(image->file,"%%%%EndComments\n");
X  /*
X    Output Postscript commands.
X  */
X  for (q=Postscript; *q; q++)
X    (void) fprintf(image->file,"%s\n",*q);
X  if (encapsulated)
X    (void) fprintf(image->file,"userdict begin\n");
X  (void) fprintf(image->file,"%%%%BeginData:\n");
X  (void) fprintf(image->file,"DisplayImage\n");
X  /*
X    Output image data.
X  */
X  p=image->pixels;
X  if ((image->class == DirectClass) || (image->colors > 256))
X    {
X      (void) fprintf(image->file,"%d %d\n%u %u\n%u %u\n%d\n%d\n",x,y,width,
X        height,image->columns,image->rows,(image->class == PseudoClass),
X        image->compression == NoCompression);
X      switch (image->compression)
X      {
X        case RunlengthEncodedCompression:
X        default:
X        {
X          register unsigned char
X            *q;
X
X          /*
X            Allocate pixel array.
X          */
X          number_packets=3*image->columns*image->rows;
X          pixels=(unsigned char *) malloc(number_packets*sizeof(unsigned char));
X          if (pixels == (unsigned char *) NULL)
X            {
X              Warning("memory allocation error",(char *) NULL);
X              return(False);
X            }
X          /*
X            Dump LZW encoded pixels.
X          */
X          q=pixels;
X          for (i=0; i < image->packets; i++)
X          {
X            for (j=0; j <= (int) p->length; j++)
X            {
X              *q++=p->red;
X              *q++=p->green;
X              *q++=p->blue;
X            }
X            p++;
X          }
X          (void) LZWEncodeFilter(image->file,pixels,number_packets);
X          (void) fprintf(image->file,">");
X          (void) free((char *) pixels);
X          break;
X        }
X        case NoCompression:
X        {
X          /*
X            Dump uncompressed DirectColor packets.
X          */
X          x=0;
X          for (i=0; i < image->packets; i++)
X          {
X            for (j=0; j <= ((int) p->length); j++)
X            {
X              x++;
X              (void) fprintf(image->file,"%02x%02x%02x",p->red,p->green,
X                p->blue);
X              if (x == 12)
X                {
X                  x=0;
X                  (void) fprintf(image->file,"\n");
X                }
X            }
X            p++;
X          }
X          break;
X        }
X      }
X    }
X  else
X    {
X      (void) fprintf(image->file,"%d %d\n%u %u\n%u %u\n%d\n%d\n",x,y,width,
X        height,image->columns,image->rows,(image->class == PseudoClass),
X        image->compression == NoCompression);
X      /*
X        Dump number of colors and colormap.
X      */
X      (void) fprintf(image->file,"%u\n",image->colors);
X      for (i=0; i < image->colors; i++)
X        (void) fprintf(image->file,"%02x%02x%02x\n",image->colormap[i].red,
X          image->colormap[i].green,image->colormap[i].blue);
X      switch (image->compression)
X      {
X        case RunlengthEncodedCompression:
X        default:
X        {
X          register unsigned char
X            *q;
X
X          /*
X            Allocate pixel array.
X          */
X          number_packets=image->columns*image->rows;
X          pixels=(unsigned char *) malloc(number_packets*sizeof(unsigned char));
X          if (pixels == (unsigned char *) NULL)
X            {
X              Warning("memory allocation error",(char *) NULL);
X              return(False);
X            }
X          /*
X            Dump LZW encoded pixels.
X          */
X          q=pixels;
X          for (i=0; i < image->packets; i++)
X          {
X            for (j=0; j <= (int) p->length; j++)
X              *q++=(unsigned char) p->index;
X            p++;
X          }
X          (void) LZWEncodeFilter(image->file,pixels,number_packets);
X          (void) fprintf(image->file,">");
X          (void) free((char *) pixels);
X          break;
X        }
X        case NoCompression:
X        {
X          /*
X            Dump uncompressed PseudoColor packets.
X          */
X          x=0;
X          for (i=0; i < image->packets; i++)
X          {
X            for (j=0; j <= ((int) p->length); j++)
X            {
X              x++;
X              (void) fprintf(image->file,"%02x",p->index);
X              if (x == 36)
X                {
X                  x=0;
X                  (void) fprintf(image->file,"\n");
X                }
X            }
X            p++;
X          }
X          break;
X        }
X      }
X    }
X  (void) fprintf(image->file,"\n");
X  (void) fprintf(image->file,"%%%%EndData\n");
X  if (encapsulated)
X    (void) fprintf(image->file,"end\n");
X  (void) fprintf(image->file,"%%%%PageTrailer\n");
X  (void) fprintf(image->file,"%%%%Trailer\n");
X  (void) fprintf(image->file,"%%%%EOF\n");
X  CloseImage(image);
X  return(True);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   W r i t e R G B I m a g e                                                 %
%                                                                             %
SHAR_EOF
true || echo 'restore of ImageMagick/encode.c failed'
fi
echo 'End of ImageMagick part 35'
echo 'File ImageMagick/encode.c is continued in part 36'
echo 36 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
