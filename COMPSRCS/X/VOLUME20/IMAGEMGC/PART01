Newsgroups: comp.sources.x
From: cristy@eplrx7.es.duPont.com (Cristy)
Subject: v20i057:  imagemagic - X11 image processing and display, Part01/38
Message-ID: <csx-v20i057=imagemagic.125050@sparky.Sterling.COM>
X-Md4-Signature: 246ac3c004ad18b2be6a1860371e8f39
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Wed, 14 Jul 1993 17:52:04 GMT
Approved: chris@sterling.com

Submitted-by: cristy@eplrx7.es.duPont.com (Cristy)
Posting-number: Volume 20, Issue 57
Archive-name: imagemagic/part01
Environment: X11
Supersedes: imagemagic: Volume 13, Issue 17-37


 cristy@dupont.com

 ---

 Display

     Display is a machine architecture independent image
     processing and display program.  It can display an image on
     any workstation display running an X server.  Display first
     determines the hardware capabilities of the workstation.  If
     the number of unique colors in the image is less than or
     equal to the number the workstation can support, the image
     is displayed in an X window.  Otherwise the number of colors
     in the image is first reduced to match the color resolution
     of the workstation before it is displayed.

     This means that a continuous-tone 24 bits/pixel image can
     display on a 8 bit pseudo-color device or monochrome device.
     In most instances the reduced color image closely resembles
     the original.  Alternatively, a monochrome or pseudo-color
     image can display on a continuous-tone 24 bits/pixels
     device.


 Import

     Import reads an image from any visible window on an X server
     and outputs it as an image file.  You can capture a single
     window, the entire screen, or any rectangular portion of the
     screen.  You can use display (see display(1)) utility for
     redisplay, printing, editing, formatting, archiving, image
     processing, etc. of the captured image.

     The target window can be specified by id, name, or may be
     selected by clicking the mouse in the desired window.  If
     you press a button and then drag, a rectangle will form
     which expands and contracts as the mouse moves.  To save the
     portion of the screen  defined by the rectangle, just
     release the button.  The keyboard bell is rung once at the
     beginning of the screen capture and twice when it completes.


 Animate

     Animate displays a sequence of images on any workstation
     display running an X server.  Animate first determines the
     hardware capabilities of the workstation.  If the number of
     unique colors in an image is less than or equal to the
     number the workstation can support, the image is displayed
     in an X window.  Otherwise the number of colors in the image
     is first reduced to match the color resolution of the
     workstation before it is displayed.

     This means that a continuous-tone 24 bits/pixel image can
     display on a 8 bit pseudo-color device or monochrome device.
     In most instances the reduced color image closely resembles
     the original.  Alternatively, a monochrome or pseudo-color
     image sequence can display on a continuous-tone 24
     bits/pixels device.


 Montage

     Montage creates a composite image by combining several
     separate images.  The images are tiled on the composite
     image with the name of the image optionally appearing just
     below the individual tile.


 Mogrify

     Mogrify transforms an image or a sequence of images.  These
     transforms include image scaling, image rotation, color
     reduction, and others.  The transmogrified image overwrites
     the original image.


 Convert

     Convert converts an input file using one image format to an
     output file with a differing image format. By default, the
     image format is determined by it's magic number. To specify
     a particular image format, precede the filename with an
     image format name and a colon (i.e.  ps:image) or specify
     the image type as the filename suffix (i.e. image.ps).
     Specify file as - for standard input or output.  If file has
     the extension .Z, the file is decoded with uncompress.

     Convert recognizes the following image formats:

       Tag       Description
       ----------------------------------------------------
       ALPHA     Raw alpha bytes
       AVS       AVS X image file
       BMP       Microsoft Windows bitmap image file
       CMYK      Raw cyan, magenta, yellow, and black bytes
       EPS       Adobe Encapsulated Postscript
       FAX       Group 3
       GIF       Compuserve Graphics image file
       GRAY      Raw gray bytes
       JPEG
       MIFF      Machine Independant file format
       MTV
       PCX       ZSoft IBM PC Paintbrush file
       PICT      Apple Macintosh QuickDraw/PICT file
       PNM       Portable bitmap
       PS        Adobe PostScript file
       PS2       Adobe PostScript Level II file
       RGB       Raw red, green, and blue bytes
       RLE       Utah Raster Toolkit
       SUN       SUN raster
       TGA       Truevision Targa image file
       TEXT      raw text file;  read only
       TIFF      Tagged Image File Format
       VICAR
       VIFF      Khoros Visualization image file.
       X         select image from X server screen
       XC        constant image of X server background color
       XBM       X11 bitmap
       XWD       X11 window dump
       YUV       Raw Y, U, and V bytes


 Combine

     Combine combines images to create new images.


 Segment

     Segment segments an image by analyzing the histograms of the
     color components and identifying units that are homogeneous
     with the fuzzy c-means technique.  The scale-space filter
     analyzes the histograms of the three color components of the
     image and identifies a set of classes.  The extents of each
     class is used to coarsely segment the image with
     thresholding.  The color associated with each class is
     determined by the mean color of all pixels within the
     extents of a particular class.  Finally, any unclassified
     pixels are assigned to the closest class with the fuzzy c-
     means technique.


 XTP

     Xtp is a utility for retrieving, listing, or printing files
     from a remote network site, or sending files to a remote
     network site.  Xtp performs most of the same functions as
     the ftp program, but does not require any interactive
     commands.  You simply specify the file transfer task on the
     command line and xtp performs the task automatically.

#!/bin/sh
# This is ImageMagick, a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 07/07/1993 14:14 UTC by cristy@dupont.com
# Source directory /tmp_mnt/nfs/zeta/home/cristy/Archive/ImageMagick
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   2266 -rw-r--r-- ImageMagick/utilities/Imakefile
#  36611 -rw-r--r-- ImageMagick/utilities/mogrify.c
#   2959 -rw-r--r-- ImageMagick/utilities/Make.com
#   3074 -rw-r--r-- ImageMagick/utilities/Makefile
#  26574 -rw-r--r-- ImageMagick/utilities/convert.c
#  11344 -rw-r--r-- ImageMagick/utilities/convert.man
#  13912 -rw-r--r-- ImageMagick/utilities/mogrify.man
#  23690 -rw-r--r-- ImageMagick/utilities/combine.c
#  11289 -rw-r--r-- ImageMagick/utilities/combine.man
#  59822 -rw-r--r-- ImageMagick/utilities/segment.c
#   8572 -rw-r--r-- ImageMagick/utilities/segment.man
#   1512 -rw-r--r-- ImageMagick/xtp/Imakefile
#   1709 -rw-r--r-- ImageMagick/xtp/Makefile
#   1876 -rw-r--r-- ImageMagick/xtp/README
#    541 -rw-r--r-- ImageMagick/xtp/get
#   5583 -rw-r--r-- ImageMagick/xtp/network.c
#  36662 -rw-r--r-- ImageMagick/xtp/regular.c
#   1299 -rw-r--r-- ImageMagick/xtp/regular.h
#  41691 -rw-r--r-- ImageMagick/xtp/xtp.c
#    819 -rw-r--r-- ImageMagick/xtp/xtp.h
#   6440 -rw-r--r-- ImageMagick/xtp/xtp.man
#    354 -rw-r--r-- ImageMagick/images/README
#  10067 -rw-r--r-- ImageMagick/ChangeLog
#   2673 -rw-r--r-- ImageMagick/Imakefile
#   2134 -rw-r--r-- ImageMagick/Magick.tmpl
#   3648 -rw-r--r-- ImageMagick/Make.com
#   3027 -rw-r--r-- ImageMagick/Makefile
#   2670 -rw-r--r-- ImageMagick/Manifest.ps
#   5666 -rw-r--r-- ImageMagick/PreRvIcccm.c
#   1201 -rw-r--r-- ImageMagick/PreRvIcccm.h
#  12850 -rw-r--r-- ImageMagick/README
#   6075 -rw-r--r-- ImageMagick/SYNOPSIS
# 187033 -rw-r--r-- ImageMagick/X.c
#   5805 -rw-r--r-- ImageMagick/X.h
#   3092 -rw-r--r-- ImageMagick/XWDFile.h
#  11194 -rw-r--r-- ImageMagick/colors.c
#  35828 -rw-r--r-- ImageMagick/shear.c
# 230407 -rw-r--r-- ImageMagick/decode.c
#  73391 -rw-r--r-- ImageMagick/animate.c
#    485 -rw-r--r-- ImageMagick/animate.h
#  17246 -rw-r--r-- ImageMagick/animate.man
#   1328 -rw-r--r-- ImageMagick/display.h
#  68487 -rw-r--r-- ImageMagick/compress.c
#    784 -rw-r--r-- ImageMagick/compress.h
# 202798 -rw-r--r-- ImageMagick/display.c
#  32428 -rw-r--r-- ImageMagick/display.man
#  22346 -rw-r--r-- ImageMagick/import.c
# 119137 -rw-r--r-- ImageMagick/image.c
#   4822 -rw-r--r-- ImageMagick/image.h
#   8036 -rw-r--r-- ImageMagick/import.man
#  60193 -rw-r--r-- ImageMagick/quantize.c
#   9952 -rw-r--r-- ImageMagick/miff.man
#  56463 -rw-r--r-- ImageMagick/montage.c
#  19241 -rw-r--r-- ImageMagick/montage.man
#  21343 -rw-r--r-- ImageMagick/utility.c
#  11046 -rw-r--r-- ImageMagick/quantize.man
#    690 -rw-r--r-- ImageMagick/utility.h
#  17852 -rw-r--r-- ImageMagick/signature.c
# 175688 -rw-r--r-- ImageMagick/encode.c
#     22 -rw-r--r-- ImageMagick/patchlevel.h
#    281 -rw-r--r-- ImageMagick/scenes/Makefile
#    464 -rw-r--r-- ImageMagick/scenes/README
#  28655 -rw-r--r-- ImageMagick/scenes/dna.script
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= ImageMagick/utilities/Imakefile ==============
if test ! -d 'ImageMagick'; then
    echo 'x - creating directory ImageMagick'
    mkdir 'ImageMagick'
fi
if test ! -d 'ImageMagick/utilities'; then
    echo 'x - creating directory ImageMagick/utilities'
    mkdir 'ImageMagick/utilities'
fi
if test -f 'ImageMagick/utilities/Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/utilities/Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/utilities/Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/utilities/Imakefile' &&
#
#  Imakefile for ImageMagick image utilities.
#
#  Copyright 1992 E. I. du Pont de Nemours & Company
#
#  Permission to use, copy, modify, distribute, and sell this software and
#  its documentation for any purpose is hereby granted without fee,
#  provided that the above Copyright notice appear in all copies and that
#  both that Copyright notice and this permission notice appear in
#  supporting documentation, and that the name of E. I. du Pont de Nemours
#  & Company not be used in advertising or publicity pertaining to
#  distribution of the software without specific, written prior
#  permission.  E. I. du Pont de Nemours & Company makes no representations
#  about the suitability of this software for any purpose.  It is provided
#  "as is" without express or implied warranty.
#
#  E. I. du Pont de Nemours & Company disclaims all warranties with regard
#  to this software, including all implied warranties of merchantability
#  and fitness, in no event shall E. I. du Pont de Nemours & Company be
#  liable for any special, indirect or consequential damages or any
#  damages whatsoever resulting from loss of use, data or profits, whether
#  in an action of contract, negligence or other tortious action, arising
#  out of or in connection with the use or performance of this software.
#
X
#include "../Magick.tmpl"
X
EXTRA_INCLUDES= -I..
X
MagickObjects= ../X.o ../image.o ../shear.o ../quantize.o ../colors.o \
X  ../signature.o ../decode.o ../encode.o ../compress.o ../utility.o \
X  ../PreRvIcccm.o
X
COMBINEObjects= combine.o $(MagickObjects)
CONVERTObjects= convert.o $(MagickObjects)
MOGRIFYObjects= mogrify.o $(MagickObjects)
SEGMENTObjects= segment.o $(MagickObjects)
X
PROGRAMS= mogrify convert combine segment
X
AllTarget($(PROGRAMS))
X
NormalProgramTarget(mogrify,$(MOGRIFYObjects), , , )
InstallProgram(mogrify,$(LOCALDIR))
InstallManPage(mogrify,$(MANDIR))
NormalProgramTarget(convert,$(CONVERTObjects), , , )
InstallProgram(convert,$(LOCALDIR))
InstallManPage(convert,$(MANDIR))
NormalProgramTarget(combine,$(COMBINEObjects), , , )
InstallProgram(combine,$(LOCALDIR))
InstallManPage(combine,$(MANDIR))
NormalProgramTarget(segment,$(SEGMENTObjects), , , )
InstallProgram(segment,$(LOCALDIR))
InstallManPage(segment,$(MANDIR))
DependTarget()
SHAR_EOF
chmod 0644 ImageMagick/utilities/Imakefile ||
echo 'restore of ImageMagick/utilities/Imakefile failed'
Wc_c="`wc -c < 'ImageMagick/utilities/Imakefile'`"
test 2266 -eq "$Wc_c" ||
	echo 'ImageMagick/utilities/Imakefile: original size 2266, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/utilities/mogrify.c ==============
if test -f 'ImageMagick/utilities/mogrify.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/utilities/mogrify.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/utilities/mogrify.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/utilities/mogrify.c' &&
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%              M   M   OOO    GGGG  RRRR   IIIII  FFFFF  Y   Y                %
%              MM MM  O   O  G      R   R    I    F       Y Y                 %
%              M M M  O   O  G GG   RRRRR    I    FFF      Y                  %
%              M   M  O   O  G   G  R R      I    F        Y                  %
%              M   M   OOO    GGG   R  R   IIIII  F        Y                  %
%                                                                             %
%                                                                             %
%               Transmogrify an Image or Sequence of Images.                  %
%                                                                             %
%                                                                             %
%                                                                             %
%                           Software Design                                   %
%                             John Cristy                                     %
%                            December 1992                                    %
%                                                                             %
%                                                                             %
%  Copyright 1993 E. I. du Pont de Nemours & Company                          %
%                                                                             %
%  Permission to use, copy, modify, distribute, and sell this software and    %
%  its documentation for any purpose is hereby granted without fee,           %
%  provided that the above Copyright notice appear in all copies and that     %
%  both that Copyright notice and this permission notice appear in            %
%  supporting documentation, and that the name of E. I. du Pont de Nemours    %
%  & Company not be used in advertising or publicity pertaining to            %
%  distribution of the software without specific, written prior               %
%  permission.  E. I. du Pont de Nemours & Company makes no representations   %
%  about the suitability of this software for any purpose.  It is provided    %
%  "as is" without express or implied warranty.                               %
%                                                                             %
%  E. I. du Pont de Nemours & Company disclaims all warranties with regard    %
%  to this software, including all implied warranties of merchantability      %
%  and fitness, in no event shall E. I. du Pont de Nemours & Company be       %
%  liable for any special, indirect or consequential damages or any           %
%  damages whatsoever resulting from loss of use, data or profits, whether    %
%  in an action of contract, negligence or other tortious action, arising     %
%  out of or in connection with the use or performance of this software.      %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  `Mogrify' applies one or more image transforms to an image or sequence of
%   images and overwrites the original image.
%
%  The Mogrify program command syntax is:
%
%  Usage: mogrify [options ...] file [ [options ...] file ...]
%
%  Where options include:
%    -border geometry     surround image with a border of color
%    -clip geometry       preferred size and location of the clipped image
%    -colormap filename   transform image colors to match this set of colors
%    -colors value        preferred number of colors in the image
%    -colorspace type     GRAY, RGB, XYZ, YCbCr, YIQ, or YUV
%    -compress type       RunlengthEncoded or QEncoded
%    -density geometry    vertical and horizonal density of the image
%    -display server      obtain image or font from this X server
%    -dither              apply Floyd/Steinberg error diffusion to image
%    -enhance             apply a digital filter to enhance a noisy image
%    -font name           X11 font for displaying text
%    -gamma value         level of gamma correction
%    -geometry geometry   preferred size of the image
%    -interlace type      NONE, LINE, or PLANE
%    -inverse             apply color inversion to image
%    -monochrome          transform image to black and white
%    -noise               reduce noise with a noise peak elimination filter
%    -normalize           tranform image to span the full range of colors
%    -page geometry       size and location of the Postscript page
%    -quality value       JPEG quality setting
%    -reflect             reverse image scanlines
%    -roll geometry       roll an image vertically or horizontally
%    -rotate degrees      apply Paeth rotation to the image
%    -scale geometry      preferred size factors of the image
%    -scene value         image scene number
%    -shear geometry      slide one edge of the image along the X or Y axis
%    -treedepth value     depth of the color classification tree
%    -undercolor geometry control undercolor removal and black generation
%    -verbose             print detailed information about the image
%
%  Change '-' to '+' in any option above to reverse its effect.  For
%  example, specify +compress to store the image as uncompressed.
%
%  By default, the image format of `file' is determined by its magic
%  number.  To specify a particular image format, precede the filename
%  with an image format name and a colon (i.e. ps:image) or specify the
%  image type as the filename suffix (i.e. image.ps).  Specify 'file' as
%  '-' for standard input or output.
%
%
*/
X
/*
X  Include declarations.
*/
#include "display.h"
#include "image.h"
#include "X.h"
X
/*
X  Global declarations.
*/
char
X  *client_name;
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   E r r o r                                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function Error displays an error message and then terminates the program.
%
%  The format of the Error routine is:
%
%      Error(message,qualifier)
%
%  A description of each parameter follows:
%
%    o message: Specifies the message to display before terminating the
%      program.
%
%    o qualifier: Specifies any qualifier to the message.
%
%
*/
void Error(message,qualifier)
char
X  *message,
X  *qualifier;
{
X  (void) fprintf(stderr,"%s: %s",client_name,message);
X  if (qualifier != (char *) NULL)
X    (void) fprintf(stderr," (%s)",qualifier);
X  (void) fprintf(stderr,".\n");
X  exit(1);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   U s a g e                                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function Usage displays the program command syntax.
%
%  The format of the Usage routine is:
%
%      Usage()
%
%
*/
static void Usage()
{
X  char
X    **p;
X
X  static char
X    *options[]=
X    {
X      "-border geometry     surround image with a border of color",
X      "-clip geometry       preferred size and location of the clipped image",
X      "-colormap filename   transform image colors to match this set of colors",
X      "-colors value        preferred number of colors in the image",
X      "-colorspace type     GRAY, RGB, XYZ, YCbCr, YIQ, or YUV",
X      "-compress type       RunlengthEncoded or QEncoded",
X      "-density geometry    vertical and horizonal density of the image",
X      "-display server      obtain image or font from this X server",
X      "-dither              apply Floyd/Steinberg error diffusion to image",
X      "-enhance             apply a digital filter to enhance a noisy image",
X      "-font name           X11 font for displaying text",
X      "-gamma value         level of gamma correction",
X      "-geometry geometry   preferred size of the image",
X      "-interlace type      NONE, LINE, or PLANE",
X      "-inverse             apply color inversion to image",
X      "-monochrome          transform image to black and white",
X      "-noise               reduce noise with a noise peak elimination filter",
X      "-normalize           tranform image to span the full range of colors",
X      "-page geometry       size and location of the Postscript page",
X      "-quality value       JPEG quality setting",
X      "-reflect             reflect the image scanlines",
X      "-roll geometry       roll an image vertically or horizontally",
X      "-rotate degrees      apply Paeth rotation to the image",
X      "-scale geometry      preferred size factors of the image",
X      "-scene number        image scene number",
X      "-shear geometry      slide one edge of the image along the X or Y axis",
X      "-treedepth value     depth of the color classification tree",
X      "-undercolor geometry control undercolor removal and black generation",
X      "-verbose             print detailed information about the image",
X      (char *) NULL
X    };
X  (void) fprintf(stderr,
X    "Usage: %s [-options ...] file [ [-options ...] file ...]\n",client_name);
X  (void) fprintf(stderr,"\nWhere options include: \n");
X  for (p=options; *p != (char *) NULL; p++)
X    (void) fprintf(stderr,"  %s\n",*p);
X  (void) fprintf(stderr,
X    "\nChange '-' to '+' in any option above to reverse its effect.  For\n");
X  (void) fprintf(stderr,
X    "example, specify +compress to store the image as uncompressed.\n");
X  (void) fprintf(stderr,
X    "\nBy default, the image format of `file' is determined by its magic\n");
X  (void) fprintf(stderr,
X    "number.  To specify a particular image format, precede the filename\n");
X  (void) fprintf(stderr,
X    "with an image format name and a colon (i.e. ps:image) or specify the\n");
X  (void) fprintf(stderr,
X    "image type as the filename suffix (i.e. image.ps).  Specify 'file' as\n");
X  (void) fprintf(stderr,"'-' for standard input or output.\n");
X  exit(1);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%    M a i n                                                                  %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
*/
int main(argc,argv)
int
X  argc;
X
char
X  **argv;
{
X  char
X    *border_color,
X    *border_geometry,
X    *clip_geometry,
X    *colormap_filename,
X    *density,
X    *font,
X    *image_geometry,
X    *option,
X    *page_geometry,
X    *roll_geometry,
X    *scale_geometry,
X    *server_name,
X    *shear_geometry,
X    *undercolor_geometry;
X
X  double
X    gamma;
X
X  Image
X    **images;
X
X  ImageInfo
X    image_info;
X
X  int
X    degrees,
X    flags,
X    i,
X    x,
X    y;
X         
X  unsigned int
X    colorspace,
X    compression,
X    dither,
X    enhance,
X    height,
X    image_number,
X    interlace,
X    inverse,
X    maximum_images,
X    monochrome,
X    noise,
X    normalize,
X    number_colors,
X    quality,
X    reflect,
X    scene,
X    tree_depth,
X    verbose,
X    width;
X
X  /*
X    Display usage profile if there are no command line arguments.
X  */
X  client_name=(*argv);
X  if (argc < 2)
X    Usage();
X  /*
X    Set defaults.
X  */
X  border_color=(char *) NULL;
X  border_geometry=(char *) NULL;
X  clip_geometry=(char *) NULL;
X  colormap_filename=(char *) NULL;
X  colorspace=RGBColorspace;
X  compression=UndefinedCompression;
X  degrees=0;
X  density=(char *) NULL;
X  dither=False;
X  enhance=False;
X  font=(char *) NULL;
X  gamma=0.0;
X  image_geometry=(char *) NULL;
X  interlace=NoneInterlace;
X  inverse=False;
X  monochrome=False;
X  noise=False;
X  normalize=False;
X  number_colors=0;
X  quality=75;
X  page_geometry=(char *) NULL;
X  reflect=False;
X  roll_geometry=(char *) NULL;
X  scale_geometry=(char *) NULL;
X  server_name=(char *) NULL;
X  shear_geometry=(char *) NULL;
X  scene=0;
X  tree_depth=0;
X  undercolor_geometry=(char *) NULL;
X  verbose=False;
X  maximum_images=2048;
X  images=(Image **) malloc(maximum_images*sizeof(Image *));
X  if (images == (Image **) NULL)
X    Error("unable to mogrify images","memory allocation failed");
X  /*
X    Parse command line.
X  */
X  image_number=0;
X  for (i=1; i < argc; i++)
X  {
X    option=argv[i];
X    if (((int) strlen(option) > 1) && ((*option == '-') || (*option == '+')))
X      switch (*(option+1))
X      {
X        case 'b':
X        {
X          if (strncmp("border",option+1,7) == 0)
X            {
X              border_geometry=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing geometry on -border",(char *) NULL);
X                  border_geometry=argv[i];
X                }
X              break;
X            }
X          if (strncmp("bordercolor",option+1,7) == 0)
X            {
X              border_color=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing color on -bordercolor",(char *) NULL);
X                  border_color=argv[i];
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'c':
X        {
X          if (strncmp("clip",option+1,2) == 0)
X            {
X              clip_geometry=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing geometry on -clip",(char *) NULL);
X                  clip_geometry=argv[i];
X                }
X              break;
X            }
X          if (strncmp("colormap",option+1,7) == 0)
X            {
X              colormap_filename=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing file name on -colormap",(char *) NULL);
X                  colormap_filename=argv[i];
X                }
X              break;
X            }
X          if (strncmp("colors",option+1,7) == 0)
X            {
X              number_colors=0;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                    Error("missing colors on -colors",(char *) NULL);
X                  number_colors=atoi(argv[i]);
X                }
X              break;
X            }
X          if (strncmp("colorspace",option+1,7) == 0)
X            {
X              colorspace=RGBColorspace;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing type on -colorspace",(char *) NULL);
X                  option=argv[i];
X                  colorspace=UndefinedColorspace;
X                  if (Latin1Compare("gray",option) == 0)
X                    colorspace=GRAYColorspace;
X                  if (Latin1Compare("rgb",option) == 0)
X                    colorspace=RGBColorspace;
X                  if (Latin1Compare("xyz",option) == 0)
X                    colorspace=XYZColorspace;
X                  if (Latin1Compare("ycbcr",option) == 0)
X                    colorspace=YCbCrColorspace;
X                  if (Latin1Compare("yiq",option) == 0)
X                    colorspace=YIQColorspace;
X                  if (Latin1Compare("yuv",option) == 0)
X                    colorspace=YUVColorspace;
X                  if (colorspace == UndefinedColorspace)
X                    Error("invalid colorspace type on -colorspace",option);
X                }
X              break;
X            }
X          if (strncmp("compress",option+1,3) == 0)
X            {
X              compression=NoCompression;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing type on -compress",(char *) NULL);
X                  option=argv[i];
X                  if (Latin1Compare("runlengthencoded",option) == 0)
X                    compression=RunlengthEncodedCompression;
X                  else
X                    if (Latin1Compare("qencoded",option) == 0)
X                      compression=QEncodedCompression;
X                    else
X                      Error("invalid compression type on -compress",option);
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'd':
X        {
X          if (strncmp("density",option+1,3) == 0)
X            {
X              density=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing geometry on -density",(char *) NULL);
X                  density=argv[i];
X                }
X              break;
X            }
X          if (strncmp("display",option+1,3) == 0)
X            {
X              server_name=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing server name on -display",(char *) NULL);
X                  server_name=argv[i];
X                }
X              break;
X            }
X          if (strncmp("dither",option+1,3) == 0)
X            {
X              dither=(*option == '-');
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'e':
X        {
X          enhance=(*option == '-');
X          break;
X        }
X        case 'f':
X        {
X          font=(char *) NULL;
X          if (*option == '-')
X            {
X              i++;
X              if (i == argc)
X                Error("missing font name on -font",(char *) NULL);
X              font=argv[i];
X            }
X          break;
X        }
X        case 'g':
X        {
X          if (strncmp("gamma",option+1,2) == 0)
X            {
X              gamma=0.0;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%f",(float *) &x))
X                    Error("missing gamma on -gamma",(char *) NULL);
X                  gamma=atof(argv[i]);
X                }
X              break;
X            }
X          if (strncmp("geometry",option+1,2) == 0)
X            {
X              image_geometry=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing geometry on -geometry",(char *) NULL);
X                  image_geometry=argv[i];
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'h':
X        {
X          if (strncmp("help",option+1,2) == 0)
X            {
X              Usage();
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'i':
X        {
X          if (strncmp("interlace",option+1,3) == 0)
X            {
X              interlace=NoneInterlace;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing type on -interlace",(char *) NULL);
X                  option=argv[i];
X                  interlace=UndefinedInterlace;
X                  if (Latin1Compare("none",option) == 0)
X                    interlace=NoneInterlace;
X                  if (Latin1Compare("line",option) == 0)
X                    interlace=LineInterlace;
X                  if (Latin1Compare("plane",option) == 0)
X                    interlace=PlaneInterlace;
X                  if (interlace == UndefinedInterlace)
X                    Error("invalid interlace type on -interlace",option);
X                }
X              break;
X            }
X          if (strncmp("inverse",option+1,3) == 0)
X            {
X              inverse=(*option == '-');
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'm':
X        {
X          monochrome=(*option == '-');
X          break;
X        }
X        case 'n':
X        {
X          if (strncmp("noise",option+1,3) == 0)
X            {
X              noise=(*option == '-');
X              break;
X            }
X          if (strncmp("normalize",option+1,3) == 0)
X            {
X              normalize=(*option == '-');
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'p':
X        {
X          if (strncmp("page",option+1,2) == 0)
X            {
X              page_geometry=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing page geometry on -page",(char *) NULL);
X                  page_geometry=argv[i];
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'q':
X        {
X          i++;
X          if ((i == argc) || !sscanf(argv[i],"%d",&x))
X            Error("missing quality on -quality",(char *) NULL);
X          quality=atoi(argv[i]);;
X          break;
X        }
X        case 'r':
X        {
X          if (strncmp("reflect",option+1,2) == 0)
X            {
X              reflect=(*option == '-');
X              break;
X            }
X          if (strncmp("roll",option+1,3) == 0)
X            {
X              roll_geometry=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if (i == argc)
X                    Error("missing geometry on -roll",(char *) NULL);
X                  roll_geometry=argv[i];
X                }
X              break;
X            }
X          if (strncmp("rotate",option+1,3) == 0)
X            {
X              degrees=0;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                    Error("missing degrees on -rotate",(char *) NULL);
X                  degrees=atoi(argv[i]);
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 's':
X        {
X          if (strncmp("scale",option+1,3) == 0)
X            {
X              scale_geometry=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%f",(float *) &x))
X                    Error("missing scale geometry on -scale",(char *) NULL);
X                  scale_geometry=argv[i];
X                }
X              break;
X            }
X          if (strncmp("scene",option+1,3) == 0)
X            {
X              scene=0;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                    Error("missing scene number on -scene",(char *) NULL);
X                  scene=atoi(argv[i]);
X                }
X              break;
X            }
X          if (strncmp("shear",option+1,2) == 0)
X            {
X              shear_geometry=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%f",(float *) &x))
X                    Error("missing shear geometry on -shear",(char *) NULL);
X                  shear_geometry=argv[i];
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 't':
X        {
X          tree_depth=0;
X          if (*option == '-')
X            {
X              i++;
X              if ((i == argc) || !sscanf(argv[i],"%d",&x))
X                Error("missing depth on -treedepth",(char *) NULL);
X              tree_depth=atoi(argv[i]);
X            }
X          break;
X        }
X        case 'u':
X        {
X          if (strncmp("undercolor",option+1,2) == 0)
X            {
X              undercolor_geometry=(char *) NULL;
X              if (*option == '-')
X                {
X                  i++;
X                  if ((i == argc) || !sscanf(argv[i],"%f",(float *) &x))
X                    Error("missing undercolor geometry on -undercolor",
X                      (char *) NULL);
X                  undercolor_geometry=argv[i];
X                }
X              break;
X            }
X          Error("unrecognized option",option);
X          break;
X        }
X        case 'v':
X        {
X          verbose=(*option == '-');
X          break;
X        }
X        default:
X        {
X          Error("unrecognized option",option);
X          break;
X        }
X      }
X    else
X      {
X        double
X          normalized_maximum_error,
X          normalized_mean_error;
X
X        Image
X          *image,
X          info_image,
X          *next_image;
X
X        time_t
X          start_time;
X
X        unsigned int
X          mean_error_per_pixel;
X
X        unsigned long
X          total_colors;
X
X        /*
X          Option is a file name: begin by reading image from specified file.
X        */
X        start_time=time((time_t *) NULL);
X        GetImageInfo(&image_info);
X        (void) strcpy(image_info.filename,option);
X        image_info.server_name=server_name;
X        image_info.font=font;
X        image_info.geometry=image_geometry;
X        image_info.page=page_geometry;
X        image_info.density=density;
X        image_info.border_color=border_color;
X        image_info.interlace=interlace;
X        image_info.monochrome=monochrome;
X        image_info.quality=quality;
X        image_info.verbose=verbose;
X        image_info.undercolor=undercolor_geometry;
X        image=ReadImage(&image_info);
X        if (image == (Image *) NULL)
X          if (*option == '-')
X            break;
X          else
X            continue;
X        do
X        {
X          info_image=(*image);
X          if (scene != 0)
X            image->scene=scene;
X          total_colors=0;
X          /*
X            Transform image as defined by the clip, image and scale geometries.
X          */
X          TransformImage(&image,clip_geometry,image_geometry,scale_geometry);
X          if (reflect)
X            {
X              Image
X                *reflected_image;
X
X              /*
X                Reverse image scanlines.
X              */
X              reflected_image=ReflectImage(image);
X              if (reflected_image != (Image *) NULL)
X                {
X                  DestroyImage(image);
X                  image=reflected_image;
X                }
X            }
X          if (roll_geometry != (char *) NULL)
X            {
X              Image
X                *rolled_image;
X
X              /*
X                Roll image.
X              */
X              x=0;
X              y=0;
X              flags=XParseGeometry(roll_geometry,&x,&y,&width,&height);
X              rolled_image=RollImage(image,x,y);
X              if (rolled_image != (Image *) NULL)
X                {
X                  DestroyImage(image);
X                  image=rolled_image;
X                }
X            }
X          if (border_geometry != (char *) NULL)
X            {
X              Image
X                *bordered_image;
X
X              ImageInfo
X                border_info;
X
X              /*
X                Surround image with a border of solid color.
X              */
X              border_info=image_info;
X              (void) strcpy(border_info.filename,"XC:border");
X              border_info.geometry="1x1";
X              bordered_image=ReadImage(&border_info);
X              if (bordered_image != (Image *) NULL)
X                {
X                  ColorPacket
X                    border_color;
X
X                  RectangleInfo
X                    border_info;
X
X                  DestroyImage(bordered_image);
X                  border_info.width=0;
X                  border_info.height=0;
X                  border_info.x=0;
X                  border_info.y=0;
X                  flags=XParseGeometry(border_geometry,&border_info.x,
X                    &border_info.y,&border_info.width,&border_info.height);
X                  if ((flags & HeightValue) == 0)
X                    border_info.height=border_info.width;
X                  border_color.red=bordered_image->pixels->red;
X                  border_color.green=bordered_image->pixels->green;
X                  border_color.blue=bordered_image->pixels->blue;
X                  bordered_image=BorderImage(image,&border_info,&border_color,
X                    &border_color);
X                  if (bordered_image != (Image *) NULL)
X                    {
X                      DestroyImage(image);
X                      bordered_image->class=DirectClass;
X                      image=bordered_image;
X                    }
X                }
X            }
X          if (shear_geometry != (char *) NULL)
X            {
X              float
X                x_shear,
X                y_shear;
X
X              Image
X                *sheared_image;
X
X              /*
X                Shear image.
X              */
X              x_shear=0.0;
X              y_shear=0.0;
X              (void) sscanf(shear_geometry,"%fx%f",&x_shear,&y_shear);
X              sheared_image=ShearImage(image,x_shear,y_shear,False);
X              if (sheared_image != (Image *) NULL)
X                {
X                  DestroyImage(image);
X                  image=sheared_image;
X                }
X            }
X          if ((degrees % 360) != 0)
X            {
X              Image
X                *rotated_image;
X
X              /*
X                Rotate image.
X              */
X              rotated_image=RotateImage(image,(double) degrees,False);
X              if (rotated_image != (Image *) NULL)
X                {
X                  DestroyImage(image);
X                  image=rotated_image;
X                }
X            }
X          if (enhance)
X            {
X              Image
X                *enhanced_image;
X
X              /*
X                Enhance image.
X              */
X              enhanced_image=EnhanceImage(image);
X              if (enhanced_image != (Image *) NULL)
X                {
X                  DestroyImage(image);
X                  image=enhanced_image;
X                }
X            }
X          if (noise)
X            {
X              Image
X                *noisy_image;
X
X              /*
X                Reduce noise in image.
X              */
X              noisy_image=NoisyImage(image);
X              if (noisy_image != (Image *) NULL)
X                {
X                  DestroyImage(image);
X                  image=noisy_image;
X                }
X            }
X          if (gamma > 0.0)
X            GammaImage(image,gamma);
X          if (inverse)
X            InverseImage(image);
X          if (normalize)
X            NormalizeImage(image);
X          if (colorspace == GRAYColorspace)
X            QuantizeImage(image,256,8,dither,GRAYColorspace,True);
X          if (monochrome)
X            QuantizeImage(image,2,8,dither,GRAYColorspace,True);
X          if (number_colors != 0)
X            if ((image->class == DirectClass) ||
X                (image->colors > number_colors))
X              {
X                /*
X                  Reduce the number of colors in the image.
X                */
X                QuantizeImage(image,number_colors,tree_depth,dither,colorspace,
X                  True);
X                if (verbose)
X                  {
X                    /*
X                      Measure quantization error.
X                    */
X                    QuantizationError(image,&mean_error_per_pixel,
X                      &normalized_mean_error,&normalized_maximum_error);
X                    total_colors=NumberColors(image,(FILE *) NULL);
X                  }
X                SyncImage(image);
X              }
X          if (verbose)
X            {
X              /*
X                Display detailed info about the image.
X              */
X              (void) fprintf(stderr,"[%u] %s",
X                image->scene == 0 ? image_number : image->scene,
X                info_image.filename);
X              (void) fprintf(stderr," %ux%u",info_image.columns,
X                info_image.rows);
X              if ((info_image.columns != image->columns) ||
X                  (info_image.rows != image->rows))
X                (void) fprintf(stderr,"=>%ux%u",image->columns,image->rows);
X              if (image->class == DirectClass)
X                (void) fprintf(stderr," DirectClass");
X              else
X                if (total_colors == 0)
X                  (void) fprintf(stderr," PseudoClass %uc",image->colors);
X                else
X                  {
X                    (void) fprintf(stderr," PseudoClass %lu=>%uc",total_colors,
X                      image->colors);
X                    (void) fprintf(stderr," %u/%.6f/%.6fe",mean_error_per_pixel,
X                      normalized_mean_error,normalized_maximum_error);
X                  }
X              (void) fprintf(stderr," %s %lds\n",image->magick,
X                time((time_t *) NULL)-start_time+1);
X            }
X          if (compression != UndefinedCompression)
X            image->compression=compression;
X          else
X            image->compression=info_image.compression;
X          (void) strcpy(image->filename,option);
X          if (number_colors == 0)
X            (void) WriteImage(&image_info,image);
X          if (image_number == maximum_images)
X            {
X              /*
X                Increase size of images array.
X              */
X              maximum_images<<=1;
X              images=(Image **)
X                realloc((char *) images,maximum_images*sizeof(Image *));
X              if (images == (Image **) NULL)
X                Error("unable to mogrify images","memory allocation failed");
X            }
X          images[image_number++]=image;
X          next_image=image->next;
X          if (next_image != (Image *) NULL)
X            image=next_image;
X        } while (next_image != (Image *) NULL);
X        if (number_colors == 0)
X          DestroyImages(image);
X      }
X    }
X  if (image_number == 0)
X    Error("missing an image file name",(char *) NULL);
X  if (number_colors != 0)
X    {
X      Image
X        *colormap_image;
X
X      /*
X        Global colormap option;  reduce colors then write image.
X      */
X      colormap_image=(Image *) NULL;
X      if (colormap_filename != (char *) NULL)
X        {
X          (void) strcpy(image_info.filename,colormap_filename);
X          colormap_image=ReadImage(&image_info);
X          if (colormap_image == (Image *) NULL)
X            Error("unable to mogrify images","cannot read image colormap");
X        }
X      maximum_images=image_number;
X      QuantizeImages(images,maximum_images,colormap_image,number_colors,
X        tree_depth,dither,colorspace,True);
X      if (colormap_image != (Image *) NULL)
X        DestroyImage(colormap_image);
X      for (image_number=0; image_number < maximum_images; image_number++)
X      {
X        (void) WriteImage(&image_info,images[image_number]);
X        DestroyImage(images[image_number]);
X      }
X    }
X  (void) free((char *) images);
X  return(False);
}
SHAR_EOF
chmod 0644 ImageMagick/utilities/mogrify.c ||
echo 'restore of ImageMagick/utilities/mogrify.c failed'
Wc_c="`wc -c < 'ImageMagick/utilities/mogrify.c'`"
test 36611 -eq "$Wc_c" ||
	echo 'ImageMagick/utilities/mogrify.c: original size 36611, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/utilities/Make.com ==============
if test -f 'ImageMagick/utilities/Make.com' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/utilities/Make.com (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/utilities/Make.com (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/utilities/Make.com' &&
$!
$! Make ImageMagick X image utilities for VMS.
$!
$
$define/nolog X11 decw$include:
$define/nolog sys sys$library:
$link_options="/nodebug/notraceback"
$define/nolog lnk$library sys$library:vaxcrtl
$
$if ((p1.nes."").and.(p1.nes."mogrify")) then goto SkipMogrify
$write sys$output "Making Mogrify..."
$call Make mogrify
$
$link'link_options' mogrify,[-]X,[-]image,[-]shear,[-]quantize,[-]colors, -
X  [-]signature,[-]decode,[-]encode,[-]compress,[-]utility,[-]PreRvIcccm, -
X  sys$input:/opt
sys$share:decw$xlibshr.exe/share
$
$mogrify:==$'f$environment("default")'mogrify
$write sys$output "..symbol MOGRIFY defined."
$
$SkipMogrify:
$if ((p1.nes."").and.(p1.nes."convert")) then goto SkipConvert
$write sys$output "Making Convert..."
$call Make convert
$
$link'link_options' convert,[-]X,[-]image,[-]shear,[-]quantize,[-]colors, -
X  [-]signature,[-]decode,[-]encode,[-]compress,[-]utility,[-]PreRvIcccm, -
X  sys$input:/opt
sys$share:decw$xlibshr.exe/share
$
$convert:==$'f$environment("default")'convert
$write sys$output "..symbol CONVERT defined."
$SkipConvert:
$if ((p1.nes."").and.(p1.nes."combine")) then goto SkipCombine
$write sys$output "Making Combine..."
$call Make combine
$
$link'link_options' combine,[-]X,[-]image,[-]shear,[-]quantize,[-]colors, -
X  [-]signature,[-]decode,[-]encode,[-]compress,[-]utility,[-]PreRvIcccm, -
X  sys$input:/opt
sys$share:decw$xlibshr.exe/share
$
$combine:==$'f$environment("default")'combine
$write sys$output "..symbol COMBINE defined."
$SkipCombine:
$if ((p1.nes."").and.(p1.nes."segment")) then goto SkipSegment
$write sys$output "Making Segment..."
$call Make segment
$
$link'link_options' segment,[-]X,[-]image,[-]shear,[-]quantize,[-]colors, -
X  [-]signature,[-]decode,[-]encode,[-]compress,[-]utility,[-]PreRvIcccm, -
X  sys$input:/opt
sys$share:decw$xlibshr.exe/share
$
$segment:==$'f$environment("default")'segment
$write sys$output "..symbol SEGMENT defined."
$SkipSegment:
$type sys$input
X
Use this command to specify which X server to contact:
X
X  $set display/create/node=node_name::
X
This can be done automatically from your LOGIN.COM with the following 
command:
X
X  $if (f$trnlmn("sys$rem_node").nes."") then -
X  $  set display/create/node='f$trnlmn("sys$rem_node")'
$exit
$
$Make: subroutine
$!
$! A very primitive "make" (or MMS) hack for DCL.
$!
$if (p1.eqs."") then exit
$source_file=f$search(f$parse(p1,".c"))
$if (source_file.nes."")
$  then
$    object_file=f$parse(source_file,,,"name")+".obj"
$    object_file=f$search( object_file )
$    if (object_file.nes."") 
$      then
$        object_time=f$file_attribute(object_file,"cdt")
$        source_time=f$file_attribute(source_file,"cdt")
$        if (f$cvtime(object_time).lts.f$cvtime(source_time)) then -
$          object_file=""
$      endif
$    if (object_file.eqs."") 
$      then
$        write sys$output "Compiling ",p1
$        cc/nodebug/optimize/include_directory=[-] 'source_file'
$      endif
$  endif
$exit
$endsubroutine
X
SHAR_EOF
chmod 0644 ImageMagick/utilities/Make.com ||
echo 'restore of ImageMagick/utilities/Make.com failed'
Wc_c="`wc -c < 'ImageMagick/utilities/Make.com'`"
test 2959 -eq "$Wc_c" ||
	echo 'ImageMagick/utilities/Make.com: original size 2959, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/utilities/Makefile ==============
if test -f 'ImageMagick/utilities/Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/utilities/Makefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/utilities/Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/utilities/Makefile' &&
#
#  Generic makefile for convert, mogrify, and combine for computers that
#  do not have xmkmf.
#
#  Copyright 1993 E. I. du Pont de Nemours & Company
#
#  Permission to use, copy, modify, distribute, and sell this software and
#  its documentation for any purpose is hereby granted without fee,
#  provided that the above Copyright notice appear in all copies and that
#  both that Copyright notice and this permission notice appear in
#  supporting documentation, and that the name of E. I. du Pont de Nemours
#  & Company not be used in advertising or publicity pertaining to
#  distribution of the software without specific, written prior
#  permission.  E. I. du Pont de Nemours & Company makes no representations
#  about the suitability of this software for any purpose.  It is provided
#  "as is" without express or implied warranty.
#
#  E. I. du Pont de Nemours & Company disclaims all warranties with regard
#  to this software, including all implied warranties of merchantability
#  and fitness, in no event shall E. I. du Pont de Nemours & Company be
#  liable for any special, indirect or consequential damages or any
#  damages whatsoever resulting from loss of use, data or profits, whether
#  in an action of contract, negligence or other tortious action, arising
#  out of or in connection with the use or performance of this software.
#
X
#
# Uncomment the following lines if you have the JPEG or TIFF libraries.
# See README for more details.
#
#TOP= ..
#JPEG_DEFINES= -DHasJPEG
#JPEG_INCLUDES= -I$(TOP)/jpeg
SHAR_EOF
true || echo 'restore of ImageMagick/utilities/Makefile failed'
fi
echo 'End of ImageMagick part 1'
echo 'File ImageMagick/utilities/Makefile is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
