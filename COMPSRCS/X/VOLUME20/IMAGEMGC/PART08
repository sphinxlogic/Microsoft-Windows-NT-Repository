Newsgroups: comp.sources.x
From: cristy@eplrx7.es.duPont.com (Cristy)
Subject: v20i064:  imagemagic - X11 image processing and display, Part08/38
Message-ID: <1993Jul14.175432.1069@sparky.sterling.com>
X-Md4-Signature: b2d0e0a673bc378c63c4c75fc48c894c
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Wed, 14 Jul 1993 17:54:32 GMT
Approved: chris@sterling.com

Submitted-by: cristy@eplrx7.es.duPont.com (Cristy)
Posting-number: Volume 20, Issue 64
Archive-name: imagemagic/part08
Environment: X11
Supersedes: imagemagic: Volume 13, Issue 17-37

#!/bin/sh
# this is magick.08 (part 8 of ImageMagick)
# do not concatenate these parts, unpack them in order with /bin/sh
# file ImageMagick/Manifest.ps continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 8; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping ImageMagick/Manifest.ps'
else
echo 'x - continuing file ImageMagick/Manifest.ps'
sed 's/^X//' << 'SHAR_EOF' >> 'ImageMagick/Manifest.ps' &&
{gsave 86.0 exch lineto stroke grestore} forall
showpage
SHAR_EOF
echo 'File ImageMagick/Manifest.ps is complete' &&
chmod 0644 ImageMagick/Manifest.ps ||
echo 'restore of ImageMagick/Manifest.ps failed'
Wc_c="`wc -c < 'ImageMagick/Manifest.ps'`"
test 2670 -eq "$Wc_c" ||
	echo 'ImageMagick/Manifest.ps: original size 2670, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/PreRvIcccm.c ==============
if test -f 'ImageMagick/PreRvIcccm.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/PreRvIcccm.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/PreRvIcccm.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/PreRvIcccm.c' &&
#include "display.h"
#include "image.h"
#include "X.h"
X
#ifdef PRE_R5_ICCCM
/*
X  Compatibility routines for pre X11R5 ICCCM.
*/
XXrmDatabase XrmGetDatabase(display)
Display
X  *display;
{
X  return(display->db);
}
#endif
X
#ifdef PRE_R4_ICCCM
/*
X  Compatibility routines for pre X11R4 ICCCM.
*/
XXClassHint *XAllocClassHint()
{
X  return((XClassHint *) malloc(sizeof(XClassHint)));
}
X
XXIconSize *XAllocIconSize()
{
X  return((XIconSize *) malloc(sizeof(XIconSize)));
}
X
XXSizeHints *XAllocSizeHints()
{
X  return((XSizeHints *) malloc(sizeof(XSizeHints)));
}
X
Status XReconfigureWMWindow(display,window,screen_number,value_mask,values)
Display
X  *display;
X
Window
X  window;
X
int
X  screen_number;
X
unsigned int
X  value_mask;
X
XXWindowChanges
X  *values;
{
X  return(XConfigureWindow(display,window,value_mask,values));
}
X
XXStandardColormap *XAllocStandardColormap()
{
X  return((XStandardColormap *) malloc(sizeof(XStandardColormap)));
}
X
XXWMHints *XAllocWMHints()
{
X  return((XWMHints *) malloc(sizeof(XWMHints)));
}
X
Status XGetRGBColormaps(display,window,colormap,count,property)
Display
X  *display;
X
Window
X  window;
X
XXStandardColormap
X  **colormap;
X
int
X  *count;
X
Atom
X  property;
{
X  *count=1;
X  return(XGetStandardColormap(display,window,colormap,property));
}
X
Status XGetWMColormapWindows(display,window,colormap_windows,number_windows)
Display
X  *display;
X
Window
X  window,
X  **colormap_windows;
X
int
X  *number_windows;
{
X  Atom
X    actual_type,
X    *data,
X    property;
X
X  int
X    actual_format,
X    status;
X
X  unsigned long
X    leftover,
X    number_items;
X
X  property=XInternAtom(display,"WM_COLORMAP_WINDOWS",False);
X  if (property == None)
X    return(False);
X  /*
X    Get the window property.
X  */
X  *data=(Atom) NULL;
X  status=XGetWindowProperty(display,window,property,0L,1000000L,False,
X    XA_WINDOW,&actual_type,&actual_format,&number_items,&leftover,
X    (unsigned char **) &data);
X  if (status != Success)
X    return(False);
X  if ((actual_type != XA_WINDOW) || (actual_format != 32))
X    {
X      if (data != (Atom *) NULL)
X        Xfree((char *) data);
X      return(False);
X    }
X  *colormap_windows=(Window *) data;
X  *number_windows=(int) number_items;
X  return(True);
}
X
Status XGetWMName(display,window,text_property)
Display
X  *display;
X
Window
X  window;
X
XXTextProperty
X  *text_property;
{
X  char
X    *window_name;
X
X  if (XFetchName(display,window,&window_name) == 0)
X    return(False);
X  text_property->value=(unsigned char *) window_name;
X  text_property->encoding=XA_STRING;
X  text_property->format=8;
X  text_property->nitems=strlen(window_name);
X  return(True);
}
X
char *XResourceManagerString(display)
Display
X  *display;
{
X  return display->xdefaults;
}
X
void XrmDestroyDatabase(database)
XXrmDatabase
X  database;
{
}
X
int XSetWMName(display,window,property)
Display
X  *display;
X
Window
X  window;
X
XXTextProperty
X  *property;
{
X  XStoreName(display,window,property->value);
}
X
int XStringListToTextProperty(argv,argc,property)
char
X  **argv;
X
int
X  argc;
X
XXTextProperty
X  *property;
{
X  register int
X    i;
X
X  register unsigned int
X    number_bytes;
X
X  XTextProperty
X     protocol;
X
X  number_bytes=0;
X  for (i=0; i < argc; i++)
X    number_bytes+=(unsigned int) ((argv[i] ? strlen(argv[i]) : 0)+1);
X  protocol.encoding=XA_STRING;
X  protocol.format=8;
X  protocol.nitems=0;
X  if (number_bytes)
X    protocol.nitems=number_bytes-1;
X  protocol.value=NULL;
X  if (number_bytes <= 0)
X    {
X      protocol.value=(unsigned char *) malloc(sizeof(char));
X      if (!protocol.value)
X        return(False);
X      *protocol.value='\0';
X    }
X  else
X    {
X      register char
X        *buffer;
X
X      buffer=(char *) malloc(number_bytes*sizeof(char));
X      if (buffer == (char *) NULL)
X        return(False);
X      protocol.value=(unsigned char *) buffer;
X      for (i=0; i < argc; i++)
X      {
X        char
X          *argument;
X
X        argument=argv[i];
X        if (!argument)
X          *buffer++='\0';
X        else
X          {
X            (void) strcpy(buffer,argument);
X            buffer+=(strlen(argument)+1);
X          }
X      }
X    }
X  *property=protocol;
X  return(True);
}
X
void XSetWMProperties(display,window,window_name,icon_name,argv,argc,
X  size_hints,manager_hints,class_hint)
Display
X  *display;
X
Window
X  window;
X
XXTextProperty
X  *window_name,
X  *icon_name;
X
char
X  **argv;
X
int
X  argc;
X
XXSizeHints
X  *size_hints;
X
XXWMHints *manager_hints;
X
XXClassHint
X  *class_hint;
{
X  XSetStandardProperties(display,window,window_name->value,icon_name,None,
X    argv,argc,size_hints);
X  XSetWMHints(display,window,manager_hints);
X  XSetClassHint(display,window,class_hint);
}
X
Status XSetWMProtocols(display,window,protocols,count)
Display
X  *display;
X
Window
X  window;
X
Atom
X  *protocols;
X
int
X  count;
{
X  Atom
X    protocols_property;
X
X  protocols_property=XInternAtom(display,"WM_PROTOCOLS",False);
X  XChangeProperty(display,window,protocols_property,XA_ATOM,32,PropModeReplace,
X    (unsigned char *) protocols, count);
X  return(True);
}
X
VisualID XVisualIDFromVisual(visual)
Visual
X  *visual;
{
X  return(visual->visualid);
}
X
Status XWithdrawWindow(display,window,screen)
Display
X  *display;
X
Window
X  window;
X
int
X  screen;
{
X  return(XUnmapWindow(display,window));
}
X
int XWMGeometry(display,screen,user_geometry,default_geometry,border_width,
X  size_hints,x,y,width,height,gravity)
Display
X  *display;
X
int
X  screen;
X
char
X  *user_geometry,
X  *default_geometry;
X
unsigned int
X  border_width;
X
XXSizeHints
X  *size_hints;
X
int
X  *x,
X  *y,
X  *width,
X  *height,
X  *gravity;
{
X  int
X    status;
X
X  status=XGeometry(display,screen,user_geometry,default_geometry,border_width,
X    0,0,0,0,x,y,width,height);
X  *gravity=NorthWestGravity;
X  return(status);
}
#endif
SHAR_EOF
chmod 0644 ImageMagick/PreRvIcccm.c ||
echo 'restore of ImageMagick/PreRvIcccm.c failed'
Wc_c="`wc -c < 'ImageMagick/PreRvIcccm.c'`"
test 5666 -eq "$Wc_c" ||
	echo 'ImageMagick/PreRvIcccm.c: original size 5666, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/PreRvIcccm.h ==============
if test -f 'ImageMagick/PreRvIcccm.h' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/PreRvIcccm.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/PreRvIcccm.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/PreRvIcccm.h' &&
#ifdef PRE_R5_ICCCM
/*
X  Compatability defines for pre X11R5 ICCCM.
*/
extern XrmDatabase
X  XrmGetDatabase();
#endif
X
#ifdef PRE_R4_ICCCM
/*
X  Compatability defines for pre X11R4 ICCCM.
*/
#ifdef vms
#define XMaxRequestSize(display)  16384
#endif
X
#define XInductColormap(display,colormap)  XInstallColormap(display,colormap)
#define XUninductColormap(display,colormap)  XUninstallColormap(display,colormap)
X
typedef struct _XTextProperty
{
X  unsigned char
X    *value;
X
X  Atom
X    encoding;
X
X  int
X    format;
X
X  unsigned long
X    nitems;
} XTextProperty;
X
/*
X  Pre R4 ICCCM compatibility routines.
*/
char 
X  *XResourceManagerString();
X
extern int
X  XWMGeometry();
X
extern Status
X  XGetRGBColormaps(),
X  XGetWMName(),
X  XReconfigureWMWindow(),
X  XSetWMProtocols(),
X  XWithdrawWindow();
X
extern XClassHint
X  *XAllocClassHint();
X
extern XIconSize
X  *XAllocIconSize();
X
extern XSizeHints
X  *XAllocSizeHints();
X
extern XStandardColormap
X  *XAllocStandardColormap();
X
extern XWMHints
X  *XAllocWMHints();
X
extern VisualID
X  XVisualIDFromVisual();
X
extern void
X  XrmDestroyDatabase(),
X  XSetWMProperties();
#else
#define XInductColormap(display,colormap)
#define XUninductColormap(display,colormap)
#endif
SHAR_EOF
chmod 0644 ImageMagick/PreRvIcccm.h ||
echo 'restore of ImageMagick/PreRvIcccm.h failed'
Wc_c="`wc -c < 'ImageMagick/PreRvIcccm.h'`"
test 1201 -eq "$Wc_c" ||
	echo 'ImageMagick/PreRvIcccm.h: original size 1201, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/README ==============
if test -f 'ImageMagick/README' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/README' &&
AUTHOR
X
X  The author is cristy@dupont.com.  Comments, suggestions, or bug
X  reports are welcome, but be kind.  This software is NOT shareware.
X  However, I am interested in who might be using it.  Please consider
X  sending me a picture postcard of the area where you live.  Send
X  postcards to
X
X    John Cristy
X    5 Middleton Lane
X    Landenberg, PA  19350
X
X
AVAILABLILITY
X
X  Anonymous FTP at export.lcs.mit.edu, file contrib/ImageMagick.tar.Z.
X
X
UNIX COMPILATION
X
X  Type:
X
X    uncompress ImageMagick.tar.Z
X    tar xvf ImageMagick.tar
X    cd ImageMagick
X    xmkmf
X    make Makefiles
X    make
X
X  If you do not have 'xmkmf', edit 'Makefile' as required by your
X  hardware environment and type 'make'.
X
X  Finally type:
X
X    display images/aquarium.miff
X    display -monochrome -dither images/aquarium.miff
X
X  If the image colors are not correct use this command:
X
X    display -visual default images/aquarium.miff
X
X  You can find other example images in the 'images' directory.
X
X  Be sure to read the manual pages for the display, animate, montage,
X  import, mogrify, and convert utilities.
X
X  The ImageMagick utilites read and write MIFF images.  Refer to the
X  end of this message for more information about MIFF.  Use `convert'
X  to convert images to and from the MIFF format.
X
X  Some ImageMagick utilities recognizes these image formats:
X
X       Tag       Description
X       ----------------------------------------------------
X       AVS       AVS X image file
X       BMP       Microsoft Windows bitmap image file
X       EPS       Adobe Encapsulated Postscript
X       GIF       Compuserve Graphics image file
X       JPEG
X       PCX       ZSoft IBM PC Paintbrush file
X       PICT      Apple Macintosh QuickDraw/PICT file
X       PNM       Portable bitmap
X       PS        Adobe PostScript file
X       RLE       Utah Raster Toolkit
X       SUN       SUN raster
X       TGA       Truevision Targa image file
X       TIFF      Tagged Image File Format
X       VICAR
X       VIFF      Khoros Visualization image file.
X       XBM       X11 bitmap
X       XWD       X11 window dump
X
X  and for your convenience automatically converts the alien image
X  format to MIFF at execution time.  However, the MIFF image format has
X  several advantages over most image formats (i.e. runlength encoding,
X  digital signature on an image colormap, etc.).  ImageMagick is
X  designed to exploit these advantages.  Whenever possible convert an
X  alien image format to the MIFF format before using the various
X  ImageMagick programs.
X
X  Other formats are also recognized.  See CONVERT(1) for a list of
X  valid image formats.  You can specify a particular image format by
X  prefixing the image filename with the image type and a colon (i.e.
X  ps:image.ps).
X
X  ImageMagick requires GNU's Ghostscript software available via FTP as
X  ftp.uu.net:systems/gnu/ghostscript-2.6.1.tar.gz to read the
X  Postscript format.  For ImageMagick to read Postscript files, `gs'
X  must be in your execution path and the `pbmraw' and `ppmraw' devices
X  must be recognized.  Add it to your 'DEVICE_DEVS' define in your
X  Ghostscript `Makefile' and recompile.
X
X  ImageMagick requires the Independent JPEG Group's software available via 
X  FTP as ftp.uu.net:graphics/jpeg/jpegsrc.v4.tar.Z to read the JPEG image
X  format.
X
X  ImageMagick requires Sam Leffler's TIFF software available via FTP as 
X  sgi.com:graphics/tiff/v3.2beta.tar.Z to read the TIFF image format.
X
X  To display images in the JPEG or TIFF format, get the JPEG and TIFF
X  archives and build ImageMagick as follows:
X
X    cd ImageMagick
X    mkdir jpeg
X    cd jpeg
X    zcat jpegsrc.v4.tar.Z | tar xvof -
X    cp jmemnobs.c jmemsys.c
X    cp makefile.unix Makefile
X    make libjpeg.a
X    cd ..
X    mkdir tiff
X    cd tiff
X    zcat v3.2beta.tar.Z | tar xvof -
X    cd libtiff
X    cp Makefile.sun Makefile
X    make
X    cd ../..
X    < edit Magick.tmpl and define HasJPEG and HasTIFF lines as instructed >
X    touch decode.c
X    touch encode.c
X    xmkmf
X    make Makefiles
X    make
X
X  You can now display images in the JPEG or TIFF format.
X
X  If you have a colormapped X server, the number of unique colors in an
X  image must first be reduced to match the requirements of your server
X  before it can be displayed.  ImageMagick tries to make the color reduced
X  image closely resemble the original.  However, this process can be
X  time consuming.  To speed it up, ImageMagick trades image quality for
X  processing time.  For the "best" image possible, type
X
X      display -colors 256 -dither image.jpeg
X
X  or add this to your X resources file:
X
X      display.colors: 256
X
X  This example assumes your server supports 256 colors.  Choose
X  whatever value is appropriate for your X server.  Alternatively if
X  you intend to view the image frequently, reduce the number of colors
X  to match the resolution of your X server once and write to a new
X  image.  Then display this new image.  For example,
X
X      convert -colors 256 -dither image.jpeg image.miff
X      display image.miff
X
X  The default dimensions of a Postscript page is 612x792.  If you prefer
X  another default, change the PageWidth and PageHeight defines in encode.c.
X
X
VMS COMPILATION
X
X  Type
X
X    @make
X    set display/create/node=node_name::
X
X  where node_name is the DECNET X server to contact.
X
X  Finally type:
X
X    display images/aquarium.miff
X    display -monochrome -dither images/aquarium.miff
X
X
ANIMATION
X
X  An example animation sequence is available from anonymous FTP at
X  export.lcs.mit.edu, file contrib/ImageMagick.animation.tar.Z Or
X  alternatively, you can create this sequence yourself.  Just look at
X  README in the scenes directory.
X  
X  To prevent color flashing on visuals that have colormaps, `animate'
X  creates a single colormap from the image sequence.  This can be
X  rather time consuming.  You can speed this operation up by reducing
X  the colors in the image before you `animate' them.  Use `mogrify' to
X  color reduce the images:
X
X    mogrify -colors 256 scenes/dna.[0-9]*
X
X  Note, the image sequence in ImageMagick.animation.tar.Z is already
X  reduced.  Alternatively, you can use a Standard Colormap; or a
X  static, direct, or true color visual.  You can define a Standard
X  Colormap with `xstdcmap'.  For example, to use the "best" Standard
X  Colormap, type:
X
X    xstdcmap -best
X    animate -map best scenes/dna.[0-9]*
X
X  or to use a true color visual:
X
X    animate -visual truecolor scenes/dna.[0-9]*
X
X  Image filenames can appear in any order on the command line if the
X  scene keyword is specified in the MIFF image.  Otherwise the images
X  display in the order they appear on the command line.  A scene is
X  specified when converting from another image format to MIFF by using
X  the "scene" option with any filter.  Be sure to choose a scene number
X  other than zero.  For example, to convert a TIFF image to a MIFF
X  image as scene #2, type:
X
X    convert -scene 2 image.tiff image.miff
X
X
NOTES
X
X  1.  If you get a compile error on XTextProperty in PreRvIcccm.h,
X      change it to _XTextProperty. If you get a compile error on
X      XVisualIDFromVisual in PreRvIcccm.c, change it to
X      _XVisualIDFromVisual.
X
X  2.  24 bit images are reduced to 244 colors on an 8 bit display to
X      help prevent colormap flashing.  If you want all 256 colors, type
X
X        display -colors 256 image.miff
X
X      To further help reduce colormap flashing, do not install the
X      default standard colormap (RGB_DEFAULT_MAP).
X
X  3.  Machine dependancies:
X
X      For MacX, set the DISPLAY variable to host:0.2 for the color
X      rootless window.
X
X      I suspect all the following problems will be fixed when these
X      vendors upgrade to X11R4.  I find conditional compilation
X      statements offensive.  So if you have any of the following
X      problems, the fix must be applied manually.
X
X      MIPS does not always generate exposure events correctly when
X      displaying a monochrome image on their color server.  Holes in the
X      image may appear when an area is blocked then exposed.  I do not
X      currently have a solution for this problem.
X
X      Images do not dislay correctly on the IBM R6000 visual with 4096
X      colors.  However they do display correctly on the visual with 256
X      colors.  Until IBM fixes their server, type xdpyinfo to determine 
X      the ID of the 256 color visual and type
X
X        display -visual 0x???? image.miff
X
X      On the Stardent put
X
X        *installColormap:  on
X
X      in your X resource file.
X
X      Digital and Tektronix has a bug in their servers.  When converting
X      from LSBFirst to MSBFirst X server (or visa-versa) you may get the 
X      error
X
X        Illegal unit size: 8 found in routine: _normalizeimagebits
X
X      On some HP's you may get a memory fault when exiting display(1).
X      To fix this problem comment out the XCLoseDisplay line near the
X      last line of display.c and recompile.  Under HPUX 9.0 the compiler
X      has a bug.  You might have to compile image.c unoptimized to
X      prevent bus errors with montage(1).
X
X  4.  On occasion, a window manager (twm) may get in strange state which will 
X      cause the display program to work improperly.  Fix this by restarting the
X      window manager.
X
X  5.  If the image is displayed with incorrect colors, try using a different
X      visual.  Type xdpyinfo and choose an alternative visual (if one exists)
X      by either visual class or visual id.  For example, to specifically 
X      choose a PseudoColor visual on a server that supports it, type
X
X        display -visual pseudocolor image.miff
X
X  6.  Make sure that the include file math.h defines the function atof as
X      type double.  Otherwise the -gamma option will not work properly.
X
X  7.  If you get a compile error on "WithdrawnState", replace
X      "WithdrawnState" with "0";
X
X
MIFF IMAGE FORMAT
X
X  MIFF is an image format which I developed.  I like it because it
X
X    1) It is machine independant.  It can be read on virtually any
X       computer.  No byte swapping is necessary.
X
X    2) It has a text header.  Most image formats are coded in binary
X       and you cannot easily tell attributes about the image.  Use
X       'more' on MIFF image files and the attributes are displayed in
X       text form.
X
X    3) It can handle runlength-encoded images.  Although most scanned
X       images do not benefit from runlength-encoding, most
X       computer-generated images do.  Images of mostly uniform colors
X       have a high compression ratio and therefore take up less memory
X       and disk space.
X
X    4) It allows a scene number to be specified.  This allows you to
X       specify an animation sequence out-of-order on the command line.
X       The correct order is determined by the scene number of each
X       image.
X
X    5) MIFF computes a digital signature for colormapped images.  This
X       is useful for animating a sequence of images on a colormapped X
X       server.  If all signatures match in the image sequence,
X       computing a global colormap is not necessary.
X
X  One way to get an image into MIFF format is to use `convert'.  or
X  read it from an X window using the 'import' program.  Alternatively,
X  type the necessary header information in a file with a text editor.
X  Next, dump the binary bytes into another file.  Finally, type
X
X    cat header binary_image | display -write image.miff -
X
X  For example, suppose you have a raw red, green, blue image file on
X  disk that is 640 by 480.  The header file would look like this:
X
X    id=ImageMagick columns=640 rows=480 :
X
X  The image file would have red, green, blue tuples (rgbrgbrgb...).
X
X  Refer to the 'display' manual page for more details.
X
COPYRIGHT
X
X  Copyright 1993 E. I. du Pont de Nemours & Company
X
X  Permission to use, copy, modify, distribute, and sell this software and
X  its documentation for any purpose is hereby granted without fee,
X  provided that the above copyright notice appear in all copies and that
X  both that copyright notice and this permission notice appear in
X  supporting documentation, and that the name of E. I. du Pont de Nemours
X  & Company not be used in advertising or publicity pertaining to
X  distribution of the software without specific, written prior
X  permission.  E. I. du Pont de Nemours & Company makes no representations
X  about the suitability of this software for any purpose.  It is provided
X  "as is" without express or implied warranty.
X
X  E. I. du Pont de Nemours & Company disclaims all warranties with regard
X  to this software, including all implied warranties of merchantability
X  and fitness, in no event shall E. I. du Pont de Nemours & Company be
X  liable for any special, indirect or consequential damages or any
X  damages whatsoever resulting from loss of use, data or profits, whether
X  in an action of contract, negligence or other tortious action, arising
X  out of or in connection with the use or performance of this software.
SHAR_EOF
chmod 0644 ImageMagick/README ||
echo 'restore of ImageMagick/README failed'
Wc_c="`wc -c < 'ImageMagick/README'`"
test 12850 -eq "$Wc_c" ||
	echo 'ImageMagick/README: original size 12850, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/SYNOPSIS ==============
if test -f 'ImageMagick/SYNOPSIS' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/SYNOPSIS (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/SYNOPSIS (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/SYNOPSIS' &&
ImageMagick is a collection of X11 image processing and display utilities.  It
is available on export.lcs.mit.edu as contrib/ImageMagick.tar.Z.
X
cristy@dupont.com
X
---
X
Display
X
X     Display is a machine architecture independent image
X     processing and display program.  It can display an image on
X     any workstation display running an X server.  Display first
X     determines the hardware capabilities of the workstation.  If
X     the number of unique colors in the image is less than or
X     equal to the number the workstation can support, the image
X     is displayed in an X window.  Otherwise the number of colors
X     in the image is first reduced to match the color resolution
X     of the workstation before it is displayed.
X
X     This means that a continuous-tone 24 bits/pixel image can
X     display on a 8 bit pseudo-color device or monochrome device.
X     In most instances the reduced color image closely resembles
X     the original.  Alternatively, a monochrome or pseudo-color
X     image can display on a continuous-tone 24 bits/pixels
X     device.
X
X
Import
X
X     Import reads an image from any visible window on an X server
X     and outputs it as an image file.  You can capture a single
X     window, the entire screen, or any rectangular portion of the
X     screen.  You can use display (see display(1)) utility for
X     redisplay, printing, editing, formatting, archiving, image
X     processing, etc. of the captured image.
X
X     The target window can be specified by id, name, or may be
X     selected by clicking the mouse in the desired window.  If
X     you press a button and then drag, a rectangle will form
X     which expands and contracts as the mouse moves.  To save the
X     portion of the screen  defined by the rectangle, just
X     release the button.  The keyboard bell is rung once at the
X     beginning of the screen capture and twice when it completes.
X
X
Animate
X
X     Animate displays a sequence of images on any workstation
X     display running an X server.  Animate first determines the
X     hardware capabilities of the workstation.  If the number of
X     unique colors in an image is less than or equal to the
X     number the workstation can support, the image is displayed
X     in an X window.  Otherwise the number of colors in the image
X     is first reduced to match the color resolution of the
X     workstation before it is displayed.
X
X     This means that a continuous-tone 24 bits/pixel image can
X     display on a 8 bit pseudo-color device or monochrome device.
X     In most instances the reduced color image closely resembles
X     the original.  Alternatively, a monochrome or pseudo-color
X     image sequence can display on a continuous-tone 24
X     bits/pixels device.
X
X
Montage
X
X     Montage creates a composite image by combining several
X     separate images.  The images are tiled on the composite
X     image with the name of the image optionally appearing just
X     below the individual tile.
X
X
Mogrify
X
X     Mogrify transforms an image or a sequence of images.  These
X     transforms include image scaling, image rotation, color
X     reduction, and others.  The transmogrified image overwrites
X     the original image.
X
X
Convert
X
X     Convert converts an input file using one image format to an
X     output file with a differing image format. By default, the
X     image format is determined by it's magic number. To specify
X     a particular image format, precede the filename with an
X     image format name and a colon (i.e.  ps:image) or specify
X     the image type as the filename suffix (i.e. image.ps).
X     Specify file as - for standard input or output.  If file has
X     the extension .Z, the file is decoded with uncompress.
X
X     Convert recognizes the following image formats:
X
X       Tag       Description
X       ----------------------------------------------------
X       ALPHA     Raw alpha bytes
X       AVS       AVS X image file
X       BMP       Microsoft Windows bitmap image file
X       CMYK      Raw cyan, magenta, yellow, and black bytes
X       EPS       Adobe Encapsulated Postscript
X       FAX       Group 3
X       GIF       Compuserve Graphics image file
X       GRAY      Raw gray bytes
X       JPEG
X       MIFF      Machine Independant file format
X       MTV
X       PCX       ZSoft IBM PC Paintbrush file
X       PICT      Apple Macintosh QuickDraw/PICT file
X       PNM       Portable bitmap
X       PS        Adobe PostScript file
X       PS2       Adobe PostScript Level II file
X       RGB       Raw red, green, and blue bytes
X       RLE       Utah Raster Toolkit
X       SUN       SUN raster
X       TGA       Truevision Targa image file
X       TEXT      raw text file;  read only
X       TIFF      Tagged Image File Format
X       VICAR
X       VIFF      Khoros Visualization image file.
X       X         select image from X server screen
X       XC        constant image of X server background color
X       XBM       X11 bitmap
X       XWD       X11 window dump
X       YUV       Raw Y, U, and V bytes
X
X
Combine
X
X     Combine combines images to create new images.
X
X
Segment
X
X     Segment segments an image by analyzing the histograms of the
X     color components and identifying units that are homogeneous
X     with the fuzzy c-means technique.  The scale-space filter
X     analyzes the histograms of the three color components of the
X     image and identifies a set of classes.  The extents of each
X     class is used to coarsely segment the image with
X     thresholding.  The color associated with each class is
X     determined by the mean color of all pixels within the
X     extents of a particular class.  Finally, any unclassified
X     pixels are assigned to the closest class with the fuzzy c-
X     means technique.
X
X
XXTP
X
X     Xtp is a utility for retrieving, listing, or printing files
X     from a remote network site, or sending files to a remote
X     network site.  Xtp performs most of the same functions as
X     the ftp program, but does not require any interactive
X     commands.  You simply specify the file transfer task on the
X     command line and xtp performs the task automatically.
SHAR_EOF
chmod 0644 ImageMagick/SYNOPSIS ||
echo 'restore of ImageMagick/SYNOPSIS failed'
Wc_c="`wc -c < 'ImageMagick/SYNOPSIS'`"
test 6075 -eq "$Wc_c" ||
	echo 'ImageMagick/SYNOPSIS: original size 6075, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ImageMagick/X.c ==============
if test -f 'ImageMagick/X.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ImageMagick/X.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ImageMagick/X.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ImageMagick/X.c' &&
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%                                                                             %
%                                     X   X                                   %
%                                      X X                                    %
%                                       X                                     %
%                                      X X                                    %
%                                     X   X                                   %
%                                                                             %
%                          X11 Utility Routines for Display.                  %
%                                                                             %
%                                                                             %
%                                 Software Design                             %
%                                   John Cristy                               %
%                                    July 1992                                %
%                                                                             %
%                                                                             %
%  Copyright 1993 E. I. du Pont de Nemours & Company                          %
%                                                                             %
%  Permission to use, copy, modify, distribute, and sell this software and    %
%  its documentation for any purpose is hereby granted without fee,           %
%  provided that the above Copyright notice appear in all copies and that     %
%  both that Copyright notice and this permission notice appear in            %
%  supporting documentation, and that the name of E. I. du Pont de Nemours    %
%  & Company not be used in advertising or publicity pertaining to            %
%  distribution of the software without specific, written prior               %
%  permission.  E. I. du Pont de Nemours & Company makes no representations   %
%  about the suitability of this software for any purpose.  It is provided    %
%  "as is" without express or implied warranty.                               %
%                                                                             %
%  E. I. du Pont de Nemours & Company disclaims all warranties with regard    %
%  to this software, including all implied warranties of merchantability      %
%  and fitness, in no event shall E. I. du Pont de Nemours & Company be       %
%  liable for any special, indirect or consequential damages or any           %
%  damages whatsoever resulting from loss of use, data or profits, whether    %
%  in an action of contract, negligence or other tortious action, arising     %
%  out of or in connection with the use or performance of this software.      %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
*/
X
/*
X  Include declarations.
*/
#include "display.h"
#include "image.h"
#include "X.h"
X
/*
X  State declarations.
*/
#define ControlState  0x0001
#define DefaultState  0x0000
#define ExitState  0x0002
X
/*
X  External declarations.
*/
extern char
X  *client_name;
X
extern void
X  Error _Declare((char *,char *));
X
/*
X  Forward declarations.
*/
int
X  Latin1Compare _Declare((char *,char *));
X
static Image
X  *XGetWindowImage _Declare((Display *,Window,unsigned int,unsigned int));
X
static void
X  XHighlightRegion _Declare((Display *,Window,GC,RectangleInfo *)),
X  XMakeImageLSBFirst _Declare((XWindowInfo *,Image *, XImage *)),
X  XMakeImageMSBFirst _Declare((XWindowInfo *,Image *, XImage *));
X
static Window
X  XClientWindow _Declare((Display *,Window)),
X  XSelectWindow _Declare((Display *,RectangleInfo *)),
X  XWindowByProperty _Declare((Display *,Window,Atom));
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   I s T r u e                                                               %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function IsTrue returns True if the boolean is "true", "on", "yes" or "1".
%
%  The format of the IsTrue routine is:
%
%      option=IsTrue(boolean)
%
%  A description of each parameter follows:
%
%    o option: either True or False depending on the boolean parameter.
%
%    o boolean: Specifies a pointer to a character array.
%
%
*/
unsigned int IsTrue(boolean)
char
X  *boolean;
{
X  if (boolean == (char *) NULL)
X    return(False);
X  if (Latin1Compare(boolean,"true") == 0)
X    return(True);
X  if (Latin1Compare(boolean,"on") == 0)
X    return(True);
X  if (Latin1Compare(boolean,"yes") == 0)
X    return(True);
X  if (Latin1Compare(boolean,"1") == 0)
X    return(True);
X  return(False);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   L a t i n 1 C o m p a r e                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function Latin1Compare compares two null terminated Latin-1 strings,
%  ignoring case differences, and returns an integer greater than, equal
%  to, or less than 0, according to whether first is lexicographically
%  greater than, equal to, or less than second.  The two strings are
%  assumed to be encoded using ISO 8859-1.
%
%  The format of the Latin1Compare routine is:
%
%      Latin1Compare(first,second)
%
%  A description of each parameter follows:
%
%    o first: A pointer to the string to convert to Latin1 string.
%
%    o second: A pointer to the string to convert to Latin1 string.
%
%
*/
int Latin1Compare(first,second)
char
X  *first,
X  *second;
{
X  register unsigned char
X   *p,
X   *q;
X
X  p=(unsigned char *) first;
X  q=(unsigned char *) second;
X  while ((*p != '\0') && (*q != '\0'))
X  {
X    register unsigned char
X      c,
X      d;
X
X    c=(*p);
X    d=(*q);
X    if (c != d)
X      {
X        /*
X          Try lowercasing and try again.
X        */
X        if ((c >= XK_A) && (c <= XK_Z))
X          c+=(XK_a-XK_A);
X        else
X          if ((c >= XK_Agrave) && (c <= XK_Odiaeresis))
X            c+=(XK_agrave-XK_Agrave);
X          else
X            if ((c >= XK_Ooblique) && (c <= XK_Thorn))
X              c+=(XK_oslash-XK_Ooblique);
X        if ((d >= XK_A) && (d <= XK_Z))
X          d+=(XK_a-XK_A);
X        else
X          if ((d >= XK_Agrave) && (d <= XK_Odiaeresis))
X            d+=(XK_agrave-XK_Agrave);
X          else if ((d >= XK_Ooblique) && (d <= XK_Thorn))
X            d+=(XK_oslash-XK_Ooblique);
X        if (c != d)
X          return(((int) c)-((int) d));
X      }
X    p++;
X    q++;
X  }
X  return(((int) *p)-((int) *q));
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   L a t i n 1 U p p e r                                                     %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function Latin1Upper copies a null terminated string from src to dst
%  (including the null), changing all Latin-1 lowercase letters to
%  uppercase.  The string is assumed to be encoded using ISO 8859-1.
%
%  The format of the Latin1Upper routine is:
%
%      Latin1Upper(string)
%
%  A description of each parameter follows:
%
%    o string: A pointer to the string to convert to upper-case Latin1.
%
%
*/
static void Latin1Upper(string)
char
X  *string;
{
X  unsigned char
X    c;
X
X  c=(*string);
X  while (c != '\0')
X  {
X    if ((c >= XK_a) && (c <= XK_z))
X      *string=c-(XK_a-XK_A);
X    else
X      if ((c >= XK_agrave) && (c <= XK_odiaeresis))
X        *string=c-(XK_agrave-XK_Agrave);
X      else
X        if ((c >= XK_oslash) && (c <= XK_thorn))
X          *string=c-(XK_oslash-XK_Ooblique);
X    string++;
X    c=(*string);
X  }
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   R e a d X I m a g e                                                       %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Procedure ReadXImage reads an image from an X window.
%
%  The format of the ReadXImage routine is:
%
%      image=ReadXImage(filename,server_name,frame,borders,screen,descend)
%
%  A description of each parameter follows:
%
%    o image: Specifies a pointer to the Image structure.
%
%    o filename: Specifies the name of the image to read.
%
%    o server_name: Specifies the name of the X server to read image from.
%
%    o frame: Specifies whether to include the window manager frame with the
%      image.
%
%    o borders: Specifies whether borders pixels are to be saved with
%      the image.
%
%    o screen: Specifies whether the GetImage request used to obtain the image
%      should be done on the root window, rather than directly on the specified
%      window.
%
%    o descend: If this option is zero the colormap of the chosen window is
%      used to obtain the red, green, and blue values.  Otherwise the image
%      is obtained by descending the window hierarchy and reading each
%      subwindow and its colormap.
%
%
*/
Image *ReadXImage(filename,server_name,frame,borders,screen,descend)
char
X  *filename,
X  *server_name;
X
unsigned int
X  frame,
X  borders,
X  screen,
X  descend;
{
X  Display
X    *display;
X
X  Image
X    *image;
X
X  int
X    status,
X    x;
X
X  RectangleInfo
X    clip_info;
X
X  Window
X    client_window,
X    root_window,
X    target_window;
X
X  XTextProperty
X    window_name;
X
X  /*
X    Open X server connection.
X  */
X  display=XOpenDisplay(server_name);
X  if (display == (Display *) NULL)
X    {
X      Warning("unable to connect to X server",XDisplayName(server_name));
X      return((Image *) NULL);
X    }
X  /*
X    Set our forgiving error handler.
X  */
X  XSetErrorHandler(XError);
X  /*
X    Select target window.
X  */
X  clip_info.x=0;
X  clip_info.y=0;
X  clip_info.width=0;
X  clip_info.height=0;
X  root_window=XRootWindow(display,XDefaultScreen(display));
X  target_window=(Window) NULL;
X  if ((filename != (char *) NULL) && (*filename != '\0'))
X    if (Latin1Compare(filename,"root") == 0)
X      target_window=root_window;
X    else
X      {
X        /*
X          Select window by ID or name.
X        */
X        if (isdigit(*filename))
X          target_window=XWindowByID(display,root_window,
X            (Window) strtol(filename,(char **) NULL,0));
X        if (target_window == (Window) NULL)
X          target_window=XWindowByName(display,root_window,filename);
X        if (target_window == (Window) NULL)
X          Warning("No window with specified id exists",filename);
X      }
X  /*
X    If target window is not defined, interactively select one.
X  */
X  if (target_window == (Window) NULL)
X    target_window=XSelectWindow(display,&clip_info);
X  client_window=target_window;
X  if (target_window != root_window)
X    {
X      unsigned int
X        d;
X
X      /*
X        Get client window.
X      */
X      status=XGetGeometry(display,target_window,&root_window,&x,&x,&d,&d,&d,&d);
X      if (status != 0)
X        {
X          client_window=XClientWindow(display,target_window);
X          if (!frame)
X            target_window=client_window;
X        }
X    }
X  if (screen)
X    {
X      int
X        y;
X
X      Window
X        child;
X
X      XWindowAttributes
X        window_attributes;
X
X      /*
X        Obtain window image directly from screen.
X      */
X      status=XGetWindowAttributes(display,target_window,&window_attributes);
X      if (status == False)
X        {
X          Warning("unable to read X window attributes",filename)
X          XCloseDisplay(display);
X          return((Image *) NULL);
X        }
X      XTranslateCoordinates(display,target_window,root_window,0,0,&x,&y,&child);
X      clip_info.x=x;
X      clip_info.y=y;
X      clip_info.width=window_attributes.width;
X      clip_info.height=window_attributes.height;
X      if (borders)
X        {
X          /*
X            Include border in image.
X          */
X          clip_info.x-=window_attributes.border_width;
X          clip_info.y-=window_attributes.border_width;
X          clip_info.width+=2*window_attributes.border_width;
X          clip_info.height+=2*window_attributes.border_width;
X        }
X      target_window=root_window;
X    }
X  /*
X    Alert the user not to alter the screen.
X  */
X  XBell(display,0);
X  /*
X    Get image by window id.
X  */
X  image=XGetWindowImage(display,target_window,borders,descend);
X  if (image == (Image *) NULL)
X    Warning("unable to read X window image",filename)
X  else
X    {
X      if ((clip_info.width != 0) && (clip_info.height != 0))
X        {
X          Image
X            *clipped_image;
X
X          /*
X            Clip image as defined by the clipping rectangle.
X          */
X          clipped_image=ClipImage(image,&clip_info);
X          if (clipped_image != (Image *) NULL)
X            {
X              DestroyImage(image);
X              image=clipped_image;
X            }
X        }
X      status=XGetWMName(display,target_window,&window_name);
X      if (status == True)
X        {
X          if ((filename != (char *) NULL) && (*filename == '\0'))
X            {
X              /*
X                Initialize image filename.
X              */
X              (void) strncpy(image->filename,(char *) window_name.value,
X                (int) window_name.nitems);
X              image->filename[window_name.nitems]='\0';
X            }
X          /*
X            Initialize image comment.
X          */
X          image->comments=(char *)
X            malloc((strlen((char *) window_name.value)+2048)*sizeof(char));
X          if (image->comments != (char *) NULL)
X            (void) sprintf(image->comments,
X              "\n  Imported from X11 window:  %*s\n",(int) window_name.nitems,
X              window_name.value);
X        }
X    }
X  /*
X    Alert the user we're done.
X  */
X  XBell(display,0);
X  XBell(display,0);
X  XCloseDisplay(display);
X  return(image);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   X A n n o t a t e I m a g e                                               %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function XAnnotateImage annotates the image with text.
%
%  The format of the XAnnotateImage routine is:
%
%    status=XAnnotateImage(display,window,annotate_info,background,image)
%
%  A description of each parameter follows:
%
%    o status: Function XAnnotateImage returns True if the image is
%      successfully annotated with text.  False is returned is there is a
%      memory shortage.
%
%    o display: Specifies a connection to an X server;  returned from
%      XOpenDisplay.
%
%    o window: Specifies a pointer to a XWindowInfo structure.
%
%    o text: Specifies the text to annotate the image.
%
%    o annotate_info: Specifies a pointer to a XAnnotateInfo structure.
%
%    o background: Specifies whether the background color is included in
%      the annotation.  Must be either True or False;
%
%    o image: Specifies a pointer to a Image structure;  returned from
%      ReadImage.
%
%
*/
unsigned int XAnnotateImage(display,window,annotate_info,background,image)
Display
X  *display;
X
XXWindowInfo
X  *window;
X
XXAnnotateInfo
X  *annotate_info;
X
unsigned int
X  background;
X
Image
X  *image;
{
X  GC
X    graphic_context;
X
X  Image
X    *annotate_image;
X
X  int
X    x,
X    y;
X
X  Pixmap
X    annotate_pixmap;
X
X  register RunlengthPacket
X    *p,
X    *q;
X
X  unsigned int
X    height,
X    width;
X
X  XGCValues
X    graphic_context_value;
X
X  XImage
X    *annotate_ximage;
X
X  XPixelInfo
X    *pixel_info;
X
X  /*
X    Initialize annotated image.
X  */
X  if (!UncompressImage(image))
X    return(False);
X  /*
X    Initialize annotated pixmap.
X  */
X  annotate_pixmap=XCreatePixmap(display,window->id,annotate_info->width,
X    annotate_info->height,window->depth);
X  if (annotate_pixmap == (Pixmap) NULL)
X    return(False);
X  /*
X    Initialize graphics info.
X  */
X  graphic_context_value.background=0;
X  graphic_context_value.foreground=(unsigned long) (~0);
X  graphic_context_value.font=annotate_info->font_info->fid;
X  graphic_context=XCreateGC(display,window->id,GCBackground | GCFont |
X    GCForeground,&graphic_context_value);
X  if (graphic_context == (GC) NULL)
X    return(False);
X  /*
X    Draw text to pixmap.
X  */
X  XDrawImageString(display,annotate_pixmap,graphic_context,0,
X    annotate_info->font_info->ascent,annotate_info->text,
X    strlen(annotate_info->text));
X  XFreeGC(display,graphic_context);
X  /*
X    Initialize annotated X image.
X  */
X  annotate_ximage=XGetImage(display,annotate_pixmap,0,0,annotate_info->width,
X    annotate_info->height,AllPlanes,ZPixmap);
X  if (annotate_ximage == (XImage *) NULL)
X    return(False);
X  XFreePixmap(display,annotate_pixmap);
X  /*
X    Initialize annotated image.
X  */
X  annotate_image=AllocateImage("MIFF");
X  if (annotate_image == (Image *) NULL)
X    return(False);
X  annotate_image->columns=annotate_info->width;
X  annotate_image->rows=annotate_info->height;
X  annotate_image->packets=annotate_image->columns*annotate_image->rows;
X  annotate_image->pixels=(RunlengthPacket *)
X    malloc((unsigned int) image->packets*sizeof(RunlengthPacket));
X  if (annotate_image->pixels == (RunlengthPacket *) NULL)
X    {
X      DestroyImage(annotate_image);
X      return(False);
X    }
X  /*
X    Transfer annotated X image to image.
SHAR_EOF
true || echo 'restore of ImageMagick/X.c failed'
fi
echo 'End of ImageMagick part 8'
echo 'File ImageMagick/X.c is continued in part 9'
echo 9 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
