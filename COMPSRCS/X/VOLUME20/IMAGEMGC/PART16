Newsgroups: comp.sources.x
From: cristy@eplrx7.es.duPont.com (Cristy)
Subject: v20i072:  imagemagic - X11 image processing and display, Part16/38
Message-ID: <1993Jul14.175657.1661@sparky.sterling.com>
X-Md4-Signature: 80afac055652aaa0e77951b19450970a
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Wed, 14 Jul 1993 17:56:57 GMT
Approved: chris@sterling.com

Submitted-by: cristy@eplrx7.es.duPont.com (Cristy)
Posting-number: Volume 20, Issue 72
Archive-name: imagemagic/part16
Environment: X11
Supersedes: imagemagic: Volume 13, Issue 17-37

#!/bin/sh
# this is magick.16 (part 16 of ImageMagick)
# do not concatenate these parts, unpack them in order with /bin/sh
# file ImageMagick/decode.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 16; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping ImageMagick/decode.c'
else
echo 'x - continuing file ImageMagick/decode.c'
sed 's/^X//' << 'SHAR_EOF' >> 'ImageMagick/decode.c' &&
%                                                                             %
%                                                                             %
%                                                                             %
%  R e a d R L E I m a g e                                                    %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function ReadRLEImage reads a run-length encoded Utah Raster Toolkit
%  image file and returns it.  It allocates the memory necessary for the new
%  Image structure and returns a pointer to the new image.
%
%  The format of the ReadRLEImage routine is:
%
%      image=ReadRLEImage(image_info)
%
%  A description of each parameter follows:
%
%    o image:  Function ReadRLEImage returns a pointer to the image after
%      reading.  A null image is returned if there is a a memory shortage or
%      if the image cannot be read.
%
%    o image_info: Specifies a pointer to an ImageInfo structure.
%
%
*/
static Image *ReadRLEImage(image_info)
ImageInfo
X  *image_info;
{
#define SkipLinesOp  0x01
#define SetColorOp  0x02
#define SkipPixelsOp  0x03
#define ByteDataOp  0x05
#define RunDataOp  0x06
#define EOFOp  0x07
X
X  char
X    magick[12];
X
X  Image
X    *image;
X
X  int
X    opcode,
X    operand,
X    status,
X    x,
X    y;
X
X  register int
X    i,
X    j;
X
X  register RunlengthPacket
X    *q;
X
X  register unsigned char
X    *p;
X
X  unsigned char
X    background_color[256],
X    *colormap,
X    header[2048],
X    integer[2],
X    pixel,
X    plane,
X    *rle_pixels;
X
X  unsigned int
X    bits_per_pixel,
X    flags,
X    map_length,
X    number_colormaps,
X    number_planes;
X
X  /*
X    Allocate image structure.
X  */
X  image=AllocateImage("RLE");
X  if (image == (Image *) NULL)
X    return((Image *) NULL);
X  /*
X    Open image file.
X  */
X  (void) strcpy(image->filename,image_info->filename);
X  OpenImage(image,"r");
X  if (image->file == (FILE *) NULL)
X    {
X      Warning("unable to open file",image->filename);
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  /*
X    Determine if this is a RLE file.
X  */
X  status=ReadData((char *) magick,1,2,image->file);
X  if ((status == False) || (strncmp(magick,"\122\314",2) != 0))
X    {
X      Warning("not a RLE image file",(char *) NULL);
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  do
X  {
X    /*
X      Read image header.
X    */
X    status=ReadData((char *) header,1,13,image->file);
X    if (status == False)
X      {
X        Warning("unable to read RLE image header",(char *) NULL);
X        DestroyImage(image);
X        return((Image *) NULL);
X      }
X    image->columns=header[4]+(header[5] << 8);
X    image->rows=header[6]+(header[7] << 8);
X    image->packets=image->columns*image->rows;
X    flags=header[8];
X    image->alpha=flags & 0x04;
X    number_planes=header[9];
X    bits_per_pixel=header[10];
X    number_colormaps=header[11];
X    map_length=1 << header[12];
X    if ((number_planes == 0) || (number_planes == 2) || (bits_per_pixel != 8) ||
X        ((image->columns*image->rows) == 0))
X      {
X        Warning("unsupported RLE image file",(char *) NULL);
X        DestroyImage(image);
X        return((Image *) NULL);
X      }
X    if (flags & 0x02)
X      {
X        /*
X          No background color-- initialize to black.
X        */
X        for (i=0; i < number_planes; i++)
X          background_color[i]=(unsigned char) 0;
X        (void) fgetc(image->file);
X      }
X    else
X      {
X        /*
X          Initialize background color.
X        */
X        p=background_color;
X        for (i=0; i < number_planes; i++)
X          *p++=(unsigned char) fgetc(image->file);
X        if ((number_planes % 2) == 0)
X          (void) fgetc(image->file);
X      }
X    colormap=(unsigned char *) NULL;
X    if (number_colormaps != 0)
X      {
X        /*
X          Read image colormaps.
X        */
X        colormap=(unsigned char *)
X          malloc(number_colormaps*map_length*sizeof(unsigned char));
X        if (colormap == (unsigned char *) NULL)
X          {
X            Warning("memory allocation error",(char *) NULL);
X            DestroyImage(image);
X            return((Image *) NULL);
X          }
X        p=colormap;
X        for (i=0; i < number_colormaps; i++)
X          for (j=0; j < map_length; j++)
X          {
X            (void) fgetc(image->file);
X            *p++=(unsigned char) fgetc(image->file);
X          }
X      }
X    /*
X      Allocate image comment.
X    */
X    image->comments=(char *)
X      malloc((strlen(image->filename)+2048)*sizeof(char));
X    if (image->comments == (char *) NULL)
X      {
X        Warning("memory allocation error",(char *) NULL);
X        DestroyImage(image);
X        return((Image *) NULL);
X      }
X    (void) sprintf(image->comments,"\n  Imported from Utah raster image:  %s\n",
X      image->filename);
X    if (flags & 0x08)
X      {
X        unsigned int
X          comment_length;
X
X        /*
X          Read image comment.
X        */
X        (void) ReadData((char *) integer,1,2,image->file);
X        comment_length=integer[0]+(integer[1] << 8);
X        image->comments=(char *) realloc((char *) image->comments,
X          (unsigned int) (strlen(image->comments)+comment_length+2048));
X        if (image->comments == (char *) NULL)
X          {
X            Warning("memory allocation error",(char *) NULL);
X            DestroyImage(image);
X            return((Image *) NULL);
X          }
X        (void) strcat(image->comments,"\n  ");
X        status=ReadData((char *) image->comments+strlen(image->comments),1,
X          (int) comment_length+(comment_length % 2 ? 0 : 1),image->file);
X        if (status == False)
X          {
X            Warning("unable to read RLE comment",(char *) NULL);
X            DestroyImage(image);
X            return((Image *) NULL);
X          }
X        (void) strcat(image->comments,"\n");
X      }
X    /*
X      Allocate RLE pixels.
X    */
X    if (image->alpha)
X      number_planes++;
X    rle_pixels=(unsigned char *)
X      malloc((unsigned int) image->packets*number_planes*sizeof(unsigned char));
X    if (rle_pixels == (unsigned char *) NULL)
X      {
X        Warning("memory allocation error",(char *) NULL);
X        DestroyImage(image);
X        return((Image *) NULL);
X      }
X    if ((flags & 0x01) && ((~flags) & 0x02))
X      {
X        /*
X          Set background color.
X        */
X        p=rle_pixels;
X        for (i=0; i < image->packets; i++)
X        {
X          if (!image->alpha)
X            for (j=0; j < number_planes; j++)
X              *p++=background_color[j];
X          else
X            {
X              for (j=0; j < (number_planes-1); j++)
X                *p++=background_color[j];
X              *p++=0;  /* initialize alpha channel */
X            }
X        }
X      }
X    /*
X      Read runlength-encoded image.
X    */
X    plane=0;
X    x=0;
X    y=0;
X    (void) fgetc(image->file);
X    opcode=fgetc(image->file);
X    while (((opcode & 0x3f) != EOFOp) && (opcode != EOF))
X    {
X      switch (opcode & 0x3f)
X      {
X        case SkipLinesOp:
X        {
X          operand=fgetc(image->file);
X          if (opcode & 0x40)
X            {
X              (void) ReadData((char *) integer,1,2,image->file);
X              operand=integer[0]+(integer[1] << 8);
X            }
X          x=0;
X          y+=operand;
X          break;
X        }
X        case SetColorOp:
X        {
X          operand=fgetc(image->file);
X          plane=operand;
X          if (plane == 255)
X            plane=number_planes-1;
X          x=0;
X          break;
X        }
X        case SkipPixelsOp:
X        {
X          operand=fgetc(image->file);
X          if (opcode & 0x40)
X            {
X              (void) ReadData((char *) integer,1,2,image->file);
X              operand=integer[0]+(integer[1] << 8);
X            }
X          x+=operand;
X          break;
X        }
X        case ByteDataOp:
X        {
X          operand=fgetc(image->file);
X          if (opcode & 0x40)
X            {
X              (void) ReadData((char *) integer,1,2,image->file);
X              operand=integer[0]+(integer[1] << 8);
X            }
X          p=rle_pixels+((image->rows-y-1)*image->columns*number_planes)+
X            x*number_planes+plane;
X          operand++;
X          for (i=0; i < operand; i++)
X          {
X            pixel=fgetc(image->file);
X            if ((y < image->rows) && ((x+i) < image->columns))
X              *p=pixel;
X            p+=number_planes;
X          }
X          if (operand & 0x01)
X            (void) fgetc(image->file);
X          x+=operand;
X          break;
X        }
X        case RunDataOp:
X        {
X          operand=fgetc(image->file);
X          if (opcode & 0x40)
X            {
X              (void) ReadData((char *) integer,1,2,image->file);
X              operand=integer[0]+(integer[1] << 8);
X            }
X          pixel=fgetc(image->file);
X          (void) fgetc(image->file);
X          operand++;
X          p=rle_pixels+((image->rows-y-1)*image->columns*number_planes)+
X            x*number_planes+plane;
X          for (i=0; i < operand; i++)
X          {
X            if ((y < image->rows) && ((x+i) < image->columns))
X              *p=pixel;
X            p+=number_planes;
X          }
X          x+=operand;
X          break;
X        }
X        default:
X          break;
X      }
X      opcode=fgetc(image->file);
X    }
X    if (number_colormaps != 0)
X      {
X        unsigned char
X          pixel;
X
X        unsigned int
X          mask;
X
X        /*
X          Apply colormap transformation to image.
X        */
X        mask=(map_length-1);
X        p=rle_pixels;
X        for (i=0; i < image->packets; i++)
X          for (j=0; j < number_planes; j++)
X          {
X            pixel=colormap[j*map_length+(*p & mask)];
X            *p++=pixel;
X          }
X        (void) free((char *) colormap);
X      }
X    /*
X      Create image.
X    */
X    image->pixels=(RunlengthPacket *)
X      malloc((unsigned int) image->packets*sizeof(RunlengthPacket));
X    if (image->pixels == (RunlengthPacket *) NULL)
X      {
X        Warning("memory allocation error",(char *) NULL);
X        DestroyImage(image);
X        return((Image *) NULL);
X      }
X    p=rle_pixels;
X    q=image->pixels;
X    if (number_planes >= 3)
X      {
X        /*
X          Convert raster image to DirectClass runlength-encoded packets.
X        */
X        for (i=0; i < (image->columns*image->rows); i++)
X        {
X          q->red=(*p++);
X          q->green=(*p++);
X          q->blue=(*p++);
X          q->index=(unsigned short) (image->alpha ? (*p++) : 0);
X          q->length=0;
X          q++;
X        }
X      }
X    else
X      {
X        unsigned short
X          index;
X
X        /*
X          Create grayscale map.
X        */
X        image->class=PseudoClass;
X        image->colors=256;
X        image->colormap=(ColorPacket *)
X          malloc(image->colors*sizeof(ColorPacket));
X        if (image->colormap == (ColorPacket *) NULL)
X          {
X            Warning("unable to read image","memory allocation failed");
X            DestroyImage(image);
X            return((Image *) NULL);
X          }
X        for (i=0; i < image->colors; i++)
X        {
X          image->colormap[i].red=(unsigned char) i;
X          image->colormap[i].green=(unsigned char) i;
X          image->colormap[i].blue=(unsigned char) i;
X        }
X        /*
X          Convert raster image to PseudoClass runlength-encoded packets.
X        */
X        for (i=0; i < (image->columns*image->rows); i++)
X        {
X          index=(unsigned short) (*p++);
X          q->red=image->colormap[index].red;
X          q->green=image->colormap[index].green;
X          q->blue=image->colormap[index].blue;
X          q->index=index;
X          q->length=0;
X          q++;
X        }
X      }
X    (void) free((char *) rle_pixels);
X    /*
X      Proceed to next image.
X    */
X    (void) fgetc(image->file);
X    status=ReadData((char *) magick,1,2,image->file);
X    if ((status == True) && (strncmp(magick,"\122\314",2) == 0))
X      {
X        /*
X          Allocate next image structure.
X        */
X        image->next=AllocateImage("RLE");
X        if (image->next == (Image *) NULL)
X          {
X            DestroyImages(image);
X            return((Image *) NULL);
X          }
X        image->next->file=image->file;
X        (void) sprintf(image->next->filename,"%s.%u",image_info->filename,
X          image->scene+1);
X        image->next->scene=image->scene+1;
X        image->next->previous=image;
X        image=image->next;
X      }
X  } while ((status == True) && (strncmp(magick,"\122\314",2) == 0));
X  while (image->previous != (Image *) NULL)
X    image=image->previous;
X  CloseImage(image);
X  return(image);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  R e a d S U N I m a g e                                                    %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function ReadSUNImage reads a SUN image file and returns it.  It allocates
%  the memory necessary for the new Image structure and returns a pointer to
%  the new image.
%
%  The format of the ReadSUNImage routine is:
%
%      image=ReadSUNImage(image_info)
%
%  A description of each parameter follows:
%
%    o image:  Function ReadSUNImage returns a pointer to the image after
%      reading.  A null image is returned if there is a a memory shortage or
%      if the image cannot be read.
%
%    o image_info: Specifies a pointer to an ImageInfo structure.
%
%
*/
static Image *ReadSUNImage(image_info)
ImageInfo
X  *image_info;
{
#define RMT_EQUAL_RGB  1
#define RMT_NONE  0
#define RMT_RAW  2
#define RT_STANDARD  1
#define RT_ENCODED  2
#define RT_FORMAT_RGB  3
X
X  typedef struct _SUNHeader
X  {
X    unsigned long
X      magic,
X      width,
X      height,
X      depth,
X      length,
X      type,
X      maptype,
X      maplength;
X  } SUNHeader;
X
X  Image
X    *image;
X
X  register int
X    bit,
X    i,
X    x,
X    y;
X
X  register RunlengthPacket
X    *q;
X
X  register unsigned char
X    *p;
X
X  SUNHeader
X    sun_header;
X
X  unsigned char
X    *sun_data,
X    *sun_pixels;
X
X  unsigned int
X    status;
X
X  /*
X    Allocate image structure.
X  */
X  image=AllocateImage("SUN");
X  if (image == (Image *) NULL)
X    return((Image *) NULL);
X  /*
X    Open image file.
X  */
X  (void) strcpy(image->filename,image_info->filename);
X  OpenImage(image,"r");
X  if (image->file == (FILE *) NULL)
X    {
X      Warning("unable to open file",image->filename);
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  /*
X    Read SUN raster header.
X  */
X  sun_header.magic=MSBFirstReadLong(image->file);
X  do
X  {
X    /*
X      Verify SUN identifier.
X    */
X    if (sun_header.magic != 0x59a66a95)
X      {
X        Warning("not a SUN raster,",image->filename);
X        DestroyImages(image);
X        return((Image *) NULL);
X      }
X    sun_header.width=MSBFirstReadLong(image->file);
X    sun_header.height=MSBFirstReadLong(image->file);
X    sun_header.depth=MSBFirstReadLong(image->file);
X    sun_header.length=MSBFirstReadLong(image->file);
X    sun_header.type=MSBFirstReadLong(image->file);
X    sun_header.maptype=MSBFirstReadLong(image->file);
X    sun_header.maplength=MSBFirstReadLong(image->file);
X    switch (sun_header.maptype)
X    {
X      case RMT_NONE:
X      {
X        if (sun_header.depth < 24)
X          {
X            /*
X              Create linear color ramp.
X            */
X            image->colors=1 << sun_header.depth;
X            image->colormap=(ColorPacket *)
X              malloc(image->colors*sizeof(ColorPacket));
X            if (image->colormap == (ColorPacket *) NULL)
X              {
X                Warning("memory allocation error",(char *) NULL);
X                return((Image *) NULL);
X              }
X            for (i=0; i < image->colors; i++)
X            {
X              image->colormap[i].red=(255*i)/(image->colors-1);
X              image->colormap[i].green=(255*i)/(image->colors-1);
X              image->colormap[i].blue=(255*i)/(image->colors-1);
X            }
X          }
X        break;
X      }
X      case RMT_EQUAL_RGB:
X      {
X        unsigned char
X          *sun_colormap;
X
X        /*
X          Read SUN raster colormap.
X        */
X        image->colors=sun_header.maplength/3;
X        image->colormap=(ColorPacket *)
X          malloc(image->colors*sizeof(ColorPacket));
X        sun_colormap=(unsigned char *)
X          malloc(image->colors*sizeof(unsigned char));
X        if ((image->colormap == (ColorPacket *) NULL) ||
X            (sun_colormap == (unsigned char *) NULL))
X          {
X            Warning("memory allocation error",(char *) NULL);
X            DestroyImages(image);
X            return((Image *) NULL);
X          }
X        (void) ReadData((char *) sun_colormap,1,(int) image->colors,
X          image->file);
X        for (i=0; i < image->colors; i++)
X          image->colormap[i].red=sun_colormap[i];
X        (void) ReadData((char *) sun_colormap,1,(int) image->colors,
X          image->file);
X        for (i=0; i < image->colors; i++)
X          image->colormap[i].green=sun_colormap[i];
X        (void) ReadData((char *) sun_colormap,1,(int) image->colors,
X          image->file);
X        for (i=0; i < image->colors; i++)
X          image->colormap[i].blue=sun_colormap[i];
X        (void) free((char *) sun_colormap);
X        break;
X      }
X      case RMT_RAW:
X      {
X        unsigned char
X          *sun_colormap;
X
X        /*
X          Read SUN raster colormap.
X        */
X        sun_colormap=(unsigned char *)
X          malloc(sun_header.maplength*sizeof(unsigned char));
X        if (sun_colormap == (unsigned char *) NULL)
X          {
X            Warning("memory allocation error",(char *) NULL);
X            DestroyImages(image);
X            return((Image *) NULL);
X          }
X        (void) ReadData((char *) sun_colormap,1,(int) sun_header.maplength,
X          image->file);
X        (void) free((char *) sun_colormap);
X        break;
X      }
X      default:
X      {
X        Warning("colormap type is not supported",image->filename);
X        DestroyImages(image);
X        return((Image *) NULL);
X      }
X    }
X    sun_data=(unsigned char *) malloc(sun_header.length*sizeof(unsigned char));
X    if (sun_data == (unsigned char *) NULL)
X      {
X        Warning("memory allocation error",(char *) NULL);
X        DestroyImages(image);
X        return((Image *) NULL);
X      }
X    status=ReadData((char *) sun_data,1,(int) sun_header.length,image->file);
X    if (status == False)
X      {
X        Warning("unable to read image data",image_info->filename);
X        DestroyImages(image);
X        return((Image *) NULL);
X      }
X    sun_pixels=sun_data;
X    if (sun_header.type == RT_ENCODED)
X      {
X        unsigned int
X          number_pixels;
X
X        /*
X          Read run-length encoded raster pixels.
X        */
X        number_pixels=(sun_header.width+(sun_header.width % 2))*
X          sun_header.height*(((sun_header.depth-1) >> 3)+1);
X        sun_pixels=(unsigned char *)
X          malloc(number_pixels*sizeof(unsigned char));
X        if (sun_pixels == (unsigned char *) NULL)
X          {
X            Warning("memory allocation error",(char *) NULL);
X            DestroyImages(image);
X            return((Image *) NULL);
X          }
X        (void) SUNDecodeImage(sun_data,sun_pixels,
X          (unsigned int) sun_header.width,(unsigned int) sun_header.height);
X        (void) free((char *) sun_data);
X      }
X    /*
X      Create image.
X    */
X    image->alpha=(sun_header.depth == 32);
X    image->class=(sun_header.depth < 24 ? PseudoClass : DirectClass);
X    image->columns=sun_header.width;
X    image->rows=sun_header.height;
X    image->packets=image->columns*image->rows;
X    image->pixels=(RunlengthPacket *)
X      malloc((unsigned int) image->packets*sizeof(RunlengthPacket));
X    image->comments=(char *)
X      malloc((strlen(image->filename)+2048)*sizeof(char));
X    (void) sprintf(image->comments,
X      "\n  Imported from SUN raster image:  %s\n",image->filename);
X    if ((image->pixels == (RunlengthPacket *) NULL) ||
X        (image->comments == (char *) NULL))
X      {
X        Warning("memory allocation error",(char *) NULL);
X        DestroyImages(image);
X        return((Image *) NULL);
X      }
X    /*
X      Convert SUN raster image to runlength-encoded packets.
X    */
X    p=sun_pixels;
X    q=image->pixels;
X    if (sun_header.depth == 1)
X      for (y=0; y < image->rows; y++)
X      {
X        /*
X          Convert bitmap scanline to runlength-encoded color packets.
X        */
X        for (x=0; x < (image->columns >> 3); x++)
X        {
X          for (bit=7; bit >= 0; bit--)
X          {
X            q->index=((*p) & (0x01 << bit) ? 0x00 : 0x01);
X            q->length=0;
X            q++;
X          }
X          p++;
X        }
X        if ((image->columns % 8) != 0)
X          {
X            for (bit=7; bit >= (8-(image->columns % 8)); bit--)
X            {
X              q->index=((*p) & (0x01 << bit) ? 0x00 : 0x01);
X              q->length=0;
X              q++;
X            }
X            p++;
X          }
X        if ((((image->columns/8)+(image->columns % 8 ? 1 : 0)) % 2) != 0)
X          p++;
X      }
X    else
X      if (image->class == PseudoClass)
X        for (y=0; y < image->rows; y++)
X        {
X          /*
X            Convert PseudoColor scanline to runlength-encoded color packets.
X          */
X          for (x=0; x < image->columns; x++)
X          {
X            q->index=(*p++);
X            q->length=0;
X            q++;
X          }
X          if ((image->columns % 2) != 0)
X            p++;
X        }
X      else
X        for (y=0; y < image->rows; y++)
X        {
X          /*
X            Convert DirectColor scanline to runlength-encoded color packets.
X          */
X          for (x=0; x < image->columns; x++)
X          {
X            q->index=(unsigned short) (image->alpha ? (*p++) : 0);
X            if (sun_header.type == RT_STANDARD)
X              {
X                q->blue=(*p++);
X                q->green=(*p++);
X                q->red=(*p++);
X              }
X            else
X              {
X                q->red=(*p++);
X                q->green=(*p++);
X                q->blue=(*p++);
X              }
X            if (image->colors != 0)
X              {
X                q->red=image->colormap[q->red].red;
X                q->green=image->colormap[q->green].green;
X                q->blue=image->colormap[q->blue].blue;
X              }
X            q->length=0;
X            q++;
X          }
X          if (((image->columns % 2) != 0) && (image->alpha == False))
X            p++;
X        }
X    (void) free((char *) sun_pixels);
X    if (image->class == PseudoClass)
X      {
X        SyncImage(image);
X        CompressColormap(image);
X      }
X    /*
X      Proceed to next image.
X    */
X    sun_header.magic=MSBFirstReadLong(image->file);
X    if (sun_header.magic == 0x59a66a95)
X      {
X        /*
X          Allocate image structure.
X        */
X        image->next=AllocateImage("SUN");
X        if (image->next == (Image *) NULL)
X          {
X            DestroyImages(image);
X            return((Image *) NULL);
X          }
X        image->next->file=image->file;
X        (void) sprintf(image->next->filename,"%s.%u",image_info->filename,
X          image->scene+1);
X        image->next->scene=image->scene+1;
X        image->next->previous=image;
X        image=image->next;
X      }
X  } while (sun_header.magic == 0x59a66a95);
X  while (image->previous != (Image *) NULL)
X    image=image->previous;
X  CloseImage(image);
X  return(image);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  R e a d T A R G A I m a g e                                                %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function ReadTARGAImage reads a Truevision Targa image file and returns
%  it.  It allocates the memory necessary for the new Image structure and
%  returns a pointer to the new image.
%
%  The format of the ReadTARGAImage routine is:
%
%      image=ReadTARGAImage(image_info)
%
%  A description of each parameter follows:
%
%    o image:  Function ReadTARGAImage returns a pointer to the image after
%      reading.  A null image is returned if there is a a memory shortage or
%      if the image cannot be read.
%
%    o image_info: Specifies a pointer to an ImageInfo structure.
%
%
*/
static Image *ReadTARGAImage(image_info)
ImageInfo
X  *image_info;
{
#define TargaColormap 1
#define TargaRGB 2
#define TargaMonochrome 3
#define TargaRLEColormap  9
#define TargaRLERGB  10
#define TargaRLEMonochrome  11
X
X  typedef struct _TargaHeader
X  {
X    unsigned char
X      id_length,
X      colormap_type,
X      image_type;
X
X    unsigned short
X      colormap_index,
X      colormap_length;
X
X    unsigned char
X      colormap_size;
X
X    unsigned short
X      x_origin,
X      y_origin,
X      width,
X      height;
X
X    unsigned char
X      pixel_size,
X      attributes;
X  } TargaHeader;
X
X  Image
X    *image;
X
X  register int
X    i,
X    x,
X    y;
X
X  register RunlengthPacket
X    *q;
X
X  TargaHeader
X    targa_header;
X
X  unsigned char
X    blue,
X    green,
X    j,
X    k,
X    red,
X    runlength;
X
X  unsigned int
X    base,
X    flag,
X    real,
X    skip,
X    status,
X    true;
X
X  unsigned short
X    index;
X
X  /*
X    Allocate image structure.
X  */
X  image=AllocateImage("TGA");
X  if (image == (Image *) NULL)
X    return((Image *) NULL);
X  /*
X    Open image file.
X  */
X  (void) strcpy(image->filename,image_info->filename);
X  OpenImage(image,"r");
X  if (image->file == (FILE *) NULL)
X    {
X      Warning("unable to open file",image->filename);
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  /*
X    Determine if this is a TARGA file.
X  */
X  status=ReadData((char *) &targa_header.id_length,1,1,image->file);
X  do
X  {
X    /*
X      Read TARGA header information.
X    */
X    if (status == False)
X      {
X        Warning("not a TARGA image file",(char *) NULL);
X        DestroyImages(image);
X        return((Image *) NULL);
X      }
X    targa_header.colormap_type=fgetc(image->file);
X    targa_header.image_type=fgetc(image->file);
X    targa_header.colormap_index=LSBFirstReadShort(image->file);
X    targa_header.colormap_length=LSBFirstReadShort(image->file);
X    targa_header.colormap_size=fgetc(image->file);
X    targa_header.x_origin=LSBFirstReadShort(image->file);
X    targa_header.y_origin=LSBFirstReadShort(image->file);
X    targa_header.width=LSBFirstReadShort(image->file);
X    targa_header.height=LSBFirstReadShort(image->file);
X    targa_header.pixel_size=fgetc(image->file);
X    targa_header.attributes=fgetc(image->file);
X    /*
X      Create image.
X    */
X    image->alpha=targa_header.pixel_size == 32;
X    image->columns=targa_header.width;
X    image->rows=targa_header.height;
X    image->packets=image->columns*image->rows;
X    image->pixels=(RunlengthPacket *)
X      malloc((unsigned int) image->packets*sizeof(RunlengthPacket));
X    if (targa_header.id_length != 0)
X      image->comments=(char *)
X        malloc((targa_header.id_length+1)*sizeof(char));
X    else
X      image->comments=(char *)
X        malloc((strlen(image->filename)+2048)*sizeof(char));
X    if ((image->pixels == (RunlengthPacket *) NULL) ||
X        (image->comments == (char *) NULL))
X      {
X        Warning("memory allocation error",(char *) NULL);
X        DestroyImages(image);
X        return((Image *) NULL);
X      }
X    if (targa_header.id_length == 0)
X      (void) sprintf(image->comments,
X        "\n  Imported from TARGA raster image:  %s\n",image->filename);
X    else
X      {
X        (void) ReadData(image->comments,1,targa_header.id_length,image->file);
X        image->comments[targa_header.id_length]='\0';
X      }
X    red=0;
X    green=0;
X    blue=0;
X    if (targa_header.colormap_type != 0)
X      {
X        /*
X          Read TARGA raster colormap.
X        */
X        image->class=PseudoClass;
X        image->colors=targa_header.colormap_length;
X        image->colormap=(ColorPacket *)
X          malloc(image->colors*sizeof(ColorPacket));
X        if (image->colormap == (ColorPacket *) NULL)
X          {
X            Warning("memory allocation error",(char *) NULL);
X            DestroyImages(image);
X            return((Image *) NULL);
X          }
X        for (i=0; i < image->colors; i++)
X        {
X          switch (targa_header.colormap_size)
X          {
X            case 8:
X            default:
X            {
X              /*
X                Gray scale.
X              */
X              red=fgetc(image->file);
X              green=red;
X              blue=red;
X              break;
X            }
X            case 15:
X            case 16:
X            {
X              /*
X                5 bits each of red green and blue.
X              */
X              j=fgetc(image->file);
X              k=fgetc(image->file);
X              red=(unsigned char) (k & 0x7C) >> 2;
X              green=((unsigned char) (k & 0x03) << 3)+
X                ((unsigned char) (j & 0xE0) >> 5);
X              blue=j & 0x1F;
X              break;
X            }
X            case 32:
X            case 24:
X            {
X              /*
X                8 bits each of blue green and red.
X              */
X              blue=fgetc(image->file);
X              green=fgetc(image->file);
X              red=fgetc(image->file);
X              break;
X            }
X          }
X          image->colormap[i].red=red;
X          image->colormap[i].green=green;
X          image->colormap[i].blue=blue;
X        }
X      }
X    /*
X      Convert TARGA pixels to runlength-encoded packets.
X    */
X    base=0;
X    flag=0;
X    index=0;
X    skip=False;
X    real=0;
X    runlength=0;
X    true=0;
X    for (y=0; y < image->rows; y++)
X    {
X      real=true;
X      if (((unsigned char) (targa_header.attributes & 0x20) >> 5) == 0)
X        real=image->rows-real-1;
X      q=image->pixels+(real*image->columns)-1;
X      for (x=0; x < image->columns; x++)
X      {
X        if ((targa_header.image_type == TargaRLEColormap) ||
X            (targa_header.image_type == TargaRLERGB) ||
X            (targa_header.image_type == TargaRLEMonochrome))
X          if (runlength != 0)
X            {
X              runlength--;
X              skip=flag != 0;
X            }
X          else
X            {
X              status=ReadData((char *) &runlength,1,1,image->file);
X              if (status == False)
X                {
X                  Warning("unable to read image data",image_info->filename);
X                  DestroyImages(image);
X                  return((Image *) NULL);
X                }
X              flag=runlength & 0x80;
X              if (flag != 0)
X                runlength-=128;
X              skip=False;
X            }
X        if (!skip)
X          switch (targa_header.pixel_size)
X          {
X            case 8:
X            default:
X            {
X              /*
X                Gray scale.
X              */
X              index=fgetc(image->file);
X              if (targa_header.colormap_type == 0)
X                {
X                  red=index;
X                  green=index;
X                  blue=index;
X                }
X              else
X                {
X                  red=image->colormap[index].red;
X                  green=image->colormap[index].green;
X                  blue=image->colormap[index].blue;
X                }
X              break;
X            }
X            case 15:
X            case 16:
X            {
X              /*
X                5 bits each of red green and blue.
X              */
X              j=fgetc(image->file);
X              k=fgetc(image->file);
X              red=(unsigned char) (k & 0x7C) >> 2;
X              green=((unsigned char) (k & 0x03) << 3)+
X                ((unsigned char) (j & 0xE0) >> 5);
X              blue=j & 0x1F;
X              break;
X            }
X            case 32:
X            case 24:
X            {
X              /*
X                8 bits each of blue green and red.
X              */
X              blue=fgetc(image->file);
X              green=fgetc(image->file);
X              red=fgetc(image->file);
X              if (targa_header.pixel_size == 32)
X                index=fgetc(image->file);
X              break;
X            }
X          }
X        if (status == False)
X          {
X            Warning("unable to read image data",image_info->filename);
X            DestroyImages(image);
X            return((Image *) NULL);
X          }
X        q->red=red;
X        q->green=green;
X        q->blue=blue;
X        q->index=index;
X        q->length=0;
X        q++;
X      }
X      if (((unsigned char) (targa_header.attributes & 0xc0) >> 6) == 4)
X        true+=4;
X      else
X        if (((unsigned char) (targa_header.attributes & 0xc0) >> 6) == 2)
X          true+=2;
X        else
X          true++;
X      if (true >= image->rows)
X        {
X          base++;
X          true=base;
X        }
X    }
X    if ((targa_header.image_type == TargaMonochrome) ||
X        (targa_header.image_type == TargaRLEMonochrome))
X      QuantizeImage(image,2,8,False,GRAYColorspace,True);
X    /*
X      Proceed to next image.
X    */
X    status=ReadData((char *) &targa_header.id_length,1,1,image->file);
X    if (status == True)
X      {
X        /*
X          Allocate image structure.
X        */
X        image->next=AllocateImage("TGA");
X        if (image->next == (Image *) NULL)
X          {
X            DestroyImages(image);
X            return((Image *) NULL);
X          }
X        image->next->file=image->file;
X        (void) sprintf(image->next->filename,"%s.%u",image_info->filename,
X          image->scene+1);
X        image->next->scene=image->scene+1;
X        image->next->previous=image;
X        image=image->next;
X      }
X  } while (status == True);
X  while (image->previous != (Image *) NULL)
X    image=image->previous;
X  CloseImage(image);
X  return(image);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  R e a d T E X T I m a g e                                                  %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function ReadTEXTImage reads a text file and returns it as an image.  It
%  allocates the memory necessary for the new Image structure and returns a
%  pointer to the new image.
%
%  The format of the ReadTEXTImage routine is:
%
%      image=ReadTEXTImage(image_info)
%
%  A description of each parameter follows:
%
%    o image:  Function ReadTEXTImage returns a pointer to the image after
%      reading. A null image is returned if there is a a memory shortage or if
%      the image cannot be read.
%
%    o image_info: Specifies a pointer to an ImageInfo structure.
%
%
*/
static Image *ReadTEXTImage(image_info)
ImageInfo
X  *image_info;
{
#define PageHeight  60
#define PageWidth  80
X
X  char
X    *resource_value,
X    *text_status,
X    text[2048];
X
X  Display
X    *display;
X
X  Image
X    *image;
X
X  int
X    status,
X    x,
X    y;
X
X  register int
X    i;
X
X  register RunlengthPacket
X    *p;
X
X  RunlengthPacket
X    background_color;
X
X  unsigned int
X    height,
X    width;
X
X  XAnnotateInfo
X    annotate_info;
X
X  XFontStruct
X    *font_info;
X
X  XPixelInfo
X    pixel_info;
X
X  XResourceInfo
X    resource_info;
X
X  XrmDatabase
X    resource_database,
X    server_database;
X
X  XStandardColormap
X    map_info;
X
X  XVisualInfo
X    *visual_info;
X
X  XWindowInfo
X    image_window;
X
X  /*
X    Allocate image structure.
X  */
X  image=AllocateImage("TEXT");
X  if (image == (Image *) NULL)
X    return((Image *) NULL);
X  /*
X    Open image file.
X  */
X  (void) strcpy(image->filename,image_info->filename);
X  OpenImage(image,"r");
X  if (image->file == (FILE *) NULL)
X    {
X      Warning("unable to open file",image->filename);
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  /*
X    Open X server connection.
X  */
X  display=XOpenDisplay(image_info->server_name);
X  if (display == (Display *) NULL)
X    {
X      Warning("unable to connect to X server",
X        XDisplayName(image_info->server_name));
X      return((Image *) NULL);
X    }
X  /*
X    Set our forgiving error handler.
X  */
X  XSetErrorHandler(XError);
X  /*
X    Initialize resource database.
X  */
X  XrmInitialize();
X  resource_database=XrmGetDatabase(display);
X  resource_value=XResourceManagerString(display);
X  if (resource_value == (char *) NULL)
X    resource_value="";
X  server_database=XrmGetStringDatabase(resource_value);
X  XrmMergeDatabases(server_database,&resource_database);
X  /*
X    Get user defaults from X resource database.
X  */
X  XGetResourceInfo(resource_database,client_name,&resource_info);
X  /*
X    Initialize visual info.
X  */
X  visual_info=XBestVisualInfo(display,"default",(char *) NULL,
X    (XStandardColormap *) NULL);
X  if (visual_info == (XVisualInfo *) NULL)
X    {
X      Warning("unable to get visual",resource_info.visual_type);
X      return((Image *) NULL);
X    }
X  /*
X    Determine background and foreground colors.
X  */
X  map_info.colormap=XDefaultColormap(display,visual_info->screen);
X  XGetPixelInfo(display,visual_info,&map_info,&resource_info,(Image *) NULL,
X    &pixel_info);
X  pixel_info.annotate_color=pixel_info.foreground_color;
X  pixel_info.annotate_index=1;
X  /*
X    Initialize font info.
X  */
X  if (image_info->font != (char *) NULL)
X    resource_info.font=image_info->font;
X  font_info=XBestFont(display,&resource_info,(char *) NULL,~0);
X  if (font_info == (XFontStruct *) NULL)
X    {
X      Warning("unable to load font",resource_info.font);
X      return((Image *) NULL);
X    }
X  /*
X    Window superclass.
X  */
X  image_window.id=XRootWindow(display,visual_info->screen);
X  image_window.screen=visual_info->screen;
X  image_window.depth=visual_info->depth;
X  image_window.visual_info=visual_info;
X  image_window.pixel_info=(&pixel_info);
X  image_window.font_info=font_info;
X  /*
X    Initialize Image structure.
X  */
X  width=PageWidth;
X  height=PageHeight;
X  if (image_info->density != (char *) NULL)
X    {
X      int
X        flags;
X
X      /*
X        User specified density.
X      */
X      flags=XParseGeometry(image_info->density,&x,&y,&width,&height);
X      if ((flags & WidthValue) == 0)
X        width=PageWidth;
X      if ((flags & HeightValue) == 0)
X        height=width;
X    }
X  image->columns=width*font_info->max_bounds.width+4;
X  image->rows=height*
X    (font_info->max_bounds.ascent+font_info->max_bounds.descent)+4;
X  image->packets=image->columns*image->rows;
X  image->pixels=(RunlengthPacket *)
X    malloc((unsigned int) image->packets*sizeof(RunlengthPacket));
X  image->comments=(char *) malloc((strlen(image->filename)+2048)*sizeof(char));
X  if ((image->pixels == (RunlengthPacket *) NULL) ||
X      (image->comments == (char *) NULL))
X    {
X      Warning("unable to allocate image","memory allocation error");
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  (void) sprintf(image->comments,"\n  Imported from text file:  %s\n",
X    image->filename);
X  /*
X    Create colormap.
X  */
X  image->colors=2;
X  image->colormap=(ColorPacket *) malloc(image->colors*sizeof(ColorPacket));
X  if (image->colormap == (ColorPacket *) NULL)
X    {
X      Warning("unable to read image","memory allocation failed");
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  image->colormap[0].red=pixel_info.background_color.red >> 8;
X  image->colormap[0].green=pixel_info.background_color.green >> 8;
X  image->colormap[0].blue=pixel_info.background_color.blue >> 8;
X  image->colormap[1].red=pixel_info.foreground_color.red >> 8;
X  image->colormap[1].green=pixel_info.foreground_color.green >> 8;
X  image->colormap[1].blue=pixel_info.foreground_color.blue >> 8;
X  /*
X    Initialize text image to background color.
X  */
X  background_color.red=image->colormap[0].red;
X  background_color.green=image->colormap[0].green;
X  background_color.blue=image->colormap[0].blue;
X  background_color.index=0;
X  background_color.length=0;
X  p=image->pixels;
X  for (i=0; i < image->packets; i++)
X    *p++=background_color;
X  /*
X    Annotate the text image.
X  */
X  XGetAnnotateInfo(&annotate_info);
X  annotate_info.font_info=font_info;
X  annotate_info.text=(char *)
X    malloc((image->columns/Max(font_info->min_bounds.width,1)+2)*sizeof(char));
X  if (annotate_info.text == (char *) NULL)
X    {
X      Warning("unable to read image","memory allocation failed");
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  image->colormap[0].red=pixel_info.background_color.red >> 8;
X  annotate_info.height=font_info->ascent+font_info->descent;
X  x=0;
X  y=0;
X  text[sizeof(text)-1]='\0';
X  text_status=fgets(text,sizeof(text)-1,image->file);
X  if ((int) strlen(text) > 0)
X    text[strlen(text)-1]='\0';
X  while (text_status != (char *) NULL)
X  {
X    *annotate_info.text='\0';
X    if (*text != '\0')
X      {
X        /*
X          Compute width of text.
X        */
X        (void) strcpy(annotate_info.text,text);
X        annotate_info.width=
X          XTextWidth(font_info,annotate_info.text,strlen(annotate_info.text));
X        if ((annotate_info.width+4) >= image->columns)
X          {
X            /*
X              Reduce text until width is within bounds.
X            */
X            i=strlen(annotate_info.text);
X            for (; (annotate_info.width+4) >= image->columns; i--)
X              annotate_info.width=XTextWidth(font_info,annotate_info.text,
X                (unsigned int) i);
X            annotate_info.text[i]='\0';
X            while ((i > 0) && !isspace(annotate_info.text[i]))
X              i--;
X            if (i > 0)
X              annotate_info.text[i]='\0';
X            annotate_info.width=XTextWidth(font_info,annotate_info.text,
X              strlen(annotate_info.text));
X          }
X        /*
X          Annotate image with text.
X        */
X        (void) sprintf(annotate_info.geometry,"%ux%u%+d%+d",
X          annotate_info.width,annotate_info.height,x+2,y+2);
X        status=XAnnotateImage(display,&image_window,&annotate_info,False,image);
X        if (status == 0)
X          {
X            Warning("unable to annotate image","memory allocation error");
X            DestroyImage(image);
X            return((Image *) NULL);
X          }
X      }
X    /*
X      Get next string.
X    */
X    if (strlen(text) != strlen(annotate_info.text))
X      (void) strcpy(text,text+strlen(annotate_info.text)+1);
X    else
X      {
X        text_status=fgets(text,sizeof(text)-1,image->file);
X        if ((int) strlen(text) > 0)
X          text[strlen(text)-1]='\0';
X      }
X    y+=annotate_info.height;
X    if ((text_status != (char *) NULL) &&
X        ((y+font_info->ascent+4) > image->rows))
X      {
X        /*
X          Page is full-- allocate next image structure.
X        */
X        image->orphan=True;
X        image->next=CopyImage(image,image->columns,image->rows,False);
X        image->orphan=False;
X        if (image->next == (Image *) NULL)
X          {
X            DestroyImages(image);
X            return((Image *) NULL);
X          }
X        (void) sprintf(image->next->filename,"%s.%u",image_info->filename,
X          image->scene+1);
X        image->next->scene=image->scene+1;
X        image->next->previous=image;
X        image=image->next;
X        /*
X          Initialize text image to background color.
X        */
X        p=image->pixels;
X        for (i=0; i < image->packets; i++)
X          *p++=background_color;
X        y=0;
X      }
X  }
X  /*
X    Free resources.
X  */
X  (void) free((char *) annotate_info.text);
X  XFreeFont(display,font_info);
X  XFree((void *) visual_info);
X  /*
X    Force to runlength-encoded PseudoClass image.
X  */
X  while (image->previous != (Image *) NULL)
X  {
X    image->class=PseudoClass;
X    image=image->previous;
X  }
X  image->class=PseudoClass;
X  CloseImage(image);
X  XCloseDisplay(display);
X  return(image);
}
X
#ifdef HasTIFF
#include "tiff.h"
#include "tiffio.h"
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%  R e a d T I F F I m a g e                                                  %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function ReadTIFFImage reads a Tagged image file and returns it.  It
%  allocates the memory necessary for the new Image structure and returns a
%  pointer to the new image.
%
%  The format of the ReadTIFFImage routine is:
%
%      image=ReadTIFFImage(image_info)
%
%  A description of each parameter follows:
%
%    o image:  Function ReadTIFFImage returns a pointer to the image after
%      reading.  A null image is returned if there is a a memory shortage or
%      if the image cannot be read.
%
%    o image_info: Specifies a pointer to an ImageInfo structure.
%
%
*/
static Image *ReadTIFFImage(image_info)
ImageInfo
X  *image_info;
{
X  Image
X    *image;
X
X  int
X    range;
X
X  register int
X    i,
X    quantum,
X    x,
X    y;
X
X  register RunlengthPacket
X    *q;
X
X  TIFF
X    *tiff;
X
X  unsigned int
X    status;
X
X  unsigned long
X    height,
X    width;
X
X  unsigned short
X    bits_per_sample,
X    max_sample_value,
X    min_sample_value,
X    photometric,
X    samples_per_pixel;
X
X  /*
X    Allocate image structure.
X  */
X  image=AllocateImage("TIFF");
X  if (image == (Image *) NULL)
X    return((Image *) NULL);
X  /*
X    Open TIFF image tiff.
X  */
X  (void) strcpy(image->filename,image_info->filename);
X  tiff=TIFFOpen(image->filename,"r");
X  if (tiff == (TIFF *) NULL)
X    {
X      Warning("unable to open tiff image",image->filename);
X      DestroyImage(image);
X      return((Image *) NULL);
X    }
X  do
X  {
X    if (image_info->verbose)
X      TIFFPrintDirectory(tiff,stderr,False);
X    /*
X      Allocate memory for the image and pixel buffer.
X    */
X    TIFFGetField(tiff,TIFFTAG_IMAGEWIDTH,&width);
X    TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&height);
X    for (quantum=1; quantum <= 16; quantum<<=1)
X    {
X      image->columns=width/quantum;
X      image->rows=height/quantum;
X      image->packets=image->columns*image->rows;
X      image->pixels=(RunlengthPacket *)
X        malloc((unsigned int) image->packets*sizeof(RunlengthPacket));
X      if ((image->pixels != (RunlengthPacket *) NULL))
X        break;
X    }
X    image->comments=(char *)
X      malloc((strlen(image->filename)+2048)*sizeof(char));
X    if ((image->pixels == (RunlengthPacket *) NULL) ||
X        (image->comments == (char *) NULL))
X      {
X        Warning("unable to allocate memory",(char *) NULL);
X        DestroyImages(image);
X        TIFFClose(tiff);
X        return((Image *) NULL);
X      }
X    (void) sprintf(image->comments,"\n  Imported from TIFF image %s.\n",
X      image->filename);
X    TIFFGetFieldDefaulted(tiff,TIFFTAG_BITSPERSAMPLE,&bits_per_sample);
X    TIFFGetFieldDefaulted(tiff,TIFFTAG_MINSAMPLEVALUE,&min_sample_value);
X    TIFFGetFieldDefaulted(tiff,TIFFTAG_MAXSAMPLEVALUE,&max_sample_value);
X    TIFFGetFieldDefaulted(tiff,TIFFTAG_PHOTOMETRIC,&photometric);
X    TIFFGetFieldDefaulted(tiff,TIFFTAG_SAMPLESPERPIXEL,&samples_per_pixel);
X    range=max_sample_value-min_sample_value;
X    if ((bits_per_sample > 8) || (samples_per_pixel > 1) || TIFFIsTiled(tiff))
X      {
X        register unsigned long
SHAR_EOF
true || echo 'restore of ImageMagick/decode.c failed'
fi
echo 'End of ImageMagick part 16'
echo 'File ImageMagick/decode.c is continued in part 17'
echo 17 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
