Newsgroups: comp.sources.x
From: cristy@eplrx7.es.duPont.com (Cristy)
Subject: v20i079:  imagemagic - X11 image processing and display, Part23/38
Message-ID: <1993Jul14.231928.22107@sparky.sterling.com>
X-Md4-Signature: 5838ce95e458d010445ee51cc81e264f
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Wed, 14 Jul 1993 23:19:28 GMT
Approved: chris@sterling.com

Submitted-by: cristy@eplrx7.es.duPont.com (Cristy)
Posting-number: Volume 20, Issue 79
Archive-name: imagemagic/part23
Environment: X11
Supersedes: imagemagic: Volume 13, Issue 17-37

#!/bin/sh
# this is magick.23 (part 23 of ImageMagick)
# do not concatenate these parts, unpack them in order with /bin/sh
# file ImageMagick/display.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 23; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping ImageMagick/display.c'
else
echo 'x - continuing file ImageMagick/display.c'
sed 's/^X//' << 'SHAR_EOF' >> 'ImageMagick/display.c' &&
X
X      /*
X        User specified geometry.
X      */
X      size_hints=XAllocSizeHints();
X      if (size_hints == (XSizeHints *) NULL)
X        Error("unable to display on root","memory allocation failed");
X      size_hints->flags=(long) NULL;
X      (void) sprintf(default_geometry,"%ux%u",width,height);
X      flags=XWMGeometry(display,visual_info->screen,
X        resource_info->image_geometry,default_geometry,
X        window_info.border_width,size_hints,&window_info.x,&window_info.y,
X        (int *) &width,(int *) &height,&gravity);
X      if (flags & (XValue | YValue))
X        {
X          width=XDisplayWidth(display,visual_info->screen);
X          height=XDisplayHeight(display,visual_info->screen);
X        }
X      XFree((void *) size_hints);
X    }
X  /*
X    Create the root pixmap.
X  */
X  window_info.pixmap=
X    XCreatePixmap(display,window_info.id,width,height,window_info.depth);
X  if (window_info.pixmap == (Pixmap) NULL)
X    Error("unable to create X pixmap",(char *) NULL);
X  /*
X    Display pixmap on the root window.
X  */
X  if ((width > window_info.width) || (height > window_info.height))
X    XFillRectangle(display,window_info.pixmap,window_info.highlight_context,
X      0,0,width,height);
X  XPutImage(display,window_info.pixmap,window_info.graphic_context,
X    window_info.ximage,0,0,window_info.x,window_info.y,window_info.width,
X    window_info.height);
X  XSetWindowBackgroundPixmap(display,window_info.id,window_info.pixmap);
X  XClearWindow(display,window_info.id);
X  /*
X    Free resources.
X  */
X  XFreePixmap(display,window_info.pixmap);
X  XDestroyImage(window_info.ximage);
X  XFreeGC(display,window_info.graphic_context);
X  XFreeGC(display,window_info.highlight_context);
X  XFreeCursor(display,window_info.cursor);
X  XFreeCursor(display,window_info.busy_cursor);
X  if (pixel_info.pixels != (unsigned long *) NULL)
X    (void) free((char *) pixel_info.pixels);
X  XFree((void *) map_info);
X  XFree((void *) visual_info);
X  /*
X    Put property on root window and set close-down mode to RetainPermanent.
X  */
X  window_info.pixmap=XCreatePixmap(display,root_window,1,1,1);
X  if (window_info.pixmap == (Pixmap) NULL)
X    Error("unable to create X pixmap",(char *) NULL);
X  XChangeProperty(display,root_window,property,XA_PIXMAP,32,PropModeReplace,
X    (unsigned char *) &window_info.pixmap,1);
X  XSetCloseDownMode(display,RetainPermanent);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   X D i s p l a y I m a g e                                                 %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function XDisplayImage displays an image via X11.  A new image is created
%  and returned if the user interactively transforms the displayed image.
%
%  The format of the XDisplayImage routine is:
%
%      loaded_image=XDisplayImage(display,resource_info,argv,argc,image,state)
%
%  A description of each parameter follows:
%
%    o loaded_image:  Function XDisplayImage returns an image when the
%      user chooses 'Load Image' from the command menu or picks a tile
%      from the image directory.  Otherwise a null image is returned.
%
%    o display: Specifies a connection to an X server;  returned from
%      XOpenDisplay.
%
%    o resource_info: Specifies a pointer to a X11 XResourceInfo structure.
%
%    o argv: Specifies the application's argument list.
%
%    o argc: Specifies the number of arguments.
%
%    o image: Specifies an address to an address of an Image structure;
%      returned from ReadImage.
%
%
*/
static Image *XDisplayImage(display,resource_info,argv,argc,image,state)
Display
X  *display;
X
XXResourceInfo
X  *resource_info;
X
char
X  **argv;
X
int
X  argc;
X
Image
X  **image;
X
unsigned long
X  *state;
{
#define MagnifySize  256  /* must be a power of 2 */
#define MaxPanSize  96
#define MaxWindows  9
X
X  char
X    command[2048],
X    text[2048];
X
X  Image
X    *displayed_image,
X    *loaded_image;
X
X  int
X    status;
X
X  KeySym
X    key_symbol;
X
X  register int
X    i;
X
X  static Atom
X    delete_property,
X    protocols_property;
X
X  static Window
X    root_window;
X
X  static XClassHint
X    *class_hint;
X
X  static XPixelInfo
X    pixel_info;
X
X  static XStandardColormap
X    *map_info;
X
X  static XVisualInfo
X    *visual_info = (XVisualInfo *) NULL;
X
X  static XWindowInfo
X    *magick_windows[MaxWindows];
X
X  static XWindows
X    *window;
X
X  static XWMHints
X    *manager_hints;
X
X  static unsigned int
X    number_windows;
X
X  struct stat
X    file_info;
X
X  time_t
X    update_time,
X    timer;
X
X  unsigned int
X    scale_factor;
X
X  XEvent
X    event;
X
X  XFontStruct
X    *font_info;
X
X  XGCValues
X    graphic_context_value;
X
X  XWindowInfo
X    previous_window;
X
X  if (visual_info == (XVisualInfo *) NULL)
X    {
X      /*
X        Allocate standard colormap.
X      */
X      if (resource_info->debug)
X        XSynchronize(display,True);
X      map_info=XAllocStandardColormap();
X      if (map_info == (XStandardColormap *) NULL)
X        Error("unable to create standard colormap","memory allocation failed");
X      map_info->colormap=(Colormap) NULL;
X      pixel_info.pixels=(unsigned long *) NULL;
X      /*
X        Allocate visual.
X      */
X      visual_info=XBestVisualInfo(display,resource_info->visual_type,
X        resource_info->map_type,map_info);
X      if (visual_info == (XVisualInfo *) NULL)
X        Error("unable to get visual",resource_info->visual_type);
X      if (resource_info->debug)
X        {
X          (void) fprintf(stderr,"Visual:\n");
X          (void) fprintf(stderr,"  visual id: 0x%lx\n",visual_info->visualid);
X          (void) fprintf(stderr,"  class: %s\n",XVisualClassName(visual_info));
X          (void) fprintf(stderr,"  depth: %d planes\n",visual_info->depth);
X          (void) fprintf(stderr,"  size of colormap: %d entries\n",
X            visual_info->colormap_size);
X          (void) fprintf(stderr,"  red, green, blue masks: 0x%lx 0x%lx 0x%lx\n",
X            visual_info->red_mask,visual_info->green_mask,
X            visual_info->blue_mask);
X          (void) fprintf(stderr,"  significant bits in color: %d bits\n",
X            visual_info->bits_per_rgb);
X        }
X      /*
X        Allocate atoms.
X      */
X      protocols_property=XInternAtom(display,"WM_PROTOCOLS",False);
X      delete_property=XInternAtom(display,"WM_DELETE_WINDOW",False);
X      if ((protocols_property == (Atom) NULL) ||
X          (delete_property == (Atom) NULL))
X        Error("unable to create property",(char *) NULL);
X      /*
X        Allocate class and manager hints.
X      */
X      class_hint=XAllocClassHint();
X      manager_hints=XAllocWMHints();
X      if ((class_hint == (XClassHint *) NULL) ||
X          (manager_hints == (XWMHints *) NULL))
X        Error("unable to allocate X hints",(char *) NULL);
X      /*
X        Initialize window id's.
X      */
X      root_window=XRootWindow(display,visual_info->screen);
X      window=(XWindows *) malloc(sizeof(XWindows));
X      if (window == (XWindows *) NULL)
X        Error("unable to create X windows","memory allocation failed");
X      number_windows=0;
X      magick_windows[number_windows++]=(&window->backdrop);
X      magick_windows[number_windows++]=(&window->icon);
X      magick_windows[number_windows++]=(&window->image);
X      magick_windows[number_windows++]=(&window->info);
X      magick_windows[number_windows++]=(&window->magnify);
X      magick_windows[number_windows++]=(&window->pan);
X      magick_windows[number_windows++]=(&window->popup);
X      for (i=0; i < number_windows; i++)
X        magick_windows[i]->id=(Window) NULL;
X    }
X  /*
X    Initialize Standard Colormap.
X  */
X  loaded_image=(Image *) NULL;
X  displayed_image=(*image);
X  if (resource_info->debug)
X    {
X      (void) fprintf(stderr,"Image: [%u] %s %ux%u ",displayed_image->scene,
X        displayed_image->filename,displayed_image->columns,
X        displayed_image->rows);
X      if (displayed_image->colors != 0)
X        (void) fprintf(stderr,"%uc ",displayed_image->colors);
X      (void) fprintf(stderr,"%s\n",displayed_image->magick);
X    }
X  XMakeStandardColormap(display,visual_info,resource_info,&pixel_info,
X    displayed_image,map_info);
X  /*
X    Initialize font info.
X  */
X  (void) sprintf(text," [%u] %s %ux%u %s ",displayed_image->scene,
X    displayed_image->filename,displayed_image->columns,displayed_image->rows,
X    XVisualClassName(visual_info));
X  if (displayed_image->colors != 0)
X    (void) sprintf(text,"%s%uc ",text,displayed_image->colors);
X  font_info=XBestFont(display,resource_info,text,displayed_image->columns);
X  if (font_info == (XFontStruct *) NULL)
X    Error("unable to load font",resource_info->font);
X  /*
X    Initialize class hints.
X  */
X  if (resource_info->name == (char *) NULL)
X    class_hint->res_name=client_name;
X  else
X    class_hint->res_name=resource_info->name;
X  class_hint->res_class=(char *) "ImageMagick";
X  /*
X    Initialize graphic context.
X  */
X  window->context.id=(Window) NULL;
X  XGetWindowInfo(display,visual_info,map_info,&pixel_info,font_info,
X    resource_info,&window->context);
X  manager_hints->flags=InputHint | StateHint;
X  manager_hints->input=False;
X  manager_hints->initial_state=WithdrawnState;
X  XMakeWindow(display,root_window,argv,argc,class_hint,manager_hints,
X    delete_property,&window->context);
X  if (resource_info->debug)
X    (void) fprintf(stderr,"Window id: 0x%lx (context)\n",window->context.id);
X  graphic_context_value.background=pixel_info.background_color.pixel;
X  graphic_context_value.foreground=pixel_info.foreground_color.pixel;
X  graphic_context_value.font=font_info->fid;
X  graphic_context_value.function=GXcopy;
X  graphic_context_value.line_width=2;
X  graphic_context_value.graphics_exposures=False;
X  graphic_context_value.plane_mask=AllPlanes;
X  pixel_info.graphic_context=XCreateGC(display,window->context.id,GCBackground |
X    GCFont | GCForeground | GCFunction | GCGraphicsExposures | GCLineWidth |
X    GCPlaneMask,&graphic_context_value);
X  if (pixel_info.graphic_context == (GC) NULL)
X    Error("unable to create graphic context",(char *) NULL);
X  graphic_context_value.background=pixel_info.foreground_color.pixel;
X  graphic_context_value.foreground=pixel_info.background_color.pixel;
X  pixel_info.highlight_context=XCreateGC(display,window->context.id,
X    GCBackground | GCFont | GCForeground | GCFunction | GCGraphicsExposures |
X    GCLineWidth | GCPlaneMask,&graphic_context_value);
X  if (pixel_info.highlight_context == (GC) NULL)
X    Error("unable to create graphic context",(char *) NULL);
X  XDestroyWindow(display,window->context.id);
X  /*
X    Initialize icon window.
X  */
X  XGetWindowInfo(display,visual_info,map_info,&pixel_info,font_info,
X    resource_info,&window->icon);
X  XBestIconSize(display,&window->icon,displayed_image);
X  window->icon.attributes.event_mask=StructureNotifyMask;
X  manager_hints->flags=InputHint | StateHint;
X  manager_hints->input=False;
X  manager_hints->initial_state=IconicState;
X  XMakeWindow(display,root_window,argv,argc,class_hint,manager_hints,
X    delete_property,&window->icon);
X  if (resource_info->debug)
X    (void) fprintf(stderr,"Window id: 0x%lx (icon)\n",window->icon.id);
X  /*
X    Initialize image window.
X  */
X  previous_window=window->image;
X  XGetWindowInfo(display,visual_info,map_info,&pixel_info,font_info,
X    resource_info,&window->image);
X  window->image.name=(char *) malloc(2048*sizeof(char));
X  window->image.icon_name=(char *) malloc(2048*sizeof(char));
X  if ((window->image.name == NULL) || (window->image.icon_name == NULL))
X    Error("unable to create image window","memory allocation failed");
X  if (resource_info->title != (char *) NULL)
X    {
X      /*
X        User specified window name.
X      */
X      (void) strcpy(window->image.name,resource_info->title);
X      (void) strcpy(window->image.icon_name,resource_info->title);
X    }
X  else
X    {
X      char
X        *p;
X
X      /*
X        Window name is the base of the filename.
X      */
X      p=displayed_image->filename+strlen(displayed_image->filename)-1;
X      while ((p > displayed_image->filename) && (*(p-1) != '/'))
X        p--;
X      (void) strcpy(window->image.name,"ImageMagick: ");
X      (void) strcat(window->image.name,p);
X      (void) strcpy(window->image.icon_name,p);
X    }
X  window->image.geometry=resource_info->image_geometry;
X  window->image.width=displayed_image->columns;
X  if (window->image.width >= XDisplayWidth(display,visual_info->screen))
X    window->image.width=(XDisplayWidth(display,visual_info->screen)*7) >> 3;
X  window->image.height=displayed_image->rows;
X  if (window->image.height >= XDisplayHeight(display,visual_info->screen))
X    window->image.height=(XDisplayHeight(display,visual_info->screen)*7) >> 3;
X  window->image.border_width=resource_info->border_width;
X  window->image.immutable=False;
X  window->image.attributes.event_mask=ButtonMotionMask | ButtonPressMask |
X    ButtonReleaseMask | EnterWindowMask | ExposureMask | KeyPressMask |
X    KeyReleaseMask | LeaveWindowMask | OwnerGrabButtonMask |
X    StructureNotifyMask;
X  XGetWindowInfo(display,visual_info,map_info,&pixel_info,font_info,
X    resource_info,&window->backdrop);
X  if (resource_info->backdrop || (window->backdrop.id != (Window) NULL))
X    {
X      /*
X        Initialize backdrop window.
X      */
X      window->backdrop.cursor=XMakeInvisibleCursor(display,root_window);
X      if (window->backdrop.cursor == (Cursor) NULL)
X        Error("unable to create cursor",(char *) NULL);
X      window->backdrop.name="ImageMagick Backdrop";
X      window->backdrop.flags=USSize | USPosition;
X      window->backdrop.width=XDisplayWidth(display,visual_info->screen);
X      window->backdrop.height=XDisplayHeight(display,visual_info->screen);
X      window->backdrop.border_width=0;
X      window->backdrop.attributes.cursor=window->backdrop.cursor;
X      window->backdrop.attributes.do_not_propagate_mask=ButtonPressMask |
X        ButtonReleaseMask;
X      window->backdrop.attributes.event_mask=KeyPressMask;
X      window->backdrop.attributes.override_redirect=True;
X      manager_hints->flags=IconWindowHint | InputHint | StateHint;
X      manager_hints->icon_window=window->icon.id;
X      manager_hints->input=True;
X      manager_hints->initial_state=
X        resource_info->iconic ? IconicState : NormalState;
X      XMakeWindow(display,root_window,argv,argc,class_hint,manager_hints,
X        delete_property,&window->backdrop);
X      if (resource_info->debug)
X        (void) fprintf(stderr,"Window id: 0x%lx (backdrop)\n",
X          window->backdrop.id);
X      XMapWindow(display,window->backdrop.id);
X      XClearWindow(display,window->backdrop.id);
X      if (window->image.id != (Window) NULL)
X        {
X          XDestroyWindow(display,window->image.id);
X          window->image.id=(Window) NULL;
X        }
X      /*
X        Position image in the center the backdrop.
X      */
X      window->image.flags|=USPosition;
X      window->image.x=XDisplayWidth(display,visual_info->screen)/2-
X        window->image.width/2;
X      window->image.y=XDisplayHeight(display,visual_info->screen)/2-
X        window->image.height/2;
X      window->image.attributes.event_mask|=FocusChangeMask;
X    }
X  manager_hints->flags=IconWindowHint | InputHint | StateHint;
X  manager_hints->icon_window=window->icon.id;
X  manager_hints->input=True;
X  manager_hints->initial_state=
X    resource_info->iconic ? IconicState : NormalState;
X  XMakeWindow(display,
X    (resource_info->backdrop ? window->backdrop.id : root_window),argv,argc,
X    class_hint,manager_hints,delete_property,&window->image);
X  if (resource_info->debug)
X    (void) fprintf(stderr,"Window id: 0x%lx (image)\n",window->image.id);
X  if (window->backdrop.id == (Window) NULL)
X    *state|=ReconfigureImageState;
X  /*
X    Initialize X image structure.
X  */
X  window->image.x=displayed_image->columns/2-window->image.width/2;
X  window->image.y=displayed_image->rows/2-window->image.height/2;
X  status=XMakeImage(display,resource_info,&window->image,displayed_image,
X    displayed_image->columns,displayed_image->rows);
X  if (status == False)
X    Error("unable to create X image",(char *) NULL);
X  if (resource_info->use_pixmap)
X    (void) XMakePixmap(display,resource_info,&window->image);
X  XMapWindow(display,window->image.id);
X  /*
X    Initialize magnify window and cursor.
X  */
X  XGetWindowInfo(display,visual_info,map_info,&pixel_info,font_info,
X    resource_info,&window->magnify);
X  window->magnify.name=(char *) malloc(2048*sizeof(char));
X  if (window->magnify.name == NULL)
X    Error("unable to create magnify window","memory allocation failed");
X  (void) sprintf(window->magnify.name,"Magnify %uX",resource_info->magnify);
X  window->magnify.cursor=XMakeMagnifyCursor(display,window->image.id,
X    map_info->colormap,resource_info->background_color,
X    resource_info->foreground_color);
X  if (window->magnify.cursor == (Cursor) NULL)
X    Error("unable to create cursor",(char *) NULL);
X  XRecolorCursor(display,window->magnify.cursor,&pixel_info.background_color,
X    &pixel_info.foreground_color);
X  window->magnify.width=MagnifySize;
X  window->magnify.height=MagnifySize;
X  window->magnify.min_width=MagnifySize;
X  window->magnify.min_height=MagnifySize;
X  window->magnify.width_inc=MagnifySize;
X  window->magnify.height_inc=MagnifySize;
X  window->magnify.immutable=False;
X  window->magnify.attributes.save_under=True;
X  window->magnify.attributes.cursor=window->magnify.cursor;
X  window->magnify.attributes.event_mask=ExposureMask | KeyPressMask |
X    StructureNotifyMask;
X  manager_hints->flags=InputHint | StateHint | WindowGroupHint;
X  manager_hints->input=False;
X  manager_hints->initial_state=NormalState;
X  manager_hints->window_group=window->image.id;
X  XMakeWindow(display,root_window,argv,argc,class_hint,manager_hints,
X    delete_property,&window->magnify);
X  if (resource_info->debug)
X    (void) fprintf(stderr,"Window id: 0x%lx (magnify)\n",window->magnify.id);
X  /*
X    Initialize panning window.
X  */
X  XGetWindowInfo(display,visual_info,map_info,&pixel_info,font_info,
X    resource_info,&window->pan);
X  window->pan.name="Pan Icon";
X  scale_factor=UpShift(MaxPanSize)/displayed_image->columns;
X  if (scale_factor > (UpShift(MaxPanSize)/displayed_image->rows))
X    scale_factor=UpShift(MaxPanSize)/displayed_image->rows;
X  window->pan.width=DownShift(displayed_image->columns*scale_factor);
X  window->pan.height=DownShift(displayed_image->rows*scale_factor);
X  window->pan.attributes.save_under=True;
X  window->pan.attributes.event_mask=ButtonMotionMask | ButtonPressMask |
X    ButtonReleaseMask | StructureNotifyMask | VisibilityChangeMask;
X  manager_hints->flags=InputHint | StateHint | WindowGroupHint;
X  manager_hints->input=False;
X  manager_hints->initial_state=NormalState;
X  manager_hints->window_group=window->image.id;
X  XMakeWindow(display,root_window,argv,argc,class_hint,manager_hints,
X    delete_property,&window->pan);
X  if (resource_info->debug)
X    (void) fprintf(stderr,"Window id: 0x%lx (pan)\n",window->pan.id);
X  /*
X    Initialize popup window.
X  */
X  XGetWindowInfo(display,visual_info,map_info,&pixel_info,font_info,
X    resource_info,&window->popup);
X  window->popup.name="ImageMagick Popup";
X  window->popup.flags=PSize | PPosition;
X  window->popup.attributes.override_redirect=True;
X  window->popup.attributes.save_under=True;
X  window->popup.attributes.event_mask=ButtonMotionMask | ButtonPressMask |
X    ButtonReleaseMask | EnterWindowMask | ExposureMask | KeyPressMask |
X    LeaveWindowMask | OwnerGrabButtonMask | VisibilityChangeMask;
X  manager_hints->flags=InputHint | StateHint | WindowGroupHint;
X  manager_hints->input=True;
X  manager_hints->initial_state=NormalState;
X  manager_hints->window_group=window->image.id;
X  XMakeWindow(display,root_window,argv,argc,class_hint,manager_hints,
X    delete_property,&window->popup);
X  if (resource_info->debug)
X    (void) fprintf(stderr,"Window id: 0x%lx (pop up)\n",window->popup.id);
X  XSetTransientForHint(display,window->popup.id,window->image.id);
X  /*
X    Initialize info window.
X  */
X  XGetWindowInfo(display,visual_info,map_info,&pixel_info,font_info,
X    resource_info,&window->info);
X  window->info.name="ImageMagick Info";
X  window->info.flags=PSize;
X  window->info.attributes.save_under=True;
X  window->info.attributes.win_gravity=UnmapGravity;
X  window->info.attributes.event_mask=StructureNotifyMask;
X  manager_hints->flags=InputHint | StateHint | WindowGroupHint;
X  manager_hints->input=False;
X  manager_hints->initial_state=NormalState;
X  manager_hints->window_group=window->image.id;
X  XMakeWindow(display,window->image.id,argv,argc,class_hint,manager_hints,
X    delete_property,&window->info);
X  if (resource_info->debug)
X    (void) fprintf(stderr,"Window id: 0x%lx (info)\n",window->info.id);
X  if (*state & ImageMappedState)
X    {
X      /*
X        Image window already mapped-- selectively refresh or map pan window.
X      */
X      if ((window->image.width == previous_window.width) &&
X          (window->image.height == previous_window.height))
X        {
X          XRefreshWindow(display,&window->image,(XEvent *) NULL);
X          *state&=(~ReconfigureImageState);
X        }
X      if ((window->image.width < window->image.ximage->width) ||
X          (window->image.height < window->image.ximage->height))
X        XMapRaised(display,window->pan.id);  /* map panning window */
X    }
X  /*
X    Respond to events.
X  */
X  timer=time((time_t *) NULL)+resource_info->delay;
X  update_time=0;
X  if (resource_info->update)
X    {
X      /*
X        Determine when file data was last modified.
X      */
X      status=stat(displayed_image->filename,&file_info);
X      if (status == 0)
X        update_time=file_info.st_mtime;
X    }
X  *state&=(~LastImageState);
X  *state&=(~NextImageState);
X  do
X  {
X    /*
X      Handle a window event.
X    */
X    if (resource_info->delay != 0)
X      {
X        if (timer < time((time_t *) NULL))
X          if (!resource_info->update)
X            *state|=NextImageState | ExitState;
X          else
X            {
X              /*
X                Determine if image file was modified.
X              */
X              status=stat(displayed_image->filename,&file_info);
X              if (status == 0)
X                if (update_time != file_info.st_mtime)
X                  {
X                    /*
X                      Redisplay image.
X                    */
X                    loaded_image=ReadImage(resource_info->image_info);
X                    if (loaded_image != (Image *) NULL)
X                      *state|=NextImageState | ExitState;
X                  }
X              timer=time((time_t *) NULL)+resource_info->delay;
X            }
X        if (XEventsQueued(display,QueuedAfterFlush) == 0)
X          {
X            /*
X              Block if delay > 0.
X            */
X            (void) sleep(1);
X            continue;
X          }
X      }
X    XNextEvent(display,&event);
X    switch (event.type)
X    {
X      case ButtonPress:
X      {
X        if ((event.xbutton.button == Button3) &&
X            (event.xbutton.state & Mod1Mask))
X          {
X            /*
X              Convert Alt-Button3 to Button2.
X            */
X            event.xbutton.button=Button2;
X            event.xbutton.state&=(~Mod1Mask);
X          }
X        if (event.xbutton.window == window->image.id)
X          switch (event.xbutton.button)
X          {
X            case Button1:
X            {
X              int
X                command_number;
X
X              static char
X                *MenuSelections[]=
X                {
X                  "Image Info",
X                  "Reflect",
X                  "Rotate Right",
X                  "Rotate Left",
X                  "Half Size",
X                  "Double Size",
X                  "Restore",
X                  "Annotate",
X                  "Composite",
X                  "Load",
X                  "Write",
X                  "Next",
X                  "Previous",
X                  "Quit"
X                };
X
X              static KeySym
X                MenuCommand[]=
X                {
X                  XK_i,
X                  XK_r,
X                  XK_slash,
X                  XK_backslash,
X                  XK_less,
X                  XK_greater,
X                  XK_o,
X                  XK_a,
X                  XK_c,
X                  XK_l,
X                  XK_w,
X                  XK_n,
X                  XK_p,
X                  XK_q
X                };
X
X              /*
X                Select a command from the pop-up menu.
X              */
X              command_number=XPopupMenu(display,&window->popup,
X                event.xbutton.x_root,event.xbutton.y_root,"Commands",
X                MenuSelections,sizeof(MenuSelections)/sizeof(MenuSelections[0]),
X                command);
X              if (command_number >= 0)
X                loaded_image=XImageWindowCommand(display,resource_info,window,
X                  MenuCommand[command_number],&displayed_image,state);
X              break;
X            }
X            case Button2:
X            {
X              /*
X                User pressed the image clip button.
X              */
X              XClipImageWindow(display,resource_info,window,&event,
X                displayed_image,state);
X              break;
X            }
X            case Button3:
X            {
X              if (displayed_image->montage != (char *) NULL)
X                {
X                  /*
X                    User picked an image tile to display.
X                  */
X                  loaded_image=XTileImageWindow(display,resource_info,window,
X                    displayed_image,&event);
X                  if (loaded_image != (Image *) NULL)
X                    *state|=NextImageState | ExitState;
X                  break;
X                }
X              /*
X                User pressed the image magnify button.
X              */
X              if (*state & MagnifyMappedState)
X                XRaiseWindow(display,window->magnify.id);
X              else
X                {
X                  /*
X                    Make magnify image.
X                  */
X                  status=XMakeImage(display,resource_info,&window->magnify,
X                    (Image *) NULL,window->magnify.width,
X                    window->magnify.height);
X                  status|=XMakePixmap(display,resource_info,&window->magnify);
X                  if (status == False)
X                    Error("unable to create magnify image",(char *) NULL);
X                  XMapRaised(display,window->magnify.id);
X                }
X              XMagnifyImageWindow(display,resource_info,window,&event);
X              break;
X            }
X            default:
X              break;
X          }
X        if (event.xbutton.window == window->pan.id)
X          {
X            XPanImageWindow(display,window,&event);
X            break;
X          }
X        break;
X      }
X      case ClientMessage:
X      {
X        /*
X          If client window delete message, exit.
X        */
X        if (event.xclient.message_type == protocols_property)
X          if (*event.xclient.data.l == delete_property)
X            if (event.xclient.window == window->image.id)
X              *state|=ExitState;
X            else
X              XWithdrawWindow(display,event.xclient.window,visual_info->screen);
X        break;
X      }
X      case ConfigureNotify:
X      {
X        if (resource_info->debug)
X          (void) fprintf(stderr,"Configure Notify: 0x%lx %dx%d+%d+%d\n",
X            event.xconfigure.window,event.xconfigure.width,
X            event.xconfigure.height,event.xconfigure.x,event.xconfigure.y);
X        if (event.xconfigure.window == window->image.id)
X          {
X            /*
X              Image window has a new configuration.
X            */
X            if ((event.xconfigure.width != window->image.width) ||
X                (event.xconfigure.height != window->image.height))
X              {
X                window->image.x=0;
X                window->image.y=0;
X                window->image.width=event.xconfigure.width;
X                window->image.height=event.xconfigure.height;
X                if (!(*state & ReconfigureImageState))
X                  {
X                    status=XConfigureImageWindow(display,resource_info,window,
X                      window->image.width,window->image.height,displayed_image);
X                    if (status == False)
X                      XPopupAlert(display,&window->popup,
X                        "unable to configure image",window->image.name);
X                  }
X                *state|=UpdateConfigurationState;
X              }
X            *state&=(~ReconfigureImageState);
X            break;
X          }
X        if (event.xconfigure.window == window->magnify.id)
X          {
X            unsigned int
X              magnify;
X
X            /*
X              Magnify window has a new configuration.
X            */
X            window->magnify.width=event.xconfigure.width;
X            window->magnify.height=event.xconfigure.height;
X            if (!(*state & MagnifyMappedState))
X              break;
X            magnify=1;
X            while (magnify <= event.xconfigure.width)
X              magnify<<=1;
X            while (magnify <= event.xconfigure.height)
X              magnify<<=1;
X            magnify>>=1;
X            if ((magnify != event.xconfigure.width) ||
X                (magnify != event.xconfigure.height))
X              {
X                XResizeWindow(display,window->magnify.id,magnify,magnify);
X                break;
X              }
X            status=XMakeImage(display,resource_info,&window->magnify,
X              (Image *) NULL,window->magnify.width,window->magnify.height);
X            status|=XMakePixmap(display,resource_info,&window->magnify);
X            if (status == False)
X              Error("unable to create magnify image",(char *) NULL);
X            XMakeMagnifyImage(display,resource_info,window);
X            break;
X          }
X        if (event.xconfigure.window == window->pan.id)
X          {
X            /*
X              Icon window has a new configuration.
X            */
X            window->pan.width=event.xconfigure.width;
X            window->pan.height=event.xconfigure.height;
X            break;
X          }
X        if (event.xconfigure.window == window->icon.id)
X          {
X            /*
X              Icon window has a new configuration.
X            */
X            window->icon.width=event.xconfigure.width;
X            window->icon.height=event.xconfigure.height;
X            break;
X          }
X        break;
X      }
X      case EnterNotify:
X      {
X        /*
X          Selectively install colormap.
X        */
X        if (map_info->colormap != XDefaultColormap(display,visual_info->screen))
X          if (event.xcrossing.mode != NotifyUngrab)
X            XInductColormap(display,map_info->colormap);
X        break;
X      }
X      case Expose:
X      {
X        if (resource_info->debug)
X          (void) fprintf(stderr,"Expose: 0x%lx %dx%d+%d+%d\n",
X            event.xexpose.window,event.xexpose.width,event.xexpose.height,
X            event.xexpose.x,event.xexpose.y);
X        /*
X          Refresh windows that are now exposed.
X        */
X        if (event.xexpose.window == window->image.id)
X          if (*state & ImageMappedState)
X            {
X              XRefreshWindow(display,&window->image,&event);
X              timer=time((time_t *) NULL)+resource_info->delay;
X              break;
X            }
X        if (event.xexpose.window == window->magnify.id)
X          if (event.xexpose.count == 0)
X            if (*state & MagnifyMappedState)
X              {
X                XMakeMagnifyImage(display,resource_info,window);
X                break;
X              }
X        break;
X      }
X      case FocusOut:
X      {
X        /*
X          Set input focus for backdrop window.
X        */
X        if (resource_info->debug)
X          (void) fprintf(stderr,"FocusOut Notify: 0x%lx\n",event.xfocus.window);
X        if (event.xfocus.window == window->image.id)
X          XSetInputFocus(display,window->image.id,RevertToNone,CurrentTime);
X        break;
X      }
X      case KeyPress:
X      {
X        if (*state & ReconfigureImageState)
X          {
X            /*
X              No key press during image reconfiguration.
X            */
X            XBell(display,0);
X            break;
X          }
X        /*
X          Respond to a user key press.
X        */
X        *command=' ';
X        XLookupString((XKeyEvent *) &event.xkey,command,sizeof(command),
X          &key_symbol,(XComposeStatus *) NULL);
X        if (resource_info->debug)
X          (void) fprintf(stderr,"Key press: 0x%lx (%c)\n",key_symbol,*command);
X        if (event.xkey.state & ControlMask)
X          *state|=ControlState;
X        if (event.xkey.window == window->image.id)
X          loaded_image=XImageWindowCommand(display,resource_info,window,
X            key_symbol,&displayed_image,state);
X        if (event.xkey.window == window->magnify.id)
X          XMagnifyWindowCommand(display,resource_info,window,key_symbol);
X        break;
X      }
X      case KeyRelease:
X      {
X        /*
X          Respond to a user key release.
X        */
X        XLookupString((XKeyEvent *) &event.xkey,command,sizeof(command),
X          &key_symbol,(XComposeStatus *) NULL);
X        if (resource_info->debug)
X          (void) fprintf(stderr,"Key release: 0x%lx (%c)\n",key_symbol,
X            *command);
X        *state&=(~ControlState);
X        break;
X      }
X      case LeaveNotify:
X      {
X        /*
X          Selectively uninstall colormap.
X        */
X        if (map_info->colormap != XDefaultColormap(display,visual_info->screen))
X          if (event.xcrossing.mode != NotifyUngrab)
X            XUninductColormap(display,map_info->colormap);
X        break;
X      }
X      case MapNotify:
X      {
X        if (resource_info->debug)
X          (void) fprintf(stderr,"Map Notify: 0x%lx\n",event.xmap.window);
X        if (event.xmap.window == window->image.id)
X          {
X            if (window->backdrop.id != (Window) NULL)
X              {
X                /*
X                  Install colormap and set input focus for backdrop window.
X                */
X                XInstallColormap(display,map_info->colormap);
X                XSetInputFocus(display,window->image.id,RevertToNone,
X                  CurrentTime);
X              }
X            if ((window->image.width < window->image.ximage->width) ||
X                (window->image.height < window->image.ximage->height))
X              XMapRaised(display,window->pan.id);
X            *state|=ImageMappedState;
X            break;
X          }
X        if (event.xmap.window == window->magnify.id)
X          {
X            *state|=MagnifyMappedState;
X            break;
X          }
X        if (event.xmap.window == window->pan.id)
X          {
X            XMakePanImage(display,resource_info,window,displayed_image);
X            *state|=PanMappedState;
X            break;
X          }
X        if (event.xmap.window == window->info.id)
X          {
X            *state|=InfoMappedState;
X            break;
X          }
X        if (event.xmap.window == window->icon.id)
X          {
X            if (resource_info->colormap == PrivateColormap)
X              if ((visual_info->class == GrayScale) ||
X                  (visual_info->class == PseudoColor))
X                {
X                  /*
X                    Icons look best with a shared colormap.
X                  */
X                  resource_info->colormap=SharedColormap;
X                  XMakeStandardColormap(display,visual_info,resource_info,
X                    &pixel_info,displayed_image,map_info);
X                  *state|=UpdateColormapState;
X                  resource_info->colormap=PrivateColormap;
X                }
X            /*
X              Create an icon image.
X            */
X            status=XMakeImage(display,resource_info,&window->icon,
X              displayed_image,window->icon.width,window->icon.height);
X            status|=XMakePixmap(display,resource_info,&window->icon);
X            if (status == False)
X              Error("unable to create icon image",(char *) NULL);
X            XSetWindowBackgroundPixmap(display,window->icon.id,
X              window->icon.pixmap);
X            XClearWindow(display,window->icon.id);
X            break;
X          }
X        break;
X      }
X      case MappingNotify:
X      {
X        XRefreshKeyboardMapping(&event.xmapping);
X        break;
X      }
X      case NoExpose:
X        break;
X      case ReparentNotify:
X      {
X        if (resource_info->debug)
X          (void) fprintf(stderr,"Reparent Notify: 0x%lx=>0x%lx\n",
X            event.xreparent.parent,event.xreparent.window);
X        break;
X      }
X      case UnmapNotify:
X      {
X        if (resource_info->debug)
X          (void) fprintf(stderr,"Unmap Notify: 0x%lx\n",event.xunmap.window);
X        if (event.xunmap.window == window->image.id)
X          {
X            *state&=(~ImageMappedState);
X            if (*state & PanMappedState)
X              XWithdrawWindow(display,window->pan.id,window->pan.screen);
X            if (*state & MagnifyMappedState)
X              XWithdrawWindow(display,window->magnify.id,
X                window->magnify.screen);
X            break;
X          }
X        if (event.xunmap.window == window->magnify.id)
X          {
X            *state&=(~MagnifyMappedState);
X            break;
X          }
X        if (event.xunmap.window == window->pan.id)
X          {
X            *state&=(~PanMappedState);
X            break;
X          }
X        if (event.xunmap.window == window->info.id)
X          {
X            *state&=(~InfoMappedState);
X            break;
X          }
X        if (event.xunmap.window == window->icon.id)
X          if (resource_info->colormap == PrivateColormap)
X            if ((visual_info->class == GrayScale) ||
X                (visual_info->class == PseudoColor))
X              {
X                XMakeStandardColormap(display,visual_info,resource_info,
X                  &pixel_info,displayed_image,map_info);
X                *state|=UpdateColormapState;
X                break;
X              }
X        break;
X      }
X      case VisibilityNotify:
X      {
X        if (resource_info->debug)
X          (void) fprintf(stderr,"Visibility Notify: 0x%lx\n",
X             event.xvisibility.window);
X        if (event.xvisibility.window == window->pan.id)
X          {
X            XRaiseWindow(display,window->pan.id);
X            XDrawPanRectangle(display,window);
X            break;
X          }
X        break;
X      }
X      default:
X      {
X        if (resource_info->debug)
X          (void) fprintf(stderr,"Event type: %d\n",event.type);
X        break;
X      }
X    }
X  if (*state & UpdateColormapState)
X    {
X      /*
X        Update window colormap and graphic context.
X      */
X      if (resource_info->debug)
X        (void) fprintf(stderr,"Update Colormap\n");
X      for (i=0; i < number_windows; i++)
X      {
X        XSetWindowColormap(display,magick_windows[i]->id,map_info->colormap);
X        XSetBackground(display,magick_windows[i]->graphic_context,
X          pixel_info.background_color.pixel);
X        XSetForeground(display,magick_windows[i]->graphic_context,
X          pixel_info.foreground_color.pixel);
X        XSetBackground(display,magick_windows[i]->highlight_context,
X          pixel_info.foreground_color.pixel);
X        XSetForeground(display,magick_windows[i]->highlight_context,
X          pixel_info.background_color.pixel);
X      }
X      *state&=(~UpdateColormapState);
X    }
X  if (*state & UpdateConfigurationState)
X    {
X      XWindowChanges
X        window_changes;
X
X      if (resource_info->debug)
X        (void) fprintf(stderr,"Update Configuration\n");
X      if ((window->image.width < window->image.ximage->width) ||
X          (window->image.height < window->image.ximage->height))
X        {
X          /*
X            Update panning icon configuration.
X          */
X          window->image.x=window->image.ximage->width/2-window->image.width/2;
X          window->image.y=window->image.ximage->height/2-window->image.height/2;
X          window->pan.clip_geometry=window->image.clip_geometry;
X          scale_factor=UpShift(MaxPanSize)/displayed_image->columns;
X          if (scale_factor > (UpShift(MaxPanSize)/displayed_image->rows))
X            scale_factor=UpShift(MaxPanSize)/displayed_image->rows;
X          window_changes.width=DownShift(displayed_image->columns*scale_factor);
X          window_changes.height=DownShift(displayed_image->rows*scale_factor);
X          XReconfigureWMWindow(display,window->pan.id,window->pan.screen,
X            CWWidth | CWHeight,&window_changes);
X          XMapRaised(display,window->pan.id);
X          if (*state & PanMappedState)
X            XMakePanImage(display,resource_info,window,displayed_image);
X        }
X      else
X        if (*state & PanMappedState)
X          XWithdrawWindow(display,window->pan.id,window->pan.screen);
X      /*
X        Update magnifier configuration.
X      */
X      window->magnify.x=window->image.width >> 1;
X      window->magnify.y=window->image.height >> 1;
X      if (*state & MagnifyMappedState)
X        XMakeMagnifyImage(display,resource_info,window);
X      /*
X        Update icon configuration.
X      */
X      window->icon.clip_geometry=window->image.clip_geometry;
X      XBestIconSize(display,&window->icon,displayed_image);
X      window_changes.width=window->icon.width;
X      window_changes.height=window->icon.height;
X      XReconfigureWMWindow(display,window->icon.id,window->icon.screen,CWWidth |
X        CWHeight,&window_changes);
X      /*
X        Update font configuration.
X      */
X      (void) sprintf(text," [%u] %s %ux%u %s ",displayed_image->scene,
X        displayed_image->filename,displayed_image->columns,
X        displayed_image->rows,XVisualClassName(visual_info));
X      if (displayed_image->colors != 0)
X        (void) sprintf(text,"%s%uc ",text,displayed_image->colors);
X      XFreeFont(display,font_info);
X      font_info=XBestFont(display,resource_info,text,window->image.width);
X      if (font_info == (XFontStruct *) NULL)
X        Error("unable to load font",resource_info->font);
X      for (i=0; i < number_windows; i++)
X      {
X        magick_windows[i]->font_info=font_info;
X        XSetFont(display,magick_windows[i]->graphic_context,font_info->fid);
X        XSetFont(display,magick_windows[i]->highlight_context,font_info->fid);
X      }
X      /*
X        Update image window configuration.
X      */
X      XSetWindowBackground(display,window->image.id,
X        window->image.pixel_info->background_color.pixel);
X      XRefreshWindow(display,&window->image,(XEvent *) NULL);
X      *state&=(~UpdateConfigurationState);
X    }
X  }
X  while (!(*state & ExitState));
X  if ((*state & LastImageState) || (*state & NextImageState))
X    *state&=(~ExitState);
X  /*
X    Alert user we are busy.
X  */
X  XDefineCursor(display,window->image.id,window->image.busy_cursor);
X  XFlush(display);
X  if (resource_info->write_filename != (char *) NULL)
X    {
X      /*
X        Update image with user transforms.
X      */
X      if ((window->image.clip_geometry != (char *) NULL) ||
X          (displayed_image->columns != window->image.ximage->width) ||
X          (displayed_image->rows != window->image.ximage->height))
X        {
X          char
X            image_geometry[2048];
X
X          /*
X            Clip and/or scale displayed_image.
X          */
X          (void) sprintf(image_geometry,"%dx%d",window->image.ximage->width,
X            window->image.ximage->height);
X          TransformImage(&displayed_image,window->image.clip_geometry,
X            image_geometry,(char *) NULL);
X        }
X      if (resource_info->colorspace == GRAYColorspace)
X        QuantizeImage(displayed_image,256,8,resource_info->dither,
X          GRAYColorspace,True);
X      if (resource_info->monochrome)
X        QuantizeImage(displayed_image,2,8,resource_info->dither,GRAYColorspace,
X          True);
X      if (resource_info->number_colors != 0)
X        if ((displayed_image->class == DirectClass) ||
X            (displayed_image->colors > resource_info->number_colors))
X          {
X            QuantizeImage(displayed_image,resource_info->number_colors,
X              resource_info->tree_depth,resource_info->dither,
X              resource_info->colorspace,True);
X            SyncImage(displayed_image);
X          }
X    }
X  /*
X    Withdraw pan and magnify window.
X  */
X  if (*state & PanMappedState)
X    XWithdrawWindow(display,window->pan.id,window->pan.screen);
X  if (*state & MagnifyMappedState)
X    XWithdrawWindow(display,window->magnify.id,window->magnify.screen);
X  XSync(display,False);
X  while (XCheckTypedWindowEvent(display,window->image.id,Expose,&event))
X    XRefreshWindow(display,&window->image,&event);
X  if (*state & ExitState)
X    {
X      /*
X        Destroy X windows.
X      */
X      for (i=0; i < number_windows; i++)
X      {
X        if (magick_windows[i]->id != (Window) NULL)
X          XDestroyWindow(display,magick_windows[i]->id);
X        if (magick_windows[i]->ximage != (XImage *) NULL)
X          XDestroyImage(magick_windows[i]->ximage);
X        if (magick_windows[i]->pixmap != (Pixmap) NULL)
X          XFreePixmap(display,magick_windows[i]->pixmap);
X      }
X      /*
X        Free Standard Colormap.
X      */
X      if (resource_info->map_type == (char *) NULL)
X        XFreeStandardColormap(display,visual_info,&pixel_info,map_info);
X      (void) free((void *) window);
X      XFree((void *) class_hint);
X      XFree((void *) manager_hints);
X      XFree((void *) map_info);
X      XFree((void *) visual_info);
X      visual_info=(XVisualInfo *) NULL;
X    }
X  /*
X    Free X resources.
X  */
X  (void) free((char *) window->magnify.name);
X  (void) free((char *) window->image.name);
X  (void) free((char *) window->image.icon_name);
X  for (i=0; i < number_windows; i++)
X  {
X    XFreeCursor(display,magick_windows[i]->cursor);
X    XFreeCursor(display,magick_windows[i]->busy_cursor);
X  }
X  XFreeGC(display,pixel_info.graphic_context);
X  XFreeGC(display,pixel_info.highlight_context);
X  XFreeFont(display,font_info);
X  XFlush(display);
X  *image=displayed_image;
X  return(loaded_image);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   X D r a w P a n R e c t a n g l e                                         %
%                                                                             %
%                                                                             %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Function XDrawPanRectangle draws a rectangle in the pan window.  The pan
%  window displays a scaled image and the rectangle shows which portion of
%  the image is displayed in the image window.
%
%  The format of the XDrawPanRectangle routine is:
%
%    XDrawPanRectangle(display,window)
%
%  A description of each parameter follows:
%
%    o display: Specifies a connection to an X server;  returned from
%      XOpenDisplay.
%
%    o window: Specifies a pointer to a XWindows structure.
%
%
*/
static void XDrawPanRectangle(display,window)
Display
X  *display;
X
XXWindows
X  *window;
{
X  unsigned long
X    scale_factor;
X
X  int
X    x,
X    y;
X
X  unsigned int
X    height,
X    width;
X
X  /*
X    Determine dimensions of the panning rectangle.
X  */
X  scale_factor=(unsigned long)
X    (UpShift(window->pan.width)/window->image.ximage->width);
X  x=DownShift(window->image.x*scale_factor);
X  width=DownShift(window->image.width*scale_factor);
X  scale_factor=(unsigned long)
X    (UpShift(window->pan.height)/window->image.ximage->height);
X  y=DownShift(window->image.y*scale_factor);
X  height=DownShift(window->image.height*scale_factor);
X  /*
X    Display the panning rectangle.
X  */
X  XClearWindow(display,window->pan.id);
X  XSetForeground(display,window->pan.graphic_context,
X    window->image.pixel_info->background_color.pixel);
X  XDrawRectangle(display,window->pan.id,window->pan.graphic_context,x+1,y+1,
X    width-2,height-2);
X  XSetForeground(display,window->pan.graphic_context,
X    window->image.pixel_info->foreground_color.pixel);
X  XDrawRectangle(display,window->pan.id,window->pan.graphic_context,x,y,
X    width,height);
}
X
/*
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%                                                                             %
%                                                                             %
%   X I m a g e W i n d o w C o m m a n d                                     %
SHAR_EOF
true || echo 'restore of ImageMagick/display.c failed'
fi
echo 'End of ImageMagick part 23'
echo 'File ImageMagick/display.c is continued in part 24'
echo 24 > _shar_seq_.tmp
exit 0

exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
