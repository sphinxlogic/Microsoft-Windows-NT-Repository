Newsgroups: comp.sources.x
From: jch@okimicro.oki.com (Jan Hardenbergh)
Subject: v20i019:  pexdraw - A PEX drawing program, Part09/14
Message-ID: <1993Jun8.150207.19172@sparky.imd.sterling.com>
X-Md4-Signature: e79ab9c01a4b72c343f8c86057687d1d
Sender: chris@sparky.imd.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Tue, 8 Jun 1993 15:02:07 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: jch@okimicro.oki.com (Jan Hardenbergh)
Posting-number: Volume 20, Issue 19
Archive-name: pexdraw/part09
Environment: X11R5, PEX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  fb.c pexdrawc.1
# Wrapped by chris@sparky on Tue Jun  8 09:46:33 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 9 (of 14)."'
if test -f 'fb.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fb.c'\"
else
  echo shar: Extracting \"'fb.c'\" \(27419 characters\)
  sed "s/^X//" >'fb.c' <<'END_OF_FILE'
X#ifdef SCCS
Xstatic char sccsid[]="@(#)fb.c	1.14 Oki Electric Industry Co., Ltd. 93/05/24";
X#endif
X/*
X	This file is under sccs control at Stardent in:
X	/nfs/sole/root/sccs1.p/X11R5/mit/demos/pexdraw/s.fb.c
X*/
X/*
X *			Copyright (c) 1992 by
X *			Oki Electric Industry Co., Ltd.
X *			All Rights Reserved
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted,
X * provided that the above copyright notice appear in all copies and that
X * both that copyright notice and this permission notice appear in
X * supporting documentation, and that the name of Oki not be
X * used in advertising or publicity pertaining to distribution of the
X * software without specific, written prior permission. Oki
X * makes no representations about the suitability of this software for any
X * purpose.  It is provided "as is" without express or implied warranty.
X *
X * This supercedes the Stardent copyright granting the same rights that
X * appeared in the pdraw predecessor to pexdraw.
X *
X *************************************************************************
X *
X *                         P E X D R A W
X *
X *  A PEX drawing program based on PDRAW,
X *
X *   
X *
X *************************************************************************/
X
X#include <stdio.h>
X
X#include <math.h>
X
X#include <X11/PEX5/PEXlib.h>
X#include <X11/Xutil.h> /* because of XVisualInfo in pexdraw.h !?! */
X
X#include "pexdraw.h"
X
Xint theAnchorX, theAnchorY, theDynX, theDynY, theAltX, theAltY;
Xint theTriStripCount = 0;
X
X#define TRIMAX 12
XXPoint theTriDCs[TRIMAX];
XPEXCoord       theTriPoints[TRIMAX];
X
Xfloat theTheta, thePhi, theDeltaTheta, theDeltaPhi;
X
X
X/*************************************************************************
X *
X * D Y N A M I C    F E E D B A C K   R O U T I N E S
X *
X */
Xstatic void fbInitLine(
X#if NeedFunctionPrototypes
XXButtonPressedEvent * /* event */
X#endif
X);
X
Xstatic void fbDynLine(
X#if NeedFunctionPrototypes
XXMotionEvent * /* event */
X#endif
X);
X
Xstatic void fbEndLine(
X#if NeedFunctionPrototypes
XXButtonReleasedEvent * /* event */
X#endif
X);
X
Xstatic void fbEndMClip(
X#if NeedFunctionPrototypes
XXButtonReleasedEvent * /* event */
X#endif
X);
X
Xstatic void fbDummy();
Xstatic void fbDynBox(
X#if NeedFunctionPrototypes
XXMotionEvent * /* event */
X#endif
X);
X
Xstatic void fbEndPick(
X#if NeedFunctionPrototypes
XXButtonReleasedEvent * /* event */
X#endif
X);
X
X
Xstatic void fbInitTriStrip(
X#if NeedFunctionPrototypes
XXButtonPressedEvent * /* event */
X#endif
X);
X
Xstatic void fbDynTriStrip(
X#if NeedFunctionPrototypes
XXMotionEvent * /* event */
X#endif
X);
X
Xstatic void fbEndTriStrip(
X#if NeedFunctionPrototypes
XXButtonReleasedEvent * /* event */
X#endif
X);
X
Xstatic void fbFinishTriStrip(
X#if NeedFunctionPrototypes
XXButtonReleasedEvent * /* event */
X#endif
X);
X
X
Xstatic void fbInitNURBCurve(
X#if NeedFunctionPrototypes
XXButtonPressedEvent * /* event */
X#endif
X);
X
Xstatic void fbDynNURBCurve(
X#if NeedFunctionPrototypes
XXMotionEvent * /* event */
X#endif
X);
X
Xstatic void fbEndNURBCurve(
X#if NeedFunctionPrototypes
XXButtonReleasedEvent * /* event */
X#endif
X);
X
Xstatic void fbFinishNURBCurve(
X#if NeedFunctionPrototypes
XXButtonReleasedEvent * /* event */
X#endif
X);
X
X
Xstatic void fbFinishPolygon (
X#if NeedFunctionPrototypes
XXButtonReleasedEvent * /* event */
X#endif
X);
X
X
Xstatic void fbEndText(
X#if NeedFunctionPrototypes
XXButtonReleasedEvent * /* event */
X#endif
X);
X
X
Xstatic void fbInitView(
X#if NeedFunctionPrototypes
XXButtonPressedEvent * /* event */
X#endif
X);
X
Xstatic void fbDynView(
X#if NeedFunctionPrototypes
XXMotionEvent * /* event */
X#endif
X);
X
Xstatic void fbEndView(
X#if NeedFunctionPrototypes
XXButtonReleasedEvent * /* event */
X#endif
X);
X
X
Xstatic void fbInitTranslate(
X#if NeedFunctionPrototypes
XXButtonPressedEvent * /* event */
X#endif
X);
X
X/* use dynline */
Xstatic void fbEndTranslate(
X#if NeedFunctionPrototypes
XXButtonReleasedEvent * /* event */
X#endif
X);
X
X
Xstatic void fbInitStretch(
X#if NeedFunctionPrototypes
XXButtonPressedEvent * /* event */
X#endif
X);
X
X/* use dynline, or dyntristrip */
Xstatic void fbEndStretch(
X#if NeedFunctionPrototypes
XXButtonReleasedEvent * /* event */
X#endif
X);
X
X
Xstatic void fbEndZoom(
X#if NeedFunctionPrototypes
XXButtonReleasedEvent * /* event */
X#endif
X);
X
Xstatic void fbZoomReset(
X#if NeedFunctionPrototypes
XXButtonReleasedEvent * /* event */
X#endif
X);
X
X
Xstatic void fbInitCircle(
X#if NeedFunctionPrototypes
XXButtonPressedEvent * /* event */
X#endif
X);
X
Xstatic void fbEndCircle(
X#if NeedFunctionPrototypes
XXButtonReleasedEvent * /* event */
X#endif
X);
X
Xstatic void fbDynCircle(
X#if NeedFunctionPrototypes
XXMotionEvent * /* event */
X#endif
X);
X
X
X
X
X/*************************************************************************
X *
X *  T O O L   S E L E C T I O N   R O U T I N E S
X *
X *************************************************************************
X */
X
Xvoid 
Xset_tool_pointer()
X{
X    theCurrentTool = TOOL_POINTER;
X
X    /*
X     * don't deal with fancy pre-pick hilite, yet.
X     */
X    if (the51Flag) {
X      thePressHandlerTable[0] = fbInitLine;
X      theMotionHandlerTable[0] = fbDynBox;
X    } else {
X      thePressHandlerTable[0] = fbDummy;
X      theMotionHandlerTable[0] = fbDummy;
X    }
X    theReleaseHandlerTable[0] = fbEndPick;
X
X    thePressHandlerTable[1] = fbInitTranslate;
X    theMotionHandlerTable[1] = fbDynLine;
X    theReleaseHandlerTable[1] = fbEndTranslate;
X
X    thePressHandlerTable[2] = fbInitStretch;
X    theMotionHandlerTable[2] = fbDummy;
X    theReleaseHandlerTable[2] = fbEndStretch;
X}
X
Xvoid 
Xset_tool_line()
X{
X    theCurrentTool = TOOL_LINE;
X
X    thePressHandlerTable[0] = fbInitLine;
X    theMotionHandlerTable[0] = fbDynLine;
X    theReleaseHandlerTable[0] = fbEndLine;
X
X    thePressHandlerTable[1] = fbInitLine;
X    theMotionHandlerTable[1] = fbDynLine;
X    theReleaseHandlerTable[1] = fbEndLine;
X
X    thePressHandlerTable[2] = fbInitView;
X    theMotionHandlerTable[2] = fbDynView;
X    theReleaseHandlerTable[2] = fbEndView;
X}
X
Xvoid 
Xset_tool_view()
X{
X
X    theCurrentTool = TOOL_VIEW;
X
X    thePressHandlerTable[0] = fbInitView;
X    theMotionHandlerTable[0] = fbDynView;
X    theReleaseHandlerTable[0] = fbEndView;
X
X    thePressHandlerTable[1] = fbDummy;
X    theMotionHandlerTable[1] = fbDummy;
X    theReleaseHandlerTable[1] = fbDummy;
X
X    thePressHandlerTable[2] = fbInitView;
X    theMotionHandlerTable[2] = fbDynView;
X    theReleaseHandlerTable[2] = fbEndView;
X}
X
Xvoid
Xset_tool_nurbc()
X{
X    theCurrentTool = TOOL_NURBC;
X
X    thePressHandlerTable[0] = fbInitNURBCurve;
X    theMotionHandlerTable[0] = fbDynLine;
X    theReleaseHandlerTable[0] = fbEndNURBCurve;
X
X    thePressHandlerTable[1] = fbFinishNURBCurve;
X    theMotionHandlerTable[1] = fbDummy;
X    theReleaseHandlerTable[1] = fbDummy;
X
X    thePressHandlerTable[2] = fbInitView;
X    theMotionHandlerTable[2] = fbDynView;
X    theReleaseHandlerTable[2] = fbEndView;
X}
X
Xvoid
Xset_tool_pgon()
X{
X    theCurrentTool = TOOL_PGON;
X
X    thePressHandlerTable[0] = fbInitNURBCurve;
X    theMotionHandlerTable[0] = fbDynLine;
X    theReleaseHandlerTable[0] = fbEndNURBCurve;
X
X    thePressHandlerTable[1] = fbFinishPolygon;
X    theMotionHandlerTable[1] = fbDummy;
X    theReleaseHandlerTable[1] = fbDummy;
X
X    thePressHandlerTable[2] = fbInitView;
X    theMotionHandlerTable[2] = fbDynView;
X    theReleaseHandlerTable[2] = fbEndView;
X}
X
Xvoid
Xset_tool_circle()
X{
X    theCurrentTool = TOOL_CIRCLE;
X
X    thePressHandlerTable[0] = fbInitCircle;
X    theMotionHandlerTable[0] = fbDynCircle;
X    theReleaseHandlerTable[0] = fbEndCircle;
X
X    thePressHandlerTable[1] = fbDummy;
X    theMotionHandlerTable[1] = fbDummy;
X    theReleaseHandlerTable[1] = fbDummy;
X
X    thePressHandlerTable[2] = fbInitView;
X    theMotionHandlerTable[2] = fbDynView;
X    theReleaseHandlerTable[2] = fbEndView;
X}
X
X
Xvoid
Xset_tool_text()
X{
X  theCurrentTool = TOOL_TEXT;
X
X  thePressHandlerTable[0] = fbDummy;
X  theMotionHandlerTable[0] = fbDummy;
X  theReleaseHandlerTable[0] = fbEndText;
X
X  thePressHandlerTable[1] = fbDummy;
X  theMotionHandlerTable[1] = fbDummy;
X  theReleaseHandlerTable[1] = fbDummy;
X
X  thePressHandlerTable[2] = fbInitView;
X  theMotionHandlerTable[2] = fbDynView;
X  theReleaseHandlerTable[2] = fbEndView;
X}
X
Xvoid
Xset_tool_tristrip()
X{
X    theCurrentTool = TOOL_TRISTRIP;
X
X    thePressHandlerTable[0] = fbInitTriStrip;
X    theMotionHandlerTable[0] = fbDynTriStrip;
X    theReleaseHandlerTable[0] = fbEndTriStrip;
X
X    thePressHandlerTable[1] = fbFinishTriStrip;
X    theMotionHandlerTable[1] = fbDummy;
X    theReleaseHandlerTable[1] = fbDummy;
X
X    thePressHandlerTable[2] = fbInitView;
X    theMotionHandlerTable[2] = fbDynView;
X    theReleaseHandlerTable[2] = fbEndView;
X}
X
Xvoid
Xset_tool_zoom()
X{
X  if (theCurrentTool != TOOL_ZOOM) {
X    theCurrentTool = TOOL_ZOOM;
X
X    thePressHandlerTable[0] = fbInitLine;
X    theMotionHandlerTable[0] = fbDynBox;
X    theReleaseHandlerTable[0] = fbEndZoom;
X
X    thePressHandlerTable[1] = fbDummy;
X    theMotionHandlerTable[1] = fbDummy;
X    theReleaseHandlerTable[1] = fbZoomReset;
X
X    thePressHandlerTable[2] = fbInitView;
X    theMotionHandlerTable[2] = fbDynView;
X    theReleaseHandlerTable[2] = fbEndView;
X  }
X}
X
Xvoid
Xset_tool_mclip()
X{
X  if (theCurrentTool != TOOL_MCLIP) {
X    theCurrentTool = TOOL_MCLIP;
X
X    thePressHandlerTable[0] = fbInitLine;
X    theMotionHandlerTable[0] = fbDynLine;
X    theReleaseHandlerTable[0] = fbEndMClip;
X
X    thePressHandlerTable[1] = fbDummy;
X    theMotionHandlerTable[1] = fbDummy;
X    theReleaseHandlerTable[1] = fbDummy;;
X
X    thePressHandlerTable[2] = fbInitView;
X    theMotionHandlerTable[2] = fbDynView;
X    theReleaseHandlerTable[2] = fbEndView;
X  }
X}
X
X/*************************************************************************
X *
X * D Y N A M I C     F E E D B A C K     R O U T I N E S
X *
X */
Xstatic void fbInitLine(event )
X XButtonPressedEvent *event;
X{
X  XGCValues values;
X
X  theAnchorX = event->x;
X  theAnchorY = event->y;
X  theDynX = event->x;
X  theDynY = event->y;
X  XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theAnchorX, theAnchorY, theDynX, theDynY );
X}
X
Xstatic void fbDynLine(event )
X XMotionEvent *event;
X{
X  XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theAnchorX, theAnchorY, theDynX, theDynY );
X  theDynX = event->x;
X  theDynY = event->y;
X  XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theAnchorX, theAnchorY, theDynX, theDynY );
X}
X
Xstatic void fbDynBox(event )
X XMotionEvent *event;
X{
X  XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theAnchorX, theAnchorY, theAnchorX, theDynY );
X  XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theAnchorX, theDynY, theDynX, theDynY );
X  XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theDynX, theDynY, theDynX, theAnchorY );
X  XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theDynX, theAnchorY, theAnchorX, theAnchorY );
X  theDynX = event->x;
X  theDynY = event->y;
X  XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theAnchorX, theAnchorY, theAnchorX, theDynY );
X  XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theAnchorX, theDynY, theDynX, theDynY );
X  XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theDynX, theDynY, theDynX, theAnchorY );
X  XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theDynX, theAnchorY, theAnchorX, theAnchorY );
X}
X
Xstatic void fbEndLine(event )
X XButtonReleasedEvent *event;
X{
X  XPoint xp[2];
X  PEXCoord *pl;
X  int count;
X
X  xp[0].x = theAnchorX;
X  xp[0].y = theAnchorY;
X  xp[1].x = theDynX;
X  xp[1].y = theDynY;
X
X  if ((count = theRenderProcs.MapXToMC( &theMCMatrix, 2, xp, &pl)) ==  2) {
X    InsertLineCmd( 2, pl, 1 );
X    free((char *)pl);
X    theRenderProcs.ReDraw();
X  }
X}
X
Xstatic void fbEndMClip(event )
X XButtonReleasedEvent *event;
X{
X  XPoint xp[2];
X  PEXCoord *pl;
X  int count;
X
X  xp[0].x = theAnchorX;
X  xp[0].y = theAnchorY;
X  xp[1].x = theDynX;
X  xp[1].y = theDynY;
X
X  if ((count = theRenderProcs.MapXToMC( &theMCMatrix, 2, xp, &pl)) ==  2) {
X    InsertMClipCmd( pl, 1 );
X    free((char *)pl);
X    theRenderProcs.ReDraw();
X  }
X}
X
X
X/*
X * no dynamic hiliting
X */
Xstatic void fbDummy() {}
X
X#define DIFFERENT(a,b) (((((a)-(b))>3)||(((a)-(b))<-3))?1:0)
X
Xstatic void fbEndPick(event )
X XButtonReleasedEvent *event;
X{
X  long s;
X  int e;
X  int count;
X  long *struxArray;
X  int *elemArray;
X
X  XDrawPoint(  theDisplay, theWindow, theDynGC, event->x, event->y );
X  ClearSelection();
X
X  if (the51Flag && 
X      (DIFFERENT(event->x,theAnchorX) || DIFFERENT(event->y,theAnchorY))) {
X    /* do pick all */
X    theRenderProcs.PickAll( event->x, event->y, theAnchorX,theAnchorY,
X			   &count, &struxArray, &elemArray );
X    if (count > 0) {
X      ColorGroup( count, struxArray, elemArray );
X      SelectSomething( struxArray[0], elemArray[0] );
X    }
X  } else {
X    theRenderProcs.PickOne( event->x, event->y, &s, &e);
X    if ( e != -1 )
X      SelectSomething( s, e );
X  }
X  theRenderProcs.ReDraw();
X}
X
X/*************************************************************************
X *  fbInitTriStrip - initialze and reinit tristrip inster dynamics.
X *
X * if we are working on a tristrip, then start the next point. Otherwise,
X *  we are just drawing a line!
X */
Xstatic void fbInitTriStrip(event )
X XButtonPressedEvent *event;
X{
X  if (theTriStripCount) {
X    if (theTriStripCount == TRIMAX) {
X      fbFinishTriStrip( event );
X      return;
X    }
X    theAnchorX = theAltX;
X    theAnchorY = theAltY;
X    theAltX = theDynX;
X    theAltY = theDynY;
X    theDynX = event->x;
X    theDynY = event->y;
X    XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theAnchorX, theAnchorY, theDynX, theDynY );
X    XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theAltX, theAltY, theDynX, theDynY );
X  } else {
X    theAnchorX = event->x;
X    theAnchorY = event->y;
X    theDynX = event->x;
X    theDynY = event->y;
X    theAltX = event->x;
X    theAltY = event->y;
X    XDrawLine( theDisplay, theWindow, theDynGC, 
X	      theAnchorX, theAnchorY, theDynX, theDynY );
X  }
X}
X
Xstatic void fbDynTriStrip(event )
X XMotionEvent *event;
X{
X  if (theTriStripCount) {
X    XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theAnchorX, theAnchorY, theDynX, theDynY );
X    XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theAltX, theAltY, theDynX, theDynY );
X    theDynX = event->x;
X    theDynY = event->y;
X    XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theAnchorX, theAnchorY, theDynX, theDynY );
X    XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theAltX, theAltY, theDynX, theDynY );
X  } else {
X    XDrawLine( theDisplay, theWindow, theDynGC, 
X	      theAnchorX, theAnchorY, theDynX, theDynY );
X    theDynX = event->x;
X    theDynY = event->y;
X    XDrawLine( theDisplay, theWindow, theDynGC, 
X	      theAnchorX, theAnchorY, theDynX, theDynY );
X  }
X}
Xstatic void fbEndTriStrip(event )
X XButtonReleasedEvent *event;
X{
X  if (theTriStripCount) {
X    XDrawLine( theDisplay, theWindow, 
X	      theDynGC, theAnchorX, theAnchorY, theDynX, theDynY );
X    XDrawLine( theDisplay, theWindow,
X	      theDynGC, theAltX, theAltY, theDynX, theDynY );
X    theDynX = event->x;
X    theDynY = event->y;
X    XDrawLine( theDisplay, theWindow, 
X	      theDynGC, theAnchorX, theAnchorY, theDynX, theDynY );
X    XDrawLine( theDisplay, theWindow,
X	      theDynGC, theAltX, theAltY, theDynX, theDynY );
X    theTriDCs[theTriStripCount].x = theDynX;
X    theTriDCs[theTriStripCount].y = theDynY;
X    theTriStripCount++;
X  } else {
X    XDrawLine( theDisplay, theWindow, theDynGC, 
X	      theAnchorX, theAnchorY, theDynX, theDynY );
X    theDynX = event->x;
X    theDynY = event->y;
X    XDrawLine( theDisplay, theWindow, theDynGC, 
X	      theAnchorX, theAnchorY, theDynX, theDynY );
X    theTriDCs[0].x = theAnchorX;
X    theTriDCs[0].y = theAnchorY;
X    theTriDCs[1].x = theDynX;
X    theTriDCs[1].y = theDynY;
X    theTriStripCount = 2;
X  }
X}
X
Xstatic void fbFinishTriStrip (event )
X XButtonReleasedEvent *event;
X{
X  int i, count;
X  PEXCoord *p;
X
X  if (theTriStripCount < 3) return;
X
X  if ((count = theRenderProcs.MapXToMC( &theMCMatrix, theTriStripCount,
X				       theTriDCs, &p))  ==  theTriStripCount) {
X    if ( count > 2 ) {
X      InsertTriStripCmd( count, p, 1 );
X      free((char *)p);
X      theRenderProcs.ReDraw();
X    }
X  }
X  theTriStripCount = 0;
X}
X
X/*************************************************************************
X *  fbInitNURBCurve - initialze and reinit NURBCurve inster dynamics.
X *
X * if we are working on a NURBCurve, then start the next point. Otherwise,
X *  we are just drawing a line!
X *
X * made applicable to polygons by calling the press handler of [1] when full.
X */
Xstatic void fbInitNURBCurve(event )
X XButtonPressedEvent *event;
X{
X  if (theTriStripCount) {
X    if (theTriStripCount == TRIMAX) {
X      thePressHandlerTable[1]( event );
X      return;
X    }
X    theAnchorX = theDynX;
X    theAnchorY = theDynY;
X    theDynX = event->x;
X    theDynY = event->y;
X    XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theAnchorX, theAnchorY, theDynX, theDynY );
X  } else {
X    theAnchorX = event->x;
X    theAnchorY = event->y;
X    theDynX = event->x;
X    theDynY = event->y;
X    XDrawLine( theDisplay, theWindow, theDynGC, 
X	      theAnchorX, theAnchorY, theDynX, theDynY );
X    theTriDCs[theTriStripCount].x = theDynX;
X    theTriDCs[theTriStripCount].y = theDynY;
X    theTriStripCount++;  /* save this point as the first point */
X  }
X}
X
Xstatic void fbEndNURBCurve(event )
X XButtonReleasedEvent *event;
X{
X  if (theTriStripCount) {
X    XDrawLine( theDisplay, theWindow, 
X	      theDynGC, theAnchorX, theAnchorY, theDynX, theDynY );
X    theDynX = event->x;
X    theDynY = event->y;
X    XDrawLine( theDisplay, theWindow, 
X	      theDynGC, theAnchorX, theAnchorY, theDynX, theDynY );
X    theTriDCs[theTriStripCount].x = theDynX;
X    theTriDCs[theTriStripCount].y = theDynY;
X    theTriStripCount++;
X  }
X}
X
Xstatic void fbFinishNURBCurve (event )
X XButtonReleasedEvent *event;
X{
X  int i, count;
X  PEXCoord *p;
X
X  if (theTriStripCount < 3) return;
X
X  if ((count = theRenderProcs.MapXToMC( &theMCMatrix, theTriStripCount,
X				       theTriDCs, &p))  ==  theTriStripCount) {
X    if ( count > 2 ) {
X      InsertNURBCurveCmd( count, p, 1 );
X      free((char *)p);
X      theRenderProcs.ReDraw();
X    }
X  }
X  theTriStripCount = 0;
X}
X
Xstatic void fbFinishPolygon (event )
X XButtonReleasedEvent *event;
X{
X  int i, count;
X  PEXCoord *p;
X
X  if (theTriStripCount < 3) return;
X
X  if ((count = theRenderProcs.MapXToMC( &theMCMatrix, theTriStripCount,
X				       theTriDCs, &p))  ==  theTriStripCount) {
X    if ( count > 2 ) {
X      InsertPolygonCmd( count, p, 1 );
X      free((char *)p);
X      theRenderProcs.ReDraw();
X    }
X  }
X  theTriStripCount = 0;
X}
X
Xstatic void fbEndText(event )
X XButtonReleasedEvent *event;
X{
X  XPoint xp[2];
X  PEXCoord *pl;
X  int count;
X  char *charStr;
X  int flags;
X  
X
X  XDrawPoint(  theDisplay, theWindow, theDynGC, event->x, event->y );
X
X  xp[0].x = event->x;
X  xp[0].y = event->y;
X
X  if ((theRenderProcs.MapXToMC( &theMCMatrix, 1, xp, &pl)) == 1) {
X    GetSomeTextFromUI( event->x, event->y, &count, &charStr, &flags );
X    InsertTextCmd( pl, count, charStr, flags, 1 );
X    free(charStr);
X    free((char *)pl);
X    theRenderProcs.ReDraw();
X  }
X}
X
X
X/*************************************************************************
X *
X */
Xstatic void fbInitTranslate(event )
X XButtonPressedEvent *event;
X{
X
X  theAnchorX = event->x;
X  theAnchorY = event->y;
X  theDynX = event->x;
X  theDynY = event->y;
X  XDrawPoint( theDisplay, theWindow, theDynGC, 
X	    theAnchorX, theAnchorY );
X}
X
Xstatic void fbEndTranslate(event ) 
X XButtonReleasedEvent *event;
X{
X  XPoint xp[2];
X  PEXCoord *pl;
X  int count;
X
X  if ( theSelectedElement == -1 ) {
X    printf("nothing selected\n");
X    return;
X  }
X
X  theDynX = event->x;
X  theDynY = event->y;
X  XDrawPoint( theDisplay, theWindow, theDynGC, 
X	    theDynX, theDynY );
X
X  xp[0].x = theAnchorX;
X  xp[0].y = theAnchorY;
X  xp[1].x = theDynX;
X  xp[1].y = theDynY;
X  if ((count = theRenderProcs.MapXToMC( &theMCMatrix, 2, xp, &pl)) ==  2) {
X    TranslateSelected( pl );
X    free((char *)pl);
X    theRenderProcs.ReDraw();
X  }
X}
X
X/*************************************************************************
X *
X */
Xstatic void fbInitStretch(event )
X XButtonPressedEvent *event;
X{
X  int i, count;
X  XPoint *points, *p;
X  float dist, currentDist;
X  int error;
X
X  theSelectedIndex = -1;
X
X  error = GetXPointsFromSelected(&count, &points);
X  if (error) {
X    printf("imagine a popup dialog... bad mapping in InitStretch %d\n", error );
X    return;
X  }
X
X  currentDist = MAXFLOAT;
X
X  for (i = 0, p = points; i < count; i++, p++ ) {
X    /* don't bother with divide, only relative dist counts */
X    dist = (event->x - p->x)*(event->x - p->x) + 
X           (event->y - p->y)*(event->y - p->y);
X    if (dist < currentDist) {
X      currentDist = dist;
X      theSelectedIndex = i;
X    }
X  }
X
X  if (theSelectedIndex == -1) return;
X
X  if (theSelectedIndex > 0) {
X    theAnchorX = points[theSelectedIndex-1].x;
X    theAnchorY = points[theSelectedIndex-1].y;
X  } else {
X    theAnchorX = points[theSelectedIndex+1].x;
X    theAnchorY = points[theSelectedIndex+1].y;
X  }
X  free(points); /* all done */
X  
X  theDynX = event->x;
X  theDynY = event->y;
X  XDrawLine( theDisplay, theWindow, theDynGC, 
X	    theAnchorX, theAnchorY, theDynX, theDynY );
X
X  /*
X   * O.K.  we're ready.
X   */
X  theMotionHandlerTable[2] = fbDynLine;
X}
X
X/*************************************************************************
X * fbEndStretch
X */
Xstatic void fbEndStretch(event )
X XButtonReleasedEvent *event;
X{
X  XPoint xp;
X  PEXCoord *pl;
X  int count;
X
X  xp.x = event->x;
X  xp.y = event->y;
X  if ((count = theRenderProcs.MapXToMC( &theMCMatrix, 1, &xp, &pl)) ==  1) {
X    if ( count == 1 ) {
X      StretchSelected(pl);
X      free((char *)pl);
X      theRenderProcs.ReDraw();
X    }
X    theMotionHandlerTable[2] = fbDummy;
X  }
X}       
X
X/*************************************************************************
X *
X */
Xstatic void fbInitView(event ) 
X XButtonPressedEvent *event;
X{
X  PEXVector  vpn;  /* view plane normal    */
X  float tsinTheta;
X    
X  theDynX = event->x;
X  theDynY = event->y;
X
X  /* view plane normal */
X  GetVPN(1, &vpn);
X
X  PEXNormalizeVectors(1,&vpn,&vpn); /* just in case the user was playing */
X
X  /*
X   * theta = atan2(cos(phi)*sin(theta), cos(phi)*cos(theta))
X   */
X  theTheta = atan2(vpn.x, vpn.z);
X  /*
X   * atan2(sin(theta), cos(theta)) gives theta.
X   * since we have sin(phi) = dy and dx = cos(phi)*sin(theta)
X   * we want atan2(dy, dx/sin(theta)) BUT sin(theta) will be zero
X   * so we use dy*sin(theta) BUT when sin(theta) and dx are negative
X   * it changes the quadrant. so...
X   */
X  tsinTheta = sin(theTheta);
X  if (tsinTheta >= 0 ) {
X   thePhi = atan2( vpn.y * tsinTheta, vpn.x);
X  } else {
X   thePhi = atan2( -(vpn.y * tsinTheta), -vpn.x);
X  }
X/*  
X  thedebug = 1;
X  printf("start t %g, p %g, x,y,z %g, %g, %g\n", theTheta, thePhi,  
X   vpn.x, vpn.y, vpn.z);
X*/
X}
X
Xstatic void fbDynView(event )
X XMotionEvent *event;
X{
X  PEXVector  vpn;  /* view plane normal    */
X  PEXVector  vup;  /* view up vector       */
X  float cx, cy, cz;
X  int t, c;
X    	
X  theTheta += 0.005 * (theDynX - event->x);
X  thePhi   += 0.005 * (event->y - theDynY);
X
X  theDynX = event->x;
X  theDynY = event->y;
X
X
X  vpn.x = cos( thePhi ) * sin( theTheta );
X  vpn.y = sin( thePhi );
X  vpn.z = cos( thePhi ) * cos( theTheta );
X
X  /* view up vector */
X  GetVUP(1, &vup);
X
X  t = 6; c = 0;
X  while (t--) {
X    cx = vpn.y*vup.z - vpn.z*vup.y;
X    cy = vpn.z*vup.x - vpn.x*vup.z;
X    cz = vpn.x*vup.y - vpn.y*vup.x;
X  
X    if ((cx*cx + cy*cy + cz*cz) < 0.1) {
X    	if ((vup.y < 0.8) && (vup.y > -0.8)) {
X    	  vup.y += 0.03;
X        } else {
X    	  vup.x += 0.05;
X    	}
X	PEXNormalizeVectors(1,&vup,&vup);
X    	c = 1;
X    } else {
X    	t = 0;
X    }
X  }
X
X  if (c) {
X    SetVUP(1,&vup);
X  }  	
X  SetVPN(1,&vpn);
X
X  applyViewSet(1);
X  XSync(theDisplay,1); /* sync and discard events */
X}
X
Xstatic void fbEndView(event )
X XButtonReleasedEvent *event;
X{
X  Window root, child;
X  int root_x, root_y;
X  int win_x, win_y;
X  unsigned int keys_buttons;
X  	
X  XQueryPointer(theDisplay,theWindow,
X                &root, &child, &root_x, &root_y, &win_x, &win_y,
X                &keys_buttons);
X  XQueryPointer(theDisplay,theWindow,
X                &root, &child, &root_x, &root_y, &win_x, &win_y,
X                &keys_buttons);
X/*                
X	if ((win_x != theDynX) && (win_y != theDynY)) {
X		printf("spinning... %d, %d, %d, %d\n", 
X		theDynX,win_x,theDynY,win_y);
X	}
X*/
X}
X
X/*************************************************************************
X * fbEndZoom
X *
X */
Xstatic void fbEndZoom(event )
X XButtonReleasedEvent *event;
X{
X  PEXMatrix XCtoNPC;
X  PEXCoord p[2];
X  int err;
X  float t;
X  XWindowAttributes winAttrs;
X  
X  p[0].x = event->x;
X  p[0].y = event->y;
X  p[0].z = 0.0;
X  p[1].x = theAnchorX;
X  p[1].y = theAnchorY;
X  p[1].z = 0.0;
X
X  theRenderProcs.MapXToNPC( 2, p );
X
X  /* this really belongs next to Resize */
X
X#define SWAP(a,b) {t=a;a=b;b=t;}
X
X  if (p[0].x > p[1].x) SWAP(p[0].x, p[1].x);
X  if (p[0].y > p[1].y) SWAP(p[0].y, p[1].y);
X
X  if ((p[1].y - p[0].y) > (p[1].x - p[0].x)) {
X    theWindowSize = (p[1].y - p[0].y)/2.0;
X  } else {
X    theWindowSize = (p[1].x - p[0].x)/2.0;
X  }
X  theWindowCenterX = (p[0].x+p[1].x)/2.0;
X  theWindowCenterY = (p[0].y+p[1].y)/2.0;
X
X  XGetWindowAttributes(theDisplay,theWindow,&winAttrs);
X
X  ResizeWindow(theWindow, winAttrs.width, winAttrs.height );
X
X  theRenderProcs.ReDraw();
X}
X
Xstatic void fbZoomReset(event )
X XButtonReleasedEvent *event;
X{
X  XWindowAttributes winAttrs;
X
X  theWindowSize = 0.5;
X  theWindowCenterX = 0.5;
X  theWindowCenterY = 0.5;
X
X  XGetWindowAttributes(theDisplay,theWindow,&winAttrs);
X
X  ResizeWindow(theWindow, winAttrs.width, winAttrs.height );
X
X  theRenderProcs.ReDraw();
X}
X
X/*************************************************************************
X * fbInitCircle - 
X */
Xstatic void fbInitCircle(event )
X XButtonPressedEvent *event;
X{
X  double angle;
X  int i;
X  double distance;
X
X  theAnchorX = event->x;
X  theAnchorY = event->y;
X  theDynX = event->x+1;
X  theDynY = event->y;
X
X  angle = (2*M_PI) / (double)(TRIMAX-1);
X  distance = sqrt((double)((theDynX-theAnchorX)*(theDynX-theAnchorX) + 
X			   (theDynY-theAnchorY)*(theDynY-theAnchorY)));
X
X  for (i = 0; i < TRIMAX; i++) {
X    theTriDCs[i].x = theDynX + (int)(distance*cos((double)i*angle));
X    theTriDCs[i].y = theDynY + (int)(distance*sin((double)i*angle));;
X  }
X  XDrawLines( theDisplay, theWindow, theDynGC, 
X	     theTriDCs, TRIMAX, CoordModeOrigin );
X}
X
Xstatic void fbEndCircle(event )
X XButtonReleasedEvent *event;
X{
X  XPoint xp[3];
X  PEXCoord *pl;
X  int count;
X
X  xp[0].x = theAnchorX;
X  xp[0].y = theAnchorY;
X  xp[1].x = theDynX;
X  xp[1].y = theDynY;
X
X  xp[2].x = (theDynX == theAnchorY)?theDynX+5:theDynX;
X  xp[2].y = (theDynY == theAnchorY)?theAnchorX+5:theAnchorX;
X
X  if ((count = theRenderProcs.MapXToMC( &theMCMatrix, 3, xp, &pl)) ==  3) {
X    InsertCircleCmd( 3, pl, 1 );
X    free((char *)pl);
X    theRenderProcs.ReDraw();
X  }
X}
X
Xstatic void fbDynCircle(event )
X XMotionEvent *event;
X{
X  double angle;
X  int i;
X  double distance;
X
X  XDrawLines( theDisplay, theWindow, theDynGC, 
X	     theTriDCs, TRIMAX, CoordModeOrigin );
X  theDynX = event->x;
X  theDynY = event->y;
X
X  angle = (2*M_PI) / (double)(TRIMAX-1);
X  distance = sqrt((double)((theDynX-theAnchorX)*(theDynX-theAnchorX) + 
X			   (theDynY-theAnchorY)*(theDynY-theAnchorY)));
X
X  for (i = 0; i < TRIMAX; i++) {
X    theTriDCs[i].x = theDynX + (int)(distance*cos((double)i*angle));
X    theTriDCs[i].y = theDynY + (int)(distance*sin((double)i*angle));;
X  }
X  XDrawLines( theDisplay, theWindow, theDynGC, 
X	     theTriDCs, TRIMAX, CoordModeOrigin );
X}
END_OF_FILE
  if test 27419 -ne `wc -c <'fb.c'`; then
    echo shar: \"'fb.c'\" unpacked with wrong size!
  fi
  # end of 'fb.c'
fi
if test -f 'pexdrawc.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pexdrawc.1'\"
else
  echo shar: Extracting \"'pexdrawc.1'\" \(30534 characters\)
  sed "s/^X//" >'pexdrawc.1' <<'END_OF_FILE'
X#ifdef SCCS
Xstatic char sccsid[]="@(#)pexdraw.c	1.30 Oki Electric Industry Co., Ltd. 93/06/01";
X#endif
X/*
X *			Copyright (c) 1992 by
X *			Oki Electric Industry Co., Ltd.
X *			All Rights Reserved
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted,
X * provided that the above copyright notice appear in all copies and that
X * both that copyright notice and this permission notice appear in
X * supporting documentation, and that the name of Oki not be
X * used in advertising or publicity pertaining to distribution of the
X * software without specific, written prior permission. Oki
X * makes no representations about the suitability of this software for any
X * purpose.  It is provided "as is" without express or implied warranty.
X *
X *************************************************************************
X *
X *                         P E X D R A W
X *
X *  A PEX drawing program based on PDRAW,
X *
X *   
X *
X *************************************************************************/
X
X#include <stdio.h>
X
X#include <math.h>
X
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xatom.h>
X
X#include <X11/PEX5/PEXlib.h>
X
X#define DECL_GLOBALS 1
X
X#include "pexdraw.h"
X
X#define LIGHTMAX 8
XPEXLookupTable	theLightLUT;
XPEXTableIndex	theLightsOn[LIGHTMAX];
Xint		theLightsOnCount = 0;
XPEXTableIndex	theLightsOff[1];
Xint		theLightsOffCount = 0;
X
Xstatic float	AmbientColor[3] = { 1,1,1 };
Xstatic float	LightColor[3] = { 0.9, 0.9, 0.9 };
Xstatic float	LightVector[3] = { 0.0, 0.0, -1.0 };
X
X#define SELECT_COLOR_IND 3
Xstatic int theRandomColorIndex = 1;
X#define RANDOM_COLOR_MAX 8
X
X#define INT_STYLE_ELEM 3
X#define REFL_EQN_ELEM 4
X#define REFL_ATTRS_ELEM 5
X#define INT_SHAD_ELEM 6
X#define LIGHT_SRC_ELEM 7
X#define MATRIX_ELEM 8
X#define FACE_CULL_ELEM 9
X
Xextern renderProcs wksProcs, rdrProcs;
X
Xstatic int theMCSeqNo = 0;
Xint theHPFlag = 0;
X
X/*************************************************************************
X *
X * A P P L I C A T I O N    P R O C E D U R E S
X *
X *************************************************************************
X *
X * Still a little overlap with the selected object interactions.
X */
X
X
X/*************************************************************************
X * TranslateSelected - translate whatever is selected by the given vector
X */
Xvoid
XTranslateSelected(points)
X PEXCoord *points;
X{
X  int error;
X  char *eData;
X  float deltaX, deltaY, deltaZ;
X  PEXCoord *p;
X  int i, nPoints;
X  unsigned long count, length;
X  PEXOCData *ocd, *OCData;
X
X  if ( theSelectedElement == -1 ) return;
X
X  deltaX = points[1].x - points[0].x;
X  deltaY = points[1].y - points[0].y;
X  deltaZ = points[1].z - points[0].z;
X
X  if (!(PEXFetchElements( theDisplay, theSelectedStrux,
X			   PEXBeginning, theSelectedElement+1,
X			   PEXBeginning, theSelectedElement+1, theFF,
X			   &count, &length, &eData ))) { return; }
X
X  OCData = PEXDecodeOCs( theFF, count, length, eData );
X
X  if ( OCData->oc_type  == PEXOCPolyline) {
X
X    nPoints = OCData->data.Polyline.count;
X    p = OCData->data.Polyline.points;
X
X    for (i = 0; i < nPoints; i++, p++ ) {
X      p->x += deltaX;
X      p->y += deltaY;
X      p->z +=deltaZ;
X    }
X
X    PEXSetElementPtr( theDisplay, theSelectedStrux, 
X		     PEXBeginning, theSelectedElement+2 );
X    PEXPolyline(theDisplay, theSelectedStrux, PEXOCStore, nPoints,  
X		OCData->data.Polyline.points);
X    PEXMarkers(theDisplay, theSelectedStrux, PEXOCStore, nPoints,  
X	       OCData->data.Polyline.points);
X    PEXDeleteElements( theDisplay, theSelectedStrux, 
X		      PEXCurrent, -3, PEXCurrent, -2);
X  } else if ( OCData->oc_type == PEXOCTriangleStrip ) { 
X
X    if (OCData->data.TriangleStrip.vertex_attributes) {
X      /* should check to make sure there are no normals!!! */
X      /* it would be fairly easy to work with these, but not now */
X      return;
X    }
X
X    p = OCData->data.TriangleStrip.vertices.no_data;
X
X    for (i = 0; i < OCData->data.TriangleStrip.count; i++, p++ ) {
X      p->x += deltaX;
X      p->y += deltaY;
X      p->z += deltaZ;
X    }
X
X    PEXSetElementPtr( theDisplay, theSelectedStrux, 
X		     PEXBeginning, theSelectedElement+2 );
X    PEXTriangleStrip( theDisplay, theSelectedStrux, PEXOCStore, 
X		     OCData->data.TriangleStrip.facet_attributes,
X		     OCData->data.TriangleStrip.vertex_attributes,
X		     OCData->data.TriangleStrip.color_type,
X		     OCData->data.TriangleStrip.facet_data,
X		     OCData->data.TriangleStrip.count,
X		     OCData->data.TriangleStrip.vertices );
X    PEXMarkers( theDisplay, theSelectedStrux, PEXOCStore, 
X	       OCData->data.TriangleStrip.count,
X	       OCData->data.TriangleStrip.vertices.no_data );
X    PEXDeleteElements( theDisplay, theSelectedStrux, 
X		      PEXCurrent, -3, PEXCurrent, -2 );
X  } else if ( OCData->oc_type == PEXOCNURBCurve ) { 
X
X    if (OCData->data.NURBCurve.rationality == PEXRational) {
X      int i;
X      double w;
X      PEXCoord4D *p4;
X
X      p4 = OCData->data.NURBCurve.points.point_4d;
X      for (i = 0; i < OCData->data.NURBCurve.count; i++, p4++ ) {
X	w = 1.0 / p4->w;
X	p4->x = ((p4->x * w) + deltaX) * p4->w;
X	p4->y = ((p4->y * w) + deltaY) * p4->w;
X	p4->z = ((p4->z * w) + deltaZ) * p4->w;
X      }
X    } else {
X      p = OCData->data.NURBCurve.points.point;
X
X      for (i = 0; i < OCData->data.NURBCurve.count; i++, p++ ) {
X	p->x += deltaX;
X	p->y += deltaY;
X	p->z += deltaZ;
X      }
X    }
X
X    PEXSetElementPtr( theDisplay, theSelectedStrux, 
X		     PEXBeginning, theSelectedElement+2 );
X    PEXNURBCurve(theDisplay, theSelectedStrux, PEXOCStore, 
X		 OCData->data.NURBCurve.rationality,
X		 OCData->data.NURBCurve.order, 
X		 OCData->data.NURBCurve.knots,
X		 OCData->data.NURBCurve.count, OCData->data.NURBCurve.points,
X		 OCData->data.NURBCurve.tmin, OCData->data.NURBCurve.tmax );
X    if (OCData->data.NURBCurve.rationality == PEXRational) {
X      int i;
X      double w;
X      for (i = 0; i < OCData->data.NURBCurve.count; i++ ) {
X	w = 1.0 / OCData->data.NURBCurve.points.point_4d[i].w;
X	OCData->data.NURBCurve.points.point[i].x = 
X	  OCData->data.NURBCurve.points.point_4d[i].x * w;
X	OCData->data.NURBCurve.points.point[i].y = 
X	  OCData->data.NURBCurve.points.point_4d[i].y * w;
X	OCData->data.NURBCurve.points.point[i].z = 
X	  OCData->data.NURBCurve.points.point_4d[i].z * w;
X      }
X    }
X    PEXMarkers( theDisplay, theSelectedStrux, PEXOCStore, 
X	       OCData->data.NURBCurve.count,
X	       OCData->data.NURBCurve.points.point );
X    PEXDeleteElements( theDisplay, theSelectedStrux, 
X		      PEXCurrent, -3, PEXCurrent, -2 );
X  } else if ( OCData->oc_type == PEXOCText ) { 
X
X    OCData->data.EncodedText.origin.x += deltaX;
X    OCData->data.EncodedText.origin.y += deltaY;
X    OCData->data.EncodedText.origin.z += deltaZ;
X
X    PEXSetElementPtr( theDisplay, theSelectedStrux, 
X		     PEXBeginning, theSelectedElement+2 );
X    PEXEncodedText( theDisplay, theSelectedStrux, PEXOCStore, 
X		   &OCData->data.EncodedText.origin,
X		   &OCData->data.EncodedText.vector1,
X		   &OCData->data.EncodedText.vector2,
X		   OCData->data.EncodedText.count,
X		   OCData->data.EncodedText.encoded_text );
X    PEXMarkers( theDisplay, theSelectedStrux, PEXOCStore, 1,
X	       &OCData->data.EncodedText.origin );
X    PEXDeleteElements( theDisplay, theSelectedStrux, 
X		      PEXCurrent, -3, PEXCurrent, -2 );
X  } else {
X    printf("imagine a Motif alarm! selecting unknown element type %d\n",
X	   OCData->oc_type );
X    return;
X  }
X}
X
X/*************************************************************************
X * StretchSelected
X */
XStretchSelected(points)
X     PEXCoord *points;
X{
X  int error;
X  char *eData;
X  float deltaX, deltaY, deltaZ;
X  PEXCoord *p;
X  int i, nPoints;
X  unsigned long count, length;
X  PEXOCData *ocd, *OCData;
X
X  if ( theSelectedElement == -1 ) return;
X
X  if (!(PEXFetchElements( theDisplay, theSelectedStrux,
X			   PEXBeginning, theSelectedElement+1,
X			   PEXBeginning, theSelectedElement+1, theFF,
X			   &count, &length, &eData ))) { return; }
X
X  OCData = PEXDecodeOCs( theFF, count, length, eData );
X
X  if (OCData->oc_type  == PEXOCPolyline) {
X
X    nPoints = OCData->data.Polyline.count;
X    p = OCData->data.Polyline.points;
X
X    p[theSelectedIndex] = points[0];
X    PEXSetElementPtr( theDisplay, theSelectedStrux,
X		     PEXBeginning,  theSelectedElement+2 );
X    PEXPolyline(theDisplay, theSelectedStrux, PEXOCStore, nPoints,
X		OCData->data.Polyline.points);
X    PEXMarkers(theDisplay, theSelectedStrux, PEXOCStore, nPoints,
X		OCData->data.Polyline.points);
X    PEXDeleteElements( theDisplay, theSelectedStrux, 
X		      PEXCurrent, -3, PEXCurrent, -2);
X  } else if (OCData->oc_type == PEXOCTriangleStrip ) { 
X
X    if (OCData->data.TriangleStrip.vertex_attributes) {
X      /* should check to make sure there are no normals!!! */
X      return;
X    }
X
X    p = OCData->data.TriangleStrip.vertices.no_data;
X    p[theSelectedIndex] = points[0];
X
X    PEXSetElementPtr( theDisplay, theSelectedStrux,
X		     PEXBeginning,  theSelectedElement+2 );
X    PEXTriangleStrip( theDisplay, theSelectedStrux, PEXOCStore, 
X		     OCData->data.TriangleStrip.facet_attributes,
X		     OCData->data.TriangleStrip.vertex_attributes,
X		     OCData->data.TriangleStrip.color_type,
X		     OCData->data.TriangleStrip.facet_data,
X		     OCData->data.TriangleStrip.count,
X		     OCData->data.TriangleStrip.vertices );
X    PEXMarkers( theDisplay, theSelectedStrux, PEXOCStore, 
X	       OCData->data.TriangleStrip.count,
X	       OCData->data.TriangleStrip.vertices.no_data );
X    PEXDeleteElements( theDisplay, theSelectedStrux, 
X		      PEXCurrent, -3, PEXCurrent, -2);
X  } else if ( OCData->oc_type == PEXOCNURBCurve ) { 
X
X    if (OCData->data.NURBCurve.rationality == PEXRational) {
X      PEXCoord4D *p4;
X
X      p4 = OCData->data.NURBCurve.points.point_4d;
X      p4[theSelectedIndex].x = points[0].x * p4[theSelectedIndex].w;
X      p4[theSelectedIndex].y = points[0].y * p4[theSelectedIndex].w;
X      p4[theSelectedIndex].z = points[0].z * p4[theSelectedIndex].w;
X    } else {
X      p = OCData->data.NURBCurve.points.point;
X      p[theSelectedIndex] = points[0];
X    }
X
X    PEXSetElementPtr( theDisplay, theSelectedStrux, 
X		     PEXBeginning, theSelectedElement+2 );
X    PEXNURBCurve(theDisplay, theSelectedStrux, PEXOCStore, 
X		 OCData->data.NURBCurve.rationality,
X		 OCData->data.NURBCurve.order, 
X		 OCData->data.NURBCurve.knots,
X		 OCData->data.NURBCurve.count, OCData->data.NURBCurve.points,
X		 OCData->data.NURBCurve.tmin, OCData->data.NURBCurve.tmax );
X    if (OCData->data.NURBCurve.rationality == PEXRational) {
X      int i;
X      double w;
X      for (i = 0; i < OCData->data.NURBCurve.count; i++ ) {
X	w = 1.0 / OCData->data.NURBCurve.points.point_4d[i].w;
X	OCData->data.NURBCurve.points.point[i].x = 
X	  OCData->data.NURBCurve.points.point_4d[i].x * w;
X	OCData->data.NURBCurve.points.point[i].y = 
X	  OCData->data.NURBCurve.points.point_4d[i].y * w;
X	OCData->data.NURBCurve.points.point[i].z = 
X	  OCData->data.NURBCurve.points.point_4d[i].z * w;
X      }
X    }
X    PEXMarkers( theDisplay, theSelectedStrux, PEXOCStore, 
X	       OCData->data.NURBCurve.count,
X	       OCData->data.NURBCurve.points.point );
X    PEXDeleteElements( theDisplay, theSelectedStrux, 
X		      PEXCurrent, -3, PEXCurrent, -2 );
X  } else if ( OCData->oc_type == PEXOCText ) { 
X
X    OCData->data.EncodedText.origin = points[0];
X
X    PEXSetElementPtr( theDisplay, theSelectedStrux, 
X		     PEXBeginning, theSelectedElement+2 );
X    PEXEncodedText( theDisplay, theSelectedStrux, PEXOCStore, 
X		   &OCData->data.EncodedText.origin,
X		   &OCData->data.EncodedText.vector1,
X		   &OCData->data.EncodedText.vector2,
X		   OCData->data.EncodedText.count,
X		   OCData->data.EncodedText.encoded_text );
X    PEXMarkers( theDisplay, theSelectedStrux, PEXOCStore, 1,
X	       &OCData->data.EncodedText.origin );
X    PEXDeleteElements( theDisplay, theSelectedStrux, 
X		      PEXCurrent, -3, PEXCurrent, -2 );
X  } else {
X    printf("imagine a Motif alarm! selecting unknown element type %d, %d\n",
X	   OCData->oc_type );
X  }
X}
X
X/*************************************************************************
X * SelectSomething - make something look selected.
X *
X */
Xvoid SelectSomething(strux,element)
X long strux;
X long element;
X{
X  int error;
X  char *eData;
X  PEXCoord *p;  
X  int nPoints;
X  unsigned long count, length;
X  PEXOCData *OCData;
X
X  if (!(PEXFetchElements( theDisplay, strux,
X			    PEXBeginning, element, PEXBeginning, element, 
X			    theFF, &count, &length, &eData ))) { return; }
X
X  PEXSetElementPtr( theDisplay, strux, PEXBeginning,  element );
X
X  OCData = PEXDecodeOCs( theFF, count, length, eData );
X
X  if (OCData->oc_type  == PEXOCPolyline) {
X
X    nPoints = OCData->data.Polyline.count;
X    p = OCData->data.Polyline.points;
X    PEXMarkers(theDisplay, strux, PEXOCStore, nPoints, p);
X    PEXSetElementPtr( theDisplay, strux, PEXCurrent,  -2 );
X    PEXSetLineColorIndex( theDisplay, strux, PEXOCStore,
X			 SELECT_COLOR_IND);
X  } else if (OCData->oc_type == PEXOCTriangleStrip ) { 
X
X   if (OCData->data.TriangleStrip.vertex_attributes) {
X      /* should check to make sure there are no normals!!! */
X      /* it would be fairly easy to work with these, but not now */
X      return;
X    }
X
X    PEXMarkers(theDisplay, strux, PEXOCStore, 
X	       OCData->data.TriangleStrip.count, 
X	       OCData->data.TriangleStrip.vertices.no_data );
X    PEXSetElementPtr( theDisplay, strux, PEXCurrent,  -2 );
X    PEXSetSurfaceColorIndex( theDisplay, strux, PEXOCStore, 
X			    SELECT_COLOR_IND);
X  } else if (OCData->oc_type == PEXOCNURBCurve ) { 
X
X    if (OCData->data.NURBCurve.rationality == PEXRational) {
X      int i;
X      double w;
X      for (i = 0; i < OCData->data.NURBCurve.count; i++ ) {
X	w = 1.0 / OCData->data.NURBCurve.points.point_4d[i].w;
X	OCData->data.NURBCurve.points.point[i].x = 
X	  OCData->data.NURBCurve.points.point_4d[i].x * w;
X	OCData->data.NURBCurve.points.point[i].y = 
X	  OCData->data.NURBCurve.points.point_4d[i].y * w;
X	OCData->data.NURBCurve.points.point[i].z = 
X	  OCData->data.NURBCurve.points.point_4d[i].z * w;
X      }
X    }
X
X    PEXMarkers(theDisplay, strux, PEXOCStore, 
X	       OCData->data.NURBCurve.count, 
X	       OCData->data.NURBCurve.points.point );
X    PEXSetElementPtr( theDisplay, strux, PEXCurrent,  -2 );
X    PEXSetLineColorIndex( theDisplay, strux, PEXOCStore, 
X			    SELECT_COLOR_IND);
X  } else if (OCData->oc_type == PEXOCText ) { 
X
X    if (GetTextRect(OCData, theSelectedStrux, theSelectedElement-1, &p)) {
X      PEXMarkers(theDisplay, strux, PEXOCStore, 4, p);
X    } else {
X      PEXMarkers(theDisplay, strux, PEXOCStore, 1,
X		 &OCData->data.EncodedText.origin );
X    }
X    PEXSetElementPtr( theDisplay, strux, PEXCurrent,  -2 );
X    PEXSetTextColorIndex( theDisplay, strux, PEXOCStore, 
X			    SELECT_COLOR_IND);
X  } else {
X    printf("imagine a Motif alarm! selecting unknown element type %d\n",
X	   OCData->oc_type );
X    PEXFreeOCData(count, OCData);
X    free(eData);
X    return;
X  }
X
X  theSelectedStrux = strux;
X  theSelectedElement = element;
X  PEXFreeOCData(count, OCData);
X  free(eData);
X}
X
X/*************************************************************************
X * ClearSelection
X *
X * Implicitly knows that each element has a color followed by a primitive
X *  - color
X *  - primitive
X *  
X * The selected Element has an extra color between the color & prim and 
X * the point primitive directly afterwords.  Two extra elements.  This
X * will be a headache if multiple elements are allowed to be selected.
X *
X *  - color
X *  - select color
X *  - primitive
X *  - points.
X *
X * The selected color is really at theSelectedElement. Set the pointer and 
X * delete it. The element pointer moves forward.  Skip two elements and 
X * delete the points.
X *
X */
Xvoid ClearSelection()
X{
X  if ( theSelectedElement == -1 ) return;
X
X  PEXDeleteElements( theDisplay, theSelectedStrux,
X		    PEXBeginning, theSelectedElement,
X		    PEXBeginning, theSelectedElement);
X
X  PEXDeleteElements( theDisplay, theSelectedStrux,
X		    PEXBeginning, theSelectedElement+1,
X		    PEXBeginning, theSelectedElement+1);
X
X  theSelectedStrux = -1;
X  theSelectedElement= -1;
X}
X
X/*************************************************************************
X * DeleteSelected
X */
Xvoid DeleteSelected()
X{
X  if ( theSelectedElement == -1 ) return;
X
X  PEXDeleteElements( theDisplay, theSelectedStrux,
X		    PEXBeginning, theSelectedElement-1,
X		    PEXBeginning, theSelectedElement+2);
X
X  theSelectedStrux = -1;
X  theSelectedElement= -1;
X
X}
X/*************************************************************************
X * ColorGroup -- this is in lieu of SelectGroup and the management of
X * a group of selected objects.
X *
X */
Xvoid ColorGroup( count, struxArray, elemArray )
X     int count;
X     long *struxArray;
X     int *elemArray;
X{
X  int i;
X  unsigned long length;
X
X  PEXElementInfo *eInfo;
X  unsigned long eCount;
X
X  if ( ++theRandomColorIndex > RANDOM_COLOR_MAX) theRandomColorIndex = 2;
X
X  for (i = 0; i < count; i++ ) {
X       if(PEXGetElementInfo(theDisplay, struxArray[i],
X			    PEXBeginning, elemArray[i],
X			    PEXBeginning, elemArray[i],
X			    theFF, &eCount, &eInfo )){
X    if ((eCount == 1) &&
X	((eInfo->type >= OCPRIMTAB_BASE) && (eInfo->type <= OCPRIMTAB_MAX))) {
X
X      PEXDeleteElements( theDisplay, struxArray[i],
X			PEXBeginning, elemArray[i]-1,
X			PEXBeginning, elemArray[i]-1 );
X
X      switch (myOCPrimType[eInfo->type-OCPRIMTAB_BASE]) {
X      case OCPRIM_MARKER:
X	PEXSetMarkerColorIndex( theDisplay, struxArray[i], PEXOCStore,
X			     theRandomColorIndex );
X	break;
X      case OCPRIM_LINE:
X	PEXSetLineColorIndex( theDisplay, struxArray[i], PEXOCStore,
X			     theRandomColorIndex );
X	break;
X      case OCPRIM_PGON:
X	PEXSetSurfaceColorIndex( theDisplay, struxArray[i], PEXOCStore, 
X			     theRandomColorIndex );
X	break;
X      case OCPRIM_TEXT:
X	PEXSetTextColorIndex( theDisplay, struxArray[i], PEXOCStore,
X			     theRandomColorIndex );
X	break;
X      default:
X	break;
X      }
X    }
X  } else { printf("PEXGetStructureInfo failed\n");}
X}
X}
X
X/*************************************************************************
X * InitStrux
X */
XPEXStructure 
XInitStrux()
X{
X  PEXName names[2];
X  int error;
X  PEXMatrix matrix;
X  PEXReflectionAttributes reflAttrs;
X  PEXStructure struxid;
X
X  struxid = PEXCreateStructure(theDisplay);
X
X  PEXSetEditingMode(theDisplay, struxid, PEXStructureInsert);
X
X  theRenderProcs.Post( struxid );
X
X  /*
X   * need this for picking
X   */
X  names[0] = 2;
X  names[1] = 1;
X  PEXAddToNameSet(theDisplay, struxid, PEXOCStore, 2, names );
X
X  PEXSetViewIndex(theDisplay, struxid, PEXOCStore, 1);
X
X  /* INT_STYLE_ELEM == element 3 */
X  PEXSetInteriorStyle(theDisplay, struxid, PEXOCStore, PEXInteriorStyleHollow );
X
X  /* REFL_EQN_ELEM  == element 4 */
X  PEXSetReflectionModel(theDisplay, struxid, PEXOCStore, PEXReflectionSpecular);
X
X  /* set the area properties */
X  reflAttrs.ambient = 0.3;
X  reflAttrs.diffuse = 0.3;
X  reflAttrs.specular = 0.7;
X  reflAttrs.specular_conc = 50.0;
X  reflAttrs.transmission = 0.0;
X  reflAttrs.specular_color.type = PEXColorTypeRGB;
X  reflAttrs.specular_color.value.rgb.red   = 1.0;
X  reflAttrs.specular_color.value.rgb.green = 1.0;
X  reflAttrs.specular_color.value.rgb.blue  = 1.0;
X
X  PEXSetReflectionAttributes(theDisplay, struxid, PEXOCStore, &reflAttrs);
X  /* INT_SHAD_ELEM  == element */
X  PEXSetSurfaceInterpMethod(theDisplay, struxid, PEXOCStore, 
X			    PEXSurfaceInterpNone);
X  PEXSetLightSourceState(theDisplay, struxid, PEXOCStore, 
X			 theLightsOnCount, theLightsOn, 
X			 theLightsOffCount, theLightsOff );
X  PEXRotate(PEXXAxis, 0.0, theMCMatrix.matrix );
X  PEXSetLocalTransform(theDisplay, struxid, PEXOCStore, PEXReplace, 
X		       theMCMatrix.matrix);
X  theMCMatrix.strux = struxid;
X  theMCMatrix.seqNo = ++theMCSeqNo;
X
X  return (struxid);
X}
X
X/*************************************************************************
X * InsertLine
X */
Xvoid InsertLineCmd( nPoints, points, select )
X     int nPoints;
X     PEXCoord *points;
X     int select;
X{
X
X  int error, e;
X
X  if (theNewStrux == 0) {
X    theNewStrux = InitStrux();
X  } else if ( theSelectedElement != -1 ) {
X    ClearSelection();
X  }
X
X  PEXSetElementPtr( theDisplay, theNewStrux, PEXEnd,  0 );
X
X  PEXSetLineColorIndex( theDisplay, theNewStrux, PEXOCStore, 1);
X
X  PEXPolyline(theDisplay, theNewStrux, PEXOCStore, nPoints, points);
X
X  if (select) {
X    PEXStructureInfo info;
X
X    if (PEXGetStructureInfo(theDisplay, theNewStrux, theFF, PEXElementPtr,
X			    &info )) {
X      SelectSomething( theNewStrux, info.element_pointer );
X    } else { printf("PEXGetStructureInfo failed\n");}
X  }
X}
X
X/*************************************************************************
X * InsertTriStrip
X */
Xvoid
XInsertTriStripCmd( nPoints, points, select )
X     int nPoints;
X     PEXCoord *points;
X     int select;
X{
X  int error, e;
X  PEXArrayOfFacetData tooLateToCast;
X  PEXArrayOfVertex too;  /* should be able to cast these somehow, too late */
X
X  if (theNewStrux == 0) {
X    theNewStrux = InitStrux();
X  } else if ( theSelectedElement != -1 ) {
X    ClearSelection();
X  }
X
X  PEXSetElementPtr( theDisplay, theNewStrux, PEXEnd,  0 );
X
X  PEXSetSurfaceColorIndex( theDisplay, theNewStrux, PEXOCStore, 1);
X  too.no_data = points;
X  tooLateToCast.index = NULL;
X  PEXTriangleStrip( theDisplay, theNewStrux, PEXOCStore, 0, 0, PEXColorTypeRGB,
X		   tooLateToCast, nPoints, too);
X
X  if (select) {
X    PEXStructureInfo  info;
X
X    if (PEXGetStructureInfo(theDisplay, theNewStrux, theFF, PEXElementPtr,
X			    &info )) {
X      SelectSomething( theNewStrux, info.element_pointer );
X    } else { printf("PEXGetStructureInfo failed\n");}
X  }
X}
X
X/*************************************************************************
X * InsertNURBCurveCmd
X */
Xvoid InsertNURBCurveCmd( nPoints, points, select )
X     int nPoints;
X     PEXCoord *points;
X     int select;
X{
X  int order = 3;
X  float *knots, knotValue;
X  int error, e, i;
X  PEXArrayOfCoord p;
X
X  if (nPoints < order) {printf("not enough points\n"); return;}
X
X  if (theNewStrux == 0) {
X    theNewStrux = InitStrux();
X  } else if ( theSelectedElement != -1 ) {
X    ClearSelection();
X  }
X
X  knots = (float *)malloc((nPoints+order)*sizeof(float)); if (!knots)
X    {printf("Knots\n"); exit(1);}
X  p.point = points;
X
X  /*
X   * generate a knot vector for a uniform B-splines
X   */
X  knotValue = 0.0;
X  for (i = 0; i < order; i++ ) knots[i] = knotValue;
X  knotValue++;
X  for (i = order; i < nPoints; i++, knotValue++) knots[i] = knotValue;
X  for (i = nPoints; i < nPoints+order; i++ ) knots[i] = knotValue;
X
X  PEXSetElementPtr( theDisplay, theNewStrux, PEXEnd,  0 );
X
X  PEXSetLineColorIndex( theDisplay, theNewStrux, PEXOCStore, 1);
X
X  PEXNURBCurve(theDisplay, theNewStrux, PEXOCStore, PEXNonRational, order, 
X	       knots, (unsigned int)nPoints, p, 
X	       (double)0.0, (double)knotValue);
X
X  free((char *)knots);
X
X  if (select) {
X    PEXStructureInfo info;
X
X    if (PEXGetStructureInfo(theDisplay, theNewStrux, theFF, PEXElementPtr,
X			    &info )) {
X      SelectSomething( theNewStrux, info.element_pointer );
X    } else { printf("PEXGetStructureInfo failed\n");}
X  }
X}
X
Xvoid Cross3D( A, B, C )
X     PEXVector *A;
X     PEXVector *B;
X     PEXVector *C;
X{
X  C->x = (A->y * B->z) - (A->z * B->y);
X  C->y = (A->z * B->x) - (A->x * B->z);
X  C->z = (A->x * B->y) - (A->y * B->x);
X}
X
X/*************************************************************************
X * InsertCircleCmd - do a rational NURB. There are at least three ways to do
X *  this:
X * 2 are found on page 374, Mathematical Elements for Computer Graphics, 
X *   2nd ed. David F. Rogers and J Alan Adams. McGraw Hill, 1990.
X * One of which is the triangle method, using 7 control points at the corners
X *   and middles of an equilateral triangle, with knot vector
X *   [ 0, 0, 0, 1, 1, 2, 2, 3, 3, 3 ] and weights ( or H or W values )
X *   [ 1.0, 0.5, 1.0, 0.5, 1.0, 0.5, 1.0]
X *
X * The second is a square, with control points at the corners and midpoints.
X *  X (knots) = [0,0,0,1,1,2,2,3,3,4,4,4]
X *  W         = [1.0, 0.707, 1.0, 0.707, 1.0, 0.707, 1.0] 
X *                                           0.707 = sqrt(2)/sqrt(2)
X *
X * A third is a square, but only two of the sides have midpoint controls.
X *  X [ 0,0,0, 0.25, 0.5, 0.5, 0.75, 1,1,1]
X *  W [1, 0.5, 0.5, 1, 0.5, 0.5, 1]
X * from Piegl, Les. On NURBS: A Survey. IEEE CG&A, January 1991.
X *
X * We are going to use the triangle.
X *
X * we have two points, center of circle & triangle & p1 == p7.
X *  distance to p2, & p6  is RADICAL3 * distance from p1 to center.
X *  distance from p1 to p4 ( top of triangle ) is 3 * distance to center.
X *  just make p3 & p5 midpoints.
X *
X * We must have a thrid point to construct the plane.
X *
X */
Xvoid InsertCircleCmd( nPoints, points, select )
X     int nPoints;
X     PEXCoord *points;
X     int select;
X{
X  int order = 3;
X  float knots[10];
X  PEXCoord4D p4[7];
X  PEXArrayOfCoord p;
X  double distance;
X  PEXVector A, B, C;
X
X  if (nPoints != 3) {printf("not enough points\n"); return;}
X
X  if (theNewStrux == 0) {
X    theNewStrux = InitStrux();
X  } else if ( theSelectedElement != -1 ) {
X    ClearSelection();
X  }
X
X  A.x = points[0].x - points[1].x;
X  A.y = points[0].y - points[1].y;
X  A.z = points[0].z - points[1].z;
X
X  B.x = points[2].x - points[1].x;
X  B.y = points[2].y - points[1].y;
X  B.z = points[2].z - points[1].z;
X
X  Cross3D( &A, &B, &C );
X  Cross3D( &A, &C, &B );
X  PEXNormalizeVectors( 1, &B, &B );
X
X  /* 
X   * B now contains a unit vector perpedicular to A in the plane
X   * defined by the three input points.  After we get the distance
X   * we can define all of the points of the equilateral triangle.
X   */
X  distance = sqrt(A.x*A.x + A.y*A.y + A.z*A.z);
X
X#define RADICAL3 1.732
X
X  p4[0].x =points[0].x; p4[0].y =points[0].y; p4[0].z =points[0].z; 
X  p4[0].w = 1.0;
X
X  p4[6] = p4[0];
X
X  /*
X   * rational NURB control points are given as x*w, y*w, z*w, w 
X   * p1 & p7 are the midpoint of the base.
X   * p2 & p6 are the corners of base.
X   */
X  p4[1].w = 0.5;
X  p4[1].x = (points[0].x + RADICAL3 * distance * B.x) * p4[1].w;
X  p4[1].y = (points[0].y + RADICAL3 * distance * B.y) * p4[1].w;
X  p4[1].z = (points[0].z + RADICAL3 * distance * B.z) * p4[1].w;
X
X  p4[5].w = 0.5;
X  p4[5].x = (points[0].x - RADICAL3 * distance * B.x) * p4[1].w;
X  p4[5].y = (points[0].y - RADICAL3 * distance * B.y) * p4[1].w;
X  p4[5].z = (points[0].z - RADICAL3 * distance * B.z) * p4[1].w;
X
X  /* the top of the triangle is 3X past the center */
X
X  p4[3].w = 0.5;
X  p4[3].x = (points[0].x - 3 * A.x) * p4[1].w;
X  p4[3].y = (points[0].y - 3 * A.y) * p4[1].w;
X  p4[3].z = (points[0].z - 3 * A.z) * p4[1].w;
X
X  /* now get the midpoints, special case of weights = 0.5 !!! */
X
X  p4[2].w = p4[1].w + p4[3].w;
X  p4[2].x = p4[1].x + p4[3].x;
X  p4[2].y = p4[1].y + p4[3].y;
X  p4[2].z = p4[1].z + p4[3].z;
X
X  p4[4].w = p4[5].w + p4[3].w;
X  p4[4].x = p4[5].x + p4[3].x;
X  p4[4].y = p4[5].y + p4[3].y;
X  p4[4].z = p4[5].z + p4[3].z;
X
X  p.point_4d = p4;
X
X  /*
X   * generate a knot vector for a uniform B-splines
X   *   [ 0, 0, 0, 1, 1, 2, 2, 3, 3, 3 ]
X   */
X  knots[0] = 0; knots[1] = 0; knots[2] = 0;
X  knots[3] = 1; knots[4] = 1;  
X  knots[5] = 2; knots[6] = 2;
X  knots[7] = 3; knots[8] = 3; knots[9] = 3;
X
X  PEXSetElementPtr( theDisplay, theNewStrux, PEXEnd,  0 );
X
X  PEXSetLineColorIndex( theDisplay, theNewStrux, PEXOCStore, 1);
X
X  PEXNURBCurve(theDisplay, theNewStrux, PEXOCStore, PEXRational,
X	       order, knots, (unsigned int)7, p, 
X	       (double)0.0, (double)3.0);
X
X  if (select) {
X    PEXStructureInfo info;
X
X    if (PEXGetStructureInfo(theDisplay, theNewStrux, theFF, PEXElementPtr,
X			    &info )) {
X      SelectSomething( theNewStrux, info.element_pointer );
X    } else { printf("PEXGetStructureInfo failed\n");}
X  }
X}
X
X/*************************************************************************
X * InsertPolygonCmd
X */
Xvoid InsertPolygonCmd( nPoints, points, select )
X     int nPoints;
X     PEXCoord *points;
X     int select;
X{
X
X  if (nPoints < 3) {printf("not enough points\n"); return;}
X
X  if (theNewStrux == 0) {
X    theNewStrux = InitStrux();
X  } else if ( theSelectedElement != -1 ) {
X    ClearSelection();
X  }
X
X  PEXSetElementPtr( theDisplay, theNewStrux, PEXEnd,  0 );
X
X  PEXSetSurfaceColorIndex( theDisplay, theNewStrux, PEXOCStore, 1);
X
X  PEXFillArea(theDisplay, theNewStrux, PEXOCStore, PEXShapeUnknown, 
X	      True, /* ignore edges, for the heck of it */
X	       (unsigned int)nPoints, points );
X
X  if (select) {
X    PEXStructureInfo info;
X
X    if (PEXGetStructureInfo(theDisplay, theNewStrux, theFF, PEXElementPtr,
X			    &info )) {
X      SelectSomething( theNewStrux, info.element_pointer );
X    } else { printf("PEXGetStructureInfo failed\n");}
X  }
X}
X
X/*************************************************************************
X * InsertTextCmd - 
X */
Xvoid InsertTextCmd( point,nChars,charStr, flags, select )
X     PEXCoord *point;
X     int nChars;
X     char *charStr;
X     int flags;
X     int select;
X{
X  PEXVector vector1, vector2;
X  int error, e;
X
X  if (theNewStrux == 0) {
X    theNewStrux = InitStrux();
X  } else if ( theSelectedElement != -1 ) {
X    ClearSelection();
X  }
X
X    vector1.x = 1.0;
X    vector1.y = 0.0;
X    vector1.z = 0.0;
X    vector2.x = 0.0;
X    vector2.y = 1.0;
X    vector2.z = 0.0;
X
X  PEXSetElementPtr( theDisplay, theNewStrux, PEXEnd,  0 );
X
X  PEXSetTextColorIndex( theDisplay, theNewStrux, PEXOCStore, 1);
X
X  PEXText(theDisplay, theNewStrux, PEXOCStore,
X	  point, &vector1, &vector2, nChars, charStr );
X
X  if (select) {
X    PEXStructureInfo info;
X
X    if (PEXGetStructureInfo(theDisplay, theNewStrux, theFF, PEXElementPtr,
X			    &info )) {
X      SelectSomething( theNewStrux, info.element_pointer );
X    } else { printf("PEXGetStructureInfo failed\n");}
X  }
X}
X
X/*************************************************************************
X *  GetXPointsFromSelected
X *
X *  generate X coordinates for each vertex of the selected object.
X *   - inquire element contents
X *   - map from world [should be model] to screen using MapWCPointsToX
X *
X * ALLOCATES points array.
X */
Xint
XGetXPointsFromSelected(nPoints_return, points )
X     int *nPoints_return;
X     XPoint **points;
X{
X  int i;
X  int error;
X  char *eData;
X  PEXCoord *p;  
X  int nPoints, nGot;
X  unsigned long count, length;
X  PEXOCData *OCData, *matrixOC;
X  MCMatrix mc;
X
X  if (!(PEXFetchElements( theDisplay, theSelectedStrux,
X			   PEXBeginning, theSelectedElement+1,
X			   PEXBeginning, theSelectedElement+1, theFF,
X			   &count, &length, &eData ))) { return; }
X
X
X  OCData = PEXDecodeOCs( theFF, count, length, eData );
X  XFree((char *)eData);
X
X  if (OCData->oc_type  == PEXOCPolyline) {
X    nPoints = OCData->data.Polyline.count;
X    p = OCData->data.Polyline.points;
END_OF_FILE
  if test 30534 -ne `wc -c <'pexdrawc.1'`; then
    echo shar: \"'pexdrawc.1'\" unpacked with wrong size!
  fi
  # end of 'pexdrawc.1'
fi
echo shar: End of archive 9 \(of 14\).
cp /dev/null ark9isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo "concatentating pexdraw.c ..."
    cat pexdrawc.? > pexdraw.c
    rm pexdrawc.?
    echo "concatentating pexdraw.uil ..."
    cat pexdrawu.? > pexdraw.uil
    rm pexdrawu.?
    echo "concatentating teapot.c ..."
    rm teapotc.?
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM       | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@imd.sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
