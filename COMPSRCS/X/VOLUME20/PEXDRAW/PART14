Newsgroups: comp.sources.x
From: jch@okimicro.oki.com (Jan Hardenbergh)
Subject: v20i024:  pexdraw - A PEX drawing program, Part14/14
Message-ID: <1993Jun8.150344.19549@sparky.imd.sterling.com>
X-Md4-Signature: 9247c12f38adfbf44d5ee2db3cfdb38b
Sender: chris@sparky.imd.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Tue, 8 Jun 1993 15:03:44 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: jch@okimicro.oki.com (Jan Hardenbergh)
Posting-number: Volume 20, Issue 24
Archive-name: pexdraw/part14
Environment: X11R5, PEX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  Imakefile XMU/CmapAlloc.c XMU/LookupCmap.c rgbc.c
#   util/pexutcmaphp.h util/pexutcmapint.h
# Wrapped by chris@sparky on Tue Jun  8 09:46:38 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 14 (of 14)."'
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
  echo shar: Extracting \"'Imakefile'\" \(3809 characters\)
  sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
X/*
X *			Copyright (c) 1992,1993 by
X *			Oki Electric Industry Co., Ltd.
X *			All Rights Reserved
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted,
X * provided that the above copyright notice appear in all copies and that
X * both that copyright notice and this permission notice appear in
X * supporting documentation, and that the name of Oki not be
X * used in advertising or publicity pertaining to distribution of the
X * software without specific, written prior permission. Oki
X * makes no representations about the suitability of this software for any
X * purpose.  It is provided "as is" without express or implied warranty.
X *************************************************************************
X *
X *                         P E X D R A W
X *
X *  A PEX drawing program. (or the baby CAD program)
X *
X *  %xmkmf  [-DNO_MOTIF if no Motif]
X *
X *  Jan "YON" Hardenbergh, May 1993
X *
X * Note: MSimpleUidTarget(pdraw) is a Motif rule. As are:
X *    $(MRESOURCELIB) $(XMLIB)
X *
X * iffa you agotta no motif, add -DNO_MOTIF to your imake command, or as
X * David Boyce said, just do xmkmf, ^c then copy the line and add...
X *
X * This will build the pexdraw application and five other sample's that can
X * be "Executed" from pexdraw to create various structures. These create
X * a PEX cube, PEXlib logo, an RGB cude, a teapot and a SOFAS example.
X *
X */
X
X#ifdef SVR4
XUCBLIB = /usr/ucblib/libucb.a
X#endif
X
X#ifndef NO_MOTIF
X#ifdef MOTIF
X#include "Motif.tmpl"
X#include "Motif.rules"
XMOTIF_LIBS =  $(MRESOURCELIB) $(XMLIB) $(UCBLIB)
X#endif
X#if (!defined(MOTIF) || defined(UseInstalled))
X/* the version of Motif.tmpl I have is broken with respect to R5... */
XMOTIF_LIBS = -lMrm -lXm  $(UCBLIB)
X#endif
X#else
XMOTIF_LIBS = 
X#endif
X
X#define IHaveSubdirs
X
X/* Hopefully, you have the patched Project.tmpl when you imake
X * otherwise, use one of these.
X * PEXLIB=$(TOP)/extensions/lib/PEXlib/libPEX5.a
X * PEXLIB=-lPEX5
X */
XDBUTOBJS = util/pexutdb.o util/pexutdbint.o \
X	 util/pexutcmap.o  util/pexutcmapint.o util/pexutcmaphp.o
X
XLOCAL_LIBRARIES = $(MOTIF_LIBS) $(XTOOLLIB) $(XMULIB) $(PEXLIB) -lm $(XLIB) -lgen -lw
XXOCAL_LIBRARIES = $(XMULIB) $(PEXLIB) -lm $(XLIB)
X
XSLOCAL_LIBS =  $(PEXLIB) -lm $(XLIB)
X
XDEFINES = 
XINCLUDES = -I.  -I$(MTOOLKITSRC) -I$(TOP) -I$(TOP)/X11/extensions
XCCOPTIONS = $(G)
X
X
XPOBJS = pexdraw.o ui.o fb.o wks.o rdr.o init.o $(DBUTOBJS)
XXOBJS = pexdraw.o ui_x.o fb.o wks.o rdr.o init.o $(DBUTOBJS)
X
XPLCOBJS = plcube.o
XRGBC    = rgbc.o
XSOFAS   = sofas.o
XTEAPOT  = teapot.o
XPLOGO   = plogo.o
X	
X#ifdef IHaveSubdirs
X#define PassCDebugFlags 
X SUBDIRS = util
X
XMakeSubdirs($(SUBDIRS))
XDependSubdirs($(SUBDIRS))
X#endif
X
Xall:: pexdraw plcube rgbc sofas teapot
X
X#ifndef NO_MOTIF
XNormalProgramTarget(pexdraw,$(POBJS),,$(LOCAL_LIBRARIES),)
X#endif
X
XNormalProgramTarget(pxd,$(XOBJS),,$(LOCAL_LIBRARIES),)
X
XNormalProgramTarget(plcube,$(PLCOBJS),,$(SLOCAL_LIBS),)
X
XNormalProgramTarget(rgbc,$(RGBC),,$(SLOCAL_LIBS),)
X
XNormalProgramTarget(sofas,$(SOFAS),,$(SLOCAL_LIBS),)
X
XNormalProgramTarget(teapot,$(TEAPOT),,$(SLOCAL_LIBS),)
X
XNormalProgramTarget(plogo,$(PLOGO),,$(SLOCAL_LIBS),)
X
X#ifndef NO_MOTIF
X#ifdef MOTIF
X   CLIENTSRC = /usr/X/motif/clients/
XMSimpleUidTarget(pexdraw)
X#else
XXCOMM   you may need to try /usr/X/motif/clients/uil/uil
Xpexdraw.uid: pexdraw.uil
X	 uil -o pexdraw.uid pexdraw.uil
X#endif
X#endif
X
Xtar:
X	 tar cvf new.tar README pexdraw.c pexdraw.h pexdraw.uil Imakefile \
X	 rdr.c wks.c fb.c ui.c ui_x.c init.c \
X	  util/pexutdbint.h  util/pexutdbint.c  util/pexutdb.h  util/pexutdb.c \
X	  util/Imakefile util/pexutcmap.c util/pexutcmap.h \
X	  util/pexutext.h util/pexutcmapint.c util/pexutcmapint.h \
X	  util/pexutcmaphp.c util/pexutcmaphp.h \
X          rgbc.c plcube.c sofas.c teapot.c plogo.c XMU
X
XDependTarget()
END_OF_FILE
  if test 3809 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
  fi
  # end of 'Imakefile'
fi
if test -f 'XMU/CmapAlloc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'XMU/CmapAlloc.c'\"
else
  echo shar: Extracting \"'XMU/CmapAlloc.c'\" \(9405 characters\)
  sed "s/^X//" >'XMU/CmapAlloc.c' <<'END_OF_FILE'
X#ifdef SCCS
Xstatic char sccsid[]="@(#)CmapAlloc.c	1.3 Oki 92/11/30";
X#endif
X/*
X	This file is under sccs control at Oki in:
X	/nfs/sole/root/sccs1.p/X11R5/mit/lib/Xmu/s.CmapAlloc.c
X*/
X/*
X * $XConsortium: CmapAlloc.c,v 1.7 92/11/24 14:15:51 rws Exp $
X * 
X * Copyright 1989 by the Massachusetts Institute of Technology
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided 
X * that the above copyright notice appear in all copies and that both that 
X * copyright notice and this permission notice appear in supporting 
X * documentation, and that the name of M.I.T. not be used in advertising
X * or publicity pertaining to distribution of the software without specific, 
X * written prior permission. M.I.T. makes no representations about the 
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X *
X * M.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL M.I.T.
X * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
X * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
X * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X *
X * Author:  Donna Converse, MIT X Consortium
X */
X
X#include <X11/Xlib.h>
X#include <X11/Xatom.h>
X#include <X11/Xutil.h>
X#include <stdio.h>
X
X#define lowbit(x) ((x) & (~(x) + 1))
X
Xstatic int default_allocation();
Xstatic void best_allocation();
Xstatic void gray_allocation();
Xstatic int icbrt();
Xstatic int icbrt_with_bits();
Xstatic int icbrt_with_guess();
X
X/* To determine the best allocation of reds, greens, and blues in a 
X * standard colormap, use XmuGetColormapAllocation.
X * 	vinfo		specifies visual information for a chosen visual
X *	property	specifies one of the standard colormap property names
X * 	red_max		returns maximum red value 
X *      green_max	returns maximum green value
X * 	blue_max	returns maximum blue value
X *
X * XmuGetColormapAllocation returns 0 on failure, non-zero on success.
X * It is assumed that the visual is appropriate for the colormap property.
X */
X
XStatus XmuGetColormapAllocation(vinfo, property, red_max, green_max, blue_max)
X    XVisualInfo		*vinfo;
X    Atom		property;
X    unsigned long	*red_max, *green_max, *blue_max;
X{
X    Status 	status = 1;
X
X    if (vinfo->colormap_size <= 2)
X	return 0;
X
X    switch (property)
X    {
X      case XA_RGB_DEFAULT_MAP:
X	status = default_allocation(vinfo, red_max, green_max, blue_max);
X	break;
X      case XA_RGB_BEST_MAP:
X	best_allocation(vinfo, red_max, green_max, blue_max);
X	break;
X      case XA_RGB_GRAY_MAP:
X	gray_allocation(vinfo->colormap_size, red_max, green_max, blue_max);
X	break;
X      case XA_RGB_RED_MAP:
X	*red_max = vinfo->colormap_size - 1;
X	*green_max = *blue_max = 0;
X	break;
X      case XA_RGB_GREEN_MAP:
X	*green_max = vinfo->colormap_size - 1;
X	*red_max = *blue_max = 0;
X	break;
X      case XA_RGB_BLUE_MAP:
X	*blue_max = vinfo->colormap_size - 1;
X	*red_max = *green_max = 0;
X	break;
X      default:
X	status = 0;
X    }
X    return status;
X}
X
X/****************************************************************************/
X/* Determine the appropriate color allocations of a gray scale.
X *
X * Keith Packard, MIT X Consortium
X */
X
Xstatic void gray_allocation(n, red_max, green_max, blue_max)
X    int		n;	/* the number of cells of the gray scale */
X    unsigned long *red_max, *green_max, *blue_max;
X{
X    *red_max = (n * 30) / 100;
X    *green_max = (n * 59) / 100; 
X    *blue_max = (n * 11) / 100; 
X    *green_max += ((n - 1) - (*red_max + *green_max + *blue_max));
X}
X
X/****************************************************************************/
X/* Determine an appropriate color allocation for the RGB_DEFAULT_MAP.
X * If a map has less than a minimum number of definable entries, we do not
X * produce an allocation for an RGB_DEFAULT_MAP.  
X *
X * For 16 planes, the default colormap will have 27 each RGB; for 12 planes,
X * 12 each.  For 8 planes, let n = the number of colormap entries, which may
X * be 256 or 254.  Then, maximum red value = floor(cube_root(n - 125)) - 1.
X * Maximum green and maximum blue values are identical to maximum red.
X * This leaves at least 125 cells which clients can allocate.
X *
X * Return 0 if an allocation has been determined, non-zero otherwise.
X */
X
Xstatic int default_allocation(vinfo, red, green, blue)
X    XVisualInfo		*vinfo;
X    unsigned long	*red, *green, *blue;
X{
X    int			ngrays;		/* number of gray cells */
X
X    if (vinfo->colormap_size < 250)	/* skip it */
X	return 0;
X
X    switch (vinfo->class) {
X      case PseudoColor:
X
X	if (vinfo->colormap_size > 65000)
X	    /* intended for displays with 16 planes */
X	    *red = *green = *blue = (unsigned long) 27;
X	else if (vinfo->colormap_size > 4000)
X	    /* intended for displays with 12 planes */
X	    *red = *green = *blue = (unsigned long) 12;
X	else
X	    /* intended for displays with 8 planes */
X	    *red = *green = *blue = (unsigned long)
X		(icbrt(vinfo->colormap_size - 125) - 1);
X	break;
X
X      case DirectColor:
X
X	*red = *green = *blue = vinfo->colormap_size / 2 - 1;
X	break;
X
X      case TrueColor:
X
X	*red = vinfo->red_mask / lowbit(vinfo->red_mask);
X	*green = vinfo->green_mask / lowbit(vinfo->green_mask);
X	*blue = vinfo->blue_mask / lowbit(vinfo->blue_mask);
X	break;
X
X      case GrayScale:
X
X	if (vinfo->colormap_size > 65000)
X	    ngrays = 4096;
X	else if (vinfo->colormap_size > 4000)
X	    ngrays = 512;
X	else
X	    ngrays = 12;
X	gray_allocation(ngrays, red, green, blue);
X	break;
X	
X      default:
X	return 0;
X    }
X    return 1;
X}
X
X/****************************************************************************/
X/* Determine an appropriate color allocation for the RGB_BEST_MAP.
X *
X * For a DirectColor or TrueColor visual, the allocation is determined
X * by the red_mask, green_mask, and blue_mask members of the visual info.
X *
X * Otherwise, if the colormap size is an integral power of 2, determine
X * the allocation according to the number of bits given to each color,
X * with green getting more than red, and red more than blue, if there
X * are to be inequities in the distribution.  If the colormap size is
X * not an integral power of 2, let n = the number of colormap entries.
X * Then maximum red value = floor(cube_root(n)) - 1;
X * 	maximum blue value = floor(cube_root(n)) - 1;
X *	maximum green value = n / ((# red values) * (# blue values)) - 1;
X * Which, on a GPX, allows for 252 entries in the best map, out of 254
X * defineable colormap entries.
X */
X 
Xstatic void best_allocation(vinfo, red, green, blue)
X    XVisualInfo		*vinfo;
X    unsigned long	*red, *green, *blue;
X{
X
X    if (vinfo->class == DirectColor ||	vinfo->class == TrueColor)
X    {
X	*red = vinfo->red_mask;
X	while ((*red & 01) == 0)
X	    *red >>= 1;
X	*green = vinfo->green_mask;
X	while ((*green & 01) == 0)
X	    *green >>=1;
X	*blue = vinfo->blue_mask;
X	while ((*blue & 01) == 0)
X	    *blue >>= 1;
X    }
X    else
X    {
X	register int bits, n;
X	
X	/* Determine n such that n is the least integral power of 2 which is
X	 * greater than or equal to the number of entries in the colormap.
X         */
X	n = 1;
X	bits = 0;
X	while (vinfo->colormap_size > n)
X	{
X	    n = n << 1;
X	    bits++;
X	}
X	
X	/* If the number of entries in the colormap is a power of 2, determine
X	 * the allocation by "dealing" the bits, first to green, then red, then
X	 * blue.  If not, find the maximum integral red, green, and blue values
X	 * which, when multiplied together, do not exceed the number of 
X
X	 * colormap entries.
X	 */
X	if (n == vinfo->colormap_size)
X	{
X	    register int r, g, b;
X	    b = bits / 3;
X	    g = b + ((bits % 3) ? 1 : 0);
X	    r = b + (((bits % 3) == 2) ? 1 : 0);
X	    *red = 1 << r;
X	    *green = 1 << g;
X	    *blue = 1 << b;
X	}
X	else
X	{
X	    *red = icbrt_with_bits(vinfo->colormap_size, bits);
X	    *blue = *red;	
X	    *green = (vinfo->colormap_size / ((*red) * (*blue)));
X	}
X	(*red)--;
X	(*green)--;
X	(*blue)--;
X    }
X    return;
X}
X
X/*
X * integer cube roots by Newton's method
X *
X * Stephen Gildea, MIT X Consortium, July 1991
X */
X
Xstatic int icbrt(a)		/* integer cube root */
X    int a;
X{
X    register int bits = 0;
X    register unsigned n = a;
X
X    while (n)
X    {
X	bits++;
X	n >>= 1;
X    }
X    return icbrt_with_bits(a, bits);
X}
X
X
Xstatic int icbrt_with_bits(a, bits)
X    int a;
X    int bits;			/* log 2 of a */
X{
X    return icbrt_with_guess(a, a>>2*bits/3);
X}
X
X#ifdef _X_ROOT_STATS
Xint icbrt_loopcount;
X#endif
X
X/* Newton's Method:  x_n+1 = x_n - ( f(x_n) / f'(x_n) ) */
X
X/* for cube roots, x^3 - a = 0,  x_new = x - 1/3 (x - a/x^2) */
X
X/*
X * Quick and dirty cube roots.  Nothing fancy here, just Newton's method.
X * Only works for positive integers (since that's all we need).
X * We actually return floor(cbrt(a)) because that's what we need here, too.
X */
X
Xstatic int icbrt_with_guess(a, guess)
X    int a, guess;
X{
X    register int delta;
X
X#ifdef _X_ROOT_STATS
X    icbrt_loopcount = 0;
X#endif
X    if (a <= 0)
X	return 0;
X    if (guess < 1)
X	guess = 1;
X
X    do {
X#ifdef _X_ROOT_STATS
X	icbrt_loopcount++;
X#endif
X	delta = (guess - a/(guess*guess))/3;
X#ifdef DEBUG
X	printf("pass %d: guess=%d, delta=%d\n", icbrt_loopcount, guess, delta);
X#endif
X	guess -= delta;
X    } while (delta != 0);
X
X    if (guess*guess*guess > a)
X	guess--;
X
X    return guess;
X}
END_OF_FILE
  if test 9405 -ne `wc -c <'XMU/CmapAlloc.c'`; then
    echo shar: \"'XMU/CmapAlloc.c'\" unpacked with wrong size!
  fi
  # end of 'XMU/CmapAlloc.c'
fi
if test -f 'XMU/LookupCmap.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'XMU/LookupCmap.c'\"
else
  echo shar: Extracting \"'XMU/LookupCmap.c'\" \(10375 characters\)
  sed "s/^X//" >'XMU/LookupCmap.c' <<'END_OF_FILE'
X#ifdef SCCS
Xstatic char sccsid[]="@(#)LookupCmap.c	1.3 Oki 92/11/30";
X#endif
X/*
X	This file is under sccs control at Oki in:
X	/nfs/sole/root/sccs1.p/X11R5/mit/lib/Xmu/s.LookupCmap.c
X*/
X/* $XConsortium: LookupCmap.c,v 1.8 92/11/23 15:43:44 rws Exp $ 
X * 
X * Copyright 1989 by the Massachusetts Institute of Technology
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided 
X * that the above copyright notice appear in all copies and that both that 
X * copyright notice and this permission notice appear in supporting 
X * documentation, and that the name of M.I.T. not be used in advertising
X * or publicity pertaining to distribution of the software without specific, 
X * written prior permission. M.I.T. makes no representations about the 
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X *
X * M.I.T. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
X * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL M.I.T.
X * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
X * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
X * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
X * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X *
X * Author:  Donna Converse, MIT X Consortium
X */
X
X#include <stdio.h>
X#include <X11/Xlib.h>
X#include <X11/Xatom.h>
X#include <X11/Xutil.h>
X#include <X11/Xmu/StdCmap.h>
X
Xextern char *malloc();
Xstatic Status lookup();
X
X/*
X * To create a standard colormap if one does not currently exist, or
X * replace the currently existing standard colormap, use 
X * XmuLookupStandardColormap().
X *
X * Given a screen, a visual, and a property, XmuLookupStandardColormap()
X * will determine the best allocation for the property under the specified
X * visual, and determine the whether to create a new colormap or to use
X * the default colormap of the screen.  It will call XmuStandardColormap()
X * to create the standard colormap.
X *
X * If replace is true, any previous definition of the property will be 
X * replaced.  If retain is true, the property and the colormap will be
X * made permanent for the duration of the server session.  However,
X * pre-existing property definitions which are not replaced cannot be made
X * permanent by a call to XmuLookupStandardColormap(); a request to retain 
X * resources pertains to newly created resources.
X *
X * Returns 0 on failure, non-zero on success.  A request to create a 
X * standard colormap upon a visual which cannot support such a map is
X * considered a failure.  An example of this would be requesting any
X * standard colormap property on a monochrome visual, or, requesting an
X * RGB_BEST_MAP on a display whose colormap size is 16.
X */
X
XStatus XmuLookupStandardColormap(dpy, screen, visualid, depth, property,
X				 replace, retain)
X    Display		*dpy;		/* specifies X server connection */
X    int			screen; 	/* specifies screen of display */
X    VisualID		visualid;	/* specifies the visual type */
X    unsigned int	depth;		/* specifies  the visual type */
X    Atom		property;	/* a standard colormap property */
X    Bool		replace;	/* specifies whether to replace */
X    Bool		retain;		/* specifies whether to retain */
X{
X    Display		*odpy;		/* original display connection */
X    XStandardColormap	*colormap;	
X    XVisualInfo		vinfo_template, *vinfo;	/* visual */
X    long		vinfo_mask;
X    unsigned long	r_max, g_max, b_max;	/* allocation */
X    int			count;	
X    Colormap		cmap;			/* colormap ID */
X    Status		status = 0;
X
X
X    /* Match the requested visual */
X
X    vinfo_template.visualid = visualid;	
X    vinfo_template.screen = screen;
X    vinfo_template.depth = depth;
X    vinfo_mask = VisualIDMask | VisualScreenMask | VisualDepthMask;
X    if ((vinfo = XGetVisualInfo(dpy, vinfo_mask, &vinfo_template, &count)) ==
X	NULL)
X	return 0;
X
X    /* Monochrome visuals have no standard maps */
X
X    if (vinfo->colormap_size <= 2) {
X	XFree((char *) vinfo);
X	return 0;	
X    }
X
X    /* If the requested property already exists on this screen, and, 
X     * if the replace flag has not been set to true, return success.
X     * lookup() will remove a pre-existing map if replace is true.
X     */
X
X    if (lookup(dpy, screen, visualid, property, (XStandardColormap *) NULL,
X	       replace) && !replace) {
X	XFree((char *) vinfo);
X	return 1;
X    }
X
X    /* Determine the best allocation for this property under the requested
X     * visualid and depth, and determine whether or not to use the default
X     * colormap of the screen.
X     */
X
X    if (!XmuGetColormapAllocation(vinfo, property, &r_max, &g_max, &b_max)) {
X	XFree((char *) vinfo);
X	return 0;
X    }
X
X    cmap = (property == XA_RGB_DEFAULT_MAP &&
X	    visualid == XVisualIDFromVisual(DefaultVisual(dpy, screen)))
X	? DefaultColormap(dpy, screen) : None;
X
X    /* If retaining resources, open a new connection to the same server */
X
X    if (retain) {
X	odpy = dpy;
X	if ((dpy = XOpenDisplay(XDisplayString(odpy))) == NULL) {
X	    XFree((char *) vinfo);
X	    return 0;
X	}
X    }
X
X    /* Create the standard colormap */
X
X    colormap = XmuStandardColormap(dpy, screen, visualid, depth, property,
X				   cmap, r_max, g_max, b_max);
X
X    /* Set the standard colormap property */
X
X    if (colormap) {
X	XGrabServer(dpy);
X
X	if (lookup(dpy, screen, visualid, property, colormap, replace) &&
X	    !replace) {
X	    /* Someone has defined the property since we last looked.
X	     * Since we will not replace it, release our own resources.
X	     * If this is the default map, our allocations will be freed 
X	     * when this connection closes.
X	     */
X	    if (colormap->killid == ReleaseByFreeingColormap)
X		XFreeColormap(dpy, colormap->colormap);
X	}
X	else if (retain) {
X		XSetCloseDownMode(dpy, RetainPermanent);
X	}
X	XUngrabServer(dpy);
X	XFree((char *) colormap);
X	status = 1;
X    }
X
X    if (retain)
X	XCloseDisplay(dpy);
X    XFree((char *) vinfo);
X    return status;
X}
X
X/***************************************************************************/
X
X/* Lookup a standard colormap property.  If the property is RGB_DEFAULT_MAP,
X * the visualid is used to determine whether the indicated standard colormap
X * exists.  If the map exists and replace is true, delete the resources used
X * by the map and remove the property.  Return true if the map exists,
X * or did exist and was deleted; return false if the map was not found.
X *
X * Note that this is not the way that a Status return is normally used.
X *
X * If new is not NULL, new points to an XStandardColormap structure which
X * describes a standard colormap of the specified property.  It will be made
X * a standard colormap of the screen if none already exists, or if replace 
X * is true.
X */
X
Xstatic Status lookup(dpy, screen, visualid, property, new, replace)
X    Display		*dpy;		/* specifies display connection */
X    int			screen;		/* specifies screen number */
X    VisualID		visualid;	/* specifies visualid for std map */
X    Atom		property;	/* specifies colormap property name */
X    XStandardColormap	*new;		/* specifies a standard colormap */
X    Bool		replace;	/* specifies whether to replace */
X{
X    register int	i;
X    int			count;
X    XStandardColormap	*stdcmaps, *s;
X    Window		win = RootWindow(dpy, screen);
X
X    /* The property does not already exist */
X
X    if (! XGetRGBColormaps(dpy, win, &stdcmaps, &count, property)) {
X	if (new)
X	    XSetRGBColormaps(dpy, win, new, 1, property);
X	return 0;
X    }
X
X    /* The property exists and is not describing the RGB_DEFAULT_MAP */
X
X    if (property != XA_RGB_DEFAULT_MAP) {
X	if (replace) {
X	    XmuDeleteStandardColormap(dpy, screen, property);
X	    if (new)
X		XSetRGBColormaps(dpy, win, new, 1, property);
X	}
X	XFree((char *)stdcmaps);
X	return 1;
X    }
X
X    /* The property exists and is RGB_DEFAULT_MAP */
X    
X    for (i=0, s=stdcmaps; (i < count) && (s->visualid != visualid); i++, s++)
X	;
X
X    /* No RGB_DEFAULT_MAP property matches the given visualid */
X
X    if (i == count) {
X	if (new) {
X	    XStandardColormap	*m, *maps;
X
X	    s = (XStandardColormap *) malloc((unsigned) ((count+1) * sizeof
X					      (XStandardColormap)));
X
X	    for (i = 0, m = s, maps = stdcmaps; i < count; i++, m++, maps++) {
X		m->colormap   = maps->colormap;
X		m->red_max    = maps->red_max;
X		m->red_mult   = maps->red_mult;
X		m->green_max  = maps->green_max;
X		m->green_mult = maps->green_mult;
X		m->blue_max   = maps->blue_max;
X		m->blue_mult  = maps->blue_mult;
X		m->visualid   = maps->visualid;
X		m->killid     = maps->killid;
X	    }
X	    m->colormap   = new->colormap;
X	    m->red_max    = new->red_max;
X	    m->red_mult   = new->red_mult;
X	    m->green_max  = new->green_max;
X	    m->green_mult = new->green_mult;
X	    m->blue_max   = new->blue_max;
X	    m->blue_mult  = new->blue_mult;
X	    m->visualid   = new->visualid;
X	    m->killid     = new->killid;
X
X	    XSetRGBColormaps(dpy, win, s, ++count, property);
X	    free((char *) s);
X	}
X	XFree((char *) stdcmaps);
X	return 0;
X    }
X
X    /* Found an RGB_DEFAULT_MAP property with a matching visualid */
X
X    if (replace) {
X	/* Free old resources first - we may need them, particularly in 
X	 * the default colormap of the screen.  However, because of this,
X	 * it is possible that we will destroy the old resource and fail 
X	 * to create a new one if XmuStandardColormap() fails.
X	 */
X
X	if (count == 1) {
X	    XmuDeleteStandardColormap(dpy, screen, property);
X	    if (new)
X		XSetRGBColormaps(dpy, win, new, 1, property);
X	}
X	else {
X	    XStandardColormap	*map;
X
X	    /* s still points to the matching standard colormap */
X
X	    if (s->killid == ReleaseByFreeingColormap) {
X		if ((s->colormap != None) &&
X		    (s->colormap != DefaultColormap(dpy, screen)))
X		    XFreeColormap(dpy, s->colormap);
X	    }
X	    else if (s->killid != None)
X		XKillClient(dpy, s->killid);
X
X	    map = (new) ? new : stdcmaps + --count;
X
X	    s->colormap   = map->colormap;
X	    s->red_max    = map->red_max;
X	    s->red_mult   = map->red_mult;
X	    s->green_max  = map->green_max;
X	    s->green_mult = map->green_mult;
X	    s->blue_max   = map->blue_max;
X	    s->blue_mult  = map->blue_mult;
X	    s->visualid   = map->visualid;
X	    s->killid     = map->killid;
X
X	    XSetRGBColormaps(dpy, win, stdcmaps, count, property);
X	}
X    }
X    XFree((char *) stdcmaps);
X    return 1;
X}
END_OF_FILE
  if test 10375 -ne `wc -c <'XMU/LookupCmap.c'`; then
    echo shar: \"'XMU/LookupCmap.c'\" unpacked with wrong size!
  fi
  # end of 'XMU/LookupCmap.c'
fi
if test -f 'rgbc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rgbc.c'\"
else
  echo shar: Extracting \"'rgbc.c'\" \(4510 characters\)
  sed "s/^X//" >'rgbc.c' <<'END_OF_FILE'
X/*
X * rgbc.c - RGB Cube
X cc -o rgbc rgbc.c -lPEX5 -lm -lX11                    -lnsl
X
X			Copyright (c) 1993 by 
X			Oki Electric Industry Co., Ltd.
X			All Rights Reserved
X	
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted,
X * provided that the above copyright notice appear in all copies and that
X * both that copyright notice and this permission notice appear in
X * supporting documentation, and that the name of Oki not be
X * used in advertising or publicity pertaining to distribution of the
X * software without specific, written prior permission. Oki
X * makes no representations about the suitability of this software for any
X * purpose.  It is provided "as is" without express or implied warranty.
X*/
X#include <X11/Xlib.h>
X#include <X11/PEX5/PEXlib.h>
X
X#define SET_POINT(p,a,b,c) {(p)->x=(a);(p)->y=(b);(p)->z=(c);}
X#define SET_RGB(p,a,b,c) {(p)->red=(a);(p)->green=(b);(p)->blue=(c);}
X
X#define RADICAL3 1.732
X#define RAD3INV  (1.0/RADICAL3)
X
Xmain (argc, argv)
X     int argc;
X     char  *argv[];
X{
X  Display		*theDisplay;
X  char			*displayString = (char *)0;
X  PEXExtensionInfo	*info_return;
X  char			err_msg[PEXErrorStringLength];
X  XID                   theStrux;  
X  int                   i;
X  PEXCoord p[2];
X
X  for ( i = 1; i<argc; i++ ) {
X    if ((strncmp(argv[i],"-display",strlen(argv[i]))) == 0) {
X      if (++i > argc) { printf("not enough args"); exit(1); }
X      displayString = argv[i];
X    } else if ((strncmp(argv[i],"-strux",strlen(argv[i]))) == 0) {
X      if (++i > argc) { printf("not enough args"); exit(1); }
X      theStrux = atoi(argv[i]);
X    }
X  }
X
X  /*
X   * Open the display and initialize the PEX extension.
X   */
X  
X  if (!(theDisplay = XOpenDisplay(displayString)))
X    {
X      printf ( "Could not open display %s\n",displayString);
X      exit (1);
X    }
X  
X  if (PEXInitialize(theDisplay, &info_return, PEXErrorStringLength, err_msg))
X    {
X      printf ("%s\n", err_msg);
X      exit (1);	    
X    }
X
X  PEXSetLineColorIndex( theDisplay, theStrux, PEXOCStore, 2);
X  p[0].x = 0; p[0].y = 0; p[0].z = 0;
X  p[1].x = -1; p[1].y = -1; p[1].z = -1;
X  PEXPolyline(theDisplay, theStrux, PEXOCStore, 2, p );
X
X  PEXSetSurfaceColorIndex( theDisplay, theStrux, PEXOCStore, 7 );
X
X  {
X    PEXVertexRGB             coords[8];
X    PEXArrayOfVertex         varr;
X    PEXConnectivityData      c10y[6];
X    PEXListOfUShort          clist[6];
X    unsigned short           indices[24];
X    
X    PEXArrayOfFacetData      aFacetData;
X    
X    
X    SET_POINT(&coords[0].point, 0,0,0); SET_RGB(&coords[0].rgb, 0,0,0);
X    SET_POINT(&coords[1].point, 1,0,0); SET_RGB(&coords[1].rgb, 1,0,0);
X    SET_POINT(&coords[2].point, 0,1,0); SET_RGB(&coords[2].rgb, 0,1,0);
X    SET_POINT(&coords[3].point, 0,0,1); SET_RGB(&coords[3].rgb, 0,0,1);
X    SET_POINT(&coords[4].point, 1,1,0); SET_RGB(&coords[4].rgb, 1,1,0);
X    SET_POINT(&coords[5].point, 1,0,1); SET_RGB(&coords[5].rgb, 1,0,1);
X    SET_POINT(&coords[6].point, 0,1,1); SET_RGB(&coords[6].rgb, 0,1,1);
X    SET_POINT(&coords[7].point, 1,1,1); SET_RGB(&coords[7].rgb, 1,1,1);
X
X    
X    indices[0] = 0; indices[1] = 1; indices[2] = 4; indices[3] = 2;
X    indices[4] = 0; indices[5] = 2; indices[6] = 6; indices[7] = 3;
X    indices[8] = 0; indices[9] = 3; indices[10] = 5; indices[11] = 1;
X    indices[12] = 7; indices[13] = 6; indices[14] = 2; indices[15] = 4;
X    indices[16] = 7; indices[17] = 4; indices[18] = 1; indices[19] = 5;
X    indices[20] = 7; indices[21] = 5; indices[22] = 3; indices[23] = 6;
X    
X    clist[0].count = 4;
X    clist[0].shorts = &indices[0];
X    clist[1].count = 4;
X    clist[1].shorts = &indices[4];
X    clist[2].count = 4;
X    clist[2].shorts = &indices[8];
X    clist[3].count = 4;
X    clist[3].shorts = &indices[12];
X    clist[4].count = 4;
X    clist[4].shorts = &indices[16];
X    clist[5].count = 4;
X    clist[5].shorts = &indices[20];
X    
X    c10y[0].count = 1;
X    c10y[0].lists = &clist[0];
X    c10y[1].count = 1;
X    c10y[1].lists = &clist[1];
X    c10y[2].count = 1;
X    c10y[2].lists = &clist[2];
X    c10y[3].count = 1;
X    c10y[3].lists = &clist[3];
X    c10y[4].count = 1;
X    c10y[4].lists = &clist[4];
X    c10y[5].count = 1;
X    c10y[5].lists = &clist[5];
X    
X    varr.rgb = coords;
X    PEXSetOfFillAreaSets( theDisplay, theStrux, PEXOCStore,
X			 PEXShapeUnknown, PEXGANone, PEXGAColor, 
X			 PEXGANone, PEXContourUnknown, 1, PEXColorTypeRGB,
X			 6, aFacetData, 8, varr, 24, (PEXSwitch *)0, c10y );
X  }
X
X  XSync(theDisplay,0);
X}
END_OF_FILE
  if test 4510 -ne `wc -c <'rgbc.c'`; then
    echo shar: \"'rgbc.c'\" unpacked with wrong size!
  fi
  # end of 'rgbc.c'
fi
if test -f 'util/pexutcmaphp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/pexutcmaphp.h'\"
else
  echo shar: Extracting \"'util/pexutcmaphp.h'\" \(3626 characters\)
  sed "s/^X//" >'util/pexutcmaphp.h' <<'END_OF_FILE'
X#ifndef PEXUTCMAP_HP_IH /* { */
X#define PEXUTCMAP_HP_IH
X
X/******************************************************************************/
X/*                                                                            */
X/*  (c) Copyright Hewlett-Packard Company, 1992, Fort Collins, Colorado       */
X/*                                                                            */
X/*                            All Rights Reserved                             */
X/*                                                                            */
X/*  Permission to use, copy, modify, and distribute this software and its     */
X/*  documentation for any purpose and without fee is hereby granted,          */
X/*  provided that the above copyright notices appear in all copies and that   */
X/*  both the copyright notices and this permission notice appear in           */
X/*  supporting documentation, and that the name of Hewlett-Packard not be     */
X/*  used in advertising or publicity pertaining to distribution of the        */
X/*  software without specific, written prior permission.                      */
X/*                                                                            */
X/*  HEWLETT-PACKARD MAKES NO WARRANTY OF ANY KIND WITH REGARD TO THIS         */
X/*  SOFTWARE, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF        */
X/*  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  Hewlett-Packard    */
X/*  shall not be liable for errors contained herein or direct, indirect,      */
X/*  special, incidental or consequential damages in connection with the       */
X/*  furnishing, performance or use of this software.                          */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/* $Source: /BE700/9.0/gtd/R903/wbuild/PEX5/head/RCS/pexutcmaphp.h,v $                      	      */
X/* $Date: 93/03/17 14:14:27 $                                                 */
X/* $Revision: 500.1.200.1 $                                                   */
X/*                                                                            */
X/* Description:                                                               */
X/*   Internal header file of Hewlett-Packard-specific functionality           */
X/*   for PEXUt colormap/visual utilities, not to be included by applications. */
X/*                                                                            */
X/* Notes:                                                                     */
X/*                                                                            */
X/******************************************************************************/
X
X
X#ifndef NeedFunctionPrototypes
X#if defined(FUNCPROTO) || defined(__STDC__) || \
X    defined(__cplusplus) || defined(c_plusplus)
X#define NeedFunctionPrototypes  1
X#else
X#define NeedFunctionPrototypes  0
X#endif /* FUNCPROTO, __STDC__, __cplusplus, c_plusplus */
X#endif /* NeedFunctionPrototypes */
X
X
X#ifdef __cplusplus   /* do not leave open across includes */
Xextern "C" {         /* for C++ V2.0 */
X#endif
X
Xextern
Xint pexut_modify_colormap_for_HP_dependencies (
X#if NeedFunctionPrototypes
X		Display				*display,
X		Colormap			colormap_id,
X		XVisualInfo			*vis_info,
X		PEXColorApproxEntry		*capx_info
X#endif
X		);
X
X#ifdef __cplusplus
X}                    /* for C++ V2.0 */
X#endif
X
X#endif /* } PEXUTCMAP_HP_IH */
END_OF_FILE
  if test 3626 -ne `wc -c <'util/pexutcmaphp.h'`; then
    echo shar: \"'util/pexutcmaphp.h'\" unpacked with wrong size!
  fi
  # end of 'util/pexutcmaphp.h'
fi
if test -f 'util/pexutcmapint.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/pexutcmapint.h'\"
else
  echo shar: Extracting \"'util/pexutcmapint.h'\" \(10605 characters\)
  sed "s/^X//" >'util/pexutcmapint.h' <<'END_OF_FILE'
X#ifndef PEXUTCMAP_IH /* { */
X#define PEXUTCMAP_IH
X
X/******************************************************************************/
X/*                                                                            */
X/*  (c) Copyright Hewlett-Packard Company, 1992, Fort Collins, Colorado       */
X/*                                                                            */
X/*                            All Rights Reserved                             */
X/*                                                                            */
X/*  Permission to use, copy, modify, and distribute this software and its     */
X/*  documentation for any purpose and without fee is hereby granted,          */
X/*  provided that the above copyright notices appear in all copies and that   */
X/*  both the copyright notices and this permission notice appear in           */
X/*  supporting documentation, and that the name of Hewlett-Packard not be     */
X/*  used in advertising or publicity pertaining to distribution of the        */
X/*  software without specific, written prior permission.                      */
X/*                                                                            */
X/*  HEWLETT-PACKARD MAKES NO WARRANTY OF ANY KIND WITH REGARD TO THIS         */
X/*  SOFTWARE, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF        */
X/*  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  Hewlett-Packard    */
X/*  shall not be liable for errors contained herein or direct, indirect,      */
X/*  special, incidental or consequential damages in connection with the       */
X/*  furnishing, performance or use of this software.                          */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/* $Source: /users/waitz/work/tmp/RCS/pexutcmapint.h,v $                      	      */
X/* $Date: 93/03/02 16:39:31 $                                                 */
X/* $Revision: 1.1 $                                                   */
X/*                                                                            */
X/* Description:                                                               */
X/*   Internal header file for PEXUt cmap/visual utilities,                    */
X/*   not to be included by application programs.                              */
X/*                                                                            */
X/* Notes:                                                                     */
X/*                                                                            */
X/******************************************************************************/
X
X
X#ifndef NeedFunctionPrototypes
X#if defined(FUNCPROTO) || defined(__STDC__) || \
X    defined(__cplusplus) || defined(c_plusplus)
X#define NeedFunctionPrototypes  1
X#else
X#define NeedFunctionPrototypes  0
X#endif /* FUNCPROTO, __STDC__, __cplusplus, c_plusplus */
X#endif /* NeedFunctionPrototypes */
X
X
X#ifdef __cplusplus   /* do not leave open across includes */
Xextern "C" {         /* for C++ V2.0 */
X#endif
X
X
X/*
X    This structure type is used to describe standard colormap properties
X    that should searched as part of an interoperability convention.
X    The ordering of entries in an array of these structures is the search
X    order of the properties.
X
X    The fields are used as follows:
X
X	is_standard		True if the colormap property is a current
X				standard, i.e. supported by XGetRGBColormaps.
X				False otherwise.
X
X	have_atom		True if the Atom in the property_atom field
X				is valid, False if only the property_name
X				string is valid.
X
X	property_atom		Atom value for the property name, which may
X				be predefined or may have been fetched by
X				an earlier call to XInternAtom.
X
X	property_name		the property name as a NULL-terminated
X				character string.
X*/
X	
Xtypedef struct {
X	int	is_standard;
X	int	have_atom;
X	Atom	property_atom;
X	char	*property_name;
X} interop_property_type;
X
X
X/*
X    This structure type is the entry type for the SERVER_OVERLAY_VISUALS
X    property.  The property contains an entry for each Visual on the screen
X    of the root window where it is attached.
X    
X    The fields are used as follows:
X
X	visualid		identifier of the Visual.
X
X	transparent_type	specifies the mechanism that controls
X				transparency in the Visual: one of None,
X				TransparentPixel, or TransparentMask.
X
X	value			pixel value that is transparent, if
X				the transparent_type is TransparentPixel.
X
X	layer			specifies the layer of the Visual.  Image
X				layer is 0, overlay layer is 1.
X*/
X	
Xtypedef struct {
X	VisualID	visualid;
X	int		transparent_type;
X	int		value;
X	int		layer;
X} overlay_visuals_type;
X
X
X
X/*
X    This structure type is used internally by the PEXUt code to record
X    information about each Visual that is considered.  The central
X    creator and user of the structure type is PEXUtFindVisual; it passes
X    pointers to this structure type to several subsidiary routines.
X    
X    The fields are used as follows:
X
X	unmet_hard_criteria	a mask of the hard criteria that are not
X				met by the Visual; if this is mask is non-zero,
X				the Visual is not a candidate for selection.
X
X	unmet_soft_criteria	a mask of the soft criteria that are not
X				met by the Visual; this mask is used in
X				choosing among several Visuals that are
X				candidates.
X
X	property_ptr		a pointer to the entry for the Visual in the 
X				first standard colormap property (in priority)
X				that contains an entry for the Visual; if 
X				properties were not searched then this pointer
X				is NULL.
X
X	property_atom		the atom for the property whose entry is
X				addressed by property_ptr.
X
X	visual_ptr		a pointer to the description of the Visual.
X
X	order_rating,		independent integers that represent the
X	soft_rating,		relative rank of the Visual in the respective
X	color_rating		category:  order of appearance in a target
X				list or colormap property; number of soft
X				criteria that the Visual meets; level of
X				color resolution.  These fields are combined
X				to form an overall rating in order to choose
X				among several candidate Visuals.
X*/
X
Xtypedef struct {
X	unsigned int		unmet_hard_criteria;
X	unsigned int		unmet_soft_criteria;
X	XStandardColormap	*property_ptr;
X	Atom			property_atom;
X	XVisualInfo		*visual_ptr;
X	unsigned int		order_rating;
X	unsigned int		soft_rating;
X	unsigned int		color_rating;
X	unsigned int		class_rating;
X} visual_info_type;
X
X
X/*
X    MAX_ORDER_RATING is the maximum value of the order rating, i.e. the rating 
X    for each candidate visual that is based on its relative order in a
X    target list or standard colormap property.  The value range should
X    map to a range compatible with the ORDER_SHIFT,
X    such that the range and the shift do not exceed 32 bits when combined.
X
X    Similarly, MAX_SOFT_RATING is the maximum value for the rating based
X    on how well a Visual meets the soft criteria.  It must be compatible
X    with SOFT_SHIFT.  And so on for the other factors used in rating Visuals.
X*/
X
X#define MAX_CLASS_RATING  0x1
X#define CLASS_SHIFT       0
X#define MAX_COLOR_RATING  0xFFFF
X#define COLOR_SHIFT       1
X#define MAX_ORDER_RATING  0x1FF
X#define ORDER_SHIFT       17
X#define MAX_SOFT_RATING   0x1FF
X#define SOFT_SHIFT        22
X
X
X/*
X    No specifications are provided for these internal utilities.
X    For the most part, their names describe their functionality.
X*/
X
Xextern
Xint pexut_get_standard_cmap_property (
X#if NeedFunctionPrototypes
X		Display				*display,
X		int				screen,
X		interop_property_type		*property_info,
X		Atom				*property_atom_return,
X		int				*property_count_return,
X		XStandardColormap		**property_data_return
X#endif
X		);
X		
Xextern
Xint pexut_get_overlay_visuals_property (
X#if NeedFunctionPrototypes
X		Display				*display,
X		int				screen,
X		int				*property_count_return,
X		overlay_visuals_type		**property_data_return
X#endif
X		);
X		
Xextern
Xint pexut_evaluate_color_criteria (
X#if NeedFunctionPrototypes
X		Display				*display,
X		PEXUtVisualCriteria		*criteria,
X		XVisualInfo			*vis_info,
X		visual_info_type		*p_info
X#endif
X		);
X
Xextern
Xint pexut_evaluate_double_buffering_capability (
X#if NeedFunctionPrototypes
X		Display				*display,
X		PEXUtVisualCriteria		*criteria,
X		XVisualInfo			*vis_info,
X		visual_info_type		*p_info
X#endif
X		);
X
Xextern
Xint pexut_evaluate_color_approx_type (
X#if NeedFunctionPrototypes
X		Display				*display,
X		PEXUtVisualCriteria		*criteria,
X		XVisualInfo			*vis_info,
X		visual_info_type		*p_info
X#endif
X		);
X
Xextern
Xunsigned int pexut_compute_overall_rating (
X#if NeedFunctionPrototypes
X		visual_info_type		*p_info
X#endif
X		);
X
Xextern
Xint pexut_create_temporary_window (
X#if NeedFunctionPrototypes
X		Display				*display,
X		XVisualInfo			*vis_info,
X		Window				*window_return
X#endif
X		);
X
Xextern
Xint pexut_destroy_temporary_window (
X#if NeedFunctionPrototypes
X		Display				*display,
X		XVisualInfo			*vis_info,
X		Window				window
X#endif
X		);
X
Xextern
Xint pexut_verify_color_approx_type (
X#if NeedFunctionPrototypes
X		Display				*display,
X		Window				window,
X		PEXEnumTypeIndex		color_approx_type
X#endif
X		);
X
Xextern
Xint pexut_synthesize_cmap_from_visual (
X#if NeedFunctionPrototypes
X		XVisualInfo			*vis_info,
X		XStandardColormap		*cmap_info_return
X#endif
X		);
X
Xextern
Xint pexut_load_color_approx_from_std_cmap (
X#if NeedFunctionPrototypes
X		int				color_approx_type,
X		XVisualInfo			*vis_info,
X		XStandardColormap		*cmap_info,
X		PEXColorApproxEntry		*capx_info_return
X#endif
X		);
X
Xextern
Xint pexut_match_color_approx_entry (
X#if NeedFunctionPrototypes
X		PEXColorApproxEntry		*entry1, 
X		PEXColorApproxEntry		*entry2
X#endif
X		);
X
Xextern
Xint pexut_create_one_channel_map (
X#if NeedFunctionPrototypes
X		Display				*display,
X		XVisualInfo			*vis_info,
X		PEXColorApproxEntry		*capx_info,
X		Colormap			*colormap_id_return
X#endif
X		);
X
Xextern
Xint pexut_create_three_channel_map (
X#if NeedFunctionPrototypes
X		Display				*display,
X		XVisualInfo			*vis_info,
X		PEXColorApproxEntry		*capx_info,
X		Colormap			*colormap_id_return
X#endif
X		);
X
Xextern
Xint pexut_create_read_only_map (
X#if NeedFunctionPrototypes
X		Display				*display,
X		XVisualInfo			*vis_info,
X		PEXColorApproxEntry		*capx_info,
X		Colormap			*colormap_id_return
X#endif
X		);
X
Xextern
Xint pexut_count_bits_in_mask (
X#if NeedFunctionPrototypes
X		unsigned int mask
X#endif
X		);
X
X#ifdef __cplusplus
X}                    /* for C++ V2.0 */
X#endif
X
X#endif /* } PEXUTCMAP_IH */
END_OF_FILE
  if test 10605 -ne `wc -c <'util/pexutcmapint.h'`; then
    echo shar: \"'util/pexutcmapint.h'\" unpacked with wrong size!
  fi
  # end of 'util/pexutcmapint.h'
fi
echo shar: End of archive 14 \(of 14\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo "concatentating pexdraw.c ..."
    cat pexdrawc.? > pexdraw.c
    rm pexdrawc.?
    echo "concatentating pexdraw.uil ..."
    cat pexdrawu.? > pexdraw.uil
    rm pexdrawu.?
    echo "concatentating teapot.c ..."
    rm teapotc.?
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM       | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@imd.sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
