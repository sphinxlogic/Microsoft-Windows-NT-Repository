Newsgroups: comp.sources.x
From: jch@okimicro.oki.com (Jan Hardenbergh)
Subject: v20i021:  pexdraw - A PEX drawing program, Part11/14
Message-ID: <1993Jun8.150229.19322@sparky.imd.sterling.com>
X-Md4-Signature: 17d0d25a089e4d41ec4db8bffdc2b7b0
Sender: chris@sparky.imd.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Tue, 8 Jun 1993 15:02:29 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: jch@okimicro.oki.com (Jan Hardenbergh)
Posting-number: Volume 20, Issue 21
Archive-name: pexdraw/part11
Environment: X11R5, PEX

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  pexdrawu.2 rdr.c util/pexutext.h
# Wrapped by chris@sparky on Tue Jun  8 09:46:34 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 11 (of 14)."'
if test -f 'pexdrawu.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pexdrawu.2'\"
else
  echo shar: Extracting \"'pexdrawu.2'\" \(28751 characters\)
  sed "s/^X//" >'pexdrawu.2' <<'END_OF_FILE'
X            XmNlabelString = "View Reference Point";
X            };
X        };
X
Xobject
X    view_ref_pt_x : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_FORM;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmLabel view_ref_pt_label;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "0";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_ref_pt_x);
X            };
X        };
X
Xobject
X    view_ref_pt_y : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_FORM;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField view_ref_pt_x;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "0";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_ref_pt_y);
X            };
X        };
X
Xobject
X    view_ref_pt_z : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_FORM;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField view_ref_pt_y;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "0";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_ref_pt_z);
X            };
X        };
X
X!****************************** View Plane Normal  ********************
X
Xobject
X    view_pl_norm_sep : XmSeparator {
X	arguments {
X	    XmNleftAttachment =  XmATTACH_FORM;
X	    XmNrightAttachment =  XmATTACH_FORM;
X	    XmNtopAttachment = XmATTACH_WIDGET;
X	    XmNtopWidget = XmTextField view_ref_pt_y;
X	};
X    };
X
X
Xobject
X    view_pl_norm_label : XmLabel {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_pl_norm_sep;
X	    XmNleftAttachment = XmATTACH_FORM ;
X            XmNlabelString = "View Plane Normal";
X            };
X        };
X
Xobject
X    view_pl_norm_x : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_pl_norm_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmLabel view_pl_norm_label;
X            XmNwidth = 80;
X            XmNmaxLength = 8;
X            XmNvalue = "0";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_pl_norm_x);
X            };
X        };
X
Xobject
X    view_pl_norm_y : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_pl_norm_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField view_pl_norm_x;
X            XmNwidth = 80;
X            XmNmaxLength = 8;
X            XmNvalue = "0";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_pl_norm_y);
X            };
X        };
X
Xobject
X    view_pl_norm_z : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_pl_norm_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField view_pl_norm_y;
X            XmNwidth = 80;
X            XmNmaxLength = 8;
X            XmNvalue = "1";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_pl_norm_z);
X            };
X        };
X
X!****************************** View Up Vector  ********************
X
Xobject
X    view_up_vect_sep : XmSeparator {
X	arguments {
X	    XmNleftAttachment =  XmATTACH_FORM;
X	    XmNrightAttachment =  XmATTACH_FORM;
X	    XmNtopAttachment = XmATTACH_WIDGET;
X	    XmNtopWidget = XmTextField view_pl_norm_y;
X	};
X    };
X
X
Xobject
X    view_up_vect_label : XmLabel {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_up_vect_sep;
X	    XmNleftAttachment = XmATTACH_FORM ;
X            XmNlabelString = "View Up Vector";
X            };
X        };
X
Xobject
X    view_up_vect_x : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_up_vect_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmLabel view_up_vect_label;
X            XmNwidth = 80;
X            XmNmaxLength = 8;
X            XmNvalue = "0";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_up_vect_x);
X            };
X        };
X
Xobject
X    view_up_vect_y : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_up_vect_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField view_up_vect_x;
X            XmNwidth = 80;
X            XmNmaxLength = 8;
X            XmNvalue = "1";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_up_vect_y);
X            };
X        };
X
Xobject
X    view_up_vect_z : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_up_vect_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField view_up_vect_y;
X            XmNwidth = 80;
X            XmNmaxLength = 8;
X            XmNvalue = "0";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_up_vect_z);
X            };
X        };
X
X!****************************** Projection Reference Point *******************
X
Xobject
X    proj_ref_pt_sep : XmSeparator {
X	arguments {
X	    XmNleftAttachment =  XmATTACH_FORM;
X	    XmNrightAttachment =  XmATTACH_FORM;
X	    XmNtopAttachment = XmATTACH_WIDGET;
X	    XmNtopWidget = XmTextField view_up_vect_y;
X	};
X    };
X
X
Xobject
X    proj_ref_pt_label : XmLabel {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator proj_ref_pt_sep;
X	    XmNleftAttachment = XmATTACH_FORM ;
X            XmNlabelString = "Projection Reference Point";
X            };
X        };
X
Xobject
X    proj_ref_pt_x : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator proj_ref_pt_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmLabel proj_ref_pt_label;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "0";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_proj_ref_pt_x);
X            };
X        };
X
Xobject
X    proj_ref_pt_y : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator proj_ref_pt_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField proj_ref_pt_x;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "0";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_proj_ref_pt_y);
X            };
X        };
X
Xobject
X    proj_ref_pt_z : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator proj_ref_pt_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField proj_ref_pt_y;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "10";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_proj_ref_pt_z);
X            };
X        };
X
X!****************************** View Window *******************
X
Xobject
X    view_window_sep : XmSeparator {
X	arguments {
X	    XmNleftAttachment =  XmATTACH_FORM;
X	    XmNrightAttachment =  XmATTACH_FORM;
X	    XmNtopAttachment = XmATTACH_WIDGET;
X	    XmNtopWidget = XmTextField proj_ref_pt_y;
X	};
X    };
X
X
Xobject
X    view_window_label : XmLabel {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_window_sep;
X	    XmNleftAttachment = XmATTACH_FORM ;
X            XmNlabelString = "View Window - minx, maxx, miny, maxy";
X            };
X        };
X
Xobject
X    view_window_minx : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_window_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmLabel view_window_label;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "-3";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_window_minx);
X            };
X        };
X
Xobject
X    view_window_maxx : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_window_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField view_window_minx;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "3";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_window_maxx);
X            };
X        };
X
Xobject
X    view_window_miny : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_window_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField view_window_maxx;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "-3";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_window_miny);
X            };
X        };
X
Xobject
X    view_window_maxy : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_window_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField view_window_miny;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "3";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_window_maxy);
X            };
X        };
X
X!****************************** View Plane Distance, Back & Front *************
X
Xobject
X    view_plane_sep : XmSeparator {
X	arguments {
X	    XmNleftAttachment =  XmATTACH_FORM;
X	    XmNrightAttachment =  XmATTACH_FORM;
X	    XmNtopAttachment = XmATTACH_WIDGET;
X	    XmNtopWidget = XmTextField view_window_maxy;
X	};
X    };
X
X
Xobject
X    view_plane_label : XmLabel {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_plane_sep;
X	    XmNleftAttachment = XmATTACH_FORM ;
X            XmNlabelString = "View Plane, Back & Front";
X            };
X        };
X
Xobject
X    view_plane_dist : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_plane_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmLabel view_plane_label;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "0";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_plane_dist);
X            };
X        };
X
Xobject
X    view_plane_back : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_plane_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField view_plane_dist;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "-5";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_plane_back);
X            };
X        };
X
Xobject
X    view_plane_front : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator view_plane_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField view_plane_back;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "5";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_view_plane_front);
X            };
X        };
X
X!****************************** Projection Viewport  *******************
X
Xobject
X    proj_vp_sep : XmSeparator {
X	arguments {
X	    XmNleftAttachment =  XmATTACH_FORM;
X	    XmNrightAttachment =  XmATTACH_FORM;
X	    XmNtopAttachment = XmATTACH_WIDGET;
X	    XmNtopWidget = XmTextField view_plane_front;
X	};
X    };
X
X
Xobject
X    proj_vp_label : XmLabel {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator proj_vp_sep;
X	    XmNleftAttachment = XmATTACH_FORM ;
X            XmNlabelString = "Projection Viewport";
X            };
X        };
X
Xobject
X    proj_vp_minx : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator proj_vp_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmLabel proj_vp_label;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "0";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_proj_vp_minx);
X            };
X        };
X
Xobject
X    proj_vp_maxx : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator proj_vp_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField proj_vp_minx;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "1";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_proj_vp_maxx);
X            };
X        };
X
Xobject
X    proj_vp_miny : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator proj_vp_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField proj_vp_maxx;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "0";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_proj_vp_miny);
X            };
X        };
X
Xobject
X    proj_vp_maxy : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator proj_vp_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField proj_vp_miny;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "1";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_proj_vp_maxy);
X            };
X        };
X
Xobject
X    proj_vp_minz : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator proj_vp_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField proj_vp_maxy;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "0";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_proj_vp_minz);
X            };
X        };
X
Xobject
X    proj_vp_maxz : XmTextField {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator proj_vp_sep;
X	    XmNleftAttachment = XmATTACH_WIDGET;
X	    XmNleftWidget = XmTextField proj_vp_minz;
X            XmNwidth = 30;
X            XmNmaxLength = 3;
X            XmNvalue = "1";
X            };
X        callbacks {
X	    MrmNcreateCallback = procedure proc_pexdraw_create(k_proj_vp_maxz);
X            };
X        };
X
X!********************************* Projection type
X
X
Xobject
X    proj_type_sep : XmSeparator {
X	arguments {
X	    XmNleftAttachment =  XmATTACH_FORM;
X	    XmNrightAttachment =  XmATTACH_FORM;
X	    XmNtopAttachment = XmATTACH_WIDGET;
X	    XmNtopWidget = XmTextField proj_vp_maxz;
X	};
X    };
X
Xobject
X    proj_type_label : XmLabel {
X        arguments {
X	    XmNleftAttachment =  XmATTACH_FORM;
X	    XmNtopAttachment = XmATTACH_WIDGET;
X	    XmNtopWidget =  XmSeparator proj_type_sep;
X            XmNlabelString = "Projection Type";
X            };
X    };
X
Xobject
X    proj_type_box : XmRadioBox {
X        arguments {
X            XmNorientation = XmHORIZONTAL;
X	    XmNleftAttachment =  XmATTACH_WIDGET;
X	    XmNleftWidget = XmLabel proj_type_label;
X	    XmNtopAttachment = XmATTACH_WIDGET;
X	    XmNtopWidget =  XmSeparator proj_type_sep;
X            XmNborderWidth = 0;
X	    XmNisHomogeneous = false;
X            };
X        controls {
X            XmToggleButton   proj_type_para;
X            XmToggleButton   proj_type_persp;
X            };
X        };
X                                                                                                              
Xobject
X    proj_type_para : XmToggleButton {
X        arguments {
X            XmNlabelString = "Parallel";
X            XmNset = on;   ! A radio box requires one toggle to be set.
X            };                                                             
X        callbacks {
X            MrmNcreateCallback = procedure proc_pexdraw_create (k_proj_type_para);
X            };
X        };
X
Xobject
X    proj_type_persp : XmToggleButton {
X        arguments {
X            XmNlabelString = "Perspective";
X            XmNindicatorOn = on;   ! A radio box requires one toggle to be set.
X            };
X        callbacks {
X            MrmNcreateCallback = procedure proc_pexdraw_create (k_proj_type_persp);
X            };
X        };
X
X!*****************************  Bottom Buttons ******************************
X
Xobject
X    button_box : XmRowColumn {
X        arguments {
X            XmNorientation = XmHORIZONTAL;
X	    XmNleftAttachment =  XmATTACH_FORM;
X	    XmNrightAttachment =  XmATTACH_FORM;
X	    XmNbottomAttachment =  XmATTACH_FORM;
X            XmNborderWidth = 2;
X            XmNentryBorder = 3;
X            };
X        controls {                                                  
X            XmPushButton     apply_button;
X            XmPushButton     dismiss_button;
X            XmPushButton     can_button;
X            };
X        };
X
Xobject
X    apply_button : XmPushButton widget { ! The menu positions the buttons
X        arguments {                     !  automatically.
X            XmNlabelString = "apply";
X            XmNforeground = yellow;
X            XmNbackground = red;
X            XmNhighlightColor = magenta;
X            XmNborderColor = green;
X	    XmNaccelerator = "Ctrl <key>a";
X	    XmNacceleratorText = "^a";
X            };
X        callbacks {
X            MrmNcreateCallback = procedure proc_pexdraw_create (k_apply_vs);
X            XmNactivateCallback = procedure proc_pexdraw_activate (k_apply_vs);
X        };
X    };
X
Xobject
X    can_button : XmPushButton widget {                       
X        arguments {
X            XmNlabelString = "reset";
X            XmNforeground = yellow;
X            XmNbackground = red;
X            XmNhighlightColor = magenta;
X            XmNborderColor = green;
X            };
X        callbacks {
X            MrmNcreateCallback = procedure proc_pexdraw_create (k_reset_vs);
X            XmNactivateCallback = procedure proc_pexdraw_activate (k_reset_vs);
X        };
X    };
X
Xobject
X    dismiss_button : XmPushButton widget {
X        arguments {
X            XmNlabelString = "dismiss";
X            XmNforeground = yellow;
X            XmNbackground = red;
X            XmNhighlightColor = magenta;
X            XmNborderColor = green;
X        };
X        callbacks {
X            MrmNcreateCallback = procedure proc_pexdraw_create (k_dismiss_vs);
X            XmNactivateCallback = procedure proc_pexdraw_activate (k_dismiss_vs);
X        };
X    };
X
X!************************************************************************
X! end of Set View Form
X!************************************************************************
X
X!************************************************************************
X! The Light Form
X!************************************************************************
X
Xobject
X    light_dialog : XmFormDialog {
X        arguments {
X            XmNdialogTitle = "PEX Light Options";
X            XmNdialogStyle = XmDIALOG_MODELESS;
X	    XmNheight = 400;
X	    XmNwidth = 360;
X!	    XmNmwmDecorations = 30;
X            XmNbackground = lightblue;
X        };
X        controls {
X            XmLabel     light_toggles_label;
X            XmRowColumn light_toggles_box;
X	    XmSeparator	light_radio_sep;
X            XmLabel     light_radio_label;
X            XmRadioBox 	light_radio_box;
X	    XmSeparator	light_type_sep;
X	    XmLabel	light_type_label;
X	    XmRadioBox	light_type_box;
X	    XmSeparator	light_pos_sep;
X	    XmLabel	light_pos_label;
X	    XmTextField	light_pos_x;
X	    XmTextField	light_pos_y;
X	    XmTextField	light_pos_z;
X	    XmSeparator	light_color_sep;
X	    XmLabel	light_color_label;
X	    XmTextField	light_color_red;
X	    XmTextField	light_color_green;
X	    XmTextField	light_color_blue;
X	    XmSeparator	light_direction_sep;
X	    XmLabel	light_direction_label;
X	    XmTextField	light_direction_x;
X	    XmTextField	light_direction_y;
X	    XmTextField	light_direction_z;
X	    XmSeparator	light_coeff_sep;
X	    XmLabel	light_coeff_label;
X	    XmTextField	light_coeff_const;
X	    XmTextField	light_coeff_dist;
X	    XmSeparator	light_conc_exp_sep;
X	    XmLabel	light_conc_exp_label;
X	    XmTextField	light_conc_exp;
X	    XmSeparator	light_spread_angle_sep;
X	    XmLabel	light_spread_angle_label;
X	    XmTextField	light_spread_angle;
X            XmRowColumn light_button_box;
X            };
X
X        callbacks {
X            MrmNcreateCallback = procedure proc_pexdraw_create (k_light);
X            };
X    };
X
X!****************************** Light On/Off Toggles ********************
X
Xobject
X    light_toggles_label : XmLabel {
X        arguments {
X	    XmNtopAttachment = XmATTACH_FORM ;
X	    XmNleftAttachment = XmATTACH_FORM ;
X            XmNlabelString = "THIS FORM DOES NOTHING ! ! !";
X            };
X        };
X
Xobject
X    light_toggles_box : XmRowColumn {
X        arguments {
X	    XmNleftAttachment = XmATTACH_FORM ;
X	    XmNrightAttachment = XmATTACH_FORM ;
X	    XmNtopAttachment = XmATTACH_WIDGET;
X	    XmNtopWidget = XmLabel light_toggles_label;
X            XmNorientation = XmHORIZONTAL;
X            XmNbackground = lightblue;
X            XmNborderWidth = 0;
X            };
X        controls {
X            XmToggleButton   light_on1;
X            XmToggleButton   light_on2;
X            XmToggleButton   light_on3;
X            XmToggleButton   light_on4;
X            XmToggleButton   light_on5;
X            XmToggleButton   light_on6;
X            XmToggleButton   light_on7;
X            XmToggleButton   light_on8;
X            };
X        };
X
X
Xobject
X    light_on1 : XmToggleButton {
X        arguments {
X            XmNlabelString = "1";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_on1);
X            };
X        };
Xobject
X    light_on2 : XmToggleButton {
X        arguments {
X            XmNlabelString = "2";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_on2);
X            };
X        };
Xobject
X    light_on3 : XmToggleButton {
X        arguments {
X            XmNlabelString = "3";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_on3);
X            };
X        };
Xobject
X    light_on4 : XmToggleButton {
X        arguments {
X            XmNlabelString = "4";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_on4);
X            };
X        };
Xobject
X    light_on5 : XmToggleButton {
X        arguments {
X            XmNlabelString = "5";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_on5);
X            };
X        };
Xobject
X    light_on6 : XmToggleButton {
X        arguments {
X            XmNlabelString = "6";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_on6);
X            };
X        };
Xobject
X    light_on7 : XmToggleButton {
X        arguments {
X            XmNlabelString = "7";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_on7);
X            };
X        };
Xobject
X    light_on8 : XmToggleButton {
X        arguments {
X            XmNlabelString = "8";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_on8);
X            };
X        };
X
X!****************************** Light Radio Toggles ********************
Xobject
X    light_radio_sep : XmSeparator {
X	arguments {
X	    XmNleftAttachment =  XmATTACH_FORM;
X	    XmNrightAttachment =  XmATTACH_FORM;
X	    XmNtopAttachment = XmATTACH_WIDGET;
X	    XmNtopWidget = XmRowColumn light_toggles_box;
X	};
X    };
X
Xobject
X    light_radio_label : XmLabel {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator light_radio_sep;
X	    XmNleftAttachment = XmATTACH_FORM ;
X	    XmNrightAttachment = XmATTACH_FORM ;
X            XmNlabelString = "Light Edit Selector";
X            };
X        };
X
Xobject
X    light_radio_box : XmRadioBox {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmLabel light_radio_label;
X	    XmNleftAttachment = XmATTACH_FORM ;
X	    XmNrightAttachment = XmATTACH_FORM ;
X            XmNorientation = XmHORIZONTAL;
X            XmNborderWidth = 1;
X            };
X        controls {
X            XmToggleButton   light_edit1;
X            XmToggleButton   light_edit2;
X            XmToggleButton   light_edit3;
X            XmToggleButton   light_edit4;
X            XmToggleButton   light_edit5;
X            XmToggleButton   light_edit6;
X            XmToggleButton   light_edit7;
X            XmToggleButton   light_edit8;
X            };
X        };
X
X
Xobject
X    light_edit1 : XmToggleButton {
X        arguments {
X            XmNlabelString = "1";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_edit1);
X            };
X        };
Xobject
X    light_edit2 : XmToggleButton {
X        arguments {
X            XmNlabelString = "2";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_edit2);
X            };
X        };
Xobject
X    light_edit3 : XmToggleButton {
X        arguments {
X            XmNlabelString = "3";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_edit3);
X            };
X        };
Xobject
X    light_edit4 : XmToggleButton {
X        arguments {
X            XmNlabelString = "4";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_edit4);
X            };
X        };
Xobject
X    light_edit5 : XmToggleButton {
X        arguments {
X            XmNlabelString = "5";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_edit5);
X            };
X        };
Xobject
X    light_edit6 : XmToggleButton {
X        arguments {
X            XmNlabelString = "6";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_edit6);
X            };
X        };
Xobject
X    light_edit7 : XmToggleButton {
X        arguments {
X            XmNlabelString = "7";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_edit7);
X            };
X        };
Xobject
X    light_edit8 : XmToggleButton {
X        arguments {
X            XmNlabelString = "8";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_edit8);
X            };
X        };
X
X!****************************** Light Type Radio ********************
Xobject
X    light_type_sep : XmSeparator {
X	arguments {
X	    XmNleftAttachment =  XmATTACH_FORM;
X	    XmNrightAttachment =  XmATTACH_FORM;
X	    XmNtopAttachment = XmATTACH_WIDGET;
X	    XmNtopWidget = XmRadioBox light_radio_box;
X	};
X    };
X
Xobject
X    light_type_label : XmLabel {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmSeparator light_type_sep;
X	    XmNleftAttachment = XmATTACH_FORM ;
X	    XmNrightAttachment = XmATTACH_FORM;
X            XmNlabelString = "Light Type";
X            };
X        };
X
Xobject
X    light_type_box : XmRadioBox {
X        arguments {
X	    XmNtopAttachment = XmATTACH_WIDGET ;
X	    XmNtopWidget = XmLabel light_type_label;
X	    XmNleftAttachment = XmATTACH_FORM;
X	    XmNrightAttachment = XmATTACH_FORM;
X            XmNorientation = XmHORIZONTAL;
X            XmNborderWidth = 1;
X            };
X        controls {
X            XmToggleButton   light_type_ambient;
X            XmToggleButton   light_type_directional;
X            XmToggleButton   light_type_positional;
X            XmToggleButton   light_type_spot;
X            };
X        };
X
Xobject
X    light_type_ambient : XmToggleButton {
X        arguments {
X            XmNlabelString = "Ambient";
X            };
X        callbacks {
X            XmNvalueChangedCallback = procedure proc_pexdraw_activate (k_light_type_ambient);
END_OF_FILE
  if test 28751 -ne `wc -c <'pexdrawu.2'`; then
    echo shar: \"'pexdrawu.2'\" unpacked with wrong size!
  fi
  # end of 'pexdrawu.2'
fi
if test -f 'rdr.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'rdr.c'\"
else
  echo shar: Extracting \"'rdr.c'\" \(20761 characters\)
  sed "s/^X//" >'rdr.c' <<'END_OF_FILE'
X#ifdef SCCS
Xstatic char sccsid[]="@(#)rdr.c	1.15 Oki 93/05/24";
X#endif
X/*
X *			Copyright (c) 1992 by
X *			Oki Electric Industry Co., Ltd.
X *			All Rights Reserved
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted,
X * provided that the above copyright notice appear in all copies and that
X * both that copyright notice and this permission notice appear in
X * supporting documentation, and that the name of Oki Electric not be
X * used in advertising or publicity pertaining to distribution of the
X * software without specific, written prior permission. Oki Electric
X * makes no representations about the suitability of this software for any
X * purpose.  It is provided "as is" without express or implied warranty.
X *
X *************************************************************************
X * rdr.c - the methods for using a PHIGS Workstation resource as the
X * render object.
X *
X *  rdrInit
X *  rdrReDraw
X *  rdrMapXtoMC
X *  rdrMapMCtoX
X *  rdrSetView
X *  rdrSetNPCtoDC
X *  rdrPost
X *  rdrDeleteAll
X *  rdrPickOne
X */
X
X#include <stdio.h>
X
X#include <math.h>
X
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/Xatom.h>
X
X#include <X11/PEX5/PEXlib.h>
X#include "pexdraw.h"
X#include "util/pexutdb.h"  /* this ain't Right, but life is too short */
X
X/*************************************************************************
X * State Variables
X */
Xstatic int myMCSeqNo = -1;
Xstatic int thePickInitFlag = 0;
X
Xstatic int theRdrViewLUT;
X
Xstatic int rPostCount = 0;
Xstatic long *rPostTable = (long *)0;
X
Xstatic Drawable the3DBuffer;
Xstatic int thePMWidth, thePMHeight;
Xstatic PEXPipelineContext thePC;
Xextern int theDBFlag;
X
XPEXNPCSubVolume theVolume;
XPEXViewport theViewport;
XPEXMatrix theXToMCMatrix;
Xint theMatrixValidFlag = 0;
X
Xextern int theHPFlag;
X/* L O C A L  P r o c s */
X
X/*************************************************************************
X *
X */
XXID  rdrInit( dpy,  w, colorLUT, lightLUT, textLUT, depthCueLUT,colorApproxLUT)
X     Display *dpy;
X     Window w;
X     PEXLookupTable colorLUT;
X     PEXLookupTable lightLUT;
X     PEXLookupTable textLUT;
X     PEXLookupTable depthCueLUT;
X     PEXLookupTable colorApproxLUT;
X{
X  XID                           renderObj;
X  PEXNameSet			incl, excl;
X  PEXName names[2];
X  PEXRendererAttributes		rAttrs;	/* renderer attributes */
X  long                          rMask;
X  XWindowAttributes             winAttrs;
X
X  PEXPCAttributes		pcAttrs;
X  unsigned long			pcMask[3];
X  
X  XColor                        background;
X  Drawable                      id;
X  int                           dbstat;
X/*************************************************************************/
X
X  theRdrViewLUT = PEXCreateLookupTable( theDisplay, theWindow, PEXLUTView);
X
X  incl = PEXCreateNameSet(theDisplay);
X  names[0] = 1; names[1] = 2; names[2] = 3; /* do an extra, for the heck */
X  PEXChangeNameSet(theDisplay, incl, PEXNSAdd, 3, names);
X  excl = PEXCreateNameSet(theDisplay);
X
X/*
X * init the NPC to DC transform so we have it when we need it.
X */
X  theVolume.min.x = theVolume.min.y = theVolume.min.z = 0.0;
X  theVolume.max.x = theVolume.max.y = theVolume.max.z = 1.0;
X
X  XGetWindowAttributes(theDisplay, theWindow, &winAttrs );
X
X  theViewport.min.x = theViewport.min.y = theViewport.min.z = 0.0;
X  theViewport.max.x = winAttrs.width;
X  theViewport.max.y = winAttrs.height;
X  theViewport.max.z = 1.0;
X  theViewport.use_drawable = 1;
X
X/*
X * Init the Pipeline Context for TextHeight and CurveApprox Criteria.
X */
X  pcAttrs.char_height = 0.08;
X  pcAttrs.curve_approx.method = PEXApproxConstantBetweenKnots;
X  pcAttrs.curve_approx.tolerance = 16.0;
X  pcAttrs.surface_approx.method = PEXApproxConstantBetweenKnots;
X  pcAttrs.surface_approx.u_tolerance = 4.0;
X  pcAttrs.surface_approx.v_tolerance = 4.0;
X
X  pcMask[0] = pcMask[1] = pcMask[2] = 0;
X  if (CheckEnumType(PEXETCurveApproxMethod, PEXApproxConstantBetweenKnots))
X    {PEXSetPCAttributeMask(pcMask, PEXPCCurveApprox);
X     PEXSetPCAttributeMask(pcMask, PEXPCSurfaceApprox);}
X  PEXSetPCAttributeMask(pcMask, PEXPCCharHeight );
X  if (theHPFlag == 0)
X  thePC = PEXCreatePipelineContext(theDisplay, pcMask, &pcAttrs);
X
X/*
X * now set all of the accumulated attributes into the struct and set the flags.
X */
X  rAttrs.pipeline_context = thePC;
X  rAttrs.npc_subvolume = theVolume;
X  rAttrs.viewport = theViewport;
X  rAttrs.view_table = theRdrViewLUT;
X  rAttrs.light_table = lightLUT;
X  rAttrs.hlhsr_mode = PEXHLHSRZBuffer;
X  rAttrs.depth_cue_table = depthCueLUT;
X  rAttrs.color_approx_table = colorApproxLUT;
X  rAttrs.color_table = colorLUT;
X  rAttrs.text_font_table = textLUT;
X  rAttrs.pick_incl = incl;
X  rAttrs.pick_excl = excl;
X  rAttrs.pick_excl = excl;
X  rAttrs.clear_image = True;
X  rAttrs.clear_z = True;
X
X  rMask = PEXRAPipelineContext|PEXRALightTable|PEXRAHLHSRMode|
X    PEXRAViewTable|PEXRADepthCueTable|PEXRAColorTable|
X      PEXRAColorApproxTable|PEXRAPickIncl|PEXRAPickExcl|
X	PEXRANPCSubVolume|PEXRAViewport|PEXRAClearImage|
X	  PEXRAClearZ|PEXRATextFontTable;
X
X/*  if (theHPFlag == 0)   mask |= PEXRAPipelineContext; byte swapping bug? */
X
X  renderObj = PEXCreateRenderer(theDisplay, theWindow, rMask, &rAttrs);
X
X  background.pixel = BlackPixel(theDisplay,theScreen);
X  background.red = 0;
X  background.green = 0;
X  background.blue = 0;
X  background.flags = DoRed|DoGreen|DoBlue;
X
X  if (theDBFlag) {
X    dbstat = PEXUtDBConfig(theDisplay, theWindow, True,&background,False,&id);	
X    printf(" dbstat %x, id %x, win %x\n", dbstat, id, theWindow );
X    if (theWindow != id) {
X      printf(" Pixmap or MBX - reassinging theWindow! \n");
X      the3DBuffer = id;
X    } else {
X      the3DBuffer = theWindow;
X    }
X  } else {
X    the3DBuffer = theWindow;
X  }
X  return (renderObj);
X}
X
X/*************************************************************************
X * ReDraw - does a redraw for the renderer case.
X */
Xvoid  rdrReDraw()
X{
X  int i;
X  Drawable id;
X
X  PEXBeginRendering(theDisplay, the3DBuffer, theRenderObj);
X
X  for (i = 0; i < rPostCount; i++ )
X    PEXExecuteStructure(theDisplay, theRenderObj, PEXOCRender, rPostTable[i] );
X  
X  PEXEndRendering(theDisplay, theRenderObj, 1);
X  
X  if (theDBFlag) {
X    id = PEXUtDBSwap(theDisplay, theWindow, False );
X    the3DBuffer = id;
X  }
X  XFlush(theDisplay);
X}
X
X/*************************************************************************
X * MapPoints 
X */
Xint  rdrMapXToMC(mc, nCoords, xPoints, mcPoints )
X     MCMatrix *mc;
X     int nCoords;
X     XPoint *xPoints;
X     PEXCoord **mcPoints;
X{
X  int i;
X  int error;
X  unsigned long valueMask[2];
X  PEXRendererAttributes *rdrAttrs;
X  PEXMatrix WCtoXC, NPCtoXC, XtoMC;
X  XPoint *xp;
X  PEXCoord p, *m;
X
X  error = PEXNPCToXCTransform( &theVolume, (PEXDeviceCoord *)&theViewport, 
X			      theWinHeight, NPCtoXC );
X  if(error != 0) printf("imagine a Motif alarm, NPCtoXC err = %d\n",error);
X
X  PEXMatrixMult( theMatMap, theMatOri, WCtoXC );
X  PEXMatrixMult( NPCtoXC, WCtoXC, WCtoXC );
X  if (myMCSeqNo != mc->seqNo) myMCSeqNo = mc->seqNo; /* cache this someday */
X  PEXMatrixMult( WCtoXC, mc->matrix, WCtoXC );
X  
X  error = PEXInvertMatrix( WCtoXC, XtoMC );
X  if(error != 0) printf("imagine a Motif alarm, Invert err = %d\n",error);
X
X  m = (PEXCoord *)malloc(nCoords * sizeof(PEXCoord));
X
X  for (i = 0, xp = xPoints; i < nCoords; i++, xp++ ) {
X    p.x = (float)xp->x;
X    p.y = (float)xp->y;
X    p.z = theDepth;
X    PEXTransformPoints(XtoMC, 1, &p, &m[i]);
X  }
X
X  *mcPoints = m;
X  return (nCoords);
X}
X
X/*************************************************************************
X * MapMCToX
X *
X * MC xform struct.
X * count
X * points in
X * returns points out.
X * functions returns count
X */
Xint rdrMapMCToX( mc, inCount, mcPoints, xPoints )
X     MCMatrix *mc;
X     int inCount;
X     PEXCoord *mcPoints;
X     XPoint **xPoints;
X{
X  int i;
X  int error;
X  PEXMatrix WCtoXC, NPCtoXC, XtoMC;
X  XPoint *xp;
X  PEXCoord p, *m;
X
X  error = PEXNPCToXCTransform( &theVolume, (PEXDeviceCoord *)&theViewport, 
X			      theWinHeight, NPCtoXC );
X  if(error != 0) printf("imagine a Motif alarm, NPCtoXC err = %d\n",error);
X
X  PEXMatrixMult( theMatMap, theMatOri, WCtoXC );
X  PEXMatrixMult( NPCtoXC, WCtoXC, WCtoXC );
X  if (myMCSeqNo != mc->seqNo) myMCSeqNo = mc->seqNo; /* cache this someday */
X  PEXMatrixMult( WCtoXC, mc->matrix, WCtoXC );
X
X  *xPoints = (XPoint *)malloc(inCount * sizeof(XPoint));
X
X  for (i = 0, xp = *xPoints; i < inCount; i++, xp++ ) {
X    PEXTransformPoints(WCtoXC, 1, &mcPoints[i], &p);
X    xp->x = p.x;
X    xp->y = p.y;
X  }
X
X  return (inCount);
X}
X
X/*************************************************************************
X *
X */
Xvoid  rdrSetView( viewNumber, view)
X     int viewNumber;
X     PEXViewEntry *view;
X{
X  PEXSetTableEntries(theDisplay, theRdrViewLUT,1,1, PEXLUTView,(char *)view);
X}
X
X/*************************************************************************
X *
X */
Xvoid  rdrSetNPCToDC( volume, viewport )
X     PEXNPCSubVolume *volume;
X     PEXViewport *viewport;
X{
X  PEXRendererAttributes		rAttrs;	/* renderer attributes */
X
X  rAttrs.npc_subvolume = *volume;
X  rAttrs.viewport = *viewport;
X  PEXChangeRenderer( theDisplay, theRenderObj, 
X		    PEXRANPCSubVolume|PEXRAViewport, &rAttrs );
X
X  theMatrixValidFlag = 0;
X  theVolume = *volume;
X  theViewport = *viewport;
X }
X
X/*************************************************************************
X * P O S T - rdrPost
X *
X * put the struxid in the "to be redrawn" list.
X */
Xvoid  rdrPost( struxid )
Xlong struxid;
X{
X  int i;
X/*
X * Check to see if this strux is already in use.
X * This quite inefficient if you have lots of structures. Perhaps
X * keep a pointer to an encoded ROC packet with all of the executes.
X */
X  for (i = 0; i < rPostCount; i++ )
X    if (rPostTable[i] == struxid) 
X      { printf("alarm, alread posted %d\n", struxid ); return; }
X
X  rPostCount++;
X  if (rPostCount == 1) {
X    rPostTable = (long *)malloc(rPostCount*sizeof(long *));
X  } else {
X    rPostTable = (long *)realloc(rPostTable, rPostCount*sizeof(long *));
X  }
X
X  if (!rPostTable) {printf("alarm, malloc failed in rdrPost\n"); }
X
X  rPostTable[rPostCount-1] = struxid;
X}
X
X/*************************************************************************
X *  DeleteAllStrux
X *
X *  PHIGS Workstation Version, get all of the posted structres and delete them
X *  Should probably do a PEXGetDescendants, to be really thorough.
X */
Xvoid  rdrDeleteAll()
X{
X  PEXDestroyStructures(theDisplay, rPostCount, (PEXStructure *)rPostTable);
X  rPostCount = 0;
X  free(rPostTable);
X  theNewStrux = 0;
X  theSelectedElement = -1;
X}
X
X
X/*************************************************************************
X * PickSomething - returns structure and element, else element == -1
X */
X#if NeedFunctionPrototypes
X/* need to do this to avoid warning about initialization, due to shorts */
Xvoid  rdrPickOne( short x, short y, long *strux, int *element )
X#else
Xvoid  rdrPickOne( x, y, strux, element )
X     short x;
X     short y;
X     long *strux;
X     int *element;
X#endif
X{
X  PEXPDDCHitBox hitInfo;
X  PEXPickPath *pickReturn;
X  int i;
X  int statusReturn, hidden;
X  XColor                        background;
X  Drawable                      id;
X  int                           dbstat;
X
X  hitInfo.position.x = x;
X  hitInfo.position.y = theWinHeight - y;
X  hitInfo.distance = 10;
X
X/*
X * this is just to test both cases.
X * Since there is the default structure in the beginning. When we add one we
X * have two, to get the PEXPickOne, delete all then add something.
X */
X  if (rPostCount == 1) {
X    pickReturn =  PEXPickOne(theDisplay, theWindow, theRenderObj,
X			     rPostTable[0],  PEXPickLast,  
X			     PEXPickDeviceDCHitBox, (PEXPickRecord *)&hitInfo, 
X			     &statusReturn, &hidden);
X  } else {
X    PEXBeginPickOne(theDisplay, theWindow, theRenderObj, (XID)1, PEXPickLast,  
X		    PEXPickDeviceDCHitBox, (PEXPickRecord *)&hitInfo );
X    
X    for (i = 0; i < rPostCount; i++ )
X      PEXExecuteStructure(theDisplay, theRenderObj, PEXOCRender, rPostTable[i]);
X    
X    pickReturn = PEXEndPickOne(theDisplay, theRenderObj,
X			       &statusReturn, &hidden);
X  }
X
X  if (statusReturn == PEXPick) {
X    /*
X     * Get the last struxure/element in the pick path
X     */
X    *strux   = pickReturn->elements[pickReturn->count-1].sid;
X    *element = pickReturn->elements[pickReturn->count-1].offset;
X  } else {
X    *element = -1;
X  }
X
X  if (statusReturn == PEXPick) {
X    PEXColor echoColor;
X    PEXElementRef eRefs[4];
X    int i;
X    PEXRendererAttributes	rAttrs;	/* renderer attributes */
X    int count, offset;
X/*
X * just testing for now. Really should try to do something useful.
X * count -1 here is because we are skipping over the dummy structure
X * in the return path.
X * we are copying from a pick return path to an element ref path
X */
X    if (rPostCount == 1) {
X      count = pickReturn->count;
X      offset = 0;
X    } else {
X      count = pickReturn->count - 1;
X      offset = 1;
X    }
X    if (count > 4) return;
X    for (i = 0; i < count; i++ ) {
X      eRefs[i].structure =  pickReturn->elements[i+offset].sid;
X      eRefs[i].offset    =  pickReturn->elements[i+offset].offset;
X    }
X
X    rAttrs.clear_image = False;
X    PEXChangeRenderer( theDisplay, theRenderObj, PEXRAClearImage, &rAttrs );
X
X    background.pixel = BlackPixel(theDisplay,theScreen);
X    background.red = 0;
X    background.green = 0;
X    background.blue = 0;
X    background.flags = DoRed|DoGreen|DoBlue;
X    if (theDBFlag)
X      dbstat = PEXUtDBConfig(theDisplay, theWindow, False,&background,False, &id);
X
X    PEXBeginRendering(theDisplay, theWindow, theRenderObj);
X    PEXAccumulateState(theDisplay, theRenderObj, count, eRefs );
X    echoColor.rgb.red   = 1.0;
X    echoColor.rgb.green = 1.0;
X    echoColor.rgb.blue  = 0.0;
X    PEXSetLineColor( theDisplay, theRenderObj, PEXOCRender,
X		    PEXColorTypeRGB, &echoColor );
X    PEXSetTextColor( theDisplay, theRenderObj, PEXOCRender,
X		    PEXColorTypeRGB, &echoColor );
X    PEXSetSurfaceColor( theDisplay, theRenderObj, PEXOCRender,
X		    PEXColorTypeRGB, &echoColor );
X    PEXRenderElements(theDisplay, theRenderObj, *strux, PEXBeginning, *element,
X			     PEXBeginning, *element );
X    PEXEndRendering(theDisplay, theRenderObj, 1);
X
X    XSync(theDisplay, 0);
X    if (theDBFlag) {
X      dbstat = PEXUtDBConfig(theDisplay, theWindow, True,&background,False,&id);	
X      printf(" dbstat %x, id %x, win %x\n", dbstat, id, theWindow );
X      if (theWindow != id) {
X        printf(" Pixmap or MBX - reassinging theWindow! \n");
X        the3DBuffer = id;
X      } else {
X        the3DBuffer = theWindow;
X      }
X    }
X    rAttrs.clear_image = True;
X    PEXChangeRenderer( theDisplay, theRenderObj, PEXRAClearImage, &rAttrs );
X  }
X
X}
X
X/*************************************************************************
X * rdrPickAll - 
X */
X#if NeedFunctionPrototypes
X/* need to do this to avoid warning about initialization, due to shorts */
Xvoid rdrPickAll( short x, short y, short x2, short y2,
X		int *nFound, long **struxArray, int **elemArray )
X#else
Xvoid rdrPickAll( x, y, x2, y2, nFound, struxArray, elemArray )
X     short x;
X     short y;
X     short x2;
X     short y2;
X     int *nFound;
X     long **struxArray;
X     int **elemArray;
X#endif
X{
X  PEXPDNPCHitVolume  hitBox;
X  PEXPickPath *pickReturn, *pps;
X  int i;
X  int statusReturn, hidden;
X  PEXMatrix XCtoNPC;
X  PEXCoord p[2];
X  int more;
X  unsigned long hitCount;
X  float t;
X  int notDone = 1;
X
X  *nFound = 0;
X
X  i = PEXXCToNPCTransform( &theVolume, (PEXDeviceCoord *)&theViewport,
X			  theWinHeight, XCtoNPC );
X  if (i!=0) {printf("rdrPickAll bad XCtoNPC %d\n", i); return; }
X
X  p[0].x = x;
X  p[0].y = y;
X  p[0].z = 1.0;
X  p[1].x = x2;
X  p[1].y = y2;
X  p[1].z = 0.0;
X
X  PEXTransformPoints(XCtoNPC, 2, p, (PEXCoord *)&hitBox);
X
X#define SWAP(a,b) {t=a;a=b;b=t;}
X
X  if (hitBox.min.x > hitBox.max.x) SWAP(hitBox.min.x, hitBox.max.x);
X  if (hitBox.min.y > hitBox.max.y) SWAP(hitBox.min.y, hitBox.max.y);
X  if (hitBox.min.z > hitBox.max.z) SWAP(hitBox.min.z, hitBox.max.z);
X
X  if (rPostCount == 1) {
X    PEXRendererAttributes	rAttrs;	/* renderer attributes */
X    PEXElementRef       ep[1];
X
X    rAttrs.pick_start_path.count = 1;
X    rAttrs.pick_start_path.elements = ep;
X    rAttrs.pick_start_path.elements[0].structure = rPostTable[0];
X    rAttrs.pick_start_path.elements[0].offset = 0; /* begins after */
X
X    PEXChangeRenderer(theDisplay, theRenderObj, PEXRAPickStartPath, &rAttrs );
X    *nFound = 0;
X
X    while (notDone) {
X      pickReturn = PEXPickAll(theDisplay, theWindow, theRenderObj,
X			    PEXPickLast, /* max hits */3, 
X			    PEXPickDeviceNPCHitVolume,
X			    (PEXPickRecord *)&hitBox,
X			    &statusReturn, &more, &hitCount );
X
X      if (statusReturn == PEXPick) {
X	if (*nFound == 0) {
X	  *struxArray = (long *)malloc(hitCount*sizeof(long));
X	  *elemArray = (int *)malloc(hitCount*sizeof(int));
X	} else {
X	  *struxArray = (long *)realloc((char *)*struxArray,
X					(*nFound+hitCount)*sizeof(long));
X	  *elemArray = (int *)realloc((char *)*elemArray,
X				      (*nFound+hitCount)*sizeof(int));
X	}
X
X	for (i = *nFound, pps = pickReturn; i < *nFound+(int)hitCount; i++ ){
X	  /*
X	   * Get the last struxure/element in the pick path
X	   printf("depth %d, leaf - sid %x, element %x\n", pps->count, 
X	   */ 
X	  (*struxArray)[i] = pps->elements[pps->count-1].sid;
X	  (*elemArray)[i] = pps->elements[pps->count-1].offset;
X	  pps++;
X	}
X	*nFound += hitCount;
X	PEXFreePickPaths(hitCount,pickReturn);
X      } else {
X	notDone = 0;
X      }
X      if (more == PEXNoMoreHits) notDone = 0;
X    } /* end while notDone */
X  } else {
X    PEXBeginPickAll(theDisplay, theWindow, theRenderObj, 1,
X		    PEXPickLast,  False, /* max hits */42, 
X		    PEXPickDeviceNPCHitVolume, (PEXPickRecord *)&hitBox );
X    
X    for (i = 0; i < rPostCount; i++ )
X      PEXExecuteStructure(theDisplay, theRenderObj, PEXOCRender, rPostTable[i]);
X    
X    pickReturn = PEXEndPickAll(theDisplay, theRenderObj,
X			     &statusReturn, &more, &hitCount );
X
X
X    if (statusReturn == PEXPick) {
X      *struxArray = (long *)malloc(hitCount*sizeof(long));
X      *elemArray = (int *)malloc(hitCount*sizeof(int));
X      for (i = 0, pps = pickReturn; i < (int)hitCount; i++ ){
X	/*
X	 * Get the last struxure/element in the pick path
X	 *  printf("depth %d, leaf - sid %x, element %x\n", pps->count, 
X	 */ 
X	(*struxArray)[i] = pps->elements[pps->count-1].sid;
X	(*elemArray)[i] = pps->elements[pps->count-1].offset;
X	pps++;
X      }
X      *nFound = hitCount;
X      PEXFreePickPaths(hitCount,pickReturn);
X    } else {
X      printf("no luck in pick all\n");
X    }
X  }
X}
X
Xint rdrMapXToNPC( count, points)
X     int count;
X     PEXCoord *points;
X{
X  int i;
X  PEXMatrix XCtoNPC;
X
X  i = PEXXCToNPCTransform( &theVolume, (PEXDeviceCoord *)&theViewport,
X			  theWinHeight, XCtoNPC );
X  if (i!=0) {printf("rdrPickAll bad XCtoNPC %d\n", i); return (0); }
X
X  PEXTransformPoints(XCtoNPC, count, points, points);
X  return (1);
X}
X
Xint rdrReconfigureWindow( wkid, width, height)
X     long wkid;
X     int width;
X     int height;
X{
X   if (theWimpyWindow)
X     XResizeWindow(theDisplay, theWindow, width, height );
X
X   the3DBuffer = PEXUtDBResize(theDisplay, theWindow);
X}
X
Xint rdrGetColorFromIndex(cIndex, rgb)
X     int cIndex;
X     PEXColorRGB *rgb;
X{
X  PEXRendererAttributes *rAttr;
X  int table_type;
X  int defined;
X  PEXColorSpecifier *entry;
X
X  rAttr = PEXGetRendererAttributes( theDisplay, theRenderObj, PEXRAColorTable);
X  if (!rAttr) return (0);
X  entry = (PEXColorSpecifier *)PEXGetTableEntry(theDisplay, rAttr->color_table,
X						cIndex, PEXSetValue, &defined,
X						&table_type);
X  if (table_type != PEXLUTColor) {
X    printf("rdrGetColorFromIndex fix it!!!\n");
X    return (0);
X  }
X  if (entry->type != PEXColorTypeRGB) printf("RGB NOT %d\n");
X  *rgb = entry->value.rgb;
X
X  PEXFreeTableEntries(table_type, 1,(PEXPointer)entry);
X  PEXFreeRendererAttributes(rAttr);
X  return (1);
X}
X
X/*************************************************************************
X * U N P O S T - rdrUnpost
X *
X * remove the struxid from the "to be redrawn" list.
X */
Xvoid  rdrUnpost( strux )
Xlong strux;
X{
X  int i;
X/*
X * Check to see if this strux is already in use.
X * This quite inefficient if you have lots of structures. Perhaps
X * keep a pointer to an encoded ROC packet with all of the executes.
X */
X  for (i = 0; i < rPostCount; i++ )
X    if (rPostTable[i] == strux) {
X      if (i < rPostCount-1) {
X	bcopy(&rPostTable[i+1], &rPostTable[i], sizeof(long)*(rPostCount-i-1));
X      }
X      rPostCount--;
X      return;
X    }
X  /* no can do */
X  printf("tried to unpost non existent strux = %x\n", strux);
X}
X
X
X/*
X * init the procedure pointer structure
X */
XrenderProcs rdrProcs = { rdrInit, rdrReDraw, rdrMapXToMC, rdrMapMCToX, 
X			   rdrSetView, rdrSetNPCToDC, rdrPost, rdrDeleteAll,
X			   rdrPickOne, rdrPickAll, rdrMapXToNPC,
X			   rdrReconfigureWindow, rdrGetColorFromIndex, 
X			   rdrUnpost };
X
END_OF_FILE
  if test 20761 -ne `wc -c <'rdr.c'`; then
    echo shar: \"'rdr.c'\" unpacked with wrong size!
  fi
  # end of 'rdr.c'
fi
if test -f 'util/pexutext.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'util/pexutext.h'\"
else
  echo shar: Extracting \"'util/pexutext.h'\" \(7178 characters\)
  sed "s/^X//" >'util/pexutext.h' <<'END_OF_FILE'
X
X#ifndef _PEXUTEXT_H_ /* [ */
X#define _PEXUTEXT_H_
X
X/******************************************************************************/
X/*                                                                            */
X/*  (c) Copyright Hewlett-Packard Company, 1992, Fort Collins, Colorado       */
X/*                                                                            */
X/*                            All Rights Reserved                             */
X/*                                                                            */
X/*  Permission to use, copy, modify, and distribute this software and its     */
X/*  documentation for any purpose and without fee is hereby granted,          */
X/*  provided that the above copyright notices appear in all copies and that   */
X/*  both the copyright notices and this permission notice appear in           */
X/*  supporting documentation, and that the name of Hewlett-Packard not be     */
X/*  used in advertising or publicity pertaining to distribution of the        */
X/*  software without specific, written prior permission.                      */
X/*                                                                            */
X/*  HEWLETT-PACKARD MAKES NO WARRANTY OF ANY KIND WITH REGARD TO THIS         */
X/*  SOFTWARE, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF        */
X/*  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  Hewlett-Packard    */
X/*  shall not be liable for errors contained herein or direct, indirect,      */
X/*  special, incidental or consequential damages in connection with the       */
X/*  furnishing, performance or use of this software.                          */
X/*                                                                            */
X/******************************************************************************/
X
X/******************************************************************************/
X/*                                                                            */
X/* $Source: /users/waitz/work/tmp/RCS/pexutext.h,v $                      	      */
X/* $Date: 93/03/02 16:39:31 $                                                 */
X/* $Revision: 1.1 $                                                           */
X/*                                                                            */
X/* Description:                                                               */
X/*   Internal header file for PEXUt ,                    		      */
X/*   not to be included by application programs.                              */
X/*                                                                            */
X/* Notes:                                                                     */
X/*                                                                            */
X/******************************************************************************/
X
X/*
X** Data structures and constants for escapes used in the utilities.
X** This header file is intended to make the code more portable by eliminating
X** the need to include vendor-specific extension header files.
X*/
X
X/*
X** The following is to prevent multiple inclusion of escape information from 
X** any vendor specific header files.  It relies on standard constant names
X** for the escape opcode.
X*/
X
X#if !defined (ES_ESCAPE_DBLBUFFER) /* [ */
X
X/*
X** Constants for E&S double-buffering escapes
X*/
X#define ES_ESCAPE_DBLBUFFER             0x80040001      /* escape for db      */
X#define ES_RENDERER_SINGLEBUFFER                 0      /* turn db off        */
X#define ES_RENDERER_DBLBUFFER                    1      /* turn db on         */
X
X#define ES_ESCAPE_SWAPBUFFER            0x80040002      /* escape to swap buf */
X
X#define ES_ESCAPE_SWAPBUFFERCONTENT     0x80040003      /* escape to inquire  */
X#define ES_DB_SWAP_CONTENT_UNDEFINED             0      /* what the content   */
X#define ES_DB_SWAP_CONTENT_CLEAR_TO_BACKGROUND   1      /* of the back buffer */
X#define ES_DB_SWAP_CONTENT_UNCHANGED             2      /* will be after a    */
X#define ES_DB_SWAP_CONTENT_FRONTBUFFER           3      /* swap is done       */
X
X
X/*
X** Constants for enumerated type descriptors returned from PEXGetEnumTypeInfo
X*/
X#define ES_ESCAPE_ET_DBLBUFFER          0x8401
X#define ES_ESCAPE_ET_SWAPBUFFER         0x8402
X#define ES_ESCAPE_ET_SWAPBUFFERCONTENT  0x8403
X
X#define ES_ESCAPE_ETM_DBLBUFFER         "ES_ESCAPE_DBLBUFFER"
X#define ES_ESCAPE_ETM_SWAPBUFFER        "ES_ESCAPE_SWAPBUFFER"
X#define ES_ESCAPE_ETM_SWAPBUFFERCONTENT "ES_ESCAPE_SWAPBUFFERCONTENT"
X
X/*
X** Data structures for E&S double-buffering.
X** The PEXEscape function is defined in PEXlib.h.
X** These define the data argument for PEXEscape.
X*/
Xtypedef struct {        /* Data for ES_ESCAPE_DBLBUFFER in PEXEscape function */
X   Drawable             drawable;
X   unsigned long        bufferMode;
X} esEscapeDblBuffer;
X
Xtypedef struct {        /* Data for ES_ESCAPE_SWAPBUFFER in PEXEscape function*/
X   Drawable             drawable;
X} esEscapeSwapBuffer;
X
Xtypedef struct {/* Data for ES_ESCAPE_SWAPBUFFERCONTENT in PEXEscapeWithReply */
X   Drawable             drawable;
X} esEscapeSwapBufferContent;
X
Xtypedef struct {/* Return from PEXEscapeWithReply, ES_ESCAPE_SWAPBUFFERCONTENT*/
X   unsigned char        type;
X   unsigned char        unused;
X   unsigned short       sequence_num;
X   unsigned long        length;
X   unsigned long        escapeId;
X   unsigned long        content;
X} esEscapeSwapBufferContentReply;
X
X#endif /* ] */
X
X
X#if !defined (HP_ESCAPE_DFRONT) /* [ */
X/*
X** Constants for HP double-buffering escapes
X*/
X
X#define HP_ESCAPE_DFRONT                0x80070001      /* escape render cntl */
X#define HP_RENDER_TO_BACK_BUFFER                 0      /* render to back     */
X#define HP_RENDER_TO_FRONT_BUFFER                1      /* render to front    */
X
X#define HP_ESCAPE_ET_DFRONT             0x8701
X#define HP_ESCAPE_ETM_DFRONT            "HP_ESCAPE_DFRONT"
X
Xtypedef struct {        /* Data for HP_ESCAPE_DFRONT in PEXEscape function    */
X   Drawable             drawable;
X   int                  render_to_front_buffer;
X} hpEscapeSetRenderingBuffer;
X
X#endif /* ] */
X
X
X#if !defined (PEXEscapeQueryColorApprox) /* [ */
X
X/* QueryColorApprox                                                           */
X#define PEXEscapeQueryColorApprox    0x80010001
X#define PEXETEscapeQueryColorApprox  0x8101
X
X/* QueryColorApprox mnemonic                                                  */
X#define PEXETMEscapeQueryColorApprox "QueryColorApprox"
X
Xtypedef struct 
X{
X   Drawable            drawable;     /* Drawable to compare capx against     */
X   PEXColorApproxEntry capx;         /* Color approx to check                */
X} PEXEscapeQueryColorApproxData;
X
Xtypedef struct 
X{
X   char          capx_is_supported;  /* True if given input approx supported */
X   char          dithering_supported;/* True if dithering is supported       */
X   char          all_capxs;          /* True if all alt capx's are returned  */
X   char          reserved1;
X   unsigned long count;              /* Number of alternative color approx's */
X   unsigned int	 reserved2[3];
X} PEXEscapeQueryColorApproxReplyData;
X
X#endif /* ] */
X
X#endif /* _PEXUTEXT_H_ ] */
END_OF_FILE
  if test 7178 -ne `wc -c <'util/pexutext.h'`; then
    echo shar: \"'util/pexutext.h'\" unpacked with wrong size!
  fi
  # end of 'util/pexutext.h'
fi
echo shar: End of archive 11 \(of 14\).
cp /dev/null ark11isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 14 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
    echo "concatentating pexdraw.c ..."
    cat pexdrawc.? > pexdraw.c
    rm pexdrawc.?
    echo "concatentating pexdraw.uil ..."
    cat pexdrawu.? > pexdraw.uil
    rm pexdrawu.?
    echo "concatentating teapot.c ..."
    rm teapotc.?
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM       | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@imd.sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
