Newsgroups: comp.sources.x
From: gregor@asdi.saic.com (Gregg Hanna x6033)
Subject: v20i096:  mrolo - Motif rolodex, Part01/02
Message-ID: <csx-v20i096=mrolo.164513@sparky.Sterling.COM>
X-Md4-Signature: 5801732e417267feea0b1a4d425fe273
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Thu, 15 Jul 1993 21:45:30 GMT
Approved: chris@sterling.com

Submitted-by: gregor@asdi.saic.com (Gregg Hanna x6033)
Posting-number: Volume 20, Issue 96
Archive-name: mrolo/part01
Environment: X11, OSF/Motif

MRolo is a Motif based cardfile program.  It was designed to
be as simple as possible, and was born out of frustration with
xrolo's and xrolodex's many menus.  Even if you love xrolo or
xrolodex, you might want to look at prolo in this distribution,
which is a program for generating PostScript versions of
a card file database.

Some features of mrolo:

  o From the main screen you see a list of all cards and
    may scroll through them viewing/editing cards as desired.

  o You may jump to a section of the card file by clicking on
    a lettered tab on the edge of the screen (A-Z).

  o You can search cards quickly by simply entering text
    in a text field on the main screen.

  o There are no explicit save/load operations, the current
    display reflects the disk file's contents and changes
    are verified and written at the time of the change.

The program uses a disk format identical to xrolo, so if you use
that it should be an easy switch.  A program is supplied to convert
xrolodex files to mrolo, so that's not too hard either.

This software was developed on a Sun4 running SunOS 4.1.1.
It should run on other systems, but it is not tested.

Please send bug reports, feedback, and suggestions
to gregor@kafka.saic.com

Copyright 1993 by gregg hanna.  Permission is granted
to use, modify, and distribute this program.  Basically
do anything you want with it, but if you want to use
it or any part of it to make money you must get further
permission from me.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 2)."
# Contents:  mrolo mrolo/Imakefile mrolo/MRolo.ad mrolo/Makefile.std
#   mrolo/README mrolo/callback.c mrolo/mcard.bm mrolo/mrolo.bm
#   mrolo/mrolo.c mrolo/mrolo.man mrolo/patchlevel.h mrolo/prolo.c
#   mrolo/prolo.man mrolo/rolo.h mrolo/roloP.h mrolo/rolox.c
#   mrolo/rolox.h mrolo/xr2mr mrolo/xr2mr.man
# Wrapped by gregor@asdi on Wed Jun 23 19:55:48 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'mrolo' ; then
    echo shar: Creating directory \"'mrolo'\"
    mkdir 'mrolo'
fi
if test -f 'mrolo/Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/Imakefile'\"
else
echo shar: Extracting \"'mrolo/Imakefile'\" \(490 characters\)
sed "s/^X//" >'mrolo/Imakefile' <<'END_OF_FILE'
XSRCS = callback.c creation.c mrolo.c rolo.c rolox.c
XOBJS = callback.o creation.o mrolo.o rolo.o rolox.o
XLDLIBS = -lXm $(SYSLIBS)
X
XComplexProgramTarget(mrolo)
XInstallAppDefaults(MRolo)
X
Xall:: prolo
X
Xprolo: prolo.c rolo.o
X	$(LINK.c) -o prolo prolo.c rolo.o
X
Xclean::
X	$(RM) prolo xdef
X
XInstallProgram(prolo,$(BINDIR))
XInstallProgram(xr2mr,$(BINDIR))
XInstallManPage(prolo,$(MANDIR))
XInstallManPage(xr2mr,$(MANDIR))
X
Xxdef: MRolo.ad
X	sed -e '1,$$s/^#/!/g' -e '1,$$s/^*/mrolo*/g' MRolo.ad > xdef
X
END_OF_FILE
if test 490 -ne `wc -c <'mrolo/Imakefile'`; then
    echo shar: \"'mrolo/Imakefile'\" unpacked with wrong size!
fi
# end of 'mrolo/Imakefile'
fi
if test -f 'mrolo/MRolo.ad' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/MRolo.ad'\"
else
echo shar: Extracting \"'mrolo/MRolo.ad'\" \(1403 characters\)
sed "s/^X//" >'mrolo/MRolo.ad' <<'END_OF_FILE'
X# fonts:  note that addressList ought to have a fixed width font
X*fontList: -*-helvetica-*-r-*-*-14-*-*-*-*-*-*-*
X*addressList*fontList: -*-fixed-*-r-*-*-14-*-*-*-*-*-*-*
X
X# default size of the comment box on the card info screen
X*commentText.rows: 10
X*commentText.cols: 80
X
X# size of the filter text field
X*filterText.columns:	11
X
X# these control the way buttons look, if you change to
X# XmPACK_TIGHT you probably want to make resizeWidth False
X*XmRowColumn*packing:	XmPACK_COLUMN
X*rowColumn.resizeWidth:	True
X*rowColumn.width:	500
X
X# custom resources, shown here with default values
X*showSecondary:	True
X*sizePrimary:	20
X
X# colors you *might* like
X*foreground:	black
X*background:	white
X*XmPushButton*foreground:	black
X*XmPushButton*background:	pink
X*XmText*foreground:	black
X*XmText*background:	alice blue
X*addressList*foreground:	black
X*addressList*background:	honeydew
X
X# labels
X*quitButton.labelString:	Quit
X*addCardButton.labelString:	Add Card
X*clearButton.labelString:	Clear Filter
X*deleteCardButton.labelString:	Delete Card
X*okButton.labelString:		OK
X*cancelButton.labelString:	Cancel
X*primaryLabel.labelString:	Phone
X*secondaryLabel.labelString:	Phone #2
X*nameLabel.labelString:		Name
X*messageBox.okLabelString:	Yes
X*messageBox.cancelLabelString:	No
X*messageBox.helpLabelString:	Help
X
X# tranversals
X*quitButton.traversalOn:	True
X*addCardButton.traversalOn:	True
X*clearButton.traversalOn:	True
X
END_OF_FILE
if test 1403 -ne `wc -c <'mrolo/MRolo.ad'`; then
    echo shar: \"'mrolo/MRolo.ad'\" unpacked with wrong size!
fi
# end of 'mrolo/MRolo.ad'
fi
if test -f 'mrolo/Makefile.std' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/Makefile.std'\"
else
echo shar: Extracting \"'mrolo/Makefile.std'\" \(731 characters\)
sed "s/^X//" >'mrolo/Makefile.std' <<'END_OF_FILE'
XCFLAGS = -O -D_NO_PROTO
XBINDIR = /usr/bin/X11
XAPPDIR = /usr/lib/X11/app-defaults
XMANDIR = /usr/man/mann
XMANEXT = n
XLDLIBS = -lXm -lXt -lX11
X
Xall: mrolo prolo
X
Xmrolo: callback.o creation.o mrolo.o rolo.o rolox.o
X	$(COMPILE.c) -o mrolo mrolo.o rolo.o rolox.o creation.o callback.o $(LDLIBS)
X
Xprolo: prolo.c rolo.o
X	$(COMPILE.c) -o prolo prolo.c rolo.o
X
Xxdef: MRolo.ad
X	sed -e '1,$$s/^#/!/g' -e '1,$$s/^*/mrolo*/g' MRolo.ad > xdef
X
Xinstall: all
X	cp mrolo $(BINDIR)
X	cp prolo $(BINDIR)
X	cp xr2mr $(BINDIR)
X	chmod +x $(BINDIR)/xr2mr
X	cp MRolo.ad $(APPDIR)/MRolo
X
Xinstall.man:
X	cp mrolo.man $(MANDIR)/mrolo.$(MANEXT)
X	cp prolo.man $(MANDIR)/prolo.$(MANEXT)
X	cp xr2mr.man $(MANDIR)/xr2mr.$(MANEXT)
X
Xclean:
X	$(RM) *.o prolo mrolo xdef *~
X
END_OF_FILE
if test 731 -ne `wc -c <'mrolo/Makefile.std'`; then
    echo shar: \"'mrolo/Makefile.std'\" unpacked with wrong size!
fi
# end of 'mrolo/Makefile.std'
fi
if test -f 'mrolo/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/README'\"
else
echo shar: Extracting \"'mrolo/README'\" \(2114 characters\)
sed "s/^X//" >'mrolo/README' <<'END_OF_FILE'
XMRolo is a Motif based cardfile program.  It was designed to
Xbe as simple as possible, and was born out of frustration with
Xxrolo's and xrolodex's many menus.
X
XSome features of mrolo:
X
X  o From the main screen you see a list of all cards and
X    may scroll through them viewing/editing cards as desired.
X
X  o You may jump to a section of the card file by clicking on
X    a lettered tab on the edge of the screen (A-Z).
X
X  o You can search cards quickly by simply entering text
X    in a text field on the main screen.
X
X  o There are no explicit save/load operations, the current
X    display reflects the disk file's contents and changes
X    are verified and written at the time of the change.
X
XThe program uses a disk format identical to xrolo, so if you use
Xthat it should be an easy switch.  See the manpage for lots of
Xdetails.
X
XThe package contains three programs:
X
X	mrolo - the Motif cardfile program
X	prolo - a program to print the cardfile
X	xr2mr - a script to convert xrolodex files to
X                mrolo/xrolo format
X
XTo compile the programs do as follows:
X
X	xmkmf
X	make
X
XIf you do not have xmkmf or imake, edit and use Makefile.std.
XIf you want to try the program out without installing
Xit then do the following:
X
X	make xdef
X
XThen merge the file xdef with your X defaults.  The file
Xxdef is a slightly massaged version of the MRolo.ad
Xfile.  If you don't already have a .rolo file in your
Xhome directory an empty file will be created for you.
X
XTo install the applications and the app-defaults file:
X
X	make install
X
XTo install the man-page:
X
X	make install.man
X
XIf you hack this program, good luck.  It was originally
Xgenerated with Builder Xcessory, but I changed it quite
Xa bit from that.  You probably want to do a "make depend"
Xbefore changing anything, just to keep 'make' honest.
X
XPlease send bug reports, feedback, and suggestions
Xto gregor@kafka.saic.com
X
XCopyright 1993 by gregg hanna.  Permission is granted
Xto use, modify, and distribute this program.  Basically
Xdo anything you want with it, but if you want to use
Xit or any part of it to make money you must get further
Xpermission from me.
X
END_OF_FILE
if test 2114 -ne `wc -c <'mrolo/README'`; then
    echo shar: \"'mrolo/README'\" unpacked with wrong size!
fi
# end of 'mrolo/README'
fi
if test -f 'mrolo/callback.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/callback.c'\"
else
echo shar: Extracting \"'mrolo/callback.c'\" \(4976 characters\)
sed "s/^X//" >'mrolo/callback.c' <<'END_OF_FILE'
X/* Copyright 1993 by gregg hanna */
X/*
X * Generated by the ICS builderXcessory (BX).
X *
X *
X * Builder Xcessory 1.0.1.
X *
X */
X#include <Xm/Xm.h>
X#include <Xm/Text.h>
X#include "rolo.h"
X
Xint DisplayedCard;
Xint DialogForDelete = 0;
X
X
Xvoid SetDialogDelete()
X{
X  Arg args[1];
X  XmString xmstr;
X  extern Widget MessageBox;
X
X  DialogForDelete = 1;
X
X  xmstr = XmStringCreateSimple("Delete this card?");
X  XtSetArg(args[0],XmNmessageString,xmstr);
X  XtSetValues(MessageBox,args,1);
X
X  XmStringFree(xmstr);
X}
X
Xvoid SetDialogUpdate()
X{
X  Arg args[2];
X  XmString xmstr;
X  extern Widget MessageBox;
X
X  DialogForDelete = 0;
X  
X  xmstr = XmStringCreateSimple("Save changes to this card?");
X  XtSetArg(args[0],XmNmessageString,xmstr);
X  XtSetValues(MessageBox,args,1);
X
X  XmStringFree(xmstr);
X}
X
Xvoid
XActuallyDeleteCard(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call;
X  extern Widget Shell001, Shell002, ListForRolo;
X  void OKCard();
X  Arg arg[1];
X  int n;
X
X  DeleteRoloCard(DisplayedCard);
X  if ( DialogForDelete ) { /* The dialog was a delete dialog */
X    XmListDeletePos(ListForRolo,DisplayedCard+1);
X    WriteRolo();
X  } else {  /* we were using the delete dialog as an update dialog */
X    XtSetArg(arg[0],XmNtopItemPosition,&n);
X    XtGetValues(ListForRolo,arg,1);
X    DisplayedCard = -1;
X    OKCard(NULL,NULL,NULL); /* will re-add this rec and update */
X    XmListSetPos(ListForRolo,n);
X  }
X
X  XtUnmapWidget(Shell001);
X  XtUnmapWidget(Shell002);
X}
X
X
Xvoid
XAddCard(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  extern Widget nameText, numberText, numberText2, commentText, Shell001, deleteCardButton;
X  Arg args[1];
X
X  XmTextSetString(nameText,"");
X  XmTextSetString(numberText,"");
X  XmTextSetString(numberText2,"");
X  XmTextSetString(commentText,"");
X
X  XtSetArg(args[0],XmNsensitive,False);
X  XtSetValues(deleteCardButton,args,1);
X
X  DisplayedCard = -1;
X  
X  XtMapWidget(Shell001);
X}
X
Xvoid
XCancelCard(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  extern Widget Shell001;
X  XtUnmapWidget(Shell001);
X}
X
Xvoid
XDeleteCard(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  extern Widget Shell002;
X  SetDialogDelete();
X  XtMapWidget(Shell002);
X}
X
Xvoid
XDontDeleteCard(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  extern Widget Shell002;
X  XtUnmapWidget(Shell002);
X}
X
Xvoid
XOKCard(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  extern Widget nameText, numberText, numberText2, commentText, Shell002;
X  extern Widget Shell001, ListForRolo;
X  char *a, *b, *c, *d;
X  int same;
X
X  a = XmTextGetString(nameText);
X  b = XmTextGetString(numberText);
X  c = XmTextGetString(commentText);
X  d = XmTextGetString(numberText2);
X
X  if ( DisplayedCard < 0 ) {
X    MakeNewRolo(a,b,d,c);
X    WriteRolo();
X    PutListOnScreen();
X    XtUnmapWidget(Shell001);
X    XmListSetPos(ListForRolo,GetIndex(a)+1);
X  } else {
X    same = ( strcmp(a,GetName(DisplayedCard)) == 0 ) &&
X           ( strcmp(b,GetNumber(DisplayedCard)) == 0 ) &&
X           ( strcmp(d,GetNumber2(DisplayedCard)) == 0 ) &&
X           ( strcmp(c,GetText(DisplayedCard)) == 0 );
X    if ( ! same ) {
X      SetDialogUpdate();
X      XtMapWidget(Shell002);
X    } else {
X      XtUnmapWidget(Shell001);
X    }
X  }
X}
X
Xvoid
XQuitProg(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  exit(0);
X}
X
Xvoid
XSelected(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  XmListCallbackStruct *list=(XmListCallbackStruct*)call;
X  extern Widget nameText, numberText, numberText2, commentText, Shell001, deleteCardButton;
X  extern Widget filterText;
X  Arg args[1];
X  char *s;
X  int n;
X
X  n = list->item_position - 1;
X  if ( n < 0 ) return;
X
X  XmProcessTraversal(filterText,XmTRAVERSE_CURRENT);
X
X  s = GetName(n);
X  XmTextSetString(nameText,s);
X  s = GetNumber(n);
X  XmTextSetString(numberText,s);
X  s = GetNumber2(n);
X  XmTextSetString(numberText2,s);
X  s = GetText(n);
X  XmTextSetString(commentText,s);
X
X  XtSetArg(args[0],XmNsensitive,True);
X  XtSetValues(deleteCardButton,args,1);
X
X  DisplayedCard = n;
X  
X  XtMapWidget(Shell001);
X}
X
Xvoid
XSpinRolo(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  XmListCallbackStruct *list=(XmListCallbackStruct*)call;
X  extern Widget ListForRolo;
X  char A[2];
X  int n;
X
X  A[0] = (char)((list->item_position) + (int)'A' - 1);
X  A[1] = '\0';
X  n = GetIndex(A);
X  XmListSetPos(ListForRolo,n+1);
X}
X
X
Xvoid ChangeFilter(w, client, call)
X     Widget w;
X     caddr_t client;
X     caddr_t call;
X{
X  XmAnyCallbackStruct *acs=(XmAnyCallbackStruct*)call;
X  char *s;
X  
X  s = XmTextGetString(w);
X  RoloFilter(s);
X  PutListOnScreen();
X}
X
Xvoid ClearFilter(w, client, call)
X     Widget w;
X     caddr_t client;
X     caddr_t call;
X{
X  extern Widget filterText;
X
X  XmTextSetString(filterText,"");
X  RoloFilter(NULL);
X  PutListOnScreen();
X}
X
Xvoid ReturnHit(w, client, call)
X     Widget w;
X     caddr_t client;
X     caddr_t call;
X{
X  XmProcessTraversal(w,XmTRAVERSE_NEXT_TAB_GROUP);
X}
X
END_OF_FILE
if test 4976 -ne `wc -c <'mrolo/callback.c'`; then
    echo shar: \"'mrolo/callback.c'\" unpacked with wrong size!
fi
# end of 'mrolo/callback.c'
fi
if test -f 'mrolo/mcard.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/mcard.bm'\"
else
echo shar: Extracting \"'mrolo/mcard.bm'\" \(1877 characters\)
sed "s/^X//" >'mrolo/mcard.bm' <<'END_OF_FILE'
X#define mcard_width 48
X#define mcard_height 48
Xstatic char mcard_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x3f,
X   0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20,
X   0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0xfc, 0xff, 0xff, 0xff, 0x0f, 0x20,
X   0x04, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20,
X   0x04, 0x00, 0x1e, 0x00, 0x01, 0x20, 0x04, 0x00, 0x22, 0x00, 0x01, 0x20,
X   0x04, 0x00, 0x22, 0x00, 0x01, 0x20, 0x04, 0x00, 0x22, 0x00, 0x01, 0x20,
X   0x84, 0x1b, 0x12, 0x0c, 0x61, 0x20, 0x84, 0x24, 0x0e, 0x12, 0x91, 0x20,
X   0x84, 0x24, 0x12, 0x21, 0x09, 0x21, 0x84, 0x24, 0x22, 0x21, 0x09, 0x21,
X   0x84, 0x24, 0x22, 0x21, 0x09, 0x21, 0x84, 0x24, 0x22, 0x12, 0x91, 0x20,
X   0x84, 0x24, 0x22, 0x0c, 0x61, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20,
X   0x04, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20,
X   0x04, 0x1c, 0x00, 0x00, 0x38, 0x20, 0x04, 0x08, 0x00, 0x00, 0x10, 0x20,
X   0xfc, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1877 -ne `wc -c <'mrolo/mcard.bm'`; then
    echo shar: \"'mrolo/mcard.bm'\" unpacked with wrong size!
fi
# end of 'mrolo/mcard.bm'
fi
if test -f 'mrolo/mrolo.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/mrolo.bm'\"
else
echo shar: Extracting \"'mrolo/mrolo.bm'\" \(1877 characters\)
sed "s/^X//" >'mrolo/mrolo.bm' <<'END_OF_FILE'
X#define mrolo_width 48
X#define mrolo_height 48
Xstatic char mrolo_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x3f,
X   0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20,
X   0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0xfc, 0xff, 0xff, 0xff, 0x0f, 0x20,
X   0x04, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20,
X   0x04, 0x00, 0x1e, 0x00, 0x01, 0x20, 0x04, 0x00, 0x22, 0x00, 0x01, 0x20,
X   0x04, 0x00, 0x22, 0x00, 0x01, 0x20, 0x04, 0x00, 0x22, 0x00, 0x01, 0x20,
X   0x84, 0x1b, 0x12, 0x0c, 0x61, 0x20, 0x84, 0x24, 0x0e, 0x12, 0x91, 0x20,
X   0x84, 0x24, 0x12, 0x21, 0x09, 0x21, 0x84, 0x24, 0x22, 0x21, 0x09, 0x21,
X   0x84, 0x24, 0x22, 0x21, 0x09, 0x21, 0x84, 0x24, 0x22, 0x12, 0x91, 0x20,
X   0x84, 0x24, 0x22, 0x0c, 0x61, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20,
X   0x04, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20,
X   0x04, 0x1c, 0x00, 0x00, 0x38, 0x20, 0x04, 0x08, 0x00, 0x00, 0x10, 0x20,
X   0xfc, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x08, 0x00, 0x00, 0x10, 0x00,
X   0xfc, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x04, 0x08, 0x00, 0x00, 0x10, 0x20,
X   0x04, 0x1c, 0x00, 0x00, 0x38, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20,
X   0x04, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20,
X   0x04, 0x00, 0x00, 0x00, 0x00, 0x20, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20,
X   0xfc, 0xff, 0xff, 0xff, 0x0f, 0x20, 0x04, 0x00, 0x00, 0x00, 0x08, 0x20,
X   0xfc, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x04, 0x00, 0x00, 0x00, 0x08, 0x20,
X   0xfc, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20,
X   0x00, 0x00, 0x00, 0x00, 0xf8, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 1877 -ne `wc -c <'mrolo/mrolo.bm'`; then
    echo shar: \"'mrolo/mrolo.bm'\" unpacked with wrong size!
fi
# end of 'mrolo/mrolo.bm'
fi
if test -f 'mrolo/mrolo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/mrolo.c'\"
else
echo shar: Extracting \"'mrolo/mrolo.c'\" \(3587 characters\)
sed "s/^X//" >'mrolo/mrolo.c' <<'END_OF_FILE'
X/* Copyright 1993 by gregg hanna */
X/*
X * Generated by the ICS builderXcessory (BX).
X *
X *
X * Builder Xcessory 1.0.1.
X *
X */
X/*
X * REQUIRED MOTIF INCLUDE FILES
X */
X#include <Xm/Xm.h>
X#include <X11/Shell.h>
X#include <Xm/DialogS.h>
X#include <X11/StringDefs.h>
X
X/* GLOBAL WIDGET VARIABLES */
XWidget Shell000;
XWidget Form;
XWidget Createform();
XWidget Shell001;
XWidget Form1;
XWidget Createform1();
XWidget Shell002;
XWidget MessageBox;
XWidget CreatemessageBox();
X
Xvoid dumpcore(){char *s; s = 0; *s = 'x'; }
X
X#include "mrolo.bm"
X#include "mcard.bm"
X
Xtypedef struct {
X  Boolean showSecondary;
X  int     sizePrimary;
X} mroloAppResources, *mroloAppResourcesP;
X
X#define MOffset(x) XtOffset(mroloAppResourcesP, x)
X
Xstatic XtResource resources[] = {
X  {"showSecondary", "ShowSecondary", XtRBoolean, sizeof(Boolean),
X     MOffset(showSecondary), XtRImmediate, (XtPointer) True},
X  {"sizePrimary", "SizePrimary", XtRInt, sizeof(int),
X     MOffset(sizePrimary), XtRImmediate, (XtPointer) 20},
X};
X
XBoolean showSecondary;
Xint sizePrimary;
X
Xvoid SetResources(w)
X   Widget  w;
X{
X  mroloAppResources appResources;
X  XtGetApplicationResources(w, (XtPointer) &appResources,
X            resources, XtNumber(resources), NULL, 0);
X  showSecondary = appResources.showSecondary;
X  sizePrimary = appResources.sizePrimary;
X}
X
Xvoid SetIcon(w)
X	Widget w;
X{
X  Pixmap p;
X  Arg arg[1];
X
X  p = XCreateBitmapFromData(XtDisplay(w),XtWindow(w),mrolo_bits,mrolo_width,mrolo_height);
X  XtSetArg(arg[0],XmNiconPixmap,p);
X  XtSetValues(w,arg,1);
X}
X
Xvoid SetIcon2(w)
X	Widget w;
X{
X  Pixmap p;
X  Arg arg[1];
X
X  p = XCreateBitmapFromData(XtDisplay(w),XtWindow(w),mcard_bits,mcard_width,mcard_height);
X  XtSetArg(arg[0],XmNiconPixmap,p);
X  XtSetValues(w,arg,1);
X}
X
X#define APP_NAME "mrolo"
X
X/* MAIN PROGRAM */
Xmain(argc, argv)
Xint argc;
Xchar **argv;
X{
X    Display *display;
X    Arg 	args[256];
X    int 	argcnt;
X    XtAppContext context;
X    extern Widget filterText;
X
X    InitRolo(argc,argv,1);
X    SetupRolo();
X
X    XtToolkitInitialize();
X    context = XtCreateApplicationContext();
X    display = XtOpenDisplay(context, 0, "mrolo", "MRolo",
X        0, 0, &argc, argv);
X    if(display == NULL)
X    {
X	XtWarning("cannot open display");
X	exit(1);
X    }
X    XmRegisterConverters();
X    argcnt = 0;
X    XtSetArg(args[argcnt], XmNtitle, "Rolodex"); argcnt++;
X    Shell000 = XtAppCreateShell( APP_NAME, "MRolo",
X        applicationShellWidgetClass, display, args, argcnt);
X    argcnt = 0;
X    XtSetArg(args[argcnt], XmNmappedWhenManaged, False); argcnt++;
X    XtSetArg(args[argcnt], XmNtitle, "Card View"); argcnt++;
X    Shell001 = XtAppCreateShell( APP_NAME, "MRolo",
X        applicationShellWidgetClass, display, args, argcnt);
X    argcnt = 0;
X    XtSetArg(args[argcnt], XmNmappedWhenManaged, False); argcnt++;
X    XtSetArg(args[argcnt], XmNtitle, "Confirmation Dialog"); argcnt++;
X    Shell002 = XtAppCreateShell( APP_NAME, "MRolo",
X        applicationShellWidgetClass, display, args, argcnt);
X    Form = Createform(Shell000);
X    XtManageChild(Form);
X    Form1 = Createform1(Shell001);
X    XtManageChild(Form1);
X    MessageBox = CreatemessageBox(Shell002);
X    XtManageChild(MessageBox);
X    XtRealizeWidget(Shell000);
X    XtRealizeWidget(Shell001);
X    XtRealizeWidget(Shell002);
X
X    SetResources(Shell000);
X
X    SetIcon(Shell000);
X    SetIcon2(Shell001);
X    SetIcon(Shell002);
X
X    PutListOnScreen();
X
X    XmProcessTraversal(filterText,XmTRAVERSE_CURRENT);
X
X    XtAppMainLoop(context);
X
X    /* Note:  Shell000 is main selection window,
X     *        Shell001 is the card display,
X     *        Shell002 is the confirm box.
X     */
X}
END_OF_FILE
if test 3587 -ne `wc -c <'mrolo/mrolo.c'`; then
    echo shar: \"'mrolo/mrolo.c'\" unpacked with wrong size!
fi
# end of 'mrolo/mrolo.c'
fi
if test -f 'mrolo/mrolo.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/mrolo.man'\"
else
echo shar: Extracting \"'mrolo/mrolo.man'\" \(6456 characters\)
sed "s/^X//" >'mrolo/mrolo.man' <<'END_OF_FILE'
X.TH mrolo L "19 April 1993"
X.SH NAME
Xmrolo \- Motif-based card file manager
X.SH SYNOPSIS
X.B mrolo
X[
X.B -h
X] [
X.B -f filename
X]
X.SH DESCRIPTION
X.LP
X.I MRolo
Xis a program for maintaining a simple cardfile,
Xspecifically oriented for saving address-book
Xinformation.
X.LP
XThe default database file read is
X.IR $HOME/.rolo ,
Xalthough this can be overridden with the
X.B ROLODEX
Xenvironment variable or the
X.B -f
Xcommand-line argument.
XIf the file does not exist, it is created empty.
XThe database is stored in a format similar to that of the
X.I xrolo
Xprogram:  Blocks of text separated by lines containing just
Xa ctrl-L.  In addition,
X.I MRolo
Xassumes that the first line in a block is the primary name,
Xthe second line is the primary number, the third line
Xis a secondary number, and the rest is for other names,
Xnumbers, and comments.  (You don't need
Xto understand the file format to use
X.IR MRolo .)
X.LP
XWhen invoked
X.I MRolo
Xwill present the user with a screen summarizing the database.
XThe user may scroll through the summary with the scroll-bar,
Xor they may click on one of the large letters along the left
Xedge of the window and jump right to that part of the database.
XSelecting an individual summary entry
Xwill display a window containing the full information of
Xthat entry, ready for editing or viewing.
X.LP
XOn the main
X.I MRolo
Xscreen there are three buttons and a text field.
XThe three buttons are as follows:
X.TP 2
X.B Quit
XExit the
X.I MRolo
Xprogram immediately.
X.TP 2
X.B "Add Card"
XDisplay a blank detail window, into which new card information
Xmay be entered.
X.TP 2
X.B "Clear Filter"
XClear the selection filter, as described in the next paragraph.
X.LP
XTyping some text in the text field and pressing
X.I return
Xwill limit the summary display to only those cards which contain
Xthat text somewhere in their entry (the entire entry,
Xnot just the summary).  All of the cards are still in the database,
Xthey just aren't all accessible.  To see all of the cards again,
Xdelete all the text from the text field and press
X.I return
Xor just press the
X.B "Clear Filter"
Xbutton.
X.LP
XAny time you change a card, add a new card, or delete a card
X(by pressing "Delete Card" on the detail screen), you will
Xbe asked before the data is written to the disk.  You never
Xhave to explicitly save the database, it is done by validating
Xthe individual changes.  Likewise the screen always reflects
Xthe current contents of the database, except when a filter has
Xbeen applied thus hiding some of the database from view.
X.LP
XThere is a companion program for printing your card file called
X.I prolo
Xand a program to convert
X.I xrolodex
Xcard files to
X.I mrolo
Xformat called
X.IR xr2mr .
XThese programs are documented separately.
X.SH OPTIONS
X.TP
X.B \-f filename
XRun using the specified file as the default database.
X.SH ADVANCED TECHNIQUES
X.LP
XIf you like using
X.I mrolo
Xthen there are some "advanced" techniques you might
Xwant to know about.  These tricks allow you to
Xget more power and flexibility out of the simple
X.I mrolo
Xinterface.
X.LP
XRemember that everything is optional and the program doesn't
Xcare what is where.  You can put text in the slots traditionally
Xused for phone numbers, so if there is no secondary number some
Xadditional descriptive text can go there.
X.LP
XWhile the program was developed for an address book, exploit
Xit for whatever you need, for example record or video collection
Xdatabases would work well.
X.LP
XYou can simulate having several address books by including codes
Xin the comment section of the cards.  For example, I use
Xthe code "~p" for personal entries, and "~w" for work
Xrelated entries.
XIf I want to see just work entries I can
Xenter "~w" in the filter.
XNote that cards can appear in multiple lists by including
Xall applicable codes:  for example, Karen's entry has a "~p~w"
Xcode since she is my friend and I work with her.
X.LP
XPeople who use
X.I mrolo
Xalot will want to know about
X.IR prolo ,
Xwhich is used for printing card file databases.  Once you
Xknow how this program works (see the manpage for
X.IR prolo )
Xyou can optimize your entries to look better on paper.
X.SH XDEFAULTS
X.LP
XThere are a number of values you may wish to tweek in your
XX-Defaults.  Look at the app defaults file for a more complete
Xlist than is given here.
X.TP
Xmrolo*showSecondary
XIf set to True (the default) the main screen will
Xshow both primary and secondary numbers, if False
Xonly the primary number will be shown.  This does
Xnot affect the card screen or the file format.
X.TP
Xmrolo*sizePrimary
XIf showSecondary is True then this resource defines
Xhow wide the column containing the primary number
Xis.  The default is 20 characters.
X.TP
Xmrolo*fontList
XThe default font for everything in
X.IR mrolo .
X.TP
Xmrolo*addressList*fontList
XFont used in address list on main screen.  This
Xshould be a fixed width font if you want the
Xcolumns to line up.
X.TP
Xmrolo*commentText.rows and mrolo*commentText.cols
XThe default size of the card text area.  You can
Xscroll beyond this size or resize the window,
Xbut you might want to change this if you have alot
Xof extremely large cards.
X.TP
Xmrolo*filterText.columns
XThis is the size of the text field on the main screen.
X.TP
Xmrolo*{various}.foreground and mrolo*{various}.background
XChange the colors to suit your tastes; some
Xgood values for {various} are:
Xnothing (default colors for application),
XXmPushButton (all buttons),
XXmText (all text fields),
XaddressList (main screen).
X.TP
Xmrolo*XmRowColumn*packing
XIf you like your buttons only as big as the text they
Xhold, try XmPACK_TIGHT here.  If you do that, you will
Xwant to do the following also...
X.TP
Xmrolo*rowColumn*resizeWidth and mrolo*rowColumn*width
XExplicitly set the width of the main screen, it usually
Xdefaults to size based on the buttons and input field
Xon the main screen.
X.SH FILES
X.TP 20
X.B ~/.rolo
XDefault database.
X.SH ENVIRONMENT
X.TP 20
XROLODEX
XDefault database, overrides ~/.rolo, but not the -f option.
X.SH "SEE ALSO"
X.PD
X.BR xr2mr (1),
X.BR prolo (1),
X.BR xrolo (1)
X.br
X.ne 5
X.SH BUGS
X.LP
XNone known.  Report bugs to gregor@kafka.saic.com
X.SH AUTHOR
X.nf
X.LP
Xgregg hanna (gregor@kafka.saic.com)
XScience Applications International Corporation
X10260 Campus Point Drive, MS C3
XSan Diego, California  92121
X.fi
X.LP
XCopyright 1993 by gregg hanna.  Permission is granted
Xto use, modify, and distribute this program.  Basically
Xdo anything you want with it, but if you want to use
Xit or any part of it to make money you must get further
Xpermission from me.
X
X
END_OF_FILE
if test 6456 -ne `wc -c <'mrolo/mrolo.man'`; then
    echo shar: \"'mrolo/mrolo.man'\" unpacked with wrong size!
fi
# end of 'mrolo/mrolo.man'
fi
if test -f 'mrolo/patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/patchlevel.h'\"
else
echo shar: Extracting \"'mrolo/patchlevel.h'\" \(21 characters\)
sed "s/^X//" >'mrolo/patchlevel.h' <<'END_OF_FILE'
X#define PATCHLEVEL 0
END_OF_FILE
if test 21 -ne `wc -c <'mrolo/patchlevel.h'`; then
    echo shar: \"'mrolo/patchlevel.h'\" unpacked with wrong size!
fi
# end of 'mrolo/patchlevel.h'
fi
if test -f 'mrolo/prolo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/prolo.c'\"
else
echo shar: Extracting \"'mrolo/prolo.c'\" \(6520 characters\)
sed "s/^X//" >'mrolo/prolo.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include "rolo.h"
X#include "roloP.h"
X
Xint complines(rr)
X	RoloRec *rr;
X{
X  int n;
X  char *s;
X  for ( n = 1, s = rr->text; *s != '\0'; s++ )
X    if ( *s == '\n' ) n++;
X  if ( s != rr->text )
X    if ( *(s-1) != '\n' ) n++;
X  return n;
X}
X
Xint box, equal, fontsize, card;
Xchar *filtertext;
X
Xvoid InitProlo(argc,argv)
X     int argc;
X     char *argv[];
X{
X  int c, n;
X  char buf[255];
X  extern char *optarg;
X
X  box = equal = card = 0;
X  filtertext = NULL;
X  fontsize = 5;
X
X  while ((c = getopt(argc, argv, "cf:beF:hs:")) != -1) {
X    switch (c) {
X    case 'c':
X      card = 1;
X      break;
X    case 'f':
X      sprintf(buf,"ROLODEX=%s",optarg);
X      putenv(buf);
X      break;
X    case 'b':
X      box = 1;
X      break;
X    case 'e':
X      equal = 1;
X      break;
X    case 'F':
X      filtertext = optarg;
X      break;
X    case 'h':
X      fprintf(stderr,"%s [-c] [-b] [-e] [-F filtertext] [-h] [-f rolofile] [-s fontsize]\n",argv[0]);
X      exit(1);
X      break;
X    case 's':
X      n = sscanf(optarg,"%d",&fontsize);
X      if ( n == 0 ) fontsize = 5;
X      break;
X    }
X  }
X}
X
Xmain(argc,argv)
X     int argc;
X     char *argv[];
X{
X  char *text;
X  RoloRec *rr;
X  int high, height;
X
X  InitProlo(argc,argv);
X  InitRolo(argc,argv,0);
X  SetupRolo();
X
X  RoloFilter(filtertext);
X
X  /* find tallest entry */
X  high = 0;
X  for ( rr = RoloList; rr != NULL; rr = rr->next ) {
X    if ( ! rr->on ) continue;
X    height = complines(rr);
X    if ( height > high ) high = height;
X  }
X
X  printf("%%!\n\n");
X  printf("\n%% user parameters:  feel free to change the following parameters\n");
X  printf("/fontsize %d def  %% size for font, play with this!\n",fontsize);
X  printf("/equalbox %d def  %% if 1, put each entry in equal sized boxes\n",equal);
X  printf("/boxmode %d def   %% if 1, draw boxes around each entry\n",box);
X  printf("/cardinfo %d def  %% if 1, print card contents\n",card);
X  printf("\n%% other parameters\n");
X  printf("/ystart 750 def\n");
X  printf("/xwidth 525 def\n");
X  printf("/tallest %d def   %% tallest entry in # of lines\n",high);
X  printf("cardinfo 0 eq { /tallest 1 def } if\n");
X  printf("0.1 setlinewidth\n");
X  printf("/Times-Roman findfont fontsize scalefont setfont\n");
X  printf("/mw 0 def\n");
X  printf("/mw2 0 def\n\n");
X  printf("/mw3 0 def\n\n");
X  printf("/mw4 0 def\n\n");
X
X  printf("\n%% define procedures\n");
X  printf("/newpage { showpage fontsize 5 mul 750 moveto } def\n");
X  printf("/movecol { currentpoint pop mw add mw2 add ystart moveto } def\n");
X  printf("\n/newcol {  %% shift to a new column, if no more columns shift to new page\n");
X  printf("  movecol\n");
X  printf("  currentpoint pop mw2 add\n");
X  printf("  xwidth gt { newpage } if\n");
X  printf("} def\n");
X
X  printf("\n/checkloc {  %% given # of lines, check if we can fit in this column\n");
X  printf("  equalbox 1 eq { pop tallest } if  %% if in equal box mode, ignore # lines tall\n");
X  printf("  height mul 100 add      %% projected location after next printing (with padding)\n");
X  printf("  currentpoint exch pop   %% space left in column\n");
X  printf("  gt { newcol } if        %% if it won't fit, start new column\n");
X  printf("} def\n");
X
X  printf("\n/boxit {  %% given # of lines, draw a box mw+mw2 wide and # lines tall\n");
X  printf("  boxmode 1 eq {\n");
X  printf("    equalbox 1 eq { pop tallest } if  %% if in equal box mode, ignore # lines tall\n");
X  printf("    gsave\n");
X  printf("      currentpoint\n");
X  printf("      newpath\n");
X  printf("        exch 1 sub exch height sub 1 sub moveto\n");
X  printf("        height mul\n");
X  printf("        dup 0 exch rlineto\n");
X  printf("        mw mw2 add 0 rlineto\n");
X  printf("        neg 0 exch rlineto\n");
X  printf("      closepath\n");
X  printf("      stroke\n");
X  printf("    grestore\n");
X  printf("  } if\n");
X  printf("} def\n");
X
X  printf("\n/fixloc { %% # of lines just printed, adjust for equalbox\n");
X  printf("  equalbox 1 eq {\n");
X  printf("    height mul neg vjump add  %% compute how much farther down we need to go\n");
X  printf("    0 exch rmoveto\n");
X  printf("  } if\n");
X  printf("} def\n");
X
X  printf("\n");
X  printf("/sizestr { stringwidth /h exch def /w exch def } def\n");
X  printf("/chmax { w mw gt { /mw w def } if } def\n");
X  printf("/chmax2 { w mw2 gt { /mw2 w def } if } def\n");
X  printf("/chmax3 { w mw3 gt { /mw3 w def } if } def\n");
X  printf("/chmax4 { w mw4 gt { /mw4 w def } if } def\n");
X  printf("/nshow { dup show sizestr mw w sub 0 rmoveto } def\n");
X  printf("/tshow { cardinfo 1 eq { dup show sizestr w neg height rmoveto } if } def\n");
X  printf("/pshow1 { dup show sizestr mw3 w sub 0 rmoveto } def\n");
X  printf("/pshow2 { dup show sizestr mw3 w add neg height rmoveto } def\n");
X  printf("/height fontsize neg def\n");
X  printf("/vjump height tallest mul def\n");
X
X  printf("\n%% find widest entry\n");
X  for ( rr = RoloList; rr != NULL; rr = rr->next )
X    if ( rr->on ) printf("(%s) sizestr chmax\n",rr->name);
X
X  printf("/mw mw fontsize add def\n");
X
X  printf("\n%% find widest text\n");
X  for ( rr = RoloList; rr != NULL; rr = rr->next ) {
X    if ( ! rr->on ) continue;
X    text = rr->text;
X    while ( *text != '\0' ) {
X      printf("(");
X      while (*text != '\n' && *text != '\0') putc(*text++,stdout);
X      printf(") sizestr chmax2\n");
X      if ( *text != '\0' ) text++;
X    }
X  }
X
X  printf("\n%% find widest primary number\n");
X  for ( rr = RoloList; rr != NULL; rr = rr->next ) {
X    if ( ! rr->on ) continue;
X    printf("(%s) sizestr chmax3\n",rr->number);
X  }
X
X  printf("/mw3 mw3 fontsize add def\n");
X
X  printf("\n%% find widest secondary number\n");
X  for ( rr = RoloList; rr != NULL; rr = rr->next ) {
X    if ( ! rr->on ) continue;
X    printf("(%s) sizestr chmax4\n",rr->number2);
X  }
X
X  printf("mw3 mw4 add mw2 gt { /mw2 mw3 mw4 add def } if\n");
X
X  printf("/mw2 mw2 fontsize add def\n");
X
X  printf("\n%% setup and print\n");
X  printf("fontsize 5 mul 750 moveto\n");
X
X  for ( rr = RoloList; rr != NULL; rr = rr->next ) {
X    if ( ! rr->on ) continue;
X    height = complines(rr);
X    printf("%d checkloc\n",height);
X    printf("%d boxit\n",height);
X    printf("(%s) nshow\n",rr->name);
X    printf("(%s) pshow1\n",rr->number);
X    printf("(%s) pshow2\n",rr->number2);
X    text = rr->text;
X    while ( *text != '\0' ) {
X      printf("(");
X      while (*text != '\n' && *text != '\0') putc(*text++,stdout);
X      printf(") tshow\n");
X      if ( *text != '\0' ) text++;
X    }
X    printf("mw neg 0 rmoveto\n");
X    printf("%d fixloc\n",height);
X  }
X
X  printf("showpage\n");
X}
X
END_OF_FILE
if test 6520 -ne `wc -c <'mrolo/prolo.c'`; then
    echo shar: \"'mrolo/prolo.c'\" unpacked with wrong size!
fi
# end of 'mrolo/prolo.c'
fi
if test -f 'mrolo/prolo.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/prolo.man'\"
else
echo shar: Extracting \"'mrolo/prolo.man'\" \(3489 characters\)
sed "s/^X//" >'mrolo/prolo.man' <<'END_OF_FILE'
X.TH prolo L "13 May 1993"
X.SH NAME
Xprolo \- card file database printer
X.SH SYNOPSIS
X.B prolo
X[
X.B \-cbeh
X] [
X.B \-F filtertext
X] [
X.B \-f rolofile
X] [
X.B \-f fontsize
X]
X.SH DESCRIPTION
X.LP
X.I PRolo
Xis a program for printing a simple cardfile,
Xgenerating PostScript output.
X.LP
XThe default database file read is
X.IR $HOME/.rolo ,
Xalthough this can be overridden with the
X.B ROLODEX
Xenvironment variable or the
X.B -f
Xcommand-line argument.
XIf the file does not exist, it is created empty.
XThe database is assumed to be in the format of
Xthe
X.I mrolo
Xor
X.I xrolo
Xprograms.
X.LP
XThe output will be a PostScript program.  Most of the options
Xset from the command line can also be set by editing this
Xprogram before printing.  The basic, unchangeable format
Xfor the individual records is:
X.nf
XFirst Line  Second Line  Third Line
X            Fourth Line
X            Fifth Line
X              .
X              .
X              .
X.fi
X.LP
XWhen used with
X.I mrolo
XThe first line is usually a name, the second the primary
Xphone number, the third the secondary phone number,
Xand others are descriptive text (address, other
Xnumbers, etc.).  The PostScript program will organize these
Xentries in columns and the columns into pages, if needed.
X.LP
XNote that lines are sized and spaced based on the largest
Xentries, so you might want to edit your cardfile to have
Xfairly consistent field lengths.  For example, if you use
Xthe secondary number to store a very long string or
Xhave one name which is particularly long then 
X.B all
Xof the
Xprinted entries will be very wide.
X.SH OPTIONS
X.TP
X.B \-c
XInclude card info, by default only name, primary and secondary
Xnumbers are printed.
X.TP
X.B \-b
XDraw a box around each entry.
X.TP
X.B \-e
XMake all entries the same size.  Each entry will take up
Xas much space as the largest entry, using more space
Xbut looking neat and tidy.  This only makes sense with
Xthe -c option.
X.TP
X.B \-F filertext
XOnly emit entries which contain
X.I filtertext
Xsomewhere in the entry.  This option cannot be changed
Xin the PostScript program, it must be specified on
Xthe command line.
X.TP
X.B \-f filename
XRun using the specified file as the default database.
XThis option cannot be changed in the PostScript program,
Xit must be specified on the command line.
X.TP
X.B \-s fontsize
XThe font size used to print the entries.  The default is 5
X(small for pocket lists).
X
X.SH POSTSCRIPT OPTIONS
X.LP
XMost of the command-line options (the exceptions are noted above)
Xcan be changed and played with in the output file.  Each option
Xhas a corresponding variable set at the beginning of the PostScript,
Xthe following table describes the mappings:
X.TP
X.B -c
Xcardinfo
X.TP
X.B -b
Xboxmode
X.TP
X.B -e
Xequalbox
X.TP
X.B -s
Xfontsize
X
X.SH FILES
X.TP 20
X.B ~/.rolo
XDefault database.
X.SH ENVIRONMENT
X.TP 20
XROLODEX
XDefault database, overrides ~/.rolo, but not the -f option.
X.SH "SEE ALSO"
X.PD
X.BR xrolo (1),
X.BR mrolo (1)
X.br
X.ne 5
X.SH BUGS
X.LP
XThis program makes assumptions about the size of the
Xoutput paper.  It was developed for 8.5x11 paper, your milage
Xmay vary.
X.LP
XReport bugs to gregor@kafka.saic.com
X.SH AUTHOR
X.nf
X.LP
Xgregg hanna (gregor@kafka.saic.com)
XScience Applications International Corporation
X10260 Campus Point Drive, MS C3
XSan Diego, California  92121
X.fi
X.LP
XCopyright 1993 by gregg hanna.  Permission is granted
Xto use, modify, and distribute this program.  Basically
Xdo anything you want with it, but if you want to use
Xit or any part of it to make money you must get further
Xpermission from me.
X
X
END_OF_FILE
if test 3489 -ne `wc -c <'mrolo/prolo.man'`; then
    echo shar: \"'mrolo/prolo.man'\" unpacked with wrong size!
fi
# end of 'mrolo/prolo.man'
fi
if test -f 'mrolo/rolo.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/rolo.h'\"
else
echo shar: Extracting \"'mrolo/rolo.h'\" \(280 characters\)
sed "s/^X//" >'mrolo/rolo.h' <<'END_OF_FILE'
X#ifndef _ROLO_H
X#define _ROLO_H
X
X#define VERSION_MAJOR 1
X#define VERSION_MINOR 2
X
Xvoid InitRolo();
Xvoid SortRolo();
Xvoid SetupRolo();
Xvoid PutListOnScreen();
Xvoid DeleteRoloCard();
Xvoid WriteRolo();
Xchar *GetName();
Xchar *GetNumber();
Xchar *GetNumber2();
Xchar *GetText();
X
X#endif
END_OF_FILE
if test 280 -ne `wc -c <'mrolo/rolo.h'`; then
    echo shar: \"'mrolo/rolo.h'\" unpacked with wrong size!
fi
# end of 'mrolo/rolo.h'
fi
if test -f 'mrolo/roloP.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/roloP.h'\"
else
echo shar: Extracting \"'mrolo/roloP.h'\" \(228 characters\)
sed "s/^X//" >'mrolo/roloP.h' <<'END_OF_FILE'
X#ifndef _ROLOP_H
X#define _ROLOP_H
X
Xtypedef struct _RoloRec {
X  char *name;
X  char *number;
X  char *number2;
X  char *text;
X  int on;
X  struct _RoloRec *next;
X} RoloRec;
X
X#define BUFSIZE 100000
X
Xextern RoloRec *RoloList;
X
X#endif
X
END_OF_FILE
if test 228 -ne `wc -c <'mrolo/roloP.h'`; then
    echo shar: \"'mrolo/roloP.h'\" unpacked with wrong size!
fi
# end of 'mrolo/roloP.h'
fi
if test -f 'mrolo/rolox.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/rolox.c'\"
else
echo shar: Extracting \"'mrolo/rolox.c'\" \(1114 characters\)
sed "s/^X//" >'mrolo/rolox.c' <<'END_OF_FILE'
X/* Copyright 1993 by gregg hanna */
X#include <stdio.h>
X#include <stdlib.h>
X#include <ctype.h>
X#include <X11/Xos.h>
X#include <Xm/Xm.h>
X#include <Xm/List.h>
X
X#include "patchlevel.h"
X#include "rolo.h"
X#include "roloP.h"
X
Xextern Boolean showSecondary;
Xextern int sizePrimary;
X
Xvoid PutListOnScreen()
X{
X  RoloRec *rr;
X  char buf[500];
X  int n, i;
X  extern Widget ListForRolo;
X  XmString *xmtable;
X
X  n = 0;
X  for ( rr = RoloList; rr != NULL; rr = rr->next )
X    if ( rr->on ) n++;
X
X  xmtable = (XmString*)calloc(n,sizeof(XmString));
X  for ( rr = RoloList, i = 0; rr != NULL; rr = rr->next )
X    if ( rr->on ) {
X      sprintf(buf,"%-30s",rr->name);
X      buf[30] = ' ';
X      if ( showSecondary ) {
X        sprintf(&buf[31],"%-*s",sizePrimary,rr->number);
X        buf[31+sizePrimary] = ' ';
X        strcpy(&buf[31+sizePrimary+1],rr->number2);
X      } else {
X        strcpy(&buf[31],rr->number);
X      }
X      xmtable[i] = XmStringCreateSimple(buf);
X      i++;
X    }
X  XmListDeleteAllItems(ListForRolo);
X  XmListAddItems(ListForRolo,xmtable,n,0);
X  for ( i = 0; i < n; i++ ) XmStringFree(xmtable[i]);
X  free(xmtable);
X}
X
END_OF_FILE
if test 1114 -ne `wc -c <'mrolo/rolox.c'`; then
    echo shar: \"'mrolo/rolox.c'\" unpacked with wrong size!
fi
# end of 'mrolo/rolox.c'
fi
if test -f 'mrolo/rolox.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/rolox.h'\"
else
echo shar: Extracting \"'mrolo/rolox.h'\" \(67 characters\)
sed "s/^X//" >'mrolo/rolox.h' <<'END_OF_FILE'
X#ifndef _ROLOX_H
X#define _ROLOX_H
X
Xvoid PutListOnScreen();
X
X#endif
END_OF_FILE
if test 67 -ne `wc -c <'mrolo/rolox.h'`; then
    echo shar: \"'mrolo/rolox.h'\" unpacked with wrong size!
fi
# end of 'mrolo/rolox.h'
fi
if test -f 'mrolo/xr2mr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/xr2mr'\"
else
echo shar: Extracting \"'mrolo/xr2mr'\" \(60 characters\)
sed "s/^X//" >'mrolo/xr2mr' <<'END_OF_FILE'
X#!/bin/sh
Xsed '1,$s/^####$/\014/g' $1 | tail +2
Xecho "\014"
END_OF_FILE
if test 60 -ne `wc -c <'mrolo/xr2mr'`; then
    echo shar: \"'mrolo/xr2mr'\" unpacked with wrong size!
fi
chmod +x 'mrolo/xr2mr'
# end of 'mrolo/xr2mr'
fi
if test -f 'mrolo/xr2mr.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo/xr2mr.man'\"
else
echo shar: Extracting \"'mrolo/xr2mr.man'\" \(775 characters\)
sed "s/^X//" >'mrolo/xr2mr.man' <<'END_OF_FILE'
X.TH xr2mr L "19 May 1993"
X.SH NAME
Xxr2mr \- Convert xrolodex file to mrolo format
X.SH SYNOPSIS
X.B xr2mr
X[
X.B filename
X]
X.SH DESCRIPTION
X.LP
X.I xr2mr
Xis a UNIX shell script which will read a xrolodex
Xfile and emit on standard output an equivalent
X.I mrolo
Xfile.  If no file is given on the command line
Xthen standard input is used.
X.LP
XThe format for
X.I mrolo
Xis detailed in it's own manpage, but the format
Xis compatible with xrolo.
X.SH EXAMPLE
X.LP
Xxr2mr .rolodex > .rolo
X.SH "SEE ALSO"
X.PD
X.BR mrolo (1),
X.BR prolo (1),
X.BR xrolo (1)
X.br
X.ne 5
X.SH BUGS
X.LP
XNone known.  Report bugs to gregor@kafka.saic.com
X.SH AUTHOR
X.nf
X.LP
Xgregg hanna (gregor@kafka.saic.com)
XScience Applications International Corporation
X10260 Campus Point Drive, MS C3
XSan Diego, California  92121
X.fi
END_OF_FILE
if test 775 -ne `wc -c <'mrolo/xr2mr.man'`; then
    echo shar: \"'mrolo/xr2mr.man'\" unpacked with wrong size!
fi
# end of 'mrolo/xr2mr.man'
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
