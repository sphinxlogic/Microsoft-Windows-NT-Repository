Newsgroups: comp.sources.x
From: vojta@math.berkeley.edu (Paul Vojta)
Subject: v20i054:  xdvi - dvi previewer, Patch16b/2
Message-ID: <1993Jun28.143135.7442@sparky.imd.sterling.com>
X-Md4-Signature: 6f20859709c805548387e297a51bfa2b
Sender: chris@sparky.imd.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Mon, 28 Jun 1993 14:31:35 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: vojta@math.berkeley.edu (Paul Vojta)
Posting-number: Volume 20, Issue 54
Archive-name: xdvi/patch16b
Environment: X10, X11
Patch-To: xdvi: Volume 17, Issue 23-25,27,40-41,53,106-107

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  xdvi.p16.1
# Wrapped by chris@sparky on Mon Jun 28 08:49:45 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 2)."'
if test -f 'xdvi.p16.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xdvi.p16.1'\"
else
  echo shar: Extracting \"'xdvi.p16.1'\" \(44861 characters\)
  sed "s/^X//" >'xdvi.p16.1' <<'END_OF_FILE'
XPrereq: 15
Xdiff -cr xdvi_old/patchlevel.h xdvi_new/patchlevel.h
X*** xdvi_old/patchlevel.h	Tue Jun 16 11:37:36 1992
X--- xdvi_new/patchlevel.h	Tue Aug 25 12:22:44 1992
X***************
X*** 1 ****
X! #define PATCHLEVEL 15
X--- 1 ----
X! #define PATCHLEVEL 16
Xdiff -cr xdvi_old/README xdvi_new/README
X*** xdvi_old/README	Fri Jun 19 13:18:24 1992
X--- xdvi_new/README	Wed Sep 16 17:34:48 1992
X***************
X*** 79,84 ****
X--- 79,85 ----
X  			definition of drawingWidgetClass.
X  	TEXXET		(everything)  Enables op-codes 250 and 251 (used for
X  			right-to-left languages).
X+ 	BDPI		(xdvi.c) Default number of pixels per inch to use.
X  	GREY		(everything)  Use greyscale anti-aliasing for
X  			displaying shrunken bitmaps.
X  	MAKEPK		(font_open.c)  If a font is not found, then try to
X***************
X*** 87,93 ****
X  			correctly for your site, and be sure that the
X  			destination directory for MakeTeXPK appears in your
X  			DEFAULT_FONT_PATH variable.
X! 	MAKEPKCMD=/usr/local/tex/bin/MakeTeXPK (font_open.c)  Same as the
X  			above, but this variant explicitly declares which
X  			command to use to create the font.
X  
X--- 88,94 ----
X  			correctly for your site, and be sure that the
X  			destination directory for MakeTeXPK appears in your
X  			DEFAULT_FONT_PATH variable.
X! 	MAKEPKCMD=\"/usr/local/tex/bin/MakeTeXPK\" (font_open.c)  Same as the
X  			above, but this variant explicitly declares which
X  			command to use to create the font.
X  
X***************
X*** 259,263 ****
X--- 260,268 ----
X     32.  Added support for greyscale anti-aliasing.
X  --  Patchlevel 15: --
X     33.  Added support for MakeTeXPK, as in dvips.
X+ --  Patchlevel 16: --
X+    34.	In the code for greyscale anti-aliasing, try to allocate a colormap
X+ 	so that GXor operations can be used for drawing.  Also interpolate
X+ 	between foreground and background colors.
X  
X  Paul Vojta, vojta@math.berkeley.edu
Xdiff -cr xdvi_old/README.VMS xdvi_new/README.VMS
X*** xdvi_old/README.VMS	Sun Jun  7 22:47:16 1992
X--- xdvi_new/README.VMS	Wed Sep 16 17:19:08 1992
X***************
X*** 10,17 ****
X          [-bw width] [-fg color] [-bg color] [-hl color] [-bd color] [-cr color]
X          [-margins dimen] [-sidemargin dimen] [-topmargin dimen] [-version]
X          [-offsets dimen] [-xoffset dimen] [-yoffset dimen] [-keep] [-nogrey]
X!         [-hushspecials] [-hushchars] [-hush] [-paper papertype] [-mgs[n] size]
X!         [-altfont font] [-thorough] [-copy] [-geometry geometry]
X          [-icongeometry geometry] [-iconic] [-display display] dvi_file
X  
X  DESCRIPTION
X--- 10,17 ----
X          [-bw width] [-fg color] [-bg color] [-hl color] [-bd color] [-cr color]
X          [-margins dimen] [-sidemargin dimen] [-topmargin dimen] [-version]
X          [-offsets dimen] [-xoffset dimen] [-yoffset dimen] [-keep] [-nogrey]
X!         [-gamma g] [-hushspecials] [-hushchars] [-hush] [-paper papertype]
X!         [-mgs[n] size] [-altfont font] [-thorough] [-copy] [-geometry geometry]
X          [-icongeometry geometry] [-iconic] [-display display] dvi_file
X  
X  DESCRIPTION
X***************
X*** 129,140 ****
X                           should not move to the home position when moving to a
X                           new page.  See also the `k' keystroke.
X  
X!    -nogrey               (.grey)  Turns off the use greyscale anti-aliasing
X                           when printing shrunken bitmaps.  In this case, the
X!                          logic of the corresponding resource is the reverse;
X                           -nogrey corresponds to grey:off; +nogrey to grey:on.
X                           See also the 'G' keystroke.
X  
X     -hushspecials         (.hushSpecials)  Causes XDVI to suppress warnings about
X                           \special strings which it cannot process.
X  
X--- 129,148 ----
X                           should not move to the home position when moving to a
X                           new page.  See also the `k' keystroke.
X  
X!    -nogrey               (.grey)  Turns off the use of greyscale anti-aliasing
X                           when printing shrunken bitmaps.  In this case, the
X!                          logic of the corresponding resource is the reverse:
X                           -nogrey corresponds to grey:off; +nogrey to grey:on.
X                           See also the 'G' keystroke.
X  
X+    -gamma <gamma>        (.gamma)  Controls the interpolation of colors in the
X+                          greyscale anti-aliasing color palette.  The default
X+                          value is 1.0.  For 0 < gamma < 1, the fonts will be
X+                          lighter (more like the background), and for gamma > 1,
X+                          the fonts will be darker (more like the foreground).
X+                          Negative values behave the same way, but use a slightly
X+                          different algorithm.
X+ 
X     -hushspecials         (.hushSpecials)  Causes XDVI to suppress warnings about
X                           \special strings which it cannot process.
X  
X***************
X*** 142,148 ****
X                           about references to characters which are not defined in
X                           the font.
X  
X!    -hush                 (.Hush)  Causes XDVI to suppress all suppressable
X                           warnings.
X  
X     -paper <papertype>    (.paper)  Specifies the size of the printed page.  This
X--- 150,156 ----
X                           about references to characters which are not defined in
X                           the font.
X  
X!    -hush                 (.Hush)  Causes XDVI to suppress all suppressible
X                           warnings.
X  
X     -paper <papertype>    (.paper)  Specifies the size of the printed page.  This
X***************
X*** 180,186 ****
X     -copy                 (.copy)  Always use the copy operation when writing
X                           characters to the display.  This option may be
X                           necessary for correct operation on a color display, but
X!                          overstrike characters will be incorrect.
X  
X     -geometry <geometry>  (*geometry)  Specifies the initial geometry of the
X                           window.
X--- 188,197 ----
X     -copy                 (.copy)  Always use the copy operation when writing
X                           characters to the display.  This option may be
X                           necessary for correct operation on a color display, but
X!                          overstrike characters will be incorrect.  If greyscale
X!                          anti-aliasing is in use, the copy operation will
X!                          disable the use of colorplanes and make overstrikes
X!                          come out incorrectly.
X  
X     -geometry <geometry>  (*geometry)  Specifies the initial geometry of the
X                           window.
X***************
X*** 239,245 ****
X          synonym for this keystroke.
X  
X     r    Moves right two thirds of a window-full.  The <Right Arrow> key is a
X!         sysnonym for this keystroke.
X  
X     c    Moves the page so that the point currently beneath the cursor is moved
X          to the middle of the window.  It also (gasp!) warps the cursor to the
X--- 250,256 ----
X          synonym for this keystroke.
X  
X     r    Moves right two thirds of a window-full.  The <Right Arrow> key is a
X!         synonym for this keystroke.
X  
X     c    Moves the page so that the point currently beneath the cursor is moved
X          to the middle of the window.  It also (gasp!) warps the cursor to the
X***************
X*** 311,322 ****
X     (within a certain range), and if this fails, then it will use the font
X     specified as the alternate font (cf. -altfont).
X  
X!    For compatibilty with some versions of TeX, you may also use the logical name
X!    "TEXFONTS" in place of "XDVIFONTS", although in that case the string should
X!    not include any "%" specifiers.  The reason for recognizing "TEXFONTS" is
X!    that certain version of TeX also support the convention regarding an extra
X!    slash in the font path; therefore, users who create their own fonts can put
X!    both their .TFM and raster files in the same directory and do
X  
X          $ DEFINE TEXFONTS "/MFDIR"
X  
X--- 322,333 ----
X     (within a certain range), and if this fails, then it will use the font
X     specified as the alternate font (cf. -altfont).
X  
X!    For compatibility with some versions of TeX, you may also use the logical
X!    name "TEXFONTS" in place of "XDVIFONTS", although in that case the string
X!    should not include any "%" specifiers.  The reason for recognizing "TEXFONTS"
X!    is that certain versions of TeX also support the convention regarding an
X!    extra slash in the font path; therefore, users who create their own fonts can
X!    put both their .TFM and raster files in the same directory and do
X  
X          $ DEFINE TEXFONTS "/MFDIR"
X  
X***************
X*** 330,335 ****
X--- 341,349 ----
X     explicitly, and therefore this feature is not useful, the "XDVIFONTS" logical
X     name be set to an empty string to cause XDVI to ignore "TEXFONTS".
X  
X+    XDVI also recognizes the "PKFONTS" logical name, which is checked after
X+    "XDVIFONTS" but before "TEXFONTS".
X+ 
X     The logical name "XDVISIZES" must be set to indicate which sizes of fonts are
X     available.  It should consist of a list of numbers separated by slashes.  If
X     the list begins with a slash, the system default sizes are used, as well.
X***************
X*** 342,349 ****
X     Virtual fonts are also supported, although XDVI does not have any built-in
X     fonts to which they can refer.  The search path for .VF files can be
X     specified with the "XDVIVFS" logical name in a similar manner to that for the
X!    "XDVIFONTS" logical name.  Virtual fonts are searched for immediately after
X!    looking for the font as a normal font in the exact size specified.
X  
X  FILES
X  -----
X--- 356,365 ----
X     Virtual fonts are also supported, although XDVI does not have any built-in
X     fonts to which they can refer.  The search path for .VF files can be
X     specified with the "XDVIVFS" logical name in a similar manner to that for the
X!    "XDVIFONTS" logical name.  XDVI will also check the "VFFONTS" logical name if
X!    the "XDVIFONTS" logical name is not defined.  Virtual fonts are searched for
X!    immediately after looking for the font as a normal font in the exact size
X!    specified.
X  
X  FILES
X  -----
Xdiff -cr xdvi_old/XDVI.RNH xdvi_new/XDVI.RNH
X*** xdvi_old/XDVI.RNH	Sun Jun  7 22:47:17 1992
X--- xdvi_new/XDVI.RNH	Wed Sep 16 17:19:10 1992
X***************
X*** 10,15 ****
X--- 10,16 ----
X  .! Added new switches for patchlevel 10.  Scott Allendorf.
X  .! Added new switches for patchlevel 11.  Scott Allendorf.
X  .! Added new switches for patchlevel 14.  Scott Allendorf.
X+ .! Added new switches for patchlevel 16.  Scott Allendorf.
X  .!
X  .NO PAGING
X  .NO FLAGS ALL
X***************
X*** 116,122 ****
X  .BREAK
X  Always use the copy operation when writing characters to the display.
X  This option may be necessary for correct operation on a color display,
X! but overstrike characters will be incorrect.
X  .SKIP
X  The resource name is ".copy".
X  .INDENT -1
X--- 117,125 ----
X  .BREAK
X  Always use the copy operation when writing characters to the display.
X  This option may be necessary for correct operation on a color display,
X! but overstrike characters will be incorrect.  If greyscale anti-aliasing
X! is in use, the copy operation will disable the use of colorplanes and make
X! overstrikes come out incorrectly.
X  .SKIP
X  The resource name is ".copy".
X  .INDENT -1
X***************
X*** 161,166 ****
X--- 164,181 ----
X  .SKIP
X  Same as -fg.
X  .INDENT -1
X+ 3 -gamma
X+ .BREAK
X+ -gamma <gamma>
X+ .SKIP
X+ Controls the interpolation of colors in the greyscale anti-aliasing color
X+ palette.  The default value is 1.0.  For 0 < gamma < 1, the fonts will be
X+ lighter (more like the background), and for gamma > 1, the fonts will be darker
X+ (more like the foreground).  Negative values behave the same way, but use a
X+ slightly different algorithm.
X+ .SKIP
X+ The resource name is ".gamma".
X+ .INDENT -1
X  3 -geometry
X  .BREAK
X  -geometry <geometry>
X***************
X*** 179,185 ****
X  .INDENT -1
X  3 -hush
X  .BREAK
X! Causes XDVI to suppress all suppressable warnings.
X  .SKIP
X  The resource name is ".Hush".
X  .INDENT -1
X--- 194,200 ----
X  .INDENT -1
X  3 -hush
X  .BREAK
X! Causes XDVI to suppress all suppressible warnings.
X  .SKIP
X  The resource name is ".Hush".
X  .INDENT -1
X***************
X*** 228,239 ****
X  .SKIP
X  The resource name is ".listFonts".
X  .INDENT -1
X  3 -nogrey
X  .BREAK
X  -nogrey
X  .SKIP
X  Turns off the use of greyscale anti-aliasing when printing shrunken bitmaps.
X! (In this case, the logic of the corresponding resource is the reverse;
X  -nogrey corresponds to grey:off; +nogrey to grey:on).
X  See also 'G' under the Keystrokes help entry.
X  .SKIP
X--- 243,289 ----
X  .SKIP
X  The resource name is ".listFonts".
X  .INDENT -1
X+ 3 -margins
X+ .BREAK
X+ -margins <dimen>
X+ .SKIP
X+ Specifies the size of both the top and side margins.  This should be a
X+ decimal number optionally followed by "cm", e.g., 1.5 or 3cm, giving a
X+ measurement in inches or centimeters.
X+ XDVI determines the "home" position of
X+ the page within the window as follows.  If the entire page fits in the
X+ window, then the margin settings are ignored.  If, even after removing
X+ the margins from the left, right, top, and bottom, the page still
X+ cannot fit in the window, then the page is put in the window such that
X+ the top and left margins are hidden, and presumably the upper
X+ left-hand corner of the text on the page will be in the upper
X+ left-hand corner of the window.  Otherwise, the text is centered in
X+ the window.  See also `M' under the Keystrokes help entry.
X+ .SKIP
X+ The resource name is ".Margin".
X+ .INDENT -1
X+ 3 -mgs[n]
X+ .BREAK
X+ -mgs[n] <size>
X+ .SKIP
X+ Specifies the size of the window to be used for the "magnifying glass"
X+ for Button n.  See the MOUSE ACTIONS section.
X+ Defaults are 200, 350, 600, 900, and 1200.
X+ .SKIP
X+ The resource name is ".magnifierSize[n]".
X+ .INDENT -1
X+ 3 -mgs
X+ .BREAK
X+ -mgs <size>
X+ .SKIP
X+ Same as -mgs1.
X+ .INDENT -1
X  3 -nogrey
X  .BREAK
X  -nogrey
X  .SKIP
X  Turns off the use of greyscale anti-aliasing when printing shrunken bitmaps.
X! (In this case, the logic of the corresponding resource is the reverse:
X  -nogrey corresponds to grey:off; +nogrey to grey:on).
X  See also 'G' under the Keystrokes help entry.
X  .SKIP
X***************
X*** 275,315 ****
X  .SKIP
X  The resource name is ".paper".
X  .INDENT -1
X- 3 -margins
X- .BREAK
X- -margins <dimen>
X- .SKIP
X- Specifies the size of both the top and side margins.  This should be a
X- decimal number optionally followed by "cm", e.g., 1.5 or 3cm, giving a
X- measurement in inches or centimeters.
X- XDVI determines the "home" position of
X- the page within the window as follows.  If the entire page fits in the
X- window, then the margin settings are ignored.  If, even after removing
X- the margins from the left, right, top, and bottom, the page still
X- cannot fit in the window, then the page is put in the window such that
X- the top and left margins are hidden, and presumably the upper
X- left-hand corner of the text on the page will be in the upper
X- left-hand corner of the window.  Otherwise, the text is centered in
X- the window.  See also `M' under the Keystrokes help entry.
X- .SKIP
X- The resource name is ".Margin".
X- .INDENT -1
X- 3 -mgs[n]
X- .BREAK
X- -mgs[n] <size>
X- .SKIP
X- Specifies the size of the window to be used for the "magnifying glass"
X- for Button n.  See the MOUSE ACTIONS section.
X- Defaults are 200, 350, 600, 900, and 1200.
X- .SKIP
X- The resource name is ".magnifierSize[n]".
X- .INDENT -1
X- 3 -mgs
X- .BREAK
X- -mgs <size>
X- .SKIP
X- Same as -mgs1.
X- .INDENT -1
X  3 -rv
X  .BREAK
X  Causes the page to be displayed with white characters on a black
X--- 325,330 ----
X***************
X*** 478,484 ****
X  .INDENT -1
X  3 G
X  .BREAK
X! The key toggles the use of greyscale anti-aliasing for displaying shrunken 
X  bitmaps.  In addition, the key sequences `0G' and `1G' clear and set this flag,
X  respectively.  See also the -nogrey option.
X  
X--- 493,499 ----
X  .INDENT -1
X  3 G
X  .BREAK
X! The key toggles the use of greyscale anti-aliasing for displaying shrunken
X  bitmaps.  In addition, the key sequences `0G' and `1G' clear and set this flag,
X  respectively.  See also the -nogrey option.
X  
X***************
X*** 536,545 ****
X  of the font (within a certain range), and if this fails, then it will
X  use the font specified as the alternate font (cf. -altfont).
X  .SKIP
X! For compatibilty with some versions of TeX, you may also use the logical name
X  "TEXFONTS" in place of "XDVIFONTS", although in that case the string should
X! not include any "%" specifiers.
X  
X  .INDENT -1
X  3 XDVISIZES
X  .BREAK
X--- 551,580 ----
X  of the font (within a certain range), and if this fails, then it will
X  use the font specified as the alternate font (cf. -altfont).
X  .SKIP
X! For compatibility with some versions of TeX, you may also use the logical name
X  "TEXFONTS" in place of "XDVIFONTS", although in that case the string should
X! not include any "%" specifiers.  The reason for recognizing "TEXFONTS" is
X! that certain versions of TeX also support the convention regarding an extra
X! slash in the font path; therefore, users who create their own fonts can put
X! both their .TFM and raster file in the same directory and do
X! .SKIP
X! .LITERAL
X!         $ DEFINE TEXFONTS "/MFDIR"
X  
X+ or
X+ 
X+         $ DEFINE TEXFONTS "MFDIR/"
X+ .END LITERAL
X+ .SKIP
X+ in order to get TeX and XDVI to search their directory in addition to the
X+ system standard directories.  The "XDVIFONTS" logical name overrides the
X+ "TEXFONTS" logical name, so that on those sites where "TEXFONTS" must be set
X+ explicitly, and therefore this feature is not useful, the "XDVIFONTS" logical
X+ name be set to an empty string to cause XDVI to ignore "TEXFONTS".
X+ .SKIP
X+ XDVI also recognizes the "PKFONTS" logical name, which is checked after
X+ "XDVIFONTS" but before "TEXFONTS".
X+ 
X  .INDENT -1
X  3 XDVISIZES
X  .BREAK
X***************
X*** 559,566 ****
X  Virtual fonts are supported, although XDVI does not have any built-in fonts to
X  which they can refer.  The search path for .VF files can be specified with the
X  "XDVIVFS" logical name in a similar manner to that for the "XDVIFONTS" logical
X! name.  Virtual fonts are searched for immediately after looking for the font
X! as a normal font in the exact size specified.
X  
X  .INDENT -1
X  2 Resource_Names
X--- 594,602 ----
X  Virtual fonts are supported, although XDVI does not have any built-in fonts to
X  which they can refer.  The search path for .VF files can be specified with the
X  "XDVIVFS" logical name in a similar manner to that for the "XDVIFONTS" logical
X! name.  XDVI will also check the "VFFONTS" logical name if the "XDVIFONTS"
X! logical name is not defined.  Virtual fonts are searched for immediately after
X! looking for the font as a normal font in the exact size specified.
X  
X  .INDENT -1
X  2 Resource_Names
Xdiff -cr xdvi_old/dvi_draw.c xdvi_new/dvi_draw.c
X*** xdvi_old/dvi_draw.c	Fri Jun 19 12:25:05 1992
X--- xdvi_new/dvi_draw.c	Mon Aug 24 18:44:34 1992
X***************
X*** 6,20 ****
X   * Code derived from dvi-imagen.c.
X   *
X   * Modification history:
X!  * 1/1986	Modified for X.10 by Bob Scheifler, MIT LCS.
X!  * 7/1988	Modified for X.11 by Mark Eichin, MIT
X   * 12/1988	Added 'R' option, toolkit, magnifying glass
X!  *			--Paul Vojta, UC Berkeley.
X   * 2/1989	Added tpic support	--Jeffrey Lee, U of Toronto
X!  * 4/1989	Modified for System V by Donald Richardson, Clarkson Univ.
X   * 3/1990	Added VMS support	--Scott Allendorf, U of Iowa
X   * 7/1990	Added reflection mode	--Michael Pak, Hebrew U of Jerusalem
X   * 1/1992	Added greyscale code	--Till Brychcy, Techn. Univ. Muenchen
X   *
X   *	Compilation options:
X   *	SYSV	compile for System V
X--- 6,21 ----
X   * Code derived from dvi-imagen.c.
X   *
X   * Modification history:
X!  * 1/1986	Modified for X.10	--Bob Scheifler, MIT LCS.
X!  * 7/1988	Modified for X.11	--Mark Eichin, MIT
X   * 12/1988	Added 'R' option, toolkit, magnifying glass
X!  *					--Paul Vojta, UC Berkeley.
X   * 2/1989	Added tpic support	--Jeffrey Lee, U of Toronto
X!  * 4/1989	Modified for System V	--Donald Richardson, Clarkson Univ.
X   * 3/1990	Added VMS support	--Scott Allendorf, U of Iowa
X   * 7/1990	Added reflection mode	--Michael Pak, Hebrew U of Jerusalem
X   * 1/1992	Added greyscale code	--Till Brychcy, Techn. Univ. Muenchen
X+  *					  and Lee Hetherington, MIT
X   *
X   *	Compilation options:
X   *	SYSV	compile for System V
X***************
X*** 180,190 ****
X  }
X  
X  #if	NeedVarargsPrototypes
X! static	volatile void
X  tell_oops(_Xconst char *message, ...)
X  #else
X  /* VARARGS */
X! static	volatile void
X  tell_oops(va_alist)
X  	va_dcl
X  #endif
X--- 181,191 ----
X  }
X  
X  #if	NeedVarargsPrototypes
X! static	NORETURN void
X  tell_oops(_Xconst char *message, ...)
X  #else
X  /* VARARGS */
X! static	NORETURN void
X  tell_oops(va_alist)
X  	va_dcl
X  #endif
X***************
X*** 206,212 ****
X  	if (currinf.virtual)
X  	    Fprintf(stderr, " in virtual font %s\n", currinf.virtual->fontname);
X  	else
X! 	    Fprintf(stderr, ", offset %d\n", xtell(currinf.pos - 1));
X  	exit(1);
X  }
X  
X--- 207,213 ----
X  	if (currinf.virtual)
X  	    Fprintf(stderr, " in virtual font %s\n", currinf.virtual->fontname);
X  	else
X! 	    Fprintf(stderr, ", offset %ld\n", xtell(currinf.pos - 1));
X  	exit(1);
X  }
X  
X***************
X*** 248,254 ****
X  	if (isprint(ch))
X  	    Printf(" (%c)", ch);
X  	Putchar('\n');
X! 	Printf("x = %d, y = %d, dvi = %d\n", g->x, g->y, g->dvi_adv);
X  	print_bitmap(&g->bitmap);
X  }
X  
X--- 249,255 ----
X  	if (isprint(ch))
X  	    Printf(" (%c)", ch);
X  	Putchar('\n');
X! 	Printf("x = %d, y = %d, dvi = %ld\n", g->x, g->y, g->dvi_adv);
X  	print_bitmap(&g->bitmap);
X  }
X  
X***************
X*** 285,291 ****
X  	    return;
X  	}
X  	else s = dvi_table2[ch - (FNTNUM0 + 64)];
X! 	if (s) puts(s);
X  	else
X  	    tell_oops("unknown op-code %d", ch);
X  }
X--- 286,292 ----
X  	    return;
X  	}
X  	else s = dvi_table2[ch - (FNTNUM0 + 64)];
X! 	if (s) Puts(s);
X  	else
X  	    tell_oops("unknown op-code %d", ch);
X  }
X***************
X*** 351,364 ****
X  shrink_glyph_grey(g)
X  	register struct glyph *g;
X  {
X- 	int	shrunk_bytes_wide, shrunk_height;
X  	int	rows_left, rows, init_cols, cols_left;
X  	register int	cols;
X  	int	x, y;
X  	long	thesample;
X! 	BMUNIT	*old_ptr, *new_ptr;
X! 	register BMUNIT	m, *cp;
X! 	int	min_sample = shrink_factor * shrink_factor * density / 100;
X  
X  	/* These machinations ensure that the character is shrunk according to
X  	   its hot point, rather than its upper left-hand corner. */
X--- 352,362 ----
X  shrink_glyph_grey(g)
X  	register struct glyph *g;
X  {
X  	int	rows_left, rows, init_cols, cols_left;
X  	register int	cols;
X  	int	x, y;
X  	long	thesample;
X! 	BMUNIT	*old_ptr;
X  
X  	/* These machinations ensure that the character is shrunk according to
X  	   its hot point, rather than its upper left-hand corner. */
X***************
X*** 375,447 ****
X  	    rows += shrink_factor;
X  	    --g->y2;
X  	}
X! 	g->bitmap2.h = shrunk_height = g->y2 +
X! 	    ROUNDUP(g->bitmap.h - cols, shrink_factor) + 1;
X! 	if (g->bitmap2.bits) free(g->bitmap2.bits);
X! 	alloc_bitmap(&g->bitmap2);
X  
X! 	if (g->pixmap2)
X! 	    XDestroyImage(g->image2);
X! 
X! 	g->pixmap2 = xmalloc((unsigned) (g->bitmap2.bytes_wide * g->bitmap2.h *
X! 			       DefaultDepthOfScreen(SCRN)), "character pixmap");
X! 	g->image2 = XCreateImage(DISP,DefaultVisualOfScreen(SCRN),
X  				 DefaultDepthOfScreen(SCRN),
X! 				 ZPixmap, 0, g->pixmap2,
X  				 g->bitmap2.w, g->bitmap2.h,
X  				 BITS_PER_BMUNIT, 0);
X  
X  	old_ptr = (BMUNIT *) g->bitmap.bits;
X- 	new_ptr = (BMUNIT *) g->bitmap2.bits;
X- 	shrunk_bytes_wide = g->bitmap2.bytes_wide;
X  	rows_left = g->bitmap.h;
X- 	bzero((char *) new_ptr, shrunk_bytes_wide * shrunk_height);
X  	y = 0;
X  	while (rows_left) {
X  	    x = 0;
X  	    if (rows > rows_left) rows = rows_left;
X  	    cols_left = g->bitmap.w;
X- #ifndef	MSBITFIRST
X- 	    m = (1 << 0);
X- #else
X- 	    m = (1 << (BITS_PER_BMUNIT-1));
X- #endif
X- 	    cp = new_ptr;
X  	    cols = init_cols;
X  	    while (cols_left) {
X  		if (cols > cols_left) cols = cols_left;
X- 		if ((thesample = sample(old_ptr, g->bitmap.bytes_wide,
X- 			g->bitmap.w - cols_left, cols, rows)) >= min_sample)
X- 		    *cp |= m;
X- #ifndef	MSBITFIRST
X- 		if (m == (BMUNIT)(1 << (BITS_PER_BMUNIT-1))) {
X- 		    m = (1 << 0);
X- 		    ++cp;
X- 		}
X- 		else m <<= 1;
X- #else
X- 		if (m == (1 << 0)) {
X- 		    m = (1 << (BITS_PER_BMUNIT-1));
X- 		    ++cp;
X- 		}
X- 		else m >>= 1;
X- #endif
X- 		cols_left -= cols;
X- 		cols = shrink_factor;
X  
X! 		if (shrink_factor == 2)
X! 		    XPutPixel(g->image2, x, y, pixel2[thesample]);
X! 		else if (shrink_factor == 3)
X! 		    XPutPixel(g->image2, x, y, pixel3[thesample]);
X! 		else if (shrink_factor == 4)
X! 		    XPutPixel(g->image2, x, y, pixel4[thesample]);
X! 		else
X! 		    XPutPixel(g->image2, x, y,
X! 			pixel4[thesample * 16 / shrink_factor / shrink_factor]);
X  
X  		x++;
X  	    }
X- 	    *((char **) &new_ptr) += shrunk_bytes_wide;
X  	    *((char **) &old_ptr) += rows * g->bitmap.bytes_wide;
X  	    rows_left -= rows;
X  	    rows = shrink_factor;
X--- 373,408 ----
X  	    rows += shrink_factor;
X  	    --g->y2;
X  	}
X! 	g->bitmap2.h = g->y2 + ROUNDUP(g->bitmap.h - cols, shrink_factor) + 1;
X  
X! 	g->image2 = XCreateImage(DISP, DefaultVisualOfScreen(SCRN),
X  				 DefaultDepthOfScreen(SCRN),
X! 				 ZPixmap, 0, (char *) NULL,
X  				 g->bitmap2.w, g->bitmap2.h,
X  				 BITS_PER_BMUNIT, 0);
X+ 	g->pixmap2 = g->image2->data = xmalloc((unsigned)
X+ 			g->image2->bytes_per_line * g->bitmap2.h,
X+ 			"character pixmap");
X  
X  	old_ptr = (BMUNIT *) g->bitmap.bits;
X  	rows_left = g->bitmap.h;
X  	y = 0;
X  	while (rows_left) {
X  	    x = 0;
X  	    if (rows > rows_left) rows = rows_left;
X  	    cols_left = g->bitmap.w;
X  	    cols = init_cols;
X  	    while (cols_left) {
X  		if (cols > cols_left) cols = cols_left;
X  
X! 		thesample = sample(old_ptr, g->bitmap.bytes_wide,
X! 			g->bitmap.w - cols_left, cols, rows);
X! 		XPutPixel(g->image2, x, y, pixeltbl[thesample]);
X  
X+ 		cols_left -= cols;
X+ 		cols = shrink_factor;
X  		x++;
X  	    }
X  	    *((char **) &old_ptr) += rows * g->bitmap.bytes_wide;
X  	    rows_left -= rows;
X  	    rows = shrink_factor;
X***************
X*** 450,462 ****
X  
X  	while (y < g->bitmap2.h) {
X  	    for (x = 0; x < g->bitmap2.w; x++)
X! 		XPutPixel(g->image2, x, y, pixel2[0]);
X  	    y++;
X  	}
X  
X  	g->y2 = g->y / shrink_factor;
X- 	if (debug & DBG_BITMAP)
X- 	    print_bitmap(&g->bitmap2);
X  }
X  #endif	/* GREY */
X  
X--- 411,421 ----
X  
X  	while (y < g->bitmap2.h) {
X  	    for (x = 0; x < g->bitmap2.w; x++)
X! 		XPutPixel(g->image2, x, y, *pixeltbl);
X  	    y++;
X  	}
X  
X  	g->y2 = g->y / shrink_factor;
X  }
X  #endif	/* GREY */
X  
X***************
X*** 488,494 ****
X  	}
X  	g->bitmap2.h = shrunk_height = g->y2 +
X  	    ROUNDUP(g->bitmap.h - cols, shrink_factor) + 1;
X- 	if (g->bitmap2.bits) free(g->bitmap2.bits);
X  	alloc_bitmap(&g->bitmap2);
X  	old_ptr = (BMUNIT *) g->bitmap.bits;
X  	new_ptr = (BMUNIT *) g->bitmap2.bits;
X--- 447,452 ----
X***************
X*** 601,607 ****
X  	long	dvi_h_sav;
X  #endif
X  
X! 	if (ch > maxchar) realloc_font(currinf.fontp, ch);
X  	if ((g = &currinf.fontp->glyph[ch])->bitmap.bits == NULL) {
X  	    if (g->addr == 0) {
X  		if (!hush_chars)
X--- 559,565 ----
X  	long	dvi_h_sav;
X  #endif
X  
X! 	if (ch > maxchar) realloc_font(currinf.fontp, WIDEARG(,(int)) ch);
X  	if ((g = &currinf.fontp->glyph[ch])->bitmap.bits == NULL) {
X  	    if (g->addr == 0) {
X  		if (!hush_chars)
X***************
X*** 615,621 ****
X  	    open_font_file(currinf.fontp);
X  	    Fseek(currinf.fontp->file, g->addr, 0);
X  	    (*currinf.fontp->read_char)(currinf.fontp, ch);
X! 	    if (debug & DBG_BITMAP) print_char(ch, g);
X  	    currinf.fontp->timestamp = ++current_timestamp;
X  	}
X  
X--- 573,579 ----
X  	    open_font_file(currinf.fontp);
X  	    Fseek(currinf.fontp->file, g->addr, 0);
X  	    (*currinf.fontp->read_char)(currinf.fontp, ch);
X! 	    if (debug & DBG_BITMAP) print_char((ubyte) ch, g);
X  	    currinf.fontp->timestamp = ++current_timestamp;
X  	}
X  
X***************
X*** 714,723 ****
X  
X  
X  #ifndef	TEXXET
X! long
X  set_no_char(ch)
X  #else
X! void
X  set_no_char(cmd, ch)
X  	ubyte	cmd;
X  #endif
X--- 672,681 ----
X  
X  
X  #ifndef	TEXXET
X! static	long
X  set_no_char(ch)
X  #else
X! static	void
X  set_no_char(cmd, ch)
X  	ubyte	cmd;
X  #endif
Xdiff -cr xdvi_old/dvi_init.c xdvi_new/dvi_init.c
X*** xdvi_old/dvi_init.c	Wed Jun 10 18:46:09 1992
X--- xdvi_new/dvi_init.c	Mon Aug 24 18:44:44 1992
X***************
X*** 6,20 ****
X   * Code derived from dvi-imagen.c.
X   *
X   * Modification history:
X!  * 1/1986	Modified for X.10 by Bob Scheifler, MIT LCS.
X!  * 7/1988	Modified for X.11 by Mark Eichin, MIT
X   * 12/1988	Added 'R' option, toolkit, magnifying glass
X!  *			--Paul Vojta, UC Berkeley.
X   * 2/1989	Added tpic support	--Jeffrey Lee, U of Toronto
X!  * 4/1989	Modified for System V by Donald Richardson, Clarkson Univ.
X   * 3/1990	Added VMS support	--Scott Allendorf, U of Iowa
X   * 7/1990	Added reflection mode	--Michael Pak, Hebrew U of Jerusalem
X   * 1/1992	Added greyscale code	--Till Brychcy, Techn. Univ. Muenchen
X   *
X   *	Compilation options:
X   *	SYSV	compile for System V
X--- 6,21 ----
X   * Code derived from dvi-imagen.c.
X   *
X   * Modification history:
X!  * 1/1986	Modified for X.10	--Bob Scheifler, MIT LCS.
X!  * 7/1988	Modified for X.11	--Mark Eichin, MIT
X   * 12/1988	Added 'R' option, toolkit, magnifying glass
X!  *					--Paul Vojta, UC Berkeley.
X   * 2/1989	Added tpic support	--Jeffrey Lee, U of Toronto
X!  * 4/1989	Modified for System V	--Donald Richardson, Clarkson Univ.
X   * 3/1990	Added VMS support	--Scott Allendorf, U of Iowa
X   * 7/1990	Added reflection mode	--Michael Pak, Hebrew U of Jerusalem
X   * 1/1992	Added greyscale code	--Till Brychcy, Techn. Univ. Muenchen
X+  *					  and Lee Hetherington, MIT
X   *
X   *	Compilation options:
X   *	SYSV	compile for System V
X***************
X*** 180,186 ****
X  
X  	fontp->flags |= FONT_LOADED;
X  	fontp->file = font_open(fontp->fontname, &font_found,
X! 	    (WIDEARG(float, double)) fsize, &size_found, &fontp->filename);
X  	if (fontp->file == NULL) {
X  	    Fprintf(stderr, "Can't find font %s.\n", fontp->fontname);
X  	    font_not_found = True;
X--- 181,188 ----
X  
X  	fontp->flags |= FONT_LOADED;
X  	fontp->file = font_open(fontp->fontname, &font_found,
X! 	    (WIDEARG(float, double)) fsize, &size_found, fontp->magstepval,
X! 	    &fontp->filename);
X  	if (fontp->file == NULL) {
X  	    Fprintf(stderr, "Can't find font %s.\n", fontp->fontname);
X  	    font_not_found = True;
X***************
X*** 223,238 ****
X  
X  	if (fontp->flags & FONT_VIRTUAL) {
X  	    while (maxchar > 0 && fontp->macro[maxchar].pos == NULL) --maxchar;
X! 	    if (maxchar < 255) realloc_virtual_font(fontp, maxchar);
X  	}
X  	else {
X  	    while (maxchar > 0 && fontp->glyph[maxchar].addr == 0) --maxchar;
X! 	    if (maxchar < 255) realloc_font(fontp, maxchar);
X  	}
X  }
X  
X  
X  /*
X   *	reuse_font recursively sets the flags for font structures being reused.
X   */
X  
X--- 225,284 ----
X  
X  	if (fontp->flags & FONT_VIRTUAL) {
X  	    while (maxchar > 0 && fontp->macro[maxchar].pos == NULL) --maxchar;
X! 	    if (maxchar < 255)
X! 		realloc_virtual_font(fontp, WIDEARG(,(int)) maxchar);
X  	}
X  	else {
X  	    while (maxchar > 0 && fontp->glyph[maxchar].addr == 0) --maxchar;
X! 	    if (maxchar < 255)
X! 		realloc_font(fontp, WIDEARG(,(int)) maxchar);
X  	}
X  }
X  
X  
X  /*
X+  *	MAGSTEPVALUE - If the given magnification is close to a \magstep
X+  *	or a \magstephalf, then return twice the number of \magsteps.
X+  *	Otherwise return NOMAGSTP.
X+  */
X+ 
X+ #define	NOMAGSTP (-29999)
X+ #define	NOBUILD	29999
X+ 
X+ static	int
X+ magstepvalue(mag)
X+ 	float	*mag;
X+ {
X+ 	int	m	= 0;
X+ 	double	fmag	= *mag;
X+ 	double	xmag	= pixels_per_inch;
X+ 	float	margin	= fmag * 0.002;
X+ 
X+ 	if (fmag < pixels_per_inch)
X+ 	    for (;;) {
X+ 		if (xmag - fmag < margin && -(xmag - fmag) < margin) {
X+ 		    *mag = xmag;
X+ 		    return m;
X+ 		}
X+ 		if (xmag < fmag) break;
X+ 		xmag *= 0.9128709292;
X+ 		--m;
X+ 	    }
X+ 	else
X+ 	    for (;;) {
X+ 		if (xmag - fmag < margin && -(xmag - fmag) < margin) {
X+ 		    *mag = xmag;
X+ 		    return m;
X+ 		}
X+ 		if (xmag > fmag) break;
X+ 		xmag *= 1.095445115;
X+ 		++m;
X+ 	    }
X+ 	return NOMAGSTP;
X+ }
X+ 
X+ 
X+ /*
X   *	reuse_font recursively sets the flags for font structures being reused.
X   */
X  
X***************
X*** 262,268 ****
X  void
X  define_font(file, cmnd, vfparent, tn_headpp)
X  	FILE		*file;
X! 	WIDEARG(ubyte,unsigned int) cmnd;
X  	struct font	*vfparent;	/* vf parent of this font, or NULL */
X  	struct tn	**tn_headpp;	/* addr of head of list of TeXnumbers */
X  {
X--- 308,314 ----
X  void
X  define_font(file, cmnd, vfparent, tn_headpp)
X  	FILE		*file;
X! 	WIDEARG(ubyte, unsigned int) cmnd;
X  	struct font	*vfparent;	/* vf parent of this font, or NULL */
X  	struct tn	**tn_headpp;	/* addr of head of list of TeXnumbers */
X  {
X***************
X*** 272,277 ****
X--- 318,324 ----
X  	double	scale_dimconv;
X  	int scale;
X  	int design;
X+ 	int magstepval;
X  	int len;
X  	char *fontname;
X  	int size;
X***************
X*** 280,286 ****
X  	    "TeXnumber structure");
X  	tnp->next = *tn_headpp;
X  	*tn_headpp = tnp;
X! 	tnp->TeXnumber = num(file, (ubyte) cmnd - FNTDEF1 + 1);
X  	(void) four(file);	/* checksum */
X  	scale = four(file);
X  	design = four(file);
X--- 327,333 ----
X  	    "TeXnumber structure");
X  	tnp->next = *tn_headpp;
X  	*tn_headpp = tnp;
X! 	tnp->TeXnumber = num(file, (int) cmnd - FNTDEF1 + 1);
X  	(void) four(file);	/* checksum */
X  	scale = four(file);
X  	design = four(file);
X***************
X*** 307,312 ****
X--- 354,360 ----
X  	    fsize = (72.27 * (1<<4)) * vfparent->dimconv * scale / design;
X  	    scale_dimconv = vfparent->dimconv;
X  	}
X+ 	magstepval = magstepvalue(&fsize);
X  	size = 5 * fsize + 0.5;
X  	/*
X  	 * reuse font if possible
X***************
X*** 317,329 ****
X  		    Printf("%s at %d dpi\n", fontname, (int) (fsize + 0.5));
X  		fontp = (struct font *) xmalloc((unsigned) sizeof(struct font),
X  		    "font structure");
X- 		fontp->next = font_head;
X- 		font_head = fontp;
X  		fontp->dimconv = scale * scale_dimconv / (1<<20);
X  		fontp->fontname = fontname;
X  		fontp->fsize = fsize;
X  		fontp->flags = FONT_IN_USE;
X  		if (vfparent == NULL) load_font(fontp);
X  		break;
X  	    }
X  	    if (strcmp(fontname, fontp->fontname) == 0
X--- 365,378 ----
X  		    Printf("%s at %d dpi\n", fontname, (int) (fsize + 0.5));
X  		fontp = (struct font *) xmalloc((unsigned) sizeof(struct font),
X  		    "font structure");
X  		fontp->dimconv = scale * scale_dimconv / (1<<20);
X  		fontp->fontname = fontname;
X  		fontp->fsize = fsize;
X+ 		fontp->magstepval = magstepval;
X  		fontp->flags = FONT_IN_USE;
X  		if (vfparent == NULL) load_font(fontp);
X+ 		fontp->next = font_head;
X+ 		font_head = fontp;
X  		break;
X  	    }
X  	    if (strcmp(fontname, fontp->fontname) == 0
Xdiff -cr xdvi_old/font_open.c xdvi_new/font_open.c
X*** xdvi_old/font_open.c	Mon Jun 15 12:49:37 1992
X--- xdvi_new/font_open.c	Fri Jul 24 14:28:54 1992
X***************
X*** 1,5 ****
X  /*
X!  *	font_open.c(font, font_ret, mag, mag_ret, name)
X   *	Find and open gf, pk, or pxl files in the given path, having the given
X   *	name and magnification.  It tries gf files first, followed by pk and pxl
X   *	files.  The path variable should be of the form path1:path2:...:pathn,
X--- 1,5 ----
X  /*
X!  *	font_open.c(font, font_ret, mag, mag_ret, magstepval, name)
X   *	Find and open gf, pk, or pxl files in the given path, having the given
X   *	name and magnification.  It tries gf files first, followed by pk and pxl
X   *	files.  The path variable should be of the form path1:path2:...:pathn,
X***************
X*** 40,47 ****
X  #include <errno.h>
X  
X  #ifndef	X_NOT_STDC_ENV
X! #include <stdlib.h>
X  #endif
X  
X  /*
X   *	If you think you have to change DEFAULT_TAIL, then you haven't read the
X--- 40,53 ----
X  #include <errno.h>
X  
X  #ifndef	X_NOT_STDC_ENV
X! #include <stdlib.h>	/* has getenv() */
X! #include <math.h>	/* has atof() */
X! #else
X! extern	char	*getenv();
X! #ifndef	atof
X! double	atof();
X  #endif
X+ #endif
X  
X  /*
X   *	If you think you have to change DEFAULT_TAIL, then you haven't read the
X***************
X*** 67,84 ****
X  static	int	*sizes, *sizend;
X  static	char	default_size_list[]	= DEFAULT_FONT_SIZES;
X  
X  #define	FILENAMESIZE 512
X  
X  #ifdef	sun
X  char	*sprintf();
X  #endif
X  
X- char	*getenv();
X- 
X- #ifndef	atof
X- double	atof();
X- #endif
X- 
X  #ifdef	SEARCH_SUBDIRECTORIES
X  /* We will need some system include files to deal with directories.  */
X  /* <sys/types.h> was included by xdvi.h.  */
X--- 73,93 ----
X  static	int	*sizes, *sizend;
X  static	char	default_size_list[]	= DEFAULT_FONT_SIZES;
X  
X+ #ifdef	_POSIX_SOURCE
X+ #include <limits.h>
X+ #ifdef	PATH_MAX
X+ #define	FILENAMESIZE	PATH_MAX
X+ #endif
X+ #endif
X+ 
X+ #ifndef	FILENAMESIZE
X  #define	FILENAMESIZE 512
X+ #endif
X  
X  #ifdef	sun
X  char	*sprintf();
X  #endif
X  
X  #ifdef	SEARCH_SUBDIRECTORIES
X  /* We will need some system include files to deal with directories.  */
X  /* <sys/types.h> was included by xdvi.h.  */
X***************
X*** 99,111 ****
X  
X  #ifdef	HAVE_GETWD
X  extern	char	*getwd ();
X! #define	getcwd(b, len)	((b) ? getwd (b) : getwd (xmalloc (len, "getwd")))
X  #else
X! #ifdef	ANSI
X  extern	char	*getcwd (char *, int);
X  #else
X  extern	char	*getcwd ();
X! #endif	/* not ANSI */
X  #endif	/* not HAVE_GETWD */
X  
X  static	char	*cwd;
X--- 108,130 ----
X  
X  #ifdef	HAVE_GETWD
X  extern	char	*getwd ();
X! #define	GETCWD(b, len)	((b) ? getwd (b) : getwd (xmalloc (len, "getwd")))
X  #else
X! /* POSIX says getcwd result is undefined if the pointer is NULL; at least
X!    on a Convex, the result is a coredump.  Hence the GETCWD macro
X!    below is defined, as it works regardless of what getcwd() does
X!    with a NULL pointer  */
X! #define	GETCWD(b, len)	((b) ? getcwd (b,len) \
X! 			: getcwd (xmalloc (len, "getcwd"),len))
X! #ifdef	_POSIX_SOURCE
X! #include <unistd.h>	/* getcwd prototype */
X! #else
X! #if	NeedFunctionPrototypes
X  extern	char	*getcwd (char *, int);
X  #else
X  extern	char	*getcwd ();
X! #endif	/* not NeedFunctionPrototypes */
X! #endif	/* not _POSIX_SOURCE */
X  #endif	/* not HAVE_GETWD */
X  
X  static	char	*cwd;
X***************
X*** 204,210 ****
X  
X  static	struct subdir_entry *
X  make_subdir_entry(index, name)
X! 	char	*index, *name;
X  {
X  	struct subdir_entry		*new_entry;
X  	static	struct subdir_entry	**subdir_tail = &subdir_head;
X--- 223,230 ----
X  
X  static	struct subdir_entry *
X  make_subdir_entry(index, name)
X! 	_Xconst char	*index;
X! 	char		*name;
X  {
X  	struct subdir_entry		*new_entry;
X  	static	struct subdir_entry	**subdir_tail = &subdir_head;
X***************
X*** 225,231 ****
X  
X  static	void
X  add_subdirs(str, len, recurs)
X! 	char	*str;
X  	int	len;
X  	Boolean	recurs;
X  {
X--- 245,251 ----
X  
X  static	void
X  add_subdirs(str, len, recurs)
X! 	_Xconst char	*str;
X  	int	len;
X  	Boolean	recurs;
X  {
X***************
X*** 278,287 ****
X  
X  static	void
X  compute_subdir_paths(fp, fp_default)
X! 	char	*fp, *fp_default;
X  {
X! 	char	*star_loc = NULL;
X! 	char	*endp;
X  
X  	do {
X  	    if (star_loc == NULL) {
X--- 298,308 ----
X  
X  static	void
X  compute_subdir_paths(fp, fp_default)
X! 	_Xconst char	*fp;
X! 	_Xconst char	*fp_default;
X  {
X! 	_Xconst char	*star_loc = NULL;
X! 	_Xconst char	*endp;
X  
X  	do {
X  	    if (star_loc == NULL) {
X***************
X*** 358,364 ****
X  	   is not necessarily the same directory the user expects to be
X  	   in.  So, we must always call getcwd(3) or getwd(3), even though
X  	   they are slow and prone to hang in networked installations.  */
X! 	cwd = getcwd ((char *) NULL, FILENAMESIZE + 2);
X  	if (cwd == NULL) {
X  	    perror ("getcwd");
X  	    exit (errno);
X--- 379,385 ----
X  	   is not necessarily the same directory the user expects to be
X  	   in.  So, we must always call getcwd(3) or getwd(3), even though
X  	   they are slow and prone to hang in networked installations.  */
X! 	cwd = GETCWD ((char *) NULL, FILENAMESIZE + 2);
X  	if (cwd == NULL) {
X  	    perror ("getcwd");
X  	    exit (errno);
X***************
X*** 580,638 ****
X  }
X  
X  #ifdef	MAKEPKCMD
X  #define	MAKEPK
X  #endif
X  
X  #ifdef	MAKEPK
X- 
X  #ifndef	MAKEPKCMD
X  #define	MAKEPKCMD	"MakeTeXPK"
X  #endif
X  
X! /*
X!  *	Create the string for magstep() values.
X!  */
X  
X- static	char *
X- magstring(mdpi)
X- 	int	mdpi;
X- {
X- 	int	m;
X- 	double	fdpi;
X- 	int	tdpi;
X- 	static	char	str[24];
X- 
X- 	if (mdpi != 0) {
X- 	    fdpi = pixels_per_inch;
X- 	    m = 0;
X- 	    if (mdpi >= pixels_per_inch) {
X- 		while ((tdpi = fdpi + 0.5) < mdpi) {
X- 		    fdpi *= 1.095445115;
X- 		    ++m;
X- 		}
X- 		if (tdpi == mdpi) {
X- 		    Sprintf(str, "magstep\\(%d%s\\)", m / 2, m % 2 ? ".5" : "");
X- 		    return str;
X- 		}
X- 	    }
X- 	    else {
X- 		do {
X- 		    fdpi *= 0.9128709292;
X- 		    ++m;
X- 		}
X- 		while ((tdpi = fdpi + 0.5) > mdpi);
X- 		if (tdpi == mdpi) {
X- 		    Sprintf(str, "magstep\\(-%d%s\\)", m / 2, m % 2 ? ".5" :"");
X- 		    return str;
X- 		}
X- 	    }
X- 	}
X- 	Sprintf(str, "%d+%d/%d", mdpi / pixels_per_inch, mdpi % pixels_per_inch,
X- 	    pixels_per_inch);
X- 	return str;
X- }
X- #endif	/* MAKEPK */
X- 
X  /*
X   *	Try a given font name
X   */
X--- 601,618 ----
X  }
X  
X  #ifdef	MAKEPKCMD
X+ #undef	MAKEPK
X  #define	MAKEPK
X  #endif
X  
X  #ifdef	MAKEPK
X  #ifndef	MAKEPKCMD
X  #define	MAKEPKCMD	"MakeTeXPK"
X  #endif
X  
X! #define	NOBUILD	29999
X! #endif
X  
X  /*
X   *	Try a given font name
X   */
X***************
X*** 645,657 ****
X  #endif
X  
X  static	FILE *
X! PRE_FONT_OPEN(font, fmag, mag_ret, name, try_make)
X  	_Xconst char	*font;
X  	float	fmag;
X  	int	*mag_ret;
X  	char	**name;
X  #ifdef	MAKEPK
X! 	Boolean	try_make;
X  #endif
X  {
X  	FILE	*f;
X--- 625,637 ----
X  #endif
X  
X  static	FILE *
X! PRE_FONT_OPEN(font, fmag, mag_ret, name, magstepval)
X  	_Xconst char	*font;
X  	float	fmag;
X  	int	*mag_ret;
X  	char	**name;
X  #ifdef	MAKEPK
X! 	int	magstepval;
X  #endif
X  {
X  	FILE	*f;
X***************
X*** 708,716 ****
X  
X  #ifdef	MAKEPK
X  	/* Try to create the font. */
X! 	    if (try_make) {
X! 	    Sprintf(mkpk, "%s %s %d %d %s", MAKEPKCMD, font, mag / 5,
X! 		pixels_per_inch, magstring(mag / 5));
X  	    Printf("- %s\n", mkpk);
X  	    if (system(mkpk) == 0
X  		&& (f = try_size(font, mag, name, path_to_use,
X--- 688,709 ----
X  
X  #ifdef	MAKEPK
X  	/* Try to create the font. */
X! 	if (magstepval != NOBUILD) {
X! 	    char str[24];
X! 	    int	dpi	= (mag + 2) / 5;
X! 
X! 	    if (magstepval == NOMAGSTP)
X! 		Sprintf(str, "%d+%d/%d", dpi / pixels_per_inch,
X! 		    dpi % pixels_per_inch, pixels_per_inch);
X! 	    else if (magstepval < 0)
X! 		Sprintf(str, "magstep\\(-%d%s\\)", (-magstepval) / 2,
X! 		    magstepval % 2 ? ".5" :"");
X! 	    else
X! 		Sprintf(str, "magstep\\(%d%s\\)", magstepval / 2,
X! 		    magstepval % 2 ? ".5" :"");
X! 
X! 	    Sprintf(mkpk, "%s %s %d %d %s", MAKEPKCMD, font, dpi,
X! 		pixels_per_inch, str);
X  	    Printf("- %s\n", mkpk);
X  	    if (system(mkpk) == 0
X  		&& (f = try_size(font, mag, name, path_to_use,
X***************
X*** 737,748 ****
X  	}
X  }
X  
X  FILE *
X! font_open(font, font_ret, mag, mag_ret, name)
X  	_Xconst char	*font;
X  	char	**font_ret;
X! 	WIDEARG(float,double) mag;
X  	int	*mag_ret;
X  	char	**name;
X  {
X  	FILE	*f;
X--- 730,743 ----
X  	}
X  }
X  
X+ /* ARGSUSED */
X  FILE *
X! font_open(font, font_ret, mag, mag_ret, magstepval, name)
X  	_Xconst char	*font;
X  	char	**font_ret;
X! 	WIDEARG(float, double) mag;
X  	int	*mag_ret;
X+ 	int	magstepval;
X  	char	**name;
X  {
X  	FILE	*f;
X***************
X*** 749,755 ****
X  	int	actual_pt, low_pt, high_pt, trial_pt;
X  	char	fn[50], *fnend;
X  
X! 	f = PRE_FONT_OPEN(font, mag, mag_ret, name, True);
X  	if (f != NULL) {
X  	    *font_ret = NULL;
X  	    return f;
X--- 744,750 ----
X  	int	actual_pt, low_pt, high_pt, trial_pt;
X  	char	fn[50], *fnend;
X  
X! 	f = PRE_FONT_OPEN(font, mag, mag_ret, name, magstepval);
X  	if (f != NULL) {
X  	    *font_ret = NULL;
X  	    return f;
X***************
X*** 770,776 ****
X  		else trial_pt = high_pt++;
X  		Sprintf(fnend, "%d", trial_pt);
X  		f = PRE_FONT_OPEN(fn, mag * actual_pt / trial_pt, mag_ret,
X! 		    name, False);
X  		if (f != NULL) {
X  		    *font_ret = strcpy(xmalloc((unsigned) strlen(fn) + 1,
X  			"name of font used"), fn);
X--- 765,771 ----
X  		else trial_pt = high_pt++;
X  		Sprintf(fnend, "%d", trial_pt);
X  		f = PRE_FONT_OPEN(fn, mag * actual_pt / trial_pt, mag_ret,
X! 		    name, NOBUILD);
X  		if (f != NULL) {
X  		    *font_ret = strcpy(xmalloc((unsigned) strlen(fn) + 1,
X  			"name of font used"), fn);
X***************
X*** 779,785 ****
X  	    }
X  	}
X  	if (alt_font != NULL) {
X! 	    f = PRE_FONT_OPEN(alt_font, mag, mag_ret, name, False);
X  	    if (f != NULL)
X  		*font_ret = strcpy(xmalloc((unsigned) strlen(alt_font) + 1,
X  		    "name of font used"), alt_font);
X--- 774,780 ----
X  	    }
X  	}
X  	if (alt_font != NULL) {
X! 	    f = PRE_FONT_OPEN(alt_font, mag, mag_ret, name, NOBUILD);
X  	    if (f != NULL)
X  		*font_ret = strcpy(xmalloc((unsigned) strlen(alt_font) + 1,
X  		    "name of font used"), alt_font);
X
X
END_OF_FILE
  if test 44861 -ne `wc -c <'xdvi.p16.1'`; then
    echo shar: \"'xdvi.p16.1'\" unpacked with wrong size!
  fi
  # end of 'xdvi.p16.1'
fi
echo shar: End of archive 2 \(of 2\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM       | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@imd.sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
