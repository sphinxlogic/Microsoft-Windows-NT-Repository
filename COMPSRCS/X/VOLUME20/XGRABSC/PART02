Newsgroups: comp.sources.x
From: bruce@servio.slc.com (Bruce Schuchardt)
Subject: v20i101:  xgrabsc - Grab and dump X displays, Part02/05
Message-ID: <1993Aug4.171656.9413@sparky.sterling.com>
X-Md4-Signature: ef39928670b5e6cd5ed8a95358ef7b0c
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Wed, 4 Aug 1993 17:16:56 GMT
Approved: chris@sterling.com

Submitted-by: bruce@servio.slc.com (Bruce Schuchardt)
Posting-number: Volume 20, Issue 101
Archive-name: xgrabsc/part02
Environment: X11
Supersedes: xgrabsc: Volume 18, Issue 52-56

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 5)."
# Contents:  xgrabsc.2_3/XGrabxm.res xgrabsc.2_3/xgrabsc.c
#   xgrabsc.2_3/xgrabxm.c
# Wrapped by bruce@trout on Mon Jun 28 09:14:50 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'xgrabsc.2_3/XGrabxm.res' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/XGrabxm.res'\"
else
echo shar: Extracting \"'xgrabsc.2_3/XGrabxm.res'\" \(10437 characters\)
sed "s/^X//" >'xgrabsc.2_3/XGrabxm.res' <<'END_OF_FILE'
X#include "config.h"
X
XXGrab*.title.labelString: X-Windows Screen Grabber
XXGrab*.title.FontList:   *-times-medium-r-normal--18-*
XXGrab*.title.x: 135
X
X!----------------------------box 1
X
XXGrab*.box1.x: 0
XXGrab*.box1.y:  35
X
XXGrab*.inputLbl.x:     5
XXGrab*.inputLbl.y:      0
XXGrab*.inputLbl.FontList: *-helvetica-medium-o-normal--14-*
XXGrab*.inputLbl.labelString: Input Options--------------------------------------------
X
XXGrab*.selectiontype.topAttachment: attach_widget
XXGrab*.selectiontype.topWidget: inputLbl
XXGrab*.selectiontype.topOffset: 2
XXGrab*.selectiontype.orientation: horizontal
XXGrab*.selectiontype.numColumns: 2
XXGrab*.selectiontype.x: 5
X
XXGrab*.click.labelString: Click on Window
XXGrab*.stretch.labelString: Stretch Rectangle
XXGrab*.stretch.set: 1
XXGrab*.key.labelString: Wait for Control key
XXGrab*.root.labelString: Grab Whole Screen
X
XXGrab*.sleeplbl.x: 10
XXGrab*.sleeplbl.y:  90
XXGrab*.sleeplbl.labelString: Sleep before starting
X
XXGrab*.sleeptime.leftAttachment: attach_widget
XXGrab*.sleeptime.leftWidget:      sleeplbl
XXGrab*.sleeptime.leftOffset:  5
XXGrab*.sleeptime.y:      85
XXGrab*.sleeptime.width:  40
XXGrab*.sleeptime*value:  DEFAULT_PRESLEEP
X
XXGrab*.psleeplbl.leftAttachment: attach_widget
XXGrab*.psleeplbl.leftWidget:	sleeptime
XXGrab*.psleeplbl.leftOffset:    10
XXGrab*.psleeplbl.y:    90
XXGrab*.psleeplbl.labelString: Sleep after selecting
X
XXGrab*.psleeptime.leftAttachment: attach_widget
XXGrab*.psleeptime.leftWidget:	psleeplbl
XXGrab*.psleeptime.leftOffset:     5
XXGrab*.psleeptime.y:     85
XXGrab*.psleeptime.width:  40
XXGrab*.psleeptime*value: DEFAULT_POSTSLEEP
X
XXGrab*.host.x:   10
XXGrab*.host.y:   120
XXGrab*.host.labelString: Use Alternate Display:
XXGrab*.host.width:  150
XXGrab*.host.set: 0
X
XXGrab*.hostText.leftAttachment: attach_widget
XXGrab*.hostText.leftWidget:	host
XXGrab*.hostText.leftOffset:     5
XXGrab*.hostText.y:    115
X! xgrab sets DISPLAY value into this widget
X! XGrab*.hostText*value: :0
X
X
X!----------------------------box 2
XXGrab*.box2.x:   0
XXGrab*.box2.topAttachment: attach_widget
XXGrab*.box2.topWidget: box1
X
XXGrab*.outputFormat.x:   5
XXGrab*.outputFormat.y:    0
XXGrab*.outputFormat.FontList: *-helvetica-medium-o-normal--12-*
XXGrab*.outputFormat.labelString: Output Format-------------------------------------------------
X
XXGrab*.formattype.topAttachment: attach_widget
XXGrab*.formattype.topWidget: outputFormat
XXGrab*.formattype.topOffset: 2
XXGrab*.formattype.orientation: horizontal
XXGrab*.formattype.numColumns: 2
X
XXGrab*.xwd.labelString:    X Window Dump
XXGrab*.ps.labelString:     PostScript
XXGrab*.ps.set: 1
XXGrab*.puzzle.labelString: Puzzle
XXGrab*.xwdxy.labelString:  XWD-xy
XXGrab*.xpm.labelString:    Bitmap/XPM
XXGrab*.xpm2.labelString:   Bm/XPM2
XXGrab*.xpm3.labelString:   Bm/XPM3
X
X!----------------------------box 3
XXGrab*.box3.x:   0
XXGrab*.box3.topAttachment: attach_widget
XXGrab*.box3.topWidget: box2
X
XXGrab*.psOptions.x:   5
XXGrab*.psOptions.y:    0
XXGrab*.psOptions.FontList: *-helvetica-medium-o-normal--12-*
XXGrab*.psOptions.labelString: PostScript Options----------------------------------------------
X
XXGrab*.compress.x:   10
XXGrab*.compress.y:    25 
XXGrab*.compress.labelString: Compress
XXGrab*.compress.set: 1
X
XXGrab*.color.leftAttachment: attach_widget
XXGrab*.color.leftWidget: compress
XXGrab*.color.leftOffset:    10
XXGrab*.color.y:     25
XXGrab*.color.labelString: Color Output
X
XXGrab*.binary.leftAttachment: attach_widget
XXGrab*.binary.leftWidget: color
XXGrab*.binary.leftOffset: 10
XXGrab*.binary.y: 25
XXGrab*.binary.labelString: Binary
X
XXGrab*.limit.leftAttachment: attach_widget
XXGrab*.limit.leftWidget: binary
XXGrab*.limit.leftOffset: 10
XXGrab*.limit.y: 25
X#if defined(NO_PRINTER_MEMORY_CHECKS)
XXGrab*.limit.set: 0
X#else
XXGrab*.limit.set: 1
X#endif
XXGrab*.limit.labelString: Limit Check
X
XXGrab*.postscripttype.topAttachment: attach_widget
XXGrab*.postscripttype.topWidget: compress
XXGrab*.postscripttype.topOffset: 2
XXGrab*.postscripttype.orientation: horizontal
XXGrab*.postscripttype.numColumns: 1
XXGrab*.postscripttype.x: 5
X
XXGrab*.portrait.labelString: Portrait
XXGrab*.portrait.set: true
XXGrab*.landscape.labelString: Landscape
XXGrab*.epsi.labelString: PS Figure
XXGrab*.onlyEpsi.labelString: Preview Only
XXGrab*.pageWidth.x: 10
XXGrab*.pageWidth.y:  90
XXGrab*.pageWidth.labelString: Paper Width
X
XXGrab*.pageWidthText.leftAttachment: attach_widget
XXGrab*.pageWidthText.leftWidget: pageWidth
XXGrab*.pageWidthText.leftOffset: 0
XXGrab*.pageWidthText.y:  85
XXGrab*.pageWidthText.width: 45
XXGrab*.pageWidthText*value: PAPER_WIDTH
X
XXGrab*.pageHeight.leftAttachment: attach_widget
XXGrab*.pageHeight.leftWidget:	pageWidthText
XXGrab*.pageHeight.leftOffset: 2
XXGrab*.pageHeight.y:  90
XXGrab*.pageHeight.labelString: Height
X
XXGrab*.pageHeightText.leftAttachment: attach_widget
XXGrab*.pageHeightText.leftWidget: pageHeight
XXGrab*.pageHeightText.leftOffset:  0
XXGrab*.pageHeightText.y:  85
XXGrab*.pageHeightText.width: 45
XXGrab*.pageHeightText*value: PAPER_HEIGHT
X
XXGrab*.horizMargin.leftAttachment: attach_widget
XXGrab*.horizMargin.leftWidget: pageHeightText
XXGrab*.horizMargin.leftOffset:  2
XXGrab*.horizMargin.y:  90
XXGrab*.horizMargin.labelString: Margin Width
X
XXGrab*.horizMarginText.leftAttachment: attach_widget
XXGrab*.horizMarginText.leftWidget: horizMargin
XXGrab*.horizMarginText.leftOffset:  0
XXGrab*.horizMarginText.y:  85
XXGrab*.horizMarginText.width: 45
XXGrab*.horizMarginText*value: HORIZ_MARGIN
X
XXGrab*.vertMargin.leftAttachment: attach_widget
XXGrab*.vertMargin.leftWidget: horizMarginText
XXGrab*.vertMargin.leftOffset:  2
XXGrab*.vertMargin.y:  90
XXGrab*.vertMargin.labelString:  Height
X
XXGrab*.vertMarginText.leftAttachment: attach_widget
XXGrab*.vertMarginText.leftWidget: vertMargin
XXGrab*.vertMarginText.leftOffset:  0
XXGrab*.vertMarginText.y:  85
XXGrab*.vertMarginText.width: 45
XXGrab*.vertMarginText*value: VERT_MARGIN
X
X!----------------------------box 4
XXGrab*.box4.x: 0
XXGrab*.box4.topAttachment: attach_widget
XXGrab*.box4.topWidget: box3
X
XXGrab*.prOptions.x:   5
XXGrab*.prOptions.y:    0
XXGrab*.prOptions.FontList: *-helvetica-medium-o-normal--12-*
XXGrab*.prOptions.labelString: Image Processing Options-----
X
XXGrab*.borders.x:   10
XXGrab*.borders.y:    20
XXGrab*.borders.labelString: Include Borders
XXGrab*.borders.width:          105
XXGrab*.borders.set:            1
X
XXGrab*.reverse.x:   10
XXGrab*.reverse.y:    45
XXGrab*.reverse.labelString: Reverse Colors
XXGrab*.reverse.width:           105
X
XXGrab*.brightnessLbl.x:   10
XXGrab*.brightnessLbl.y:    75
XXGrab*.brightnessLbl.labelString: Brightness
X
XXGrab*.brightnessText.x:   85
XXGrab*.brightnessText.y:    70
XXGrab*.brightnessText.width: 40
XXGrab*.brightnessText*value: 100
X
X!----------------------------box 5
XXGrab*.box5.leftAttachment: attach_widget
XXGrab*.box5.leftWidget: box4
XXGrab*.box5.leftOffset: 5
XXGrab*.box5.topAttachment: attach_widget
XXGrab*.box5.topWidget: box3
X
XXGrab*.outputLbl.x:     5
XXGrab*.outputLbl.y:      0
XXGrab*.outputLbl.FontList: *-helvetica-medium-o-normal--12-*
XXGrab*.outputLbl.labelString: Output Options------------------------
X
XXGrab*.outputtype.topAttachment: attach_widget
XXGrab*.outputtype.topWidget: outputLbl
XXGrab*.outputtype.topOffset: 2
XXGrab*.outputtype.orientation: vertical
XXGrab*.outputtype.numColumns: 1
X
XXGrab*.file.labelString: To File:
XXGrab*.file.set: 1
XXGrab*.file.marginHeight: 2
XXGrab*.printer.labelString: To Command:
XXGrab*.printer.marginHeight: 4
X
XXGrab*.fileText.leftAttachment: attach_widget
XXGrab*.fileText.leftWidget: outputtype
XXGrab*.fileText.leftOffset: 5
XXGrab*.fileText.topAttachment: attach_widget
XXGrab*.fileText.topWidget: outputLbl
XXGrab*.fileText.topOffset: 2
XXGrab*.fileText.width: 110
XXGrab*.fileText*value: DEFAULT_FILENAME
X
XXGrab*.printerText.leftAttachment: attach_widget
XXGrab*.printerText.leftWidget: outputtype
XXGrab*.printerText.leftOffset: 5
XXGrab*.printerText.topAttachment: attach_widget
XXGrab*.printerText.topWidget: fileText
XXGrab*.printerText.topOffset: 2
XXGrab*.printerText.width: 110
XXGrab*.printerText*value: DEFAULT_COMMAND
X
X
X
XXGrab*.converttype.topAttachment: attach_widget
XXGrab*.converttype.topWidget: box5
XXGrab*.converttype.topOffset: 15
XXGrab*.converttype.orientation: horizontal
XXGrab*.converttype.numColumns: 2
XXGrab*.converttype.x: 5
X
XXGrab*.nodither.labelString: No Dither
XXGrab*.nodither.set: true
XXGrab*.dither.labelString: Dither
XXGrab*.halftone.labelString: Halftone
XXGrab*.mapbw.labelString: Map to B/W
XXGrab*.mdither.labelString: M-Dither
X
X!----------------------------box 6
XXGrab*.box6.x:   0
XXGrab*.box6.topAttachment: attach_widget
XXGrab*.box6.topWidget: converttype
X
X
XXGrab*.splat.labelString: ------------------------------------------------------------
X
XXGrab*.OK.x:   110
XXGrab*.OK.y:     25
XXGrab*.OK.width:            80
XXGrab*.OK.FontList: *-helvetica-bold-r-normal--14-*
XXGrab*.OK.labelString: OK
X
XXGrab*.Dismiss.x:   265
XXGrab*.Dismiss.y:     25
XXGrab*.Dismiss.width:            80
XXGrab*.Dismiss.FontList: *-helvetica-bold-r-normal--14-*
XXGrab*.Dismiss.labelString: Dismiss
X
X
X!----------------------------- pervasive resources
XXGrab*FontList: *-helvetica-medium-r-normal--12-*
XXGrab*XmText.FontList: *-helvetica-medium-r-normal--12-*
XXGrab*XmToggleButton.FontList: *-helvetica-medium-r-normal--12-*
XXGrab*XmLabel.FontList: *-helvetica-medium-r-normal--12-*
XXGrab*XmLabel.borderWidth: 0
XXGrab*XmToggleButton.borderWidth: 0
XXGrab*XmForm.borderWidth: 0
XXGrab*XmPushButton.shadowThickness: 3
X
XXGrab*XmToggleButton.marginHeight: 0
XXGrab*XmRowColumn*adjustMargin: false
X
XXGrab*XmForm.background: #a3d1f2
XXGrab*XmRowColumn.background: #a3d1f2
XXGrab*XmLabel.background: #a3d1f2
XXGrab*XmText*background: ivory
XXGrab*XmToggleButton.background: #a3d1f2
X!XGrab*XmPushButton.background: #d3f1ff
X
XXGrab*selstyle.foreground: navy
XXGrab*outputXmFormat.foreground: navy
XXGrab*psOptions.foreground: navy
XXGrab*prOptions.foreground: navy
XXGrab*outputLbl.foreground: navy
XXGrab*foreground: navy
XXGrab*background: #d3f1ff
X
XXGrab*selectColor: navy
XXGrab*highlightColor: navy
XXGrab*highlightThickness: 2
X
X! ========================================================================
X! *
X! * Name - XGrabxm.ad
X! *
X! * Version:	1.2
X! *
X! * ccsid:	@(#)XGrabxm.res	1.2 -06/28/93 09:13:40
X! * from: 	ccs/s.XGrabxm.res
X! * date: 	06/28/93 09:14:48
X! *
X! * Copyright (c) 1991-3 Bruce Schuchardt.
X! * Read the file cpyright.h for full copyright inXmFormation.
X! *
X! *
X! * Description: Application Defaults file for xgrabxm
X! *
X! *========================================================================
X
END_OF_FILE
if test 10437 -ne `wc -c <'xgrabsc.2_3/XGrabxm.res'`; then
    echo shar: \"'xgrabsc.2_3/XGrabxm.res'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/XGrabxm.res'
fi
if test -f 'xgrabsc.2_3/xgrabsc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/xgrabsc.c'\"
else
echo shar: Extracting \"'xgrabsc.2_3/xgrabsc.c'\" \(22410 characters\)
sed "s/^X//" >'xgrabsc.2_3/xgrabsc.c' <<'END_OF_FILE'
X/*========================================================================
X *
X * Name - xgrabsc.c
X *
X * ccs version:	1.31
X *
X * ccsid:	@(#)xgrabsc.c	1.31 - 06/28/93 09:13:50
X * from: 	ccs/s.xgrabsc.c
X * date: 	06/28/93 09:14:49
X *
X * Copyright (c) 1990-93 Bruce Schuchardt.
X * Read the file cpyright.h for full copyright information.
X *
X * XmuClientWindow and TryChildren are Copyright 1989 by the Massachusetts
X * Institute of Technology
X *
X * Permission to use, copy, modify, and distribute this [XmuClientWindow]
X * software and its
X * documentation for any purpose and without fee is hereby granted, provided 
X * that the above copyright notice appear in all copies and that both that 
X * copyright notice and this permission notice appear in supporting 
X * documentation, and that the name of M.I.T. not be used in advertising
X * or publicity pertaining to distribution of the software without specific, 
X * written prior permission. M.I.T. makes no representations about the 
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X *
X * Description:
X *
X * xgrabsc - grab screen images and store in files
X *
X *========================================================================
X */
X
X#if defined(__hpux)
X/* the folks at HP have decided to make things more difficult
X */
X#define XLIB_ILLEGAL_ACCESS
X#endif
X
X
X#include "cpyright.h"
X#include "patchlevel.h"
X#include "config.h"
X#include "checkvm.h"
X#include "cmdopts.h"
X
X#include <stdio.h>
X
X#include <X11/Xos.h>
X#include <X11/Xlib.h>
X#include <X11/Xutil.h>
X#include <X11/cursorfont.h>
X#include <X11/Xatom.h>
X
X#ifdef VMS
X#include "XWDFile.h"
X#else
X#include <X11/XWDFile.h>
X#endif /* VMS */
X
X#ifndef CARD32
X#include <X11/Xmd.h>
X#endif
X
X
X#ifndef NO_VIRTUAL_WINDOW
X#include "virtual.h"
X#endif
X
X
X#define MAX_CELLS  256
X#define TRUE  1
X#define FALSE 0
X
X
Xtypedef enum {
X  NO_DITHER=0,
X  FS_DITHER,
X  MATRIX_DITHER,
X  MATRIX_HALFTONE,
X  MAP_BW
X} ditherType;
X
X
Xtypedef unsigned char byte;
Xtypedef unsigned long dw;
Xtypedef unsigned int  word;
X
X
X
Xtypedef struct {
X  XImage *ximage;
X  word numcells;
X  word red[MAX_CELLS], green[MAX_CELLS], blue[MAX_CELLS];
X  byte used[MAX_CELLS];
X} imageInfo;
X
X
Xtypedef enum {
X  sourceRect,
X  sourceRoot,
X  sourceId,
X  sourceWd,
X  sourceKey,
X  sourceCoords
X} sourceType;
X
Xtypedef enum {
X  puzzleFormat,
X  psFormat,
X  simpleFormat,
X  xwdFormat,
X  pixmapFormat
X} formatType;
X
X
X
X
X#ifdef BCOPY
X#ifdef MEMCPY
X#undef MEMCPY
X#endif
X#define memcpy(x,y,c) bcopy(y,x,c)
X#define memset(x,c)   bzero(x,c) /* well, I only use it for zeroing out stuff */
X#endif
X
X#ifdef MEMCPY
Xchar *memcpy();
Xchar *memset();
X#endif
X
X
X#ifdef VMS
X#define rindex strrchr
X#endif
X
Xstatic Display *hDisplay;
Xstatic int      hScreen;
Xstatic Window   hRoot, vRoot;
Xstatic int      displayCells;
Xstatic char    *programName;
Xstatic char    imageName[64];
X
Xstatic char    *version    = XGRABSC_VERSION;
Xstatic int      patchLevel = XGRABSC_PATCHLEVEL;
Xstatic int      verbose;
X
Xstatic word nr[MAX_CELLS], ng[MAX_CELLS], nb[MAX_CELLS];
X
Xstatic char   hexdigits[] = "0123456789abcdef";
X
Xstatic double pageWidth   = PAPER_WIDTH;
Xstatic double pageHeight  = PAPER_HEIGHT;
Xstatic double horizMargin = HORIZ_MARGIN;
Xstatic double vertMargin  = VERT_MARGIN;
Xstatic double horizInset  = PAPER_WIDTH - HORIZ_MARGIN - HORIZ_MARGIN;
Xstatic double vertInset   = PAPER_HEIGHT - VERT_MARGIN - VERT_MARGIN;
X
Xstatic char        *outfileName;
X
XditherType  DitherKind;
Xint         Halftone;
Xint         ForceBitmap;
X
Xstatic int needColorImageProc;
X
X
X/* most functions have been moved to seperate source include files */
X
X#include "process.hc"         /* color processing     */
X#include "get.hc"             /* get images           */
X#include "mem.hc"             /* memcpy, memset       */
X#include "convert.hc"         /* color->bw conversion */
X#include "write.hc"           /* output functions     */
X
X
X
X
Xstatic Window xgTryChildren();
X
X/* versions of XmuGetClientWindow and screenNumberOfScreen.
X * GetClientWindow is used so Xmu need not be linked (causes problems on
X *  some platforms and configurations if Xt is not used)
X * ScreenNumberOfScreen is used because some X implementations do not
X *  include this function (HP in particular).
X *
X * The following three functions are from the X11R4 MIT distribution and
X * are copyrighted by MIT (see the file header)
X */
X
Xstatic Window GetClientWindow (win)
X    Window win;
X{
X    Atom WM_STATE;
X    Atom type = None;
X    int format;
X    unsigned long nitems, after;
X    unsigned char *data;
X    Window inf;
X
X    WM_STATE = XInternAtom(hDisplay, "WM_STATE", True);
X    if (!WM_STATE)
X	return win;
X    XGetWindowProperty(hDisplay, win, WM_STATE, 0, 0, False, AnyPropertyType,
X		       &type, &format, &nitems, &after, &data);
X    if (type)
X	return win;
X    inf = xgTryChildren(win, WM_STATE);
X    if (!inf)
X	inf = win;
X    return inf;
X}
X
Xstatic Window xgTryChildren (win, WM_STATE)
X    Window win;
X    Atom WM_STATE;
X{
X    Window root, parent;
X    Window *children;
X    unsigned int nchildren;
X    unsigned int i;
X    Atom type = None;
X    int format;
X    unsigned long nitems, after;
X    unsigned char *data;
X    Window inf = 0;
X
X    if (!XQueryTree(hDisplay, win, &root, &parent, &children, &nchildren))
X	return 0;
X    for (i = 0; !inf && (i < nchildren); i++) {
X	XGetWindowProperty(hDisplay, children[i], WM_STATE, 0, 0, False,
X			   AnyPropertyType, &type, &format, &nitems,
X			   &after, &data);
X	if (type)
X	    inf = children[i];
X    }
X    for (i = 0; !inf && (i < nchildren); i++)
X	inf = xgTryChildren(children[i], WM_STATE);
X    if (children) XFree((char *)children);
X    return inf;
X}
X
X
X
Xint ScreenNumberOfScreen (scr)
X    register Screen *scr;
X{
X    register Display *dpy = scr->display;
X    register Screen *dpyscr = dpy->screens;
X    register int i;
X
X    for (i = 0; i < dpy->nscreens; i++, dpyscr++) {
X	if (scr == dpyscr) return i;
X    }
X    return -1;
X}
X
X
X
Xxgrabsc(argc, argv, env)
X  int argc;
X  char *argv[];  /* must have at least argv[0] == programName */
X  char *env;
X{
X  char        *args[100], *arg;
X  extern char *optarg;
X  FILE        *outfile;
X  XRectangle  xrect;
X  XWindowAttributes xwa;
X  imageInfo   image;
X  int         argn, argi, polarity;
X  int	      cmdi, cmdargi;
X  int         doAnd;
X  int         doOr;
X  int         doReverse;
X  int         depth;
X  int         noBell;
X  int         psColor;
X  int         brighten;
X  int         grabServer;
X  int         compress;
X  int         sleepSeconds;
X  int         postSelectSleepSeconds;
X  int         andBits;
X  int         orBits;
X  int         encapsulate;
X  Window      sourceWindow, childWindow, clientWindow, wmWindow, ignored;
X  char       *ptr;
X  char       *display;
X  int         i, x, y;
X  int         brightenFactor;
X  sourceType  source;
X  formatType  outputFormat;
X  int         xpmFormat;
X  int         landscape;
X  int         binary;
X  int	      borders;
X  int	      checkLimits;
X  int	      preview;
X  int         onlyEpsi;
X  int         xwdxy;
X
X
X  outfile     = stdout;
X  outfileName = NULL;
X  display     = NULL;
X  programName = argv[0];
X
X  noBell       = FALSE;
X  brighten     = FALSE;
X  compress     = TRUE;
X  DitherKind   = NO_DITHER;
X  doAnd        = FALSE;
X  doOr         = FALSE;
X  doReverse    = FALSE;
X  encapsulate  = FALSE;
X  ForceBitmap  = FALSE;
X  grabServer   = TRUE;
X  Halftone     = FALSE;
X  landscape    = FALSE;
X  binary       = FALSE;
X  sleepSeconds = 0;
X  postSelectSleepSeconds = 0;
X  verbose      = FALSE;
X  borders      = TRUE;
X#ifdef NO_PRINTER_MEMORY_CHECKS
X  checkLimits  = FALSE;
X#else
X  checkLimits  = TRUE;
X#endif
X  preview      = FALSE;
X  needColorImageProc = DEFAULT_NEED_COLORIMAGE_PROC;
X
X  source       = sourceRect;
X  outputFormat = psFormat;
X  psColor      = FALSE;
X  onlyEpsi     = FALSE;
X  xwdxy	       = FALSE;
X
X
X  /* merge environment options and command line options */
X  args[0] = programName;
X  if (env != NULL) {
X    args[1] = env;
X    for (argn=2; argn<100  &&
X                (args[argn]=(char *)strchr(args[argn-1], ' ')) != NULL;
X	        argn++) {
X      /* remove leading white space */
X      while (*args[argn] == ' ' || *args[argn] == 9) {
X        *(args[argn]) = '\0';
X        args[argn]++;
X      }
X      if (*args[argn] == '|' || *args[argn] == '>') /* dbx leaves these in the cmd line */
X        break;
X    }
X  }
X  else
X    argn = 1;
X
X  for (i=1; i<argc && argn<100; argn++, i++)
X    args[argn] = argv[i];
X
X  
X  for (argi=1; argi<argn; argi++) {
X    arg = args[argi];
X
X    polarity = 1;
X    if (arg[0] == '-') {
X      arg++;
X      if (arg[0] == '-') {
X        arg++;
X        polarity = 0;
X      }
X      else if (arg[0] == 'n' && arg[1] == 'o') {
X        arg += 2;
X	polarity = 0;
X      }
X    }
X
X    for (cmdi=0; cmdi<numCmds; cmdi++) {
X      if (strcmp(arg, commands[cmdi].userstr) == 0)
X        break;
X    }
X    if (cmdi >= numCmds) {
X      fprintf(stderr, "%s: unknown option '%s'\n", programName, arg);
X      exit(3);
X    }
X
X    cmdargi = argi+1;
X    argi += commands[cmdi].numargs;
X    if (argi >= argn) {
X      fprintf(stderr, "%s: not enough arguments for '%s'\n", programName, arg);
X      exit(3);
X    }
X
X    switch (commands[cmdi].command) {
X      case CMD_DISPLAY:
X        display = args[cmdargi];
X        break;
X      case CMD_BELL:
X        noBell = !polarity;
X        break;
X      case CMD_GRABSERVER:
X        grabServer = polarity;
X        break;
X      case CMD_OUTPUT:
X        outfileName = args[cmdargi];
X        break;
X      case CMD_PRESLEEP:
X        sleepSeconds = atoi(args[cmdargi]);
X        if (sleepSeconds < 0) sleepSeconds = 0;
X        break;
X      case CMD_POSTSLEEP:
X        postSelectSleepSeconds = atoi(args[cmdargi]);
X        if (postSelectSleepSeconds < 0) postSelectSleepSeconds = 0;
X        break;
X      case CMD_VERBOSE:
X        verbose = polarity;
X        break;
X      case CMD_BORDERS:
X        borders = polarity;
X	break;
X      case CMD_NOBORDERS:
X        borders = !polarity;
X	break;
X
X
X      case CMD_SOURCE_KEY:
X        source = sourceKey;
X        grabServer = FALSE;
X	break;
X      case CMD_SOURCE_COORDS:
X      { short w,h,x,y;
X	source = sourceCoords;
X        sscanf(args[cmdargi], "%ix%i+%i+%i", &w, &h, &x, &y);
X	xrect.width = w; 
X	xrect.height = h;
X	xrect.x = x;  
X	xrect.y = y;
X	break;
X      }
X
X      case CMD_SOURCE_ID:
X        source = sourceId;
X        sourceWindow = 0;
X        if (!sscanf(args[cmdargi], "%ix", &sourceWindow)) {
X          fprintf(stderr, "%s: invalid window id '%s'\n", programName, args[cmdargi]);
X	  exit(3);
X        }
X        break;
X      case CMD_SOURCE_RECT:
X	source = sourceRect;
X	break;
X      case CMD_SOURCE_ROOT:
X        source = sourceRoot;
X        break;
X      case CMD_SOURCE_WD:
X        source = sourceWd;
X        break;
X
X
X
X      case CMD_AND:
X        doAnd = polarity;
X	if (doAnd)
X          andBits = atoi(args[cmdargi]);
X        break;
X      case CMD_OR:
X        doOr = polarity;
X	if (doOr)
X          orBits = atoi(args[cmdargi]);
X        break;
X      case CMD_NOT:
X        doReverse = polarity;
X	break;
X      case CMD_BRIGHTEN:
X        brighten = polarity;
X	if (brighten) {
X          brightenFactor = atoi(args[cmdargi]);
X          if (brightenFactor <= 0) {
X            fprintf(stderr, "%s: brightening factor must be a positive number\n",
X              programName);
X            exit(3);
X          }
X	  if (brightenFactor != 100)
X            brighten = TRUE;
X	  else
X	    brighten = FALSE;
X	}
X        break;
X
X      case CMD_DITHER_MAP:
X        ForceBitmap = TRUE;
X        Halftone = FALSE;
X        break;
X      case CMD_DITHER_MATRIX:
X        DitherKind = MATRIX_DITHER;
X        Halftone = TRUE;
X        ForceBitmap = FALSE;
X        break;
X      case CMD_DITHER_FS:
X        if (!polarity) {
X          DitherKind = NO_DITHER;
X	  Halftone = ForceBitmap = FALSE;
X        }
X        else {
X          DitherKind = FS_DITHER;
X          Halftone = TRUE;
X          ForceBitmap = FALSE;
X        }
X        break;
X      case CMD_DITHER_HALFTONE:
X        DitherKind = MATRIX_HALFTONE;
X        Halftone = TRUE;
X        ForceBitmap = FALSE;
X        break;
X      case CMD_DITHER_NONE:
X        DitherKind = NO_DITHER;
X	Halftone = ForceBitmap = FALSE;
X	break;
X
X
X
X      case CMD_OUTPUT_PS:
X        psColor = FALSE;
X        outputFormat = psFormat;
X        break;
X      case CMD_OUTPUT_CPS:
X        psColor = polarity;
X        outputFormat = psFormat;
X	break;
X      case CMD_OUTPUT_SIMPLE:
X        outputFormat = simpleFormat;
X        break;
X      case CMD_OUTPUT_XWD:
X        outputFormat = xwdFormat;
X	xwdxy = FALSE;
X        break;
X      case CMD_OUTPUT_XWDXY:
X        outputFormat = xwdFormat;
X	xwdxy = TRUE;
X        break;
X      case CMD_OUTPUT_PIXMAP:
X        xpmFormat = 1;
X        outputFormat = pixmapFormat;
X        break;
X      case CMD_OUTPUT_XPM2:
X        if (polarity) xpmFormat = 2;
X	else if (xpmFormat == 2) xpmFormat = 1;
X	outputFormat = pixmapFormat;
X	break;
X      case CMD_OUTPUT_XPM3:
X        if (polarity) xpmFormat = 3;
X	else if (xpmFormat == 3) xpmFormat = 1;
X	outputFormat = pixmapFormat;
X	break;
X
X      case CMD_OUTPUT_PUZZLE:
X        outputFormat = puzzleFormat;
X        break;
X
X      case CMD_LANDSCAPE:
X        landscape = polarity;
X	outputFormat = psFormat;
X        break;
X      case CMD_BIN:
X        binary = polarity;
X        outputFormat = psFormat;
X	break;
X      case CMD_COMPRESS:
X        compress = polarity;
X        outputFormat = psFormat;
X        break;
X      case CMD_EPS:
X        encapsulate = polarity;
X        outputFormat = psFormat;
X	break;
X      case CMD_PREVIEWONLY:
X        onlyEpsi = polarity;
X	preview = polarity;
X        outputFormat = psFormat;
X	break;
X      case CMD_LIMIT:
X        checkLimits = polarity;
X        outputFormat = psFormat;
X	break;
X      case CMD_PREVIEW:
X        preview = polarity;
X        outputFormat = psFormat;
X	break;  
X      case CMD_PAGE:
X        outputFormat = psFormat;
X        sscanf(args[cmdargi], "%lfx%lf-%lf-%lf",
X	  &pageWidth, &pageHeight, &horizMargin, &vertMargin);
X	horizInset = pageWidth - horizMargin - horizMargin;
X	vertInset  = pageHeight - vertMargin - vertMargin;
X        break;
X      case CMD_COLORPROC:
X        outputFormat = psFormat;
X	needColorImageProc = polarity;
X	break;
X    }
X  }
X
X
X  if (verbose) {
X    fprintf(stderr, "%s: xgrabsc version %s\n", programName, version);
X    fprintf(stderr, "%s:         patchlevel %d\n", programName, patchLevel);
X    fprintf(stderr, "%s:         %s\n\n", programName, Copyright);
X  }
X
X  if (!display) display = (char *)getenv("DISPLAY");
X  hDisplay = XOpenDisplay(display);
X  if (!hDisplay) {
X    fprintf(stderr, "%s: could not open X display\n", programName);
X    exit(3);
X  }
X  hScreen  = DefaultScreen(hDisplay);
X  hRoot    = DefaultRootWindow(hDisplay);
X#ifndef NO_VIRTUAL_WINDOW
X  vRoot    = VirtualRootWindow(hDisplay, hScreen);
X#else
X  vRoot    = hRoot;
X#endif
X
X  depth  = DefaultDepth(hDisplay, hScreen);
X  if (DisplayCells(hDisplay, hScreen) > MAX_CELLS) {
X    fprintf(stderr, "%s: color table is too big for this program\n",
X      programName);
X    XCloseDisplay(hDisplay);
X    exit(3);
X  }
X
X  /* sleep if asked to do so */
X  if (sleepSeconds)
X    sleep(sleepSeconds);
X
X  /* grab the screen if asked to do so */
X  if (grabServer)
X    XGrabServer(hDisplay);
X
X  if (source != sourceId)
X    sourceWindow = hRoot;
X
X  childWindow = (Window)NULL;
X
X  switch (source) {
X    case sourceKey:
X      childWindow =
X#ifdef SELECTION_MASK
X          getWindowWhenKeyIsPressed(SELECTION_MASK)
X#else
X          getWindowWhenKeyIsPressed(ControlMask);
X#endif
X      if (!childWindow) {
X        fprintf(stderr, "%s: unable to find source window\n", programName);
X        XCloseDisplay(hDisplay);
X        exit(3);
X      }
X      break;
X    case sourceCoords:
X      /* already got the xrect in the command line processing section */
X      break;
X    case sourceId:
X      childWindow = sourceWindow;
X      break;
X    case sourceWd:
X      /* grab the image from the root window so menus will show up on top
X       * of the window */
X      childWindow=getWindow();
X      if (!childWindow) {
X        fprintf(stderr, "%s: unable to find source window\n", programName);
X        XCloseDisplay(hDisplay);
X        exit(3);
X      }
X      break;
X    case sourceRoot:
X      xrect.x = xrect.y = 0;
X      xrect.width  = DisplayWidth(hDisplay, hScreen);
X      xrect.height = DisplayHeight(hDisplay, hScreen);
X      break;
X    case sourceRect:
X    default:
X      if (!getRectangle(&xrect)) {
X        XCloseDisplay(hDisplay);
X        exit(3);
X      }
X      break;
X  }
X
X
X
X  clientWindow = (Window)NULL;
X  if (!borders  &&
X      (source == sourceKey || source == sourceWd || source == sourceId)  &&
X      childWindow != hRoot) {
X    /* look for a different client window */
X    clientWindow = GetClientWindow(childWindow);
X    if (clientWindow && clientWindow != childWindow) {
X      if (verbose)
X	fprintf(stderr, "%s: found subwindow 0x%x\n", programName, clientWindow);
X      wmWindow = childWindow;
X      childWindow = clientWindow;
X    }
X  }
X
X  if ((source == sourceKey && childWindow != hRoot) ||
X      source == sourceId ||
X      source == sourceWd) {
X
X    if (childWindow == hRoot) {
X      xrect.x      = 0;
X      xrect.y      = 0;
X      xrect.width  = DisplayWidth(hDisplay, hScreen);
X      xrect.height = DisplayHeight(hDisplay, hScreen);
X    }
X    else {
X
X      /* take the child window (and optional client/wm window info) and
X      * determine the portion of the root window that should be grabbed */
X
X      if (!XGetWindowAttributes(hDisplay, childWindow, &xwa)) {
X        fprintf(stderr, "%s: unable to get window coordinates\n", programName);
X        XCloseDisplay(hDisplay);
X        exit(3);
X      }
X
X      /* get the correct screen and root window for the selected window,
X        * and if it isn't the default, muck with the global state of the
X        * program a bit
X        */
X      i = ScreenNumberOfScreen(xwa.screen);
X      if (i != hScreen) {
X        hRoot   = xwa.root;
X        hScreen = i;
X#ifndef NO_VIRTUAL_WINDOW
X        vRoot   = VirtualRootWindow(hDisplay, hScreen);
X#else
X        vRoot   = hRoot;
X#endif
X        depth   = DefaultDepth(hDisplay, hScreen);
X      }
X
X      sourceWindow = vRoot;
X      if (!borders) {
X        xrect.x      = 0;
X        xrect.y      = 0;
X        xrect.width  = xwa.width;
X        xrect.height = xwa.height;
X      }
X      else {
X        xrect.x      = -xwa.border_width;
X        xrect.y      = -xwa.border_width;
X        xrect.width  = xwa.width + (2 * xwa.border_width);
X        xrect.height = xwa.height + (2 * xwa.border_width);
X      }
X
X      /* translate the rectangle coordinates to root-window coordinates */
X      if (!XTranslateCoordinates(hDisplay, childWindow, vRoot,
X            (int)(xrect.x), (int)(xrect.y), &x, &y, &ignored)) {
X	fprintf(stderr, "%s: unable to translate window coordinates\n", programName);
X	XCloseDisplay(hDisplay);
X	exit(3);
X      }
X      xrect.x = (short)x;   /* why did they make rectangle coords shorts? */
X      xrect.y = (short)y;
X
X
X      if (hRoot == vRoot) {
X        /* do some clipping here, since it's cheap */
X        i = DisplayWidth(hDisplay, hScreen);
X        if (xrect.x + xrect.width > i) {
X          x = i - (int)(xrect.x);
X          if (x < 0) x = 0;
X          xrect.width = x;
X        }
X        i = DisplayHeight(hDisplay, hScreen);
X        if (xrect.y + xrect.height > i) {
X          x = i - (int)(xrect.y);
X          if (x < 0) x = 0;
X          xrect.height = x;
X        }
X      }
X    }
X  }
X
X
X  if (verbose)
X    fprintf(stderr, "%s: bounding box is [x=%d y=%d w=%d h=%d]\n", programName, xrect.x, xrect.y,
X                    xrect.width, xrect.height);
X
X  /* sleep if asked to do so */
X  if (postSelectSleepSeconds) {
X    if (grabServer) {
X      XUngrabServer(hDisplay);
X      XSync(hDisplay, FALSE);
X    }
X    sleep(postSelectSleepSeconds);
X    if (grabServer)
X      XGrabServer(hDisplay);
X  }
X
X
X  /* get the image bounded by the rectangle from the source window */
X  if (!noBell)
X    XBell(hDisplay, 50);
X
X  if (!getImage(&xrect, &image, sourceWindow, childWindow)) {
X    XCloseDisplay(hDisplay);
X    exit(3);
X  }
X  if (grabServer)
X    XUngrabServer(hDisplay);
X
X  if (!noBell) {
X    XBell(hDisplay, 20);
X    XBell(hDisplay, 30);
X  }
X
X  XFlush(hDisplay);
X
X
X
X  /* do color image processing/conversions */
X
X  if (depth >= 2) {
X    if (brighten)
X      brightenColors(&image, brightenFactor);
X    if (doAnd)
X      alterPlanes(&image, TRUE, andBits);
X    if (doOr)
X      alterPlanes(&image, FALSE, orBits);
X  }
X  
X  if (doReverse)
X    reverseColors(&image);
X
X  if (depth >= 2) {
X    if (! (preview && psColor) ) {
X      if (ForceBitmap) {
X        pixmap2bitmap(&image);
X        depth = 1;
X      }
X      else if (Halftone)
X        pixmap2halftone(&image, DitherKind);
X      else
X        compressColormap(&image);
X    }
X    else
X      compressColormap(&image);
X  }
X
X
X  /* open the output stream */
X  if (outfileName) {
X    outfile = fopen(outfileName, "w");
X    if (!outfile) {
X      fprintf(stderr, "%s: ", programName);
X      perror(outfileName);
X      exit(3);
X    }
X    /* form an image name based on the file name */
X    {
X    char *img = rindex(outfileName, '/');
X    if (img) strcpy(imageName, img + 1);
X    else strcpy(imageName, outfileName);
X    ptr = rindex(imageName, '.');  /* Drop the final extension */
X    if (ptr) *ptr = '\0';
X    }
X  }
X  else
X    strcpy(imageName,"unnamed");
X
X
X  /* write to the output stream in the requested format */
X  switch (outputFormat) {
X    case xwdFormat:
X      writeXWD(&image, outfile, xwdxy);
X      break;
X    case simpleFormat:
X      writeSimple(&image, outfile);
X      break;
X    case puzzleFormat:
X      writePuzzle(&image, outfile);
X      break;
X    case pixmapFormat:
X      if (image.ximage->depth <= 1)
X        writeXYPixmap(&image, outfile);
X      else
X        writeZPixmap(xpmFormat, &image, outfile);
X      break;
X    case psFormat:
X    default:
X      if (onlyEpsi)
X        writeOnlyPreview(&image, outfile);
X      else if (psColor && image.ximage->depth >= 2)
X        writeColorPS(&image, outfile, compress, encapsulate,
X	                preview, landscape, binary, checkLimits);
X      else
X        writePostscript(&image, outfile, compress, encapsulate,
X	                preview, landscape, binary, checkLimits);
X      break;
X  }
X
X
X  XDestroyImage(image.ximage);
X  XCloseDisplay(hDisplay);
X  if (outfileName)
X    fclose(outfile);
X
X  exit(0);
X}
X
X
X
X
X
X#ifndef NO_MAIN
Xmain(argc, argv)
X  int argc;
X  char *argv[];
X{
X  char *env;
X  env = (char *)getenv("XGRABSC");
X  xgrabsc(argc, argv, env);
X}
X#endif
END_OF_FILE
if test 22410 -ne `wc -c <'xgrabsc.2_3/xgrabsc.c'`; then
    echo shar: \"'xgrabsc.2_3/xgrabsc.c'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/xgrabsc.c'
fi
if test -f 'xgrabsc.2_3/xgrabxm.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/xgrabxm.c'\"
else
echo shar: Extracting \"'xgrabsc.2_3/xgrabxm.c'\" \(17554 characters\)
sed "s/^X//" >'xgrabsc.2_3/xgrabxm.c' <<'END_OF_FILE'
X/*========================================================================
X *
X * Name - xgrabxm.c
X *
X * Version:	1.5
X *
X * ccsid:	@(#)xgrabxm.c	1.5 -06/28/93 09:13:55
X * from: 	ccs/s.xgrabxm.c
X * date: 	06/28/93 09:14:49
X *
X * Copyright (c) 1990-93 Bruce Schuchardt.
X * Read the file cpyright.h for full copyright information.
X *
X *
X * Description:
X *
X * xgrab.c - interactive front for xgrabsc
X *
X *========================================================================
X */
X#include "cpyright.h"
X#include "patchlevel.h"
X#include "config.h"
X
X#include <stdio.h>
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Shell.h>
X#include <Xm/Xm.h>
X#include <Xm/Form.h>
X#include <Xm/Label.h>
X#include <Xm/PushB.h>
X#include <Xm/RowColumn.h>
X#include <Xm/ToggleB.h>
X#include <Xm/Text.h>
X
Xstatic char *fallback_resources[] = {
X#include "xgrabxm_ad.h"
X  NULL
X  };
X
X
Xstatic Display *hDisplay;
X
Xtypedef enum {
X  HITWIN = 1,
X  STRETCH,
X  KEY,
X  ROOT,
X
X  XWD,
X  XWDXY,
X  PS,
X  BITMAP,
X  BITMAP2,
X  BITMAP3,
X  PUZZLE,
X  SIMPLE,
X
X  NO_DITHER,
X  DITHER,
X  MDITHER,
X  HALFTONE,
X  MAPBW,
X
X  REVERSE,
X
X  TOFILE,
X  TOPRN,
X
X  PS_NORMAL,
X  PS_EPS,
X  PS_EPSI,
X  PS_EPSIONLY,
X  PS_LANDSCAPE
X  
X  } radioType;
X
XradioType encValue = PS_NORMAL;
XradioType cnvValue = NO_DITHER;
XradioType selValue = STRETCH;
XradioType fmtValue = PS;
XradioType outValue = TOFILE;
X
X
X
Xvoid encValueChanged(widget, newValue, tag)
X  Widget widget;
X  void *tag;
X  radioType newValue;
X{
X  if (newValue == encValue) /* turning it off */
X    encValue = PS_NORMAL;
X  else
X    encValue = newValue;
X}
X
X
Xvoid cnvValueChanged(widget, newValue, tag)
X  Widget widget;
X  void *tag;
X  radioType newValue;
X{
X  if (newValue == cnvValue) /* turning it off */
X    cnvValue = NO_DITHER;
X  else
X    cnvValue = newValue;
X}
X
X
Xvoid selValueChanged(widget, newValue, tag)
X  Widget widget;
X  void *tag;
X  radioType newValue;
X{
X  radioType oldValue = selValue;
X  
X  if (newValue == selValue) /* turning it off */
X    selValue = STRETCH;
X  else
X    selValue = newValue;
X#ifdef DEBUGGING
X  fprintf(stderr, "old sel value = %d   new = %d\n", oldValue, selValue);
X#endif
X}
X
Xvoid fmtValueChanged(widget, newValue, tag)
X  Widget widget;
X  void *tag;
X  radioType newValue;
X{
X  if (newValue == fmtValue) /* turning it off */
X    fmtValue = PS;
X  else
X    fmtValue = newValue;
X}
X
Xvoid outValueChanged(widget, newValue, tag)
X  Widget widget;
X  void *tag;
X  radioType newValue;
X{
X  if (newValue == encValue) /* turning it off */
X    outValue = TOFILE;
X  else
X    outValue = newValue;
X}
X
X
XWidget selBtns, formatBtns, psColr, encBtns, psComp, sltext, psltext,
X       psLim, 
X       psBin, borderBtn, horizMargin, vertMargin, pgHeight, pgWidth,
X       cnvBtns, revBtn, brtext, outBtns, filenm, prncmd, dispBtn, hostnm;
XWidget hShell;
X
XXtAppContext appContext;
X
X
Xstatic char* stradi(ptr, i)    /* Add an integer to a string */
X    char* ptr;
X    int i; {
X
X    sprintf(ptr + strlen(ptr), "%d", i);
X    return ptr;
X}
X
Xstatic char* stradw(ptr, s)   /* Add a string to another, with no ws */
X    char* ptr;
X    char* s; {
X
X    char* ou = ptr + strlen(ptr);
X
X    while (isspace(*s)) {
X	++s;
X    }
X    while (*s && !isspace(*s)) {
X	*ou++ = *s++;
X    }
X    *ou = '\0';
X
X    return ptr;
X}
X
X
Xstatic void doGrab() {
X  char tmp[257];
X  char cmdargs[200];
X  char piper[200];
X  char cmd[500];
X  char *txt;
X  int  s, d, len, num;
X  int  sltime, psltime;
X  int  bright;
X  Boolean state;
X
X  cmdargs[0] = '\0';
X  piper[0] = '\0';
X
X  XtVaGetValues(sltext, XmNvalue, &txt, NULL);
X  sltime = atoi(txt);
X  if (sltime < 0) sltime = 0;
X  sprintf(tmp, "-sleep %d ", sltime);
X  strcat(cmdargs, tmp);
X
X  XtVaGetValues(psltext, XmNvalue, &txt, NULL);
X  psltime = atoi(txt);
X  if (psltime < 0) psltime = 0;
X  sprintf(tmp, "-post %d ", psltime);
X  strcat(cmdargs, tmp);
X
X  XtVaGetValues(brtext, XmNvalue, &txt, NULL);
X  bright = atoi(txt);
X  sprintf(tmp, "-brighten %d ", bright);
X  strcat(cmdargs, tmp);
X
X  XtVaGetValues(borderBtn, XmNset, &state, NULL);
X  if (!state)
X    strcat(cmdargs, "-");
X  strcat(cmdargs, "-bdrs ");
X
X  XtVaGetValues(revBtn, XmNset, &state, NULL);
X  if (!state)
X    strcat(cmdargs, "-");
X  strcat(cmdargs, "-reverse ");
X
X  switch (selValue) {
X    case HITWIN:
X      strcat(cmdargs, "-click ");
X      break;
X    case KEY:
X      strcat(cmdargs, "-key ");
X      break;
X    case ROOT:
X      strcat(cmdargs, "-root ");
X      break;
X    case STRETCH:
X    default:
X      strcat(cmdargs, "-stretch ");
X      break;
X  }
X  switch (fmtValue) {
X    case XWD:
X      strcat(cmdargs, "-xwd ");
X      break;
X    case XWDXY:
X      strcat(cmdargs, "-xwdxy ");
X      break;
X    case BITMAP:
X      strcat(cmdargs, "-bm ");
X      break;
X    case BITMAP2:
X      strcat(cmdargs, "-bm2 ");
X      break;
X    case BITMAP3:
X      strcat(cmdargs, "-bm3 ");
X      break;
X    case PUZZLE:
X      strcat(cmdargs, "-puzzle ");
X      break;
X    case SIMPLE:
X      strcat(cmdargs, "-simple ");
X      break;
X    case PS:
X    default:
X      XtVaGetValues(psColr, XmNset, &state, NULL);
X      if (!state)
X        strcat(cmdargs, "-ps ");
X      else
X        strcat(cmdargs, "-cps ");
X
X      switch (encValue) {
X        case PS_EPS:
X          strcat(cmdargs, "-eps ");
X	  break;
X	case PS_EPSI:
X	  strcat(cmdargs, "-preview ");
X	  break;
X	case PS_EPSIONLY:
X	  strcat(cmdargs, "-previewonly ");
X	  break;
X	case PS_LANDSCAPE:
X	  strcat(cmdargs, "-landscape ");
X	  break;
X	default:
X	  break;
X      }
X
X      XtVaGetValues(psComp, XmNset, &state, NULL);
X      if (!state)
X        strcat(cmdargs, "-");
X      strcat(cmdargs, "-compress ");
X      XtVaGetValues(psBin, XmNset, &state, NULL);
X      if (!state)
X        strcat(cmdargs, "-");
X      strcat(cmdargs, "-bin ");
X
X      XtVaGetValues(psLim, XmNset, &state, NULL);
X      if (!state)
X        strcat(cmdargs, "-");
X      strcat(cmdargs, "-limit ");
X
X      strcat(cmdargs, "-page ");
X      XtVaGetValues(pgWidth, XmNvalue, &txt, NULL);
X      if (strlen(txt))    stradw(cmdargs, txt);
X      else                stradi(cmdargs, PAPER_WIDTH);
X      strcat(cmdargs, "x");
X      XtVaGetValues(pgHeight, XmNvalue, &txt, NULL);
X      if (strlen(txt))    stradw(cmdargs, txt);
X      else                stradi(cmdargs, PAPER_HEIGHT);
X      strcat(cmdargs, "-");
X      XtVaGetValues(horizMargin, XmNvalue, &txt, NULL);
X      if (strlen(txt))    stradw(cmdargs, txt);
X      else                stradi(cmdargs, HORIZ_MARGIN);
X      strcat(cmdargs, "-");
X      XtVaGetValues(horizMargin, XmNvalue, &txt, NULL);
X      if (strlen(txt))    stradw(cmdargs, txt);
X      else                stradi(cmdargs, VERT_MARGIN);
X      strcat(cmdargs, " ");
X
X      break;
X  }
X  switch (cnvValue) {
X    case DITHER:
X      strcat(cmdargs, "-dither ");
X      break;
X    case MDITHER:
X      strcat(cmdargs, "-mdither ");
X      break;
X    case HALFTONE:
X      strcat(cmdargs, "-halftone ");
X      break;
X    case MAPBW:
X      strcat(cmdargs, "-bw ");
X      break;
X    default:
X      break;
X  }
X  switch (outValue) {
X    case TOPRN:
X      XtVaGetValues(prncmd, XmNvalue, &txt, NULL);
X      if (strlen(txt)) {
X        strcat(piper, " | ");
X        strcat(piper, txt);
X      }
X      break;
X    case TOFILE:
X    default:
X      strcat(cmdargs, "-o ");
X      XtVaGetValues(filenm, XmNvalue, &txt, NULL);
X      if (strlen(txt)) {
X        strcat(cmdargs, txt);
X#ifdef BUMP_FILENAMES
X	len = strlen(txt);
X	for (s=0; s<len && (txt[s] != '.'); s++)
X	{}
X	strcpy(tmp, txt);
X	tmp[s] = '\0';
X	d = s;
X	while (d > 0  &&  ('0' <= txt[d-1]  &&  txt[d-1] <= '9'))
X	  d--;
X	if ('0' <= txt[d]  && txt[d] <= '9')
X	  num = atoi(&tmp[d]);
X	else
X	  num = 0;
X	num++;
X	sprintf(&tmp[d], "%d", num);
X	strcat(tmp, &txt[s]);
X	XtVaSetValues(filenm, XmNvalue, tmp, NULL);
X#endif
X      }
X      else {
X        strcat(cmdargs, "screen.dmp");
X	XtVaSetValues(filenm, XmNvalue, "screen.dmp", NULL);
X      }
X      strcat(cmdargs, " ");
X      break;
X  }
X
X  XtVaGetValues(dispBtn, XmNset, &state, NULL);
X  if (state) {
X    XtVaGetValues(hostnm, XmNvalue, &txt, NULL);
X    strcat(cmdargs, "-d ");
X    if (strlen(txt)) {
X      strcat(cmdargs, txt);
X      strcat(cmdargs, " ");
X    }
X    else
X      strcat(cmdargs, ":0 ");
X  }
X
X  sprintf(cmd, "xgrabsc %s%s\n", cmdargs, piper);
X#ifdef DEBUGGING
X  fputs(cmd, stderr);
X#else
X  /* try to make the window iconic */
X  XtUnmapWidget(hShell);
X  XSync(hDisplay, False);
X  system(cmd);
X  XtMapWidget(hShell);
X#endif
X}
X
X
X
X
Xstatic void doDismiss() {
X  if (hShell) {
X    XtDestroyWidget(hShell);
X    hShell = NULL;
X    exit(0);
X  }
X}
X
X
X
X
Xstatic void createWindow() {
X  Widget dialog, button, box1, box2, box3, box4, box5, box6;
X
X  dialog = XtVaCreateManagedWidget("dialog", xmFormWidgetClass, hShell,
X           NULL);
X           XtVaCreateManagedWidget("title",  xmLabelWidgetClass, dialog,
X           NULL);
X
X
X  /* selection options */
X  /* input options */
X  box1 = XtVaCreateManagedWidget("box1", xmFormWidgetClass, dialog, NULL);
X
X           XtVaCreateManagedWidget("inputLbl", xmLabelWidgetClass, box1,
X	   NULL);
X
X  dispBtn= XtVaCreateManagedWidget("host", xmToggleButtonWidgetClass, box1,
X	   NULL);
X
X  hostnm = XtVaCreateManagedWidget("hostText", xmTextWidgetClass, box1,
X           NULL);
X
X  if (getenv("DISPLAY"))
X    XtVaSetValues(hostnm, XmNvalue, getenv("DISPLAY"), NULL);
X
X  selBtns = XmCreateRadioBox(box1, "selectiontype", NULL, 0);
X           XtManageChild(selBtns);
X	   
X  button = XtVaCreateManagedWidget("click", xmToggleButtonWidgetClass, selBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, selValueChanged,
X	   HITWIN);
X
X  button = XtVaCreateManagedWidget("stretch", xmToggleButtonWidgetClass, selBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, selValueChanged,
X	   STRETCH);
X
X  button = XtVaCreateManagedWidget("key", xmToggleButtonWidgetClass, selBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, selValueChanged,
X	   KEY);
X
X  button = XtVaCreateManagedWidget("root", xmToggleButtonWidgetClass, selBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, selValueChanged,
X	   ROOT);
X
X           XtVaCreateManagedWidget("sleeplbl", xmLabelWidgetClass, box1,
X           NULL);
X
X  sltext = XtVaCreateManagedWidget("sleeptime", xmTextWidgetClass, box1,
X           NULL);
X
X           XtVaCreateManagedWidget("psleeplbl", xmLabelWidgetClass, box1,
X           NULL);
X
X  psltext = XtVaCreateManagedWidget("psleeptime", xmTextWidgetClass, box1,
X           NULL);
X
X  box2 = XtVaCreateManagedWidget("box2", xmFormWidgetClass, dialog, NULL);
X
X  /* output options */
X           XtVaCreateManagedWidget("outputFormat", xmLabelWidgetClass, box2,
X           NULL);
X
X  formatBtns = XmCreateRadioBox(box2, "formattype", NULL, 0);
X	   XtManageChild(formatBtns);
X	   
X  button = XtVaCreateManagedWidget("xwd", xmToggleButtonWidgetClass, formatBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, fmtValueChanged,
X	   XWD);
X
X  button = XtVaCreateManagedWidget("xwdxy", xmToggleButtonWidgetClass, formatBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, fmtValueChanged,
X	   XWDXY);
X
X  button = XtVaCreateManagedWidget("ps", xmToggleButtonWidgetClass, formatBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, fmtValueChanged,
X	   PS);
X
X  button = XtVaCreateManagedWidget("xpm", xmToggleButtonWidgetClass, formatBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, fmtValueChanged,
X	   BITMAP);
X
X  button = XtVaCreateManagedWidget("xpm2", xmToggleButtonWidgetClass, formatBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, fmtValueChanged,
X	   BITMAP2);
X
X  button = XtVaCreateManagedWidget("xpm3", xmToggleButtonWidgetClass, formatBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, fmtValueChanged,
X	   BITMAP3);
X
X  button = XtVaCreateManagedWidget("puzzle", xmToggleButtonWidgetClass, formatBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, fmtValueChanged,
X	   PUZZLE);
X
X
X
X  /* postscript options */
X  box3 = XtVaCreateManagedWidget("box3", xmFormWidgetClass, dialog, NULL);
X
X           XtVaCreateManagedWidget("psOptions", xmLabelWidgetClass, box3,
X           NULL);
X
X  psComp = XtVaCreateManagedWidget("compress", xmToggleButtonWidgetClass, box3,
X	   NULL);
X
X  psColr = XtVaCreateManagedWidget("color", xmToggleButtonWidgetClass, box3,
X	   NULL);
X
X           XtVaCreateManagedWidget("pageWidth", xmLabelWidgetClass, box3,
X           NULL);
X
X  pgWidth = XtVaCreateManagedWidget("pageWidthText",xmTextWidgetClass, box3,
X           NULL);
X
X           XtVaCreateManagedWidget("pageHeight", xmLabelWidgetClass, box3,
X           NULL);
X
X  pgHeight = XtVaCreateManagedWidget("pageHeightText",xmTextWidgetClass, box3,
X           NULL);
X
X           XtVaCreateManagedWidget("horizMargin", xmLabelWidgetClass, box3,
X           NULL);
X
X  horizMargin = XtVaCreateManagedWidget("horizMarginText",xmTextWidgetClass, box3,
X           NULL);
X
X           XtVaCreateManagedWidget("vertMargin", xmLabelWidgetClass, box3,
X           NULL);
X
X  vertMargin = XtVaCreateManagedWidget("vertMarginText",xmTextWidgetClass, box3,
X           NULL);
X
X
X  encBtns = XmCreateRadioBox(box3, "postscripttype", NULL, 0);
X	   XtManageChild(encBtns);
X	   
X  button = XtVaCreateManagedWidget("portrait", xmToggleButtonWidgetClass, encBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, encValueChanged,
X	   PS_NORMAL);
X
X  button = XtVaCreateManagedWidget("landscape", xmToggleButtonWidgetClass, encBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, encValueChanged,
X	   PS_LANDSCAPE);
X
X  button = XtVaCreateManagedWidget("epsi", xmToggleButtonWidgetClass, encBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, encValueChanged,
X	   PS_EPSI);
X
X/*------------
X  button = XtVaCreateManagedWidget("encap", xmToggleButtonWidgetClass, encBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, encValueChanged,
X	   PS_EPS);
X---------------*/
X
X  button = XtVaCreateManagedWidget("onlyEpsi", xmToggleButtonWidgetClass, encBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, encValueChanged,
X	   PS_EPSIONLY);
X
X  psBin = XtVaCreateManagedWidget("binary", xmToggleButtonWidgetClass, box3,
X	   NULL);
X
X  psLim = XtVaCreateManagedWidget("limit", xmToggleButtonWidgetClass, box3,
X	   NULL);
X
X
X  /* image processing options */
X  box4 = XtVaCreateManagedWidget("box4", xmFormWidgetClass, dialog, NULL);
X
X           XtVaCreateManagedWidget("prOptions", xmLabelWidgetClass, box4,
X           NULL);
X
X           XtVaCreateManagedWidget("brightnessLbl", xmLabelWidgetClass, box4,
X	   NULL);
X  brtext = XtVaCreateManagedWidget("brightnessText", xmTextWidgetClass, box4,
X           NULL);
X
X  revBtn = XtVaCreateManagedWidget("reverse", xmToggleButtonWidgetClass, box4, NULL);
X
X  borderBtn = XtVaCreateManagedWidget("borders", xmToggleButtonWidgetClass, box4, NULL);
X
X
X  box5 = XtVaCreateManagedWidget("box5", xmFormWidgetClass, dialog, NULL);
X
X           XtVaCreateManagedWidget("outputLbl", xmLabelWidgetClass, box5,
X	   NULL);
X
X  outBtns = XmCreateRadioBox(box5, "outputtype", NULL, 0);
X	   XtManageChild(outBtns);
X
X
X  button = XtVaCreateManagedWidget("file", xmToggleButtonWidgetClass, outBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, outValueChanged,
X	   TOFILE);
X
X  filenm = XtVaCreateManagedWidget("fileText", xmTextWidgetClass, box5,
X           NULL);
X
X  button = XtVaCreateManagedWidget("printer", xmToggleButtonWidgetClass, outBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, outValueChanged,
X	   TOPRN);
X
X  prncmd = XtVaCreateManagedWidget("printerText", xmTextWidgetClass, box5,
X           NULL);
X
X
X  cnvBtns = XmCreateRadioBox(dialog, "converttype", NULL, 0);
X
X           XtVaSetValues(cnvBtns,
X	   XmNorientation, XmHORIZONTAL,
X	   NULL);
X	   XtManageChild(cnvBtns);
X	   
X  button = XtVaCreateManagedWidget("nodither", xmToggleButtonWidgetClass, cnvBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, cnvValueChanged,
X	   NO_DITHER);
X
X  button = XtVaCreateManagedWidget("dither", xmToggleButtonWidgetClass, cnvBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, cnvValueChanged,
X	   DITHER);
X
X  button = XtVaCreateManagedWidget("mdither", xmToggleButtonWidgetClass, cnvBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, cnvValueChanged,
X	   MDITHER);
X
X  button = XtVaCreateManagedWidget("halftone", xmToggleButtonWidgetClass, cnvBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, cnvValueChanged,
X	   HALFTONE);
X
X  button = XtVaCreateManagedWidget("mapbw", xmToggleButtonWidgetClass, cnvBtns,
X	   NULL);
X           XtAddCallback(button, XmNvalueChangedCallback, cnvValueChanged,
X	   MAPBW);
X
X  box6 = XtVaCreateManagedWidget("box6", xmFormWidgetClass, dialog, NULL);
X
X  XtVaCreateManagedWidget("splat", xmLabelWidgetClass, box6, NULL);
X  
X  button = XtVaCreateManagedWidget("OK", xmPushButtonWidgetClass, box6, NULL);
X  XtAddCallback(button, XmNactivateCallback, doGrab, NULL);
X
X  button = XtVaCreateManagedWidget("Dismiss", xmPushButtonWidgetClass, box6, NULL);
X  XtAddCallback(button, XmNactivateCallback, doDismiss, NULL);
X
X}
X
X
X
Xint main(argc, argv, envp)
X  int argc;
X  char *argv[];
X  char *envp;
X{
X  puts("X-Windows Screen Grabber");
X  puts(Copyright);
X  puts("");
X
X
X  hShell = XtAppInitialize(&appContext, "XGrab", NULL, 0, &argc, argv,
X     fallback_resources, NULL, 0);
X
X  hDisplay = XtDisplay(hShell);
X  createWindow();
X
X  XtRealizeWidget(hShell);
X  XtAppMainLoop(appContext);
X}
END_OF_FILE
if test 17554 -ne `wc -c <'xgrabsc.2_3/xgrabxm.c'`; then
    echo shar: \"'xgrabsc.2_3/xgrabxm.c'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/xgrabxm.c'
fi
echo shar: End of archive 2 \(of 5\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
