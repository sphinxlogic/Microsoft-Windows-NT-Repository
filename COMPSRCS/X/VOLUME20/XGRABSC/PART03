Newsgroups: comp.sources.x
From: bruce@servio.slc.com (Bruce Schuchardt)
Subject: v20i102:  xgrabsc - Grab and dump X displays, Part03/05
Message-ID: <1993Aug4.171711.9496@sparky.sterling.com>
X-Md4-Signature: 47729f2bcb97ec2ba55a8c45a4cf5d4d
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Wed, 4 Aug 1993 17:17:11 GMT
Approved: chris@sterling.com

Submitted-by: bruce@servio.slc.com (Bruce Schuchardt)
Posting-number: Volume 20, Issue 102
Archive-name: xgrabsc/part03
Environment: X11
Supersedes: xgrabsc: Volume 18, Issue 52-56

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 5)."
# Contents:  xgrabsc.2_3/XGrabxaw.res xgrabsc.2_3/process.hc
#   xgrabsc.2_3/virtual.h xgrabsc.2_3/xgrabsc.man
#   xgrabsc.2_3/xgrabxaw.c
# Wrapped by bruce@trout on Mon Jun 28 09:14:50 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'xgrabsc.2_3/XGrabxaw.res' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/XGrabxaw.res'\"
else
echo shar: Extracting \"'xgrabsc.2_3/XGrabxaw.res'\" \(9956 characters\)
sed "s/^X//" >'xgrabsc.2_3/XGrabxaw.res' <<'END_OF_FILE'
X#include "config.h"
X
XXGrab*.title.label: X-Windows Screen Grabber
XXGrab*.title.font:   *-times-medium-r-normal--18-*
XXGrab*.title.horizDistance: 105
X
X!----------------------------box 1
X
XXGrab*.box1.horizDistance: 0
XXGrab*.box1.vertDistance:  35
X
XXGrab*.inputLbl.horizDistance:     5
XXGrab*.inputLbl.vertDistance:      0
XXGrab*.inputLbl.font: *-helvetica-medium-o-normal--14-*
XXGrab*.inputLbl.label: Input Options-------------------------------------
X
XXGrab*.click.horizDistance:   10
XXGrab*.click.vertDistance:    25
XXGrab*.click.label: Click on Window
X
XXGrab*.stretch.horizDistance:   135
XXGrab*.stretch.vertDistance:     25
XXGrab*.stretch.label: Stretch Rectangle
XXGrab*.stretch.state: 1
X
XXGrab*.key.horizDistance:   265
XXGrab*.key.vertDistance:     25
XXGrab*.key.label: Wait for Control key
X
XXGrab*.root.horizDistance: 10
XXGrab*.root.vertDistance:  55
XXGrab*.root.label: Grab Whole Screen
X
XXGrab*.sleeplbl.horizDistance: 10
XXGrab*.sleeplbl.vertDistance:  85
XXGrab*.sleeplbl.label: Sleep before starting
X
XXGrab*.sleeptime.fromHoriz:      sleeplbl
XXGrab*.sleeptime.horizDistance:     5
XXGrab*.sleeptime.vertDistance:     85
XXGrab*.sleeptime.width:            30
XXGrab*.sleeptime*string: DEFAULT_PRESLEEP
X
XXGrab*.psleeplbl.fromHoriz:	sleeptime
XXGrab*.psleeplbl.horizDistance:   10
XXGrab*.psleeplbl.vertDistance:    85
XXGrab*.psleeplbl.label: Sleep after selecting
X
XXGrab*.psleeptime.fromHoriz:	psleeplbl
XXGrab*.psleeptime.horizDistance:     5
XXGrab*.psleeptime.vertDistance:     85
XXGrab*.psleeptime.width:            30
XXGrab*.psleeptime*string: DEFAULT_POSTSLEEP
X
XXGrab*.host.horizDistance:   10
XXGrab*.host.vertDistance:   115
XXGrab*.host.label: Use Alternate Display:
XXGrab*.host.shapeStyle: oval
XXGrab*.host.width:	    140
XXGrab*.host.state: 0
X
XXGrab*.hostText.fromHoriz:	host
XXGrab*.hostText.horizDistance:     5
XXGrab*.hostText.vertDistance:    115
X! xgrab sets DISPLAY value into this widget
X! XGrab*.hostText*string: :0
X
X
X!----------------------------box 2
XXGrab*.box2.horizDistance:   0
XXGrab*.box2.vertDistance:  180
X
XXGrab*.outputFormat.horizDistance:   5
XXGrab*.outputFormat.vertDistance:    0
XXGrab*.outputFormat.font: *-helvetica-medium-o-normal--12-*
XXGrab*.outputFormat.label: Output Format------------------------------------------
X
XXGrab*.ps.horizDistance:    10
XXGrab*.ps.vertDistance:     25
XXGrab*.ps.label: PostScript
XXGrab*.ps.state: 1
X
XXGrab*.puzzle.horizDistance:    87
XXGrab*.puzzle.vertDistance:     25
XXGrab*.puzzle.label: Puzzle
X
XXGrab*.xwd.horizDistance:   142
XXGrab*.xwd.vertDistance:    25
XXGrab*.xwd.label: X Window Dump
X
XXGrab*.xyxwd.horizDistance:    252
XXGrab*.xyxwd.vertDistance:     25
XXGrab*.xyxwd.label: XWD/xy
X
XXGrab*.xpm.horizDistance:    10
XXGrab*.xpm.vertDistance:     55
XXGrab*.xpm.label: Bitmap/XPM
X
XXGrab*.xpm2.horizDistance:    95
XXGrab*.xpm2.vertDistance:     55
XXGrab*.xpm2.label: Bm/XPM2
X
XXGrab*.xpm3.horizDistance:   165
XXGrab*.xpm3.vertDistance:     55
XXGrab*.xpm3.label: Bm/XPM3
X
X!----------------------------box 3
XXGrab*.box3.horizDistance:   0
XXGrab*.box3.vertDistance:  270
X
XXGrab*.psOptions.horizDistance:   5
XXGrab*.psOptions.vertDistance:    0
XXGrab*.psOptions.font: *-helvetica-medium-o-normal--12-*
XXGrab*.psOptions.label: PostScript Options---------------------------------------
X
XXGrab*.compress.horizDistance:   10
XXGrab*.compress.vertDistance:    25 
XXGrab*.compress.shapeStyle: oval
XXGrab*.compress.label: Compress
XXGrab*.compress.state: 1
X
XXGrab*.color.fromHoriz: compress
XXGrab*.color.horizDistance:    10
XXGrab*.color.vertDistance:     25
XXGrab*.color.shapeStyle: oval
XXGrab*.color.label: Color Output
X
XXGrab*.binary.fromHoriz: color
XXGrab*.binary.horizDistance: 10
XXGrab*.binary.vertDistance: 25
XXGrab*.binary.shapeStyle: oval
XXGrab*.binary.label: Binary
X
XXGrab*.limit.fromHoriz: binary
XXGrab*.limit.horizDistance: 10
XXGrab*.limit.vertDistance: 25
XXGrab*.limit.shapeStyle: oval
X#if defined(NO_PRINTER_MEMORY_CHECKS)
XXGrab*.limit.state: 0
X#else
XXGrab*.limit.state: 1
X#endif
XXGrab*.limit.label: Limit Check
X
XXGrab*.landscape.horizDistance: 10
XXGrab*.landscape.vertDistance: 55
XXGrab*.landscape.width: 80
XXGrab*.landscape.label: Landscape
X
XXGrab*.epsi.fromHoriz: landscape
XXGrab*.epsi.horizDistance:    10
XXGrab*.epsi.vertDistance:     55
XXGrab*.epsi.label: PS Figure
X
XXGrab*.onlyEpsi.fromHoriz: epsi
XXGrab*.onlyEpsi.horizDistance:    10
XXGrab*.onlyEpsi.vertDistance:     55
XXGrab*.onlyEpsi.label: Preview Only
X
XXGrab*.pageWidth.horizDistance: 10
XXGrab*.pageWidth.vertDistance:  85
XXGrab*.pageWidth.label: Paper Width
X
XXGrab*.pageWidthText.fromHoriz: pageWidth
XXGrab*.pageWidthText.horizDistance: 0
XXGrab*.pageWidthText.vertDistance:  85
XXGrab*.pageWidthText.width: 35
XXGrab*.pageWidthText*string: PAPER_WIDTH
X
XXGrab*.pageHeight.fromHoriz:	pageWidthText
XXGrab*.pageHeight.horizDistance: 2
XXGrab*.pageHeight.vertDistance:  85
XXGrab*.pageHeight.label: Height
X
XXGrab*.pageHeightText.fromHoriz: pageHeight
XXGrab*.pageHeightText.horizDistance:  0
XXGrab*.pageHeightText.vertDistance:  85
XXGrab*.pageHeightText.width: 35
XXGrab*.pageHeightText*string: PAPER_HEIGHT
X
XXGrab*.horizMargin.fromHoriz: pageHeightText
XXGrab*.horizMargin.horizDistance:  2
XXGrab*.horizMargin.vertDistance:  85
XXGrab*.horizMargin.label: Margin Width
X
XXGrab*.horizMarginText.fromHoriz: horizMargin
XXGrab*.horizMarginText.horizDistance:  0
XXGrab*.horizMarginText.vertDistance:  85
XXGrab*.horizMarginText.width: 35
XXGrab*.horizMarginText*string: HORIZ_MARGIN
X
XXGrab*.vertMargin.fromHoriz: horizMarginText
XXGrab*.vertMargin.horizDistance:  2
XXGrab*.vertMargin.vertDistance:  85
XXGrab*.vertMargin.label:  Height
X
XXGrab*.vertMarginText.fromHoriz: vertMargin
XXGrab*.vertMarginText.horizDistance:  0
XXGrab*.vertMarginText.vertDistance:  85
XXGrab*.vertMarginText.width: 35
XXGrab*.vertMarginText*string: VERT_MARGIN
X
X!----------------------------box 4
XXGrab*.box4.horizDistance: 0
XXGrab*.box4.vertDistance: 385
X
XXGrab*.prOptions.horizDistance:   5
XXGrab*.prOptions.vertDistance:    0
XXGrab*.prOptions.font: *-helvetica-medium-o-normal--12-*
XXGrab*.prOptions.label: Image Processing Options-----
X
XXGrab*.borders.horizDistance:   10
XXGrab*.borders.vertDistance:    25
XXGrab*.borders.shapeStyle: oval
XXGrab*.borders.label: Include Borders
XXGrab*.borders.width:          105
XXGrab*.borders.state:            1
X
XXGrab*.reverse.horizDistance:   10
XXGrab*.reverse.vertDistance:    55
XXGrab*.reverse.shapeStyle: oval
XXGrab*.reverse.label: Reverse Colors
XXGrab*.reverse.width:           105
X
XXGrab*.brightnessLbl.horizDistance:   10
XXGrab*.brightnessLbl.vertDistance:    85
XXGrab*.brightnessLbl.label: Brightness
X
XXGrab*.brightnessText.horizDistance:   85
XXGrab*.brightnessText.vertDistance:    85
XXGrab*.brightnessText.width:           30
XXGrab*.brightnessText*string: 100
X
XXGrab*.dither.horizDistance:   10
XXGrab*.dither.vertDistance:   115
XXGrab*.dither.label: Dither
X
XXGrab*.mdither.horizDistance:   62
XXGrab*.mdither.vertDistance:   115
XXGrab*.mdither.label: M-Dither
X
XXGrab*.halftone.horizDistance:  132
XXGrab*.halftone.vertDistance:   115
XXGrab*.halftone.label: Halftone
X
XXGrab*.mapbw.horizDistance:   10
XXGrab*.mapbw.vertDistance:    140
XXGrab*.mapbw.label: Map to B/W
X
X
X!----------------------------box 5
XXGrab*.box5.fromHoriz: box4
XXGrab*.box5.horizDistance: 5
XXGrab*.box5.vertDistance:  385
X
XXGrab*.outputLbl.horizDistance:     5
XXGrab*.outputLbl.vertDistance:      0
XXGrab*.outputLbl.font: *-helvetica-medium-o-normal--12-*
XXGrab*.outputLbl.label: Output Options--------------
X
XXGrab*.file.horizDistance:   10
XXGrab*.file.vertDistance:    25
XXGrab*.file.label: To File:
XXGrab*.file.state: 1
X
XXGrab*.fileText.horizDistance:   100
XXGrab*.fileText.vertDistance:    25
XXGrab*.fileText.width: 100
XXGrab*.fileText*string: DEFAULT_FILENAME
X
XXGrab*.printer.horizDistance:    10
XXGrab*.printer.vertDistance:     55
XXGrab*.printer.label: To Command:
X
XXGrab*.printerText.horizDistance:    100
XXGrab*.printerText.vertDistance:     55
XXGrab*.printerText.width: 100
XXGrab*.printerText*string: DEFAULT_COMMAND
X
X
X!----------------------------box 6
XXGrab*.box6.horizDistance:   0
XXGrab*.box6.vertDistance:  547
X
X
XXGrab*.splat.label: -----------------------------------------------------
X
XXGrab*.OK.horizDistance:   110
XXGrab*.OK.vertDistance:     25
XXGrab*.OK.width:            80
XXGrab*.OK.font: *-helvetica-bold-r-normal--14-*
XXGrab*.OK.label: OK
X
XXGrab*.Dismiss.horizDistance:   265
XXGrab*.Dismiss.vertDistance:     25
XXGrab*.Dismiss.width:            80
XXGrab*.Dismiss.font: *-helvetica-bold-r-normal--14-*
XXGrab*.Dismiss.label: Dismiss
X
X
X!----------------------------- pervasive resources
XXGrab*font: *-helvetica-medium-r-normal--12-*
XXGrab*Label.borderWidth: 0
XXGrab*Toggle.borderWidth: 1
XXGrab*Form.borderWidth: 0
XXGrab*Toggle.shapeStyle: rectangle
XXGrab*Command.shapeStyle: oval
XXGrab*Text.editType: edit
X
XXGrab*Form.title.right: chainRight
XXGrab*Form.box5.right: chainRight
XXGrab*Form.box5.Text.right: chainRight
XXGrab*Form.box6.right: chainRight
XXGrab*Form.box6.Dismiss.left: chainRight
XXGrab*Form.box6.Dismiss.right: chainRight
X
XXGrab*Form.Form.*.left: chainLeft
XXGrab*Form.Form.*.right: chainLeft
XXGrab*Form.Form.*.top: chainTop
XXGrab*Form.Form.*.bottom: chainTop
X
XXGrab*Form.background: #a3d1f2
XXGrab*Label.background: #a3d1f2
X!XGrab*Text*background: #d3f1ff
XXGrab*Toggle.background: ivory
X!XGrab*Command.background: #d3f1ff
X
XXGrab*selstyle.foreground: navy
XXGrab*outputFormat.foreground: navy
XXGrab*psOptions.foreground: navy
XXGrab*prOptions.foreground: navy
XXGrab*outputLbl.foreground: navy
XXGrab*foreground: navy
XXGrab*background: #d3f1ff
X
X! ========================================================================
X! *
X! * Name - XGrabxaw.res
X! *
X! * Version:	1.2
X! *
X! * ccsid:	@(#)XGrabxaw.res	1.2 - 06/28/93 09:13:39
X! * from: 	ccs/s.XGrabxaw.res
X! * date: 	06/28/93 09:14:48
X! *
X! * Copyright (c) 1991-2 Bruce Schuchardt.
X! * Read the file cpyright.h for full copyright information.
X! *
X! *
X! * Description: Application Defaults file for xgrab
X! *
X! *========================================================================
X
END_OF_FILE
if test 9956 -ne `wc -c <'xgrabsc.2_3/XGrabxaw.res'`; then
    echo shar: \"'xgrabsc.2_3/XGrabxaw.res'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/XGrabxaw.res'
fi
if test -f 'xgrabsc.2_3/process.hc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/process.hc'\"
else
echo shar: Extracting \"'xgrabsc.2_3/process.hc'\" \(7583 characters\)
sed "s/^X//" >'xgrabsc.2_3/process.hc' <<'END_OF_FILE'
X/*========================================================================
X *
X * Name - process.hc
X *
X * ccs version:	1.2
X *
X * ccsid:	@(#)process.hc	1.2 - 07/06/92 10:52:51
X * from: 	ccs/s.process.hc
X * date: 	06/28/93 09:14:49
X *
X * Description:  color processing functions for xgrabsc
X *
X *               see cpyright.h for copyright information
X *
X *
X *========================================================================
X */
X
X/*
X * Alter colors by setting or clearing bits in rgb values.
X * This effectively reduces the depth of the image, causing the
X * number of colors used to be reduced.  Equivalent colors are
X * merged in the image, and the used flags of remapped colors are
X * cleared.
X *
X * The number of eliminated colormap entries is returned.  The colormap
X * is not compressed.
X */
XalterPlanes(image, modeIsAnd, bits)
X  imageInfo *image;
X  int modeIsAnd;      /* if TRUE, combine mask with AND; if FALSE, use OR */
X  unsigned int bits;
X{
X  int nc, cidx, ridx, h, w;
X  long p;
X  XImage *ximage = image->ximage;
X  long map[MAX_CELLS];
X  int remapCount;
X  word mask;
X
X  if (ximage->depth <= 1)
X    return 0;
X
X  mask = 0xFFFF ^ ((1 << (bits+8)) - 1);
X  if (!modeIsAnd)
X    mask = ~mask & 0xFFFF;
X
X  if (verbose) {
X    fprintf(stderr, "%s: %s color with mask %x...", programName,
X            modeIsAnd? "ANDing" : "ORing", mask);
X    fflush(stderr);
X  }
X
X  nc = image->numcells;
X  if (modeIsAnd)
X    for (cidx=0; cidx<nc; cidx++) {
X      nr[cidx] = image->red[cidx]   & mask;
X      ng[cidx] = image->green[cidx] & mask;
X      nb[cidx] = image->blue[cidx]  & mask;
X    }
X  else
X    for (cidx=0; cidx<nc; cidx++) {
X      nr[cidx] = image->red[cidx]   | mask;
X      ng[cidx] = image->green[cidx] | mask;
X      nb[cidx] = image->blue[cidx]  | mask;
X    }
X
X  /* now eliminate redundant colors */
X  for (cidx=0; cidx<nc; cidx++)
X    map[cidx] = cidx;
X  remapCount = 0;
X  for (cidx=0; cidx<nc; cidx++)
X    if (image->used[cidx])
X      for (ridx=cidx+1; ridx<nc; ridx++)
X        if (image->used[ridx]  &&
X            nr[cidx]==nr[ridx] &&
X            ng[cidx]==ng[ridx] &&
X            nb[cidx]==nb[ridx]) {
X          /* the colors match - remap this pixel to the one we're scanning with */
X          map[ridx] = cidx;
X          image->used[ridx] = FALSE;
X          remapCount++;
X        }
X
X  memcpy((char *)image->red,   (char *)nr, nc*sizeof(word));
X  memcpy((char *)image->green, (char *)ng, nc*sizeof(word));
X  memcpy((char *)image->blue,  (char *)nb, nc*sizeof(word));
X
X  /* remap redundant pixels in the image */
X  if (remapCount)
X    for (h=0; h<ximage->height; h++)
X      for (w=0; w<ximage->width; w++) {
X        p = XGetPixel(ximage, w, h);
X        if (p != map[p])
X          XPutPixel(ximage, w, h, map[p]);
X      }
X
X  if (verbose)
X    fprintf(stderr, "  %d colors remapped\n", remapCount, nc);
X  return remapCount;
X}
X
X
X
X
X
X/* Brighten or darken colors in the image by the given amount ('percent').
X * The amount is an integer that, if less than 100 will darken the image
X * and if greater than 100 will brighten the image.  After modifying
X * colors equivalent colors are merged (as in alterPlanes).  The number
X * of eliminated colors is returned.
X */
XbrightenColors(image, percent)
X  imageInfo *image;
X  int percent;
X{
X  int nc, cidx, ridx, h, w;
X  long p;
X  XImage *ximage = image->ximage;
X  float  adjustment;
X  long map[MAX_CELLS];
X  int remapCount;
X  dw new;
X
X  if (ximage->depth <= 1)
X    return 0;
X
X  if (verbose) {
X    fprintf(stderr, "%s: adjusting intensity by %d...", programName, percent);
X    fflush(stderr);
X  }
X
X  adjustment = (float)percent / 100.0;
X  nc = image->numcells;
X  for (cidx=0; cidx<nc; cidx++) {
X    new = image->red[cidx] * adjustment;
X    if (new > (dw)0xFFFF) new = (dw)0xFFFF;
X    nr[cidx] = new;
X    new = image->green[cidx] * adjustment;
X    if (new > (dw)0xFFFF) new = (dw)0xFFFF;
X    ng[cidx] = new;
X    new = image->blue[cidx] * adjustment;
X    if (new > (dw)0xFFFF) new = (dw)0xFFFF;
X    nb[cidx] = new;
X  }
X
X  /* now eliminate redundant colors */
X  for (cidx=0; cidx<nc; cidx++)
X    map[cidx] = cidx;
X  remapCount = 0;
X  for (cidx=0; cidx<nc; cidx++)
X    if (image->used[cidx])
X      for (ridx=cidx+1; ridx<nc; ridx++)
X        if (image->used[ridx]  &&
X            nr[cidx]==nr[ridx] &&
X            ng[cidx]==ng[ridx] &&
X            nb[cidx]==nb[ridx]) {
X          map[ridx] = cidx;
X          image->used[ridx] = FALSE;
X          remapCount++;
X        }
X
X  memcpy((char *)image->red,   (char *)nr, nc*sizeof(word));
X  memcpy((char *)image->green, (char *)ng, nc*sizeof(word));
X  memcpy((char *)image->blue,  (char *)nb, nc*sizeof(word));
X
X  /* remap redundant pixels in the image */
X  if (remapCount)
X    for (h=0; h<ximage->height; h++)
X      for (w=0; w<ximage->width; w++) {
X        p = XGetPixel(ximage, w, h);
X        if (p != map[p])
X          XPutPixel(ximage, w, h, map[p]);
X      }
X
X
X  if (verbose)
X    fprintf(stderr, "  %d colors remapped\n", remapCount, nc);
X
X  return remapCount;
X}
X
X
X
X
X
X/* Reverse the colors in the image */
XreverseColors(image)
X  imageInfo *image;
X{
X  int nc, cidx;
X  long size, idx;
X  unsigned char *data;
X  XImage *ximage;
X  int map[2];
X
X  if (verbose) {
X    fprintf(stderr, "%s: reversing colors...", programName);
X    fflush(stderr);
X  }
X
X
X  if (image->ximage->depth <= 1) {
X    /* for black and white images, just reverse the bits */
X    ximage = image->ximage;
X    data = (unsigned char *)ximage->data;
X    size = ximage->bytes_per_line * ximage->height;
X    for (idx=0; idx<size; idx++, data++)
X      *data = ~(*data);
X  }
X  else {
X    /* for other images, reverse the color values in the color table */
X    nc = image->numcells;
X    for (cidx=0; cidx<nc; cidx++) {
X      image->red[cidx]   = (unsigned short)~((unsigned short)(image->red[cidx]));
X      image->blue[cidx]  = (unsigned short)~((unsigned short)(image->blue[cidx]));
X      image->green[cidx] = (unsigned short)~((unsigned short)(image->green[cidx]));
X    }
X  }
X}
X
X
X
X
X
X/*
X * Compress the colors used in an XImage so that all pixel values are
X * adjacent.  Alters the rgb color tables and the XImage data values.
X */
XcompressColormap(image)
X  imageInfo *image;
X{
X  XImage *ximage = image->ximage;
X  long map[MAX_CELLS];
X  int  ncolors, w, h, m;
X  long p;
X
X  if (ximage->depth <= 1  ||  image->numcells > MAX_CELLS)
X    return;
X
X  if (verbose) {
X    fprintf(stderr, "%s: compressing colormap...", programName);
X    fflush(stderr);
X  }
X  ncolors = 0;
X  /* map[] is indexed by old pixel values.  It delivers new, compressed,
X   * pixel values. */
X  for (m=0; m<MAX_CELLS; m++) map[m] = MAX_CELLS+1;
X  /* bludgeon through the whole image and remap each pixel value */
X  for (h=0; h<ximage->height; h++) {
X    for (w=0; w<ximage->width; w++) {
X      /* Get the pixel index and see if it has been used or not.
X       * Then remap the pixel */
X      p = XGetPixel(ximage, w, h);
X      if (map[p] == MAX_CELLS+1) {
X        map[p] = ncolors;
X        ncolors++;
X      }
X      if (p != map[p])
X        XPutPixel(ximage, w, h, map[p]);
X    }
X  }
X  /* now compress the color table */
X  memset((char *)image->used, 0, MAX_CELLS);
X  for (m=0; m<MAX_CELLS; m++) {
X    if (map[m] != MAX_CELLS+1) {
X      p = map[m];
X      nr[p] = image->red[m];
X      ng[p] = image->green[m];
X      nb[p] = image->blue[m];
X      image->used[p] = TRUE;
X    }
X  }
X  memcpy((char *)image->red,   (char *)nr, ncolors*sizeof(word));
X  memcpy((char *)image->green, (char *)ng, ncolors*sizeof(word));
X  memcpy((char *)image->blue,  (char *)nb, ncolors*sizeof(word));
X  image->numcells = ncolors;
X  if (verbose)
X    fprintf(stderr, "  %d colors used\n", ncolors);
X}
X
END_OF_FILE
if test 7583 -ne `wc -c <'xgrabsc.2_3/process.hc'`; then
    echo shar: \"'xgrabsc.2_3/process.hc'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/process.hc'
fi
if test -f 'xgrabsc.2_3/virtual.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/virtual.h'\"
else
echo shar: Extracting \"'xgrabsc.2_3/virtual.h'\" \(2379 characters\)
sed "s/^X//" >'xgrabsc.2_3/virtual.h' <<'END_OF_FILE'
X/*
X * Name - virtual.h
X *
X * ccs version:	1.3
X *
X * ccsid:	@(#)virtual.h	1.3 - 07/06/92 10:52:59
X * from: 	ccs/s.virtual.h
X * date: 	06/28/93 09:14:49
X *
X *--- original header:
X *
X * vroot.h -- Virtual Root Window handling header file
X *
X * This header file redefines the X11 macros RootWindow and DefaultRootWindow,
X * making them look for a virtual root window as provided by certain `virtual'
X * window managers like swm and tvtwm. If none is found, the ordinary root
X * window is returned, thus retaining backward compatibility with standard
X * window managers.
X * The function implementing the virtual root lookup remembers the result of
X * its last invocation to avoid overhead in the case of repeated calls
X * on the same display and screen arguments.
X * The lookup code itself is taken from Tom LaStrange's ssetroot program.
X *
X * Most simple root window changing X programs can be converted to using
X * virtual roots by just including
X *
X * #include "vroot.h"
X *
X * after all the X11 header files.  It has been tested on such popular
X * X clients as xphoon, xfroot, xloadimage, and xaqua.
X *
X * Andreas Stolcke (stolcke@ICSI.Berkeley.EDU), 9/7/90
X */
X
Xstatic Window
XVirtualRootWindow(dpy, screen)
XDisplay *dpy;
X{
X	static Display *save_dpy = (Display *)0;
X	static int save_screen = -1;
X	static Window root = (Window)0;
X
X	Atom __SWM_VROOT = None;
X	int i;
X	Window rootReturn, parentReturn, *children;
X	unsigned int numChildren;
X
X	if ( dpy != save_dpy || screen != save_screen ) {
X		root = RootWindow(dpy, screen);
X
X		/* go look for a virtual root */
X		__SWM_VROOT = XInternAtom(dpy, "__SWM_VROOT", False);
X		XQueryTree(dpy, root, &rootReturn, &parentReturn,
X				 &children, &numChildren);
X		for (i = 0; i < numChildren; i++) {
X			Atom actual_type;
X			int actual_format;
X			long nitems, bytesafter;
X			Window *newRoot = (Window *)0;
X
X			if (XGetWindowProperty(dpy, children[i], __SWM_VROOT,
X				0, 1, False, XA_WINDOW,
X				&actual_type, &actual_format,
X				&nitems, &bytesafter,
X				(unsigned char **) &newRoot) == Success
X			    && newRoot) {
X			    root = *newRoot;
X			    break;
X			}
X		}
X
X		save_dpy = dpy;
X		save_screen = screen;
X	}
X
X	return root;
X}
X
X/*********************
X#undef DefaultRootWindow
X#define DefaultRootWindow(dpy) RootWindow(dpy, DefaultScreen(dpy))
X
X#undef RootWindow
X#define RootWindow(dpy,screen) VirtualRootWindow(dpy,screen)
X**********************/
END_OF_FILE
if test 2379 -ne `wc -c <'xgrabsc.2_3/virtual.h'`; then
    echo shar: \"'xgrabsc.2_3/virtual.h'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/virtual.h'
fi
if test -f 'xgrabsc.2_3/xgrabsc.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/xgrabsc.man'\"
else
echo shar: Extracting \"'xgrabsc.2_3/xgrabsc.man'\" \(16313 characters\)
sed "s/^X//" >'xgrabsc.2_3/xgrabsc.man' <<'END_OF_FILE'
X.\"========================================================================
X.\"
X.\" Name - xgrabsc.man
X.\"
X.\" ccs version: 1.18
X.\"
X.\" ccsid:	@(#)xgrabsc.man	1.18 - 06/28/93 09:13:52
X.\" from: 	ccs/s.xgrabsc.man
X.\" date: 	06/28/93 09:14:49
X.\"
X.\" Copyright (C) 1990-92 Bruce Schuchardt
X.\" See the end of this document for full copyright information.
X.\"
X.\" Description:  Man page for xgrabsc
X.\"
X.\"========================================================================
X.\"
X.TH XGRABSC 1X
X.\"
X.SH NAME
Xxgrabsc \- grab rectangular screen images and store in files
X.\"
X.SH SYNOPSIS
X.in +8n
X.ti -8n
X\fIxgrabsc\fR
X[\fB\-d\fP\ \fIdisplay\fP]
X[\fB\-id\fP\ \fIwindowId\fP]
X[\fB\-o\fP\ \fIoutputFile\fP]
X[\fB\-s\fP\ \fIseconds\fP]
X[\fB\-post\fP\ \fIseconds\fP]
X[\fB\-b\fP\ \fIpercent\fP]
X[\fB\-and\fP\ \fIandBits\fP]
X[\fB\-or\fP\ \fIorBits\fP]
X[\fB\-page\fP\ \fIwidthxheight-hmarg-vmarg\fP]
X[\fB\-bell -grab -verbose -bdrs -nobdrs -key -stretch -root -click
X-coords \fIwidthxheight+x+y\fP
X.br
X-reverse -bw -mdither -dither -halftone
X.br
X-ps -cps -simple -xwd -xwdxy -bm -bm2 -bm3 -puzzle
X.br
X-bin -comp -eps -l -limit -preview -prev -previewonly -colproc\fP]
X.in -8n
X.\"
X.\"
X.\"
X.SH DESCRIPTION
X\fIxgrabsc\fR lets you grab arbitrary rectangular images from an
XX server and writes them to standard output in a variety of formats.
X.PP
XCommand line options also allow reduction of colormaps, halftoning
Xand dithering of color images, and direct mapping of color images
Xto monochrome.
X.PP
XOptions must be seperated with spaces or tabs.  They
Xmay be preceded with a dash, but this optional and provided for Un*x
Xaddicts.  Many may also be prefixed with 'no', or an additional dash, to
Xturn them off.
X.PP
XThe default output format is gray-scale non-encapsulated Postscript, with
Ximage compression (if image compression significantly reduces the amount of
Xoutput).
X.PP
XIf you desire an output format not produced by xgrabsc, try using the
XPBM package by Jef Poskanzer to convert xgrabsc to that format.  PBM
Xcan read xgrabsc's XWD output and convert it to a lot of different formats.
X.\"
X.\"
X.\"
X.\"
X.SH GENERAL OPTIONS
X.TP 8
X-d \fIdisplayName\fP or -display \fIdisplayName\fP
X.br
XUse an alternate display.  If no display is specified on the command line,
Xxgrabsc looks for the environment variable DISPLAY for the name of the
Xdisplay and screen to grab from.  Note that you must have permission to
Xaccess the display on another computer.
X.TP
X-bell
XThe display's bell is normally rung while the screen is being accessed.
XThis turns the bell on or off (\fI-nobell\fP will turn it \fIoff\fP).
X.TP
X-grab
XEnable server grabs.  Normally xgrabsc will "grab" the server so
Xthat the screen is frozen while a rectangle is selected and the image
Xis extracted.  If the screen is not frozen, rubber-banding may cause
Xvideo droppings on portions of the screen that are changing.  Use \fI-nograb\fP
Xto turn off server grabs.
X.TP
X-o \fIoutput-file\fP or -output \fIoutput-file\fP
X.br
XWrite output to \fIoutput-file\fP instead of standard output.  The
Xoutput-file name, minus directory and extension, is used as the internal
Xname for the image in formats supporting image names.  Postscript,
Xxwd, pixmap and bitmap formats all support image names.
X.TP
X-s \fIseconds\fP or -sleep \fIseconds\fP
X.br
XSleep for \fIseconds\fP seconds before commencing operation.  This
Xshould be used if you need some time to get the target image ready.
X.TP
X-post \fIseconds\fP
XSleep for \fIseconds\fP seconds after window/rectangle selection.  This is
Xcommonly used to pop up menus after a window has been selected but before
Xxgrabsc takes its snapshot.
X.TP
X-verbose
XDisplay processing information on standard error output (stderr).
X.sp 3
X.\"
X.\"
X.\"
X.\"
X.\"
X.SH SELECTION OPTIONS
X.TP
X-id \fIwindow ID\fP
XDump the window with the given ID.
X.TP
X-key
XSelect the window under the mouse when the Control key is pressed.  This
Xoption is normally used in getting images of menus.  Pop up the menu,
Xoptionally move the pointer to the window containing the menu, and strike
Xthe Control key to begin the dump.
X.TP
X-root
XDump the entire screen (root window).
X.TP
X-stretch
XUse rubber-band rectangle to select region to grab.  This is the
Xdefault.
X.TP
X-click
XWait for a click on a window and dump the selected window.
X.TP
X-coords \fIwidthxheight+x+y\fP
XSelects the given area of the screen, without mouse or keyboard interaction.
XUse this if you need to grab the same area of the screen over and over again.
X.\"
X.\"
X.\"
X.\"
X.\"
X.sp 3
X.SH IMAGE PROCESSING OPTIONS
X.TP
X-nobdrs or -noborders
X.br
XRemove window-manager borders from window images.  This option
Xapplies only to selection by ID (\fI\-id\fP) or xwd-style selection
X(\fI-click\fP).
X.TP
X-bdrs or -borders
X.br
XInclude window-manager borders in window images.  This option
Xapplies only to selection by ID (\fI\-id\fP) or xwd-style selection
X(\fI-click\fP).  Use \fI-nobdrs\fP or \fI-noborders\fP to turn it off.
X.TP
X-b \fIpercent\fR or -brighten \fIpercent\fR
X.br
Xbrighten or darken the image by \fIpercent\fR.  Percentages are given
Xas integers. 100 is the base and a larger number will brighten the image
Xwhile a smaller number will darken the image.
X.TP
X-and \fIandBits\fR
XClear all colormap bits up to the given plane.  This has the effect of
Xdarkening the image somewhat and shrinking the apparent depth of the image
X(and, consequently, the size of the color table).  \fIAndBits\fR should
Xbe in the range [1-8] inclusive.
X.TP
X-or \fIorBits\fR
XSet all colormap bits up to the given plane.  This brightens the image
Xsomewhat and also shrinks the apparent depth of the image.  When
Xboth \-A and \-O are specified, ANDing will occur before ORing.
X.TP
X-reverse
XReverse the colors in the image.  The bits of each color used in the
Ximage are inverted.
X.TP
X-bw
XConvert the source color image to a monochrome bitmap.  All colors
Xfalling below the average color intensity are mapped to black.  Others
Xare mapped to white.
X.TP
X-halftone
XConvert the source color image to a halftoned monchrome bitmap.
XResolution is maintained by increasing the size of the image by
Xa factor of four on both axes.
X.TP
X-mdither
XConvert the source color image to a dithered monochrome bitmap.
XThis is like halftoning, but resolution is sacrificed to keep the
Xresulting image the same size as the original.  The matrix dithering
Xalgorithm used with this option is most suitable for line-drawings
Xand text.  For more complex graphics the \fI-dither\fR option is recommended.
X.TP
X-dither
XConvert the source color image to a dithered monochrome bitmap with
Xthe Floyd-Steinberg algorithm.
X.TP
X-nodither
XTurns off any dithering.  Use this if your \fBXGRABSC\fP environment variable
Xspecifies dithering and you want to override it to produce an undithered
Ximage.
X.sp 3
X.\"
X.\"
X.\"
X.\"
X.SH OUTPUT FORMAT OPTIONS
X.TP
X-cps
XWrite output in \fIPostscript\fP format using the colorimage operator
Xfor color printers.
XColor to grayscale conversion is bundled into the output so you can actually
Xuse either color or cheaper grayscale printers.  For monochrome displays, the
X\fI-ps\fP option will give more compact output.
X.TP
X-ps
XWrite output in \fIPostscript\fP format for greyscale printers.
XThe number of bits per Postscript sample is determined by the depth of the
Ximage.
X.TP
X-xwd
XWrite output in \fIxwd\fP format.  Use this if you want to convert to another
Xoutput format with \fBPbm+\fP.
X.TP
XWrite output in \FIxwd -xy\fP format.  This is like xwd, but allows black and
Xwhite images to be written with eight pixels per byte instead of the default
Xone pixel per byte.  While xwud and xpr will handle this format, some programs
Xwill not.
X.TP
X-bm
XWrite the output in X Bitmap format if the image is black and white, or
XX Pixmap format if the image is gray or color.
X.TP
X-bm2
XWrite the output in X Bitmap format if the image is black and white, or
XX Pixmap format 2 if the image is gray or color.
X-bm3
XWrite the output in X Bitmap format if the image is black and white, or
XX Pixmap format 3 if the image is gray or color.
X.TP
X-puzzle
XWrite output in a format suitable for loading into the \fIpuzzle\fP
Xprogram (see example below).
X.sp 2
X.\"
X.\"
X.\"
X.\"
X.\"
X.SH POSTSCRIPT OPTIONS
X.TP
X-compress
XEnable or suppress Postscript image run-length encoding.  Postscript output
Xis
Xnormally compressed to minimize the size of output.  If your printer
Xcan't handle compressed output, you should use \fI-nocompress\fP to turn
Xoff compression.
X.TP
X-eps
XCreate Encapsulated Postscript output, rather than normal stand-alone
XPostscript.  This adds EPSF header comments and removes all scaling and
Xtranslation of the image.
X.TP
X-l or -landscape
X.br
XUse landscape layout (with page width and height exchanged) for Postscript
Xoutput.  This option is ignored if Encapsulated Postscript output is requested.
XWidth and height may be specified with the -page option.
X.TP
X-bin
XWrite Postscript output in binary rather than using hexidecimal encoding.
XThis causes the image portion of the output to use half as much space,
Xdecreasing transmission time to the printer.  Note that not all print
Xspoolers can handle 8 bit binary data, so this may not work on your system!
X.TP
X-limit
XFor Postscript output, check printer memory availability before attempting
Xto print an image (the code to perform the checks is integrated into the
Xoutput of xgrabsc).  This is turned off if Encapsulated Postscript output
Xis requested, and may be disabled completely when building the xgrabsc
Xprogram.  On the command line it may be turned off with \fI-nolimit\fP.
X.TP
X-preview or -prev
X.br
XSelects Encapsulated Postscript output with an EPSI preview image in its
Xheader.  The preview image, if necessary, is dithered to black and white
Xeither with
Xa default dithering algorithm or one you specify on the command line (e.g.,
X\fI-mdither\fP).  Programs such as Frame use preview images to display
Xthe postscript image during editing sessions.  If you don't have a preview
Ximage, Frame will display a blank rectangle.  The image will print OK but
Xyou won't see it while editing.
X.TP
X-previewonly
XLike \fI-preview\fP but writes only the preview portion, not the postscript
Ximage.  This may be used to add the preview to an existing EPS file after
Xhaving displayed it using a PostScript interpreter.
X.TP
X-page \fIwidthxheight-marginWidth-marginHeight\fP
XSets the size of the paper and the borders you desire around the edge of the
Xpaper.  Xgrabsc will reduce the image if necessary to keep it within the
Xborders you specify.  The default page size and margins are set when
Xxgrabsc is built.  Measurements are in inches (e.g., 8.5x11.0-0.5-0.5)
X.sp 3
X.\"
X.\"
X.\"
X.\"
X.\"
X.\"
X.\"
X.SH PROCESSING ORDER
XIt is helpful to know the order of processing when multiple processing
Xoptions are given on the command line.
X.PP
XProcessing is done in five phases:  1) set up, 2) obtain image,
X3) process colors, 4) poly->monochrome conversions, and 5) output conversion.
X.PP
XThe set-up phase includes processing command-line options, sleeping,
Xconnecting to X-Windows, freezing the screen, and grabbing the mouse if
Xnecessary.
X.PP
XIf the mouse is grabbed for rubber-banding, an upper-left-corner cursor is
Xdisplayed until the left mouse button is pressed.  A lower-left-corner
Xcursor is then displayed while drawing rubber-rectangles until the mouse
Xbutton is released.
X.PP
XIf the mouse is grabbed for xwd-style window selection, an xwd-style cursor
Xis displayed until the left mouse button is pressed.
X.PP
XThe mouse is then released.
X.PP
XThe bell is then run and the image is pulled from the screen.
X.PP
XFollowing the image-grab, the bell is run twice and the screen is released.
X.PP
XIf the image is not monochrome, the color manipulation functions are
Xthen applied in this order: brighten, AND, and OR, reverse.
X.PP
XOnly one polychrome to monochrome conversion is allowed.  If none of
Xthese is chosen, the color table of a polychrome image is compressed
Xin preparation for output conversion.
X.PP
XThe output stream is then opened and the image is written in the selected
Xoutput format.
X.sp 2
X.SH ENVIRONMENT
XXGRABSC - specifies command line arguments to be processed before those
Xactually entered on the command line.
X.PP
XDISPLAY - specifies the name of the display that xgrabsc should grab from.
X.sp 2
X.SH EXAMPLES
XThe simplest form of use, giving Postscript output, is
X.sp
X.ti +5
Xxgrabsc >outfile.ps
X.sp
X.PP
XTo write output in \fIPostscript\fP format and send to the printer,
Xuse
X.sp
X.ti +5
Xxgrabsc | lpr
X.sp
XIt is sometimes helpful to brighten an image somewhat before it is
Xformatted for Postscript output.  E.g., to brighten by 30%
X.sp
X.ti +5
Xxgrabsc -b 130 | lpr
X.sp
X.PP
XIf your printer supports color, and your display is color, you can
Xhave xgrabsc generate color output instead of gray scale:
X.sp
X.ti +5
Xxgrabsc -cps | lpr
X.sp
X.PP
XThe default Postscript output attempts to scale the image so that
Xit will all fit on one page, and is centered on the page.  If you
Xare grabbing images to include in documents, such as with FrameMaker,
Xyou should ask for Encapsulated Postscript output with the \fI-eps\fP
Xswitch.  For example:
X.sp
X.ti +5
X  xgrabsc -eps -o image1.eps
X.PP
XTo select an entire window, write output in \fIpuzzle\fP format
Xand read into the puzzle program, use the commands
X.sp
X.ti +5
Xxgrabsc -click -puzzle >outfile.pzl
X.br
X.ti +5
Xpuzzle -picture outfile.pzl
X.sp
X.PP
XTo have xgrabsc sleep for three seconds before rubber-banding, display
Xprocessing information, and have the result displayed with xwud,
X.sp
X.ti +5
Xxgrabsc -xwd -verbose -s 3 | xwud
X.sp
X.PP
XTo grab an image from another server and then reduce the colormap
Xto three bits by ANDing, use
X.sp
X.ti +5
Xxgrabsc -d other:0.0 -and 5 -bm >outfile.xpm
X.sp
XYou will, of course, have to go to the other machine to select the
Ximage with that machine's mouse.
X.sp 2
X.SH LIMITATIONS
XColormaps larger than 256 entries are not currently supported. This
Xmeans that it won't work with your fancy 24-bit display.
X.PP
XThe default screen visual is used as the visual for the image.
XVisuals are associated with particular windows, and xgrabsc pretends
Xignorance about any windows but the root.
X.PP
XThis software has been tested with StaticGray and 8-plane PseudoColor
Xon DECStations (using both UWS 2.2 and X11 Release 4).  It has also
Xbeen tested with 8-plane PseudoColor on Sun SparcStations and various
Xother platforms using X11 Release 4 and Release 5.
X.PP
XX11 Pixmap format is rather verbose.
XYou may want to run large images through the \fIcompress\fP utility
Xbefore storing them in a file.  E.g.,
X.sp
X.ti +5
Xxgrabsc -bm | compress >outfile.xpm.Z
X.sp
X.SH AUTHOR
X.nf
X     Bruce Schuchardt
X    Servio Corporation
X      bruce@slc.com
X.fi
X.sp 2
X.SH ACKNOWLEGEMENTS
X.PP
XSome of the source code for xgrabsc came from
Xthe xloadimage project by Jim Frost (jimf@saber.com) and others.  Jim's
Xcopyright has been included both here and in the source code.
X.PP
XThe idea for using run-length encoding for Postscript output came from
Xthe xwd2ps project by Robert Tatar and Craig A. McGowan.
X.PP
XThe ad2c.sed script that makes it possible to let you run xgrab without
Xinstalling XGrab.ad everywhere is part of the ad2c package developed by
XGeorge Ferguson.
X.sp 2
X.SH CONTRIBUTORS
X.PP
XYves Arrouye wrote the EPS Preview and page-configuration enhancements.
X.sp 2
X.SH COPYRIGHT
XCopyright (c) 1990-93 Bruce Schuchardt
X.PP
X\fIXgrabsc\fR is copywritten material with a very loose copyright
Xallowing unlimited modification and distribution if the copyright
Xnotices are left intact.  Various portions are copywritten by various
Xpeople, but all use a modification of the MIT copyright notice.
XPlease check the cpyright.h for complete copyright information.  The
Xintent is to keep the source free, not to stifle its distribution, so
Xplease write to me if you have any questions.
X.PP
XTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
XINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
XNO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR
XCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
XOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
XOR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
XUSE OR PERFORMANCE OF THIS SOFTWARE.
X.s 2
X.SH SEE ALSO
XX(1X), xhost(1), xwd(1X), xwud(1X), xwd2ps(1X), xloadimage(1X), xpm(1X),
Xxpr(1X), puzzle(1X), compress(1), uncompress(1), xv(1X)
END_OF_FILE
if test 16313 -ne `wc -c <'xgrabsc.2_3/xgrabsc.man'`; then
    echo shar: \"'xgrabsc.2_3/xgrabsc.man'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/xgrabsc.man'
fi
if test -f 'xgrabsc.2_3/xgrabxaw.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/xgrabxaw.c'\"
else
echo shar: Extracting \"'xgrabsc.2_3/xgrabxaw.c'\" \(14663 characters\)
sed "s/^X//" >'xgrabsc.2_3/xgrabxaw.c' <<'END_OF_FILE'
X/*========================================================================
X *
X * Name - xgrabxaw.c
X *
X * Version:	1.16
X *
X * ccsid:	@(#)xgrabxaw.c	1.16 - 06/28/93 09:13:54
X * from: 	ccs/s.xgrabxaw.c
X * date: 	06/28/93 09:14:49
X *
X * Copyright (c) 1990-93 Bruce Schuchardt.
X * Read the file cpyright.h for full copyright information.
X *
X *
X * Description:
X *
X * xgrab.c - interactive front for xgrabsc
X *
X *========================================================================
X */
X#include "cpyright.h"
X#include "patchlevel.h"
X#include "config.h"
X
X#include <stdio.h>
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Shell.h>
X#include <X11/Xaw/Form.h>
X#include <X11/Xaw/Label.h>
X#include <X11/Xaw/Command.h>
X#include <X11/Xaw/AsciiText.h>
X#include <X11/Xaw/Toggle.h>
X
Xstatic char *fallback_resources[] = {
X#include "xgrabxaw_ad.h"
X  NULL
X  };
X
X
Xstatic Display *hDisplay;
X
Xtypedef enum {
X  HITWIN = 1,
X  STRETCH,
X  KEY,
X  ROOT,
X
X  XWD,
X  XWDXY,
X  PS,
X  BITMAP,
X  BITMAP2,
X  BITMAP3,
X  PUZZLE,
X  SIMPLE,
X
X  DITHER,
X  MDITHER,
X  HALFTONE,
X  MAPBW,
X
X  REVERSE,
X
X  TOFILE,
X  TOPRN,
X
X  PS_NORMAL,
X  PS_EPS,
X  PS_EPSI,
X  PS_EPSIONLY,
X  PS_LANDSCAPE
X  
X  } radioType;
X
X
XWidget selBtns, formatBtns, psColr, encBtns, psComp, sltext, psltext,
X       psLim,
X       psBin, borderBtn, horizMargin, vertMargin, pgHeight, pgWidth,
X       cnvBtns, revBtn, brtext, outBtns, filenm, prncmd, dispBtn, hostnm;
XWidget hShell;
X
XXtAppContext appContext;
X
X
Xstatic char* stradi(ptr, i)    /* Add an integer to a string */
X    char* ptr;
X    int i; {
X
X    sprintf(ptr + strlen(ptr), "%d", i);
X    return ptr;
X}
X
Xstatic char* stradw(ptr, s)   /* Add a string to another, with no ws */
X    char* ptr;
X    char* s; {
X
X    char* ou = ptr + strlen(ptr);
X
X    while (isspace(*s)) {
X	++s;
X    }
X    while (*s && !isspace(*s)) {
X	*ou++ = *s++;
X    }
X    *ou = '\0';
X
X    return ptr;
X}
X
X
Xstatic void doGrab() {
X  char tmp[257];
X  char cmdargs[200];
X  char piper[200];
X  char cmd[500];
X  char *txt;
X  int  s, d, len, num;
X  int  sltime, psltime;
X  int  bright;
X  Boolean state;
X
X  cmdargs[0] = '\0';
X  piper[0] = '\0';
X
X  XtVaGetValues(sltext, XtNstring, &txt, NULL);
X  sltime = atoi(txt);
X  if (sltime < 0) sltime = 0;
X  sprintf(tmp, "-sleep %d ", sltime);
X  strcat(cmdargs, tmp);
X
X  XtVaGetValues(psltext, XtNstring, &txt, NULL);
X  psltime = atoi(txt);
X  if (psltime < 0) psltime = 0;
X  sprintf(tmp, "-post %d ", psltime);
X  strcat(cmdargs, tmp);
X
X  XtVaGetValues(brtext, XtNstring, &txt, NULL);
X  bright = atoi(txt);
X  sprintf(tmp, "-brighten %d ", bright);
X  strcat(cmdargs, tmp);
X
X  XtVaGetValues(borderBtn, XtNstate, &state, NULL);
X  if (!state)
X    strcat(cmdargs, "-");
X  strcat(cmdargs, "-bdrs ");
X
X  XtVaGetValues(revBtn, XtNstate, &state, NULL);
X  if (!state)
X    strcat(cmdargs, "-");
X  strcat(cmdargs, "-reverse ");
X
X  switch ((int)XawToggleGetCurrent(selBtns)) {
X    case HITWIN:
X      strcat(cmdargs, "-click ");
X      break;
X    case KEY:
X      strcat(cmdargs, "-key ");
X      break;
X    case ROOT:
X      strcat(cmdargs, "-root ");
X      break;
X    case STRETCH:
X    default:
X      strcat(cmdargs, "-stretch ");
X      break;
X  }
X  switch ((int)XawToggleGetCurrent(formatBtns)) {
X    case XWD:
X      strcat(cmdargs, "-xwd ");
X      break;
X    case XWDXY:
X      strcat(cmdargs, "-xwdxy ");
X      break;
X    case BITMAP:
X      strcat(cmdargs, "-bm ");
X      break;
X    case BITMAP2:
X      strcat(cmdargs, "-bm2 ");
X      break;
X    case BITMAP3:
X      strcat(cmdargs, "-bm3 ");
X      break;
X    case PUZZLE:
X      strcat(cmdargs, "-puzzle ");
X      break;
X    case SIMPLE:
X      strcat(cmdargs, "-simple ");
X      break;
X    case PS:
X    default:
X      XtVaGetValues(psColr, XtNstate, &state, NULL);
X      if (!state)
X        strcat(cmdargs, "-ps ");
X      else
X        strcat(cmdargs, "-cps ");
X
X      switch ((int)XawToggleGetCurrent(encBtns)) {
X        case PS_EPS:
X          strcat(cmdargs, "-eps ");
X	  break;
X	case PS_EPSI:
X	  strcat(cmdargs, "-preview ");
X	  break;
X	case PS_EPSIONLY:
X	  strcat(cmdargs, "-previewonly ");
X	  break;
X	case PS_LANDSCAPE:
X	  strcat(cmdargs, "-landscape ");
X	  break;
X	default:
X	  break;
X      }
X
X      XtVaGetValues(psComp, XtNstate, &state, NULL);
X      if (!state)
X        strcat(cmdargs, "-");
X      strcat(cmdargs, "-compress ");
X      XtVaGetValues(psBin, XtNstate, &state, NULL);
X      if (!state)
X        strcat(cmdargs, "-");
X      strcat(cmdargs, "-bin ");
X
X      XtVaGetValues(psLim, XtNstate, &state, NULL);
X      if (!state)
X        strcat(cmdargs, "-");
X      strcat(cmdargs, "-limit ");
X
X      strcat(cmdargs, "-page ");
X      XtVaGetValues(pgWidth, XtNstring, &txt, NULL);
X      if (strlen(txt))    stradw(cmdargs, txt);
X      else                stradi(cmdargs, PAPER_WIDTH);
X      strcat(cmdargs, "x");
X      XtVaGetValues(pgHeight, XtNstring, &txt, NULL);
X      if (strlen(txt))    stradw(cmdargs, txt);
X      else                stradi(cmdargs, PAPER_HEIGHT);
X      strcat(cmdargs, "-");
X      XtVaGetValues(horizMargin, XtNstring, &txt, NULL);
X      if (strlen(txt))    stradw(cmdargs, txt);
X      else                stradi(cmdargs, HORIZ_MARGIN);
X      strcat(cmdargs, "-");
X      XtVaGetValues(horizMargin, XtNstring, &txt, NULL);
X      if (strlen(txt))    stradw(cmdargs, txt);
X      else                stradi(cmdargs, VERT_MARGIN);
X      strcat(cmdargs, " ");
X
X      break;
X  }
X  switch ((int)XawToggleGetCurrent(cnvBtns)) {
X    case DITHER:
X      strcat(cmdargs, "-dither ");
X      break;
X    case MDITHER:
X      strcat(cmdargs, "-mdither ");
X      break;
X    case HALFTONE:
X      strcat(cmdargs, "-halftone ");
X      break;
X    case MAPBW:
X      strcat(cmdargs, "-bw ");
X      break;
X    default:
X      break;
X  }
X  switch ((int)XawToggleGetCurrent(outBtns)) {
X    case TOPRN:
X      XtVaGetValues(prncmd, XtNstring, &txt, NULL);
X      if (strlen(txt)) {
X        strcat(piper, " | ");
X        strcat(piper, txt);
X      }
X      break;
X    case TOFILE:
X    default:
X      strcat(cmdargs, "-o ");
X      XtVaGetValues(filenm, XtNstring, &txt, NULL);
X      if (strlen(txt)) {
X        strcat(cmdargs, txt);
X#ifdef BUMP_FILENAMES
X	len = strlen(txt);
X	for (s=0; s<len && (txt[s] != '.'); s++)
X	{}
X	strcpy(tmp, txt);
X	tmp[s] = '\0';
X	d = s;
X	while (d > 0  &&  ('0' <= txt[d-1]  &&  txt[d-1] <= '9'))
X	  d--;
X	if ('0' <= txt[d]  && txt[d] <= '9')
X	  num = atoi(&tmp[d]);
X	else
X	  num = 0;
X	num++;
X	sprintf(&tmp[d], "%d", num);
X	strcat(tmp, &txt[s]);
X	XtVaSetValues(filenm, XtNstring, tmp, NULL);
X#endif
X      }
X      else {
X        strcat(cmdargs, "screen.dmp");
X	XtVaSetValues(filenm, XtNstring, "screen.dmp", NULL);
X      }
X      strcat(cmdargs, " ");
X      break;
X  }
X
X  XtVaGetValues(dispBtn, XtNstate, &state, NULL);
X  if (state) {
X    XtVaGetValues(hostnm, XtNstring, &txt, NULL);
X    strcat(cmdargs, "-d ");
X    if (strlen(txt)) {
X      strcat(cmdargs, txt);
X      strcat(cmdargs, " ");
X    }
X    else
X      strcat(cmdargs, ":0 ");
X  }
X
X  sprintf(cmd, "xgrabsc %s%s\n", cmdargs, piper);
X  /* fputs(cmd, stderr); */
X  /* try to make the window iconic */
X  XtUnmapWidget(hShell);
X  XSync(hDisplay, False);
X  system(cmd);
X  XtMapWidget(hShell);
X}
X
X
X
X
Xstatic void doDismiss() {
X  if (hShell) {
X    XtDestroyWidget(hShell);
X    hShell = NULL;
X    exit(0);
X  }
X}
X
X
X
X
Xstatic void createWindow() {
X  Widget dialog, button, box1, box2, box3, box4, box5, box6;
X
X  dialog = XtVaCreateManagedWidget("dialog", formWidgetClass, hShell,
X           NULL);
X           XtVaCreateManagedWidget("title",  labelWidgetClass, dialog,
X           NULL);
X
X
X  /* selection options */
X  /* input options */
X  box1 = XtVaCreateManagedWidget("box1", formWidgetClass, dialog, NULL);
X
X           XtVaCreateManagedWidget("inputLbl", labelWidgetClass, box1,
X	   NULL);
X
X  dispBtn= XtVaCreateManagedWidget("host", toggleWidgetClass, box1,
X	   NULL);
X
X  hostnm = XtVaCreateManagedWidget("hostText", asciiTextWidgetClass, box1,
X           XtNeditType, XawtextEdit, NULL);
X
X  if (getenv("DISPLAY"))
X    XtVaSetValues(hostnm, XtNstring, getenv("DISPLAY"), NULL);
X
X  selBtns =
X           XtVaCreateManagedWidget("click", toggleWidgetClass, box1,
X           XtNradioData, HITWIN,
X	   NULL);
X
X           XtVaCreateManagedWidget("stretch", toggleWidgetClass, box1,
X           XtNradioData, STRETCH,
X	   XtNradioGroup, selBtns,
X	   NULL);
X
X           XtVaCreateManagedWidget("key", toggleWidgetClass, box1,
X           XtNradioData, KEY,
X	   XtNradioGroup, selBtns,
X	   NULL);
X
X           XtVaCreateManagedWidget("root", toggleWidgetClass, box1,
X           XtNradioData, ROOT,
X	   XtNradioGroup, selBtns,
X	   NULL);
X
X           XtVaCreateManagedWidget("sleeplbl", labelWidgetClass, box1,
X           NULL);
X
X  sltext = XtVaCreateManagedWidget("sleeptime", asciiTextWidgetClass, box1,
X           XtNeditType, XawtextEdit, NULL);
X
X           XtVaCreateManagedWidget("psleeplbl", labelWidgetClass, box1,
X           NULL);
X
X  psltext = XtVaCreateManagedWidget("psleeptime", asciiTextWidgetClass, box1,
X           XtNeditType, XawtextEdit, NULL);
X
X  box2 = XtVaCreateManagedWidget("box2", formWidgetClass, dialog, NULL);
X
X  /* output options */
X           XtVaCreateManagedWidget("outputFormat", labelWidgetClass, box2,
X           NULL);
X
X  formatBtns =
X           XtVaCreateManagedWidget("xwd", toggleWidgetClass, box2,
X           XtNradioData, XWD,
X	   NULL);
X
X           XtVaCreateManagedWidget("ps", toggleWidgetClass, box2,
X           XtNradioData, PS,
X	   XtNradioGroup, formatBtns,
X	   NULL);
X
X           XtVaCreateManagedWidget("puzzle", toggleWidgetClass, box2,
X           XtNradioData, PUZZLE,
X	   XtNradioGroup, formatBtns,
X	   NULL);
X
X
X           XtVaCreateManagedWidget("xyxwd", toggleWidgetClass, box2,
X           XtNradioData, XWDXY,
X	   XtNradioGroup, formatBtns,
X	   NULL);
X
X           XtVaCreateManagedWidget("xpm", toggleWidgetClass, box2,
X           XtNradioData, BITMAP,
X	   XtNradioGroup, formatBtns,
X	   NULL);
X
X           XtVaCreateManagedWidget("xpm2", toggleWidgetClass, box2,
X           XtNradioData, BITMAP2,
X	   XtNradioGroup, formatBtns,
X	   NULL);
X
X           XtVaCreateManagedWidget("xpm3", toggleWidgetClass, box2,
X           XtNradioData, BITMAP3,
X	   XtNradioGroup, formatBtns,
X	   NULL);
X
X
X  /* postscript options */
X  box3 = XtVaCreateManagedWidget("box3", formWidgetClass, dialog, NULL);
X
X           XtVaCreateManagedWidget("psOptions", labelWidgetClass, box3,
X           NULL);
X
X  psComp = XtVaCreateManagedWidget("compress", toggleWidgetClass, box3,
X	   NULL);
X
X  psColr = XtVaCreateManagedWidget("color", toggleWidgetClass, box3,
X	   NULL);
X
X  psBin = XtVaCreateManagedWidget("binary", toggleWidgetClass, box3,
X	   NULL);
X
X  psLim = XtVaCreateManagedWidget("limit", toggleWidgetClass, box3,
X	   NULL);
X
X  encBtns= XtVaCreateManagedWidget("landscape", toggleWidgetClass, box3,
X           XtNradioData, PS_LANDSCAPE,
X	   NULL);
X
X           XtVaCreateManagedWidget("epsi", toggleWidgetClass, box3,
X           XtNradioData, PS_EPSI,
X	   XtNradioGroup, encBtns,
X	   NULL);
X
X           XtVaCreateManagedWidget("onlyEpsi", toggleWidgetClass, box3,
X           XtNradioData, PS_EPSIONLY,
X	   XtNradioGroup, encBtns,
X	   NULL);
X
X/*------------
X           XtVaCreateManagedWidget("encap", toggleWidgetClass, box3,
X           XtNradioData, PS_EPS,
X	   XtNradioGroup, encBtns,
X	   NULL);
X--------------*/
X
X
X           XtVaCreateManagedWidget("pageWidth", labelWidgetClass, box3,
X           NULL);
X
X  pgWidth = XtVaCreateManagedWidget("pageWidthText",asciiTextWidgetClass, box3,
X           XtNeditType, XawtextEdit, NULL);
X
X           XtVaCreateManagedWidget("pageHeight", labelWidgetClass, box3,
X           NULL);
X
X  pgHeight = XtVaCreateManagedWidget("pageHeightText",asciiTextWidgetClass, box3,
X           XtNeditType, XawtextEdit, NULL);
X
X           XtVaCreateManagedWidget("horizMargin", labelWidgetClass, box3,
X           NULL);
X
X  horizMargin = XtVaCreateManagedWidget("horizMarginText",asciiTextWidgetClass, box3,
X           XtNeditType, XawtextEdit, NULL);
X
X           XtVaCreateManagedWidget("vertMargin", labelWidgetClass, box3,
X           NULL);
X
X  vertMargin = XtVaCreateManagedWidget("vertMarginText",asciiTextWidgetClass, box3,
X           XtNeditType, XawtextEdit, NULL);
X
X
X  /* image processing options */
X  box4 = XtVaCreateManagedWidget("box4", formWidgetClass, dialog, NULL);
X
X           XtVaCreateManagedWidget("prOptions", labelWidgetClass, box4,
X           NULL);
X  cnvBtns= XtVaCreateManagedWidget("dither", toggleWidgetClass, box4,
X           XtNradioData, DITHER,
X	   NULL);
X           XtVaCreateManagedWidget("mdither", toggleWidgetClass, box4,
X           XtNradioData, MDITHER,
X	   XtNradioGroup, cnvBtns,
X	   NULL);
X           XtVaCreateManagedWidget("halftone", toggleWidgetClass, box4,
X           XtNradioData, HALFTONE,
X	   XtNradioGroup, cnvBtns,
X	   NULL);
X           XtVaCreateManagedWidget("mapbw", toggleWidgetClass, box4,
X           XtNradioData, MAPBW,
X	   XtNradioGroup, cnvBtns,
X	   NULL);
X
X           XtVaCreateManagedWidget("brightnessLbl", labelWidgetClass, box4,
X	   NULL);
X  brtext = XtVaCreateManagedWidget("brightnessText", asciiTextWidgetClass, box4,
X           XtNeditType, XawtextEdit, NULL);
X
X  revBtn = XtVaCreateManagedWidget("reverse", toggleWidgetClass, box4, NULL);
X
X  borderBtn = XtVaCreateManagedWidget("borders", toggleWidgetClass, box4, NULL);
X
X  box5 = XtVaCreateManagedWidget("box5", formWidgetClass, dialog, NULL);
X
X           XtVaCreateManagedWidget("outputLbl", labelWidgetClass, box5,
X	   NULL);
X
X  outBtns= XtVaCreateManagedWidget("file", toggleWidgetClass, box5,
X           XtNradioData, TOFILE,
X	   NULL);
X
X  filenm = XtVaCreateManagedWidget("fileText", asciiTextWidgetClass, box5,
X           XtNeditType, XawtextEdit, NULL);
X
X           XtVaCreateManagedWidget("printer", toggleWidgetClass, box5,
X           XtNradioData, TOPRN,
X	   XtNradioGroup, outBtns,
X	   NULL);
X
X  prncmd = XtVaCreateManagedWidget("printerText", asciiTextWidgetClass, box5,
X           XtNeditType, XawtextEdit, NULL);
X
X
X  box6 = XtVaCreateManagedWidget("box6", formWidgetClass, dialog, NULL);
X
X  XtVaCreateManagedWidget("splat", labelWidgetClass, box6, NULL);
X  
X  button = XtVaCreateManagedWidget("OK", commandWidgetClass, box6, NULL);
X  XtAddCallback(button, XtNcallback, doGrab, NULL);
X
X  button = XtVaCreateManagedWidget("Dismiss", commandWidgetClass, box6, NULL);
X  XtAddCallback(button, XtNcallback, doDismiss, NULL);
X
X}
X
X
X
Xint main(argc, argv, envp)
X  int argc;
X  char *argv[];
X  char *envp;
X{
X  puts("X-Windows Screen Grabber");
X  puts(Copyright);
X  puts("");
X
X
X  hShell = XtAppInitialize(&appContext, "XGrab", NULL, 0, &argc, argv,
X     fallback_resources, NULL, 0);
X
X  hDisplay = XtDisplay(hShell);
X  createWindow();
X
X  XtRealizeWidget(hShell);
X  XtAppMainLoop(appContext);
X}
END_OF_FILE
if test 14663 -ne `wc -c <'xgrabsc.2_3/xgrabxaw.c'`; then
    echo shar: \"'xgrabsc.2_3/xgrabxaw.c'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/xgrabxaw.c'
fi
echo shar: End of archive 3 \(of 5\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
