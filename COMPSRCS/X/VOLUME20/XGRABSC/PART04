Newsgroups: comp.sources.x
From: bruce@servio.slc.com (Bruce Schuchardt)
Subject: v20i103:  xgrabsc - Grab and dump X displays, Part04/05
Message-ID: <1993Aug4.171727.9619@sparky.sterling.com>
X-Md4-Signature: 680406921cfd8b09a71a631e94882c3f
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Wed, 4 Aug 1993 17:17:27 GMT
Approved: chris@sterling.com

Submitted-by: bruce@servio.slc.com (Bruce Schuchardt)
Posting-number: Volume 20, Issue 103
Archive-name: xgrabsc/part04
Environment: X11
Supersedes: xgrabsc: Volume 18, Issue 52-56

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 4 (of 5)."
# Contents:  xgrabsc.2_3/Bugs xgrabsc.2_3/README xgrabsc.2_3/README.2_3
#   xgrabsc.2_3/XWDFile.h xgrabsc.2_3/Xmd.h xgrabsc.2_3/cmdopts.h
#   xgrabsc.2_3/config.h xgrabsc.2_3/cpyright.h xgrabsc.2_3/get.hc
#   xgrabsc.2_3/hp.mak xgrabsc.2_3/simple.mak xgrabsc.2_3/xgrab.man
# Wrapped by bruce@trout on Mon Jun 28 09:14:50 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'xgrabsc.2_3/Bugs' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/Bugs'\"
else
echo shar: Extracting \"'xgrabsc.2_3/Bugs'\" \(3494 characters\)
sed "s/^X//" >'xgrabsc.2_3/Bugs' <<'END_OF_FILE'
X/*========================================================================
X*
X* Name - Bugs
X*
X* Version:	1.7
X*
X* ccsid:	@(#)Bugs	1.7 - 06/25/93 12:54:09
X* from: 	ccs/s.Bugs
X* date: 	06/28/93 09:14:48
X*
X* Description: Known bugs and problems.  This list does not include
X*              bugs that have been fixed.  See the patch set README
X*              files for descriptions of the bugs they fix.
X*
X*========================================================================*/
X
X*  xgrab dumps core after xgrabsc finishes
X
XThis has been reported for Sun3's running 4.0.3 and Tek 4319's
Xrunning Utek 4.1.  Looks like the stack is being overwritten
Xby the system() call.
X
X*  Postscript images produced by xgrabsc don't get printed
X
XThis is almost always a memory requirement problem.  Xgrabsc
Xv2.0 and later can generate checks for memory availability so
Xyou can at least see how much memory you're lacking to be able
Xto print your document.  I'd like to be able to preempt the
Xtransfer of the rest of the file when there isn't enough memory
Xto process it, but haven't been able to make this happen. 
X
X
X*  The puzzle program won't display xgrabsc output
X
XWhile xgrabsc can create puzzle picture files from monochrome 
Xscreens, the puzzle program will not display pictures with "-
Xpicture" on monochrome systems. This is not a "bug" in xgrabsc, 
Xbut is a "confusing feature".
X
X
X*  When started from a window-manager menu, xgrabsc fails to grab an image.
X
XIf you run xgrabsc from a Twm menu, be sure to end your exec 
Xcommand with "&". The program may not be able to grab the pointer 
Xor server unless you do this.  This will likely happen with any 
Xwindow manager, but has been reported onlyfor Twm.
X
X
X*  Encapsulate Postscript images are not centered or scaled when printed
X
XThis isn't a problem with xgrabsc.  EPS files are not supposed to
Xcontain scaling or transformation commands.
X
X
X*  The X cursor isn't included in images
X
XIf someone can tell me how to grab an image with the X cursor, I'd
Xbe much obliged.  Most X servers explicitely hide the cursor when
Xprocessing getImage requests.
X
X
X* BadMatch errors are generated when grabbing with the keyboard (-k) and
X  the cursor is on a menubar
X
XI haven't been able to reproduce this error.
X
X
X* Can't grab xeyes
X
XI haven't been able to reproduce this problem.
X
X
X* Dithered output sent to "xpr" for a laserjet doesn't produce an image
X
XI have no laserjet to test with.
X
X
X* The halftoning algorithm in xgrabsc should be improved
X
XSomeone have a better algorithm?  If so, please send it to me.  I'm
Xnot interested in supporting zillions of different dithering
Xalgorithms, but would be happy to improve the ones already in xgrabsc.
X
X
X* Postscript output doesn't center properly when printed
X
XThe default paper size is hard-coded into xgrabsc.  If you're not
Xusing the size of paper specified in config.h, you should use the
X"-page" command to set the size of paper to be expected.
X
X
X* Binary Postscript images appear dark when printed
X
XYour print spooler is probably stripping off the top bits of the binary
Xdata, causing the samples to be darker.  Some systems have "lpr" options
Xto tell the spooler that the file you're printing contains binary data.
XConsult your lpr documentation.
X
X
X* Preview images appear reversed when displayed
X
XYour tool does not match the setting of EPSF_BLACK in config.h.  The
Xdefault setting of this value matches the EPSF v2.0 specification, but
Xsome tools, such as older versions of xfig, expect the bits to be reversed.
END_OF_FILE
if test 3494 -ne `wc -c <'xgrabsc.2_3/Bugs'`; then
    echo shar: \"'xgrabsc.2_3/Bugs'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/Bugs'
fi
if test -f 'xgrabsc.2_3/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/README'\"
else
echo shar: Extracting \"'xgrabsc.2_3/README'\" \(5228 characters\)
sed "s/^X//" >'xgrabsc.2_3/README' <<'END_OF_FILE'
X*========================================================================
X*
X* Name - README
X*
X* Version:	1.12
X*
X* ccsid:	@(#)README	1.12 - 06/25/93 12:54:12
X* from: 	ccs/s.README
X* date: 	06/28/93 09:14:48
X*
X* Copyright (C) 1990-92 Bruce Schuchardt
X* See either the man page or the file cpyright.h for full copyright
X* information.
X*
X* Description:  README for xgrabsc
X*
X*		Notes for this specific release are in README.xx_yy
X*
X*========================================================================
X
XINTRO TO xgrabsc
X
XWhen I first wrote xgrabsc, there were a number of programs available
Xfor getting X-Window screen dumps (e.g., xwd and xwps), but they
Xwere all restricted to dumping a single window in a single format.
XI wrote xgrabsc in an effort to get around these restrictions.
X
XThe main contribution of this program is its use of root-window
Xrubberbanding to allow capture of arbitrary portions of the screen,
Xand its multiple output formats (x-bitmap, x-pixmap, xwd, puzzle,
X"simple", and several Postscript formats).
X
XThe Postscript dumps will use run-length encoding if it results in
Xany savings in size.  A typical xterm window dump on a mono system
Xruns around 40K bytes (20K for binary output).  An xwd dump on the
Xsame screen will be around 650K bytes.  While the xpr program has a
X"compress" option, it only compresses white samples.  Reducing the 
Xsize of the output increases the cost of computing the dump and the
Xfinal printing of the dump, but it reduces the cost of storage and
Xthe time to transfer the dump to your printer.  The latter is
Xespecially important for large screen dumps.
X
XThe xgrabsc program is not interactive.  You specify all processing
Xoptions on the command line with obscure option characters.  These
Xare all detailed in the man page.  An interactive interface to xgrabsc,
Xnamed xgrab, is also included in this release.  xgrab allows you to
Xdo most of the setup with a mouse, and then uses the xgrabsc program
Xto actually do the processing.  To use xgrab you must have the xgrabsc
Xprogram in your execution path.
X
X
X
XOPTIONS FOR BUILDING xgrabsc
X
XThe file config.h contains all the configuration options for xgrabsc.
XPlease take a moment to look through that file before building xgrabsc.
X
XYou also have the choice of building either the Athena or Motif 1.2 version of
Xthe xgrab form.  The default is to build the Athena version since many people
Xdon't have version 1.2 of Motif yet.  If you want to build the Motif version
Xyou will have to edit the Imakefile or simple.mak before building. 
X
XTo find out if you have Motif 1.2, look for the definition of XmREVISION in
Xyour Xm.h include file.  If it is 1, you don't have Motif 1.2. 
X
X
X
X
XBUILDING xgrabsc
X
XXgrabsc should build easily enough.  If you don't have the imake
Xprogram, use simple.mak (i.e., make -f simple.mak).  There are targets
Xfor xgrabsc, xgrab, install, install.man, and clean.
X
XE.g.,
X  xmkmf
X  make
X  make install
X  make install.man
X
XThe install target will put xgrabsc in /usr/bin/X11 and the man page in
X/usr/man/man1, unless you are using imake and your configuration files
Xspecify alternative directories.  If you are using simple.mak and don't
Xlike these locations, change the makefile before installing.
X
XPlease send comments, bugs, and enhancements to bruce@slc.com.  Please
Xread the Bugs file before sending bug reports.
X
X
X Manifest
X ---------------------------------
X README              this file
X README.xx_yy        files describing incremental changes to xgrabsc
X
X Acks                acknowledgements for code gleaned from other
X                     systems, and people who have been very helpful
X                     in adding features and removing bugs from xgrabsc
X
X Bugs                known bugs - read this before sending bug reports
X
X Imakefile           Input for "imake" program
X simple.mak          Simpler input for standard "make"
X hp.mak		     A version of simple.mak for HPUX 9.0, which comes with
X 		     Motif1.2
X
X checkvm.h           Memory-check Postscript operator
X config.h            Configuration options
X cpyright.h          Copyright notice for this software (READ IT)
X cmdopts.h	     Command line options for xgrabsc
X patchlevel.h        Current patch level
X virtual.h           Support for virtual window managers
X xgrabxm.c           Source for Motif 1.2 window interface to xgrabsc
X xgrabxaw.c	     Source for the Athena window interface to xgrabsc
X xgrabsc.c           Program source for the screen grabber
X
X *.hc                function include files for xgrabsc.c
X
X XWDfile.h           xwd structure definition needed on some platforms
X 
X ad2c.sed            sed script to convert XGrab.ad to fallback resources
X                     for xgrab (see Ack file - this isn't mine)
X
X xgrabsc.man         Man page for xgrabsc
X xgrab.man           Man page for xgrab
X
X XGrabxm.res         Resources for the Motif xgrab program
X XGrabxaw.res	     Resources for the Athena xgrab program
X
X
X
XBUGS:
X
XCommon problems and known bugs are described in the Bugs file.
X
X
X
XTO DO:
X
XSupport for 24-bit displays.  If someone wants to give this a shot, please
Xlet me know.
X
X
X~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
X  Bruce Schuchardt          bruce@SLC.COM
X  Servio Corp.
X  Beaverton, OR
END_OF_FILE
if test 5228 -ne `wc -c <'xgrabsc.2_3/README'`; then
    echo shar: \"'xgrabsc.2_3/README'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/README'
fi
if test -f 'xgrabsc.2_3/README.2_3' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/README.2_3'\"
else
echo shar: Extracting \"'xgrabsc.2_3/README.2_3'\" \(5041 characters\)
sed "s/^X//" >'xgrabsc.2_3/README.2_3' <<'END_OF_FILE'
X/*========================================================================
X*
X* Name - README.2_3
X*
X* Version:	1.9
X*
X* ccsid:	@(#)README.2_3	1.9 - 06/28/93 09:13:37
X* from: 	ccs/s.README.2_3
X* date: 	06/28/93 09:14:48
X*
X* Description: Notes on release 2.3
X*
X*========================================================================
X
XThis release adds the following features:
X
X  * faster, more compact color Postscript printing.  Color printers are just
X    too cheap and plentiful these days to keep the old algorithms.
X    Bob Tatar's colorImage operator has consequently been removed from
X    xgrabsc.  Though it is good code and quite general, it is very very slow.
X    Direct conversion of the rgb table to luminesence values is now used
X    instead.
X    
X    There are still some bugs in compressed binary color output, but I
X    didn't want to hold up the release for them.
X  
X  * a Motif version of the user-interface.  You have to mess with the
X    makefile (Imakefile or simple.mak) to get the Motif version to build,
X    and you MUST have Motif 1.2 or later to use that version of xgrab -
X    the resource file uses 1.2 features.
X   
X    Both versions have had a "matrix" dither toggle button added.
X    
X    Unless I hear a big scream from you I will be dropping the Athena
X    version in v2.4.
X
X  * the encapsulated-postscript options in the window interface have been
X    simplified.  There are now only "Landscape" and "PS Figure" options.
X
X  * a "-coords" selection mode contributed by Matthew Freedman.  This
X    selection mode lets you specify the exact area to be grabbed.  Pre and
X    Post grab sleeping still applies, but there is no keyboard or mouse
X    interaction.
X
X  * if you specify an output file name with "-o", xgrabsc now puts a
X    %%File comment in Postscript output showing the name of the file the
X    image was written to.
X
X  * the resource files for the xgrab program are now run through xrdb
X    (and consequently the C preprocessor) to set the proper defaults for
X    page sizes and other settings from the config.h include file.  There
X    are new entries at the bottom of config.h for these resources.
X
X  * XWD style output for black & white images used to pack eight pixels per
X    output byte.  This has been changed so that output is one pixel per byte,
X    just like the xwd program.  A new option "-xwdxy" has been added to
X    give the packed style output and is equivalent to the "-xy" option
X    for the xwd program.  The unpacked format has not been extensively
X    tested.
X
X
Xand this release fixes the following bugs:
X
X  * the man page for xgrabsc said it accepts "-output" but it accepted only
X    "-o" or "-out".  It now accepts all three.
X
X  * NewsPrint had trouble with the "/max" definition in the CheckVM operator.
X    It has been changed to "/maximum" as recommended by Joe Ramey.
X
X  * several people reported that for little-endian machines (e.g.,
X    DECStations) the XWD-writing code was swapping the bits of the size of
X    the colormap before padding the output colormap with blacks.  This
X    resulted in very large output.
X
X  * XWD output for dithered images from color displays on screens with
X    Black==1 (e.g., color HPUX 9.0 tubes) was giving reversed images when
X    displayed with xwud on the same screen.  I wish MIT would require
X    Black to be 0 in all servers - it would make life a bit easier.
X
X  * XScreenNumberOfScreen not found in Xlib on HP's.  Xgrabsc now has its
X    own copy of this function
X
X  * Dumping of subwindows in earlier releases just didn't work at all.  In
X    this release, you can dump any window by ID.
X
X  * Preview images in EPSI files were using 1 for white and 0 for black.
X    The EPSF v2.0 spec states that "In the preview section, bits of 0 are
X    white, bits of 1 are black".  FrameMaker follows this but some releases
X    of xfig do not, so I've added a configuration option in config.h and
X    made the default follow the standard.
X
X  * xgrabsc was always looking at the root window for the colormap of an
X    image, even if point-and-click or window-id dumps were selected.  It
X    now gets the first colormap in the installed colormaps of the target
X    window.
X
X  * color postscript routines were leaving items on the stack after reading
X    an image's color table.  This could mess up postscript programs using
X    xgrabsc files.
X
X  * dithering operations were failing with displays having Black=1.  Fixing
X    this has unfortunately exposed a bug in xwud.  If xwud will display the
X    images with reversed colors.  xpr will display them properly
X
X  * postscript output now always includes %!PS-Adobe-2.0 and %%EndProlog
X    lines
X
X  * postscript preview output did not always indicate the correct number of
X    lines
X
X  * postscript previews sometimes had an erroneous blank line between data
X    and %%EndPreview
X  
X  * The -reverse option was only working for color images.  It now works for
X    black and white images also.
X
X  * XPM3 format was not using the output file name in forming a name for
X    the image structure  
X
END_OF_FILE
if test 5041 -ne `wc -c <'xgrabsc.2_3/README.2_3'`; then
    echo shar: \"'xgrabsc.2_3/README.2_3'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/README.2_3'
fi
if test -f 'xgrabsc.2_3/XWDFile.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/XWDFile.h'\"
else
echo shar: Extracting \"'xgrabsc.2_3/XWDFile.h'\" \(3317 characters\)
sed "s/^X//" >'xgrabsc.2_3/XWDFile.h' <<'END_OF_FILE'
X#include <X11/copyright.h>
X
X/* Copyright 1985, 1986, Massachusetts Institute of Technology */
X
X/* $XConsortium: XWDFile.h,v 1.12 89/10/08 16:33:57 rws Exp $ */
X/*
X * XWDFile.h	MIT Project Athena, X Window system window raster
X *		image dumper, dump file format header file.
X *
X *  Author:	Tony Della Fera, DEC
X *		27-Jun-85
X * 
X * Modifier:    William F. Wyatt, SAO
X *              18-Nov-86  - version 6 for saving/restoring color maps
X */
X
X
X/*
X * This is not portable between machines of differing word sizes.  To make
X * it portable, do the following things:
X *
X *     o  #include <X11/Xmd.h>
X *     o  remove the typedef for xwdval
X *     o  replace all instances of xwdval with the appropriate CARD32 ... B32
X *     o  make sure that XWDFileHeader is padded to quadword boundaries
X *     o  make sure the window name is written out quadword aligned
X *     o  create an XWDColor structure that contains the same fields as XColor
X *        but which is defined in terms of CARD32 B32, CARD16 B16, and CARD8
X *     o  convert XColor structures to XWDColor structures in xwd
X *     o  remove all xwdval casts from xwd
X *     o  pack image data before writing out if necessary
X *     o  replace casts from xwdval objects in xwud with cvtINT macros
X *     o  convert XWDColor structures to XColor structures
X *     o  unpack data after reading in if necessary
X */
X
X
X#include "Xmd.h"
X
X#define XWD_FILE_VERSION 7
X#ifdef WORD64
X#define sz_XWDheader 104
X#else
X#define sz_XWDheader 100
X#endif
X#define sz_XWDColor 12
X
Xtypedef CARD32 xwdval;		/* for old broken programs */
X
Xtypedef struct _xwd_file_header {
X	CARD32 header_size B32;  /* Size of the entire file header (bytes). */
X	CARD32 file_version B32;	/* XWD_FILE_VERSION */
X	CARD32 pixmap_format B32;	/* Pixmap format */
X	CARD32 pixmap_depth B32;	/* Pixmap depth */
X	CARD32 pixmap_width B32;	/* Pixmap width */
X	CARD32 pixmap_height B32;	/* Pixmap height */
X	CARD32 xoffset B32;		/* Bitmap x offset */
X	CARD32 byte_order B32;		/* MSBFirst, LSBFirst */
X	CARD32 bitmap_unit B32;		/* Bitmap unit */
X	CARD32 bitmap_bit_order B32;	/* MSBFirst, LSBFirst */
X	CARD32 bitmap_pad B32;		/* Bitmap scanline pad */
X	CARD32 bits_per_pixel B32;	/* Bits per pixel */
X	CARD32 bytes_per_line B32;	/* Bytes per scanline */
X	CARD32 visual_class B32;	/* Class of colormap */
X	CARD32 red_mask B32;		/* Z red mask */
X	CARD32 green_mask B32;		/* Z green mask */
X	CARD32 blue_mask B32;		/* Z blue mask */
X	CARD32 bits_per_rgb B32;	/* Log2 of distinct color values */
X	CARD32 colormap_entries B32;	/* Number of entries in colormap */
X	CARD32 ncolors B32;		/* Number of Color structures */
X	CARD32 window_width B32;	/* Window width */
X	CARD32 window_height B32;	/* Window height */
X	CARD32 window_x B32;		/* Window upper left X coordinate */
X	CARD32 window_y B32;		/* Window upper left Y coordinate */
X	CARD32 window_bdrwidth B32;	/* Window border width */
X#ifdef WORD64
X	CARD32 header_end B32;		/* Pad to fill out word */
X#endif
X} XWDFileHeader;
X
Xstruct {
X        CARD32	pixel B32;
X        CARD16	red B16;
X	CARD16	green B16;
X	CARD16	blue B16;
X        CARD8	flags;
X        CARD8	pad;
X} XWDColor;
X
X
X/*
X * Name - XWDFile.h
X *
X * ccs version:	1.1
X *
X * ccsid:	@(#)XWDFile.h	1.1 - 07/02/92 16:01:52
X * from: 	ccs/s.XWDFile.h
X * date: 	06/28/93 09:14:48
X *
X * This is XWDFile.h from XWindows v11r4
X */
END_OF_FILE
if test 3317 -ne `wc -c <'xgrabsc.2_3/XWDFile.h'`; then
    echo shar: \"'xgrabsc.2_3/XWDFile.h'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/XWDFile.h'
fi
if test -f 'xgrabsc.2_3/Xmd.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/Xmd.h'\"
else
echo shar: Extracting \"'xgrabsc.2_3/Xmd.h'\" \(4639 characters\)
sed "s/^X//" >'xgrabsc.2_3/Xmd.h' <<'END_OF_FILE'
X/***********************************************************
XCopyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
Xand the Massachusetts Institute of Technology, Cambridge, Massachusetts.
X
X                        All Rights Reserved
X
XPermission to use, copy, modify, and distribute this software and its 
Xdocumentation for any purpose and without fee is hereby granted, 
Xprovided that the above copyright notice appear in all copies and that
Xboth that copyright notice and this permission notice appear in 
Xsupporting documentation, and that the names of Digital or MIT not be
Xused in advertising or publicity pertaining to distribution of the
Xsoftware without specific, written prior permission.  
X
XDIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
XALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
XDIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
XANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
XWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
XARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
XSOFTWARE.
X
X******************************************************************/
X#ifndef XMD_H
X#define XMD_H 1
X/* $XConsortium: Xmd.h,v 1.35 89/08/15 14:38:57 jim Exp $ */
X/*
X *  Xmd.h: MACHINE DEPENDENT DECLARATIONS.
X */
X
X/*
X * Special per-machine configuration flags.
X */
X#ifdef CRAY
X#define WORD64				/* 64-bit architecture */
X#define UNSIGNEDBITFIELDS		/* bit fields do not honor sign */
X#endif
X
X
X/*
X * Stuff to handle large architecture machines; the constants were generated
X * on a 32-bit machine and must coorespond to the protocol.
X */
X#ifdef WORD64
X#define MUSTCOPY
X#endif /* WORD64 */
X
X
X/*
X * Definition of macro used to set constants for size of network structures;
X * machines with preprocessors that can't handle all of the sz_ symbols
X * can define this macro to be sizeof(x) if and only if their compiler doesn't
X * pad out structures (esp. the xTextElt structure which contains only two 
X * one-byte fields).  Network structures should always define sz_symbols.
X *
X * The sz_ prefix is used instead of something more descriptive so that the
X * symbols are no more than 32 characters long (which causes problems for some
X * compilers and preprocessors).
X */
X#if defined(__STDC__) && !defined(UNIXCPP)
X#define SIZEOF(x) sz_##x
X#else
X#define SIZEOF(x) sz_/**/x
X#endif /* if ANSI C compiler else not */
X
X
X
X/*
X * ibm pcc doesn't understand pragmas.
X */
X#if defined(ibm032) && defined(__HIGHC__)
Xpragma on(pointers_compatible);
Xpragma off(char_default_unsigned);
X#endif
X
X
X/*
X * Bitfield suffixes for the protocol structure elements, if you
X * need them.  Note that bitfields are not guarranteed to be signed
X * (or even unsigned) according to ANSI C.
X */
X#ifdef WORD64
X#define B32 :32
X#define B16 :16
X#else
X#define B32
X#define B16
X#endif
X
Xtypedef long           INT32;
Xtypedef short          INT16;
Xtypedef char           INT8;
X
Xtypedef unsigned long CARD32;
Xtypedef unsigned short CARD16;
Xtypedef unsigned char  CARD8;
X
Xtypedef unsigned long		BITS32;
Xtypedef unsigned short		BITS16;
Xtypedef unsigned char		BYTE;
X
Xtypedef unsigned char            BOOL;
X
X
X/*
X * definitions for sign-extending bitfields on 64-bit architectures
X */
X#if defined(WORD64) && defined(UNSIGNEDBITFIELDS)
X#define cvtINT8toInt(val)   (((val) & 0x00000080) ? ((val) | 0xffffffffffffff00) : (val))
X#define cvtINT16toInt(val)  (((val) & 0x00008000) ? ((val) | 0xffffffffffff0000) : (val))
X#define cvtINT32toInt(val)  (((val) & 0x80000000) ? ((val) | 0xffffffff00000000) : (val))
X#define cvtINT8toLong(val)  cvtINT8toInt(val)
X#define cvtINT16toLong(val) cvtINT16toInt(val)
X#define cvtINT32toLong(val) cvtINT32toInt(val)
X#else
X#define cvtINT8toInt(val) (val)
X#define cvtINT16toInt(val) (val)
X#define cvtINT32toInt(val) (val)
X#define cvtINT8toLong(val) (val)
X#define cvtINT16toLong(val) (val)
X#define cvtINT32toLong(val) (val)
X#endif /* WORD64 and UNSIGNEDBITFIELDS */
X
X
X
X#ifdef MUSTCOPY
X/*
X * This macro must not cast or else pointers will get aligned and be wrong
X */
X#define NEXTPTR(p,t)  (((char *) p) + SIZEOF(t))
X#else /* else not MUSTCOPY, this is used for 32-bit machines */
X/*
X * this version should leave result of type (t *), but that should only be 
X * used when not in MUSTCOPY
X */  
X#define NEXTPTR(p,t) (((t *)(p)) + 1)
X#endif /* MUSTCOPY - used machines whose C structs don't line up with proto */
X
X#endif /* XMD_H */
X
X/*
X * Name - Xmd.h
X *
X * ccs version:	1.1
X *
X * ccsid:	@(#)Xmd.h	1.1 - 07/02/92 16:01:53
X * from: 	ccs/s.Xmd.h
X * date: 	06/28/93 09:14:48
X *
X * This is Xmd.h from XWindows v11r4
X */
END_OF_FILE
if test 4639 -ne `wc -c <'xgrabsc.2_3/Xmd.h'`; then
    echo shar: \"'xgrabsc.2_3/Xmd.h'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/Xmd.h'
fi
if test -f 'xgrabsc.2_3/cmdopts.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/cmdopts.h'\"
else
echo shar: Extracting \"'xgrabsc.2_3/cmdopts.h'\" \(3079 characters\)
sed "s/^X//" >'xgrabsc.2_3/cmdopts.h' <<'END_OF_FILE'
X/*========================================================================
X *
X * Name - cmdopts.h
X *
X * ccs version:	1.6
X *
X * ccsid:	@(#)cmdopts.h	1.6 - 06/28/93 09:13:42
X * from: 	ccs/s.cmdopts.h
X * date: 	06/28/93 09:14:48
X *
X * Copyright (c) 1990-93 Bruce Schuchardt.
X * Read the file cpyright.h for full copyright information.
X *
X *
X * Description:
X *
X * command line options for xgrabsc
X *
X *========================================================================
X */
X
Xtypedef enum {
X  CMD_BELL,
X  CMD_GRABSERVER,
X  CMD_DISPLAY,
X  CMD_OUTPUT,
X  CMD_PRESLEEP,
X  CMD_POSTSLEEP,
X  CMD_VERBOSE,
X  CMD_BORDERS,
X  CMD_NOBORDERS,
X
X  CMD_SOURCE_KEY,
X  CMD_SOURCE_ID,
X  CMD_SOURCE_RECT,
X  CMD_SOURCE_ROOT,
X  CMD_SOURCE_WD,
X
X  CMD_AND,
X  CMD_OR,
X  CMD_NOT,
X  CMD_BRIGHTEN,
X
X  CMD_DITHER_MAP,
X  CMD_DITHER_MATRIX,
X  CMD_DITHER_FS,
X  CMD_DITHER_HALFTONE,
X  CMD_DITHER_NONE,
X
X  CMD_OUTPUT_PS,
X  CMD_OUTPUT_CPS,
X  CMD_OUTPUT_SIMPLE,
X  CMD_OUTPUT_XWD,
X  CMD_OUTPUT_XWDXY,
X  CMD_OUTPUT_XPM,
X  CMD_OUTPUT_XPM2,
X  CMD_OUTPUT_XPM3,
X  CMD_OUTPUT_PIXMAP,
X  CMD_OUTPUT_PUZZLE,
X
X  CMD_BIN,
X  CMD_COMPRESS,
X  CMD_EPS,
X  CMD_PREVIEWONLY,
X  CMD_LANDSCAPE,
X  CMD_LIMIT,
X  CMD_PAGE,
X  CMD_PREVIEW,
X  CMD_COLORPROC,
X
X  CMD_SOURCE_COORDS
X  
X  } commandEnum;
X
X
Xtypedef struct {
X  commandEnum	command;
X  int		numargs;
X  char		*userstr;
X  } commandType;
X
XcommandType commands[] = {
X {  CMD_BELL,		0, "bell"	},
X {  CMD_GRABSERVER,	0, "grab"	},
X {  CMD_DISPLAY,	1, "d"		},
X {  CMD_DISPLAY,	1, "display"	},
X {  CMD_OUTPUT,		1, "o"		},
X {  CMD_OUTPUT,		1, "out"	},
X {  CMD_OUTPUT,		1, "output"	},
X {  CMD_PRESLEEP,	1, "s"		},
X {  CMD_PRESLEEP,	1, "sleep"	},
X {  CMD_POSTSLEEP,	1, "post"	},
X {  CMD_VERBOSE,	0, "verbose"	},
X {  CMD_BORDERS,	0, "borders"	},
X {  CMD_BORDERS,	0, "bdrs"	},
X
X {  CMD_SOURCE_KEY,	0, "key"	},
X {  CMD_SOURCE_ID,	1, "id"		},
X {  CMD_SOURCE_RECT,	0, "stretch"	},
X {  CMD_SOURCE_ROOT,	0, "root"	},
X {  CMD_SOURCE_WD,	0, "click"	},
X
X {  CMD_AND,		1, "and"	},
X {  CMD_OR,		1, "or"		},
X {  CMD_NOT,		0, "reverse"	},
X {  CMD_BRIGHTEN,	1, "b"		},
X {  CMD_BRIGHTEN,	1, "brighten"	},
X
X {  CMD_DITHER_MAP,	0, "bw"		},
X {  CMD_DITHER_MATRIX,	0, "mdither"	},
X {  CMD_DITHER_FS,	0, "dither"	},
X {  CMD_DITHER_HALFTONE,0, "halftone"	},
X/*  {  CMD_DITHER_NONE,    0, "nodither"   }, */
X
X {  CMD_OUTPUT_PS,	0, "ps"		},
X {  CMD_OUTPUT_CPS,	0, "cps"	},
X {  CMD_OUTPUT_SIMPLE,	0, "simple"	},
X {  CMD_OUTPUT_XWD,	0, "xwd"	},
X {  CMD_OUTPUT_XWDXY,   0, "xwdxy"      },
X {  CMD_OUTPUT_PIXMAP,	0, "bm"		},
X {  CMD_OUTPUT_XPM2,	0, "bm2"	},
X {  CMD_OUTPUT_XPM3,	0, "bm3"	},
X {  CMD_OUTPUT_PUZZLE,	0, "puzzle"	},
X
X {  CMD_BIN,    	0, "bin"	},
X {  CMD_COMPRESS, 	0, "comp"	},
X {  CMD_COMPRESS, 	0, "compress"	},
X {  CMD_EPS,    	0, "eps"	},
X {  CMD_PREVIEWONLY,	0, "previewonly"},
X {  CMD_LANDSCAPE,	0, "l"		},
X {  CMD_LANDSCAPE,	0, "landscape"	},
X {  CMD_LIMIT,		0, "limit"	},
X {  CMD_PAGE,		1, "page"	},
X {  CMD_PREVIEW,	0, "preview"	},
X {  CMD_PREVIEW,	0, "prev"	},
X {  CMD_COLORPROC,	0, "colproc"    },
X 
X {  CMD_SOURCE_COORDS,  1, "coords"     }
X 
X};
X
Xint numCmds = sizeof(commands) / sizeof(commandType);
END_OF_FILE
if test 3079 -ne `wc -c <'xgrabsc.2_3/cmdopts.h'`; then
    echo shar: \"'xgrabsc.2_3/cmdopts.h'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/cmdopts.h'
fi
if test -f 'xgrabsc.2_3/config.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/config.h'\"
else
echo shar: Extracting \"'xgrabsc.2_3/config.h'\" \(4162 characters\)
sed "s/^X//" >'xgrabsc.2_3/config.h' <<'END_OF_FILE'
X/*========================================================================
X *
X * Name - config.h
X *
X * Version:	1.11
X *
X * ccsid:	@(#)config.h	1.11 - 06/28/93 09:13:43
X * from: 	ccs/s.config.h
X * date: 	06/28/93 09:14:48
X *
X * Copyright (c) 1991-93 Bruce Schuchardt.
X * Read the file cpyright.h for full copyright information.
X *
X *
X * Description:
X *   configuration options for xgrabsc
X *
X *========================================================================
X */
X
X/* if you do not have memcpy routines but do have bcopy, define the following */
X/* #define BCOPY */
X
X/* if you have neither memcpy nor bcopy, or for some other reason would like
X * to use xgrabsc's version of memcpy, define the following */
X/* #define MEMCPY */
X
X/* if you want to use some other key than Control for selection, define
X * the following and replace ControlMask with the mask of your choice */
X/* #define SELECTION_MASK ControlMask */
X
X/* when forming postscript output and the "-c" option has not been specified,
X * xgrabsc will make a pass over the image to determine whether run-length
X * encoding will shrink the output appreciably.  If you are building xgrabsc
X * for a slower machine, you may wish to avoid this overhead.  If so,
X * define the following */
X/* #define NO_RLE_CHECKS */
X
X/* When forming color postscript output, xgrabsc will include a color to
X * greyscale converter in the output so that it can also be printed on
X * non-color printers.  If you prefer to have this converter omitted from
X * color postscript output by default, change the following to FALSE */
X#define DEFAULT_NEED_COLORIMAGE_PROC  TRUE
X
X
X/* Xgrabsc will look for a virtual-window manager's root window for
X * window dumps.  If the virtual-window manager support code gives you
X * trouble, define the following to omit it */
X/* #define NO_VIRTUAL_WINDOW */
X
X/* Xgrabsc can write code to check printer memory availability before
X * attempting to display an image.  Postscript previewers may cause problems
X * with this since they usually allocate memory as needed, and so will
X * often fail memory-availability checks.
X * Editors, such as FrameMaker can also cause problems like this, so
X * the checks are always turned off when Encapsulated Postscript format is
X * requested.
X * A command line switch can also turn checks on or off, but they can be
X * disabled totally here by commenting out the following line. */
X#define NO_PRINTER_MEMORY_CHECKS
X
X
X
X/* The "Encapsulated PostScript FILES Specification Version 2.0" document
X * specifies that preview images in EPSF files must use 1 for black and
X * 0 for white.  FrameMaker adheres to this but xfig does not.  The default
X * for xgrabsc is to follow the specification, but if you use a tool like
X * xfig that expects 0 to be black, change the following definition.
X */
X#define EPSF_BLACK 1
X
X/* xgrabsc has a hard-coded notion of the size of your printer's paper.
X * The default is for US Letter size (8.5x11.0 inch).
X * The inset sizes control the maximum size of the image on the page.
X * These are preset to leave at least a 0.5 inch border around the image.
X */
X#define PAPER_WIDTH         8.5   /* inches are assumed */
X#define PAPER_HEIGHT       11.0
X
X#define VERT_MARGIN	    0.5
X#define HORIZ_MARGIN	    0.5
X
X
X/* xgrabsc generates images by bunches of IMAGE_CODEWIDTH chars for the
X * images, and PREVIEW_CODEWITH chars for the EPSI preview image.
X * Change them if you want larger or smaller lines, but make sure the
X * numbers you choose are divisible by 2!
X */
X#define IMAGE_CODEWIDTH	     60
X#define PREVIEW_CODEWIDTH    60
X
X
X/* xgrab can add/increment numbers in file names for 'to file' output.
X * If there is no number, a '1' will be added after the last period in
X * the file name or at the end of the file name if there is no period.
X * Numbers found in such positions will be bumped after each grab.
X */
X#define BUMP_FILENAMES
X
X
X/* the following options let you specify what the default file name
X * and command are for the xgrab program, and the default pre and post
X * snapshot sleep times
X */
X#define DEFAULT_FILENAME  screen1.dmp
X#define DEFAULT_COMMAND   lpr
X#define DEFAULT_PRESLEEP  3
X#define DEFAULT_POSTSLEEP 0
X
END_OF_FILE
if test 4162 -ne `wc -c <'xgrabsc.2_3/config.h'`; then
    echo shar: \"'xgrabsc.2_3/config.h'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/config.h'
fi
if test -f 'xgrabsc.2_3/cpyright.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/cpyright.h'\"
else
echo shar: Extracting \"'xgrabsc.2_3/cpyright.h'\" \(2267 characters\)
sed "s/^X//" >'xgrabsc.2_3/cpyright.h' <<'END_OF_FILE'
X#ifndef _COPYRIGHT_
X#define _COPYRIGHT_
X/*========================================================================
X*
X* Name - cpyright.h
X*
X* Version:	1.6
X*
X* ccsid:	@(#)cpyright.h	1.6 - 04/26/93 17:44:24
X* from: 	ccs/s.cpyright.h
X* date: 	06/28/93 09:14:48
X*
X* Description: copyright information for xgrabsc
X*
X*========================================================================
X*
X* Copyright (C) 1990-93 Bruce Schuchardt, Servio Corp.
X*
X* Permission to use, copy, modify, distribute, and sell this software
X* and its documentation for any purpose is hereby granted without fee,
X* provided that the above copyright notice appear in all copies, and
X* that both that copyright notice and this permission notice appear
X* in supporting documentation.  The author makes no representations
X* about the suitability of this software for any purpose.  It is
X* provided "as is" without express or implied warranty.
X*
X* THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X* INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
X* NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR
X* CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
X* OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
X* OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
X* USE OR PERFORMANCE OF THIS SOFTWARE.
X*
X* GetClientWindow() and TryChildren() functions in xgrabsc.c are
X* copyrighted by MIT:
X*
X*   Copyright 1989 by the Massachusetts Institute of Technology
X*
X*   Permission to use, copy, modify, and distribute this [XmuClientWindow]
X*   software and its
X*   documentation for any purpose and without fee is hereby granted, provided 
X*   that the above copyright notice appear in all copies and that both that 
X*   copyright notice and this permission notice appear in supporting 
X*   documentation, and that the name of M.I.T. not be used in advertising
X*   or publicity pertaining to distribution of the software without specific, 
X*   written prior permission. M.I.T. makes no representations about the 
X*   suitability of this software for any purpose.  It is provided "as is"
X*   without express or implied warranty.
X*/
X
Xstatic char *Copyright = "Copyright (C) 1990-93 Bruce Schuchardt";
X#endif
X
X
END_OF_FILE
if test 2267 -ne `wc -c <'xgrabsc.2_3/cpyright.h'`; then
    echo shar: \"'xgrabsc.2_3/cpyright.h'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/cpyright.h'
fi
if test -f 'xgrabsc.2_3/get.hc' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/get.hc'\"
else
echo shar: Extracting \"'xgrabsc.2_3/get.hc'\" \(7556 characters\)
sed "s/^X//" >'xgrabsc.2_3/get.hc' <<'END_OF_FILE'
X/*========================================================================
X *
X * Name - get.hc
X *
X * ccs version:	1.4
X *
X * ccsid:	@(#)get.hc	1.4 - 11/03/92 14:55:59
X * from: 	ccs/s.get.hc
X * date: 	06/28/93 09:14:48
X *
X * Description:  image grabbing functions for xgrabsc
X *
X *               see cpyright.h for copyright information
X *
X *
X *========================================================================
X */
X
X/*
X * Get the image bounded by the given rectangle.
X * The associated colormap information is also extracted and returned.
X * TRUE is returned if an image was successfully grabbed, and FALSE
X * otherwise.
X */
XgetImage(xrect, image, window, cmapwindow)
X  XRectangle *xrect;
X  imageInfo *image;
X  Window window, cmapwindow;
X{
X  XImage *ximage;
X  int depth, ncolors, cmapSize, numCmaps;
X  int h, w;
X  long i;
X  XColor colors[MAX_CELLS];
X  Colormap *cmaps, cmap;
X
X  if (xrect->width == 0  || xrect->height == 0)
X    return FALSE;
X
X  /* get the image */
X  depth  = DefaultDepth(hDisplay, hScreen);
X  ximage = XGetImage(hDisplay, window,
X            xrect->x, xrect->y, xrect->width, xrect->height, AllPlanes,
X            depth==1 ? XYPixmap : ZPixmap);
X  image->ximage = ximage;
X
X  /* get the colormap info */
X  if (cmapwindow != (Window)NULL)
X    cmaps = XListInstalledColormaps(hDisplay, cmapwindow, &numCmaps);
X  else
X    cmaps = XListInstalledColormaps(hDisplay, window, &numCmaps);
X
X  if (numCmaps == 0)
X    cmap = DefaultColormap(hDisplay, hScreen);
X  else {
X    cmap = *cmaps;
X    if (numCmaps > 1)
X      fprintf(stderr,
X        "%s: more than one colormap found - using first encountered",
X        programName);
X  }
X  XFree(cmaps);
X
X  ncolors = DisplayCells(hDisplay, hScreen);
X  /* this won't cut the mustard for DirectColor */
X  for (i=0; i<ncolors; i++)
X    colors[i].pixel = i;
X
X  XQueryColors(hDisplay, cmap, colors, ncolors);
X  for (i=0; i<ncolors; i++) {
X    image->red[i]   = colors[i].red;
X    image->green[i] = colors[i].green;
X    image->blue[i]  = colors[i].blue;
X  }
X
X  /* figure out which colormap entries are actually used by the image */
X  ncolors = cmapSize = 0;
X  memset((char *)image->used, 0, MAX_CELLS);
X  for (h=0; h<ximage->height; h++)
X    for (w=0; w<ximage->width; w++) {
X      i = XGetPixel(ximage, w, h);
X      if (!image->used[i]) {
X        image->used[i] = TRUE;
X        if (i+1 > cmapSize)      /* keep track of colormap size */
X          cmapSize = i+1;
X        ncolors++;
X      }
X    }
X  image->numcells = cmapSize;
X  if (verbose)
X    fprintf(stderr, "%s: image has %d colors\n", programName, ncolors);
X
X  return TRUE;
X}
X
X
X
X/*
X * Let the user stretch a rectangle on the screen and return its values.
X * It may be wise to grab the server before calling this routine.  If the
X * screen is allowed to change during XOR drawing video droppings may result.
X */
XgetRectangle(xrect)
X  XRectangle *xrect;
X{
X  XEvent event;
X  unsigned int x, y, rootx, rooty;
X  GC gc;
X  Cursor pointer1, pointer2;
X  int boxDrawn = False;
X  int rx, ry, rw, rh;
X
X  /* get some cursors for rectangle formation */
X  pointer1 = XCreateFontCursor(hDisplay, XC_ul_angle);
X  pointer2 = XCreateFontCursor(hDisplay, XC_lr_angle);
X
X  /* grab the pointer */
X  if (GrabSuccess != XGrabPointer(hDisplay, hRoot, False, ButtonPressMask,
X        GrabModeAsync, GrabModeAsync, hRoot, pointer1, CurrentTime)) {
X    fprintf(stderr,"%s - could not grab pointer!\n", programName);
X    exit(3);
X  }
X
X  /* create a graphics context to draw with */
X  gc = XCreateGC(hDisplay, hRoot, 0, NULL);
X  if (!gc) {
X    fprintf(stderr,"%s - could not get drawing resources\n", programName);
X    exit(3);
X  }
X  XSetSubwindowMode(hDisplay, gc, IncludeInferiors);
X  XSetForeground(hDisplay, gc, 255);
X  XSetFunction(hDisplay, gc, GXxor);
X
X  /* get a button-press and pull out the root location */
X  XMaskEvent(hDisplay, ButtonPressMask, &event);
X  rootx = rx = event.xbutton.x_root;
X  rooty = ry = event.xbutton.y_root;
X
X  /* get pointer motion events */
X  XChangeActivePointerGrab(hDisplay, ButtonMotionMask | ButtonReleaseMask,
X        pointer2, CurrentTime);
X
X
X  /* MAKE_RECT converts the original root coordinates and the event root
X   * coordinates into a rectangle in xrect */
X#define MAKE_RECT(etype) \
X  x = event.etype.x_root;       \
X  y = event.etype.y_root;       \
X  rw  = x - rootx;              \
X  if (rw  < 0) rw  = -rw;       \
X  rh  = y - rooty;              \
X  if (rh  < 0) rh  = -rh;       \
X  rx = x < rootx ? x : rootx;   \
X  ry = y < rooty ? y : rooty
X
X  /* loop to let the user drag a rectangle */
X  while (TRUE) {
X    XNextEvent(hDisplay, &event);
X    switch(event.type) {
X      case ButtonRelease:
X        if (boxDrawn) {
X          XDrawRectangle(hDisplay, hRoot, gc, rx, ry, rw, rh);
X          boxDrawn = False;
X        }
X        XFlush(hDisplay);
X        /* record the final location */
X        MAKE_RECT(xbutton);
X        /* release resources */
X        XFreeGC(hDisplay, gc);
X        XFreeCursor(hDisplay, pointer1);
X        XFreeCursor(hDisplay, pointer2);
X        xrect->x      = rx;
X        xrect->y      = ry;
X        xrect->width  = rw;
X        xrect->height = rh;
X        XUngrabPointer(hDisplay, CurrentTime);
X	XSync(hDisplay, FALSE);
X        return True;
X      case MotionNotify:
X        if (boxDrawn) {
X          XDrawRectangle(hDisplay, hRoot, gc, rx, ry, rw, rh);
X          boxDrawn = False;
X        }
X        while (XCheckTypedEvent(hDisplay, MotionNotify, &event))
X          {}
X        MAKE_RECT(xmotion);
X        XDrawRectangle(hDisplay, hRoot, gc, rx, ry, rw, rh);
X        boxDrawn = True;
X        break;
X    }
X  }
X}
X
X
X
X
X
X
X/*
X * find the window under the mouse pointer when one of the bits in keyMask
X * is satisfied.
X */
XWindow getWindowWhenKeyIsPressed(keyMask)
X  unsigned int keyMask;
X{
X  Bool status;
X  Window result;
X  Window root, child;
X  int root_x, root_y, win_x, win_y;
X  unsigned int keys_buttons;
X
X  if (verbose)
X    fprintf(stderr, "%s: waiting for keypress\n", programName);
X
X  do {
X    status = XQueryPointer(hDisplay, vRoot, &root, &child,
X              &root_x, &root_y, &win_x, &win_y, &keys_buttons);
X    if (!status)
X      return (Window)0;
X  } while ((keyMask != 0) && ((keyMask & keys_buttons) == 0));
X
X  if (child == (Window)0) {
X    if (verbose) {
X      fprintf(stderr, "%s: unable to find a non-root window under pointer.\n",
X              programName);
X      fprintf(stderr, "%s: using root window.\n", programName);
X    }
X    result = (Window)vRoot;
X  }
X  else
X    result = child;
X
X  if (verbose)
X    fprintf(stderr, "%s: returning window id %d\n", programName, result);
X
X  return result;
X}
X
X
X
X
X/*
X * choose a window as in xwd
X */
X
XWindow getWindow() {
X  int status;
X  Cursor cursor;
X  XEvent event;
X  Window result;
X
X  result = None;
X
X  cursor = XCreateFontCursor(hDisplay, XC_target);
X
X  status = XGrabPointer(hDisplay, vRoot, FALSE,
X         ButtonPressMask|ButtonReleaseMask, GrabModeSync,
X         GrabModeAsync, hRoot, cursor, CurrentTime);
X  if (status != GrabSuccess) {
X    fprintf(stderr, "%s: can't grab mouse\n", programName);
X    exit(3);
X  }
X
X  while (TRUE) {
X    XAllowEvents(hDisplay, SyncPointer, CurrentTime);
X    XWindowEvent(hDisplay, vRoot, ButtonPressMask|ButtonReleaseMask, &event);
X
X    switch (event.type) {
X      case ButtonRelease:
X        result = event.xbutton.subwindow;
X        if (result == None)
X          result = hRoot;
X        XUngrabPointer(hDisplay, CurrentTime);      /* Done with pointer */
X        if (verbose)
X          fprintf(stderr, "%s: found window with id 0x%x\n", programName, result);
X        return result;
X        break;
X    }
X  }
X
X}
X
X
X
X
END_OF_FILE
if test 7556 -ne `wc -c <'xgrabsc.2_3/get.hc'`; then
    echo shar: \"'xgrabsc.2_3/get.hc'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/get.hc'
fi
if test -f 'xgrabsc.2_3/hp.mak' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/hp.mak'\"
else
echo shar: Extracting \"'xgrabsc.2_3/hp.mak'\" \(3278 characters\)
sed "s/^X//" >'xgrabsc.2_3/hp.mak' <<'END_OF_FILE'
X#=============================================================================
X#
X# Name - hp.mak
X#
X# Version:	1.3
X#
X# ccsid:	@(#)hp.mak	1.3 - 06/25/93 12:54:20
X# from: 	ccs/s.hp.mak
X# date: 	06/28/93 09:14:48
X#
X# Description: make file for xgrabsc for HPUX 9.01.  Use "make -f hp.mak"
X#
X# Read through the options up to "all: $(PROGRAMS)" and change as needed
X#
X#=============================================================================
X
X# change WEXT if you want to build the Athena version of the window
X# interface (not recommended if you have Motif 1.2 libraries).  The default
X# for HP machines is to build the Motif version, but you need v1.2
X# which is shipped with HPUX 9.0 and later.  If you have 8.07 you should
X# build the xaw version.
XWEXT = xm
X#WEXT = xaw
X
X#CC=gcc
XCP=cp
XXRDB=/usr/bin/X11/xrdb
X
X# if your X include/library files aren't in normal places, use these:
XXINC = -I/usr/include/X11R5
XXLIB = -L/usr/lib/X11R5
X
X# if you are building xgrabxm, and your Motif include/library files aren't
X# in the normal places, use these:
XMOTIFINC = -I/usr/include/Motif1.2
XMOTIFLIB = -L/usr/lib/Motif1.2
X
X# set your favorite compilation flags
X#CFLAGS = -g $(XINC)
XCFLAGS = +O3 $(XINC)
X
X# set your favorite linker flags
X#LDFLAGS = $(XLIB) -Wl,-a,archive
XLDFLAGS = $(XLIB)
X
X# change INSTALL_PATH to the directory in which you want xgrabsc installed
XINSTALL_PATH    = /usr/bin/X11
X
X# change XAPPLOADDIR to the directory in which your want xgrab app-defaults
X# installed
XXAPPLOADDIR = /usr/lib/X11/app-defaults
X
X# change MAN_PATH to point to your man page top directory
XMAN_PATH        = /usr/man
X
X# change MAN_EXT to the section for xgrabsc
XMAN_EXT         = n
X
XPROGRAMS = xgrabsc xgrab
X
Xall: $(PROGRAMS)
X
Xxgrabsc: xgrabsc.o
X	rm -f xgrabsc
X	$(CC) $(LDFLAGS) $(CFLAGS) -o xgrabsc xgrabsc.o -lX11
X
Xxgrabsc.o: xgrabsc.c checkvm.h patchlevel.h cpyright.h \
X  process.hc get.hc mem.hc convert.hc write.hc cmdopts.h config.h
X
Xxgrab: xgrab$(WEXT) XGrab.ad
X	$(CP) xgrab$(WEXT) xgrab
X
XXGrab.ad: XGrab$(WEXT).ad
X	$(CP) XGrab$(WEXT).ad XGrab.ad
X
Xxgrabxaw: xgrabxaw.o
X	rm -f xgrabxaw
X	$(CC) $(LDFLAGS) $(CFLAGS) -o xgrabxaw xgrabxaw.o -lXaw -lXt -lXmu -lXext -lX11
X
Xxgrabxaw.o: xgrabxaw.c xgrabxaw_ad.h config.h
X
Xxgrabxaw_ad.h: XGrabxaw.ad
X	rm -f xgrabxaw_ad.h
X	sed -n '1,/! ====/p' XGrabxaw.ad | sed -n -f ad2c.sed >xgrabxaw_ad.h
X
XXGrabxaw.ad: XGrabxaw.res config.h
X	rm -f XGrabxaw.ad
X	$(XRDB) -n XGrabxaw.res >XGrabxaw.ad
X
X
Xxgrabxm: xgrabxm.o
X	rm -f xgrabxm
X	$(CC) $(LDFLAGS) $(CFLAGS) -o xgrabxm xgrabxm.o $(MOTIFLIB) -lXm -lXt -lXext -lX11
X
Xxgrabxm.o: xgrabxm.c xgrabxm_ad.h config.h
X	$(CC) -c $(CFLAGS) $(MOTIFINC) xgrabxm.c
X
Xxgrabxm_ad.h: XGrabxm.ad
X	rm -f xgrabxm_ad.h
X	sed -n '1,/! ====/p' XGrabxm.ad | sed -n -f ad2c.sed >xgrabxm_ad.h
X
XXGrabxm.ad: XGrabxm.res config.h
X	rm -f XGrabxm.ad
X	$(XRDB) -n XGrabxm.res >XGrabxm.ad
X
X
Xinstall: all
X	install -c -s xgrabsc $(INSTALL_PATH)
X	install -c xgrab $(INSTALL_PATH)
X	install -c XGrab.ad $(XAPPLOADDIR)/XGrab
X
Xinstall.man::
X	install -c -m 644 xgrabsc.man \
X		$(MAN_PATH)/man$(MAN_EXT)/xgrabsc.$(MAN_EXT)
X	install -c -m 644 xgrab.man \
X		$(MAN_PATH)/man$(MAN_EXT)/xgrab.$(MAN_EXT)
X
Xclean::
X	rm -f core *.o xgrabsc xgrab xgrabxm xgrabxaw XGrab.ad *.log xgrab_ad.h test*
X	rm -f xgrabxaw_ad.h xgrabxm_ad.h
X	rm -f XGrabxaw.ad XGrabxm.ad
X
END_OF_FILE
if test 3278 -ne `wc -c <'xgrabsc.2_3/hp.mak'`; then
    echo shar: \"'xgrabsc.2_3/hp.mak'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/hp.mak'
fi
if test -f 'xgrabsc.2_3/simple.mak' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/simple.mak'\"
else
echo shar: Extracting \"'xgrabsc.2_3/simple.mak'\" \(3102 characters\)
sed "s/^X//" >'xgrabsc.2_3/simple.mak' <<'END_OF_FILE'
X#=============================================================================
X#
X# Name - simple.mak
X#
X# Version:	1.16
X#
X# ccsid:	@(#)simple.mak	1.16 - 06/28/93 09:13:44
X# from: 	ccs/s.simple.mak
X# date: 	06/28/93 09:14:49
X#
X# Description: make file for xgrabsc.  Use "make -f simple.mak"
X#
X# Read through the options up to "all: $(PROGRAMS)" and change as needed
X#
X#=============================================================================
X
X#CC=gcc
XCP=cp
XXRDB=/usr/bin/X11/xrdb
X
X# change WEXT if you want to build the Motif version of the window
X# interface (recommended if you have Motif 1.2 libraries).
X#WEXT = xm
XWEXT = xaw
X
X# if your X include/library files aren't in normal places, use these:
X#XINC = -I/usr/include/X11R5
X#XLIB = -L/usr/lib/X11R5
X
X# if you are building xgrabxm, and your Motif include/library files aren't
X# in the normal places, use these:
X#MOTIFINC = -I/usr/include/Motif1.2
X#MOTIFLIB = -L/usr/lib/Motif1.2
X
X# set your favorite compilation flags
X#CFLAGS = -g $(XINC)
XCFLAGS = -O $(XINC)
X
X# set your favorite linker flags
X#LDFLAGS = $(XLIB) -Wl,-a,archive
XLDFLAGS = $(XLIB)
X
X# change INSTALL_PATH to the directory in which you want xgrabsc installed
XINSTALL_PATH    = /usr/bin/X11
X
X# change XAPPLOADDIR to the directory in which your want xgrab app-defaults
X# installed
XXAPPLOADDIR = /usr/lib/X11/app-defaults
X
X# change MAN_PATH to point to your man page top directory
XMAN_PATH        = /usr/man
X
X# change MAN_EXT to the section for xgrabsc
XMAN_EXT         = n
X
XPROGRAMS = xgrabsc xgrab
X
Xall: $(PROGRAMS)
X
Xxgrabsc: xgrabsc.o
X	rm -f xgrabsc
X	$(CC) $(LDFLAGS) $(CFLAGS) -o xgrabsc xgrabsc.o -lX11
X
Xxgrabsc.o: xgrabsc.c checkvm.h patchlevel.h cpyright.h \
X  process.hc get.hc mem.hc convert.hc write.hc cmdopts.h config.h
X
Xxgrab: xgrab$(WEXT) XGrab.ad
X	$(CP) xgrab$(WEXT) xgrab
X
XXGrab.ad: XGrab$(WEXT).ad
X	$(CP) XGrab$(WEXT).ad XGrab.ad
X
Xxgrabxaw: xgrabxaw.o
X	rm -f xgrabxaw
X	$(CC) $(LDFLAGS) $(CFLAGS) -o xgrabxaw xgrabxaw.o -lXaw -lXt -lXmu -lXext -lX11
X
Xxgrabxaw.o: xgrabxaw.c xgrabxaw_ad.h config.h
X
Xxgrabxaw_ad.h: XGrabxaw.ad
X	rm -f xgrabxaw_ad.h
X	sed -n '1,/! ====/p' XGrabxaw.ad | sed -n -f ad2c.sed >xgrabxaw_ad.h
X
XXGrabxaw.ad: XGrabxaw.res config.h
X	rm -f XGrabxaw.ad
X	$(XRDB) -n XGrabxaw.res >XGrabxaw.ad
X
X
Xxgrabxm: xgrabxm.o
X	rm -f xgrabxm
X	$(CC) $(LDFLAGS) $(CFLAGS) -o xgrabxm xgrabxm.o $(MOTIFLIB) -lXm -lXt -lXext -lX11
X
Xxgrabxm.o: xgrabxm.c xgrabxm_ad.h config.h
X	$(CC) -c $(CFLAGS) $(MOTIFINC) xgrabxm.c
X
Xxgrabxm_ad.h: XGrabxm.ad
X	rm -f xgrabxm_ad.h
X	sed -n '1,/! ====/p' XGrabxm.ad | sed -n -f ad2c.sed >xgrabxm_ad.h
X
XXGrabxm.ad: XGrabxm.res config.h
X	rm -f XGrabxm.ad
X	$(XRDB) -n XGrabxm.res >XGrabxm.ad
X
X
Xinstall: all
X	install -c -s xgrabsc $(INSTALL_PATH)
X	install -c xgrab $(INSTALL_PATH)
X	install -c XGrab.ad $(XAPPLOADDIR)/XGrab
X
Xinstall.man::
X	install -c -m 644 xgrabsc.man \
X		$(MAN_PATH)/man$(MAN_EXT)/xgrabsc.$(MAN_EXT)
X	install -c -m 644 xgrab.man \
X		$(MAN_PATH)/man$(MAN_EXT)/xgrab.$(MAN_EXT)
X
Xclean::
X	rm -f core *.o xgrabsc xgrab xgrabxm xgrabxaw XGrab.ad *.log xgrab_ad.h test*
X	rm -f xgrabxaw_ad.h xgrabxm_ad.h
X	rm -f XGrabxaw.ad XGrabxm.ad
X
END_OF_FILE
if test 3102 -ne `wc -c <'xgrabsc.2_3/simple.mak'`; then
    echo shar: \"'xgrabsc.2_3/simple.mak'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/simple.mak'
fi
if test -f 'xgrabsc.2_3/xgrab.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xgrabsc.2_3/xgrab.man'\"
else
echo shar: Extracting \"'xgrabsc.2_3/xgrab.man'\" \(4500 characters\)
sed "s/^X//" >'xgrabsc.2_3/xgrab.man' <<'END_OF_FILE'
X.\"========================================================================
X.\"
X.\" Name - xgrab.man
X.\"
X.\" ccs version: 1.8
X.\"
X.\" ccsid:	@(#)xgrab.man	1.8 - 06/25/93 13:29:31
X.\" from: 	ccs/s.xgrab.man
X.\" date: 	06/28/93 09:14:49
X.\"
X.\" Copyright (C) 1990-92 Bruce Schuchardt
X.\" See the end of this document for full copyright information.
X.\"
X.\" Description:  Man page for xgrab
X.\"
X.\"========================================================================
X.\"
X.TH XGRAB 1X
X.\"
X.SH NAME
Xxgrab \- interactive front for xgrabsc, an X-Windows image grabber
X.\"
X.SH SYNOPSIS
X.in +8n
X.ti -8n
X\fIxgrab\fR
X.in -8n
X.\"
X.SH DESCRIPTION
X\fIxgrab\fR lets you grab arbitrary rectangular images from an
XX server and writes them to files or commands (such as lpr) in
Xa variety of formats.
X.PP
X\fIxgrab\fR is a front for the xgrabsc program.
XRead the man page for \fIxgrabsc\fR for a description of the options
Xpresented by xgrab.
X.PP
XAfter selecting options from the various categories presented, press
Xthe \fIOK\fR button to have xgrab run xgrabsc to let you grab an image
Xfrom the screen.  After you press \fIOK\fP, xgrab's window will disappear
Xand xgrabsc will gain control until the grabbing process is finished.
XAfterwards, the xgrab window will reappear.
X.sp 2
X.SH OPTIONS
XXgrab responds to the standard application options, such as \fI-display\fP.
XSee the man page for \fIX\fP for a complete list.
X.sp
XYou can also override the default xgrab settings in your .Xdefaults.  See
Xthe examples section below for instructions.
X.sp 2
X.SH RESOURCES
XThe XGrab resource file, XGrab.ad, contains a complete specification of the
Xresources of all the widgets used in the xgrab window.  Global resources,
Xsuch as default font and color, are at the bottom of the file.
X.sp 2
X.SH EXAMPLES
XThe \fITo Command\fR output option may be used to pipe xgrabsc output
Xto programs.  The most common commands are \fIlpr\fR for Postscript
Xoutput, and \fIxwud\fR for X-Window Dump output.  Programs that do not
Xaccept piped input should not be used in \fITo Command\fR.
X.sp
XYou can also get fancy and pipe the output through more than one command,
Xsuch as \fItee screen.dmp | xwud\fP, to store the grabbed image and get
Xa preview window.
X.sp 2
XDefault settings for xgrab can be made in your .Xdefaults file.  For
Xthe Athena toolkit version of xgrab, Toggle
Xbuttons can be set/unset through their \fI.state\fP attribute, and text
Xfield strings can be set through their \fI*string\fP attribute.  For
Xthe Motif toolkit version (which has diamond-shaped buttons for radio
Xbuttons), toggle buttons can be set/unset through their \fI.set\fP
Xattribute and text field strings can be set through their \fI*value\fP
Xattribute.
X.sp
XFor
Xexample, to set the default paper size for postscript output, put these
Xlines in your .Xdefaults (and use xrdb to load them into the server!):
X.sp
XXGrab*.pageWidthText*string:   8.5
X.br
XXGrab*.pageHeightText*string: 11.0
X.sp
Xor
X.sp
XXGrab*.pageWidthText*value:    8.5
X.br
XXGrab*.pageHeightText*value:  10.0
X.sp
XTo set the default output type to \fIXWD\fP, put these lines in
Xyour .Xdefaults:
X.sp
XXGrab*.ps.state:  0
X.br
XXGrab*.xwd.state: 1
X.sp 2
X.SH LIMITATIONS
XSee the limitations listed in the xgrabsc man page.
X.sp 2
X.SH AUTHOR
X.nf
X     Bruce Schuchardt
X    Servio Corporation
X      bruce@slc.com
X.fi
X.sp 2
X.SH ACKNOWLEGEMENTS
X.PP
XSee the xgrabsc man page, and the Acks file in the xgrabsc distribution
Xfor a list of acknowledgements.
X.sp 2
X.SH COPYRIGHT
XCopyright (c) 1991-93 Bruce Schuchardt
X.PP
X\fIXgrab\fR is copywritten material with a very loose copyright
Xallowing unlimited modification and distribution if the copyright
Xnotices are left intact.  Various portions are copywritten by various
Xpeople, but all use a modification of the MIT copyright notice.
XPlease check the source for complete copyright information.  The
Xintent is to keep the source free, not to stifle its distribution, so
Xplease write to me if you have any questions.
X.PP
XTHE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
XINCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
XNO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR
XCONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
XOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
XOR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
XUSE OR PERFORMANCE OF THIS SOFTWARE.
X.s 2
X.SH SEE ALSO
XX(1X), xgrabsc(1X), xhost(1), xwd(1X), xwud(1X), xloadimage(1X), xpm(1X),
Xxpr(1X), ad2c(1)
END_OF_FILE
if test 4500 -ne `wc -c <'xgrabsc.2_3/xgrab.man'`; then
    echo shar: \"'xgrabsc.2_3/xgrab.man'\" unpacked with wrong size!
fi
# end of 'xgrabsc.2_3/xgrab.man'
fi
echo shar: End of archive 4 \(of 5\).
cp /dev/null ark4isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
