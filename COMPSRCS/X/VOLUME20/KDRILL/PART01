Newsgroups: comp.sources.x
From: philb@cats.UCSC.EDU (Philip Brown)
Subject: v20i095:  kdrill - Kanji drill program, Part01/01
Message-ID: <1993Jul15.204759.8834@sparky.sterling.com>
X-Md4-Signature: c2de2a501c5dca4c92502a2552d2b01f
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Thu, 15 Jul 1993 20:47:59 GMT
Approved: chris@sterling.com

Submitted-by: philb@cats.UCSC.EDU (Philip Brown)
Posting-number: Volume 20, Issue 95
Archive-name: kdrill/part01
Environment: X11R5, kanji-font

[ I was unable to test this (no kanji-dict or kanji font), but it compiles ]
[ just fine.                                                               ]
[		Chris							   ]

an R5 kanji<->english "flashcard" like program.
uses "kanjidic". information on where to get this
dictionary is in the readme.

#! /bin/sh
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  README Imakefile KDrill Makefile defs.h externs.h game.c
#   init.c kdrill.man main.c patchlevel.h readfile.c usefile
# Wrapped by chris@sparky on Thu Jul 15 15:40:47 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 1)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(2157 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
X  README file for kanjidrill   oct 2, 1992
X     (by Philip Brown)
X
X  Here is a program to quiz folks on either english-to-kanji, or
Xkanji-to-english. It will quiz you on either the whole dictionary [around
X6000 kanji?]  OR specific kanji, if you give the JIS-number in the
X"usefile".
X
X  For the usefile, one number per entry, in hex, at the beginning of the
Xline. NO TRAILING SPACE!! Anything after will be treated as a comment, so
Xyou can notate the meaning of each kanji. A nifty useful usefile is
Xincluded.
X
X  I use the PD kanjidic file from monu6.cc.monash.edu.au: I do not include
Xit, as it is 400K. There is also a mirror at ftp.uwtc.washington.edu, but
Xthey have not updated to the latest version as of this writing.
X
XUnfortunately.. they recently changed the format of the latest version.
XI have simplified my parsing to account for all versions.
X
XThe format of any kanjidic file used (does not have to be the latest
Xversion) should be:
X
Xkk 3333 .... {english} {english}
X
XWhere kk is the 16-bit kanji value seen as two 8-bit vals.(MSB,LSB)
X'x' is any char, '....' is any char any number of times,
X and the {english} segments may be any number, but there must be at least
Xone, or the entry will be ignored. I hope. Note that the braces {} MUST
Xbe included there.
X
X  Future releases MAY include quizzing on kana-to-kanji, etc, etc. but that
Xwill be annoying to program, so may never happen. If someone ELSE wants
Xto add it, feel free, and mail me so.
XNote that you can make your own romaji quizzes, and add kana quizzes, by
Xadding/fiddling with the lines of the dictionary. I should probably
Xinclude a little sample of that.
X
X   The neat thing about programming this drill, is that it uses the Kanji in
Xthe kanji24 Xwindows font, so we don't have to store extra graphics.
XAdding new entries to the usefile is fairly simple. grep through the
Xdictionary for potential numbers, then use "xfd -fn kanji24" to check out
Xwhat the characters actually look like. Note that you have to click "Next
XPage" MANY times before getting to the actual kanji section.
X
XPhilip Brown
Xphilb@soda.berkeley.edu
X [and hopefully for the next year or so, philb@cats.ucsc.edu]
X
END_OF_FILE
  if test 2157 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
  echo shar: Extracting \"'Imakefile'\" \(323 characters\)
  sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
XDEPLIBS = $(DEPXLIB)
X/* Sun compilations require having the XMU lib here...
X * I don't know about "normal" systems
X */
XLOCAL_LIBRARIES = $(XLIB) $(XTOOLLIB) $(XAWLIB) $(XMULIB)
XINCLUDES = -I/usr/X11R5/include/X11
X
X
XSRCS = main.c readfile.c game.c init.c
XOBJS = main.o readfile.o game.o init.o
X
XComplexProgramTarget(kdrill)
END_OF_FILE
  if test 323 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
  fi
  # end of 'Imakefile'
fi
if test -f 'KDrill' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'KDrill'\"
else
  echo shar: Extracting \"'KDrill'\" \(125 characters\)
  sed "s/^X//" >'KDrill' <<'END_OF_FILE'
X!This resource file is NOT CHECKED (I think),
X!But try it anyways if it works for you.
XKDrill*width:	400
XKDrill*height:	300
X
END_OF_FILE
  if test 125 -ne `wc -c <'KDrill'`; then
    echo shar: \"'KDrill'\" unpacked with wrong size!
  fi
  # end of 'KDrill'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(10450 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and <Imakefile>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.72.1.1 92/03/18 13:13:37 rws Exp $
X
X# operating system:  SunOS 4.1.1
X
X# $XConsortium: sunLib.rules,v 1.7 91/12/20 11:19:47 rws Exp $
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -g kmem -m 2755
X
X      PROJECTROOT = /usr/X11R5
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/X11R5/lib
X           BINDIR = /usr/X11R5/bin
X          INCROOT = /usr/X11R5/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/X11R5/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = 1
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X# $XConsortium: sunLib.tmpl,v 1.14.1.1 92/03/17 14:58:46 rws Exp $
X
XSHLIBLDFLAGS = -assert pure-text
XPICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X       XMULIBONLY = -lXmu
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
XDEPLIBS = $(DEPXLIB)
X
XLOCAL_LIBRARIES = $(XLIB) $(XTOOLLIB) $(XAWLIB) $(XMULIB)
XINCLUDES = -I/usr/X11R5/include/X11
X
XSRCS = main.c readfile.c game.c init.c
XOBJS = main.o readfile.o game.o init.o
X
X PROGRAM = kdrill
X
Xall:: kdrill
X
Xkdrill: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xsaber_kdrill:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xosaber_kdrill:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xinstall:: kdrill
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  kdrill $(DESTDIR)$(BINDIR)
X
Xinstall.man:: kdrill.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) kdrill.man $(DESTDIR)$(MANDIR)/kdrill.$(MANSUFFIX)
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	# load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	# load $(ALLDEFINES) $(OBJS)
X
X# -------------------------------------------------------------------------
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
END_OF_FILE
  if test 10450 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'defs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'defs.h'\"
else
  echo shar: Extracting \"'defs.h'\" \(1008 characters\)
  sed "s/^X//" >'defs.h' <<'END_OF_FILE'
X#define KANJIFONT "kanji24"
X#define KANJIFILE "kanjidic"
X#define WINDOWHEIGHT 250
X#define WINDOWWIDTH  400
X#define USEFILE "usefile"
X
Xextern int errno;
X
Xstruct translationstruct {
X
X	char *pronunciation;/* not used, currently */
X	char *english;	/* english translation string.
X			 * null-terminated.
X			 * Can theoretically be any length, but
X			 * since it will all be on a single-line
X			 * text widget, that would be silly
X			 */
X};
X
X/********************************************************************
X
XSO here's the format for the translation/dictionary file I have decided
Xon so far:
X
XI changed specs. it will have to be in "kanjidic" format...
X
XTwo char high-bit-set identifier, followed by JIS number in hex.
XFollowed by stroke information? [HAS TO BE TERMINATED BY 'Gx', where
X				  'x' is any number]
XFollowed by pronunciation guide, in kana.
XFollowed by various english translations, enclosed in {}
X
X"kanjidic" often has multiple {} phrases. which leads to another nasty
Xhack  in readstructs()
X
X*/
END_OF_FILE
  if test 1008 -ne `wc -c <'defs.h'`; then
    echo shar: \"'defs.h'\" unpacked with wrong size!
  fi
  # end of 'defs.h'
fi
if test -f 'externs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'externs.h'\"
else
  echo shar: Extracting \"'externs.h'\" \(655 characters\)
  sed "s/^X//" >'externs.h' <<'END_OF_FILE'
Xextern struct translationstruct *translations[0x8000];
Xextern int lowest,highest;	/* keep track of how many we have */
Xextern char *dictname;
X
Xextern int game(),xtoi(),getline();
Xvoid readstructs(),readstructs(),kprint(),eprint();
Xextern void englishcallback();
Xextern void kanjicallback();
Xextern void changemode();
X
Xextern void quit();
Xextern XtAppContext Context;
X
Xextern unsigned long black,white;
Xextern Display *display;
Xextern Window mainwindow,rootwindow;
Xextern Widget toplevel,form,quitbutton,statusline;
Xextern Widget kanjimode,englishmode;
Xextern Widget englishWidget[4],kanjiWidget[4];
Xextern Pixmap kanjiPixmap[4];
Xextern GC gc,kgc,cleargc;
END_OF_FILE
  if test 655 -ne `wc -c <'externs.h'`; then
    echo shar: \"'externs.h'\" unpacked with wrong size!
  fi
  # end of 'externs.h'
fi
if test -f 'game.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'game.c'\"
else
  echo shar: Extracting \"'game.c'\" \(6243 characters\)
  sed "s/^X//" >'game.c' <<'END_OF_FILE'
X#define GUESSKANJI 1
X#define GUESSENGLISH 0
X
X#include <stdio.h>
X#include <X11/Xlib.h>
X#include <X11/Xatom.h>
X#include <X11/Xutil.h>
X#include <Intrinsic.h>
X#include <StringDefs.h>
X
X#include "defs.h"
X#include "externs.h"
X
Xint values[4];
Xint truevalue;
Xint Kanji2English=1;
X
Xextern Display *display;
Xextern Window mainwindow;
X
Xint englishwidth=7;
Xint englishheight=11;
X
X/* setstatus:
X *  sets label for main status widget.
X *	( the long one at the bottom)
X */
Xvoid setstatus(s)
Xchar *s;
X{
X	XtVaSetValues(statusline,
X		      XtNlabel,s,
X		      NULL);
X}
X
X/* pickkanji:
X *   picks an acceptably random kanji char
X */
X
Xint pickkanji(){
X	int i,span;
X	span = highest - lowest;
X
X	i = (random()%span) + lowest;
X	while((translations[i] == NULL) || (translations[i] == (void *) 1)){
X		i= (i+1)% (highest+1);
X		if(i==0) i = (random()%span) + lowest;
X	}
X	return i;
X
X}
X
X/* printkanji:
X *	updates all the kanji buttons.
X *	uses a nasty hack to get the buttons to update/grey out  properly,
X *	since we use BITMAPS for the kanji
X */
X
Xvoid printkanji(){
X	int i,knum;
X	XChar2b onecharstring;
X
X	if(Kanji2English == GUESSKANJI){
X		XFillRectangle(display,kanjiPixmap[0],cleargc,0,0,50,50);
X		XFillRectangle(display,kanjiPixmap[1],cleargc,0,0,50,50);
X		XFillRectangle(display,kanjiPixmap[2],cleargc,0,0,50,50);
X		XFillRectangle(display,kanjiPixmap[3],cleargc,0,0,50,50);
X		knum = values[truevalue];
X		onecharstring.byte1 = (knum & 0xff00)>>8;
X		onecharstring.byte2 = (knum & 0x00ff);
X		XDrawImageString16(display,kanjiPixmap[0],kgc,
X					   0,24,&onecharstring,1);
X
X		/* this is the hack to get it to redraw */
X		XtVaSetValues(kanjiWidget[0],XtNlabel,"",NULL);
X		return;
X	}
X	for(i=0;i<4;i++) {
X		knum = values[i];
X
X		onecharstring.byte1 = (knum & 0xff00)>>8;
X		onecharstring.byte2 = (knum & 0x00ff);
X
X		XFillRectangle(display,kanjiPixmap[i],cleargc,0,0,50,50);
X
X		/* and now stupid hack to get it to redraw.. */
X		XtVaSetValues(kanjiWidget[i], XtNlabel,"",NULL);
X
X		XDrawImageString16(display,kanjiPixmap[i],kgc,
X					   0,24,&onecharstring,1);
X	}
X}
X
X/* printenglish()
X *  similar to printkanji()
X *  Forces all english widgets to update the way we WANT them to update
X */
Xvoid printenglish(){
X	int i;
X	char *string;
X	if(Kanji2English == GUESSENGLISH){
X		string = translations[values[truevalue]]->english;
X		XtVaSetValues(englishWidget[0],
X			      XtNlabel,string,
X			      XtNresize,True,
X			      NULL);
X		XtVaSetValues(englishWidget[1],XtNlabel,"",NULL);
X		XtVaSetValues(englishWidget[2],XtNlabel,"",NULL);
X		XtVaSetValues(englishWidget[3],XtNlabel,"",NULL);
X		return;
X	}
X	for(i=0;i<4;i++){
X		Widget w;
X		int width;
X
X		string =translations[values[i]]->english;
X		w = englishWidget[i];
X		width = strlen(string) * englishwidth;
X
X		XtVaSetValues(w,
X			      XtNlabel,string,
X			      XtNresize,True,
X			      NULL);
X	}
X}
X
X
X/* kanjitoenglish
X *	sets up question...
X *	{ "what does this symbol? choose one of the four choices"}
X *	
X *	then returns, presumably falling back to XtAppMainLoop()
X *
X *	guesskanji == GUESSKANJI : give kanji, and user guesses the meaning
X *					int English
X *	guesskanji == GUESSENGLISH : give english, and user guesses which
X *					kanji fits best. 
X */
Xint kanjitoenglish(guesskanji)
X{
X	int doloop;
X	int i;
X	int userguess=0;
X	Kanji2English=guesskanji;
X
X	/* determine which value will be correct one.. */
X	truevalue = random() %4;
X
X	/* hack for random numbers...
X	 * only picks values that are acceptable by our current
X	 *  "usefile"
X	 */
X	values[0] = pickkanji();
X	values[1] = pickkanji();
X	values[2] = pickkanji();
X	values[3] = pickkanji();
X
X	/* now weed out duplicates.. */
X	doloop = 0;
X	do{
X		if((values[0] == values[1]) || (values[0] == values[2])
X		    || values[0] == values[3] ){
X			values[0] = pickkanji();
X			doloop=1;
X		} else
X		if(values[1] == values[2] || values[1] == values[3]){
X			values[1] = pickkanji();
X			doloop=1;
X		} else 
X		if(values[2] == values[3]){
X			values[2] = pickkanji();
X			doloop=1;
X		} else
X			doloop = 0;
X	}while(doloop);
X
X	printkanji();	/* update labels */
X	printenglish(); /* likewise      */
X
X	switch(Kanji2English){
X	   case GUESSENGLISH:
X		/* the first english label is set sensitive,
X		 * because it looks silly otherwise
X		 */
X		XtVaSetValues(englishWidget[0],XtNsensitive,True,NULL);
X		XtVaSetValues(englishWidget[1],XtNsensitive,False,NULL);
X		XtVaSetValues(englishWidget[2],XtNsensitive,False,NULL);
X		XtVaSetValues(englishWidget[3],XtNsensitive,False,NULL);
X
X		XtVaSetValues(kanjiWidget[0],XtNsensitive,True,NULL);
X		XtVaSetValues(kanjiWidget[1],XtNsensitive,True,NULL);
X		XtVaSetValues(kanjiWidget[2],XtNsensitive,True,NULL);
X		XtVaSetValues(kanjiWidget[3],XtNsensitive,True,NULL);
X
X		XtVaSetValues(kanjimode,XtNsensitive,True,NULL);
X		XtVaSetValues(englishmode,XtNsensitive,False,NULL);
X		break;
X	   case GUESSKANJI:
X		XtVaSetValues(englishWidget[0],XtNsensitive,True,NULL);
X		XtVaSetValues(englishWidget[1],XtNsensitive,True,NULL);
X		XtVaSetValues(englishWidget[2],XtNsensitive,True,NULL);
X		XtVaSetValues(englishWidget[3],XtNsensitive,True,NULL);
X
X		XtVaSetValues(kanjiWidget[0],XtNsensitive,False,NULL);
X		XtVaSetValues(kanjiWidget[1],XtNsensitive,False,NULL);
X		XtVaSetValues(kanjiWidget[2],XtNsensitive,False,NULL);
X		XtVaSetValues(kanjiWidget[3],XtNsensitive,False,NULL);
X
X		XtVaSetValues(kanjimode,XtNsensitive,False,NULL);
X		XtVaSetValues(englishmode,XtNsensitive,True,NULL);
X		break;
X	}
X}
X
X
X/* englishcallback:
X *	handles english widgets.
X *	only really neccessary if we are guessing the meaning of a
X *	kanji character
X */
Xvoid englishcallback(w,data,calldata)
XWidget w;
XXtPointer data;XtPointer calldata;
X{
X	if(!Kanji2English)
X		return;
X	if(data == (XtPointer) truevalue){
X		setstatus("Correct!");
X		kanjitoenglish(GUESSKANJI);
X	} else {
X		XBell(display,100);
X		setstatus("Incorrect.");
X	}
X
X}
X
X
Xvoid kanjicallback(w,data,calldata)
XWidget w;XtPointer data;XtPointer calldata;
X{
X	if(data == (XtPointer) truevalue){
X		setstatus("Correct!");
X		kanjitoenglish(GUESSENGLISH);
X	} else {
X		XBell(display,100);
X		setstatus("Incorrect.");
X	}
X}
X
X
X/* changemode:
X *   change from guessing kanji to guessing english, or vica verse,
X *	by clicking on the appropriate button
X */
Xvoid changemode(w,data,calldata)
XWidget w;XtPointer data;XtPointer calldata;
X{
X	kanjitoenglish((int ) data); 
X
X}
X
END_OF_FILE
  if test 6243 -ne `wc -c <'game.c'`; then
    echo shar: \"'game.c'\" unpacked with wrong size!
  fi
  # end of 'game.c'
fi
if test -f 'init.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'init.c'\"
else
  echo shar: Extracting \"'init.c'\" \(6707 characters\)
  sed "s/^X//" >'init.c' <<'END_OF_FILE'
X#include <stdio.h>
X
X#include <Xlib.h>
X#include <Xatom.h>
X#include <Xutil.h>
X#include <Intrinsic.h>
X#include <StringDefs.h>
X#include <Xaw/Command.h>
X#include <Xaw/Label.h>
X#include <Xaw/Form.h>
X#include <Composite.h>
X#include "defs.h"
X#include "externs.h"
X
Xint englishup,englishdown;/* not used.. */
X
XFont kfont;
Xchar *usefile=USEFILE;
X
Xstatic XtActionsRec actionlist[] = {
X	{ "quit",quit },
X};
X
Xstatic char *fallback[] = {
X	"KDrill*width: 200",
X	"KDrill*height: 200",
X	NULL
X};
X
Xstatic XrmOptionDescRec optionlist[] = {
X/* WHAT dies this do?? */
X/* I just copied it from the xterm source, mainly */
X
X{"-help",	"*help",XrmoptionNoArg,	(caddr_t) NULL},
X};
X
X
X/* initgc:
X *	initialises global gc values, and the fonts
X */
Xvoid initgc(){
X	XGCValues gcvalues;
X
X	gc =  XCreateGC(display,mainwindow,0,NULL);
X	cleargc = XCreateGC(display,mainwindow,0,NULL);
X	kgc = XCreateGC(display,mainwindow,0,NULL);
X
X	XSetForeground(display,gc,black);
X	XSetBackground(display,gc,white);
X	XSetForeground(display,kgc,black);
X	XSetBackground(display,kgc,white);
X	XSetForeground(display,cleargc,white);
X	XSetBackground(display,cleargc,black);
X
X	kfont = XLoadFont(display,KANJIFONT);
X	if(kfont == (Font) NULL){
X		perror("cannot load desired kanji font\n");
X		exit(0);
X	}
X	XSetFont(display,kgc,kfont);
X	XSetFont(display,gc,XLoadFont(display,"fixed"));
X
X
X
X}
X
X/* getusefile:
X *	Gets a "usefile", to abridge the full dictionary.
X *	If possible, will get it from the user's home directory,
X *	otherwise, tries current directory
X */
XFILE *getusefile(){
X	FILE *f;
X	char *homedir;
X	char fullname[100];
X
X	if(usefile == NULL) return NULL;
X	fullname[0] = '\0';
X	if(usefile[0] == '~'){
X		homedir = (char *) getenv("HOME");
X		if(homedir == NULL){
X			perror("Cannot expand '~' char. no HOME env. varriable");
X			exit(0);
X		}
X		sprintf(fullname,"%s%s",homedir,usefile);
X	} else {
X		strcpy(fullname,usefile);
X	}
X
X	if((f = fopen(fullname,"r")) == NULL){
X		puts("no usefile. using entire dictionary...");
X		usefile = NULL;
X	} else {
X		printf("using \"%s\" to abridge dictionary\n",fullname);
X	}
X	return f;
X}
X
X/* inituse:
X *	clear out global array of 'translations' (really abridgements),
X *	and set what kanji chars are appropriate to check on.
X *
X *	we set "okay" chars to have a NULL pointer stored for them in the
X *	translation table, since later, we will want to check if
X *	malloc malloc'd them properly.
X *
X *	 unacceptable chars have a pointer stored of (void *) 1
X *
X *	We should really redo this.. but either way, there would
X *	seem to be a conflict as to whether we have actually
X *	malloced memory that starts at 0x00000001, or whatever.
X *	
X */
Xvoid inituse(){
X	FILE *f;
X	int i;
X	char inbuf[100];
X
X	f = getusefile();
X
X	/* set all translations flags == NULL.
X	 *	NULL means it's okay to use this character
X	 *	
X	 */
X	if(usefile == NULL){
X		i = 0x2000;
X		while(i<0x8000){
X			translations[i++] = (void *)NULL;
X		}
X		return;
X	} else {	/* set all to UNREADABLE, for now */
X		i = 0x2000;
X		while(i<0x8000){
X			translations[i++] = (void *)1;
X		}
X	}
X
X	while(fgets(inbuf,99,f) != NULL){
X		int usechar;
X		usechar = xtoi(inbuf);
X		if( usechar<0x8000)
X			translations[usechar] = NULL;
X	}
X
X}
X
X/* initstuffs:
X *	calls the various init routines to setup
X *	GCs, fonts, dictionaries, and widgets
X */
X 
Xvoid initstuffs(argc,argv)
Xint *argc;
Xchar *argv[];
X{
X	int i,junk;
X	Arg args[5];
X	
X	srandom (time(NULL));
X	dictname = KANJIFILE;
X
X	/* check for abridgements of the dictionary... */
X	inituse();
X	readstructs(&argc,argv);
X
X	toplevel = XtVaAppInitialize(&Context,"KDrill",
X				   NULL,0,
X				   (int *) &argc,(String *) argv,
X				   NULL,NULL);
X	form = XtVaCreateManagedWidget("kdrill",formWidgetClass,
X					   toplevel,NULL);
X	/* I suppose I shouldn't hard-code this.. but it makes
X		things easier for now.
X	*/
X	XtVaSetValues(toplevel,
X		      XtNwidth,WINDOWWIDTH,
X		      XtNheight,WINDOWHEIGHT,
X		      XtNx,200,
X		      XtNy,100,
X		      NULL);
X
X	
X	display = XtDisplay(toplevel);
X
X	/* make KANJI buttons */
X	for(i=0;i<4;i++){
X		char labl[20];
X		sprintf(labl,"kanji%d",i);
X		kanjiPixmap[i]=XCreatePixmap(display,
X					RootWindow(display,0),
X					30,30,1);
X
X		kanjiWidget[i]=XtVaCreateManagedWidget(
X			labl,commandWidgetClass,
X			form,NULL);
X		XtVaSetValues(kanjiWidget[i],
X			      XtNlabel,"",
X			      XtNwidth,50,
X			      XtNheight,50,
X			      XtNbitmap,kanjiPixmap[i],
X			      XtNshapeStyle,XawShapeOval,
X			      NULL);
X		XtAddCallback(kanjiWidget[i],XtNcallback,kanjicallback,(XtPointer)i);
X		if(i>0){
X			sprintf(labl,"english%d",i-1);
X			XtVaSetValues(kanjiWidget[i],
X				      XtNfromHoriz,kanjiWidget[i-1],
X				      NULL);
X		}
X
X	}
X	/********************************/
X	/* make ENGLISH buttons.. */
X	/********************************/
X	for(i=0;i<4;i++){
X		char labl[20];
X		sprintf(labl,"english%d",i);
X
X		englishWidget[i]=XtVaCreateManagedWidget(
X			labl,commandWidgetClass,
X			form,NULL);
X
X		/* the following is stupid, but I don't know of a better
X		  way to make it resize properly. I've tried the
X		  XtResize thing.
X		*/
X		XtVaSetValues(englishWidget[i],
X			      XtNlabel,"                                ",
X			      NULL);
X		
X		XtAddCallback(englishWidget[i],XtNcallback,englishcallback,(XtPointer) i);
X
X		if(i==0){
X			XtVaSetValues(englishWidget[0],
X				      XtNfromVert,kanjiWidget[0],
X				      NULL);
X		} else {
X			XtVaSetValues(englishWidget[i],
X				      XtNfromVert,englishWidget[i-1],
X				      NULL);
X		}
X		
X
X	}
X
X	kanjimode = XtVaCreateManagedWidget("kanjimode",commandWidgetClass,
X					    form,NULL);
X	XtVaSetValues(kanjimode,
X			XtNlabel,"Guess kanji",
X			XtNfromVert,englishWidget[3],
X			XtNshapeStyle,XawShapeOval,
X			NULL);
X	XtAddCallback(kanjimode,XtNcallback,changemode,(XtPointer) 1);
X	englishmode = XtVaCreateManagedWidget("englishmode",commandWidgetClass,
X					      form,NULL);
X	XtVaSetValues(englishmode,
X			XtNlabel,"Guess english",
X			XtNfromVert,englishWidget[3],
X			XtNshapeStyle,XawShapeOval,
X			XtNfromHoriz,kanjimode,
X			NULL);
X	XtAddCallback(englishmode,XtNcallback,changemode,(XtPointer) 0);
X
X	quitbutton = XtVaCreateManagedWidget("quit",commandWidgetClass,
X					     form,NULL);
X	XtVaSetValues(quitbutton,
X		      XtNlabel,"quit",
X		      XtNfromVert,kanjimode,
X		      XtNshapeStyle,XawShapeEllipse,
X		      NULL);
X	XtAddCallback(quitbutton,XtNcallback,quit,NULL);
X
X	statusline = XtVaCreateManagedWidget("status",labelWidgetClass,
X					     form,NULL);
X	XtVaSetValues(statusline,
X		      XtNlabel,"Welcome to kanjidrill",
X		      XtNfromHoriz,quitbutton,
X		      XtNfromVert,kanjimode,
X		      NULL);
X
X
X	XtAppAddActions(Context,actionlist,XtNumber(actionlist));
X
X	XtRealizeWidget(toplevel);
X	mainwindow = XtWindow(form);
X
X	white = WhitePixel(display,0);
X	black = BlackPixel(display,0);
X	initgc();
X
X}
END_OF_FILE
  if test 6707 -ne `wc -c <'init.c'`; then
    echo shar: \"'init.c'\" unpacked with wrong size!
  fi
  # end of 'init.c'
fi
if test -f 'kdrill.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'kdrill.man'\"
else
  echo shar: Extracting \"'kdrill.man'\" \(1637 characters\)
  sed "s/^X//" >'kdrill.man' <<'END_OF_FILE'
X.\" kdrill.1 1.13 93/02/15 
X.TH KDRILL 1.1 "9 November 1992"
X.SH NAME
Xkdrill \- drill program for kanji chars under Xwindows
X.SH DESCRIPTION
X.B kdrill
Xwill use the "kanjidic" file to interpret many of the various 16-bit kanji
Xchars in the
X.I kanji24
Xfont supplied with the X11R5 distribution. It checks for a file by the name of
X.B "usefile"
Xin the current directory (although this may be altered easily by your system 
Xadministrator at compile time).
X
XThe usefile simply consists of a list of hex numbers, one per line, no
Xinitial spaces allowed. The usefile makes the program only use particular
Xkanji, instead of the thousands possible in the dictionary. It is
Xpossible to add comment lines by having the very first character of a
Xline be "#". It is also possible to add english reminders after the number
Xon each line, so you remember what each number is.
XHex numbers can be checked or found by using the "xfd" util on the
X"kanji24" font. 
X
XThe dictionary, kanjidic, is currently available where it originated, via
Xftp from
X.I monu6.cc.monash.edu.au,
Xor from a mirror in the U.S. at ftp.uwtc.washington.edu
XIn one of these locations, the file may be found in a directory,
X.B JimBreen,
Xwhile in both locations, it is in a subdirectory akin to 
X.I /pub/japanese
Xor
X.I /pub/nihongo
Xor similar.
X
X.SH AUTHOR
XPhilip P Brown
X.SH BUGS
XThis was written with some of the R5 xterm source as a template. Thus, there 
Xare a few pieces of code in there that are apparently useless.
X
XThis manual page is NOT by Sun. 
X
Xkdrill does not like working on my truecolor display. This indicates it
Xprobably won't be happy on a regular color display, also.
END_OF_FILE
  if test 1637 -ne `wc -c <'kdrill.man'`; then
    echo shar: \"'kdrill.man'\" unpacked with wrong size!
  fi
  # end of 'kdrill.man'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
  echo shar: Extracting \"'main.c'\" \(1367 characters\)
  sed "s/^X//" >'main.c' <<'END_OF_FILE'
X#include <stdio.h>
X
X#include <Xlib.h>
X#include <Xatom.h>
X#include <Xutil.h>
X#include <Intrinsic.h>
X#include <StringDefs.h>
X#include <Xaw/Command.h>
X#include <Xaw/Label.h>
X#include <Xaw/Form.h>
X#include <Composite.h>
X#include "defs.h"
X#include "externs.h"
X#include "patchlevel.h"
X
Xstatic char *version = VERSION;
X
XDisplay *display;
Xint screen;
XWindow mainwindow,rootwindow;
XGC gc,kgc,cleargc;
XWidget toplevel,form,quitbutton,statusline;
XWidget kanjimode,englishmode,othermode;
XWidget englishWidget[4],kanjiWidget[4];
XPixmap kanjiPixmap[4];
XXtAppContext Context;
X
Xchar *dictname=NULL;
X
XXChar2b *kstring;
XXChar2b onecharstring;
X
Xunsigned long white,black;
X
X/* quitbutton, of course */
Xvoid quit(w,data,calldata)
XWidget w;
XXtPointer data,calldata;
X{
X	puts("quitting?");
X	XtCloseDisplay(display);
X	exit(0);
X}
X
X
X
X/* keypress:
X * return whether got strnage key (shift, etc), or normal key.
X * returns 0 on normal key, or exits program if 'q' hit
X */
Xint keypress(key)
Xint key;
X{
X	if(key == 61)
X		exit(0);
X	else
X
X		/* sun codes for shift, control, etc */
X	switch(key){
X		case 106:
X		case 83:
X		case 26:
X			return 1;
X			break;
X		default:
X			/* printf("Got keypress %d\n",key); */
X			return 0;
X	}
X}
X
X
Xmain(argc,argv)
Xint argc;
Xchar *argv[];
X{
X	int i;
X	XEvent event;
X
X	initstuffs();
X
X	kanjitoenglish(1);
X	/* if pass 0, means want to guess english */
X	XtAppMainLoop(Context);
X
X}
END_OF_FILE
  if test 1367 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
  fi
  # end of 'main.c'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
  echo shar: Extracting \"'patchlevel.h'\" \(76 characters\)
  sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X#ifndef _PATCHLEVEL_H
X#define _PATCHLEVEL_H
X
X#define VERSION	"v1.0"
X
X#endif
END_OF_FILE
  if test 76 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
  fi
  # end of 'patchlevel.h'
fi
if test -f 'readfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'readfile.c'\"
else
  echo shar: Extracting \"'readfile.c'\" \(3436 characters\)
  sed "s/^X//" >'readfile.c' <<'END_OF_FILE'
X/*
X * This file is for just setting up the structs, etc
X */
X
X
X#include <stdio.h>
X#include <ctype.h>
X#include <Xfuncs.h>
X#include <Xlib.h>
X#include <Xatom.h>
X#include <Xutil.h>
X#include <Intrinsic.h>
X#include <StringDefs.h>
X#include <Xos.h>
X
X#include "defs.h"
X#include "externs.h"
X
X/* translations[] keeps track of which kanji it is okay to test the
X *	user on. Likewise with numberofkanji, highest, and lowest.
X *	translations[x] == 
X */
Xstruct translationstruct *translations[0x8000];
Xint numberofkanji,highest,lowest;
X
X
X/* random debugging util? */
Xvoid printline(s)
Xunsigned char *s;
X{
X	while(*s){
X		putchar(*s++);
X	}
X	putchar('\n');
X}
X
X/* Since there is no standard util to convert hex ascii to int,...
X *  have to supply our own..
X *  It isn't incredibly efficient.. let's hope the compiler is smart.
X *  arrg..
X */
Xint xtoi(s)
Xchar * s;
X{
X	int out=0;
X	sscanf(s,"%x",&out);
X	return out;
X}
X
X/* getline:
X *	reads a line (from dictionary).
X *	returns true (1) if read aline, otherwise,
X *	returns false (0);
X *
X *	used in "readstructs", below.
X */
X
Xunsigned char instring[2][512];
Xunsigned char *inptr=NULL;
Xint whichstring;
X
Xint getline(fp,s)
XFILE *fp;
Xunsigned char *s;
X{
X	if(inptr==NULL){
X		inptr= &instring[0][100];
X		whichstring=0;
X	}
X	for(;;){
X		int i;
X		if(inptr == &instring[whichstring][100]){
X			whichstring = 1-whichstring;
X			inptr=instring[whichstring];
X			i=fread(instring[whichstring],1,100,fp);
X			if(i<100){
X				instring[whichstring][i]='\0';
X				/* okay, we put the termination signal in.
X				 * But if there is a complete line in there,
X				 * it should be read with our buffering
X				 */
X			}
X		}
X		switch(*inptr){
X			case 0:
X				*s = '\0';
X				return 0;
X			case 10:
X			case 13:
X				*inptr='\0';
X				*s++ = *inptr++;
X				return 1;
X			default:
X				*s++ = *inptr++;
X		}
X	}
X}
X
X/* nextchar:
X * returns pointer to next non-whitespace char
Xunsigned char *nextchar(c)
Xunsigned char *c;
X{
X	while(isspace(*c)){
X		if(*c == '\0') break;
X		c++;
X	}
X	return c;
X}
X
X
X/* readstructs:
X *	the main dictionary reading routine.
X *	Fills in the global translationstruct with 
X */
Xvoid readstructs(){
X	unsigned char instring[256];
X	int i;
X	FILE *fp;
X	lowest = highest = 0x3000;
X	fp = fopen(dictname,"r");
X	if(fp == NULL){
X		perror("cannot open kanji translation file");
X		fprintf(stderr,"Looking for %s\n",dictname);
X		exit(0);
X	}
X
X	puts("reading in dictionary: please wait a few moments...");
X	while (getline(fp,instring) != 0) {
X		unsigned char *parse;
X		int instrlen;	/* length of pronunciation */
X
X		/*i = instring[0] *256 + instring[1];*/
X		i = xtoi(&instring[2]);
X
X		if(i < 0x3000){
X			/* NASTY HACK */
X			continue;
X		}
X		if(translations[i] != NULL){
X			continue;
X			/* trick so that users can specify which numbers
X			   they want to drill on */
X		}
X			/* NOther nasty hack */
X		parse = index(instring,'{');
X		if(parse == NULL){
X			continue;
X		}
X		
X
X		if(i<lowest) lowest = i;
X		if (i >highest) highest = i;
X		
X		translations[i] = (struct translationstruct *)
X			malloc(sizeof(struct translationstruct));
X		if (translations[i] == NULL){
X			perror("Cannot allocate memory for translation table\n");
X			exit(errno);
X		}
X
X		translations[i]->pronunciation = NULL;
X
X		instrlen = strlen(parse)+1;
X
X		translations[i]->english = (char *) malloc(instrlen);
X		if(translations[i]->english == NULL){
X			perror("Cannot allocate memory for translation table\n");
X			exit(errno);		
X		}
X
X		strncpy(translations[i]->english,parse,instrlen);
X	} 
X}
END_OF_FILE
  if test 3436 -ne `wc -c <'readfile.c'`; then
    echo shar: \"'readfile.c'\" unpacked with wrong size!
  fi
  # end of 'readfile.c'
fi
if test -f 'usefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'usefile'\"
else
  echo shar: Extracting \"'usefile'\" \(1379 characters\)
  sed "s/^X//" >'usefile' <<'END_OF_FILE'
X# This is the "kdrill" 'usefile'
X#  it is used to abridge the "kanjidic" dictionary
X#
X# lines can be commented by the VERY FIRST CHARACTER being a '#'
X# Try not to leave blank lines
X# Only the initial hex number is important..
X#  You can add whatever english you  like afterwards,so that you remember
X#  what the numbers mean.
X3030 rising sun
X303f someone?
X306c "one"
X312b rain
X312c east
X315f yen, round
X323c below ,low 
X3433 dry
X3250 fire
X3456 interval (of time), a room
X355d bow
X3662 gold
X3665 nine
X376e  Moon
X384a self
X385e five
X3971 country
X3b30 three
X3b33 mountain
X3b4d four
X3b4e samurai,gentleman
X3b5s child
X3b54 city
X3b7b temple(buddhist)
X3b7e time, or hour
X3c37 seven
X3d3a utensil?ten??
X3d3d ten
X3d50 exit (verb)
X3d77 woman
X3e2e small
X3e65 above
X3f4d person
X3f65 water
X4038 life
X403e west
X405a cut, cut off
X4069 thousand
X406e river
X4134 all
X422b sheaf
X4267 large
X4331 one
X4366 middle/center
X4544 rice paddy
X455a earth
X4561 knife , sword
X466e south
X4673 two
X467c sun
X467e enter
X482a cultivated field, really.
X482b farm?
X482c eight
X4934 hundred
X4977 wind, style
X4a2c minute, portion
X4a60 garden
X4b2e country
X4b4c north
X4b5c book, origin
X4b7c ten thousand, many, etc
X4c40 bright, clear
X4c5a tree
X4c5c ordinal for numbers
X4c67 gates
X4d4b day of week
X4d5b sunshine
X4f3b six
X5042 thousand (sort of)
X5051 hundred (sort of)
X5345 one?
X5744 three (fur/hair radical)
X666d new moon
X
END_OF_FILE
  if test 1379 -ne `wc -c <'usefile'`; then
    echo shar: \"'usefile'\" unpacked with wrong size!
  fi
  # end of 'usefile'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
