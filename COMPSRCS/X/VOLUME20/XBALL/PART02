Newsgroups: comp.sources.x
From: daven@ctron.com ("David N. Nedde")
Subject: v20i002:  xball - simulate bouncing balls in a window, Part02/05
Message-ID: <1993May24.202838.23929@sparky.imd.sterling.com>
X-Md4-Signature: 5a6862a34275cb11a12c028f97eb0266
Sender: chris@sparky.imd.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Mon, 24 May 1993 20:28:38 GMT
Approved: chris@sparky.imd.sterling.com

Submitted-by: daven@ctron.com ("David N. Nedde")
Posting-number: Volume 20, Issue 2
Archive-name: xball/part02
Environment: X11, OSF/Motif, Athena

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 2 (of 5)."
# Contents:  Make.motif Make.athena color_l.c demo.c file_sel.c help.c
#   list.c misc.c miscx.c help.h
# Wrapped by daven@osiris on Tue May  4 16:35:07 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Make.motif' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Make.motif'\"
else
echo shar: Extracting \"'Make.motif'\" \(12467 characters\)
sed "s/^X//" >'Make.motif' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.51 89/12/12 12:37:30 jim Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X###########################################################################
X# Makefile generated from "Imake.tmpl" and <Imakefile>
X# $XConsortium: Imake.tmpl,v 1.77 89/12/18 17:01:37 jim Exp $
X#
X# Platform-specific parameters may be set in the appropriate .cf
X# configuration files.  Site-wide parameters may be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor doesn't define any unique symbols, you'll need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make Makefile", "make Makefiles", or "make World").
X#
X# If you absolutely can't get imake to work, you'll need to set the
X# variables at the top of each Makefile as well as the dependencies at the
X# bottom (makedepend will do this automatically).
X#
X
X###########################################################################
X# platform-specific configuration parameters - edit sun.cf to change
X
XSYSLIBS=-lXt -lX11
XMWM_DEFINES=-DSHAPE -DOPAQUE
XSYSLIBS=$(MTOOLKITSRC)/libXt.a $(XLIBSRC)/libX11.a
X
X# platform:  $XConsortium: sun.cf,v 1.38 89/12/23 16:10:10 jim Exp $
X# operating system:  SunOS 4.1
X
X###########################################################################
X# site-specific configuration parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.21 89/12/06 11:46:50 jim Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar cq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X               RM = rm -f
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0664
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X          DESTDIR =
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -D_NO_PROTO -DSTRINGS_ALIGNED -DNO_REGEX -DNO_ISDIR -DUSE_RE_COMP -DUSE_GETWD
X      COMPATFLAGS =
X
X      ALLINCLUDES = $(STD_INCLUDES) $(TOP_INCLUDES) $(INCLUDES) $(EXTRA_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(PROTO_DEFINES) $(DEFINES) $(COMPATFLAGS)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS)
X   LDCOMBINEFLAGS = -X -r
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X###########################################################################
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
X###########################################################################
X# X Window System make variables; this need to be coordinated with rules
X# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
X          PATHSEP = /
X        USRLIBDIR = $(DESTDIR)/usr/lib
X           BINDIR = $(DESTDIR)/usr/bin/X11
X          INCROOT = $(DESTDIR)/usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = $(DESTDIR)/usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           AWMDIR = $(LIBDIR)/awm
X           TWMDIR = $(LIBDIR)/twm
X           GWMDIR = $(LIBDIR)/gwm
X          MANPATH = $(DESTDIR)/usr/man
X    MANSOURCEPATH = $(MANPATH)/man
X           MANDIR = $(MANSOURCEPATH)n
X        LIBMANDIR = $(MANSOURCEPATH)3
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X
X        SOXLIBREV = 4.2
X          SOXTREV = 4.0
X         SOXAWREV = 4.0
X        SOOLDXREV = 4.0
X         SOXMUREV = 4.0
X        SOXEXTREV = 4.0
X
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X            FONTC = bdftosnf
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier.sh
X
X        CONFIGSRC = $(TOP)/config
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X     MKFONTDIRSRC = $(FONTSRC)/mkfontdir
X     EXTENSIONSRC = $(TOP)/extensions
X
X  DEPEXTENSIONLIB = $(USRLIBDIR)/libXext.a
X     EXTENSIONLIB =  -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X
X        DEPXMULIB =
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB =
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB =
X           XAWLIB = -lXaw
X
X LINTEXTENSIONLIB = $(USRLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(USRLIBDIR)/llib-lX11.ln
X          LINTXMU = $(USRLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(USRLIBDIR)/llib-lXt.ln
X          LINTXAW = $(USRLIBDIR)/llib-lXaw.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X      USRINCDIR = $(DESTDIR)/usr/include
X        TESTSRC = $(TOP)/tests
X     TESTSRCLIB = $(TESTSRC)/lib
X     TESTSRCBIN = $(TESTSRC)/bin
X       COMMONPP = $(TESTSRCBIN)/Commonpp
X
X     TESTCOMSRC = $(TESTSRCLIB)/Common
X    MTOOLKITSRC = $(LIBSRC)/Xt
X     MWIDGETSRC = $(LIBSRC)/Xm
X   MRESOURCESRC = $(LIBSRC)/Mrm
X         UILSRC = $(CLIENTSRC)/uil
X            UIL = $(UILSRC)/uil
X      XMTOOLLIB = $(MTOOLKITSRC)/libXt.a
X          XMLIB = $(MWIDGETSRC)/libXm.a
X   MRESOURCELIB = $(MRESOURCESRC)/libMrm.a
X         UILLIB = $(UILSRC)/libUil.a
X     TESTCOMLIB = $(TESTCOMSRC)/libCommon.a
X
X  LINTMRESOURCE = $(MRESOURCESRC)/libMrm.a
XLINTXMWIDGETLIB = $(MWIDGETSRC)/llib-l/Xm.ln
X     LINTXMTOOL = $(MTOOLKITSRC)/llib-lXt.ln
X     LINTUILLIB = $(UILSRC)/llib-lUil.ln
X
X        DEPLIBS =
X
X        DEPLIBS1 = $(DEPLIBS)
X        DEPLIBS2 = $(DEPLIBS)
X        DEPLIBS3 = $(DEPLIBS)
X
X###########################################################################
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.67 89/12/18 17:14:15 jim Exp $
X
X###########################################################################
X# start of Imakefile
X
X# MOTIF  -> Have Motif Widgets
X# ATHENA -> Have Athena Widgets
X
X#define ATHENA
X
X           DELAY = -DDELAY=100       # DELAY ranges from -18 to whatever
X#    GRAVITY = -DGRAVITY=8       # Default gravity
X# ELASTICITY = -DELASTICY=90     # Default elasticity
X          USLEEP = -DHAVE_USLEEP      # Uncomment if usleep installed...
X       MYDEFINES = $(DELAY) $(USLEEP)
X     CDEBUGFLAGS = -g
X
XM_SRCS = act_area.c
XM_OBJS = act_area.o
XM_INCS = act_area.h
X
XA_SRCS = filemenu.c
XA_OBJS = filemenu.o
XA_INCS =
X
X         DEFINES = -DMOTIF $(MYDEFINES)
X#   MYLDLIBS = -lPW    # Uncomment if you get regcmp and regex undefined
X          LDLIBS = -lXm -lXmu -lXt -lX11 $(MYLDLIBS)
X
XTOOL_SRCS = $(M_SRCS)
XTOOL_OBJS = $(M_OBJS)
XTOOL_INCS = $(M_INCS)
X
X LINTOPTS = -abhuvz -D_NO_PROTO $(DEFINES)
X
XCOMM_SRCS = \
X	color_l.c \
X	demo.c \
X	file_sel.c \
X	help.c \
X	item.c \
X	items.c \
X	list.c \
X	menu.c \
X	misc.c \
X	miscx.c \
X	room.c \
X	scrollbar.c \
X	sim.c \
X	table.c \
X	xball.c \
X	xball_sys.c
X
XCOMM_OBJS = \
X	color_l.o \
X	demo.o \
X	file_sel.o \
X	help.o \
X	item.o \
X	items.o \
X	list.o \
X	menu.o \
X	misc.o \
X	miscx.o \
X	room.o \
X	scrollbar.o \
X	sim.o \
X	table.o \
X	xball.o \
X	xball_sys.o
X
XCOMM_INCS = \
X	color_l.h \
X	demo.h \
X	fallback.h \
X	file_sel.h \
X	help.h \
X	intf.h \
X	item.h \
X	items.h \
X	list.h \
X	menu.h \
X	misc.h \
X	miscx.h \
X	names.h \
X        patchlevel.h \
X	room.h \
X	scrollbar.h \
X	sim.h \
X	table.h \
X	xball_sys.h
X
XSRCS = $(COMM_SRCS) $(TOOL_SRCS)
XOBJS = $(COMM_OBJS) $(TOOL_OBJS)
XINCS = $(COMM_INCS) $(TOOL_INCS)
X
X PROGRAM = xball
X
Xall:: xball
X
Xxball: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xsaber_xball:
X	#load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xosaber_xball:
X	#load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xinstall:: xball
X	$(INSTALL) -c $(INSTPGMFLAGS)   xball $(BINDIR)
X
Xinstall.man:: xball.man
X	$(INSTALL) -c $(INSTMANFLAGS) xball.man $(MANDIR)/xball.n
X
Xdepend::
X	$(DEPEND) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
XCLASS            = XBall
XAPP_DEFAULTS_SRC = $(CLASS).ad
X
Xinstall::  $(CLASS).ad
X	$(INSTALL) -c $(INSTAPPFLAGS)  $(CLASS).ad $(XAPPLOADDIR)/ $(CLASS)
X
Xfallback.h: $(APP_DEFAULTS_SRC)
X	gen_fallback $(APP_DEFAULTS_SRC) > $@
X
XDEMOS = demo1 demo2 demo3 demo4 demo5 demo6 demo7 demo8 demo9 demo10 \
X        demo11 demo12 demo13 demo14
X
XBITMAPS = \
X	good_bitmaps \
X	on.xbm \
X	off.xbm \
X	man.xbm \
X	stipple.xbm \
X	xball.xbm \
X	xball-a.xbm \
X	xball-b.xbm \
X	xball-l.xbm \
X	xball-x.xbm \
X	sgi.xbm
X
XMISC = \
X	gen_fallback \
X	run_demos \
X        xball.man \
X	README
X
XDRAWING_A_DIRS = \
X	X11 \
X	X11/Xaw_d
X
XDRAWING_A = \
X	X11/Xaw_d/DrawingA.c \
X	X11/Xaw_d/DrawingA.h \
X	X11/Xaw_d/DrawingAP.h \
X	X11/Xaw_d/DrawingA.doc \
X	X11/Xaw_d/Imakefile \
X	X11/Xaw_d/Makefile.std \
X	X11/Xaw_d/Makefile \
X        X11/Xaw_d/demo.c \
X	X11/Xaw_d/README \
X	Imakefile \
X	Makefile.std \
X	Makefile \
X	Make.motif \
X	Make.athena
X
XDIST = \
X	$(DRAWING_A) \
X	$(COMM_SRCS) \
X	$(COMM_INCS) \
X	$(M_SRCS) \
X	$(M_INCS) \
X	$(A_SRCS) \
X	$(A_INCS) \
X	$(APP_DEFAULTS_SRC) \
X	$(MISC) \
X	$(BITMAPS) \
X	$(DEMOS)
X
Xshar:
X	makekit -s75k -p $(DRAWING_A_DIRS) $(DIST)
X
Xtar:
X	tar cvf - $(DIST) | compress -v > xball.tar.Z
X
X###########################################################################
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) \#*
X
XMakefile::
X	-@if [ -f Makefile ]; then \
X	echo "	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak"; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	#load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	#load $(ALLDEFINES) $(OBJS)
X
X###########################################################################
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X###########################################################################
X# dependencies generated by makedepend
X
END_OF_FILE
if test 12467 -ne `wc -c <'Make.motif'`; then
    echo shar: \"'Make.motif'\" unpacked with wrong size!
fi
# end of 'Make.motif'
fi
if test -f 'Make.athena' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Make.athena'\"
else
echo shar: Extracting \"'Make.athena'\" \(15960 characters\)
sed "s/^X//" >'Make.athena' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.51 89/12/12 12:37:30 jim Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X###########################################################################
X# Makefile generated from "Imake.tmpl" and <Imakefile>
X# $XConsortium: Imake.tmpl,v 1.77 89/12/18 17:01:37 jim Exp $
X#
X# Platform-specific parameters may be set in the appropriate .cf
X# configuration files.  Site-wide parameters may be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor doesn't define any unique symbols, you'll need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make Makefile", "make Makefiles", or "make World").
X#
X# If you absolutely can't get imake to work, you'll need to set the
X# variables at the top of each Makefile as well as the dependencies at the
X# bottom (makedepend will do this automatically).
X#
X
X###########################################################################
X# platform-specific configuration parameters - edit sun.cf to change
X
XSYSLIBS=-lXt -lX11
XMWM_DEFINES=-DSHAPE -DOPAQUE
XSYSLIBS=$(MTOOLKITSRC)/libXt.a $(XLIBSRC)/libX11.a
X
X# platform:  $XConsortium: sun.cf,v 1.38 89/12/23 16:10:10 jim Exp $
X# operating system:  SunOS 4.1
X
X###########################################################################
X# site-specific configuration parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.21 89/12/06 11:46:50 jim Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar cq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X               RM = rm -f
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0664
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X          DESTDIR =
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -D_NO_PROTO -DSTRINGS_ALIGNED -DNO_REGEX -DNO_ISDIR -DUSE_RE_COMP -DUSE_GETWD
X      COMPATFLAGS =
X
X      ALLINCLUDES = $(STD_INCLUDES) $(TOP_INCLUDES) $(INCLUDES) $(EXTRA_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(PROTO_DEFINES) $(DEFINES) $(COMPATFLAGS)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS)
X   LDCOMBINEFLAGS = -X -r
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X###########################################################################
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
X###########################################################################
X# X Window System make variables; this need to be coordinated with rules
X# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
X          PATHSEP = /
X        USRLIBDIR = $(DESTDIR)/usr/lib
X           BINDIR = $(DESTDIR)/usr/bin/X11
X          INCROOT = $(DESTDIR)/usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = $(DESTDIR)/usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           AWMDIR = $(LIBDIR)/awm
X           TWMDIR = $(LIBDIR)/twm
X           GWMDIR = $(LIBDIR)/gwm
X          MANPATH = $(DESTDIR)/usr/man
X    MANSOURCEPATH = $(MANPATH)/man
X           MANDIR = $(MANSOURCEPATH)n
X        LIBMANDIR = $(MANSOURCEPATH)3
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X
X        SOXLIBREV = 4.2
X          SOXTREV = 4.0
X         SOXAWREV = 4.0
X        SOOLDXREV = 4.0
X         SOXMUREV = 4.0
X        SOXEXTREV = 4.0
X
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X            FONTC = bdftosnf
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier.sh
X
X        CONFIGSRC = $(TOP)/config
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X     MKFONTDIRSRC = $(FONTSRC)/mkfontdir
X     EXTENSIONSRC = $(TOP)/extensions
X
X  DEPEXTENSIONLIB = $(USRLIBDIR)/libXext.a
X     EXTENSIONLIB =  -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X
X        DEPXMULIB =
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB =
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB =
X           XAWLIB = -lXaw
X
X LINTEXTENSIONLIB = $(USRLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(USRLIBDIR)/llib-lX11.ln
X          LINTXMU = $(USRLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(USRLIBDIR)/llib-lXt.ln
X          LINTXAW = $(USRLIBDIR)/llib-lXaw.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X      USRINCDIR = $(DESTDIR)/usr/include
X        TESTSRC = $(TOP)/tests
X     TESTSRCLIB = $(TESTSRC)/lib
X     TESTSRCBIN = $(TESTSRC)/bin
X       COMMONPP = $(TESTSRCBIN)/Commonpp
X
X     TESTCOMSRC = $(TESTSRCLIB)/Common
X    MTOOLKITSRC = $(LIBSRC)/Xt
X     MWIDGETSRC = $(LIBSRC)/Xm
X   MRESOURCESRC = $(LIBSRC)/Mrm
X         UILSRC = $(CLIENTSRC)/uil
X            UIL = $(UILSRC)/uil
X      XMTOOLLIB = $(MTOOLKITSRC)/libXt.a
X          XMLIB = $(MWIDGETSRC)/libXm.a
X   MRESOURCELIB = $(MRESOURCESRC)/libMrm.a
X         UILLIB = $(UILSRC)/libUil.a
X     TESTCOMLIB = $(TESTCOMSRC)/libCommon.a
X
X  LINTMRESOURCE = $(MRESOURCESRC)/libMrm.a
XLINTXMWIDGETLIB = $(MWIDGETSRC)/llib-l/Xm.ln
X     LINTXMTOOL = $(MTOOLKITSRC)/llib-lXt.ln
X     LINTUILLIB = $(UILSRC)/llib-lUil.ln
X
X        DEPLIBS =
X
X        DEPLIBS1 = $(DEPLIBS)
X        DEPLIBS2 = $(DEPLIBS)
X        DEPLIBS3 = $(DEPLIBS)
X
X###########################################################################
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.67 89/12/18 17:14:15 jim Exp $
X
X###########################################################################
X# start of Imakefile
X
X# MOTIF  -> Have Motif Widgets
X# ATHENA -> Have Athena Widgets
X
X#define MOTIF
X
X           DELAY = -DDELAY=100       # DELAY ranges from -18 to whatever
X#    GRAVITY = -DGRAVITY=8       # Default gravity
X# ELASTICITY = -DELASTICY=90     # Default elasticity
X          USLEEP = -DHAVE_USLEEP      # Uncomment if usleep installed...
X       MYDEFINES = $(DELAY) $(USLEEP)
X     CDEBUGFLAGS = -g
X
XM_SRCS = act_area.c
XM_OBJS = act_area.o
XM_INCS = act_area.h
X
XA_SRCS = filemenu.c
XA_OBJS = filemenu.o
XA_INCS =
X
X        PREDEFINES = -DSUNOS4
X
X        SUBDIRS = X11/Xaw_d
XLOCAL_LIBRARIES = -lXaw_d
X        DEFINES = -DATHENA $(MYDEFINES)
X       INCLUDES = -I.
X      LDOPTIONS = -LX11/Xaw_d
X         LDLIBS = -lXaw_d -lXaw -lXt -lXmu -lXext -lX11
X
Xall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "making" all "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) 'CDEBUGFLAGS=$(CDEBUGFLAGS)' all); \
X	done
X
XTOOL_SRCS = $(A_SRCS)
XTOOL_OBJS = $(A_OBJS)
XTOOL_INCS = $(A_INCS)
X
X LINTOPTS = -abhuvz -D_NO_PROTO $(DEFINES)
X
XCOMM_SRCS = \
X	color_l.c \
X	demo.c \
X	file_sel.c \
X	help.c \
X	item.c \
X	items.c \
X	list.c \
X	menu.c \
X	misc.c \
X	miscx.c \
X	room.c \
X	scrollbar.c \
X	sim.c \
X	table.c \
X	xball.c \
X	xball_sys.c
X
XCOMM_OBJS = \
X	color_l.o \
X	demo.o \
X	file_sel.o \
X	help.o \
X	item.o \
X	items.o \
X	list.o \
X	menu.o \
X	misc.o \
X	miscx.o \
X	room.o \
X	scrollbar.o \
X	sim.o \
X	table.o \
X	xball.o \
X	xball_sys.o
X
XCOMM_INCS = \
X	color_l.h \
X	demo.h \
X	fallback.h \
X	file_sel.h \
X	help.h \
X	intf.h \
X	item.h \
X	items.h \
X	list.h \
X	menu.h \
X	misc.h \
X	miscx.h \
X	names.h \
X        patchlevel.h \
X	room.h \
X	scrollbar.h \
X	sim.h \
X	table.h \
X	xball_sys.h
X
XSRCS = $(COMM_SRCS) $(TOOL_SRCS)
XOBJS = $(COMM_OBJS) $(TOOL_OBJS)
XINCS = $(COMM_INCS) $(TOOL_INCS)
X
X PROGRAM = xball
X
Xall:: xball
X
Xxball: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xsaber_xball:
X	#load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xosaber_xball:
X	#load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xinstall:: xball
X	$(INSTALL) -c $(INSTPGMFLAGS)   xball $(BINDIR)
X
Xinstall.man:: xball.man
X	$(INSTALL) -c $(INSTMANFLAGS) xball.man $(MANDIR)/xball.n
X
Xdepend::
X	$(DEPEND) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
XCLASS            = XBall
XAPP_DEFAULTS_SRC = $(CLASS).ad
X
Xinstall::  $(CLASS).ad
X	$(INSTALL) -c $(INSTAPPFLAGS)  $(CLASS).ad $(XAPPLOADDIR)/ $(CLASS)
X
Xfallback.h: $(APP_DEFAULTS_SRC)
X	gen_fallback $(APP_DEFAULTS_SRC) > $@
X
XDEMOS = demo1 demo2 demo3 demo4 demo5 demo6 demo7 demo8 demo9 demo10 \
X        demo11 demo12 demo13 demo14
X
XBITMAPS = \
X	good_bitmaps \
X	on.xbm \
X	off.xbm \
X	man.xbm \
X	stipple.xbm \
X	xball.xbm \
X	xball-a.xbm \
X	xball-b.xbm \
X	xball-l.xbm \
X	xball-x.xbm \
X	sgi.xbm
X
XMISC = \
X	gen_fallback \
X	run_demos \
X        xball.man \
X	README
X
XDRAWING_A_DIRS = \
X	X11 \
X	X11/Xaw_d
X
XDRAWING_A = \
X	X11/Xaw_d/DrawingA.c \
X	X11/Xaw_d/DrawingA.h \
X	X11/Xaw_d/DrawingAP.h \
X	X11/Xaw_d/DrawingA.doc \
X	X11/Xaw_d/Imakefile \
X	X11/Xaw_d/Makefile.std \
X	X11/Xaw_d/Makefile \
X        X11/Xaw_d/demo.c \
X	X11/Xaw_d/README \
X	Imakefile \
X	Makefile.std \
X	Makefile \
X	Make.motif \
X	Make.athena
X
XDIST = \
X	$(DRAWING_A) \
X	$(COMM_SRCS) \
X	$(COMM_INCS) \
X	$(M_SRCS) \
X	$(M_INCS) \
X	$(A_SRCS) \
X	$(A_INCS) \
X	$(APP_DEFAULTS_SRC) \
X	$(MISC) \
X	$(BITMAPS) \
X	$(DEMOS)
X
Xshar:
X	makekit -s75k -p $(DRAWING_A_DIRS) $(DIST)
X
Xtar:
X	tar cvf - $(DIST) | compress -v > xball.tar.Z
X
X###########################################################################
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) \#*
X
XMakefile::
X	-@if [ -f Makefile ]; then \
X	echo "	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak"; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	#load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	#load $(ALLDEFINES) $(OBJS)
X
X###########################################################################
X# rules for building in SUBDIRS - do not edit
X
Xinstall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "installing" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install); \
X	done
X
Xinstall.man::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "installing man pages" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install.man); \
X	done
X
Xclean::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "cleaning" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) RM_CMD='$(RM_CMD)' clean); \
X	done
X
Xtags::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "tagging" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) TAGS='$(TAGS)' tags); \
X	done
X
XMakefiles::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	echo "making Makefiles in $(CURRENT_DIR)/$$i..."; \
X	case "$$i" in \
X	./?*/?*/?*/?*) newtop=../../../../ sub=subsubsubsub;; \
X	./?*/?*/?*) newtop=../../../ sub=subsubsub;; \
X	./?*/?*) newtop=../../ sub=subsub;; \
X	./?*) newtop=../ sub=sub;; \
X	*/?*/?*/?*) newtop=../../../../ sub=subsubsubsub;; \
X	*/?*/?*) newtop=../../../ sub=subsubsub;; \
X	*/?*) newtop=../../ sub=subsub;; \
X	*) newtop=../ sub=sub;; \
X	esac; \
X	case "$(TOP)" in \
X	/?*) newtop= upprefix= ;; \
X	*) upprefix=../ ;; \
X	esac; \
X	$(MAKE) $${sub}dirMakefiles UPPREFIX=$$upprefix NEWTOP=$$newtop \
X	MAKEFILE_SUBDIR=$$i NEW_CURRENT_DIR=$(CURRENT_DIR)/$$i;\
X	done
X
XsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then \
X	echo "	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak"; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then \
X	echo "	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak"; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then \
X	echo "	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak"; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then \
X	echo "	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak"; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
Xincludes::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo including "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS)   includes); \
X	done
X
X###########################################################################
X# dependencies generated by makedepend
X
END_OF_FILE
if test 15960 -ne `wc -c <'Make.athena'`; then
    echo shar: \"'Make.athena'\" unpacked with wrong size!
fi
# end of 'Make.athena'
fi
if test -f 'color_l.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'color_l.c'\"
else
echo shar: Extracting \"'color_l.c'\" \(6091 characters\)
sed "s/^X//" >'color_l.c' <<'END_OF_FILE'
X/**********************************************************************
X * color_l.c - Color list object definition
X *
X * Copyright 1993, David Nedde
X *
X * Permission to use, copy, modify, and distribute this software
X * and its documentation for any purpose and without fee is granted
X * provided that the above copyright notice appears in all copies.
X * It is provided "as is" without express or implied warranty.
X **********************************************************************/
X
X/* System Headers */
X#include <stdlib.h>
X#include <stdio.h>
X#include <X11/X.h>
X#include <X11/Intrinsic.h>
X
X/* Local headers */
X#include "color_l.h"
X#include "misc.h"
X
X/* Functions */
Xstatic void get_rgb4_names();
X
X
X/* Public object methods */
X
X/* Constructs the color_list object */
Xcolor_list_type color_list__create(filename)
Xchar *filename;
X{
X    color_list_type color_list;
X
X
X    color_list = XtNew( color_list_struct);
X
X    color_list->shaded_4_list = list__create();
X
X    get_rgb4_names( color_list, filename);
X
X    return color_list;
X}
X
X
X/* Destroys the color_list object */
Xvoid color_list__destroy(color_list)
Xcolor_list_type color_list;
X{
X    color_type            color;
X
X    
X    for (color = color_list__get_last( color_list);
X         color != (color_type)0;
X         color = color_list__get_prev( color_list))
X    {
X        XtFree( color->name);
X        XtFree( (char *)color);
X    }
X
X    list__destroy(color_list->shaded_4_list);
X
X    XtFree( (char *)color_list);
X}
X
X
X/* Remove a specified node from the colored list */
Xcolor_type color_list__remove( color_list, ind)
Xcolor_list_type color_list;
Xint             ind;
X{
X    return (color_type)list__remove( color_list->shaded_4_list, ind);
X}
X
X
X/* Returns the number of nodes in the color list */
Xint color_list__get_count( color_list)
Xcolor_list_type color_list;
X{
X    return list__get_count( color_list->shaded_4_list);
X}
X
X
X/* Private object methods */
X
X/**********************************************************************
X/*
X/* get_rgb4_colors - Extract the names of all colors from rgb.txt that
X/*		     have 4 shades of the same color.
X/*
X/* void get_rgb4_colors( color_list, passed_file_name)
X/*
X/* list_type color_list   <-  a list of found colors
X/* char * passed_file_name -> The path of the rgb.txt file.  If this parameter
X/*                            is NULL, the RGB.TXT #define is used.
X/*
X/**********************************************************************/
Xstatic void get_rgb4_names(color_list, passed_file_name)
Xcolor_list_type color_list;
Xchar *passed_file_name;
X{
X    FILE		       *rgb; /* File pointer for rgb.txt */
X    char			colorname[50]; /* Temp color name string */
X    int                   r,g,b;
X    color_type            color;
X    color_type            colors[SHADES];
X    int                   color_index;
X    int                   shade_index;
X  
X
X
X    /*** Find the number of system colors */
X    if (!(rgb = fopen(passed_file_name, "r"))) 
X    {
X        /* Problem opening file */
X        fprintf(stderr,"color_list::get_rgb4_names: Opening rgb.txt file: ");
X        perror(passed_file_name);
X        exit( EXIT_FAILURE);
X    }
X
X    /* Count the number of 4-shaded colors in the rgb.txt file */
X    while (4 == fscanf(rgb, "%d %d %d %49[^\n]\n", &r, &g, &b, colorname))
X    {
X        color = XtNew( color_struct);
X        color->r = r;
X        color->g = g;
X        color->b = b;
X        color->name = XtNewString( colorname);
X        color->last_char = strlen( color->name) - 1;
X
X        list__add_end( color_list->shaded_4_list, (void *)color);
X    }
X
X    fclose(rgb);
X
X
X    /* Now, remove all colors that do not have color, color2, color3, color4
X       in the list */
X
X    color_index = color_list__get_count( color_list) - 1; 
X    while (color_index >= SHADES - 1)
X    {
X        for (shade_index = 0; shade_index < SHADES; shade_index++)
X	{
X	    colors[ shade_index] = 
X	        color_list__get_cell( color_list, color_index - shade_index);
X
X	    if (colors[ shade_index]->name[ colors[ shade_index]->last_char] !=
X		'0' + SHADES - shade_index)
X	    {
X	        /* all 4 colors are not there */
X	        int saveindex = color_index;
X
X	        color_index -= shade_index + 1;
X		while( shade_index >= 0)
X		{
X		    XtFree( colors[ shade_index]->name);
X		    XtFree( (char *)colors[ shade_index]);
X		    color_list__remove( color_list, saveindex + shade_index);
X		    shade_index--;
X		}
X		break;
X	    }
X	}
X	if (shade_index == SHADES)
X	  color_index -= SHADES;
X    }
X
X    /* delete any remaning colors... */
X    while (color_index >= 0)
X    {
X        color = color_list__get_cell( color_list, color_index);
X
X        XtFree( color->name);
X        XtFree( (char *)color);
X        color_list__remove( color_list, color_index);
X
X	color_index--;
X    }
X}
X
X
X
X/* Gets the last node in the color list */
Xcolor_type color_list__get_last( color_list)
Xcolor_list_type color_list;
X{
X    return (color_type)list__get_last( color_list->shaded_4_list);
X}
X
X
X/* Get the previous node in the color list */
Xcolor_type color_list__get_prev( color_list)
Xcolor_list_type color_list;
X{
X    return (color_type)list__get_prev( color_list->shaded_4_list);
X}
X
X
X#ifdef NOT_USED
X
Xchar *color__get_shade( color, shade_num)
Xcolor_type color;
Xint shade_num;
X{
X    color->name[ color->last_char] = '0' + shade_num;
X    return color->name;
X}
X
X/**********************************************************************
X/*
X/* is_4_shaded_color - Returns True if the colorname passed is one of
X/*		       the colors that has 4 shades.
X/*
X/* Bool is_4_shaded_color( colorname)
X/*
X/*  Bool return <- True if the colorname is a color with 4 shades
X/*  char *colorname -> The colorname to check
X/*
X/**********************************************************************/
Xstatic Bool is_4_shaded_color( colorname)
Xchar *colorname;
X{
X  /* A color with '4' as it's last character that isn't a 
X  /* grey color (e.g. grey14) is how we determine that we
X  /* have found a color that has 4 shades. */
X
X  return (colorname[strlen(colorname)-1] == '4' && 
X	  (strncmp(colorname,"grey",4) != 0 &&
X	   strncmp(colorname,"gray",4) != 0));
X}
X#endif
X
END_OF_FILE
if test 6091 -ne `wc -c <'color_l.c'`; then
    echo shar: \"'color_l.c'\" unpacked with wrong size!
fi
# end of 'color_l.c'
fi
if test -f 'demo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'demo.c'\"
else
echo shar: Extracting \"'demo.c'\" \(14150 characters\)
sed "s/^X//" >'demo.c' <<'END_OF_FILE'
X/**********************************************************************
X * demo.c - defines the demo object
X *
X * Copyright 1993, David Nedde
X *
X * Permission to use, copy, modify, and distribute this software
X * and its documentation for any purpose and without fee is granted
X * provided that the above copyright notice appears in all copies.
X * It is provided "as is" without express or implied warranty.
X **********************************************************************/
X
X/* System Headers */
X#include <stdio.h>
X#include <unistd.h>
X#include <X11/StringDefs.h>
X
X#ifdef MOTIF
X#include <Xm/Xm.h>
X#endif
X
X/* Local headers */
X#include "demo.h"
X#include "names.h"
X#include "intf.h"
X#include "miscx.h"
X
X/* Structures */
Xtypedef struct {
X  char *demo_file;
X} app_data,*app_data_ptr;
Xstatic app_data res_data;
Xstatic XtResource resources[] = {
X  { "demoFile", "DemoFile", XtRString, sizeof(char *),
X        XtOffset( app_data_ptr, demo_file), XtRString, NULL}
X};
X
X/* Functions */
Xvoid demo_start(/* demo*/);
X
X
X/* Public object methods */
X
X/* Create the demo object */
Xdemo_type demo__create( w, menu, gravity, elasticity, file_sel, items, room)
XWidget          w;
Xmenu_type       menu;
Xscrollbar_type  gravity;
Xscrollbar_type  elasticity;
Xfile_sel_type   file_sel;
Xitems_type      items;
Xroom_type       room;
X{
X    demo_type demo = XtNew( demo_struct_type);
X
X    demo->menu = menu;
X    demo->gravity = gravity;
X    demo->elasticity = elasticity;
X    demo->file_sel = file_sel;
X    demo->items = items;
X    demo->room = room;
X
X    XtGetApplicationResources(get_toplevel(w), (XtPointer)&res_data, 
X                              resources, XtNumber(resources), 
X                              (ArgList)NULL,(Cardinal)0);
X
X    if (res_data.demo_file != 0)
X    {
X        demo->file_name  = XtNewString( res_data.demo_file);
X        demo_start( demo);
X        demo->interactive = False;
X    }
X    else
X    {
X        demo->file_name = (char *)0;
X        demo->file_ptr   = (FILE *)0;
X        demo->iterations = 0;
X        demo->interactive = True;
X
X        /* The 'Stop Demo' menu item is greyed since demo is not running */
X        menu__set_sensitivity( demo->menu, STOP_DEMO, False);
X    }
X
X    return demo;
X}
X
X
X/* Destroy the demo object */
Xvoid demo__destroy( demo)
Xdemo_type demo;
X{
X    demo__stop( demo);
X    XtFree( (char *)demo);
X}
X
X
X/* A menu callback (mcb) which queries the user for a filename, and then */
X/* loads and runs the selected demo.                                     */
Xvoid demo__run_mcb( w, demo, call_data, extra)
XWidget    w;
Xdemo_type demo;
XXtPointer call_data;
Xchar *    extra;
X{
X    char *file_name = file_sel__display( demo->file_sel, "Load Demo");
X   
X    if (file_name != (char *)0)
X    {
X        demo__stop(demo);        /* Stop a demo if one is in progress */
X
X        demo->file_name = XtNewString(file_name);
X
X        demo_start( demo);
X    }
X}
X
X
X/* A menu callback (mcb) which stops the currently running demo */
Xvoid demo__stop_mcb( w, demo, call_data, extra)
XWidget    w;
Xdemo_type demo;
XXtPointer call_data;
Xchar *    extra;
X{
X    demo__stop( demo);
X}
X
X
X/* If a demo is running, stops it by reseting the menu sensitivity,
X   and cleaning up the demo file */
Xvoid demo__stop( demo)
Xdemo_type demo;
X{
X    if (!demo__running(demo))
X        return;
X
X    /* The 'Stop Demo' menu item is greyed since menu is not running */
X    menu__set_sensitivity( demo->menu, STOP_DEMO, False);
X
X    /* Set the file_name member to NULL to tell background_processing() that
X     * there is not a demo in progress */
X    if (demo->file_name != (char *)0)
X    {
X        XtFree( demo->file_name);
X        demo->file_name = (char *)0;
X    }
X
X    /* Close the demo file */
X    if (demo->file_ptr != (FILE *)0)
X    {
X        fclose(demo->file_ptr);
X        demo->file_ptr = (FILE *)0;
X    }
X}
X
X
X    
X/* Returns True if a demo is currently running */
XBool demo__running(demo)
Xdemo_type demo;
X{
X    return demo->file_name != (char *)0;
X}
X
X
X
X/*
X  demo language: (have 'quit demo' button)
X    create %d,%d,%d,%d: create a ball with x,y, x & y velocity
X    randomize: randomize velocities of all balls on screen
X    load_bitmap %s %d,%d: load a bitmap to an x,y on the screen
X    set_velocity %s %d,%d: set ball velocities (rel or abs)
X    gravity %d: set gravity to something
X    elasticity %d: set elasticity to something
X    iterate %d: pause for n iterations
X    perpetual on|off: turn perpetual balls on or off
X    collide on|off: turn ball collision on or off
X    item_width %d: change item width
X    item_height %d: change item height
X    window_width %d: Change window width
X    window_height %d: Change window height
X    clear: clear screen
X    create_random %d,%d: create count random balls with a velocity_factor
X    label %s:  A label
X    goto %s: Goto label
X    exit: quit the xball program
X    quit: quit the xball program
X    stop: stop demo but leave program alive
X*/
X#define MAX_LEN 100
X#define is_command(comm) (strncmp(comm,in_line,strlen(comm)) == 0)
X
X
X/* Performs one iteration of the currently running demo */
Xvoid demo__process(demo)
Xdemo_type demo;
X{
X    char in_line[MAX_LEN];       /* The current demo file line read in */
X
X    /* Used to extract parameters from in_line */
X    char str[MAX_LEN];     
X    int  x,y;
X    int  x_vel,y_vel;
X    int  width,height;
X    int  count;
X    int  velocity;
X    item_type item;
X
X
X    /* Do not run the demo until the item static data has been initialized */
X    if (!item__initted())
X        return;
X
X    if (demo->iterations > 0)
X    {
X        /* Pause for another iteration */
X        demo->iterations--;
X        return;
X    }
X
X
X    /* Read the next line of the demo */
X    while (fgets(in_line,MAX_LEN,demo->file_ptr) != (char *)NULL)
X    {
X        if (in_line[0] == '#' || in_line[0] == '\n')
X        {
X            /* Comment */
X            continue;
X        }
X        else 
X        if (is_command("create_random"))
X        {
X            /* create_random %d1,%d2 */
X            /* create %d1 random balls with a max velocity of %d2 */
X            
X            sscanf(in_line,"create_random %d,%d", &count, &velocity);
X            for (x = 0; x < count; x++)
X            {
X                items__new_item(demo->items, 
X                    rand_range(intf2int(room__get_left_wall( demo->room)),
X                               intf2int(room__get_right_wall( demo->room))),
X                    rand_range(intf2int(room__get_ceiling( demo->room)),
X                               intf2int(room__get_floor( demo->room))),
X                                rand_range( -velocity, velocity),
X                                rand_range( -velocity, velocity));
X            }
X        }
X        else    
X        if (is_command("create"))
X        {
X            /* create %d1,%d2,%d3,%d4 */
X            /* Create a ball with x,y position %d1,%d2 and 
X               an x & y velocity of %d2,%d4 */
X
X            sscanf(in_line,"create %d,%d,%d,%d\n", &x,&y, &x_vel,&y_vel);
X
X            items__new_item(demo->items, x, y, x_vel, y_vel);
X        }
X        else 
X        if (is_command("randomize"))
X        {
X            int min_x,max_x,min_y,max_y;
X
X
X            /* randomize %d,%d,%d,%d */
X            /* randomize velocities of all balls on screen 
X               with a max velocity of %d */
X
X            min_x = max_x = min_y = max_y = 0;
X            sscanf(in_line,"randomize %d,%d,%d,%d", &min_x,&max_x,&min_y,&max_y);
X
X            for (item = items__get_first( demo->items);
X                 item != (item_type)0;
X                 item = items__get_next( demo->items))
X            {
X                item__randomize( item, min_x, max_x, min_y, max_y);
X            }
X        }
X        else 
X        if (is_command("load_bitmap"))
X        {
X            /* load_bitmap %s %d1,%d2 */
X            /* load a bitmap file (where %s is the file path) to an 
X               x,y position of %d1,%d2 on the screen */
X
X            sscanf(in_line,"load_bitmap %s %d,%d", str,&x,&y);
X            room__load_bitmap(demo->room, str, x, y);
X        }
X        else 
X        if (is_command("set_velocity"))
X        {
X            /* set_velocity %s %d1,%d2 */
X            /* set ball velocities (%s is relative or absolute) to the x
X               and y velocities %d1,%d2 */
X
X            sscanf(in_line,"set_velocity %s %d,%d", str,&x_vel,&y_vel);
X
X            if (strncmp(str,"rel",3) == 0)
X            {
X                for (item = items__get_first( demo->items);
X                     item != (item_type)0;
X                     item = items__get_next( demo->items))
X                {
X                    item__set_x_vel( item, item__get_x_vel(item) + x_vel);
X                    item__set_y_vel( item, item__get_y_vel(item) + y_vel);
X                }
X            }
X            else if (strncmp(str,"abs",3) == 0)
X            {
X                for (item = items__get_first( demo->items);
X                     item != (item_type)0;
X                     item = items__get_next( demo->items))
X                {
X                    item__set_x_vel( item, x_vel);
X                    item__set_y_vel( item, y_vel);
X                }
X                room__flush( demo->room);
X            }
X            else
X                fprintf(stderr, 
X                        "Unrecognized set_velocity mode '%s'.\nValid modes: 'abs' or 'rel'.\n", str);
X        }
X        else 
X        if (is_command("gravity"))
X        {
X            /* gravity %d */
X            /* set gravity to %d */
X            
X            int gravity_value;
X
X            sscanf(in_line,"gravity %d", &gravity_value);
X
X            scrollbar__set_value( demo->gravity, gravity_value);
X        }
X        else 
X        if (is_command("elasticity"))
X        {
X            /* elasticity %d */
X            /* set elasticity to %d */
X
X            int elasticity_value;
X
X            sscanf(in_line,"elasticity %d", &elasticity_value);
X            
X            scrollbar__set_value( demo->elasticity, elasticity_value);
X        }
X        else 
X        if (is_command("iterate"))
X        {
X            /* iterate %d */
X            /* pause for %d iterations */
X
X            sscanf(in_line,"iterate %d", &demo->iterations);
X
X            if (demo->iterations)
X                /* We are pausing - exit read loop */
X                return;
X        }
X        else    
X        if (is_command("perpetual"))
X        {
X            /* perpetual %s */  
X            /* toggle perpetual (%s is 'on' or 'off') */
X
X            sscanf(in_line,"%*s %s", str);
X
X            menu__set_toggle( demo->menu, PERPETUAL, strcmp("on",str) == 0);
X        }
X        else 
X        if (is_command("collide"))
X        {
X            /* collide %s */
X            /* toggle ball collision (%s is 'on' or 'off') */
X
X            sscanf(in_line,"%*s %s", str);
X
X            menu__set_toggle( demo->menu, BALL_COLLIDE, strcmp("on",str) == 0);
X        }
X        else
X#if 0
X        if (is_command("item_size"))
X        {
X            /* item_width %d */
X            /* change item size to %d,%d */
X
X            sscanf(in_line,"item_size %d,%d", &width, &height);
X
X            items__set_visible( demo->items, False);
X
X            item__set_size( width, height);
X
X            items__set_visible( demo->items, True);
X        }
X        else 
X#endif
X        if (is_command("window_width"))
X        {
X            /* window_width %d */
X            /* Change window width to %d */
X
X            sscanf(in_line,"window_width %d", &width);
X
X            room__set_width( demo->room, width);
X        }
X        else 
X        if (is_command("window_height"))
X        {
X            /* window_height %d */
X            /* Change window height to %d */
X
X            sscanf(in_line,"window_height %d", &height);
X
X            room__set_height( demo->room, (Dimension)height);
X        }
X        else 
X        if (is_command("clear"))
X        {
X            /* clear */
X            /* delete all balls in window */
X
X            items__destroy_all( demo->items);
X        }
X#if 0
X        else 
X        if (is_command("goto") || is_command("label"))
X        {
X            /* goto %s */
X            /* Goto label %s */
X
X            /* label %s */
X            /* The label %s */
X
X            printf("Not implemented\n");
X        }
X#endif
X        else 
X        if (is_command("exit") || is_command("quit"))
X        {
X            /* exit */
X            /* quit */
X            /* quit the xball program */
X
X            if (!demo->interactive)
X            {
X                demo__stop( demo);
X                exit(0);
X            }
X        }
X        else 
X        if (is_command("stop"))
X        {
X            /* stop */
X            /* stop demo but leave program alive */
X
X            demo__stop( demo);
X            return;
X        }
X        else
X        if (is_command("backwards"))
X        {
X            sscanf(in_line,"backwards %d", &count);
X
X            items__move_items_backwards( demo->items, demo->room, count);
X        }
X        else
X        if (is_command("visible"))
X        {
X            sscanf(in_line,"visible %s", str);
X
X            items__set_visible( demo->items, strcmp("on",str) == 0);
X        }
X        else
X        if (is_command("sleep"))
X        {
X            sscanf(in_line,"sleep %u", &count);
X
X            sleep( (unsigned)count);
X        }
X        else
X        {
X            /* Could not recognize demo command */
X            in_line[strlen(in_line)-1] = '\0'; /* Kill newline */
X            printf("Unrecognized command '%s'\n", in_line);
X        }
X    }
X  
X    if (feof(demo->file_ptr))
X    {
X        /* At the end of the demo file.  Stop processing the demo */
X        demo__stop( demo);
X    }
X}
X
X
X/* Private object methods */
X
X/* Loads the currently specified demo program and sensitises the stop demo 
X   menu  */
Xstatic void demo_start( demo)
Xdemo_type demo;
X{
X    demo->iterations = 0;
X
X    /* Start up the demo file */
X
X    if ((demo->file_ptr = fopen(demo->file_name, "r")) == (FILE *)0)
X    {
X        /* Problem opening demo file */
X        fprintf(stderr,"Opening demo file: ");
X        perror( demo->file_name);
X
X
X        XtFree( demo->file_name);
X        demo->file_name = (char *)0;
X        return;
X    }
X    else
X    {
X        menu__set_sensitivity( demo->menu, STOP_DEMO, True);
X    }
X}
END_OF_FILE
if test 14150 -ne `wc -c <'demo.c'`; then
    echo shar: \"'demo.c'\" unpacked with wrong size!
fi
# end of 'demo.c'
fi
if test -f 'file_sel.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'file_sel.c'\"
else
echo shar: Extracting \"'file_sel.c'\" \(6437 characters\)
sed "s/^X//" >'file_sel.c' <<'END_OF_FILE'
X/**********************************************************************
X * file_sel.c - Object that asks the user for a filename.
X *
X * Copyright 1993, David Nedde
X *
X * Permission to use, copy, modify, and distribute this software
X * and its documentation for any purpose and without fee is granted
X * provided that the above copyright notice appears in all copies.
X * It is provided "as is" without express or implied warranty.
X **********************************************************************/
X
X/**********************************************************************
X * File_sel Object
X *
X * Private Methods:
X *
X *   XtCallbackProc button_cb
X *     Callback if the user presses a button in the selection dialog.
X *  
X *
X * Private Data:
X *
X *   Bool searching - True while the dialog is up.
X *   char *filename - Filename the user selected.
X *   Widget dialog_w - the dialog widget.
X *
X **********************************************************************/
X
X/* System headers */
X#include <stdio.h>
X#include <X11/Intrinsic.h>
X
X#ifdef MOTIF
X#include <Xm/FileSB.h>
X#include <Xm/DialogS.h>
X#endif
X
X/* Local headers */
X#include "file_sel.h"
X#include "miscx.h"
X#include "names.h"
X
X/* Functions */
Xstatic void display_dialog(/* file_sel, title*/);
X
X
X/* Create the file_sel object */
Xfile_sel_type file_sel__create(toplevel)
XWidget toplevel;
X{
X    file_sel_type file_sel = XtNew( file_sel_struct_type);
X
X    file_sel->toplevel = toplevel;
X
X    file_sel->searching = False;
X    file_sel->filename = (char *)0;
X    file_sel->dialog_w = (Widget)0;
X
X    return file_sel;
X}
X
X
X/**********************************************************************
X * file_sel__free - Free data associated with file_sel object
X *
X * void file_sel__free( file_sel_type file_sel)
X *
X *
X * file_sel - the file_sel object
X *
X **********************************************************************/
Xvoid file_sel__destroy(file_sel)
Xfile_sel_type file_sel;
X{
X    if (file_sel->filename != (char *)0)
X    {
X        XtFree( file_sel->filename);
X    }
X
X    if (file_sel->dialog_w != (Widget)0)
X    {
X        XtDestroyWidget( file_sel->dialog_w);
X    }
X
X    XtFree( (char *)file_sel);
X}
X
X
X/**********************************************************************
X * file_sel__display - Display the file selection box and return selected file
X *
X * char *file_sel__display(file_sel_type file_sel, char *title)
X *
X *
X * file_sel - the file_sel object
X * title - the string used for the dialog's popup window title
X * Returns - the filename selected by the user, or (char *)0 if canceled
X *
X * Description:
X *   If the title is (char *)0, a default title will be used.
X *   the returned string is not to be freed by the caller.
X *   The method only returns when the user is done with the dialog.
X *
X **********************************************************************/
Xchar *file_sel__display(file_sel, title)
Xfile_sel_type file_sel;
Xchar *        title;
X{
X    /* Free filename if it was set in previous calls */
X    if (file_sel->filename != (char *)0)
X    {
X        XtFree(file_sel->filename);
X        file_sel->filename = (char *)0;
X    }
X
X    /* Display dialog to user and set the filename member */
X    display_dialog( file_sel, title);
X
X    return file_sel->filename;
X}
X
X
X/* Private object methods */
X
X#ifdef MOTIF
X
Xstatic void button_cb(/*w, file_sel, call_data*/);
X
X
Xstatic void display_dialog( file_sel, title)
Xfile_sel_type file_sel;
Xchar *        title;
X{
X    XEvent event;
X    XtAppContext app_context;
X
X
X    file_sel->searching = True;
X
X    if (file_sel->dialog_w == (Widget)0)
X    {
X        file_sel->dialog_w = 
X            XmCreateFileSelectionDialog(file_sel->toplevel, FILE_SB, NULL, 0);
X
X        XtAddCallback(file_sel->dialog_w, XmNcancelCallback,
X                      button_cb, (XtPointer)file_sel);
X        XtAddCallback(file_sel->dialog_w,XmNokCallback,    
X                      button_cb, (XtPointer)file_sel);
X        XtAddCallback(file_sel->dialog_w,XmNhelpCallback,
X                      button_cb, (XtPointer)file_sel);
X    }
X
X    app_context = XtWidgetToApplicationContext( file_sel->dialog_w);
X
X    if (title == (char *)0)
X      title = "Select File";
X
X    XtVaSetValues( file_sel->dialog_w,
X                  XmNdialogStyle, XmDIALOG_FULL_APPLICATION_MODAL,
X                  XtVaTypedArg,
X                    XmNdialogTitle, XmRString, title, sizeof(char *),
X                  NULL);
X
X
X    XmFileSelectionDoSearch( file_sel->dialog_w, NULL);
X    XtManageChild( file_sel->dialog_w); /* Manage the file selection widget */
X
X
X    /* Keep processing Xt events until one of the callbacks resets the 
X       searching data member */
X    while (file_sel->searching)
X    {
X        XtAppNextEvent(app_context, &event);
X        XtDispatchEvent(&event);
X    }
X}
X
X
X/**********************************************************************
X * button_cb - Callback if the user presses a button in the selection dialog.
X *
X * XtCallbackProc button_cb
X *
X * Description:
X *   Brings down the file selection dialog.
X *   If the OK button was pressed, the selected string is saved.
X *   If the Cancel button was pressed...
X **********************************************************************/
Xstatic void button_cb(w, file_sel, call_data)
XWidget w;
Xfile_sel_type file_sel;
XXmFileSelectionBoxCallbackStruct *call_data;
X{
X    XtUnmanageChild(w);  /* Bring down the file selection dialog */
X
X    switch (call_data->reason)
X    {
X        case XmCR_OK:
X        /* Get the selected filename as a (char *) */
X        if (!XmStringGetLtoR(call_data->value, XmSTRING_DEFAULT_CHARSET, 
X                             &file_sel->filename))
X            /* Internal error - couldn't get the selected filename */
X            break;
X
X        if (file_sel->filename[0] == '\0')
X        {
X            /* No string was selected */
X            XtFree( file_sel->filename);
X            file_sel->filename = (char *)0;
X        }
X        break;
X
X
X        case XmCR_HELP:
X        break;
X
X
X        case XmCR_CANCEL:
X        break;
X    }
X
X    file_sel->searching = False;     /* Exit file_sel__display() routine */
X}
X
X#endif
X
X
X#ifdef ATHENA
X
X/* Display the file dialog to the user.  
X   Call SelFile in filemenu.c */
Xstatic void display_dialog( file_sel, title)
Xfile_sel_type file_sel;
Xchar *        title;
X{
X    SelFile( file_sel->toplevel, /*prompt=*/NULL, /*cancel=*/NULL, 
X             /*init_path=*/NULL, /*show_entry=*/NULL, 
X             &file_sel->filename);
X}
X
X#endif
END_OF_FILE
if test 6437 -ne `wc -c <'file_sel.c'`; then
    echo shar: \"'file_sel.c'\" unpacked with wrong size!
fi
# end of 'file_sel.c'
fi
if test -f 'help.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help.c'\"
else
echo shar: Extracting \"'help.c'\" \(8702 characters\)
sed "s/^X//" >'help.c' <<'END_OF_FILE'
X/**********************************************************************
X * help.c - help object definition
X *
X * Copyright 1993, David Nedde
X *
X * Permission to use, copy, modify, and distribute this software
X * and its documentation for any purpose and without fee is granted
X * provided that the above copyright notice appears in all copies.
X * It is provided "as is" without express or implied warranty.
X **********************************************************************/
X
X/* System Headers */
X#include <X11/StringDefs.h>
X
X#ifdef MOTIF
X#include <Xm/Xm.h>
X#include <Xm/Form.h>
X#include <Xm/Text.h>
X#include <Xm/Separator.h>
X#include "act_area.h"
X#endif
X
X#ifdef ATHENA
X#include <X11/Intrinsic.h>
X#include <X11/Shell.h>
X#include <X11/Xaw/Form.h>
X#include <X11/Xaw/AsciiText.h>
X#include <X11/Xaw/Command.h>
X#endif
X
X/* Local headers */
X#include "help.h"
X#include "names.h"
X#include "misc.h"
X#include "miscx.h"
X
X/* File scope variables */
Xtypedef struct {
X  char *menu_help;
X  char *scrollbar_help;
X  char *pointer_help;
X  char *demo_help;
X  char *startup_help;
X  char *about_help;
X} app_data,*app_data_ptr;
Xstatic app_data res_data = { 0, 0, 0, 0, 0, 0 };
Xstatic XtResource resources[] = {
X  { "menuHelp", "MenuHelp", XtRString, sizeof(char *),
X        XtOffset( app_data_ptr, menu_help), XtRString, NULL},
X  { "scrollbarHelp", "ScrollbarHelp", XtRString, sizeof(char *),
X        XtOffset( app_data_ptr, scrollbar_help), XtRString, NULL},
X  { "pointerHelp", "PointerHelp", XtRString, sizeof(char *),
X        XtOffset( app_data_ptr, pointer_help), XtRString, NULL},
X  { "demoHelp", "DemoHelp", XtRString, sizeof(char *),
X        XtOffset( app_data_ptr, demo_help), XtRString, NULL},
X  { "startupHelp", "StartupHelp", XtRString, sizeof(char *),
X        XtOffset( app_data_ptr, startup_help), XtRString, NULL},
X  { "aboutString", "AboutString", XtRString, sizeof(char *),
X        XtOffset( app_data_ptr, about_help), XtRString, NULL}
X};
X
X/* Functions */
Xstatic void close_cb(/*w, help, call_data*/);
Xstatic void display_help_dialog(/*help, message*/);
Xstatic void create_help_dialog(/* help*/);
Xstatic void set_help_text(/* help, message*/);
X
X
X/* Public object methods */
X
X/* Create the help object */
Xhelp_type help__create(w)
XWidget w;
X{
X    help_type help = XtNew( help_struct_type);
X
X    help->toplevel = w;
X
X    help->dialog_w = (Widget)0;
X
X    return help;
X}
X
X
X/* Destroy the help object */
Xvoid help__destroy(help)
Xhelp_type help;
X{
X    XtDestroyWidget( help->dialog_w);
X
X    XtFree( (char *)help);
X}
X
X
X/* A menu callback (mcb) that displayshelp to the user, based on the
X   name of the menu button used to invoke the callback */
Xvoid help__display_mcb(w, help, call_data, extra)
XWidget    w;
Xhelp_type help;
XXtPointer call_data;
Xchar *    extra;
X{
X    char * help_text;
X    char * widget_name = XtName(w);
X
X
X    if (res_data.menu_help == 0)
X    {
X        /* Read help text resources */
X        XtGetApplicationResources(get_toplevel(w), (XtPointer)&res_data, 
X                                  resources, XtNumber(resources), 
X                                  (ArgList)NULL,(Cardinal)0);
X
X	/* We have to convert the ~ to newlines because fallback
X	   resources do not work if they have newlines embedded in them */
X	/* convert_newlines is in misc.c */
X        convert_newlines( res_data.menu_help);
X        convert_newlines( res_data.scrollbar_help);
X        convert_newlines( res_data.pointer_help);
X        convert_newlines( res_data.demo_help);
X        convert_newlines( res_data.startup_help);
X        convert_newlines( res_data.about_help);
X    }
X
X    if (strcmp( widget_name, ON_MENUS) == 0)
X        help_text = res_data.menu_help;
X    else
X    if (strcmp( widget_name, ON_SCROLL) == 0)
X        help_text = res_data.scrollbar_help;
X    else
X    if (strcmp( widget_name, ON_BUTTONS) == 0)
X        help_text = res_data.pointer_help;
X    else
X    if (strcmp( widget_name, ON_DEMOS) == 0)
X        help_text = res_data.demo_help;
X    else
X    if (strcmp( widget_name, ON_PARAMS) == 0)
X        help_text = res_data.startup_help;
X    else
X    if (strcmp( widget_name, ABOUT) == 0)
X        help_text = res_data.about_help;
X
X    /* Display the help dialog */
X    display_help_dialog(help, help_text);
X}
X
X
X/* Private object methods */
X
X/* Called when the user wants to close the help dialog */
Xstatic void close_cb(w, help, call_data)
XWidget          w;
Xhelp_type       help;
XXtPointer call_data;
X{
X    XtUnmanageChild( help->dialog_w);
X}
X
X
X/* Displays the passed message in the help dialog */
Xstatic void display_help_dialog(help, message)
Xhelp_type help;
Xchar   *message;
X{
X    if (help->dialog_w == (Widget)0)
X    {
X        create_help_dialog( help);
X    }
X
X    set_help_text( help, message);
X
X    XtManageChild( help->dialog_w);
X}
X
X
X#ifdef MOTIF
X
X/* Creates the Motif help dialog */
X/* Uses CreateActionArea in act_area.c */
Xstatic void create_help_dialog( help)
Xhelp_type help;
X{
X    Widget sep;
X    Arg    wargs[10];
X    int    n;
X
X    static ActionAreaItem action_items[] = {
X        { "close",            close_cb,  NULL }
X    };
X
X
X    help->dialog_w = 
X        XmCreateFormDialog( help->toplevel, HELP_DIALOG, NULL, 0);
X
X
X    /* Create the action area */
X    action_items[0].data = (XtPointer )help;
X    CreateActionArea( help->dialog_w, 
X                      action_items, XtNumber(action_items));
X
X
X    sep = XtVaCreateManagedWidget("separator", xmSeparatorWidgetClass,
X                            help->dialog_w, 
X                            NULL);
X
X    n = 0;
X    XtSetArg(wargs[n], XmNeditMode,           XmMULTI_LINE_EDIT); n++;
X    XtSetArg(wargs[n], XmNeditable,           False); n++;
X    XtSetArg(wargs[n], XmNverifyBell,         False); n++;
X    XtSetArg(wargs[n], XmNtopAttachment,      XmATTACH_FORM); n++;
X    XtSetArg(wargs[n], XmNleftAttachment,     XmATTACH_FORM); n++;
X    XtSetArg(wargs[n], XmNrightAttachment,    XmATTACH_FORM); n++;
X    XtSetArg(wargs[n], XmNbottomAttachment,   XmATTACH_WIDGET); n++;
X    XtSetArg(wargs[n], XmNbottomWidget,       sep); n++;
X
X    help->text_w = 
X        XmCreateScrolledText( help->dialog_w, "help_text", wargs, n);
X    XtManageChild( help->text_w);
X}
X
X
X/* Sets the help text in the Motif dialog */
Xstatic void set_help_text( help, message)
Xhelp_type help;
Xchar * message;
X{
X    XmTextSetString( help->text_w, message);
X}
X
X#endif
X
X
X#ifdef ATHENA
X
X/* Creates the Athena help dialog */
Xstatic void create_help_dialog( help)
Xhelp_type help;
X{
X    Widget      form;
X    Widget      button;
X    char        buff[50];
X    Dimension   border_width;
X    Dimension   top_width;
X    Dimension   top_height;
X    Dimension   dialog_width;
X    Dimension   dialog_height;
X    int         x_offset, y_offset;
X    Position    x,y;
X
X
X
X    sprintf(buff, "%s_popup", HELP_DIALOG);
X    help->dialog_w = 
X        XtVaCreateWidget( buff, transientShellWidgetClass, help->toplevel,
X                          XtNtransientFor,      help->toplevel,
X                          XtNmappedWhenManaged, False,
X                          NULL);
X
X    form = XtVaCreateManagedWidget( HELP_DIALOG, formWidgetClass, 
X                                    help->dialog_w, NULL);
X
X    help->text_w = 
X        XtVaCreateManagedWidget( "help_textAW", asciiTextWidgetClass, form,
X                                 NULL);
X
X    button = 
X        XtVaCreateManagedWidget( "close", commandWidgetClass, form,
X                                 XtNfromVert,   help->text_w,
X                                 NULL);
X    XtAddCallback( button, XtNcallback, close_cb, (XtPointer)help);
X
X    XtInstallAccelerators( form, button);
X
X    /* Manage so the shell widget's width and height will be set */
X    XtManageChild( help->dialog_w);
X
X    /* Position centered over the toplevel window */
X    XtVaGetValues( help->toplevel,
X                   XtNwidth,       &top_width,
X                   XtNheight,      &top_height,
X                   XtNborderWidth, &border_width,
X                   NULL);
X
X    XtVaGetValues( help->dialog_w,
X                   XtNwidth,  &dialog_width,
X                   XtNheight, &dialog_height,
X                   NULL);
X
X    x_offset = (top_width  - dialog_width ) / 2;
X    y_offset = (top_height - dialog_height) / 2;
X
X    XtTranslateCoords(help->toplevel, x_offset, y_offset, &x, &y);
X
X    XtUnmanageChild( help->dialog_w);
X
X    XtVaSetValues( help->dialog_w,
X                   XtNx,                 x,
X                   XtNy,                 y,
X                   XtNmappedWhenManaged, True,
X                   NULL);
X}
X
X
X/* Set the help string in the Athena help dialog */
Xstatic void set_help_text( help, message)
Xhelp_type help;
Xchar * message;
X{
X    XtVaSetValues( help->text_w,
X                   XtNstring, message,
X                   NULL);
X}
X
X#endif
END_OF_FILE
if test 8702 -ne `wc -c <'help.c'`; then
    echo shar: \"'help.c'\" unpacked with wrong size!
fi
# end of 'help.c'
fi
if test -f 'list.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'list.c'\"
else
echo shar: Extracting \"'list.c'\" \(5282 characters\)
sed "s/^X//" >'list.c' <<'END_OF_FILE'
X/**********************************************************************
X * list.c - defines a void * list object
X *
X * Copyright 1993, David Nedde
X *
X * Permission to use, copy, modify, and distribute this software
X * and its documentation for any purpose and without fee is granted
X * provided that the above copyright notice appears in all copies.
X * It is provided "as is" without express or implied warranty.
X **********************************************************************/
X
X/* System Headers */
X#include <malloc.h>
X
X/* Local headers */
X#include "list.h"
X
X/* Functions */
Xstatic void list_double(/* list*/);
Xstatic void *get_item(/* list, index*/);
X
X
X
X/* Public object methods */
X
X/* Create the list object */
Xlist_type list__create()
X{
X    list_type list;
X
X
X    list = (list_type)malloc( sizeof( list_struct));
X
X    list->count     = 0;
X    list->curr_item = 0;
X    list->max_count = LIST_INITIAL_SIZE;
X    list->data = (void **)malloc( sizeof( void *) * list->max_count);
X
X    return list;
X}
X
X
X/* Destroy the list object.  Items in the list are not freed */
Xvoid list__destroy( list)
Xlist_type list;
X{
X    free( list->data);
X    free( list);
X}
X
X
X/* Add an item to the start of the list */
Xvoid *list__add_start( list, data_item)
Xlist_type list;
Xvoid *data_item;
X{
X    int i;
X
X
X    if (list->count == list->max_count)
X        list_double( list);
X
X    /* Copy all item down by one */
X    for (i = list->count-1; i > 0; i--)
X        list->data[ i] = list->data[ i - 1];
X
X    list->data[ 0] = data_item;
X
X    list->count++;
X
X    return data_item;
X}
X
X
X/* Add an item to the end of the list */
Xvoid *list__add_end( list, data_item)
Xlist_type list;
Xvoid *data_item;
X{
X    if (list->count == list->max_count)
X        list_double( list);
X
X    list->data[ list->count] = data_item;
X
X    list->count++;
X
X    return data_item;
X}
X
X
X/* Get the first item in the list */
Xvoid *list__get_first( list)
Xlist_type list;
X{
X    list->curr_item = 0;
X    return get_item( list, list->curr_item);
X}
X
X
X/* Get the next item in the list.  NULL is returned if there are no more
X   items in the list */
Xvoid *list__get_next( list)
Xlist_type list;
X{
X    list->curr_item++;
X    return get_item( list, list->curr_item);
X}
X
X
X/* Return the last item in the list */
Xvoid *list__get_last( list)
Xlist_type list;
X{
X    list->curr_item = list->count - 1;
X    return get_item( list, list->curr_item);
X}
X
X
X/* Return the previous item in the list.  If there are no more items,
X   return NULL. */
Xvoid *list__get_prev( list)
Xlist_type list;
X{
X    if (list->curr_item > 0)
X    {
X        list->curr_item--;
X        return get_item( list, list->curr_item);
X    }
X    else
X        return (void *)0;
X}
X
X
X/* Remove the last item in the list.  The item removed is returned. */
Xvoid *list__remove_last( list)
Xlist_type list;
X{
X    void *data_item = (void *)0;
X
X
X    if (list->count > 0)
X    {
X        list->count--;
X        data_item = list->data[ list->count];
X        list->data[ list->count] = (void *)0;
X    }
X
X    return data_item;
X}
X
X
X/* Remove the first item in the list.  The item removed is returned. */
Xvoid *list__remove_first( list)
Xlist_type list;
X{
X    int i;
X    void *data_item = (void *)0;
X
X
X    if (list->count > 0)
X    {
X        list->count--;
X        data_item = list->data[ 0];
X
X        /* Shift data pointers up one */
X        for (i = 0; i < list->count; i++)
X            list->data[ i] = list->data[ i+1];
X
X        list->data[ list->count] = (void *)0;
X    }
X
X    return data_item;
X}
X
X
X/* Remove the current item in the list, as positioned by get_first, next, 
X   last, prev.   The current item is now the item after the one removed */
Xvoid *list__remove_curr( list)
Xlist_type list;
X{
X    int i;
X    void *data_item = (void *)0;
X
X    if (list->curr_item < list->count)
X    {
X        data_item = list->data[ list->curr_item];
X
X        for (i = list->curr_item; i < list->count; i++)
X            list->data[ i] = list->data[ i+1];
X
X        list->data[ list->count] = (void *)0;
X    }
X
X    return data_item;
X}
X
X
X/* Remove an item at the specified position in the list */
Xvoid *list__remove( list, ind)
Xlist_type list;
Xint       ind;
X{
X    int i;
X    void *data_item = (void *)0;
X
X    if (ind >= 0 && ind < list->count)
X    {
X        data_item = list->data[ ind];
X
X        for (i = ind; i < list->count - 1; i++)
X            list->data[ i] = list->data[ i+1];
X
X        list->data[ list->count] = (void *)0;
X    }
X
X    list->count--;
X
X    return data_item;
X}
X
X
X/* Remove all items in the list.  The objects are not freed */
Xvoid list__remove_all( list)
Xlist_type list;
X{
X    int i;
X
X
X    for (i = 0; i < list->count; i++)
X        list->data[ i] = (void *)0;
X
X    list->count = 0;
X}
X
X
X/* Private object methods */
X
X/* Return the specified object at a specified position */
Xstatic void *get_item( list, ind)
Xlist_type list;
Xint       ind;
X{
X    if (ind < list->count)
X        return list->data[ ind];
X    else
X        return (void *)0;
X}
X
X
X/* Double the size of the list */
Xstatic void list_double( list)
Xlist_type list;
X{
X    int i;
X
X
X    /* Double the list's size */
X    void **tmp_data = list->data;
X
X    list->max_count *= 2;
X    list->data = (void **)malloc( sizeof( void *) * list->max_count);
X
X    for (i = 0; i < list->count; i++)
X        list->data[ i] = tmp_data[ i];
X
X    free( tmp_data);
X}
END_OF_FILE
if test 5282 -ne `wc -c <'list.c'`; then
    echo shar: \"'list.c'\" unpacked with wrong size!
fi
# end of 'list.c'
fi
if test -f 'misc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'misc.c'\"
else
echo shar: Extracting \"'misc.c'\" \(1605 characters\)
sed "s/^X//" >'misc.c' <<'END_OF_FILE'
X/**********************************************************************
X * misc.c - Misc functions
X *
X * Copyright 1993, David Nedde
X *
X * Permission to use, copy, modify, and distribute this software
X * and its documentation for any purpose and without fee is granted
X * provided that the above copyright notice appears in all copies.
X * It is provided "as is" without express or implied warranty.
X **********************************************************************/
X
X/* System Headers */
X#include <malloc.h>
X#include <string.h>
X
X
X/* Given a string 'text\nmore text', allocates and returns the
X   string before the newline. */
Xchar *get_string( str)
Xchar *str;
X{
X    char *tmp;
X    char *newline = strchr(str,'\n');
X    int len;
X
X    if (newline == (char *)0)
X        return (char *)0;
X
X    len = newline - str;
X    tmp = malloc( len + 1);
X    strncpy( tmp, str, len + 1);
X    tmp[ len] = '\0';
X
X    return tmp;
X}
X
X
X/* Because some systems  do not have strdup */
Xchar *my_strdup( str)
Xchar *str;
X{
X    char *ret_str = malloc( strlen( str) + 1);
X
X    strcpy( ret_str, str);
X
X    return ret_str;
X}
X
X
X/* Return a random value in the specified range */
Xlong rand_range( min, max)
Xlong min, max;
X{
X    if (min == max)
X        return min;
X    else
X        return random() % (max - min) + min;
X}
X
X
X/* Change '~' to \n in the passed string */
X/* This silliness is due to fallback resources not handling \n in the 
X   resource string */
Xvoid convert_newlines( str)
Xchar *str;
X{
X    char *curr = strchr( str, '~');
X
X
X    while (curr != 0)
X    {
X        *curr = '\n';
X        curr = strchr( curr, '~');
X    }
X}
END_OF_FILE
if test 1605 -ne `wc -c <'misc.c'`; then
    echo shar: \"'misc.c'\" unpacked with wrong size!
fi
# end of 'misc.c'
fi
if test -f 'miscx.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'miscx.c'\"
else
echo shar: Extracting \"'miscx.c'\" \(1735 characters\)
sed "s/^X//" >'miscx.c' <<'END_OF_FILE'
X/**********************************************************************
X * miscx.c - Misc X, Xt and Xmu related functions
X *
X * Copyright 1993, David Nedde
X *
X * Permission to use, copy, modify, and distribute this software
X * and its documentation for any purpose and without fee is granted
X * provided that the above copyright notice appears in all copies.
X * It is provided "as is" without express or implied warranty.
X **********************************************************************/
X
X/* System Headers */
X#include <X11/StringDefs.h>
X#include <X11/IntrinsicP.h>
X#include <X11/CoreP.h>
X#include <X11/Xmu/Converters.h>
X
X
X/**********************************************************************
X * setupCoverters - Setup user-defined Xt type converters.
X *
X * void setupConverters()
X *
X * Description:
X *   Sets up string to widget converter.
X **********************************************************************/
Xvoid setupConverters()
X{
X        static XtConvertArgRec parentCvtArgs[] = {
X                {XtBaseOffset, (caddr_t)XtOffset(Widget, core.parent),
X                        sizeof(Widget)}
X        };
X
X        XtAddConverter(XtRString, XtRWindow, XmuCvtStringToWidget,
X                parentCvtArgs, XtNumber(parentCvtArgs));
X}
X
X
X/**********************************************************************
X * get_toplevel - Return the toplevel widget in the widget heirarchy.
X *
X * Widget get_toplevel(Widget w)
X *
X *
X * w - Any widget in the heirarchy
X *
X **********************************************************************/
XWidget get_toplevel(w)
XWidget w;
X{
X    /* Get the toplevel shell widget to change the cursor for all windows */
X    while (!XtIsTopLevelShell( w))
X        w = XtParent( w);
X
X    return w;
X}
END_OF_FILE
if test 1735 -ne `wc -c <'miscx.c'`; then
    echo shar: \"'miscx.c'\" unpacked with wrong size!
fi
# end of 'miscx.c'
fi
if test -f 'help.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help.h'\"
else
echo shar: Extracting \"'help.h'\" \(805 characters\)
sed "s/^X//" >'help.h' <<'END_OF_FILE'
X/**********************************************************************
X * file - description
X *
X * Copyright 1993, David Nedde
X *
X * Permission to use, copy, modify, and distribute this software
X * and its documentation for any purpose and without fee is granted
X * provided that the above copyright notice appears in all copies.
X * It is provided "as is" without express or implied warranty.
X **********************************************************************/
X
X#ifndef __HELP_H__
X#define __HELP_H__
X
X#include <X11/Intrinsic.h>
X
Xtypedef struct {
X    Widget toplevel;
X    Widget dialog_w;
X    Widget text_w;
X} help_struct_type, *help_type;
X
X
X/* Public methods */
Xhelp_type help__create(/*w*/);
Xvoid      help__destroy(/*help*/);
Xvoid      help__display_mcb(/*w, help, call_data, extra*/);
X
X
X#endif
X
X
END_OF_FILE
if test 805 -ne `wc -c <'help.h'`; then
    echo shar: \"'help.h'\" unpacked with wrong size!
fi
# end of 'help.h'
fi
echo shar: End of archive 2 \(of 5\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 5 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 5 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@IMD.Sterling.COM       | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@imd.sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
