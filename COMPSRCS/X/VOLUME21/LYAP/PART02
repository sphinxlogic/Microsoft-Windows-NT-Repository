Newsgroups: comp.sources.x
From: rr@sco.com (Ronald Joe Record)
Subject: v21i005:  lyap - Calculate Lyapunov fractals, Part02/03
Message-ID: <1993Oct7.174705.3710@sparky.sterling.com>
X-Md4-Signature: bbc3292fb21ca564513c0b0b9ba39def
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Thu, 7 Oct 1993 17:47:05 GMT
Approved: chris@sterling.com

Submitted-by: rr@sco.com (Ronald Joe Record)
Posting-number: Volume 21, Issue 5
Archive-name: lyap/part02
Environment: X11
Supersedes: lyapunov-xlib: Volume 17, Issue 48-49

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  lyap/Makefile.bak lyap/lib/buffer.c lyap/lib/init_color.c
#   lyap/lib/spin.c lyap/lyap.h lyap/lyap.man lyap/params/circle-4
# Wrapped by chris@sparky on Thu Oct  7 12:38:39 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 3)."'
if test -f 'lyap/Makefile.bak' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lyap/Makefile.bak'\"
else
  echo shar: Extracting \"'lyap/Makefile.bak'\" \(15607 characters\)
  sed "s/^X//" >'lyap/Makefile.bak' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and </tmp/IIf.a00830>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.72.1.1 92/03/18 13:13:37 rws Exp $
X
X# operating system:  SunOS 4.1.1
X
X# $XConsortium: sunLib.rules,v 1.7 91/12/20 11:19:47 rws Exp $
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -g kmem -m 2755
X
X      PROJECTROOT = /usr/X11R5
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/X11R5/lib
X           BINDIR = /usr/X11R5/bin
X          INCROOT = /usr/X11R5/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/X11R5/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = 1
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X# $XConsortium: sunLib.tmpl,v 1.14.1.1 92/03/17 14:58:46 rws Exp $
X
XSHLIBLDFLAGS = -assert pure-text
XPICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X       XMULIBONLY = -lXmu
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
XCC=gcc
X#
X#   @(#) Imakefile 9.3 93/08/03
X#
X#*************************************************************************
X#*                                                                       *
X#*     Copyright (c) 1992-1993                  Ronald Joe Record        *
X#*                                                                       *
X#*  All rights reserved. No part of this program or publication may be   *
X#*  reproduced, transmitted, transcribed, stored in a retrieval system,  *
X#*  or translated into any language or computer language, in any form or *
X#*  by any means, electronic, mechanical, magnetic, optical, chemical,   *
X#*  biological, or otherwise, without the prior written permission of:   *
X#*                                                                       *
X#*              Ronald Joe Record                        (408) 458-3718  *
X#*              212 Owen St., Santa Cruz, California 95062 USA           *
X#*                                                                       *
X#*************************************************************************
X
X#
X#        Imakefile for lyap, by Ron Record
X#
X
X        SUBDIRS = lib
X
X        DEPLIBS = $(DEPXLIB)
X#    Uncomment the following line if your system doesn't support prototypes
X#    PROTODEFINE = -D_NO_PROTO
X#    -DMAPS includes code to support "Function forcing". See lyap.man (-F)
X      MAPDEFINE = -DMAPS
X        DEFINES = $(MAPDEFINE) $(PROTODEFINE)
X       INCLUDES = -I. -Ilib
X         CFLAGS = -O $(DEFINES) $(INCLUDES) $(CDEBUGFLAGS)
XLOCAL_LIBRARIES = lib/libXrr.a $(XLIB)
X  SYS_LIBRARIES = -lm $(NAPLIB)
X           SRCS = lyap.c
X           OBJS = lyap.o
X
Xall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "making" all "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) 'CDEBUGFLAGS=$(CDEBUGFLAGS)' all); \
X	done
X
Xdepend::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "depending" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS)  depend); \
X	done
X
X PROGRAM = lyap
X
Xall:: lyap
X
Xlyap: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xsaber_lyap:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xosaber_lyap:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xinstall:: lyap
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  lyap $(DESTDIR)$(BINDIR)
X
Xinstall.man:: lyap.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) lyap.man $(DESTDIR)$(MANDIR)/lyap.$(MANSUFFIX)
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
Xinstall:: lyap
X	@if [ -d $(DESTDIR) $(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR) $(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  lyap $(DESTDIR) $(BINDIR)
X
Xinstall.man:: lyap.man
X	@if [ -d $(DESTDIR) $(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR) $(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) lyap.man $(DESTDIR) $(MANDIR)/lyap.$(MANSUFFIX)
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	# load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	# load $(ALLDEFINES) $(OBJS)
X
X# -------------------------------------------------------------------------
X# rules for building in SUBDIRS - do not edit
X
Xinstall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "installing" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install); \
X	done
X
Xinstall.man::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "installing man pages" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install.man); \
X	done
X
Xclean::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "cleaning" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) RM_CMD='$(RM_CMD)' clean); \
X	done
X
Xtags::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "tagging" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) TAGS='$(TAGS)' tags); \
X	done
X
XMakefiles::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	echo "making Makefiles in $(CURRENT_DIR)/$$i..."; \
X	case "$$i" in \
X	./?*/?*/?*/?*) newtop=../../../../ sub=subsubsubsub;; \
X	./?*/?*/?*) newtop=../../../ sub=subsubsub;; \
X	./?*/?*) newtop=../../ sub=subsub;; \
X	./?*) newtop=../ sub=sub;; \
X	*/?*/?*/?*) newtop=../../../../ sub=subsubsubsub;; \
X	*/?*/?*) newtop=../../../ sub=subsubsub;; \
X	*/?*) newtop=../../ sub=subsub;; \
X	*) newtop=../ sub=sub;; \
X	esac; \
X	case "$(TOP)" in \
X	/?*) newtop= upprefix= ;; \
X	*) upprefix=../ ;; \
X	esac; \
X	$(MAKE) $${sub}dirMakefiles UPPREFIX=$$upprefix NEWTOP=$$newtop \
X	MAKEFILE_SUBDIR=$$i NEW_CURRENT_DIR=$(CURRENT_DIR)/$$i;\
X	done
X
XsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then set -x; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then set -x; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then set -x; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then set -x; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
Xincludes::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo including "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS)  includes); \
X	done
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
END_OF_FILE
  if test 15607 -ne `wc -c <'lyap/Makefile.bak'`; then
    echo shar: \"'lyap/Makefile.bak'\" unpacked with wrong size!
  fi
  # end of 'lyap/Makefile.bak'
fi
if test -f 'lyap/lib/buffer.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lyap/lib/buffer.c'\"
else
  echo shar: Extracting \"'lyap/lib/buffer.c'\" \(3470 characters\)
  sed "s/^X//" >'lyap/lib/buffer.c' <<'END_OF_FILE'
X/*************************************************************************
X *                                                                       *
X *  Copyright (c) 1992, 1993 Ronald Joe Record                           *
X *                                                                       *
X *  All rights reserved. No part of this program or publication may be   *
X *  reproduced, transmitted, transcribed, stored in a retrieval system,  *
X *  or translated into any language or computer language, in any form or *
X *  by any means, electronic, mechanical, magnetic, optical, chemical,   *
X *  biological, or otherwise, without the prior written permission of:   *
X *                                                                       *
X *      Ronald Joe Record (408) 458-3718                                 *
X *      212 Owen St., Santa Cruz, California 95062 USA                   *
X *                                                                       *
X *************************************************************************/
X
X#include "libXrr.h"
X
Xvoid
XBufferInPixmap(display, pixmap, contexts, points, col, x, y)
XDisplay *display;
XPixmap pixmap;
XGC *contexts;
Xpoints_t *points;
Xint col, x, y;
X{
X    if (points->npoints[col] == MAXPOINTS)
X    {
X        XDrawPoints(display, pixmap, contexts[col],
X            points->data[col], points->npoints[col], CoordModeOrigin);
X        points->npoints[col] = 0;
X    }
X    points->data[col][points->npoints[col]].x = x;
X    points->data[col][points->npoints[col]].y = y;
X    ++points->npoints[col];
X}
X
Xvoid
XBufferPoint(display, window, pixmap, contexts, points, col, x, y)
XDisplay *display;
XWindow window;
XPixmap pixmap;
XGC *contexts;
Xpoints_t *points;
Xint col, x, y;
X{
X    if (points->npoints[col] == MAXPOINTS)
X    {
X        XDrawPoints(display, window, contexts[col],
X            points->data[col], points->npoints[col], CoordModeOrigin);
X        XDrawPoints(display, pixmap, contexts[col],
X            points->data[col], points->npoints[col], CoordModeOrigin);
X        points->npoints[col] = 0;
X    }
X    points->data[col][points->npoints[col]].x = x;
X    points->data[col][points->npoints[col]].y = y;
X    ++points->npoints[col];
X}
X
Xvoid
XInitBuffer(points, maxcolor)
Xpoints_t *points;
Xint maxcolor;
X{
X    static int i;
X
X    for (i = 0 ; i < maxcolor; i++)
X        points->npoints[i] = 0;
X}
X
Xvoid
XFlushPixmap(display, pixmap, contexts, points, mincolor, maxcolor)
XDisplay *display;
XPixmap pixmap;
XGC *contexts;
Xpoints_t *points;
Xint mincolor, maxcolor;
X{
X    static int color;
X
X    for (color = mincolor; color < maxcolor; ++color)
X        if (points->npoints[color]) {
X            XDrawPoints(display, pixmap, contexts[color], points->data[color], 
X                    points->npoints[color], CoordModeOrigin);
X            points->npoints[color] = 0;
X        }
X}
X
Xvoid
XFlushBuffer(display, window, pixmap, contexts, points, mincolor, maxcolor)
XDisplay *display;
XWindow window;
XPixmap pixmap;
XGC *contexts;
Xpoints_t *points;
Xint mincolor, maxcolor;
X{
X    static int color;
X
X    for (color = mincolor; color < maxcolor; ++color)
X        if (points->npoints[color]) {
X            XDrawPoints(display, window, contexts[color], points->data[color], 
X                    points->npoints[color], CoordModeOrigin);
X            XDrawPoints(display, pixmap, contexts[color], points->data[color], 
X                    points->npoints[color], CoordModeOrigin);
X            points->npoints[color] = 0;
X        }
X}
END_OF_FILE
  if test 3470 -ne `wc -c <'lyap/lib/buffer.c'`; then
    echo shar: \"'lyap/lib/buffer.c'\" unpacked with wrong size!
  fi
  # end of 'lyap/lib/buffer.c'
fi
if test -f 'lyap/lib/init_color.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lyap/lib/init_color.c'\"
else
  echo shar: Extracting \"'lyap/lib/init_color.c'\" \(13721 characters\)
  sed "s/^X//" >'lyap/lib/init_color.c' <<'END_OF_FILE'
X/*************************************************************************
X *                                                                       *
X *  Copyright (c) 1992, 1993 Ronald Joe Record                           *
X *                                                                       *
X *  All rights reserved. No part of this program or publication may be   *
X *  reproduced, transmitted, transcribed, stored in a retrieval system,  *
X *  or translated into any language or computer language, in any form or *
X *  by any means, electronic, mechanical, magnetic, optical, chemical,   *
X *  biological, or otherwise, without the prior written permission of:   *
X *                                                                       *
X *      Ronald Joe Record (408) 458-3718                                 *
X *      212 Owen St., Santa Cruz, California 95062 USA                   *
X *                                                                       *
X *************************************************************************/
X
X#include <math.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <X11/Xlib.h>
X#include "libXrr.h"
X
Xint _numdivs = 2;
X
Xvoid
Xinit_color(display, win, cmap, Colors, s_col, min, n_cols, wheel, prog, res, n)
XDisplay *display;
XWindow win;
XColormap cmap;
XXColor *Colors;
Xint s_col, min, n_cols, wheel, n;
Xchar *prog;
Xchar *res;
X{
X    static short i, j, first_time=1;
X    static int colgap, leg, step, numfree;
X	static double d;
X    Colormap def_cmap;
X    int hls[3], rgb[3];
X	static char *mapfile;
X	FILE *map;
X	char buf[255];
X	int a, b, c, c_end;
X    extern void hls2rgb();
X	extern long lrand48();
X
X    def_cmap = DefaultColormap(display, DefaultScreen(display));
X    for (i=0; i<s_col; i++)
X        Colors[i].pixel = i;
X    for (i=s_col; i<n_cols; i++) {
X        Colors[i].pixel = i;
X        Colors[i].flags = DoRed|DoGreen|DoBlue;
X    }
X    XQueryColors(display, def_cmap, Colors, n_cols);
X    colgap = RGB_MAX / n_cols;
X    hls[0] = 50;    /* Hue in low range */
X    hls[2] = 1000;  /* Fully saturated */
X    for (i=s_col; i<min; i++) {
X        hls[1] = 1000L * (i-s_col) / (min - s_col);
X        hls2rgb(hls, rgb);
X        Colors[i].red = rgb[0];
X        Colors[i].green = rgb[1];
X        Colors[i].blue = rgb[2];
X    }
X    numfree = n_cols - min;
X	if (wheel == -2) {	/* black & white palette */
X		hls[1] = 1000;	/* Fully Light */
X		hls[2] = 1000;	/* Fully saturated */
X		for (i=s_col; i<((n_cols-s_col)/2)+s_col; i++) {
X			hls[0] = 3000L;
X			hls2rgb(hls, rgb);
X			Colors[i].red = rgb[0];
X			Colors[i].green = rgb[1];
X			Colors[i].blue = rgb[2];
X		}
X		hls[1] = 0;	/* Fully Dark */
X		hls[2] = 0;
X		for (i=((n_cols-s_col)/2)+s_col; i<n_cols; i++) {
X			hls[0] = 0;
X			hls2rgb(hls, rgb);
X			Colors[i].red = rgb[0];
X			Colors[i].green = rgb[1];
X			Colors[i].blue = rgb[2];
X		}
X	}
X	if (wheel == -1) {	/* white palette */
X		hls[1] = 1000;	/* Fully Light */
X		hls[2] = 1000;	/* Fully saturated */
X		for (i=s_col; i<n_cols; i++) {
X			hls[0] = 3000L;
X			hls2rgb(hls, rgb);
X			Colors[i].red = rgb[0];
X			Colors[i].green = rgb[1];
X			Colors[i].blue = rgb[2];
X		}
X	}
X    else if (wheel == 0) { /* read in cmap from $HOME/.<progname>map */
X		if (first_time) {
X        	mapfile = XGetDefault(display, res, "Mapfile");
X        	if (!mapfile) {
X            	mapfile = strdup(getenv("HOME"));
X            	mapfile = strcat(mapfile, "/.");
X            	mapfile = strcat(mapfile, prog);
X            	mapfile = strdup(strcat(mapfile, "map"));
X        	}
X			first_time = 0;
X		}
X        i = s_col;
X        if ((map = fopen(mapfile, "r")) == NULL)
X            perror(mapfile);
X        else {
X            while(!feof(map) && i <n_cols) {
X                fgets(buf,sizeof buf,map);
X                if(sscanf(buf,"%d %d %d",&a,&b,&c) == 3) {
X                    Colors[i].red = a * 256;
X                    Colors[i].green = b * 256;
X                    Colors[i].blue = c * 256;
X                    i++;
X                }
X            }
X            c_end = i;
X            while (i<n_cols) {
X                Colors[i].red = Colors[i - c_end].red;
X                Colors[i].green = Colors[i - c_end].green;
X                Colors[i].blue = Colors[i - c_end].blue;
X                i++;
X            }
X        }
X        fclose(map);
X    }
X    if (wheel == 1) {
X        colgap = 2*RGB_MAX/(n_cols - ((n_cols + min)/2));
X        for (i=min; i<min+(numfree/2); i++) {
X            Colors[i].blue = 0;
X            Colors[i].green=((i+((n_cols + min)/2))*colgap);
X            Colors[i].red=((i+((n_cols + min)/2))*colgap);
X        }
X        for (i=min+(numfree/2); i<n_cols; i++) {
X            Colors[i].blue = 0;
X            Colors[i].green=(((n_cols-i)+((n_cols + min)/2))*colgap);
X            Colors[i].red=(((n_cols-i)+((n_cols + min)/2))*colgap);
X        }
X    }
X    else if (wheel == 2) {
X        hls[0] = 800;    /* Hue in mid range */
X        hls[2] = 1000;    /* Fully saturated */
X        for (i=s_col; i<min; i++) {
X            hls[1]=1000L*(i-s_col) / (min - s_col);
X            hls2rgb(hls, rgb);
X            Colors[i].red = rgb[0];
X            Colors[i].green = rgb[1];
X            Colors[i].blue = rgb[2];
X        }
X        for (i=min; i<min+(numfree/2); i++) {
X            Colors[i].blue = RGB_MAX;
X            Colors[i].green = 0;
X            Colors[i].red=(i*2*RGB_MAX/n_cols);
X        }
X        for (i=min+(numfree/2); i<n_cols; i++) {
X            Colors[i].blue = RGB_MAX;
X            Colors[i].green = 0;
X            Colors[i].red=((n_cols - i)*2*RGB_MAX/n_cols);
X        }
X    }
X    else if (wheel == 3) {
X        hls[0] = 800;    /* Hue in mid range */
X        hls[2] = 1000;    /* Fully saturated */
X        for (i=s_col; i<min; i++) {
X            hls[1]=1000L*(i-s_col) / (min - s_col);
X            hls2rgb(hls, rgb);
X            Colors[i].red = rgb[0];
X            Colors[i].green = rgb[1];
X            Colors[i].blue = rgb[2];
X        }
X        colgap = 4*RGB_MAX/n_cols;
X        for (i=min; i<min+(numfree/4); i++) {
X            Colors[i].blue = RGB_MAX;
X            Colors[i].green = 0;
X            Colors[i].red=(i*colgap);
X        }
X        for (i=min+(numfree/4);i<min+(numfree/2);i++) {
X            Colors[i].red = RGB_MAX;
X            Colors[i].green = 0;
X            Colors[i].blue=(min+(numfree/2) - i) * colgap;
X        }
X        for(i=min+(numfree/2);i<min+(0.75*numfree);i++){
X            Colors[i].red = RGB_MAX;
X            Colors[i].blue=(i * colgap);
X            Colors[i].green = 0;
X        }
X        for (i=min+(0.75*numfree); i<n_cols; i++) {
X            Colors[i].blue = RGB_MAX;
X            Colors[i].green = 0;
X            Colors[i].red=(n_cols-i)*colgap;
X        }
X    }
X    else if (wheel == 4) {
X        hls[0] = 800;    /* Hue in mid range */
X        hls[2] = 1000;    /* Fully saturated */
X        for (i=s_col; i<min; i++) {
X            hls[1] = 1000L * (i-s_col) / (min - s_col);
X            hls2rgb(hls, rgb);
X            Colors[i].red = rgb[0];
X            Colors[i].green = rgb[1];
X            Colors[i].blue = rgb[2];
X        }
X        colgap = wheel * RGB_MAX / n_cols;
X        for (i=min; i<(n_cols/wheel); i++) {
X            Colors[i].blue = RGB_MAX;
X            Colors[i].green = 0;
X            Colors[i].red=(i*colgap);
X        }
X        for (i=(n_cols/wheel); i<(2*n_cols/wheel); i++) {
X            Colors[i].red = RGB_MAX;
X            Colors[i].green = 0;
X            Colors[i].blue=((2*n_cols/wheel) - i) * colgap;
X        }
X        for (i=(2*n_cols/wheel); i<n_cols; i++) {
X            Colors[i].red = RGB_MAX;
X            Colors[i].green=(i - (2*n_cols/wheel)) * colgap;
X            Colors[i].blue = 0;
X        }
X    }
X    else if (wheel == 5) {
X        hls[1] = 700;    /* Lightness in midrange */
X        hls[2] = 1000;    /* Fully saturated */
X        for (i=min; i<n_cols; i++) {
X            hls[0] = 3600L * i / n_cols;
X            hls2rgb(hls, rgb);
X            Colors[i].red = rgb[0];
X            Colors[i].green = rgb[1];
X            Colors[i].blue = rgb[2];
X        }
X        for (i=min; i<n_cols; i+=((n_cols-min)/10)) {
X            hls[0] = 3600L * i / n_cols;
X            hls2rgb(hls, rgb);
X            Colors[i].red = rgb[0] / 2;
X            Colors[i].green = rgb[1] / 2;
X            Colors[i].blue = rgb[2] / 2;
X        }
X    }
X    else if (wheel == 6) {
X        hls[0] = 800;    /* Hue in mid range */
X        hls[2] = 1000;    /* Fully saturated */
X        for (i=s_col; i<min; i++) {
X            hls[1] = 1000L * (i-s_col) / (min - s_col);
X            hls2rgb(hls, rgb);
X            Colors[i].red = rgb[0];
X            Colors[i].green = rgb[1];
X            Colors[i].blue = rgb[2];
X        }
X        step = numfree / 3;
X        leg = step+min;
X        for (i = min; i < leg; ++i) {
X            Colors[i].pixel = i;
X            Colors[i].red = fabs(65535 - (double)i / step * 65535.0);
X            Colors[i].blue = (double)i / step * 65535.0;
X            Colors[i].green = 0;
X            Colors[i].flags = DoRed | DoGreen | DoBlue;
X        }
X        for (j = 0, i = leg, leg += step; i < leg; ++i, ++j) {
X            Colors[i].pixel = i;
X            Colors[i].red = (double)j / step * 65535.0;
X            Colors[i].blue = 65535;
X            Colors[i].green = Colors[i].red;
X            Colors[i].flags = DoRed | DoGreen | DoBlue;
X        }
X        for (j = 0, i = leg, leg += step; i < leg; ++i, ++j) {
X            Colors[i].pixel = i;
X            Colors[i].red = 65535;
X            Colors[i].blue = fabs(65535 - (double)j / step * 65535.0);
X            Colors[i].green = Colors[i].blue;
X            Colors[i].flags = DoRed | DoGreen | DoBlue;
X        }
X    }
X    else if (wheel == 7) {    /* random palette */
X        hls[1] = 500;    /* Lightness in midrange */
X        hls[2] = 1000;    /* Fully saturated */
X        for (i=min; i<n_cols; i++) {
X            hls[0] = 3600L * (lrand48() % n_cols) / n_cols;
X            hls2rgb(hls, rgb);
X            Colors[i].red = rgb[0];
X            Colors[i].green = rgb[1];
X            Colors[i].blue = rgb[2];
X        }
X    }
X	/* wheel=8 indicates the default color map which is already queried */
X	else if (wheel == 9) {	/* red, green, blue for 3 basins */
X		hls[0] = 60;   /* hue at low end */
X		hls[2] = 1000;	/* Fully saturated */
X		for (i=s_col; i<((n_cols-s_col)/3)+s_col; i++) {
X			hls[1] = 800L * i / (((n_cols-s_col)/3)+s_col);
X			hls2rgb(hls, rgb);
X			Colors[i].red = rgb[0];
X			Colors[i].green = rgb[1];
X			Colors[i].blue = rgb[2];
X		}
X		hls[0] = 800;   /* hue in middle */
X		for (i=((n_cols-s_col)/3)+s_col;i<(2*(n_cols-s_col)/3)+s_col;i++) {
X			hls[1] = 800L * i / ((2*(n_cols-s_col)/3)+s_col);
X			hls2rgb(hls, rgb);
X			Colors[i].red = rgb[0];
X			Colors[i].green = rgb[1];
X			Colors[i].blue = rgb[2];
X		}
X		hls[0] = 1600;   /* hue in upper range */
X		for (i=(2*(n_cols-s_col)/3)+s_col; i<n_cols; i++) {
X			hls[1] = 800L * i / n_cols;
X			hls2rgb(hls, rgb);
X			Colors[i].red = rgb[0];
X			Colors[i].green = rgb[1];
X			Colors[i].blue = rgb[2];
X		}
X	}
X	else if (wheel == 10) {	/* palette of several rainbows */
X		hls[1] = 500;	/* Lightness in midrange */
X		hls[2] = 1000;	/* Fully saturated */
X		for (i=s_col; i<n_cols; i++) {
X			hls[0] = 3000L*((i-s_col)%((n_cols-s_col)/_numdivs)) 
X					/ ((n_cols-s_col)/_numdivs);
X			hls2rgb(hls, rgb);
X			Colors[i].red = rgb[0];
X			Colors[i].green = rgb[1];
X			Colors[i].blue = rgb[2];
X		}
X	}
X	else if (wheel == 11) {	/* reverse rainbow palette */
X		hls[1] = 500;	/* Lightness in midrange */
X		hls[2] = 1000;	/* Fully saturated */
X		for (i=s_col; i<n_cols; i++) {
X			hls[0] = 3000L * (i - s_col) / (n_cols - s_col);
X			hls2rgb(hls, rgb);
X			Colors[i].red = rgb[0];
X			Colors[i].green = rgb[1];
X			Colors[i].blue = rgb[2];
X		}
X	}
X	else if (wheel == 12) {	/* green colormap */
X		hls[0] = 1200;	/* Green Hue */
X		hls[2] = 1000;	/* Fully saturated */
X		for (i=s_col; i<n_cols; i++) {
X			hls[1] = (800L * (n_cols - i) / (n_cols - s_col)) + 100L;
X			hls2rgb(hls, rgb);
X			Colors[i].red = rgb[0];
X			Colors[i].green = rgb[1];
X			Colors[i].blue = rgb[2];
X		}
X	}
X	else if (wheel == 13) {	/* green "tent" shaped colormap */
X		colgap = 2*RGB_MAX/(n_cols - ((n_cols + min)/2));
X		for (i=s_col; i<s_col+((n_cols - s_col)/2); i++) {
X			Colors[i].blue = 0;
X			Colors[i].green=((i+((n_cols + min)/2))*colgap);
X			Colors[i].red=((i+((n_cols + min)/2))*colgap);
X		}
X		for (i=s_col+((n_cols - s_col)/2); i<n_cols; i++) {
X			Colors[i].blue = 0;
X			Colors[i].green=(((n_cols-i)+((n_cols + min)/2))*colgap);
X			Colors[i].red=(((n_cols-i)+((n_cols + min)/2))*colgap);
X		}
X	}
X	else if (wheel == 14) {	/* red, green, blue for n basins */
X		hls[2] = 1000L;
X		if (n) {
X			d = (double)(n_cols - s_col)/(double)n;
X			for (j=0; j<n; j++) {
X				hls[0] = (j*2500L/n)+250L; /* hue */
X				for (i=s_col+(j*d); i<((j+1)*d)+s_col; i++) {
X					if (i >= n_cols)
X						break;
X					hls[1] = 250L + (500L * (double)(i-s_col-(j*d)) / d);
X					hls2rgb(hls, rgb);
X					Colors[i].red = rgb[0];
X					Colors[i].green = rgb[1];
X					Colors[i].blue = rgb[2];
X				}
X			}
X		}
X		else {
X			hls[0] = 0L; /* hue */
X			for (i=s_col; i<n_cols; i++) {
X				hls[1] = 100L + (800L * (double)(i-s_col) / (n_cols - s_col));
X				hls2rgb(hls, rgb);
X				Colors[i].red = rgb[0];
X				Colors[i].green = rgb[1];
X				Colors[i].blue = rgb[2];
X			}
X		}
X	}
X    else if (wheel == 15) {    /* rainbow palette */
X        hls[1] = 500;    /* Lightness in midrange */
X        hls[2] = 1000;    /* Fully saturated */
X        for (i=s_col; i<n_cols; i++) {
X            hls[0] = 3000L * (i - s_col) / (n_cols - s_col);
X            hls2rgb(hls, rgb);
X            Colors[i].red = rgb[0];
X            Colors[i].green = rgb[1];
X            Colors[i].blue = rgb[2];
X        }
X    }
X    XStoreColors(display, cmap, Colors, n_cols);
X	/* install new color map */
X	XSetWindowColormap(display, win, cmap);
X}
END_OF_FILE
  if test 13721 -ne `wc -c <'lyap/lib/init_color.c'`; then
    echo shar: \"'lyap/lib/init_color.c'\" unpacked with wrong size!
  fi
  # end of 'lyap/lib/init_color.c'
fi
if test -f 'lyap/lib/spin.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lyap/lib/spin.c'\"
else
  echo shar: Extracting \"'lyap/lib/spin.c'\" \(3849 characters\)
  sed "s/^X//" >'lyap/lib/spin.c' <<'END_OF_FILE'
X/*************************************************************************
X *                                                                       *
X *  Copyright (c) 1992, 1993 Ronald Joe Record                           *
X *                                                                       *
X *  All rights reserved. No part of this program or publication may be   *
X *  reproduced, transmitted, transcribed, stored in a retrieval system,  *
X *  or translated into any language or computer language, in any form or *
X *  by any means, electronic, mechanical, magnetic, optical, chemical,   *
X *  biological, or otherwise, without the prior written permission of:   *
X *                                                                       *
X *      Ronald Joe Record (408) 458-3718                                 *
X *      212 Owen St., Santa Cruz, California 95062 USA                   *
X *                                                                       *
X *************************************************************************/
X
X#include <X11/Xlib.h>
X
X#ifdef USE_DELAY
X
X#include <signal.h>
X#include <sys/time.h>
X
Xstatic int timerdone;
X
Xstatic void onalarm() {
X	timerdone = 1;
X}
X
X/*******/
Xvoid Timer(n)   /* waits for 'n' milliseconds (from xv-2.21 source) */
X int  n;
X/*******/
X{
X  long usec;
X#ifdef HAS_ITIMER
X  struct itimerval it;
X#endif
X
X  if (!n) return;
X
X  usec = (long) n * 1000;
X  
X#ifdef HAS_ITIMER
X  memset(&it, 0, sizeof(it));
X  if (usec>=1000000L) {  /* more than 1 second */
X    it.it_value.tv_sec = usec / 1000000L;
X    usec %= 1000000L;
X  }
X
X  it.it_value.tv_usec = usec;
X#endif
X  timerdone=0;
X  signal(SIGALRM,onalarm);
X#ifdef HAS_ITIMER
X  setitimer(ITIMER_REAL, &it, (struct itimerval *)0);
X  while (1) {
X/*    sigblock(sigmask(SIGALRM));  note:  have to block, so that ALRM */
X    if (timerdone) break;        /* doesn't occur between 'if (timerdone)' */
X    else sigpause(0);            /* and calling sigpause(0) */
X  }
X
X/*  sigblock(0);                    turn ALRM blocking off */
X  signal(SIGALRM,SIG_DFL);
X#else
X  nap((long)n);
X#endif
X}
X
X#endif /*USE_DELAY */
X
Xvoid
XSpin(display, colormap, colors, start_color, num_colors, delay, dir)
XDisplay *display;
XColormap colormap;
XXColor *colors;
Xint start_color, num_colors;
Xshort dir, delay;
X{
X    static short i;
X    static long tmpxcolor;
X
X    while (!XPending(display)) {
X        if (dir) {
X            tmpxcolor = colors[start_color].pixel;
X            for (i=start_color;i<num_colors-1;i++)
X                colors[i].pixel = colors[i+1].pixel;
X            colors[num_colors-1].pixel = tmpxcolor;
X        }
X        else {
X            tmpxcolor = colors[num_colors-1].pixel;
X            for (i=num_colors-1;i>start_color;i--)
X                colors[i].pixel = colors[i-1].pixel;
X            colors[start_color].pixel = tmpxcolor;
X        }
X        XStoreColors(display, colormap, colors, num_colors);
X#ifdef USE_DELAY
X	Timer(delay);
X#endif
X    }
X}
X
Xvoid
XDemoSpin(display, colormap, colors, start_color, num_colors, delay, factor)
XDisplay *display;
XColormap colormap;
XXColor *colors;
Xint start_color, num_colors;
Xshort delay, factor;
X{
X    static short i, j;
X    long tmpxcolor;
X
X    for (j=0;j<factor*num_colors;j++) {
X        tmpxcolor = colors[start_color].pixel;
X        for (i=start_color;i<num_colors-1;i++)
X            colors[i].pixel = colors[i+1].pixel;
X        colors[num_colors-1].pixel = tmpxcolor;
X        XStoreColors(display, colormap, colors, num_colors);
X#ifdef USE_DELAY
X	Timer(delay);
X#endif
X    }
X    for (j=0;j<factor*num_colors;j++) {
X        tmpxcolor = colors[num_colors-1].pixel;
X        for (i=num_colors-1;i>start_color;i--)
X            colors[i].pixel = colors[i-1].pixel;
X        colors[start_color].pixel = tmpxcolor;
X        XStoreColors(display, colormap, colors, num_colors);
X#ifdef USE_DELAY
X	Timer(delay);
X#endif
X    }
X}
END_OF_FILE
  if test 3849 -ne `wc -c <'lyap/lib/spin.c'`; then
    echo shar: \"'lyap/lib/spin.c'\" unpacked with wrong size!
  fi
  # end of 'lyap/lib/spin.c'
fi
if test -f 'lyap/lyap.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lyap/lyap.h'\"
else
  echo shar: Extracting \"'lyap/lyap.h'\" \(5377 characters\)
  sed "s/^X//" >'lyap/lyap.h' <<'END_OF_FILE'
X/*
X *	@(#) lyap.h 9.4 93/08/18
X */
X/*************************************************************************
X *                                                                       *
X *  Copyright (c) 1992, 1993 Ronald Joe Record                           *
X *                                                                       *
X *  All rights reserved. No part of this program or publication may be   *
X *  reproduced, transmitted, transcribed, stored in a retrieval system,  *
X *  or translated into any language or computer language, in any form or *
X *  by any means, electronic, mechanical, magnetic, optical, chemical,   *
X *  biological, or otherwise, without the prior written permission of:   *
X *                                                                       *
X *      Ronald Joe Record (408) 458-3718                                 *
X *      212 Owen St., Santa Cruz, California 95062 USA                   *
X *                                                                       *
X *************************************************************************/
X
X/*
X *	Written by Ron Record (rr@sco.com) 03 Sep 1991.
X */
X
Xstatic char *lyap_h_id = "@(#) lyap.h 9.4 93/08/18";
X
X#include "patchlevel.h"
X#include "libXrr.h"
X#include <assert.h>
X#include <math.h>
X#include <memory.h>
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <values.h>
X#include <X11/Xlib.h> 
X#include <X11/StringDefs.h> 
X#include <X11/keysym.h> 
X#include <X11/cursorfont.h> 
X#include <X11/Xutil.h>
X#include <X11/Xatom.h>
X
X#define ABS(a)	(((a)<0) ? (0-(a)) : (a) )
X#define Min(x,y) ((x < y)?x:y)
X#define Max(x,y) ((x > y)?x:y)
X
X/* Useful mathematical constants that should have been defined in math.h 
X * M_LOG2E	- log2(e)
X * M_LN2        - ln(2)
X * M_PI		- pi
X */
X#ifndef M_LOG2E
X#define M_LOG2E	1.4426950408889634074
X#endif
X#ifndef M_PI
X#define M_PI	3.14159265358979323846
X#endif
X#ifndef M_LN2
X#define M_LN2      6.9314718055994530942E-1 /*Hex  2^-1 * 1.62E42FEFA39EF */
X#endif
X
X/* Useful machine-dependent values that should have been defined in values.h
X * LN_MAXDOUBLE - the natural log of the largest double  -- log(MAXDOUBLE)
X * LN_MINDOUBLE - the natural log of the smallest double -- log(MINDOUBLE)
X */
X#ifndef LN_MINDOUBLE
X#define LN_MINDOUBLE (M_LN2 * (DMINEXP - 1))
X#endif
X#ifndef LN_MAXDOUBLE
X#define LN_MAXDOUBLE (M_LN2 * DMAXEXP)
X#endif
X
X#ifndef TRUE
X#define TRUE 1
X#define FALSE 0
X#endif
X
X#define MAXFRAMES 2
X
Xint maxcolor=256, startcolor=17, color_offset=96, mincolindex=33;
Xint dwell=100, settle=50;
Xint width=256, height=256, xposition=-1, yposition=-1;
Xshort delay=0;
Xint bottom, screen;
XDisplay*	dpy;
Xchar*		displayname = 0;
XFILE *infile;
X
Xextern double log();
Xextern double fabs();
Xextern long time();
Xextern int optind;
Xextern char *optarg;
X
Xunsigned long foreground, background;
X
XWindow canvas;
X
Xvoid     resize();
Xvoid     redisplay();
Xvoid     quit();
Xvoid     Spin();
Xvoid     start_iterate();
Xvoid     stop_iterate();
Xvoid	 show_defaults();
Xvoid	 StartRubberBand();
Xvoid	 TrackRubberBand();
Xvoid	 EndRubberBand();
Xvoid	 CreateXorGC();
Xvoid	 InitBuffer();
Xvoid	 BufferPoint();
Xvoid	 FlushBuffer();
X
Xtypedef struct {
X	int x, y;
X} xy_t;
X
Xtypedef struct {
X	int start_x, start_y;
X	int last_x, last_y;
X	} rubber_band_data_t;
X
Xtypedef struct {
X	Cursor band_cursor;
X	double p_min, p_max, q_min, q_max;
X	rubber_band_data_t rubber_band;
X	} image_data_t;
X
Xpoints_t Points; /* typedef in ../lib/libXrr.h */
Ximage_data_t rubber_data;
X
XGC Data_GC[MAXCOLOR], RubberGC;
X
X#define MAXINDEX 64
X#define FUNCMAXINDEX 16
X#define NUMMAPS 5
X
Xtypedef double (*PFD)();
X
Xdouble logistic(), circle(), leftlog(), rightlog(), doublelog();
Xdouble dlogistic(), dcircle(), dleftlog(), drightlog(), ddoublelog();
XPFD map, deriv;
XPFD Maps[NUMMAPS] = { logistic, circle, leftlog, rightlog, doublelog };
XPFD Derivs[NUMMAPS] = { dlogistic, dcircle, dleftlog, drightlog, ddoublelog };
X
Xint aflag=0, bflag=0, wflag=0, hflag=0, Rflag=0;
Xdouble pmins[NUMMAPS] = { 2.0, 0.0, 0.0, 0.0, 0.0 };
Xdouble pmaxs[NUMMAPS] = { 4.0, 1.0, 6.75, 6.75, 16.0 };
Xdouble amins[NUMMAPS] = { 2.0, 0.0, 0.0, 0.0, 0.0 };
Xdouble aranges[NUMMAPS] = { 2.0, 1.0, 6.75, 6.75, 16.0 };
Xdouble bmins[NUMMAPS] = { 2.0, 0.0, 0.0, 0.0, 0.0 };
Xdouble branges[NUMMAPS] = { 2.0, 1.0, 6.75, 6.75, 16.0 };
X
Xint   forcing[MAXINDEX] = { 0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
X			0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
X			0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1 };
Xint   Forcing[FUNCMAXINDEX] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
X
Xint   maxindex = MAXINDEX;
Xint   funcmaxindex = FUNCMAXINDEX;
Xdouble	min_a=2.0, min_b=2.0, a_range=2.0, b_range=2.0, minlyap=1.0;
Xdouble  max_a=4.0, max_b=4.0;
Xdouble  start_x=0.5, lyapunov, a_inc, b_inc, a, b;
Xint	numcolors=16, numfreecols, displayplanes, lowrange;
Xxy_t	point, velocity;
XPixmap  pixmap;
XColormap cmap;
XXColor	Colors[MAXCOLOR];
Xdouble  *exponents[MAXFRAMES];
Xdouble  a_minimums[MAXFRAMES], b_minimums[MAXFRAMES];
Xdouble  a_maximums[MAXFRAMES], b_maximums[MAXFRAMES];
Xdouble  minexp, maxexp, prob=0.5;
Xint     expind[MAXFRAMES]={0}, resized[MAXFRAMES]={0};
Xint	numwheels=MAXWHEELS, force=0, Force=0, negative=1;
Xint     nostart=1, stripe_interval=7;
Xint	save=1, show=0, useprod=1, savefile=0, restfile=0, storefile=0;
Xint	maxframe=0, frame=0, dorecalc=0, mapindex=0, run=1, demo=0;
Xchar	*outname="lyap.ppm";
Xchar	*inname="lyap.sav";
Xchar	*savname="lyap.sav";
END_OF_FILE
  if test 5377 -ne `wc -c <'lyap/lyap.h'`; then
    echo shar: \"'lyap/lyap.h'\" unpacked with wrong size!
  fi
  # end of 'lyap/lyap.h'
fi
if test -f 'lyap/lyap.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lyap/lyap.man'\"
else
  echo shar: Extracting \"'lyap/lyap.man'\" \(7420 characters\)
  sed "s/^X//" >'lyap/lyap.man' <<'END_OF_FILE'
X.\"	@(#) lyap.man 9.2 93/08/23 SCOINC
X.\"
X.TH LYAP LOCAL
X.SH NAME
Xlyap \- display an array of Lyapunov exponents graphically
X.SH SYNOPSIS
X.in +8n
X.ti -8n
X\fIlyap\fR
X[-BLps][-W width][-H height][-o filename][-a 
X\fIn\fR ]
X[-b 
X\fIn\fR ]
X[-w 
X\fIn\fR ]
X[-h 
X\fIn\fR ]
X[-i xstart]
X[-M 
X\fIn\fR ]
X[-R 
X\fIp\fR ]
X[-S 
X\fIn\fR ]
X[-D 
X\fIn\fR ]
X[-F string][-f string][-r 
X\fIn\fR ]
X[-O 
X\fIn\fR ]
X[-C 
X\fIn\fR ]
X[-c 
X\fIn\fR ]
X[-m 
X\fIn\fR ]
X[-x xpos]
X[-y ypos]
X.in -8n
X.SH DESCRIPTION
X\fIlyap\fR
Xgenerates and graphically displays an array of Lyapunov exponents for a 
Xvariety of iterated periodically forced non-linear maps of the unit interval.
X.SH OPTIONS
X.TP 8
X-C \fIn\fP
XSpecifies the minimum color index to be used for negative exponents
X.TP
X-D \fIn\fP
XSpecifies the "dwell" or number of iterations over which to average in order
Xto calculate the Lyapunov exponent. Default is 400.
X.TP
X-H \fIn\fP
XSpecifies the height of the window. Default is 256.
X.TP
X-L 
XIndicates use log(x) + log(y) rather than log(xy).
X.TP
X-M \fIr\fP
XSpecifies the real value to compare exponent values to for indexing into
Xa color wheel. The default value is 1.0.
X.TP
X-O \fIn\fP
XSpecifies the minimum color index to be used for positive exponents
X.TP
X-R \fIp\fP
XSpecifies pseudo-random forcing with probability \fIp\fP of using parameter
Xvalue 'a'.
X.TP
X-S \fIn\fP
XSpecifies the "settle" or number of iterations prior to the beginning of
Xthe calculation of the Lyapunov exponent. Default is 200.
X.TP
X-W \fIn\fP
XSpecifies the width of the window. Default is 256.
X.TP
X-a \fIr\fP
XSpecifies the real value to use as the minimum parameter value of the 
Xhorizontal axis. Default is 3.0 for the logistic map.
X.TP
X-b \fIn\fP
XSpecifies the real value to use as the minimum parameter value of the 
Xvertical axis. Default is 3.0 for the logistic map.
X.TP
X-c \fIn\fP
XSelects one of six different color wheels to use. The default color
Xwheel is a rainbow palette.
X.TP
X-F \fI10101010\fP
XSpecifies the "Function" forcing function to use. The example above would 
Xalternate between iterating the circle and logistic maps. An argument of
X"-F 2323" would alternate between left and right logistic maps. The default
Xis to only use the single specified map (see the description of -m).
X.TP
X-f \fIabbabaab\fP
XSpecifies the forcing function to use. The default is to alternate between
Xthe "a" parameter and the "b" parameter.
X.TP
X-h \fIr\fP
XSpecifies the real value to be used as the range over which the vertical
Xparameter values vary. The default is 1.0.
X.TP
X-i \fIr\fP
XSpecifies the real value of the initial condition to use. Default is 0.05.
X.TP
X-m \fIn\fP
XSelects between available non-linear maps of the unit interval. A value of
X0 specifies the logistic map. A value of 1, the circle map. A value of 2,
Xthe left-logistic. A value of 3, the right-logistic. A value of 4, the
Xdouble-logistic. The default is 0, the logistic map.
X.TP
X-o \fIfilename\fP
XSpecifies the output filename to be used. If the -o option is given, this
Xfile will automatically be written out at the completion of the drawing.
XIf it is not specified, a default filename of lyap.out is used and only
Xwritten if the 'F' key is pressed during a run. The format of the
Xoutput file is PPM for color and PGM for monochrome. The parameters used to
Xcalculate the picture are included as comments at the beginning of the file.
X.TP
X-p
XSwitches color indices for negative and positive exponents. Generally,
Xcauses negative exponents to be displayed in more detail while darkening
Xand narrowing the color range for positive exponents. This can be toggled
Xduring runtime by pressing the 'p' key.
X.TP
X-r \fIn\fP
XSpecifies the maximum rgb value to be used. Default is 35000.
X.TP
X-s \fIfilename\fP
XSpecifies the output filename to be used when saving for a later restart. 
XIf the -s option is given, this file will automatically be written out at 
Xthe completion of the drawing. If it is not specified, a default filename 
Xof lyap.sav is used and only written if the 'f' key is pressed during a run. 
XThe color indices are saved for picture restoration. The parameters and
Xother variables necessary to resume calculation are stored as well. You
Xcan therefore use the -s option or 'f' key to temporarily save the program's 
Xstate and resume at a later time.
X.TP
X-u
XProduces a usage message.
X.TP
X-v 
XPrints out the various values to be used and exits.
X.TP
X-w \fIr\fP
XSpecifies the real value to be used as the range over which the horizontal
Xparameter values vary. The default is 1.0.
X.TP
X-x \fIn\fP
XSpecifies the x screen coordinate of the window (default is 256).
X.TP
X-y \fIn\fP
XSpecifies the y screen coordinate of the window (default is 256).
X.sp 2
X.SH NOTES
X.sp
XDuring display, pressing any mouse button allows you to select the area to
Xbe investigated with the mouse. The upper left hand corner of the desired
Xarea is the location of the cursor when the button is pressed. The lower
Xright hand corner is specified by the cursor when the button is released.
X.sp 2
XUse of the keys 
X\fIdDeEfFkKjJmnrRsSuUwWxXqQ\fP
Xindicates:
X.sp
X.ti 10
X(<) Halve dwell value.
X.ti 10
X(>) Double dwell value.
X.ti 10
X([) Halve settle value.
X.ti 10
X(]) Double settle value.
X.ti 10
X(d) Descends the ladder of lyap windows if a ladder has previously been
Xascended via the 'u' or 'U' keys.
X.ti 10
X(D) Flushes the drawing buffer
X.ti 10
X(E or e) Recalculate the indices into the color wheel using a different method
X.ti 10
X(f) Save current screen to lyap format ouput file for later continuation
X.ti 10
X(F) Save current screen to PPM format ouput file for later redisplay
X.ti 10
X(H or h or ?) Display brief help message
X.ti 10
X(i) Decrement the interval between stripes for the striped color map.
X.ti 10
X(I) Increment the interval between stripes for the striped color map.
X.ti 10
X(K) Decrease value exponents are compared against by 0.05.
X.ti 10
X(J) Increase value exponents are compared against by 0.05.
X.ti 10
X(M) Decrease value exponents are compared against by 0.005.
X.ti 10
X(N) Increase value exponents are compared against by 0.005.
X.ti 10
X(m) Increment the map index, changing the map to be iterated.
X.ti 10
X(P or p) Toggle positive/negative exponent display.
X.ti 10
X(r) Redraw the window using previously calculated exponents.
X.ti 10
X(R) Redraw the window using the newly set dwell and/or settle values.
X.ti 10
X(S) Spin the color wheel
X.ti 10
X(s) Halve the length of the spin and spin the color wheel
X.ti 10
X(u) Go up to the window just prior to the most recent zoom.
X.ti 10
X(U) Go all the way up to the original window.
X.ti 10
X(V or v) Display values of various parameters currently in use
X.ti 10
X(W or w) Use next color map.
X.ti 10
X(<ctrl>-W) Use color map in $HOME/.lyapmap
X.ti 10
X(X or x) Clear window
X.ti 10
X(Q or q) quit
X.sp 2
X.SH AUTHOR
X.nf
X        Ronald Joe Record
X     The Santa Cruz Operation 
X          P.O. Box 1900
X       Santa Cruz, CA 95061
X            rr@sco.com
X.fi
X.sp 2
X.SH ACKNOWLEDGEMENTS
X.PP
XThe algorithm was taken from the September 1991 Scientific American article
Xby A. K. Dewdney who gives credit to Mario Markus of the Max Planck Institute
Xfor its creation. Additional information and ideas were gleaned from the
Xdiscussion on alt.fractals involving Stephen Hall, Ed Kubaitis, Dave Platt
Xand Baback Moghaddam. Assistance with colormaps and spinning color wheels
Xand X was gleaned from Hiram Clawson. Rubber banding code was adapted from
Xan existing Mandelbrot program written by Stacey Campbell.
END_OF_FILE
  if test 7420 -ne `wc -c <'lyap/lyap.man'`; then
    echo shar: \"'lyap/lyap.man'\" unpacked with wrong size!
  fi
  # end of 'lyap/lyap.man'
fi
if test -f 'lyap/params/circle-4' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lyap/params/circle-4'\"
else
  echo shar: Extracting \"'lyap/params/circle-4'\" \(56 characters\)
  sed "s/^X//" >'lyap/params/circle-4' <<'END_OF_FILE'
X
Xlyap -f abbb -m 1 -D 400 -S 200 -W 256 -H 256 -M -0.85
END_OF_FILE
  if test 56 -ne `wc -c <'lyap/params/circle-4'`; then
    echo shar: \"'lyap/params/circle-4'\" unpacked with wrong size!
  fi
  # end of 'lyap/params/circle-4'
fi
echo shar: End of archive 2 \(of 3\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
