Newsgroups: comp.sources.x
From: pc@hillside.co.uk (Peter Collinson)
Subject: v21i080:  xcal - A calendar program for X, Part05/08
Message-ID: <1993Dec21.161757.22057@sparky.sterling.com>
X-Md4-Signature: fd5044c4524fe6111cd2009d6138c940
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Hillside Systems, 61 Hillside Avenue, Canterbury, Kent CT2 8HA
Date: Tue, 21 Dec 1993 16:17:57 GMT
Approved: chris@sterling.com

Submitted-by: pc@hillside.co.uk (Peter Collinson)
Posting-number: Volume 21, Issue 80
Archive-name: xcal/part05
Environment: X11
Supersedes: xcal: Volume 12, Issue 101

Xcal is a calendar program. For more details see Part 1 of this posting

Part 5 of 8
--shar starts here--
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 8)."
# Contents:  Makefile.sunos pscal/pscal.script xcalev/xcalev.c
# Wrapped by pc@hillside on Wed Nov 17 11:24:36 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile.sunos' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.sunos'\"
else
echo shar: Extracting \"'Makefile.sunos'\" \(14214 characters\)
sed "s/^X//" >'Makefile.sunos' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.51 89/12/12 12:37:30 jim Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X###########################################################################
X# Makefile generated from "Imake.tmpl" and <Imakefile>
X# $XConsortium: Imake.tmpl,v 1.77 89/12/18 17:01:37 jim Exp $
X#
X# Platform-specific parameters may be set in the appropriate .cf
X# configuration files.  Site-wide parameters may be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor doesn't define any unique symbols, you'll need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make Makefile", "make Makefiles", or "make World").
X#
X# If you absolutely can't get imake to work, you'll need to set the
X# variables at the top of each Makefile as well as the dependencies at the
X# bottom (makedepend will do this automatically).
X#
X
X###########################################################################
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.38 89/12/23 16:10:10 jim Exp $
X# operating system:  SunOS 4.0.3
X
X###########################################################################
X# site-specific configuration parameters - edit site.def to change
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X               RM = rm -f
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0664
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X          DESTDIR =
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS =
X      COMPATFLAGS =
X
X      ALLINCLUDES = $(STD_INCLUDES) $(TOP_INCLUDES) $(INCLUDES) $(EXTRA_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(PROTO_DEFINES) $(DEFINES) $(COMPATFLAGS)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS)
X   LDCOMBINEFLAGS = -X -r
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X###########################################################################
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
X###########################################################################
X# X Window System make variables; this need to be coordinated with rules
X# $XConsortium: Project.tmpl,v 1.63 89/12/18 16:46:44 jim Exp $
X
X          PATHSEP = /
X        USRLIBDIR = $(DESTDIR)/usr/lib
X           BINDIR = $(DESTDIR)/usr/bin/X11
X          INCROOT = $(DESTDIR)/usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = $(DESTDIR)/usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           AWMDIR = $(LIBDIR)/awm
X           TWMDIR = $(LIBDIR)/twm
X           GWMDIR = $(LIBDIR)/gwm
X          MANPATH = $(DESTDIR)/usr/man
X    MANSOURCEPATH = $(MANPATH)/man
X           MANDIR = $(MANSOURCEPATH)n
X        LIBMANDIR = $(MANSOURCEPATH)3
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X
X        SOXLIBREV = 4.2
X          SOXTREV = 4.0
X         SOXAWREV = 4.0
X        SOOLDXREV = 4.0
X         SOXMUREV = 4.0
X        SOXEXTREV = 4.0
X
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X            FONTC = bdftosnf
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier.sh
X
X        CONFIGSRC = $(TOP)/config
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X     MKFONTDIRSRC = $(FONTSRC)/mkfontdir
X     EXTENSIONSRC = $(TOP)/extensions
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X
X        DEPXMULIB =
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB =
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB =
X           XAWLIB = -lXaw
X
X LINTEXTENSIONLIB = $(USRLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(USRLIBDIR)/llib-lX11.ln
X          LINTXMU = $(USRLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(USRLIBDIR)/llib-lXt.ln
X          LINTXAW = $(USRLIBDIR)/llib-lXaw.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X###########################################################################
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.67 89/12/18 17:14:15 jim Exp $
X
X###########################################################################
X# start of Imakefile
X
X        DEFINES = -DLONG_IS_32_BITS -DVER_VEC
X
X          SRCS1 = xcal.c xcal_alarm.c xcal_buts.c xcal_days.c xcal_edit.c \
X		  xcal_help.c xcal_popup.c xcal_strip.c xcal_memo.c strfdate.c version.c
X          OBJS1 = xcal.o xcal_alarm.o xcal_buts.o xcal_days.o xcal_edit.o \
X		  xcal_help.o xcal_popup.o xcal_strip.o xcal_memo.o strfdate.o version.o
X
X       PROGRAMS = derived xcal
X   INSTPGMFLAGS = $(INSTBINFLAGS)
X         BINDIR = /usr/local/bin
X
X OBJS = $(OBJS1) $(OBJS2) $(OBJS3)
X SRCS = $(SRCS1) $(SRCS2) $(SRCS3)
X
Xall:: $(PROGRAMS)
X
Xxcal: $(OBJS1) $(DEPLIBS1)
X	$(RM) $@
X	$(CC) -o $@ $(LDOPTIONS) $(OBJS1)  $(XAWLIB) $(XMULIB) $(XTOOLLIB) $(XLIB) $(LDLIBS)  -lm $(EXTRA_LOAD_FLAGS)
X
Xinstall:: xcal
X	$(INSTALL) -c $(INSTPGMFLAGS)   xcal $(BINDIR)
X
Xinstall.man:: xcal.man
X	$(INSTALL) -c $(INSTMANFLAGS) xcal.man $(MANDIR)/xcal.n
X
Xsaber_xcal:
X	#load $(ALLDEFINES) $(SRCS1)  $(XAWLIB) $(XMULIB) $(XTOOLLIB) $(XLIB) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)  -lm
X
Xosaber_xcal:
X	#load $(ALLDEFINES) $(OBJS1)  $(XAWLIB) $(XMULIB) $(XTOOLLIB) $(XLIB) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)  -lm
X
Xdepend::
X	$(DEPEND) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAMS)
X
Xinstall:: XCal.ad
X	$(INSTALL) -c $(INSTAPPFLAGS) XCal.ad $(XAPPLOADDIR)/XCal
X
Xinstall:: XCal.help
X	$(INSTALL) -c $(INSTDATFLAGS) XCal.help  $(XAPPLOADDIR)/XCal.help
X
Xderived:	xcal_help.h xcal_ad.h
X
Xclean::
X	$(RM) xcal_help.h xcal_ad.h
X
Xxcal_help.h:	XCal.help
X	sh C_from_help.sh
X
Xxcal_ad.h:	XCal.ad
X	sh C_from_ad.sh
X
XSUBD=xcalpr xcalev xcal_cal
X
Xall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBD) ;\
X	do \
X	(cd $$i ; echo "making" all "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) 'CDEBUGFLAGS=$(CDEBUGFLAGS)' all); \
X	done
X
Xclean::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBD) ;\
X	do \
X	(cd $$i ; echo "cleaning" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) RM_CMD='$(RM_CMD)' clean); \
X	done
X
Xinstall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBD) ;\
X	do \
X	(cd $$i ; echo "installing" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install); \
X	done
X
Xinstall.man::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBD) ;\
X	do \
X	(cd $$i ; echo "installing man pages" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install.man); \
X	done
X
Xdepend::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBD) ;\
X	do \
X	(cd $$i ; echo "depending" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS)   depend); \
X	done
X
XSUBDIRS = pscal
X
Xall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "making" all "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) 'CDEBUGFLAGS=$(CDEBUGFLAGS)' all); \
X	done
X
Xdepend::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "depending" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS)   depend); \
X	done
X
X###########################################################################
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) \#*
X
XMakefile::
X	-@if [ -f Makefile ]; then \
X	echo "	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak"; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	#load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	#load $(ALLDEFINES) $(OBJS)
X
X###########################################################################
X# rules for building in SUBDIRS - do not edit
X
Xinstall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "installing" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install); \
X	done
X
Xinstall.man::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "installing man pages" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install.man); \
X	done
X
Xclean::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "cleaning" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) RM_CMD='$(RM_CMD)' clean); \
X	done
X
Xtags::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "tagging" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) TAGS='$(TAGS)' tags); \
X	done
X
XMakefiles::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	echo "making Makefiles in $(CURRENT_DIR)/$$i..."; \
X	case "$$i" in \
X	./?*/?*/?*/?*) newtop=../../../../ sub=subsubsubsub;; \
X	./?*/?*/?*) newtop=../../../ sub=subsubsub;; \
X	./?*/?*) newtop=../../ sub=subsub;; \
X	./?*) newtop=../ sub=sub;; \
X	*/?*/?*/?*) newtop=../../../../ sub=subsubsubsub;; \
X	*/?*/?*) newtop=../../../ sub=subsubsub;; \
X	*/?*) newtop=../../ sub=subsub;; \
X	*) newtop=../ sub=sub;; \
X	esac; \
X	case "$(TOP)" in \
X	/?*) newtop= upprefix= ;; \
X	*) upprefix=../ ;; \
X	esac; \
X	$(MAKE) $${sub}dirMakefiles UPPREFIX=$$upprefix NEWTOP=$$newtop \
X	MAKEFILE_SUBDIR=$$i NEW_CURRENT_DIR=$(CURRENT_DIR)/$$i;\
X	done
X
XsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then \
X	echo "	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak"; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then \
X	echo "	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak"; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then \
X	echo "	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak"; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then \
X	echo "	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak"; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
Xincludes::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo including "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS)   includes); \
X	done
X
X###########################################################################
X# dependencies generated by makedepend
X
END_OF_FILE
if test 14214 -ne `wc -c <'Makefile.sunos'`; then
    echo shar: \"'Makefile.sunos'\" unpacked with wrong size!
fi
# end of 'Makefile.sunos'
fi
if test -f 'pscal/pscal.script' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'pscal/pscal.script'\"
else
echo shar: Extracting \"'pscal/pscal.script'\" \(13265 characters\)
sed "s/^X//" >'pscal/pscal.script' <<'END_OF_FILE'
X#!/bin/sh
X#+
X#
X# NAME:
X#	pscal
X#
X# SYNOPSIS:
X#	pscal [-Pprinter] [other printer flags] month year
X#
X# DESCRIPTION:
X#	`Pscal' is a PostScript program to print calendars.
X#
X#	The file $HOME/.holiday is read and used to print short messages
X#	on specified days.  The .holiday file should consist of lines of
X#	the form 
X#		month:day:message string
X#	Messages should be 20 characters or less, with no more than 6
X#	messages per day.  No spaces should appear from the beginning
X#	of a line until after the second colon.
X#	Month and day should be numbers in the obvious ranges.
X#	12/89 - The holiday checking has been loosened up in that the
X#	following takes place:
X#		1. The Shell Variable EFILE is used preferentially
X#		2. Then the file Events in the current directory is used
X#		3. Finally the $HOME/.holiday file is used.
X#	The whole process can be turned off by setting EFILE=/dev/null.
X#
X# OPTIONS:
X#	Any argument whose first character is '-' is passed on to lpr.
X#	The shell variables BANNER, LFOOT, CFOOT, and RFOOT become a
X#	top centered banner, and left, centered, or right justified
X#	footers respectively.  As in:
X#
X#		BANNER="Schedule 1" CFOOT=Preliminary pscal 4 90
X#
X# AUTHOR:
X#	Patrick Wood
X#	Copyright (C) 1987 by Pipeline Associates, Inc.
X#	Permission is granted to modify and distribute this free of charge.
X# 
X# HISTORY:
X#	@Original From: patwood@unirot.UUCP (Patrick Wood)
X#	@Shell stuff added 3/9/87 by King Ables
X#	@Made pretty by tjt 1988
X#	@Holiday and printer flag passing hacks added Dec 1988 
X#	@ by smann@june.cs.washington.edu 
X#	@Used the better looking version with 5 rows of days rather than 6
X#	@ hacked together with holiday and banner/footnotes added
X#	@ by Joe (No Relation) Wood, 12/89, jlw@lzga.ATT.COM
X#	@Fixed "-R" (didn't work at all; now it at least works on 8.5x11)
X#	@Also fixed handling of unrecognized arguments
X#	@ by Jeff Mogul, 1/90, mogul@decwrl.dec.com
X#
X# BUGS:
X#	`Pscal' doesn't work for months before 1753 (weird stuff happened
X#	in September, 1752).
X#
X#	A better format for the dates of holidays would be nice.
X#	An escape to allow holiday messages to be raw PostScript would
X#	also be nice.
X#	The holiday messages should be handled more intelligently (ie,
X#	the messages should be clipped to the day).
X#
X
X# 
X# PostScript program to print calendars.
X# Doesn't deal well with September 1752 or before.
X# 
X
XUSAGE="Usage: pscal [ -Rrt ] [ -F hfont ] [ -f font ] [-d directory] [ month [ year ] ]"
X
XTFONT=Times-Bold
XDFONT=Helvetica-Bold
XEFONT=Times-Roman
X
XCalendar=$HOME/Calendar
X
XROTATE=90
XSCALE="1.0 1.0"
X#	Was 50 -120 - changed to 71 -120 for A4 Use
XTRANSLATE="71 -120"
X
XLPR="lpr"
X
Xwhile test $# != 0
Xdo
X    case $1 in
X	-P) test $# -lt 2 && { echo "$USAGE" 1>&2; exit 1; }
X	    eval ENVAR="$1$2"; shift; shift;;
X	-P*) eval ENVAR=$1; shift;;
X	-F) test $# -lt 2 && { echo "$USAGE" 1>&2; exit 1; }
X	    TFONT="$2"; shift; shift;;
X	-F*) TFONT=`echo $1 | sed -n 1s/-.//p`; shift;;
X	-f) test $# -lt 2 && { echo "$USAGE" 1>&2; exit 1; }
X	    DFONT="$2"; shift; shift;;
X	-f*) DFONT=`echo $1 | sed -n 1s/-.//p`; shift;;
X	-t) LPR=cat; shift;;
X	-r) ROTATE=90; shift;;
X	-R) ROTATE=0; SCALE="0.75 0.75"; TRANSLATE="50 900"; shift;;
X	-d) test $# -lt 2 && { echo "$USAGE" 1>&2; exit 1; }
X	    Calendar="$2"; shift; shift;;
X	--|-) break;;
X	-*) eval ENVAR=\"$ENVAR $1\"; shift;;
X	*) break
X    esac
Xdone
X
Xtest $# -gt 2 && { echo "$USAGE" 1>&2; exit 1; }
X
Xcase $# in
X    0)	set `date`; YEAR=$6; MONTH=$2;;
X    1)	MONTH=$1; set `date`; YEAR=$6;;
X    2)	MONTH=$1 YEAR=$2;;
Xesac
X
XMONTH=`case $MONTH in Jan|jan) echo 1;;Feb|feb) echo 2;;Mar|mar) echo 3;;Apr|apr) echo 4;;
X	May|may) echo 5;;Jun|jun) echo 6;;Jul|jul) echo 7;;Aug|aug) echo 8;;
X	Sep|sep) echo 9;;Oct|oct) echo 10;;Nov|nov) echo 11;;Dec|dec) echo 12;;
X	1|2|3|4|5|6|7|8|9|10|11|12) echo $MONTH;;esac`
X
XMONTHNAME=`sed -n ${MONTH}p <<END-monthlist
XJan
XFeb
XMar
XApr
XMay
XJun
XJul
XAug
XSep
XOct
XNov
XDec
XEND-monthlist`
X
Xtest $YEAR -lt 100 && YEAR=`expr $YEAR + 1900`
X
Xif [ -n "$EFILE" -a -r "$EFILE" ]
Xthen
X	Files=$EFILE
X	monthday=yes
Xelif [ -r Events ]
Xthen
X	Files=Events
X	monthday=yes
Xelif [ -r $HOME/.holiday ]
Xthen
X	Files=$HOME/.holiday
X	monthday=yes
Xelif [ -d $Calendar ]
Xthen
X	cd $Calendar
X	if [ -d xy$YEAR ]
X	then
X		cd xy$YEAR
X	fi
X	list=`echo xc*$MONTHNAME$YEAR`
X	case "$list" in
X	xc\*$MONTHNAME$YEAR)
X			;;
X	*)
X		for file in $list
X		do
X			day=`expr $file : 'xc\([0-9]*\)'`
X			(cat $file;echo) | sed '/^$/d
X					s/^/./' | fmt -25 |
X					 sed -n "7q
X					s/^\.//
X					s/^/$day ( /
X					s/\$/ )/
X					p"
X		done > /tmp/pscal$$
X		holidays=`cat /tmp/pscal$$`
X		rm -f /tmp/pscal$$	
X	esac
Xfi
X
Xcase "$monthday" in
Xyes)
X	holidays=`cat $Files | grep \^$MONTH: | awk -F: '{printf("%s ( %s",$2,$3);\
X		for(i = 4; i <= NF; i++) printf(":%s", $i);printf(")\n"); }'`
Xesac
X
X$LPR $ENVAR <<END-OF-CALENDAR
X%!
X% PostScript program to draw calendar
X% Copyright (C) 1987 by Pipeline Associates, Inc.
X% Permission is granted to modify and distribute this free of charge.
X
X% The number after /month should be set to a number from 1 to 12.
X% The number after /year should be set to the year you want.
X% You can change the title and date fonts, if you want.
X% We figure out the rest.
X% This program won't produce valid calendars before 1800 due to the switch
X% from Julian to Gregorian calendars in September of 1752 wherever English
X% was spoken.
X
X/month $MONTH def
X/year $YEAR def
X/titlefont /$TFONT def
X/dayfont /$DFONT def
X/eventfont /$EFONT def
X/holidays [ $holidays ] def
X/Bannerstring ($BANNER) def
X/Lfootstring ($LFOOT) def
X/Rfootstring ($RFOOT) def
X/Cfootstring ($CFOOT) def
X
X% calendar names - change these if you don't speak english
X% "August", "April" and "February" could stand to be kerned even if you do
X
X/month_names
X[ (January) (February) (March) (April) (May) (June) (July)
X(August) (September) (October) (November) (December) ]
Xdef
X
X/day_names
X[ (Sunday) (Monday) (Tuesday) (Wednesday) (Thursday) (Friday) (Saturday) ]
Xdef
X
X% layout parameters - you can change these, but things may not look nice
X
X/daywidth 100 def
X/dayheight 95 def
X
X/titlefontsize 48 def
X/weekdayfontsize 10 def
X/datefontsize 30 def
X/footfontsize 20 def
X
X/topgridmarg 35 def
X/leftmarg 35 def
X/daytopmarg 10 def
X/dayleftmarg 5 def
X
X% layout constants - don't change these, things probably won't work
X
X/rows 5 def
X/subrows 6 def
X
X% calendar constants - change these if you want a French revolutionary calendar
X
X/days_week 7 def
X
X/days_month [ 31 28 31 30 31 30 31 31 30 31 30 31 ] def
X
X/isleap {				% is this a leap year?
X	year 4 mod 0 eq			% multiple of 4
X	year 100 mod 0 ne 		% not century
X	year 1000 mod 0 eq or and	% unless it's a millenia
X} def
X
X/ndays {				% number of days in this month
X	days_month month 1 sub get
X	month 2 eq			% February
X	isleap and
X	{
X		1 add
X	} if
X} def
X
X/weekday {				% weekday (range 0-6) for integer date
X	days_week mod
X} def
X
X/startday {				% starting day-of-week for this month
X	/off year 2000 sub def		% offset from start of "epoch"
X	off
X	off 4 idiv add			% number of leap years
X	off 100 idiv sub		% number of centuries
X	off 1000 idiv add		% number of millenia
X	6 add weekday days_week add 	% offset from Jan 1 2000
X	/off exch def
X	1 1 month 1 sub {
X		/idx exch def
X		days_month idx 1 sub get
X		idx 2 eq
X		isleap and
X		{
X			1 add
X		} if
X		/off exch off add def
X	} for
X	off weekday			% 0--Sunday, 1--monday, etc.
X} def
X
X/prtevent {		% event-string day prtevent
X			%  print out an event
X	/start startday def
X	/day 2 1 roll def
X	day start add 1 sub 7 mod daywidth mul
X	day start add 1 sub 7 div truncate dayheight neg mul 
X	-5 
X	numevents day start add get -10 mul add
X	numevents
X	day start add 
X	numevents day start add get 1 add
X	put
X	add moveto
X	show
X} def
X
X/drawevents {		% read in a file full of events; print
X			%  the events for this month
X	/numevents
X	[0 0 0 0 0 0 0
X	 0 0 0 0 0 0 0
X	 0 0 0 0 0 0 0
X	 0 0 0 0 0 0 0
X	 0 0 0 0 0 0 0
X	 0 0 0 0 0 0 0] def 
X	 eventfont findfont 9 scalefont setfont
X	 0 2 holidays length 2 sub {
X		dup
X		1 add holidays 2 1 roll get
X		2 1 roll holidays 2 1 roll get
X		prtevent
X	} for
X		
X} def
X
X% ------------------------------------------------------------------------
X
X/prtnum { 3 string cvs show } def
X
X/center {				% center string in given width
X	/width exch def
X	/str exch def width str 
X	stringwidth pop sub 2 div 0 rmoveto str show
X} def
X
X/centernum { exch 3 string cvs exch center } def
X
X/drawgrid {				% draw calendar boxes
X	titlefont findfont weekdayfontsize scalefont setfont
X	currentpoint /y0 exch def /x0 exch def
X	0 1 days_week 1 sub {
X		submonth 0 eq
X		{
X			x0 y0 moveto
X			dup dup daywidth mul 40 rmoveto
X			day_names exch get
X			daywidth center
X		} if
X		x0 y0 moveto
X		daywidth mul topgridmarg rmoveto
X		1.0 setlinewidth
X		submonth 0 eq
X		{
X			/rowsused rows 1 sub def
X		}
X		{
X			/rowsused rows def
X		}
X		ifelse
X		0 1 rowsused {
X			gsave
X			daywidth 0 rlineto 
X			0 dayheight neg rlineto
X			daywidth neg 0 rlineto
X			closepath stroke
X			grestore
X			0 dayheight neg rmoveto
X		} for
X	} for
X} def
X
X/drawnums {				% place day numbers on calendar
X	dayfont findfont datefontsize
X	submonth 0 ne
X	{
X		2.5 mul
X	} if scalefont setfont
X	/start startday def
X	/days ndays def
X	start daywidth mul dayleftmarg add daytopmarg rmoveto
X	submonth 0 ne
X	{
X		dayleftmarg neg dayheight -2 div rmoveto
X	} if
X	1 1 days {
X		/day exch def
X		gsave
X		day start add weekday 0 eq
X		{
X			submonth 0 eq
X			{
X				.7 setgray
X			} if
X		} if
X		day start add weekday 1 eq
X		{
X			submonth 0 eq
X			{
X				.7 setgray
X			} if
X		} if
X		submonth 0 eq
X		{
X			isdouble
X			{
X				day prtdouble
X			}
X			{
X				day prtnum
X			} ifelse
X		}
X		{
X			day daywidth centernum
X		} ifelse
X		grestore
X		day start add weekday 0 eq
X		{
X			currentpoint exch pop dayheight sub 0 exch moveto
X			submonth 0 eq
X			{
X				dayleftmarg 0 rmoveto
X			} if
X		}
X		{
X			daywidth 0 rmoveto
X		} ifelse
X	} for
X} def
X/isdouble {				% overlay today with next/last week?
X	days start add rows days_week mul gt
X	{
X		day start add rows days_week mul gt
X		{
X			true true
X		}
X		{
X			day start add rows 1 sub days_week mul gt
X			day days_week add days le and
X			{
X				false true
X			}
X			{
X				false
X			} ifelse
X		} ifelse
X	}
X	{
X		false
X	} ifelse
X} def
X
X/prtdouble {
X	gsave
X	  dayfont findfont datefontsize 2 mul 3 div scalefont setfont
X	  exch
X	  {
X		(23/) stringwidth pop dayheight rmoveto
X		prtnum
X	  }
X	  {
X		0 datefontsize 5 div rmoveto
X		prtnum
X		0 datefontsize -5 div rmoveto
X		gsave
X		  dayfont findfont datefontsize scalefont setfont
X		  (/) show
X		grestore
X	  } ifelse
X	grestore
X} def
X
X/drawfill {				% place fill squares on calendar
X	/start startday def
X	/days ndays def
X	currentpoint /y0 exch def /x0 exch def
X	submonth 0 eq
X	{
X		usefirst
X		{
X			/fillstart 2 def
X		}
X		{
X			/fillstart 0 def
X		}
X		ifelse
X	}
X	{
X		/fillstart 0 def
X	}
X	ifelse
X	fillstart daywidth mul topgridmarg rmoveto
X	1.0 setlinewidth
X	fillstart 1 start 1 sub {
X		gsave
X		.9 setgray
X		daywidth 0 rlineto 
X		0 dayheight neg rlineto
X		daywidth neg 0 rlineto
X		closepath fill
X		grestore
X		daywidth 0 rmoveto
X	} for
X	x0 y0 moveto
X	submonth 0 ne
X	{
X		/lastday rows 1 add days_week mul def
X		days_week 1 sub daywidth mul -440 rmoveto
X	}
X	{
X		/lastday rows days_week mul 2 sub fillstart add def
X		days_week 3 sub fillstart add daywidth mul
X		-440 dayheight add rmoveto
X	} ifelse
X	lastday -1 ndays start 1 add add
X	{
X		/day exch def
X		gsave
X		.9 setgray
X		daywidth 0 rlineto 
X		0 dayheight neg rlineto
X		daywidth neg 0 rlineto
X		closepath fill
X		grestore
X		day weekday 1 eq
X		{
X			x0 y0 moveto
X			days_week 1 sub daywidth mul -440 dayheight add rmoveto
X		}
X		{
X			daywidth neg 0 rmoveto
X		} ifelse
X	} for
X} def
X
X/usefirst {				% are last two boxes used by days?
X	start ndays add rows days_week mul 3 sub gt
X	start 2 ge and
X	
X} def
X
X/calendar
X{
X	titlefont findfont titlefontsize scalefont setfont
X	0 60 moveto
X	/month_name month_names month 1 sub get def
X	month_name show
X	/yearstring year 10 string cvs def
X	daywidth days_week mul yearstring stringwidth pop sub 60 moveto
X	yearstring show
X
X	eventflag {
X		% Show a centered Banner if any at the Top
X		daywidth days_week mul 2 div
X		Bannerstring stringwidth pop 2 div sub
X		60 moveto
X		Bannerstring show
X		% Show footnotes left-center-right
X		eventfont findfont footfontsize scalefont setfont
X		/bottomrow { dayheight rows mul 5 sub neg } def
X		0 bottomrow moveto
X		Lfootstring show
X		daywidth days_week mul Rfootstring stringwidth pop sub
X		bottomrow moveto
X		Rfootstring show
X		daywidth days_week mul Cfootstring stringwidth pop sub 2 div
X		bottomrow moveto
X		Cfootstring show
X		
X	} if
X
X	0 -5 moveto
X	drawnums
X
X	0 -5 moveto
X	drawfill
X
X	eventflag {
X		0 0 moveto
X		drawevents
X	} if
X
X	0 -5 moveto
X	drawgrid
X} def
X
X/eventflag true def
X
X$SCALE scale
X$ROTATE rotate
X$TRANSLATE translate
X/submonth 0 def
Xcalendar
X/eventflag false def
Xmonth 1 sub 0 eq
X{
X	/lmonth 12 def
X	/lyear year 1 sub def
X}
X{
X	/lmonth month 1 sub def
X	/lyear year def
X} ifelse
Xmonth 1 add 13 eq
X{
X	/nmonth 1 def
X	/nyear year 1 add def
X} 
X{
X	/nmonth month 1 add def
X	/nyear year def
X} ifelse
Xusefirst
X{
X	0 30 translate
X}
X{
X	days_week 2 sub daywidth mul -350 translate
X}
Xifelse
X/submonth 1 def
X/year lyear def
X/month lmonth def
Xgsave
X.138 .138 scale
X12 -120 translate
Xcalendar
Xgrestore
X/submonth 1 def
X/year nyear def
X/month nmonth def
Xdaywidth 0 translate
Xgsave
X.138 .138 scale
X12 -120 translate
Xcalendar
Xgrestore
X
Xshowpage
X
XEND-OF-CALENDAR
X
END_OF_FILE
if test 13265 -ne `wc -c <'pscal/pscal.script'`; then
    echo shar: \"'pscal/pscal.script'\" unpacked with wrong size!
fi
# end of 'pscal/pscal.script'
fi
if test -f 'xcalev/xcalev.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xcalev/xcalev.c'\"
else
echo shar: Extracting \"'xcalev/xcalev.c'\" \(12776 characters\)
sed "s/^X//" >'xcalev/xcalev.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char    *sccsid = "@(#)xcalev.c	1.15 (Hillside Systems) 11/15/93";
Xstatic char    *copyright = "@(#)Copyright 1993 Peter Collinson, Hillside Systems";
X#endif                          /* lint */
X#include "version.h"
X/***
X 
X* program name:
X        xcalev.c
X* function:
X	Load's xcal data files from a `calendar' like data file
X	called regular stored in the standard Calendar directory
X* switches:
X	-v	print version and exit
X	-f	name of regular file
X	-d dir	Use "dir" instead of Calendar
X	-x	be compatible with the X calendar program
X		(ie flat structure in the Calendar directory)
X	-r	remove entries from the files
X	followed by an optional year
X
X* libraries used:
X        standard
X* compile time parameters:
X        standard
X* history:
X        Written October 1993
X        Peter Collinson
X        Hillside Systems
X* (C) Copyright: 1993 Hillside Systems/Peter Collinson
X 
X        Permission to use, copy, modify, and distribute this software
X        and its documentation for any purpose is hereby granted to
X        anyone, provided that the above copyright notice appear
X        in all copies and that both that copyright notice and this
X        permission notice appear in supporting documentation, and that
X        the name of Peter Collinson not be used in advertising or
X        publicity pertaining to distribution of the software without
X        specific, written prior permission.  Hillside Systems makes no
X        representations about the suitability of this software for any
X        purpose.  It is provided "as is" without express or implied
X        warranty.
X 
X        Peter Collinson DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
X        SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
X        AND FITNESS, IN NO EVENT SHALL Peter Collinson BE LIABLE FOR
X        ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
X        WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
X        WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
X        ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X        PERFORMANCE OF THIS SOFTWARE.
X 
X***/
X#include <stdio.h>
X#include <ctype.h>
X#include <string.h>
X#include <time.h>
X#include <pwd.h>
X#include <unistd.h>
X#if defined(NeXT)
X#include <sys/fcntl.h>
X#endif
X#include <sys/stat.h>
X
Xstatic char	*progname = "xcalev";	/* name of program */
Xstatic char	*regular = "regular";	/* name of regular file */
Xstatic char	*calendar = "Calendar";	/* name of calendar directory */
Xstatic int	compat;			/* if non-zero use calendar compatible files */
Xstatic int	expunge;		/* remove entries rather than add them */
X
Xstatic char	*calfmt;		/* printf format of a calendar file */
Xstatic char	*caldir;		/* name of a calendar directory */
X
Xstatic char	*months[]	= {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
X				   "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
X
Xstatic int days_in_months[] = { 
X    31, 29, 31, 30,
X    31, 30, 31, 31,
X    30, 31, 30, 31,
X};
X
Xstatic int	year;			/* year to do the work for */
X
X/*
X * various strings
X */
Xstatic char	*memerr = "No more memory\n";
Xstatic char	*usage = "Usage: xcalev [-f srcfile] [-d dir][-x][-r] [year]\n";
X
Xchar	*malloc();
X
X/*
X *	routines
X */
Xstatic void filenames();
Xstatic void lineprocess();
Xstatic int monthmatch();
Xstatic void fileupdate();
Xstatic char *connect_file();
Xstatic void disconnect_file();
Xstatic char *delstr();
Xstatic void rewrite_file();
Xstatic char *Strdup();
Xstatic void fatal();
Xstatic void error();
Xstatic char *readbfile();
X
Xmain(argc, argv)
X	int	argc;
X	char	*argv[];
X{
X	register int	c;
X	extern char 	*optarg;
X	extern int	optind;
X	FILE		*fin;
X	char		line[BUFSIZ];
X
X	while ((c = getopt(argc, argv, "d:f:crv")) != EOF) {
X
X		switch (c) {
X		case 'd':
X			calendar = optarg;
X			break;
X		case 'f':
X			regular = optarg;
X			break;
X		case 'x':
X			compat = 1;
X			break;
X		case 'r':
X			expunge = 1;
X			break;
X		case 'v':
X			fprintf(stderr, "%s\n", version);
X			exit(0);
X		default:
X			fatal(usage);
X		}
X	}
X	if (optind < argc) {
X		year = atoi(argv[optind]);
X		if (year < 1993 && year > 2100)
X			fatal("Year %s should be > 1993\n", argv[optind]);
X	}
X
X	filenames();
X
X	/*
X	 * open the regular file
X	 */
X	if ((fin = fopen(regular, "r")) == NULL) {
X		fatal("Cannot open: %s\n", regular);
X	}
X	while (fgets(line, sizeof line, fin) != NULL) {
X		lineprocess(line);
X	}
X	fclose(fin);
X	exit(0);
X}	
X
X
X/*
X * organise filenames
X */
Xstatic void
Xfilenames()
X{
X	struct	passwd	*pw;
X	char		buf[256];
X	time_t		ti;
X	struct	tm	*tm;
X
X	pw = getpwuid(getuid());
X	if (pw == NULL)
X		fatal("Cannot get password information\n");
X	/*
X	 * get filename of Calendar directory
X	 */
X	if (*calendar != '.' && *calendar != '/') {
X		/* need to prepend the home directory */
X		(void) sprintf(buf, "%s/%s", pw->pw_dir, calendar);
X		calendar = Strdup(buf);
X	}
X	/*
X	 * and the source file
X	 */
X	if (*regular != '.' && *regular != '/') {
X		(void) sprintf(buf, "%s/%s", calendar, regular);
X		regular = Strdup(buf);
X	}
X	/*
X	 * get the year sorted
X	 */
X	if (year == 0) {
X		time(&ti);
X		tm = localtime(&ti);
X		year = tm->tm_year + 1900;
X	}
X	/*
X	 * xcalendar files are all
X	 * xc<d><Mon><Year>
X	 * or
X	 * xc<dd><Mon><Year>
X	 *
X	 * where d or dd is the day (%02d would have been better)
X	 * <Mon> is a capitalised first three letters of the
X	 *         English month name. If you need compatibility
X	 *         don't redefine the short names in the resources
X	 *         for this program.
X	 * <Year> is the full numeric year.
X	 *
X	 * We will follow this BUT we will also make this program
X	 * create subdirectories for new years
X	 *         xy<Year>
X	 * to speed up file access
X	 */
X	if (compat) 
X		(void) sprintf(buf, "%s/xc%%d%%s%d", calendar, year);
X	else	(void) sprintf(buf, "%s/xy%d/xc%%d%%s%d", calendar, year, year);
X	calfmt = Strdup(buf);
X	if (compat)
X		caldir = calendar;
X	else {
X		(void) sprintf(buf, "%s/xy%d", calendar, year);
X		caldir = Strdup(buf);
X	}
X
X	/*
X	 * See if we have a calendar directory
X	 */
X	if (access(calendar, F_OK) < 0) {
X		printf("%s does not exist, creating it\n", calendar);
X		if (mkdir(calendar, 0755) < 0) {
X			perror("mkdir");
X			fatal("Cannot create: %s\n", calendar);
X		}
X	}
X	/*
X	 * and an annual one
X	 */
X	if (access(caldir, F_OK) < 0) {
X		printf("%s does not exist, creating it\n", caldir);
X		if (mkdir(caldir, 0755) < 0) {
X			perror("mkdir");
X			fatal("Cannot create: %s\n", caldir);
X		}
X	}		
X}
X
X/*
X *	Process a single line from the regular file
X *	format is
X *	Month day text
X *	or
X *	day Month text
X *	Month is always a text string
X *	day can be a range with no spaces
X *	eg	5-11
X *	Lines starting with # are ignored
X */
Xstatic void
Xlineprocess(line)
X	char	*line;
X{
X	char	 *p1, *p2, *rest;
X	char	*ds;
X	char	*ms;
X	int	day, dayend, i, mon;
X	static int lineno;
X
X	lineno++;
X	/* comment */
X	if (*line == '#')
X		return;
X	
X	/* parse line into three sections */
X	p1 = strtok(line, " \t");
X	if (p1 == NULL) {
X		error("Cannot find month or day on line %d of %s\n", lineno,
X			regular);
X		return;
X	}
X	p2 = strtok(NULL, " \t");
X	if (p2 == NULL) {
X		error("Cannot find month or day on line %d of %s\n",
X		      lineno, regular);
X		return;
X	}
X	rest = strtok(NULL, "\n");
X	if (rest == NULL) {
X		error("No associated text with date on line %d of %s\n", 
X		      lineno, regular);
X		return;
X	}
X	/* is p1 or p2 the day? */
X	if (isdigit(*p1)) {
X		ds = p1;
X		ms = p2;
X	} else {
X		ds = p2;
X		ms = p1;
X	}
X	/* see if we have a range */
X	p1 = strchr(ds, '-');
X	if (p1) {
X		*p1++ = '\0';
X		day = atoi(ds);
X		dayend = atoi(p1);
X		if (dayend < day) {
X			error("Illegal day range: %d should be <= than %d\n", day, dayend);
X			return;
X		}	
X	} else {
X		day = dayend = atoi(ds);
X	}
X	mon = monthmatch(ms);
X	if (mon == -1) {
X		if (isdigit(*ms))
X			error("Months must be given as names, line %d of %s\n",
X				lineno, regular);
X		else
X			error("Cannot recognise %s as a month name, line %d of %s\n",
X				ms, lineno, regular);
X		return;
X	}
X	if (day < 1 || day > days_in_months[mon]) {
X		error("%s does not have a day numbered %d, line %d of %s\n",
X			months[mon], day, lineno, regular);
X		return;
X	}
X	if (dayend < 1 || dayend > days_in_months[mon]) {
X		error("%s does not have a day numbered %d, line %d of %s\n",
X			months[mon], dayend, lineno, regular);
X		return;
X	}
X
X	/* lose leading space before the text */
X	while (isspace(*rest))
X		rest++;
X	if (*rest == '\0')
X		return;
X	for (i = day; i <= dayend; i++)
X		fileupdate(i, mon, rest);
X}
X
X/*
X * Attempt to recognise a month string
X * return a month (0-11) if OK
X * else -1
X */
Xstatic int
Xmonthmatch(str)
X	char	*str;
X{
X	register int i;
X	
X	for (i = 0; i < 12; i++) {
X		if (strncasecmp(str, months[i], 3) == 0)
X			return i;
X	}
X	return -1;
X}
X
X/*
X * update a file from the data
X */
Xstatic void
Xfileupdate(day, mon, txt)
X	int	day;
X	int	mon;
X	char	*txt;
X{
X	char	filename[256];
X	char	*contents;
X	char	*substr;
X	int	flen;
X	int	addnl = 0;
X	FILE	*newf;
X
X	(void) sprintf(filename, calfmt, day, months[mon]);
X
X	if (access(filename, F_OK) == 0) {
X		/* file exists */
X		/* connect in memory and look for the text string */
X		contents = connect_file(filename, &flen);
X		if (flen) {
X			substr = strstr(contents, txt);
X			if (substr) {
X				/* message already exists */
X				if (expunge) {
X					/* 
X					 * we need to delete the string and
X					 * rewrite the file
X					 */
X					contents = delstr(contents, flen, txt, substr);
X					rewrite_file(filename, contents);
X					/* all done - exit */
X				} 
X				/* adding to file */
X				/* but already there - so exit */
X				disconnect_file(contents, flen);
X				return;
X			}
X			/* add the string at the end of the file */
X			/* check if we need to add a leading newline */
X			if (contents[flen-1] != '\n')
X				addnl = 1;
X			disconnect_file(contents, flen);
X		}
X	}
X	if (expunge)
X		return;
X	newf = fopen(filename, "a");
X	if (newf == NULL) {
X		error("Cannot open %s for appending\n", filename);
X		return;
X	}
X	if (addnl)
X		putc('\n', newf);
X	fputs(txt, newf);
X	fclose(newf);
X}
X	
Xstatic char *
Xconnect_file(filename, bytes)
X        char    *filename;
X        int     *bytes;
X{
X        int     fd;
X        struct  stat statb;
X        char    *fibase;
X 
X        if ((fd = open(filename, 0)) < 0) {
X                error("Cannot open calendar file: %s\n", filename);
X		return NULL;
X	}
X 
X        if (fstat(fd, &statb) < 0)
X                fatal("Cannot fstat %s (shouldn't happen)\n", filename);
X 
X        if (statb.st_size == 0) {
X		*bytes = 0;
X		return;
X	}
X	fibase = readbfile(fd, statb.st_size);
X
X        if ((int)fibase == -1)
X                fatal("Cannot read %s into memory\n", filename);
X 
X        close(fd);      /* we have it now */
X
X	fibase[statb.st_size] = '\0';	/* add a terminating NULL */
X        *bytes = statb.st_size;
X        return(fibase);
X}
X
Xstatic void
Xdisconnect_file(base, len)
X	char	*base;
X	int	len;
X{
X	free(base);
X}
X
X/*
X * delete a text string from a file
X */
Xstatic char *
Xdelstr(contents, len, txt, posn)
X	char	*contents;
X	int	len;
X	char	*txt;
X	char	*posn;
X{
X	int	len_of_txt;
X	int	len_to_move;
X	register char *s, *d;
X	
X	len_of_txt = strlen(txt);
X	if (*(posn + len_of_txt) == '\n')
X		len_of_txt++;
X	len_to_move = strlen(posn) - len_of_txt;
X	/* do this by steam */
X	d = posn;
X	s = posn + len_of_txt;
X	if (*s == '\0') {
X		*d = '\0';
X		/* eat any newline at the end of the file */
X		for(;;) {
X			if (d == contents)
X				break;
X			d--;
X			if (*d == '\n')
X				*d = '\0';
X			else 	
X				break;
X		}
X		return contents;
X	}
X	while(len_to_move--)
X		*d++ = *s++;
X	*d = '\0';
X	return contents;
X}
X	
X/*
X * rewrite a file from a new contents string
X */
Xstatic void
Xrewrite_file(filename, new)
X	char	*filename;
X	char	*new;
X{
X	int	len;
X	int	fd;
X	
X	unlink(filename);
X	if (*new == '\0') {
X		/* nothing there - delete the file */
X		return;
X	}
X	len = strlen(new);
X	if ((fd = creat(filename, 0666)) < 0) {
X		error("Cannot create: %s\n", filename);
X		return;
X	}
X	if (write(fd, new, len) != len)
X		error("Problem writing %s\n", filename);
X	close(fd);
X}
X
X/*
X * private strdup this used to call the system strdup()
X * and fail on an error, but it seems that some systems don't a strdup()
X */
Xstatic char *
XStrdup(str)
X	char	*str;
X{
X	int	len;
X	char	*ret;
X
X	len = strlen(str) + 1;
X	ret = malloc(len);
X	if (ret == NULL)
X		fatal(memerr);
X	(void) memcpy(ret, str, len);
X	return ret;
X}
X
X/*
X * fatal routine
X * print an error message and exit
X * should use vprintf I guess
X */
Xstatic void
Xfatal(fmt, a, b, c)
X	char	*fmt;
X{
X	fprintf(stderr, "%s: ", progname);
X	fprintf(stderr, fmt, a, b, c);
X	exit(1);
X}
X
X/*
X * error routine
X */
Xstatic void
Xerror(fmt, a, b, c, d)
X	char	*fmt;
X{
X	fprintf(stderr, "%s: ", progname);
X	fprintf(stderr, fmt, a, b, c, d);
X}
X
X/*
X * malloc some memory and
X * read the file into it
X */
Xstatic char *
Xreadbfile(fd, len)
X	int	fd;
X	int	len;
X{
X	char	*base;
X	
X	base = malloc(len+1);
X	if (base == NULL)
X		return ((char *)-1);
X	if (read(fd, base, len) != len)
X		return ((char *)-1);
X	return base;
X}
END_OF_FILE
if test 12776 -ne `wc -c <'xcalev/xcalev.c'`; then
    echo shar: \"'xcalev/xcalev.c'\" unpacked with wrong size!
fi
# end of 'xcalev/xcalev.c'
fi
echo shar: End of archive 5 \(of 8\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga: The only way to fly!  |    sources-x@sterling.com
       "It's intuitively obvious to the most casual observer..."
 GCS d++(--) -p+ c++ !l u++ e+ m+(-) s++/++ n h--- f+ g+++ w+ t++ r+ y+
