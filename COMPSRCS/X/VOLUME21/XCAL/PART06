Newsgroups: comp.sources.x
From: pc@hillside.co.uk (Peter Collinson)
Subject: v21i081:  xcal - A calendar program for X, Part06/08
Message-ID: <1993Dec21.161812.22168@sparky.sterling.com>
X-Md4-Signature: 78c063c29da489e794522a68449590a4
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Hillside Systems, 61 Hillside Avenue, Canterbury, Kent CT2 8HA
Date: Tue, 21 Dec 1993 16:18:12 GMT
Approved: chris@sterling.com

Submitted-by: pc@hillside.co.uk (Peter Collinson)
Posting-number: Volume 21, Issue 81
Archive-name: xcal/part06
Environment: X11
Supersedes: xcal: Volume 12, Issue 101

Xcal is a calendar program. For more details see Part 1 of this posting

Part 6 of 8
--shar starts here--
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 6 (of 8)."
# Contents:  Makefile.bsdi xcal_memo.c xcal_strip.c
# Wrapped by pc@hillside on Wed Nov 17 11:24:37 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Makefile.bsdi' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile.bsdi'\"
else
echo shar: Extracting \"'Makefile.bsdi'\" \(14937 characters\)
sed "s/^X//" >'Makefile.bsdi' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and <Imakefile>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit bsd.cf to change
X
X# platform:  $XConsortium: bsd.cf,v 1.18 91/07/30 12:10:52 rws Exp $
X
X# operating system:             4.3bsd
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = 	/bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = 	/usr/bin/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = groff -Tps
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS = -s
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X      PROJECTROOT =  /usr/X11
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS =
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = bsd.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules 			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def 			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.138.1.1 92/11/11 09:49:19 rws Exp $
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR =  /usr/X11/lib
X           BINDIR =  /usr/X11/bin
X          INCROOT =  /usr/X11/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH =  /usr/X11/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = 	/bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X        PEXLIBSRC = $(EXTENSIONSRC)/lib/PEXlib
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X  DEPEXTENSIONLIB = $(USRLIBDIR)/libXext.a
X     EXTENSIONLIB = 			 -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB) $(USRLIBDIR)/libX11.a
X             XLIB = $(EXTENSIONLIB) 			 -lX11
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB = 			 -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB = 			 -lXdmcp
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.a
X           XMULIB = 			 -lXmu
X
X       DEPOLDXLIB = $(USRLIBDIR)/liboldX.a
X          OLDXLIB = 			 -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.a
X         XTOOLLIB = 			 -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.a
X           XAWLIB = 			 -lXaw
X
X        DEPXILIB = $(USRLIBDIR)/libXi.a
X           XILIB = 			 -lXi
X
X       DEPPEXLIB = $(USRLIBDIR)/libPEX5.a
X          PEXLIB = 			 -lPEX5
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB = 			 -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB = 			 -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X          LINTPEX = $(LINTLIBDIR)/llib-lPEX5.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
X        DEFINES = -DLONG_IS_32_BITS -DVER_VEC
X
X          SRCS1 = xcal.c xcal_alarm.c xcal_buts.c xcal_days.c xcal_edit.c 		  xcal_help.c xcal_popup.c xcal_strip.c xcal_memo.c strfdate.c version.c
X
X          OBJS1 = xcal.o xcal_alarm.o xcal_buts.o xcal_days.o xcal_edit.o 		  xcal_help.o xcal_popup.o xcal_strip.o xcal_memo.o strfdate.o version.o
X
X       PROGRAMS = derived xcal
X   INSTPGMFLAGS = $(INSTBINFLAGS)
X         BINDIR = /usr/local/bin
X
X OBJS = $(OBJS1) $(OBJS2) $(OBJS3)
X SRCS = $(SRCS1) $(SRCS2) $(SRCS3)
X
Xall:: $(PROGRAMS)
X
Xxcal: $(OBJS1) $(DEPLIBS1)
X	$(RM) $@
X	$(CC) -o $@ $(LDOPTIONS) $(OBJS1)  $(XAWLIB) $(XMULIB) $(XTOOLLIB) $(XLIB) $(LDLIBS)  -lm $(EXTRA_LOAD_FLAGS)
X
Xinstall:: xcal
X	-@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  xcal $(DESTDIR)$(BINDIR)
X
Xinstall.man:: xcal.man
X	-@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) xcal.man $(DESTDIR)$(MANDIR)/xcal.$(MANSUFFIX)
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAMS)
X
Xinstall:: XCal.ad
X	-@if [ -d $(DESTDIR)$(XAPPLOADDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XAPPLOADDIR)); fi
X	$(INSTALL) -c $(INSTAPPFLAGS) XCal.ad $(DESTDIR)$(XAPPLOADDIR)/XCal
X
Xinstall:: XCal.help
X	$(INSTALL) -c $(INSTDATFLAGS) XCal.help $(DESTDIR) $(XAPPLOADDIR)/XCal.help
X
Xderived:	xcal_help.h xcal_ad.h
X
Xclean::
X	$(RM) xcal_help.h xcal_ad.h
X
Xxcal_help.h:	XCal.help
X	sh C_from_help.sh
X
Xxcal_ad.h:	XCal.ad
X	sh C_from_ad.sh
X
XSUBD=xcalpr xcalev xcal_cal
X
Xall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBD) ;\
X	do \
X	(cd $$i ; echo "making" all "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) 'CDEBUGFLAGS=$(CDEBUGFLAGS)' all); \
X	done
X
Xclean::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBD) ;\
X	do \
X	(cd $$i ; echo "cleaning" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) RM_CMD='$(RM_CMD)' clean); \
X	done
X
Xinstall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBD) ;\
X	do \
X	(cd $$i ; echo "installing" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install); \
X	done
X
Xinstall.man::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBD) ;\
X	do \
X	(cd $$i ; echo "installing man pages" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install.man); \
X	done
X
Xdepend::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBD) ;\
X	do \
X	(cd $$i ; echo "depending" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS)  depend); \
X	done
X
XSUBDIRS = pscal
X
Xall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "making" all "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) 'CDEBUGFLAGS=$(CDEBUGFLAGS)' all); \
X	done
X
Xdepend::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "depending" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS)  depend); \
X	done
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
X# -------------------------------------------------------------------------
X# rules for building in SUBDIRS - do not edit
X
Xinstall::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "installing" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install); \
X	done
X
Xinstall.man::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "installing man pages" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) DESTDIR='$(DESTDIR)' install.man); \
X	done
X
Xclean::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "cleaning" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) RM_CMD='$(RM_CMD)' clean); \
X	done
X
Xtags::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo "tagging" "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS) TAGS='$(TAGS)' tags); \
X	done
X
XMakefiles::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	echo "making Makefiles in $(CURRENT_DIR)/$$i..."; \
X	case "$$i" in \
X	./?*/?*/?*/?*) newtop=../../../../ sub=subsubsubsub;; \
X	./?*/?*/?*) newtop=../../../ sub=subsubsub;; \
X	./?*/?*)    newtop=../../ sub=subsub;; \
X	./?*)       newtop=../ sub=sub;; \
X	*/?*/?*/?*)    newtop=../../../../ sub=subsubsubsub;; \
X	*/?*/?*)    newtop=../../../ sub=subsubsub;; \
X	*/?*)       newtop=../../ sub=subsub;; \
X	*)	    newtop=../ sub=sub;; \
X	esac; \
X	case "$(TOP)" in \
X	/?*) newtop=  upprefix=  ;; \
X	*) upprefix=../ ;; \
X	esac; \
X	$(MAKE) $${sub}dirMakefiles UPPREFIX=$$upprefix NEWTOP=$$newtop \
X	MAKEFILE_SUBDIR=$$i NEW_CURRENT_DIR=$(CURRENT_DIR)/$$i;\
X	done
X
XsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then set -x; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then set -x; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then set -x; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
XsubsubsubsubdirMakefiles:
X	$(RM) $(MAKEFILE_SUBDIR)/Makefile.bak
X	-@if [ -f $(MAKEFILE_SUBDIR)/Makefile ]; then set -x; \
X	$(MV) $(MAKEFILE_SUBDIR)/Makefile $(MAKEFILE_SUBDIR)/Makefile.bak; \
X	else exit 0; fi
X	cd $(MAKEFILE_SUBDIR); $(IMAKE_CMD) -DTOPDIR=$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(UPPREFIX)$(TOP) -DCURDIR=$(NEW_CURRENT_DIR); \
X	$(MAKE) $(MFLAGS) Makefiles
X
Xincludes::
X	@case '${MFLAGS}' in *[ik]*) set +e;; esac; \
X	for i in $(SUBDIRS) ;\
X	do \
X	(cd $$i ; echo including "in $(CURRENT_DIR)/$$i..."; \
X	$(MAKE) $(MFLAGS)  includes); \
X	done
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
END_OF_FILE
if test 14937 -ne `wc -c <'Makefile.bsdi'`; then
    echo shar: \"'Makefile.bsdi'\" unpacked with wrong size!
fi
# end of 'Makefile.bsdi'
fi
if test -f 'xcal_memo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xcal_memo.c'\"
else
echo shar: Extracting \"'xcal_memo.c'\" \(15581 characters\)
sed "s/^X//" >'xcal_memo.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char    *sccsid = "@(#)xcal_memo.c	1.22 (Hillside Systems) 10/29/93";
Xstatic char    *copyright = "@(#)Copyright 1989,1990,1993 Peter Collinson, Hillside Systems";
X#endif				/* lint */
X/***
X
X* module name:
X	xcal_memo.c
X* function:
X	Deal with popup memo file
X	A single popup file is stored in a file called
X	memo on the Calendar directory
X* history:
X	Written December 1990
X	Peter Collinson
X	Hillside Systems
X* (C) Copyright: 1989,1990 Hillside Systems/Peter Collinson
X	
X	For full permissions and copyright notice - see xcal.c
X***/
X#include <stdio.h>
X#include <ctype.h>
X#include <X11/Xos.h>
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Shell.h>
X#include <X11/Xaw/AsciiText.h>
X#include <X11/Xaw/Text.h>
X#include <X11/Xaw/Command.h>
X#include <X11/Xaw/Label.h>
X#include <X11/Xaw/Paned.h>
X#include <X11/Xaw/Form.h>
X#include <X11/Xaw/Dialog.h>
X#include "xcal.h"
X
Xstatic XtCallbackRec callbacks[] = {
X	{NULL, NULL},
X	{NULL, NULL}
X};
X#define ClearCallbacks() memset((caddr_t)callbacks, '\0', sizeof (callbacks))
X#define argLD(N,V) { XtSetArg(args[nargs], N, V); nargs++; }
X
X/*
X * Structure for storing relavant data about the memo Edit
X */
Xtypedef struct memoEdit {
X	Widget          m_button;	/* widget of the control button */
X	Widget          m_popup;	/* widget of editor popup */
X	Widget          m_quit;		/* widget of quit button */
X	Widget		m_edit;		/* widget of edit button */
X	Widget		m_help;		/* widget of help button */
X	Widget          m_save;		/* widget of save button */
X	Boolean         m_savesens;	/* state of the save button */
X	Widget          m_display;	/* widget of display title area */
X	Widget          m_text;		/* the text area */
X	Widget          m_today;	/* today's data */
X	Widget          m_weekly;	/* widget of text image of weekly */
X					/* events */
X	String		m_weeklytext;	/* weekly text */
X	Cardinal        m_size;		/* size of the buffer */
X	char           *m_data;		/* pointer to malloc'ed data buffer */
X} MemoEdit;
X
Xstatic MemoEdit memo;
X
Xstatic String   memoContents;
X
Xextern void     MemoHelp();		/* look in xcal_help.c */
X
X/*
X * Internal routines
X */
Xvoid            MemoPopup();
Xstatic void     CleanMemo();
Xstatic void     MemoCheckExit();
Xstatic void     MCheckDia();
Xstatic Boolean  WriteMemoFile();
Xstatic void	EditToday();
Xstatic int      NewlineCount();
Xstatic String   GetMemoFile();
Xstatic void     SaveMemoEdits();
Xstatic void     MemoTextChanged();
Xstatic void     FinishMemoEditing();
Xstatic void     YesCheck();
Xstatic void     NoCheck();
Xstatic void	AdjustTitleHeight();
X
X/*
X * Callback routine to display the memo file
X */
X
Xvoid
XDoMemo(w, closure, call_data)
X	Widget          w;
X	caddr_t         closure;
X	caddr_t         call_data;
X{
X	static Arg      args[1];
X
X	/*
X	 * Make the button become a finish button
X	 */
X	memo.m_button = w;
X	callbacks[0].callback = FinishMemoEditing;
X	callbacks[0].closure = NULL;
X	XtSetArg(args[0], XtNcallback, callbacks);
X	XtSetValues(w, args, 1);
X
X	MouseShow(w, False);
X	/*
X	 * Get existing memo contents
X	 * if the user is polling then re-read the file
X	 */
X	if (appResources.update && memoContents != NULL) {
X		XtFree(memoContents);
X		memoContents = NULL;
X	}
X	if (memoContents == NULL)
X		memoContents = GetMemoFile();
X
X	/*
X	 * Set up the popup widget for editing
X	 */
X	MemoPopup();
X}
X
X
X/*
X * Get old contents from a memo file if any
X */
Xstatic String
XGetMemoFile()
X{
X
X	if (FoundCalendarDir && access(appResources.memoFile, F_OK) == 0)
X		return ReadCalendarFile(NULL, appResources.memoFile);
X	return NULL;
X}
X
X
X/*
X * Do the biz to popup an edit style window
X */
Xvoid
XMemoPopup()
X{
X	Widget          et, lw;
X	Widget          frame;
X	Arg             args[10];
X	Cardinal        nargs;
X	String          str;
X	MonthEntry     *me;
X	Dimension       charHeight;
X
X	/*
X	 * set up edit buffer
X	 */
X	if (memoContents)
X		memo.m_size = appResources.textbufsz + strlen(memoContents) + 1;
X	else
X		memo.m_size = appResources.textbufsz;
X	memo.m_data = XtMalloc(memo.m_size);
X
X	if (memoContents)
X		strcpy(memo.m_data, memoContents);
X	else
X		*memo.m_data = '\0';
X	memo.m_popup = XtCreatePopupShell("memo", topLevelShellWidgetClass, toplevel, NULL, 0);
X
X	/*
X	 * The first title line
X	 */
X	et = XtCreateManagedWidget("memoPanel", panedWidgetClass, memo.m_popup, NULL, 0);
X
X	nargs = 0;
X	argLD(XtNshowGrip, False);
X	argLD(XtNskipAdjust, True);
X	argLD(XtNdefaultDistance, 1);
X	frame = XtCreateManagedWidget("title", formWidgetClass, et, args, nargs);
X	/*
X	 * containing some buttons for controlling the world
X	 */
X	/*
X	 * Take label "quit" from resources
X	 */
X	callbacks[0].callback = FinishMemoEditing;
X	callbacks[0].closure = NULL;
X	nargs = 0;
X	argLD(XtNcallback, callbacks);
X	argLD(XtNfromHoriz, NULL);
X	argLD(XtNleft, XtChainLeft);
X	argLD(XtNright, XtChainLeft);
X	lw = memo.m_quit = XtCreateManagedWidget("quit", commandWidgetClass, frame, args, nargs);
X
X	/*
X	 * Edit todays file from here as well
X	 * Take label from resources
X	 */
X	callbacks[0].callback = EditToday;
X	callbacks[0].closure = (caddr_t) 0;
X	nargs = 0;
X	argLD(XtNcallback, callbacks);
X	argLD(XtNfromHoriz, lw);
X	argLD(XtNleft, XtChainLeft);
X	argLD( XtNright, XtChainLeft);
X	memo.m_edit = lw = XtCreateManagedWidget("edit", commandWidgetClass, frame, args, nargs);
X
X	/*
X	 * If we are dealing with  help then do it now
X	 */
X	if (appResources.giveHelp) {
X		/* Take label "help" from resources */
X		callbacks[0].callback = MemoHelp;
X		callbacks[0].closure = (caddr_t) 0;
X		nargs = 0;
X		argLD(XtNcallback, callbacks);
X		argLD(XtNfromHoriz, lw);
X		argLD(XtNleft, XtChainLeft);
X		argLD( XtNright, XtChainLeft);
X		memo.m_help = lw = XtCreateManagedWidget("help", commandWidgetClass, frame, args, nargs);
X	}
X
X	/*
X	 * The remaining bit here is a date label
X	 */
X	nargs = 0;
X	argLD(XtNlabel, date_area);
X	argLD(XtNborderWidth, 0);
X	argLD(XtNfromHoriz, lw);
X	argLD(XtNfromVert, NULL);
X	argLD(XtNvertDistance, 2);
X	argLD(XtNleft, XtChainLeft);
X	argLD(XtNright, XtChainRight);
X	lw = memo.m_display = XtCreateManagedWidget("date", labelWidgetClass, frame, args, nargs);
X
X	/*
X	 * Details for today
X	 */
X	me = GetMonthEntry(today.year, today.month);
X	nargs = 0;
X	str = me->me_have[today.day];
X	if (str == NULL)
X		str = "";
X	argLD(XtNstring, str);
X	argLD(XtNdisplayCaret, False);
X	argLD(XtNeditType, XawtextRead);
X	memo.m_today = XtCreateManagedWidget("display", asciiTextWidgetClass, et, args, nargs);
X	{
X		Dimension       height;
X
X		XtSetArg(args[0], XtNheight, &height);
X		XtGetValues(memo.m_today, args, 1);
X		charHeight = height;
X		height = height * NewlineCount(str);
X		XtSetArg(args[0], XtNheight, height);
X		XtSetValues(memo.m_today, args, 1);
X	}
X
X	AdjustTitleHeight(memo.m_quit, memo.m_edit,
X			  appResources.giveHelp ? memo.m_help : NULL,
X			  memo.m_display);
X
X	/*
X	 * Weekly details - the data for today + an edit button
X	 * The header to this is a form
X	 */
X	nargs = 0;
X	argLD(XtNshowGrip, False);
X	argLD(XtNskipAdjust, True);
X	argLD(XtNdefaultDistance, 1);
X	frame = XtCreateManagedWidget("weeklyMemo", formWidgetClass, et, args, nargs);
X	/*
X	 * Take label "edit" from resources
X	 */
X	callbacks[0].callback = DoWeekly;
X	callbacks[0].closure = (caddr_t) & memo;
X	nargs = 0;
X	argLD(XtNcallback, callbacks);
X	argLD(XtNfromHoriz, NULL);
X	argLD(XtNleft, XtChainLeft);
X	argLD(XtNright, XtChainLeft);
X	lw = XtCreateManagedWidget("weeklyEdit", commandWidgetClass, frame, args, nargs);
X
X	/*
X	 * Say this is a weekly commitment
X	 */
X	nargs = 0;
X	argLD(XtNshowGrip, True);
X	argLD(XtNborderWidth, 0);
X	argLD(XtNfromHoriz, MyCalendar ? lw : NULL);
X	argLD(XtNfromVert, NULL);
X	argLD(XtNvertDistance, 2);
X	argLD(XtNleft, XtChainLeft);
X	argLD(XtNright, XtChainRight);
X	lw = XtCreateManagedWidget("weeklyTitle", labelWidgetClass, frame, args, nargs);
X
X	/*
X	 * Details for today
X	 */
X	nargs = 0;
X	if (memo.m_weeklytext)
X		XtFree(memo.m_weeklytext);
X	memo.m_weeklytext = str = GetWeeklyFile(today.wday);
X	if (str == NULL)
X		str = "";
X	argLD(XtNstring, str);
X	argLD(XtNdisplayCaret, False);
X	argLD(XtNeditType, XawtextRead);
X	if (charHeight)
X		argLD(XtNheight, NewlineCount(str) * charHeight);
X	memo.m_weekly = XtCreateManagedWidget("display", asciiTextWidgetClass, et, args, nargs);
X	/*
X	 * Another form with some buttons
X	 */
X	nargs = 0;
X	argLD(XtNshowGrip, False);
X	argLD(XtNskipAdjust, True);
X	argLD(XtNdefaultDistance, 1);
X	frame = XtCreateManagedWidget("memoMiddle", formWidgetClass, et, args, nargs);
X	if (MyCalendar) {
X		/*
X		 * Take label "save" from resources
X		 */
X		callbacks[0].callback = SaveMemoEdits;
X		callbacks[0].closure = (caddr_t) & memo;
X		nargs = 0;
X		argLD(XtNcallback, callbacks);
X		argLD(XtNfromHoriz, NULL);
X		argLD(XtNleft, XtChainLeft);
X		argLD(XtNright, XtChainLeft);
X		argLD(XtNsensitive, False);
X		lw = memo.m_save = XtCreateManagedWidget("save", commandWidgetClass, frame, args, nargs);
X		memo.m_savesens = False;
X	}
X	/*
X	 * Say this is a memo edit
X	 */
X	nargs = 0;
X	argLD(XtNshowGrip, True);
X	argLD(XtNborderWidth, 0);
X	argLD(XtNfromHoriz, MyCalendar ? lw : NULL);
X	argLD(XtNfromVert, NULL);
X	argLD(XtNvertDistance, 2);
X	argLD(XtNleft, XtChainLeft);
X	argLD(XtNright, XtChainRight);
X	lw = XtCreateManagedWidget("memoTitle", labelWidgetClass, frame, args, nargs);
X
X	/*
X	 * The text widget is in the pane below
X	 * The Scroll Attributes are controlled from the application
X	 * defaults file
X	 */
X	callbacks[0].callback = MemoTextChanged;
X	callbacks[0].closure = (caddr_t) & memo;
X	nargs = 0;
X	argLD(XtNstring, memo.m_data);
X	argLD(XtNeditType, XawtextEdit);
X	argLD(XtNlength, memo.m_size);
X	argLD(XtNuseStringInPlace, True);
X	argLD(XtNcallback, callbacks);
X	memo.m_text = XtCreateManagedWidget("memoText", asciiTextWidgetClass, et, args, nargs);
X
X
X	XtPopup(memo.m_popup, XtGrabNone);
X
X}
X
X/*
X * Adjust title line height
X * possibly 4 objects
X */
Xstatic void
XAdjustTitleHeight(quit, edit, help, label)
X	Widget		quit;
X	Widget		edit;
X	Widget		help;
X	Widget		label;
X{
X	int		hq, he, hh, hl;
X	int		max;
X
X	hq = wHeight(quit);
X	he = wHeight(edit);
X	hh = help ? wHeight(help): 0;
X	hl = wHeight(label);
X
X	max = hq;
X	max = (he > max) ? he : max;
X	max = (hh > max) ? hh : max;
X	max = (hl > max) ? hl : max;
X
X	if (hq < max)
X		SetWidgetHeightMax(quit, hq, max);
X	if (he < max)
X		SetWidgetHeightMax(edit, he, max);
X	if (hh & hh < max)
X		SetWidgetHeightMax(help, hh, max);
X	if (hl < max)
X		SetWidgetHeightMax(label, hl, max);
X}
X
X/*
X * This callback starts editing today
X */
Xstatic void
XEditToday(w, closure, call_data)
X	Widget		w;
X	caddr_t         closure;
X	caddr_t         call_data;
X{	
X
X	StartEditing(w, &today, w);
X}
X
X/*
X * Count newlines in a string
X */
Xstatic int
XNewlineCount(str)
X	String          str;
X{
X	register int    sum = 0;
X
X	while (*str)
X		if (*str++ == '\n')
X			sum++;
X	/* Add one line - assume last line does NOT have an nl */
X	sum++;
X	/* ignore a final newline */
X	if (str[-1] == '\n')
X		sum--;
X	if (sum <= 0)
X		sum = 1;
X	return (sum > appResources.maxDisplayLines ? appResources.maxDisplayLines : sum);
X}
X
X/*
X * Entry point from outside when today's text changed
X */
Xvoid
XUpdateMemo()
X{
X	Arg             args[1];
X	String          str;
X	MonthEntry     *me;
X
X	/*
X	 * if the button widget is zero then we are displaying nothing
X	 */
X	if (memo.m_button == 0)
X		return;
X
X	me = GetMonthEntry(today.year, today.month);
X	str = me->me_have[today.day];
X	if (str == NULL)
X		str = "";
X	XtSetArg(args[0], XtNstring, str);
X	XtSetValues(memo.m_today, args, 1);
X
X	XtSetArg(args[0], XtNlabel, date_area);
X	XtSetValues(memo.m_display, args, 1);
X
X	if (memo.m_weeklytext)
X		XtFree(memo.m_weeklytext);
X	memo.m_weeklytext = str = GetWeeklyFile(today.wday);
X	if (str == NULL)
X		str = "";
X	XtSetArg(args[0], XtNstring, str);
X	XtSetValues(memo.m_weekly, args, 1);
X
X}
X
X/*
X * Poll call from the alarm timeout
X */
Xvoid
XMemoPoll()
X{
X	int             size;
X	Arg             args[10];
X	int             nargs;
X
X	if (memo.m_button == 0)
X		return;
X	if (memo.m_savesens == True)
X		return;
X
X	if (memoContents)
X		XtFree(memoContents);
X	memoContents = GetMemoFile();
X	if (memoContents) {
X		if (strcmp(memoContents, memo.m_data) == 0)
X			return;
X		size = strlen(memoContents) + 1;
X		if (size > memo.m_size) {
X			size += appResources.textbufsz;
X			XtFree(memo.m_data);
X			memo.m_data = XtMalloc(memo.m_size = size);
X		}
X		strcpy(memo.m_data, memoContents);
X	} else
X		*memo.m_data = '\0';
X
X	nargs = 0;
X	argLD(XtNstring, memo.m_data);
X	argLD(XtNlength, memo.m_size);
X	argLD(XtNuseStringInPlace, True);
X	XtSetValues(memo.m_text, args, nargs);
X}
X
X/*
X * Call backs for various buttons
X */
X/* ARGSUSED */
Xstatic void
XMemoTextChanged(w, closure, call_data)
X	Widget          w;
X	caddr_t         closure;
X	caddr_t         call_data;
X{
X	register MemoEdit *memo = (MemoEdit *) closure;
X
X	if (MyCalendar) {
X		memo->m_savesens = True;
X		XtSetSensitive(memo->m_save, True);
X	}
X}
X
X/*
X * Callback routines
X */
X/* ARGSUSED */
Xstatic void
XSaveMemoEdits(w, closure, call_data)
X	Widget          w;
X	caddr_t         closure;
X	caddr_t         call_data;
X{
X	MemoEdit       *memo = (MemoEdit *) closure;
X
X	if (WriteMemoFile(memo) == False)
X		return;
X	if (memoContents) {
X		XtFree(memoContents);
X		memoContents = XtNewString(memo->m_data);
X	}
X	memo->m_savesens = False;
X	XtSetSensitive(memo->m_save, False);
X}
X
X/*
X * Write the memo file out
X */
Xstatic          Boolean
XWriteMemoFile(memo)
X	MemoEdit       *memo;
X{
X	Cardinal        len = strlen(memo->m_data);
X	String          fname;
X	int             fd;
X
X	if (len == 0) {
X		unlink(appResources.memoFile);
X		return (True);
X	}
X	/*
X	 * First let's see if we have to create the toplevel directory
X	 */
X	if (!NeedTop())
X		return (False);
X
X	fname = appResources.memoFile;
X
X	if ((fd = open(fname, O_WRONLY | O_TRUNC | O_CREAT, 0666)) < 0) {
X		XBell(XtDisplay(toplevel), 0);
X		fprintf(stderr, "xcal: Could not open %s/%s for writing.\n", MapStem, fname);
X		perror("xcal: open");
X		fflush(stderr);
X		return (False);
X	}
X	if (write(fd, memo->m_data, len) != len) {
X		XBell(XtDisplay(toplevel), 0);
X		fprintf(stderr, "xcal: Write error %s/%s file.\n", MapStem, fname);
X		perror("xcal: write");
X		fflush(stderr);
X		close(fd);
X		return (False);
X	}
X	close(fd);
X	return (True);
X}
X
Xstatic void
XFinishMemoEditing(w, closure, call_data)
X	Widget          w;
X	caddr_t         closure;
X	caddr_t         call_data;
X{
X
X	if (memo.m_savesens == True)
X		MemoCheckExit();
X	else
X		CleanMemo();
X}
X
Xstatic void
XCleanMemo()
X{
X	static Arg      args[1];
X	static MemoEdit	zerom;
X
X	callbacks[0].callback = DoMemo;
X	callbacks[0].closure = NULL;
X	XtSetArg(args[0], XtNcallback, callbacks);
X	XtSetValues(memo.m_button, args, 1);
X	XtSetSensitive(memo.m_button, True);
X
X	MouseShow(memo.m_button, True);
X	XtPopdown(memo.m_popup);
X	XtDestroyWidget(memo.m_popup);
X	XtFree(memo.m_data);
X	XtFree(memo.m_weeklytext);
X	memo = zerom;
X}
X
Xstatic void
XMemoCheckExit()
X{
X	DialogPopup(memo.m_quit, MCheckDia, &memo, NULL);
X}
X
Xstatic void
XMCheckDia(pop, ed)
X	Widget          pop;
X	MemoEdit       *ed;
X{
X	Widget          dia;
X
X	XtSetSensitive(memo.m_quit, False);
X	XtSetSensitive(memo.m_button, False);
X	XtSetSensitive(memo.m_save, False);
X
X	/* Take "Save file?" from resources */
X	dia = XtCreateManagedWidget("memocheck", dialogWidgetClass, pop, NULL, 0);
X	XawDialogAddButton(dia, "yes", YesCheck, ed);
X	XawDialogAddButton(dia, "no", NoCheck, ed);
X}
X
X/* ARGSUSED */
Xstatic void
XYesCheck(w, closure, call_data)
X	Widget          w;
X	caddr_t         closure;
X	caddr_t         call_data;
X{
X	SaveMemoEdits(w, closure, call_data);
X	CleanMemo();
X
X	XtDestroyWidget(XtParent(XtParent(w)));
X}
X
X/* ARGSUSED */
Xstatic void
XNoCheck(w, closure, call_data)
X	Widget          w;
X	caddr_t         closure;
X	caddr_t         call_data;
X{
X	CleanMemo();
X        XtDestroyWidget(XtParent(XtParent(w)));
X}
X
END_OF_FILE
if test 15581 -ne `wc -c <'xcal_memo.c'`; then
    echo shar: \"'xcal_memo.c'\" unpacked with wrong size!
fi
# end of 'xcal_memo.c'
fi
if test -f 'xcal_strip.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xcal_strip.c'\"
else
echo shar: Extracting \"'xcal_strip.c'\" \(18555 characters\)
sed "s/^X//" >'xcal_strip.c' <<'END_OF_FILE'
X#ifndef lint
Xstatic char    *sccsid = "@(#)xcal_strip.c	3.27 (Hillside Systems) 11/1/93";
Xstatic char    *copyright = "@(#)Copyright 1989,1990,1993 Peter Collinson, Hillside Systems";
X#endif				/* lint */
X/***
X
X* module name:
X	xcal_strip.c
X* function:
X	Deal with the popup strip calendars obtained either by
X	selection and the middle button, or by the < and > buttons
X	on each strip.
X* history:
X	Written November 1989
X	Peter Collinson
X	Hillside Systems
X* (C) Copyright: 1989 Hillside Systems/Peter Collinson
X	
X	For full permissions and copyright notice - see xcal.c
X***/
X#include <stdio.h>
X#include <ctype.h>
X#include <X11/Intrinsic.h>
X#include <X11/Xatom.h>
X#include <X11/StringDefs.h>
X#include <X11/Shell.h>
X#include <X11/Xaw/Paned.h>
X#include <X11/Xaw/Viewport.h>
X#include <X11/Xaw/Command.h>
X#include <X11/Xaw/Label.h>
X#include <X11/Xaw/Dialog.h>
X#include <X11/Xaw/AsciiText.h>
X#include "xcal.h"
X
Xstatic XtCallbackRec callbacks[] = {
X	{NULL, NULL},
X	{NULL, NULL},
X	{NULL, NULL},
X	{NULL, NULL}
X};
X#define ClearCallbacks() memset((caddr_t)callbacks, '\0', sizeof (callbacks))
X
XDate            callb;		/* contains date when calendar day button */
X				/* pressed */
X
Xstatic String   defTranslations =
X"<Btn2Down>: set()\n\
X	<Btn2Up>: LoadDateAction() unset()";
X
X/*
X *	These translations used to make the middle mouse button
X *	load a date file from a selection when clicked on a strip
X */
X
X/*
X * Forward routines local to this file
X */
Xstatic void     MakeMonth();
Xstatic void     DayBack();
X#ifndef LONG_IS_32_BITS
Xstatic void     YmBack();
X#endif
Xstatic void     StripQuit();
Xvoid            StripHelp();
Xvoid            WeeklyHelp();
X
X/*
X * Local routines
X */
Xstatic void     MakeNewMonth();
Xstatic void	LoadDateCallback();
Xstatic Cardinal DateSum();
Xstatic void	setStripMax();
Xstatic Dimension CreateActionBar();
Xstatic Dimension CreateWeeklyActionBar();
X
X#define argLD(N,V) { XtSetArg(args[nargs], N, V); nargs++; }
X
X/*
X * Start a strip calendar happening a callback of left button
X */
X/* ARGSUSED */
Xvoid
XDoCalendar(w, closure, call_data)
X	Widget          w;
X	caddr_t         closure;
X	caddr_t         call_data;
X{
X	NewMonthStrip(&today, NULL);	/* today is global */
X}
X
X/* ARGSUSED */
Xvoid
XDoWeekly(w, closure, call_data)
X	Widget          w;
X	caddr_t         closure;
X	caddr_t         call_data;
X{
X	Date            thisday;
X
X	thisday.day = 0;
X	thisday.month = 0;
X	thisday.year = 0;
X	thisday.wday = 0;
X	NewMonthStrip(&thisday, w);/* today is global */
X}
X
X
X/*
X * Start a strip calendar happening a callback of the > or < buttons in
X * another strip
X */
X/* ARGSUSED */
Xstatic void
XMakeNewMonth(w, closure, call_data)
X	Widget          w;
X	caddr_t         closure;
X	caddr_t         call_data;
X{
X	Date            thisday;
X
X	thisday.year = YrUnpack((Cardinal) closure);
X	thisday.month = MoUnpack((Cardinal) closure);
X	thisday.day = today.day;
X	NewMonthStrip(&thisday, NULL);
X}
X
X/* 
X *	Do all the X stuff to popup a Strip calendar
X *	A calendar strip is:
X *
X *	Popup ("<month year>")		// Name is the month and the year
X *	 Paned ("<month>")		// Name is the month
X *       Label ("header")		// optional contains Month Year
X *	 Form ("action")		// < Quit >
X *		Command ("back")	// contains < 
X *		Label ("quit")		// contains Quit
X *		Command ("next")	// contains >
X *	 ViewPort ("viewport")		// Viewport containing strip data
X *	        Paned ("data")		// Panel containing the calendar data
X *		    (Then many of..)
X *		    Form ("<dd DDD>")	// where DDD is the day of the week
X *		    Label ("label")	// contains the string above
X *		    Command ("info")	// contains the text from the file
X *		
X */
Xvoid
XNewMonthStrip(td, but)
X	Date           *td;
X	Widget		but;
X{
X	Widget          shell, mon, dw, lw, lwi, form, monvp, mondt;
X	Arg             args[15];
X	char            titlestr[256];
X	char		tbuf[256];
X	char            iconName[256];
X	int             type;
X	MonthEntry     *me;
X	Instance       *ins;
X	register int    i;
X	register Cardinal nargs;
X	Cardinal        thisDay;
X	Cardinal        startLoop;
X	String          dayStr;
X	Cardinal        numberOfDays;
X	Boolean         defaultsAreSet = False;
X	Boolean         markThisMonth = False;
X	Dimension       labelH, infoH;
X	Dimension       width;
X	Dimension	totalHeight;
X	Dimension	hdrHeight;
X	Dimension       totalWidth;
X	static		XtTranslations but2;
X
X	type = (td->day == 0) ? ME_WEEKLY : ME_MONTHLY;
X	hdrHeight = 0;
X
X	/*
X	 * There are lots of differences between Months and weekly strips
X	 * here. Later tests are done using a switch structure
X	 */
X	switch (type) {
X	case ME_MONTHLY:
X		FmtDate(td, iconName, sizeof iconName, appResources.stripfmt);
X		XtSetArg(args[0], XtNiconName, iconName);
X		shell = XtCreatePopupShell(XtNewString(iconName), topLevelShellWidgetClass, toplevel, args, 1);
X		ins = RegisterMonth(td->year, td->month, shell);
X		mon = XtCreateManagedWidget(appResources.mon[td->month], panedWidgetClass, shell, NULL, 0);
X		thisDay = FirstDay(td->month, td->year);
X		numberOfDays = NumberOfDays(td->month, td->year);
X		startLoop = 1;
X		/*
X		 * Get the map for this year
X		 */
X		me = GetMonthEntry(td->year, td->month);
X		/*
X		 * Title bar is month and date
X		 */
X		FmtDate(td, titlestr, sizeof titlestr, appResources.stripfmt);
X		/*
X		 * see if we will need to worry about marking today's entry
X		 */
X		if (appResources.markToday && td->year == today.year && td->month == today.month)
X			markThisMonth = True;
X		break;
X	case ME_WEEKLY:
X		(void) strcpy(iconName, appResources.weekly);
X		nargs = 0;
X		argLD(XtNiconName, iconName);
X		shell = XtCreatePopupShell(XtNewString(iconName), topLevelShellWidgetClass, toplevel, args, nargs);
X		if (but && XtIsSubclass(but, commandWidgetClass))
X			ButtonOff(but, shell);
X		ins = RegisterMonth(0, 0, shell);
X		mon = XtCreateManagedWidget(iconName, panedWidgetClass, shell, NULL, 0);
X		thisDay = 0;
X		numberOfDays = 6;	/* test is <= */
X		startLoop = 0;
X		/*
X		 * Get the map for this year
X		 */
X		me = GetWeeklyEntry();
X		/*
X		 * Title bar is from the resources
X		 */
X		strcpy(titlestr, iconName);
X		/*
X		 * see if we will need to worry about marking today's entry
X		 */
X		if (appResources.markToday)
X			markThisMonth = True;
X		break;
X	}
X	/*
X	 * Find size of title bar by creating the widget and then throwing it
X	 * away
X	 */
X	DoTemplate(tbuf, sizeof tbuf, appResources.stripfmt);
X	XtSetArg(args[0], XtNlabel, tbuf);
X	lw = XtCreateManagedWidget("sizer", labelWidgetClass, shell, args, 1);
X	XtSetArg(args[0], XtNwidth, &totalWidth);
X	XtGetValues(lw, args, 1);
X	XtDestroyWidget(lw);
X	/*
X	 * Width is affected by a resource value
X	 */
X	if (appResources.minstripwidth && appResources.minstripwidth > totalWidth)
X		totalWidth = appResources.minstripwidth;
X	/*
X	 * Now set the title bar should we need it
X	 */
X	if (appResources.useWmTitle) {
X		XtSetArg(args[0], XtNlabel, XtNewString(titlestr));
X		lw =  XtCreateManagedWidget("header", labelWidgetClass, mon, args, 1);
X		hdrHeight = wHeight(lw);
X	}
X	/*
X	 * Action bar
X	 */
X	nargs = 0;
X	argLD(XtNshowGrip, False);
X	argLD(XtNdefaultDistance, 2);
X	dw = XtCreateManagedWidget("action", formWidgetClass, mon, args, nargs);
X
X	switch (type) {
X	case ME_MONTHLY:
X		hdrHeight += CreateActionBar(shell, dw, mon, td);
X		break;
X	case ME_WEEKLY:
X		hdrHeight += CreateWeeklyActionBar(shell, dw);
X		break;
X	}
X	
X	/*
X	 * Create a Viewport, with a panel inside it
X	 */
X	nargs = 0;
X	argLD(XtNshowGrip, False);
X	argLD(XtNallowVert, True);
X	monvp = XtCreateManagedWidget("viewport", viewportWidgetClass, mon, args, nargs);
X	mondt = XtCreateManagedWidget("panel", panedWidgetClass, monvp, NULL, 0);
X
X
X#ifdef	LONG_IS_32_BITS
X	callbacks[0].callback = DayBack;
X#else
X	callbacks[0].callback = YmBack;
X	callbacks[1].callback = DayBack;
X#endif
X	totalHeight = 0;
X	for (i = startLoop; i <= numberOfDays; i++) {
X		dayStr = appResources.sday[thisDay];
X		switch (type) {
X		case ME_MONTHLY:
X			(void) sprintf(titlestr, "%2d %s", i, dayStr);
X			break;
X		case ME_WEEKLY:
X			(void) strcpy(titlestr, dayStr);
X			break;
X		}
X#ifdef LONG_IS_32_BITS
X		callbacks[0].closure = (caddr_t) DatePack(thisDay, i, td->month, td->year);
X#else
X		callbacks[0].closure = (caddr_t) DatePack(td->month, td->year);
X		callbacks[1].closure = (caddr_t) DayPack(thisDay, i);
X#endif
X
X		thisDay = (thisDay + 1) % 7;
X
X		/*
X		 * Each line in the strip is form containing label - command
X		 */
X		nargs = 0;
X		argLD(XtNshowGrip, False);
X		argLD(XtNdefaultDistance, 0);
X		form = XtCreateManagedWidget(dayStr, formWidgetClass, mondt, args, nargs);
X
X		nargs = 0;
X		argLD(XtNlabel, XtNewString(titlestr));
X		/* a little naughty here */
X		/* this string memory is lost */
X		/* on quit */
X		argLD(XtNborderWidth, 0);
X		argLD(XtNjustify, XtJustifyLeft);
X		argLD(XtNfromHoriz, NULL);
X		argLD(XtNleft, XtChainLeft);
X		argLD(XtNright, XtChainLeft);
X
X		ins->i_day_label[i] = lw = XtCreateManagedWidget("label", labelWidgetClass, form, args, nargs);
X
X		/*
X		 * To get a handle on the old values which are lost by
X		 * highlighting we get them after we have created the widget.
X		 * Then we highlight today.
X		 */
X		if (markThisMonth &&
X		    ((type == ME_MONTHLY && today.day == i) ||
X		     (type == ME_WEEKLY && today.wday == i))) {
X			nargs = 0;
X			argLD(XtNforeground, &ins->i_col.fg);
X			argLD(XtNbackground, &ins->i_col.bg);
X			argLD(XtNfont, &ins->i_font);
X			XtGetValues(lw, args, nargs);
X
X			nargs = 0;
X			argLD(XtNforeground, appResources.today.fg);
X			argLD(XtNbackground, appResources.today.bg);
X			argLD(XtNfont, appResources.fontToday);
X			XtSetValues(lw, args, nargs);
X		}
X		/*
X		 * Done the first time through
X		 * Gets the width of the line we have just made
X		 */
X		if (defaultsAreSet == False) {	/* compute text width */
X			nargs = 0;
X			argLD(XtNwidth, &width);
X			argLD(XtNheight, &labelH);
X			XtGetValues(lw, args, nargs);
X			defaultsAreSet = True;
X		}
X		/*
X		 * Start processing the RHS of the line
X		 * This contains text from the file should any exist
X		 */
X		nargs = 0;
X		argLD(XtNborderWidth, 0);
X		argLD(XtNcallback, callbacks);
X		argLD(XtNfromHoriz, lw);
X		argLD(XtNleft, XtChainLeft);
X		argLD(XtNright, XtChainRight);
X		argLD(XtNjustify, XtJustifyLeft);
X		argLD(XtNwidth, totalWidth - width);
X
X		if (me->me_have[i]) {
X			argLD(XtNlabel, me->me_have[i]);
X		} else {
X			argLD(XtNlabel, "    ");
X		}
X		ins->i_day_info[i] = lwi = XtCreateManagedWidget("info", commandWidgetClass, form, args, nargs);
X
X		/* add translations */
X		if (but2 == NULL) {
X			but2 = XtParseTranslationTable(defTranslations);
X		}
X		XtAugmentTranslations(lwi, but2);
X
X		/* deal with height */
X		infoH = wHeight(lwi);
X		if (labelH < infoH) {
X			SetWidgetHeightMax(lw, labelH, infoH);
X			totalHeight += infoH + 1;
X		} else if (labelH > infoH) {
X			SetWidgetHeightMax(lwi, infoH, labelH);
X			totalHeight += labelH + 1;
X		}
X		/*
X		 * cope with 1752
X		 */
X		if (td->year == 1752 && td->month == 8 && i == 2) {
X			i = 13;
X			numberOfDays += 11;	/* giving back the 11 days */
X		}
X	}
X	ClearCallbacks();
X
X	/* set up size for viewport scrolling */
X	setStripMax(monvp, totalHeight, hdrHeight);
X
X	/* here we go */
X	XtPopup(shell, XtGrabNone);
X}
X
X/*
X * Get the height of the specified widget
X */
XDimension
XwHeight(w)
X	Widget	w;
X{
X	Arg		args[1];
X	Dimension	H;
X
X	XtSetArg(args[0], XtNheight, &H);
X	XtGetValues(w, args, 1);
X	return H;
X}
X
X/*
X * Set the max size of the viewport for the strip
X */
Xstatic void
XsetStripMax(w, stripHeight, hdrHeight)
X	Widget	w;
X	Dimension stripHeight;
X	Dimension hdrHeight;
X{
X	Dimension	maxH;
X	Arg             args[1];
X
X	if (appResources.maxstripheight == 0) {
X		/* remove the hdrHeight here as a guess */
X		maxH = HeightOfScreen(XtScreen(toplevel));
X		maxH -= hdrHeight;
X	}	
X	else	maxH = appResources.maxstripheight;
X	maxH -= hdrHeight + 20;
X	if (stripHeight > maxH) {
X		XtSetArg(args[0], XtNheight, maxH);
X		XtSetValues(w, args, 1);
X	}
X}
X/*
X * Create action bar for normal monthly strip
X */
Xstatic Dimension
XCreateActionBar(shell, dw, mon, td)
X	Widget          shell;
X	Widget          dw;
X	Widget          mon;
X	Date           *td;
X{
X	Widget          lw;
X	register Cardinal nargs;
X	Arg             args[8];
X	Dimension	ht, maxht = 0;
X
X	/*
X	 * back one month label "<" from resources
X	 */
X	callbacks[0].callback = MakeNewMonth;
X	callbacks[0].closure = (caddr_t) DateSum(td, -1);
X	nargs = 0;
X	argLD(XtNcallback, callbacks);
X	argLD(XtNfromHoriz, NULL);
X	argLD(XtNleft, XtChainLeft);
X	argLD(XtNright, XtChainLeft);
X	lw = XtCreateManagedWidget("back", commandWidgetClass, dw, args, nargs);
X	maxht = wHeight(lw);
X	maxht++;
X	ClearCallbacks();
X
X	/*
X	 * Quit button label "quit" from resources
X	 */
X	callbacks[0].callback = StripQuit;
X	callbacks[0].closure = (caddr_t) shell;
X	nargs = 0;
X	argLD(XtNcallback, callbacks);
X	argLD(XtNfromHoriz, lw);
X	argLD(XtNleft, XtChainLeft);
X	argLD(XtNright, XtChainRight);
X	lw = XtCreateManagedWidget("quit", commandWidgetClass, dw, args, nargs);
X	ht = wHeight(lw);
X	maxht = ht > maxht ? ht : maxht;
X	ClearCallbacks();
X
X	/*
X	 * On one month label ">" from resources
X	 */
X	callbacks[0].callback = MakeNewMonth;
X	callbacks[0].closure = (caddr_t) DateSum(td, 1);
X	nargs = 0;
X	argLD(XtNcallback, callbacks);
X	argLD(XtNfromHoriz, lw);
X	argLD(XtNleft, XtChainRight);
X	argLD(XtNright, XtChainRight);
X	lw = XtCreateManagedWidget("next", commandWidgetClass, dw, args, nargs);
X	ht = wHeight(lw);
X	maxht = ht > maxht ? ht : maxht;
X	ClearCallbacks();
X
X	/*
X	 * Help button label help from resources
X	 */
X	if (appResources.giveHelp) {
X		callbacks[0].callback = StripHelp;
X		callbacks[0].closure = (caddr_t) 0;
X		nargs = 0;
X		argLD(XtNcallback, callbacks);
X		argLD(XtNshowGrip, False);
X		lw = XtCreateManagedWidget("help", commandWidgetClass, mon, args, nargs);
X		maxht += wHeight(lw);
X		ClearCallbacks();
X	}
X	return maxht;
X}
X
X/*
X * Create action bar for normal monthly strip
X */
Xstatic Dimension
XCreateWeeklyActionBar(shell, dw)
X	Widget          shell;
X	Widget          dw;
X{
X	Widget          lw;
X	register Cardinal nargs;
X	Arg             args[8];
X	Dimension	ht, maxht = 0;
X
X	/*
X	 * Quit button label "quit" from resources
X	 */
X	callbacks[0].callback = StripQuit;
X	callbacks[0].closure = (caddr_t) shell;
X	nargs = 0;
X	argLD(XtNcallback, callbacks);
X	argLD(XtNfromHoriz, NULL);
X	argLD(XtNleft, XtChainLeft);
X	argLD(XtNright, appResources.giveHelp ? XtChainLeft : XtChainRight);
X	lw = XtCreateManagedWidget("quit", commandWidgetClass, dw, args, nargs);
X	maxht = wHeight(lw);
X	ClearCallbacks();
X
X	/*
X	 * Help button label help from resources
X	 */
X	if (appResources.giveHelp) {
X		callbacks[0].callback = WeeklyHelp;
X		callbacks[0].closure = (caddr_t) 0;
X		nargs = 0;
X		argLD(XtNcallback, callbacks);
X		argLD(XtNfromHoriz, lw);
X		argLD(XtNleft, XtChainLeft);
X		argLD(XtNright, XtChainRight);
X		lw = XtCreateManagedWidget("help", commandWidgetClass, dw, args, nargs);
X		ht = wHeight(lw);
X		maxht = ht > maxht ? ht : maxht;
X		ClearCallbacks();
X	}
X	return maxht;
X}
X
X/*
X * Called when the date changes to ensure that the correct day has the
X * appropriate highlights
X */
Xvoid
XChangeHighlight(old, new)
X	Date           *old;
X	Date           *new;
X{
X	register Instance *ins;
X	Arg             args[5];
X	Cardinal        nargs;
X
X	for (ins = FindInstanceList(old); ins; ins = ins->i_next) {
X		nargs = 0;
X		argLD(XtNforeground, ins->i_col.fg);
X		argLD(XtNbackground, ins->i_col.bg);
X		argLD(XtNfont, ins->i_font);
X		XtSetValues(ins->i_day_label[old->day], args, nargs);
X	}
X
X	for (ins = FindInstanceList(new); ins; ins = ins->i_next) {
X		nargs = 0;
X		argLD(XtNforeground, &ins->i_col.fg);
X		argLD(XtNbackground, &ins->i_col.bg);
X		argLD(XtNfont, &ins->i_font);
X		XtGetValues(ins->i_day_label[new->day], args, nargs);
X
X		nargs = 0;
X		argLD(XtNforeground, appResources.today.fg);
X		argLD(XtNbackground, appResources.today.bg);
X		argLD(XtNfont, appResources.fontToday);
X		XtSetValues(ins->i_day_label[new->day], args, nargs);
X	}
X}
X
X/*
X * Called when middle mouse button is clicked on a date box
X * This gets the current selection and adds it to the file
X * corresponding to the day.
X * This allows quick data loading
X */
Xvoid
XLoadDateStrip(w, event, params, numb)
X        Widget        	w;
X        XSelectionEvent *event;
X        String         *params;
X        Cardinal       *numb;
X{
X
X	/* set up to get the selection */
X	/* I am unconvinced that it should be this easy */
X	XtGetSelectionValue(w, XA_PRIMARY, XA_STRING,
X			LoadDateCallback, 0, XtLastTimestampProcessed(XtDisplay(w)));
X	/* The work is done in the callback routine */
X}
X
Xstatic void
XLoadDateCallback(w, xcd, sel, seltype, val, len, fmt)
X	Widget		w;
X	XtPointer	xcd;
X	Atom		*sel;
X	Atom		*seltype;
X	XtPointer	val;
X	unsigned long	*len;
X	int		*fmt;	
X{	
X	String		s;
X	int		n;
X	Arg             args[1];
X	Cardinal	v;
X	XtCallbackRec	*cb;
X	Date		da;
X
X	/* deal with arguments to get the text */
X	if (*seltype != XA_STRING)
X		n = 0;
X	else
X		n = (*len) * (*fmt/8);
X	if (n == 0)
X		return;
X
X	s = (String) XtMalloc(n+1);
X	if (n > 0)
X		memcpy(s, (char *)val, n);
X	s[n] = 0;
X	XtFree(val);
X
X	/* get closure data to find the date */
X	XtSetArg(args[0], XtNcallback, &cb);
X	XtGetValues(w, args, 1);
X	v = (Cardinal) cb->closure;
X	da.month = MoUnpack(v),
X	da.year = YrUnpack(v);
X#ifndef LONG_IS_32_BITS
X	cb++;
X	v = (Cardinal) cb->closure;
X#endif
X	da.day = DyUnpack(v);
X	da.wday = WdUnpack(v);
X	/* Add text to day file (code in xcal_edit.c) */
X	AppendText(w, &da, s);
X}
X
X
X/*
X * Call back from a quit button to lose a month strip
X */
X/* ARGSUSED */
Xstatic void
XStripQuit(w, closure, call_data)
X	Widget          w;
X	caddr_t         closure;
X	caddr_t         call_data;
X{
X	XtPopdown((Widget) closure);
X	XtDestroyWidget((Widget) closure);
X}
X
X
X/*
X * Month arithmetic and packing
X */
Xstatic          Cardinal
XDateSum(td, inx)
X	Date           *td;
X	int             inx;
X{
X	int             m, y;
X
X	m = td->month;
X	y = td->year;
X	m += inx;
X	if (m < 0) {
X		m = 11;
X		y--;
X	} else if (m > 11) {
X		m = 0;
X		y++;
X	}
X#ifdef LONG_IS_32_BITS
X	return (DatePack(0, 0, m, y));
X#else
X	return (DatePack(m, y));
X#endif
X}
X
X/*
X * Call back from day selection button press
X * This is done in two stages if cannot fold dates into a closure
X */
X/* ARGSUSED */
Xstatic void
XDayBack(w, closure, call_data)
X	Widget          w;
X	caddr_t         closure;
X	caddr_t         call_data;
X{
X#ifdef LONG_IS_32_BITS
X	callb.month = MoUnpack((Cardinal) closure);
X	callb.year = YrUnpack((Cardinal) closure);
X#endif
X	callb.day = DyUnpack((Cardinal) closure);
X	callb.wday = WdUnpack((Cardinal) closure);
X	StartEditing(w, &callb, NULL);
X}
X
X#ifndef LONG_IS_32_BITS
X/* ARGSUSED */
Xstatic void
XYmBack(w, closure, call_data)
X	Widget          w;
X	caddr_t         closure;
X	caddr_t         call_data;
X{
X	callb.month = MoUnpack((Cardinal) closure);
X	callb.year = YrUnpack((Cardinal) closure);
X}
X#endif
END_OF_FILE
if test 18555 -ne `wc -c <'xcal_strip.c'`; then
    echo shar: \"'xcal_strip.c'\" unpacked with wrong size!
fi
# end of 'xcal_strip.c'
fi
echo shar: End of archive 6 \(of 8\).
cp /dev/null ark6isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 8 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga: The only way to fly!  |    sources-x@sterling.com
       "It's intuitively obvious to the most casual observer..."
 GCS d++(--) -p+ c++ !l u++ e+ m+(-) s++/++ n h--- f+ g+++ w+ t++ r+ y+
