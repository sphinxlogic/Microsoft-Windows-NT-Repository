Newsgroups: comp.sources.x
From: ti@bazooka.amb.org (Ti Kan)
Subject: v21i067:  xmcd - X11/Motif CD audio player, Part05/13
Message-ID: <1993Dec19.193858.24134@sparky.sterling.com>
X-Md4-Signature: f07164860bf24267ecbffa5fc9896db8
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Sun, 19 Dec 1993 19:38:58 GMT
Approved: chris@sterling.com

Submitted-by: ti@bazooka.amb.org (Ti Kan)
Posting-number: Volume 21, Issue 67
Archive-name: xmcd/part05
Environment: X11, OSF/Motif

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 5 (of 13)."
# Contents:  cdfunc.c
# Wrapped by ti@bazooka on Mon Nov  8 10:35:20 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'cdfunc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cdfunc.c'\"
else
echo shar: Extracting \"'cdfunc.c'\" \(55680 characters\)
sed "s/^X//" >'cdfunc.c' <<'END_OF_FILE'
X/*
X *   xmcd - Motif(tm) CD Audio Player
X *
X *   Copyright (C) 1993  Ti Kan
X *   E-mail: ti@amb.org
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 2 of the License, or
X *   (at your option) any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X */
X#ifndef LINT
Xstatic char *_cdfunc_c_ident_ = "@(#)cdfunc.c	1.150 93/09/28";
X#endif
X
X#include <X11/keysym.h>
X#include <Xm/Xm.h>
X#include <Xm/MessageB.h>
X#include "xmcd.h"
X#include "patchlevel.h"
X#include "widget.h"
X#include "dbprog.h"
X#include "hotkey.h"
X#include "help.h"
X#include "util.h"
X#include "cdlib.h"
X#include "cdfunc.h"
X
X
X/* Callback info structure */
Xtypedef struct {
X	Widget		widget;
X	String		type;
X	XtCallbackProc	func;
X	XtPointer	data;
X} cbinfo_t;
X
X
Xextern widgets_t	widgets;
Xextern pixmaps_t	pixmaps;
Xextern AppData		app_data;
Xextern bool_t		exit_flag;
X
Xuid_t			ouid;			/* Original uid of user */
Xchar			**dbdirs = NULL;	/* Database directories */
XSTATIC char		keystr[3],		/* Keypad number string */
X			lockfile[40];		/* Lock file path */
XSTATIC int		tm_blinkid = -1,	/* Time dpy blink timer ID */
X			ab_blinkid = -1;	/* A->B dpy blink timer ID */
XSTATIC bool_t		devbusy = FALSE,	/* Device busy flag */
X			searching = FALSE,	/* Running REW or FF */
X			btnlbl_state = FALSE,	/* Button label state */
X			lock_state = FALSE,	/* Caddy lock state */
X			repeat_state = FALSE,	/* Repeat mode state */
X			shuffle_state = FALSE;	/* Shuffle mode state */
X
X
X/*
X * curtrk_pos
X *	Return the trkinfo table offset location of the current playing
X *	CD track.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	Integer offset into the trkinfo table, or -1 if not currently
X *	playing audio.
X */
Xint
Xcurtrk_pos(curstat_t *s)
X{
X	int	i;
X
X	i = (int) s->cur_trk - 1;
X	if (s->trkinfo[i].trkno == s->cur_trk)
X		return(i);
X
X	for (i = 0; i < MAXTRACK; i++) {
X		if (s->trkinfo[i].trkno == s->cur_trk)
X			return(i);
X	}
X	return(-1);
X}
X
X
X/*
X * curprog_pos
X *	Return an integer representing the position of the current
X *	program or shuffle mode playing order (0 = first, 1 = second, ...).
X *	This routine should be used only when in program or shuffle play
X *	mode.
X *
X * Arg:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	An integer representing the position of the current program
X *	or shuffle mode playing order, or -1 if not in the appropriate mode.
X */
Xint
Xcurprog_pos(curstat_t *s)
X{
X	return((int) s->playorder[s->prog_cnt]);
X}
X
X
X/*
X * curtrk_type
X *	Return the track type of the currently playing track.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	TYP_AUDIO or TYP_DATA.
X */
Xbyte_t
Xcurtrk_type(curstat_t *s)
X{
X	sword32_t	i;
X
X	if ((i = curtrk_pos(s)) >= 0)
X		return(s->trkinfo[i].type);
X
X	return(TYP_AUDIO);
X}
X
X
X/*
X * track_rtime
X *	Return the remaining time of the current playing track in seconds.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	The track remaining time in seconds.
X */
XSTATIC sword32_t
Xtrack_rtime(curstat_t *s)
X{
X	sword32_t	i,
X			secs,
X			tot_sec,
X			cur_sec;
X
X	if ((i = curtrk_pos(s)) < 0)
X		return(0);
X
X	tot_sec = (s->trkinfo[i+1].min * 60 + s->trkinfo[i+1].sec) -
X		  (s->trkinfo[i].min * 60 + s->trkinfo[i].sec);
X	cur_sec = s->cur_trk_min * 60 + s->cur_trk_sec;
X	secs = tot_sec - cur_sec;
X
X	return((secs >= 0) ? secs : 0);
X}
X
X
X/*
X * disc_rtime_norm
X *	Return the remaining time of the disc in seconds.  This is
X *	used during normal playback.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	The disc remaining time in seconds.
X */
XSTATIC sword32_t
Xdisc_rtime_norm(curstat_t *s)
X{
X	sword32_t	secs;
X
X	secs = (s->tot_min * 60 + s->tot_sec) -
X		(s->cur_tot_min * 60 + s->cur_tot_sec);
X
X	return((secs >= 0) ? secs : 0);
X}
X
X
X/*
X * disc_rtime_prog
X *	Return the remaining time of the disc in seconds.  This is
X *	used during shuffle or program mode.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	The disc remaining time in seconds.
X */
XSTATIC sword32_t
Xdisc_rtime_prog(curstat_t *s)
X{
X	sword32_t	i,
X			secs = 0;
X
X	/* Find the time of all unplayed tracks */
X	for (i = s->prog_cnt; i < (int) s->prog_tot; i++) {
X		secs += ((s->trkinfo[s->playorder[i]+1].min * 60 +
X			 s->trkinfo[s->playorder[i]+1].sec) -
X		         (s->trkinfo[s->playorder[i]].min * 60 +
X			 s->trkinfo[s->playorder[i]].sec));
X	}
X
X	/* FInd the remaining time of the current track */
X	for (i = 0; i < MAXTRACK; i++) {
X		if (s->trkinfo[i].trkno == LEAD_OUT_TRACK)
X			break;
X
X		if (s->trkinfo[i].trkno == s->cur_trk) {
X			secs += ((s->trkinfo[i+1].min * 60 +
X				  s->trkinfo[i+1].sec) -
X				 (s->cur_tot_min * 60 + s->cur_tot_sec));
X
X			break;
X		}
X	}
X
X	return((secs >= 0) ? secs : 0);
X}
X
X
X/*
X * devspec_init
X *	Read the specified device-specific configuration file and
X *	initialize parameters.
X *
X * Args:
X *	path - Path name to the file to read.
X *	priv - Whether the privileged keywords are to be recognized.
X *
X * Return:
X *	Nothing.
X */
XSTATIC void
Xdevspec_init(char *path, bool_t priv)
X{
X	FILE	*fp;
X	char	buf[STR_BUF_SZ],
X		parm[12];
X
X	if ((fp = fopen(path, "r")) != NULL) {
X		/* Read in device-specific parameters */
X		while (fgets(buf, sizeof(buf), fp) != NULL) {
X			/* Skip comments */
X			if (buf[0] == '#' || buf[0] == '!' || buf[0] == '\n')
X				continue;
X
X			/* These are privileged parameters and users
X			 * cannot overide them in their .xmcdcfg file.
X			 */
X			if (priv) {
X				if (sscanf(buf, "logicalDriveNumber: %s\n",
X					   parm) > 0) {
X					app_data.devnum = atoi(parm);
X					continue;
X				}
X				if (sscanf(buf, "driveVendorCode: %s\n",
X					   parm) > 0) {
X					app_data.vendor_code = atoi(parm);
X					continue;
X				}
X				if (sscanf(buf, "playAudio12Support: %s\n",
X					   parm) > 0) {
X					app_data.play12_supp = stob(parm);
X					continue;
X				}
X				if (sscanf(buf, "playAudioMSFSupport: %s\n",
X					   parm) > 0) {
X					app_data.playmsf_supp = stob(parm);
X					continue;
X				}
X				if (sscanf(buf, "playAudio10Support: %s\n",
X					   parm) > 0) {
X					app_data.play10_supp = stob(parm);
X					continue;
X				}
X				if (sscanf(buf, "playAudioTISupport: %s\n",
X					   parm) > 0) {
X					app_data.playti_supp = stob(parm);
X					continue;
X				}
X				if (sscanf(buf, "loadSupport: %s\n",
X					   parm) > 0) {
X					app_data.load_supp = stob(parm);
X					continue;
X				}
X				if (sscanf(buf, "ejectSupport: %s\n",
X					   parm) > 0) {
X					app_data.eject_supp = stob(parm);
X					continue;
X				}
X				if (sscanf(buf, "volumeControlSupport: %s\n",
X					   parm) > 0) {
X					app_data.mselvol_supp = stob(parm);
X					continue;
X				}
X				if (sscanf(buf, "volumeControlSetDBD: %s\n",
X					   parm) > 0) {
X					app_data.mselvol_dbd = stob(parm);
X					continue;
X				}
X				if (sscanf(buf, "scsiAudioVolumeBase: %s\n",
X					   parm) > 0) {
X					app_data.base_scsivol = atoi(parm);
X					continue;
X				}
X				if (sscanf(buf, "pauseResumeSupport: %s\n",
X					   parm) > 0) {
X					app_data.pause_supp = stob(parm);
X					continue;
X				}
X				if (sscanf(buf, "caddyLockSupport: %s\n",
X					   parm) > 0) {
X					app_data.caddylock_supp = stob(parm);
X					continue;
X				}
X				if (sscanf(buf, "minimumPlayBlocks: %s\n",
X					   parm) > 0) {
X					app_data.min_playblks = atoi(parm);
X					continue;
X				}
X			}
X
X			/* These are general parameters that can be
X			 * changed by the user.
X			 */
X			if (sscanf(buf, "volumeControlTaper: %s\n",
X				   parm) > 0) {
X				app_data.vol_taper = atoi(parm);
X				continue;
X			}
X			if (sscanf(buf, "spinDownOnLoad: %s\n",
X				   parm) > 0) {
X				app_data.load_spindown = stob(parm);
X				continue;
X			}
X			if (sscanf(buf, "ejectOnExit: %s\n",
X				   parm) > 0) {
X				app_data.exit_eject = stob(parm);
X				continue;
X			}
X			if (sscanf(buf, "stopOnExit: %s\n",
X				   parm) > 0) {
X				app_data.exit_stop = stob(parm);
X				continue;
X			}
X		}
X
X		fclose(fp);
X	}
X
X	if (priv) {
X		/* If the drive does not support software eject, then we
X		 * can't lock the caddy.
X		 */
X		if (!app_data.eject_supp)
X			app_data.caddylock_supp = FALSE;
X
X		/* If the drive does not support locking the caddy, don't
X		 * attempt to lock it.
X		 */
X		if (!app_data.caddylock_supp)
X			app_data.caddy_lock = FALSE;
X	}
X}
X
X
X/*
X * dpy_track
X *	Update the track number display region of the main window.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	Nothing
X */
Xvoid
Xdpy_track(curstat_t *s)
X{
X	XmString	xs;
X	char		str[4];
X	static char	prev[4] = { '\0' };
X	static int	sav_trk = -1;
X
X
X	if (s->cur_trk != sav_trk)
X		/* Update database/program window current track display */
X		dbprog_curtrkupd(s);
X
X	sav_trk = s->cur_trk;
X
X	if (s->cur_trk <= 0 || s->mode == M_NODISC)
X		strcpy(str, "-");
X	else if (s->time_dpy == T_REMAIN_DISC) {
X		if (s->shuffle || s->program)
X			sprintf(str, "-%d", s->prog_tot - s->prog_cnt);
X		else
X			sprintf(str, "-%d", s->tot_trks - curtrk_pos(s) - 1);
X	}
X	else
X		sprintf(str, "%d", s->cur_trk);
X
X	if (strcmp(str, prev) == 0)
X		/* No change, just return */
X		return;
X
X	xs = XmStringCreateSimple(str);
X
X	XtVaSetValues(
X		widgets.main.track_ind,
X		XmNlabelString,
X		xs,
X		NULL
X	);
X
X	XmStringFree(xs);
X
X	strcpy(prev, str);
X}
X
X
X/*
X * dpy_index
X *	Update the index number display region of the main window.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	Nothing
X */
Xvoid
Xdpy_index(curstat_t *s)
X{
X	XmString	xs;
X	char		str[4];
X	static char	prev[4] = { '\0' };
X
X	if (s->cur_idx <= 0 || s->mode == M_NODISC || s->mode == M_STOP)
X		strcpy(str, "-");
X	else
X		sprintf(str, "%d", s->cur_idx);
X
X	if (strcmp(str, prev) == 0)
X		/* No change, just return */
X		return;
X
X	xs = XmStringCreateSimple(str);
X
X	XtVaSetValues(
X		widgets.main.index_ind,
X		XmNlabelString,
X		xs,
X		NULL
X	);
X
X	XmStringFree(xs);
X
X	strcpy(prev, str);
X}
X
X
X/*
X * dpy_time
X *	Update the time display region of the main window.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *	blank - Whether the display region should be blanked.
X *
X * Return:
X *	Nothing
X */
Xvoid
Xdpy_time(curstat_t *s, bool_t blank)
X{
X	sword32_t	time_sec;
X	XmString	xs;
X	char		str[12];
X	static char	prev[12];
X
X	if (blank)
X		str[0] = '\0';
X	else if (s->mode == M_NODISC) {
X		if (devbusy)
X			strcpy(str, app_data.str_busy);
X		else
X			strcpy(str, app_data.str_nodisc);
X	}
X	else if (s->mode == M_STOP)
X		strcpy(str, " --:--");
X	else if (curtrk_type(s) == TYP_DATA)
X		strcpy(str, app_data.str_data);
X	else {
X		switch (s->time_dpy) {
X		case T_ELAPSED:
X			sprintf(str, "%s%02u:%02u",
X				(s->cur_idx == 0) ? "-" : "+",
X				s->cur_trk_min,
X				s->cur_trk_sec);
X			break;
X
X		case T_REMAIN_TRACK:
X			time_sec = track_rtime(s);
X
X			sprintf(str, "-%02u:%02u",
X				time_sec / 60, time_sec % 60);
X			break;
X
X		case T_REMAIN_DISC:
X			if (s->shuffle || s->program) {
X				if (s->cur_idx == 0) {
X					strcpy(str, " --:--");
X					break;
X				}
X				else
X					time_sec = disc_rtime_prog(s);
X			}
X			else
X				time_sec = disc_rtime_norm(s);
X
X			sprintf(str, "-%02u:%02u",
X				time_sec / 60, time_sec % 60);
X			break;
X
X		default:
X			strcpy(str, "??:??");
X			break;
X		}
X	}
X
X	if (strcmp(str, prev) == 0)
X		/* No change: just return */
X		return;
X
X	xs = XmStringCreateSimple(str);
X
X	XtVaSetValues(
X		widgets.main.time_ind,
X		XmNlabelString,
X		xs,
X		NULL
X	);
X
X	XmStringFree(xs);
X
X	strcpy(prev, str);
X}
X
X
X/*
X * dpy_dbmode
X *	Update the cddb indicator of the main window.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	Nothing
X */
Xvoid
Xdpy_dbmode(curstat_t *s)
X{
X	String		str;
X	XmString	xs;
X	static bool_t	first = TRUE,
X			prev = FALSE;
X
X	if (!first && prev == s->cddb)
X		/* No change: just return */
X		return;
X
X	first = FALSE;
X
X	if (s->cddb)
X		str = app_data.str_dbmode;
X	else
X		str = "";
X
X	xs = XmStringCreateSimple(str);
X
X	XtVaSetValues(
X		widgets.main.dbmode_ind,
X		XmNlabelString,
X		xs,
X		NULL
X	);
X
X	XmStringFree(xs);
X
X	prev = s->cddb;
X}
X
X
X/*
X * dpy_progmode
X *	Update the prog indicator of the main window.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	Nothing
X */
Xvoid
Xdpy_progmode(curstat_t *s)
X{
X	String		str;
X	XmString	xs;
X	static bool_t	first = TRUE,
X			prev = FALSE;
X
X	if (!first && prev == s->program)
X		/* No change: just return */
X		return;
X
X	first = FALSE;
X
X	if (s->program)
X		str = app_data.str_progmode;
X	else
X		str = "";
X
X	xs = XmStringCreateSimple(str);
X
X	XtVaSetValues(
X		widgets.main.progmode_ind,
X		XmNlabelString,
X		xs,
X		NULL
X	);
X
X	XmStringFree(xs);
X
X	prev = s->program;
X}
X
X
X/*
X * dpy_timemode
X *	Update the time mode indicator of the main window.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	Nothing
X */
Xvoid
Xdpy_timemode(curstat_t *s)
X{
X	String		str;
X	XmString	xs;
X	static byte_t	prev = 0xff;
X
X	if (prev == s->time_dpy)
X		/* No change: just return */
X		return;
X
X	switch (s->time_dpy) {
X	case T_ELAPSED:
X		str = app_data.str_elapse;
X		break;
X
X	case T_REMAIN_TRACK:
X		str = app_data.str_remaintrk;
X		break;
X
X	case T_REMAIN_DISC:
X		str = app_data.str_remaindisc;
X		break;
X	}
X
X	xs = XmStringCreateSimple(str);
X
X	XtVaSetValues(
X		widgets.main.timemode_ind,
X		XmNlabelString,
X		xs,
X		NULL
X	);
X
X	XmStringFree(xs);
X
X	prev = s->time_dpy;
X}
X
X
X/*
X * dpy_playmode
X *	Update the play mode indicator of the main window.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	Nothing
X */
Xvoid
Xdpy_playmode(curstat_t *s, bool_t blank)
X{
X	char		*str;
X	XmString	xs;
X	static char	prev[10];
X
X	if (blank)
X		str = "";
X	else {
X		switch (s->mode) {
X		case M_PLAY:
X			str = app_data.str_play;
X			break;
X		case M_PAUSE:
X			str = app_data.str_pause;
X			break;
X		case M_STOP:
X			str = app_data.str_ready;
X			break;
X		case M_A:
X			str = "a->?";
X			break;
X		case M_AB:
X			str = "a->b";
X			break;
X		case M_SAMPLE:
X			str = app_data.str_sample;
X			break;
X		default:
X			str = "";
X			break;
X		}
X	}
X
X	if (strcmp(prev, str) == 0)
X		/* No change: just return */
X		return;
X
X	xs = XmStringCreateSimple(str);
X
X	XtVaSetValues(
X		widgets.main.playmode_ind,
X		XmNlabelString,
X		xs,
X		NULL
X	);
X
X	XmStringFree(xs);
X
X	strcpy(prev, str);
X
X	if (s->mode == M_A)
X		cd_ab_blink(s, TRUE);
X	else
X		cd_ab_blink(s, FALSE);
X}
X
X
X/*
X * dpy_all
X *	Update all indicator of the main window.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	Nothing
X */
Xvoid
Xdpy_all(curstat_t *s)
X{
X	dpy_dbmode(s);
X	dpy_progmode(s);
X	dpy_timemode(s);
X	dpy_playmode(s, FALSE);
X	dpy_track(s);
X	dpy_index(s);
X	dpy_time(s, FALSE);
X}
X
X
X/*
X * dpy_time_blink
X *	Make the time indicator region of the main window blink.
X *	This is used when the disc is paused.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	Nothing
X */
XSTATIC void
Xdpy_time_blink(curstat_t *s)
X{
X	static bool_t	bstate = TRUE;
X
X	if (bstate) {
X		tm_blinkid = cd_timeout(
X			app_data.blinkoff_interval,
X			dpy_time_blink,
X			(byte_t *) s
X		);
X		dpy_time(s, TRUE);
X	}
X	else {
X		tm_blinkid = cd_timeout(
X			app_data.blinkon_interval,
X			dpy_time_blink,
X			(byte_t *) s
X		);
X		dpy_time(s, FALSE);
X	}
X	bstate = !bstate;
X}
X
X
X/*
X * dpy_ab_blink
X *	Make the a->b indicator of the main window blink.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	Nothing
X */
XSTATIC void
Xdpy_ab_blink(curstat_t *s)
X{
X	static bool_t	bstate = TRUE;
X
X	if (bstate) {
X		ab_blinkid = cd_timeout(
X			app_data.blinkoff_interval,
X			dpy_ab_blink,
X			(byte_t *) s
X		);
X		dpy_playmode(s, TRUE);
X	}
X	else {
X		ab_blinkid = cd_timeout(
X			app_data.blinkon_interval,
X			dpy_ab_blink,
X			(byte_t *) s
X		);
X		dpy_playmode(s, FALSE);
X	}
X	bstate = !bstate;
X}
X
X
X/*
X * dpy_keypad_ind
X *	Update the digital track number indicator on the keypad window.
X *
X * Args:
X *	Nothing.
X *
X * Return:
X *	Nothing.
X */
XSTATIC void
Xdpy_keypad_ind(void)
X{
X	XmString	xs;
X
X	if (!XtIsManaged(widgets.keypad.form))
X		return;
X
X	xs = XmStringCreateSimple((keystr[0] == '\0') ? "--" : keystr);
X
X	XtVaSetValues(
X		widgets.keypad.keypad_ind,
X		XmNlabelString,
X		xs,
X		NULL
X	);
X
X	XmStringFree(xs);
X}
X
X
X/*
X * reset_curstat
X *	Reset the curstat_t structure to initial defaults.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *	clear_toc - Whether the trkinfo CD table-of-contents 
X *		should be cleared.
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xreset_curstat(curstat_t *s, bool_t clear_toc)
X{
X	sword32_t	i;
X	static bool_t	first_time = TRUE;
X
X	s->cur_trk = s->cur_idx = -1;
X	s->cur_tot_min = s->cur_tot_sec = s->cur_tot_frame = 0;
X	s->cur_trk_min = s->cur_trk_sec = s->cur_trk_frame = 0;
X	s->cur_tot_addr = s->cur_trk_addr = 0;
X	s->sav_iaddr = 0;
X	s->prog_tot = 0;
X	s->prog_cnt = 0;
X	s->program = FALSE;
X
X	if (clear_toc) {
X		s->mode = M_NODISC;
X		s->first_trk = s->last_trk = -1;
X		s->tot_min = s->tot_sec = 0;
X		s->tot_trks = 0;
X		s->tot_addr = 0;
X
X		for (i = 0; i < MAXTRACK; i++) {
X			s->trkinfo[i].trkno = -1;
X			s->trkinfo[i].min = 0;
X			s->trkinfo[i].sec = 0;
X			s->trkinfo[i].frame = 0;
X			s->trkinfo[i].addr = 0;
X			s->playorder[i] = -1;
X		}
X	}
X
X	if (first_time) {
X		/* These are to be initialized only once */
X		first_time = FALSE;
X
X		s->time_dpy = T_ELAPSED;
X		s->repeat = s->shuffle = FALSE;
X		s->cddb = FALSE;
X		s->level = 0;
X		s->caddy_lock = FALSE;
X		s->vendor[0] = '\0';
X		s->prod[0] = '\0';
X		s->revnum[0] = '\0';
X	}
X}
X
X
X/*
X * reset_shuffle
X *	Recompute a new shuffle play sequence.  Updates the playorder
X *	table in the curstat_t structure.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xreset_shuffle(curstat_t *s)
X{
X	sword32_t	i,
X			j,
X			n;
X
X	srand((unsigned) time(NULL));
X	s->prog_cnt = 0;
X	s->prog_tot = s->tot_trks;
X
X	for (i = 0; i < MAXTRACK; i++) {
X		if (i >= (int) s->prog_tot) {
X			s->playorder[i] = -1;
X			continue;
X		}
X
X		do {
X			n = rand() % (int) s->prog_tot;
X			for (j = 0; j < i; j++) {
X				if (n == s->playorder[j])
X					break;
X			}
X		} while (j < i);
X
X		s->playorder[i] = n;
X	}
X
X
X#ifdef DEBUG
X	fprintf(stderr, "Shuffle tracks: ");
X
X	for (i = 0; i < s->prog_tot; i++)
X		fprintf(stderr, "%d ", s->trkinfo[s->playorder[i]].trkno);
X
X	fprintf(stderr, "\n");
X#endif
X}
X
X
X/*
X * set_lock_btn
X *	Set the lock button state
X *
X * Args:
X *	state - TRUE=in, FALSE=out
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xset_lock_btn(bool_t state)
X{
X	XmToggleButtonSetState(
X		widgets.main.lock_btn, (int) state, (int) False
X	);
X	lock_state = state;
X}
X
X
X/*
X * set_repeat_btn
X *	Set the repeat button state
X *
X * Args:
X *	state - TRUE=in, FALSE=out
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xset_repeat_btn(bool_t state)
X{
X	XmToggleButtonSetState(
X		widgets.main.repeat_btn, (int) state, (int) False
X	);
X	repeat_state = state;
X}
X
X
X/*
X * set_shuffle_btn
X *	Set the shuffle button state
X *
X * Args:
X *	state - TRUE=in, FALSE=out
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xset_shuffle_btn(bool_t state)
X{
X	XmToggleButtonSetState(
X		widgets.main.shuffle_btn, (int) state, (int) False
X	);
X	shuffle_state = state;
X}
X
X
X/*
X * set_vol_slider
X *	Set the volume control slider position
X *
X * Args:
X *	percent - The percentage setting.
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xset_vol_slider(byte_t percent)
X{
X	XmScaleSetValue(widgets.main.level_scale, (int) percent);
X}
X
X
X/*
X * set_btn_lbltype
X *	Set the main window pushbuttons label type
X *
X * Args:
X *	type - BTN_PIXMAP or BTN_STRING.
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xset_btn_lbltype(byte_t type)
X{
X	type = (type == BTN_STRING) ? XmSTRING : XmPIXMAP;
X
X	XtVaSetValues(widgets.main.btnlbl_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.lock_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.repeat_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.shuffle_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.eject_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.poweroff_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.dbprog_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.help_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.time_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.ab_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.sample_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.keypad_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.playpause_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.stop_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.prevtrk_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.nexttrk_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.previdx_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.nextidx_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.rew_btn,
X		XmNlabelType, type,
X		NULL
X	);
X	XtVaSetValues(widgets.main.ff_btn,
X		XmNlabelType, type,
X		NULL
X	);
X}
X
X
X/*
X * set_btn_color
X *	Set the label color of a pushbutton widget
X *
X * Args:
X *	w - The pushbutton widget.
X *	px - The label pixmap, if applicable.
X *	color - The pixel value of the desired color.
X *
X * Return:
X *	Nothing.
X */
XSTATIC void
Xset_btn_color(Widget w, Pixmap px, Pixel color)
X{
X	unsigned char	labtype;
X
X	XtVaGetValues(w, XmNlabelType, &labtype, NULL);
X
X	if (labtype == XmPIXMAP)
X		XtVaSetValues(w, XmNlabelPixmap, px, NULL);
X	else
X		XtVaSetValues(w, XmNforeground, color, NULL);
X}
X
X
X/*
X * set_scale_color
X *	Set the indicator color of a scale widget
X *
X * Args:
X *	w - The scale widget.
X *	color - The pixel value of the desired color.
X *
X * Return:
X *	Nothing.
X */
XSTATIC void
Xset_scale_color(Widget w, Pixel color)
X{
X	XtVaSetValues(w, XmNforeground, color, NULL);
X}
X
X
X/*
X * taper_vol
X *	Translate the volume level based on the configured taper
X *	characteristics.
X *
X * Args:
X *	v - The linear volume value.
X *
X * Return:
X *	The curved volume value.
X */
Xint
Xtaper_vol(int v)
X{
X	switch (app_data.vol_taper) {
X	case 1:
X		/* inverse-squared taper */
X		return(MAX_VOL - (sqr(MAX_VOL - v) / MAX_VOL));
X	case 2:
X		/* squared taper */
X		return(sqr(v) / MAX_VOL);
X	case 0:
X	default:
X		/* linear taper */
X		return(v);
X	}
X	/*NOTREACHED*/
X}
X
X
X/*
X * untaper_vol
X *	Translate the volume level based on the configured taper
X *	characteristics.
X *
X * Args:
X *	v - The curved volume value.
X *
X * Return:
X *	The linear volume value.
X */
Xint
Xuntaper_vol(int v)
X{
X	switch (app_data.vol_taper) {
X	case 1:
X		/* inverse-squared taper */
X		return(MAX_VOL - isqrt(sqr(MAX_VOL) - (MAX_VOL * v)));
X	case 2:
X		/* squared taper */
X		return(isqrt(v) * 10);
X	case 0:
X	default:
X		/* linear taper */
X		return(v);
X	}
X	/*NOTREACHED*/
X}
X
X
X/*
X * cd_timeout
X *	Alarm clock callback facility
X *
X * Args:
X *	msec - When msec milliseconds has elapsed, the callback
X *		occurs.
X *	handler - Pointer to the callback function.
X *	arg - An argument passed to the callback function.
X *
X * Return:
X *	An integer timeout ID.
X */
Xint
Xcd_timeout(word32_t msec, void (*handler)(), byte_t *arg)
X{
X	return((int)
X		XtAppAddTimeOut(
X			XtWidgetToApplicationContext(widgets.toplevel),
X			(unsigned long) msec,
X			(XtTimerCallbackProc) handler,
X			(XtPointer) arg
X		)
X	);
X}
X
X
X/*
X * cd_untimeout
X *	Cancel a pending alarm configured with cd_timeout.
X *
X * Args:
X *	id - The timeout ID
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xcd_untimeout(int id)
X{
X	XtRemoveTimeOut((XtIntervalId) id);
X}
X
X
X/*
X * cd_beep
X *	Beep the workstation speaker.
X *
X * Args:
X *	Nothing.
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xcd_beep(void)
X{
X	XBell(XtDisplay(widgets.toplevel), 50);
X}
X
X
X/*
X * cd_pause_blink
X *	Disable or enable the time indicator blinking.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *	enable - TRUE: start blink, FALSE: stop blink
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xcd_pause_blink(curstat_t *s, bool_t enable)
X{
X	static bool_t	blinking = FALSE;
X
X	if (enable) {
X		if (!blinking) {
X			/* Start time display blink */
X			blinking = TRUE;
X			dpy_time_blink(s);
X		}
X	}
X	else if (blinking) {
X		/* Stop time display blink */
X		cd_untimeout(tm_blinkid);
X
X		tm_blinkid = -1;
X		blinking = FALSE;
X	}
X}
X
X
X/*
X * cd_ab_blink
X *	Disable or enable the a->b indicator blinking.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *	enable - TRUE: start blink, FALSE: stop blink
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xcd_ab_blink(curstat_t *s, bool_t enable)
X{
X	static bool_t	blinking = FALSE;
X
X	if (enable) {
X		if (!blinking) {
X			/* Start A->B display blink */
X			blinking = TRUE;
X			dpy_ab_blink(s);
X		}
X	}
X	else if (blinking) {
X		/* Stop A->B display blink */
X		cd_untimeout(ab_blinkid);
X
X		ab_blinkid = -1;
X		blinking = FALSE;
X	}
X}
X
X
X/*
X * cd_info_popup
X *	Pop up the information message dialog box.
X *
X * Args:
X *	title - The title bar text string.
X *	msg - The information message text string.
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xcd_info_popup(char *title, char *msg)
X{
X	XmString	xs;
X
X	/* Set the dialog box title */
X	xs = XmStringCreateSimple(title);
X	XtVaSetValues(widgets.dialog.info, XmNdialogTitle, xs, NULL);
X	XmStringFree(xs);
X
X	/* Set the dialog box message */
X	xs = XmStringCreateLtoR(msg, XmSTRING_DEFAULT_CHARSET);
X	XtVaSetValues(widgets.dialog.info, XmNmessageString, xs, NULL);
X	XmStringFree(xs);
X
X	/* Pop up the info dialog */
X	if (!XtIsManaged(widgets.dialog.info))
X		XtManageChild(widgets.dialog.info);
X}
X
X
X/*
X * cd_warning_popup
X *	Pop up the warning message dialog box.
X *
X * Args:
X *	title - The title bar text string.
X *	msg - The warning message text string.
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xcd_warning_popup(char *title, char *msg)
X{
X	XmString	xs;
X
X	/* Set the dialog box title */
X	xs = XmStringCreateSimple(title);
X	XtVaSetValues(widgets.dialog.warning, XmNdialogTitle, xs, NULL);
X	XmStringFree(xs);
X
X	/* Set the dialog box message */
X	xs = XmStringCreateLtoR(msg, XmSTRING_DEFAULT_CHARSET);
X	XtVaSetValues(widgets.dialog.warning, XmNmessageString, xs, NULL);
X	XmStringFree(xs);
X
X	/* Pop up the warning dialog */
X	if (!XtIsManaged(widgets.dialog.warning))
X		XtManageChild(widgets.dialog.warning);
X}
X
X
X/*
X * cd_fatal_popup
X *	Pop up the fatal error message dialog box.
X *
X * Args:
X *	title - The title bar text string.
X *	msg - The fatal error message text string.
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xcd_fatal_popup(char *title, char *msg)
X{
X	XmString	xs;
X
X	if (!XtIsManaged(widgets.dialog.fatal)) {
X		/* Set the dialog box title */
X		xs = XmStringCreateSimple(title);
X		XtVaSetValues(widgets.dialog.fatal, XmNdialogTitle, xs, NULL);
X		XmStringFree(xs);
X
X		/* Set the dialog box message */
X		xs = XmStringCreateLtoR(msg, XmSTRING_DEFAULT_CHARSET);
X		XtVaSetValues(widgets.dialog.fatal, XmNmessageString, xs, NULL);
X		XmStringFree(xs);
X
X		/* Pop up the error dialog */
X		XtManageChild(widgets.dialog.fatal);
X	}
X}
X
X
X/*
X * cd_confirm_popup
X *	Pop up the user-confirmation message dialog box.
X *
X * Args:
X *	title - The title bar text string.
X *	msg - The fatal error message text string.
X *	f_ok - Pointer to the callback function if user selects OK
X *	a_ok - Argument passed to f_ok
X *	f_cancel - Pointer to the callback function if user selects Cancel
X *	a_cancel - Argument passed to f_cancel
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xcd_confirm_popup(
X	char *title,
X	char *msg,
X	XtCallbackProc f_ok,
X	XtPointer a_ok,
X	XtCallbackProc f_cancel,
X	XtPointer a_cancel
X)
X{
X	XmString	xs;
X	Widget		ok_btn,
X			cancel_btn;
X	static cbinfo_t	ok_cbinfo,
X			cancel_cbinfo;
X
X	/* Set the dialog box title */
X	xs = XmStringCreateSimple(title);
X	XtVaSetValues(widgets.dialog.confirm, XmNdialogTitle, xs, NULL);
X	XmStringFree(xs);
X
X	/* Set the dialog box message */
X	xs = XmStringCreateLtoR(msg, XmSTRING_DEFAULT_CHARSET);
X	XtVaSetValues(widgets.dialog.confirm, XmNmessageString, xs, NULL);
X	XmStringFree(xs);
X
X	/* Add callbacks */
X	ok_btn = XmMessageBoxGetChild(
X		widgets.dialog.confirm,
X		XmDIALOG_OK_BUTTON
X	);
X	cancel_btn = XmMessageBoxGetChild(
X		widgets.dialog.confirm,
X		XmDIALOG_CANCEL_BUTTON
X	);
X
X	ok_cbinfo.widget = ok_btn;
X	ok_cbinfo.type = XmNactivateCallback;
X	ok_cbinfo.func = f_ok;
X	ok_cbinfo.data = a_ok;
X	cancel_cbinfo.widget = cancel_btn;
X	cancel_cbinfo.type = XmNactivateCallback;
X	cancel_cbinfo.func = f_cancel;
X	cancel_cbinfo.data = a_cancel;
X	
X	if (f_ok != NULL) {
X		XtAddCallback(
X			ok_btn,
X			XmNactivateCallback,
X			f_ok,
X			a_ok
X		);
X
X		XtAddCallback(
X			ok_btn,
X			XmNactivateCallback,
X			(XtCallbackProc) cd_rmcallback,
X			(XtPointer) &ok_cbinfo
X		);
X
X		XtAddCallback(
X			cancel_btn,
X			XmNactivateCallback,
X			(XtCallbackProc) cd_rmcallback,
X			(XtPointer) &ok_cbinfo
X		);
X	}
X
X	if (f_cancel != NULL) {
X		XtAddCallback(
X			cancel_btn,
X			XmNactivateCallback,
X			f_cancel,
X			a_cancel
X		);
X
X		XtAddCallback(
X			cancel_btn,
X			XmNactivateCallback,
X			(XtCallbackProc) cd_rmcallback,
X			(XtPointer) &cancel_cbinfo
X		);
X
X		XtAddCallback(
X			ok_btn,
X			XmNactivateCallback,
X			(XtCallbackProc) cd_rmcallback,
X			(XtPointer) &cancel_cbinfo
X		);
X	}
X
X	/* Pop up the error dialog */
X	if (!XtIsManaged(widgets.dialog.confirm))
X		XtManageChild(widgets.dialog.confirm);
X}
X
X
X/*
X * cd_playprog
X *	Play the track program as defined in the playorder table.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xcd_playprog(curstat_t *s)
X{
X	if (s->mode == M_PAUSE)
X		cd_pause_blink(s, FALSE);
X
X	cdlib_playprog(s);
X}
X
X
X/*
X * cd_init
X *	Top level function that initializes all subsystems.  Used on
X *	program startup.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xcd_init(curstat_t *s)
X{
X	int		i;
X	char		*cp,
X			*path,
X			titlestr[STR_BUF_SZ],
X			str[FILE_PATH_SZ + 2];
X	XmString	xs;
X
X
X	/* Check sanity of some parameters and reset to default if
X	 * found to be out of acceptable range.
X	 */
X	if (app_data.stat_interval < 100 || app_data.stat_interval > 5000)
X		app_data.stat_interval = STATUS_INTERVAL;
X	if (app_data.ins_interval < 500 || app_data.ins_interval > 10000)
X		app_data.ins_interval = INSERT_INTERVAL;
X	if (app_data.prev_threshold < 1 || app_data.prev_threshold > 750)
X		app_data.prev_threshold = PREV_THRESHOLD;
X	if (app_data.skip_blks < 50 || app_data.skip_blks > 1000)
X		app_data.skip_blks = SKIP_BLKS;
X	if (app_data.skip_pause < 5 || app_data.skip_pause > 100)
X		app_data.skip_pause = SKIP_PAUSE;
X	if (app_data.skip_vol < 0 || app_data.skip_vol > 100)
X		app_data.skip_vol = SKIP_VOL;
X	if (app_data.skip_minvol < 0 || app_data.skip_minvol > 20)
X		app_data.skip_minvol = SKIP_MINVOL;
X	if (app_data.sample_blks < 75 || app_data.sample_blks > 2000)
X		app_data.sample_blks = SAMPLE_BLKS;
X	if (app_data.blinkon_interval < 0 ||
X	    app_data.blinkon_interval > 10000)
X		app_data.blinkon_interval = BLINKON_INTERVAL;
X	if (app_data.blinkoff_interval < 0 ||
X	    app_data.blinkoff_interval > 10000)
X		app_data.blinkoff_interval = BLINKOFF_INTERVAL;
X	if (app_data.base_scsivol < 0 || app_data.base_scsivol > 0xff)
X		app_data.base_scsivol = BASE_SCSIVOL;
X
X	if (app_data.max_dbdirs <= 0 || app_data.max_dbdirs > 100) {
X		fprintf(stderr, "%s: %s\n", PROGNAME, app_data.str_dbdirserr);
X		exit(1);
X	}
X
X	ouid = getuid();
X
X	if ((cp = getenv("XMCD_LIBDIR")) != NULL) {
X		if (app_data.libdir != NULL)
X			MEM_FREE(app_data.libdir);
X		app_data.libdir = (char *) MEM_ALLOC(strlen(cp) + 1);
X		if (app_data.libdir == NULL) {
X			fprintf(stderr, "%s: %s\n",
X				PROGNAME, app_data.str_nomemory);
X			exit(1);
X		}
X
X		strcpy(app_data.libdir, cp);
X	}
X
X	/* Allocate memory for the database directories string pointers array */
X	dbdirs = (char **)(void *) MEM_ALLOC(
X		app_data.max_dbdirs * sizeof(char *)
X	);
X	if (dbdirs == NULL) {
X		fprintf(stderr, "%s: %s\n", PROGNAME, app_data.str_nomemory);
X		exit(1);
X	}
X
X	if ((cp = getenv("XMCD_DBPATH")) != NULL) {
X		if (app_data.dbdir != NULL)
X			MEM_FREE(app_data.dbdir);
X
X		app_data.dbdir = (char *) MEM_ALLOC(strlen(cp) + 1);
X		if (app_data.dbdir == NULL) {
X			fprintf(stderr, "%s: %s\n",
X				PROGNAME, app_data.str_nomemory);
X			exit(1);
X		}
X
X		strcpy(app_data.dbdir, cp);
X	}
X
X	/* Create the global array of strings each of which is a
X	 * path to a CD database directory.
X	 */
X
X	i = 0;
X	if (app_data.dbdir[0] == '\0')
X		dbdirs[0] = NULL;
X	else {
X		for (path = app_data.dbdir;
X		     (cp = strchr(path, DBPATH_SEPCHAR)) != NULL &&
X		     i < app_data.max_dbdirs - 1;
X		     path = cp + 1, i++) {
X			*cp = '\0';
X
X			if (path[0] == '/')
X				dbdirs[i] = (char *) MEM_ALLOC(
X					strlen(path) + 1
X				);
X			else
X				dbdirs[i] = (char *) MEM_ALLOC(
X					strlen(path) +
X					strlen(app_data.libdir) + 7
X				);
X
X			if (dbdirs[i] == NULL) {
X				fprintf(stderr, "%s: %s\n",
X					PROGNAME, app_data.str_nomemory);
X				exit(1);
X			}
X
X			if (path[0] == '/')
X				strcpy(dbdirs[i], path);
X			else
X				sprintf(dbdirs[i], "%s/cddb/%s",
X					app_data.libdir, path);
X
X			*cp = DBPATH_SEPCHAR;
X
X			/* Add path to list in directory selector popup */
X			sprintf(str, "  %s", dbdirs[i]);
X			xs = XmStringCreateSimple(str);
X			XmListAddItemUnselected(
X				widgets.dirsel.dir_list,
X				xs,
X				i + 1
X			);
X			XmStringFree(xs);
X		}
X
X		if (cp != NULL && *cp == DBPATH_SEPCHAR)
X			*cp = '\0';
X
X		if (path[0] == '/')
X			dbdirs[i] = (char *) MEM_ALLOC(strlen(path) + 1);
X		else
X			dbdirs[i] = (char *) MEM_ALLOC(
X				strlen(path) + strlen(app_data.libdir) + 7
X			);
X
X		if (dbdirs[i] == NULL) {
X			fprintf(stderr, "%s: %s\n",
X				PROGNAME, app_data.str_nomemory);
X			exit(1);
X		}
X		if (path[0] == '/')
X			strcpy(dbdirs[i], path);
X		else
X			sprintf(dbdirs[i], "%s/cddb/%s",
X				app_data.libdir, path);
X
X		/* Add path to list in directory selector popup */
X		sprintf(str, "  %s", dbdirs[i]);
X		xs = XmStringCreateSimple(str);
X		XmListAddItemUnselected(widgets.dirsel.dir_list, xs, i + 1);
X		XmStringFree(xs);
X	}
X
X	for (i++; i < app_data.max_dbdirs; i++)
X		dbdirs[i] = NULL;
X
X	lockfile[0] = '\0';
X
X	/* Initialize the database/program subsystem */
X	dbprog_init(s);
X
X	/* Initialize the CD interface subsystem */
X	cdlib_init(s);
X
X	/* Get system-wide device-specific resource configurations */
X	sprintf(str, "%s/config/%s",
X		app_data.libdir, basename(app_data.device));
X	devspec_init(str, TRUE);
X
X	/* Get user device-specific resource configurations */
X	sprintf(str, "%s/.xmcdcfg/%s",
X		homedir(ouid), basename(app_data.device));
X	devspec_init(str, FALSE);
X
X	/* Set the main window title */
X	sprintf(titlestr, "%s %d", app_data.main_title, app_data.devnum);
X	XStoreName(
X		XtDisplay(widgets.toplevel),
X		XtWindow(widgets.toplevel),
X		titlestr
X	);
X}
X
X
X/*
X * cd_start
X *	Start up I/O to the CD player.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xcd_start(curstat_t *s)
X{
X	cdlib_start(s);
X}
X
X
X/*
X * cd_icon
X *	Main window iconification/deiconification handler.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *	iconified - Whether the main window is iconified.
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xcd_icon(curstat_t *s, bool_t iconified)
X{
X	cdlib_icon(s, iconified);
X}
X
X
X/*
X * cd_halt
X *	Top level function to shut down all subsystems.  Used when
X *	closing the application.
X *
X * Args:
X *	s - Pointer to the curstat_t structure.
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xcd_halt(curstat_t *s)
X{
X	cdlib_halt(s);
X}
X
X
X/*
X * cd_devlock
X *	Create a lock to prevent another xmcd process from accessing
X *	the same CD-ROM device.
X *
X * Args:
X *	path - The lock file path name.
X *
X * Return:
X *	TRUE if the lock was successful.  If FALSE, then it indicates
X *	that another xmcd process currently has the lock.
X */
Xbool_t
Xcd_devlock(char *path)
X{
X	int		fd;
X	pid_t		pid,
X			mypid;
X	char		buf[12];
X	struct stat	stbuf;
X
X	if (stat(path, &stbuf) < 0)
X		return(FALSE);
X
X	if ((stbuf.st_mode & S_IFMT) != S_IFCHR)
X		return(FALSE);
X
X	sprintf(lockfile, "/tmp/.cdlk.%x", stbuf.st_rdev);
X
X	mypid = getpid();
X
X	for (;;) {
X		fd = open(lockfile, O_CREAT | O_EXCL | O_WRONLY | O_SYNC);
X		if (fd < 0) {
X			if (errno == EEXIST) {
X				if ((fd = open(lockfile, O_RDONLY)) < 0)
X					return(FALSE);
X
X				if (read(fd, buf, 12) > 0)
X					pid = (pid_t) atoi(buf);
X				else {
X					close(fd);
X					return(FALSE);
X				}
X
X				close(fd);
X
X				if (pid == mypid)
X					/* Our own lock */
X					return(TRUE);
X
X				if (pid <= 0 ||
X				    (kill(pid, 0) < 0 && errno == ESRCH)) {
X					/* Pid died, steal its lockfile */
X					unlink(lockfile);
X				}
X				else {
X					/* Pid still running: clash */
X					devbusy = TRUE;
X					return(FALSE);
X				}
X			}
X			else
X				return(FALSE);
X		}
X		else {
X			sprintf(buf, "%d\n", mypid);
X			write(fd, buf, strlen(buf));
X
X			close(fd);
X			chmod(lockfile, 0644);
X
X			devbusy = FALSE;
X			return(TRUE);
X		}
X	}
X}
X
X
X/*
X * onsig
X *	Signal handler.  Causes the application to shut down gracefully.
X *
X * Args:
X *	sig - The signal number received.
X *
X * Return:
X *	Nothing.
X */
Xvoid
Xonsig(int sig)
X{
X	signal(sig, SIG_IGN);
X	cd_exit(
X		widgets.toplevel,
X		(XtPointer) curstat_addr(),
X		(XtPointer) NULL
X	);
X}
X
X
X/**************** vv Callback routines vv ****************/
X
X/*
X * cd_checkbox
X *	Main window checkbox callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_checkbox(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	XmRowColumnCallbackStruct
X			*p = (XmRowColumnCallbackStruct *)(void *) call_data;
X	curstat_t	*s = (curstat_t *)(void *) client_data;
X
X
X	if (p->reason != XmCR_ACTIVATE)
X		return;
X
X	if (p->widget == widgets.main.btnlbl_btn) {
X		btnlbl_state = !btnlbl_state;
X		set_btn_lbltype((byte_t)
X			(btnlbl_state ? BTN_STRING : BTN_PIXMAP)
X		);
X	}
X	else if (p->widget == widgets.main.lock_btn) {
X		lock_state = !lock_state;
X		cdlib_lock(s, lock_state);
X	}
X	else if (p->widget == widgets.main.repeat_btn) {
X		repeat_state = !repeat_state;
X		cdlib_repeat(s, repeat_state);
X	}
X	else if (p->widget == widgets.main.shuffle_btn) {
X		shuffle_state = !shuffle_state;
X		cdlib_shuffle(s, shuffle_state);
X	}
X}
X
X
X/*
X * cd_load_eject
X *	Main window load/eject button callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_load_eject(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	curstat_t	*s = (curstat_t *)(void *) client_data;
X
X	if (searching) {
X		cd_beep();
X		return;
X	}
X	if (s->mode == M_PAUSE)
X		cd_pause_blink(s, FALSE);
X
X	cdlib_load_eject(s);
X}
X
X
X/*
X * cd_poweroff
X *	Main window quit button callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_poweroff(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	cd_confirm_popup(
X		app_data.str_confirm,
X		app_data.str_quit,
X		(XtCallbackProc) cd_exit,
X		client_data,
X		(XtCallbackProc) NULL,
X		NULL
X	);
X}
X
X
X/*
X * cd_dbprog
X *	Main window dbprog button callback function
X */
Xvoid
Xcd_dbprog(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	static bool_t	first = TRUE;
X
X	if (XtIsManaged(widgets.dbprog.form)) {
X		/* Pop down the Database/Program window */
X		dbprog_cancel(w, client_data, call_data);
X		return;
X	}
X
X	/* Pop up the Database/Program window */
X	dbprog_popup(w, client_data, call_data);
X
X	if (first) {
X		first = FALSE;
X		XmProcessTraversal(
X			widgets.dbprog.cancel_btn,
X			XmTRAVERSE_CURRENT
X		);
X	}
X}
X
X
X/*
X * cd_time
X *	Main window time mode button callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_time(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	curstat_t	*s = (curstat_t *)(void *) client_data;
X
X	switch (s->time_dpy) {
X	case T_ELAPSED:
X		s->time_dpy = T_REMAIN_TRACK;
X		break;
X
X	case T_REMAIN_TRACK:
X		s->time_dpy = T_REMAIN_DISC;
X		break;
X
X	case T_REMAIN_DISC:
X		s->time_dpy = T_ELAPSED;
X		break;
X	}
X
X	dpy_timemode(s);
X	dpy_track(s);
X	dpy_time(s, FALSE);
X}
X
X
X/*
X * cd_ab
X *	Main window a->b mode button callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_ab(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	if (searching) {
X		cd_beep();
X		return;
X	}
X	cdlib_ab((curstat_t *)(void *) client_data);
X}
X
X
X/*
X * cd_sample
X *	Main window sample mode button callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_sample(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	if (searching) {
X		cd_beep();
X		return;
X	}
X	cdlib_sample((curstat_t *)(void *) client_data);
X}
X
X
X/*
X * cd_level
X *	Main window volume control slider callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_level(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	XmScaleCallbackStruct
X			*p = (XmScaleCallbackStruct *)(void *) call_data;
X
X	cdlib_level(
X		(curstat_t *)(void *) client_data,
X		(byte_t) p->value,
X		(bool_t) (p->reason != XmCR_VALUE_CHANGED)
X	);
X}
X
X
X/*
X * cd_play_pause
X *	Main window play/pause button callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_play_pause(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	curstat_t	*s = (curstat_t *)(void *) client_data;
X
X	if (searching) {
X		cd_beep();
X		return;
X	}
X
X	cdlib_play_pause(s);
X
X	switch (s->mode) {
X	case M_PAUSE:
X		cd_pause_blink(s, TRUE);
X		break;
X	case M_PLAY:
X	case M_STOP:
X	case M_A:
X	case M_AB:
X	case M_SAMPLE:
X		cd_pause_blink(s, FALSE);
X		break;
X	}
X}
X
X
X/*
X * cd_stop
X *	Main window stop button callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_stop(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	curstat_t	*s = (curstat_t *)(void *) client_data;
X
X	if (searching) {
X		cd_beep();
X		return;
X	}
X	if (s->mode == M_PAUSE)
X		cd_pause_blink(s, FALSE);
X
X	cdlib_stop(s, TRUE);
X}
X
X
X/*
X * cd_prevtrk
X *	Main window prev track button callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_prevtrk(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	if (searching) {
X		cd_beep();
X		return;
X	}
X	cdlib_prevtrk((curstat_t *)(void *) client_data);
X}
X
X
X/*
X * cd_nexttrk
X *	Main window next track button callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_nexttrk(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	if (searching) {
X		cd_beep();
X		return;
X	}
X	cdlib_nexttrk((curstat_t *)(void *) client_data);
X}
X
X
X/*
X * cd_previdx
X *	Main window prev index button callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_previdx(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	if (searching) {
X		cd_beep();
X		return;
X	}
X	cdlib_previdx((curstat_t *)(void *) client_data);
X}
X
X
X/*
X * cd_previdx
X *	Main window next index button callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_nextidx(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	if (searching) {
X		cd_beep();
X		return;
X	}
X	cdlib_nextidx((curstat_t *)(void *) client_data);
X}
X
X
X/*
X * cd_rew
X *	Main window search rewind button callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_rew(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	XmPushButtonCallbackStruct
X			*p = (XmPushButtonCallbackStruct *)(void *) call_data;
X	curstat_t	*s = (curstat_t *)(void *) client_data;
X	bool_t		start;
X	static bool_t	rew_running = FALSE;
X
X	if (p->reason == XmCR_ARM) {
X		if (!rew_running) {
X			if (searching) {
X				/* Release running FF */
X				XtCallActionProc(
X					widgets.main.ff_btn,
X					"Activate",
X					p->event,
X					NULL,
X					0
X				);
X				XtCallActionProc(
X					widgets.main.ff_btn,
X					"Disarm",
X					p->event,
X					NULL,
X					0
X				);
X			}
X
X			rew_running = TRUE;
X			searching = TRUE;
X			start = TRUE;
X		}
X		else
X			/* Already running REW */
X			return;
X	}
X	else {
X		if (rew_running) {
X			rew_running = FALSE;
X			searching = FALSE;
X			start = FALSE;
X		}
X		else
X			/* Not running REW */
X			return;
X	}
X
X	cdlib_rew(s, start);
X
X	if (s->mode == M_PAUSE)
X		cd_pause_blink(s, (bool_t) !start);
X}
X
X
X/*
X * cd_ff
X *	Main window search fast-forward button callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_ff(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	XmPushButtonCallbackStruct
X			*p = (XmPushButtonCallbackStruct *)(void *) call_data;
X	curstat_t	*s = (curstat_t *)(void *) client_data;
X	bool_t		start;
X	static bool_t	ff_running = FALSE;
X
X	if (p->reason == XmCR_ARM) {
X		if (!ff_running) {
X			if (searching) {
X				/* Release running REW */
X				XtCallActionProc(
X					widgets.main.rew_btn,
X					"Activate",
X					p->event,
X					NULL,
X					0
X				);
X				XtCallActionProc(
X					widgets.main.rew_btn,
X					"Disarm",
X					p->event,
X					NULL,
X					0
X				);
X			}
X
X			ff_running = TRUE;
X			searching = TRUE;
X			start = TRUE;
X		}
X		else
X			/* Already running FF */
X			return;
X	}
X	else {
X		if (ff_running) {
X			ff_running = FALSE;
X			searching = FALSE;
X			start = FALSE;
X		}
X		else
X			/* Not running FF */
X			return;
X	}
X
X	cdlib_ff(s, start);
X
X	if (s->mode == M_PAUSE)
X		cd_pause_blink(s, (bool_t) !start);
X}
X
X
X/*
X * cd_keypad_popup
X *	Main window keypad button callback function
X */
Xvoid
Xcd_keypad_popup(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	static bool_t	first = TRUE;
X
X	if (XtIsManaged(widgets.keypad.form)) {
X		/* Pop down keypad window */
X		cd_keypad_popdown(w, client_data, call_data);
X		return;
X	}
X
X	/* Pop up keypad window */
X	XtManageChild(widgets.keypad.form);
X
X	/* Reset keypad */
X	cd_keypad_clear(w, client_data, call_data);
X
X	if (first) {
X		first = FALSE;
X		XmProcessTraversal(
X			widgets.keypad.cancel_btn,
X			XmTRAVERSE_CURRENT
X		);
X	}
X}
X
X
X/*
X * cd_keypad_clear
X *	Keypad window clear button callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_keypad_clear(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	/* Reset keypad */
X	keystr[0] = '\0';
X	dpy_keypad_ind();
X}
X
X
X/*
X * cd_keypad_popdown
X *	Keypad window popdown callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_keypad_popdown(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	/* Pop down keypad window */
X	if (XtIsManaged(widgets.keypad.form))
X		XtUnmanageChild(widgets.keypad.form);
X}
X
X
X/*
X * cd_keypad_num
X *	Keypad window number button callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_keypad_num(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	char	tmpstr[2];
X
X	/* The user entered a digit */
X	if (strlen(keystr) >= sizeof(keystr) - 1) {
X		cd_beep();
X		return;
X	}
X	sprintf(tmpstr, "%u", (int) client_data);
X	strcat(keystr, tmpstr);
X	dpy_keypad_ind();
X}
X
X
X/*
X * cd_keypad_enter
X *	Keypad window enter button callback function
X */
Xvoid
Xcd_keypad_enter(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	curstat_t	*s = (curstat_t *)(void *) client_data;
X	bool_t		paused = FALSE,
X			sav_shuffle,
X			sav_program;
X	sword32_t	sav_cur_trk;
X
X	/* The user activated the Enter key */
X
X	/* Save some parameters */
X	sav_shuffle = s->shuffle;
X	sav_program = s->program;
X	sav_cur_trk = s->cur_trk;
X
X	/* Clear shuffle and program mode */
X	s->shuffle = FALSE;
X	s->program = FALSE;
X
X	if (!cdlib_check_disc(s)) {
X		cd_beep();
X		return;
X	}
X
X	s->cur_trk = (sword32_t) atoi(keystr);
X
X	if (curtrk_pos(s) < 0) {
X		/* Illegal track entered */
X		cd_keypad_clear(w, client_data, call_data);
X
X		s->shuffle = sav_shuffle;
X		s->program = sav_program;
X		s->cur_trk = sav_cur_trk;
X
X		cd_beep();
X		return;
X	}
X
X	/* Update shuffle button state */
X	set_shuffle_btn(FALSE);
X
X	switch (s->mode) {
X	case M_PAUSE:
X		/* Mute sound */
X		cdlib_mute_on(s);
X		paused = TRUE;
X
X		/*FALLTHROUGH*/
X	case M_PLAY:
X	case M_A:
X	case M_AB:
X	case M_SAMPLE:
X		/* Set play status to stop */
X		cdlib_stop(s, FALSE);
X
X		/* Do this again because cdlib_stop resets cur_trk */
X		s->cur_trk = atoi(keystr);
X
X		break;
X
X	default:
X		break;
X	}
X
X	/* Start playback at new track */
X	cd_play_pause(w, client_data, call_data);
X
X	if (paused) {
X		/* This will cause the playback to pause */
X		cd_play_pause(w, client_data, call_data);
X
X		/* Restore sound */
X		cdlib_mute_off(s);
X	}
X
X	cd_keypad_clear(w, client_data, call_data);
X}
X
X
X/*
X * cd_about
X *	Program information popup callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_about(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	int		i;
X	char		txt[2048];
X	XmString	xs_progname,
X			xs_desc,
X			xs_info,
X			xs_tmp,
X			xs;
X	curstat_t	*s = (curstat_t *)(void *) client_data;
X
X	if (XtIsManaged(widgets.dialog.about)) {
X		/* Pop down the about dialog box */
X		XtUnmanageChild(widgets.dialog.about);
X		return;
X	}
X
X	xs_progname = XmStringCreateLtoR(PROGNAME, CHSET1);
X
X	sprintf(txt, "   v%s%s PL%d\n%s\n%s\n%s\n\n",
X		VERSION,
X		VERSION_EXT,
X		PATCHLEVEL,
X		"Motif(tm) CD Audio Player",
X		"Copyright (C) 1993  Ti Kan",
X		"E-mail: ti@amb.org");
X
X	xs_desc = XmStringCreateLtoR(txt, CHSET2);
X
X	sprintf(txt, "%s\n%s%s %s %s%s%s\n%s%s\n%s%s\n\n%s",
X		cdlib_vers(),
X		"CD-ROM: ",
X		(s->vendor[0] == '\0') ? "??" : s->vendor,
X		s->prod,
X		(s->revnum[0] == '\0') ? "" : "(",
X		s->revnum,
X		(s->revnum[0] == '\0') ? "" : ")",
X		"Device: ",
X		app_data.device,
X		"Mode:   ",
X		cdlib_mode(),
X		"CD Database directories:"
X	);
X
X	for (i = 0; i < app_data.max_dbdirs && dbdirs[i] != NULL; i++)
X		sprintf(txt, "%s\n    %s", txt, dbdirs[i]);
X
X	if (i == 0)
X		strcat(txt, " None");
X
X	sprintf(txt, "%s\n\n%s\n%s", txt,
X		"This is free software and comes with no warranty.",
X		"See the GNU General Public License for details.");
X
X	xs_info = XmStringCreateLtoR(txt, CHSET3);
X
X	/* Set the dialog box title */
X	xs = XmStringCreateSimple(app_data.str_about);
X	XtVaSetValues(widgets.dialog.about, XmNdialogTitle, xs, NULL);
X	XmStringFree(xs);
X
X	/* Set the dialog box message */
X	xs_tmp = XmStringConcat(xs_progname, xs_desc);
X	xs = XmStringConcat(xs_tmp, xs_info);
X	XtVaSetValues(widgets.dialog.about, XmNmessageString, xs, NULL);
X	XmStringFree(xs_progname);
X	XmStringFree(xs_desc);
X	XmStringFree(xs_info);
X	XmStringFree(xs_tmp);
X	XmStringFree(xs);
X
X	/* Pop up the about dialog box */
X	XtManageChild(widgets.dialog.about);
X}
X
X
X/*
X * cd_help
X *	Program help window popup callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_help_popup(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	if (w == widgets.main.help_btn && XtIsManaged(widgets.help.form)) {
X		/* Pop down help window */
X		XtUnmanageChild(widgets.help.form);
X
X		return;
X	}
X
X	/* Pop up help window */
X	help_popup(w);
X}
X
X
X/*
X * cd_help_popdown
X *	Program help window popdown callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_help_popdown(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	/* Pop down help window */
X	if (XtIsManaged(widgets.help.form))
X		XtUnmanageChild(widgets.help.form);
X}
X
X
X/*
X * cd_warning_popdown
X *	Warning message dialog box popdown callback function
X */
X/*ARGSUSED*/
Xvoid
Xcd_warning_popdown(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	/* Pop down the warning dialog */
X	if (XtIsManaged(widgets.dialog.warning))
X		XtUnmanageChild(widgets.dialog.warning);
X}
X
X
X/*
X * cd_fatal_popdown
X *	Fatal error message dialog box popdown callback function.
X *	This causes the application to terminate.
X */
Xvoid
Xcd_fatal_popdown(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	/* Pop down the error dialog */
X	if (XtIsManaged(widgets.dialog.fatal))
X		XtUnmanageChild(widgets.dialog.fatal);
X
X	/* Quit */
X	cd_exit(w, client_data, call_data);
X}
X
X
X/*
X * cd_rmcallback
X *	Remove callback function specified in cdinfo_t.
X */
X/*ARGSUSED*/
Xvoid
Xcd_rmcallback(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	cbinfo_t	*cb = (cbinfo_t *)(void *) client_data;
X
X	XtRemoveCallback(
X		cb->widget,
X		cb->type,
X		(XtCallbackProc) cb->func,
X		(XtPointer) cb->data
X	);
X}
X
X
X/*
X * cd_form_focus_chg
X *	Focus change callback.  Used to implement keyboard grabs for
X *	hotkey handling.
X */
X/*ARGSUSED*/
Xvoid
Xcd_form_focus_chg(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	XmAnyCallbackStruct	*p = (XmAnyCallbackStruct *)(void *) call_data;
X	Widget			form = (Widget) client_data;
X	static Widget		prev_form = (Widget) NULL;
X
X	if (p->reason != XmCR_FOCUS || form == (Widget) NULL)
X		return;
X
X	if (prev_form != NULL) {
X		if (form == prev_form)
X			return;
X		else
X			hotkey_ungrabkeys(prev_form);
X	}
X
X	if (form != widgets.toplevel) {
X		hotkey_grabkeys(form);
X		prev_form = form;
X	}
X}
X
X
X/*
X * cd_exit
X *	Shut down the application gracefully.
X */
X/*ARGSUSED*/
Xvoid
Xcd_exit(Widget w, XtPointer client_data, XtPointer call_data)
X{
X	XmAnyCallbackStruct	p;
X
X	if (XtIsRealized(widgets.toplevel))
X		XtUnmapWidget(widgets.toplevel);
X
X	cd_halt((curstat_t *)(void *) client_data);
X
X	/* Uninstall current keyboard grabs */
X	p.reason = XmCR_FOCUS;
X	cd_form_focus_chg(
X		widgets.toplevel,
X		(XtPointer) widgets.toplevel,
X		(XtPointer) &p
X	);
X
X	if (!devbusy && lockfile[0] != '\0')
X		unlink(lockfile);
X
X	exit_flag = TRUE;
X}
X
X
X/**************** ^^ Callback routines ^^ ****************/
X
X/***************** vv Event Handlers vv ******************/
X
X
X/*
X * cd_btn_focus_chg
X *	Pushbutton keyboard focus change event handler.  Used to change
X *	the main window pushbuttons' label color.
X */
X/*ARGSUSED*/
Xvoid
Xcd_btn_focus_chg(Widget w, XtPointer client_data, XEvent *ev, Boolean *cont)
X{
X	static bool_t	first = TRUE;
X	static int	count = 0;
X	static Pixel	fg,
X			hl;
X
X	if (!app_data.main_showfocus)
X		return;
X
X	if (first) {
X		first = FALSE;
X
X		XtVaGetValues(w, XmNforeground, &fg, NULL);
X		XtVaGetValues(w, XmNhighlightColor, &hl, NULL);
X	}
X
X	if (ev->type == FocusOut) {
X		if (count <= 0)
X			return;
X
X		/* Restore original forground pixmap */
X		if (w == widgets.main.eject_btn)
X			set_btn_color(w, pixmaps.main.eject_pixmap, fg);
X		else if (w == widgets.main.poweroff_btn)
X			set_btn_color(w, pixmaps.main.poweroff_pixmap, fg);
X		else if (w == widgets.main.dbprog_btn)
X			set_btn_color(w, pixmaps.main.dbprog_pixmap, fg);
X		else if (w == widgets.main.help_btn)
X			set_btn_color(w, pixmaps.main.help_pixmap, fg);
X		else if (w == widgets.main.time_btn)
X			set_btn_color(w, pixmaps.main.time_pixmap, fg);
X		else if (w == widgets.main.ab_btn)
X			set_btn_color(w, pixmaps.main.ab_pixmap, fg);
X		else if (w == widgets.main.sample_btn)
X			set_btn_color(w, pixmaps.main.sample_pixmap, fg);
X		else if (w == widgets.main.keypad_btn)
X			set_btn_color(w, pixmaps.main.keypad_pixmap, fg);
X		else if (w == widgets.main.level_scale)
X			set_scale_color(w, fg);
X		else if (w == widgets.main.playpause_btn)
X			set_btn_color(w, pixmaps.main.playpause_pixmap, fg);
X		else if (w == widgets.main.stop_btn)
X			set_btn_color(w, pixmaps.main.stop_pixmap, fg);
X		else if (w == widgets.main.prevtrk_btn)
X			set_btn_color(w, pixmaps.main.prevtrk_pixmap, fg);
X		else if (w == widgets.main.nexttrk_btn)
X			set_btn_color(w, pixmaps.main.nexttrk_pixmap, fg);
X		else if (w == widgets.main.previdx_btn)
X			set_btn_color(w, pixmaps.main.previdx_pixmap, fg);
X		else if (w == widgets.main.nextidx_btn)
X			set_btn_color(w, pixmaps.main.nextidx_pixmap, fg);
X		else if (w == widgets.main.rew_btn)
X			set_btn_color(w, pixmaps.main.rew_pixmap, fg);
X		else if (w == widgets.main.ff_btn)
X			set_btn_color(w, pixmaps.main.ff_pixmap, fg);
X
X		count--;
X	}
X	else if (ev->type == FocusIn) {
X		if (count >= 1)
X			return;
X
X		/* Set new highlighted forground pixmap */
X		if (w == widgets.main.eject_btn)
X			set_btn_color(w, pixmaps.main.eject_hlpixmap, hl);
X		else if (w == widgets.main.poweroff_btn)
X			set_btn_color(w, pixmaps.main.poweroff_hlpixmap, hl);
X		else if (w == widgets.main.dbprog_btn)
X			set_btn_color(w, pixmaps.main.dbprog_hlpixmap, hl);
X		else if (w == widgets.main.help_btn)
X			set_btn_color(w, pixmaps.main.help_hlpixmap, hl);
X		else if (w == widgets.main.time_btn)
X			set_btn_color(w, pixmaps.main.time_hlpixmap, hl);
X		else if (w == widgets.main.ab_btn)
X			set_btn_color(w, pixmaps.main.ab_hlpixmap, hl);
X		else if (w == widgets.main.sample_btn)
X			set_btn_color(w, pixmaps.main.sample_hlpixmap, hl);
X		else if (w == widgets.main.keypad_btn)
X			set_btn_color(w, pixmaps.main.keypad_hlpixmap, hl);
X		else if (w == widgets.main.level_scale)
X			set_scale_color(w, hl);
X		else if (w == widgets.main.playpause_btn)
X			set_btn_color(w, pixmaps.main.playpause_hlpixmap, hl);
X		else if (w == widgets.main.stop_btn)
X			set_btn_color(w, pixmaps.main.stop_hlpixmap, hl);
X		else if (w == widgets.main.prevtrk_btn)
X			set_btn_color(w, pixmaps.main.prevtrk_hlpixmap, hl);
X		else if (w == widgets.main.nexttrk_btn)
X			set_btn_color(w, pixmaps.main.nexttrk_hlpixmap, hl);
X		else if (w == widgets.main.previdx_btn)
X			set_btn_color(w, pixmaps.main.previdx_hlpixmap, hl);
X		else if (w == widgets.main.nextidx_btn)
X			set_btn_color(w, pixmaps.main.nextidx_hlpixmap, hl);
X		else if (w == widgets.main.rew_btn)
X			set_btn_color(w, pixmaps.main.rew_hlpixmap, hl);
X		else if (w == widgets.main.ff_btn)
X			set_btn_color(w, pixmaps.main.ff_hlpixmap, hl);
X
X		count++;
X	}
X}
X
X/***************** ^^ Event Handlers ^^ ******************/
X
END_OF_FILE
if test 55680 -ne `wc -c <'cdfunc.c'`; then
    echo shar: \"'cdfunc.c'\" unpacked with wrong size!
fi
# end of 'cdfunc.c'
fi
echo shar: End of archive 5 \(of 13\).
cp /dev/null ark5isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 13 archives.
    echo "Now read the README and INSTALL files for further instructions."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
    ///  Ti Kan                vorsprung durch technik
   ///   AMB Research Laboratories, Sunnyvale, CA. USA
  ///    ti@amb.org
 //////  ...!{decwrl,synopsys,tandem,tsoft,ultra}!sgiblab!bazooka!ti
///      ...!uunet!bazooka!ti



exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga: The only way to fly!  |    sources-x@sterling.com
       "It's intuitively obvious to the most casual observer..."
 GCS d++(--) -p+ c++ !l u++ e+ m+(-) s++/++ n h--- f+ g+++ w+ t++ r+ y+
