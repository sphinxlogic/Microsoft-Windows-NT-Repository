Newsgroups: comp.sources.x
From: ti@bazooka.amb.org (Ti Kan)
Subject: v21i065:  xmcd - X11/Motif CD audio player, Part03/13
Message-ID: <1993Dec19.193823.23991@sparky.sterling.com>
X-Md4-Signature: 12de1d87824c11fc5be12c30ca3c3a73
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Sun, 19 Dec 1993 19:38:23 GMT
Approved: chris@sterling.com

Submitted-by: ti@bazooka.amb.org (Ti Kan)
Posting-number: Volume 21, Issue 65
Archive-name: xmcd/part03
Environment: X11, OSF/Motif

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 3 (of 13)."
# Contents:  help.h hotkey.h lib_demo.h lib_hita.h lib_hpux.h lib_nec.h
#   lib_odt.h lib_pion.h lib_scsipt.h lib_sim.h lib_sun.h lib_svr4.h
#   lib_tosh.h
# Wrapped by ti@bazooka on Mon Nov  8 10:35:18 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'help.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help.h'\"
else
echo shar: Extracting \"'help.h'\" \(1136 characters\)
sed "s/^X//" >'help.h' <<'END_OF_FILE'
X/*
X *   xmcd - Motif(tm) CD Audio Player
X *
X *   Copyright (C) 1993  Ti Kan
X *   E-mail: ti@amb.org
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 2 of the License, or
X *   (at your option) any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X */
X#ifndef __HELP_H__
X#define __HELP_H__
X
X#ifndef LINT
Xstatic char *_help_h_ident_ = "@(#)help.h	1.10 93/09/28";
X#endif
X
X/* Max number of widgets supported by the help system */
X#define MAX_HELP_WIDGETS	72
X
X/* Public functions */
Xvoid	help_setup(widgets_t *);
Xvoid	help_popup(Widget);
X
X#endif	/* __HELP_H__ */
END_OF_FILE
if test 1136 -ne `wc -c <'help.h'`; then
    echo shar: \"'help.h'\" unpacked with wrong size!
fi
# end of 'help.h'
fi
if test -f 'hotkey.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'hotkey.h'\"
else
echo shar: Extracting \"'hotkey.h'\" \(1186 characters\)
sed "s/^X//" >'hotkey.h' <<'END_OF_FILE'
X/*
X *   xmcd - Motif(tm) CD Audio Player
X *
X *   Copyright (C) 1993  Ti Kan
X *   E-mail: ti@amb.org
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 2 of the License, or
X *   (at your option) any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X */
X#ifndef __HOTKEY_H__
X#define __HOTKEY_H__
X
X#ifndef LINT
Xstatic char *_hotkey_h_ident_ = "@(#)hotkey.h	1.13 93/09/28";
X#endif
X
X#define MAX_TRANSLATIONS_SZ	4096
X
X/* Public functions */
Xvoid	hotkey(Widget, XEvent *, String *, Cardinal *);
Xvoid	hotkey_setup(widgets_t *);
Xvoid	hotkey_grabkeys(Widget);
Xvoid	hotkey_ungrabkeys(Widget);
X
X#endif	/* __HOTKEY_H__ */
END_OF_FILE
if test 1186 -ne `wc -c <'hotkey.h'`; then
    echo shar: \"'hotkey.h'\" unpacked with wrong size!
fi
# end of 'hotkey.h'
fi
if test -f 'lib_demo.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib_demo.h'\"
else
echo shar: Extracting \"'lib_demo.h'\" \(1332 characters\)
sed "s/^X//" >'lib_demo.h' <<'END_OF_FILE'
X/*
X *   xmcd - Motif(tm) CD Audio Player
X *
X *   Copyright (C) 1993  Ti Kan
X *   E-mail: ti@amb.org
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 2 of the License, or
X *   (at your option) any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X */
X#ifndef __LIB_DEMO_H__
X#define __LIB_DEMO_H__
X
X#if !defined(OSI_MODULE) || defined(DEMO_ONLY)
X
X#ifndef LINT
Xstatic char *_lib_demo_h_ident_ = "@(#)lib_demo.h	1.16 93/09/28";
X#endif
X
X#include "lib_sim.h"	/* CD-ROM simulator header file */
X
X/* Public function prototypes */
Xbool_t	pthru_send(byte_t, word32_t, byte_t *, word32_t, byte_t, word32_t,
X		byte_t, byte_t, byte_t);
Xbool_t	pthru_open(char *);
Xvoid	pthru_close(void);
Xchar	*pthru_vers(void);
X
X#endif	/* OSI_MODULE */
X
X#endif	/* __LIB_DEMO_H__ */
X
END_OF_FILE
if test 1332 -ne `wc -c <'lib_demo.h'`; then
    echo shar: \"'lib_demo.h'\" unpacked with wrong size!
fi
# end of 'lib_demo.h'
fi
if test -f 'lib_hita.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib_hita.h'\"
else
echo shar: Extracting \"'lib_hita.h'\" \(7959 characters\)
sed "s/^X//" >'lib_hita.h' <<'END_OF_FILE'
X/*
X *   xmcd - Motif(tm) CD Audio Player
X *
X *   Copyright (C) 1993  Ti Kan
X *   E-mail: ti@amb.org
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 2 of the License, or
X *   (at your option) any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X *   The name "Hitachi" is a trademark of Hitachi Corporation, and is
X *   used here for identification purposes.  This software and its
X *   author are not affiliated in any way with Hitachi.
X *
X */
X#ifndef __LIB_HITA_H__
X#define __LIB_HITA_H__
X
X#ifdef HITACHI
X
X#ifndef LINT
Xstatic char *_lib_hita_h_ident_ = "@(#)lib_hita.h	1.17 93/10/01";
X#endif
X
X#ifndef VUSUPPORT
X#define VUSUPPORT
X#endif
X
X
X/* Hitachi vendor-unique commands */
X#define OP_VH_AUDPLAY		0xe0	/* Hitachi play audio */
X#define OP_VH_PAUSE		0xe1	/* Hitachi pause */
X#define OP_VH_PLAYTRK		0xe2	/* Hitachi play audio track */
X#define OP_VH_RDINFO		0xe3	/* Hitachi read disk info */
X#define OP_VH_EJECT		0xe4	/* Hitachi eject */
X#define OP_VH_RDSTAT		0xe5	/* Hitachi read audio status */
X#define OP_VH_PWRSAVE		0xe6	/* Hitachi power save mode */
X#define OP_VH_RDXINFO		0xe8	/* Hitachi read extended disk info */
X
X
X/* Macros to compute the real offset of the data area in several
X * data structures.  The pad byte in the beginning of some structures
X * are there to prevent the compiler from inserting a pad byte in
X * the middle of the structure.  The alternative is to use #pragma pack(1),
X * but that's not very portable.
X */
X#define AD_VH_PAUSE(x)		(x)	/* Hitachi pause data addr */
X#define AD_VH_RDINFO(x)		((x)+1)	/* Hitachi disk info data addr */
X#define AD_VH_RDSTAT(x)		(x)	/* Hitachi audio status data addr */
X#define AD_VH_RDXINFO(x)	(x)	/* Hitachi ext disk info data addr */
X
X
X/* Return data lengths */
X#define SZ_VH_PAUSE		3	/* Hitachi pause data size */
X#define SZ_VH_RDINFO		303	/* Hitachi disk info data size */
X#define SZ_VH_TOCHDR		3	/* Hitachi disc info header size */
X#define SZ_VH_TOCENT		3	/* Hitachi disc info per-track
X					 * entry size
X					 */
X#define SZ_VH_RDSTAT		11	/* Hitachi audio status data size */
X#define SZ_VH_RDXINFO		404	/* Hitachi ext disk info data size */
X
X
X/* Hitachi MSF location */
Xtypedef struct hmsf {
X#if BYTE_ORDER == LITTLE_ENDIAN
X	unsigned int	min:7;			/* minute */
X	unsigned int	data:1;			/* 0=audio 1=data */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X	unsigned int	data:1;			/* 0=audio 1=data */
X	unsigned int	min:7;			/* minute */
X#endif	/* BYTE_ORDER */
X	unsigned int	sec:8;			/* second */
X	unsigned int	frame:8;		/* frame */
X	unsigned int	res:8;			/* reserved */
X} hmsf_t;
X
X
X/* Hitachi extended MSF location */
Xtypedef struct hxmsf {
X#if BYTE_ORDER == LITTLE_ENDIAN
X	unsigned int	adr:4;			/* ADR code */
X        unsigned int	preemph:1;		/* preemphasis */
X	unsigned int	copyallow:1;		/* digital copy allow */
X	unsigned int	trktype:1;		/* 0=audio 1=data */
X	unsigned int	audioch:1;		/* 0=2ch 1=4ch */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X	unsigned int	audioch:1;		/* 0=2ch 1=4ch */
X	unsigned int	trktype:1;		/* 0=audio 1=data */
X	unsigned int	copyallow:1;		/* digital copy allow */
X        unsigned int	preemph:1;		/* preemphasis */
X	unsigned int	adr:4;			/* ADR code */
X#endif	/* BYTE_ORDER */
X	unsigned int	min:8;			/* minute */
X	unsigned int	sec:8;			/* second */
X	unsigned int	frame:8;		/* frame */
X} hxmsf_t;
X
X
X/* Hitachi Disk Info data */
Xtypedef struct hdiscinfo {
X	unsigned int	pad0:8;			/* pad byte for alignment */
X#if BYTE_ORDER == LITTLE_ENDIAN
X	unsigned int	audio:1;		/* disc has audio tracks */
X	unsigned int	data:1;			/* disc has data tracks */
X	unsigned int	res:6;			/* reserved */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X	unsigned int	res:6;			/* reserved */
X	unsigned int	data:1;			/* disc has data tracks */
X	unsigned int	audio:1;		/* disc has audio tracks */
X#endif	/* BYTE_ORDER */
X	unsigned int	first_trk:8;		/* first track number */
X	unsigned int	last_trk:8;		/* last track number */
X
X	byte_t		msfdata[300];		/* Track MSF address data */
X} hdiscinfo_t;
X
X
X/* Hitachi Audio Status data */
Xtypedef struct haudstat {
X#if BYTE_ORDER == LITTLE_ENDIAN
X	unsigned int	playing:1;		/* Audio playing */
X	unsigned int	res1:7;			/* Reserved */
X	unsigned int	adr:4;			/* ADR code */
X        unsigned int	preemph:1;		/* preemphasis */
X	unsigned int	copyallow:1;		/* digital copy allow */
X	unsigned int	trktype:1;		/* 0=audio 1=data */
X	unsigned int	audioch:1;		/* 0=2ch 1=4ch */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X	unsigned int	res1:7;			/* Reserved */
X	unsigned int	playing:1;		/* Audio playing */
X	unsigned int	audioch:1;		/* 0=2ch 1=4ch */
X	unsigned int	trktype:1;		/* 0=audio 1=data */
X	unsigned int	copyallow:1;		/* digital copy allow */
X        unsigned int	preemph:1;		/* preemphasis */
X	unsigned int	adr:4;			/* ADR code */
X#endif	/* BYTE_ORDER */
X	unsigned int	trkno:8;		/* track number */
X	unsigned int	res2:8;			/* reserved */
X
X	hmsf_t		rel_addr;		/* relative address */
X	hmsf_t		abs_addr;		/* absolute address */
X} haudstat_t;
X
X
X/* Hitachi Extended Disk Info data */
Xtypedef struct hxdiscinfo {
X	byte_t		res[2];			/* reserved */
X	byte_t		first_trk;		/* first track number */
X	byte_t		last_trk;		/* last track number */
X
X	byte_t		xmsfdata[400];		/* track MSF address data */
X} hxdiscinfo_t;
X
X
X/* Argument for the Hitachi play audio and Hitachi play audio by track
X * commands.
X */
Xtypedef struct haudio_arg {
X	union {
X#if BYTE_ORDER == LITTLE_ENDIAN
X		struct {
X			byte_t	res;		/* reserved */
X			byte_t	frame;		/* frame */
X			byte_t	sec;		/* seconds */
X			byte_t	min;		/* minutes */
X		} startmsf;			/* OP_VH_AUDPLAY start */
X		struct {
X			byte_t	frame;		/* frame */
X			byte_t	sec;		/* seconds */
X			byte_t	min;		/* minutes */
X			byte_t	res;		/* reserved */
X		} endmsf;			/* OP_VH_AUDPLAY end */
X		struct {
X			byte_t	res[3];		/* reserved */
X			byte_t	track;		/* track number */
X		} starttrk;			/* OP_VH_PLAYTRK start */
X		struct {
X			byte_t	res1[2];	/* reserved */
X			byte_t	track;		/* track number */
X			byte_t	res2;		/* reserved */
X		} endtrk;			/* OP_VH_PLAYTRK end */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X		struct {
X			byte_t	min;		/* minutes */
X			byte_t	sec;		/* seconds */
X			byte_t	frame;		/* frame */
X			byte_t	res;		/* reserved */
X		} startmsf;			/* OP_VH_AUDPLAY start */
X		struct {
X			byte_t	res;		/* reserved */
X			byte_t	min;		/* minutes */
X			byte_t	sec;		/* seconds */
X			byte_t	frame;		/* frame */
X		} endmsf;			/* OP_VH_AUDPLAY end */
X		struct {
X			byte_t	track;		/* track number */
X			byte_t	res[3];		/* reserved */
X		} starttrk;			/* OP_VH_PLAYTRK start */
X		struct {
X			byte_t	res2;		/* reserved */
X			byte_t	track;		/* track number */
X			byte_t	res1[2];	/* reserved */
X		} endtrk;			/* OP_VH_PLAYTRK end */
X#endif	/* BYTE_ORDER */
X	} _addr;
X} haudio_arg_t;
X
X#define addr_smin	_addr.startmsf.min
X#define addr_ssec	_addr.startmsf.sec
X#define addr_sframe	_addr.startmsf.frame
X#define addr_emin	_addr.endmsf.min
X#define addr_esec	_addr.endmsf.sec
X#define addr_eframe	_addr.endmsf.frame
X#define addr_strk	_addr.starttrk.track
X#define addr_etrk	_addr.endtrk.track
X
X
X/* Public function prototypes */
Xbool_t	hita_playaudio(byte_t, word32_t, word32_t, msf_t *, msf_t *,
X		byte_t, byte_t);
Xbool_t	hita_pause_resume(bool_t);
Xbool_t	hita_start_stop(bool_t, bool_t);
Xbool_t	hita_get_playstatus(curstat_t *, byte_t *);
Xbool_t	hita_get_toc(curstat_t *);
Xbool_t	hita_mute(bool_t);
Xbool_t	hita_eject(void);
Xvoid	hita_init(void);
Xvoid	hita_halt(void);
X
X#endif	/* HITACHI */
X
X#endif	/* __LIB_HITA_H__ */
X
END_OF_FILE
if test 7959 -ne `wc -c <'lib_hita.h'`; then
    echo shar: \"'lib_hita.h'\" unpacked with wrong size!
fi
# end of 'lib_hita.h'
fi
if test -f 'lib_hpux.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib_hpux.h'\"
else
echo shar: Extracting \"'lib_hpux.h'\" \(1618 characters\)
sed "s/^X//" >'lib_hpux.h' <<'END_OF_FILE'
X/*
X *   xmcd - Motif(tm) CD Audio Player
X *
X *   Copyright (C) 1993  Ti Kan
X *   E-mail: ti@amb.org
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 2 of the License, or
X *   (at your option) any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X *   This software module contains code that interfaces xmcd to
X *   the HP-UX Release 9.0 operating system.  The name "HP" and "hpux"
X *   are used here for identification purposes.  This software and
X *   its author are not affiliated with the Hewlett-Packard Company.
X */
X#ifndef __LIB_HPUX_H__
X#define __LIB_HPUX_H__
X
X#if defined(hpux) && !defined(DEMO_ONLY)
X
X#ifndef LINT
Xstatic char *_lib_hpux_h_ident_ = "@(#)lib_hpux.h	1.4 93/09/28";
X#endif
X
X#include <sys/scsi.h>
X
X#ifndef OSI_MODULE
X#define OSI_MODULE
X#endif
X
X
X/* Public function prototypes */
Xbool_t	pthru_send(byte_t, word32_t, byte_t *, word32_t, byte_t, word32_t,
X		byte_t, byte_t, byte_t);
Xbool_t	pthru_open(char *);
Xvoid	pthru_close(void);
Xchar	*pthru_vers(void);
X
X
X#endif	/* hpux && !DEMO_ONLY */
X
X#endif	/* __LIB_HPUX_H__ */
X
END_OF_FILE
if test 1618 -ne `wc -c <'lib_hpux.h'`; then
    echo shar: \"'lib_hpux.h'\" unpacked with wrong size!
fi
# end of 'lib_hpux.h'
fi
if test -f 'lib_nec.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib_nec.h'\"
else
echo shar: Extracting \"'lib_nec.h'\" \(4957 characters\)
sed "s/^X//" >'lib_nec.h' <<'END_OF_FILE'
X/*
X *   xmcd - Motif(tm) CD Audio Player
X *
X *   Copyright (C) 1993  Ti Kan
X *   E-mail: ti@amb.org
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 2 of the License, or
X *   (at your option) any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X *   The name "NEC" is a trademark of NEC Corporation, and is
X *   used here for identification purposes.  This software and its
X *   author are not affiliated in any way with NEC.
X *
X */
X#ifndef __LIB_NEC_H__
X#define __LIB_NEC_H__
X
X#ifdef NEC
X
X#ifndef LINT
Xstatic char *_lib_nec_h_ident_ = "@(#)lib_nec.h	1.21 93/10/01";
X#endif
X
X#ifndef VUSUPPORT
X#define VUSUPPORT
X#endif
X
X
X/* NEC vendor-unique commands */
X#define OP_VN_AUDSRCH		0xd8	/* NEC audio search */
X#define OP_VN_AUDPLAY		0xd9	/* NEC play audio */
X#define OP_VN_STILL		0xda	/* NEC still */
X#define OP_VN_SETSTOP		0xd8	/* NEC set stop time */
X#define OP_VN_EJECT		0xdc	/* NEC eject */
X#define OP_VN_RDSUBQ		0xdd	/* NEC read subcode Q */
X#define OP_VN_RDTOC		0xde	/* NEC read TOC */
X
X
X/* NEC audio status codes */
X#define NAUD_PLAYING		0x00
X#define NAUD_PAUSED		0x01
X#define NAUD_SRCH_PAUSED	0x02
X#define NAUD_COMPLETED		0x03
X
X
X/* Return data lengths */
X#define SZ_VN_RDSUBQ		10	/* NEC read subcode Q data size */
X#define SZ_VN_RDTOC		4	/* NEC read TOC data size */
X
X
X/* NEC read sub-code Q command data */
Xtypedef struct nsubq_data {
X	unsigned int	audio_status:8;	/* audio status */
X#if BYTE_ORDER == LITTLE_ENDIAN
X	unsigned int	preemph:1;	/* preemphasis */
X	unsigned int	copyallow:1;	/* digital copy allow */
X	unsigned int	trktype:1;	/* 0=audio 1=data */
X	unsigned int	audioch:1;	/* 0=2ch 1=4ch */
X	unsigned int	reserved:4;	/* reserved */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X	unsigned int	reserved:4;	/* reserved */
X	unsigned int	audioch:1;	/* 0=2ch 1=4ch */
X	unsigned int	trktype:1;	/* 0=audio 1=data */
X	unsigned int	copyallow:1;	/* digital copy allow */
X	unsigned int	preemph:1;	/* preemphasis */
X#endif	/* BYTE_ORDER */
X	unsigned int	trkno:8;	/* track number (BCD) */
X	unsigned int	idxno:8;	/* index number (BCD) */
X
X	byte_t		rel_min;	/* trk relative minutes (BCD) */
X	byte_t		rel_sec;	/* trk relative seconds (BCD) */
X	byte_t		rel_frame;	/* trk relative frame (BCD) */
X	byte_t		abs_min;	/* absolute minutes (BCD) */
X
X	byte_t		abs_sec;	/* absolute seconds (BCD) */
X	byte_t		abs_frame;	/* absolute frame (BCD) */
X	byte_t		pad1[2];	/* pad for alignment */
X} nsubq_data_t;
X
X
X/* NEC read TOC command data */
Xtypedef struct ninfo_00 {		/* track information */
X	byte_t		first_trk;	/* first track (BCD) */
X	byte_t		last_trk;	/* last track (BCD) */
X	byte_t		reserved[2];	/* reserved */
X} ninfo_00_t;
X
Xtypedef struct ninfo_01 {		/* lead-out track starting time */
X	byte_t		min;		/* minutes (BCD) */
X	byte_t		sec;		/* seconds (BCD) */
X	byte_t		frame;		/* frame (BCD) */
X	byte_t		reserved;	/* reserved */
X} ninfo_01_t;
X
Xtypedef struct ninfo_02 {		/* specified track starting time */
X	byte_t		min;		/* minutes (BCD) */
X	byte_t		sec;		/* seconds (BCD) */
X	byte_t		frame;		/* frame (BCD) */
X	byte_t		trktype;	/* track type */
X} ninfo_02_t;
X
X
X/* Argument of NEC audio search and play audio commands */
Xtypedef struct naudio_arg {
X	union {				/* address */
X		word32_t	tp_00;	/* absolute logical blk addr */
X#if BYTE_ORDER == LITTLE_ENDIAN
X		struct {
X			byte_t	res;	/* reserved */
X			byte_t	frame;	/* frame (BCD) */
X			byte_t	sec;	/* seconds (BCD) */
X			byte_t	min;	/* minutes (BCD) */
X		} tp_01;
X		struct {
X			byte_t	res[3];	/* reserved */
X			byte_t	track;	/* track number (BCD) */
X		} tp_10;
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X		struct {
X			byte_t	min;	/* minutes (BCD) */
X			byte_t	sec;	/* seconds (BCD) */
X			byte_t	frame;	/* frame (BCD) */
X			byte_t	res;	/* reserved */
X		} tp_01;
X		struct {
X			byte_t	track;	/* track number (BCD) */
X			byte_t	res[3];	/* reserved */
X		} tp_10;
X#endif	/* BYTE_ORDER */
X	} _addr;
X} naudio_arg_t;
X
X#define	addr_logical	_addr.tp_00
X#define	addr_min	_addr.tp_01.min
X#define	addr_sec	_addr.tp_01.sec
X#define	addr_frame	_addr.tp_01.frame
X#define	addr_track	_addr.tp_10.track
X
X
X/* Public function prototypes */
Xbool_t	nec_playaudio(byte_t, word32_t, word32_t, msf_t *, msf_t *,
X		byte_t, byte_t);
Xbool_t	nec_pause_resume(bool_t);
Xbool_t	nec_get_playstatus(curstat_t *, byte_t *);
Xbool_t	nec_get_toc(curstat_t *);
Xbool_t	nec_mute(bool_t);
Xbool_t	nec_eject(void);
Xvoid	nec_init(void);
Xvoid	nec_halt(void);
X
X#endif	/* NEC */
X
X#endif	/* __LIB_NEC_H__ */
X
END_OF_FILE
if test 4957 -ne `wc -c <'lib_nec.h'`; then
    echo shar: \"'lib_nec.h'\" unpacked with wrong size!
fi
# end of 'lib_nec.h'
fi
if test -f 'lib_odt.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib_odt.h'\"
else
echo shar: Extracting \"'lib_odt.h'\" \(3895 characters\)
sed "s/^X//" >'lib_odt.h' <<'END_OF_FILE'
X/*
X *   xmcd - Motif(tm) CD Audio Player
X *
X *   Copyright (C) 1993  Ti Kan
X *   E-mail: ti@amb.org
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 2 of the License, or
X *   (at your option) any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X *   This software module contains code that interfaces xmcd to
X *   the SCO Open Desktop operating system.  The name "SCO" and "ODT"
X *   are used here for identification purposes.  This software and
X *   its author are not affiliated with The Santa Cruz Operation, Inc.
X */
X#ifndef __LIB_ODT_H__
X#define __LIB_ODT_H__
X
X#if defined(sco) && !defined(DEMO_ONLY)
X
X#ifndef LINT
Xstatic char *_lib_odt_h_ident_ = "@(#)lib_odt.h	1.36 93/09/28";
X#endif
X
X#include <sys/scsi.h>
X#include <sys/scsicmd.h>
X
X#ifndef OSI_MODULE
X#define OSI_MODULE
X#endif
X
X
X/* Macros to update various fields of the SCSI CDB structures.
X * These are used to work around byte alignment restrictions and
X * padding with some compilers.  In general, define NO_ALIGN_LIMIT
X * if and only if you are sure that the compiler will not insert
X * pad bytes between any field of the SCSI CDB structure.
X */
X
X#ifdef NO_ALIGN_LIMIT
X
X#define CDB6_BLK(a,d)	(a)->data[0] = (byte_t) (d);		\
X			(a)->data[1] = (byte_t) ((d) >> 8);
X#define CDB6_LEN(a,d)	(a)->data[2] = (d)
X#define CDB6_CTL(a,d)	(a)->control = (d)
X#define CDB10_BLK(a,d)	(a)->block = (d)
X#define CDB10_LEN(a,d)	(a)->length = (d)
X#define CDB10_RSV(a,d)	(a)->reserved = (d)
X#define CDB10_CTL(a,d)	(a)->control = (d)
X#define CDB12_BLK(a,d)	(a)->block = (d)
X#define CDB12_LEN(a,d)	(a)->length = (d)
X#define CDB12_RSV(a,d)	(a)->reserved = (d)
X#define CDB12_CTL(a,d)	(a)->control = (d)
X
X#else	/* !NO_ALIGN_LIMIT */
X
X#if BYTE_ORDER == LITTLE_ENDIAN
X
X#define CDB6_BLK(a,d)	{					\
X	register word16_t *p = (word16_t *)(void *) (a);	\
X	p[1] = (d);						\
X}
X#define CDB6_LEN(a,d)	{					\
X	register byte_t *p = (byte_t *) (a);			\
X	p[4] = (d);						\
X}
X#define CDB6_CTL(a,d)	{					\
X	register byte_t *p = (byte_t *) (a);			\
X	p[5] = (d);						\
X}
X#define CDB10_BLK(a,d)	{					\
X	register word16_t *p = (word16_t *)(void *) (a);	\
X	p[1] = (word16_t) (d);					\
X	p[2] = (word16_t) ((d) >> 16);				\
X}
X#define CDB10_LEN(a,d)	{					\
X	register byte_t *p = (byte_t *) (a);			\
X	p[7] = (byte_t) (d);					\
X	p[8] = (byte_t) ((d) >> 8);				\
X}
X#define CDB10_RSV(a,d)	{					\
X	register byte_t *p = (byte_t *) (a);			\
X	p[6] = (d);						\
X}
X#define CDB10_CTL(a,d)	{					\
X	register byte_t *p = (byte_t *) (a);			\
X	p[9] = (d);						\
X}
X#define CDB12_BLK(a,d)	{					\
X	register word16_t *p = (word16_t *)(void *) (a);	\
X	p[1] = (word16_t) (d);					\
X	p[2] = (word16_t) ((d) >> 16);				\
X}
X#define CDB12_LEN(a,d)	{					\
X	register word16_t *p = (word16_t *)(void *) (a);	\
X	p[3] = (word16_t) (d);					\
X	p[4] = (word16_t) ((d) >> 16);				\
X}
X#define CDB12_RSV(a,d)	{					\
X	register byte_t *p = (byte_t *) (a);			\
X	p[10] = (d);						\
X}
X#define CDB12_CTL(a,d)	{					\
X	register byte_t *p = (byte_t *) (a);			\
X	p[11] = (d);						\
X}
X
X#endif	/* BYTE_ORDER == LITTLE_ENDIAN */
X
X#endif	/* !NO_ALIGN_LIMIT */
X
X
X/* Public function prototypes */
Xbool_t	pthru_send(byte_t, word32_t, byte_t *, word32_t, byte_t, word32_t,
X		byte_t, byte_t, byte_t);
Xbool_t	pthru_open(char *);
Xvoid	pthru_close(void);
Xchar	*pthru_vers(void);
X
X
X#endif	/* sco && !DEMO_ONLY */
X
X#endif	/* __LIB_ODT_H__ */
X
END_OF_FILE
if test 3895 -ne `wc -c <'lib_odt.h'`; then
    echo shar: \"'lib_odt.h'\" unpacked with wrong size!
fi
# end of 'lib_odt.h'
fi
if test -f 'lib_pion.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib_pion.h'\"
else
echo shar: Extracting \"'lib_pion.h'\" \(7626 characters\)
sed "s/^X//" >'lib_pion.h' <<'END_OF_FILE'
X/*
X *   xmcd - Motif(tm) CD Audio Player
X *
X *   Copyright (C) 1993  Ti Kan
X *   E-mail: ti@amb.org
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 2 of the License, or
X *   (at your option) any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X *   The name "Pioneer" is a trademark of Pioneer Corporation, and is
X *   used here for identification purposes.  This software and its
X *   author are not affiliated in any way with Pioneer.
X *
X */
X#ifndef __LIB_PION_H__
X#define __LIB_PION_H__
X
X#ifdef PIONEER
X
X#ifndef LINT
Xstatic char *_lib_pion_h_ident_ = "@(#)lib_pion.h	1.19 93/10/01";
X#endif
X
X#ifndef VUSUPPORT
X#define VUSUPPORT
X#endif
X
X
X/* Pioneer vendor-unique commands */
X#define OP_VP_EJECT		0xc0	/* Pioneer magazine eject */
X#define OP_VP_RDTOC		0xc1	/* Pioneer read TOC */
X#define OP_VP_RDSUBQ		0xc2	/* Pioneer read subcode Q */
X#define OP_VP_RDHDR		0xc3	/* Pioneer read header */
X#define OP_VP_AUDSRCH		0xc8	/* Pioneer audio search */
X#define OP_VP_AUDPLAY		0xc9	/* Pioneer play audio */
X#define OP_VP_PAUSE		0xca	/* Pioneer pause */
X#define OP_VP_AUDSTOP		0xcb	/* Pioneer audio stop */
X#define OP_VP_AUDSTAT		0xcc	/* Pioneer audio status */
X#define OP_VP_AUDSCAN		0xcd	/* Pioneer audio scan */
X#define OP_VP_RDDSTAT		0xe0	/* Pioneer read drive status */
X#define OP_VP_WRCDP		0xe3	/* Pioneer write CDP */
X#define OP_VP_RDCDP		0xe4	/* Pioneer read CDP */
X
X
X/* Pioneer audio status codes */
X#define PAUD_PLAYING		0x00
X#define PAUD_PAUSED		0x01
X#define PAUD_MUTEPLAY		0x02
X#define PAUD_COMPLETED		0x03
X#define PAUD_ERROR		0x04
X#define PAUD_NOSTATUS		0x05
X
X
X/* Macros to compute the real offset of the data area in several
X * data structures.  The pad byte in the beginning of these structures
X * are there to prevent the compiler from inserting a pad byte in
X * the middle of the structure.  The alternative is to use #pragma pack(1),
X * but that's not very portable.
X */
X#define AD_VP_AUDSTAT(x)	((x)+1)	/* Pioneer audio status data addr */
X#define AD_VP_SUBQ(x)		((x)+1)	/* Pioneer read subcode data addr */
X
X/* Return data lengths */
X#define SZ_VP_RDTOC		4	/* Pioneer read TOC data size */
X#define SZ_VP_RDSUBQ		9	/* Pioneer read subcode Q data size */
X#define SZ_VP_AUDSTAT		6	/* Pioneer audio status data size */
X
X
X/* Pioneer read audio status command data */
Xtypedef struct paudstat_data {
X	unsigned int	pad0:8;		/* pad for alignment */
X	unsigned int	status:8;	/* audio status */
X#if BYTE_ORDER == LITTLE_ENDIAN
X	unsigned int	mode:4;		/* play mode */
X	unsigned int	res1:4;		/* reserved */
X	unsigned int	preemph:1;	/* preemphasis off=0 on=1 */
X	unsigned int	copyallow:1;	/* digital copy allowed off=0 on=1 */
X	unsigned int	trktype:1;	/* 0=audio 1=data */
X	unsigned int	audioch:1;	/* 0=2ch 1=4ch */
X	unsigned int	res2:4;		/* reserved */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X	unsigned int	res1:4;		/* reserved */
X	unsigned int	mode:4;		/* play mode */
X	unsigned int	res2:4;		/* reserved */
X	unsigned int	audioch:1;	/* 0=2ch 1=4ch */
X	unsigned int	trktype:1;	/* 0=audio 1=data */
X	unsigned int	copyallow:1;	/* digital copy allowed off=0 on=1 */
X	unsigned int	preemph:1;	/* preemphasis off=0 on=1 */
X#endif	/* BYTE_ORDER */
X
X	byte_t		abs_min;	/* absolute minutes (BCD) */
X	byte_t		abs_sec;	/* absolute seconds (BCD) */
X	byte_t		abs_frame;	/* absolute frame (BCD) */
X	byte_t		pad1;		/* pad for alignment */
X} paudstat_data_t;
X
X
X
X/* Pioneer read subcode Q command data */
Xtypedef struct psubq_data {
X	unsigned int	pad0:8;		/* pad for alignment */
X#if BYTE_ORDER == LITTLE_ENDIAN
X	unsigned int	preemph:1;	/* preemphasis off=0 on=1 */
X	unsigned int	copyallow:1;	/* digital copy allowed off=0 on=1 */
X	unsigned int	trktype:1;	/* 0=audio 1=data */
X	unsigned int	audioch:1;	/* 0=2ch 1=4ch */
X	unsigned int	res:4;		/* reserved */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X	unsigned int	res:4;		/* reserved */
X	unsigned int	audioch:1;	/* 0=2ch 1=4ch */
X	unsigned int	trktype:1;	/* 0=audio 1=data */
X	unsigned int	copyallow:1;	/* digital copy allowed off=0 on=1 */
X	unsigned int	preemph:1;	/* preemphasis off=0 on=1 */
X#endif	/* BYTE_ORDER */
X	unsigned int	trkno:8;	/* track number (BCD) */
X	unsigned int	idxno:8;	/* index number (BCD) */
X
X	byte_t		rel_min;	/* trk relative minutes (BCD) */
X	byte_t		rel_sec;	/* trk relative seconds (BCD) */
X	byte_t		rel_frame;	/* trk relative frame (BCD) */
X	byte_t		abs_min;	/* absolute minutes (BCD) */
X
X	byte_t		abs_sec;	/* absolute seconds (BCD) */
X	byte_t		abs_frame;	/* absolute frame (BCD) */
X	byte_t		pad1[2];	/* pad for alignment */
X} psubq_data_t;
X
X
X/* Pioneer read TOC command data */
Xtypedef struct pinfo_00 {		/* track information */
X	byte_t		first_trk;	/* first track (BCD) */
X	byte_t		last_trk;	/* last track (BCD) */
X	byte_t		reserved[2];	/* reserved */
X} pinfo_00_t;
X
Xtypedef struct pinfo_01 {		/* lead-out track starting time */
X	byte_t		min;		/* minutes (BCD) */
X	byte_t		sec;		/* seconds (BCD) */
X	byte_t		frame;		/* frame (BCD) */
X	byte_t		reserved;	/* reserved */
X} pinfo_01_t;
X
Xtypedef struct pinfo_02 {		/* specified track starting time */
X#if BYTE_ORDER == LITTLE_ENDIAN
X	unsigned int	preemph:1;	/* preemphasis off=0 on=1 */
X	unsigned int	copyallow:1;	/* digital copy allowed off=0 on=1 */
X	unsigned int	trktype:1;	/* 0=audio 1=data */
X	unsigned int	audioch:1;	/* 0=2ch 1=4ch */
X	unsigned int	res:4;		/* reserved */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X	unsigned int	res:4;		/* reserved */
X	unsigned int	audioch:1;	/* 0=2ch 1=4ch */
X	unsigned int	trktype:1;	/* 0=audio 1=data */
X	unsigned int	copyallow:1;	/* digital copy allowed off=0 on=1 */
X	unsigned int	preemph:1;	/* preemphasis off=0 on=1 */
X#endif	/* BYTE_ORDER */
X
X	unsigned int	min:8;		/* minutes (BCD) */
X	unsigned int	sec:8;		/* seconds (BCD) */
X	unsigned int	frame:8;	/* frame (BCD) */
X} pinfo_02_t;
X
X
X/* Argument of Pioneer audio search and audio play commands */
Xtypedef struct paudio_arg {
X	union {				/* address */
X		word32_t	tp_00;	/* absolute logical blk addr */
X#if BYTE_ORDER == LITTLE_ENDIAN
X		struct {
X			byte_t	frame;	/* frame (BCD) */
X			byte_t	sec;	/* seconds (BCD) */
X			byte_t	min;	/* minutes (BCD) */
X			byte_t	res;	/* reserved */
X		} tp_01;
X		struct {
X			byte_t	track;	/* track number (BCD) */
X			byte_t	res[3];	/* reserved */
X		} tp_10;
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X		struct {
X			byte_t	res;	/* reserved */
X			byte_t	min;	/* minutes (BCD) */
X			byte_t	sec;	/* seconds (BCD) */
X			byte_t	frame;	/* frame (BCD) */
X		} tp_01;
X		struct {
X			byte_t	res[3];	/* reserved */
X			byte_t	track;	/* track number (BCD) */
X		} tp_10;
X#endif	/* BYTE_ORDER */
X	} _addr;
X} paudio_arg_t;
X
X#define	addr_logical	_addr.tp_00
X#define	addr_min	_addr.tp_01.min
X#define	addr_sec	_addr.tp_01.sec
X#define	addr_frame	_addr.tp_01.frame
X#define	addr_track	_addr.tp_10.track
X
X
X/* Public function prototypes */
Xbool_t	pion_playaudio(byte_t, word32_t, word32_t, msf_t *, msf_t *,
X		byte_t, byte_t);
Xbool_t	pion_pause_resume(bool_t);
Xbool_t	pion_get_playstatus(curstat_t *, byte_t *);
Xbool_t	pion_get_toc(curstat_t *);
Xbool_t	pion_eject(void);
Xvoid	pion_init(void);
Xvoid	pion_halt(void);
X
X#endif	/* PIONEER */
X
X#endif	/* __LIB_PION_H__ */
X
END_OF_FILE
if test 7626 -ne `wc -c <'lib_pion.h'`; then
    echo shar: \"'lib_pion.h'\" unpacked with wrong size!
fi
# end of 'lib_pion.h'
fi
if test -f 'lib_scsipt.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib_scsipt.h'\"
else
echo shar: Extracting \"'lib_scsipt.h'\" \(13069 characters\)
sed "s/^X//" >'lib_scsipt.h' <<'END_OF_FILE'
X/*
X *   xmcd - Motif(tm) CD Audio Player
X *
X *   Copyright (C) 1993  Ti Kan
X *   E-mail: ti@amb.org
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 2 of the License, or
X *   (at your option) any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X */
X#ifndef __LIB_SCSIPT_H__
X#define __LIB_SCSIPT_H__
X
X#ifndef LINT
Xstatic char *_lib_scsipt_h_ident_ = "@(#)lib_scsipt.h	1.37 93/09/28";
X#endif
X
X#ifndef CDLIB_MODULE
X#define CDLIB_MODULE
X#endif
X
X
X/* Vendor unique operations code */
X#define VENDOR_SCSI2		0	/* Use SCSI-2 audio commands */
X#define VENDOR_TOSHIBA		1	/* Use Toshiba audio commands */
X#define VENDOR_NEC		2	/* Use NEC audio commands */
X#define VENDOR_PIONEER		3	/* Use Pioneer audio commands */
X#define VENDOR_HITACHI		4	/* Use Hitachi audio commands */
X
X
X/* Data direction code */
X#define READ_OP			0	/* SCSI data direction */
X#define WRITE_OP		1	/* SCSI data direction */
X
X
X/* Play audio format codes */
X#define ADDR_BLK		0x01	/* block address specified */
X#define ADDR_MSF		0x02	/* MSF address specified */
X#define ADDR_TRKIDX		0x04	/* track/index numbers specified */
X#define ADDR_OPTEND		0x80	/* End address can be ignored */
X
X
X/* Misc constants */
X#define MAX_SRCH_BLKS		225	/* max search play blks per sample */
X#define MAX_SCSIVOL		0xff	/* SCSI Mode Sense/Mode Select audio
X					 * volume maximum value.
X					 */
X#define MAX_RECOVERR		20	/* Max number of err recovery tries */
X#define ERR_SKIPBLKS		10	/* Number of frame to skip on error */
X#define ERR_CLRTHRESH		1500	/* If there hasn't been any errors
X					 * for this many blocks of audio
X					 * playback, then the previous errors
X					 * count is cleared.
X					 */
X
X
X/* SCSI command opcodes */
X
X/* 6-byte commands */
X#define OP_S_TEST		0x00	/* test unit ready */
X#define OP_S_REZERO		0x01	/* rezero */
X#define OP_S_RSENSE		0x03	/* request sense */
X#define OP_S_SEEK		0x0b	/* seek */
X#define OP_S_INQUIR		0x12	/* inquiry */
X#define OP_S_MSELECT		0x15	/* mode select */
X#define OP_S_MSENSE		0x1a	/* mode sense */
X#define OP_S_START		0x1b	/* start/stop unit */
X#define OP_S_PREVENT		0x1e	/* prevent/allow medium removal */
X
X/* 10-byte commands */
X#define OP_M_RDCAP		0x25	/* read capacity */
X#define OP_M_RDSUBQ		0x42	/* read subchannel */
X#define OP_M_RDTOC		0x43	/* read TOC */
X#define OP_M_RDHDR		0x44	/* read header */
X#define OP_M_PLAY		0x45	/* play audio */
X#define OP_M_PLAYMSF		0x47	/* play audio MSF */
X#define OP_M_PLAYTI		0x48	/* play audio track/index */
X#define OP_M_PLAYTR		0x49	/* play audio track relative */
X#define OP_M_PAUSE		0x4b	/* pause/resume */
X
X/* 12-byte commands */
X#define OP_L_PLAY		0xa5	/* play audio */
X#define OP_L_PLAYTR		0xa9	/* play audio track relative */
X
X
X/* Data buffer lengths */
X#define SZ_RDSUBQ		48	/* max read sub-channel Q data size */
X#define SZ_RDTOC		804	/* max read TOC data size */
X#define SZ_TOCHDR		4	/* TOC header size */
X#define SZ_TOCENT		8	/* TOC per-track entry size */
X#define SZ_MSENSE		60	/* max mode sense/mode sel data size */
X#define SZ_RSENSE		18	/* max request sense data size */
X
X/* Data buffer address */
X#define AD_RSENSE(x)		((byte_t *) (x) + 1)
X					/* start of real request sense data */
X
X
X/* Read Sub-channel audio status */
X#define AUDIO_NOTVALID		0x00	/* audio status not valid */
X#define AUDIO_PLAYING		0x11	/* audio play in progress */
X#define AUDIO_PAUSED		0x12	/* audio play paused */
X#define AUDIO_COMPLETED		0x13	/* audio play successfully completed */
X#define AUDIO_FAILED		0x14	/* audio played stopped due to error */
X#define AUDIO_NOSTATUS		0x15	/* no audio status */
X
X
X/* Mode sense/mode select page codes */
X#define PG_ERRECOV		0x01	/* error recovery parameters page */
X#define PG_DISCONN		0x02	/* disconn/conn parameters page */
X#define PG_CDROMCTL		0x0d	/* cd-rom control parameters page */
X#define PG_AUDIOCTL		0x0e	/* audio control parameters page */
X#define PG_ALL			0x3f	/* 0x01, 0x02, 0x0d and 0x0e */
X
X
X/* Read sub-channel format codes */
X#define SUB_ALL			0x00	/* sub-Q channel data */
X#define SUB_CURPOS		0x01	/* current CD-ROM position */
X#define SUB_CATNO		0x02	/* media catalog num (UPC/bar code) */
X#define SUB_ISRC		0x03	/* track ISRC code */
X
X
X/* Inquiry data misc definitions */
X#define DEV_ROM			0x05	/* ROM peripheral device type */
X#define DEV_CONNECTED		0x00	/* peripheral qualifier */
X
X
X/* The inquiry data structure */
Xtypedef struct inquiry_data {
X#if BYTE_ORDER == LITTLE_ENDIAN
X	unsigned int	type:5;		/* peripheral device type */
X	unsigned int	pqual:3;	/* peripheral qualifier */
X	unsigned int	qualif:7;	/* device type qualifier */
X	unsigned int	rmb:1;		/* removable media */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X	unsigned int	pqual:3;	/* peripheral qualifier */
X	unsigned int	type:5;		/* peripheral device type */
X	unsigned int	rmb:1;		/* removable media */
X	unsigned int	qualif:7;	/* device type qualifier */
X#endif	/* BYTE_ORDER */
X
X	unsigned int	ver:8;		/* SCSI version */
X	unsigned int	res1:8;		/* reserved */
X
X	byte_t		len;		/* length of additional data */
X	byte_t		res2[3];	/* reserved */
X	byte_t		vendor[8];	/* vendor ID */
X	byte_t		prod[16];	/* product ID */
X	byte_t		revnum[4];	/* revision number */
X} inquiry_data_t;
X
X
X/* The Mode Sense/Mode Select data structures */
X
X/* Block descriptor data structure */
Xtypedef struct blk_desc {
X	unsigned int	dens_code:8;	/* density code */
X	unsigned int	num_blks:24;	/* number of blocks */
X
X	unsigned int	res:8;		/* reserved */
X	unsigned int	blk_len:24;	/* block length */
X} blk_desc_t;
X
X/* Audio-parameters page data structure */
Xtypedef struct audio_pg {
X#if BYTE_ORDER == LITTLE_ENDIAN
X	unsigned int	pg_code:6;	/* page code */
X	unsigned int	res:2;		/* reserved */
X	unsigned int	pg_len:8;	/* page length */
X	unsigned int	res1:1;		/* reserved */
X	unsigned int	sotc:1;		/* SOTC */
X	unsigned int	immed:1;	/* immediate */
X	unsigned int	res2:5;		/* reserved */
X	unsigned int	res3:8;		/* reserved */
X
X	unsigned int	res4:16;	/* reserved */
X	unsigned int	audio_bps:16;	/* logical blocks per second */
X
X	unsigned int	p0_ch_ctrl:4;	/* port 0 channel control */
X	unsigned int	res5:4;		/* reserved */
X	unsigned int	p0_vol:8;	/* port 0 volume */
X	unsigned int	p1_ch_ctrl:4;	/* port 1 channel control */
X	unsigned int	res6:4;		/* reserved */
X	unsigned int	p1_vol:8;	/* port 1 volume */
X
X	unsigned int	p2_ch_ctrl:4;	/* port 2 channel control */
X	unsigned int	res7:4;		/* reserved */
X	unsigned int	p2_vol:8;	/* port 2 volume */
X	unsigned int	p3_ch_ctrl:4;	/* port 3 channel control */
X	unsigned int	res8:4;		/* reserved */
X	unsigned int	p3_vol:8;	/* port 3 volume */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X	unsigned int	res:2;		/* reserved */
X	unsigned int	pg_code:6;	/* page code */
X	unsigned int	pg_len:8;	/* page length */
X	unsigned int	res2:5;		/* reserved */
X	unsigned int	immed:1;	/* immediate */
X	unsigned int	sotc:1;		/* SOTC */
X	unsigned int	res1:1;		/* reserved */
X	unsigned int	res3:8;		/* reserved */
X
X	unsigned int	res4:16;	/* reserved */
X	unsigned int	audio_bps:16;	/* logical blocks per second */
X
X	unsigned int	res5:4;		/* reserved */
X	unsigned int	p0_ch_ctrl:4;	/* port 0 channel control */
X	unsigned int	p0_vol:8;	/* port 0 volume */
X	unsigned int	res6:4;		/* reserved */
X	unsigned int	p1_ch_ctrl:4;	/* port 1 channel control */
X	unsigned int	p1_vol:8;	/* port 1 volume */
X
X	unsigned int	res7:4;		/* reserved */
X	unsigned int	p2_ch_ctrl:4;	/* port 2 channel control */
X	unsigned int	p2_vol:8;	/* port 2 volume */
X	unsigned int	res8:4;		/* reserved */
X	unsigned int	p3_ch_ctrl:4;	/* port 3 channel control */
X	unsigned int	p3_vol:8;	/* port 3 volume */
X#endif	/* BYTE_ORDER */
X} audio_pg_t;
X
X/* Mode Sense/Mode Select data structure */
Xtypedef struct mode_sense_data {
X	/* mode header */
X	unsigned int	data_len:8;	/* data length */
X	unsigned int	medium:8;	/* medium */
X#if BYTE_ORDER == LITTLE_ENDIAN
X	unsigned int	speed:4;	/* speed */
X	unsigned int	buffered:3;	/* buffered */
X	unsigned int	wprot:1;	/* write protected */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X	unsigned int	wprot:1;	/* write protected */
X	unsigned int	buffered:3;	/* buffered */
X	unsigned int	speed:4;	/* speed */
X#endif	/* BYTE_ORDER */
X	unsigned int	bdescr_len:8;	/* block descriptor length */
X
X	byte_t		data[24];	/* block desc/page desc data */
X} mode_sense_data_t;
X
X
X/* Request Sense data structure */
Xtypedef struct req_sense_data {
X	unsigned int	pad:8;		/* pad byte for alignment */
X#if BYTE_ORDER == LITTLE_ENDIAN
X	unsigned int	errcode:7;	/* error code */
X	unsigned int	valid:1;	/* valid bit */
X	unsigned int	segno:8;	/* segment number */
X	unsigned int	key:4;		/* sense key */
X	unsigned int	res:1;		/* reserved */
X	unsigned int	ili:1;		/* ILI */
X	unsigned int	eom:1;		/* end-of-medium */
X	unsigned int	fm:1;		/* filemark */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X	unsigned int	valid:1;	/* valid bit */
X	unsigned int	errcode:7;	/* error code */
X	unsigned int	segno:8;	/* segment number */
X	unsigned int	fm:1;		/* filemark */
X	unsigned int	eom:1;		/* end-of-medium */
X	unsigned int	ili:1;		/* ILI */
X	unsigned int	res:1;		/* reserved */
X	unsigned int	key:4;		/* sense key */
X#endif	/* BYTE_ORDER */
X
X	byte_t		info[4];	/* information */
X
X	byte_t	 	addl_len;	/* additional sense length */
X	byte_t		cmd_spec[4];	/* command specific information */
X
X	byte_t		code;		/* additional sense code */
X	byte_t		qual;		/* additional sense code qualifier */
X
X	byte_t		fruc;		/* field replaceable unit code */
X	byte_t		key_spec[3];	/* sense-key specific */
X} req_sense_data_t;
X
X
X/* CD position MSF structure */
Xtypedef struct msf {
X	byte_t		res;		/* reserved */
X	byte_t		min;		/* minutes */
X	byte_t		sec;		/* seconds */
X	byte_t		frame;		/* frame */
X} msf_t;
X
X
X/* Combined MSF and logical address union */
Xtypedef union lmsf {
X	msf_t		msf;		/* MSF address */
X	word32_t	logical;	/* logical address */
X} lmsf_t;
X
X
X/* Read subchannel Q data header */
Xtypedef struct subq_hdr {
X	byte_t		reserved;	/* reserved */
X	byte_t		audio_status;	/* audio status */
X	word16_t	subch_len;	/* subchannel data length */
X} subq_hdr_t;
X
X
X/* Subchannel Q data - format 01 (CD-ROM Current Position) */
Xtypedef struct subq_01 {
X	unsigned int	fmt_code:8;	/* format code */
X#if BYTE_ORDER == LITTLE_ENDIAN
X	unsigned int	preemph:1;	/* preemphasis */
X	unsigned int	copyallow:1;	/* digital copy allow */
X	unsigned int	trktype:1;	/* 0=audio 1=data */
X	unsigned int	audioch:1;	/* 0=2ch 1=4ch */
X	unsigned int	adr:4;		/* ADR */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X	unsigned int	adr:4;		/* ADR */
X	unsigned int	audioch:1;	/* 0=2ch 1=4ch */
X	unsigned int	trktype:1;	/* 0=audio 1=data */
X	unsigned int	copyallow:1;	/* digital copy allow */
X	unsigned int	preemph:1;	/* preemphasis */
X#endif	/* BYTE_ORDER */
X	unsigned int	trkno:8;	/* track number */
X	unsigned int	idxno:8;	/* index number */
X
X	lmsf_t		abs_addr;	/* absolute address */
X	lmsf_t		rel_addr;	/* track-relative address */
X} subq_01_t;
X
X
X/* Read TOC command data header */
Xtypedef struct toc_hdr {
X	word16_t	data_len;	/* TOC data length */
X	byte_t		first_trk;	/* first track number */
X	byte_t		last_trk;	/* last track number */
X} toc_hdr_t;
X
X
X/* Read TOC command track descriptor */
Xtypedef struct toc_trk_descr {
X	unsigned int	res1:8;		/* reserved */
X#if BYTE_ORDER == LITTLE_ENDIAN
X	unsigned int	preemph:1;	/* preemphasis */
X	unsigned int	copyallow:1;	/* digital copy allow */
X	unsigned int	trktype:1;	/* 0=audio 1=data */
X	unsigned int	audioch:1;	/* 0=2ch 1=4ch */
X	unsigned int	adr:4;		/* ADR */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X	unsigned int	adr:4;		/* ADR */
X	unsigned int	audioch:1;	/* 0=2ch 1=4ch */
X	unsigned int	trktype:1;	/* 0=audio 1=data */
X	unsigned int	copyallow:1;	/* digital copy allow */
X	unsigned int	preemph:1;	/* preemphasis */
X#endif	/* BYTE_ORDER */
X	unsigned int	trkno:8;	/* track number */
X	unsigned int	res2:8;		/* reserved */
X
X	lmsf_t		abs_addr;	/* absolute address */
X} toc_trk_descr_t;
X
X
X/***** Additional include files *****/
X
X/* OS interface library headers */
X#include "lib_hpux.h"			/* HP-UX support header */
X#include "lib_odt.h"			/* SCO ODT support header */
X#include "lib_sun.h"			/* SunOS support header */
X#include "lib_svr4.h"			/* SVR4 support header */
X#include "lib_demo.h"			/* Demo-only support header -
X					 * This must be included last.
X					 */
X
X/* Vendor-unique library headers */
X#ifdef HITACHI
X#include "lib_hita.h"			/* Hitachi vendor-unique header */
X#endif
X#ifdef NEC
X#include "lib_nec.h"			/* NEC vendor-unique header */
X#endif
X#ifdef PIONEER
X#include "lib_pion.h"			/* Pioneer vendor-unique header */
X#endif
X#ifdef TOSHIBA
X#include "lib_tosh.h"			/* Toshiba vendor-unique header */
X#endif
X
X
X#endif	/* __LIB_SCSIPT_H__ */
X
END_OF_FILE
if test 13069 -ne `wc -c <'lib_scsipt.h'`; then
    echo shar: \"'lib_scsipt.h'\" unpacked with wrong size!
fi
# end of 'lib_scsipt.h'
fi
if test -f 'lib_sim.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib_sim.h'\"
else
echo shar: Extracting \"'lib_sim.h'\" \(3425 characters\)
sed "s/^X//" >'lib_sim.h' <<'END_OF_FILE'
X/*
X *   xmcd - Motif(tm) CD Audio Player
X *
X *   Copyright (C) 1993  Ti Kan
X *   E-mail: ti@amb.org
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 2 of the License, or
X *   (at your option) any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X */
X#ifndef __LIB_SIM_H__
X#define __LIB_SIM_H__
X
X#if !defined(OSI_MODULE) || defined(DEMO_ONLY)
X
X#ifndef LINT
Xstatic char *_lib_sim_h_ident_ = "@(#)lib_sim.h	1.10 93/09/28";
X#endif
X
X#define SIMULATED_CDROM			/* Use CD-ROM simulator */
X
X
X#define CDSIM_MAGIC	0x584d4344	/* Magic number */
X#define MAX_DATALEN	1000		/* Max I/O data length */
X
X/* Return status codes */
X#define CDSIM_COMPOK	0		/* Command completed OK */
X#define CDSIM_COMPERR	1		/* Command completed with error */
X#define CDSIM_NOTSUPP	2		/* Command not supported */
X#define CDSIM_PARMERR	3		/* Command parameter error */
X#define CDSIM_PKTERR	4		/* Command packet error */
X
X
X/* CD simulator IPC packet structure (1024 bytes in size) */
Xtypedef struct simpkt {
X	word32_t	magic;		/* Magic number */
X
X	byte_t		pktid;		/* Packet id */
X	byte_t		retcode;	/* Return code */
X	byte_t		dir;		/* Data direction: READ_OP/WRITE_OP */
X	byte_t		cdbsz;		/* CDB size */
X
X	word32_t	len;		/* Data length in bytes */
X
X	byte_t		cdb[12];	/* CDB data */
X
X	byte_t		data[MAX_DATALEN];
X					/* I/O Data */
X} simpkt_t;
X
X
X#define CDSIM_NODISC	0x00		/* CD simulator no disc */
X#define CDSIM_STOPPED	0x01		/* CD simulator stopped */
X#define CDSIM_PAUSED	0x02		/* CD simulator paused */
X#define CDSIM_PLAYING	0x03		/* CD simulator playing audio */
X
X#define CDSIM_NTRKS	10		/* Number of tracks on simulated CD */
X#define CDSIM_NIDXS	4		/* Number of index/track on sim CD */
X#define CDSIM_TRKLEN	4500		/* Length of each simulated track */
X#define CDSIM_IDXLEN	1125		/* Length of each simulated track */
X
X/* CD simulator internal status structures */
X
Xtypedef struct trkstat {
X	word32_t	addr;		/* Starting absolute addr of track */
X	byte_t		nidxs;		/* Number of indices */
X	byte_t		rsvd[3];	/* Reserved */
X	word32_t	iaddr[CDSIM_NIDXS];
X					/* Index absolute addresses */
X} trkstat_t;
X
Xtypedef struct simstat {
X	byte_t		status;		/* Current mode status flag */
X	byte_t		ntrks;		/* Number of tracks */
X	byte_t		trkno;		/* Current track */
X	byte_t		idxno;		/* Current index */
X
X	word32_t	absaddr;	/* Current absolute address */
X	word32_t	reladdr;	/* Current relative address */
X	trkstat_t	trk[MAXTRACK];	/* Per-track information */
X	word32_t	startaddr;	/* Start play address */
X	word32_t	endaddr;	/* End play address */
X
X	bool_t		caddylock;	/* Caddy locked */
X} simstat_t;
X
X
X#define CDSIM_PKTSZ	sizeof(simpkt_t)
X#define CDSIM_INQSZ	sizeof(inquiry_data_t)
X
X
X/* Public function prototypes */
Xbool_t	cdsim_sendpkt(char *, int, simpkt_t *);
Xbool_t	cdsim_getpkt(char *, int, simpkt_t *);
Xvoid	cdsim_main(void);
X
X#endif	/* !OSI_MODULE || DEMO_ONLY */
X
X#endif	/* __LIB_SIM_H__ */
X
END_OF_FILE
if test 3425 -ne `wc -c <'lib_sim.h'`; then
    echo shar: \"'lib_sim.h'\" unpacked with wrong size!
fi
# end of 'lib_sim.h'
fi
if test -f 'lib_sun.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib_sun.h'\"
else
echo shar: Extracting \"'lib_sun.h'\" \(2185 characters\)
sed "s/^X//" >'lib_sun.h' <<'END_OF_FILE'
X/*
X *   xmcd - Motif(tm) CD Audio Player
X *
X *   Copyright (C) 1993  Ti Kan
X *   E-mail: ti@amb.org
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 2 of the License, or
X *   (at your option) any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X *   This software module contains code that interfaces xmcd to
X *   the SunOS operating systems.  The name "Sun" and "SunOS"
X *   are used here for identification purposes.  This software and
X *   its author are not affiliated with Sun Microsystems.
X */
X#ifndef __LIB_SUN_H__
X#define __LIB_SUN_H__
X
X#if defined(sun) && !defined(DEMO_ONLY)
X
X#ifndef LINT
Xstatic char *_lib_sun_h_ident_ = "@(#)lib_sun.h	1.7 93/10/06";
X#endif
X
X#ifdef SVR4
X
X#include <sys/scsi/impl/uscsi.h>
X#define USCSI_STATUS_GOOD	0
X
X#else	/* !SVR4 */
X
X#include <scsi/impl/uscsi.h>
X#undef USCSI_WRITE
X#define USCSI_WRITE		0
X
X/* This is a hack to work around a bug in SunOS 4.x's _IOWR macro
X * in <sys/ioccom.h> which makes it incompatible with ANSI compilers.
X * If Sun ever changes the definition of USCSICMD or _IOWR then
X * this will have to change...
X */
X#undef _IOWR
X#undef USCSICMD
X
X#define _IOWR(x,y,t)	( \
X				_IOC_INOUT | \
X				((sizeof(t) & _IOCPARM_MASK) << 16) | \
X				((x) << 8) | (y) \
X			)
X#define USCSICMD	_IOWR('u', 1, struct uscsi_cmd)
X
X#endif	/* SVR4 */
X
X
X#ifndef OSI_MODULE
X#define OSI_MODULE
X#endif
X
X
X/* Public function prototypes */
Xbool_t	pthru_send(byte_t, word32_t, byte_t *, word32_t, byte_t, word32_t,
X		byte_t, byte_t, byte_t);
Xbool_t	pthru_open(char *);
Xvoid	pthru_close(void);
Xchar	*pthru_vers(void);
X
X
X#endif	/* sun && !DEMO_ONLY */
X
X#endif	/* __LIB_SUN_H__ */
X
END_OF_FILE
if test 2185 -ne `wc -c <'lib_sun.h'`; then
    echo shar: \"'lib_sun.h'\" unpacked with wrong size!
fi
# end of 'lib_sun.h'
fi
if test -f 'lib_svr4.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib_svr4.h'\"
else
echo shar: Extracting \"'lib_svr4.h'\" \(5120 characters\)
sed "s/^X//" >'lib_svr4.h' <<'END_OF_FILE'
X/*
X *   xmcd - Motif(tm) CD Audio Player
X *
X *   Copyright (C) 1993  Ti Kan
X *   E-mail: ti@amb.org
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 2 of the License, or
X *   (at your option) any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X */
X#ifndef __LIB_SVR4_H__
X#define __LIB_SVR4_H__
X
X#if defined(SVR4) && !defined(sun) && !defined(DEMO_ONLY)
X
X#ifndef LINT
Xstatic char *_lib_svr4_h_ident_ = "@(#)lib_svr4.h	1.31 93/10/06";
X#endif
X
X#ifdef i386
X/*
X *   Intel x86 UNIX SVR4 support
X *   Portable Device Interface/SCSI Device Interface
X *
X *   This software fragment contains code that interfaces xmcd to
X *   the UNIX System V Release 4 operating system for the Intel
X *   x86 hardware platforms from UNIX System Laboratories.
X *   The name "USL", "UNIX" and "Intel" are used here for
X *   identification purposes.  This software and its author are
X *   not affiliated with USL or Intel.
X */
X
X#include <sys/scsi.h>
X#include <sys/sdi_edt.h>
X#include <sys/sdi.h>
X
X#ifndef OSI_MODULE
X#define OSI_MODULE
X#endif
X
X
X/* Macros to update various fields of the SCSI CDB structures.
X * These are used to work around byte alignment restrictions and
X * padding with some compilers.  In general, define NO_ALIGN_LIMIT
X * if and only if you are sure that the compiler will not insert
X * pad bytes between any field of the SCSI CDB structure.
X */
X
X#ifdef NO_ALIGN_LIMIT
X
X#define CDB6_BLK(a,d)	(a)->ss_addr = (d)
X#define CDB6_LEN(a,d)	(a)->ss_len = (d)
X#define CDB6_CTL(a,d)	(a)->ss_cont = (d)
X#define CDB10_BLK(a,d)	(a)->sm_addr = (d)
X#define CDB10_LEN(a,d)	(a)->sm_len = (d)
X#define CDB10_RSV(a,d)	(a)->sm_res2 = (d)
X#define CDB10_CTL(a,d)	(a)->sm_cont = (d)
X#define CDB12_BLK(a,d)	(a)->sl_addr = (d)
X#define CDB12_LEN(a,d)	(a)->sl_len = (d)
X#define CDB12_RSV(a,d)	(a)->sl_res2 = (d)
X#define CDB12_CTL(a,d)	(a)->sl_cont = (d)
X
X#else	/* !NO_ALIGN_LIMIT */
X
X#if BYTE_ORDER == LITTLE_ENDIAN
X
X#define CDB6_BLK(a,d)	{					\
X	register word16_t *p = (word16_t *)(void *) SCS_AD(a);	\
X	p[1] = (d);						\
X}
X#define CDB6_LEN(a,d)	{					\
X	register byte_t *p = (byte_t *) SCS_AD(a);		\
X	p[4] = (d);						\
X}
X#define CDB6_CTL(a,d)	{					\
X	register byte_t *p = (byte_t *) SCS_AD(a);		\
X	p[5] = (d);						\
X}
X#define CDB10_BLK(a,d)	{					\
X	register word16_t *p = (word16_t *)(void *) SCM_AD(a);	\
X	p[1] = (word16_t) (d);					\
X	p[2] = (word16_t) ((d) >> 16);				\
X}
X#define CDB10_LEN(a,d)	{					\
X	register byte_t *p = (byte_t *) SCM_AD(a);		\
X	p[7] = (byte_t) (d);					\
X	p[8] = (byte_t) ((d) >> 8);				\
X}
X#define CDB10_RSV(a,d)	{					\
X	register byte_t *p = (byte_t *) SCM_AD(a);		\
X	p[6] = (d);						\
X}
X#define CDB10_CTL(a,d)	{					\
X	register byte_t *p = (byte_t *) SCM_AD(a);		\
X	p[9] = (d);						\
X}
X#define CDB12_BLK(a,d)	{					\
X	register word16_t *p = (word16_t *)(void *) SCL_AD(a);	\
X	p[1] = (word16_t) (d);					\
X	p[2] = (word16_t) ((d) >> 16);				\
X}
X#define CDB12_LEN(a,d)	{					\
X	register word16_t *p = (word16_t *)(void *) SCL_AD(a);	\
X	p[3] = (word16_t) (d);					\
X	p[4] = (word16_t) ((d) >> 16);				\
X}
X#define CDB12_RSV(a,d)	{					\
X	register byte_t *p = (byte_t *) SCL_AD(a);		\
X	p[10] = (d);						\
X}
X#define CDB12_CTL(a,d)	{					\
X	register byte_t *p = (byte_t *) SCL_AD(a);		\
X	p[11] = (d);						\
X}
X
X#endif	/* BYTE_ORDER == LITTLE_ENDIAN */
X
X#endif	/* !NO_ALIGN_LIMIT */
X
X
X#ifndef SCL_AD
X
X/* SCSI 12-byte CDB */
X#define SCL_AD(x)	((byte_t *) (x) + 2)
X#define SCL_SZ		12
X
Xstruct scl {
X	unsigned int	sl_pad0:16;	/* pad for alignment */
X	unsigned int	sl_op:8;	/* Opcode */
X	unsigned int	sl_res1:5;	/* Reserved field */
X	unsigned int	sl_lun:3;	/* Logical unit number */
X
X	word32_t	sl_addr;	/* Block address */
X	word32_t	sl_len;		/* Transfer length */
X
X	byte_t		sl_res2;	/* Reserved field */
X	byte_t		sl_cont;	/* Control byte */
X};
X 
X#endif	/* SCL_AD */
X
X
X/* SCSI Command Descriptor Block union */
Xunion scsi_cdb {
X	struct scs	scs;
X	struct scm	scm;
X	struct scl	scl;
X};
X
X#endif	/* i386 */
X
X#ifdef MOTOROLA
X/*
X *   Motorola 88k UNIX SVR4 support
X *
X *   This software fragment contains code that interfaces xmcd to
X *   the System V Release 4 operating system from Motorola.
X *   The name "Motorola" is used here for identification purposes.
X */
X
X#include <sys/param.h>
X#include <sys/dk.h>
X
X#ifndef OSI_MODULE
X#define OSI_MODULE
X#endif
X
X#endif	/* MOTOROLA */
X
X
X/* Public function prototypes */
Xbool_t	pthru_send(byte_t, word32_t, byte_t *, word32_t, byte_t, word32_t,
X		byte_t, byte_t, byte_t);
Xbool_t	pthru_open(char *);
Xvoid	pthru_close(void);
Xchar	*pthru_vers(void);
X
X#endif	/* SVR4 && !sun && !DEMO_ONLY */
X
X#endif	/* __LIB_SVR4_H__ */
X
END_OF_FILE
if test 5120 -ne `wc -c <'lib_svr4.h'`; then
    echo shar: \"'lib_svr4.h'\" unpacked with wrong size!
fi
# end of 'lib_svr4.h'
fi
if test -f 'lib_tosh.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lib_tosh.h'\"
else
echo shar: Extracting \"'lib_tosh.h'\" \(5199 characters\)
sed "s/^X//" >'lib_tosh.h' <<'END_OF_FILE'
X/*
X *   xmcd - Motif(tm) CD Audio Player
X *
X *   Copyright (C) 1993  Ti Kan
X *   E-mail: ti@amb.org
X *
X *   This program is free software; you can redistribute it and/or modify
X *   it under the terms of the GNU General Public License as published by
X *   the Free Software Foundation; either version 2 of the License, or
X *   (at your option) any later version.
X *
X *   This program is distributed in the hope that it will be useful,
X *   but WITHOUT ANY WARRANTY; without even the implied warranty of
X *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
X *   GNU General Public License for more details.
X *
X *   You should have received a copy of the GNU General Public License
X *   along with this program; if not, write to the Free Software
X *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X *   The name "Toshiba" is a trademark of Toshiba Corporation, and is
X *   used here for identification purposes.  This software and its
X *   author are not affiliated in any way with Toshiba.
X *
X */
X#ifndef __LIB_TOSH_H__
X#define __LIB_TOSH_H__
X
X#ifdef TOSHIBA
X
X#ifndef LINT
Xstatic char *_lib_tosh_h_ident_ = "@(#)lib_tosh.h	1.24 93/10/01";
X#endif
X
X#ifndef VUSUPPORT
X#define VUSUPPORT
X#endif
X
X
X/* Toshiba vendor-unique commands */
X#define OP_VT_AUDSRCH		0xc0	/* Toshiba audio track search */
X#define OP_VT_AUDPLAY		0xc1	/* Toshiba play audio */
X#define OP_VT_STILL		0xc2	/* Toshiba still */
X#define OP_VT_SETSTOP		0xc3	/* Toshiba set stop time */
X#define OP_VT_EJECT		0xc4	/* Toshiba caddy eject */
X#define OP_VT_RDSUBQ		0xc6	/* Toshiba read status */
X#define OP_VT_RDINFO		0xc7	/* Toshiba read disk info */
X#define OP_VT_RDMODE		0xc8	/* Toshiba read CDROM mode */
X
X
X/* Toshiba audio status codes */
X#define TAUD_PLAYING		0x00
X#define TAUD_PAUSED		0x01
X#define TAUD_SRCH_PAUSED	0x02
X#define TAUD_OTHER		0x03
X
X
X/* Return data lengths */
X#define SZ_VT_RDSUBQ		10	/* Toshiba read sub-code Q data size */
X#define SZ_VT_RDINFO		4	/* Toshiba read disc info data size */
X#define SZ_VT_RDMODE		1	/* Toshiba read cdrom mode data size */
X
X
X/* Toshiba read sub-code Q command data */
Xtypedef struct tsubq_data {
X	unsigned int	audio_status:8;	/* audio status */
X#if BYTE_ORDER == LITTLE_ENDIAN
X	unsigned int	preemph:1;	/* preemphasis */
X	unsigned int	copyallow:1;	/* digital copy allow */
X	unsigned int	trktype:1;	/* 0=audio 1=data */
X	unsigned int	audioch:1;	/* 0=2ch 1=4ch */
X	unsigned int	reserved:4;	/* reserved */
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X	unsigned int	reserved:4;	/* reserved */
X	unsigned int	audioch:1;	/* 0=2ch 1=4ch */
X	unsigned int	trktype:1;	/* 0=audio 1=data */
X	unsigned int	copyallow:1;	/* digital copy allow */
X	unsigned int	preemph:1;	/* preemphasis */
X#endif	/* BYTE_ORDER */
X	unsigned int	trkno:8;	/* track number (BCD) */
X	unsigned int	idxno:8;	/* index number (BCD) */
X
X	byte_t		rel_min;	/* trk relative minutes (BCD) */
X	byte_t		rel_sec;	/* trk relative seconds (BCD) */
X	byte_t		rel_frame;	/* trk relative frame (BCD) */
X	byte_t		abs_min;	/* absolute minutes (BCD) */
X
X	byte_t		abs_sec;	/* absolute seconds (BCD) */
X	byte_t		abs_frame;	/* absolute frame (BCD) */
X	byte_t		pad1[2];	/* pad for alignment */
X} tsubq_data_t;
X
X
X/* Toshiba read disc information command data */
Xtypedef struct tinfo_00 {		/* track information */
X	byte_t		first_trk;	/* first track (BCD) */
X	byte_t		last_trk;	/* last track (BCD) */
X	byte_t		reserved[2];	/* reserved */
X} tinfo_00_t;
X
Xtypedef struct tinfo_01 {		/* lead-out track starting time */
X	byte_t		min;		/* minutes (BCD) */
X	byte_t		sec;		/* seconds (BCD) */
X	byte_t		frame;		/* frame (BCD) */
X	byte_t		reserved;	/* reserved */
X} tinfo_01_t;
X
Xtypedef struct tinfo_02 {		/* specified track starting time */
X	byte_t		min;		/* minutes (BCD) */
X	byte_t		sec;		/* seconds (BCD) */
X	byte_t		frame;		/* frame (BCD) */
X	byte_t		reserved;	/* reserved */
X} tinfo_02_t;
X
X
X/* Argument of Toshiba audio search and play audio commands */
Xtypedef struct taudio_arg {
X	union {				/* address */
X		word32_t	tp_00;	/* absolute logical blk addr */
X#if BYTE_ORDER == LITTLE_ENDIAN
X		struct {
X			byte_t	res;	/* reserved */
X			byte_t	frame;	/* frame (BCD) */
X			byte_t	sec;	/* seconds (BCD) */
X			byte_t	min;	/* minutes (BCD) */
X		} tp_01;
X		struct {
X			byte_t	res[3];	/* reserved */
X			byte_t	track;	/* track number (BCD) */
X		} tp_10;
X#else	/* BYTE_ORDER == BIG_ENDIAN */
X		struct {
X			byte_t	min;	/* minutes (BCD) */
X			byte_t	sec;	/* seconds (BCD) */
X			byte_t	frame;	/* frame (BCD) */
X			byte_t	res;	/* reserved */
X		} tp_01;
X		struct {
X			byte_t	track;	/* track number (BCD) */
X			byte_t	res[3];	/* reserved */
X		} tp_10;
X#endif	/* BYTE_ORDER */
X	} _addr;
X} taudio_arg_t;
X
X#define	addr_logical	_addr.tp_00
X#define	addr_min	_addr.tp_01.min
X#define	addr_sec	_addr.tp_01.sec
X#define	addr_frame	_addr.tp_01.frame
X#define	addr_track	_addr.tp_10.track
X
X
X/* Public function prototypes */
Xbool_t	tosh_playaudio(byte_t, word32_t, word32_t, msf_t *, msf_t *,
X		byte_t, byte_t);
Xbool_t	tosh_pause_resume(bool_t);
Xbool_t	tosh_get_playstatus(curstat_t *, byte_t *);
Xbool_t	tosh_get_toc(curstat_t *);
Xbool_t	tosh_mute(bool_t);
Xbool_t	tosh_eject(void);
Xvoid	tosh_init(void);
Xvoid	tosh_halt(void);
X
X#endif	/* TOSHIBA */
X
X#endif	/* __LIB_TOSH_H__ */
X
END_OF_FILE
if test 5199 -ne `wc -c <'lib_tosh.h'`; then
    echo shar: \"'lib_tosh.h'\" unpacked with wrong size!
fi
# end of 'lib_tosh.h'
fi
echo shar: End of archive 3 \(of 13\).
cp /dev/null ark3isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 13 archives.
    echo "Now read the README and INSTALL files for further instructions."
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
    ///  Ti Kan                vorsprung durch technik
   ///   AMB Research Laboratories, Sunnyvale, CA. USA
  ///    ti@amb.org
 //////  ...!{decwrl,synopsys,tandem,tsoft,ultra}!sgiblab!bazooka!ti
///      ...!uunet!bazooka!ti



exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga: The only way to fly!  |    sources-x@sterling.com
       "It's intuitively obvious to the most casual observer..."
 GCS d++(--) -p+ c++ !l u++ e+ m+(-) s++/++ n h--- f+ g+++ w+ t++ r+ y+
