Newsgroups: comp.sources.x
From: andru@tonic.lcs.mit.edu (Andrew Myers)
Subject: v21i059:  xsokoban - Simple but complex move the stones game, Part02/04
Message-ID: <1993Dec18.230056.19212@sparky.sterling.com>
X-Md4-Signature: 856140b93139659da0b76bac8646f991
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Sat, 18 Dec 1993 23:00:56 GMT
Approved: chris@sterling.com

Submitted-by: andru@tonic.lcs.mit.edu (Andrew Myers)
Posting-number: Volume 21, Issue 59
Archive-name: xsokoban/part02
Environment: X11, ansi

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  xsokoban-3.0/README xsokoban-3.0/config.h
#   xsokoban-3.0/config_local.h xsokoban-3.0/defaults.h
#   xsokoban-3.0/errors.h xsokoban-3.0/globals.h xsokoban-3.0/help.h
#   xsokoban-3.0/main.c xsokoban-3.0/options.h
#   xsokoban-3.0/resources.c xsokoban-3.0/save.c xsokoban-3.0/screen.c
#   xsokoban-3.0/screens/screen.10 xsokoban-3.0/screens/screen.14
#   xsokoban-3.0/screens/screen.20 xsokoban-3.0/screens/screen.22
#   xsokoban-3.0/screens/screen.24 xsokoban-3.0/screens/screen.25
#   xsokoban-3.0/screens/screen.35 xsokoban-3.0/screens/screen.36
#   xsokoban-3.0/screens/screen.39 xsokoban-3.0/screens/screen.41
#   xsokoban-3.0/screens/screen.50 xsokoban-3.0/screens/screen.85
#   xsokoban-3.0/screens/screen.89 xsokoban-3.0/screens/screen.90
#   xsokoban-3.0/xsokoban.man
# Wrapped by chris@sparky on Sat Dec 18 16:54:30 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 2 (of 4)."'
if test -f 'xsokoban-3.0/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/README'\"
else
  echo shar: Extracting \"'xsokoban-3.0/README'\" \(2391 characters\)
  sed "s/^X//" >'xsokoban-3.0/README' <<'END_OF_FILE'
XXSokoban 3.0
X------------
X
XThis is the third release of XSokoban.
X
XThis distribution contains all the files to compile and run the game,
Xthe original 50 sokoban screen files, 40 additional screen files
Xgleaned from various public domain versions of sokoban, and a manual
Xpage that explains how the game works.
X
XInstallation -
X  - Edit the header files config.h and config_local.h to define the
X    appropriate paths and compilation options for your system.
X    These defines should be checked carefully to make sure they are
X    correct.
X
X  - Use 'xmkmf' to produce a Makefile from the Imakefile provided, or
X    else edit 'Makefile' to set the compiler and compiler flags correctly
X    and select the right libraries to compile with.
X
X  - Compile by typing 'make'.  If something goes wrong, and you can track
X    down an error, send me a bug report (including what changes you needed
X    to make, and I will see about fixing it for later distributions).
X
X  - Play the game by typing 'xsokoban'. If it complains about not being
X    able to read the scorefile, create one with 'xsokoban -c'. If this
X    doesn't work, it is probably because you need to create the score
X    directory. See config.h.
X
X  - Set ROOTDIR to the desired location for the xsokoban data files,
X    and rebuild.  Install the game by typing 'make install' or by
X    manually copying the executable. Install the directories screens/,
X    scores/, bitmaps/, and saves/ under ROOTDIR.
X
XNotes -
X  - The screen files need to be publically readable and should not be
X    writable.
X
X  - The score file should be readable/writeable ONLY by the 'superuser' of the
X    program (see config.h).
X
X  - The save files should be readable/writeable ONLY by the 'superuser'.
X
X  - Because of this, the game needs to be run setuid of the person who is
X    'superuser'.
X
XCredits -
X  Unknown Hacker - Original curses(1) implementation.
X  Joseph L. Traub - X windows interface.
X  Kevin Solie - simultaneously developed X implementation (merged in).
X  Mark Linderman, Christos Zoulas - Mouse code (added to Solie's version).
X  Andrew Myers - Improved mouse UI and score ranking
X
XFixes/Bug Reports/Modifications -
X  - If you make any changes to this program, fix any bugs, add any neat
X    features, or whatever, please send mail to "andru@lcs.mit.edu"
X    so that I can add them in to the newest release.
X
X--Andrew Myers
X  (andru@lcs.mit.edu)
END_OF_FILE
  if test 2391 -ne `wc -c <'xsokoban-3.0/README'`; then
    echo shar: \"'xsokoban-3.0/README'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/README'
fi
if test -f 'xsokoban-3.0/config.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/config.h'\"
else
  echo shar: Extracting \"'xsokoban-3.0/config.h'\" \(2304 characters\)
  sed "s/^X//" >'xsokoban-3.0/config.h' <<'END_OF_FILE'
X/***********************************************************************
X   You may wish to alter the following directory paths.
X
X   Note that the string concatenation performed below requires an
X   ANSI-standard preprocessor. If you don't have one, you'll have to
X   manually edit SCREENPATH, SAVEPATH, etc. to start with ROOTDIR.
X***********************************************************************/
X
X#ifndef ROOTDIR
X#define ROOTDIR "."
X/* I suggest "/usr/local/lib/xsokoban" as a value for this variable
X   in the installed version, but you know best...
X*/
X#endif
X
X/**/
X/* SCREENPATH: the name of the directory where the screen files are held */
X/**/
X#ifndef SCREENPATH
X#define SCREENPATH ROOTDIR "/screens"
X#endif
X
X/**/
X/* SAVEPATH: the name of the path where save files are held */
X/*           Attention: Be sure that there are no other files with */
X/*                      the name <username>.sav                    */
X/**/
X#ifndef SAVEPATH
X#define SAVEPATH ROOTDIR "/saves"
X#endif
X
X/* BITPATH: the full pathname to the bitmap file defaults. */
X#ifndef BITPATH
X#define BITPATH ROOTDIR "/bitmaps/defaults"
X#endif
X
X/**/
X/* LOCKPATH: temporary file which is created to ensure that no users */
X/*           work with the scorefile at the same time                */
X/**/
X#ifndef LOCKFILE
X#define LOCKFILE ROOTDIR "/scores/lock"
X#endif
X
X/**/
X/* SCOREFILE: the full pathname of the score file */
X/**/
X#ifndef SCOREFILE
X#define SCOREFILE ROOTDIR "/scores/scores"
X#endif
X
X/**/
X/* MAXUSERNAME: defines the maximum length of a system's user name */
X/**/
X#define MAXUSERNAME     32
X
X/**/
X/* MAXSCOREENTRIES: defines the maximum number of entries in the scoretable */
X/**/
X#define MAXSCOREENTRIES 10000
X
X/**/
X/* SUPERUSER: defines the name of the game superuser */
X/**/
X#ifndef SUPERUSER
X#define SUPERUSER "chris"
X#endif
X
X/**/
X/* PASSWORD: defines the password necessary for creating a new score file */
X/**/
X#ifndef PASSWORD
X#define PASSWORD "score"
X#endif
X
X/**/
X/* ANYLEVEL: Allow any user to play any level and enter a score for it */
X/**/
X#undef ANYLEVEL
X
X/**/
X/* MAXSOLNRANK: The maximum solution rank for which an entry is retained */
X/* in the score table. */
X/**/
X#define MAXSOLNRANK 5
X
X/**/
X/* STACKDEPTH: Number of previous positions remembered in the move stack */
X/**/
X#define STACKDEPTH 1000
END_OF_FILE
  if test 2304 -ne `wc -c <'xsokoban-3.0/config.h'`; then
    echo shar: \"'xsokoban-3.0/config.h'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/config.h'
fi
if test -f 'xsokoban-3.0/config_local.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/config_local.h'\"
else
  echo shar: Extracting \"'xsokoban-3.0/config_local.h'\" \(737 characters\)
  sed "s/^X//" >'xsokoban-3.0/config_local.h' <<'END_OF_FILE'
X/*
X    This file contains only definitions required to make compilation
X    occur successfully. These definitions control whether various
X    include files or extern declarations are needed.
X
X    If the answer to any of these questions is yes, the corresponding
X    symbol should be defined.
X*/
X/* Is there a prototype for "getpass"? */
X#define GETPASS_PROTO
X
X/* Are "htons" and "ntohs" defined in <machine/endian.h>? */
X#undef NEED_ENDIAN
X
X/* Is there a prototype for "creat"? */
X#undef CREAT_PROTO
X
X/* Are "htons" and "ntohs" defined in <netinet/in.h>? */
X#undef NEED_NETINET_IN_H
X
X/* Is there a prototype for "fprintf" in <stdio.h>? */
X#define FPRINTF_PROTO
X
X/* Is there a prototype for "fclose" in <stdio.h>? */
X#define FCLOSE_PROTO
END_OF_FILE
  if test 737 -ne `wc -c <'xsokoban-3.0/config_local.h'`; then
    echo shar: \"'xsokoban-3.0/config_local.h'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/config_local.h'
fi
if test -f 'xsokoban-3.0/defaults.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/defaults.h'\"
else
  echo shar: Extracting \"'xsokoban-3.0/defaults.h'\" \(386 characters\)
  sed "s/^X//" >'xsokoban-3.0/defaults.h' <<'END_OF_FILE'
X#define DEF_FONT "9x15"
X#define DEF_BITH 30
X#define DEF_BITW 30
X#define DEF_CURSOR 102
X
X#define WALLS "fancyWalls"
X#define FONT "fontName"
X#define REVERSE "reverseVideo"
X#define FOREG "foreground"
X#define BACKG "background"
X#define BORDER "borderColor"
X#define CURSOR "pointerColor"
X#define BITDIR "bitmapDir"
X#define BITH "bitmapHeight"
X#define BITW "bitmapWidth"
X#define NUM_WALLS 16
END_OF_FILE
  if test 386 -ne `wc -c <'xsokoban-3.0/defaults.h'`; then
    echo shar: \"'xsokoban-3.0/defaults.h'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/defaults.h'
fi
if test -f 'xsokoban-3.0/errors.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/errors.h'\"
else
  echo shar: Extracting \"'xsokoban-3.0/errors.h'\" \(2541 characters\)
  sed "s/^X//" >'xsokoban-3.0/errors.h' <<'END_OF_FILE'
X/* textual errormessages corresponding to the #defines in globals.h */
Xchar *errmess[] = {
X    "illegal error number",
X    "cannot open screen file",
X    "more than one player position in screen file",
X    "illegal char in screen file",
X    "no player position in screenfile",
X    "too much rows in screen file",
X    "too much columns in screenfile",
X    "quit the game",
X    "cannot get your username",
X    "cannot open savefile",
X    "error writing to savefile",
X    "cannot stat savefile",
X    "error reading savefile",
X    "cannot restore, your savefile has been altered",
X    "game saved",
X    "too much users in score table",
X    "cannot open score file",
X    "error reading scorefile",
X    "error writing scorefile",
X    "illegal command line syntax",
X    "illegal password",
X    "level number too big in command line",
X    "only superuser is allowed to make a new score table",
X    "cannot find file to restore",
X    "cannot find bitmap file",
X    "cannot open display",
X    "cannot load font",
X    "cannot allocate string memory",
X    "could not load requested color"
X};
X
X/* usage message */
X#define USAGESTR \
X "usage: %s [-{s|c|r|<nn>} -display <disp> -{w|walls} -{f|font} \n\
X                 -{rv|reverse} -{b|bitdir} <path> -{fg|foreground} <color> \n\
X                 -{bg|background} <color> -{bd|border} <color> \n\
X                 -{pr|pointer} <color> -xrm <arg>]\n\n"
X
Xchar *usages[] = {
X  "\t-c                  : create a new score file (superuser only)\n",
X  "\t-r                  : restore a saved game.\n",
X  "\t-s                  : show high score table.\n",
X  "\t-<nn>               : play level <nn> (<nn> must be greater than 0)\n",
X  "\t-display <disp>     : run on display <disp>\n",
X  "\t-w                  :\n",
X  "\t-walls              : use fancy walls\n",
X  "\t-rv                 :\n",
X  "\t-reverse            : reverse the foreground and backgound colors\n",
X  "\t-f <fn>             :\n",
X  "\t-font <fn>          : use font <fn>\n",
X  "\t-b <path>           :\n",
X  "\t-bitdir <path>      : use bitmaps found in directory <path>\n",
X  "\t-fg <color>         :\n",
X  "\t-foregound <color>  : use <color> as foreground color\n",
X  "\t-bg <color>         :\n",
X  "\t-backgound <color>  : use <color> as background color\n",
X  "\t-bd <color>         :\n",
X  "\t-border <color>     : use <color> as border color\n",
X  "\t-pr <color>         :\n",
X  "\t-pointer <color>    : use <color> as the pointer foreground color\n",
X  "\t-xrm <arg>          : specify that <arg> is an X resource.\n",
X  NULL
X};
END_OF_FILE
  if test 2541 -ne `wc -c <'xsokoban-3.0/errors.h'`; then
    echo shar: \"'xsokoban-3.0/errors.h'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/errors.h'
fi
if test -f 'xsokoban-3.0/globals.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/globals.h'\"
else
  echo shar: Extracting \"'xsokoban-3.0/globals.h'\" \(2098 characters\)
  sed "s/^X//" >'xsokoban-3.0/globals.h' <<'END_OF_FILE'
X#include "config.h"
X/*****************************************************************************\
X *  Stuff in this file shouldn't ever need to be changed.                    *
X\*****************************************************************************/
X
X#ifdef VICE
Xextern int PlayerUID;
X#define getuid() PlayerUID
X#define geteuid() PlayerUID
X#endif
X
X#define BUFSIZE 256
X
X/* internal object representation */
X#define   player	'@'
X#define   playerstore	'+'
X#define   store		'.'
X#define   packet	'$'
X#define   save		'*'
X#define   ground	' '
X#define   wall		'#'
X
X/* maximum possible size of a board */
X#define MAXROW		20
X#define MAXCOL		20
X
X/* player position for movement */
Xtypedef struct {
X   short x, y;
X} POS;
X
X/* list of possible errors */
X#define E_FOPENSCREEN	1
X#define E_PLAYPOS1	2
X#define E_ILLCHAR	3
X#define E_PLAYPOS2	4
X#define E_TOMUCHROWS	5
X#define E_TOMUCHCOLS	6
X#define E_ENDGAME	7
X#define E_NOUSER	8
X#define E_FOPENSAVE	9
X#define E_WRITESAVE	10
X#define E_STATSAVE	11
X#define E_READSAVE	12
X#define E_ALTERSAVE	13
X#define E_SAVED		14
X#define E_TOMUCHSE	15
X#define E_FOPENSCORE	16
X#define E_READSCORE	17
X#define E_WRITESCORE	18
X#define E_USAGE		19
X#define E_ILLPASSWORD	20
X#define E_LEVELTOOHIGH	21
X#define E_NOSUPER	22
X#define E_NOSAVEFILE	23
X#define E_NOBITMAP	24
X#define E_NODISPLAY	25
X#define E_NOFONT	26
X#define E_NOMEM		27
X#define E_NOCOLOR	28
X
X/* classname for silly X stuff */
X#define CLASSNAME "XSokoban"
X
X/* macros translating game coords to window coords */
X#define cX(x) (bit_width * (((MAXCOL - cols) / 2) + (x)))
X#define cY(x) (bit_height * (((MAXROW - rows) / 2) + (x)))
X
X/* macros translating window coords to game coords */
X#define wX(x) (((x)/bit_width) - ((MAXCOL - cols)/2))
X#define wY(x) (((x)/bit_height) - ((MAXROW - rows)/2))
X
X
X/*** Global state ***/
Xtypedef char Map[MAXROW+1][MAXCOL+1];
X
Xextern Map map;
X
Xextern short rows, cols, level, moves, pushes, savepack, packets;
Xextern unsigned short scorelevel, scoremoves, scorepushes;
Xextern POS ppos;
Xextern Display *dpy;
Xextern unsigned int bit_width, bit_height;
Xextern Atom wm_delete_window, wm_protocols;
END_OF_FILE
  if test 2098 -ne `wc -c <'xsokoban-3.0/globals.h'`; then
    echo shar: \"'xsokoban-3.0/globals.h'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/globals.h'
fi
if test -f 'xsokoban-3.0/help.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/help.h'\"
else
  echo shar: Extracting \"'xsokoban-3.0/help.h'\" \(1202 characters\)
  sed "s/^X//" >'xsokoban-3.0/help.h' <<'END_OF_FILE'
X/* help pages */
Xtypedef struct helpline {
X   int xpos, ypos, page;
X   char *textline;
X} h_line;
X
Xh_line help_pages[] = {
X  { 0, 35, 0, "Objective:  Push all the objects from their starting positions"},
X  { 12, 50, 0, "into their goal positions.  Be warned that you can"},
X  { 12, 65, 0, "push only one object at a time; watch out for corners!"},
X  { 0, 100, 0, "Movement:"},
X  { 12, 100, 0, "Left mouse button: move player to this point"},
X  { 12, 115, 0, "Middle mouse button: push ball to this point"},
X  { 12, 130, 0, "Right mouse button: undo last action"},
X  { 0, 155, 0, "Or use the arrow keys or hljk, as in vi:"},
X  { 13, 170, 0, "Move/Push     h    l    k   j"},
X  { 13, 185, 0, "Run/Push      H    L    K   J"},
X  { 13, 200, 0, "Run Only     ^H   ^L   ^K  ^J"},
X  { 0, 225, 0, "Commands:"},
X  { 12, 240, 0, "^r: redraw screen             ?: this help message"}, 
X  { 12, 255, 0, " u: undo last action          U: restart this level"},
X  { 12, 270, 0, " s: save game and quit        q: quit game"},
X  { 0, 380, 0, "Bitmaps:"},
X  { 12, 380, 0, "Player:     Goal:      Wall:     Object:"},
X  { 12, 420, 0, "Object on a goal:      Player on a goal:"},
X  {0, 0, 0, NULL}
X};
X
X#define HELP_PAGES 1
END_OF_FILE
  if test 1202 -ne `wc -c <'xsokoban-3.0/help.h'`; then
    echo shar: \"'xsokoban-3.0/help.h'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/help.h'
fi
if test -f 'xsokoban-3.0/main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/main.c'\"
else
  echo shar: Extracting \"'xsokoban-3.0/main.c'\" \(8088 characters\)
  sed "s/^X//" >'xsokoban-3.0/main.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <pwd.h>
X#include <X11/Xlib.h>
X#include <X11/Xresource.h>
X#include <stdlib.h>
X#include <unistd.h>
X#include <string.h>
X
X#include "externs.h"
X#include "globals.h"
X#include "options.h"
X#include "errors.h"
X
X/* useful globals */
XBoolean scoring = _true_;
Xshort level, packets, savepack, moves, pushes, rows, cols;
Xunsigned short scorelevel, scoremoves, scorepushes;
XPOS ppos;
Xchar map[MAXROW + 1][MAXCOL + 1];
Xchar *username = NULL, *progname = NULL, *bitpath = NULL;
Xstatic Boolean optshowscore = _false_, optmakescore = _false_,
X	       optrestore = _false_, superuser = _false_;
Xstatic short optlevel = 0, userlevel;
Xstruct passwd *pwd;
XXrmDatabase rdb;
X
Xextern Display *dpy;
Xextern int scr;
Xextern Boolean display_alloc;
X
X/* do all the setup foo, and make sure command line gets parsed. */
Xvoid main(int argc, char **argv)
X{
X  short ret = 0, ret2 = 0;
X
X#ifdef VICE
X  Authenticate();
X#endif
X
X  scorelevel = 0;
X  moves = pushes = packets = savepack = 0;
X
X  /* make the program name be what it is invoked with */
X  progname = strrchr(argv[0], '/');
X  if(progname == NULL)
X    progname = argv[0];
X  else
X    progname++;
X
X  /* find out who is playing us. (pwd will be kept around in case we need to
X   * build the Xresources stuff later.
X   */
X  pwd = getpwuid(getuid());
X  if(pwd == NULL)
X    /* we MUST be being played by somebody, sorry */
X    ret = E_NOUSER;
X  else {
X    /* find out who we are. */
X    username = pwd->pw_name;
X    /* see if we are the superuser */
X    superuser = (strcmp(username, SUPERUSER) == 0) ? _true_ : _false_;
X    /* Parse the command line */
X    ret = CheckCommandLine(&argc, argv);
X    if(ret == 0) {
X      if(optshowscore)
X	ret = OutputScore();
X      else if(optmakescore) {
X	if(superuser) {
X	  /* make sure of that, shall we? */
X	  ret = GetGamePassword();
X	  if(ret == 0)
X	    ret = MakeNewScore();
X	} else
X	  /* sorry, BAD superuser */
X	  ret = E_NOSUPER;
X      } else if(optrestore) {
X	ret = RestoreGame();
X      } else {
X	ret = GetUserLevel(&userlevel);
X	if(ret == 0) {
X	    if(optlevel > 0) {
X#ifndef ANYLEVEL
X		if (userlevel < optlevel) {
X		    if (superuser) {
X			/* superusers can play any level (but not score),
X			 * which is useful for testing out new boards.
X			 */
X			level = optlevel;
X			scoring = _false_;
X		    } else {
X			ret = E_LEVELTOOHIGH;
X		    }
X		} else
X#endif
X		  level = optlevel;
X	  } else
X	    level = userlevel;
X	}
X      }
X    }
X  }
X  if(ret == 0) {
X    /* play till we drop, then nuke the good stuff */
X    ret = GameLoop();
X    DestroyDisplay();
X  }
X  /* always report here since the game returns E_ENDGAME when the user quits.
X   * Sigh.. it would be so much easier to just do it right.
X   */
X  Error(ret);
X  /* see if they score, and do it (again report an error */
X  if((scorelevel > 0) && scoring) {
X    ret2 = Score(_true_);
X    Error(ret2);
X  }
X  /* exit with whatever status we ended with */
X  exit(ret);
X}
X
X/* Oh boy, the fun stuff.. Follow along boys and girls as we parse the command
X * line up into little bitty pieces and merge in all the xdefaults that we
X * need.
X */
Xshort CheckCommandLine(int *argcP, char **argv)
X{
X  XrmDatabase command = NULL, temp = NULL;
X  char *res;
X  char buf[1024];
X  int option;
X
X  /* let's do this the sensible way, Command line first! */
X  /* we will also OPEN the display here, though we won't do anything with it */
X  XrmInitialize();
X
X  /* build an XrmDB from the command line based on the options (options.h) */
X  XrmParseCommand(&command, options, sizeof(options)/sizeof(*options),
X		  progname, argcP, argv);
X
X  /* okay, we now have the X command line options parsed, we might as well
X   * make sure we need to go further before we do.  These command line options
X   * are NOT caught by XrmParseCommand(), so we need to do them ourselves.
X   * Remember, they are all exclusive of one another.
X   */
X  for(option = 1; option < *argcP; option++) {
X    if(argv[option][0] == '-') {
X      switch(argv[option][1]) {
X	case 's':
X	  if(optshowscore || optmakescore || optrestore || (optlevel > 0))
X	    return E_USAGE;
X	  optshowscore = _true_;
X	  break;
X	case 'c':
X	  if(optshowscore || optmakescore || optrestore || (optlevel > 0))
X	    return E_USAGE;
X	  optmakescore = _true_;
X	  break;
X	case 'r':
X	  if(optshowscore || optmakescore || optrestore || (optlevel > 0))
X	    return E_USAGE;
X	  optrestore = _true_;
X	  break;
X	default:
X	  if(optshowscore || optrestore || optmakescore || (optlevel > 0))
X	    return E_USAGE;
X	  optlevel = atoi(argv[option]+1);
X	  if(optlevel == 0)
X	    return E_USAGE;
X	  break;
X      }
X    } else
X      /* found an option that didn't begin with a - (oops) */
X      return E_USAGE;
X  }
X
X  if (optshowscore) return 0; /* Don't mess with X any more */
X  /* okay.. NOW, find out what display we are currently attached to. This
X   * allows us to put the display on another machine
X   */
X  res = GetDatabaseResource(command, "display");
X
X  /* open up the display */
X  dpy = XOpenDisplay(res);
X  if(dpy == (Display *)NULL)
X    return E_NODISPLAY;
X  display_alloc = _true_;
X
X  /* okay, we have a display, now we can get the std xdefaults and stuff */
X  res = XResourceManagerString(dpy);
X  if(res != NULL)
X    /* try to get it off the server first (ya gotta love R4) */
X    rdb = XrmGetStringDatabase(res);
X  else {
X    /* can't get it from the server, let's do it the slow way */
X    /* try HOME first in case you have people sharing accounts :) */
X    res = getenv("HOME");
X    if(res != NULL)
X      strcpy(buf, res);
X    else
X      /* no HOME, let's try and make one from the pwd (whee) */
X      strcpy(buf, pwd->pw_dir);
X    strcat(buf, "/.Xdefaults");
X    rdb = XrmGetFileDatabase(buf);
X  }
X
X  /* let's merge in the X environment */
X  res = getenv("XENVIRONMENT");
X  if(res != NULL) {
X    temp = XrmGetFileDatabase(res);
X    XrmMergeDatabases(temp, &rdb);
X  }
X
X  /* now merge in the rest of the X command line options! */
X  XrmMergeDatabases(command, &rdb);
X  return 0;
X}
X
X/* we just sit here and keep playing level after level after level after .. */
Xshort GameLoop(void)
X{
X  short ret = 0;
X
X  /* make sure X is all set up and ready for us */
X  ret = InitX();
X  if(ret != 0)
X    return ret;
X
X  /* get where we are starting from */
X  if(!optrestore)
X    ret = ReadScreen();
X
X  /* until we quit or get an error, just keep on going. */
X  while(ret == 0) {
X    ret = Play();
X    if((scorelevel > 0) && scoring) {
X      int ret2;
X      ret2 = Score(_false_);
X      Error(ret2);
X      scorelevel = 0;
X    }
X    if(ret == 0) {
X      level++;
X      moves = pushes = packets = savepack = 0;
X      ret = ReadScreen();
X    }
X  }
X  return ret;
X}
X
X/* Does this really need a comment :) */
Xshort GetGamePassword(void)
X{
X  return ((strcmp(getpass("Password: "), PASSWORD) == 0) ? 0 : E_ILLPASSWORD);
X}
X
X/* display the correct error message based on the error number given us. 
X * There are 2 special cases, E_ENDGAME (in which case we don't WANT a 
X * silly error message cause it's not really an error, and E_USAGE, in which
X * case we want to give a really nice list of all the legal options.
X */
Xvoid Error(short err)
X{
X  switch(err) {
X    case E_FOPENSCREEN:
X    case E_PLAYPOS1:
X    case E_ILLCHAR:
X    case E_PLAYPOS2:
X    case E_TOMUCHROWS:
X    case E_TOMUCHCOLS:
X    case E_NOUSER:
X    case E_FOPENSAVE:
X    case E_WRITESAVE:
X    case E_STATSAVE:
X    case E_READSAVE:
X    case E_ALTERSAVE:
X    case E_SAVED:
X    case E_TOMUCHSE:
X    case E_FOPENSCORE:
X    case E_READSCORE:
X    case E_WRITESCORE:
X    case E_USAGE:
X    case E_ILLPASSWORD:
X    case E_LEVELTOOHIGH:
X    case E_NOSUPER:
X    case E_NOSAVEFILE:
X    case E_NOBITMAP:
X    case E_NODISPLAY:
X    case E_NOFONT:
X    case E_NOMEM:
X    case E_NOCOLOR:
X      fprintf(stderr, "%s: %s\n", progname, errmess[err]);
X      if(err == E_USAGE)
X        Usage();
X      break;
X    default:
X      if(err != E_ENDGAME)
X	fprintf(stderr, "%s: %s\n", progname, errmess[0]);
X      break;
X  }
X}
X
X/* this simply prints out the usage string nicely. */
Xvoid Usage(void)
X{
X  short i;
X
X  fprintf(stderr, USAGESTR, progname);
X  for (i = 0; usages[i] != NULL; i++)
X    fprintf(stderr, "%s", usages[i]);
X}
END_OF_FILE
  if test 8088 -ne `wc -c <'xsokoban-3.0/main.c'`; then
    echo shar: \"'xsokoban-3.0/main.c'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/main.c'
fi
if test -f 'xsokoban-3.0/options.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/options.h'\"
else
  echo shar: Extracting \"'xsokoban-3.0/options.h'\" \(1595 characters\)
  sed "s/^X//" >'xsokoban-3.0/options.h' <<'END_OF_FILE'
X/* the list of the options used to build the command line XrmDB.
X * if an option has no seperate arg, and appears on the command line, the 
X * last value in the table is what will be entered into the db.
X */
Xstatic XrmOptionDescRec options[] = {
X  { "-w",          "*fancyWalls",    XrmoptionNoArg,    (caddr_t)  "on" },
X  { "-walls",      "*fancyWalls",    XrmoptionNoArg,    (caddr_t)  "on" },
X  { "-f",          "*fontName",      XrmoptionSepArg,   (caddr_t)     0 },
X  { "-font",       "*fontName",      XrmoptionSepArg,   (caddr_t)     0 },
X  { "-rv",         "*reverseVideo",  XrmoptionNoArg,    (caddr_t)  "on" },
X  { "-reverse",    "*reverseVideo",  XrmoptionNoArg,    (caddr_t)  "on" },
X  { "-fg",         "*foreground",    XrmoptionSepArg,   (caddr_t)     0 },
X  { "-foreground", "*foreground",    XrmoptionSepArg,   (caddr_t)     0 },
X  { "-bg",         "*background",    XrmoptionSepArg,   (caddr_t)     0 },
X  { "-background", "*background",    XrmoptionSepArg,   (caddr_t)     0 },
X  { "-bd",         "*borderColor",   XrmoptionSepArg,   (caddr_t)     0 },
X  { "-border",     "*borderColor",   XrmoptionSepArg,   (caddr_t)     0 },
X  { "-pr",         "*pointerColor",  XrmoptionSepArg,   (caddr_t)     0 },
X  { "-pointer",    "*pointerColor",  XrmoptionSepArg,   (caddr_t)     0 },
X  { "-b",          "*bitmapDir",     XrmoptionSepArg,   (caddr_t)     0 },
X  { "-bitdir",     "*bitmapDir",     XrmoptionSepArg,   (caddr_t)     0 },
X  { "-display",    ".display",	     XrmoptionSepArg,	(caddr_t)     0 },
X  { "-xrm",        (char *) 0,       XrmoptionResArg,   (caddr_t)     0 }
X};
END_OF_FILE
  if test 1595 -ne `wc -c <'xsokoban-3.0/options.h'`; then
    echo shar: \"'xsokoban-3.0/options.h'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/options.h'
fi
if test -f 'xsokoban-3.0/resources.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/resources.c'\"
else
  echo shar: Extracting \"'xsokoban-3.0/resources.c'\" \(1703 characters\)
  sed "s/^X//" >'xsokoban-3.0/resources.c' <<'END_OF_FILE'
X#include <stdio.h>
X
X#include "externs.h"
X#include "globals.h"
X
Xextern char *progname;
Xextern XrmDatabase rdb;
Xextern Display *dpy;
Xextern Colormap cmap;
X
X/* rewritten slightly from the xantfarm code by Jef Poskanzer */
X
X/* get a resource from the specified db.  This helps support the -display
X * code, but could be used to get a resource that should only be specified
X * in a given place (ie either only command line, or only Xresource db)
X */
Xchar *GetDatabaseResource(XrmDatabase db, char *res)
X{
X  char name[500];
X  char class[500];
X  char *type;
X  XrmValue value;
X
X  (void)sprintf(name, "%s.%s", progname, res);
X  (void)sprintf(class, "%s.%s", CLASSNAME, res);
X
X  if(XrmGetResource(db, name, class, &type, &value) == True)
X    if(strcmp(type, "String") == 0)
X      return (char *)value.addr;
X  return (char *)0;
X}
X
X/* just calls the above routine with the general combined db */
Xchar *GetResource(char *res)
X{
X  return GetDatabaseResource(rdb, res);
X}
X
X/* returns the color pixel for the given resource */
XBoolean GetColorResource(char *res, unsigned long *cP)
X{
X  XColor color;
X  char *rval = GetResource(res);
X
X  if(rval == (char *)0)
X    return _false_;
X  if(XParseColor(dpy, cmap, rval, &color) != True)
X    return _false_;
X  if(XAllocColor(dpy, cmap, &color) != True)
X    return _false_;
X  *cP = color.pixel;
X  return _true_;
X}
X
Xchar *boolopts[] = {
X  "true",
X  "True",
X  "on",
X  "On",
X  "yes",
X  "Yes",
X  "1"
X};
X
X/* convert a string to the 'boolean' type (I defined my own, thanks) */
XBoolean StringToBoolean(char *str)
X{
X  int nboolopts = sizeof(boolopts)/sizeof(*boolopts), i;
X
X  for(i = 0; i < nboolopts; i++)
X    if(strcmp(str, boolopts[i]) == 0)
X      return _true_;
X  return _false_;
X}
END_OF_FILE
  if test 1703 -ne `wc -c <'xsokoban-3.0/resources.c'`; then
    echo shar: \"'xsokoban-3.0/resources.c'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/resources.c'
fi
if test -f 'xsokoban-3.0/save.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/save.c'\"
else
  echo shar: Extracting \"'xsokoban-3.0/save.c'\" \(4135 characters\)
  sed "s/^X//" >'xsokoban-3.0/save.c' <<'END_OF_FILE'
X#include "config_local.h"
X
X#include <stdio.h>
X#include <sys/types.h>
X#include <sys/stat.h>
X#include <signal.h>
X#include <string.h>
X#include <unistd.h>
X
X#ifdef NEED_NETINET_IN_H
X#include <netinet/in.h>
X#endif
X
X#ifdef NEED_ENDIAN
X#include <machine/endian.h>
X#endif
X
X#include "externs.h"
X#include "globals.h"
X
Xextern char *malloc();
Xextern FILE *fopen();
X
Xextern char *username;
Xextern char map[MAXROW + 1][MAXCOL + 1];
Xextern short level, moves, pushes, packets, savepack, rows, cols;
Xextern POS ppos;
X
Xstatic long savedbn;
Xstatic char *sfname;
Xstatic FILE *savefile;
Xstatic struct stat sfstat;
X
X/* save out a game in a standard format.  Uses the ntoh functions and hton
X * functions so that the same save file will work on an MSB or LSB system
X * other than that, it is a standard sokoban score file.
X */
Xshort SaveGame(void)
X{
X  short ret = 0;
X
X  signal(SIGINT, SIG_IGN);
X  sfname = malloc(strlen(SAVEPATH) + strlen(username) + 6);
X  sprintf(sfname, "%s/%s.sav", SAVEPATH, username);
X
X  packets = htons(packets);
X  pushes = htons(pushes);
X  moves = htons(moves);
X  level = htons(level);
X  cols = htons(cols);
X  savepack = htons(savepack);
X  rows = htons(rows);
X  ppos.x = htons(ppos.x);
X  ppos.y = htons(ppos.y);
X
X  if ((savefile = fopen(sfname, "w")) == NULL)
X    ret = E_FOPENSAVE;
X  else {
X    savedbn = fileno(savefile);
X    if (write(savedbn, &(map[0][0]), MAXROW * MAXCOL) != MAXROW * MAXCOL)
X      ret = E_WRITESAVE;
X    else if (write(savedbn, &ppos, sizeof(POS)) != sizeof(POS))
X      ret = E_WRITESAVE;
X    else if (write(savedbn, &level, 2) != 2)
X      ret = E_WRITESAVE;
X    else if (write(savedbn, &moves, 2) != 2)
X      ret = E_WRITESAVE;
X    else if (write(savedbn, &pushes, 2) != 2)
X      ret = E_WRITESAVE;
X    else if (write(savedbn, &packets, 2) != 2)
X      ret = E_WRITESAVE;
X    else if (write(savedbn, &savepack, 2) != 2)
X      ret = E_WRITESAVE;
X    else if (write(savedbn, &rows, 2) != 2)
X      ret = E_WRITESAVE;
X    else if (write(savedbn, &cols, 2) != 2)
X      ret = E_WRITESAVE;
X    else
X      fclose(savefile);
X    if (stat(sfname, &sfstat) != 0)
X      ret = E_STATSAVE;
X    else if ((savefile = fopen(sfname, "a")) == NULL)
X      ret = E_FOPENSAVE;
X    else if (write(savedbn, &sfstat, sizeof(sfstat)) != sizeof(sfstat))
X      ret = E_WRITESAVE;
X    fclose(savefile);
X  }
X
X  ppos.x = ntohs(ppos.x);
X  ppos.y = ntohs(ppos.y);
X  pushes = ntohs(pushes);
X  moves = ntohs(moves);
X  level = ntohs(level);
X  packets = ntohs(packets);
X  cols = ntohs(cols);
X  rows = ntohs(rows);
X  savepack = ntohs(savepack);
X
X  if ((ret == E_WRITESAVE) || (ret == E_STATSAVE))
X    unlink(sfname);
X  signal(SIGINT, SIG_DFL);
X
X  return ret;
X}
X
X/* loads in a previously saved game */
Xshort RestoreGame(void)
X{
X  short ret = 0;
X  struct stat oldsfstat;
X
X  signal(SIGINT, SIG_IGN);
X  sfname = malloc(strlen(SAVEPATH) + strlen(username) + 6);
X  sprintf(sfname, "%s/%s.sav", SAVEPATH, username);
X
X  if (stat(sfname, &oldsfstat) < -1)
X    ret = E_NOSAVEFILE;
X  else {
X    if ((savefile = fopen(sfname, "r")) == NULL)
X      ret = E_FOPENSAVE;
X    else {
X      savedbn = fileno(savefile);
X      if (read(savedbn, &(map[0][0]), MAXROW * MAXCOL) != MAXROW * MAXCOL)
X	ret = E_READSAVE;
X      else if (read(savedbn, &ppos, sizeof(POS)) != sizeof(POS))
X	ret = E_READSAVE;
X      else if (read(savedbn, &level, 2) != 2)
X	ret = E_READSAVE;
X      else if (read(savedbn, &moves, 2) != 2)
X	ret = E_READSAVE;
X      else if (read(savedbn, &pushes, 2) != 2)
X	ret = E_READSAVE;
X      else if (read(savedbn, &packets, 2) != 2)
X	ret = E_READSAVE;
X      else if (read(savedbn, &savepack, 2) != 2)
X	ret = E_READSAVE;
X      else if (read(savedbn, &rows, 2) != 2)
X	ret = E_READSAVE;
X      else if (read(savedbn, &cols, 2) != 2)
X	ret = E_READSAVE;
X      else if (read(savedbn, &sfstat, sizeof(sfstat)) != sizeof(sfstat))
X	ret = E_READSAVE;
X    }
X
X    ppos.x = ntohs(ppos.x);
X    ppos.y = ntohs(ppos.y);
X    level = ntohs(level);
X    moves = ntohs(moves);
X    pushes = ntohs(pushes);
X    packets = ntohs(packets);
X    savepack = ntohs(savepack);
X    rows = ntohs(rows);
X    cols = ntohs(cols);
X
X    unlink(sfname);
X  }
X  signal(SIGINT, SIG_DFL);
X  return ret;
X}
END_OF_FILE
  if test 4135 -ne `wc -c <'xsokoban-3.0/save.c'`; then
    echo shar: \"'xsokoban-3.0/save.c'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/save.c'
fi
if test -f 'xsokoban-3.0/screen.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/screen.c'\"
else
  echo shar: Extracting \"'xsokoban-3.0/screen.c'\" \(1616 characters\)
  sed "s/^X//" >'xsokoban-3.0/screen.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <string.h>
X
X#include "externs.h"
X#include "globals.h"
X
Xextern char *malloc();
Xextern FILE *fopen();
X
Xextern short level, packets, savepack, rows, cols;
Xextern char map[MAXROW + 1][MAXCOL + 1];
Xextern POS ppos;
X
X/* Read in the current screen level, updating "ppos", "map", "savepack",
X   and "packets" appropriately. Return 0 if success, else an error code. */
Xshort ReadScreen(void)
X{
X  FILE *screen;
X  char *fnam;
X  int y, x;
X  short j, c, ret = 0;
X
X  for (y = 0; y < MAXROW; y++)
X    for (x = 0; x < MAXCOL; x++)
X      map[y][x] = ground;
X
X  fnam = malloc(strlen(SCREENPATH) + 12);
X  sprintf(fnam, "%s/screen.%d", SCREENPATH, level);
X
X  if ((screen = fopen(fnam, "r")) == NULL)
X    ret = E_FOPENSCREEN;
X  else {
X    packets = savepack = rows = j = cols = 0;
X    ppos.x = -1;
X    ppos.y = -1;
X
X    while ((ret == 0) && ((c = getc(screen)) != EOF)) {
X      if (c == '\n') {
X	map[rows++][j] = '\0';
X	if (rows > MAXROW)
X	  ret = E_TOMUCHROWS;
X	else {
X	  if (j > cols)
X	    cols = j;
X	  j = 0;
X	}
X      } else if ((c == player) || (c == playerstore)) {
X	if (ppos.x != -1)
X	  ret = E_PLAYPOS1;
X	else {
X	  ppos.x = rows;
X	  ppos.y = j;
X	  map[rows][j++] = c;
X	  if (j > MAXCOL)
X	    ret = E_TOMUCHCOLS;
X	}
X      } else if ((c == save) || (c == packet) ||
X		 (c == wall) || (c == store) ||
X		 (c == ground)) {
X	if (c == save) {
X	  savepack++;
X	  packets++;
X	}
X	if (c == packet)
X	  packets++;
X	map[rows][j++] = c;
X	if (j > MAXCOL)
X	  ret = E_TOMUCHCOLS;
X      } else
X	ret = E_ILLCHAR;
X    }
X    fclose(screen);
X    if ((ret == 0) && (ppos.x == -1))
X      ret = E_PLAYPOS2;
X  }
X  return (ret);
X}
END_OF_FILE
  if test 1616 -ne `wc -c <'xsokoban-3.0/screen.c'`; then
    echo shar: \"'xsokoban-3.0/screen.c'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/screen.c'
fi
if test -f 'xsokoban-3.0/screens/screen.10' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/screens/screen.10'\"
else
  echo shar: Extracting \"'xsokoban-3.0/screens/screen.10'\" \(320 characters\)
  sed "s/^X//" >'xsokoban-3.0/screens/screen.10' <<'END_OF_FILE'
X ###  #############
X##@####       #   #
X# $$   $$  $ $ ...#
X#  $$$#    $  #...#
X# $   # $$ $$ #...#
X###   #  $    #...#
X#     # $ $ $ #...#
X#    ###### ###...#
X## #  #  $ $  #...#
X#  ## # $$ $ $##..#
X# ..# #  $      #.#
X# ..# # $$$ $$$ #.#
X##### #       # #.#
X    # ######### #.#
X    #           #.#
X    ###############
END_OF_FILE
  if test 320 -ne `wc -c <'xsokoban-3.0/screens/screen.10'`; then
    echo shar: \"'xsokoban-3.0/screens/screen.10'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/screens/screen.10'
fi
if test -f 'xsokoban-3.0/screens/screen.14' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/screens/screen.14'\"
else
  echo shar: Extracting \"'xsokoban-3.0/screens/screen.14'\" \(284 characters\)
  sed "s/^X//" >'xsokoban-3.0/screens/screen.14' <<'END_OF_FILE'
X       #######
X #######     #
X #     # $@$ #
X #$$ #   #########
X # ###......##   #
X #   $......## # #
X # ###......     #
X##   #### ### #$##
X#  #$   #  $  # #
X#  $ $$$  # $## #
X#   $ $ ###$$ # #
X#####     $   # #
X    ### ###   # #
X      #     #   #
X      ########  #
X             ####
END_OF_FILE
  if test 284 -ne `wc -c <'xsokoban-3.0/screens/screen.14'`; then
    echo shar: \"'xsokoban-3.0/screens/screen.14'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/screens/screen.14'
fi
if test -f 'xsokoban-3.0/screens/screen.20' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/screens/screen.20'\"
else
  echo shar: Extracting \"'xsokoban-3.0/screens/screen.20'\" \(303 characters\)
  sed "s/^X//" >'xsokoban-3.0/screens/screen.20' <<'END_OF_FILE'
X    ##########
X#####        ####
X#     #   $  #@ #
X# #######$####  ###
X# #    ## #  #$ ..#
X# # $     #  #  #.#
X# # $  #     #$ ..#
X# #  ### ##     #.#
X# ###  #  #  #$ ..#
X# #    #  ####  #.#
X# #$   $  $  #$ ..#
X#    $ # $ $ #  #.#
X#### $###    #$ ..#
X   #    $$ ###....#
X   #      ## ######
X   ########
END_OF_FILE
  if test 303 -ne `wc -c <'xsokoban-3.0/screens/screen.20'`; then
    echo shar: \"'xsokoban-3.0/screens/screen.20'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/screens/screen.20'
fi
if test -f 'xsokoban-3.0/screens/screen.22' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/screens/screen.22'\"
else
  echo shar: Extracting \"'xsokoban-3.0/screens/screen.22'\" \(311 characters\)
  sed "s/^X//" >'xsokoban-3.0/screens/screen.22' <<'END_OF_FILE'
X######     ####
X#    #######  #####
X#   $#  #  $  #   #
X#  $  $  $ # $ $  #
X##$ $   # @# $    #
X#  $ ########### ##
X# #   #.......# $#
X# ##  # ......#  #
X# #   $........$ #
X# # $ #.... ..#  #
X#  $ $####$#### $#
X# $   ### $   $  ##
X# $     $ $  $    #
X## ###### $ ##### #
X#         #       #
X###################
END_OF_FILE
  if test 311 -ne `wc -c <'xsokoban-3.0/screens/screen.22'`; then
    echo shar: \"'xsokoban-3.0/screens/screen.22'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/screens/screen.22'
fi
if test -f 'xsokoban-3.0/screens/screen.24' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/screens/screen.24'\"
else
  echo shar: Extracting \"'xsokoban-3.0/screens/screen.24'\" \(306 characters\)
  sed "s/^X//" >'xsokoban-3.0/screens/screen.24' <<'END_OF_FILE'
X###############
X#..........  .####
X#..........$$.#  #
X###########$ #   ##
X#      $  $     $ #
X## ####   #  $ #  #
X#      #   ##  # ##
X#  $#  # ##  ### ##
X# $ #$###    ### ##
X###  $ #  #  ### ##
X###    $ ## #  # ##
X # $  #  $  $ $   #
X #  $  $#$$$  #   #
X #  #  $      #####
X # @##  #  #  #
X ##############
END_OF_FILE
  if test 306 -ne `wc -c <'xsokoban-3.0/screens/screen.24'`; then
    echo shar: \"'xsokoban-3.0/screens/screen.24'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/screens/screen.24'
fi
if test -f 'xsokoban-3.0/screens/screen.25' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/screens/screen.25'\"
else
  echo shar: Extracting \"'xsokoban-3.0/screens/screen.25'\" \(295 characters\)
  sed "s/^X//" >'xsokoban-3.0/screens/screen.25' <<'END_OF_FILE'
X####
X#  ##############
X#  #   ..#......#
X#  # # ##### ...#
X##$#    ........#
X#   ##$######  ####
X# $ #     ######@ #
X##$ # $   ######  #
X#  $ #$$$##       #
X#      #    #$#$###
X# #### #$$$$$    #
X# #    $     #   #
X# #   ##        ###
X# ######$###### $ #
X#        #    #   #
X##########    #####
END_OF_FILE
  if test 295 -ne `wc -c <'xsokoban-3.0/screens/screen.25'`; then
    echo shar: \"'xsokoban-3.0/screens/screen.25'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/screens/screen.25'
fi
if test -f 'xsokoban-3.0/screens/screen.35' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/screens/screen.35'\"
else
  echo shar: Extracting \"'xsokoban-3.0/screens/screen.35'\" \(298 characters\)
  sed "s/^X//" >'xsokoban-3.0/screens/screen.35' <<'END_OF_FILE'
X############ ######
X#   #    # ###....#
X#   $$#   @  .....#
X#   # ###   # ....#
X## ## ###  #  ....#
X # $ $     # # ####
X #  $ $##  #      #
X#### #  #### # ## #
X#  # #$   ## #    #
X# $  $  # ## #   ##
X# # $ $    # #   #
X#  $ ## ## # #####
X# $$     $$  #
X## ## ### $  #
X #    # #    #
X ###### ######
END_OF_FILE
  if test 298 -ne `wc -c <'xsokoban-3.0/screens/screen.35'`; then
    echo shar: \"'xsokoban-3.0/screens/screen.35'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/screens/screen.35'
fi
if test -f 'xsokoban-3.0/screens/screen.36' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/screens/screen.36'\"
else
  echo shar: Extracting \"'xsokoban-3.0/screens/screen.36'\" \(289 characters\)
  sed "s/^X//" >'xsokoban-3.0/screens/screen.36' <<'END_OF_FILE'
X            #####
X#####  ######   #
X#   ####  $ $ $ #
X# $   ## ## ##  ##
X#   $ $     $  $ #
X### $  ## ##     ##
X  # ##### #####$$ #
X ##$##### @##     #
X # $  ###$### $  ##
X # $  #   ###  ###
X # $$ $ #   $$ #
X #     #   ##  #
X #######.. .###
X    #.........#
X    #.........#
X    ###########
END_OF_FILE
  if test 289 -ne `wc -c <'xsokoban-3.0/screens/screen.36'`; then
    echo shar: \"'xsokoban-3.0/screens/screen.36'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/screens/screen.36'
fi
if test -f 'xsokoban-3.0/screens/screen.39' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/screens/screen.39'\"
else
  echo shar: Extracting \"'xsokoban-3.0/screens/screen.39'\" \(291 characters\)
  sed "s/^X//" >'xsokoban-3.0/screens/screen.39' <<'END_OF_FILE'
X             ######
X #############....#
X##   ##     ##....#
X#  $$##  $ @##....#
X#      $$ $#  ....#
X#  $ ## $$ # # ...#
X#  $ ## $  #  ....#
X## ##### ### ##.###
X##   $  $ ##   .  #
X# $###  # ##### ###
X#   $   #       #
X#  $ #$ $ $###  #
X# $$$# $   # ####
X#    #  $$ #
X######   ###
X     #####
END_OF_FILE
  if test 291 -ne `wc -c <'xsokoban-3.0/screens/screen.39'`; then
    echo shar: \"'xsokoban-3.0/screens/screen.39'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/screens/screen.39'
fi
if test -f 'xsokoban-3.0/screens/screen.41' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/screens/screen.41'\"
else
  echo shar: Extracting \"'xsokoban-3.0/screens/screen.41'\" \(286 characters\)
  sed "s/^X//" >'xsokoban-3.0/screens/screen.41' <<'END_OF_FILE'
X           #####
X          ##   ##
X         ##     #
X        ##  $$  #
X       ## $$  $ #
X       # $    $ #
X####   #   $$ #####
X#  ######## ##    #
X#.            $$$@#
X#.# ####### ##   ##
X#.# #######. #$ $##
X#........... #    #
X##############  $ #
X             ##  ##
X              ####
END_OF_FILE
  if test 286 -ne `wc -c <'xsokoban-3.0/screens/screen.41'`; then
    echo shar: \"'xsokoban-3.0/screens/screen.41'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/screens/screen.41'
fi
if test -f 'xsokoban-3.0/screens/screen.50' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/screens/screen.50'\"
else
  echo shar: Extracting \"'xsokoban-3.0/screens/screen.50'\" \(307 characters\)
  sed "s/^X//" >'xsokoban-3.0/screens/screen.50' <<'END_OF_FILE'
X      ############
X     ##..    #   #
X    ##..* $    $ #
X   ##..*.# # # $##
X   #..*.# # # $  #
X####...#  #    # #
X#  ## #          #
X# @$ $ ###  #   ##
X# $   $   # #   #
X###$$   # # # # #
X  #   $   # # #####
X  # $# #####      #
X  #$   #   #    # #
X  #  ###   ##     #
X  #  #      #    ##
X  ####      ######
END_OF_FILE
  if test 307 -ne `wc -c <'xsokoban-3.0/screens/screen.50'`; then
    echo shar: \"'xsokoban-3.0/screens/screen.50'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/screens/screen.50'
fi
if test -f 'xsokoban-3.0/screens/screen.85' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/screens/screen.85'\"
else
  echo shar: Extracting \"'xsokoban-3.0/screens/screen.85'\" \(312 characters\)
  sed "s/^X//" >'xsokoban-3.0/screens/screen.85' <<'END_OF_FILE'
X############
X#      #   ##
X# $  $   #  ######
X####  #####      #
X #..  #     #### #
X #.####  ####    #
X #....    #  $ ####
X # ...#   # $$$#  ##
X###.#### ##  $@$   #
X#     ##### $ #    #
X# #.# $      $###$ #
X# #.########  #  $ #
X# #..        ##  $ #
X# # ####### $ # #  #
X#   #     #       ##
X#####     ##########
END_OF_FILE
  if test 312 -ne `wc -c <'xsokoban-3.0/screens/screen.85'`; then
    echo shar: \"'xsokoban-3.0/screens/screen.85'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/screens/screen.85'
fi
if test -f 'xsokoban-3.0/screens/screen.89' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/screens/screen.89'\"
else
  echo shar: Extracting \"'xsokoban-3.0/screens/screen.89'\" \(326 characters\)
  sed "s/^X//" >'xsokoban-3.0/screens/screen.89' <<'END_OF_FILE'
X ##################
X #   $       ...#.##
X #       ####..... #
X # #######  #..... #
X # #    $ $ ##....##
X # #  $ # # ###...#
X # # $@$ $  ##### #
X## #  $  $ $$   $ #
X#  #$# $#   # $## #
X# ##    ## ## $ # #
X# # $# $ $  #     #
X# #         #######
X# ########$##   #
X#        #  $   #
X########    #####
X       ###  #
X         ####
END_OF_FILE
  if test 326 -ne `wc -c <'xsokoban-3.0/screens/screen.89'`; then
    echo shar: \"'xsokoban-3.0/screens/screen.89'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/screens/screen.89'
fi
if test -f 'xsokoban-3.0/screens/screen.90' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/screens/screen.90'\"
else
  echo shar: Extracting \"'xsokoban-3.0/screens/screen.90'\" \(337 characters\)
  sed "s/^X//" >'xsokoban-3.0/screens/screen.90' <<'END_OF_FILE'
X####################
X#..#    #          #
X#.$  $  #$$  $## $##
X#.$#  ###  ## ##   #
X#  # $ #  $$   $   #
X# ###  # #  #$  ####
X#  ## # $   #@ #   #
X# $    $  ##.##  $ #
X#  # $# $# $     ###
X#  #  #  #   ###   #
X#  ######## #      #
X#           #  #.#.#
X##$########$#   ...#
X#    .*  #    ##.#.#
X# .*...*   $  .....#
X####################
X
END_OF_FILE
  if test 337 -ne `wc -c <'xsokoban-3.0/screens/screen.90'`; then
    echo shar: \"'xsokoban-3.0/screens/screen.90'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/screens/screen.90'
fi
if test -f 'xsokoban-3.0/xsokoban.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xsokoban-3.0/xsokoban.man'\"
else
  echo shar: Extracting \"'xsokoban-3.0/xsokoban.man'\" \(5471 characters\)
  sed "s/^X//" >'xsokoban-3.0/xsokoban.man' <<'END_OF_FILE'
X.TH XSOKOBAN 6 "2 November 1993" "MIT Lab for Computer Science"
X.SH NAME
Xxsokoban \- Pushing objects around...
X.SH SYNOPSIS
X.B xsokoban 
X[ 
X.B \-s
X.B \-r
X.B \-c
X.B \-nn
X.B \-display
X<disp>
X.B {\-w | \-walls}
X.B {\-rv | \-reverse}
X.B {\-f | \-font}
X<fn>
X.B {\-b | \-bitdir}
X<path>
X.B {\-fg | \-foregound}
X<color>
X.B {\-bg | \-backgound}
X<color>
X.B {\-bd | \-border}
X<color>
X.B {\-pr | \-pointer}
X<color>
X.B \-xrm
X<arg> ] 
X.SH DESCRIPTION
XThe goal of 
X.I xsokoban
Xis to push all the round objects into the score area of each level
Xusing the mouse or the arrow keys. The arrow keys move the player in
Xthe corresponding direction, pushing an object if it is in the way and
Xthere is a clear space on the other side. The mouse buttons each have a
Xdistinct function.
X
XIf the left mouse button is pressed on a clear square, the player will
Xmove to that location via the optimal path if such a path exists;
Xotherwise, the game will beep.
X
XIf the middle button is pressed on an object that is adjacent to the
Xplayer, the object will be pushed one step.  If the middle mouse button
Xis pressed on an empty space, the player will move the closest object
Xthat is on a straight line with the destination, such that the object
Xcan be pushed in that direction, and the player is not directly between
Xthe destination and the object.  Before pushing the object, the player
Xis moved optimally to start the push.
X
XThe right button mouse undoes the last user action, and may be used any
Xnumber of times.
X
X.PP
XThe rest of the functions are bound to the keyboard:
X.TP 8
X.B ?
XDisplay a help screen.
X.TP 8
X.B q
XQuit the game.
X.TP 8
X.B s
XSave and quit.
X.TP 8
X.B u
XUndo the last action. Same as right mouse button.
X.TP 8
X.B U
XRestart a level.
X.TP 8
X.B ^R
XRedraw the screen.
X.TP 8
X.B h,j,k,l
XAct just like the arrow keys, as in
X.IR vi (1).
X.SH OPTIONS
X.TP 8
X.B \-s
XShow the scores
X.TP 8
X.B \-c 
XCreate a new score file (can be ran only by the owner of the game).
X.TP 8
X.B \-r
XRestore a saved game.
X.TP 8
X.B \-nn
XStart at level 
X.I nn, 
Xprovided that levels below it are completed. 
X.TP 8
X.B \-display <display>
XRun the game on named display.
X.TP 8
X.B {\-w | \-walls}
XUse fancy walls. (This is the default unless an option bitmap set is used)
X.TP 8
X.B {\-rv | \-reverse}
XUse reverse video.
X.TP 8
X.B {\-f | \-font} <fontname>
XUse the named font instead of the default 9x15 font.
X.TP 8
X.B {\-b | \-bitdir} <path>
XUse the bitmaps found in <path> instead of the defaults.
X.TP 8
X.B {\-fg | \-foreground} <color>
XUse the named color as the foreground color. (default is BlackPixel())
X.TP 8
X.B {\-bg | \-background} <color>
XUse the named color as the background color. (default is WhitePixel())
X.TP 8
X.B {\-bd | \-border} <color>
XUse the named color as the border color. (default is foreground color)
X.TP 8
X.B {\-pr | \-pointer} <color>
XUse the named color as the mouse pointer foreground. (default is foreground)
X.TP 8
X.B \-xrm <arg>
X<arg> is an X Resource specification.
X.SH AUTHORS
XUnknown Hacker - Original curses(1) implementation.
X.br
XJoseph L. Traub - X windows interface.
X.br
XKevin Solie - simultaneously developed X implementation (merged in).
X.br
XMark Linderman, Christos Zoulas - Mouse code (added to Solie's version).
X.br
XAndrew Myers - Improved mouse UI and score ranking
X.SH RESOURCES
X.I Xsokoban
Xunderstands the following resources.
X.TP 8
X.B fancyWalls : boolean
XUse fancy walls.
X.TP 8
X.B fontName : font
XUse named font.
X.TP 8
X.B reverseVideo : boolean
XReverse foreground and background pixels.
X.TP 8
X.B foreground : color
XUse color as foreground color.
X.TP 8
X.B background : color
XUse color as background color.
X.TP 8
X.B borderColor : color
XUse color as border color.
X.TP 8
X.B pointerColor : color
XUse color as pointer color.
X.TP 8
X.B bitmapDir : string
XLook for bitmaps in path specified by string.
X.TP 8
X.SH SPECIAL BITMAPS
XIn order to define your own bitmaps for
X.I xsokoban
Xyou only need to know the names of which files it is looking for.
XThe standard bitmap files are:
X.TP 8
X.B man.xbm
X-- The player bitmap.
X.TP 8
X.B goal.xbm
X-- The goal area bitmap.
X.TP 8
X.B wall.xbm
X-- The standard wall bitmap.
X.TP 8
X.B object.xbm
X-- The object that gets pushed.
X.TP 8
X.B treasure.xbm
X-- The bitmap for the object when it is on the goal.
X.TP 8
X.B saveman.xbm
X-- The bitmap for the player when it is on the goal.
X.TP 8
XTo use the fancy walls option, you need the following additional files.
X.TP 8
X.B lonewall.xbm
X-- a wall with connections on no sides.
X.TP 8
X.B southwall.xbm
X-- a wall with only northern connections
X.TP 8
X.B northwall.xbm
X-- a wall with only southern connections
X.TP 8
X.B eastwall.xbm
X-- a wall with only western connections
X.TP 8
X.B westwall.xbm
X-- a wall with only eastern connections
X.TP 8
X.B llcornerwall.xbm
X-- a wall with northern and eastern connections
X.TP 8
X.B ulcornerwall.xbm
X-- a wall with southern and eastern connections
X.TP 8
X.B lrcornerwall.xbm
X-- a wall with northern and western connections
X.TP 8
X.B urcornerwall.xbm
X-- a wall with southern and western connections
X.TP 8
X.B north_twall.xbm
X-- a wall with connections on all BUT northern side
X.TP 8
X.B south_twall.xbm
X-- a wall with connections on all BUT southern side
X.TP 8
X.B east_twall.xbm
X-- a wall with connections on all BUT eastern side
X.TP 8
X.B west_twall.xbm
X-- a wall with connections on all BUT western side
X.TP 8
X.B centerwall.xbm
X-- A wall will connections on all four sides.
X.SH BUGS
XAuto bitmap resizing code doesn't take into account text displays.
X.br
XFeedback on user error is poor (only beeps).
END_OF_FILE
  if test 5471 -ne `wc -c <'xsokoban-3.0/xsokoban.man'`; then
    echo shar: \"'xsokoban-3.0/xsokoban.man'\" unpacked with wrong size!
  fi
  # end of 'xsokoban-3.0/xsokoban.man'
fi
echo shar: End of archive 2 \(of 4\).
cp /dev/null ark2isdone
MISSING=""
for I in 1 2 3 4 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 4 archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga: The only way to fly!  |    sources-x@sterling.com
       "It's intuitively obvious to the most casual observer..."
 GCS d++(--) -p+ c++ !l u++ e+ m+(-) s++/++ n h--- f+ g+++ w+ t++ r+ y+
