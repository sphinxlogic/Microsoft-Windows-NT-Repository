Newsgroups: comp.sources.x
From: pf@z-code.z-code.com ("Paul Falstad")
Subject: v21i084:  xmine - X11-based version of the popular PC game Minesweeper, Part01/01
Message-ID: <1994Jan4.185238.14877@sparky.sterling.com>
X-Md4-Signature: 565ce27ab9c3f7fe563d023a5069695d
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Tue, 4 Jan 1994 18:52:38 GMT
Approved: chris@sterling.com

Submitted-by: pf@z-code.z-code.com ("Paul Falstad")
Posting-number: Volume 21, Issue 84
Archive-name: xmine/part01
Environment: X11, OSF/Motif

xmine is an X11-based version of the popular PC game Minesweeper. The
object is to place flags on mines on the game board without exposing
them.

xmine is freely redistributable.  It's mostly Xlib-based, but it
requires Motif libraries for the menus.

Author: Paul Falstad (pf@z-code.com)

---- Cut Here and feed the following to sh ----
#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  README Imakefile Makefile Xmine cool.xbm dead.xbm
#   fallback.h fillface.xbm happy.xbm ohno.xbm patchlevel.h press.xbm
#   xmine.1 xmine.c
# Wrapped by chris@sparky on Tue Jan  4 12:37:03 1994
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin:$PATH ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 1)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(289 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
Xxmine is an X11-based version of the popular PC game Minesweeper. The
Xobject is to place flags on mines on the game board without exposing
Xthem.
X
Xxmine is freely redistributable.  It's mostly Xlib-based, but it
Xrequires Motif libraries for the menus.
X
XAuthor: Paul Falstad (pf@z-code.com)
END_OF_FILE
  if test 289 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
  echo shar: Extracting \"'Imakefile'\" \(79 characters\)
  sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
XSYS_LIBRARIES = -lXm -lXt -lX11
X
XAllTarget(xmine)
X
XSimpleProgramTarget(xmine)
X
END_OF_FILE
  if test 79 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
  fi
  # end of 'Imakefile'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(211 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
XCC = cc
XCFLAGS = -O -D_NO_PROTO
X
XLIBS = -lXm -lXt -lX11
X
Xxmine: xmine.c fallback.h
X	$(CC) $(CFLAGS) -o xmine xmine.c $(LIBS)
X
Xfallback.h: Xmine
X	sed -e 's/^/"/' -e 's/\\/\\\\/g' -e 's/$$/",/' Xmine > fallback.h
END_OF_FILE
  if test 211 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'Xmine' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Xmine'\"
else
  echo shar: Extracting \"'Xmine'\" \(1353 characters\)
  sed "s/^X//" >'Xmine' <<'END_OF_FILE'
XXmine*foreground: White
XXmine*background: Grey50
XXmine*menubar*fontList: -*-times-bold-i-normal--14-100-*-*-*-*-*-*
XXmine*fontList: -*-times-bold-r-normal--14-100-*-*-*-*-*-*
X*game.labelString: Game
X*game.mnemonic: G
X*New.mnemonic: N
X*New.accelerator: <Key>F2
X*New.acceleratorText: F2
X*Beginner.mnemonic: B
X*Intermediate.mnemonic: I
X*Expert.mnemonic: E
X*Custom.labelString: Custom ...
X*Custom.mnemonic: C
X*Marks.labelString: Marks [?]
X*Marks.mnemonic: M
X*Best.labelString: Best Times
X*Best.mnemonic: T
X*Exit.mnemonic: x
X*About.labelString: About xmine ...
X*About.mnemonic: A
X*Custom.title: Custom Field
X*Custom*height_label.labelString: Height:
X*Custom*width_label.labelString: Width:
X*Custom*mines_label.labelString: Mines:
X*Custom*height_text.columns: 4
X*Custom*width_text.columns: 4
X*Custom*mines_text.columns: 4
X*Custom*ok.labelString: Ok
X*Best.title: Best Scores
X*Best*label.labelString: Fastest Mine Sweepers
X*Best*begin_label.labelString: Beginner:
X*Best*inter_label.labelString: Intermediate:
X*Best*expert_label.labelString: Expert:
X*Best*ok.labelString: Ok
X*Best*clear.labelString: Reset Scores
X*About.title: About xmine
X*About*ok.labelString: Ok
X*HighScorer.title: New Best Score
X*HighScorer*label.labelString: You have the fastest time for this
Xlevel.\nPlease enter your name.
X*HighScorer*name.value: Anonymous
X*HighScorer*ok.labelString: Ok
END_OF_FILE
  if test 1353 -ne `wc -c <'Xmine'`; then
    echo shar: \"'Xmine'\" unpacked with wrong size!
  fi
  # end of 'Xmine'
fi
if test -f 'cool.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'cool.xbm'\"
else
  echo shar: Extracting \"'cool.xbm'\" \(275 characters\)
  sed "s/^X//" >'cool.xbm' <<'END_OF_FILE'
X#define cool_width 16
X#define cool_height 16
Xstatic char cool_bits[] = {
X   0xc0, 0x07, 0x30, 0x18, 0x08, 0x20, 0x04, 0x40, 0x04, 0x40, 0xfa, 0xbf,
X   0xf6, 0xde, 0x62, 0x8c, 0x02, 0x80, 0x12, 0x90, 0x24, 0x48, 0xc4, 0x47,
X   0x08, 0x20, 0x30, 0x18, 0xc0, 0x07, 0x00, 0x00};
END_OF_FILE
  if test 275 -ne `wc -c <'cool.xbm'`; then
    echo shar: \"'cool.xbm'\" unpacked with wrong size!
  fi
  # end of 'cool.xbm'
fi
if test -f 'dead.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'dead.xbm'\"
else
  echo shar: Extracting \"'dead.xbm'\" \(275 characters\)
  sed "s/^X//" >'dead.xbm' <<'END_OF_FILE'
X#define dead_width 16
X#define dead_height 16
Xstatic char dead_bits[] = {
X   0xc0, 0x07, 0x30, 0x18, 0x08, 0x20, 0x04, 0x40, 0x54, 0x54, 0x22, 0x88,
X   0x52, 0x94, 0x02, 0x80, 0x02, 0x80, 0xc2, 0x87, 0x24, 0x48, 0x04, 0x40,
X   0x08, 0x20, 0x30, 0x18, 0xc0, 0x07, 0x00, 0x00};
END_OF_FILE
  if test 275 -ne `wc -c <'dead.xbm'`; then
    echo shar: \"'dead.xbm'\" unpacked with wrong size!
  fi
  # end of 'dead.xbm'
fi
if test -f 'fallback.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fallback.h'\"
else
  echo shar: Extracting \"'fallback.h'\" \(1480 characters\)
  sed "s/^X//" >'fallback.h' <<'END_OF_FILE'
X"Xmine*foreground: White",
X"Xmine*background: Grey50",
X"Xmine*menubar*fontList: -*-times-bold-i-normal--14-100-*-*-*-*-*-*",
X"Xmine*fontList: -*-times-bold-r-normal--14-100-*-*-*-*-*-*",
X"*game.labelString: Game",
X"*game.mnemonic: G",
X"*New.mnemonic: N",
X"*New.accelerator: <Key>F2",
X"*New.acceleratorText: F2",
X"*Beginner.mnemonic: B",
X"*Intermediate.mnemonic: I",
X"*Expert.mnemonic: E",
X"*Custom.labelString: Custom ...",
X"*Custom.mnemonic: C",
X"*Marks.labelString: Marks [?]",
X"*Marks.mnemonic: M",
X"*Best.labelString: Best Times",
X"*Best.mnemonic: T",
X"*Exit.mnemonic: x",
X"*About.labelString: About xmine ...",
X"*About.mnemonic: A",
X"*Custom.title: Custom Field",
X"*Custom*height_label.labelString: Height:",
X"*Custom*width_label.labelString: Width:",
X"*Custom*mines_label.labelString: Mines:",
X"*Custom*height_text.columns: 4",
X"*Custom*width_text.columns: 4",
X"*Custom*mines_text.columns: 4",
X"*Custom*ok.labelString: Ok",
X"*Best.title: Best Scores",
X"*Best*label.labelString: Fastest Mine Sweepers",
X"*Best*begin_label.labelString: Beginner:",
X"*Best*inter_label.labelString: Intermediate:",
X"*Best*expert_label.labelString: Expert:",
X"*Best*ok.labelString: Ok",
X"*Best*clear.labelString: Reset Scores",
X"*About.title: About xmine",
X"*About*ok.labelString: Ok",
X"*HighScorer.title: New Best Score",
X"*HighScorer*label.labelString: You have the fastest time for this
Xlevel.\\nPlease enter your name.",
X"*HighScorer*name.value: Anonymous",
X"*HighScorer*ok.labelString: Ok",
END_OF_FILE
  if test 1480 -ne `wc -c <'fallback.h'`; then
    echo shar: \"'fallback.h'\" unpacked with wrong size!
  fi
  # end of 'fallback.h'
fi
if test -f 'fillface.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fillface.xbm'\"
else
  echo shar: Extracting \"'fillface.xbm'\" \(287 characters\)
  sed "s/^X//" >'fillface.xbm' <<'END_OF_FILE'
X#define fillface_width 16
X#define fillface_height 16
Xstatic char fillface_bits[] = {
X   0xc0, 0x07, 0xf0, 0x1f, 0xf8, 0x3f, 0xfc, 0x7f, 0xfc, 0x7f, 0xfe, 0xff,
X   0xfe, 0xff, 0xfe, 0xff, 0xfe, 0xff, 0xfe, 0xff, 0xfc, 0x7f, 0xfc, 0x7f,
X   0xf8, 0x3f, 0xf0, 0x1f, 0xc0, 0x07, 0x00, 0x00};
END_OF_FILE
  if test 287 -ne `wc -c <'fillface.xbm'`; then
    echo shar: \"'fillface.xbm'\" unpacked with wrong size!
  fi
  # end of 'fillface.xbm'
fi
if test -f 'happy.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'happy.xbm'\"
else
  echo shar: Extracting \"'happy.xbm'\" \(278 characters\)
  sed "s/^X//" >'happy.xbm' <<'END_OF_FILE'
X#define happy_width 16
X#define happy_height 16
Xstatic char happy_bits[] = {
X   0xc0, 0x07, 0x30, 0x18, 0x08, 0x20, 0x04, 0x40, 0x64, 0x4c, 0x62, 0x8c,
X   0x02, 0x80, 0x02, 0x80, 0x02, 0x80, 0x12, 0x90, 0x24, 0x48, 0xc4, 0x47,
X   0x08, 0x20, 0x30, 0x18, 0xc0, 0x07, 0x00, 0x00};
END_OF_FILE
  if test 278 -ne `wc -c <'happy.xbm'`; then
    echo shar: \"'happy.xbm'\" unpacked with wrong size!
  fi
  # end of 'happy.xbm'
fi
if test -f 'ohno.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ohno.xbm'\"
else
  echo shar: Extracting \"'ohno.xbm'\" \(275 characters\)
  sed "s/^X//" >'ohno.xbm' <<'END_OF_FILE'
X#define ohno_width 16
X#define ohno_height 16
Xstatic char ohno_bits[] = {
X   0xc0, 0x07, 0x30, 0x18, 0x08, 0x20, 0x64, 0x4c, 0x64, 0x4c, 0x62, 0x8c,
X   0x02, 0x80, 0x02, 0x80, 0x82, 0x83, 0x42, 0x84, 0x44, 0x44, 0x84, 0x43,
X   0x08, 0x20, 0x30, 0x18, 0xc0, 0x07, 0x00, 0x00};
END_OF_FILE
  if test 275 -ne `wc -c <'ohno.xbm'`; then
    echo shar: \"'ohno.xbm'\" unpacked with wrong size!
  fi
  # end of 'ohno.xbm'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
  echo shar: Extracting \"'patchlevel.h'\" \(21 characters\)
  sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X#define PATCHLEVEL 1
END_OF_FILE
  if test 21 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
  fi
  # end of 'patchlevel.h'
fi
if test -f 'press.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'press.xbm'\"
else
  echo shar: Extracting \"'press.xbm'\" \(278 characters\)
  sed "s/^X//" >'press.xbm' <<'END_OF_FILE'
X#define press_width 16
X#define press_height 16
Xstatic char press_bits[] = {
X   0xc0, 0x07, 0x30, 0x18, 0x08, 0x20, 0x04, 0x40, 0x04, 0x46, 0xc2, 0x86,
X   0xc2, 0x80, 0x02, 0x80, 0x12, 0x80, 0x22, 0x90, 0x24, 0x4c, 0xc4, 0x43,
X   0x08, 0x20, 0x30, 0x18, 0xc0, 0x07, 0x00, 0x00};
END_OF_FILE
  if test 278 -ne `wc -c <'press.xbm'`; then
    echo shar: \"'press.xbm'\" unpacked with wrong size!
  fi
  # end of 'press.xbm'
fi
if test -f 'xmine.1' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xmine.1'\"
else
  echo shar: Extracting \"'xmine.1'\" \(2123 characters\)
  sed "s/^X//" >'xmine.1' <<'END_OF_FILE'
X.TH XMINE 1
X.SH NAME
Xxmine \- identify mines in a mine field without getting blown up
X.SH SYNOPSIS
X.RB xmine
X.SH DESCRIPTION
X.I xmine
Xis an X11-based version of the popular PC game Minesweeper. The
Xobject is to place flags on mines on the game board without exposing
Xthem.  If you expose a mine, it "explodes" and the game ends.  Exposed
Xmines appear as black capital "M" characters.
X.PP
XTo begin, click the first mouse button anywhere on the field.
XA series of numbers will be revealed.  The number
Xin each square corresponds to the number of mines that border
Xthat square, including diagonals.  Squares that do not border
Xmines are empty.
X.PP
XOnce you have determined the location of a mine, flag it by
Xclicking with the third mouse button.  Flags appear as
Xcapital "X" characters which are red on color displays.
XOnce you have marked
Xall the mines surrounding a number, click the middle mouse
Xbutton to reveal the contents of the un-mined squares surrounding
Xit.  If you flag a mine incorrectly and force an unflagged mine
Xto be revealed, the game ends.
X.PP
XThe number at the top left of the game board displays the number
Xof mines left for you to identify.  At the top right is a timer
Xthat indicates the number of seconds for which the game has
Xbeen running.  High scores are achieved by having the fastest
Xtime for a skill level.
X.PP
XThere are four levels of game play: beginner, intermediate,
Xexpert, and custom, set using the Game menu.  For each level, the number of
Xmines and the size of the board increase:
X.TP 5
X.B beginner
Xhas 10 mines in an 8x8 board.
X.TP 5
X.B intermediate
Xhas 40 mines in a 16x16 board.
X.TP 5
X.B expert
Xhas 99 mines in a 16x39 board.
X.TP 5
X.B custom
Xallows you to specify your own board dimensions and number of mines.
X.PP
XIf you choose Marks [?] from the Game menu, you may place question
Xmarks on squares by clicking twice with the third mouse button.
XAlthough they may be helpful for deducing the location of mines,
Xthey are not treated as flagged mines when you click with the middle
Xmouse button on a numbered square.
X.SH AUTHOR
XPaul Falstad
X.br
XManual entry written by Linda Branagan.
END_OF_FILE
  if test 2123 -ne `wc -c <'xmine.1'`; then
    echo shar: \"'xmine.1'\" unpacked with wrong size!
  fi
  # end of 'xmine.1'
fi
if test -f 'xmine.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'xmine.c'\"
else
  echo shar: Extracting \"'xmine.c'\" \(37268 characters\)
  sed "s/^X//" >'xmine.c' <<'END_OF_FILE'
X/* xmine - Copyright (c) 1993 by Paul Falstad
X * freely redistributable
X */
X
X#include <stdio.h>
X#include <Xm/MainW.h>
X#include <Xm/DrawingA.h>
X#include <Xm/PushBG.h>
X#include <Xm/PushB.h>
X#include <Xm/RowColumn.h>
X#include <Xm/ScrolledW.h>
X#include <Xm/Form.h>
X#include <Xm/CascadeBG.h>
X#include <Xm/Separator.h>
X#include <Xm/ToggleB.h>
X#include <Xm/DialogS.h>
X#include <Xm/TextF.h>
X#include <Xm/LabelG.h>
X#include <Xm/PanedW.h>
X
X#include "patchlevel.h"
X
X#define GSPACEX 16
X#define GSPACEY 16
X
X#define SCORE_FILE "~/.xmine_scores"
X#define TOPMARGIN 60
X#define BOTMARGIN 12
X#define SIDEMARGIN 12
X#define STATUS_Y_OFFSET 12
X#define TOTAL_WIDTH (SIDEMARGIN*2+gsizex*GSPACEX)
X#define TOTAL_HEIGHT (TOPMARGIN+BOTMARGIN+gsizey*GSPACEY)
X#define STATUS_HEIGHT (TOPMARGIN-STATUS_Y_OFFSET*2)
X#define DIGIT_X_OFFSET (SIDEMARGIN+4)
X#define DIGIT_Y_OFFSET (STATUS_Y_OFFSET+4)
X#define DIGIT_HEIGHT (TOPMARGIN-DIGIT_Y_OFFSET*2)
X#define DIGIT_WIDTH 16
X#define DIGIT_COUNT 3
X#define DIGIT_MARGIN 2
X#define DIGIT_HWEDGE_WIDTH (DIGIT_WIDTH-(DIGIT_MARGIN+1)*2)
X#define DIGIT_VWEDGE_HEIGHT ((DIGIT_HEIGHT-7)/2)
X
X#define COVERED 0
X#define MARKED 1
X#define UNCOVERED 2
X#define QUESTIONED 3
X#define MINE -1
X#define MAX_GSIZEX 100
X#define MAX_GSIZEY 100
Xint grid[MAX_GSIZEX][MAX_GSIZEY]; /* fix this */
Xint gridview[MAX_GSIZEX][MAX_GSIZEY]; /* fix this */
X#define INITIAL_SIZE_X 8
X#define INITIAL_SIZE_Y 8
Xint gsizex = INITIAL_SIZE_X, gsizey = INITIAL_SIZE_Y;
Xint layed_out = 0, game_on = 1, face_armed = 0;
Xint questions_allowed = 0, game_level = 0;
XXFontStruct *font_info;
XWidget drawarea;
XDisplay *disp;
XWindow win;
X
X#define COL_BLUE 0
X#define COL_LIMEGREEN 1
X#define COL_RED 2
X#define COL_NAVY 3
X#define COL_BROWN 4
X#define COL_AQUA 5
X#define COL_BLACK 6
X#define COL_GRAY 7
X#define COL_WHITE 8
X#define COL_LITEGRAY 9
X#define COL_DARKGRAY 10
X#define COL_YELLOW 11
X#define COL_DARKRED 12
X#define COL_COUNT 13
Xchar *colnames[COL_COUNT] = {
X    "Blue", "LimeGreen", "Red", "Navy",
X    "Brown", "MediumAquamarine", "Black", "Gray",
X    "White", "Grey75", "Grey50", "Yellow", "darkred"
X};
XXColor cols[COL_COUNT];
X
Xint numcols[] = {
X    COL_BLUE, COL_LIMEGREEN, COL_RED, COL_NAVY,
X    COL_BROWN, COL_AQUA, COL_BLACK, COL_GRAY
X};
X
X#include "cool.xbm"
X#include "fillface.xbm"
X#include "dead.xbm"
X#include "happy.xbm"
X#include "ohno.xbm"
X#include "press.xbm"
X
X#define FACE_HAPPY 0
X#define FACE_OHNO 1
X#define FACE_COOL 2
X#define FACE_DEAD 3
X#define FACE_PRESS 4
X#define FACE_COUNT 5
XPixmap faces[FACE_COUNT];
Xstatic char *face_bits[FACE_COUNT] = {
X    happy_bits, ohno_bits, cool_bits, dead_bits, press_bits
X};
Xint cur_face = FACE_HAPPY;
Xint mine_count, covered_count, marked_count;
Xint armed_x, armed_y, armed, timer;
XXtIntervalId timer_id;
X
X#define FACE_BUTTON_WIDTH (fillface_width+5)
X#define FACE_BUTTON_HEIGHT (fillface_height+5)
X#define FACE_X_POS ((TOTAL_WIDTH-FACE_BUTTON_WIDTH)/2+1)
X#define FACE_Y_POS ((TOPMARGIN-FACE_BUTTON_HEIGHT)/2)
X
XGC gc;
X
X#ifdef __STDC__
X#define P(X) X
X#else
X#define P(X) ()
X#endif /* __STDC__ */
X
Xtypedef void (*void_proc)();
X
Xextern void search_action P ((Widget, XButtonEvent *, String *, int *));
Xextern void clear_action P ((Widget, XButtonEvent *, String *, int *));
Xextern void mark_action P ((Widget, XButtonEvent *, String *, int *));
Xextern void redraw_cb P ((Widget, XtPointer, XmDrawingAreaCallbackStruct *));
Xextern void redrawsquare P ((int, int));
Xextern void drawsquare P ((int, int));
Xextern int hasmine P ((int, int));
Xextern void uncover P ((int, int));
Xextern void clear_around P ((int, int));
Xextern int is_state P ((int, int, int));
Xextern void shadow_rev_rect P ((int, int, int, int, int));
Xextern void shadow_rect P ((int, int, int, int, int));
Xextern XmString genxmstr P ((char *));
Xextern void layout_board P ((int, int));
Xextern void boom P ((void));
Xextern void restart P ((void));
Xextern void draw_face P ((void));
Xextern void set_face P ((int));
Xextern void winner P ((void));
Xextern void draw_blank_square P ((int, int, int));
Xextern void draw_button P ((int, int));
Xextern void arm_clear P ((int, int, int));
Xextern void track_face P ((int, int, int));
Xextern void arm_face P ((int));
Xextern void draw_digit P ((int, int, int));
Xextern void draw_digits P ((int, int));
Xextern void timer_callback P ((void));
Xextern void set_level P ((Widget, int));
Xextern void tog_question P ((void));
Xextern void set_custom P ((void));
Xextern void dialog_ok P ((void));
Xextern void get_text_int P ((Widget, int *));
Xextern void best_times P ((void));
Xextern void about P ((void));
Xextern struct scores *get_scores P ((void));
Xextern void write_scores P ((struct scores *));
Xextern void get_score_file_name P ((char *));
Xextern void new_best P ((int));
Xextern void clear_scores P ((void));
Xextern int cant_write_score_file P ((void));
Xextern void fix_size P ((void));
Xextern void relax_size P ((void));
Xextern void resize_handler P ((Widget, XtPointer, XEvent *, Boolean *));
X
XPixmap fillface;
XXtAppContext app;
XWidget toplevel, menubar;
XWidget level_buttons[4];
X
Xstruct scores {
X    char names[3][80];
X    int times[3];
X};
X
Xchar *fallbacks[] = {
X#include "fallback.h"
X    NULL
X};
X
Xmain(argc, argv)
Xunsigned int argc;
Xchar *argv[];
X{
X    Widget main_w, drawing_a, menu, btn;
X    XGCValues gcv;
X    void draw(), redraw_cb(), set_color(), exit();
X    XColor unused;
X    int i;
X
X    XtActionsRec actions[3];
X    String translations =
X        "<Btn1Down>:   search(down)\n\
X         <Btn1Up>:     search(up)\n\
X         <Btn1Motion>: search(move)\n\
X	 <Btn2Down>:   clear(down)\n\
X	 <Btn2Motion>: clear(move)\n\
X	 <Btn2Up>:     clear(up)\n\
X	 <Btn3Down>:   mark(down)\n";
X
X    toplevel = XtVaAppInitialize(&app, "Xmine", NULL, 0,
X        &argc, argv, fallbacks, NULL);
X
X    main_w = XtVaCreateManagedWidget("main_w",
X        xmFormWidgetClass, toplevel,
X	NULL);
X
X    menubar = XmCreateMenuBar(main_w, "menubar", NULL, 0);
X    XtVaSetValues(menubar,
X	XmNtopAttachment, XmATTACH_FORM,
X	XmNleftAttachment, XmATTACH_FORM,
X	XmNrightAttachment,	XmATTACH_FORM,
X	NULL);
X    menu = XmCreatePulldownMenu(menubar, "game_menu", NULL, 0);
X    XtVaCreateManagedWidget("game",
X	xmCascadeButtonGadgetClass, menubar,
X	XmNsubMenuId,		    menu,
X	XmNbackground,	 cols[COL_LITEGRAY].pixel,
X	NULL);
X    btn = XtVaCreateManagedWidget("New",
X	xmPushButtonGadgetClass,   menu,
X	NULL);
X    XtAddCallback(btn, XmNactivateCallback, (void_proc) restart, 0);
X    XtVaCreateManagedWidget("_sep1", xmSeparatorWidgetClass, menu, NULL);
X    level_buttons[0] = btn = XtVaCreateManagedWidget("Beginner",
X	xmToggleButtonWidgetClass,   menu,
X	NULL);
X    XtAddCallback(btn, XmNvalueChangedCallback, (void_proc) set_level,
X(XtPointer) 1);
X    level_buttons[1] = btn = XtVaCreateManagedWidget("Intermediate",
X	xmToggleButtonWidgetClass,   menu,
X	NULL);
X    XtAddCallback(btn, XmNvalueChangedCallback, (void_proc) set_level,
X(XtPointer) 2);
X    level_buttons[2] = btn = XtVaCreateManagedWidget("Expert",
X	xmToggleButtonWidgetClass,   menu,
X	NULL);
X    XtAddCallback(btn, XmNvalueChangedCallback, (void_proc) set_level,
X(XtPointer) 3);
X    level_buttons[3] = btn = XtVaCreateManagedWidget("Custom",
X	xmToggleButtonWidgetClass,   menu,
X	NULL);
X    XtAddCallback(btn, XmNvalueChangedCallback, (void_proc) set_custom, NULL);
X    XtVaCreateManagedWidget("_sep2", xmSeparatorWidgetClass, menu, NULL);
X    btn = XtVaCreateManagedWidget("Marks",
X	xmToggleButtonWidgetClass,   menu,
X	NULL);
X    XtAddCallback(btn, XmNvalueChangedCallback,
X	(XtPointer) tog_question, NULL);
X    XtVaCreateManagedWidget("_sep3", xmSeparatorWidgetClass, menu, NULL);
X    btn = XtVaCreateManagedWidget("Best",
X	xmPushButtonWidgetClass,   menu,
X	NULL);
X    XtAddCallback(btn, XmNactivateCallback, (void_proc) best_times, NULL);
X    btn = XtVaCreateManagedWidget("About",
X	xmPushButtonWidgetClass,   menu,
X	NULL);
X    XtAddCallback(btn, XmNactivateCallback, (void_proc) about, NULL);
X    btn = XtVaCreateManagedWidget("Exit",
X	xmPushButtonWidgetClass,   menu,
X	NULL);
X    XtAddCallback(btn, XmNactivateCallback, (void_proc) exit, NULL);
X    XtManageChild(menubar);
X
X    for (i = 0; i != COL_COUNT; i++)
X	XAllocNamedColor(XtDisplay(main_w),
X	    DefaultColormapOfScreen(XtScreen(main_w)),
X	    colnames[i], &cols[i], &unused);
X    {
X	cols[COL_DARKRED].red = 60*256;
X	cols[COL_DARKRED].green = cols[COL_DARKRED].blue = 0;
X	XAllocColor(XtDisplay(main_w),
X	    DefaultColormapOfScreen(XtScreen(main_w)),
X	    &cols[COL_DARKRED]);
X    }
X
X    gcv.foreground = cols[COL_WHITE].pixel;
X    gc = XCreateGC(XtDisplay(main_w),
X        RootWindowOfScreen(XtScreen(main_w)), GCForeground, &gcv);
X
X    actions[0].string = "clear";
X    actions[0].proc = (void_proc) clear_action;
X    actions[1].string = "search";
X    actions[1].proc = (void_proc) search_action;
X    actions[2].string = "mark";
X    actions[2].proc = (void_proc) mark_action;
X    XtAppAddActions(app, actions, 3);
X
X    drawing_a = XtVaCreateManagedWidget("drawing_a",
X        xmDrawingAreaWidgetClass, main_w,
X        XmNtranslations, XtParseTranslationTable(translations),
X        XmNwidth,        GSPACEX*gsizex+SIDEMARGIN*2,
X        XmNheight,       GSPACEY*gsizey+TOPMARGIN+BOTMARGIN,
X        XmNresizePolicy, XmNONE,  /* remain this a fixed size */
X	XmNbackground,	 cols[COL_LITEGRAY].pixel,
X	XmNtopAttachment,XmATTACH_WIDGET,
X	XmNtopWidget,	 menubar,
X        NULL);
X    XtAddCallback(drawing_a, XmNexposeCallback, (void_proc) redraw_cb, NULL);
X    font_info = XLoadQueryFont(XtDisplay(main_w),
X	"-*-courier-bold-r-normal-*-*-120-*");
X    XSetFont(XtDisplay(main_w), gc, font_info->fid);
X
X    set_level((Widget) 0, 1);
X    XtAddEventHandler(toplevel,
X	StructureNotifyMask, False, resize_handler, 0);
X    XtRealizeWidget(toplevel);
X    fillface = XCreateBitmapFromData(XtDisplay(main_w),
X	XtWindow(main_w), fillface_bits,
X	fillface_width, fillface_height);
X    for (i = 0; i != FACE_COUNT; i++)
X	faces[i] = XCreateBitmapFromData(XtDisplay(main_w),
X	    XtWindow(main_w), face_bits[i],
X	    fillface_width, fillface_height);
X    drawarea = drawing_a;
X    win = XtWindow(drawing_a);
X    disp = XtDisplay(drawing_a);
X    XtAppMainLoop(app);
X    return 0;
X}
X
Xvoid
Xsearch_action(widget, event, args, num_args)
XWidget widget;
XXButtonEvent *event;
XString *args;
Xint *num_args;
X{
X    int xg, yg;
X
X    track_face(event->x, event->y, *args[0]);
X    if (!game_on) return;
X    xg = (event->x-SIDEMARGIN)/GSPACEX;
X    yg = (event->y-TOPMARGIN)/GSPACEY;
X    if (!strcmp(args[0], "down")) {
X	armed = False;
X	if (!(xg >= 0 && xg < gsizex && yg >= 0 && yg < gsizey))
X	    return;
X	if (gridview[xg][yg] != COVERED) return;
X	armed_x = xg; armed_y = yg;
X	armed = True;
X	set_face(FACE_OHNO);
X	draw_blank_square(xg, yg, True);
X	return;
X    }
X    if (!strcmp(args[0], "move")) {
X	if (xg == armed_x && yg == armed_y) {
X	    if (!armed) {
X		set_face(FACE_OHNO);
X		draw_blank_square(armed_x, armed_y, True);
X		armed = True;
X	    }
X	} else {
X	    if (armed) {
X		set_face(FACE_HAPPY);
X		draw_button(armed_x, armed_y);
X		armed = False;
X	    }
X	}
X	return;
X    }
X    if (!armed) return;
X    if (!layed_out) layout_board(armed_x, armed_y);
X    uncover(armed_x, armed_y);
X    if (game_on) set_face(FACE_HAPPY);
X}
X
Xvoid
Xtrack_face(x, y, op)
Xint x, y, op;
X{
X    int onface = False;
X
X    if (x >= FACE_X_POS && x <= FACE_X_POS+FACE_BUTTON_WIDTH &&
X	y >= FACE_Y_POS && y <= FACE_Y_POS+FACE_BUTTON_HEIGHT)
X	onface = True;
X    if (op == 'u') {
X	if (!face_armed) return;
X	arm_face(False);
X	restart();
X	return;
X    }
X    if (op == 'd') {
X	if (!onface) return;
X	arm_face(True);
X	armed = False;
X	return;
X    }
X    if (onface != face_armed)
X	arm_face(onface);
X}
X
Xvoid
Xarm_face(armit)
Xint armit;
X{
X    face_armed = armit;
X    XClearArea(disp, win,
X	FACE_X_POS, FACE_Y_POS, FACE_BUTTON_WIDTH, FACE_BUTTON_HEIGHT,
X	False);
X    if (face_armed)
X	shadow_rev_rect(FACE_X_POS+2, FACE_Y_POS+2,
X	    FACE_BUTTON_WIDTH-4, FACE_BUTTON_HEIGHT-4, 2);
X    else
X	shadow_rect(FACE_X_POS, FACE_Y_POS,
X	    FACE_BUTTON_WIDTH, FACE_BUTTON_HEIGHT, 2);
X    draw_face();
X}
X
Xvoid
Xmark_action(widget, event, args, num_args)
XWidget widget;
XXButtonEvent *event;
XString *args;
Xint *num_args;
X{
X    if (!game_on) return;
X    if (!layed_out) return;
X    if (!strcmp(args[0], "down")) {
X	int xg, yg;
X
X	xg = (event->x-SIDEMARGIN)/GSPACEX;
X	yg = (event->y-TOPMARGIN)/GSPACEY;
X	if (xg >= 0 && xg < gsizex &&
X	    yg >= 0 && yg < gsizey) {
X	    if (gridview[xg][yg] == UNCOVERED) return;
X	    if (gridview[xg][yg] == MARKED) {
X		gridview[xg][yg] = (questions_allowed) ? QUESTIONED : COVERED;
X		marked_count--;
X	    } else if (gridview[xg][yg] == QUESTIONED)
X		gridview[xg][yg] = COVERED;
X	    else {
X		gridview[xg][yg] = MARKED;
X		marked_count++;
X	    }
X	    redrawsquare(xg, yg);
X	    draw_digits(mine_count-marked_count, 0);
X	    draw_digits(timer, 1);
X	}
X    }
X}
X
Xvoid
Xclear_action(widget, event, args, num_args)
XWidget widget;
XXButtonEvent *event;
XString *args;
Xint *num_args;
X{
X    int xg, yg;
X
X    if (!game_on) return;
X    if (!layed_out) return;
X    xg = (event->x-SIDEMARGIN)/GSPACEX;
X    yg = (event->y-TOPMARGIN)/GSPACEY;
X    if (!(xg >= 0 && xg < gsizex && yg >= 0 && yg < gsizey))
X	return;
X    if (!strcmp(args[0], "down")) {
X	arm_clear(xg, yg, True);
X	armed_x = xg; armed_y = yg;
X	return;
X    }
X    if (!strcmp(args[0], "move")) {
X	int arm_it = (xg == armed_x && yg == armed_y);
X	if (arm_it != armed) arm_clear(armed_x, armed_y, arm_it);
X	return;
X    }
X    if (!armed) return;
X    arm_clear(armed_x, armed_y, False);
X    clear_around(xg, yg);
X    if (game_on)
X	set_face(FACE_HAPPY);
X}
X
Xvoid
Xarm_clear(x, y, armit)
Xint x, y, armit;
X{
X    int dx, dy;
X
X    armed = armit;
X    set_face(armit ? FACE_OHNO : FACE_HAPPY);
X    for (dx = -1; dx <= 1; dx++)
X	for (dy = -1; dy <= 1; dy++)
X	    if (is_state(x+dx, y+dy, COVERED))
X		if (armit)
X		    draw_blank_square(x+dx, y+dy, True);
X		else
X		    draw_button(x+dx, y+dy);
X}
X
Xvoid
Xdraw_face()
X{
X    int x, y;
X
X    x = (TOTAL_WIDTH-fillface_width)/2+face_armed;
X    y = (TOPMARGIN-fillface_height)/2+face_armed;
X    XSetClipMask(disp, gc, fillface);
X    XSetClipOrigin(disp, gc, x, y);
X    XSetBackground(disp, gc, cols[COL_YELLOW].pixel);
X    XSetForeground(disp, gc, cols[COL_BLACK].pixel);
X    XCopyPlane(disp,
X	(Drawable) faces[(face_armed) ? FACE_PRESS : cur_face],
X	win, gc, 0, 0,
X	fillface_width, fillface_height, x, y, 1L);
X    XSetClipMask(disp, gc, None);
X}
X
Xvoid
Xset_face(f)
Xint f;
X{
X    if (cur_face == f) return;
X    cur_face = f;
X    draw_face();
X}
X
Xvoid
Xredraw_cb(drawing_a, client_data, cbs)
XWidget    drawing_a;
XXtPointer client_data;
XXmDrawingAreaCallbackStruct *cbs;
X{
X    int x, y, w, h, xf, yf, xt, yt;
X
X    x = cbs->event->xexpose.x-SIDEMARGIN;
X    y = cbs->event->xexpose.y-TOPMARGIN;
X    w = cbs->event->xexpose.width;
X    h = cbs->event->xexpose.height;
X    xf = x/GSPACEX;
X    yf = y/GSPACEY;
X    xt = (x+w+GSPACEX-1)/GSPACEX;
X    yt = (y+h+GSPACEX-1)/GSPACEX;
X    for (x = xf; x <= xt; x++)
X	for (y = yf; y <= yt; y++)
X	    drawsquare(x, y);
X    if (xf < 0 || yf < 0 || xt >= gsizex || yt >= gsizey) {
X	shadow_rect(0, 0, TOTAL_WIDTH, TOTAL_HEIGHT, 3);
X	shadow_rev_rect(SIDEMARGIN, TOPMARGIN,
X	    TOTAL_WIDTH-SIDEMARGIN*2,
X	    TOTAL_HEIGHT-(TOPMARGIN+BOTMARGIN), 3);
X	shadow_rev_rect(SIDEMARGIN, STATUS_Y_OFFSET,
X	    TOTAL_WIDTH-SIDEMARGIN*2,
X	    STATUS_HEIGHT, 3);
X	shadow_rect(FACE_X_POS, FACE_Y_POS,
X	    FACE_BUTTON_WIDTH, FACE_BUTTON_HEIGHT, 2);
X	draw_face();
X	draw_digits(mine_count-marked_count, 0);
X	draw_digits(timer, 1);
X    }
X}
X
Xvoid
Xredrawsquare(x, y)
Xint x, y;
X{
X    XClearArea(disp, win, x*GSPACEX+SIDEMARGIN,
X	y*GSPACEY+TOPMARGIN, GSPACEX, GSPACEY, True);
X}
X
Xvoid
Xredraw_all()
X{
X    XClearArea(disp, win, SIDEMARGIN,
X	TOPMARGIN, GSPACEX*gsizex, GSPACEY*gsizey, True);
X}
X
Xvoid
Xredraw_entire()
X{
X    if (disp)
X	XClearArea(disp, win, 0, 0, TOTAL_WIDTH, TOTAL_HEIGHT, True);
X}
X
Xvoid
Xshadow_rect(xp, yp, w, h, thick)
Xint xp, yp, w, h, thick;
X{
X    int off = 0;
X
X    w--, h--;
X    while (thick--) {
X	XSetForeground(disp, gc, cols[COL_WHITE].pixel);
X	XDrawLine(disp, win, gc,
X	    xp, yp+off, xp+w-off, yp+off);
X	XDrawLine(disp, win, gc,
X	    xp+off, yp, xp+off, yp+h-off);
X	XSetForeground(disp, gc, cols[COL_DARKGRAY].pixel);
X	XDrawLine(disp, win, gc,
X	    xp+off, yp+h-off, xp+w, yp+h-off);
X	XDrawLine(disp, win, gc,
X	    xp+w-off, yp+off, xp+w-off, yp+h);
X	off++;
X    }
X}
X
Xvoid
Xshadow_rev_rect(xp, yp, w, h, thick)
Xint xp, yp, w, h, thick;
X{
X    int off = 0;
X
X    w--, h--;
X    xp -= thick; yp -= thick;
X    w += thick*2; h += thick*2;
X    while (thick--) {
X	XSetForeground(disp, gc, cols[COL_DARKGRAY].pixel);
X	XDrawLine(disp, win, gc,
X	    xp, yp+off, xp+w-off, yp+off);
X	XDrawLine(disp, win, gc,
X	    xp+off, yp, xp+off, yp+h-off);
X	XSetForeground(disp, gc, cols[COL_WHITE].pixel);
X	XDrawLine(disp, win, gc,
X	    xp+off, yp+h-off, xp+w, yp+h-off);
X	XDrawLine(disp, win, gc,
X	    xp+w-off, yp+off, xp+w-off, yp+h);
X	off++;
X    }
X}
X
Xvoid
Xdraw_button(xp, yp)
Xint xp, yp;
X{
X    xp = xp*GSPACEX+SIDEMARGIN;
X    yp = yp*GSPACEY+TOPMARGIN;
X    shadow_rect(xp, yp, GSPACEX, GSPACEY, 2);
X}
X
Xvoid
Xdraw_blank_square(xp, yp, clr)
Xint xp, yp, clr;
X{
X    xp = xp*GSPACEX+SIDEMARGIN;
X    yp = yp*GSPACEY+TOPMARGIN;
X    if (clr)
X	XClearArea(disp, win,
X	    xp, yp, GSPACEX, GSPACEY, False);
X    XSetForeground(disp, gc, cols[COL_DARKGRAY].pixel);
X    XDrawLine(disp, win, gc,
X	xp, yp, xp+GSPACEX-1, yp);
X    XDrawLine(disp, win, gc,
X	xp, yp, xp, yp+GSPACEY-1);
X}
X
Xvoid
Xdrawsquare(x, y)
Xint x, y;
X{
X    int xp, yp;
X    char buf[2];
X    int wid;
X    int color, yoffset = 0;
X
X    if (x < 0 || y < 0 || x >= gsizex || y >= gsizey) return;
X    buf[1] = 0;
X    xp = x*GSPACEX+SIDEMARGIN;
X    yp = y*GSPACEY+TOPMARGIN;
X    if (gridview[x][y] == UNCOVERED) {
X	draw_blank_square(x, y, False);
X	if (!grid[x][y]) return;
X	if (grid[x][y] == MINE) {
X	    buf[0] = 'M';
X	    color = COL_BLACK;
X	} else {
X	    color = numcols[grid[x][y]-1];
X	    buf[0] = grid[x][y]+'0';
X	    yoffset = 2;
X	}
X    } else if (gridview[x][y] == MARKED) {
X	draw_button(x, y);
X	buf[0] = 'X';
X	color = COL_RED;
X    } else if (gridview[x][y] == QUESTIONED) {
X	draw_button(x, y);
X	buf[0] = '?';
X	color = COL_RED;
X    } else {
X	draw_button(x, y);
X	return;
X    }
X
X    wid = XTextWidth(font_info, buf, 1);
X    XSetForeground(disp, gc, cols[color].pixel);
X    XDrawString(disp, win, gc,
X	xp+(GSPACEX-wid)/2,
X	yp+(GSPACEY+font_info->ascent-font_info->descent)/2+yoffset,
X	buf, 1);
X}
X
Xvoid
Xlayout_board(fx, fy)
Xint fx, fy;
X{
X    int i, x, y, xd, yd, tries;
X
X    srand((unsigned int) time(0));
X    for (i = 0; i != mine_count; i++) {
X	tries = 1000;
X	do {
X	    x = (rand()>>1) % gsizex;
X	    y = (rand()>>1) % gsizey;
X	    tries--;
X	} while (tries && (grid[x][y] ||
X		     !(x < fx-1 || x > fx+1 || y < fy-1 || y > fy+1)));
X	grid[x][y] = MINE;
X	if (!tries) {
X	    mine_count = i;
X	    break;
X	}
X    }
X    for (x = 0; x != gsizex; x++)
X	for (y = 0; y != gsizey; y++) {
X	    if (grid[x][y] == MINE) continue;
X	    i = 0;
X	    for (xd = -1; xd <= 1; xd++)
X		for (yd = -1; yd <= 1; yd++)
X		    if (hasmine(x+xd, y+yd)) i++;
X	    grid[x][y] = i;
X	}
X    layed_out = 1;
X    if (timer_id)
X	XtRemoveTimeOut(timer_id);
X    timer_id = XtAppAddTimeOut(app, 1000L, (void_proc) timer_callback, NULL);
X    covered_count = gsizex*gsizey;
X    fix_size();
X}
X
Xvoid
Xtimer_callback()
X{
X    if (!(layed_out && game_on)) {
X	timer_id = 0;
X	return;
X    }
X    if (timer >= 999) return;
X    draw_digits(++timer, 1);
X    timer_id = XtAppAddTimeOut(app, 1000L, (void_proc) timer_callback, NULL);
X}
X
Xint
Xhasmine(x, y)
Xint x, y;
X{
X    if (x < 0 || y < 0 || x >= gsizex || y >= gsizey) return False;
X    return grid[x][y] == MINE;
X}
X
Xint
Xis_state(x, y, state)
Xint x, y, state;
X{
X    if (x < 0 || y < 0 || x >= gsizex || y >= gsizey) return False;
X    return gridview[x][y] == state;
X}
X
Xint
Xiscovered(x, y)
Xint x, y;
X{
X    if (x < 0 || y < 0 || x >= gsizex || y >= gsizey) return False;
X    return gridview[x][y] == COVERED;
X}
X
Xvoid
Xuncover(x, y)
Xint x, y;
X{
X    int dx, dy;
X
X    if (x < 0 || y < 0 || x >= gsizex || y >= gsizey) return;
X    if (gridview[x][y] != COVERED) return;
X    gridview[x][y] = UNCOVERED;
X    covered_count--;
X    if (grid[x][y] == MINE)
X	boom();
X    else if (covered_count == mine_count)
X	winner();
X    redrawsquare(x, y);
X    if (grid[x][y] == 0)
X	for (dx = -1; dx <= 1; dx++)
X	    for (dy = -1; dy <= 1; dy++)
X		uncover(x+dx, y+dy);
X}
X
Xvoid
Xboom()
X{
X    int x, y;
X
X    for (x = 0; x != gsizex; x++)
X	for (y = 0; y != gsizey; y++) {
X	    if (grid[x][y] != MINE || gridview[x][y] == MARKED) continue;
X	    gridview[x][y] = UNCOVERED;
X	    redrawsquare(x, y);
X	}
X    game_on = 0;
X    relax_size();
X    set_face(FACE_DEAD);
X}
X
Xvoid
Xwinner()
X{
X    int x, y;
X
X    game_on = 0;
X    relax_size();
X    for (x = 0; x != gsizex; x++)
X	for (y = 0; y != gsizey; y++)
X	    if (gridview[x][y] == COVERED) {
X		gridview[x][y] = MARKED;
X		redrawsquare(x, y);
X	    }
X    draw_digits(0, 0);
X    set_face(FACE_COOL);
X    XtAppAddTimeOut(app, 500L, (void_proc) new_best, (XtPointer) game_level);
X}
X
Xvoid
Xrestart()
X{
X    int x, y;
X
X    for (x = 0; x != gsizex; x++)
X	for (y = 0; y != gsizey; y++) {
X	    gridview[x][y] = COVERED;
X	    grid[x][y] = 0;
X	}
X    game_on = 1;
X    layed_out = 0;
X    relax_size();
X    if (drawarea) {
X	redraw_all();
X	set_face(FACE_HAPPY);
X    }
X    timer = marked_count = 0;
X}
X
Xvoid
Xclear_around(x, y)
Xint x, y;
X{
X    int dx, dy, ct = 0;
X
X    if (gridview[x][y] != UNCOVERED) return;
X    for (dx = -1; dx <= 1; dx++)
X	for (dy = -1; dy <= 1; dy++)
X	    if (is_state(x+dx, y+dy, MARKED)) ct++;
X    if (grid[x][y] != ct) return;
X    for (dx = -1; dx <= 1; dx++)
X	for (dy = -1; dy <= 1; dy++)
X	    if (is_state(x+dx, y+dy, COVERED)) uncover(x+dx, y+dy);
X}
X
XXmString
Xgenxmstr(str)
Xchar *str;
X{
X    static XmString oldstr;
X
X    if (oldstr) XmStringFree(oldstr);
X    return oldstr = XmStringLtoRCreate(str, XmSTRING_DEFAULT_CHARSET);
X}
X
Xvoid
Xdraw_hwedge(x, y, dir)
Xint x, y, dir;
X{
X    int i;
X
X    for (i = 0; i <= 2; i++, y += dir)
X	XDrawLine(disp, win, gc, x+i, y, x+DIGIT_HWEDGE_WIDTH-(i+1), y);
X}
X
Xvoid
Xdraw_midwedge(x, y)
Xint x, y;
X{
X
X    XDrawLine(disp, win, gc, x, y, x+DIGIT_HWEDGE_WIDTH-1, y);
X    XDrawLine(disp, win, gc, x+1, y+1, x+DIGIT_HWEDGE_WIDTH-2, y+1);
X    XDrawLine(disp, win, gc, x+1, y-1, x+DIGIT_HWEDGE_WIDTH-2, y-1);
X}
X
Xvoid
Xdraw_vwedge(x, y, dir)
Xint x, y, dir;
X{
X    int i;
X
X    for (i = 0; i <= 2; i++, x += dir)
X	XDrawLine(disp, win, gc, x, y+i, x, y+DIGIT_VWEDGE_HEIGHT-(i+1));
X}
X
Xvoid
Xdraw_digit(val, num, which)
Xint val, num, which;
X{
X    int x, y;
X    static int segs[11] = {
X	127-2, 32+64, 127-(8+64),
X	127-(8+16), 8+32+2+64, 127-(32+16),
X	127-32, 1+32+64, 127,
X	127-16, 2
X    };
X    int seg = segs[val];
X
X    x = !which ? DIGIT_X_OFFSET :
X	      	TOTAL_WIDTH-(DIGIT_X_OFFSET+DIGIT_COUNT*DIGIT_WIDTH);
X    x += num*DIGIT_WIDTH+DIGIT_MARGIN;
X    y = DIGIT_Y_OFFSET+DIGIT_MARGIN+1;
X    XSetForeground(disp, gc, cols[(seg & 1) ? COL_RED : COL_DARKRED].pixel);
X    draw_hwedge(x+1, y, 1);
X    XSetForeground(disp, gc, cols[(seg & 2) ? COL_RED : COL_DARKRED].pixel);
X    draw_midwedge(x+1, y+1+DIGIT_VWEDGE_HEIGHT);
X    XSetForeground(disp, gc, cols[(seg & 4) ? COL_RED : COL_DARKRED].pixel);
X    draw_hwedge(x+1, y+(1+DIGIT_VWEDGE_HEIGHT)*2, -1);
X    XSetForeground(disp, gc, cols[(seg & 8) ? COL_RED : COL_DARKRED].pixel);
X    draw_vwedge(x, y+1, 1);
X    XSetForeground(disp, gc, cols[(seg & 16) ? COL_RED : COL_DARKRED].pixel);
X    draw_vwedge(x, y+2+DIGIT_VWEDGE_HEIGHT, 1);
X    XSetForeground(disp, gc, cols[(seg & 32) ? COL_RED : COL_DARKRED].pixel);
X    draw_vwedge(x+1+DIGIT_HWEDGE_WIDTH, y+1, -1);
X    XSetForeground(disp, gc, cols[(seg & 64) ? COL_RED : COL_DARKRED].pixel);
X    draw_vwedge(x+1+DIGIT_HWEDGE_WIDTH, y+2+DIGIT_VWEDGE_HEIGHT, -1);
X}
X
Xvoid
Xdraw_digits(val, which)
Xint val, which;
X{
X    XSetForeground(disp, gc, cols[COL_BLACK].pixel);
X    XFillRectangle(disp, win, gc,
X	!which ? DIGIT_X_OFFSET :
X	      	 TOTAL_WIDTH-(DIGIT_X_OFFSET+DIGIT_COUNT*DIGIT_WIDTH),
X	DIGIT_Y_OFFSET,
X	DIGIT_WIDTH * DIGIT_COUNT, DIGIT_HEIGHT);
X    XSetForeground(disp, gc, cols[COL_RED].pixel);
X    if (val < 0) {
X	draw_digit(10, 0, which);
X	val = -val;
X    } else
X	draw_digit((val/100)%10, 0, which);
X    draw_digit((val/10)%10, 1, which);
X    draw_digit(val%10, 2, which);
X}
X
Xvoid
Xset_level(w, level)
XWidget w;
Xint level;
X{
X    int i;
X
X    if (level == 1) {
X	mine_count = 10;
X	gsizex = gsizey = 8;
X    } else if (level == 2) {
X	mine_count = 40;
X	gsizex = gsizey = 16;
X    } else if (level == 3) {
X	mine_count = 99;
X	gsizex = 30;
X	gsizey = 16;
X    }
X    game_level = level-1;
X    if (!drawarea) return;
X    for (i = 0; i != XtNumber(level_buttons); i++)
X	if (i != level-1)
X	    XmToggleButtonSetState(level_buttons[i], False, False);
X    XtVaSetValues(toplevel, XmNallowShellResize, True, NULL);
X    XtVaSetValues(drawarea,
X        XmNwidth,        GSPACEX*gsizex+SIDEMARGIN*2,
X        XmNheight,       GSPACEY*gsizey+TOPMARGIN+BOTMARGIN,
X	NULL);
X    XtVaSetValues(toplevel, XmNallowShellResize, False, NULL);
X    redraw_entire();
X    restart();
X}
X
Xvoid
Xtog_question()
X{
X    questions_allowed ^= 1;
X}
X
Xint dialog_up;
X
Xvoid
Xset_custom()
X{
X    Widget custom, pane, w, rc, rc2, mine_w, height_w, width_w;
X    char buf[20];
X
X    custom = XtVaCreatePopupShell("Custom",
X	topLevelShellWidgetClass, toplevel,
X	XmNdeleteResponse, XmDESTROY,
X	XmNdialogStyle,    XmDIALOG_FULL_APPLICATION_MODAL,
X	NULL);
X    pane = XtVaCreateWidget(NULL, xmPanedWindowWidgetClass, custom,
X	XmNsashHeight, 1,
X	XmNsashWidth,  1,
X	NULL);
X    rc2 = XtVaCreateManagedWidget(NULL,
X	xmRowColumnWidgetClass, pane,
X	NULL);
X    rc = XtVaCreateManagedWidget(NULL,
X	xmRowColumnWidgetClass, rc2,
X	XmNorientation, XmHORIZONTAL,
X	NULL);
X    XtVaCreateManagedWidget("height_label",
X	xmLabelGadgetClass, rc,
X	NULL);
X    sprintf(buf, "%d", gsizey);
X    height_w = XtVaCreateManagedWidget("height_text",
X	xmTextFieldWidgetClass, rc,
X	XmNvalue,		buf,
X	NULL);
X    rc = XtVaCreateManagedWidget(NULL,
X	xmRowColumnWidgetClass, rc2,
X	XmNorientation, XmHORIZONTAL,
X	NULL);
X    XtVaCreateManagedWidget("width_label",
X	xmLabelGadgetClass, rc,
X	NULL);
X    sprintf(buf, "%d", gsizex);
X    width_w = XtVaCreateManagedWidget("width_text",
X	xmTextFieldWidgetClass, rc,
X	XmNvalue,		buf,
X	NULL);
X    rc = XtVaCreateManagedWidget(NULL,
X	xmRowColumnWidgetClass, rc2,
X	XmNorientation, XmHORIZONTAL,
X	NULL);
X    XtVaCreateManagedWidget("mines_label",
X	xmLabelGadgetClass, rc,
X	NULL);
X    sprintf(buf, "%d", mine_count);
X    mine_w = XtVaCreateManagedWidget("mines_text",
X	xmTextFieldWidgetClass, rc,
X	XmNvalue,		buf,
X	NULL);
X    rc2 = XtVaCreateManagedWidget(NULL,
X	xmFormWidgetClass, pane,
X	NULL);
X    w = XtVaCreateManagedWidget("ok",
X	xmPushButtonWidgetClass, rc2,
X	XmNleftAttachment, XmATTACH_POSITION,
X	XmNrightAttachment,XmATTACH_POSITION,
X	XmNleftPosition,   30,
X	XmNrightPosition,  70,
X	NULL);
X    XtAddCallback(w, XmNactivateCallback, (void_proc) dialog_ok, NULL);
X    XtManageChild(pane);
X    XtPopup(custom, XtGrabExclusive);
X    dialog_up = True;
X    while (dialog_up) {
X	XtAppProcessEvent(app, XtIMAll);
X	XSync(disp, 0);
X    }
X    XtPopdown(custom);
X    get_text_int(width_w, &gsizex);
X    if (gsizex > 100) gsizex = 100;
X    if (gsizex < 8) gsizex = 8;
X    get_text_int(height_w, &gsizey);
X    if (gsizey > 100) gsizey = 100;
X    if (gsizey < 8) gsizey = 8;
X    get_text_int(mine_w, &mine_count);
X    if (mine_count < 1) mine_count = 1;
X    set_level((Widget) 0, 4);
X}
X
Xvoid
Xdialog_ok()
X{
X    dialog_up = False;
X}
X
Xvoid
Xget_text_int(w, val)
XWidget w;
Xint *val;
X{
X    char *str;
X
X    str = XmTextFieldGetString(w);
X    if (!str) return;
X    if (atoi(str)) *val = atoi(str);
X    XtFree(str);
X}
X
Xvoid
Xbest_times()
X{
X    Widget custom, pane, w, rc2, ok_w;
X    Widget matrix[9];
X    char buf[20];
X    struct scores *sc;
X
X    sc = get_scores();
X    custom = XtVaCreatePopupShell("Best",
X	topLevelShellWidgetClass, toplevel,
X	XmNdeleteResponse, XmDESTROY,
X	XmNdialogStyle,    XmDIALOG_FULL_APPLICATION_MODAL,
X	NULL);
X    pane = XtVaCreateWidget(NULL, xmPanedWindowWidgetClass, custom,
X	XmNsashHeight, 1,
X	XmNsashWidth,  1,
X	NULL);
X    XtVaCreateManagedWidget("label",
X	xmLabelGadgetClass, pane,
X	NULL);
X    rc2 = XtVaCreateManagedWidget(NULL,
X	xmFormWidgetClass, pane,
X	NULL);
X    matrix[0] = XtVaCreateManagedWidget("begin_label",
X	xmLabelGadgetClass, rc2,
X	XmNtopAttachment, XmATTACH_FORM,
X	XmNleftAttachment, XmATTACH_FORM,
X	NULL);
X    sprintf(buf, "%d", sc->times[0]);
X    matrix[1] = XtVaCreateManagedWidget("begin_time",
X	xmLabelGadgetClass, rc2,
X	XmNtopAttachment,   XmATTACH_FORM,
X	XmNleftAttachment,  XmATTACH_OPPOSITE_WIDGET,
X	XmNlabelString,	    genxmstr(buf),
X	XmNalignment,	   XmALIGNMENT_BEGINNING,
X	NULL);
X    matrix[2] = XtVaCreateManagedWidget("begin_name",
X	xmLabelGadgetClass, rc2,
X	XmNtopAttachment,   XmATTACH_FORM,
X	XmNleftAttachment,  XmATTACH_WIDGET,
X	XmNleftWidget,	    matrix[1],
X	XmNrightAttachment, XmATTACH_FORM,
X	XmNlabelString,	    genxmstr(sc->names[0]),
X	XmNleftOffset,	    20,
X	XmNalignment,	   XmALIGNMENT_BEGINNING,
X	NULL);
X    matrix[3] = XtVaCreateManagedWidget("inter_label",
X	xmLabelGadgetClass, rc2,
X	XmNtopAttachment,   XmATTACH_WIDGET,
X	XmNtopWidget,	    matrix[0],
X	XmNleftAttachment,  XmATTACH_FORM,
X	NULL);
X    sprintf(buf, "%d", sc->times[1]);
X    matrix[4] = XtVaCreateManagedWidget("inter_time",
X	xmLabelGadgetClass, rc2,
X	XmNtopAttachment,   XmATTACH_WIDGET,
X	XmNtopWidget,	    matrix[0],
X	XmNleftAttachment,  XmATTACH_WIDGET,
X	XmNleftWidget,	    matrix[3],
X	XmNleftOffset,	    20,
X	XmNlabelString,	    genxmstr(buf),
X	XmNalignment,	   XmALIGNMENT_BEGINNING,
X	NULL);
X    XtVaSetValues(matrix[1], XmNleftWidget, matrix[4], NULL);
X    matrix[5] = XtVaCreateManagedWidget("inter_name",
X	xmLabelGadgetClass, rc2,
X	XmNtopAttachment,   XmATTACH_WIDGET,
X	XmNtopWidget,	    matrix[2],
X	XmNleftAttachment,  XmATTACH_OPPOSITE_WIDGET,
X	XmNleftWidget,	    matrix[2],
X	XmNrightAttachment, XmATTACH_FORM,
X	XmNlabelString,	    genxmstr(sc->names[1]),
X	XmNalignment,	   XmALIGNMENT_BEGINNING,
X	NULL);
X    matrix[6] = XtVaCreateManagedWidget("expert_label",
X	xmLabelGadgetClass, rc2,
X	XmNtopAttachment,   XmATTACH_WIDGET,
X	XmNtopWidget,	    matrix[3],
X	XmNleftAttachment,  XmATTACH_FORM,
X	XmNbottomAttachment,XmATTACH_FORM,
X	NULL);
X    sprintf(buf, "%d", sc->times[2]);
X    matrix[7] = XtVaCreateManagedWidget("expert_time",
X	xmLabelGadgetClass, rc2,
X	XmNtopAttachment,   XmATTACH_WIDGET,
X	XmNtopWidget,	    matrix[4],
X	XmNleftAttachment,  XmATTACH_OPPOSITE_WIDGET,
X	XmNleftWidget,	    matrix[4],
X	XmNbottomAttachment,XmATTACH_FORM,
X	XmNlabelString,	    genxmstr(buf),
X	XmNalignment,	   XmALIGNMENT_BEGINNING,
X	NULL);
X    matrix[8] = XtVaCreateManagedWidget("expert_name",
X	xmLabelGadgetClass, rc2,
X	XmNtopAttachment,   XmATTACH_WIDGET,
X	XmNtopWidget,	    matrix[5],
X	XmNleftAttachment,  XmATTACH_OPPOSITE_WIDGET,
X	XmNleftWidget,	    matrix[5],
X	XmNrightAttachment, XmATTACH_FORM,
X	XmNbottomAttachment,XmATTACH_FORM,
X	XmNlabelString,	    genxmstr(sc->names[2]),
X	XmNalignment,	   XmALIGNMENT_BEGINNING,
X	NULL);
X    rc2 = XtVaCreateManagedWidget(NULL,
X	xmFormWidgetClass, pane,
X	NULL);
X    ok_w = XtVaCreateManagedWidget("ok",
X	xmPushButtonWidgetClass, rc2,
X	XmNleftAttachment, XmATTACH_POSITION,
X	XmNrightAttachment,XmATTACH_POSITION,
X	XmNleftPosition,   0,
X	XmNrightPosition,  50,
X	NULL);
X    XtAddCallback(ok_w, XmNactivateCallback, (void_proc) dialog_ok, NULL);
X    w = XtVaCreateManagedWidget("clear",
X	xmPushButtonWidgetClass, rc2,
X	XmNleftAttachment, XmATTACH_POSITION,
X	XmNrightAttachment,XmATTACH_POSITION,
X	XmNleftPosition,   50,
X	XmNrightPosition,  100,
X	NULL);
X    XtAddCallback(w, XmNactivateCallback, (void_proc) clear_scores, NULL);
X    if (cant_write_score_file()) XtSetSensitive(w, False);
X    XtManageChild(pane);
X    XtPopup(custom, XtGrabExclusive);
X    XmProcessTraversal(ok_w, XmTRAVERSE_CURRENT);
X    dialog_up = True;
X    while (dialog_up) {
X	XtAppProcessEvent(app, XtIMAll);
X	XSync(disp, 0);
X    }
X    XtPopdown(custom);
X
X}
X
Xvoid
Xabout()
X{
X    Widget custom, pane, w, rc2;
X    char buf[100];
X
X    custom = XtVaCreatePopupShell("About",
X	topLevelShellWidgetClass, toplevel,
X	XmNdeleteResponse, XmDESTROY,
X	XmNdialogStyle,    XmDIALOG_FULL_APPLICATION_MODAL,
X	NULL);
X    pane = XtVaCreateWidget(NULL, xmPanedWindowWidgetClass, custom,
X	XmNsashHeight, 1,
X	XmNsashWidth,  1,
X	NULL);
X    sprintf(buf, "xmine 1.0.%d by Paul Falstad", PATCHLEVEL);
X    XtVaCreateManagedWidget("label",
X	xmLabelGadgetClass, pane,
X	XmNlabelString,     genxmstr(buf),
X	NULL);
X    rc2 = XtVaCreateManagedWidget(NULL,
X	xmFormWidgetClass, pane,
X	NULL);
X    w = XtVaCreateManagedWidget("ok",
X	xmPushButtonWidgetClass, rc2,
X	XmNleftAttachment, XmATTACH_POSITION,
X	XmNrightAttachment,XmATTACH_POSITION,
X	XmNleftPosition,   30,
X	XmNrightPosition,  70,
X	NULL);
X    XtAddCallback(w, XmNactivateCallback, (void_proc) dialog_ok, NULL);
X    XtManageChild(pane);
X    XtPopup(custom, XtGrabExclusive);
X    XmProcessTraversal(w, XmTRAVERSE_CURRENT);
X    dialog_up = True;
X    while (dialog_up) {
X	XtAppProcessEvent(app, XtIMAll);
X	XSync(disp, 0);
X    }
X    XtPopdown(custom);
X}
X
Xvoid
Xget_score_file_name(buf)
Xchar *buf;
X{
X    if (*SCORE_FILE == '~' && getenv("HOME"))
X	sprintf(buf, "%s%s", getenv("HOME"), SCORE_FILE+1);
X    else
X	strcpy(buf, SCORE_FILE);
X}
X
Xstruct scores *
Xget_scores()
X{
X    static struct scores sc;
X    char buf[1000];
X    int i, score;
X    FILE *in;
X
X    for (i = 0; i != 3; i++) {
X	strcpy(sc.names[i], "Anonymous");
X	sc.times[i] = 999;
X    }
X    get_score_file_name(buf);
X    if (in = fopen(buf, "r")) {
X	while (fscanf(in, "%d %d \"%[^\"]\"", &i, &score, buf) == 3) {
X	    if (i < 0 || i > 2) break;
X	    strcpy(sc.names[i], buf);
X	    sc.times[i] = score;
X	}
X	fclose(in);
X    }
X    return &sc;
X}
X
Xvoid
Xwrite_scores(sc)
Xstruct scores *sc;
X{
X    int i;
X    char buf[1000];
X    FILE *out;
X
X    get_score_file_name(buf);
X    if (!(out = fopen(buf, "w")))
X	return;
X    for (i = 0; i != 3; i++)
X	if (sc->times[i] != 999)
X	    fprintf(out, "%d %d \"%s\"\n", i, sc->times[i], sc->names[i]);
X    fclose(out);
X}
X
Xvoid
Xnew_best(level)
Xint level;
X{
X    Widget custom, pane, rc2, name_w, w;
X    char *str;
X    struct scores *sc;
X
X    if (level < 0 || level >= 3) return;
X    sc = get_scores();
X    if (timer >= sc->times[level]) return;
X    custom = XtVaCreatePopupShell("HighScorer",
X	topLevelShellWidgetClass, toplevel,
X	XmNdeleteResponse, XmDESTROY,
X	XmNdialogStyle,    XmDIALOG_FULL_APPLICATION_MODAL,
X	NULL);
X    pane = XtVaCreateWidget(NULL, xmPanedWindowWidgetClass, custom,
X	XmNsashHeight, 1,
X	XmNsashWidth,  1,
X	NULL);
X    XtVaCreateManagedWidget("label",
X	xmLabelGadgetClass, pane,
X	NULL);
X    name_w = XtVaCreateManagedWidget("name",
X	xmTextFieldWidgetClass, pane, NULL);
X    XtAddCallback(name_w, XmNactivateCallback, (void_proc) dialog_ok, NULL);
X    rc2 = XtVaCreateManagedWidget(NULL,
X	xmFormWidgetClass, pane,
X	NULL);
X    w = XtVaCreateManagedWidget("ok",
X	xmPushButtonWidgetClass, rc2,
X	XmNleftAttachment, XmATTACH_POSITION,
X	XmNrightAttachment,XmATTACH_POSITION,
X	XmNleftPosition,   30,
X	XmNrightPosition,  70,
X	NULL);
X    XtAddCallback(w, XmNactivateCallback, (void_proc) dialog_ok, NULL);
X    XtManageChild(pane);
X    XtPopup(custom, XtGrabExclusive);
X    XmTextFieldSetSelection(name_w, 0, XmTextFieldGetLastPosition(name_w),
XCurrentTime);
X    XmProcessTraversal(name_w, XmTRAVERSE_CURRENT);
X    dialog_up = True;
X    while (dialog_up) {
X	XtAppProcessEvent(app, XtIMAll);
X	XSync(disp, 0);
X    }
X    XtPopdown(custom);
X    str = XmTextFieldGetString(name_w);
X    if (str && *str) {
X	strcpy(sc->names[level], str);
X	sc->times[level] = timer;
X	write_scores(sc);
X    }
X    if (str) XtFree(str);
X    best_times();
X}
X
Xvoid
Xclear_scores()
X{
X    char buf[1000];
X    FILE *out;
X
X    dialog_up = False;
X    get_score_file_name(buf);
X    if (out = fopen(buf, "w")) fclose(out);
X}
X
Xint
Xcant_write_score_file()
X{
X    return geteuid() != getuid();
X}
X
Xvoid
Xfix_size()
X{
X    XSizeHints hints;
X    Dimension wid, hgt;
X
X    XtVaGetValues(toplevel,
X	XmNwidth, &wid,
X	XmNheight, &hgt,
X	NULL);
X    hints.flags = PMaxSize|PMinSize;
X    hints.max_width = hints.min_width = wid;
X    hints.max_height = hints.min_height = hgt;
X    XSetWMNormalHints(disp, XtWindow(toplevel), &hints);
X}
X
Xvoid
Xrelax_size()
X{
X    XSizeHints hints;
X    Dimension wid, hgt, menu_hgt;
X
X    XtVaGetValues(toplevel,
X	XmNwidth, &wid,
X	XmNheight, &hgt,
X	NULL);
X    hints.flags = PMaxSize|PMinSize|PResizeInc;
X    XtVaGetValues(menubar,
X	XmNheight, &menu_hgt,
X	NULL);
X    hints.min_width = SIDEMARGIN*2+GSPACEX*INITIAL_SIZE_X;
X    hints.min_height = TOPMARGIN+BOTMARGIN+menu_hgt+GSPACEY*INITIAL_SIZE_Y;
X    hints.max_width = hints.max_height = 10000;
X    hints.width_inc = GSPACEX;
X    hints.height_inc = GSPACEY;
X    XSetWMNormalHints(disp, XtWindow(toplevel), &hints);
X}
X
Xvoid
Xresize_handler(w, data, event, contflag)
XWidget w;
XXtPointer data;
XXEvent *event;
XBoolean *contflag;
X{
X    int new_gsizex, new_gsizey;
X    static int started = 0;
X    Dimension menu_hgt;
X
X    if (!started) {
X	relax_size();
X	started = 1;
X    }
X    if (event->type != ConfigureNotify) return;
X    if (layed_out && game_on) return;
X    XtVaGetValues(menubar,
X	XmNheight, &menu_hgt,
X	NULL);
X    new_gsizex = (event->xconfigure.width-SIDEMARGIN*2)/GSPACEX;
X    new_gsizey = (event->xconfigure.height-
X		      (menu_hgt+TOPMARGIN+BOTMARGIN))/GSPACEY;
X    if (new_gsizex > MAX_GSIZEX)
X	new_gsizex = MAX_GSIZEX;
X    if (new_gsizey > MAX_GSIZEY)
X	new_gsizey = MAX_GSIZEY;
X    if (new_gsizex != gsizex || new_gsizey != gsizey) {
X	gsizex = new_gsizex;
X	gsizey = new_gsizey;
X	set_level(w, 4);
X    }
X}
END_OF_FILE
  if test 37268 -ne `wc -c <'xmine.c'`; then
    echo shar: \"'xmine.c'\" unpacked with wrong size!
  fi
  # end of 'xmine.c'
fi
echo shar: End of archive 1 \(of 1\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have the archive.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga: The only way to fly!  |    sources-x@sterling.com
       "It's intuitively obvious to the most casual observer..."
 GCS d++(--) -p+ c++ !l u++ e+ m+(-) s++/++ n h--- f+ g+++ w+ t++ r+ y+
