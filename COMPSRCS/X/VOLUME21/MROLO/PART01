Newsgroups: comp.sources.x
From: gregor@kafka.saic.com (gregg hanna)
Subject: v21i008:  mrolo - Motif rolodex, Part01/03
Message-ID: <csx-v21i008=mrolo.201846@sparky.Sterling.COM>
X-Md4-Signature: e5ab836653c06d768fbd3b9640552635
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Sat, 9 Oct 1993 01:19:16 GMT
Approved: chris@sterling.com

Submitted-by: gregor@kafka.saic.com (gregg hanna)
Posting-number: Volume 21, Issue 8
Archive-name: mrolo/part01
Environment: X11, OSF/Motif
Supersedes: mrolo: Volume 20, Issue 96-97

*Rolo is a set of card file database programs designed to be
simple yet robust, and was born out of frustration with
xrolo's and xrolodex's many menus.  The main program is
mrolo, the Motif based card file program, and there is also
crolo, the curses based equivalent.

Some features of mrolo/crolo:

  o From the main screen you see a list of all cards and
    may scroll through them viewing/editing cards as desired.

  o You may jump to a section of the card file by clicking on
    a lettered tab on the edge of the screen (A-Z) [mrolo] or
    typing the upper-case letter [crolo].

  o You can search cards quickly by simply entering text
    in a text field on the main screen.  (You can easily
    do a regular expression search, if you want, just
    start the text with a slash.)

  o There are no explicit save/load operations, the current
    display reflects the disk file's contents and changes
    are verified and written at the time of the change.

New in release 1.3:

  o Regular expression matching.
  o crolo, curses-based for dial-in use
  o Internationalization (see mrolo*indexElements resource).
  o Handles X parameters (like -iconic) correctly.
  o Windows behave better (they all iconify together, etc).
  o AS OF feature, keeps track of when a card was last updated.
  o Optionally constrain the filter to certain fields.
  o Various bug fixes, lots of clean-up, more portability.

The programs use a disk format identical to xrolo, so if you
use that it should be an easy switch.  See the manpages for
lots of details.

This software was developed on a Sun4 running SunOS 4.1.1.  It
should run on other systems, but it is not tested.  I'm
especially concerned about the portability of the regular
expression code, the curses code, and the time code.

If the curses code gives you trouble, just don't build crolo.
If the time code gives you trouble, define the NO_TIME symbol
(i.e. -DNO_TIME) and the "as of:" option will be compiled out.
(Right now, if you put "as of:" at the beginning of the line
in a card then *rolo will put the current date/time on that
line whenever the card is changed.) If the regular expression
code gives you trouble, compile with the flag -DDONT_REGEXP.
Also, contact me (gregor@kafka.saic.com) and I'll try to help
make it work on your system.

The package contains four programs:

	mrolo - the Motif cardfile program
	crolo - the curses cardfile program
	prolo - a program to print the cardfile
	xr2mr - a script to convert xrolodex files to
                mrolo/xrolo format

To compile the programs do as follows:

	xmkmf
	make

If you do not have xmkmf or imake, edit and use Makefile.std.
If you have problems with compiling crolo, you might need to
adjust the value of TERMLIBS.  (Some systems don't need
-ltermcap.)

To test it, you may want to uudecode and uncompress the file
sample.Z.uu, which is a 100 entry pseudo-random sample
file.  (The option "-f sample" overrides the default
~/.rolo file.)

Once you're happy that the applications work install with:

	make install

To install the man-pages:

	make install.man

Please send bug reports, feedback, and suggestions to
gregor@kafka.saic.com

Thanks to:
  Bill James and Kral Ferch, my in-house testers.
  David Koblas for AppDefault handling and new backup code.
  William Shubert for the new icon.
  Bruce Bowler for helping make it more VMS friendly.
  John Silva for helping make it more HP friendly.
  Brian Rice for helping make it more Ultrix friendly.
  The anonymous soul who wrote the arrows.c file, which I
     adapted for crolo.
  AT&T and Rich Salz and Jim for the PD getopt(3).
  Everyone who generously offered their suggestions.

Copyright 1993 by gregg hanna.  Permission is granted to use,
modify, and distribute this program.  Basically do anything
you want with it, but if you want to use it or any part of it
to make money you must get further permission from me.


#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 3)."
# Contents:  mrolo13 mrolo13/CHANGES mrolo13/Imakefile mrolo13/MANIFEST
#   mrolo13/MRolo.ad mrolo13/Makefile.std mrolo13/README mrolo13/ad2c
#   mrolo13/arrows.c mrolo13/arrows.h mrolo13/callback.c
#   mrolo13/compat.c mrolo13/compat.h mrolo13/crolo.man
#   mrolo13/getopt.c mrolo13/mrolo.bm mrolo13/mrolo.c
#   mrolo13/myregexp.h mrolo13/patchlevel.h mrolo13/prolo.man
#   mrolo13/rolo.h mrolo13/roloP.h mrolo13/roloc.c mrolo13/rolox.c
#   mrolo13/rolox.h mrolo13/xr2mr mrolo13/xr2mr.man
# Wrapped by gregor@kafka on Fri Sep  3 01:45:25 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test ! -d 'mrolo13' ; then
    echo shar: Creating directory \"'mrolo13'\"
    mkdir 'mrolo13'
fi
if test -f 'mrolo13/CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/CHANGES'\"
else
echo shar: Extracting \"'mrolo13/CHANGES'\" \(1562 characters\)
sed "s/^X//" >'mrolo13/CHANGES' <<'END_OF_FILE'
XVersion 1.2
X
X  Initial public release.
X
X
XVersion 1.3
X
X  Used dialogs instead of Application Shells to do card
X  info and confirmation windows.  Makes behavior more
X  appropriate.
X
X  Fixed bugs in reading input file to enhance xrolo
X  compatibility.
X
X  Modified Imakefile to make it more portable.
X
X  Kludged around old Motif ScrolledList bug that showed
X  just one list entry.
X
X  Fixed memory leak in OKCard.
X
X  Handle XmString tables differently, works under gcc.
X
X  Added mystrdup and mystrcasecmp to make it more
X  portable.
X
X  Added regular expression support.
X
X  Changed MRolo.ad to have better default fonts.  (They
X  were coming up as kanji for some people.)
X
X  Handles X arguments (like -iconic) correctly.
X
X  Added crolo to the distribution.
X
X  Changed index tabs to buttons for more intuitive use.
X
X  Made index tabs configurable to allow non-english
X  alphabets.
X
X  Modified the backup handling to only backup if changes
X  are made (koblas@netcom.com).
X
X  Setup fallback AppDefaults (koblas@netcom.com).
X
X  Added AS OF keyword, keeps track of last change to a card.
X
X  Added filter search limiting as an option.
X
X  Added portability features, consideration for VMS and Ultix (sort of),
X  consideration of non-X users building crolo (NO_X flag).
X
X  Added ifdefs to not do STANDOUT for crolo under SYSV, I had troubles
X  with the HP and Sun using SYSV curses.
X
X  Uses argv[0] as the app name, so if you put app-defaults for
X  different names and symlink the application you can get different
X  looks.  Especially useful for making non-phone rolo files.
END_OF_FILE
if test 1562 -ne `wc -c <'mrolo13/CHANGES'`; then
    echo shar: \"'mrolo13/CHANGES'\" unpacked with wrong size!
fi
# end of 'mrolo13/CHANGES'
fi
if test -f 'mrolo13/Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/Imakefile'\"
else
echo shar: Extracting \"'mrolo13/Imakefile'\" \(965 characters\)
sed "s/^X//" >'mrolo13/Imakefile' <<'END_OF_FILE'
XSRCS = callback.c creation.c mrolo.c rolo.c rolox.c compat.c getopt.c
XOBJS = callback.o creation.o mrolo.o rolo.o rolox.o compat.o getopt.o
XLDLIBS = -lXm $(SYSLIBS)
XTERMLIBS = -lcurses -ltermcap
X
XComplexProgramTarget(mrolo)
XInstallAppDefaults(MRolo)
X
Xall:: prolo crolo
X
Xprolo: prolo.c rolo.o compat.o getopt.o
X	$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) -o prolo prolo.c rolo.o compat.o getopt.o
X
Xcrolo: crolo.c rolo.o roloc.o arrows.o compat.o getopt.o
X	$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) -o crolo crolo.c rolo.o roloc.o arrows.o compat.o getopt.o $(TERMLIBS)
X
Xclean::
X	$(RM) prolo crolo rolo.samp- xdef MRolo.ad.h
X
XInstallProgram(crolo,$(BINDIR))
XInstallProgram(prolo,$(BINDIR))
XInstallProgram(xr2mr,$(BINDIR))
XInstallManPage(crolo,$(MANDIR))
XInstallManPage(prolo,$(MANDIR))
XInstallManPage(xr2mr,$(MANDIR))
X
Xxdef: MRolo.ad
X	sed -e '1,$$s/^#/!/g' -e '1,$$s/^*/mrolo*/g' MRolo.ad > xdef
X
XMRolo.ad.h: MRolo.ad
X      ./ad2c MRolo.ad > MRolo.ad.h
X
Xmrolo.o: MRolo.ad.h
END_OF_FILE
if test 965 -ne `wc -c <'mrolo13/Imakefile'`; then
    echo shar: \"'mrolo13/Imakefile'\" unpacked with wrong size!
fi
# end of 'mrolo13/Imakefile'
fi
if test -f 'mrolo13/MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/MANIFEST'\"
else
echo shar: Extracting \"'mrolo13/MANIFEST'\" \(1860 characters\)
sed "s/^X//" >'mrolo13/MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X CHANGES                    1		change file
X Imakefile                  1		template for imake
X MANIFEST                   1		this file
X MRolo.ad                   1		application defaults
X Makefile.std               1		non-imake makefile
X README                     1		read this first
X ad2c                       1		converts AD file to .h
X arrows.c                   1		handles arrows under BSD curses
X arrows.h                   1		handles arrows under BSD curses
X callback.c                 1		X callbacks for mrolo
X compat.c                   1		compatibility functions
X compat.h                   1		compatibility function headers
X creation.c                 3		X window creation for mrolo
X crolo.c                    1		curses rolo main program
X crolo.man                  1		curses rolo man page
X getopt.c                   1		portable getopt(3)
X mrolo.bm                   1		bitmap for mrolo
X mrolo.c                    1		Motif rolo main program
X mrolo.man                  2		Motif rolo man page
X myregexp.h                 1		portable regexp
X patchlevel.h               1		patchlevel file
X prolo.c                    2		rolo printer main program
X prolo.man                  1		rolo printer man page
X rolo.c                     2		rolo functions (used by *rolo)
X rolo.h                     1		headers for rolo functions
X sample.Z.uu                2		sample rolo file (compressed/uuencoded)
X roloP.h                    1		private header for rolo.c
X roloc.c                    1		curses rolo functions
X rolox.c                    1		X windows rolo functions
X rolox.h                    1		headers for X windows rolo functions
X xr2mr                      1		converter from xrolodex file to rolo file
X xr2mr.man                  1		manual page for converter
X
END_OF_FILE
if test 1860 -ne `wc -c <'mrolo13/MANIFEST'`; then
    echo shar: \"'mrolo13/MANIFEST'\" unpacked with wrong size!
fi
# end of 'mrolo13/MANIFEST'
fi
if test -f 'mrolo13/MRolo.ad' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/MRolo.ad'\"
else
echo shar: Extracting \"'mrolo13/MRolo.ad'\" \(1789 characters\)
sed "s/^X//" >'mrolo13/MRolo.ad' <<'END_OF_FILE'
X! fonts:  note that addressList ought to have a fixed width font
X*fontList: -*-helvetica-*-r-*-*-14-*-*-*-*-*-*-*
X*addressList*fontList: -misc-fixed-*-r-*-*-14-*-*-*-*-*-*-*
X
X! default size of the comment box on the card info screen
X*commentText.rows: 10
X*commentText.cols: 80
X
X! size of the filter text field
X*filterText.columns:	11
X
X! these control the way buttons look, if you change to
X! XmPACK_TIGHT you probably want to make resizeWidth False
X*XmRowColumn*packing:	XmPACK_COLUMN
X*rowColumn.resizeWidth:	True
X*rowColumn.width:	500
X
X! custom resources, shown here with default values
X*showSecondary:	True
X*sizePrimary:	20
X*selectFilter:	False
X
X! colors you *might* like
X*foreground:	black
X*background:	white
X*XmPushButton*foreground:	black
X*XmPushButton*background:	pink
X*XmText*foreground:	black
X*XmText*background:	alice blue
X*addressList*foreground:	black
X*addressList*background:	honeydew
X
X! labels
X*quitButton.labelString:	Quit
X*addCardButton.labelString:	Add Card
X*clearButton.labelString:	Clear Filter
X*deleteCardButton.labelString:	Delete Card
X*pickerButton.labelString:	Fields
X*okButton.labelString:		OK
X*cancelButton.labelString:	Cancel
X*primaryLabel.labelString:	Phone
X*secondaryLabel.labelString:	Phone #2
X*nameLabel.labelString:		Name
X*messageBox.okLabelString:	Yes
X*messageBox.cancelLabelString:	No
X*messageBox.helpLabelString:	Help
X
X! tranversals
X*quitButton.traversalOn:	True
X*addCardButton.traversalOn:	True
X*clearButton.traversalOn:	True
X
X! indexes on side of screen
Xmrolo*indexElements:		A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
X
X! default spacing
X*form.leftOffset:	2
X*form.rightOffset:	2
X*form.topOffset:	2
X*form.bottomOffset:	2
X
X! Toggle buttons, and thus filter settings.
X*tbutton0.set:	True
X*tbutton1.set:	True
X*tbutton2.set:	True
X*tbutton3.set:	True
END_OF_FILE
if test 1789 -ne `wc -c <'mrolo13/MRolo.ad'`; then
    echo shar: \"'mrolo13/MRolo.ad'\" unpacked with wrong size!
fi
# end of 'mrolo13/MRolo.ad'
fi
if test -f 'mrolo13/Makefile.std' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/Makefile.std'\"
else
echo shar: Extracting \"'mrolo13/Makefile.std'\" \(1854 characters\)
sed "s/^X//" >'mrolo13/Makefile.std' <<'END_OF_FILE'
X# Sun OS 4.1.* users:  it should work as is.
X# HP/UX users:  use -DUSE_REGCOMP -DSYSV, LDFLAGS and INCLUDES
X# everyone else:  read through the makefile
X
XRM = /bin/rm
XBINDIR = /usr/bin/X11
XAPPDIR = /usr/lib/X11/app-defaults
XMANDIR = /usr/man/mann
XMANEXT = n
XLDLIBS = -lXm -lXt -lX11
XTERMLIBS = -lcurses -ltermcap
X
X# uncomment one of the following
X#   USE_RE_COMP - if you have re_comp/re_exec
X#   USE_REGCOMP - if you have regcomp/regexec/regfree (POSIX)
X#   DONT_REGEXP - if you have don't have any
X#   nothing - if you have compile/step
X#REGEX = -DUSE_RE_COMP
X#REGEX = -DUSE_REGCOMP
X#REGEX = -DDONT_REGEXP
XREGEX =
X
X# uncomment the following if you don't have X and are just building crolo
X#XMODE = -DNO_X
X
X
X# SYSV controls how curses is handled.  If crolo doesn't
X# compile or works funny, try -DSYSV.
X#SYSV = -DSYSV
X#INCLUDES = -I /usr/include/X11R4 -I /usr/include/Motif1.1
XCFLAGS = -O -D_NO_PROTO $(REGEX) $(XMODE) $(SYSV) $(INCLUDES)
X
X#LDFLAGS = -L /usr/lib/X11R4 -L /usr/lib/Motif1.1
X
XLINK.c = $(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS)
X
Xall: mrolo prolo crolo
X
Xmrolo: callback.o creation.o mrolo.o rolo.o rolox.o compat.o getopt.o
X	$(LINK.c) -o mrolo mrolo.o rolo.o rolox.o creation.o callback.o compat.o getopt.o $(LDLIBS)
X
Xprolo: prolo.c rolo.o compat.o getopt.o
X	$(LINK.c) -o prolo prolo.c rolo.o compat.o getopt.o
X
Xcrolo: crolo.c rolo.o roloc.o compat.o arrows.o getopt.o
X	$(LINK.c) -o crolo crolo.c rolo.o roloc.o compat.o arrows.o getopt.o $(TERMLIBS)
X
XMRolo.ad.h: MRolo.ad
X	./ad2c MRolo.ad > MRolo.ad.h
X
Xmrolo.o: MRolo.ad.h
X
X
Xinstall: all
X	cp mrolo $(BINDIR)
X	cp prolo $(BINDIR)
X	cp xr2mr $(BINDIR)
X	chmod +x $(BINDIR)/xr2mr
X	cp MRolo.ad $(APPDIR)/MRolo
X
Xinstall.man:
X	cp mrolo.man $(MANDIR)/mrolo.$(MANEXT)
X	cp prolo.man $(MANDIR)/prolo.$(MANEXT)
X	cp xr2mr.man $(MANDIR)/xr2mr.$(MANEXT)
X
Xclean:
X	$(RM) *.o prolo mrolo crolo rolo.samp- xdef *~
END_OF_FILE
if test 1854 -ne `wc -c <'mrolo13/Makefile.std'`; then
    echo shar: \"'mrolo13/Makefile.std'\" unpacked with wrong size!
fi
# end of 'mrolo13/Makefile.std'
fi
if test -f 'mrolo13/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/README'\"
else
echo shar: Extracting \"'mrolo13/README'\" \(3912 characters\)
sed "s/^X//" >'mrolo13/README' <<'END_OF_FILE'
X*Rolo is a set of card file database programs designed to be
Xsimple yet robust, and was born out of frustration with
Xxrolo's and xrolodex's many menus.  The main program is
Xmrolo, the Motif based card file program, and there is also
Xcrolo, the curses based equivalent.
X
XSome features of mrolo/crolo:
X
X  o From the main screen you see a list of all cards and
X    may scroll through them viewing/editing cards as desired.
X
X  o You may jump to a section of the card file by clicking on
X    a lettered tab on the edge of the screen (A-Z) [mrolo] or
X    typing the upper-case letter [crolo].
X
X  o You can search cards quickly by simply entering text
X    in a text field on the main screen.  (You can easily
X    do a regular expression search, if you want, just
X    start the text with a slash.)
X
X  o There are no explicit save/load operations, the current
X    display reflects the disk file's contents and changes
X    are verified and written at the time of the change.
X
XNew in this release:
X
X  o Regular expression matching.
X  o crolo, curses-based for dial-in use
X  o Internationalization (see mrolo*indexElements resource).
X  o Handles X parameters (like -iconic) correctly.
X  o Windows behave better (they all iconify together, etc).
X  o AS OF feature, keeps track of when a card was last updated.
X  o Optionally constrain the filter to certain fields.
X  o Various bug fixes, lots of clean-up, more portability.
X
XThe programs use a disk format identical to xrolo, so if you
Xuse that it should be an easy switch.  See the manpages for
Xlots of details.
X
XThis software was developed on a Sun4 running SunOS 4.1.1.  It
Xshould run on other systems, but it is not tested.  I'm
Xespecially concerned about the portability of the regular
Xexpression code, the curses code, and the time code.
X
XIf the curses code gives you trouble, just don't build crolo.
XIf the time code gives you trouble, define the NO_TIME symbol
X(i.e. -DNO_TIME) and the "as of:" option will be compiled out.
X(Right now, if you put "as of:" at the beginning of the line
Xin a card then *rolo will put the current date/time on that
Xline whenever the card is changed.) If the regular expression
Xcode gives you trouble, compile with the flag -DDONT_REGEXP.
XAlso, contact me (gregor@kafka.saic.com) and I'll try to help
Xmake it work on your system.
X
XThe package contains four programs:
X
X	mrolo - the Motif cardfile program
X	crolo - the curses cardfile program
X	prolo - a program to print the cardfile
X	xr2mr - a script to convert xrolodex files to
X                mrolo/xrolo format
X
XTo compile the programs do as follows:
X
X	xmkmf
X	make
X
XIf you do not have xmkmf or imake, edit and use Makefile.std.
XIf you have problems with compiling crolo, you might need to
Xadjust the value of TERMLIBS.  (Some systems don't need
X-ltermcap.)
X
XTo test it, you may want to uudecode and uncompress the file
Xsample.Z.uu, which is a 100 entry pseudo-random sample
Xfile.  (The option "-f sample" overrides the default
X~/.rolo file.)
X
XOnce you're happy that the applications work install with:
X
X	make install
X
XTo install the man-pages:
X
X	make install.man
X
XPlease send bug reports, feedback, and suggestions to
Xgregor@kafka.saic.com
X
XThanks to:
X  Bill James and Kral Ferch, my in-house testers.
X  David Koblas for AppDefault handling and new backup code.
X  William Shubert for the new icon.
X  Bruce Bowler for helping make it more VMS friendly.
X  John Silva for helping make it more HP friendly.
X  Brian Rice for helping make it more Ultrix friendly.
X  The anonymous soul who wrote the arrows.c file, which I
X     adapted for crolo.
X  AT&T and Rich Salz and Jim for the PD getopt(3).
X  Everyone who generously offered their suggestions.
X
XCopyright 1993 by gregg hanna.  Permission is granted to use,
Xmodify, and distribute this program.  Basically do anything
Xyou want with it, but if you want to use it or any part of it
Xto make money you must get further permission from me.
X
END_OF_FILE
if test 3912 -ne `wc -c <'mrolo13/README'`; then
    echo shar: \"'mrolo13/README'\" unpacked with wrong size!
fi
# end of 'mrolo13/README'
fi
if test -f 'mrolo13/ad2c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/ad2c'\"
else
echo shar: Extracting \"'mrolo13/ad2c'\" \(882 characters\)
sed "s/^X//" >'mrolo13/ad2c' <<'END_OF_FILE'
X#!/bin/sh
X#
X#	ad2c : Convert app-defaults file to C strings decls.
X#
X#	George Ferguson, ferguson@cs.rcohester.edu, 12 Nov 1990.
X#	19 Mar 1991: gf
X#		Made it self-contained.
X#	6 Jan 1992: mycroft@gnu.ai.mit.edu (Charles Hannum)
X#		Removed use of "-n" and ":read" label since Gnu and
X#		IBM sed print pattern space on "n" command. Still works
X#		with Sun sed, of course.
X#	7 Jan 1992: matthew@sunpix.East.Sun.COM (Matthew Stier)
X#		Escape quotes after escaping backslashes.
X#	8 Jul 1992: Version 1.6
X#
X
Xsed '
X# remove comments
X/^!/d
X# remove blanks
X/^$/d
X# escape backslash
Xs/\\/\\\\/g
X# except the line continuation ones
Xs/\\$//g
X# escape quotes
Xs/"/\\"/g
X# add leading quote
Xs/^/"/
X#
X: test
X/\\$/b slash
Xs/$/",/
Xp
Xd
X#
X: slash
Xn
X# just like "read" only does not add leading quote
X/^!/d
X/^$/d
Xs/"/\\"/g
Xs/\\\\/\\/g
Xs/\\n/\\\\n/g
Xs/\\t/\\\\t/g
Xs/\\f/\\\\f/g
Xs/\\b/\\\\b/g
Xb test' "$@"
END_OF_FILE
if test 882 -ne `wc -c <'mrolo13/ad2c'`; then
    echo shar: \"'mrolo13/ad2c'\" unpacked with wrong size!
fi
chmod +x 'mrolo13/ad2c'
# end of 'mrolo13/ad2c'
fi
if test -f 'mrolo13/arrows.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/arrows.c'\"
else
echo shar: Extracting \"'mrolo13/arrows.c'\" \(3480 characters\)
sed "s/^X//" >'mrolo13/arrows.c' <<'END_OF_FILE'
X/*
X * this program demonstates one way to handle arrow escape sequences using
X * bsd curses.
X *
X *  to compile:  cc -o demo demo.c -lcurses -ltermcap
X *			
X */
X
X#include <curses.h>
X#include "arrows.h"
X
X#include <stdio.h>
X
Xextern char *getenv();
X
X/* array to hold arrow escape sequences */
Xchar 	arrow_table[4][80];
X
X
X/*
X * get arrow terminal capabilities for terminal from termcap file
X * curses uses the global variable ttytype to specify what it
X * thinks your terminal type is
X */
Xget_arrow_info()
X{
X
X	char buffer[1024];
X	char *bp;
X
X	tgetent(buffer,ttytype);
X
X	bp = arrow_table[MY_KEY_RIGHT];
X	tgetstr("kr",&bp);
X
X	bp = arrow_table[MY_KEY_LEFT];
X	tgetstr("kl",&bp);
X
X	bp = arrow_table[MY_KEY_UP];
X	tgetstr("ku",&bp);
X
X	bp = arrow_table[MY_KEY_DOWN];
X	tgetstr("kd",&bp);
X}
X
X
X/*
X * read in the escape sequence and compare it to what we got from
X * termcap entry.
X */
Xdo_escape(c)
X  int c;
X{
X	char buffer[8]; /* buffer to store entire escape sequence */
X	int size;	/* length of the escape sequence */
X	int  i;
X
X	/* we assume that all arrow sequences are the same length */
X	/* so we will just get the size of one of them.           */
X	size=strlen(arrow_table[MY_KEY_RIGHT]);
X
X	/* the first character was an escape */
X	buffer[0]=ESCAPE;
X
X	/* read in the rest of the escape sequence */
X	for(i=1;i<size;i++) {
X
X		buffer[i] = getch();
X
X		/* this hack takes care of vt100s which termcap specifies
X		 * as sending <esc>O[ABCD] but which sometimes send
X		 *  <esc>[[ABCD]
X		 */
X		if(i == 1) 
X		    if((buffer[i] == '[') && (arrow_table[MY_KEY_RIGHT][1] == 'O'))
X				buffer[i] = 'O';
X
X	}
X
X	/* add a null terminator to our escape sequence */
X	buffer[size] = '\0';
X
X	/* compare what we read in to what termcap says */
X	/* if we get a match, return the proper result  */
X        if(!strcmp(buffer,arrow_table[MY_KEY_RIGHT]))
X                return(MY_KEY_RIGHT);
X        else if(!strcmp(buffer,arrow_table[MY_KEY_LEFT]))
X                return(MY_KEY_LEFT);
X        else if(!strcmp(buffer,arrow_table[MY_KEY_UP]))
X                return(MY_KEY_UP);
X        else if(!strcmp(buffer,arrow_table[MY_KEY_DOWN]))
X                return(MY_KEY_DOWN);
X        else
X                return(ESCAPE);
X}
X
X#if 0
Xmain()
X{
X	WINDOW *screen;
X	int	x = 5, y = 5,  		/* location of our window */
X		len = 30, width = 10;	/* dimensions of our window */
X	char	c;
X
X	/* initialize curses and enter cbreak mode */
X	initscr();
X	noecho();
X	crmode();
X
X
X	/* read in our arrow termcap entries */
X	get_arrow_info();
X
X
X	/* create our window and display it */
X	screen = newwin(width,len,y,x);
X	waddstr(screen,"\n\n\n\n\tHELLO WORLD\n");
X	box(screen,'+','-'); 
X	wrefresh(screen);
X
X	/* read in characters and move window accordingly */
X	while(c != 'x') {
X		c = wgetch(screen);
X		if ( c == ESCAPE ) {
X			c = do_escape();
X		}
X		switch(c) {
X			case MY_KEY_LEFT : if( x != 0 )
X						mvwin(screen,y,--x);
X					wrefresh(screen);
X					break;
X			case MY_KEY_DOWN :	if( y+width < LINES)
X						mvwin(screen,++y,x);
X					wrefresh(screen);
X					break;
X			case MY_KEY_UP :	if( y != 0 )
X						mvwin(screen,--y,x);
X					wrefresh(screen);
X					break;
X			case MY_KEY_RIGHT :if( x+len < COLS)
X						mvwin(screen,y,++x);
X					wrefresh(screen);
X					break;
X			case 'c' :	clear();
X					refresh();
X					touchwin(screen);
X					wrefresh(screen);
X					break;
X		}
X	}
X
X	/* you should always call endwin before you exit a curses programs */
X	/* so that the terminal is restored to its original state */
X	clear();
X	refresh();
X	endwin();
X	exit(0);
X}
X#endif
END_OF_FILE
if test 3480 -ne `wc -c <'mrolo13/arrows.c'`; then
    echo shar: \"'mrolo13/arrows.c'\" unpacked with wrong size!
fi
# end of 'mrolo13/arrows.c'
fi
if test -f 'mrolo13/arrows.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/arrows.h'\"
else
echo shar: Extracting \"'mrolo13/arrows.h'\" \(148 characters\)
sed "s/^X//" >'mrolo13/arrows.h' <<'END_OF_FILE'
X
X#define ESCAPE 		27
X#define MY_KEY_RIGHT	0
X#define MY_KEY_LEFT	1
X#define MY_KEY_UP	2
X#define MY_KEY_DOWN	3
X
Xint get_arrow_info();
Xint do_escape();
END_OF_FILE
if test 148 -ne `wc -c <'mrolo13/arrows.h'`; then
    echo shar: \"'mrolo13/arrows.h'\" unpacked with wrong size!
fi
# end of 'mrolo13/arrows.h'
fi
if test -f 'mrolo13/callback.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/callback.c'\"
else
echo shar: Extracting \"'mrolo13/callback.c'\" \(6043 characters\)
sed "s/^X//" >'mrolo13/callback.c' <<'END_OF_FILE'
X/* Copyright 1993 by gregg hanna */
X/*
X * Generated by the ICS builderXcessory (BX).
X *
X *
X * Builder Xcessory 1.0.1.
X *
X */
X#include <stdio.h>
X#include <X11/Intrinsic.h>
X#include <X11/Xos.h>
X#include <Xm/Xm.h>
X#include <Xm/Text.h>
X#include <Xm/List.h>
X#include <Xm/ToggleB.h>
X#include <string.h>
X#include "compat.h"
X#include "roloP.h"
X#include "rolo.h"
X
Xint DisplayedCard;
Xint DialogForDelete = 0;
X
X#define IsUp XtIsManaged
X#define UpDialog XtManageChild
X#define DownDialog XtUnmanageChild
X
Xvoid SetDialogDelete()
X{
X  Arg args[1];
X  XmString xmstr;
X  extern Widget confirmDialog;
X
X  DialogForDelete = 1;
X
X  xmstr = XmStringCreateSimple("Delete this card?");
X  XtSetArg(args[0],XmNmessageString,xmstr);
X  XtSetValues(confirmDialog,args,1);
X
X  XmStringFree(xmstr);
X}
X
Xvoid SetDialogUpdate()
X{
X  Arg args[2];
X  XmString xmstr;
X  extern Widget confirmDialog;
X
X  DialogForDelete = 0;
X  
X  xmstr = XmStringCreateSimple("Save changes to this card?");
X  XtSetArg(args[0],XmNmessageString,xmstr);
X  XtSetValues(confirmDialog,args,1);
X
X  XmStringFree(xmstr);
X}
X
Xvoid PickChange(w,client,call)
X     Widget w;
X     caddr_t client, call;
X{
X  Boolean v;
X  int n;
X  XmToggleButtonCallbackStruct *event = (XmToggleButtonCallbackStruct*)call;
X
X  n = (int)client;
X  if ( n >= 0 && n < 4 ) {
X    if ( event->set ) RoloSearch[n] = 1;
X    else RoloSearch[n] = 0;
X  }
X}
X
Xvoid ManageArgAtClick(w,client,call)
X     Widget w;
X     caddr_t client, call;
X{
X  extern Widget picker;
X  XmToggleButtonCallbackStruct *event = (XmToggleButtonCallbackStruct*)call;
X  Widget wi = (Widget)client;
X  XButtonEvent *bevent;
X  Position x, y;
X
X  UpDialog(picker);
X}
X
Xvoid PickDone(w,client,call)
X     Widget w;
X     caddr_t client, call;
X{
X  Widget dialog;
X
X  dialog = (Widget)client;
X  DownDialog(dialog);
X}
X
Xvoid
XActuallyDeleteCard(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  extern Widget cardForm, confirmDialog, ListForRolo;
X  void OKCard();
X  Arg arg[1];
X  int n;
X
X  DeleteRoloCard(DisplayedCard);
X  if ( DialogForDelete ) { /* The dialog was a delete dialog */
X    XmListDeletePos(ListForRolo,DisplayedCard+1);
X    WriteRolo();
X  } else {  /* we were using the delete dialog as an update dialog */
X    XtSetArg(arg[0],XmNtopItemPosition,&n);
X    XtGetValues(ListForRolo,arg,1);
X    DisplayedCard = -1;
X    OKCard((Widget)NULL,(caddr_t)NULL,(caddr_t)NULL); /* will re-add this rec and update */
X    XmListSetPos(ListForRolo,n);
X  }
X
X  DownDialog(cardForm);
X  DownDialog(confirmDialog);
X}
X
X
Xvoid
XAddCard(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  extern Widget nameText, numberText, numberText2, commentText, cardForm, deleteCardButton;
X  Arg args[1];
X
X  XmTextSetString(nameText,"");
X  XmTextSetString(numberText,"");
X  XmTextSetString(numberText2,"");
X  XmTextSetString(commentText,"");
X
X  XtSetArg(args[0],XmNsensitive,False);
X  XtSetValues(deleteCardButton,args,1);
X
X  DisplayedCard = -1;
X  
X  UpDialog(cardForm);
X}
X
Xvoid
XCancelCard(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  extern Widget cardForm, confirmDialog;
X  DownDialog(cardForm);
X  DownDialog(confirmDialog);
X}
X
Xvoid
XDeleteCard(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  extern Widget confirmDialog;
X  SetDialogDelete();
X  if ( IsUp(confirmDialog) ) DownDialog(confirmDialog);
X  UpDialog(confirmDialog);
X}
X
Xvoid
XDontDeleteCard(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  extern Widget confirmDialog;
X  DownDialog(confirmDialog);
X}
X
Xvoid
XOKCard(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  extern Widget nameText, numberText, numberText2, commentText, confirmDialog;
X  extern Widget cardForm, ListForRolo;
X  char *a, *b, *c, *d;
X  int same;
X
X  a = XmTextGetString(nameText);
X  b = XmTextGetString(numberText);
X  c = XmTextGetString(commentText);
X  d = XmTextGetString(numberText2);
X
X  if ( DisplayedCard < 0 ) {
X    MakeNewRolo(a,b,d,c,1);
X    WriteRolo();
X    PutListOnScreen();
X    DownDialog(cardForm);
X    XmListSetPos(ListForRolo,GetIndex(a)+1);
X  } else {
X    same = ( strcmp(a,GetCardName(DisplayedCard)) == 0 ) &&
X           ( strcmp(b,GetNumber(DisplayedCard)) == 0 ) &&
X           ( strcmp(d,GetNumber2(DisplayedCard)) == 0 ) &&
X           ( strcmp(c,GetText(DisplayedCard)) == 0 );
X    if ( ! same ) {
X      SetDialogUpdate();
X      if ( IsUp(confirmDialog) ) DownDialog(confirmDialog);
X      UpDialog(confirmDialog);
X    } else {
X      DownDialog(cardForm);
X    }
X  }
X  if (a!=NULL) free(a);
X  if (b!=NULL) free(b);
X  if (c!=NULL) free(c);
X  if (d!=NULL) free(d);
X}
X
Xvoid
XQuitProg(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  (void)exit(0);
X}
X
Xvoid
XSelected(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  XmListCallbackStruct *list=(XmListCallbackStruct*)call;
X  extern Widget nameText, numberText, numberText2, commentText, cardForm, deleteCardButton;
X  extern Widget filterText;
X  Arg args[1];
X  char *s;
X  int n;
X
X  n = list->item_position - 1;
X  if ( n < 0 ) return;
X
X  XmProcessTraversal(filterText,XmTRAVERSE_CURRENT);
X
X  s = GetCardName(n);
X  XmTextSetString(nameText,s);
X  s = GetNumber(n);
X  XmTextSetString(numberText,s);
X  s = GetNumber2(n);
X  XmTextSetString(numberText2,s);
X  s = GetText(n);
X  XmTextSetString(commentText,s);
X
X  XtSetArg(args[0],XmNsensitive,True);
X  XtSetValues(deleteCardButton,args,1);
X
X  DisplayedCard = n;
X  
X  UpDialog(cardForm);
X}
X
Xvoid
XSpinRolo(w, client, call)
XWidget w;
Xcaddr_t client;
Xcaddr_t call;
X{
X  extern Widget ListForRolo;
X  int n;
X
X  n = GetIndex((char*)client);
X  XmListSetPos(ListForRolo,n+1);
X}
X
X
Xvoid ChangeFilter(w, client, call)
X     Widget w;
X     caddr_t client;
X     caddr_t call;
X{
X  char *s;
X  
X  s = XmTextGetString(w);
X  RoloFilter(s);
X  PutListOnScreen();
X}
X
Xvoid ClearFilter(w, client, call)
X     Widget w;
X     caddr_t client;
X     caddr_t call;
X{
X  extern Widget filterText;
X
X  XmTextSetString(filterText,"");
X  RoloFilter((char*)NULL);
X  PutListOnScreen();
X}
X
Xvoid ReturnHit(w, client, call)
X     Widget w;
X     caddr_t client;
X     caddr_t call;
X{
X  XmProcessTraversal(w,XmTRAVERSE_NEXT_TAB_GROUP);
X}
X
END_OF_FILE
if test 6043 -ne `wc -c <'mrolo13/callback.c'`; then
    echo shar: \"'mrolo13/callback.c'\" unpacked with wrong size!
fi
# end of 'mrolo13/callback.c'
fi
if test -f 'mrolo13/compat.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/compat.c'\"
else
echo shar: Extracting \"'mrolo13/compat.c'\" \(1502 characters\)
sed "s/^X//" >'mrolo13/compat.c' <<'END_OF_FILE'
X#ifndef NO_COMPAT
X
X#include <ctype.h>
X
X/* strcmp, case insensitive */
Xint mystrcasecmp(a,b)
X     char *a, *b;
X{
X  int rval;
X  for ( rval = 0; *a != '\0' && *b != '\0' && rval == 0; a++, b++ ) {
X    rval = *a - *b;
X    if ( rval != 0 )
X      if ( isupper(*a) && islower(*b) )
X        rval = *a - toupper(*b);
X      else if ( islower(*a) && isupper(*b) )
X        rval = toupper(*a) - *b;
X  }
X  return rval;
X}
X
Xint mystrncasecmp(a,b,n)
X     char *a, *b;
X     int n;
X{
X  int rval, i;
X
X  for ( i = 0, rval = 0; i < n && *a != '\0' && *b != '\0' && rval == 0; a++, b++, i++ ) {
X    rval = *a - *b;
X    if ( rval != 0 )
X      if ( isupper(*a) && islower(*b) )
X        rval = *a - toupper(*b);
X      else if ( islower(*a) && isupper(*b) )
X        rval = toupper(*a) - *b;
X  }
X  if ( i < n && *a == '\0' ) rval = -1;
X  return rval;
X}
X
Xchar *mystrcpy(t,s)
X	char *t, *s;
X{
X  char *a;
X
X  a = t;
X  for ( ; *s != '\0'; s++, t++ ) *t = *s;
X  *t = '\0';
X  return a;
X}
X
Xchar *mystrdup(s)
X  char *s;
X{
X  char *t;
X
X  if ( s == (char*)0 ) return (char*)0;
X  t = (char*)malloc(strlen(s)+1);
X  if ( t == (char*)0 ) return (char*)0;
X  mystrcpy(t,s);
X  return t;
X}
X
X#endif
X
Xchar *mystrstrcase(t,s)
X     char *t, *s;
X{
X  int n;
X  char s1, s2;
X
X  n = strlen(s);
X  s1 = s[0];
X  if ( isupper(s1) ) s2 = tolower(s1);
X  else if ( islower(s1) ) s2 = toupper(s1);
X  else s2 = s1;
X  for (; *t != '\0'; t++ ) {
X    if ( *t == s1 || *t == s2 )
X      if ( mystrncasecmp(t,s,n) == 0 ) {
X        return t;
X      }
X  }
X  return (char*)0;
X}
X
END_OF_FILE
if test 1502 -ne `wc -c <'mrolo13/compat.c'`; then
    echo shar: \"'mrolo13/compat.c'\" unpacked with wrong size!
fi
# end of 'mrolo13/compat.c'
fi
if test -f 'mrolo13/compat.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/compat.h'\"
else
echo shar: Extracting \"'mrolo13/compat.h'\" \(250 characters\)
sed "s/^X//" >'mrolo13/compat.h' <<'END_OF_FILE'
X
Xchar *mystrstrcase();
X
X#ifndef NO_COMPAT
X
Xint mystrcasecmp();
Xint mystrncasecmp();
Xchar *mystrcpy();
Xchar *mystrdup();
X
X#else
X
X#define mystrcasecmp strcasecmp
X#define mystrncasecmp strncasecmp
X#define mystrcpy strcpy
X#define mystrdup strdup
X
X#endif
END_OF_FILE
if test 250 -ne `wc -c <'mrolo13/compat.h'`; then
    echo shar: \"'mrolo13/compat.h'\" unpacked with wrong size!
fi
# end of 'mrolo13/compat.h'
fi
if test -f 'mrolo13/crolo.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/crolo.man'\"
else
echo shar: Extracting \"'mrolo13/crolo.man'\" \(3372 characters\)
sed "s/^X//" >'mrolo13/crolo.man' <<'END_OF_FILE'
X'\" t
X.TH crolo L "21 July 1993"
X.SH NAME
Xcrolo \- curses-based card file manager
X.SH SYNOPSIS
X.B crolo
X[
X.B -v
X] [
X.B -f filename
X]
X.SH DESCRIPTION
X.LP
X.I CRolo
Xis a program for maintaining a simple cardfile,
Xspecifically oriented for saving address-book
Xinformation.
X.LP
XThe default database file read is
X.IR $HOME/.rolo ,
Xalthough this can be overridden with the
X.B ROLODEX
Xenvironment variable or the
X.B -f
Xcommand-line argument.
XIf the file does not exist, it is created empty.
XThe database is stored in a format similar to that of the
X.I xrolo
Xprogram:  Blocks of text separated by lines containing just
Xa ctrl-L.
X.LP
XWhen invoked
X.I CRolo
Xwill present the user with a screen summarizing the database.
XThe user may scroll through the summary with the cursor keys,
Xup and down move the selection bar up and down, while left
Xand right move up or down a screenful.
XIf the cursor keys don't work correctly, or you are
Xused to the vi editor, the following controls work as well:
X.TS
Xtab(:), center;
Xc l.
X^F, ^D:move down a screen
X^B, ^U:move up a screen
Xj, +:move down a line
Xk, -:move up a line
X.TE
X.LP
XSelecting an individual entry (by hitting return)
Xwill display the full information in your default
Xeditor.  You may edit or just view this information.
X.LP
XHitting any capital letter will scroll your listing to
Xthose entries which start with that letter.
XCommands are entered by pressing the lower-case
Xletter which corresponds to the first letter of
Xthe command you want to execute.  The commands are:
X.IP "Add Card"
XStarts your editor with a blank card.  Fill in text
Xas desired then save the file, it will be added to your
Xcard file database.
X.IP "Delete Card"
XWill delete the currently selected card from your card
Xfile database, after confirming the deletion.
X.IP "Redraw"
XThis will redraw the whole screen.  Control-L does this
Xalso.
X.IP "Quit"
XExit the program.
X.IP "Clear Filter"
XEmpties the contents of the filter string, thus showing
Xall of the cards in the database.
X.IP "Filter"
XEnter a filter string and only cards which contain the
Xgiven string will be shown on the display.  If the first
Xletter of the string is a backslash the rest of the
Xfilter text will be interpreted as a regular expression,
Xotherwise it is matched as case-insensitive text.
X.LP
XThere are companion programs included in this package but
Xdocumented seperately.  They are:
X.IP "\fImrolo\fR"
XMotif-based card file database manager
X.IP "\fIprolo\fR"
Xprints card file databases in postscript
X.IP "\fIxr2mr\fR"
Xconverts xrolodex files to crolo format
X.SH OPTIONS
X.TP
X.B \-v
XDisplay the version number and show error messages.
X.TP
X.B \-f filename
XRun using the specified file as the default database.
X.SH FILES
X.TP 20
X.B ~/.rolo
XDefault database.
X.SH ENVIRONMENT
X.TP 20
XROLODEX
XDefault database, overrides ~/.rolo, but not the -f option.
X.SH "SEE ALSO"
X.PD
X.BR xr2mr (1),
X.BR mrolo (1),
X.BR prolo (1)
X.br
X.ne 5
X.SH BUGS
X.LP
XNone known.  Report bugs to gregor@kafka.saic.com
X.SH AUTHOR
X.nf
X.LP
Xgregg hanna (gregor@kafka.saic.com)
XScience Applications International Corporation
X10260 Campus Point Drive, MS C3
XSan Diego, California  92121
X.fi
X.LP
XCopyright 1993 by gregg hanna.  Permission is granted
Xto use, modify, and distribute this program.  Basically
Xdo anything you want with it, but if you want to use
Xit or any part of it to make money you must get further
Xpermission from me.
X
X
END_OF_FILE
if test 3372 -ne `wc -c <'mrolo13/crolo.man'`; then
    echo shar: \"'mrolo13/crolo.man'\" unpacked with wrong size!
fi
# end of 'mrolo13/crolo.man'
fi
if test -f 'mrolo13/getopt.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/getopt.c'\"
else
echo shar: Extracting \"'mrolo13/getopt.c'\" \(1409 characters\)
sed "s/^X//" >'mrolo13/getopt.c' <<'END_OF_FILE'
X/*
X**  GETOPT PROGRAM AND LIBRARY ROUTINE
X**
X**  I wrote main() and AT&T wrote getopt() and we both put our efforts into
X**  the public domain via mod.sources.
X**	Rich $alz
X**	Mirror Systems
X**	(mirror!rs, rs@mirror.TMC.COM)
X**	August 10, 1986
X** 
X**  This is the public-domain AT&T getopt(3) code.  Hacked by Rich and by Jim.
X*/
X
X#include <stdio.h>
X#ifdef NO_X
X#include <strings.h>
X#else
X#include <X11/Xos.h>
X#endif
X
X#define ERR(_s, _c) { if (opterr) fprintf (stderr, "%s%s%c\n", argv[0], _s, _c);}
X
Xint	opterr = 1;
Xint	optind = 1;
Xint	optopt;
Xchar	*optarg;
X
Xint
Xgetopt(argc, argv, opts)
Xint	argc;
Xchar	**argv, *opts;
X{
X	static int sp = 1;
X	register int c;
X	register char *cp;
X
X	if(sp == 1)
X		if(optind >= argc ||
X		   argv[optind][0] != '-' || argv[optind][1] == '\0')
X			return(EOF);
X		else if(strcmp(argv[optind], "--") == NULL) {
X			optind++;
X			return(EOF);
X		}
X	optopt = c = argv[optind][sp];
X	if(c == ':' || (cp=index(opts, c)) == NULL) {
X		ERR(": illegal option -- ", c);
X		if(argv[optind][++sp] == '\0') {
X			optind++;
X			sp = 1;
X		}
X		return('?');
X	}
X	if(*++cp == ':') {
X		if(argv[optind][sp+1] != '\0')
X			optarg = &argv[optind++][sp+1];
X		else if(++optind >= argc) {
X			ERR(": option requires an argument -- ", c);
X			sp = 1;
X			return('?');
X		} else
X			optarg = argv[optind++];
X		sp = 1;
X	} else {
X		if(argv[optind][++sp] == '\0') {
X			sp = 1;
X			optind++;
X		}
X		optarg = NULL;
X	}
X	return(c);
X}
END_OF_FILE
if test 1409 -ne `wc -c <'mrolo13/getopt.c'`; then
    echo shar: \"'mrolo13/getopt.c'\" unpacked with wrong size!
fi
# end of 'mrolo13/getopt.c'
fi
if test -f 'mrolo13/mrolo.bm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/mrolo.bm'\"
else
echo shar: Extracting \"'mrolo13/mrolo.bm'\" \(1659 characters\)
sed "s/^X//" >'mrolo13/mrolo.bm' <<'END_OF_FILE'
X#define mrolo_width 50
X#define mrolo_height 44
Xstatic char mrolo_bits[] = {
X 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X 0x00,0x00,0x00,0xf0,0x1f,0x00,0x00,0x00,0x00,0x00,0x08,0x20,0x00,0x00,0x00,
X 0x00,0x00,0x88,0x22,0x00,0x00,0x00,0x00,0x00,0x48,0x25,0x00,0xe0,0xff,0xff,
X 0xff,0x0f,0x20,0x00,0x10,0x00,0x00,0x00,0x00,0x20,0x00,0x10,0x00,0x00,0x00,
X 0x00,0x20,0x00,0x10,0x00,0x3e,0x80,0x03,0x20,0x00,0x10,0x00,0x66,0x00,0x03,
X 0x20,0x00,0x10,0x00,0x66,0x00,0x03,0x20,0x00,0x10,0x00,0x66,0x00,0x03,0x20,
X 0x00,0x90,0x3f,0x66,0x3e,0xf3,0x21,0x00,0x90,0x6d,0x3e,0x63,0x1b,0x23,0x00,
X 0x90,0x6d,0x66,0x63,0x1b,0x23,0x00,0x90,0x6d,0x66,0x63,0x1b,0x23,0x00,0x90,
X 0x6d,0x66,0x63,0x1b,0x23,0x00,0x90,0x6d,0x66,0x36,0xb3,0x21,0x00,0x90,0x6d,
X 0xc6,0x9c,0xe7,0x20,0x00,0x10,0x00,0x00,0x00,0x00,0x20,0x00,0x1c,0x00,0x00,
X 0x00,0x00,0xe0,0x00,0x1c,0x10,0x00,0x00,0x20,0xe0,0x00,0x1c,0x28,0x00,0x00,
X 0x50,0xe0,0x00,0x1c,0x10,0x00,0x00,0x20,0xe0,0x00,0xfc,0xff,0xff,0xff,0xff,
X 0xff,0x00,0xbc,0xff,0xff,0xff,0xff,0xf7,0x00,0xfc,0xff,0xff,0xff,0xff,0xff,
X 0x00,0x1c,0x10,0x00,0x00,0x20,0xe0,0x00,0x1c,0x28,0x00,0x00,0x50,0xe0,0x00,
X 0x1c,0x10,0x00,0x00,0x20,0xe0,0x00,0x1c,0x00,0x00,0x00,0x00,0xe0,0x00,0x10,
X 0x00,0x00,0x00,0x00,0x20,0x00,0x10,0x00,0x00,0x00,0x00,0x20,0x00,0x30,0x00,
X 0x00,0x00,0x00,0x20,0x00,0xd0,0xff,0xff,0xff,0x07,0x20,0x00,0x30,0x00,0x00,
X 0x00,0x08,0x20,0x00,0xd0,0xff,0xff,0xff,0xf7,0x3f,0x00,0x20,0x00,0x00,0x00,
X 0x08,0x20,0x00,0xc0,0xff,0xff,0xff,0xf7,0x3f,0x00,0x00,0x00,0x00,0x00,0x08,
X 0x20,0x00,0x00,0x00,0x00,0x00,0xf0,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
X 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
END_OF_FILE
if test 1659 -ne `wc -c <'mrolo13/mrolo.bm'`; then
    echo shar: \"'mrolo13/mrolo.bm'\" unpacked with wrong size!
fi
# end of 'mrolo13/mrolo.bm'
fi
if test -f 'mrolo13/mrolo.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/mrolo.c'\"
else
echo shar: Extracting \"'mrolo13/mrolo.c'\" \(3438 characters\)
sed "s/^X//" >'mrolo13/mrolo.c' <<'END_OF_FILE'
X/* Copyright 1993 by gregg hanna */
X/*
X * Generated by the ICS builderXcessory (BX).
X *
X *
X * Builder Xcessory 1.0.1.
X *
X */
X/*
X * REQUIRED MOTIF INCLUDE FILES
X */
X#include <Xm/Xm.h>
X#include <X11/Shell.h>
X#include <Xm/DialogS.h>
X#include <X11/StringDefs.h>
X#include <stdio.h>
X
X/* GLOBAL WIDGET VARIABLES */
XWidget Shell000;
XWidget Form;
XWidget Createform();
XWidget cardForm;
XWidget confirmDialog;
XWidget CreateMessageDialog();
XWidget CreateFormDialog();
XWidget CreatePicker();
X
Xvoid dumpcore(){char *s; s = 0; *s = 'x'; }
X
X#include "roloP.h"
X#include "rolo.h"
X#include "mrolo.bm"
X#include "compat.h"
X
Xtypedef struct {
X  String  indexElements;
X  Boolean showSecondary;
X  int     sizePrimary;
X  Boolean selectFilter;
X} mroloAppResources, *mroloAppResourcesP;
X
X#define MOffset(x) XtOffset(mroloAppResourcesP, x)
X
Xstatic XtResource resources[] = {
X  {"indexElements", "IndexElements", XtRString, sizeof(String),
X     MOffset(indexElements), XtRString, "A B C D E F G H I J K L M N O P Q R S T U V W X Y Z"},
X  {"showSecondary", "ShowSecondary", XtRBoolean, sizeof(Boolean),
X     MOffset(showSecondary), XtRImmediate, (XtPointer) True},
X  {"sizePrimary", "SizePrimary", XtRInt, sizeof(int),
X     MOffset(sizePrimary), XtRImmediate, (XtPointer) 20},
X  {"selectFilter", "SelectFilter", XtRBoolean, sizeof(Boolean),
X     MOffset(selectFilter), XtRImmediate, (XtPointer) False},
X};
X
Xstatic char *appDefaults[] = {
X#include "MRolo.ad.h"
X      NULL
X};
X
XBoolean showSecondary;
Xint sizePrimary;
XString indexElements;
X
Xvoid SetResources(w)
X   Widget  w;
X{
X  mroloAppResources appResources;
X  XtGetApplicationResources(w, (XtPointer) &appResources,
X			    resources, XtNumber(resources), NULL, 0);
X  showSecondary = appResources.showSecondary;
X  sizePrimary = appResources.sizePrimary;
X  indexElements = mystrdup(appResources.indexElements);
X  if ( ! selectFilter )
X    selectFilter = (int)appResources.selectFilter;
X}
X
Xvoid SetIcon(w)
X	Widget w;
X{
X  Pixmap p;
X  Arg arg[1];
X
X  p = XCreateBitmapFromData(XtDisplay(w),XtWindow(w),mrolo_bits,mrolo_width,mrolo_height);
X  XtSetArg(arg[0],XmNiconPixmap,p);
X  XtSetValues(w,arg,1);
X}
X
X#define APP_NAME argv[0]
X
X/* Tweeks the size of a widget to make old ScrolledLists work right */
Xvoid DoResize()
X{
X  Dimension width, height, bwidth;
X
X  XtVaGetValues(Shell000,XmNwidth,&width,XmNheight,&height,XmNborderWidth,&bwidth,NULL);
X  XtResizeWidget(Shell000,width,height-1,bwidth);
X  XtResizeWidget(Shell000,width,height,bwidth);
X}
X
X/* MAIN PROGRAM */
Xmain(argc, argv)
Xint argc;
Xchar **argv;
X{
X    Arg 	args[256];
X    int 	argcnt;
X    XtAppContext context;
X    extern Widget filterText;
X    extern Widget picker;
X
X    XmRegisterConverters();
X    argcnt = 0;
X    XtSetArg(args[argcnt], XmNtitle, "Rolodex"); argcnt++;
X    Shell000 = XtAppInitialize(&context,APP_NAME,NULL,0,(Cardinal*)&argc,argv,
X			       appDefaults,args,argcnt);
X    SetResources(Shell000);
X
X    InitRolo(argc,argv,1);
X    SetupRolo();
X
X    Form = Createform(Shell000);
X    XtManageChild(Form);
X
X    cardForm = CreateFormDialog(Shell000);
X    confirmDialog = CreateMessageDialog(Shell000);
X
X    if ( selectFilter )
X      picker = CreatePicker(Shell000);
X
X    XtRealizeWidget(Shell000);
X
X    SetIcon(Shell000);
X    PutListOnScreen();
X
X#ifdef WANT_CORE
X    XSetErrorHandler(dumpcore);
X#endif
X
X    XmProcessTraversal(filterText,XmTRAVERSE_CURRENT);
X
X    DoResize();  /* kludge for old ScrolledList */
X
X    XtAppMainLoop(context);
X
X    return 0;
X
X}
END_OF_FILE
if test 3438 -ne `wc -c <'mrolo13/mrolo.c'`; then
    echo shar: \"'mrolo13/mrolo.c'\" unpacked with wrong size!
fi
# end of 'mrolo13/mrolo.c'
fi
if test -f 'mrolo13/myregexp.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/myregexp.h'\"
else
echo shar: Extracting \"'mrolo13/myregexp.h'\" \(848 characters\)
sed "s/^X//" >'mrolo13/myregexp.h' <<'END_OF_FILE'
X/* setup regular expression handling */
X
X#ifdef USE_RE_COMP
X
Xchar *re_comp();
Xint re_exec();
X#define re_free()
X
X#else
X#ifdef _POSIX_SOURCE
X
X#include <regex.h>
Xstatic regex_t local_re;
X#define re_comp(s)  (regcomp(&local_re,(s),REG_NOSUB|REG_ICASE),(char*)NULL)
X#define re_exec(s)  (regexec(&local_re,(s),(size_t)0,NULL,0)==NULL)
X#define re_free()  (regfree(&local_re))
X
X#else
X#ifdef NO_REGEX
X
X#ifndef DONT_REGEX
X#define DONT_REGEX
X#endif
X
X#else
X
X#define INIT   register char *sp = instring;
X#define GETC() (*sp++)
X#define PEEKC()     (*sp)
X#define UNGETC(c)   (--sp)
X#define RETURN(c)   return;
X#define ERROR(c)    if(verbose)fprintf(stderr,"regexp compile error %d\n",(c));
X#define re_comp(s)  (char*)(compile((s),expbuf,&expbuf[EXPSIZE],'\0'),NULL)
X#define re_exec(s)  step((s),expbuf)
X#define re_free()
X#include <regexp.h>
X
X#endif
X#endif
X#endif
END_OF_FILE
if test 848 -ne `wc -c <'mrolo13/myregexp.h'`; then
    echo shar: \"'mrolo13/myregexp.h'\" unpacked with wrong size!
fi
# end of 'mrolo13/myregexp.h'
fi
if test -f 'mrolo13/patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/patchlevel.h'\"
else
echo shar: Extracting \"'mrolo13/patchlevel.h'\" \(21 characters\)
sed "s/^X//" >'mrolo13/patchlevel.h' <<'END_OF_FILE'
X#define PATCHLEVEL 0
END_OF_FILE
if test 21 -ne `wc -c <'mrolo13/patchlevel.h'`; then
    echo shar: \"'mrolo13/patchlevel.h'\" unpacked with wrong size!
fi
# end of 'mrolo13/patchlevel.h'
fi
if test -f 'mrolo13/prolo.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/prolo.man'\"
else
echo shar: Extracting \"'mrolo13/prolo.man'\" \(3680 characters\)
sed "s/^X//" >'mrolo13/prolo.man' <<'END_OF_FILE'
X.TH prolo L "13 May 1993"
X.SH NAME
Xprolo \- card file database printer
X.SH SYNOPSIS
X.B prolo
X[
X.B \-cbeh
X] [
X.B \-F filtertext
X] [
X.B \-f rolofile
X] [
X.B \-s fontsize
X]
X.SH DESCRIPTION
X.LP
X.I PRolo
Xis a program for printing a simple cardfile,
Xgenerating PostScript output.
X.LP
XThe default database file read is
X.IR $HOME/.rolo ,
Xalthough this can be overridden with the
X.B ROLODEX
Xenvironment variable or the
X.B -f
Xcommand-line argument.
XIf the file does not exist, it is created empty.
XThe database is assumed to be in the format of
Xthe
X.I mrolo
Xor
X.I xrolo
Xprograms.
X.LP
XThe output will be a PostScript program.  Most of the options
Xset from the command line can also be set by editing this
Xprogram before printing.  The basic, unchangeable format
Xfor the individual records is:
X.nf
XFirst Line  Second Line  Third Line
X            Fourth Line
X            Fifth Line
X              .
X              .
X              .
X.fi
X.LP
XWhen used with
X.I mrolo
XThe first line is usually a name, the second the primary
Xphone number, the third the secondary phone number,
Xand others are descriptive text (address, other
Xnumbers, etc.).  The PostScript program will organize these
Xentries in columns and the columns into pages, if needed.
X.LP
XNote that lines are sized and spaced based on the largest
Xentries, so you might want to edit your cardfile to have
Xfairly consistent field lengths.  For example, if you use
Xthe secondary number to store a very long string or
Xhave one name which is particularly long then 
X.B all
Xof the
Xprinted entries will be very wide.
X.SH OPTIONS
X.TP
X.B \-c
XInclude card info, by default only name, primary and secondary
Xnumbers are printed.
X.TP
X.B \-b
XDraw a box around each entry.
X.TP
X.B \-e
XMake all entries the same size.  Each entry will take up
Xas much space as the largest entry, using more space
Xbut looking neat and tidy.  This only makes sense with
Xthe -c option.
X.TP
X.B \-F filertext
XOnly emit entries which contain
X.I filtertext
Xsomewhere in the entry.  This option cannot be changed
Xin the PostScript program, it must be specified on
Xthe command line.  If the filter text begins with a back-slash,
Xthe filter is interpreted as a regular expression.  Note that
Xthe shell treats back-slash as a special character, so you
Xmust quote it properly.
X.TP
X.B \-f filename
XRun using the specified file as the default database.
XThis option cannot be changed in the PostScript program,
Xit must be specified on the command line.
X.TP
X.B \-s fontsize
XThe font size used to print the entries.  The default is 5
X(small for pocket lists).
X
X.SH POSTSCRIPT OPTIONS
X.LP
XMost of the command-line options (the exceptions are noted above)
Xcan be changed and played with in the output file.  Each option
Xhas a corresponding variable set at the beginning of the PostScript,
Xthe following table describes the mappings:
X.TP
X.B -c
Xcardinfo
X.TP
X.B -b
Xboxmode
X.TP
X.B -e
Xequalbox
X.TP
X.B -s
Xfontsize
X
X.SH FILES
X.TP 20
X.B ~/.rolo
XDefault database.
X.SH ENVIRONMENT
X.TP 20
XROLODEX
XDefault database, overrides ~/.rolo, but not the -f option.
X.SH "SEE ALSO"
X.PD
X.BR xrolo (1),
X.BR mrolo (1)
X.br
X.ne 5
X.SH BUGS
X.LP
XThis program makes assumptions about the size of the
Xoutput paper.  It was developed for 8.5x11 paper, your milage
Xmay vary.
X.LP
XReport bugs to gregor@kafka.saic.com
X.SH AUTHOR
X.nf
X.LP
Xgregg hanna (gregor@kafka.saic.com)
XScience Applications International Corporation
X10260 Campus Point Drive, MS C3
XSan Diego, California  92121
X.fi
X.LP
XCopyright 1993 by gregg hanna.  Permission is granted
Xto use, modify, and distribute this program.  Basically
Xdo anything you want with it, but if you want to use
Xit or any part of it to make money you must get further
Xpermission from me.
X
X
END_OF_FILE
if test 3680 -ne `wc -c <'mrolo13/prolo.man'`; then
    echo shar: \"'mrolo13/prolo.man'\" unpacked with wrong size!
fi
# end of 'mrolo13/prolo.man'
fi
if test -f 'mrolo13/rolo.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/rolo.h'\"
else
echo shar: Extracting \"'mrolo13/rolo.h'\" \(320 characters\)
sed "s/^X//" >'mrolo13/rolo.h' <<'END_OF_FILE'
X#ifndef _ROLO_H
X#define _ROLO_H
X
X#define VERSION_MAJOR 1
X#define VERSION_MINOR 3
X
Xint NumRoloOn();
Xvoid MakeNewRolo();
Xvoid InitRolo();
Xvoid SetupRolo();
Xvoid PutListOnScreen();
Xvoid DeleteRoloCard();
Xvoid WriteRolo();
Xchar *GetCardName();
Xchar *GetNumber();
Xchar *GetNumber2();
Xchar *GetText();
Xint GetIndex();
X
X#endif
END_OF_FILE
if test 320 -ne `wc -c <'mrolo13/rolo.h'`; then
    echo shar: \"'mrolo13/rolo.h'\" unpacked with wrong size!
fi
# end of 'mrolo13/rolo.h'
fi
if test -f 'mrolo13/roloP.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/roloP.h'\"
else
echo shar: Extracting \"'mrolo13/roloP.h'\" \(297 characters\)
sed "s/^X//" >'mrolo13/roloP.h' <<'END_OF_FILE'
X#ifndef _ROLOP_H
X#define _ROLOP_H
X
Xtypedef struct _RoloRec {
X  char *name;
X  char *number;
X  char *number2;
X  char *text;
X  int on;
X  struct _RoloRec *next;
X} RoloRec;
X
X#define STRSIZE 100000
X
Xextern RoloRec *RoloList;
Xextern int RoloSearch[4];
Xextern int selectFilter;
X
XRoloRec *GetN();
X
X#endif
X
END_OF_FILE
if test 297 -ne `wc -c <'mrolo13/roloP.h'`; then
    echo shar: \"'mrolo13/roloP.h'\" unpacked with wrong size!
fi
# end of 'mrolo13/roloP.h'
fi
if test -f 'mrolo13/roloc.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/roloc.c'\"
else
echo shar: Extracting \"'mrolo13/roloc.c'\" \(1219 characters\)
sed "s/^X//" >'mrolo13/roloc.c' <<'END_OF_FILE'
X/* Copyright 1993 by gregg hanna */
X#include <curses.h>
X#include "patchlevel.h"
X#include "rolo.h"
X#include "roloP.h"
X
Xextern WINDOW *listWin;
Xextern int top_of_screen, linec, linew, active_line;
X
Xstatic void formatstr(r,s,n)
X     RoloRec *r;
X     char *s;
X     int n;
X{
X  int i;
X  sprintf(s,"%-30s %s, %s",r->name,r->number,r->number2);
X  if ( strlen(s) < n )
X    for ( i = strlen(s); i < n; i++ )
X      s[i] = ' ';
X  s[n] = '\0';
X}
X
Xvoid PutLineOnScreen(ln)
X     int ln;
X{
X  RoloRec *rr;
X  char *buf, *s;
X  int n;
X
X  if ( top_of_screen < 0 ) top_of_screen = 0;
X  buf = (char*)malloc(500+linew);
X  wmove(listWin,ln-top_of_screen,0);
X  for ( n = 0, rr = RoloList; rr != NULL; rr = rr->next ) {
X    if ( rr->on ) {
X      if ( n == ln ) {
X#ifdef SYSV
X	formatstr(rr,buf,linew-1);
X	waddch(listWin,((n==active_line)?'>':' '));
X        waddstr(listWin,buf);
X#else
X	formatstr(rr,buf,linew);
X	if ( n != active_line ) waddstr(listWin,buf);
X	else for ( s = buf; *s != '\0'; s++ ) waddch(listWin,*s|_STANDOUT);
X#endif
X	break;
X      }
X      n++;
X    }
X  }
X  if ( rr == NULL ) wclrtoeol(listWin);
X  free(buf);
X}
X
Xvoid PutListOnScreen()
X{
X  int i;
X  for ( i = top_of_screen; i < top_of_screen + linec; i++ )
X    PutLineOnScreen(i);
X}
END_OF_FILE
if test 1219 -ne `wc -c <'mrolo13/roloc.c'`; then
    echo shar: \"'mrolo13/roloc.c'\" unpacked with wrong size!
fi
# end of 'mrolo13/roloc.c'
fi
if test -f 'mrolo13/rolox.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/rolox.c'\"
else
echo shar: Extracting \"'mrolo13/rolox.c'\" \(1176 characters\)
sed "s/^X//" >'mrolo13/rolox.c' <<'END_OF_FILE'
X/* Copyright 1993 by gregg hanna */
X#include <stdio.h>
X#include <stdlib.h>
X#include <ctype.h>
X#include <X11/Xos.h>
X#include <Xm/Xm.h>
X#include <Xm/List.h>
X
X#include "patchlevel.h"
X#include "rolo.h"
X#include "roloP.h"
X
Xextern Boolean showSecondary;
Xextern int sizePrimary;
X
Xvoid PutListOnScreen()
X{
X  RoloRec *rr;
X  char buf[500];
X  int n, i;
X  extern Widget ListForRolo;
X  XmString *xmtable;
X
X  n = 0;
X  for ( rr = RoloList; rr != NULL; rr = rr->next )
X    if ( rr->on ) n++;
X
X  xmtable = (XmString*)calloc(n,sizeof(XmString));
X  for ( rr = RoloList, i = 0; rr != NULL; rr = rr->next )
X    if ( rr->on ) {
X      sprintf(buf,"%-30s",rr->name);
X      buf[30] = ' ';
X      if ( showSecondary ) {
X        sprintf(&buf[31],"%-*s",sizePrimary,rr->number);
X        buf[31+sizePrimary] = ' ';
X        mystrcpy(&buf[31+sizePrimary+1],rr->number2);
X      } else {
X        mystrcpy(&buf[31],rr->number);
X      }
X      xmtable[i] = XmStringCreateSimple(buf);
X      i++;
X    }
X  XtUnmapWidget(ListForRolo);
X  XmListDeleteAllItems(ListForRolo);
X  XmListAddItems(ListForRolo,xmtable,n,0);
X  XtMapWidget(ListForRolo);
X  for ( i = 0; i < n; i++ ) XmStringFree(xmtable[i]);
X  free(xmtable);
X}
X
END_OF_FILE
if test 1176 -ne `wc -c <'mrolo13/rolox.c'`; then
    echo shar: \"'mrolo13/rolox.c'\" unpacked with wrong size!
fi
# end of 'mrolo13/rolox.c'
fi
if test -f 'mrolo13/rolox.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/rolox.h'\"
else
echo shar: Extracting \"'mrolo13/rolox.h'\" \(67 characters\)
sed "s/^X//" >'mrolo13/rolox.h' <<'END_OF_FILE'
X#ifndef _ROLOX_H
X#define _ROLOX_H
X
Xvoid PutListOnScreen();
X
X#endif
END_OF_FILE
if test 67 -ne `wc -c <'mrolo13/rolox.h'`; then
    echo shar: \"'mrolo13/rolox.h'\" unpacked with wrong size!
fi
# end of 'mrolo13/rolox.h'
fi
if test -f 'mrolo13/xr2mr' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/xr2mr'\"
else
echo shar: Extracting \"'mrolo13/xr2mr'\" \(60 characters\)
sed "s/^X//" >'mrolo13/xr2mr' <<'END_OF_FILE'
X#!/bin/sh
Xsed '1,$s/^####$/\014/g' $1 | tail +2
Xecho "\014"
END_OF_FILE
if test 60 -ne `wc -c <'mrolo13/xr2mr'`; then
    echo shar: \"'mrolo13/xr2mr'\" unpacked with wrong size!
fi
chmod +x 'mrolo13/xr2mr'
# end of 'mrolo13/xr2mr'
fi
if test -f 'mrolo13/xr2mr.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'mrolo13/xr2mr.man'\"
else
echo shar: Extracting \"'mrolo13/xr2mr.man'\" \(775 characters\)
sed "s/^X//" >'mrolo13/xr2mr.man' <<'END_OF_FILE'
X.TH xr2mr L "19 May 1993"
X.SH NAME
Xxr2mr \- Convert xrolodex file to mrolo format
X.SH SYNOPSIS
X.B xr2mr
X[
X.B filename
X]
X.SH DESCRIPTION
X.LP
X.I xr2mr
Xis a UNIX shell script which will read a xrolodex
Xfile and emit on standard output an equivalent
X.I mrolo
Xfile.  If no file is given on the command line
Xthen standard input is used.
X.LP
XThe format for
X.I mrolo
Xis detailed in it's own manpage, but the format
Xis compatible with xrolo.
X.SH EXAMPLE
X.LP
Xxr2mr .rolodex > .rolo
X.SH "SEE ALSO"
X.PD
X.BR mrolo (1),
X.BR prolo (1),
X.BR xrolo (1)
X.br
X.ne 5
X.SH BUGS
X.LP
XNone known.  Report bugs to gregor@kafka.saic.com
X.SH AUTHOR
X.nf
X.LP
Xgregg hanna (gregor@kafka.saic.com)
XScience Applications International Corporation
X10260 Campus Point Drive, MS C3
XSan Diego, California  92121
X.fi
END_OF_FILE
if test 775 -ne `wc -c <'mrolo13/xr2mr.man'`; then
    echo shar: \"'mrolo13/xr2mr.man'\" unpacked with wrong size!
fi
# end of 'mrolo13/xr2mr.man'
fi
echo shar: End of archive 1 \(of 3\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 3 archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0

exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
