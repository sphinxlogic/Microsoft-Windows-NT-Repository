Newsgroups: comp.sources.x
From: bob@snuffy.penfield.ny.us (Bob Smith)
Subject: v21i014:  notes - an X11R5 note pad based on the Athena Widget set, Part01/02
Message-ID: <csx-v21i014=notes.150228@sparky.Sterling.COM>
X-Md4-Signature: c24fe5fc1ab804f3a2e09e0bc1eb3c54
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Fuzzball Widget Factory
Date: Wed, 20 Oct 1993 20:04:57 GMT
Approved: chris@sterling.com

Submitted-by: bob@snuffy.penfield.ny.us (Bob Smith)
Posting-number: Volume 21, Issue 14
Archive-name: notes/part01
Environment: X11R5

[ Also worked on a Sparc 10 with 4.1.3, X11R5 ]
[                 Chris                       ]

This is a small note manager I wrote a while back.  Seems to work
OK.  I've used it for nearly 10 months now without a mishap so I
think it's fairly stable.  However my system is a Sun 3, SunOS 3.5, with
X11R5... Somewhat of an oddball machine.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 2)."
# Contents:  .notes CHANGES INSTALL Imakefile MANIFEST Makefile README
#   main.c notes.h notes.man notes.xbm patchlevel.h
# Wrapped by bob@snuffy on Sun Sep 19 21:37:43 1993
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f '.notes' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'.notes'\"
else
echo shar: Extracting \"'.notes'\" \(5942 characters\)
sed "s/^X//" >'.notes' <<'END_OF_FILE'
X295 181 410 106 About NOTES
X
X	Notes v1.0.2 by Bob Smith
X
X	Send gripes or suggestions to ...
X
X	bob@snuffy.dracut.ma.us (Bob Smith)
X205 183 500 594 CHANGES
XCHANGES to Notes for v1.0.2
X
Xo	Changed the 'chains' on the buttons that are part
X	of the notes list so that they don't get mucked up
X	when the window is resized.
X
Xo	Added a 'Select' button to the note display to allow
X	selecting the entire note easily.
X
Xo	Changed filler_buttons to filler_boxes... Just makes
X	more sense.
X
Xo	Made a change in the dialog message when creating a new
X	note.
X
Xo	Put the whole mess under SCCS control ... even
X	though I have no real experience at using sccs...
X	as good a time as any to learn...
X
XCHANGES to Notes for v1.0.1
X
Xo	Added a Button 2 translation to the `Dismiss' button
X	of the Notes list that causes everything (any displayed
X	notes and the note list) to be dismissed in one action.
X
Xo	Added a Button 2 translation to the `Save' button
X	of the Notes list that causes a save operation to be
X	performed and everything dismissed.
X
Xo	Added a Button 2 translation to the Notes list widget
X	that will dismiss the associated note.
X
Xo	Did away with the quitAction function in main.c
X	as it was unneeded.
X
Xo	Corrected read_notefile so that it wouldn't core
X	dump in the absence of a HOME variable in the
X	environment.
X
Xo	Put some speedup hacks into read_notefile,
X	the entire file is now read in one pass instead of
X	a line at a time.  Loads up appreciably faster!
X
Xo	Added some error checking around malloc's and realloc's,
X	doesn't do anything graceful!  Just checks and dies
X	if a problem is encountered.
X
Xo	Added a die() function, a quick way out for error
X	conditions.
X
Xo	Added an AddCallback definition, just an easier way
X	to do XtAddCallback...
X
Xo	Consolidated some code with the addition of the function
X	destroy_widget() in callbacks.c
X
Xo	added desensitize_all and resensitize_all -- an effort
X	in keeping the user from getting the thing in an odd
X	state...  maybe
X
Xo	made more things work via callbacks
X
Xo	added H_OFFSET and H_OFFSET definitions in Imakefile
X	for use by write_notefile() in main.c -- the purpose
X	is to correct out the offsets injected by my window
X	manager (twm) while a note is mapped to prevent the
X	windows from 'creeping' when they are saved...  if
X	someone knows a way to detect these offsets at run
X	time I'd appreciate a better idea...
X
Xo	added a Button 3 translation to the startup_button
X	to bring up a `quit' dialog box
X
Xo	...and otherwise damn near rewrote the whole thing
X207 181 500 551 INSTALL
XINSTALL notes for Notes v1.0.2
X
XIn theory all you should have to do is:
X
X	xmkmf			to create the Makefile
X	make            	to build notes
X	make install		to install notes in BINDIR
X				and notes.xbm in BITMAPDIR
X	make install.man	to install notes.man in MANDIR
X
XThings that may cause problems:
X
Xstrdup()
X
X	Notes uses a strdup() function that SunOS3.5 is
X	missing.  A replacement is included in main.c with
X	a feeble attempt made to properly 'ifdef' it in the
X	Imakefile.  If you need it and the Makefile is
X	generated without defining NEED_STRDUP, check and
X	fix the Imakefile.
X
XH_OFS / V_OFS
X
X	Various window managers do weird things to a windows
X	x and y values when they are mapped.  This prompted the
X	inclusion of settable parameters V_OFS and H_OFS in
X	the Imakefile, which ultimately effects the definitions
X	of V_OFFSET and H_OFFSET in main.c ...  You may have to
X	experiment a bit by saving your .notes files
X	repeatedly with notes mapped and checking the values
X	in .notes to get it exactly right on your system.
X204 185 500 300 MANIFEST
X   File Name        Archive #   Description
X-----------------------------------------------------------
X .notes                     1   A sample notes files
X CHANGES                    1   A history of changes
X INSTALL                    1   Installation instructions
X Imakefile                  1   an Imake makefile
X MANIFEST                   1   This shipping list
X Makefile                   1   an Imake generated makefile
X README                     1   Miscellaneous comments
X TODO                       1	Stuff that should be fixed one day
X callbacks.c                1   source
X main.c                     1   source
X notes.h                    1   source
X notes.man                  1   Manual page for notes
X notes.xbm                  1   Bitmap for notes
X patchlevel.h               1   source
X204 185 500 328 README
XREADME for Notes v1.0.2
X
XNotes is an X11R5 note pad based on the Athena Widget set.
XIt was developed on a Sun3 running SunOS3.5 and X11R5 using
Xtwm as the window manager.  As yet it has not been tested on
Xanything else.  I would appreciate reports from anyone
Xrunning it elsewhere.
X
XThere's really nothing fancy about this program, it merely keeps
Xa collection of notes in popups and saves them to a file
Xcalled .notes in your home directory.  This .notes file not only
Xsaves the contents of each note, but also the geometry of each
Xnote.
X
XTheorectically there should be no limit to the number of notes
Xthat you could have, but in practice - the list widget will run
Xoff the bottom of your screen at some point...
X
Xbob@snuffy.dracut.ma.us (Bob Smith)
X205 184 500 550 TODO
XTODO list for Notes
X
Xo	improve the man page
X
Xo	improve the state of comments in the source
X
Xo	Make Save button sensitive based on
X	a.	adding a new note
X	b.	deleting a note
X	c.	changes in note text
X	d.	change of note title
X	e.	change of note geometry
X	thereby allowing a form of feedback to the
X	user regarding a need to save changes
X
Xo	along with being able to recognize and indicate
X	when changes are in need of saving, allow
X	specifying autosave on exit
X
Xo	Be able to specify an alternate notes file
X
Xo	Fix the list widget so that when it's about to
X	hang off the screen, switch to multiple columns
X	or add a scrollbar (pending a final decision here)
X
Xo	Find a better way to get a windows geometry while
X	it's mapped and eliminate the need for H_OFS and
X	V_OFS.
END_OF_FILE
if test 5942 -ne `wc -c <'.notes'`; then
    echo shar: \"'.notes'\" unpacked with wrong size!
fi
# end of '.notes'
fi
if test -f 'CHANGES' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'CHANGES'\"
else
echo shar: Extracting \"'CHANGES'\" \(1819 characters\)
sed "s/^X//" >'CHANGES' <<'END_OF_FILE'
XCHANGES to Notes for v1.0.1
X
Xo	Added a Button 2 translation to the `Dismiss' button
X	of the Notes list that causes everything (any displayed
X	notes and the note list) to be dismissed in one action.
X
Xo	Added a Button 2 translation to the `Save' button
X	of the Notes list that causes a save operation to be
X	performed and everything dismissed.
X
Xo	Added a Button 2 translation to the Notes list widget
X	that will dismiss the associated note.
X
Xo	Did away with the quitAction function in main.c
X	as it was unneeded.
X
Xo	Corrected read_notefile so that it wouldn't core
X	dump in the absence of a HOME variable in the
X	environment.
X
Xo	Put some speedup hacks into read_notefile,
X	the entire file is now read in one pass instead of
X	a line at a time.  Loads up appreciably faster!
X
Xo	Added some error checking around malloc's and realloc's,
X	doesn't do anything graceful!  Just checks and dies
X	if a problem is encountered.
X
Xo	Added a die() function, a quick way out for error
X	conditions.
X
Xo	Added an AddCallback definition, just an easier way
X	to do XtAddCallback...
X
Xo	Consolidated some code with the addition of the function
X	destroy_widget() in callbacks.c
X
Xo	added desensitize_all and resensitize_all -- an effort
X	in keeping the user from getting the thing in an odd
X	state...  maybe
X
Xo	made more things work via callbacks
X
Xo	added H_OFFSET and H_OFFSET definitions in Imakefile
X	for use by write_notefile() in main.c -- the purpose
X	is to correct out the offsets injected by my window
X	manager (twm) while a note is mapped to prevent the
X	windows from 'creeping' when they are saved...  if
X	someone knows a way to detect these offsets at run
X	time I'd appreciate a better idea...
X
Xo	added a Button 3 translation to the startup_button
X	to bring up a `quit' dialog box
X
Xo	...and otherwise damn near rewrote the whole thing
END_OF_FILE
if test 1819 -ne `wc -c <'CHANGES'`; then
    echo shar: \"'CHANGES'\" unpacked with wrong size!
fi
# end of 'CHANGES'
fi
if test -f 'INSTALL' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'INSTALL'\"
else
echo shar: Extracting \"'INSTALL'\" \(997 characters\)
sed "s/^X//" >'INSTALL' <<'END_OF_FILE'
XINSTALL notes for Notes v1.0.1
X
XIn theory all you should have to do is:
X
X	xmkmf			to create the Makefile
X	make            	to build notes
X	make install		to install notes in BINDIR
X				and notes.xbm in BITMAPDIR
X	make install.man	to install notes.man in MANDIR
X
XThings that may cause problems:
X
X	Notes uses a strdup() function that SunOS3.5 is
X	missing.  A replacement is included in main.c with
X	a feeble attempt made to properly 'ifdef' it in the
X	Imakefile.  If you need it and the Makefile is
X	generated without defining NEED_STRDUP, check and
X	fix the Imakefile.
X
X	Various window managers do weird things to a windows
X	x and y values when they are mapped.  This prompted the
X	inclusion of settable parameters V_OFS and H_OFS in
X	the Imakefile, which ultimately effects the definitions
X	of V_OFFSET and H_OFFSET in main.c ...  You may have to
X	experiment a bit by saving your .notes files
X	repeatedly with notes mapped and checking the values
X	in .notes to get it exactly right on your system.
END_OF_FILE
if test 997 -ne `wc -c <'INSTALL'`; then
    echo shar: \"'INSTALL'\" unpacked with wrong size!
fi
# end of 'INSTALL'
fi
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(858 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
X/*
X * change the definition of H_OFS and V_OFS to match what your
X * window manager does to transient popups -- values given here
X * are for twm with a borderWidth setting of 3 -- if you have no
X * idea what I'm talking about, but you notice that saved notes seem
X * to 'creep' away from their saved positions, then you should
X * probably look into this...
X */
XH_OFS=2
XV_OFS=24
X
X#if defined(SunArchitecture) && (OSMajorVersion == 3)
X        DEFINES = -DNEED_STRDUP -DH_OFFSET=$(H_OFS) -DV_OFFSET=$(V_OFS)
X#else
X        DEFINES = -DH_OFFSET=$(H_OFS) -DV_OFFSET=$(V_OFS)
X#endif
X
X /* CDEBUGFLAGS = -g */
X           SRCS = main.c callbacks.c
X           OBJS = main.o callbacks.o
XLOCAL_LIBRARIES = XawClientLibs
X        DEPLIBS = XawClientDepLibs
X
XComplexProgramTarget(notes)
XInstallNonExec(notes.xbm, $(INCDIR)/bitmaps)
X
Xkit::
X	makekit -iMANIFEST -oMANIFEST -h2
END_OF_FILE
if test 858 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'MANIFEST' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'MANIFEST'\"
else
echo shar: Extracting \"'MANIFEST'\" \(709 characters\)
sed "s/^X//" >'MANIFEST' <<'END_OF_FILE'
X   File Name		Archive #	Description
X-----------------------------------------------------------
X .notes                     1	A sample notes files
X CHANGES                    1	A history of changes
X INSTALL                    1	Installation instructions
X Imakefile                  1	an Imake makefile
X MANIFEST                   1	This shipping list
X Makefile                   1	an Imake generated makefile
X README                     1	Miscellaneous comments
X callbacks.c                2	source
X main.c                     1	source
X notes.h                    1	source
X notes.man                  1	Manual page for notes
X notes.xbm                  1	Bitmap for notes
X patchlevel.h               1	source
END_OF_FILE
if test 709 -ne `wc -c <'MANIFEST'`; then
    echo shar: \"'MANIFEST'\" unpacked with wrong size!
fi
# end of 'MANIFEST'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
echo shar: Extracting \"'Makefile'\" \(12865 characters\)
sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and <Imakefile>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.72.1.1 92/03/18 13:13:37 rws Exp $
X
X# operating system:		 SunOS 3.5
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL =  /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =  -DNOSTDHDRS
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =  -DNOSTDHDRS
X      STD_DEFINES =  -DNOSTDHDRS
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X   SIGNAL_DEFINES = -DSIGNALRETURNSINT
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS = -s
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS =  -g kmem -m 2755
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -f68881
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.138.1.1 92/11/11 09:49:19 rws Exp $
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/lib
X           BINDIR = /usr/bin/X11
X          INCROOT = /usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER =  /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X        PEXLIBSRC = $(EXTENSIONSRC)/lib/PEXlib
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X  DEPEXTENSIONLIB =  $(USRLIBDIR)/libXext.a
X     EXTENSIONLIB =   -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)  $(USRLIBDIR)/libX11.a
X             XLIB = $(EXTENSIONLIB)   -lX11
X
X      DEPXAUTHLIB =  $(USRLIBDIR)/libXau.a
X         XAUTHLIB =   -lXau
X      DEPXDMCPLIB =  $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =   -lXdmcp
X
X        DEPXMULIB =  $(USRLIBDIR)/libXmu.a
X           XMULIB =   -lXmu
X
X       DEPOLDXLIB =  $(USRLIBDIR)/liboldX.a
X          OLDXLIB =   -loldX
X
X      DEPXTOOLLIB =  $(USRLIBDIR)/libXt.a
X         XTOOLLIB =   -lXt
X
X        DEPXAWLIB =  $(USRLIBDIR)/libXaw.a
X           XAWLIB =   -lXaw
X
X        DEPXILIB =  $(USRLIBDIR)/libXi.a
X           XILIB =   -lXi
X
X       DEPPEXLIB =  $(USRLIBDIR)/libPEX5.a
X          PEXLIB =   -lPEX5
X
X        DEPPHIGSLIB =  $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =   -lphigs
X
X       DEPXBSDLIB =  $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =   -lXbsd
X
X LINTEXTENSIONLIB =  $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB =  $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU =  $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL =  $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW =  $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI =  $(LINTLIBDIR)/llib-lXi.ln
X          LINTPEX =  $(LINTLIBDIR)/llib-lPEX5.ln
X        LINTPHIGS =  $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
XH_OFS=2
XV_OFS=24
X
X        DEFINES = -DNEED_STRDUP -DH_OFFSET=$(H_OFS) -DV_OFFSET=$(V_OFS)
X
X           SRCS = main.c callbacks.c
X           OBJS = main.o callbacks.o
XLOCAL_LIBRARIES = $(XAWLIB) $(XMULIB) $(XTOOLLIB) $(XLIB)
X        DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X PROGRAM = notes
X
Xall:: notes
X
Xnotes: $(OBJS) $(DEPLIBS)
X	 $(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xsaber_notes:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xosaber_notes:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
Xinstall:: notes
X	 @if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  notes $(DESTDIR)$(BINDIR)
X
Xinstall.man:: notes.man
X	 @if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) notes.man $(DESTDIR)$(MANDIR)/notes.$(MANSUFFIX)
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
Xinstall:: notes.xbm
X	$(INSTALL) -c $(INSTDATFLAGS) notes.xbm $(DESTDIR) $(INCDIR)/bitmaps
X
Xkit::
X	makekit -iMANIFEST -oMANIFEST -h2
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
Xsaber:
X	# load $(ALLDEFINES) $(SRCS)
X
Xosaber:
X	# load $(ALLDEFINES) $(OBJS)
X
X# -------------------------------------------------------------------------
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
X# DO NOT DELETE
X
Xmain.o: /usr/include/stdio.h /usr/include/strings.h /usr/include/malloc.h
Xmain.o: /usr/include/sys/param.h /usr/include/machine/param.h
Xmain.o: /usr/include/sys/signal.h /usr/include/sys/types.h
Xmain.o: /usr/include/sys/sysmacros.h /usr/include/sys/stat.h
Xmain.o: /usr/include/X11/Intrinsic.h /usr/include/X11/Xlib.h
Xmain.o: /usr/include/X11/X.h /usr/include/X11/Xfuncproto.h
Xmain.o: /usr/include/X11/Xosdefs.h /usr/include/X11/Xutil.h
Xmain.o: /usr/include/X11/Xresource.h /usr/include/X11/Core.h
Xmain.o: /usr/include/X11/Composite.h /usr/include/X11/Constraint.h
Xmain.o: /usr/include/X11/Object.h /usr/include/X11/RectObj.h
Xmain.o: /usr/include/X11/StringDefs.h /usr/include/X11/Shell.h
Xmain.o: /usr/include/X11/Xaw/Box.h /usr/include/X11/Xmu/Converters.h
Xmain.o: /usr/include/X11/Xaw/Cardinals.h /usr/include/X11/Xaw/Command.h
Xmain.o: /usr/include/X11/Xaw/Label.h /usr/include/X11/Xaw/Simple.h
Xmain.o: /usr/include/X11/Xaw/Form.h /usr/include/X11/Xaw/List.h notes.h
Xmain.o: patchlevel.h
Xcallbacks.o: /usr/include/stdio.h /usr/include/malloc.h
Xcallbacks.o: /usr/include/X11/IntrinsicP.h /usr/include/X11/Intrinsic.h
Xcallbacks.o: /usr/include/X11/Xlib.h /usr/include/sys/types.h
Xcallbacks.o: /usr/include/sys/sysmacros.h /usr/include/X11/X.h
Xcallbacks.o: /usr/include/X11/Xfuncproto.h /usr/include/X11/Xosdefs.h
Xcallbacks.o: /usr/include/X11/Xutil.h /usr/include/X11/Xresource.h
Xcallbacks.o: /usr/include/strings.h /usr/include/X11/Core.h
Xcallbacks.o: /usr/include/X11/Composite.h /usr/include/X11/Constraint.h
Xcallbacks.o: /usr/include/X11/Object.h /usr/include/X11/RectObj.h
Xcallbacks.o: /usr/include/X11/CoreP.h /usr/include/X11/CompositeP.h
Xcallbacks.o: /usr/include/X11/ConstrainP.h /usr/include/X11/ObjectP.h
Xcallbacks.o: /usr/include/X11/RectObjP.h /usr/include/X11/StringDefs.h
Xcallbacks.o: /usr/include/X11/Shell.h /usr/include/X11/Xaw/Box.h
Xcallbacks.o: /usr/include/X11/Xmu/Converters.h
Xcallbacks.o: /usr/include/X11/Xaw/Cardinals.h /usr/include/X11/Xaw/Command.h
Xcallbacks.o: /usr/include/X11/Xaw/Label.h /usr/include/X11/Xaw/Simple.h
Xcallbacks.o: /usr/include/X11/Xaw/Form.h /usr/include/X11/Xaw/List.h
Xcallbacks.o: /usr/include/X11/Xaw/AsciiText.h /usr/include/X11/Xaw/Text.h
Xcallbacks.o: /usr/include/X11/Xaw/TextSink.h /usr/include/X11/Xaw/TextSrc.h
Xcallbacks.o: /usr/include/X11/Xaw/AsciiSrc.h /usr/include/X11/Xaw/AsciiSink.h
Xcallbacks.o: notes.h patchlevel.h
END_OF_FILE
if test 12865 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
fi
# end of 'Makefile'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(880 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
XREADME for Notes v1.0.1
X
XNotes is an X11R5 note pad based on the Athena Widget set.
XIt was developed on a Sun3 running SunOS3.5 and X11R5 using
Xtwm as the window manager.  As yet it has not been tested on
Xanything else.  I would appreciate reports from anyone
Xrunning it elsewhere.
X
XThere's really nothing fancy about this program, it merely keeps
Xa collection of notes in popups and saves them to a file
Xcalled .notes in your home directory.  This .notes file not only
Xsaves the contents of each note, but also the geometry of each
Xnote.
X
XTheorectically there should be no limit to the number of notes
Xthat you could have, but in practice - the list widget will run
Xoff the bottom of your screen at some point...  probably needs
Xto be fixed...  One of these days...  A problem with slow startup
Xin v1.0.0 has been cleaned up in this version.
X
Xbob@snuffy.dracut.ma.us (Bob Smith)
END_OF_FILE
if test 880 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
echo shar: Extracting \"'main.c'\" \(13099 characters\)
sed "s/^X//" >'main.c' <<'END_OF_FILE'
X/*
X * main.c
X *
X * notes - by Bob Smith <bob@snuffy.dracut.ma.us>
X */
X
X#include <stdio.h>
X#include <strings.h>
X#include <malloc.h>
X#include <sys/param.h>		/* for MAXPATHLEN */
X#include <sys/types.h>
X#include <sys/stat.h>
X
X#include <X11/Intrinsic.h>
X#include <X11/StringDefs.h>
X#include <X11/Shell.h>
X
X#include <X11/Xaw/Box.h>
X#include <X11/Xaw/Cardinals.h>
X#include <X11/Xaw/Command.h>
X#include <X11/Xaw/Label.h>
X#include <X11/Xaw/Form.h>
X#include <X11/Xaw/List.h>
X
X#include "notes.h"
X
X
X/*
X * Global Variables
X */
XXtAppContext app_con;
XWidget toplevel;
XWidget start_button;
X
XWidget **Notes;
Xchar **Titles;
X
Xchar notefile[MAXPATHLEN];
X
X
X/*
X * forward declarations
X */
Xvoid die(), write_notefile(), sensitize_start_button();
Xstatic void dismiss_all(), dismiss_note(), save_dismiss_all();
Xstatic void version(), ask_quit(), desensitize_start_button();
X
X
X/*
X * external functions
X */
X/* in callbacks.c */
Xextern void null(), show_list(), quit(), destroy_widget(), destroy_list();
Xextern Widget *make_note_widget();
X
X
X/*
X * XtActionsRec actionTable
X */
Xstatic XtActionsRec actionTable[] = {
X	{ "null",				null },
X	{ "quit",				quit },
X	{ "ask_quit",			ask_quit },
X	{ "version",			version },
X	{ "dismiss_all",		dismiss_all },
X	{ "dismiss_note",		dismiss_note },
X	{ "save_dismiss_all",	save_dismiss_all },
X};
X
X
X/*
X * fallback_resources
X */
Xstatic char *fallback_resources[] = {
X	"notes.start_button.bitmap: notes.xbm",
X	"*List.Columns: 1",
X	"*input*translations: #override \\n\
X		<Key>Return:			null() \\n\
X		<Key>Tab:				null() \\n\
X		Ctrl<Key>J:				null()",
X	"*start_button*translations: #override \\n\
X		<Key>q:					quit() \\n\
X		<Key>Q:					quit() \\n\
X		<Key>v:					version() \\n\
X		<Key>V:					version() \\n\
X		<Btn2Down>:				set() \\n\
X		<Btn2Down>,<Btn2Up>:	version() reset() \\n\
X		<Btn3Down>:				set() \\n\
X		<Btn3Down>,<Btn3Up>:	ask_quit() reset()",
X	"*Notes*dismiss_button*translations: #override \\n\
X		<Btn2Down>:				set() \\n\
X		<Btn2Down>,<Btn2Up>:	dismiss_all() reset()",
X	"*Notes*save_button*translations: #override \\n\
X		<Btn2Down>:				set() \\n\
X		<Btn2Down>,<Btn2Up>:	save_dismiss_all() reset()",
X	"*Notes*list*translations: #override \\n\
X		<Btn2Down>:				Set() \\n\
X		<Btn2Down>,<Btn2Up>:	dismiss_note() Unset()",
X		NULL
X};
X
X
X#ifdef NEED_STRDUP
X/*
X * strdup ()
X */
Xchar *
Xstrdup(s)
X	char *s;
X{
X	char *t;
X
X	if ((t = malloc(strlen(s)+1)) == NULL)
X		die("Malloc in strdup failed.");
X	strcpy(t, s);
X	return t;
X}
X#endif
X
X
X/*
X * die ()
X */
Xvoid
Xdie(s)
X	char *s;
X{
X	fprintf(stderr, "%s\n", s);
X	fflush(stderr);
X	quit();
X}
X
X
X/*
X * dismiss_all ()
X * dismiss all notes and the list widget
X */
Xstatic void
Xdismiss_all(widget, client_data, call_data)
X	Widget widget;
X	XtPointer client_data, call_data;
X{
X	int i;
X	XWindowAttributes atribs;
X
X	i = 0;
X	while (Notes[i]) {
X		XGetWindowAttributes(XtDisplay(*Notes[i]),
X			XtWindow(*Notes[i]), &atribs);
X		if (atribs.map_state != IsUnmapped) {
X			XtPopdown(*Notes[i]);
X			XtUnmapWidget(*Notes[i]);
X		}
X		i++;
X	}
X	destroy_list();
X	sensitize_start_button();
X}
X
X
X/*
X * save_dismiss_all ()
X * save the notefile and dismiss all notes and the list
X */
Xstatic void
Xsave_dismiss_all(widget, client_data, call_data)
X	Widget widget;
X	XtPointer client_data, call_data;
X{
X	write_notefile();
X	dismiss_all();
X}
X
X
X/*
X * dismiss_note ()
X * dismiss a note
X */
Xstatic void
Xdismiss_note(widget, client_data, call_data)
X	Widget widget;
X	XtPointer client_data, call_data;
X{
X	XawListReturnStruct *item;
X	Widget w;
X	XWindowAttributes atribs;
X
X	item = XawListShowCurrent(widget);
X	if (item->list_index == -1)
X		return;
X
X	w = *Notes[item->list_index];
X	XGetWindowAttributes(XtDisplay(w), XtWindow(w), &atribs);
X
X	if (atribs.map_state != IsUnmapped) {
X		XtPopdown(w);
X		XtUnmapWidget(w);
X	}
X}
X
X
X/*
X * ask_quit()
X */
Xstatic void
Xask_quit(widget, client_data, call_data)
X	Widget widget;
X	XtPointer client_data, call_data;
X{
X	Widget popup, form, prompt;
X	Widget confirm_button, filler_box, cancel_button;
X	Dimension top_w, pop_w;
X	Position x, y;
X
X	desensitize_start_button();
X
X	popup = XtCreatePopupShell("Quit",
X		transientShellWidgetClass, toplevel,
X		NULL, ZERO);
X
X	form = XtCreateManagedWidget("form",
X		formWidgetClass, popup,
X		NULL, ZERO);
X
X	prompt = XtVaCreateManagedWidget("prompt",
X		labelWidgetClass, form,
X		XtNlabel, "Quit, Are you sure?",
X		XtNborderWidth, 0,
X		XtNtop, XawChainTop,
X		XtNbottom, XawChainTop,
X		XtNleft, XawChainLeft,
X		XtNright, XawChainLeft,
X		NULL);
X
X	confirm_button = XtVaCreateManagedWidget("confirm_button",
X		commandWidgetClass, form,
X		XtNlabel, "Yes",
X		XtNwidth, 64,
X		XtNfromVert, prompt,
X		XtNtop, XawChainBottom,
X		XtNbottom, XawChainBottom,
X		XtNleft, XawChainLeft,
X		XtNright, XawChainLeft,
X		NULL);
X		AddCallback(confirm_button, quit, NULL);
X
X	filler_box = XtVaCreateManagedWidget("filler_box",
X		boxWidgetClass, form,
X		XtNwidth, 64,
X		XtNborderWidth, 0,
X		XtNfromHoriz, confirm_button,
X		XtNfromVert, prompt,
X		XtNtop, XawChainBottom,
X		XtNbottom, XawChainBottom,
X		XtNleft, XawChainLeft,
X		XtNright, XawChainRight,
X		NULL);
X
X	cancel_button = XtVaCreateManagedWidget("cancel_button",
X		commandWidgetClass, form,
X		XtNlabel, "No",
X		XtNwidth, 64,
X		XtNfromHoriz, filler_box,
X		XtNfromVert, prompt,
X		XtNtop, XawChainBottom,
X		XtNbottom, XawChainBottom,
X		XtNleft, XawChainRight,
X		XtNright, XawChainRight,
X		NULL);
X		AddCallback(cancel_button, destroy_widget, NULL);
X		AddCallback(cancel_button, sensitize_start_button, NULL);
X
X	XtRealizeWidget(popup);
X
X	XtVaGetValues(toplevel, XtNwidth, &top_w, NULL);
X	XtVaGetValues(popup, XtNwidth, &pop_w, NULL);
X	XtTranslateCoords(toplevel, (top_w-pop_w)/2, 0, &x, &y);
X	XtVaSetValues(popup, XtNx, x, XtNy, y, NULL);
X
X	XtPopup(popup, XtGrabNone);
X}
X
X/*
X * sort_titles ()
X * sort the titles and return the new index of where widget
X * `j' ended up
X */
Xint
Xsort_titles(j)
X	int j;
X{
X	int i;
X	char *s;
X
X	i = 0;
X	while (Titles[i] && Titles[i+1]) {
X		if (strcmp(Titles[i], Titles[i+1]) > 0) {
X			if (j == i)
X				j++;
X			else
X				if (j == i+1)
X					j--;
X			s = Titles[i];
X			Titles[i] = Titles[i+1];
X			Titles[i+1] = s;
X			s = (char *) Notes[i];
X			Notes[i] = Notes[i+1];
X			Notes[i+1] = (Widget *) s;
X			i = 0;
X		} else
X			i++;
X	}
X	return j;
X}
X
X
X/*
X * read_notefile ()
X * read the notefile and make a note widget for each note
X */
Xvoid
Xread_notefile()
X{
X	FILE *fp;
X	char title[80];
X	char *buffer, *s, *t;
X	int i, x, y, w, h;
X	char *getenv();
X	struct stat sbuf;
X
X	Notes = (Widget **) malloc(sizeof(char *));
X	Titles = (char **) malloc(sizeof(char *));
X	if (!Notes || !Titles)
X		die("Malloc in read_notefile failed.");
X	*Notes = NULL;
X	*Titles = NULL;
X
X	/*
X	 * check the current directory, and then the HOME
X	 * directory...  if there is no .notes file, free the
X	 * temp buffer and get out of here leaving notefile
X	 * pointing to the HOME directory
X	 */
X	strcpy(notefile, NOTEFILE);
X	if ((fp = fopen(notefile, "r")) == NULL) {
X		if ((s = getenv("HOME")) == NULL)
X			return;
X		strcpy(notefile, s);
X		strcat(notefile, "/");
X		strcat(notefile, NOTEFILE);
X		if ((fp = fopen(notefile, "r")) == NULL)
X			return;
X	}
X
X	/*
X	 * check the size of the notes file and allocate a buffer
X	 * of appropriate size
X	 */
X	if (fstat(fileno(fp), &sbuf) == 0) {
X		if ((buffer = malloc(sbuf.st_size+1)) == NULL) {
X			fclose(fp);
X			die("Malloc of buffer in read_notefile failed.");
X		}
X	} else {
X		fclose(fp);
X		die("Can't stat notes file.");
X	}
X
X	/*
X	 * read the notes file into the temp buffer
X	 */
X	if ((i = fread(buffer, sbuf.st_size, 1, fp)) != 1) {
X		fclose(fp);
X		die("Read error on notes file.");
X	}
X	buffer[sbuf.st_size] = '\0';
X	fclose(fp);
X
X	/*
X	 * spin through the temp buffer and setup the initial
X	 * state of the NoteStruct pointers...
X	 */
X	s = buffer;
X	i = 0;
X	while (*s) {
X		if (*s == '\f') {
X			*s = '\0';
Xspeed_hack:;
X			i++;
X			Notes = (Widget **) realloc(Notes, (i+1)*sizeof(char *));
X			Titles = (char **) realloc(Titles, (i+1)*sizeof(char *));
X			if (!Notes || !Titles)
X				die("Realloc in read_notefile failed.");
X			s++;
X			if ((t = index(s, '\n')) == NULL)
X				die("Oop! No newline at end of title?");
X			else {
X				sscanf(s, "%d %d %d %d %[^\n]", &x, &y, &w, &h, title);
X				s = ++t;
X				if ((t = index(s, '\f')) != NULL) *t = '\0';
X				Notes[i-1] = make_note_widget(title, x, y, w, h, s);
X				Notes[i] = NULL;
X				Titles[i-1] = strdup(title);
X				Titles[i] = NULL;
X				if (t) {
X					s = t;
X					/* this is ugly, but it works...  */
X					goto speed_hack;
X				}
X			}
X		} else
X			s++;
X	}
X	free(buffer);
X	(void) sort_titles(0);
X}
X
X
X/*
X * alloc_new_note ()
X * make a new note
X */
Xint
Xalloc_new_note(title)
X	char *title;
X{
X	int i;
X	Position top_w, x, y;
X
X	XtVaGetValues(toplevel, XtNwidth, &top_w, NULL);
X	XtTranslateCoords(toplevel, (top_w - 512)/2, 0, &x, &y);
X
X	i = 0;
X	while (Notes[i]) i++;
X	i++;
X	Notes = (Widget **) realloc(Notes, (i+1)*sizeof(char *));
X	Titles = (char **) realloc(Titles, (i+1)*sizeof(char *));
X	if (!Notes || !Titles)
X		die("Realloc in alloc_new_note failed.");
X	Notes[i-1] = make_note_widget(title, x, y, 500, 300, "");
X	Notes[i] = NULL;
X	Titles[i-1] = strdup(title);
X	Titles[i] = NULL;
X	return sort_titles(i-1);
X}
X
X
X/*
X * unalloc_note ()
X */
Xvoid
Xunalloc_note(widget)
X	Widget widget;
X{
X	int i;
X
X	i = 0;
X	while (Notes[i]) {
X		if (*Notes[i] == widget) {
X			while (Notes[i+1]) {
X				Notes[i] = Notes[i+1];
X				Titles[i] = Titles[i+1];
X				i++;
X			}
X			Notes[i] = NULL;
X			Titles[i] = NULL;
X			Notes = (Widget **) realloc(Notes, (i+1)*sizeof(char *));
X			Titles = (char **) realloc(Titles, (i+1)*sizeof(char *));
X			if (!Notes || !Titles)
X				die("Realloc in unalloc_note failed.");
X			return;
X		}
X		i++;
X	}
X}
X
X
X/*
X * write_notefile ()
X */
Xvoid
Xwrite_notefile()
X{
X	FILE *fp;
X	int i;
X	Dimension w, h;
X	Position x, y;
X	String title, text;
X	XWindowAttributes atribs;
X
X	if ((fp = fopen(notefile, "w")) == NULL)
X		return;
X
X	i = 0;
X	while (Notes[i]) {
X		XtVaGetValues(*Notes[i], XtNtitle, &title,
X			XtNx, &x, XtNy, &y, NULL);
X		XGetWindowAttributes(XtDisplay(*Notes[i]),
X			XtWindow(*Notes[i]), &atribs);
X		/*
X		 * this hack is the only way I know for now of eliminating
X		 * 'creeping' windows caused by the offset injected into
X		 * the x and y values of a window when they're mapped by
X		 * a window manager such as twm...  there's undoubtedly
X		 * a more elegant approach, but I don't know how to
X		 * do it yet! :-)
X		 */
X		if (atribs.map_state != IsUnmapped) {
X			x -= H_OFFSET;
X			y -= V_OFFSET;
X		}
X		XtVaGetValues(XtNameToWidget(*Notes[i], "*note"),
X			XtNstring, &text, XtNwidth, &w, XtNheight, &h, NULL);
X		fprintf(fp, "\f%d %d %d %d %s\n%s", x, y, w, h, title, text);
X		i++;
X	}
X	fclose(fp);
X}
X
X
X/*
X * desensitize_start_button ()
X */
Xstatic void
Xdesensitize_start_button(widget, client_data, call_data)
X	Widget widget;
X	XtPointer client_data, call_data;
X{
X	Widget w;
X
X	w = XtNameToWidget(toplevel, "*start_button");
X	if (w)
X		XtVaSetValues(w, XtNsensitive, False, NULL);
X}
X
X
X/*
X * sensitize_start_button ()
X */
Xvoid
Xsensitize_start_button(widget, client_data, call_data)
X	Widget widget;
X	XtPointer client_data, call_data;
X{
X	Widget w;
X
X	w = XtNameToWidget(toplevel, "*start_button");
X	if (w)
X		XtVaSetValues(w, XtNsensitive, True, NULL);
X}
X
X/*
X * version ()
X */
Xstatic void
Xversion(widget, client_data, call_data)
X	Widget widget;
X	XtPointer client_data, call_data;
X{
X	Widget w, popup, form, prompt, dismiss_button;
X	static char tmp[BUFSIZ];
X	Position top_w, pop_w, x, y;
X
X	desensitize_start_button();
X
X	popup = XtCreatePopupShell("Version",
X		transientShellWidgetClass, toplevel,
X		NULL, ZERO);
X
X	form = XtCreateManagedWidget("form",
X		formWidgetClass, popup,
X		NULL, ZERO);
X
X	sprintf(tmp, "Notes v%d.%d.%d\nby %s",
X		VERSION, SUBVERSION, PATCHLEVEL, AUTHOR);
X	prompt = XtVaCreateManagedWidget("prompt",
X		labelWidgetClass, form,
X		XtNlabel, tmp,
X		XtNborderWidth, 0,
X		XtNtop, XawChainTop,
X		XtNbottom, XawChainTop,
X		XtNleft, XawChainLeft,
X		XtNright, XawChainLeft,
X		NULL);
X
X	dismiss_button = XtVaCreateManagedWidget("dismiss_button",
X		commandWidgetClass, form,
X		XtNlabel, "Dismiss",
X		XtNwidth, 64,
X		XtNfromVert, prompt,
X		XtNtop, XawChainBottom,
X		XtNbottom, XawChainBottom,
X		XtNleft, XawChainLeft,
X		XtNright, XawChainLeft,
X		NULL);
X		AddCallback(dismiss_button, destroy_widget, NULL);
X		AddCallback(dismiss_button, sensitize_start_button, NULL);
X
X	XtRealizeWidget(popup);
X
X	XtVaGetValues(toplevel, XtNwidth, &top_w, NULL);
X	XtVaGetValues(popup, XtNwidth, &pop_w, NULL);
X	XtTranslateCoords(toplevel, (top_w-pop_w)/2, 0, &x, &y);
X	XtVaSetValues(popup, XtNx, x, XtNy, y, NULL);
X
X	XtPopup(popup, XtGrabNone);
X}
X
X
X/*
X * main ()
X */
Xmain(argc, argv)
X	int argc;
X	char *argv[];
X{
X	Widget start_button;
X
X	toplevel = XtAppInitialize(&app_con, "notes",
X		NULL, ZERO,				/* options, option count */
X		&argc, argv,			/* command line options */
X		fallback_resources,		/* fallback resources */
X		NULL, ZERO);			/* other args */
X
X	XtAppAddActions(app_con, actionTable, XtNumber(actionTable));
X
X	start_button = XtCreateManagedWidget("start_button",
X		commandWidgetClass, toplevel,
X		NULL, ZERO);
X		AddCallback(start_button, desensitize_start_button, NULL);
X		AddCallback(start_button, show_list, NULL);
X
X	XtRealizeWidget(toplevel);
X	read_notefile();
X	XtAppMainLoop(app_con);
X}
END_OF_FILE
if test 13099 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
fi
# end of 'main.c'
fi
if test -f 'notes.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'notes.h'\"
else
echo shar: Extracting \"'notes.h'\" \(341 characters\)
sed "s/^X//" >'notes.h' <<'END_OF_FILE'
X/*
X * notes.h
X *
X * notes - by Bob Smith <bob@snuffy.dracut.ma.us>
X */
X
X#include "patchlevel.h"
X
X#ifndef TRUE
X# define TRUE 1
X#endif
X#ifndef FALSE
X# define FALSE 0
X#endif
X
X#define NOTEFILE ".notes"
X
X#define XtGrandParent(w) XtParent(XtParent(w))
X
X#define AddCallback(w, callback, closure) \
X	XtAddCallback(w, XtNcallback, callback, closure)
END_OF_FILE
if test 341 -ne `wc -c <'notes.h'`; then
    echo shar: \"'notes.h'\" unpacked with wrong size!
fi
# end of 'notes.h'
fi
if test -f 'notes.man' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'notes.man'\"
else
echo shar: Extracting \"'notes.man'\" \(968 characters\)
sed "s/^X//" >'notes.man' <<'END_OF_FILE'
X.TH NOTES 1 "October 1992" X11R5
X.SH NAME
Xnotes \- X window system notepad
X.SH SYNOPSIS
X.B notes
X[
X.I \-toolkitoptions ...
X]
X.SH DESCRIPTION
X.I notes
Xprovides a mechanism for manipulating on-screen notes.  Notes may be
Xdisplayed, edited, and saved.  In addition, any on-screen note may be
Xresized to any arbitrary size either when it is created or at a later time.
X.SH OPTIONS
X.PP
X.I notes
Xaccepts all of the standard X Toolkit command line options.
X.SH "FILES"
X~/.notes
X.PP
XWhen
X.I notes
Xfirst starts, it looks for a file called ``.notes'' in the current
Xdirectory.  If not found, it will then look in your HOME directory
Xfor this file.
X.SH BUGS
XThere is no indicator of unsaved changes.
XIf the system should go down while unsaved changes exist in a note
Xor notes, those changes will be lost.
X.PP
XThere is no way to specify an alternate notefile.
X.PP
XThis man page could use some help on the subject of useful
Xresources.
X.SH AUTHOR
XBob Smith, bob@snuffy.dracut.ma.us
END_OF_FILE
if test 968 -ne `wc -c <'notes.man'`; then
    echo shar: \"'notes.man'\" unpacked with wrong size!
fi
# end of 'notes.man'
fi
if test -f 'notes.xbm' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'notes.xbm'\"
else
echo shar: Extracting \"'notes.xbm'\" \(3278 characters\)
sed "s/^X//" >'notes.xbm' <<'END_OF_FILE'
X#define notes_width 64
X#define notes_height 64
Xstatic char notes_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff,
X   0xff, 0xff, 0xff, 0x3f, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
X   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
X   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
X   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x40,
X   0x02, 0x00, 0xdc, 0x80, 0x01, 0x00, 0x00, 0x40, 0x02, 0x00, 0x58, 0xce,
X   0xe7, 0x78, 0x00, 0x40, 0x02, 0x00, 0x5c, 0x9b, 0xb1, 0x4d, 0x00, 0x40,
X   0x02, 0x00, 0xb4, 0xd9, 0xf8, 0x3d, 0x00, 0x40, 0x02, 0x00, 0xb6, 0xcd,
X   0x1e, 0x32, 0x00, 0x40, 0x02, 0x00, 0x36, 0x87, 0xf3, 0x1e, 0x00, 0x40,
X   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
X   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
X   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x7e, 0x00,
X   0x00, 0x7e, 0x00, 0x40, 0x02, 0x00, 0xc3, 0x00, 0x00, 0xc3, 0x00, 0x40,
X   0x02, 0x00, 0x99, 0x00, 0x00, 0x99, 0x00, 0x40, 0x02, 0x00, 0xdb, 0x00,
X   0x00, 0xdb, 0x00, 0x40, 0x06, 0x00, 0x5a, 0x00, 0x00, 0x5a, 0x00, 0x60,
X   0xfc, 0xff, 0xdb, 0xff, 0xff, 0xdb, 0xff, 0x3f, 0x00, 0x00, 0x18, 0x00,
X   0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00,
X   0xfc, 0xff, 0xdb, 0xff, 0xff, 0xdb, 0xff, 0x3f, 0x06, 0x00, 0x5a, 0x00,
X   0x00, 0x5a, 0x00, 0x60, 0x02, 0x00, 0xdb, 0x00, 0x00, 0xdb, 0x00, 0x40,
X   0x02, 0x00, 0x99, 0x00, 0x00, 0x99, 0x00, 0x40, 0x02, 0x00, 0xc3, 0x00,
X   0x00, 0xc7, 0x00, 0x40, 0x02, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x40,
X   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
X   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
X   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x36, 0x87,
X   0xf3, 0x1e, 0x00, 0x40, 0x02, 0x00, 0xb6, 0xcd, 0x1e, 0x32, 0x00, 0x40,
X   0x02, 0x00, 0xb4, 0xd9, 0xf8, 0x3d, 0x00, 0x40, 0x02, 0x00, 0x5c, 0x9b,
X   0xb1, 0x4d, 0x00, 0x40, 0x02, 0x00, 0x58, 0xce, 0xe7, 0x78, 0x00, 0x40,
X   0x02, 0x00, 0xdc, 0x80, 0x01, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00,
X   0x03, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
X   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
X   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
X   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x06, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x60, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
END_OF_FILE
if test 3278 -ne `wc -c <'notes.xbm'`; then
    echo shar: \"'notes.xbm'\" unpacked with wrong size!
fi
# end of 'notes.xbm'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
echo shar: Extracting \"'patchlevel.h'\" \(190 characters\)
sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X/*
X * patchlevel.h
X *
X * notes - by Bob Smith <bob@snuffy.dracut.ma.us>
X */
X
X#define VERSION 1
X#define SUBVERSION 0
X#define PATCHLEVEL 2
X#define AUTHOR "Bob Smith <bob@snuffy.dracut.ma.us>"
END_OF_FILE
if test 190 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
fi
# end of 'patchlevel.h'
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
* Bob Smith          + mx: bob@snuffy.penfield.ny.us      *
* 838 Harmon Rd.     + uucp: ur-valhalla!snuffy!bob       *
* Penfield, NY 14526 + office|voice mail: +1 716 724-6186 *

exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
