Newsgroups: comp.sources.x
From: philb@cats.ucsc.edu (Philip Brown)
Subject: v21i002:  kdrill - A program to quiz folks on kanji, Part01/02
Message-ID: <csx-v21i002=kdrill.115455@sparky.Sterling.COM>
X-Md4-Signature: 9a8d11a44894044d57d8a5c62ca0c5e5
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Thu, 7 Oct 1993 16:55:29 GMT
Approved: chris@sterling.com

Submitted-by: philb@cats.ucsc.edu (Philip Brown)
Posting-number: Volume 21, Issue 2
Archive-name: kdrill/part01
Environment: X11R5
Supersedes: kdrill: Volume 20, Issue 134-135

[ I could not test this, other than by compiling it :-) ]
[			-- chris			]

  Here is a program to quiz folks on either english-to-kanji, or
kanji-to-english. It will quiz you on either the whole dictionary [around
6000 kanji?]  OR specific kanji, if you give the JIS-number in the
"usefile".
It can actually quiz you on kanji<-> kana readings, now, as well as be
selective about the "grade-level".

THIS REQUIRES X11 R5 !! This is because I do not think mit X11R4's Athena
Widgets handled 16-bit fonts properly. If you happen to have a 16-bit
capable libXaw, you should be okay anyway.

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then feed it
# into a shell via "sh file" or similar.  To overwrite existing files,
# type "sh file -c".
# Contents:  README Makefile defs.h game.c init.c main.c readfile.c
#   widgets.c
# Wrapped by chris@sparky on Thu Oct  7 11:48:56 1993
PATH=/bin:/usr/bin:/usr/ucb:/usr/local/bin:/usr/lbin ; export PATH
echo If this archive is complete, you will see the following message:
echo '          "shar: End of archive 1 (of 2)."'
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
  echo shar: Extracting \"'README'\" \(3487 characters\)
  sed "s/^X//" >'README' <<'END_OF_FILE'
X  README file for kanjidrill  v2.1 July 20th, 1993
X     (by Philip Brown)
X
X  Here is a program to quiz folks on either english-to-kanji, or
Xkanji-to-english. It will quiz you on either the whole dictionary [around
X6000 kanji?]  OR specific kanji, if you give the JIS-number in the
X"usefile".
XIt can actually quiz you on kanji<-> kana readings, now, as well as be
Xselective about the "grade-level".
X
XTHIS REQUIRES X11 R5 !! This is because I do not think mit X11R4's Athena
XWidgets handled 16-bit fonts properly. If you happen to have a 16-bit
Xcapable libXaw, you should be okay anyway.
X
X  I use the PD kanjidic file from monu6.cc.monash.edu.au: I do not include
Xit, as it is 400K. There is also a mirror at ftp.uwtc.washington.edu, but
Xthey have not updated to the latest version as of this writing.
X
X  For the usefile, one number per entry, in hex, at the beginning of the
Xline. NO TRAILING SPACE!! Anything after will be treated as a comment, so
Xyou can notate the meaning of each kanji. A nifty useful usefile is
Xincluded.
X
XThe approximate format of any kanjidic file used should be:
X
Xkk 3333 .... Fxxx Gxxx .... nnnn  nnnn  nn {english} {english}
X
XWhere kk is the 16-bit kanji value seen as two 8-bit vals.(MSB,LSB)
X'....' is any char any number of times, except for things starting with
X"F" or "G"
XFxxx is a frequency of use rating.
XGxxx is a grade level rating.
Xnn is 16-bit kana interpretation with spaces between different ones.
XThere may be any number of {english} segments, also.
XNote that the braces {} MUST be included there.
X
XUnfortunately, "kanjidic" does not have english translations for some
Xentries, and does not have kana for others. Depending on whether the
Xprogram is in "showenglish" mode, or "showkana" mode, entries will be
Xskiped if they do not have the required information to display.
X(When you change modes, however, the entries will again become valid, as
Xall entries in kanjidic have at LEAST one type)
X
XTO CHANGE FONTS, startup files, etc, you can either edit the 'fallback'
Xresources in "init.c", or make up a resource file "KDrill", and stick it
Xin your local app-defaults file. (Or load them with xrdb)
XSample KDrill file included.
X
X
X
X
X   The neat thing about programming this drill is that it uses the Kanji in
Xthe kanji24 Xwindows font, so we don't have to store extra graphics.
XAdding new entries to the usefile is fairly simple. grep through the
Xdictionary for potential numbers, then use "xfd -fn kanji24" to check out
Xwhat the characters actually look like. Note that you have to click "Next
XPage" MANY times before getting to the actual kanji section.
X
X
XCODING NOTES:
X
X   Coding this was.. "fun".  Fairly educational. I started this program
Xalmost a year ago, because there was nothing out there like it. I made
Xsome stupid design errors, and didn't have a clue what Xrm stuff was for.
XThen there was a long hiatus, while I went through a few more quarters of
Xschool :-)
X
XAfter finding some nice code ("tetris"), the junk I found in "xterm"
Xstarted to make more sense.  Coupled with perusing certain other
Xprograms, both bad and good, made me more aware of how a "good" X program
Xshould be written.
X  I hope this program can be used as an example of a well-written
XXwindows program. I haven't got EVERYTHING in there.. but I do have a lot
Xof the things a "proper" Xwindows program should have.
X[ I even have an icon now! tee-hee..]
X
X Philip Brown philb@soda.berkeley.edu {preferred address}
X [also for the next year or so, philb@cats.ucsc.edu]
X
X
END_OF_FILE
  if test 3487 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
  fi
  # end of 'README'
fi
if test -f 'Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Makefile'\"
else
  echo shar: Extracting \"'Makefile'\" \(10277 characters\)
  sed "s/^X//" >'Makefile' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and <Imakefile>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit sun.cf to change
X
X# platform:  $XConsortium: sun.cf,v 1.72.1.1 92/03/18 13:13:37 rws Exp $
X
X# operating system:  SunOS 4.1.2
X
X# $XConsortium: sunLib.rules,v 1.7 91/12/20 11:19:47 rws Exp $
X
X.c.o:
X	$(CC) -c $(CFLAGS) $*.c
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = gcc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = gcc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -g kmem -m 2755
X
X      CDEBUGFLAGS = -O2
X        CCOPTIONS =
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.138.1.1 92/11/11 09:49:19 rws Exp $
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/lib
X           BINDIR = /usr/bin/X11
X          INCROOT = /usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X        PEXLIBSRC = $(EXTENSIONSRC)/lib/PEXlib
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X# $XConsortium: sunLib.tmpl,v 1.14.1.2 92/11/11 09:55:02 rws Exp $
X
XSHLIBLDFLAGS = -assert pure-text
XPICFLAGS = -fpic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X       XMULIBONLY = -lXmu
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        DEPPEXLIB =
X           PEXLIB = -lPEX5
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X         SOPEXREV = 1.0
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X          LINTPEX = $(LINTLIBDIR)/llib-lPEX5.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
XDEPLIBS = $(DEPXLIB)
X
XLOCAL_LIBRARIES = $(XLIB) $(XTOOLLIB) $(XAWLIB) $(XMULIB)
X
XINCLUDES = -I/usr/include/X11
X
XSRCS = main.c readfile.c game.c init.c widgets.c attributes.c
XOBJS = main.o readfile.o game.o init.o widgets.o attributes.o
X
X PROGRAM = kdrill
X
Xall:: kdrill
X
Xkdrill: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
Xinstall:: kdrill
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  kdrill $(DESTDIR)$(BINDIR)
X
Xinstall.man:: kdrill.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) kdrill.man $(DESTDIR)$(MANDIR)/kdrill.$(MANSUFFIX)
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
Xlint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
Xlint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
Xclean::
X	$(RM) $(PROGRAM)
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
X# -------------------------------------------------------------------------
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
END_OF_FILE
  if test 10277 -ne `wc -c <'Makefile'`; then
    echo shar: \"'Makefile'\" unpacked with wrong size!
  fi
  # end of 'Makefile'
fi
if test -f 'defs.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'defs.h'\"
else
  echo shar: Extracting \"'defs.h'\" \(1146 characters\)
  sed "s/^X//" >'defs.h' <<'END_OF_FILE'
X/*
X * defs.h for kdrill
X *   Okay, I lied.. this file has struct definitions, as
X *   well as the #defines
X */
Xextern int errno;
X
X/* enum for "changemode()" */
Xenum { GUESSMEANING, GUESSKANJI,TOGGLEKANA};
X
X
Xstruct translationstruct {
X
X	char *english;	/* english translation string.
X			 * null-terminated.
X			 * Can theoretically be any length, but
X			 * since it will all be on a single-line
X			 * text widget, that would be silly
X			 */
X
X	int frequency;		/* frequency that kanji is used */
X	int grade_level;	/* akin to  school class level */
X	XChar2b *pronunciation;
X
X};
X
X/********************************************************************
X
XSO here's the format for the translation/dictionary file I have decided
Xon so far:
X
XI changed specs. it will have to be in "kanjidic" format...
X
XTwo char high-bit-set identifier, followed by JIS number in hex.
XFollowed by stroke information? [HAS TO BE TERMINATED BY 'Gx', where
X				  'x' is any number]
XFollowed by pronunciation guide, in kana.
XFollowed by various english translations, enclosed in {}
X
X"kanjidic" often has multiple {} phrases. which leads to another nasty
Xhack  in readstructs()
X
X*/
END_OF_FILE
  if test 1146 -ne `wc -c <'defs.h'`; then
    echo shar: \"'defs.h'\" unpacked with wrong size!
  fi
  # end of 'defs.h'
fi
if test -f 'game.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'game.c'\"
else
  echo shar: Extracting \"'game.c'\" \(7453 characters\)
  sed "s/^X//" >'game.c' <<'END_OF_FILE'
X#include <stdio.h>
X#include <X11/Xlib.h>
X#include <X11/Xatom.h>
X#include <X11/Xutil.h>
X#include <Intrinsic.h>
X#include <StringDefs.h>
X#include <Xaw/Command.h>
X
X#include "defs.h"
X#include "externs.h"
X
Xint values[4];
Xint truevalue;
Xint Kanji2English=GUESSKANJI;
Xint showEnglish = True;
Xint doBell = True;
X
Xextern Display *display;
Xextern Window mainwindow;
X
Xint englishwidth=7;
Xint englishheight=11;
X
X/* setstatus:
X *  sets label for main status bar widget.
X *	( the long one at the bottom)
X */
Xvoid setstatus(s)
Xchar *s;
X{
X	XtVaSetValues(statusline,
X		      XtNlabel,s,
X		      NULL);
X}
X
X/*
X*UseThisKanji()
X*	Returns Boolean value on whether this is a "valid" kanji for us,
X*	based on usefile markings,
X*	current grade set,
X*	and whether it has english/kana translation
X*/
XBoolean UseThisKanji(kanji)
Xstruct translationstruct *kanji;
X{
X	/* nonexistant? */
X	if(kanji == NULL) return False;
X
X	/* "do not read", set by inituse ?*/
X	if(kanji == (void *) 1) return False; 
X
X	if(showEnglish){
X		if(kanji->english == NULL)
X			return False;
X		if(kanji->english[0] == '\0')
X			return False;
X	} else {
X		/* we're supposed to be showing kana.. are there any? */
X		if(kanji->pronunciation == NULL)
X			return False;
X	}
X
X	/* only thing left is to check grade level */
X
X	if(gradelevel == 0)
X		return True;
X	if(kanji->grade_level == 0)
X			return False;
X
X	if(kanji->grade_level > gradelevel)
X		return False;
X
X	return True;	
X}
X
X
X/* CountKanji
X *This routine gets called a hell of a lot:
X *	When we change grade level, and
X *	when we change kana/english display.
X *	 (the secnd being because kanjidic does not always have
X *	 english and/or kana listings
X */
Xvoid CountKanji(){
X	int counter;
X	numberofkanji=0;
X	for(counter=lowest;counter <=highest;counter++){
X		if(UseThisKanji(translations[counter])){
X			numberofkanji++;
X		}
X	}
X}
X
X/* pickkanji:
X *   picks an acceptably random kanji char
X */
X
Xint pickkanji(){
X	int rand_kanji,count;
X	
X
X	rand_kanji = random()%numberofkanji;
X
X	for(count=lowest;count<=highest;count++){
X		if(UseThisKanji(translations[count])){
X		      rand_kanji--;
X		      if(rand_kanji <0)
X			  return count;
X		}
X	}
X	fprintf(stderr,"Internal error: picked kanji out of range");
X	return 0;
X
X}
X
X/* printkanji:
X *	updates all the kanji buttons.
X */
X
Xvoid printkanji(){
X	int i,knum;
X	XChar2b onecharstring[2];
X
X	onecharstring[1].byte1 = onecharstring[1].byte2 = 0;
X
X	if(Kanji2English == GUESSKANJI){
X		knum = values[truevalue];
X		onecharstring[0].byte1 = (knum & 0xff00)>>8;
X		onecharstring[0].byte2 = (knum & 0x00ff);
X
X		XtVaSetValues(kanjiWidget[0],XtNlabel,onecharstring,NULL);
X		XtVaSetValues(kanjiWidget[1],XtNlabel,"  ",NULL);
X		XtVaSetValues(kanjiWidget[2],XtNlabel,"  ",NULL);
X		XtVaSetValues(kanjiWidget[3],XtNlabel,"  ",NULL);
X		return;
X	}
X	/* else */
X	for(i=0;i<4;i++) {
X		knum = values[i];
X
X		onecharstring[0].byte1 = (knum & 0xff00)>>8;
X		onecharstring[0].byte2 = (knum & 0x00ff);
X
X
X		XtVaSetValues(kanjiWidget[i],
X			      XtNlabel,onecharstring,
X			      XtNsensitive,True,
X			      NULL);
X
X	}
X}
X
X/* SetWidgetLabel:
X *	Convenience function to
X *	set label of four lines of english/kana.
X *	Will change fonts, dependant on "showEnglish"
X */
Xvoid SetWidgetLabel(widget,Tnum)
XWidget widget;
Xint Tnum;
X{
X
X	if(showEnglish == True){
X		XtVaSetValues(widget,
X			     XtNencoding,XawTextEncoding8bit,
X			     XtNfont,fixedfont,
X			     XtNlabel,translations[Tnum]->english,
X			     NULL);
X	} else {
X		XtVaSetValues(widget,
X			     XtNencoding,XawTextEncodingChar2b,
X			     XtNfont,smallkfont,
X			     NULL);
X		XtVaSetValues(widget,
X			      XtNlabel,translations[Tnum]->pronunciation,
X			      NULL);
X	}
X}
X/* printenglish()
X *  similar to printkanji()
X *  updates all "english" labels...
X *  EXCEPT: sometimes we want then to print kana! :-) so we use
X *  SetWidgetLabel() to do the correct type
X */
Xvoid printenglish(){
X	int i;
X
X	/* we must be guessing which character for one meaning */
X	if(Kanji2English == GUESSMEANING){
X		SetWidgetLabel(englishWidget[0],values[truevalue]);
X		XtVaSetValues(englishWidget[1],XtNlabel,"  ",XtNsensitive,False,NULL);
X		XtVaSetValues(englishWidget[2],XtNlabel,"  ",XtNsensitive,False,NULL);
X		XtVaSetValues(englishWidget[3],XtNlabel,"  ",XtNsensitive,False,NULL);
X		return;
X	}
X	/* ELSE */
X	/* we have all FOUR  active for picking*/
X	for(i=0;i<4;i++){
X		XtVaSetValues(englishWidget[i],XtNsensitive,True,NULL);
X		SetWidgetLabel(englishWidget[i],values[i]);
X	}
X}
X
X
X/* kanjitoenglish
X *	sets up question...
X *	{ "what does this symbol? choose one of the four choices"}
X *	
X *	then returns, presumably falling back to XtAppMainLoop()
X *
X *	guesskanji == GUESSKANJI : give kanji, and user guesses the meaning
X *					int English
X *	guesskanji == GUESSENGLISH : give english, and user guesses which
X *					kanji fits best. 
X */
Xvoid kanjitoenglish(guesskanji)
Xint guesskanji;
X{
X	int doloop;
X	Kanji2English=guesskanji;
X
X	/* determine which value will be correct one.. */
X	truevalue = random() %4;
X
X	/* hack for random numbers...
X	 * only picks values that are acceptable by our current
X	 *  "usefile"
X	 */
X	values[0] = pickkanji();
X	values[1] = pickkanji();
X	values[2] = pickkanji();
X	values[3] = pickkanji();
X
X	/* now weed out duplicates.. */
X	doloop = 0;
X	do{
X		if((values[0] == values[1]) || (values[0] == values[2])
X		    || values[0] == values[3] ){
X			values[0] = pickkanji();
X			doloop=1;
X		} else
X		if(values[1] == values[2] || values[1] == values[3]){
X			values[1] = pickkanji();
X			doloop=1;
X		} else 
X		if(values[2] == values[3]){
X			values[2] = pickkanji();
X			doloop=1;
X		} else
X			doloop = 0;
X	}while(doloop);
X
X	DescribeCurrent(values[truevalue]);
X
X	printkanji();	/* update labels */
X	printenglish(); /* likewise      */
X	switch(guesskanji){
X		case GUESSKANJI:
X			XtVaSetValues(kanjimode,XtNsensitive,False,NULL);
X			XtVaSetValues(englishmode,XtNsensitive,True,NULL);
X			break;
X		case GUESSMEANING:
X			XtVaSetValues(kanjimode,XtNsensitive,True,NULL);
X			XtVaSetValues(englishmode,XtNsensitive,False,NULL);
X			break;
X	}
X	
X}
X
X
X/* englishcallback:
X *	Handles clicking on "english" widgets.
X *	Only really neccessary if we are guessing the meaning of a
X *	kanji character
X */
Xvoid englishcallback(w,data,calldata)
XWidget w;
XXtPointer data;XtPointer calldata;
X{
X	if(Kanji2English!= GUESSKANJI)
X		return;
X	if(data == (XtPointer) truevalue){
X		setstatus("Correct!");
X		kanjitoenglish(GUESSKANJI);
X	} else {
X		if(doBell)
X			XBell(display,100);
X		setstatus("Incorrect.");
X	}
X
X}
X
X/*
X *handles top four kanji buttons at top
X */
Xvoid kanjicallback(w,data,calldata)
XWidget w;XtPointer data;XtPointer calldata;
X{
X	if(Kanji2English != GUESSMEANING)
X		return;
X	if(data == (XtPointer) truevalue){
X		setstatus("Correct!");
X		kanjitoenglish(GUESSMEANING);
X	} else {
X		if(doBell)
X			XBell(display,100);
X		setstatus("Incorrect.");
X	}
X}
X
X
X/* changemode:
X *   change from guessing kanji to guessing english, or vica verse,
X *	by clicking on the appropriate button
X *
X *   Also handles changing from english <->kana display,
X *   calling CountKanji(), because we have to .
X */
Xvoid ChangeMode(w,data,calldata)
XWidget w;XtPointer data;XtPointer calldata;
X{
X	int whichbutton = (int) data;
X#ifdef DEBUG
X	printf("button mode change: %d\n",whichbutton);
X#endif
X	switch(whichbutton){
X		case GUESSMEANING:
X		case GUESSKANJI:
X			kanjitoenglish(whichbutton);
X			break;
X		case TOGGLEKANA:
X#ifdef DEBUG
X			puts("We toggle kana/english now");
X#endif
X			showEnglish = !showEnglish;
X			CountKanji();
X			kanjitoenglish(Kanji2English);
X			break;
X	}
X}
X
END_OF_FILE
  if test 7453 -ne `wc -c <'game.c'`; then
    echo shar: \"'game.c'\" unpacked with wrong size!
  fi
  # end of 'game.c'
fi
if test -f 'init.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'init.c'\"
else
  echo shar: Extracting \"'init.c'\" \(5423 characters\)
  sed "s/^X//" >'init.c' <<'END_OF_FILE'
X#include <stdlib.h>
X#include <stdio.h>
X
X#include <Xos.h>
X#include <Intrinsic.h>
X#include <StringDefs.h>
X#include <Shell.h>
X#include <Xaw/Command.h>
X#include <Xaw/Label.h>
X#include <Xaw/Form.h>
X#include <Composite.h>
X#include "defs.h"
X#include "externs.h"
X
X#include "icon.xbm"
X
XXFontStruct *largekfont;
XXFontStruct *smallkfont;
XXFontStruct *fixedfont;
X
X/* I should just get rid of this, but I might use it at some
X * later date
X */
Xstatic XtActionsRec actionlist[] = {
X	{ "quit",quit },
X};
X
X/*
X * We  must have these resources set!!
X *
X * ( Note the similarity between this stuff and optionDescList[].
X *   coincidence? I think not :-)
X */
Xstatic char *fallback[] = {
X	"KDrill.noBell:     0",
X	"KDrill*usefile:    usefile", 
X	"KDrill*dictfile:   kanjidic",
X	"KDrill*kanjifont:  kanji24",
X	"KDrill*smallkanji: kanji16",
X	"KDrill*font:       fixed",
X	"KDrill*gradelevel: 0",
X	"KDrill*showkana:   0",
X	NULL
X};
X
X/* command line arguments should set the appropriate resources.. so we can
X * pull them out when wanted
X */
Xstatic XrmOptionDescRec optionDescList[] = {
X	{"-usefile",	".usefile",	XrmoptionSepArg,(caddr_t) NULL},
X	{"-dictfile",	".dictfile",	XrmoptionSepArg,(caddr_t) NULL},
X	{"-font",	".font",	XrmoptionSepArg,(caddr_t) NULL},
X	{"-kanjifont",	".kanjifont",	XrmoptionSepArg,(caddr_t) NULL},
X	{"-smallkanji",	".smallkanji",	XrmoptionSepArg,(caddr_t) NULL},
X	{"-noBell",     ".noBell",	XrmoptionNoArg, "1"},
X	{"-guessmeaning",".guessmeaning",XrmoptionNoArg,"1"},
X	{"-gradelevel", ".gradelevel",  XrmoptionSepArg,(caddr_t) NULL},	
X	{"-showkana",   ".showkana",    XrmoptionNoArg,"1"},
X};
X
X
X
X/* initgc:
X *	Initialises global gc values.
X *      We don't really need this any more. But
X *	GC's are good to have, I suppose.
X */
Xvoid initgc(){
X
X	gc =  XCreateGC(display,mainwindow,0,NULL);
X	cleargc = XCreateGC(display,mainwindow,0,NULL);
X
X	XSetForeground(display,gc,black);
X	XSetBackground(display,gc,white);
X	XSetForeground(display,cleargc,white);
X	XSetBackground(display,cleargc,black);
X
X}
X
X/* getusefile:
X *	Gets a "usefile", to abridge the full dictionary.
X *	If possible, will get it from the user's home directory,
X *	otherwise, tries current directory
X */
XFILE *getusefile(){
X	FILE *f;
X	char *homedir;
X	char fullname[100];
X
X	if(usefile == NULL) return NULL;
X	fullname[0] = '\0';
X	if(usefile[0] == '~'){
X		homedir = (char *) getenv("HOME");
X		if(homedir == NULL){
X			perror("Cannot expand '~' char. no HOME env. varriable");
X			exit(0);
X		}
X		sprintf(fullname,"%s%s",homedir,usefile);
X	} else {
X		strcpy(fullname,usefile);
X	}
X
X	if((f = fopen(fullname,"r")) == NULL){
X		puts("no usefile. using entire dictionary...");
X		usefile = NULL;
X	} else {
X		printf("using \"%s\" to abridge dictionary\n",fullname);
X	}
X	return f;
X}
X
X/* inituse:
X *	clear out global array of 'translations' (really abridgements),
X *	and set what kanji chars are appropriate to check on.
X *
X *	we set "okay" chars to have a NULL pointer stored for them in the
X *	translation table, since later, we will want to check if
X *	malloc malloc'd them properly.
X *
X *	 unacceptable chars have a pointer stored of (void *) 1
X *
X *	We should really redo this.. but either way, there would
X *	seem to be a conflict as to whether we have actually
X *	malloced memory that starts at 0x00000001, or whatever.
X *	(on a sparc, that will never happen :-) 
X *	
X */
Xvoid inituse(){
X	FILE *f;
X	int i;
X	char inbuf[100];
X
X	f = getusefile();
X
X	/* set all translations flags == NULL.
X	 *	NULL means it's okay to use this character
X	 *	
X	 */
X	if(usefile == NULL){
X		i = 0x2000;
X		while(i<0x8000){
X			translations[i++] = (void *)NULL;
X		}
X		return;
X	} else {	/* set all to UNREADABLE, for now */
X		i = 0x2000;
X		while(i<0x8000){
X			translations[i++] = (void *)1;
X		}
X	}
X
X	while(fgets(inbuf,99,f) != NULL){
X		int usechar;
X		usechar = xtoi(inbuf);
X		if( usechar<0x8000)
X			translations[usechar] = NULL;
X	}
X
X}
X
X
X/* initstuffs:
X *	calls the various init routines to setup
X *	GCs, fonts, dictionaries, and widgets
X *	(But initializing the translations is done later)
X */
X
Xstatic Pixmap iconpixmap;
X
Xvoid initstuffs(argc,argv)
Xint *argc;
Xchar *argv[];
X{
X	char tempnumber[10];
X	XWMHints wmhints;
X
X	srandom (time(NULL));
X
X	toplevel = XtVaAppInitialize(&Context,"KDrill",
X 				   optionDescList,XtNumber(optionDescList),
X 				   argc,argv,
X				   fallback,
X 				   NULL,NULL);
X
X	if(*argc >1){
X		usage();
X	}
X
X	/* this don't work?!! */
X	doBell = !GetXtBoolean("noBell","NoBell");
X
X
X	if(GetXtBoolean("guessmeaning","Guessmeaning"))
X		Kanji2English = GUESSMEANING;
X	GetXtString("gradelevel","Gradelevel",tempnumber);
X	gradelevel = atoi(tempnumber);
X	if(gradelevel>6){
X		fprintf(stderr,"Grade level >6: defaulting to All (0)\n");
X		gradelevel = 0;
X	}
X
X	/* display set in here */
X	MakeWidgets();
X
X	XtAppAddActions(Context,actionlist,XtNumber(actionlist));
X	XtRealizeWidget(toplevel);
X	mainwindow = XtWindow(form);
X
X	iconpixmap = XCreateBitmapFromData(display,mainwindow,
X					   icon_bits,icon_width,icon_height);
X
X	XtVaSetValues(toplevel,XtNiconName,"kdrill",
X				XtNiconPixmap,iconpixmap,
X				NULL);
X#ifdef OLDWAY
Xwmhints.icon_pixmap = iconpixmap;
X	wmhints.flags = IconPixmapHint;
X
X	XSetWMProperties(display,mainwindow,"kdrill","kdrill",
X			NULL,NULL, /* argv,argc */
X			NULL,&wmhints,NULL); /* size, wmhints, classhints */
X#endif /* OLDWAY */
X
X
X	white = WhitePixel(display,0);
X	black = BlackPixel(display,0);
X	initgc();
X	SetBackingStore(display,XtScreen(toplevel),XtWindow(toplevel));
X	
X}
END_OF_FILE
  if test 5423 -ne `wc -c <'init.c'`; then
    echo shar: \"'init.c'\" unpacked with wrong size!
  fi
  # end of 'init.c'
fi
if test -f 'main.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'main.c'\"
else
  echo shar: Extracting \"'main.c'\" \(5363 characters\)
  sed "s/^X//" >'main.c' <<'END_OF_FILE'
X
X#include <stdio.h>
X
X#include <Xlib.h>
X#include <Xatom.h>
X#include <Xutil.h>
X#include <Intrinsic.h>
X#include <StringDefs.h>
X#include <Xaw/Command.h>
X#include <Xaw/Label.h>
X#include <Xaw/Form.h>
X#include <Composite.h>
X
X#include "defs.h"
X#include "externs.h"
X#include "patchlevel.h"
X
Xstatic char *version = VERSION;
X
XDisplay *display;
Xint screen;
XWindow mainwindow,rootwindow;
XGC gc,cleargc;
XXtAppContext Context;
X
Xchar *dictname=NULL;
Xchar *usefile=NULL;
Xchar kanjifontname[100];
X
XXChar2b *kstring;
XXChar2b onecharstring;
X
Xunsigned long white,black;
X
X
X
X/* quitbutton, of course */
Xvoid quit(w,data,calldata)
XWidget w;
XXtPointer data,calldata;
X{
X#ifdef DEBUG
X	puts("quitting?");
X#endif
X	XtCloseDisplay(display);
X	exit(0);
X}
X
X
Xint usage(){
X	printf(" kdrill    -- Version %s\n",version);
X	fflush(stdout);
X	puts("A program to drill on kanji to english, or vica versa");
X	puts("");
X	puts("Options:");
X	puts("  -usefile usefilename         changes abridgement file of dictionary");
X	puts("  -dictfile dictfilename       changes dictionary file from");
X	puts("                               \"kanjidic\" to some other file");
X	puts("  -font fontname               changes english font");
X	puts("  -kanjifont Kanjifontname     changes LARGE kanji font");
X	puts("  -smallkanji Kanjifontname    changes small kanji font");
X	puts("  -noBell                      turns off beep for incorrect answer");
X	puts("  -guessmeaning                starts off with four kanji to one meaning");
X	puts("  -gradelevel                  define cut-off grade level:");
X	puts("                                6 is highest limit, 0 means no restrictions");
X	puts("  -showkana                    start showing kana meanings instead of english");
X	puts("");
X	puts("       The above options can also be set as resources,");
X	puts("       with the same name as their optionflag");
X	puts("");
X	exit(0);
X}
X
X/* keypress:
X * return whether got strnage key (shift, etc), or normal key.
X * returns 0 on normal key, or exits program if 'q' hit
X */
Xint keypress(key)
Xint key;
X{
X	if(key == 61)
X		exit(0);
X	else
X
X		/* sun codes for shift, control, etc */
X	switch(key){
X		case 106:
X		case 83:
X		case 26:
X			return 1;
X			break;
X		default:
X			/* printf("Got keypress %d\n",key); */
X			return 0;
X	}
X}
X
X/* GetXtNumber(), GetXtBoolean(), GetXtString():
X *	Not the "best way" to get resources...
X *	supposed to read them all in at one go.
X *	But I had reasons for reading things in at different times,
X *	and I have stuck to that model
X */
X
X/* GetXtNumber:
X *	Given resource name and and class, will attempt to look up
X *	resource value in database.
X *	Will return default of 0!!!
X */
Xint GetXtNumber(name,class)
Xchar *name,*class;
X{
X	Cardinal resourcevalue;
X	char resourcename[100],resourceclass[100];
X	XtResource resourceList=	{
X		NULL,NULL,
X		XtRCardinal,sizeof(int),0,
X		XtRCardinal,0
X	};
X
X	resourceList.resource_name = resourcename;
X	resourceList.resource_class = resourceclass;
X
X	strcpy(resourcename,name);
X	strcpy(resourceclass,class);
X
X	XtGetApplicationResources(toplevel,&resourcevalue,
X				  &resourceList,1,
X				  NULL,0);
X	return resourcevalue;
X}
X/* GetXtBoolean()
X*	see GetXtNumber
X*/
XBoolean GetXtBoolean(name,class)
Xchar *name,*class;
X{
X	Boolean resourcevalue;
X	char resourcename[100],resourceclass[100];
X
X	XtResource resourceList ={
X		NULL,NULL,
X		XtRBoolean,sizeof(Boolean),0,
X		XtRBoolean,False,
X	};
X	resourceList.resource_name = resourcename;
X	resourceList.resource_class = resourceclass;
X
X	strcpy(resourcename,name);
X	strcpy(resourceclass,class);
X
X	XtGetApplicationResources(toplevel,&resourcevalue,
X				  &resourceList,1,
X				  NULL,0);
X	return resourcevalue;
X}
X
X
X/* GetXtString:
X *	Given the resource name and class, will
X *	 copy the resource string value to
X *	 destinationstring address.
X *	Destination must be MALLOCED ARRAY!!!
X */
Xvoid GetXtString(name,class,destinationstring)
Xchar *name,*class;
Xchar *destinationstring;
X{
X	char resourcename[100],resourceclass[100];
X	char buffer[100];
X	char *returnstring = buffer;
X	
X
X	XtResource resourceList ={
X		NULL,NULL,
X		XtRString,sizeof(char *),0,
X		XtRString,"NOT SET"
X	};
X	resourceList.resource_name = resourcename;
X	resourceList.resource_class = resourceclass;
X
X	strcpy(resourcename,name);
X	strcpy(resourceclass,class);
X
X	XtGetApplicationResources(toplevel,&returnstring,
X				  &resourceList,1,
X				  NULL,0);
X	strcpy(destinationstring,returnstring);
X}
X
Xint main(argc,argv)
Xint argc;
Xchar *argv[];
X{
X
X	char usefilename[100],dict[100];
X
X	initstuffs(&argc,argv);
X
X	puts("Reading in dictionary: please wait a few moments...");
X
X	GetXtString("usefile","Usefile",usefilename);
X	GetXtString("dictfile","Dictfile",dict);
X	dictname = dict;
X	usefile = usefilename;
X#ifdef DEBUG
X	puts("");
X	printf("usefile from resources is \"%s\"\n",usefilename);
X	printf("dictfile from resources is\" %s\"\n",dictname);
X#endif
X
X	/* check for abridgements of the dictionary... */
X	inituse();
X	/* and actually read in structs of dictionary */
X	readstructs(&argc,argv);
X
X	showEnglish = ! GetXtBoolean("showkana","Showkana");
X	CountKanji();
X	if(numberofkanji<8){
X		fprintf(stderr,"There are two few kanji readable in the current configuration\n");
X		fprintf(stderr,"Please either reconfigure your usefile, or raise the grade level\n");
X		exit(0);
X	}
X
X	
X	kanjitoenglish(Kanji2English);
X	/* if pass 0, means want to guess english */
X	XtAppMainLoop(Context);
X	return 0;
X}
END_OF_FILE
  if test 5363 -ne `wc -c <'main.c'`; then
    echo shar: \"'main.c'\" unpacked with wrong size!
  fi
  # end of 'main.c'
fi
if test -f 'readfile.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'readfile.c'\"
else
  echo shar: Extracting \"'readfile.c'\" \(7193 characters\)
  sed "s/^X//" >'readfile.c' <<'END_OF_FILE'
X/*
X * This file is for just setting up the structs, etc
X */
X
X#include <stdlib.h>
X#include <stdio.h>
X#include <ctype.h>
X#include <Xfuncs.h>
X#include <Xlib.h>
X#include <Xatom.h>
X#include <Xutil.h>
X#include <Intrinsic.h>
X#include <StringDefs.h>
X#include <Xos.h>
X
X#include "defs.h"
X#include "externs.h"
X
X/* translations[] keeps track of which kanji it is okay to test the
X *	user on. Likewise with numberofkanji, highest, and lowest.
X *	YES, it is best to keep in a large array, otherwise
X *	it would be difficult to switch between grade levels.
X */
Xstruct translationstruct *translations[0x8000];
Xint numberofkanji,highest,lowest;
X
X
X/* random debugging util? */
Xvoid printline(s)
Xunsigned char *s;
X{
X	while(*s){
X		putchar(*s++);
X	}
X	putchar('\n');
X}
X
X/* Since there is no standard util to convert hex ascii to int,...
X *  have to supply our own..
X *  It isn't incredibly efficient.. let's hope the compiler is smart.
X *  arrg..
X */
Xint xtoi(s)
Xchar * s;
X{
X	int out=0;
X	sscanf(s,"%x",&out);
X	return out;
X}
X
X/* getline:
X *	reads a line (from dictionary).
X *	returns true (1) if read aline, otherwise,
X *	returns false (0);
X *
X *	used in "readstructs", below.
X */
X
Xunsigned char instring[2][512];
Xunsigned char *inptr=NULL;
Xint whichstring;
X
Xint getline(fp,s)
XFILE *fp;
Xunsigned char *s;
X{
X	if(inptr==NULL){
X		inptr= &instring[0][100];
X		whichstring=0;
X	}
X	for(;;){
X		int i;
X		if(inptr == &instring[whichstring][100]){
X			whichstring = 1-whichstring;
X			inptr=instring[whichstring];
X			i=fread(instring[whichstring],1,100,fp);
X			if(i<100){
X				instring[whichstring][i]='\0';
X				/* okay, we put the termination signal in.
X				 * But if there is a complete line in there,
X				 * it should be read with our buffering
X				 */
X			}
X		}
X		switch(*inptr){
X			case 0:
X				*s = '\0';
X				return 0;
X			case 10:
X			case 13:
X				*inptr='\0';
X				*s++ = *inptr++;
X				return 1;
X			default:
X				*s++ = *inptr++;
X		}
X	}
X}
X
X/* nextword:
X *	Goes to first whitespace, then sets pointer to
X *	beginning of non-white-space.
X *
X *	Returns 1 on success, 0 on fail
X */
Xint nextword(stringp)
Xchar ** stringp;
X{
X	while(!isspace(**stringp)){
X		if(stringp == '\0')
X			return 0;
X		*stringp +=1;
X	}
X	/* now on space */
X	while(isspace(**stringp)){
X		if(stringp == '\0')
X			return 0;
X		*stringp +=1;
X	}
X	return 1;
X	
X}
X
X/* nextchar:
X * returns pointer to next non-whitespace char
X*/
Xunsigned char *nextchar(c)
Xunsigned char *c;
X{
X	while(isspace(*c)){
X		if(*c == '\0') break;
X		c++;
X	}
X	return c;
X}
X
X/* StripBrackets:
X *	Gets rid of those annoying {enlish}{english2} brackets.
X *	PRESUMES first char of source is '{'!!
X *      Well, actually, it nicely sets a null string if otherwise.
X */
Xvoid StripBrackets(dest,source)
Xchar *dest,*source;
X{
X	char *parse = &source[1];
X
X	if(source[0] != '{'){
X		dest[0] = '\0';
X		return;
X	}
X	/* (*dest) is always assumed to be needing a write */
X
X	do {
X		switch(*parse){
X			case '{':
X				*dest++ = ':';
X				*dest++ = ' ';
X				break;
X			case '}':
X				break;
X			default:
X				*dest++ = *parse;				
X		}
X		parse++;
X	} while((*parse != '\n') && (*parse != '\0'));
X	*dest = '\0';
X	return;
X}
X
X
X/* Okay, it's not actually pronunciation we're reading.
X * We are reading the "no-yoni" and "kun-yoni" interpretation
X * in kanjidic
X */
Xvoid ReadPronunciation(Pstring,kanjinum)
Xint kanjinum;
Xchar **Pstring;
X{
X	XChar2b kanabuffer[256];
X	XChar2b *pronunciation;
X	int pronun_len;
X	unsigned char *parse = (unsigned char *) *Pstring;
X
X	pronunciation = kanabuffer;
X	/* "bad" job here.. this is just to get things working..
X	 * this method will probably skip a few kana
X	 */
X
X	if(*parse == '{'){
X		/* only english exists, so set to null */
X		translations[kanjinum] == NULL;
X		return;
X	}
X	
X	while((*parse > 127) && (*parse != '\0')){
X		/* kanjidic seems to have high bit set on
X		 * Kana.. which we need to strip both of!!
X		 */
X		pronunciation->byte1= (*parse++ & 0x7f);
X		pronunciation->byte2= (*parse++ & 0x7f);
X		pronunciation++;
X		/* skip space, and put in divider if
X		 * second reading is there
X		 */
X		while(*parse == ' ') {
X			parse++;
X			if(*parse == '\0')
X				break;
X			if(*parse >127){
X			   pronunciation->byte1 = 0x21;
X			   pronunciation->byte2 = 0x27;
X			   pronunciation++;
X			}
X		}
X	}
X	pronunciation->byte1=pronunciation->byte2 = 0;
X	pronun_len = strlen((char *) kanabuffer);
X
X	translations[kanjinum]->pronunciation =
X		(XChar2b *) malloc(pronun_len+4);
X	if(translations[kanjinum]->pronunciation == NULL){
X		fprintf(stderr,"Not enough memory to read in dictionary\n");
X		exit(0);
X	}
X	strncpy(translations[kanjinum]->pronunciation, kanabuffer, pronun_len+1);
X
X	/* now position parse pointer for next step:
X	 *  reading english
X	 */
X	while(*parse != '{'){
X		if(*parse == '\0'){
X			return;
X		}
X		parse++;
X	}
X
X	*Pstring = (char *)parse;
X}
X
X/* readstructs:
X *	the main dictionary reading routine.
X *	Fills in the global translationstruct with
X *	all that is available for each selected kanji, in
X *	Grade, "pronunciation", english translation, and
X *	frequency of use (by native speakers)
X */
Xvoid readstructs(){
X	unsigned char instring[256];
X	FILE *fp;
X
X	lowest = highest = 0x3000;
X	fp = fopen(dictname,"r");
X	if(fp == NULL){
X		perror("cannot open kanji translation file");
X		fprintf(stderr,"Looking for %s\n",dictname);
X		exit(0);
X	}
X
X	while (getline(fp,instring) != 0) {
X		int Kanji;
X		int freq,grade;
X		unsigned char *parse;
X		int instrlen;	/* length of pronunciation */
X
X		if(strlen(instring) <10) continue;
X
X		/*try to get kanji Index right away */
X		Kanji = xtoi(&instring[2]);
X
X
X		/* skip comments, and kanji not specified in
X		 * the usefile
X		 */	
X		if( (Kanji < 0x3000) || (translations[Kanji] != NULL) ){
X			continue;
X		}
X
X		parse = &instring[2];
X		if(parse == NULL){
X			continue;
X		}
X		/* now parse for grade level, frequency, and english */
X		freq = grade = 0;
X
X		nextword(&parse);
X		/* check for high bit set, which means
X		 * start of kana definition of kana
X		 */
X		/* used to have (*parse != '{')  */
X		while ( (*parse < 127)  && (*parse != '{') ) {
X			
X			switch(*parse){
X				case 'G':
X					grade = atoi(++parse);
X					break;
X				case 'F':
X					freq = atoi(++parse);
X					break;
X				default:
X					break;
X			}
X			nextword(&parse);
X		}
X		
X		
X		/**********************************************
X		 *  Now we know that we have a useable/wanted *
X		 *  dictionary definition                     *
X		 *********************************************/
X
X		if(Kanji<lowest) lowest = Kanji;
X		if (Kanji >highest) highest = Kanji;
X		
X		translations[Kanji] = (struct translationstruct *)
X			malloc(sizeof(struct translationstruct));
X		if (translations[Kanji] == NULL){
X			perror("Cannot allocate memory for translation table\n");
X			exit(errno);
X		}
X		translations[Kanji]->frequency = freq;
X		translations[Kanji]->grade_level = grade;
X
X		ReadPronunciation(&parse,Kanji);
X		/*
X		 * translations[Kanji]->pronunciation[0].byte1=0;
X		 * translations[Kanji]->pronunciation[0].byte2=0;
X		 */
X
X
X		instrlen = strlen(parse)+1;
X		translations[Kanji]->english = (char *) malloc(instrlen);
X		if(translations[Kanji]->english == NULL){
X			perror("Cannot allocate memory for translation table\n");
X			exit(errno);		
X		}
X
X		StripBrackets(translations[Kanji]->english,parse);
X
X	} /* and repeat until end of file */
X}
X
END_OF_FILE
  if test 7193 -ne `wc -c <'readfile.c'`; then
    echo shar: \"'readfile.c'\" unpacked with wrong size!
  fi
  # end of 'readfile.c'
fi
if test -f 'widgets.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'widgets.c'\"
else
  echo shar: Extracting \"'widgets.c'\" \(7005 characters\)
  sed "s/^X//" >'widgets.c' <<'END_OF_FILE'
X#include <stdio.h>
X
X#include <Xos.h>
X#include <Intrinsic.h>
X#include <StringDefs.h>
X#include <Xaw/Command.h>
X#include <Xaw/Label.h>
X#include <Xaw/Form.h>
X#include <Composite.h>
X#include "defs.h"
X#include "externs.h"
X
XWidget toplevel,form,quitbutton,statusline;
XWidget gradedisplay;
XWidget currentkanjiForm,currentkanjiGrade,currentkanjiFreq,currentkanjiNum;
XWidget kanjimode,englishmode,togglekana;
XWidget englishWidget[4],kanjiWidget[4];
X
Xint gradelevel=0;
X
X char *gradelist[8] = {
X	"Grade: All  ",
X	"Grade: One  ",
X	"Grade: Two  ",
X	"Grade: Three",
X	"Grade: Four ",
X	"Grade: Five ",
X	"Grade: Six  ",
X	"Grade: ERROR!"
X};
Xvoid changegrade(widget,data,calldata)
XWidget widget;
XXtPointer data; XtPointer calldata;
X{
X	gradelevel = gradelevel +1;
X	if(gradelevel ==7) gradelevel = 0;
X	
X	XtVaSetValues(widget,
X		      XtNlabel,gradelist[gradelevel],
X		      NULL);
X
X	/* need to recount all kanji equal or below the current level */
X	CountKanji();
X	if(numberofkanji<9){
X		XtVaSetValues(statusline,XtNlabel,"Too Few Kanji",NULL);
X		fprintf(stderr,"Too Few Kanji\n");
X		if(gradelevel==0){
X			fprintf("You must have either a too-small usefile,or a corrupted kanjidic\n");
X			exit(0);
X		}
X		changegrade(0,0,0);
X		return;
X	}
X	/* and make another puzzle... */
X	kanjitoenglish(Kanji2English);
X	return;
X}
X
X/* DescribeCurrent()
X *	Sets labels to display difficulty of
X *	Current "true" kanji"
X */
Xvoid DescribeCurrent(kanjinum)
Xint kanjinum;
X{
X	char gradelabel[10],freqlabel[10],numlabel[10];
X
X
X
X	if(translations[kanjinum]->grade_level !=0){
X		sprintf(gradelabel,"G: %4d",translations[kanjinum]->grade_level);
X	} else {
X		sprintf(gradelabel,"G:     ");
X	}
X	if(translations[kanjinum]->frequency !=0){
X		sprintf(freqlabel,"F: %4d",translations[kanjinum]->frequency);
X#ifdef DEBUG
X	printf("Describing %x\n",kanjinum);
X	printf("Freqnum %d\n",translations[kanjinum]->frequency);
X#endif
X
X	} else {
X		sprintf(freqlabel,"F:     ");
X	}
X	sprintf(numlabel,"#: %4x",kanjinum);
X
X	XtVaSetValues(currentkanjiGrade,XtNlabel,gradelabel,NULL);
X	XtVaSetValues(currentkanjiFreq,XtNlabel,freqlabel,NULL);
X	XtVaSetValues(currentkanjiNum,XtNlabel,numlabel,NULL);
X}
X
X/* MakeKanjiButtons()
X *  set up kanji button widgets at initialization
X */
Xvoid MakeKanjiButtons(){
X	int i;
X	/* make KANJI buttons */
X	for(i=0;i<4;i++){
X		char labl[20];
X		sprintf(labl,"kanji%d",i);
X
X		kanjiWidget[i]=XtVaCreateManagedWidget(
X			labl,commandWidgetClass,
X			form,
X			      XtNlabel,"",
X			      XtNwidth,50, XtNheight,50,
X			      XtNshapeStyle,XawShapeOval,
X			      XtNencoding,XawTextEncodingChar2b,
X			      XtNfont,largekfont,
X			      NULL);
X		XtAddCallback(kanjiWidget[i],XtNcallback,kanjicallback,(XtPointer)i);
X		if(i>0){
X			XtVaSetValues(kanjiWidget[i],
X				      XtNfromHoriz,kanjiWidget[i-1],
X				      NULL);
X		}
X
X	}
X	currentkanjiForm = XtVaCreateManagedWidget(
X			"curkanjiForm",formWidgetClass,form,
X			XtNhorizDistance,40,
X			XtNright,XawChainRight,XtNleft,XawChainRight,
X			XtNfromHoriz,kanjiWidget[3],NULL);
X	currentkanjiGrade = XtVaCreateManagedWidget(
X			"curkanjiGrade",labelWidgetClass,currentkanjiForm,
X			XtNlabel,"G:     ",
X			NULL);
X	currentkanjiFreq = XtVaCreateManagedWidget(
X			"curkanjiFreq",labelWidgetClass,currentkanjiForm,
X			XtNlabel,"F:     ",
X			XtNfromVert,currentkanjiGrade,
X			NULL);
X	currentkanjiNum = XtVaCreateManagedWidget(
X			"curkanjiNum",labelWidgetClass,currentkanjiForm,
X			XtNlabel,"#:     ",
X			XtNfromVert,currentkanjiFreq,
X			NULL);
X}
X/* MakeEnglishButtons:
X * Just that. initialize the english buttons that display the possible
X * guesses.
X */
Xvoid MakeEnglishButtons(){
X	int i;
X	for(i=0;i<4;i++){
X		char labl[20];
X		sprintf(labl,"english%d",i);
X
X		englishWidget[i]=XtVaCreateManagedWidget(
X			labl,commandWidgetClass,form,
X			XtNwidth,320,
X			XtNright,XawChainRight,
X			XtNleft,XawChainLeft,
X			XtNfont,fixedfont,
X			NULL);
X		
X		XtAddCallback(englishWidget[i],XtNcallback,englishcallback,(XtPointer) i);
X
X		if(i==0){
X			XtVaSetValues(englishWidget[0],
X				      XtNfromVert,currentkanjiForm,
X				      XtNvertDistance,10,
X				      NULL);
X		} else {
X			XtVaSetValues(englishWidget[i],
X				      XtNfromVert,englishWidget[i-1],
X				      NULL);
X		}
X		
X
X	}
X}
X
Xvoid initfonts(){
X	char LargeKname[100],SmallKname[100],Fixedname[100];
X
X	GetXtString("kanjifont","Kanjifont",LargeKname);
X	GetXtString("smallkanji","Smallkanji",SmallKname);
X	GetXtString("font","Font",Fixedname);
X
X#ifdef DEBUG
X	printf("kanjifont from resources is \"%s\"\n",LargeKname);
X	printf("smallkanjifont from resources is \"%s\"\n",SmallKname);
X	printf("regular font from resources is \"%s\"\n",Fixedname);
X#endif
X	largekfont = XLoadQueryFont(display,LargeKname);
X	smallkfont = XLoadQueryFont(display,SmallKname);
X	fixedfont  = XLoadQueryFont(display,Fixedname);
X	if(largekfont == NULL){
X		fprintf(stderr,"could not load large kanji font\n");
X		exit(0);
X	}
X	if(smallkfont == NULL){
X		fprintf(stderr,"could not load small kanji font\n");
X		exit(0);
X	}
X	if(fixedfont == NULL){
X		fprintf(stderr,"could not load english font??\n");
X		exit(0);
X	}
X	
X
X}
X
Xint MakeWidgets(){
X	/* I suppose I shouldn't hard-code window-width and height..
X		but it makes things easier for now.
X	*/
X	form = XtVaCreateManagedWidget("kdrill",formWidgetClass,
X					   toplevel,
X		      XtNx,200, XtNy,100,
X		      NULL);
X
X	
X	display = XtDisplay(toplevel);
X
X	initfonts();
X
X	MakeKanjiButtons();
X	MakeEnglishButtons();
X
X	kanjimode = XtVaCreateManagedWidget(
X			"kanjimode",commandWidgetClass, form,
X			XtNlabel,"Guess kanji",
X			XtNvertDistance,20,
X			XtNfromVert,englishWidget[3],
X			XtNshapeStyle,XawShapeOval,
X			NULL);
X	XtAddCallback(kanjimode,XtNcallback,ChangeMode,(XtPointer) GUESSKANJI);
X
X	englishmode = XtVaCreateManagedWidget(
X			"englishmode",commandWidgetClass, form,
X			XtNlabel,"Guess Meaning",
X			XtNvertDistance,20,
X			XtNfromVert,englishWidget[3],
X			XtNshapeStyle,XawShapeOval,
X			XtNfromHoriz,kanjimode,
X			NULL);
X	XtAddCallback(englishmode,XtNcallback,ChangeMode,(XtPointer) GUESSMEANING);
X
X	togglekana = XtVaCreateManagedWidget("togglekana",commandWidgetClass,
X					      form,
X			XtNlabel,"English/Kana",
X			XtNvertDistance,20,
X			XtNfromVert,englishWidget[3],
X			XtNshapeStyle,XawShapeOval,
X			XtNfromHoriz,englishmode,
X			NULL);
X	XtAddCallback(togglekana,XtNcallback,ChangeMode,(XtPointer) TOGGLEKANA);
X
X
X	quitbutton = XtVaCreateManagedWidget("quit",commandWidgetClass,
X					     form,
X		      XtNlabel,"quit",
X		      XtNfromVert,kanjimode,
X		      XtNshapeStyle,XawShapeEllipse,
X		      NULL);
X
X	XtAddCallback(quitbutton,XtNcallback,quit,NULL);
X
X	statusline = XtVaCreateManagedWidget("status",labelWidgetClass,
X					     form,
X		      XtNlabel,"Welcome to kanjidrill",
X		      XtNfromHoriz,quitbutton,
X		      XtNfromVert,kanjimode,
X		      XtNresize,True,
X		      NULL);
X
X	gradedisplay = XtVaCreateManagedWidget(
X			"gradedisplay",commandWidgetClass,form,
X			XtNlabel,gradelist[gradelevel],
X			XtNresize,False,
X			XtNfromVert,kanjimode,
X			XtNfromHoriz,statusline,
X			NULL);
X	XtAddCallback(gradedisplay,XtNcallback,changegrade,NULL);
X
X	return 0;
X}
END_OF_FILE
  if test 7005 -ne `wc -c <'widgets.c'`; then
    echo shar: \"'widgets.c'\" unpacked with wrong size!
  fi
  # end of 'widgets.c'
fi
echo shar: End of archive 1 \(of 2\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked both archives.
    rm -f ark[1-9]isdone
else
    echo You still must unpack the following archives:
    echo "        " ${MISSING}
fi
exit 0
exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
