Newsgroups: comp.sources.x
From: jeff@tasslehoff.interlan.com (Jeff Bailey)
Subject: v21i038:  pan - A post a note program, Part02/06
Message-ID: <1993Nov9.000702.10767@sparky.sterling.com>
X-Md4-Signature: cac7eab6c89f045fdcaba0ddd0a850b4
Sender: chris@sparky.sterling.com (Chris Olson)
Organization: Sterling Software
Date: Tue, 9 Nov 1993 00:07:02 GMT
Approved: chris@sterling.com

Submitted-by: jeff@tasslehoff.interlan.com (Jeff Bailey)
Posting-number: Volume 21, Issue 38
Archive-name: pan/part02
Environment: X11, OpenLook, XView
Supersedes: pan: Volume 16, Issue 137-142

---- Cut Here and feed the following to sh ----
#!/bin/sh
# This is part 02 of a multipart archive
# ============= pan3.0/README ==============
if test ! -d 'pan3.0'; then
    echo 'x - creating directory pan3.0'
    mkdir 'pan3.0'
fi
if test -f 'pan3.0/README' -a X"$1" != X"-c"; then
	echo 'x - skipping pan3.0/README (File already exists)'
else
echo 'x - extracting pan3.0/README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pan3.0/README' &&
XAbout Pan:
X
XPan is an Open Look X Windows Post A Note program.  It is basically a note
Xmanager program.  It organizes notes into folders.  Each note may be hidden or
Xvisible.  If it is visible, it is mapped to a window on the display.  The
Xnote's state, position, and size are "remembered" across invocations of Pan.
X
XSome of Pan's features are:
X
X    o  Multiple folders
X    o  Number of notes limited only by memory (swap space).
X    o  Re-sizable notes with full text editing capabilities.
X    o  Note text size limited only by machine resources.
X    o  Command line control language.
X    o  Flexible note searching features.
X    o  Flexible note printing features.
X
XNew Features in Version 3.0 (in no particular order):
X
X    o  Abbreviated button with user configurable menu for quick searching
X       for notes by title.
X    o  Notes now have an Action menu button with Print, Width, and Destroy
X       menu items.  (It is now harder to accidentally destroy a note.)
X    o  Width option from note's Action menu will automatically expand
X       a note to a specified character width.
X    o  Windows and the widgets within them are now created and positioned
X       better.  Pan now handles the -scale option and different fonts
X       better.
X    o  Command line control interface for Pan
X        o  X resource to control processing interval.
X        o  X resource to enable/disable logging
X    o  X resources for top, bottom, left, and right window border margins.
X       Allows for better interaction with window managers other than olwm.
X    o  X resource for title length limit in menus.  Also, better "fitting"
X       of titles in menus with proportional fonts.
X    o  Quit menu item now at bottom of Action menu.  (Fewer accidental quits).
X        o  X resource to specify default action of Action menu
X    o  X resource to limit the number of notes exposed by a single action.
X       Prevents accidental "over exposures" leading to over usage of swap
X       resources.
X    o  X resource to independently set the text subwindow font.
X    o  X resource to allow display of folder name in note's title bar.
X    o  Handles iconified notes better.
X    o  Matching notes window now re-sizable
X    o  Move notes window now re-sizable
X    o  New (different) icon for the main Pan window
X    o  Visual feedback on folder creation
X    o  All pop ups now have a class of "Pan"
X    o  X Resources to specify initial size of new notes.
X    o  Support for drag and drop of a note to another application
X
XHistory:
X
XI wrote this program after seeing a couple of X based post-it style programs
Xand deciding that none of them did exactly what I wanted.  Note that I intend
Xno insult by this statement - I simply wanted different functionality.  Pan has
Xgone through several in-house revisions.  Some of the available options
Xwere requested by individual users of the program.  Because of this, they
Xmay not seem generally useful.
X
XVersion 3.0 is the second public release of Pan.  It is greatly enhanced
Xand incorporates many user requested features.
X
XVersion 2.4 is the first version that I publicly distributed.
X
XIf you find bugs, or mis-features, or want enhancements, feel free to send
Xme e-mail.  Note, however, that I can promise nothing.  I may or may not do
Xwhat you request.  It depends upon my available free time, current work
Xload, and whether I feel it is generally desirable or feasible.
X
XCaveats:
X
XA lot of people have been using this program for quite a while, and I haven't
Xgotten a single complaint about a lost note due to program error.  However,
Xas we all know, there is always a first.  In other words, I think pan is
Xpretty trustworthy, but I wouldn't bet my life on it!
X
XVersion 3.0:
X
XI have only built and tested Pan 3.0 under Open Windows V3 on a sun4 platform.
XI have tried to remain compatible with OW2.0, but I may have accidentally
Xused a new feature, or attribute.  If Pan 3.0 won't compile or work correctly
Xunder OW2.0, get Pan 2.4 and use it.
X
X****
XSpecial thanks to the following people who helped me by Beta testing pan 3.0:
X****
X
XCharles.Ditzel@west.sun.com
Xwollborn@helios.tnt.uni-hannover.de
Xjay@vnet.ibm.com
Xbk@kullmar.kullmar.se		(Thanks for help with the compiler warnings)
Xgsipe@pyratl.ga.pyramid.com	(Thanks for the BSD support)
Xrwm26@cas.org
XMats.Larsson@eua.ericsson.se
Xamir@matis.ingr.com		(Thanks for the Imakefile)
Xian@sq.com
Xlee@sq.com
XJoe.Backo@east.sun.com
Xam@comdyn.cdsyd.oz.au		(Thanks for finding the destroy folder bug)
Xyu@math.duke.edu		(Thanks for finding the edited list bug)
Xneilb@borris.eece.unm.edu
Xdj@micromuse.co.uk
X
XIf I forgot anybody, or left something off of the list, my apologies.
X
XVersion 2.4:
X
XI've only ever built this under Open Windows (v2 & v3) on a sun4 platform.
XI don't know whether it will build and run under any other configuration.
X
XBuilding pan:
X
XBasically, pan needs the xview library, the olgx library, and the X11 library.
XIt also needs the X and xview include files.
X
XTo build pan, make sure OPENWINHOME is set in the environment and
Xthen run make.  If this doesn't work, take a look at the Makefile and
Xsee if you can modify it for your configuration.  The included Makefile
Xis pathetically simple.
X
XNote that to include drag and drop of notes to other applications, PAN_DND
Xmust be defined during the compile.  This feature is available *only* under
XOW/Xview V3.x.
X
XIf you are compiling under BSD, make sure that you (or your compiler) defines
XBSD.  This is necessary because of some header file differences.
X
XNote that if you use a more strict (or ANSI) compiler, you might get lots
Xof warnings.  I haven't gone through and made sure that I always cast the
Xreturn value from xv_get() everywhere and I might have been sloppy elsewhere
Xtoo.  I apologize if this causes any grief.
X
XSCRIPTS FOR CONTROL LANGUAGE EXECUTION
X
XTwo scripts are included for support of control language execution.  The
Xcontrol language is documented in the manual entry for pan.  However, I did
Xnot get the chance to write manual entries for the scripts.  They are 
Xvery simplistic, so using them shouldn't be a problem.  Briefly:
X
Xpancmd - Allows the queuing of control language statements to be executed
X         by pan.  Usage is:
X
Xpancmd [-user <username>] [-dir <pan directory>] [-now] <pan command> <arguments> ...
X
X    -user - specify another user name to use to locate the pan directory.
X            Uses $HOME/.pan as the default.
X
X    -dir  - specify the full pan directory path name.
X
X    -now  - attempt to signal the running pan to execute the command
X            immediately.
X
X	Command Language Syntax:
X
X	expose    title <title RE> [windowmax <max # to expose>]
X	hide      title <title RE>
X	move      source <folder> title <title RE> destination <folder>
X	newfolder folder <name>
X	newnote   [folder <folder>] [title <title>] [size <width> <height>]
X		  [location <x> <y>] [hidden|visible|veiled] [file <name>]
X	print     folder <folder> title <title RE>
X	quit
X	veil      title <title RE>
X
Xpanlog - Allows viewing and removal of the pan log file.   This file contains
X         the results of execution of control language statements.  Usage:
X
Xpanlog [-user <username>] [-dir <pan directory>] [-remove] [-quiet]
X
X    -user   - specify another user name to use to locate the pan directory.
X              Uses $HOME/.pan as the default.
X
X    -dir    - specify the full pan directory path name.
X
X    -remove - remove the log after displaying it.
X
X    -quiet  - do not display the log.
SHAR_EOF
chmod 0644 pan3.0/README ||
echo 'restore of pan3.0/README failed'
Wc_c="`wc -c < 'pan3.0/README'`"
test 7450 -eq "$Wc_c" ||
	echo 'pan3.0/README: original size 7450, current size' "$Wc_c"
fi
# ============= pan3.0/pan.h ==============
if test -f 'pan3.0/pan.h' -a X"$1" != X"-c"; then
	echo 'x - skipping pan3.0/pan.h (File already exists)'
else
echo 'x - extracting pan3.0/pan.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pan3.0/pan.h' &&
X/*
XPost A Note V3.0
XCopyright (c) 1993, Jeffrey W. Bailey
XAll rights reserved.
X
XPermission is granted to distribute this program in exact, complete
Xsource form, which includes this copyright notice, as long as no fee
Xother than media and distribution cost is charged.
X
XThis program may not be used in whole, or in part, in any other manner
Xwithout prior written permission from the author.
X
XThis program may not be distributed in modified form without prior
Xwritten permission from the author.  In other words, patches may be
Xdistributed, but modified source may not be distributed.
X
XIf there are any questions, comments or suggestions, the author may be
Xcontacted at:
X
X    jeff@rd1.interlan.com
X
X    or
X
X    Jeffrey Bailey
X    Racal-Datacom, Inc.
X    Mail Stop E-110
X    1601 N. Harrison Parkway
X    Sunrise, FL  33323-2899
X*/
X
X#ifndef  PAN
X
X#include <stdio.h>
X
X#ifdef HAS_STDLIB
X#include <stdlib.h>
X#else
Xextern char *malloc();
Xextern char *getenv();
X#endif /* HAS_STDLIB */
X
X#include <sys/types.h>
X
X#ifndef BSD
X#include <time.h>
X#include <dirent.h>
X#else
X#include <sys/dir.h>
X#define dirent direct
X#endif /* BSD */
X
X#include <sys/file.h>
X#include <sys/wait.h>
X#include <sys/time.h>
X#include <sys/resource.h>
X#include <sys/stat.h>
X#include <xview/xview.h>
X#include <xview/panel.h>
X#include <xview/openmenu.h>
X#include <xview/textsw.h>
X#include <xview/svrimage.h>
X#include <xview/icon.h>
X#include <xview/notice.h>
X#include <xview/defaults.h>
X#include <xview/seln.h>
X
X#define  PAN
X
X/* parser stuff */
Xstruct ps_component
X    {
X    struct ps_component *ps_prev; /* Pointer to previous node */
X    struct ps_component *ps_next; /* Pointer to next node */
X    char *ps_text;                /* Pointer to token text */
X    char ps_start_delim;          /* Character delimiter for start of token */
X    char ps_end_delim;            /* Character delimiter for end of token */
X    };
Xextern struct ps_component *parse_string();
X
X
X/* Linked List stuff */
X
Xstruct LLM_node   {
X                  struct LLM_node *Next;
X                  struct LLM_node *Prev;
X                  };
X
Xstruct LLM_root   {
X                  int              Init;
X                  struct LLM_node *First;
X                  struct LLM_node *Last;
X                  struct LLM_node *Current;
X                  unsigned int     Size;
X                  };
X
Xtypedef struct LLM_root LLM_root;
X
Xextern char *LLM_add();
Xextern char *LLM_first();
Xextern char *LLM_insert();
Xextern char *LLM_last();
Xextern char *LLM_next();
Xextern char *LLM_previous();
Xextern char *LLM_current();
X
X/* Pan stuff */
Xstruct resource {
X    char *a;
X    char *b;
X};
X
X#ifdef public
Xstruct resource resources [] = {
X    {"pan.initialDirectory",	"pan.initialdirectory"},
X    {"pan.noticeBeep",		"pan.noticebeep"},
X    {"pan.confirmDestroy",	"pan.confirmdestroy"},
X    {"pan.printCommand",	"pan.printcommand"},
X    {"pan.iconTransparent",	"pan.icontransparent"},
X    {"pan.folderOrder",	        "pan.folderorder"},
X    {"pan.defaultSearch",	"pan.defaultsearch"},
X    {"pan.folderInTitle",	"pan.folderintitle"},
X    {"pan.textFont",		"pan.textfont"},
X    {"pan.windowMax",		"pan.windowmax"},
X    {"pan.actionDefault",	"pan.actiondefault"},
X    {"pan.menuTextLength",	"pan.menutextlength"},
X    {"pan.setWidth",		"pan.setwidth"},
X    {"pan.logging",		"pan.logging"},
X    {"pan.topMargin",		"pan.topmargin"},
X    {"pan.bottomMargin",	"pan.bottommargin"},
X    {"pan.leftMargin",		"pan.leftmargin"},
X    {"pan.rightMargin",		"pan.rightmargin"},
X    {"pan.checkInterval",	"pan.checkinterval"},
X    {"pan.searchMenu",		"pan.searchmenu"},
X    {"pan.noteWidth",		"pan.notewidth"},
X    {"pan.noteHeight",		"pan.noteheight"}
X};
X
Xunsigned short mainicon [] = {
X#include "panmain.icon"
X};
X
Xunsigned short mainiconmask [] = {
X#include "panmain.mask.icon"
X};
X
Xunsigned short myicon [] = {
X#include "pan.icon"
X};
X
Xunsigned short myiconmask [] = {
X#include "pan.mask.icon"
X};
X
X#else /* ifdef public */
X
Xextern struct resource resources [];
Xextern unsigned short mainicon [];
Xextern unsigned short mainiconmask [];
Xextern unsigned short myicon [];
Xextern unsigned short myiconmask [];
X
X#endif /* ifdef public */
X
X/* Index number into resources array */
X#define RES_IDIR          0
X#define RES_NBEEP         1
X#define RES_CDESTROY      2
X#define RES_PCOMMAND      3
X#define RES_ITRANSPARENT  4
X#define RES_FORDER        5
X#define RES_DSEARCH       6
X#define RES_FINTITLE      7
X#define RES_TEXTFONT      8
X#define RES_WINDOWMAX     9
X#define RES_ACTIONDEF     10
X#define RES_MENUTEXTLEN   11
X#define RES_SETWIDTH      12
X#define RES_LOGGING       13
X#define RES_TOPMARGIN     14
X#define RES_BOTTOMMARGIN  15
X#define RES_LEFTMARGIN    16
X#define RES_RIGHTMARGIN   17
X#define RES_CHECKINTERVAL 18
X#define RES_SEARCHMENU    19
X#define RES_NOTEWIDTH     20
X#define RES_NOTEHEIGHT    21
X
X/* Resource default values (IDIR default is built dynamically) */
X#define RESDEF_NBEEP		TRUE
X#define RESDEF_CDESTROY		FALSE
X#define RESDEF_PCOMMAND		"/usr/ucb/lpr $FILE"
X#define RESDEF_ITRANSPARENT	FALSE
X#define RESDEF_FORDER      	"Miscellaneous"
X#define RESDEF_DSEARCH      	""
X#define RESDEF_FINTITLE     	FALSE
X#define RESDEF_TEXTFONT     	NULL
X#define RESDEF_WINDOWMAX     	20
X#define RESDEF_ACTIONDEF    	CHOICE_FOLDER
X#define RESDEF_MENUTEXTLEN	20
X#define RESDEF_SETWIDTH		80
X#define RESDEF_LOGGING		TRUE
X#define RESDEF_TOPMARGIN	25
X#define RESDEF_BOTTOMMARGIN	5
X#define RESDEF_LEFTMARGIN	5
X#define RESDEF_RIGHTMARGIN	5
X#define RESDEF_CHECKINTERVAL	60
X#define RESDEF_SEARCHMENU	"."
X#define RESDEF_NOTEWIDTH	-1
X#define RESDEF_NOTEHEIGHT	-1
X
X#ifndef public
X#define public extern
X#endif
X
X#define NOTEDIR ".pan"
X#define NOTENAM "Note_%d_%d"
X#define CTRLNAM "PanCtrl"
X#define CTRLLCK "PanCtrl.lock"
X#define ERRLNAM "PanCtrl.log"
X#define PIDNAM  "PID"
X
X#define DEFWIDTH  260
X#define DEFHEIGHT 200
X#define DEFSPACING 30
X#define DEFPANELSPACING 10
X
X/*
X    Most of the following size parameters have become estimates since I
X    implemented the new window creation algorithm
X*/
X
X#define MAINWIDTH  200
X#define MAINHEIGHT 90
X
X#define FLDRWIDTH  350
X#define FLDRHEIGHT 100
X#define FLDRSPACING 30
X
X#define DESTROYWIDTH  220
X#define DESTROYHEIGHT 280
X#define DESTROYSPACING 30
X
X#define SEARCHWIDTH  230
X#define SEARCHHEIGHT 230
X#define SEARCHSPACING 30
X
X#define MOVEWIDTH  600
X#define MOVEHEIGHT 250
X#define MOVESPACING 30
X
X/* Empirically determined scrollbar width.  How can you really find out? */
X#define SCROLLWIDTH 35
X
X#define FORCE   1
X#define NOFORCE 0
X
X#define NOTITLE "Untitled"
X
X#define MAXTITLELEN     100
X#define MAXTITLEDISLEN  8
X#define MAXSEARCHLEN    MAXTITLELEN
X#define MAXSEARCHDISLEN 12
X#define MAXBUFLEN       1024
X
X#define MAXSUBDIR      20  /* Max. len of sub dir name */
X#define MAXNAME        256 /* Max. note file name len */
X
X#define COL_ROLLOVER 10
X#define COL_MAXCOL    6
X
X#define CHOICE_ALL       "All"
X#define CHOICE_FROM_LIST "From List"
X
X#define CHOICE_QUIT    "Quit"
X#define CHOICE_MOVE    "Move Note..."
X#define CHOICE_FOLDER  "Create Folder..."
X#define CHOICE_DESTROY "Destroy Folder..."
X#define CHOICE_PRINT   "Print Note"
X
X#define ERRONDISPLAY 1
X#define ERRINLOG     0
X
Xpublic Frame  main_frame;
Xpublic Panel  main_panel;
Xpublic Menu   main_newnote;
Xpublic Menu   main_expose;
Xpublic Menu   main_print;
X
Xpublic Frame      folder_frame;
Xpublic Panel_item folder_item;
Xpublic Menu_item  folder_mitem;
X
Xpublic Frame      move_frame;
Xpublic Panel      move_panel;
Xpublic Menu_item  move_mitem;
X
Xpublic Frame      destroy_frame;
Xpublic Panel_item destroy_item;
Xpublic Menu_item  destroy_mitem;
X
Xpublic Frame      search_frame;
Xpublic Panel_item search_item;
Xpublic Panel_item search_button;
X
Xpublic int move_up, destroy_up, search_up;
X
Xenum NoteState {
X    Visible = 0,
X    Hidden  = 1,
X    Veiled  = 2
X};
Xtypedef enum NoteState NoteState;
X
Xstruct Note {
X    Rect       rect;
X    NoteState  state;
X    char       ntitle[MAXTITLELEN + 1];
X    int        mapped;
X    Frame      frame;
X    Panel      panel;
X    Textsw     textsw;
X    Panel_item title;
X    Panel_item hide;
X    Panel_item action;
X    Menu       actionmenu;
X    Panel_item cdate;
X    Panel_item ctime;
X    Icon       icon;
X#ifdef PAN_DND
X    Xv_opaque  drag_obj;
X    Xv_opaque  drag_tgt;
X    int        got_itms;
X    Xv_opaque  sel_itm1;
X    Xv_opaque  sel_itm2;
X    Xv_opaque  sel_itm3;
X#endif
X    long       crttime;
X    long       touched;
X    char       basename[MAXNAME];
X    struct SubDir *sp;
X};
X
Xstruct SubDir {
X    char           subdir[MAXSUBDIR];
X   struct LLM_root note_rt;
X};
X
Xstruct FreeWin {
X    Frame      frame;
X    Panel      panel;
X    Textsw     textsw;
X    Panel_item title;
X    Panel_item hide;
X    Panel_item action;
X    Menu       actionmenu;
X    Panel_item cdate;
X    Panel_item ctime;
X    Icon       icon;
X#ifdef PAN_DND
X    Xv_opaque  drag_obj;
X    Xv_opaque  drag_tgt;
X    int        got_itms;
X    Xv_opaque  sel_itm1;
X    Xv_opaque  sel_itm2;
X    Xv_opaque  sel_itm3;
X#endif
X};
X
Xpublic int  confirmdestroy;
Xpublic int  noticenobeep;
Xpublic int  icontransparent;
Xpublic char folderorder[2048];
Xpublic int  fintitle;
Xpublic char textfont[2048];
Xpublic int  windowmax;
Xpublic char actiondef[2048];
Xpublic int  menutextlen;
Xpublic int  setwidth;
Xpublic char widthtext[20];
Xpublic int  logging;
Xpublic int  topmargin;
Xpublic int  bottommargin;
Xpublic int  leftmargin;
Xpublic int  rightmargin;
Xpublic int  checkinterval;
Xpublic char searchmenu[2048];
Xpublic int  notewidth;
Xpublic int  noteheight;
X
Xpublic int  notecount;
X
Xpublic int  debug_on;
X
Xpublic char note_dir [MAXBUFLEN];
Xpublic char myname [MAXBUFLEN];
X
Xextern int  cleanup(), hideall(), exposeall(), hidenote(), noteaction();
Xextern int  dismissed(), frameexit(), dragdrop(), reseticon(), newtitle();
Xextern int  newnote(), exposemenu(), actionmenu(), newfolder(), folderdone();
Xextern int  notesearch(), movenote(), destroyfolder(), createfolder();
Xextern int  search_menu_proc();
Xextern Menu gen_exposemenu(), gen_prtmenu();
Xextern Notify_value child_death();
Xextern Notify_value check_ctl_file();
Xextern char *add_sorted();
X
X#ifdef PAN_DND
Xextern drag_proc();
X#endif
X
Xpublic struct LLM_root subdir_rt;
Xpublic struct LLM_root freewin_rt;
X
X#endif /* PAN */
SHAR_EOF
chmod 0644 pan3.0/pan.h ||
echo 'restore of pan3.0/pan.h failed'
Wc_c="`wc -c < 'pan3.0/pan.h'`"
test 10131 -eq "$Wc_c" ||
	echo 'pan3.0/pan.h: original size 10131, current size' "$Wc_c"
fi
# ============= pan3.0/menu.c ==============
if test -f 'pan3.0/menu.c' -a X"$1" != X"-c"; then
	echo 'x - skipping pan3.0/menu.c (File already exists)'
else
echo 'x - extracting pan3.0/menu.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pan3.0/menu.c' &&
X/*
XPost A Note V3.0
XCopyright (c) 1993, Jeffrey W. Bailey
XAll rights reserved.
X
XPermission is granted to distribute this program in exact, complete
Xsource form, which includes this copyright notice, as long as no fee
Xother than media and distribution cost is charged.
X
XThis program may not be used in whole, or in part, in any other manner
Xwithout prior written permission from the author.
X
XThis program may not be distributed in modified form without prior
Xwritten permission from the author.  In other words, patches may be
Xdistributed, but modified source may not be distributed.
X
XIf there are any questions, comments or suggestions, the author may be
Xcontacted at:
X
X    jeff@rd1.interlan.com
X
X    or
X
X    Jeffrey Bailey
X    Racal-Datacom, Inc.
X    Mail Stop E-110
X    1601 N. Harrison Parkway
X    Sunrise, FL  33323-2899
X*/
X
X#include "pan.h"
X#include <xview/font.h>
X
Xextern int errno;
Xextern char *sys_errlist[];
X
X/*
X    Routine to dynamically create a menu of all currently hidden notes
X    for the expose from list menu.
X*/
XMenu gen_exposemenu(mitem, op)
X    Menu_item mitem;
X    Menu_generate op;
X    {
X    int  cols;
X    int  count = 0;
X    int  i;
X    static Menu menu = NULL;
X    Menu_item mi;
X    char *cp;
X    char *text;
X    struct Note *np;
X    struct SubDir *sp;
X    char title[2 * MAXTITLELEN];
X
X    if(op == MENU_DISPLAY)
X        {
X        text = (char *)xv_get(mitem, MENU_STRING);
X        if(menu != NULL)
X            {
X            for(i = xv_get(menu, MENU_NITEMS); i > 0; i--)
X                {
X                xv_set(menu, MENU_REMOVE, i, NULL);
X                xv_destroy(xv_get(menu, MENU_NTH_ITEM, i));
X                }
X            xv_set(menu, MENU_NCOLS, 1, NULL);
X            }
X        else
X            {
X            menu = xv_create(NULL, MENU, NULL);
X            }
X        sp = (struct SubDir *)LLM_first(&subdir_rt);
X        while(sp != NULL)
X            {
X            if(strcmp(sp->subdir, text) == 0) break;
X            sp = (struct SubDir *)LLM_next(&subdir_rt);
X            }
X        np = (struct Note *)LLM_first(&sp->note_rt);
X        /* find first note not visible */
X        while(np != NULL && np->state == Visible)
X            {
X            np = (struct Note *)LLM_next(&sp->note_rt);
X            }
X        if(np != NULL)
X            {
X            cp = malloc(strlen(CHOICE_ALL) + 1);
X            strcpy(cp, CHOICE_ALL);
X            mi = xv_create(NULL, MENUITEM,
X                MENU_STRING, cp,
X                MENU_NOTIFY_PROC, exposemenu,
X                MENU_CLIENT_DATA, 0xFFFFFFFF,
X                MENU_RELEASE,
X                MENU_RELEASE_IMAGE,
X                NULL);
X            xv_set(menu, MENU_APPEND_ITEM, mi, NULL);
X            count++;
X            }
X        while(np != NULL)
X            {
X            if(np->state != Visible)
X                {
X                *title = 0;
X                menu_string_normalize(np->ntitle, title);
X                cp = malloc(strlen(title) + 1);
X                strcpy(cp, title);
X                mi = xv_create(NULL, MENUITEM,
X                    MENU_STRING, cp,
X                    MENU_NOTIFY_PROC, exposemenu,
X                    MENU_CLIENT_DATA, np,
X                    MENU_RELEASE,
X                    MENU_RELEASE_IMAGE,
X                    NULL);
X                xv_set(menu, MENU_APPEND_ITEM, mi, NULL);
X                count++;
X                }
X            np = (struct Note *)LLM_next(&sp->note_rt);
X            }
X        if(count == 0)
X            {
X            mi = xv_create(NULL, MENUITEM,
X                MENU_STRING, "No hidden notes",
X                MENU_NOTIFY_PROC, exposemenu,
X                MENU_CLIENT_DATA, NULL,
X                MENU_RELEASE,
X                NULL);
X            xv_set(menu, MENU_APPEND_ITEM, mi, NULL);
X            }
X        else
X            {
X            cols = menu_columns(count);
X            xv_set(menu, MENU_NCOLS, cols, NULL);
X            }
X        }
X    return(menu);
X    }
X
X/*
X    Handles the Action menu choices.
X*/
Xactionmenu(menu, mitem)
X    Menu menu;
X    Menu_item mitem;
X    {
X    char *text;
X    Menu_item pullright;
X    Menu mpullright;
X    char *ptext;
X    struct Note *np;
X
X    if(strcmp((text = (char *)xv_get(mitem, MENU_STRING)), CHOICE_QUIT) == 0)
X        {
X        cleanup(0);
X        }
X    /* Figure out if we have a print item by climbing the hierarchy */
X    mpullright = NULL;
X    pullright = (Menu_item) xv_get(menu, MENU_PARENT);
X    if(pullright != NULL)
X        mpullright = (Menu_item) xv_get(pullright, MENU_PARENT);
X    if(mpullright != NULL)
X        pullright = (Menu_item) xv_get(mpullright, MENU_PARENT);
X    if(pullright != NULL)
X        {
X        ptext = (char *)xv_get(pullright, MENU_STRING);
X        if(strcmp(ptext, CHOICE_PRINT) == 0)
X            {
X            np = (struct Note *)xv_get(mitem, MENU_CLIENT_DATA);
X            if(np == NULL)
X                {
X                notice_prompt(main_frame, NULL,
X                    NOTICE_MESSAGE_STRINGS,
X                        "No notes to print",
X                        NULL,
X                    NOTICE_BUTTON_YES, "Acknowledge",
X                    NOTICE_NO_BEEPING, noticenobeep,
X                    NULL);
X                return;
X                }
X            w_printnote(np, ERRONDISPLAY);
X            }
X        }
X    }
X
X/*
X    Routine to dynamically create a menu of all notes
X    for the action print note menu.
X*/
XMenu gen_prtmenu(mitem, op)
X    Menu_item mitem;
X    Menu_generate op;
X    {
X    int  cols;
X    int  count = 0;
X    int  i;
X    static Menu menu = NULL;
X    Menu_item mi;
X    char *cp;
X    char *text;
X    struct Note *np;
X    struct SubDir *sp;
X    char title[2 * MAXTITLELEN];
X
X    if(op == MENU_DISPLAY)
X        {
X        text = (char *)xv_get(mitem, MENU_STRING);
X        if(menu != NULL)
X            {
X            for(i = xv_get(menu, MENU_NITEMS); i > 0; i--)
X                {
X                xv_set(menu, MENU_REMOVE, i, NULL);
X                xv_destroy(xv_get(menu, MENU_NTH_ITEM, i));
X                }
X            xv_set(menu, MENU_NCOLS, 1, NULL);
X            }
X        else
X            {
X            menu = xv_create(NULL, MENU, NULL);
X            }
X        sp = (struct SubDir *)LLM_first(&subdir_rt);
X        while(sp != NULL)
X            {
X            if(strcmp(sp->subdir, text) == 0) break;
X            sp = (struct SubDir *)LLM_next(&subdir_rt);
X            }
X        np = (struct Note *)LLM_first(&sp->note_rt);
X        while(np != NULL)
X            {
X            *title = 0;
X            menu_string_normalize(np->ntitle, title);
X            cp = malloc(strlen(title) + 1);
X            strcpy(cp, title);
X            mi = xv_create(NULL, MENUITEM,
X                MENU_STRING, cp,
X                MENU_NOTIFY_PROC, actionmenu,
X                MENU_CLIENT_DATA, np,
X                MENU_RELEASE,
X                MENU_RELEASE_IMAGE,
X                NULL);
X            xv_set(menu, MENU_APPEND_ITEM, mi, NULL);
X            count++;
X            np = (struct Note *)LLM_next(&sp->note_rt);
X            }
X        if(count == 0)
X            {
X            mi = xv_create(NULL, MENUITEM,
X                MENU_STRING, "No notes to print",
X                MENU_NOTIFY_PROC, actionmenu,
X                MENU_CLIENT_DATA, NULL,
X                MENU_RELEASE,
X                NULL);
X            xv_set(menu, MENU_APPEND_ITEM, mi, NULL);
X            }
X        else
X            {
X            cols = menu_columns(count);
X            xv_set(menu, MENU_NCOLS, cols, NULL);
X            }
X        }
X    return(menu);
X    }
X
Xstatic Font panel_font;
Xstatic int  pf_width;
Xstatic int  pf_height;
Xstatic int  mitem_len;
X
Xinit_menu_string_normalize()
X    {
X    pf_width = 0;
X    panel_font = xv_get(main_panel, PANEL_FONT);
X    if(panel_font)
X        {
X        pf_width =  xv_get(panel_font, FONT_DEFAULT_CHAR_WIDTH);
X        pf_height =  xv_get(panel_font, FONT_DEFAULT_CHAR_HEIGHT);
X        }
X    mitem_len = pf_width * menutextlen;
X    }
X
Xmenu_string_normalize(src, dst)
X    char *src, *dst;
X    {
X    Font_string_dims dims;
X    int  i;
X    int  slen;
X
X    if(*src == 0)
X        {
X        strcpy(dst, NOTITLE);
X        return;
X        }
X
X    strncpy(dst, src, menutextlen);
X    dst[menutextlen] = 0;
X    if(pf_width == 0) return;
X
X    slen = strlen(src);
X
X    i = menutextlen;
X    xv_get(panel_font, FONT_STRING_DIMS, dst, &dims);
X    while(dims.width < mitem_len && i < slen)
X        {
X        dst[i] = src[i];
X        i++;
X        dst[i] = 0;
X        xv_get(panel_font, FONT_STRING_DIMS, dst, &dims);
X        }
X    while(dims.width > mitem_len)
X        {
X        i--;
X        dst[i] = 0;
X        xv_get(panel_font, FONT_STRING_DIMS, dst, &dims);
X        }
X    }
X
Xmenu_columns(count)
X    int  count;
X    {
X    int  cols = 0;
X    int  h, rh;
X
X    if(pf_width == 0)
X        {
X        cols = count / COL_ROLLOVER;
X        if(cols == 0) cols = 1;
X        if(cols == 1 && count > COL_ROLLOVER) cols = 2;
X        if(cols > COL_MAXCOL) cols = COL_MAXCOL;
X        }
X    else
X        {
X        rh = mitem_len + (mitem_len / 2);
X        h = pf_height * count;
X        while(h > rh && cols < COL_MAXCOL)
X            {
X            cols++;
X            h = pf_height * (count / cols);
X            }
X        }
X    return(cols);
X    }
SHAR_EOF
chmod 0644 pan3.0/menu.c ||
echo 'restore of pan3.0/menu.c failed'
Wc_c="`wc -c < 'pan3.0/menu.c'`"
test 9172 -eq "$Wc_c" ||
	echo 'pan3.0/menu.c: original size 9172, current size' "$Wc_c"
fi
# ============= pan3.0/move.c ==============
if test -f 'pan3.0/move.c' -a X"$1" != X"-c"; then
	echo 'x - skipping pan3.0/move.c (File already exists)'
else
echo 'x - extracting pan3.0/move.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pan3.0/move.c' &&
X/*
XPost A Note V3.0
XCopyright (c) 1993, Jeffrey W. Bailey
XAll rights reserved.
X
XPermission is granted to distribute this program in exact, complete
Xsource form, which includes this copyright notice, as long as no fee
Xother than media and distribution cost is charged.
X
XThis program may not be used in whole, or in part, in any other manner
Xwithout prior written permission from the author.
X
XThis program may not be distributed in modified form without prior
Xwritten permission from the author.  In other words, patches may be
Xdistributed, but modified source may not be distributed.
X
XIf there are any questions, comments or suggestions, the author may be
Xcontacted at:
X
X    jeff@rd1.interlan.com
X
X    or
X
X    Jeffrey Bailey
X    Racal-Datacom, Inc.
X    Mail Stop E-110
X    1601 N. Harrison Parkway
X    Sunrise, FL  33323-2899
X*/
X
X#include "pan.h"
X#include <X11/X.h>
X#include <X11/Xutil.h>
X
Xextern int errno;
Xextern char *sys_errlist[];
X
Xint applymove();
Xint movedone();
Xint chosesrc();
Xint move_resize_proc();
X
Xstatic Panel_item srctext, dsttext, notetext, srclist, dstlist, notelist;
Xstatic Panel_item appbutton;
X
Xmovenote(menu, mitem)
X    Menu menu;
X    Menu_item mitem;
X    {
X    Rect *prect;
X    int  x, y;
X    int  row;
X    struct SubDir *sp;
X    struct Note *np;
X    static XClassHint chint;
X    char buf[MAXTITLELEN + 1];
X
X    w_popupxy(&x, &y, MOVEWIDTH, MOVEHEIGHT, MOVESPACING);
X    move_mitem = mitem;
X    move_frame = xv_create(main_frame, FRAME_CMD,
X                           XV_LABEL, "Move Notes",
X                           XV_X, x,
X                           XV_Y, y,
X                           FRAME_NO_CONFIRM, TRUE,
X                           FRAME_DONE_PROC, movedone,
X                           FRAME_SHOW_RESIZE_CORNER, TRUE,
X                           WIN_EVENT_PROC, move_resize_proc,
X                           WIN_CONSUME_EVENTS,
X                               WIN_RESIZE,
X                               NULL,
X                           NULL);
X    if(move_frame == NULL)
X        {
X        notice_prompt(main_frame, NULL,
X            NOTICE_MESSAGE_STRINGS,
X                "Unable to create sub-frame (internal error)",
X                NULL,
X            NOTICE_BUTTON_YES, "Acknowledge",
X            NOTICE_NO_BEEPING, noticenobeep,
X            NULL);
X        return;
X        }
X
X    /* Set up the X class since xview doesn't */
X    chint.res_name = "pan";
X    chint.res_class = "Pan";
X    XSetClassHint((Display *)xv_get(move_frame, XV_DISPLAY),
X        xv_get(move_frame, XV_XID), &chint);
X
X    move_panel = (Panel) xv_get(move_frame, FRAME_CMD_PANEL);
X    xv_set(move_panel, WIN_RETAINED, FALSE, NULL);
X
X    srclist = xv_create(move_panel, PANEL_LIST,
X        XV_X, xv_col(move_panel, 0),
X        XV_Y, xv_row(move_panel, 1),
X        PANEL_LIST_DISPLAY_ROWS, 7,
X        PANEL_LIST_WIDTH, xv_col(move_panel, 15),
X        PANEL_CHOOSE_ONE, TRUE,
X        PANEL_READ_ONLY, TRUE,
X        PANEL_NOTIFY_PROC, chosesrc,
X        NULL);
X    srctext = xv_create(move_panel, PANEL_MESSAGE,
X        XV_X, xv_col(move_panel, 0),
X        XV_Y, xv_row(move_panel, 0),
X        PANEL_LABEL_STRING, "Source Folder",
X        NULL);
X
X    prect = (Rect *) xv_get(srclist, PANEL_ITEM_RECT);
X    dstlist = xv_create(move_panel, PANEL_LIST,
X        XV_X, prect->r_left + prect->r_width + SCROLLWIDTH + 20,
X        XV_Y, xv_row(move_panel, 1),
X        PANEL_LIST_DISPLAY_ROWS, 7,
X        PANEL_LIST_WIDTH, xv_col(move_panel, 15),
X        PANEL_CHOOSE_ONE, TRUE,
X        PANEL_READ_ONLY, TRUE,
X        NULL);
X    dsttext = xv_create(move_panel, PANEL_MESSAGE,
X        XV_X, prect->r_left + prect->r_width + SCROLLWIDTH + 20,
X        XV_Y, xv_row(move_panel, 0),
X        PANEL_LABEL_STRING, "Destination Folder",
X        NULL);
X
X    row = 0;
X    sp = (struct SubDir *) LLM_first(&subdir_rt);
X    while(sp != NULL)
X        {
X        xv_set(srclist,
X            PANEL_LIST_INSERT, row,
X            PANEL_LIST_STRING, row, sp->subdir, 
X            PANEL_LIST_CLIENT_DATA, row, sp, 
X            NULL);
X        xv_set(dstlist,
X            PANEL_LIST_INSERT, row,
X            PANEL_LIST_STRING, row, sp->subdir, 
X            PANEL_LIST_CLIENT_DATA, row, sp, 
X            NULL);
X        sp = (struct SubDir *) LLM_next(&subdir_rt);
X        row++;
X        }
X
X    prect = (Rect *) xv_get(dstlist, PANEL_ITEM_RECT);
X    notelist = xv_create(move_panel, PANEL_LIST,
X        XV_X, prect->r_left + prect->r_width + SCROLLWIDTH + 20,
X        XV_Y, xv_row(move_panel, 1),
X        PANEL_LIST_DISPLAY_ROWS, 7,
X        PANEL_LIST_WIDTH, xv_col(move_panel, 20),
X        PANEL_CHOOSE_ONE, FALSE,
X        PANEL_READ_ONLY, TRUE,
X        NULL);
X
X    notetext = xv_create(move_panel, PANEL_MESSAGE,
X        XV_X, prect->r_left + prect->r_width + SCROLLWIDTH + 20,
X        XV_Y, xv_row(move_panel, 0),
X        PANEL_LABEL_STRING, "Notes To Move",
X        NULL);
X
X    y = prect->r_top + prect->r_height + DEFPANELSPACING;
X
X    appbutton = xv_create(move_panel, PANEL_BUTTON,
X                     XV_X, xv_col(move_panel, 0),
X                     XV_Y, y,
X                     PANEL_LABEL_STRING, "Apply",
X                     PANEL_NOTIFY_PROC, applymove,
X                     NULL);
X
X    window_fit(move_panel);
X    window_fit(move_frame);
X
X    row = 0;
X    sp = (struct SubDir *) LLM_first(&subdir_rt);
X    np = (struct Note *)LLM_first(&sp->note_rt);
X    while(np != NULL)
X        {
X        strcpy(buf, np->ntitle);
X        if(strlen(buf) == 0) strcpy(buf, NOTITLE);
X        xv_set(notelist,
X            PANEL_LIST_INSERT, row,
X            PANEL_LIST_STRING, row, buf,
X            PANEL_LIST_CLIENT_DATA, row, np, 
X            PANEL_LIST_SELECT, row, FALSE,
X            NULL);
X        np = (struct Note *)LLM_next(&sp->note_rt);
X        row++;
X        }
X    xv_set(move_frame, XV_SHOW, TRUE, NULL);
X    (void) xv_set(move_mitem, MENU_INACTIVE, TRUE, NULL);
X    move_up = 1;
X    }
X
Xmovedone()
X    {
X    xv_destroy_safe(move_frame);
X    (void) xv_set(move_mitem, MENU_INACTIVE, FALSE, NULL);
X    move_up = 0;
X    }
X
Xapplymove(item, event)
X    Panel_item item;
X    Event *event;
X    {
X    int  i;
X    int  row;
X    struct Note *np;
X    struct SubDir *src_sp;
X    struct SubDir *dst_sp;
X
X    /* get src dir */
X    row = xv_get(srclist, PANEL_LIST_NROWS);
X    for(i = 0; i < row; i++)
X        {
X        if(xv_get(srclist, PANEL_LIST_SELECTED, i))
X            {
X            src_sp = (struct SubDir *) xv_get(srclist, PANEL_LIST_CLIENT_DATA,
X                                              i);
X            }
X        }
X
X    /* get dst dir */
X    row = xv_get(dstlist, PANEL_LIST_NROWS);
X    for(i = 0; i < row; i++)
X        {
X        if(xv_get(dstlist, PANEL_LIST_SELECTED, i))
X            {
X            dst_sp = (struct SubDir *) xv_get(dstlist, PANEL_LIST_CLIENT_DATA,
X                                              i);
X            }
X        }
X
X    row = xv_get(notelist, PANEL_LIST_NROWS);
X    for(i = 0; i < row; i++)
X        {
X        if(xv_get(notelist, PANEL_LIST_SELECTED, i))
X            {
X            np = (struct Note *) xv_get(notelist, PANEL_LIST_CLIENT_DATA, i);
X            if(w_movenote(src_sp, dst_sp, np, ERRONDISPLAY) < 0)
X                {
X                if(xv_get(move_frame, FRAME_CMD_PUSHPIN_IN) == FALSE)
X                    {
X                    xv_destroy_safe(move_frame);
X                    (void) xv_set(move_mitem, MENU_INACTIVE, FALSE, NULL);
X                    move_up = 0;
X                    }
X                return;
X                }
X            }
X        }
X
X    xv_set(notelist, XV_SHOW, FALSE, NULL);
X    for(i = row - 1; i >= 0; i--)
X        {
X        if(xv_get(notelist, PANEL_LIST_SELECTED, i))
X            {
X            xv_set(notelist, PANEL_LIST_DELETE, i, NULL);
X            }
X        }
X    xv_set(notelist, XV_SHOW, TRUE, NULL);
X
X    if(xv_get(move_frame, FRAME_CMD_PUSHPIN_IN) == FALSE)
X        {
X        xv_destroy_safe(move_frame);
X        (void) xv_set(move_mitem, MENU_INACTIVE, FALSE, NULL);
X        move_up = 0;
X        }
X    refresh_popups();
X    }
X
Xchosesrc(item, string, client_data, op, event)
X    Panel_item item;
X    char *string;
X    char *client_data;
X    Panel_list_op op;
X    Event *event;
X    {
X    int  i;
X    int  row;
X    struct SubDir *sp;
X    struct Note *np;
X    char buf[MAXTITLELEN + 1];
X
X    if(op == PANEL_LIST_OP_SELECT)
X        {
X        xv_set(notelist, XV_SHOW, FALSE, NULL);
X        row = xv_get(notelist, PANEL_LIST_NROWS);
X        for(i = row - 1; i >= 0; i--)
X            xv_set(notelist, PANEL_LIST_DELETE, i, NULL);
X        sp = (struct SubDir *)client_data;
X        row = 0;
X        np = (struct Note *)LLM_first(&sp->note_rt);
X        while(np != NULL)
X            {
X            strcpy(buf, np->ntitle);
X            if(strlen(buf) == 0) strcpy(buf, NOTITLE);
X            xv_set(notelist,
X                PANEL_LIST_INSERT, row,
X                PANEL_LIST_STRING, row, buf,
X                PANEL_LIST_CLIENT_DATA, row, np, 
X                PANEL_LIST_SELECT, row, FALSE,
X                NULL);
X            np = (struct Note *)LLM_next(&sp->note_rt);
X            row++;
X            }
X        xv_set(notelist, XV_SHOW, TRUE, NULL);
X        }
X    }
X
Xrefresh_move()
X    {
X    int  row, i;
X    struct SubDir *sp;
X    struct Note *np;
X    char buf[MAXTITLELEN + 1];
X
X    if(!move_up) return;
X
X    xv_set(srclist, XV_SHOW, FALSE, NULL);
X    xv_set(dstlist, XV_SHOW, FALSE, NULL);
X    xv_set(notelist, XV_SHOW, FALSE, NULL);
X
X    row = xv_get(srclist, PANEL_LIST_NROWS);
X    for(i = row - 1; i >= 0; i--)
X        xv_set(srclist, PANEL_LIST_DELETE, i, NULL);
X
X    row = xv_get(dstlist, PANEL_LIST_NROWS);
X    for(i = row - 1; i >= 0; i--)
X        xv_set(dstlist, PANEL_LIST_DELETE, i, NULL);
X
X    row = xv_get(notelist, PANEL_LIST_NROWS);
X    for(i = row - 1; i >= 0; i--)
X        xv_set(notelist, PANEL_LIST_DELETE, i, NULL);
X
X    row = 0;
X    sp = (struct SubDir *) LLM_first(&subdir_rt);
X    while(sp != NULL)
X        {
X        xv_set(srclist,
X            PANEL_LIST_INSERT, row,
X            PANEL_LIST_STRING, row, sp->subdir, 
X            PANEL_LIST_CLIENT_DATA, row, sp, 
X            NULL);
X        xv_set(dstlist,
X            PANEL_LIST_INSERT, row,
X            PANEL_LIST_STRING, row, sp->subdir, 
X            PANEL_LIST_CLIENT_DATA, row, sp, 
X            NULL);
X        sp = (struct SubDir *) LLM_next(&subdir_rt);
X        row++;
X        }
X
X    row = 0;
X    sp = (struct SubDir *) LLM_first(&subdir_rt);
X    np = (struct Note *)LLM_first(&sp->note_rt);
X    while(np != NULL)
X        {
X        strcpy(buf, np->ntitle);
X        if(strlen(buf) == 0) strcpy(buf, NOTITLE);
X        xv_set(notelist,
X            PANEL_LIST_INSERT, row,
X            PANEL_LIST_STRING, row, buf,
X            PANEL_LIST_CLIENT_DATA, row, np, 
X            PANEL_LIST_SELECT, row, FALSE,
X            NULL);
X        np = (struct Note *)LLM_next(&sp->note_rt);
X        row++;
X        }
X
X    xv_set(srclist, XV_SHOW, TRUE, NULL);
X    xv_set(dstlist, XV_SHOW, TRUE, NULL);
X    xv_set(notelist, XV_SHOW, TRUE, NULL);
X    }
X
Xmove_resize_proc(frame, event, arg)
X    Frame frame;
X    Event *event;
X    Notify_arg arg;
X    {
X    Rect rect, *prect;
X    int  x, y, rh, h;
X
X    if(event_id(event) != WIN_RESIZE) return;
X    frame_get_rect(frame, &rect);
X    rect.r_height -= (topmargin + bottommargin); /* correct for wm title bar */
X    rect.r_width -= (leftmargin + rightmargin);  /* correct for wm border */
X
X    prect = (Rect *) xv_get(appbutton, PANEL_ITEM_RECT);
X    y = rect.r_height - prect->r_height - DEFPANELSPACING;
X    x = rect.r_width / 2 - prect->r_width / 2;
X    xv_set(appbutton, XV_Y, y, XV_X, x, NULL);
X
X    rh = xv_get(srclist, PANEL_LIST_ROW_HEIGHT);
X    y -= (2 * rh);
X    prect = (Rect *) xv_get(srclist, PANEL_ITEM_RECT);
X    y -= prect->r_top;
X
X    if(y < rh) y = rh;
X    h = y / rh;
X
X    xv_set(srclist, PANEL_LIST_DISPLAY_ROWS, h, NULL);
X    xv_set(dstlist, PANEL_LIST_DISPLAY_ROWS, h, NULL);
X    xv_set(notelist, PANEL_LIST_DISPLAY_ROWS, h, NULL);
X
X    prect = (Rect *) xv_get(notelist, PANEL_ITEM_RECT);
X    y = rect.r_width - prect->r_left - SCROLLWIDTH;
X    xv_set(notelist, PANEL_LIST_WIDTH, y, NULL);
X    }
SHAR_EOF
chmod 0644 pan3.0/move.c ||
echo 'restore of pan3.0/move.c failed'
Wc_c="`wc -c < 'pan3.0/move.c'`"
test 12055 -eq "$Wc_c" ||
	echo 'pan3.0/move.c: original size 12055, current size' "$Wc_c"
fi
# ============= pan3.0/pan.icon ==============
if test -f 'pan3.0/pan.icon' -a X"$1" != X"-c"; then
	echo 'x - skipping pan3.0/pan.icon (File already exists)'
else
echo 'x - extracting pan3.0/pan.icon (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pan3.0/pan.icon' &&
X/* Format_version=1, Width=64, Height=64, Depth=1, Valid_bits_per_item=16
X */
X	0x0000,0x0000,0x0000,0x0800,
X	0x0000,0x0000,0x0000,0x1600,
X	0x0000,0x0000,0x0000,0x1100,
X	0x0000,0x0000,0x0000,0x2200,
X	0x0000,0x0000,0x0000,0x4200,
X	0x0000,0x0000,0x0000,0x6400,
X	0x07FF,0xFFFF,0xFFFF,0x9FE0,
X	0x0400,0x0000,0x0001,0x0820,
X	0x0400,0x0000,0x0001,0x1020,
X	0x0400,0x0020,0x0002,0x2020,
X	0x0424,0x0022,0x0004,0x2020,
X	0x045E,0x61FE,0x0004,0x4020,
X	0x0401,0xB600,0x0008,0x8020,
X	0x0400,0x0000,0x0010,0x8020,
X	0x0400,0x0000,0x0011,0x0020,
X	0x0400,0x0000,0x01A2,0x0020,
X	0x0404,0x0100,0x0142,0x0020,
X	0x04EB,0x5531,0xAE45,0xB920,
X	0x0400,0x8983,0xF089,0x8320,
X	0x0400,0x0118,0x0108,0x0020,
X	0x0400,0x0008,0x0110,0x0020,
X	0x0400,0x0000,0x0220,0x0020,
X	0x0400,0x0000,0x2420,0x0020,
X	0x046E,0x340F,0x4446,0x8220,
X	0x0400,0x83A8,0x0888,0x7DA0,
X	0x0400,0x0000,0x1080,0x0020,
X	0x0400,0x0000,0x1100,0x0020,
X	0x0400,0x0000,0x2E00,0x0020,
X	0x0400,0x0000,0x2200,0x0020,
X	0x0421,0x8800,0x4C00,0x0020,
X	0x0442,0xA800,0x7000,0x0020,
X	0x0418,0x457D,0xC000,0x0020,
X	0x0400,0x0248,0x0000,0x0020,
X	0x0400,0x0000,0x0000,0x0020,
X	0x0400,0x0000,0x0000,0x0020,
X	0x0400,0x0000,0x0000,0x0020,
X	0x0400,0x0000,0x0000,0x0020,
X	0x0400,0x0000,0x0000,0x0020,
X	0x0400,0x0000,0x0000,0x0020,
X	0x0400,0x0000,0x0000,0x0020,
X	0x0400,0x0000,0x0000,0x0020,
X	0x0400,0x0000,0x0000,0x0020,
X	0x0400,0x0000,0x0000,0x0020,
X	0x0400,0x0000,0x0000,0x0020,
X	0x0400,0x0000,0x0000,0x0020,
X	0x0400,0x0000,0x0000,0x0020,
X	0x07FF,0xFFFF,0xFFFF,0xFFE0,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000,
X	0x0000,0x0000,0x0000,0x0000
SHAR_EOF
chmod 0644 pan3.0/pan.icon ||
echo 'restore of pan3.0/pan.icon failed'
Wc_c="`wc -c < 'pan3.0/pan.icon'`"
test 1997 -eq "$Wc_c" ||
	echo 'pan3.0/pan.icon: original size 1997, current size' "$Wc_c"
fi
true || echo 'restore of pan3.0/hidexp.c failed'
echo End of part 2, continue with part 3
exit 0

--
Jeffrey Bailey
Racal-Datacom, Inc.
Mail Stop E-110
1601 N. Harrison Parkway                  INET : jeff@rd1.interlan.com
Sunrise, FL 33323-2899                    UUCP : ...uflorida!novavax!rd1!jeff

exit 0 # Just in case...
-- 
  // chris@Sterling.COM           | Send comp.sources.x submissions to:
\X/  Amiga - The only way to fly! |    sources-x@sterling.com
 "It's intuitively obvious to the |
  most casual observer..."        | GCS d+/-- p+ c++ l+ m+ s++/+ g+ w+ t+ r+ x+
