Newsgroups: comp.sources.x
Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: peebles@mips.com (Andrew Peebles)
Subject: v17i044: Xparty - multi-person conference call (MOTIF), Part01/04
Message-ID: <csx-17i044-xparty@uunet.UU.NET>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Date: Wed, 1 Apr 1992 13:49:53 GMT
Approved: dcmartin@msi.com

Submitted-by: peebles@mips.com (Andrew Peebles)
Posting-number: Volume 17, Issue 44
Archive-name: xparty/part01

# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 04/01/1992 13:49 UTC by dcmartin@fascet
# Source directory /home/fascet/csx/src/xparty
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   3183 -rw-r--r-- Image.c
#    751 -rw-r--r-- Imakefile
#   9335 -rw-r--r-- Makefile
#    335 -rw-r--r-- Makefile.std
#   1245 -rw-r--r-- PromptForString.c
#    439 -rw-r--r-- README
#    939 -rw-r--r-- SetArg.c
#  58120 -rw-r--r-- Table.c
#   2633 -rw-r--r-- Table.h
#   3108 -rw-r--r-- TableP.h
#    983 -rw-r--r-- Warning.c
#   1513 -rw-r--r-- WidgetNames.c
#   1677 -rw-r--r-- XParty
#   2058 -rw-r--r-- image.h
#    275 -rw-r--r-- list.bg
#   6476 -rw-r--r-- message.c
#   5643 -rw-r--r-- operator.c
#  17617 -rw-r--r-- orig_disp.c
#     59 -rw-r--r-- patchlevel.h
#  17408 -rw-r--r-- utils.c
#   2264 -rw-r--r-- xmsg.icon
#   2811 -rw-r--r-- xparty.c
#   9608 -rw-r--r-- xparty.man
#   1373 -rw-r--r-- xphone.h
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= Image.c ==============
if test -f 'Image.c' -a X"$1" != X"-c"; then
	echo 'x - skipping Image.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Image.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Image.c' &&
/***************************************************************************
X *
X * FILE NAME		: image.c
X *
X * AUTHOR		: Andrew Peebles
X *
X * DESCRIPTION		: Contains Xm routines for pixmap handling
X *
X * VERSIONS		: %W%
X *
X ***************************************************************************/
X
/*
X * standard includes
X */
#include <stdio.h>
#include <X11/Intrinsic.h>
#include <X11/IntrinsicP.h>
#include <Xm/Xm.h>
#include "image.h"
X
/*
X * Function:
X */
Boolean
CreateAndInstallPixmap (bits, width, height, name)
/*
X * Takes arguments from a bitmap include file, creates an image
X * from the data and stores it in the PIXMAP cache under name.
X * These pixmaps can then be retrieved with GetPixmap and used
X * for button labels, etc.
X */
char	*bits;
int	width, height;
char	*name;
{
X    XImage *image;
X
X    image = (XImage *) XtMalloc (sizeof (XImage));
X    image->width = width;
X    image->height = height;
X    image->data = bits;
X    image->depth = 1;
X    image->xoffset = 0;
X    image->format = XYBitmap;
X    image->byte_order = LSBFirst;
X    image->bitmap_unit = 8;
X    image->bitmap_bit_order = LSBFirst;
X    image->bitmap_pad = 8;
X    image->bytes_per_line = (width+7)/8;
X
X    return (XmInstallImage (image, name));
}
X
/*
X * Function:
X */
Pixmap
GetPixmap (w, name)
/*
X * Used to retrieve pixmaps stored in the PIXMAP cache.  Returns
X * a pixmap id.  Uses the pasted in widget to calculate the foreground
X * and background values of the pixmap.
X */
Widget	w;
char	*name;
{
X  Pixmap	p;
X  Arg		args[5];
X  Pixel		f,b;
X
X  XtSetArg (args[0], XmNforeground, &f);
X  XtSetArg (args[1], XmNbackground, &b);
X  XtGetValues (w, args, 2);
X  p = XmGetPixmap (w->core.screen,
X		   name,
X		   f, b);
X  return (p);
}
X
/*
X * Function:
X */
void
InstallDefaultPixmaps ()
/*
X * Install some default pixmaps in the PIXMAP cache.  These
X * are the dialog pixmaps used by the Motif dialog widget set.
X * They can be retrieved with the function GetPixmap with the
X * following names:
X *
X *	xm_error
X *	xm_warning
X *	xm_question
X *	xm_info
X *	xm_working
X */
{
X  XImage	*image;
X
X  CreateAndInstallPixmap (errorBits,
X			  errorWidth,
X			  errorHeight,
X			  "xm_error");
X
X  CreateAndInstallPixmap (infoBits,
X			  infoWidth,
X			  infoHeight,
X			  "xm_info");
X
X  CreateAndInstallPixmap (questionBits,
X			  questionWidth,
X			  questionHeight,
X			  "xm_question");
X
X  CreateAndInstallPixmap (warningBits,
X			  warningWidth,
X			  warningHeight,
X			  "xm_warning");
X
X  CreateAndInstallPixmap (workingBits,
X			  workingWidth,
X			  workingHeight,
X			  "xm_working");
X
}
X
/*
X * Function:
X */
XXImage *
MakeImage (width, height, data)
/*
X * takes arguments from a bitmap include file and returns an XImage
X * pointer to that data.
X */
int	width, height;
char	*data;
{
X  XImage	*image;
X
X      image = (XImage *) XtMalloc (sizeof (XImage));
X      image->width = width;
X      image->height = height;
X      image->data = data;
X      image->depth = 1;
X      image->xoffset = 0;
X      image->format = XYBitmap;
X      image->byte_order = LSBFirst;
X      image->bitmap_unit = 8;
X      image->bitmap_bit_order = LSBFirst;
X      image->bitmap_pad = 8;
X      image->bytes_per_line = (width+7)/8;
X      return (image);
}
X
SHAR_EOF
chmod 0644 Image.c ||
echo 'restore of Image.c failed'
Wc_c="`wc -c < 'Image.c'`"
test 3183 -eq "$Wc_c" ||
	echo 'Image.c: original size 3183, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Imakefile ==============
if test -f 'Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Imakefile' &&
X       MOTIFLIB = -lXm
X    DEPMOTIFLIB = $(USRLIBDIR)/libXm.a
X
LOCAL_LIBRARIES = $(MOTIFLIB) $(XTOOLLIB) $(XLIB)
X        DEPLIBS = $(DEPMOTIFLIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X        DEFINES = -D_NO_PROTO
X
X   INSTALLFLAGS = -m 5755
X
X          SRCS = xparty.c \
X		  orig_disp.c \
X		  utils.c \
X		  message.c \
X		  operator.c \
X                  Warning.c \
X		  SetArg.c \
X		  Image.c \
X		  PromptForString.c \
X		  WidgetNames.c \
X                  Table.c
X
X          OBJS = xparty.o \
X		  orig_disp.o \
X		  utils.o \
X		  message.o \
X		  operator.o \
X                  Warning.o \
X		  SetArg.o \
X		  Image.o \
X		  PromptForString.o \
X		  WidgetNames.o \
X                  Table.o
X
X       PROGRAMS = xparty
X
all:: $(PROGRAMS)
X
ComplexProgramTarget(xparty)
SHAR_EOF
chmod 0644 Imakefile ||
echo 'restore of Imakefile failed'
Wc_c="`wc -c < 'Imakefile'`"
test 751 -eq "$Wc_c" ||
	echo 'Imakefile: original size 751, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile ==============
if test -f 'Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
# Makefile generated by imake - do not edit!
# $XConsortium: imake.c,v 1.51 89/12/12 12:37:30 jim Exp $
X
###########################################################################
# Makefile generated from "Imake.tmpl" and <Imakefile>
# $XConsortium: Imake.tmpl,v 1.77 89/12/18 17:01:37 jim Exp $
#
# Platform-specific parameters may be set in the appropriate .cf
# configuration files.  Site-wide parameters may be set in the file
# site.def.  Full rebuilds are recommended if any parameters are changed.
#
# If your C preprocessor doesn't define any unique symbols, you'll need
# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
# "make Makefile", "make Makefiles", or "make World").
#
# If you absolutely can't get imake to work, you'll need to set the
# variables at the top of each Makefile as well as the dependencies at the
# bottom (makedepend will do this automatically).
#
X
###########################################################################
# platform-specific configuration parameters - edit sgi.cf to change
X
CRT1 = /usr/lib/crt1.o
CRTN = /usr/lib/crtn.o
X
###########################################################################
# site-specific configuration parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.21 89/12/06 11:46:50 jim Exp $
X
X        OPTIMIZER = -O2
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar scq
X  BOOTSTRAPCFLAGS = "$(OPTIMIZER)"
X               CC = cc
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = bsdinst.sh
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -o
X         LINTOPTS = -ax
X               LN = ln -s
X
X               MV = mv
X               CP = cp
X           RANLIB = /bin/true
X  RANLIBINSTFLAGS =
X               RM = rm -f
X  VENDOR_INCLUDES =
X     STD_INCLUDES =
X  STD_CPP_DEFINES = -DSYSV
X      STD_DEFINES = -DSYSV -DMALLOC_0_RETURNS_NULL
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES = -lsun -lmalloc -lc_s
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DATTSHAREDLIB
X
X    PROTO_DEFINES = -DFUNCPROTO -DNARROWPROTO
X
X     INSTPGMFLAGS = -s
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0664
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 2755 -g sys
X
X          DESTDIR =
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = $(OPTIMIZER)
X        CCOPTIONS = -prototypes -cckr -float
X      COMPATFLAGS =
X
X      ALLINCLUDES = $(STD_INCLUDES) $(TOP_INCLUDES) $(INCLUDES) $(EXTRA_INCLUDES) $(VENDOR_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(PROTO_DEFINES) $(DEFINES) $(COMPATFLAGS)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS)
X   LDCOMBINEFLAGS = -r
X
X        MACROFILE = sgi.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
###########################################################################
# X Window System Build Parameters
# $XConsortium: Project.tmpl,v 1.68 90/07/03 12:14:47 rws Exp $
X
###########################################################################
# X Window System make variables; this need to be coordinated with rules
# $XConsortium: Project.tmpl,v 1.68 90/07/03 12:14:47 rws Exp $
X
X          PATHSEP = /
X        USRLIBDIR = $(DESTDIR)/usr/lib
X           BINDIR = $(DESTDIR)/usr/bin/X11
X          INCROOT = $(DESTDIR)/usr/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = $(DESTDIR)/usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           AWMDIR = $(LIBDIR)/awm
X           TWMDIR = $(LIBDIR)/twm
X           GWMDIR = $(LIBDIR)/gwm
X          MANPATH = $(DESTDIR)/usr/man
X    MANSOURCEPATH = $(MANPATH)/man
X           MANDIR = $(MANSOURCEPATH)n
X        LIBMANDIR = $(MANSOURCEPATH)3
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X
X        MKDIRHIER = mkdir -p
X
X        CONFIGSRC = $(TOP)/config
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X
X          FONTSRC = $(TOP)/fonts.pcf
X
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      BDFTOSNFSRC = $(FONTSRC)/tools/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/tools/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/tools/mkfontdir
X     EXTENSIONSRC = $(TOP)/extensions
X
X  DEPEXTENSIONLIB =  $(USRLIBDIR)/libXext.a
X     EXTENSIONLIB =   -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)  $(USRLIBDIR)/libX11_s.a
X             XLIB = $(EXTENSIONLIB)  -lX11_s
X
X      DEPXAUTHLIB =  $(USRLIBDIR)/libXau.a
X         XAUTHLIB =   -lXau
X
X        DEPXMULIB =  $(USRLIBDIR)/libXmu.a
X           XMULIB =   -lXmu
X
X       DEPOLDXLIB =  $(USRLIBDIR)/liboldX.a
X          OLDXLIB =   -loldX
X
X      DEPXTOOLLIB =  $(USRLIBDIR)/libXt_s.a
X         XTOOLLIB =  -lXt_s
X
X        DEPXAWLIB =  $(USRLIBDIR)/libXaw.a
X           XAWLIB =   -lXaw
X
X         DEPXILIB =  $(USRLIBDIR)/libXi.a
X            XILIB =   -lXi
X
X LINTEXTENSIONLIB =  $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB =  $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU =  $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL =  $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW =  $(LINTLIBDIR)/llib-lXaw.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
###########################################################################
# Imake rules for building libraries, programs, scripts, and data files
# rules:  $XConsortium: Imake.rules,v 1.70 90/05/04 16:57:30 keith Exp $
X
###########################################################################
# start of Imakefile
X
X       MOTIFLIB = -lXm
X    DEPMOTIFLIB = $(USRLIBDIR)/libXm.a
X
LOCAL_LIBRARIES = $(MOTIFLIB) $(XTOOLLIB) $(XLIB)
X        DEPLIBS = $(DEPMOTIFLIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X        DEFINES = -D_NO_PROTO
X
X   INSTALLFLAGS = -m 5755
X
X          SRCS = xparty.c \
X		  orig_disp.c \
X		  utils.c \
X		  message.c \
X		  operator.c \
X                  Warning.c \
X		  SetArg.c \
X		  Image.c \
X		  PromptForString.c \
X		  WidgetNames.c \
X                  Table.c
X
X          OBJS = xparty.o \
X		  orig_disp.o \
X		  utils.o \
X		  message.o \
X		  operator.o \
X                  Warning.o \
X		  SetArg.o \
X		  Image.o \
X		  PromptForString.o \
X		  WidgetNames.o \
X                  Table.o
X
X       PROGRAMS = xparty
X
all:: $(PROGRAMS)
X
X        PROGRAM = xparty
X
all:: xparty
X
xparty: $(OBJS) $(DEPLIBS)
X	 $(RM) $@ ; \
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
install:: xparty
X	$(INSTALL) -c $(INSTPGMFLAGS) $(INSTALLFLAGS) xparty $(BINDIR)
X
install.man:: xparty.man
X	$(INSTALL) -c $(INSTMANFLAGS) xparty.man $(MANDIR)/xparty.n
X
depend::
X	$(DEPEND) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
lint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
lint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
clean::
X	$(RM) $(PROGRAM)
X
###########################################################################
# common rules for all Makefiles - do not edit
X
emptyrule::
X
clean::
X	$(RM_CMD) \#*
X
Makefile::
X	-@if [ -f Makefile ]; then \
X		echo "	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak"; \
X		$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else : ; fi ; \
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
tags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
###########################################################################
# empty rules for directories that do not have SUBDIRS - do not edit
X
install::
X	@echo "install in $(CURRENT_DIR) done"
X
install.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
Makefiles::
X
includes::
X
###########################################################################
# dependencies generated by makedepend
X
SHAR_EOF
chmod 0644 Makefile ||
echo 'restore of Makefile failed'
Wc_c="`wc -c < 'Makefile'`"
test 9335 -eq "$Wc_c" ||
	echo 'Makefile: original size 9335, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile.std ==============
if test -f 'Makefile.std' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile.std (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile.std (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile.std' &&
LIBS            = -lXm -lXt -lX11 -lbsd
X
CFLAGS          = -g -DMips -systype sysv -signed -D_NO_PROTO
X
X
NOBJS		= xparty.o orig_disp.o utils.o message.o operator.o \
X                  Warning.o SetArg.o Image.o PromptForString.o WidgetNames.o \
X		  Table.o
X
xparty  	: $(NOBJS)
X		  cc ${CFLAGS} -o xparty ${NOBJS} ${LIBPATHS} ${LIBS}
X
SHAR_EOF
chmod 0644 Makefile.std ||
echo 'restore of Makefile.std failed'
Wc_c="`wc -c < 'Makefile.std'`"
test 335 -eq "$Wc_c" ||
	echo 'Makefile.std: original size 335, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= PromptForString.c ==============
if test -f 'PromptForString.c' -a X"$1" != X"-c"; then
	echo 'x - skipping PromptForString.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting PromptForString.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'PromptForString.c' &&
/***************************************************************************
X *
X * FILE NAME		: PromptForString.c
X *
X * AUTHOR		: Andrew Peebles
X *
X * DESCRIPTION		: Special routine for prompting the user for
X *			  a string.
X *
X * VERSIONS		: %W%
X *
X ***************************************************************************/
X
/*
X * standard includes
X */
#include <stdio.h>
#include <ctype.h>
X
#include <Xm/SelectioB.h>
X
static XtCallbackRec OK_CB[] = {
X  {NULL, 	NULL},
X  {NULL,        NULL},
};
X
X
PromptForString (reference, pmpt, deft, okProc, okData)
Widget	reference;
char	*pmpt;
char    *deft;
int	(*okProc)();
caddr_t	okData;
{
X  Arg	args[10];
X  int	n;
X  Widget prompt, button;
X  XmStringCharSet char_set = (XmStringCharSet) XmSTRING_DEFAULT_CHARSET;
X
X  OK_CB[0].callback = (XtCallbackProc) (*okProc);
X  OK_CB[0].closure  = okData;
X
X  n = SetArgs (args,
X	       XmNselectionLabelString, XmStringLtoRCreate (pmpt, char_set),
X	       XmNtextString, XmStringLtoRCreate (deft, char_set),
X	       XmNokCallback, OK_CB,
X	       NULL);
X  prompt = XmCreatePromptDialog (reference,
X				 "PromptForString",
X				 args, n);
X  button = XmSelectionBoxGetChild (prompt, XmDIALOG_HELP_BUTTON);
X  XtUnmanageChild (button);
X  XtManageChild (prompt);
}
X
SHAR_EOF
chmod 0644 PromptForString.c ||
echo 'restore of PromptForString.c failed'
Wc_c="`wc -c < 'PromptForString.c'`"
test 1245 -eq "$Wc_c" ||
	echo 'PromptForString.c: original size 1245, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
XXparty is a multi-person conference calling program for Motif.
It operates like talk, but with the capability of having up to ten
people on the `party' line.  It can also be used to send "one way"
messages to users on remote displays.
X
To build:
X
X	unshar the distribution
X	xmkmf
X	make
X
Put the resource file XParty in your $XAPPLRESDIR directory or include it
in your .Xdefaults file.
X
Send problems to:
X
X	Andrew Peebles
X	peebles@mips.com
SHAR_EOF
chmod 0644 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 439 -eq "$Wc_c" ||
	echo 'README: original size 439, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= SetArg.c ==============
if test -f 'SetArg.c' -a X"$1" != X"-c"; then
	echo 'x - skipping SetArg.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting SetArg.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'SetArg.c' &&
#include <stdio.h>
#include <X11/Xlib.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
X
#include <varargs.h>
X
/*
X * Function SetArgs
X *
X * SetArgs fills an ArgList (an array of Args) with a given list of values.
X * The list of values is NULL terminated.
X *
X * SetArgs returns the number of arguments that were set.
X *
X * EXAMPLE USAGE:
X *
X * int n;
X * Arg args[10];
X *
X * n = SetArgs (args,
X *		XmNwidth, 10,
X *		XmNheight, 20,
X *		NULL);
X * XtSetValues (w, args, n);
X */
X
SetArgs(va_alist)
va_dcl
{
X  va_list a;
X
X  /* The first argument is the array to fill. */
X  register ArgList this_arg;
X
X  /* Others are name and value pairs. */
X  String name;
X  
X  /* How many Args have we set? */
X  int count = 0;
X  
X  va_start(a);
X  this_arg = va_arg(a, ArgList);
X  
X  while ((name = va_arg(a, String)) != NULL)
X    {
X      XtSetArg(this_arg[count], name, va_arg(a, XtArgVal));    
X      ++count;
X    }
X  
X  va_end(a);
X  return count;
}
X
X
SHAR_EOF
chmod 0644 SetArg.c ||
echo 'restore of SetArg.c failed'
Wc_c="`wc -c < 'SetArg.c'`"
test 939 -eq "$Wc_c" ||
	echo 'SetArg.c: original size 939, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Table.c ==============
if test -f 'Table.c' -a X"$1" != X"-c"; then
	echo 'x - skipping Table.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Table.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Table.c' &&
#define _Table_c
X
/*LINTLIBRARY*/ /* -*-C++-*- */
/*
X * Table - Forms-based composite widget/geometry manager for the X Toolkit
X *
X * David Harrison
X * University of California, Berkeley
X * 1989
X *
X * This file contains the implementation for the Table widget.
X */
X
/* Edit History
X
02/10/91     marbru     SetValues must copy table.init_layout, if changed
11/25/90  12 nazgul	Better handling of geometry
11/08/90   2 schulert	remove include of Xmu.h
10/31/90   1 schulert	change w->xrm_name to x->core.xrm_name
10/31/90  10 nazgul	Handle gadgets when formatting is done by name
09/30/90   9 nazgul	Try not to change the widget if we are going to return
X			XtGeometryAlmost
09/13/90   7 nazgul	Added #ifdefs so it works with Motif 1.1 as well as 1.0
08/07/90   5 nazgul	Mon Aug  6 09:41:11 1990 patches from david@jpl-devvax.jpl.nasa.gov
07/26/90   4 nazgul	Removal of Xmu.h reference (Niels Mayer)
07/25/90   3 nazgul	Merged in latest patches from the net
07/15/90   2 nazgul	Now deal with XmText widgets reasonably
X
*/
X
#include <X11/IntrinsicP.h>
#include <X11/StringDefs.h>
X
/*#include "WcCreate.h" */
#include "TableP.h"
X
#define INIT_TBL_SIZE	10
#define TBL_CLASS_NAME	"Table"
X
static caddr_t def = (caddr_t) 0;
X
static XtResource resources[] = {
X    { XtNlayout, XtCLayout, XtRPointer, sizeof(caddr_t),
X	XtOffset(TableWidget, table.init_layout), XtRPointer, (caddr_t) &def },
X    { XtNinternalHeight, XtCHeight, XtRDimension, sizeof(Dimension),
X	XtOffset(TableWidget, table.int_height), XtRImmediate, (caddr_t) 0 },
X    { XtNinternalWidth, XtCWidth, XtRDimension, sizeof(Dimension),
X	XtOffset(TableWidget, table.int_width), XtRImmediate, (caddr_t) 0 },
X
X    { XtNcolumnSpacing, XtCSpacing, XtRDimension, sizeof(Dimension),
X	XtOffset(TableWidget, table.col_spacing), XtRImmediate, (caddr_t) 0 },
X    { XtNrowSpacing, XtCSpacing, XtRDimension, sizeof(Dimension),
X	XtOffset(TableWidget, table.row_spacing), XtRImmediate, (caddr_t) 0 },
/* If we want it more motif-like
X    { XmNverticalSpacing, XmCSpacing, XtRDimension, sizeof(Dimension),
X	XtOffset(TableWidget, table.col_spacing), XtRImmediate, (caddr_t) 0 },
X    { XmNhorizontalSpacing, XmCSpacing, XtRDimension, sizeof(Dimension),
X	XtOffset(TableWidget, table.row_spacing), XtRImmediate, (caddr_t) 0 },
*/
X    { XtNdefaultOptions, XtCOptions, XtROptions, sizeof(XtTblMask),
X	XtOffset(TableWidget, table.def_options), XtRImmediate, (caddr_t) 0 }
};
X
/* Forward declarations */
static void TblClassInitialize();
static void TblExposeProc();
static void TblInitialize();
static void TblResize();
static XtGeometryResult TblQueryGeometry();
static void TblPositionChild();
static Boolean TblSetValues();
static XtGeometryResult TblGeometryManager();
static void TblChangeManaged();
static Boolean TblFindChild();
static void TblDestroy();
static XtTblMask ParseOpts();
X
X
X
/*
X * Local structures
X */
X
typedef struct _TableLoc {
X    Position ax, ay;		/* Position in array       */
X    Dimension h_span, v_span;	/* Span size in array      */
X    XtTblMask options;		/* Widget position options */
} TableLoc, *TableLocPtr;
X
typedef struct _TableLocEntry {
X    Widget w;
X    TableLoc loc;
} TableLocEntry, *TableLocEntryPtr;
X
struct _TableLocTbl {
X    Cardinal n_layout;		/* Number of layout widgets */
X    Cardinal a_layout;		/* Allocated space          */
X    TableLocEntryPtr locs;	/* Widget locations         */
};
X
struct _TableDefLoc {
X    String w_name;		/* Widget name        */
X    TableLoc loc;		/* Widget information */
};
X
typedef unsigned long TableVecMask;
#define	VEC_MINIMIZE	0x01
X
struct _TableVector {
X    TableVecMask mask;		/* Option mask  */
X    Cardinal value;		/* Size of item */
};
X
X
#if XmVersion > 1000
static XtActionsRec actionsList[] =
{
X	{ "Enter",	(XtActionProc)	_XmManagerEnter },
X	{ "FocusIn",	(XtActionProc)	_XmManagerFocusIn },
X	{ "Arm",	(XtActionProc)	_XmGadgetArm  },
X	{ "Activate",	(XtActionProc)	_XmGadgetActivate },
X	{ "Help",	(XtActionProc)	_XmManagerHelp },
X	{ "Return",	(XtActionProc)	_XmBulletinBoardReturn },
X	{ "BulletinBoardReturn", (XtActionProc)	_XmBulletinBoardReturn },
X        { "BulletinBoardCancel", (XtActionProc)	_XmBulletinBoardCancel },
};
#else
static XtActionsRec actionsList[] =
{
X	{ "Enter",	(XtActionProc)	_XmManagerEnter },
X	{ "FocusIn",	(XtActionProc)	_XmBulletinBoardFocus },
X	{ "Arm",	(XtActionProc)	_XmBulletinBoardArm  },
X	{ "Activate",	(XtActionProc)	_XmBulletinBoardActivate },
X	{ "Help",	(XtActionProc)	_XmBulletinBoardHelp },
X	{ "Return",	(XtActionProc)	_XmBulletinBoardReturn },
};
#endif
X
EXTERNDEF TableClassRec tableClassRec = {
X  { /* core_class fields */
#ifdef OLDLEVEL
X    /* superclass	  */    (WidgetClass) &compositeClassRec,
#else
X    /* superclass         */    (WidgetClass) &xmBulletinBoardClassRec,
#endif
X    /* class_name         */    TBL_CLASS_NAME,
X    /* widget_size        */    sizeof(TableRec),
X    /* class_initialize   */    TblClassInitialize,
X    /* class_part_init    */    NULL,
X    /* class_inited       */    FALSE,
X    /* initialize         */    TblInitialize,
X    /* initialize_hook    */    NULL,
X    /* realize            */    XtInheritRealize,
X    /* actions            */    actionsList,
X    /* num_actions        */    XtNumber(actionsList),
X    /* resources          */    resources,
X    /* num_resources      */    XtNumber(resources),
X    /* xrm_class          */    NULLQUARK,
X    /* compress_motion    */    False,
X    /* compress_exposure  */    TRUE,
X    /* compress_enterleave*/    False,
X    /* visible_interest   */    FALSE,
X    /* destroy            */    TblDestroy,
X    /* resize             */    TblResize,
X    /* expose             */    _XmRedisplayGadgets,
X    /* set_values         */    TblSetValues,
X    /* set_values_hook    */    NULL,
X    /* set_values_almost  */    XtInheritSetValuesAlmost,
X    /* get_values_hook    */    NULL,
X    /* accept_focus       */    NULL,
X    /* version            */    XtVersion,
X    /* callback_private   */    NULL,
X    /* tm_table           */    XtInheritTranslations,
X    /* query_geometry     */	TblQueryGeometry,
X    /* display_accelerator*/	/*XtInheritDisplayAccelerator,*/ NULL,
X    /* extension          */	NULL
X  },
X  { /* composite_class fields */
X    /* geometry_manager   */   TblGeometryManager,
X    /* change_managed     */   TblChangeManaged,
X    /* insert_child       */   XtInheritInsertChild,
X    /* delete_child       */   XtInheritDeleteChild,
X    /* extension          */   NULL
X  },
#ifndef OLDLEVEL
{ /* constraint_class fields */
X    /* resource list 	*/ NULL,
X    /* num resources	*/ 0,
X    /* constraint size  */ 0,
X    /* init proc	*/ NULL,
X    /* destroy proc     */ NULL,
X    /* set values proc  */ NULL,
X    /* extension 	*/   NULL
X  },
X  { /* manager_class	  */
#if XmVersion > 1000
X    /* translations 	  */	XtInheritTranslations,
X    /* syn_resources	  */	NULL,
X    /* num_syn_resources  */	0,
X    /* syn_cont_resources */	NULL,
X    /* num_syn_cont_resources */ 0,
X    /* parent_process     */    NULL,
X    /* extension	  */	NULL
#else
X    /* translations 	  */	(XtTranslations) _XtInherit,
X    /* get_resources	  */	NULL,
X    /* num_get_resources  */	0,
X    /* get_constraint_resources */	NULL,
X    /* num_get_constraint_resources */	0,
X    /* extension	  */	NULL
#endif
X  },
{ /* Bulletin Board */
X    /* always_install_accelerators */	False,
#if XmVersion > 1000
X    /* geo_matrix_create */	NULL,
X    /* focus_moved_proc */	XtInheritFocusMovedProc,
#endif
X    /* extension	*/  NULL,
X  },
#endif
X  { /* table_class fields */
X    /* position_child	  */	TblPositionChild,
X    /* find_child	  */	TblFindChild,
X  }
};
X
EXTERNDEF WidgetClass tableWidgetClass = (WidgetClass) &tableClassRec;
X
X
X
/*ARGSUSED*/
static void cvtStrToDefLoc(args, num_args, from, to)
XXrmValue *args;			/* Arguments to converter */
Cardinal *num_args;		/* Number of arguments    */
XXrmValue *from;			/* From type              */
XXrmValue *to;			/* To type                */
/*
X * Converts a string representation into an array of TableDefLoc
X * structures.
X */
{
X    static caddr_t ptr;
X    String layout_spec;
X
X    if (*num_args != 0) {
X	XtErrorMsg("cvtStrToDefLoc", "wrongParameters", "XtToolkitError",
X		   "String to layout takes no additional arguments",
X		   (String *) NULL, (Cardinal *) NULL);
X    }
X
X    layout_spec = (String) from->addr;
X    ptr = XtTblParseLayout(layout_spec);
X    to->size = sizeof(caddr_t);
X    to->addr = (caddr_t) &ptr;
}
X
/*ARGSUSED*/
static void cvtStrToOpts(args, num_args, from, to)
XXrmValue *args;			/* Arguments to converter */
Cardinal *num_args;		/* Number of arguments    */
XXrmValue *from;			/* From type              */
XXrmValue *to;			/* To type                */
/*
X * Converts a string representation into a default options
X * mask (XtTblMask).
X */
{
X    static XtTblMask mask;
X    String opt_spec;
X
X    if (*num_args != 0) {
X	XtErrorMsg("cvtStrToOpts", "wrongParameters", "XtToolkitError",
X		   "String to options takes no additional arguments",
X		   (String *) NULL, (Cardinal *) NULL);
X    }
X
X    opt_spec = (String) from->addr;
X    to->size = sizeof(int);
X    mask = ParseOpts(opt_spec);
X    to->addr = (caddr_t) &mask;
}
X
X
static void TblClassInitialize()
/*
X * Adds an appropriate string-to-default widget location table
X * converter.
X */
{
X    XtAddConverter(XtRString, XtRPointer, cvtStrToDefLoc, NULL, 0);
X    XtAddConverter(XtRString, XtROptions, cvtStrToOpts, NULL, 0);
}
X
X
X
X
/* 
X * Table Management Functions
X *
X * Default table is a linear null terminated array,  the location
X * array is a linear dynamic array.  Both should be replaced
X * with hash tables.
X */
X
static Cardinal LenDefLoc(ptr)
TableDefLocPtr ptr;
/*
X * Returns the length of a DefLoc list.
X */
{
X    Cardinal i;
X
X    for (i = 0;  ptr && ptr[i].w_name;  i++) {
X	/* Null body */
X    }
X    return i;
}
X
static TableDefLocPtr CopyDefLoc(ptr)
TableDefLocPtr ptr;
/*
X * Makes a dynamically allocated copy of `ptr'.
X */
{
X    TableDefLocPtr copy;
X    Cardinal i, len;
X
X    len = LenDefLoc(ptr);
X    if (len) {
X	copy = (TableDefLocPtr) XtCalloc(len+1, sizeof(struct _TableDefLoc));
X	for (i = 0;  i < len;  i++) {
X	    copy[i] = ptr[i];
X	}
X	copy[i].w_name = (String) 0;
X    } else {
X	copy = (TableDefLocPtr) 0;
X    }
X    return copy;
}
X
static TableDefLocPtr FindDefLoc(tbl, name)
TableDefLocPtr tbl;		/* Table to examine */
String name;			/* Widget name      */
/*
X * Scans through `tbl' looking for the name `name'.  Returns
X * a pointer to the found value or NULL if not found.
X */
{
X    TableDefLocPtr idx;
X
X    if (!name) return (TableDefLocPtr) 0;
X
X    for (idx = tbl;  idx && idx->w_name;  idx++) {
X	if (strcmp(idx->w_name, name) == 0) return idx;
X    }
X    return (TableDefLocPtr) 0;
}
X
static TableDefLocPtr MergeDefLoc(source, dest)
TableDefLocPtr source;		/* Original table     */
TableDefLocPtr dest;		/* Additional entries */
/*
X * Returns a table where the entries in `dest' have been
X * merged with those in `source'.  Similar entries in
X * `dest' override those in `source'.  The returned
X * table is allocated.
X */
{
X    TableDefLocPtr result, update;
X    Cardinal s_len, d_len;
X    Cardinal i, j;
X
X    s_len = LenDefLoc(source);
X    d_len = LenDefLoc(dest);
X    result = (TableDefLocPtr)
X      XtCalloc(s_len + d_len + 1, sizeof(struct _TableDefLoc));
X    for (i = 0;  i < s_len;  i++) {
X	result[i] = source[i];
X    }
X    /* Add null termination */
X    result[i].w_name = (String) 0;
X    /* Now merge the results */
X    for (j = 0;  j < d_len;  j++) {
X	if (update = FindDefLoc(result, dest[j].w_name)) {
X	    update->loc = dest[j].loc;
X	} else {
X	    /* Add to end */
X	    result[i].w_name = dest[j].w_name;
X	    result[i].loc = dest[j].loc;
X	    i += 1;
X	    result[i].w_name = (String) 0;
X	}
X    }
X    return result;
}
X
X
X
static TableLocTblPtr TblInitLocTbl()
/*
X * Returns a newly allocated location table.  This is implemented
X * at the moment as dynamic array.  Eventually,  a hash table
X * will be used.
X */
{
X    TableLocTblPtr rtn;
X
X    rtn = (TableLocTblPtr) XtMalloc(sizeof(struct _TableLocTbl));
X    rtn->n_layout = 0;
X    rtn->a_layout = INIT_TBL_SIZE;
X    rtn->locs = (TableLocEntryPtr)
X      XtCalloc(INIT_TBL_SIZE, sizeof(TableLocEntry));
X    return rtn;
}
X
static void TblInsertLoc(tbl, w, locp)
TableLocTblPtr tbl;		/* Table for insertion             */
Widget w;			/* Subwidget to place              */
TableLocPtr locp;		/* Widget location information     */
/*
X * Inserts an item into the location table.  If there is already
X * an entry for the widget,  it is replaced by this one.  If there
X * is no room,  additional room is allocated.
X */
{
X    int i;
X
X    for (i = 0;  i < tbl->n_layout;  i++) {
X	if (tbl->locs[i].w == w) {
X	    tbl->locs[i].loc = *locp;
X	    return;
X	}
X    }
X    /* Not in the table */
X    if (tbl->n_layout >= tbl->a_layout) {
X	/* Make more space */
X	tbl->a_layout += tbl->a_layout;
X	tbl->locs = (TableLocEntryPtr)
X	  XtRealloc(tbl->locs, tbl->a_layout * sizeof(TableLocEntry));
X    }
X    tbl->locs[tbl->n_layout].w = w;
X    tbl->locs[tbl->n_layout].loc = *locp;
X    tbl->n_layout += 1;
}
X
static TableLocPtr TblLocLookup(tbl, w)
TableLocTblPtr tbl;		/* Table for lookup      */
Widget w;			/* What widget to lookup */
/*
X * Looks up widget `w' in the hard widget position table.
X * Returns NULL if it can't find the widget.
X */
{
X    int i;
X
X    for (i = 0;  i < tbl->n_layout;  i++) {
X	if (tbl->locs[i].w == w) {
X	    return &(tbl->locs[i].loc);
X	}
X    }
X    return (TableLocPtr) 0;
}
X
static void TblFreeLocTbl(tbl)
TableLocTblPtr tbl;		/* Table to free */
/*
X * Frees memory resources of `tbl'.
X */
{
X    XtFree((char *) (tbl->locs));
X    XtFree((char *) tbl);
}
X
X
X
static void TblInitialize(request, new)
Widget request;			/* Values from resources */
Widget new;			/* Actual widget         */
/*
X * Intializes appropriate fields in instance record.
X */
{
X    TableWidget old = (TableWidget) request;
X    TableWidget tw = (TableWidget) new;
X
X    tw->table.init_layout = CopyDefLoc(old->table.init_layout);
X    tw->table.layout_db = (TableDefLocPtr) 0;
X    tw->table.real_layout = TblInitLocTbl();
X    tw->table.vec_state = INVALID;
X    tw->table.num_rows = tw->table.num_cols = 0;
X    tw->table.rows = (TableVecPtr) 0;
X    tw->table.cols = (TableVecPtr) 0;
X    tw->table.vec_height = 0;
X    tw->table.vec_width = 0;
}
X
X
X
static TableLocTblPtr GetManaged(nw, wl)
Cardinal nw;			/* Number of widgets */
WidgetList wl;			/* Widget list       */
/*
X * Returns those widgets in `wl' that are managed and looks
X * up their table postions.  If no table position is found,
X * the widget is placed at 0,0 with a span of 1 with no options.
X */
{
X    TableLocTblPtr result;
X    Cardinal i;
X
X    result = TblInitLocTbl();
X    for (i = 0;  i < nw;  i++) {
X	if (XtIsManaged(wl[i])) {
X	    if (result->n_layout >= result->a_layout) {
X		/* Make more space */
X		result->a_layout += result->a_layout;
X		result->locs = (TableLocEntryPtr)
X		  XtRealloc(result->locs,
X			    result->a_layout * sizeof(TableLocEntry));
X	    }
X	    result->locs[result->n_layout].w = wl[i];
X	    if (!TblFindChild(wl[i],
X			      &(result->locs[result->n_layout].loc.ax),
X			      &(result->locs[result->n_layout].loc.ay),
X			      &(result->locs[result->n_layout].loc.h_span),
X			      &(result->locs[result->n_layout].loc.v_span),
X			      &(result->locs[result->n_layout].loc.options))) {
X		/* Can't find location -- make one up */
X		result->locs[result->n_layout].loc.ax = 0;
X		result->locs[result->n_layout].loc.ay = 0;
X		result->locs[result->n_layout].loc.h_span = 1;
X		result->locs[result->n_layout].loc.v_span = 1;
X		result->locs[result->n_layout].loc.options = 0;
X	    }
X	    result->n_layout += 1;
X	}
X    }
X    return result;
}
X
X
static Cardinal VecSize(mw, val_func)
TableLocTblPtr mw;		/* List of managed widgets           */
void (*val_func)();		/* Returns either row or column info */
/*
X * Determines the vector size by examining locations of all
X * widgets in `mw'.  Basically determines the maximum of loc+span.
X */
{
X    Cardinal i, loc, span;
X    Cardinal result = 0;
X    Boolean small_flag;
X
X    for (i = 0;  i < mw->n_layout;  i++) {
X	(*val_func)(&(mw->locs[i]), &loc, &span, &small_flag);
X	if (result < loc+span) {
X	    result = loc+span;
X	}
X    }
X    return result;
}
X
X
X
static void SetVecOptions(mw, val_func, vec)
TableLocTblPtr mw;		/* Managed widget list */
void (*val_func)();		/* Row or col info     */
TableVecPtr vec;		/* Spacing vector      */
/*
X * Steps through the list of widgets.  If the widget is marked
X * as having the small flag set,  it sets all corresponding
X * options in `vec'.
X */
{
X    Cardinal i, j;
X    Cardinal loc, span;
X    Boolean small_flag;
X
X    for (i = 0;  i < mw->n_layout;  i++) {
X	(*val_func)(&(mw->locs[i]), &loc, &span, &small_flag);
X	if (small_flag) {
X	    for (j = loc;  j < loc+span;  j++) {
X		vec[j].mask = VEC_MINIMIZE;
X	    }
X	}
X    }
}
X
X
/* Must be set before span_cmp works */
static void (*span_cmp_val_func)();
X
static int span_cmp(a, b)
char *a, *b;
/*
X * Compares items based on span.
X */
{
X    Cardinal loc_a, loc_b;
X    Cardinal span_a, span_b;
X    Boolean small_flag;
X
X    (*span_cmp_val_func)((TableLocEntryPtr) a, &loc_a, &span_a, &small_flag);
X    (*span_cmp_val_func)((TableLocEntryPtr) b, &loc_b, &span_b, &small_flag);
X    return span_a - span_b;
}
X
X
static Cardinal FindDistrib(loc, span, vec, result)
Cardinal loc, span;		/* Widget loc and span */
TableVecPtr vec;		/* Spacing vector     */
Cardinal *result;		/* Result array       */
/*
X * This routine fills in `result' with a list of indices
X * into the spacing vector suitable for distributing required
X * space.  Normally,  it skips those items marked as
X * VEC_MINIMIZE.  However,  if there aren't any non-VEC_MINIMIZE
X * spaces,  all of them become candidates.
X */
{
X    Cardinal i, count;
X
X    count = 0;
X    for (i = loc;  i < loc+span;  i++) {
X	if (vec[i].mask & VEC_MINIMIZE) continue;
X	result[count++] = i;
X    }
X    if (count == 0) {
X	/* Add them all back in */
X	for (i = loc;  i < loc+span;  i++) {
X	    result[count++] = i;
X	}
X    }
X    return count;
}
X
X
static void DoDistrib(n_dist, distrib, loc, span, vec, size, inter)
Cardinal n_dist;		/* Number of distribution points */
Cardinal *distrib;		/* Indicies into `vec'           */
Cardinal loc, span;		/* Widget location and span      */
TableVecPtr vec;		/* Spacing vector                */
Dimension size;			/* Size of widget                */
Dimension inter;		/* inter {col,row} spacing	 */
/*
X * If `size' is larger than the current sum of space in `vec'
X * specified by `loc' and `span',  the difference in space
X * is evenly added to each vector entry given by `distrib'.
X */
{
X    Cardinal sum = 0;
X    Cardinal i;
X    int diff, amt;
X
X    for (i = loc;  i < loc+span;  i++) {
X	sum += vec[i].value;
X    }
X    if (span > 1)
X	sum += (span-1) * inter;
X    diff = size - sum;
X    if (diff > 0) {
X	/* Distribution required */
X	amt = diff / n_dist;
X	for (i = 0;  i < n_dist-1;  i++) {
X	    vec[distrib[i]].value += amt;
X	    diff -= amt;
X	}
X	/* Last one deincremented by remaining space */
X	vec[distrib[i]].value += diff;
X    }
}
X
X
X
X
static Cardinal CompVector(mw, val_func, size_func, inter, result)
TableLocTblPtr mw;		/* List of managed widgets with locs */
void (*val_func)();		/* Returns either row or column info */
Dimension (*size_func)();	/* Returns desired size of subwidget */
Dimension inter;		/* inter {row,col} spacing	     */
TableVecPtr *result;		/* Result vector                     */
/*
X * This routine computes the values for either the row or column
X * spacing vector.  The strategy is as follows:
X *   1. Scan mw and determine number of entrys in result and allocate
X *   2. Scan list and set appropriate vector flags.
X *   3. Sort the managed widgets in span order (low to high)
X *   4. For each item in sorted list:
X *      A. Determine distribution locations.
X *      B. Distribute any needed space to locations.
X * There are some inefficiencies here that could be overcome.
X */
{
X    Cardinal res_num, i;
X    Cardinal n_dist, *distrib;
X    Cardinal loc, span;
X    Boolean small_flag;
X
X    res_num = VecSize(mw, val_func);
X    if (res_num) {
X	*result = (TableVecPtr) XtCalloc(res_num, sizeof(struct _TableVector));
X	for (i = 0;  i < res_num;  i++) {
X	    (*result)[i].mask = 0;
X	    (*result)[i].value = 0;
X	}
X	SetVecOptions(mw, val_func, *result);
X
X	span_cmp_val_func = val_func;
X	qsort((char *) mw->locs, (int) mw->n_layout,
X	      sizeof(TableLocEntry), span_cmp);
X
X	distrib = (Cardinal *) XtCalloc(res_num, sizeof(Cardinal));
X	for (i = 0;  i < mw->n_layout;  i++) {
X	    (*val_func)(&(mw->locs[i]), &loc, &span, &small_flag);
X	    n_dist = FindDistrib(loc, span, *result, distrib);
X	    DoDistrib(n_dist, distrib, loc, span, *result,
X		      (*size_func)(mw->locs[i].w), inter);
X	}
X	return res_num;
X    } else {
X	*result = (TableVecPtr) 0;
X	return 0;
X    }
X    /*NOTREACHED*/
}
X
X
static void ColValues(oneloc, loc, span, small_flag)
TableLocEntryPtr oneloc;	/* Widget data       */
Cardinal *loc;			/* Location in array */
Cardinal *span;			/* Spanning distance */
Boolean *small_flag;		/* Whether locked    */
/*
X * This routine returns column data from `oneloc'.  It is
X * passed to CompVector when computing the column spacing vector.
X */
{
X    *loc = oneloc->loc.ax;
X    *span = oneloc->loc.h_span;
X    *small_flag = oneloc->loc.options & TBL_SM_WIDTH;
}
X
static void RowValues(oneloc, loc, span, small_flag)
TableLocEntryPtr oneloc;	/* Widget data       */
Cardinal *loc;			/* Location in array */
Cardinal *span;			/* Spanning distance */
Boolean *small_flag;		/* Whether locked    */
/*
X * This routine returns row data from `oneloc'.  It is
X * passed to CompVector when computing the row spacing vector.
X */
{
X    *loc = oneloc->loc.ay;
X    *span = oneloc->loc.v_span;
X    *small_flag = oneloc->loc.options & TBL_SM_HEIGHT;
}
X
static Dimension ColSize(w)
Widget w;			/* Child widget */
/*
X * This routine returns the desired width of the widget `w'.
X * It is used by CompVector when computing the column vector.
X */
{
X    Dimension r_size, r_border;
X    XtWidgetGeometry child;
X
X    r_size = w->core.width;
X    r_border = w->core.border_width;
X    (void) XtQueryGeometry(w, (XtWidgetGeometry *) 0, &child);
X    if (child.request_mode & CWWidth) r_size = child.width;
X    if (child.request_mode & CWBorderWidth) r_border = child.border_width;
X    return r_size + r_border + r_border;
}
X
static Dimension RowSize(w)
Widget w;			/* Child widget */
/*
X * This routine returns the desired width of the widget `w'.
X * It is used by CompVector when computing the column vector.
X */
{
X    Dimension r_size, r_border;
X    XtWidgetGeometry child;
X
X    r_size = w->core.height;
X    r_border = w->core.border_width;
X    (void) XtQueryGeometry(w, (XtWidgetGeometry *) 0, &child);
X    if (child.request_mode & CWHeight) r_size = child.height;
X    if (child.request_mode & CWBorderWidth) r_border = child.border_width;
X    return r_size + r_border + r_border;
}
X
X
X
/*ARGSUSED*/
static void TblRecompVectors(tw)
TableWidget tw;			/* Table widget */
/*
X * Recomputes the size vectors in the table widget by
X * examining the preferred sizes of subwidgets.  The
X * following fields are modified: num_rows, num_cols,
X * rows, cols, vec_height, and vec_width.
X */
{
X    TableLocTblPtr managed;
X    Cardinal i;
X
X    /* Free existing vectors */
X    if (tw->table.cols) XtFree((char *) (tw->table.cols));
X    tw->table.num_cols = 0;
X    if (tw->table.rows) XtFree((char *) (tw->table.rows));
X    tw->table.num_rows = 0;
X    tw->table.vec_width = tw->table.vec_height = 0;
X
X    /* Generate list of managed widgets with locations */
X    managed = GetManaged(tw->composite.num_children, tw->composite.children);
X    
X    /* Handle columns */
X    tw->table.num_cols = CompVector(managed, ColValues, ColSize,
X				    tw->table.col_spacing, &(tw->table.cols));
X    for (i = 0;  i < tw->table.num_cols;  i++) {
X	tw->table.vec_width += tw->table.cols[i].value;
X    }
X      
X
X    /* Handle rows */
X    tw->table.num_rows = CompVector(managed, RowValues, RowSize,
X				    tw->table.row_spacing, &(tw->table.rows));
X    for (i = 0;  i < tw->table.num_rows;  i++) {
X	tw->table.vec_height += tw->table.rows[i].value;
X    }
X
X    TblFreeLocTbl(managed);
}
X
X
static void TblRequestResize(tw)
TableWidget tw;			/* Table widget */
/*
X * Asks the parent to become the size given by the row and
X * column vectors.  Precondition: vec_state must be MINIMUM.
X */
{
X    XtGeometryResult rtn;
X    Dimension act_width, act_height;
X    Dimension r_width, r_height;
X
X    act_width = tw->table.vec_width + 2*tw->table.int_width +
X      (tw->table.num_cols-1)*tw->table.col_spacing;
X    act_height = tw->table.vec_height + 2*tw->table.int_height +
X      (tw->table.num_rows-1)*tw->table.row_spacing;
X    rtn = XtMakeResizeRequest((Widget) tw, act_width, act_height,
X			      &r_width, &r_height);
X    switch (rtn) {
X    case XtGeometryYes:
X    case XtGeometryNo:
X	/* Either case -- no action required */
X	break;
X    case XtGeometryAlmost:
X	if ((r_width >= act_width) &&
X	    (r_height >= act_height)) {
X	    (void) XtMakeResizeRequest((Widget) tw, r_width, r_height,
X				       (Dimension *) 0, (Dimension *) 0);
X	}
X	break;
X    }
}
X
X
X
static void ExtraSpace(num, vec, size)
Cardinal num;			/* Length of `vec' */
TableVecPtr vec;		/* Spacing vector  */
Dimension size;			/* Overall size    */
/*
X * If `size' is larger than the sum of all widths in `vec',
X * the extra space is distributed evenly among appropriate
X * candidates of `vec'.
X */
{
X    Cardinal i, ndist, sum = 0;
X    Cardinal *dist;
X    int diff, amt;
X
X    for (i = 0;  i < num;  i++) sum += vec[i].value;
X    diff = size - sum;
X    if (diff > 0) {
X	/* Have to distribute space */
X	dist = (Cardinal *) XtCalloc(num, sizeof(Cardinal));
X	ndist = FindDistrib(0, num, vec, dist);
X	amt = diff/ndist;
X	for (i = 0;  i < ndist-1;  i++) {
X	    vec[dist[i]].value += amt;
X	    diff -= amt;
X	}
X	vec[dist[i]].value += diff;
X	XtFree((char *) dist);
X    }
}
X
X
static Dimension SumVec(loc, span, vec, start, inter, end)
Position loc, span;		/* Start and length      */
TableVecPtr vec;		/* Spacing vector        */
Dimension start;		/* Added before sum      */
Dimension inter;		/* Added between items   */
Dimension end;			/* Added after sum       */
/*
X * Returns the sum of the space in `vec' from `loc' for length `span'.
X * Adds in the appropriate padding given by `start', `inter' and `end'.
X */
{
X    Position i;
X    Dimension sum = 0;
X
X    for (i = loc;  i < loc+span;  i++) sum += vec[i].value;
X    return sum + start + end + ((span >= 0) ? span*inter : 0);
}
X
static void PlaceWidget(w, x, y, width, height, rw, rh, opt)
Widget w;			/* What widget to place  */
Position x, y;			/* Location of space     */
Dimension width, height;	/* Size of space         */
Dimension rw, rh;		/* Actual size           */
XXtTblMask opt;			/* Justification options */
/*
X * This routine moves the widget `w' inside the space given
X * by x, y, width, height.  Its location in this space
X * is determined by looking at the justification options of 
X * `opt'.
X */
{
X    Position rx, ry;
X
X    if (opt & TBL_LEFT) rx = x;
X    else if (opt & TBL_RIGHT) rx = x + width - rw;
X    else rx = x + (width-rw)/2;
X    if (opt & TBL_TOP) ry = y;
X    else if (opt & TBL_BOTTOM) ry = y + height - rh;
X    else ry = y + (height-rh)/2;
#ifdef NOTDEF
X    rx += w->core.border_width;
X    ry += w->core.border_width;
#endif
X    
/*    XtMoveWidget(w, rx, ry);*/
X    _XmMoveObject((RectObj) w, rx, ry);
}
X
X
static void DoPlace(managed, cvec, rvec, vp, hp, rs, cs)
TableLocTblPtr managed;		/* List of managed widgets with locs */
TableVecPtr cvec, rvec;		/* Column and row spacing vector     */
Dimension vp, hp;		/* Vertical and horizontal padding   */
Dimension rs, cs;		/* Row and column interspace         */
/*
X * This routine places each widget in `managed' according to the
X * spacing vectors `cvec' and `rvec' and the widget placement
X * options (justification and resizing).  First,  if allowed,
SHAR_EOF
true || echo 'restore of Table.c failed'
fi
echo 'End of  part 1'
echo 'File Table.c is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
