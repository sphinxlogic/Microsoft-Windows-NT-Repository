Newsgroups: comp.sources.x
Path: uunet!think.com!mips!msi!dcmartin
From: crowley@chaco.cs.unm.edu (Charlie Crowley)
Subject: v17i016: point text editor (TCL and TK), Part15/16
Message-ID: <1992Mar18.142016.27962@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
References: <csx-17i002-tcl-editor@uunet.UU.NET>
Date: Wed, 18 Mar 1992 14:20:16 GMT
Approved: dcmartin@msi.com

Submitted-by: crowley@chaco.cs.unm.edu (Charlie Crowley)
Posting-number: Volume 17, Issue 16
Archive-name: tcl-editor/part15

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 14 (of 15)."
# Contents:  doc/userman.2
# Wrapped by crowley@chaco.cs.unm.edu on Tue Mar 10 15:05:51 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'doc/userman.2' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'doc/userman.2'\"
else
echo shar: Extracting \"'doc/userman.2'\" \(53933 characters\)
sed "s/^X//" >'doc/userman.2' <<'END_OF_FILE'
Then execute the {\tt CopyToHereMode} command twice.
The easiest why to do this is to click the middle mouse button twice
X(if you click quickly the mouse menu will not come up).
The first {\tt CopyToHereMode} sets the to location as the beginning of
the selected lines.
The second {\tt CopyToHereMode} moves the selection to that point.
Selecting the lines serves the dual purpose of setting the insertion
point (the copy destination) for the first {\tt CopyToHereMode}
and setting the selection (the text to be copied) for the
second {\tt CopyToHereMode}.
X
The other typical use of {\tt CopyToHereMode} is to copy in a word
or phrase while you are typing.
You are typing and you get to a point where you want to type a word that
is already visible on the screen.
Why type it again?
Stop typing, click the middle mouse button (the first {\tt CopyToHereMode}),
select the word (double click with the left mouse button), click
the middle mouse button again (the second {\tt CopyToHereMode})
and continue typing.
Note that you do note lose the insertion point when you use
X{\tt CopyToHereMode}.
X
The {\tt CopyToHereMode} command is, as the name implies,
a moded command.
It is executed in pairs and after the first execution you are in
what is called ``copy mode'' or ``duplicate mode''.
This is indicated by a pointing hand cursor (``hand1'')
X(there is an option to
set the copy mode cursor to any cursor font cursor you like,
for example you might want to use ``gumby'').
Being in copy mode does not restrict you in any way. 
All Point commands work exactly the same and you could stay
in copy mode for hours if you wanted or quite Point while in
copy mode.
The only effect of copy mode is that a second {\tt CopyToHereMode}
will complete the copy and copy the selected text to the destination
remembered when you executed the first {\tt CopyToHereMode}.
X
There is a {\tt MoveToHereMode} which works exactly the same
except the text is moved rather than copied.
I rarely use this command and you will note it is not
on the menus.
You might find a use for it.
X
The other type of copy I will call ``copy-from-to'' and it is
implemented by the Point command {\tt CopySelToMouse}.
It is attached to the move-right motion of the middle button
mouse menu.
To copy text: select the text to copy,
move the mouse sprite over the destination,
press the middle mouse button, move right a bit and then release
to execute {\tt CopySelToMouse}.
I use this to copy lines from one place to another.
Note that if you select the text in line mode,
the {\tt CopySelToMouse} command will insert the text in front of
the line over which you execute the command.
This means you don't have to be that accurate and select the very
first character of the line.
These comments also apply to word mode, {\it mutatis mutandis}.
X
Note that both ``copy''s are on mouse menus.
This is because I copy things a lot and like to do it quickly
and without thinking about how to do it
or diverting my attention from the text.
X
There is also a {\tt MoveSelToMouse} which I use frequently
but less often than {\tt CopySelToMouse}.
It works just like {\tt CopySelToMouse} except the text is
moved rather than copied.
It is attached to the move-left motion of the middle mouse menu.
I use it to rearrange text and I almost always use it on whole lines.
X
X
X
X\subsection{ Moving Windows Around and Screen Layout}
X
Your window manager allows you to move windows around.
I have move window attached to the left mouse button on the
title bar of my windows.\footnote{Actually it is a {\it twm}
function containing the commands \{f.move f.deltastop f.raiselower\}.}
But in practice I rarely move Point text windows around that way.
I have fixed on a preferred screen layout and windows go in certain
positions in that layout.
It use Point's move window commands to move windows between set
locations.
Mainly I use three locations: NE, NW and SE.
These correspond to left, right and middle button clicks on the
X``MoveW'' command on the text window menu bar.
X(They are also on the ``Move Window $=>$'' submenu of the FILE menu.)
I move windows around in a single jump using a mouse click.
X
You will want to develop your own screen layouts but when you do
I recommend using the move window commands to move windows
between fixed window locations.
X
X
X\subsection{Backup Files}
X
Backup files are great when you need then but a nuisance when you don't
need them.
The solution I have found is to store backups in a subdirectory out
of the way.
The option {\tt backupNameFormat} determines how the path names of
the backup files will be determined.
This is discussed in section \ref{sect:options}.
This allows you to specify that backups go into a subdirectory.
X
The option {\tt backupDepth} determines the number of backups to keep.
I use six and have often been glad I did.
This does use up disk space but text files are typically not that
large so it is not a major problem.
X
X
X\subsection{Undo, Redo and Again}
X
XEach command is recorded in the command history.
There is a pointer to the most recently executed
X(and not undone) command.
The undo command undoes that command and moves the
pointer back to the previous command.
Thus another undo will undo that previous command.
You can continue this way and undo every command you have
executed since the file was loaded or the last time
the file was saved.\footnote{Sorry, you cannot undo past a save.
but I am thinking of changing that.}
X
There is a separate command history for each file
X(not each window, each file).
This is most noticeable when undoing a move from one file to another.
There delete is in the command history of the ``from'' file and the
insert is in the command history of the ``to'' file.
They must be undone separately.
X
Undo undoes the effect of the last command:
deleted text is inserted again,
copied text is deleted,
moved text is moved back,
changed text is changed back.
If you select text, delete it and type in new text,
this whole action is undone as a unit.
X
There are two cases when an single undo will undo more than
one command.
The first is a delete followed by an insert at the same location.
This is taken to be a replace and is considered a single operation
and so it undone (and redone) as a unit.
The second case is when a sequence of edits has been grouped
explicitly as a block command.
There are commands to mark the beginning and the end of a block
of commands.
XFor example, one might consider a search and replace operation to be
a single command and so they are blocked.
X
If you undo a command and decide you really didn't want
to undo it you can use the redo command to redo (or un-undo) it.
In terms of the command history,
redo moves the pointer up to the next command and redoes that
command.
Thus undo moves backward in the command history list and
redo moves forward in the command history list.
X
You can undo and redo and much as you want but as soon as you
make an ordinary edit (not an undo or a redo),
the edits that were undone but not redone are discarded.
This is a bug (there is a lot of work to handle this case)
that will be corrected in a future version.
X
Again repeats the last command (that has not been undone)
in the current context.
That is, if the last edit was to delete the selection and
replace it with some other text, then redo will replace
the current selection with that text.
This is the most common use of the again command.
Again is often used with search to get the effect of a
replace with verification on each change command.
X
Again takes an optional argument that determines what
X``last command'' actually means.
You can choose the last command overall, the last command
in the file in the selection window or the last command
in the file in a named window.
X
X
X
X
X\subsection{Line numbers}
X
The default window titles indicates the range of line number shown
in the  window.
If you triple click on the line, a message is displayed
X(in the message line of the browser usually, although
this can be controlled by the user with the {\it messageFlags} option)
showing the line number.
This is the fastest way to determine the line number of a line.
X
There is a command to turn line numbering on and off in a window.
X
There are commands to jump to a specified line number or to
the selected line number.
X
X
X
X\subsection{Using the scrap}
X
Deleted text goes into a buffer called the {\it scrap buffer}.
The insert command inserts the text in the scrap buffer.
There are commands to copy the selection into the scrap buffer
and to exchange the selection with the scrap buffer.
You can use these command to exchange two strings.
These commands are all on the ``Scrap $=>$'' submenu of the EDIT menu.
X
X
X
X\subsection{Searching, C tags, and keywords}
X
There are many searching commands in Point because searching
is a common thing to do when looking at programs.
X
There are two general types of searches in Point.
In this section we discuss string search which searches for
the next instance of a specific string.
There are no special characters and the search string can contain
anything (including newlines) and it must be matched exactly.
In the next section we will discuss regular expression searching where 
you search for an instance of a string pattern that might match
a large number of strings.
X
You can search forward (or backward) for the next (or previous)
instance of the selected text.
This is the most common form of searching and so is on a mouse menu
X(right mouse button move-down is search forward for selection
and right mouse menu move-up is search backward for selection)
for quick access.
These same commands are attached to the left mouse button click
on the ``$<<$'' (for search backward) and ``$>>$'' (for search
forward) buttons on the menu bar.
The mouse menu is faster for a single search and the menu bar
button is faster and easier for repeated searches for the same string.
X
Sometimes you search for something and then after you find it you
change the selection.
XFor example you might make a small edit.
The {\tt RepeatSearch} command will search for the last string
you searched for without you having to select it again.
Indeed, the edit you made might mean that that exact string is
no longer there to select anyway.
The {\tt RepeatSearch} command is attached to the right mouse
button click on the ``$<<$'' (for search backward)
and ``$>>$'' (for search forward) buttons on the menu bar.
These commands are also attached to the F3 (search backward)
and F4 (search forward) keys.
X
I often use the F4 and F5 (repeat last edit) key together to do an
impromptu, interactive search and replace.
X
There is a search dialogue box you can bring up and type in any string
to search for.
Click the middle mouse button on the ``$<<$'' or ``$>>$'' menu
bar buttons to bring up the search dialogue box.
XFrom the search dialogue box you can type in a search string
and you can change the {\tt ignoreCase} and {\tt findWholeWords}
searching options.
X
You can also type a search string directly into the ``$<<$'' or ``$>>$''
menu bar buttons by moving the cursor to ``$<<$'' or ``$>>$'',
pressing any function key (or any non-ASCII key) to
clear the string, and typing the characters to search for.
The search is ``incremental'' (like {\tt emacs} searches) in that it searches
for the string typed in so far after each character is typed.
X
You can also search for a matching bracket.
This command (and all search commands) is on the GOTO menu.
X
Point also implements Unix tags.
You specify the tag by selecting it or entering it into a dialogue box.
Point then finds the file the tag is in, opens a window on that file
X(or tops an existing window on that file),
positions the window at the tag and selects the tag.
X
A different sort of search is the keyword search which is an internal
form of {\tt grep}.
You can activate a keyword search using the selection as the keyword
or you can bring up a dialogue box and type in the keyword
to search for.
The keyword search looks through all the {\tt *.c and *.h} files
in the current directory\footnote{The files to be searched are
changed via Point options.}
and brings up a dialogue box with a scrolling list of all the
files that contain the keyword at least once.
When you click on a file name on this scrolling list three things happen:
X\begin{enumerate}
X\item A window containing the file is displayed.
If the file is in an existing open window that window will be topped.
Otherwise a new window will be created.
X\item That window will be scrolled so that the first instance
of the keyword is visible in the window and that instance will
be selected (in character mode).
X\item The file name in the scrolling list will have an asterisk
prepended to it.
This is done so you can easily keep track of the files you have
already looked at.
X\end{enumerate}
X
X
X\subsection{Searching for regular expressions}
X
It is often useful to search for a string pattern rather than a
specific string.
XFor example, you might want to search for the next thing within
parentheses.
The regular expression for that would be:
X\begin{verbatim}
X     (.*)
X\end{verbatim}
X
A regular expression is represented in a special notation that
describes the pattern you wish to search for.
Often most of the characters in the pattern are literal characters that
you want to match exactly but some with be special codes that match
a class of characters or special features in the string.
X
XFirst let us define what a regular expression is.
A {\it regular expression} is one of:
X
X\begin{enumerate}
X
X\item {\bf char} matches itself, unless it is a special
X                character (metachar): . \ [ ] * + \verb+^+ \$
X
X\item {\bf .} matches any character.
X
X\item {\bf \verb+\+} matches the character following it, except
X		when followed by a left or right round bracket,
X		a digit 1 to 9 or a left or right angle bracket. 
X		(see [7], [8] and [9])
X		It is used as an escape character for all 
X		other meta-characters, and itself. When used
X		in a set ([4]), it is treated as an ordinary
X		character.
X
X\item {\bf [set]} matches one of the characters in the set.
X                If the first character in the set is "\verb+^+",
X                it matches a character NOT in the set, i.e. 
X		complements the set. A shorthand S-E is 
X		used to specify a set of characters S upto 
X		E, inclusive. The special characters "]" and 
X		"-" have no special meaning if they appear 
X		as the first chars in the set.
X                Some examples:
X		\begin{itemize}
X                \item {\bf [a-z]} any lowercase alpha
X
X                \item {\bf [\verb+^+]-]} any char except ] and -
X
X                \item {\bf [\verb+^+A-Z]} any char except uppercase alpha
X
X                \item {\bf [a-zA-Z]} any alpha
X		\end{itemize}
X
X\item {\bf *} any regular expression form [1] to [4], followed by
X                closure char (*) matches zero or more matches of
X                that form.
X
X\item {\bf +} same as [5], except it matches one or more.
X
X\item a regular expression in the form [1] to [10], enclosed
X                as \verb+\+(form\verb+\+) matches what form matches.
X                The enclosure creates a set of tags, used for [8] and for
X                pattern substitution. The tagged forms are numbered
X		starting from 1.
X
X\item {\bf \verb+\+D} a \verb+\+ followed by a digit 1 to 9 matches
X		whatever a
X                previously tagged regular expression ([7]) matched.
X
X\item {\bf \verb+\+<} a regular expression starting with a \verb+\+<
X		construct {\bf \verb+\+>} and/or ending with a \verb+\+>
X		construct, restricts the
X		pattern matching to the beginning of a word, and/or
X		the end of a word. A word is defined to be a character
X		string beginning and/or ending with the characters
X		A-Z a-z 0-9 and \_. It must also be preceded and/or
X		followed by any character outside those mentioned.
X
X\item a composite regular expression xy where x and y
X                are in the form [1] to [10] matches the longest
X                match of x followed by a match for y.
X
X\item {\bf \verb+^+} a regular expression starting with a \verb+^+ character
X		{\bf \$} and/or ending with a \$ character, restricts the
X                pattern matching to the beginning of the line,
X                or the end of line. [anchors] Elsewhere in the
X		pattern, \verb+^+ and \$ are treated as ordinary characters.
X
X\end{enumerate}
X
XEnter the regular expression as the search string and begin the search.
In the next section we will discuss how to use regular expression to do
search and replace operations.
X
X
X\subsection{Regular expression search and replace}
X
This operation is done from a dialog box.
You specify a regular expression to search for and a replacement pattern.
The replacement pattern allows you to replace the matched string with
a string composes of literal text and pieces of the matched string.
XFor example to find two string inside curly braces and interchange
them you would use the search pattern:
X\begin{verbatim}
X     {\([^)]*\)}\(.*\){\([^)]*\)}
X\end{verbatim}
and use the replacement pattern:
X\begin{verbatim}
X     {\3}\2{\1}
X\end{verbatim}
X
The search patterns are the same as used in regular expression search.
The replacement patterns describe how to construct the string that
will replace the string that was matched.
You can construct the replacement string using parts of the matched string.
X
The replacement string is constructed by reading the characters
of the replacement pattern one and a time and interpreting them
as follows:
X
X\begin{enumerate}
X
X\item {\bf char} put that character into the replacement string,
X		unless it is a special character (metachar): \& or \verb+\+.
X
X\item {\bf \&} put the entire matched string into the replacement string.
X
X\item {\bf \verb+\+D} put the Dth matched substring into the replacement
X	string.  A matched substring is a part of the search pattern
X	enclosed in \verb+\+( and \verb+\+).
X	D must be a digit from 1 to 9.
X
X\end{enumerate}
X
After a string is matched it is replaced by the replacement string
constructed according the replacement pattern.
You can decide whether you want to verify each replacement by
setting a toggle in the dialog box.
X
X
X
X
X\section{Customizing Point with Point Options} \label{sect:options}
X
The simplest way to customize Point is to change the values
of the Point options.
There are a number of Point options that affect the way
things are done in Point.
Most options can be changed from the ``PREFS'' menu on the
file browser menu bar.
In this section I will discuss each of the Point options.
X
Another way to customize Point is to change the Tcl code
that controls how the windows look and interact.
I will discuss that in  section \ref{sect:customize}.
X
X
X
X
X\subsection{Point Options}
X
In the following subsections the name of the option is
followed by a colon and its default value.
X
X
X\subsubsection{Browser Appearance Related Options}
X
X\begin{description}
X
X\item[browserFont:fixed (or ``font'' from resource database)]
This sets the font used to display file names in a file browser.
This option is the default font used for new file browsers.
The font of an individual file browser can be set with the
X{\tt browserFont} command (several of which are available
on the ``MISC'' menu on the browser menu bar).
X
X\item[browserGeometry:490x415+656+0]
This is the default geometry for new file browsers.
You can change the geometry of an existing window
with the {\tt MoveWindow} command or with the window manager.
X
X\item[filePattern:*]
This options sets the filter used in displaying file names
in a file browser.
X
X\item[showDirsFirst:True]
If this option is true, Point will list all directories first
X(in alphabetical order) and then the ordinary files
X(in alphabetical order).
If this option is false the directories and files will
be interspersed (in overall alphabetical order).
X
X\item[showSizes:False]
If this option is true, the file browser will show file sizes
next to file names.
X
X\end{description}
X
X
X
X\subsubsection{Text Appearance Related Options}
X
X\begin{description}
X
X\item[eofChar:1]
This options determines which character is used to mark the end of
the file in a text window.
It is specified as the numerical equivalent of its ASCII code.
The default is a small diamond in most fonts.
X
X\item[selectedTextBackground:white]
The option determines the background color for selected text
X(if underlineSelection is 0).
The value must be a color name in the X color database.
X
X\item[selectedTextForeground:black]
The option determines the foreground color for selected text
X(if underlineSelection is 0).
The value must be a color name in the X color database.
X
X\item[textBackground:white (or ``background'' from resource database)]
The option determines the background color for text.
The value must be a color name in the X color database.
X
X\item[textForeground:black (or ``foreground'' from resource database)]
The option determines the foreground color for text.
The value must be a color name in the X color database.
X
X\item[textFont:fixed or ``font'' from resource database]
This options sets the default font used for newly created windows.
You can set the font of an existing window with the {\tt textFont}
command.
It can be any font name that can be found in the X font directories.
X
X\end{description}
X
X
X
X
X\subsubsection{Text Window Appearance Related Options}
X
X\begin{description}
X
X\item[autoZoom:False]
This options causes new windows to be opened in the zoomed state.
X
X\item[copySpriteName:hand1]
The shape of the mouse sprite in text windows to indicate
that Point is in copy mode.
It can be the name of any character in the X cursor font.
X
X
X\item[iconFormat:"File: \%n"]
This option determines the contents of the window icon name that
Point gives the window.
The window manager typically uses this name as the default icon.
The {\it iconFormat} is in the same form as the {\it titleFormat}
X(see below).
X
X\item[SetLineNumbers:Not an option]
Line numbering is determined by window not by a global option.
SetLineNumbers is really a command that changes the state
of line number display in a window.
See the SetLineNumbers for details.
X
X\item[mouseMenuFont:fixed]
The font used in the popup mouse menus.
It can be any font name that can be found in the X font directories.
X
X\item[messageFlags:2]
This option determines how error messages are displayed.
It can be any number from 0 to 15 and is the sum of:
X1 if you want messages to appear in popup dialogue boxes,
X2 if you want messages to appear in the message line of all file browsers,
X4 if you want messages to appear in the title bar of the active window,
X8 if you want messages to appear in the {\tt xterm} window for which Point
was started.
X
X\item[pathNames:False]
This options determines whether full path names are used in text window
title bars and the open file list (if pathNames is True)
or only the last component of the path name is used.
X
X\item[showPartialLines:False]
If only part of a line will fit at the bottom of the window
then the line is not drawn unless this option is true.
X
X\item[spriteBackground:white]
The background color used for the mouse sprite in text windows.
X
X\item[spriteForeground:black]
The foreground color used for the mouse sprite in text windows.
X
X\item[spriteName:left\_ptr]
The shape of the mouse sprite in text windows.
X
X\item[textGeometry:500x400+0+0]
The default geometry for new text windows
X(if one is not specified in the new window command).
The geometry of existing text windows can be changed with the
window manager.
X
X\item[titleFormat:\%n\%r. readOnly. [\%l-\%L]\%c. (modified).]
This option determines the contents of the window title that
Point gives the window.
The window manager typically displayed this title in the title bar.
The {\it titleFormat} is in the form of a format string similar in spirit
to the one given to the C {\tt printf} function.
The title is generated by going through the {\it titleFormat} string
character by character.
All characters except '\%' and the character following it
are copied literally to the title.
A '\%' indicates that some specific string related to the window
is to be copied into the title.
The character after the '\%' determined which string.
The possible values are (and I am including the '\%' here for clarity):
X\begin{itemize}
X\item {\bf \%n} --- the file name (affected by pathNames option).
X\item {\bf \%N} --- the full path name of the file.
X\item {\bf \%s} --- the final component of the file name.
X\item {\bf \%c/modMsg/} --- "modMsg" if the file has changed and "" otherwise.
X		The matching '/'s can be any character that does not
X		appear in "modMsg".
X\item {\bf \%r/readOnlyMsg/} --- "readOnlyMsg" if the file is read only
X		and "" otherwise.
X		The matching '/'s can be any character that does not
X		appear in "readOnlyMsg".
X\item {\bf \%o/overTypeMsg/} --- "overTypeMsg" if Point is in over type
X		mode and "" otherwise.
X		The matching '/'s can be any character that does not
X		appear in "overTypeMsg".
X\item {\bf \%l} --- the line number of the top line in the window.
X\item {\bf \%L} --- the line number of the bottom line in the window.
X\item {\bf \%p} --- the character number (position) of the first character
X		in the window.
X\item {\bf \%P} --- the character number (position) of the last character
X		in the window.
X\item {\bf \%S} --- the size of the file (in characters).
X\item {\bf \%v} --- the column number of the leftmost column in the window.
X\item {\bf \%V} --- the column number of the rightmost column in the window.
X\end{itemize}
X
X\item[underlineSelection:0]
This options determines how the selection is shown in text windows.
A value of 0 causes Point to use the colors specified in the
options {\tt [selected]text\{foreground$\mid$background\}}.
A value of 1 causes selections to be underlined with a one pixel wide line.
A value of 2 causes selections to be underlined with a two pixel wide line.
X
X\end{description}
X
X
X\subsubsection{File and Backup Related Options}
X
X\begin{description}
X
X\item[backupByCopy:True]
If this option is true, then backups will be made by copying the
original file contents into a backup file and then copying the
new contents into the original file.
This way the original file contains the newest version and
hard links are not lost.
If this option is false, then the original file will be
renamed to the backup file and the new contents written to
a new file with the same name as the original file.
This saves one copy but loses hard links.
X
X\item[backupDepth:1]
This options determines how many levels of backup point maintains.
If backupDepth is set to 0 then no backups are made.
Otherwise it must be a value from 1 to 9.
X
X\item[backupNameFormat:\%n.\%v]
This option controls how the path name of backup files is generated.
It is like a {\tt printf} format string.
The backup file path name is generated by reading this format string
one character at a time.
All characters except ``\%'' are copied to the path name unchanged.
XEach ``\%'' is followed by a format character that indicates
what string value should replace the \% and the format character.
The following format characters are recognized:
X	\begin{description}
X	\item[n] Insert the name of the file (not the path name but
X		just the last component of the path name).
X	\item[b] Insert the base name of the file, that is, the name
X		without the extension.
X		The base name is the the name up but not including
X		the last ``.'' in the name.
X	\item[v] The version number.
X		The most recent backup will be version 1, the next
X		most recent version 2, etc.
X		Only 9 versions are supported so this will always
X		be a single digit (1 to 9).
X	\item[other] Anything else will be passed through (without the \%).
X	\end{description}
This formats allows relative or absolute path names.
XFor example you can have PC style backups with:
X\begin{verbatim}
X	set backupNameFormat %b.bak
X\end{verbatim}
You can have simple emacs style backups with:
X\begin{verbatim}
X	set backupNameFormat %n~
X\end{verbatim}
You can have complex emacs style backups with:
X\begin{verbatim}
X	set backupNameFormat %n~%v~
X\end{verbatim}
I use:
X\begin{verbatim}
X	set backupNameFormat bak/%n.%v
X\end{verbatim}
X
X\item[maxFiles:200]
The maximum number of files that can be edited at one time.
This limit will be removed soon.
X
X\item[nBuffers:300]
This options sets the number of internal buffers Point uses for text.
XEach buffer is 1024 bytes long.
This value must be 25 or greater.
A small number of buffers means that Point does more I/O.
If you have a large buffer cache in the operating system
this will not slow you down very much and you will save
redundant buffering.
X
X\item[readOnly:False]
This option determines whether new windows will be marked as read-only.
If so, no editing will be allowed.
If the UNIX file permissions do not allow writing the file,
the window will be marked read-only in any case.
X
X\end{description}
X
X
X\subsubsection{Interaction Style Options}
X
X\begin{description}
X
X\item[autoIndent:True]
This options determines whether autoindenting occurs when you
start a new line (with the Return key).
If set to True, it causes each new line to be spaced over by exactly the
same spaces and tabs as the previous line.
Point will not use tabs if the previous line used spaces.
X
X\item[button1ScrollsDown:False]
If this option is True then the scrollbars work such that
button 1 (the left mouse button) scrolls
down (towards the end of the file) and button 3 (the right mouse
button) scrolls up (towards the beginning of the file).
Setting this options to False reverses the meaning of button 1
and button 3.
X
X\item[insertReplaces:False]
If this option is True and the selection contains more than one
character, then a typed character will delete the selection
before being inserted.
If this option is false the selection is only used to determine
the insertion point and is not replaced by the insertion.
X
X\item[menuDelay:600]
This options determines the number of milliseconds of delay
after a mouse menu button is pressed before the mouse menu
comes up.
X
X\item[menuTolerance:10]
This options sets the number of pixels you have to move (after pressing
the mouse button and bringing up a mouse menu) before you leave the
X``no motion'' menu item.
X
X\item[mouseSpriteMenu:False]
This options determines whether mouse menus are displayed using
the mouse cursor (if mouseSpriteMenu is True) or with a circular
menu drawn over the text (if mouseSpriteMenu is False).
There is a delay (determined by the {\tt menuDelay} option)
before the menu comes up
so that fast mouse menu commands will not bring up the menu.
X
X\item[overType:False]
This options determines whether typed characters are inserted
at the insertion point or whether they replace the first character
of the selection.
Setting this to True allows you to type over text instead of inserting
in front of it.
X
X\item[returnString:""]
This option is used to coordinate modal dialogue boxes.
When Point puts up a dialogue box where it needs to wait for 
an answer, it sets {\tt returnString} to the empty string and
then processes events while waiting for it to become non-empty.
The {\tt WaitForReturnString} command is used to wait until the
X{\tt returnString} option is set to a non-empty value.
X
X\item[rightMargin:999]
This option determines when typed lines will be automatically broken.
The intention of the default of 999 is to not break lines but allow
them to be long.
This option also affects the margins used by the {\tt JustifySel} command.
In fact, that command will only be useful if this option is set to the
line length you want to justify to.
X
X\item[tabWidth:8]
This options sets the location of the tab stops in the text.
Tab stops are every {\tt tabWidth} characters.
Tabs must be equally spaced.
X
X\item[tkScrolling:False]
Determines the scrolling style in text window.
If this option is true the ``Macintosh'' scrolling style is used.
If this options is false the ``line to top'' scrolling style is used.
X
X\item[undoMotion:False]
Point records motion in the file (scrolling and jumping) in its
undo history but normally it is ignored.
If this option is True then undo will undo motion as well
as edits.
X
X\end{description}
X
X
X
X\subsubsection{Search Options}
X
X\begin{description}
X
X\item[findWholeWords:False]
This options determines whether searched for strings can be surrounded
by alphanumeric character.
Setting {\tt findWholeWords} to True is useful when looking for variable
names like {\it i} which occur frequently within other names.
X
X\item[ignoreCase:True]
This options determined whether case is considered in searches.
X
X\item[keywordPattern:*.c *.h]
This specifies the files that are scanned for keywords in the
keyword search commands.
X
X\item[linesOverFind:999]
When a string is searched for and the window must by jumped in
order to show the string just found,
Point needs to know how to position the window
in relation to the line the found string is on.
This option determines how many lines down from the top of the
window a found string will be placed.
A value of 0 means that it will be placed on the top line.
If the value is greater than the number of lines in the window,
the found string will be placed in the middle of the window
X(this is the default case).
This option also affects text positioning in the window after a
X{\tt GotoLine} command if the {\tt lof} argument is specified.
X
X\item[wrapInSearches:False]
If this option is set to True then forward searches will
wrap around the end of the file, that is,
a search started in the middle of a file will search
to the end of the file then continue searching at the
beginning of the file until it either finds the word
or has searched the entire file.
X
X\end{description}
X
X
X
X\subsubsection{Mouse Menu Options}
X
X\begin{description}
X
X\item[lmm1: Ext]
The text in the no-motion entry of mouse menu 1.
X
X\item[cmm1:ExtendSelection]
X
X\item[lmm1n: $<<$]
The text in the move-north entry of mouse menu 1.
X
X\item[cmm1n:Search backward [selection get]]
The command executed by the move-north entry of mouse menu 1.
X
X\item[lmm1e:Undo]
The text in the move-east entry of mouse menu 1.
X
X\item[cmm1e:Undo]
The command executed by the move-east entry of mouse menu 1.
X
X\item[lmm1s: $>>$]
The text in the move-south entry of mouse menu 1.
X
X\item[cmm1s:Search forward [selection get]]
The command executed by the move-south entry of mouse menu 1.
X
X\item[lmm1w:Again]
The text in the move-west entry of mouse menu 1.
X
X\item[cmm1w:Again]
The command executed by the move-west entry of mouse menu 1.
X
X\item[lmm2: Dup]
The text in the no-motion entry of mouse menu 2.
X
X\item[cmm2:CopyToHereMode]
The command executed by the no-motion entry of mouse menu 2.
X
X\item[lmm2n:Del ]
The text in the move-north of mouse menu 2.
X
X\item[cmm2n:Delete]
The command executed by the move-north of mouse menu 2.
X
X\item[lmm2e:Copy]
The text in the move-east entry of mouse menu 2.
X
X\item[cmm2e:CopySelToMouse]
The command executed by the move-east entry of mouse menu 2.
X
X\item[lmm2s:Ins ]
The text in the move-south entry of mouse menu 2.
X
X\item[cmm2s:Insert]
The command executed by the move-south entry of mouse menu 2.
X
X\item[lmm2w:Move]
The text in the move-west entry of mouse menu 2.
X
X\item[cmm2w:MoveSelToMouse]
The command executed by the move-west entry of mouse menu 2.
X
X\end{description}
X
X
X
X\subsection{Options you may want to change}
X
There are many Point options and in this section I want to list the ones
that you are most likely to want to change.
X
X\begin{itemize}
X
X\item {\bf tkScrolling}
I prefer line-to-top style scrolling myself since I use it to exactly
position code where I can look at as much as possible.
X
X\item {\bf button1ScrollsDown}
I learned this style of scrolling using line-to-top scrolling at Xerox.
It depends in whether your mental model has the mouse rotated to 3
o'clock or to 9 o'clock.
X
X\item {\bf backupNameFormat} and {\bf backupDepth}
I like to put the backups in a subdirectory where they don't clutter
up my directory but they are there when I need them.
Since they are out of the way I keep six backups.
This seems to be enough for almost all screw-ups.
My format is ``bak/\%n.\%v''.
X
X\item {\bf textColors}
What can I say?  Color is fun.
X
X\item {\bf textFont}
I use {\tt 6x13} because I like to see as much as possible.
If you use a larger font you will want to have some smaller fonts
on the menus so that you can temporarily change to a smaller font
to see more stuff.
X
X\item {\bf findWholeWords}
This is handy when you are looking for instance of the identifier
X{\it i} and in other similar cases.
X
X\item {\bf ignoreCase}
Normally I have this true since I hate to type shifted letters,
but once in a while you want case to matter to separate the wheat
from the chaff.
X
X\item {\bf linesOverFind}
Ordinarily you do not change this interactively but each person
has a different idea about where found string should be.
I use the middle of the window and so set this to 999.
X
X\end{itemize}
X
X
X
X\subsection{Setting local options by directory with .ptdirrc}
X
XEach time Point changes to a new directory it looks for a
file named {\tt .ptdirrc} in the new directory.
If there is one, it reads it in as a setup file.
This allows you to set options by directory.
X
XFor example you might want to change the option {\tt textForeground}.
Then you could tell by the color of the text which directory
it had come from.
X
Or you might want to have different {\tt backupDepth}s and
different {\tt backupNameFormat}s in different directories.
You might even want to have a message window pop up when
you change to a directory, an active reminder of something.
X
X
X
X\section{Customizing Point Using Tcl} \label{sect:customize}
X
Point is implemented using the Tcl command language and the Tk X toolkit.
This means that all user actions cause Tcl code to be interpreted.
All the Point commands are added to the Tcl interpreter hence all the
functionality of Point is available from Tcl
as well as  all of the Tk toolkit functionality.
Together these make a highly configurable text editor.
X
All the functionality described in this manual is achieved though
the Tcl code in {\tt ptsetup.tcl}.
You might want to look through that file (using Point for course!)
to get an idea of what is there.
X
All customization of Point is done by editing the {\tt ptsetup.tcl} file.
In this section we will describe what kinds of changes to make
to perform various levels of customization in Point.
X
X
X\subsection{Setting Point Options}
X
You will notice that the near the beginning of {\tt ptsetup.tcl}
there are a number of lines that set Point options that look like:
X\begin{verbatim}
X	Option set selectedTextBackground lawngreen
X\end{verbatim}
Any Point option can be set with a similar line.
The keywords ``Option set'' determines the command and is
always the same.
The fourth string is the name of the Point option.
These are listed in a section \ref{sect:options}.
The third string is the new value of the option.
That's all there is to it.
X
Another easy thing to do is to change the default geometries
used in various commands.
Above the {\tt Option set} lines you see three lines:
X\begin{verbatim}
X     set location1 "502x410+0+0"
X     set location2 "502x390+530+415"
X     set location3 "502x390+530+0"
X\end{verbatim}
By changing these geometries you can change where the command
place windows.
X
Unfortunately not all geometries are specified here
X(I'm working on changing that).
So you might search through {\tt ptsetup.tcl} for other
geometry specifications that you can change.
X
X
X
X\subsection{ Changing the Menus }
X
The next level of customization involves changing the menus.
I have set things up so the menus are specified using Tcl
lists which are structured a bit like Lisp lists except brackets
are used instead of parentheses.
Thus you can change the menus without having to learn too much about Tcl
and the Tk toolkit commands.
X
A word of warning: Tcl lists are fragile in the sense that a missing
bracket makes the list invalid.
The way Point is currently set up, if the Tcl menu list is invalid
than the menu doesn't get made and lots of bad things happen.
Thus you should always change a copy of {\tt ptsetup.tcl}.
I use {\tt egrep -n '\{|\}' ptsetup.tcl | more} to find sticky
problems with mismatched brackets.
I will try to make Point more robust in this respect in the future.
X
Let us look at the structure of menu specifications.
The browser menu bar is created using the Tcl variable {\tt BrowserMenuSpec}
and it is set as follows.
XFor this explanation I am using a reduced version of the 
distributed menu bar specification.
The full version can be found in {\tt ptsetup.tcl}.
It has more items on it but they are similar to these items.
X
X\begin{verbatim}
set BrowserMenuSpec {
X     {button New "  New  " {
X          {OpenFileOrCD 502x410+0+0}
X          {OpenFileOrCD 502x390+530+415}
X          {OpenFileOrCD 502x390+530+0}
X     }}
X     {menu   DIRS "DIRS"   DIRS}
X     {button DelFile "Del File" {
X          {exec rm [selection get];Option set filePattern "*"}
X          Bell
X          Bell
X     }}
X     {button Close "  Close  " {
X          CloseBrowser
X          Bell
X          Bell
X     }}
X     {menu   QUIT "QUIT"   QuitMenu}
X}
X\end{verbatim}
X
A {\it menu bar specification} is a list of items each of which is
also a list.
The specification above has four sublists
X(button, menu, button, button, menu).
XEach sublist will create one button on the menu bar.
The only two types allowed are ``button'' and ''menu''.
X
A ``button'' sublist starts with the keyword ``button''.
The second item is the name of the button.
This is used to bind other events to that button.
We will ignore it for now.
The third string is the text that will appear on the button.
You can put spaces here to space out the buttons.
The fourth item on the list is a sublist of three Tcl commands.
These are the commands that will be executed when the user clicks
the left, middle and right mouse buttons on this menu bar button.
The one for ``Close'' is the simplest.
Note that newlines can be used within bracketed lists for readability.
The left mouse button action is the Point command ``CloseBrowser''.
In general any Point command can be put here.
The Point command are all listed in section \ref{sect:commands}.
Note that we use default (ring the bell) actions for the middle
and right mouse buttons if we do not want to use them.
The command must be there and the list must have exactly three commands.
You can use ``Bell'' and ``DoNothing'' as dummy commands.
X
The ``DelFile'' button is a little more complicated.
Its left mouse button command consists of two Tcl commands.
Note that if the command is more than a single string it
must be a sublist and enclosed in brackets.
If several Tcl/Point commands are to be executed then they
must be separated by semicolons or newlines.
The phrase {\tt [selection get]} is a Tcl expression that inserts
the current X selection as that argument.
The {\tt exec} command is a Tcl command to execute a Unix command,
in this case the {\tt rm} command.
Thus the first command will delete the file that is named in the
XX selection.
The second command is a Point command to get the {\tt filePattern} option.
This will have the effect of forcing Point to reread the directory and
rewrite the list of files.
The ``New'' button has a different command for each mouse button.
XEach command has an argument so it must be enclosed in brackets
so that the command is a single item on the list.
XEach command is the Tcl procedure {\tt OpenFileOrCD} which is given below:
X\begin{verbatim}
proc OpenFileOrCD {geometry} {
X     set name [selection get]
X     if [file isdirectory $name] \
X          "CD $name" \
X          "OpenWindow $name $geometry"
X}
X\end{verbatim}
It gets the X selection and tests if it is a file or a directory.
If it is a directory to changed to it and if it is a file
it opens a window on that file.
X
A ``menu'' sublist starts with the keyword ``menu''.
The second string is the name of the button.
This is used to bind other events to that button.
The third string is the text that will appear on the button.
The forth string is the {\it name} of the string where
the submenu is specified.
Note that the submenu itself {\it cannot} appear here.
The submenu must be specified as another Tcl variable and
the name of that Tcl variable is put here.
X
Let's look at the specification of {\tt QuitMenu}:
X\begin{verbatim}
set QuitMenu {
X     {command "And save all" {QuitPoint save}}
X     {command "And ask" MakeQuitBox}
X     {command "And discard edits" {QuitPoint discard}}
X}
X\end{verbatim}
X
Menu specifications are similar to but a bit different from
menu bar specifications.
They also consist of a series of sublists,
each of which specifies one item on the menu.
There are five types of sublists,
but only the ``command'' type is used in {\tt QuitMenu}.
The ``command'' specification is similar to the ``button'' specification.
It starts with the keyword ``command'' and then the text of the
menu item.
X(No name is required as it is with a ``button''.)
The third item is a single command to execute when the button is selected.
X(You cannot give a command for each mouse buttons --- you should
use a submenu instead.)
X{\tt QuitPoint} is a Point command and {\tt MakeQuitBox} is a Tcl procedure.
You might look at {\tt MakeQuitBox} in {\tt ptsetup.tcl}
but to understand it requires familiarity with the Tk toolkit.
X
You can also look up the {\tt DIRS} menu specification string in
X{\tt ptsetup.tcl}.
It is not difficult to understand.
X
The Tcl variable {\tt TextMenuSpec} specifies
the text window menu bar.
It works just like the browser menu bar specification.
X
As a larger example of submenu specifications
let us look at the {\tt EditMenu} specification
used in {\tt TextMenuSpec}.
Below is an abbreviated version of it:
X\begin{verbatim}
set EditMenu {
X     {command "Redraw window" {Redraw}}
X     {cascade "Copy =>" {
X          {command "Note destination" {CopyToHereMode}}
X          {command "Sel to destination" {CopyToHereMode}}
X          {command "Cancel copy mode" {CancelModes}}
X     }}
X     {separator}
X     {command "Repeat last edit" {Again mostrecent}}
X}
X\end{verbatim}
This shows two more menu item types: ``separator'' and ``cascade''.
The ``separator'' one is obvious:
it generates a horizontal separator line in the menu.
The ``cascade'' type creates a pull-right (or walking) submenu.
The second string is the text to put in the menu item.
The third item in the sublist is yet another menu specification.
But this time the menu string itself must appear {\it not}
the name of a variable that it is set to as in menu bar specifications.
This is an admitted inconsistency based on the idea that these
submenus would be fairly small but menu bar menus would be larger.
You could have several levels of submenus but they get tedious for
the user if they are nested too deeply.
X
So that is the format of the menu strings.
To change the browser menu, change the value the Tcl variable
X{\tt BrowserMenuSpec} is set to and similarly for {\tt TextMenuSpec}.
You might try small changes in the existing menus as build up as you
gain confidence.
It is quite easy to remove or rearrange menu items
and it is fairly easy to add your own items.
Cascade submenus are also quite easy except for keeping
the brackets matched.
X
X
X
X\subsection{ Extending Point Using Tcl as a Macro Language }
X
Since Tcl is an interpreted language you can use it to write Point macros.
Let's look at a couple of examples.
X
This is a macro that indents each line that contains some
part of the selection:
X\begin{verbatim}
proc IndentSelection {} {
X     set sel [Sel get]
X     set here [lindex $sel 0]
X     set stop [lindex $sel 1]
X     for {} 1 {} {
X          MoveSel line left0
X          set here [lindex [Sel get] 0]
X          if {$here>$stop} \
X               break;
X          InsertString \t
X          set stop [expr $stop+1]
X          MoveSel char down
X     }
X}
X\end{verbatim}
X
The first three lines get the bounds of the selection.
The loop beginning in the fourth line continues until a {\tt break}
is executed.
We move the selection to the very first character of the line
and get its location.
If we are beyond the original selection then the loop is done.
Otherwise we insert a tab to indent the line.
Since we have added a character we have to adjust {\tt stop}.
XFinally we move down to the next line and repeat the loop.
X
This example sends the selection through a Unix command and
replaces it with the output of the Unix command.
this is analogous to the ``!'' command in {\tt vi}.
X\begin{verbatim}
proc Filter {{cmd fmt}} {
X     set s [Sel return]
X     set ret [catch {exec $cmd < $s} ns]
X     if {$ret==0} DeleteToScrap
X     InsertString $ns
X}
X\end{verbatim}
Note that {\tt fmt} is the default {\tt cmd}.
This fills the text to 72 character lines.
XFirst we get the selection and send it to the Unix command.
We use {\tt catch} in case the Unix command fails.
If the command succeeds we delete the selection
and replace it with the standard output of the command.
Otherwise we insert the error message in front of
the original selection.
X
The following three Tcl procedures make it easy to
experiment with macros:
X\begin{verbatim}
proc DefineMacro {{id 0}} {
X     set name Macro$id
X     global $name
X     set $name [selection get]
X}
X
proc ExecMacro {{id 0}} {
X     set name Macro$id
X     global $name
X     # Note the two levels of indirection on name
X     eval [set $name]
X}
X
proc ExecSel {{id 0}} {
X     eval [selection get]
X}
X\end{verbatim}
X``DefineMacro'' defines the selection as the name of the macro
and ``ExecMacro'' executes the macro with that name.
X``ExecSel'' is used to read in the macro definition.
As I was writing the above indenting macro I worked as follows.
XFirst I defined ``IndentSelection'' as the macro with ``DefineMacro''.
Then I wrote the ``proc'' definition of ``IndentSelection'', selected
it and entered the definition with ``ExecSel''.
Then I selected the sample text and executes ``ExecMacro''.
When there was an error, I corrected the definition,
entered it with ``ExecSel'' and retried it with ``ExecMacro''.
X
X
X
X
X
X\section{Hints For Using Point} \label{sect:hints}
X
In this section I will describe how a number of common
editing tasks are best performed in Point.
This is to give you an idea of some styles of editing
that the commands will support.
I will use the notations LMB, MMB and RMB for the left,
middle and right mouse buttons.
X
X{\bf To make many copies of a line(s):}
X\begin{enumerate}
X\item Select the line(s) to copy (triple click and drag while holding down
the third click for multiple lines).
X\item DeleteToScrap (F1) (to copy the lines into the scrap buffer).\footnote{
Copy to scrap would also work here but it is a less common command
and not as instinctive as delete for most people.}
X\item InsertFromScrap (F2) to replace the deleted copy.
X\item Select an insertion point and InsertFromScrap (F2).
X\item Repeat 4 as many times as necessary.
X\end{enumerate}
X
X{\bf To make one copy of a some line(s) right next to the line(s):}
X\begin{enumerate}
X\item Select the lines.
X\item Duplicate, duplicate (Click the MMB twice).
X\end{enumerate}
X
X{\bf To make one copy of a some line(s) somewhere else:}
X\begin{enumerate}
X\item Select at the location you want to copy the lines to.
X\item Duplicate (Click the MMB).
X\item Select the lines.
X\item Duplicate (Click the MMB).
X\end{enumerate}
X
X{\bf To make one copy of a some line(s) somewhere else (another method):}
X\begin{enumerate}
X\item Select the lines.
X\item Move the mouse to the location you want to copy the lines to.
X\item CopySelToMouse (press MMB and move right)
X\end{enumerate}
X
X{\bf To see more a file:}
X\begin{itemize}
X\item Zoom the window, or
X\item Change to a smaller font (File menu ``SetTextFont $=>$'' submenu).
X\end{itemize}
X
X{\bf Note:} I zoom any window that I am going to be using for more than
a minute or two.
And then I unzoom it when I am finished working with it.
I zoom and unzoom windows quite frequently.
X
X{\bf To look at two windows at the same time:}
X\begin{enumerate}
X\item Move them to different quadrants.
X\item Do this by clicking a mouse button on the ``MoveW'' menu bar item.
X(LMB for the NW quadrant, MMB for the SE quadrant, RMB for the NE quadrant)
X\end{enumerate}
X
X{\bf To switch between two places in a file:}
X\begin{enumerate}
X\item Jump to the other place.
X\item Use jump to last place to switch (click the MMB on ``Jump'')
X\end{enumerate}
X{\bf or}
X\begin{enumerate}
X\item Use forward and backward search to switch between two
instances of a name (such as the definition and a use of a procedure).
X\end{enumerate}
X
X{\bf To look at all instances of a name in a collection of files:}
X\begin{enumerate}
X\item Invoke search for selected keyword (RMB on the ``Tag'' menu bar item)
X\item Fill in the form and search.
X\end{enumerate}
X
X{\bf To move a procedure header to the top of the window:}
X\begin{enumerate}
X\item Click with the LMB on the scroll bar beside the top
line of the procedure.
X\end{enumerate}
X
X{\bf To replace words with nearby words:}
X\begin{enumerate}
X\item select the word to replace (double click with the LMB)
X\item delete (F1)
X\item duplicate (click the MMB) to mark the insertion point
X\item select the new word
X\item duplicate (click the MMB) to duplicate the selected word
to the remembered insertion point
X\end{enumerate}
X
X{\bf To insert a nearby word while typing:}
X\begin{enumerate}
X\item type up to the word
X\item duplicate
X\item select the word
X\item duplicate
X\item continue typing
X\end{enumerate}
X
X{\bf To do a search and replace:}
X\begin{enumerate}
X\item Use the replace command
X\end{enumerate}
X
X{\bf To do a search and replace (another method):}
X\begin{enumerate}
X\item Select the string to search for and search forward and then backward
X(this sets the remembered search string)
X\item search for the string until you find one you want to replace
X\item replace the string
X\item search for the next one with RepeatSearch (F4)
X\item optionally replace with Again (F5)
X\item repeat until done
X\end{enumerate}
X
X
X\input{cmds.tex}
X
X\end{document}
X
END_OF_FILE
if test 53933 -ne `wc -c <'doc/userman.2'`; then
    echo shar: \"'doc/userman.2'\" unpacked with wrong size!
fi
# end of 'doc/userman.2'
fi
echo shar: End of archive 14 \(of 15\).
cp /dev/null ark14isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
