Newsgroups: comp.sources.x
Path: uunet!think.com!mips!msi!dcmartin
From: crowley@chaco.cs.unm.edu (Charlie Crowley)
Subject: v17i003: point text editor (TCL and TK), Part02/16
Message-ID: <1992Mar18.141319.26527@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
References: <csx-17i002-tcl-editor@uunet.UU.NET>
Date: Wed, 18 Mar 1992 14:13:19 GMT
Approved: dcmartin@msi.com

Submitted-by: crowley@chaco.cs.unm.edu (Charlie Crowley)
Posting-number: Volume 17, Issue 3
Archive-name: tcl-editor/part02

#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 1 (of 15)."
# Contents:  Imakefile KnownBugs Make.dist README ToDo command.h doc
#   file.h findfiles.c help help/fkeys.help help/general.help
#   help/index.help help/mmenus.help help/options.help
#   help/scroll.help lines.c patchlevel.h piece.c tags.c tcl.c tclLib
#   tclLib/anaBoxes.tcl tclLib/cmd.tcl tclLib/macros.tcl
#   tclLib/makeMenus.tcl tclLib/ptsetup.tcl tclLib/startup.tcl
#   tclLib/tclIndex version.c
# Wrapped by crowley@chaco.cs.unm.edu on Tue Mar 10 15:05:31 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'Imakefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Imakefile'\"
else
echo shar: Extracting \"'Imakefile'\" \(1932 characters\)
sed "s/^X//" >'Imakefile' <<'END_OF_FILE'
X# $Header: /nfs/unmvax/faculty/crowley/x/pt/RCS/Imakefile,v 1.8 1992/03/04 17:06:40 crowley Exp crowley $
X
X#
X# Point - a text editor for X Windows
X#
X# Author: Charles Crowley
X#         Computer Science Dept.
X#         University of New Mexico
X#         Albuquerque, NM 87131
X#         (office) 505-277-5446
X#         (messages) 505-277-3112
X#         (net) crowley@unmvax.cs.unm.edu
X
X# **************** CHANGES REQUIRED ***************
X# This must be set to where you have the Tk distribution
TK_DIR		= FullPathNameOfTkDistribution
X
X# This must be set to the library of Point tcl files
POINT_LIBRARY   = FullPathNameOfPointDistribution/tclLib
X
X
X
TK_INCLUDES	= -I${TK_DIR} -I${TK_DIR}/tcl
X
CFLAGS		= -O ${TK_INCLUDES} -DPOINT_LIBRARY=\"${POINT_LIBRARY}\"
X
SYS_LIBRARIES	= ${TK_DIR}/libtk.a ${TK_DIR}/tcl/libtcl.a -lX11 -lm
X
OTHERFILES	= README ToDo KnownBugs Imakefile Make.dist ptsetup.tcl \
X			doc/point.n doc/userman.tex doc/cmds.tex \
X			doc/userman.ps help/fkeys.help help/index.help \
X			help/options.help help/general.help help/mmenus.help \
X			help/scroll.help
X
X
INCLUDEFILES	= ana.h command.h file.h funcdecl.h pt.h
X
SOURCES		= anaDialogs.c anaObjects.c anaSources.c \
X			browser.c buffers.c cmdTable.c command.c \
X			copymove.c cursor.c display.c fileio.c \
X			findfiles.c findpos.c goto.c \
X			inschar.c insdel.c \
X			library.c lines.c mouse.c options.c piece.c \
X			point.c pt.c regex.c repaint.c replace.c search.c \
X			select.c spans.c stats.c tags.c tcl.c tkColbox.c \
X			undoredo.c version.c windows.c
X
OBJS		= anaDialogs.o anaObjects.o anaSources.o browser.o \
X			buffers.o cmdTable.o command.o copymove.o \
X			cursor.o display.o fileio.o \
X			findfiles.o findpos.o goto.o \
X			inschar.o insdel.o \
X			library.o lines.o mouse.o options.o piece.o \
X			point.o regex.o repaint.o replace.o search.o select.o \
X			spans.o stats.o tags.o tcl.o tkColbox.o undoredo.o \
X			version.o windows.o
X
ComplexProgramTarget(point)
X
END_OF_FILE
if test 1932 -ne `wc -c <'Imakefile'`; then
    echo shar: \"'Imakefile'\" unpacked with wrong size!
fi
# end of 'Imakefile'
fi
if test -f 'KnownBugs' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'KnownBugs'\"
else
echo shar: Extracting \"'KnownBugs'\" \(876 characters\)
sed "s/^X//" >'KnownBugs' <<'END_OF_FILE'
X			KNOWN BUGS
X
This is a list of know bugs in Point.  Most of them are minor and are on
my to-do list but near the bottom of it.
X
X* MoveToLastPlace acts seems to lose places sometimes.
X* The line numbers on the title bar sometimes get messed up.
X* FindMatchingBrackets does not work correctly.
X* Justify lines is very rough.
X* The undoMotion option is not implemented.
X* The backupByCopy option is not implemented.
X* The showSizes option is not fully debugged.
X* The lineNumbers option screws up if you try to edit the file while line
X	numbers are present.
X* The autoZoom option has no effect.
X* The showPartialLines option has no effect.
X* The filePattern option has no effect.
X* Undo begin and Undo end do not work properly when redoing edits.
X* When pt has to start point things sometimes fail.
X* Internal search and replace does not honor the 'withing selection' option.
X
END_OF_FILE
if test 876 -ne `wc -c <'KnownBugs'`; then
    echo shar: \"'KnownBugs'\" unpacked with wrong size!
fi
# end of 'KnownBugs'
fi
if test -f 'Make.dist' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'Make.dist'\"
else
echo shar: Extracting \"'Make.dist'\" \(1947 characters\)
sed "s/^X//" >'Make.dist' <<'END_OF_FILE'
X# /* $Header: /nfs/unmvax/faculty/crowley/x/pt/RCS/Make.dist,v 1.10 1992/03/04 17:06:40 crowley Exp crowley $ */
X#
X# Point - a text editor for X Windows
X#
X# Author: Charles Crowley
X#         Computer Science Dept.
X#         University of New Mexico
X#         Albuquerque, NM 87131
X#         (office) 505-277-5446
X#         (messages) 505-277-3112
X#         (net) crowley@unmvax.cs.unm.edu
X
X
X# **************** CHANGES REQUIRED ***************
X# This must be set to where you have the Tk distribution
TK_DIR		= FullPathNameOfTkDistribution
X
X# This must be set to the library of Point tcl files
POINT_LIBRARY   = FullPathNameOfPointDistribution/tclLib
X
X
X
TK_INCLUDES =	-I${TK_DIR} -I${TK_DIR}/tcl
X
CFLAGS =	-O ${TK_INCLUDES} -DPOINT_LIBRARY=\"${POINT_LIBRARY}\"
X
LDFLAGS =	-O ${TK_DIR}/libtk.a ${TK_DIR}/tcl/libtcl.a -lX11 -lm
X
CC =		cc
X
OTHERS = README ToDo KnownBugs Imakefile Make.dist ptsetup.tcl \
X		doc/point.n doc/userman.tex doc/cmds/tex \
X		doc/userman.ps help/*.help tclLib/*.tcl tclLib/tclIndex
X
INCLUDES = ana.h command.h file.h funcdecl.h pt.h
X
SOURCES	= anaDialogs.c anaObjects.c anaSources.c \
X	browser.c buffers.c cmdTable.c command.c \
X	copymove.c cursor.c display.c fileio.c \
X	findfiles.c findpos.c goto.c \
X	inschar.c insdel.c \
X	library.c lines.c mouse.c options.c piece.c \
X	point.c pt.c regex.c repaint.c replace.c search.c \
X	select.c spans.c stats.c tags.c tcl.c tkColbox.c undoredo.c \
X	version.c windows.c
X
OBJS	= anaDialogs.o anaObjects.o anaSources.o browser.o \
X	buffers.o cmdTable.o command.o copymove.o \
X	cursor.o display.o fileio.o \
X	findfiles.o findpos.o goto.o \
X	inschar.o insdel.o \
X	library.o lines.o mouse.o options.o piece.o \
X	point.o regex.o repaint.o replace.o search.o select.o \
X	spans.o stats.o tags.o tcl.o tkColbox.o undoredo.o \
X	version.o windows.o
X
point: $(OBJS)
X	-rm -f point
X	${CC} -o point $(OBJS) $(LDFLAGS)
X
pt: pt.o
X	-rm -f pt
X	${CC} -o pt pt.o $(LDFLAGS)
X
clean:
X	rm -f $(OBJS) point pt
X
END_OF_FILE
if test 1947 -ne `wc -c <'Make.dist'`; then
    echo shar: \"'Make.dist'\" unpacked with wrong size!
fi
# end of 'Make.dist'
fi
if test -f 'README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'README'\"
else
echo shar: Extracting \"'README'\" \(6903 characters\)
sed "s/^X//" >'README' <<'END_OF_FILE'
X$Header: /nfs/unmvax/faculty/crowley/x/pt/RCS/README,v 1.6 1992/03/04 17:06:40 crowley Exp crowley $
X
X		THE POINT TEXT EDITOR FOR X
X
Point is a text editor for X windows.  It is specifically designed to use
the mouse as much as possible in editing.  It also provided convenient
ways to keep a number of windows open on files and ways to copy text
between and within files using the mouse.
X
Some features of Point:
X* Unlimited number of windows and files
X* Easy move and copy within and between windows
X* Completely configurable: menus, key meanings, titles, etc.
X* Extensive options to modify the look and behavior
X* Uses Tcl as a macro language and the Tk toolkit
X* Flexible searching: for selection, for last string searched for,
X    for a regular expression, for the last regular expression,
X    for a string in a list of files, for a C tag.
X* File browsers vaguely similar to NeXT to load files.
X* Circular mouse menus, that is, "gesture" commands
X* Unlimited undo, redo and again (repeat last command)
X
I have built Point on:
X
X(1) SUN 4 running SunOS 4.1
X(2) DEC 5000/200 running Ultrix 4.1
X
The distribution builds fine on both of them.
I have also built it on:
X
X(3) Macintosh FX running AUX where point runs but the file browser does
X    not show the files correctly, something about the opendir/readdir
X    interface I think.
X
If you have any problems please feel free to call me or send me email.
X
X
X		RECENT CHANGES
X
X"Changes.log" describes the recent changes to point in chronilogical
order.  "Changes.doc" gives longer explanations of some of the
changes.
X
X
X		FIRST GET TK/TCL
X
Point uses the Tk/Tcl distribution, using Tcl as its macro language and
Tk as its widget set.  In order to build point you have to first build
Tk/Tcl.  This version of Point works with Tcl version 6.2 and Tk version 1.4.
The first thing to do is to get the Tk/Tcl distribution.  You can get
this from allspice.berkeley.edu in tcl/tk1.4.tar.Z,from unmvax.cs.unm.edu
in pub/Point/tk1.4.tar.Z or from several other places.
X
Tcl/Tk is very interesting in its own right and I encourage you to look
through it.  The Tk distribution creates a directory "tk1.4".
X
X
X		THEN BUILD POINT
X
Once you have built Tk/Tcl you can build Point:
X
X1. Execute "zcat pt.tar.Z | tar xvf -" to uncompress and untar the files.
X   It puts everything into the current directory so create a subdirectory
X   "Point" and move to it before you untar.
X
X2. On a System V UNIX set the SYSV preprocessor variable at the top of pt.h.
X   The SYSV variable only affects the way opendir and readdir are used.
X   You might look at that code and see which form your system supports
X   by looking at the man page for "opendir".
X
X3. Set the TK_DIR variable in Imakefile and/or Make.dist to the path name
X   of the main directory of the tk distribution. The makefiles expect the
X   libraries to be where they are built in tk: $(TK_DIR)/libtk.a and
X   $(TK_DIR)/libtcl/tcl.a.  If they are somewhere else you must edit the
X   makefile.  The compiles also require the include files in the TK_DIR tree.
X
X4. The POINT_LIBRARY must be set correctly, that is, to the subdirectory
X   of the Point distribution where the startup file is.  This should be
X   a full pathname that Point will work no matter which directory you
X   start point in.
X
X5. Use "xmkmf" to create the Makefile from the Imakefile.
X   If you do not have or do not like imake you can use "Make.dist",
X   use "ln Make.dist Makefile" or "make -f Make.dist".
X   You will have to modify the link step if you keep your X libraries
X   in a place other than /usr/lib.  We keep our's in /usr/local/X11/lib.
X
X6. Run make.
X
X
X		THEN BE SURE THE INITIALIZATION FILES IN ORDER
X
Point requires a number of files to run correctly and these must be in files
where Point can find them.  The key is the POINT_LIBRARY which was
specified in the Makefile.  This allows Point to start up from any
directory and always find the necessary files.  These files can be in a
system area or in your personal directory tree if you are building Point
for your own use and not installing it on the system in general.
The default startup file is the file "POINT_LIBRARY/startup.tcl" which
completes the Point initialization.  It tries three things until one works:
X
X1. Look for ~/.ptrc and use it as the initialization file.  Otherwise:
X
X2. Look for ./ptsetup.tcl and use it as the initialization file.  Otherwise:
X
X3. Look for $POINT_LIBRARY/ptsetup.tcl and use it as the initialization
X     file.  Otherwise give up.
X
X
This gets you to "ptsetup.tcl" which does the main initialization:
X
X1. It sets up some variables used in other tcl files. See 4 below.
X
X2. It sets personal option preferences.
X
X3. It initializes tcl and autoloading and explicitly loads in the files
X     necessary to run point.
X
X4. Finally you should set HelpDirectory (line 5 in ptsetup.tcl) to the
X     directory where the help files are located.  In the distribution they
X     are in a subdirectory "help".  They are the files of the form *.help.
X
Thus there is one important directory that contains all the tcl files.
This is "tclLib" in the distribution.  Setting POINT_LIBRARY to "tclLib"
and using the default files there should make everything work.
X
This may all seem complicated and it is.  I set things up this way so
that Point would always find system default files no matter where you
start it.  Also the minimum information is kept in the Point binary
and almost all of the setup sequence is in tcl code that is easily changed.
X
X
X		THEN RUN POINT
X
Now you can run "point README" to test it out.
X
You can generate the manual page(s) from doc/point.n with nroff or troff
or ptroff or whatever ("ptroff -man doc/pt.n" in my system).  The reference
manual is in doc/userman.tex. The reference manual is in LaTeX format but
I have also included a Postscript version in doc/userman.ps.  If you are
getting this from comp.sources.x then there will be no Postscript file
and doc/userman.tex will be divided into userman.part1 and userman.part2.
Just cat them together to create the tex file:
X	cat userman.part[12] >userman.tex
X	rm userman.part[12]
X
X
X		PROBLEMS?
X
If you have any problems building Point please call me at 505-277-5446
or email me at crowley@unmvax.cs.unm.edu and I will try my best to
help you overcome your problem.  Even if you find a workaround for a
build problem I would like to hear about it so I can fix it in my stuff.
X
Point is still under active development and any suggestions for changes
and improvement are welcome and very much appreciated.  Also bug reports,
of course.  I will be happy to add features for people who make suggestions.
The file TODO records some of my plans for improvements.
X
X
X		HISTORY
X
Point is an X version of a PC text editor of the same name that was bundled
with the Logitech mouse for a couple of years.  I have been working on the X
version off and on for over a year (mostly off unfortunately).
X
END_OF_FILE
if test 6903 -ne `wc -c <'README'`; then
    echo shar: \"'README'\" unpacked with wrong size!
fi
# end of 'README'
fi
if test -f 'ToDo' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'ToDo'\"
else
echo shar: Extracting \"'ToDo'\" \(380 characters\)
sed "s/^X//" >'ToDo' <<'END_OF_FILE'
This file describes some of the plans I have for improving Point.
X
X* better undo/redo with selective (non-sequential) undo and redo
X* file splits within a single window
X* folded lines as an alternative to horizontal scrolling
X* zero-width selections and typing deletes the selection
X* remove the option limiting the number of open files
X* add hypertext features
X* convert to C++
X
END_OF_FILE
if test 380 -ne `wc -c <'ToDo'`; then
    echo shar: \"'ToDo'\" unpacked with wrong size!
fi
# end of 'ToDo'
fi
if test -f 'command.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'command.h'\"
else
echo shar: Extracting \"'command.h'\" \(1608 characters\)
sed "s/^X//" >'command.h' <<'END_OF_FILE'
X/* $Header: /nfs/unmvax/faculty/crowley/x/pt/RCS/command.h,v 1.9 1992/02/19 16:43:42 crowley Exp crowley $ */
X
struct commandTableEntry {
X	char *command_name;
X	int command_number;
X};
X
X/* Define the functions */
typedef enum {
X	FNOTUSED,	/* so 0 is not a valid command */
X	FDONOTHING,
X	FEXTEND,
X	FINSASCII,
X	FINSERT,
X	FJUSTIFY,
X	FDELETE,
X	FEXCHSCRAP,
X	FCOPYSCRAP,
X	FCOPYTO,
X	FMOVETO,
X	FCOPYFROM,/* duplicate */
X	FMOVEFROM,/* extract */
X	FREDO,
X	FUNDO,
X	FREPLACE,
X	FCTAG,
X	FMATCHCHAR,
X	FBOTFILE,
X	FGOTOSELECTION,
X	FGOBACKTO,
X	FGOTOLINE,
X	FMOVESEL,
X	FWINDOWFONT,
X	FREADONLY,
X	FCANCEL,
X	FSAVEFILE,
X	FWRITEFILE,
X	FSAVEALL,
X	FCLOSEWINDOW,
X	FINFORMONCLOSE,
X	FZOOM,
X	FQUITPOINT,
X	FEXECCMD,
X	FHELP,
X	FREDRAW,
X	FCD,
X	FCHANGECASE,
X	FBROWSERFONT,
X	FINSBLOCK,
X	FCREATEBLOCK,
X	FCREATEATTRIBUTE,
X	FCREATELINK,
X	FCREATEMAP,
X	FCREATEDOCUMENT,
X	FCREATEVIEW,
X	FADDFILETODOCUMENT,
X	FCHANGEMAP,
X	FCLOSEDOCUMENT,
X	FSHOWATTRIBUTES,
X	FSHOWBLOCKS,
X	FSHOWDOCUMENTS,
X	FSHOWFILES,
X	FSHOWLINKS,
X	FSHOWMAPS,
X	FSHOWTEXTS,
X	FSHOWVIEWS,
X	FGOTODIGIT,
X	FSEARCHLETTER,
X	FBROWSER,
X	FPRINTSTATS,
X	FCLOSEBROWSER,
X	FSHOWUNDOS,
X	FREPEATSEARCH,
X	FREPEATSEARCHBACK,
X	FAGAIN,
X	FSCROLLWINDOW,
X	FPOINTSELECTION,
X	FINSERTSTRING,
X	FSEARCHFORS,
X	FGETFILECHARS,
X	FGETROWCOL,
X	FGETWINDOWLIST,
X	FWINDOWNAME,
X	FGETWINDOWINFO,
X	FGETFILEINFO,
X	FRAISELISTWINDOW,
X	FRAISE,
X	FLOWER,
X	FOPTION,
X	FKEY,
X	FMOUSE,
X	FCONFIGURE,
X	FEXPOSE,
X	FVSCROLL,
X	FHSCROLL,
X	FENTERTEXT,
X	FENTERBROWSER,
X	FSETTEXTCOLOR,
X	FOPENWINDOW,
X	FWAITFORRETURNSTRING,
X	FBARRIER,
X	FREGEXSEARCH,
X	FREPEATREGEXSEARCH,
X	FREGEXREPLACEONE,
X	FREGEXREPLACEALL,
X	FLINENUMBERS,
X	FLASTCOMMAND
X} PointCommand;
END_OF_FILE
if test 1608 -ne `wc -c <'command.h'`; then
    echo shar: \"'command.h'\" unpacked with wrong size!
fi
# end of 'command.h'
fi
if test ! -d 'doc' ; then
    echo shar: Creating directory \"'doc'\"
    mkdir 'doc'
fi
if test -f 'file.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'file.h'\"
else
echo shar: Extracting \"'file.h'\" \(3257 characters\)
sed "s/^X//" >'file.h' <<'END_OF_FILE'
X/* $Header: /nfs/unmvax/faculty/crowley/x/pt/RCS/file.h,v 1.2 91/08/01 16:57:49 crowley Exp Locker: crowley $ */
X
X/* a PIECE is a sequence of characters that is contiguous in the logical */
X/* and physical files.  Originally the file is one (big) piece.  As edits */
X/* are made it is divided into more pieces.  The characters in a piece */
X/* are either in the original (unchanged) file or in the add file (which) */
X/* contains all characters that have been added to the file in this editing */
X/* session */
X
struct piece {
X	char flags;		/* record various Boolean data */
X	int file;		/* Unix file handle */
X	BlockID blockID;	/* block piece comes from or NullObject */
X				/* if it comes from a format string */
X	Offset position;	/* start of the piece */
X	Offset length;		/* length of the piece */
X	struct piece *nextClone;/* next piece in the clone list */
X	struct piece *nextPiece;/* next piece in the list */
X	struct piece *prevPiece;/* previous piece in the list */
X};
X
X/* piece.flags constants */
X#define IS_CLONED_PIECE		1
X#define IS_DECORATION		2
X
typedef struct piece *Piece;
X
X/* An open file consists of the original file (which is not changed during */
X/* an editing session) and an add file (where all new characters go). */
X/* The logical file is described in the pieces table which shows where */
X/* the logically contiguous characters in the file are physically located */
X
struct openFile {
X
X	/* flag to keep track of whether this is a view or not */
X	int isView;
X
X	/* the original file size */
X	Offset origFileSize;
X
X	/* the current logical file size -- changed as the file is edited */
X	/* NOT the same as the size of origfile or addfile or their sum */
X	Offset fileSize;
X
X	/* the file being edited -- this is read only */
X	char origName[FILENAMESIZE];
X	int origHandle;
X
X	/* the piece list */
X	Piece pieceList;
X	
X	/* the command history */
X	struct changeItem * cmdHistory;
X
X	/* optimization fields */
X	/* loLogPiece and hiLogPiece are the low and high logical addresses */
X	/* that are mapped by piece number logPiece which is the last piece */
X	/* where a byte was found and is initialized to the one big piece */
X	/* that is the whole file when you start editing. */
X	/* The idea is that once you map a logical byte to a piece, it is */
X	/* likely that the next mapping is in the same piece. */
X	/* loLogBuffer and hiLogBuffer are the logical character limits of */
X	/* some valid characters in a buffer pointed to by logBuffer. */
X	Offset loLogPiece, hiLogPiece, loLogBuffer, hiLogBuffer;
X	Piece logPiece;
X	unsigned char *logBuf;
X
X	/* some file status flags */
X	char useCount;	/* the number of windows using the file */
X	char flags;	/* various information (see below) */
X};
X
X/* flags */
X#define BAK_MADE	1	/* a backup copy has been made */
X#define READ_ONLY	2	/* file cannot be written (changeable) */
X#define IS_CHANGED	4	/* file has been changed but not yet saved */
X#define NO_WRITES	8	/* file can never be written (no changeable) */
X
X/* a disk buffer (both in and out of the address space) */
struct diskBuffer {
X	int handle;	/* DOS file handle */
X	/* double linked hash chain links */
X	struct diskBuffer *forwardHash, *backwardHash;
X	int blockNumber;
X	unsigned char *bufferAddress;
X	char written;	/* =1 if an add file block */
X};
END_OF_FILE
if test 3257 -ne `wc -c <'file.h'`; then
    echo shar: \"'file.h'\" unpacked with wrong size!
fi
# end of 'file.h'
fi
if test -f 'findfiles.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'findfiles.c'\"
else
echo shar: Extracting \"'findfiles.c'\" \(2511 characters\)
sed "s/^X//" >'findfiles.c' <<'END_OF_FILE'
X/* $Header: /nfs/unmvax/faculty/crowley/x/pt/RCS/findfiles.c,v 1.5 1992/03/04 17:07:18 crowley Exp crowley $ */
X
X#include <sys/types.h>
X#include "pt.h"
X#ifdef SYSV
X#include <dirent.h>
X#else
X#include <sys/dir.h>
X#endif
X#include <ctype.h>
X#include <string.h>
X#include <stdio.h>
X
X/* scratch file name */
char scratchFileName[FILENAMESIZE];
X
char *
makeFullPathname(origName)
X	char *origName;
X{
X	extern char msgBuffer[];
X	extern char scratchFileName[];
X
X	int n;
X	register char *p;
X	char *fromPtr, *toPtr;
X
X	/* first figure out what we have to do */
X	if( origName[0] != '/' ) {
X		/* must prepend the current drive and directory */
X		(void)getcwd(scratchFileName, FILENAMESIZE);
X		n = strlen(scratchFileName);
X		if( scratchFileName[n-1] != '/' ) {
X			scratchFileName[n++] = '/';
X			scratchFileName[n] = '\0';
X		}
X	} else
X		scratchFileName[0] = '\0';
X	strncat(scratchFileName, origName, FILENAMESIZE);
X	
X	/* now eliminate any ".." components */
X	p = scratchFileName;
X	while( *p != '\0' ) {
X		/* look for a "/../" */
X		if( *p=='.' && *(p+1)=='.' && *(p-1)=='/' && *(p+2)=='/' ) {
X			/* find the previous path component */
X			n = 2;
X			while( 1 ) {
X				if( (p-n) < scratchFileName )
X					/* string is "component/../ ..." */
X					break;
X				if( *(p-n) == '/' )
X					break;
X				++n;
X			}
X			/* eliminate the "component/../" by copying the */
X			/* rest of the  string up n character positions */
X			fromPtr = p + 3;
X			/* *(p-n) is the last character to keep so: */
X			toPtr = p - n + 1;
X			/* move p to continue the scan at the beginning */
X			/* of the moved part of the string */
X			p = toPtr;
X			while( 1 ) {
X				if( (*toPtr++ = *fromPtr++) == '\0' )
X					break;
X			}
X		} else
X			++p;
X	}
X
X	return scratchFileName;
X}
X
int
striccmp( a, b )
X	char *a, *b;
X{
X	char cha, chb;
X
X	while( 1 ) {
X		chb = *b++;
X		if( (cha = *a++) == '\0' )
X			break;
X		/* not end of string for 'a' */
X		if( cha != chb ) {
X			if( isupper(cha) )
X				cha = tolower(cha);
X			if( isupper(chb) )
X				chb = tolower(chb);
X			if( cha != chb )	
X				break;
X			/* either chb is a letter hence not end of string */
X			/* for 'b' or if cha != chb we break */
X		} /* else cha == chb hence not end of string for 'b' either */
X	}
X	return cha - chb;
X}
X
struct window *
findFilenameWindow(filename)
X	char *filename;
X{
X	extern struct window *windowList;
X	extern struct openFile *files;
X
X	register struct window *w;
X
X	w = windowList;
X	while( w != NULL ) {
X		if( striccmp(files[w->fileId].origName, filename) == 0 )
X			return w;
X		w = w->nextWindow;
X	}
X	return NULL;
X}
END_OF_FILE
if test 2511 -ne `wc -c <'findfiles.c'`; then
    echo shar: \"'findfiles.c'\" unpacked with wrong size!
fi
# end of 'findfiles.c'
fi
if test ! -d 'help' ; then
    echo shar: Creating directory \"'help'\"
    mkdir 'help'
fi
if test -f 'help/fkeys.help' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/fkeys.help'\"
else
echo shar: Extracting \"'help/fkeys.help'\" \(1313 characters\)
sed "s/^X//" >'help/fkeys.help' <<'END_OF_FILE'
XFUNCTION KEY BINDINGS
X
XF1	Delete the selection to the scrap buffer
XF2	Insert the contents of the scrap buffer in front of the selection
XF3	Search backwards for the last string that was searched for
XF4	Search forewards for the last string that was searched for
XF5	Repeat the last edit but with the current selection and insertion point
XF6	Redo the most recently undone edit in the file
XF7	Scroll the window up (towards the beginning of the file) one screenful
XF8	Scroll the window down (towards the end of the file) one screenful
XF9	Undo the most recently done edit
Up	Move the selection up one line
Down	Move the selection down one line
Right	Move the selection one character to the right
Left	Move the selection one character to the left
Home	Move the selection to the first non-white space character on the line
XEnd	Move the selection to the last character on the line (the newline)
PageUp	Scroll the window one page up (towards the beginning of the file)
PageDown Scroll the window one page down (towards the end of the file)
X
TO CLOSE THIS WINDOW: click the left mouse button on the `Close' command
X			on the menu bar at the top of this window.
X
TO CHANGE THESE BINDING: edit the startup file `ptsetup.tcl'.  Search for
X			the string 'TextBindings' and you can probably figure
X			out how to change a binding.
END_OF_FILE
if test 1313 -ne `wc -c <'help/fkeys.help'`; then
    echo shar: \"'help/fkeys.help'\" unpacked with wrong size!
fi
# end of 'help/fkeys.help'
fi
if test -f 'help/general.help' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/general.help'\"
else
echo shar: Extracting \"'help/general.help'\" \(651 characters\)
sed "s/^X//" >'help/general.help' <<'END_OF_FILE'
X		GENERAL HELP ON POINT
X
TO CLOSE THIS WINDOW: click the left mouse button on the `Close' command
X			on the menu bar at the top of this window.
X
TO EXIT POINT: If a file browser window is in your screen, move the mouse to
X		the `QUIT' box on the right side of its top menu bar.  Press
X		the left mouse button and select a quit option.
X	       If there is no file browser visible, move the mouse sprite to
X		to the `FILE' box on the left side of the menu bar of this
X		window. Press the left mouse button and move the mouse sprite
X		down to the box labelled `Open ...' and release the mouse
X		button.  When the file browser appears use its QUIT menu.
X
END_OF_FILE
if test 651 -ne `wc -c <'help/general.help'`; then
    echo shar: \"'help/general.help'\" unpacked with wrong size!
fi
# end of 'help/general.help'
fi
if test -f 'help/index.help' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/index.help'\"
else
echo shar: Extracting \"'help/index.help'\" \(300 characters\)
sed "s/^X//" >'help/index.help' <<'END_OF_FILE'
fkeys.help 500 400 +0 +0 function keys function key keyboard keystroke
general.help 500 400 +0 +0 general
mmenus.help 500 400 +0 +0 mouse menus mouse menu popup menus popup menu
scroll.help 500 400 +0 +0 scroll scrolling scroll bar slider
options.help 500 400 +0 +0 option options resource resources
END_OF_FILE
if test 300 -ne `wc -c <'help/index.help'`; then
    echo shar: \"'help/index.help'\" unpacked with wrong size!
fi
# end of 'help/index.help'
fi
if test -f 'help/mmenus.help' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/mmenus.help'\"
else
echo shar: Extracting \"'help/mmenus.help'\" \(1053 characters\)
sed "s/^X//" >'help/mmenus.help' <<'END_OF_FILE'
X		HELP ON POPUP MOUSE MENUS
X
TO POPUP A MOUSE MENU: With the mouse sprite inside the text area, press the
X	middle or right mouse button.  Wait 0.6 seconds and the menu will
X	pop up.
TO CANCEL A MOUSE MENU WITHOUT EXECUTING ANY COMMANDS: Click the left mouse
X	button and then release the middle or right mouse button.
TO SELECT ITEMS ON THE MOUSE MENU: While holding down the middle or right 
X	mouse button, move around the menu.  The item closest to the mouse
X	sprite will be selected.
TO EXECUTE A COMMAND ON A MOUSE MENU: Select the item and release the middle
X	or right mouse button while it is selected.
TO EXECUTE A MOUSE MENU COMMAND QUICKLY: Press the middle or right mouse
X	button (do not wait for the menu to come up), move in the direction
X	of the item and release the mouse button.  For the first 0.6 second
X	the menu is logically there but doesn't appear.
MIDDLE MOUSE BUTTON COMMANDS:
X        Del		Del:  Delete the selection
X         |		Move: Move the selection to this point
Move <- Dup -> Copy	Dup:  CopyToHereMode
X         |
X        Ins
END_OF_FILE
if test 1053 -ne `wc -c <'help/mmenus.help'`; then
    echo shar: \"'help/mmenus.help'\" unpacked with wrong size!
fi
# end of 'help/mmenus.help'
fi
if test -f 'help/options.help' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/options.help'\"
else
echo shar: Extracting \"'help/options.help'\" \(1436 characters\)
sed "s/^X//" >'help/options.help' <<'END_OF_FILE'
X		HELP ON OPTIONS
X
TO ACCESS OPTIONS: Move the mouse sprite to the box labelled `PREFS' on the
X	left side of the top menu bar of the file browser.  Press the
X	left mouse button and a menu will drop down.
X
TO KEEP THE OPTIONS MENU ON THE SCREEN: Move the mouse sprite to the box
X	labelled `PREFS' on the left side of the top menu bar of the file
X	browser.  Hold down the SHIFT key and press the left mouse button.
X	Hold down the left mouse button and move the menu where you want it
X	to go and then release the left mouse button.
X
TO CHANGE BOOLEAN OPTIONS: Boolean option have a square box on the left.
X	The square is dark if the option is on or true.  Change them
X	(off to on or on to off) by clicking on them.
X
TO CHANGE 'ONE OF SEVERAL' OPTIONS: These options have diamonds on their left.
X	Click on the new one to change to it, the old value will be
X	automatically turned off.
X
TO CHANGE STRING VALUED OPTIONS: Menu items followed by `...' will pop up a
X	dialogue box when you select them.  These are used for options that
X	have a string value.  Move the mouse cursor to the entry field
X	(no mouse click is necessary) and type in the new value.  Entering
X	a carriage return at the end signals the end of the string and
X	sets the new value.
X	
TO GET TO SUBMENUS: Submenus have a `==>' on their right.  Move the mouse
X	sprite over the item and the submenu will appear.  Move directly
X	right over to the submenu to select items on it.
X
END_OF_FILE
if test 1436 -ne `wc -c <'help/options.help'`; then
    echo shar: \"'help/options.help'\" unpacked with wrong size!
fi
# end of 'help/options.help'
fi
if test -f 'help/scroll.help' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'help/scroll.help'\"
else
echo shar: Extracting \"'help/scroll.help'\" \(1270 characters\)
sed "s/^X//" >'help/scroll.help' <<'END_OF_FILE'
X		HELP ON SCROLLING AND SCROLLBARS
X
TO SCROLL DOWN (towards the end of the file): Move the mouse sprite inside
X		the scrollbar on the left side of the window next to the line
X		you want to be the new top line in the window.  Then click the
X		RIGHT mouse button.  Hold down for continuous scrolling.
X
TO SCROLL UP (towards the beginning of the file): Move the mouse sprite inside
X		the scrollbar on the left side of the window next to the line
X		you want to be the new top line in the window.  Then click the
X		LEFT mouse button.  Hold down for continuous scrolling.
X
TO KNOW WHERE YOU ARE IN THE FILE: The entire scrollbar represent the whole
X		file.  The slider inside it represents the part of the file
X		you are seeing.
X
TO JUMP TO A PLACE IN THE FILE: Move the mouse sprite inside the scrollbar
X		on the left side of the window at the approximate place in
X		the file you want to jump to.  That is, if you want to go to
X		a place about 3/4 of the way through the file, move the mouse
X		sprite 3/4 of the way down the scroll bar.  Then press the
X		MIDDLE mouse button.  The window will jump to that spot.
X		Move the mouse up or down while holding down the middle mouse
X		button to adject.  Release the mouse button when you are
X		happy with where you are in the file.
END_OF_FILE
if test 1270 -ne `wc -c <'help/scroll.help'`; then
    echo shar: \"'help/scroll.help'\" unpacked with wrong size!
fi
# end of 'help/scroll.help'
fi
if test -f 'lines.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'lines.c'\"
else
echo shar: Extracting \"'lines.c'\" \(3332 characters\)
sed "s/^X//" >'lines.c' <<'END_OF_FILE'
X/* $Header: /nfs/unmvax/faculty/crowley/x/pt/RCS/lines.c,v 1.1 1991/07/05 16:34:41 crowley Exp crowley $ */
X
X#include <ctype.h>
X#include "pt.h"
X
Offset
readLine( fid, cp, buffer, makeLowerCase )
X	int fid;
X	Offset cp;
X	char *buffer;
X	int makeLowerCase;
X{
X	extern int getSpanSize;
X
X	char *limit = buffer + MSGBUFFERSIZE - 1;
X	char ch;
X	unsigned char *firstByte = (unsigned char *)1;
X	unsigned char *lastByte = (unsigned char *)0;
X
X	while( buffer < limit ) {
X                if( firstByte > lastByte ) {
X                        if( getSpan( fid, cp, &firstByte, &lastByte, 0 ) )
X				break;
X                }
X		++cp;
X		ch = (char)(*firstByte++);
X++getSpanSize;
X		if( makeLowerCase && isupper(ch) )
X			ch = tolower(ch);
X		*buffer++ = ch;
X		if( ch == '\n' )
X			break;
X	}
X	*buffer = '\0';
X	return cp;
X}
X
Offset
nextLine( fid, cp, n)
X	int fid;
X	Offset cp;
X	int *n;
X{
X	extern int getSpanSize;
X
X	int nLines = 0;
X	unsigned char *firstByte = (unsigned char *)1;
X	unsigned char *lastByte = (unsigned char *)0;
X
X	while( nLines < *n ) {
X                if( firstByte > lastByte ) {
X                        if( getSpan( fid, cp, &firstByte, &lastByte, 0 ) )
X				break;
X                }
X		if( (char)(*firstByte++) == '\n' )
X			++nLines;
X++getSpanSize;
X		++cp;
X	}
X	*n = nLines;
X	return cp;
X}
X
X/*
X * prevLine backs up 'n' lines or partial lines.  That is, if it starts at the
X * beginning of a line it will not count that line but if it starts in the
X * middle of a line it will count that part of the line.
X *
X * A special case is when n == -1, then prevLine backs up to the beginning
X * of the current line.  If it is already at the beginning of the line it
X * does not change cp, else it moves cp to the first character of the line.
X */
Offset
prevLine( fid, cp, n )
X	int fid;
X	Offset cp;
X	int *n;
X{
X	int uch;
X	int nLines = 0;
X	unsigned char *firstByte = (unsigned char *)1;
X	unsigned char *lastByte = (unsigned char *)0;
X
X	/* are we already off one of the beginning? */
X	if( cp <= 0 ) {
X		*n = 0;
X		return (Offset)0;
X	}
X
X	/* read the characters before the one we are on */
X	uch = getFileByte( fid, --cp );
X
X	/* you can't move past the beginning of the text so just return */
X	if( uch == BLOCK_EOF ) {
X		*n = 0;
X		/* Move back to the first character of the file. */
X		return (Offset)0;
X	}
X
X	/* Now see if we are starting at the beginning of a line */
X	if( (char)uch == '\n' ) {
X		if( *n == -1 ) {
X			*n = 0;
X			return cp + 1;
X		}
X	}
X
X	/* since we handled the beginning of line case above.  The n==-1 */
X	/* special case reduces to the case of n==1 */
X	if( *n == -1 )
X		*n = 1;
X
X	/* Now loop through the lines */
X	while( nLines < *n ) {
X		--cp;
X                if( firstByte > lastByte ) {
X                        if( getSpan( fid, cp, &firstByte, &lastByte, 1 ) ) {
X                        	/* end of file, count as a line */
X				++nLines;
X				break;
X			}
X                }
X		if( ((char)(*lastByte--)) == '\n' )
X			++nLines;
X#ifdef XXXXXX
X                uch = getFileByte( fid, --cp );
X                if( uch == BLOCK_EOF ) {
X                        ++nLines;
X                        break;
X                }
X                if( ((char)uch) == '\n' )
X                        ++nLines;
X#endif
X	}
X	/* send back the number of lines we really did back up */
X	*n = nLines;
X
X	/* we moved one past the character we are looking for */
X	return cp + 1;
X}
END_OF_FILE
if test 3332 -ne `wc -c <'lines.c'`; then
    echo shar: \"'lines.c'\" unpacked with wrong size!
fi
# end of 'lines.c'
fi
if test -f 'patchlevel.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'patchlevel.h'\"
else
echo shar: Extracting \"'patchlevel.h'\" \(21 characters\)
sed "s/^X//" >'patchlevel.h' <<'END_OF_FILE'
X#define PATCHLEVEL 0
END_OF_FILE
if test 21 -ne `wc -c <'patchlevel.h'`; then
    echo shar: \"'patchlevel.h'\" unpacked with wrong size!
fi
# end of 'patchlevel.h'
fi
if test -f 'piece.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'piece.c'\"
else
echo shar: Extracting \"'piece.c'\" \(3377 characters\)
sed "s/^X//" >'piece.c' <<'END_OF_FILE'
X/* $Header: /nfs/unmvax/faculty/crowley/x/pt/RCS/piece.c,v 1.4 1992/03/04 17:07:18 crowley Exp crowley $ */
X
X#include "pt.h"
X
X/* piece table */
Piece freePList;
unsigned int bytesLeft;
unsigned int piecesLeft;
X
Piece 
dupPieces(pp)
X	Piece pp;
X{
X	Piece pp2;
X	Piece lastpp, retpp;
X
X	lastpp = retpp = NULL;
X	while( pp != NULL ) {
X		pp2 = getFreePiece();
X		/* link to the previous piece */
X		if( lastpp != NULL )
X			lastpp->nextPiece = pp2;
X		else	/* first time through, remember the first piece */
X			retpp = pp2;
X		pp2->prevPiece = lastpp;
X		/* copy the field values */
X		pp2->file = pp->file;
X		pp2->position = pp->position;
X		pp2->length = pp->length;
X		lastpp = pp2;
X		pp = pp->nextPiece;
X	}
X	/* pp2->nextPiece == NULL already since getFreePiece does that */
X	return retpp;
X}
X
Piece 
getFreePiece()
X{
X	extern char msgBuffer[];
X	extern Piece freePList;
X	extern unsigned int bytesLeft;
X	extern unsigned int piecesLeft;
X	extern int piecesRequested;
X	extern int piecesAllocated;
X	extern int debug;
X	
X	Piece pp;
X	
X++piecesRequested;
X	pp = freePList;
X	if( pp != NULL ) {
X		--piecesLeft;
X		freePList = freePList->nextPiece;
X	} else { /* we have to allocate a piece structure from the free space */
X++piecesAllocated;
X		pp = (Piece)PtMalloc(sizeof(struct piece), "piece" );
X	}
X	pp->nextPiece = pp->prevPiece = NULL;
X	pp->flags = 0;
X	pp->blockID = NullObject;
X	pp->nextClone = pp;
X	return pp;
X}
X
void
freePieces(pp)
X	Piece pp;
X{
X	extern Piece freePList;
X	extern unsigned int piecesLeft;
X	extern int piecesFreed;
X	
X	Piece pp2;
X	
X	if( pp == NULL )
X		return;
X++piecesFreed;
X	pp2 = pp;
X	while( pp2->nextPiece != NULL ) {
X		pp2 = pp2->nextPiece;
X		++piecesLeft;
X	}
X	pp2->nextPiece = freePList;
X	freePList = pp;
X	++piecesLeft;
X}
X
Piece 
findPiece(logPos, ff, beginLogPos)
X	Offset logPos, *beginLogPos;
X	struct openFile *ff;
X{
X	extern char msgBuffer[];
X	extern int piecesSearchedFor;
X	extern int piecesScanned;
X	extern int scanned0pieces;
X	extern int scanned1pieces;
X	extern int scanned2pieces;
X	extern int scanned3PlusPieces;
X
X	Piece pp;
X	Offset nn, n2;
X	int savePiecesScanned;
X
X++piecesSearchedFor;
savePiecesScanned = piecesScanned;
X	/* see if we already know what piece it is in */
X	pp = ff->logPiece;
X	nn = ff->loLogPiece;
X	if( ff->loLogPiece <= logPos && logPos <= ff->hiLogPiece )
X		/*EMPTY*/
X	{
X		/* now nn = first logical byte in this piece */
X	} else {	/* go through the piece table */
X		if( logPos < nn ) {	/* below this piece? */
X			if( logPos < 0 ) {  /* error checking to be safe */
X				msg("findPiece: byte number < 0", 1);
X				return pp;	/* what else? */
X			}
X			/* search down for the piece */
X			while( logPos < nn ) {
X				pp = pp->prevPiece;
X++piecesScanned;
X				nn -= pp->length;
X			}
X		} else {	/* must be at or above this piece */
X			if( logPos >= ff->fileSize ) {
X				/* return the last piece */
X				while( pp->nextPiece != NULL ) {
X					nn += pp->length;
X++piecesScanned;
X					pp = pp->nextPiece;
X				}
X			} else {
X				/* search up for the piece */
X				while( 1 ) {
X					n2 = nn + pp->length;
X					if( logPos < n2 )
X						break;
X					if( pp->nextPiece == NULL )
X						break;
X					nn = n2;
X++piecesScanned;
X					pp = pp->nextPiece;
X				}
X			}
X		}
X	}
X	*beginLogPos = nn;
switch( piecesScanned - savePiecesScanned ) {
case 0: ++scanned0pieces; break;
case 1: ++scanned1pieces; break;
case 2: ++scanned2pieces; break;
default: ++scanned3PlusPieces; break;
X}
X	return pp;
X}
END_OF_FILE
if test 3377 -ne `wc -c <'piece.c'`; then
    echo shar: \"'piece.c'\" unpacked with wrong size!
fi
# end of 'piece.c'
fi
if test -f 'tags.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tags.c'\"
else
echo shar: Extracting \"'tags.c'\" \(3563 characters\)
sed "s/^X//" >'tags.c' <<'END_OF_FILE'
X/* $Header: /nfs/unmvax/faculty/crowley/x/pt/RCS/tags.c,v 1.6 1992/03/04 17:07:18 crowley Exp crowley $ */
X
X#include <stdio.h>
X#include "pt.h"
X
void
findCTag( ctag )
X	char *ctag;
X{
X	extern struct window *selWindow;
X	extern Offset selBegin, selEnd;
X	extern int selMode;
X	extern int ignoreCase;
X	extern int linesOverFind;
X	extern char msgBuffer[];
X	extern struct openFile *files;
X	extern char * textGeometry;
X
X	int tags_file;
X	char *p, *p_limit, *file_name, *search_string;
X	int ctag_len, f_len, line_number;
X	int n, len, linesPassed;
X	Offset cp;
X	char ch;
X	int saveIgnoreCase;
X	struct window *w;
X
X	ctag_len = strlen( ctag );
X
X	/* open the tags file */
X	tags_file = getFileId( "tags" );
X	if( tags_file < 0 ) {
X		msg("Could not open 'tags' file\n", 1);
X		goto CleanUp1;
X	}
X
X	/* search for the selection in the tags file */
X	f_len = fileSize( tags_file );
X	line_number = 0;
X	saveIgnoreCase = ignoreCase;
X	ignoreCase = 0;
X	cp = -1;
X	while( 1 ) {
X		cp = searchSpans( tags_file, cp+1, f_len, ctag, ctag_len,
X							&line_number);
X		if( cp < 0 ) {
X			sprintf( msgBuffer, "%s not found in the tags file\n",
X									ctag);
X			msg( msgBuffer, 1);
X			goto CleanUp2;
X		}
X		/* make sure it is at the beginning of a line */
X		if( cp == 0 )
X			break;
X		ch = getFileByte( tags_file, cp-1 );
X		if( ch == '\n' )
X			break;
X	}
X
X	/* extract the file name and the search string for the tag */
X	file_name = (char *)PtMalloc( MSGBUFFERSIZE, "file name" );
X	search_string = (char *)PtMalloc( MSGBUFFERSIZE, "search string" );
X	/* scan to the first tab */
X	while( 1 ) {
X		ch = getFileByte( tags_file, cp++ );
X		if( (char)ch == '\t' )
X			break;
X	}
X	/* copy the file name */
X	p = file_name;
X	p_limit = p + MSGBUFFERSIZE;
X	while( p < p_limit ) {
X		ch = (char)getFileByte( tags_file, cp++ );
X		if( ch == '\t' )
X			break;
X		*p++ = ch;
X	}
X	*p = '\0';	/* terminate the string */
X	/* copy the search string */
X	cp += 2;	/* skip the '/^' */
X	p = search_string;
X	p_limit = p + MSGBUFFERSIZE;
X	while( p < p_limit ) {
X		ch = (char)getFileByte( tags_file, cp++ );
X		if( ch == '\n' )
X			break;
X		*p++ = ch;
X	}
X	p -= 2;		/* skip the '$/' */
X	*p = '\0';	/* terminate the string */
X
X	/* see if the file is already in a window */
X	p = makeFullPathname( file_name );
X	w = findFilenameWindow( p );
X	if( w != NULL )
X		topWindow( w );
X	else
X		w = createWindow( NULL, file_name, textGeometry );
X
X	/* make the string we found the selection */
X	/* first erase the old selection */
X	if( selWindow != w ) {
X		drawSelection( 1 );
X		selWindow = w;
X	}
X	/* then find the search string in the file */
X	len = strlen( search_string );
X	cp = searchSpans( w->fileId, 0, fileSize(w->fileId),
X		search_string, len, &linesPassed);
X	if( cp == -1 ) {
X		printf("listCB: ERROR: ctag %s not found in file %s\n",
X			search_string, files[w->fileId].origName);
X		goto CleanUp3;
X	}
X
X	/* make it the selection */
X	selBegin = cp;
X	selEnd = cp + len - 1;
X	selMode = SELCHAR;
X	AssertSelectionOwnership();
X
X	/* jump the window to show the string we found */
X	/* find the number of lines in the window */
X	n = selWindow->nRows;
X	if( linesOverFind > n )
X		/* if linesOverFind would place it outside the */
X		/* window then put it in the middle of the window */
X		n >>= 1;
X	else
X		/* otherwise put it linesOverFind lines down */
X		n = linesOverFind;
X	linesPassed -= n;
X	if( linesPassed < 0 )
X		linesPassed = 0;
X	doGoto( w, linesPassed, 0 );
X
X	/* close the tags file and free the strings */
CleanUp3:
X	PtFree( file_name );
X	PtFree( search_string );
CleanUp2:
X	ignoreCase = saveIgnoreCase;
X	closeFile( tags_file, 2 );
CleanUp1:
X	PtFree( ctag );
X}
END_OF_FILE
if test 3563 -ne `wc -c <'tags.c'`; then
    echo shar: \"'tags.c'\" unpacked with wrong size!
fi
# end of 'tags.c'
fi
if test -f 'tcl.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tcl.c'\"
else
echo shar: Extracting \"'tcl.c'\" \(1559 characters\)
sed "s/^X//" >'tcl.c' <<'END_OF_FILE'
X/* $Header: /nfs/unmvax/faculty/crowley/x/pt/RCS/tcl.c,v 1.1 1991/10/10 23:46:27 crowley Exp $ */
X
X#include <stdio.h>
X#include "pt.h"
X
Tcl_Interp * interp = NULL;
X
char *
XExecTclCommand( command )
X	char * command;
X{
X	extern Tcl_Interp * interp;
X
X	int result = Tcl_Eval( interp, command, 0, (char **)NULL );
X
X	if( *interp->result != 0 && result != TCL_OK )
X			printf("%s\n", interp->result);
X	return interp->result;
X}
X
X/*ARGSUSED*/
int
doPtCommand( clientData, interp, argc, argv )
X	ClientData clientData;
X	Tcl_Interp * interp;
X	int argc;
X	char *argv[];
X{
X	extern struct window *activeWindow;
X	extern int debug;
X	
X	int i;
X	char *args[6];
X
X	for( i = 1; i < argc; ++i )
X		args[i-1] = argv[i];
X	for( ; i <= 6; ++i )
X		args[i-1] = "";
X	(void)command( (int)clientData, args[0], args[1], args[2], args[3],
X							args[4], args[5] );
X	return TCL_OK;
X}
X
X/*ARGSUSED*/
void
ptTcl(w, event, args, nargs)
X	int w;
X	XButtonEvent *event;
X	String *args;
X	Cardinal *nargs;
X{
X	extern char msgBuffer[];
X	extern Tcl_Interp * interp;
X
X	int i;
X	char ch, *to, *from, *limit;
X
X	to = msgBuffer;
X	limit = msgBuffer + MSGBUFFERSIZE - 1;
X	*to = '\0';	/* make it empty to begin with */
X	for( i = 0; i < *nargs; ++i ) {
X		*to++ = ' ';
X		from = args[i];
X		while( 1 ) {
X			if( to >= limit ) {
X				sprintf( msgBuffer,
X				  "Tcl command over %d bytes was ignored.",
X				  MSGBUFFERSIZE );
X				msg( msgBuffer, 1 );
X				to = limit - 1;
X				break;
X			}
X			ch = *to++ = *from++;
X			if( ch == '\0' ) {
X				--to;	/* back up over '\0' */
X				break;
X			}
X		}
X	}
X	(void)ExecTclCommand( msgBuffer );
X}
X
END_OF_FILE
if test 1559 -ne `wc -c <'tcl.c'`; then
    echo shar: \"'tcl.c'\" unpacked with wrong size!
fi
# end of 'tcl.c'
fi
if test ! -d 'tclLib' ; then
    echo shar: Creating directory \"'tclLib'\"
    mkdir 'tclLib'
fi
if test -f 'tclLib/anaBoxes.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclLib/anaBoxes.tcl'\"
else
echo shar: Extracting \"'tclLib/anaBoxes.tcl'\" \(2380 characters\)
sed "s/^X//" >'tclLib/anaBoxes.tcl' <<'END_OF_FILE'
proc MakeMapBox {} {
X	global raised sunken
X	set name .MapBox
X
X	catch ".destroy $name"
X	toplevel $name
X	wm title $name "Create Map"
X	wm iconname $name "Create Map"
X	wm minsize $name 0 0
X	
X	set attrList ""
X
X	label $name.label1 -text "Create Map"
X
X	label $name.label2 -text "Name of map:"
X	entry $name.mapname -relief $sunken
X	bind.entry $name.mapname
X
X	frame $name.alist
X	scrollbar $name.alist.scrollbar -relief sunken \
X		-command "$name.alist.items view"
X	listbox $name.alist.items -scroll "$name.alist.scrollbar set"  \
X		-relief sunken
X	bind $name.alist.items <1> "
X		set index \[%W nearest %y\]
X		lappend \$attrList \$index
X		$name.label3 configure -text \$attrList
X	"
X	pack append $name.alist \
X		$name.alist.scrollbar {left fill} \
X		$name.alist.items {right fill expand}
X
X	label $name.label3 -text "Attributes Chosen"
X
X	frame $name.buttons
X	button $name.buttons.create -text "Create Attribute" -command "
X		Option set returnString \$attrList
X		destroy $name
X	"
X	button $name.buttons.cancel -text "Cancel" -command "
X		Option set returnString XXXcancelXXX
X		destroy $name
X	"
X	pack append $name.buttons \
X		$name.buttons.create {left fill} \
X		$name.buttons.cancel {right fill}
X
X	pack append $name \
X		$name.label1 {top fill} \
X		$name.label2 {top fill} \
X		$name.mapname {top fill} \
X		$name.alist {top fill} \
X		$name.label3 {top fill} \
X		$name.buttons {top fill}
X	return $name
X}
X
proc MakePickBox {label} {
X	global wcounter raised sunken
X
X	set wcounter [expr $wcounter+1]
X	set name [format ".pb%05d" $wcounter]
X
X	toplevel $name -relief $raised
X	wm title $name $label
X	wm iconname $name $label
X	wm minsize $name 0 0
X	label $name.label1 -text $label
X
X	entry $name.keyword -relief $sunken
X	bind.entry $name.keyword
X
X	frame $name.slist
X	scrollbar $name.slist.scrollbar -relief sunken \
X		-command "$name.slist.items view"
X	listbox $name.slist.items -scroll "$name.slist.scrollbar set"  \
X		-relief sunken
X	bind $name.slist.items <1> "
X		set index \[%W nearest %y\]
X		Option set returnString \$index
X		destroy $name
X	"
X	pack append $name.slist \
X		$name.slist.scrollbar {left fill} \
X		$name.slist.items {right fill expand}
X
X	button $name.close -text "Cancel" -command "
X		Option set returnString XXXcancelXXX
X		destroy $name
X	"
X
X	pack append $name \
X		$name.label1 {top fill} \
X		$name.keyword {top fill} \
X		$name.slist {top fill} \
X		$name.close {top fill}
X	return $name
X}
X
END_OF_FILE
if test 2380 -ne `wc -c <'tclLib/anaBoxes.tcl'`; then
    echo shar: \"'tclLib/anaBoxes.tcl'\" unpacked with wrong size!
fi
# end of 'tclLib/anaBoxes.tcl'
fi
if test -f 'tclLib/cmd.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclLib/cmd.tcl'\"
else
echo shar: Extracting \"'tclLib/cmd.tcl'\" \(620 characters\)
sed "s/^X//" >'tclLib/cmd.tcl' <<'END_OF_FILE'
proc CreateCmdInfo {{file ../doc/cmds.tex}} {
X	global CmdName CmdInfo
X	set CmdName ""
X	set CmdInfo ""
X	set fid [open $file r]
X	set gettingPara 0
X	while {![eof $fid]} {
X		set line [gets $fid]
X		if {[string index $line 0]=="\\" && $gettingPara} {
X			set gettingPara 0
X			lappend CmdInfo $para
X		}
X		if $gettingPara {
X			set para [format "%s %s" $para $line]
X		}
X		if [regexp "\\subsubsection{(.*)}" $line junk cmd] {
X			set gettingPara 1
X			lappend CmdName [lindex $cmd 0]
X			set para [format "%s\n" $cmd]
X		}
X	}
X	if $gettingPara {
X		lappend CmdInfo $para
X	}
X}
X#CreateCmdInfo
X#foreach x $CmdInfo {
X#	puts stdout "<$x>"
X#}
END_OF_FILE
if test 620 -ne `wc -c <'tclLib/cmd.tcl'`; then
    echo shar: \"'tclLib/cmd.tcl'\" unpacked with wrong size!
fi
# end of 'tclLib/cmd.tcl'
fi
if test -f 'tclLib/macros.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclLib/macros.tcl'\"
else
echo shar: Extracting \"'tclLib/macros.tcl'\" \(1221 characters\)
sed "s/^X//" >'tclLib/macros.tcl' <<'END_OF_FILE'
X#
X# Some macros to extend Point commands
X#
proc Filter {{cmd fmt}} {
X	set s [selection get]
X	set ret [catch {exec $cmd << $s} ns]
X	# if the command failed then do not delete the selection
X	if {$ret==0} DeleteToScrap
X	# insert the result or the error message
X	InsertString $ns
X}
X
proc IndentSelection {{outdent 0}} {
X	set sel [Sel get]
X	set here [lindex $sel 0]
X	set stop [lindex $sel 1]
X	for {} 1 {} {
X		MoveSel line left0
X		set here [lindex [Sel get] 0]
X		if {$here>$stop} \
X			break;
X		if $outdent {
X			DeleteToScrap
X		} else {
X			InsertString \t
X		}
X		set stop [expr $stop+1]
X		MoveSel char down
X	}
X}
X
proc DefineMacro {{id 0}} {
X	set name Macro$id
X	global $name
X	set $name [selection get]
X}
X
proc ExecMacro {{id 0}} {
X	set name Macro$id
X	global $name
X	eval [set $name]
X}
X
proc ExecSel {{id 0}} {
X	eval [selection get]
X}
X
proc MoveWindow {geometry} {
X	set aw [WindowName get active]
X	wm geometry $aw [FixGeometry $geometry]
X	RaiseWindow
X}
X
proc ExtendSelToLines {} {
X	set endSel [lindex [Sel get] 1]
X	MoveSel line left0 noupdate
X	set beginSel [lindex [Sel get] 0]
X	Sel set $endSel $endSel
X	MoveSel line right noupdate
X	set endSel [lindex [Sel get] 1]
X	Sel set $beginSel $endSel
X	set w [WindowName get sel]
X	Redraw
X}
X
X
END_OF_FILE
if test 1221 -ne `wc -c <'tclLib/macros.tcl'`; then
    echo shar: \"'tclLib/macros.tcl'\" unpacked with wrong size!
fi
# end of 'tclLib/macros.tcl'
fi
if test -f 'tclLib/makeMenus.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclLib/makeMenus.tcl'\"
else
echo shar: Extracting \"'tclLib/makeMenus.tcl'\" \(3504 characters\)
sed "s/^X//" >'tclLib/makeMenus.tcl' <<'END_OF_FILE'
X#
X#
X# Make the menus and menu bars
X#
X#
proc MakeMenubar {name menuString} {
X	global raised bd
X	frame $name -relief $raised -bd $bd
X	foreach item $menuString {
X		set kind [lindex $item 0]
X		set buttonName "[lindex $item 1]"
X		case $kind in \
X		"button"    {MakeButton $name.$buttonName \
X				"[lindex $item 2]" "[lindex $item 3]" } \
X		"menu"      {MakeMenu $name.$buttonName \
X				"[lindex $item 2]" "[lindex $item 3]" }
X		pack append $name $name.$buttonName {left fill}
X	}
X}
X
proc MakeButton {name text cmd} {
X	global raised bd
X	button $name -text "$text" -relief $raised -bd $bd
X	bind $name <Any-Enter> {global insideButton;set insideButton 1}
X	bind $name <Any-Leave> {global insideButton;set insideButton 0}
X	bind $name <Any-ButtonRelease-1> "+execButton $name \{[lindex $cmd 0]\}"
X	bind $name <Any-ButtonRelease-2> "execButton $name \{[lindex $cmd 1]\}"
X	bind $name <Any-ButtonRelease-3> "execButton $name \{[lindex $cmd 2]\}"
X}
X
proc MakeMenuItems {name menuString} {
X	set n 0
X	foreach item $menuString {
X		set kind [lindex $item 0]
X		case $kind in {
X		"cascade"   {
X			$name add cascade -label [lindex $item 1] \
X				-menu $name.$n
X			menu $name.$n 
X			bind.menu $name.$n
X			if {[llength [lindex $item 2]]==1} then {
X				set m [lindex $item 2]
X				global $m
X				MakeMenuItems $name.$n [set $m]
X			} else {
X				MakeMenuItems $name.$n [lindex $item 2]
X			}
X		}
X		"separator" { $name add separator }
X		"command"   {MakeCommand $name \
X			[lindex $item 1] [lindex $item 2] }
X		"check"     {MakeCheck $name $n \
X			[lindex $item 1]  [lindex $item 2] [lindex $item 3] }
X		"radio"     {MakeRadio $name $n \
X			[lindex $item 1]  [lindex $item 2] \
X			[lindex $item 3]  [lindex $item 4] }
X		}
X		if "[string compare $kind "separator"] != 0" \
X			{set n [expr $n+1]}
X	}
X}
X
proc MakeCommand {name text cmd} {
X	$name add command -label "$text" -command "$cmd"
X}
X
proc MakeCheck {name index text variable cmd} {
X	global $variable
X	$name add checkbutton -label "$text" -variable $variable \
X							-command "$cmd"
X	set xx [Option get $variable]
X	if {$xx!=[set $variable]} {catch {$name invoke $index}}
X}
X
proc MakeRadio {name index text variable value cmd} {
X	global $variable
X	$name add radio -label "$text" -variable $variable -value $value \
X		-command $cmd
X	if ![string compare "[Option get $variable]" "$value"] {
X		catch {$name invoke $index}
X	}
X}
X
proc MakeMenu {name text menuString} {
X	global raised bd
X	global menuBarButton
X	menubutton $name -text $text -relief $raised -bd $bd -menu $name.m
X	menu $name.m
X	bind $name <Any-Enter> "set postedMenu {};$name activate"
X	bind $name <Any-B1-Enter> "set menuBarButton 1;$name activate; $name post"
X	bind $name <Any-B3-Enter> "set menuBarButton 3;$name activate; $name post"
X	bind $name <Any-B1-Leave> "$name deactivate"
X	bind $name <Any-B3-Leave> "$name deactivate"
X	bind $name <Shift-B1-Leave> "$name deactivate"
X	bind $name <Shift-B3-Leave> "$name deactivate"
X	bind $name <Any-Leave> "$name deactivate"
X	bind $name <Any-1> "set menuBarButton 1;$name post"
X	bind $name <Any-3> "set menuBarButton 3;$name post"
X	bind $name <Shift-1> "set menuBarButton 1;$name.m post %X %Y"
X	bind $name <Shift-3> "set menuBarButton 3;$name.m post %X %Y"
X	bind $name <Any-ButtonRelease-1> "$name unpost"
X	bind $name <Any-ButtonRelease-3> "$name unpost"
X	bind $name <Shift-B1-Motion> "set menuBarButton 1;$name.m post %X %Y"
X	bind $name <Shift-B3-Motion> "set menuBarButton 1;$name.m post %X %Y"
X	global $menuString
X	MakeMenuItems $name.m [set $menuString]
X	bind.menu $name.m
X}
X
END_OF_FILE
if test 3504 -ne `wc -c <'tclLib/makeMenus.tcl'`; then
    echo shar: \"'tclLib/makeMenus.tcl'\" unpacked with wrong size!
fi
# end of 'tclLib/makeMenus.tcl'
fi
if test -f 'tclLib/ptsetup.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclLib/ptsetup.tcl'\"
else
echo shar: Extracting \"'tclLib/ptsetup.tcl'\" \(1119 characters\)
sed "s/^X//" >'tclLib/ptsetup.tcl' <<'END_OF_FILE'
X#
X# Setup some variables used in the tcl code
X#
X# CHANGE THIS:
set HelpDirectory help
X#
X# these work well for an 1152x900 screen
X#
set location1 "502x410+0+0"
set location2 "502x390-200+415"
set location3 "502x390-0+0"
set location4 "502x390+0+435"
set browserBig 490x465-0+0
set browser1 135x380+510+0
set browser2 135x380+651+0
set browser3 135x380+787+0
Option set textGeometry			$location1
Option set browserGeometry		$browserBig
Option set thinBrowserGeometry		$browser1
X#
X# Set Point options
X#
Option set wrapAroundSearches		True
X#
X# Setup some variables used in the tcl code
X#
set wcounter 0
X#
X# monochrome screen adjustments
X#
set raised "raised"
X#set raised "flat"
set sunken "sunken"
X#set sunken "flat"
set bd 1
X#set bd 2
X#
X# set up autoloading
X#
global PointTclLibrary
source $PointTclLibrary/init.tcl
set auto_path "$PointTclLibrary"
X#
X# define menus
X#
source $PointTclLibrary/browserMenu.tcl
source $PointTclLibrary/cmd.tcl
source $PointTclLibrary/macros.tcl
source $PointTclLibrary/makeBoxes.tcl
source $PointTclLibrary/makeMenus.tcl
source $PointTclLibrary/subs.tcl
source $PointTclLibrary/textMenu.tcl
X
END_OF_FILE
if test 1119 -ne `wc -c <'tclLib/ptsetup.tcl'`; then
    echo shar: \"'tclLib/ptsetup.tcl'\" unpacked with wrong size!
fi
# end of 'tclLib/ptsetup.tcl'
fi
if test -f 'tclLib/startup.tcl' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclLib/startup.tcl'\"
else
echo shar: Extracting \"'tclLib/startup.tcl'\" \(338 characters\)
sed "s/^X//" >'tclLib/startup.tcl' <<'END_OF_FILE'
if [file exists ~/.ptrc] then {
X	source ~/.ptrc
X} else {
X	if [file exists ./ptsetup.tcl] then {
X		source ./ptsetup.tcl
X	} else {
X		global PointTclLibrary
X		if [file exists $PointTclLibrary/ptsetup.tcl] {
X			source $PointTclLibrary/ptsetup.tcl
X		} else {
X			puts stderr \
X			    "CANNOT FIND A STARTUP FILE. POINT WILL NOT WORK."
X		}
X	}
X}
END_OF_FILE
if test 338 -ne `wc -c <'tclLib/startup.tcl'`; then
    echo shar: \"'tclLib/startup.tcl'\" unpacked with wrong size!
fi
# end of 'tclLib/startup.tcl'
fi
if test -f 'tclLib/tclIndex' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'tclLib/tclIndex'\"
else
echo shar: Extracting \"'tclLib/tclIndex'\" \(1713 characters\)
sed "s/^X//" >'tclLib/tclIndex' <<'END_OF_FILE'
X# Tcl autoload index file: each line identifies a Tcl
X# procedure and the file where that procedure is
X# defined.  Generated by the "auto_mkindex" command.
X
XFilter macros.tcl
IndentSelection macros.tcl
DefineMacro macros.tcl
XExecMacro macros.tcl
XExecSel macros.tcl
MoveWindow macros.tcl
XExtendSelToLines macros.tcl
BrowserMenuBindings browserMenu.tcl
TextMenuBindings textMenu.tcl
TextBindings textMenu.tcl
BrowserWindow windows.tcl
TextWindow windows.tcl
MakeMenubar makeMenus.tcl
MakeButton makeMenus.tcl
MakeMenuItems makeMenus.tcl
MakeCommand makeMenus.tcl
MakeCheck makeMenus.tcl
MakeRadio makeMenus.tcl
MakeMenu makeMenus.tcl
HelpWindow makeBoxes.tcl
GetSelectedKeyword makeBoxes.tcl
MakeSearchOptionsBox makeBoxes.tcl
MakeOtherOptionsBox makeBoxes.tcl
MakeVerifyBox makeBoxes.tcl
DoRegexReplace makeBoxes.tcl
DoReplace makeBoxes.tcl
MakeRegexReplaceBox makeBoxes.tcl
MakeReplaceBox makeBoxes.tcl
MakeModalEntry makeBoxes.tcl
MakeModalYesNo makeBoxes.tcl
MakeMsgBox makeBoxes.tcl
MakemmBox makeBoxes.tcl
MakeUndoBox makeBoxes.tcl
MakeColorBox makeBoxes.tcl
MakeCtagBox makeBoxes.tcl
XFillKeywordBox makeBoxes.tcl
MakeKeywordBox makeBoxes.tcl
MakeGotoBox makeBoxes.tcl
MakeDebugBox makeBoxes.tcl
MakeAsciiBox makeBoxes.tcl
MakeAboutBox makeBoxes.tcl
MakeQuitBox makeBoxes.tcl
MakeSearchBox makeBoxes.tcl
MakeRebindWindow makeBoxes.tcl
UpdateRebindHelp makeBoxes.tcl
InsertSelectedString subs.tcl
SearchForSel subs.tcl
XFixGeometry subs.tcl
execButton subs.tcl
pr subs.tcl
OpenFileOrCD subs.tcl
bind.entry subs.tcl
bind.menu subs.tcl
bs subs.tcl
tkerror subs.tcl
CreateCmdInfo cmd.tcl
MakeMapBox anaBoxes.tcl
MakePickBox anaBoxes.tcl
unknown init.tcl
auto_load init.tcl
auto_execok init.tcl
auto_reset init.tcl
END_OF_FILE
if test 1713 -ne `wc -c <'tclLib/tclIndex'`; then
    echo shar: \"'tclLib/tclIndex'\" unpacked with wrong size!
fi
# end of 'tclLib/tclIndex'
fi
if test -f 'version.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'version.c'\"
else
echo shar: Extracting \"'version.c'\" \(31 characters\)
sed "s/^X//" >'version.c' <<'END_OF_FILE'
char * version_string = "1.3";
END_OF_FILE
if test 31 -ne `wc -c <'version.c'`; then
    echo shar: \"'version.c'\" unpacked with wrong size!
fi
# end of 'version.c'
fi
echo shar: End of archive 1 \(of 15\).
cp /dev/null ark1isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 15 archives.
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
