Newsgroups: comp.sources.x
Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: rsmith@PIONEER.ARC.NASA.GOV (Roger Smith RCS)
Subject: v17i051: Xwindow based ethernet load monitor, Part01/01
Message-ID: <1992Apr1.150146.5949@msi.com>
Originator: dcmartin@snoopy
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Date: Wed, 1 Apr 1992 15:01:46 GMT
Approved: dcmartin@msi.com

Submitted-by: rsmith@PIONEER.ARC.NASA.GOV (Roger Smith RCS)
Posting-number: Volume 17, Issue 51
Archive-name: xnetload/part01

# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 04/01/1992 15:00 UTC by dcmartin@snoopy
# Source directory /home/fascet/csx/src/xnetloadRPC
#
# existing files will NOT be overwritten unless -c is specified
#
#                                                                          
#                                                                          
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#    313 -rw-r--r-- CHANGES
#    624 -rw-r--r-- Imakefile
#  10573 -rw-r--r-- Makefile
#    187 -rw-r--r-- XNetload.ad
#    386 -rw-r--r-- display.c
#   1777 -rw-r--r-- ether.h
#   2713 -rw-r--r-- ether_clnt.c
#   2061 -rw-r--r-- ether_xdr.c
#    625 -rw-r--r-- get_load.c
#    152 -rw-r--r-- misc.h
#   2316 -rw-r--r-- rpc_stuff.c
#    924 -rw-r--r-- xload.bit
#   5617 -rw-r--r-- xload.c
#   4086 -rw-r--r-- xnetload.man
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= CHANGES ==============
if test -f 'CHANGES' -a X"$1" != X"-c"; then
	echo 'x - skipping CHANGES (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting CHANGES (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'CHANGES' &&
The following changes have been made to this directory since R3:
X
X      o	Now use Athena StripChart widget.
X
X      o Understands WM_DELETE_WINDOW.
X
X      o 3-26-92 Modified from xload to xnetload by Roger Smith,
X  	Sterling Software at NASA-Ames Research Center,
X	Mountain View, Calif. rsmith@proteus.arc.nasa.gov
SHAR_EOF
chmod 0644 CHANGES ||
echo 'restore of CHANGES failed'
Wc_c="`wc -c < 'CHANGES'`"
test 313 -eq "$Wc_c" ||
	echo 'CHANGES: original size 313, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Imakefile ==============
if test -f 'Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Imakefile' &&
X        DEPLIBS = XawClientDepLibs
LOCAL_LIBRARIES = XawClientLibs
X           SRCS = xload.c get_load.c display.c rpc_stuff.c ether_clnt.c ether_xdr.c
X           OBJS = xload.o get_load.o display.o rpc_stuff.o ether_clnt.o ether_xdr.o
X
AllTarget(xnetload)
NormalProgramTarget(xnetload,$(OBJS),$(DEPLIBS),$(LOCAL_LIBRARIES), /**/)
InstallProgramWithFlags(xnetload, $(BINDIR), $(INSTKMEMFLAGS))
InstallManPage(xnetload,$(MANDIR))
X
InstallAppDefaults(XNetload)
X
DependTarget()
X
CCxnetload:   $(SRCS)
X	#load $(CFLAGS) $(SRCS) $(DEPLIBS) $(LDOPTIONS)  $(LOCAL_LIBRARIES) $(LDLIBS) $(LOCAL_X_LIBRARIES) $(EXTRA_LOAD_FLAGS)
X	#link
SHAR_EOF
chmod 0644 Imakefile ||
echo 'restore of Imakefile failed'
Wc_c="`wc -c < 'Imakefile'`"
test 624 -eq "$Wc_c" ||
	echo 'Imakefile: original size 624, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile ==============
if test -f 'Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
# Makefile generated by imake - do not edit!
# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
#
# The cpp used on this machine replaces all newlines and multiple tabs and
# spaces in a macro expansion with a single space.  Imake tries to compensate
# for this, but is not always successful.
#
X
# -------------------------------------------------------------------------
# Makefile generated from "Imake.tmpl" and <Imakefile>
# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
#
# Platform-specific parameters may be set in the appropriate <vendor>.cf
# configuration files.  Site-specific parameters should be set in the file
# site.def.  Full rebuilds are recommended if any parameters are changed.
#
# If your C preprocessor does not define any unique symbols, you will need
# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
# "make World" the first time).
#
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that need to come before
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
# -------------------------------------------------------------------------
# platform-specific configuration parameters - edit sun.cf to change
X
# platform:  $XConsortium: sun.cf,v 1.68 91/07/30 11:34:39 rws Exp $
X
# operating system:  SunOS 4.1.1
X
# $XConsortium: sunLib.rules,v 1.6 91/03/24 17:55:58 rws Exp $
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that go after
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X      PROJECTROOT = /usr/X11/R5
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
# -------------------------------------------------------------------------
# X Window System Build Parameters
# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
# -------------------------------------------------------------------------
# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/X11/R5/lib
X           BINDIR = /usr/X11/R5/bin
X          INCROOT = /usr/X11/R5/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/X11/R5/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
# $XConsortium: sunLib.tmpl,v 1.11 91/07/31 11:32:08 rws Exp $
X
SHLIBLDFLAGS = -assert pure-text
PICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
# -------------------------------------------------------------------------
# Imake rules for building libraries, programs, scripts, and data files
# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
# -------------------------------------------------------------------------
# start of Imakefile
X
X        DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
LOCAL_LIBRARIES = $(XAWLIB) $(XMULIB) $(XTOOLLIB) $(XLIB)
X           SRCS = xload.c get_load.c display.c rpc_stuff.c ether_clnt.c ether_xdr.c
X           OBJS = xload.o get_load.o display.o rpc_stuff.o ether_clnt.o ether_xdr.o
X
all:: xnetload
X
xnetload: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS)   $(EXTRA_LOAD_FLAGS)
X
clean::
X	$(RM) xnetload
X
install:: xnetload
X	@if [ -d $(DESTDIR) $(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR) $(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  $(INSTKMEMFLAGS) xnetload $(DESTDIR) $(BINDIR)
X
install.man:: xnetload.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) xnetload.man $(DESTDIR)$(MANDIR)/xnetload.$(MANSUFFIX)
X
install:: XNetload.ad
X	@if [ -d $(DESTDIR)$(XAPPLOADDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XAPPLOADDIR)); fi
X	$(INSTALL) -c $(INSTAPPFLAGS) XNetload.ad $(DESTDIR)$(XAPPLOADDIR)/XNetload
X
depend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
CCxnetload:   $(SRCS)
X	#load $(CFLAGS) $(SRCS) $(DEPLIBS) $(LDOPTIONS)  $(LOCAL_LIBRARIES) $(LDLIBS) $(LOCAL_X_LIBRARIES) $(EXTRA_LOAD_FLAGS)
X	#link
X
# -------------------------------------------------------------------------
# common rules for all Makefiles - do not edit
X
emptyrule::
X
clean::
X	$(RM_CMD) "#"*
X
Makefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
tags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
saber:
X	# load $(ALLDEFINES) $(SRCS)
X
osaber:
X	# load $(ALLDEFINES) $(OBJS)
X
# -------------------------------------------------------------------------
# empty rules for directories that do not have SUBDIRS - do not edit
X
install::
X	@echo "install in $(CURRENT_DIR) done"
X
install.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
Makefiles::
X
includes::
X
# -------------------------------------------------------------------------
# dependencies generated by makedepend
X
SHAR_EOF
chmod 0644 Makefile ||
echo 'restore of Makefile failed'
Wc_c="`wc -c < 'Makefile'`"
test 10573 -eq "$Wc_c" ||
	echo 'Makefile: original size 10573, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= XNetload.ad ==============
if test -f 'XNetload.ad' -a X"$1" != X"-c"; then
	echo 'x - skipping XNetload.ad (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting XNetload.ad (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'XNetload.ad' &&
XXNetload.input:				false
XXNetload*Label*Justify:			left
*label.label:				"Ethernet Load %"
*JumpScroll:				1
*minScale:				10
XXNetload*internalBorderWidth:		0
XXNetload*showGrip:			FALSE
X
SHAR_EOF
chmod 0644 XNetload.ad ||
echo 'restore of XNetload.ad failed'
Wc_c="`wc -c < 'XNetload.ad'`"
test 187 -eq "$Wc_c" ||
	echo 'XNetload.ad: original size 187, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= display.c ==============
if test -f 'display.c' -a X"$1" != X"-c"; then
	echo 'x - skipping display.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting display.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'display.c' &&
/*
X * display.c
X *
X *
X */
#include <stdio.h>
#include <signal.h>	
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include "misc.h"
X
#define STR_LEN (256)
X
static char HostName[STR_LEN];
static int IntervalVal = 0;
static int IntervalChanged = TRUE;
X
void SetHost( host )
char *host;
{
X	strncpy( HostName, host, STR_LEN );
}
X
void SetInterval( inter )
int inter;
{
X	IntervalVal = inter;
}
SHAR_EOF
chmod 0644 display.c ||
echo 'restore of display.c failed'
Wc_c="`wc -c < 'display.c'`"
test 386 -eq "$Wc_c" ||
	echo 'display.c: original size 386, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ether.h ==============
if test -f 'ether.h' -a X"$1" != X"-c"; then
	echo 'x - skipping ether.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ether.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ether.h' &&
/*
X * Please do not edit this file.
X * It was generated using rpcgen.
X */
X
#include <rpc/types.h>
X
#define NBUCKETS 16
#define NPROTOS 6
#define HASHSIZE 256
X
struct ethertimeval {
X	u_int tv_seconds;
X	u_int tv_useconds;
};
typedef struct ethertimeval ethertimeval;
bool_t xdr_ethertimeval();
X
struct etherstat {
X	ethertimeval e_time;
X	u_int e_bytes;
X	u_int e_packets;
X	u_int e_bcast;
X	u_int e_size[NBUCKETS];
X	u_int e_proto[NPROTOS];
};
typedef struct etherstat etherstat;
bool_t xdr_etherstat();
X
struct etherhmem_node {
X	int h_addr;
X	u_int h_cnt;
X	struct etherhmem_node *h_nxt;
};
typedef struct etherhmem_node etherhmem_node;
bool_t xdr_etherhmem_node();
X
typedef etherhmem_node *etherhmem;
bool_t xdr_etherhmem();
X
struct etheraddrs {
X	ethertimeval e_time;
X	u_int e_bytes;
X	u_int e_packets;
X	u_int e_bcast;
X	etherhmem e_addrs[HASHSIZE];
};
typedef struct etheraddrs etheraddrs;
bool_t xdr_etheraddrs();
X
struct addrmask {
X	int a_addr;
X	int a_mask;
};
typedef struct addrmask addrmask;
bool_t xdr_addrmask();
X
#define ETHERPROG ((u_long)100010)
#define ETHERVERS ((u_long)1)
#define ETHERPROC_GETDATA ((u_long)1)
extern etherstat *etherproc_getdata_1();
#define ETHERPROC_ON ((u_long)2)
extern void *etherproc_on_1();
#define ETHERPROC_OFF ((u_long)3)
extern void *etherproc_off_1();
#define ETHERPROC_GETSRCDATA ((u_long)4)
extern etheraddrs *etherproc_getsrcdata_1();
#define ETHERPROC_GETDSTDATA ((u_long)5)
extern etheraddrs *etherproc_getdstdata_1();
#define ETHERPROC_SELECTSRC ((u_long)6)
extern void *etherproc_selectsrc_1();
#define ETHERPROC_SELECTDST ((u_long)7)
extern void *etherproc_selectdst_1();
#define ETHERPROC_SELECTPROTO ((u_long)8)
extern void *etherproc_selectproto_1();
#define ETHERPROC_SELECTLNTH ((u_long)9)
extern void *etherproc_selectlnth_1();
SHAR_EOF
chmod 0644 ether.h ||
echo 'restore of ether.h failed'
Wc_c="`wc -c < 'ether.h'`"
test 1777 -eq "$Wc_c" ||
	echo 'ether.h: original size 1777, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ether_clnt.c ==============
if test -f 'ether_clnt.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ether_clnt.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ether_clnt.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ether_clnt.c' &&
/*
X * Please do not edit this file.
X * It was generated using rpcgen.
X */
X
#include <rpc/rpc.h>
#include "ether.h"
X
/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };
X
etherstat *
etherproc_getdata_1(argp, clnt)
X	void *argp;
X	CLIENT *clnt;
{
X	static etherstat res;
X
X	bzero((char *)&res, sizeof(res));
X	if (clnt_call(clnt, ETHERPROC_GETDATA, xdr_void, argp, xdr_etherstat, &res, TIMEOUT) != RPC_SUCCESS) {
X		return (NULL);
X	}
X	return (&res);
}
X
void *
etherproc_on_1(argp, clnt)
X	void *argp;
X	CLIENT *clnt;
{
X	static char res;
X
X	bzero((char *)&res, sizeof(res));
X	if (clnt_call(clnt, ETHERPROC_ON, xdr_void, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
X		return (NULL);
X	}
X	return ((void *)&res);
}
X
void *
etherproc_off_1(argp, clnt)
X	void *argp;
X	CLIENT *clnt;
{
X	static char res;
X
X	bzero((char *)&res, sizeof(res));
X	if (clnt_call(clnt, ETHERPROC_OFF, xdr_void, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
X		return (NULL);
X	}
X	return ((void *)&res);
}
X
etheraddrs *
etherproc_getsrcdata_1(argp, clnt)
X	void *argp;
X	CLIENT *clnt;
{
X	static etheraddrs res;
X
X	bzero((char *)&res, sizeof(res));
X	if (clnt_call(clnt, ETHERPROC_GETSRCDATA, xdr_void, argp, xdr_etheraddrs, &res, TIMEOUT) != RPC_SUCCESS) {
X		return (NULL);
X	}
X	return (&res);
}
X
etheraddrs *
etherproc_getdstdata_1(argp, clnt)
X	void *argp;
X	CLIENT *clnt;
{
X	static etheraddrs res;
X
X	bzero((char *)&res, sizeof(res));
X	if (clnt_call(clnt, ETHERPROC_GETDSTDATA, xdr_void, argp, xdr_etheraddrs, &res, TIMEOUT) != RPC_SUCCESS) {
X		return (NULL);
X	}
X	return (&res);
}
X
void *
etherproc_selectsrc_1(argp, clnt)
X	addrmask *argp;
X	CLIENT *clnt;
{
X	static char res;
X
X	bzero((char *)&res, sizeof(res));
X	if (clnt_call(clnt, ETHERPROC_SELECTSRC, xdr_addrmask, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
X		return (NULL);
X	}
X	return ((void *)&res);
}
X
void *
etherproc_selectdst_1(argp, clnt)
X	addrmask *argp;
X	CLIENT *clnt;
{
X	static char res;
X
X	bzero((char *)&res, sizeof(res));
X	if (clnt_call(clnt, ETHERPROC_SELECTDST, xdr_addrmask, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
X		return (NULL);
X	}
X	return ((void *)&res);
}
X
void *
etherproc_selectproto_1(argp, clnt)
X	addrmask *argp;
X	CLIENT *clnt;
{
X	static char res;
X
X	bzero((char *)&res, sizeof(res));
X	if (clnt_call(clnt, ETHERPROC_SELECTPROTO, xdr_addrmask, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
X		return (NULL);
X	}
X	return ((void *)&res);
}
X
void *
etherproc_selectlnth_1(argp, clnt)
X	addrmask *argp;
X	CLIENT *clnt;
{
X	static char res;
X
X	bzero((char *)&res, sizeof(res));
X	if (clnt_call(clnt, ETHERPROC_SELECTLNTH, xdr_addrmask, argp, xdr_void, &res, TIMEOUT) != RPC_SUCCESS) {
X		return (NULL);
X	}
X	return ((void *)&res);
}
SHAR_EOF
chmod 0644 ether_clnt.c ||
echo 'restore of ether_clnt.c failed'
Wc_c="`wc -c < 'ether_clnt.c'`"
test 2713 -eq "$Wc_c" ||
	echo 'ether_clnt.c: original size 2713, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ether_xdr.c ==============
if test -f 'ether_xdr.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ether_xdr.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ether_xdr.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ether_xdr.c' &&
/*
X * Please do not edit this file.
X * It was generated using rpcgen.
X */
X
#include <rpc/rpc.h>
#include "ether.h"
X
bool_t
xdr_ethertimeval(xdrs, objp)
X	XDR *xdrs;
X	ethertimeval *objp;
{
X	if (!xdr_u_int(xdrs, &objp->tv_seconds)) {
X		return (FALSE);
X	}
X	if (!xdr_u_int(xdrs, &objp->tv_useconds)) {
X		return (FALSE);
X	}
X	return (TRUE);
}
X
bool_t
xdr_etherstat(xdrs, objp)
X	XDR *xdrs;
X	etherstat *objp;
{
X	if (!xdr_ethertimeval(xdrs, &objp->e_time)) {
X		return (FALSE);
X	}
X	if (!xdr_u_int(xdrs, &objp->e_bytes)) {
X		return (FALSE);
X	}
X	if (!xdr_u_int(xdrs, &objp->e_packets)) {
X		return (FALSE);
X	}
X	if (!xdr_u_int(xdrs, &objp->e_bcast)) {
X		return (FALSE);
X	}
X	if (!xdr_vector(xdrs, (char *)objp->e_size, NBUCKETS, sizeof(u_int), xdr_u_int)) {
X		return (FALSE);
X	}
X	if (!xdr_vector(xdrs, (char *)objp->e_proto, NPROTOS, sizeof(u_int), xdr_u_int)) {
X		return (FALSE);
X	}
X	return (TRUE);
}
X
bool_t
xdr_etherhmem_node(xdrs, objp)
X	XDR *xdrs;
X	etherhmem_node *objp;
{
X	if (!xdr_int(xdrs, &objp->h_addr)) {
X		return (FALSE);
X	}
X	if (!xdr_u_int(xdrs, &objp->h_cnt)) {
X		return (FALSE);
X	}
X	if (!xdr_pointer(xdrs, (char **)&objp->h_nxt, sizeof(etherhmem_node), xdr_etherhmem_node)) {
X		return (FALSE);
X	}
X	return (TRUE);
}
X
bool_t
xdr_etherhmem(xdrs, objp)
X	XDR *xdrs;
X	etherhmem *objp;
{
X	if (!xdr_pointer(xdrs, (char **)objp, sizeof(etherhmem_node), xdr_etherhmem_node)) {
X		return (FALSE);
X	}
X	return (TRUE);
}
X
bool_t
xdr_etheraddrs(xdrs, objp)
X	XDR *xdrs;
X	etheraddrs *objp;
{
X	if (!xdr_ethertimeval(xdrs, &objp->e_time)) {
X		return (FALSE);
X	}
X	if (!xdr_u_int(xdrs, &objp->e_bytes)) {
X		return (FALSE);
X	}
X	if (!xdr_u_int(xdrs, &objp->e_packets)) {
X		return (FALSE);
X	}
X	if (!xdr_u_int(xdrs, &objp->e_bcast)) {
X		return (FALSE);
X	}
X	if (!xdr_vector(xdrs, (char *)objp->e_addrs, HASHSIZE, sizeof(etherhmem), xdr_etherhmem)) {
X		return (FALSE);
X	}
X	return (TRUE);
}
X
bool_t
xdr_addrmask(xdrs, objp)
X	XDR *xdrs;
X	addrmask *objp;
{
X	if (!xdr_int(xdrs, &objp->a_addr)) {
X		return (FALSE);
X	}
X	if (!xdr_int(xdrs, &objp->a_mask)) {
X		return (FALSE);
X	}
X	return (TRUE);
}
SHAR_EOF
chmod 0644 ether_xdr.c ||
echo 'restore of ether_xdr.c failed'
Wc_c="`wc -c < 'ether_xdr.c'`"
test 2061 -eq "$Wc_c" ||
	echo 'ether_xdr.c: original size 2061, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= get_load.c ==============
if test -f 'get_load.c' -a X"$1" != X"-c"; then
	echo 'x - skipping get_load.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting get_load.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'get_load.c' &&
#include <stdio.h>
#include <X11/Xos.h>
#include <X11/Intrinsic.h>
X
extern float GetNetLoad();
extern int   GetStatData();
/* ARGSUSED */
void 
GetLoadPoint( w, closure, call_data )
Widget	w;		/* unused */
XXtPointer closure;	/* unused */
XXtPointer call_data;	/* pointer to (double) return value */
{
X    double *loadavg = (double *)call_data;
X    long	temp;
X    float load;
X    int i;
X
X    i = GetStatData();
X    if ( i == 0 ) return;
X    load = (float)GetNetLoad();
X    *loadavg = (double)load;
}
X
static xload_error(str1, str2)
char *str1, *str2;
{
X    (void) fprintf(stderr,"xload: %s %s\n", str1, str2);
X    exit(-1);
}
X
SHAR_EOF
chmod 0644 get_load.c ||
echo 'restore of get_load.c failed'
Wc_c="`wc -c < 'get_load.c'`"
test 625 -eq "$Wc_c" ||
	echo 'get_load.c: original size 625, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= misc.h ==============
if test -f 'misc.h' -a X"$1" != X"-c"; then
	echo 'x - skipping misc.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting misc.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'misc.h' &&
#ifndef _MISC_H
#define _MISC_H
/*
X * misc.h
X *
X */
X
#define TRUE		(1)
#define FALSE		(0)
X
#define MWIN_W		(400)
#define MWIN_H		(50)
X
X
#endif _MISC_H
X
SHAR_EOF
chmod 0644 misc.h ||
echo 'restore of misc.h failed'
Wc_c="`wc -c < 'misc.h'`"
test 152 -eq "$Wc_c" ||
	echo 'misc.h: original size 152, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= rpc_stuff.c ==============
if test -f 'rpc_stuff.c' -a X"$1" != X"-c"; then
	echo 'x - skipping rpc_stuff.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting rpc_stuff.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'rpc_stuff.c' &&
/*
X *
X *
X *
X *
X */
#include <stdio.h>
#include <rpc/rpc.h>
#include "ether.h"
X
#define NDPROTO 0
#define ICMPPROTO 1
#define UDPPROTO 2
#define TCPPROTO 3
#define ARPPROTO 4
#define OTHERPROTO 5
X
X
static CLIENT *Client;
static etherstat PrevStatData = { { 0, 0 }, 0, 0, 0,
X				  { 0, 0, 0, 0, 0, 0, 0, 0, 
X				    0, 0, 0, 0, 0, 0, 0, 0 },
X				  { 0, 0, 0, 0, 0, 0 } };
static etherstat *StatData = NULL;
static double TimeDelta = 1.0;
X
void InitRPC( host )
char *host;
{
X
X	Client = clnt_create( host, ETHERPROG, ETHERVERS, "udp" );
X
X	if( Client == NULL ) {
X		fprintf( stderr, "xtr: Could not create connection to " );
X		fprintf( stderr, "'%s'\n", host );
X		exit( 1 );
X	}
}
X
void TurnOnEther()
{
X	int dummy;
X
X	etherproc_on_1( &dummy, Client );
}
X
void TurnOffEther()
{
X	int dummy;
X
X	etherproc_off_1( &dummy, Client );
}
int GetStatData()
{
X        int dummy;
X	double start_secs, stop_secs;
X
X        if( StatData != NULL ) {
X                PrevStatData = *StatData;
X        }
X
X        if ((StatData = etherproc_getdata_1( &dummy, Client )) == 0) return ( 0 );
X	gettimeofday(&StatData->e_time, (struct timezone *) 0);
X	start_secs = (double)PrevStatData.e_time.tv_seconds + 
X	             (double)PrevStatData.e_time.tv_useconds/1000000.0;
X	stop_secs = (double)StatData->e_time.tv_seconds + 
X	            (double)StatData->e_time.tv_useconds/1000000.0;
X        TimeDelta = stop_secs - start_secs;
X
X        if( TimeDelta <= 0 ) {
X                TimeDelta = 1.0;
X        }
X	return ( 1 );
}
X
float GetNetLoad()
{
X	long bits;
X	int delta;
X	float nload;
X	static short firstTime=1;
X
X	if (firstTime){
X	    PrevStatData = *StatData;
X	    firstTime=0;
X	}
X	bits = (StatData->e_bytes - PrevStatData.e_bytes) * 8;
/*	delta = (StatData->e_time.tv_seconds - PrevStatData.e_time.tv_seconds);*/
X	if ( TimeDelta )
X	    nload = (float)((( (double)bits / TimeDelta ) / 
X			    ((double)(10 * 1024 * 1024))) * 100.0);
X	else
X	    nload = 0;
X	nload /= 10.0;
X
/* occasionally a glitch comes through and we go way over 100%. the following
X   limits the output to 100%. */
X
X	if ( nload > 10.0 ) nload = 10.0;
#ifdef DEBUG
X	printf ("newbytes=%d, oldbytes=%d, deltabytes=%d, deltatime=%lf, load=%f\n", 
X		StatData->e_bytes,
X		PrevStatData.e_bytes,
X		StatData->e_bytes - PrevStatData.e_bytes,
X		TimeDelta,
X		nload);  
#endif
X	return( nload );
X
}
SHAR_EOF
chmod 0644 rpc_stuff.c ||
echo 'restore of rpc_stuff.c failed'
Wc_c="`wc -c < 'rpc_stuff.c'`"
test 2316 -eq "$Wc_c" ||
	echo 'rpc_stuff.c: original size 2316, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xload.bit ==============
if test -f 'xload.bit' -a X"$1" != X"-c"; then
	echo 'x - skipping xload.bit (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xload.bit (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xload.bit' &&
#define xload_width 32
#define xload_height 32
#define xload_x_hot 15
#define xload_y_hot 16
static char xload_bits[] = {
X   0x00, 0x00, 0xc0, 0x03, 0x1e, 0x00, 0xf0, 0x03, 0x00, 0x00, 0xf8, 0x03,
X   0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xfc, 0x03, 0x00, 0x00, 0xfe, 0x03,
X   0xff, 0xff, 0xff, 0xff, 0x00, 0x80, 0xff, 0x03, 0x00, 0xc0, 0xff, 0x03,
X   0xff, 0xff, 0xff, 0xff, 0x00, 0xe0, 0xff, 0x03, 0x00, 0xf0, 0xff, 0x03,
X   0xff, 0xff, 0xff, 0xff, 0x00, 0xf8, 0xff, 0x03, 0x00, 0xf8, 0xff, 0x03,
X   0xff, 0xff, 0xff, 0xff, 0x00, 0xfc, 0xff, 0x03, 0x00, 0xfc, 0xff, 0x03,
X   0xff, 0xff, 0xff, 0xff, 0x00, 0xfe, 0xff, 0x03, 0x00, 0xfe, 0xff, 0x03,
X   0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x03, 0x00, 0xff, 0xff, 0x03,
X   0xff, 0xff, 0xff, 0xff, 0x80, 0xff, 0xff, 0x03, 0xc0, 0xff, 0xff, 0x03,
X   0xff, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 0x03, 0xff, 0xff, 0xff, 0x03,
X   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03};
SHAR_EOF
chmod 0644 xload.bit ||
echo 'restore of xload.bit failed'
Wc_c="`wc -c < 'xload.bit'`"
test 924 -eq "$Wc_c" ||
	echo 'xload.bit: original size 924, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xload.c ==============
if test -f 'xload.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xload.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xload.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xload.c' &&
#ifndef lint
static char rcsid[] = "$XConsortium: xload.c,v 1.26 89/12/11 15:53:27 kit Exp $";
#endif /* lint */
X
#include <stdio.h> 
#include <X11/Intrinsic.h>
#include <X11/Xatom.h>
#include <X11/StringDefs.h>
#include <X11/Shell.h>
X
#include <X11/Xaw/Cardinals.h>
#include <X11/Xaw/Label.h>
#include <X11/Xaw/Paned.h>
#include <X11/Xaw/StripChart.h>
#include <X11/Xmu/SysUtil.h>
X
#include "xload.bit"
X
char *ProgramName;
X
extern void exit(), GetLoadPoint();
extern void SetHost(), SetInterval();
static void quit();
X
/*
X * Definition of the Application resources structure.
X */
X
typedef struct _XNetloadResources {
X  Boolean show_label;
} XNetloadResources;
X
/*
X * Command line options table.  Only resources are entered here...there is a
X * pass over the remaining options after XtParseCommand is let loose. 
X */
X
static XrmOptionDescRec options[] = {
{"-scale",	"*load.minScale",	XrmoptionSepArg,	   NULL},
{"-update",	"*load.update",		XrmoptionSepArg,	   "1"},
{"-hl",		"*load.highlight",	XrmoptionSepArg,	   NULL},
{"-highlight",	"*load.highlight",	XrmoptionSepArg,	   NULL},
{"-label",	"*label.label",		XrmoptionSepArg, "EtherNet Load %"},
{"-nolabel",	"*showLabel",	        XrmoptionNoArg,          "False"},
{"-jumpscroll",	"*load.jumpScroll",	XrmoptionSepArg,	   NULL},
};
X
/*
X * The structure containing the resource information for the
X * Xload application resources.
X */
X
#define Offset(field) (XtOffset(XNetloadResources *, field))
X
static XtResource my_resources[] = {
X  {"showLabel", XtCBoolean, XtRBoolean, sizeof(Boolean),
X     Offset(show_label), XtRImmediate, (caddr_t) TRUE},
};
X
#undef Offset
X
static XtActionsRec xload_actions[] = {
X    { "quit",	quit },
};
static Atom wm_delete_window;
X
X
/*
X * Exit with message describing command line format.
X */
X
void usage()
{
X    fprintf (stderr, "usage:  %s [-options ...]\n\n", ProgramName);
X    fprintf (stderr, "where options include:\n");
X    fprintf (stderr,
X      "    -display dpy            X server on which to display\n");
X    fprintf (stderr,
X      "    -geometry geom          size and location of window\n");
X    fprintf (stderr, 
X      "    -fn font                font to use in label\n");
X    fprintf (stderr, 
X      "    -scale number           minimum number of scale lines\n");
X    fprintf (stderr, 
X      "    -update seconds         interval between updates\n");
X    fprintf (stderr,
X      "    -label string           annotation text\n");
X    fprintf (stderr, 
X      "    -bg color               background color\n");
X    fprintf (stderr, 
X      "    -fg color               graph color\n");
X    fprintf (stderr, 
X      "    -hl color               scale and text color\n");
X    fprintf (stderr, 
X      "    -nolabel                removes the label from above the chart.\n");
X    fprintf (stderr, 
X      "    -jumpscroll value       number of pixels to scroll on overflow\n");
X    fprintf (stderr, "\n");
X    exit(1);
}
X
void main(argc, argv)
X    int argc;
X    char **argv;
{
X    char host[256], * label;
X    Widget toplevel, load, pane, label_wid, load_parent;
X    Arg args[1];
X    Pixmap icon_pixmap = None;
X    XNetloadResources resources;
X    char *targetHost = "localhost";
X    ProgramName = argv[0];
X    toplevel = XtInitialize(NULL, "XNetload", 
X			    options, XtNumber(options), &argc, argv);
X      
X    XtGetApplicationResources( toplevel, (caddr_t) &resources, 
X			      my_resources, XtNumber(my_resources),
X			      NULL, (Cardinal) 0);
X    if (argc > 2) usage();
X    
X    /*
X     * This is a hack so that f.delete will do something useful in this
X     * single-window application.
X     */
X    XtAppAddActions (XtWidgetToApplicationContext(toplevel),
X		     xload_actions, XtNumber(xload_actions));
X    XtOverrideTranslations(toplevel,
X		    XtParseTranslationTable ("<Message>WM_PROTOCOLS: quit()"));
X
X    XtSetArg (args[0], XtNiconPixmap, &icon_pixmap);
X    XtGetValues(toplevel, args, ONE);
X    if (icon_pixmap == None) {
X	XtSetArg(args[0], XtNiconPixmap, 
X		 XCreateBitmapFromData(XtDisplay(toplevel),
X				       XtScreen(toplevel)->root,
X				       xload_bits, xload_width, xload_height));
X	XtSetValues (toplevel, args, ONE);
X    }
X
X    if (resources.show_label) {
X      pane = XtCreateManagedWidget ("paned", panedWidgetClass,
X				    toplevel, NULL, ZERO);
X
X      label_wid = XtCreateManagedWidget ("label", labelWidgetClass,
X					 pane, NULL, ZERO);
X      
X      XtSetArg (args[0], XtNlabel, &label);
X      XtGetValues(label_wid, args, ONE);
X      
X      if ( strcmp("label", label) == 0 ) {
X	(void) XmuGetHostname (host, 255);
X	XtSetArg (args[0], XtNlabel, host);
X	XtSetValues (label_wid, args, ONE);
X      }
X
X      load_parent = pane;
X    }
X    else
X      load_parent = toplevel;
X
X    load = XtCreateManagedWidget ("load", stripChartWidgetClass,
X				  load_parent, NULL, ZERO);    
X    if ( argc == 2 )
X	targetHost = argv[1];
X
X    InitRPC( targetHost );
X    SetHost( targetHost );
X    SetInterval( 1 );
X    TurnOnEther();
X    XtAddCallback(load, XtNgetValue, GetLoadPoint, NULL);
X
X    XtRealizeWidget (toplevel);
X    wm_delete_window = XInternAtom (XtDisplay(toplevel), "WM_DELETE_WINDOW",
X                                    False);
X    (void) XSetWMProtocols (XtDisplay(toplevel), XtWindow(toplevel),
X                            &wm_delete_window, 1);
X    XtMainLoop();
}
X
X
static void quit (w, event, params, num_params)
X    Widget w;
X    XEvent *event;
X    String *params;
X    Cardinal *num_params;
{
X    if (event->type == ClientMessage &&
X        event->xclient.data.l[0] != wm_delete_window) {
X        XBell (XtDisplay(w), 0);
X        return;
X    }
X    XCloseDisplay (XtDisplay(w));
X    exit (0);
}
SHAR_EOF
chmod 0644 xload.c ||
echo 'restore of xload.c failed'
Wc_c="`wc -c < 'xload.c'`"
test 5617 -eq "$Wc_c" ||
	echo 'xload.c: original size 5617, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xnetload.man ==============
if test -f 'xnetload.man' -a X"$1" != X"-c"; then
	echo 'x - skipping xnetload.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xnetload.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xnetload.man' &&
.TH XNETLOAD 1 "Release 1" "X Version 11"
.SH NAME
xnetload - ethernet load average display for X
.SH SYNOPSIS
.ta 6n
\fBxnetload\fP	[-\fItoolkitoption\fP ...] [-scale \fIinteger\fP] 
.br
X	[-update \fIseconds\fP] [-hl \fIcolor\fP] [-highlight \fIcolor\fP] 
.br
X	[-jumpscroll \fIpixels\fP] [-label \fIstring\fP] [-nolabel] \fIhost\fP
.SH DESCRIPTION
The 
.I xnetload 
program displays a periodically updating histogram of the ethernet load average for
the specified \fIhost\fP. The resulting graph is scaled as 0% to 100%.
NOTE: \fIThe specified host must be running rpc.etherd.
.SH OPTIONS
.PP
.I Xnetload
accepts all of the standard X Toolkit command line options (see \fIX(1)\fP).
The order of the options is unimportant.  \fIxnetload\fP also accepts the
following additional options:
.PP
.TP 8
.B \-hl \fIcolor\fP or \-highlight \fIcolor\fP
This option specifies the color of the scale lines.  
.TP 8
.B \-jumpscroll \FPnumber of pixels\fP
The number of pixels to shift the graph to the left when the graph
reaches the right edge of the window.  The default value is 1/2 the width
of the current window.  Smooth scrolling can be achieved by setting it to 1.
.TP 8
.B \-label \fIstring\fP
The string to put into the label above the load average.
.TP 8
.B \-nolabel
If this command line option is specified then no label will be
displayed above the load graph.
.TP 8
.B \-scale \fIinteger\fP
This option specifies the minimum number of tick marks in the histogram,
where one division represents one load average point.  If the load goes
above this number, \fIxnetload\fP will create more divisions, but it will never
use fewer than this number.  The default is 10 (as set by the resource file).
.PP
.TP 8
.B \-update \fIseconds\fP
This option specifies the frequency in seconds at which \fIxnetload\fP
updates its display.  The minimum amount of time allowed between updates
is 1 second. For ethernet load monitoring this should be set to 1.
.TP 8
.B  \fIhost\fP
The \fIhost\fP specification is required. It is the name of any host, reachable
from the initiating CPU, that is running rpc.etherd
.SH RESOURCES
In addition to the resources available to each of the widgets used by 
\fIxnetload\fP there is one resource defined by the application itself.
.TP 8
.B showLabel (\fPclass\fB Boolean)
If False then no label will be displayed.
.SH WIDGETS
In order to specify resources, it is useful to know the hierarchy of
the widgets which compose \fIxnetload\fR.  In the notation below,
indentation indicates hierarchical structure.  The widget class name
is given first, followed by the widget instance name.
.sp
.nf
.ta .5i 1.0i 1.5i 2.0i
XXnetload  xnetload
X	Paned  paned
X		Label  label
X		StripChart  load
.fi
.sp
.SH ENVIRONMENT
.PP
.TP 8
.B DISPLAY
to get the default host and display number.
.TP 8
.B XENVIRONMENT
to get the name of a resource file that overrides the global resources
stored in the RESOURCE_MANAGER property.
.SH FILES
/usr/lib/X11/app-defaults/XNetload - specifies required resources
.SH SEE ALSO
XX(1), xrdb(1), mem(4), Athena StripChart Widget.
.SH BUGS
This program requires the ability to talk to the rpd.etherd daemon, and to
set the ethernet interface into promiscuous mode. Therefore, the Makefile
installs the program in /usr/bin/X11/ with root as the owner and with the
setuid bit set. This may not be necessary on some (most) systems, depending 
on the ownership of rpc.etherd.
.PP
.SH COPYRIGHT
Taken from the original xload sources distributed with X11R4.
Original copyright is preserved below:
.PP
Copyright 1988, Massachusetts Institute of Technology.
.br
See \fIX(1)\fP for a full statement of rights and permissions.
.SH AUTHORS
Original xload authors: K. Shane Hartman (MIT-LCS) and Stuart A. Malone (MIT-LCS);
.br
with features added by Jim Gettys (MIT-Athena), Bob Scheifler (MIT-LCS),
Tony Della Fera (MIT-Athena), and Chris Peterson (MIT-LCS).
.PP
Modified to the current xnetload form by:
.br
Roger Smith, Sterling Software at
.br
NASA-Ames Research Center, Mountain View, Ca.
.PP
For questions or reporting bugs:
.br
rsmith@proteus.arc.nasa.gov
SHAR_EOF
chmod 0644 xnetload.man ||
echo 'restore of xnetload.man failed'
Wc_c="`wc -c < 'xnetload.man'`"
test 4086 -eq "$Wc_c" ||
	echo 'xnetload.man: original size 4086, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
