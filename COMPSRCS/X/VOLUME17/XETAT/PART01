Newsgroups: comp.sources.x
Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: pierre%system@uunet.UU.NET (Pierre Ficheux)
Subject: v17i019: xetat : graphical system activity reporter, Part01/02
Message-ID: <csx-17i019-xetat@uunet.UU.NET>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Date: Wed, 18 Mar 1992 21:36:24 GMT
Approved: dcmartin@msi.com

Submitted-by: pierre%system@uunet.UU.NET (Pierre Ficheux)
Posting-number: Volume 17, Issue 19
Archive-name: xetat/part01

[ I could not compile this program since it needs SYSVR3.2 - dcm ]

#!/bin/sh
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 03/10/1992 15:58 UTC by pficheux@lectra.gna.org
# Source directory /X11/Divers/contrib/lectra/xetat/distrib
#
# existing files will NOT be overwritten unless -c is specified
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   1090 -rw-r--r-- README.en
#   1070 -rw-r--r-- README.fr
#    303 -rw-r--r-- Imakefile
#   1775 -rw-r--r-- activite.bit
#   1778 -rw-r--r-- processus.bit
#   1766 -rw-r--r-- xetat.bit
#   9502 -r--r--r-- activite.c
#     21 -rw-r--r-- patchlevel.h
#  19144 -r--r--r-- processus.c
#  12724 -r--r--r-- xetat.c
#   1279 -rw-r--r-- xetat.man.en
#   1640 -rw-r--r-- xetat.man.fr
#   5546 -rw-r--r-- XEtat.ad.en
#   5539 -rw-r--r-- XEtat.ad.fr
#
# ============= README.en ==============
if test -f 'README.en' -a X"$1" != X"-c"; then
	echo 'x - skipping README.en (File already exists)'
else
echo 'x - extracting README.en (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README.en' &&
X
X		  	  XETAT	1.x
X
X		graphical system activity reporter		
X
X    		     Pierre Ficheux 12/91
X
X
1-Introduction
--------------
X
XXETAT must be used with UNIX SVR3.2 and displays graphical informations about your 
system (such informations can also be collected by "sar"). 
X
2-Generation
------------
X
First, you must copy the english (if you read this, i assume you speak english!) 
version of the resource file and man pages to the generic files :
X
X		"cp XEtat.ad.en	XEtat.ad" 
X		"cp xetat.man.en xetat.man"
X
Then, you just have to follow the standard X11R4 client generation procedure :
X
X	1- generate the Makefile using "imake" 
X
X		imake -DUseInstalled -I/usr/lib/X11/config -DTOPDIR=/usr/lib/X11
X
X	2- create the dependencies with "make depend"
X
X	3- create the program with "make all"
X
X	4- install it with "make install"
X
X	5- install the man pages with "make install.man"
X
X
Have fun !
X
X
X	Pierre FICHEUX		Lectra-Systemes Service R & D 
X                                ZI Marticot
X                                33610 Cestas	FRANCE         
X				E-mail : pficheux@lectra.gna.org
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
SHAR_EOF
chmod 0644 README.en ||
echo 'restore of README.en failed'
Wc_c="`wc -c < 'README.en'`"
test 1090 -eq "$Wc_c" ||
	echo 'README.en: original size 1090, current size' "$Wc_c"
fi
# ============= README.fr ==============
if test -f 'README.fr' -a X"$1" != X"-c"; then
	echo 'x - skipping README.fr (File already exists)'
else
echo 'x - extracting README.fr (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README.fr' &&
X		  	  XETAT	1.x
X
X		graphical system activity reporter		
X
X    		     Pierre Ficheux 12/91
X
X
X
X
1-Introduction
--------------
X
XXETAT est destine a System V 3.2 et permet de visualiser graphiquement des 
informations collectees habituellement par "sar". 
X
2-Generation
------------
X
Si vous desirez le programme en francais, vous devez copier la version francaise du
fichier de resource et du man sur les fichiers generiques
X
X	"cp XEtat.ad.fr XEtat.ad"
X	"cp xetat.man.fr xetat.man"
X
Ensuite, il vous suffit de suivre la methode standard de generation d'un client X11 :
X
X	1- generation du Makfile par "imake" 
X
X		imake -DUseInstalled -I/usr/lib/X11/config -DTOPDIR=/usr/lib/X11
X
X	2- creation des dependance par "make depend"
X
X	3- creation du programme par "make all"
X
X	4- installation par "make install"
X
X	5- installation du man par "make install.man"
X
Bon courage !
X
X	Pierre FICHEUX		Lectra-Systemes Service R & D 
X                                ZI Marticot
X                                33610 Cestas	FRANCE         
X				E-mail : pficheux@lectra.gna.org
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
SHAR_EOF
chmod 0644 README.fr ||
echo 'restore of README.fr failed'
Wc_c="`wc -c < 'README.fr'`"
test 1070 -eq "$Wc_c" ||
	echo 'README.fr: original size 1070, current size' "$Wc_c"
fi
# ============= Imakefile ==============
if test -f 'Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Imakefile (File already exists)'
else
echo 'x - extracting Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Imakefile' &&
#
# Imakefile pour XETAT
#
X         INSTALL = bsdinst	
X            SRCS = xetat.c activite.c processus.c
X            OBJS = xetat.o activite.o processus.o
X          LDLIBS = -lXaw -lXmu -lXext -lXt -lX11 $(EXTRA_LIBRARIES)
X        PROGRAMS = xetat
X
ComplexProgramTarget(xetat)
InstallAppDefaults(XEtat)
SHAR_EOF
chmod 0644 Imakefile ||
echo 'restore of Imakefile failed'
Wc_c="`wc -c < 'Imakefile'`"
test 303 -eq "$Wc_c" ||
	echo 'Imakefile: original size 303, current size' "$Wc_c"
fi
# ============= activite.bit ==============
if test -f 'activite.bit' -a X"$1" != X"-c"; then
	echo 'x - skipping activite.bit (File already exists)'
else
echo 'x - extracting activite.bit (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'activite.bit' &&
#define activite_width 45
#define activite_height 45
static char activite_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0x07,
X   0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x40, 0x40, 0x40, 0x00, 0x04,
X   0x04, 0x60, 0x40, 0xc0, 0x00, 0x04, 0x04, 0xc0, 0x40, 0x60, 0x00, 0x04,
X   0x84, 0x80, 0x41, 0x20, 0x60, 0x04, 0x84, 0x01, 0x43, 0x30, 0x30, 0x04,
X   0x04, 0x03, 0x41, 0x10, 0x98, 0x04, 0x04, 0x06, 0x00, 0x00, 0x4c, 0x04,
X   0x04, 0x0c, 0x00, 0x00, 0x20, 0x04, 0x04, 0x80, 0x08, 0x11, 0x18, 0x04,
X   0x04, 0x80, 0x08, 0x11, 0x04, 0x04, 0x34, 0x80, 0x08, 0x11, 0x82, 0x05,
X   0xe4, 0x80, 0x08, 0x91, 0xe1, 0x04, 0x84, 0x03, 0x07, 0x51, 0x70, 0x04,
X   0x04, 0x01, 0x02, 0x2e, 0x00, 0x04, 0x04, 0x00, 0xf0, 0x11, 0x00, 0x04,
X   0x04, 0x00, 0xf8, 0x0f, 0x00, 0x04, 0x04, 0x00, 0xfc, 0x07, 0x00, 0x04,
X   0x04, 0x00, 0xfc, 0x07, 0x00, 0x04, 0xfc, 0xff, 0xff, 0xff, 0xff, 0x07,
X   0xac, 0xaa, 0xaa, 0xaa, 0xaa, 0x06, 0x54, 0x55, 0x55, 0x55, 0x55, 0x05,
X   0xac, 0xaa, 0xaa, 0xaa, 0xaa, 0x06, 0x54, 0x55, 0x55, 0x55, 0x55, 0x05,
X   0xac, 0xaa, 0xaa, 0xaa, 0xaa, 0x06, 0x54, 0x55, 0x55, 0x55, 0x55, 0x05,
X   0xac, 0xaa, 0xaa, 0xaa, 0xaa, 0x06, 0x54, 0x55, 0x55, 0x55, 0x55, 0x05,
X   0xfc, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 activite.bit ||
echo 'restore of activite.bit failed'
Wc_c="`wc -c < 'activite.bit'`"
test 1775 -eq "$Wc_c" ||
	echo 'activite.bit: original size 1775, current size' "$Wc_c"
fi
# ============= processus.bit ==============
if test -f 'processus.bit' -a X"$1" != X"-c"; then
	echo 'x - skipping processus.bit (File already exists)'
else
echo 'x - extracting processus.bit (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'processus.bit' &&
#define processus_width 45
#define processus_height 45
static char processus_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x01, 0x00, 0x00,
X   0x00, 0x00, 0xf0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00,
X   0x00, 0x00, 0xfc, 0x07, 0x00, 0x00, 0x00, 0x80, 0xff, 0x3f, 0x00, 0x00,
X   0x00, 0xe0, 0xff, 0xff, 0x00, 0x00, 0x00, 0xf0, 0x1f, 0xff, 0x01, 0x00,
X   0x00, 0xfc, 0x41, 0xf0, 0x07, 0x00, 0x00, 0x7e, 0x40, 0xc0, 0x0f, 0x00,
X   0x00, 0x1f, 0x40, 0x00, 0x1f, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x1e, 0x00,
X   0x80, 0x07, 0x00, 0x00, 0x3c, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x78, 0x00,
X   0xc0, 0x03, 0x00, 0x0c, 0x78, 0x00, 0xe0, 0x01, 0x00, 0x0e, 0xf0, 0x00,
X   0xe0, 0x01, 0x00, 0x07, 0xf0, 0x00, 0xe0, 0x00, 0x00, 0x07, 0xe0, 0x00,
X   0xf0, 0x00, 0x80, 0x03, 0xe0, 0x01, 0xf0, 0x00, 0x80, 0x03, 0xe0, 0x01,
X   0xf0, 0x00, 0xc0, 0x01, 0xe0, 0x01, 0x70, 0x00, 0xc0, 0x00, 0xc0, 0x01,
X   0x70, 0x07, 0xe0, 0x00, 0xdc, 0x01, 0x70, 0x00, 0x60, 0x00, 0xc0, 0x01,
X   0xf0, 0x00, 0xe0, 0x01, 0xe0, 0x01, 0xf0, 0x00, 0xc0, 0x03, 0xe0, 0x01,
X   0xf0, 0x00, 0x80, 0x07, 0xe0, 0x01, 0xe0, 0x00, 0x00, 0x0f, 0xe0, 0x00,
X   0xe0, 0x01, 0x00, 0x1e, 0xf0, 0x00, 0xe0, 0x01, 0x00, 0x3c, 0xf0, 0x00,
X   0xc0, 0x03, 0x00, 0x78, 0x78, 0x00, 0xc0, 0x03, 0x00, 0x70, 0x78, 0x00,
X   0x80, 0x07, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x1e, 0x00,
X   0x00, 0x1f, 0x40, 0x00, 0x1f, 0x00, 0x00, 0x7e, 0x40, 0xc0, 0x0f, 0x00,
X   0x00, 0xfc, 0x41, 0xf0, 0x07, 0x00, 0x00, 0xf0, 0x1f, 0xff, 0x01, 0x00,
X   0x00, 0xe0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x80, 0xff, 0x3f, 0x00, 0x00,
X   0x00, 0x00, 0xfc, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 processus.bit ||
echo 'restore of processus.bit failed'
Wc_c="`wc -c < 'processus.bit'`"
test 1778 -eq "$Wc_c" ||
	echo 'processus.bit: original size 1778, current size' "$Wc_c"
fi
# ============= xetat.bit ==============
if test -f 'xetat.bit' -a X"$1" != X"-c"; then
	echo 'x - skipping xetat.bit (File already exists)'
else
echo 'x - extracting xetat.bit (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xetat.bit' &&
#define xetat_width 45
#define xetat_height 45
static char xetat_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
X   0x80, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x00, 0x00, 0x00, 0x00,
X   0x40, 0x10, 0x00, 0x00, 0x00, 0x00, 0x40, 0x17, 0x00, 0x00, 0x00, 0x00,
X   0x40, 0x15, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xf5, 0xff, 0xff, 0xff, 0x03,
X   0x44, 0x15, 0x00, 0x00, 0x00, 0x02, 0x44, 0x15, 0x00, 0x00, 0x00, 0x02,
X   0x44, 0x15, 0x00, 0x00, 0x00, 0x02, 0x44, 0x15, 0x04, 0x00, 0x00, 0x02,
X   0x44, 0x15, 0x04, 0x00, 0x00, 0x02, 0x44, 0x15, 0x06, 0x00, 0x00, 0x02,
X   0x44, 0x15, 0x0a, 0x00, 0x00, 0x02, 0x7c, 0xf5, 0xff, 0xff, 0xff, 0x03,
X   0x44, 0x15, 0x09, 0x00, 0x00, 0x02, 0x44, 0x17, 0x09, 0x00, 0x00, 0x02,
X   0x44, 0x17, 0x09, 0x00, 0x00, 0x02, 0x44, 0x97, 0x08, 0x00, 0x00, 0x02,
X   0x44, 0x97, 0x10, 0x00, 0x00, 0x02, 0x44, 0x57, 0x10, 0x00, 0x40, 0x02,
X   0x44, 0x57, 0x10, 0x00, 0xc0, 0x02, 0x44, 0x57, 0x10, 0x00, 0xa0, 0x02,
X   0x7c, 0xf7, 0xff, 0xff, 0xff, 0x03, 0x44, 0x37, 0x10, 0x08, 0x10, 0x03,
X   0x44, 0x17, 0x20, 0x16, 0x10, 0x02, 0x44, 0x17, 0xa0, 0x21, 0x08, 0x02,
X   0x44, 0x17, 0x60, 0x40, 0x08, 0x02, 0x44, 0x17, 0x00, 0x80, 0x04, 0x02,
X   0x44, 0x17, 0x00, 0x00, 0x05, 0x02, 0x44, 0x17, 0x00, 0x00, 0x02, 0x02,
X   0x7c, 0xf7, 0xff, 0xff, 0xff, 0x03, 0x64, 0x17, 0x00, 0x00, 0x00, 0x02,
X   0x54, 0x17, 0x00, 0x00, 0x00, 0x02, 0x54, 0x17, 0x00, 0x00, 0x00, 0x02,
X   0x4c, 0x10, 0x00, 0x00, 0x00, 0x02, 0x84, 0x0f, 0x00, 0x00, 0x00, 0x02,
X   0x04, 0x07, 0x00, 0x00, 0x00, 0x02, 0x04, 0x07, 0x00, 0x00, 0x00, 0x02,
X   0xfc, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 xetat.bit ||
echo 'restore of xetat.bit failed'
Wc_c="`wc -c < 'xetat.bit'`"
test 1766 -eq "$Wc_c" ||
	echo 'xetat.bit: original size 1766, current size' "$Wc_c"
fi
# ============= activite.c ==============
if test -f 'activite.c' -a X"$1" != X"-c"; then
	echo 'x - skipping activite.c (File already exists)'
else
echo 'x - extracting activite.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'activite.c' &&
/*
X * xetat - graphical system activity reporter
X *
X * Copyright 1991 Lectra Systemes
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of Lectra Systemes not be used in advertising or
X * publicity pertaining to distribution of the software without specific,
X * written prior permission.  Lectra Systemes makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X *
X * Auteur : Pierre FICHEUX 	Lectra Systemes R & D
X *
X */
static char sccsid[] = "@(#)activite.c	1.1 3/10/92";
X
/*
X * Visualisation de l'activite
X */
X
/* 
X * Fichiers standards du toolkit Xt
X */
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/XawMisc.h>
#include <X11/Form.h>
#include <X11/Label.h>
#include <X11/Shell.h>
#include <X11/Xaw/StripChart.h>
/*
X * Public include files for widgets used in this file.
X */
#ifdef X11R3
#include <X11/Command.h>
#include <X11/Box.h>
#else /* R4 or later */
#include <X11/Xaw/Command.h>
#include <X11/Xaw/Box.h>
#endif /* X11R3 */
X
#include <sys/types.h>
#include <sys/sysinfo.h>
#include <nlist.h>
X
#define U		0
#define V		1
#define PROC		2
#define FREEMEM 	3
#define SYSINFO		4
#define AVAILRMEM 	5
X
#define VALEUR_FREEMEM		5
X
struct nlist namelist[] =
{
X    { "u", },
X    { "v", },
X    { "proc", },
X    { "freemem", },
X    { "sysinfo", },
X    { "availrmem", },
X    { 0, },
};
X
long availrmem;
extern int kmem;
struct sysinfo old, new;
static char buf[80];
Dimension largeur_boite, hauteur_boite, distance_horizontale, distance_verticale, largeur_bord;
X
extern Widget forme_activite, topLevel, shell_activite;
extern Widget titre_idle, titre_user, titre_kernel, titre_wait, titre_sxbrk, titre_freemem;
extern Widget boite_idle, boite_user, boite_kernel, boite_wait, boite_sxbrk, boite_freemem;
extern Widget indicateur_idle, indicateur_user, indicateur_kernel, indicateur_wait, indicateur_sxbrk, indicateur_freemem;
extern Widget afficheur_idle, afficheur_user, afficheur_kernel, afficheur_wait, afficheur_sxbrk, afficheur_freemem;
Dimension largeur_idle=1, largeur_user=1, largeur_kernel=1, largeur_wait=1, largeur_sxbrk=1, largeur_freemem=1;
X
double charge_courante_systeme[6];
extern void init_charge ();
static char flag_popup_actif = FALSE;
X
/*
X * Lecture de la charge initiale du systeme
X */
X
void init_charge ()
{
X    register int i;
X
X    if (nlist("/unix", namelist) != 0) {
X	perror ("init_charge-nlist");
X	exit(1);
X    }
X
X    /* lecture de l'etat du systeme */
X    if (lseek (kmem, namelist[SYSINFO].n_value, 0) < 0) {
X	perror ("init_charge-lseek");
X	exit (1);
X    }
X    
X    if (read (kmem, (char *)&old, sizeof(old)) != sizeof (old)) {
X	perror ("init_charge-read");
X	exit (1);
X    }
X
X    /* mesure de availrmem */
X    if (lseek(kmem, (long) namelist[AVAILRMEM].n_value, 0) < 0) {
X	perror ("mesure_charge_courante_systeme-lseek");
X	exit (1);
X    }
X
X    if (read(kmem, &availrmem, sizeof(availrmem)) != sizeof (availrmem)) {
X	perror ("mesure_charge_courante_systeme-read");
X	exit (1);
X    }
X
X
#ifdef DEBUG
X    for (i = 0 ; i != 5 ; i++)
X	printf ("old.cpu[%d] = %ld\n", i, old.cpu[i]);
#endif
}
X
/*
X * Lecture de la charge courante du systeme
X */
X
void mesure_charge_courante_systeme ()
{
X    extern double charge_courante_systeme[];
X    register double tdiff, valeur;
X    register int i;
X    long freemem;
X
X    /* mesure de availrmem */
X    if (lseek(kmem, (long) namelist[AVAILRMEM].n_value, 0) < 0) {
X	perror ("mesure_charge_courante_systeme-lseek");
X	exit (1);
X    }
X
X    if (read(kmem, &availrmem, sizeof(availrmem)) != sizeof (availrmem)) {
X	perror ("mesure_charge_courante_systeme-read");
X	exit (1);
X    }
X
X    /* mesure de freemem */
X    if (lseek(kmem, (long) namelist[FREEMEM].n_value, 0) < 0) {
X	perror ("mesure_charge_courante_systeme-lseek");
X	exit (1);
X    }
X
X    if (read(kmem, &freemem, sizeof(freemem)) != sizeof (freemem)) {
X	perror ("mesure_charge_courante_systeme-read");
X	exit (1);
X    }
X
X    /* lecture de l'etat du systeme */
X    if (lseek (kmem, namelist[SYSINFO].n_value, 0) < 0) {
X	perror ("mesure_charge_courante_systeme-lseek");
X	exit (1);
X    }
X    
X    if (read (kmem, (char *)&new, sizeof(new)) != sizeof (new)) {
X	perror ("mesure_charge_courante_systeme-read");
X	exit (1);
X    }
X
#ifdef DEBUG
X    printf ("mesure_charge : apres lecture...\n");
X    for (i = 0 ; i != 5 ; i++)
X	printf ("new.cpu[%d] = %ld\n", i, new.cpu[i]);
#endif
X
X    /* Somme des differences de temps */
X    tdiff = (double)(new.cpu[0]-old.cpu[0]) + (double)(new.cpu[1]-old.cpu[1]) + (double)(new.cpu[2]-old.cpu[2]) + (double)(new.cpu[3]-old.cpu[3]) + (double)(new.cpu[4]-old.cpu[4]);
X
X    /* calcul des charges */
X    for (i = 0 ; i != 5 ; i++) {
X	charge_courante_systeme[i] = (double)(new.cpu[i]-old.cpu[i]) / tdiff;
X
#ifdef DEBUG
X	printf ("mesure_charge : tdiff = %g  c[%d] = %g\n", tdiff, i, charge_courante_systeme[i]);
#endif
X    }
#ifdef DEBUG
X    printf ("freemem %ld availrmem = %ld\n*****************************\n", freemem, availrmem);
#endif
X    charge_courante_systeme[5] = (double)freemem;
X
X    /* New devient Old */
X    for (i = 0 ; i != 5 ; i++)
X	old.cpu[i] = new.cpu[i];
X
X    /* Initialise le comptage */
X    XtAddTimeOut ((unsigned long)4000, mesure_charge_courante_systeme, (caddr_t)NULL);
}
X
X
X
/*
X * Fonction periodique de mise a jour des graphes
X */
X
/* Mise a jour de la valeur affichee */
X
void mise_a_jour_mesure(widget_afficheur, format, valeur_mesure)
Widget widget_afficheur;
char *format;
long valeur_mesure;
{
X    Arg args[10];
X    register int n;
X
X    /* Formatage de la mesure */
X    sprintf (buf, format, valeur_mesure);
X
X    n = 0;
X    XtSetArg (args[n], XtNlabel, buf); n++;
X    XtSetValues (widget_afficheur, args, n);
}
X
/*
X * Callbacks utilises par les stripCharts (Idle, User, ...)
X */
X
void Mise_a_jour_idle(w, closure, call_data)
X     Widget	w;		/* unused */
X     caddr_t	closure;	/* unused */
X     caddr_t	call_data;	/* pointer to (double) return value */
{
X    double *valeur = (double *)call_data;
X
X    mise_a_jour_mesure (afficheur_idle, "%3d %%", (int) ((double)100. * charge_courante_systeme[CPU_IDLE]));
X
#ifdef DEBUG
X    printf ("Mise a jour idle %g\n", charge_courante_systeme[CPU_IDLE]);
#endif
X    *valeur = charge_courante_systeme[CPU_IDLE];
}
X
void Mise_a_jour_user(w, closure, call_data)
X     Widget	w;		/* unused */
X     caddr_t	closure;	/* unused */
X     caddr_t	call_data;	/* pointer to (double) return value */
{
X    double *valeur = (double *)call_data;
X
X    mise_a_jour_mesure (afficheur_user, "%3d %%", (int)((double)100. * charge_courante_systeme[CPU_USER]));
X
#ifdef DEBUG
X    printf ("Mise a jour user %g\n", charge_courante_systeme[CPU_USER]);
#endif
X    *valeur = charge_courante_systeme[CPU_USER];
}
X
void Mise_a_jour_kernel(w, closure, call_data)
X     Widget	w;		/* unused */
X     caddr_t	closure;	/* unused */
X     caddr_t	call_data;	/* pointer to (double) return value */
{
X    double *valeur = (double *)call_data;
X
X    mise_a_jour_mesure (afficheur_kernel, "%3d %%", (int)((double)100. * charge_courante_systeme[CPU_KERNEL]));
X
#ifdef DEBUG
X    printf ("Mise a jour kernel %g\n", charge_courante_systeme[CPU_KERNEL]);
#endif
X    *valeur = charge_courante_systeme[CPU_KERNEL];
}
X
void Mise_a_jour_wait(w, closure, call_data)
X     Widget	w;		/* unused */
X     caddr_t	closure;	/* unused */
X     caddr_t	call_data;	/* pointer to (double) return value */
{
X    double *valeur = (double *)call_data;
X
X    mise_a_jour_mesure (afficheur_wait, "%3d %%", (int)((double)100. * charge_courante_systeme[CPU_WAIT]));
X
#ifdef DEBUG
X    printf ("Mise a jour wait %g\n", charge_courante_systeme[CPU_WAIT]);
#endif
X    *valeur = charge_courante_systeme[CPU_WAIT];
}
X
void Mise_a_jour_sxbrk(w, closure, call_data)
X     Widget	w;		/* unused */
X     caddr_t	closure;	/* unused */
X     caddr_t	call_data;	/* pointer to (double) return value */
{
X    double *valeur = (double *)call_data;
X
X    mise_a_jour_mesure (afficheur_sxbrk, "%3d %%", (int)((double)100. * charge_courante_systeme[CPU_SXBRK]));
X
#ifdef DEBUG
X    printf ("Mise a jour sxbrk %g\n", charge_courante_systeme[CPU_SXBRK]);
#endif
X    *valeur = charge_courante_systeme[CPU_SXBRK];
}
X
void Mise_a_jour_freemem(w, closure, call_data)
X     Widget	w;		/* unused */
X     caddr_t	closure;	/* unused */
X     caddr_t	call_data;	/* pointer to (double) return value */
{
X    double *valeur = (double *)call_data;
X
X    mise_a_jour_mesure (afficheur_freemem, "%3d", (int)charge_courante_systeme[VALEUR_FREEMEM]);
X
#ifdef DEBUG
X    printf ("Mise a jour freemem %g\n", charge_courante_systeme[VALEUR_FREEMEM] / (double)availrmem);
#endif
X    *valeur = charge_courante_systeme[VALEUR_FREEMEM] / (double)availrmem;
}
X
/* 
X * Fonction d'initialisation de l'affichage de l'activite 
X */
X
void Activite (w, client_data, call_data)
Widget w;
caddr_t client_data, call_data;
{
#ifdef DEBUG
X    printf (stderr, "Activite...\n");
#endif
X    
X    if (flag_popup_actif == FALSE) {
X
X	/* affiche la fenetre */
X	XtPopup (shell_activite, XtGrabNone);
X
X	flag_popup_actif = TRUE;
X    }
}
X
/*
X * Callback du bouton Quitte du shell d'activite
X */
X
void Quit_activite (w, client_data, call_data)
Widget w;
caddr_t client_data, call_data;
{
X    flag_popup_actif = FALSE;
X    XtPopdown (shell_activite);
}
X
X
X
X
X
X
X
SHAR_EOF
chmod 0444 activite.c ||
echo 'restore of activite.c failed'
Wc_c="`wc -c < 'activite.c'`"
test 9502 -eq "$Wc_c" ||
	echo 'activite.c: original size 9502, current size' "$Wc_c"
fi
# ============= patchlevel.h ==============
if test -f 'patchlevel.h' -a X"$1" != X"-c"; then
	echo 'x - skipping patchlevel.h (File already exists)'
else
echo 'x - extracting patchlevel.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'patchlevel.h' &&
#define PATCHLEVEL	0
SHAR_EOF
chmod 0644 patchlevel.h ||
echo 'restore of patchlevel.h failed'
Wc_c="`wc -c < 'patchlevel.h'`"
test 21 -eq "$Wc_c" ||
	echo 'patchlevel.h: original size 21, current size' "$Wc_c"
fi
# ============= processus.c ==============
if test -f 'processus.c' -a X"$1" != X"-c"; then
	echo 'x - skipping processus.c (File already exists)'
else
echo 'x - extracting processus.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'processus.c' &&
/*
X * xetat - graphical system activity reporter
X *
X * Copyright 1991 Lectra Systemes
X *
X * Permission to use, copy, modify, and distribute this software and its
X * documentation for any purpose and without fee is hereby granted, provided
X * that the above copyright notice appear in all copies and that both that
X * copyright notice and this permission notice appear in supporting
X * documentation, and that the name of Lectra Systemes not be used in advertising or
X * publicity pertaining to distribution of the software without specific,
X * written prior permission.  Lectra Systemes makes no representations about the
X * suitability of this software for any purpose.  It is provided "as is"
X * without express or implied warranty.
X *
X * Auteur : Pierre FICHEUX 	Lectra Systemes R & D
X *
X */
static char sccsid[] = "@(#)processus.c	1.1 3/10/92";
X
/*
X * Fonctions de visualisation des processus		
X */
X
#include <stdio.h>
#include <string.h>
#include <time.h>
X
/*
X * Fichiers d'inclusion X11
X */
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/XawMisc.h>
#include <X11/Form.h>
#include <X11/Label.h>
#include <X11/Shell.h>
#include <X11/List.h>
#include <X11/Paned.h>
#include <X11/Viewport.h>
#include <X11/Xaw/StripChart.h>
X
#ifdef X11R3
#include <X11/Command.h>
#include <X11/Box.h>
#else /* R4 or later */
#include <X11/Xaw/Command.h>
#include <X11/Xaw/Box.h>
#endif /* X11R3 */
X
#include <sys/types.h>
#include <sys/param.h>
#include <sys/immu.h>
#include <sys/signal.h>
#include <sys/region.h>
#include <sys/var.h>
#include <sys/proc.h>
#include <sys/dir.h>
#include <sys/user.h>
#include <sys/syslocal.h>
#include <nlist.h>
#include <fcntl.h>
X
X
/* Structure de definition d'un shell processus */
X
struct definition_processus {
X    char flag_shell_actif;	/* TRUE si un popup shell existe */
X    Widget popup_shell;		/* widget popup shell */
X    Widget forme;		/* widget form contenant les infos */
X    Widget paned;		/* Paned utilise pour l'affichage de p_size */
X    Widget afficheur;		/* widget d'affichage de la taille du processus */
X    Widget indicateur;		/* widget indicateur de la taille */
X    Widget label_titre;		/* widget titre */
X    Widget label_car;		/* widget informations */
X    Widget quit;		/* widget de sortie */
X    pid_t p_pid, p_ppid;	/* Informations sur le processus ... */
X    uid_t p_uid;
X    uint p_size;
X    long p_stime;
X    long p_utime;
};
X
/* Maxi 400 processus */
X
#define MAXPROC	400
X
/* Indice des elements de namelist[] */
X
#define U		0
#define V		1
#define PROC		2
#define FREEMEM 	3
#define SYSINFO		4
#define AVAILRMEM 	5
X
extern Pixmap pixmap_processus;
extern Widget prototype_bouton_quit, prototype_label_titre, prototype_indicateur, prototype_afficheur, prototype_paned;
extern Widget shell_processus, liste_processus;
extern int kmem;			/* descripteur memoire noyau */
static int nb_processus;		/* nombre courant de processus */
String table_processus[MAXPROC];	/* liste des noms des rpocessus */
struct proc proctab;			/* structure de definition d'un processus */
struct user usertab;			/* suite de la definition ... */
struct var  vartab;			/* pointe de la zone v */
static char buf[100], buf1[100],buf2[100];	
static long valeur_freemem;		/* valeur courante freemem */
char flag_mise_a_jour_autorisee;	/* TRUE si la mise a jour est autorisee */
X
/* liste des definitions de processus */
static struct definition_processus *definition_processus[MAXPROC], *tempo[MAXPROC]; 
/* liste des variables exploitees */
extern struct nlist namelist[];
X
extern char host[];
X
void mise_a_jour_liste_processus ();
X
/*ARGSUSED*/
void Quit_processus(w, client_data, call_data)
Widget w;
caddr_t client_data, call_data;
{
#ifdef DEBUG
X    printf ("Quitte processus...\n");
#endif
X    XtPopdown (shell_processus);
}
X
/*
X * Ferme la fenetre apres click sur Ok (sans tuer le shell)
X */
X
void Quit_definition_processus(w, client_data, call_data)
Widget w;
caddr_t client_data, call_data;
{
X    XtPopdown ((Widget)client_data);
}
X
/*
X * Mise a jour manuelle
X */
X
void Mise_a_jour_liste (w, client_data, call_data)
Widget w;
caddr_t client_data, call_data;
{
X    register int n;
X    Arg args[10];
X
X    flag_mise_a_jour_autorisee = FALSE;
X
X    mise_a_jour_liste_processus ();
X
X    XtUnmapWidget (liste_processus);
X    XtMapWidget (liste_processus);
X
X    /* la mise a jour est de nouveau autorisee */
X    flag_mise_a_jour_autorisee = TRUE;
}
X
X
/*
X * Fonction de mise a jour d'un processus a partir de son indice dans
X * la liste definition_processsus
X */
X
mise_a_jour_d_un_processus (indice_processus)
int indice_processus;
{
X    register int i;
X    int existe = FALSE; 
X
X    /* Pointe la zone v */
X    if (lseek(kmem, (long) namelist[V].n_value, 0) < 0) {
X	perror ("mise_a_jour_d_un_processus-lseek");
X	exit (1);
X    }
X    
X    if (read(kmem, &vartab, sizeof(vartab)) != sizeof(vartab)) {
X	perror ("mise_a_jour_d_un_processus-read");
X	exit (1);
X    }
X
X    /* Pointe la zone proc */
X    if (lseek(kmem, (long) namelist[PROC].n_value, 0) < 0) {
X	perror ("mise_a_jour_d_un_processus-lseek");
X	exit (1);
X    }
X
X    /* On determine tous les processus existants */
X    for (i = 0 ; i < vartab.v_proc ; i++)
X    {
X	if (read(kmem, &proctab, sizeof(proctab)) != sizeof(proctab)) {
X	    perror ("mise_a_jour_d_un_processus-read");
X	    exit (1);
X	}
X
X	/* Si etat != 0 et c'est le PID cherche */
X	if (proctab.p_stat != 0 && proctab.p_pid == definition_processus[indice_processus]->p_pid) {
X	    /*
X             * lit la zone u associee au processus 
X	     */
X	    if (sysmot (RDUBLK, proctab.p_pid, &usertab, sizeof(usertab)) < 0) {
X		continue;
X	    }
X
X	    existe = TRUE;
X	    /* Mise a jour */
X	    /* Affecte les caracteristiques */
X	    definition_processus[indice_processus]->p_size = proctab.p_size;
X	    definition_processus[indice_processus]->p_stime = proctab.p_stime;
X	    definition_processus[indice_processus]->p_utime = proctab.p_utime;
X	}
X    }
X
X    return (existe);
}	    
X
X
void Mise_a_jour_graphe_processus(w, client_data, call_data)
X     Widget	w;		/* unused */
X     caddr_t	client_data;	/* pointe le numero du processus dans la liste */
X     caddr_t	call_data;	/* pointer to (double) return value */
{
X    double *valeur = (double *)call_data;
X    struct definition_processus *p = (struct definition_processus *)client_data;
X    int n;
X    Arg args[10];
X
#ifdef DEBUG
X    printf ("Mise a jour %d\n", p->p_pid);
printf ("pid %d %ld %ld\n", p->p_pid, p->p_stime ,p->p_utime);
#endif
X    cftime (buf1, "%M:%S", &p->p_stime);    
X    cftime (buf2, "%M:%S", &p->p_utime);    
#ifdef DEBUG
printf ("pid %d %s %s\n", p->p_pid, buf1, buf2);
#endif
X    sprintf (buf, "%-3d %-5d %-5d %-6s  %-6s", p->p_uid, p->p_pid, p->p_ppid, buf1, buf2);
X
X    /* Mise a jour du widget */
X    n = 0;
X    XtSetArg (args[n], XtNlabel, buf); n++;
X    XtSetValues (p->label_car, args, n);
X    
X    /* Mise a jour de l'afficheur */
X    sprintf (buf, "%-4d/%-4d", p->p_size, valeur_freemem);
X    n = 0;
X    XtSetArg (args[n], XtNlabel, buf); n++;
X    XtSetValues (p->afficheur, args, n);
X    
X    /* Mise a jour du graphe */
X    *valeur = (double)p->p_size / (double)valeur_freemem;
}
X
/*
X * Fonction de mise a jour periodique des informations sur les processus
X */
XXtTimerCallbackProc mise_a_jour_processus (closure, id)
caddr_t closure;
XXtIntervalId *id;
{
X    register int i, n;
X    Arg args[10];
X    Dimension largeur_boite, hauteur_boite, distance_horizontale, largeur_bord;
X    Dimension distance_verticale, largeur_indicateur;
X
X    if (flag_mise_a_jour_autorisee == TRUE) {
X
X	/*
X	 * Mise a jour de la liste des processus
X	 */
X	for (i = 0 ; i != nb_processus ; i++) {
X	    if (definition_processus[i] != NULL && definition_processus[i]->flag_shell_actif == TRUE) {
#ifdef DEBUG
X		printf ("mise a jour %d ", i);
#endif
X		/* 
X		 * Si le processus n'existe plus, on tue le shell et on
X		 * libere la cellule definissant le processus 
X		 */
X		if (mise_a_jour_d_un_processus (i) == FALSE) {
#ifdef DEBUG
X		    printf ("rate !!\n");
#endif
X		    XtPopdown (definition_processus[i]->popup_shell);
X		    free (definition_processus[i]);
X		    mise_a_jour_liste_processus ();
X		    XtUnmapWidget (liste_processus);
X		    XtMapWidget (liste_processus);
X
X		    break;
X		}
X	    }
X	}
X
X    /* mesure de freemem */
X    if (lseek(kmem, (long) namelist[FREEMEM].n_value, 0) < 0) {
X	perror ("mesure_charge_courante_systeme-lseek");
X	exit (1);
X    }
X    
X    if (read(kmem, &valeur_freemem, sizeof(valeur_freemem)) != sizeof (valeur_freemem)) {
X	perror ("mesure_charge_courante_systeme-read");
X	exit (1);
X    }
#ifdef DEBUG
X    printf ("freemem = %ld\n", valeur_freemem);
#endif
X	
#ifdef DEBUG
X	printf ("\n");
#endif
X    }
X    
X    /* Initialise le comptage */
X    XtAddTimeOut ((unsigned long)4000, mise_a_jour_processus, (caddr_t)NULL);
}
X
/*
X * Selection d'un processsus
X * Cette fonction est appelee lors de la selection d'un processus dans la liste
X * affichee. Elle ouvre un popup shell contenant les informations concernant
X * le processus.
X */
X
void Selection (w, client_data, call_data)
Widget w;
caddr_t client_data, call_data;
{
X    int n;
X    Arg args[10];
X    int distance_horizontale;
X    Dimension largeur, hauteur;
X    String label;
X    Pixel background;
X    XtJustify justification;
X    Boolean showgrip;
X
/*    XtListReturnStruct *p = (XtListReturnStruct *) call_data;*/
X    XawListReturnStruct *p = (XawListReturnStruct *) call_data;
X
#ifdef DEBUG
X    printf (stderr, "Selection\n"); 
#endif
#ifdef DEBUG
X    printf (stderr, "chaine %s index %d\n", p->string, p->list_index);
#endif
X
X    /* Si le processus n'est pas deja espionne */
X    if (definition_processus[p->list_index]->flag_shell_actif == FALSE) {
X
X	/* On cree un shell application au nom du processus  */
X	n = 0;
X	XtSetArg(args[n], XtNiconPixmap, pixmap_processus); n++;
X	definition_processus[p->list_index]->popup_shell = XtCreatePopupShell (strcat (strcpy (buf, host), p->string), applicationShellWidgetClass, liste_processus, args, n);
X	
X	/* 
X	 * Creation du widget forme 
X	 */
X	sprintf (buf, "forme%d", p->list_index);
X	definition_processus[p->list_index]->forme = XtCreateManagedWidget (buf, formWidgetClass, definition_processus[p->list_index]->popup_shell, NULL, 0);
X	
X	/* 
X	 * Creation du widget titre 
X	 */
X	/* lecture des valeurs dans le prototype */
X	n = 0;
X	XtSetArg (args[n], XtNlabel, &label); n++;
X	XtGetValues (prototype_label_titre, args, n);
X
X	sprintf (buf, "label_titre%d", p->list_index);
X	n = 0;
X	XtSetArg (args[n], XtNlabel, label); n++;
X	definition_processus[p->list_index]->label_titre = XtCreateManagedWidget (buf, labelWidgetClass, definition_processus[p->list_index]->forme, args, n);
X
X	/*
X	 * Creation du widget caracteristiques
X	 */
X	/* formatage des valeurs */
X	cftime (buf1, "%M:%S", &definition_processus[p->list_index]->p_stime);    
X	cftime (buf2, "%M:%S", &definition_processus[p->list_index]->p_utime);    
X	sprintf (buf, "%-3d %-5d %-5d %-6s  %-6s", definition_processus[p->list_index]->p_uid, definition_processus[p->list_index]->p_pid, definition_processus[p->list_index]->p_ppid, buf1, buf2);
X	
X	/* creation du widget */
X	n = 0;
X	XtSetArg (args[n], XtNlabel, buf); n++;
X	XtSetArg (args[n], XtNborderWidth, 0); n++;
X	XtSetArg (args[n], XtNfromVert, definition_processus[p->list_index]->label_titre); n++;
X	sprintf (buf1, "label_car%d", p->list_index);
X	definition_processus[p->list_index]->label_car = XtCreateManagedWidget (buf1, labelWidgetClass, definition_processus[p->list_index]->forme, args, n);
X
X	/* Creation du widget Paned contenant la taille et le graphe */
X	n = 0;
X	XtSetArg (args[n], XtNwidth, &largeur); n++;
X	XtSetArg (args[n], XtNheight, &hauteur); n++;
X	XtSetArg (args[n], XtNjustify, &justification); n++;
X	XtSetArg (args[n], XtNshowGrip, &showgrip); n++;
X	XtGetValues (prototype_paned, args, n);
X
X	n = 0;
X	XtSetArg (args[n], XtNwidth, largeur); n++;
X	XtSetArg (args[n], XtNheight, hauteur); n++;
X	XtSetArg (args[n], XtNjustify, justification); n++;
X	XtSetArg (args[n], XtNshowGrip, showgrip); n++;
X	XtSetArg (args[n], XtNfromVert, definition_processus[p->list_index]->label_car); n++;
X	sprintf (buf, "paned%d", p->list_index);
X	definition_processus[p->list_index]->paned = XtCreateManagedWidget (buf, panedWidgetClass, definition_processus[p->list_index]->forme, args, n);
X
X	/* creation du widget afficheur */
X	n = 0;
X	XtSetArg (args[n], XtNwidth, &largeur); n++;
X	XtSetArg (args[n], XtNheight, &hauteur); n++;
X	XtGetValues (prototype_afficheur, args, n);
X
X	n = 0;
X	XtSetArg (args[n], XtNlabel, ""); n++;
X	XtSetArg (args[n], XtNwidth, largeur); n++;
X	XtSetArg (args[n], XtNheight, hauteur); n++;
X
X	sprintf (buf, "afficheur%d", p->list_index);
X	definition_processus[p->list_index]->afficheur = XtCreateManagedWidget (buf, labelWidgetClass, definition_processus[p->list_index]->paned, args, n);
X
X
X	/* creation du widget indicateur (graphe) */
X	/* lecture des valeurs dans le prototype */
X	n = 0;
X	XtSetArg (args[n], XtNwidth, &largeur); n++;
X	XtSetArg (args[n], XtNheight, &hauteur); n++;
X	XtGetValues (prototype_indicateur, args, n);
X
X	n = 0;
X	XtSetArg (args[n], XtNwidth, largeur); n++;
X	XtSetArg (args[n], XtNheight, hauteur); n++;
X	sprintf (buf, "indicateur%d", p->list_index);
X	definition_processus[p->list_index]->indicateur = XtCreateManagedWidget (buf, stripChartWidgetClass, definition_processus[p->list_index]->paned, args, n);
X	XtAddCallback(definition_processus[p->list_index]->indicateur, XtNgetValue, Mise_a_jour_graphe_processus, (caddr_t)definition_processus[p->list_index]);
X
X
X	/* Creation du widget quit */
X	sprintf (buf, "quit%d", p->list_index);
X
X	/* lecture des valeurs dans le prototype */
X	n = 0;
X	XtSetArg (args[n], XtNlabel, &label); n++;
X	XtSetArg (args[n], XtNwidth, &largeur); n++;
X	XtSetArg (args[n], XtNhorizDistance, &distance_horizontale); n++;
X	XtGetValues (prototype_bouton_quit, args, n);
X
X	/* Fixe les valeurs */
X	n = 0;
X	XtSetArg (args[n], XtNlabel, label); n++;
X	XtSetArg (args[n], XtNfromVert, definition_processus[p->list_index]->paned); n++;
X	XtSetArg (args[n], XtNhorizDistance, distance_horizontale); n++;
X	XtSetArg (args[n], XtNwidth, largeur); n++;
X	definition_processus[p->list_index]->quit = XtCreateManagedWidget (buf, commandWidgetClass, definition_processus[p->list_index]->forme, args, n);
X	
X	/* callback du quit */
X	XtAddCallback(definition_processus[p->list_index]->quit, XtNcallback, Quit_definition_processus, (caddr_t)definition_processus[p->list_index]->popup_shell);
X	
X	/* Affichage */
X	definition_processus[p->list_index]->flag_shell_actif = TRUE;
X    }
X
X    /* affiche le popup shell */
X    XtPopup (definition_processus[p->list_index]->popup_shell, XtGrabNone);
}
X
/*
X * Mise a jour de la liste des processus
X * Cette fonction est appelee si un processus espionne est tue ou bien
X * si l'utilisateur demande une nouvelle liste des processus
X */
void mise_a_jour_liste_processus ()
{
X    register int i, j, nb, n;
X    Arg args[10];
X
X    /* interdit la mise a jour ! */	
X    flag_mise_a_jour_autorisee = FALSE;
X
X    /* Pointe la zone v */
X    if (lseek(kmem, (long) namelist[V].n_value, 0) < 0) {
X	perror ("mise_a_jour_liste_processus-lseek");
X	exit (1);
X    }
X    
X    if (read(kmem, &vartab, sizeof(vartab)) != sizeof(vartab)) {
X	perror ("mise_a_jour_liste_processus-read");
X	exit (1);
X    }
X
X    /* Pointe la zone proc */
X    if (lseek(kmem, (long) namelist[PROC].n_value, 0) < 0) {
X	perror ("mise_a_jour_liste_processus-lseek");
X	exit (1);
X    }
X
X    /* On determine tous les processus existants */
X    nb = 0;
X    for (i = 0 ; i < vartab.v_proc ; i++)
X    {
X	if (read(kmem, &proctab, sizeof(proctab)) != sizeof(proctab)) {
X	    perror ("mise_a_jour_liste_processus-read");
X	    exit (1);
X	}
X
X	/* Si etat != 0 */
X	if (proctab.p_stat != 0) {
X	    /*
X             * lit la zone u associee au processus 
X	     */
X	    if (sysmot (RDUBLK, proctab.p_pid, &usertab, sizeof(usertab)) < 0) {
X		continue;
X	    }
X
X	    /* On remplit la liste */
X	    sprintf (buf, "%s-%d", usertab.u_comm, proctab.p_pid);
#ifdef DEBUG
printf ("processus %s\n", buf);
#endif
X	    if (table_processus[nb] != NULL)
X	      free (table_processus[nb]);
X	    if ((table_processus[nb] = (String) calloc (1, 1 + strlen (buf))) == NULL) {
X		perror ("mise_a_jour_liste_processus-calloc");
X		exit (1);
X	    }
X	    strcpy (table_processus[nb], buf);
X
X	    /* Allocation de la structure de definition */
X	    if ((tempo[nb] = (struct definition_processus *) calloc (1, sizeof(struct definition_processus))) == NULL) {
X		perror ("mise_a_jour_liste_processus-calloc");
X		exit (1);
X	    }
X
X
X	    /* Affecte les caracteristiques */
X	    /* 
X	     * Si le processus etait deja espionne, on continue de l'espionner...
X	     */
X	    /* Recherche le processus dans definition_processus */
X	    for (j = 0 ; j != nb_processus ; j++) {
X		if (definition_processus[j]->p_pid == proctab.p_pid && definition_processus[j]->flag_shell_actif == TRUE) {
#ifdef DEBUG
X		    printf ("%d deja affiche !!!\n", j);
#endif
X		    /*
X                     * Recopie les widgets
X		     */
X		    tempo[nb]->flag_shell_actif = TRUE;
X		    tempo[nb]->popup_shell = definition_processus[j]->popup_shell;
X		    tempo[nb]->forme = definition_processus[j]->forme;
X		    tempo[nb]->label_titre = definition_processus[j]->label_titre;
X		    tempo[nb]->label_car = definition_processus[j]->label_car;
X		    tempo[nb]->quit = definition_processus[j]->quit;
X
X		    break;
X		}
X	    }
X
X	    /* Charge les caracteristiques du processus */
X	    tempo[nb]->p_pid = proctab.p_pid;
X	    tempo[nb]->p_ppid = proctab.p_ppid;
X	    tempo[nb]->p_utime = proctab.p_utime;
X	    tempo[nb]->p_stime = proctab.p_stime;
X	    tempo[nb]->p_uid = proctab.p_uid;
X	    tempo[nb++]->p_size = proctab.p_size;
X	}
X    }
X
X    /* 
X     * Modification de la liste : on recopie tempo sur definition processus
X     */
X    for (i = 0 ; i != nb ; i++) {
X	if (definition_processus[i] != NULL)
X	  free ((char *)definition_processus[i]);
X	definition_processus[i] = tempo[i];
X    }
X    for ( ; i < nb_processus ; i++) {
X	free ((char *)definition_processus[i]);
X    }
X
X    /* Mise a jour du nombre de processus courant */
X    nb_processus = nb;
X
X    /* Modification du widget liste */
X    n = 0;
X    XtSetArg (args[n], XtNnumberStrings, nb_processus); n++;
X    XtSetValues (liste_processus, args, n);
X
X    /* la mise a jour est de nouveau autorisee */
X    flag_mise_a_jour_autorisee = TRUE;
}
X
/*
X * Lecture et affichage de la liste des processus
X * Cette fonction cree et affiche la liste des processus, elle lance de plus
X * la mise a jour periodique des caracteristiques des processus espionnes
X */
X
void Processus(w, client_data, call_data)
Widget w;
caddr_t client_data, call_data;
{
X    int i, n;
X    Arg args[10];
X
#ifdef DEBUG
X    printf ("Processus...\n");
#endif
X
X    /* Creation de la liste des processus */
X    nb_processus = 0;
X    mise_a_jour_liste_processus ();
X
X
X    /* Modification du widget liste */
X    n = 0;
X    XtSetArg (args[n], XtNnumberStrings, nb_processus); n++;
X    XtSetValues (liste_processus, args, n);
X
X    /* affichage */
X    XtPopup (shell_processus, XtGrabNone);
X
X    /* Initialise le comptage */
X    flag_mise_a_jour_autorisee = TRUE;
X    XtAddTimeOut ((unsigned long)4000, mise_a_jour_processus, (caddr_t)NULL);
}
X
SHAR_EOF
chmod 0444 processus.c ||
echo 'restore of processus.c failed'
Wc_c="`wc -c < 'processus.c'`"
test 19144 -eq "$Wc_c" ||
	echo 'processus.c: original size 19144, current size' "$Wc_c"
fi
true || echo 'restore of xetat.c failed'
echo End of part 1, continue with part 2
exit 0

 _____________________________________________________________________________
| Pierre FICHEUX                     | Certains hommes n'ont que ce qu'ils    |
| Lectra Systemes                    | meritent, les autres sont celibataires |
| ZI Marticot  33610 CESTAS          |                                        |
| FRANCE                             |                   Sacha Guitry         |
|------------------------------------|----------------------------------------'
|tel   : (33) 56 68 80 00            |
|fax   : (33) 56 78 88 31            |
|E-mail: pficheux@lectra.gna.org     |
|____________________________________|
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
