Newsgroups: comp.sources.x
Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: Fritz Haubensak <hsk@informatik.uni-wuerzburg.de>
Subject: v17i068: TeXcad (X) version 1.2, Part04/10
Message-ID: <1992Apr21.130913.2298@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Nntp-Posting-Host: fascet
Organization: Molecular Simulations, Inc.
References: <csx-17i065-xtexcad-1.2@uunet.UU.NET>
Date: Tue, 21 Apr 1992 13:09:13 GMT
Approved: dcmartin@msi.com
Lines: 2180

Submitted-by: Fritz Haubensak <hsk@informatik.uni-wuerzburg.de>
Posting-number: Volume 17, Issue 68
Archive-name: xtexcad-1.2/part04

# this is part.04 (part 4 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file graphics.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 4; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping graphics.c'
else
echo 'x - continuing file graphics.c'
sed 's/^X//' << 'SHAR_EOF' >> 'graphics.c' &&
X		while (message_marker != message_curr)
X		{
X			a1 = message_marker->x;
X			a2 = message_marker->y;
X			real2zoomed(&a1, &a2);
X			print_text_text_marker(message_marker->textpos,a1,a2,message_marker->text);
X			message_marker = message_marker->next;
X		}
X		/* last */
X		a1 = message_curr->x;
X		a2 = message_curr->y;
X		real2zoomed(&a1, &a2);
X		print_text_text_marker(message_curr->textpos,a1,a2,message_curr->text);
X	}	/* text */
X	/* boxes */
X	/* framed */
X	if (framedBox_start != NULL)
X	{	/* min. 1 entry */
X		framedBox_marker = framedBox_start;
X		while (framedBox_marker != framedBox_curr)
X		{
X			a1 = framedBox_marker->x;
X			a2 = framedBox_marker->y;
X			e1 = framedBox_marker->h;
X			e2 = framedBox_marker->v;
X			real2zoomed(&a1, &a2);
X			real2zoomed(&e1, &e2);
X			XDrawRectangle(disp, win, gc, (int) a1, (int) a2,
X				       (unsigned int) ((int) (e1 - a1)),
X				       (unsigned int) ((int) (e2 - a2)));
X
X			print_box_text(framedBox_marker->textpos,
X				    a1, a2, e1, e2, framedBox_marker->text);
X
X			framedBox_marker = framedBox_marker->next;
X		}
X		/* last one */
X		a1 = framedBox_curr->x;
X		a2 = framedBox_curr->y;
X		e1 = framedBox_curr->h;
X		e2 = framedBox_curr->v;
X		real2zoomed(&a1, &a2);
X		real2zoomed(&e1, &e2);
X		XDrawRectangle(disp, win, gc, (int) a1, (int) a2,
X			       (unsigned int) ((int) (e1 - a1)),
X			       (unsigned int) ((int) (e2 - a2)));
X
X		print_box_text(framedBox_curr->textpos,
X			       a1, a2, e1, e2, framedBox_curr->text);
X
X	}	/* framed */
X	/* dashed */
X	if (dashedBox_start != NULL)
X	{	/* min. 1 entry */
X		XSetLineAttributes(disp, gc, 0, LineOnOffDash, CapButt, JoinMiter);
X		dashedBox_marker = dashedBox_start;
X		while (dashedBox_marker != dashedBox_curr)
X		{
X			a1 = dashedBox_marker->x;
X			a2 = dashedBox_marker->y;
X			e1 = dashedBox_marker->h;
X			e2 = dashedBox_marker->v;
X			real2zoomed(&a1, &a2);
X			real2zoomed(&e1, &e2);
X			XDrawRectangle(disp, win, gc, (int) a1, (int) a2,
X				       (unsigned int) ((int) (e1 - a1)),
X				       (unsigned int) ((int) (e2 - a2)));
X
X			print_box_text(dashedBox_marker->textpos,
X				    a1, a2, e1, e2, dashedBox_marker->text);
X
X			dashedBox_marker = dashedBox_marker->next;
X		}
X		/* last one */
X		a1 = dashedBox_curr->x;
X		a2 = dashedBox_curr->y;
X		e1 = dashedBox_curr->h;
X		e2 = dashedBox_curr->v;
X		real2zoomed(&a1, &a2);
X		real2zoomed(&e1, &e2);
X		XDrawRectangle(disp, win, gc, (int) a1, (int) a2,
X			       (unsigned int) ((int) (e1 - a1)),
X			       (unsigned int) ((int) (e2 - a2)));
X
X		print_box_text(dashedBox_curr->textpos,
X			       a1, a2, e1, e2, dashedBox_curr->text);
X
X		XSetLineAttributes(disp, gc, 0, LineSolid, CapButt, JoinMiter);
X
X	}	/* dashed */
X	/* filled */
X	if (filledBox_start != NULL)
X	{	/* min. 1 entry */
X		filledBox_marker = filledBox_start;
X		while (filledBox_marker != filledBox_curr)
X		{
X			a1 = filledBox_marker->x;
X			a2 = filledBox_marker->y;
X			e1 = filledBox_marker->h;
X			e2 = filledBox_marker->v;
X			real2zoomed(&a1, &a2);
X			real2zoomed(&e1, &e2);
X
X			XFillRectangle(disp, win, gc, (int) a1, (int) a2,
X			(unsigned int) (e1 - a1), (unsigned int) (e2 - a2));
X
X			filledBox_marker = filledBox_marker->next;
X		}
X		/* last one */
X		a1 = filledBox_curr->x;
X		a2 = filledBox_curr->y;
X		e1 = filledBox_curr->h;
X		e2 = filledBox_curr->v;
X		real2zoomed(&a1, &a2);
X		real2zoomed(&e1, &e2);
X		XFillRectangle(disp, win, gc, (int) a1, (int) a2,
X			(unsigned int) (e1 - a1), (unsigned int) (e2 - a2));
X	}	/* filled */
X	/* circle */
X	/* normal */
X	if (kreis_start != NULL)
X	{	/* min. 1 entry */
X		kreis_marker = kreis_start;
X		while (kreis_marker != kreis_curr)
X		{
X			a1 = kreis_marker->x;
X			a2 = kreis_marker->y;
X			real2zoomed(&a1, &a2);
X			r = (int) (10 * kreis_marker->radius);
X			XDrawArc(disp, win, gc, (int) (a1) - r,
X				 (int) (a2) - r,
X				 (unsigned int) (r + r),
X				 (unsigned int) (r + r),
X				 0, 360 * 64);
X			kreis_marker = kreis_marker->next;
X		}
X		/* last circle */
X		a1 = kreis_curr->x;
X		a2 = kreis_curr->y;
X		real2zoomed(&a1, &a2);
X		r = (int) (10 * kreis_curr->radius);
X		XDrawArc(disp, win, gc, (int) (a1) - r,
X			 (int) (a2) - r,
X			 (unsigned int) (r + r),
X			 (unsigned int) (r + r),
X			 0, 360 * 64);
X	}	/* normal circle */
X	/* filled */
X	if (disc_start != NULL)
X	{	/* min. 1 entry */
X		disc_marker = disc_start;
X		while (disc_marker != disc_curr)
X		{
X			a1 = disc_marker->x;
X			a2 = disc_marker->y;
X			real2zoomed(&a1, &a2);
X			r = (int) (10 * disc_marker->radius);
X			XFillArc(disp, win, gc, (int) (a1) - r,
X				 (int) (a2) - r,
X				 (unsigned int) (r + r),
X				 (unsigned int) (r + r),
X				 0, 360 * 64);
X			disc_marker = disc_marker->next;
X		}
X		/* last circle */
X		a1 = disc_curr->x;
X		a2 = disc_curr->y;
X		real2zoomed(&a1, &a2);
X		r = (int) (10 * disc_curr->radius);
X		XFillArc(disp, win, gc, (int) (a1) - r,
X			 (int) (a2) - r,
X			 (unsigned int) (r + r),
X			 (unsigned int) (r + r),
X			 0, 360 * 64);
X	}	/* filled circle */
X	/* oval */
X	if (oval_start != NULL)
X	{	/* min. 1 entry */
X		oval_marker = oval_start;
X		while (oval_marker != oval_curr)
X		{
X			a1 = oval_marker->x;
X			a2 = oval_marker->y;
X			real2zoomed(&a1, &a2);
X			e1 = oval_marker->h;
X			e2 = oval_marker->v;
X			real2zoomed(&e1, &e2);
X			DrawOval((int) a1, (int) a2, (int) e1, (int) e2);
X			oval_marker = oval_marker->next;
X		}
X		/* last circle */
X		a1 = oval_curr->x;
X		a2 = oval_curr->y;
X		real2zoomed(&a1, &a2);
X		e1 = oval_curr->h;
X		e2 = oval_curr->v;
X		real2zoomed(&e1, &e2);
X		DrawOval((int) a1, (int) a2, (int) e1, (int) e2);
X	}	/* oval circle */
}/* proc */
X
X
void
DrawOval(int x, int y, int h, int v)
{
X	/* x,y refer to upper left corner of the rectangle */
X
X	Display        *disp = XtDisplay(pboard);
X	Window          win = XtWindow(pboard);
X	int             zoom;
X	int             d1, d2;
X	float           rad;
X	d1 = h - x;
X	d2 = v - y;
X
X	if (d1 < d2)
X		rad = (float) d1 / (float) 2;
X	else
X		rad = (float) d2 / (float) 2;
X
X	if (zoomed == False)
X	{
X		zoom = 1;
X		if (rad > 20.0)
X			rad = 20.0;
X	} else
X	{
X		zoom = 10;
X		if (rad > 200.0)
X			rad = 200.0;
X	}
X
X
X
X	XDrawLine(disp, win, gc, x + (int) (rad), y, h - (int) (rad), y);
X	XDrawLine(disp, win, gc, h, y + (int) (rad), h, v - (int) (rad));
X	XDrawLine(disp, win, gc, h - (int) (rad), v, x + (int) (rad), v);
X	XDrawLine(disp, win, gc, x, v - (int) (rad), x, y + (int) (rad));
X
X	XDrawArc(disp, win, gc, x, y, (int) (2 * rad), (int) (2 * rad), 90 * 64, 90 * 64);
X	XDrawArc(disp, win, gc, h - (int) (2 * rad), y, (int) (2 * rad), (int) (2 * rad), 0, 90 * 64);
X	XDrawArc(disp, win, gc, h - (int) (2 * rad), v - (int) (2 * rad), (int) (2 * rad), (int) (2 * rad), 0, -90 * 64);
X	XDrawArc(disp, win, gc, x, v - (int) (2 * rad), (int) (2 * rad), (int) (2 * rad), 180 * 64, 90 * 64);
X
X
}
X
X
void
print_text_text_marker(char *pos, float x, float y, char *txt)
{
X /* print the text and the marker of the text-input */
X
X	int xpos,ypos;
X	int fnt_height=10;
X	int fnt_width=8;
X	Display *disp=XtDisplay(pboard);
X	Window win=XtWindow(pboard);
X	int lenn=strlen(txt)*fnt_width;
X
X
X
X
X	switch(pos[0])
X	{
X	case 't':	if (pos[1]=='l') 
X			{
X				xpos=x;
X				ypos=y+fnt_height;
X			}
X			else if (pos[1]=='r') 
X			{
X				xpos=x-lenn;
X				ypos=y+fnt_height;
X			}
X			else
X			{
X				xpos=x-lenn/2;
X				ypos=y+fnt_height;
X			}
X			draw_vector_marker(x,y-fnt_height,x,y);
X			break;
X
X	case 'b':	if (pos[1]=='l') 
X			{
X				xpos=x;
X				ypos=y;
X			}
X			else if (pos[1]=='r') 
X			{
X				xpos=x-lenn;
X				ypos=y;
X			}
X			else
X			{
X				xpos=x-lenn/2;
X				ypos=y;
X			}
X			draw_vector_marker(x,y+fnt_height,x,y);	
X			break;
X
X	case 'l':	xpos=x;
X			ypos=y+fnt_height/2;
X			draw_vector_marker(x-fnt_width,y,x,y);
X			break;
X
X	case 'r':	xpos=x-lenn;
X			ypos=y+fnt_height/2;
X			draw_vector_marker(x+fnt_width,y,x,y);
X			break;
X
X	default:	xpos=x-lenn/2;
X			ypos=y+fnt_height/2;
X			draw_vector_marker(x,y+fnt_height,x,y);
X			break;	
X
X	} /* switch */
X
X	XDrawString(disp,win,gc,xpos,ypos,txt,lenn/fnt_width);
X					
}
X
void
print_box_text(char *pos, float x, float y, float h, float v, char *txt)
{
X	/* displays the first letter of the box-text at */
X	/* the corresponding position in the frame */
X
X	Display        *disp;
X	Drawable        win;
X	int             hor, ver,lenn;
X	disp = XtDisplay(pboard);
X	win = XtWindow(pboard);
X
X	switch (pos[0])
X	{
X	case 't':
X		ver = (int) (y + 0.1 * (v - y));
X		hor = (int) (x + 0.5 * (h - x));
X		break;
X
X	case 'b':
X		ver = (int) (v - 0.1 * (v - y));
X		hor = (int) (x + 0.5 * (h - x));
X		break;
X
X	case 'r':
X		hor = (int) (h - 0.1 * (h - x));
X		ver = (int) (v - 0.5 * (v - y));
X		break;
X
X	case 'l':
X		hor = (int) (x + 0.1 * (h - x));
X		ver = (int) (v - 0.5 * (v - y));
X		break;
X
X	case '\0':
X		ver = (int) (y + (v - y) / 2);	/* center */
X		hor = (int) (x + (h - x) / 2);
X		break;
X
X	}	/* switch */
X
X
X	switch (pos[1])
X	{
X	case 'r':
X		hor = (int) (h - 0.1 * (h - x));
X		break;
X	case 'l':
X		hor = (int) (x + 0.1 * (h - x));
X		break;
X	}	/* switch */
X
X
X	if (zoomed==False) XDrawString(disp, win, gc, hor, ver, txt, 1);
X		else
X		{
X			lenn=strlen(txt)*8; /* 8 Bit horizontal width */
X			/* right adjustment ? */
X			if ( (pos[0]=='r') || (pos[1]=='r') )
X				XDrawString(disp, win, gc, hor-lenn, ver, txt, lenn/8);
X			else 
X				if ( (pos[0]=='l') || (pos[1]=='l') )
X				 XDrawString(disp, win, gc, hor, ver, txt, lenn/8);
X			else /* center text */
X				XDrawString(disp, win, gc, hor-lenn/2, ver, txt, lenn/8);
X
X			/* show selection point */
X			draw_vector_marker(hor,ver+20,hor,ver);
X		}
X			
X			
X
}
X
X
X
X
void
init_prompt_text()
{
X	/* called once. builds the interface for text-queries */
X
X	Widget          container, txt, cancel, ok;
X	XtTranslations  trans_table;
X	char            temp_str[200] = "<KeyPress>Return: ok_text() \n\
X			Ctrl<Key>J      : dummy() \n\
X			Ctrl<Key>O      : dummy() \n\
X			Ctrl<Key>M      : dummy()";
X
X	static XtActionsRec actions[150] = {{"dummy", dummy},
X	{"ok_text", ok_text}};
X
X
X
X	
X	input_up = XtCreatePopupShell("Text Input", transientShellWidgetClass, canvas, NULL,0);
X
X
X	n=0;
X	XtSetArg(args[n],XtNorientation,XtorientHorizontal);
X	container = XtCreateManagedWidget("hi", boxWidgetClass, input_up, args, n);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 520);
X	n++;
X	XtSetArg(args[n], XtNautoFill, False);
X	n++;
X	XtSetArg(args[n], XtNuseStringInPlace, True);
X	n++;
X	XtSetArg(args[n], XtNstring, textinput);
X	n++;
X	XtSetArg(args[n], XtNlength, XtNumber(textinput));
X	n++;
X	XtSetArg(args[n], XtNeditType, XawtextEdit);
X	n++;
X	XtSetArg(args[n], XtNresize, XawtextResizeWidth);
X	n++;
X	XtSetArg(args[n], XtNwrap, XawtextWrapWord);
X	n++;
X
X	
X
X	txt = XtCreateManagedWidget("dialogue", asciiTextWidgetClass, container, args, n);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 30);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 255);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Cancel");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X
X	
X	cancel = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(cancel, XtNcallback, cancel_text, NULL);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 30);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 255);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Accept");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X
X	
X
X	ok = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(ok, XtNcallback, ok_text, NULL);
X
X	XtAddActions(actions, XtNumber(actions));
X	trans_table = XtParseTranslationTable(temp_str);
X	XtOverrideTranslations(txt, trans_table);
X
}
X
void
cancel_text()
{
X	transform(textinput);
X	XtPopdown(input_up);
}
X
void
ok_text()
{
X	float           x, y;
X	Display        *disp;
X	Drawable        win;
X	int		lenn=81;
X
X
X	transform(textinput);
X
X	if (strlen(textinput) == 0)
X	{	/* the input was zero-string */
X		cancel_text();
X		return;
X	}
X	disp = XtDisplay(pboard);
X	win = XtWindow(pboard);
X
X	XtPopdown(input_up);
X	/* insert text into list */
X
X	x = (float) n;
X	y = (float) m;
X	if (zoomed == True)
X		zoomed2real(&x, &y);
X	/* allocate memory */
X	if (message_start == NULL)
X	{	/* first entry */
X		message_start = (struct fig5 *) malloc(sizeof(message));
X		message_curr = message_start;
X	} else
X	{	/* insert at end */
X		message_curr->next = (struct fig5 *) malloc(sizeof(message));
X		message_curr = message_curr->next;
X	}
X	/* message_curr points to struct */
X	/* save coordinates */
X	message_curr->x = x;
X	message_curr->y = y;
X	/* save text-string */
X	/* preserve a total string length of 80 Bytes */
X	/* this is useful to edit the text */
X	if (lenn<1+strlen(textinput)) lenn=1+strlen(textinput);
X	message_curr->text = (char *) malloc(lenn);
X	strcpy(message_curr->text, textinput);
X	message_curr->next = NULL;
X
X	/* query the position */
X
X	/* initial values */
X	txtpos[0] = '\0';
X	txtpos[1] = '\0';
X	query_text_adjustment();
X
X	if (txtpos[0] == '\0')	/* center */
X	{
X		txtpos[0] = 'c';
X		txtpos[1] = 'c';
X	}
X	message_curr->textpos[0] = txtpos[0];
X	message_curr->textpos[1] = txtpos[1];
X
X	/* refresh show the new object ! */
}
X
X
X
void
manage_text_input()
{
X	Position        x, y, x_rel, y_rel;
X	int             h, v;
X	unsigned int    mask;
X
X
X	PointerPosition(&h, &v, &mask);
X	/* button1 was pressed in pboard at x,y */
X
X	/* setting position of widget */
X	n = 0;
X	XtSetArg(args[n], XtNx, &x_rel);
X	n++;
X	XtSetArg(args[n], XtNy, &y_rel);
X	n++;
X	XtGetValues(canvas, args, n);	/* get the relative coordinates of
X					 * widget: canvas */
X	XtTranslateCoords(canvas, x_rel, y_rel, &x, &y);
X	n = 0;
X	XtSetArg(args[n], XtNx, x + cmd_btn_width + 2 * new_section);
X	n++;
X	XtSetArg(args[n], XtNy, y + 4 * cmd_btn_height);
X	n++;
X	XtSetValues(input_up, args, n);
X	/* position set ! */
X
X	XtPopupSpringLoaded(input_up);
X	n = h;
X	m = v;
X
X
}
X
X
X
void
init_text_and_position()
{
X	/* called once. used to buid the interface for text-queries and */
X	/* text-positions. used with dashed and framed boxes */
X
X	Widget          container, txt1, cancel, center, tl, tr, bl, br, b,
X	                t, quit, lbl, r, l;
X	XtTranslations  trans_table;
X	char            temp_str[200] = "<KeyPress>Return: dummy() \n\
X			Ctrl<Key>J      : dummy() \n\
X			Ctrl<Key>O      : dummy() \n\
X			Ctrl<Key>M      : dummy()";
X
X
X	static XtActionsRec actions[150] = {{"dummy", dummy}};
X
X
X
X	
X
X	box_me_up = XtCreatePopupShell("Text Input", transientShellWidgetClass, canvas, NULL,0);
X
X
X	container = XtCreateManagedWidget("hi", boxWidgetClass, box_me_up, NULL, 0);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 40);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 260);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Text Placement");
X	n++;
X	
X	lbl = XtCreateManagedWidget("hi", labelWidgetClass, container, args, n);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 260);
X	n++;
X	XtSetArg(args[n], XtNautoFill, False);
X	n++;
X	XtSetArg(args[n], XtNuseStringInPlace, True);
X	n++;
X	XtSetArg(args[n], XtNstring, boxinput);
X	n++;
X	XtSetArg(args[n], XtNlength, XtNumber(boxinput));
X	n++;
X	XtSetArg(args[n], XtNeditType, XawtextEdit);
X	n++;
X	XtSetArg(args[n], XtNresize, XawtextResizeWidth);
X	n++;
X	XtSetArg(args[n], XtNwrap, XawtextWrapWord);
X	n++;
X	
X	txt1 = XtCreateManagedWidget("dialogue", asciiTextWidgetClass, container, args, n);
X
X	n = 0;
X	XtSetArg(args[n], XtNlabel, "Position: CENTER");
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 260);
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyLeft);
X	n++;
X	
X	txt2 = XtCreateManagedWidget("< position of text >", labelWidgetClass, container, args, n);
X
X
X	n = 0;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 260);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Style: NO SHADOW");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyLeft);
X	n++;
X	
X	txt3 = XtCreateManagedWidget("shadow", labelWidgetClass, container, args, n);
X
X	n = 0;
X	XtSetArg(args[n], XtNbackground, XtDefaultForeground);
X	n++;
X	XtSetArg(args[n], XtNforeground, XtDefaultBackground);
X	n++;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 7);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 260);
X	n++;
X	
X	XtCreateManagedWidget("", labelWidgetClass, container, args, n);
X
X
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 25);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 260);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Center Top and Bottom");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	center = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(center, XtNcallback, box_text, km);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 95);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Top Left");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	tl = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(tl, XtNcallback, box_text, ka);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 55);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Top");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	t = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(t, XtNcallback, box_text, ke);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 95);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Top Right");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	tr = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(tr, XtNcallback, box_text, kb);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 125);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Left");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	l = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(l, XtNcallback, box_text, kl);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 125);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Right");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	r = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(r, XtNcallback, box_text, kr);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 95);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Bottom Left");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	bl = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(bl, XtNcallback, box_text, kc);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 55);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Bottom");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	b = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(b, XtNcallback, box_text, kf);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 95);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Bottom Right");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	br = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(br, XtNcallback, box_text, kd);
X
X	n = 0;
X	XtSetArg(args[n], XtNbackground, XtDefaultForeground);
X	n++;
X	XtSetArg(args[n], XtNforeground, XtDefaultBackground);
X	n++;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 7);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 260);
X	n++;
X	XtCreateManagedWidget("", labelWidgetClass, container, args, n);
X
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 120);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Filled shadow");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	
X	XtAddCallback(XtCreateManagedWidget("hi", commandWidgetClass, container, args, n)
X		      ,XtNcallback, box_text, ff);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 120);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Framed shadow");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	
X	XtAddCallback(XtCreateManagedWidget("hi", commandWidgetClass, container, args, n)
X		      ,XtNcallback, box_text, nn);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 260);
X	n++;
X	XtSetArg(args[n], XtNlabel, "No shadow");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	
X	XtAddCallback(XtCreateManagedWidget("hi", commandWidgetClass, container, args, n)
X		      ,XtNcallback, box_text, minus);
X
X
X	n = 0;
X	XtSetArg(args[n], XtNbackground, XtDefaultForeground);
X	n++;
X	XtSetArg(args[n], XtNforeground, XtDefaultBackground);
X	n++;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 7);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 260);
X	n++;
X	XtCreateManagedWidget("", labelWidgetClass, container, args, n);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 45);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 125);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Accept");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	quit = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(quit, XtNcallback, box_text, kp);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 45);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 125);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Cancel");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	cancel = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(cancel, XtNcallback, box_text, kq);
X
X	XtAddActions(actions, XtNumber(actions));
X	trans_table = XtParseTranslationTable(temp_str);
X	XtOverrideTranslations(txt1, trans_table);
X	txtpos[0] = '\0';	/* default: center */
X
X
}
X
X
void
box_text(Widget cmd, char id, caddr_t call_data)
{
X	/* store the text-position */
X
X	static char     s1[100], s2[100];
X	strcpy(s1, "Position : ");
X	strcpy(s2, "Style: ");
X
X
X	switch (id)
X	{
X	case 'q':
X		txtpos[0] = '?';
X		XtPopdown(box_me_up);	/* cancel */
X		visible = False;
X		break;	/* cancel */
X	case 'm':
X		strcat(s1, "CENTER text");
X		txtpos[0] = '\0';
X		break;
X	case 'a':
X		strcat(s1, "TOP LEFT Placement");
X		strcpy(txtpos, "tl");
X		break;
X	case 'b':
X		strcat(s1, "TOP RIGHT Placement");
X		strcpy(txtpos, "tr");
X		break;
X	case 'c':
X		strcat(s1, "BOTTOM LEFT Placement");
X		strcpy(txtpos, "bl");
X		break;
X	case 'd':
X		strcat(s1, "BOTTOM RIGHT Placement");
X		strcpy(txtpos, "br");
X		break;
X	case 'e':
X		strcat(s1, "TOP Placement");
X		strcpy(txtpos, "t");
X		break;
X	case 'f':
X		strcat(s1, "BOTTOM Placement");
X		strcpy(txtpos, "b");
X		break;
X	case 'l':
X		strcat(s1, "LEFT Placement");
X		strcpy(txtpos, "l");
X		break;
X	case 'r':
X		strcat(s1, "RIGHT Placement");
X		strcpy(txtpos, "r");
X		break;
X	case 'p':
X		XtPopdown(box_me_up);
X		visible = False;
X		transform(boxinput);	/* remove special chars */
X		break;
X	default:
X		shadow = id;
X		if (shadow == '-')
X			strcat(s2, "NO SHADOW");
X		else if (shadow == 'N')
X			strcat(s2, "FRAMED SHADOW");
X		else
X			strcat(s2, "FILLED SHADOW");
X		break;
X	}	/* end of switch */
X
X	if ((id != 'q') && (id != 'p'))
X	{
X		if ((id != '-') && (id != 'N') && (id != 'F'))
X		{
X			XtSetArg(args[0], XtNlabel, s1);
X			XtSetValues(txt2, args, 1);
X		} else
X		{
X			XtSetArg(args[0], XtNlabel, s2);
X			XtSetValues(txt3, args, 1);
X		}
X	}
}
X
void
query_box_text_and_position()
{
X	/* called to enter the text and textposition */
X
X	Position        x, y, x_rel, y_rel;
X	int             h, v;
X	XtAppContext    app_context;	/* Applikationscontext */
X	XEvent          event;	/* Event */
X	unsigned int    mask;
X
X
X	PointerPosition(&h, &v, &mask);
X	/* setting position of widget */
X	n = 0;
X	XtSetArg(args[n], XtNx, &x_rel);
X	n++;
X	XtSetArg(args[n], XtNy, &y_rel);
X	n++;
X	XtGetValues(canvas, args, n);	/* get the relative coordinates of
X					 * widget: canvas */
X	XtTranslateCoords(canvas, x_rel, y_rel, &x, &y);
X	n = 0;
X	XtSetArg(args[n], XtNx, x + cmd_btn_width + 2 * new_section);
X	n++;
X	XtSetArg(args[n], XtNy, y + 4 * cmd_btn_height);
X	n++;
X	XtSetValues(box_me_up, args, n);
X	/* position set ! */
X
X
X	n = 0;
X	XtSetArg(args[n], XtNlabel, "Position : CENTER text");
X	n++;
X	XtSetValues(txt2, args, n);
X
X	txtpos[0] = '\0';
X
X	XtPopupSpringLoaded(box_me_up);
X
X
X	app_context = XtWidgetToApplicationContext(box_me_up);
X
X	visible = True;
X
X	while (visible)
X	{
X		XtAppNextEvent(app_context, &event);
X		XtDispatchEvent(&event);
X
X	}
X
X	transform(boxinput);
X
X
}
X
X
X
void
perform_erase()
{
X	/* erases all */
X
X	xur = 0.0;
X	yur = 0.0;
X
X
X	/* normal circle */
X	if (kreis_start != NULL)
X	{
X		do
X		{
X			kreis_marker = kreis_start;
X			kreis_start = kreis_marker->next;
X			free(kreis_marker);
X		} while (kreis_marker != kreis_curr);
X
X		kreis_start = NULL;
X		kreis_curr = NULL;
X	}
X	/* filled circle */
X	if (disc_start != NULL)
X	{
X		do
X		{
X			disc_marker = disc_start;
X			disc_start = disc_marker->next;
X			free(disc_marker);
X		} while (disc_marker != disc_curr);
X
X		disc_start = NULL;
X		disc_curr = NULL;
X	}
X	/* oval */
X	if (oval_start != NULL)
X	{
X		do
X		{
X			oval_marker = oval_start;
X			oval_start = oval_marker->next;
X			free(oval_marker);
X		} while (oval_marker != oval_curr);
X
X		oval_start = NULL;
X		oval_curr = NULL;
X	}
X	/* framedBox */
X	if (framedBox_start != NULL)
X	{
X		do
X		{
X			framedBox_marker = framedBox_start;
X			framedBox_start = framedBox_marker->next;
X			free(framedBox_marker);
X		} while (framedBox_marker != framedBox_curr);
X
X		framedBox_start = NULL;
X		framedBox_curr = NULL;
X	}
X	/* dashedBox */
X	if (dashedBox_start != NULL)
X	{
X		do
X		{
X			dashedBox_marker = dashedBox_start;
X			dashedBox_start = dashedBox_marker->next;
X			free(dashedBox_marker);
X		} while (dashedBox_marker != dashedBox_curr);
X
X		dashedBox_start = NULL;
X		dashedBox_curr = NULL;
X	}
X	/* filledBox */
X	if (filledBox_start != NULL)
X	{
X		do
X		{
X			filledBox_marker = filledBox_start;
X			filledBox_start = filledBox_marker->next;
X			free(filledBox_marker);
X		} while (filledBox_marker != filledBox_curr);
X
X		filledBox_start = NULL;
X		filledBox_curr = NULL;
X	}
X	/* line */
X	if (strich_start != NULL)
X	{
X		do
X		{
X			strich_marker = strich_start;
X			strich_start = strich_marker->next;
X			free(strich_marker);
X		} while (strich_marker != strich_curr);
X
X		strich_start = NULL;
X		strich_curr = NULL;
X	}
X	/* vector */
X	if (pfeil_start != NULL)
X	{
X		do
X		{
X			pfeil_marker = pfeil_start;
X			pfeil_start = pfeil_marker->next;
X			free(pfeil_marker);
X		} while (pfeil_marker != pfeil_curr);
X
X		pfeil_start = NULL;
X		pfeil_curr = NULL;
X	}
X	/* text */
X	if (message_start != NULL)
X	{
X		do
X		{
X			message_marker = message_start;
X			message_start = message_marker->next;
X			free(message_marker);
X		} while (message_marker != message_curr);
X
X		message_start = NULL;
X		message_curr = NULL;
X	}
X	/* bezier */
X	if (bezier_start != NULL)
X	{
X		do
X		{
X			bezier_marker = bezier_start;
X			bezier_start = bezier_marker->next;
X			free(bezier_marker);
X		} while (bezier_marker != bezier_curr);
X
X		bezier_start = NULL;
X		bezier_curr = NULL;
X	}
}
X
X
X
void
init_ask_erase()
{
X	/* initializes the 'are you sure ?' - widget */
X
X	Widget          container, c1, c2, lbl;
X	
X	
X	
X	
X	ask_up = XtCreatePopupShell("P A X", transientShellWidgetClass, canvas, NULL,0);
X
X
X	container = XtCreateManagedWidget("hi", boxWidgetClass, ask_up, NULL, 0);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 40);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 160);
X	n++;
X	XtSetArg(args[n], XtNlabel, "ARE YOU SURE ?");
X	n++;
X	
X	lbl = XtCreateManagedWidget("hi", labelWidgetClass, container, args, n);
X
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 25);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 75);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Accept");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	c1 = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(c1, XtNcallback, answer, kj);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 25);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 75);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Cancel");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	c2 = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(c2, XtNcallback, answer, kn);
}
X
X
void
query_ask_erase()
{
X	int             h, v;
X	unsigned int    mask;
X	Position        x_rel, y_rel, x, y, xx, yy;
X	XtAppContext    app_context;	/* Applikationcontext */
X	XEvent          event;	/* Event */
X
X
X
X	txtpos[0] = '\0';
X
X	/* is there anything in the database ? */
X
X	if (
X	    (message_start == NULL) && (strich_start == NULL) && 
X	    (pfeil_start == NULL) && (framedBox_start == NULL) && 
X	    (dashedBox_start == NULL) && (filledBox_start == NULL)
X	    && (kreis_start == NULL) && (disc_start == NULL) && 
X	    (oval_start == NULL) && (bezier_start == NULL)
X	   )
X	{
X		/* database empty */
X		n = 0;
X		XtSetArg(args[n], XtNx, &x_rel);
X		n++;
X		XtSetArg(args[n], XtNy, &y_rel);
X		n++;
X		XtGetValues(pboard, args, n);
X		XtTranslateCoords(canvas, x_rel, y_rel, &xx, &yy);
X		n = 0;
X		XtSetArg(args[n], XtNx, 175 + xx);
X		n++;
X		XtSetArg(args[n], XtNy, 295 + yy);
X		n++;
X		XtSetValues(sign_up, args, n);
X		XtPopup(sign_up, XtGrabExclusive);
X		return;
X	}
X	PointerPosition(&h, &v, &mask);
X	/* setting position of widget */
X	n = 0;
X	XtSetArg(args[n], XtNx, &x_rel);
X	n++;
X	XtSetArg(args[n], XtNy, &y_rel);
X	n++;
X	XtGetValues(canvas, args, n);
X	XtTranslateCoords(canvas, x_rel, y_rel, &x, &y);
X	n = 0;
X	XtSetArg(args[n], XtNx, x + cmd_btn_width + 2 * new_section);
X	n++;
X	XtSetArg(args[n], XtNy, v);
X	n++;
X	XtSetValues(ask_up, args, n);
X	/* position set ! */
X
X
X	XtPopup(ask_up, XtGrabExclusive);
X
X
X	app_context = XtWidgetToApplicationContext(ask_up);
X
X	visible = True;
X
X	while (visible)
X	{
X		XtAppNextEvent(app_context, &event);
X		XtDispatchEvent(&event);
X
X	}
X
X
X
X
}
X
X
X
X
void
draw_the_shadow(void *object, char id)
{
X	/* shadows are drawn by the <refresh>-function */
X	struct fig2    *shade;
X	struct fig3    *frame;
X	struct fig4    *dash;
X	float           x, y, h, v;
X	float           ver, hor;
X	int		ext; /* width/height of shadow */
X	if (shadow == '-')
X		return;	/* no shadow */
X
X	if (id == 'N')
X	{
X		frame = (struct fig3 *) object;
X		x = frame->x;
X		y = frame->y;
X		h = frame->h;
X		v = frame->v;
X	} else
X	{
X		dash = (struct fig4 *) object;
X		x = dash->x;
X		y = dash->y;
X		h = dash->h;
X		v = dash->v;
X	}
X
X	norm_rectangle(&x, &y, &h, &v);
X	
X	hor=0.1*(h-x); /* h is always bigger than x; see norm_rectangle ! */
X	ver=0.1*(v-y); 
X	
X	ext=(hor<ver) ? hor : ver;
X	ext=(ext<10) ? ext : 10;
X	
X	hor=ext;
X	ver=ext;
X	
X	if (shadow == 'N')
X	{
X		/* get new memory for lines */
X		shade = (struct fig2 *) malloc(sizeof(strich));
X		shade->x = x + hor;
X		shade->y = v;
X		shade->h = x + hor;
X		shade->v = v + ver;
X		if (strich_curr != NULL)
X			strich_curr->next = shade;
X		shade->next = NULL;
X		strich_curr = shade;
X		if (strich_start == NULL)
X			strich_start = shade;
X		/* that was the first one */
X		shade = (struct fig2 *) malloc(sizeof(strich));
X		shade->x = x + hor;
X		shade->y = v + ver;
X		shade->h = h + hor;
X		shade->v = v + ver;
X		if (strich_curr != NULL)
X			strich_curr->next = shade;
X		shade->next = NULL;
X		strich_curr = shade;
X		/* now comes the 3rd one */
X		shade = (struct fig2 *) malloc(sizeof(strich));
X		shade->x = h + hor;
X		shade->y = v + ver;
X		shade->h = h + hor;
X		shade->v = y + ver;
X		if (strich_curr != NULL)
X			strich_curr->next = shade;
X		shade->next = NULL;
X		strich_curr = shade;
X		/* and finally... */
X		shade = (struct fig2 *) malloc(sizeof(strich));
X		shade->x = h + hor;
X		shade->y = y + ver;
X		shade->h = h;
X		shade->v = y + ver;
X		if (strich_curr != NULL)
X			strich_curr->next = shade;
X		shade->next = NULL;
X		strich_curr = shade;
X	} else
X	{
X		/* first fbox */
X		shade = (struct fig2 *) malloc(sizeof(filledBox));
X		shade->x = x + hor;
X		shade->y = v;
X		shade->h = h + hor;
X		shade->v = v + hor;
X		if (filledBox_curr != NULL)
X			filledBox_curr->next = shade;
X		shade->next = NULL;
X		filledBox_curr = shade;
X		if (filledBox_start == NULL)
X			filledBox_start = shade;
X		/* 2nd fbox */
X		shade = (struct fig2 *) malloc(sizeof(filledBox));
X		shade->x = h;
X		shade->y = y + hor;
X		shade->h = h + hor;
X		shade->v = v;
X		if (filledBox_curr != NULL)
X			filledBox_curr->next = shade;
X		shade->next = NULL;
X		filledBox_curr = shade;
X	}
X
}
X
X
X
X
X
void
init_text_adjustment()
{
X
X	Widget          container, center, tl, t, tr, l, r, bl, b, br,
X	                quit;
X
X	
X	pop_adjust_up = XtCreatePopupShell("Text Adjustment", transientShellWidgetClass, canvas, NULL,0);
X
X
X	container = XtCreateManagedWidget("hi", boxWidgetClass, pop_adjust_up, NULL, 0);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 40);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 260);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Text Adjustment");
X	n++;
X	
X	XtCreateManagedWidget("hi", labelWidgetClass, container, args, n);
X
X
X	n = 0;
X	XtSetArg(args[n], XtNlabel, "Position: CENTER");
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 260);
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyLeft);
X	n++;
X	
X	adj_txt2 = XtCreateManagedWidget("< position of text >", labelWidgetClass, container, args, n);
X
X
X
X	n = 0;
X	XtSetArg(args[n], XtNbackground, XtDefaultForeground);
X	n++;
X	XtSetArg(args[n], XtNforeground, XtDefaultBackground);
X	n++;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 7);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 260);
X	n++;
X	XtCreateManagedWidget("", labelWidgetClass, container, args, n);
X
X
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 25);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 260);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Center text");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	center = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(center, XtNcallback, adjust_text, kz);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 95);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Top Left");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	tl = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(tl, XtNcallback, adjust_text, ka);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 55);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Top");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	t = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(t, XtNcallback, adjust_text, ke);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 95);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Top Right");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	tr = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(tr, XtNcallback, adjust_text, kb);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 125);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Left");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	l = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(l, XtNcallback, adjust_text, kl);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 125);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Right");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	r = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(r, XtNcallback, adjust_text, kr);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 95);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Bottom Left");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	bl = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(bl, XtNcallback, adjust_text, kc);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 55);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Bottom");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	b = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(b, XtNcallback, adjust_text, kf);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 20);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 95);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Bottom Right");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	br = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(br, XtNcallback, adjust_text, kd);
X
X	n = 0;
X	XtSetArg(args[n], XtNbackground, XtDefaultForeground);
X	n++;
X	XtSetArg(args[n], XtNforeground, XtDefaultBackground);
X	n++;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 7);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 260);
X	n++;
X	XtCreateManagedWidget("", labelWidgetClass, container, args, n);
X
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, (XtArgVal) 45);
X	n++;
X	XtSetArg(args[n], XtNwidth, (XtArgVal) 260);
X	n++;
X	XtSetArg(args[n], XtNlabel, "Accept");
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	
X	quit = XtCreateManagedWidget("hi", commandWidgetClass, container, args, n);
X	XtAddCallback(quit, XtNcallback, adjust_text, kp);
X
X
X	txtpos[0] = '\0';	/* default: center */
X
X
}
X
X
X
X
X
void
adjust_text(Widget cmd, char id, caddr_t call_data)
{
X	/* store the text-position */
X
X	static char     s1[100];
X	strcpy(s1, "Position : ");
X
X
X
X	switch (id)
X	{
X
X	case 'z':
X		strcat(s1, "CENTER");
X		txtpos[0] = '\0';
X		break;
X	case 'a':
X		strcat(s1, "TOP LEFT");
X		strcpy(txtpos, "tl");
X		break;
X	case 'b':
X		strcat(s1, "TOP RIGHT");
X		strcpy(txtpos, "tr");
X		break;
X	case 'c':
X		strcat(s1, "BOTTOM LEFT");
X		strcpy(txtpos, "bl");
X		break;
X	case 'd':
X		strcat(s1, "BOTTOM RIGHT");
X		strcpy(txtpos, "br");
X		break;
X	case 'e':
X		strcat(s1, "TOP");
X		strcpy(txtpos, "t");
X		break;
X	case 'f':
X		strcat(s1, "BOTTOM");
X		strcpy(txtpos, "b");
X		break;
X	case 'l':
X		strcat(s1, "LEFT");
X		strcpy(txtpos, "l");
X		break;
X	case 'r':
X		strcat(s1, "RIGHT");
X		strcpy(txtpos, "r");
X		break;
X	case 'p':
X		XtPopdown(pop_adjust_up);
X		visible = False;
X		transform(textinput);	/* remove special chars */
X		break;
X	default:
X		break;
X	}	/* end of switch */
X
X	if ((id != 'q') && (id != 'p'))
X	{
X		XtSetArg(args[0], XtNlabel, s1);
X		XtSetValues(adj_txt2, args, 1);
X	}
}
X
X
X
X
X
void
query_text_adjustment()
{
X
X	Position        x, y, x_rel, y_rel;
X	int             h, v;
X	XtAppContext    app_context;	/* Applikationscontext */
X	XEvent          event;	/* Event */
X	unsigned int    mask;
X
X
X	PointerPosition(&h, &v, &mask);
X	/* setting position of widget */
X	n = 0;
X	XtSetArg(args[n], XtNx, &x_rel);
X	n++;
X	XtSetArg(args[n], XtNy, &y_rel);
X	n++;
X	XtGetValues(canvas, args, n);	/* get the relative coordinates of
X					 * widget: canvas */
X	XtTranslateCoords(canvas, x_rel, y_rel, &x, &y);
X	n = 0;
X	XtSetArg(args[n], XtNx, x + cmd_btn_width + 2 * new_section);
X	n++;
X	XtSetArg(args[n], XtNy, y + 4 * cmd_btn_height);
X	n++;
X	XtSetValues(pop_adjust_up, args, n);
X	/* position set ! */
X
X
X	n = 0;
X	XtSetArg(args[n], XtNlabel, "Position : CENTER");
X	n++;
X	XtSetValues(adj_txt2, args, n);
X
X	txtpos[0] = '\0';
X
X	XtPopupSpringLoaded(pop_adjust_up);
X
X
X	app_context = XtWidgetToApplicationContext(pop_adjust_up);
X
X	visible = True;
X
X	while (visible)
X	{
X		XtAppNextEvent(app_context, &event);
X		XtDispatchEvent(&event);
X
X	}
X
X	transform(textinput);
X
X
}
X
int number_of_text()
{
X  int i;
X	/* compute number of text-entries */
X	i=1;
X	if (message_start==NULL) return 0;
X	if (message_start==message_curr) return 1;
X	message_marker=message_start;
X	do
X	{
X		i++;
X		if (message_marker!=message_curr) message_marker=message_marker->next;
X	} while (message_marker!=message_curr);
X
X	return i;
}
X
X
X
void textedit()
{
X  Widget perle;
X  Widget kiste,toggle,blabla;
X  Widget ok,del,more;
X  int i,lenn=81;
X  int anz_text;
X  XtTranslations  trans_table,trans_table2;
X  char		  leave_str[100]="<LeaveNotify> : beende_textedit() correct_text_error()\n";
X  char		  ok_str[100]="<ButtonRelease> : beende_textedit() correct_text_error()\n";
X  char		  more_str[100]="<ButtonRelease>    : beende_textedit() textedit()\n";
X  char		  del_str[100]="<ButtonRelease>    : delete_textedit() beende_textedit() textedit()\n";
X
X  char            temp_str2[100] = 
X			"<KeyPress>Return	: dummy() \n";
X  
X  static XtActionsRec actions[200] = {{"dummy", dummy},
X				      {"textedit", textedit},
X				      {"beende_textedit", beende_textedit},
X				      {"delete_textedit", delete_textedit},
X				      {"correct_text_error",correct_text_error}};
X  Position x_rel, y_rel, x, y;
X	
X
X	muschel=XtCreatePopupShell("Edit/Delete", transientShellWidgetClass, canvas, NULL, 0);
X
X	trans_table = XtParseTranslationTable(leave_str);
X	XtOverrideTranslations(muschel, trans_table);
X
X	perle=XtCreateManagedWidget("behaelter", boxWidgetClass, muschel, NULL, 0);
X	
X	n=0;
X	XtSetArg(args[n], XtNlabel,"Edit Normal Text");n++;
X	XtSetArg(args[n], XtNjustify,XtJustifyCenter);n++;
X	XtSetArg(args[n], XtNwidth,560);n++;
X	XtSetArg(args[n], XtNheight,40);n++;
X	
X	XtCreateManagedWidget("", labelWidgetClass, perle, args, n);
X
X
X	n=0;
X	XtSetArg(args[n], XtNlabel,"Accept");n++;
X	XtSetArg(args[n], XtNjustify,XtJustifyCenter);n++;
X	XtSetArg(args[n], XtNwidth,130);n++;
X	XtSetArg(args[n], XtNheight,40);n++;
X	XtSetArg(args[n], XtNshapeStyle,XmuShapeOval);n++;
X	
X	
X	ok=XtCreateManagedWidget("ok", commandWidgetClass, perle, args, n);
X	trans_table = XtParseTranslationTable(ok_str);
X	XtOverrideTranslations(ok, trans_table);
X
X
X	/* compute number of text-entries */
X	anz_text=number_of_text();
X
X	if (anz_text==0)
X	{
X		leave_pick("Sorry - No text available !\n");
X		return;
X	}	
X
X
X	if (anz_text>10)
X	{
X		n=0;
X		XtSetArg(args[n], XtNlabel,"More");n++;
X		XtSetArg(args[n], XtNjustify,XtJustifyCenter);n++;
X		XtSetArg(args[n], XtNwidth,130);n++;
X		XtSetArg(args[n], XtNheight,40);n++;
X		XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);n++;
X		
X		more=XtCreateManagedWidget("more", commandWidgetClass, perle, args, n);
X		trans_table = XtParseTranslationTable(more_str);
X		XtOverrideTranslations(more, trans_table);
X	}
X
X
X	n=0;
X	XtSetArg(args[n], XtNlabel,"Delete");n++;
X	XtSetArg(args[n], XtNjustify,XtJustifyCenter);n++;
X	XtSetArg(args[n], XtNwidth,130);n++;
X	XtSetArg(args[n], XtNheight,40);n++;
X	XtSetArg(args[n], XtNshapeStyle,XmuShapeOval);n++;
X	
X	del=XtCreateManagedWidget("del", commandWidgetClass, perle, args, n);
X	trans_table = XtParseTranslationTable(del_str);
X	XtOverrideTranslations(del, trans_table);
X	
X	
X	if (ab>anz_text) ab=-9;
X	ab+=10; /* ab was initially -9 */
X	if (ab>anz_text) ab=1;
X
X	/* message_marker must point to the "ab"th text! */
X
X	message_marker=message_start;
X	for (i=2; i<=ab; i++) message_marker=message_marker->next;
X
X	for (i=ab; ( (i<=anz_text) && (i-ab<10) ); i++)
X	{
X		n=0;
X		XtSetArg(args[n],XtNorientation,XtorientHorizontal);n++;
X		XtSetArg(args[n],XtNborderWidth,0);n++;
X		kiste=XtCreateManagedWidget("drin", boxWidgetClass, perle, args, n);
X		n=0;
X		XtSetArg(args[n],XtNstate,False);n++;
X		XtSetArg(args[n],XtNheight,20);n++;
X		XtSetArg(args[n],XtNwidth,20);n++;
X		XtSetArg(args[n],XtNshapeStyle,XmuShapeOval);n++;
X		toggle=XtCreateManagedWidget("!", toggleWidgetClass, kiste, args, n);
X		n=0;
X		XtSetArg(args[n],XtNuseStringInPlace,True);n++;
X		XtSetArg(args[n],XtNstring,message_marker->text);n++;
X		XtSetArg(args[n],XtNwidth,500);n++;
X		if (lenn<1+strlen(message_marker->text)) lenn=1+strlen(message_marker->text);
X		XtSetArg(args[n],XtNlength,lenn);n++; 
X		/* warning, this is constant */
X	/* it is a fact, that each of these pointers point to a memory-location, which */
X	/* is at last exactly 80 Bytes big. */
X	/* Well, this is an arbitrary restriction */
X		XtSetArg(args[n],XtNeditType,XawtextEdit);n++;
X		
X		blabla=XtCreateManagedWidget("text", asciiTextWidgetClass, kiste, args, n);
X		XtAddActions(actions, XtNumber(actions));
X		trans_table2 = XtParseTranslationTable(temp_str2);
X		XtOverrideTranslations(blabla, trans_table2);
X
X		/* Store the pointers, used for a delete action */
X		mem[i-ab].tg=toggle;
X		mem[i-ab].obj=(struct fig5 *)message_marker;
X		mem[i-ab+1].tg=NULL;
X		mem[i-ab+1].obj=NULL;
X
X		message_marker=message_marker->next;
X		
X	}
X
X	XtAddActions(actions, XtNumber(actions));
X	
X	
X
X	/* setting position of widget */
X	n = 0;
X	XtSetArg(args[n], XtNx, &x_rel);
X	n++;
X	XtSetArg(args[n], XtNy, &y_rel);
X	n++;
X	XtGetValues(canvas, args, n);	/* get the relative coordinates of
X					 * widget: canvas */
X	XtTranslateCoords(canvas, x_rel, y_rel, &x, &y);
X	n = 0;
X	XtSetArg(args[n], XtNx, x + cmd_btn_width);
X	n++;
X	XtSetArg(args[n], XtNy, y + 2 * cmd_btn_height);
X	n++;
X	XtSetValues(muschel, args, n);
X	/* position set ! */
X
X
X	XtPopupSpringLoaded(muschel);
X
X	
}
X
void correct_text_error()
{
X
X	/* remove special chars from text */
X
X	message_marker=message_start;
X	if (message_marker==NULL) return;
X
X	while (message_marker!=NULL)
X	{
X		transform(message_marker->text);
X		message_marker=message_marker->next;
X	}
X	
X	ab=-9; /* for a new start */
X	
}
X		
void beende_textedit()	
{
X	XtPopdown(muschel);
X	XtDestroyWidget(muschel); /* and its children ! */
}	
X
X
X
void delete_textedit()
{
X	/* perform an erase on the selected (toggled) text */
X
X int i=0; /* counter */
X Boolean offon;
X struct fig5 * five;
X
X	while ( (mem[i].tg!=NULL) && (i<10) )
X	{
X		/* was the toggle active ? */
X		n=0;
X		XtSetArg(args[n],XtNstate,&offon);n++;
X		XtGetValues(mem[i].tg, args, n);
X
X		if (offon==True) /* it was selected - delete text ! */
X		{
X			message_marker = (struct fig5 *)mem[i].obj;
X			if (message_start == mem[i].obj)
X			{	/* first entry */
X				if (message_curr == message_start)
X				{	/* exactly 1 entry */
X
X					message_start = NULL;
X					message_curr = NULL;
X
X				} else
X					message_start = message_start->next;
X
X				free(message_marker);
X			} else
X			{
X				message_marker = message_start;
X				do
X				{
X					five = (struct fig5 *) message_marker;
X					/* remember the last object */
X					message_marker = message_marker->next;
X
X				} while (message_marker != mem[i].obj);
X				/* <message_marker> points to the desired object and */
X				/* <five> to the object before */
X
X				/* last entry ? */
X				if (message_marker == message_curr)
X				{
X					message_marker = NULL;
X					free(message_curr);
X					message_curr = five;
X					five->next=NULL;
X				} else
X					/* no! the object was somewhere in the middle */
X				{
X					five->next = message_marker->next;
X					free(message_marker);
X				}
X			} /* else */
X		
X
X			
X		} /* if offon */
X
X		i++;
X
X	} /* while */
} /* proc */
X
X
X	
int sorry_msg()
{
X int i=-1;
X
X	if (
X		(pfeil_start==NULL) &&
X		(strich_start==NULL) &&
X		(framedBox_start==NULL) &&
X		(dashedBox_start==NULL) &&
X		(filledBox_start==NULL) &&
X		(kreis_start==NULL) &&
X		(disc_start==NULL) &&
X		(bezier_start==NULL) &&
X		(oval_start==NULL)
X	   )
X		leave_pick("Sorry - No objects !\n");
X
X	else i=0;
X
X	return i;
X
}	
X
X
X
int fb_number_of_text()
{
X  int i;
X	/* compute number of text-entries */
X	i=1;
X	if (framedBox_start==NULL) return 0;
X	if (framedBox_start==framedBox_curr) return 1;
X	framedBox_marker=framedBox_start;
X	do
X	{
X		i++;
X		if (framedBox_marker!=framedBox_curr) framedBox_marker=framedBox_marker->next;
X	} while (framedBox_marker!=framedBox_curr);
X
X	return i;
}
X
X
X
void fb_textedit()
{
X  Widget perle;
X  Widget kiste,toggle,blabla;
X  Widget ok,del,more;
X  int i,lenn=81;
SHAR_EOF
true || echo 'restore of graphics.c failed'
fi
echo 'End of  part 4'
echo 'File graphics.c is continued in part 5'
echo 5 > _shar_seq_.tmp
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
