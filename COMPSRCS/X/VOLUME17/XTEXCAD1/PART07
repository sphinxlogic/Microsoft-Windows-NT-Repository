Newsgroups: comp.sources.x
Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: Fritz Haubensak <hsk@informatik.uni-wuerzburg.de>
Subject: v17i071: TeXcad (X) version 1.2, Part07/10
Message-ID: <1992Apr21.131401.2475@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Nntp-Posting-Host: fascet
Organization: Molecular Simulations, Inc.
References: <csx-17i065-xtexcad-1.2@uunet.UU.NET>
Date: Tue, 21 Apr 1992 13:14:01 GMT
Approved: dcmartin@msi.com
Lines: 2166

Submitted-by: Fritz Haubensak <hsk@informatik.uni-wuerzburg.de>
Posting-number: Volume 17, Issue 71
Archive-name: xtexcad-1.2/part07

# this is part.07 (part 7 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file oberfl.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 7; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping oberfl.c'
else
echo 'x - continuing file oberfl.c'
sed 's/^X//' << 'SHAR_EOF' >> 'oberfl.c' &&
X	XtSetArg(args[n], XtNwidth, 140);
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	XtSetArg(args[n], XtNstate, False);
X	n++;
X	
X	din = XtCreateManagedWidget("page", toggleWidgetClass, dummy1, args, n);
X	XtAddCallback(din, XtNcallback, full_dina4, NULL);
X
X	n = 0;
X
X	XtSetArg(args[n], XtNlabel, "enable ruler");
X	n++;
X	XtSetArg(args[n], XtNheight, 30);
X	n++;
X	XtSetArg(args[n], XtNwidth, 140);
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	XtSetArg(args[n], XtNstate, True);
X	n++;
X	
X	rul = XtCreateManagedWidget("lineal", toggleWidgetClass, dummy1, args, n);
X	XtAddCallback(rul, XtNcallback, ruler_switch, NULL);
X
X	n = 0;
X
X	XtSetArg(args[n], XtNlabel, "cross wire");
X	n++;
X	XtSetArg(args[n], XtNheight, 30);
X	n++;
X	XtSetArg(args[n], XtNwidth, 140);
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	XtSetArg(args[n], XtNstate, False);
X	n++;
X	
X	cross_curs = XtCreateManagedWidget("cross", toggleWidgetClass, dummy1, args, n);
X	XtAddCallback(cross_curs, XtNcallback, cross_switch, NULL);
X
X	n = 0;
X
X	XtSetArg(args[n], XtNlabel, "watch line length");
X	n++;
X	XtSetArg(args[n], XtNheight, 30);
X	n++;
X	XtSetArg(args[n], XtNwidth, 140);
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNshapeStyle, XmuShapeOval);
X	n++;
X	XtSetArg(args[n], XtNstate, False);
X	n++;
X	
X	length_line = XtCreateManagedWidget("llline", toggleWidgetClass, dummy1, args, n);
X	XtAddCallback(length_line, XtNcallback, l_length_switch, NULL);
X	line_length = 0;
X
X	/* add action to translation manager */
X	XtAddActions(actions, XtNumber(actions));
X	XtOverrideTranslations(radio_up, trans_table1);
X	XtOverrideTranslations(raster1, trans_table2);
X	XtOverrideTranslations(snap1, trans_table2);
X	XtOverrideTranslations(slp, trans_table2);
X	XtOverrideTranslations(dias, trans_table2);
X	XtOverrideTranslations(read_number, trans_table);
X
}
/*-----------------------------------------------------------*/
X
void
print_msg(Widget text_widget, char *msg)
{
X	/* prints messages into the welcome and report widget */
X
X	XawTextPosition text_pos;
X	int             result;
X	XawTextBlock    text_block;
X
X
X	/* get current position of Cursor */
X	text_pos = XawTextGetInsertionPoint(text_widget);
X
X
X	/* text_block init. */
X	text_block.firstPos = 0;
X	text_block.length = strlen(msg);
X	text_block.ptr = msg;
X	text_block.format = FMT8BIT;
X
X	XawTextReplace(text_widget, text_pos, text_pos, &text_block);
X
X	/* display text */
X	XawTextDisplay(text_widget);
}
SHAR_EOF
echo 'File oberfl.c is complete' &&
chmod 0644 oberfl.c ||
echo 'restore of oberfl.c failed'
Wc_c="`wc -c < 'oberfl.c'`"
test 37008 -eq "$Wc_c" ||
	echo 'oberfl.c: original size 37008, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= oberfl.h ==============
if test -f 'oberfl.h' -a X"$1" != X"-c"; then
	echo 'x - skipping oberfl.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting oberfl.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'oberfl.h' &&
/* xtexcad  V1.2 - graphic editor for LaTeX */
/* 1991 by K.Zitzmann */
/* header-file oberfl.h */
X
X
#ifndef OBERFLH
#define OBERFLH
X
X
X
/* prototypes */
X
X
void popup_init(void);
void paintboard(void);
void textup_init(void);
void print_msg(Widget w, char *msg); /* display message in textwidget */
void radio_init(void);
void command_init(void);
void headline(Widget w, char *txt);
X
X
X
/* constant */
X
X extern const Dimension cmd_btn_width;
X extern const Dimension cmd_btn_height;
X extern const vertical_distance,new_section;
X
X extern const yorigin;
X
X #define xorigin (cmd_btn_width+2*new_section)
X 
X extern const y_A4_max;
X extern const y_A4_min;
X extern const x_A4_max;
X extern const x_A4_min;
X
X 
/* global variables */ 
X
X extern Widget toplevel,canvas,pboard,textup,wtext,input_up,get_up,box_me_up;
X extern Widget line_cmd,box_cmd,circle_cmd,text_cmd,file_cmd;
X extern Widget vector_cmd,zoom_cmd,refresh_cmd,erase_cmd,edit_cmd,options_cmd;
X extern Widget snap1,raster1,radio_up,slp,dias;
X extern Widget txt2,txt3,raster_up,ask_up,sign_up,sign_msg;
X extern Widget coordinates,about,pop_adjust_up,adj_txt2,fileselector,bezier_cmd;
X extern Widget lft,rgt,up,dwn,zentr;
X
X extern Arg args[10]; 
X extern int n,m;
X
X extern Boolean snap, raster; /* radio-button-options */
X extern Boolean zoomed,steigung,durchmesser,refr_auto,dina4;
X extern Boolean ruler,cross;
X
X extern char graph_action,shadow; /* current action : 'L'=line etc. */
X
X extern char filename[100];
X extern char chain[100];
X extern char titlename[200];
X extern char boxinput[256];
X extern char textinput[256];
X 
X 
X extern char txtpos[3];
X extern float xur,yur;
X extern GC gc,copy_gc; /* Graphic Context ID */
X
X extern Pixmap about_map;
X 
X 
X 
X /* Figure Data Base */
X 
X extern struct fig1 {
X	float x,y,h,v;
X	struct fig1 *next;
X	} oval;
X
X extern struct fig2 {
X	float x,y,h,v;
X	struct fig2 *next;
X	int radius;
X	} filledBox,strich,pfeil,disc,kreis;
X
X extern struct fig3 {
X	float x,y,h,v;
X	char *text;
X	char textpos[2];
X	struct fig3 *next;
X	} framedBox;
X
X extern struct fig4 {
X	float x,y,h,v;
X	char *text;
X	char textpos[2];
X	float dashlength;
X	struct fig4 *next;
X	} dashedBox;
X
X extern struct fig5 {
X	float x,y;
X	char *text;
X	char textpos[2]; /* for the makebox-command */
X	struct fig5 *next;
X	} message;
X
X extern struct fig6 {
X 	float ax,ay; /* startpoint */
X 	float ex,ey; /* endpoint */
X 	float sx,sy; /* controlpoint */
X	struct fig6 *next;
X 	} bezier;
X
X /* box,oval: first coordinates must be the upper left corner */
X /* circle: x,y determine the middlepoint, h,v are useless after creating object */
X
X extern struct fig2 *disc_start, *disc_curr, *disc_marker;
X extern struct fig2 *kreis_start, *kreis_curr, *kreis_marker;
X extern struct fig2 *filledBox_start, *filledBox_curr, *filledBox_marker;
X extern struct fig1 *oval_start, *oval_curr, *oval_marker;
X extern struct fig2 *strich_start, *strich_curr, *strich_marker;
X extern struct fig2 *pfeil_start, *pfeil_curr, *pfeil_marker;
X extern struct fig3 *framedBox_start, *framedBox_curr, *framedBox_marker;
X extern struct fig4 *dashedBox_start, *dashedBox_curr, *dashedBox_marker;
X extern struct fig5 *message_start, *message_curr, *message_marker;
X extern struct fig6 *bezier_start, *bezier_curr, *bezier_marker;
X
X
X extern int x_zoom_max;
X extern int x_zoom_min;
X extern int y_zoom_max;
X extern int y_zoom_min;
X
X extern int xmotion;
X extern int ymotion;
X
X /* user data */
extern char	aa;
extern char	bb;
extern char	cc;
extern char	dd;
extern char	ee;
extern char	ff;
extern char	gg;
extern char	hh;
extern char	ii;
extern char	jj;
extern char	kk;
extern char	ll;
extern char	mm;
extern char	nn;
extern char	oo;
extern char	pp;
extern char	qq;
extern char	rr;
extern char	ss;
extern char	tt;
extern char	uu;
extern char	vv;
extern char	ww;
extern char	xx;
extern char	yy;
extern char	zz;
extern char     point;
extern char     DUMMY;
extern char	minus;
extern char	ka;
extern char	kb;
extern char	kc;
extern char	kd;
extern char	ke;
extern char	kf;
extern char	kg;
extern char	kh;
extern char	ki;
extern char	kj;
extern char	klein_k;
extern char	kl;
extern char	km;
extern char	kn;
extern char	ko;
extern char	kp;
extern char	kq;
extern char	kr;
extern char	ks;
extern char	kt;
extern char	ku;
extern char	kv;
extern char	kw;
extern char	kx;
extern char	ky;
extern char	kz;
X
#endif
SHAR_EOF
chmod 0644 oberfl.h ||
echo 'restore of oberfl.h failed'
Wc_c="`wc -c < 'oberfl.h'`"
test 4292 -eq "$Wc_c" ||
	echo 'oberfl.h: original size 4292, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= patchlevel.h ==============
if test -f 'patchlevel.h' -a X"$1" != X"-c"; then
	echo 'x - skipping patchlevel.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting patchlevel.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'patchlevel.h' &&
/* xtexcad  V1.2 - graphic editor for LaTeX */
/* 1991 by K.Zitzmann */
/* patchlevel.h */
X
#define PATCHLEVEL 0.0
X
SHAR_EOF
chmod 0644 patchlevel.h ||
echo 'restore of patchlevel.h failed'
Wc_c="`wc -c < 'patchlevel.h'`"
test 116 -eq "$Wc_c" ||
	echo 'patchlevel.h: original size 116, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= pickedit.c ==============
if test -f 'pickedit.c' -a X"$1" != X"-c"; then
	echo 'x - skipping pickedit.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting pickedit.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'pickedit.c' &&
/* xtexcad  V1.1 - graphic editor for LaTeX */
/* 1991 by K.Zitzmann */
/* pickedit.c */
X
#include "x_stuff.h"
#include "oberfl.h"
#include "ereignis.h"
#include "graphics.h"
#include "pickedit.h"
#include <math.h>
X
X
X
/* this data-structure contains the best matching objects which are */
/* found during a pick-action... */
X
#define sumobj 5
X
int             maxobj = 5;
X
char            kind[sumobj];	/* the object type: 'L'=line, 'V'=vector,
X				 * 'N'=framedBox etc */
int             distance[sumobj];	/* the distance to the selected point
X					 * on the screen */
void           *obj[sumobj];	/* pointer to the current element in kind[] */
int             tip;
X
int             x_pick, y_pick, currIndex;
/* currIndex is THE index which points ALWAYS to the current object */
X
int             points = 10;	/* radius for edit circle */
/* ----------------------------------- */
/*
X * interface to application is : set_pick_stack(x,y) and nextObject()  and
X * currIndex
X */
X
X
void
init_pick()
{
X	int             i;
X	for (i = 0; i <= maxobj; i++)
X	{
X		kind[i] = '-';
X		distance[i] = 9999;
X		obj[i] = NULL;
X	}
X
X	tip = 0;
X	currIndex = 0;
}
X
X
int
nextObject()
{
X	/* returns -1 if there is no object & otherwise the index */
X	/* of the object in the global data-stucture */
X
X	if (kind[tip] == '-')
X		return -1;	/* no object */
X
X	if (tip <= maxobj)
X		tip++;
X	else
X		return -1;
X
X	currIndex = tip - 1;
X
X	return currIndex;
}
X
X
X
void
set_pick_stack(int x, int y)
{
X	/* fills the stack with matching objects */
X	int             d, res;
X	float           h, v;
X	init_pick();
X
X	if (zoomed == True)
X	{
X		h = (float) x;
X		v = (float) y;
X		zoomed2real(&h, &v);
X		x = h;
X		y = v;
X	}
X	/* bezier */
X	if (bezier_start != NULL)
X	{	/* there is min. 1 entry */
X		bezier_marker = bezier_start;
X		res = analyse_bezier(bezier_marker, &d, x, y);
X		if (res == 1)
X			insert_object(bezier_marker, d, ii);
X
X		if (bezier_marker != bezier_curr)
X		{
X			do
X			{
X				bezier_marker = bezier_marker->next;
X				res = analyse_bezier(bezier_marker, &d, x, y);
X				if (res == 1)
X					insert_object(bezier_marker, d, ii);
X			} while (bezier_marker != bezier_curr);
X		}
X	}
X	/* line */
X	if (strich_start != NULL)
X	{	/* there is min. 1 entry */
X		strich_marker = strich_start;
X		res = analyse_pin(strich_marker, &d, x, y);
X		if (res == 1)
X			insert_object(strich_marker, d, ll);
X
X		if (strich_marker != strich_curr)
X		{
X			do
X			{
X				strich_marker = strich_marker->next;
X				res = analyse_pin(strich_marker, &d, x, y);
X				if (res == 1)
X					insert_object(strich_marker, d, ll);
X			} while (strich_marker != strich_curr);
X		}
X	}
X	/* vector */
X	if (pfeil_start != NULL)
X	{	/* there is min. 1 entry */
X		pfeil_marker = pfeil_start;
X		res = analyse_pin(pfeil_marker, &d, x, y);
X		if (res == 1)
X			insert_object(pfeil_marker, d, vv);
X
X		if (pfeil_marker != pfeil_curr)
X		{
X			do
X			{
X				pfeil_marker = pfeil_marker->next;
X				res = analyse_pin(pfeil_marker, &d, x, y);
X				if (res == 1)
X					insert_object(pfeil_marker, d, vv);
X			} while (pfeil_marker != pfeil_curr);
X		}
X	}
X	/* framedBox */
X	if (framedBox_start != NULL)
X	{	/* there is min. 1 entry */
X		framedBox_marker = framedBox_start;
X		res = analyse_nbox(framedBox_marker, &d, x, y);
X		if (res == 1)
X			insert_object(framedBox_marker, d, nn);
X
X		if (framedBox_marker != framedBox_curr)
X		{
X			do
X			{
X				framedBox_marker = framedBox_marker->next;
X				res = analyse_nbox(framedBox_marker, &d, x, y);
X				if (res == 1)
X					insert_object(framedBox_marker, d, nn);
X			} while (framedBox_marker != framedBox_curr);
X		}
X	}
X	/* dashedBox */
X	if (dashedBox_start != NULL)
X	{	/* there is min. 1 entry */
X		dashedBox_marker = dashedBox_start;
X		res = analyse_dbox(dashedBox_marker, &d, x, y);
X		if (res == 1)
X			insert_object(dashedBox_marker, d, dd);
X
X		if (dashedBox_marker != dashedBox_curr)
X		{
X			do
X			{
X				dashedBox_marker = dashedBox_marker->next;
X				res = analyse_dbox(dashedBox_marker, &d, x, y);
X				if (res == 1)
X					insert_object(dashedBox_marker, d, dd);
X			} while (dashedBox_marker != dashedBox_curr);
X		}
X	}
X	/* filledBox */
X	if (filledBox_start != NULL)
X	{	/* there is min. 1 entry */
X		filledBox_marker = filledBox_start;
X		res = analyse_fbox(filledBox_marker, &d, x, y);
X		if (res == 1)
X			insert_object(filledBox_marker, d, ff);
X
X
X
X		if (filledBox_marker != filledBox_curr)
X		{
X			do
X			{
X				filledBox_marker = filledBox_marker->next;
X				res = analyse_fbox(filledBox_marker, &d, x, y);
X				if (res == 1)
X					insert_object(filledBox_marker, d, ff);
X			} while (filledBox_marker != filledBox_curr);
X		}
X	}
X	/* normal circle */
X	if (kreis_start != NULL)
X	{	/* there is min. 1 entry */
X		kreis_marker = kreis_start;
X		res = analyse_ncircle(kreis_marker, &d, x, y);
X		if (res == 1)
X			insert_object(kreis_marker, d, cc);
X
X		if (kreis_marker != kreis_curr)
X		{
X			do
X			{
X				kreis_marker = kreis_marker->next;
X				res = analyse_ncircle(kreis_marker, &d, x, y);
X				if (res == 1)
X					insert_object(kreis_marker, d, cc);
X			} while (kreis_marker != kreis_curr);
X		}
X	}
X	/* filled circle */
X	if (disc_start != NULL)
X	{	/* there is min. 1 entry */
X		disc_marker = disc_start;
X		res = analyse_fcircle(disc_marker, &d, x, y);
X		if (res == 1)
X			insert_object(disc_marker, d, bb);
X
X		if (disc_marker != disc_curr)
X		{
X			do
X			{
X				disc_marker = disc_marker->next;
X				res = analyse_fcircle(disc_marker, &d, x, y);
X				if (res == 1)
X					insert_object(disc_marker, d, bb);
X			} while (disc_marker != disc_curr);
X		}
X	}
X	/* oval */
X	if (oval_start != NULL)
X	{	/* there is min. 1 entry */
X		oval_marker = oval_start;
X		res = analyse_ocircle(oval_marker, &d, x, y);
X		if (res == 1)
X			insert_object(oval_marker, d, oo);
X
X		if (oval_marker != oval_curr)
X		{
X			do
X			{
X				oval_marker = oval_marker->next;
X				res = analyse_ocircle(oval_marker, &d, x, y);
X				if (res == 1)
X					insert_object(oval_marker, d, oo);
X			} while (oval_marker != oval_curr);
X		}
X	}
}
X
X
void
insert_object(void *p, int d, char c)
{
X	int             i, k;
X	/*
X	 * operations performed on global data-structure :
X	 * 
X	 * 
X	/* compute insert-position
X	 */
X	for (i = 0; (distance[i] < d) && (i != maxobj); i++);
X
X	if (i == maxobj)
X		return;	/* the distance was too far; there are better objects */
X
X	/* move elements */
X	for (k = (maxobj - 1); k > i; k--)
X	{
X		kind[k] = kind[k - 1];
X		distance[k] = distance[k - 1];
X		obj[k] = obj[k - 1];
X	}
X
X	/* the new entry */
X	kind[i] = c;
X	distance[i] = d;
X	obj[i] = p;
X
X	/* fin */
X
}
X
X
/* function int analyse_xxxxxx() : */
/* returns wether the object is a possible pick(1) or not(0) */
/* p points to the object; d returns the distance to the object */
/* xpos,ypos reference the pick position of the pointer */
X
X
int analyse_bezier(struct fig6 *p, int *d, int xpos, int ypos)
{
X	int cmpdiff=9999;
X	int diff;
X	int x,y;
X	float u;
X	int zone=20;
X	
X	for (u=0; u<=1; u+=0.1)
X	{
X		x=(int)(p->ax*(1-u)*(1-u)+p->sx*(1-u)*2*u+p->ex*u*u);
X        	y=(int)(p->ay*(1-u)*(1-u)+p->sy*(1-u)*2*u+p->ey*u*u);
X
X		diff=calc_distance(x,y,xpos,ypos);
X		
X		cmpdiff=(cmpdiff<diff) ? cmpdiff : diff;
X	}
X
X	(*d)= cmpdiff;
X
X	return (cmpdiff<zone) ? 1 : 0;
}
X
X
X
X
int
analyse_pin(struct fig2 * p, int *d, int xpos, int ypos)
{
X	float           d1, d2;
X	float           x1, x2, y1, y2;
X	float           x, y, h, v;
X	float           zone;
X	double          alpha;
X
X
X	/* 1. test : bounding rectangle */
X
X	x = p->x;
X	y = p->y;
X	v = p->v;
X	h = p->h;
X
X	zone = 30.0;
X
X	norm_rectangle(&x, &y, &h, &v);
X	/* now, x,y is the upper left corner of the rectangle */
X
X
X
X	x = x - zone;
X	h = h + zone;
X	y = y - zone;
X	v = v + zone;
X
X
X	if ((xpos < (int) x) || (xpos > (int) h) || (ypos < (int) y) || (ypos > (int) v))
X		return 0;
X
X
X
X
X	/* 2. test : distance */
X
X	x = (p->x);
X	y = (p->y);
X
X	/* %%%%%%%%%%%%%%%%%%%%%  see documentation  %%%%%%%%%%%%%%%%%%%%% */
X
X	/* Vector 1 */
X	x1 = (float) xpos - x;
X	x2 = (float) ypos - y;
X
X	/* compute length of the above vector */
X
X	d1 = (float) sqrt((double) (x1 * x1 + x2 * x2));
X	/* --- */
X
X	/* Vector 2 */
X	y1 = (p->h) - x;
X	y2 = (p->v) - y;
X
X	d2 = (float) sqrt((double) (y1 * y1 + y2 * y2));
X	/* --- */
X
X
X	alpha = (double) ((x1 * y1 + x2 * y2) / (d1 * d2));
X
X	/* acos(x),-1<=x<=1 */
X	if (alpha < -1.0)
X		alpha = -1.0;
X	if (alpha > 1.0)
X		alpha = 1.0;
X
X
X	alpha = acos(alpha);
X
X
X	(*d) = (int) (d1 * (float) sin(alpha));
X
X
X	if ((*d) <= (int) zone)
X		return 1;
X	else
X		return 0;
X
}
X
X
X
int
analyse_nbox(struct fig3 * p, int *d, int xpos, int ypos)
{
X	/* normal box */
X	float           zone;
X	int             x, y, h, v;
X	int             dt, db, dr, dl;
X
X
X
X	zone = 20.0;
X
X	x = (int) ((p->x) - zone);
X	y = (int) ((p->y) - zone);
X	v = (int) ((p->v) + zone);
X	h = (int) ((p->h) + zone);
X
X	/* 1. test : bounding rectangle */
X
X	if ((xpos < x) || (xpos > h) || (ypos < y) || (ypos > v))
X		return 0;
X
X
X	/* 2. test : distance to a boundery */
X
X	dl = abs(xpos - (int) (p->x));
X	dr = abs(xpos - (int) (p->h));
X	dt = abs(ypos - (int) (p->y));
X	db = abs(ypos - (int) (p->v));
X
X	/* compute the minimum of dr,dl,dt,db and store it in d */
X
X	if (dr < dl)
X		dl = dr;	/* minimum in dl */
X	if (db < dt)
X		dt = db;	/* minimum in dt */
X
X	if (dt < dl)
X		(*d) = dt;
X	else
X		(*d) = dl;
X
X
X	if ((*d) <= (int) zone)
X		return 1;
X	else
X		return 0;
X
}
X
X
X
int
analyse_dbox(struct fig4 * p, int *d, int xpos, int ypos)
{
X	/* dashed box */
X	float           zone;
X	int             x, y, h, v;
X	int             dt, db, dr, dl;
X	zone = 20;
X
X	x = (int) ((p->x) - zone);
X	y = (int) ((p->y) - zone);
X	v = (int) ((p->v) + zone);
X	h = (int) ((p->h) + zone);
X
X	/* 1. test : bounding rectangle */
X
X	if ((xpos < x) || (xpos > h) || (ypos < y) || (ypos > v))
X		return 0;
X
X
X	/* 2. test : distance to a boundery */
X
X	dl = abs(xpos - (int) (p->x));
X	dr = abs(xpos - (int) (p->h));
X	dt = abs(ypos - (int) (p->y));
X	db = abs(ypos - (int) (p->v));
X
X	/* compute the minimum of dr,dl,dt,db and store it in d */
X
X	if (dr < dl)
X		dl = dr;	/* minimum in dl */
X	if (db < dt)
X		dt = db;	/* minimum in dt */
X
X	if (dt < dl)
X		(*d) = dt;
X	else
X		(*d) = dl;
X
X
X	if ((*d) <= (int) zone)
X		return 1;
X	else
X		return 0;
X
}
X
X
X
int
analyse_fbox(struct fig2 * p, int *d, int xpos, int ypos)
{
X	/* filled box */
X	int             x, y, h, v;
X	x = (int) (p->x);
X	y = (int) (p->y);
X	v = (int) (p->v);
X	h = (int) (p->h);
X
X	/* test : bounding rectangle */
X
X	if ((xpos < x) || (xpos > h) || (ypos < y) || (ypos > v))
X		return 0;
X
X	(*d) = 0;	/* optimal pick */
X
X	return 1;
X
}
X
X
int
analyse_ncircle(struct fig2 * p, int *d, int xpos, int ypos)
{
X	/* normal circle */
X	float           zone;
X	int             x, y, h, v;
X
X
X	zone = 20.0;
X
X	/* x,y is middlepoint/referencepoint */
X	x = (int) ((p->x) - zone) - (p->radius);
X	y = (int) ((p->y) - zone) - (p->radius);
X	v = (int) ((p->y) + zone) + (p->radius);
X	h = (int) ((p->x) + zone) + (p->radius);
X
X	/* now, x,y,h and v define the boundery-rectangle of the circle */
X
X	/* 1. test : bounding rectangle */
X
X	if ((xpos < x) || (xpos > h) || (ypos < y) || (ypos > v))
X		return 0;
X
X
X	/* 2. test : distance to a boundery (point on the circle-slice) */
X	/*
X	 * compute the difference between radius and the length from
X	 * (xpos,ypos) to
X	 */
X	/* the midlepoint */
X
X	x = xpos - (int) (p->x);
X	y = ypos - (int) (p->y);
X
X	(*d) = abs((p->radius) -
X		   (int) sqrt((double) ((float) x * (float) x + (float) y * (float) y)));
X
X	if ((*d) <= (int) zone)
X		return 1;
X	else
X		return 0;
}
X
X
X
int
analyse_ocircle(struct fig1 * p, int *d, int xpos, int ypos)
{
X	/* oval */
X	int             zone;
X	int             x, y, h, v;
X	int             dt, db, dr, dl;
X	zone = 20;
X
X	x = (int) (p->x) - zone;
X	y = (int) (p->y) - zone;
X	v = (int) (p->v) + zone;
X	h = (int) (p->h) + zone;
X
X	/* 1. test : bounding rectangle */
X
X	if ((xpos < x) || (xpos > h) || (ypos < y) || (ypos > v))
X		return 0;
X
X
X	/* 2. test : distance to a boundery */
X
X	dl = abs(xpos - (int) (p->x));
X	dr = abs(xpos - (int) (p->h));
X	dt = abs(ypos - (int) (p->y));
X	db = abs(ypos - (int) (p->v));
X
X
X
X	/* compute the minimum of dr,dl,dt,db and store it in d */
X
X	if (dr < dl)
X		dl = dr;	/* minimum in dl */
X	if (db < dt)
X		dt = db;	/* minimum in dt */
X
X	if (dt < dl)
X		(*d) = dt;
X	else
X		(*d) = dl;
X
X
X	if ((*d) <= zone)
X		return 1;
X	else
X		return 0;
X
}
X
X
X
int
analyse_fcircle(struct fig2 * p, int *d, int xpos, int ypos)
{
X	/* filled circle */
X	int             x, y, h;
X
X
X
X
X	/*
X	 * 1. test : the position of the selection point must be inside the
X	 * fille circle
X	 */
X	/*
X	 * compute the difference between radius and the length from
X	 * (xpos,ypos) to
X	 */
X	/* the midlepoint */
X
X	x = (xpos - (int) (p->x));
X	y = (ypos - (int) (p->y));
X
X	h = (int) sqrt((double) ((float) x * (float) x + (float) y * (float) y));	/* length of this vector */
X
X	if (h < (p->radius))
X		(*d) = 0;	/* the selection point is fully inside the
X				 * circle */
X	else
X		return 0;
X
X	return 1;
}
X
X
X
void
set_pick_object(void)
{
X	/* Override Translation Manager */
X	XtTranslations  trans_table;
X	char            destination[80] = "<Btn1Up>: manage_pick()";
X	static XtActionsRec actions[80] = {{"manage_pick", manage_pick}};
X	XtAddActions(actions, XtNumber(actions));
X	trans_table = XtParseTranslationTable(destination);
X	XtOverrideTranslations(pboard, trans_table);
}
X
X
void
set_copy_object(void)
{
X	/* Override Translation Manager */
X	XtTranslations  trans_table;
X	char            destination[80] = "<Btn1Down>: manage_copy()";
X	static XtActionsRec actions[80] = {{"manage_copy", manage_copy}};
X	XtAddActions(actions, XtNumber(actions));
X	trans_table = XtParseTranslationTable(destination);
X	XtOverrideTranslations(pboard, trans_table);
}
X
X
X
void
leave_pick(char *message)
{
X	Position        xx, yy, y_rel, x_rel;
X	n = 0;
X	XtSetArg(args[n], XtNx, &x_rel);
X	n++;
X	XtSetArg(args[n], XtNy, &y_rel);
X	n++;
X	XtGetValues(pboard, args, n);
X	XtTranslateCoords(canvas, x_rel, y_rel, &xx, &yy);
X	n = 0;
X	XtSetArg(args[n], XtNx, 175 + xx);
X	n++;
X	XtSetArg(args[n], XtNy, 295 + yy);
X	n++;
X
X	XtSetValues(sign_up, args, n);
X
X	n = 0;
X	XtSetArg(args[n], XtNlabel, message);
X	n++;
X	XtSetValues(sign_msg, args, n);
X	XtPopupSpringLoaded(sign_up);
}
X
X
void
manage_pick(void)
{
X
X
X	int             index;
X	unsigned int    mask;
X
X
X
X
X	PointerPosition(&x_pick, &y_pick, &mask);
X
X	XtUninstallTranslations(pboard);
X
X	set_pick_stack(x_pick, y_pick);	/* pick_stack is filled with matching
X					 * objects */
X
X	index = nextObject();
X
X	if (index == -1)
X	{	/* no objects found */
X		left();
X		leave_pick("No valid object found !");
X		return;
X	} else
X		pick_manager();
}
X
X
X
X
X
void
pick_manager()
{
X	int             btn1 = 256, btn2 = 512, btn3 = 1024;
X	int             index;
X	int             x, y, h, v;
X	unsigned int    mask, mask2;
X	Display        *disp = XtDisplay(pboard);
X	Window          win = XtWindow(pboard);
X	headline(toplevel, "Actions: Button 1 to EDIT ---- Button 2 to MOVE ---- Button 3 for MORE");
X
X	while (True)
X	{
X
X		prepare_top_stack_object();
X
X		do
X		{	/* watch for any buttonPress */
X			PointerPosition(&x, &y, &mask);
X			if ((x < x_A4_min) || (x > x_A4_max) || (y < y_A4_min) || (y > y_A4_max))
X			{
X				left();
X				prepare_top_stack_object();
X				return;
X			}
X			draw_coords(pboard, (caddr_t) x, (caddr_t) y);
X
X		} while (!((mask & btn3) || (mask & btn2) || (mask & btn1)));
X
X		do
X		{
X			PointerPosition(&h, &v, &mask2);
X		} while ((mask2 & btn3));
X
X
X		prepare_top_stack_object();
X
X		if (mask & btn1)
X			pick_edit();
X		else if (mask & btn2)
X			index = pick_move(x, y);
X		else
X		{	/* more */
X			index = nextObject();
X
X			if (index == -1)
X			{	/* no objects found */
X				left();
X				leave_pick("No valid object found !");
X				return;
X			}
X		}
X
X	}	/* while */
}
X
X
X
int
pick_move(int startx, int starty)
{
X	/* currIndex points to object-reference in global database */
X
X	struct fig1    *one;
X	struct fig2    *two;
X	struct fig3    *three;
X	struct fig4    *four;
X	struct fig6    *six;	
X	int             x, y, h, v, oldh, oldv;
X	unsigned int    mask;
X	Display        *disp = XtDisplay(pboard);
X	Window          win = XtWindow(pboard);
X	int             btn1 = 256, btn2 = 512, btn3 = 1024;
X	float           ax, bx, ay, by, sx, sy;
X	int             rad;
X	float           zoomx, zoomy, zoomh, zoomv, zoomsx, zoomsy;
X	Boolean         redraw;
X	int             snapx, snapy;
X
X
X	by = -999.0;
X	oldh = -999;
X	oldv = oldh;
X
X
X	do
X	{
X		PointerPosition(&x, &y, &mask);
X
X		draw_coords(pboard, (caddr_t) x, (caddr_t) y);
X
X		switch (kind[currIndex])
X		{
X		case 'I':
X			six = (struct fig6 *) obj[currIndex];
X			h = x - startx;
X			v = y - starty;
X			if ((oldh != h) || (oldv != v))
X			{
X				oldh = h;
X				oldv = v;
X				zoomx = six->ax;
X				zoomy = six->ay;
X				zoomh = six->ex;
X				zoomv = six->ey;
X				zoomsx = six->sx;
X				zoomsy = six->sy;
X				
X				if (zoomed == True) real2zoomed(&zoomsx, &zoomsy);
X				
X				/* delete old line */
X				if (by == -999.0)
X					DrawBezier(zoomx, zoomy, zoomh, zoomv, zoomsx, zoomsy);
X				else
X					DrawBezier(ax, ay, bx, by, sx, sy);
X					
X				if (zoomed == True) 
X				{
X					real2zoomed(&zoomx, &zoomy);
X					real2zoomed(&zoomh, &zoomv);
X				}
X				ax = zoomx + (float) h;
X				ay = zoomy + (float) v;
X				bx = zoomh + (float) h;
X				by = zoomv + (float) v;
X				sx = zoomsx + (float) h;
X				sy = zoomsy + (float) v;
X
X				if ((snap == True) && (raster == True))
X				{
X					snapx = (int) ax;
X					snapy = (int) ay;
X					valid_snap_coords(&snapx, &snapy);
X					bx -= (ax - (float) snapx);
X					by -= (ay - (float) snapy);
X					sx -= (ax - (float) snapx);
X					sy -= (ay - (float) snapy);
X					ax = (float) snapx;
X					ay = (float) snapy;
X				}
X				/* draw new line */
X				
X				if (zoomed==True)
X				{
X					zoomed2real(&ax,&ay);
X					zoomed2real(&bx,&by);
X				}
X				
X				DrawBezier(ax, ay, bx, by, sx, sy);
X			}
X			break;
X
X		case 'L':
X			two = (struct fig2 *) obj[currIndex];
X			h = x - startx;
X			v = y - starty;
X			if ((oldh != h) || (oldv != v))
X			{
X				oldh = h;
X				oldv = v;
X				zoomx = two->x;
X				zoomy = two->y;
X				zoomh = two->h;
X				zoomv = two->v;
X				if (zoomed == True)
X				{
X					real2zoomed(&zoomx, &zoomy);
X					real2zoomed(&zoomh, &zoomv);
X				}
X				/* delete old line */
X				if (by == -999.0)
X					XDrawLine(disp, win, gc, (int) zoomx, (int) zoomy,
X						  (int) zoomh, (int) zoomv);
X				else
X					XDrawLine(disp, win, gc, (int) ax, (int) ay,
X						  (int) bx, (int) by);
X				ax = zoomx + (float) h;
X				ay = zoomy + (float) v;
X				bx = zoomh + (float) h;
X				by = zoomv + (float) v;
X
X				if ((snap == True) && (raster == True))
X				{
X					snapx = (int) ax;
X					snapy = (int) ay;
X					valid_snap_coords(&snapx, &snapy);
X					bx -= (ax - (float) snapx);
X					by -= (ay - (float) snapy);
X					ax = (float) snapx;
X					ay = (float) snapy;
X				}
X				/* draw new line */
X				XDrawLine(disp, win, gc, (int) ax, (int) ay, (int) bx, (int) by);
X			}
X			break;
X
X		case 'V':
X			h = x - startx;
X			v = y - starty;
X			if ((oldh != h) || (oldv != v))
X			{
X				oldh = h;
X				oldv = v;
X				two = (struct fig2 *) obj[currIndex];
X				zoomx = two->x;
X				zoomy = two->y;
X				zoomh = two->h;
X				zoomv = two->v;
X				if (zoomed == True)
X				{
X					real2zoomed(&zoomx, &zoomy);
X					real2zoomed(&zoomh, &zoomv);
X				}
X				if (by == -999.0)
X				{
X					XDrawLine(disp, win, gc, (int) zoomx, (int) zoomy,
X						  (int) zoomh, (int) zoomv);
X					draw_vector_marker(zoomx, zoomy, zoomh, zoomv);
X				} else
X				{
X					XDrawLine(disp, win, gc, (int) ax, (int) ay, (int) bx, (int) by);
X					draw_vector_marker(ax, ay, bx, by);
X				}
X				ax = zoomx + (float) h;
X				ay = zoomy + (float) v;
X				bx = zoomh + (float) h;
X				by = zoomv + (float) v;
X
X				if ((snap == True) && (raster == True))
X				{
X					snapx = (int) ax;
X					snapy = (int) ay;
X					valid_snap_coords(&snapx, &snapy);
X					bx -= (ax - (float) snapx);
X					by -= (ay - (float) snapy);
X					ax = (float) snapx;
X					ay = (float) snapy;
X				}
X				XDrawLine(disp, win, gc, (int) ax, (int) ay, (int) bx, (int) by);
X				draw_vector_marker(ax, ay, bx, by);
X			}
X			break;
X
X		case 'N':
X			h = x - startx;
X			v = y - starty;
X			if ((oldh != h) || (oldv != v))
X			{
X				oldh = h;
X				oldv = v;
X				three = (struct fig3 *) obj[currIndex];
X				zoomx = three->x;
X				zoomy = three->y;
X				zoomh = three->h;
X				zoomv = three->v;
X				if (zoomed == True)
X				{
X					real2zoomed(&zoomx, &zoomy);
X					real2zoomed(&zoomh, &zoomv);
X				}
X				if (by == -999.0)
X				{
X					XDrawRectangle(disp, win, gc, (int) zoomx, (int) zoomy,
X					     (unsigned int) (zoomh - zoomx),
X					    (unsigned int) (zoomv - zoomy));
X					print_box_text(three->textpos, zoomx, zoomy, zoomh, zoomv, three->text);
X				} else
X				{
X					XDrawRectangle(disp, win, gc, ax, ay,
X						   (unsigned int) (bx - ax),
X						  (unsigned int) (by - ay));
X					XDrawLine(disp, win, gc, (int) ax, (int) ay, (int) bx, (int) by);
X					XDrawLine(disp, win, gc, (int) ax, (int) by, (int) bx, (int) ay);
X				}
X				ax = zoomx + (float) h;
X				ay = zoomy + (float) v;
X				bx = zoomh + (float) h;
X				by = zoomv + (float) v;
X
X				if ((snap == True) && (raster == True))
X				{
X					snapx = (int) ax;
X					snapy = (int) ay;
X					valid_snap_coords(&snapx, &snapy);
X					bx -= (ax - (float) snapx);
X					by -= (ay - (float) snapy);
X					ax = (float) snapx;
X					ay = (float) snapy;
X				}
X				XDrawRectangle(disp, win, gc, ax, ay,
X					       (unsigned int) (bx - ax),
X					       (unsigned int) (by - ay));
X				XDrawLine(disp, win, gc, (int) ax, (int) ay, (int) bx, (int) by);
X				XDrawLine(disp, win, gc, (int) ax, (int) by, (int) bx, (int) ay);
X			}
X			break;
X
X		case 'D':
X			h = x - startx;
X			v = y - starty;
X			if ((h != oldh) || (v != oldv))
X			{
X				oldh = h;
X				oldv = v;
X				four = (struct fig4 *) obj[currIndex];
X				zoomx = four->x;
X				zoomy = four->y;
X				zoomh = four->h;
X				zoomv = four->v;
X				XSetLineAttributes(disp, gc, 0, LineOnOffDash, CapButt, JoinMiter);
X				if (zoomed == True)
X				{
X					real2zoomed(&zoomx, &zoomy);
X					real2zoomed(&zoomh, &zoomv);
X				}
X				if (by == -999.0)
X				{
X					XDrawRectangle(disp, win, gc, (int) zoomx, (int) zoomy,
X					     (unsigned int) (zoomh - zoomx),
X					    (unsigned int) (zoomv - zoomy));
X					print_box_text(four->textpos, zoomx, zoomy, zoomh, zoomv, four->text);
X				} else
X				{
X					XDrawRectangle(disp, win, gc, (int) ax, (int) ay,
X						   (unsigned int) (bx - ax),
X						  (unsigned int) (by - ay));
X					XDrawLine(disp, win, gc, (int) ax, (int) ay, (int) bx, (int) by);
X					XDrawLine(disp, win, gc, (int) ax, (int) by, (int) bx, (int) ay);
X				}
X				ax = zoomx + (float) h;
X				ay = zoomy + (float) v;
X				bx = zoomh + (float) h;
X				by = zoomv + (float) v;
X
X				if ((snap == True) && (raster == True))
X				{
X					snapx = (int) ax;
X					snapy = (int) ay;
X					valid_snap_coords(&snapx, &snapy);
X					bx -= (ax - (float) snapx);
X					by -= (ay - (float) snapy);
X					ax = (float) snapx;
X					ay = (float) snapy;
X				}
X				XDrawRectangle(disp, win, gc, (int) ax, (int) ay,
X					       (unsigned int) (bx - ax),
X					       (unsigned int) (by - ay));
X				XDrawLine(disp, win, gc, (int) ax, (int) ay, (int) bx, (int) by);
X				XDrawLine(disp, win, gc, (int) ax, (int) by, (int) bx, (int) ay);
X				XSetLineAttributes(disp, gc, 0, LineSolid, CapButt, JoinMiter);
X			}
X			break;
X
X		case 'F':
X			h = x - startx;
X			v = y - starty;
X			if ((oldh != h) || (oldv != v))
X			{
X				oldh = h;
X				oldv = v;
X				two = (struct fig2 *) obj[currIndex];
X				zoomx = two->x;
X				zoomy = two->y;
X				zoomh = two->h;
X				zoomv = two->v;
X				if (zoomed == True)
X				{
X					real2zoomed(&zoomx, &zoomy);
X					real2zoomed(&zoomh, &zoomv);
X				}
X				if (by == -999.0)
X				{
X					XFillRectangle(disp, win, gc, (int) zoomx, (int) zoomy,
X					     (unsigned int) (zoomh - zoomx),
X					    (unsigned int) (zoomv - zoomy));
X				} else
X				{
X					XDrawRectangle(disp, win, gc, (int) ax, (int) ay,
X						   (unsigned int) (bx - ax),
X						  (unsigned int) (by - ay));
X					XDrawLine(disp, win, gc, (int) ax, (int) ay, (int) bx, (int) by);
X					XDrawLine(disp, win, gc, (int) ax, (int) by, (int) bx, (int) ay);
X				}
X				ax = zoomx + (float) h;
X				ay = zoomy + (float) v;
X				bx = zoomh + (float) h;
X				by = zoomv + (float) v;
X
X				if ((snap == True) && (raster == True))
X				{
X					snapx = (int) ax;
X					snapy = (int) ay;
X					valid_snap_coords(&snapx, &snapy);
X					bx -= (ax - (float) snapx);
X					by -= (ay - (float) snapy);
X					ax = (float) snapx;
X					ay = (float) snapy;
X				}
X				XDrawRectangle(disp, win, gc, (int) ax, (int) ay,
X					       (unsigned int) (bx - ax),
X					       (unsigned int) (by - ay));
X				XDrawLine(disp, win, gc, (int) ax, (int) ay, (int) bx, (int) by);
X				XDrawLine(disp, win, gc, (int) ax, (int) by, (int) bx, (int) ay);
X			}
X			break;
X
X		case 'C':
X			h = x - startx;
X			v = y - starty;
X			if ((oldh != h) || (oldv != v))
X			{
X				oldh = h;
X				oldv = v;
X				two = (struct fig2 *) obj[currIndex];
X				zoomx = two->x;
X				zoomy = two->y;
X				rad = two->radius;
X				if (zoomed == True)
X				{
X					real2zoomed(&zoomx, &zoomy);
X					real2zoomed(&zoomh, &zoomv);
X					rad *= 10;
X				}
X				if (by == -999.0)
X				{
X					XDrawArc(disp, win, gc, (int) zoomx - rad,
X						 (int) zoomy - rad,
X						 (unsigned int) (rad + rad),
X						 (unsigned int) (rad + rad), 0, 64 * 360);
X					by = 0;
X				} else
X				{
X					XDrawArc(disp, win, gc, (int) (ax - (float) rad),
X						 (int) (ay - (float) rad),
X						 (unsigned int) (rad + rad),
X						 (unsigned int) (rad + rad), 0, 64 * 360);
X					XDrawLine(disp, win, gc, ax, ay - rad, ax, ay + rad);
X					XDrawLine(disp, win, gc, ax - rad, ay, ax + rad, ay);
X				}
X				ax = zoomx + (float) h;
X				ay = zoomy + (float) v;
X
X				if ((snap == True) && (raster == True))
X				{
X					snapx = (int) ax;
X					snapy = (int) ay;
X					valid_snap_coords(&snapx, &snapy);
X					ax = (float) snapx;
X					ay = (float) snapy;
X				}
X				XDrawArc(disp, win, gc, (int) (ax - (float) rad),
X					 (int) (ay - (float) rad),
X					 (unsigned int) (rad + rad),
X				   (unsigned int) (rad + rad), 0, 64 * 360);
X				XDrawLine(disp, win, gc, (int) ax, (int) ay - rad, (int) ax, (int) ay + rad);
X				XDrawLine(disp, win, gc, (int) ax - rad, (int) ay, (int) ax + rad, (int) ay);
X			}
X			break;
X
X		case 'B':
X			h = x - startx;
X			v = y - starty;
X			if ((oldh != h) || (oldv != v))
X			{
X				oldh = h;
X				oldv = v;
X				two = (struct fig2 *) obj[currIndex];
X				zoomx = two->x;
X				zoomy = two->y;
X				rad = two->radius;
X				if (zoomed == True)
X				{
X					real2zoomed(&zoomx, &zoomy);
X					real2zoomed(&zoomh, &zoomv);
X					rad *= 10;
X				}
X				if (by == -999.0)
X				{
X					XFillArc(disp, win, gc, (int) zoomx - rad, (int) zoomy - rad,
X						 (unsigned int) (rad + rad),
X						 (unsigned int) (rad + rad), 0, 64 * 360);
X					by = 0;
X				} else
X				{
X					XDrawArc(disp, win, gc, (int) (ax - (float) rad),
X						 (int) (ay - (float) rad),
X						 (unsigned int) (rad + rad),
X						 (unsigned int) (rad + rad), 0, 64 * 360);
X					XDrawLine(disp, win, gc, (int) ax, (int) ay - rad, (int) ax, (int) ay + rad);
X					XDrawLine(disp, win, gc, (int) ax - rad, (int) ay, (int) ax + rad, (int) ay);
X				}
X				ax = zoomx + (float) h;
X				ay = zoomy + (float) v;
X
X				if ((snap == True) && (raster == True))
X				{
X					snapx = (int) ax;
X					snapy = (int) ay;
X					valid_snap_coords(&snapx, &snapy);
X					ax = (float) snapx;
X					ay = (float) snapy;
X				}
X				XDrawArc(disp, win, gc, (int) (ax - (float) rad),
X					 (int) (ay - (float) rad),
X					 (unsigned int) (rad + rad),
X				   (unsigned int) (rad + rad), 0, 64 * 360);
X				XDrawLine(disp, win, gc, (int) ax, (int) ay - rad, (int) ax, (int) ay + rad);
X				XDrawLine(disp, win, gc, (int) ax - rad, (int) ay, (int) ax + rad, (int) ay);
X			}
X			break;
X
X		case 'O':
X			h = x - startx;
X			v = y - starty;
X			if ((oldh != h) || (oldv != v))
X			{
X				oldh = h;
X				oldv = v;
X				one = (struct fig1 *) obj[currIndex];
X				zoomx = one->x;
X				zoomy = one->y;
X				zoomh = one->h;
X				zoomv = one->v;
X				if (zoomed == True)
X				{
X					real2zoomed(&zoomx, &zoomy);
X					real2zoomed(&zoomh, &zoomv);
X				}
X				if (by == -999.0)
X					DrawOval((int) zoomx, (int) zoomy, (int) zoomh, (int) zoomv);
X				else
X				{
X					DrawOval((int) ax, (int) ay, (int) bx, (int) by);
X					XDrawLine(disp, win, gc, (int) (ax + (bx - ax) / 2), (int) ay, (int) (ax + (bx - ax) / 2), by);
X					XDrawLine(disp, win, gc, (int) ax, (int) (ay + (by - ay) / 2), (int) bx, (int) (ay + (by - ay) / 2));
X				}
X				ax = zoomx + (float) h;
X				ay = zoomy + (float) v;
X				bx = zoomh + (float) h;
X				by = zoomv + (float) v;
X
X				if ((snap == True) && (raster == True))
X				{
X					snapx = (int) ax;
X					snapy = (int) ay;
X					valid_snap_coords(&snapx, &snapy);
X					bx -= (ax - (float) snapx);
X					by -= (ay - (float) snapy);
X					ax = (float) snapx;
X					ay = (float) snapy;
X				}
X				DrawOval((int) ax, (int) ay, (int) bx, (int) by);
X				XDrawLine(disp, win, gc, (int) (ax + (bx - ax) / 2), (int) ay, (int) (ax + (bx - ax) / 2), by);
X				XDrawLine(disp, win, gc, (int) ax, (int) (ay + (by - ay) / 2), (int) bx, (int) (ay + (by - ay) / 2));
X			}
X			break;
X
X		default:
X			break;
X
X		}	/* switch */
X	} while ((mask & btn2));	/* || ( (graph_action=='Y') && (mask & btn1) ) ); */
X
X
X	if ((x < x_A4_min) || (x > x_A4_max) || (y < y_A4_min) || (y > y_A4_max))
X	{	/* cancel */
X		if ((refr_auto == True) && (graph_action != 'Y'))
X			refresh(pboard, '?', (caddr_t)DUMMY);
X		return -1;
X	}
X	/* store the new position of the object */
X
X	switch (kind[currIndex])
X	{
X	case 'I':
X		six = (struct fig6 *) obj[currIndex];
X		if (zoomed == True) zoomed2real(&sx, &sy);
X		six->ax = ax;
X		six->ay = ay;
X		six->ex = bx;
X		six->ey = by;
X		six->sx = sx;
X		six->sy = sy;
X		break;
X
X	case 'L':
X		two = (struct fig2 *) obj[currIndex];
X		if (zoomed == True)
X		{
X			zoomed2real(&ax, &ay);
X			zoomed2real(&bx, &by);
X		}
X		two->x = ax;
X		two->y = ay;
X		two->h = bx;
X		two->v = by;
X		break;
X
X	case 'V':
X		two = (struct fig2 *) obj[currIndex];
X		if (zoomed == True)
X		{
X			zoomed2real(&ax, &ay);
X			zoomed2real(&bx, &by);
X		}
X		two->x = ax;
X		two->y = ay;
X		two->h = bx;
X		two->v = by;
X		break;
X
X
X	case 'N':
X		three = (struct fig3 *) obj[currIndex];
X		XDrawLine(disp, win, gc, (int) ax, (int) ay, (int) bx, (int) by);
X		XDrawLine(disp, win, gc, (int) ax, (int) by, (int) bx, (int) ay);
X		zoomx = ax;
X		zoomy = ay;
X		zoomh = bx;
X		zoomv = by;
X		if (zoomed == True)
X		{
X			zoomed2real(&zoomx, &zoomy);
X			zoomed2real(&zoomh, &zoomv);
X		}
X		three->x = zoomx;
X		three->y = zoomy;
X		three->h = zoomh;
X		three->v = zoomv;
X		print_box_text(three->textpos, zoomx, zoomy, zoomh, zoomv, three->text);
X		break;
X
X	case 'D':
X		four = (struct fig4 *) obj[currIndex];
X		XSetLineAttributes(disp, gc, 0, LineOnOffDash, CapButt, JoinMiter);
X		XDrawLine(disp, win, gc, (int) ax, (int) ay, (int) bx, (int) by);
X		XDrawLine(disp, win, gc, (int) ax, (int) by, (int) bx, (int) ay);
X		XSetLineAttributes(disp, gc, 0, LineSolid, CapButt, JoinMiter);
X		zoomx = ax;
X		zoomy = ay;
X		zoomh = bx;
X		zoomv = by;
X		if (zoomed == True)
X		{
X			zoomed2real(&zoomx, &zoomy);
X			zoomed2real(&zoomh, &zoomv);
X		}
X		four->x = zoomx;
X		four->y = zoomy;
X		four->h = zoomh;
X		four->v = zoomv;
X		print_box_text(four->textpos, zoomx, zoomy, zoomh, zoomv, four->text);
X		break;
X
X	case 'F':
X		two = (struct fig2 *) obj[currIndex];
X		XDrawLine(disp, win, gc, (int) ax, (int) ay, (int) bx, (int) by);
X		XDrawLine(disp, win, gc, (int) ax, (int) by, (int) bx, (int) ay);
X		XDrawRectangle(disp, win, gc, (int) ax, (int) ay,
X			       (unsigned int) (bx - ax),
X			       (unsigned int) (by - ay));
X		XFillRectangle(disp, win, gc, (int) ax, (int) ay,
X			       (unsigned int) (bx - ax),
X			       (unsigned int) (by - ay));
X		zoomx = ax;
X		zoomy = ay;
X		zoomh = bx;
X		zoomv = by;
X		if (zoomed == True)
X		{
X			zoomed2real(&zoomx, &zoomy);
X			zoomed2real(&zoomh, &zoomv);
X		}
X		two->x = zoomx;
X		two->y = zoomy;
X		two->h = zoomh;
X		two->v = zoomv;
X		break;
X
X	case 'C':
X		two = (struct fig2 *) obj[currIndex];
X		XDrawLine(disp, win, gc, (int) ax - rad, (int) ay, (int) ax + rad, (int) ay);
X		XDrawLine(disp, win, gc, (int) ax, (int) ay - rad, (int) ax, (int) ay + rad);
X		zoomx = ax;
X		zoomy = ay;
X		if (zoomed == True)
X		{
X			zoomed2real(&zoomx, &zoomy);
X			zoomed2real(&zoomh, &zoomv);
X		}
X		two->x = zoomx;
X		two->y = zoomy;
X		break;
X
X	case 'B':
X		two = (struct fig2 *) obj[currIndex];
X		XDrawLine(disp, win, gc, (int) ax - rad, (int) ay, (int) ax + rad, (int) ay);
X		XDrawLine(disp, win, gc, (int) ax, (int) ay - rad, (int) ax, (int) ay + rad);
X		XDrawArc(disp, win, gc, (int) ax - rad, (int) ay - rad,
X			 (unsigned int) (rad + rad),
X			 (unsigned int) (rad + rad), 0, 64 * 360);
X		XFillArc(disp, win, gc, (int) ax - rad, (int) ay - rad,
X			 (unsigned int) (rad + rad),
X			 (unsigned int) (rad + rad), 0, 64 * 360);
X		zoomx = ax;
X		zoomy = ay;
X		if (zoomed == True)
X		{
X			zoomed2real(&zoomx, &zoomy);
X			zoomed2real(&zoomh, &zoomv);
X		}
X		two->x = zoomx;
X		two->y = zoomy;
X		break;
X
X	case 'O':
X		one = (struct fig1 *) obj[currIndex];
X		XDrawLine(disp, win, gc, (int) (ax + (bx - ax) / 2), (int) ay,
X			  (int) (ax + (bx - ax) / 2), (int) by);
X		XDrawLine(disp, win, gc, (int) ax, (int) (ay + (by - ay) / 2),
X			  (int) bx, (int) (ay + (by - ay) / 2));
X		zoomx = ax;
X		zoomy = ay;
X		zoomh = bx;
X		zoomv = by;
X		if (zoomed == True)
X		{
X			zoomed2real(&zoomx, &zoomy);
X			zoomed2real(&zoomh, &zoomv);
X		}
X		one->x = zoomx;
X		one->y = zoomy;
X		one->h = zoomh;
X		one->v = zoomv;
X		break;
X
X
X	default:
X		break;
X
X	}	/* switch */
X
X
X
X
X	if (refr_auto == True)
X		refresh(pboard, '?', (caddr_t)DUMMY);
X
X	return 0;
X
X
}
X
X
void
pick_edit()
{
X	/* currIndex points to object-reference in global database */
X	/* button 1 is pressed */
X
X	struct fig1    *one;
X	struct fig2    *two;
X	struct fig3    *three;
X	struct fig4    *four;
X	struct fig6    *six;
X	int             x, y, dist1, dist2, dist3, dist4, low_val;
X	unsigned int    mask;
X	double          vec_x, vec_y, vec_h, vec_v;
X	int             res1, res2;
X	float           h_pos, v_pos, x_pos, y_pos;
X	float           h, v;
X
X
X
X
X
X	PointerPosition(&x, &y, &mask);
X
X
X	if (zoomed == True)
X	{
X		h = (float) x;
X		v = (float) y;
X		zoomed2real(&h, &v);
X		x = (int) h;
X		y = (int) v;
X	}
X	switch (kind[currIndex])
X	{
X	case 'I':	/* which point ? */
X		six = (struct fig6 *) obj[currIndex];
X		dist1 = calc_distance(x, y, (int) six->ax, (int) six->ay);	/* ax,ay */
X		dist2 = calc_distance(x, y, (int) six->ex, (int) six->ey);	/* ex,ey */
X		dist3 = calc_distance(x, y, (int) six->sx, (int) six->sy);	/* sx,sy */
X		if (zoomed == True)
X		{
X			dist1 *= 10;
X			dist2 *= 10;
X			dist3 *= 10;
X		}
X		/* compute minimum */
X		low_val=(dist1<dist2) ? dist1 : dist2;
X		low_val=(low_val<dist3) ? low_val : dist3;
X		if (low_val<=points)
X		{ /* buttonpress was inside of circle */
X		if (low_val==dist1) edit_bezier_curveA();
X			else if (low_val==dist2) edit_bezier_curveE();
X			else edit_bezier_curveS();	
X
X			if (refr_auto == True)
X				refresh(pboard, '?', (caddr_t)DUMMY);	/* wipe screen */
X		}	/* if low_val<=points */
X		break;
X
X	case 'L':	/* edit which endpoint ? */
X		two = (struct fig2 *) obj[currIndex];
X		vec_x = (double) two->x - (double) x;
X		vec_y = (double) two->y - (double) y;
X		vec_h = (double) two->h - (double) x;
X		vec_v = (double) two->v - (double) y;
X		res1 = abs((int) sqrt(vec_x * vec_x + vec_y * vec_y));
X		res2 = abs((int) sqrt(vec_h * vec_h + vec_v * vec_v));
X		if (zoomed == True)
X		{
X			res1 = res1 * 10;
X			res2 = res2 * 10;
X		}
X		if ((res1 <= points) || (res2 <= points))
X		{
X			if (res1 < res2)
X			{
X				edit_x_line();
X				if (refr_auto == True)
X					refresh(pboard, '?', (caddr_t)DUMMY);	/* wipe screen */
X			} else
X			{
X				edit_y_line();
X				if (refr_auto == True)
X					refresh(pboard, '?', (caddr_t)DUMMY);	/* wipe screen */
X			}
X		}
X		break;
X
X	case 'V':	/* edit which endpoint ? */
X		two = (struct fig2 *) obj[currIndex];
X		vec_x = (double) two->x - (double) x;
X		vec_y = (double) two->y - (double) y;
X		vec_h = (double) two->h - (double) x;
X		vec_v = (double) two->v - (double) y;
X		res1 = abs((int) sqrt(vec_x * vec_x + vec_y * vec_y));
X		res2 = abs((int) sqrt(vec_h * vec_h + vec_v * vec_v));
X		if (zoomed == True)
X		{
X			res1 = res1 * 10;
X			res2 = res2 * 10;
X		}
X		if ((res1 <= points) || (res2 <= points))
X		{
X			if (res1 < res2)
X				edit_x_vector();
X			else
X				edit_y_vector();
X		}
X		break;
X
X	case 'N':	/* which point ? */
X		three = (struct fig3 *) obj[currIndex];
X		dist1 = calc_distance(x, y, (int) three->x, (int) three->y);	/* upper left */
X		dist2 = calc_distance(x, y, (int) three->h, (int) three->v);	/* lower right */
X		dist3 = calc_distance(x, y, (int) three->h, (int) three->y);	/* upper right */
X		dist4 = calc_distance(x, y, (int) three->x, (int) three->v);	/* lower left */
X		if (zoomed == True)
X		{
X			dist1 *= 10;
X			dist2 *= 10;
X			dist3 *= 10;
X			dist4 *= 10;
X		}
X		/* compute minimum */
X		if (dist1 < dist2)
X			low_val = dist1;
X		else
X			low_val = dist2;
X		if (dist3 < low_val)
X			low_val = dist3;
X		if (dist4 < low_val)
X			low_val = dist4;
X		if (low_val <= points)
X		{
X			x_pos = three->x;
X			y_pos = three->y;
X			h_pos = three->h;
X			v_pos = three->v;
X			if (low_val == dist1)
X			{
X				three->x = h_pos;
X				three->y = v_pos;
X				three->h = x_pos;
X				three->v = y_pos;
X				/*
X				 * now, coordinates are in the correct
X				 * order...
X				 */
X			} else if (low_val == dist3)
X			{
X				three->y = v_pos;
X				three->v = y_pos;
X			} else if (low_val == dist4)
X			{
X				three->x = h_pos;
X				three->h = x_pos;
X			}
X			/* low_val==dist2 is default... */
X			edit_frame(nn);
X			if (refr_auto == True)
X				refresh(pboard, '?', (caddr_t)DUMMY);	/* wipe screen */
X		}	/* if low_val<=points */
X		break;
X
X
X	case 'F':	/* which point ? */
X		two = (struct fig2 *) obj[currIndex];
X		dist1 = calc_distance(x, y, (int) two->x, (int) two->y);	/* upper left */
X		dist2 = calc_distance(x, y, (int) two->h, (int) two->v);	/* lower right */
X		dist3 = calc_distance(x, y, (int) two->h, (int) two->y);	/* upper right */
X		dist4 = calc_distance(x, y, (int) two->x, (int) two->v);	/* lower left */
X		if (zoomed == True)
X		{
X			dist1 *= 10;
X			dist2 *= 10;
X			dist3 *= 10;
X			dist4 *= 10;
X		}
X		/* compute minimum */
X		if (dist1 < dist2)
X			low_val = dist1;
X		else
X			low_val = dist2;
X		if (dist3 < low_val)
X			low_val = dist3;
X		if (dist4 < low_val)
X			low_val = dist4;
X		if (low_val <= points)
X		{
X			x_pos = two->x;
X			y_pos = two->y;
X			h_pos = two->h;
X			v_pos = two->v;
X			if (low_val == dist1)
X			{
X				two->x = h_pos;
X				two->y = v_pos;
X				two->h = x_pos;
X				two->v = y_pos;
X				/*
X				 * now, coordinates are in the correct
X				 * order...
X				 */
X			} else if (low_val == dist3)
X			{
X				two->y = v_pos;
X				two->v = y_pos;
X			} else if (low_val == dist4)
X			{
X				two->x = h_pos;
X				two->h = x_pos;
X			}
X			/* low_val==dist2 is default... */
X			edit_frame(ff);
X			if (refr_auto == True)
X				refresh(pboard, '?', (caddr_t)DUMMY);	/* wipe screen */
X		}	/* if low_val<=points */
X		break;
X
X
X
X	case 'D':	/* which point ? */
X		four = (struct fig4 *) obj[currIndex];
X		dist1 = calc_distance(x, y, (int) four->x, (int) four->y);	/* upper left */
X		dist2 = calc_distance(x, y, (int) four->h, (int) four->v);	/* lower right */
X		dist3 = calc_distance(x, y, (int) four->h, (int) four->y);	/* upper right */
X		dist4 = calc_distance(x, y, (int) four->x, (int) four->v);	/* lower left */
X		if (zoomed == True)
X		{
X			dist1 *= 10;
X			dist2 *= 10;
X			dist3 *= 10;
X			dist4 *= 10;
X		}
X		/* compute minimum */
X		if (dist1 < dist2)
X			low_val = dist1;
X		else
X			low_val = dist2;
X		if (dist3 < low_val)
X			low_val = dist3;
X		if (dist4 < low_val)
X			low_val = dist4;
X		if (low_val <= points)
X		{
X			x_pos = four->x;
X			y_pos = four->y;
X			h_pos = four->h;
X			v_pos = four->v;
X			if (low_val == dist1)
X			{
X				four->x = h_pos;
X				four->y = v_pos;
X				four->h = x_pos;
X				four->v = y_pos;
X				/*
X				 * now, coordinates are in the correct
X				 * order...
X				 */
X			} else if (low_val == dist3)
X			{
X				four->y = v_pos;
SHAR_EOF
true || echo 'restore of pickedit.c failed'
fi
echo 'End of  part 7'
echo 'File pickedit.c is continued in part 8'
echo 8 > _shar_seq_.tmp
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
