Newsgroups: comp.sources.x
Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: Fritz Haubensak <hsk@informatik.uni-wuerzburg.de>
Subject: v17i065: TeXcad (X) version 1.2, Part01/10
Message-ID: <csx-17i065-xtexcad-1.2@uunet.UU.NET>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Nntp-Posting-Host: fascet
Organization: Molecular Simulations, Inc.
Date: Tue, 21 Apr 1992 13:06:41 GMT
Approved: dcmartin@msi.com
Lines: 1895

Submitted-by: Fritz Haubensak <hsk@informatik.uni-wuerzburg.de>
Posting-number: Volume 17, Issue 65
Archive-name: xtexcad-1.2/part01

xtexcad is a drawing tool to produce LaTeX picture environments.
It is a re-implementation to run under X of the well known TeXcad
distributed with emTeX.

xtexcad was developed by Klaus Zitzmann of Koblenz University,
zitzmann@infko.uni-koblenz.de; please direct any questions
concerning the programm to him.

Regards, Fritz
-- 
Friedrich Haubensak  hsk@infko.uni-koblenz.de |
              ...!uunet!mcsun!unido!infko!hsk |  Science is true !
FB Informatik, Uni Koblenz,                   |
Rheinau 3-4, D-5400 Koblenz, Germany          |    Don't be misled by facts.

#!/bin/sh
# This is a shell archive (produced by shar 3.50)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 04/21/1992 13:03 UTC by dcmartin@fascet
# Source directory /home/fascet/dcmartin/csx/src/xtexcad/texcad12
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#    887 -rw-r--r-- Imakefile
#  10984 -rw-r--r-- Makefile
#    683 -rw-r--r-- Makefile.std
#   3363 -rw-r--r-- README
#     18 -rw-r--r-- Xtexcad.ad
#  16682 -rw-r--r-- ereignis.c
#   1281 -rw-r--r-- ereignis.h
#    476 -rw-r--r-- extdef.h
#  36818 -rw-r--r-- file_sel.c
#   1046 -rw-r--r-- file_sel.h
# 134559 -rw-r--r-- graphics.c
#   3541 -rw-r--r-- graphics.h
#  36048 -rw-r--r-- io_trans.c
#   1526 -rw-r--r-- io_trans.h
#  37008 -rw-r--r-- oberfl.c
#   4292 -rw-r--r-- oberfl.h
#    116 -rw-r--r-- patchlevel.h
#  85301 -rw-r--r-- pickedit.c
#   1800 -rw-r--r-- pickedit.h
#  65217 -rw-r--r-- pics.h
#     20 -rwxr-xr-x texcad
#  10421 -rw-r--r-- texcad12.man
#    700 -rw-r--r-- x_stuff.h
#   1731 -rw-r--r-- yyscan.h
#   6312 -rw-r--r-- yyscan.l
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= Imakefile ==============
if test -f 'Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Imakefile' &&
/* xtexcad 1.2 - Imakefile */
/* K.Zitzmann 2/92 */
/* If your version of the gcc is NOT able to link with shared libraries */
/* you can use the cc to reduce the size of the code. */
/* ( in this case you have to link the gnu-lib explicitly ) */
X
#ifdef BandAidCompiler
#include BandAidCompiler
#endif
X
X        DEFINES = -I../server
X        DEPLIBS = XawClientDepLibs
LOCAL_LIBRARIES = XawClientLibs
X  SYS_LIBRARIES = -lm -ll
X           SRCS = oberfl.c ereignis.c file_sel.c pickedit.c graphics.c yyscan.l io_trans.c 
X           SRCS = SRCS extdef.h pics.h x_stuff.h oberfl.h ereignis.h file_sel.h pickedit.h
X           SRCS = SRCS graphics.h yyscan.h io_trans.h
X           OBJS = oberfl.o ereignis.o file_sel.o pickedit.o graphics.o yyscan.o io_trans.o
X
/* overrides -O option */
X
X    CDEBUGFLAGS = -w 
X	     CC = gcc
X	     
X
X
ComplexProgramTarget(xtexcad)
InstallAppDefaults(Xtexcad)
SHAR_EOF
chmod 0644 Imakefile ||
echo 'restore of Imakefile failed'
Wc_c="`wc -c < 'Imakefile'`"
test 887 -eq "$Wc_c" ||
	echo 'Imakefile: original size 887, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile ==============
if test -f 'Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
# Makefile generated by imake - do not edit!
# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
#
# The cpp used on this machine replaces all newlines and multiple tabs and
# spaces in a macro expansion with a single space.  Imake tries to compensate
# for this, but is not always successful.
#
X
# -------------------------------------------------------------------------
# Makefile generated from "Imake.tmpl" and <Imakefile>
# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
#
# Platform-specific parameters may be set in the appropriate <vendor>.cf
# configuration files.  Site-specific parameters should be set in the file
# site.def.  Full rebuilds are recommended if any parameters are changed.
#
# If your C preprocessor does not define any unique symbols, you will need
# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
# "make World" the first time).
#
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that need to come before
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
# -------------------------------------------------------------------------
# platform-specific configuration parameters - edit sun.cf to change
X
# platform:  $XConsortium: sun.cf,v 1.68 91/07/30 11:34:39 rws Exp $
X
# operating system:  SunOS 4.1.1
X
# $XConsortium: sunLib.rules,v 1.6 91/03/24 17:55:58 rws Exp $
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that go after
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X      PROJECTROOT = /usr/X11/R5
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
# -------------------------------------------------------------------------
# X Window System Build Parameters
# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
# -------------------------------------------------------------------------
# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/X11/R5/lib
X           BINDIR = /usr/X11/R5/bin
X          INCROOT = /usr/X11/R5/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/X11/R5/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
# $XConsortium: sunLib.tmpl,v 1.11 91/07/31 11:32:08 rws Exp $
X
SHLIBLDFLAGS = -assert pure-text
PICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
# -------------------------------------------------------------------------
# Imake rules for building libraries, programs, scripts, and data files
# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
# -------------------------------------------------------------------------
# start of Imakefile
X
X        DEFINES = -I../server
X        DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
LOCAL_LIBRARIES = $(XAWLIB) $(XMULIB) $(XTOOLLIB) $(XLIB)
X  SYS_LIBRARIES = -lm -ll
X           SRCS = oberfl.c ereignis.c file_sel.c pickedit.c graphics.c yyscan.l io_trans.c
X           SRCS = SRCS extdef.h pics.h x_stuff.h oberfl.h ereignis.h file_sel.h pickedit.h
X           SRCS = SRCS graphics.h yyscan.h io_trans.h
X           OBJS = oberfl.o ereignis.o file_sel.o pickedit.o graphics.o yyscan.o io_trans.o
X
X    CDEBUGFLAGS = -w
X	     CC = gcc
X
X PROGRAM = xtexcad
X
all:: xtexcad
X
xtexcad: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
saber_xtexcad:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
osaber_xtexcad:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
install:: xtexcad
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  xtexcad $(DESTDIR)$(BINDIR)
X
install.man:: xtexcad.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) xtexcad.man $(DESTDIR)$(MANDIR)/xtexcad.$(MANSUFFIX)
X
depend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
lint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
lint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
clean::
X	$(RM) $(PROGRAM)
X
install:: Xtexcad.ad
X	@if [ -d $(DESTDIR)$(XAPPLOADDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XAPPLOADDIR)); fi
X	$(INSTALL) -c $(INSTAPPFLAGS) Xtexcad.ad $(DESTDIR)$(XAPPLOADDIR)/Xtexcad
X
# -------------------------------------------------------------------------
# common rules for all Makefiles - do not edit
X
emptyrule::
X
clean::
X	$(RM_CMD) "#"*
X
Makefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
tags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
saber:
X	# load $(ALLDEFINES) $(SRCS)
X
osaber:
X	# load $(ALLDEFINES) $(OBJS)
X
# -------------------------------------------------------------------------
# empty rules for directories that do not have SUBDIRS - do not edit
X
install::
X	@echo "install in $(CURRENT_DIR) done"
X
install.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
Makefiles::
X
includes::
X
# -------------------------------------------------------------------------
# dependencies generated by makedepend
X
SHAR_EOF
chmod 0644 Makefile ||
echo 'restore of Makefile failed'
Wc_c="`wc -c < 'Makefile'`"
test 10984 -eq "$Wc_c" ||
	echo 'Makefile: original size 10984, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile.std ==============
if test -f 'Makefile.std' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile.std (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile.std (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile.std' &&
CC= gcc
#CFLAGS= -g -w
CFLAGS= # -w
X
cad: oberfl.o ereignis.o file_sel.o pickedit.o graphics.o yyscan.o io_trans.o 
X	$(CC) -s -o xtexcad\
X		oberfl.o ereignis.o file_sel.o pickedit.o\
X		graphics.o io_trans.o yyscan.o\
X		-lXaw -lXmu -lXt -lXext -lX11 -lm -ll
X
ereignis.o: ereignis.h ereignis.c pics.h extdef.h oberfl.h
X
file_sel.o: file_sel.h file_sel.c extdef.h 
X
pickedit.o: pickedit.h pickedit.c extdef.h 
X
graphics.o: graphics.h graphics.c extdef.h 
X
io_trans.o: io_trans.h io_trans.c extdef.h 
X
oberfl.o: oberfl.c oberfl.h x_stuff.h extdef.h pics.h
X
yyscan.c:  yyscan.l
X	lex -t yyscan.l > yyscan.c
X
yyscan.o: yyscan.h yyscan.c extdef.h
X
clean:
X	rm -f *.o xtexcad core *% yyscan.c
SHAR_EOF
chmod 0644 Makefile.std ||
echo 'restore of Makefile.std failed'
Wc_c="`wc -c < 'Makefile.std'`"
test 683 -eq "$Wc_c" ||
	echo 'Makefile.std: original size 683, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
This is a drawing tool to produce LaTeX picture environments.
X
This is an X11 (re)implementation of the well known TeXcad
distributed with emTeX.
X
X
TeXcad 1.2 is distributed with the following files:
X
-rw-r--r--  1 uni-koblenz      887 Apr 10 17:29 Imakefile
-rw-r--r--  1 uni-koblenz      683 Apr 10 16:21 Makefile.std
-rw-r--r--  1 uni-koblenz     3363 Apr 10 17:48 README
-rw-r--r--  1 uni-koblenz       18 Jan 20 15:33 Xtexcad.ad
-rw-r--r--  1 uni-koblenz    16682 Mar  5 10:45 ereignis.c
-rw-r--r--  1 uni-koblenz     1281 Mar  5 10:45 ereignis.h
-rw-r--r--  1 uni-koblenz      475 Mar  5 10:45 extdef.h
-rw-r--r--  1 uni-koblenz    36818 Mar  5 10:45 file_sel.c
-rw-r--r--  1 uni-koblenz     1046 Mar  5 10:45 file_sel.h
-rw-r--r--  1 uni-koblenz   134559 Mar  5 10:45 graphics.c
-rw-r--r--  1 uni-koblenz     3540 Mar  5 10:45 graphics.h
-rw-r--r--  1 uni-koblenz    36047 Mar  5 10:45 io_trans.c
-rw-r--r--  1 uni-koblenz     1526 Mar  5 10:45 io_trans.h
-rw-r--r--  1 uni-koblenz    37008 Apr 10 15:40 oberfl.c
-rw-r--r--  1 uni-koblenz     4292 Mar  5 10:45 oberfl.h
-rw-r--r--  1 uni-koblenz      116 Jan 27 14:33 patchlevel.h
-rw-r--r--  1 uni-koblenz    85301 Mar  5 10:45 pickedit.c
-rw-r--r--  1 uni-koblenz     1799 Mar  5 10:45 pickedit.h
-rw-r--r--  1 uni-koblenz    65217 Mar  5 10:45 pics.h
-rwxr-xr-x  1 uni-koblenz       20 Mar  5 10:45 texcad*
-rw-r--r--  1 uni-koblenz    10421 Apr 10 16:48 texcad12.man
-rw-r--r--  1 uni-koblenz      700 Mar  5 10:45 x_stuff.h
-rw-r--r--  1 uni-koblenz     1731 Mar  5 10:45 yyscan.h
-rw-r--r--  1 uni-koblenz     6312 Mar  5 10:45 yyscan.l
X
X
X     Imakefile			
X     Makefile.std			% my old makefile		
X     
X     ereignis.c				% event distribution...
X     ereignis.h
X     
X     graphics.c				% the main graphic functions
X     graphics.h
X     
X     file_sel.c				% the file selector box
X     file_sel.h
X     
X     io_trans.c				% the i/o functions
X     io_trans.h
X     
X     oberfl.c				% void main()
X     oberfl.h
X     
X     pickedit.c				%
X     pickedit.h
X     
X     yyscan.l				% lex scanner definition
X     yyscan.h
X     
X     extdef.h				% external functions
X     pics.h				% icons, about sign and pictures
X     x_stuff.h				% what TeXcad requires from X
X     
X     texcad12.man			% program description (TeX format)
X     
X     Xtexcad.ad 			% the resources for TeXcad
X
X
X
On my system 'make -f Makefile.std cad' compiles and links the whole
thing.
X
You should use the GNU ANSI-C Compiler.
I've successfully compiled TeXcad with gcc 2.0 on Sun3 and Sun4 under
SunOS 4.1.1 and on DG AViiON 200 under DG/UX 4.31 and with gcc 1.40
on NeXT.
X
Patches for Data General DGUX are done by J. Marenda (marked with /* JM */)
X
X
!!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!!
!!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!!
!!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!!
X
general hint:
X
Please don't use the -O optimization option on 680x0 architectures like SUN3
or NeXT.  The gcc produces incorrect code which leads to crashes (here:
segmentation fault within the XLib) !!!
Optimization on SUN4 works properly.
X
!!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!!
!!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!!
!!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!! IMPORTANT !!!
SHAR_EOF
chmod 0644 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 3363 -eq "$Wc_c" ||
	echo 'README: original size 3363, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xtexcad.ad ==============
if test -f 'Xtexcad.ad' -a X"$1" != X"-c"; then
	echo 'x - skipping Xtexcad.ad (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xtexcad.ad (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xtexcad.ad' &&
XXtexcad*Font:6x13
SHAR_EOF
chmod 0644 Xtexcad.ad ||
echo 'restore of Xtexcad.ad failed'
Wc_c="`wc -c < 'Xtexcad.ad'`"
test 18 -eq "$Wc_c" ||
	echo 'Xtexcad.ad: original size 18, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ereignis.c ==============
if test -f 'ereignis.c' -a X"$1" != X"-c"; then
	echo 'x - skipping ereignis.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ereignis.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ereignis.c' &&
/* xtexcad  V1.2 - graphic editor for LaTeX */
/* 1991 by K.Zitzmann */
/* ereignis.c */
X
#include "x_stuff.h"
#include "ereignis.h"
#include "file_sel.h"
#include "oberfl.h"
#include "graphics.h"
#include "io_trans.h"
#include <math.h>
#include "pics.h"
#include "pickedit.h"
X
/* used by the cross-hair-pointer */
int             h_cross = -999;
int             v_cross = -999;
X
X
X
X
void
about_handler()
{
X	/* displays additional information about this program, like */
X	/* the copyright,author etc. */
X
X	Display        *disp;
X	Window          win;
X	Widget          child, child2, box;
X	XtTranslations  trans_table;
X	char            destination[80] = "<LeaveNotify>: XtMenuPopdown()";
X	Position        x, y, x_rel, y_rel;
X	char            ss[200];
X
X	strcpy(ss,titlename);
X	strcat(ss," -  SHAREWARE-Utility For The Development\nOf Portable LaTeX-Graphics.\n\n");
X	strcat(ss,"    Last Change: 1/1992\n");
X
X	
X	about = XtCreatePopupShell("About...", transientShellWidgetClass, canvas, NULL,0);
X
X
X	n = 0;
X	XtSetArg(args[n], XtNborderWidth, 0);
X	n++;
X	box = XtCreateManagedWidget("abt1", boxWidgetClass, about, args, n);
X
X	n = 0;
X	disp = XtDisplay(toplevel);
X	win = XtWindow(toplevel);
X	about_map = XCreateBitmapFromData(disp, win, texcad_bits, texcad_width, texcad_height);
X	XtSetArg(args[n], XtNborderWidth, 0);
X	n++;
X	XtSetArg(args[n], XtNjustify, XtJustifyCenter);
X	n++;
X	XtSetArg(args[n], XtNbitmap, about_map);
X	n++;
X	XtSetArg(args[n], XtNwidth, 2 * texcad_width);
X	n++;
X	
X	child = XtCreateManagedWidget("abt2", labelWidgetClass, box, args, n);
X
X	n = 0;
X	XtSetArg(args[n], XtNheight, texcad_height);
X	n++;
X	XtSetArg(args[n], XtNborderWidth, 0);
X	n++;
X	XtSetArg(args[n], XtNwidth, 2 * texcad_width);
X	n++;
X	
X	child2 = XtCreateManagedWidget(ss, labelWidgetClass, box, args, n);
X
X
X
X	/* Override Translation Manager */
X
X	trans_table = XtParseTranslationTable(destination);
X	XtOverrideTranslations(about, trans_table);
X
X
X	/* setting the widget-position */
X	n = 0;
X	XtSetArg(args[n], XtNx, &x_rel);
X	n++;
X	XtSetArg(args[n], XtNy, &y_rel);
X	n++;
X	XtGetValues(canvas, args, n);	/* get the relative coordinates of
X					 * widget: canvas */
X	XtTranslateCoords(canvas, x_rel, y_rel, &x, &y);
X	n = 0;
X	XtSetArg(args[n], XtNx, x + cmd_btn_width + 3 * new_section);
X	n++;
X	XtSetArg(args[n], XtNy, y + 2 * cmd_btn_height);
X	n++;
X	XtSetValues(about, args, n);
X
X
X
X
X	XtPopup(about, XtGrabExclusive);
X
X
X
}
X
X
X
X
void
draw_coords(Widget cmd, caddr_t hi, caddr_t call_data)
{
X	/* displays the absolute and relative coordinates of the pointer. */
X	/* Furthermore it handles the cross-wire */
X
X	Display        *disp = XtDisplay(coordinates);
X	Window          win = XtWindow(coordinates);
X	Display        *disp2 = XtDisplay(pboard);
X	Window          win2 = XtWindow(pboard);
X	int             x, y, h, v;
X	float           a, b;
X	unsigned int    mask;
X	char            s1[13];
X	char            s2[13];
X
X
X
X
X
X	snapPointerPosition(&x, &y, &mask);
X
X	if ((h_cross != x) || (v_cross != y))
X	{	/* redraw */
X		if (zoomed == True)
X		{
X			a = x;
X			b = y;
X			zoomed2real(&a, &b);
X			h = (int) a;
X			v = (int) b;
X			if (h < 0)
X				h = 0;
X			if (v < 0)
X				v = 0;
X			if (x < 1)
X				sprintf(s1, "X=000,%3.3i", h);
X			else
X				sprintf(s1, "X=%3.3i,%3.3i", x, h);
X			if (y < 1)
X				sprintf(s2, "Y=000,%3.3i", v);
X			else
X				sprintf(s2, "Y=%3.3i,%3.3i", y, v);
X		} else
X		{
X			if (x < 1)
X				strcpy(s1, "X=---,000");
X			else
X				sprintf(s1, "X=---,%3.3i", x);
X			if (y < 1)
X				strcpy(s2, "Y=---,000");
X			else
X				sprintf(s2, "Y=---,%3.3i", y);
X		}
X
X		XClearArea(disp, win, 15, 11, 70, 30, False);
X		
/* JM */
X		
X		if (black_white_patch)
X			XSetFunction(disp, gc, GXand);
X		else
X			XSetFunction(disp, gc, GXor);
X
X		XDrawString(disp, win, gc, 3, 12, "  rel abs", 9);
X		XDrawString(disp, win, gc, 3, 24, s1, 9);
X		XDrawString(disp, win, gc, 3, 36, s2, 9);
X
/* JM */	if (black_white_patch)
X			XSetFunction(disp, gc, GXequiv);
X		else
X			XSetFunction(disp, gc, GXxor);
X
X		/* cross */
X
X		if (cross == True)
X		{
X			XDrawLine(disp2, win2, gc, x, 0, x, y_A4_max);
X			XDrawLine(disp2, win2, gc, 0, y, x_A4_max, y);
X
X
X			/* delete old */
X			if (h_cross != -999)
X			{
X				XDrawLine(disp2, win2, gc, h_cross, 0, h_cross, y_A4_max);
X				XDrawLine(disp2, win2, gc, 0, v_cross, x_A4_max, v_cross);
X			}
X		}	/* cross==True */
X	}	/* redraw */
X	h_cross = x;
X	v_cross = y;
X
X
}
X
X
void
ruler_on()
{
X	/* enable ruler */
X
X	char            s[3];
X	int             x, y, step = 4;
X	Display        *disp = XtDisplay(pboard);
X	Window          win = XtWindow(pboard);
X	Boolean         first = True;
X	int             adjust;
X	float           hor = 1, ver = 1;
X	int             zahl;
X
X
X	for (x = step; x < x_A4_max; x += step)
X	{
X		if ((x % 16) == 0)
X			XDrawLine(disp, win, gc, x, y_A4_max, x, y_A4_max - 4);
X		else if ((x % 40) == 0)
X		{
X			XDrawLine(disp, win, gc, x, y_A4_max, x, y_A4_max - 7);
X			if (first == True)
X				first = False;	/* don't draw the first one */
X			else
X			{
X				if (zoomed == True)
X				{
X					hor = (float) x;
X					zoomed2real(&hor, &ver);
X					zahl = (int) (hor + 0.5);
X				} else
X					zahl = x;
X				sprintf(s, "%i", (int) (zahl));
X				if (strlen(s) == 2)
X					adjust = 10;
X				else
X					adjust = 13;
X				XDrawString(disp, win, gc, x - adjust, y_A4_max - 10, s, strlen(s));
X			}
X		} else
X			XDrawLine(disp, win, gc, x, y_A4_max, x, y_A4_max - 2);
X	}
X
X	for (y = y_A4_max - step; y > 0; y -= step)
X	{
X		if ((y % 16) == 0)
X			XDrawLine(disp, win, gc, 0, y, 4, y);
X		else if ((y % 40) == 0)
X		{
X			XDrawLine(disp, win, gc, 0, y, 7, y);
X			if (zoomed == True)
X			{
X				ver = (float) y;
X				zoomed2real(&hor, &ver);
X				zahl = (int) (ver + 0.5);
X			} else
X				zahl = y;
X			sprintf(s, "%i", (int) (zahl));
X			XDrawString(disp, win, gc, 10, y + 4, s, strlen(s));
X		} else
X			XDrawLine(disp, win, gc, 0, y, 2, y);
X	}
}
X
X
X
void
ruler_switch(Widget w, char c, caddr_t call_data)
{
X	/* called by the settings menu (callback) */
X	/* toggles the use of the ruler */
X
X	if (ruler == True)
X		ruler = False;
X	else
X		ruler = True;
X
X	ruler_on();
}
X
X
void
cross_switch(Widget w, char c, caddr_t call_data)
{
X	/* toggles the use of the cross-hair */
X
X	Display        *disp = XtDisplay(pboard);
X	Window          win = XtWindow(pboard);
X	unsigned int    mask;
X	if (cross == True)
X		cross = False;	/* redraw cross-cursor */
X
X
X	else
X	{
X		cross = True;
X		/* draw it */
X		snapPointerPosition(&h_cross, &v_cross, &mask);
X	}
X
X	XDrawLine(disp, win, gc, h_cross, 0, h_cross, y_A4_max);
X	XDrawLine(disp, win, gc, 0, v_cross, x_A4_max, v_cross);
X
X
}
X
X
void
automatic_refresh(Widget w, caddr_t client_data, caddr_t call_data)
{
X	if (refr_auto == True)
X		refr_auto = False;
X	else
X		refr_auto = True;
}
X
X
void
full_dina4(Widget w, caddr_t client_data, caddr_t call_data)
{
X	if (dina4 == True)
X		dina4 = False;
X	else
X		dina4 = True;
}
X
X
void
l_length_switch(Widget w, caddr_t client_data, caddr_t call_data)
{
X	if (line_length == 0)
X		line_length = 10;
X	else
X		line_length = 0;
}
X
void
aus_raster(Widget w, char c, caddr_t call_data)
{
X	/* toggles the use of a raster */
X	/* realizes raster height/width input */
X
X	XtAppContext    app_context;	/* Applikationcontext */
X	XEvent          event;
X	Position        x, y, x_rel, y_rel;
X	int             h, v;
X	unsigned int    mask;
X
X
X
X
X	if (raster == False)
X	{
X		XtPopdown(radio_up);
X		PointerPosition(&h, &v, &mask);
X		/* setting position of widget */
X		n = 0;
X		XtSetArg(args[n], XtNx, &x_rel);
X		n++;
X		XtSetArg(args[n], XtNy, &y_rel);
X		n++;
X		XtGetValues(canvas, args, n);
X		/* get the relative coordinates of widget: canvas */
X		XtTranslateCoords(canvas, x_rel, y_rel, &x, &y);
X		n = 0;
X		XtSetArg(args[n], XtNx, x + cmd_btn_width + 2 * new_section);
X		n++;
X		XtSetArg(args[n], XtNy, y + 4 * cmd_btn_height);
X		n++;
X		XtSetValues(raster_up, args, n);
X		/* position set ! */
X
X		/* query raster-height */
X		XtPopup(raster_up, XtGrabExclusive);
X
X		app_context = XtWidgetToApplicationContext(raster_up);
X
X		visible = True;
X
X		while (visible)
X		{
X			XtAppNextEvent(app_context, &event);
X			XtDispatchEvent(&event);
X
X		}
X
X	} else
X		raster = False;
X
}
X
void
raster_on()
{
X	/* display raster */
X
X	Display        *disp = XtDisplay(pboard);
X	Window          win = XtWindow(pboard);
X	int             x, y, x_disp, y_disp, zoom=(zoomed==True) ? 10 : 1;
X	float           h = 1, v = 1;	/* dummy init */
X	int 		cross_len=3;
X	int		cross_space;
X	char		d_list[2];
X
X
X	/* enable raster display on pboard */
X
X	y = rast_height; 
X	x = rast_height;
X
X	if (zoomed==True)
X	{
X		d_list[0] = (char)cross_len;
X		d_list[1] = (char)10;
X		XSetLineAttributes(disp, copy_gc, 0, LineOnOffDash, CapButt, JoinMiter);
X	}
X	else
X	{
X		cross_space=rast_height-cross_len; 
X	
X		d_list[0]=(char)cross_len;
X		d_list[1]=(char)cross_space;
X	}
X
X
X		XSetDashes(disp,copy_gc,0,d_list,2);
X
X
X
X	for (; (x <= 600 - rast_height); x += rast_height)
X	{
X		if (zoomed == True)
X		{
X			h = (float) x;
X			real2zoomed(&h, &v);
X			x_disp = (int) h;
X		} else
X			x_disp = x;
X
X		XDrawLine(disp, win, copy_gc, x_disp, rast_height-(int)(cross_len/2), x_disp, 840 - (int)(cross_len/2));
X	}
X
X
X
X	for (; (y <= 840 - rast_height); y += rast_height)
X	{
X		if (zoomed == True)
X		{
X			v = (float) y;
X			real2zoomed(&h, &v);
X			y_disp = (int) v;
X		} else
X			y_disp = y;
X
X		XDrawLine(disp, win, copy_gc, rast_height-(int)(cross_len/2), y_disp, 600 - (int)(cross_len/2), y_disp);
X
X	}
X
X
}
X
X
void
raster_off()
{
X
X	/* disable raster display on pboard */
X
X	raster_on();
X
X
X
}
X
X
void
get_number()
{
X	/* raster-stuff */
X	int             j=0,i=0;
X	char		zahl[10],un[2];
X	Boolean		unknown=False;
X	float 		num=0.0;
X	char		out[300];
X
X	raster = True;
X	ulen=1.0; /* standard unitlength */
X	unit=1; /* standard: points */
X
X	/* set new raster-height/width or default value */
X
X	/* scan the input ! */
X	zahl[0]='\0';
X
X	while( ( (isdigit(chain[i])) || (chain[i]=='.') ) && (i<=strlen(chain)) )
X	{
X		zahl[i]=chain[i];
X		i++;
X		zahl[i]='\0';
X	}
X
X	/* the number is in zahl */
X
X	num=(zahl[0]!='\0') ? atof(zahl) : 0.0;
X
X	/* get the unit - take 'pt' if none is specified */
X
X	while(i<=strlen(chain) && j<=2)
X	{
X		if (isalpha(chain[i])) un[j++]=chain[i];
X		i++;
X	}
X	
X	if ((toupper(un[0]))=='I') unit=2; /* Inch */
X	else
X	if ((toupper(un[0]))=='C') unit=3; /* Cm */
X	else
X	if ((toupper(un[0]))=='M') unit=4; /* Mm */
X	else
X	if ((toupper(un[0]))=='P') /* Pica or Point */
X	{
X		if ((toupper(un[1]))=='T') unit=1; /* point */
X		else 
X		if ((toupper(un[1]))=='C') unit=5; /* pica */
X		else unknown=True;
X	} else unknown=True;
X	
X	if (unknown==True) /* unit not recognized */
X		unit=1; /* default-unit = points */
X	
X	if (num!=0.0) rast_height=(int)compute_length(num);
X		else rast_height=40; /* standard raster */
X
X	if (rast_height<4)
X	{
X		num=-1.0;
X		rast_height=40;
X	}
X	
X	visible = False;
X
X	XtPopdown(raster_up);
X
X	out[0]='\0';
X
X	if ( (num==0.0) && (unknown==True) )
X		strcat(out,"ERROR !!!\n - Unit not recognized\n - No value specified\n\nInvoking standard
raster...\n");
X	else if (unknown==True) strcat(out,"ERROR !!!\n - Unit not recognized\n\nTaking POINTS now !\n");
X	else if (num==0.0) strcat(out,"ERROR !!!\n - No valid value !\nInvoking standard raster...\n");
X	
X
X
X	if (num==-1.0) strcat(out,"Sorry - raster too small !\nInvoking standard raster...\n");
X
X
X	if (out[0]!='\0') leave_pick(out);
X
X
X	
X
}
X
X
X
void
snap_on(Widget w, caddr_t client_data, caddr_t call_data)
{
X	/* enable snap function for LaTeX-Graph-File */
X
X	if (snap == False)
X		snap = True;
X	else
X		snap = False;
X
}
X
X
X
void
slopes(Widget w, caddr_t client_data, caddr_t call_data)
{
X	/* toggles the use of finit/infinite slopes */
X
X	if (steigung == False)
X	{
X		steigung = True;
X		/* all slopes allowed */
X		line_slope = 0;
X		arrow_slope = 0;
X	} else
X	{
X		steigung = False;
X		line_slope = slope_line;
X		arrow_slope = slope_arrow;
X	}
X
}
X
void
diams(Widget w, caddr_t client_data, caddr_t call_data)
{
X	/* toggles the use of unlimited diameters */
X	if (durchmesser == False)
X	{
X		durchmesser = True;
X		circle_diameter[0] = -1;
X		disc_diameter[0] = -1;
X	} else
X	{
X		durchmesser = False;
X		circle_diameter[0] = 1;
X		disc_diameter[0] = 1;
X	}
}
X
X
void
load_handler()
{
X	/* read a LaTeX-file from the medium */
X
X	char            title[] = "Load object";
X	char            pattern[] = "*.tex";
X	char           *name;
X	Position        x, y, x_rel, y_rel;
X
X
X	n = 0;
X	XtSetArg(args[n], XtNx, &x_rel);
X	n++;
X	XtSetArg(args[n], XtNy, &y_rel);
X	n++;
X	XtGetValues(canvas, args, n);	/* get the relative coordinates of
X					 * widget: canvas */
X
X	XtTranslateCoords(canvas, x_rel, y_rel, &x, &y);
X        
X	centerpopup(canvas,fileselector);
X	name =
X		file_select(pattern, title);
X
X	if (name != NULL)
X	{
X		perform_erase();	/* clear data-base */
X		load_it(name);
X	}
}
X
X
X
X
void
trans_handler()
{
X	/* translate the objects to pure LaTeX-code */
X
X	char            title[] = "Save object";
X	char            pattern[] = "*.tex";
X	char           *name;
X	Position        x, y, x_rel, y_rel;
X	if (
X	    disc_start == NULL &&
X	    kreis_start == NULL &&
X	    filledBox_start == NULL &&
X	    oval_start == NULL &&
X	    strich_start == NULL &&
X	    pfeil_start == NULL &&
X	    framedBox_start == NULL &&
X	    dashedBox_start == NULL &&
X	    bezier_start == NULL &&
X	    message_start == NULL)
X	{
X		leave_pick("SAVE:\n\nThere are no objects !");
X		return;
X	}
X	n = 0;
X	XtSetArg(args[n], XtNx, &x_rel);
X	n++;
X	XtSetArg(args[n], XtNy, &y_rel);
X	n++;
X	XtGetValues(canvas, args, n);	/* get the relative coordinates of
X					 * widget: canvas */
X
X	XtTranslateCoords(canvas, x_rel, y_rel, &x, &y);
X
X	centerpopup(canvas,fileselector);
X	name =
X		file_select(pattern, title);
X
X	if (name != NULL)
X		trans_it(name);
X
}
X
void
general_purpose_handler(Widget cmd, caddr_t id, caddr_t call_data)
{
X	/* distributes all other incoming events */
X
X	int             i;
X	char            txt[100];
X	XtTranslations  trans_table;
X	char            destination[80] = "<EnterWindow> : set_TM_btn1_first() \n\
X		       <LeaveWindow> : left()";
X	static XtActionsRec actions[80] = {{"set_TM_btn1_first", set_TM_btn1_first},
X	{"left", left}};
X
X
X	XtAddActions(actions, XtNumber(actions));
X	trans_table = XtParseTranslationTable(destination);
X	XtOverrideTranslations(pboard, trans_table);
X
X	/* set the new current action code */
X	graph_action = (char) id;
X
X	strcpy(txt, titlename);
X	strcat(txt, "  :  ");
X
X	switch (graph_action)
X	{
X	case 'L':
X		strcat(txt, "#### Line ####");
X		headline(toplevel, txt);
X		break;
X
X	case 'V':
X		strcat(txt, "#### Vector ####");
X		headline(toplevel, txt);
X		break;
X
X	case 'Z':
X		strcat(txt, "#### Area Zoom ####");
X		headline(toplevel, txt);
X		break;
X
X	case 'T':
X		strcat(txt, "#### Text ####");
X		headline(toplevel, txt);
X		break;
X
X	case 'N':
X		strcat(txt, "#### Box --> framed ####");
X		headline(toplevel, txt);
X		break;
X
X	case 'D':
X		strcat(txt, "#### Box --> dashed ####");
X		headline(toplevel, txt);
X		break;
X
X	case 'F':
X		strcat(txt, "#### Box --> filled ####");
X		headline(toplevel, txt);
X		break;
X
X	case 'C':
X		strcat(txt, "#### Circle --> normal ####");
X		headline(toplevel, txt);
X		break;
X
X	case 'O':
X		strcat(txt, "#### Circle --> oval ####");
X		headline(toplevel, txt);
X		break;
X
X	case 'B':
X		strcat(txt, "#### Circle --> filled ####");
X		headline(toplevel, txt);
X		break;
X
X	case 'A':
X		strcat(txt, "#### Erase --> erasing the entire database ####");
X		headline(toplevel, txt);
X		query_ask_erase();
X		if (txtpos[0] == 'j')
X			perform_erase();
X		XtUninstallTranslations(pboard);
X		left();
X		break;
X
X	case 'G':
X		if ( (i=sorry_msg())==-1 ) break;
X		strcat(txt, "#### Erase --> pick the desired object ####");
X		headline(toplevel, txt);
X		break;
X
X	case 'P':
X		if ( (i=sorry_msg())==-1 ) break;
X		strcat(txt, "#### Pick object ####");
X		headline(toplevel, txt);
X		break;
X
X	case 'Y':
X		if ( (i=sorry_msg())==-1 ) break;
X		strcat(txt, "#### Pick object to copy ####");
X		headline(toplevel, txt);
X		break;
X
X	case 'I':
X		strcat(txt, "#### Bezier ####");
X		headline(toplevel, txt);
X		break;
X
X	default:
X		break;
X	}	/* switch */
}
X
X
X
X
X
void
quit_handler(Widget cmd, caddr_t client_data, caddr_t call_data)
{
X	XFreePixmap(XtDisplay(pboard), about_map);
X	perform_erase();	/* clear data-base */
X	exit(0);
}
X
X
void
options(Widget w, caddr_t client_data, caddr_t call_data)
{
X	/* puts the settings-menu to the right position */
X
X	Position        x, y, x_rel, y_rel;
X	n = 0;
X	XtSetArg(args[n], XtNx, &x_rel);
X	n++;
X	XtSetArg(args[n], XtNy, &y_rel);
X	n++;
X
X	/* get the relative coordinates of widget: canvas */
X	XtGetValues(canvas, args, n);
X
X	XtTranslateCoords(canvas, x_rel, y_rel, &x, &y);
X
X	n = 0;
X	XtSetArg(args[n], XtNx, x + cmd_btn_width + 2 * new_section);
X	n++;
X	XtSetArg(args[n], XtNy, y + 9 * cmd_btn_height);
X	n++;
X	XtSetValues(radio_up, args, n);
X
X	XtPopupSpringLoaded(radio_up);
}
X
X
void
answer(Widget w, char c, caddr_t call_data)
{
X	txtpos[0] = c;
X	XtPopdown(ask_up);
X	visible = False;
X
}
SHAR_EOF
chmod 0644 ereignis.c ||
echo 'restore of ereignis.c failed'
Wc_c="`wc -c < 'ereignis.c'`"
test 16682 -eq "$Wc_c" ||
	echo 'ereignis.c: original size 16682, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= ereignis.h ==============
if test -f 'ereignis.h' -a X"$1" != X"-c"; then
	echo 'x - skipping ereignis.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting ereignis.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'ereignis.h' &&
/* xtexcad  V1.2 - graphic editor for LaTeX */
/* 1991 by K.Zitzmann */
/* header-file ereignis.h */
X
X
X
#ifndef EREIGNISH
#define EREIGNISH
X
X
X
X
X
/* prototypes */
X
X
X
X
X void load_handler(void);
X void trans_handler(void);
X void about_handler(void);
X void quit_handler(Widget cmd, caddr_t client_data, caddr_t call_data);
X void options(Widget w, caddr_t client_data, caddr_t call_data);
X void raster_on(void);
X void raster_off(void);
X void snap_on(Widget w, caddr_t client_data, caddr_t call_data);
X void general_purpose_handler(Widget w, caddr_t client_data, caddr_t call_data);
X void aus_raster(Widget w, char c, caddr_t call_data);
X void slopes(Widget w, caddr_t c, caddr_t call_data);
X void diams(Widget w, caddr_t c, caddr_t call_data);
X void answer(Widget w, char c, caddr_t call_data);
X void get_number(void);
X void automatic_refresh(Widget w, caddr_t client_data, caddr_t call_data);
X void full_dina4(Widget w, caddr_t client_data, caddr_t call_data);
X void draw_coords(Widget cmd, caddr_t, caddr_t call_data);
X void ruler_on(void);
X void ruler_switch(Widget w, char c, caddr_t call_data);
X void cross_switch(Widget w, char c, caddr_t call_data);
X void l_length_switch(Widget w, caddr_t client_data, caddr_t call_data);
X
X
extern int h_cross;
extern int v_cross;
X
X
X
#endif
X
X
X
X
X
SHAR_EOF
chmod 0644 ereignis.h ||
echo 'restore of ereignis.h failed'
Wc_c="`wc -c < 'ereignis.h'`"
test 1281 -eq "$Wc_c" ||
	echo 'ereignis.h: original size 1281, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= extdef.h ==============
if test -f 'extdef.h' -a X"$1" != X"-c"; then
	echo 'x - skipping extdef.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting extdef.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'extdef.h' &&
/* xtexcad  V1.2 - graphic editor for LaTeX */
/* 1991 by K.Zitzmann */
/* header-file extdef.h */
X
X
#ifndef EXTERNALH
#define EXTERNALH
X
#ifndef DGUX
extern double atof(char *txt);
#endif
extern double sqrt(double x);
extern int abs(int x);
extern double fabs(double x);
extern double acos(double x);
extern double sin(double x);
extern char *malloc(int l);
extern char *getenv(char *s);           
extern int chdir();                     
X
/* to be continued... */
X
X
#endif
SHAR_EOF
chmod 0644 extdef.h ||
echo 'restore of extdef.h failed'
Wc_c="`wc -c < 'extdef.h'`"
test 476 -eq "$Wc_c" ||
	echo 'extdef.h: original size 476, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= file_sel.c ==============
if test -f 'file_sel.c' -a X"$1" != X"-c"; then
	echo 'x - skipping file_sel.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting file_sel.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'file_sel.c' &&
/* xtexcad  V1.2 - graphic editor for LaTeX */
/* 1991 by K.Zitzmann */
/* file_sel.c */
X
X
#define MAXPATH LAENGE+LAENGE2   /* Laenge mit Pfad */ 
#define LAENGE 21                /* Laenge Dateiname */
#define WEITE 150                /* Breite des Directoryfensters */
#define LAENGE2 50               /* Laenge Pfadname */
#define HOEHE 300                /* Hoehe des Directoryfensters */
#define ABSTAND 8                /* Abstand zwischen den einzelnen Widgets */
#define DEFAULT_X 300            /* Vorgabe fuer X Koordinate */
#define DEFAULT_Y 300            /* Vorgabe fuer Y Koordinate */
X
#include <strings.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/dir.h>
#include <sys/stat.h>
#include <X11/IntrinsicP.h>
#include <X11/Shell.h>
#include <X11/ShellP.h>
#include <X11/Xaw/Viewport.h>
#include <X11/Xaw/DialogP.h>
/* R4: */
/* #include <X11/Xaw/AsciiSrc.h> */
/* R5 */
#include <X11/Xaw/AsciiText.h>
X
#include <X11/Xaw/Text.h>
X
#include "extdef.h"
#include "x_stuff.h"
#include "file_sel.h"
X
X
static char *filename;                    /* Pointer auf Filename */
static Widget file_s;                     /* Popupshell fuer Fileselectbox */
static Widget list_direct,                /* Directoryeintraege im Fenster */
X	      titel_zeile;                /*Label fuer angezeigte Titelzeile */
X
static DialogWidget path,                 /* Dialog fuer Ausgabe Path */
X		    text,                 /* Eingabe Filename DialogWidget */
X		    patt_t;               /* Labelfeld Ausgabe des Patterns */
X
static char _default[LAENGE];             /* String zum Loeschen des Labels */
static char _default2[LAENGE2];           /* String zum Loesch Titel,Path */
static char patt_global[LAENGE];          /* Pattern als globale Variable */
static int init_called=0;                 /* Widgets korrekt mit INIT_FILE_ */
X					  /* SELECT initialisiert */
X
/* Pointer werden global benoetigt um Speicher beim Verlassen der Fileselect-*/
/* box wieder freigegeben werden kann */
static String *Liste;                     /* Liste der bearbeiteten Strings */
static char *Inhalt;                      /* Listeninhalt */ 
X
static char *getcwd(buf,size)
char *buf;
int size;
{
char pathname[MAXPATHLEN];
X
getwd(pathname);
pathname[size-1] = '\0';
strncpy(buf,pathname,size);
}
X
/*****************************************************************************/
/* Funktion ueberprueft, ob uebergebener Name ein Directory oder eine Datei  */
/* ist.                                                                      */
/*                                                                           */
/* Aufruf: Is_direct(name);                                                  */
/*                                                                           */
/* Parameter: char *name; Name der Datei, die als Directory getestet werden  */
/*                        soll.                                              */
/* Rueckgabe: int;  0 Uebergebener Name war kein Directory, oder Name war    */
/*                    ueberhaupt kein Eintrag in dem aktuellen Directory, der*/
/*                    opendir() zu oeffnen war.                              */
/*                  1 Uebergebener Name war Directory                        */
/*****************************************************************************/
int Is_direct(name)
X    char *name;
{
X    struct stat buf;
X
X    stat(name,&buf);         
X     
X    if(buf.st_mode & S_IFDIR)
X        return(1);              
X    else
X        return(0);
}
X
/*****************************************************************************/
/* Funktion zaehlt Eintrage im aktuellen Verzeichnis, die zum Pattern passen */
/* oder ein Directoryeintrag sind.                                           */
/*                                                                           */
/* Aufruf: count_eintraege();                                                */
/*                                                                           */
/* Parameter: keine;                                                         */
/* Rueckgabe: short; Anzahl der Eintraege im Directory, die der Bedingung    */
/*                   genuegt haben.                                          */
/*****************************************************************************/
short count_eintraege()
{
X   DIR *dirp;                      /* offenes Directory */
X   struct direct *datei;           /* gelesenener Directoryeintrag */
X   short counter=0;                
X
X   dirp = opendir(".");
X   while((datei = readdir(dirp)) != NULL)
X     if((match(datei->d_name,patt_global)) || (Is_direct(datei->d_name)))
X	 counter ++;
X
X   closedir(dirp);
X   return(counter);
}
X  
/*****************************************************************************/
/* Funktion ueberprueft, ob uebergeneber String zu dem uebergebenen Pattern  */
/* passt.                                                                    */
/*                                                                           */
/* Aufruf: match(string,pattern);                                            */
/*                                                                           */
/* Parameter: char *string; String, der uenerprueft werden soll              */
/*            char *pattern; Pattern mit dem der Striong verglichen wird     */
/* Rueckgabe: 0 String passt nicht zu dem uebergebenen Pattern               */
/*            1 String passt zu dem ubergebenen Pattern                      */
/*****************************************************************************/
int match(sstring,pattern)
char *sstring,*pattern;
{
X     char *st,*pa;
X     int lst=0,lpa=0,ist=1,ipa=1;
X
X     st=sstring; while (*st++) lst++; st=sstring; /* Laenge berechnen */
X     pa=pattern;while (*pa++) lpa++; pa=pattern;/* Laenge berechnen */
X     if (!(lst*lpa)) return(0);     /* Ein String war leer */
X
X     while(1)
X	  {
X	  if (*pa == '?')
X	       {
X	       if (ist>lst) return(0);
X	       ++ist; ++st; ++ipa; ++pa;
X	       if ((ist>lst) && (ipa>lpa)) return(1);
X	       if (ipa>lpa) return(0);
X	       continue;
X	       }
X	  if (*pa == '*')
X	       {
X	       if (ipa == lpa) return(1);
X	       ++ipa; ++pa;
X	       if (ist > lst) continue;
X	       do
X		    {
X		    if (match(st,pa)) return(1);
X		    ++ist; ++st;
X		    } while (ist <= lst);
X	       return(0);
X	       }
X	  if ((ist > lst) || (!(*st++ == *pa++))) return(0);
X	  ++ipa;
X	  if ((++ist > lst) && (ipa > lpa)) return(1);
X	  } /* von while */
} /* von match */
X
/*****************************************************************************/
/* Funktion erstellt aus allen passenden Eintraegen im Directory eine Liste, */
/* die an das Listwidget uebergeben werden kann.                             */
/*                                                                           */
/* Aufruf: directory_erstellen(anzahl);                                      */
/*                                                                           */
/* Parameter: short anzahl; anzahl der Eintraege, die in die Liste eingefuegt*/
/*                          werden, um Speicher zu allocieren.               */
/* Rueckgabe: String *; Pointer auf den Listenkopf                           */
/*****************************************************************************/
String *directory_erstellen(short anzahl)
X {
X   static char *offset;            /* Naechste freie Speicherstelle */
X   static DIR *dirp2;              /* offenes Directory */
X   struct direct *datei;           /* Struktur um Dateinamen zu ermitteln */
X   short i=0;                      /* Zaehler */                     
X   char f_name[LAENGE];            /* Filename in passender Laenge */
X   char *eintrag;                  /* Rueckgabe des geprueften Eintrages */
X   String *Liste2;                 /* Liste der bearbeiteten Strings */
X   char *Inhalt2;                  /* Listeninhalt */ 
X   short directory_typ;            /* Eintrag ist Directory */
X   char *stelle;                   /* temp Pointer */
X
X   /* neuen Speicher suchen */
X   Liste2 = (String *)malloc((anzahl+2)*sizeof(Liste));
X   Inhalt2 = offset = (char *)malloc((anzahl+1)*(LAENGE+1)*sizeof(char));
X
X   /* aktuelles Verzeichnis oeffnen */
X   dirp2 = opendir(".");
X
X   directory_typ = 0;
X    
X   /* Directoryeintraege in Liste uebernehmen */
X   i = 0;
X   while((datei = readdir(dirp2)) != NULL)
X     /* Eintrag ueberpruefen mit match-Funktion und ueberpruefen ob Direct. */
X     if((directory_typ = Is_direct(datei->d_name)) ||
X	   (match(datei->d_name,patt_global)))
X         {
X	 sprintf(f_name,"%-20.20s",datei->d_name);
X
X	 /* falls Namen zu lang letzte Stelle mit Stern ausgeben */
X	 if((stelle=index(f_name,' ')) == NULL)  
X	   {
X	   f_name[LAENGE] = '\0';
X	   f_name[LAENGE-1] = '*';
X	   }
X	 if(directory_typ)  /* Directorys wird zur Kennung ein / angehangen */
X	   {
X	     /* nachfolgende Blanks abschneiden */
X	     if((stelle=index(f_name,' ')) != NULL)  
X	       *stelle = '/';
X	     else 
X	       {
X	       f_name[LAENGE-1] = '/';
X	       f_name[LAENGE-2] = '*';
X	       }
X	   }
X	 strcpy(offset,f_name);              /* Stringinhalt uebernehmen */
X	 Liste2[i] = (char *)offset;         /* String in Liste anfuegen */
SHAR_EOF
true || echo 'restore of file_sel.c failed'
fi
echo 'End of  part 1'
echo 'File file_sel.c is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
