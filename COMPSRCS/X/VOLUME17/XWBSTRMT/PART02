Newsgroups: comp.sources.x
Path: uunet!cis.ohio-state.edu!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: cattelan@everest.ee.umn.edu (Russell Cattelan)
Subject: v17i056: xwebster (MOTIF) (REPOST), Part02/03
Message-ID: <1992Apr14.141542.7774@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Nntp-Posting-Host: fascet
Organization: Molecular Simulations, Inc.
References: <csx-17i055-xwebster-motif@uunet.UU.NET>
Date: Tue, 14 Apr 1992 14:15:42 GMT
Approved: dcmartin@msi.com
Lines: 1510

Submitted-by: cattelan@everest.ee.umn.edu (Russell Cattelan)
Posting-number: Volume 17, Issue 56
Archive-name: xwebster-motif/part02

#!/bin/sh
# this is part.02 (part 2 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file Xwebster.ad.hp_widgets continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 2; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping Xwebster.ad.hp_widgets'
else
echo 'x - continuing file Xwebster.ad.hp_widgets'
sed 's/^X//' << 'SHAR_EOF' >> 'Xwebster.ad.hp_widgets' &&
X     Ctrl<Key>H:		delete-previous-character() \n\
X     Meta<Key>D:		delete-next-word() \n\
X     Meta<Key>H:		delete-previous-word() \n\
X     Shift Meta<Key>H:		backward-kill-word() \n\
X     Ctrl<Key>W:		kill-selection() \n\
X     Ctrl<Key>K:		kill-to-end-of-line() \n\
X     Meta<Key>K:		kill-to-end-of-paragraph() \n\
X     Ctrl<Key>Y:		unkill() \n\
X     Meta<Key>Y:		stuff() \n\
X     Ctrl<Key>L:		redraw-display() \n\
X     <FocusIn>:			focus-in() \n\
X     <FocusOut>:		focus-out() \n\
X     <Btn1Down>:		select-start() \n\
X     Button1<PtrMoved>:		extend-adjust() \n\
X     <Btn1Up>:			extend-end() \n\
X     <Btn2Down>:		stuff() \n\
X     <Btn3Down>:		extend-start() \n\
X     Button3<PtrMoved>:		extend-adjust() \n\
X     <Btn3Up>:			extend-end() \n\
X     <Key>Execute:		execute() \n\
X     <Key>:			insert-char() \n\
X     Shift<Key>:		insert-char() \n\
X     <EnterWindow>:		enter() \n\
X     <LeaveWindow>:		leave()
SHAR_EOF
echo 'File Xwebster.ad.hp_widgets is complete' &&
chmod 0644 Xwebster.ad.hp_widgets ||
echo 'restore of Xwebster.ad.hp_widgets failed'
Wc_c="`wc -c < 'Xwebster.ad.hp_widgets'`"
test 19389 -eq "$Wc_c" ||
	echo 'Xwebster.ad.hp_widgets: original size 19389, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= controlpanel.c ==============
if test -f 'controlpanel.c' -a X"$1" != X"-c"; then
	echo 'x - skipping controlpanel.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting controlpanel.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'controlpanel.c' &&
X /* -*-C-*-
********************************************************************************
*
* File:         controlpanel.c
* RCS:          $Header: /home/everest1/cattelan/work/xwebster.motif/RCS/controlpanel.c,v 1.1 1992/03/21 22:39:43 cattelan Exp $
* Description:  Control Panel for Webster
* Author:       Niels Mayer, HPLabs
* Created:      Wed Aug 31 21:40:58 1988
* Modified:     Mon Mar  6 16:08:53 1989 (Niels Mayer) mayer@hplnpm
* Language:     C
* Package:      N/A
* Status:       G-Job
*
* xwebster - dictionary browser
*
* Copyright 1988 Hewlett-Packard Company
*
* Permission to use, copy, modify, and distribute this software and its
* documentation for any purpose and without fee is hereby granted, provided
* that the above copyright notice appear in all copies and that both that
* copyright notice and this permission notice appear in supporting
* documentation, and that the name of HP not be used in advertising or
* publicity pertaining to distribution of the software without specific,
* written prior permission.  HP makes no representations about the
* suitability of this software for any purpose.  It is provided "as is"
* without express or implied warranty.
*
* Please send any improvements, bug fixes, useful modifications, and comments
* to mayer@hplabs.hp.com.
********************************************************************************
*/
static char rcs_identity[] = "@(#)$Header: /home/everest1/cattelan/work/xwebster.motif/RCS/controlpanel.c,v 1.1 1992/03/21 22:39:43 cattelan Exp $";
X
#include "xwebster.h"
#include "user_prefs.h"
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <Xm/PushB.h>
#include <Xm/Text.h>
#include <Xm/TextF.h>
#include <Xm/Form.h>
#include <Xm/LabelG.h>
/*
#include <Xw/PButton.h>
#include <Xw/SText.h>
#include <Xw/TextEdit.h>
#include <Xw/TitleBar.h>
*/
X
static Widget control_panel_Wgt = NULL;
static Widget word_input_Wgt = NULL;
static Widget define_button_Wgt = NULL;
#ifdef DEFINE_FULL 
static Widget define_full_button_Wgt = NULL;
#endif /* define full */
static Widget complete_button_Wgt = NULL;
static Widget endings_button_Wgt = NULL;
static Widget thesaurus_button_Wgt = NULL;
static Widget labelbar_Wgt = NULL;
static Widget formbar_Wgt = NULL;
static Widget quit_button_Wgt = NULL;
static Widget help_button_Wgt = NULL;
static int    controlpanel_active = TRUE;
static int    cur_word_is_from_textedit = TRUE;
X
extern int   Webster_Send(/* char* buf */);  /* from xwebster.c */
extern XtAppContext webster_app;
int moo; /* temp variable */
/******************************************************************************
X * note that this callback is used for 3 different callbacks:
X * 1) called from the controlpanel define_button_Wgt with client_data==NULL,
X *    this proc. assumes that word to be defined is in the word_input_Wgt.
X * 2) called from Controlpanel_Define_Action (which is a actionproc that is
X *    called from the word_input_Wgt) with client_data==NULL, this proc.
X *    again assumes that word to be defined is in the word_input_Wgt.
X * 3) called from a callback on a wordbutton_Wgt in module Wordlist, 
X *    client_data is set to the word to be defined. In this case, 
X *    subsequent calls to Controlpanel_Cur_Word_Is_From_TextEdit()
X *    will return false.
X ******************************************************************************/
XXtCallbackProc 
X  Controlpanel_Define_Callback(widget, client_data, call_data)
Widget widget;
caddr_t client_data;
caddr_t call_data;
{
X  char buf[BUFSIZ];
X  extern Display* display;
X  
X  if (!controlpanel_active) {
X    XBell(display, 100);
X    return(NULL);
X  }
X  
X  Display_Def_Text_Reset();	/* clear the def buffer to show text is coming */
X  XtVaSetValues(define_button_Wgt, 
X                XmNset, TRUE,
X                NULL); /*-action resulted in the callback*/
X  Controlpanel_Deactivate();    /* disallow further input till ready. */
X
X  if (client_data == NULL) {    /* IF not called from Wordlist word button */
X    char* word;                 /* THEN get the word from word_input_Wgt */
X    word = (char *)XmTextFieldGetString(word_input_Wgt);
X    sscanf(word, "%[^\n]", temptext); /* get only one word, no newlines */
X    XtFree(word);
X      sprintf(buf, "DEFINE %s\r\n", temptext);
X      cur_word_is_from_textedit = TRUE;
X  }
X  else {			/* ELSE get the word from the callback data */
X    sprintf(buf, "DEFINE %s\r\n", (char*)client_data);
X    Controlpanel_Set_Input_Word((char*)client_data);
X    cur_word_is_from_textedit = FALSE;
X  }
X  if (!Webster_Send(buf))
X   Controlpanel_Reactivate();
}
X
X
X
static void 
X  Controlpanel_Define_Action(w, event, params, num_params)
Widget w;
XXEvent *event;
String *params;
Cardinal *num_params;
{
X  Controlpanel_Define_Callback(w, NULL, NULL);
}
X
XXtCallbackProc
X  Controlpanel_Define_button_Callback(widget, client_data, call_data)
Widget widget;
caddr_t client_data;
caddr_t call_data;
{
X  char buf[BUFSIZ]; 
X  if (!strcmp(user_prefs.dictionary_source,"next")){
X  sprintf(buf,"INDEX dictionary\r\n");
X  if (!Webster_Send(buf))
X    Controlpanel_Reactivate();
};
X  Controlpanel_Define_Callback(widget, client_data, call_data);
}
X
/******************************************************************************
X *
X ******************************************************************************/
XXtCallbackProc
X  Controlpanel_Thesaurus_button_Callback(widget, client_data, call_data)
Widget widget;
caddr_t client_data;
caddr_t call_data;
{
X  char buf[BUFSIZ];
X  sprintf(buf,"INDEX thesaurus\r\n");
X  if (!Webster_Send(buf))
X    Controlpanel_Reactivate();
X  Controlpanel_Define_Callback(widget, client_data, call_data);
}
X
static void 
X  Controlpanel_Thesaurus_Action(w, event, params, num_params)
X     Widget w;
X     XEvent *event;
X     String *params;
X     Cardinal *num_params;
{
X  Controlpanel_Thesaurus_button_Callback(w, NULL, NULL);
}
/******************************************************************************
X *
X ******************************************************************************/
#ifdef DEFINE_FULL
XXtCallbackuser_prefsProc
X  Controlpanel_Define_full_button_Callback(widget, client_data, call_data)
Widget widget;
caddr_t client_data;
caddr_t call_data;
{
X  char buf[BUFSIZ];
X    sprintf(buf,"INDEX dictionary-full\r\n");
X    if (!Webster_Send(buf))
X      Controlpanel_Reactivate();
X  Controlpanel_Define_Callback(widget, client_data, call_data);
}
/******************************************************************************
X *
X ******************************************************************************/
static void 
X  Controlpanel_Define_full_Action(w, event, params, num_params)
X     Widget w;
X     XEvent *event;
X     String *params;
X     Cardinal *num_params;
{
X  Controlpanel_Define_full_button_Callback(w, NULL, NULL);
}
/******************************************************************************
X *
X ******************************************************************************/
#endif /* Define Full */
static XtCallbackProc 
Controlpanel_Complete_Callback(widget, client_data, call_data)
X     Widget widget;
X     caddr_t client_data;
X     caddr_t call_data;
{
X  char buf[BUFSIZ];
X  char* word;
X  extern Display* display;
X
X  if (!controlpanel_active) {
X    XBell(display, 100);
X    return(NULL);
X  }
X
X  /* show em which button they hit even if a key-*/
X  XtVaSetValues(complete_button_Wgt,
X		XmNset, TRUE,
X		NULL); /*-action resulted in the callback*/
X  Controlpanel_Deactivate();	/* disallow further input till ready. */
X  word = (char *)XmTextFieldGetString(word_input_Wgt);
X  sscanf(word, "%[^\n]", temptext); /* don't get newlines */
X  XtFree(word); 
X  sprintf(buf, "COMPLETE %s\r\n", temptext);
X  cur_word_is_from_textedit = TRUE;
X  if (!Webster_Send(buf))
X    Controlpanel_Reactivate();
}
X
/******************************************************************************
X *
X ******************************************************************************/
static void 
X  Controlpanel_Complete_Action(w, event, params, num_params)
X     Widget w;
X     XEvent *event;
X     String *params;
X     Cardinal *num_params;
{
X  Controlpanel_Complete_Callback(w, NULL, NULL);
}
X
/******************************************************************************
X *
X ******************************************************************************/
static XtCallbackProc 
Controlpanel_Endings_Callback(widget, client_data, call_data)
X     Widget widget;
X     caddr_t client_data;
X     caddr_t call_data;
{
X  char buf[BUFSIZ];
X  char* word;
X  extern Display* display;
X
X  if (!controlpanel_active) {
X    XBell(display, 100);
X    return(NULL);
X  }
X   
X  XtVaSetValues(endings_button_Wgt,
X		XmNset, TRUE,
X		NULL); /*-action resulted in the callback*/
X  Controlpanel_Deactivate();	/* disallow further input till ready. */
X  word = (char *)XmTextFieldGetString(word_input_Wgt);
X  sscanf(word, "%[^\n]", temptext); /* get only one word, no newlines */
X  XtFree(word); 
X  sprintf(buf, "ENDINGS %s\r\n", temptext);
X  cur_word_is_from_textedit = TRUE;
X  if (!Webster_Send(buf))
X    Controlpanel_Reactivate();
}
X
/******************************************************************************
X *
X ******************************************************************************/
static void 
X  Controlpanel_Endings_Action(w, event, params, num_params)
X     Widget w;
X     XEvent *event;
X     String *params;
X     Cardinal *num_params;
{
X  Controlpanel_Endings_Callback(w, NULL, NULL);
}
X
X
/******************************************************************************
X *
X ******************************************************************************/
static XtCallbackProc 
X  Controlpanel_Quit_Callback(widget, client_data, call_data)
X     Widget widget;
X     caddr_t client_data;
X     caddr_t call_data;
{
X  /* 
X   * note that the quit button is the only one that remains active all the time.
X   * That's becauese it's ok to quit xwebster anytime even when it hasn't
X   * completed it's transaction with the webster server.
X   */
X  extern int webster_Socket;	/* in main.c */
X  close(webster_Socket);
X  exit(0);
}
X
X
/******************************************************************************
X *
X ******************************************************************************/
static XtCallbackProc 
Controlpanel_Help_Callback(widget, client_data, call_data)
X     Widget widget;
X     caddr_t client_data;
X     caddr_t call_data;
{
X  extern Display* display;
X
X  if (!controlpanel_active) {
X    XBell(display, 100);
X    return(NULL);
X  }
X
X  Display_Def_Show_Help();
}
X
X
/******************************************************************************
X *
X ******************************************************************************/
static void 
Controlpanel_Noop_Action(w, event, params, num_params)
X     Widget w;
X     XEvent *event;
X     String *params;
X     Cardinal *num_params;
{
X  extern Display* display;
X
X  XBell(display, 100);
}
X
X
XXtActionsRec word_input_Wgt_actions_table [] = {
X  {"webster-define-word",   Controlpanel_Define_Action},
X  {"webster-complete-word", Controlpanel_Complete_Action},
X  {"webster-list-endings",  Controlpanel_Endings_Action},
X  {"webster-thesaurus-word", Controlpanel_Thesaurus_Action},
X  {"webster-no-op",         Controlpanel_Noop_Action},
};
X
/******************************************************************************
X *
X ******************************************************************************/
void
X  Controlpanel_Init(w)
Widget w;
{
X  control_panel_Wgt = XtVaCreateManagedWidget("control_panel", 
X					      xmFormWidgetClass,
X					      w,
X					      NULL);
X  word_input_Wgt = XtVaCreateManagedWidget("word_input",
X					   xmTextFieldWidgetClass,
X					   control_panel_Wgt, 
X					   XmNbottomAttachment, XmATTACH_FORM,
X					   XmNtopAttachment, XmATTACH_FORM,
X					   NULL); 
/*
X  XtAddCallback(word_input_Wgt,
X		XmNactivateCallback, 
X		(XtCallbackProc)Controlpanel_Define_Callback, 
X		NULL);
*/
X  XtAppAddActions(webster_app,
X		  word_input_Wgt_actions_table, 
X		  XtNumber(word_input_Wgt_actions_table));
X  
X
X  define_button_Wgt = XtVaCreateManagedWidget("define", 
X					      xmPushButtonWidgetClass, 
X					      control_panel_Wgt, 
X					      XmNleftAttachment,XmATTACH_WIDGET, 
X					      XmNleftWidget, word_input_Wgt, 
X					      XmNbottomAttachment, XmATTACH_FORM, 
X					      XmNtopAttachment, XmATTACH_FORM,
X					      NULL);
X  
X  XtAddCallback(define_button_Wgt, 
X		XmNactivateCallback, 
X		(XtCallbackProc)Controlpanel_Define_button_Callback, 
X		NULL);
X
#ifdef DEFINE_FULL
define_full_button_Wgt = XtVaCreateManagedWidget("define_full", 
X						 xmPushButtonWidgetClass, 
X						 control_panel_Wgt, 
X						 XmNleftAttachment,XmATTACH_WIDGET, 
X						 XmNleftWidget, define_button_Wgt, 
X						 XmNbottomAttachment, XmATTACH_FORM, 
X						 XmNtopAttachment, XmATTACH_FORM,
X						 NULL);
X
X  XtAddCallback(define_full_button_Wgt, 
X		XmNactivateCallback, 
X		(XtCallbackProc)Controlpanel_Define_full_button_Callback, 
X		NULL);
#endif /* Define full */
X  complete_button_Wgt = XtVaCreateManagedWidget("complete", 
X						xmPushButtonWidgetClass, 
X						control_panel_Wgt, 
X						XmNleftAttachment,XmATTACH_WIDGET, 
#ifdef DEFINE_FULL
X						XmNleftWidget,define_full_button_Wgt, 
#else
X						XmNleftWidget,define_button_Wgt,
#endif /* Define full */
X						XmNbottomAttachment, XmATTACH_FORM, 
X						XmNtopAttachment, XmATTACH_FORM,
X						NULL);
X  
X  XtAddCallback(complete_button_Wgt, 
X		XmNactivateCallback, 
X		(XtCallbackProc)Controlpanel_Complete_Callback, 
X		NULL);
X
X  endings_button_Wgt = XtVaCreateManagedWidget("endings", 
X					       xmPushButtonWidgetClass, 
X					       control_panel_Wgt,
X					       XmNleftAttachment,XmATTACH_WIDGET, 
X					       XmNleftWidget,complete_button_Wgt, 
X					       XmNbottomAttachment, XmATTACH_FORM, 
X					       XmNtopAttachment, XmATTACH_FORM,
X					       NULL);
X  XtAddCallback(endings_button_Wgt, 
X		XmNactivateCallback, 
X		(XtCallbackProc)Controlpanel_Endings_Callback, 
X		NULL);
X  
X  thesaurus_button_Wgt = XtVaCreateWidget("thesaurus", 
X					  xmPushButtonWidgetClass, 
X					  control_panel_Wgt,
X					  XmNleftAttachment,XmATTACH_WIDGET, 
X					  XmNleftWidget, endings_button_Wgt ,  
X					  XmNbottomAttachment, XmATTACH_FORM, 
X					  XmNtopAttachment, XmATTACH_FORM,
X					  NULL);
X  if (!strcmp(user_prefs.dictionary_source,"next"))
X    XtManageChild(thesaurus_button_Wgt);
X  
X  XtAddCallback(thesaurus_button_Wgt, 
X		XmNactivateCallback, 
X		(XtCallbackProc)Controlpanel_Thesaurus_button_Callback, 
X		NULL);
X  
X  {/*
X    * force the controlpanel to have no sash's -- do this by setting XtNmin
X    * and XtNmax constraint resources to the same values -- the height of the
X    * widget. See XWVPANED(3x) for details.
X    */
X    Dimension height;
X    XtVaGetValues(control_panel_Wgt, 
X		  XmNheight, &height,
X		  NULL);
X
X    XtVaSetValues(control_panel_Wgt, 
X		  XmNminHeight, height,
X		  XmNmaxHeight, height,
X		  NULL);
X
X  }
}
X
/******************************************************************************
X *
X ******************************************************************************/
void
Controlpanel_Titlebar_Init(parent_Wgt)
X     Widget parent_Wgt;
{
X  extern char xwebster_version[]; 
X  XmString label = XmStringCreateSimple(xwebster_version);
X
X  formbar_Wgt = XtVaCreateManagedWidget("titlebar",
X					 xmFormWidgetClass,
X					 parent_Wgt, 
X					 NULL);
X
X    quit_button_Wgt = XtVaCreateManagedWidget("quit", 
X					      xmPushButtonWidgetClass,
X					      formbar_Wgt,
X					      XmNleftAttachment, XmATTACH_FORM,
X					      NULL);
X
X  XtAddCallback(quit_button_Wgt,
X		XmNactivateCallback, 
X		(XtCallbackProc)Controlpanel_Quit_Callback,
X		NULL);
X  
X  help_button_Wgt = XtVaCreateManagedWidget("help",
X					    xmPushButtonWidgetClass,
X					    formbar_Wgt,
X					    XmNrightAttachment,XmATTACH_FORM,
X					    NULL);
X  XtAddCallback(help_button_Wgt, 
X		XmNactivateCallback, 
X		(XtCallbackProc)Controlpanel_Help_Callback, 
X		NULL);
X
X  labelbar_Wgt = XtVaCreateManagedWidget("labelbar",
X					 xmLabelWidgetClass,
X					 formbar_Wgt, 
X					 XmNlabelString, label,
X					 XmNleftAttachment, XmATTACH_WIDGET,
X					 XmNleftWidget, quit_button_Wgt,
X					 XmNalignment, XmALIGNMENT_CENTER,
X					 XmNrightAttachment, XmATTACH_WIDGET,
X					 XmNrightWidget, help_button_Wgt,
X					 NULL);
X  XmStringFree(label);
X
X  
X
X  {/*
X    * force the titlebar to have no sash's -- do this by setting XtNmin
X    * and XtNmax constraint resources to the same values -- the height of the
X    * widget. See XWVPANED(3x) for details.
X    */
X    Dimension height;
X    XtVaGetValues(formbar_Wgt,
X		  XmNheight, &height,
X		  NULL);
X    XtVaSetValues(formbar_Wgt, 
X		  XmNminHeight, height,
X		  XmNmaxHeight, height,
X		  NULL);
X  }
}
X
X
/******************************************************************************
X *
X ******************************************************************************/
Controlpanel_Titlebar_Set_Label(str)
X     char* str;
{
X XmString label = XmStringCreateSimple(str);
X  XtVaSetValues(labelbar_Wgt, 
X	      XmNlabelString, label,
X	      NULL);
X XmStringFree(label);
}
X
X
/******************************************************************************
X *
X ******************************************************************************/
Controlpanel_Deactivate()
{
X  controlpanel_active = FALSE;
X  
#ifndef SLOW_X_SERVER
X  XtSetSensitive(define_button_Wgt, FALSE);
#ifdef DEFINE_FULL
X  XtSetSensitive(define_full_button_Wgt, FALSE);
#endif /* Define full */
X  XtSetSensitive(complete_button_Wgt, FALSE);
X  XtSetSensitive(endings_button_Wgt, FALSE);
X  XtSetSensitive(thesaurus_button_Wgt, FALSE);
X  /* XtSetSensitive(quit_button_Wgt, FALSE); --> allow quit while server busy*/
X  XtSetSensitive(help_button_Wgt, FALSE);
X  Wordlist_Deactivate();
#endif
}
X
/******************************************************************************
X *
X ******************************************************************************/
Controlpanel_Reactivate()
{
X  controlpanel_active = TRUE;
X
#ifndef SLOW_X_SERVER
X  XtSetSensitive(define_button_Wgt, TRUE);
#ifdef DEFINE_FULL
X  XtSetSensitive(define_full_button_Wgt, TRUE);
#endif /* Define Full */
X  XtSetSensitive(complete_button_Wgt, TRUE);
X  XtSetSensitive(endings_button_Wgt, TRUE); 
X  XtSetSensitive(thesaurus_button_Wgt, TRUE);
X  /* XtSetSensitive(quit_button_Wgt, TRUE); */
X  XtSetSensitive(help_button_Wgt, TRUE);
X  Wordlist_Reactivate();
#endif
X
X  /* 
X   * the following is a lamo hack to fix a "feature" of PushButtons -- when they're
X   *  pressed, they invert colors. if the push callback then insensitizes them,
X   *  upon resensitizing they'll not invert back to the "off" color. So force them
X   *  off here. 
X   */
X
X  XtVaSetValues(define_button_Wgt, 
X		XmNset, FALSE,
X		NULL); 
#ifdef DEFINE_FULL
X  XtVaSetValues(define_full_button_Wgt, 
X		XmNset, FALSE,
X		NULL);
#endif /* Define full */
X  XtVaSetValues(complete_button_Wgt, 
X		XmNset, FALSE,
X		NULL);
X  XtVaSetValues(endings_button_Wgt, 
X		XmNset, FALSE,
X		NULL);
X  XtVaSetValues(thesaurus_button_Wgt, 
X		XmNset, FALSE,
X		NULL); 
X  XtVaSetValues(quit_button_Wgt, 
X		XmNset, FALSE,
X		NULL);
X  XtVaSetValues(help_button_Wgt, 
X		XmNset, FALSE,
X		NULL);
X
}
X
/******************************************************************************
X *
X ******************************************************************************/
Controlpanel_Set_Input_Word(word)
X     char* word;
{
X  XmTextFieldSetString(word_input_Wgt,word); 
X  XmTextFieldSetInsertionPosition(word_input_Wgt, XmTextGetLastPosition(word_input_Wgt));
}
X
/******************************************************************************
X *
X ******************************************************************************/
int Controlpanel_Cur_Word_Is_From_TextEdit()
{
X  return(cur_word_is_from_textedit);
}
SHAR_EOF
chmod 0644 controlpanel.c ||
echo 'restore of controlpanel.c failed'
Wc_c="`wc -c < 'controlpanel.c'`"
test 19720 -eq "$Wc_c" ||
	echo 'controlpanel.c: original size 19720, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= display_def.c ==============
if test -f 'display_def.c' -a X"$1" != X"-c"; then
	echo 'x - skipping display_def.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting display_def.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'display_def.c' &&
/* -*-C-*-
********************************************************************************
*
* File:         display_def.c
* RCS:          $Header: /home/everest1/cattelan/work/xwebster.motif/RCS/display_def.c,v 1.1 1992/03/21 22:39:43 cattelan Exp $
* Description:  Module for clearing, appending to and displaying a definition.
* Author:       Niels Mayer, HPLabs
* Created:      Wed Aug 31 19:17:42 1988
* Modified:     Mon Mar  6 17:16:58 1989 (Niels Mayer) mayer@hplnpm
* Language:     C
* Package:      N/A
* Status:       G-Job
*
* xwebster - dictionary browser
*
* Copyright 1988 Hewlett-Packard Company
*
* Permission to use, copy, modify, and distribute this software and its
* documentation for any purpose and without fee is hereby granted, provided
* that the above copyright notice appear in all copies and that both that
* copyright notice and this permission notice appear in supporting
* documentation, and that the name of HP not be used in advertising or
* publicity pertaining to distribution of the software without specific,
* written prior permission.  HP makes no representations about the
* suitability of this software for any purpose.  It is provided "as is"
* without express or implied warranty.
*
* Please send any improvements, bug fixes, useful modifications, and comments
* to mayer@hplabs.hp.com.
********************************************************************************
*/
static char rcs_identity[] = "@(#)$Header: /home/everest1/cattelan/work/xwebster.motif/RCS/display_def.c,v 1.1 1992/03/21 22:39:43 cattelan Exp $";
X
#include "xwebster.h"
#include "user_prefs.h"
#include <Xm/ScrolledW.h>
#include <Xm/Text.h>
X
X
static Widget display_Wgt = NULL;
static char   text[16384]; /* hopefully no def will be longer than this! */
static int    end_idx = 0;
X
X
/******************************************************************************
X * KLUDGE_O_RAMA: on select, invert the text in the StaticText widget to show 
X * that something's being done and store the definition in the cut buffer.
X ******************************************************************************/
static XtCallbackProc 
X  Display_Select_Callback(widget, client_data, call_data)
X     Widget widget;
X     caddr_t client_data;
X     caddr_t call_data;
{
X  Pixel foreground;
X  Pixel background;
X  char* displ_text;
X
X  XtVaGetValues(widget, 
X	      XmNforeground, &foreground,
X	      XmNbackground, &background,
X	      NULL);
X
X  XtVaSetValues(widget, 
X	      XmNforeground, background,
X	      XmNbackground, foreground,
X	      NULL);
X  
X  XtVaGetValues(display_Wgt, 
X	      XmNstring, &displ_text,
X	      NULL);
X  XStoreBuffer(XtDisplay(widget), displ_text, strlen(displ_text), 0);
}
X
X
/******************************************************************************
X * KLUDGE_O_RAMA: on release, uninvert the text in the StaticText widget.
X ******************************************************************************/
static XtCallbackProc 
X  Display_Release_Callback(widget, client_data, call_data)
X     Widget widget;
X     caddr_t client_data;
X     caddr_t call_data;
{
X  Pixel foreground;
X  Pixel background;
X
X  /* 
X   * Uninvert the display that was inverted in Display_Select_Callback
X   */
X
X  XtVaGetValues(widget,
X	      XmNforeground, &foreground,
X	      XmNbackground, &background,
X	      NULL);
X
X  XtVaSetValues(widget, 
X	      XmNforeground, background,
X	      XmNbackground, foreground,
X	      NULL);
}
X
X
/******************************************************************************
X *
X ******************************************************************************/
void
X  Display_Def_Init(w)
X     Widget w;
{
X
X    Widget display_scroller_Wgt = XtVaCreateManagedWidget("display_scroller", 
X							  xmScrolledWindowWidgetClass,
X							  w, 
X							  XmNscrollingPolicy, XmAPPLICATION_DEFINED,
X							  XmNscrollHorizontal, False,
X							  XmNwordWrap, True,
X							  NULL);
X
X    display_Wgt = XtVaCreateManagedWidget("display", 
X					  xmTextWidgetClass, 
X					  display_scroller_Wgt, 
X					  XmNeditMode, XmMULTI_LINE_EDIT, 
X					  XmNeditable, FALSE,
X					  NULL);
X
X
X    XtAddCallback(display_Wgt, 
X		  XmNactivateCallback,  
X		  (XtCallbackProc) Display_Select_Callback, 
X		  NULL);
/*     XtAddCallback(display_Wgt, XmNrelease, Display_Release_Callback, NULL); */
/*    XtAddCallback(display_Wgt, XmNactivateCallback, Display_Release_Callback, NULL);*/
X
}
X
X
/******************************************************************************
X *
X ******************************************************************************/
Display_Def_Text_Reset()
{
X  /* Set it to null to clear the current text */
X  XmTextSetString(display_Wgt,NULL);
}
X
X
/******************************************************************************
X *
X ******************************************************************************/
Display_Def_Text_Append(intext)
X     char* intext;
{
X  /* Insert seems to work better for mutiple lines, there may be a better way although */
X  XmTextInsert(display_Wgt, XmTextGetLastPosition(display_Wgt),intext);
}
X
X
/******************************************************************************
X *
X ******************************************************************************/
Display_Def_Refresh()
{
X  /* 
X    *This function could probably be removed  but I don't want to 
X    *Bother with it right now, not that important
X     */
X  XmTextSetInsertionPosition(display_Wgt, 0);
}
X
X
/******************************************************************************
X *
X ******************************************************************************/
Display_Def_Show_Help()
{
Display_Def_Text_Reset();
Display_Def_Text_Append(user_prefs.help_text);
Display_Def_Refresh();
}
SHAR_EOF
chmod 0644 display_def.c ||
echo 'restore of display_def.c failed'
Wc_c="`wc -c < 'display_def.c'`"
test 5712 -eq "$Wc_c" ||
	echo 'display_def.c: original size 5712, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= patchlevel.h ==============
if test -f 'patchlevel.h' -a X"$1" != X"-c"; then
	echo 'x - skipping patchlevel.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting patchlevel.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'patchlevel.h' &&
#define PATCHLEVEL 0
SHAR_EOF
chmod 0644 patchlevel.h ||
echo 'restore of patchlevel.h failed'
Wc_c="`wc -c < 'patchlevel.h'`"
test 21 -eq "$Wc_c" ||
	echo 'patchlevel.h: original size 21, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= user_prefs.h ==============
if test -f 'user_prefs.h' -a X"$1" != X"-c"; then
	echo 'x - skipping user_prefs.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting user_prefs.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'user_prefs.h' &&
/* -*-C-*-
********************************************************************************
*
* File:         user_prefs.h
* RCS:          $Header: /home/everest1/cattelan/work/xwebster.motif/RCS/user_prefs.h,v 1.1 1992/03/21 22:39:43 cattelan Exp $
* Description:  type definition and global datastructure for user preferences
* Author:       Niels Mayer, HPLabs
* Created:      Thu Aug 11 00:06:04 1988
* Modified:     Tue Sep 13 15:34:34 1988 (Niels Mayer) mayer@hplnpm
* Language:     C
* Package:      N/A
* Status:       G-Job
*
* xwebster - dictionary browser
*
* Copyright 1988 Hewlett-Packard Company
*
* Permission to use, copy, modify, and distribute this software and its
* documentation for any purpose and without fee is hereby granted, provided
* that the above copyright notice appear in all copies and that both that
* copyright notice and this permission notice appear in supporting
* documentation, and that the name of HP not be used in advertising or
* publicity pertaining to distribution of the software without specific,
* written prior permission.  HP makes no representations about the
* suitability of this software for any purpose.  It is provided "as is"
* without express or implied warranty.
*
* Please send any improvements, bug fixes, useful modifications, and comments
* to mayer@hplabs.hp.com.
********************************************************************************
*/
static char rcs_identity_user_prefs[] = "@(#)$Header: /home/everest1/cattelan/work/xwebster.motif/RCS/user_prefs.h,v 1.1 1992/03/21 22:39:43 cattelan Exp $";
X
typedef struct {
X  String help_text;
X  String host_addr_list;	/* a list of whitespace separated host addrs */
X  int    host_port;
X  String host_service_name;
X  int    num_words_before_refresh;
X  String dictionary_source;
} USER_PREFS_DATA, *USER_PREFS_DATA_PTR;
X
extern USER_PREFS_DATA user_prefs;
SHAR_EOF
chmod 0644 user_prefs.h ||
echo 'restore of user_prefs.h failed'
Wc_c="`wc -c < 'user_prefs.h'`"
test 1870 -eq "$Wc_c" ||
	echo 'user_prefs.h: original size 1870, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= wordlist.c ==============
if test -f 'wordlist.c' -a X"$1" != X"-c"; then
	echo 'x - skipping wordlist.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting wordlist.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'wordlist.c' &&
/* -*-C-*-
********************************************************************************
*
* File:         wordlist.c
* RCS:          $Header: /home/everest1/cattelan/work/xwebster.motif/RCS/wordlist.c,v 1.1 1992/03/21 22:39:43 cattelan Exp $
* Description:  Module to display a list of words
* Author:       Niels Mayer, HPLabs
* Created:      Wed Aug 31 21:17:29 1988
* Modified:     Mon Mar  6 17:17:00 1989 (Niels Mayer) mayer@hplnpm
* Language:     C
* Package:      N/A
* Status:       G-Job
*
* xwebster - dictionary browser
*
* Copyright 1988 Hewlett-Packard Company
*
* Permission to use, copy, modify, and distribute this software and its
* documentation for any purpose and without fee is hereby granted, provided
* that the above copyright notice appear in all copies and that both that
* copyright notice and this permission notice appear in supporting
* documentation, and that the name of HP not be used in advertising or
* publicity pertaining to distribution of the software without specific,
* written prior permission.  HP makes no representations about the
* suitability of this software for any purpose.  It is provided "as is"
* without express or implied warranty.
*
* Please send any improvements, bug fixes, useful modifications, and comments
* to mayer@hplabs.hp.com.
********************************************************************************
*/
static char rcs_identity[] = "@(#)$Header: /home/everest1/cattelan/work/xwebster.motif/RCS/wordlist.c,v 1.1 1992/03/21 22:39:43 cattelan Exp $";
X
#include "xwebster.h"
#include "user_prefs.h"
#include <Xm/ScrolledW.h>
#include <Xm/RowColumn.h>
#include <Xm/PushB.h>
X
static Widget wordlist_Wgt = NULL;
static Widget wordlist_scroller_Wgt = NULL;
static Widget wordlist[16384];	/* hopefully, people won't be listing this many words */
static int    wordlist_base = 0; /* points to the first elt to be managed */
static int    wordlist_idx = 0;	/* points to the elt after last in wordlist */
X
extern XtCallbackProc Controlpanel_Define_Callback();
X
/******************************************************************************
X *
X ******************************************************************************/
Wordlist_Init(parent_Wgt)
X     Widget parent_Wgt;
{
X  wordlist_scroller_Wgt = XtVaCreateManagedWidget("wordlist_scroller", 
X						  xmScrolledWindowWidgetClass,
X						  parent_Wgt,
X						  XmNscrollingPolicy, XmAUTOMATIC,
X						  NULL);
X  wordlist_Wgt = XtVaCreateManagedWidget("wordlist", 
X					 xmRowColumnWidgetClass,
X					 wordlist_scroller_Wgt,
X					 XmNadjustLast, False,
X					 XmNpacking, XmPACK_COLUMN,
X					 NULL);
}
X
X
/******************************************************************************
X * Clears all the buttons.
X ******************************************************************************/
Wordlist_Reset()
{
X  register int i;
X
X  /*
X   * the following seems to prevent a ridiculous amount of display updating 
X   * thatwas occuring as each widget got deleted and others moved to fill the
X   * gap
X   */
X  XtUnmanageChildren(wordlist, wordlist_idx);
X
X  /*
X   * Now we can delete all the word widgets with a minimum of display noize
X   */
X  for (i=0; (i < wordlist_idx); i++) {
X    XtDestroyWidget(wordlist[i]);
X  }
X  wordlist_idx = 0;
X  wordlist_base = 0;
}
X
/******************************************************************************
X *
X ******************************************************************************/
static XtCallbackProc Wordlist_Button_Destroy_Callback(widget, client_data, call_data)
X     Widget widget;
X     caddr_t client_data;
X     caddr_t call_data;
{
X  XtFree(client_data);		/* frees the string containing the word */
}
X
/******************************************************************************
X *
X ******************************************************************************/
Wordlist_Add(str)
X     char* str;
{
X  Widget wordbutton_Wgt;
X  XmString label;
X  char* word;
X
X  label = XmStringCreateSimple(str);
X  wordbutton_Wgt = XtVaCreateWidget("word", 
X				    xmPushButtonWidgetClass,
X				    wordlist_Wgt,
X				    XmNlabelString, label,
X				    NULL);
X  XmStringFree(label);
X  word = COPY_STRING(str);
X  XtAddCallback(wordbutton_Wgt, 
X		XmNactivateCallback, 
X		(XtCallbackProc)Controlpanel_Define_Callback, 
X		word);
X  
X  XtAddCallback(wordbutton_Wgt, 
X		XmNdestroyCallback, /* on destroy, of Wgt, dealloc the word */
X		(XtCallbackProc)Wordlist_Button_Destroy_Callback, 
X		word);
X  XtSetSensitive(wordbutton_Wgt, FALSE);
X  wordlist[wordlist_idx++] = wordbutton_Wgt;
X  
X  /*
X   * Refresh the display of words every <num_words_before_refresh> words
X   */
X  if ((wordlist_idx % user_prefs.num_words_before_refresh) == 0) {
X    XtManageChildren(&wordlist[wordlist_base], (wordlist_idx - wordlist_base));
X    wordlist_base += user_prefs.num_words_before_refresh;
X  }
}
X
/******************************************************************************
X * 
X ******************************************************************************/
Wordlist_Show()
{
X  register int i;
X  
X  for (i=0; (i < wordlist_idx); i++) {
X    XtSetSensitive(wordlist[i], TRUE);
X  }
X  XtManageChildren(wordlist, wordlist_idx);
}
X
/******************************************************************************
X * Desensitizes wordlist buttons
X ******************************************************************************/
Wordlist_Deactivate()
{
X  register int i;
X
X  for (i=0; (i < wordlist_idx); i++) {
X    XtSetSensitive(wordlist[i], FALSE);
X  }
}
X
/******************************************************************************
X * Resensitizes wordlist buttons
X ******************************************************************************/
Wordlist_Reactivate()
{
X  register int i;
X
X  ARGLIST_RESET();
X  ARGLIST_ADD(XmNset, FALSE);
X  for (i=0; (i < wordlist_idx); i++) {
X    XtSetSensitive(wordlist[i], TRUE);
X    XtSetValues(wordlist[i], ARGLIST());
X  }
}
SHAR_EOF
chmod 0644 wordlist.c ||
echo 'restore of wordlist.c failed'
Wc_c="`wc -c < 'wordlist.c'`"
test 5889 -eq "$Wc_c" ||
	echo 'wordlist.c: original size 5889, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xwebster.c ==============
if test -f 'xwebster.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xwebster.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xwebster.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xwebster.c' &&
/* -*-C-*-
********************************************************************************
*
* File:         xwebster.c
* RCS:          $Header: /home/everest1/cattelan/work/xwebster.motif/RCS/xwebster.c,v 1.1 1992/03/21 22:39:43 cattelan Exp $
* Description:  X11 + HP-Xwidgets interface to a webster dictionary server
* Author:       Niels Mayer, HPLabs
* Created:      Wed Aug 31 14:09:08 1988
* Modified:     Mon Mar  6 03:43:14 1989 (Niels Mayer) mayer@hplnpm
* Language:     C
* Package:      N/A
* Status:       G-Job
*
* xwebster - dictionary browser
*
* Copyright 1988 Hewlett-Packard Company
*
* Permission to use, copy, modify, and distribute this software and its
* documentation for any purpose and without fee is hereby granted, provided
* that the above copyright notice appear in all copies and that both that
* copyright notice and this permission notice appear in supporting
* documentation, and that the name of HP not be used in advertising or
* publicity pertaining to distribution of the software without specific,
* written prior permission.  HP makes no representations about the
* suitability of this software for any purpose.  It is provided "as is"
* without express or implied warranty.
*
* Please send any improvements, bug fixes, useful modifications, and comments
* to mayer@hplabs.hp.com.
********************************************************************************
*/
static char rcs_identity[] = "@(#)$Header: /home/everest1/cattelan/work/xwebster.motif/RCS/xwebster.c,v 1.1 1992/03/21 22:39:43 cattelan Exp $";
char xwebster_version[] = "Xwebster, version 2.0";
X
/* 
X * Some aspects of this program were inspired by the first
X * C-language translation of the webster client program, webster.c, done by:
X *                   "David A. Curry
X *                    Purdue University
X *                    Engineering Computer Network
X *                    April, 1986"
X * The only copyright notice appearing in the webster.c source is:
X *   "Webster's 7th Collegiate Dictionary, Copyright (C) 1963 by Merriam-Webster,
X *    Inc.  No part of this information may be copied or reprinted without the
X *    express written consent of the publisher."
X */
X
#include "xwebster.h"
#include "user_prefs.h"
#include <stdio.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
/* #include <memory.h> */
#include <Xm/PanedW.h>
#include <X11/cursorfont.h>
X
static XtInputCallbackProc Webster_Get_Server_Output();
static void Process_Webster_Line();
static int Webster_Connect_To_Server();
static void Webster_Reconnect();
static XtInputCallbackProc Webster_Handle_Server_Exception();
static void Webster_Disconnect();
X
int              webster_Socket = NULL;
static XtInputId webster_xinput;
static XtInputId webster_xexcept;
static Widget    toplevel_Wgt = NULL;
/* must be global */
/* change this later when add the EXTERN macro */
XXtAppContext webster_app;
Display*         display;
X
String fallbacks[] = {
X  "*.panel.background: white",
X  "*.control_panel.word_input.columns: 30",
X  "*.panel.wordlist_scroller.height: 100",
X  "*.display_scroller.display.rows: 24",
X  "*.display_scroller.display.columns: 80",
X  "*.wordlist_scroller.wordlist.numColumns: 4",
X   NULL
X  };
X
USER_PREFS_DATA  user_prefs; /* extern declared in user_prefs.h, really here */
X
/* 
X * Data on how user-customization resources are interpreted:
X * this must be kept up to date with data structure USER_PREFS_DATA_PTR 
X * in user_prefs.h
X *
X * My philosophy is to place all my intended defaults in 
X * APPDEFAULTSDIR/Xwebster, so that the program doesn't have to
X * be recompiled just to change a simple default. Thus I don't always have
X * the best defaults in this structure.
X */
X
static XtResource resources[] = {
X  {"helpText", "HelpText",
X     XtRString, sizeof(String),
X     XtOffset(USER_PREFS_DATA_PTR, help_text),
X     XtRString, "Warning -- Someone forgot to install APPDEFAULTSDIR/Xwebster"},
X  {"hostAddrList", "HostAddrList",
X     XtRString, sizeof(String),
X     XtOffset(USER_PREFS_DATA_PTR, host_addr_list),
X     XtRString, ""},
X  {"hostPort", "HostPort",
X     XtRInt, sizeof(int),
X     XtOffset(USER_PREFS_DATA_PTR, host_port),
X     XtRString, ""},
X  {"hostServiceName", "HostServiceName",
X     XtRString, sizeof(String),
X     XtOffset(USER_PREFS_DATA_PTR, host_service_name),
X     XtRString, "webster"},
X  {"numWordsBeforeRefresh", "NumWordsBeforeRefresh",
X     XtRInt, sizeof(int),
X     XtOffset(USER_PREFS_DATA_PTR, num_words_before_refresh),
X     XtRString, "20"},
X  {"dictionarySource","DictonarySource",
X    XtRString, sizeof(String),
X    XtOffset(USER_PREFS_DATA_PTR, dictionary_source),
X    XtRString, "next"}
};
X
X
X
X
/******************************************************************************
X *
X ******************************************************************************/
main(argc, argv)
X     int             argc;
X     char          **argv;
{
X  /* 
X   * Initialize the toolkit, place xwebster-defined resources in user_prefs.
X   */
X  toplevel_Wgt = XtVaAppInitialize(&webster_app,"Xwebster",NULL,0,&argc,argv,fallbacks,NULL);
X
X  XtVaGetApplicationResources(toplevel_Wgt, 
X			    &user_prefs, 
X			    resources, 
X			    XtNumber(resources), 
X			    NULL);
X  {
X    Widget panel_Wgt = XtVaCreateManagedWidget("panel", 
X					       xmPanedWindowWidgetClass,
X					       toplevel_Wgt, 
X					       NULL);
X    Controlpanel_Titlebar_Init(panel_Wgt); 
X    Wordlist_Init(panel_Wgt);
X    Controlpanel_Init(panel_Wgt);
X    Display_Def_Init(panel_Wgt);
X  }
X  XtRealizeWidget(toplevel_Wgt);
X  display = XtDisplay(toplevel_Wgt);
X  XDefineCursor(display, XtWindow(toplevel_Wgt), 
X		XCreateFontCursor(display, XC_plus));
X  XtAppMainLoop(webster_app);
}
X
/******************************************************************************
X * This procedure is called indirectly, via XtAddInput() callback from 
X * XtMainLoop() whenever new input appears on webster_Socket. This callback
X * is setup in procedure Webster_Reconnect().
X * This procedure will read all the data from webster_Socket, and then call 
X * Process_Webster_Line() for each line of input received. If an incomplete 
X * line of text is received, then this procedure will buffer that line until
X * the next time it gets called from the callback.
X ******************************************************************************/
static XtInputCallbackProc 
X  Webster_Get_Server_Output(client_data, source_fildes, id)
caddr_t   client_data;
int       source_fildes;
XXtInputId id;
{
X  unsigned nbytes;
X  char readbuf[BUFSIZ];
X  static char buf[2*BUFSIZ];	/* overkill -- buf shouldn't get longer than BUFSIZ+
X				   the size of any remaining line (max 80). */
X  static char linebuf[BUFSIZ];
X  static int buf_end_idx = 0;	/* init value only on first call */
X  int prev_buf_end_idx;
X  int prev_buf_idx;
X  register int buf_idx;
X  register int linebuf_idx;
X  
X  if (webster_Socket == NULL)
X    Webster_Reconnect();
X  if (webster_Socket == NULL)
X    return;
X  if ((nbytes = read(webster_Socket, readbuf, BUFSIZ)) <= 0) {
X    Webster_Disconnect();
X    return;
X  }
X  memcpy(&(buf[buf_end_idx]), readbuf, nbytes);	/* append new input to buf */
X  buf_end_idx += nbytes;
X  buf[buf_end_idx] = '\000';	/* NULL marks end of buf */
X  prev_buf_end_idx = buf_end_idx;
X
X  buf_idx = 0; 
X  while (1) {			/* process lines till none left: exits w/ break*/
X    linebuf_idx = 0;
X    prev_buf_idx = buf_idx;
X    /** try to copy a line of characters to linebuf, quitting on EOF or \000 **/
X    while (((buf[buf_idx] & 0177) != '\n')
X	   && (buf[buf_idx] != '\000')
X	   && (buf[buf_idx] != '\200'))	/* webster server's <EOF> char */
X      linebuf[linebuf_idx++] = buf[buf_idx++] & 0177;
X
X    if ((buf[buf_idx] & 0177) == '\n') { /* copy to linebuf stopped at LF */
X      linebuf[linebuf_idx-1] = '\n'; /* overwrite CR with LF */
X      linebuf[linebuf_idx] = '\000'; /* NULL terminate linebuf */
X      Process_Webster_Line(linebuf); /* process a line of input */
X      buf_idx++;		/* skip over \n in buf */
X      buf_end_idx -= linebuf_idx + 1; /* shorten by len(linebuf)+len(\n) */
X    }
X    else if (buf[buf_idx] == '\200') { /* copy to linebuf stopped at EOF */
X      Process_Webster_Line(NULL); /* signal special case of EOF */
X      buf_idx++;		/* skip over \200 in buf */
X      buf_end_idx -= linebuf_idx + 1; /* shorten by len(linebuf)+len(\200) */
X    }
X    else {			/* copy to linebuf stopped at \000 (end of buf) */
X      /** IF characters were transferred from buf to linebuf... **/
X      if (prev_buf_end_idx != buf_end_idx)
X	/** ...THEN shiftLeft characters that weren't transferred. **/
X	memccpy(&(buf[0]), &(buf[prev_buf_idx]), '\000', 2*BUFSIZ); 
X      break;			/*@@@---EXIT THE WHILE LOOP---@@@*/
X      /* Buf_end_idx is now really end of buf: on the next call to this proc,
X	 new input will append after remaining unprocessed input in buf.*/
X    }
X  }
}
X
/******************************************************************************
X * This is a "state machine" procedure that is called for every line of text
X * received from the webster server. The state of the webster program is
X * contained in the static variable webster_state which lets this procedure
X * handle the current line of text in a way that depends on what the previous
X * line of text was. For more info on the webster protocol that is embodied in
X * this procedure, do "/usr/bin/telnet 10.0.0.51 103" and then type "HELP<cr>".
X ******************************************************************************/
#define WEBSTER_READY 0
#define GET_WORDLIST 1
#define GET_XREFS 2
#define GET_DEFINITION 3
/*-----------------------------------------------------------------------------*/
static void 
X  Process_Webster_Line(line)
char* line;
{
X  static int num_xrefs;
X  static int webster_state = WEBSTER_READY;
X  static int current_wordlist_is_xrefs = FALSE;
X
X  switch(webster_state) {
X  case WEBSTER_READY:
X    if (line == NULL) {
X      Wordlist_Reset();
X      Controlpanel_Reactivate(); /* ready for user input */
X    } 
X    else if (strncmp(line, "AMBIGUOUS ", 10) == 0) { /* returned by COMPLETE */
X      int num_ambiguities = 0;
X      sscanf(line, "AMBIGUOUS %d\n", &num_ambiguities);
X      sprintf(temptext, "Ambiguous! Matches %d other words.", num_ambiguities);
X      Controlpanel_Titlebar_Set_Label(temptext);
X      XBell(display, 100);
X      Wordlist_Reset();
X      Controlpanel_Reactivate(); /* ready for user input */
X      /* webster_state = WEBSTER_READY; */
X    }
X    else if (strncmp(line, "COMPLETION ", 11) == 0) { /* returned by COMPLETE */
X      sscanf(line, "COMPLETION %s\n", temptext);
X      Controlpanel_Set_Input_Word(temptext);
X      Controlpanel_Titlebar_Set_Label("\000");
X      Wordlist_Reset();
X      Controlpanel_Reactivate(); /* ready for user input */
X      /* webster_state = WEBSTER_READY; */
X    }
X    else if (strncmp(line, "MATCHS 0\n", 9) == 0) { /* returned by ENDINGS */
X      XBell(display, 100);
X      Controlpanel_Titlebar_Set_Label("No matching words!");
X      Wordlist_Reset();
X      Controlpanel_Reactivate(); /* ready for user input */
X      /* webster_state = WEBSTER_READY; */
X    }      
X    else if (strncmp(line, "MATCHS\n", 7) == 0) { /* returned by ENDINGS */
X      Controlpanel_Titlebar_Set_Label("Choose a word:");
X      Wordlist_Reset();
X      webster_state = GET_WORDLIST; current_wordlist_is_xrefs = FALSE;
X    }
X    else if (strncmp(line, "SPELLING 0\n", 11) == 0) { /* returned by DEFINE and SPELL */
X      Controlpanel_Titlebar_Set_Label("No such word!");
X      XBell(display, 100);
X      Wordlist_Reset();
X      Controlpanel_Reactivate(); /* ready for user input */
X      /* webster_state = WEBSTER_READY; */
X    }
X    else if (strncmp(line, "SPELLING\n", 9) == 0) { /* returned by DEFINE */
SHAR_EOF
true || echo 'restore of xwebster.c failed'
fi
echo 'End of  part 2'
echo 'File xwebster.c is continued in part 3'
echo 3 > _shar_seq_.tmp
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
