Newsgroups: comp.sources.x
Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: eyckmans%imec.be@imec.be
Subject: v17i063: xautolock, Part01/01
Message-ID: <1992Apr14.160435.11572@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Nntp-Posting-Host: fascet
Organization: Molecular Simulations, Inc.
Date: Tue, 14 Apr 1992 16:04:35 GMT
Approved: dcmartin@msi.com
Lines: 1440

Xautolock is a program which monitors console activity, and starts up
a program of  your choice if  nothing  happens  during a certain time
interval.  You can use this to automatically start up a screen locker
in case you tend  to forget to do so  manually before having a coffee
break.

                                          Enjoy,

					SDT & MCE

Submitted-by: eyckmans%imec.be@imec.be
Posting-number: Volume 17, Issue 63
Archive-name: xautolock/part01

#!/bin/sh
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 04/14/1992 16:02 UTC by dcmartin@fascet
# Source directory /home/fascet/dcmartin/csx/src/xautolock/xautolock
#
# existing files will NOT be overwritten unless -c is specified
#
#                                                                          
#                                                                          
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#    135 -rw-r--r-- Imakefile
#  10346 -rw-r--r-- Makefile
#    216 -rw-r--r-- Makefile.std
#   3693 -rw-r--r-- README
#     22 -rw-r--r-- patchlevel.h
#  17669 -rw-r--r-- xautolock.c
#   2055 -rw-r--r-- xautolock.man
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= Imakefile ==============
if test -f 'Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Imakefile' &&
HDRS = patchlevel.h 
SRCS = xautolock.c 
OBJS = xautolock.o 
X
SYS_LIBRARIES = -lX11 
X
all:: xautolock
X
ComplexProgramTarget(xautolock)
SHAR_EOF
chmod 0644 Imakefile ||
echo 'restore of Imakefile failed'
Wc_c="`wc -c < 'Imakefile'`"
test 135 -eq "$Wc_c" ||
	echo 'Imakefile: original size 135, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile ==============
if test -f 'Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
# Makefile generated by imake - do not edit!
# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
#
# The cpp used on this machine replaces all newlines and multiple tabs and
# spaces in a macro expansion with a single space.  Imake tries to compensate
# for this, but is not always successful.
#
X
# -------------------------------------------------------------------------
# Makefile generated from "Imake.tmpl" and <Imakefile>
# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
#
# Platform-specific parameters may be set in the appropriate <vendor>.cf
# configuration files.  Site-specific parameters should be set in the file
# site.def.  Full rebuilds are recommended if any parameters are changed.
#
# If your C preprocessor does not define any unique symbols, you will need
# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
# "make World" the first time).
#
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that need to come before
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
# -------------------------------------------------------------------------
# platform-specific configuration parameters - edit sun.cf to change
X
# platform:  $XConsortium: sun.cf,v 1.68 91/07/30 11:34:39 rws Exp $
X
# operating system:  SunOS 4.1.1
X
# $XConsortium: sunLib.rules,v 1.6 91/03/24 17:55:58 rws Exp $
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that go after
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X      PROJECTROOT = /usr/X11/R5
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
# -------------------------------------------------------------------------
# X Window System Build Parameters
# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
# -------------------------------------------------------------------------
# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/X11/R5/lib
X           BINDIR = /usr/X11/R5/bin
X          INCROOT = /usr/X11/R5/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/X11/R5/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
# $XConsortium: sunLib.tmpl,v 1.11 91/07/31 11:32:08 rws Exp $
X
SHLIBLDFLAGS = -assert pure-text
PICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
# -------------------------------------------------------------------------
# Imake rules for building libraries, programs, scripts, and data files
# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
# -------------------------------------------------------------------------
# start of Imakefile
X
HDRS = patchlevel.h
SRCS = xautolock.c
OBJS = xautolock.o
X
SYS_LIBRARIES = -lX11
X
all:: xautolock
X
X PROGRAM = xautolock
X
all:: xautolock
X
xautolock: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
saber_xautolock:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
osaber_xautolock:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
install:: xautolock
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  xautolock $(DESTDIR)$(BINDIR)
X
install.man:: xautolock.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) xautolock.man $(DESTDIR)$(MANDIR)/xautolock.$(MANSUFFIX)
X
depend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
lint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
lint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
clean::
X	$(RM) $(PROGRAM)
X
# -------------------------------------------------------------------------
# common rules for all Makefiles - do not edit
X
emptyrule::
X
clean::
X	$(RM_CMD) "#"*
X
Makefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
tags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
saber:
X	# load $(ALLDEFINES) $(SRCS)
X
osaber:
X	# load $(ALLDEFINES) $(OBJS)
X
# -------------------------------------------------------------------------
# empty rules for directories that do not have SUBDIRS - do not edit
X
install::
X	@echo "install in $(CURRENT_DIR) done"
X
install.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
Makefiles::
X
includes::
X
# -------------------------------------------------------------------------
# dependencies generated by makedepend
X
SHAR_EOF
chmod 0644 Makefile ||
echo 'restore of Makefile failed'
Wc_c="`wc -c < 'Makefile'`"
test 10346 -eq "$Wc_c" ||
	echo 'Makefile: original size 10346, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile.std ==============
if test -f 'Makefile.std' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile.std (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile.std (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile.std' &&
RM   = /bin/rm -f
CC   = cc
HDRS = patchlevel.h
SRCS = xautolock.c
OBJS = xautolock.o
X
LIBS = -lX11
X
all:: xautolock
X
xautolock: $(OBJS) 
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LIBS) 
X
clean:
X	$(RM) xautolock $(OBJS) core
SHAR_EOF
chmod 0644 Makefile.std ||
echo 'restore of Makefile.std failed'
Wc_c="`wc -c < 'Makefile.std'`"
test 216 -eq "$Wc_c" ||
	echo 'Makefile.std: original size 216, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
X 
PURPOSE
=======
X
XXautolock is a program which monitors console activity, and starts up
a program of  your choice if  nothing  happens  during a certain time
interval.  You can use this to automatically start up a screen locker
in case you tend  to forget to do so  manually before having a coffee
break.
X
X 
HARDWARE PLATFORMS
==================
X
We have used  xautolock  on the following hardware without problems :
X
Sparc II
DECstation 3100 to 5500
Sony News 1800
HP Apollo 9000/4xx
VAXen
X
An  earlier  version also ran on  the following machinery,  but we no
longer have those, so testing it was a bit difficult :-). 
X
Sun 3/60
Apollo 3000 to 4500
X
X 
HOW TO USE IT
=============
X 
Just read the man page, it's really simple.
X
X
HOW IT WORKS
============
X
When  xautolock  starts  executing,  it  traverses  the  window tree, 
selects  SubstructureNotify  on all windows and adds each window to a
temporary list.  About +- 30 seconds later,  it scans this list,  and
now asks for the following events :
X
X KeyPress
X ButtonRelease
X PointerMotion
X
However,  it tries not to interfere with the normal event propagation
mechanism whenever possible. This is the reason for the delay between
the moment xautolock learns about a new window (and consequently asks
for SubstructureNotify events) and the moment it asks for the rest of
the events. Whenever a new window is created, a similar process takes
place.
X
If nothing happens within a user-specified period of time,  xautolock
will fire up a program  which is supposed  to lock the screen.  While
this program is running, xautolock itself remains on the look-out for
user interaction.
X
In contradiction  to what many people  believe,  this scheme does not
cause a noticeable overhead. 
X
X
COMPILING XAUTOLOCK
===================
X
XXautolock  should  compile  straight  out of  the box.  Just  do  the
following :
X
X 1 : Type 
X
X      make Makefile
X      make
X      make install
X      make clean 
X
X 2 : Have fun.
X
X 
KNOWN BUGS
==========
X
If,  when creating  a window,  an application  waits for more than 30
seconds before calling XSelectInput (),  xautolock may interfere with
the  event propagation  mechanism.  In order to minimize  the risk of
this happening,  an extra delay of 20 seconds  has been inserted into
the   xautolock  initialization  sequence.   This  was  done  because
xautolock is most likely to be started automatically when a user logs
in, and that process can be rather time-consuming.
X
XXautolock  does not check whether the screenlocker specified actually
is available.
X
If you can find others, please send e-mail to one of the authors.
X
X
COPYRIGHT
=========
X 
Copyright 1990, 1992 by S. De Troch and MCE.
X
Permission to use,  copy,  and  modify this software  without fee for
personal  use is hereby granted,  provided that  the above  copyright
notice appears  in all copies.  You may not  distribute  any modified
source code or  documentation  to users at any sites  other than your
own.
X
X 
DISCLAIMER
==========
X
THE AUTHORS  DISCLAIM  ALL WARRANTIES  WITH  REGARD TO THIS SOFTWARE,
INCLUDING  ALL IMPLIED WARRANTIES OF MERCHANTABILITY  AND FITNESS, IN
NO  EVENT  SHALL THEY   BE  LIABLE  FOR   ANY  SPECIAL,  INDIRECT  OR
CONSEQUENTIAL DAMAGES  OR ANY DAMAGES WHATSOEVER  RESULTING FROM LOSS
OF  USE,  DATA  OR  PROFITS,   WHETHER  IN  AN  ACTION  OF  CONTRACT,
NEGLIGENCE  OR   OTHER   TORTIOUS  ACTION,   ARISING  OUT  OF  OR  IN
CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
X
X 
AUTHORS
=======
X
XXautolock was conceived, written and performed by :
X
X Stefan De Troch             detroch@imec.be
X Michel Eyckmans (MCE)       eyckmans@imec.be
X
Special thanks to :
X
X Kris Croes                  croes@imec.be
X
SHAR_EOF
chmod 0644 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 3693 -eq "$Wc_c" ||
	echo 'README: original size 3693, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= patchlevel.h ==============
if test -f 'patchlevel.h' -a X"$1" != X"-c"; then
	echo 'x - skipping patchlevel.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting patchlevel.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'patchlevel.h' &&
#define PATCHLEVEL 7 
SHAR_EOF
chmod 0644 patchlevel.h ||
echo 'restore of patchlevel.h failed'
Wc_c="`wc -c < 'patchlevel.h'`"
test 22 -eq "$Wc_c" ||
	echo 'patchlevel.h: original size 22, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xautolock.c ==============
if test -f 'xautolock.c' -a X"$1" != X"-c"; then
	echo 'x - skipping xautolock.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xautolock.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xautolock.c' &&
/****************************************************************************
X *
X * xautolock                                           
X * =========                                                       
X *
X * Authors   :  S. De Troch (SDT)
X *              M. Eyckmans (MCE)                     
X *
X * Date      :  22/07/90
X *
X * Comments  :  
X * 
X * Review    :  - 12/02/92 (MCE)
X *                Hacked around a dxcalendar problem.
X *              - 21/02/92 (MCE)
X *                Major rewrite.
X *              - 24/02/92 (MCE)
X *                Removed an initialization bug.
X *              - 25/02/92 (MCE)
X *                Added code to detect multiple invocations.
X *              - 06/03/92 (MCE)
X *                Re-arranged the event loop in order to detect defunct
X *                children as soon as possible.
X *              - 10/03/92 (SDT & MCE)
X *                Added code to detect broken server connections.
X *              - 24/03/92 (MCE)
X *                Don't reset the timeout counter after receiving a
X *                synthetic or otherwise unexpected event.
X *
X * --------------------------------------------------------------------------
X *
X * Please send bug reports to detroch@imec.be or eyckmans@imec.be. 
X *
X * --------------------------------------------------------------------------
X *
X * Copyright 1990, 1992 by S. De Troch and MCE.
X *
X * Permission to use, copy, and modify this software without fee for
X * personal use is hereby granted, provided that the above copyright
X * notice appears in all copies. You may not distribute any modified 
X * source code or documentation to users at any sites other than your
X * own.
X *
X * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
X * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO
X * EVENT SHALL THEY BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
X * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA
X * OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
X * PERFORMANCE OF THIS SOFTWARE.
X *
X ****************************************************************************/
X
X
/*
X *  Have a guess what this does...
X *  ==============================
X */
#include <stdio.h>
#include <strings.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <sys/types.h>
#include <sys/wait.h>
#ifndef news1800
#include <stdlib.h>
#ifndef apollo
#include <malloc.h>
#include <unistd.h>
#endif /* apollo */
#endif /* news1800 */
#include "patchlevel.h"
X
X
X
/*
X *  Usefull macros and customization stuff
X *  ======================================
X */
#define FALSE                  0       /* as it says                   */
#define TRUE                   1       /* as it says                   */
X
#define PROBLEMS               1       /* for use by exit ()           */
#define SHORT_BELL             50      /* as is says                   */
#define LONG_BELL              100     /* as is says                   */
#define MIN_MINUTES            1       /* minimum number of minutes
X					  before firing up the locker  */
#define DEFAULT_MINUTES        10      /* default ...                  */
#define MAX_MINUTES            60      /* maximum ...                  */
#define INITIAL_SLEEP          20      /* for machines on which the
X					  login sequence takes forever */
#define INCREMENTAL_SLEEP      1       /* time step in seconds         */
#define CREATION_DELAY         30      /* should be > 10 and 
X					  < min (45,(MIN_MINUTES*30))  */
#define BUFFER_SIZE            512
#define DEFAULT_NOTIFY         15      
#define DEFAULT_LOCKER         "xlock" /* NEVER use the -root option!  */ 
X
/*
X *  We have to use :
X *
X *   KeyPress      : because KeyRelease is less portable.
X *   ButtonRelease : because only a single client can get button related
X *                   events, and ButtonPress is more likely to be asked
X *                   by the owner of a window.
X *
X *  Warning : The `expected_types' array must contain all event types
X *            that are covered by (MandatoryMasks | OptionalMasks).
X */ 
#define OptionalMasks      (  KeyPressMask)
X
#define MandatoryMasks     (  ButtonReleaseMask \
X		            | PointerMotionMask)
X
#define NOF_EXPECTED_TYPES     3
static int  expected_types[NOF_EXPECTED_TYPES] =
X			       { KeyPress, ButtonRelease, MotionNotify };
X
#define Main                   main
#define forever                for (;;)
#define Abort()                (void) exit (PROBLEMS)
#define Output0(str)           (Void) fprintf (stdout, str)
#define Output1(str,arg1)      (Void) fprintf (stdout, str, arg1)
#define Error0(str)            (Void) fprintf (stderr, str)
#define Error1(str,arg1)       (Void) fprintf (stderr, str, arg1)
#define Error2(str,arg1,arg2)  (Void) fprintf (stderr, str, arg1, arg2)
X
static void*                   ch_ptr; /* this is dirty */
#define New(type)              (ch_ptr = malloc (sizeof (type)), \
X				  ch_ptr == (void*) NULL         \
X				? (Error0 ("Out of memory.\n"),  \
X				   Abort (),                     \
X				   (type*) NULL                  \
X				  )                              \
X				: (type*) ch_ptr                 \
X                               )                                 \
X
X
X
/*
X *  New types
X *  =========
X */
#define Void                   void
typedef int                    Int;
typedef char                   Char;
typedef char*                  String;
typedef int                    Boolean;
typedef unsigned long          Huge;
X
#ifdef apollo
typedef Int                    (*XErrorHandler);
#endif /* apollo */
X
#ifdef news1800
typedef int                    pid_t;
typedef Int                    (*XErrorHandler);
#endif /* news1800 */
X
typedef struct QueueItem_
X	{
X	  Window              window;
X	  Int                 creationtime; 
X	  struct QueueItem_*  next;
X	  struct QueueItem_*  prev;
X	} aQueueItem, *QueueItem;
X
typedef struct Queue_
X	{
X	  struct QueueItem_*  head;
X	  struct QueueItem_*  tail;
X	} aQueue, *Queue;
X
X
X
/*
X *  Function declarations
X *  =====================
X */
#ifdef news1800
extern void*                  malloc (/*unsigned*/);;
#endif /* news1800 */
X
static Void   Usage           (/*String*/);
static Queue  NewQueue        (/*Void*/);
static Void   AddToQueue      (/*Queue, Window*/);
static Void   ProcessQueue    (/*Queue, Display*, Time*/);
static Void   SelectEvents    (/*Display*, Window, Boolean*/);
static Void   CheckConnection (/*Display, String*/);
static Int    FetchFalseAlarm (/*Display*, XEvent*/);
X
X
X
/*
X *  Global variables
X *  ================
X */
static Time  now = 0;  /* number of sleeps since we started  */
X
X
X
/*
X *  Function for telling the user about syntax errors
X *  =================================================
X */
static Void  Usage (prog_name)
String  prog_name;  /* as it says */
X
{
X  Error1 ("Usage: %s [-help][-time minutes][-locker locker][-notify].\n",
X	  prog_name);
X  Error0 ("    -help          : get this message.\n");
X  Error2 ("    -time minutes  : time to lock screen [min = %d, max = %d].\n",
X	  MIN_MINUTES, MAX_MINUTES);
X  Error0 ("    -locker locker : program used to lock.\n");
X  Error0 ("    -notify        : warns if the screen will be locked.\n");
X  Error0 ("\n");
X  Error0 ("  Defaults :\n");
X  Error1 ("     time   : %d minutes\n", DEFAULT_MINUTES);
X  Error1 ("     locker : %s\n", DEFAULT_LOCKER);
X
X  exit (PROBLEMS);
}
X
X
X
/*
X *  X Error handler
X *  ===============
X */
/*ARGSUSED*/
static Int  FetchFalseAlarm (d, event)
Display*  d;      /* display pointer */
XXEvent    event;  /* error event     */
X
{
X  return 0;
}
X
X
X
/*
X *  Function for finding out whether an other xautolock is already running
X *  ======================================================================
X */
/*ARGSUSED*/
static Void  CheckConnection (d, prog_name)
Display*  d;          /* display pointer */
String    prog_name;  /* as it says      */
X
{
X  pid_t   pid;        /* as it says               */
X  Int     kill_val;   /* return value of kill ()  */
X  Window  r;          /* root window              */
X  Atom    property;   /* property atom            */
X  Atom    type;       /* property type atom       */
X  Int     format;     /* property format          */
X  Huge    nof_items;  /* actual number of items   */
X  Huge    after;      /* dummy                    */
X  pid_t*  contents;   /* actual property value    */
X
X
X  pid = getpid ();
X  r = DefaultRootWindow (d);
X  property = XInternAtom (d, "XAUTOLOCK_SEMAPHORE_PID", False);
X
X  XGrabServer (d);
X  XGetWindowProperty (d, r, property, 0L, 2L, False, AnyPropertyType,
X		      &type, &format, &nof_items, &after,
X		      (Char*) &contents);
X
X  if (type == XA_ATOM)
X  {
X    kill_val = kill (*contents, 0);
X
X    if (kill_val == 0)
X    {
X      Error2 ("%s is already running (PID %d).\n",
X	      prog_name, *contents);
X      Abort ();
X    }
X  }
X
X  XChangeProperty (d, r, property, XA_ATOM, 8,
X                   PropModeReplace, &pid, sizeof (pid));
X  XUngrabServer (d);
X
X  XFree ((Char*) contents);
}
X
X
X
/*
X *  Function for creating a new queue
X *  =================================
X */
static Queue  NewQueue ()
X
{
X  Queue  queue;  /* return value */
X
X
X  queue = New (aQueue);
X  queue->tail = New (aQueueItem);
X  queue->head = New (aQueueItem);
X
X  queue->tail->next = queue->head;
X  queue->head->prev = queue->tail;
X  queue->tail->prev = queue->head->next = (QueueItem) NULL;
X
X  return queue;
}
X
X
X
/*
X *  Function for adding an item to a queue
X *  ======================================
X */
static Void  AddToQueue (queue, window)
Queue   queue;   /* as it says */
Window  window;  /* as it says */
X
{
X  QueueItem  new;  /* new item */
X
X
X  new = New (aQueueItem);
X
X  new->window = window;
X  new->creationtime = now;
X  new->next = queue->tail->next;
X  new->prev = queue->tail;
X  queue->tail->next->prev = new;
X  queue->tail->next = new;
}
X
X
X
/*
X *  Function for processing those entries that are old enough
X *  =========================================================
X */
static Void  ProcessQueue (queue, d, age)
Queue     queue;  /* as it says      */
Display*  d;      /* display pointer */
Time      age;    /* required age    */
X
{
X  QueueItem  current;  /* as it says */
X
X
X  if (now > age)
X  {
X    current = queue->head->prev;
X
X    while (   current->prev 
X           && current->creationtime + age < now
X          )
X    {
X      SelectEvents (d, current->window, False);
X      current = current->prev;
X      free ((void*) current->next);
X    }
X
X    current->next = queue->head;
X    queue->head->prev = current;
X  }
}
X
X
X
/*
X *  Function for selecting events on a tree of windows
X *  ==================================================
X */
static Void  SelectEvents (d, window, substructure_only)
Display*  d;                  /* display pointer   */
Window    window;             /* window            */
Boolean   substructure_only;  /* as it says        */
X
{
X  Window             rootw;             /* root window of this window */
X  Window             parent;            /* parent of this window      */
X  Window*            children;          /* children of this window    */
X  Int                nof_children = 0;  /* number of children         */
X  Int                i;                 /* loop counter               */
X  XWindowAttributes  attribs;           /* attributes of the window   */
X
X
X
X /*
X  *  Start by querying the server about parent and child windows.
X  */
X  if (!XQueryTree (d, window, &rootw, &parent, &children, &nof_children))
X  {
X    return;
X  }
X
X
X /*
X  *  Build the appropriate event mask. The basic idea is that we don't want
X  *  to interfere with the normal event propagation mechanismi if we don't
X  *  have to. 
X  */
X  if (substructure_only)
X  {
X    XSelectInput (d, window, SubstructureNotifyMask); 
X  }
X  else
X  {
X    if (   parent == rootw
X        || parent == None
X       )
X    {
X      attribs.all_event_masks = 
X      attribs.do_not_propagate_mask = OptionalMasks;
X    }
X    else
X    {
X      (Void) XGetWindowAttributes (d, window, &attribs);
X    }
X  
X    XSelectInput (d, window,   SubstructureNotifyMask
X			     | MandatoryMasks
X		             | (  (  attribs.all_event_masks
X				   | attribs.do_not_propagate_mask)
X				& OptionalMasks)); 
X  }
X
X
X /*
X  *  Now do the same thing for all children.
X  */
X  for (i = 0; i < nof_children; i++)
X  {
X    SelectEvents (d, children[i], substructure_only);
X  }
X
X  if (nof_children != 0)
X  {
X    XFree ((Char*) children);
X  }
}
X
X
X
/*
X *  Main function
X *  =============
X */
Int  Main (argc, argv)
Int    argc;    /* number of arguments */
Char*  argv[];  /* array of arguments  */
X
{
X  Display*  d;                             /* as it says                 */
X  XEvent    event;                         /* as it says                 */
X  String    command = DEFAULT_LOCKER;      /* as it says                 */
X  Queue     queue;                         /* as it says                 */
X  Int       i;                             /* loop counter               */
X  Int       timecounter = 0;               /* as it says                 */
X  Int       time_limit = DEFAULT_MINUTES;  /* as it says                 */
X  Int       notify_time = DEFAULT_NOTIFY;  /* notify margin              */
X  Boolean   notify_lock = FALSE;           /* whether to notify the user 
X				              before locking             */
X  pid_t     locker_pid = 0;                /* child pid                  */
X  Char*     ptr;                           /* temporary storage          */
X
X
X /*
X  *  Beautify argv[0].
X  */
X  for (ptr = argv[0] + strlen (argv[0]) - 1; ptr >= argv[0]; ptr--)
X  {
X    if (*ptr == '/')
X    {
X      break;
X    }
X  }
X
X  argv[0] = ptr + 1;
X
X
X /*
X  *  Process command line arguments.
X  */
X  for (i = 0; ++i < argc; )
X  {
X    if (!strcmp (argv[i], "-help"))
X    {
X      Usage (argv[0]);
X    }
X    else if (!strcmp (argv[i], "-locker"))
X    {
X      if (++i >= argc)
X      {
X	Usage (argv[0]);
X      }
X
X      command = argv[i];
X    }
X    else if (!strcmp (argv[i], "-notify"))
X    {
X      notify_lock = TRUE;
X    }
X    else if (!strcmp (argv[i], "-time"))
X    {
X      if (++i >= argc)
X      {
X	Usage (argv[0]);
X      }
X      if (!sscanf (argv[i], "%d", &time_limit))
X      {
X	Usage (argv[0]);
X      }
X
X      if (time_limit < MIN_MINUTES)
X      {
X	Error1 ("Warning: time is set to minimum value of %d minute(s).\n",
X		MIN_MINUTES);
X	time_limit = MIN_MINUTES;
X      }
X      else if (time_limit > MAX_MINUTES)
X      {
X	Error1 ("Warning: time is set to maximum time of %d minute(s).\n",
X		MAX_MINUTES);
X	time_limit = MAX_MINUTES;
X      }
X    }
X    else
X    {
X      Usage (argv[0]);
X    }
X  }
X
X
X /*
X  *  Other initializations.
X  */
X  time_limit = time_limit * 60;
X
#ifdef SAFER
X  if (   (d = XOpenDisplay (":0"))
X      == (Display*) NULL
X     )
X  {
X    Error0 ("Couldn't get a connection.\n");
X    Abort ();
X  }
#else
X  if (   (d = XOpenDisplay ((String) NULL))
X      == (Display*) NULL
X     )
X  {
X    Error0 ("Couldn't get a connection.\n");
X    Abort ();
X  }
#endif
X
X  XSetErrorHandler ((XErrorHandler) FetchFalseAlarm);
X  CheckConnection (d, argv[0]);
X
X  XSync (d, 0);   
X  (Void) sleep (INITIAL_SLEEP);
X  AddToQueue (queue = NewQueue (), DefaultRootWindow (d));
X  SelectEvents (d, DefaultRootWindow (d), True);
X
X
X /*
X  *  Main event loop.
X  */
X  forever
X  {
X   /*
X    *  Find out whether the connection to the server is still
X    *  valid. We have to do this, because unlike XNextEvent(),
X    *  XPending () doesn't notice if the connection is lost.
X    */
X    XNoOp (d);
X    XFlush (d);
X
X
X   /*
X    *  Now read whatever is available for reading.
X    */
X    while (XPending (d))
X    {
X      if (XCheckMaskEvent (d, SubstructureNotifyMask, &event))
X      {
X	if (event.type == CreateNotify)
X	{
X	  AddToQueue (queue, event.xcreatewindow.window);
X	}
X      }
X      else
X      {
X        XNextEvent (d, &event);
X      }
X
X
X     /*
X      *  Reset the timecounter if and only if the event is of one of
X      *  the types we are expecting to get *and* was not generated by
X      *  XSendEvent ().
X      */
X      for (i = -1; ++i < NOF_EXPECTED_TYPES; )
X      {
X	if (event.type == expected_types[i])
X	{
X	  break;
X	}
X      }
X
X      if (   i < NOF_EXPECTED_TYPES
X	  && !(event.xany.send_event)
X	 )
X      {
X        timecounter = 0;
X      }
X    }
X
X
X   /*
X    *  Let's sleep...
X    */
X    for (i = 0; i++ < INCREMENTAL_SLEEP; )
X    {
X      (Void) sleep (1);
X
X      if (now++ > CREATION_DELAY)
X      {
X        timecounter++;
X      }
X    }
X
X    ProcessQueue (queue, d, (Time) CREATION_DELAY);
X
X
X   /*
X    *  Find out whether we should do something special. This can
X    *  be one (or more) of the following :
X    *
X    *   - Wait for the previous locker (if any).
X    *   - Ring the bell, if we were asked to and are about to lock.
X    *   - Start up a new locker if the time limit has been reached.
X    */
X    if (locker_pid)
X    {
X      union wait  status;  /* childs process status */
X        
X
X      if (!wait3 (&status, WNOHANG, (struct rusage*) NULL))
X      {
X        timecounter = 0; /* it is */
X      }
X      else
X      {
X        locker_pid = 0;  /* it isn't */
X      }
X    }
X
X    if (timecounter == time_limit - notify_time)
X    {
X
X      if (notify_lock)
X      {
X        XBell (d, SHORT_BELL);
X        XBell (d, LONG_BELL);
X        XBell (d, SHORT_BELL);
X        XBell (d, LONG_BELL);
X      }
X    }
X
X    if (timecounter > time_limit)
X    {
X      if (!locker_pid)
X      {
X        switch (locker_pid = fork ())
X        {
X	  case -1 :
X	    locker_pid = 0;
X	    break;
X  
X	  case 0 :
X	    (Void) close (ConnectionNumber (d));
X	    system (command);
X	    exit (0);
X  
X	  default :
X            timecounter = 0;
X        }
X      }
X    }
X  }
}
SHAR_EOF
chmod 0644 xautolock.c ||
echo 'restore of xautolock.c failed'
Wc_c="`wc -c < 'xautolock.c'`"
test 17669 -eq "$Wc_c" ||
	echo 'xautolock.c: original size 17669, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= xautolock.man ==============
if test -f 'xautolock.man' -a X"$1" != X"-c"; then
	echo 'x - skipping xautolock.man (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting xautolock.man (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'xautolock.man' &&
.\"%Z%%M% -- version %I% (IMEC)		last update: %G%
.\"Template for man pages
.\"
.TH xautolock l
X
.SH NAME
X
X  xautolock \- locks X display after a period of inactivity
X
.SH SYNTAX 
X
\fBxautolock\fR [\fB\-help\fR] [\fB\-time\fR \fIminutes\fR]
[\fB\-locker\fR \fIlocker\fR] [\fB\-notify\fR]
.br 
X
.SH DESCRIPTION 
X
When \fIxautolock\fR is started, it monitors the activity on the
work station (keyboard, mouse, window creation). When no activity
is detected within the specified time (argument to \fI-time\fR, default
is 10 minutes), the screen is automatically locked using the specified
screen locker (argument to \fI-locker\fR, default is "xlock").
X
When the \fI-notify\fR flag is enabled, a warning signal will be
issued to notify the user that his screen will be locked.
When invoked with the \fI-help\fR flag, the only action is to display
a concise help message.
X
.SH OPTIONS
X
.TP 10
\fB\-help\fR 
xautolock will \fIonly\fR display a concise help message.
.TP 
\fB\-time\fR 
The argument \fIminutes\fR specifies the time-out. (D=10)
.TP 
\fB\-locker\fR 
The argument \fIlocker\fR specifies the locker program. (D="xlock")
Your PATH-environment is used to locate the command. Notice that if
the argument \fIlocker\fR contains several words, it must be specified
between quotes.
.TP 
\fB\-notify\fR 
enable notification of user at 15 seconds before locking.
X
.SH KNOWN\ BUGS 
X
xautolock does not check whether \fIlocker\fR is available.
X
.SH REMARK
X
This program is provided as-is. You are at your own in case of problems.
Nevertheless, comments and suggestions are always welcome.
X
.SH COPYRIGHT
X
Copyright 1990, 1992 by S. De Troch and MCE.
X
Permission to use, copy, and modify this software without fee for
personal use is hereby granted, provided that the above copyright
notice appears in all copies. You may not distribute any modified
source code or documentation to users at any sites other than your
own.
X
X
.SH AUTHOR   \"Name(s) of author(s).
X
Stefan De Troch (detroch@imec.be),
Michel Eyckmans (eyckmans@imec.be),
Kris Croes (croes@imec.be).
SHAR_EOF
chmod 0644 xautolock.man ||
echo 'restore of xautolock.man failed'
Wc_c="`wc -c < 'xautolock.man'`"
test 2055 -eq "$Wc_c" ||
	echo 'xautolock.man: original size 2055, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
