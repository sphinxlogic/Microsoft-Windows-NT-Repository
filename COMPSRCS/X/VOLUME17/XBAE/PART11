Newsgroups: comp.sources.x
Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: Andrew Wason <aw@bae.bellcore.com>
Subject: v17i038: Xbae widgets (MOTIF), Part11/12
Message-ID: <1992Mar23.180429.16399@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
References: <csx-17i028-xbae@uunet.UU.NET>
Date: Mon, 23 Mar 1992 18:04:29 GMT
Approved: dcmartin@msi.com

Submitted-by: Andrew Wason <aw@bae.bellcore.com>
Posting-number: Volume 17, Issue 38
Archive-name: xbae/part11

---- Cut Here and feed the following to sh ----
#!/bin/sh
# this is Xbae.shar.11 (part 11 of Xbae)
# do not concatenate these parts, unpack them in order with /bin/sh
# file Xbae/examples/caption/caption.c continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 11; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping Xbae/examples/caption/caption.c'
else
echo 'x - continuing file Xbae/examples/caption/caption.c'
sed 's/^X//' << 'SHAR_EOF' >> 'Xbae/examples/caption/caption.c' &&
X
main(argc, argv)
int argc;
char *argv[];
{
X    Widget toplevel, rc, button;
X    XtAppContext app;
X
X    toplevel = XtVaAppInitialize(&app, "Caption",
X				 NULL, 0,
X				 &argc, argv,
X				 NULL,
X				 NULL);
X
X    rc = XtVaCreateManagedWidget("rc",
X				 xmRowColumnWidgetClass, toplevel,
X				 NULL);
X
X    button = XtVaCreateManagedWidget("button1",
X				     xmPushButtonWidgetClass, rc,
X				     NULL);
X    XtAddCallback(button, XmNactivateCallback, popupCaptionTextF,
X		  (XtPointer)"caption1");
X    button = XtVaCreateManagedWidget("button2",
X				     xmPushButtonWidgetClass, rc,
X				     NULL);
X    XtAddCallback(button, XmNactivateCallback, popupCaptionFrame,
X		  (XtPointer)"caption2");
X    button = XtVaCreateManagedWidget("button3",
X				     xmPushButtonWidgetClass, rc,
X				     NULL);
X    XtAddCallback(button, XmNactivateCallback, popupCaptionFrame,
X		  (XtPointer)"caption3");
X    button = XtVaCreateManagedWidget("button4",
X				     xmPushButtonWidgetClass, rc,
X				     NULL);
X    XtAddCallback(button, XmNactivateCallback, popupCaptionTextF,
X		  (XtPointer)"caption4");
X    button = XtVaCreateManagedWidget("button5",
X				     xmPushButtonWidgetClass, rc,
X				     NULL);
X    XtAddCallback(button, XmNactivateCallback, popupCaptionToggle, NULL);
X    
X    XtRealizeWidget(toplevel);
X    XtAppMainLoop(app);
}
X
/* ARGSUSED */
void
popupCaptionTextF(w, name, call_data)
Widget w;
String name;
XXtPointer call_data;
{
X    Widget shell, cw;
X
X    shell = XtCreatePopupShell(name,
X			       xmDialogShellWidgetClass, w,
X			       NULL, 0);
X    
X    cw = XtCreateWidget("cw",
X			xbaeCaptionWidgetClass, shell,
X			NULL, 0);
X
X    XtVaCreateManagedWidget("text",
X			    xmTextFieldWidgetClass, cw,
X			    NULL);
X
X    XtManageChild(cw);
}
X
/* ARGSUSED */
void
popupCaptionFrame(w, name, call_data)
Widget w;
String name;
XXtPointer call_data;
{
X    Widget shell, form, cw, frame, rc;
X    int i;
X
X    shell = XtCreatePopupShell(name,
X			       xmDialogShellWidgetClass, w,
X			       NULL, 0);
X
X    form = XtCreateWidget("form",
X			  xmFormWidgetClass, shell,
X			  NULL, 0);
X    cw = XtVaCreateManagedWidget("cw",
X				 xbaeCaptionWidgetClass, form,
X				 NULL);
X    frame = XtVaCreateManagedWidget("frame",
X				    xmFrameWidgetClass, cw,
X				    NULL);
X    rc = XtVaCreateManagedWidget("rc",
X				 xmRowColumnWidgetClass, frame,
X				 NULL);
X    for (i = 0; i < 3; i++)
X	XtVaCreateManagedWidget("button",
X				xmPushButtonWidgetClass, rc,
X				NULL);
X
X    XtManageChild(form);
}
X
/* ARGSUSED */
void
popupCaptionToggle(w, client_data, call_data)
Widget w;
XXtPointer client_data;
XXtPointer call_data;
{
X    Widget shell, form, cw, frame, rc;
X    int i;
X
X    shell = XtCreatePopupShell("caption5",
X			       xmDialogShellWidgetClass, w,
X			       NULL, 0);
X
X    form = XtCreateWidget("form",
X				   xmFormWidgetClass, shell,
X				   NULL, 0);
X
X    cw = XtVaCreateManagedWidget("cw1",
X				 xbaeCaptionWidgetClass, form,
X				 NULL);
X    frame = XtVaCreateManagedWidget("frame",
X				    xmFrameWidgetClass, cw,
X				    NULL);
X    rc = XmCreateRadioBox(frame, "rc", NULL, 0);
X    XtManageChild(rc);
X
X    for (i = 0; i < 4; i++)
X	XtVaCreateManagedWidget("button",
X				xmToggleButtonWidgetClass, rc,
X				NULL);
X
X
X    cw = XtVaCreateManagedWidget("cw2",
X				 xbaeCaptionWidgetClass, form,
X				 NULL);
X    frame = XtVaCreateManagedWidget("frame",
X				    xmFrameWidgetClass, cw,
X				    NULL);
X    rc = XmCreateRadioBox(frame, "rc", NULL, 0);
X    XtManageChild(rc);
X
X    for (i = 0; i < 4; i++)
X	XtVaCreateManagedWidget("button",
X				xmToggleButtonWidgetClass, rc,
X				NULL);
X
X    XtManageChild(form);
}
X
SHAR_EOF
echo 'File Xbae/examples/caption/caption.c is complete' &&
chmod 0644 Xbae/examples/caption/caption.c ||
echo 'restore of Xbae/examples/caption/caption.c failed'
Wc_c="`wc -c < 'Xbae/examples/caption/caption.c'`"
test 4981 -eq "$Wc_c" ||
	echo 'Xbae/examples/caption/caption.c: original size 4981, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/caption/Imakefile ==============
if test -f 'Xbae/examples/caption/Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/caption/Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/caption/Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/caption/Imakefile' &&
#include "../../Xbae.tmpl"
X
X   LOCAL_LDFLAGS = -L../../src
X LOCAL_LIBRARIES = -lXbae -lXm -lXt -lX11
X         DEPLIBS =
X        INCLUDES = -I../../src
X         DEFINES = -D_NO_PROTO
X
UninstalledSimpleProgramTarget(caption)
SHAR_EOF
chmod 0644 Xbae/examples/caption/Imakefile ||
echo 'restore of Xbae/examples/caption/Imakefile failed'
Wc_c="`wc -c < 'Xbae/examples/caption/Imakefile'`"
test 223 -eq "$Wc_c" ||
	echo 'Xbae/examples/caption/Imakefile: original size 223, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/colors/Colors.ad ==============
if test ! -d 'Xbae/examples/colors'; then
    echo 'x - creating directory Xbae/examples/colors'
    mkdir 'Xbae/examples/colors'
fi
if test -f 'Xbae/examples/colors/Colors.ad' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/colors/Colors.ad (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/colors/Colors.ad (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/colors/Colors.ad' &&
*mw.rows:		7
*mw.columns:		5
*mw.columnWidths:	10, 10, 10, 10, 10
*mw.columnLabels:	Color0, Color1, Color2, Color3, Color4
*mw.rowLabels:		Color0, Color1, Color2, Color3, Color4, Color5, Color6
X
*menu*cell.labelString:		Cell Orientation
*menu*row.labelString:		Row Orientation
*menu*column.labelString:	Column Orientation
*reset.labelString:		Reset
SHAR_EOF
chmod 0644 Xbae/examples/colors/Colors.ad ||
echo 'restore of Xbae/examples/colors/Colors.ad failed'
Wc_c="`wc -c < 'Xbae/examples/colors/Colors.ad'`"
test 349 -eq "$Wc_c" ||
	echo 'Xbae/examples/colors/Colors.ad: original size 349, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/colors/colors.c ==============
if test -f 'Xbae/examples/colors/colors.c' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/colors/colors.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/colors/colors.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/colors/colors.c' &&
/*
X * Copyright(c) 1992 Bell Communications Research, Inc. (Bellcore)
X *                        All rights reserved
X * Permission to use, copy, modify and distribute this material for
X * any purpose and without fee is hereby granted, provided that the
X * above copyright notice and this permission notice appear in all
X * copies, and that the name of Bellcore not be used in advertising
X * or publicity pertaining to this material without the specific,
X * prior written permission of an authorized representative of
X * Bellcore.
X *
X * BELLCORE MAKES NO REPRESENTATIONS AND EXTENDS NO WARRANTIES, EX-
X * PRESS OR IMPLIED, WITH RESPECT TO THE SOFTWARE, INCLUDING, BUT
X * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
X * FITNESS FOR ANY PARTICULAR PURPOSE, AND THE WARRANTY AGAINST IN-
X * FRINGEMENT OF PATENTS OR OTHER INTELLECTUAL PROPERTY RIGHTS.  THE
X * SOFTWARE IS PROVIDED "AS IS", AND IN NO EVENT SHALL BELLCORE OR
X * ANY OF ITS AFFILIATES BE LIABLE FOR ANY DAMAGES, INCLUDING ANY
X * LOST PROFITS OR OTHER INCIDENTAL OR CONSEQUENTIAL DAMAGES RELAT-
X * ING TO THE SOFTWARE.
X */
X
#include <stdio.h>
#include <X11/StringDefs.h>
#include <Xm/Form.h>
#include <Xm/RowColumn.h>
#include <Xm/Label.h>
#include <Xm/PushB.h>
#include <Xbae/Matrix.h>
X
/*
X * Interactively set row, column and cell colors.
X * Consists of an option menu to select row, column or cell orientation.
X * Then when a color name is entered in a cell, that row, column or cell
X * (depending on the orientation) is set to the color entered.
X */
X
void SetColorCB();
void RowOrientationCB();
void ColumnOrientationCB();
void CellOrientationCB();
void ResetCB();
void LoadMatrix();
X
typedef enum {
X    CellOrientation,
X    RowOrientation,
X    ColumnOrientation
} ColorOrientation;
typedef struct {
X    Widget matrix;
X    ColorOrientation orientation;
} ColorDataRec, *ColorData;
X
main(argc, argv)
int argc;
char *argv[];
{
X    Widget toplevel, form, menu, row, column, cell, reset, option;
X    XtAppContext app;
X    ColorDataRec colorData;
X    Arg args[2];
X    int n;
X
X    toplevel = XtVaAppInitialize(&app, "Colors",
X				 NULL, 0,
X				 &argc, argv,
X				 NULL,
X				 NULL);
X
X    /*
X     * Create a Form to hold everything
X     */
X    form = XtCreateManagedWidget("form",
X                                 xmFormWidgetClass,     toplevel,
X                                 NULL, 0);
X
X    /*
X     * Create a menu for use in an OptionMenu
X     */
X    menu = XmCreatePulldownMenu(form, "menu", NULL, 0);
X
X    /*
X     * Create a menu button to select cell orientation
X     */
X    cell = XtVaCreateManagedWidget("cell",
X				   xmPushButtonWidgetClass,	menu,
X				   NULL);
X    XtAddCallback(cell, XmNactivateCallback, CellOrientationCB,
X		  (XtPointer)&colorData);
X
X    /*
X     * Create a menu button to select row orientation
X     */
X    row = XtVaCreateManagedWidget("row",
X				  xmPushButtonWidgetClass,	menu,
X				  NULL);
X    XtAddCallback(row, XmNactivateCallback, RowOrientationCB,
X		  (XtPointer)&colorData);
X
X    /*
X     * Create a menu button to select column orientation
X     */
X    column = XtVaCreateManagedWidget("column",
X				     xmPushButtonWidgetClass,   menu,
X				     NULL);
X    XtAddCallback(column, XmNactivateCallback, ColumnOrientationCB,
X		  (XtPointer)&colorData);
X
X    /*
X     * Setup and create the option menu
X     */
X    n = 0;
X    XtSetArg(args[n], XmNsubMenuId, menu);		n++;
X    XtSetArg(args[n], XmNmenuHistory, cell);		n++;
X    option = XmCreateOptionMenu(form, "option", args, n);
X    XtManageChild(option);
X
X
X    colorData.orientation = CellOrientation;
X
X    /*
X     * Create a Matrix widget.  Add a callback to get the color entered
X     * in a cell.
X     */
X    colorData.matrix =
X	XtVaCreateManagedWidget("mw",
X				xbaeMatrixWidgetClass,	form,
X				XmNtopAttachment,	XmATTACH_WIDGET,
X				XmNtopWidget,		option,
X				XmNleftAttachment,	XmATTACH_FORM,
X				XmNrightAttachment,	XmATTACH_FORM,
X				XmNbottomAttachment,	XmATTACH_FORM,
X				NULL);
X    XtAddCallback(colorData.matrix, XmNleaveCellCallback, SetColorCB,
X		  (XtPointer)&colorData);
X
X    /*
X     * Create a button to reset XmNcolors
X     */
X    reset = XtVaCreateManagedWidget("reset",
X				    xmPushButtonWidgetClass, form,
X				    XmNleftAttachment, XmATTACH_WIDGET,
X				    XmNleftWidget, option,
X				    NULL);
X    XtAddCallback(reset, XmNactivateCallback, ResetCB,
X		  (XtPointer)colorData.matrix);
X
X
X    /*
X     * Load the matrix with default values
X     */
X    LoadMatrix(colorData.matrix);
X
X    XtRealizeWidget(toplevel);
X    XtAppMainLoop(app);
}
X
/* ARGSUSED */
void
CellOrientationCB(w, colorData, call_data)
Widget w;
ColorData colorData;
XXtPointer call_data;
{
X    colorData->orientation = CellOrientation;
}
X
/* ARGSUSED */
void
RowOrientationCB(w, colorData, call_data)
Widget w;
ColorData colorData;
XXtPointer call_data;
{
X    colorData->orientation = RowOrientation;
}
X
/* ARGSUSED */
void
ColumnOrientationCB(w, colorData, call_data)
Widget w;
ColorData colorData;
XXtPointer call_data;
{
X    colorData->orientation = ColumnOrientation;
}
X
/* ARGSUSED */
void
SetColorCB(w, colorData, call_data)
Widget w;
ColorData colorData;
XXbaeMatrixLeaveCellCallbackStruct *call_data;
{
X    XrmValue fromVal, toVal;
X    Pixel color;
X
X    /*
X     * If the color is "X" or "Z", ignore it since that is what we load
X     * the matrix with
X     */
X    if (call_data->value[0] == 'X' || call_data->value[0] == 'Z')
X	return;
X
X    /*
X     * Attempt to convert the string in this cell to a Pixel
X     */
X    fromVal.size = strlen(call_data->value) + 1;
X    fromVal.addr = call_data->value;
X    toVal.size = sizeof(Pixel);
X    toVal.addr = (caddr_t) &color;
X    if (!XtConvertAndStore(w, XtRString, &fromVal, XtRPixel, &toVal))
X	return;
X
X    /*
X     * Set the current row/column to the specified color based on our
X     * current orientation.
X     */
X    switch (colorData->orientation) {
X    case CellOrientation:
X	XbaeMatrixSetCellColor(colorData->matrix,
X			       call_data->row, call_data->column, color);
X	break;
X    case RowOrientation:
X	XbaeMatrixSetRowColors(colorData->matrix, call_data->row, &color, 1);
X	break;
X    case ColumnOrientation:
X	XbaeMatrixSetColumnColors(colorData->matrix, call_data->column,
X				  &color, 1);
X	break;
X    }
}
X
/* ARGSUSED */
void
ResetCB(w, matrix, client_data)
Widget w;
Widget matrix;
XXtPointer client_data;
{
X    XtVaSetValues(matrix,
X		  XmNcolors, NULL,
X		  NULL);
X    LoadMatrix(matrix);
}
X
void
LoadMatrix(w)
Widget w;
{
X    int rows, columns;
X    int i, j;
X    String *rowArrays, **cells;
X
X    XtVaGetValues(w,
X		  XmNrows,	&rows,
X		  XmNcolumns,	&columns,
X		  NULL);
X
X    cells = (String **)XtMalloc(rows * sizeof(String *));
X    rowArrays = (String *)XtMalloc(rows * columns * sizeof(String));
X
X    for (i = 0; i < rows; i++) {
X	cells[i] = &rowArrays[i * columns];
X	if (i % 2)
X	    for (j = 0; j < columns; j++)
X		rowArrays[i * columns + j] = "X";
X	else
X	    for (j = 0; j < columns; j++)
X		rowArrays[i * columns + j] = "Z";
X    }
X
X    XtVaSetValues(w,
X		  XmNcells,	cells,
X		  NULL);
X
X    XtFree((XtPointer) rowArrays);
X    XtFree((XtPointer) cells);
}
X
SHAR_EOF
chmod 0644 Xbae/examples/colors/colors.c ||
echo 'restore of Xbae/examples/colors/colors.c failed'
Wc_c="`wc -c < 'Xbae/examples/colors/colors.c'`"
test 7063 -eq "$Wc_c" ||
	echo 'Xbae/examples/colors/colors.c: original size 7063, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/colors/Imakefile ==============
if test -f 'Xbae/examples/colors/Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/colors/Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/colors/Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/colors/Imakefile' &&
#include "../../Xbae.tmpl"
X
X   LOCAL_LDFLAGS = -L../../src
X LOCAL_LIBRARIES = -lXbae -lXm -lXt -lX11
X         DEPLIBS =
X        INCLUDES = -I../../src
X         DEFINES = -D_NO_PROTO
X
UninstalledSimpleProgramTarget(colors)
SHAR_EOF
chmod 0644 Xbae/examples/colors/Imakefile ||
echo 'restore of Xbae/examples/colors/Imakefile failed'
Wc_c="`wc -c < 'Xbae/examples/colors/Imakefile'`"
test 222 -eq "$Wc_c" ||
	echo 'Xbae/examples/colors/Imakefile: original size 222, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/dynamic/Dynamic.ad ==============
if test ! -d 'Xbae/examples/dynamic'; then
    echo 'x - creating directory Xbae/examples/dynamic'
    mkdir 'Xbae/examples/dynamic'
fi
if test -f 'Xbae/examples/dynamic/Dynamic.ad' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/dynamic/Dynamic.ad (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/dynamic/Dynamic.ad (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/dynamic/Dynamic.ad' &&
*mw.rows:			6
*mw.columns:			5
*mw.columnWidths:		5, 15, 10, 10, 15
X
*mw.rowLabels:			Row1, Row2, Row3, Row4, Row5, RowSix
*mw.columnLabels:		Col1, Col2, Col3, Col4, ColFive
*mw.visibleRows:		6
SHAR_EOF
chmod 0644 Xbae/examples/dynamic/Dynamic.ad ||
echo 'restore of Xbae/examples/dynamic/Dynamic.ad failed'
Wc_c="`wc -c < 'Xbae/examples/dynamic/Dynamic.ad'`"
test 194 -eq "$Wc_c" ||
	echo 'Xbae/examples/dynamic/Dynamic.ad: original size 194, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/dynamic/dynamic.c ==============
if test -f 'Xbae/examples/dynamic/dynamic.c' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/dynamic/dynamic.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/dynamic/dynamic.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/dynamic/dynamic.c' &&
/*
X * Copyright(c) 1992 Bell Communications Research, Inc. (Bellcore)
X *                        All rights reserved
X * Permission to use, copy, modify and distribute this material for
X * any purpose and without fee is hereby granted, provided that the
X * above copyright notice and this permission notice appear in all
X * copies, and that the name of Bellcore not be used in advertising
X * or publicity pertaining to this material without the specific,
X * prior written permission of an authorized representative of
X * Bellcore.
X *
X * BELLCORE MAKES NO REPRESENTATIONS AND EXTENDS NO WARRANTIES, EX-
X * PRESS OR IMPLIED, WITH RESPECT TO THE SOFTWARE, INCLUDING, BUT
X * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
X * FITNESS FOR ANY PARTICULAR PURPOSE, AND THE WARRANTY AGAINST IN-
X * FRINGEMENT OF PATENTS OR OTHER INTELLECTUAL PROPERTY RIGHTS.  THE
X * SOFTWARE IS PROVIDED "AS IS", AND IN NO EVENT SHALL BELLCORE OR
X * ANY OF ITS AFFILIATES BE LIABLE FOR ANY DAMAGES, INCLUDING ANY
X * LOST PROFITS OR OTHER INCIDENTAL OR CONSEQUENTIAL DAMAGES RELAT-
X * ING TO THE SOFTWARE.
X */
X
#include <Xm/RowColumn.h>
#include <Xm/Label.h>
#include <Xm/PushB.h>
#include <Xbae/Matrix.h>
X
/*
X * Dynamically expand the matrix when tabbing past the last row or column.
X */
X
X
void TraverseCB();
X
main(argc, argv)
int argc;
char *argv[];
{
X    Widget toplevel, mw;
X    XtAppContext app;
X
X    toplevel = XtVaAppInitialize(&app, "Dynamic",
X				 NULL, 0,
X				 &argc, argv,
X				 NULL,
X				 NULL);
X
X    mw = XtVaCreateManagedWidget("mw",
X				 xbaeMatrixWidgetClass,	toplevel,
X				 NULL);
X    XtAddCallback(mw, XmNtraverseCellCallback, TraverseCB, NULL);
X
X    XtRealizeWidget(toplevel);
X    XtAppMainLoop(app);
}
X
/* ARGSUSED */
void
TraverseCB(w, client_data, call_data)
Widget w;
XXtPointer client_data;
XXbaeMatrixTraverseCellCallbackStruct *call_data;
{
X    static XrmQuark QRight = NULLQUARK;
X    static XrmQuark QDown = NULLQUARK;
X
X    /*
X     * Get the Quarks we care about
X     */
X    if (QRight == NULLQUARK) {
X	QRight = XrmStringToQuark("Right");
X	QDown = XrmStringToQuark("Down");
X    }
X
X    /*
X     * If we are moving down, and we are at the last row, add a new row
X     * and traverse to it.
X     */
X    if (call_data->qparam == QDown &&
X	call_data->row == call_data->num_rows - 1) {
X	XbaeMatrixAddRows(w, call_data->num_rows, NULL, NULL, NULL, 1);
X	call_data->next_row = call_data->num_rows;
X	call_data->next_column = call_data->column;
X    }
X    /*
X     * If we are moving right, and we are at the last column, add a new column
X     * and traverse to it.
X     */
X    else if (call_data->qparam == QRight &&
X	call_data->column == call_data->num_columns - 1) {
X	short width = 10;
X	XbaeMatrixAddColumns(w, call_data->num_columns, NULL, NULL,
X			     &width, NULL, NULL, NULL, NULL, 1);
X	call_data->next_column = call_data->num_columns;
X	call_data->next_row = call_data->row;
X    }
}
X
X
SHAR_EOF
chmod 0644 Xbae/examples/dynamic/dynamic.c ||
echo 'restore of Xbae/examples/dynamic/dynamic.c failed'
Wc_c="`wc -c < 'Xbae/examples/dynamic/dynamic.c'`"
test 2890 -eq "$Wc_c" ||
	echo 'Xbae/examples/dynamic/dynamic.c: original size 2890, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/dynamic/Imakefile ==============
if test -f 'Xbae/examples/dynamic/Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/dynamic/Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/dynamic/Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/dynamic/Imakefile' &&
#include "../../Xbae.tmpl"
X
X   LOCAL_LDFLAGS = -L../../src
X LOCAL_LIBRARIES = -lXbae -lXm -lXt -lX11
X         DEPLIBS =
X        INCLUDES = -I../../src
X         DEFINES = -D_NO_PROTO
X
UninstalledSimpleProgramTarget(dynamic)
SHAR_EOF
chmod 0644 Xbae/examples/dynamic/Imakefile ||
echo 'restore of Xbae/examples/dynamic/Imakefile failed'
Wc_c="`wc -c < 'Xbae/examples/dynamic/Imakefile'`"
test 223 -eq "$Wc_c" ||
	echo 'Xbae/examples/dynamic/Imakefile: original size 223, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/matrix/Matrix.ad ==============
if test ! -d 'Xbae/examples/matrix'; then
    echo 'x - creating directory Xbae/examples/matrix'
    mkdir 'Xbae/examples/matrix'
fi
if test -f 'Xbae/examples/matrix/Matrix.ad' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/matrix/Matrix.ad (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/matrix/Matrix.ad (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/matrix/Matrix.ad' &&
*mw.rowLabels:		1, 2, 3, 4, 5, 6
*mw.columnLabels:	Color, #, Texture, Measure, Size
*mw.columnLabelAlignments:alignment_beginning, alignment_center,\
X			alignment_beginning, alignment_beginning,\
X			alignment_beginning
*mw.columnAlignments:	alignment_beginning, alignment_end,\
X			alignment_beginning, alignment_beginning,\
X			alignment_beginning
*mw.visibleRows:	4
SHAR_EOF
chmod 0644 Xbae/examples/matrix/Matrix.ad ||
echo 'restore of Xbae/examples/matrix/Matrix.ad failed'
Wc_c="`wc -c < 'Xbae/examples/matrix/Matrix.ad'`"
test 365 -eq "$Wc_c" ||
	echo 'Xbae/examples/matrix/Matrix.ad: original size 365, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/matrix/matrix.c ==============
if test -f 'Xbae/examples/matrix/matrix.c' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/matrix/matrix.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/matrix/matrix.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/matrix/matrix.c' &&
/*
X * Copyright(c) 1992 Bell Communications Research, Inc. (Bellcore)
X *                        All rights reserved
X * Permission to use, copy, modify and distribute this material for
X * any purpose and without fee is hereby granted, provided that the
X * above copyright notice and this permission notice appear in all
X * copies, and that the name of Bellcore not be used in advertising
X * or publicity pertaining to this material without the specific,
X * prior written permission of an authorized representative of
X * Bellcore.
X *
X * BELLCORE MAKES NO REPRESENTATIONS AND EXTENDS NO WARRANTIES, EX-
X * PRESS OR IMPLIED, WITH RESPECT TO THE SOFTWARE, INCLUDING, BUT
X * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
X * FITNESS FOR ANY PARTICULAR PURPOSE, AND THE WARRANTY AGAINST IN-
X * FRINGEMENT OF PATENTS OR OTHER INTELLECTUAL PROPERTY RIGHTS.  THE
X * SOFTWARE IS PROVIDED "AS IS", AND IN NO EVENT SHALL BELLCORE OR
X * ANY OF ITS AFFILIATES BE LIABLE FOR ANY DAMAGES, INCLUDING ANY
X * LOST PROFITS OR OTHER INCIDENTAL OR CONSEQUENTIAL DAMAGES RELAT-
X * ING TO THE SOFTWARE.
X */
X
#include <Xbae/Matrix.h>
X
/*
X * Simple example of loaded Matrix
X */
X
#define ROWS		6
#define COLUMNS		5
X
String rows[ROWS][COLUMNS] = {
X    "Orange", "12", "Rough", "Inches", "Large",
X    "Blue", "323", "Smooth", "Feet", "Medium",
X    "Yellow", "456", "Bristly", "Meters", "Large",
X    "Green", "1", "Knobby", "Miles", "Small",
X    "Pink", "33", "Hairy", "Quarts", "Small",
X    "Black", "7", "Silky", "Gallons", "Small"
};
String *cells[ROWS];
X
short widths[5] = { 6, 3, 10, 10, 10 };
X
main(argc, argv)
int argc;
char *argv[];
{
X    Widget toplevel, mw;
X    XtAppContext app;
X    int i;
X
X    toplevel = XtVaAppInitialize(&app, "Simple",
X				 NULL, 0,
X				 &argc, argv,
X				 NULL,
X				 NULL);
X
X    for (i = 0; i < ROWS; i++)
X	cells[i] = &rows[i][0];
X
X    mw = XtVaCreateManagedWidget("mw",
X				 xbaeMatrixWidgetClass, toplevel,
X				 XmNrows,		ROWS,
X				 XmNcolumns,		COLUMNS,
X				 XmNcolumnWidths,	widths,
X				 XmNcells,		cells,
X				 NULL);
X
X    XtRealizeWidget(toplevel);
X    XtAppMainLoop(app);
}
X
SHAR_EOF
chmod 0644 Xbae/examples/matrix/matrix.c ||
echo 'restore of Xbae/examples/matrix/matrix.c failed'
Wc_c="`wc -c < 'Xbae/examples/matrix/matrix.c'`"
test 2097 -eq "$Wc_c" ||
	echo 'Xbae/examples/matrix/matrix.c: original size 2097, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/matrix/Imakefile ==============
if test -f 'Xbae/examples/matrix/Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/matrix/Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/matrix/Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/matrix/Imakefile' &&
#include "../../Xbae.tmpl"
X
X   LOCAL_LDFLAGS = -L../../src
X LOCAL_LIBRARIES = -lXbae -lXm -lXt -lX11
X         DEPLIBS =
X        INCLUDES = -I../../src
X         DEFINES = -D_NO_PROTO
X
UninstalledSimpleProgramTarget(matrix)
SHAR_EOF
chmod 0644 Xbae/examples/matrix/Imakefile ||
echo 'restore of Xbae/examples/matrix/Imakefile failed'
Wc_c="`wc -c < 'Xbae/examples/matrix/Imakefile'`"
test 222 -eq "$Wc_c" ||
	echo 'Xbae/examples/matrix/Imakefile: original size 222, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/select/select.c ==============
if test ! -d 'Xbae/examples/select'; then
    echo 'x - creating directory Xbae/examples/select'
    mkdir 'Xbae/examples/select'
fi
if test -f 'Xbae/examples/select/select.c' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/select/select.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/select/select.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/select/select.c' &&
/*
X * Copyright(c) 1992 Bell Communications Research, Inc. (Bellcore)
X *                        All rights reserved
X * Permission to use, copy, modify and distribute this material for
X * any purpose and without fee is hereby granted, provided that the
X * above copyright notice and this permission notice appear in all
X * copies, and that the name of Bellcore not be used in advertising
X * or publicity pertaining to this material without the specific,
X * prior written permission of an authorized representative of
X * Bellcore.
X *
X * BELLCORE MAKES NO REPRESENTATIONS AND EXTENDS NO WARRANTIES, EX-
X * PRESS OR IMPLIED, WITH RESPECT TO THE SOFTWARE, INCLUDING, BUT
X * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
X * FITNESS FOR ANY PARTICULAR PURPOSE, AND THE WARRANTY AGAINST IN-
X * FRINGEMENT OF PATENTS OR OTHER INTELLECTUAL PROPERTY RIGHTS.  THE
X * SOFTWARE IS PROVIDED "AS IS", AND IN NO EVENT SHALL BELLCORE OR
X * ANY OF ITS AFFILIATES BE LIABLE FOR ANY DAMAGES, INCLUDING ANY
X * LOST PROFITS OR OTHER INCIDENTAL OR CONSEQUENTIAL DAMAGES RELAT-
X * ING TO THE SOFTWARE.
X */
X
#include <stdio.h>
#include <Xm/Xm.h>
#include <Wc/WcCreate.h>
#include <Xbae/Matrix.h>
X
/*
X * Creates a matrix and two option menus.  One menu selects the type of
X * selection desired (row, column or cell).  The other selects the mode
X * (exclusive - only one item at a time, or add - multiple items
X * can be selected).
X * The File menu can be used to load the matrix with dummy data.
X * The Edit menu can be used to copy, clear or delete the currently
X * selected item, or to deselect all selections.
X */
X
#define RCO(name, func)		WcRegisterConstructor(app, name, func)
#define RCN(name, class)	WcRegisterClassName(app, name, class)
#define RCP(name, class)	WcRegisterClassPtr(app, name, class)
X
extern void MriRegisterMotif();
X
X
typedef enum {
X    NoSelection,
X    CellSelection,
X    RowSelection,
X    ColumnSelection
} SelectionType;
X
typedef enum {
X    AddMode,
X    ExclusiveMode
} SelectionMode;
X
typedef struct _SelectionStruct {
X    int row, column;
X    SelectionType type;
X    SelectionMode mode;
X    Boolean selected;
X    Widget matrix;
} *SelectionPtr, SelectionStruct;
X
SelectionPtr GetSelectionFromWidget();
void SelectCB(), NewMatrixCB(), RegisterSelectionWidgetCB();
void SetSelectionTypeCB(), SetSelectionModeCB();
void DeleteCB(), CopyCB(), ClearCB(), LoadCB(), DeselectCB();
X
void
main(argc, argv)
int argc;
char *argv[];
{
X    Widget toplevel;
X    XtAppContext app;
X
X    toplevel = XtAppInitialize(&app, "Select",
X			       NULL, 0,
X			       &argc, argv,
X			       NULL,
X			       NULL, 0);
X
X    MriRegisterMotif(app);
X    
X    RCN("XbaeMatrix", xbaeMatrixWidgetClass);
X    RCP("xbaeMatrixWidgetClass", xbaeMatrixWidgetClass);
X
X    WcRegisterCallback(app, "NewMatrixCB", NewMatrixCB, NULL);
X    WcRegisterCallback(app, "RegisterSelectionWidgetCB",
X		       RegisterSelectionWidgetCB, NULL);
X    WcRegisterCallback(app, "SelectCB", SelectCB, NULL);
X    WcRegisterCallback(app, "SetSelectionTypeCB", SetSelectionTypeCB, NULL);
X    WcRegisterCallback(app, "SetSelectionModeCB", SetSelectionModeCB, NULL);
X    WcRegisterCallback(app, "DeleteCB", DeleteCB, NULL);
X    WcRegisterCallback(app, "CopyCB", CopyCB, NULL);
X    WcRegisterCallback(app, "ClearCB", ClearCB, NULL);
X    WcRegisterCallback(app, "LoadCB", LoadCB, NULL);
X    WcRegisterCallback(app, "DeselectCB", DeselectCB, NULL);
X
X    WcWidgetCreation(toplevel);
X
X    XtRealizeWidget(toplevel);
X    XtAppMainLoop(app);
}
X
/*
X * Create our internal matrix object and associate it with the widget
X */
/* ARGSUSED */
void
NewMatrixCB(w, client_data, call_data)
Widget w;
XXtPointer client_data;
XXtPointer call_data;
{
X    SelectionPtr selection = XtNew(SelectionStruct);
X    selection->type = NoSelection;
X    selection->selected = False;
X    selection->matrix = w;
X
X    XtVaSetValues(w,
X		  XmNuserData, selection,
X		  NULL);
}
X
/*
X * Associate the selection object with a widget
X */
/* ARGSUSED */
void
RegisterSelectionWidgetCB(w, client_data, call_data)
Widget w;
XXtPointer client_data;
XXtPointer call_data;
{
X    SelectionPtr selection;
X    Widget matrix;
X
X    if ((matrix = WcFullNameToWidget(w, (String)client_data)) == NULL)
X	return;
X
X    selection = GetSelectionFromWidget(matrix);
X    XtVaSetValues(w,
X		  XmNuserData, selection,
X		  NULL);
}
X
/*
X * Callback when a cell is clicked on
X */
/* ARGSUSED */
void
SelectCB(w, client_data, call_data)
Widget w;
XXtPointer client_data;
XXbaeMatrixSelectCellCallbackStruct *call_data;
{
X    SelectionPtr selection = GetSelectionFromWidget(w);
X
X    if (selection->mode == ExclusiveMode && selection->selected)
X	switch (selection->type) {
X	case CellSelection:
X	    XbaeMatrixDeselectCell(w, selection->row, selection->column);
X	    break;
X	case RowSelection:
X	    XbaeMatrixDeselectRow(w, selection->row);
X	    break;
X	case ColumnSelection:
X	    XbaeMatrixDeselectColumn(w, selection->column);
X	    break;
X	}
X
X    selection->row = call_data->row;
X    selection->column = call_data->column;
X
X    switch (selection->type) {
X    case CellSelection:
X	XbaeMatrixSelectCell(w, selection->row, selection->column);
X	break;
X    case RowSelection:
X	XbaeMatrixSelectRow(w, selection->row);
X	break;
X    case ColumnSelection:
X	XbaeMatrixSelectColumn(w, selection->column);
X	break;
X    }
X
X    selection->selected = True;
}
X
/* ARGSUSED */
void
SetSelectionTypeCB(w, client_data, call_data)
Widget w;
XXtPointer client_data;
XXtPointer call_data;
{
X    SelectionPtr selection = GetSelectionFromWidget(w);
X
X    XbaeMatrixDeselectAll(selection->matrix);
X    selection->selected = False;
X
X    switch (((String)client_data)[0]) {
X    case '1':
X	selection->type = CellSelection;
X	break;
X    case '2':
X	selection->type = RowSelection;
X	break;
X    case '3':
X	selection->type = ColumnSelection;
X	break;
X    default:
X	XtAppWarningMsg(XtWidgetToApplicationContext(w),
X			"setSelectionTypeCB", "badParam", "Select",
X			"Bad param passed to SetSelectionTypeCB",
X			(String *) NULL, (Cardinal *) NULL);
X	break;
X    }
}
X
/* ARGSUSED */
void
SetSelectionModeCB(w, client_data, call_data)
Widget w;
XXtPointer client_data;
XXtPointer call_data;
{
X    SelectionPtr selection = GetSelectionFromWidget(w);
X
X    XbaeMatrixDeselectAll(selection->matrix);
X    selection->selected = False;
X
X    switch (((String)client_data)[0]) {
X    case '0':
X	selection->mode = ExclusiveMode;
X	break;
X    case '1':
X	selection->mode = AddMode;
X	break;
X    default:
X	XtAppWarningMsg(XtWidgetToApplicationContext(w),
X			"setSelectionModeCB", "badParam", "Select",
X			"Bad param passed to SetSelectionModeCB",
X			(String *) NULL, (Cardinal *) NULL);
X	break;
X    }
}
X
/*
X * Delete the selected row or column.
X */
/* ARGSUSED */
void
DeleteCB(w, client_data, call_data)
Widget w;
XXtPointer client_data;
XXtPointer call_data;
{
X    Widget matrix;
X    SelectionPtr selection;
X
X    if ((matrix = WcFullNameToWidget(w, (String)client_data)) == NULL)
X	return;
X
X    selection = GetSelectionFromWidget(matrix);
X
X    if (!selection->selected)
X	return;
X
X    /*
X     * We cop out and only delete the last row/column selected
X     */
X    switch (selection->type) {
X    case RowSelection:
X	XbaeMatrixDeleteRows(matrix, selection->row, 1);
X	break;
X    case ColumnSelection:
X	XbaeMatrixDeleteColumns(matrix, selection->column, 1);
X	break;
X    }
}
X
/*
X * Clear the selected row, column or cell.
X */
/* ARGSUSED */
void
ClearCB(w, client_data, call_data)
Widget w;
XXtPointer client_data;
XXtPointer call_data;
{
X    Widget matrix;
X    int rows, columns;
X    int i;
X    SelectionPtr selection;
X
X    if ((matrix = WcFullNameToWidget(w, (String)client_data)) == NULL)
X	return;
X
X    selection = GetSelectionFromWidget(matrix);
X
X    if (!selection->selected)
X	return;
X
X    XtVaGetValues(matrix,
X		  XmNcolumns, &columns,
X		  XmNrows, &rows,
X		  NULL);
X
X    /*
X     * We only clear the last selection made
X     */
X    switch (selection->type) {
X    case CellSelection:
X	XbaeMatrixSetCell(matrix, selection->row, selection->column, "");
X	break;
X    case RowSelection:
X	for (i = 0; i < columns; i++)
X	    XbaeMatrixSetCell(matrix, selection->row, i, "");
X	break;
X    case ColumnSelection:
X	for (i = 0; i < rows; i++)
X	    XbaeMatrixSetCell(matrix, i, selection->column, "");
X	break;
X    }
}
/*
X * Copy the selected row or column. Place the copy below it.
X */
/* ARGSUSED */
void
CopyCB(w, client_data, call_data)
Widget w;
XXtPointer client_data;
XXtPointer call_data;
{
X    Widget matrix;
X    int rows;
X    String **cells;
X    String *data;
X    String label, *row_labels, *column_labels;
X    short *widths, width;
X    int *lengths, length;
X    int i;
X    SelectionPtr selection;
X
X    if ((matrix = WcFullNameToWidget(w, (String)client_data)) == NULL)
X	return;
X
X    selection = GetSelectionFromWidget(matrix);
X
X    if (!selection->selected)
X	return;
X
X    XtVaGetValues(matrix,
X		  XmNcells, &cells,
X		  XmNrows, &rows,
X		  XmNcolumnWidths, &widths,
X		  XmNcolumnMaxLengths, &lengths,
X		  XmNrowLabels, &row_labels,
X		  XmNcolumnLabels, &column_labels,
X		  NULL);
X
X    /*
X     * Using data retrieved via GetValues in an Xt/widget function
X     * without copying it locally is dangerous.
X     * The below is just for demo purposes.
X     * We only copy the last selection made
X     */
X    switch (selection->type) {
X    case RowSelection:
X	label = row_labels ? row_labels[selection->row] : NULL;
X	XbaeMatrixAddRows(matrix, selection->row, cells[selection->row],
X			  &label, NULL, 1);
X	break;
X    case ColumnSelection:
X	data = (String *)XtMalloc(rows * sizeof(String));
X	for (i = 0; i < rows; i++)
X	    data[i] = cells[i][selection->column];
X	/* We could get colors, alignments etc and copy those too,
X	 * but I am lazy */
X	width = widths[selection->column];
X	length = lengths ?
X	    lengths[selection->column] : widths[selection->column];
X	label = column_labels ? column_labels[selection->column] : NULL;
X	XbaeMatrixAddColumns(matrix, selection->column, data,
X			     &label, &width, &length, NULL, NULL, NULL, 1);
X	XtFree((XtPointer)data);
X	break;
X    }
}
X
/* ARGSUSED */
void
DeselectCB(w, client_data, call_data)
Widget w;
XXtPointer client_data;
XXtPointer call_data;
{
X    Widget matrix;
X    SelectionPtr selection;
X
X    if ((matrix = WcFullNameToWidget(w, (String)client_data)) == NULL)
X	return;
X
X    selection = GetSelectionFromWidget(matrix);
X
X    XbaeMatrixDeselectAll(matrix);
X    selection->selected = False;
}
X
/* ARGSUSED */
void
LoadCB(w, client_data, call_data)
Widget w;
XXtPointer client_data;
XXtPointer call_data;
{
X    int i, j;
X    int rows, columns;
X    char buf[BUFSIZ];
X    String **cells;
X    Widget matrix;
X
X    if ((matrix = WcFullNameToWidget(w, client_data)) == NULL)
X	return;
X
X    XtVaGetValues(matrix,
X		  XmNrows, &rows,
X		  XmNcolumns, &columns,
X		  NULL);
X
X    cells = (String **) XtMalloc(sizeof(String *) * rows);
X    for (i = 0; i < rows; i++) {
X	cells[i] = (String *) XtMalloc(sizeof(String) * columns);
X	for (j = 0; j < columns; j++) {
X	    sprintf(buf, "r%dc%d", i, j);
X	    cells[i][j] = XtNewString(buf);
X	}
X    }
X
X    XtVaSetValues(matrix,
X		  XmNcells, cells,
X		  NULL);
X
X    for (i = 0; i < rows; i++) {
X	for (j = 0; j < columns; j++)
X	    XtFree((XtPointer)cells[i][j]);
X	XtFree((XtPointer)cells[i]);
X    }
X    XtFree((XtPointer)cells);
}
X
SelectionPtr
GetSelectionFromWidget(w)
Widget w;
{
X    SelectionPtr selection = NULL;
X
X    XtVaGetValues(w,
X		  XmNuserData, &selection,
X		  NULL);
X    if (selection == NULL)
X	XtAppErrorMsg(XtWidgetToApplicationContext(w),
X		      "getSelectionFromWidget", "notRegistered", "Select",
X		      "Widget not registered",
X		      NULL, 0);
X    return selection;
}
SHAR_EOF
chmod 0644 Xbae/examples/select/select.c ||
echo 'restore of Xbae/examples/select/select.c failed'
Wc_c="`wc -c < 'Xbae/examples/select/select.c'`"
test 11563 -eq "$Wc_c" ||
	echo 'Xbae/examples/select/select.c: original size 11563, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/select/Select.ad ==============
if test -f 'Xbae/examples/select/Select.ad' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/select/Select.ad (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/select/Select.ad (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/select/Select.ad' &&
Select.wcChildren:		mainWin
X
*XbaeMatrix.fontList:		-*-courier-medium-r-*-*-*-140-*-*-*-*-*-*
*fontList:			-*-helvetica-bold-r-*-*-*-140-*-*-*-*-*-*
X
*menuBar*background:		VioletRed3
*background:			salmon2
X
X
*mainWin.wcClassName:		XmMainWindow
*mainWin.showSeparators:	True
*mainWin.wcChildren:		menuBar, matrix, buttonBox
X
!
! Menubar and all menus
!
X
*menuBar.wcConstructor: 	XmCreateMenuBar
*menuBar.wcCallback:		WcSetValueCB( *mainWin.menuBar: this )
*menuBar.wcChildren:		file, edit, help
*menuBar.wcPopups:		fileMenu, editMenu, helpMenu
X
*menuBar*XmCascadeButton.marginWidth:	8
*menuBar*XmRowColumn.spacing:		0
X
*file.wcConstructor:		XmCreateCascadeButton
*file.labelString:		File
*file.subMenuId:		*fileMenu
*fileMenu.wcConstructor:	XmCreatePulldownMenu
*fileMenu.wcChildren:		f_load, f_exit
X
*fileMenu*wcConstructor:	XmCreatePushButton
*f_load.labelString:		Load
*f_load.activateCallback:	LoadCB(*matrix)
*f_exit.labelString:		Exit
*f_exit.activateCallback:	WcExitCB()
X
*edit.wcConstructor:		XmCreateCascadeButton
*edit.labelString:		Edit
*edit.subMenuId:		*editMenu
*editMenu.wcConstructor:	XmCreatePulldownMenu
*editMenu.wcChildren:		e_copy, e_clear, e_delete, e_deselect
X
*editMenu*wcConstructor:	XmCreatePushButton
*e_copy.labelString:		Copy
*e_copy.activateCallback: 	CopyCB(*matrix)
*e_clear.labelString:		Clear
*e_clear.activateCallback: 	ClearCB(*matrix)
*e_delete.labelString:		Delete
*e_delete.activateCallback: 	DeleteCB(*matrix)
*e_deselect.labelString:	Deselect
*e_deselect.activateCallback: 	DeselectCB(*matrix)
X
*help.wcConstructor:		XmCreateCascadeButton
*help.wcCallback:		WcSetValueCB( ^.menuHelpWidget: this )
*help.labelString:		Help
*help.subMenuId:		*helpMenu
*helpMenu.wcConstructor:	XmCreatePulldownMenu
*helpMenu.wcChildren:		h_onSelect
X
*helpMenu*wcConstructor:	XmCreatePushButton
*h_onSelect.labelString:	On Select...
*h_onSelect.activateCallback:	WcCreateChildrenCB( Select, helpDialog ),\
X				WcSetValueCB(this.activateCallback: \
X					WcManageCB( *helpDialog ))
X
*helpDialog.wcConstructor:	XmCreateInformationDialog
*helpDialog.wcCallback:		WcUnmanageCB( .Cancel, .Help )
*helpDialog.messageString:\
Shift-Click Button1 to select a row, column or cell.\n\
Select the mode with the "Selection Mode" menu.\n\
Select the type with the "Selection Type" menu.
X
X
!
! Matrix
!
X
*matrix.wcClassName:		XbaeMatrix
*matrix.wcCallback:		WcSetValueCB( *mainWin.workWindow: this ),\
X				NewMatrixCB()
*matrix.boldLabels:		True
*matrix.rowLabels:		1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
*matrix.columnLabels:		One,Two,Three,Four,Five,Six,Seven,Eight,\
X				Nine,Ten
*matrix.rows:			15
*matrix.columns:		10
*matrix.visibleRows:		8
*matrix.visibleColumns:		5
*matrix.columnWidths:		10,5,10,5,10,5,10,10,5,10
*matrix.selectCellCallback:	SelectCB()
*matrix.translations:		#override\n\
X				Shift<Btn1Down>:	SelectCell()
X
!
! buttonBox
!
*buttonBox.wcClassName:		XmRowColumn
*buttonBox.wcChildren:		selectionType, selectionMode
*buttonBox.wcCallback:		WcSetValueCB( *mainWin.commandWindow: this )
X
X
*selectionType.wcConstructor:	XmCreateOptionMenu
*selectionType.labelString:	Selection Type:
*selectionType.wcPopups:	typeMenu
X
*typeMenu.wcConstructor:	XmCreatePulldownMenu
*typeMenu.wcCallback:		WcSetValueCB(^^.subMenuId: this)
*typeMenu.wcChildren:		cellType, rowType, columnType
X
*typeMenu*wcConstructor:	XmCreatePushButton
X
*cellType.labelString:		Cell
*cellType.wcCallback:		RegisterSelectionWidgetCB(*matrix),\
X				SetSelectionTypeCB(1)
*cellType.activateCallback:	SetSelectionTypeCB(1)
*rowType.labelString:		Row
*rowType.wcCallback:		RegisterSelectionWidgetCB(*matrix)
*rowType.activateCallback:	SetSelectionTypeCB(2)
*columnType.labelString:	Column
*columnType.wcCallback:		RegisterSelectionWidgetCB(*matrix)
*columnType.activateCallback:	SetSelectionTypeCB(3)
X
X
*selectionMode.wcConstructor:	XmCreateOptionMenu
*selectionMode.labelString:	Selection Mode:
*selectionMode.wcPopups:	modeMenu
X
*modeMenu.wcConstructor:	XmCreatePulldownMenu
*modeMenu.wcCallback:		WcSetValueCB(^^.subMenuId: this)
*modeMenu.wcChildren:		exclusiveMode, addMode
*modeMenu*wcConstructor:	XmCreatePushButton
X
*exclusiveMode.labelString:	Exclusive
*exclusiveMode.wcCallback:	RegisterSelectionWidgetCB(*matrix),\
X				SetSelectionModeCB(0)
*exclusiveMode.activateCallback:SetSelectionModeCB(0)
X
*addMode.labelString:		Add
*addMode.wcCallback:		RegisterSelectionWidgetCB(*matrix)
*addMode.activateCallback:	SetSelectionModeCB(1)
SHAR_EOF
chmod 0644 Xbae/examples/select/Select.ad ||
echo 'restore of Xbae/examples/select/Select.ad failed'
Wc_c="`wc -c < 'Xbae/examples/select/Select.ad'`"
test 4422 -eq "$Wc_c" ||
	echo 'Xbae/examples/select/Select.ad: original size 4422, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/select/Imakefile ==============
if test -f 'Xbae/examples/select/Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/select/Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/select/Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/select/Imakefile' &&
#include "../../Xbae.tmpl"
X
X   LOCAL_LDFLAGS = -L../../src
X LOCAL_LIBRARIES = -lXbae -lXmp -lXm -lWc -lXt -lX11
X         DEPLIBS =
X        INCLUDES = -I../../src
X         DEFINES = -D_NO_PROTO
X
UninstalledSimpleProgramTarget(select)
SHAR_EOF
chmod 0644 Xbae/examples/select/Imakefile ||
echo 'restore of Xbae/examples/select/Imakefile failed'
Wc_c="`wc -c < 'Xbae/examples/select/Imakefile'`"
test 233 -eq "$Wc_c" ||
	echo 'Xbae/examples/select/Imakefile: original size 233, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/traversal/traversal.c ==============
if test ! -d 'Xbae/examples/traversal'; then
    echo 'x - creating directory Xbae/examples/traversal'
    mkdir 'Xbae/examples/traversal'
fi
if test -f 'Xbae/examples/traversal/traversal.c' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/traversal/traversal.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/traversal/traversal.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/traversal/traversal.c' &&
/*
X * Copyright(c) 1992 Bell Communications Research, Inc. (Bellcore)
X *                        All rights reserved
X * Permission to use, copy, modify and distribute this material for
X * any purpose and without fee is hereby granted, provided that the
X * above copyright notice and this permission notice appear in all
X * copies, and that the name of Bellcore not be used in advertising
X * or publicity pertaining to this material without the specific,
X * prior written permission of an authorized representative of
X * Bellcore.
X *
X * BELLCORE MAKES NO REPRESENTATIONS AND EXTENDS NO WARRANTIES, EX-
X * PRESS OR IMPLIED, WITH RESPECT TO THE SOFTWARE, INCLUDING, BUT
X * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
X * FITNESS FOR ANY PARTICULAR PURPOSE, AND THE WARRANTY AGAINST IN-
X * FRINGEMENT OF PATENTS OR OTHER INTELLECTUAL PROPERTY RIGHTS.  THE
X * SOFTWARE IS PROVIDED "AS IS", AND IN NO EVENT SHALL BELLCORE OR
X * ANY OF ITS AFFILIATES BE LIABLE FOR ANY DAMAGES, INCLUDING ANY
X * LOST PROFITS OR OTHER INCIDENTAL OR CONSEQUENTIAL DAMAGES RELAT-
X * ING TO THE SOFTWARE.
X */
X
#include <Xbae/Matrix.h>
X
/*
X * Custom traversal.
X * Defines a new type of traversal.  Pressing the Return key will
X * now move down a row and back to the first column (like a carriage
X * return).
X */
X
void TraverseCB();
X
main(argc, argv)
int argc;
char *argv[];
{
X    Widget toplevel, mw;
X    XtAppContext app;
X
X    toplevel = XtVaAppInitialize(&app, "Traversal",
X				 NULL, 0,
X				 &argc, argv,
X				 NULL,
X				 NULL);
X
X    mw = XtVaCreateManagedWidget("mw",
X				 xbaeMatrixWidgetClass, toplevel,
X				 NULL);
X    XtAddCallback(mw, XmNtraverseCellCallback, TraverseCB, NULL);
X
X    XtRealizeWidget(toplevel);
X    XtAppMainLoop(app);
}
X
/*
X * Custom traversal callback.  If the EditCell() action has the param
X * "Return", then we move down a row and back to the first editable
X * column.
X */
/* ARGSUSED */
void
TraverseCB(w, client_data, call_data)
Widget w;
XXtPointer client_data;
XXbaeMatrixTraverseCellCallbackStruct *call_data;
{
X    static XrmQuark Qreturn = NULLQUARK;
X
X    /*
X     * Get a Quark for our special action parm (for faster comparisons)
X     */
X    if (Qreturn == NULLQUARK)
X	Qreturn = XrmStringToQuark("Return");
X
X    /*
X     * See if this is our special quark
X     */
X    if (call_data->qparam != Qreturn)
X	return;
X
X    /*
X     * If we are on the last row we don't move
X     */
X    if (call_data->row == call_data->num_rows - 1)
X	return;
X
X    /*
X     * Move down a row and back to the first non-fixed column
X     */
X    call_data->next_row = call_data->row + 1;
X    call_data->next_column = call_data->fixed_columns;
}
X
X
X
SHAR_EOF
chmod 0644 Xbae/examples/traversal/traversal.c ||
echo 'restore of Xbae/examples/traversal/traversal.c failed'
Wc_c="`wc -c < 'Xbae/examples/traversal/traversal.c'`"
test 2639 -eq "$Wc_c" ||
	echo 'Xbae/examples/traversal/traversal.c: original size 2639, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/traversal/Traversal.ad ==============
if test -f 'Xbae/examples/traversal/Traversal.ad' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/traversal/Traversal.ad (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/traversal/Traversal.ad (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/traversal/Traversal.ad' &&
*mw.rows:		10
*mw.columns:		5
*mw.columnWidths:	10, 5, 10, 15, 1
X
! We need translations on the TextField edit widget to do our custom
! traversal (EditCell(Return))
*mw.textTranslations:	#override\n\
X			Shift ~Ctrl ~Meta ~Alt <Key>Tab:   EditCell(Left)\n\
X			~Ctrl ~Meta ~Alt <Key>Tab:	   EditCell(Right)\n\
X			<Key>osfUp:			   EditCell(Up)\n\
X			<Key>osfDown:			   EditCell(Down)\n\
X			<Key>osfActivate:		   EditCell(Return)\n\
X			~Shift ~Meta ~Alt <Key>Return:	   EditCell(Return)\n\
X			<Key>osfCancel:			   CancelEdit()
SHAR_EOF
chmod 0644 Xbae/examples/traversal/Traversal.ad ||
echo 'restore of Xbae/examples/traversal/Traversal.ad failed'
Wc_c="`wc -c < 'Xbae/examples/traversal/Traversal.ad'`"
test 524 -eq "$Wc_c" ||
	echo 'Xbae/examples/traversal/Traversal.ad: original size 524, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/traversal/Imakefile ==============
if test -f 'Xbae/examples/traversal/Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/traversal/Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/traversal/Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/traversal/Imakefile' &&
#include "../../Xbae.tmpl"
X
X   LOCAL_LDFLAGS = -L../../src
X LOCAL_LIBRARIES = -lXbae -lXm -lXt -lX11
X         DEPLIBS =
X        INCLUDES = -I../../src
X         DEFINES = -D_NO_PROTO
X
UninstalledSimpleProgramTarget(traversal)
SHAR_EOF
chmod 0644 Xbae/examples/traversal/Imakefile ||
echo 'restore of Xbae/examples/traversal/Imakefile failed'
Wc_c="`wc -c < 'Xbae/examples/traversal/Imakefile'`"
test 225 -eq "$Wc_c" ||
	echo 'Xbae/examples/traversal/Imakefile: original size 225, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbae/examples/README ==============
if test -f 'Xbae/examples/README' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbae/examples/README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbae/examples/README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbae/examples/README' &&
To run the example programs, change into the example directory,
SHAR_EOF
true || echo 'restore of Xbae/examples/README failed'
fi
echo 'End of Xbae part 11'
echo 'File Xbae/examples/README is continued in part 12'
echo 12 > _shar_seq_.tmp
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
