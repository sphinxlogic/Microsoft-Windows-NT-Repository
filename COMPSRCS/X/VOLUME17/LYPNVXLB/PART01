Newsgroups: comp.sources.x
Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: Renaldo Recuerdo <rr@sco.COM>
Subject: v17i048: Xlib only lyapunov, Part01/02
Message-ID: <csx-17i048-lyapunov-xlib@uunet.UU.NET>
Originator: dcmartin@snoopy
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Organization: Molecular Simulations, Inc.
Date: Wed, 1 Apr 1992 14:45:31 GMT
Approved: dcmartin@msi.com

Submitted-by: Renaldo Recuerdo <rr@sco.COM>
Posting-number: Volume 17, Issue 48
Archive-name: lyapunov-xlib/part01

# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 04/01/1992 14:44 UTC by dcmartin@snoopy
# Source directory /home/fascet/csx/src
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#    719 -rw-r--r-- Imakefile
#    969 -rw-r--r-- Makefile.ODT
#    810 -rw-r--r-- Makefile.OSF
#    141 -rw-r--r-- Package
#   2890 -rw-r--r-- README
#   3365 -rw-r--r-- TAGS
#   2282 -rw-r--r-- hls2rgb.c
#   7181 -rw-r--r-- lyap.6X
#  40245 -rw-r--r-- lyap.c
#   3798 -rw-r--r-- lyap.h
#   6696 -rw-r--r-- lyap.man
#     91 -rw-r--r-- params/asharpe.1
#     57 -rw-r--r-- params/asharpe.2
#     86 -rw-r--r-- params/asharpe.3
#     79 -rw-r--r-- params/asharpe.4
#     73 -rw-r--r-- params/asharpe.5
#     77 -rw-r--r-- params/asharpe.6
#     91 -rw-r--r-- params/asharpe.7
#     88 -rw-r--r-- params/asharpe.8
#     87 -rw-r--r-- params/asharpe.9
#     81 -rw-r--r-- params/circle-12
#     68 -rw-r--r-- params/circle-12test
#     65 -rw-r--r-- params/circle-2
#     73 -rw-r--r-- params/circle-4
#     77 -rw-r--r-- params/circle-8
#    119 -rw-r--r-- params/manray
#     76 -rw-r--r-- params/period-12
#     60 -rw-r--r-- params/period-2
#     68 -rw-r--r-- params/period-4
#     72 -rw-r--r-- params/period-8
#     81 -rw-r--r-- params/skewed-12
#     65 -rw-r--r-- params/skewed-2
#     73 -rw-r--r-- params/skewed-4
#     78 -rw-r--r-- params/skewed-8
#    123 -rw-r--r-- patchlevel.h
#   2381 -rw-r--r-- tags
#     33 -rw-r--r-- testit
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= Imakefile ==============
if test -f 'Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Imakefile' &&
#
#	Imakefile for lyap, by Ron Record
#
X        DEPLIBS = $(DEPXLIB)
#	Uncomment the following line if you have only 16 colors
#    COLORDEFINE = -DSIXTEEN_COLORS
#	Uncomment the following line if your system doesn't support prototypes 
#    PROTODEFINE = -D_NO_PROTO
#	-DMAPS includes code to support "Function forcing". See lyap.man (-F)
X      MAPDEFINE = -DMAPS
X        DEFINES = $(COLORDEFINE) $(MAPDEFINE) $(PROTODEFINE)
X         CFLAGS = -O $(DEFINES) $(CDEBUGFLAGS)
LOCAL_LIBRARIES = $(XLIB) 
X  SYS_LIBRARIES = -lm
X       INCLUDES = .
X           SRCS = lyap.c hls2rgb.c
X           OBJS = lyap.o hls2rgb.o
X
ComplexProgramTarget(lyap)
X
InstallProgram(lyap, /usr/games/X11)
InstallManPage(lyap, /usr/games/X11/doc)
SHAR_EOF
chmod 0644 Imakefile ||
echo 'restore of Imakefile failed'
Wc_c="`wc -c < 'Imakefile'`"
test 719 -eq "$Wc_c" ||
	echo 'Imakefile: original size 719, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile.ODT ==============
if test -f 'Makefile.ODT' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile.ODT (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile.ODT (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile.ODT' &&
CC = cc 
#DEBUG =  -g
##
## Compiler Defines
## 
DEFINES = -DSYSV -DSOCKETCONN -DTCPCONN -DTLICONN -DLAI_TCP \
X	   -DSTREAMWRITEMAX=4096 -DXSIGHT -DSIXTEEN_COLORS -DMAPS
X
CFLAGS = $(DEBUG) $(DEFINES)
##
## Libraries
## X11 	X11 graphics library
##
##
LIBS 	= 	-lX11	\
X		-lx		\
X      		-lsocket	\
X		-lnsl_s	\
X		-lPW	\
X		-lm
X
X
.o:.c
X
all: lyap lyap.doc
X
cp install:	all
X	-mkdir -p $(ROOT)/usr/games/X11
X	cp lyap $(ROOT)/usr/games/X11/lyap
X	-mkdir -p $(ROOT)/usr/games/X11/doc
X	cp lyap.doc $(ROOT)/usr/games/X11/doc/lyap
X	-mkdir -p $(ROOT)/usr/games/X11/lib/lyap
X	cp params/* $(ROOT)/usr/games/X11/lib/lyap
X	-mkdir -p $(ROOT)/usr/games/X11/lib/lyap/pics
X	cp pics/* $(ROOT)/usr/games/X11/lib/lyap/pics
X
clean:
X	rm -f *.o
X
clobber:	clean
X	rm -f lyap
X
lyap : lyap.o hls2rgb.o
X	$(CC) $(CFLAGS) -o $@ $@.o hls2rgb.o $(LIBS)
X
lyap.o: lyap.c hls2rgb.c lyap.h
X
lyap.doc:	lyap.man
X	nroff -man lyap.man > lyap.doc
X
lyap.doc.mm:	lyap.man.mm
X	nroff -cm -rN4 lyap.man.mm > lyap.doc.mm
SHAR_EOF
chmod 0644 Makefile.ODT ||
echo 'restore of Makefile.ODT failed'
Wc_c="`wc -c < 'Makefile.ODT'`"
test 969 -eq "$Wc_c" ||
	echo 'Makefile.ODT: original size 969, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile.OSF ==============
if test -f 'Makefile.OSF' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile.OSF (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile.OSF (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile.OSF' &&
CC = cc 
#DEBUG =  -g
##
## Compiler Defines
## 
DEFINES = -DMAPS
X
CFLAGS = $(DEBUG) $(DEFINES)
##
## Libraries
## X11 	X11 graphics library
##
##
LIBS 	= -lX11 -lm
X
.o:.c
X
all: lyap lyap.doc
X
cp install:	all
X	-mkdir -p $(ROOT)/usr/games/X11
X	cp lyap $(ROOT)/usr/games/X11/lyap
X	-mkdir -p $(ROOT)/usr/games/X11/doc
X	cp lyap.doc $(ROOT)/usr/games/X11/doc/lyap
X	-mkdir -p $(ROOT)/usr/games/X11/lib/lyap
X	cp params/* $(ROOT)/usr/games/X11/lib/lyap
X	-mkdir -p $(ROOT)/usr/games/X11/lib/lyap/pics
X	cp pics/* $(ROOT)/usr/games/X11/lib/lyap/pics
X
clean:
X	rm -f *.o
X
clobber:	clean
X	rm -f lyap
X
lyap : lyap.o hls2rgb.o
X	$(CC) $(CFLAGS) -o $@ $@.o hls2rgb.o $(LIBS)
X
lyap.o: lyap.c hls2rgb.c lyap.h
X
lyap.doc:	lyap.man
X	nroff -man lyap.man > lyap.doc
X
lyap.doc.mm:	lyap.man.mm
X	nroff -cm -rN4 lyap.man.mm > lyap.doc.mm
SHAR_EOF
chmod 0644 Makefile.OSF ||
echo 'restore of Makefile.OSF failed'
Wc_c="`wc -c < 'Makefile.OSF'`"
test 810 -eq "$Wc_c" ||
	echo 'Makefile.OSF: original size 810, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Package ==============
if test -f 'Package' -a X"$1" != X"-c"; then
	echo 'x - skipping Package (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Package (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Package' &&
[ -f lyap.shar ] && mv lyap.shar lyap.shar-
shar R* Imakefile M*T M*F Package *.c *.h lyap.6X lyap.man tags TAGS params/* testit > lyap.shar
SHAR_EOF
chmod 0644 Package ||
echo 'restore of Package failed'
Wc_c="`wc -c < 'Package'`"
test 141 -eq "$Wc_c" ||
	echo 'Package: original size 141, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
X
X
Written by Ronald Joe Record (rr@sco) 03 Sep 1991
X
INTRO
-----
X
The idea here is to calculate the Lyapunov exponent for a periodically
forced logistic map (later i added several other nonlinear maps of the unit
interval). In order to turn the 1-dimensional parameter space of the
logistic map into a 2-dimensional parameter space, select two parameter
values (a and b) then alternate the iterations of the logistic map using
first a then b as the parameter. This program accepts an argument to 
specify a forcing function, so instead of just alternating a and b, you
can use a as the parameter for say 6 iterations, then b for 6 iterations
and so on. An interesting forcing function to look at is abbabaab (the
Morse-Thue sequence, an aperiodic self-similar, self-generating sequence).
Anyway, you step through all the values of a and b in the ranges you want,
calculating the Lyapunov exponent for each pair of values. The exponent
is calculated by iterating out a ways (specified by the variable "settle")
then on subsequent iterations calculating an average of the logarithm of
the absolute value of the derivative at that point. Points in parameter
space with a negative Lyapunov exponent are colored one way (using the
value of the exponent to index into a color map) while points with a
non-negative exponent are colored differently. 
X
ACKNOWLEDGEMENTS
----------------
X
The algorithm was taken from the September 1991 Scientific American article
by A. K. Dewdney who gives credit to Mario Markus of the Max Planck Institute
for its creation. Additional information and ideas were gleaned from the
discussion on alt.fractals involving Stephen Hall, Ed Kubaitis, Dave Platt
and Baback Moghaddam. Assistance with colormaps and spinning color wheels
and X was gleaned from Hiram Clawson. Rubber band code was adapted from 
Stacey Campbell's xmandel source.
X
BUILD
-----
X
To build the lyap binary, either use the Imakefile or one of the sample 
makefiles - Makefile.ODT or Makefile.OSF. Makefile.ODT is a sample makefile
used to build lyap on an SCO ODT system. Makefile.OSF was used as a makefile
on a DECstation 3100 running OSF/1. If your system has only 16 colors, 
uncomment the COLORDEFINE line of the Imakefile and/or add a -DSIXTEEN_COLORS 
to the appropriate makefile. The manual page can be formatted by typing 
"nroff -man lyap.man > lyap.doc".
X
INSTALL
-------
X
To install lyap, copy the lyap binary to the desired location (the sample
makefiles put it in /usr/games/X11)
Copy the formatted man page to wherever you keep your local doc (i use
/usr/games/X11/doc for games and imaging software), then add that location
to your MANPATH.
X
Some "interesting" runs of lyap are included as simple shell scripts in the
"params" subdirectory.
X
X
Ideas, comments, additions, deletions, suggestions, bug reports, code review,...
e-mail Ronald Record at rr@sco.com or ...uunet!sco!rr.
X
SHAR_EOF
chmod 0644 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 2890 -eq "$Wc_c" ||
	echo 'README: original size 2890, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= TAGS ==============
if test -f 'TAGS' -a X"$1" != X"-c"; then
	echo 'x - skipping TAGS (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting TAGS (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'TAGS' &&
ABS               20 lyap.h           #define ABS(a)	(((a)<0) ? (0-(a)) : (a) )
BufferPoint     1388 lyap.c           BufferPoint(display, window, color, x, y)
Clear           1152 lyap.c           Clear() 
CreateXorGC     1173 lyap.c           CreateXorGC()
Cycle_frames     743 lyap.c           Cycle_frames()
Destroy_frame   1362 lyap.c           Destroy_frame()
EndRubberBand   1248 lyap.c           void 
FlushBuffer     1408 lyap.c           FlushBuffer()
Getkey           777 lyap.c           Getkey(event)
InitBuffer      1379 lyap.c           InitBuffer()
Max               22 lyap.h           #define Max(x,y) ((x > y)?x:y)
Min               21 lyap.h           #define Min(x,y) ((x < y)?x:y)
Redraw          1048 lyap.c           Redraw() 
SetupCorners    1202 lyap.c           SetupCorners(corners, data)
Spin             753 lyap.c           Spin(w)
StartRubberBand 1185 lyap.c           void 
TrackRubberBand 1218 lyap.c           void 
check_params     678 lyap.c           check_params(mapnum, parnum)
circle           250 lyap.c           circle(x, r)			/* sin() hump or sorta like the circle map */
complyap         131 lyap.c           complyap()
dcircle          259 lyap.c           dcircle(x, r)			/* derivative of the "sin() hump" */
ddoublelog       309 lyap.c           ddoublelog(x, r)		/* derivative of the double logistic */
dleftlog         278 lyap.c           dleftlog(x, r)			/* derivative of the left skewed logistic */
dlogistic        243 lyap.c           dlogistic(x, r)			/* the derivative of logistic map */
doublelog        299 lyap.c           doublelog(x, r)			/* double logistic */
drightlog        292 lyap.c           drightlog(x, r)			/* derivative of the right skewed logistic */
freemem         1481 lyap.c           freemem()
go_back         1322 lyap.c           go_back() 
go_down         1311 lyap.c           go_down() 
go_init         1354 lyap.c           go_init() 
hls2rgb           24 hls2rgb.c        void hls2rgb( hue_light_sat, rgb )
hue_value         82 hls2rgb.c        static double hue_value( n1, n2, hue )
init_canvas      344 lyap.c           init_canvas()
init_color       366 lyap.c           init_color()
init_data        319 lyap.c           init_data()
jumpwin         1332 lyap.c           jumpwin()
leftlog          268 lyap.c           leftlog(x, r)			/* left skewed logistic */
logistic         236 lyap.c           logistic(x, r)			/* the familiar logistic map */
main              37 lyap.c           main(ac, av)
main_event        91 lyap.c           main_event()
parseargs        563 lyap.c           parseargs(ac, av)
print_help      1426 lyap.c           print_help() 
print_values    1452 lyap.c           print_values() 
recalc          1137 lyap.c           recalc() 
redisplay        968 lyap.c           void 
redraw          1018 lyap.c           redraw(exparray, index, cont)
resize           982 lyap.c           resize()
rightlog         285 lyap.c           rightlog(x, r)			/* right skewed logistic */
save_to_file    1062 lyap.c           save_to_file() 
sendpoint        924 lyap.c           sendpoint(expo)
set_new_params  1284 lyap.c           set_new_params(w, data)
setforcing      1502 lyap.c           setforcing()
setupmem        1489 lyap.c           setupmem()
show_defaults   1161 lyap.c           show_defaults() 
usage            704 lyap.c           usage()
SHAR_EOF
chmod 0644 TAGS ||
echo 'restore of TAGS failed'
Wc_c="`wc -c < 'TAGS'`"
test 3365 -eq "$Wc_c" ||
	echo 'TAGS: original size 3365, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= hls2rgb.c ==============
if test -f 'hls2rgb.c' -a X"$1" != X"-c"; then
	echo 'x - skipping hls2rgb.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting hls2rgb.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'hls2rgb.c' &&
/* From colorwheel.c which is part of color3 by Hiram Clawson (hiramc@sco.com)*/
X
#include	<X11/Xlib.h>
#include	<X11/Xutil.h>
X
#ifdef _NO_PROTO
static double hue_value();
#else
static double hue_value( double, double, double );
#endif
X
/***********************************************************************
X * NAME: hls2rgb() from foley and van dam, fundamentals of interactive ...
X *		page 619
X *
X * PURPOSE: Convert hls[0..3600][0..1000][0..1000] space to rgb space
X *	That is the Hue, Lightness, Saturation color model.
X *	Which is two cones, base to base, the bottom tip is black, the
X *	top tip is white, the middle (bases) around the outside is a color
X *	wheel.  The axis of this solid is Lightness.  Hue is the angular
X *	measure around the cones, and the saturation is the radius from the
X *	axis towards the surface of the cones.
X ***********************************************************************/
void hls2rgb( hue_light_sat, rgb )
int hue_light_sat[3];
int rgb[3];		/*	Each in range [0..65535]	*/
{
X	double r, g, b, h, l, s;
X	double m1, m2;
X
X	h = (double) hue_light_sat[0] / 10.0;
X	l = (double) hue_light_sat[1] / 1000.0;
X	s = (double) hue_light_sat[2] / 1000.0;
X
X	if ( l < 0.5 )
X	{
X		m2 = l * ( 1.0 + s );
X	}
X	else
X	{
X		m2 = l + s - (l * s);
X	}
X	m1 = (2.0 * l) - m2;
X	if ( (s + 1.0) == 1.0 )
X	{
X		if ( (h + 1.0) < 1.0 )
X		{
X			r = g = b = l;
X		}
X		else
X		{
X			r = g = b = 0.0;
X		}
X	}
X	else
X	{
X		r = hue_value( m1, m2, h + 120.0 );
X		g = hue_value( m1, m2, h );
X		b = hue_value( m1, m2, h - 120.0 );
X	}
X	rgb[0] = 65535.0 * r;
X	rgb[1] = 65535.0 * g;
X	rgb[2] = 65535.0 * b;
X	if ( rgb[0] > 65535 )
X		rgb[0] = 65535;
X	else if ( rgb[0] < 0 )
X		rgb[0] = 0;
X
X	if ( rgb[1] > 65535 )
X		rgb[1] = 65535;
X	else if ( rgb[1] < 0 )
X		rgb[1] = 0;
X
X	if ( rgb[2] > 65535 )
X		rgb[2] = 65535;
X	else if ( rgb[2] < 0 )
X		rgb[2] = 0;
X
X	return;
}	/* end of void hls2rgb( hue_light_sat, rgb )	*/
X
static double hue_value( n1, n2, hue )
double n1;
double n2;
double hue;
{
X	if ( hue > 360.0 )
X		hue -= 360.0;
X	if ( hue < 0.0 )
X		hue += 360.0;
X	if ( hue < 60.0 )
X		return  ( n1 + ((n2 - n1)*hue/60.0));
X	else if ( hue < 180.0 )
X		return ( n2 );
X	else if ( hue < 240.0 )
X		return ( n1 + ((n2 - n1)*(240.0 - hue)/60.0));
X	else
X		return( n1 );
}	/* end of double hue_value( n1, n2, hue )	*/
SHAR_EOF
chmod 0644 hls2rgb.c ||
echo 'restore of hls2rgb.c failed'
Wc_c="`wc -c < 'hls2rgb.c'`"
test 2282 -eq "$Wc_c" ||
	echo 'hls2rgb.c: original size 2282, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= lyap.6X ==============
if test -f 'lyap.6X' -a X"$1" != X"-c"; then
	echo 'x - skipping lyap.6X (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting lyap.6X (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'lyap.6X' &&
X
X
X
LYAP(6X)                                                             LYAP(6X)
X
X
X
NAME
X  lyap - display an array of Lyapunov exponents graphically
X
SYNOPSIS
X  _l_y_a_p [-BLps][-W width][-H height][-o filename][-a _n ] [-b _n ] [-w _n ] [-h _n
X          ] [-i xstart] [-M _n ] [-R _p ] [-S _n ] [-D _n ] [-F string][-f
X          string][-r _n ] [-O _n ] [-C _n ] [-c _n ] [-m _n ] [-x xpos] [-y ypos]
X
DESCRIPTION
X  _l_y_a_p generates and graphically displays an array of Lyapunov exponents for
X  a variety of iterated periodically forced non-linear maps of the unit
X  interval.
X
OPTIONS
X
X  -C _n    Specifies the minimum color index to be used for negative exponents
X
X  -D _n    Specifies the "dwell" or number of iterations over which to average
X          in order to calculate the Lyapunov exponent. Default is 400.
X
X  -B      Causes the stop, go, spin and quit buttons to be displayed.
X
X  -H _n    Specifies the height of the window. Default is 256.
X
X  -L      Indicates use log(x) + log(y) rather than log(xy).
X
X  -M _r    Specifies the real value to compare exponent values to for indexing
X          into a color wheel. The default value is 1.0.
X
X  -O _n    Specifies the minimum color index to be used for positive exponents
X
X  -R _p    Specifies pseudo-random forcing with probability _p of using parame-
X          ter value 'a'.
X
X  -S _n    Specifies the "settle" or number of iterations prior to the begin-
X          ning of the calculation of the Lyapunov exponent. Default is 200.
X
X  -W _n    Specifies the width of the window. Default is 256.
X
X  -a _r    Specifies the real value to use as the minimum parameter value of
X          the horizontal axis. Default is 3.0 for the logistic map.
X
X  -b _n    Specifies the real value to use as the minimum parameter value of
X          the vertical axis. Default is 3.0 for the logistic map.
X
X  -c _n    Selects one of six different color wheels to use. The default color
X          wheel is a rainbow palette.
X
X  -F _1_0_1_0_1_0_1_0
X          Specifies the "Function" forcing function to use. The example above
X          would alternate between iterating the circle and logistic maps. An
X          argument of "-F 2323" would alternate between left and right logis-
X          tic maps. The default is to only use the single specified map (see
X          the description of -m).
X
X  -f _a_b_b_a_b_a_a_b
X          Specifies the forcing function to use. The default is to alternate
X          between the "a" parameter and the "b" parameter.
X
X  -h _r    Specifies the real value to be used as the range over which the
X          vertical parameter values vary. The default is 1.0.
X
X  -i _r    Specifies the real value of the initial condition to use. Default
X          is 0.05.
X
X  -m _n    Selects between available non-linear maps of the unit interval. A
X          value of 0 specifies the logistic map. A value of 1, the circle
X          map. A value of 2, the left-logistic. A value of 3, the right-
X          logistic. A value of 4, the double-logistic. The default is 0, the
X          logistic map.
X
X  -o _f_i_l_e_n_a_m_e
X          Specifies the output filename to be used. If the -o option is
X          given, this file will automatically be written out at the comple-
X          tion of the drawing.  If it is not specified, a default filename of
X          lyap.out is used and only written if the 'f' or 'F' keys are
X          pressed during a run. The format of the output file is PPM for
X          color and PGM for monochrom. The parameters used to calculate the
X          picture are included as comments at the beginning of the output
X          file.
X
X  -p      Switches color indices for negative and positive exponents. Gen-
X          erally, causes negative exponents to be displayed in more detail
X          while darkening and narrowing the color range for positive
X          exponents. This can be toggled during runtime by pressing the 'p'
X          key.
X
X  -r _n    Specifies the maximum rgb value to be used. Default is 35000.
X
X  -s _n    Specifies the length of the color wheel spin.
X
X  -u      Produces a usage message.
X
X  -v      Prints out the various values to be used and exits.
X
X  -w _r    Specifies the real value to be used as the range over which the
X          horizontal parameter values vary. The default is 1.0.
X
X  -x _n    Specifies the x screen coordinate of the window (default is 256).
X
X  -y _n    Specifies the y screen coordinate of the window (default is 256).
X
X
X
NOTES
X
X  During display, pressing any mouse button allows you to select the area to
X  be investigated with the mouse. The upper left hand corner of the desired
X  area is the location of the cursor when the button is pressed. The lower
X  right hand corner is specified by the cursor when the button is released.
X
X
X  Use of the keys _b_B_e_E_f_F_k_K_j_J_m_n_r_R_s_S_w_W_x_X_q_Q indicates:
X
X          (<) Halve dwell value.
X          (>) Double dwell value.
X          ([) Halve settle value.
X          (]) Double settle value.
X          (B or b) Toggle button display on/off
X          (E or e) Recalculate the indices into the color wheel using a dif-
X  ferent method
X          (F or f) Save current screen to ouput file (not yet implemented)
X          (H or h or ?) Display brief help message
X          (i) Decrement the interval between stripes for the striped color
X  map.
X          (I) Increment the interval between stripes for the striped color
X  map.
X          (K) Decrease value exponents are compared against by 0.05.
X          (J) Increase value exponents are compared against by 0.05.
X          (M) Decrease value exponents are compared against by 0.005.
X          (N) Increase value exponents are compared against by 0.005.
X          (m) Increment the map index, changing the map to be iterated.
X          (P or p) Toggle positive/negative exponent display.
X          (r) Redraw the window using previously calculated exponents.
X          (R) Redraw the window using the newly set dwell and/or settle
X  values.
X          (S) Spin the color wheel
X          (s) Halve the length of the spin and spin the color wheel
X          (u) Go up to the window just prior to the most recent zoom.
X          (U) Go all the way up to the original window.
X          (V or v) Display values of various parameters currently in use
X          (W or w) Use next color map.
X          (X or x) Clear window
X          (Q or q) quit
X
X
X
AUTHOR
X          Ronald Joe Record
X       The Santa Cruz Operation
X            P.O. Box 1900
X         Santa Cruz, CA 95061
X              rr@sco.com
X
X
X
ACKNOWLEDGEMENTS
X
X  The algorithm was taken from the September 1991 Scientific American article
X  by A. K. Dewdney who gives credit to Mario Markus of the Max Planck Insti-
X  tute for its creation. Additional information and ideas were gleaned from
X  the discussion on alt.fractals involving Stephen Hall, Ed Kubaitis, Dave
X  Platt and Baback Moghaddam. Assistance with colormaps and spinning color
X  wheels and X was gleaned from Hiram Clawson. Rubber banding code was
X  adapted from an existing Mandelbrot program written by Stacey Campbell.
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
SHAR_EOF
chmod 0644 lyap.6X ||
echo 'restore of lyap.6X failed'
Wc_c="`wc -c < 'lyap.6X'`"
test 7181 -eq "$Wc_c" ||
	echo 'lyap.6X: original size 7181, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= lyap.c ==============
if test -f 'lyap.c' -a X"$1" != X"-c"; then
	echo 'x - skipping lyap.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting lyap.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'lyap.c' &&
/* Lyap - calculate and display Lyapunov exponents */
X
/* Written by Ron Record (rr@sco) 03 Sep 1991 */
X
/* The idea here is to calculate the Lyapunov exponent for a periodically
X * forced logistic map (later i added several other nonlinear maps of the unit
X * interval). In order to turn the 1-dimensional parameter space of the
X * logistic map into a 2-dimensional parameter space, select two parameter
X * values ('a' and 'b') then alternate the iterations of the logistic map using
X * first 'a' then 'b' as the parameter. This program accepts an argument to 
X * specify a forcing function, so instead of just alternating 'a' and 'b', you
X * can use 'a' as the parameter for say 6 iterations, then 'b' for 6 iterations
X * and so on. An interesting forcing function to look at is abbabaab (the
X * Morse-Thue sequence, an aperiodic self-similar, self-generating sequence).
X * Anyway, step through all the values of 'a' and 'b' in the ranges you want,
X * calculating the Lyapunov exponent for each pair of values. The exponent
X * is calculated by iterating out a ways (specified by the variable "settle")
X * then on subsequent iterations calculating an average of the logarithm of
X * the absolute value of the derivative at that point. Points in parameter
X * space with a negative Lyapunov exponent are colored one way (using the
X * value of the exponent to index into a color map) while points with a
X * non-negative exponent are colored differently. 
X * 
X * The algorithm was taken from the September 1991 Scientific American article
X * by A. K. Dewdney who gives credit to Mario Markus of the Max Planck Institute
X * for its creation. Additional information and ideas were gleaned from the
X * discussion on alt.fractals involving Stephen Hall, Ed Kubaitis, Dave Platt
X * and Baback Moghaddam. Assistance with colormaps and spinning color wheels
X * and X was gleaned from Hiram Clawson. Rubber banding code was adapted from
X * an existing Mandelbrot program written by Stacey Campbell.
X */
X
#include "lyap.h"
X
static char *version = LYAP_VERSION;
X
main(ac, av)
X	int ac;
X	char **av;
{
X	int i;
X	XSizeHints hint;
X	extern void init_canvas(), init_data(), init_color(), parseargs();
X	extern void Clear();
X
X	parseargs(ac, av);
X    	dpy = XOpenDisplay("");
X    	screen = DefaultScreen(dpy);
X	background = BlackPixel(dpy, screen);
X	setupmem();
X	init_data();
X	if (displayplanes > 1)
X		foreground = startcolor;
X	else
X		foreground = WhitePixel(dpy,XDefaultScreen(dpy));
X	hint.x = xposition;
X	hint.y = yposition;
X	hint.width = width;
X	hint.height = height;
X	hint.flags = PPosition | PSize;
X	/*
X 	* Create the window to display the Lyapunov exponents 
X 	*/
X	canvas = XCreateSimpleWindow(dpy, DefaultRootWindow(dpy),
X		hint.x, hint.y, hint.width, hint.height,
X		5, foreground, background);
X	XSetStandardProperties(dpy, canvas, "Lyap by Ron Record", 
X		"Lyap", None, av, ac, &hint);
X	init_canvas();
X	XSelectInput(dpy,canvas,KeyPressMask|ButtonPressMask|ButtonMotionMask|
X		ButtonReleaseMask|ExposureMask|StructureNotifyMask);
X	XMapRaised(dpy, canvas);
X	if (displayplanes > 1) {
X		init_color();
X		/* install new color map */
X		XSetWindowColormap(dpy, canvas, cmap);
X	}
X	else {
X		XQueryColors(dpy, DefaultColormap(dpy, DefaultScreen(dpy)), 
X				Colors, numcolors);
X	}
X	pixmap = XCreatePixmap(dpy, DefaultRootWindow(dpy), 
X			width, height, DefaultDepth(dpy, screen));
X	rubber_data.band_cursor=XCreateFontCursor(dpy, XC_hand2);
X	CreateXorGC();
X	Clear();
X	for(;;)
X	    main_event();
}
X
main_event()
{
X	int n;
X	XEvent event;
X
X	if (complyap() == TRUE)
X	    run=0;
X	n = XEventsQueued(dpy, QueuedAfterFlush);
X	while (n--) {
X    	    XNextEvent(dpy, &event);
X            switch(event.type) 
X            {
X            case KeyPress:
X		Getkey(&event);
X		break;
X            case Expose:
X		redisplay(canvas, &event);
X	        break;
X            case ConfigureNotify:
X		resize();
X	        break;
X            case ButtonPress:
X		StartRubberBand(canvas, &rubber_data, &event);
X	        break;
X            case MotionNotify:
X		TrackRubberBand(canvas, &rubber_data, &event);
X	        break;
X            case ButtonRelease:
X		EndRubberBand(canvas, &rubber_data, &event);
X	        break;
X            }
X        }
}
X
/* complyap() is the guts of the program. This is where the Lyapunov exponent
X * is calculated. For each iteration (past some large number of iterations)
X * calculate the logarithm of the absolute value of the derivative at that
X * point. Then average them over some large number of iterations. Some small
X * speed up is achieved by utilizing the fact that log(a*b) = log(a) + log(b).
X */
complyap()
{
X	register i, bindex, findex;
X	double total, prod, x, r;
X	extern void save_to_file();
X
X	if (!run)
X		return TRUE;
X	a += a_inc;
X	if (a >= max_a)
X		if (sendpoint(lyapunov) == TRUE)
X			return FALSE;
X		else {
X			FlushBuffer();
X			if (savefile)
X				save_to_file();
X			return TRUE;
X		}
X	if (b >= max_b) {
X		FlushBuffer();
X		if (savefile)
X			save_to_file();
X		return TRUE;
X	}
X	prod = 1.0;
X	total = 0.0;
X	bindex = 0;
X	x = start_x;
X	r = (forcing[bindex]) ? b : a;
#ifdef MAPS
X	findex = 0;
X	map = Maps[Forcing[findex]];
#endif
X	for (i=0;i<settle;i++) {	   /* Here's where we let the thing */
X		x = (*map)(x, r);	   /* "settle down". There is usually */
X		if (++bindex >= maxindex) { /* some initial "noise" in the */
X			bindex = 0;	   /* iterations. How can we optimize */
X			if (Rflag)	    /* the value of settle ??? */
X			    setforcing();
X		}
X		r = (forcing[bindex]) ? b : a;
#ifdef MAPS
X		if (++findex >= funcmaxindex)
X			findex = 0;
X		map = Maps[Forcing[findex]];
#endif
X	}
#ifdef MAPS
X	deriv = Derivs[Forcing[findex]];
#endif
X	if (useprod) {			/* using log(a*b) */
X		for (i=0;i<dwell;i++) {
X			x = (*map)(x, r);
X			prod *= ABS((*deriv)(x, r));
X			/* we need to prevent overflow and underflow */
X			if ((prod > 1.0e12) || (prod < 1.0e-12)) {
X				total += log(prod);
X				prod = 1.0;
X			}
X			if (++bindex >= maxindex) {
X				bindex = 0;
X				if (Rflag)
X					setforcing();
X			}
X			r = (forcing[bindex]) ? b : a;
#ifdef MAPS
X			if (++findex >= funcmaxindex)
X				findex = 0;
X			map = Maps[Forcing[findex]];
X			deriv = Derivs[Forcing[findex]];
#endif
X		}
X		total += log(prod);
X		lyapunov = (total * M_LOG2E) / (double)dwell;
X	}
X	else {				/* use log(a) + log(b) */
X		for (i=0;i<dwell;i++) {
X			x = (*map)(x, r);
X			total += log(ABS((*deriv)(x, r)));
X			if (++bindex >= maxindex) {
X				bindex = 0;
X				if (Rflag)
X					setforcing();
X			}
X			r = (forcing[bindex]) ? b : a;
#ifdef MAPS
X			if (++findex >= funcmaxindex)
X				findex = 0;
X			map = Maps[Forcing[findex]];
X			deriv = Derivs[Forcing[findex]];
#endif
X		}
X		lyapunov = (total * M_LOG2E) / (double)dwell;
X	}
X	if (sendpoint(lyapunov) == TRUE)
X		return FALSE;
X	else {
X		FlushBuffer();
X		if (savefile)
X			save_to_file();
X		return TRUE;
X	}
}
X
double
logistic(x, r)			/* the familiar logistic map */
double x, r;
{
X	return(r * x * (1.0 - x));
}
X
double
dlogistic(x, r)			/* the derivative of logistic map */
double x, r;
{
X	return(r - (2.0 * r * x));
}
X
double
circle(x, r)			/* sin() hump or sorta like the circle map */
double x, r;
{
X	extern double sin();
X
X	return(r * sin(M_PI * x));
}
X
double
dcircle(x, r)			/* derivative of the "sin() hump" */
double x, r;
{
X	extern double cos();
X
X	return(r * M_PI * cos(M_PI * x));
}
X
double
leftlog(x, r)			/* left skewed logistic */
double x, r;
{
X	double d;
X
X	d = 1.0 - x;
X	return(r * x * d * d);
}
X
double
dleftlog(x, r)			/* derivative of the left skewed logistic */
double x, r;
{
X	return(r * (1.0 - (4.0 * x) + (3.0 * x * x)));
}
X
double
rightlog(x, r)			/* right skewed logistic */
double x, r;
{
X	return(r * x * x * (1.0 - x));
}
X
double
drightlog(x, r)			/* derivative of the right skewed logistic */
double x, r;
{
X	return(r * ((2.0 * x) - (3.0 * x * x)));
}
X
double
doublelog(x, r)			/* double logistic */
double x, r;
{
X	double d;
X
X	d = 1.0 - x;
X	return(r * x * x * d * d);
}
X
double
ddoublelog(x, r)		/* derivative of the double logistic */
double x, r;
{
X	double d;
X
X	d = x * x;
X	return(r * ((2.0 * x) - (6.0 * d) + (4.0 * x * d)));
}
X
void
init_data()
{
X	static int i;
X
X	numcolors = XDisplayCells(dpy, XDefaultScreen(dpy));
X	displayplanes = DisplayPlanes(dpy, XDefaultScreen(dpy));
X	if (numcolors > maxcolor)
X		numcolors = maxcolor;
X	numfreecols = numcolors - mincolindex;
X	lowrange = mincolindex - startcolor;
X	a_inc = a_range / (double)width;
X	b_inc = b_range / (double)height;
X	point.x = -1;
X	point.y = 0;
X	a = rubber_data.p_min = min_a;
X	b = rubber_data.q_min = min_b;
X	rubber_data.p_max = max_a;
X	rubber_data.q_max = max_b;
X	if (show)
X		show_defaults();
X	InitBuffer();
X	srand48(time(0));
}
X
void
init_canvas()
{
X	static int i;
X
X	/*
X 	* create default, writable, graphics contexts for the canvas.
X 	*/
X        for (i=0; i<maxcolor; i++) {
X            Data_GC[i] = XCreateGC(dpy, DefaultRootWindow(dpy),
X                (unsigned long) NULL, (XGCValues *) NULL);
X            /* set the background to black */
X            XSetBackground(dpy,Data_GC[i],BlackPixel(dpy,XDefaultScreen(dpy)));
X            /* set the foreground of the ith context to i */
X            XSetForeground(dpy, Data_GC[i], i);
X        }
X        if (displayplanes == 1) {
X            XSetForeground(dpy,Data_GC[0],BlackPixel(dpy,XDefaultScreen(dpy)));
X            XSetForeground(dpy,Data_GC[1],WhitePixel(dpy,XDefaultScreen(dpy)));
X        }
}
X
void
init_color()
{
X	static int i, j, colgap, leg, step;
X	static Visual *visual;
X	Colormap def_cmap;
X	int hls[3], rgb[3];
X	extern void hls2rgb( int[3], int[3]);
X
X	def_cmap = DefaultColormap(dpy, DefaultScreen(dpy));
X	for (i=0; i<numcolors; i++) {
X		Colors[i].pixel = i;
X		Colors[i].flags = DoRed|DoGreen|DoBlue;
X	}
X
X	/* Try to write into a new color map */
X	visual = DefaultVisual(dpy, DefaultScreen(dpy));
X	cmap = XCreateColormap(dpy, canvas, visual, AllocAll);
X	XQueryColors(dpy, def_cmap, Colors, numcolors);
X	if (mincolindex)
X		colgap = rgb_max / mincolindex;
X	else
X		colgap = rgb_max;
X	hls[0] = 50;	/* Hue in low range */
X	hls[2] = 1000;	/* Fully saturated */
X	for (i=startcolor; i<lowrange + startcolor; i++) {
X		hls[1] = 1000L * (i-startcolor) / lowrange;
X		hls2rgb(hls, rgb);
X		Colors[i].red = rgb[0];
X		Colors[i].green = rgb[1];
X		Colors[i].blue = rgb[2];
X	}
X	colgap = rgb_max / numcolors;
X	if (numwheels == 0)
X		XQueryColors(dpy, def_cmap, Colors, numcolors);
X	else if (numwheels == 1) {
X		colgap = 2*rgb_max/(numcolors - color_offset);
X		for (i=mincolindex; i<(numcolors/2); i++) {
X			Colors[i].blue = 0;
X			Colors[i].green=((i+color_offset)*colgap);
X			Colors[i].red=((i+color_offset)*colgap);
X		}
X		for (i=(numcolors/2); i<(numcolors); i++) {
X			Colors[i].blue = 0;
X			Colors[i].green=(((numcolors-i)+color_offset)*colgap);
X			Colors[i].red=(((numcolors-i)+color_offset)*colgap);
X		}
X	}
X	else if (numwheels == 2) {
X	        hls[0] = 800;	/* Hue in mid range */
X	        hls[2] = 1000;	/* Fully saturated */
X	        for (i=startcolor; i<lowrange + startcolor; i++) {
X			hls[1] = 1000L * (i-startcolor) / lowrange;
X			hls2rgb(hls, rgb);
X			Colors[i].red = rgb[0];
X			Colors[i].green = rgb[1];
X			Colors[i].blue = rgb[2];
X	        }
X		for (i=mincolindex; i<(numcolors/2); i++) {
X			Colors[i].blue = rgb_max;
X			Colors[i].green = 0;
X			Colors[i].red=(i*2*rgb_max/numcolors);
X		}
X		for (i=(numcolors/2); i<numcolors; i++) {
X			Colors[i].blue = rgb_max;
X			Colors[i].green = 0;
X			Colors[i].red=((numcolors - i)*2*rgb_max/numcolors);
X		}
X	}
X	else if (numwheels == 3) {
X	        hls[0] = 800;	/* Hue in mid range */
X	        hls[2] = 1000;	/* Fully saturated */
X	        for (i=startcolor; i<lowrange + startcolor; i++) {
X			hls[1] = 1000L * (i-startcolor) / lowrange;
X			hls2rgb(hls, rgb);
X			Colors[i].red = rgb[0];
X			Colors[i].green = rgb[1];
X			Colors[i].blue = rgb[2];
X	        }
X		colgap = 4*rgb_max/numcolors;
X		for (i=mincolindex; i<(numcolors/4); i++) {
X			Colors[i].blue = rgb_max;
X			Colors[i].green = 0;
X			Colors[i].red=(i*colgap);
X		}
X		for (i=(numcolors/4); i<(numcolors/2); i++) {
X			Colors[i].red = rgb_max;
X			Colors[i].green = 0;
X			Colors[i].blue=((numcolors/2) - i) * colgap;
X		}
X		for (i=(numcolors/2); i<(0.75*numcolors); i++) {
X			Colors[i].red = rgb_max;
X			Colors[i].blue=(i * colgap);
X			Colors[i].green = 0;
X		}
X		for (i=(0.75*numcolors); i<numcolors; i++) {
X			Colors[i].blue = rgb_max;
X			Colors[i].green = 0;
X			Colors[i].red=(numcolors-i)*colgap;
X		}
X	}
X	else if (numwheels == 4) {
X	        hls[0] = 800;	/* Hue in mid range */
X	        hls[2] = 1000;	/* Fully saturated */
X	        for (i=startcolor; i<lowrange + startcolor; i++) {
X			hls[1] = 1000L * (i-startcolor) / lowrange;
X			hls2rgb(hls, rgb);
X			Colors[i].red = rgb[0];
X			Colors[i].green = rgb[1];
X			Colors[i].blue = rgb[2];
X	        }
X		colgap = numwheels * rgb_max / numcolors;
X		for (i=mincolindex; i<(numcolors/numwheels); i++) {
X			Colors[i].blue = rgb_max;
X			Colors[i].green = 0;
X			Colors[i].red=(i*colgap);
X		}
X		for (i=(numcolors/numwheels); i<(2*numcolors/numwheels); i++) {
X			Colors[i].red = rgb_max;
X			Colors[i].green = 0;
X			Colors[i].blue=((2*numcolors/numwheels) - i) * colgap;
X		}
X		for (i=(2*numcolors/numwheels); i<numcolors; i++) {
X			Colors[i].red = rgb_max;
X			Colors[i].green=(i - (2*numcolors/numwheels)) * colgap;
X			Colors[i].blue = 0;
X		}
X	}
X	else if (numwheels == 5) {
X		hls[1] = 700;	/* Lightness in midrange */
X		hls[2] = 1000;	/* Fully saturated */
X		for (i=mincolindex; i<numcolors; i++) {
X			hls[0] = 3600L * i / numcolors;
X			hls2rgb(hls, rgb);
X			Colors[i].red = rgb[0];
X			Colors[i].green = rgb[1];
X			Colors[i].blue = rgb[2];
X		}
X		for (i=mincolindex; i<numcolors; i+=stripe_interval) {
X			hls[0] = 3600L * i / numcolors;
X			hls2rgb(hls, rgb);
X			Colors[i].red = rgb[0] / 2;
X			Colors[i].green = rgb[1] / 2;
X			Colors[i].blue = rgb[2] / 2;
X		}
X	}
X	else if (numwheels == 6) {
X	    hls[0] = 800;	/* Hue in mid range */
X	    hls[2] = 1000;	/* Fully saturated */
X	    for (i=startcolor; i<lowrange + startcolor; i++) {
X		hls[1] = 1000L * (i-startcolor) / lowrange;
X		hls2rgb(hls, rgb);
X		Colors[i].red = rgb[0];
X		Colors[i].green = rgb[1];
X		Colors[i].blue = rgb[2];
X	    }
X	    step = numfreecols / 3;
X	    leg = step+mincolindex;
X	    for (i = mincolindex; i < leg; ++i)
X	    {
X		Colors[i].pixel = i;
X		Colors[i].red = fabs(65535 - (double)i / step * 65535.0);
X		Colors[i].blue = (double)i / step * 65535.0;
X		Colors[i].green = 0;
X		Colors[i].flags = DoRed | DoGreen | DoBlue;
X	    }
X	    for (j = 0, i = leg, leg += step; i < leg; ++i, ++j)
X	    {
X		Colors[i].pixel = i;
X		Colors[i].red = (double)j / step * 65535.0;
X		Colors[i].blue = 65535;
X		Colors[i].green = Colors[i].red;
X		Colors[i].flags = DoRed | DoGreen | DoBlue;
X	    }
X	    for (j = 0, i = leg, leg += step; i < leg; ++i, ++j)
X	    {
X		Colors[i].pixel = i;
X		Colors[i].red = 65535;
X		Colors[i].blue = fabs(65535 - (double)j / step * 65535.0);
X		Colors[i].green = Colors[i].blue;
X		Colors[i].flags = DoRed | DoGreen | DoBlue;
X	    }
X	}
X	else if (numwheels == MAXWHEELS) {	/* rainbow palette */
X		hls[1] = 500;	/* Lightness in midrange */
X		hls[2] = 1000;	/* Fully saturated */
X		for (i=mincolindex; i<numcolors; i++) {
X			hls[0] = 3600L * i / numcolors;
X			hls2rgb(hls, rgb);
X			Colors[i].red = rgb[0];
X			Colors[i].green = rgb[1];
X			Colors[i].blue = rgb[2];
X		}
X	}
X	XStoreColors(dpy, cmap, Colors, numcolors);
}
X
void
parseargs(ac, av)
int ac;
char **av;
{
X	static int c;
X	static int i;
X	int bindex=0, findex;
X	char *ch;
X	extern int optind;
X	extern char *optarg;
X	extern double atof();
X	extern void check_params(), usage();
X
X	map = Maps[0];
X	deriv = Derivs[0];
X	maxexp=minlyap; minexp= -1.0 * minlyap;
X
X	while ((c=getopt(ac,av,
X		"Lpuvc:i:m:C:W:H:M:N:O:R:S:a:b:D:F:f:o:w:h:r:s:x:y:"))!=EOF){
X		switch (c) {
X		case 'C':	mincolindex=atoi(optarg); break;
X		case 'D':	dwell=atoi(optarg); break;
#ifdef MAPS
X		case 'F':	funcmaxindex = strlen(optarg);
X				if (funcmaxindex > FUNCMAXINDEX)
X					usage();
X				ch = optarg;
X				Force++;
X				for (findex=0;findex<funcmaxindex;findex++) {
X					Forcing[findex] = (int)(*ch++ - '0');;
X					if (Forcing[findex] >= NUMMAPS)
X						usage();
X				}
X				break;
#endif
X		case 'H':	height=atoi(optarg); break;
X		case 'L':	useprod=0; break;
X		case 'M':	minlyap=ABS(atof(optarg)); 
X				maxexp=minlyap; minexp= -1.0 * minlyap; break;
X		case 'N':	maxcolor=ABS(atoi(optarg)); 
X				if ((maxcolor - startcolor) <= 0)
X					startcolor = 0;
X				if ((maxcolor - mincolindex) <= 0) {
X					mincolindex = 1;
X					color_offset = 0;
X				}
X				break;
X		case 'O':	color_offset=atoi(optarg); break;
X		case 'R':	prob=atof(optarg); Rflag++; setforcing(); break;
X		case 'S':	settle=atoi(optarg); break;
X		case 'W':	width=atoi(optarg); break;
X		case 'a':	min_a=atof(optarg); aflag++; break;
X		case 'b':	min_b=atof(optarg); bflag++; break;
X		case 'c':	numwheels=atoi(optarg); break;
X		case 'f':	maxindex = strlen(optarg);
X				if (maxindex > MAXINDEX)
X					usage();
X				ch = optarg;
X				force++;
X				while (bindex < maxindex) {
X					if (*ch == 'a')
X						forcing[bindex++] = 0;
X					else if (*ch == 'b')
X						forcing[bindex++] = 1;
X					else
X						usage();
X					ch++;
X				}
X				break;
X		case 'h':	b_range=atof(optarg); hflag++; break;
X		case 'i':	start_x=atof(optarg); break;
X		case 'm':	mapindex=atoi(optarg); 
X				if ((mapindex >= NUMMAPS) || (mapindex < 0))
X					usage();
X				map = Maps[mapindex];
X				deriv = Derivs[mapindex];
X				if (!aflag)
X					min_a = amins[mapindex];
X				if (!wflag)
X					a_range = aranges[mapindex];
X				if (!bflag)
X					min_b = bmins[mapindex];
X				if (!hflag)
X					b_range = branges[mapindex];
X				if (!Force)
X					for (i=0;i<FUNCMAXINDEX;i++)
X					    Forcing[i] = mapindex;
X				break;
X		case 'o':	savefile++; outname=optarg; break;
X		case 'p':	negative--; break;
X		case 'r':	rgb_max=atoi(optarg); break;
X		case 's':	spinlength=atoi(optarg); break;
X		case 'u':	usage(); break;
X		case 'v':	show=1; break;
X		case 'w':	a_range=atof(optarg); wflag++; break;
X		case 'x':	xposition=atoi(optarg); break;
X		case 'y':	yposition=atoi(optarg); break;
X		case '?':	usage(); break;
X		}
X	}
X	max_a = min_a + a_range;
X	max_b = min_b + b_range;
X        a_minimums[0] = min_a; b_minimums[0] = min_b;
X        a_maximums[0] = max_a; b_maximums[0] = max_b;
X	if (Force)
X		if (maxindex == funcmaxindex)
X		    for (findex=0;findex<funcmaxindex;findex++)
X			check_params(Forcing[findex],forcing[findex]);
X		else
X		    fprintf(stderr, "Warning! Unable to check parameters\n");
X	else
X		check_params(mapindex,2);
}
X
void
check_params(mapnum, parnum)
int mapnum;
int parnum;
{
X
X	if (parnum != 1) {
X	    if ((max_a > pmaxs[mapnum]) || (min_a < pmins[mapnum])) {
X		fprintf(stderr, "Warning! Parameter 'a' out of range.\n");
X		fprintf(stderr, "You have requested a range of (%f,%f).\n",
X			min_a,max_a);
X		fprintf(stderr, "Valid range is (%f,%f).\n",
X			pmins[mapnum],pmaxs[mapnum]);
X	    }
X	}
X	if (parnum != 0) {
X	    if ((max_b > pmaxs[mapnum]) || (min_b < pmins[mapnum])) {
X		fprintf(stderr, "Warning! Parameter 'b' out of range.\n");
X		fprintf(stderr, "You have requested a range of (%f,%f).\n",
X			min_b,max_b);
X		fprintf(stderr, "Valid range is (%f,%f).\n",
X			pmins[mapnum],pmaxs[mapnum]);
X	    }
X	}
}
X
void
usage()
{
X    fprintf(stderr,"lyap [-BLs][-W#][-H#][-a#][-b#][-w#][-h#][-x xstart]\n");
X    fprintf(stderr,"\t[-M#][-S#][-D#][-f string][-r#][-O#][-C#][-c#][-m#]\n");
#ifdef MAPS
X    fprintf(stderr,"\t[-F string]\n");
#endif
X    fprintf(stderr,"\tWhere: -C# specifies the minimum color index\n");
X    fprintf(stderr,"\t       -r# specifies the maxzimum rgb value\n");
X    fprintf(stderr,"\t       -u displays this message\n");
X    fprintf(stderr,"\t       -a# specifies the minimum horizontal parameter\n");
X    fprintf(stderr,"\t       -b# specifies the minimum vertical parameter\n");
X    fprintf(stderr,"\t       -w# specifies the horizontal parameter range\n");
X    fprintf(stderr,"\t       -h# specifies the vertical parameter range\n");
X    fprintf(stderr,"\t       -D# specifies the dwell\n");
X    fprintf(stderr,"\t       -S# specifies the settle\n");
X    fprintf(stderr,"\t       -H# specifies the initial window height\n");
X    fprintf(stderr,"\t       -W# specifies the initial window width\n");
X    fprintf(stderr,"\t       -O# specifies the color offset\n");
X    fprintf(stderr,"\t       -c# specifies the desired color wheel\n");
X    fprintf(stderr,"\t       -m# specifies the desired map (0-4)\n");
X    fprintf(stderr,"\t       -f aabbb specifies a forcing function of 00111\n");
#ifdef MAPS
X    fprintf(stderr,"\t       -F 00111 specifies the function forcing function\n");
#endif
X    fprintf(stderr,"\t       -L indicates use log(x)+log(y) rather than log(xy)\n");
X    fprintf(stderr,"\tDuring display :\n");
X    fprintf(stderr,"\t     Use the mouse to zoom in on an area\n");
X    fprintf(stderr,"\t     e or E recalculates color indices\n");
X    fprintf(stderr,"\t     f or F saves exponents to a file\n");
X    fprintf(stderr,"\t     KJmn increase/decrease minimum negative exponent\n");
X    fprintf(stderr,"\t     r or R redraws\n");
X    fprintf(stderr,"\t     s or S spins the colorwheel\n");
X    fprintf(stderr,"\t     w or W changes the color wheel\n");
X    fprintf(stderr,"\t     x or X clears the window\n");
X    fprintf(stderr,"\t     q or Q exits\n");
X    exit(1);
}
X
Cycle_frames()
{
X	static int i;
X	extern void redraw();
X
X	for (i=0;i<=maxframe;i++)
X		redraw(exponents[i], expind[i], 1); 
}
X		
void
Spin(w)
Window w;
{
X	static int i, j;
X	long tmpxcolor;
X
X	if (displayplanes > 1) {
X		for (j=0;j<spinlength;j++) {
X			tmpxcolor = Colors[mincolindex].pixel;
X			for (i=mincolindex;i<numcolors-1;i++)
X				Colors[i].pixel = Colors[i+1].pixel;
X			Colors[numcolors-1].pixel = tmpxcolor;
X			XStoreColors(dpy, cmap, Colors, numcolors);
X		}
X		for (j=0;j<spinlength;j++) {
X			tmpxcolor = Colors[numcolors-1].pixel;
X			for (i=numcolors-1;i>mincolindex;i--)
X				Colors[i].pixel = Colors[i-1].pixel;
X			Colors[mincolindex].pixel = tmpxcolor;
X			XStoreColors(dpy, cmap, Colors, numcolors);
X		}
X	}
}
X
Getkey(event)
XXKeyEvent *event;
{
X	unsigned char key;
X	static int i;
X	extern void init_color(), recalc(), print_values(), print_help();
X	extern void go_init(), go_back(), go_down(), Clear();
X	extern void save_to_file(), Redraw(), redraw();
X
X        if (XLookupString(event, (char *)&key, sizeof(key), (KeySym *)0,
X            (XComposeStatus *) 0) > 0)
X                switch (key) {
X	case '<': dwell /= 2; if (dwell < 1) dwell = 1; break;
X	case '>': dwell *= 2; break;
X	case '[': settle /= 2; if (settle < 1) settle = 1; break;
X	case ']': settle *= 2; break;
X	case 'd': go_down(); break;
X	case 'D': FlushBuffer(); break;
X	case 'e':
X	case 'E': FlushBuffer();
X		  dorecalc = (!dorecalc);
X		  if (dorecalc)
X			recalc(); 
X		  else {
X			maxexp = minlyap; minexp = -1.0 * minlyap;
X		  }
X		  redraw(exponents[frame], expind[frame], 1);
X		  break;
X	case 'f':
X	case 'F': save_to_file(); break;
X	case 'i': if (stripe_interval > 0) {
X			stripe_interval--;
X		  	if (displayplanes > 1) {
X		  	    init_color(); 
X		  	    XSetWindowColormap(dpy, canvas, cmap);
X		  	}
X		  }
X		  break;
X	case 'I': stripe_interval++;
X		  if (displayplanes > 1) {
X		  	init_color(); 
X		  	XSetWindowColormap(dpy, canvas, cmap);
X		  }
X		  break;
X	case 'K': if (minlyap > 0.05)
X			minlyap -= 0.05;
X		   break;
X	case 'J': minlyap += 0.05; 
X		   break;
X	case 'm': mapindex++;
X                  if (mapindex >= NUMMAPS)
X                        mapindex=0;
X                  map = Maps[mapindex];
X                  deriv = Derivs[mapindex];
X		  if (!aflag)
X                        min_a = amins[mapindex];
X                  if (!wflag)
X                        a_range = aranges[mapindex];
X                  if (!bflag)
X                        min_b = bmins[mapindex];
X                  if (!hflag)
X                        b_range = branges[mapindex];
X                  if (!Force)
X                        for (i=0;i<FUNCMAXINDEX;i++)
X                             Forcing[i] = mapindex;
X        	  max_a = min_a + a_range;
X        	  max_b = min_b + b_range;
X        	  a_minimums[0] = min_a; b_minimums[0] = min_b;
X        	  a_maximums[0] = max_a; b_maximums[0] = max_b;
X        	  a_inc = a_range / (double)width;
X        	  b_inc = b_range / (double)height;
X        	  point.x = -1;
X        	  point.y = 0;
X        	  a = rubber_data.p_min = min_a;
X        	  b = rubber_data.q_min = min_b;
X        	  rubber_data.p_max = max_a;
X        	  rubber_data.q_max = max_b;
X                  Clear();
X                  break;
X	case 'M': if (minlyap > 0.005)
X			minlyap -= 0.005;
X		   break;
X	case 'N': minlyap += 0.005;
X		   break;
X	case 'p':
X	case 'P': negative = (!negative); 
X		  FlushBuffer(); redraw(exponents[frame], expind[frame], 1); 
X		  break;
X	case 'r': FlushBuffer(); redraw(exponents[frame], expind[frame], 1); 
X		  break;
X	case 'R': FlushBuffer(); Redraw(); break;
X	case 's':
X		   spinlength=spinlength/2;
X	case 'S': if (displayplanes > 1) 
X			Spin(canvas); 
X		   spinlength=spinlength*2; break;
X	case 'u': go_back(); break;
X	case 'U': go_init(); break;
X	case 'v':
X	case 'V': print_values(); break;
X	case 'W': if (numwheels < MAXWHEELS)
X			numwheels++;
X		   else
X			numwheels = 0;
X		   if (displayplanes > 1) {
SHAR_EOF
true || echo 'restore of lyap.c failed'
fi
echo 'End of  part 1'
echo 'File lyap.c is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
