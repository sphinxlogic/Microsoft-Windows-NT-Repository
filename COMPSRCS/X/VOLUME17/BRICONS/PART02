Newsgroups: comp.sources.x
Path: uunet!cis.ohio-state.edu!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: bri@ukc.ac.uk
Subject: v17i062: bricons - command panel, Part02/02
Message-ID: <1992Apr14.144611.9250@msi.com>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Nntp-Posting-Host: fascet
Organization: Molecular Simulations, Inc.
References: <csx-17i061-bricons@uunet.UU.NET>
Date: Tue, 14 Apr 1992 14:46:11 GMT
Approved: dcmartin@msi.com
Lines: 1688

Submitted-by: bri@ukc.ac.uk
Posting-number: Volume 17, Issue 62
Archive-name: bricons/part02

# this is part.02 (part 2 of a multipart archive)
# do not concatenate these parts, unpack them in order with /bin/sh
# file bricons.l continued
#
if test ! -r _shar_seq_.tmp; then
	echo 'Please unpack part 1 first!'
	exit 1
fi
(read Scheck
 if test "$Scheck" != 2; then
	echo Please unpack part "$Scheck" next!
	exit 1
 else
	exit 0
 fi
) < _shar_seq_.tmp || exit 1
if test ! -f _shar_wnt_.tmp; then
	echo 'x - still skipping bricons.l'
else
echo 'x - continuing file bricons.l'
sed 's/^X//' << 'SHAR_EOF' >> 'bricons.l' &&
.LP
Please do not specify the BitmapFilePath in the Xbricons resource file as
it will be ignored by the program.
.LP
This program will read a .briconsrc file from the current directory.  If the
file to be read is in another directory then place the following line in the 
&\.X11defaults or Xbricons resource file:
.sp
.ce
*icon_file:     /usr/mydir/.briconsrc
.SH FILES
.LP
The Xbricons file specifies the required resources.  To make sure the program
uses the resources file set the following line in your .login:
.ce
setenv  XUSERFILESEARCHPATH ~/app_defaults/%N
.LP
and place all all resources in the app_defaults directory.
.SH WIDGETS
.LP
The bricons program is a toolkit-based application which consists of a 
combination of widgets.  In order to specify resources, it is useful to know
the hierarchy of the widgets which compose bricons.  In the list below, 
indentation indicates hierarchical structure.  The widget class name is given 
first, followed by the widget instance name.
.sp
.nf
X	Xbricons	toplevel	
X		Form	box
X			Command	action[18]
X			OverrideShell	popup_shell
X				Form	popup_layout
X				Command	sub_action[10]
.fi
.SH EXAMPLE
.LP
Below is an example of a simple \&.briconsrc file:
.sp
.nf
# <-- a line starting with a '#' is a comment line
#
#       Bri's icon file
#
X
# first line must have keyword %icon or %text
# to indicate if button is an icon
X
%icon calculator
xcalc
%text Games\\n sub\\n menu
%sub_menu
X	%text xeyes
X	xeyes
X	%text othello
X	othello 
%end_sub_menu
.if
.sp
.SH BUGS
After selecting the source button the buttons may not be re-displayed 
correctly.  Selecting the source button a second time may help.
.SH AUTHOR
Bruce R Ingram, University of Kent at Canterbury.
SHAR_EOF
echo 'File bricons.l is complete' &&
chmod 0644 bricons.l ||
echo 'restore of bricons.l failed'
Wc_c="`wc -c < 'bricons.l'`"
test 6362 -eq "$Wc_c" ||
	echo 'bricons.l: original size 6362, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bricons.txt ==============
if test -f 'bricons.txt' -a X"$1" != X"-c"; then
	echo 'x - skipping bricons.txt (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bricons.txt (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bricons.txt' &&
X
X
X
BRICONS(l)        MISC. REFERENCE MANUAL PAGES         BRICONS(l)
X
X
X
NAME
X     bricons - quick start  up  utility  for  applications  using
X     text, icons and pop-up menus an X display
X
SYNOPSIS
X     bricons  [options]
X     [-file] [-col] [-help] [-sensitive]
X
DESCRIPTION
X     Bricons program allows the user to quickly start up applica-
X     tions  by  selecting the appropriate button from the display
X     and pressing the left mouse button.  A maximum of up to six-
X     teen main menu buttons can be displayed. Each main menu but-
X     ton can launch an application or pop-up a sub menu  contain-
X     ing more buttons. The buttons can be represented as a bitmap
X     or as text.
X
X     Information on how the program is  to  present  each  button
X     (either  as a bitmap or text) and the application that is to
X     be executed if that  button  is  selected  is  contained  in
X     script  file  called .briconsrc.  This file should be stored
X     in the user's home directory.
X
X     The .briconsrc file contains a number of key words which are
X     used  to indicate if the button label is some text or a bit-
X     map and if the button is to pop-up a sub menu  or  launch  a
X     program.  These key words are explained below:
X
X     The .briconsrc file should start with the keyword  %icon  or
X     %text  The key word %icon indicates that the button label is
X     a bitmap.  This should be followed by the file name contain-
X     ing the bitmap.  For example:
X
X                           %icon clock.icon
X
X     The key word %text indicates that the button label  is  some
X     text.   The  text can be split over three lines by using the
X     new line character \n.  For example:
X
X                      %text Line1\nLine2\nLine3
X
X     would be presented as:
X                                Line1
X                                Line2
X                                Line3
X
X     Once a  button  has  been  selected  it  is  prevented  from
X     accidentally  being  re-selected by "graying out" the button
X     (default action).  Sometimes however it maybe  desirable  to
X     allow the button to be selected more than once.  This can be
X     done be using the keyword %icon+ or %text+
X
X
X
X
Sun Release 4.1   Last change: 28th March 1992                  1
X
X
X
X
X
X
BRICONS(l)        MISC. REFERENCE MANUAL PAGES         BRICONS(l)
X
X
X
X     The next line in the .briconsrc file should  either  contain
X     the key word %sub_menu or the application to be started.  If
X     the name of an application  is given then a check is made to
X     see if such an program can be executed.  If the program does
X     not exist or is not in the users path then an error  message
X     is printed and the button associated with the application is
X     ignored.
X
X     If the key word %sub_menu is used then a pop-up sub menu  is
X     created.   Any further buttons defined in the briconsrc file
X     will appear in the sub menu for that button  until  the  key
X     word  %end_sub_menu  is found.  A maximum of ten buttons are
X     allowed in a single pop-up sub menu.
X
X     Any line in the .briconsrc file starting with a #  character
X     is treated as a comment and will be ignored.
X
X     This program has four default buttons labelled source, edit,
X     help  and  quit.   The  edit  button allows the user to edit
X     there icon file (default being an empty source button causes
X     the  program  to  distory  all  the  current  buttons  being
X     displayed and re-read the icon file and display the new but-
X     tons.
X
OPTIONS
X     bricons accepts all of  the  standard  X   Toolkit   command
X     line options along with the additional options listed below:
X
X     -file
X          Tells the program to read  this  file  instead  of  the
X          default file.
X
X     -col Indicates the number of  buttons  in  a  column  before
X          starting  a  new row.  The default number of columns is
X          15.
X
X     -help
X          Tells the program the path for the help file.
X
X     -sensitive
X          Toggle used for default "graying out" of selected  but-
X          tons.   If  set  to  TRUE  then buttons will "gray out"
X          unless specifically requested not to.
X
XX DEFAULTS
X     The bricons program reads the .Xdefaults file  and  Xbricons
X     resource  file  during  startup  and  uses  the  appropriate
X     resource  specification  to  customise  the  appearance   or
X     characteristics  of  its  display.  This program understands
X     all of the core resource names and classes as well as:
X
X     no_of_cols
X
X
X
Sun Release 4.1   Last change: 28th March 1992                  2
X
X
X
X
X
X
BRICONS(l)        MISC. REFERENCE MANUAL PAGES         BRICONS(l)
X
X
X
X          Specifies the number of buttons in a column.
X
X     icon_file
X          Specifies path name for icon file to be read.
X
X     help_file
X          Specifies path name for help file.
X
SETTING BITMAP DIRECTORIES
X     This program will search the default  bitmap  directory  for
X     any bitmaps that are to be used to represent buttons. If the
X     user wishes the program to search other directories for bit-
X     map  files  then  this  should  be  specified  in  the users
X     .X11defaults file.  *BitmapFilePath: should  be  added  fol-
X     lowed  by  colon separated path names where the bitmap files
X     can be found.  For example:
X
X     *BitmapFilePath:    /usr/local/include/X11/bitmaps:/usr/mydir/bitmaps
X
X     Please do not specify the  BitmapFilePath  in  the  Xbricons
X     resource file as it will be ignored by the program.
X
X     This program will read a .briconsrc file  from  the  current
X     directory.   If  the file to be read is in another directory
X     then place the following line in the &.X11defaults or  Xbri-
X     cons resource file:
X
X                *icon_file:     /usr/mydir/.briconsrc
X
FILES
X     The Xbricons file specifies the required resources.  To make
X     sure  the  program uses the resources file set the following
X     line in your .login:
X            setenv  XUSERFILESEARCHPATH ~/app_defaults/%N
X
X     and place all all resources in the app_defaults directory.
X
WIDGETS
X     The bricons program is  a  toolkit-based  application  which
X     consists  of  a combination of widgets.  In order to specify
X     resources, it is useful to know the hierarchy of the widgets
X     which compose bricons.  In the list below, indentation indi-
X     cates hierarchical structure.   The  widget  class  name  is
X     given first, followed by the widget instance name.
X
X          Xbricons  toplevel
X               Form box
X                    Command   action[18]
X                    OverrideShell  popup_shell
X                         Form popup_layout
X                         Command   sub_action[10]
X
X
X
X
Sun Release 4.1   Last change: 28th March 1992                  3
X
X
X
X
X
X
BRICONS(l)        MISC. REFERENCE MANUAL PAGES         BRICONS(l)
X
X
X
EXAMPLE
X     Below is an example of a simple .briconsrc file:
X
X     # <-- a line starting with a '#' is a comment line
X     #
X     #       Bri's icon file
X     #
X
X     # first line must have keyword %icon or %text
X     # to indicate if button is an icon
X
X     %icon calculator
X     xcalc
X     %text Games\n sub\n menu
X     %sub_menu
X          %text xeyes
X          xeyes
X          %text othello
X          othello
X     %end_sub_menu
X
X
X
BUGS
X     After selecting the source button the  buttons  may  not  be
X     re-displayed  correctly.   Selecting  the  source  button  a
X     second time may help.
X
AUTHOR
X     Bruce R Ingram, University of Kent at Canterbury.
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
X
Sun Release 4.1   Last change: 28th March 1992                  4
X
X
X
SHAR_EOF
chmod 0644 bricons.txt ||
echo 'restore of bricons.txt failed'
Wc_c="`wc -c < 'bricons.txt'`"
test 7617 -eq "$Wc_c" ||
	echo 'bricons.txt: original size 7617, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= buttons.c ==============
if test -f 'buttons.c' -a X"$1" != X"-c"; then
	echo 'x - skipping buttons.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting buttons.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'buttons.c' &&
static char* sccs_buttons_c = "%W%%G%";
X
/* 
X * Copyright 1992 Bruce. R. Ingram.
X * University of Kent at Canterbury, UK
X *
X * Permission  to   use, copy, modify  and  distribute  this  software  and its
X * documentation   for any purpose is hereby granted without fee, provided that
X * the   above  copyright  notice  appear  in  all  copies  and  that both that
X * copyright  notice   and  this   permission   notice  appear  in   supporting
X * documentation,  and  that  the name  of the author and The University  of
X * Kent  at  Canterbury  not be  used in advertising or publicity pertaining to
X * distribution  of  the  software  without specific, written prior permission.
X * The   author  and   The   University   of   Kent at   Canterbury   make  no
X * representations  about  the  suitability  of this  software for any purpose.
X * It is provided "as is" without express or implied warranty.
X *
X * THE   AUTHOR  AND  THE  UNIVERSITY  OF KENT  AT   CANTERBURY  DISCLAIMS ALL
X * WARRANTIES  WITH  REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED  WARRANTIES
X * OF   MERCHANTABILITY  AND  FITNESS,  IN NO  EVENT  SHALL THE AUTHOR  OR THE
X * UNIVERSITY  OF KENT  AT  CANTERBURY  BE LIABLE FOR ANY SPECIAL, INDIRECT  OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS  OF USE,
X * DATA  OR  PROFITS,  WHETHER  IN  AN ACTION OF CONTRACT, NEGLIGENCE  OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
X * OF THIS SOFTWARE.
X *
X * Author:
X *
X * Mr  B. R. Ingram email bri@ukc.ac.uk
*/
X
#include "gen.h"
#include "widgets.h"
X
X
extern  int     GetCommand PROTO((char *, char *));
extern  int     GetKeyword PROTO((FILE *));
static  void    CreateSubMenu PROTO((FILE *,int,char *,char *,Info *));
extern  void    Quit PROTO((Widget,XtPointer,XtPointer)),
X		SingleAction PROTO((Widget,XtPointer,XtPointer)),
X		MultiAction PROTO((Widget,XtPointer,XtPointer)),
X                ReadALine PROTO((FILE*,char **)),
X                Source PROTO((Widget,XtPointer,XtPointer));
extern  void    set_popup PROTO((Widget,XEvent *,String *,Cardinal *));
extern  void    GetButtonTitle PROTO((FILE *,char *));
extern  void    CheckForComments PROTO((FILE *));
extern	void	delay PROTO((Widget,XEvent *,String *,Cardinal *));
X
static  void    SetButton PROTO((int,char *,int));
static  void    SetSubMenuButton PROTO((int,char *,int));
static	void	CreatePopupShell PROTO((int));
static	void	CreateSubMenuButton PROTO((int,char *,int));
static	void	DefaultButtons PROTO((Info *,int));
X
#include "trans.h"
X
X
/*
X	The function CreateButtons reads the contents of file data->icon_file
X	the file should contain a list consisting of a button title which
X	can be a string or a bitmap.  This is followed by a command that
X	is to be executed.  For each title and command read correctly from 
X	file a butoon is created. 
*/
extern int
CreateButtons(data)
Info	*data;
{
X	int 	i = 0;
X	int	is_icon;
X	char	ch, w_buffer[80];
X	char	icon[MAXLINE], path[MAXPATHLEN], ptrans[250];
X	char	*command;
X	FILE	*fp;
X
X	fp = fopen(data->icon_file,"r");
X	if(fp == NULL)
X	{
X		fp = fopen(data->icon_file,"w");
X		(void) fprintf(fp,"# Default .briconsrc file\n");
X		(void) fprintf(fp,"# A line starting with a '#' is a comment line\n");
X		(void) fprintf(fp,"# first line must have keyword %%icon or %%text\n");
X		(void) fprintf(fp,"# to indicate if button is an icon or text\n");
X		(void) fprintf(fp,"# for more information select the help button\n");
X		(void) fprintf(fp,"\n%%text test1\n");
X		(void) fprintf(fp,"xterm\n");
X		fclose(fp);
X		DefaultButtons(data,i);
X		return(i);
X	}
X	GetPath(path);
X	ch = getc(fp);
X	while((ch != EOF) && (i < MAXBUTTONS))
X	{
X		ungetc(ch,fp);
X		is_icon = GetKeyword(fp);
X		if(is_icon == EOF)
X			break;
X		/* get button title & check if it is an icon or text */
X		GetButtonTitle(fp,icon);
X		ReadALine(fp,&command);
X		if((strcmp(command,"%sub_menu\n")) == 0)
X		{
X			/* 
X				create translations for the button that 
X				pops up the sub menu
X			*/
X			(void) sprintf(ptrans,pb_Trans,i,popup_menu_name);
X
X			/* create main menu button that will popup sub menu */
X			(void) sprintf(w_buffer,"action%d",i);
X			action[i] = XtVaCreateWidget(
X					w_buffer,
X					commandWidgetClass,
X					box,
X					NULL);
X
X			XtVaSetValues(action[i],
X					XtNtranslations,
X					XtParseTranslationTable(ptrans),
X					NULL);
X
X			SetButton(is_icon,icon,i);
X			CreateSubMenu(fp,i,icon,path,data); 
X			i++;
X		}
X		else if((is_icon != UNKNOWN) && (GetCommand(path,command)))
X		{
X			(void) sprintf(w_buffer,"action%d",i);
X			action[i] = XtVaCreateWidget(
X					w_buffer, 	     /* widget name */	
X					commandWidgetClass,  /* widget class */
X					box,	            /* parent widget */
X					NULL);	   /* terminate varargs list */
X
X			SetButton(is_icon,icon,i);
X
X			/* add callback for this button */
X
X			if(data->sensitive)
X			{
X				if((is_icon == TEXT) || (is_icon == ICON))
X					XtAddCallback(action[i],XtNcallback,
X						SingleAction,command);
X				else
X					XtAddCallback(action[i],XtNcallback,
X						MultiAction,command);
X			}
X			else
X			{
X				if((is_icon == TEXT) || (is_icon == ICON))
X					XtAddCallback(action[i],XtNcallback,
X						MultiAction,command);
X				else
X					XtAddCallback(action[i],XtNcallback,
X						SingleAction,command);
X			}
X			i++;
X		}
X		icon[0] = '\0';
X		ch = getc(fp);
X	}
X	fclose(fp);
X	DefaultButtons(data,i);
X	return(i);
}
X
static	void
SetButton(is_icon,icon,button_num)
int	is_icon;
char	*icon;
int	button_num;
{
X
X	/* if button title is a string then */
X	if((is_icon == TEXT) || (is_icon == TEXTPLUS))
X	{
X		XtVaSetValues(
X			action[button_num],
X			XtNwidth,
X			W_WIDTH,
X			XtNheight,
X			W_HEIGHT,
X			XtNlabel,
X			icon,	/* button title */
X			NULL);
X	}
X	/* if button title is a bitmap then */
X	if((is_icon == ICON) || (is_icon == ICONPLUS))	
X	{
X		XtVaSetValues(
X			action[button_num],
X			XtNwidth,
X			W_WIDTH,
X			XtNheight,
X			W_HEIGHT,
X			XtVaTypedArg,
X			XtNbitmap,
X			XtRString,
X			icon,	/* button title (bitmap) */
X			strlen(icon) +1,
X			NULL);
X	}
}
X
static	void
SetSubMenuButton(is_icon,icon,button_num)
int	is_icon;
char	*icon;
int	button_num;
{
X
X	/* if button title is a string then */
X	if((is_icon == TEXT) || (is_icon == TEXTPLUS))
X	{
X		XtVaSetValues(
X			sub_action[button_num],
X			XtNwidth,
X			W_WIDTH,
X			XtNheight,
X			W_HEIGHT,
X			XtNlabel,
X			icon,	/* button title */
X			NULL);
X	}
X	/* if button title is a bitmap then */
X	if((is_icon == ICON) || (is_icon == ICONPLUS))	
X	{
X		XtVaSetValues(
X			sub_action[button_num],
X			XtNwidth,
X			W_WIDTH,
X			XtNheight,
X			W_HEIGHT,
X			XtVaTypedArg,
X			XtNbitmap,
X			XtRString,
X			icon,	/* button title (bitmap) */
X			strlen(icon) +1,
X			NULL);
X	}
X	if(button_num > 0)
X		XtVaSetValues(sub_action[button_num], XtNfromVert,
X				sub_action[button_num - 1],NULL);
}
X
/*
X	The function PositionButtons places each button next to the 
X	previous button one until the number of buttons equals the 
X	number of columns.  Then a new row is started.
*/
extern void
PositionButtons(i,columns)
int	i;
int	columns;
{
X	int	button_no;
X	int	position = 0;
X
X	button_no = 1;
X	while((button_no < columns) && (button_no <= i))
X	{
X		XtVaSetValues(action[button_no],
X			XtNfromHoriz,action[button_no - 1],NULL);
X		button_no++;
X	}
X	position = columns;
X	while(button_no <= i)
X	{
X		if(position == columns)
X		{
X			XtVaSetValues(action[button_no],
X				XtNfromVert,action[button_no - columns],NULL);
X			position = 0;
X		}
X		else
X		{
X			XtVaSetValues(action[button_no],
X				XtNfromVert,action[button_no - columns],NULL);
X			XtVaSetValues(action[button_no],
X				XtNfromHoriz,action[button_no -1],NULL);
X		}
X		position++;
X		button_no++;
X	}
}
X
/*
X	Once all the buttons have been created then make sure they are 
X	managed.
*/
extern void
ManageButtons()
{
X	WidgetList      w_list;
X	Cardinal        num_childern, i;
X
X	XtVaGetValues(box,
X		XtNchildren,
X		&w_list,
X		XtNnumChildren,
X		&num_childern,
X		NULL);
X
X	for(i = 0; i < num_childern; i++)
X		XtManageChild(w_list[i]);
}
X
static	void
CreateSubMenu(fp,shell_no,label,path, data)
FILE	*fp;
int	shell_no;
char	*label;
char	*path;
Info	*data;
{
X	int	button_num = 0;
X	int	key_word = 0;
X	int 	make_shell = FALSE;
X	char	icon[MAXLINE];
X	char	*command;
X
X	while(button_num < MAXBUTTONS)
X	{
X		key_word = GetKeyword(fp);
X		if(key_word == EOF)
X			break;
X		if(key_word == SUB_MENU)
X			(void) fprintf(stderr,"ERROR: only one sub menu allowed per button\n");
X		else if(key_word == END_SUB_MENU)
X			break;
X		else if(key_word == END)
X			break;
X		else if(key_word == UNKNOWN)
X		{
X			(void) fprintf(stderr,"ERROR: syntax error when reading icon file please check\n");
X		}
X		GetButtonTitle(fp,icon);
X		ReadALine(fp,&command);
X		if(GetCommand(path,command))
X		{
X			if(make_shell == FALSE)
X			{
X				CreatePopupShell(shell_no);
X				make_shell = TRUE;
X			}
X			CreateSubMenuButton(key_word,icon,button_num);
X
X			if(data->sensitive)
X			{
X				if((key_word == TEXT) || (key_word == ICON))
X					XtAddCallback(sub_action[button_num],
X					XtNcallback,SingleAction,command);
X				else
X					XtAddCallback(sub_action[button_num],
X					XtNcallback,MultiAction,command);
X			}
X			else
X			{
X				if((key_word == TEXT) || (key_word == ICON))
X					XtAddCallback(sub_action[button_num],
X					XtNcallback,MultiAction,command);
X				else
X					XtAddCallback(sub_action[button_num],
X					XtNcallback,SingleAction,command);
X			}
X
X			XtVaSetValues(sub_action[button_num],
X					XtNtranslations,
X					XtParseTranslationTable(cb_Trans),
X					NULL);
X			button_num++;
X		}
X	}
}
X
static	void
CreatePopupShell(shell_no)
int	shell_no;
{
X
X	popup_shell = XtCreatePopupShell(
X			"popup_menu",
X			overrideShellWidgetClass,
X			action[shell_no],
X			NULL,
X			0);
X
X	XtVaSetValues(popup_shell,
X			XtNtranslations,
X			XtParseTranslationTable(pm_Trans),
X			NULL);
X
X	popup_layout = XtCreateManagedWidget(
X			"popup_layout",
X			formWidgetClass,
X			popup_shell,
X			NULL,
X			0);
}
X
static	void
CreateSubMenuButton(key_word,button_name,button_num)
int	key_word;
char	*button_name;
int	button_num;
{
X	char	w_buffer[80];
X
X	(void) sprintf(w_buffer,"sub_action%d",button_num);
X	sub_action[button_num] = XtVaCreateManagedWidget(
X			w_buffer,
X			commandWidgetClass,
X			popup_layout,
X			NULL);
X
X	SetSubMenuButton(key_word,button_name,button_num); 
}
X
extern	void
set_popup(w,event,params,num_params)
Widget	w;
XXEvent	*event;	/* unused */
String	*params;
Cardinal	*num_params;
{
X	/*
X		position the menu, whose name was passed as the first and
X		only parameter at position (20,5) relative to the widget w.
X	*/
X	Widget	a_shell;
X	Position	x,y;
X
X	if(*num_params != 1)
X		XtError("Wrong parameter count passed to set_popup()");
X	
X	/* get the internal Widget id of the named shell */
X	a_shell = XtNameToWidget(toplevel,params[0]);
X	if(a_shell == NULL)
X		XtError("FATAL ERROR: Wrong shell name passed to set_popup()\n\
X			please check icon file is correct");
X	XtTranslateCoords(w,(Position) 5,(Position) 5, &x,&y);
X	XtVaSetValues(a_shell,XtNx,x,XtNy,y,NULL);
}
X
extern	void
delay(w,event,params,num_params)
Widget  w;
XXEvent  *event; /* unused */
String  *params;
Cardinal        *num_params;
{
X	(void) sleep(1);
}
X
static	void
DefaultButtons(data,last_button)
Info	*data;
int	last_button;
{
X	int	string_length;
X	char	w_buffer[80];
X	char	ptrans[250];
X	char	*edit_file, *h_file;
X
X	/* create default sub menu which will contain source, edit & quit */
X	/* buttons.  Default menu button is called Manage  */
X
X	/* create main menu button */
X	(void) sprintf(ptrans,pb_Trans,last_button,popup_menu_name);
X
X	(void) sprintf(w_buffer,"action%d",last_button);
X	action[last_button] = XtVaCreateWidget(
X			w_buffer,
X			commandWidgetClass,
X			box,
X			NULL);
X
X	XtVaSetValues(action[last_button],XtNtranslations,
X			XtParseTranslationTable(ptrans),NULL);
X
X	SetButton(TEXT,"Edit\nIcons",last_button);
X
X	/* create popup shell */
X	CreatePopupShell(last_button);
X
X	CreateSubMenuButton(TEXT,"Source",0);
X
X	XtAddCallback(sub_action[0],XtNcallback,Source,data);
X
X	XtVaSetValues(sub_action[0],XtNtranslations,
X				XtParseTranslationTable(cb_Trans),NULL);
X
X	CreateSubMenuButton(TEXT,"Edit",1);
X
X	string_length = strlen(EDITOR);
X	string_length += strlen(data->icon_file);
X	if((edit_file = malloc(string_length +1)) == NULL)
X	{
X		(void) fprintf(stderr,"ERROR: out of memory for string edit_file.  In function CreateButtons.\n");
X		exit(1);
X	}
X	strcpy(edit_file,EDITOR);
X	strcat(edit_file,data->icon_file);
X
X	XtAddCallback(sub_action[1],XtNcallback,SingleAction,edit_file);
X
X	XtVaSetValues(sub_action[1],XtNtranslations,
X				XtParseTranslationTable(cb_Trans),NULL);
X
X	CreateSubMenuButton(TEXT,"Help",2);
X
X	string_length = 0;
X	string_length = strlen(FORMATTER);
X	string_length = strlen(HELP_VIEWER);
X	string_length += strlen(data->help_file);
X	if((h_file = malloc(string_length +1)) == NULL)
X	{
X		(void) fprintf(stderr,"ERROR: out of memory for string edit_file.  In function CreateButtons.\n");
X		exit(1);
X	}
X	strcpy(h_file,FORMATTER);
X	strcat(h_file,data->help_file);
X	strcat(h_file,HELP_VIEWER);
X	XtAddCallback(sub_action[2],XtNcallback,SingleAction,h_file);
X
X	XtVaSetValues(sub_action[2],XtNtranslations,
X				XtParseTranslationTable(cb_Trans),NULL);
X
X	CreateSubMenuButton(TEXT,"Quit",3);
X
X	XtAddCallback(sub_action[3],XtNcallback,Quit,NULL);
X
X	XtVaSetValues(sub_action[3],XtNtranslations,
X				XtParseTranslationTable(cb_Trans),NULL);
}
X
SHAR_EOF
chmod 0644 buttons.c ||
echo 'restore of buttons.c failed'
Wc_c="`wc -c < 'buttons.c'`"
test 13200 -eq "$Wc_c" ||
	echo 'buttons.c: original size 13200, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= gen.c ==============
if test -f 'gen.c' -a X"$1" != X"-c"; then
	echo 'x - skipping gen.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting gen.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'gen.c' &&
static char* sccs_gen_c = "%W%%G%";
X
/* 
X * Copyright 1992 Bruce. R. Ingram.
X * University of Kent at Canterbury, UK
X *
X * Permission  to   use, copy, modify  and  distribute  this  software  and its
X * documentation   for any purpose is hereby granted without fee, provided that
X * the   above  copyright  notice  appear  in  all  copies  and  that both that
X * copyright  notice   and  this   permission   notice  appear  in   supporting
X * documentation,  and  that  the name  of the author and The University  of
X * Kent  at  Canterbury  not be  used in advertising or publicity pertaining to
X * distribution  of  the  software  without specific, written prior permission.
X * The   author  and   The   University   of   Kent at   Canterbury   make  no
X * representations  about  the  suitability  of this  software for any purpose.
X * It is provided "as is" without express or implied warranty.
X *
X * THE   AUTHOR  AND  THE  UNIVERSITY  OF KENT  AT   CANTERBURY  DISCLAIMS ALL
X * WARRANTIES  WITH  REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED  WARRANTIES
X * OF   MERCHANTABILITY  AND  FITNESS,  IN NO  EVENT  SHALL THE AUTHOR  OR THE
X * UNIVERSITY  OF KENT  AT  CANTERBURY  BE LIABLE FOR ANY SPECIAL, INDIRECT  OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS  OF USE,
X * DATA  OR  PROFITS,  WHETHER  IN  AN ACTION OF CONTRACT, NEGLIGENCE  OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
X * OF THIS SOFTWARE.
X *
X * Author:
X *
X * Mr  B. R. Ingram email bri@ukc.ac.uk
*/
X
#include "gen.h"
X
static	int	IsExecutable PROTO((char *,char *)), 
X		Executable PROTO((char *));
extern	void	CheckForComments PROTO((FILE *));
X
/*
X	IsExecutable function searches along the users path trying to
X	locate the file program.  If found a check is made to see if it
X	is executable.  If it is TRUE is returned, otherwise FALSE is
X	returned.
*/
static int
IsExecutable(path,program)
char	*path;
char	*program;
{
X	int i, j;
X	char	pathname[MAXPATHLEN];
X
X	i = 0;
X	if(*program == '/')
X	{
X		if(Executable(program))
X			return(TRUE);
X		else
X			return(FALSE);
X	}
X	while (path[i] != '\0')
X	{
X		if (path[i] == ' ')
X			++i;
X		for (j = 0; path[i] != ' ' && path[i] != '\0'; ++i, ++j)
X			pathname[j] = path[i];
X		pathname[j++] = '/';
X		strcpy(&pathname[j], program);
X		if(Executable(pathname)) 
X			return(TRUE);
X	}
X	return(FALSE);
}
X
X
/*
X	GetCommand reads a line of text from the file pointed at by file
X	pointer fp.  It then checks if the first word is a valid command.
*/
extern int
GetCommand(path,command)
char	*path;
char	*command;
{
X	int	i = 0;
X	int	is_binary = FALSE;
X	char	prog_name[MAXPATHLEN];
X	char	*c_ptr;
X
X	prog_name[0] = '\0';
X	if(*command != NULL)
X	{
X		c_ptr = command;
X		/* get first word from line of text */
X		while((*c_ptr != ' ') && (*c_ptr != '\0') && (*c_ptr != '\n'))
X			prog_name[i++] = *c_ptr++;
X		prog_name[i] = '\0';
X		if(IsExecutable(path,prog_name))
X			is_binary = TRUE;
X		else
X		{
X			(void) fprintf(stderr,"ERROR: %s ",prog_name);
X			(void) fprintf(stderr,"is not executable or file not found\n");
X		}
X	}
X	return(is_binary);
}
X
X
X
/*
X	The function GetPath fills in the given char array with the value of 
X	the environmental variable PATH, with spaces instead of colons, and a 
X	'.' in the appropriate place.
*/
extern void
GetPath(p)
char *p;
{
X        char *path;
X
X        path = getenv("PATH");
X        if (*path == ':')
X                *p++ = '.';
X        while (*path != '\0') {
X                if (*path == ':')
X                        *p++ = ' ';
X                else
X                        *p++ = *path;
X                ++path;
X        }
X        if (*--path == ':')
X                *p++ = '.';
X        *p = '\0';
}
X
X
/*
X	The Executable  function returns True if file exists and is a directly 
X	executable Regular file. Otherwise False is returned.
X */
static int
Executable(file)
char *file;
{
X        struct stat st_buf;
X
X        if ( stat(file, &st_buf) != 0 )
X           return (FALSE); 
X        else 
X           return (S_IFREG & st_buf.st_mode) && (access(file,1)==0) && 
X		( !(S_IFDIR & st_buf.st_mode) ) ; 
}
X
extern	void
ReadALine(fp,command)
FILE	*fp;
char	**command;
{
X	char    c_line[MAXLINE];
X
X	c_line[0] = '\0';
X	CheckForComments(fp);
X	fgets(c_line,MAXLINE,fp); 
X	if(*c_line != NULL)
X	{
X		*command = strcpy(malloc(strlen(c_line) + 1), c_line);
X		if(*command == NULL)
X		{
X			(void) fprintf(stderr,"ERROR: out of memory \n");
X			exit(1);
X		}
X	}
}
X
X
extern int
GetKeyword(fp)
FILE	*fp;
{
X	int	symbol = FALSE;
X	int	valid = 0;
X	char	label[20];
X
X	CheckForComments(fp);
X	valid = fscanf(fp,"%s",label);
X	if(valid == EOF)
X		symbol = EOF;
X	else if((strcmp(label,"%icon")) == 0)
X		symbol = ICON;
X	else if((strcmp(label,"%icon+")) == 0)
X		symbol = ICONPLUS;
X	else if((strcmp(label,"%text")) == 0)
X		symbol = TEXT;
X	else if((strcmp(label,"%text+")) == 0)
X		symbol = TEXTPLUS;
X	else if((strcmp(label,"%sub_menu")) == 0)
X		symbol = SUB_MENU;
X	else if((strcmp(label,"%end_sub_menu")) == 0)
X		symbol = END_SUB_MENU;
X	else if((strcmp(label,"\0")) == 0)
X		symbol = END;
X	else
X		symbol = UNKNOWN;
X	return(symbol);
}
X
X
/*
X	Read the button title from file pointed at by file pointer fp. 
*/
extern	void
GetButtonTitle(fp,title)
FILE	*fp;
char	*title;
{
X	int	i = 0;
X	char	ch;	
X
X	title[0] = '\0';
X	ch = getc(fp);
X	if (isspace(ch))
X	{
X		while (((ch = getc(fp)) != EOF) && (isspace(ch)))
X					;
X	}
X	ungetc(ch,fp);
X	while(((ch = getc(fp)) != EOF) && (i < MAXLINE) && (ch != '\n'))
X	{
X		if(ch == '\\')
X		{
X			ch = getc(fp);
X			if(ch == EOF)
X				break;
X			if(ch == 'n')
X			{
X				title[i] = '\n';
X				i++;
X				ch = getc(fp);
X			}
X			else
X			{
X				title[i] = '\\';
X				i++;
X				title[i] = ch;
X			}
X		}
X		title[i] = ch;
X		i++;
X	}
X	title[i] = '\0';
}
X
X
/*
X	Any line of text beginning with a "#" character is a comment line.
X	This function looks for comment lines and ignores them.
*/
extern void
CheckForComments(fp)
FILE	*fp;
{
X	int	is_comment = TRUE;
X	char	ch;
X
X	ch = getc(fp);
X	while(is_comment)
X	{
X		if(ch == '#')
X		{
X			while((ch != EOF) && (ch != '\n'))
X				ch = getc(fp);
X		}
X		else if(isspace(ch))
X		{
X			 while((ch != EOF) && (isspace(ch)))
X				ch = getc(fp);
X		}
X		else
X		{
X			is_comment = FALSE;
X			ungetc(ch,fp);
X		}
X	}
}
X
SHAR_EOF
chmod 0644 gen.c ||
echo 'restore of gen.c failed'
Wc_c="`wc -c < 'gen.c'`"
test 6188 -eq "$Wc_c" ||
	echo 'gen.c: original size 6188, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= gen.h ==============
if test -f 'gen.h' -a X"$1" != X"-c"; then
	echo 'x - skipping gen.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting gen.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'gen.h' &&
static char* sccs_gen_h = "%W%%G%";
X
#include <stdio.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <X11/Xos.h>
#include <X11/Intrinsic.h>
#include <X11/StringDefs.h>
#include <X11/Xaw/Form.h>
#include <X11/Xaw/Command.h>
#include <X11/Shell.h>
#include <X11/Xaw/Cardinals.h>
#include <malloc.h>
#include <ctype.h>
X
/*
X	Macro for using prototypes if ANSI C is available.
*/
#ifdef __STDC__
#define PROTO(x) x
#else
#define PROTO(x) ()
#endif
X
#define	MAXLINE		500	
#define	MAXBUTTONS	16		/* max number of "buttons" */
#define NO_OF_COLS      18		/* default number of columns */
#define	W_WIDTH		55		/* width of "button" widgets */
#define	W_HEIGHT	55		/* height of "button" widgets */
#define	EDITOR		"xterm -e vi "	/* editor used to edit icon file. */
#define	FORMATTER	"xterm -e vi " /* text formatter for help file */
#define	HELP_VIEWER	" "		/* viewer for help file */
#define	MAXPROCS	20
X
#define	ICON		1	
#define	TEXT		2
#define	SUB_MENU	3
#define	END_SUB_MENU	4
#define	UNKNOWN		5
#define	END		6
#define	TEXTPLUS	7
#define	ICONPLUS	8
X
#ifndef MAXPATHLEN
#define MAXPATHLEN	1024
#endif
X
#define	RESOURCE_NAME	".bitmapFilePath: "
#define	RESOURCE_VALUE	"/bitmaps"
/*
X	structure for holding info on number of buttons created, number of
X	columns & file to be read.
*/
typedef struct	info{
X		int	no_of_buttons;
X		int	no_of_columns;
X		Boolean	sensitive;
X		char	*icon_file;
X		char	*help_file;
}Info;
X
typedef struct	c_id{
X		int	child_id;
X		Widget	w_id;
}ChildInfo;
X
ChildInfo	ci_ptr[MAXPROCS];
X
/* forward declarations */
int	fprintf(), ungetc(), fclose(), fscanf();
char	*strcpy(), *getenv(), *malloc(); 
X
typedef int     bool_t;
X
SHAR_EOF
chmod 0644 gen.h ||
echo 'restore of gen.h failed'
Wc_c="`wc -c < 'gen.h'`"
test 1642 -eq "$Wc_c" ||
	echo 'gen.h: original size 1642, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= main.c ==============
if test -f 'main.c' -a X"$1" != X"-c"; then
	echo 'x - skipping main.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting main.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'main.c' &&
static char* sccs_main_c = "%W%%G%"; 
X
/* 
X * Copyright 1992 Bruce. R. Ingram.
X * University of Kent at Canterbury, UK
X *
X * Permission  to   use, copy, modify  and  distribute  this  software  and its
X * documentation   for any purpose is hereby granted without fee, provided that
X * the   above  copyright  notice  appear  in  all  copies  and  that both that
X * copyright  notice   and  this   permission   notice  appear  in   supporting
X * documentation,  and  that  the name  of the author and The University  of
X * Kent  at  Canterbury  not be  used in advertising or publicity pertaining to
X * distribution  of  the  software  without specific, written prior permission.
X * The   author  and   The   University   of   Kent at   Canterbury   make  no
X * representations  about  the  suitability  of this  software for any purpose.
X * It is provided "as is" without express or implied warranty.
X *
X * THE   AUTHOR  AND  THE  UNIVERSITY  OF KENT  AT   CANTERBURY  DISCLAIMS ALL
X * WARRANTIES  WITH  REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED  WARRANTIES
X * OF   MERCHANTABILITY  AND  FITNESS,  IN NO  EVENT  SHALL THE AUTHOR  OR THE
X * UNIVERSITY  OF KENT  AT  CANTERBURY  BE LIABLE FOR ANY SPECIAL, INDIRECT  OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS  OF USE,
X * DATA  OR  PROFITS,  WHETHER  IN  AN ACTION OF CONTRACT, NEGLIGENCE  OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
X * OF THIS SOFTWARE.
X *
X * Author:
X *
X * Mr  B. R. Ingram email bri@ukc.ac.uk
*/
X
#include "gen.h"
#include "widgets.h"
X
X
/*  Forward  references  */
X
extern	int	CreateButtons PROTO((Info *));
extern	void	GetPath PROTO((char *));
extern	void	PositionButtons PROTO((int,int)), ManageButtons();
extern  void    set_popup PROTO((Widget,XEvent *,String *,Cardinal *));
extern	void	delay PROTO((Widget,XEvent *,String *,Cardinal *));
extern	void	Quit PROTO((Widget,XtPointer,XtPointer));
static	void	AddResource PROTO((char **));
X
#include "trans.h"
X
/*
X	We set various default resources for the various widgets.
*/
String fallback_resources[] = {
"*background:    #ffd28e",
"*foreground:	black",
"*borderColor:	black",
"*box.background:	gray",
NULL,
};
X
X
/*
X	We store our application's resources in a structure of 
X	the following type.
*/
typedef struct
{
X	int 	no_of_cols;
X	char	*icon_file;
X	char	*help_file;
X	Boolean	sensitive;
} AppData, *AppDataPtr;
X
X
/* The description of our application's resources. */
static XtResource resources[] = {
X	{ "no_of_cols", "No_of_cols",XtRInt,sizeof (int),
X	  XtOffset(AppDataPtr,no_of_cols),XtRString,"18" },
X	{ "icon_file", "Icon_file", XtRString, sizeof(char *),
X	  XtOffset(AppDataPtr,icon_file),XtRString,"./.briconsrc" },
X	{ "help_file", "Help_file", XtRString, sizeof(char *),
X	  XtOffset(AppDataPtr,help_file),XtRString,
X	  "bricons.txt" },
X	{ "sensitive", "Sensitive", XtRBoolean, sizeof(Boolean),
X	  XtOffset(AppDataPtr,sensitive),XtRString,"False" },
};
X
/* Reading command line options. */
XXrmOptionDescRec options[] = {
X	{ "-col", "*no_of_cols", XrmoptionSepArg, NULL },
X	{ "-file", "*icon_file", XrmoptionSepArg, NULL },
X	{ "-help", "*help_file", XrmoptionSepArg, NULL },
X	{ "-sensitive", "sensitive", XrmoptionSepArg, NULL }
};
X
X
XXtAppContext    app_context;
X
int 
main(argc,argv)
unsigned int argc;
char **argv;
{
X	int		string_len = 0;
X	Info		*data;	
X	AppData		Rdata;
X
X	/* create a shell widget for this application */
X	toplevel = XtVaAppInitialize(
X                &app_context,           /* Application context */
X                "Xbricons",             /* Application class name */
X                options, 		/* Command line option list */
X		XtNumber(options),  
X                &argc, argv,            /* Command line args */
X		/* fallback_resources	   use fallback_resources or */
X		NULL,		 	/* app_defaults file */
X                NULL);			/* terminate varargs list */	
X
X	/* Retrieve the application resources */
X	XtVaGetApplicationResources(toplevel,&Rdata,resources,
X			XtNumber(resources),NULL);
X
X	AddResource(argv[0]);
X
X	/* add the menu actions to the global action list */
X	XtAppAddActions(app_context,(XtActionList) menu_actions,
X				XtNumber(menu_actions));
X
X	/* create a form widget which is used to hold all the buttons */
X	box = XtVaCreateManagedWidget("box",	/* widget name */
X		formWidgetClass,		/* widget class */
X		toplevel,			/* parent widget */
X		NULL);				/* terminate varargs list */
X
/*
X	allocate some memory for data structure holding number of buttons,
X	the name of the icon file etc.
*/
X	data = (struct info *) malloc(sizeof(struct info));
X	if(data == NULL)
X	{
X		(void) fprintf(stderr,"%s: out of memory when creating Info data structure. In function main\n",argv[0]);
X		exit(1);
X	}	
X
X	string_len = 0;
X	string_len = strlen(Rdata.icon_file);
X	if((data->icon_file = malloc(string_len +1)) == NULL)
X	{
X		(void) fprintf(stderr,"%s: out of memory reading icon file name.  In function main\n",argv[0]);
X		exit(1);
X	}
X	strcpy(data->icon_file,Rdata.icon_file);
X
X	string_len = 0;
X	string_len = strlen(Rdata.help_file);
X	if((data->help_file = malloc(string_len +1)) == NULL)
X	{
X		(void) fprintf(stderr,"%s: out of memory reading icon file name.  In function main\n",argv[0]);
X		exit(1);
X	}
X	strcpy(data->help_file,Rdata.help_file);
X
X	data->no_of_columns = Rdata.no_of_cols;
X
X	data->sensitive = Rdata.sensitive;
X
X	/* read contents of icon file & create buttons */
X	data->no_of_buttons = CreateButtons(data);
X
X	/* position buttons according to number of columns */
X	PositionButtons(data->no_of_buttons,data->no_of_columns);
X
X	ManageButtons();
X
X	/* create windows for widgets and map them. */
X	XtRealizeWidget(toplevel);
X
X	/* loop for events */
X	XtAppMainLoop(app_context);
X	exit(0);
}
X
X
X
static	void
AddResource(prog_name)
char *prog_name;
{
X	int		string_len, len;
X	char		*bitmap_dir;	
X	char		tmp_string[300];
X	char		*res_name_ptr;
X	char		current_dir[MAXPATHLEN];
X	char		*dummy;
X	XrmDatabase	resource_db;
X	XrmDatabase	*dbPtr;
X	XrmValue	value;
X	XrmValue	*vPtr;
X	Bool		found;
X
X	resource_db = XtDatabase(XtDisplay(toplevel));
X
X	string_len = strlen(RESOURCE_NAME);
X	string_len += strlen(RESOURCE_VALUE);
X	res_name_ptr = malloc(MAXPATHLEN + string_len + 1);
X	if(res_name_ptr == NULL)
X	{
X		(void) fprintf(stderr,"\nOut of memory error\n");
X		exit(1);
X	}
X	(void)getcwd(current_dir,MAXPATHLEN);
X
X	strcpy(res_name_ptr,RESOURCE_NAME);
X	strcat(res_name_ptr,current_dir);
X	strcat(res_name_ptr,RESOURCE_VALUE);
X
X	(void) sprintf(tmp_string,"%s.bitmapFilePath",prog_name);
X	found = XrmGetResource(resource_db, tmp_string, 
X			"Xbricons.BitmapFilePath", &dummy, &value);
X	dbPtr = &resource_db;
X	vPtr = &value;
X	if(!found)
X	{
X		(void) fprintf(stderr,"\n.bitmapFilePath not defined in resource file");
X		(void) fprintf(stderr,"\nAdding default: %s\n",res_name_ptr);
X		XrmPutLineResource(dbPtr, res_name_ptr); 
X	}
X	else
X	{
X		len  = strlen(vPtr->addr);
X		len += strlen(current_dir);
X		len += strlen(RESOURCE_NAME);
X		len += strlen(RESOURCE_VALUE);
X		bitmap_dir = malloc(len + 2);
X		if(bitmap_dir == NULL)
X		{
X			(void) fprintf(stderr,"\nOut of memory error\n");
X			exit(1);
X		}
X		strcpy(bitmap_dir, RESOURCE_NAME);
X		strcat(bitmap_dir,vPtr->addr);
X		strcat(bitmap_dir,":");
X		strcat(bitmap_dir,current_dir);
X		strcat(bitmap_dir,RESOURCE_VALUE);
X		XrmPutLineResource(dbPtr, bitmap_dir); 
X	}
}
SHAR_EOF
chmod 0644 main.c ||
echo 'restore of main.c failed'
Wc_c="`wc -c < 'main.c'`"
test 7300 -eq "$Wc_c" ||
	echo 'main.c: original size 7300, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= patchlevel.h ==============
if test -f 'patchlevel.h' -a X"$1" != X"-c"; then
	echo 'x - skipping patchlevel.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting patchlevel.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'patchlevel.h' &&
#define PATCH_LEVEL 0
SHAR_EOF
chmod 0644 patchlevel.h ||
echo 'restore of patchlevel.h failed'
Wc_c="`wc -c < 'patchlevel.h'`"
test 22 -eq "$Wc_c" ||
	echo 'patchlevel.h: original size 22, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= trans.h ==============
if test -f 'trans.h' -a X"$1" != X"-c"; then
	echo 'x - skipping trans.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting trans.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'trans.h' &&
static char* sccs_trans_h = "%W%%G%";
X
/*
X	translations for the main menu buttons to popup the sub menu.  
X	SetPopup positions the shell.  MenuPopup realizes the shell.
*/
X
static	String pb_Trans =
X	"<EnterWindow>:	highlight() \n\
X	<LeaveWindow>:	unhighlight() \n\
X	<Btn1Down>:	set_popup(box.action%d.popup_menu) MenuPopup(popup_menu) unhighlight()";
X
/*
X	translations for the command buttons of the popup menus the
X	command callback is invoked when the button is released with
X	the pointer in the command widget.
*/
X
static	String cb_Trans =
X	"<EnterWindow>:	set() \n\
X	<LeaveWindow>:	unset() \n\
X	<Btn1Up>:	notify() delay() reset()";
X
/*
X	translations for the shell of the popup menu.  When the button
X	is released the shell catches it and pops itself down.
*/
X
static	String pm_Trans =
X	"<Btn1Up>:	MenuPopdown()";
X
/* add new actions to this program */
X
static	XtActionsRec	menu_actions[] = {
X	{ "set_popup", set_popup },
X	{ "delay", delay }
};
X
/*  the name of the shell, used by SetPopup and MenuPopup actions */
static  String popup_menu_name = "popup_menu";
X
SHAR_EOF
chmod 0644 trans.h ||
echo 'restore of trans.h failed'
Wc_c="`wc -c < 'trans.h'`"
test 1066 -eq "$Wc_c" ||
	echo 'trans.h: original size 1066, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= widgets.h ==============
if test -f 'widgets.h' -a X"$1" != X"-c"; then
	echo 'x - skipping widgets.h (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting widgets.h (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'widgets.h' &&
X
Widget  toplevel,       /* must exist on which to place other widgets */
X		box,
X			action[MAXBUTTONS + 1],
X			popup_shell,
X				popup_layout,
X				sub_action[10];
SHAR_EOF
chmod 0644 widgets.h ||
echo 'restore of widgets.h failed'
Wc_c="`wc -c < 'widgets.h'`"
test 162 -eq "$Wc_c" ||
	echo 'widgets.h: original size 162, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
rm -f _shar_seq_.tmp
echo You have unpacked the last part
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
