Newsgroups: comp.sources.x
Path: uunet!zaphod.mps.ohio-state.edu!mips!msi!dcmartin
From: bri@ukc.ac.uk
Subject: v17i061: bricons - command panel, Part01/02
Message-ID: <csx-17i061-bricons@uunet.UU.NET>
Originator: dcmartin@fascet
Sender: dcmartin@msi.com (David C. Martin - Moderator)
Nntp-Posting-Host: fascet
Organization: Molecular Simulations, Inc.
Date: Tue, 14 Apr 1992 14:45:34 GMT
Approved: dcmartin@msi.com
Lines: 1439

The program is called bricons and allows the user to quickly start up 
applications from a configured command panel on a workstation display
running X.  Each button is used to execute a shell command using the Bourne 
shell. Each button can be configured to display a single spring loaded popup 
menu with up to ten more buttons.

- Bruce Ingram -

Submitted-by: bri@ukc.ac.uk
Posting-number: Volume 17, Issue 61
Archive-name: bricons/part01

#!/bin/sh
# This is a shell archive (produced by shar 3.49)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 04/14/1992 14:43 UTC by dcmartin@fascet
# Source directory /home/fascet/dcmartin/csx/src/bricons
#
# existing files will NOT be overwritten unless -c is specified
#
# This is part 1 of a multipart archive                                    
# do not concatenate these parts, unpack them in order with /bin/sh        
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#    738 -rw-r--r-- Imakefile
#  11340 -rw-r--r-- Makefile
#    575 -rw-r--r-- Makefile.std
#   1515 -rw-r--r-- README
#    784 -rw-r--r-- Xbricons
#   6041 -rw-r--r-- action.c
#   1871 -rw-r--r-- bitmaps/calander
#   1883 -rw-r--r-- bitmaps/letters
#   2256 -rw-r--r-- bitmaps/games
#   2378 -rw-r--r-- bitmaps/help
#   1965 -rw-r--r-- bitmaps/dclock
#   2256 -rw-r--r-- bitmaps/dragon
#   1748 -rw-r--r-- bitmaps/readNews
#    875 -rw-r--r-- bitmaps/load
#   6362 -rw-r--r-- bricons.l
#   7617 -rw-r--r-- bricons.txt
#  13200 -rw-r--r-- buttons.c
#   6188 -rw-r--r-- gen.c
#   1642 -rw-r--r-- gen.h
#   7300 -rw-r--r-- main.c
#     22 -rw-r--r-- patchlevel.h
#   1066 -rw-r--r-- trans.h
#    162 -rw-r--r-- widgets.h
#
if test -r _shar_seq_.tmp; then
	echo 'Must unpack archives in sequence!'
	echo Please unpack part `cat _shar_seq_.tmp` next
	exit 1
fi
# ============= Imakefile ==============
if test -f 'Imakefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Imakefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Imakefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Imakefile' &&
/**/# static char* sccs_imake = "%W%%G%";
/**/#	Imakefile for bricons
X
X
/**/# Here's what to change to customize the installation...
/**/# Where do you want this stuff (if the defaults aren't okay)?
BINDIR = /usr/local/bin
LIBDIR = /usr/lib
MANDIR = /usr/man
X
/**/# This is -g for debugging.
CDEBUGFLAGS = -g
X
SRCS =  main.c \
X	action.c \
X	buttons.c \
X	gen.c 
X
OBJS =  main.o \
X	buttons.o \
X	action.o \
X	gen.o 
X
HDRS = 	gen.h \
X	trans.h \
X	widgets.h
X
LOCAL_LIBRARIES = XawClientLibs
X
ComplexProgramTarget(bricons)
X
install::
/**/# This definition installs the Xbricons resource file.
/**/# the .briconsrc file & the man page bricons.l
InstallAppDefaults(Xbricons)
InstallNonExec(.briconsrc,$(LIBDIR))
InstallManPage(bricons.l,$(MANDIR))
X
SHAR_EOF
chmod 0644 Imakefile ||
echo 'restore of Imakefile failed'
Wc_c="`wc -c < 'Imakefile'`"
test 738 -eq "$Wc_c" ||
	echo 'Imakefile: original size 738, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile ==============
if test -f 'Makefile' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile' &&
# Makefile generated by imake - do not edit!
# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
#
# The cpp used on this machine replaces all newlines and multiple tabs and
# spaces in a macro expansion with a single space.  Imake tries to compensate
# for this, but is not always successful.
#
X
# -------------------------------------------------------------------------
# Makefile generated from "Imake.tmpl" and <Imakefile>
# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
#
# Platform-specific parameters may be set in the appropriate <vendor>.cf
# configuration files.  Site-specific parameters should be set in the file
# site.def.  Full rebuilds are recommended if any parameters are changed.
#
# If your C preprocessor does not define any unique symbols, you will need
# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
# "make World" the first time).
#
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that need to come before
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
# -------------------------------------------------------------------------
# platform-specific configuration parameters - edit sun.cf to change
X
# platform:  $XConsortium: sun.cf,v 1.68 91/07/30 11:34:39 rws Exp $
X
# operating system:  SunOS 4.1.1
X
# $XConsortium: sunLib.rules,v 1.6 91/03/24 17:55:58 rws Exp $
X
# -------------------------------------------------------------------------
# site-specific configuration parameters that go after
# the platform-specific parameters - edit site.def to change
X
# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X            SHELL = /bin/sh
X
X              TOP = .
X      CURRENT_DIR = .
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = install
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -C
X         LINTOPTS = -axz
X               LN = ln -s
X             MAKE = make
X               MV = mv
X               CP = cp
X
X           RANLIB = ranlib
X  RANLIBINSTFLAGS =
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES =
X      STD_DEFINES =
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF = -DSUNSHLIB
X
X    PROTO_DEFINES =
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0644
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X      PROJECTROOT = /usr/X11/R5
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X      CDEBUGFLAGS = -O
X        CCOPTIONS = -pipe
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = sun.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
# -------------------------------------------------------------------------
# X Window System Build Parameters
# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
# -------------------------------------------------------------------------
# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/X11/R5/lib
X           BINDIR = /usr/X11/R5/bin
X          INCROOT = /usr/X11/R5/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/X11/R5/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = n
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
# $XConsortium: sunLib.tmpl,v 1.11 91/07/31 11:32:08 rws Exp $
X
SHLIBLDFLAGS = -assert pure-text
PICFLAGS = -pic
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sa.$(SOXMUREV)
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sa.$(SOXTREV)
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sa.$(SOXAWREV)
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        SOXLIBREV = 4.10
X          SOXTREV = 4.10
X         SOXAWREV = 5.0
X        SOOLDXREV = 4.10
X         SOXMUREV = 4.10
X        SOXEXTREV = 4.10
X      SOXINPUTREV = 4.10
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
# -------------------------------------------------------------------------
# Imake rules for building libraries, programs, scripts, and data files
# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
# -------------------------------------------------------------------------
# start of Imakefile
X
# static char* sccs_imake = "%W%%G%";
#	Imakefile for bricons
X
# Here's what to change to customize the installation...
# Where do you want this stuff (if the defaults aren't okay)?
BINDIR = /usr/local/bin
LIBDIR = /usr/lib
MANDIR = /usr/man
X
# This is -g for debugging.
CDEBUGFLAGS = -g
X
SRCS =  main.c \
X	action.c \
X	buttons.c \
X	gen.c
X
OBJS =  main.o \
X	buttons.o \
X	action.o \
X	gen.o
X
HDRS = 	gen.h \
X	trans.h \
X	widgets.h
X
LOCAL_LIBRARIES = $(XAWLIB) $(XMULIB) $(XTOOLLIB) $(XLIB)
X
X PROGRAM = bricons
X
all:: bricons
X
bricons: $(OBJS) $(DEPLIBS)
X	$(RM) $@
X	$(CC) -o $@ $(OBJS) $(LDOPTIONS) $(LOCAL_LIBRARIES) $(LDLIBS) $(EXTRA_LOAD_FLAGS)
X
saber_bricons:: $(SRCS)
X	# load $(ALLDEFINES) $(SRCS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
osaber_bricons:: $(OBJS)
X	# load $(ALLDEFINES) $(OBJS) $(LOCAL_LIBRARIES) $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
install:: bricons
X	@if [ -d $(DESTDIR)$(BINDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(BINDIR)); fi
X	$(INSTALL) -c $(INSTPGMFLAGS)  bricons $(DESTDIR)$(BINDIR)
X
install.man:: bricons.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) bricons.man $(DESTDIR)$(MANDIR)/bricons.$(MANSUFFIX)
X
depend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
lint:
X	$(LINT) $(LINTFLAGS) $(SRCS) $(LINTLIBS)
lint1:
X	$(LINT) $(LINTFLAGS) $(FILE) $(LINTLIBS)
X
clean::
X	$(RM) $(PROGRAM)
X
install::
# This definition installs the Xbricons resource file.
# the .briconsrc file & the man page bricons.l
X
install:: Xbricons.ad
X	@if [ -d $(DESTDIR)$(XAPPLOADDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(XAPPLOADDIR)); fi
X	$(INSTALL) -c $(INSTAPPFLAGS) Xbricons.ad $(DESTDIR)$(XAPPLOADDIR)/Xbricons
X
install:: .briconsrc
X	$(INSTALL) -c $(INSTDATFLAGS) .briconsrc $(DESTDIR)$(LIBDIR)
X
install.man:: bricons.l.man
X	@if [ -d $(DESTDIR)$(MANDIR) ]; then set +x; \
X	else (set -x; $(MKDIRHIER) $(DESTDIR)$(MANDIR)); fi
X	$(INSTALL) -c $(INSTMANFLAGS) bricons.l.man $(DESTDIR)$(MANDIR)/bricons.l.$(MANSUFFIX)
X
# -------------------------------------------------------------------------
# common rules for all Makefiles - do not edit
X
emptyrule::
X
clean::
X	$(RM_CMD) "#"*
X
Makefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
tags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X
saber:
X	# load $(ALLDEFINES) $(SRCS)
X
osaber:
X	# load $(ALLDEFINES) $(OBJS)
X
# -------------------------------------------------------------------------
# empty rules for directories that do not have SUBDIRS - do not edit
X
install::
X	@echo "install in $(CURRENT_DIR) done"
X
install.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
Makefiles::
X
includes::
X
# -------------------------------------------------------------------------
# dependencies generated by makedepend
X
SHAR_EOF
chmod 0644 Makefile ||
echo 'restore of Makefile failed'
Wc_c="`wc -c < 'Makefile'`"
test 11340 -eq "$Wc_c" ||
	echo 'Makefile: original size 11340, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Makefile.std ==============
if test -f 'Makefile.std' -a X"$1" != X"-c"; then
	echo 'x - skipping Makefile.std (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Makefile.std (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Makefile.std' &&
X
OBJS=main.o gen.o action.o buttons.o
X
#CC=gcc
CC=cc
#CFLAGS= -ansi -pedantic -Wall
CFLAGS= -g
#CFLAGS= -O2
X
LIBS= -lXaw -lXmu -lXt -lXext -lX11 
X
TARGET= bricons
X
X
all:	$(OBJS)
X	$(CC) $(CFLAGS) -o $(TARGET) $(OBJS) $(LIBS)
X
main.o:		gen.h widgets.h trans.h main.c
X		$(CC) $(CFLAGS) -c main.c
X
gen.o:		gen.h gen.c
X		$(CC) $(CFLAGS) -c gen.c
X
action.o:	gen.h widgets.h action.c
X		$(CC) $(CFLAGS) -c action.c
X
buttons.o:	gen.h widgets.h trans.h buttons.c
X		$(CC) $(CFLAGS) -c buttons.c
X
install:
X	strip $(TARGET)
X	mv $(TARGET) /s/bri/bin/mbins/$Mbin
X
clean:
X	rm $(TARGET) *.o
X
SHAR_EOF
chmod 0644 Makefile.std ||
echo 'restore of Makefile.std failed'
Wc_c="`wc -c < 'Makefile.std'`"
test 575 -eq "$Wc_c" ||
	echo 'Makefile.std: original size 575, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= README ==============
if test -f 'README' -a X"$1" != X"-c"; then
	echo 'x - skipping README (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting README (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'README' &&
PROGRAM
X	bricons
X
DESCRIPTION
X	The bricons program allows the user to start up applications 
X	from a configured command panel on a workstation display 
X	running X.  The bricons interface can consist of up to sixteen
X	buttons which can display some text or an icon. Each button is 
X	used to execute a shell command using the Bourne shell.
X	Each button can be configured to display a single spring 
X	loaded popup menu with up to ten more buttons.
X
COMPILATION
X	Assuming a good X installation at your site, simply:
X
X		xmkmf ; make
X
X	Otherwise use the Makefile provided.
X
CONFIGURATION
X	Once the bricons program has been successfully compiled it can
X	be executed straight away it should display some example buttons
X	one of which is a sub menu.
X
X	The bricons program looks for a .briconsrc configuration file in
X	your home directory otherwise it looks in the current directory
X	for the file.
X
PORTABILITY
X	The bricons program has been compiled and tested on the following:
X
X	machine 		SPARC workstation1 	SPARC workstation2 
X	operating system	SunOS 4.1.1		SunOS 4.1.2_ER
X
X	machine			DEC3100 		VAX station
X	operating system	Ultrix Worksystem V2.1	Ultrix-32 V3.1
X				(Rev 14)		(Rev. 9)
X
X	machine			Sun3
X	operating system	SunOS 4.1.1	
X
ACKNOWLEDGEMENTS
X	Many thanks go to Richard Hesketh and Martin Davy for all their
X	help and advice.
X
___________________________________________________________________________
X	Bruce Ingram	email	bri@ukc.ac.uk
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SHAR_EOF
chmod 0644 README ||
echo 'restore of README failed'
Wc_c="`wc -c < 'README'`"
test 1515 -eq "$Wc_c" ||
	echo 'README: original size 1515, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= Xbricons ==============
if test -f 'Xbricons' -a X"$1" != X"-c"; then
	echo 'x - skipping Xbricons (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting Xbricons (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'Xbricons' &&
! Application resources file for bricons program
! B.R. Ingram 9th Sept 1991
*no_of_cols: 			16
*icon_file: 			/home/cur/bri/.briconsrc
*help_file:			/home/cur/bri/Man/bricons.l
*borderColor:			yellow
*popup_layout*.borderColor:	black
*background:			#ffd28e
*box.background:		gray
*action0.background:		#fafbc6
*action1.background:		#fadde8
*action2.background:		#d9fedd
*action3.background:		#ececc9
*action4.background:		#ffffff
*action5.background:		#feffc5
*action6.background:		#feff99
*action7.background:		#fedcff
*action8.background:		#febeff
*action9.background:		#bfffff
*action10.background:		#8bffff
*action11.background:		#8bfd8e
*action12.background:		#cdebef
*action13.background:		#f3ea8a
*action14.background:		#f3eae6
*font: -adobe-times-bold-i-*-*-14-*-*-*-*-*-*-*
SHAR_EOF
chmod 0644 Xbricons ||
echo 'restore of Xbricons failed'
Wc_c="`wc -c < 'Xbricons'`"
test 784 -eq "$Wc_c" ||
	echo 'Xbricons: original size 784, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= action.c ==============
if test -f 'action.c' -a X"$1" != X"-c"; then
	echo 'x - skipping action.c (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting action.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'action.c' &&
#include "gen.h"
#include "widgets.h"
#include <signal.h>
#include <sys/wait.h>
X
/* 
X * Copyright 1992 Bruce. R. Ingram.
X * University of Kent at Canterbury, UK
X *
X * Permission  to   use, copy, modify  and  distribute  this  software  and its
X * documentation   for any purpose is hereby granted without fee, provided that
X * the   above  copyright  notice  appear  in  all  copies  and  that both that
X * copyright  notice   and  this   permission   notice  appear  in   supporting
X * documentation,  and  that  the name  of the author and The University  of
X * Kent  at  Canterbury  not be  used in advertising or publicity pertaining to
X * distribution  of  the  software  without specific, written prior permission.
X * The   author  and   The   University   of   Kent at   Canterbury   make  no
X * representations  about  the  suitability  of this  software for any purpose.
X * It is provided "as is" without express or implied warranty.
X *
X * THE   AUTHOR  AND  THE  UNIVERSITY  OF KENT  AT   CANTERBURY  DISCLAIMS ALL
X * WARRANTIES  WITH  REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED  WARRANTIES
X * OF   MERCHANTABILITY  AND  FITNESS,  IN NO  EVENT  SHALL THE AUTHOR  OR THE
X * UNIVERSITY  OF KENT  AT  CANTERBURY  BE LIABLE FOR ANY SPECIAL, INDIRECT  OR
X * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS  OF USE,
X * DATA  OR  PROFITS,  WHETHER  IN  AN ACTION OF CONTRACT, NEGLIGENCE  OR OTHER
X * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
X * OF THIS SOFTWARE.
X *
X * Author:
X *
X * Mr  B. R. Ingram email bri@ukc.ac.uk
*/
X
extern	XtAppContext	app_context;
X
static void 	catch_child();
static void	ResetButton PROTO((XtPointer,XtIntervalId));
extern  int     CreateButtons PROTO((Info *));
extern  void    PositionButtons PROTO((int,int)), ManageButtons();
X
extern void 
Quit(widget, client_data,call_data)
Widget          widget;
XXtPointer       client_data;
XXtPointer       call_data;
{
X	/* exit graciously */
X	XtDestroyWidget(toplevel);
X        exit(0);
}
X
X
extern void 
MultiAction(widget,client_data,call_data)
Widget          widget;
XXtPointer       client_data;
XXtPointer       call_data;
{
X	char	*command = (char*) client_data;
X	int	pid;
X	static	bool_t first_time = TRUE;
X	char	*exec_command;	/* for "exec " + command */
X
#define PREPEND "exec "
X
X        if (first_time) 
X	{
X        	first_time = FALSE;
X		if ((int) signal(SIGCHLD, catch_child) == -1) 
X		{
X			(void) fprintf(stderr,"unable to install child catcher");
X			exit(1);
X		}
X	}
X
X	switch(pid = fork())
X	{
X		case -1:
X			(void) fprintf(stderr,"ERROR: Process cannot fork\n");
X			(void) fprintf(stderr,"Sorry unable to execute command\n");
X			break;
X		case 0:
X			/* child */
X			exec_command = malloc((unsigned) sizeof(PREPEND) +
X				strlen(command) + 1);
X			if(exec_command == NULL)
X			{
X				(void) fprintf(stderr,"ERROR: out of memory\n");
X				exit(1);
X			}
X			strcpy(exec_command,PREPEND);
X			strcat(exec_command,command);
X			execlp("/bin/sh","sh","-c",exec_command,(char *) 0);
X			exit(127);
X			break;
X	}
}
X
X
extern void 
SingleAction(widget,client_data,call_data)
Widget          widget;
XXtPointer       client_data;
XXtPointer       call_data;
{
X	char	*command = (char*) client_data;
X	int	pid;
X	int	i = 0;
X	static	bool_t first_time = TRUE;
X	char	*exec_command;	/* for "exec " + command */
X
#define PREPEND "exec "
X
/*
X	This section of code was taken from xalias written by Godfrey Paul
X        First time only, arrange for SIGCHLD to be called.
*/
X        if (first_time) 
X	{
X        	first_time = FALSE;
X		if ((int) signal(SIGCHLD, catch_child) == -1) 
X		{
X			(void) fprintf(stderr,"unable to install child catcher");
X			exit(1);
X		}
X	}
X
X	switch(pid = fork())
X	{
X		case -1:
X			(void) fprintf(stderr,"ERROR: Process cannot fork\n");
X			(void) fprintf(stderr,"Sorry unable to execute command\n");
X			break;
X		case 0:
X			/* child */
X			exec_command = malloc((unsigned) sizeof(PREPEND) +
X				strlen(command) + 1);
X			if(exec_command == NULL)
X			{
X				(void) fprintf(stderr,"ERROR: out of memory\n");
X				exit(1);
X			}
X			strcpy(exec_command,PREPEND);
X			strcat(exec_command,command);
X			execlp("/bin/sh","sh","-c",exec_command,(char *) 0);
X			exit(127);
X			break;
X	}
X	while((ci_ptr[i].child_id != 0) && (i < MAXPROCS))
X			i++;
X	if(i < MAXPROCS)
X	{
X		ci_ptr[i].child_id = pid;
X		ci_ptr[i].w_id = widget;
X		XtSetSensitive(widget,False);
X	}
X	else
X		(void) printf("\nWarning: unable to deactivate selected button\n");
X
}
X
X
/*
X	This section of code was taken from xalias written by Godfrey Paul
*/
static void
catch_child()
{
X        int     	pid;
X	int		i = 0;
X        union wait      status;
X
X
X        /*
X         * wait3() returns -1 if the are no children left, or 0
X         * if there are no exited children.
X         */
X        while ((pid = wait3(&status, WNOHANG, (struct rusage *) NULL)) > 0)
X	{
X
X		while((ci_ptr[i].child_id != pid) && (i < MAXPROCS))
X				i++;
X		if(ci_ptr[i].child_id == pid)
X		{
X			XtAppAddTimeOut(app_context,50,ResetButton,pid);
X		}
X	}
X        return;
}
X
extern void
Source(widget,client_data,call_data)
Widget          widget;
XXtPointer       client_data;
XXtPointer       call_data;
{
X	Info    *data = (Info*) client_data;
X
X	int		x = 0;
X	WidgetList	w_list;
X	Cardinal	num_childern, i;
X	if(data->no_of_buttons >= 0)
X	{
X		while(x < MAXPROCS)
X		{
X			ci_ptr[x].child_id = 0;
X			ci_ptr[x].w_id = NULL;
X			x++;
X		}
X		XtUnmanageChild(box);
X		XtVaGetValues(
X			box,
X			XtNchildren,
X			&w_list,
X			XtNnumChildren,
X			&num_childern,
X			NULL);
X
X		for(i = 0; i < num_childern; i++)
X		{
X			XtDestroyWidget(w_list[i]);
X		}
X		data->no_of_buttons = 0;
X		data->no_of_buttons = CreateButtons(data);
X		PositionButtons(data->no_of_buttons,data->no_of_columns);
X		ManageButtons();
X		XtManageChild(box);
X	}
}
X
static void
ResetButton(client_data,id)
XXtPointer       client_data;
XXtIntervalId	*id;
{
X	int	c_pid = (int) client_data;
X	int	i = 0;
X	while((ci_ptr[i].child_id != c_pid) && (i < MAXPROCS))
X			i++;
X	if(ci_ptr[i].child_id == c_pid)
X	{
X		XtSetSensitive(ci_ptr[i].w_id,True);
X		ci_ptr[i].child_id = 0;
X	}
}
SHAR_EOF
chmod 0644 action.c ||
echo 'restore of action.c failed'
Wc_c="`wc -c < 'action.c'`"
test 6041 -eq "$Wc_c" ||
	echo 'action.c: original size 6041, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bitmaps/calander ==============
if test ! -d 'bitmaps'; then
    echo 'x - creating directory bitmaps'
    mkdir 'bitmaps'
fi
if test -f 'bitmaps/calander' -a X"$1" != X"-c"; then
	echo 'x - skipping bitmaps/calander (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bitmaps/calander (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bitmaps/calander' &&
#define cal_width 48
#define cal_height 48
static char cal_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x07, 0xf8, 0x07, 0xfc, 0x01,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa8, 0x2a, 0x54, 0x15, 0xaa, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa8, 0x2a, 0x54, 0x15, 0xaa, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa8, 0x2a, 0x54, 0x15, 0xaa, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa8, 0x2a, 0x54, 0x15, 0xaa, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa8, 0x2a, 0x54, 0x01, 0xaa, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x07, 0xf8, 0x07, 0xfc, 0x01,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa8, 0x2a, 0x54, 0x15, 0xaa, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa8, 0x2a, 0x54, 0x15, 0xaa, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa8, 0x2a, 0x54, 0x15, 0xaa, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa8, 0x2a, 0x54, 0x15, 0xaa, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa8, 0x2a, 0x54, 0x01, 0xaa, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x07, 0xf8, 0x07, 0xfc, 0x01,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa8, 0x2a, 0x54, 0x15, 0xaa, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa8, 0x2a, 0x54, 0x15, 0xaa, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa8, 0x2a, 0x54, 0x15, 0xaa, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa8, 0x2a, 0x54, 0x15, 0xaa, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0xa8, 0x2a, 0x54, 0x01, 0xaa, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 bitmaps/calander ||
echo 'restore of bitmaps/calander failed'
Wc_c="`wc -c < 'bitmaps/calander'`"
test 1871 -eq "$Wc_c" ||
	echo 'bitmaps/calander: original size 1871, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bitmaps/letters ==============
if test -f 'bitmaps/letters' -a X"$1" != X"-c"; then
	echo 'x - skipping bitmaps/letters (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bitmaps/letters (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bitmaps/letters' &&
#define letters_width 48
#define letters_height 48
static char letters_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0xfe, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x02, 0x00, 0x00, 0x00, 0x20,
X   0x00, 0xfa, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x02, 0x00, 0x00, 0x00, 0x2a,
X   0x00, 0x3a, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x02, 0x00, 0x00, 0x00, 0x2e,
X   0xe0, 0xff, 0xff, 0xff, 0xff, 0x21, 0x20, 0x00, 0x00, 0x00, 0x00, 0x21,
X   0xa0, 0x03, 0x00, 0x00, 0x70, 0x21, 0x20, 0x00, 0x00, 0x00, 0x50, 0x21,
X   0xa0, 0x1f, 0x00, 0x00, 0x50, 0x21, 0x20, 0x00, 0x00, 0x00, 0x70, 0x21,
X   0xfe, 0xff, 0xff, 0xff, 0x0f, 0x21, 0x02, 0x00, 0x00, 0x00, 0x08, 0x21,
X   0xfa, 0x01, 0x00, 0x80, 0x0b, 0x21, 0x02, 0x00, 0x00, 0x80, 0x0a, 0x21,
X   0xba, 0x01, 0x00, 0x80, 0x0a, 0x21, 0x02, 0x00, 0x00, 0x80, 0x0b, 0x21,
X   0x3a, 0x00, 0x00, 0x00, 0x08, 0x21, 0x02, 0x00, 0x00, 0x00, 0x08, 0x21,
X   0x02, 0xc0, 0xfb, 0x03, 0x08, 0x21, 0x02, 0x00, 0x00, 0x00, 0x08, 0x3f,
X   0x02, 0xc0, 0xbd, 0x0f, 0x08, 0x01, 0x02, 0x00, 0x00, 0x00, 0x08, 0x01,
X   0x02, 0xc0, 0x7f, 0x7b, 0x08, 0x01, 0x02, 0x00, 0x00, 0x00, 0x08, 0x01,
X   0x02, 0x00, 0x00, 0x00, 0xf8, 0x01, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00,
X   0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00,
X   0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00,
X   0xfe, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 bitmaps/letters ||
echo 'restore of bitmaps/letters failed'
Wc_c="`wc -c < 'bitmaps/letters'`"
test 1883 -eq "$Wc_c" ||
	echo 'bitmaps/letters: original size 1883, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bitmaps/games ==============
if test -f 'bitmaps/games' -a X"$1" != X"-c"; then
	echo 'x - skipping bitmaps/games (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bitmaps/games (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bitmaps/games' &&
#define dragon2.icon_width 50
#define dragon2.icon_height 48
#define dragon2.icon_x_hot 0
#define dragon2.icon_y_hot 0
static char dragon2.icon_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0xef, 0x01, 0x00,
X   0x00, 0x00, 0xe0, 0xc0, 0x10, 0x01, 0x00, 0x00, 0x00, 0x20, 0x41, 0x89,
X   0xe0, 0x01, 0x00, 0x00, 0xa0, 0xe2, 0x41, 0x1c, 0x03, 0x00, 0x00, 0x20,
X   0x1c, 0x61, 0x83, 0x02, 0x00, 0x00, 0x60, 0x00, 0xe0, 0x40, 0x00, 0x00,
X   0x00, 0xc0, 0x03, 0x34, 0x20, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x14, 0x40,
X   0x00, 0x00, 0x00, 0x00, 0x30, 0x36, 0x78, 0x00, 0x00, 0x00, 0x20, 0xc0,
X   0x61, 0x48, 0x00, 0x00, 0x00, 0x20, 0x87, 0x50, 0x10, 0x00, 0x00, 0x00,
X   0xb0, 0x58, 0x48, 0x1f, 0x00, 0x00, 0x00, 0x70, 0x30, 0x24, 0x11, 0x00,
X   0x00, 0x00, 0xf8, 0x60, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0xd6,
X   0x78, 0x00, 0x00, 0x00, 0x00, 0x88, 0x59, 0x86, 0x00, 0x00, 0x00, 0x00,
X   0x04, 0xf3, 0x01, 0x01, 0x00, 0x00, 0x00, 0x42, 0x06, 0x00, 0x02, 0x00,
X   0x00, 0x70, 0x49, 0x06, 0x00, 0x02, 0x00, 0x00, 0xf8, 0x4f, 0x8c, 0x03,
X   0x02, 0x00, 0x00, 0xe8, 0x40, 0x54, 0x00, 0x02, 0x00, 0x00, 0xa8, 0x23,
X   0x28, 0x00, 0x01, 0x00, 0x00, 0xa8, 0x1c, 0xd0, 0x83, 0x07, 0x00, 0x00,
X   0x80, 0x00, 0x20, 0x7c, 0x04, 0x00, 0x00, 0x80, 0x00, 0xc3, 0x01, 0x04,
X   0x00, 0x00, 0xc0, 0x81, 0x7c, 0x06, 0x04, 0x00, 0x00, 0x20, 0x42, 0x01,
X   0x38, 0x02, 0x00, 0x00, 0xd0, 0x4e, 0x15, 0xc0, 0x01, 0x00, 0x00, 0xf8,
X   0xf3, 0xef, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0xc0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x06,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x6a, 0x9c, 0x01, 0x00, 0x00,
X   0x60, 0xd7, 0xfe, 0xd6, 0x00, 0x00, 0x00, 0x60, 0xe6, 0xd6, 0xde, 0x01,
X   0x00, 0x00, 0x60, 0x96, 0xd6, 0x86, 0x01, 0x00, 0x00, 0xc0, 0xf3, 0xd7,
X   0xdd, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 bitmaps/games ||
echo 'restore of bitmaps/games failed'
Wc_c="`wc -c < 'bitmaps/games'`"
test 2256 -eq "$Wc_c" ||
	echo 'bitmaps/games: original size 2256, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bitmaps/help ==============
if test -f 'bitmaps/help' -a X"$1" != X"-c"; then
	echo 'x - skipping bitmaps/help (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bitmaps/help (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bitmaps/help' &&
#define help2.icon_width 52
#define help2.icon_height 51
#define help2.icon_x_hot 0
#define help2.icon_y_hot 0
static char help2.icon_bits[] = {
X   0x00, 0x00, 0xe0, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0xc0, 0x03,
X   0x00, 0x00, 0x00, 0xc0, 0x01, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x70, 0x00,
X   0x00, 0x30, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00,
X   0x0e, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x80, 0x07,
X   0x00, 0x80, 0x3f, 0x80, 0x08, 0xc0, 0x0f, 0x00, 0xc0, 0x7f, 0x10, 0x22,
X   0xe1, 0x1f, 0x00, 0xe0, 0xff, 0x40, 0x55, 0xf2, 0x3f, 0x00, 0xf0, 0xff,
X   0xa9, 0xaa, 0xf8, 0x3f, 0x00, 0xf0, 0xff, 0x57, 0x55, 0xfd, 0x7f, 0x00,
X   0xc8, 0xff, 0xef, 0xbf, 0xfe, 0xff, 0x00, 0x88, 0xff, 0x3f, 0xe0, 0xff,
X   0x9f, 0x00, 0x0c, 0xff, 0x0f, 0x80, 0xff, 0x8f, 0x00, 0x04, 0xfe, 0x07,
X   0x00, 0xff, 0x07, 0x01, 0x04, 0xfc, 0x03, 0x00, 0xfe, 0x03, 0x01, 0x02,
X   0xf8, 0x01, 0x00, 0xfc, 0x01, 0x02, 0x02, 0xf4, 0x00, 0x00, 0xf8, 0x00,
X   0x02, 0x02, 0x68, 0x00, 0x00, 0x70, 0x01, 0x02, 0x02, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x01, 0x9c,
X   0xfb, 0x3b, 0xfc, 0x00, 0x04, 0x01, 0x08, 0x11, 0x12, 0x88, 0x01, 0x04,
X   0x01, 0x08, 0x11, 0x10, 0x08, 0x01, 0x04, 0x01, 0x08, 0x11, 0x11, 0x88,
X   0x01, 0x04, 0x01, 0xf8, 0xf1, 0x11, 0xf8, 0x00, 0x04, 0x01, 0x08, 0x11,
X   0x11, 0x08, 0x00, 0x04, 0x01, 0x08, 0x11, 0x10, 0x08, 0x00, 0x04, 0x01,
X   0x08, 0x11, 0x12, 0x09, 0x00, 0x04, 0x02, 0x9c, 0xfb, 0xfb, 0x1d, 0x00,
X   0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0xf8,
X   0x03, 0x00, 0xfe, 0x01, 0x01, 0x04, 0xfc, 0x07, 0x00, 0xff, 0x03, 0x01,
X   0x08, 0xfe, 0x0f, 0x80, 0xff, 0x87, 0x00, 0x08, 0xff, 0x3f, 0xe0, 0xff,
X   0x4f, 0x00, 0x98, 0xff, 0xef, 0x1f, 0xff, 0x5f, 0x00, 0xd0, 0xff, 0x07,
X   0x00, 0xfe, 0x3f, 0x00, 0xf0, 0xff, 0x03, 0x00, 0xfc, 0x3f, 0x00, 0xe0,
X   0xff, 0x01, 0x00, 0xf8, 0x1f, 0x00, 0xc0, 0xff, 0x00, 0x00, 0xf0, 0x1f,
X   0x00, 0x80, 0x7f, 0x00, 0x00, 0xe0, 0x07, 0x00, 0x00, 0x3f, 0x00, 0x00,
X   0xc0, 0x03, 0x00, 0x00, 0x1e, 0x01, 0x00, 0xd2, 0x00, 0x00, 0x00, 0x5c,
X   0x48, 0x84, 0x68, 0x00, 0x00, 0x00, 0x70, 0x15, 0x51, 0x15, 0x00, 0x00,
X   0x00, 0x80, 0xab, 0xaa, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x5c, 0xd5, 0x01,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 bitmaps/help ||
echo 'restore of bitmaps/help failed'
Wc_c="`wc -c < 'bitmaps/help'`"
test 2378 -eq "$Wc_c" ||
	echo 'bitmaps/help: original size 2378, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bitmaps/dclock ==============
if test -f 'bitmaps/dclock' -a X"$1" != X"-c"; then
	echo 'x - skipping bitmaps/dclock (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bitmaps/dclock (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bitmaps/dclock' &&
#define dclock_width 49
#define dclock_height 42
#define dclock_x_hot 0
#define dclock_y_hot 0
static char dclock_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x88,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x08, 0xa2, 0x06, 0x00, 0x00, 0x00, 0x00, 0x70, 0xa2, 0x09, 0x00,
X   0x00, 0x00, 0x00, 0x80, 0xa2, 0x08, 0x00, 0x00, 0x00, 0x00, 0x80, 0xa2,
X   0x08, 0x00, 0x00, 0x00, 0x00, 0x88, 0xb2, 0x08, 0x00, 0x00, 0x00, 0x00,
X   0x70, 0xac, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x80, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x0f, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0xc0, 0x1f, 0x00, 0x48, 0x10, 0x00, 0x00, 0x60, 0x18, 0x00,
X   0x6c, 0x18, 0x00, 0x00, 0x60, 0x18, 0x00, 0x6c, 0x18, 0x00, 0x00, 0x60,
X   0x18, 0x00, 0x6c, 0x18, 0x00, 0x00, 0x60, 0x98, 0x01, 0x6c, 0x18, 0x00,
X   0x00, 0x60, 0x98, 0x01, 0x6c, 0x18, 0x00, 0x00, 0x60, 0x98, 0x01, 0x6c,
X   0x18, 0x00, 0x00, 0xe0, 0x0f, 0x01, 0xe6, 0x0f, 0x00, 0x00, 0xe0, 0x07,
X   0x00, 0xe0, 0x07, 0x00, 0x00, 0xe0, 0x0f, 0x00, 0xc4, 0x0f, 0x00, 0x00,
X   0x30, 0x0c, 0x00, 0x06, 0x0c, 0x00, 0x00, 0x30, 0x0c, 0x00, 0x06, 0x0c,
X   0x00, 0x00, 0x30, 0x8c, 0x00, 0x06, 0x0c, 0x00, 0x00, 0x30, 0xcc, 0x00,
X   0x06, 0x0c, 0x00, 0x00, 0x30, 0xcc, 0x00, 0x06, 0x0c, 0x00, 0x00, 0x30,
X   0x8c, 0x00, 0x06, 0x0c, 0x00, 0x00, 0xf0, 0x07, 0x00, 0x02, 0x04, 0x00,
X   0x00, 0xe0, 0x07, 0x00, 0x02, 0x04, 0x00, 0x00, 0xe0, 0x03, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 bitmaps/dclock ||
echo 'restore of bitmaps/dclock failed'
Wc_c="`wc -c < 'bitmaps/dclock'`"
test 1965 -eq "$Wc_c" ||
	echo 'bitmaps/dclock: original size 1965, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bitmaps/dragon ==============
if test -f 'bitmaps/dragon' -a X"$1" != X"-c"; then
	echo 'x - skipping bitmaps/dragon (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bitmaps/dragon (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bitmaps/dragon' &&
#define dragon2.icon_width 50
#define dragon2.icon_height 48
#define dragon2.icon_x_hot 0
#define dragon2.icon_y_hot 0
static char dragon2.icon_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x0a, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0xef, 0x01, 0x00,
X   0x00, 0x00, 0xe0, 0xc0, 0x10, 0x01, 0x00, 0x00, 0x00, 0x20, 0x41, 0x89,
X   0xe0, 0x01, 0x00, 0x00, 0xa0, 0xe2, 0x41, 0x1c, 0x03, 0x00, 0x00, 0x20,
X   0x1c, 0x61, 0x83, 0x02, 0x00, 0x00, 0x60, 0x00, 0xe0, 0x40, 0x00, 0x00,
X   0x00, 0xc0, 0x03, 0x34, 0x20, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x14, 0x40,
X   0x00, 0x00, 0x00, 0x00, 0x30, 0x36, 0x78, 0x00, 0x00, 0x00, 0x20, 0xc0,
X   0x61, 0x48, 0x00, 0x00, 0x00, 0x20, 0x87, 0x50, 0x10, 0x00, 0x00, 0x00,
X   0xb0, 0x58, 0x48, 0x1f, 0x00, 0x00, 0x00, 0x70, 0x30, 0x24, 0x11, 0x00,
X   0x00, 0x00, 0xf8, 0x60, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd0, 0xd6,
X   0x78, 0x00, 0x00, 0x00, 0x00, 0x88, 0x59, 0x86, 0x00, 0x00, 0x00, 0x00,
X   0x04, 0xf3, 0x01, 0x01, 0x00, 0x00, 0x00, 0x42, 0x06, 0x00, 0x02, 0x00,
X   0x00, 0x70, 0x49, 0x06, 0x00, 0x02, 0x00, 0x00, 0xf8, 0x4f, 0x8c, 0x03,
X   0x02, 0x00, 0x00, 0xe8, 0x40, 0x54, 0x00, 0x02, 0x00, 0x00, 0xa8, 0x23,
X   0x28, 0x00, 0x01, 0x00, 0x00, 0xa8, 0x1c, 0xd0, 0x83, 0x07, 0x00, 0x00,
X   0x80, 0x00, 0x20, 0x7c, 0x04, 0x00, 0x00, 0x80, 0x00, 0xc3, 0x01, 0x04,
X   0x00, 0x00, 0xc0, 0x81, 0x7c, 0x06, 0x04, 0x00, 0x00, 0x20, 0x42, 0x01,
X   0x38, 0x02, 0x00, 0x00, 0xd0, 0x4e, 0x15, 0xc0, 0x01, 0x00, 0x00, 0xf8,
X   0xf3, 0xef, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0xc0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x06,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x6a, 0x9c, 0x01, 0x00, 0x00,
X   0x60, 0xd7, 0xfe, 0xd6, 0x00, 0x00, 0x00, 0x60, 0xe6, 0xd6, 0xde, 0x01,
X   0x00, 0x00, 0x60, 0x96, 0xd6, 0x86, 0x01, 0x00, 0x00, 0xc0, 0xf3, 0xd7,
X   0xdd, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 bitmaps/dragon ||
echo 'restore of bitmaps/dragon failed'
Wc_c="`wc -c < 'bitmaps/dragon'`"
test 2256 -eq "$Wc_c" ||
	echo 'bitmaps/dragon: original size 2256, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bitmaps/readNews ==============
if test -f 'bitmaps/readNews' -a X"$1" != X"-c"; then
	echo 'x - skipping bitmaps/readNews (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bitmaps/readNews (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bitmaps/readNews' &&
#define unnamed_width 41
#define unnamed_height 43
#define unnamed_x_hot 0
#define unnamed_y_hot 0
static char unnamed_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfa,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x30, 0x00, 0x00, 0x00, 0xfa,
X   0x00, 0xf0, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x30, 0x03, 0x00, 0x00, 0xfa,
X   0x00, 0x18, 0x03, 0x00, 0x00, 0xfa, 0x00, 0x18, 0x03, 0x00, 0x00, 0xfe,
X   0x00, 0xfc, 0x01, 0x00, 0x00, 0xfa, 0x00, 0x6c, 0x00, 0x00, 0x00, 0xfa,
X   0x00, 0x67, 0x6c, 0x00, 0x00, 0xbe, 0x00, 0xcc, 0x4c, 0x00, 0x00, 0xba,
X   0x00, 0xc0, 0x7e, 0x04, 0x00, 0xba, 0x00, 0xc0, 0x66, 0x1a, 0x00, 0xba,
X   0x00, 0x00, 0x06, 0x10, 0x18, 0xba, 0x00, 0x00, 0xb8, 0x1f, 0x19, 0xba,
X   0x00, 0x00, 0x80, 0xd9, 0x0e, 0xba, 0x80, 0x01, 0x80, 0xcd, 0x0c, 0xba,
X   0xc0, 0x01, 0x00, 0x6a, 0x06, 0xbe, 0xc0, 0x11, 0x00, 0x68, 0x06, 0xbe,
X   0xa0, 0x31, 0x00, 0x60, 0x03, 0xba, 0x20, 0x11, 0x00, 0x80, 0x02, 0xba,
X   0x90, 0x09, 0x00, 0x00, 0x02, 0xba, 0x10, 0x0b, 0x00, 0x00, 0x00, 0xbe,
X   0x18, 0xb7, 0x01, 0x00, 0x00, 0xba, 0x00, 0x36, 0x01, 0x00, 0x00, 0xbe,
X   0x00, 0xfa, 0x19, 0x00, 0x00, 0xba, 0x00, 0x9a, 0x6d, 0x00, 0x00, 0xba,
X   0x00, 0x18, 0xd8, 0x00, 0x00, 0xbe, 0x00, 0xe0, 0x6c, 0x03, 0x00, 0xba,
X   0x00, 0x00, 0x7c, 0x09, 0x00, 0xe0, 0x00, 0x00, 0x6c, 0x36, 0x00, 0xe0,
X   0x00, 0x00, 0x60, 0x2c, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x0c, 0x00, 0xe0,
X   0x00, 0x00, 0x00, 0x0d, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x0f, 0x00, 0xe0,
X   0x00, 0x00, 0x00, 0x04, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0,
X   0x00, 0x00, 0x00, 0x00, 0x00, 0xa0,  };
SHAR_EOF
chmod 0644 bitmaps/readNews ||
echo 'restore of bitmaps/readNews failed'
Wc_c="`wc -c < 'bitmaps/readNews'`"
test 1748 -eq "$Wc_c" ||
	echo 'bitmaps/readNews: original size 1748, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bitmaps/load ==============
if test -f 'bitmaps/load' -a X"$1" != X"-c"; then
	echo 'x - skipping bitmaps/load (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bitmaps/load (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bitmaps/load' &&
#define load_width 32
#define load_height 32
static char load_bits[] = {
X   0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0x02, 0x00, 0x00, 0x40,
X   0x02, 0x00, 0x00, 0x40, 0x02, 0x00, 0x00, 0x40, 0x02, 0x04, 0x00, 0x40,
X   0x02, 0x0e, 0x00, 0x40, 0x02, 0x0e, 0x00, 0x40, 0x02, 0x0f, 0x00, 0x40,
X   0x02, 0x1f, 0x00, 0x40, 0x02, 0x1f, 0x00, 0x40, 0xfe, 0xff, 0xff, 0x7f,
X   0x02, 0x1f, 0x00, 0x40, 0x02, 0x1f, 0x00, 0x40, 0x92, 0x3f, 0x00, 0x40,
X   0xb2, 0x3f, 0x00, 0x40, 0xf2, 0x3f, 0x00, 0x40, 0xfa, 0x7f, 0x00, 0x40,
X   0xfa, 0x7f, 0x00, 0x40, 0xfa, 0xff, 0x00, 0x40, 0xfe, 0xff, 0x00, 0x40,
X   0xfe, 0xff, 0x01, 0x40, 0xfe, 0xff, 0x09, 0x40, 0xfe, 0xff, 0x2d, 0x62,
X   0xfe, 0xff, 0x7f, 0x73, 0xfe, 0xff, 0x7f, 0x77, 0xfe, 0xff, 0xff, 0x7f,
X   0xfe, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x7f, 0xfe, 0xff, 0xff, 0x7f,
X   0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00};
SHAR_EOF
chmod 0644 bitmaps/load ||
echo 'restore of bitmaps/load failed'
Wc_c="`wc -c < 'bitmaps/load'`"
test 875 -eq "$Wc_c" ||
	echo 'bitmaps/load: original size 875, current size' "$Wc_c"
rm -f _shar_wnt_.tmp
fi
# ============= bricons.l ==============
if test -f 'bricons.l' -a X"$1" != X"-c"; then
	echo 'x - skipping bricons.l (File already exists)'
	rm -f _shar_wnt_.tmp
else
> _shar_wnt_.tmp
echo 'x - extracting bricons.l (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'bricons.l' &&
.\" static char* sccs_bricons_c = "%W%%G%";
.\"  bricons.l  B. Ingram version 1.0 24th June 1991
.TH BRICONS l "28th March 1992"
.SH NAME
bricons \- quick start up utility for applications using text, icons and pop-up
menus
an X display
.SH SYNOPSIS
.B bricons
\ [options]
.br
[\fB\-file\fP] [\fB\-col\fP] [\fB\-help\fP] [\fB\-sensitive\fP]
.br
.SH DESCRIPTION
.LP
Bricons program allows the user to quickly start up applications
by selecting the appropriate button from the display and pressing the left 
mouse button.  A maximum of up to sixteen main menu buttons can be displayed.  
Each main menu button can launch an application or pop-up a sub menu containing 
more buttons. The buttons can be represented as a bitmap or as text.
.LP
Information on how the program is to present each button (either as a bitmap 
or text) and the application that is to be executed if that button is selected 
is contained in script file called .briconsrc.  This file should be stored in 
the user's home directory.
.LP
The \&.briconsrc file contains a number of key words which are used to
indicate if the button label is some text or a bitmap and if the button is to
pop-up a sub menu or launch a program.  These key words are explained below:
.LP
The .briconsrc file should start with the keyword
.B %icon
or
.B %text
The key word %icon indicates that the button label is a bitmap.  This should be
followed by the file name containing the bitmap.  For example:
.sp
.ce
%icon clock.icon
.LP
The key word %text indicates that the button label is some text.  The text can
be split over three lines by using the new line character \\n.  For 
example:
.sp
.ce
%text Line1\\nLine2\\nLine3
.LP
would be presented as:
.ce 3
Line1
Line2
Line3
.LP
Once a button has been selected it is prevented from accidentally being 
re-selected by "graying out" the button (default action).  Sometimes however 
it maybe desirable to allow the button to be selected more than once.  This
can be done be using the keyword
.B %icon+
or 
.B %text+
.LP
The next line in the \&.briconsrc file should either contain the key word
%sub_menu or the application to be started.  If the name of an 
application  is given then a check is made to see if such an program can be 
executed.  If the program does not exist or is not in the users path then an 
error message is printed and the button associated with the application is 
ignored.
.LP
If the key word %sub_menu is used then a pop-up sub menu is created.  Any
further buttons defined in the briconsrc file will appear in the sub menu for
that button until the key word %end_sub_menu is found.  A maximum of
ten buttons are allowed in a single pop-up sub menu.
.LP
Any line in the \&.briconsrc file starting with a # character is 
treated as a comment and will be ignored.  
.LP
This program has four default buttons labelled source, edit, help and quit.
The edit button allows the user to edit there icon file (default being an empty
./briconsrc file) and to add or delete buttons from the script file.  The 
source button causes the program to distory all the current buttons being 
displayed and re-read the icon file and display the new buttons.
.SH OPTIONS
.LP
bricons accepts all of the standard X  Toolkit  command  line options along 
with the additional options listed below:
.TP
-file
Tells the program to read this file instead of the default file.
.TP
-col
Indicates the number of buttons in a column before starting a new row.  The 
default number of columns is 15.
.TP
-help
Tells the program the path for the help file.
.TP
-sensitive
Toggle used for default "graying out" of selected buttons.  If set to TRUE 
then buttons will "gray out" unless specifically requested not to.
.SH X DEFAULTS
.LP
The bricons program reads the .Xdefaults file and Xbricons resource file
during startup and uses the appropriate resource specification to
customise the appearance or characteristics of its display.  This program 
understands all of the core resource names and classes as well as:
.TP
no_of_cols
Specifies the number of buttons in a column.
.TP
icon_file
Specifies path name for icon file to be read.
.TP
help_file
Specifies path name for help file.
.SH "SETTING BITMAP DIRECTORIES"
.LP
This program will search the default bitmap directory for any bitmaps that
are to be used to represent buttons. If the user wishes the program to
search other directories for bitmap files then this should be specified in
the users .X11defaults file.  *BitmapFilePath: should be added followed by
colon separated path names where the bitmap files can be found.  For example:
.sp
.ce
*BitmapFilePath:	/usr/local/include/X11/bitmaps:/usr/mydir/bitmaps
SHAR_EOF
true || echo 'restore of bricons.l failed'
fi
echo 'End of  part 1'
echo 'File bricons.l is continued in part 2'
echo 2 > _shar_seq_.tmp
exit 0
-- 
--
Molecular Simulations, Inc.			mail: dcmartin@msi.com
796 N. Pastoria Avenue				uucp: uunet!dcmartin
Sunnyvale, California 94086			at&t: 408/522-9236
