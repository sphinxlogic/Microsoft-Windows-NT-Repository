Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i024:  xpilot - Multiplayer gravity war game hand-shake program, Part22/24
Message-ID: <3319@master.CNA.TEK.COM>
Date: 4 Aug 92 19:31:58 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2396
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Bjoern Stabell <bjoerns@staff.cs.uit.no>
Posting-number: Volume 14, Issue 24
Archive-name: xpilot/Part22
Environment: X11, ANSI C



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 22 (of 24)."
# Contents:  fonts/map-5.bdf maps/README maps/doggy.uue
#   src/cmdline.c src/dbuff.h src/lib/socklib.h src/player.c
#   src/robot.c
# Wrapped by billr@saab on Tue Aug  4 10:38:59 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'fonts/map-5.bdf' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'fonts/map-5.bdf'\"
else
echo shar: Extracting \"'fonts/map-5.bdf'\" \(3350 characters\)
sed "s/^X//" >'fonts/map-5.bdf' <<'END_OF_FILE'
XSTARTFONT 2.1
XCOMMENT This is a custom-made font for the xpilot game
XFONT map-5
XSIZE 1 1 1
XFONTBOUNDINGBOX 5 5 0 0
XSTARTPROPERTIES 3
XFONT_ASCENT 5
XFONT_DESCENT 0
XDEFAULT_CHAR 36
XENDPROPERTIES 
XCHARS 29
XSTARTCHAR Others
XENCODING 36
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0
XBITMAP 
X88
X50
X20
X50
X88
XENDCHAR
XSTARTCHAR PosGrav
XENCODING 43
XSWIDTH 350 0
XDWIDTH 5 0
XBBX 5 5 0 0
XBITMAP 
X20
X20
XF8
X20
X20
XENDCHAR
XSTARTCHAR NegGrav 
XENCODING 45
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0
XBITMAP 
X00
X00
XF8
X00
X00
XENDCHAR
XSTARTCHAR Slash
XENCODING 47
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0
XBITMAP 
X08
X10
X20
X40
X80
XENDCHAR
XSTARTCHAR Dot
XENCODING 46
XSWIDTH 350 0
XDWIDTH 5 0
XBBX 5 5 0 0
XBITMAP
X00
X00
X00
X18
X18
XENDCHAR
XSTARTCHAR Upperleft 
XENCODING 113 
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0
XBITMAP 
X08
X18
X38
X78
XF8
XENDCHAR 
XSTARTCHAR Upperright 
XENCODING 119 
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0 
XBITMAP 
X80
XC0
XE0
XF0
XF8
XENDCHAR 
XSTARTCHAR Lowerleft 
XENCODING 97 
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0 
XBITMAP 
XF8
X78
X38
X18
X08
XENDCHAR 
XSTARTCHAR Lowerright 
XENCODING 115 
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0 
XBITMAP 
XF8
XF0
XE0
XC0
X80
XENDCHAR 
XSTARTCHAR Upcannon 
XENCODING 114
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0 
XBITMAP 
X00
X00
X20
X50
X88
XENDCHAR
XSTARTCHAR Downcannon 
XENCODING 99 
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0
XBITMAP 
X88
X50
X20
X00
X00
XENDCHAR 
XSTARTCHAR Rightcannon 
XENCODING 102 
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0 
XBITMAP 
X80
X40
X20
X40
X80
XENDCHAR 
XSTARTCHAR Leftcannon 
XENCODING 100 
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0 
XBITMAP
X08
X10
X20
X10
X08
XENDCHAR 
XSTARTCHAR Square 
XENCODING 120 
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0 
XBITMAP 
XF8
XF8
XF8
XF8
XF8
XENDCHAR 
XSTARTCHAR Homebase 
XENCODING 42
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0 
XBITMAP 
X20
X20
XA8
X70
X20
XENDCHAR
XSTARTCHAR Fuel 
XENCODING 70 
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0 
XBITMAP 
XF8
X88
X88
X88
XF8
XENDCHAR 
XSTARTCHAR Open 
XENCODING 32 
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0 
XBITMAP 
X00
X00
X20
X00
X00
XENDCHAR
XSTARTCHAR Postnil
XENCODING 48
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0
XBITMAP
X20
X50
X88
X50
X20
XENDCHAR
XSTARTCHAR Postone
XENCODING 49
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0
XBITMAP
X20
X50
X88
X50
X20
XENDCHAR
XSTARTCHAR Posttwo
XENCODING 50
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0
XBITMAP
X20
X50
X88
X50
X20
XENDCHAR
XSTARTCHAR Postthree
XENCODING 51
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0
XBITMAP
X20
X50
X88
X50
X20
XENDCHAR
XSTARTCHAR Postfour
XENCODING 52
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0
XBITMAP
X20
X50
X88
X50
X20
XENDCHAR
XSTARTCHAR Postfive
XENCODING 53
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0
XBITMAP
X20
X50
X88
X50
X20
XENDCHAR
XSTARTCHAR Postsix
XENCODING 54
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0
XBITMAP
X20
X50
X88
X50
X20
XENDCHAR
XSTARTCHAR Postseven
XENCODING 55
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0
XBITMAP
X20
X50
X88
X50
X20
XENDCHAR
XSTARTCHAR Posteight
XENCODING 56
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0
XBITMAP
X20
X50
X88
X50
X20
XENDCHAR
XSTARTCHAR Postnine
XENCODING 57
XSWIDTH 350 0 
XDWIDTH 5 0 
XBBX 5 5 0 0
XBITMAP
X20
X50
X88
X50
X20
XENDCHAR
XSTARTCHAR counterclockwise
XCOMMENT a curling forcefield with a counterclockwise curl
XCOMMENT typed as '<' represented by a curling arrow
XENCODING 60
XSWIDTH 350 0
XDWIDTH 5 0
XBBX 5 5 0 0
XBITMAP
X40
XF0
X48
X08
X10
XENDCHAR
XSTARTCHAR clockwise
XCOMMENT a curling forcefield with a clockwise curl
XCOMMENT typed as '>' represented by a curling arrow 
XENCODING 62
XSWIDTH 350 0
XDWIDTH 5 0
XBBX 5 5 0 0
XBITMAP
X10
X78
X90
X80
X40
XENDCHAR
XENDFONT
END_OF_FILE
if test 3350 -ne `wc -c <'fonts/map-5.bdf'`; then
    echo shar: \"'fonts/map-5.bdf'\" unpacked with wrong size!
fi
# end of 'fonts/map-5.bdf'
fi
if test -f 'maps/README' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'maps/README'\"
else
echo shar: Extracting \"'maps/README'\" \(160 characters\)
sed "s/^X//" >'maps/README' <<'END_OF_FILE'
XThe xpilots program will probably not find these maps automatically (if you
Xhaven't specified the correct MAPDIR), so you will have to specify the
Xwhole path.
X
END_OF_FILE
if test 160 -ne `wc -c <'maps/README'`; then
    echo shar: \"'maps/README'\" unpacked with wrong size!
fi
# end of 'maps/README'
fi
if test -f 'maps/doggy.uue' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'maps/doggy.uue'\"
else
echo shar: Extracting \"'maps/doggy.uue'\" \(3524 characters\)
sed "s/^X//" >'maps/doggy.uue' <<'END_OF_FILE'
Xbegin 644 doggy.map
XM-#EX-3`*-`I$;V=G>5-T>6QE"DMJ96QL($ER9V5N<PIX>'AX>'AX>'AX>'AX
XM>'AX>'AX>'AX>'AX>'AX>'AX>'AX>'AX>'AX>'AX>'AX>'AX"G@N+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+G@*>"XN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM>`IX+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BYX"G@N+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+G@*>"XN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN>`IX+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BYX"G@N+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+G@*>"XN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN>`IX+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BYX"G@N+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+G@*>"XN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM>`IX+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BYX"G@N+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+G@*>"XN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN>`IX+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BYX"G@N+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+G@*>"XN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN>`IX+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BYX"G@N+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+G@*>"XN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM>`IX+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BYX"G@N+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+G@*>"XN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN>`IX+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BYX"G@N+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+G@*>"XN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN>`IX+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BYX"G@N+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+G@*>"XN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM>`IX+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BYX"G@N+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+G@*>"XN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN>`IX+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BYX"G@N+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+G@*>"XN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN>`IX+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BYX"G@N+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+G@*>"XN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM>`IX+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BYX"G@N+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+G@*>"XN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN>`IX+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BYX"G@N+BXN+BXN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+G@*>"XN+BXN+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN>`IX+BXN+BXN+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BYX"G@N+BXN+BXN
XM+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+BXN+G@*>"XN
XM<BXN+G(N+BYR+BXN<BXN+G(N+G(N+BYR+BXN<BXN+G(N+BYR+BXN<BXN+G(N
XM>`IX+BI&*BXJ1BHN*D8J+BI&*BXJ1BXJ1BHN*D8J+BI&*BXJ1BHN*D8J+BI&
XM*BXJ1BIX"GAX>'AX>'AX>'AX>'AX>'AX>'AX>'AX>'AX>'AX>'AX>'AX>'AX
X1>'AX>'AX>'AX>'@*"@H*"@IX
X`
Xend
END_OF_FILE
if test 3524 -ne `wc -c <'maps/doggy.uue'`; then
    echo shar: \"'maps/doggy.uue'\" unpacked with wrong size!
fi
# end of 'maps/doggy.uue'
fi
if test -f 'src/cmdline.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/cmdline.c'\"
else
echo shar: Extracting \"'src/cmdline.c'\" \(3323 characters\)
sed "s/^X//" >'src/cmdline.c' <<'END_OF_FILE'
X/* $Id: cmdline.c,v 1.6 1992/07/10 23:19:56 bjoerns Exp $
X *
X *	This file is part of the XPilot project, written by
X *
X *	    Bjxrn Stabell (bjoerns@stud.cs.uit.no)
X *	    Ken Ronny Schouten (kenrsc@stud.cs.uit.no)
X *
X *	Copylefts are explained in the LICENSE file.
X */
X
X#include <stdlib.h>
X#include "global.h"
X#include "robot.h"
X#include "map.h"
X
X#ifndef	lint
Xstatic char sourceid[] =
X    "@(#)$Id: cmdline.c,v 1.6 1992/07/10 23:19:56 bjoerns Exp $";
X#endif
X
Xdouble		Gravity = -0.14;	/* Power of gravity */
Xdouble		ShipMass = 20.0;	/* Default mass of ship */
Xdouble		ShotsMass = 0.1;	/* Default mass of shots */
Xdouble		ShotsSpeed = 21.0;	/* Default speed of shots */
Xint		ShotsLife = 90;		/* Default number of ticks */
X					/* each shot will live */
Xint		WantedNumRobots = -1;	/* How many robots should enter */
X					/* the game? */
Xint		ShotsMax = 256;		/* Max shots pr. player */
Xbool		ShotsGravity = true;	/* Shots affected by gravity */
Xbool		LooseMass = false;	/* Loose mass when firering */
X
Xbool		RawMode = false;	/* Let robots live even if there */
X					/* are no players logged in */
Xbool		NoQuit = false;		/* Don't quit even if there are */
X					/* no human players playing */
X
X
Xvoid Parser(int argc, char *argv[])
X{
X    int i;
X    bool map_loaded = false;
X
X
X    for (i=1; i<argc; i++) {
X
X	if (strncmp("-help", argv[i], 2) == 0) {
X	    printf("Usage:	%s [-options ..]\n\n"
X		   "Where options include:\n"
X		   "	-help			print out this message\n"
X		   "	-version		print out current version\n"
X		   "	-map <file>		use alternative map\n"
X		   "	-gravity <real>		sets gravity power\n"
X		   "	-shots <int>		new maximum shot limit\n"
X		   "	-shotspeed <real>	default speed of shots\n"
X		   "	-shotmass <real>	mass of players' shots\n"
X		   "	-shotlife <ticks>	how long shots should last\n"
X		   "	-shipmass <real>	mass of players' ship\n"
X		   "	-rawmode		don't sleep if there are "
X		   "only robots left\n"
X		   "	-noquit			don't quit if there are only "
X		   "robots left\n"
X		   "	-robots <int>		number of robots\n",
X		   argv[0]);
X	    exit(0);
X	}
X
X	if (strncmp("-version", argv[i], 2) == 0) {
X	    puts(TITLE);
X	    exit(0);
X	}
X
X	if (strcmp("-robots", argv[i]) == 0) {
X	    WantedNumRobots = atoi(argv[++i]);
X	    if (WantedNumRobots < 0)
X		WantedNumRobots = INT_MAX;
X	    continue;
X	}
X
X	if (strcmp("-rawmode", argv[i]) == 0) {
X	    RawMode = true;
X	    continue;
X	}
X
X	if (strcmp("-noquit", argv[i]) == 0) {
X	    NoQuit = true;
X	    continue;
X	}
X
X	if (strcmp("-map", argv[i]) == 0) {
X	    Load_map(argv[++i]);
X	    map_loaded = true;
X	    continue;
X	}
X
X	if (strcmp("-gravity", argv[i]) == 0) {
X	    Gravity = atof(argv[++i]);
X	    continue;
X	}
X
X	if (strcmp("-shots", argv[i]) == 0) {
X	    ShotsMax = atoi(argv[++i]);
X	    continue;
X	}
X
X	if (strcmp("-shotmass", argv[i]) == 0) {
X	    ShotsMass = atof(argv[++i]);
X	    continue;
X	}
X
X	if (strcmp("-shipmass", argv[i]) == 0) {
X	    ShipMass = atof(argv[++i]);
X	    continue;
X	}
X
X	if (strcmp("-shotlife", argv[i]) == 0) {
X	    ShotsLife = atoi(argv[++i]);
X	    continue;
X	}
X
X	if (strcmp("-shotspeed", argv[i]) == 0) {
X	    ShotsSpeed = atof(argv[++i]);
X	    continue;
X	}
X
X	printf("Unkown option \"%s\".\n", argv[i]);
X    }
X
X    if (!map_loaded) {
X#ifndef SILENT
X	printf("Map not specified, trying to open " DEFAULT_MAP ".\n");
X#endif
X	Load_map(DEFAULT_MAP);
X    }
X}
END_OF_FILE
echo shar: 1 control character may be missing from \"'src/cmdline.c'\"
if test 3323 -ne `wc -c <'src/cmdline.c'`; then
    echo shar: \"'src/cmdline.c'\" unpacked with wrong size!
fi
# end of 'src/cmdline.c'
fi
if test -f 'src/dbuff.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/dbuff.h'\"
else
echo shar: Extracting \"'src/dbuff.h'\" \(818 characters\)
sed "s/^X//" >'src/dbuff.h' <<'END_OF_FILE'
X/* dbuff.h,v 1.6 1992/06/25 03:23:51 bjoerns Exp
X *
X *	This file is part of the XPilot project, written by
X *
X *	    Bjxrn Stabell (bjoerns@stud.cs.uit.no)
X *	    Ken Ronny Schouten (kenrsc@stud.cs.uit.no)
X *
X *	Copylefts are explained in the LICENSE file.
X */
X
X#ifndef	DBUFF_H
X#define	DBUFF_H
X
X#include <X11/Xlib.h>
X
Xtypedef struct {
X    Display	    *display;
X    Colormap	    cmap;
X    unsigned long   drawing_planes;
X    int		    buffer;
X    XColor	    *colormaps[2];
X    int		    map_size;
X    unsigned long   masks[2];
X    unsigned long   *planes;
X    unsigned long   pixel;
X} dbuff_state_t;
X
X/*
X * Prototypes.
X */
Xextern dbuff_state_t	*start_dbuff(int, Display *, Colormap,
X				     unsigned long, XColor *);
Xextern void		dbuff_switch(int, dbuff_state_t *);
Xextern void		end_dbuff(int, dbuff_state_t *);
X
X#endif
END_OF_FILE
echo shar: 1 control character may be missing from \"'src/dbuff.h'\"
if test 818 -ne `wc -c <'src/dbuff.h'`; then
    echo shar: \"'src/dbuff.h'\" unpacked with wrong size!
fi
# end of 'src/dbuff.h'
fi
if test -f 'src/lib/socklib.h' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lib/socklib.h'\"
else
echo shar: Extracting \"'src/lib/socklib.h'\" \(3113 characters\)
sed "s/^X//" >'src/lib/socklib.h' <<'END_OF_FILE'
X/* -*-C-*-
X *
X * Project :	 TRACE
X *
X * File    :	 socklib.h
X *
X * Description
X *
X * Copyright (C) 1991 by Arne Helme, The TRACE project
X *
X * Rights to use this source is granted for all non-commercial and research
X * uses. Creation of derivate forms of this software may be subject to
X * restriction. Please obtain written permission from the author.
X *
X * This software is provided "as is" without any express or implied warranty.
X *
X * RCS:      /users/staff/bjoerns/src/cvs/xpilot/src/lib/socklib.h,v 1.1.1.1 1992/05/11 12:32:34 bjoerns Exp
X * Log:      socklib.h,v
X * Revision 1.1.1.1  1992/05/11  12:32:34  bjoerns
X * XPilot v1.0
X *
X * Revision 1.2  91/10/02  08:38:20  08:38:20  arne (Arne Helme)
X * "ANSI C prototypes added."
X * 
X * Revision 1.1  91/10/02  08:34:53  08:34:53  arne (Arne Helme)
X * Initial revision
X * 
X */
X
X#ifndef _SOCKLIB_INCLUDED
X#define _SOCKLIB_INCLUDED
X
X/* Include files */
X#include <sys/types.h>
X#if(hpux)
X#include <time.h>
X#else
X#include <sys/time.h>
X#endif
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <arpa/inet.h>
X#include <stdio.h>
X#include <netdb.h>
X#include <signal.h>
X#include <setjmp.h>
X#include <errno.h>
X
X/* Error values and their meanings */
X#define SL_ESOCKET		0	/* socket system call error */
X#define SL_EBIND		1	/* bind system call error */
X#define SL_ELISTEN		2	/* listen system call error */
X#define SL_EHOSTNAME		3	/* Invalid host name format */
X#define SL_ECONNECT		5	/* connect system call error */
X#define SL_ESHUTD		6	/* shutdown system call error */
X#define SL_ECLOSE		7	/* close system call error */
X#define SL_EWRONGHOST		8	/* message arrived from unspec. host */
X#define SL_ENORESP		9	/* No response */
X#define SL_ERECEIVE		10	/* Receive error */
X
X#ifndef _SOCKLIB_LIBSOURCE
Xextern int
X    sl_errno,
X    sl_timeout_s,
X    sl_timeout_us,
X    sl_default_retries,
X    sl_broadcast_enabled;
Xextern struct sockaddr_in
X    sl_dgram_lastaddr;
X#ifdef __STDC__
Xextern void	SetTimeout(int, int);
Xextern int	CreateServerSocket(int);
Xextern int	GetPortNum(int);
Xextern int	CreateClientSocket(char *, int);
Xextern int	SocketAccept(int);
Xextern int	SocketReadable(int);
Xextern int	SocketRead(int, char *, int);
Xextern int	SocketWrite(int, char *, int);
Xextern int	SocketClose(int);
Xextern int	CreateDgramSocket(int);
Xextern int	DgramSend(int, char *, int, char *, int);
Xextern int	DgramReceiveAny(int, char *, int);
Xextern int	DgramReceive(int, char *, char *, int);
Xextern int	DgramSendRec(int, char *, int, char *, int, char *, int);
Xextern char	*DgramLastaddr(void);
Xextern int	DgramLastport(void);
X#else /* __STDC__ */
Xextern void	SetTimeout();
Xextern int	CreateServerSocket();
Xextern int	GetPortNum();
Xextern int	CreateClientSocket();
Xextern int	SocketAccept();
Xextern int	SocketReadable();
Xextern int	SocketRead();
Xextern int	SocketWrite();
Xextern int	SocketClose();
Xextern int	CreateDgramSocket();
Xextern int	DgramSend();
Xextern int	DgramReceiveAny();
Xextern int	DgramReceive();
Xextern int	DgramSendRec();
Xextern char	*DgramLastaddr();
Xextern int	DgramLastport();
X#endif /* __STDC__ */
X#endif /* _SOCKLIB_LIBSOURCE */
X#endif /* _SOCKLIB_INCLUDED */
END_OF_FILE
if test 3113 -ne `wc -c <'src/lib/socklib.h'`; then
    echo shar: \"'src/lib/socklib.h'\" unpacked with wrong size!
fi
# end of 'src/lib/socklib.h'
fi
if test -f 'src/player.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/player.c'\"
else
echo shar: Extracting \"'src/player.c'\" \(7761 characters\)
sed "s/^X//" >'src/player.c' <<'END_OF_FILE'
X/* player.c,v 1.12 1992/06/28 05:38:24 bjoerns Exp
X *
X *	This file is part of the XPilot project, written by
X *
X *	    Bjxrn Stabell (bjoerns@stud.cs.uit.no)
X *	    Ken Ronny Schouten (kenrsc@stud.cs.uit.no)
X *
X *	Copylefts are explained in the LICENSE file.
X */
X
X#include <stdio.h>
X#include "global.h"
X#include "map.h"
X#include "score.h"
X#include "robot.h"
X
X#ifndef	lint
Xstatic char sourceid[] =
X    "@(#)player.c,v 1.12 1992/06/28 05:38:24 bjoerns Exp";
X#endif
X
X
Xstatic char msg[MSG_LEN];
X
X
X
X/********** **********
X * functions on player array.
X */
X
Xvoid Pick_startpos(int ind)
X{
X    int	start, i;
X    bool alone;
X
X
X    do {
X	alone = true;
X	start = rand()%World.NumBases;
X
X	for (i=0; i<NumPlayers; i++)
X	    if (i != ind && Players[i]->home_base == start)
X		alone = false;
X    } while (!alone);
X
X    Players[ind]->home_base = start;
X}
X
X
X
Xvoid Go_home(int ind)
X{
X    player *pl = Players[ind];
X
X    pl->pos.x = World.base[pl->home_base].x
X		* BLOCK_SZ + BLOCK_SZ/2.0;
X    pl->pos.y = World.base[pl->home_base].y
X		* BLOCK_SZ - ships[DIR_UP].pts[1].y;
X    pl->acc.x = pl->acc.y = 0.0;
X    pl->vel.x = pl->vel.y = pl->velocity = 0.0;
X
X    CLR_BIT(pl->status, THRUSTING);
X
X    if (pl->robot_mode != RM_NOT_ROBOT)
X	pl->robot_mode = RM_TAKE_OFF;
X}
X
X
Xvoid Init_player(int ind)
X{
X    player *pl = Players[ind];
X    bool too_late = false;
X    int i;
X
X
X    pl->world.x = pl->world.y	= 0.0;
X    pl->vel.x	= pl->vel.y	= 0.0;
X    pl->acc.x	= pl->acc.y	= 0.0;
X    pl->dir	= pl->double_dir= DIR_UP;
X    pl->turnvel		= 0.0;
X    pl->turnacc		= 0.0;
X    pl->fuel		= DEFAULT_PLAYER_FUEL + (rand()%400) - 200;
X    pl->max_fuel	= MAX_PLAYER_FUEL;
X
X    Pick_startpos(ind);
X    Go_home(ind);
X
X    if (BIT(World.rules->mode, TIMING)) {
X	pl->power	= MAX_PLAYER_POWER;
X	pl->turnspeed	= 27.0;
X    }
X    pl->mass	= pl->emptymass	= ShipMass;
X
X    pl->check		= 0;
X    pl->round		= 0;
X    pl->time		= 0;
X    pl->last_lap_time	= 0;
X    pl->last_time	= 0;
X    pl->last_lap	= 0;
X    pl->best_run	= 0;
X    pl->best_lap	= 0;
X    pl->count		= -1;
X    pl->control_count	= 0;
X    pl->fuel_count	= 0;
X
X    pl->type		= OBJ_PLAYER;
X    pl->shots		= 0;
X    pl->extra_shots	= 0;
X    pl->missiles	= 0;
X    pl->mines		= 0;
X    pl->cloaks		= 0;
X    pl->sensors		= 0;
X    pl->forceVisible	= 0;
X    pl->shot_speed	= ShotsSpeed;
X    pl->sensor_range	= MAX(pl->fuel*ENERGY_RANGE_FACTOR,VISIBILITY_DISTANCE);
X    pl->max_speed	= SPEED_LIMIT - pl->shot_speed;
X    pl->shot_max	= ShotsMax;
X    pl->shot_life	= ShotsLife;
X    pl->shot_mass	= ShotsMass;
X    pl->score		= 0;
X    pl->fs		= 0;
X    pl->name[0]		= '\0';
X
X    pl->info_press	= false;
X    pl->help_press	= false;
X    pl->help_page	= 0;
X
X    pl->mode		= World.rules->mode;
X    pl->status		= PLAYING | GRAVITY | DEF_BITS;
X    pl->have		= DEF_HAVE;
X    pl->used		= DEF_USED;
X
X    pl->mychar		= ' ';
X    pl->life		= World.rules->lives;
X
X    /*
X     * If limited lives and if nobody has lost a life yet, you may enter
X     * now, otherwise you will have to wait 'til everyone gets GAME OVER.
X     */
X    if (BIT(pl->mode, LIMITED_LIVES)) {
X	for (i=0; i<NumPlayers; i++)
X	    if (Players[i]->life < 3)
X		too_late = true;
X	if (too_late) {
X	    pl->mychar	= 'W';
X	    pl->life	= 0;
X	    pl->status |= GAME_OVER;
X	}
X    }
X
X    if (BIT(World.rules->mode, TIMING))
X	pl->team = 0;
X
X    pl->lock.tagged	= LOCK_NONE;
X    pl->lock.pl_id	= 0;
X    pl->lock.pos.x	= pl->pos.x;
X    pl->lock.pos.y	= pl->pos.y;
X
X    pl->robot_mode	= RM_NOT_ROBOT;
X    pl->robot_count	= 0;
X    pl->robot_ind	= -1;
X
X    pl->id		= Id;
X    GetInd[Id]		= ind;
X}
X
X
X
Xvoid Alloc_players(int number)
X{
X    int i;
X
X    for (i=0; i<number; i++)
X	Players[i]=(player *)malloc(sizeof(player));
X}
X
X
X
Xvoid Free_players(int number)
X{
X    int i;
X
X    for (i=0; i<number; i++)		    
X	free(Players[i]);
X}
X
X
X
Xvoid Set_label_strings(void)
X{
X    int i, j, hi_ind;
X    double hi, hi_tmp;
X    player *pl, *tmp;
X
X
X    /*
X     * Sorts players after score. (selection sort)
X     */
X    for (i=0; i<NumPlayers; i++) {
X
X	hi = Players[i]->score;
X	hi_ind = i;
X	for (j=i+1; j<NumPlayers; j++)
X	    if (Players[j]->score > hi)
X		hi = Players[hi_ind=j]->score;
X
X	if (hi_ind != i) {
X	    tmp = Players[hi_ind];
X	    Players[hi_ind] = Players[i];
X	    Players[i] = tmp;
X	    GetInd[Players[i]->id] = i;
X	    GetInd[Players[hi_ind]->id] = hi_ind;
X	}
X    }
X
X    /*
X     * Get the person with the best kill-ratio (i.e. score/number of deaths.)
X     */
X    hi = (double)Players[0]->score / (Players[0]->life+1);
X    hi_ind = 0;
X    for (i=1; i<NumPlayers; i++)
X	if ((hi_tmp = (double)Players[i]->score/(Players[i]->life+1)) > hi) {
X	    hi = hi_tmp;
X	    hi_ind = i;
X	}
X
X    /*
X     * Re-formats the labels.
X     */
X    for (i=0; i<NumPlayers; i++) {
X	pl = Players[i];
X
X	sprintf(pl->lblstr, "%c%c %-19s%03d%6d", (hi_ind==i)?'*':pl->mychar,
X		(pl->team==0)?' ':pl->team+'0',
X		pl->name, pl->life, pl->score);
X    }
X
X    Set_labels();
X}
X
X
X/*
XIKKE FERDIG
Xvoid Reset_all_players(void)
X{
X    int i;
X
X
X    for (i=0; i<NumPlayers; i++) {
X	printf("Resetting player %s\n", Players[i]->name);
X	CLR_BIT(Players[i]->status, GAME_OVER);
X	Players[i]->life = World.rules->lives;
X	Players[i]->mychar = ' ';
X    }
X    Set_label_strings();
X}
XKalles fra Comput_game_status()
X*/
X
X
Xvoid Compute_game_status(void)
X{
X/*  int i;
X    int num_alive = 0, num_waiting = 0;
X    bool too_late = false;
X    int pl_id;
X
X
X    for (i=0; i<NumPlayers; i++) {
X	if (!BIT(Players[i]->status, GAME_OVER)) {
X	    num_alive++;
X	    pl_id = i;
X	}
X	if (Players[i]->mychar == 'W')
X	    num_waiting++;
X    }
X
XDette er ikke ferdig Ken.  :)
X
X    if (NumPlayers>1 && num_alive<=1) {
X	if (num_alive == 0)
X	    Set_message("Game over! No apparent winners.");
X
X
X    if ((num_alive == 1) && (NumPlayers != 1)) {
X	sprintf(msg, "%s has won the game!!!!!!! Long live %s!",
X		Players[pl_id]->name, Players[pl_id]->name);
X	Set_message(msg);
X	Players[pl_id]->score += PTS_GAME_WON;
X	Reset_all_players();
X    } else if (num_alive == 0) {
X	Reset_all_players();
X    }	
X*/
X}
X
X
X
Xvoid Delete_player(int ind)
X{
X    player *pl;
X    int i, id;
X
X
X    pl = Players[ind];
X    id = pl->id;
X
X    for (i=0; i<NumObjs; i++)		/* Delete all remaining shots */
X	if (Obj[i]->id == id)
X	    Delete_shot(i);
X
X    NumPlayers--;
X    if (pl->robot_mode != RM_NOT_ROBOT)
X	NumRobots--;
X
X    /*
X     * Swap entry no 'ind' with the last one.
X     */
X    pl			= Players[NumPlayers];	/* Swap pointers... */
X    Players[NumPlayers]	= Players[ind];
X    Players[ind]	= pl;
X
X    GetInd[Players[ind]->id] = ind;
X
X    for (i=0; i<NumPlayers; i++)
X	if ((Players[i]->lock.pl_id == id) || NumPlayers <= 1)
X	    Players[i]->lock.tagged = LOCK_NONE;
X}
X
X
X
Xvoid Kill_player(int ind)
X{
X    player *pl;
X
X
X    Explode(ind);
X
X    pl			= Players[ind];
X    pl->vel.x		= pl->vel.y	= 0.0;
X    pl->acc.x		= pl->acc.y	= 0.0;
X    pl->double_dir	= pl->dir	= DIR_UP;
X    pl->turnacc		= 0.0;
X    pl->turnvel		= 0.0;
X    pl->mass		= ShipMass;
X    pl->status		|= WAITING_SHOTS | DEF_BITS;
X    pl->status		&= ~(KILL_BITS);
X    pl->extra_shots	= 0;
X    pl->missiles	= 0;
X    pl->mines		= 0;
X    pl->cloaks		= 0;
X    pl->sensors		= 0;
X    pl->forceVisible	= 0;
X    pl->shot_speed	= ShotsSpeed;
X    pl->shot_max	= ShotsMax;
X    pl->shot_life	= ShotsLife;
X    pl->shot_mass	= ShotsMass;
X    pl->last_time	= pl->time;
X    pl->last_lap	= 0;
X    pl->count		= RECOVERY_DELAY;
X
X    pl->fuel *= 0.90;				/* Loose 10% of fuel */
X    pl->fuel = MAX(pl->fuel, MIN_PLAYER_FUEL+(rand()%(int)MIN_PLAYER_FUEL)/5);
X
X    if (BIT(World.rules->mode, TIMING))
X	pl->fuel = RACE_PLAYER_FUEL;
X
X    if (BIT(pl->mode, LIMITED_LIVES))
X	pl->life--;
X    else
X	pl->life++;
X
X    if (pl->life == -1) {
X	pl->life = 0;
X	SET_BIT(pl->status, GAME_OVER);
X	pl->mychar = 'D';
X    }
X
X    pl->have	= DEF_HAVE;
X    pl->used	|= DEF_USED;
X    pl->used	&= ~(USED_KILL);
X    pl->used	&= pl->have;
X}
END_OF_FILE
echo shar: 1 control character may be missing from \"'src/player.c'\"
if test 7761 -ne `wc -c <'src/player.c'`; then
    echo shar: \"'src/player.c'\" unpacked with wrong size!
fi
# end of 'src/player.c'
fi
if test -f 'src/robot.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/robot.c'\"
else
echo shar: Extracting \"'src/robot.c'\" \(27268 characters\)
sed "s/^X//" >'src/robot.c' <<'END_OF_FILE'
X/* robot.c,v 1.3 1992/06/26 15:25:46 bjoerns Exp
X *
X *	This file is part of the XPilot project, written by
X *
X *	    Bjxrn Stabell (bjoerns@stud.cs.uit.no)
X *	    Ken Ronny Schouten (kenrsc@stud.cs.uit.no)
X *
X *	Copylefts are explained in the LICENSE file.
X *
X *      Thanks to Maurice Abraham for this piece of code, and what
X *      a beauty it is :)
X */
X
X#include "global.h"
X#include "map.h"
X#include "score.h"
X#include "draw.h"
X#include "robot.h"
X
X#ifndef	lint
Xstatic char sourceid[] =
X    "@(#)robot.c,v 1.3 1992/06/26 15:25:46 bjoerns Exp";
X#endif
X
X
Xextern long	KILLING_SHOTS;
X
Xint		NumRobots = 0;
Xstatic int	MAX_ROBOTS = 1;
X
Xstatic robot_t Robots[] = {
X    "Mad Max",		94, 20,
X    "Blackie",		10, 90,
X    "Kryten",		70, 40,
X    "Marvin",		30, 70,
X    "R2D2",		50, 60,
X    "C3PO",		60, 50,
X    "K9",		50, 50,
X    "Robby",		45, 55,
X    "Mickey",		05, 95,
X    "Hermes",		15, 85,
X    "Pan",		60, 60,
X    "Azurion",		40, 30,
X    "Droidion",		60, 30,
X    "Terminator",	80, 40,
X    "Sniper",		30, 90,
X    "Slugger",		40, 40,
X    "Uzi",		95,  5,
X    "Capone",		80, 50,
X    "Tanx",		40, 70,
X    "Chrome Star",	60, 60,
X    "Bully",		80, 10,
X    "Metal Hero",	40, 45,
X    "Aurora",		60, 55,
X    "Dalt Wisney",	30, 75,
X    "Psycho",		65, 55,
X    "Gorgon",		30, 40,
X    "Pompel",		50, 50,
X    "Pilt",		50, 50,
X    "Sparky",		20, 40,
X    "Cobra",		85, 60,
X    "Falcon",		70, 20,
X    "Boson",		25, 35,
X    "Blazy",		40, 40,
X    "Pixie",		15, 93,
X    "Wimpy",		 5, 98,
X    "Bonnie",		30, 40,
X    "Clyde",		40, 45,
X    "Neuro",		70, 70,
X    NULL,		 0,  0
X};
X
X
X/*
X * Private functions.
X */
Xstatic void Calculate_max_robots(void);
Xstatic void New_robot(void);
Xstatic void Delete_robot(void);
Xstatic bool Check_robot_navigate(int ind, bool *no_evade);
Xstatic bool Check_robot_evade(int ind, int mine_i, int ship_i);
Xstatic bool Check_robot_target(int ind, int item_x, int item_y, int new_mode,
X				int attack_level);
X
X
X
X/********** **********
X * Updating robots and the like.
X */
X
Xstatic void Calculate_max_robots(void)
X{
X    int	i;
X
X    for (i=0; Robots[i].name != NULL; i++)
X	;
X
X    MAX_ROBOTS = i;
X}
X
X
X
Xstatic void Delete_robot(void)
X{
X    long	i, low_score = LONG_MAX, low_i = -1;
X
X
X    for (i=0; i<NumPlayers; i++) {
X	if (Players[i]->robot_mode == RM_NOT_ROBOT)
X	    continue;
X
X	if (Players[i]->score < low_score) {
X	    low_i = i;
X	    low_score = Players[i]->score;
X	}
X    }
X
X    if (low_i >= 0) {
X	Quit(low_i);
X    }
X}
X
X
X
Xstatic void New_robot(void)
X{
X    player	*robot;
X    robot_t	*rob;
X    int		i, num;
X    static bool	first_time = true;
X
X
X    if (first_time) {
X	Calculate_max_robots();
X	first_time = false;
X    }
X
X    if (NumPlayers >= World.NumBases-1)
X	return;
X
X    Init_player(NumPlayers);
X    robot = Players[NumPlayers];
X
X new_name:
X    num = rand()%MAX_ROBOTS;
X
X    for (i=0; i<NumPlayers; i++)
X	if (num == Players[i]->robot_ind)
X	    goto new_name;
X
X    rob = &Robots[num];
X
X    strcpy(robot->name, rob->name);
X    strcpy(robot->realname, "robot");
X
X    robot->disp_type	= DT_NONE;
X    robot->color	= WHITE;
X    robot->name_length	= strlen(robot->name) * 6;
X    robot->turnspeed	= MAX_PLAYER_TURNSPEED;
X    robot->turnspeed_s	= MAX_PLAYER_TURNSPEED;
X    robot->turnresistance	= 0.12;
X    robot->turnresistance_s	= 0.12;
X    robot->power	= MAX_PLAYER_POWER;
X    robot->power_s	= MAX_PLAYER_POWER;
X    robot->instruments	= 0;
X    robot->team		= 0;
X    robot->mychar	= 'R';
X    robot->robot_mode	= RM_TAKE_OFF;
X    robot->robot_ind	= num;
X
X/*    robot->shot_speed	= ShotsSpeed + (rob->attack - 50) / 5.0;
X    robot->shot_mass	= ShotsMass + (rob->defense - rob->attack) / 10.0;
X    robot->max_speed	= SPEED_LIMIT - robot->shot_speed;
X*/
X    NumPlayers++;
X    Id++;
X    NumRobots++;
X
X#ifndef	SILENT    
X    printf("%s (%d, %s) starts at startpos %d.\n",
X	   robot->name, NumPlayers, robot->realname, robot->home_base);
X#endif
X
X    Set_label_strings();
X}
X
X
Xstatic bool Check_robot_navigate(int ind, bool *no_evade)
X{
X    int i,j,k;
X    player *pl;
X    int area_val[10][10];
X    int calc_val[10][10];
X    int locn_block;
X    long dx, dy;
X    int di, dj;
X    bool found_wall;
X    bool found_grav;
X    bool cannon_dead;
X    bool near_wall;
X    int best_val;
X    int best_i, best_j;
X    float best_vx, best_vy;
X    int best_dir;
X    int delta_dir;
X
X    pl = Players[ind];
X
X    if (pl->velocity > 2.0 || ABS(pl->vel.x) > 1.5)
X	return false;
X
X    for (i = 0; i < 10; i ++) {
X	for (j = 0; j < 10; j ++) {
X	    area_val[i][j] = 0;
X	}
X    }
X
X    found_wall = false;
X    found_grav = false;
X
X    for (i = 0; i < 10; i += 2) {
X	for (j = 0; j < 10; j += 2) {
X
X	    dx = (long)(pl->pos.x / BLOCK_SZ) + (i / 2) - 2;
X	    dy = (long)(pl->pos.y / BLOCK_SZ) + (j / 2) - 2;
X
X	    if (dx<0 || dx>=World.x || dy<0 || dy>=World.y)
X		locn_block = FILLED;
X	    else
X		locn_block = World.block[dx][dy];
X
X	    switch (locn_block) {
X
X	    case SPACE:
X	    case BASE:
X	    case WORMHOLE:
X		area_val[i][j] = 1;
X		area_val[i+1][j] = 1;
X		area_val[i+1][j+1] = 1;
X		area_val[i][j+1] = 1;
X		break;
X
X	    case REC_LU:
X		area_val[i+1][j] = 1;
X		found_wall = true;
X		break;
X
X	    case REC_LD:
X		area_val[i+1][j+1] = 1;
X		found_wall = true;
X		break;
X
X	    case REC_RU:
X		area_val[i][j] = 1;
X		found_wall = true;
X		break;
X
X	    case REC_RD:
X		area_val[i][j+1] = 1;
X		found_wall = true;
X		break;
X
X	    case POS_GRAV:
X	    case NEG_GRAV:
X	    case CWISE_GRAV:
X	    case ACWISE_GRAV:
X		found_grav = true;
X		break;
X
X	    case CANNON:
X		cannon_dead = true;
X		for (k = 0; k < World.NumCannons; k ++) {
X		    if (World.cannon[k].pos.x == dx
X			    && World.cannon[k].pos.y == dy
X			    && World.cannon[k].dead_time <= 50)
X			cannon_dead = false;
X		}
X		if (cannon_dead) {
X		    area_val[i][j] = 1;
X		    area_val[i+1][j] = 1;
X		    area_val[i+1][j+1] = 1;
X		    area_val[i][j+1] = 1;
X		}
X		found_wall = true;
X		break;
X
X	    default:
X		found_wall = true;
X		break;
X	    }
X	}
X    }
X
X    if (found_grav || !found_wall)
X	return false;
X
X    /* iterate twice for weighting, central 6x6 square should be accurate */
X
X    for (k = 0; k < 2; k ++) {
X	for (i = 0; i < 10; i ++) {
X	    for (j = 0; j < 10; j ++) {
X
X		calc_val[i][j] = 0;
X		if (area_val[i][j] == 0)
X		    continue;
X
X		if (i <= 0 || i >= 9 || j <= 0 || j >= 9)
X		    continue;
X
X		calc_val[i][j] += 2*area_val[i-1][j];
X		calc_val[i][j] += 2*area_val[i][j+1];
X		calc_val[i][j] += 2*area_val[i+1][j];
X		calc_val[i][j] += 2*area_val[i][j-1];
X
X		calc_val[i][j] += area_val[i-1][j-1];
X		calc_val[i][j] += area_val[i-1][j+1];
X		calc_val[i][j] += area_val[i+1][j-1];
X		calc_val[i][j] += area_val[i+1][j+1];
X	    }
X	}
X
X	for (i = 0; i < 10; i ++) {
X	    for (j = 0; j < 10; j ++) {
X		area_val[i][j] = calc_val[i][j];
X	    }
X	}
X    }
X
X    /* now focus in to local 3x3 square */
X
X    dx = pl->pos.x;
X    dy = pl->pos.y;
X
X    dx = dx - (dx / BLOCK_SZ * BLOCK_SZ);
X    dy = dy - (dy / BLOCK_SZ * BLOCK_SZ);
X
X    di = 3;
X    dj = 3;
X
X    if (dx > BLOCK_SZ/2) {
X	di ++;
X	dx -= BLOCK_SZ/2;
X    }
X
X    if (dy > BLOCK_SZ/2) {
X	dj ++;
X	dy -= BLOCK_SZ/2;
X    }
X
X    for (i = 0; i < 3; i ++) {
X	for (j = 0; j < 3; j ++) {
X	    area_val[i][j] = area_val[di+i][dj+j];
X	}
X    }
X
X    *no_evade = true;
X
X    if (ABS(pl->vel.x) < 0.5) {
X
X	best_i = 1;
X	best_j = (pl->vel.y > 0 ? 2 : 0);
X
X    } else if (ABS(pl->vel.y) < 0.5) {
X
X	best_i = (pl->vel.x > 0 ? 2 : 0);
X	best_j = 1;
X
X    } else {
X
X	best_i = (pl->vel.x > 0 ? 2 : 0);
X	best_j = (pl->vel.y > 0 ? 2 : 0);
X    }
X
X    best_val = area_val[best_i][best_j];
X    near_wall = false;
X
X    for (j = 2; j >= 0; j --) {
X	for (i = 0; i <= 2; i ++) {
X
X	    if (i == 1 && j == 1)
X		continue;
X
X	    if (area_val[i][j] == 0) {
X		near_wall = true;
X		if (i == 1 && (j == 0 || j == 2)) {
X		    best_i = 1;
X		    best_j = (2 - j);
X		    best_val = 99999;
X		}
X		continue;
X	    }
X
X	    if (area_val[i][j] > best_val) {
X		best_i = i;
X		best_j = j;
X		best_val = area_val[i][j];
X	    }
X	}
X    }
X
X    if (area_val[1][1] >= best_val)
X	return false;
X
X    if (!near_wall) {
X	if (BIT(pl->used, OBJ_REFUEL)) {
X	    /* refueling, so hang around */
X	    best_i = 1;
X	    best_j = 1;
X	    best_val = area_val[1][1];
X	} else {
X	    return false;
X	}
X    }
X
X    if (best_j == 1) {
X	if (dy < BLOCK_SZ/6)
X	    best_j = 2;
X	if (dy > BLOCK_SZ/3)
X	    best_j = 0;
X    }
X
X    pl->turnspeed = MAX_PLAYER_TURNSPEED;
X    pl->power = pl->mass / 2;
X    LIMIT(pl->power, MIN_PLAYER_POWER, MAX_PLAYER_POWER);
X
X    best_vx = (best_i - 1) * 0.75;
X    best_vy = (best_j - 1) * 1.25;
X
X    if (pl->vel.x > best_vx + 0.75)
X	best_dir = 3*RES/8;
X    else
X    if (pl->vel.x < best_vx - 0.75)
X	best_dir = RES/8;
X    else
X    if (pl->vel.x > best_vx + 0.25)
X	best_dir = 5*RES/16;
X    else
X    if (pl->vel.x < best_vx - 0.25)
X	best_dir = 3*RES/16;
X    else
X	best_dir = RES/4;
X
X    delta_dir = best_dir - pl->dir;
X    delta_dir = MOD(delta_dir, RES);
X
X    if (delta_dir > RES/8 && delta_dir < 7*RES/8) {
X	pl->turnacc = (delta_dir < RES/2 ?
X			pl->turnspeed : (-pl->turnspeed));
X    } else if (delta_dir > RES/64 && delta_dir < 63*RES/64) {
X	pl->turnspeed = MIN_PLAYER_TURNSPEED;
X	pl->turnacc = (delta_dir < RES/2 ?
X			pl->turnspeed : (-pl->turnspeed));
X    } else {
X	pl->turnacc = 0;
X    }
X
X    if (pl->vel.y > best_vy + 0.25) {
X	CLR_BIT(pl->status, THRUSTING);
X    } else if (pl->vel.y < best_vy - 0.25) {
X	SET_BIT(pl->status, THRUSTING);
X    }
X
X    return true;
X}
X
X
Xstatic bool Check_robot_evade(int ind, int mine_i, int ship_i)
X{
X    int i;
X    player *pl;
X    object *shot;
X    player *ship;
X    int stop_dist;
X    bool evade;
X    bool left_ok,right_ok;
X    int safe_width;
X    int travel_dir;
X    int delta_dir;
X    int aux_dir;
X    int px[3],py[3];
X    int dist;
X    int locn_block;
X    vector *gravity;
X    int gravity_dir;
X    int dx,dy;
X
X    pl		= Players[ind];
X    safe_width	= 3*SHIP_SZ/2;
X    stop_dist	=
X	(RES * pl->velocity) / (MAX_PLAYER_TURNSPEED * pl->turnresistance)
X	    + (pl->velocity * pl->velocity * pl->mass) / (2 * MAX_PLAYER_POWER)
X		+ safe_width;
X    evade = false;
X
X    if (pl->velocity <= 0.2)
X	travel_dir = DIR_DOWN;
X    else {
X	travel_dir = atan2(pl->vel.y, pl->vel.x) * RES / (2.0 * PI);
X	travel_dir = MOD(travel_dir, RES);
X    }
X
X    aux_dir = MOD(travel_dir+RES/4, RES);
X    px[0] = pl->pos.x;				/* ship center x */
X    py[0] = pl->pos.y;				/* ship center y */
X    px[1] = px[0] + safe_width * tcos(aux_dir);	/* ship left side x */
X    py[1] = py[0] + safe_width * tsin(aux_dir);	/* ship left side y */
X    px[2] = 2 * px[0] - px[1];			/* ship right side x */
X    py[2] = 2 * py[0] - py[1];			/* ship right side y */
X
X    left_ok = true;
X    right_ok = true;
X
X    for (dist=0; dist<stop_dist+BLOCK_SZ/2; dist+=BLOCK_SZ/2) {
X	for (i=0; i<3; i++) {
X	    dx = (px[i] + dist * tcos(travel_dir)) / BLOCK_SZ;
X	    dy = (py[i] + dist * tsin(travel_dir)) / BLOCK_SZ;
X
X	    if (dx<0 || dx>=World.x || dy<0 || dy>=World.y) {
X		evade = true;
X		if (i==1) left_ok = false;
X		if (i==2) right_ok = false;
X		continue;
X	    }
X
X	    locn_block = World.block[dx][dy];
X	    if (locn_block != SPACE && locn_block != BASE
X		&& locn_block != POS_GRAV && locn_block != NEG_GRAV
X		&& locn_block != CWISE_GRAV && locn_block != ACWISE_GRAV) {
X
X		evade = true;
X		if (i == 1) left_ok = false;
X		if (i == 2) right_ok = false;
X		continue;
X            }
X
X	    gravity = &World.gravity[dx][dy]; /* watch out for strong gravity */
X            if (LENGTH(gravity->x, gravity->y) >= 1.0) {
X		gravity_dir = atan2(gravity->y-pl->pos.y, gravity->x-pl->pos.x)
X		    		* RES / (2.0 * PI);
X		gravity_dir = MOD(gravity_dir, RES);
X		if (MOD(gravity_dir-travel_dir, RES) <= RES/4 ||
X		    MOD(gravity_dir-travel_dir, RES) >= 3*RES/4) {
X		    evade = true;
X		    if (i == 1) left_ok = false;
X		    if (i == 2) right_ok = false;
X		    continue;
X		}
X	    }
X	}
X    }
X
X    if (mine_i >= 0) {
X	shot = Obj[mine_i];
X	aux_dir = atan2(shot->pos.y-pl->pos.y, shot->pos.x-pl->pos.x)
X	    		* RES/(2.0*PI);
X	aux_dir = MOD(aux_dir, RES);
X	delta_dir = MOD(aux_dir - travel_dir,RES);
X	if (delta_dir < RES/4) {
X	    left_ok = false;
X	    evade = true;
X	}
X	if (delta_dir > RES*3/4) {
X	    right_ok = false;
X	    evade = true;
X	}
X    }
X
X    if (ship_i >= 0) {
X	ship = Players[ship_i];
X	aux_dir = atan2(ship->pos.y-pl->pos.y, ship->pos.x-pl->pos.x)
X	    		* RES/(2.0*PI);
X	aux_dir = MOD(aux_dir, RES);
X	delta_dir = MOD(aux_dir - travel_dir,RES);
X	if (delta_dir < RES/4) {
X	    left_ok = false;
X	    evade = true;
X	}
X	if (delta_dir > RES*3/4) {
X	    right_ok = false;
X	    evade = true;
X	}
X    }
X
X    if (pl->velocity > MAX_ROBOT_SPEED)
X	evade = true;
X
X    if (!evade)
X	return false;
X
X    delta_dir = 0;
X    while (!left_ok && !right_ok && delta_dir<7*RES/8) {
X	delta_dir += RES/16;
X
X	left_ok = true;
X	aux_dir = MOD(travel_dir+delta_dir,RES);
X	for (dist=0; dist < stop_dist+BLOCK_SZ/2; dist += BLOCK_SZ/2) {
X	    dx = (px[0] + dist * tcos(aux_dir)) / BLOCK_SZ;
X	    dy = (py[0] + dist * tsin(aux_dir)) / BLOCK_SZ;
X
X	    if (dx<0 || dx>=World.x || dy<0 || dy>=World.y) {
X		left_ok = false;
X		continue;
X	    }
X
X	    locn_block = World.block[dx][dy];
X	    if (locn_block != SPACE && locn_block != BASE
X		&& locn_block != POS_GRAV && locn_block != NEG_GRAV
X		&& locn_block != CWISE_GRAV && locn_block != ACWISE_GRAV)
X	    {
X		left_ok = false;
X		continue;
X            }
X
X	    /* watch out for strong gravity */
X	    gravity = &World.gravity[dx][dy];
X            if (LENGTH(gravity->x, gravity->y) >= 1.0) {
X		gravity_dir = atan2(gravity->y-pl->pos.y, gravity->x-pl->pos.x)
X		    		* RES / (2.0 * PI);
X		gravity_dir = MOD(gravity_dir, RES);
X		if (MOD(gravity_dir-travel_dir, RES) <= RES/4 ||
X		    MOD(gravity_dir-travel_dir, RES) >= 3*RES/4) {
X
X		    left_ok = false;
X		    continue;
X		}
X	    }
X	}
X
X	right_ok = true;
X	aux_dir = MOD(travel_dir-delta_dir, RES);
X	for (dist=0; dist < stop_dist+BLOCK_SZ/2; dist += BLOCK_SZ/2) {
X	    dx = (px[0] + dist * tcos(aux_dir)) / BLOCK_SZ;
X	    dy = (py[0] + dist * tsin(aux_dir)) / BLOCK_SZ;
X
X	    if (dx<0 || dx>=World.x || dy<0 || dy>=World.y) {
X		right_ok = false;
X		continue;
X	    }
X
X	    locn_block = World.block[dx][dy];
X	    if (locn_block != SPACE && locn_block != BASE
X		&& locn_block != POS_GRAV && locn_block != NEG_GRAV
X		&& locn_block != CWISE_GRAV && locn_block != ACWISE_GRAV) {
X
X		right_ok = false;
X		continue;
X            }
X
X	    /* watch out for strong gravity */
X	    gravity = &World.gravity[dx][dy];
X            if (LENGTH(gravity->x, gravity->y)>=1.0) {
X		gravity_dir = atan2(gravity->y-pl->pos.y, gravity->x-pl->pos.x)
X	    			* RES / (2.0 * PI);
X		gravity_dir = MOD(gravity_dir, RES);
X		if (MOD(gravity_dir-travel_dir, RES) <= RES/4 ||
X		    MOD(gravity_dir-travel_dir, RES) >= 3*RES/4) {
X
X		    right_ok = false;
X		    continue;
X		}
X	    }
X	}
X    }
X
X    pl->turnspeed = MAX_PLAYER_TURNSPEED;
X    pl->power = MAX_PLAYER_POWER;
X
X    delta_dir = MOD(pl->dir - travel_dir, RES);
X
X    if (pl->robot_mode != RM_EVADE_LEFT && pl->robot_mode != RM_EVADE_RIGHT) {
X	if (left_ok && !right_ok)
X	    pl->robot_mode = RM_EVADE_LEFT;
X	else if (right_ok && !left_ok)
X	    pl->robot_mode = RM_EVADE_RIGHT;
X	else
X	    pl->robot_mode = (delta_dir < RES/2 ?
X			    RM_EVADE_LEFT : RM_EVADE_RIGHT);
X    }
X
X    if (delta_dir < 3*RES/8 || delta_dir > 5*RES/8) {
X	pl->turnacc = (pl->robot_mode == RM_EVADE_LEFT ?
X		       pl->turnspeed : (-pl->turnspeed));
X	CLR_BIT(pl->status, THRUSTING);
X    } else {
X	pl->turnacc = 0;
X	SET_BIT(pl->status, THRUSTING);
X	pl->robot_mode = (delta_dir < RES/2 ? RM_EVADE_LEFT : RM_EVADE_RIGHT);
X    }
X
X    return true;
X}
X
X
Xstatic bool Check_robot_target(int ind, int item_x, int item_y, int new_mode,
X			       int attack_level)
X{
X    int i;
X    player *pl;
X    long item_dist;
X    int item_dir;
X    int travel_dir;
X    int delta_dir;
X    int dx, dy;
X    int dist;
X    int locn_block;
X    bool clear_path;
X    bool slowing;
X
X
X    pl = Players[ind];
X
X    dx = item_x - pl->pos.x;
X    dy = item_y - pl->pos.y;
X
X    if (new_mode != RM_CANNON_KILL)
X	dy += SHIP_SZ/2;
X
X    item_dist	= LENGTH(dy, dx);
X    item_dir	= atan2(dy, dx) * RES/(2.0*PI);
X    item_dir	= MOD(item_dir, RES);
X
X    if (new_mode == RM_REFUEL || new_mode == RM_CANNON_KILL)
X	item_dist -= 2*BLOCK_SZ;
X
X    clear_path = true;
X
X    for (dist = 0; clear_path && dist < item_dist; dist += BLOCK_SZ/2) {
X
X	dx = (pl->pos.x + dist*tcos(item_dir)) / BLOCK_SZ;
X	dy = (pl->pos.y + dist*tsin(item_dir)) / BLOCK_SZ;
X
X	if (dx < 0 || dx >= World.x || dy < 0 || dy >= World.y) {
X	    clear_path = false;
X	    continue;
X	}
X
X	locn_block = World.block[dx][dy];
X	if (locn_block != SPACE && locn_block != BASE && locn_block != CANNON
X	    && locn_block != POS_GRAV && locn_block != NEG_GRAV
X	    && locn_block != CWISE_GRAV && locn_block != ACWISE_GRAV) {
X
X	    clear_path = false;
X	    continue;
X	}
X    }
X
X    if (!clear_path)
X	return false;
X	
X    if (pl->velocity <= 0.2)
X	travel_dir = DIR_DOWN;
X    else {
X	travel_dir = atan2(pl->vel.y,pl->vel.x) * RES/(2.0*PI);
X	travel_dir = MOD(travel_dir, RES);
X    }
X
X    pl->turnspeed = MAX_PLAYER_TURNSPEED/2;
X    pl->power     = MAX_PLAYER_POWER/2;
X
X    delta_dir = MOD(item_dir-travel_dir,RES);
X    if (delta_dir >= RES/4 && delta_dir <= 3*RES/4 && item_dist > 2*BLOCK_SZ) {
X
X	if (new_mode == RM_HARVEST) {	     /* reverse direction of travel */
X	    item_dir	= MOD(travel_dir+RES/2, RES);
X	}
X
X	pl->turnspeed	= MAX_PLAYER_TURNSPEED;
X	slowing		= true;
X
X    } else if (new_mode == RM_CANNON_KILL && item_dist <= 0) {
X
X	/* too close, to move away */
X	pl->turnspeed	= MAX_PLAYER_TURNSPEED;
X        item_dir	= MOD(item_dir+RES/2,RES);
X	slowing		= true;
X
X    } else {
X
X	slowing		= false;
X    }
X
X    delta_dir = MOD(item_dir-pl->dir, RES);
X    if (delta_dir > RES/8 && delta_dir < 7*RES/8) {
X	pl->turnacc = (delta_dir < RES/2 ?
X		       pl->turnspeed : (-pl->turnspeed));
X    } else if ((delta_dir > RES/64 && delta_dir < 63*RES/64)
X	       || (pl->robot_mode == RM_CANNON_KILL)
X	       || (pl->robot_count%8) == 0) {
X	pl->turnspeed	= MIN_PLAYER_TURNSPEED;
X	pl->turnacc	= (delta_dir < RES/2
X			   ? pl->turnspeed : (-pl->turnspeed));
X    } else {
X	pl->turnacc = 0.0;
X    }
X
X    if (slowing) {
X
X	SET_BIT(pl->status, THRUSTING);
X
X    } else if (item_dist < 0) {
X
X	CLR_BIT(pl->status, THRUSTING);
X
X    } else if (item_dist < BLOCK_SZ) {
X
X	if (pl->velocity < NORMAL_ROBOT_SPEED/3)
X	    SET_BIT(pl->status, THRUSTING);
X	if (pl->velocity > NORMAL_ROBOT_SPEED/2)
X	    CLR_BIT(pl->status, THRUSTING);
X
X    } else if (item_dist < 4*BLOCK_SZ) {
X
X	if (pl->velocity < NORMAL_ROBOT_SPEED/2)
X	    SET_BIT(pl->status, THRUSTING);
X	if (pl->velocity > NORMAL_ROBOT_SPEED)
X	    CLR_BIT(pl->status, THRUSTING);
X
X    } else if (new_mode != RM_ATTACK) {
X
X	if (pl->velocity < NORMAL_ROBOT_SPEED)
X	    SET_BIT(pl->status, THRUSTING);
X	if (pl->velocity > 3*NORMAL_ROBOT_SPEED/2)
X	    CLR_BIT(pl->status, THRUSTING);
X
X    } else {
X
X	if (pl->velocity < ATTACK_ROBOT_SPEED/2)
X	    SET_BIT(pl->status, THRUSTING);
X	if (pl->velocity > ATTACK_ROBOT_SPEED)
X	    CLR_BIT(pl->status, THRUSTING);
X    }
X
X    if (new_mode == RM_ATTACK) {
X	if ((pl->robot_count%10) == 0 && pl->missiles > 0) {
X
X	    Fire_shot(ind, OBJ_SMART_SHOT, pl->dir);
X
X	} else if ((pl->robot_count%2) == 0
X		   && item_dist < VISIBILITY_DISTANCE
X		   && (pl->robot_count %
X		       (110-Robots[pl->robot_ind].attack)) < 15+attack_level) {
X
X	    Fire_shot(ind, OBJ_SHOT, pl->dir);
X	    for (i=0; i<pl->extra_shots; i++) {
X		Fire_shot(ind,OBJ_SHOT, MOD(pl->dir+(1+i)*SHOTS_ANGLE, RES));
X		Fire_shot(ind,OBJ_SHOT, MOD(pl->dir-(1+i)*SHOTS_ANGLE, RES));
X	    }
X
X	    if (BIT(pl->have, OBJ_REAR_SHOT))
X		Fire_shot(ind, OBJ_SHOT, MOD(pl->dir+RES/2, RES));
X	}
X
X	if (pl->fuel < pl->fuel2 && pl->mines > 0 && (pl->robot_count%30)==0) {
X	    Place_mine(ind);
X	    pl->mines--;
X	    CLR_BIT(pl->used, OBJ_CLOAKING_DEVICE);
X	}
X    }
X	
X    if (new_mode == RM_CANNON_KILL && !slowing) {
X	if ((pl->robot_count%2) == 0 && item_dist < VISIBILITY_DISTANCE) {
X
X	    Fire_shot(ind, OBJ_SHOT, pl->dir);
X	    for (i=0; i<pl->extra_shots; i++) {
X		Fire_shot(ind,OBJ_SHOT, MOD(pl->dir+(1+i)*SHOTS_ANGLE, RES));
X		Fire_shot(ind,OBJ_SHOT, MOD(pl->dir-(1+i)*SHOTS_ANGLE, RES));
X	    }
X
X	    if (BIT(pl->have, OBJ_REAR_SHOT))
X		Fire_shot(ind, OBJ_SHOT, MOD(pl->dir+RES/2, RES));
X	}
X    }
X	
X    pl->robot_mode = new_mode;
X    return true;
X}
X
X
Xvoid Update_robots(void)
X{
X    player	*pl, *ship;
X    object	*shot;
X    double	distance, mine_dist, item_dist,
X    		ship_dist, enemy_dist, cannon_dist, fuel_dist;
X    int		i, j, mine_i, item_i, ship_i, enemy_i, cannon_i, fuel_i;
X    long	dx, dy;
X    bool	harvest_checked;
X    bool	fuel_checked;
X    bool	evade_checked;
X    int		attack_level;
X
X
X    if (NumRobots < WantedNumRobots
X	&& NumPlayers < World.NumBases
X	&& NumRobots < MAX_ROBOTS) {
X
X	New_robot();
X    }
X
X    if (NumRobots <= 0)
X	return;
X
X    if (NumPlayers >= World.NumBases && NumRobots > 0) {
X	Delete_robot();
X    }
X
X    for (i=0; i<NumPlayers; i++) {
X	pl = Players[i];
X	if (pl->robot_mode == RM_NOT_ROBOT)
X	    continue;
X	if (!BIT(pl->status, PLAYING))
X	    continue;
X
X	if (pl->robot_count <= 0)
X	    pl->robot_count = 1000 + rand()%20;
X
X	pl->robot_count--;
X
X	CLR_BIT(pl->used, OBJ_SHIELD|OBJ_CLOAKING_DEVICE);
X	harvest_checked	= false;
X	fuel_checked	= false;
X	evade_checked	= false;
X
X	mine_i		= -1;
X	mine_dist	= SHIP_SZ + 200;
X	item_i		= -1;
X	item_dist	= VISIBILITY_DISTANCE;
X
X	if (BIT(pl->have, OBJ_CLOAKING_DEVICE) && pl->fuel > pl->fuel3)
X	    SET_BIT(pl->used, OBJ_CLOAKING_DEVICE);
X
X	for (j=0; j<NumObjs; j++) {
X	    shot = Obj[j];
X
X	    switch (shot->type) {
X	    case OBJ_WIDEANGLE_SHOT:
X	    case OBJ_REAR_SHOT:
X	    case OBJ_SMART_SHOT:
X	    case OBJ_CLOAKING_DEVICE:
X	    case OBJ_ENERGY_PACK:
X	    case OBJ_MINE_PACK:
X	    case OBJ_SENSOR_PACK:
X		dx = shot->pos.x - pl->pos.x;
X		dy = shot->pos.y - pl->pos.y;
X
X		if ((distance = LENGTH(dx,dy)) < item_dist) {
X		    item_i	= j;
X		    item_dist	= distance;
X		}
X		break;
X
X	    case OBJ_MINE:
X		dx = shot->pos.x - pl->pos.x;
X		dy = shot->pos.y - pl->pos.y;
X
X		if ((distance = LENGTH(dx,dy)) < mine_dist) {
X		    mine_i	= j;
X		    mine_dist	= distance;
X		}
X		break;
X	    }
X
X	    if (BIT(shot->type, KILLING_SHOTS)
X		&& ABS(shot->pos.x - pl->pos.x) < SHIP_SZ+20
X		&& ABS(shot->pos.y - pl->pos.y) < SHIP_SZ+20
X		&& shot->id != pl->id
X		&& (shot->type == OBJ_CANNON_SHOT
X		    || pl->robot_count%100
X		    	< (Robots[pl->robot_ind].defense+700)/8)) {
X		SET_BIT(pl->used, OBJ_SHIELD);
X	    }
X	}
X
X	if (Check_robot_navigate(i, &evade_checked))
X	    continue;
X
X	ship_i		= -1;
X	ship_dist	= (pl->fuel >= pl->fuel1 ? SHIP_SZ*6 : 0);
X	enemy_i		= -1;
X	enemy_dist	= (pl->fuel >= pl->fuel3 ?
X			   VISIBILITY_DISTANCE*2 : VISIBILITY_DISTANCE);
X
X	for (j=0; j<NumPlayers; j++) {
X	    ship = Players[j];
X	    if (j==i || !(BIT(ship->status, PLAYING)))
X		continue;
X
X	    dx = ship->pos.x - pl->pos.x;
X	    dy = ship->pos.y - pl->pos.y;
X
X	    if (ABS(dx) < ship_dist && ABS(dy) < ship_dist
X		&& (distance = LENGTH(dx,dy)) < ship_dist) {
X
X		ship_i    = j;
X		ship_dist = distance;
X	    }
X
X	    if (ship->robot_mode == RM_NOT_ROBOT
X		&& (distance = LENGTH(dx,dy)) < enemy_dist) {
X
X		enemy_i    = j;
X		enemy_dist = distance;
X	    }
X	}
X
X	if (pl->lock.tagged == LOCK_PLAYER) {
X	    ship = Players[GetInd[pl->lock.pl_id]];
X	    if (!(BIT(ship->status, PLAYING))
X		|| pl->lock.distance > 2*VISIBILITY_DISTANCE
X		|| (!(pl->visibility[GetInd[pl->lock.pl_id]].canSee)
X		    && (pl->robot_count%25) == 0)) {
X		pl->lock.pl_id	= 1;
X		pl->lock.tagged	= LOCK_NONE;
X		pl->lock.pos.x	= pl->pos.x;
X		pl->lock.pos.y	= pl->pos.y;
X		pl->lock.distance	= 0;
X	    }
X	}
X
X	if (enemy_i >= 0) {
X	    ship = Players[enemy_i];
X	    if (pl->lock.tagged == LOCK_NONE
X		|| enemy_dist < 3*pl->lock.distance/4) {
X		if (!(pl->visibility[enemy_i].canSee)
X		    || (BIT(ship->status, THRUSTING)
X			&& enemy_dist < VISIBILITY_DISTANCE)) {
X		    pl->lock.pl_id	= ship->id;
X		    pl->lock.tagged	= LOCK_PLAYER;
X		    pl->lock.pos.x	= ship->pos.x;
X		    pl->lock.pos.y	= ship->pos.y;
X		    pl->lock.distance	= LENGTH(pl->pos.x-ship->pos.x,
X						 pl->pos.y-ship->pos.y);
X		    pl->sensor_range	= VISIBILITY_DISTANCE;
X		}
X	    }
X	}
X
X	if (!evade_checked) {
X	    if (Check_robot_evade(i, mine_i, ship_i))
X		continue;
X	}
X
X	if (item_i >= 0 && enemy_dist > 2*item_dist
X		&& enemy_dist > 12*BLOCK_SZ) {
X
X	    harvest_checked = true;
X	    dx = Obj[item_i]->pos.x;
X	    dy = Obj[item_i]->pos.y;
X
X	    if (Check_robot_target(i, dx, dy, RM_HARVEST, 0))
X		    continue;
X	}
X
X	if (pl->lock.tagged == LOCK_PLAYER) {
X
X	    ship = Players[GetInd[pl->lock.pl_id]];
X	    dx = ship->pos.x;
X	    dy = ship->pos.y;
X	    attack_level = MAX(ship->score/8, 0);
X
X	    if (Check_robot_target(i, dx, dy, RM_ATTACK, attack_level))
X		continue;
X	}
X
X	if (item_i >= 0 && !harvest_checked) {
X
X	    dx = Obj[item_i]->pos.x;
X	    dy = Obj[item_i]->pos.y;
X
X	    if (Check_robot_target(i, dx, dy, RM_HARVEST, 0))
X		continue;
X	}
X
X	cannon_i	= -1;
X	cannon_dist	= VISIBILITY_DISTANCE;
X	fuel_i		= -1;
X	fuel_dist	= VISIBILITY_DISTANCE;
X
X	for (j = 0; j < World.NumCannons; j ++) {
X
X	    if (World.cannon[j].dead_time > 0)
X		continue;
X
X	    dx = World.cannon[j].pos.x * BLOCK_SZ + BLOCK_SZ/2 - pl->pos.x;
X	    dy = World.cannon[j].pos.y * BLOCK_SZ + BLOCK_SZ/2 - pl->pos.y;
X
X	    if (ABS(dx) < cannon_dist && ABS(dy) < cannon_dist &&
X		    (distance=LENGTH(dx,dy)) < cannon_dist) {
X		cannon_i    = j;
X		cannon_dist = distance;
X	    }
X	}
X
X	for (j = 0; j < World.NumFuels; j ++) {
X
X	    if (World.fuel[j].left < 100 || pl->fuel >= MAX_PLAYER_FUEL-200)
X		continue;
X
X	    dx = World.fuel[j].pos.x - pl->pos.x;
X	    dy = World.fuel[j].pos.y - pl->pos.y;
X
X	    if (ABS(dx) < fuel_dist && ABS(dy) < fuel_dist &&
X		    (distance=LENGTH(dx,dy)) < fuel_dist) {
X		fuel_i    = j;
X		fuel_dist = distance;
X	    }
X	}
X
X	if (fuel_i >= 0 && cannon_dist > fuel_dist) {
X
X	    fuel_checked = true;
X	    dx = World.fuel[fuel_i].pos.x;
X	    dy = World.fuel[fuel_i].pos.y;
X
X	    SET_BIT (pl->used, OBJ_REFUEL);
X	    pl->fs = fuel_i;
X
X	    if (Check_robot_target(i, dx, dy, RM_REFUEL, 0))
X		continue;
X	}
X
X	if (cannon_i >= 0) {
X
X	    dx = World.cannon[cannon_i].pos.x * BLOCK_SZ + BLOCK_SZ/2;
X	    dy = World.cannon[cannon_i].pos.y * BLOCK_SZ + BLOCK_SZ/2;
X
X	    if (Check_robot_target(i, dx, dy, RM_CANNON_KILL, 0))
X		continue;
X	}
X
X	if (fuel_i >= 0 && !fuel_checked) {
X
X	    dx = World.fuel[fuel_i].pos.x;
X	    dy = World.fuel[fuel_i].pos.y;
X
X	    SET_BIT (pl->used, OBJ_REFUEL);
X	    pl->fs = fuel_i;
X
X	    if (Check_robot_target(i, dx, dy, RM_REFUEL, 0))
X		continue;
X	}
X
X	if (pl->fuel < DEFAULT_PLAYER_FUEL)
X	    pl->fuel += 0.2;
X	if (pl->fuel < MIN_PLAYER_FUEL)
X	    pl->fuel = MIN_PLAYER_FUEL;
X
X	if (pl->vel.y < (-NORMAL_ROBOT_SPEED) || (pl->robot_count%64) < 32) {
X
X	    pl->robot_mode = RM_ROBOT_CLIMB;
X	    pl->turnspeed = MAX_PLAYER_TURNSPEED/2;
X	    pl->power 	  = MAX_PLAYER_POWER/2;
X	    if (ABS(pl->dir-RES/4) > RES/16) {
X		pl->turnacc = (pl->dir < RES/4
X			       || pl->dir >= 3*RES/4
X			       ? pl->turnspeed : (-pl->turnspeed));
X	    } else {
X		pl->turnacc = 0.0;
X	    }
X	    if (pl->vel.y < NORMAL_ROBOT_SPEED/2
X		   && pl->velocity < ATTACK_ROBOT_SPEED)
X		SET_BIT(pl->status, THRUSTING);
X	    if (pl->vel.y > NORMAL_ROBOT_SPEED)
X		CLR_BIT(pl->status, THRUSTING);
X	    continue;
X	}
X	
X	/* must be idle */
X	pl->robot_mode	= RM_ROBOT_IDLE;
X	pl->turnspeed	= MAX_PLAYER_TURNSPEED/2;
X	pl->turnacc	= 0;
X	pl->power	= MAX_PLAYER_POWER/2;
X	CLR_BIT(pl->status, THRUSTING);
X	if (pl->velocity < NORMAL_ROBOT_SPEED/2)
X	    SET_BIT(pl->status, THRUSTING);
X	if (pl->velocity > NORMAL_ROBOT_SPEED)
X	    CLR_BIT(pl->status, THRUSTING);
X    }
X}
END_OF_FILE
echo shar: 1 control character may be missing from \"'src/robot.c'\"
if test 27268 -ne `wc -c <'src/robot.c'`; then
    echo shar: \"'src/robot.c'\" unpacked with wrong size!
fi
# end of 'src/robot.c'
fi
echo shar: End of archive 22 \(of 24\).
cp /dev/null ark22isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    echo "\nNow run 'bldmaps.sh' to build the map files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
