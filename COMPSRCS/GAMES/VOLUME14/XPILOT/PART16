Path: uunet!zephyr.ens.tek.com!master!saab!billr
From: billr@saab.CNA.TEK.COM (Bill Randle)
Newsgroups: comp.sources.games
Subject: v14i018:  xpilot - Multiplayer gravity war game hand-shake program, Part16/24
Message-ID: <3313@master.CNA.TEK.COM>
Date: 4 Aug 92 19:30:20 GMT
Sender: news@master.CNA.TEK.COM
Lines: 2254
Approved: billr@saab.CNA.TEK.COM

Submitted-by: Bjoern Stabell <bjoerns@staff.cs.uit.no>
Posting-number: Volume 14, Issue 18
Archive-name: xpilot/Part16
Environment: X11, ANSI C



#! /bin/sh
# This is a shell archive.  Remove anything before this line, then unpack
# it by saving it into a file and typing "sh file".  To overwrite existing
# files, type "sh file -c".  You can also feed this as standard input via
# unshar, or by typing "sh <file", e.g..  If this archive is complete, you
# will see the following message at the end:
#		"End of archive 16 (of 24)."
# Contents:  src/default.c src/draw.c src/lib/Makefile
# Wrapped by billr@saab on Tue Aug  4 10:38:57 1992
PATH=/bin:/usr/bin:/usr/ucb ; export PATH
if test -f 'src/default.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/default.c'\"
else
echo shar: Extracting \"'src/default.c'\" \(6943 characters\)
sed "s/^X//" >'src/default.c' <<'END_OF_FILE'
X/* $Id: default.c,v 1.6 1992/07/10 21:40:59 bjoerns Exp $
X *
X *	This file is part of the XPilot project, written by
X *
X *	    Bjxrn Stabell (bjoerns@stud.cs.uit.no)
X *	    Ken Ronny Schouten (kenrsc@stud.cs.uit.no)
X *
X *	Copylefts are explained in the LICENSE file.
X */
X
X#include <X11/keysym.h>
X#include "global.h"
X#include "pack.h"
X#include "limits.h"
X
X#ifndef	lint
Xstatic char sourceid[] =
X    "@(#)$Id: default.c,v 1.6 1992/07/10 21:40:59 bjoerns Exp $";
X#endif
X
X#define ON(x)	      ( (strcasecmp(x, "true")==0) || (strcasecmp(x, "on")==0) )
X#define NELEM(a)	(sizeof(a) / sizeof((a)[0]))
X
X
X
Xstatic double atod(char *str)
X{
X    double tmp;
X
X    sscanf(str, "%lf", &tmp);
X    return (tmp);
X}
X
X
Xvoid Get_defaults(int ind)
X{
X    char		*str;
X    int			i;
X    player		*pl = Players[ind];
X    static struct _keyResources
X    {
X	char    *resource;
X	keys_t	key;
X    } keyResources[] = {
X	"keyLockNext", 		KEY_LOCK_NEXT,
X	"keyLockPrev", 		KEY_LOCK_PREV,
X	"keyLockClose", 	KEY_LOCK_CLOSE,
X	"keyChangeHome",	KEY_CHANGE_HOME,
X	"keyShield",		KEY_SHIELD,
X	"keyFireShot",		KEY_FIRE_SHOT,
X	"keyFireMissile",	KEY_FIRE_MISSILE,
X	"keyDropMine",		KEY_DROP_MINE,
X	"keyTurnLeft",		KEY_TURN_LEFT,
X	"keyTurnRight",		KEY_TURN_RIGHT,
X	"keySelfDestruct",	KEY_SELF_DESTRUCT,
X	"keyIdMode",		KEY_ID_MODE,
X	"keyPause",		KEY_PAUSE,
X	"keyToggleVelocity",	KEY_TOGGLE_VELOCITY,
X	"keyToggleCompass",	KEY_TOGGLE_COMPASS,
X	"keySwapSettings",	KEY_SWAP_SETTINGS,
X	"keyRefuel",		KEY_REFUEL,
X	"keyIncreasePower",	KEY_INCREASE_POWER,
X	"keyDecreasePower",	KEY_DECREASE_POWER,
X	"keyIncreaseTurnspeed",	KEY_INCREASE_TURNSPEED,
X	"keyDecreaseTurnspeed",	KEY_DECREASE_TURNSPEED,
X	"keyThrust",		KEY_THRUST,
X	"keyCloak",		KEY_CLOAK,
X	"keySlowdown",		KEY_SLOWDOWN,
X	"keySpeedup",		KEY_SPEEDUP
X    };
X    static struct _keyDefs keyDefs[MAX_KEY_DEFS] =
X    {
X	XK_Left,		KEY_LOCK_PREV,
X	XK_Right,		KEY_LOCK_NEXT,
X	XK_Next,		KEY_LOCK_NEXT,
X	XK_Prior,		KEY_LOCK_PREV,
X	XK_Up,			KEY_LOCK_CLOSE,
X	XK_Down,		KEY_LOCK_CLOSE,
X	XK_Select,		KEY_LOCK_CLOSE,
X	XK_Home,		KEY_CHANGE_HOME,
X	XK_Meta_R,		KEY_SHIELD,
X	XK_space,		KEY_SHIELD,
X	XK_Return,		KEY_FIRE_SHOT,
X	XK_backslash,		KEY_FIRE_MISSILE,
X	XK_Linefeed,		KEY_FIRE_MISSILE,
X	XK_Tab,			KEY_DROP_MINE,
X	XK_a,			KEY_TURN_LEFT,
X	XK_s,			KEY_TURN_RIGHT,
X	XK_q,			KEY_SELF_DESTRUCT,
X	XK_i,			KEY_ID_MODE,
X	XK_p,			KEY_PAUSE,
X	XK_v,			KEY_TOGGLE_VELOCITY,
X	XK_c,			KEY_TOGGLE_COMPASS,
X	XK_Escape,		KEY_SWAP_SETTINGS,
X	XK_f,			KEY_REFUEL,
X	XK_Control_L,		KEY_REFUEL,
X	XK_KP_Multiply,		KEY_INCREASE_POWER,
X	XK_KP_Divide,		KEY_DECREASE_POWER,
X	XK_KP_Add,		KEY_INCREASE_TURNSPEED,
X	XK_KP_Subtract,		KEY_DECREASE_TURNSPEED,
X	XK_Shift_L,		KEY_THRUST,
X	XK_Shift_R,		KEY_THRUST,
X	XK_Delete,		KEY_CLOAK,
X	XK_BackSpace,		KEY_CLOAK,
X	XK_bracketright,	KEY_SPEEDUP,
X	XK_bracketleft,		KEY_SLOWDOWN
X    };
X
X
X    /*
X     * Defaults.
X     */
X    pl->power			= 45.0;
X    pl->turnspeed		= 30.0;
X    pl->turnresistance		= 0.12;
X
X    pl->power_s			= 35.0;
X    pl->turnspeed_s		= 25.0;
X    pl->turnresistance_s	= 0.12;
X    pl->team			= 0;
X    pl->fuel3			= 500.0;
X    pl->fuel2			= 200.0;
X    pl->fuel1			= 100.0;
X    pl->instruments		= SHOW_HUD_INSTRUMENTS | SHOW_HUD_HORIZONTAL;
X    bcopy(keyDefs, pl->keyDefs, sizeof(keyDefs));
X
X    /*
X     * Name
X     */
X    if (pl->name[0] == '\0') {
X	if ((pl->disp != NULL)
X	    && (str = XGetDefault(pl->disp, "xpilot", "name")) != NULL)
X	    strncpy(pl->name, str, MAX_NAME_LEN);
X	else
X	    strcpy(pl->name, pl->realname);
X    }
X    CAP_LETTER(pl->name[0]);
X
X
X    /*
X     * Control sensitivity.
X     */
X    str = XGetDefault(pl->disp, "xpilot", "power");
X    if (str)
X	pl->power = atod(str);
X    str = XGetDefault(pl->disp, "xpilot", "turnSpeed");
X    if (str)
X	pl->turnspeed = atod(str);
X    str = XGetDefault(pl->disp, "xpilot", "turnResistance");
X    if (str)
X	pl->turnresistance = atod(str);
X
X    str = XGetDefault(pl->disp, "xpilot", "altPower");
X    if (str)
X	pl->power_s = atod(str);
X    str = XGetDefault(pl->disp, "xpilot", "altTurnSpeed");
X    if (str)
X	pl->turnspeed_s = atod(str);
X    str = XGetDefault(pl->disp, "xpilot", "altTurnResistance");
X    if (str)
X	pl->turnresistance_s = atod(str);
X
X
X    /*
X     * Misc. data, fuel limits on HUD.
X     */
X    str = XGetDefault(pl->disp, "xpilot", "team");
X    if (str)
X	pl->team = atoi(str);
X    str = XGetDefault(pl->disp, "xpilot", "fuelNotify");
X    if (str)
X	pl->fuel3 = atod(str);
X    str = XGetDefault(pl->disp, "xpilot", "fuelWarning");
X    if (str)
X	pl->fuel2 = atod(str);
X    str = XGetDefault(pl->disp, "xpilot", "fuelCritical");
X    if (str)
X	pl->fuel1 = atod(str);
X    
X    /*
X     * Instruments.
X     */
X
X    /* HUD */
X    str = XGetDefault(pl->disp, "xpilot", "showHUD");
X    if (str) {
X	if (ON(str)) {
X	    SET_BIT(pl->instruments, SHOW_HUD_INSTRUMENTS);
X	} else {
X	    CLR_BIT(pl->instruments, SHOW_HUD_INSTRUMENTS);
X	}
X    }
X    str = XGetDefault(pl->disp, "xpilot", "verticalHUDLine");
X    if (str) {
X	if (ON(str)) {
X	    SET_BIT(pl->instruments, SHOW_HUD_VERTICAL);
X	} else {
X	    CLR_BIT(pl->instruments, SHOW_HUD_VERTICAL);
X	}
X    }
X    str = XGetDefault(pl->disp, "xpilot", "horizontalHUDLine");
X    if (str) {
X	if (ON(str)) {
X	    SET_BIT(pl->instruments, SHOW_HUD_HORIZONTAL);
X	} else {
X	    CLR_BIT(pl->instruments, SHOW_HUD_HORIZONTAL);
X	}
X    }
X
X    /* FUEL */
X    str = XGetDefault(pl->disp, "xpilot", "fuelMeter");
X    if (str) {
X	if (ON(str)) {
X	    SET_BIT(pl->instruments, SHOW_FUEL_METER);
X	} else {
X	    CLR_BIT(pl->instruments, SHOW_FUEL_METER);
X	}
X    }
X    str = XGetDefault(pl->disp, "xpilot", "fuelGauge");
X    if (str) {
X	if (ON(str)) {
X	    SET_BIT(pl->instruments, SHOW_FUEL_GAUGE);
X	} else {
X	    CLR_BIT(pl->instruments, SHOW_FUEL_GAUGE);
X	}
X    }
X
X    /* Misc. meters. */
X    str = XGetDefault(pl->disp, "xpilot", "turnSpeedMeter");
X    if (str) {
X	if (ON(str)) {
X	    SET_BIT(pl->instruments, SHOW_TURNSPEED_METER);
X	} else {
X	    CLR_BIT(pl->instruments, SHOW_TURNSPEED_METER);
X	}
X    }
X    str = XGetDefault(pl->disp, "xpilot", "powerMeter");
X    if (str) {
X	if (ON(str)) {
X	    SET_BIT(pl->instruments, SHOW_POWER_METER);
X	} else {
X	    CLR_BIT(pl->instruments, SHOW_POWER_METER);
X	}
X    }
X
X    /* key bindings */
X    for (i = 0; i < NELEM(keyResources); i++)
X	if (str = XGetDefault(pl->disp, "xpilot", keyResources[i].resource))
X	{
X	    KeySym ks;
X	    char *p, *p1;
X	    int j;
X
X	    p1 = (char *)malloc(sizeof(char) * strlen(str));
X	    strcpy(p1, str);
X	    p = strtok(p1, " \t\n");
X
X	    while (p) {
X		if ((ks = XStringToKeysym(p)) == NoSymbol) {
X		    printf("%s is not a valid keysym.\n", p);
X		    break;
X		}
X
X		for (j = 0; j < MAX_KEY_DEFS; j++)
X		    if (!pl->keyDefs[j].keysym || pl->keyDefs[j].keysym == ks) {
X			pl->keyDefs[j].keysym = ks;
X			pl->keyDefs[j].key = keyResources[i].key;
X			break;
X		    }
X
X		if (j >= MAX_KEY_DEFS) {
X		    printf("Too may key definitions.  Only %d allowed.\n",
X			   MAX_KEY_DEFS);
X		    i = NELEM(keyResources);
X		    break;
X		}
X
X		p = strtok(NULL, " \t\n");
X	    }
X
X	    free(p1);
X	}
X}
END_OF_FILE
echo shar: 1 control character may be missing from \"'src/default.c'\"
if test 6943 -ne `wc -c <'src/default.c'`; then
    echo shar: \"'src/default.c'\" unpacked with wrong size!
fi
# end of 'src/default.c'
fi
if test -f 'src/draw.c' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/draw.c'\"
else
echo shar: Extracting \"'src/draw.c'\" \(35828 characters\)
sed "s/^X//" >'src/draw.c' <<'END_OF_FILE'
X/* $Id: draw.c,v 1.14 1992/07/10 21:41:00 bjoerns Exp $
X *
X *	This file is part of the XPilot project, written by
X *
X *	    Bjxrn Stabell (bjoerns@stud.cs.uit.no)
X *	    Ken Ronny Schouten (kenrsc@stud.cs.uit.no)
X *
X *	Copylefts are explained in the LICENSE file.
X */
X
X#include <X11/Xproto.h>
X#include <X11/Xlib.h>
X#include <X11/Xos.h>
X
X#include <stdio.h>
X#include <math.h>
X
X#include "global.h"
X#include "map.h"
X#include "draw.h"
X#include "version.h"
X
X#ifndef	lint
Xstatic char sourceid[] =
X    "@(#)$Id: draw.c,v 1.14 1992/07/10 21:41:00 bjoerns Exp $";
X#endif
X
X
X#define X(i, co)  ((int) ((co) - Players[i]->world.x))
X#define Y(i, co)  ((int) (FULL-((co) - Players[i]->world.y)))
X
X#define Draw_meter(_p, x, y, title, per)				\
X{									\
X    player *p=(_p);							\
X    XSetForeground(p->disp, p->gc, p->colors[RED].pixel);		\
X    XFillRectangle(p->disp, p->p_draw, p->gc, x+2, y+2,			\
X		   (int)(298*per), 8);					\
X    XSetForeground(p->disp, p->gc, p->colors[WHITE].pixel);		\
X    XDrawRectangle(p->disp, p->p_draw, p->gc, x, y, 300, 10);		\
X    XDrawLine(p->disp, p->p_draw, p->gc, x, y-4, x, y+14);		\
X    XDrawLine(p->disp, p->p_draw, p->gc, x+300, y-3, x+300, y+13);	\
X    XDrawLine(p->disp, p->p_draw, p->gc, x+150, y-3, x+150, y+13);	\
X    XDrawLine(p->disp, p->p_draw, p->gc, x+75, y-1, x+75, y+11);	\
X    XDrawLine(p->disp, p->p_draw, p->gc, x+225, y-1, x+225, y+11);	\
X    XDrawString(p->disp, p->p_draw, p->gc, (x)+305, (y)+10,		\
X		title, strlen(title));					\
X}
X
X#define UNKOWN_PLAYER	"* Unknown *"
X#define NO_PLAYER	"** None **"
X
X
X/*
X * Globals.
X */
Xunsigned long		loops = 0;
Xmessage_t		*Msg[MAX_MSGS];
X
Xstatic XPoint		points[5];
Xstatic XGCValues	gcv;
X
XXPoint	diamond[] = {
X    { 0, -DSIZE },
X    { DSIZE, -DSIZE },
X    { -DSIZE, -DSIZE },
X    { -DSIZE, DSIZE },
X    { DSIZE, DSIZE }
X};
X
X
X
X#ifdef SCROLL
Xchar *scroll(char *string, int start, int length)
X{
X    static char str[MAX_SCROLL_LEN];
X    int i;
X    
X    
X    for (i=0; string[i+start] && i<length; i++)
X	str[i] = string[i+start];
X    
X    str[length]='\0';
X    return (str);
X}
X#endif
X
X
X
Xvoid Draw_objects()
X{
X    static long scroll_i = 0;
X    int i, j;
X    player *dr;
X    
X    
X    if (++loops >= ULONG_MAX)	    /* Used for misc. timing purposes */
X	loops = 0;
X    
X#ifdef SCROLL
X    if ((loops%SCROLL_DELAY) == 0)
X	if (++scroll_i >= ULONG_MAX)
X	    scroll_i = 0;
X#else
X    if ((loops%TITLE_DELAY) == 0)
X	scroll_i = !scroll_i;
X#endif
X    
X    for(j=0; j<NumPlayers; j++) {
X	dr = Players[j];
X	if (dr->disp_type == DT_NONE)
X	    continue;
X
X	XSync(dr->disp, False);
X	
X	/*
X	 * If status is GAME_OVER, the user may look through the other
X	 * players 'eyes'.  This is done by using two indexes, one determining
X	 * which data should be used (i, set below) and one determining where
X	 * to draw it (j).
X	 */
X	if (BIT(dr->status, GAME_OVER) && (BIT(dr->status, PLAYING)) &&
X	    (dr->lock.tagged == LOCK_PLAYER))
X	    i = GetInd[dr->lock.pl_id];
X	else
X	    i = j;
X	
X#ifdef SCROLL
X	/*
X	 * Scroll a message in the window title.
X	 */
X	if ((loops%SCROLL_DELAY) == 0)
X	    XStoreName(dr->disp, dr->top,
X		       scroll(dr->scroll, scroll_i%dr->scroll_len, SCROLL_LEN));
X#else
X	/*
X	 * Switch between two different window titles.
X	 */
X	if ((loops%TITLE_DELAY) == 0) {
X	    if (scroll_i)
X		XStoreName(dr->disp, dr->top, COPYRIGHT);
X	    else
X		XStoreName(dr->disp, dr->top, TITLE);
X	    
X	}
X#endif
X	
X	gcv.dash_offset = 0;
X	Display_hud(j, i);
X	Draw_world(j, i);
X	Draw_shots(j, i);
X	gcv.dash_offset = DASHES_LENGTH-(loops%DASHES_LENGTH);
X	Draw_ships(j, i);
X	XSetForeground(dr->disp, dr->gc, dr->colors[WHITE].pixel);
X	Draw_cannon(j, i);
X	/*
X	  old stuff, will be totally removed
X	  if (BIT(Players[i]->used, OBJ_COMPASS))
X	  Display_compass(j, i);
X	  
X	  if (BIT(Players[i]->status, VELOCITY_GAUGE))
X	  Display_velocity_gauge(j, i);
X	  
X	  if (BIT(Players[i]->status, POWER_GAUGE))
X	  Display_power_gauge(j, i);
X	  
X	  if (BIT(World.rules->mode, TIMING))
X	  Display_time(j, i);
X	  */
X	if (BIT(Players[i]->instruments, SHOW_FUEL_GAUGE))
X	    Display_fuel_gauge(j, i);
X	
X	Draw_meters(j, i);
X	
X	Display_message(j, i);
X	
X	Draw_radar(j, i);
X	
X	/*
X	 * Now switch planes and clear the screen.
X	 */
X	dbuff_switch(j, dr->dbuf_state);
X	if (dr->p_radar != dr->radar)
X	    XCopyArea(dr->disp, dr->p_radar, dr->radar, dr->gc,
X		      0, 0, 256, RadarHeight, 0, 0);
X	if (dr->p_draw != dr->draw)
X	    XCopyArea(dr->disp, dr->p_draw, dr->draw, dr->gc,
X		      0, 0, 768, 768, 0, 0);
X
X	if (BIT(dr->disp_type, DT_HAVE_PLANES))
X	    XSetPlaneMask(dr->disp, dr->gc, dr->dbuf_state->drawing_planes);
X
X	XSetPlaneMask(dr->disp, dr->gc, dr->dbuf_state->drawing_planes);
X	XSetForeground(dr->disp, dr->gc, dr->colors[BLACK].pixel);
X	XFillRectangle(dr->disp, dr->p_draw, dr->gc, 0, 0, 768, 768);
X	/*	XFlush(dr->disp);   */
X    }
X}
X
X
Xvoid Draw_ships(int draw, int data)
X{
X    int i;
X    player *dr = Players[draw];
X    player *pl = Players[data];
X    player *pl_i;
X    unsigned long mask=0;
X    
X    
X    for(i=0; i<NumPlayers; i++) {
X	pl_i = Players[i];
X	if (BIT(pl_i->status, PLAYING|PAUSE) &&
X	    (!BIT(pl_i->status, GAME_OVER)) &&
X	    (pl->world.x < pl_i->pos.x) &&
X	    (pl->world.x+FULL > pl_i->pos.x) &&
X	    (pl->world.y  < pl_i->pos.y) &&
X	    (pl->world.y+FULL > pl_i->pos.y)) {
X	    
X	    if (BIT(pl_i->status, PAUSE)) {
X		
X		XSetForeground(dr->disp, dr->gc, dr->colors[BLUE].pixel);
X		
X		XFillRectangle(dr->disp, dr->p_draw, dr->gc,
X			       X(data, pl_i->pos.x-10),
X			       Y(data, pl_i->pos.y+13),
X			       20, 26);
X		
X		XSetForeground(dr->disp, dr->gc, dr->colors[WHITE].pixel);
X		
X		if (pl_i->count<=0 || (loops%10)>=5) {
X		    XDrawRectangle(dr->disp, dr->p_draw, dr->gc,
X				   X(data, pl_i->pos.x-10),
X				   Y(data, pl_i->pos.y+13),
X				   20, 26);
X		    
X		    XDrawString(dr->disp, dr->p_draw, dr->gc,
X				X(data, pl_i->pos.x-2),
X				Y(data, pl_i->pos.y-4),
X				"P", 1);
X		}
X		continue;
X	    }
X	    
X	    if (!pl->visibility[i].canSee && i!=data && !TEAM(i, draw))
X		continue;
X	    
X	    points[0].x = X(data, pl_i->pos.x + ships[pl_i->dir].pts[0].x);
X	    points[0].y = Y(data, pl_i->pos.y + ships[pl_i->dir].pts[0].y);
X	    points[1].x = X(data, pl_i->pos.x + ships[pl_i->dir].pts[1].x);
X	    points[1].y = Y(data, pl_i->pos.y + ships[pl_i->dir].pts[1].y);
X	    points[2].x = X(data, pl_i->pos.x + ships[pl_i->dir].pts[2].x);
X	    points[2].y = Y(data, pl_i->pos.y + ships[pl_i->dir].pts[2].y);
X	    points[3].x = X(data, pl_i->pos.x + ships[pl_i->dir].pts[0].x);
X	    points[3].y = Y(data, pl_i->pos.y + ships[pl_i->dir].pts[0].y);
X	    
X	    XSetForeground(dr->disp, dr->gc, dr->colors[pl_i->color].pixel);
X	    
X	    /*
X	     * Determine if you the name of the player should be drawn below
X	     * his/her ship.
X	     */
X	    if ((BIT(pl->status, ID_MODE) && (data!=i)) ||
X		((draw != data) && (i == data)))
X		XDrawString(dr->disp, dr->p_draw, dr->gc,
X			    X(data, pl_i->pos.x-pl_i->name_length/2),
X			    Y(data,pl_i->pos.y-30),
X			    pl_i->name, strlen(pl_i->name));
X	    
X	    if (BIT(pl_i->used, OBJ_REFUEL|OBJ_SHIELD|OBJ_CLOAKING_DEVICE)) {
X		
X		mask = GCLineStyle;
X		gcv.line_style = LineOnOffDash;
X		
X#ifndef NO_ROTATING_DASHES
X		mask |= GCDashOffset;
X#endif
X		XChangeGC(dr->disp, dr->gc, mask, &gcv);
X		
X		if (BIT(pl_i->used, OBJ_CLOAKING_DEVICE))
X		    XDrawLines(dr->disp, dr->p_draw, dr->gc, points, 4, 0);
X		
X		if (BIT(pl_i->used, OBJ_REFUEL)) {
X		    XDrawLine(dr->disp, dr->p_draw, dr->gc,
X			      X(data, World.fuel[pl_i->fs].pos.x),
X			      Y(data, World.fuel[pl_i->fs].pos.y),
X			      X(data, pl_i->pos.x),
X			      Y(data, pl_i->pos.y));
X		}
X		
X		if (BIT(pl_i->used, OBJ_SHIELD)) 
X		    XDrawArc(dr->disp, dr->p_draw, dr->gc,
X			     X(data,pl_i->pos.x - 17),
X			     Y(data,pl_i->pos.y + 17),
X			     34, 34, 0, 64 * 360);
X	    } 
X	    
X	    gcv.line_style = LineSolid;
X	    XChangeGC(dr->disp, dr->gc, GCLineStyle, &gcv);
X	    
X	    if (!BIT(pl_i->used, OBJ_CLOAKING_DEVICE) &&
X		((i == data) || pl->visibility[i].canSee)) {
X		if (pl->lock.tagged==LOCK_PLAYER && GetInd[pl->lock.pl_id]==i)
X		    XFillPolygon(dr->disp, dr->p_draw, dr->gc, points, 4,
X				 Convex, CoordModeOrigin);
X		else
X		    XDrawLines(dr->disp, dr->p_draw, dr->gc, points, 4, 0);
X	    }
X	}
X    }
X}
X
X
X
Xvoid Draw_shots(int draw, int data)
X{
X    int i, x, y;
X    char str[2];
X    player *pl = Players[data];
X    player *dr = Players[draw];
X    object *shot;
X    
X    
X    for(i=0; i<NumObjs; i++) {
X	shot = Obj[i];
X	
X	if (shot->pos.x >= pl->world.x && shot->pos.x < pl->world.x+FULL &&
X	    shot->pos.y >= pl->world.y && shot->pos.y < pl->world.y+FULL) {
X	    
X	    x = X(data, shot->pos.x);
X	    y = Y(data, shot->pos.y);
X	    
X	    if ((shot->id!=-1) &&
X		(TEAM(data, GetInd[shot->id])) && (shot->id != pl->id) &&
X		(shot->type != OBJ_CANNON_DEBRIS)) 
X		XSetForeground(dr->disp, dr->gc, dr->colors[BLUE].pixel);
X	    else
X		XSetForeground(dr->disp, dr->gc, dr->colors[shot->color].pixel);
X	    
X	    switch (shot->type) {
X	    case OBJ_SHOT:
X	    case OBJ_CANNON_SHOT:
X		XDrawRectangle(dr->disp, dr->p_draw, dr->gc, x, y, 2, 2);
X		break;
X	    case OBJ_SPARK:
X	    case OBJ_DEBRIS:
X	    case OBJ_CANNON_DEBRIS:
X		if (!BIT(dr->disp_type, DT_HAVE_COLOR))
X		    XDrawPoint(dr->disp, dr->p_draw, dr->gc, x, y);
X		else
X		    XDrawRectangle(dr->disp, dr->p_draw, dr->gc, x, y, 2, 2);
X		break;
X
X	    case OBJ_SMART_SHOT:
X		XSetLineAttributes(dr->disp, dr->gc, 4,
X				   LineSolid, CapButt, JoinMiter);
X		
X		XDrawLine(dr->disp, dr->p_draw, dr->gc,
X			  x, y,
X			  (int)(x-tcos(shot->dir)*SMART_SHOT_LEN),
X			  (int)(y+tsin(shot->dir)*SMART_SHOT_LEN));
X		
X		XSetLineAttributes(dr->disp, dr->gc, 0,
X				   LineSolid, CapButt, JoinMiter);
X		break;
X
X	    case OBJ_MINE:
X		XDrawArc(dr->disp, dr->p_draw, dr->gc, x, y, 8, 8, 0, 64*360);
X		break;
X	    case OBJ_WIDEANGLE_SHOT:
X		str[0] = 'W';
X		goto draw;
X		break;
X	    case OBJ_REAR_SHOT:
X		str[0] = 'R';
X		goto draw;
X		break;
X	    case OBJ_SMART_SHOT_PACK:
X		str[0] = 'S';
X		goto draw;
X		break;
X	    case OBJ_ENERGY_PACK:
X		str[0] = 'F';
X		goto draw;
X		break;
X	    case OBJ_MINE_PACK:
X		str[0] = 'M';
X		goto draw;
X		break;
X	    case OBJ_SENSOR_PACK:
X		str[0] = 'I';
X		goto draw;
X		break;
X	    case OBJ_CLOAKING_DEVICE:
X		str[0] = 'C';
X	    draw:
X		points[0].x = x-10;
X		points[0].y = y+10;
X		points[1].x = x;
X		points[1].y = y-10;
X		points[2].x = x+10;
X		points[2].y = y+10;
X		points[3].x = x-10;
X		points[3].y = y+10;
X		
X		XDrawLines(dr->disp, dr->p_draw, dr->gc,
X			   points, 4, CoordModeOrigin);
X		str[1] = '\0';
X		XDrawString(dr->disp, dr->p_draw, dr->gc, x-3, y+8, str, 1);
X		break;
X
X	    default:
X		error("Draw_shots: Shot type %d not defined.", shot->type);
X		break;
X	    }
X	}
X    }
X}
X
X
Xvoid Draw_meters(int draw, int data)
X{
X    player *dr=Players[draw], *pl=Players[data];
X
X
X    if (BIT(pl->instruments, SHOW_FUEL_METER) ||
X	(pl->fuel_count && !BIT(pl->instruments, SHOW_FUEL_GAUGE)))
X	Draw_meter(dr, 10, 10, "Fuel", (pl->fuel/pl->max_fuel));
X    if (BIT(pl->instruments, SHOW_POWER_METER) || pl->control_count)
X	Draw_meter(dr, 10, 40, "Power", ((double)pl->power/MAX_PLAYER_POWER));
X    if (BIT(pl->instruments, SHOW_TURNSPEED_METER) || pl->control_count)
X	Draw_meter(dr, 10, 60, "Turnspeed",
X		   ((double)pl->turnspeed/MAX_PLAYER_TURNSPEED));
X    
X    if (BIT(pl->status, SELF_DESTRUCT) && pl->count>0)
X	Draw_meter(dr, (FULL-300)/2 -32, 3*FULL/4,
X		   "Self destructing", pl->count/150.0);
X    if (Shutdown != -1)
X	Draw_meter(dr, (FULL-300)/2 -32, 4*FULL/5,
X		   "SHUTDOWN", (double)Shutdown/(double)ShutdownDelay);
X    
X    /*	Draw_meter(dr, 10, 30, "Shots", ((double)pl->shots/pl->shot_max));  */
X}
X
X
X
Xvoid Display_hud(int draw, int data)
X{
X    player *dr=Players[draw], *pl=Players[data];
X    player *target=Players[GetInd[dr->lock.pl_id]];
X    int size, vert_pos;
X    char str[20];
X    double dx, dy, theta;
X    
X    
X    XSetForeground(dr->disp, dr->gc, dr->colors[BLUE].pixel);
X    
X    if (!BIT(pl->instruments, SHOW_HUD_INSTRUMENTS))
X	return;
X    
X    /*
X     * HUD frame.
X     */
X    gcv.line_style = LineOnOffDash;
X    XChangeGC(dr->disp, dr->gc, GCLineStyle | GCDashOffset, &gcv);
X    
X    if (BIT(pl->instruments, SHOW_HUD_HORIZONTAL)) {
X	XDrawLine(dr->disp, dr->p_draw, dr->gc,
X		  CENTER-HUD_SIZE, CENTER-HUD_SIZE+HUD_OFFSET,
X		  CENTER+HUD_SIZE, CENTER-HUD_SIZE+HUD_OFFSET);
X	XDrawLine(dr->disp, dr->p_draw, dr->gc,
X		  CENTER-HUD_SIZE, CENTER+HUD_SIZE-HUD_OFFSET,
X		  CENTER+HUD_SIZE, CENTER+HUD_SIZE-HUD_OFFSET);
X    }
X    if (BIT(pl->instruments, SHOW_HUD_VERTICAL)) {
X	XDrawLine(dr->disp, dr->p_draw, dr->gc,
X		  CENTER-HUD_SIZE+HUD_OFFSET, CENTER-HUD_SIZE, 
X		  CENTER-HUD_SIZE+HUD_OFFSET, CENTER+HUD_SIZE);
X	XDrawLine(dr->disp, dr->p_draw, dr->gc,
X		  CENTER+HUD_SIZE-HUD_OFFSET, CENTER-HUD_SIZE,
X		  CENTER+HUD_SIZE-HUD_OFFSET, CENTER+HUD_SIZE);
X    }
X    gcv.line_style = LineSolid;
X    XChangeGC(dr->disp, dr->gc, GCLineStyle, &gcv);
X    
X    
X    /*
X     * Special items.
X     */
X    vert_pos = CENTER - HUD_SIZE + HUD_OFFSET;
X    
X    if (pl->mines > 0) {
X	vert_pos += HUD_ITEMS_SPACE;
X	sprintf(str, "M%02d", pl->mines);
X	XDrawString(dr->disp, dr->p_draw, dr->gc,
X		    CENTER-HUD_SIZE-4, vert_pos, str, 3);
X    }
X    if (pl->missiles > 0) {
X	vert_pos += HUD_ITEMS_SPACE;
X	sprintf(str, "S%02d", pl->missiles);
X	XDrawString(dr->disp, dr->p_draw, dr->gc,
X		    CENTER-HUD_SIZE-4, vert_pos, str, 3);
X    }
X    if (pl->cloaks > 0) {
X	vert_pos += HUD_ITEMS_SPACE;
X	sprintf(str, "C%02d", pl->cloaks);
X	XDrawString(dr->disp, dr->p_draw, dr->gc,
X		    CENTER-HUD_SIZE-4, vert_pos, str, 3);
X    }
X    if (pl->sensors > 0) {
X	vert_pos += HUD_ITEMS_SPACE;
X	sprintf(str, "I%02d", pl->sensors);
X	XDrawString(dr->disp, dr->p_draw, dr->gc,
X		    CENTER-HUD_SIZE-4, vert_pos, str, 3);
X    }
X    if (pl->extra_shots > 0) {
X	vert_pos += HUD_ITEMS_SPACE;
X	sprintf(str, "W%02d", pl->extra_shots);
X	XDrawString(dr->disp, dr->p_draw, dr->gc,
X		    CENTER-HUD_SIZE-4, vert_pos, str, 3);
X    }
X    if (BIT(pl->have, OBJ_REAR_SHOT)) {
X	vert_pos += HUD_ITEMS_SPACE;
X	str[0] = 'R';
X	XDrawString(dr->disp, dr->p_draw, dr->gc,
X		    CENTER-HUD_SIZE-4, vert_pos,
X		    str, 1);
X    }
X    
X    
X    /* Fuel notify, HUD meter on */
X    if (pl->fuel_count || pl->fuel<pl->fuel3) {
X	sprintf(str, "%4.0f", pl->fuel);
X	XDrawString(dr->disp, dr->p_draw, dr->gc, CENTER+HUD_SIZE-HUD_OFFSET+2,
X		    CENTER+HUD_SIZE-HUD_OFFSET/2+6, str, 4);
X    }
X    
X    /*
X     * Display direction arrow and miscellaneous target information.
X     */
X    switch (pl->lock.tagged) {
X    case LOCK_PLAYER:
X	dx=(target->pos.x - pl->pos.x);
X	dy=(target->pos.y - pl->pos.y);
X	if ((BIT(World.rules->mode, LIMITED_VISIBILITY) &&
X	     (pl->lock.distance > pl->sensor_range)) ||
X	    (!pl->visibility[GetInd[target->id]].canSee &&
X	     !TEAM(data, GetInd[dr->lock.pl_id])) ||
X	    (dy==0.0 && dx==0.0))
X	    goto no_target;
X	sprintf(str, "%03d", (int)(pl->lock.distance/BLOCK_SZ));
X	XDrawString(dr->disp, dr->p_draw, dr->gc,
X		    CENTER+HUD_SIZE-HUD_OFFSET+2,
X		    CENTER-HUD_SIZE+HUD_OFFSET/2+3, str, 3);
X	break;
X	
X    case LOCK_NONE:
X	goto no_target;
X	break;
X	
X    default:
X	error("Unkown pl->lock.tagged.");
X	break;
X    }
X    
X    theta=atan2(dy, dx);	/* Only works for LOCK_PLAYER */
X    
X    if ((pl->lock.distance>WARNING_DISTANCE) || ((loops%2)==0)) {
X	size = 10000/(800+pl->lock.distance);
X	if (TEAM(data, GetInd[pl->lock.pl_id]))
X	    XDrawArc(dr->disp, dr->p_draw, dr->gc,
X		     (int)(CENTER+HUD_SIZE*0.6*cos(theta)),
X		     (int)(CENTER-HUD_SIZE*0.6*sin(theta)),
X		     size, size, 0, 64*360);
X	else
X	    XFillArc(dr->disp, dr->p_draw, dr->gc,
X		     (int)(CENTER+HUD_SIZE*0.6*cos(theta)),
X		     (int)(CENTER-HUD_SIZE*0.6*sin(theta)),
X		     size, size, 0, 64*360);
X    }
X    
X    size=strlen(target->name);
X    XDrawString(dr->disp, dr->p_draw, dr->gc,
X		CENTER-target->name_length/2, CENTER-HUD_SIZE+HUD_OFFSET/2+3,
X		target->name, size);
X    
X    
X    /* Fuel gauge, must be last */
X no_target:
X    
X    if (!((pl->fuel_count) ||
X	  (pl->fuel<pl->fuel3 &&
X	   ((pl->fuel<pl->fuel1 && (loops%4)<2) ||
X	    (pl->fuel<pl->fuel2 && pl->fuel>pl->fuel1 && (loops%8)<4) ||
X	    (pl->fuel>pl->fuel2)))))
X	return;
X    
X    XDrawRectangle(dr->disp, dr->p_draw, dr->gc,
X		   CENTER+HUD_SIZE-HUD_OFFSET+FUEL_GAUGE_OFFSET-1,
X		   CENTER-HUD_SIZE+HUD_OFFSET+FUEL_GAUGE_OFFSET-1,
X		   HUD_OFFSET-(2*FUEL_GAUGE_OFFSET)+2,
X		   HUD_FUEL_GAUGE_SIZE+2);
X    
X    size = pl->fuel/pl->max_fuel*HUD_FUEL_GAUGE_SIZE;
X    XFillRectangle(dr->disp, dr->p_draw, dr->gc,
X		   CENTER+HUD_SIZE-HUD_OFFSET+FUEL_GAUGE_OFFSET,
X		   CENTER-HUD_SIZE+HUD_OFFSET+FUEL_GAUGE_OFFSET
X		   + (HUD_FUEL_GAUGE_SIZE-size),
X		   HUD_OFFSET-(2*FUEL_GAUGE_OFFSET), size);
X    
X    XSetFillStyle(dr->disp, dr->gc, FillSolid);		/* Reset fill style */
X}
X
X
Xvoid Display_fuel_gauge(int draw, int data)
X{
X    int percent;
X    player *pl = Players[data];
X    player *dr = Players[draw];
X    
X    
X    XSetForeground(dr->disp, dr->gc, dr->colors[WHITE].pixel);
X    
X    XDrawArc(dr->disp, dr->p_draw, dr->gc,
X	     730 - 120, 36 - 30,
X	     60, 60, 0, 64 * 360);
X    
X    XSetForeground(dr->disp, dr->gc, dr->colors[RED].pixel);
X    
X    percent = 64*(pl->fuel/pl->max_fuel)*360;
X    XFillArc(dr->disp, dr->p_draw, dr->gc,
X	     730 - 119, 36 - 29,
X	     58, 58, 90*64 - percent,
X	     (int)percent);
X    
X    XSetForeground(dr->disp, dr->gc, dr->colors[WHITE].pixel);
X    
X    XDrawLine(dr->disp, dr->p_draw, dr->gc,
X	      730-120+30, 36, 730-120+30, 6);
X}
X
X
X#if 0
Xvoid Display_velocity_gauge(int draw, int data)
X{
X    double theta;
X    player *dr = Players[draw];
X    player *pl = Players[data];
X    
X    
X    XSetForeground(dr->disp, dr->gc, 
X		   dr->colors[WHITE].pixel);
X    
X    XDrawArc(dr->disp, dr->p_draw, 
X	     dr->gc,
X	     730 - 210, 36 - 30,
X	     60, 60, 0, 64 * 360);	
X    
X    XDrawLine(dr->disp, dr->p_draw,
X	      dr->gc, 730-210+30, 36, 730-210+30, 6);
X    
X    
X    XSetForeground(dr->disp, dr->gc, 
X		   dr->colors[RED].pixel);
X    
X    theta = 5*PI/2 - ((pl->velocity/pl->max_speed)*2*PI);
X    XDrawLine(dr->disp, dr->p_draw, dr->gc, 730-210+30, 36,
X	      (int)(730-210+30+25*cos(theta)), (int)(36 - 25*sin(theta)));
X    
X}
X
X
Xvoid Display_power_gauge(int draw, int data)
X{
X    int percent;
X    player *dr = Players[draw];
X    
X    
X    XSetForeground(dr->disp, dr->gc, dr->colors[WHITE].pixel);
X    
X    XDrawArc(dr->disp, dr->p_draw, dr->gc,
X	     730 - 300, 36 - 30,
X	     60, 60, 0, 64 * 360);  
X    
X    XSetForeground(dr->disp, dr->gc, dr->colors[RED].pixel);
X    
X    percent=64*(Players[data]->power/MAX_PLAYER_POWER)*360;
X    XFillArc(dr->disp, dr->p_draw, dr->gc,
X	     730 - 299, 36 - 29,
X	     58, 58, 90*64 - percent,
X	     (int)percent);
X    
X    XSetForeground(dr->disp, dr->gc, dr->colors[WHITE].pixel);
X    
X    XDrawLine(dr->disp, dr->p_draw, dr->gc, 730-120+30, 36, 730-120+30, 6);
X}
X
Xvoid Display_compass(int draw, int data)
X{
X    char string[30];
X    double dx=0.0, dy=0.0, theta;
X    player *pl = Players[data];
X    player *dr = Players[draw];
X    int len, pl_ind = GetInd[pl->lock.pl_id];
X    
X    
X    switch (pl->lock.tagged) {
X
X    case LOCK_NONE:
X	strcpy(string, NO_PLAYER);
X	pl->lock.distance = DBL_MAX;
X	break;
X	
X    case LOCK_PLAYER:
X	dx = (Players[pl_ind]->pos.x - pl->pos.x);
X	dy = (Players[pl_ind]->pos.y - pl->pos.y);
X	if ((BIT(World.rules->mode, LIMITED_VISIBILITY) &&
X	     (pl->lock.distance > pl->sensor_range)) ||
X	    (!pl->visibility[pl_ind].canSee &&
X	     !TEAM(draw, GetInd[dr->lock.pl_id]))) {
X	    strcpy(string, UNKOWN_PLAYER);
X	} else {
X	    sprintf(string, "%s: %5.2f",
X		    Players[pl_ind]->name, pl->lock.distance/BLOCK_SZ);
X	}
X	break;
X	
X    default:
X	error("Unkown pl->lock.tagged.");
X	break;
X    }
X    len=strlen(string);
X    
X    if (TEAM(draw, GetInd[dr->lock.pl_id]) && 
X	pl->lock.tagged != LOCK_NONE)
X	XSetForeground(dr->disp, dr->gc, dr->colors[BLUE].pixel);
X    
X    XDrawArc(dr->disp, dr->p_draw, dr->gc, 730-30, 36-30, 60, 60, 0, 64*360);
X    
X    if ((dy != 0.0) || (dx != 0.0)) {
X	if (((BIT(World.rules->mode, LIMITED_VISIBILITY)) &&
X	     (pl->lock.distance>pl->sensor_range)))
X	    XDrawPoint(dr->disp, dr->p_draw, dr->gc, 730, 36);
X	else {
X	    if (BIT(Players[pl_ind]->status, INVISIBLE) &&
X		!TEAM(draw, GetInd[dr->lock.pl_id]))
X		theta = 2*PI*(double)rand()/RAND_MAX;
X	    else
X		theta = atan2(dy, dx);
X	    XDrawLine(dr->disp, dr->p_draw, dr->gc, 730, 36,
X		      (int)(730 + 25*cos(theta)),
X		      (int)(36 - 25*sin(theta)));
X	}
X    } else
X	theta = 0.0;
X    
X    if (pl->lock.distance < WARNING_DISTANCE)
X	XSetForeground(dr->disp, dr->gc, dr->colors[RED].pixel);
X    
X    XDrawString(dr->disp, dr->p_draw, dr->gc, 720-(4*len), 100, string, len);
X}
X#endif
X
X
Xvoid Draw_cannon(int draw, int data)
X{
X    player *pl = Players[data];
X    player *dr = Players[draw];
X    int i;
X    
X    
X    for (i=0; i<World.NumCannons; i++) {
X	if ((pl->world.x < (World.cannon[i].pos.x*BLOCK_SZ)) &&
X	    (pl->world.x+FULL > (World.cannon[i].pos.x*BLOCK_SZ)) &&
X	    (pl->world.y  < (World.cannon[i].pos.y*BLOCK_SZ)) &&
X	    (pl->world.y+FULL > (World.cannon[i].pos.y*BLOCK_SZ)) &&
X	    (World.cannon[i].dead_time == 0)) {
X	    
X	    switch (World.cannon[i].dir)
X	      {
X	      case DIR_UP:
X		points[0].x = World.cannon[i].pos.x*BLOCK_SZ;
X		points[0].y = World.cannon[i].pos.y*BLOCK_SZ;
X		points[1].x = World.cannon[i].pos.x*BLOCK_SZ+BLOCK_SZ;
X		points[1].y = World.cannon[i].pos.y*BLOCK_SZ;
X		points[2].x = World.cannon[i].pos.x*BLOCK_SZ+BLOCK_SZ/2;
X		points[2].y = World.cannon[i].pos.y*BLOCK_SZ+BLOCK_SZ/3;
X		break;
X
X	      case DIR_DOWN:
X		points[0].x = World.cannon[i].pos.x*BLOCK_SZ;
X		points[0].y = World.cannon[i].pos.y*BLOCK_SZ+BLOCK_SZ;
X		points[1].x = World.cannon[i].pos.x*BLOCK_SZ+BLOCK_SZ;
X		points[1].y = World.cannon[i].pos.y*BLOCK_SZ+BLOCK_SZ;
X		points[2].x = World.cannon[i].pos.x*BLOCK_SZ+BLOCK_SZ/2;
X		points[2].y = World.cannon[i].pos.y*BLOCK_SZ+2*BLOCK_SZ/3;
X		break;
X
X	      case DIR_RIGHT:
X		points[0].x = World.cannon[i].pos.x*BLOCK_SZ;
X		points[0].y = World.cannon[i].pos.y*BLOCK_SZ;
X		points[1].x = World.cannon[i].pos.x*BLOCK_SZ;
X		points[1].y = World.cannon[i].pos.y*BLOCK_SZ+BLOCK_SZ;
X		points[2].x = World.cannon[i].pos.x*BLOCK_SZ+BLOCK_SZ/3;
X		points[2].y = World.cannon[i].pos.y*BLOCK_SZ+BLOCK_SZ/2;
X		break;
X
X	      case DIR_LEFT:
X		points[0].x = World.cannon[i].pos.x*BLOCK_SZ+BLOCK_SZ;
X		points[0].y = World.cannon[i].pos.y*BLOCK_SZ;
X		points[1].x = World.cannon[i].pos.x*BLOCK_SZ+BLOCK_SZ;
X		points[1].y = World.cannon[i].pos.y*BLOCK_SZ+BLOCK_SZ;
X		points[2].x = World.cannon[i].pos.x*BLOCK_SZ+2*BLOCK_SZ/3;
X		points[2].y = World.cannon[i].pos.y*BLOCK_SZ+BLOCK_SZ/2;
X	        break;
X	    }
X	    
X	    points[0].x = X(data, points[0].x);
X	    points[1].x = X(data, points[1].x);
X	    points[2].x = X(data, points[2].x);
X	    points[3].x = points[0].x;
X	    
X	    points[0].y = Y(data, points[0].y);
X	    points[1].y = Y(data, points[1].y);
X	    points[2].y = Y(data, points[2].y);
X	    points[3].y = points[0].y;
X	    
X	    XDrawLines(dr->disp, dr->p_draw, dr->gc, points, 4, 0);
X	    
X	    World.cannon[i].active = true;
X	}
X    }
X}
X
X
X
Xvoid Display_message(int draw, int ind)
X{
X    player *dr = Players[draw];
X    int i;
X    
X    
X    for (i=0; i<MAX_MSGS; i++) {
X	if (Msg[i]->life-- > MSG_FLASH)
X	    XSetForeground(dr->disp, dr->gc, dr->colors[RED].pixel);
X	else if (Msg[i]->life > 0)
X	    XSetForeground(dr->disp, dr->gc, dr->colors[WHITE].pixel);
X	else
X	    Msg[i]->txt[0]='\0';
X	
X	XDrawString(dr->disp, dr->p_draw, dr->gc, 10, 755-(13*i),
X		    Msg[i]->txt, strlen(Msg[i]->txt));
X    }
X}
X
X
X
Xvoid Set_message(char *message)
X{
X    int i;
X    message_t *tmp;
X    
X    
X    tmp = Msg[MAX_MSGS-1];
X    for (i=MAX_MSGS-1; i>0; i--)
X	Msg[i] = Msg[i-1];
X    
X    Msg[0] = tmp;
X    
X    Msg[0]->life = MSG_DURATION;
X    strcpy(Msg[0]->txt, message);
X}
X
X
X
Xvoid Draw_radar(int draw, int data)
X{
X    int i;
X    player *pl = Players[data];
X    player *dr = Players[draw];
X    
X    if (dr->s_radar != dr->p_radar)
X	/* Draw static radar onto radar */
X	XCopyArea(dr->disp, dr->s_radar, dr->p_radar, dr->gc,
X		  0, 0, 256, RadarHeight, 0, 0);
X    else {
X	/* Clear radar */
X	XSetForeground(dr->disp, dr->gcr, dr->colors[BLACK].pixel);
X	XFillRectangle(dr->disp, dr->p_radar,
X		       dr->gcr, 0, 0, 256, RadarHeight);
X    }
X    
X    if (BIT(pl->mode, TIMING)) {
X	XSetForeground(dr->disp,
X		       dr->gcr, /* Checkpoint */
X		       dr->colors[WHITE].pixel);
X	
X	diamond[0].x = 256*World.check[pl->check].x/World.x;
X	diamond[0].y = RadarHeight -
X	    RadarHeight*World.check[pl->check].y/World.y+DSIZE;
X	XDrawLines(dr->disp, dr->p_radar,
X		   dr->gcr, diamond,
X		   5, CoordModePrevious);
X    }
X    
X    for(i=0; i<NumPlayers; i++) {
X	if (BIT(Players[i]->status, PLAYING) &&
X	    !BIT(Players[i]->status, GAME_OVER)) {
X	    
X	    if ((BIT(World.rules->mode, LIMITED_VISIBILITY) &&
X		 (LENGTH(pl->pos.x-Players[i]->pos.x,
X			 pl->pos.y-Players[i]->pos.y) > pl->sensor_range)) ||
X		(!pl->visibility[i].canSee && i!=data))
X		continue;
X	    
X	    if (data == i) {					/* You */
X		
X		if (loops%10 >= 8)
X		    XSetForeground(dr->disp, dr->gcr, dr->colors[BLACK].pixel);
X		else
X		    XSetForeground(dr->disp, dr->gcr, dr->colors[WHITE].pixel);
X		
X	    } else if ((GetInd[pl->lock.pl_id]==i) &&
X		       BIT(pl->used, OBJ_COMPASS) &&
X		       (pl->lock.tagged==LOCK_PLAYER)) {	/* Tagged */
X		
X		if (loops%4 >= 3)
X		    XSetForeground(dr->disp, dr->gcr, dr->colors[BLACK].pixel);
X		else
X		    XSetForeground(dr->disp, dr->gcr, dr->colors[WHITE].pixel);
X	    } else
X		XSetForeground(dr->disp, dr->gcr, dr->colors[WHITE].pixel);
X	    
X	    XDrawRectangle(dr->disp, dr->p_radar, dr->gcr,
X			   (int)(256*Players[i]->pos.x / (World.x*BLOCK_SZ)),
X			   (int)(RadarHeight
X				 - (RadarHeight*(Players[i]->pos.y/
X						  (World.y*BLOCK_SZ)))),
X			   2, 2);
X	}
X    }
X}
X
X
X
Xvoid Display_time(int draw, int data)
X{
X    static char string[MAX_STATUS_CHARS];
X    static char lap_name[MAX_CHARS] = "NOBODY";
X    static char run_name[MAX_CHARS] = "NOBODY";
X    static int best_lap = 0;
X    static int best_run = 0;
X    int i;
X    player *pl_i;
X    player *pl = Players[data];
X    player *dr = Players[draw];
X    
X    
X    XSetForeground(dr->disp, dr->gcr, dr->colors[WHITE].pixel);
X    
X    sprintf(string, "Time: %-5.2f	  Round: %d	  Last time: %-5.2f",
X	    pl->time/100.0, pl->round, pl->last_time/100.0);
X    XDrawString(dr->disp, dr->p_draw, dr->gc, 10, 30, string, strlen(string));	
X    
X    sprintf(string, "Best time: %-5.2f	     "
X	    "Best round: %-5.2f      Last lap: %-5.2f",
X	    pl->best_run/100.0, pl->best_lap/100.0, pl->last_lap_time/100.0);
X    XDrawString(dr->disp, dr->p_draw, dr->gc, 10, 50, string, strlen(string));	
X    
X    if (!(BIT(World.rules->mode, ONE_PLAYER_ONLY))) {
X	for (i=0;i < NumPlayers; i++) {
X	    pl_i = Players[i];
X	    if (((pl_i->best_lap < best_lap) || (best_lap == 0)) &&
X		(pl_i->best_lap != 0)) {
X		best_lap = pl_i->best_lap;
X		strcpy(lap_name, pl_i->name);
X	    }
X	    if (((pl_i->best_run < best_run) || (best_run == 0)) &&
X		(pl_i->best_run != 0)) {
X		best_run = pl_i->best_run;
X		strcpy(run_name, pl_i->name);
X	    }
X	}
X	sprintf(string,
X		"Best time by %s : %-5.2f    Best round by %s: %-5.2f",
X		run_name, best_run/100.0, lap_name, best_lap/100.0);
X	XDrawString(dr->disp, dr->p_draw, dr->gc, 10, 70, string, strlen(string));
X    }
X}
X
X
X
Xvoid Draw_world(int draw, int data)
X{
X    int xi, yi, xb, yb, i, offset;
X    double x, y;
X    static const int WS_PR_SC=1+(double)FULL/BLOCK_SZ;
X    static const int INSIDE_WS=BLOCK_SZ-2;
X    static int wormCount;
X    player *pl = Players[data];
X    player *dr = Players[draw];
X    
X    pl->wormDrawCount = (pl->wormDrawCount + 1) & 7;
X    
X    xb = (pl->world.x/BLOCK_SZ); LIMIT(xb, 0, World.x-1);
X    yb = (pl->world.y/BLOCK_SZ); LIMIT(yb, 0, World.y-1);
X
X    for (xi=xb; xi<=(WS_PR_SC+xb) && xi<World.x; xi++)
X	for (yi=yb; yi<=(WS_PR_SC+yb) && yi<World.y; yi++) {
X	    x = (xi*BLOCK_SZ); y=(yi*BLOCK_SZ);
X	    
X	    switch (World.block[xi][yi]) {
X		
X	    case FILLED:
X		XDrawRectangle(dr->disp, dr->p_draw, dr->gc,
X			       X(data, x), Y(data, y+BLOCK_SZ),
X			       BLOCK_SZ, BLOCK_SZ);
X		break;
X		
X	    case CHECK:
X		points[0].x = X(data, x+(BLOCK_SZ/2));
X		points[0].y = Y(data, y);
X		points[1].x = X(data, x);
X		points[1].y = Y(data, (y+BLOCK_SZ/2));
X		points[2].x = X(data, (x+BLOCK_SZ/2));
X		points[2].y = Y(data, (y+BLOCK_SZ));
X		points[3].x = X(data, x+BLOCK_SZ);
X		points[3].y = Y(data, y+(BLOCK_SZ/2));
X		points[4].x = X(data, x+(BLOCK_SZ/2));
X		points[4].y = Y(data, y);
X		
X		for(i=0; i<World.NumChecks; i++)
X		    if ((World.check[i].x == xi) && (World.check[i].y == yi)) {
X			if (i != pl->check) {
X			    XDrawLines(dr->disp, dr->p_draw, dr->gc,
X				       points, 5, 0); 
X			} else {
X			    XFillPolygon(dr->disp, dr->p_draw, dr->gc,
X					 points, 5, Convex, CoordModeOrigin);
X			}
X		    }
X		break;
X		
X	    case REC_LU:
X		points[0].x = X(data, x);
X		points[0].y = Y(data, y);
X		points[1].x = X(data, x);
X		points[1].y = Y(data, (y+BLOCK_SZ));
X		points[2].x = X(data, (x+BLOCK_SZ));
X		points[2].y = Y(data, (y+BLOCK_SZ));
X		points[3].x = X(data, x);
X		points[3].y = Y(data, y);
X		XDrawLines(dr->disp, dr->p_draw, dr->gc, points, 4, 0); 
X		break;
X		
X	    case REC_RU:
X		points[0].x = X(data, x);
X		points[0].y = Y(data, (y+BLOCK_SZ));
X		points[1].x = X(data, (x+BLOCK_SZ));
X		points[1].y = Y(data, (y+BLOCK_SZ));
X		points[2].x = X(data, (x+BLOCK_SZ));
X		points[2].y = Y(data, y);
X		points[3].x = X(data, x);
X		points[3].y = Y(data, (y+BLOCK_SZ));
X		XDrawLines(dr->disp, dr->p_draw, dr->gc, points, 4, 0); 
X		break;
X		
X	    case REC_LD:
X		points[0].x = X(data, x);
X		points[0].y = Y(data, y);
X		points[1].x = X(data, x);
X		points[1].y = Y(data, (y+BLOCK_SZ));
X		points[2].x = X(data, (x+BLOCK_SZ));
X		points[2].y = Y(data, y);
X		points[3].x = X(data, x);
X		points[3].y = Y(data, y);
X		XDrawLines(dr->disp, dr->p_draw, dr->gc, points, 4, 0); 
X		break;
X		
X	    case REC_RD:
X		points[0].x = X(data, x);
X		points[0].y = Y(data, y);
X		points[1].x = X(data, (x+BLOCK_SZ));
X		points[1].y = Y(data, (y+BLOCK_SZ));
X		points[2].x = X(data, (x+BLOCK_SZ));
X		points[2].y = Y(data, y);
X		points[3].x = X(data, x);
X		points[3].y = Y(data, y);
X		XDrawLines(dr->disp, dr->p_draw, dr->gc, points, 4, 0); 
X		break;
X		
X	    case FUEL:
X		for(i=0; i<World.NumFuels; i++) {
X		    if (((int) (World.fuel[i].pos.x/BLOCK_SZ) == xi) &&
X			((int) (World.fuel[i].pos.y/BLOCK_SZ) == yi)) {
X			XDrawRectangle(dr->disp, dr->p_draw, dr->gc,
X				       X(data, x), Y(data, y+BLOCK_SZ),
X				       BLOCK_SZ, BLOCK_SZ);
X			XSetForeground(dr->disp, dr->gc, dr->colors[RED].pixel);
X			offset = INSIDE_WS*World.fuel[i].left/MAX_STATION_FUEL;
X			XFillRectangle(dr->disp, dr->p_draw, dr->gc,
X				       X(data, x)+1,
X				       Y(data, y+BLOCK_SZ)
X				       + (INSIDE_WS-offset)+1,
X				       INSIDE_WS,
X				       offset);
X			XSetForeground(dr->disp, dr->gc,
X				       dr->colors[BLUE].pixel);
X		    }
X		}
X		break;
X		
X	    case ACWISE_GRAV:
X		XSetForeground(dr->disp, dr->gc, dr->colors[RED].pixel);
X		XDrawArc(dr->disp, dr->p_draw, dr->gc,
X			 X(data, x+5), Y(data, y+BLOCK_SZ-5),
X			 BLOCK_SZ-10, BLOCK_SZ-10, 64*150, 64*300);
X		XDrawLine(dr->disp, dr->p_draw, dr->gc,
X			  X(data, x+BLOCK_SZ/2),
X			  Y(data, y+BLOCK_SZ-5),
X			  X(data, x+BLOCK_SZ/2+4),
X			  Y(data, y+BLOCK_SZ-1));
X		XDrawLine(dr->disp, dr->p_draw, dr->gc,
X			  X(data, x+BLOCK_SZ/2),
X			  Y(data, y+BLOCK_SZ-5),
X			  X(data, x+BLOCK_SZ/2+4),
X			  Y(data, y+BLOCK_SZ-9));
X		XSetForeground(dr->disp, dr->gc, dr->colors[BLUE].pixel);
X		break;
X		
X	    case CWISE_GRAV:
X		XSetForeground(dr->disp, dr->gc, dr->colors[RED].pixel);
X		XDrawArc(dr->disp, dr->p_draw, dr->gc,
X			 X(data, x+5), Y(data, y+BLOCK_SZ-5),
X			 BLOCK_SZ-10, BLOCK_SZ-10, 64*90, 64*300);
X		XDrawLine(dr->disp, dr->p_draw, dr->gc,
X			  X(data, x+BLOCK_SZ/2),
X			  Y(data, y+BLOCK_SZ-5),
X			  X(data, x+BLOCK_SZ/2-4),
X			  Y(data, y+BLOCK_SZ-1));
X		XDrawLine(dr->disp, dr->p_draw, dr->gc,
X			  X(data, x+BLOCK_SZ/2),
X			  Y(data, y+BLOCK_SZ-5),
X			  X(data, x+BLOCK_SZ/2-4),
X			  Y(data, y+BLOCK_SZ-9));
X		XSetForeground(dr->disp, dr->gc, dr->colors[BLUE].pixel);
X		break;
X		
X	    case POS_GRAV:
X		XSetForeground(dr->disp, dr->gc, dr->colors[RED].pixel);
X		XDrawArc(dr->disp, dr->p_draw, dr->gc,
X			 X(data, x+1), Y(data, y+BLOCK_SZ-1),
X			 INSIDE_WS, INSIDE_WS, 0, 64*360);
X		XDrawLine(dr->disp, dr->p_draw, dr->gc,
X			  X(data, x+BLOCK_SZ/2),
X			  Y(data, y+5),
X			  X(data, x+BLOCK_SZ/2),
X			  Y(data, y+BLOCK_SZ-5));
X		XDrawLine(dr->disp, dr->p_draw, dr->gc,
X			  X(data, x+5),
X			  Y(data, y+BLOCK_SZ/2),
X			  X(data, x+BLOCK_SZ-5),
X			  Y(data, y+BLOCK_SZ/2));
X		XSetForeground(dr->disp, dr->gc, dr->colors[BLUE].pixel);
X		break;
X		
X	    case NEG_GRAV:
X		XSetForeground(dr->disp, dr->gc, dr->colors[RED].pixel);
X		XDrawArc(dr->disp, dr->p_draw, dr->gc,
X			 X(data, x+1), Y(data, y+BLOCK_SZ-1),
X			 INSIDE_WS, INSIDE_WS, 0, 64*360);
X		XDrawLine(dr->disp, dr->p_draw, dr->gc,
X			  X(data, x+5),
X			  Y(data, y+BLOCK_SZ/2),
X			  X(data, x+BLOCK_SZ-5),
X			  Y(data, y+BLOCK_SZ/2));
X		XSetForeground(dr->disp, dr->gc, dr->colors[BLUE].pixel);
X		break;
X		
X	    case WORMHOLE:
X	    {
X		static int wormOffset[8][3] =
X		{
X		    10, 10, 10,
X		    5, 10, 10,
X		    0, 10, 10,
X		    0, 5, 10,
X		    0, 0, 10,
X		    5, 0, 10,
X		    10, 0, 10,
X		    10, 5, 10,
X		};
X#define _O 	wormOffset[pl->wormDrawCount]
X#define ARC(_x, _y, _w)							       \
X		XDrawArc(dr->disp, dr->draw, dr->gc,			       \
X			 X(data, x+1) + (_x), Y(data, y+BLOCK_SZ-1) + (_y), \
X			 INSIDE_WS - (_w), INSIDE_WS - (_w), 0, 64*360)
X 
X		XSetForeground(dr->disp, dr->gc, dr->colors[RED].pixel);
X		ARC(0, 0, 0);
X		ARC(_O[0], _O[1], _O[2]);
X		ARC(_O[0] * 2, _O[1] * 2, _O[2] * 2);
X		XSetForeground(dr->disp, dr->gc, dr->colors[BLUE].pixel);
X		break;
X	    }
X
X	    case SPACE:
X		if (((xi%8)==0) && ((yi%8)==0))
X		    if (BIT(dr->disp_type, DT_HAVE_COLOR)) {
X			XDrawRectangle(dr->disp, dr->p_draw, dr->gc,
X				       X(data, xi*BLOCK_SZ+BLOCK_SZ/2),
X				       Y(data, yi*BLOCK_SZ+BLOCK_SZ/2),
X				       2, 2);
X		    } else {
X			XDrawPoint(dr->disp, dr->p_draw, dr->gc,
X				   X(data, xi*BLOCK_SZ+BLOCK_SZ/2),
X				   Y(data, yi*BLOCK_SZ+BLOCK_SZ/2));
X		    }
X
X		
X#ifdef DRAW_GRAV_VECTORS
X		XSetForeground(dr->disp, dr->gc, dr->colors[RED].pixel);
X		XDrawLine(dr->disp, dr->p_draw, dr->gc,
X			  X(data, x+BLOCK_SZ/2),
X			  Y(data, y+BLOCK_SZ/2),
X			  X(data, x+BLOCK_SZ/2+ 50*World.gravity[xi][yi].x),
X			  Y(data, y+BLOCK_SZ/2+ 50*World.gravity[xi][yi].y));
X		XSetForeground(dr->disp, dr->gc, dr->colors[WHITE].pixel);
X		XDrawPoint(dr->disp, dr->p_draw, dr->gc,
X			   X(data, x+BLOCK_SZ/2),
X			   Y(data, y+BLOCK_SZ/2));
X		XSetForeground(dr->disp, dr->gc, dr->colors[BLUE].pixel);
X#endif
X		break;
X		
X	    case BASE:
X		XSetForeground(dr->disp, dr->gc, dr->colors[WHITE].pixel);
X		XDrawLine(dr->disp, dr->p_draw, dr->gc,
X			  X(data, x), Y(data, y-1),
X			  X(data, x+BLOCK_SZ), Y(data, y-1));
X		XSetForeground(dr->disp, dr->gc, dr->colors[BLUE].pixel);
X		break;
X		
X	    default:
X		break;
X	    }
X	}
X}
X
X
X
Xvoid Draw_world_radar(int draw)
X{
X    int xi, yi;
X    double xs, ys;
X    player *dr = Players[draw];
X    
X    
X    xs = 256.0 / World.x;
X    ys = (double)RadarHeight / World.y;
X   
X    if (dr->s_radar == dr->radar) 
X	XSetPlaneMask(dr->disp, dr->gcr, 
X		      AllPlanes&(~(dr->dpl_1[0]|dr->dpl_1[1])));
X    else {
X	/* Clear radar */
X	XSetForeground(dr->disp, dr->gcr, dr->colors[BLACK].pixel);
X	XFillRectangle(dr->disp, dr->s_radar, dr->gcr, 0, 0, 256, RadarHeight);
X    }
X    XSetForeground(dr->disp, dr->gcr, dr->colors[BLUE].pixel);
X
X    for (xi=0; xi<World.x; xi++)
X	for (yi=0; yi<World.y; yi++)
X	    switch (World.block[xi][yi]) {
X	    case FILLED:
X	    case FILLED_NO_DRAW:
X	    case REC_LU:
X	    case REC_RU:
X	    case REC_LD:
X	    case REC_RD:
X	    case FUEL:
X		XDrawPoint(dr->disp, dr->s_radar, dr->gcr,
X			   (int)((xi*xs)+(0.5*xs)),
X			   (int)(RadarHeight-((yi*ys)+(0.5*ys))));
X		break;
X	    default:
X		break;
X	    }
X    
X    if (dr->s_radar == dr->radar)
X	XSetPlaneMask(dr->disp, dr->gcr, 
X		      AllPlanes&(~(dr->dpl_2[0]|dr->dpl_2[1])));
X}
END_OF_FILE
echo shar: 1 control character may be missing from \"'src/draw.c'\"
if test 35828 -ne `wc -c <'src/draw.c'`; then
    echo shar: \"'src/draw.c'\" unpacked with wrong size!
fi
# end of 'src/draw.c'
fi
if test -f 'src/lib/Makefile' -a "${1}" != "-c" ; then 
  echo shar: Will not clobber existing file \"'src/lib/Makefile'\"
else
echo shar: Extracting \"'src/lib/Makefile'\" \(10909 characters\)
sed "s/^X//" >'src/lib/Makefile' <<'END_OF_FILE'
X# Makefile generated by imake - do not edit!
X# $XConsortium: imake.c,v 1.65 91/07/25 17:50:17 rws Exp $
X#
X# The cpp used on this machine replaces all newlines and multiple tabs and
X# spaces in a macro expansion with a single space.  Imake tries to compensate
X# for this, but is not always successful.
X#
X
X# -------------------------------------------------------------------------
X# Makefile generated from "Imake.tmpl" and </tmp/IIf.a05164>
X# $XConsortium: Imake.tmpl,v 1.139 91/09/16 08:52:48 rws Exp $
X#
X# Platform-specific parameters may be set in the appropriate <vendor>.cf
X# configuration files.  Site-specific parameters should be set in the file
X# site.def.  Full rebuilds are recommended if any parameters are changed.
X#
X# If your C preprocessor does not define any unique symbols, you will need
X# to set BOOTSTRAPCFLAGS when rebuilding imake (usually when doing
X# "make World" the first time).
X#
X
X# 57
X
X# 64
X
X# 71
X
X# 85
X
X# 92
X
X# 114
X
X# 121
X
X# 128
X
X# 136
X
X# 143
X
X# 152
X
X# 159
X
X# 184
X
X# 197
X
X# 208
X
X# 220
X
X# 230
X
X# 237
X
X# 246
X
X# 253
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that need to come before
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# 41
X
X# -------------------------------------------------------------------------
X# platform-specific configuration parameters - edit hp.cf to change
X
X# platform:  $XConsortium: hp.cf,v 1.48 91/12/18 09:43:08 rws Exp $
X
X# 25
X
X# $$
X
X# 27
X
X# 38
X
X# 283
X
X# 294
X
X# -------------------------------------------------------------------------
X# site-specific configuration parameters that go after
X# the platform-specific parameters - edit site.def to change
X
X# site:  $XConsortium: site.def,v 1.2 91/07/30 20:26:44 rws Exp $
X
X# 30
X
X# 37
X
X# 312
X
X# 315
X
X# 321
X
X# 324
X
X# 334
X
X# 344
X
X# 356
X
X# 362
X
X# 366
X
X# 378
X
X# 381
X
X# 390
X
X# 423
X
X# 428
X
X# 440
X
X# 445
X
X# 451
X
X# 463
X
X# 491
X
X# 504
X
X# 537
X
X# 540
X
X# 553
X
X# 560
X
X# 571
X
X# 577
X
X# 583
X
X# 606
X
X# 613
X
X# 619
X
X# 628
X
X# 638
X
X# 669
X
X# 672
X
X# 675
X
X            SHELL = /bin/sh
X
X              TOP = ../.
X      CURRENT_DIR = ./lib
X
X               AR = ar clq
X  BOOTSTRAPCFLAGS =
X               CC = cc
X               AS = as
X
X               FC = f77
X      FDEBUGFLAGS =
X          FCFLAGS =  $(FDEBUGFLAGS)
X
X         COMPRESS = compress
X              CPP = /lib/cpp $(STD_CPP_DEFINES)
X    PREPROCESSCMD = cc -E $(STD_CPP_DEFINES)
X          INSTALL = $(BINDIR)/bsdinst
X               LD = ld
X             LINT = lint
X      LINTLIBFLAG = -o
X         LINTOPTS = -ax
X               LN = ln -s
X             MAKE = make
X               MV = mv -f
X               CP = cp
X# 712
X
X               RM = rm -f
X            TROFF = psroff
X         MSMACROS = -ms
X              TBL = tbl
X              EQN = eqn
X     STD_INCLUDES =
X  STD_CPP_DEFINES = -DSYSV
X      STD_DEFINES = -DSYSV
X EXTRA_LOAD_FLAGS =
X  EXTRA_LIBRARIES =
X             TAGS = ctags
X
X           MFLAGS = -$(MAKEFLAGS)
X
X    SHAREDCODEDEF = -DSHAREDCODE
X         SHLIBDEF =
X
X# 733
X
X# 739
X
X# 742
X
X# 745
X
X# 748
X
X# 751
X
X# 754
X
X# 757
X
X# 770
X
X    PROTO_DEFINES =
X
X# 777
X
X     INSTPGMFLAGS =
X
X     INSTBINFLAGS = -m 0755
X     INSTUIDFLAGS = -m 4755
X     INSTLIBFLAGS = -m 0755
X     INSTINCFLAGS = -m 0444
X     INSTMANFLAGS = -m 0444
X     INSTDATFLAGS = -m 0444
X    INSTKMEMFLAGS = -m 4755
X
X      PROJECTROOT = /usr/local
X
X     TOP_INCLUDES = -I$(INCROOT)
X
X# 797
X
X      CDEBUGFLAGS = +O2
X        CCOPTIONS = -Wp,-H200000
X
X      ALLINCLUDES = $(INCLUDES) $(EXTRA_INCLUDES) $(TOP_INCLUDES) $(STD_INCLUDES)
X       ALLDEFINES = $(ALLINCLUDES) $(STD_DEFINES) $(EXTRA_DEFINES) $(PROTO_DEFINES) $(DEFINES)
X           CFLAGS = $(CDEBUGFLAGS) $(CCOPTIONS) $(ALLDEFINES)
X        LINTFLAGS = $(LINTOPTS) -DLINT $(ALLDEFINES)
X# 813
X
X           LDLIBS = $(SYS_LIBRARIES) $(EXTRA_LIBRARIES)
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X# 820
X
X   LDCOMBINEFLAGS = -X -r
X      DEPENDFLAGS =
X
X        MACROFILE = hp.cf
X           RM_CMD = $(RM) *.CKP *.ln *.BAK *.bak *.o core errs ,* *~ *.a .emacs_* tags TAGS make.log MakeOut
X
X    IMAKE_DEFINES =
X
X         IRULESRC = $(CONFIGDIR)
X        IMAKE_CMD = $(IMAKE) -DUseInstalled -I$(IRULESRC) $(IMAKE_DEFINES)
X# 834
X
X     ICONFIGFILES = $(IRULESRC)/Imake.tmpl $(IRULESRC)/Imake.rules \
X			$(IRULESRC)/Project.tmpl $(IRULESRC)/site.def \
X			$(IRULESRC)/$(MACROFILE) $(EXTRA_ICONFIGFILES)
X
X# -------------------------------------------------------------------------
X# X Window System Build Parameters
X# $XConsortium: Project.tmpl,v 1.138 91/09/10 09:02:12 rws Exp $
X
X# 21
X
X# 37
X
X# 62
X
X# 138
X
X# 169
X
X# 180
X
X# 197
X
X# 206
X
X# 211
X
X# 238
X
X# 241
X
X# 253
X
X# 261
X
X# 273
X
X# 332
X
X# 363
X
X# 375
X
X# 385
X
X# 388
X
X# 391
X
X# 394
X
X# 397
X
X# 400
X
X# 403
X
X# 406
X
X# 409
X
X# 412
X
X# 418
X
X# 424
X
X# 427
X
X# 430
X
X# 433
X
X# 436
X
X# 442
X
X# -------------------------------------------------------------------------
X# X Window System make variables; this need to be coordinated with rules
X
X          PATHSEP = /
X        USRLIBDIR = /usr/local/lib
X           BINDIR = /usr/local/bin
X          INCROOT = /usr/local/include
X     BUILDINCROOT = $(TOP)
X      BUILDINCDIR = $(BUILDINCROOT)/X11
X      BUILDINCTOP = ..
X           INCDIR = $(INCROOT)/X11
X           ADMDIR = /usr/adm
X           LIBDIR = $(USRLIBDIR)/X11
X        CONFIGDIR = $(LIBDIR)/config
X       LINTLIBDIR = $(USRLIBDIR)/lint
X
X          FONTDIR = $(LIBDIR)/fonts
X         XINITDIR = $(LIBDIR)/xinit
X           XDMDIR = $(LIBDIR)/xdm
X           TWMDIR = $(LIBDIR)/twm
X          MANPATH = /usr/local/man
X    MANSOURCEPATH = $(MANPATH)/man
X        MANSUFFIX = 1
X     LIBMANSUFFIX = 3
X           MANDIR = $(MANSOURCEPATH)$(MANSUFFIX)
X        LIBMANDIR = $(MANSOURCEPATH)$(LIBMANSUFFIX)
X           NLSDIR = $(LIBDIR)/nls
X        PEXAPIDIR = $(LIBDIR)/PEX
X      XAPPLOADDIR = $(LIBDIR)/app-defaults
X       FONTCFLAGS = -t
X
X     INSTAPPFLAGS = $(INSTDATFLAGS)
X
X            IMAKE = imake
X           DEPEND = makedepend
X              RGB = rgb
X# 492
X
X            FONTC = bdftopcf
X
X        MKFONTDIR = mkfontdir
X        MKDIRHIER = /bin/sh $(BINDIR)/mkdirhier
X# 508
X
X        CONFIGSRC = $(TOP)/config
X       DOCUTILSRC = $(TOP)/doc/util
X        CLIENTSRC = $(TOP)/clients
X          DEMOSRC = $(TOP)/demos
X           LIBSRC = $(TOP)/lib
X          FONTSRC = $(TOP)/fonts
X       INCLUDESRC = $(TOP)/X11
X        SERVERSRC = $(TOP)/server
X          UTILSRC = $(TOP)/util
X        SCRIPTSRC = $(UTILSRC)/scripts
X       EXAMPLESRC = $(TOP)/examples
X       CONTRIBSRC = $(TOP)/../contrib
X           DOCSRC = $(TOP)/doc
X           RGBSRC = $(TOP)/rgb
X        DEPENDSRC = $(UTILSRC)/makedepend
X         IMAKESRC = $(CONFIGSRC)
X         XAUTHSRC = $(LIBSRC)/Xau
X          XLIBSRC = $(LIBSRC)/X
X           XMUSRC = $(LIBSRC)/Xmu
X       TOOLKITSRC = $(LIBSRC)/Xt
X       AWIDGETSRC = $(LIBSRC)/Xaw
X       OLDXLIBSRC = $(LIBSRC)/oldX
X      XDMCPLIBSRC = $(LIBSRC)/Xdmcp
X      BDFTOSNFSRC = $(FONTSRC)/bdftosnf
X      BDFTOSNFSRC = $(FONTSRC)/clients/bdftosnf
X      BDFTOPCFSRC = $(FONTSRC)/clients/bdftopcf
X     MKFONTDIRSRC = $(FONTSRC)/clients/mkfontdir
X         FSLIBSRC = $(FONTSRC)/lib/fs
X    FONTSERVERSRC = $(FONTSRC)/server
X     EXTENSIONSRC = $(TOP)/extensions
X         XILIBSRC = $(EXTENSIONSRC)/lib/xinput
X      PHIGSLIBSRC = $(EXTENSIONSRC)/lib/PEX
X
X# 551
X
X# 565
X
X# 570
X
X# 577
X
X# $$
X
XSHLIBLDFLAGS = -b
XPICFLAGS = +Z
X
X  DEPEXTENSIONLIB =
X     EXTENSIONLIB = -lXext
X
X          DEPXLIB = $(DEPEXTENSIONLIB)
X             XLIB = $(EXTENSIONLIB) -lX11
X
X        DEPXMULIB = $(USRLIBDIR)/libXmu.sl
X           XMULIB = -lXmu
X
X       DEPOLDXLIB =
X          OLDXLIB = -loldX
X
X      DEPXTOOLLIB = $(USRLIBDIR)/libXt.sl
X         XTOOLLIB = -lXt
X
X        DEPXAWLIB = $(USRLIBDIR)/libXaw.sl
X           XAWLIB = -lXaw
X
X        DEPXILIB =
X           XILIB = -lXi
X
X        LDOPTIONS = $(CDEBUGFLAGS) $(CCOPTIONS) $(LOCAL_LDFLAGS) -L$(USRLIBDIR)
X# 47
X
X        SOXLIBREV = SharedXlibRev
X          SOXTREV = SharedXtRev
X         SOXAWREV = SharedXawRev
X        SOOLDXREV = SharedOldXRev
X         SOXMUREV = SharedXmuRev
X        SOXEXTREV = SharedXextRev
X      SOXINPUTREV = SharedXinputRev
X
X# 594
X
X# 598
X
X      DEPXAUTHLIB = $(USRLIBDIR)/libXau.a
X         XAUTHLIB =  -lXau
X      DEPXDMCPLIB = $(USRLIBDIR)/libXdmcp.a
X         XDMCPLIB =  -lXdmcp
X# 606
X
X# 610
X
X# 614
X
X# 618
X
X# 622
X
X        DEPPHIGSLIB = $(USRLIBDIR)/libphigs.a
X           PHIGSLIB =  -lphigs
X
X       DEPXBSDLIB = $(USRLIBDIR)/libXbsd.a
X          XBSDLIB =  -lXbsd
X
X LINTEXTENSIONLIB = $(LINTLIBDIR)/llib-lXext.ln
X         LINTXLIB = $(LINTLIBDIR)/llib-lX11.ln
X          LINTXMU = $(LINTLIBDIR)/llib-lXmu.ln
X        LINTXTOOL = $(LINTLIBDIR)/llib-lXt.ln
X          LINTXAW = $(LINTLIBDIR)/llib-lXaw.ln
X           LINTXI = $(LINTLIBDIR)/llib-lXi.ln
X        LINTPHIGS = $(LINTLIBDIR)/llib-lphigs.ln
X
X          DEPLIBS = $(DEPXAWLIB) $(DEPXMULIB) $(DEPXTOOLLIB) $(DEPXLIB)
X# 657
X
X         DEPLIBS1 = $(DEPLIBS)
X         DEPLIBS2 = $(DEPLIBS)
X         DEPLIBS3 = $(DEPLIBS)
X
X# -------------------------------------------------------------------------
X# Imake rules for building libraries, programs, scripts, and data files
X# rules:  $XConsortium: Imake.rules,v 1.123 91/09/16 20:12:16 rws Exp $
X
X# 162
X
X# 173
X
X# 353
X
X# 600
X
X# 615
X
X# 637
X
X# 708
X
X# 1341
X
X# 1442
X
X# 1465
X
X# 1484
X
X# 1499
X
X# -------------------------------------------------------------------------
X# start of Imakefile
X
X# @(#)Imakefile 23/01/92
X# Imakefile - socklib
X
XOBJS = socklib.o
XSRCS = socklib.c
X
X#
X# Make socklib
X#
X
Xall:: libsocklib.a
X
Xlibsocklib.a:  $(OBJS)
X	$(RM) $@
X	$(AR) $@  $(OBJS)
X
Xdepend::
X	$(DEPEND) $(DEPENDFLAGS) -s "# DO NOT DELETE" -- $(ALLDEFINES) -- $(SRCS)
X
X# -------------------------------------------------------------------------
X# common rules for all Makefiles - do not edit
X
Xemptyrule::
X
Xclean::
X	$(RM_CMD) "#"*
X
XMakefile::
X	-@if [ -f Makefile ]; then set -x; \
X	$(RM) Makefile.bak; $(MV) Makefile Makefile.bak; \
X	else exit 0; fi
X	$(IMAKE_CMD) -DTOPDIR=$(TOP) -DCURDIR=$(CURRENT_DIR)
X
Xtags::
X	$(TAGS) -w *.[ch]
X	$(TAGS) -xw *.[ch] > TAGS
X# 868
X
X# 876
X
X# 890
X
X# -------------------------------------------------------------------------
X# empty rules for directories that do not have SUBDIRS - do not edit
X
Xinstall::
X	@echo "install in $(CURRENT_DIR) done"
X
Xinstall.man::
X	@echo "install.man in $(CURRENT_DIR) done"
X
XMakefiles::
X
Xincludes::
X
X# -------------------------------------------------------------------------
X# dependencies generated by makedepend
X
X# DO NOT DELETE
X
Xsocklib.o: socklib.h /usr/include/sys/types.h /usr/include/sys/stdsyms.h
Xsocklib.o: /usr/include/sys/time.h /usr/include/sys/socket.h
Xsocklib.o: /usr/include/sys/ioctl.h /usr/include/netinet/in.h
Xsocklib.o: /usr/include/arpa/inet.h /usr/include/stdio.h /usr/include/netdb.h
Xsocklib.o: /usr/include/signal.h /usr/include/sys/signal.h
Xsocklib.o: /usr/include/sys/syscall.h /usr/include/setjmp.h
Xsocklib.o: /usr/include/errno.h /usr/include/sys/errno.h
END_OF_FILE
if test 10909 -ne `wc -c <'src/lib/Makefile'`; then
    echo shar: \"'src/lib/Makefile'\" unpacked with wrong size!
fi
# end of 'src/lib/Makefile'
fi
echo shar: End of archive 16 \(of 24\).
cp /dev/null ark16isdone
MISSING=""
for I in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ; do
    if test ! -f ark${I}isdone ; then
	MISSING="${MISSING} ${I}"
    fi
done
if test "${MISSING}" = "" ; then
    echo You have unpacked all 24 archives.
    echo "\nNow run 'bldmaps.sh' to build the map files"
    rm -f ark[1-9]isdone ark[1-9][0-9]isdone
else
    echo You still need to unpack the following archives:
    echo "        " ${MISSING}
fi
##  End of shell archive.
exit 0
